
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/XuYueming/p/18919143" title="发布于 2025-06-08 10:26">
    <span role="heading" aria-level="2">给定 (u,v)，如何 O(1) 求 lca(u,v) 的孩子 u',v'，且分别为 u,v 的祖先或本身</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="问题描述">问题描述</h2>
<p>一棵树，<span class="math inline">\(q\)</span> 次询问给定 <span class="math inline">\(u,v\)</span>，保证 <span class="math inline">\(u,v\)</span> 不为祖孙关系。设 <span class="math inline">\(p=\operatorname{lca}(u,v)\)</span>，求 <span class="math inline">\(p\)</span> 的一个孩子 <span class="math inline">\(u'\)</span> 且 <span class="math inline">\(u'\)</span> 为 <span class="math inline">\(u\)</span> 的祖先或 <span class="math inline">\(u\)</span> 本身，类似需要求 <span class="math inline">\(v'\)</span>。</p>
<h2 id="朴素解法">朴素解法</h2>
<p>倍增可以做到 <span class="math inline">\(\mathcal{O}(\log n)\)</span>，但太慢了。</p>
<h2 id="优化解法">优化解法</h2>
<p>不妨令 <span class="math inline">\(\mathrm{idx}(u)&lt;\mathrm{idx}(v)\)</span>，考虑到 DFS 序求 <span class="math inline">\(p=\operatorname{lca}(u,v)\)</span> 最后一步跳父亲前，如果 ST 表对于相同深度的点，选取 <span class="math inline">\(\operatorname{idx}\)</span> 大的，就是求出了 <span class="math inline">\(v'\)</span>，得到了 <span class="math inline">\(p\)</span> 后，通过求 <span class="math inline">\(\operatorname{lca}(u,p)\)</span> 最后一步不要跳父亲，就能得到 <span class="math inline">\(u'\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(\mathcal{O}(1)\)</span>。</p>
<h2 id="代码实现">代码实现</h2>
<details codes="" open="">
<summary>优化解法</summary>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;tuple&gt;
#include &lt;cassert&gt;
using namespace std;

const int N = 5e5 + 10;
const int lgN = __lg(N) + 1;

int n, q, rt;
vector&lt;int&gt; e[N];

int st[lgN][N], idx[N], dpt[N], fa[N], timer, R[N];

void dfs(int u) {
    st[0][idx[u] = ++timer] = u;
    for (int v : e[u]) {
        if (v == fa[u]) continue;
        fa[v] = u;
        dpt[v] = dpt[u] + 1;
        dfs(v);
    }
    R[u] = timer;
}
inline int Min(int u, int v) {
    return dpt[u] &lt; dpt[v] ? u : v;
}
inline tuple&lt;int, int, int&gt; lca(int u, int v) {
    if (u == v) return { 0, 0, u };
    int U, V, p, iu = idx[u], iv = idx[v];
    bool F = false;
    if (iu &gt; iv) swap(iu, iv), swap(u, v), F = true;
    int k = __lg(iv - iu);
    V = Min(st[k][iu + 1], st[k][iv - (1 &lt;&lt; k) + 1]);
    p = fa[V];
    if (p == u) U = 0;
    else {
        int ip = idx[p];
        k = __lg(iu - ip++);
        U = Min(st[k][ip], st[k][iu - (1 &lt;&lt; k) + 1]);
    }
    if (F) swap(U, V);
    return { U, V, p };
}

signed main() {
    scanf("%d%d%d", &amp;n, &amp;q, &amp;rt);
    for (int i = 1, u, v; i &lt; n; ++i) {
        scanf("%d%d", &amp;u, &amp;v);
        e[u].emplace_back(v);
        e[v].emplace_back(u);
    }
    dfs(rt);
    for (int k = 1; k &lt; lgN; ++k)
        for (int i = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; ++i)
            st[k][i] = Min(st[k - 1][i], st[k - 1][i + (1 &lt;&lt; (k - 1))]);
    for (int u, v; q--; ) {
        scanf("%d%d", &amp;u, &amp;v);
        auto [U, V, p] = lca(u, v);
        printf("%d\n", p);
        fprintf(stderr, "u' = %d, v' = %d\n", U, V);
        assert(!U || (idx[U] &lt;= idx[u] &amp;&amp; idx[u] &lt;= R[U]));
        assert(!V || (idx[V] &lt;= idx[v] &amp;&amp; idx[v] &lt;= R[V]));
    }
    return 0;
}
</code></pre>
</details>
<details codes="">
<summary>朴素倍增</summary>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;tuple&gt;
#include &lt;cassert&gt;
using namespace std;

const int N = 5e5 + 10;
const int lgN = __lg(N) + 1;

int n, q, rt;
vector&lt;int&gt; e[N];

int idx[N], dpt[N], fa[lgN][N], timer, R[N];

void dfs(int u) {
    idx[u] = ++timer;
    for (int v : e[u]) {
        if (v == fa[0][u]) continue;
        fa[0][v] = u;
        dpt[v] = dpt[u] + 1;
        dfs(v);
    }
    R[u] = timer;
}

inline tuple&lt;int, int, int&gt; lca(int u, int v) {
    if (u == v) return { 0, 0, u };
    bool F = false;
    int p, U, V;
    if (dpt[u] &lt; dpt[v]) swap(u, v), F = true;
    for (int i = lgN - 1; ~i; --i)
        if (fa[i][u] &amp;&amp; dpt[fa[i][u]] &gt; dpt[v])
            u = fa[i][u];
    if (fa[0][u] == v) {
        U = u, V = 0, p = v;
    } else {
        if (dpt[u] != dpt[v])
            u = fa[0][u];
        for (int i = lgN - 1; ~i; --i)
            if (fa[i][u] != fa[i][v])
                u = fa[i][u], v = fa[i][v];
        U = u, V = v, p = fa[0][u];
    }
    if (F) swap(U, V);
    return { U, V, p };
}

signed main() {
    scanf("%d%d%d", &amp;n, &amp;q, &amp;rt);
    for (int i = 1, u, v; i &lt; n; ++i) {
        scanf("%d%d", &amp;u, &amp;v);
        e[u].emplace_back(v);
        e[v].emplace_back(u);
    }
    dfs(rt);
    for (int k = 1; k &lt; lgN; ++k)
        for (int i = 1; i &lt;= n; ++i)
            fa[k][i] = fa[k - 1][fa[k - 1][i]];
    for (int u, v; q--; ) {
        scanf("%d%d", &amp;u, &amp;v);
        auto [U, V, p] = lca(u, v);
        printf("%d\n", p);
        fprintf(stderr, "u' = %d, v' = %d\n", U, V);
        assert(!U || (idx[U] &lt;= idx[u] &amp;&amp; idx[u] &lt;= R[U]));
        assert(!V || (idx[V] &lt;= idx[v] &amp;&amp; idx[v] &lt;= R[V]));
    }
    return 0;
}
</code></pre>
</details>
<h2 id="算法比较">算法比较</h2>
<p>不妨用<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener nofollow">这题</a>来比较。朴素倍增会<a href="https://www.luogu.com.cn/record/219873690" target="_blank" rel="noopener nofollow">超时</a>，优化解法<a href="https://www.luogu.com.cn/record/219866023" target="_blank" rel="noopener nofollow">总耗时 <span class="math inline">\(4.30\mathrm{s}\)</span></a>。使用链式前向星存图，注释 <code>fprintf</code> 后，朴素倍增<a href="https://www.luogu.com.cn/record/219875771" target="_blank" rel="noopener nofollow">总耗时 <span class="math inline">\(2.73\mathrm{s}\)</span></a>，优化解法<a href="https://www.luogu.com.cn/record/219878286" target="_blank" rel="noopener nofollow">总耗时 <span class="math inline">\(1.36\mathrm{s}\)</span></a>。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>
  本文作者：<a href="https://www.cnblogs.com/XuYueming/" target="_blank">XuYueming</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/XuYueming/p/18919143" target="_blank">https://www.cnblogs.com/XuYueming/p/18919143</a>。
</p>

<p>
  若未作特殊说明，本作品采用
  <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="license">
    知识共享署名-非商业性使用 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005983106523148148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-08 11:13">2025-06-08 10:26</span>&nbsp;
<a href="https://www.cnblogs.com/XuYueming">XuYueming</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18919143);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18919143', targetLink: 'https://www.cnblogs.com/XuYueming/p/18919143', title: '给定 (u,v)，如何 O(1) 求 lca(u,v) 的孩子 u&amp;#39;,v&amp;#39;，且分别为 u,v 的祖先或本身' })">举报</a>
</div>
        