
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wherewhere/p/18446824" title="发布于 2025-01-17 16:06">
    <span role="heading" aria-level="2">【UWP】让 UWP 自己托管自己 —— Windows SDK 篇</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        众所周知，UWP 使用的窗口模型是 CoreWindow，但是 UWP 本身只是一个应用模型，所以完全可以创建 win32 窗口，那么我们可以不可以创建一个 win32 窗口，然后像 XAML 岛 (XAML Islands) 一样把 XAML 托管上去呢？本篇将讲述如何在 UWP 创建一个 XAML 岛窗口。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>众所周知，UWP 使用的窗口模型是 CoreWindow，但是 UWP 本身只是一个应用模型，所以完全可以创建 win32 窗口，那么我们可以不可以创建一个 win32 窗口，然后像 XAML 岛 (XAML Islands) 一样把 XAML 托管上去呢？本篇将讲述如何在 UWP 创建一个 XAML 岛窗口。</p>
<p><img src="https://img2024.cnblogs.com/blog/2662465/202410/2662465-20241018154958316-63773942.png" alt="示例" height="1824" width="2736"></p>
<p>首先，XAML 岛会判断当前的应用模型是否为<code>ClassicDesktop</code>，所以我们需要利用<code>Detours</code>劫持<code>AppPolicyGetWindowingModel</code>方法。具体内容如下：</p>
<pre class="language-csharp highlighter-hljs"><code>#r "nuget:Detours.Win32Metadata"
#r "nuget:Microsoft.Windows.CsWin32"

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.Storage.Packaging.Appx;
using Detours = Microsoft.Detours.PInvoke;

/// &lt;summary&gt;
/// Represents a hook for the &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function.
/// &lt;/summary&gt;
public sealed partial class HookWindowingModel : IDisposable
{
    /// &lt;summary&gt;
    /// The value that indicates whether the class has been disposed.
    /// &lt;/summary&gt;
    private bool disposed;

    /// &lt;summary&gt;
    /// The reference count for the hook.
    /// &lt;/summary&gt;
    private static int refCount;

    /// &lt;summary&gt;
    /// The value that represents the current process token.
    /// &lt;/summary&gt;
    private const int currentProcessToken = -6;

    /// &lt;remarks&gt;The original &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function.&lt;/remarks&gt;
    /// &lt;inheritdoc cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt;
    private static unsafe delegate* unmanaged[Stdcall]&lt;HANDLE, AppPolicyWindowingModel*, WIN32_ERROR&gt; AppPolicyGetWindowingModel;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="HookWindowingModel"/&gt; class.
    /// &lt;/summary&gt;
    public HookWindowingModel()
    {
        refCount++;
        StartHook();
    }

    /// &lt;summary&gt;
    /// Finalizes this instance of the &lt;see cref="HookWindowingModel"/&gt; class.
    /// &lt;/summary&gt;
    ~HookWindowingModel()
    {
        Dispose();
    }

    /// &lt;summary&gt;
    /// Gets the value that indicates whether the hook is active.
    /// &lt;/summary&gt;
    public static bool IsHooked { get; private set; }

    /// &lt;summary&gt;
    /// Gets or sets the windowing model to use when the hooked &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function is called.
    /// &lt;/summary&gt;
    internal static AppPolicyWindowingModel WindowingModel { get; set; } = AppPolicyWindowingModel.AppPolicyWindowingModel_ClassicDesktop;

    /// &lt;summary&gt;
    /// Starts the hook for the &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function.
    /// &lt;/summary&gt;
    private static unsafe void StartHook()
    {
        if (!IsHooked)
        {
            using FreeLibrarySafeHandle library = PInvoke.GetModuleHandle("KERNEL32.dll");
            if (!library.IsInvalid &amp;&amp; NativeLibrary.TryGetExport(library.DangerousGetHandle(), nameof(PInvoke.AppPolicyGetWindowingModel), out nint appPolicyGetWindowingModel))
            {
                void* appPolicyGetWindowingModelPtr = (void*)appPolicyGetWindowingModel;
                delegate* unmanaged[Stdcall]&lt;HANDLE, AppPolicyWindowingModel*, WIN32_ERROR&gt; overrideAppPolicyGetWindowingModel = &amp;OverrideAppPolicyGetWindowingModel;

                _ = Detours.DetourRestoreAfterWith();

                _ = Detours.DetourTransactionBegin();
                _ = Detours.DetourUpdateThread(PInvoke.GetCurrentThread());
                _ = Detours.DetourAttach(ref appPolicyGetWindowingModelPtr, overrideAppPolicyGetWindowingModel);
                _ = Detours.DetourTransactionCommit();

                AppPolicyGetWindowingModel = (delegate* unmanaged[Stdcall]&lt;HANDLE, AppPolicyWindowingModel*, WIN32_ERROR&gt;)appPolicyGetWindowingModelPtr;
                IsHooked = true;
            }
        }
    }

    /// &lt;summary&gt;
    /// Ends the hook for the &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function.
    /// &lt;/summary&gt;
    private static unsafe void EndHook()
    {
        if (--refCount == 0 &amp;&amp; IsHooked)
        {
            void* appPolicyGetWindowingModelPtr = AppPolicyGetWindowingModel;
            delegate* unmanaged[Stdcall]&lt;HANDLE, AppPolicyWindowingModel*, WIN32_ERROR&gt; overrideAppPolicyGetWindowingModel = &amp;OverrideAppPolicyGetWindowingModel;

            _ = Detours.DetourTransactionBegin();
            _ = Detours.DetourUpdateThread(PInvoke.GetCurrentThread());
            _ = Detours.DetourDetach(&amp;appPolicyGetWindowingModelPtr, overrideAppPolicyGetWindowingModel);
            _ = Detours.DetourTransactionCommit();

            AppPolicyGetWindowingModel = null;
            IsHooked = false;
        }
    }

    /// &lt;param name="policy"&gt;A pointer to a variable of the &lt;a href="https://docs.microsoft.com/windows/win32/api/appmodel/ne-appmodel-apppolicywindowingmodel"&gt;AppPolicyWindowingModel&lt;/a&gt; enumerated type.
    /// When the function returns successfully, the variable contains the &lt;see cref="WindowingModel"/&gt; when the identified process is current; otherwise, the windowing model of the identified process.&lt;/param&gt;
    /// &lt;remarks&gt;The overridden &lt;see cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt; function.&lt;/remarks&gt;
    /// &lt;inheritdoc cref="PInvoke.AppPolicyGetWindowingModel(HANDLE, AppPolicyWindowingModel*)"/&gt;
    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe WIN32_ERROR OverrideAppPolicyGetWindowingModel(HANDLE processToken, AppPolicyWindowingModel* policy)
    {
        if ((int)processToken.Value == currentProcessToken)
        {
            *policy = WindowingModel;
            return WIN32_ERROR.ERROR_SUCCESS;
        }
        return AppPolicyGetWindowingModel(processToken, policy);
    }

    /// &lt;inheritdoc/&gt;
    public void Dispose()
    {
        if (!disposed &amp;&amp; IsHooked)
        {
            EndHook();
        }
        GC.SuppressFinalize(this);
        disposed = true;
    }
}</code></pre>
<p>准备工作完成，接下来我们就可以创建窗口了，首先我们需要新创建一个线程，CoreWindow 线程无法新建 XAML 岛，新建线程只需要用<code>Thread</code>就行了。</p>
<pre class="language-csharp highlighter-hljs"><code>new Thread(() =&gt; { ... });</code></pre>
<p>首先我们需要创建 XAML 岛，这时我们就需要利用上面劫持器来劫持获取应用模型的方法了。</p>
<pre class="language-csharp highlighter-hljs"><code>DesktopWindowXamlSource source;
using (HookWindowingModel hook = new())
{
    source = new DesktopWindowXamlSource();
}</code></pre>
<p>微软并没有单独提供一个 Win32 窗口管理的轮子，如果引用 Windows Forms 就太臃肿了，于是我们需要手动制作一个 Window 类：</p>
<pre class="language-csharp highlighter-hljs"><code>/// &lt;summary&gt;
/// Represents a system-managed container for the content of an app.
/// &lt;/summary&gt;
public partial class DesktopWindow
{
    private bool m_bIsClosed = false;
    private DesktopWindowXamlSource m_source;
    private IDesktopWindowXamlSourceNative m_native;

    private readonly HWND m_hwnd;
    private readonly WNDCLASSEXW m_wndClassEx;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="DesktopWindow"/&gt; class.
    /// &lt;/summary&gt;
    public DesktopWindow()
    {
        m_wndClassEx = RegisterDesktopWindowClass(WNDPROC);
        m_hwnd = CreateDesktopWindow();
    }

    /// &lt;summary&gt;
    /// Gets the event dispatcher for the window.
    /// &lt;/summary&gt;
    public CoreDispatcher Dispatcher { get; private set; }

    /// &lt;summary&gt;
    /// Gets the &lt;see cref="DesktopWindowXamlSource"/&gt; to provide XAML for this window.
    /// &lt;/summary&gt;
    public DesktopWindowXamlSource WindowXamlSource
    {
        get =&gt; m_source;
        private init
        {
            if (m_source != value)
            {
                m_source = value;
                if (value != null)
                {
                    Dispatcher = CoreWindow.GetForCurrentThread().Dispatcher;
                    m_native = value.As&lt;IDesktopWindowXamlSourceNative&gt;();
                    m_native.AttachToWindow(m_hwnd);
                    ResizeWindowToDesktopWindowXamlSourceWindowDimensions();
                }
                else
                {
                    m_native = null;
                }
            }
        }
    }

    /// &lt;summary&gt;
    /// Shows the window and activates it.
    /// &lt;/summary&gt;
    public void Show() =&gt; _ = PInvoke.ShowWindow(m_hwnd, SHOW_WINDOW_CMD.SW_NORMAL);

    private LRESULT WNDPROC(HWND hWnd, uint message, WPARAM wParam, LPARAM lParam)
    {
        switch (message)
        {
            case PInvoke.WM_PAINT:
                HDC hdc = PInvoke.BeginPaint(hWnd, out PAINTSTRUCT ps);
                _ = PInvoke.GetClientRect(hWnd, out RECT rect);
                _ = PInvoke.FillRect(hdc, rect, new DefaultSafeHandle(PInvoke.GetStockObject(GET_STOCK_OBJECT_FLAGS.WHITE_BRUSH)));
                _ = PInvoke.EndPaint(hWnd, ps);
                return new LRESULT();
            case PInvoke.WM_CLOSE when m_bIsClosed:
                goto default;
            case PInvoke.WM_CLOSE:
                m_bIsClosed = true;
                goto default;
            case PInvoke.WM_SIZE:
                ResizeWindowToDesktopWindowXamlSourceWindowDimensions();
                return new LRESULT();
            case PInvoke.WM_CREATE:
                return new LRESULT();
            case PInvoke.WM_DESTROY:
                PInvoke.PostQuitMessage(0);
                return new LRESULT();
            default:
                return PInvoke.DefWindowProc(hWnd, message, wParam, lParam);
        }
    }

    private void ResizeWindowToDesktopWindowXamlSourceWindowDimensions()
    {
        if (m_bIsClosed) return;
        _ = PInvoke.GetClientRect(m_hwnd, out RECT rect);
        _ = PInvoke.SetWindowPos(
            m_native.WindowHandle,
            new HWND(),
            0, 0,
            rect.Width, rect.Height,
            SET_WINDOW_POS_FLAGS.SWP_NOACTIVATE | SET_WINDOW_POS_FLAGS.SWP_NOZORDER | SET_WINDOW_POS_FLAGS.SWP_SHOWWINDOW);
    }
}

public partial class DesktopWindow
{
    private static readonly unsafe HINSTANCE g_hInstance = new((void*)Process.GetCurrentProcess().Handle);

    // win32 window class name for top-level WinUI desktop windows
    private const string s_windowClassName = "WinUIDesktopWin32WindowClass";

    // Default window title for top-level WinUI desktop windows
    private const string s_defaultWindowTitle = "WinUI Desktop";

    private static unsafe WNDCLASSEXW RegisterDesktopWindowClass(WNDPROC lpfnWndProc)
    {
        if (!PInvoke.GetClassInfoEx(new DefaultSafeHandle(g_hInstance), s_windowClassName, out WNDCLASSEXW wndClassEx))
        {
            wndClassEx.cbSize = (uint)Marshal.SizeOf(wndClassEx);
            wndClassEx.style = WNDCLASS_STYLES.CS_HREDRAW | WNDCLASS_STYLES.CS_VREDRAW;
            wndClassEx.cbClsExtra = 0;
            wndClassEx.cbWndExtra = 0;
            wndClassEx.hCursor = PInvoke.LoadCursor(new HINSTANCE(), PInvoke.IDC_ARROW);
            wndClassEx.hbrBackground = (HBRUSH)((nint)SYS_COLOR_INDEX.COLOR_WINDOW + 1);
            wndClassEx.hInstance = g_hInstance;

            fixed (char* lps_windowClassName = s_windowClassName)
            {
                wndClassEx.lpszClassName = lps_windowClassName;
            }

            wndClassEx.lpfnWndProc = lpfnWndProc;
            _ = PInvoke.RegisterClassEx(wndClassEx);

            return wndClassEx;
        }
        return default;
    }

    private static unsafe HWND CreateDesktopWindow() =&gt;
        PInvoke.CreateWindowEx(
            0,                                  // Extended Style
            s_windowClassName,                  // name of window class
            s_defaultWindowTitle,               // title-bar string
            WINDOW_STYLE.WS_OVERLAPPEDWINDOW | WINDOW_STYLE.WS_VISIBLE,  // top-level window
            int.MinValue,                       // default horizontal position
            (int)SHOW_WINDOW_CMD.SW_HIDE,       // If the y parameter is some other value,
                                                // then the window manager calls ShowWindow with that value as the nCmdShow parameter
            int.MinValue,                       // default width
            int.MinValue,                       // default height
            new HWND(),                         // no owner window
            null,                               // use class menu
            new DefaultSafeHandle(g_hInstance),
            null);

    private partial class DefaultSafeHandle(nint invalidHandleValue, bool ownsHandle) : SafeHandle(invalidHandleValue, ownsHandle)
    {
        public DefaultSafeHandle(nint handle) : this(handle, true) =&gt; SetHandle(handle);

        public override bool IsInvalid =&gt; handle != nint.Zero;

        protected override bool ReleaseHandle() =&gt; true;
    }
}</code></pre>
<p>然后我们就可以初始化一个窗口了。</p>
<pre class="language-csharp highlighter-hljs"><code>DesktopWindow window = new() { WindowXamlSource = source };</code></pre>
<p>最后不要忘了用消息循环保持当前线程，不然这里跑完了窗口就退出了。</p>
<pre class="language-csharp highlighter-hljs"><code>MSG msg = new();
while (msg.message != PInvoke.WM_QUIT)
{
    if (PInvoke.PeekMessage(out msg, new HWND(), 0, 0, PEEK_MESSAGE_REMOVE_TYPE.PM_REMOVE))
    {
        _ = PInvoke.DispatchMessage(msg);
    }
}</code></pre>
<p>最后把之前的东西组合起来，再加点东西：</p>
<pre class="language-csharp highlighter-hljs"><code>/// &lt;summary&gt;
/// Represents a system-managed container for the content of an app.
/// &lt;/summary&gt;
public partial class DesktopWindow
{
    private bool m_bIsClosed = false;
    private DesktopWindowXamlSource m_source;
    private IDesktopWindowXamlSourceNative m_native;

    private readonly HWND m_hwnd;
    private readonly WNDCLASSEXW m_wndClassEx;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="DesktopWindow"/&gt; class.
    /// &lt;/summary&gt;
    public DesktopWindow()
    {
        m_wndClassEx = RegisterDesktopWindowClass(WNDPROC);
        m_hwnd = CreateDesktopWindow();
    }

    /// &lt;summary&gt;
    /// Get the handle of the window.
    /// &lt;/summary&gt;
    public nint Hwnd =&gt; m_hwnd;

    /// &lt;summary&gt;
    /// Gets the event dispatcher for the window.
    /// &lt;/summary&gt;
    public CoreDispatcher Dispatcher { get; private set; }

    /// &lt;summary&gt;
    /// Gets or sets the visual root of an application window.
    /// &lt;/summary&gt;
    public UIElement Content
    {
        get =&gt; WindowXamlSource.Content;
        set =&gt; WindowXamlSource.Content = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets the XamlRoot in which this element is being viewed.
    /// &lt;/summary&gt;
    [SupportedOSPlatform("Windows10.0.18362.0")]
    public XamlRoot XamlRoot
    {
        get =&gt; WindowXamlSource.Content.XamlRoot;
        set =&gt; WindowXamlSource.Content.XamlRoot = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets a string used for the window title.
    /// &lt;/summary&gt;
    public unsafe string Title
    {
        get
        {
            int windowTextLength = PInvoke.GetWindowTextLength(m_hwnd);
            char* windowText = stackalloc char[windowTextLength + 1];
            _ = PInvoke.GetWindowText(m_hwnd, windowText, windowTextLength + 1);
            return new string(windowText);
        }
        set =&gt; _ = PInvoke.SetWindowText(m_hwnd, value);
    }

    /// &lt;summary&gt;
    /// Gets the &lt;see cref="DesktopWindowXamlSource"/&gt; to provide XAML for this window.
    /// &lt;/summary&gt;
    public DesktopWindowXamlSource WindowXamlSource
    {
        get =&gt; m_source;
        private init
        {
            if (m_source != value)
            {
                m_source = value;
                if (value != null)
                {
                    Dispatcher = CoreWindow.GetForCurrentThread().Dispatcher;
                    m_native = value.As&lt;IDesktopWindowXamlSourceNative&gt;();
                    m_native.AttachToWindow(m_hwnd);
                    ResizeWindowToDesktopWindowXamlSourceWindowDimensions();
                }
                else
                {
                    m_native = null;
                }
            }
        }
    }

    /// &lt;summary&gt;
    /// Occurs when the window has closed.
    /// &lt;/summary&gt;
    public event TypedEventHandler&lt;DesktopWindow, object&gt; Closed;

    /// &lt;summary&gt;
    /// Shows the window and activates it.
    /// &lt;/summary&gt;
    public void Show() =&gt; _ = PInvoke.ShowWindow(m_hwnd, SHOW_WINDOW_CMD.SW_NORMAL);

    /// &lt;summary&gt;
    /// Sets the icon for the window, using the specified icon path.
    /// &lt;/summary&gt;
    /// &lt;param name="iconPath"&gt;The path of the icon.&lt;/param&gt;
    public unsafe void SetIcon(string iconPath)
    {
        fixed (char* ptr = iconPath)
        {
            HANDLE icon = PInvoke.LoadImage(new HINSTANCE(), ptr, GDI_IMAGE_TYPE.IMAGE_ICON, 0, 0, IMAGE_FLAGS.LR_LOADFROMFILE);
            _ = PInvoke.SendMessage(m_hwnd, PInvoke.WM_SETICON, PInvoke.ICON_BIG, new LPARAM((nint)icon.Value));
        }
    }

    private LRESULT WNDPROC(HWND hWnd, uint message, WPARAM wParam, LPARAM lParam)
    {
        switch (message)
        {
            case PInvoke.WM_PAINT:
                HDC hdc = PInvoke.BeginPaint(hWnd, out PAINTSTRUCT ps);
                _ = PInvoke.GetClientRect(hWnd, out RECT rect);
                _ = PInvoke.FillRect(hdc, rect, new DefaultSafeHandle(PInvoke.GetStockObject(GET_STOCK_OBJECT_FLAGS.WHITE_BRUSH)));
                _ = PInvoke.EndPaint(hWnd, ps);
                return new LRESULT();
            case PInvoke.WM_CLOSE when m_bIsClosed:
                goto default;
            case PInvoke.WM_CLOSE:
                m_bIsClosed = true;
                Closed?.Invoke(this, null);
                goto default;
            case PInvoke.WM_SIZE:
                ResizeWindowToDesktopWindowXamlSourceWindowDimensions();
                return new LRESULT();
            case PInvoke.WM_CREATE:
                return new LRESULT();
            case PInvoke.WM_DESTROY:
                PInvoke.PostQuitMessage(0);
                return new LRESULT();
            default:
                return PInvoke.DefWindowProc(hWnd, message, wParam, lParam);
        }
    }

    private void ResizeWindowToDesktopWindowXamlSourceWindowDimensions()
    {
        if (m_bIsClosed) return;
        _ = PInvoke.GetClientRect(m_hwnd, out RECT rect);
        _ = PInvoke.SetWindowPos(
            m_native.WindowHandle,
            new HWND(),
            0, 0,
            rect.Width, rect.Height,
            SET_WINDOW_POS_FLAGS.SWP_NOACTIVATE | SET_WINDOW_POS_FLAGS.SWP_NOZORDER | SET_WINDOW_POS_FLAGS.SWP_SHOWWINDOW);
    }
}

public partial class DesktopWindow
{
    private static readonly unsafe HINSTANCE g_hInstance = new((void*)Process.GetCurrentProcess().Handle);

    // win32 window class name for top-level WinUI desktop windows
    private const string s_windowClassName = "WinUIDesktopWin32WindowClass";

    // Default window title for top-level WinUI desktop windows
    private const string s_defaultWindowTitle = "WinUI Desktop";

    private static unsafe WNDCLASSEXW RegisterDesktopWindowClass(WNDPROC lpfnWndProc)
    {
        if (!PInvoke.GetClassInfoEx(new DefaultSafeHandle(g_hInstance), s_windowClassName, out WNDCLASSEXW wndClassEx))
        {
            wndClassEx.cbSize = (uint)Marshal.SizeOf(wndClassEx);
            wndClassEx.style = WNDCLASS_STYLES.CS_HREDRAW | WNDCLASS_STYLES.CS_VREDRAW;
            wndClassEx.cbClsExtra = 0;
            wndClassEx.cbWndExtra = 0;
            wndClassEx.hCursor = PInvoke.LoadCursor(new HINSTANCE(), PInvoke.IDC_ARROW);
            wndClassEx.hbrBackground = (HBRUSH)((nint)SYS_COLOR_INDEX.COLOR_WINDOW + 1);
            wndClassEx.hInstance = g_hInstance;

            fixed (char* lps_windowClassName = s_windowClassName)
            {
                wndClassEx.lpszClassName = lps_windowClassName;
            }

            wndClassEx.lpfnWndProc = lpfnWndProc;
            _ = PInvoke.RegisterClassEx(wndClassEx);

            return wndClassEx;
        }
        return default;
    }

    private static unsafe HWND CreateDesktopWindow() =&gt;
        PInvoke.CreateWindowEx(
            0,                                  // Extended Style
            s_windowClassName,                  // name of window class
            s_defaultWindowTitle,               // title-bar string
            WINDOW_STYLE.WS_OVERLAPPEDWINDOW | WINDOW_STYLE.WS_VISIBLE,  // top-level window
            int.MinValue,                       // default horizontal position
            (int)SHOW_WINDOW_CMD.SW_HIDE,       // If the y parameter is some other value,
                                                // then the window manager calls ShowWindow with that value as the nCmdShow parameter
            int.MinValue,                       // default width
            int.MinValue,                       // default height
            new HWND(),                         // no owner window
            null,                               // use class menu
            new DefaultSafeHandle(g_hInstance),
            null);

    private partial class DefaultSafeHandle(nint invalidHandleValue, bool ownsHandle) : SafeHandle(invalidHandleValue, ownsHandle)
    {
        public DefaultSafeHandle(nint handle) : this(handle, true) =&gt; SetHandle(handle);

        public override bool IsInvalid =&gt; handle != nint.Zero;

        protected override bool ReleaseHandle() =&gt; true;
    }
}

public partial class DesktopWindow
{
    /// &lt;summary&gt;
    /// Create a new &lt;see cref="DesktopWindow"/&gt; instance.
    /// &lt;/summary&gt;
    /// &lt;param name="launched"&gt;Do something after &lt;see cref="DesktopWindowXamlSource"/&gt; created.&lt;/param&gt;
    /// &lt;returns&gt;The new instance of &lt;see cref="DesktopWindow"/&gt;.&lt;/returns&gt;
    public static Task&lt;DesktopWindow&gt; CreateAsync(Action&lt;DesktopWindowXamlSource&gt; launched)
    {
        TaskCompletionSource&lt;DesktopWindow&gt; taskCompletionSource = new();

        new Thread(() =&gt;
        {
            try
            {
                DesktopWindowXamlSource source;
                using (HookWindowingModel hook = new())
                {
                    source = new DesktopWindowXamlSource();
                }

                DesktopWindow window = new() { WindowXamlSource = source };

                launched(source);
                taskCompletionSource.SetResult(window);

                MSG msg = new();
                while (msg.message != PInvoke.WM_QUIT)
                {
                    if (PInvoke.PeekMessage(out msg, new HWND(), 0, 0, PEEK_MESSAGE_REMOVE_TYPE.PM_REMOVE))
                    {
                        _ = PInvoke.DispatchMessage(msg);
                    }
                }
            }
            catch (Exception e)
            {
                taskCompletionSource.SetException(e);
            }
        })
        {
            Name = nameof(DesktopWindowXamlSource)
        }.Start();

        return taskCompletionSource.Task;
    }
}</code></pre>
<p>这样创建的窗口还存在一些问题，但是我不知道该怎么解决，所以该方法还是仅供参考。</p>
<p>最后附上示例应用：<a title="CoreAppUWP" href="https://github.com/wherewhere/CoreAppUWP/tree/wuxc" target="_blank" rel="noopener nofollow">https://github.com/wherewhere/CoreAppUWP/tree/wuxc</a></p>
<p>MUXC 篇：<a title="【UWP】让 UWP 自己托管自己 —— Windows App SDK 篇" href="https://www.cnblogs.com/wherewhere/p/18446822" target="_blank" rel="noopener">【UWP】让 UWP 自己托管自己 —— Windows App SDK 篇</a></p>
<blockquote>
<p>（由于微软迟迟不正式发布 .NET Core App 对 UWP 的支持，所以本文章实际仍处于未完成状态，源码也暂时未上传至 Github，作者会在微软正式发布之后完善文章并更新源码。</p>
</blockquote>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/wherewhere/" target="_blank">where-where</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/wherewhere/p/18446824" target="_blank">https://www.cnblogs.com/wherewhere/p/18446824</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="5.424869107278935" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-17 16:09">2025-01-17 16:06</span>&nbsp;
<a href="https://www.cnblogs.com/wherewhere">where-where</a>&nbsp;
阅读(<span id="post_view_count">74</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18446824" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18446824);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18446824', targetLink: 'https://www.cnblogs.com/wherewhere/p/18446824', title: '【UWP】让 UWP 自己托管自己 —— Windows SDK 篇' })">举报</a>
</div>
        