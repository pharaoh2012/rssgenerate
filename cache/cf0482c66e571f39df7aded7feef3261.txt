
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cupid8505/p/19027178" title="发布于 2025-08-07 17:11">
    <span role="heading" aria-level="2">LWIP TCP滑动窗口为TCP ZeroWindow的解决方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>最近做项目使用到LWIP, 板子当作客户端，PC机当作服务器，当板子和PC机通信一段时间后，板子就接收不到数据。抓包分析为：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3483237/202508/3483237-20250807170044586-1869589472.png" class="lazyload"></p>
<p>发现经过一段时间通信后，滑动窗口大小越来越小，最终显示为TCP WINDOW FULL，TCP ZeroWindow。 仔细分析了下LWIP源码，还以为是内存管理出了问题，跟踪了半天memp.c也没发现问题。后来发现问题出现自己的应用实现代码，下面是我这边的实现代码：</p>
<pre><code>
err_t tcp_client_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
{
    if (err != ERR_OK) {
        RLOG_ERROR("Error in tcp_client_recv: %d\n", err);
        tcp_client_close(tpcb); // 关闭连接
        return ERR_OK; // 释放 pbuf
    }

    if (p != NULL) {
        // 处理接收到的数据
        char *data = (char *)p-&gt;payload;
        int datalen = p-&gt;len;

        // 安全地复制数据
        char buff[datalen + 1];
        memcpy(buff, data, datalen);
        buff[datalen] = '\0';

        // 打印接收到的数据
        //RLOG_INFO("Received data: %s\n", buff);

        // 释放 pbuf
        pbuf_free(p);
        RLOG_INFO("pbuf freed\n");
    }
    tcp_output(tpcb);

    return ERR_OK;
}

</code></pre>
<p>上面的代码，需要在接受数据后，主动调用tcp_recved(tpcb, p-&gt;tot_len) ，修改代码后，再次验证功能正常。<br>
修改后的代码：</p>
<pre><code>
err_t tcp_client_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
{
    if (err != ERR_OK) {
        RLOG_ERROR("Error in tcp_client_recv: %d\n", err);
        tcp_client_close(tpcb); // 关闭连接
        return ERR_OK; // 释放 pbuf
    }

    if (p != NULL) {
        // 处理接收到的数据
        char *data = (char *)p-&gt;payload;
        int datalen = p-&gt;len;

        // 安全地复制数据
        char buff[datalen + 1];
        memcpy(buff, data, datalen);
        buff[datalen] = '\0';

        // 打印接收到的数据
        //RLOG_INFO("Received data: %s\n", buff);
		
	tcp_recved(tpcb, p-&gt;tot_len);
        // 释放 pbuf
        pbuf_free(p);
        RLOG_INFO("pbuf freed\n");
    }
    tcp_output(tpcb);

    return ERR_OK;
}
</code></pre>
<p>修正后运行效果：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3483237/202508/3483237-20250807180155615-1757621659.png" class="lazyload"></p>
<p>原来，tcp_recved(tpcb, p-&gt;tot_len) 的主要作用是通知 TCP 层应用程序已经处理了指定长度的数据。这有助于 TCP 层调整接收窗口，避免接收缓冲区溢出，并确保数据传输的高效性。如果忘记调用这个函数，可能会导致接收窗口过小，影响数据传输效率。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.035416666666666666" data-date-updated="2025-08-07 18:02">2025-08-07 17:11</span>&nbsp;
<a href="https://www.cnblogs.com/cupid8505">cupid8505</a>&nbsp;
阅读(<span id="post_view_count">82</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19027178);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19027178', targetLink: 'https://www.cnblogs.com/cupid8505/p/19027178', title: 'LWIP TCP滑动窗口为TCP ZeroWindow的解决方法' })">举报</a>
</div>
        