
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18756129" title="发布于 2025-03-06 18:57">
    <span role="heading" aria-level="2">MyBatis与其使用方法讲解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="orm">ORM</h1>
<blockquote>
<p>在讲解Mybatis之前,我们需了解一个概念ORM(Object-Relational Mapping)对象关系映射,其是数据库与Java对象进行映射的一个技术.通过使用ORM,我们可以不用编写负责的Sql语句,而是通过操作对象来实现增删改查操作</p>
</blockquote>
<h2 id="缺优分析">缺优分析</h2>
<ul>
<li><strong>优点</strong>
<ul>
<li>提高开发效率,减少代码的重复性和维护成本</li>
<li>增加代码的可读性,降低复杂度</li>
<li>对数据库查询的细节进行抽象,隐藏了sql语句</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>在进行多表联查时,或存在where条件时,ORM语句会变得复杂</li>
</ul>
</li>
</ul>
<h1 id="mybatis">MyBatis</h1>
<ul>
<li>mybatis是一个支持自定义SQL的持久层框架,通过XML文件来实现SQL配置和数据映射,MyBatis允许开发者手动编写SQL语句,提高灵活性</li>
</ul>
<blockquote>
<p>Mybatis通过<code>mapper</code>文件,将sql查询和Java对象绑定到一起,简化了JDBC代码的编写,手动设置参数,获取结果集的工作</p>
</blockquote>
<h2 id="mybatis的工作流程">MyBatis的工作流程</h2>
<ul>
<li><strong>其分为以下几步</strong></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202503/3423316-20250306185534868-2058824016.png" alt="" loading="lazy"></p>
<h2 id="mybatis的基本使用">MyBatis的基本使用</h2>
<h3 id="环境准备">环境准备</h3>
<ul>
<li>引入依赖包:</li>
</ul>
<pre><code class="language-xml">&lt;!--springboot的mybatis &gt;
&lt;dependency&gt;    
		&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    
		&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;   
		&lt;version&gt;3.0.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- MySQL 连接器 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.23&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ul>
<li>创建mybatis配置文件(<code>mybatis-config.xml</code>)</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!-- mybatis环境 --&gt;
    &lt;environments default="mysql"&gt;
        &lt;environment id="mysql"&gt;
            &lt;!-- 配置事务的类型 --&gt;
            &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源（连接池） --&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/数据库名称?userSSL=false&amp;amp;serverTimezone=Asia/Shanghai"/&gt;
                &lt;property name="username" value="帐号"/&gt;
                &lt;property name="password" value="密码"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!-- mybatis映射配置位置 --&gt;
    &lt;!-- 按模块映射不同的配置文件，让配置文件看起来更简洁 --&gt;
    &lt;mappers&gt;
        &lt;mapper resource="映射配置文件全路径"&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>springboot中的<code>application.yml</code></li>
</ul>
<pre><code class="language-xml">mybatis:
  # mapper配置文件
  mapper-locations: classpath:mapper/*.xml
  # resultType别名，没有这个配置resultType包名要写全，配置后只要写类名
  type-aliases-package: com.mashang.xiaomistore.domain
  configuration:
    #下划线自动转驼峰
    map-underscore-to-camel-case: true
</code></pre>
<ul>
<li>创建Mapper映射文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.company.mapper.StudentMapper"&gt;
    &lt;select id="queryAll" resultType="com.company.entity.Student"&gt;
        SELECT * FROM student
    &lt;/select&gt;
&lt;/mapper&gt;

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202503/3423316-20250306185548670-1844023108.png" alt="" loading="lazy"></p>
<ul>
<li>创建Mapper接口:</li>
</ul>
<pre><code class="language-java">public interface StudentMapper {
    List&lt;Student&gt; queryAll();
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202503/3423316-20250306185558083-739654692.png" alt="" loading="lazy"></p>
<h3 id="mybatis日志配置">MyBatis日志配置</h3>
<ul>
<li>引入SpringBoot中的log4j</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j2 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
    &lt;version&gt;3.4.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>在SpringBoot中在<code>application.yml</code>中<code>mybatis</code>配置项中进行配置</li>
</ul>
<pre><code class="language-xml">mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.log4j.Log4jImpl
</code></pre>
<ul>
<li>配置<code>log4j.properties</code>文件</li>
</ul>
<pre><code class="language-xml">### 设置###
log4j.rootLogger = debug,stdout,D,E

### 输出信息到控制抬 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n

### 输出DEBUG 级别以上的日志到=D://logs/error.log ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = D://logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG 
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 输出ERROR 级别以上的日志到=D://logs/error.log ###
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File =D://logs/error.log 
log4j.appender.E.Append = true
log4j.appender.E.Threshold = ERROR 
log4j.appender.E.layout = org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre>
<ul>
<li>
<p><strong>一个基本的mybatis的XML模板如下</strong></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;!-- CRUD 配置 --&gt;
&lt;/mapper&gt;

</code></pre>
</li>
</ul>
<h2 id="curd实现">CURD实现</h2>
<h3 id="select查询">select查询</h3>
<ul>
<li>
<p>使用<code>&lt;select&gt;</code>标签实现基本查询</p>
<pre><code class="language-xml">&lt;select id ="getUserById" resultType="com.company.domain.entity.User"&gt;
		SELECT * FORM user 
&lt;/select&gt;
</code></pre>
<ul>
<li><code>id</code>:对应Mapper接口中的方法名,必须一致</li>
<li><code>resultType</code>:指定返回结果映射到哪个Java类</li>
</ul>
</li>
<li>
<p>传参<code>#{}</code>与<code>${}</code>的区别</p>
<ul>
<li><code>#{}</code>的特点
<ul>
<li>事先进行预编译:使用<code>#{}</code>的参数会被Mybatis当作JDBC中的<code>?</code>占位符</li>
<li>防止sql注入:由于会事先进行预编译,Mybatis能够防止Sql注入</li>
<li>类型转换:会根据参数类型进行适当的类型转换</li>
</ul>
</li>
<li><code>${}</code>的特点
<ul>
<li>字符串拼接:<code>&amp;{}</code>直接将字符串进行替换,相当于在Sql中直接拼接传入的参数</li>
<li>存在sql注入的风险:没有预编译,会引发sql注入问题</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多条件查询</p>
<pre><code class="language-xml">&lt;select id="getUserByNameAndAge" resultType="User"&gt;
    SELECT * FROM user 
    WHERE name = #{name} AND age = #{age}
&lt;/select&gt;

</code></pre>
</li>
<li>
<p>模糊查询</p>
<pre><code class="language-xml">&lt;select&gt;
        SELECT *
        FROM user
        WHERE name LIKE CONCAT('%', #{name}, '%')
&lt;/select&gt;
</code></pre>
<ul>
<li>使用LIKE关键字和CONCAT()函数进行查询</li>
</ul>
</li>
</ul>
<h3 id="insert插入">insert插入</h3>
<ul>
<li>
<p>使用<code>&lt;insert&gt;</code>标签实现基本插入操作</p>
<pre><code class="language-xml">    &lt;insert id="insertUser" parameterType="User"&gt;
        INSERT INTO user(name, age)
        VALUES (#{name}, #{age})
    &lt;/insert&gt;
</code></pre>
<ul>
<li><code>parameterType</code>:表示入参类型</li>
</ul>
</li>
<li>
<p>实现回填自增主键</p>
<ul>
<li>使用<code>userGeneratedKeys</code>和<code>keyProperty</code>实现</li>
</ul>
<pre><code class="language-xml">&lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt;
    INSERT INTO user (name, age) 
    VALUES (#{name}, #{age})
&lt;/insert&gt;
</code></pre>
<ul>
<li><code>userGeneratedKeys</code>:表示是否启动自增</li>
<li><code>keyProperty</code>:表示将生成的主键赋值给哪个java对象的哪个属性如<code>user.id</code></li>
</ul>
</li>
</ul>
<h3 id="update更新">update更新</h3>
<ul>
<li>
<p>使用<code>&lt;update&gt;</code>标签实现基本更新</p>
<pre><code class="language-xml">	 &lt;update id="updateUser" parameterType="User"&gt;
        UPDATE user
        SET name=#{name},
            age =#{age}
        WHERE id = #{id}
    &lt;/update&gt;
</code></pre>
</li>
</ul>
<h3 id="delete删除">delete删除</h3>
<ul>
<li>
<p>使用<code>&lt;delete&gt;</code>标签基本查询</p>
<pre><code class="language-xml">    &lt;delete id="deleteUserById" parameterType="Integer"&gt;
        DELETE
        FROM user
        WHERE id = #{id}
    &lt;/delete&gt;
</code></pre>
</li>
</ul>
<h3 id="传参方式">传参方式</h3>
<ul>
<li>
<p>多参数传参(使用@Param)</p>
<ul>
<li>当方法有多个参数时,使用<code>@Param</code>注解明确参数名</li>
</ul>
<pre><code class="language-xml">&lt;select id="getUserByNameAndAge" resultType="User"&gt;
    SELECT * FROM user 
    WHERE name = #{name} AND age = #{age}
&lt;/select&gt;
</code></pre>
<ul>
<li>Mapper接口</li>
</ul>
<pre><code class="language-java">    User getUserByNameAndAge(
            @Param("name") String name,
            @Param("age") Integer age);
</code></pre>
</li>
<li>
<p>对象参数</p>
<ul>
<li>当参数为一个Java对象时,MyBatis自动将对象属性映射到Sql语句中的占位符</li>
</ul>
<pre><code class="language-xml">&lt;insert id="insertUser" parameterType="User"&gt;
    INSERT INTO user (name, age) 
    VALUES (#{name}, #{age})
&lt;/insert&gt;

</code></pre>
<ul>
<li><code>#{name}</code>对应user.name,<code>#{age}</code>对应user.age</li>
<li>Mapper接口</li>
</ul>
<pre><code class="language-java">void insertUser(User user);
</code></pre>
</li>
<li>
<p>Map参数</p>
<ul>
<li>通过Map传递多个参数或动态参数</li>
</ul>
<pre><code class="language-xml">&lt;select id="getUserByMap" resultType="User"&gt;
    SELECT * FROM user 
    WHERE name = #{name} AND age = #{age}
&lt;/select&gt;

</code></pre>
<ul>
<li>Mapper接口</li>
</ul>
<pre><code class="language-java">User getUserByMap(Map&lt;String, Object&gt; params);
</code></pre>
</li>
<li>
<p>集合/数组参数</p>
<ul>
<li>适用于批量查询,比如WHERE id IN (…)</li>
</ul>
<pre><code class="language-xml">&lt;select id="getUsersByIds" resultType="User"&gt;
    SELECT * FROM user 
    WHERE id IN
    &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/select&gt;
</code></pre>
<ul>
<li><code>&lt;foreach&gt;</code>是动态sql中的知识点等下会系统讲解</li>
<li>Mapper接口</li>
</ul>
<pre><code class="language-java">List&lt;User&gt; getUsersByIds(@Param("ids") List&lt;Integer&gt; ids);

</code></pre>
</li>
</ul>
<h2 id="动态sql">动态sql</h2>
<h3 id="与标签"><where>与<if>标签</if></where></h3>
<ul>
<li><code>&lt;where&gt;</code>:生成WHERE子句,并自动判断去掉开头多余的<code>AND/OR</code>关键字,使sql更简洁</li>
<li><code>&lt;if&gt;</code>:用于判断传参条件,根据条件决定是否拼接某段SQL语句,适用于传参条件不固定,只有在满足条件时接入某个子串</li>
</ul>
<pre><code class="language-xml">&lt;select id="getUserByCondition" resultType="User"&gt;
    SELECT * FROM user
    &lt;where&gt;
        &lt;if test="name != null and name != ''"&gt;
            AND name LIKE CONCAT('%', #{name}, '%')
        &lt;/if&gt;
        &lt;if test="age != null"&gt;
            AND age = #{age}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;

</code></pre>
<ul>
<li>当<code>name</code>为非空,会添加<code>AND name LIKE CONCAT('%', #{name}, '%')</code> 当<code>age</code>为非空时会添加 <code>AND age = #{age}</code></li>
<li>结合<where>标签使用,能自动处理首个AND,使得SQL语句正确</where></li>
</ul>
<h3 id="_"><trim></trim></h3>
<ul>
<li>其作用在于动态拼接SQL片段前添加或去除特点字符,比如前缀,后缀,以及多余的分隔符如<code>,</code></li>
<li>常用于INSERT和UPDATE语句,避免出现多余逗号</li>
</ul>
<p>INSERT语句</p>
<pre><code class="language-xml">&lt;insert id="insertUserSelective" parameterType="User"&gt;
    INSERT INTO user
    &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt;
        &lt;if test="name != null"&gt;name,&lt;/if&gt;
        &lt;if test="age != null"&gt;age,&lt;/if&gt;
        &lt;if test="email != null"&gt;email,&lt;/if&gt;
    &lt;/trim&gt;
    VALUES
    &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt;
        &lt;if test="name != null"&gt;#{name},&lt;/if&gt;
        &lt;if test="age != null"&gt;#{age},&lt;/if&gt;
        &lt;if test="email != null"&gt;#{email},&lt;/if&gt;
    &lt;/trim&gt;
&lt;/insert&gt;

</code></pre>
<ul>
<li><trim>标签包裹字段列表和对应值部分</trim></li>
<li><code>suffixOverrides=”,”</code> 表示自动去除多余的逗号,确保sql语法正确</li>
</ul>
<p>UPDATE语句</p>
<ul>
<li><code>&lt;set&gt;</code>标签是<code>&lt;trim&gt;</code>的特性化</li>
</ul>
<pre><code class="language-xml">&lt;update id="updateUserDynamic" parameterType="User"&gt;
    UPDATE user
    &lt;set&gt;
        &lt;if test="name != null"&gt;name = #{name},&lt;/if&gt;
        &lt;if test="age != null"&gt;age = #{age},&lt;/if&gt;
        &lt;if test="email != null"&gt;email = #{email},&lt;/if&gt;
    &lt;/set&gt;
    WHERE id = #{id}
&lt;/update&gt;
</code></pre>
<ul>
<li><code>&lt;set&gt;</code>标签内部原理类似<code>&lt;trim&gt;</code>,会自动去除多余逗号</li>
</ul>
<h3 id="_-1"><foreach></foreach></h3>
<ul>
<li><code>&lt;foreach&gt;</code>用于遍历集合,数组和Map,常用于批量操作或动态生成IN子句</li>
<li>其主要属性
<ul>
<li>collection:集合或数组名称(可用<code>@Param()</code>指定对应名称,默认为<code>list</code>或<code>array</code>)</li>
<li>item:循环时每个元素的别名</li>
<li>open:循环生成sql片段的前缀</li>
<li>separator:循环时的分隔符</li>
<li>close:循环生成sql片段的后缀</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;select id="getUsersByIds" resultType="User"&gt;
    SELECT * FROM user
    &lt;where&gt;
        &lt;if test="ids != null"&gt;
            AND id IN
            &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt;
                #{id}
            &lt;/foreach&gt;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;

</code></pre>
<ul>
<li>当ids不为null时,进入<code>&lt;if test="ids != null"&gt;</code>生成的sql片段为 <code>SELECT * FROM AND  WHERE id IN(#{id},#{id},…)</code></li>
<li>其中<foreach>标签遍历集合ids,用逗号进行分隔,并在开头添加<code>(</code>括号,结尾添加<code>)</code>括号</foreach></li>
<li>最终<where>标签会去除第一个AND,使sql合法<code>SELECT * FROM id WHERE IN(#{id},#{id},…)</code></where></li>
</ul>
<h2 id="mybatis的映射">MyBatis的映射</h2>
<h3 id="基本映射">基本映射</h3>
<blockquote>
<p>用于单一的字段对应</p>
</blockquote>
<ul>
<li>
<p>假设有一个user表,其中有字段<code>id,name,age</code>其在Java中有个简单的对应类User,其属性分别也是<code>id,name,age</code>那么在Mapper.xml进行select查询时</p>
<pre><code class="language-xml">SELECT id, name, age FROM user WHERE id = #{id}
</code></pre>
</li>
<li>
<p>MyBatis会将查询的结果中每一列值自动赋值给User对象中相同的属性</p>
<ul>
<li>数据库列表的id→User对象的id</li>
<li>数据库列表的name→User对象的name</li>
<li>数据库列表的age→User对象的age</li>
</ul>
</li>
<li>
<p>这样可能就会出现一种情况,数据库列表的列名与对象的属性名不一致,通常使用开启驼峰转换来解决→在<code>application.yml</code>的mybatis配置中添加如下配置:</p>
<pre><code class="language-xml">mybatis:
    map-underscore-to-camel-case: true
</code></pre>
</li>
</ul>
<h3 id="一对一映射">一对一映射</h3>
<blockquote>
<p>当查询中需要查询一个对象时</p>
</blockquote>
<ul>
<li>现假设,数据库有两张表一个user(用户)表,另一个user_detail(用户详细信息)表,在Java中我们可以创建两个类User和UserDetail类</li>
<li>然后再创建一个UserVo类,其中包含User的属性和一个UserDatail对象</li>
</ul>
<pre><code class="language-java">public class User {
    private Integer id;
    private String name;
    private Integer age;
}

public class UserDetail {
    private Integer detailId;
    private String address;
    private String phone;
}

public class UserVo {
    private Integer id;
    private String name;
    private Integer age;
    private UserDetail userDetail;  // 一对一关系：一个用户对应一份详细信息 
}
</code></pre>
<p>XML配置如下:</p>
<pre><code class="language-xml">&lt;resultMap id="userVoMap" type="com.example.UserVo"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;result property="age" column="age"/&gt;
    &lt;!-- 一对一映射 --&gt;
    &lt;association property="userDetail" javaType="com.example.UserDetail"&gt;
        &lt;id property="detailId" column="detail_id"/&gt;
        &lt;result property="address" column="address"/&gt;
        &lt;result property="phone" column="phone"/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;

&lt;select id="getUserVoById" resultMap="userVoMap" parameterType="int"&gt;
    SELECT u.id, u.name, u.age, ud.detail_id, ud.address, ud.phone
    FROM user u
    LEFT JOIN user_detail ud ON u.id = ud.user_id
    WHERE u.id = #{id}
&lt;/select&gt;

</code></pre>
<ul>
<li><code>&lt;resultMap&gt;</code>标签
<ul>
<li>用于定义一组映射规则,将查询的结果转换为一个指定类型的Java对象</li>
<li>属性
<ul>
<li>id:为该映射指定一个唯一标识,供其在XML中引用使用,如<code>&lt;resultMap id="userResultMap" type="com.example.User"&gt;</code></li>
<li>type:指定映射结果对应的Java类型(对象的全路径)</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;result&gt;</code>标签
<ul>
<li>用于将数据库列映射到Java对象的属性,在<code>&lt;resultMap&gt;</code>中使用</li>
<li>属性
<ul>
<li>property:Java对象中的属性名称,如<code>&lt;result property="userName" column="user_name"/&gt;</code>其表示将查询到的user_name列的值赋值给userName属性</li>
<li>cloumn:数据库查询结果中的列名,如<code>column="user_name”</code>表示sql查询列名为user_name的值</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;id&gt;</code>标签
<ul>
<li><code>&lt;id&gt;</code>类似于<code>&lt;result&gt;</code>主要用于映射主键字段</li>
<li>属性
<ul>
<li>property:与<code>&lt;result&gt;</code>相同,映射到Java对象的<strong>主键属性</strong></li>
<li>column:对应数据库中的<strong>主键列名</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;association&gt;</code>标签
<ul>
<li>表示一个一对一关连</li>
<li>当查询到结果时,MyBatis会将用户的基本字段<code>{id,name,age}</code>直接映射到UserVo中,同时将详细信息<code>{detail_id,address,phone}</code>封装为一个UserDetail对象,并赋值到UserVo的<code>userDetail</code>对象中</li>
</ul>
</li>
</ul>
<h3 id="一对多映射">一对多映射</h3>
<blockquote>
<p>提供用于有列表对象的查询</p>
</blockquote>
<ul>
<li>
<p>现假设一个老师(Teacher)类和一个学生(student)类,一个老师可以对应多个学生,在Java中我们可以设计Teacher类, 使用List<student>属性来存放老师的所有学生</student></p>
<pre><code class="language-java">public class Teacher {
    private Integer id;
    private String teacherName;
    private Integer age;
    private List&lt;Student&gt; students; // 一对多关系：一个老师对应多个学生
}

public class Student {
    private Integer id;
    private String name;
    private Integer age;
}
</code></pre>
<p>XML配置如下:</p>
<pre><code class="language-xml">&lt;resultMap id="teacherMap" type="com.example.Teacher"&gt;
    &lt;id property="id" column="teacher_id"/&gt;
    &lt;result property="teacherName" column="teacher_name"/&gt;
    &lt;result property="age" column="teacher_age"/&gt;
    &lt;!-- 一对多映射 --&gt;
    &lt;collection property="students" ofType="com.example.Student"&gt;
        &lt;id property="id" column="student_id"/&gt;
        &lt;result property="name" column="student_name"/&gt;
        &lt;result property="age" column="student_age"/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;

&lt;select id="getTeacherWithStudents" resultMap="teacherMap" parameterType="int"&gt;
    SELECT t.id as teacher_id, t.teacher_name, t.age as teacher_age,
           s.id as student_id, s.name as student_name, s.age as student_age
    FROM teacher t
    LEFT JOIN student s ON t.id = s.teacher_id
    WHERE t.id = #{id}
&lt;/select&gt;
</code></pre>
<ul>
<li><code>&lt;collection&gt;</code>标签:用于表示一对多关系,把查询结果中的学生记录封装成一个列表,并赋值到Teacher对象中的<code>student</code>属性</li>
</ul>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1374042775902778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-06 18:58">2025-03-06 18:57</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18756129" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18756129);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18756129', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18756129', title: 'MyBatis与其使用方法讲解' })">举报</a>
</div>
        