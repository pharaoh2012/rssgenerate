
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/WindrunnerMax/p/18899981" title="发布于 2025-05-28 10:25">
    <span role="heading" aria-level="2">从零实现富文本编辑器#4-浏览器选区模型核心交互策略</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>先前我们提到了，数据模型的设计是编辑器的基础模块，其直接影响了选区模块的表示。选区模块的设计同样是编辑器的基础部分，编辑器应用变更时操作范围的表达，就需要基于选区模型来实现，也就是说选区代表的意义是编辑器需要感知在什么范围内执行变更命令。</p>
<ul>
<li>开源地址: <a href="https://github.com/WindRunnerMax/BlockKit" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/BlockKit</a></li>
<li>在线编辑: <a href="https://windrunnermax.github.io/BlockKit/" target="_blank" rel="noopener nofollow">https://windrunnermax.github.io/BlockKit/</a></li>
<li>项目笔记: <a href="https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md</a></li>
</ul>
<p>从零实现富文本编辑器项目的相关文章:</p>
<ul>
<li><a href="https://www.cnblogs.com/WindrunnerMax/p/18816107" target="_blank">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>
<li><a href="https://www.cnblogs.com/WindrunnerMax/p/18826249" target="_blank">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>
<li><a href="https://www.cnblogs.com/WindrunnerMax/p/18840221" target="_blank">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>
<li><a href="" rel="noopener nofollow">从零实现富文本编辑器#4-浏览器选区模型核心交互策略</a></li>
</ul>
<h2 id="浏览器选区">浏览器选区</h2>
<p>数据模型设计直接影响了编辑器选区模型的表达，例如下面的例子中<code>Quill</code>与<code>Slate</code>编辑器的模型选区实现，其与本身维护的数据结构密切相关。然而无论是哪种编辑器设计的数据模型，都需要基于浏览器的选区来实现，因此在本文中我们先来实现浏览器选区模型的基本操作。</p>
<pre><code class="language-js">// Quill
{ index: 0, length: 3 }

// Slate
{ 
  anchor: { offset: 0, path: [0, 0] }, 
  focus: { offset: 3, path: [0, 0] } 
} 
</code></pre>
<p>实际上选区这个概念还是比较抽象，但是我们应该是经常与其打交道的。例如在鼠标拖动文本部分内容时，这部分会携带淡蓝色的背景色，这就是选区范围的表达，同样我们可能会将其称为选中、拖蓝、选中范围等等，这便是浏览器提供的选区能力。</p>
<p>除了选中文本的蓝色背景色外，闪烁的光标同样是选区的一种表现形式。光标的选区范围是一个点，或者可以称为折叠的选区。光标的表达通常只出现在可编辑元素中，例如输入框、文本域、<code>ContentEditable</code>元素等。若是在非可编辑元素中，光标处于虽然不可见状态，但实际上仍然是存在的。</p>
<p>浏览器选区的操作主要基于<code>Range</code>和<code>Selection</code>对象，<code>Range</code>对象表示包含节点和部分文本节点的文档片段，<code>Selection</code>对象表示用户选择的文本范围或光标符号的当前位置。</p>
<h3 id="range">Range</h3>
<p><code>Range</code>对象与数学上的区间概念类似，也就是说<code>Range</code>指的是一个连续的内容范围。数学上的区间表示由两个点即可表示，<code>Range</code>对象的表达同样是由<code>startContainer</code>起始到<code>endContainer</code>结束，因此选区必须要连续才能够正常表达。<code>Range</code>实例对象的属性如下:</p>
<ul>
<li><code>startContainer</code>：表示选区的起始节点。</li>
<li><code>startOffset</code>：表示选区的起始偏移量。</li>
<li><code>endContainer</code>：表示选区的结束节点。</li>
<li><code>endOffset</code>：表示选区的结束偏移量。</li>
<li><code>collapsed</code>: 表示<code>Range</code>的起始位置和终止位置是否相同，即折叠状态。</li>
<li><code>commonAncestorContainer</code>：表示选区的共同祖先节点，即完整包含<code>startContainer</code>和<code>endContainer</code>最深一级的节点。</li>
</ul>
<p><code>Range</code>对象还存在诸多方法，在我们的编辑器中常用的主要是设置设置选区起始位置<code>setStart</code>、设置结束位置<code>setEnd</code>、获取选区矩形位置<code>getBoundingClientRect</code>等。在下面的例子中，我们就可以获取文本片段<code>23</code>的位置：</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;script&gt;
  const range = document.createRange();
  range.setStart($1.firstChild, 1); // $1
  range.setEnd($1.firstChild, 3);
  console.log(range.getBoundingClientRect());
&lt;/script&gt;
</code></pre>
<p>获取文本片段矩形位置是个非常重要的应用，这样我们可以实现非完整<code>DOM</code>元素的位置获取，而不是必须通过<code>HTML DOM</code>来获取矩形位置，这对实现诸如划词高亮等效果非常有用。此外，需要关注的是这里的<code>firstChild</code>是<code>Text</code>节点，即值为<code>Node.TEXT_NODE</code>类型，这样才可以计算文本片段。</p>
<p>既然可以设置文本节点，那么自然也存在非文本节点的状态。在调用设置选区时，如果节点类型是<code>Text</code>、<code>Comment</code>或<code>CDATASection</code>之一，那么<code>offset</code>指的是从结束节点算起字符的偏移量。对于其他<code>Node</code>类型节点，<code>offset</code>是指从结束结点开始算起子节点的偏移量。</p>
<p>在下面的例子中，我们就是将选区设置为非文本内容的节点。此时最外层的<code>$1</code>节点作为父节点，存在<code>2</code>个子节点，因此<code>offset</code>可以设置的范围是<code>0-2</code>，若此时设置为<code>3</code>则会直接抛出异常。这里基本与设置文本选区的<code>offset</code>一致，差异是文本选区必须要文本节点，非文本则是父节点。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;/span&gt;
&lt;script&gt;
  const range = document.createRange();
  range.setStart($1, 1);
  range.setEnd($1, 2);
  console.log(range.getBoundingClientRect());
&lt;/script&gt;
</code></pre>
<p>构造<code>Range</code>对象主要的目的便是获取相关<code>DOM</code>的位置来计算，还有个常见的需求是实现内容高亮，通常来说这需要我们主动计算位置来实现虚拟图层。在较新的浏览器中实现了<code>::highlight</code>伪元素，可以帮我们用浏览器的原生实现来实现高亮效果，下面的例子中<code>23</code>文本片段就会出现背景色。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;style&gt;
  ::highlight(highlight-bg) {
    color: white;
    background-color: blue;
  }
&lt;/style&gt;
&lt;script&gt;
  const range = document.createRange();
  range.setStart($1.firstChild, 1);
  range.setEnd($1.firstChild, 3);
  const highlightBG = new Highlight();
  highlightBG.add(range);
  CSS.highlights.set("highlight-bg", highlightBG);
&lt;/script&gt;
</code></pre>
<h3 id="selection">Selection</h3>
<p><code>Selection</code>对象表示用户选择的文本范围或光标符号的当前位置，其代表页面中的文本选区，可能横跨多个元素。文本选区通常由用户拖拽鼠标经过文字而产生，实际上浏览器中的<code>Selection</code>就是由<code>Range</code>来组成的。<code>Selection</code>对象的主要属性如下:</p>
<ul>
<li><code>anchorNode</code>：表示选区的起始节点。</li>
<li><code>anchorOffset</code>：表示选区的起始偏移量。</li>
<li><code>focusNode</code>：表示选区的结束节点。</li>
<li><code>focusOffset</code>：表示选区的结束偏移量。</li>
<li><code>isCollapsed</code>：表示选区的起始位置和终止位置是否相同，即折叠状态。</li>
<li><code>rangeCount</code>：表示选区中包含的<code>Range</code>对象的数量。</li>
</ul>
<p>用户可能从左到右选择文本或从右到左选择文本，<code>anchor</code>指向用户开始选择的地方，而<code>focus</code>指向用户结束选择的地方。<code>anchor</code>和<code>focus</code>的概念不能与选区的起始位置<code>startContainer</code>和终止位置<code>endContainer</code>混淆，<code>Range</code>对象永远是<code>start</code>节点指向<code>end</code>节点。</p>
<ul>
<li>锚点<code>anchor</code>: 选区的锚指的是选区起始点，当我们使用鼠标框选一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。</li>
<li>焦点<code>focus</code>: 选区的焦点指的是选区的终点，当我们用鼠标框选一个选区的时候，焦点是我们的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。</li>
</ul>
<p>我们可以通过<code>SelectionChange</code>事件来监听选区的变化，在这个选区的事件回调中，可以通过<code>window.getSelection()</code>来获取当前的选区对象状态。通过<code>getSelection</code>获取的选区实例对象是个单例对象，即引用是同实例，内部的值是变化的。</p>
<p>当然<code>W3C</code>标准并未强制要求单例，但主流浏览器<code>Chrome</code>、<code>Firefox</code>、<code>Safari</code>实现为同一实例。不过为了保证兼容性以及<code>null</code>状态，我们实际要使用选区对象的时候，通常是实时通过<code>getSelection</code>获取选区状态。此外<code>Selection</code>对象的属性是不可枚举的，<code>spread</code>操作符是无效的。</p>
<pre><code class="language-js">document.addEventListener("selectionchange", () =&gt; {
  const selection = window.getSelection();
  console.log({
    anchor: selection.anchorNode,
    anchorOffset: selection.anchorOffset,
    focus: selection.focusNode,
    focusOffset: selection.focusOffset,
    isCollapsed: selection.isCollapsed,
  });
});
</code></pre>
<p>编辑器中自然还需要设置选区的操作，这部分可以使用<code>Selection</code>对象的<code>addRange</code>方法来实现，通常在调用该方法之前需要使用<code>removeAllRanges</code>方法来移除已有选区。需要注意的是，该方法无法处理反向的选区，即<code>backward</code>状态。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;script&gt;
  const range = document.createRange();
  range.setStart($1.firstChild, 1);
  range.setEnd($1.firstChild, 3);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
&lt;/script&gt;
</code></pre>
<p>因此设置选区时，通常是需要使用<code>setBaseAndExtent</code>来实现。正向的选区直接将<code>start</code>、<code>end</code>方向的节点设置为<code>base</code>和<code>extent</code>即可，反向选区则是将<code>start</code>、<code>end</code>方向的节点设置为<code>extent</code>和<code>base</code>，这样就可以实现反向选区的效果，<code>DOM</code>节点参数与<code>Range</code>基本一致。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;script&gt;
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 3, $1.firstChild, 1);
&lt;/script&gt;
</code></pre>
<p>设置选区的部分可以通过上述<code>API</code>实现，而获取选区的部分虽然可以通过<code>focus</code>和<code>anchor</code>来获取。但是在<code>Selection</code>对象上并未标记<code>backward</code>状态，因此我们还需要通过<code>getRangeAt</code>方法来获取选区内建的<code>Range</code>对象，因此来对比原始对象的状态。</p>
<p><code>Selection</code>对象上的<code>rangeCount</code>属性表示选区中包含的<code>Range</code>对象的数量，通常我们只需要获取第一个选区即可。这里的判断条件需要特别关注，因为若是当前没有选区值，也就是<code>rangeCount</code>为<code>0</code>，此时直接获取内建选区对象是会抛出异常的。</p>
<p>此外我们可能会好奇，通常进行选区操作的时候我们都是只能选单个连读的选区的，为什么会出现<code>rangeCount</code>属性。这里是需要注意在<code>Firefox</code>中是可以设置多个选区的，按住<code>Ctrl</code>键可以实现多个选区的状态，但是为了主要浏览器兼容性通常我们只需要处理首个选区。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;script&gt;
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 3, $1.firstChild, 1);
  if (selection.rangeCount &gt; 0) {
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    console.log(rect);
  }
&lt;/script&gt;
</code></pre>
<p>选区这部分还有个比较有趣的控制效果，通常来说<code>ContentEditable</code>元素是应该作为整体被选中的，此时内部的文本节点表现仍然是被选中的状态。而若是真的想避免文本内容被选中，便可以使用<code>user-select</code>属性来完成，由于选区实际上靠边缘节点就可以实现，就可以出现特殊的选区断层效果。</p>
<p>此外，下面的例子中我们是使用<code>childNodes</code>而不是<code>children</code>来获取子节点的状态。<code>childNodes</code>是获取所有子节点的集合，包括文本节点、注释节点等，而<code>children</code>只会获取元素节点的集合，因此在设置选区时需要特别注意。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;12&lt;span style="user-select: none;"&gt;34&lt;/span&gt;56&lt;/span&gt;
&lt;script&gt;
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.childNodes[0], 1, $1.childNodes[2], 1);
&lt;/script&gt;
</code></pre>
<p>在<code>Range</code>对象的最后，我们介绍了<code>::highlight</code>伪元素，在这里我们同样介绍一下<code>::selection</code>伪元素。<code>::selection</code>用于将央视应用于用户选中的文本部分，即我们可以通过设置<code>::selection</code>的样式来实现选区的样式控制，例如设置背景色、字体颜色等。</p>
<p>在这里还有个比较有趣的事情，在实现浏览器的扩展或者脚本时比较有用。如果想恢复<code>::selection</code>伪元素的原始背景色，是不可以设置为<code>transparent</code>的，因为这会导致选区的背景色消失，实际上默认的浅蓝色背景是保留的关键字<code>highlight</code>，当然使用<code>#BEDAFF</code>也是可行的。</p>
<pre><code class="language-html">&lt;span id="$1"&gt;123456&lt;/span&gt;
&lt;style&gt;
  span::selection{
    background: blue;
    color: white;
  }
&lt;/style&gt;
&lt;script&gt;
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 1, $1.firstChild, 3);
&lt;/script&gt;
</code></pre>
<h2 id="可编辑元素">可编辑元素</h2>
<p>虽然选区本质上跟可编辑元素并没有直接关系，但是我们实现的目标是富文本编辑器，自然是需要在<code>ContentEditable</code>元素中处理选区状态。不过在这之前，我们可以先简单针对于<code>input</code>元素实现选区操作。</p>
<pre><code class="language-html">&lt;input id="$1" value="123456" /&gt;
&lt;script&gt;
  $1.focus();
  $1.setSelectionRange(1, 3);
&lt;/script&gt;
</code></pre>
<p>紧接着来看<code>ContentEditable</code>实现，本质上对于选区的操作是否是可编辑元素是没有什么区别的。只不过在可编辑元素中会显示地表现出光标，或者称为插入符。而在非可编辑元素中，光标虽然不可见，但是选区的变换事件以及转移实际上还是真实存在的。</p>
<pre><code class="language-html">&lt;span id="$1" contenteditable&gt;123456&lt;/span&gt;
&lt;script&gt;
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 3, $1.firstChild, 1);
&lt;/script&gt;
</code></pre>
<p>其实在最开始的时候，我想实现的就是纯<code>Blocks</code>的编辑器，而实际上目前我并没有找到比较好的编辑器实现来做参考，主要是类似的编辑器都设计的特别复杂，在没有相关文章的情况很难理解。当时也还是比较倾向于<code>quill-delta</code>的数据结构，因为其无论是对于协同的支持还是<code>diff</code>、<code>ops</code>的表达都非常完善。</p>
<p>因此最开始想的是通过多个<code>Quill Editor</code>实例来实现嵌套<code>Blocks</code>，实际上这里边的坑会有很多，需要禁用大量的编辑器默认行为并且重新实现。例如<code>History</code>、<code>Enter</code>换行操作、选区变换等等，可以预见这其中需要关注的点会有很多，但是相对于从零实现编辑器需要适配的各种浏览器兼容事件还有类似于输入事件的处理等等，这种管理方式还算是可以接受的。</p>
<p>在这里需要关注一个问题，<code>Blocks</code>的编辑器在数据结构上必然需要以嵌套的数据结构来描述，当然初始化时可以设计的扁平化的<code>Block</code>，然后对每个<code>Block</code>都存储了<code>string[]</code>的<code>Block</code>节点信息来获取引用。如果在设计编辑器时不希望有嵌套的结构，而是希望通过扁平的数据结构描述内容，此时在内容中如果引用了块结构，那么就再并入<code>Editor</code>实例，这种思路会全部局限于富文本框架，扩展性会差一些。</p>
<p><code>Blocks</code>的编辑器是完全由最外层的<code>Block</code>结构管理引用关系，也就是说引用是在<code>children</code>里的，而块引用的编辑器则需要由编辑器本身来管理引用关系，也就是说引用是在<code>ops</code>里的。所以说对于数据结构的设计与实现非常依赖于编辑器整体的架构设计，当然我们也可以将块引用的编辑器看作单入口的<code>Blocks</code>编辑器，这其中的<code>Line</code>表达全部交由<code>Editor</code>实例来处理，这就是不同设计中却又相通的点。</p>
<p>在具体尝试实现编辑器的过程中，发现浏览器中存在明确的选区策略，在下面例子<code>State 1</code>的<code>ContentEditable</code>状态下，无法做到从<code>Selection Line 1</code>选择到<code>Selection Line 2</code>。这是浏览器默认行为，而这种选区的默认策略就定染导致无法基于这种模型实现<code>Blocks</code>。</p>
<pre><code class="language-html">&lt;p&gt;State 1&lt;/p&gt;
&lt;div contenteditable="false" data-block&gt;
  &lt;div contenteditable="true" data-line&gt;Selection Line 1&lt;/div&gt;
  &lt;div contenteditable="true" data-line&gt;selection Line 2&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>而如果是<code>Stage 2</code>的模型状态，是完全可以做到选区的正常操作的，在模型方面没有什么问题，但是我们此时的<code>Quill</code>选区又出现了问题。由于其在初始化时是会由<code>&lt;br/&gt;</code>产生到<code>div/p</code>状态的突变，导致其选区的<code>Range</code>发生异动，此时在浏览器中的光标是不正确的。</p>
<p>而我们此时没有办法入侵到<code>Quill</code>中帮助其修正选区，且<code>DOM</code>上没有任何辅助我们修正选区的标记，所以这个方式也难以继续下去。甚至于如果需要处理其中状态变更的话，还需要侵入到<code>parchment</code>的视图层实现，这样就需要更加复杂的处理。</p>
<pre><code class="language-html">&lt;p&gt;State 2&lt;/p&gt;
&lt;div contenteditable="true" data-block&gt;
  &lt;div contenteditable="true" data-line&gt;Selection Line 1&lt;/div&gt;
  &lt;div contenteditable="true" data-line&gt;selection Line 2&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>因此在这种状态下，我们可能只能选取<code>Stage 3</code>策略的形式，并不实现完整的<code>Blocks</code>，而是将<code>Quill</code>作为嵌套结构的编辑器实例。在这种模型状态下编辑器不会出现选区的偏移问题，我们的嵌套结构也可以借助<code>Quill</code>的<code>Embed Blot</code>来实现插件扩展嵌套<code>Block</code>结构。</p>
<pre><code class="language-html">&lt;p&gt;State 3&lt;/p&gt;
&lt;div contenteditable="true" data-block&gt;
  &lt;div data-line&gt;Selection Line 1&lt;/div&gt;
  &lt;div data-line&gt;selection Line 2&lt;/div&gt;
  &lt;div contenteditable="false" data-block&gt;
    &lt;div contenteditable="true" data-line&gt;Selection Line 1&lt;/div&gt;
    &lt;div contenteditable="true" data-line&gt;selection Line 2&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>在这种情况下，如果想实现<code>Blocks</code>编辑器的目标，通过<code>Quill</code>来实现就只能依赖于<code>Embed Blot</code>的模式来实现，而这又是完全依赖于<code>Quill</code>维护的视图层。如果需要处理边界<code>Case</code>就需要再处理<code>parchment</code>的视图层，这样下来会非常麻烦，因此这也是从零实现编辑器的部分原因。</p>
<p>其实类似的问题在<code>editor.js</code>中也有存在，在其在线<code>DEMO</code>中可以发现我们无法从纯文本行<code>1</code>选择到行<code>2</code>。具体是在选中行<code>1</code>的部分文本后，拖拽选择到行<code>2</code>的部分文本时，会发现行<code>1</code>和<code>2</code>会被全部选中，基于<code>slate</code>实现的<code>Yoopta-Editor</code>也存在类似的问题。</p>
<p>这个问题在飞书文档上就并不存在了，在飞书文档中的重点是选区必然处于同一个父级<code>Block</code>下，具体的实现是当鼠标按下时拖选完全处于非受控状态，此时若是碰撞到其他块内，内部的选区样式会被<code>::selection</code>覆盖掉，然后这个块整体的样式会被<code>class</code>应用选中的样式。</p>
<p>而此时若是抬起鼠标，此时会立即纠正选区状态，此时的选区实现是会真正处于同一个父级块中。处于同一个块是为了简化操作，无论是应用变更还是获取选中片段的数据，在同一个父级块中进行迭代就不需要基于渲染块的顺序来递归迭代查找，这样在数据处理方面会更加简单。</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;div class="level1"&gt;
    &lt;div class="level2.1"&gt;
      &lt;div class="level3.1" id="$nodeA"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="level2.2"&gt;
      &lt;div class="level3.1"&gt;
        &lt;div class="level4.1" id="$nodeB"&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  const getNodeDepth = (node) =&gt; {
    let depth = 0;
    let current = node;
    while (current.parentNode) {
      depth++;
      current = current.parentNode;
    }
    return depth;
  };

  const liftNode = (node1, node2) =&gt; {
    const depth1 = getNodeDepth(node1);
    const depth2 = getNodeDepth(node2);

    let [deepNode, shallowNode] = depth1 &gt; depth2 ? [node1, node2] : [node2, node1];

    for (let i = Math.abs(depth1 - depth2); i &gt; 0; i--) {
      deepNode = deepNode.parentNode;
    }

    while (deepNode !== shallowNode) {
      const deepNodeParent = deepNode.parentNode;
      const shallowNodeParent = shallowNode.parentNode;
      if (deepNodeParent === shallowNodeParent) {
        return [deepNode, shallowNode, deepNodeParent];
      }
      deepNode = deepNodeParent;
      shallowNode = shallowNodeParent;
    }

    return [null, null, null];
  };

  console.log(liftNode($nodeA, $nodeB));
&lt;/script&gt;
</code></pre>
<h2 id="自绘选区">自绘选区</h2>
<p>在我们的设计中是基于<code>ContentEditable</code>实现，也就是说没有准备实现自绘选区，只是最近思考了一下自绘选区的实现。通常来说在整体编辑器内的<code>contenteditable=false</code>节点会存在特殊的表现，在类似于<code>inline-block</code>节点中，例如<code>Mention</code>节点中，当节点前后没有任何内容时，我们就需要在其前后增加零宽字符，用以放置光标。</p>
<p>在下面的例子中，<code>line-1</code>是无法将光标放置在<code>@xxx</code>内容后的，虽然我们能够将光标放置之前，但此时光标位置是在<code>line node</code>上，是不符合我们预期的文本节点的。那么我们就必须要在其后加入零宽字符，在<code>line-2/3</code>中我们就可以看到正确的光标放置效果。这里的<code>0.1px</code>也是个为了兼容光标的放置的<code>magic</code>，没有这个<code>hack</code>的话，非同级节点光标同样无法放置在<code>inline-block</code>节点后。</p>
<pre><code class="language-html">&lt;div contenteditable style="outline: none"&gt;
  &lt;div data-line-node="1"&gt;
    &lt;span data-leaf&gt;&lt;span contenteditable="false" style="margin: 0 0.1px;"&gt;@xxx&lt;/span&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div data-line-node="2"&gt;
    &lt;span data-leaf&gt;&amp;#8203;&lt;/span&gt;
    &lt;span data-leaf&gt;&lt;span contenteditable="false" style="margin: 0 0.1px;"&gt;@xxx&lt;/span&gt;&lt;/span&gt;
    &lt;span data-leaf&gt;&amp;#8203;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div data-line-node="3"&gt;
    &lt;span data-leaf&gt;&amp;#8203;&lt;span contenteditable="false"&gt;@xxx&lt;/span&gt;&amp;#8203;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>那么除了通过零宽字符或者<code>&lt;br&gt;</code>标签来放置光标外，自然也可以通过自绘选区来实现，因为此时不再需要<code>ContentEditable</code>属性，那么自然就不会存在这些奇怪的行为。因此如果借助原生的选区实现，然后在此基础上实现控制器层，就可以实现完全受控的编辑器。</p>
<p>但是这里存在一个很大的问题，就是内容的输入，因为不启用<code>ContentEditable</code>的话是无法出现光标的，自然也无法输入内容。而如果我们想唤醒内容输入，特别是需要唤醒<code>IME</code>输入法的话，浏览器给予的常规<code>API</code>就是借助<code>&lt;input&gt;</code>来完成，因此我们就必须要实现隐藏的<code>&lt;input&gt;</code>来实现输入，实际上很多代码编辑器例如 <a href="https://github.com/codemirror/codemirror5" target="_blank" rel="noopener nofollow">CodeMirror</a> 就是类似实现。</p>
<p>但是使用隐藏的<code>&lt;input&gt;</code>就会出现其他问题，因为焦点在<code>input</code>上时，浏览器的文本就无法选中了。因为在同个页面中，焦点只会存在一个位置，因此在这种情况下，我们就必须要自绘选区的实现了。例如钉钉文档、有道云笔记就是自绘选区，开源的 <a href="https://github.com/microsoft/monaco-editor" target="_blank" rel="noopener nofollow">Monaco</a> 同样是自绘选区，<a href="https://github.com/textbus/textbus" target="_blank" rel="noopener nofollow">TextBus</a> 则绘制了光标，选区则是借助了浏览器实现。</p>
<p>其实这里说起来<code>TextBus</code>的实现倒是比较有趣，因为其自绘了光标焦点需要保持在外挂的<code>textarea</code>上，但是本身的文本选区也是需要焦点的。因此考虑这里的实现应该是具有比较特殊的实现，特别是<code>IME</code>的输入中应该是有特殊处理，可能是重新触发了事件。而且这里的<code>IME</code>输入除了本身的非折叠选区内容删除外，还需要唤醒字符的输入，此外还有输入过程中暂态的字符处理，自绘选区复杂的地方就在输入模块上。</p>
<p>最后探究发现<code>TextBus</code>既没有使用<code>ContentEditable</code>这种常见的实现方案，也没有像<code>CodeMirror</code>或者<code>Monaco</code>一样自绘选区。从<code>Playground</code>的<code>DOM</code>节点上来看，其是维护了一个隐藏的<code>iframe</code>来实现的，这个<code>iframe</code>内存在一个<code>textarea</code>，以此来处理<code>IME</code>的输入。</p>
<p>这种实现非常的特殊，因为内容输入的情况下，文本的选区会消失，也就是说两者的焦点是会互相抢占的。那么先来看一个简单的例子，以<code>iframe</code>和文本选区的焦点抢占为例，可以发现在<code>iframe</code>不断抢占的情况下，我们是无法拖拽文本选区的。这里值得一提的是，我们不能直接在<code>onblur</code>事件中进行<code>focus</code>，这个操作会被浏览器禁止，必须要以宏任务的异步时机触发。</p>
<pre><code class="language-html">&lt;span&gt;123123&lt;/span&gt;
&lt;iframe id="$1"&gt;&lt;/iframe&gt;
&lt;script&gt;
  const win = $1.contentWindow;
  win.addEventListener("blur", () =&gt; {
    console.log("blur");
    setTimeout(() =&gt; $1.focus(), 0);
  });
  win.addEventListener("focus", () =&gt; console.log("focus"));
  win.focus();
&lt;/script&gt;
</code></pre>
<p>实际上这个问题是我踩过的坑，注意我们的焦点聚焦调用是直接调用的<code>$1.focus</code>，假如此时我们是调用<code>win.focus</code>的话，那么就可以发现文本选区是可以拖拽的。通过这个表现其实可以看出来，主从框架的文档的选区是完全独立的，如果焦点在同一个框架内则会相互抢占，如果不在同一个框架内则是可以正常表达，也就是<code>$1</code>和<code>win</code>的区别。</p>
<p>其实可以注意到此时文本选区是灰色的，这个可以用<code>::selection</code>伪元素来处理样式，而且各种事件都是可以正常触发的，例如<code>SelectionChange</code>事件以及手动设置选区等。当然如果直接在<code>iframe</code>中放置<code>textarea</code>的话，可以得到同样的表现，同样也可以正常的输入内容，并且不会打断<code>IME</code>的输入法，这个<code>Magic</code>的表现在诸多浏览器都可以正常触发。</p>
<pre><code class="language-html">&lt;span&gt;123123&lt;/span&gt;
&lt;iframe id="$1"&gt;&lt;/iframe&gt;
&lt;script&gt;
  const win = $1.contentWindow;
  const textarea = document.createElement("textarea");
  $1.contentDocument.body.appendChild(textarea);
  textarea.focus();
  textarea.addEventListener("blur", () =&gt; {
    setTimeout(() =&gt; textarea.focus(), 0);
  });
  win.addEventListener("blur", () =&gt; console.log("blur"));
  win.addEventListener("focus", () =&gt; console.log("focus"));
  win.focus();
&lt;/script&gt;
</code></pre>
<p>那么除了特殊的<code>TextBus</code>外，<code>CodeMirror</code>、<code>Monaco/VSCode</code>、钉钉文档、有道云笔记的编辑器都是自绘选区的实现。那么自绘选区就需要考虑两点内容，首先是如何计算当前光标在何处，其次就是如何绘制虚拟的选区图层。选区图层这部分我们之前的<code>diff</code>和虚拟图层实现中已经聊过了，我们还是采取相对简单的三行绘制的形式实现，现在基本都是这么实现的，折行情况下的独行绘制目前只在飞书文档的搜索替换中看到过。</p>
<p>因此复杂的就是光标在何处的计算，我们的编辑器选区依然可以保持浏览器的模型来实现，主要是取得<code>anchor</code>和<code>focus</code>的位置即可。那么在浏览器中是存在<code>API</code>可以实现光标的位置选区<code>Range</code>的，目前我看只有<code>VSCode</code>中使用了这个<code>API</code>，而<code>CodeMirror</code>和钉钉文档则是自己实现了光标的位置计算。<code>CodeMirror</code>中通过二分查找来不断对比光标和字符位置，这其中折行的查找会导致复杂了不少。</p>
<p>说起来，<code>VSCode</code>的包管理则是挺有趣的管理，<code>VSC</code>是开源的应用，在其中提取了核心的<code>monaco-editor-core</code>包。然后这个包会作为<code>monaco-editor</code>的<code>dev</code>依赖，在打包的时候会将其打包到<code>monaco-editor</code>中，<code>monaco-editor</code>则是重新包装了<code>core</code>来让编辑器可以运行在浏览器<code>web</code>容器内，这样就可以实现<code>web</code>版的<code>VSCode</code>。</p>
<p>在这里我们可以使用浏览器相关的<code>API</code>来实现光标的选区位置计算，配合起来相关的<code>API</code>兼容性也是比较好的，当然如果在<code>shadow DOM</code>中使用的话兼容性就比较差了。这是基于浏览器<code>DOM</code>的实现，若是使用<code>Canvas</code>绘制选区的话，就需要完全基于绘制的文本来计算了。这部分实现起来倒是也并不是很复杂，<code>DOM</code>绘制的复杂是因为我们难以获取文本位置及大小，而在<code>Canvas</code>中这些信息我们通常都是会记录的。</p>
<pre><code class="language-html">&lt;div id="$container" style="width: 200px; word-break: break-word; user-select: none; position: relative;"&gt;&lt;div id="$text" data-text&gt;123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123&lt;/div&gt;&lt;div id="$layer"&gt;&lt;/div&gt;&lt;/div&gt;
&lt;style&gt;body { margin: 0; padding: 0; }&lt;/style&gt;
&lt;script&gt;
  const render = (startRect, endRect) =&gt; {
    const block = document.createElement("div");
    block.style.position = "absolute";
    block.style.width = "100%";
    block.style.height = "0";
    block.style.top = startRect.top + "px";
    block.style.pointerEvents = "none";
    const head = document.createElement("div");
    const body = document.createElement("div");
    const tail = document.createElement("div");
    $layer.innerHTML = "";
    $layer.appendChild(block);
    block.appendChild(head);
    block.appendChild(body);
    block.appendChild(tail);
    if (startRect.top === endRect.top) {
      // 单行(非折行)的情况 `head`
      head.style.marginLeft = startRect.left + "px";
      head.style.height = startRect.height + "px";
      head.style.width = endRect.right - startRect.left + "px";
      head.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
    } else if (endRect.top - startRect.bottom &lt; startRect.height) {
      // 两行(折单次)的情况 `head + tail` `body`占位
      head.style.marginLeft = startRect.left + "px";
      head.style.height = startRect.height + "px";
      head.style.width = startRect.width - startRect.left + "px";
      head.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
      body.style.height = endRect.top - startRect.bottom + "px";
      tail.style.width = endRect.right + "px";
      tail.style.height = endRect.height + "px";
      tail.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
    } else {
      // 多行(折多次)的情况 `head + body + tail`
      head.style.marginLeft = startRect.left + "px";
      head.style.height = startRect.height + "px";
      head.style.width = startRect.width - startRect.left + "px";
      head.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
      body.style.width = "100%";
      body.style.height = endRect.top - startRect.bottom + "px";
      body.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
      tail.style.marginLeft = 0;
      tail.style.height = endRect.height + "px";
      tail.style.width = endRect.right + "px";
      tail.style.backgroundColor = "rgba(0, 0, 0, 0.2)";
    }
  }
  const getCaretFromPoint = (x, y) =&gt; {
    const element = document.elementFromPoint(x, y);
    if (!element || !element.closest("[data-text]")) {
      return null;
    }
    if (document.caretRangeFromPoint) {
      const range = document.caretRangeFromPoint(x, y)
      return { node: range.startContainer, offset: range.startOffset }
    } else if (document.caretPositionFromPoint) {
      const pos = document.caretPositionFromPoint(x, y);
      return { node: pos.offsetNode, offset: pos.offset }
    }
    return null;
  }
  const getRect = (node, offset) =&gt; {
    const range = document.createRange();
    range.setStart(node, offset);
    range.setEnd(node, offset);
    return range.getBoundingClientRect();
  }
  $text.onmousedown = (e) =&gt; {
    const start = getCaretFromPoint(e.clientX, e.clientY);
    if(!start) return;
    const startRect = getRect(start.node, start.offset);
    const onMouseMove = (e) =&gt; {
      const end = getCaretFromPoint(e.clientX, e.clientY);
      if (!end) return;
      const endRect = getRect(end.node, end.offset);
      const [rect1, rect2] = start.offset &lt; end.offset ? [startRect, endRect] : [endRect, startRect];
      render(rect1, rect2);
    }
    const onMouseUp = (e) =&gt; {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  }
&lt;/script&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>在这里我们总结了浏览器的相关<code>API</code>，并且基于<code>Range</code>对象与<code>Selection</code>对象实现了基本的选区操作，并且举了相关的应用具体场景和示例。此外，还介绍了先前针对<code>Blocks</code>编辑器的选区遇到的问题，在最后我们调研了诸多自绘选区的编辑器实现，并且实现了简单的自绘选区示例。</p>
<p>接下来我们会从数据模型出发，设计编辑器选区模型的表示，然后在浏览器选区相关的<code>API</code>基础上，实现编辑器选区模型与浏览器选区的同步。通过选区模型作为编辑器操作的范围目标，来实现编辑器的基础操作，例如插入、删除、格式化等操作，以及诸多选区相关的边界操作问题。</p>
<h2 id="每日一题">每日一题</h2>
<ul>
<li><a href="https://github.com/WindRunnerMax/EveryDay" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/EveryDay</a></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.w3.org/TR/selection-api/" target="_blank" rel="noopener nofollow">https://www.w3.org/TR/selection-api/</a></li>
<li><a href="https://juejin.cn/post/7068232010304585741" target="_blank" rel="noopener nofollow">https://juejin.cn/post/7068232010304585741</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Range</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Selection</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/children" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Element/children</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint" target="_blank" rel="noopener nofollow">https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.032025587752314816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-28 10:25">2025-05-28 10:25</span>&nbsp;
<a href="https://www.cnblogs.com/WindrunnerMax">WindRunnerMax</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18899981);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18899981', targetLink: 'https://www.cnblogs.com/WindrunnerMax/p/18899981', title: '从零实现富文本编辑器#4-浏览器选区模型核心交互策略' })">举报</a>
</div>
        