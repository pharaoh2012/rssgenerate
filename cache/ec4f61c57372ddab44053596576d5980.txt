
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18931148" title="发布于 2025-06-16 14:49">
    <span role="heading" aria-level="2">c++ 函数 类</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="一函数定义">一、函数定义</h1>
<p>在 C++ 中，<strong>函数</strong>是组织代码逻辑的基本单元，用于实现模块化、复用、结构清晰的程序设计。</p>
<hr>
<h2 id="1函数的基本结构">1、函数的基本结构</h2>
<pre><code class="language-cpp">返回类型 函数名(参数列表) {
    // 函数体
    return 值; // 可选，视返回类型而定
}
</code></pre>
<p><strong>声明（Declaration）：</strong></p>
<p>告诉编译器函数存在，通常放在头文件中：</p>
<pre><code class="language-cpp">int add(int a, int b);  // 函数声明
</code></pre>
<p><strong>定义（Definition）：</strong></p>
<p>提供函数实现，通常放在 <code>.cpp</code> 文件中：</p>
<pre><code class="language-cpp">int add(int a, int b) {
    return a + b;
}
</code></pre>
<hr>
<h2 id="2函数重载overload">2、函数重载（Overload）</h2>
<p>同一个函数名可以定义多个参数不同的函数：</p>
<pre><code class="language-cpp">void print(int x);
void print(double x);
void print(std::string s);
</code></pre>
<p>注意：<strong>参数数量或类型不同</strong>才能构成重载，返回类型不同不能单独构成重载。</p>
<hr>
<h2 id="3默认参数值">3、默认参数值</h2>
<pre><code class="language-cpp">void greet(std::string name = "Guest") {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!\n";
}

greet();         // 输出 Hello, Guest!
greet("Alice");  // 输出 Hello, Alice!
</code></pre>
<hr>
<h2 id="4内联函数inline">4、内联函数（<code>inline</code>）</h2>
<p>建议编译器将函数代码插入调用处，适用于短小频繁调用的函数。</p>
<pre><code class="language-cpp">inline int square(int x) {
    return x * x;
}
</code></pre>
<hr>
<h2 id="5虚函数与纯虚函数">5、虚函数与纯虚函数</h2>
<p>在 C++ 中，<strong>虚函数（<code>virtual</code>）</strong>和<strong>纯虚函数（<code>= 0</code>）</strong>是实现 <strong>多态性</strong> 的关键机制，但它们在语法、用途、作用上有所不同。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>虚函数（Virtual Function）</th>
<th>纯虚函数（Pure Virtual Function）</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义方式</td>
<td><code>virtual void foo();</code></td>
<td><code>virtual void foo() = 0;</code></td>
</tr>
<tr>
<td>是否有实现</td>
<td>✅ 可以有实现（也可以没有）</td>
<td>❌ 必须在子类中实现（抽象接口）</td>
</tr>
<tr>
<td>是否必须重写</td>
<td>❌ 子类可选是否重写</td>
<td>✅ 子类<strong>必须</strong>重写（除非子类也是抽象类）</td>
</tr>
<tr>
<td>所在类</td>
<td>可以在任何类中</td>
<td>必须出现在抽象类中（即包含纯虚函数的类）</td>
</tr>
<tr>
<td>创建对象</td>
<td>✅ 可以实例化含虚函数的类</td>
<td>❌ 抽象类不可被实例化</td>
</tr>
<tr>
<td>用途</td>
<td>提供多态行为的默认实现</td>
<td>强制子类实现，作为接口规范</td>
</tr>
</tbody>
</table>
<h3 id="-1-虚函数示例可重写">🔷 1. 虚函数示例（可重写）</h3>
<pre><code class="language-cpp">class Animal {
public:
    virtual void speak() {
        std::cout &lt;&lt; "Animal speaks\n";
    }
};

class Dog : public Animal {
public:
    void speak() override {
        std::cout &lt;&lt; "Dog barks\n";
    }
};

Animal* p = new Dog();
p-&gt;speak();  // 输出：Dog barks（多态）
</code></pre>
<p>🔸 如果 <code>Dog</code> 不重写 <code>speak()</code>，则会使用 <code>Animal</code> 的默认实现。</p>
<hr>
<h3 id="-2-纯虚函数示例强制重写">🔷 2. 纯虚函数示例（强制重写）</h3>
<pre><code class="language-cpp">class Shape {
public:
    virtual void draw() = 0;  // 纯虚函数
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing Circle\n";
    }
};

// Shape s;       // ❌ 错误，抽象类不能实例化
Shape* p = new Circle();
p-&gt;draw();        // 输出：Drawing Circle
</code></pre>
<p>🔸 若 <code>Circle</code> 不实现 <code>draw()</code>，它也将变为抽象类。</p>
<h3 id="接口类interface">接口类（interface）</h3>
<p>C++ 没有 <code>interface</code> 关键字，但你可以用纯虚函数模拟接口类：</p>
<pre><code class="language-cpp">class IStream {
public:
    virtual void read() = 0;
    virtual void write() = 0;
    virtual ~IStream() {}  // 接口类应定义虚析构
};
</code></pre>
<h2 id="6lambda-表达式c11-起">6、Lambda 表达式（C++11 起）</h2>
<pre><code class="language-cpp">[捕获列表](参数列表) -&gt; 返回类型 {
    函数体
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>[]</code>：捕获列表（可以捕获外部变量）</li>
<li><code>()</code>：参数列表</li>
<li><code>-&gt;</code>：返回类型（可省略）</li>
<li><code>{}</code>：函数体</li>
</ul>
<p>匿名函数，通常用于简洁回调：</p>
<pre><code class="language-cpp">auto add = [](int a, int b) -&gt; int {
    return a + b;
};
std::cout &lt;&lt; add(3, 5);  // 输出：8

//返回类型如果能推导，可以省略 `-&gt; int`：
auto add = [](int a, int b) {
    return a + b;
};
std::cout &lt;&lt; add(3, 4);  // 输出 7
</code></pre>
<p>Lambda 表达式是 C++11 引入的一种<strong>匿名函数</strong>，用于定义<strong>可内联的函数对象</strong>，特别适合临时、小巧的函数使用场景，如算法回调、事件处理、线程创建等。</p>
<h3 id="捕获外部变量capture">捕获外部变量（capture）</h3>
<table>
<thead>
<tr>
<th>捕获方式</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>值捕获</td>
<td><code>[x]</code></td>
<td>捕获变量 <code>x</code> 的值（拷贝）</td>
</tr>
<tr>
<td>引用捕获</td>
<td><code>[&amp;x]</code></td>
<td>捕获变量 <code>x</code> 的引用</td>
</tr>
<tr>
<td>捕获全部（值）</td>
<td><code>[=]</code></td>
<td>捕获所有外部变量的值</td>
</tr>
<tr>
<td>捕获全部（引用）</td>
<td><code>[&amp;]</code></td>
<td>捕获所有外部变量的引用</td>
</tr>
<tr>
<td>混合捕获</td>
<td><code>[=, &amp;y]</code></td>
<td>除 <code>y</code> 外其他变量值捕获</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">int x = 10;
int y = 5;

auto f = [=, &amp;y]() {
    // x 是值捕获，y 是引用捕获
    std::cout &lt;&lt; x + y &lt;&lt; "\n";
    y += 1;  // 允许修改 y
};

f();
</code></pre>
<hr>
<h3 id="常见应用场景">常见应用场景</h3>
<ol>
<li>与 STL 算法结合（如 <code>std::sort</code>）</li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {4, 2, 5, 1};
std::sort(v.begin(), v.end(), [](int a, int b) {
    return a &lt; b;
});
</code></pre>
<ol start="2">
<li>与线程一起使用：</li>
</ol>
<pre><code class="language-cpp">#include &lt;thread&gt;
std::thread t([] {
    std::cout &lt;&lt; "In thread\n";
});
t.join();
</code></pre>
<hr>
<h3 id="可变-lambdamutable">可变 lambda（<code>mutable</code>）</h3>
<p>默认情况下，值捕获的变量是不可修改的。加上 <code>mutable</code> 可以让其变为可变：</p>
<pre><code class="language-cpp">int x = 5;
auto f = [x]() mutable {
    x += 1;       // 允许修改捕获变量的副本
    std::cout &lt;&lt; x;
};
f();  // 输出 6，但外部 x 不变
</code></pre>
<h2 id="特殊函数类型">特殊函数类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造函数</td>
<td>创建对象时自动调用</td>
</tr>
<tr>
<td>析构函数</td>
<td>对象销毁时自动调用</td>
</tr>
<tr>
<td>拷贝构造函数</td>
<td>对象以另一个对象初始化时调用</td>
</tr>
<tr>
<td>移动构造函数</td>
<td>右值初始化对象时调用</td>
</tr>
<tr>
<td>运算符重载函数</td>
<td>重载 <code>+</code>, <code>==</code> 等</td>
</tr>
<tr>
<td>虚函数</td>
<td>用于多态</td>
</tr>
<tr>
<td>纯虚函数</td>
<td>抽象类成员函数</td>
</tr>
</tbody>
</table>
<h1 id="二函数参数值传递与引用传递">二、函数参数值传递与引用传递</h1>
<p>在 C++ 中，<strong>函数参数</strong>默认是<strong>值传递（pass-by-value）</strong>，但 <strong>并不都是值传递</strong>，C++ 支持多种参数传递方式，主要包括以下几种：</p>
<hr>
<h2 id="1-值传递pass-by-value">1. 值传递（Pass by Value）</h2>
<ul>
<li><strong>将实参的副本传入函数</strong></li>
<li>函数内对参数的修改不会影响原变量</li>
</ul>
<pre><code class="language-cpp">void foo(int x) {
    x = 100;
}

int main() {
    int a = 10;
    foo(a);
    std::cout &lt;&lt; a; // 输出 10，不变
}
</code></pre>
<hr>
<h2 id="2-引用传递pass-by-reference">2. 引用传递（Pass by Reference）</h2>
<ul>
<li>传入变量的别名，函数内对其修改会影响原变量</li>
</ul>
<pre><code class="language-cpp">void foo(int&amp; x) {
    x = 100;
}

int main() {
    int a = 10;
    foo(a);
    std::cout &lt;&lt; a; // 输出 100，被修改了
}
</code></pre>
<hr>
<h2 id="3-指针传递pass-by-pointer">3. 指针传递（Pass by Pointer）</h2>
<ul>
<li>函数接收变量的地址，通过指针访问和修改</li>
</ul>
<pre><code class="language-cpp">void foo(int* x) {
    *x = 100;
}

int main() {
    int a = 10;
    foo(&amp;a);
    std::cout &lt;&lt; a; // 输出 100
}
</code></pre>
<hr>
<h2 id="4-常引用传递pass-by-const-reference">4. 常引用传递（Pass by const Reference）</h2>
<ul>
<li>适用于<strong>避免拷贝开销</strong>，但又<strong>不允许函数修改实参</strong></li>
<li>常用于传递大型对象，如 <code>std::string</code>, <code>std::vector</code></li>
</ul>
<pre><code class="language-cpp">void print(const std::string&amp; s) {
    std::cout &lt;&lt; s;
}
</code></pre>
<hr>
<h2 id="5-右值引用pass-by-rvalue-referencec11">5. 右值引用（Pass by rvalue reference）C++11+</h2>
<ul>
<li>支持移动语义，避免不必要的深拷贝</li>
</ul>
<pre><code class="language-cpp">void foo(std::string&amp;&amp; s) {
    std::cout &lt;&lt; s;
}

foo("hello"s);  // 移动传参
</code></pre>
<hr>
<h3 id="小结对照表">小结对照表：</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>是否复制</th>
<th>是否可修改原变量</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>值传递</td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>小数据类型（int, float）</td>
</tr>
<tr>
<td>引用传递</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>需要修改原变量</td>
</tr>
<tr>
<td>指针传递</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>类似引用，但更灵活</td>
</tr>
<tr>
<td>const 引用传递</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>传大型对象且不修改</td>
</tr>
<tr>
<td>右值引用传递</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>支持移动，避免拷贝</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="结论">结论：</h2>
<blockquote>
<p>C++ 中函数参数<strong>默认是值传递</strong>，但你可以通过 <code>&amp;</code>（引用）、<code>*</code>（指针）或 <code>&amp;&amp;</code>（右值引用）来实现其他传参方式。</p>
</blockquote>
<h1 id="三构造函数-析构函数">三、构造函数 析构函数</h1>
<h2 id="构造函数constructor">构造函数Constructor</h2>
<p>构造函数是当<strong>对象被创建</strong>时自动调用的特殊函数，用于<strong>初始化对象的成员变量</strong>。</p>
<ul>
<li>名字与类名相同</li>
<li>没有返回值</li>
<li>可以有多个</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认构造函数</td>
<td>不带参数或所有参数有默认值</td>
</tr>
<tr>
<td>带参构造函数</td>
<td>用户提供初始化参数</td>
</tr>
<tr>
<td>拷贝构造函数</td>
<td>用已有对象创建新对象（传值方式）</td>
</tr>
<tr>
<td>移动构造函数（C++11）</td>
<td>用于资源“窃取”（效率更高）</td>
</tr>
<tr>
<td>委托构造函数（C++11）</td>
<td>在一个构造函数中调用另一个构造函数</td>
</tr>
</tbody>
</table>
<h2 id="拷贝构造函数-copy-constructor">拷贝构造函数 Copy Constructor</h2>
<p>如果你没有显式定义 <code>operator=()</code>，C++ 会默认生成一个浅拷贝的赋值运算符，对每个成员做成员赋值。但如果你类中包含裸指针等资源，默认赋值将产生<strong>浅拷贝问题</strong>（资源共享，析构冲突），此时应自定义赋值运算符。</p>
<p>拷贝构造作用：</p>
<ul>
<li>通过一个已有对象<strong>初始化另一个对象</strong></li>
<li>将对象<strong>按值传递</strong>给函数</li>
<li>函数<strong>按值返回对象</strong></li>
</ul>
<pre><code class="language-cpp">ClassName(const ClassName&amp; other);
</code></pre>
<blockquote>
<p>参数是 <code>const &amp;</code> 避免递归调用自身</p>
</blockquote>
<p>禁止拷贝构造：</p>
<pre><code class="language-cpp">// 在 C++11/14/17 中，推荐使用 `= default` 和 `= delete` 明确指定：
class MyClass {
public:
    MyClass() = default;
    MyClass(const MyClass&amp;) = delete;
    ~MyClass() = default;
};
</code></pre>
<h2 id="析构函数-destructor">析构函数 Destructor</h2>
<p>析构函数是在<strong>对象销毁时自动调用</strong>的特殊函数，用于<strong>释放资源、关闭文件、清理指针等</strong>。</p>
<ul>
<li>名字为 <code>~类名</code></li>
<li>没有参数，没有返回值</li>
<li>每个类最多只能有一个析构函数</li>
<li>可以是虚的（用于多态删除）</li>
</ul>
<h2 id="示例">示例</h2>
<p>将定义和实现全部写在头文件中的写法：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
public:
    std::string name;
    int* age;

    // ✅ 1. 默认构造函数（委托给带参构造）
    Person() : Person("unknown", 0) {
        std::cout &lt;&lt; "Default constructor called (delegated)\n";
    }

    // ✅ 2. 带参构造函数
    Person(const std::string&amp; name_, int age_) {
        name = name_;
        age = new int(age_);
        std::cout &lt;&lt; "Parameterized constructor called\n";
    }

    // ✅ 3. 拷贝构造函数（深拷贝）
    Person(const Person&amp; other) {
        name = other.name;
        age = new int(*other.age);
        std::cout &lt;&lt; "Copy constructor called\n";
    }

    // ✅ 4. 移动构造函数（C++11）
    Person(Person&amp;&amp; other) noexcept {
        name = std::move(other.name); // string 自带 move
        age = other.age;              // 窃取指针
        other.age = nullptr;          // 避免析构 double free
        std::cout &lt;&lt; "Move constructor called\n";
    }

    // ✅ 5. 析构函数
    ~Person() {
        std::cout &lt;&lt; "Destructor called for " &lt;&lt; name &lt;&lt; "\n";
        delete age;
    }
};


</code></pre>
<p>现代c++推荐头文件和源文件分离，分离的写法：</p>
<pre><code class="language-cpp">// Person.h
#ifndef PERSON_H
#define PERSON_H

#include &lt;string&gt;

class Person {
public:
    std::string name;
    int* age;
	// ✅ 1.默认构造函数
    Person();
    // ✅ 2.带参构造函数
    Person(const std::string&amp; name_, int age_);
    // ✅ 3.拷贝构造函数（深拷贝）
    Person(const Person&amp; other);
    // ✅ 4.移动构造函数（C++11）
    Person(Person&amp;&amp; other) noexcept;
    // ✅ 5.析构函数
    virtual ~Person();
    
	// 拷贝赋值运算符（可选）
    Person&amp; operator=(const Person&amp; other);
    // 移动赋值运算符（可选）
    Person&amp; operator=(Person&amp;&amp; other) noexcept;

    // ✅ const表示该函数不会修改类成员变量，如果在常函数里修改成员变量会报错
    virtual void introduce() const;
};

#endif

</code></pre>
<pre><code class="language-cpp">// Person.cpp
#include "Person.h"
#include &lt;iostream&gt;

// ✅ 1.默认构造函数
Person::Person() : Person("unknown", 0) {
    std::cout &lt;&lt; "Default constructor called\n";
}

// ✅ 2.带参构造函数
Person::Person(const std::string&amp; name_, int age_) {
    name = name_;
    age = new int(age_);
    std::cout &lt;&lt; "Parameterized constructor called\n";
}

// ✅ 3.拷贝构造函数（深拷贝）
Person::Person(const Person&amp; other) {
    name = other.name;
    age = new int(*other.age);
    std::cout &lt;&lt; "Copy constructor called\n";
}

// ✅ 4.移动构造函数（C++11）
Person::Person(Person&amp;&amp; other) noexcept {
    name = std::move(other.name);
    age = other.age;
    other.age = nullptr;
    std::cout &lt;&lt; "Move constructor called\n";
}

// ✅ 5.析构函数
Person::~Person() {
    std::cout &lt;&lt; "Person destructor called for " &lt;&lt; name &lt;&lt; "\n";
    delete age;
}

// 拷贝赋值运算符（可选）
Person&amp; Person::operator=(const Person&amp; other) {
    if (this != &amp;other) {
        name = other.name;
        delete age;
        age = new int(*other.age);
    }
    return *this;
}

// 移动赋值运算符（可选）
Person&amp; Person::operator=(Person&amp;&amp; other) noexcept {
    if (this != &amp;other) {
        name = std::move(other.name);
        delete age;
        age = other.age;
        other.age = nullptr;
    }
    return *this;
}

void Person::introduce() const {
    std::cout &lt;&lt; "Hi, I am " &lt;&lt; name &lt;&lt; ", age " &lt;&lt; *age &lt;&lt; ".\n";
}
</code></pre>
<h2 id="默认构造拷贝析构行为总结">默认构造/拷贝/析构行为总结</h2>
<table>
<thead>
<tr>
<th>函数类型</th>
<th>是否自动生成</th>
<th>什么时候需要自定义？</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造函数</td>
<td>✅（如果没写）</td>
<td>成员需要特殊初始化逻辑时</td>
</tr>
<tr>
<td>拷贝构造函数</td>
<td>✅（如果没写）</td>
<td>含指针资源、句柄或禁止拷贝</td>
</tr>
<tr>
<td>析构函数</td>
<td>✅（如果没写）</td>
<td>成员包含动态资源（如 new）时需释放</td>
</tr>
<tr>
<td>移动构造函数</td>
<td>❌（C++11+）</td>
<td>优化效率或防止拷贝</td>
</tr>
</tbody>
</table>
<ul>
<li>如果你<strong>不写</strong>，编译器会<strong>自动生成</strong>一个“浅拷贝”版本。</li>
<li>如果类中有<strong>裸指针</strong>，一定要自己写拷贝构造，否则可能引发<strong>双重释放</strong>错误。</li>
</ul>
<h2 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h2>
<p>C++ 中的 <strong>深拷贝（deep copy）</strong> 与 <strong>浅拷贝（shallow copy）</strong> 是对象复制时的两种方式，区别在于是否真正复制了堆上资源。理解这两者对掌握类的构造函数、拷贝构造函数和析构函数至关重要。</p>
<h3 id="一定义和区别">一、定义和区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>浅拷贝（Shallow Copy）</th>
<th>深拷贝（Deep Copy）</th>
</tr>
</thead>
<tbody>
<tr>
<td>拷贝内容</td>
<td>只复制指针的地址</td>
<td>分配新内存并复制数据内容</td>
</tr>
<tr>
<td>资源共享</td>
<td>原对象和副本指向同一内存</td>
<td>原对象和副本各自拥有独立内存</td>
</tr>
<tr>
<td>安全性</td>
<td>❌ 改变一个对象会影响另一个；易发生悬垂指针、双重释放</td>
<td>✅ 对象互不影响</td>
</tr>
<tr>
<td>析构风险</td>
<td>❌ 多次析构同一块内存（如果未正确管理）</td>
<td>✅ 每个对象析构各自拥有的内存</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="二示例演示">二、示例演示</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

class Person {
public:
    char* name;

    // 构造函数
    Person(const char* n) {
        name = new char[strlen(n) + 1];
        strcpy(name, n);
    }

    // 浅拷贝构造函数（默认）
    // Person(const Person&amp; other) = default;

    // ✅ 深拷贝构造函数
    Person(const Person&amp; other) {
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
    }

    // 析构函数
    ~Person() {
        delete[] name;
    }

    void print() {
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; std::endl;
    }
};
</code></pre>
<p>如果不写深拷贝构造函数，编译器默认使用浅拷贝，即只是复制了指针 <code>name</code> 的地址，两个对象共用同一块堆内存。这样一来，修改 <code>p2.name</code> 会影响 <code>p1.name</code>，两个对象析构时还会<strong>重复释放</strong>同一块内存，导致崩溃。</p>
<hr>
<h3 id="三默认拷贝行为说明">三、默认拷贝行为说明</h3>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>默认行为</th>
<th>是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>拷贝构造函数</td>
<td>浅拷贝</td>
<td>❌</td>
</tr>
<tr>
<td>赋值运算符 <code>=</code></td>
<td>浅赋值</td>
<td>❌</td>
</tr>
<tr>
<td>析构函数</td>
<td>默认释放</td>
<td>❌（若使用裸指针）</td>
</tr>
</tbody>
</table>
<h2 id="const在类中的作用">const在类中的作用</h2>
<p><code>const</code> 可以修饰<strong>类的成员函数</strong>、<strong>函数参数与返回值</strong>和对象，但它<strong>不能直接修饰整个类本身</strong>。</p>
<hr>
<h3 id="const-修饰函数常成员函数"><code>const</code> <strong>修饰函数</strong>（常成员函数）</h3>
<pre><code class="language-cpp">class MyClass {
public:
    int getValue() const; // ✅ 表示该函数不会修改类成员变量
private:
    int value = 42;
};
int MyClass::getValue() const {
    // this-&gt;value = 10; ❌ 编译错误：不能修改成员变量
    return value;
}
</code></pre>
<pre><code class="language-cpp">const MyClass obj;   // ✅ **只能调用 const 成员函数**
MyClass obj2;        // ✅ **既可以调用 const 成员函数，也可以调用非常成员函数**
</code></pre>
<hr>
<h3 id="const-修饰函数参数和返回值"><code>const</code> 修饰函数参数和返回值</h3>
<p>修饰参数</p>
<pre><code class="language-cpp">void printName(const std::string&amp; name); // ✅ 避免拷贝 + 保证不修改参数
</code></pre>
<p>修饰返回值</p>
<pre><code class="language-cpp">const std::string&amp; getName() const; // ✅ 返回值不能被修改（防止误用）
</code></pre>
<blockquote>
<p>注意：<code>const</code> 修饰<strong>返回值</strong>时，通常用于<strong>返回引用或指针</strong>，不太常用于值返回。</p>
</blockquote>
<hr>
<h3 id="不能直接修饰类">不能直接修饰类</h3>
<pre><code class="language-cpp">const class MyClass {}; // ❌ 不常见，基本无意义
</code></pre>
<h1 id="四继承">四、继承</h1>
<p>基类函数用 <code>virtual</code> 修饰，子类可以 <code>override</code> 它</p>
<h2 id="继承方式-修饰符可见性">继承方式 修饰符可见性</h2>
<p>c++ Java中的继承方式是完全一样的，继承方式</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>基类的 <code>public</code> 成员在子类中变成</th>
<th>基类的 <code>protected</code> 成员在子类中变成</th>
<th>基类的 <code>private</code> 成员</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code> 继承</td>
<td><code>public</code></td>
<td><code>protected</code></td>
<td>❌ 不可访问</td>
</tr>
<tr>
<td><code>protected</code> 继承</td>
<td><code>protected</code></td>
<td><code>protected</code></td>
<td>❌ 不可访问</td>
</tr>
<tr>
<td><code>private</code> 继承</td>
<td><code>private</code></td>
<td><code>private</code></td>
<td>❌ 不可访问</td>
</tr>
</tbody>
</table>
<p>可见性</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内访问</th>
<th>派生类访问</th>
<th>类外访问</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>✅ 可访问</td>
<td>✅ 可访问</td>
<td>✅ 可访问</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✅ 可访问</td>
<td>✅ 可访问</td>
<td>❌ 不可访问</td>
</tr>
<tr>
<td><code>private</code></td>
<td>✅ 可访问</td>
<td>❌ 不可访问</td>
<td>❌ 不可访问</td>
</tr>
</tbody>
</table>
<h2 id="示例-1">示例</h2>
<pre><code class="language-cpp">//student.h
#ifndef STUDENT_H
#define STUDENT_H

#include "Person.h" 

class Student : public Person {
public:
    std::string school;

    Student();
    Student(const std::string&amp; name_, int age_, const std::string&amp; school_);
    ~Student() override;

    void introduce() const override;
};

#endif
</code></pre>
<pre><code class="language-cpp">//student.cpp
#include "Student.h"
#include &lt;iostream&gt;

Student::Student() : Person("unknown_student", 18), school("Unknown School") {
    std::cout &lt;&lt; "Student default constructor\n";
}

Student::Student(const std::string&amp; name_, int age_, const std::string&amp; school_)
    : Person(name_, age_), school(school_) {
    std::cout &lt;&lt; "Student parameterized constructor\n";
}

Student::~Student() {
    std::cout &lt;&lt; "Student destructor called for " &lt;&lt; name &lt;&lt; "\n";
}

void Student::introduce() const {
    std::cout &lt;&lt; "Hi, I am student " &lt;&lt; name &lt;&lt; ", age " &lt;&lt; *age
              &lt;&lt; ", studying at " &lt;&lt; school &lt;&lt; ".\n";
}
</code></pre>
<h2 id="构造函数和析构函数的顺序">构造函数和析构函数的顺序</h2>
<ul>
<li><strong>构造顺序</strong>：先构造基类 → 再构造派生类</li>
<li><strong>析构顺序</strong>：先析构派生类 → 再析构基类</li>
</ul>
<pre><code class="language-cpp">class Base {
public:
    Base() { std::cout &lt;&lt; "Base()\n"; }
    ~Base() { std::cout &lt;&lt; "~Base()\n"; }
};

class Derived : public Base {
public:
    Derived() { std::cout &lt;&lt; "Derived()\n"; }
    ~Derived() { std::cout &lt;&lt; "~Derived()\n"; }
};
</code></pre>
<p>输出顺序：</p>
<pre><code>Base()
Derived()
~Derived()
~Base()
</code></pre>
<h2 id="c特有多继承与虚继承-菱形继承问题">C++特有：多继承与虚继承 菱形继承问题</h2>
<h3 id="多继承">多继承</h3>
<pre><code class="language-cpp">class A { public: int x; };
class B { public: int x; };
class C : public A, public B {};  // 多继承，C 有两个 x，需区分 A::x 和 B::x
</code></pre>
<p>“<strong>菱形继承问题（Diamond Problem）</strong>”是 C++ 多继承中特有的一种<strong>继承结构冲突问题</strong>，会导致：</p>
<ol>
<li><strong>基类子对象重复</strong></li>
<li><strong>数据二义性 / 歧义访问</strong></li>
<li><strong>构造和析构混乱</strong></li>
<li><strong>资源浪费</strong></li>
</ol>
<hr>
<h3 id="一什么是菱形继承结构">一、什么是菱形继承结构？</h3>
<p>如下图所示，<code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，而 <code>D</code> 同时继承自 <code>B</code> 和 <code>C</code>：</p>
<pre><code class="language-cpp">      A
     / \
    B   C
     \ /
      D
class A {
public:
    int value;
};

class B : public A {};
class C : public A {};
class D : public B, public C {};
</code></pre>
<hr>
<h3 id="二菱形继承引发的问题">二、菱形继承引发的问题</h3>
<h4 id="1-产生-多个-a-子对象">1. 产生 <strong>多个 A 子对象</strong></h4>
<p>在 <code>D</code> 中包含了 <strong>两个 A 对象</strong>：</p>
<ul>
<li>一个来自 <code>B</code>（B→A）</li>
<li>一个来自 <code>C</code>（C→A）</li>
</ul>
<h4 id="2-访问-value-发生歧义">2. 访问 <code>value</code> 发生歧义</h4>
<pre><code class="language-cpp">D d;
d.value = 10; // ❌ 错误：编译器不知道是 B::A::value 还是 C::A::value
</code></pre>
<p>必须手动指定：</p>
<pre><code class="language-cpp">d.B::value = 10;
d.C::value = 20;
</code></pre>
<hr>
<h3 id="三解决方法虚继承virtual">三、解决方法：虚继承（<code>virtual</code>）</h3>
<p>用 <code>virtual</code> 修饰继承关系，让 <strong>B 和 C 共享同一个 A 子对象</strong>。</p>
<pre><code class="language-cpp">class A {
public:
    int value;
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
</code></pre>
<h4 id="虚继承效果">虚继承效果：</h4>
<ul>
<li><code>D</code> 中只有 <strong>一个 A 对象</strong>，由编译器自动协调</li>
<li>访问成员不再歧义：</li>
</ul>
<pre><code class="language-cpp">D d;
d.value = 10; // ✅ 正常访问，无歧义
</code></pre>
<h1 id="五友元">五、友元</h1>
<p>在 C++ 中，<strong>友元（friend）</strong>机制允许非成员函数或其他类访问某个类的私有（<code>private</code>）和受保护（<code>protected</code>）成员。友元关系是 <strong>单向</strong>、<strong>不传递</strong> 的，常用于操作符重载、调试工具或两个类之间的紧密协作等场景。</p>
<hr>
<h2 id="一友元的三种形式">一、友元的三种形式</h2>
<h3 id="1-友元函数friend-function">1. 友元函数（Friend Function）</h3>
<pre><code class="language-cpp">class Box {
private:
    int width;
public:
    Box(int w) : width(w) {}

    // 声明友元函数
    friend void printWidth(const Box&amp; b);
};

// 非成员函数，可以访问 Box 的私有成员
void printWidth(const Box&amp; b) {
    std::cout &lt;&lt; "Width: " &lt;&lt; b.width &lt;&lt; std::endl;
}
</code></pre>
<p>🔸<strong>特点</strong>：</p>
<ul>
<li>非类成员函数，但拥有类的访问权限</li>
<li>常用于重载 <code>operator&lt;&lt;</code> 等操作符</li>
</ul>
<hr>
<h3 id="2-友元类friend-class">2. 友元类（Friend Class）</h3>
<pre><code class="language-cpp">class Engine;

class Car {
private:
    int speed;
public:
    Car(int s) : speed(s) {}
    friend class Engine;  // Engine 可以访问 Car 的私有成员
};

class Engine {
public:
    void showSpeed(const Car&amp; c) {
        std::cout &lt;&lt; "Speed: " &lt;&lt; c.speed &lt;&lt; std::endl;
    }
};
</code></pre>
<p>🔸<strong>特点</strong>：</p>
<ul>
<li>一个类可以将另一个类声明为友元</li>
<li>该友元类的<strong>所有成员函数</strong>都能访问被友元类的私有成员</li>
<li><strong>单向</strong>：Engine 是 Car 的朋友，但 Car 不可访问 Engine 的私有成员</li>
</ul>
<hr>
<h3 id="3-成员函数作为友元">3. 成员函数作为友元</h3>
<pre><code class="language-cpp">class B;

class A {
private:
    int a_val;
public:
    A(int v) : a_val(v) {}
    friend void B::printA(const A&amp; a);  // 只让 B 的某个成员函数成为友元
};

class B {
public:
    void printA(const A&amp; a) {
        std::cout &lt;&lt; a.a_val &lt;&lt; std::endl;
    }
};
</code></pre>
<p>注意：这种方式必须 <strong>先声明 B 类</strong>，否则编译器不知道 <code>B::printA</code> 是什么。</p>
<hr>
<h2 id="二友元的特性总结">二、友元的特性总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单向访问</td>
<td>被声明为友元的类/函数可以访问声明类的私有成员，反之不行</td>
</tr>
<tr>
<td>非成员也可声明为友元</td>
<td>普通函数、类、类的成员函数都可以作为友元</td>
</tr>
<tr>
<td>不破坏封装性</td>
<td>尽管能访问私有成员，但访问范围被<strong>显式限定</strong></td>
</tr>
<tr>
<td>编译时绑定</td>
<td>友元关系在编译时建立，无法在运行时动态设置</td>
</tr>
<tr>
<td>不继承、不传递</td>
<td>子类不会继承友元权限，友元类的友元也无访问权</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三示例重载--运算符">三、示例：重载 <code>&lt;&lt;</code> 运算符</h2>
<pre><code class="language-cpp">class Person {
private:
    std::string name;
    int age;
public:
    Person(std::string n, int a) : name(n), age(a) {}
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p);
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Person&amp; p) {
    os &lt;&lt; "Name: " &lt;&lt; p.name &lt;&lt; ", Age: " &lt;&lt; p.age;
    return os;
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18931148" target="_blank">https://www.cnblogs.com/aslanvon/p/18931148</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-16 14:50">2025-06-16 14:49</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18931148);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18931148', targetLink: 'https://www.cnblogs.com/aslanvon/p/18931148', title: 'c++ 函数 类' })">举报</a>
</div>
        