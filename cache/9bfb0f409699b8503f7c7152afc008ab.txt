
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/18715636" title="发布于 2025-02-14 16:34">
    <span role="heading" aria-level="2">SSE进行消息推送保证你看的清清楚楚</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1425695/202502/1425695-20250214162723139-1193065204.jpg" alt="" loading="lazy"></p>
<h4 id="sse简介">SSE简介</h4>
<p>SSE(Server-Sent Events)是一种实现服务器主动向客户端推送数据的技术,也称为 “事件流”。<br>
它基于 HTTP 协议,是一个get请求。<br>
利用了其长连接特性,从而实现:服务器向客户端的实时数据推送。<br>
但客户端不能通过 SSE 向服务端发送数据。因此它是单向通信的。<br>
SSE 的连接状态仅有三种：已连接、连接中、已断开。<br>
连接状态是由浏览器自动维护的,客户端无法手动关闭或重新打开连接。</p>
<h4 id="eventsource-的连接状态">eventSource 的连接状态</h4>
<p>readyState 属性表示当前 EventSource 对象的状态。<br>
它是一个只读属性，它的值有以下几个：<br>
CONNECTING：表示正在和服务器建立连接。此时:readyState的值是0</p>
<p>OPEN：表示已经建立连接，正在接收服务器发送的数据。<br>
此时:readyState的值是1</p>
<p>CLOSED：表示连接已经被关闭，无法再接收服务器发送的数据。<br>
此时:readyState的值是2</p>
<h4 id="sse-和-websocket-的区别">SSE 和 WebSocket 的区别</h4>
<p>1.通信方式不同: SSE是单向通信的。WebSocket是双向通信的。<br>
2.协议不同: SSE基于HTTP协议,是一个get请求。WebSocket 一般基于TCP协议。<br>
3.跨域问题:SSE是不能够跨域的(HTTP协议,get请求)。 WebSocket 是可以跨域的。<br>
4.重连机制:SSE浏览器会自动重连。WebSocket需要手动实现重连机制<br>
5.传输数据不同: SSE只能够传输纯文本,不支持直接发送二进制数据。WebSocket支持发送文本和二进制数据。</p>
<h4 id="服务端基本响应格式">服务端基本响应格式</h4>
<p>event：自定义事件类型。客户端可以根据不同的事件类型来执行不同的操作。<br>
id：事件的唯一标识符。客户端可以使用这个ID来恢复事件流。<br>
retry：建议的重新连接时间（毫秒）。如果连接中断，客户端将等待这段时间后尝试重新连接。<br>
data:事件的数据。如果数据跨越多行，每行都应该以data:开始。"data:" + "内容" + "\n\n"</p>
<h4 id="ressetheaderconnection-keep-alive">res.setHeader("Connection", "keep-alive");</h4>
<p>在HTTP/1.1协议中,Connection头用于控制网络连接的持久性。<br>
即是否保持TCP连接打开以后,便于后续的请求和响应可以通过同一个连接发送。<br>
而不是每个请求都建立一个新的连接。<br>
这样助于减少建立和关闭TCP连接所需的时间和资源，从而提高性能。<br>
在HTTP/1.1中,默认情况下连接就是持久性的(keep-alive)，除非特别指定为close。<br>
但一些旧的HTTP/1.0客户端或代理中，可能需要显式设置Connection: keep-alive头来请求持久连接。<br>
对于现代的Web应用来说，通常不需要手动设置这个头，因为大多数客户端和服务器都默认支持持久连接。<br>
小提醒：如果你不确认http版本，那就加上。<br>
否则会出现没有保持持久连接的情况下，每次隔一次请求就要重新连接一次，图表/表格/页面刷新会不流畅。</p>
<h4 id="ressetheadercache-control-no-cache">res.setHeader("Cache-Control", "no-cache");</h4>
<p>控制客户端（如浏览器）和中间代理服务器对响应的缓存行为。<br>
允许缓存，但强制验证。<br>
客户端或代理服务器可以缓存响应，但在每次使用缓存前,必须进行校验。<br>
如果服务器确认缓存有效，则使用缓存；否则返回新数据。<br>
或者说:防止使用过期缓存,确保客户端不会直接使用本地缓存,而是始终与服务器确认数据的最新性。<br>
它的适用场景:<br>
动态数据：如实时更新的内容（股票价格、新闻推送）。<br>
个性化内容：如用户特定的数据（购物车、个人资料）。<br>
SSE:确保客户端不会缓存事件流数据。</p>
<h4 id="ngix配置问题">ngix配置问题</h4>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202502/1425695-20250214162822496-1634962106.png" alt="" loading="lazy"></p>
<h4 id="sse实现消息推送">SSE实现消息推送</h4>
<p>我们后端来使用node+express来实现一下SSE消息推送。<br>
我们需要创建一个 express项目,然后安装express和cors。<br>
然后我们创建 routes/sse/infoPush.js文件。<br>
这个文件用来实现SSE消息推送。<br>
1.我们需要告诉客户端消息类型<br>
2.告诉浏览器不要直接使用缓存中的资源<br>
3.使用setInterval不断发送消息<br>
4.设置事件类型event和事件名称sseEvent<br>
5.给每个事件分配一个唯一的标识符<br>
6.客户端与服务器之间的连接意外关闭,等待多长时间尝试重新连接<br>
7.构建SSE消息："data: " + 消息 + "\n\n"<br>
8.当客户端点击关闭时,我们清除定时器，并且结束推送</p>
<pre><code>// app.js
const express=require("express");
const path=require("path")
// 处理跨域的插件
const cors = require('cors')
// SSE相关信息路由 
const sseInfoRouter = require('./routes/sse/infoPush'); 
const app= express();
// 使用跨域插件
app.use(cors())
// 当以/public/ 开头的时候，去./public/ 目录中去找对应的资源
app.use(express.static(path.join(__dirname, '/public')));
app.use('/sse', sseInfoRouter);

//端口
app.listen(3000,function () {
  console.log("127.0.0.1:3000")
});
</code></pre>
<pre><code>// routes/sse/infoPush.js 文件
const express = require("express");
const router = express.Router();
router.get("/ai/question/push", (req, res) =&gt; {
  // 设置 SSE 响应类型(告诉客户端响应类型，这是一个SSE事件流)
  res.setHeader("Content-Type", "text/event-stream;charset=utf-8");
  /**
   * 告诉浏览器不要直接使用缓存中的资源，而是应该向服务器发送请求来检查该资源是否有更新。
   * 确保用户获取到最新内容是非常有用，尤其是在内容频繁更新的Web应用中。
   * */ 
  res.setHeader("Cache-Control", "no-cache");
  // 用于控制网络连接的持久性。
  res.setHeader("Connection", "keep-alive");
  // 告诉浏览器，来自任何源的请求都可以被接受并访问该资源。可以跨域
  res.setHeader("Access-Control-Allow-Origin", "*");
  let index = 0;
  const timer = setInterval(() =&gt; {
    /**
     * 下面的res.write(event:sseEvent\n) 需要和客户端保持一致。
     * 它表示的是事件类型event和事件名称sseEvent
     * sse.addEventListener("sseEvent", (event) =&gt; { })
     * 也就是说：需要和前端的addEventListener事件监听名称一样
     * */ 
    res.write(`event:sseEvent\n`);
    // id 字段是SSE消息的一个可选部分，它允许为每个事件分配一个唯一的标识符。
    res.write(`id:${index}\n`);
    /**
     * 我们向SSE响应中添加一个 retry 字段，
     * retry 字段指定如果客户端与服务器之间的连接意外关闭，
     * 客户端在尝试重新连接之前应该等待的时间(以毫秒为单位)
     * 这里我们设置等待5s后重新连接
     * */ 
    res.write(`retry: 5000\n`);
    /**
     * 构建SSE消息："data: " + 消息 + "\n\n"
     * 两个连续的换行符 \n\n，表示消息的结束
     * */ 
    res.write("data: " + JSON.stringify({ content: new Date() }) + "\n\n");
    index++;
    console.log(index)
  }, 1000);

  // 当客户端点击关闭时,我们清除定时器，并且结束推送
  req.on("close", () =&gt; {
    clearInterval(timer);
    res.end();
  });
});

module.exports = router;
</code></pre>
<h4 id="eventsource-构造函数的介绍">EventSource() 构造函数的介绍</h4>
<p>EventSource 对象是 HTML5 新增的一个客户端 API。<br>
用于服务器实时推送数据到客户端,它是单向的。</p>
<pre><code>const eventSource = new EventSource(url, options);
</code></pre>
<p>参数url:必填,建立起与服务器的连接，并开始接收服务器发送的数据<br>
参数options：Object 类型，表示可选参数。<br>
withCredentials：Boolean 类型，表示是否允许发送 Cookie 和 HTTP 认证信息。默认为 false。<br>
下面这2个参数都是没有的，我看见有些博客写了，但是我在mdn上，并没有看见。<br>
headers：Object 类型，表示要发送的请求头信息。  [没有这个参数]<br>
retryInterval：Number 类型，表示与服务器失去连接后，重新连接的时间间隔。默认为 1000 毫秒。[没有这个参数]</p>
<h4 id="使用eventsource接收数据并渲染">使用EventSource接收数据并渲染</h4>
<pre><code>&lt;template&gt;
  &lt;div class="chat-box"&gt;
    &lt;button @click="startConnectHandler"&gt;建立连接&lt;/button&gt;
    &lt;button @click="endConnectHandler"&gt;关闭连接&lt;/button&gt;
    &lt;h2&gt;
      连接状态{{ stateData }}
    &lt;/h2&gt;
    &lt;h2&gt;下面就是返回来的数据&lt;/h2&gt;
    &lt;div&gt;
      &lt;div v-for="(item, index) in list" :key="index"&gt;
        {{ item }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      eventSource: null,
      stateData: null,
      list: [],
      connectStatus:false,
    };
  },
  created() {},
  methods: {
    startConnectHandler() {
      let url = "http://127.0.0.1:3000/sse/ai/question/push?title=请你介绍一下SSE？";
      // 表示与服务器建立连接的 URL。必填。
      const sseObj  = new EventSource(url);
      this.eventSource = sseObj;
      console.log('状态',sseObj,this.eventSource)
      
      if (sseObj.readyState === 0) {
        //sseObj.readyState === EventSource.CONNECTING 也可以判断正在连接服务器
        console.log('0:"正在连接服务器...');
      } 
      
      sseObj.onopen = (e) =&gt; {
        if(sseObj.readyState === 1){
          // sseObj.readyState === EventSource.OPEN 也可以判断连接成功
          let data = `SSE 连接成功，状态${ sseObj.readyState}, 对象${e}`;
          this.stateData = data;
          console.log("1:SSE 连接成功");
        }
      };
      // 接收消息，这个事件需要和后端保持一致哈
      // 后端的事件名称：sseEvent
      sseObj.addEventListener("sseEvent", (event) =&gt; {
        const data = JSON.parse(event.data);
        this.list.push(data.content);
        console.log("这次消息推送的内容event:", event);
      });
      sseObj.onerror = (e) =&gt; {
        console.log("error", e);
      };
    },
    endConnectHandler() {
      if(this.eventSource){
        this.eventSource.close();
        if(this.eventSource.readyState === 2) {
          // sseObj.readyState === EventSource.CLOSED 也可以判断连接已经关闭
          console.log('2连接已经关闭。',this.eventSource, this.eventSource.readyState);
        }
        console.log("end");
      }
    },
  },
};
&lt;/script&gt;
&lt;style scoped&gt;
.chat-box{
  padding-left: 20px;
  padding-top: 20px;
  button{
    margin-right: 20px;
    padding: 6px;
  }
}
&lt;/style&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202502/1425695-20250214162837708-1687384568.gif" alt="" loading="lazy"></p>
<h4 id="我们多次点击出问题">我们多次点击出问题</h4>
<p>我们发现多次点击出现了问题。无法正常关闭。<br>
为啥会出现这样的问题：因为多次点击创建了多个实例对象。<br>
在关闭的时候关闭的是最后一个，前面的那些都没有正常关闭。<br>
解决办法:<br>
1.创建连接后给创建按钮禁用。<br>
2.使用单例模式</p>
<h4 id="避免多次重复连接创建连接后给按钮禁用">避免多次重复连接:创建连接后给按钮禁用</h4>
<pre><code>&lt;template&gt;
  &lt;div class="chat-box"&gt;
    &lt;button @click="startConnectHandler" :disabled="connectStatus" &gt;建立连接&lt;/button&gt;
    &lt;button @click="endConnectHandler"&gt;关闭连接&lt;/button&gt;
    &lt;h2&gt;
      &lt;p&gt;连接状态{{ this.eventSource &amp;&amp; this.eventSource.readyState }}&lt;/p&gt; 
    &lt;/h2&gt;
    &lt;h2&gt;下面就是返回来的数据&lt;/h2&gt;
    &lt;div&gt;
      &lt;div v-for="(item, index) in list" :key="index"&gt;
        {{ item }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      eventSource: null,
      stateData: null,
      list: [],
      connectStatus:false,
    };
  },
  created() {},
  methods: {
    startConnectHandler() {
      let url = "http://127.0.0.1:3000/sse/ai/question/push?title=请你介绍一下SSE？";
      
      // 表示与服务器建立连接的 URL。必填。
      const sseObj  = new EventSource(url);
      this.eventSource = sseObj;
      console.log('状态',sseObj,this.eventSource)
      
      if (sseObj.readyState === 0) {
        this.connectStatus = true
        //sseObj.readyState === EventSource.CONNECTING 也可以判断正在连接服务器
        console.log('0:"正在连接服务器...');
      } 
      
      sseObj.onopen = (e) =&gt; {
        if(sseObj.readyState === 1){
          // sseObj.readyState === EventSource.OPEN 也可以判断连接成功
          let data = `SSE 连接成功，状态${ sseObj.readyState}, 对象${e}`;
          this.stateData = data;
          console.log("1:SSE 连接成功");
        }
      };
      // 接收消息，这个事件需要和后端保持一致哈
      // 后端的事件名称：sseEvent
      sseObj.addEventListener("sseEvent", (event) =&gt; {
        const data = JSON.parse(event.data);
        this.list.push(data.content);
        console.log("这次消息推送的内容event:", event);
      });
      sseObj.onerror = (e) =&gt; {
        console.log("error", e);
      };
    },
    endConnectHandler() {
      if(this.eventSource){
        this.connectStatus = false
        this.eventSource.close();
        if(this.eventSource.readyState === 2) {
          // sseObj.readyState === EventSource.CLOSED 也可以判断连接已经关闭
          console.log('2连接已经关闭。',this.eventSource, this.eventSource.readyState);
        }
        console.log("end");
      }
    },
  },
};
&lt;/script&gt;
&lt;style scoped&gt;
.chat-box{
  padding-left: 20px;
  padding-top: 20px;
  button{
    margin-right: 20px;
    padding: 6px;
  }
}
&lt;/style&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202502/1425695-20250214162859259-391357924.gif" alt="" loading="lazy"></p>
<h4 id="推送完消息如何断开完整版">推送完消息如何断开[完整版]</h4>
<p>前后端约定一个字段表示已经推送结束。<br>
当前端检测到后，就认为已经结束推送结束,然后关闭连接。</p>
<pre><code>&lt;template&gt;
  &lt;div class="chat-box"&gt;
    &lt;button @click="startConnectHandler" :disabled="connectStatus" &gt;建立连接&lt;/button&gt;
    &lt;button @click="endConnectHandler"&gt;关闭连接&lt;/button&gt;
    &lt;h2&gt;
      &lt;p&gt;连接状态{{ this.eventSource &amp;&amp; this.eventSource.readyState }}&lt;/p&gt; 
    &lt;/h2&gt;
    &lt;h2&gt;下面就是返回来的数据&lt;/h2&gt;
    &lt;div&gt;
      &lt;div v-for="(item, index) in list" :key="index"&gt;
        {{ item }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      eventSource: null,
      stateData: null,
      list: [],
      connectStatus:false,
    };
  },
  created() {},
  methods: {
    startConnectHandler() {
      let url = "http://127.0.0.1:3000/sse/ai/question/push?title=请你介绍一下SSE？";
      
      // 表示与服务器建立连接的 URL。必填。
      const sseObj  = new EventSource(url);
      this.eventSource = sseObj;
      console.log('状态',sseObj,this.eventSource)
      
      if (sseObj.readyState === 0) {
        this.connectStatus = true
        //sseObj.readyState === EventSource.CONNECTING 也可以判断正在连接服务器
        console.log('0:"正在连接服务器...');
      } 
      
      sseObj.onopen = (e) =&gt; {
        if(sseObj.readyState === 1){
          // sseObj.readyState === EventSource.OPEN 也可以判断连接成功
          let data = `SSE 连接成功，状态${ sseObj.readyState}, 对象${e}`;
          this.stateData = data;
          console.log("1:SSE 连接成功");
        }
      };
      // 接收消息，这个事件需要和后端保持一致哈
      // 后端的事件名称：sseEvent
      sseObj.addEventListener("sseEvent", (event) =&gt; {
        const data = JSON.parse(event.data);
        //如果最后推送的是 'contDnd',说明推送已经完了。此时关闭连接
        if(data.content==='contDnd'){
          this.endConnectHandler()
        }else{
          this.list.push(data.content);
        }
        console.log("这次消息推送的内容event:", data.content);
      });
      sseObj.onerror = (e) =&gt; {
        console.log("error", e);
      };
    },
    endConnectHandler() {
      if(this.eventSource){
        this.connectStatus = false
        this.eventSource.close();
        if(this.eventSource.readyState === 2) {
          // sseObj.readyState === EventSource.CLOSED 也可以判断连接已经关闭
          console.log('2连接已经关闭。',this.eventSource, this.eventSource.readyState);
        }
        console.log("end");
      }
    },
  },
};
&lt;/script&gt;
&lt;style scoped&gt;
.chat-box{
  padding-left: 20px;
  padding-top: 20px;
  button{
    margin-right: 20px;
    padding: 6px;
  }
}
&lt;/style&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202502/1425695-20250214163149852-1666511057.gif" alt="" loading="lazy"></p>
<h4 id="尾声">尾声</h4>
<p>今天情人节，各位小伙伴们有啥打算。<br>
我准备去垃圾桶看看能不能见到宝贝<br>
不说了，现在先规划路径，拜拜啦</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07052193092476852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 16:34">2025-02-14 16:34</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">35</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18715636" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18715636);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18715636', targetLink: 'https://www.cnblogs.com/IwishIcould/p/18715636', title: 'SSE进行消息推送保证你看的清清楚楚' })">举报</a>
</div>
        