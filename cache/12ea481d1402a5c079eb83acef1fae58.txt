
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19058849" title="发布于 2025-08-26 14:25">
    <span role="heading" aria-level="2">【渲染流水线】[逐片元阶段]-[混合Blend]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250826143525236-275201204.png" alt="【渲染流水线】[逐片元阶段]-[混合Blend]以UnityURP为例" class="desc_img">
        本文深入解析Unity URP渲染管线中的Blend和BlendOp指令，对比OpenGL原生实现与Unity内置管线的差异。URP通过优化混合操作，支持加法/减法/Min/Max等运算，在移动端和高性能平台均能高效运行。文章详细介绍了混合因子配置和实际应用，包括透明度混合、加法发光等效果，并提供能量护盾、粒子发光、水体渲染等具体Shader实现案例，展示如何利用混合指令实现各种视觉特效。URP相比传统方案具有更好的跨平台兼容性和性能表现。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Unity URP（Universal Render Pipeline）中的Blend和BlendOp是ShaderLab中控制颜色混合的核心指令，其发展历史与渲染技术演进密切相关。早期固定功能管线仅支持简单的Alpha混合，随着可编程着色器的普及，混合操作逐渐扩展为可定制化的数学运算。URP通过优化这些指令的底层实现，使其在移动端和高性能平台均能高效运行。</p>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="opengl中的混合实现"><strong>OpenGL中的混合实现</strong></h1>
<h2 id="api调用机制">‌<strong>API调用机制</strong>‌</h2>
<p>OpenGL通过<code>glBlendFunc</code>和<code>glBlendEquation</code>函数实现混合操作，对应URP中<code>Blend</code>和<code>BlendOp</code>指令。其中：</p>
<ul>
<li><code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code>等价于URP的<code>Blend SrcAlpha OneMinusSrcAlpha</code></li>
<li><code>glBlendEquation(GL_FUNC_ADD)</code>对应<code>BlendOp Add</code>操作</li>
</ul>
<h2 id="管线阶段差异">‌<strong>管线阶段差异</strong>‌</h2>
<p>OpenGL将混合作为固定管线阶段，在片段着色器之后执行，而URP通过可编程着色器在片元处理阶段动态控制混合参数</p>
<h2 id="双源混合限制">‌<strong>双源混合限制</strong>‌</h2>
<p>OpenGL 4.x支持<code>GL_SRC1_COLOR</code>等双源混合因子，但移动端GLES 3.0需通过扩展实现，URP对此做了平台兼容性封装</p>
<h1 id="内置管线混合实现"><strong>内置管线混合实现</strong></h1>
<h2 id="早期实现方式">‌<strong>早期实现方式</strong>‌</h2>
<p>内置管线通过<code>Queue="Transparent"</code>标签自动启用混合，但需手动配置<code>Blend</code>命令且不支持<code>BlendOp</code>高级操作</p>
<h2 id="深度处理差异">‌<strong>深度处理差异</strong>‌</h2>
<p>内置管线要求显式关闭深度写入（<code>ZWrite Off</code>），而URP在透明渲染队列中自动管理深度测试与混合的冲突</p>
<h2 id="性能优化对比">‌<strong>性能优化对比</strong>‌</h2>
<p>内置管线混合计算固定于GPU固定功能单元，URP则通过可编程着色器实现动态混合策略，如根据设备性能切换<code>Min/Max</code>操作</p>
<h1 id="关键技术对比"><strong>关键技术对比</strong></h1>
<table>
<thead>
<tr>
<th>特性</th>
<th>OpenGL原生实现</th>
<th>Unity内置管线</th>
<th>URP优化方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>混合因子配置</td>
<td><code>glBlendFunc</code></td>
<td><code>Blend</code>命令</td>
<td>封装为跨平台Shader指令</td>
</tr>
<tr>
<td>操作符扩展</td>
<td><code>glBlendEquation</code></td>
<td>仅支持基础加减</td>
<td>支持<code>Min/Max/RevSub</code>等</td>
</tr>
<tr>
<td>移动端兼容性</td>
<td>需检查扩展支持</td>
<td>全平台统一行为</td>
<td>自动降级混合方案</td>
</tr>
<tr>
<td>多渲染目标支持</td>
<td><code>glDrawBuffers</code></td>
<td>有限支持</td>
<td>完整MRT混合控制</td>
</tr>
</tbody>
</table>
<ul>
<li>OpenGL中实现URP的<code>BlendOp RevSub</code>需调用<code>glBlendEquation(GL_FUNC_REVERSE_SUBTRACT)</code></li>
<li>内置管线模拟URP发光效果需组合<code>Blend One One</code>与多个Pass渲染</li>
</ul>
<h1 id="核心问题解决"><strong>核心问题解决</strong></h1>
<ul>
<li>‌<strong>透明效果实现</strong>‌：通过<code>Blend SrcAlpha OneMinusSrcAlpha</code>等组合，解决了传统透明度混合中排序依赖和边缘锯齿问题</li>
<li>‌<strong>复杂光效合成</strong>‌：利用<code>BlendOp Max</code>或<code>Add</code>操作，实现发光体叠加时的亮度累积效果</li>
<li>‌<strong>非破坏性图像处理</strong>‌：<code>BlendOp RevSub</code>等操作允许反向颜色计算，用于特殊遮罩或腐蚀效果</li>
</ul>
<h1 id="命令使用介绍">命令使用介绍</h1>
<ul>
<li>将当前片元颜色与帧缓冲颜色按公式混合</li>
<li>支持加法/乘法/透明度混合等模式‌</li>
<li>混合当前片元与颜色缓冲（<code>Blend</code>&nbsp;指令，如&nbsp;<code>Blend SrcAlpha OneMinusSrcAlpha</code>；<code>BlendOp</code> 指令控制操作符，如<code>BlendOp Sub</code>（默认不指定是Add））</li>
</ul>
<h2 id="blend命令">Blend命令</h2>
<p>混合命令是当前输出的颜色值Src，和缓冲区里的颜色值Dst做数值运算来进行混合。命令配置主要影响这个运算公式，下面先看下这个运算公式是什么样的：</p>
<p>$Src * SrcFactor + Dst * DstFactor$</p>
<ul>
<li>这里的Src是当前输出的颜色值。</li>
<li>Dst是缓冲区里已有的颜色值。</li>
<li>SrcFactor是接下来命令配置时要改变的当前颜色值的影响变量因子。</li>
<li>DstFactor同样的是命令配置要改变缓冲区内的颜色值的影响因子。</li>
</ul>
<p>这两个因子与颜色值相乘后相加就是新的要输出的颜色值。这里的相加是默认操作，由接下来的命令BlendOp来配置可修改。</p>
<p>上述公式是对颜色RGBA一起操作的配置。还有一种是分离颜色RGB和A单独控制的配置方式，与这个类似的公式：</p>
<p>$Src * SrcFactorA + Dst * DstFactorA$</p>
<p>混合的两种模板公式：</p>
<p><code>Blend</code> SrcFactor DstFactor</p>
<p><code>Blend</code> SrcFactor DstFactor, SrcFactorA DstFactorA</p>
<p>第一种配置方式直接配置RGBA，第二种将RGB和A分开配置。</p>
<ul>
<li>
<p>那么这些Factor因子可以配置成哪些内容：</p>
<h3 id="基础混合因子"><strong>‌基础混合因子‌</strong></h3>
<table>
<thead>
<tr>
<th>因子名称</th>
<th>数学表达式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>One</code></td>
<td>1</td>
<td>完全保留源或目标颜色值（常用于加法混合）‌</td>
</tr>
<tr>
<td><code>Zero</code></td>
<td>0</td>
<td>忽略源或目标颜色值（常用于屏蔽颜色）‌</td>
</tr>
<tr>
<td><code>SrcColor</code></td>
<td>源颜色的RGB值</td>
<td>使用片元着色器输出的RGB值作为混合因子‌</td>
</tr>
<tr>
<td><code>SrcAlpha</code></td>
<td>源颜色的Alpha值</td>
<td>使用片元着色器的透明度值（如标准透明混合）‌</td>
</tr>
<tr>
<td><code>DstColor</code></td>
<td>目标颜色的RGB值</td>
<td>使用帧缓冲区中已存在的RGB值（如乘法混合）‌</td>
</tr>
<tr>
<td><code>DstAlpha</code></td>
<td>目标颜色的Alpha值</td>
<td>使用帧缓冲区中已存在的透明度值‌</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="反相混合因子"><strong>‌反相混合因子‌</strong></h3>
<table>
<thead>
<tr>
<th>因子名称</th>
<th>数学表达式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OneMinusSrcColor</code></td>
<td>1 - 源颜色RGB值</td>
<td>反相源颜色值（用于特殊效果叠加）‌</td>
</tr>
<tr>
<td><code>OneMinusSrcAlpha</code></td>
<td>1 - 源Alpha值</td>
<td>反相源透明度（与<code>SrcAlpha</code>配合实现标准透明混合）‌</td>
</tr>
<tr>
<td><code>OneMinusDstColor</code></td>
<td>1 - 目标颜色RGB值</td>
<td>反相目标颜色值（如屏幕空间发光效果）‌</td>
</tr>
<tr>
<td><code>OneMinusDstAlpha</code></td>
<td>1 - 目标Alpha值</td>
<td>反相目标透明度值‌</td>
</tr>
</tbody>
</table>
<h3 id="混合因子应用场景"><strong>混合因子应用场景‌</strong></h3>
<ul>
<li>‌<strong>透明度混合</strong>‌：<code>Blend SrcAlpha OneMinusSrcAlpha</code>（源透明×源颜色 + (1-源透明)×目标颜色）‌</li>
<li>‌<strong>加法发光</strong>‌：<code>Blend One One</code>（源颜色 + 目标颜色）‌</li>
<li>‌<strong>乘法叠加</strong>‌：<code>Blend DstColor Zero</code>（源颜色×目标颜色）‌</li>
<li>‌<strong>反相混合</strong>‌：<code>Blend OneMinusDstColor OneMinusSrcColor</code>（用于特殊遮罩效果）‌</li>
</ul>
</li>
<li>
<p>BlendOp命令</p>
<p>通过<code>BlendOp</code>修改混合计算方式，支持以下操作：</p>
<ul>
<li><code>Add</code>（默认）：相加</li>
<li><code>Sub</code>：源减去目标</li>
<li><code>RevSub</code>：目标减去源</li>
<li><code>Min</code>/<code>Max</code>：取最小/最大值‌</li>
</ul>
<pre><code class="language-glsl">BlendOp RevSub  
Blend One One // 实现颜色相减效果‌
</code></pre>
</li>
</ul>
<h1 id="应用示例"><strong>应用示例</strong></h1>
<h2 id="能量护盾特效"><strong>能量护盾特效</strong></h2>
<ul>
<li>
<p>使用<code>BlendOp RevSub</code>结合<code>Blend One One</code>，实现护盾边缘对背景颜色的"扣除"效果，模拟能量场扭曲</p>
<p>能量护盾特效通过反向减法混合(RevSub)实现背景颜色扣除，配合蜂窝纹理可产生能量场扭曲效果</p>
<ul>
<li>
<p>EnergyShield.shader</p>
<pre><code class="language-c">Shader "URP/EnergyShield" {
    Properties {
        _MainTex ("Shield Pattern", 2D) = "white" {}
        _EdgeColor ("Edge Color", Color) = (0.2,0.8,1,1)
    }
    SubShader {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" }
        Blend One One
        BlendOp RevSub
        ZWrite Off

        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        ENDHLSL

        Pass {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            struct Attributes {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct Varyings {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            half4 _EdgeColor;

            Varyings vert(Attributes IN) {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = IN.uv;
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                half4 tex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                return tex * _EdgeColor;
            }
            ENDHLSL
        }
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="粒子系统发光">‌<strong>粒子系统发光</strong></h2>
<ul>
<li>
<p>采用<code>Blend One One</code>与<code>BlendOp Add</code>叠加多层粒子颜色，避免传统混合导致的亮度衰减</p>
<p>粒子系统采用加法混合(Add)确保多层粒子叠加时亮度线性累积，避免传统混合的亮度衰减问题</p>
<ul>
<li>
<p>ParticleGlow.shader</p>
<pre><code class="language-c">Shader "URP/ParticleGlow" {
    Properties {
        _MainTex ("Particle Texture", 2D) = "white" {}
        _Intensity ("Glow Intensity", Range(1,10)) = 3
    }
    SubShader {
        Tags { "RenderType"="Transparent" "Queue"="Transparent+100" }
        Blend One One
        BlendOp Add
        ZWrite Off
        Cull Off

        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        ENDHLSL

        Pass {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            struct Attributes {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
                half4 color : COLOR;
            };

            struct Varyings {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
                half4 color : COLOR;
            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            float _Intensity;

            Varyings vert(Attributes IN) {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = IN.uv;
                OUT.color = IN.color * _Intensity;
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                half4 tex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                return tex * IN.color;
            }
            ENDHLSL
        }
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="透明水体渲染"><strong>透明水体渲染</strong></h2>
<ul>
<li>
<p>通过<code>Blend SrcAlpha OneMinusSrcAlpha</code>控制折射/反射强度，配合<code>BlendOp Min</code>保留深度最小的泡沫高光</p>
<p>水体渲染使用Min混合操作保留最小深度值，配合标准Alpha混合实现透明折射效果</p>
<ul>
<li>
<p>WaterSurface.shader</p>
<pre><code class="language-c">Shader "URP/WaterSurface" {
    Properties {
        _MainTex ("Water Texture", 2D) = "white" {}
        _NormalMap ("Normal Map", 2D) = "bump" {}
        _FoamTex ("Foam Texture", 2D) = "white" {}
    }
    SubShader {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" }
        Blend SrcAlpha OneMinusSrcAlpha
        BlendOp Min
        ZWrite Off

        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        ENDHLSL

        Pass {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            struct Attributes {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
                float3 normalOS : NORMAL;
                float4 tangentOS : TANGENT;
            };

            struct Varyings {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 normalWS : TEXCOORD1;
                float3 viewDirWS : TEXCOORD2;
            };

            TEXTURE2D(_MainTex);
            TEXTURE2D(_NormalMap);
            TEXTURE2D(_FoamTex);
            SAMPLER(sampler_MainTex);

            Varyings vert(Attributes IN) {
                Varyings OUT;
                float3 positionWS = TransformObjectToWorld(IN.positionOS.xyz);
                OUT.positionCS = TransformWorldToHClip(positionWS);
                OUT.uv = IN.uv;
                OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);
                OUT.viewDirWS = GetWorldSpaceViewDir(positionWS);
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                half4 water = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                water.a = 0.7;
                half3 normalTS = UnpackNormal(SAMPLE_TEXTURE2D(_NormalMap, sampler_MainTex, IN.uv));
                half foam = SAMPLE_TEXTURE2D(_FoamTex, sampler_MainTex, IN.uv).r;
                return min(water, foam.xxxx);
            }
            ENDHLSL
        }
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007638888888888889" data-date-updated="2025-08-26 14:36">2025-08-26 14:25</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19058849);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19058849', targetLink: 'https://www.cnblogs.com/SmalBox/p/19058849', title: '【渲染流水线】[逐片元阶段]-[混合Blend]以UnityURP为例' })">举报</a>
</div>
        