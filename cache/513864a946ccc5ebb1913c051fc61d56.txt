
            <div class="postcontent">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="引言">引言</h3>
<p>记得很久以前经常被问到这样一个面试题"FactoryBean 和BeanFactory它们有啥区别"。在 Spring 框架中，<strong><code>BeanFactory</code></strong> 和 <strong><code>FactoryBean</code></strong> 是两个核心概念，虽然名称相似，但它们的角色和功能完全不同。</p>
<h3 id="1-定义与角色"><strong>1. 定义与角色</strong></h3>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>BeanFactory</strong></th>
<th><strong>FactoryBean</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>角色</strong></td>
<td>Spring 的 <strong>IoC 容器核心接口</strong>，负责管理所有 Bean 的生命周期（创建、配置、依赖注入）。</td>
<td>一个 <strong>特殊 Bean 接口</strong>，用于动态创建复杂对象（如代理对象、连接池、动态代理等）。</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>提供容器基础能力（如 <code>getBean()</code>、<code>containsBean()</code> 等）。</td>
<td>通过 <code>getObject()</code> 方法返回实际需要的 Bean 实例。</td>
</tr>
<tr>
<td><strong>接口方法</strong></td>
<td><code>getBean()</code>、<code>containsBean()</code>、<code>isSingleton()</code> 等。</td>
<td><code>getObject()</code>、<code>getObjectType()</code>、<code>isSingleton()</code>。</td>
</tr>
<tr>
<td><strong>典型实现</strong></td>
<td><code>DefaultListableBeanFactory</code>、<code>ApplicationContext</code> 等。</td>
<td><code>SqlSessionFactoryBean</code>（MyBatis）、<code>ProxyFactoryBean</code>（AOP）等。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="2-核心区别"><strong>2. 核心区别</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>BeanFactory</strong></th>
<th><strong>FactoryBean</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>获取对象的方式</strong></td>
<td>直接返回容器中注册的 Bean 实例（如 <code>getBean("beanName")</code>）。</td>
<td>默认返回 <code>getObject()</code> 的结果（如 <code>getBean("factoryBeanName")</code>）。</td>
</tr>
<tr>
<td><strong>访问自身的方式</strong></td>
<td>直接通过 <code>getBean("beanName")</code> 获取。</td>
<td>需通过 <code>&amp;beanName</code> 前缀获取（如 <code>getBean("&amp;factoryBeanName")</code>）。</td>
</tr>
<tr>
<td><strong>是否单例</strong></td>
<td>容器默认管理 Bean 的作用域（如单例、原型）。</td>
<td>通过 <code>isSingleton()</code> 方法定义创建对象的作用域。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>管理所有 Bean 的基础设施（如依赖注入、生命周期管理）。</td>
<td>封装复杂对象的创建逻辑（如动态代理、数据库连接池）。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="3-使用场景与示例"><strong>3. 使用场景与示例</strong></h3>
<h4 id="1-beanfactory-的使用"><strong>(1) BeanFactory 的使用</strong></h4>
<ul>
<li><strong>作用</strong>：作为 Spring 容器的根接口，负责管理所有 Bean 的生命周期。</li>
<li><strong>示例</strong>：<pre><code class="language-java">// 通过 BeanFactory 获取 Bean
BeanFactory factory = new ClassPathXmlApplicationContext("beans.xml");
UserService userService = factory.getBean("userService", UserService.class);
</code></pre>
</li>
</ul>
<h4 id="2-factorybean-的使用"><strong>(2) FactoryBean 的使用</strong></h4>
<ul>
<li><strong>作用</strong>：通过自定义 <code>getObject()</code> 方法创建复杂对象。</li>
<li><strong>示例</strong>：<pre><code class="language-java">// 定义 FactoryBean
public class MyConnectionFactory implements FactoryBean&lt;Connection&gt; {
    @Override
    public Connection getObject() throws Exception {
        // 返回数据库连接
        return DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb");
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return Connection.class;
    }

    @Override
    public boolean isSingleton() {
        return true; // 是否为单例
    }
}

// 配置到 Spring 容器
@Configuration
public class AppConfig {
    @Bean
    public FactoryBean&lt;Connection&gt; connectionFactory() {
        return new MyConnectionFactory();
    }
}

// 使用
@Autowired
private Connection connection; // 实际注入的是 getObject() 返回的 Connection
</code></pre>
</li>
</ul>
<p>在 Spring 框架中，<code>FactoryBean</code> 被广泛用于集成第三方中间件或框架，通过封装复杂对象的创建逻辑，简化配置并提高灵活性。以下是几个常见中间件使用 <code>FactoryBean</code> 的示例：</p>
<h3 id="1-mybatis-的-sqlsessionfactorybean"><strong>1. MyBatis 的 <code>SqlSessionFactoryBean</code></strong></h3>
<p><strong>作用</strong>：<br>
创建 MyBatis 的 <code>SqlSessionFactory</code> 实例，集成数据库配置、映射文件扫描等逻辑。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-xml">&lt;!-- Spring 配置文件中定义 SqlSessionFactoryBean --&gt;
&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>SqlSessionFactoryBean</code> 实现了 <code>FactoryBean&lt;SqlSessionFactory&gt;</code>。</li>
<li><code>getObject()</code> 方法内部调用 MyBatis 的 <code>SqlSessionFactoryBuilder</code> 创建 <code>SqlSessionFactory</code>。</li>
<li>支持延迟加载和复杂配置（如多数据源、事务管理器）。</li>
</ul>
<hr>
<h3 id="2-openfeign-的-feignclientfactorybean"><strong>2. OpenFeign 的 <code>FeignClientFactoryBean</code></strong></h3>
<p><strong>作用</strong>：<br>
动态创建 Feign 客户端（RESTful API 调用代理对象）。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">@Configuration
public class FeignConfig {
    @Bean
    public FactoryBean&lt;MyServiceClient&gt; myServiceClient() {
        FeignClientFactoryBean factory = new FeignClientFactoryBean();
        factory.setUrl("http://example.com/api");
        factory.setType(MyServiceClient.class);
        return factory;
    }
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>FeignClientFactoryBean</code> 封装了 Feign 的 <code>Target</code> 和 <code>Encoder/Decoder</code> 配置。</li>
<li><code>getObject()</code> 返回动态代理的 Feign 客户端实例。</li>
<li>支持自定义拦截器、重试策略等。</li>
</ul>
<hr>
<h3 id="3-redis-的-redisconnectionfactorybean"><strong>3. Redis 的 <code>RedisConnectionFactoryBean</code></strong></h3>
<p><strong>作用</strong>：<br>
创建 Redis 连接池（如 <code>JedisConnectionFactory</code> 或 <code>LettuceConnectionFactory</code>）。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-xml">&lt;!-- Spring 配置文件中定义 RedisConnectionFactoryBean --&gt;
&lt;bean id="redisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;
    &lt;property name="hostName" value="localhost"/&gt;
    &lt;property name="port" value="6379"/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>JedisConnectionFactory</code> 本身实现了 <code>FactoryBean&lt;RedisConnection&gt;</code>。</li>
<li><code>getObject()</code> 返回 <code>RedisConnection</code> 实例（如 <code>JedisConnection</code>）。</li>
<li>支持连接池配置（如最大连接数、超时时间）。</li>
</ul>
<hr>
<h3 id="4-rocketmq-的-rocketmqtemplate"><strong>4. RocketMQ 的 <code>RocketMQTemplate</code></strong></h3>
<p><strong>作用</strong>：<br>
封装 RocketMQ 生产者和消费者的创建逻辑。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">@Configuration
public class RocketMQConfig {
    @Bean
    public RocketMQTemplate rocketMQTemplate() {
        RocketMQTemplate template = new RocketMQTemplate();
        template.setProducer(new DefaultMQProducer("my-producer-group"));
        template.setConsumer(new DefaultMQPushConsumer("my-consumer-group"));
        return template;
    }
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>RocketMQTemplate</code> 通过 <code>FactoryBean</code> 模式初始化生产者和消费者。</li>
<li><code>getObject()</code> 返回配置好的 <code>RocketMQTemplate</code> 实例。</li>
<li>支持消息发送、监听器注册等操作。</li>
</ul>
<h3 id="5-quartz-的-schedulerfactorybean"><strong>5. Quartz 的 <code>SchedulerFactoryBean</code></strong></h3>
<p><strong>作用</strong>：<br>
创建 Quartz 调度器（<code>Scheduler</code>），集成任务调度逻辑。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-xml">&lt;!-- Spring 配置文件中定义 SchedulerFactoryBean --&gt;
&lt;bean id="schedulerFactoryBean" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
    &lt;property name="triggers"&gt;
        &lt;list&gt;
            &lt;ref bean="myCronTrigger"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>SchedulerFactoryBean</code> 封装了 Quartz 的 <code>SchedulerFactory</code> 配置。</li>
<li><code>getObject()</code> 返回 <code>Scheduler</code> 实例。</li>
<li>支持动态注册任务和触发器。</li>
</ul>
<hr>
<h3 id="6-dubbo-的-servicebean"><strong>6. Dubbo 的 <code>ServiceBean</code></strong></h3>
<p><strong>作用</strong>：<br>
发布 Dubbo 服务，封装服务暴露和注册逻辑。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-xml">&lt;!-- Spring 配置文件中定义 Dubbo ServiceBean --&gt;
&lt;bean id="dubboService" class="com.alibaba.dubbo.config.ServiceBean"&gt;
    &lt;property name="interface" value="com.example.MyService"/&gt;
    &lt;property name="ref" ref="myServiceImpl"/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>ServiceBean</code> 实现了 <code>FactoryBean&lt;Exporter&gt;</code>。</li>
<li><code>getObject()</code> 返回服务导出器（<code>Exporter</code>），完成服务注册和暴露。</li>
<li>支持负载均衡、容错策略等 Dubbo 特性。</li>
</ul>
<hr>
<h3 id="7-kafka-的-kafkatemplate"><strong>7. Kafka 的 <code>KafkaTemplate</code></strong></h3>
<p><strong>作用</strong>：<br>
封装 Kafka 生产者和消费者的创建逻辑。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">@Configuration
public class KafkaConfig {
    @Bean
    public KafkaTemplate&lt;String, String&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(new ProducerFactory&lt;&gt;());
    }
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li><code>KafkaTemplate</code> 通过 <code>FactoryBean</code> 模式初始化生产者工厂。</li>
<li><code>getObject()</code> 返回配置好的 <code>KafkaTemplate</code> 实例。</li>
<li>支持消息发送、消费者监听等操作。</li>
</ul>
<hr>
<h3 id="总结对比"><strong>总结对比</strong></h3>
<table>
<thead>
<tr>
<th>中间件</th>
<th>FactoryBean 类型</th>
<th>作用领域</th>
<th>核心方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyBatis</td>
<td><code>SqlSessionFactoryBean</code></td>
<td>数据库访问</td>
<td>创建 <code>SqlSessionFactory</code></td>
</tr>
<tr>
<td>OpenFeign</td>
<td><code>FeignClientFactoryBean</code></td>
<td>RESTful 客户端</td>
<td>创建 Feign 动态代理</td>
</tr>
<tr>
<td>Redis</td>
<td><code>JedisConnectionFactory</code></td>
<td>缓存/键值存储</td>
<td>创建 Redis 连接池</td>
</tr>
<tr>
<td>RocketMQ</td>
<td><code>RocketMQTemplate</code></td>
<td>消息队列</td>
<td>封装生产者/消费者逻辑</td>
</tr>
<tr>
<td>Quartz</td>
<td><code>SchedulerFactoryBean</code></td>
<td>定时任务调度</td>
<td>创建调度器并注册任务</td>
</tr>
<tr>
<td>Dubbo</td>
<td><code>ServiceBean</code></td>
<td>微服务 RPC</td>
<td>发布服务并注册到注册中心</td>
</tr>
<tr>
<td>Kafka</td>
<td><code>KafkaTemplate</code></td>
<td>消息队列</td>
<td>封装生产者/消费者逻辑</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>解耦配置与逻辑</strong>：通过 <code>FactoryBean</code> 将复杂初始化逻辑封装，Spring 容器只需管理 Bean 的声明。</li>
<li><strong>支持动态创建</strong>：可根据运行时条件（如环境变量、配置参数）动态生成不同对象。</li>
<li><strong>统一资源管理</strong>：集中管理中间件的连接池、配置参数，便于维护和扩展。</li>
</ul>
<h3 id="4-获取-factorybean-本身"><strong>4. 获取 FactoryBean 本身</strong></h3>
<ul>
<li><strong>默认行为</strong>：<code>getBean("factoryBeanName")</code> 返回的是 <code>FactoryBean.getObject()</code> 的结果。</li>
<li><strong>获取 FactoryBean 实例本身</strong>：需在 Bean 名称前加 <code>&amp;</code> 前缀。<pre><code class="language-java">// 获取 FactoryBean 创建的 Bean
Connection connection = context.getBean("connectionFactory", Connection.class);

// 获取 FactoryBean 实例本身
MyConnectionFactory factoryBean = (MyConnectionFactory) context.getBean("&amp;connectionFactory");
</code></pre>
</li>
</ul>
<hr>
<h3 id="5-常见问题与解决方案"><strong>5. 常见问题与解决方案</strong></h3>
<h4 id="问题1混淆-beanfactory-和-factorybean-的功能"><strong>问题1：混淆 BeanFactory 和 FactoryBean 的功能</strong></h4>
<ul>
<li><strong>解决方案</strong>：明确 <code>BeanFactory</code> 是容器，<code>FactoryBean</code> 是创建 Bean 的工具。</li>
</ul>
<h4 id="问题2期望获取-factorybean-实例却得到其创建的-bean"><strong>问题2：期望获取 FactoryBean 实例却得到其创建的 Bean</strong></h4>
<ul>
<li><strong>示例</strong>：<pre><code class="language-java">// 错误：获取的是 Encryptor 实例，而非 FactoryBean
Encryptor encryptor = factory.getBean("encryptor");

// 正确：添加 "&amp;" 前缀获取 FactoryBean
FactoryBean factoryBean = factory.getBean("&amp;encryptor");
</code></pre>
</li>
</ul>
<h4 id="问题3未正确实现-getobjecttype-导致类型检查失败"><strong>问题3：未正确实现 <code>getObjectType()</code> 导致类型检查失败</strong></h4>
<ul>
<li><strong>修复</strong>：确保 <code>getObjectType()</code> 返回准确的类型信息。</li>
</ul>
<hr>
<h3 id="6-高级应用场景"><strong>6. 高级应用场景</strong></h3>
<h4 id="1-动态代理生成"><strong>(1) 动态代理生成</strong></h4>
<pre><code class="language-java">public class ServiceProxyFactoryBean implements FactoryBean&lt;MyService&gt; {
    @Override
    public MyService getObject() {
        return (MyService) Proxy.newProxyInstance(
            getClass().getClassLoader(),
            new Class[]{MyService.class},
            (proxy, method, args) -&gt; {
                System.out.println("Before method: " + method.getName());
                return method.invoke(new MyServiceImpl(), args);
            });
    }
}
</code></pre>
<h4 id="2-延迟初始化"><strong>(2) 延迟初始化</strong></h4>
<pre><code class="language-java">public class LazyInitFactoryBean implements FactoryBean&lt;ExpensiveBean&gt; {
    private ExpensiveBean instance;

    @Override
    public ExpensiveBean getObject() {
        if (instance == null) {
            instance = new ExpensiveBean(); // 延迟初始化
        }
        return instance;
    }
}
</code></pre>
<hr>
<h3 id="7-总结"><strong>7. 总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>BeanFactory</strong></th>
<th><strong>FactoryBean</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本质</strong></td>
<td>Spring 容器的根接口，管理所有 Bean 的生命周期。</td>
<td>一个特殊 Bean，用于封装复杂对象的创建逻辑。</td>
</tr>
<tr>
<td><strong>获取方式</strong></td>
<td><code>getBean("beanName")</code> 返回容器中的 Bean 实例。</td>
<td><code>getBean("factoryBeanName")</code> 返回 <code>getObject()</code> 的结果，<code>getBean("&amp;factoryBeanName")</code> 返回 FactoryBean 本身。</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>Spring 容器的基础功能（如依赖注入、生命周期管理）。</td>
<td>创建动态代理、连接池、复杂对象等。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>BeanFactory</strong> 是 <strong>Spring 容器本身</strong>，负责管理所有 Bean。</li>
<li><strong>FactoryBean</strong> 是 <strong>容器中的一个 Bean</strong>，负责 <strong>生产其他 Bean</strong>。</li>
<li><strong>&amp;beanName</strong> 是访问 FactoryBean 本身的“密钥”。</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="itemdesc">
                发表于 
<span id="post-date" data-last-update-days="0.004166666666666667" data-date-updated="2025-06-17 16:57">2025-06-17 16:51</span>&nbsp;
<a href="https://www.cnblogs.com/root429">java金融</a>&nbsp;
阅读(<span id="post_view_count">69</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18933245);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18933245', targetLink: 'https://www.cnblogs.com/root429/p/18933245', title: 'FactoryBean 和BeanFactory的傻傻的总是分不清？' })">举报</a>

            </div>
        