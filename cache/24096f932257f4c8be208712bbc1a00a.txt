
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tangtang1997/p/18628049" title="发布于 2024-12-24 16:34">
    <span role="heading" aria-level="2">在 .NET Core 中使用 ActionBlock 实现高效率的多步骤数据处理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#一引言" rel="noopener nofollow">一、引言</a></li><li><a href="#二actionblock介绍" rel="noopener nofollow">二、ActionBlock介绍</a><ul><li><a href="#什么是-actionblock" rel="noopener nofollow">什么是 ActionBlock？</a></li><li><a href="#actionblock-的特点" rel="noopener nofollow">ActionBlock 的特点</a></li><li><a href="#actionblock-的使用场景" rel="noopener nofollow">ActionBlock 的使用场景</a></li><li><a href="#actionblock-的基本用法" rel="noopener nofollow">ActionBlock 的基本用法</a></li></ul></li><li><a href="#三假设场景" rel="noopener nofollow">三、假设场景</a></li><li><a href="#四解决方案" rel="noopener nofollow">四、解决方案</a></li></ul></div><p></p>
<h2 id="一引言">一、引言</h2>
<p><a href="https://www.cnblogs.com/Tangtang1997/p/18623843" target="_blank">上一篇博客</a> 分享了使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/channels" target="_blank" rel="noopener nofollow">Channel</a> 来实现针对大量数据的多线程异步处理，感谢大哥们在评论中提出的宝贵的问题和建议！本篇将分享使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.actionblock-1?redirectedfrom=MSDN&amp;view=net-9.0" target="_blank" rel="noopener nofollow">ActionBlock</a> 如何实现，欢迎在评论区留言讨论。</p>
<h2 id="二actionblock介绍">二、ActionBlock介绍</h2>
<h3 id="什么是-actionblock">什么是 ActionBlock？</h3>
<p><code>ActionBlock</code>是 .NET 中 TPL Dataflow 库的一部分，用于处理数据流和并行任务。它提供了一种简单而强大的方式来处理并行任务，并且可以轻松地实现生产者-消费者模式。</p>
<h3 id="actionblock-的特点">ActionBlock 的特点</h3>
<ul>
<li><strong>并行处理：</strong><code>ActionBlock</code>可以配置为并行处理多个任务，从而提高处理效率</li>
<li><strong>异步编程：</strong>支持异步编程模型，可以避免阻塞线程，提高应用程序的响应速度和吞吐量</li>
<li><strong>数据流控制：</strong>可以通过设置最大并行度和其他选项来控制数据流的处理方式</li>
<li><strong>任务调度：</strong>可以用于调度和管理并行任务，确保任务按预期执行</li>
</ul>
<h3 id="actionblock-的使用场景">ActionBlock 的使用场景</h3>
<ul>
<li><strong>生产者-消费者模式</strong>：可以用于实现生产者-消费者模式，其中生产者将数据发送到<code>ActionBlock</code>，消费者从<code>ActionBlock</code>中读取数据并进行处理</li>
<li><strong>数据流处理</strong>：适用于需要处理大量数据并且需要并行处理的场景，例如日志处理、数据转换等</li>
<li><strong>任务调度</strong>：可以用于调度和管理并行任务，确保任务按预期执行</li>
</ul>
<h3 id="actionblock-的基本用法">ActionBlock 的基本用法</h3>
<p>使用<code>ActionBlock</code>非常简单，主要步骤如下：</p>
<ol>
<li>创建 ActionBlock：定义一个 ActionBlock，指定要执行的操作和并行选项</li>
<li>发送数据到 ActionBlock：使用<code>SendAsync</code>方法将数据发送到 ActionBlock</li>
<li>完成 ActionBlock：在所有数据发送完成后，调用<code>Complete</code>方法通知 ActionBlock 不再接收新的数据</li>
<li>等待处理完成：使用<code>Completion</code>属性等待所有数据处理完成</li>
</ol>
<p>以下是一个简单的示例代码，展示了如何使用 ActionBlock：</p>
<pre><code class="language-csharp">using System.Threading.Tasks.Dataflow;

var actionBlock = new ActionBlock&lt;int&gt;(async item =&gt;
{
    // 模拟异步处理
    await Task.Delay(100);
    Console.WriteLine($"Processed item: {item}");
}, new ExecutionDataflowBlockOptions
{
    MaxDegreeOfParallelism = 4 // 设置最大并行度
});

// 发送数据到 ActionBlock
for (int i = 0; i &lt; 10; i++)
{
    await actionBlock.SendAsync(i);
}

// 完成 ActionBlock
actionBlock.Complete();
// 等待处理完成
await actionBlock.Completion;

Console.WriteLine("All items processed.");
</code></pre>
<h2 id="三假设场景">三、假设场景</h2>
<p>假设我们有一组数据需要经过两个步骤的处理。每个数据项都需要进行初步处理，然后进行进一步处理。希望步骤2可以在步骤1产生结果数据后立即开始处理，而不是等待步骤1完全处理完毕。</p>
<h2 id="四解决方案">四、解决方案</h2>
<p>使用<code>TransformBlock</code>和<code>ActionBlock</code>来实现生产者-消费者模式。生产者负责读取数据并将其发送到<code>TransformBlock</code>中，消费者从<code>TransformBlock</code>中读取数据并进行处理。<br>
以下是一个简单的示例代码，演示如何使用<code>TransformBlock</code>和<code>ActionBlock</code>实现生产者-消费者模式来处理数据：</p>
<pre><code class="language-csharp">using System.Threading.Tasks.Dataflow;

var cts = new CancellationTokenSource();
// 假设有一组数据
var dataItems = Enumerable.Range(0, 1000).Select(x =&gt; $"data_{x}").ToList();

var processor = new DataProcessor(10, cts.Token);
await processor.ProcessAsync(dataItems);

Console.ReadKey();

/// &lt;summary&gt;
/// 数据处理器
/// &lt;/summary&gt;
public class DataProcessor(int maxDegreeOfParallelism, CancellationToken cancellationToken)
{
    public async Task ProcessAsync(List&lt;string&gt; dataItems)
    {
        // 创建一个 TransformBlock 用于步骤1的处理，并将结果发送到步骤2的 ActionBlock
        var step1Block = new TransformBlock&lt;string, string&gt;(async dataItem =&gt; await Step1(dataItem), new ExecutionDataflowBlockOptions
        {
            MaxDegreeOfParallelism = maxDegreeOfParallelism,
            CancellationToken = cancellationToken
        });
         
        // 创建一个 ActionBlock 用于步骤2的处理
        var step2Block = new ActionBlock&lt;string&gt;(async dataItem =&gt;
        {
            await Step2(dataItem);
        }, new ExecutionDataflowBlockOptions
        {
            MaxDegreeOfParallelism = maxDegreeOfParallelism,
            CancellationToken = cancellationToken
        });

        // 将 TransformBlock 链接到 ActionBlock
        step1Block.LinkTo(step2Block, new DataflowLinkOptions { PropagateCompletion = true });

        // 启动多个步骤1的任务（生产者）
        foreach (var dataItem in dataItems)
        {
            await step1Block.SendAsync(dataItem, cancellationToken);
        }

        // 完成步骤1的 TransformBlock 的写入
        step1Block.Complete();
        // 等待步骤1的 TransformBlock 处理完成
        await step1Block.Completion;

        // 完成步骤2的 ActionBlock 的写入
        step2Block.Complete();
        // 等待步骤2的 ActionBlock 处理完成
        await step2Block.Completion;
    }

    private async Task&lt;string&gt; Step1(string dataItem)
    {
        // 模拟步骤1的处理（如初步处理数据）
        await Task.Delay(10, cancellationToken);
        Console.WriteLine($"Step1 processed data item: {dataItem}");
        return dataItem;
    }

    private async Task Step2(string dataItem)
    {
        // 模拟步骤2的处理（如进一步处理数据）
        await Task.Delay(10, cancellationToken);
        Console.WriteLine($"Step2 processed data item: {dataItem}");
    }
}
</code></pre>
<p>代码解释:</p>
<ol>
<li><strong>创建Step1的 TransformBlock</strong>：在<code>ProcessAsync</code>方法中，我们首先创建了一个 TransformBlock，用于Step1的处理，TransformBlock 接受一个输入数据项，进行处理后返回一个输出数据项，<code>TransformBlock&lt;string, string&gt;</code>表示输入和输出都是<code>string</code>类型</li>
<li><strong>创建Step2的 ActionBlock</strong>：创建一个 ActionBlock 用于Step2的处理，ActionBlock 接受一个输入数据项并进行处理，但不返回输出数据项。<code>ActionBlock&lt;string&gt;</code>表示输入是<code>string</code>类型</li>
<li><strong>链接 TransformBlock 和 ActionBlock</strong>：将 TransformBlock 链接到 ActionBlock ，以便将Step1的处理结果发送到Step2进行处理，使用<code>LinkTo</code>方法将两个块连接起来，并设置<code>PropagateCompletion</code>为 true，表示当 TransformBlock 完成时，ActionBlock 也会完成</li>
<li><strong>启动Step1的任务</strong>：逐个将数据项发送到 TransformBlock，并等待所有数据处理完成，使用<code>SendAsync</code>方法将数据项发送到 TransformBlock</li>
<li><strong>等待任务完成</strong>：使用<code>Complete</code>方法通知 TransformBlock 不再接收新的数据，并使用<code>Completion</code>属性等待所有数据处理完成。然后完成Step2的 ActionBlock 的写入，并等待Step2的 ActionBlock 处理完成</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07013467882986112" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 16:34">2024-12-24 16:34</span>&nbsp;
<a href="https://www.cnblogs.com/Tangtang1997">贾光辉</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628049" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628049);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628049', targetLink: 'https://www.cnblogs.com/Tangtang1997/p/18628049', title: '在 .NET Core 中使用 ActionBlock 实现高效率的多步骤数据处理' })">举报</a>
</div>
        