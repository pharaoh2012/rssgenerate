
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19048795" title="发布于 2025-08-20 15:16">
    <span role="heading" aria-level="2">【渲染流水线】[逐片元阶段]-[裁剪测试]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250820151951523-2090148020.png" alt="【渲染流水线】[逐片元阶段]-[裁剪测试]以UnityURP为例" class="desc_img">
        摘要：文章介绍了Unity中三种实现渲染区域裁剪的方法：1）使用UGUI的RectMask2D组件自动裁剪UI元素，性能最优但仅支持矩形；2）在Shader中通过代码手动检测片元位置实现灵活裁剪，可支持任意形状但性能中等；3）通过GL.ScissorTest全局API高效设置屏幕矩形裁剪区域，适合全屏特效但需正交相机。三种方式各具特点，开发者可根据UI/3D模型等不同需求选择最佳方案，其中RectMask2D最适合UI裁剪，Shader方案灵活性最高。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>通过矩形区域限制渲染范围</li>
<li>可有效减少不必要的片元处理‌</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="裁剪测试执行流程"><strong>裁剪测试执行流程‌</strong></h1>
<h2 id="定义裁剪矩形">‌<strong>定义裁剪矩形</strong>‌</h2>
<ul>
<li>设置基于屏幕坐标系（左下角为原点）的矩形区域：<code>(x_min, y_min, width, height)</code></li>
<li>坐标系单位为像素，矩形范围外的片元将被丢弃‌1</li>
</ul>
<h2 id="片元位置检测">‌<strong>片元位置检测</strong>‌</h2>
<ul>
<li>计算当前片元在屏幕空间的位置坐标&nbsp;<code>(frag_x, frag_y)</code></li>
</ul>
<h2 id="边界条件判断"><strong>边界条件判断</strong>‌</h2>
<ul>
<li>若&nbsp;<code>frag_x &lt; x_min</code>&nbsp;或&nbsp;<code>frag_x &gt; x_min + width</code>，丢弃片元</li>
<li>若&nbsp;<code>frag_y &lt; y_min</code>&nbsp;或&nbsp;<code>frag_y &gt; y_min + height</code>，丢弃片元‌</li>
</ul>
<h2 id="通过测试的片元">‌<strong>通过测试的片元</strong>‌</h2>
<ul>
<li>仅保留矩形区域内的片元，进入后续模板/深度测试流程</li>
</ul>
<h1 id="配置方式"><strong>‌配置方式‌</strong></h1>
<h2 id="1-ugui组件配置无需编码"><strong>‌1. UGUI组件配置（无需编码）‌</strong></h2>
<ul>
<li>
<p>‌<strong>RectMask2D组件</strong>‌</p>
<ul>
<li>添加至UI父物体（如Panel），自动计算子元素的包围盒作为裁剪区域</li>
<li>仅支持矩形裁剪，但性能优于Mask组件（无模板缓冲开销）‌</li>
</ul>
<pre><code class="language-csharp">csharp
// 示例：为UI面板添加裁剪
GameObject panel = GameObject.Find("UIPanel");
panel.AddComponent&lt;RectMask2D&gt;();
</code></pre>
</li>
</ul>
<h2 id="2-shader脚本配置灵活控制"><strong>‌2. Shader脚本配置（灵活控制）‌</strong></h2>
<p>在Shader中启用裁剪并定义区域：</p>
<pre><code class="language-glsl">hlsl
SubShader {
    Pass {
        // 开启GPU裁剪指令
        Cull Off
        ZTest Always

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        // 声明裁剪区域（需在脚本中动态传入）
        uniform float4 _ScissorRect; // (x, y, width, height)

        fixed4 frag (v2f i) : SV_Target {
            // 手动检测片元位置
            if (i.screenPos.x &lt; _ScissorRect.x ||
                i.screenPos.x &gt; _ScissorRect.x + _ScissorRect.z ||
                i.screenPos.y &lt; _ScissorRect.y ||
                i.screenPos.y &gt; _ScissorRect.y + _ScissorRect.w) {
                discard; // 丢弃区域外片元
            }
            return fixed4(1,1,1,1);
        }
        ENDCG
    }
}
</code></pre>
<h2 id="3-c脚本全局配置高效api"><strong>‌3. C#脚本全局配置（高效API）‌</strong></h2>
<p>通过<code>Screen.scissorRect</code>动态设置：</p>
<pre><code class="language-csharp">csharp
// 定义裁剪区域（左下角坐标100,100，宽高各300像素）
Rect scissorRect = new Rect(100, 100, 300, 300);
// 启用裁剪
GL.Enable(EnableCap.ScissorTest);
GL.Scissor((int)scissorRect.x, (int)scissorRect.y,
           (int)scissorRect.width, (int)scissorRect.height);
// 渲染操作...
GL.Disable(EnableCap.ScissorTest);// 结束需关闭
</code></pre>
<blockquote>
<p>⚠️ 注意：此方法需在OnPostRender等渲染回调中调用，且要求摄像机为正交模式以保证坐标系匹配‌</p>
</blockquote>
<h1 id="关键特性对比"><strong>‌关键特性对比‌</strong></h1>
<table>
<thead>
<tr>
<th>配置方式</th>
<th>适用对象</th>
<th>形状支持</th>
<th>性能开销</th>
<th>灵活性</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>RectMask2D</strong>‌</td>
<td>UGUI元素</td>
<td>仅矩形</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>‌<strong>Shader脚本</strong>‌</td>
<td>3D模型/粒子</td>
<td>任意</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>‌<strong>GL API</strong>‌</td>
<td>全屏特效</td>
<td>仅矩形</td>
<td>最低</td>
<td>中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>实际开发中，UI裁剪首选RectMask2D，3D对象或自定义形状需结合Shader实现；GL接口适用于全屏后处理特效的局部渲染优化‌</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-08-20 15:20">2025-08-20 15:16</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19048795);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19048795', targetLink: 'https://www.cnblogs.com/SmalBox/p/19048795', title: '【渲染流水线】[逐片元阶段]-[裁剪测试]以UnityURP为例' })">举报</a>
</div>
        