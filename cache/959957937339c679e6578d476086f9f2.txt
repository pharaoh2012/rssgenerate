
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/proer-blog/p/18732077" title="发布于 2025-02-23 14:16">
    <span role="heading" aria-level="2">Vue3 性能优化十大技巧：打造高性能应用的终极指南</span>
    

</a>

			</h2>
 			Posted on 
<span id="post-date" data-last-update-days="0.16641470803935185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-23 14:16">2025-02-23 14:16</span>&nbsp;
<a href="https://www.cnblogs.com/proer-blog">Code_Cracke</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18732077" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18732077);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18732077', targetLink: 'https://www.cnblogs.com/proer-blog/p/18732077', title: 'Vue3 性能优化十大技巧：打造高性能应用的终极指南' })">举报</a>

			
			
		</div>
		<div class="postbody">    <div id="cnblogs_post_description" style="display: none">
        
        Vue3 十大性能优化技巧，助你轻松打造高性能应用！从懒加载组件到虚拟列表，从路由分割到 Tree Shaking，每一步都直击痛点。掌握这些方法，不仅能大幅提升应用速度，还能让代码更优雅、更高效。想让你的项目脱颖而出？快来一探究竟吧！
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在现代前端开发中，性能优化是提升用户体验和系统效率的关键。Vue3 作为目前最流行的前端框架之一，提供了许多内置的性能优化工具和方法。本文将深入探讨 Vue3 中的十大性能优化技巧，帮助你从零开始构建一个高性能的 Vue 应用。</p>
<h3 id="1-懒加载组件减少初始加载资源消耗">1. 懒加载组件：减少初始加载资源消耗</h3>
<p>在大型应用中，初始加载时并不需要所有组件都立即可用。通过懒加载（Lazy Loading），我们可以按需加载组件，从而减少初始加载的资源消耗，提升首屏渲染速度。</p>
<h4 id="实现方式">实现方式</h4>
<p>使用 <code>defineAsyncComponent</code>方法动态加载组件：</p>
<pre><code class="language-javascript">// 1. 基础异步组件
const Dialog = defineAsyncComponent(() =&gt; import('./Dialog.vue'));

// 2. 带加载状态的进阶用法
const UserList = defineAsyncComponent({
  loader: () =&gt; import('./UserList.vue'),
  loadingComponent: LoadingSpinner, // 加载中组件
  delay: 200 // 延迟显示 loading
});

// 3. 结合路由的懒加载（Vue Router 4）
const routes = [
  { path: '/dashboard', component: () =&gt; import('./Dashboard.vue') }
];
</code></pre>
<h4 id="适用场景">适用场景</h4>
<ul>
<li>不常用的页面或功能模块。</li>
<li>需要延迟加载的复杂组件。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3257203/202502/3257203-20250223141357230-1599544065.jpg" alt="" loading="lazy"></p>
<hr>
<h3 id="2-合理使用事件总线避免全局污染">2. 合理使用事件总线：避免全局污染</h3>
<p>事件总线（Event Bus）虽然方便，但过度使用会导致代码难以维护，并可能引发性能问题。建议优先使用 Vue3 提供的 <code>provide/inject</code>或状态管理工具（如 Vuex/Pinia）来实现组件间通信。</p>
<h4 id="示例代码">示例代码</h4>
<pre><code class="language-javascript">// 使用 provide/inject 替代事件总线
export default {
  setup() {
    const sharedState = ref('Hello Vue3');
    provide('sharedState', sharedState);
  }
};

// 子组件中注入共享状态
export default {
  setup() {
    const sharedState = inject('sharedState');
    return { sharedState };
  }
};
</code></pre>
<h4 id="注意事项">注意事项</h4>
<ul>
<li>尽量避免全局事件总线，减少不必要的监听器。</li>
<li>对于复杂的状态管理，推荐使用 Pinia。</li>
</ul>
<hr>
<h3 id="3-虚拟列表高效处理长列表数据">3. 虚拟列表：高效处理长列表数据</h3>
<p>当处理大量数据的列表时，直接渲染所有项会导致性能瓶颈。虚拟列表技术通过只渲染可见区域的内容，显著提升了渲染性能。</p>
<h4 id="推荐库">推荐库</h4>
<ul>
<li><a href="https://github.com/Akryum/vue-virtual-scroller?spm=5aebb161.2ef5001f.0.0.14b05171CiSQyD" target="_blank" rel="noopener nofollow">vue-virtual-scroller</a></li>
</ul>
<h4 id="示例代码-1">示例代码</h4>
<pre><code class="language-html">&lt;template&gt;
  &lt;RecycleScroller
    class="scroller"
    :items="items"
    :item-size="50"
    key-field="id"
    v-slot="{ item }"
  &gt;
    &lt;div class="item"&gt;{{ item.name }}&lt;/div&gt;
  &lt;/RecycleScroller&gt;
&lt;/template&gt;

&lt;script&gt;
import { RecycleScroller } from 'vue-virtual-scroller';
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css';

export default {
  components: { RecycleScroller },
  data() {
    return {
      items: Array.from({ length: 1000 }, (_, i) =&gt; ({ id: i, name: `Item ${i}` }))
    };
  }
};
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3257203/202502/3257203-20250223141427446-1099932152.jpg" alt="" loading="lazy"></p>
<hr>
<h3 id="4-缓存计算属性和方法避免重复计算">4. 缓存计算属性和方法：避免重复计算</h3>
<p>对于开销较大的计算属性或方法，可以使用缓存来避免重复计算。Vue3 的 <code>computed</code>属性本身具有缓存特性，但对于方法，可以通过手动缓存优化。</p>
<h4 id="示例代码-2">示例代码</h4>
<pre><code class="language-javascript">export default {
  data() {
    return {
      cachedResult: null
    };
  },
  methods: {
    expensiveOperation(input) {
      if (this.cachedResult === null) {
        this.cachedResult = this.performExpensiveCalculation(input);
      }
      return this.cachedResult;
    },
    performExpensiveCalculation(input) {
      // 模拟复杂计算
      return input * 2;
    }
  }
};
</code></pre>
<hr>
<h3 id="5-优化图片加载提升页面加载速度">5. 优化图片加载：提升页面加载速度</h3>
<p>图片是影响页面加载速度的重要因素。通过以下方法可以有效优化图片加载：</p>
<ul>
<li>使用现代图片格式（如 WebP）。</li>
<li>根据屏幕分辨率加载不同尺寸的图片。</li>
<li>延迟加载（Lazy Load）非关键图片。</li>
</ul>
<h4 id="示例代码-3">示例代码</h4>
<pre><code class="language-html">&lt;img src="placeholder.jpg" data-src="high-res-image.webp" class="lazyload"&gt;
</code></pre>
<h4 id="工具推荐">工具推荐</h4>
<ul>
<li><a href="https://github.com/aFarkas/lazysizes?spm=5aebb161.2ef5001f.0.0.14b05171CiSQyD" target="_blank" rel="noopener nofollow">Lazysizes</a></li>
</ul>
<hr>
<h3 id="6-精准控制渲染v-memo-高阶用法">6. 精准控制渲染：v-memo 高阶用法</h3>
<p>性能对比：在 1000 个节点的列表中，使用 <code>v-memo</code> 可使渲染速度提升 4 倍。</p>
<h4 id="示例代码-4">示例代码</h4>
<pre><code class="language-html">&lt;!-- 仅当 id 或 msg 变化时重新渲染 --&gt;
&lt;div v-for="item in list" :key="item.id" v-memo="[item.id, item.msg]"&gt;
  {{ item.msg }}
&lt;/div&gt;

&lt;!-- 与 React 的 shouldComponentUpdate 对比 --&gt;
&lt;ChildComponent 
  v-memo="[prop1, prop2]"
  :prop1="value1"
  :prop2="value2" 
/&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3257203/202502/3257203-20250223141453135-274121733.jpg" alt="" loading="lazy"></p>
<hr>
<h3 id="7-路由懒加载加快初始加载速度">7. 路由懒加载：加快初始加载速度</h3>
<p>通过路由懒加载，可以将不同的路由模块分割成独立的文件，按需加载。</p>
<h4 id="示例代码-5">示例代码</h4>
<pre><code class="language-javascript">const routes = [
  {
    path: '/home',
    component: () =&gt; import('./views/Home.vue')
  }
];
</code></pre>
<hr>
<h3 id="8-构建优化双剑客tree-shaking--代码分割">8. 构建优化双剑客：Tree Shaking + 代码分割</h3>
<h4 id="webpack-配置示例">Webpack 配置示例：</h4>
<pre><code class="language-javascript">// vue.config.js
module.exports = {
  configureWebpack: {
    optimization: {
      splitChunks: {
        chunks: 'all',
        minSize: 20000,
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
          }
        }
      }
    }
  }
}
</code></pre>
<h4 id="分析工具推荐">分析工具推荐：</h4>
<ul>
<li>webpack-bundle-analyzer 可视化分析打包结果</li>
<li>Lighthouse 性能评分对比</li>
</ul>
<hr>
<h3 id="9-数据请求优化防抖-vs-节流-vs-批量">9. 数据请求优化：防抖 vs 节流 vs 批量</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>场景</th>
<th>实现示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>防抖</td>
<td>搜索框输入</td>
<td>Lodash <code>debounce</code></td>
</tr>
<tr>
<td>节流</td>
<td>滚动加载</td>
<td>Lodash <code>throttle</code></td>
</tr>
<tr>
<td>批量</td>
<td>表单提交</td>
<td>Axios 拦截器合并请求</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">// 批量请求拦截器
let pendingRequests = [];

axios.interceptors.request.use(config =&gt; {
  if (config.url.endsWith('/batch')) {
    pendingRequests.push(config);
    return new Promise(resolve =&gt; setTimeout(() =&gt; {
      const batchData = pendingRequests.map(req =&gt; req.data);
      resolve({ ...config, data: batchData });
    }, 50));
  }
  return config;
});
</code></pre>
<hr>
<h3 id="10-响应式编程优化ref-家族的正确打开方式">10. 响应式编程优化：Ref 家族的正确打开方式</h3>
<p>性能对比实验：</p>
<pre><code class="language-javascript">// ❌ 低效写法
const obj = reactive({ a: 1, b: 2 });
watch(obj, () =&gt; {...}); // 监听整个对象

// ✅ 高效写法
const a = ref(1);
const b = ref(2);
watch([a, b], ([newA, newB]) =&gt; {...}); // 精准监听
</code></pre>
<p><strong>结语</strong>：性能优化是一个持续的过程<br>
优化前后 Lighthouse 评分对比：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td>FCP</td>
<td>2.8s</td>
<td>1.2s</td>
</tr>
<tr>
<td>TTI</td>
<td>4.1s</td>
<td>1.8s</td>
</tr>
<tr>
<td>综合评分</td>
<td>58</td>
<td>92</td>
</tr>
</tbody>
</table>
<p><img src="https://img2024.cnblogs.com/blog/3257203/202502/3257203-20250223141525070-56832010.jpg" alt="" loading="lazy"></p>
<p><strong>互动话题</strong>：你在 Vue 项目中遇到过哪些棘手的性能问题？欢迎在评论区分享你的优化故事！</p>
<blockquote>
<p><strong>写在最后</strong><br>
哈喽！大家好呀，我是 Code_Cracke，一名热爱编程的小伙伴。在这里，我将分享一些实用的开发技巧和经验心得。如果你也对编程充满热情，欢迎关注并一起交流学习！</p>
<p>如果你对这篇文章有任何疑问、建议或者独特的见解，欢迎在评论区留言。无论是探讨技术细节，还是分享项目经验，都能让我们共同进步。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/proer-blog/" target="_blank">Code_Cracke</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/proer-blog/p/18732077" target="_blank">https://www.cnblogs.com/proer-blog/p/18732077</a></p>
</div>
<div class="clear"></div>
</div>
	