
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wJiang/p/18930549" title="发布于 2025-06-16 08:57">
    <span role="heading" aria-level="2">深入剖析开源AI阅读器项目Saga Reader基于大模型的文本转换与富文本渲染优化方案</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-16 08:57">2025-06-16 08:57</span>&nbsp;
<a href="https://www.cnblogs.com/wJiang">姜 萌@cnblogs</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18930549);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18930549', targetLink: 'https://www.cnblogs.com/wJiang/p/18930549', title: '深入剖析开源AI阅读器项目Saga Reader基于大模型的文本转换与富文本渲染优化方案' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>AI阅读器作为一种新型的内容消费工具，正在改变人们获取和处理信息的方式。本文将介绍Saga Reader项目中如何利用大型语言模型(LLM)进行网页内容抓取、智能优化和富文本渲染，特别是如何通过精心设计的提示词(prompt)引导LLM生成样式丰富的HTML内容，提升用户阅读体验。</p>
<h3 id="关于saga-reader">关于Saga Reader</h3>
<p>基于Tauri开发的著名开源AI驱动的智库式阅读器（前端部分使用Web框架），能根据用户指定的主题和偏好关键词自动从互联网上检索信息。它使用云端或本地大型模型进行总结和提供指导，并包括一个AI驱动的互动阅读伴读功能，你可以与AI讨论和交换阅读内容的想法。</p>
<p><a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><strong>Github - Saga Reader</strong></a>，完全<strong>开源</strong>，可外部服务<strong>0依赖</strong>，可<strong>纯本地</strong>电脑运行的AI项目。欢迎大家关注分享。🧑‍💻码农🧑‍💻开源不易，各位好人路过请给个小星星💗<strong>Star</strong>💗。</p>
<p><strong>核心技术栈</strong>：Rust + Tauri（跨平台）+ Svelte（前端）+ LLM（大语言模型集成），支持<strong>本地 / 云端双模式</strong></p>
<p><strong>关键词</strong>：端智能，边缘大模型；Tauri 2.0；桌面端安装包 &lt; 5MB，内存占用 &lt; 20MB。</p>
<p><strong>运行截图</strong><br>
<img src="https://img2024.cnblogs.com/blog/98620/202506/98620-20250616085402117-584361747.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/98620/202506/98620-20250616085407205-1991642233.png" alt="" loading="lazy"></p>
<h2 id="系统架构概述">系统架构概述</h2>
<p>Saga Reader的内容处理流程主要包含以下几个关键步骤：<br>
<img src="https://img2024.cnblogs.com/blog/98620/202506/98620-20250616085418505-631487134.png" alt="" loading="lazy"></p>
<ol>
<li><strong>内容抓取</strong>：通过爬虫或RSS获取原始网页内容</li>
<li><strong>内容净化(Purge)</strong>：清理原始HTML中的无关元素</li>
<li><strong>内容优化(Optimize)</strong>：将净化后的内容转换为富文本格式</li>
<li><strong>内容摘要(Melt)</strong>：生成文章摘要</li>
<li><strong>内容渲染</strong>：在前端展示优化后的内容</li>
</ol>
<p>这些步骤形成了一个完整的内容处理管道，每个环节都由专门的处理器负责。</p>
<h2 id="基于llm的文章处理器">基于LLM的文章处理器</h2>
<p>在Saga Reader中，文章处理的核心是<code>ArticleLLMProcessor</code>类，它实现了<code>IArticleProcessor</code>接口，负责调用LLM进行内容转换：</p>
<pre><code class="language-rust:crates/intelligent/src/article_processor/llm_processor.rs">/// 基于LLM的文章处理器。
pub struct ArticleLLMProcessor {
    /// Agent化的生成式服务实例。
    agent: CompletionAgent,
    /// 用于与Agent交互的user prompt。
    user_prompt_command: String,
}

impl IArticleProcessor for ArticleLLMProcessor {
    async fn process(&amp;self, input: &amp;Article) -&gt; anyhow::Result&lt;Article&gt; {
        let mut output = input.clone();
        let content = output.content.as_ref().unwrap();
        let mut chat = format!(r#"## 原内容\n"{}"\n"#, content);
        chat.push_str(self.user_prompt_command.as_str());
        let content = self.agent.completion(chat).await?;
        output.content.replace(content);
        Ok(output)
    }
}
</code></pre>
<p>这个处理器的工作方式很直观：它接收一篇文章，将文章内容与预设的提示词组合，发送给LLM，然后用LLM的输出替换原始内容。</p>
<h2 id="优化器optimizer的实现">优化器(Optimizer)的实现</h2>
<p>在内容处理管道中，优化器(Optimizer)是将净化后的内容转换为富文本格式的关键组件：</p>
<pre><code class="language-rust:crates/intelligent/src/article_processor/optimizer.rs">pub struct Optimizer {}

impl IPresetArticleLLMProcessor for Optimizer {
    fn new_processor(llm_section: LLMSection) -&gt; anyhow::Result&lt;ArticleLLMProcessor&gt; {
        let options = AITargetOption {
            temperature: Some(0.1),
            ..Default::default()
        };
        ArticleLLMProcessor::new(llm_section, SYSTEM_PROMPT.into(), USER_PROMPT_COMMAND_OPTIMIZE.into(), options)
    }
}
</code></pre>
<p>优化器使用较低的temperature值(0.1)，这有助于生成更加确定性的输出，确保HTML结构的一致性和稳定性。</p>
<h2 id="从markdown到富html的转变">从Markdown到富HTML的转变</h2>
<p>最近的一项重要升级是将LLM的输出从简单的Markdown转变为样式丰富的HTML。这一转变的核心在于系统提示词(System Prompt)的设计。</p>
<h3 id="系统提示词设计">系统提示词设计</h3>
<p>新的系统提示词将LLM定位为"专业内容设计师"，要求它生成"视觉现代化的HTML电子邮件片段"：</p>
<pre><code class="language-html:crates/intelligent/src/article_processor/prompts/optimizer_sys.prompt">You are to act as a professional Content Designer. Your task is to convert the provided article into **visually modern HTML email snippets** that render well in modern email clients like Hotmail.
</code></pre>
<h3 id="few-shot示例约束">Few-shot示例约束</h3>
<p>提示词中包含了多种HTML组件的模板，作为few-shot示例，引导LLM按照特定的样式生成内容：</p>
<ol>
<li><strong>标准段落</strong>：用于介绍、结论和过渡文本</li>
<li><strong>要点列表</strong>：用于组织多个核心观点</li>
<li><strong>强调文本</strong>：用于突出关键词或短语</li>
<li><strong>引用块</strong>：用于突出重要观点或原文引用</li>
<li><strong>图片块</strong>：用于嵌入文章中的图片</li>
</ol>
<p>例如，要点列表的模板如下：</p>
<pre><code class="language-html:crates/intelligent/src/article_processor/prompts/optimizer_sys.prompt">&lt;ul style="margin:20px 0; padding-left:0; list-style-type:none;"&gt;
&lt;li style="position:relative; margin-bottom:12px; padding-left:28px; font-family:'Google Sans',Roboto,Arial,sans-serif; font-size:15px; line-height:1.6" class="text-surface-700-300"&gt;
    &lt;span class="preset-filled-primary-500" style="position:absolute; left:0; top:0; width:18px; height:18px; border-radius:50%; color:white; text-align:center; line-height:18px; font-size:12px;"&gt;1&lt;/span&gt;
    Description of the first key point
&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="输出要求">输出要求</h3>
<p>提示词还详细规定了输出的要求，包括：</p>
<ul>
<li>美观优雅的设计，和谐的配色方案</li>
<li>一致的视觉风格</li>
<li>将Markdown图片链接转换为HTML img标签</li>
<li>使用多种视觉元素增强可读性</li>
<li>移除与正文无关的操作性信息</li>
<li>翻译为中文</li>
<li>使用过渡文本连接各个组件</li>
<li>适当引用重要的原文片段</li>
<li>使用高亮样式标记关键点</li>
</ul>
<h2 id="前端渲染实现">前端渲染实现</h2>
<p>在前端，<code>ArticleRenderWidget.svelte</code>组件负责渲染优化后的内容：</p>
<pre><code class="language-svelte:app/src/lib/widgets/ArticleRenderWidget.svelte">&lt;script lang="ts"&gt;
	/** eslint-disable svelte/no-at-html-tags */
	import type { ArticleRenderProps, ArticleRenderType } from './types';
	import Markdown from './Markdown.svelte';
	import { removeCodeBlockWrapper } from '$lib/utils/text';
	import { featuresApi } from '$lib/hybrid-apis/feed/impl';
	import { onMount } from 'svelte';

	const { value }: ArticleRenderProps = $props();
	const purgedHtml = $derived(removeCodeBlockWrapper(value));
	const renderType: ArticleRenderType = $derived(purgedHtml[0] === '&lt;' ? 'html' : 'markdown');
	let htmlContainer: HTMLDivElement | null = $state(null);

	onMount(() =&gt; {
		if (!htmlContainer) return;
		const anchorClickInterceptor = (event: MouseEvent) =&gt; {
			// 检查点击的元素是否是一个链接
			const target = event.target as HTMLElement;
			if (target?.tagName === 'A') {
				// 阻止默认的链接跳转行为
				event.preventDefault();
				// 获取链接的 href 属性
				const url = (target as HTMLAnchorElement).href;
				// 调用特定函数来处理链接
				featuresApi.open_article_external(url);
			}
		};
		(htmlContainer as HTMLDivElement).addEventListener('click', anchorClickInterceptor);
		return () =&gt; {
			(htmlContainer as HTMLDivElement).removeEventListener('click', anchorClickInterceptor);
		};
	});
&lt;/script&gt;

{#if renderType === 'html'}
	&lt;div bind:this={htmlContainer} class="p-6 preset-filled-surface-50-950"&gt;{@html purgedHtml}&lt;/div&gt;
{:else}
	&lt;Markdown {value} /&gt;
{/if}
</code></pre>
<p>该组件能够智能判断内容类型，对HTML和Markdown分别采用不同的渲染方式：</p>
<ul>
<li>对于HTML内容，直接使用Svelte的<code>{@html}</code>指令渲染</li>
<li>对于Markdown内容，使用<code>Markdown.svelte</code>组件渲染</li>
</ul>
<p>此外，组件还实现了链接点击拦截，确保外部链接在适当的环境中打开。</p>
<h2 id="内容处理流水线">内容处理流水线</h2>
<p>在<code>FeaturesAPIImpl</code>中，我们可以看到完整的内容处理流水线：</p>
<pre><code class="language-rust:crates/feed_api_rs/src/features/impl_default.rs">async fn process_article_pipelines(
    &amp;self,
    article: &amp;mut Article,
    purge: &amp;ArticleLLMProcessor,
    optimizer: &amp;ArticleLLMProcessor,
    melt: &amp;ArticleLLMProcessor,
) -&gt; anyhow::Result&lt;(Article, Article, Article)&gt; {
    let out_purged_article = purge.process(article).await?;
    info!(
        "article purged, title = {}, source_link = {}, optimizing",
        article.title, article.source_link
    );

    let out_optimized_article = optimizer.process(&amp;out_purged_article).await?;
    info!(
        "purged article optimized, title = {}, melting",
        out_purged_article.title
    );
    if let Some(optimized_content) = out_optimized_article.content.clone() {
        if optimized_content.contains("QINO-AGENTIC-EXECUTION-FAILURE") {
            return Err(anyhow::Error::msg("QINO-AGENTIC-EXECUTION-FAILURE"));
        }
    }

    let out_melted_article = melt.process(&amp;out_optimized_article).await?;
    info!(
        "optimized article melted, title = {}, recording",
        out_melted_article.title
    );

    Ok((
        out_purged_article,
        out_optimized_article,
        out_melted_article,
    ))
}
</code></pre>
<p>这个方法依次调用三个处理器：</p>
<ol>
<li><code>purge</code>：清理原始HTML</li>
<li><code>optimizer</code>：将净化后的内容转换为富文本</li>
<li><code>melt</code>：生成文章摘要</li>
</ol>
<p>处理完成后，返回三个版本的文章，分别对应处理流程的三个阶段。</p>
<h2 id="技术亮点与创新">技术亮点与创新</h2>
<h3 id="1-基于few-shot的html样式约束">1. 基于Few-shot的HTML样式约束</h3>
<p>通过在系统提示词中提供HTML组件的模板，我们实现了对LLM输出的精确控制。这种few-shot示例约束的方法，使LLM能够生成符合预期样式的HTML内容，而不是简单的文本或基础Markdown。</p>
<h3 id="2-多模态内容处理管道">2. 多模态内容处理管道</h3>
<p>Saga Reader实现了一个完整的内容处理管道，从原始网页到富文本展示，每个环节都由专门的处理器负责。这种模块化设计使系统易于维护和扩展。</p>
<h3 id="3-智能渲染适配">3. 智能渲染适配</h3>
<p>前端组件能够智能判断内容类型，对HTML和Markdown分别采用不同的渲染方式，确保最佳的展示效果。</p>
<h2 id="结论">结论</h2>
<p>Saga Reader项目通过精心设计的提示词和完整的内容处理管道，成功地将大型语言模型应用于文本转换与富文本渲染优化。这种方法不仅提升了用户阅读体验，也为AI辅助内容处理提供了一个可行的实践范例。</p>
<p>未来，我们可以进一步探索更多的视觉元素和交互方式，使AI生成的内容更加丰富多样，更好地满足用户的阅读需求。同时，随着大型语言模型能力的不断提升，我们也可以期待更加智能和个性化的内容处理方案。</p>
<h2 id="-saga-reader系列技术文章">📝 Saga Reader系列技术文章</h2>
<ul>
<li><a href="https://www.cnblogs.com/wJiang/p/18873839" target="_blank">开源我的一款自用AI阅读器，引流Web前端、Rust、Tauri、AI应用开发</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18883448" target="_blank">【实战】深入浅出 Rust 并发：RwLock 与 Mutex 在 Tauri 项目中的实践</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18895168" target="_blank">【实战】Rust与前端协同开发：基于Tauri的跨平台AI阅读器实践</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18896688" target="_blank">揭秘 Saga Reader 智能核心：灵活的多 LLM Provider 集成实践 (Ollama, GLM, Mistral 等)</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18915251" target="_blank">Svelte 5 在跨平台 AI 阅读助手中的实践：轻量化前端架构的极致性能优化<br>
</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18915252" target="_blank">Svelte 5状态管理实战：基于Tauri框架的AI阅读器Saga Reader开发实践</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18921999" target="_blank">Svelte 5 状态管理全解析：从响应式核心到项目实战</a></li>
<li><a href="https://www.cnblogs.com/wJiang/p/18928723" target="_blank">【实战】基于 Tauri 和 Rust 实现基于无头浏览器的高可用网页抓取</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>&nbsp;</p>
<div style="filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=1,StartColorStr='#6699FF',EndColorStr='#A1FBFF">
<table>
<tbody>
<tr>
<td rowspan="4"><img alt="" src="https://images.cnblogs.com/cnblogs_com/wJiang/233935/t_a.jpg"></td>
<td>
<p>网名：</p></td>
<td>
<p>无疆_炎戎<br>无疆_寒冰</p></td></tr>
<tr>
<td>
<p>实名：</p>
</td><td>
<p>姜萌</p></td></tr>
<tr>
<td colspan="2"><a href="http://www.wjiangathpc.spaces.live.com/" target="_blank">http://www.wjiangathpc.spaces.live.com/</a></td></tr>
<tr>
<td colspan="2"><a href="http://www.cnblogs.com/wJiang" target="_blank">http://www.cnblogs.com/wJiang</a></td></tr></tbody></table></div>
<p>&nbsp;</p>
<div id="license"><a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" alt="Creative Commons License" src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png"></a><br>本<span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" rel="dc:type">作品</span>由<a href="http://www.cnblogs.com/" rel="cc:attributionURL" target="_blank" xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">姜萌</a>创作，采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank">知识共享署名 2.5 中国大陆许可协议</a>进行许可。 </div>
</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="wJiang" blog-id="64968" post-id="18930549"></vc:categories-tags>
    </ul>
