
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sanyejun/p/19002339" title="发布于 2025-07-24 10:58">
    <span role="heading" aria-level="2">从Mono脚本生成Entity：深入理解Unity DOTS中的Archetype、Chunk与Entity结构设计</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-pm-slice="1 1 []">Unity 的 DOTS（Data-Oriented Technology Stack）是面向性能极致优化的一种架构范式，其底层结构设计并非偶然，而是深思熟虑的结果。本篇文章将从开发者最熟悉的入口——MonoBehaviour 脚本 + Baker 入手，逐步剖析 DOTS 中 Entity 是如何生成与组织的，并深入理解其底层架构：Archetype、Chunk、Entity 的设计逻辑和动机。</p>
<div><hr></div>
<h2>一、从 MonoBehaviour + Baker 生成 Entity 说起</h2>
<p>在 Unity DOTS 中，我们通过 Authoring + Baker 的方式将传统的 GameObject 转换为 Entity。一个常见的写法如下：</p>
<pre><code>public class MonsterAuthoring : MonoBehaviour
{
    public int MonsterType;

    class Baker : Baker&lt;MonsterAuthoring&gt;
    {
        public override void Bake(MonsterAuthoring authoring)
        {
            var entity = GetEntity(TransformUsageFlags.Dynamic);
            AddComponent(entity, new Health { Value = 100 });
            AddComponent(entity, new Translation { Value = float3.zero });
            AddSharedComponent(entity, new MonsterType { TypeId = authoring.MonsterType });
        }
    }
}</code></pre>
<p>表面上看，我们只是在添加组件。然而在背后，Unity DOTS 会根据这些组件自动为这个 Entity 创建归属结构——Archetype，并为其分配内存空间——Chunk。</p>
<div><hr></div>
<h2>二、Entity 是什么？</h2>
<p>Entity 是 DOTS 中最基本的单位，但本身并不存储任何数据，它只是一个引用句柄：</p>
<pre><code>public struct Entity
{
    public int Index;     // 在内部数组中的位置
    public int Version;   // 生命周期安全检测用
}</code></pre>
<p>Entity 代表的是一个“ID”，它的数据存在 Chunk 中，它的组件定义了它的“能力和状态”。</p>
<div><hr></div>
<h2>三、Archetype：组件组合定义实体结构</h2>
<p>当你给一个 Entity 添加了多个组件时，Unity 会自动根据这些组件的集合定义一个 Archetype。它可以理解为一个“结构签名”：</p>
<p>例如：</p>
<pre><code>Archetype A = [Translation, Health, MonsterType]
Archetype B = [Translation, Velocity]</code></pre>
<p>所有具有相同组件组合的 Entity 都属于同一个 Archetype。这样做的好处是：</p>
<ul data-spread="false">
<li>
<p>可以快速定位拥有某些组件的所有实体</p>
</li>
<li>
<p>方便数据批处理</p>
</li>
<li>
<p>支持结构化存储（方便内存布局）</p>
</li>
</ul>
<div><hr></div>
<h2>四、Chunk：结构化内存块</h2>
<p>每个 Archetype 拥有若干个 Chunk。Chunk 是 DOTS 中用于存储实体数据的最小单位。</p>
<h3>✅ Chunk 特点：</h3>
<ul data-spread="false">
<li>
<p>大小固定为 <strong>16KB</strong>（Unity 内部固定）</p>
</li>
<li>
<p>所有 Entity 的组件数据按列式存储</p>
</li>
<li>
<p>每个 Chunk 只容纳一种 Archetype 的实体</p>
</li>
<li>
<p>同一个 Chunk 中所有 Entity 的 SharedComponent 值必须一致</p>
</li>
</ul>
<h3>🧮 一个 Chunk 容纳多少个 Entity？</h3>
<p>取决于每个 Entity 拥有组件数据的总大小。</p>
<p>例如：</p>
<ul data-spread="false">
<li>
<p>Entity 每个数据 32B，则 Chunk 容纳 16KB / 32 ≈ 512 个</p>
</li>
<li>
<p>若数据变大（如包含 float4x4），Entity 变少</p>
</li>
</ul>
<div><hr></div>
<h2>五、SharedComponent：控制 Chunk 分类的关键</h2>
<p>SharedComponent 是一种特殊的组件，实现了 <code>ISharedComponentData</code> 接口。它的值不能在 Entity 级别存储，而是存储在 Chunk 的 header 区域。</p>
<h3>特性：</h3>
<ul data-spread="false">
<li>
<p>所有 Chunk 内的 Entity 必须拥有相同的 SharedComponent 值</p>
</li>
<li>
<p>值不同的 Entity 不能放在同一个 Chunk 中</p>
</li>
<li>
<p>更改 SharedComponent 值会导致 Entity 搬家（Chunk 移动）</p>
</li>
</ul>
<h3>使用场景：</h3>
<ul data-spread="false">
<li>
<p>怪物类型分类（如 MonsterType）</p>
</li>
<li>
<p>LOD 分组、区域分组、渲染材质分组（RenderMeshArray）</p>
</li>
</ul>
<h3>注意：频繁更改 SharedComponent 会引起性能抖动</h3>
<div><hr></div>
<h2>六、为什么 Chunk 是 16KB？</h2>
<p>这个数字是深思熟虑后的硬件适配值：</p>
<ul data-spread="false">
<li>
<p>L1 Cache 一般为 32KB，每个 Chunk 16KB 可以保证高缓存命中率</p>
</li>
<li>
<p>L2 Cache 较大，也能容纳多个 Chunk</p>
</li>
<li>
<p>16KB 是内存对齐、批处理、页管理的黄金折中值</p>
</li>
</ul>
<p>太小：Entity 太少、效率低 太大：Cache 溢出、处理慢</p>
<p>因此 Unity 默认设定为 16KB，不可修改。</p>
<div><hr></div>
<h2>七、Archetype、Chunk、Entity 的组织结构图（文字版）</h2>
<pre><code>Archetype A: [Translation, Health, MonsterType]
│
├─ Chunk A1 (MonsterType = 1)
│   ├─ Entity 1
│   ├─ Entity 2
│   └─ ...
│
├─ Chunk A2 (MonsterType = 2)
│   ├─ Entity 1001
│   └─ ...
└─ ...</code></pre>
<div><hr></div>
<h2>八、总结：设计背后的哲学</h2>
<p>Unity DOTS 的 Archetype-Chuck-Entity 结构，融合了以下领域的精髓：</p>
<table>
<tbody>
<tr><th>灵感来源</th><th>应用点</th></tr>
<tr>
<td>数据导向设计 DoD</td>
<td>构建 Archetype 以优化访问结构</td>
</tr>
<tr>
<td>列式数据库</td>
<td>Chunk 内组件按列排列</td>
</tr>
<tr>
<td>稀疏集合（Index+Version）</td>
<td>安全地管理 Entity 生命周期</td>
</tr>
<tr>
<td>GPU 渲染管线</td>
<td>SharedComponent 控制分组渲染</td>
</tr>
</tbody>
</table>
<p>其核心目标是：<strong>利用现代硬件缓存特性，让大规模数据更新与处理高效而可控。</strong></p>
<div><hr></div>
<h2>九、附：如何查看实际 Chunk/Archetype</h2>
<ul data-spread="false">
<li>
<p>通过 <code>Entities Hierarchy</code>（Window → Entities）可视化工具查看 Chunk 分布</p>
</li>
<li>
<p>通过代码：</p>
</li>
</ul>
<pre><code>EntityQuery query = GetEntityQuery(typeof(Health), typeof(MonsterType));
var chunks = query.ToArchetypeChunkArray(Allocator.Temp);
Debug.Log($"Archetype has {chunks.Length} chunks");</code></pre>
<div><hr></div>
<h2>结语</h2>
<p>你只是在 Mono 脚本里写了几行 AddComponent，Unity 在背后已经帮你构建好了复杂而高效的数据处理架构。这就是 DOTS 的魅力所在——开发者专注逻辑，系统保障性能。</p>
<p>理解 Archetype、Chunk、Entity 的内在原理，是走向 DOTS 高效架构设计的第一步。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-07-24 11:01">2025-07-24 10:58</span>&nbsp;
<a href="https://www.cnblogs.com/sanyejun">三页菌</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19002339);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19002339', targetLink: 'https://www.cnblogs.com/sanyejun/p/19002339', title: '从Mono脚本生成Entity：深入理解Unity DOTS中的Archetype、Chunk与Entity结构设计' })">举报</a>
</div>
        