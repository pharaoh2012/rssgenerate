
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18904611" title="发布于 2025-05-30 17:19">
    <span role="heading" aria-level="2">【对称加密】DES与AES算法详解及Java实现</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="对称加密des与aes算法详解及java实现">对称加密：DES与AES算法详解及Java实现</h1>
<h2 id="目录">目录</h2>
<ol>
<li><a href="#1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%A6%82%E8%BF%B0" rel="noopener nofollow">对称加密概述</a></li>
<li><a href="#2-des%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3" rel="noopener nofollow">DES算法详解</a></li>
<li><a href="#3-aes%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3" rel="noopener nofollow">AES算法详解</a></li>
<li><a href="#4-java%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B" rel="noopener nofollow">Java实现示例</a></li>
<li><a href="#5-%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="noopener nofollow">安全注意事项</a></li>
<li><a href="#6-%E6%80%BB%E7%BB%93" rel="noopener nofollow">总结</a></li>
</ol>
<hr>
<h2 id="1-对称加密概述">1. 对称加密概述</h2>
<p>对称加密是指加密和解密使用相同密钥的加密算法。主要特点包括：</p>
<ul>
<li><strong>高效性</strong>：比非对称加密快100-1000倍</li>
<li><strong>密钥管理</strong>：需要安全地共享密钥</li>
<li><strong>常见算法</strong>：DES、3DES、AES、Blowfish等</li>
<li><strong>应用场景</strong>：大数据量加密、SSL/TLS会话密钥、磁盘加密等</li>
</ul>
<p><strong>基本流程</strong>：</p>
<pre><code>明文 + 密钥 → 加密算法 → 密文
密文 + 密钥 → 解密算法 → 明文
</code></pre>
<hr>
<h2 id="2-des算法详解">2. DES算法详解</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><strong>Data Encryption Standard</strong> (数据加密标准)</li>
<li>1977年被NIST采纳为联邦标准</li>
<li>分组长度：64位</li>
<li>密钥长度：56位（实际64位，含8位奇偶校验）</li>
<li>已被认为不够安全（1999年被暴力破解）</li>
</ul>
<h3 id="核心原理">核心原理</h3>
<ol>
<li><strong>初始置换(IP)</strong>：打乱64位明文的顺序</li>
<li><strong>16轮Feistel网络</strong>：
<ul>
<li>将数据分为左右两半(各32位)</li>
<li>右半通过扩展置换(32→48位)</li>
<li>与子密钥异或</li>
<li>通过S盒替换(48→32位)</li>
<li>与左半异或并交换左右</li>
</ul>
</li>
<li><strong>最终置换(FP)</strong>：IP的逆置换</li>
</ol>
<h3 id="密钥生成">密钥生成</h3>
<ol>
<li>从64位密钥中去掉8位校验位</li>
<li>通过置换选择PC-1得到56位密钥</li>
<li>每轮左移1-2位生成16个子密钥</li>
</ol>
<p><strong>安全性问题</strong>：</p>
<ul>
<li>56位密钥太小（2⁵⁶种可能）</li>
<li>存在弱密钥和半弱密钥</li>
<li>已被AES取代</li>
</ul>
<hr>
<h2 id="3-aes算法详解">3. AES算法详解</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li><strong>Advanced Encryption Standard</strong> (高级加密标准)</li>
<li>2001年取代DES成为新标准</li>
<li>分组长度：128位</li>
<li>密钥长度：128/192/256位</li>
<li>目前最安全的对称加密算法</li>
</ul>
<h3 id="核心原理rijndael算法">核心原理(Rijndael算法)</h3>
<ol>
<li><strong>字节替换(SubBytes)</strong>：使用S盒进行非线性替换</li>
<li><strong>行移位(ShiftRows)</strong>：每行循环左移不同位数</li>
<li><strong>列混淆(MixColumns)</strong>：矩阵乘法混淆数据</li>
<li><strong>轮密钥加(AddRoundKey)</strong>：与子密钥异或</li>
</ol>
<p><strong>加密轮数</strong>：</p>
<ul>
<li>128位密钥：10轮</li>
<li>192位密钥：12轮</li>
<li>256位密钥：14轮</li>
</ul>
<h3 id="密钥扩展">密钥扩展</h3>
<ul>
<li>将初始密钥扩展为(轮数+1)×128位的轮密钥</li>
<li>使用Rcon常量和S盒进行非线性变换</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>更强的安全性（最小128位密钥）</li>
<li>更高的效率（适合硬件实现）</li>
<li>无已知的有效攻击方式</li>
</ul>
<hr>
<h2 id="4-java实现示例">4. Java实现示例</h2>
<h3 id="des加密解密示例">DES加密解密示例</h3>
<pre><code class="language-java">import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;
import java.security.spec.KeySpec;

public class DESExample {
    public static void main(String[] args) throws Exception {
        String plainText = "Hello, DES!";
        String secretKey = "MySecretKey"; // 至少8字节
        
        // 密钥生成
        KeySpec keySpec = new DESKeySpec(secretKey.getBytes());
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
        SecretKey key = keyFactory.generateSecret(keySpec);
        
        // 加密
        Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encrypted = cipher.doFinal(plainText.getBytes());
        System.out.println("Encrypted: " + bytesToHex(encrypted));
        
        // 解密
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decrypted = cipher.doFinal(encrypted);
        System.out.println("Decrypted: " + new String(decrypted));
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X", b));
        }
        return sb.toString();
    }
}
</code></pre>
<h3 id="aes加密解密示例">AES加密解密示例</h3>
<pre><code class="language-java">import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public class AESExample {
    public static void main(String[] args) throws Exception {
        String plainText = "Hello, AES!";
        String secretKey = "MySuperSecretKey123"; // 16/24/32字节
        
        // 确保密钥长度正确
        byte[] keyBytes = new byte[16]; // 128位
        System.arraycopy(secretKey.getBytes(), 0, keyBytes, 0, Math.min(secretKey.length(), keyBytes.length));
        SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
        
        // 加密
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encrypted = cipher.doFinal(plainText.getBytes());
        System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(encrypted));
        
        // 解密
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decrypted = cipher.doFinal(encrypted);
        System.out.println("Decrypted: " + new String(decrypted));
    }
}
</code></pre>
<h3 id="更安全的aes-cbc模式示例">更安全的AES-CBC模式示例</h3>
<pre><code class="language-java">import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public class AESCBCExample {
    public static void main(String[] args) throws Exception {
        String plainText = "Hello, AES CBC Mode!";
        String secretKey = "ThisIsA128BitKey!!"; // 16字节
        
        // 生成随机IV（初始化向量）
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        
        SecretKeySpec key = new SecretKeySpec(secretKey.getBytes(), "AES");
        
        // 加密
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
        byte[] encrypted = cipher.doFinal(plainText.getBytes());
        
        // 组合IV和密文（IV不需要保密）
        byte[] combined = new byte[iv.length + encrypted.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
        
        System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(combined));
        
        // 解密
        byte[] extractedIv = new byte[16];
        byte[] extractedCipherText = new byte[combined.length - 16];
        System.arraycopy(combined, 0, extractedIv, 0, 16);
        System.arraycopy(combined, 16, extractedCipherText, 0, extractedCipherText.length);
        
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(extractedIv));
        byte[] decrypted = cipher.doFinal(extractedCipherText);
        System.out.println("Decrypted: " + new String(decrypted));
    }
}
</code></pre>
<hr>
<h2 id="5-安全注意事项">5. 安全注意事项</h2>
<h3 id="密钥管理">密钥管理</h3>
<ol>
<li><strong>密钥生成</strong>：使用<code>SecureRandom</code>生成随机密钥</li>
<li><strong>密钥存储</strong>：使用密钥管理系统或硬件安全模块(HSM)</li>
<li><strong>密钥轮换</strong>：定期更换密钥</li>
</ol>
<h3 id="算法选择建议">算法选择建议</h3>
<ul>
<li><strong>优先使用AES</strong>：至少128位，推荐256位</li>
<li><strong>避免使用DES</strong>：除非遗留系统要求</li>
<li><strong>模式选择</strong>：
<ul>
<li>CBC模式（需要随机IV）</li>
<li>GCM模式（同时提供加密和认证）</li>
<li>避免ECB模式（相同明文产生相同密文）</li>
</ul>
</li>
</ul>
<h3 id="其他安全实践">其他安全实践</h3>
<ol>
<li>始终使用完整的初始化向量(IV)</li>
<li>对密文进行完整性验证（如HMAC）</li>
<li>使用适当的填充方案（PKCS#5/PKCS#7）</li>
<li>处理<code>BadPaddingException</code>时不泄露具体错误信息</li>
</ol>
<hr>
<h2 id="6-总结">6. 总结</h2>
<h3 id="对比des和aes">对比DES和AES</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>DES</th>
<th>AES</th>
</tr>
</thead>
<tbody>
<tr>
<td>密钥长度</td>
<td>56位</td>
<td>128/192/256位</td>
</tr>
<tr>
<td>分组大小</td>
<td>64位</td>
<td>128位</td>
</tr>
<tr>
<td>安全性</td>
<td>已不安全</td>
<td>目前安全</td>
</tr>
<tr>
<td>性能</td>
<td>较慢</td>
<td>更快</td>
</tr>
<tr>
<td>轮数</td>
<td>16轮</td>
<td>10/12/14轮</td>
</tr>
</tbody>
</table>
<h3 id="选择建议">选择建议</h3>
<ol>
<li><strong>新系统</strong>：始终使用AES（至少128位）</li>
<li><strong>遗留系统</strong>：考虑3DES过渡到AES</li>
<li><strong>高安全性需求</strong>：使用AES-256 + GCM模式</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<ul>
<li>结合对称和非对称加密（如RSA加密AES密钥）</li>
<li>使用标准库而非自己实现加密算法</li>
<li>定期评估加密方案的安全性</li>
</ul>
<p>通过合理选择和实现对称加密算法，可以有效保护数据机密性。记住加密只是安全体系的一部分，需要结合认证、访问控制等其他措施构建完整的安全解决方案。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.5379796805613426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-30 17:19">2025-05-30 17:19</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">99</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18904611);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18904611', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18904611', title: '【对称加密】DES与AES算法详解及Java实现' })">举报</a>
</div>
        