
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Ydoc770/p/18841003" title="发布于 2025-04-30 19:57">
    <span role="heading" aria-level="2">后缀自动机的构建和应用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>其实是在瞎口胡</p>
<p>参考：<a href="https://www.cnblogs.com/Meatherm/p/16390617.html" target="_blank">Meatherm 的奇妙博客</a></p>
<h2 id="sam-的线性构造">SAM 的线性构造</h2>
<p>SAM 的每个节点都表示一个 endpos 等价类，由于 SAM 和 parent tree 共用节点，所以我们要做的就是在这些节点上添加边使其能接受所有的后缀. 将一个节点的后缀边连向另一个节点表示这个节点的 endpos 等价类中所有串在后面加上一个字符会到达另一个 endpos 等价类. parent tree 上的父亲边将一个节点的 endpos 等价类划分开来，成为互不相交的新等价类，即跳父亲就是前往 endpos 等价类中以当前等价类最短串删去前面的一个字符为最长串的等价类.<br>
我们在后缀自动机的每个节点上存储这个节点的等价类中的最长串长度 <span class="math inline">\(len_i\)</span>，parent tree 上的父亲 <span class="math inline">\(fa_i\)</span> 和后缀边 <span class="math inline">\(ch_c\)</span> 连向的节点.</p>
<p>考虑增量法构建 SAM，即在前面所有的字符 <span class="math inline">\(s_{1\sim i-1}\)</span> 都已经加入 SAM 之后考虑新增 <span class="math inline">\(s_i\)</span> 新增的边. 我们从上次加入后的节点 <span class="math inline">\(lst\)</span> 开始，不难发现，由于新增的字符改变了所有原串的后缀，我们就要给新节点连上后缀边并且找到父亲，也就是说我们要找出 <span class="math inline">\(s_{1\sim i}\)</span> 后缀的所有等价类. 事实上，沿着 <span class="math inline">\(lst\)</span> 的父亲一直向上遍历到根，有结论：</p>
<ul>
<li>
<p>记途中经过的所有等价类的最长串为 <span class="math inline">\(f_1,f_2,\cdots,f_k\)</span>，那么我们就会发现，对于所有和 <span class="math inline">\(f_j\)</span> 在同一个等价类的后缀 <span class="math inline">\(f'_j\)</span>，<span class="math inline">\(f'_j+s_i\)</span> 也在加入字符 <span class="math inline">\(s_i\)</span> 后的 SAM 的同一个等价类中.</p>
<p>并且由于 <span class="math inline">\(f'_j+s_i\)</span> 总是出现在 <span class="math inline">\(s_{x+1}=s_i\)</span> 且 <span class="math inline">\(x\in\text{endpos}(f'_j)\)</span> 的位置 <span class="math inline">\(x\)</span>，所以访问到的 endpos 等价类是不会遗漏的.</p>
</li>
</ul>
<p>所以我们可以从 <span class="math inline">\(p=lst\)</span> 开始不断向上遍历 <span class="math inline">\(fa_p\)</span>，因为后缀的特殊结构决定了上个节点一定是包含之前所有后缀的，就可以根据这个节点是否有 <span class="math inline">\(ch_{c=s_i}\)</span> 这条边来分讨连边情况.</p>
<p>设新增节点为 <span class="math inline">\(nw\)</span>，根节点 <span class="math inline">\(rt=1\)</span>.</p>
<h3 id="case-1">Case 1</h3>
<p>如果 <span class="math inline">\(p\)</span> 没有出边 <span class="math inline">\(ch_c\)</span>，说明当前的 SAM 上缺少 <span class="math inline">\(x+s_i\)</span> 的信息，需要令出边 <span class="math inline">\(ch_c=nw\)</span>，此时需要继续遍历.</p>
<p>那么为什么从 <span class="math inline">\(lst\)</span> 开始遍历 <span class="math inline">\(fa_p\)</span> 找到的串就是我们要更新的信息呢？考虑跳 <span class="math inline">\(fa_p\)</span> 其实是在等价类前面删字符，这样可以遍历之前所有的后缀所在的等价类，再把新增字符 <span class="math inline">\(c\)</span> 对后缀带来的影响表示出来就好了.</p>
<p>当然，如果 <span class="math inline">\(p\)</span> 已经到达根节点，就可以直接令 <span class="math inline">\(fa_{nw}=rt\)</span> 并停止遍历，因为此时必然是第一次加入 <span class="math inline">\(c\)</span> 这个字符.</p>
<h3 id="case-2">Case 2</h3>
<p>如果 <span class="math inline">\(p\)</span> 存在一条出边 <span class="math inline">\(q=ch_c\)</span>，其实我们不能直接让这个等价类直接作为 <span class="math inline">\(fa_{nw}\)</span>. 因为如果 <span class="math inline">\(x+s_i\)</span> 不是 <span class="math inline">\(q\)</span> 的最长串，此时 <span class="math inline">\(q\)</span> 中只有一部分串是 <span class="math inline">\(x+s_i\)</span> 的后缀.</p>
<p>注意 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是父子关系，所以如果 <span class="math inline">\(len_p+1\neq len_q\)</span> 其中必然因为 <span class="math inline">\(c\)</span> 的加入缺失了一部分子串信息，这些缺少的信息是无法通过修改原图增加的，因为原图保证了最小性. 我们必须新增节点把 <span class="math inline">\(q\)</span> 的信息拆一部分出来来添加后缀边维护新的子串并且调整父子关系，由于此时的 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 不再符合父子的要求. 记这个新节点为 <span class="math inline">\(nq\)</span>，令 <span class="math inline">\(len_{nq}=len_{p}+1\)</span>，且 <span class="math inline">\(nq\)</span> 继承所有 <span class="math inline">\(q\)</span> 的出边，此时 <span class="math inline">\(nq\)</span> 与 <span class="math inline">\(q\)</span>，<span class="math inline">\(nq\)</span> 与 <span class="math inline">\(nw\)</span> 符合父子关系，有 <span class="math inline">\(fa_q=fa_{nw}=nq\)</span>. 然后需要修改所有 <span class="math inline">\(p\)</span> 原有 <span class="math inline">\(c\)</span> 出边指向 <span class="math inline">\(q\)</span> 的为 <span class="math inline">\(nq\)</span>，否则后缀边是不连续的.</p>
<p>如果 <span class="math inline">\(len_p+1=len_q\)</span>，说明此时所有字串信息都没有缺失，直接令 <span class="math inline">\(fa_{nw}=q\)</span> 即可.</p>
<p>以上两种子情况都不需要继续遍历 <span class="math inline">\(fa_p\)</span>，因为已经确保操作后维护了所有的性质.</p>
<h2 id="实现">实现</h2>
<p>非常的简短，非常的好写啊</p>
<pre><code class="language-cpp">struct node{int ch[26], fa, len;} t[maxn &lt;&lt; 1];
int lst = 1, tott = 1;
void insert(int c) {
	int p = lst, nw = lst = ++tott; t[nw].len = t[p].len + 1;
	for(; p &amp;&amp; !t[p].ch[c]; p = t[p].fa) t[p].ch[c] = nw;
	if(!p) {t[nw].fa = 1, ans += t[nw].len - t[t[nw].fa].len; return;}
	int q = t[p].ch[c]; if(t[q].len == t[p].len + 1) t[nw].fa = q;
	else {
		int nq = ++tott; t[nq] = t[q];
		t[nq].len = t[p].len + 1; t[q].fa = t[nw].fa = nq;
		for(; p &amp;&amp; t[p].ch[c] == q; p = t[p].fa) t[p].ch[c] = nq;
	}
	return;
}
</code></pre>
<h2 id="应用">应用</h2>
<p>根据 SAM 的强大性质可以解决不少串串题，但是有一些进阶应用还要结合其它数据结构.</p>
<h3 id="最小表示法">最小表示法</h3>
<p>发现这就是找在环上长度为 <span class="math inline">\(n\)</span> 的字典序最小的字串，直接倍长插入到 SAM 中然后从根节点开始不断走字典序最小的字符，走 <span class="math inline">\(n\)</span> 步得到的串即为答案.</p>
<h3 id="求本质不同字串个数">求本质不同字串个数</h3>
<p>根据 SAM 定义，每个节点上压缩的串个数之和就是 <span class="math inline">\(ans\)</span>. 由于 endpos 等价类中的串长度是连续的，所以每个节点 <span class="math inline">\(nw\)</span> 的贡献就是 <span class="math inline">\(len_{nw}-len_{fa_{nw}}\)</span>. 在插入字符时在线统计一下就好了.</p>
<h3 id="求字串出现次数">求字串出现次数</h3>
<p>对于某个子串，从根节点开始走找到对应节点，那么这个节点包括子树内所有节点都出现过这个字串，且一定不重不漏. dfs 数子树大小即可.</p>
<h3 id="求两个多个串的最长公共子串">求两个（多个）串的最长公共子串</h3>
<p>对于两个串的情形，可以对其中一个串建 SAM，另一个串在 SAM 上匹配</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.023026385680555556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-30 19:57">2025-04-30 19:57</span>&nbsp;
<a href="https://www.cnblogs.com/Ydoc770">Ydoc770</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18841003);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18841003', targetLink: 'https://www.cnblogs.com/Ydoc770/p/18841003', title: '后缀自动机的构建和应用' })">举报</a>
</div>
        