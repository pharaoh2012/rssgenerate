
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18688238" title="发布于 2025-01-23 17:19">
    <span role="heading" aria-level="2">『Python底层原理』--CPython 虚拟机</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 <code>Python</code> 编程的世界里，我们每天都在使用 <code>python</code> 命令运行程序，但你是否曾好奇这背后究竟发生了什么？</p>
<p>本文将初步探究 <code>CPython</code>（<code>Python</code> 中最流行的实现）的一些内部机制，为了更好的来理解 <code>Python</code> 语言的底层运作。</p>
<h1 id="1-cpython-简介">1. CPython 简介</h1>
<p><code>CPython</code> 是用** C 语言**编写的 <code>Python</code> 解释器，在众多 <code>Python</code> 实现（如 <code>PyPy</code>、<code>Jython</code>、<code>IronPython</code> 等）中，它以其原创性、良好的维护性和高人气脱颖而出。</p>
<p>了解 <code>CPython</code> 的一些内部机制，对我们学习和使用<code>Python</code>语言本身也有很大的帮助：</p>
<ol>
<li>有助于深入理解 <code>Python</code> 语言：了解实现细节能让我们更轻松地掌握 <code>Python</code> 的一些特性</li>
<li>实现细节在实际应用中至关重要：对象存储方式、垃圾回收机制以及多线程协调等方面的知识，对于理解语言的适用性、局限性、性能评估和效率检测都非常关键</li>
<li><code>CPython</code> 提供的 <code>Python/C</code> API 允许我们<strong>用 C 扩展 Python</strong> 或在 <strong>C 中嵌入 Python</strong>，而有效使用该 API 需要对 <code>CPython</code> 的工作原理有深入理解</li>
</ol>
<p><code>CPython</code>是开源的，源码在<code>github.com</code>上：<a href="https://github.com/python/cpython" target="_blank" rel="noopener nofollow">https://github.com/python/cpython</a></p>
<p>每个版本的<code>Python</code>都有相应的<code>CPython</code>实现，我目前使用的<code>Python3.12</code>，</p>
<p>所以本文后续如果有参考的代码，参考的是<code>CPython</code> <strong>3.12分支</strong>中的代码。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250123171901232-553239821.png" alt="" loading="lazy"></p>
<h1 id="2-python执行的流程">2. Python执行的流程</h1>
<p>宏观上来来看，一个<code>Python</code>程序的执行大致分为三个阶段：</p>
<p>第一个阶段是<strong>初始化阶段</strong>，<code>CPython</code> 在此阶段初始化运行 <code>Python</code> 所需的数据结构，包括内置类型、配置和加载内置模块、设置导入系统等。</p>
<p>这个阶段虽然重要，但常常被忽视，因为它主要为程序的运行做一些准备工作。</p>
<p>第二个阶段是<strong>编译阶段</strong>，<code>CPython</code>是解释器，虽不生成机器码，但会将源代码转换为中间表示形式。</p>
<p>它会解析源代码构建抽象语法树（<code>AST</code>），从 AST 生成字节码，并进行一些字节码优化。</p>
<p>这个阶段虽然名称是<strong>编译</strong>，但是和<code>C/C++</code>这类编译型语言的<strong>编译</strong>不是一个含义。</p>
<p><code>Python</code>代码经过编译之后的字节码是可以查看的，比如下面简单写一个加法函数。</p>
<pre><code class="language-python">def add(x, y):
    return x + y
</code></pre>
<p>命令行中使用：<code>python.exe -m dis .\cpython-vm.py</code>查看字节码。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250123171901013-600496936.png" alt="" loading="lazy"></p>
<p><code>LOAD_FAST</code> 指令将局部变量压入栈中，</p>
<p><code>BINARY_ADD</code> 指令从栈中弹出两个对象，将它们相加，并将结果压回栈中。</p>
<p>最后，<code>RETURN_VALUE</code> 指令弹出栈顶的任何内容，并将结果返回给调用者。</p>
<p>最后一个阶段是<strong>解释阶段</strong>，<code>CPython</code> 的核心是一个执行字节码的虚拟机。字节码是一系列指令，每条指令由一个操作码和一个参数组成。</p>
<p><code>CPython</code> 虚拟机是基于栈的，通过栈来存储和检索数据，执行指令。字节码执行在一个巨大的求值循环中进行，直到没有指令可执行或发生错误。</p>
<h1 id="3-核心概念">3. 核心概念</h1>
<p>通过<code>CPython</code>虚拟机的内部机制来了解<code>Python</code>的底层原理，首先要关注的就是<code>CPython</code>虚拟机中的一些核心概念。包括：<strong>代码对象</strong>，<strong>函数对象</strong>，<strong>帧对象</strong>。</p>
<h2 id="31-代码对象">3.1. 代码对象</h2>
<p><strong>代码对象</strong>是 <code>CPython</code> 中存储代码块相关信息的结构，像模块、函数体这类作为独立执行单元的代码，其信息都保存在代码对象里。</p>
<p>它包含字节码（程序编译后的中间表示形式），以及代码块内使用的变量名列表等关键信息。</p>
<p>从本质上讲，代码对象是对一段可执行代码的抽象表示，为函数的调用、模块的运行提供了必要的指令和数据描述。</p>
<p>其相关定义在源码文件：<code>cpython/Include/cpython/code.h</code></p>
<pre><code class="language-c">#define _PyCode_DEF(SIZE) {                                                    \
    PyObject_VAR_HEAD                                                          \
    // 省略...                                                                 \
  
    /* The hottest fields (in the eval loop) are grouped here at the top. */   \
    PyObject *co_consts;           /* list (constants used) */                 \
    PyObject *co_names;            /* list of strings (names used) */          \
    PyObject *co_exceptiontable;   /* Byte string encoding exception handling  \
                                      table */                                 \
    int co_flags;                  /* CO_..., see below */                     \
                                                                               \
    /* The rest are not so impactful on performance. */                        \
    int co_argcount;              /* #arguments, except *args */               \
    int co_posonlyargcount;       /* #positional only arguments */             \
    int co_kwonlyargcount;        /* #keyword only arguments */                \
    int co_stacksize;             /* #entries needed for evaluation stack */   \
    int co_firstlineno;           /* first source line number */               \
                                                                               \
    /* redundant values (derived from co_localsplusnames and                   \
       co_localspluskinds) */                                                  \
    int co_nlocalsplus;           /* number of spaces for holding local, cell, \
                                     and free variables */                     \
    int co_framesize;             /* Size of frame in words */                 \
    int co_nlocals;               /* number of local variables */              \
    int co_ncellvars;             /* total number of cell variables */         \
    int co_nfreevars;             /* number of free variables */               \
    uint32_t co_version;          /* version number */                         \
                                                                               \
    PyObject *co_localsplusnames; /* tuple mapping offsets to names */         \
    PyObject *co_localspluskinds; /* Bytes mapping to local kinds (one byte    \
                                     per variable) */                          \
    PyObject *co_filename;        /* unicode (where it was loaded from) */     \
    PyObject *co_name;            /* unicode (name, for reference) */          \
    PyObject *co_qualname;        /* unicode (qualname, for reference) */      \
    PyObject *co_linetable;       /* bytes object that holds location info */  \
    PyObject *co_weakreflist;     /* to support weakrefs to code objects */    \
    // 省略...
}

/* Bytecode object */
struct PyCodeObject _PyCode_DEF(1);
</code></pre>
<p>定义比较长，这里只列出了一部分。</p>
<p>以上一节中示例中的函数<code>add(x, y)</code>函数为例，<code>CPython</code> 会为<code>add</code>函数体创建一个代码对象。</p>
<p>在这个代码对象中，字节码部分记录了如何加载变量<code>x</code>和<code>y</code>、执行<strong>加法操作</strong>并<strong>返回结果</strong>等指令序列。</p>
<p>同时，还包含<code>co_argcount</code>（参数数量，此处为 2）等属性，这些属性描述了函数的参数使用情况。</p>
<p>此外，代码对象还会记录函数定义所在的文件名（<code>co_filename</code> ）、起始行号（<code>co_firstlineno</code>）等信息，方便调试和代码分析。</p>
<h2 id="32-函数对象">3.2. 函数对象</h2>
<p><strong>函数对象</strong>不仅仅包含可执行代码（即代码对象），还存储了与函数相关的其他重要信息，如<strong>函数名</strong>、<strong>文档字符串</strong>（<code>docstring</code>）、<strong>默认参数</strong>、<strong>外部作用域</strong>变量值等。</p>
<p><strong>函数对象</strong>将代码对象与函数运行所需的上下文信息整合在一起，使得函数可以在不同的环境中被正确调用和执行。</p>
<p>多个<strong>函数对象</strong>可以引用同一个<strong>代码对象</strong>，通过不同的外部信息实现不同的功能，例如闭包的实现。</p>
<p>其相关定义在源码文件：<code>cpython/Include/cpython/funcobject.h</code></p>
<pre><code class="language-c">typedef struct {
    PyObject_HEAD
    _Py_COMMON_FIELDS(func_)
    PyObject *func_doc;         /* The __doc__ attribute, can be anything */
    PyObject *func_dict;        /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist; /* List of weak references */
    PyObject *func_module;      /* The __module__ attribute, can be anything */
    PyObject *func_annotations; /* Annotations, a dict or NULL */
    PyObject *func_annotate;    /* Callable to fill the annotations dictionary */
    PyObject *func_typeparams;  /* Tuple of active type variables or NULL */
    vectorcallfunc vectorcall;

    uint32_t func_version;

} PyFunctionObject;
</code></pre>
<h2 id="33-帧对象">3.3. 帧对象</h2>
<p><strong>帧对象</strong>在 <code>CPython</code> 中用于跟踪代码执行过程中的各种状态信息。</p>
<p>当虚拟机执行<strong>代码对象</strong>时，<strong>帧对象</strong>负责记录变量的值、维护值栈（用于指令执行时的数据存储和操作），还会记录代码执行的位置（如当前行号、上一条执行的指令位置等），以便在函数调用、返回以及异常处理等情况下，能够正确恢复和继续执行代码。</p>
<p>可以说，<strong>帧对象</strong>为<strong>代码对象</strong>的执行提供了一个动态的上下文环境，它随着代码的执行而创建和销毁，形成一个调用栈，反映了函数调用的层次结构。</p>
<p>其相关定义在源码文件：<code>cpython/Include/internal/pycore_frame.h</code></p>
<pre><code class="language-c">struct _frame {
    PyObject_HEAD
    PyFrameObject *f_back;      /* previous frame, or NULL */
    struct _PyInterpreterFrame *f_frame; /* points to the frame data */
    PyObject *f_trace;          /* Trace function */
    int f_lineno;               /* Current line number. Only valid if non-zero */
    char f_trace_lines;         /* Emit per-line trace events? */
    char f_trace_opcodes;       /* Emit per-opcode trace events? */
    PyObject *f_extra_locals;   /* Dict for locals set by users using f_locals, could be NULL */
    /* This is purely for backwards compatibility for PyEval_GetLocals.
       PyEval_GetLocals requires a borrowed reference so the actual reference
       is stored here */
    PyObject *f_locals_cache;
    /* The frame data, if this frame object owns the frame */
    PyObject *_f_frame_data[1];
};
</code></pre>
<p>当调用函数时，会创建一个新的<strong>帧对象</strong>并压入调用栈。</p>
<p>当函数执行结束返回时，该<strong>帧对象</strong>从调用栈中弹出，虚拟机根据<strong>帧对象</strong>中记录的<code>f_back</code>（指向前一个帧对象的引用）等信息，恢复到调用函数之前的状态，继续执行后续代码。</p>
<h1 id="4-总结">4. 总结</h1>
<p>本文主要对 <code>CPython</code> 执行 <code>Python</code> 程序的过程做一个初步的宏观介绍，了解了其主要的阶段和核心概念。</p>
<p>后续打算进一步就<code>CPython</code>某个部分的具体实现细节来介绍，逐步对<code>CPython</code>的内部机制进行深入的了解。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.3775980494293982" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 17:20">2025-01-23 17:19</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">259</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688238" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688238);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688238', targetLink: 'https://www.cnblogs.com/wang_yb/p/18688238', title: '『Python底层原理』--CPython 虚拟机' })">举报</a>
</div>
        