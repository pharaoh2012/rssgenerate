
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18738421" title="发布于 2025-02-26 14:30">
    <span role="heading" aria-level="2">面试官：你项目是如何实现读写分离的？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>读写分离（Read-Write Splitting）是一种常见的数据库架构优化策略，通过将数据库的读操作（查询）和写操作（插入、更新、删除）分离到不同的数据库实例上，从而<strong>提高系统的性能、可扩展性和高可用性</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1740542496470-7592514c-a3ac-4591-8285-0777b836f684.png" alt="" loading="lazy"></p>
<p>在项目中实现读写分离目前主流的实现技术是通过 Apache ShardingSphere 来实现数据库的读写分离的。</p>
<p>从 Apache ShardingSphere 官网也可以看出读写分离是其提供的主要功能之一：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1740542496557-aece3073-b052-49db-94c3-40a82df23843.png" alt="" loading="lazy"></p>
<blockquote>
<p>ShardingSphere 官网地址：<a href="https://shardingsphere.apache.org/document/current/cn/features/readwrite-splitting/" target="_blank" rel="noopener nofollow">https://shardingsphere.apache.org/document/current/cn/features/readwrite-splitting/</a></p>
</blockquote>
<p>通过 ShardingSphere 可以轻松实现 MySQL 数据库的读写分离，以下是基于最新 ShardingSphere 5.x 版本的实现步骤和关键代码：</p>
<h2 id="1核心实现原理">1.核心实现原理</h2>
<p>ShardingSphere 通过 <strong>JDBC 驱动层透明代理</strong>实现读写分离，其核心逻辑为：</p>
<ol>
<li><strong>SQL 路由</strong>：根据 SQL 类型（SELECT/WRITE）自动路由到主库或从库。</li>
<li><strong>负载均衡</strong>：支持轮询、随机权重等算法分配读请求到多个从库。</li>
<li><strong>主从同步</strong>：依赖 MySQL 原生主从复制机制保障数据一致性。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1740542496552-dbf53244-b6f0-4d1d-9145-edeeeced0bb5.png" alt="" loading="lazy"></p>
<h2 id="2具体实现步骤">2.具体实现步骤</h2>
<h3 id="步骤-1搭建mysql主从复制前置条件">步骤 1：搭建MySQL主从复制（前置条件）</h3>
<pre><code class="language-sql">-- 主库配置（my.cnf）
server-id=1
log-bin=mysql-bin
binlog-format=ROW

-- 从库配置（my.cnf）
server-id=2
relay-log=relay-bin
read-only=1

-- 主库创建复制账号
CREATE USER 'repl'@'%' IDENTIFIED BY 'P@ssw0rd';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 从库配置主库连接
CHANGE MASTER TO 
  MASTER_HOST='master_ip',
  MASTER_USER='repl',
  MASTER_PASSWORD='P@ssw0rd',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=592;
START SLAVE;
</code></pre>
<h3 id="步骤-2springboot项目集成shardingsphere-jdbc">步骤 2：SpringBoot项目集成ShardingSphere-JDBC</h3>
<p><strong>1.添加 <strong><strong>Maven</strong></strong> 依赖</strong></p>
<p>在 pom.xml 中添加 ShardingSphere 和数据库连接池的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
  &lt;artifactId&gt;shardingsphere-jdbc-core-spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2.配置 application.yml</strong></p>
<p>在 application.yml 中配置数据源和读写分离规则：</p>
<pre><code class="language-yaml">spring:
  shardingsphere:
    datasource:
      names: master,slave0
      # 主库配置
      master:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://master_ip:3306/db?useSSL=false
        username: root
        password: Master@123
      # 从库配置  
      slave0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://slave_ip:3306/db?useSSL=false
        username: root
        password: Slave@123
      # 从库2配置  
      slave1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://slave_ip:3306/db?useSSL=false
        username: root
        password: Slave@123
    rules:
      readwrite-splitting:
        data-sources:
          readwrite_ds:
            type: Static
            props:
              write-data-source-name: master
              read-data-source-names: 
                - slave0
                - slave1
            load-balancer-name: round_robin
        load-balancers:
          round_robin:
            type: ROUND_ROBIN # 轮询
    props:
      sql-show: true  # 显示实际路由的SQL
</code></pre>
<p><strong>配置说明</strong></p>
<ul>
<li><strong>数据源配置</strong>：
<ul>
<li>master：主库数据源，用于写操作。</li>
<li>slave0 和 slave1：从库数据源，用于读操作。</li>
</ul>
</li>
<li><strong>读写分离规则</strong>：
<ul>
<li>write-data-source-name：指定写操作的数据源。</li>
<li>read-data-source-names：指定读操作的数据源列表。</li>
<li>load-balancer-name：指定读操作的负载均衡算法。</li>
</ul>
</li>
<li><strong>负载均衡算法</strong>：
<ul>
<li>ROUND_ROBIN：轮询算法，读请求会在 slave0 和 slave1 之间轮询。</li>
<li>其他可选算法：RANDOM（随机）、WEIGHT（权重）等。</li>
</ul>
</li>
</ul>
<p><strong>3.验证读写分离</strong></p>
<p>1.写操作测试</p>
<pre><code class="language-java">public void createUser(User user) {
userMapper.insert(user); // INSERT 语句自动路由到master
}
</code></pre>
<p>2.读操作测试</p>
<pre><code class="language-java">public List&lt;User&gt; listUsers() {
    return userMapper.selectList(null); // SELECT 语句路由到slave0
}
</code></pre>
<p>3.查看执行日志</p>
<p>控制台会输出类似日志：</p>
<pre><code class="language-plain">Actual SQL: master ::: INSERT INTO user (...)
Actual SQL: slave0 ::: SELECT * FROM user
</code></pre>
<h2 id="3高级配置可选">3.高级配置（可选）</h2>
<ol>
<li><strong>强制主库读</strong>通过 Hint 强制路由到主库：</li>
</ol>
<pre><code class="language-java">HintManager.getInstance().setPrimaryRouteOnly();
</code></pre>
<ol start="2">
<li><strong>故障转移</strong>配置心跳检测实现从库故障自动剔除：</li>
</ol>
<pre><code class="language-yaml">spring:
  shardingsphere:
    rules:
      readwrite-splitting:
        data-sources:
          readwrite_ds:
            type: Dynamic
            props:
              auto-aware-data-source-name: readwrite_ds
              health-check-enabled: true
              health-check-max-retry-count: 3
              health-check-retry-interval: 5000
</code></pre>
<h3 id="注意事项">注意事项</h3>
<p><strong>主从延迟问题</strong>：异步复制场景下，刚写入的数据可能无法立即从从库读取，可通过 HintManager 强制读主库临时解决。</p>
<h2 id="4优缺点分析">4.优缺点分析</h2>
<ol>
<li><strong>优点分析</strong>：
<ol>
<li><strong>提升性能</strong>：写操作通常对性能要求较高，而读操作可以通过从库分担压力，避免主库因高并发查询而过载。从库可以进行水平扩展（增加更多从库实例），进一步提升系统的读取能力。</li>
<li><strong>提高可用性</strong>：主库和从库可以部署在不同的服务器或机房，增加系统的容错性。即使某个从库出现故障，其他从库仍然可以继续提供读服务。</li>
<li><strong>优化资源利用</strong>：主库可以专注于处理写操作，从库可以优化查询性能（如添加更多的索引、缓存等）。</li>
</ol>
</li>
<li><strong>缺点分析</strong>：
<ol>
<li><strong>数据一致性延迟</strong>：由于从库的数据是通过主库同步而来，可能存在一定的延迟（秒级或更长），导致读操作可能读取到旧数据。</li>
<li><strong>复杂性增加</strong>：需要管理主从复制的配置和同步机制。需要处理主从切换、故障转移等复杂情况。</li>
<li><strong>成本增加</strong>：需要额外的硬件资源来部署从库。需要额外的运维成本来维护主从架构。</li>
</ol>
</li>
</ol>
<h2 id="5应用场景">5.应用场景</h2>
<p>读写分离适用于以下场景：</p>
<ul>
<li><strong>读操作远多于写操作系统</strong>：如电商系统、社交平台等，读操作远多于写操作。</li>
<li><strong>需要高可用性</strong>：通过主从架构提高系统的容错能力。</li>
</ul>
<h2 id="小结">小结</h2>
<p>读写分离是一种常见的数据库架构优化策略，通过将数据库的读操作和写操作分离，提高了系统的性能、可扩展性和高可用性。读写分离主流的实现技术是 Apache ShardingSphere，通过添加依赖，配置读写分离规则的方式就可以轻松的实现读写分离。</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：场景题、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列等模块。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07627846651620371" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 14:31">2025-02-26 14:30</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">156</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18738421" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18738421);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18738421', targetLink: 'https://www.cnblogs.com/vipstone/p/18738421', title: '面试官：你项目是如何实现读写分离的？' })">举报</a>
</div>
        