
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/19001726" title="发布于 2025-07-23 22:34">
    <span role="heading" aria-level="2">Golang基础笔记十四之文件操作</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/TRRPLG7siNvIGS5EPexlUA" target="_blank" rel="noopener nofollow">Golang基础笔记十四之文件操作</a></p>
</blockquote>
<p>这一篇笔记介绍 Golang 里文件的相关操作，主要用的库是 <code>io</code>。</p>
<p>以下是本篇笔记目录：</p>
<ol>
<li>文件读取</li>
<li>文件写入</li>
<li>文件追加</li>
<li>os.OpenFile()</li>
<li>文件属性</li>
</ol>
<h3 id="1文件读取">1、文件读取</h3>
<h4 id="1-文件的打开与关闭">1. 文件的打开与关闭</h4>
<h5 id="1-osopen">1) os.Open()</h5>
<p>打开一个文件可以使用 <code>os.Open()</code> 函数，其代码示例如下:</p>
<pre><code class="language-go">filePath := "a.txt"
file, err := os.Open(filePath)
</code></pre>
<p>我们可以通过判断 err 是否等于 nil 来决定是否可以接着读取文件，假设这里的 filePath 不存在，那么 err 则的信息则会是:</p>
<pre><code class="language-go">open file fail, err: open a.txt: The system cannot find the file specified.
</code></pre>
<p><code>file</code> 的具体读取操作在后面再介绍。</p>
<h5 id="2-fileclose">2) file.Close()</h5>
<p>在打开文件后，我们可以使用 <code>defer file.Close()</code> 操作来确保文件最后会被正常关闭。</p>
<h4 id="2-文件内容的读取">2. 文件内容的读取</h4>
<p>在文件打开以后，介绍几种对文件进行读取的方式，以下是打开文件的代码：</p>
<pre><code class="language-go">filePath := "a.txt"
file, err := os.Open(filePath)
if err != nil {
    fmt.Println("open file fail, err:", err)
    return
}
defer file.Close()
</code></pre>
<p>假设 <code>a.txt</code> 文件内容为：</p>
<pre><code class="language-go">第一行
second_line
end of line
</code></pre>
<h5 id="1-一次性读取">1) 一次性读取</h5>
<p>如果目标文件不大，希望一次性读取文件内容的话，可以使用 <code>io.ReadAll()</code> 函数：</p>
<pre><code class="language-go">data, err := io.ReadAll(file)
if err != nil {
    fmt.Println("read file error: ", err)
    return
}
fmt.Println("read file data: ", string(data))
return
</code></pre>
<p>返回的结果是一个 []byte 类型，可以使用 <code>string()</code> 将其转换为字符串。</p>
<h5 id="2-分块读取">2) 分块读取</h5>
<p>如果文件过大，我们可以分块读取，每次读取指定字节数的数据，下面提供一个示例，用于分批次读取文件内容，直到读完整个文件：</p>
<pre><code class="language-go">data := make([]byte, 6)
for {
    count, err := file.Read(data)
    if err == io.EOF {
        fmt.Println("end of file, exit")
        break
    }
    if err != nil {
        fmt.Println("Error: ", err)
        break
    }
    if count &gt; 0 {
        fmt.Println("read count: ", count, ", data: ", string(data[:count]))
    }
}
</code></pre>
<p>这里我们定义了一个长度为 6 的 byte 数组，然后在 for 循环里一直使用 <code>file.Read()</code> 读取，每次都往 <code>data</code> 中填充数据，直到读取到文件末尾，或者读取出现 error。</p>
<p>在这里需要注意，Go 里对读取文件到末尾的信息包装成了一个 error，我们需要进行判断下。</p>
<p><strong>file.Seek()</strong></p>
<p>在读取文件内容的时候，我们还可以指定指针读取的位置，比如重置读取的指针到开头，我们可以如下操作：</p>
<pre><code class="language-go">file.Seek(0, io.SeekStart)
</code></pre>
<p><code>file.Seek()</code> 函数接收两个参数，一个是偏移量，一个是起始位置，上面这行代码的含义就是从文件开头的偏移量为 0 的位置开始读取文件内容。</p>
<p>如果我们想从文件开头往后三个字节长度的地方开始读取，可以如下操作：</p>
<pre><code class="language-go">file.Seek(3, io.SeekStart)
</code></pre>
<p>而指定读取有三个参数：</p>
<pre><code class="language-go">const (
    SeekStart   = 0 // seek relative to the origin of the file
    SeekCurrent = 1 // seek relative to the current offset
    SeekEnd     = 2 // seek relative to the end
)
</code></pre>
<p>分别表示文件开头，指针当前位置和文件末尾。</p>
<p>当然，<code>file.Seek()</code> 的第一个参数也可以是负数，比如我们想读取文件最后六个字节的内容，可以如下操作：</p>
<pre><code class="language-go">file.Seek(-6, io.SeekEnd)
</code></pre>
<h5 id="3-按行读取">3) 按行读取</h5>
<p>我们可以使用 <code>bufio.NewScanner()</code> 函数来按行读取文件内容：</p>
<pre><code class="language-go">file.Seek(0, io.SeekStart)
scanner := bufio.NewScanner(file)

for scanner.Scan() {
    fmt.Println(scanner.Bytes(), scanner.Text())
}
</code></pre>
<p>这里，我们使用了两个内容，一个是 <code>.Bytes()</code>，一个是 <code>.Text()</code>，分别打印的内容是该行的字节数组和字符串数据。</p>
<h3 id="2文件写入">2、文件写入</h3>
<h4 id="1-文件的打开与关闭-1">1. 文件的打开与关闭</h4>
<p>文件写入的操作中，打开与关闭一个文件的操作如下：</p>
<pre><code class="language-go">filePath := "a.txt"
file, err := os.Create(filePath)
if err != nil {
    fmt.Println("create file error: ", err)
    return
}

defer file.Close()
</code></pre>
<p>使用到的函数是 <code>os.Create()</code>，在这里，如果目标文件 <code>filePath</code> 不存在则会自动创建一个文件，如果存在，则会清空原来的数据，重新写入。</p>
<h4 id="2-文件内容的写入">2. 文件内容的写入</h4>
<p>文件打开以后，下面介绍几种写入内容的方式</p>
<h5 id="1-filewrite">1) file.Write()</h5>
<p>可以直接使用 <code>file</code> 以字节数组的形式往文件写入数据：</p>
<pre><code class="language-go">    n, err := file.Write([]byte("first line\n"))
    if err != nil {
        fmt.Println("write error: ", err)
        return
    }
    fmt.Printf("write %d bytes", n)
</code></pre>
<p>这里需要注意，如果要换行需要在末尾手动加上 <code>\n</code> 字符。</p>
<h5 id="2-iowritestring">2) io.WriteString()</h5>
<p>我们也可以使用 <code>io.WriteString()</code>  函数往文件里写入数据：</p>
<pre><code class="language-go">    n, err := io.WriteString(file, "first line\n")
    if err != nil {
        fmt.Println("write error: ", err)
        return
    }
    fmt.Printf("write %d ", n)
</code></pre>
<h5 id="3-bufionewwriter">3) bufio.NewWriter()</h5>
<p>我们还可以使用 <code>bufio.NewWriter()</code> 函数写入，这种操作是以缓冲的形式写入，操作示例如下：</p>
<pre><code class="language-go">    writer := bufio.NewWriter(file)
    n, err := writer.WriteString("first line\n")
    if err != nil {
        fmt.Println("write error: ", err)
        return
    }
    writer.Flush()
    fmt.Printf("write %d bytes\n", n)
</code></pre>
<p>这种操作需要在最后使用 <code>writer.Flush()</code> 函数将数据从缓冲区写入文件。</p>
<h3 id="3文件追加">3、文件追加</h3>
<h4 id="1-文件的打开与关闭-2">1. 文件的打开与关闭</h4>
<p>如果要对文件内容进行追加，我们可以使用 <code>os.OpenFile()</code> 函数，以下是一个使用示例：</p>
<pre><code class="language-go">filePath := "a.txt"

file, err := os.OpenFile(filePath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
if err != nil {
    fmt.Println("append file error: ", err)
    return
}
defer file.Close()
</code></pre>
<p>在这里，<code>os.OpenFile()</code> 函数接受三个参数，第一个是文件地址，第二个是标志位，第三个是文件的权限。</p>
<p>对于标志位，这里的 os.O_APPEND、os.O_WRONLY、os.O_CREATE 分别表示追加，只写和创建，这样即便是文件不存在也不会报错，而是会创建一个新文件。</p>
<h4 id="2-文件内容的追加">2. 文件内容的追加</h4>
<p>追加操作可以使用 <code>file.Write()</code> 来写入字节数组，或者 <code>file.WriteString()</code> 写入字符串：</p>
<pre><code class="language-go">file.Write([]byte("hello write byte\n"))
file.WriteString("hello write string\n")
</code></pre>
<h3 id="4osopenfile">4、os.OpenFile()</h3>
<p>这里再单独介绍一下 <code>os.OpenFile()</code> 函数，这个函数在前面追问文件内容的时候已经使用过一次了，这里着重再讲一下。</p>
<p><code>os.OpenFile()</code> 函数是上面介绍的这些操作的基础函数，也就是说读取文件使用的 <code>os.Open()</code>，写入文件使用的 <code>os.Create()</code>，在底层的逻辑里都是调用的 <code>os.OpenFile()</code>，不过是在具体实现的时候，根据不同的目标，比如读取或者写入来传入不同的参数以实现具体功能。</p>
<p>先来介绍 <code>os.OpenFile()</code> 函数的参数。</p>
<h4 id="1-osopenfile-参数">1. os.OpenFile() 参数</h4>
<p>这个函数接收三个参数，name，flag 和 perm。</p>
<h5 id="1-name">1) name</h5>
<p>name 就是文件名称，string 类型，表示我们需要操作的目标文件。</p>
<h5 id="2-flag">2) flag</h5>
<p>flag 表示的是操作的目的，比如前面介绍追加文件的时候用到的 <code>os.O_APPEND|os.O_WRONLY|os.O_CREATE</code>。</p>
<p>参数类型是 int，在源码里定义了一系列关于文件的操作，如下：</p>
<pre><code class="language-go">const (
    // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
    O_RDONLY int = syscall.O_RDONLY // open the file read-only.
    O_WRONLY int = syscall.O_WRONLY // open the file write-only.
    O_RDWR   int = syscall.O_RDWR   // open the file read-write.
    // The remaining values may be or'ed in to control behavior.
    O_APPEND int = syscall.O_APPEND // append data to the file when writing.
    O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
    O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
    O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
    O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.
)
</code></pre>
<p>比如这里有 O_RDONLY 表示只读，O_WRONLY 表示只写，O_RDWR 表示读和写，在操作文件的时候，这几个参数之一是必传的，用来表示文件操作的目的是读或者写。</p>
<p>下面几个参数则需要和其他上面的几个参数之一合并使用，比如 O_APPEND 追加，O_CREATE 创建等。</p>
<p>上面我们介绍追加功能的时候，就是一个示例，内容是 <code>os.O_APPEND|os.O_WRONLY|os.O_CREATE</code>，这个操作首先通过必传的 <code>os.O_WRONLY</code> 表示是一个写操作，然后通过 <code>os.O_APPEND</code> 表示是追加操作，会在文件的末尾接着写入，而 <code>os.O_CREATE</code> 则表示如果目标文件不存在则创建一个新文件。</p>
<p>通过这种操作叠加的方式使我们追加文件的程序变得更健壮，不会因为文件不存在而报错。</p>
<h5 id="3-perm">3) perm</h5>
<p>perm 表示权限，指的是我们操作文件的时候，对文件赋予的权限，和 Linux 上文件操作的权限是一致的，比如 <code>0644</code> 代表的含义是当前用户拥有可读可写，同用户组和其他用户组只拥有可读权限。</p>
<h4 id="2-osopen-和-oscreate">2. os.Open() 和 os.Create()</h4>
<p>前面介绍了 os.Open() 和 os.Create() 分别用来读取和写入文件的操作示例，这两个函数背后也是通过调用 os.OpenFile() 来实现的。</p>
<h5 id="1-osopen-1">1) os.Open()</h5>
<p>os.Open() 函数在源代码中的定义如下：</p>
<pre><code class="language-go">func Open(name string) (*File, error) {
    return OpenFile(name, O_RDONLY, 0)
}
</code></pre>
<p>可以看到通过 OpenFile() 给了一个只读的权限实现了读取文件内容的操作。</p>
<h5 id="2-oscreate">2) os.Create()</h5>
<p>os.Create() 函数的源码如下：</p>
<pre><code class="language-go">func Create(name string) (*File, error) {
    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
</code></pre>
<p>os.Create() 函数则是通过读写操作，不存在就创建文件操作，存在就对原文件进行截断操作的方式来实现写入。</p>
<h4 id="3-osreadfile-和-oswritefile">3. os.ReadFile() 和 os.WriteFile()</h4>
<p>除了上面介绍的读写操作，这里还介绍两个以 <code>os.OpenFile()</code> 函数为基础实现的读写操作，不过这两个函数的读和写都是一次性的，也就是会一次性读取文件全部内容，或者一次性写入全部内容。</p>
<h5 id="1-osreadfile">1) os.ReadFile()</h5>
<p>os.ReadFile() 函数操作示例如下：</p>
<pre><code class="language-go">    filePath := "a.txt"
    data, err := os.ReadFile(filePath)
    fmt.Println("data: ", string(data), ", err: ", err)
</code></pre>
<p>返回的是一个字节数组，如果想要按行进行切割，可以使用 <code>strings.Split(string(data), "\n")</code> 操作。</p>
<h5 id="2-oswritefile">2) os.WriteFile()</h5>
<p>os.WriteFile() 操作示例如下：</p>
<pre><code class="language-go">    err = os.WriteFile(filePath, []byte("hello write byte\nok write done\nlast line write\n"), 0644)
    fmt.Println("write error: ", err)
</code></pre>
<p>这里将多行数据使用 <code>\n</code> 进行分隔。</p>
<h3 id="5文件属性">5、文件属性</h3>
<p>打开一个文件后，我们可以获取这个文件的相关属性。</p>
<p>可以如下操作：</p>
<pre><code class="language-go">filePath := "a.txt"
file, _ := os.Open(filePath)

info, err := file.Stat()
if err != nil {
    fmt.Println("error: ", err)
}
defer file.Close()
</code></pre>
<p>我们通过 file.Stat() 获取 FileInfo，文件的信息就都在 info 里了：</p>
<pre><code class="language-go">fmt.Println("文件名称: ", info.Name())
fmt.Printf("文件大小为 %d bytes\n", info.Size())
fmt.Printf("文件权限:%s, %o \n", info.Mode(), info.Mode())
fmt.Println("文件上次修改时间为:", info.ModTime())
</code></pre>
<p>这里文件权限打印出的字符串是 <code>-rw-rw-rw-</code>，然后我们打印其八进制的内容就是常见的 <code>666</code> 形式了。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-23 22:35">2025-07-23 22:34</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">73</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19001726);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19001726', targetLink: 'https://www.cnblogs.com/hunterxiong/p/19001726', title: 'Golang基础笔记十四之文件操作' })">举报</a>
</div>
        