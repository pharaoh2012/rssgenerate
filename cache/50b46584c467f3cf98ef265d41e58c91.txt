
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/JulianHuang/p/18775382" title="发布于 2025-03-16 18:29">
    <span role="heading" aria-level="2">老八股谈事务处理，到底在谈什么？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>hello， 我是马甲哥， 这是我的第184篇原创技术文章， 也是<a href="https://time.geekbang.org/column/article/319481" title="周志明的软件架构课" target="_blank" rel="noopener nofollow">周志明的软件架构课</a>的读书笔记。</p>
<h2 id="1-事务处理的目标数据状态的一致性">1. 事务处理的目标：数据状态的一致性</h2>
<p>当我们谈事务处理，就是在谈<strong>确保数据状态的一致性Consistency</strong>。</p>
<p>一致性： 确保数据是正确的，不同数据间不会产生矛盾 （这里的一致性与分布式共识算法中的一致性概念不一样）。</p>
<p>事务最早源自数据库系统，为达成数据库状态的一致性C Consistency，<br>
需做三个方面的努力：</p>
<ul>
<li>原子性 Atomic</li>
<li>隔离性 Isolation</li>
<li>持久性 Durability</li>
</ul>
<p>故可以看到ACID并非正交，AID是手段，目的是C， 拼凑的4字单词带来的误解已经超过容易传播的好处。</p>
<blockquote>
<p>事务的场景：虽最早起源自数据库，但今天所有需要确保数据正确性的系统(包括不限于 数据库、缓存、队列、对象存储)都会涉及事务处理。</p>
</blockquote>
<h2 id="2-传统的本地数据库事务">2. 传统的本地数据库事务</h2>
<p>本地事务是最基础的事务，不涉及使用全局事务协调器的事务。</p>
<p>事务相关的动作： 开始、结束、提交、回滚、设置隔离级别有赖于底层数据库支持，与XA、TCC、SAGA依靠应用程序代码实现不同。</p>
<h3 id="原子性和持久性">原子性和持久性</h3>
<p>遇到的问题：<br>
“写入磁盘” 并不是原子的，有“正在写”的中间态。</p>
<p><img src="https://files.mdnice.com/user/4236/ee56ee42-2f6a-43a1-bc7e-002682215351.png" alt="" loading="lazy"></p>
<p><strong>业务上的操作组合与数据库的落盘行为在不同的时空维度，因数据库崩溃恢复的时机，导致数据库难以做到业务逻辑自洽的数据一致性</strong>。</p>
<h4 id="21-commit-logging强调事务提交要顺序写日志">2.1 Commit Logging强调事务提交要顺序写日志</h4>
<ol>
<li>将修改数据的全部信息（哪个页、磁盘、从什么修改成什么）记录到磁盘日志（顺序写）</li>
<li>见到事务成功提交的“commit record”，数据库才会根据日志信息持久化落盘</li>
<li>修改完成之后，在日志中加入一条“end record”，表示事务已经完成持久化。</li>
</ol>
<p>事务日志的生成就是事务提交的关键点，代表性的有阿里的Oceanbase， 但是有一个巨大的问题，所有对数据的真实修改都必须发生了事务提交之后， 这对提升数据库性能不利。</p>
<h4 id="22-write-ahead-logging强调持久化落盘可在事务提交之前">2.2 Write Ahead Logging强调持久化落盘可在事务提交之前</h4>
<p>undolog 出现了。</p>
<p>当变动数据写入磁盘前，写明修改了哪个数据，从什么改成什么。<br>
以便在数据回滚或崩溃恢复时，可以根据undolog 日志对提前写入的数据进行擦除。</p>
<ol>
<li>分析阶段： 从事务日志中找出“不包含end record”的日志， 作为待恢复的事务集合</li>
<li>重做阶段： 从以上待恢复事务集合中，找出“含有commit record”的事务日志，这一部分已经写完事务日志，可以重做</li>
<li>回滚阶段： 以上剩下的事务日志，不包含commit record，说明事务日志还没有写完，这部分需要回滚，根据事务日志id到undolog中找到逻辑日志开始回滚。</li>
</ol>
<p>redolog： 物理日志</p>
<p>undolog： 逻辑日志</p>
<h3 id="隔离性">隔离性</h3>
<p>保证每个事务各自读写的数据相对独立，不会彼此影响。</p>
<p>读操作（select）：<br>
默认有共享锁（S锁）， 除非显式 <code>for  update</code>， 允许多个事务施加读锁，但持有后不允许施加写锁。</p>
<p>写操作（update delete add）：<br>
有排它锁（X锁），持有后不允许其他事务施加读写锁</p>
<p>范围锁： 某种查询条件内的范围数据被加排他锁。</p>
<p>这里要理解两个时机： 施加锁、实际操作</p>
<hr>
<p>持有锁的释放时机 决定了隔离级别。</p>
<ol>
<li>串行读： 加读写锁，范围锁，无并发能力----</li>
<li>可重复读： 加读写锁且持有至事务结束，不加范围锁---有幻读问题，两次相同的范围查询的数据集不一样</li>
<li>读已提交： 加读写锁，但读锁在查询之后即释放，不加范围锁--- 不可重复读问题，两次读取某数据可能不一样</li>
<li>读未提交：加写锁，完全不加读锁--- 幻读问题，读到了另一个事务未提交的数据。</li>
</ol>
<p>这里我的误区：</p>
<p><img src="https://files.mdnice.com/user/4236/6195daee-c349-4012-8640-b02c5be5ae0e.png" alt="" loading="lazy"></p>
<p>上图这个<strong>读已提交</strong>的例子，两次读的事务1并没有写锁，并不会阻止其他事务2写入。</p>
<p>事务的隔离级别： 定义了各种锁在不同加锁时间上的组合应用的结果。</p>
<p>事务的隔离效果： 事务的隔离级别+  具体的操作语句（决定涉及的数据会用上哪些锁）</p>
<h3 id="mvcc">MVCC</h3>
<p>针对“一个事务读，另一个事务写”， 有多版本并发控制（multi- verison-concurrency-control）。</p>
<blockquote>
<p>无锁优化方案：<br>
对数据的任何修改，都不会直接覆盖之前的数据，而是产生新版本与老版本共存。</p>
</blockquote>
<p>mysql的实现：<br>
每行记录有事务id、回滚指针两个隐藏字段，<br>
每次修改形成的旧版本（依赖undolog）也有这隐藏字段，通过回滚指针串起来。</p>
<p>每个事务开启时创建自己的ReadView视图。<br>
<img src="https://files.mdnice.com/user/4236/0373ae9c-ae6a-4e31-9a31-f1574bac3049.png" alt="" loading="lazy"></p>
<p>可重复度、读已提交依赖于MVCC来实现。</p>
<p>可重复读： 读取事务id小于等于当前事务id的最大版本的数据；</p>
<p>读已提交： 读取最新版本的数据</p>
<hr>
<p>That's All， 这是我对《周志明的软件架构课》中有关本地事务的读书笔记，记录了</p>
<ol>
<li>事务的本质，AID确保数据状态一致性C</li>
<li>传统数据库本地事务的演进： Commit Logging、Write Ahead Logging</li>
<li>数据库事务隔离级别的本质： 不同锁在不同作用时长的组合结果。</li>
<li>针对”一个事务读，一个事务写“的隔离级别，有MVCC来实现。</li>
</ol>
<p>《周志明的架构课》在极客时间上是免费阅读，读完思考后对很多八股文都有醍醐灌顶的感觉，强烈推荐。</p>
<h2 id="3-全文脑图">3. 全文脑图</h2>
<p><img src="https://files.mdnice.com/user/4236/686bbf18-59cc-4a75-9ba1-15fa32d80dc7.jpg" alt="" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    <hr style="FILTER: alpha(opacity=100,finishopacity=0,style=3)" width="80%" color="#987cb9" size="3">
<div style="text-align:center;">
<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href="https://www.cnblogs.com/JulianHuang/p/18775382" target="_blank">https://www.cnblogs.com/JulianHuang/p/18775382</a></p>
<strong style="color: red; ">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>
<div><img style="width: 250px;height:250px;" src="https://blog-static.cnblogs.com/files/JulianHuang/QR.gif"> </div>

</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4019384467662037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-16 18:37">2025-03-16 18:29</span>&nbsp;
<a href="https://www.cnblogs.com/JulianHuang">码甲哥不卷</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18775382" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18775382);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18775382', targetLink: 'https://www.cnblogs.com/JulianHuang/p/18775382', title: '老八股谈事务处理，到底在谈什么？' })">举报</a>
</div>
        