
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/FreeSql/p/18846755" title="发布于 2025-04-25 15:06">
    <span role="heading" aria-level="2">三维装箱问题（3D Bin Packing Problem, 3D-BPP）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="提出问题">提出问题</h1>
<p>集装箱海运家具, 沙发, 茶几, 椅子等等, 有多少套家具，以及每个家具的长宽高都会告诉你.<br>
把所有的家具都装进集装箱里, 要求通过算法算出一共需要多少集装箱.</p>
<ul>
<li>1.要考虑怎样装, 需要的集装箱才最少, 因为一个集装箱很贵的.</li>
<li>2.要考虑怎样摆放, 占用的体积最小, 找最优解. 比如, 茶几和沙发摞在一起, 旁边还有空余的位置, 那是否还可以再塞个椅子进去。</li>
</ul>
<p>你会怎样设计算法？</p>
<h1 id="分解问题">分解问题</h1>
<p>这是一个典型的三维装箱问题（3D Bin Packing Problem, 3D-BPP），它是NP-hard问题，意味着没有已知的算法能在多项式时间内找到绝对最优解。因此，我们通常使用启发式算法（Heuristics）或近似算法来寻找一个足够好的解，即尽量少用集装箱。</p>
<p>以下是一个使用C#设计启发式算法的思路和代码框架：</p>
<p><strong>核心思路:</strong></p>
<ol>
<li><strong>容器选择:</strong> 通常海运有标准集装箱尺寸，如20GP, 40GP, 40HC。我们需要确定使用哪种尺寸的集装箱，或者允许算法选择混合使用（这会更复杂）。为简化，我们先假设使用同一种标准尺寸的集装箱，例如40HC（内尺寸约为：长12.03m, 宽2.35m, 高2.69m）。<strong>注意：单位要统一！</strong> 比如都用毫米（mm）或厘米（cm）。</li>
<li><strong>物品表示:</strong> 每个家具是一个三维长方体，有长、宽、高。</li>
<li><strong>旋转:</strong> 家具可以旋转摆放以更好地利用空间。一个长方体有最多6种基本朝向（不考虑绕垂直轴的90度旋转，因为那可以通过交换长宽实现）。</li>
<li><strong>放置策略:</strong> 这是算法的关键。需要决定：
<ul>
<li><strong>物品顺序:</strong> 先放大件还是小件？通常先放大件（如按体积或最长边排序）效果较好（First Fit Decreasing - FFD 变种）。</li>
<li><strong>放置位置:</strong> 在容器的哪个位置放置物品？常用的策略是在可选空间中寻找“最合适”的位置，例如“最低-最左-最靠里”的角落。</li>
<li><strong>空间管理:</strong> 如何记录和管理容器内的剩余空间？这可以很复杂。常见方法有：
<ul>
<li><strong>层叠法（Layer-based）：</strong> 一层一层地填充。</li>
<li><strong>最大空间法（Maximal Spaces）：</strong> 维护一个剩余空间块的列表。</li>
<li><strong>三维坐标/体素法:</strong> 将容器空间离散化（计算量可能很大）。</li>
<li><strong>简单坐标点法:</strong> 维护一组可以放置物品的“锚点”（通常是已放置物品的角点或容器的角点）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>算法流程 (启发式 - 基于 FFD 和锚点/最低位置策略):</strong>
<ul>
<li><strong>初始化:</strong>
<ul>
<li>获取所有家具列表及其尺寸。</li>
<li>定义集装箱内部尺寸。</li>
<li>对家具列表进行排序（例如，按体积降序）。</li>
<li>创建一个空的集装箱列表。</li>
</ul>
</li>
<li><strong>主循环:</strong> 遍历排序后的家具列表：
<ul>
<li>对于当前家具 <code>item</code>:
<ul>
<li><strong>尝试放入现有集装箱:</strong> 遍历当前已打开的集装箱列表 <code>containers</code>。
<ul>
<li>对于每个集装箱 <code>container</code>:
<ul>
<li>尝试找到一个有效位置放置 <code>item</code>（考虑所有6种旋转）。</li>
<li><strong>寻找位置 (启发式):</strong>
<ul>
<li>维护一个该容器内可放置物品的“锚点”列表 <code>anchorPoints</code>（初始为 (0,0,0)）。</li>
<li>按一定顺序（如 Z坐标升序, Y升序, X升序）遍历 <code>anchorPoints</code>。</li>
<li>对每个锚点 <code>p</code>，尝试 <code>item</code> 的所有6种旋转 <code>r</code>。</li>
<li>检查 <code>item</code> 以旋转 <code>r</code> 放置在 <code>p</code> 时：
<ul>
<li>是否完全在集装箱边界内？</li>
<li>是否与该集装箱内已放置的任何其他物品 <code>placedItem</code> 发生碰撞？</li>
</ul>
</li>
<li>如果找到第一个有效的位置 <code>(p, r)</code>：
<ul>
<li>将 <code>item</code> 放置在 <code>container</code> 的 <code>p</code> 点，使用旋转 <code>r</code>。记录其位置和尺寸。</li>
<li>更新 <code>container</code> 的 <code>anchorPoints</code>：移除 <code>p</code>，并根据新放置的 <code>item</code> 添加新的潜在锚点（例如，新物品的右上角、前上角、右前角等）。需要仔细处理，避免重复和无效点。</li>
<li>标记 <code>item</code> 已放置，跳出当前集装箱的尝试，处理下一个家具。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果现有集装箱都放不下:</strong>
<ul>
<li>创建一个新的集装箱 <code>newContainer</code>。</li>
<li>将 <code>item</code> 放入 <code>newContainer</code>（通常放在 (0,0,0) 位置，选择一个合适的旋转）。<strong>必须检查:</strong> 如果物品本身就比集装箱大，则无法放置，需要报错。</li>
<li>记录放置信息，初始化 <code>newContainer</code> 的锚点列表。</li>
<li>将 <code>newContainer</code> 添加到 <code>containers</code> 列表中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>结束:</strong> 所有家具处理完毕后，<code>containers</code> 列表的大小就是所需的集装箱数量。</li>
</ul>
</li>
</ol>
<p><strong>C# 代码框架:</strong></p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;

// 3D Point/Vector Structure
public struct Point3D
{
    public decimal X, Y, Z;
    public Point3D(decimal x, decimal y, decimal z) { X = x; Y = y; Z = z; }
    public override string ToString() =&gt; $"({X}, {Y}, {Z})";
}

// Dimensions Structure
public struct Dimensions
{
    public decimal Length, Width, Height; // L, W, H correspond to X, Y, Z axes when placed
    public decimal Volume =&gt; Length * Width * Height;
    public Dimensions(decimal l, decimal w, decimal h) { Length = l; Width = w; Height = h; }
    public override string ToString() =&gt; $"[{Length}x{Width}x{Height}]";

    // Get dimensions for different rotations
    public Dimensions GetRotation(int rotationType)
    {
        switch (rotationType)
        {
            case 0: return new Dimensions(Length, Width, Height); // LWH (XYZ)
            case 1: return new Dimensions(Length, Height, Width); // LHW (XZY)
            case 2: return new Dimensions(Width, Length, Height); // WLH (YXZ)
            case 3: return new Dimensions(Width, Height, Length); // WHL (YZX)
            case 4: return new Dimensions(Height, Length, Width); // HLW (ZXY)
            case 5: return new Dimensions(Height, Width, Length); // HWL (ZYX)
            default: throw new ArgumentOutOfRangeException(nameof(rotationType));
        }
    }
}

// Represents a furniture item
public class Item
{
    public string Name { get; }
    public Dimensions OriginalDimensions { get; }
    public decimal Volume =&gt; OriginalDimensions.Volume;
    // Potentially add weight, fragility, stacking constraints later

    public Item(string name, decimal length, decimal width, decimal height)
    {
        Name = name;
        // Ensure non-negative dimensions
        OriginalDimensions = new Dimensions(
            Math.Max(0, length),
            Math.Max(0, width),
            Math.Max(0, height)
        );
    }

    public override string ToString() =&gt; $"{Name} {OriginalDimensions}";
}

// Represents an item placed inside a container
public class PlacedItem
{
    public Item SourceItem { get; }
    public Point3D Position { get; } // Bottom-Back-Left corner of the item in container coordinates
    public Dimensions PlacedDimensions { get; } // Dimensions after rotation

    // Bounding Box for collision detection
    public Point3D MinCorner =&gt; Position;
    public Point3D MaxCorner =&gt; new Point3D(Position.X + PlacedDimensions.Length, Position.Y + PlacedDimensions.Width, Position.Z + PlacedDimensions.Height);

    public PlacedItem(Item sourceItem, Point3D position, Dimensions placedDimensions)
    {
        SourceItem = sourceItem;
        Position = position;
        PlacedDimensions = placedDimensions;
    }

    // AABB Collision Check
    public bool Intersects(PlacedItem other)
    {
        return (this.MinCorner.X &lt; other.MaxCorner.X &amp;&amp; this.MaxCorner.X &gt; other.MinCorner.X) &amp;&amp;
               (this.MinCorner.Y &lt; other.MaxCorner.Y &amp;&amp; this.MaxCorner.Y &gt; other.MinCorner.Y) &amp;&amp;
               (this.MinCorner.Z &lt; other.MaxCorner.Z &amp;&amp; this.MaxCorner.Z &gt; other.MinCorner.Z);
    }
     // Check if this item intersects with a potential placement
    public bool Intersects(Point3D potentialPos, Dimensions potentialDims)
    {
         Point3D potMin = potentialPos;
         Point3D potMax = new Point3D(potentialPos.X + potentialDims.Length, potentialPos.Y + potentialDims.Width, potentialPos.Z + potentialDims.Height);

        return (this.MinCorner.X &lt; potMax.X &amp;&amp; this.MaxCorner.X &gt; potMin.X) &amp;&amp;
               (this.MinCorner.Y &lt; potMax.Y &amp;&amp; this.MaxCorner.Y &gt; potMin.Y) &amp;&amp;
               (this.MinCorner.Z &lt; potMax.Z &amp;&amp; this.MaxCorner.Z &gt; potMin.Z);
    }
}

// Represents a single container
public class Container
{
    public int Id { get; }
    public Dimensions Dimensions { get; }
    public List&lt;PlacedItem&gt; PlacedItems { get; }
    public List&lt;Point3D&gt; AnchorPoints { get; private set; } // Potential placement corners

    // Keep track of occupied volume/space for heuristics? (Optional)

    public Container(int id, decimal length, decimal width, decimal height)
    {
        Id = id;
        Dimensions = new Dimensions(length, width, height);
        PlacedItems = new List&lt;PlacedItem&gt;();
        // Start with the main corner as the only anchor point
        AnchorPoints = new List&lt;Point3D&gt; { new Point3D(0, 0, 0) };
    }

     // Tries to find a position and rotation to place the item
    public bool TryPlaceItem(Item item, out PlacedItem placement)
    {
        placement = null;

        // Sort anchor points: typically Z, Y, X ascending to fill bottom-up, left-right, back-front
        var sortedAnchors = AnchorPoints.OrderBy(p =&gt; p.Z).ThenBy(p =&gt; p.Y).ThenBy(p =&gt; p.X).ToList();

        foreach (Point3D anchor in sortedAnchors)
        {
            for (int rotationType = 0; rotationType &lt; 6; rotationType++)
            {
                Dimensions rotatedDims = item.OriginalDimensions.GetRotation(rotationType);

                // Check if item fits within container boundaries at this anchor
                if (anchor.X + rotatedDims.Length &lt;= Dimensions.Length &amp;&amp;
                    anchor.Y + rotatedDims.Width &lt;= Dimensions.Width &amp;&amp;
                    anchor.Z + rotatedDims.Height &lt;= Dimensions.Height)
                {
                    // Check for collisions with already placed items
                    bool collision = false;
                    foreach (PlacedItem existingItem in PlacedItems)
                    {
                        // Simple AABB check
                         if (existingItem.Intersects(anchor, rotatedDims))
                        {
                            collision = true;
                            break;
                        }
                    }

                    if (!collision)
                    {
                        // Found a valid placement!
                        placement = new PlacedItem(item, anchor, rotatedDims);
                        return true; // Return the first valid placement found
                    }
                }
            }
        }
        return false; // Could not find a place for this item in this container
    }

    // Actually place the item and update anchors
    public void PlaceItem(PlacedItem placement)
    {
        PlacedItems.Add(placement);

        // Update anchor points - this is a crucial and potentially complex step
        // A simple strategy: remove the used anchor and add new potential anchors
        Point3D placedPos = placement.Position;
        Dimensions placedDims = placement.PlacedDimensions;

        // Remove the anchor point that was used for placement
        AnchorPoints.RemoveAll(p =&gt; p.X == placedPos.X &amp;&amp; p.Y == placedPos.Y &amp;&amp; p.Z == placedPos.Z);

        // Add new potential anchor points based on the corners of the placed item
        // Only add points that are within the container bounds
        // More sophisticated logic would check if these points are already covered or invalid
        Point3D[] potentialNewAnchors = {
            new Point3D(placedPos.X + placedDims.Length, placedPos.Y, placedPos.Z),
            new Point3D(placedPos.X, placedPos.Y + placedDims.Width, placedPos.Z),
            new Point3D(placedPos.X, placedPos.Y, placedPos.Z + placedDims.Height)
        };

        foreach (var newAnchor in potentialNewAnchors)
        {
            // Basic check: is it inside the container?
            if (newAnchor.X &lt; Dimensions.Length &amp;&amp; newAnchor.Y &lt; Dimensions.Width &amp;&amp; newAnchor.Z &lt; Dimensions.Height)
            {
                 // Basic check: does it overlap with the item just placed? (Shouldn't if corners are correct)
                 // More advanced: check if it's inside *any* existing item or outside container
                 // Avoid duplicates
                if (!AnchorPoints.Any(p =&gt; p.X == newAnchor.X &amp;&amp; p.Y == newAnchor.Y &amp;&amp; p.Z == newAnchor.Z))
                {
                     // Further check: Is this point supported? (Simple heuristic: is Z&gt;0 requires something below?)
                     // For simplicity now, just add if inside bounds and not duplicate.
                    AnchorPoints.Add(newAnchor);
                }
            }
        }

        // Optional: Refine anchor points - remove points that are now inside the newly placed item
         // AnchorPoints.RemoveAll(p =&gt; IsInside(p, placement)); // Need IsInside check

        // Optional: Sort anchors again if needed for the next TryPlaceItem call
         // AnchorPoints = AnchorPoints.OrderBy(p =&gt; p.Z).ThenBy(p =&gt; p.Y).ThenBy(p =&gt; p.X).ToList();
    }

     // Helper to check if a point is strictly inside a placed item's volume
    private bool IsInside(Point3D point, PlacedItem item)
    {
        return point.X &gt; item.MinCorner.X &amp;&amp; point.X &lt; item.MaxCorner.X &amp;&amp;
               point.Y &gt; item.MinCorner.Y &amp;&amp; point.Y &lt; item.MaxCorner.Y &amp;&amp;
               point.Z &gt; item.MinCorner.Z &amp;&amp; point.Z &lt; item.MaxCorner.Z;
    }
}


// The main packer class
public class Packer
{
    public Dimensions ContainerDimensions { get; }

    public Packer(decimal containerLength, decimal containerWidth, decimal containerHeight)
    {
        ContainerDimensions = new Dimensions(containerLength, containerWidth, containerHeight);
    }

    public List&lt;Container&gt; PackItems(List&lt;Item&gt; itemsToPack)
    {
        // 1. Sort items (e.g., by volume descending) - FFD heuristic
        var sortedItems = itemsToPack.OrderByDescending(item =&gt; item.Volume).ToList();

        List&lt;Container&gt; containers = new List&lt;Container&gt;();
        int containerIdCounter = 1;
        HashSet&lt;Item&gt; packedItems = new HashSet&lt;Item&gt;(); // Keep track of packed items

        foreach (var item in sortedItems)
        {
             if (packedItems.Contains(item)) continue; // Should not happen with list processing, but safe check

            bool placed = false;

            // 2. Try placing in existing containers
            foreach (var container in containers)
            {
                if (container.TryPlaceItem(item, out PlacedItem placement))
                {
                    container.PlaceItem(placement);
                    Console.WriteLine($"Placed {item.Name} in Container {container.Id} at {placement.Position} with rotation {placement.PlacedDimensions}");
                    placed = true;
                    packedItems.Add(item);
                    break; // Move to the next item (First Fit)
                }
            }

            // 3. If not placed, open a new container
            if (!placed)
            {
                // Check if the item can fit in an empty container at all (any rotation)
                bool fitsAnyhow = false;
                PlacedItem initialPlacement = null;
                for(int r=0; r&lt;6; ++r)
                {
                    var dims = item.OriginalDimensions.GetRotation(r);
                    if(dims.Length &lt;= ContainerDimensions.Length &amp;&amp;
                       dims.Width &lt;= ContainerDimensions.Width &amp;&amp;
                       dims.Height &lt;= ContainerDimensions.Height)
                       {
                            initialPlacement = new PlacedItem(item, new Point3D(0,0,0), dims);
                            fitsAnyhow = true;
                            break;
                       }
                }

                if (fitsAnyhow)
                {
                    Container newContainer = new Container(containerIdCounter++, ContainerDimensions.Length, ContainerDimensions.Width, ContainerDimensions.Height);
                    newContainer.PlaceItem(initialPlacement); // Place at (0,0,0) with the found rotation
                    containers.Add(newContainer);
                    packedItems.Add(item);
                    Console.WriteLine($"Opened Container {newContainer.Id} and placed {item.Name} at {initialPlacement.Position} with rotation {initialPlacement.PlacedDimensions}");
                }
                else
                {
                    // Item is too large for the container
                    Console.WriteLine($"Error: Item {item.Name} ({item.OriginalDimensions}) is too large to fit in the container ({ContainerDimensions}).");
                    // Decide how to handle this - skip item, throw exception?
                }
            }
        }

        Console.WriteLine($"\nPacking complete. Total containers used: {containers.Count}");
        return containers;
    }
}

// Example Usage
public class Example
{
    public static void Main(string[] args)
    {
        // --- Configuration ---
        // Use internal dimensions of a 40ft High Cube container in cm
        decimal containerL = 1203m;
        decimal containerW = 235m;
        decimal containerH = 269m; // Use decimal for potentially better precision with cm/mm
        Console.WriteLine($"Using Container Dimensions: {containerL}cm x {containerW}cm x {containerH}cm");


        // --- Furniture List (Example Data in cm) ---
        List&lt;Item&gt; furniture = new List&lt;Item&gt;
        {
            // Sofas (L x W x H)
            new Item("Sofa 1", 200m, 90m, 80m),
            new Item("Sofa 2", 220m, 95m, 85m),
            // Coffee Tables
            new Item("Coffee Table 1", 120m, 60m, 45m),
            new Item("Coffee Table 2", 100m, 100m, 40m),
            // Chairs
            new Item("Chair 1", 60m, 60m, 90m),
            new Item("Chair 2", 60m, 60m, 90m),
            new Item("Chair 3", 55m, 58m, 95m),
            new Item("Chair 4", 55m, 58m, 95m),
            // Larger item test
            new Item("Wardrobe", 150m, 60m, 200m),
             // More items
             new Item("Bookshelf", 80m, 30m, 180m),
             new Item("Side Table 1", 40m, 40m, 60m),
             new Item("Side Table 2", 40m, 40m, 60m),
             new Item("Ottoman", 70m, 70m, 40m),

             // Add many more small items to test filling gaps
             // ... (e.g., 20 small boxes 30x30x30)
             // for (int i = 0; i &lt; 20; i++) { furniture.Add(new Item($"Small Box {i+1}", 30m, 30m, 30m)); }
        };

        Console.WriteLine($"\nItems to pack ({furniture.Count} total):");
        foreach(var item in furniture) Console.WriteLine($"- {item}");


        // --- Packing ---
        Packer packer = new Packer(containerL, containerW, containerH);
        List&lt;Container&gt; resultContainers = packer.PackItems(furniture);

        // --- Output Results ---
        Console.WriteLine($"\n--- Packing Summary ---");
        Console.WriteLine($"Total Containers Needed: {resultContainers.Count}");
        for (int i = 0; i &lt; resultContainers.Count; i++)
        {
            decimal packedVolume = resultContainers[i].PlacedItems.Sum(p =&gt; p.PlacedDimensions.Volume);
            decimal totalVolume = resultContainers[i].Dimensions.Volume;
            decimal utilization = totalVolume &gt; 0 ? (packedVolume / totalVolume) * 100 : 0;
            Console.WriteLine($"Container {resultContainers[i].Id}: Contains {resultContainers[i].PlacedItems.Count} items. Volume Utilization: {utilization:F2}%");
            // Optionally print items in each container
            // foreach(var placed in resultContainers[i].PlacedItems) {
            //     Console.WriteLine($"  - {placed.SourceItem.Name} at {placed.Position} as {placed.PlacedDimensions}");
            // }
        }
    }
}
</code></pre>
<p><strong>关键点和改进方向:</strong></p>
<ol>
<li><strong>单位一致性:</strong> 代码中使用 <code>decimal</code> 和厘米（cm）作为例子。确保所有输入尺寸和容器尺寸使用相同单位。</li>
<li><strong>锚点管理:</strong> <code>PlaceItem</code> 中更新锚点的逻辑非常基础。更高级的算法会更智能地管理剩余空间，例如使用Maximal Spaces或更复杂的锚点生成/消除规则，以避免产生无法使用的小碎片空间或无效锚点。</li>
<li><strong>启发式选择:</strong>
<ul>
<li><strong>排序:</strong> 按体积降序排序是常见的 FFD 启发式。也可以尝试按最长边、面积等排序。</li>
<li><strong>锚点选择:</strong> <code>TryPlaceItem</code> 中按 Z, Y, X 排序锚点尝试填充底部。可以尝试其他顺序。</li>
<li><strong>旋转选择:</strong> 当前代码尝试所有6种旋转。可以根据锚点和周围空间优先尝试更“可能”成功的旋转。</li>
</ul>
</li>
<li><strong>性能:</strong> 对于大量物品，碰撞检测（<code>Intersects</code>）和锚点管理会成为瓶颈。可能需要空间分区数据结构（如 Octree）来加速碰撞检测。</li>
<li><strong>稳定性/约束:</strong> 当前算法纯粹是几何装箱。没有考虑：
<ul>
<li><strong>重量:</strong> 重物应在底部。</li>
<li><strong>易碎性:</strong> 不能将重物压在易碎品上。</li>
<li><strong>堆叠限制:</strong> 某些物品不能堆叠或只能承受有限的重量。</li>
<li><strong>方向:</strong> 有些家具（如沙发）可能不能倒置或侧放。</li>
<li>这些约束需要添加到 <code>Item</code> 类和 <code>TryPlaceItem</code> 的检查逻辑中，会显著增加复杂性。</li>
</ul>
</li>
<li><strong>最优性:</strong> 这个启发式算法不保证找到绝对最少的集装箱数量。更复杂的算法（如禁忌搜索、模拟退火、遗传算法）或精确算法（分支定界法，但非常慢）可能得到更好的结果，但实现难度大得多。</li>
<li><strong>用户界面/输入:</strong> 实际应用中，需要从文件、数据库或UI读取家具列表和尺寸。</li>
<li><strong>可视化:</strong> 输出放置坐标后，使用3D可视化工具展示装箱结果会非常有帮助。</li>
</ol>
<p>这个框架提供了一个起点。根据实际需求的复杂性和对最优性的要求，可以进一步优化和扩展这个算法。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.22465647026041666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 15:07">2025-04-25 15:06</span>&nbsp;
<a href="https://www.cnblogs.com/FreeSql">FreeSql</a>&nbsp;
阅读(<span id="post_view_count">217</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18846755);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18846755', targetLink: 'https://www.cnblogs.com/FreeSql/p/18846755', title: '三维装箱问题（3D Bin Packing Problem, 3D-BPP）' })">举报</a>
</div>
        