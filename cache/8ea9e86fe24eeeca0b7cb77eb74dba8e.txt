<!----> <meta itemprop="headline" content="前端仔如何在公司搭建 AI Review 系统"> <meta itemprop="keywords" content="前端,人工智能,AIGC"> <meta itemprop="datePublished" content="2025-07-30T03:09:35.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="唐某人丶"> <meta itemprop="url" content="https://juejin.cn/user/2858385965324904"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端仔如何在公司搭建 AI Review 系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2858385965324904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    唐某人丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-07-30T03:09:35.000Z" title="Wed Jul 30 2025 03:09:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-07-30
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    5,755
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读24分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">一、前言</h2>
<p>在上一篇 <a href="https://juejin.cn/post/7517197769247391756" target="_blank" title="https://juejin.cn/post/7517197769247391756">《AI 应用开发入门：前端也可以学习 AI》</a>中，我给大家分享了前端学习 AI 应用开发的入门相关知识。我相信很多同学，看完应该都有了一定的收获。未来我会把关于前端学习 AI 的文章都放在这个 <a href="https://juejin.cn/column/7498247273660547124" target="_blank" title="https://juejin.cn/column/7498247273660547124">《前端学习 AI 之路》</a> 专栏进行更新~</p>
<p>本篇会更偏向实际的应用，我将会运用之前分享的技术和概念，给大家分享如何通过 nodejs + LLM 搭建一个简易的 AI Review 系统的。</p>
<p>在本篇你将收获到：</p>
<ol>
<li>设计 AI 应用的思路</li>
<li>设计提示词的思路</li>
<li>如何用 NodeJS 结合 LLM 分析代码</li>
</ol>
<h2 data-id="heading-1">二、背景</h2>
<p>我相信大家在团队中，都会有 Code Review 这个流程。但是有时候随着人手不够、项目周期紧张，就会出现 review 流程被忽视、或者 review 质量不高的问题。于是，我就在想，是否可以把这种费时、费精力且需要专注的事情，交给一个专门的“AI 员工”去完成呢？答案是可以的。</p>
<h2 data-id="heading-2">三、整体效果</h2>
<p>目前在我们团队，已经全面的在使用 AI 进行 Review 了，涵盖了前端、后端大大小小 20 + 的项目。得益于在集团内可以使用像（“GPT-4.1、 Calude”）这样更大上下文、更强推理能力的模型，所以整体效果是非常不错的。有时候一些很细微的安全隐患、性能、业务逻辑等问题，AI 都能比人更容易发现。</p>
<p>下面是我用演示的项目呈现的效果，也就是我们即将动手搭建的这个项目。</p>
<h3 data-id="heading-3">3.1 评论模式</h3>
<p>通过 AI 分析提交的代码，然后会在有问题的代码下，评论出问题类型以及问题的具体原因。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/469727a4f4814cf89ffdcd855adca141~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=qsKHRitlCx7eodSHSNXKJ7X1908%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-4">3.2 报告模式</h3>
<p>还一种是报告的展示形式。它会在提交的 MR 下输出一个评审报告，列出所有问题的标题、所在位置、以及具体原因。但是，这两种模式实现的本质都一样，只不过是展示结果的方式有不同，这个看你个人喜欢。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98f935515c6641ad8380699668556729~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=3Yvrn8MShXEH7My2dLZ3bbSpS0g%3D" alt="" loading="lazy"></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78291be3003049b0b951da52edad2245~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=tkgdUvAalJE%2FLUonaQcODPtz%2FOI%3D" alt="" loading="lazy"></p>
<h2 data-id="heading-5">四、思路分析</h2>
<p>那这个 AI Code Review 应用要怎么实现呢？下面给大家分享一下具体的思路。</p>
<h3 data-id="heading-6">4.1 人为流程</h3>
<p>首先要做的，就是分析你现有团队人工 review 代码的规范，然后总结出一个<strong>具体流程</strong>。为什么要这样做？<strong>因为让 AI 帮你做事的本质，就是让它模仿你做事</strong>。如果连你自己都不清楚具体的执行流程，就更别期待 AI 能把这个事情做好了。</p>
<p>下面是我举例的一个 review 流程，看完后你可以思考一下，自己平时是怎么 review 代码的，有没有一个固定的流程或者方案。如果有，则按照下面的这个“行为 + 目的”的格式记录下来。</p>
<ol>
<li>行为：收到的 MR 的提示了；目的：知道有需要 review 的 MR 提交</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4691a1d7ab324d979a63ffa624fac0c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=dvIRbnEmsIyTBU1Xxdu6rFGpHIE%3D" alt="" loading="lazy"></p>
<ol start="2">
<li>行为：查看 commit message；目的：确认本次提交的主题是什么。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac2965eb38b14adf967e6afaa5a686aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=aLk16ugeqT5Uaxl8m0VFFisWmt8%3D" alt="" loading="lazy"></p>
<ol start="3">
<li>行为：查看改动哪些文件；目的：确认改动范围，主要判断改了哪些业务模块、是否改了公共、或者高风险文件等</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0616a61ea0e4397a1a7d8c71c5f5cdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=f8Kd60F0AlzleIDuGGfzJ1oCBHw%3D" alt="" loading="lazy"></p>
<ol start="4">
<li>行为：查看文件路径；目的：确认该文件关联的业务、所属的模块等信息，当做后续 diff 评审的前置判断信息。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bf82e35bb3443efadbd7b295d39e158~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=LEB90Vy7gr0jzuofqYkOuaBlxwU%3D" alt="" loading="lazy"></p>
<ol start="5">
<li>行为：查看 diff 内容；目的：判断改动代码的逻辑、安全、性能是否存在问题。结合相关的业务和需求信息，判断是否有实现不合理的地方。</li>
<li>行为：在有问题的相关代码下，发出评论；目的：在有问题的代码下面，给出修改建议，让开发的同事能够注意和修改一下当前的问题。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df9f9ad7f6d746fcbb6ae0bd903cfd42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=nGABi%2FkwSeUHpnIOwYvwO6VOLbA%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-7">4.2 程序流程</h3>
<p>上面列举的是一个完整的人为评审代码的流程。但是，如果想让 AI 完全模仿，其实是存在一定的复杂性的。比如，人在评审某处 diff 时，会思考关联的业务、模块等前置信息，然后再做出评论。而不单单只是评审代码表面的编码问题。如果想要 AI 也这样做，还需要引入 RAG 等相关的技术，目的则是为了补充给更多的上下文信息。</p>
<p>为了不增加大家的实现和理解难度，本篇我们实现的是一个简化版本的 AI Code Review。下面是我梳理的 review 流程和与之对应的 AI 应用流程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d72fd3f39f444fc59b3a9a5ee740a134~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=B0H1HnJ9AIcusYQS6Uug5MomVww%3D" alt="画板" loading="lazy"></p>
<h3 data-id="heading-8">4.2 核心问题</h3>
<p>这次搭建的 AI Code Review 应用，本质上是一个 NodeJS 服务。这个服务通过感知 MR 事件，获取 diff 交给 LLM 分析，得到结论以后，会输出评论到 GitLab。整体流程图如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9e27ae2bb1c47f19a7bdab492d3ea7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=kaeY0IgmXta5wNwGGNVs3ezlRN4%3D" alt="" loading="lazy"></p>
<p>所以，我们要面对这些核心问题是</p>
<ol>
<li>node 服务如何感知 GitLab 的 MR 提交</li>
<li>如何获取 MR 中每个文件改动的 diff</li>
<li>如何让编写提示词，让大模型评审和分析并输出结构化的数据</li>
<li>如何解析数据以及异常的处理</li>
<li>如何发送评论到 gitlab</li>
<li>如何推送状态到企微</li>
</ol>
<p>接下来，我们带着上面的问题，来一步步实现这个 AI Code Review 应用。</p>
<h2 data-id="heading-9">五、具体实现</h2>
<h3 data-id="heading-10">5.1 创建项目</h3>
<p>创建一个 NestJS 的项目（用什么技术框架都可以，你可以使用你最熟悉的 Node 开发框架。重点是关注实现的核心步骤和思路，这个演示的项目我开源了，可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent" target="_blank" title="https://github.com/zixingtangmouren/mr-agent" ref="nofollow noopener noreferrer">GitHub</a> 上查看完整的代码）</p>
<pre><code class="hljs language-bash" lang="bash">nvm use 20
</code></pre>
<p>使用 nest 命令初始化一个项目</p>
<pre><code class="hljs language-bash" lang="bash">nest new mr-agent
</code></pre>
<h3 data-id="heading-11">5.2 实现 webhook 接口</h3>
<p>首先我们来解决 node 服务如何感知 MR 事件的问题</p>
<h4 data-id="heading-12">Webhook</h4>
<p>像 GitLab、GitHub 都会允许用户在项目中配置 webhook。它是干嘛的呢？ webhook 可以让外部的服务，感知到 git 操作的相关事件（如 push 、merge 等事件）。比如我在合并代码时，gitlab 就会把 MR 事件，通过这个 hook 发送到我们搭建的服务上。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88c89f9efa004d1b9dad3bf74d883caf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=9pHDZHV1HAQPSDha1%2BPe%2FYWBDJU%3D" alt="画板" loading="lazy"></p>
<p>以 GitLab 为例，它会允许开发者在每个项目中配置多个 webhook 接口。比如，咱们配置一个 <code>http://example.com/webhook/trigger</code> 的地址。当发生相关 git 事件时，GitLab 就会往这个地址推送消息。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a20acb88cb184a179edbcc23b47a1028~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=10TqDoMQnEQ5c3zJMtJAkwm8TQ0%3D" alt="" loading="lazy"></p>
<h4 data-id="heading-13">代码实现</h4>
<p>所以，我们要做的第一件事，就是定义一个接口 url，用于接收 GitLab 的 webhook 事件。下面的代码中，实现了一个处理<code>/webhook/trigger</code>路由的 controller，它的主要职责是接收 MR 事件并且解析 body 和 header 中的参数，代码如下（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent%2Fblob%2Fmain%2Fsrc%2Fwebhook%2Fwebhook.controller.ts" target="_blank" title="https://github.com/zixingtangmouren/mr-agent/blob/main/src/webhook/webhook.controller.ts" ref="nofollow noopener noreferrer">完整代码</a>）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5d91b8bd7134c2b9d1ca875f7c845db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=epq7Uo2knp13lcTyBJnOIV%2B0Hys%3D" alt="" loading="lazy"></p>
<h4 data-id="heading-14">Body</h4>
<p>body 中会包含很多有用的的信息，如 Git 仓库信息、分支信息、MR 信息、提交者信息等，这些数据是 GitLab 调用 webhook 接口时发送过来的，在后续的逻辑中，都会用到里面的数据。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e38fb74fa1d84025b3581aa90c70cf67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=B1QWQcLJjweKBaymFAEjV7xq%2BDQ%3D" alt="" loading="lazy"></p>
<ul>
<li>object_type/object_kind：描述的事件的类型，例如 merge 事件、push 事件等。</li>
<li>project：主要是描述仓库相关的信息，例如项目 id、名称等</li>
<li>object_attributes: 主要包含本次 MR 相关的信息，如目标分支、源分支、mr 的 id 等等</li>
<li>user：提交者的信息</li>
</ul>
<h4 data-id="heading-15">Header</h4>
<p>header 中是我们自己目定义的配置信息，核心有三个</p>
<ul>
<li>x-ai-mode：评论的模式（report 报告模式、 comment 评论模式）</li>
<li>x-push-url：用于推送状态的地址（推送到企微、或者飞书的机器人）</li>
<li>x-gitlab-token：gitlab 中的 access token，用于后续 GitLab API 调用鉴权</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47623297252c465b88462974b4a84c95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=vYYwYXMo%2Fq3%2B46ItoI%2Fv0r5W64g%3D" alt="" loading="lazy"></p>
<h4 data-id="heading-16">调试问题</h4>
<p>调试开发的这个接口确实是一个比较麻烦的问题。因为 GitLab 基本都是内网部署，想要真实调试接口，一是需要真实代码仓库，二是需要想办法把 GitLab 的请求转发到本地来。这里我给大家分享三个办法：</p>
<h5 data-id="heading-17">内网转发</h5>
<p>使用内网转发的办法，第三方的例如 <strong>ngrok</strong>、<strong>localtunnel</strong>、<strong>frp</strong> 等。如果你们公司的部署平台本身支持流量转发到本地，那就更好了（我用的是这个办法）。</p>
<h5 data-id="heading-18">ApiFox、Postman</h5>
<p>先将服务部署到你们公司 GitLab 可以访问的服务器上，手动触发 MR 事件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8431e9a28a0b41b29e8f09ff51c5d6ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=6cCgwLu7rK9tSi5JqkOi6QJgfaU%3D" alt="image.png" loading="lazy"></p>
<p>然后在日志上打印完整的 header 和 body，然后复制到 ApiFox、Postman 上在本地模拟请求</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4196a2e2dd7447c844b2a865a81a205~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=cjV%2BciKuhC5vyE1O6hou7NP%2BCFk%3D" alt="image.png" loading="lazy"></p>
<h5 data-id="heading-19">问 AI</h5>
<p>😁 最后一个办法就是，根据你的场景，问问 AI 怎么做
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4075bcc79ef744e282ff8f1fd7354960~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=yIPTdCIj5pq%2B416oWukX7Fp69Gg%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-20">5.3 获取 diff 内容</h3>
<p>在能够接受到 GitLab 发送的 MR 事件后，就要解决如何获取 diff 的问题。这一步很简单， 调用 GitLab 官方的 API 就可以。重点就是两个核心逻辑：</p>
<ol>
<li>获取全部文件的 diff 内容</li>
<li>过滤非代码文件</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/854a043196f24e9db6a576161e3ec7c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=OQ6QOjvwuiggfrXs5YbX8ZpVyQU%3D" alt="" loading="lazy"></p>
<h4 data-id="heading-21">获取 diff 内容</h4>
<p>gitlab 的 api 路径一般是一样的。唯一的区别就是不同公司的部署域名不同。baseUrl 需要配置成你公司的域名，projectId 和 mrId 都可以在 body 中取到（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent%2Fblob%2Fmain%2Fsrc%2Fgit-provide%2Fgit-provide.service.ts" target="_blank" title="https://github.com/zixingtangmouren/mr-agent/blob/main/src/git-provide/git-provide.service.ts" ref="nofollow noopener noreferrer">完整代码</a>）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/275f28c741f34669a8079698f9c4d607~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=OkoOzRIuJwt%2F7%2F8nqOiyWLr2jH0%3D" alt="" loading="lazy"></p>
<p>调用成功以后，获取的数据如下，changes 中会包含每个文件的 diff</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fab53183bef246ea9f35460255774aef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=Jz4DZND4pwzidp0g1UdiA%2BZ6Q5I%3D" alt="" loading="lazy"></p>
<h4 data-id="heading-22">过滤文件</h4>
<p>因为并不是所有的文件都需要让 LLM 进行 review ，例如像 package.json、package-lock.json 等等。所以需要把这部分非代码文件过滤出来。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92ad68f557a94c17b86849d49ddf7a60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=v9tGrTAswZGSsJtyrJOipNG%2FGG0%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-23">5.4 设计提示词</h3>
<p>有了每个文件的 diff 数据以后，就是解决如何分析 diff 内容并输出有效结论的问题。其实这个问题的本质，就是如何设计系统提示词。</p>
<h4 data-id="heading-24">提示词思路</h4>
<p>首先我们先思考一下编写提示词的目的是什么？我们期望的是，通过提示词指引 LLM，当输入 diff 文本的时候，它能够分析里面的代码并输出结构化的数据。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6b350ca5e014afcb0ad70eca8c08beb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=Wp3YRDoUg3q1W4rnuro%2BKQ1p0q8%3D" alt="画板" loading="lazy"></p>
<p>我们希望 LLM 返回的是一个数组，数组的每一项是对每一个问题的描述，里面包含标题、文件路径、行号、具体的内容等，数据结构如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Review</span> {
  <span class="hljs-comment">// 表示修改后的文件路径</span>
  <span class="hljs-attr">newPath</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 表示修改前的文件路径</span>
  <span class="hljs-attr">oldPath</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 表示评审的是旧代码还是新代码，如果评审的是 + 部分的代码，那么 type 就是 new，如果评审的是 - 部分的代码，那么 type 就是 old。</span>
  <span class="hljs-attr">type</span>: <span class="hljs-string">'old'</span> | <span class="hljs-string">'new'</span>;
  <span class="hljs-comment">// 如果是 old 类型，那么 startLine 表示的是旧代码的第 startLine 行，否则表示的是新代码的第 startLine 行</span>
  <span class="hljs-attr">startLine</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// 如果是 new 类型，那么 endLine 表示的是旧代码的第 endLine 行，否则表示的是新代码的第 endLine 行</span>
  <span class="hljs-attr">endLine</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// 对于存在问题总结的标题，例如(逻辑错误、语法错误、安全风险等)，尽可能不超过 6 个字</span>
  <span class="hljs-attr">issueHeader</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 清晰的描述代码中存在、需要注意或者修改的问题，并给出明确建议</span>
  <span class="hljs-attr">issueContent</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MRReview</span> {
  <span class="hljs-attr">reviews</span>: <span class="hljs-title class_">Review</span>[];
}
</code></pre>
<p>之所以需要这种结构化的数据，是因为后续在调用 GitLab API 发送评论的时候，需要用到这些参数。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f074851b6c0d4c3e8d0455407e74015d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=pfabc0MdV1f%2B4bh97Vqqe9who0k%3D" alt="" loading="lazy"></p>
<p>整体思路确定好了，接下来我们就来编写具体的系统提示词。</p>
<h4 data-id="heading-25">角色设定</h4>
<p>角色设定就是告诉 LLM 扮演什么角色以及它的具体要做什么事情</p>
<pre><code class="hljs language-markdown" lang="markdown">你是一个代码 MR Review 专家，你的任务是评审 Git Merge Request 中提交的代码，如果存在有问题的代码，你要提供有价值、有建设性值的建议。
注意，你评审时，应重点关注 diff 中括号后面带 + 或 - 的代码。
</code></pre>
<h4 data-id="heading-26">输入内容</h4>
<p>上面有说到，我们不仅需要 LLM 分析代码的问题，还需要它把问题代码所在的<strong>文件路径、行号分析</strong>出来。</p>
<p>但是，如果你直接把原生的 diff 内容输入给它，它是不知道这些信息。因为<strong>原生的 diff 并没有具体的行号、新旧文件路径信息</strong>的。</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-meta">@@ -1,16 +1,13 @@</span>
import { Injectable } from '@nestjs/common';
   
<span class="hljs-deletion">-interface InputProps {</span>
<span class="hljs-deletion">-  code_diff: string;</span>
<span class="hljs-deletion">-  code_context: string;</span>
<span class="hljs-deletion">-  rules?: string;</span>
<span class="hljs-deletion">-}</span>
<span class="hljs-addition">+type InputProps = Record&lt;string, any&gt;;</span>

interface CallDifyParams {
</code></pre>
<p>所以我们<strong>需要扩展输入的 diff，给它增加新旧文件的路径、以及每一行具体的行号</strong>，例如 (1， 1) 表示的是当前行，是旧文件中的第 1 行，新文件中的第 1 行。这个后面会说如何扩展，这里我们只是要先设计好，并告诉 LLM 我们会输入什么格式的内容</p>
<pre><code class="hljs language-diff" lang="diff">## new_path: src/agent/agent.service.ts
## old_path: src/agent/agent.service.ts
<span class="hljs-meta">@@ -1,16 +1,13 @@</span>
(1, 1) import { Injectable } from '@nestjs/common';
(2, 2)  
(3, ) -interface InputProps {
(4, ) - code_diff: string;
(5, ) - code_context: string;
(6, ) - rules?: string;
(7, ) -}
( , 8) +type InputProps = Record&lt;string, any&gt;;
(9, 9)  
(10, 10) interface CallDifyParams {
</code></pre>
<p>有了这些完善的信息，LLM 才知道有问题的代码在哪个文件以及它所在的具体行号</p>
<h4 data-id="heading-27">加解释</h4>
<p>diff 经过我们的扩展以后，就不再是标准的描述 diff 的 Unified Format 格式了，所以必须向 LLM  解释一下格式的含义，增强它对输入的理解，避免它随便臆想。</p>
<pre><code class="hljs language-markdown" lang="markdown">我们将使用下面的格式来呈现 MR 代码的 diff 内容:

<span class="hljs-section">## new<span class="hljs-emphasis">_path: src/agent/agent.service.ts
## old_</span>path: src/agent/agent.service.ts</span>
@@ -1,16 +1,13 @@
(1, 1) import { Injectable } from '@nestjs/common';
(2, 2)  
(3, ) -interface InputProps {
(4, ) - code<span class="hljs-emphasis">_diff: string;
(5, ) - code_</span>context: string;
(6, ) - rules?: string;
(7, ) -}
( , 8) +type InputProps = Record<span class="xml">&lt;string, any&gt;</span>;
(9, 9)  
(10, 10) interface CallDifyParams {

<span class="hljs-bullet">-</span> 以 ”## new<span class="hljs-emphasis">_path“ 开头的行内容，表示修改后的文件路径
- 以 ”## old_</span>path“ 开头的行内容，表示修改前的文件路径
<span class="hljs-bullet">-</span> @@ -1,16 +1,13 @@ 是统一差异格式(Unified Diff Format)中的hunk header，用于描述文件内容的具体修改位置和范围
<span class="hljs-bullet">-</span> 每一行左侧括号内的两个数字，左边表示旧代码的行号，右边表示新代码的行号
<span class="hljs-bullet">-</span> 括号后的 + 表示的是新增行
<span class="hljs-bullet">-</span> 括号后的 - 表示的是删除行
<span class="hljs-bullet">-</span> 引用代码中的变量、名称或文件路径时，请使用反引号（`）而不是单引号（'）。
</code></pre>
<h4 data-id="heading-28">加限制</h4>
<p>加限制的主要目的是指引 LLM 按照固定的数据类型进行输出。这里我们会告诉 LLM 具体的 TS 类型，避免它输出一些乱七八糟的类型，导致后续在代码中解析和使用的时候报异常。例如，数字变成字符串、字符串变成数组等。</p>
<pre><code class="hljs language-markdown" lang="markdown">你必须根据下面的 TS 类型定义，输出等效于MRReview类型的YML对象：

<span class="hljs-code">```ts
interface Review {
  // 表示修改后的文件路径
  newPath: string;
  // 表示修改前的文件路径
  oldPath: string;
  // 表示评审的是旧代码还是新代码，如果评审的是 + 部分的代码，那么 type 就是 new，如果评审的是 - 部分的代码，那么 type 就是 old。
  type: 'old' | 'new';
  // 如果是 old 类型，那么 startLine 表示的是旧代码的第 startLine 行，否则表示的是新代码的第 startLine 行
  startLine: number;
  // 如果是 new 类型，那么 endLine 表示的是旧代码的第 endLine 行，否则表示的是新代码的第 endLine 行
  endLine: number;
  // 对于存在问题总结的标题，例如(逻辑错误、语法错误、安全风险等)，尽可能不超过 6 个字
  issueHeader: string;
  // 清晰的描述代码中存在、需要注意或者修改的问题，并给出明确建议
  issueContent: string;
}

interface MRReview {
  reviews: Review[];
}
```</span>

</code></pre>
<p>在限制的类型中，最好是增加一些注解，让 LLM 能够理解每个字段的含义。</p>
<h4 data-id="heading-29">加示例</h4>
<p>加示例的主要目的是告诉 LLM 按照固定的文件格式进行输出，这样我们就可以直接拿 LLM 的输出，进行标准化的解析，转换成实例的数据进行使用，伪代码如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 调用 LLM 的接口</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">callLLM</span>(<span class="hljs-string">'xxxxx'</span>);

<span class="hljs-comment">// 解析数据</span>
<span class="hljs-keyword">const</span> data = yaml.<span class="hljs-title function_">load</span>(result);

<span class="hljs-comment">// 操作数据</span>
data.<span class="hljs-property">reviews</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> {  })

</code></pre>
<p>提示词描述如下</p>
<pre><code class="hljs language-markdown" lang="markdown">输出模板（注意，我只需要 yaml 格式的内容。yaml 内容的前后不要有其他内容）:

<span class="hljs-code">```yaml
reviews:
  - newPath: |
      src/agent/agent.service.ts
    oldPath: |
      src/agent/agent.service.ts
    startLine: 1
    endLine: 1
    type: |
      old
    issueHeader: |
      逻辑错误
    issueContent: |
      ...
  - newPath: |
      src/webhook/decorators/advanced-header.decorator.ts
    oldPath: |
      src/webhook/decorators/commmon-header.decorator.ts
    startLine: 1
    endLine: 1
    type: |
      new
    issueHeader: |
      性能风险
    issueContent: |
      ...
```</span>
</code></pre>
<p>这里简单说一下，为什么选择 yaml 而不是 json。因为在实践的过程中，我们发现 json 解析异常的概率会比 yaml 高很多，因为 json 的 key 和 value 是需要双引号("")包裹的，如果 issueContent 中包含了代码相关的内容且存在一些双引号、单引号之类的符号，就很容易导致报错，而且比较难通过一些替换规则进行兜底处理。</p>
<p>最后完整的提示词这里：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent%2Fblob%2Fmain%2Fpublic%2Fprompt.txt" target="_blank" title="https://github.com/zixingtangmouren/mr-agent/blob/main/public/prompt.txt" ref="nofollow noopener noreferrer">提示词</a></p>
<h4 data-id="heading-30">调试</h4>
<p>这里再告诉大家一个提示词的调试技巧，你可以先在 Coze、Dify 这样的平台上，通过工作台不断调试你的提示词，直到它能够稳定的输出你满意的结果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96f7aaa365484a55a3eba77861336f50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=ZaV26EjmEemb4%2Bv5yovd0MRGKeM%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-31">5.5 扩展、组装 diff</h3>
<p>上面我们有说到，通过 GitLab 获取的原始 diff 是没有新旧文件路径和具体的新旧行号的，这个需要通过代码计算来补全这些信息。这一小节，我们就来解决 diff 的扩展、组装问题。</p>
<h4 data-id="heading-32">扩展</h4>
<p>扩展主要做两个事：</p>
<ul>
<li>在 diff 头部加新旧文件的路径</li>
<li>在每一行加新旧文件中的行号</li>
</ul>
<p>加路径比较简单，可以在获取每个文件的 diff 数据的时候，拿到新旧文件的路径的，取值后加上即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0225da45743d40a187d00ede7a0b677d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=2%2BQnYWBCHDB6Q1HiMivJtgn%2FV5E%3D" alt="image.png" loading="lazy">
加行号稍微麻烦一点，我们需要将当前文件的 diff 按照 hunk 拆分成不同的块，然后会根据 hunk head 计算每行在新旧文件中的真实行号。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa84051d0b61464bb8fc87cc2ed79244~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=VHVGokH%2FLMaEDs52N7%2Bjf8Y%2Bez0%3D" alt="image.png" loading="lazy"></p>
<blockquote>
<p>为了防止有些同学不清楚 diff 格式的结构，我这里简单标注一下。
在下面这个 diff 中，像 “@@ -1,16 +1,13 @@” 这样的内容就是 Hunk Head，用于描述后续 diff 内容在新旧文件中的起始行号。用框住的第一个 hunk 为例：</p>
<ul>
<li>-1,16: 表示 <code>import { Injectable } from '@nestjs/common';</code> 是在旧文件中的第 1 行，改动范围是往后的一共 16 行，需要忽略 “+” 加号开头的行。</li>
<li>+1,13：表示是<code>import { Injectable } from '@nestjs/common';</code>在新文件中的第 1 行，改动范围是往后的一共 13 行，需要忽略 “-” 加号开头的行。</li>
</ul>
<p>然后图中被我用红框标注的连续代码片段就是 hunk，它一般由 hunk header + 连续的代码组成。一个文件的 diff 可能会有多个 hunk。</p>
<ul>
<li>hunk 中 “+” 开头的行，表示新文件中增加的行</li>
<li>“-” 开头的行，表示旧文件中被删除的行
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ef17e6d7bc24b45b2db11068beb65b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=o7xzcDEd2XQVmogG2MirIM4wtIM%3D" alt="image.png" loading="lazy"></li>
</ul>
</blockquote>
<p>这里需要先遍历每个文件的 diff，然后按 hunk head 来分割内容块。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> hunks = <span class="hljs-title function_">splitHunk</span>(diffFile.<span class="hljs-property">diff</span>);
</code></pre>
<p>代码如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/42536c3eda95470a9cf52c237a2b932e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=PLhGasXPSPzMc6HNo9awTT9bsOw%3D" alt="" loading="lazy"></p>
<p>逻辑是将 diff 按 “\n” 分割成包含所有行的数组，然后遍历每一行。每当遍历到一个 hunk head 就创建一个新的 hunk 结构，然后通过正则提取里面的起始行号，并将后续遍历到的行都保存起来，直到它遇到一个新的 hunk head。</p>
<p>接着就是遍历 hunk，计算每个 hunk 中每一行的具体行号。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2f7b1e5e3db4020a7c7049a4a15951a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=tqyx9tiumPk2zHV4KvFd0gPL6yM%3D" alt="" loading="lazy"></p>
<p>comptuedHunkLineNumer 的代码如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff8ee527a54c40c48c53cf57583286c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=kQmakBUWOz8Pz139%2B%2BaZ%2BgAIQUs%3D" alt="" loading="lazy"></p>
<p>核心逻辑是：</p>
<ol>
<li>使用 oldLineNumber、newLineNumber 两个独立计数器，记录新旧文件的当前行号</li>
<li>遍历到 “-” 开头的行，oldLineNumber + 1，记录行号（oldLineNumber + 1， ）</li>
<li>遍历到 “+” 开头的行，newLineNumber + 1，记录行号（ ， newLineNumber + 1）</li>
<li>遍历常规的行，oldLineNumber 和 newLineNumber 都  + 1，记录行号（oldLineNumber + 1， newLineNumber + 1）</li>
</ol>
<p>为了让你更清晰理解这个逻辑，我在 diff 中标注一下。下面是计算旧文件中的行号，我们只会对“-”开头的行和普通的行进行计数，忽律 “+” 开头的行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60b6972f6e29476089383e4dd308e485~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=YqFpe%2FIX3xcZ9dV3KoGp6rXkvKI%3D" alt="" loading="lazy"></p>
<p>计算新文件中的行，此时我将不计算 “-” 开头的行。所以<code>type InputProps = Record&lt;string, any&gt;;</code>这行代码，在合并后的新文件中，真正的行号是在第 15 行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4125366e640e43feb0551555d1fe3955~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=F5dAZ%2B9jw%2BM%2F9k3Q38L%2BbUyrEtk%3D" alt="" loading="lazy"></p>
<p>处理后 diff 的每一行，都会带上新旧文件中的行号</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-meta">@@ -1,16 +1,13 @@</span>
(1, 1)    import { Injectable } from '@nestjs/common';
(2, 2)    
(3, )    -interface InputProps {
(4, )    -  code_diff: string;
(5, )    -  code_context: string;
(6, )    -  rules?: string;
(7, )    -}
( , 8)   +type InputProps = Record&lt;string, any&gt;;
(9, 9)    
(10, 10)  interface CallDifyParams {
(11, 11)    input: InputProps;
(12, 12)    query: string;
(13, 13)    conversation_id?: string;
(14, 14)    user: string;
( , 15)  +  apiKey: string;
(16, 16)  }
(17, 17)  
</code></pre>
<h4 data-id="heading-33">组装</h4>
<p>得到每个文件扩展的 diff 以后，便是将 commit message 和所有文件 diff 拼接到一个字符串中，后续会把这个拼接好的字符串直接输入给 LLM 进行分析。</p>
<pre><code class="hljs language-diff" lang="diff">commit message: feat: 调整 review 触发逻辑，增加请求拦截器

##new_path: src/agent/agent.service.ts
##old_path: src/agent/agent.service.ts
<span class="hljs-meta">@@ -1,16 +1,13 @@</span>
(1, 1)    import { Injectable } from '@nestjs/common';
(2, 2)    
(3, )    -interface InputProps {
(4, )    -  code_diff: string;
(5, )    -  code_context: string;
(6, )    -  rules?: string;
(7, )    -}
( , 8)   +type InputProps = Record&lt;string, any&gt;;

## new_path: src/webhook/decorators/advanced-header.decorator.ts
## old_path: src/webhook/decorators/advanced-header.decorator.ts
<span class="hljs-meta">@@ -0,0 +1,152 @@</span>
( , 1)     +import {
( , 2)     +  createParamDecorator,
( , 3)     +  ExecutionContext,
( , 4)     +  BadRequestException,
( , 5)     +} from '@nestjs/common';
( , 6)     +
( , 7)     +/**
( , 8)     + * 高级 Header 装饰器，支持类型转换和验证
( , 9)     + */
( , 10)    +export const AdvancedHeader = createParamDecorator(
</code></pre>
<h3 data-id="heading-34">5.6 对接 LLM</h3>
<p>现在我们已经有了<strong>系统提示词、处理好的 diff 内容</strong>，接着就是如何调用 LLM 分析结果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8945e273525e4d9f84c98065b72699ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=75oDAg9AO0va0GsFOc8tsfKXVi4%3D" alt="画板" loading="lazy"></p>
<h4 data-id="heading-35">申请 DeepSeek</h4>
<p>演示的案例中，我用的是 DeepSeek-v3 的模型。如果能够使用 GPT-4.1 或者 Calude 模型的同学，你可以优先选择使用这两个模型。</p>
<p>这里你需要去到 <a href="https://link.juejin.cn?target=https%3A%2F%2Fapi-docs.deepseek.com%2Fzh-cn%2F" target="_blank" title="https://api-docs.deepseek.com/zh-cn/" ref="nofollow noopener noreferrer">DeepSeek</a> 官网申请一个 API Key</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3afb5b7e1f884bda8f2fe67924217a34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=a9UlixEOwew2nMM98sQm2TFyNRM%3D" alt="" loading="lazy"></p>
<p>然后去充值个几块钱，你就可以使用 DeepSeek 这个模型了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1546ae61ecb43daba430568c928446f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=EIpetX%2BUa8sH1JfWXUFxr15du2E%3D" alt="" loading="lazy"></p>
<p>具体申请和使用步骤，官网文档都讲得很清楚了，这里不过多赘述。</p>
<h4 data-id="heading-36">调用 LLM</h4>
<p>申请完 DeepSeek 的 API Key 以后，就可以通过接口调用了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f1a8a7920cc4f0ab41c731ff52c6153~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=b6P1tJpPvpsUBLCXe06yU5RSQQI%3D" alt="" loading="lazy"></p>
<p>这里主要关注一下调用接口的入参：</p>
<ul>
<li>model: 如果是 deepseek 的话，你选择 <code>deepseek-chat</code>还是 <code>deepseek-reasoner</code>都可以</li>
<li>messages: 这里我们输入两个 message，一个是系统提示词，一个是扩展的 diff</li>
<li>temperature：设置成 0.2，提高输出的精确性</li>
</ul>
<p>如果一切调用成功的话，你应该会得到 LLM 一个这样的回复：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-code">```yaml
reviews:
  - newPath: |
      src/agent/agent.service.ts
    oldPath: |
      src/agent/agent.service.ts
    startLine: 8
    endLine: 8
    type: |
      new
    issueHeader: |
      类型定义不严谨
    issueContent: |
      将 `InputProps` 从具体的接口类型改为 `Record&lt;string, any&gt;`，虽然提升了灵活性，但丢失了原有的类型约束，容易导致后续代码中出现属性拼写错误或类型不一致的问题。建议保留原有字段定义，并在需要扩展时通过继承或联合类型实现更好的类型安全。
  - newPath: |
      src/webhook/webhook.controller.ts
    oldPath: |
      src/webhook/webhook.controller.ts
    startLine: 38
    endLine: 40
    type: |
      new
    issueHeader: |
      参数注入冗余与未使用参数
    issueContent: |
      在 `trigger` 方法中注入了 `@GitlabToken()`、`@QwxRobotUrl()` 等参数，但实际方法体内并未使用这些参数，而是继续从 headers 中解析相关信息（已被删除）。建议移除未用到的装饰器参数，或者直接替换原有 header 获取逻辑，避免混乱和冗余。
```</span>

</code></pre>
<h3 data-id="heading-37">5.7 数据解析和异常处理</h3>
<p>有了 LLM 回复的数据以后，接着要做的就是将字符串解析成数据，以及处理解析过程中的异常问题</p>
<h4 data-id="heading-38">数据解析</h4>
<p>这里主要做两个是事，一个是提取 yaml 的内容</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb943a224c95430faed6a3a34efe77f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=BYIYUCKQpCTZGhJQq3VWIW0MssM%3D" alt="" loading="lazy"></p>
<p>提取完字符串以后，然后通过 <code>js-yaml</code>这个包解析数据</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> mrReview = yaml.<span class="hljs-title function_">load</span>(yamlContent) <span class="hljs-keyword">as</span> <span class="hljs-title class_">MRReview</span>;
</code></pre>
<p>至此，你已经得到一份经过 LLM 分析后产生的实例化的数据了</p>
<h4 data-id="heading-39">异常处理</h4>
<p>但是你以为到这里就结束了吗？实际的情况却是 LLM 会因为它的黑盒性和不确定性，偶然的输出一些奇奇怪怪的字符或格式，导致出现解析的异常。</p>
<h5 data-id="heading-40">场景1：多余的 '\n' 符号</h5>
<p>有时候 LLM 在输出的时候，会给 type 字段多加一个 '\n' 符号</p>
<pre><code class="hljs language-tsx" lang="tsx">{
  <span class="hljs-attr">newPath</span>: <span class="hljs-string">"src/agent/agent.service.ts"</span>,
  <span class="hljs-attr">oldPath</span>: <span class="hljs-string">"src/agent/agent.service.ts"</span>,
  <span class="hljs-attr">startLine</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">endLine</span>: <span class="hljs-number">12</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">"new\n"</span>
  ....
}
</code></pre>
<p>看日志的时候，感觉一直没问题。可是到一些具体场景判断的时候，就会开始怀疑人生。当时一些关于 type 的判断，我想破脑袋也没想明白为什么 new 会走到 old 的逻辑里面，结果仔细一看，还有一个换行符……</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ded14e6b00cc4d528fb64096426c3477~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=FVDF4yr53FPjPriNcyNCMZxHH5E%3D" alt="" loading="lazy"></p>
<p>所以针对这个场景，需要单独加一些处理逻辑。通过 replace 把字符串中的换行符全部去掉。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e3b8b4e67d64dbdaf9e141818de2c88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=UfgKaWmewQKGVA3gZHmefgDRPaM%3D" alt="" loading="lazy"></p>
<h5 data-id="heading-41">场景2：多余的空格符号</h5>
<p>我们知道 yaml 的字段结构是按空格来控制的，但有时候 LLM 偏偏就在某些字段前面少一个或者多个空格，排查的时候也是非常的头痛，例如下面的 issueHeader、issueContent 因为少了空格，而导致 yaml 解析异常…</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23920e47a2414b14af082ac00cf8eab2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=ooK2Mya893xhSPwafWEd6%2F%2B0EM8%3D" alt="" loading="lazy"></p>
<p>我的办法就是让 AI 写了一个兜底处理方法。在解析异常的时候，通过兜底方法再解析一次。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent%2Fblob%2Fmain%2Fsrc%2Fagent%2Futils.ts" target="_blank" title="https://github.com/zixingtangmouren/mr-agent/blob/main/src/agent/utils.ts" ref="nofollow noopener noreferrer">具体代码</a>（查看里面的 fixYamlFormatIssues 方法）</p>
<h5 data-id="heading-42">更多场景</h5>
<p>因为 LLM 偶现的不稳定性，会导致出现各种奇奇怪怪的问题。目前的解决思路有三个：</p>
<ol>
<li>使用更强大的模型，并调低 temperature 参数</li>
<li>调试出更完善的提示词，通过加限制、加示例等技巧，提高提示词的准确性</li>
<li>特殊场景，特殊手段。例如通过编码等手段，提前防范这些异常</li>
</ol>
<h3 data-id="heading-43">5.8 上下文分割</h3>
<p>还有一个需要解决的问题就 LLM 的上下文长度的限制。像 GPT-4.1 上下文长度有 100w 个 token，但是你用 deepseek 的话，可能只有 64000 个。</p>
<p>一旦你输入的提示词 + diff 内容超过这个上下文，就会报错导致 LLM 无法正常解析。这时我们就不得不把输入的 diff 拆分成多份，然后并行调用 LLM，最后整合数据。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38526051e53e4bad932f4b989d28ddf6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=HLbUaZj0edEpMKhfhbi1RwOemao%3D" alt="画板" loading="lazy"></p>
<p>解决这个问题的思路也很简单，每次调用 LLM 前，计算一下系统提示词 + Diff 内容需要消耗的 token，如果超了就把 diff 多差几份。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { encoding_for_model, <span class="hljs-title class_">TiktokenModel</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@dqbd/tiktoken'</span>;

 <span class="hljs-keyword">const</span> encoding = <span class="hljs-title function_">encoding_for_model</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">modelName</span>);
 <span class="hljs-keyword">const</span> tokens = encoding.<span class="hljs-title function_">encode</span>(text);
 <span class="hljs-keyword">const</span> count = tokens.<span class="hljs-property">length</span>;
 encoding.<span class="hljs-title function_">free</span>();
</code></pre>
<p>我用的是 <code>@dqbd/tiktoken</code> 这个包计算 token，它里面包含了大多数模型的 token 计算方式。</p>
<h3 data-id="heading-44">5.9 发送结果</h3>
<p>在有了处理好的 review 数据以后，我们就可以调用 GitLab 的接口发送评论了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35dab9c64a90465eb5e3a038b64e1354~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=DqQKf0m26ocrMm3a%2FI2xZev2lgc%3D" alt="" loading="lazy"></p>
<p>从上面方法的入参可以看到，newPath、oldPath、endLine、issuceContent 等数据，都是在通过 LLM 分析以后得出来的。</p>
<h3 data-id="heading-45">5.10 小结</h3>
<p>至此，这个 AI Code Review 的关键流程，我已经讲完了。下面再来总结一下两个流程：</p>
<ul>
<li>逻辑流程</li>
<li>使用流程</li>
</ul>
<h4 data-id="heading-46">逻辑流程</h4>
<ul>
<li>部署 NodeJS 服务</li>
<li>开发 webhook 接口，接受 MR 事件</li>
<li>收到事件后，获取 Diff 内容</li>
<li>有了 Diff 内容后，扩展行号、文件路径，拼成一个字符串</li>
<li>进行 token 分析，超了就分多份进行分析</li>
<li>调用 LLM，输入系统提示词、Diff</li>
<li>拿到 YAML 结构的分析数据</li>
<li>解析数据、处理异常</li>
<li>发送评论到 GitLab</li>
</ul>
<h4 data-id="heading-47">使用流程</h4>
<ul>
<li>申请 access token</li>
<li>配置 webhook</li>
<li>发起 MR</li>
<li>收到 AI 分析的评论</li>
</ul>
<h2 data-id="heading-48">六、最后</h2>
<h3 data-id="heading-49">6.1 期待</h3>
<p>本篇给大家分享了一个 AI Code Review 应用开发的简单案例。我希望大家可以看完以后，可以在自己的业务或者个人项目中去实践落地，然后再回到评论区给与反馈，展示你的成果。</p>
<h3 data-id="heading-50">6.2 学习方法</h3>
<p>如果看到文章中有任何不懂的，我建议你都可以直接问 AI。我看掘金自带的这个 AI 助手也挺方便的。我们既然要学习 AI，就要多用 AI 的方式去学习。当然，你也可以直接留言问我。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2289a12652cc416cbcd32e103d99fd81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5p-Q5Lq65Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756858171&amp;x-signature=Mm2quGNqaRYHvK9aU8hWqqIBo1U%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-51">6.3 关注</h3>
<p>最后呢，也是希望大家关注我，我会持续在这个专栏更新我的文章。本想着坚持能够一个月输出两篇，但是在工作忙碌 + 文章质量的不断权衡中，还是写了很久，才写出这一篇。原创不易，需转载请私信我~</p>
<p>这个演示的项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzixingtangmouren%2Fmr-agent" target="_blank" title="https://github.com/zixingtangmouren/mr-agent" ref="nofollow noopener noreferrer">github.com/zixingtangm…</a> (可以的话，也帮忙点点 star ⭐️ 哈哈)</p></div></div>