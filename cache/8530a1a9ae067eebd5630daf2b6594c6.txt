
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youzhibing/p/18626711" title="发布于 2024-12-24 10:03">
    <span role="heading" aria-level="2">SpringBoot支持Kafka多源配置的同时还要支持启停配置化，是真的会玩</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="开心一刻">开心一刻</h2>
<p>今早，女朋友给我发微信<br><br>
她：宝贝，你要记住<br><br>
她：我可是你女朋友，你相亲就亲，想抱就抱<br><br>
她：不要老是问我，男生要主动一些<br><br>
我：可是你上次报警可不是这么说的<br></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740136-449271568.gif" alt="开心一刻" width="200"></div>
<h2 id="基础回顾">基础回顾</h2>
<p>Spring Boot 集成 Kafka 非常简单，我相信你们都会，但我还是想带你们回顾下；只需要进行以下几步即可完成 Spring Boot 与 Kafka 的集成</p>
<ol>
<li>
<p>引入依赖</p>
<p>如果只是单纯的集成，不考虑其他功能，那么添加如下依赖即可</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.18&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
        &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>Spring Boot 并没有提供 <code>starter</code> 的方式来集成 Kafka，不要一根筋的去找 starter</p>
</blockquote>
<p>如果还需要 <code>web</code> 功能，则可以像如下一样添加依赖</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.18&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
        &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>依赖就是如此简单；扯个题外问题</p>
<blockquote>
<p><code>spring-kafka</code> 的版本在哪指定的？</p>
</blockquote>
</li>
<li>
<p>添加配置</p>
<p>如果 Kafka 未开启认证，那配置可以非常简单</p>
<pre><code class="language-yaml">spring:
  kafka:
    bootstrap-servers: 192.168.0.87:9092,192.168.0.88:9092,192.168.0.89:9092
</code></pre>
<p>但实际使用中，往往会开启认证，并对 <code>consumer</code> 做定制化配置，配置往往类似如下</p>
<pre><code class="language-yam">spring:
  kafka:
    bootstrap-servers: 192.168.0.87:9092,192.168.0.88:9092,192.168.0.89:9092
    consumer:
      # 自动提交消费位移
      enable-auto-commit: false
      # 偏移量初始位置
      auto-offset-reset: latest
      # 一次拉取记录最大数
      max-poll-records: 5
      properties:
        security.protocol: SASL_PLAINTEXT
        sasl.mechanism: PLAIN
        #sasl.mechanism: SCRAM-SHA-256
        #username、password需要调整成实际值
        sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="username" password="password";
        #sasl.jaas.config: org.apache.kafka.common.security.scram.ScramLoginModule required username="username" password="password";
    listener:
      ack-mode: manual
    producer:
      properties:
        security.protocol: SASL_PLAINTEXT
        sasl.mechanism: PLAIN
        #sasl.mechanism: SCRAM-SHA-256
        #username、password需要调整成实际值
        sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="username" password="password";
        #sasl.jaas.config: org.apache.kafka.common.security.scram.ScramLoginModule required username="username" password="password";  
</code></pre>
<p>也不复杂，相信你们都能看懂</p>
</li>
<li>
<p>进行使用</p>
<p>分两点：<code>消费消息</code> 和 <code>发送消息</code></p>
<p><code>消费消息</code> 实现很简单</p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@Component
public class KafkaConsumer {

    private static final Logger log = LoggerFactory.getLogger(KafkaConsumer.class);

    @KafkaListener(topics = "tp_qsl_order_cancel", groupId = "gid_qsl_order_cancel")
    public void listenOrder(String message, Acknowledgment acknowledgment) {
        try {
            log.info("收到kafka message: {}", message);
            // TODO 业务处理
        } finally {
            acknowledgment.acknowledge();
        }
    }
}
</code></pre>
<p>监听的 <code>topic</code> 是 <code>tp_qsl_order_cancel</code>，消费者组指定为 <code>gid_qsl_order_cancel</code>；这样，消费监听就算完成了</p>
<p><code>发送消息</code> 实现同样简单，注入 <code>KafkaTemplate</code>，然后调用其 <code>send</code> 方法即可</p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@Component
public class KafkaSender {

    private static final Logger log = LoggerFactory.getLogger(KafkaSender.class);

    @Resource
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    public void send(String topic, String msg) {
        kafkaTemplate.send(topic, msg).addCallback(
                success -&gt; {
                    if (success != null) {
                        log.info("消息发送成功: Topic={}, Partition={}, Offset={}",
                                success.getRecordMetadata().topic(), success.getRecordMetadata().partition(), success.getRecordMetadata().offset());
                    }
                },
                failure -&gt; {
                    log.error("消息发送失败：", failure.getCause());
                }
        );
    }
}
</code></pre>
<p>KafkaTemplate 提供了多个 send 方法</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739658-728758546.png" alt="KafkaTemplate_send方法"></div>
<p>我们可以按需选择</p>
</li>
</ol>
<p>上面 3 步都完成后，即可启动应用进行测试了</p>
<ol>
<li>
<p>消费消息</p>
<p>这个测试很简单，直接往 <code>tp_qsl_order_cancel</code> topic 中发送一条消息即可</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739703-1678126859.png" alt="发送消息"></div>
<p>点击 <code>发送消息</code> 后，控制台输出</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739403-1421974330.png" alt="消费者日志"></div>
<p>消息正常消费，没有任何毛病</p>
</li>
<li>
<p>发送消息</p>
<p>我加了一个 <code>OrderController</code></p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@RestController
@RequestMapping("order")
public class OrderController {

    @Resource
    private KafkaSender kafkaSender;

    @GetMapping("add")
    public String add(String orderInfo) {
        // TODO 订单业务处理
        // 下发消息到库存
        kafkaSender.send("tp_qsl_inventory_order_add", orderInfo);
        return "下单成功";
    }
}
</code></pre>
<p>便于测试消息发送；直接发起 <code>http</code> 请求</p>
<pre><code class="language-http">http://localhost:8080/order/add?orderInfo=订单完整信息
</code></pre>
<p>然后就可以去 <code>tp_qsl_inventory_order_add</code> topic 中看消息是否发送成功</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739458-208941582.png" alt="消息发送成功"></div>
<p>消息正常发送，也没有任何毛病</p>
</li>
</ol>
<p>至此，Spring Boot 集成 Kafka 就算大功告成了；如此简单，相信你们都能轻松拿捏</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739420-795440033.jpg" alt="拿捏"></div>
<h2 id="kafka-多源">Kafka 多源</h2>
<p>上述只讲了单 Kafka 源的情况，也就是 <code>消费消息</code> 与 <code>发送消息</code> 针对的是同个 Kafka 源；但实际工作中，同个项目连接多个 Kafka 源的情况是非常常见的，我们就以 2 个 Kafka 源为例，从其中一个源消费消息、向另一个源发送消息，该如何实现？其实也不难，按以下几步调整即可</p>
<ol>
<li>
<p>配置文件调整</p>
<p>既然有 2 个 Kafka 源，那么我们的配置文件就需要配置 2 个，类似如下</p>
<pre><code class="language-yaml">spring:
  kafka:
    first:
      bootstrap-servers: 192.168.0.87:9092,192.168.0.88:9092,192.168.0.89:9092
      consumer:
        # 自动提交消费位移
        enable-auto-commit: false
        # 偏移量初始位置
        auto-offset-reset: latest
        # 一次拉取记录最大数
        max-poll-records: 5
        # properties:
          # security.protocol: SASL_PLAINTEXT
          # sasl.mechanism: PLAIN
          #sasl.mechanism: SCRAM-SHA-256
          #username、password需要调整成实际值
          # sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="username" password="password";
          #sasl.jaas.config: org.apache.kafka.common.security.scram.ScramLoginModule required username="username" password="password";
      listener:
        ack-mode: manual
    second:
      bootstrap-servers: 192.168.0.90:9092
      #producer:
        #properties:
          #security.protocol: SASL_PLAINTEXT
          #sasl.mechanism: PLAIN
          #sasl.mechanism: SCRAM-SHA-256
          #username、password需要调整成实际值
          #sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="username" password="password";
          #sasl.jaas.config: org.apache.kafka.common.security.scram.ScramLoginModule required username="username" password="password";
</code></pre>
<p>这里的 <code>first</code> 和 <code>second</code> 不是固定的，你们想怎么命名就怎么命名；既然这么灵活，那 Spring Boot 肯定是不支持的，那么如上配置，Spring Boot 是识别不了的，相当于没配，此时去启动应用，Spring Boot 会启用默认配置去连接 <code>localhost:9092</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739886-1039566271.png" alt="默认连接localhost的kafka"></div>
<p>所以我们需要自定义配置 Kafka，而一旦我们进行了自定义，那么 Spring Boot 则不会启用默认配置</p>
</li>
<li>
<p>自定义配置 Kafka</p>
<p>针对每个 Kafka 源单独配置，配置内容比较固定</p>
<ol>
<li>
<p>FirstKafkaConfig</p>
<pre><code class="language-java">/**
 * 第一个Kafka配置
 * @author: 青石路
 */
@Configuration
public class FirstKafkaConfig {

    @ConfigurationProperties(prefix = "spring.kafka.first")
    @Bean("firstKafkaProperties")
    public KafkaProperties firstKafkaProperties() {
        return new KafkaProperties();
    }

    @Bean("firstKafkaTemplate")
    public KafkaTemplate&lt;String, String&gt; firstKafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(firstProducerFactory());
    }

    @Bean("firstKafkaListenerContainerFactory")
    public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; fisrtKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(firstConsumerFactory());
        factory.getContainerProperties().setAckMode(firstKafkaProperties().getListener().getAckMode());
        return factory;
    }

    @Bean("firstConsumerFactory")
    public ConsumerFactory&lt;String, String&gt; firstConsumerFactory() {
        return new DefaultKafkaConsumerFactory&lt;&gt;(firstKafkaProperties().buildConsumerProperties());
    }

    @Bean("firstProducerFactory")
    public DefaultKafkaProducerFactory&lt;String, String&gt; firstProducerFactory() {
        return new DefaultKafkaProducerFactory&lt;&gt;(firstKafkaProperties().buildProducerProperties());
    }
}
</code></pre>
</li>
<li>
<p>SecondKafkaConfig</p>
<pre><code class="language-java">/**
 * 第二个Kafka配置
 * @author: 青石路
 */
@Configuration
public class SecondKafkaConfig {

    @ConfigurationProperties(prefix = "spring.kafka.second")
    @Bean("secondKafkaProperties")
    public KafkaProperties secondKafkaProperties() {
        return new KafkaProperties();
    }

    @Bean("secondKafkaTemplate")
    public KafkaTemplate&lt;String, String&gt; secondKafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(secondProducerFactory());
    }

    @Bean("secondKafkaListenerContainerFactory")
    public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; fisrtKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(secondConsumerFactory());
        return factory;
    }

    @Bean("secondConsumerFactory")
    public ConsumerFactory&lt;String, String&gt; secondConsumerFactory() {
        return new DefaultKafkaConsumerFactory&lt;&gt;(secondKafkaProperties().buildConsumerProperties());
    }

    @Bean("secondProducerFactory")
    public DefaultKafkaProducerFactory&lt;String, String&gt; secondProducerFactory() {
        return new DefaultKafkaProducerFactory&lt;&gt;(secondKafkaProperties().buildProducerProperties());
    }
}
</code></pre>
</li>
</ol>
<p>重点在</p>
<blockquote>
<p>@ConfigurationProperties(prefix = "spring.kafka.first")</p>
<p>@ConfigurationProperties(prefix = "spring.kafka.second")</p>
</blockquote>
<p>多源之间不要配重、不要配混</p>
</li>
<li>
<p>调整消息监听与消息发送</p>
<p>因为配置了多源，那么 <code>KafkaListenerContainerFactory</code> 也对应配置了多个，所以我们要指定用哪个 KafkaListenerContainerFactory 来创建消息监听器</p>
<pre><code class="language-java">@KafkaListener(topics = "tp_qsl_order_cancel", groupId = "gid_qsl_order_cancel")

// 调整成

@KafkaListener(topics = "tp_qsl_order_cancel", groupId = "gid_qsl_order_cancel", containerFactory = "firstKafkaListenerContainerFactory")
</code></pre>
<p><code>消费消息</code> 端就算调整完成；同理，<code>KafkaTemplate</code> 也配置了多个，那么发送消息的时候也需要指定用哪个 KafkaTemplate 来发送</p>
<pre><code class="language-java">@Resource
private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

// 调整成

private KafkaTemplate&lt;String, String&gt; kafkaTemplate;
@Autowired
@Qualifier("secondKafkaTemplate")
public void setKafkaTemplate(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
    this.kafkaTemplate = kafkaTemplate;
}
</code></pre>
<p><code>发送消息</code> 端也就调整完成</p>
</li>
</ol>
<p>都调整完成后，我们启动应用，会发现启动失败，并提示如下信息</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740087-1083441269.png" alt="多源启动报错" width="90%"></div>
<p>这特喵的，跟预想的不一样吖</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740003-1140143842.png" alt="成龙_what"></div>
<p>遇到问题先不要慌，我们仔细看下提示信息，我给你们翻译一下</p>
<blockquote>
<p>KafkaAnnotationDrivenConfiguration 构造方法需要一个 KafkaProperties 实例，但在 Spring 容器中找到了 3 个，它懵圈了，不知道该使用哪一个</p>
<p>可以通过 @Primary 提高实例的优先级，或者使用 @Qualifier 明确指定使用哪个实例</p>
</blockquote>
<p>所以处理方式就来了，使用 @Primary 来提高某个 KafkaProperties 实例的优先级，KafkaAnnotationDrivenConfiguration 就不会懵圈了，会使用优先级高的 KafkaProperties 实例</p>
<blockquote>
<p>因为 KafkaAnnotationDrivenConfiguration 不是我们写的，没法通过 @Qualifier 明确指定</p>
</blockquote>
<p>我们直接提高 <code>firstKafkaProperties</code> 的优先级</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = "spring.kafka.first")
@Bean("firstKafkaProperties")
@Primary
public KafkaProperties firstKafkaProperties() {
    return new KafkaProperties();
}
</code></pre>
<p>再启动应用，发现正常启动了；你们就可以进行 <code>消费消息</code> 和 <code>发送消息</code> 测试了，我就不演示了，反正我测试都是通过的，不信？不信就不信，你能把我怎么样嘛</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740189-1893278539.gif" alt="来打我呀"></div>
<h2 id="启停配置化">启停配置化</h2>
<p>Kafka 不管是单源还是多源，应用进行集成，都是非常合理的需求，我们开发做对应的实现也是应该的；但如下这个需求我多少是有点抵触的</p>
<blockquote>
<p>客户方的环境有诸多约束、限制，权限管控非常严，还有各种防火墙，需要各种申请流程，非常耗时；项目分多个应用，应用之间存在交互（Kafka 是方式之一），每个应用的交付时间不一样，自然在客户环境的演示时间也不一样，所以为了演示不受 Kafka 的限制，需要给每个 Kafka 源增加一个开关配置，通过开关来分别控制每个 Kafka 源的启停</p>
</blockquote>
<p>这里的启停指的是 <code>启用</code> 与 <code>停用</code>；演示的时候，哪些 Kafka 源能正常使用就启用这些，哪些还不能使用就停用哪些，同时业务代码中也需要做适配调整。面对这个需求，你们说是不是不合理？所以你们能理解我的抵触了吧。但为了更好的演示，给甲方爸爸留下专业的印象，增加开关貌似是当下最合适的无奈之选，极不情愿的开启改造之旅</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095742009-412171911.gif" alt="极不情愿"></div>
<ol>
<li>
<p>增加开关配置</p>
<p>在配置文件中增加开关配置，每个 Kafka 源有其独立的配置，有几个源就配置几个开关</p>
<pre><code class="language-yaml">spring:
  kafka:
    first:
      enabled: true
      ...
    second:
      enabled: true
      ...
</code></pre>
<p><code>enabled</code> 配置成 <code>true</code> 表示启用，<code>false</code> 表示停用</p>
</li>
<li>
<p>自定义配置适配开关</p>
<p>需要根据开关值来决定是否启用 <code>FirstKafkaConfig</code> 和 <code>SecondKafkaConfig</code>，Spring Boot 正好提供了一个具有该功能的注解：<code>ConditionalOnProperty</code>，直接安排上</p>
<pre><code class="language-java">/**
 * 第一个Kafka配置
 * @author: 青石路
 */
@Configuration
@ConditionalOnProperty(name = "spring.kafka.first.enabled", havingValue = "true")
public class FirstKafkaConfig {
    ...

/**
 * 第二个Kafka配置
 * @author: 青石路
 */
@Configuration
@ConditionalOnProperty(name = "spring.kafka.second.enabled", havingValue = "true")
public class SecondKafkaConfig {
    ...
</code></pre>
<p>这样就实现了通过开关来 <code>启停</code> Kafka 源</p>
</li>
<li>
<p>消费消息与发送消息适配开关</p>
<p>消费端适配很简单</p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@Component
@ConditionalOnProperty(name = "spring.kafka.first.enabled", havingValue = "true")
public class KafkaConsumer {
    ...
</code></pre>
<p>发送端适配则有点不一样，方式有多种，我提供一种；修改 KafkaSender，改 2 处即可</p>
<p>KafkaTemplate 调整成非强制依赖，将 <code>@Autowired</code> 的 <code>required</code> 设置成 false</p>
<pre><code class="language-java">@Autowired
@Qualifier("secondKafkaTemplate")
public void setKafkaTemplate(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
    this.kafkaTemplate = kafkaTemplate;
}

// 调整成

@Autowired(required = false)
@Qualifier("secondKafkaTemplate")
public void setKafkaTemplate(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
    this.kafkaTemplate = kafkaTemplate;
}
</code></pre>
<p>使用 KafkaTemplate 时做 null 判断</p>
<pre><code class="language-java">public void send(String topic, String msg) {
    kafkaTemplate.send(topic, msg).addCallback(
            success -&gt; {
                if (success != null) {
                    log.info("消息发送成功: Topic={}, Partition={}, Offset={}",
                            success.getRecordMetadata().topic(), success.getRecordMetadata().partition(), success.getRecordMetadata().offset());
                }
            },
            failure -&gt; {
                log.error("消息发送失败：", failure.getCause());
            }
    );
}

// 调整成

public void send(String topic, String msg) {
    if (kafkaTemplate == null) {
        log.warn("未启用secondKafka，不发送消息");
        return;
    }
    kafkaTemplate.send(topic, msg).addCallback(
            success -&gt; {
                if (success != null) {
                    log.info("消息发送成功: Topic={}, Partition={}, Offset={}",
                            success.getRecordMetadata().topic(), success.getRecordMetadata().partition(), success.getRecordMetadata().offset());
                }
            },
            failure -&gt; {
                log.error("消息发送失败：", failure.getCause());
            }
    );
}
</code></pre>
</li>
</ol>
<p>至此改造就算完成；开关都为 <code>true</code> 的情况下，效果与未加开关前的多源是一致的，也就是正常的，我已经测过了，你们不放心的话自己再去测试一下；开关都为 <code>false</code> 时，相当于没注册消费监听器，也就相当于没有消费者，那么往 <code>tp_qsl_order_cancel</code> topic 中发消息，是没有消费者消费消息的，那么控制台就不会有任何输出，同理，此时的 <code>KafkaTemplate</code> 是没有注册成功的（也就是 null），发起 http 请求</p>
<pre><code class="language-http">http://localhost:8080/order/add?orderInfo=大订单
</code></pre>
<p>控制台输出如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739957-159645192.png" alt="启停配置化_都停用_发送消息日志" width="90%"></div>
<p>正是我们想要的效果，说明都为 <code>false</code> 的情况也是正确的；接下来我们看下 <code>false、true</code> 的情况</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740355-262186846.png" alt="启停配置化_启动失败" width="90%"></div>
<p>好家伙，直接启动失败！但这个问题我们前面碰到过，那么如何处理呢？用 <code>@Primary</code> 标记 <code>secondKafkaProperties</code> ？假设我们这么做了，那开关都为 <code>true</code> 的情况下，<code>KafkaProperties</code> 实例岂不是有多个 <code>Primary</code>，Spring Boot 又会懵圈，不知道该使用哪个 KafkaProperties 实例，显然这种方式行不通；我们把问题拓展下，多个 KafkaProperties 实例存在的情况下，需要动态指定一个 Primary，但不能是 Spring Boot 自动配置的那个，即</p>
<blockquote>
<p>spring.kafka-org.springframework.boot.autoconfigure.kafka.KafkaProperties</p>
</blockquote>
<p>除了这个，随便给哪个 KafkaProperties 实例指定成 Primary 都是没问题的，因为我们的业务代码中都明确指定了使用的是我们自定义的 kafka，所以我们需要在 Bean 实例化之前修改某个 KafkaProperties 的 <code>BeanDefinition</code>，设置其 Primary 为 true；实现方式有很多，我这里提供一种：<code>BeanFactoryPostProcessor</code></p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@Component
public class KafkaPrimaryProcessor implements BeanFactoryPostProcessor {

    private static final Logger log = LoggerFactory.getLogger(KafkaPrimaryProcessor.class);

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        String[] beanNames = beanFactory.getBeanNamesForType(KafkaProperties.class);
        if (beanNames.length &lt;= 1) {
            return;
        }
        for (String beanName : beanNames) {
            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
            // springboot的自动配置
            if (beanName.contains(KafkaProperties.class.getName())) {
                continue;
            }
            log.info("多KafkaProperties，指定primary[{}]", beanName);
            beanDefinition.setPrimary(true);
            return;
        }
    }
}
</code></pre>
<p>这个代码相信你们都能看懂，会从多个 KafkaProperties BeanDefinition 中取第一个（除了自动配置的），设置其 Primary 为 true，所以我们还需要调整下 <code>firstKafkaProperties</code>，拿掉其 <code>@Primary</code></p>
<pre><code class="language-java">@ConfigurationProperties(prefix = "spring.kafka.first")
@Bean("firstKafkaProperties")
@Primary
public KafkaProperties firstKafkaProperties() {
    return new KafkaProperties();
}

// 调整成

@ConfigurationProperties(prefix = "spring.kafka.first")
@Bean("firstKafkaProperties")
public KafkaProperties firstKafkaProperties() {
    return new KafkaProperties();
}
</code></pre>
<p>这么调整之后，无论是有几个 Kafka 源，以及如何启停这些源，都能正常运转，是不是很优秀，值得鼓掌！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739954-143910598.png" alt="愣着干啥，鼓掌" width="200px"></div>
<p>话说，需求至此已经算完美实现了，可以完结了，但作为一个开发，尤其是一个有追求的开发，还有一个疑点未得到解决，心里始终不舒坦，是什么疑点呢，我们继续往下看</p>
<h2 id="排除自动配置">排除自动配置</h2>
<p>既然是我们自定义配置 Kafka，不再依赖 Spring Boot 的自动配置，我们是不是可以排除掉 Spring Boot 的 Kafka 自动配置？理论上来说是可行的，那就干呗；直接排除掉 <code>KafkaAutoConfiguration.class</code></p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@SpringBootApplication(exclude = {KafkaAutoConfiguration.class})
public class KafkaApplication {

    public static void main(String[] args) {
        SpringApplication.run(KafkaApplication.class, args);
    }
}
</code></pre>
<p>既然排除了自动配置，那么也就不需要指定 KafkaProperties 的 Primary 了，<code>KafkaPrimaryProcessor</code> 直接删掉，其他不用调整；将开关都设置成 <code>true</code>，我们启动应用后测试下</p>
<ol>
<li>
<p>发送消息</p>
<p>直接 http 请求</p>
<pre><code class="language-http">http://localhost:8080/order/add?orderInfo=排除自动配置
</code></pre>
<p>日志显示发送成功</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740129-1837112158.png" alt="排除自动配置_发送消息日志"></div>
<p>我们在看下 Topic <code>tp_qsl_inventory_order_add</code> 中消息</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740279-1152042654.png" alt="排除自动配置_发送消息_topic中消息"></div>
<p>发送消息是没问题的</p>
</li>
<li>
<p>消费消息</p>
<p>往 Topic <code>tp_qsl_order_cancel</code> 中发送消息</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740206-1823756315.png" alt="排除自动配置_消费消息_topic中写消息"></div>
<p>点击 <code>发送消息</code> 后，发现控制台并没有任何输出！！！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739911-2109538506.jpg" alt="芭比Q了"></div>
<p>先别慌，我们冷静分析下，控制台没有任何输出说明消费者没注册成功，也就是 <code>@KafkaListener</code> 没生效，为什么没生效，肯定是没有被解析，谁解析它呢，KafkaListener 中应该有说明</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739991-149726486.png" alt="KafkaListener 描述"></div>
<p>已经描述的很清楚</p>
<blockquote>
<p>通过注册 KafkaListenerAnnotationBeanPostProcessor 来处理 KafkaListener 注解</p>
<p>可以手动注册 KafkaListenerAnnotationBeanPostProcessor，也可以通过 EnableKafka 注解来注册</p>
</blockquote>
<p><code>EnableKafka </code> 方便点，我们使用它</p>
<pre><code class="language-java">/**
 * @author: 青石路
 */
@SpringBootApplication(exclude = {KafkaAutoConfiguration.class})
@EnableKafka
public class KafkaApplication {

    public static void main(String[] args) {
        SpringApplication.run(KafkaApplication.class, args);
    }
}
</code></pre>
<p>重新启动应用，会发现控制台有如下输出</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095740350-553817680.png" alt="EnableKafka"></div>
<p>消费消息也正常了；因为重启应用了，保险起见，发送消息最好再测一次，记得测！！！</p>
</li>
</ol>
<p>至此，心中疑点得以解决，如此才算完美解决！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241224095739978-1648477640.gif" alt="一脸得意"></div>
<blockquote>
<p>Tips：</p>
<p>跟进 KafkaAutoConfiguration，它有如下代码</p>
<pre><code class="language-java">@Import({ KafkaAnnotationDrivenConfiguration.class, KafkaStreamsAnnotationDrivenConfiguration.class })
</code></pre>
<p>跟进 KafkaAnnotationDrivenConfiguration，其最下面有如下代码</p>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
@EnableKafka
@ConditionalOnMissingBean(name = KafkaListenerConfigUtils.KAFKA_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
static class EnableKafkaConfiguration {

}
</code></pre>
<p>这里使用了 <code>@EnableKafka</code>，这也是为什么自动配置（<code>KafkaAutoConfiguration</code>）能解析 <code>@KafkaListener</code> 的答案！</p>
</blockquote>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>Kafka 多源实现，大家需要掌握，至于启停配置化，大家就当看个热闹</p>
<p>但是启停配置化的实现（<code>@ConditionalOnProperty</code>），还是值得大家掌握的</p>
<p>Spring Boot 的条件注解非常多，在 Spring Boot 内部被广泛使用，感兴趣的可以查看：<a href="https://www.cnblogs.com/youzhibing/p/9692091.html" target="_blank">spring-boot-2.0.3源码篇 - @Configuration、Condition与@Conditional</a></p>
</li>
<li>
<p>如果不使用Spring Boot的自动配置，建议把对应的自动配置类排除掉</p>
<p><code>自动配置</code> 与 <code>手动配置</code> 同时存在的话可能会产生冲突，就像文中的 <code>KafkaProperties </code> 多实例；直接排除可能会导致缺少某些功能，肯定是没有启用这些功能的依赖，细心去寻找依赖并启用即可</p>
</li>
<li>
<p>完整代码：<a href="https://gitee.com/youzhibing/qsl-project/tree/master/spring-boot-kafka" target="_blank" rel="noopener nofollow">spring-boot-kafka</a></p>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02986726125810185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 10:03">2024-12-24 10:03</span>&nbsp;
<a href="https://www.cnblogs.com/youzhibing">青石路</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18626711" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18626711);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18626711', targetLink: 'https://www.cnblogs.com/youzhibing/p/18626711', title: 'SpringBoot支持Kafka多源配置的同时还要支持启停配置化，是真的会玩' })">举报</a>
</div>
        