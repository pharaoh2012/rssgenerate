
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vigourice/p/18739728" title="发布于 2025-03-02 23:09">
    <span role="heading" aria-level="2">使用Node.js打造交互式脚手架，简化模板下载与项目创建</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在上一篇<a href="https://www.cnblogs.com/vigourice/p/18622383" target="_blank">文章</a>中，我们探讨了如何构建一个通用的脚手架框架。今天，我们将在此基础上进一步扩展脚手架的功能，赋予它下载项目模板的能力。</p>
<p>通常情况下，我们可以将项目模板发布到 <code>npm</code> 上，或者在公司内部利用私有 <code>npm</code> 仓库进行托管。通过交互式命令行界面，开发者可以轻松选择项目类型、项目名称以及所需的项目模板。脚手架将自动下载并生成对应的项目结构，为开发者提供便捷的项目初始化体验。</p>
<p>本文的内容基于上一篇文章中定义的基础脚手架。简单回顾一下目录结构：在 <code>ice-basic-cli</code> 项目中，存在一个 <code>packages</code> 文件夹，其中包含 4 个子包。<code>cli</code> 文件夹存放与命令行相关的内容，<code>command</code> 文件夹封装了 commander 类，<code>init</code> 文件夹包含了初始化 init 指令的实现，而 <code>utils</code> 文件夹则涵盖了工具函数和方法。</p>
<h1 id="获取项目创建类型">获取项目创建类型</h1>
<p>首先，我们需要获取用户需要创建的项目类型。例如，用户可能需要基于 <code>React</code> 框架的模板，或者是 <code>Vue</code> 的模板；是 PC 端的项目，还是 H5 端的项目。这些信息都需要通过问答的形式让用户选择。</p>
<p>在命令行工具中实现问答交互，我们可以使用 <code>inquirer</code> 库。在 <code>packages/utils </code>子包中新增 <code>inquirer.js</code> 文件，对 <code>inquirer</code> 进行封装，并导出上下键盘筛选和输入方法。</p>
<pre><code class="language-javascript">import inquirer from "inquirer";
function make({
&nbsp; choices,
&nbsp; defaultValue,
&nbsp; message = "请选择",
&nbsp; type = "list",
&nbsp; require = true,
&nbsp; mask = "*",
&nbsp; validate,
&nbsp; pageSize,
&nbsp; loop,
}) {
&nbsp; const options = {
&nbsp; &nbsp; name: "name",
&nbsp; &nbsp; default: defaultValue,
&nbsp; &nbsp; message,
&nbsp; &nbsp; type,
&nbsp; &nbsp; require,
&nbsp; &nbsp; mask,
&nbsp; &nbsp; validate,
&nbsp; &nbsp; pageSize,
&nbsp; &nbsp; loop,
&nbsp; };
&nbsp; if (type === "list") {
&nbsp; &nbsp; options.choices = choices;
&nbsp; }
&nbsp; return inquirer.prompt(options).then((answer) =&gt; answer.name);
}

export function makeList(params) {
&nbsp; return make({ ...params });
}
</code></pre>
<p>在同层级的&nbsp;index.js&nbsp;文件中，将需要使用的&nbsp;<code>makeList</code>&nbsp;方法导出。</p>
<pre><code class="language-javascript">import { makeList } from "./inquirer.js";
export {
&nbsp; makeList,
};
</code></pre>
<p>接下来，我们在&nbsp;packages/init/lib&nbsp;文件夹下创建&nbsp;<code>createTemplate.js</code>&nbsp;文件，用于获取项目创建类型。用户可以根据需要选择是创建项目还是创建页面。</p>
<pre><code class="language-javascript">import { makList } from "@ice-basic-cli/utils";
const ADD_TYPE_PROJECT = "project";
const ADD_TYPE_PAGE = "page";
const ADD_TYPE = [
&nbsp; {
&nbsp; &nbsp; name: "项目",
&nbsp; &nbsp; value: ADD_TYPE_PROJECT,
&nbsp; },
&nbsp; {
&nbsp; &nbsp; name: "页面",
&nbsp; &nbsp; value: ADD_TYPE_PAGE,
&nbsp; },
];
function getAddType() {
&nbsp; return makList({
&nbsp; &nbsp; choices: ADD_TYPE,
&nbsp; &nbsp; message: "请选择初始化类型",
&nbsp; &nbsp; defaultValue: ADD_TYPE_PROJECT,
&nbsp; });
}
export default async function createTemplate() {
&nbsp; const addType = await getAddType();
}
</code></pre>
<p>接下来，我们在&nbsp;init.js&nbsp;文件中引入&nbsp;<code>createTemplate</code>&nbsp;方法。</p>
<pre><code class="language-javascript">import createTemplate from "./createTemplate.js";

async action() {
&nbsp; &nbsp; await createTemplate()
}
</code></pre>
<p>当用户执行&nbsp;<code>npx @ice-basic-cli/cli</code>&nbsp;命令时，<code>init</code> 文件中的 <code>action</code> 方法会被执行，触发交互式问答流程，用户可以根据提示选择初始化类型（例如创建项目或页面）。</p>
<h1 id="获取项目名称及项目模板">获取项目名称及项目模板</h1>
<p>接下来，我们需要用户输入新建项目的名称。首先，在 <code>utils/lib/inquirer.js</code> 文件中定义 <code>makeInput</code> 方法并导出，用于封装输入项。</p>
<pre><code class="language-javascript">export function makeInput(params) {
&nbsp; return make({
&nbsp; &nbsp; type: "input",
&nbsp; &nbsp; ...params,
&nbsp; });
}
</code></pre>
<p>再次回到 <code>packages/init/lib/createTemplate.js</code> 文件中，定义输入项目名称的函数。如果用户在上一步选择了“项目”作为初始化类型，则进行下一步的输入项目名称操作。</p>
<pre><code class="language-javascript">import { makeList, makeInput } from "@ice-basic-cli/utils";
function getAddName() {
&nbsp; return makeInput({
&nbsp; &nbsp; message: "请输入项目名称",
&nbsp; &nbsp; defaultValue: "",
&nbsp; &nbsp; validate: (v) =&gt; {
&nbsp; &nbsp; &nbsp; if (v.length &gt; 0) return true;
&nbsp; &nbsp; &nbsp; return "项目名称必填";
&nbsp; &nbsp; },
&nbsp; });
}

export default async function createTemplate() {
&nbsp; const addType = await getAddType();
&nbsp; if (addType === ADD_TYPE_PROJECT) {
&nbsp; &nbsp; const addName = await getAddName();
&nbsp; }
}
</code></pre>
<p>完成项目名称输入后，紧接着让用户选择项目模板，比如 <code>React</code> 或 <code>Vue</code> 模板。这些模板应在 <code>npm</code> 上可查询且可下载。在使用之前，请确保已将自己的模板上传至<code>npm</code> 仓库。</p>
<p>这里以两个示例模板为例，它们是我之前上传到 npm 上的测试模板。在 <code>packages/init/lib/createTemplate.js</code> 中定义选择模板的代码如下：</p>
<pre><code class="language-javascript">const ADD_TEMPLATE = [
&nbsp; {
&nbsp; &nbsp; name: "vue3项目模板",
&nbsp; &nbsp; value: "vue-template",
&nbsp; &nbsp; npmName: "ice-ts-app",
&nbsp; &nbsp; version: "0.0.1",
&nbsp; },
&nbsp; {
&nbsp; &nbsp; name: "react项目模板",
&nbsp; &nbsp; value: "react-template",
&nbsp; &nbsp; npmName: "table-brush-copy",
&nbsp; &nbsp; version: "1.0.1",
&nbsp; },
];

function getAddTemplate() {
&nbsp; return makeList({
&nbsp; &nbsp; choices: ADD_TEMPLATE,
&nbsp; &nbsp; message: "请选择项目模板",
&nbsp; });
}

export default async function createTemplate() {
&nbsp; const addType = await getAddType();
&nbsp; if (addType === ADD_TYPE_PROJECT) {
&nbsp; &nbsp; const addName = await getAddName();
&nbsp; &nbsp; const addTemplate = await getAddTemplate();
&nbsp; }
}
</code></pre>
<p>当你在命令行输入 <code>npx @ice-basic-cli/cli init</code> 指令后，程序会依次提出预设的问题，包括选择初始化类型、输入项目名称以及选择项目模板。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202502/1408181-20250226212216115-1095480111.png" alt="" loading="lazy"></p>
<h1 id="npm-api接入和封装">npm API接入和封装</h1>
<p>当用户完成了上述问答流程后，接下来我们可以通过 npm 来完成下载任务。首先，我们需要对 npm 的 API 进行一些封装以便于使用。</p>
<p>npm 提供了获取包信息的功能，通过访问 <code>https://registry.npmjs.org/${npmName}</code> 可以查看资源的最新版本、开发者信息、所需 Node 版本等详细信息。</p>
<p>例如，以 <code>@ice-basic-cli/cli</code> 为例，通过访问其 npm 页面可以看到最新版本号为 0.0.3。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202502/1408181-20250226212227706-1926925810.png" alt="" loading="lazy"></p>
<p>现在，我们将这一功能封装到代码中。在 packages/utils/lib 下创建一个名为 npm.js 的文件，并定义获取 npm 包信息和获取最新版本号的方法。考虑到国内访问 <code>https://registry.npmjs.org</code> 可能较慢，可以将其替换为淘宝镜像 <code>https://registry.npmmirror.com</code>。</p>
<pre><code class="language-javascript">import log from "./log.js";
import urlJoin from "url-join";
import axios from "axios";

function getNpmInfo(npmName) {
&nbsp; const registry = "https://registry.npmmirror.com/";
&nbsp; const url = urlJoin(registry, npmName);
&nbsp; return axios.get(url).then((response) =&gt; {
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; return response.data;
&nbsp; &nbsp; } catch (err) {
&nbsp; &nbsp; &nbsp; return Promise.reject(response);
&nbsp; &nbsp; }
&nbsp; });
}

export function getLatestVersion(npmName) {
&nbsp; return getNpmInfo(npmName).then((data) =&gt; {
&nbsp; &nbsp; if (!data["dist-tags"] || !data["dist-tags"].latest) {
&nbsp; &nbsp; &nbsp; log.error("没有 latest 版本号");
&nbsp; &nbsp; &nbsp; return Promise.reject(new Error("没有 latest 版本号"));
&nbsp; &nbsp; }
&nbsp; &nbsp; return data["dist-tags"].latest;
&nbsp; });
}
</code></pre>
<p>在同层级的 index.js 文件中导出 <code>getLatestVersion</code> 函数，以便其他模块调用。然后，在 packages/init/lib/createTemplate.js 文件中定义获取用户选择的 npm 包的最新版本号的逻辑。</p>
<pre><code class="language-javascript">import { getLatestVersion } from "@ice-basic-cli/utils";

export default async function createTemplate() {
&nbsp; const addType = await getAddType();
&nbsp; if (addType === ADD_TYPE_PROJECT) {
&nbsp; &nbsp; const addName = await getAddName();
&nbsp; &nbsp; const addTemplate = await getAddTemplate();
&nbsp; &nbsp; const selectedTemplate = ADD_TEMPLATE.find((_) =&gt; _.value === addTemplate);
&nbsp; &nbsp; const latestVersion = await getLatestVersion(selectedTemplate.npmName);
&nbsp; &nbsp; selectedTemplate.version = latestVersion;
&nbsp; }
}
</code></pre>
<h1 id="下载项目模板">下载项目模板</h1>
<p>在获取到用户选择的模板之后，我们需要建立缓存目录以下载 npm 包。这可以通过编辑 packages/init/lib/createTemplate.js 文件来实现。</p>
<pre><code class="language-javascript">import { homedir } from "node:os";
import path from "node:path";
const TEMP_HOME = ".ice-cli";

function makeTargetPath() {
&nbsp; return path.resolve(`${homedir()}/${TEMP_HOME}`);
}

export default async function createTemplate() {
&nbsp; const addType = await getAddType();
&nbsp; if (addType === ADD_TYPE_PROJECT) {
&nbsp; &nbsp; const addName = await getAddName();
&nbsp; &nbsp; const addTemplate = await getAddTemplate();
&nbsp; &nbsp; const selectedTemplate = ADD_TEMPLATE.find((_) =&gt; _.value === addTemplate);
&nbsp; &nbsp; const latestVersion = await getLatestVersion(selectedTemplate.npmName);
&nbsp; &nbsp; selectedTemplate.version = latestVersion;
&nbsp; &nbsp; const targetPath = makeTargetPath();
&nbsp; &nbsp; return {
&nbsp; &nbsp; &nbsp; type: addType,
&nbsp; &nbsp; &nbsp; name: addName,
&nbsp; &nbsp; &nbsp; template: selectedTemplate,
&nbsp; &nbsp; &nbsp; targetPath,
&nbsp; &nbsp; };
&nbsp; }
}
</code></pre>
<p>接下来，在 createTemplate.js 的同级目录下创建 <code>downloadTemplate.js</code> 文件，用于定义将模板下载到缓存目录的逻辑。这里有几个关键点需要注意：</p>
<ul>
<li>使用 <code>path-exists</code> 来判断文件是否存在，并通过 <code>fs-extra</code> 创建不存在的目录。</li>
<li>通过 <code>execa</code> 执行如 npm install {npmName}@{npmVersion} 这样的 npm 命令。</li>
<li>由于下载过程可能耗时较长，我们使用 <code>ora</code> 库展示下载进度条。</li>
</ul>
<pre><code class="language-javascript">import path from "node:path";
import { pathExistsSync } from "path-exists";
import fse from "fs-extra";
import ora from "ora";
import { execa } from "execa";

function getCacheDir(targetPath) {
&nbsp; return path.resolve(targetPath, "node_modules");
}
function makeCacheDir(targetPath) {
&nbsp; const cacheDir = getCacheDir(targetPath);
&nbsp; if (!pathExistsSync(cacheDir)) {
&nbsp; &nbsp; fse.mkdirpSync(cacheDir);
&nbsp; }
}

async function downloadAddTemplate(targetPath, selectedTemplate) {
&nbsp; const { npmName, version } = selectedTemplate;
&nbsp; const installCommand = "cnpm";
&nbsp; const installArgs = ["install", `${npmName}@${version}`];
&nbsp; const cwd = targetPath;
&nbsp; await execa(installCommand, installArgs, { cwd });
}

export default async function downloadTemplate(selectedTemplate) {
&nbsp; const { targetPath, template } = selectedTemplate;
&nbsp; makeCacheDir(targetPath);
&nbsp; const spinner = ora("正在下载模板...").start();
&nbsp; try {
&nbsp; &nbsp; await downloadAddTemplate(targetPath, template);
&nbsp; &nbsp; spinner.stop();
&nbsp; } catch (e) {
&nbsp; &nbsp; spinner.stop();
&nbsp; }
}
</code></pre>
<h1 id="拷贝项目模板">拷贝项目模板</h1>
<p>完成模板下载后，下一步是将其从缓存目录复制到用户希望创建的项目位置。这涉及到以下逻辑：</p>
<ul>
<li>获取用户输入的文件夹名称并检查该名称是否已存在。如果存在且指定了 <code>--force</code> 参数，则移除原有文件夹并创建新文件夹；否则提示错误信息。</li>
<li>将缓存目录下的内容复制到用户新建的项目文件夹内。</li>
</ul>
<pre><code class="language-javascript">import fse from "fs-extra";
import { pathExistsSync } from "path-exists";
import { log } from "@ice-basic-cli/utils";
import ora from "ora";
import path from "path";

export default function installTemplate(selectedTemplate, opts = {}) {
&nbsp; const { force = false } = opts;
&nbsp; const { targetPath, template, name } = selectedTemplate;
&nbsp; const rootDir = process.cwd();
&nbsp; fse.ensureDirSync(targetPath);
&nbsp; const installDir = path.resolve(`${rootDir}/${name}`);

&nbsp; if (pathExistsSync(installDir)) {
&nbsp; &nbsp; if (!force) {
&nbsp; &nbsp; &nbsp; log.error(`当前目录下已存在 ${installDir} 文件夹`);
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; fse.removeSync(installDir);
&nbsp; &nbsp; &nbsp; fse.ensureDirSync();
&nbsp; &nbsp; }
&nbsp; } else {
&nbsp; &nbsp; fse.ensureDirSync(installDir);
&nbsp; }
&nbsp; copyFile(targetPath, template, installDir);
}

function getCacheFilePath(targetPath, template) {
&nbsp; return path.resolve(targetPath, "node_modules", template.npmName);
}

function copyFile(targetPath, template, installDir) {
&nbsp; const originFile = getCacheFilePath(targetPath, template);
&nbsp; const fileList = fse.readdirSync(originFile);
&nbsp; const spinner = ora("正在拷贝文件").start();
&nbsp; fileList.map((file) =&gt; {
&nbsp; &nbsp; fse.copySync(`${originFile}/${file}`, `${installDir}/${file}`);
&nbsp; });
&nbsp; spinner.stop();
&nbsp; log.success("模板拷贝成功");
}
</code></pre>
<p>再次回到 <code>init.js</code> 文件中，导入 <code>downloadTemplate.js</code> 以及其他必要的模块，确保整个流程能够顺利运行。</p>
<pre><code class="language-javascript">import createTemplate from "./createTemplate.js";
import downloadTemplate from "./downloadTemplate.js";
import installTemplate from "./installTemplate.js";

class InitCommand extends Command {
   async action(name, opts) {
&nbsp; &nbsp; const selectedTemplate = await createTemplate(name, opts);
&nbsp; &nbsp; await downloadTemplate(selectedTemplate);
&nbsp; &nbsp;// 安装项目模板至项目目录
&nbsp; &nbsp; await installTemplate(selectedTemplate, opts);
&nbsp; }
}
</code></pre>
<p>到这里，一个交互式命令行下载模板的流程已经构建完成。</p>
<h1 id="非交互式项目创建">非交互式项目创建</h1>
<p>为了提供更大的灵活性，我们还需要支持非交互式的命令行创建项目方法，因为单元测试时需要通过命令而非交互方式来创建项目。</p>
<p>首先，在 <code>init.js</code> 文件中增加接收非交互式命令的指令集。</p>
<pre><code class="language-javascript">&nbsp;get options() {
&nbsp; &nbsp; return [
&nbsp; &nbsp; &nbsp; ["-f, --force", "是否强制更新", false],
&nbsp; &nbsp; &nbsp; ["-t, --type &lt;type&gt;", "项目类型（值：project/page）"],
&nbsp; &nbsp; &nbsp; ["-p, --template &lt;template&gt;", "模板名称"],
&nbsp; &nbsp; ];
&nbsp; }
</code></pre>
<p>然后，在 <code>createTemplate.js</code> 文件中处理这些参数，并根据不同的输入参数执行相应的流程。</p>
<pre><code class="language-javascript">export default async function createTemplate(name, opts) {
&nbsp; const { type = null, template = null } = opts;
&nbsp; let addType;
&nbsp; let addName;
&nbsp; let selectedTemplate;
&nbsp; if (type) {
&nbsp; &nbsp; addType = type;
&nbsp; } else {
&nbsp; &nbsp; addType = await getAddType();
&nbsp; }
&nbsp; if (addType === ADD_TYPE_PROJECT) {
&nbsp; &nbsp; if (name) {
&nbsp; &nbsp; &nbsp; addName = name;
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; addName = await getAddName();
&nbsp; &nbsp; }
&nbsp; &nbsp; if (template) {
&nbsp; &nbsp; &nbsp; selectedTemplate = ADD_TEMPLATE.find((tp) =&gt; tp.value === template);
&nbsp; &nbsp; &nbsp; if (!selectedTemplate) {
&nbsp; &nbsp; &nbsp; &nbsp; throw new Error(`项目模板 ${template} 不存在!`);
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; const addTemplate = await getAddTemplate();
&nbsp; &nbsp; &nbsp; selectedTemplate = ADD_TEMPLATE.find((_) =&gt; _.value === addTemplate);
&nbsp; &nbsp; }
&nbsp; &nbsp; const latestVersion = await getLatestVersion(selectedTemplate.npmName);
&nbsp; &nbsp; selectedTemplate.version = latestVersion;
&nbsp; &nbsp; const targetPath = makeTargetPath();
&nbsp; &nbsp; return {
&nbsp; &nbsp; &nbsp; type: addType,
&nbsp; &nbsp; &nbsp; name: addName,
&nbsp; &nbsp; &nbsp; template: selectedTemplate,
&nbsp; &nbsp; &nbsp; targetPath,
&nbsp; &nbsp; };
&nbsp; } else {
&nbsp; &nbsp; throw new Error(`创建的项目类型不支持`);
&nbsp; }
}
</code></pre>
<p>现在，在命令行工具中输入 <code>npx @ice-basic-cli/cli init testProject --type project --template vue-template --force --debug</code> 即可直接下载模板到 testProject 文件夹中。</p>
<p>通过上述步骤，我们已经详细介绍了如何使用 Node.js 实现一个从模板下载到项目创建的完整流程。这个过程不仅涵盖了交互式的命令行工具开发，还考虑到了非交互式的应用场景，确保了在各种情况下都能灵活高效地创建项目。</p>
<p>如果你对前端工程化有兴趣，或者想了解更多相关的内容，欢迎查看我的其他文章，这些内容将持续更新，希望能给你带来更多的灵感和技术分享~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04714134888541667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-02 23:10">2025-03-02 23:09</span>&nbsp;
<a href="https://www.cnblogs.com/vigourice">一颗冰淇淋</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18739728" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18739728);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18739728', targetLink: 'https://www.cnblogs.com/vigourice/p/18739728', title: '使用Node.js打造交互式脚手架，简化模板下载与项目创建' })">举报</a>
</div>
	