
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhennann/p/19055594" title="发布于 2025-08-24 16:51">
    <span role="heading" aria-level="2">Node.js 主流ORM框架动态分表方案大盘点</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250824165100572-1784373022.png" alt="Node.js 主流ORM框架动态分表方案大盘点" class="desc_img">
        针对高并发、数据量大的场景，通常会考虑采用分库分表进行优化。在这篇文章，我们重点盘点一下Node.js主流ORM框架的动态分表方案
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>针对高并发、数据量大的场景，通常会考虑采用<code>分库分表</code>进行优化。在这篇文章，我们重点盘点一下Node.js主流ORM框架的动态分表方案：</p>
<h2 id="分表规则">分表规则</h2>
<p>比如我们需要对订单表进行分表操作。可以根据实际业务需求设计分表规则，在这里，我们根据顾客Id取模动态生成表名。比如，拆分为16张表，顾客Id为129，对应的表名如下：</p>
<pre><code class="language-typescript">const tableName = `Order_${129 % 16}`;  // Order_1
</code></pre>
<h2 id="typeorm"><a href="https://typeorm.io" target="_blank" rel="noopener nofollow">TypeORM</a></h2>
<p>在TypeORM中可以按照如下方式设置动态表名：</p>
<pre><code class="language-typescript">// 获取repository
const repositoryOrder = dataSource.createQueryBuilder().connection.getRepository(EntityOrder);
// 设置动态表名
const userId = 129;
const tableName = `Order_${userId % 16}`;
repositoryOrder.metadata.tablePath = tableName;
// 查询订单
const orders = await repositoryOrder.find();
</code></pre>
<h2 id="drizzle-orm"><a href="https://orm.drizzle.team" target="_blank" rel="noopener nofollow">Drizzle ORM</a></h2>
<p><code>schema.ts</code></p>
<pre><code class="language-typescript">const orderFactory = userId =&gt; pgTable(
  `Order_${userId % 16}`,
  {
    id: serial('id').primaryKey(),  
    name: text('name').notNull(),
  },
);

export const order0 = orderFactory(0);
...
export const order15 = orderFactory(15);
</code></pre>
<p><code>query.ts</code></p>
<pre><code class="language-typescript">import * as schema from './db/schema';

const db = drizzle(process.env.DATABASE_URL!, { schema });

const userId = 129;
const modelName=`order${userId % 16}`;
const orders = await db.query[modelName].findMany();
</code></pre>
<h2 id="prisma-orm"><a href="https://www.prisma.io/docs" target="_blank" rel="noopener nofollow">Prisma ORM</a></h2>
<p>Prisma ORM对动态表名的支持还在规划当中，参见：<a href="https://github.com/prisma/prisma/issues/1708" target="_blank" rel="noopener nofollow">Table Partitioning</a></p>
<p>作为备选方案，我们可以使用<code>$queryRawUnsafe</code>直接构造原始SQL：</p>
<pre><code class="language-typescript">const userId = 129;
const tableName = `Order_${userId % 16}`;  
const orders = await prisma.$queryRawUnsafe(`SELECT * FROM "${tableName}"`);
</code></pre>
<h2 id="vona-orm"><a href="https://vona.js.org/guide/techniques/orm/introduction.html" target="_blank" rel="noopener nofollow">Vona ORM</a></h2>
<p>Vona ORM提供了两种模式：自动模式/手工模式</p>
<h3 id="1-自动模式">1. 自动模式</h3>
<p><code>model/order.ts</code></p>
<pre><code class="language-typescript">import { EntityOrder } from '../entity/order.ts';

@Model({
  entity: EntityOrder,
  table(ctx: VonaContext, defaultTable: keyof ITableRecord) {
    const user = ctx.app.bean.passport.getCurrentUser();
    if (!user) return defaultTable;
    return `${defaultTable}_${Number(user.id) % 16}`;
  },
})
export class ModelOrder {}
</code></pre>
<ul>
<li>defaultTable: 是在EntityOrder中定义的缺省表名，如：<code>Order</code></li>
</ul>
<p><code>service/order.ts</code></p>
<pre><code class="language-typescript">class ServiceOrder {
  async findAll() {
    return await this.scope.model.order.select();
  }
}
</code></pre>
<h3 id="2-手工模式">2. 手工模式</h3>
<p><code>service/order.ts</code></p>
<pre><code class="language-typescript">class ServiceOrder {
  async findAll() {
    const user = this.bean.passport.getCurrentUser();
    const tableName = `Order_${Number(user!.id) % 16}`;
    const modelOrder = this.scope.model.order.newInstance(undefined, tableName as any);
    return await modelOrder.select();
  }
}
</code></pre>
<ul>
<li>newInstance: 第一个参数可以传入数据源，从而实现<code>分库</code>能力。这里忽略，因此传入undefined</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-24 16:52">2025-08-24 16:51</span>&nbsp;
<a href="https://www.cnblogs.com/zhennann">濮水大叔</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19055594);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19055594', targetLink: 'https://www.cnblogs.com/zhennann/p/19055594', title: 'Node.js 主流ORM框架动态分表方案大盘点' })">举报</a>
</div>
        