
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18797359" title="发布于 2025-03-28 09:47">
    <span role="heading" aria-level="2">【集合分组利器】Java通用集合分组方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="java通用集合分组实现方案详解从基础到高级实践">Java通用集合分组实现方案详解：从基础到高级实践</h1>
<p>在Java开发中，对集合中的元素按照特定属性进行分组是一项常见而重要的操作。本文将全面介绍Java中实现集合分组的多种方案，从基础实现到高级用法，并通过丰富的示例展示每种方案的实际效果。</p>
<h2 id="一基础分组实现">一、基础分组实现</h2>
<h3 id="11-单属性分组">1.1 单属性分组</h3>
<p>最基本的集合分组方式是按照对象的单个属性进行分组：</p>
<pre><code class="language-java">// 通用单属性分组方法
public static &lt;T, K&gt; Map&lt;K, List&lt;T&gt;&gt; groupBySingleProperty(
        Collection&lt;T&gt; collection, 
        Function&lt;T, K&gt; classifier) {
    return collection.stream()
            .collect(Collectors.groupingBy(classifier));
}

// 使用示例：按姓名分组
Map&lt;String, List&lt;Person&gt;&gt; byName = groupBySingleProperty(people, Person::getName);

// 结果输出
System.out.println("按姓名分组结果:");
byName.forEach((name, list) -&gt; 
    System.out.println("  " + name + ": " + list));
</code></pre>
<p><strong>执行结果</strong>：</p>
<pre><code>按姓名分组结果:
  Bob: [Bob(30,Chicago), Bob(25,New York)]
  Alice: [Alice(25,New York), Alice(25,Chicago), Alice(30,New York)]
</code></pre>
<h3 id="12-多属性分组使用list作为键">1.2 多属性分组（使用List作为键）</h3>
<p>当需要按照多个属性组合作为分组依据时：</p>
<pre><code class="language-java">// 通用多属性分组方法
public static &lt;T, K&gt; Map&lt;List&lt;K&gt;, List&lt;T&gt;&gt; groupByMultipleProperties(
        Collection&lt;T&gt; collection, 
        Function&lt;T, K&gt;... classifiers) {
    
    return collection.stream()
            .collect(Collectors.groupingBy(
                item -&gt; Arrays.stream(classifiers)
                        .map(fn -&gt; fn.apply(item))
                        .collect(Collectors.toList())
            ));
}

// 使用示例：按姓名和年龄分组
Map&lt;List&lt;Object&gt;, List&lt;Person&gt;&gt; byNameAndAge = 
    groupByMultipleProperties(people, Person::getName, Person::getAge);

// 结果输出
System.out.println("\n按姓名和年龄分组结果:");
byNameAndAge.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));
</code></pre>
<p><strong>执行结果</strong>：</p>
<pre><code>按姓名和年龄分组结果:
  [Alice, 25]: [Alice(25,New York), Alice(25,Chicago)]
  [Bob, 30]: [Bob(30,Chicago)]
  [Alice, 30]: [Alice(30,New York)]
  [Bob, 25]: [Bob(25,New York)]
</code></pre>
<h2 id="二增强型分组实现">二、增强型分组实现</h2>
<h3 id="21-使用groupkey分组">2.1 使用GroupKey分组</h3>
<p>为避免使用List作为Map键可能带来的问题，我们可以引入专门的GroupKey类：</p>
<pre><code class="language-java">// GroupKey定义
public static class GroupKey {
    private final Object[] keys;
    
    public GroupKey(Object... keys) {
        this.keys = keys;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof GroupKey)) return false;
        GroupKey groupKey = (GroupKey) o;
        return Arrays.equals(keys, groupKey.keys);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(keys);
    }

    @Override
    public String toString() {
        return Arrays.toString(keys);
    }
}

// 使用GroupKey的分组方法
public static &lt;T&gt; Map&lt;GroupKey, List&lt;T&gt;&gt; groupByWithGroupKey(
        Collection&lt;T&gt; collection,
        Function&lt;T, ?&gt;... classifiers) {
    
    return collection.stream()
            .collect(Collectors.groupingBy(
                item -&gt; new GroupKey(
                    Arrays.stream(classifiers)
                          .map(fn -&gt; fn.apply(item))
                          .toArray()
                )
            ));
}

// 使用示例：按年龄和城市分组
Map&lt;GroupKey, List&lt;Person&gt;&gt; byAgeAndCity = 
    groupByWithGroupKey(people, Person::getAge, Person::getCity);

// 结果输出
System.out.println("\n使用GroupKey按年龄和城市分组结果:");
byAgeAndCity.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));
</code></pre>
<p><strong>执行结果</strong>：</p>
<pre><code>使用GroupKey按年龄和城市分组结果:
  [25, New York]: [Alice(25,New York), Bob(25,New York)]
  [30, Chicago]: [Bob(30,Chicago)]
  [25, Chicago]: [Alice(25,Chicago)]
  [30, New York]: [Alice(30,New York)]
</code></pre>
<h2 id="三基于枚举的高级分组方案">三、基于枚举的高级分组方案</h2>
<h3 id="31-枚举分组基础架构">3.1 枚举分组基础架构</h3>
<pre><code class="language-java">// 分组字段枚举接口
public interface GroupFieldEnum&lt;T&gt; {
    Function&lt;T, Object&gt; getExtractor();
    String getFieldName();
}

// Person类的分组字段枚举
public enum PersonGroupField implements GroupFieldEnum&lt;Person&gt; {
    NAME("姓名", Person::getName),
    AGE("年龄", Person::getAge),
    CITY("城市", Person::getCity);
    
    private final String fieldName;
    private final Function&lt;Person, Object&gt; extractor;
    
    PersonGroupField(String fieldName, Function&lt;Person, Object&gt; extractor) {
        this.fieldName = fieldName;
        this.extractor = extractor;
    }
    
    @Override
    public Function&lt;Person, Object&gt; getExtractor() {
        return extractor;
    }
    
    @Override
    public String getFieldName() {
        return fieldName;
    }
}

// 枚举分组工具类
public class EnumGroupingUtils {
    public static &lt;T, E extends Enum&lt;E&gt; &amp; GroupFieldEnum&lt;T&gt;&gt; 
            Map&lt;GroupKey, List&lt;T&gt;&gt; groupByEnumFields(
            Collection&lt;T&gt; collection, 
            E... groupFields) {
        
        return collection.stream()
                .collect(Collectors.groupingBy(
                    item -&gt; new GroupKey(
                        Arrays.stream(groupFields)
                              .map(field -&gt; field.getExtractor().apply(item))
                              .toArray()
                    )
                ));
    }
}
</code></pre>
<h3 id="32-枚举分组使用示例">3.2 枚举分组使用示例</h3>
<pre><code class="language-java">// 按枚举字段分组示例
System.out.println("\n枚举分组方案演示:");

// 按姓名分组
Map&lt;GroupKey, List&lt;Person&gt;&gt; byNameEnum = 
    EnumGroupingUtils.groupByEnumFields(people, PersonGroupField.NAME);
System.out.println("1. 按姓名分组结果:");
byNameEnum.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));

// 按姓名和年龄分组
Map&lt;GroupKey, List&lt;Person&gt;&gt; byNameAndAgeEnum = 
    EnumGroupingUtils.groupByEnumFields(people, 
        PersonGroupField.NAME, PersonGroupField.AGE);
System.out.println("\n2. 按姓名和年龄分组结果:");
byNameAndAgeEnum.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));

// 按所有字段分组
Map&lt;GroupKey, List&lt;Person&gt;&gt; byAllFieldsEnum = 
    EnumGroupingUtils.groupByEnumFields(people, 
        PersonGroupField.values());
System.out.println("\n3. 按所有字段分组结果:");
byAllFieldsEnum.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));

// 动态选择分组字段
List&lt;PersonGroupField&gt; dynamicFields = new ArrayList&lt;&gt;();
dynamicFields.add(PersonGroupField.CITY);
dynamicFields.add(PersonGroupField.AGE);
Map&lt;GroupKey, List&lt;Person&gt;&gt; dynamicResult = 
    EnumGroupingUtils.groupByEnumFields(people, 
        dynamicFields.toArray(new PersonGroupField[0]));
System.out.println("\n4. 动态选择字段(城市+年龄)分组结果:");
dynamicResult.forEach((key, list) -&gt; 
    System.out.println("  " + key + ": " + list));
</code></pre>
<p><strong>执行结果</strong>：</p>
<pre><code>枚举分组方案演示:
1. 按姓名分组结果:
  [Alice]: [Alice(25,New York), Alice(25,Chicago), Alice(30,New York)]
  [Bob]: [Bob(30,Chicago), Bob(25,New York)]

2. 按姓名和年龄分组结果:
  [Alice, 25]: [Alice(25,New York), Alice(25,Chicago)]
  [Bob, 30]: [Bob(30,Chicago)]
  [Alice, 30]: [Alice(30,New York)]
  [Bob, 25]: [Bob(25,New York)]

3. 按所有字段分组结果:
  [Alice, 25, New York]: [Alice(25,New York)]
  [Bob, 30, Chicago]: [Bob(30,Chicago)]
  [Alice, 25, Chicago]: [Alice(25,Chicago)]
  [Alice, 30, New York]: [Alice(30,New York)]
  [Bob, 25, New York]: [Bob(25,New York)]

4. 动态选择字段(城市+年龄)分组结果:
  [New York, 25]: [Alice(25,New York), Bob(25,New York)]
  [Chicago, 30]: [Bob(30,Chicago)]
  [Chicago, 25]: [Alice(25,Chicago)]
  [New York, 30]: [Alice(30,New York)]
</code></pre>
<h2 id="四技术深度解析">四、技术深度解析</h2>
<h3 id="41-toarraynew-persongroupfield0原理">4.1 <code>toArray(new PersonGroupField[0])</code>原理</h3>
<p>在动态字段分组中使用的这种写法是Java集合转数组的惯用模式：</p>
<pre><code class="language-java">dynamicFields.toArray(new PersonGroupField[0])
</code></pre>
<ul>
<li><strong>作用</strong>：将List<persongroupfield>转换为PersonGroupField[]数组</persongroupfield></li>
<li><strong>原理</strong>：
<ol>
<li>传入空数组作为类型模板</li>
<li>JVM根据运行时类型信息创建正确类型和大小的新数组</li>
<li>比直接指定大小更简洁高效（无需先调用size()）</li>
</ol>
</li>
<li><strong>Java 11+优化</strong>：可使用<code>toArray(PersonGroupField[]::new)</code>替代</li>
</ul>
<h3 id="42-枚举分组的优势">4.2 枚举分组的优势</h3>
<ol>
<li><strong>类型安全</strong>：编译器会检查枚举值的有效性</li>
<li><strong>可维护性</strong>：所有分组字段集中管理，修改方便</li>
<li><strong>自描述性</strong>：枚举可包含字段描述信息</li>
<li><strong>IDE支持</strong>：代码自动补全和提示更完善</li>
<li><strong>可扩展性</strong>：新增分组字段只需添加枚举项</li>
</ol>
<h2 id="五方案对比与选型建议">五、方案对比与选型建议</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单属性分组</td>
<td>简单分组需求</td>
<td>实现简单</td>
<td>功能有限</td>
</tr>
<tr>
<td>多属性List分组</td>
<td>临时性多字段分组</td>
<td>无需额外类</td>
<td>List作为键不够直观</td>
</tr>
<tr>
<td>GroupKey分组</td>
<td>需要清晰键定义的分组</td>
<td>键表达明确</td>
<td>需维护GroupKey类</td>
</tr>
<tr>
<td>枚举分组</td>
<td>企业级应用、复杂分组需求</td>
<td>类型安全、可维护</td>
<td>需要前期设计</td>
</tr>
</tbody>
</table>
<p><strong>选型建议</strong>：</p>
<ol>
<li>简单工具类：使用基础分组方案</li>
<li>中型项目：推荐GroupKey方案</li>
<li>大型复杂系统：采用枚举分组架构</li>
<li>需要最大灵活性：结合动态字段选择</li>
</ol>
<h2 id="六性能优化建议">六、性能优化建议</h2>
<ol>
<li>
<p><strong>大数据集处理</strong>：</p>
<pre><code class="language-java">// 使用并行流提高处理速度
Map&lt;GroupKey, List&lt;Person&gt;&gt; result = people.parallelStream()
        .collect(Collectors.groupingBy(...));
</code></pre>
</li>
<li>
<p><strong>内存优化</strong>：</p>
<ul>
<li>对于不可变数据集，考虑使用Guava的ImmutableListMultimap</li>
<li>分组结果如果不需要修改，返回不可变集合</li>
</ul>
</li>
<li>
<p><strong>缓存优化</strong>：</p>
<ul>
<li>频繁使用的分组结果可以考虑缓存</li>
<li>对于相同分组条件的多次操作，可以复用分组结果</li>
</ul>
</li>
</ol>
<h2 id="七总结">七、总结</h2>
<p>本文详细介绍了Java中实现集合分组的四种主要方案，从基础的<code>Collectors.groupingBy()</code>使用到基于枚举的高级分组架构。每种方案都附带了完整的代码示例和实际执行结果展示，帮助开发者深入理解其实现原理和应用场景。</p>
<p>对于大多数项目，推荐从GroupKey方案开始，它在复杂度和功能性之间取得了良好的平衡。随着项目规模扩大，可以平滑过渡到枚举分组方案，获得更好的类型安全性和可维护性。</p>
<p>无论选择哪种方案，理解分组操作背后的原理和各个方案的优缺点，都能帮助开发者写出更高效、更易维护的集合处理代码。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04969585088078704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-28 09:48">2025-03-28 09:47</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18797359" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18797359);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18797359', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18797359', title: '【集合分组利器】Java通用集合分组方案' })">举报</a>
</div>
        