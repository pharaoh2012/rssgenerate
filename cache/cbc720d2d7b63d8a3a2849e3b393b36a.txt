
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dayue-bc/p/18953017" title="发布于 2025-06-27 21:47">
    <span role="heading" aria-level="2">MyBatis 动态 SQL 与缓存机制深度解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在Java持久层技术体系中，**MyBatis**凭借其灵活的SQL映射和强大的动态SQL能力，成为企业级应用开发的首选框架
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>在Java持久层技术体系中，<strong>MyBatis</strong>凭借其灵活的SQL映射和强大的动态SQL能力，成为企业级应用开发的首选框架。本文从动态SQL核心语法、缓存实现原理、性能优化及面试高频问题四个维度，结合源码与工程实践，系统解析MyBatis的核心特性与最佳实践。</p>
</blockquote>
<h2 id="一动态sql核心语法与实现原理">一、动态SQL核心语法与实现原理</h2>
<h3 id="11-动态sql标签体系">1.1 动态SQL标签体系</h3>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
<th>示例场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;if&gt;</code></td>
<td>条件判断，按需拼接SQL片段</td>
<td>动态查询（如多条件筛选）</td>
</tr>
<tr>
<td><code>&lt;choose&gt;</code></td>
<td>类似于Java的switch语句，多选一执行</td>
<td>单条件查询（不同条件互斥）</td>
</tr>
<tr>
<td><code>&lt;where&gt;</code></td>
<td>智能处理WHERE子句，自动剔除多余的AND/OR</td>
<td>动态WHERE条件</td>
</tr>
<tr>
<td><code>&lt;set&gt;</code></td>
<td>智能处理UPDATE语句，自动剔除多余的逗号</td>
<td>动态更新（部分字段更新）</td>
</tr>
<tr>
<td><code>&lt;foreach&gt;</code></td>
<td>遍历集合，生成批量SQL</td>
<td>批量插入、IN条件查询</td>
</tr>
<tr>
<td><code>&lt;trim&gt;</code></td>
<td>自定义前缀、后缀处理，可替代<code>&lt;where&gt;</code>、<code>&lt;set&gt;</code></td>
<td>高级SQL片段处理</td>
</tr>
</tbody>
</table>
<h3 id="12-动态sql执行流程">1.2 动态SQL执行流程</h3>
<p><img alt="动态SQL执行流程图" loading="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/hlIMsuItLicaITN5VTHLic51To7EcrnJnPXsvOymoZ98ku3vqC7an7WmqmAVPQsicj6GbpAmzlbmjf7fd47RAeJCg/640?wx_fmt=png&amp;from=appmsg" class="lazyload"></p>
<h4 id="关键步骤解析">关键步骤解析：</h4>
<ol>
<li><strong>SQL节点解析</strong>：
<ul>
<li>XML配置中的动态标签（如<code>&lt;if&gt;</code>）被解析为<code>SqlNode</code>对象（如<code>IfSqlNode</code>）。</li>
</ul>
</li>
<li><strong>OGNL表达式计算</strong>：
<ul>
<li>使用OGNL（Object Graph Navigation Language）计算动态条件（如<code>#{username} != null</code>）。</li>
</ul>
</li>
<li><strong>参数绑定</strong>：
<ul>
<li>通过<code>TypeHandler</code>将Java对象转换为JDBC类型（如String → VARCHAR）。</li>
</ul>
</li>
</ol>
<h3 id="13-高级应用自定义sql提供器">1.3 高级应用：自定义SQL提供器</h3>
<h4 id="1-使用provider注解">1. 使用<code>@Provider</code>注解</h4>
<pre><code class="language-java">@SelectProvider(type = UserSqlProvider.class, method = "selectByCondition")  
List&lt;User&gt; selectByCondition(Map&lt;String, Object&gt; params);  

// 自定义SQL提供器  
public class UserSqlProvider {  
    public String selectByCondition(Map&lt;String, Object&gt; params) {  
        SQL sql = new SQL();  
        sql.SELECT("*").FROM("users");  
        if (params.containsKey("username")) {  
            sql.WHERE("username = #{username}");  
        }  
        if (params.containsKey("age")) {  
            sql.WHERE("age &gt;= #{age}");  
        }  
        return sql.toString();  
    }  
}  
</code></pre>
<h4 id="2-流式sql构建sql类">2. 流式SQL构建（SQL类）</h4>
<pre><code class="language-java">String sql = new SQL()  
    .SELECT("id", "username")  
    .FROM("users")  
    .WHERE("status = 'ACTIVE'")  
    .ORDER_BY("create_time DESC")  
    .toString();  
</code></pre>
<h2 id="二缓存机制深度解析">二、缓存机制深度解析</h2>
<h3 id="21-一级缓存本地缓存">2.1 一级缓存（本地缓存）</h3>
<h4 id="1-核心特性">1. 核心特性</h4>
<ul>
<li><strong>作用域</strong>：<code>SqlSession</code>级别（同一个会话内共享）。</li>
<li><strong>生命周期</strong>：与<code>SqlSession</code>一致，会话关闭时缓存清空。</li>
<li><strong>实现类</strong>：<code>PerpetualCache</code>（基于HashMap）。</li>
</ul>
<h4 id="2-源码关键逻辑">2. 源码关键逻辑</h4>
<pre><code class="language-java">public class DefaultSqlSession implements SqlSession {  
    private final Executor executor;  

    @Override  
    public &lt;T&gt; T selectOne(String statement, Object parameter) {  
        List&lt;T&gt; list = this.selectList(statement, parameter);  
        // 一级缓存逻辑在Executor中实现  
        return list.isEmpty() ? null : list.get(0);  
    }  
}  

public class BaseExecutor implements Executor {  
    private final PerpetualCache localCache;  

    @Override  
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {  
        BoundSql boundSql = ms.getBoundSql(parameter);  
        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);  
        return query(ms, parameter, rowBounds, resultHandler, key, boundSql);  
    }  

    @Override  
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {  
        // 先从一级缓存获取  
        List&lt;E&gt; list = (List&lt;E&gt;) localCache.getObject(key);  
        if (list != null) {  
            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);  
            return list;  
        } else {  
            // 缓存未命中，执行数据库查询  
            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);  
            return list;  
        }  
    }  
}  
</code></pre>
<h3 id="22-二级缓存全局缓存">2.2 二级缓存（全局缓存）</h3>
<h4 id="1-核心特性-1">1. 核心特性</h4>
<ul>
<li><strong>作用域</strong>：<code>namespace</code>级别（跨会话共享）。</li>
<li><strong>配置方式</strong>：<pre><code class="language-xml">&lt;cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/&gt;  
</code></pre>
</li>
<li><strong>默认实现</strong>：<code>PerpetualCache</code>（可替换为Redis、Ehcache等）。</li>
</ul>
<h4 id="2-缓存配置参数">2. 缓存配置参数</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eviction</code></td>
<td>缓存淘汰策略（LRU/FIFO/SOFT/WEAK）</td>
</tr>
<tr>
<td><code>flushInterval</code></td>
<td>刷新间隔（毫秒，默认不刷新）</td>
</tr>
<tr>
<td><code>size</code></td>
<td>缓存最大容量（元素个数）</td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td>是否只读（true则返回缓存对象的引用，性能更高）</td>
</tr>
</tbody>
</table>
<h3 id="23-缓存工作流程">2.3 缓存工作流程</h3>
<p><img alt="缓存工作流程图" loading="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/hlIMsuItLicaITN5VTHLic51To7EcrnJnPvA0vHUmeEibrNhukh16ZMbkia8P3mHOSG2ciafIZcH0UXOApRvFEeOibdQ/640?wx_fmt=png&amp;from=appmsg" class="lazyload"></p>
<h4 id="关键注意点">关键注意点：</h4>
<ul>
<li><strong>缓存失效</strong>：<br>
增删改操作（INSERT/UPDATE/DELETE）默认会清空所在<code>namespace</code>的二级缓存。</li>
<li><strong>嵌套查询</strong>：<br>
嵌套查询（<code>&lt;association&gt;</code>、<code>&lt;collection&gt;</code>）可能导致二级缓存失效（取决于<code>useCache</code>属性）。</li>
</ul>
<h2 id="三缓存集成与性能优化">三、缓存集成与性能优化</h2>
<h3 id="31-第三方缓存集成redis示例">3.1 第三方缓存集成（Redis示例）</h3>
<h4 id="1-添加依赖">1. 添加依赖</h4>
<pre><code class="language-xml">&lt;dependency&gt;  
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;  
    &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;  
    &lt;version&gt;1.0.0-beta2&lt;/version&gt;  
&lt;/dependency&gt;  
</code></pre>
<h4 id="2-配置redis缓存">2. 配置Redis缓存</h4>
<pre><code class="language-xml">&lt;cache type="org.mybatis.caches.redis.RedisCache"/&gt;  

&lt;!-- redis.properties --&gt;  
host=127.0.0.1  
port=6379  
timeout=2000  
</code></pre>
<h3 id="32-性能优化策略">3.2 性能优化策略</h3>
<h4 id="1-合理使用缓存级别">1. 合理使用缓存级别</h4>
<ul>
<li><strong>一级缓存</strong>：默认开启，适合短期高频查询（如同一请求内多次查询相同数据）。</li>
<li><strong>二级缓存</strong>：需显式配置，适合全局共享且读多写少的数据（如字典表、配置信息）。</li>
</ul>
<h4 id="2-缓存参数调优">2. 缓存参数调优</h4>
<pre><code class="language-xml">&lt;!-- 高并发场景优化配置 --&gt;  
&lt;cache  
    eviction="LRU"  
    flushInterval="300000" &lt;!-- 5分钟刷新一次 --&gt;  
    size="2048"          &lt;!-- 增大缓存容量 --&gt;  
    readOnly="true"/&gt;    &lt;!-- 只读模式提升性能 --&gt;  
</code></pre>
<h4 id="3-避免缓存穿透与雪崩">3. 避免缓存穿透与雪崩</h4>
<ul>
<li><strong>缓存穿透</strong>：<br>
查询不存在的数据导致每次都访问数据库，可通过布隆过滤器或缓存空值解决。</li>
<li><strong>缓存雪崩</strong>：<br>
大量缓存同时失效导致瞬间数据库压力剧增，可通过设置随机过期时间避免。</li>
</ul>
<h2 id="四面试高频问题深度解析">四、面试高频问题深度解析</h2>
<h3 id="41-基础概念类问题">4.1 基础概念类问题</h3>
<p><strong>Q：MyBatis动态SQL与Hibernate Criteria API的区别？</strong><br>
A：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>MyBatis动态SQL</th>
<th>Hibernate Criteria API</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQL控制</td>
<td>完全手动控制，灵活性高</td>
<td>通过API生成，灵活性低</td>
</tr>
<tr>
<td>学习成本</td>
<td>较低（熟悉XML标签即可）</td>
<td>较高（需掌握对象化查询API）</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生SQL，性能优化空间大</td>
<td>可能生成冗余SQL，优化难度高</td>
</tr>
<tr>
<td>适用场景</td>
<td>复杂SQL场景（如多表关联、嵌套查询）</td>
<td>简单增删改查场景</td>
</tr>
</tbody>
</table>
<p><strong>Q：MyBatis一级缓存与二级缓存的区别？</strong><br>
A：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>一级缓存</th>
<th>二级缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用域</td>
<td>SqlSession级别</td>
<td>Namespace级别</td>
</tr>
<tr>
<td>生命周期</td>
<td>会话关闭后失效</td>
<td>应用启动到关闭</td>
</tr>
<tr>
<td>默认开启</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>缓存共享</td>
<td>同一个会话内共享</td>
<td>跨会话共享</td>
</tr>
<tr>
<td>实现类</td>
<td>PerpetualCache</td>
<td>可自定义（如RedisCache）</td>
</tr>
</tbody>
</table>
<h3 id="42-实现原理类问题">4.2 实现原理类问题</h3>
<p><strong>Q：MyBatis如何实现动态SQL的条件判断？</strong><br>
A：</p>
<ol>
<li>通过OGNL表达式计算条件（如<code>#{username} != null</code>）。</li>
<li>解析为对应的<code>SqlNode</code>实现类（如<code>IfSqlNode</code>）。</li>
<li>在SQL执行时动态决定是否包含该SQL片段。</li>
</ol>
<p><strong>Q：二级缓存的嵌套查询会导致什么问题？如何解决？</strong><br>
A：</p>
<ul>
<li><strong>问题</strong>：嵌套查询默认不使用二级缓存，可能导致重复查询数据库。</li>
<li><strong>解决方案</strong>：
<ol>
<li>设置<code>useCache="true"</code>和<code>flushCache="false"</code>。</li>
<li>使用<code>&lt;resultMap&gt;</code>的嵌套映射替代嵌套查询。</li>
</ol>
</li>
</ul>
<h3 id="43-实战调优类问题">4.3 实战调优类问题</h3>
<p><strong>Q：如何解决MyBatis缓存与数据库一致性问题？</strong><br>
A：</p>
<ol>
<li><strong>更新策略</strong>：
<ul>
<li>增删改操作后强制刷新缓存（默认行为）。</li>
<li>设置合理的缓存过期时间（如5分钟）。</li>
</ul>
</li>
<li><strong>读写分离场景</strong>：
<ul>
<li>主库写操作后立即刷新缓存。</li>
<li>从库读操作使用缓存，通过数据库主从同步保证最终一致性。</li>
</ul>
</li>
</ol>
<p><strong>Q：MyBatis动态SQL中<code>&lt;where&gt;</code>标签与<code>&lt;trim&gt;</code>标签的区别？</strong><br>
A：</p>
<ul>
<li><code>&lt;where&gt;</code>：<br>
自动添加WHERE关键字，并剔除多余的AND/OR。</li>
<li><code>&lt;trim&gt;</code>：<br>
可自定义前缀、后缀处理，如：<pre><code class="language-xml">&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt;  
    ...  
&lt;/trim&gt;  
</code></pre>
更灵活，可替代<code>&lt;where&gt;</code>标签。</li>
</ul>
<h2 id="总结动态sql与缓存的最佳实践">总结：动态SQL与缓存的最佳实践</h2>
<h3 id="动态sql设计原则">动态SQL设计原则</h3>
<ol>
<li><strong>简洁优先</strong>：避免过度复杂的动态SQL，优先使用<code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>等基础标签。</li>
<li><strong>参数校验</strong>：在Java代码中进行参数校验，避免在动态SQL中处理复杂逻辑。</li>
<li><strong>SQL片段复用</strong>：使用<code>&lt;sql&gt;</code>标签定义公共SQL片段，通过<code>&lt;include&gt;</code>复用。</li>
</ol>
<h3 id="缓存使用策略">缓存使用策略</h3>
<ol>
<li><strong>读多写少场景</strong>：启用二级缓存，如字典表、配置信息。</li>
<li><strong>写操作频繁场景</strong>：禁用二级缓存，避免频繁刷新影响性能。</li>
<li><strong>分布式环境</strong>：使用Redis等分布式缓存替代默认实现，保证跨节点缓存一致性。</li>
</ol>
<p>通过系统化掌握MyBatis动态SQL与缓存机制的核心原理及最佳实践，面试者可在回答中精准匹配问题需求，例如分析“如何优化复杂查询性能”时，能结合动态SQL优化与缓存策略，展现对持久层技术的深度理解与工程实践能力。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-27 21:48">2025-06-27 21:47</span>&nbsp;
<a href="https://www.cnblogs.com/dayue-bc">晴空月明</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18953017);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18953017', targetLink: 'https://www.cnblogs.com/dayue-bc/p/18953017', title: 'MyBatis 动态 SQL 与缓存机制深度解析' })">举报</a>
</div>
        