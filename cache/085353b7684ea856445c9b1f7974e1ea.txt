
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sdcb/p/19003720/csharp-runner-mcp" title="发布于 2025-07-25 08:45">
    <span role="heading" aria-level="2">为大模型 MCP Code Interpreter 而生：C# Runner 开源发布</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在7月初，我立下了一个 Flag：要做一个专门为大语言模型（LLM）设计的 C# 运行器 MCP (Model-Protocol-Context)。我的小小执念，是希望 C# 能够像 Python 一样，成为大模型世界里的一等公民。</p>
<p>经过一段时间的构思、踩坑和开发，今天，我非常高兴地向大家宣布：这个项目—— <strong>C# Runner</strong> 已经正式开源发布了！</p>
<p>这是一个高性能、高安全性的 C# 代码在线执行平台（沙箱），专为大语言模型（LLM）的 Function Calling、在线代码编辑器、动态脚本执行等场景而设计。我的目标很简单：<strong>为 C# 在 AI 浪潮中争得一席之地，使其成为像 Python 一样被大模型轻松调度的“一等公民”</strong>。</p>
<p>这个项目的诞生，源于我此前对实现“毫秒级、高安全性”执行 C# 代码方案的大量研究和实验。现在，我将这些成果凝聚成了 C# Runner。</p>
<p><strong>项目地址：<a href="https://github.com/sdcb/csharp-runner" target="_blank" rel="noopener nofollow">https://github.com/sdcb/csharp-runner</a></strong></p>
<h2 id="缘起一个毫秒级的梦想">缘起：一个毫秒级的梦想</h2>
<p>一切始于一个简单而又极具挑战性的目标：</p>
<blockquote>
<p>在「冷启动」场景下，把一段未知、可能不可信的 C# 代码编译并执行完毕的时间控制在 100ms 以内（理想 &lt; 20ms），同时保证绝对的安全、可伸缩和跨平台。</p>
</blockquote>
<p>现在大模型的 Function Calling 或 Code Interpreter 基本都是跑 Python，这让我很不甘心。我希望构建一个服务，能让 C# 代码的执行体验如丝般顺滑，快到毫秒级别；同时它必须固若金汤，即使用户提交了恶意代码，也无法对服务器造成任何危害。</p>
<p>在很多现代应用场景中，我们都渴望能动态地执行用户提供的 C# 代码。然而，这面临着两大核心挑战：</p>
<ol>
<li><strong>性能</strong>：常规的 <code>dotnet run</code> 方式涉及到 MSBuild、项目还原等重度操作，耗时通常在数百甚至上千毫秒，完全无法满足交互式场景的性能要求。</li>
<li><strong>安全</strong>：执行一段未知的、可能不可信的代码，无异于在服务器上“裸奔”。必须有万无一失的沙箱机制来防止恶意代码破坏系统、窃取数据或滥用资源。</li>
</ol>
<p><strong>C# Runner</strong> 正是为解决这一对核心矛盾而生。</p>
<h2 id="效果演示">效果演示</h2>
<p>为了直观展示 C# Runner 的性能，我将一个示例网站部署到了 Azure 上。并且为了增加挑战，我只选择了一台 1GB 内存的、Azure 上最便宜的虚拟机。</p>
<p><strong>演示地址：<a href="https://csharp.starworks.cc/" target="_blank" rel="noopener nofollow">https://csharp.starworks.cc/</a></strong></p>
<p>在这个网站上，你可以直接输入 C# 代码并执行，体验毫秒级的响应速度。无论是简单的 <code>Console.WriteLine</code>，还是复杂的计算逻辑，都能在极短时间内完成。</p>
<p>它默认已经写了一段简单的代码，你可以去修改它，然后点击 <strong>Run Code</strong> 按钮，执行结果会显示在下方的 Output 区域：</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202507/233608-20250724225512622-239615818.png" alt="demo" loading="lazy"></p>
<p>如果你细心观察，会发现这个 Output 区域是实时更新的。这得益于 C# Runner 对流式输出（Server-Sent Events, SSE）的支持，你可以实时看到代码的 <code>stdout</code>、<code>stderr</code> 和最终结果。</p>
<p>这是目前这台 Azure 虚拟机的 <code>htop</code> 负载情况，资源占用非常低：</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202507/233608-20250724225518446-63624650.png" alt="htop" loading="lazy"></p>
<h2 id="c-runner-是如何工作的">C# Runner 是如何工作的？</h2>
<p>为了同时实现极致的性能和强大的安全性，C# Runner 采用了<strong>基于 Docker 的 Host-Worker 架构</strong>。</p>
<ul>
<li><strong>Worker</strong>：每个 Worker 都是一个独立的、轻量级的 Docker 容器。它是一个已经加载了 Roslyn Scripting 环境的 Web 服务，负责实际编译和执行 C# 代码。</li>
<li><strong>Host</strong>：Host 是整个系统的入口和“大脑”。它维护着一个由多个 Worker 组成的“资源池”。这些 Worker 在系统启动时就已经<strong>提前创建并预热</strong>，随时可以接收任务。</li>
</ul>
<p>当一个代码执行请求到达 Host 时，Host 会通过负载均衡策略（如轮询）选择一个空闲的 Worker，并将代码交给它执行。这种“<strong>池化 + 预热</strong>”的模式，完美规避了 Docker 冷启动的性能开销，使得终端用户可以享受到毫秒级的响应速度。</p>
<h2 id="-核心特性一览">✨ 核心特性一览</h2>
<h4 id="-安全为本-security-first">🔒 安全为本 (Security First)</h4>
<ul>
<li><strong>容器级隔离</strong>: 所有代码均在独立的 Docker Worker 容器中执行，与主机环境彻底隔离。</li>
<li><strong>资源精细控制</strong>: 可通过 Docker Compose 精确限制每个 Worker 的 CPU、内存、进程数等资源，防止资源滥用。</li>
<li><strong>执行超时</strong>: 每个任务都可以设置超时时间，防止恶意死循环代码。</li>
<li><strong>自动回收</strong>: 可配置 Worker 执行 N 次任务后自动销毁并由新的纯净实例取代，杜绝环境污染。</li>
</ul>
<h4 id="-性能至上-performance-is-key">⚡ 性能至上 (Performance is Key)</h4>
<ul>
<li><strong>Worker 预热与池化</strong>: C# Runner 的“秘密武器”，将容器启动和环境初始化的开销提前，保证业务请求的高性能响应。</li>
<li><strong>Roslyn Scripting API</strong>: 采用内存中编译执行的方式，速度远超传统 <code>dotnet run</code>。</li>
<li><strong>负载均衡</strong>: Host 自动将请求分发到多个 Worker，轻松实现水平扩展。</li>
</ul>
<h4 id="-功能丰富-feature-rich--ready-to-use">🌐 功能丰富 (Feature-Rich &amp; Ready to Use)</h4>
<ul>
<li><strong>双协议支持</strong>: 同时提供 <strong>HTTP REST API</strong> 和 <strong>MCP (Model-Protocol-Context)</strong> 接口，无缝对接传统应用和 AI Agent。</li>
<li><strong>流式输出 (SSE)</strong>: 实时返回代码的 <code>stdout</code>、<code>stderr</code> 和最终结果，交互体验流畅。</li>
<li><strong>内置 Web UI</strong>: 提供一个美观、易用的代码编辑器，支持语法高亮和 <code>Ctrl+Enter</code> 快捷执行，方便快速测试和演示。</li>
<li><strong>一键部署</strong>: 提供完整的 Docker Compose 解决方案，一条命令即可启动整个服务。</li>
</ul>
<h2 id="-60-秒快速部署">🚀 60 秒快速部署</h2>
<p>体验 C# Runner 非常简单，你只需要提前安装好 Docker 和 Docker Compose。</p>
<p><strong>1. 下载 <code>docker-compose.yml</code> 文件</strong></p>
<pre><code class="language-bash">curl -L https://raw.githubusercontent.com/sdcb/csharp-runner/refs/heads/master/docker-compose.yml -o docker-compose.yml
</code></pre>
<p><strong>2. 一键启动服务</strong></p>
<pre><code class="language-bash">docker compose up -d
</code></pre>
<blockquote>
<p>该命令会默认启动 1 个 Host 和 3 个 Worker 实例。</p>
</blockquote>
<p><strong>3. 开始使用！</strong></p>
<p>部署成功后，在浏览器中打开 <code>http://localhost:5050</code>，即可看到一个简洁的代码编辑界面，开始你的 C# 代码执行之旅！</p>
<h2 id="-灵活配置与使用">🔧 灵活配置与使用</h2>
<p>你可以通过 <code>docker-compose.yml</code> 文件轻松调整 Worker 的数量、资源限制以及回收策略，以适应不同的负载场景。</p>
<p>例如，将 <code>replicas</code> 修改为 <code>10</code>，即可轻松将后端处理能力扩展到 10 个 Worker 实例。</p>
<pre><code class="language-yml"># docker-compose.yml
services:
  # ... host service ...
  worker:
    # ...
    deploy:
      replicas: 10 # 将 Worker 实例扩展到 10 个
      resources:
        limits:
          cpus: '0.50'
          memory: 256M
</code></pre>
<p>无论是通过其 <strong>HTTP API</strong> 集成到你的业务系统，还是通过 <strong>MCP 端点</strong> empowering 你的 AI Agent，C# Runner 都提供了清晰、简单的调用方式。更多细节请参考项目主页的 API 文档。</p>
<h2 id="基于-mcp-协议调用">基于 MCP 协议调用</h2>
<p>如果你需要 MCP 协议，并希望通过它来调用 C# Runner，可以使用以下代码示例：</p>
<pre><code class="language-csharp">var clientTransport = new SseClientTransport(new SseClientTransportOptions()
{
    Name = "MyServer",
    Endpoint = new Uri("https://csharp.starworks.cc/mcp"),
});

var client = await McpClientFactory.CreateAsync(clientTransport);

// Execute a tool (this would normally be driven by LLM tool invocations).
(await client.CallToolAsync(
    "run_code",
    new Dictionary&lt;string, object?&gt;() { ["code"] = "Console.WriteLine(\"Hello World!\");" },
    new ProgressReporter(),
    cancellationToken: CancellationToken.None))
.StructuredContent.Dump();


public class ProgressReporter : IProgress&lt;ProgressNotificationValue&gt;
{
    public void Report(ProgressNotificationValue value)
    {
        value.Dump();
    }
}
</code></pre>
<p>输出将是实时的流式结果：</p>
<pre><code class="language-json">{"kind":"stdout","stdOutput":"Hello World!\n"}
{
  "kind": "end",
  "stdOutput": "Hello World!\n",
  "elapsed": 30
}
</code></pre>
<h2 id="总结">总结</h2>
<p>C# Runner 为 .NET 生态提供了一个开箱即用、兼顾性能与安全的动态代码执行解决方案。我希望它能成为您在构建下一代应用，特别是与 AI 结合的应用时的得力工具。</p>
<p>这个项目是我个人的一次探索，也必然有许多可以改进的地方。欢迎大家试用、反馈，甚至参与贡献！</p>
<ul>
<li><strong>为项目点亮 Star ⭐</strong>，这是对我最大的鼓励：<a href="https://github.com/sdcb/csharp-runner" target="_blank" rel="noopener nofollow">https://github.com/sdcb/csharp-runner</a></li>
<li><strong>提交你的想法和代码</strong>：欢迎通过 Issue 和 Pull Request 参与项目。</li>
<li><strong>加入 QQ 群讨论</strong>：欢迎加入 <strong>.NET 骚操作 QQ 群：495782587</strong>，一起交流 .NET 和 AI 的有趣玩法！</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-25 08:45">2025-07-25 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/sdcb">.NET骚操作</a>&nbsp;
阅读(<span id="post_view_count">611</span>)&nbsp;
评论(<span id="post_comment_count">9</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19003720);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19003720', targetLink: 'https://www.cnblogs.com/sdcb/p/19003720/csharp-runner-mcp', title: '为大模型 MCP Code Interpreter 而生：C# Runner 开源发布' })">举报</a>
</div>
        