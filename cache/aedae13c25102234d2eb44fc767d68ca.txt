
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/better-farther-world2099/p/18849712" title="发布于 2025-04-27 15:55">
    <span role="heading" aria-level="2">springboot分页查询并行优化实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　　　　　　　　　　　——基于异步优化与 MyBatis-Plus 分页插件思想的实践</p>
<h3>适用场景</h3>
<ul>
<li>数据量较大的单表分页查询</li>
<li>较复杂的多表关联查询，包含group by等无法进行count优化较耗时的分页查询</li>
</ul>
<h3>技术栈</h3>
<ul>
<li>
<p>核心框架：Spring Boot + MyBatis-Plus</p>
</li>
<li>
<p>异步编程：JDK 8+ 的&nbsp;<code>CompletableFuture</code>&nbsp;</p>
</li>
<li>
<p>数据库：MySQL 8.0</p>
</li>
<li>
<p>线程池：自定义线程池管理并行任务（如&nbsp;<code>ThreadPoolTaskExecutor</code>）</p>
</li>
</ul>
<h3>实现思路</h3>
<p>解决传统分页查询中&nbsp;串行执行 COUNT 与数据查询&nbsp;的性能瓶颈，通过&nbsp;并行化&nbsp;减少总耗时，同时兼容复杂查询场景（如多表关联、<code>DISTINCT</code>&nbsp;等）</p>
<p>兼容mybatisPlus分页参数，复用&nbsp;<code>IPage</code>&nbsp;接口定义分页参数（当前页、每页条数），</p>
<p>借鉴 MyBatis-Plus 的&nbsp;<code>PaginationInnerInterceptor</code>，通过实现 MyBatis 的&nbsp;<code>Interceptor</code>&nbsp;接口，拦截&nbsp;<code>Executor#query</code>&nbsp;方法，动态修改 SQL，</p>
<p>sql优化适配：COUNT 优化：自动移除&nbsp;<code>ORDER BY</code>，保留&nbsp;<code>GROUP BY</code>&nbsp;和&nbsp;<code>DISTINCT</code>（需包裹子查询），数据查询：保留完整 SQL 逻辑，仅追加&nbsp;<code>LIMIT</code>&nbsp;和&nbsp;<code>OFFSET。</code></p>
<h3>直接上代码</h3>
<p>使用简单</p>
<p>调用查询方法前赋值page对象属性total大于0数值则可进入自定义分页查询方案。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">示例代码</span>
Page&lt;User&gt; page = <span style="color: rgba(0, 0, 255, 1)">new</span> Page&lt;&gt;(1,10<span style="color: rgba(0, 0, 0, 1)">);
page.setTotal(</span>1L);</pre>
</div>
<p>线程池配置</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Configuration
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutorConfig {

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Integer CORE_POOL_SIZE = 20<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Integer MAX_POOL_SIZE = 40<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Integer QUEUE_CAPACITY = 200<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Integer KEEP_ALIVE_SECONDS = 60<span style="color: rgba(0, 0, 0, 1)">;

    @Bean(</span>"threadPoolTaskExecutor"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutor getThreadPoolTaskExecutor() {
        ThreadPoolTaskExecutor threadPoolTaskExecutor </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutor();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">核心线程数</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.setCorePoolSize(CORE_POOL_SIZE);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程池最大线程数</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.setMaxPoolSize(MAX_POOL_SIZE);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">队列容量</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.setQueueCapacity(QUEUE_CAPACITY);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程空闲存活时间</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.setKeepAliveSeconds(KEEP_ALIVE_SECONDS);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程前缀</span>
        threadPoolTaskExecutor.setThreadNamePrefix("commonTask-"<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">拒绝策略</span>
        threadPoolTaskExecutor.setRejectedExecutionHandler(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolExecutor.CallerRunsPolicy());
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程池初始化</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.initialize();

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> threadPoolTaskExecutor;
    }

    @Bean(</span>"countAsyncThreadPool"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutor getCountAsyncThreadPool() {
        ThreadPoolTaskExecutor threadPoolTaskExecutor </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutor();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">核心线程数，根据负载动态调整</span>
        threadPoolTaskExecutor.setCorePoolSize(6<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程池最大线程数，根据负载动态调整</span>
        threadPoolTaskExecutor.setMaxPoolSize(12<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">队列容量  队列容量不宜过多，根据负载动态调整</span>
        threadPoolTaskExecutor.setQueueCapacity(2<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程空闲存活时间</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.setKeepAliveSeconds(KEEP_ALIVE_SECONDS);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程前缀</span>
        threadPoolTaskExecutor.setThreadNamePrefix("countAsync-"<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">拒绝策略  队列满时由调用者主线程执行</span>
        threadPoolTaskExecutor.setRejectedExecutionHandler(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolExecutor.CallerRunsPolicy());
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">线程池初始化</span>
<span style="color: rgba(0, 0, 0, 1)">        threadPoolTaskExecutor.initialize();

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> threadPoolTaskExecutor;
    }
}</span></pre>
</div>
<p>mybatis-plus配置类</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Configuration
@MapperScan(</span>"com.xxx.mapper"<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MybatisPlusConfig {

    @Resource
    ThreadPoolTaskExecutor countAsyncThreadPool;
    @Resource
    ApplicationContext applicationContext;

    @Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> PaginationInnerInterceptor(DbType.MYSQL));
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> interceptor;
    }


    @Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> PageParallelQueryInterceptor pageParallelQueryInterceptor() {
        PageParallelQueryInterceptor pageParallelQueryInterceptor </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> PageParallelQueryInterceptor();
        pageParallelQueryInterceptor.setCountAsyncThreadPool(countAsyncThreadPool);
        pageParallelQueryInterceptor.setApplicationContext(applicationContext);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> pageParallelQueryInterceptor;
    }
}</span></pre>
</div>
<p>自定义mybatis拦截器</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">package</span><span style="color: rgba(0, 0, 0, 1)"> com.example.dlock_demo.interceptor;

</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.baomidou.mybatisplus.core.toolkit.CollectionUtils;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.baomidou.mybatisplus.extension.plugins.pagination.Page;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> lombok.extern.slf4j.Slf4j;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> net.sf.jsqlparser.JSQLParserException;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> net.sf.jsqlparser.expression.Expression;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> net.sf.jsqlparser.parser.CCJSqlParserUtil;
</span><span style="color: rgba(0, 0, 255, 1)">import</span> net.sf.jsqlparser.statement.select.*<span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.builder.StaticSqlSource;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.cache.CacheKey;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.executor.Executor;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.mapping.BoundSql;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.mapping.MappedStatement;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.mapping.ResultMap;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.plugin.Interceptor;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.plugin.Intercepts;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.plugin.Invocation;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.apache.ibatis.plugin.Signature;
</span><span style="color: rgba(0, 0, 255, 1)">import</span> org.apache.ibatis.session.*<span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.springframework.context.ApplicationContext;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.lang.reflect.Field;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.lang.reflect.Method;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.sql.SQLException;
</span><span style="color: rgba(0, 0, 255, 1)">import</span> java.util.*<span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.util.concurrent.CompletableFuture;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.util.concurrent.CompletionException;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.util.concurrent.ConcurrentHashMap;


</span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
 * Mybatis-分页并行查询拦截器
 *
 * </span><span style="color: rgba(128, 128, 128, 1)">@author</span><span style="color: rgba(0, 128, 0, 1)"> shf
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
@Intercepts({
        @Signature(type </span>= Executor.<span style="color: rgba(0, 0, 255, 1)">class</span>, method = "query"<span style="color: rgba(0, 0, 0, 1)">,
                args </span>= {MappedStatement.<span style="color: rgba(0, 0, 255, 1)">class</span>, Object.<span style="color: rgba(0, 0, 255, 1)">class</span>, RowBounds.<span style="color: rgba(0, 0, 255, 1)">class</span>, ResultHandler.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">}),
        @Signature(type </span>= Executor.<span style="color: rgba(0, 0, 255, 1)">class</span>, method = "query"<span style="color: rgba(0, 0, 0, 1)">,
                args </span>= {MappedStatement.<span style="color: rgba(0, 0, 255, 1)">class</span>, Object.<span style="color: rgba(0, 0, 255, 1)">class</span>, RowBounds.<span style="color: rgba(0, 0, 255, 1)">class</span>, ResultHandler.<span style="color: rgba(0, 0, 255, 1)">class</span>, CacheKey.<span style="color: rgba(0, 0, 255, 1)">class</span>, BoundSql.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">})
})
@Slf4j
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> PageParallelQueryInterceptor <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> Interceptor {
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 用于数据库并行查询线程池
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolTaskExecutor countAsyncThreadPool;
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 容器上下文
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> ApplicationContext applicationContext;

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> String LONG_RESULT_MAP_ID = "twoPhase-Long-ResultMap"<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Map&lt;String, MappedStatement&gt; twoPhaseMsCache = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ConcurrentHashMap();

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> setCountAsyncThreadPool(ThreadPoolTaskExecutor countAsyncThreadPool) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.countAsyncThreadPool =<span style="color: rgba(0, 0, 0, 1)"> countAsyncThreadPool;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> setApplicationContext(ApplicationContext applicationContext) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.applicationContext =<span style="color: rgba(0, 0, 0, 1)"> applicationContext;
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Object intercept(Invocation invocation) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Throwable {
        Object[] args </span>=<span style="color: rgba(0, 0, 0, 1)"> invocation.getArgs();
        MappedStatement ms </span>= (MappedStatement) args[0<span style="color: rgba(0, 0, 0, 1)">];
        Object parameter </span>= args[1<span style="color: rgba(0, 0, 0, 1)">];

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取分页参数</span>
        Page&lt;?&gt; page =<span style="color: rgba(0, 0, 0, 1)"> getPageParameter(parameter);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (page == <span style="color: rgba(0, 0, 255, 1)">null</span> || page.getSize() &lt;= 0 || !page.searchCount() || page.getTotal() == 0<span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> invocation.proceed();
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取Mapper方法(注解形式 需利用反射且只能应用在mapper接口层，不推荐使用)</span>
        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">Method method = getMapperMethod(ms);
        if (method == null || !method.isAnnotationPresent(PageParallelQuery.class)) {
            return invocation.proceed();
        }</span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">

        BoundSql boundSql </span>=<span style="color: rgba(0, 0, 0, 1)"> ms.getBoundSql(parameter);
        String originalSql </span>=<span style="color: rgba(0, 0, 0, 1)"> boundSql.getSql();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">禁用mybatis plus PaginationInnerInterceptor count查询</span>
        page.setSearchCount(<span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">);
        page.setTotal(</span>0<span style="color: rgba(0, 0, 0, 1)">);
        args[</span>2] =<span style="color: rgba(0, 0, 0, 1)"> RowBounds.DEFAULT;
        CompletableFuture</span>&lt;Long&gt; countFuture =<span style="color: rgba(0, 0, 0, 1)"> resolveCountCompletableFuture(invocation, originalSql);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">limit查询</span>
        <span style="color: rgba(0, 0, 255, 1)">long</span> startTime =<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();
        Object proceed </span>=<span style="color: rgba(0, 0, 0, 1)"> invocation.proceed();
        log.info(</span>"原SQL数据查询-耗时={}", System.currentTimeMillis() -<span style="color: rgba(0, 0, 0, 1)"> startTime);
        page.setTotal(countFuture.get());

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> proceed;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> CompletableFuture&lt;Long&gt;<span style="color: rgba(0, 0, 0, 1)"> resolveCountCompletableFuture(Invocation invocation, String originalSql) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> CompletableFuture.supplyAsync(() -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">查询总条数</span>
                <span style="color: rgba(0, 0, 255, 1)">long</span> startTime =<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();
                </span><span style="color: rgba(0, 0, 255, 1)">long</span> total =<span style="color: rgba(0, 0, 0, 1)"> executeCountQuery(originalSql, invocation);
                log.info(</span>"分页并行查询COUNT总条数[{}]-耗时={}", total, System.currentTimeMillis() -<span style="color: rgba(0, 0, 0, 1)"> startTime);
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> total;
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Throwable e) {
                log.error(</span>"page parallel query exception:"<span style="color: rgba(0, 0, 0, 1)">, e);
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> CompletionException(e);
            }
        }, countAsyncThreadPool).exceptionally(throwable </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            log.error(</span>"page parallel query exception:"<span style="color: rgba(0, 0, 0, 1)">, throwable);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> 0L<span style="color: rgba(0, 0, 0, 1)">;
        });
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> CompletableFuture&lt;Object&gt;<span style="color: rgba(0, 0, 0, 1)"> resolveOriginalProceedCompletableFuture(Invocation invocation) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> CompletableFuture.supplyAsync(() -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">long</span> startTime =<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();
                Object proceed </span>=<span style="color: rgba(0, 0, 0, 1)"> invocation.proceed();
                log.info(</span>"原SQL数据查询-耗时={}", System.currentTimeMillis() -<span style="color: rgba(0, 0, 0, 1)"> startTime);
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> proceed;
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Throwable e) {
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> CompletionException(e);
            }
        }, countAsyncThreadPool).exceptionally(throwable </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            log.error(</span>"page parallel query original proceed exception:"<span style="color: rgba(0, 0, 0, 1)">, throwable);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
        });
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 执行count查询
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">long</span><span style="color: rgba(0, 0, 0, 1)"> executeCountQuery(String originalSql, Invocation invocation)
            </span><span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> JSQLParserException, SQLException {

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解析并修改SQL为count查询</span>
        Select countSelect =<span style="color: rgba(0, 0, 0, 1)"> (Select) CCJSqlParserUtil.parse(originalSql);
        PlainSelect plainSelect </span>=<span style="color: rgba(0, 0, 0, 1)"> (PlainSelect) countSelect.getSelectBody();

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">修改select为count(*)</span>
        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">plainSelect.setSelectItems(Collections.singletonList(
                new SelectExpressionItem(new Function("COUNT", new Column("*")))
        );</span><span style="color: rgba(0, 128, 0, 1)">*/</span>
        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 移除排序和分页</span>
        Distinct distinct =<span style="color: rgba(0, 0, 0, 1)"> plainSelect.getDistinct();
        GroupByElement groupBy </span>=<span style="color: rgba(0, 0, 0, 1)"> plainSelect.getGroupBy();
        String countSql </span>= ""<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (groupBy == <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; distinct == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            Expression countFuncExpression </span>= CCJSqlParserUtil.parseExpression("COUNT(*)"<span style="color: rgba(0, 0, 0, 1)">);
            plainSelect.setSelectItems(Collections.singletonList(
                    </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> SelectExpressionItem(countFuncExpression)));
            plainSelect.setOrderByElements(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            countSql </span>=<span style="color: rgba(0, 0, 0, 1)"> plainSelect.toString();
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (groupBy != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            plainSelect.setLimit(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            plainSelect.setOffset(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            countSql </span>= "SELECT COUNT(*) FROM (" + plainSelect + ") TOTAL"<span style="color: rgba(0, 0, 0, 1)">;
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            plainSelect.setOrderByElements(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            plainSelect.setLimit(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            plainSelect.setOffset(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
            countSql </span>= "SELECT COUNT(*) FROM (" + plainSelect + ") TOTAL"<span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">执行count查询</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> doCountQuery(invocation, countSql);
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 执行修改后的COUNT(*)-SQL查询
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    @SuppressWarnings(</span>"unchecked"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> Long doCountQuery(Invocation invocation, String modifiedSql) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">Executor executor = (Executor) invocation.getTarget();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建新会话（自动获取新连接）</span>
<span style="color: rgba(0, 0, 0, 1)">        Executor executor;
        SqlSessionFactory sqlSessionFactory </span>= applicationContext.getBean(SqlSessionFactory.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">try</span> (SqlSession sqlSession =<span style="color: rgba(0, 0, 0, 1)"> sqlSessionFactory.openSession(ExecutorType.SIMPLE)) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">com.alibaba.druid.pool.DruidPooledConnection</span>
            System.out.println("新会话Connection class: " +<span style="color: rgba(0, 0, 0, 1)"> sqlSession.getConnection().getClass().getName());
            Field executorField </span>= sqlSession.getClass().getDeclaredField("executor"<span style="color: rgba(0, 0, 0, 1)">);
            executorField.setAccessible(</span><span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
            executor </span>=<span style="color: rgba(0, 0, 0, 1)"> (Executor) executorField.get(sqlSession);

            Object[] args </span>=<span style="color: rgba(0, 0, 0, 1)"> invocation.getArgs();
            MappedStatement originalMs </span>= (MappedStatement) args[0<span style="color: rgba(0, 0, 0, 1)">];
            Object parameter </span>= args[1<span style="color: rgba(0, 0, 0, 1)">];
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建新的查询参数</span>
            Map&lt;String, Object&gt; newParameter = <span style="color: rgba(0, 0, 255, 1)">new</span> HashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (parameter <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Map) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 复制原始参数但移除分页参数</span>
                Map&lt;?, ?&gt; originalParams = (Map&lt;?, ?&gt;<span style="color: rgba(0, 0, 0, 1)">) parameter;
                originalParams.forEach((k, v) </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!(v <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Page)) {
                        newParameter.put(k.toString(), v);
                    }
                });
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建新的BoundSql</span>
            BoundSql originalBoundSql =<span style="color: rgba(0, 0, 0, 1)"> originalMs.getBoundSql(newParameter);
            BoundSql newBoundSql </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BoundSql(originalMs.getConfiguration(), modifiedSql, originalBoundSql.getParameterMappings(), newParameter);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">复制原始参数值</span>
            originalBoundSql.getParameterMappings().forEach(mapping -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                String prop </span>=<span style="color: rgba(0, 0, 0, 1)"> mapping.getProperty();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (mapping.getJavaType().isInstance(newParameter)) {
                    newBoundSql.setAdditionalParameter(prop, newParameter);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (newParameter <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Map) {
                    Object value </span>= ((Map&lt;?, ?&gt;<span style="color: rgba(0, 0, 0, 1)">) newParameter).get(prop);
                    newBoundSql.setAdditionalParameter(prop, value);
                }
            });
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建新的BoundSql</span>
            <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">BoundSql originalBoundSql = originalMs.getBoundSql(parameter);
            BoundSql newBoundSql = new BoundSql(originalMs.getConfiguration(), modifiedSql,
                    originalBoundSql.getParameterMappings(), parameter);</span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
            Configuration configuration </span>=<span style="color: rgba(0, 0, 0, 1)"> originalMs.getConfiguration();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建临时ResultMap</span>
            ResultMap resultMap = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ResultMap.Builder(
                    configuration,
                    LONG_RESULT_MAP_ID,
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">强制指定结果类型</span>
                    Long.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">,
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">自动映射列到简单类型</span>
<span style="color: rgba(0, 0, 0, 1)">                    Collections.emptyList()
            ).build();
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">configuration.hasResultMap(LONG_RESULT_MAP_ID)) {
                configuration.addResultMap(resultMap);
            }

            String countMsId </span>= originalMs.getId() + "_countMsId"<span style="color: rgba(0, 0, 0, 1)">;
            MappedStatement mappedStatement </span>= twoPhaseMsCache.computeIfAbsent(countMsId, (key) -&gt;
                    <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.getNewMappedStatement(modifiedSql, originalMs, newBoundSql, resultMap, countMsId));
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">执行查询</span>
            List&lt;Object&gt; result = executor.query(mappedStatement, newParameter, RowBounds.DEFAULT, (ResultHandler&lt;?&gt;) args[3<span style="color: rgba(0, 0, 0, 1)">]);
            </span><span style="color: rgba(0, 0, 255, 1)">long</span> total = 0L<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (CollectionUtils.isNotEmpty(result)) {
                Object o </span>= result.get(0<span style="color: rgba(0, 0, 0, 1)">);
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (o != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    total </span>=<span style="color: rgba(0, 0, 0, 1)"> Long.parseLong(o.toString());
                }
            }
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> total;
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Throwable e) {
            log.error(</span>"分页并行查询-executeCountQuery异常:"<span style="color: rgba(0, 0, 0, 1)">, e);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> 0L<span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> MappedStatement getNewMappedStatement(String modifiedSql, MappedStatement originalMs, BoundSql newBoundSql,
                                                  ResultMap resultMap, String msId) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建新的MappedStatement</span>
        MappedStatement.Builder builder = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MappedStatement.Builder(
                originalMs.getConfiguration(),
                msId,
                </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> StaticSqlSource(originalMs.getConfiguration(), modifiedSql, newBoundSql.getParameterMappings()),
                originalMs.getSqlCommandType()
        );
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">复制重要属性</span>
<span style="color: rgba(0, 0, 0, 1)">        builder.resource(originalMs.getResource())
                .fetchSize(originalMs.getFetchSize())
                .timeout(originalMs.getTimeout())
                .statementType(originalMs.getStatementType())
                .keyGenerator(originalMs.getKeyGenerator())
                .keyProperty(originalMs.getKeyProperties() </span>== <span style="color: rgba(0, 0, 255, 1)">null</span> ? <span style="color: rgba(0, 0, 255, 1)">null</span> : String.join(","<span style="color: rgba(0, 0, 0, 1)">, originalMs.getKeyProperties()))
                .resultMaps(resultMap </span>== <span style="color: rgba(0, 0, 255, 1)">null</span> ?<span style="color: rgba(0, 0, 0, 1)"> originalMs.getResultMaps() : Collections.singletonList(resultMap))
                .parameterMap(originalMs.getParameterMap())
                .resultSetType(originalMs.getResultSetType())
                .cache(originalMs.getCache())
                .flushCacheRequired(originalMs.isFlushCacheRequired())
                .useCache(originalMs.isUseCache());
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> builder.build();
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 获取分页参数
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> Page&lt;?&gt;<span style="color: rgba(0, 0, 0, 1)"> getPageParameter(Object parameter) {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (parameter <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Map) {
            Map</span>&lt;?, ?&gt; paramMap = (Map&lt;?, ?&gt;<span style="color: rgba(0, 0, 0, 1)">) parameter;
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> (Page&lt;?&gt;<span style="color: rgba(0, 0, 0, 1)">) paramMap.values().stream()
                    .filter(p </span>-&gt; p <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Page)
                    .findFirst()
                    .orElse(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> parameter <span style="color: rgba(0, 0, 255, 1)">instanceof</span> Page ? (Page&lt;?&gt;) parameter : <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 获取Mapper方法
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> Method getMapperMethod(MappedStatement ms) {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            String methodName </span>= ms.getId().substring(ms.getId().lastIndexOf(".") + 1<span style="color: rgba(0, 0, 0, 1)">);
            Class</span>&lt;?&gt; mapperClass = Class.forName(ms.getId().substring(0, ms.getId().lastIndexOf("."<span style="color: rgba(0, 0, 0, 1)">)));
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> Arrays.stream(mapperClass.getMethods())
                    .filter(m </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> m.getName().equals(methodName))
                    .findFirst()
                    .orElse(</span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (ClassNotFoundException e) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
        }
    }
}</span></pre>
</div>
<h3>注意事项</h3>
<p>有人可能会担心并行查询，在高并发场景可能会导致count查询与limit数据查询不一致，但其实只要没有锁，只要是分开的两条sql查询，原mybatisplus分页插件也一样面临这个问题。</p>
<p>count优化没有进行join语句判断优化，相当于主动关闭了page.setOptimizeJoinOfCountSql(false);在一对多等场景可能会造成count查询有误，Mybatisplus官网也有相关提示，所以这里干脆舍弃了。</p>
<p>mybatisplus版本不同，可能会导致JsqlParser所使用的api有所不同，需要自己对应版本修改下。本篇版本使用的3.5.1</p>
<p>关于线程池的线程数设置顺便提一下：</p>
<p>网上流行一个说法：</p>
<p>1. CPU 密集型任务</p>
<p>特点：任务主要消耗 CPU 资源（如复杂计算、图像处理）。</p>
<p>线程数建议：</p>
<ul>
<li>核心线程数：CPU 核心数 + 1（或等于CPU核心数，避免上下文切换过多）。</li>
<li>最大线程数：与核心线程数相同（防止过多线程竞争 CPU）。</li>
</ul>
<p>2. I/O 密集型任务</p>
<p>特点：任务涉及大量等待（如网络请求、数据库读写）。</p>
<p>线程数建议：</p>
<ul>
<li>核心线程数：2 * CPU 核心数（确保正常负载下的高效处理）。</li>
<li>最大线程数：根据系统资源调整（用于应对突发高并发）。</li>
</ul>
<p>其实这个说法来源于一个经验公式推导而来：</p>
<p><strong>threads = CPU核心数 * (1 + 平均等待时间 / 平均计算时间)</strong></p>
<p>《Java 虚拟机并发编程》中介绍</p>
<p><img src="https://img2024.cnblogs.com/blog/1401949/202504/1401949-20250427154502609-36026922.png" alt="" width="622" height="505" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1401949/202504/1401949-20250427154542726-1403905285.png" alt="" width="611" height="138" loading="lazy"></p>
<p>&nbsp;</p>
<p>另一篇：《Java Concurrency in Practice》即《java并发编程实践》，给出的线程池大小的估算公式：</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1401949/202504/1401949-20250427154624272-747792643.png" alt="" width="627" height="325" loading="lazy"></p>
<p>Nthreads=Ncpu*Ucpu*(1+w/c)，其中 Ncpu=CPU核心数，Ucpu=cpu使用率，0~1；W/C=等待时间与计算时间的比率</p>
<p>仔细推导两个公式，其实类似，在cpu使用率达100%时，其实结论是一致的，这时候计算线程数的公式就成了，Nthreads=Ncpu*100%*(1+w/c) =Ncpu*(1+w/c)。</p>
<p>那么在实践应用中计算的公式就出来了，【以下推算，不考虑内存消耗等方面】，如下：</p>
<p>1、针对IO密集型，阻塞耗时w一般都是计算耗时几倍c，假设阻塞耗时=计算耗时的情况下，Nthreads=Ncpu*(1+1)=2Ncpu,所以这种情况下，建议考虑2倍的CPU核心数做为线程数</p>
<p>2、对于计算密集型，阻塞耗时趋于0，即w/c趋于0，公式Nthreads = Ncpu。</p>
<p>实际应用时要考虑同时设置了几个隔离线程池，另外tomcat自带的线程池也会共享宿主机公共资源。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5137318001388889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-27 15:56">2025-04-27 15:55</span>&nbsp;
<a href="https://www.cnblogs.com/better-farther-world2099">字节悦动</a>&nbsp;
阅读(<span id="post_view_count">120</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18849712);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18849712', targetLink: 'https://www.cnblogs.com/better-farther-world2099/p/18849712', title: 'springboot分页查询并行优化实践' })">举报</a>
</div>
        