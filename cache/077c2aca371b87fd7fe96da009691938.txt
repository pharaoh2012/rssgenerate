
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/charlee44/p/18926136" title="发布于 2025-06-12 20:51">
    <span role="heading" aria-level="2">给Markdown渲染网页增加一个目录组件(Vite+Vditor+Handlebars)(上)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        详细介绍了通过Vditor渲染Markdown文档成Web页面之后，增加一个目录组件的功能实现，并给出了具体的代码。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-引言">1 引言</h1>
<p>在上一篇文章<a href="https://charlee44.com/post.html?id=5a687db237594d3b92bc59deaf733e8a" target="_blank" rel="noopener nofollow">《解决Vditor加载Markdown网页很慢的问题(Vite+JS+Vditor)》</a>中，我们通过设置域内CDN的方式解决Vditor加载Markdown网页很慢的问题。而在这篇文章中，笔者将会开发实现一个前端中很常见的需求：给基于Markdown渲染的文档网页增加一个目录组件。</p>
<p>需要说明的是，原生的Markdown标准并没有规定生成目录的写法，但是国内的博文网站似乎都支持一个拓展来实现目录的生成：</p>
<pre><code class="language-markdown">[toc]
</code></pre>
<p>但是这样生成的目录是通常是位于文章页面的最上方，这样就失去了目录的意义。比较好的实现是像CSDN或者掘金一样，额外生成一个目录组件，并且固定在侧栏上方。这样可以在浏览文章的时候，随时定位所在的目录；同时还可以使用目录来导航。</p>
<p><img src="https://img2024.cnblogs.com/blog/1000410/202506/1000410-20250612205050047-1371722112.png" alt="掘金博文侧栏的目录组件，固定在网页右上方" loading="lazy"></p>
<p>阅读本文可能需要的前置文章：</p>
<ul>
<li><a href="https://charlee44.com/post.html?id=24b7a11791a04cf1b19df9c1fec00787" target="_blank" rel="noopener nofollow">《通过JS模板引擎实现动态模块组件(Vite+JS+Handlebars)》</a></li>
<li><a href="https://charlee44.com/post.html?id=4e2dcb7eb0804019b5f1caa65f4531b6" target="_blank" rel="noopener nofollow">《使用Vditor将Markdown文档渲染成网页(Vite+JS+Vditor)》</a></li>
</ul>
<h1 id="2-详叙">2 详叙</h1>
<h2 id="21-整体结构">2.1 整体结构</h2>
<p>将渲染Markdown文档的部分封装成单独的组件（post-article.js、post-article.handlebars和post-article.css），增加一个文章目录组件（post-toc.js、post-toc.handlebars、post-toc.css）。另外post-data.json是我们提前准备的博客文章，里面除了保存有Markdown格式的文档字符串，还有一些文章的相关数据；1.png和2.png则是文章中图片。项目组织结构如下：</p>
<p>my-native-js-app/<br>
├── public/<br>
│   ├── 1.png<br>
│   ├── 2.png<br>
│   └── post-data.json<br>
├── src/<br>
│   ├── components/<br>
│   │   ├── post-article.css<br>
│   │   ├── post-article.handlebars<br>
│   │   ├── post-article.js<br>
│   │   ├── post-toc.css<br>
│   │   ├── post-toc.handlebars<br>
│   │   └── post-toc.js<br>
│   ├── main.js<br>
│   └── style.css<br>
├── index.html<br>
└── package.json</p>
<p>还是按照代码的执行顺序来介绍这个功能的实现。首先还是index.html：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;Vite App&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id="app"&gt;
    &lt;div id="post-article-placeholder"&gt;&lt;/div&gt;
    &lt;div id="article-toc-placeholder"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>主要就是增加了post-article-placeholder和article-toc-placeholder这两个元素，分别作为Markdown博文和博文目录的容器。其实这里面还有个页面布局的问题，不过这个问题我们下一篇文章再说。这里还是先看main.js：</p>
<pre><code class="language-javascript">import "./style.css";
import "./components/post-article.js";
</code></pre>
<h2 id="22-博文内容组件">2.2 博文内容组件</h2>
<p>引用了post-article.js，也就是Markdown博文内容组件。那么就进入post-article.js：</p>
<pre><code class="language-js">import "./post-article.css";
import { CreateTocPanel } from "./post-toc.js";
import Handlebars from "handlebars";
import templateSource from "./post-article.handlebars?raw";

import "vditor/dist/index.css";
import Vditor from "vditor";

// 初始化文章标签面板
async function InitializePostArticlePanel() {
  try {   
    const response = await fetch("/post-data.json");
    if (!response.ok) {
      throw new Error("网络无响应");
    }
    const blogData = await response.json();
  
    // 编译模板
    const template = Handlebars.compile(templateSource);

    // 渲染模板
    const renderedHtml = template({
      blogMeta: blogData.blogMeta,
    });

    // 将渲染好的HTML插入到页面中
    document.getElementById("post-article-placeholder").innerHTML =
      renderedHtml;

    // 显示内容
    Vditor.preview(document.getElementById("post-content"), blogData.content, {
      cdn: window.location.origin,
      markdown: {
        toc: false,
        mark: true, //==高亮显示==
        footnotes: true, //脚注
        autoSpace: true, //自动空格，适合中英文混合排版
      },
      math: {
        engine: "KaTeX", //支持latex公式
        inlineDigit: true, //内联公式可以接数字
      },
      hljs: {
        style: "github", //代码段样式
        lineNumber: true, //是否显示行号
      },
      anchor: 2, // 为标题添加锚点 0：不渲染；1：渲染于标题前；2：渲染于标题后
      lang: "zh_CN", //中文
      theme: {
        current: "light", //light,dark,light,wechat
      },
      lazyLoadImage:
        "https://cdn.jsdelivr.net/npm/vditor/dist/images/img-loading.svg",
      transform: (html) =&gt; {
        // 使用正则表达式替换图片路径，并添加居中样式及题注
        return html.replace(
          /&lt;img\s+[^&gt;]*src="\.\/([^"]+)\.([a-zA-Z0-9]+)"\s*alt="([^"]*)"[^&gt;]*&gt;/g,
          (match, p1, p2, altText) =&gt; {
            // const newSrc = `${backendUrl}/blogs/resources/images/${postId}/${p1}.${p2}`;
            const newSrc = `${p1}.${p2}`;
            const imgWithCaption = `
                    &lt;div style="text-align: center;"&gt;
                        &lt;img src="${newSrc}" class="center-image" alt="${altText}"&gt;
                        &lt;p class="caption"&gt;${altText}&lt;/p&gt;
                    &lt;/div&gt;
                    `;
            return imgWithCaption;
          }
        );
      },
      after() {
        CreateTocPanel();
      },
    });
  } catch (error) {
    console.error("获取博客失败:", error);
  }
}

document.addEventListener("DOMContentLoaded", InitializePostArticlePanel);
</code></pre>
<p>post-article.js中的内容改进自<a href="https://charlee44.com/post.html?id=24b7a11791a04cf1b19df9c1fec00787" target="_blank" rel="noopener nofollow">《通过JS模板引擎实现动态模块组件(Vite+JS+Handlebars)》</a>中的案例，不过略有不同。首先是获取博文数据：</p>
<pre><code class="language-js">const response = await fetch("/post-data.json");
if (!response.ok) {
    throw new Error("网络无响应");
}
const blogData = await response.json();

// 编译模板
const template = Handlebars.compile(templateSource);

// 渲染模板
const renderedHtml = template({
    blogMeta: blogData.blogMeta,
});

// 将渲染好的HTML插入到页面中
document.getElementById("post-article-placeholder").innerHTML =
    renderedHtml;
</code></pre>
<p>在实际项目开发中，应该是从远端API获取数据，这里进行了简化，将数据提前准备好了放置在域内。然后，将这个数据与编译的Handlebars模板一起渲染成HTML元素。从下面的post-article.handlebars中可以看到，博文组件中内容不仅包含Markdown博文内容元素，还有诸如时间、统计信息、标签等元素：</p>
<pre><code class="language-html">&lt;div id="main-content"&gt;
    &lt;h1 id="post-title"&gt;{{blogMeta.title}}&lt;/h1&gt;
    &lt;div class="post-stats"&gt;
        &lt;span class = "post-stat"&gt;
            &lt;span&gt;📝&lt;/span&gt;&lt;span class = "text"&gt;已于&lt;/span&gt;{{blogMeta.createdTime}}&lt;span class = "text"&gt;修改&lt;/span&gt;
        &lt;/span&gt;
        &lt;span class = "post-stat"&gt;
            &lt;span&gt;👁️&lt;/span&gt;{{blogMeta.postStats.viewCount}}&lt;span class = "text"&gt;阅读&lt;/span&gt;
        &lt;/span&gt;
        &lt;span class = "post-stat"&gt;
            &lt;span&gt;👍&lt;/span&gt;{{blogMeta.postStats.likeCount}}&lt;span class = "text"&gt;点赞&lt;/span&gt;
        &lt;/span&gt;
        &lt;span class = "post-stat"&gt;
            &lt;span&gt;💬&lt;/span&gt;{{blogMeta.postStats.commentCount}}&lt;span class = "text"&gt;评论&lt;/span&gt;
        &lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="post-tags"&gt;
        &lt;span class = "tags-title"&gt;
            &lt;span&gt;🔖&lt;/span&gt;&lt;span class = "text"&gt;文章标签&lt;/span&gt;
        &lt;/span&gt;
        {{#each blogMeta.tagNames}}
        &lt;span class = "post-tag"&gt;{{this}}&lt;/span&gt;
        {{/each}}
    &lt;/div&gt;
    &lt;div class="post-categories"&gt;
        专栏
        {{#each blogMeta.categoryNames}}
        &lt;span&gt; {{this}} &lt;/span&gt;
        {{/each}}
        收录该内容
    &lt;/div&gt;
    &lt;div id="post-content"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Markdown博文内容元素是使用Vditor来渲染初始化的，这一点与之前的案例一样。不同的是增加了一个<code>after</code>配置：</p>
<pre><code class="language-js">import { CreateTocPanel } from "./post-toc.js";

//...

after() {
    CreateTocPanel();
},
</code></pre>
<p>这个<code>after</code>配置的意思是当Vditor渲染完成以后，就立刻执行<code>CreateTocPanel()</code>函数，这个函数来自于博文目录组件post-toc.js，表示要开始创建博文目录了。</p>
<h2 id="22-博文目录组件">2.2 博文目录组件</h2>
<p>post-toc.js中的代码如下所示：</p>
<pre><code class="language-js">import "./post-toc.css";

import Handlebars from "handlebars";
import templateSource from "./post-toc.handlebars?raw";

export function CreateTocPanel() {
  const headings = document.querySelectorAll(
    "#post-content h1, #post-content h2, #post-content h3"
  );

  const tocContent = [];
  headings.forEach((heading, index) =&gt; {
    const content = {};
    content["id"] = heading.id;
    content["title"] = heading.textContent;
    const marginLeft =
      heading.tagName === "H2" ? 20 : heading.tagName === "H3" ? 40 : 0;
    content["marginLeft"] = marginLeft;
    tocContent.push(content);
  });

  // 编译模板
  const template = Handlebars.compile(templateSource);

  // 渲染模板
  const renderedHtml = template({
    tocContent,
  });

  // 将渲染好的HTML插入到页面中
  const articleTocPlaceholder = document.getElementById(
    "article-toc-placeholder"
  );
  articleTocPlaceholder.innerHTML = renderedHtml;

  // 联动：滚动时同步激活目录项
  window.addEventListener("scroll", () =&gt; {
    let activeHeading;
    headings.forEach((heading) =&gt; {
      const rect = heading.getBoundingClientRect();
      if (rect.top &gt;= 0 &amp;&amp; rect.top &lt;= window.innerHeight / 2) {
        activeHeading = heading;
      }
    });

    if (activeHeading) {
      document
        .querySelectorAll(".toc-sidebar .toc a")
        .forEach((link) =&gt; link.classList.remove("active"));     
      const escapedId = CSS.escape(activeHeading.id); //安全地转义选择器中的特殊字符
      const activeLink = document.querySelector(
        `.toc-sidebar .toc a[href="#${escapedId}"]`
      );
      if (activeLink) activeLink.classList.add("active");
    }
  });
}
</code></pre>
<p>这段代码是实现博文目录功能的关键代码。首先，搜索查询渲染成HTML形式的博文内容中的标题元素<code>h1</code>、<code>h2</code>和<code>h3</code>：</p>
<pre><code class="language-js">const headings = document.querySelectorAll(
    "#post-content h1, #post-content h2, #post-content h3"
  );
</code></pre>
<p>然后提取出关键数据：</p>
<pre><code class="language-js">const tocContent = [];
  headings.forEach((heading, index) =&gt; {
    const content = {};
    content["id"] = heading.id;
    content["title"] = heading.textContent;
    const marginLeft =
      heading.tagName === "H2" ? 20 : heading.tagName === "H3" ? 40 : 0;
    content["marginLeft"] = marginLeft;
    tocContent.push(content);
  });
</code></pre>
<p>将其传入Handlebars模板进行渲染：</p>
<pre><code class="language-js">// 编译模板
  const template = Handlebars.compile(templateSource);

  // 渲染模板
  const renderedHtml = template({
    tocContent,
  });

  // 将渲染好的HTML插入到页面中
  const articleTocPlaceholder = document.getElementById(
    "article-toc-placeholder"
  );
  articleTocPlaceholder.innerHTML = renderedHtml;
</code></pre>
<p>模板post-toc.handlebars中的内容非常简单：</p>
<pre><code class="language-html">&lt;div class="toc-sidebar"&gt;
    &lt;div class="toc"&gt;
        &lt;h3&gt;文章目录&lt;/h3&gt;
        &lt;ul&gt;
            {{#each tocContent}}
            &lt;li style="margin-left: {{marginLeft}}px;"&gt;
                &lt;a href="#{{id}}" class=""&gt;
                    {{title}}
                &lt;/a&gt;
            &lt;/li&gt;
            {{/each}}
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>可以看到这里能够获取一级、二级还有三级标题，通过样式的缩进（<code>margin-left</code>）来体现标题的不同。另外，href属性的设置也保证了能通过点击来实现跳转。</p>
<p>最后实现联动，通过文章标题元素范围的判定，来高亮目录中标题元素的样式，让用户直到浏览到博文中的哪一段了：</p>
<pre><code class="language-js">// 联动：滚动时同步激活目录项
  window.addEventListener("scroll", () =&gt; {
    let activeHeading;
    headings.forEach((heading) =&gt; {
      const rect = heading.getBoundingClientRect();
      if (rect.top &gt;= 0 &amp;&amp; rect.top &lt;= window.innerHeight / 2) {
        activeHeading = heading;
      }
    });

    if (activeHeading) {
      document
        .querySelectorAll(".toc-sidebar .toc a")
        .forEach((link) =&gt; link.classList.remove("active"));     
      const escapedId = CSS.escape(activeHeading.id); //安全地转义选择器中的特殊字符
      const activeLink = document.querySelector(
        `.toc-sidebar .toc a[href="#${escapedId}"]`
      );
      if (activeLink) activeLink.classList.add("active");
    }
  });
</code></pre>
<h1 id="3-结语">3 结语</h1>
<p>最终实现的效果如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1000410/202506/1000410-20250612205028089-1058512188.png" alt="博文目录组件最终效果" loading="lazy"></p>
<p>虽然功能大致实现了，不过还有一些问题没有说清楚，比如在浏览文章的过程中，博文目录是如何始终保证黏在页面的右上角的？这个问题就放在下篇中继续论述了。</p>
<p><a href="https://download.csdn.net/download/charlee44/90987246" target="_blank" rel="noopener nofollow">实现代码</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-12 20:52">2025-06-12 20:51</span>&nbsp;
<a href="https://www.cnblogs.com/charlee44">charlee44</a>&nbsp;
阅读(<span id="post_view_count">127</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18926136);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18926136', targetLink: 'https://www.cnblogs.com/charlee44/p/18926136', title: '给Markdown渲染网页增加一个目录组件(Vite+Vditor+Handlebars)(上)' })">举报</a>
</div>
        