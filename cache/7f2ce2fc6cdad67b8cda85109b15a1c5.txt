
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/DOMLX/p/18785484" title="发布于 2025-03-21 17:26">
    <span role="heading" aria-level="2">halcon 入门教程（五） 缺陷检测</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-size: 14pt">原文作者：aircraft</span></p>
<p><span style="font-size: 14pt">原文链接：<a href="https://www.cnblogs.com/DOMLX/p/18785484" target="_blank">https://www.cnblogs.com/DOMLX/p/18785484</a></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<span style="font-size: 18px">有兴趣可以多看其他的halcon教程</span></p>
<p><span style="font-size: 18pt">&nbsp;<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-18 17:21" href="https://www.cnblogs.com/DOMLX/p/18779348">halcon 学习教程目录</a></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">　　　　　　　　　　本篇主要讲一些常见的缺陷检测方法，目前只会讲一些，后面有空的话会不断的补充完整。因为缺陷的种类实在太多太多了，各种各样的缺陷可能都要用各种不同的检测方法去检测，所以想要精通缺陷检测特别难，基本大家都是熟悉自己经常遇到的缺陷领域。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第一种：就是最常见的Blob分析加上特征提取（<span style="font-size: 18px">本篇也会多给一些这个示例。因为确实是最基础也是最常用的，用的好你可能百分之八九十的缺陷都可以检测，主要还是看对这块的理解</span>）</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第二种：图像匹配定位后再加Blob分析，可以结合本篇的Blob分析和我下一篇的：<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-20 17:14" href="https://www.cnblogs.com/DOMLX/p/18783476"><span>halcon 入门教程（六） 图像匹配（基于形状的模板匹配）与缺陷检测区域定位</span></a></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第三种：建立模板区域的差异模型，原理就是后面所有的产品都与一个标准品做差异模型，可以差异的程度对其判断NG,OK。可以看我这篇博客理解：<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-02-26 17:38" href="https://www.cnblogs.com/DOMLX/p/18739196"><span>halcon 入门教程 （七） halcon中是怎么实现半导体/Led中的GoldenDie的检测方法的 基于局部可变形模板匹配 variation_model模型</span></a></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第四种：光度立体法（基本属于2.5d的视觉范围了，适用于一些物体表面有凹凸情况下的检测，通过多个角度方向的打光图片，来获取伪3d的信息进行缺陷检测）</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第五种：<span style="font-size: 18px">图像匹配定位后</span>再加测量（比如一些钢管，或者元器件表面的某个东西的长度，宽度，厚度，半径之类的达不达标），可以结合<span style="font-size: 18px"><a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-20 17:14" href="https://www.cnblogs.com/DOMLX/p/18783476">halcon 入门教程（六） 图像匹配（基于形状的模板匹配）与缺陷检测区域定位 </a>和 <a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-02-27 17:12" href="https://www.cnblogs.com/DOMLX/p/18740576"><span>halcon 入门教程（三） 测量量测相关（点到线距离，线到线距离，轮廓线距离，一维测量，圆形测量，矩形测量等）</span></a><span>这两篇来看，组合起来基本就是这种检测方法了。</span></span></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span><span style="font-size: 18px">第六种：机器学习和深度学习的缺陷检测（基本都是通过标记好的和坏的训练集，给神经网络程序训练学习，学习成功后，后面只要传入该产品图，或者某个区域图，便可以直接给出判断好坏，甚至处理一下可以把具体缺陷都标注显示出来）</span></span></span></span></p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span><span style="font-size: 18px">有兴趣可以看看我这篇博客：<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-11 21:09" href="https://www.cnblogs.com/DOMLX/p/18766108"><span>halcon 深度学习教程（一）分类检测 （工业里如何使用halcon深度学习去检测分类产品）</span></a></span></span></span></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px">第七种：空域和频域分析（适用于一些像皮革，木材，纹理石板之类的对比度低的产品上去进行检测）</span></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px">第八种：三维重建后再加特征提取（属于3d视觉的领域了，会多一些诸如高度或者说深度信息）</span></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">　　　下面一些算子的原型我就不介绍了，有看过前面教程的应该都认识这些常用的算子了。而且每个示例代码我都打了非常详细的注释，基本看着注释应该是可以理解的吧。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">一.Blob分析加上特征提取</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px">示例1：榛子威化饼的质量检测&nbsp;&nbsp;&nbsp;</span></strong></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321152326495-195477518.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">OK图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321152343581-391245996.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">NG图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321152354985-119199458.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">示例代码：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* ​*************************************************************
*<span style="color: rgba(0, 0, 0, 1)"> 本程序演示针对榛子威化饼的质量检测
</span>*<span style="color: rgba(0, 0, 0, 1)"> 检测方法：基于形态学处理提取目标区域，通过孔洞面积和矩形度进行缺陷判断
</span>*<span style="color: rgba(0, 0, 0, 1)"> 工业应用：食品包装完整性检测（破损、变形检测）
</span>* 检测标准：孔洞面积&gt;<span style="color: rgba(128, 0, 128, 1)">300</span> 或 矩形度&lt;<span style="color: rgba(128, 0, 128, 1)">0.92</span><span style="color: rgba(0, 0, 0, 1)"> 判定为不合格
</span>* ​*************************************************************

*<span style="color: rgba(0, 0, 0, 1)"> 初始化图像和显示窗口
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">food/hazelnut_wafer_01</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 关闭可能存在的旧窗口
dev_close_window ()
</span>*<span style="color: rgba(0, 0, 0, 1)"> 创建自适应图像尺寸的显示窗口
dev_open_window_fit_image (Image, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, -<span style="color: rgba(128, 0, 128, 1)">1</span>, -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">, WindowHandle)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 禁止窗口自动更新（提升执行效率）
dev_update_window (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置可视化参数
</span>*<span style="color: rgba(0, 0, 0, 1)"> 线宽3像素用于突出显示轮廓
dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 轮廓显示模式（节省显示资源）
dev_set_draw (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">margin</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置等宽字体便于字符对齐
set_display_font (WindowHandle, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mono</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 处理24张连续拍摄的威化饼图像
</span><span style="color: rgba(0, 0, 255, 1)">for</span> Index := <span style="color: rgba(128, 0, 128, 1)">1</span> to <span style="color: rgba(128, 0, 128, 1)">2</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
    * 读取序列图像（文件名格式：1~2.bmp<span style="color: rgba(0, 0, 0, 1)">）
    
    read_image (Image, Index</span>+<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">.bmp</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 图像预处理
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 使用直方图平滑法进行二值化（适合低对比度场景）
    binary_threshold (Image, Foreground, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">smooth_histo</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">light</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, UsedThreshold)
    </span>* <span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">.5像素半径开运算去除毛刺和小孔洞
    opening_circle (Foreground, FinalRegion, </span><span style="color: rgba(128, 0, 128, 1)">8.5</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 特征提取
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算区域内部孔洞总面积（关键缺陷指标）
    area_holes (FinalRegion, AreaHoles)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算区域矩形度（1为完美矩形，值越小变形越严重）
    rectangularity (FinalRegion, Rectangularity)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像
    dev_display (Image)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 质量判定逻辑
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 孔洞超标或形状变形时显示红色报警
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (AreaHoles &gt; <span style="color: rgba(128, 0, 128, 1)">300</span> or Rectangularity &lt; <span style="color: rgba(128, 0, 128, 1)">0.92</span><span style="color: rgba(0, 0, 0, 1)">)
        dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        Text :</span>= <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">Not OK</span><span style="color: rgba(128, 0, 0, 1)">'</span>
    *<span style="color: rgba(0, 0, 0, 1)"> 合格产品显示绿色轮廓
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
        dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">forest green</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        Text :</span>= <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">OK</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">
    endif
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示检测结果
    dev_display (FinalRegion)
    </span>* 在窗口左上角显示OK/<span style="color: rgba(0, 0, 0, 1)">NG状态
    disp_message (WindowHandle, Text, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">window</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 0, 1)">''</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 非最后一张图像时暂停观察
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (Index &lt; <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">)
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示继续检测提示
        disp_continue_message (WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        stop ()  
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 模拟产线节拍控制
    endif
endfor</span></span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong><span style="font-size: 18px">示例2：鳍片检测程序（fin.hdev）&nbsp; 利用形态学分析与差异模型检测</span></strong></span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321154252978-255316756.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">两张边缘有凸出的图片：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321154320324-845677511.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321154327493-531558481.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">&nbsp;通过提取白色背景区域，然后进行闭运算将区域边缘小凸出闭合，然后与原始区域做个差异，得到缺陷位置，在进行开运算，消除多提出来的边的区域。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321154607162-2081274988.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>结果图：</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321154539299-1174161501.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">实例代码：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* ​*************************************************************
*<span style="color: rgba(0, 0, 0, 1)"> 鳍片检测程序（fin.hdev）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 功能：通过形态学处理检测金属鳍片缺陷
</span>*<span style="color: rgba(0, 0, 0, 1)"> 检测逻辑：
</span>*   <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 二值化分离前景
</span>*   <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 闭运算填充结构间隙
</span>*   <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 差异检测潜在缺陷区域
</span>*   <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">. 开运算去除噪声
</span>*<span style="color: rgba(0, 0, 0, 1)"> 工业应用：散热器制造质检
</span>* ​*************************************************************

*<span style="color: rgba(0, 0, 0, 1)"> 关闭窗口自动刷新（提升执行效率）
dev_update_window (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 读取鳍片图像序列（fin2, fin3）
read_image (Fins, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">fin</span><span style="color: rgba(128, 0, 0, 1)">'</span> + [<span style="color: rgba(128, 0, 128, 1)">2</span>:<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">])

</span>*<span style="color: rgba(0, 0, 0, 1)"> 初始化显示窗口
get_image_size (Fins, Width, Height)
dev_close_window ()
</span>*<span style="color: rgba(0, 0, 0, 1)"> 创建与图像等大的黑色背景窗口
dev_open_window (</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, Width[<span style="color: rgba(128, 0, 128, 1)">0</span>], Height[<span style="color: rgba(128, 0, 128, 1)">0</span>], <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, WindowID)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置等宽字体便于信息对齐
set_display_font (WindowID, </span><span style="color: rgba(128, 0, 128, 1)">14</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mono</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 遍历处理3个检测对象（实际图像为2张，索引从1开始）
</span><span style="color: rgba(0, 0, 255, 1)">for</span> I := <span style="color: rgba(128, 0, 128, 1)">1</span> to <span style="color: rgba(128, 0, 128, 1)">2</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
    *<span style="color: rgba(0, 0, 0, 1)"> 选择当前处理对象
    select_obj (Fins, Fin, I)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像
    dev_display (Fin)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 步骤1：二值化分割（最大化前景背景可分性）
    binary_threshold (Fin, Background, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">max_separability</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">light</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, UsedThreshold)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 蓝色显示初始分割结果
    dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">blue</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    dev_set_draw (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">margin</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">)
    dev_display (Background)
    disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    stop ()  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 质检员确认阶段结果
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 步骤2：大半径闭运算填充结构间隙
    closing_circle (Background, ClosedBackground, </span><span style="color: rgba(128, 0, 128, 1)">250</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 绿色显示填充后区域
    dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">green</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    dev_display (ClosedBackground)
    disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    stop ()  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 确认形态学处理效果
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 步骤3：差异检测（理想结构与实际结构对比）
    difference (ClosedBackground, Background, RegionDifference)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 步骤4：开运算去除微小噪声
    opening_rectangle1 (RegionDifference, FinRegion, </span><span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示最终检测结果
    dev_display (Fin)        
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 原始图像背景
    dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 红色高亮缺陷
    dev_display (FinRegion)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 叠加缺陷区域
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算缺陷区域特征
    area_center (FinRegion, FinArea, Row, Column)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 非最后一张图像时暂停
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (I &lt; <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">)
        disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        stop ()  
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 模拟产线节拍等待
    endif
endfor</span></span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><strong><span style="font-size: 18px">示例3：塑料网缺陷检测程序&nbsp;&nbsp; 使用动态阈值检测塑料网中的异常纹理区域&nbsp;&nbsp;&nbsp;&nbsp; 原图与均值图比对 提取出比均值图还暗的多的缺陷区域出来</span></strong></span></span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321160913870-872177784.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">两张测试的原图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321160934377-1329337359.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321160939410-27556241.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">实例代码：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* ​*************************************************************
*<span style="color: rgba(0, 0, 0, 1)"> 塑料网缺陷检测程序
</span>*<span style="color: rgba(0, 0, 0, 1)"> 功能：使用动态阈值检测塑料网中的异常纹理区域
</span>*<span style="color: rgba(0, 0, 0, 1)"> 检测逻辑：
</span>*   <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 图像平滑处理消除纹理干扰
</span>*   <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 动态阈值分割异常区域
</span>*   <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 连通域分析与面积筛选
</span>*<span style="color: rgba(0, 0, 0, 1)"> 工业应用：塑料编织品质量检测
</span>* ​*************************************************************

*<span style="color: rgba(0, 0, 0, 1)"> 关闭窗口自动更新（提升执行效率）
dev_update_window (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 读取塑料网基准图像（用于窗口初始化）
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastic_mesh_</span><span style="color: rgba(128, 0, 0, 1)">'</span>+[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">])

</span>*<span style="color: rgba(0, 0, 0, 1)"> 初始化显示窗口
dev_close_window ()
get_image_size (Image, Width, Height)
dev_open_window_fit_image (Image, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height, WindowHandle)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置可视化参数
</span>*<span style="color: rgba(0, 0, 0, 1)"> 等宽字体便于信息对齐
set_display_font (WindowHandle, </span><span style="color: rgba(128, 0, 128, 1)">18</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mono</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 轮廓显示模式（节省显示资源）
dev_set_draw (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">margin</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置检测结果轮廓线宽
dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 处理两张塑料网图像序列
</span><span style="color: rgba(0, 0, 255, 1)">for</span> J := <span style="color: rgba(128, 0, 128, 1)">1</span> to <span style="color: rgba(128, 0, 128, 1)">2</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
    * 读取当前检测图像（文件名格式：plastic_mesh_1.bmp~<span style="color: rgba(0, 0, 0, 1)">plastic_mesh_2.bmp）
    read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastic_mesh_</span><span style="color: rgba(128, 0, 0, 1)">'</span> + J+<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">.bmp</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 图像预处理：49x49均值滤波（消除高频纹理干扰）
    mean_image (Image, ImageMean, </span><span style="color: rgba(128, 0, 128, 1)">49</span>, <span style="color: rgba(128, 0, 128, 1)">49</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 动态阈值分割（检测比背景暗5个灰度级的异常区域）
    dyn_threshold (Image, ImageMean, RegionDynThresh, </span><span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">dark</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 连通域分析（分离独立缺陷区域）
    connection (RegionDynThresh, ConnectedRegions)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 面积筛选（过滤500像素以下的噪声）
    select_shape (ConnectedRegions, ErrorRegions, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">area</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">and</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">500</span>, <span style="color: rgba(128, 0, 128, 1)">99999</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 统计缺陷数量
    count_obj (ErrorRegions, NumErrors)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像和检测结果
    dev_display (Image)
    dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 红色高亮缺陷
    dev_display (ErrorRegions)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 判定结果输出
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (NumErrors &gt; <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示NG标识（位置：第24行，第12列）
        disp_message (WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">Mesh not OK</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">window</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">24</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">else</span>
        *<span style="color: rgba(0, 0, 0, 1)"> 显示OK标识
        disp_message (WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">Mesh OK</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">window</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">24</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    endif
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 非最后一张图像时显示继续提示
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (J &lt; <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">)
        disp_continue_message (WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        stop ()  
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 模拟产线节拍控制
    endif
endfor</span></span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18px">结果图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321161024014-1146257401.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321161034855-423075512.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">OK，这里先写这几个，还有更多的都在halcon的官方案例集里，右边那一堆都是。</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321161250030-1214662284.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong><span style="font-size: 18pt">二.空域和频域结合的缺陷检测</span></strong></span></p>
<p><span style="font-size: 18px">这里主要的案例都来自halcon程序集的快速傅里叶变换，有兴趣详细了解的，就可以去看看。就如我一直在说的，halcon里的实例就是自己最好的老师。</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321162319063-1191923492.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">先大概了解一下这个东西：</span></p>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>一、图像的两个视角：空间域 vs 频域</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 空间域（你看到的图像）​</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>是什么</strong>：图像由像素组成，每个像素代表某个位置的亮度值。</span></li>
<li><span style="font-size: 18px">​<strong>直观理解</strong>：就像你看到的一张照片，每个点直接显示颜色或明暗。</span></li>
<li><span style="font-size: 18px">​<strong>工业应用</strong>：直接观察表面划痕、颜色异常等（但复杂纹理中的小缺陷难以直接看到）。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>2. 频域（图像的“成分分析”）​</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>是什么</strong>：将图像分解为不同频率的波（高频=细节/边缘，低频=整体形状）。</span></li>
<li><span style="font-size: 18px">​<strong>直观理解</strong>：像把音乐分解成不同频率的音符，高频是鼓点，低频是贝斯。</span></li>
<li><span style="font-size: 18px">​<strong>工业应用</strong>：检测周期性纹理中的异常（如织物瑕疵、注塑件表面缺陷）。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>二、快速傅里叶变换（FFT）是什么？</strong></span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>核心作用</strong>：快速将图像从空间域转换到频域（反之亦可）。</span></li>
<li><span style="font-size: 18px">​<strong>为什么快</strong>：优化算法，计算复杂度从O(n²)降到O(n log n)，适合实时检测。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>三、HALCON中的FFT操作步骤（以检测塑料表面缺陷为例）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 读取图像</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">read_image (Image, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastics_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  * 读取塑料件表面图像</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>2. 转换到频域</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 执行FFT（空间域→频域）
fft_image (Image, ImageFFT)  </span>* 输出是复数图像（实部+虚部）</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>3. 频域滤波（增强缺陷）​</strong></span></h4>
<p><span style="font-size: 18px">&nbsp;</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 生成高斯低通滤波器（抑制背景纹理）
gen_gauss_filter (Filter, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
</span>* 频域相乘（保留高频=缺陷，抑制低频=<span style="color: rgba(0, 0, 0, 1)">背景）
convol_fft (ImageFFT, Filter, FilteredFFT)</span></span></pre>
</div>
<h4><span style="font-size: 18px"><strong>4. 转换回空间域</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 逆FFT（频域→空间域）
fft_image_inv (FilteredFFT, ImageFiltered)  </span>* 得到增强后的图像</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>5. 缺陷检测</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">threshold (ImageFiltered, Defects, <span style="color: rgba(128, 0, 128, 1)">120</span>, <span style="color: rgba(128, 0, 128, 1)">255</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 阈值分割
connection (Defects, ConnectedRegions)       </span>* 连通区域分析</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>四、频域分析在工业中的典型应用</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 周期性纹理检测（如织物、金属网）​</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：直接观察难以发现断丝、孔洞。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：通过FFT找到异常频率成分。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>2. 表面微小缺陷增强</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：划痕与背景纹理对比度低。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：抑制背景纹理（低频），增强缺陷（高频）。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>3. 振动分析</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：机械振动导致图像模糊。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：在频域分离振动频率成分并修复。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>五、关键注意事项</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 图像尺寸要求</strong></span></h4>
<ul>
<li><span style="font-size: 18px">FFT对图像尺寸敏感，最佳性能要求尺寸为2的幂次（如512x512）。</span></li>
<li><span style="font-size: 18px">​<strong>HALCON会自动填充</strong>：<code>optimize_rft_speed</code>函数优化处理速度。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>2. 滤波器设计</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>低通滤波</strong>：<code>gen_gauss_filter</code>（抑制高频噪声）。</span></li>
<li><span style="font-size: 18px">​<strong>高通滤波</strong>：<code>gen_derivative_filter</code>（增强边缘）。</span></li>
<li><span style="font-size: 18px">​<strong>带阻滤波</strong>：组合高低通滤波器（去除特定频率噪声）。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>3. 结果可视化</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>查看频谱图</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">power_real (ImageFFT, PowerSpectrum)  *<span style="color: rgba(0, 0, 0, 1)"> 计算功率谱
dev_display (PowerSpectrum)           </span>* 显示频域能量分布</span></pre>
</div>
<p><span style="font-size: 18px">亮点表示强频率成分（如周期性纹理）。</span></p>
<h3><span style="font-size: 18px"><strong>六、完整代码示例（塑料表面缺陷检测）​</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">dev_update_off ()
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastics_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
get_image_size (Image, Width, Height)
dev_open_window (</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, Width, Height, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, WindowHandle)

</span>*<span style="color: rgba(0, 0, 0, 1)"> FFT转换到频域
fft_image (Image, ImageFFT)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设计高斯滤波器（抑制低频背景）
gen_gauss_filter (Filter, </span><span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
convol_fft (ImageFFT, Filter, FilteredFFT)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 逆FFT转回空间域
fft_image_inv (FilteredFFT, ImageFiltered)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 缺陷分割与显示
threshold (ImageFiltered, Defects, </span><span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
connection (Defects, ConnectedRegions)
dev_display (Image)
dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (ConnectedRegions)</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>七、总结</strong></span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>FFT在工业中的价值</strong>：将肉眼难见的纹理异常转化为可检测的信号。</span></li>
<li><span style="font-size: 18px">​<strong>学习建议</strong>：从简单滤波开始，逐步尝试带通/带阻滤波，观察频域图的变化。</span></li>
<li><span style="font-size: 18px">​<strong>调试技巧</strong>：通过<code>power_real</code>可视化频域，调整滤波器参数观察缺陷检测效果。</span></li>
<li><span style="font-size: 18px">适用于具有一定纹理特征的图像，纹理可以理解为条纹，如布匹、木板、纸张等材质容易出现。 </span></li>
<li><span style="font-size: 18px"><span style="font-size: 18px">适用于</span>需要提取对比度低或者信噪比低的特征。 </span></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong>OK，接下来学习一下主要运用到的算子</strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>1.空域转频域算子<strong>fft_image</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#ImageFFT" rel="noopener nofollow"><em>ImageFFT</em></a>&nbsp;: : )详解：</strong></strong></span></span></strong></p>
<ul>
<li><span style="font-size: 18px"><strong>输入参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>Image</code>：输入图像（必须为单通道灰度图像）。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>输出参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>ImageFFT</code>：频域图像（复数形式，包含实部和虚部）。</span></li>
</ul>
</li>
</ul>
<h3><span style="font-size: 18px"><strong>工作原理</strong></span></h3>
<ol>
<li>
<p>​<strong>复数图像结构</strong>：</p>
<ul>
<li><span style="font-size: 18px"><code>ImageFFT</code>包含两个通道：可通过<code>get_image_size</code>查看通道数：<code>Channels := 2</code></span>
<ul>
<li>第一个通道：实部（Real Part）</li>
<li>第二个通道：虚部（Imaginary Part）</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<p>​<strong>频域特性</strong>：</p>
<ul>
<li><span style="font-size: 18px">低频分量集中在图像中心（整体形状、背景纹理）。</span></li>
<li><span style="font-size: 18px">高频分量分布在四周（细节、边缘、噪声）。</span></li>
</ul>
</li>
</ol>
<h3><span style="font-size: 18px"><strong>工业应用示例（塑料表面缺陷检测）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>场景描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：注塑件表面有微小划痕，但背景有周期性纹理干扰。</span></li>
<li><span style="font-size: 18px">​<strong>目标</strong>：通过FFT抑制背景纹理，增强缺陷。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>代码流程</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 读取图像并预处理
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastics_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
rgb1_to_gray (Image, GrayImage)  </span>*<span style="color: rgba(0, 0, 0, 1)"> 确保输入是灰度图

</span>* <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 优化FFT计算速度（关键步骤！）
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 自动填充至最优尺寸

</span>* <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 执行FFT转换到频域
fft_image (GrayImage, ImageFFT)

</span>* <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">. 频域滤波（示例：高斯带阻滤波）
gen_gauss_filter (GaussFilter, </span><span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
convol_fft (ImageFFT, GaussFilter, FilteredFFT)

</span>* <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">. 逆FFT转回空间域
fft_image_inv (FilteredFFT, ImageFiltered)

</span>* <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">. 缺陷检测
threshold (ImageFiltered, Defects, </span><span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
connection (Defects, ConnectedRegions)</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>关键注意事项</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 图像尺寸优化</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：FFT对图像尺寸敏感，非2的幂次时速度慢。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：使用<code>optimize_rft_speed</code>自动填充至最优尺寸。</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">get_image_size (Image, Width, Height)
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 第三个参数可选：
                                                </span>* <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span>（平衡速度/<span style="color: rgba(0, 0, 0, 1)">内存）
                                                </span>* <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">explore</span><span style="color: rgba(128, 0, 0, 1)">'</span>（深度优化）</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>2. 输入数据类型</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>必须</strong>：输入图像为<code>byte</code>、<code>uint2</code>或<code>real</code>类型。</span></li>
<li><span style="font-size: 18px">​<strong>建议</strong>：转换到<code>real</code>类型避免精度损失：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">convert_image_type (GrayImage, ImageReal, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">real</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
fft_image (ImageReal, ImageFFT)</span></span></pre>
</div>
<h4><span style="font-size: 18px"><strong>3. 滤波器设计</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>低频抑制</strong>​（去背景）：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* 大σ值高斯滤波器（σ=<span style="color: rgba(128, 0, 128, 1)">20</span><span style="color: rgba(0, 0, 0, 1)">）
gen_gauss_filter (LowPassFilter, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span>, Width, Height)</span></pre>
</div>
<p><span style="font-size: 18px"><strong>高频增强</strong>​（提取缺陷）：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 高斯带阻滤波（抑制特定频率）
gen_gauss_filter (BandStopFilter, </span><span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span>, Width, Height)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>4. 结果可视化</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">power_real (ImageFFT, PowerSpectrum)  * 计算功率谱（实部² +<span style="color: rgba(0, 0, 0, 1)"> 虚部²）
dev_display (PowerSpectrum)           </span>* 显示亮度表示能量强度</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>常见问题解答</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>Q1：直接显示<code>ImageFFT</code>为什么是乱码？</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：频域图像是复数，无法直接显示。</span></li>
<li><span style="font-size: 18px">​<strong>正确方法</strong>：需计算幅度谱或功率谱：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1); font-size: 18px">fft_image (Image, ImageFFT)
power_real (ImageFFT, PowerSpectrum)
dev_display (PowerSpectrum)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>Q2：如何检测周期性缺陷？</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>步骤</strong>：</span><ol>
<li><span style="font-size: 18px">在功率谱中查找对称亮斑。</span></li>
<li><span style="font-size: 18px">设计带阻滤波器消除对应频率。</span></li>
<li><span style="font-size: 18px">逆FFT后检测剩余异常区域。</span></li>
</ol></li>
</ul>
<h4><span style="font-size: 18px">​<strong>Q3：处理速度慢怎么办？</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>优化措施</strong>：</span>
<ul>
<li><span style="font-size: 18px">使用<code>optimize_rft_speed</code>优化尺寸。</span></li>
<li><span style="font-size: 18px">选择<code>fft_generic</code>的快速模式：</span></li>
</ul>
</li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">fft_generic (Image, ImageFFT, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">to_freq</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">explore</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">complex</span><span style="color: rgba(128, 0, 0, 1)">'</span>, Width)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>总结</strong></span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>核心价值</strong>：<code>fft_image</code>将图像转换到频域，使周期性纹理和微小缺陷更易分离。</span></li>
<li><span style="font-size: 18px">​<strong>典型应用</strong>：</span>
<ul>
<li><span style="font-size: 18px">消除背景纹理干扰（如金属网、织物）</span></li>
<li><span style="font-size: 18px">增强低对比度缺陷（如塑料划痕）</span></li>
<li><span style="font-size: 18px">振动模糊校正（如高速生产线图像修复）</span></li>
</ul>
</li>
</ul>
<p><span style="font-size: 18px">通过合理设计滤波器，您可以在频域中“过滤”掉不需要的信息，显著提升缺陷检测的准确性。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><strong><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>2.生成高斯滤波器算子<strong>gen_gauss_filter</strong>( :&nbsp;<a href="#ImageGauss" rel="noopener nofollow"><em>ImageGauss</em></a>&nbsp;:&nbsp;<a href="#Sigma1" rel="noopener nofollow"><em>Sigma1</em></a>,&nbsp;<a href="#Sigma2" rel="noopener nofollow"><em>Sigma2</em></a>,&nbsp;<a href="#Phi" rel="noopener nofollow"><em>Phi</em></a>,&nbsp;<a href="#Norm" rel="noopener nofollow"><em>Norm</em></a>,&nbsp;<a href="#Mode" rel="noopener nofollow"><em>Mode</em></a>,&nbsp;<a href="#Width" rel="noopener nofollow"><em>Width</em></a>,&nbsp;<a href="#Height" rel="noopener nofollow"><em>Height</em></a>&nbsp;: )详解：</strong></strong></span></span></strong></strong></p>
<h4><span style="font-size: 18px"><strong>功能描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：生成高斯滤波器（或高斯导数滤波器），用于频域或空域滤波。</span></li>
<li><span style="font-size: 18px">​<strong>典型应用</strong>：</span>
<ul>
<li><span style="font-size: 18px">抑制周期性背景纹理（如金属网、织物）</span></li>
<li><span style="font-size: 18px">增强微小缺陷（如塑料划痕、电子元件焊点缺陷）</span></li>
<li><span style="font-size: 18px">图像平滑去噪（保留边缘）</span></li>
</ul>
</li>
</ul>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th>
<p><span style="font-size: 18px">参数</span></p>
</th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th><th><span style="font-size: 18px">工业检测调参建议</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>ImageGauss</code></span></td>
<td><span style="font-size: 18px">输出对象</span></td>
<td><span style="font-size: 18px">生成的高斯滤波器图像</span></td>
<td><span style="font-size: 18px">-</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Sigma1</code></span></td>
<td><span style="font-size: 18px">实数</span></td>
<td><span style="font-size: 18px">X方向的标准差（控制滤波器的横向扩展）</span></td>
<td><span style="font-size: 18px">根据目标特征尺寸设置（例：缺陷宽度=20像素 → Sigma1=10）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Sigma2</code></span></td>
<td><span style="font-size: 18px">实数</span></td>
<td><span style="font-size: 18px">Y方向的标准差（控制滤波器的纵向扩展）</span></td>
<td><span style="font-size: 18px">通常与Sigma1相同（各向同性滤波）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Phi</code></span></td>
<td><span style="font-size: 18px">实数</span></td>
<td><span style="font-size: 18px">滤波器的旋转角度（弧度）</span></td>
<td><span style="font-size: 18px">0（无旋转）或根据纹理方向设置（如45°=0.785 rad）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Norm</code></span></td>
<td><span style="font-size: 18px">字符串</span></td>
<td><span style="font-size: 18px">标准化模式：</span><br><span style="font-size: 18px"><code>'none'</code>：不标准化</span><br><span style="font-size: 18px"><code>'n'</code>：归一化到单位能量</span></td>
<td><span style="font-size: 18px">频域滤波用<code>'none'</code>，空域滤波用<code>'n'</code></span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>Mode</code></span></td>
<td><span style="font-size: 18px">字符串</span></td>
<td><span style="font-size: 18px">滤波器模式：</span><br><span style="font-size: 18px"><code>'rft'</code>：频域滤波器（复数）</span><br><span style="font-size: 18px"><code>'dc_center'</code>：空域滤波器</span></td>
<td><span style="font-size: 18px">频域处理必选<code>'rft'</code></span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>Width</code></span></td>
<td><span style="font-size: 18px">整数</span></td>
<td><span style="font-size: 18px">滤波器宽度（需与待处理图像等宽）</span></td>
<td><span style="font-size: 18px">通过<code>get_image_size</code>获取原图尺寸</span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>Height</code></span></td>
<td><span style="font-size: 18px">整数</span></td>
<td><span style="font-size: 18px">滤波器高度（需与待处理图像等高）</span></td>
<td><span style="font-size: 18px">同上</span></td>



</tr>



</tbody>



</table>



</div>


<br>
<ul>
<li>
<ul>
<li><br><span style="font-size: 18px">
（例：划痕宽度6像素 → Sigma=2）</span></li>



</ul>




</li>



</ul>
<h4><span style="font-size: 18px">​<strong>2. Mode='rft'</strong></span></h4>
<ul>
<ul>
<li><span style="font-size: 18px">​<strong>频域滤波器特性</strong>：​<strong>必须与图像等尺寸</strong>：
</span>
<ul>
<li><span style="font-size: 18px">生成复数滤波器（实部+虚部），直接用于FFT频域乘法</span></li>
<li><span style="font-size: 18px">滤波器中心在图像左上角（FFT标准布局）</span></li>



</ul>




</li>
<li></li>



</ul>


</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1); font-size: 18px">get_image_size (Image, Width, Height)
gen_gauss_filter(..., Width, Height)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>3. Norm='none'</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>频域滤波不推荐归一化</strong>：</span>
<ul>
<li><span style="font-size: 18px">保持滤波器的绝对强度</span></li>
<li><span style="font-size: 18px">避免频域相乘后能量损失</span></li>
</ul>
</li>
</ul>
<h3><span style="font-size: 18px"><strong>工业应用案例：塑料表面划痕检测</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>场景描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：塑料件表面有细微划痕，但存在网状纹理背景干扰。</span></li>
<li><span style="font-size: 18px">​<strong>目标</strong>：抑制网状纹理，增强划痕特征。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>解决方案</strong></span></h4>
<ol>
<li><span style="font-size: 18px">​<strong>生成带阻高斯滤波器</strong>​（抑制特定频率的网状纹理）</span></li>
<li><span style="font-size: 18px">​<strong>频域滤波后检测缺陷</strong></span></li>
</ol>
<h4><span style="font-size: 18px">​<strong>代码示例</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 读取图像并转换为灰度
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastic_mesh_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
rgb1_to_gray (Image, GrayImage)

</span>* <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 获取图像尺寸
get_image_size (GrayImage, Width, Height)

</span>* <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 生成高斯带阻滤波器（抑制网状纹理）
Sigma1 :</span>= <span style="color: rgba(128, 0, 128, 1)">25.0</span>  *<span style="color: rgba(0, 0, 0, 1)"> 抑制低频（对应网状纹理周期50像素）
Sigma2 :</span>= <span style="color: rgba(128, 0, 128, 1)">3.0</span>    *<span style="color: rgba(0, 0, 0, 1)"> 保留高频（划痕特征）
gen_gauss_filter (GaussFilter, Sigma1, Sigma2, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)

</span>* <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">. 频域滤波处理
fft_image (GrayImage, ImageFFT)
convol_fft (ImageFFT, GaussFilter, FilteredFFT)
fft_image_inv (FilteredFFT, ImageFiltered)

</span>* <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">. 检测划痕
threshold (ImageFiltered, Scratches, </span><span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (Scratches)</span></span></pre>
</div>
<h4><span style="font-size: 18px"><strong>滤波器效果可视化</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 查看频域滤波器形状
power_real (GaussFilter, PowerSpectrum)
dev_display (PowerSpectrum)  </span>* 显示为中央暗区（抑制低频）+周边亮环（保留高频）</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>参数调优技巧</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 确定Sigma值</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>步骤</strong>：</span><ol>
<li><span style="font-size: 18px">对正常样本做FFT，观察功率谱中的亮斑（背景纹理频率）</span></li>
<li><span style="font-size: 18px">测量亮斑到中心的距离<code>D</code>（像素）</span></li>
<li><span style="font-size: 18px">设置<code>Sigma = D/2</code></span></li>
</ol></li>
</ul>
<h4><span style="font-size: 18px">​<strong>2. 方向性滤波（Phi调整）​</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>应用场景</strong>：当缺陷具有方向性时（如平行划痕）</span></li>
<li><span style="font-size: 18px">​<strong>设置方法</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 检测到划痕方向为60度
Phi :</span>= rad(<span style="color: rgba(128, 0, 128, 1)">60</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 转换为弧度
gen_gauss_filter(..., Phi, ...)  </span>* 生成旋转滤波器</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>3. 多尺度滤波</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 组合不同Sigma值检测多尺寸缺陷
</span><span style="color: rgba(0, 0, 255, 1)">for</span> Sigma := [<span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>] <span style="color: rgba(0, 0, 255, 1)">do</span><span style="color: rgba(0, 0, 0, 1)">
    gen_gauss_filter(..., Sigma, Sigma, ...)
    convol_fft(...)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 各尺度结果融合
endfor</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>常见问题解决</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>Q1：滤波器处理后图像变暗</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：低频成分被过度抑制。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：使用带通滤波（高斯相减）：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 生成两个高斯滤波器相减
gen_gauss_filter (Gauss1, </span><span style="color: rgba(128, 0, 128, 1)">30</span>, <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">, ...)
gen_gauss_filter (Gauss2, </span><span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">, ...)
sub_image (Gauss1, Gauss2, BandPassFilter, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>Q2：处理后出现振铃效应</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：滤波器边缘陡峭导致吉布斯现象。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：增大Sigma值使滤波器过渡平滑。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>Q3：滤波后缺陷丢失</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：Sigma设置过小导致缺陷频率被滤除。</span></li>
<li><span style="font-size: 18px">​<strong>调试</strong>：逐步增大Sigma值，观察频域功率谱变化。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>总结</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">调整策略</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">​<strong>Sigma1</strong></span></td>
<td><span style="font-size: 18px">根据背景纹理周期设置，越大抑制的低频越多</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>Sigma2</strong></span></td>
<td><span style="font-size: 18px">根据缺陷尺寸设置，越小保留的高频细节越多</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>Phi</strong></span></td>
<td><span style="font-size: 18px">沿缺陷方向设置（需先进行方向分析）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>Norm</strong></span></td>
<td><span style="font-size: 18px">频域滤波始终用<code>'none'</code>，空域滤波用<code>'n'</code></span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>尺寸</strong></span></td>
<td><span style="font-size: 18px">必须与输入图像等大（通过<code>get_image_size</code>获取）</span></td>
</tr>
</tbody>
</table>
</div>
<p><span style="font-size: 18px">通过合理设置高斯滤波器参数，可以有效分离背景纹理与目标缺陷，提升工业视觉检测的准确性和鲁棒性。建议配合<code>power_real</code>可视化频域滤波器特性，进行参数调优验证。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><strong><strong><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>3.频域卷积算子<strong>convol_fft</strong>(<a href="#ImageFFT" rel="noopener nofollow"><em>ImageFFT</em></a>,&nbsp;<a href="#ImageFilter" rel="noopener nofollow"><em>ImageFilter</em></a>&nbsp;:&nbsp;<a href="#ImageConvol" rel="noopener nofollow"><em>ImageConvol</em></a>&nbsp;: : )详解：</strong></strong></span></span></strong></strong></strong></p>
<h4><span style="font-size: 18px"><strong>功能描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心作用</strong>：在频域中执行两个图像的卷积运算（等效于空域的滤波操作）。</span></li>
<li><span style="font-size: 18px">​<strong>数学原理</strong>：频域卷积 = 频域图像 × 频域滤波器（复数乘法）。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：比空域卷积快100倍以上（尤其适合大尺寸滤波器或图像）。</span></li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>参数说明</strong></span></h3>
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th><th><span style="font-size: 18px">工业检测注意事项</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>ImageFFT</code></span></td>
<td><span style="font-size: 18px">输入</span></td>
<td><span style="font-size: 18px">经过FFT变换的输入图像（复数形式，实部+虚部）</span></td>
<td><span style="font-size: 18px">必须通过<code>fft_image</code>生成</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>ImageFilter</code></span></td>
<td><span style="font-size: 18px">输入</span></td>
<td><span style="font-size: 18px">频域滤波器（需与<code>ImageFFT</code>同尺寸，复数形式）</span></td>
<td><span style="font-size: 18px">常用高斯滤波器<code>gen_gauss_filter</code>生成</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>ImageConvol</code></span></td>
<td><span style="font-size: 18px">输出</span></td>
<td><span style="font-size: 18px">卷积结果（复数频域图像）</span></td>
<td><span style="font-size: 18px">需逆FFT转换回空间域使用</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>工业应用场景（金属表面划痕检测）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>场景需求</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：金属板表面有细微划痕，但存在周期性加工纹理（低频背景）。</span></li>
<li><span style="font-size: 18px">​<strong>目标</strong>：抑制背景纹理，增强划痕特征。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>处理流程</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 读取图像并转换到频域
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">metal_surface_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
rgb1_to_gray (Image, GrayImage)
fft_image (GrayImage, ImageFFT)  </span>*<span style="color: rgba(0, 0, 0, 1)"> 转换到频域

</span>* <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 生成高通高斯滤波器（增强高频缺陷）
gen_gauss_filter (Filter, </span><span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)

</span>* <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 频域卷积（等效于空域滤波）
convol_fft (ImageFFT, Filter, ImageConvol)

</span>* <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">. 逆FFT转回空间域
fft_image_inv (ImageConvol, ImageFiltered)

</span>* <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">. 检测划痕
threshold (ImageFiltered, Scratches, </span><span style="color: rgba(128, 0, 128, 1)">80</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (Scratches)</span></span></pre>
</div>
<h4><span style="font-size: 18px"><strong>频域卷积效果</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>输入频谱</strong>：<code>ImageFFT</code>包含金属纹理（低频中心亮区）+ 划痕（高频边缘）。</span></li>
<li><span style="font-size: 18px">​<strong>滤波器</strong>：高通滤波器（中央暗区，周边亮环）。</span></li>
<li><span style="font-size: 18px">​<strong>输出频谱</strong>：抑制低频纹理，保留高频划痕信号。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>关键参数详解</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 滤波器设计策略</strong></span></h4>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">滤波器类型</span></th><th><span style="font-size: 18px">生成方法</span></th><th><span style="font-size: 18px">适用场景</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">​<strong>低通</strong></span></td>
<td><span style="font-size: 18px"><code>gen_gauss_filter</code>大Sigma（如30）</span></td>
<td><span style="font-size: 18px">抑制高频噪声（如电子元件毛刺）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>高通</strong></span></td>
<td><span style="font-size: 18px"><code>1 - 低通滤波器</code></span></td>
<td><span style="font-size: 18px">增强边缘/划痕</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>带阻</strong></span></td>
<td><span style="font-size: 18px">高斯1 - 高斯2（不同Sigma）</span></td>
<td><span style="font-size: 18px">消除特定频率干扰（如网格纹理）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>带通</strong></span></td>
<td><span style="font-size: 18px">高斯低通 - 高斯高通</span></td>
<td><span style="font-size: 18px">提取特定尺寸特征</span></td>
</tr>
</tbody>
</table>
</div>
<h4><span style="font-size: 18px">​<strong>2. 性能优化</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>尺寸匹配</strong>：确保<code>ImageFFT</code>和<code>ImageFilter</code>尺寸相同（通过<code>get_image_size</code>验证）。</span></li>
<li><span style="font-size: 18px">​<strong>预处理加速</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">optimize_rft_speed (Width, Height, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  * 自动填充至最优尺寸</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>典型问题解决方案</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>问题1：处理后出现振铃伪影</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：滤波器边缘陡峭导致吉布斯现象。</span></li>
<li><span style="font-size: 18px">​<strong>解决</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 使用渐变高斯滤波器（边缘平滑）
gen_gauss_filter (Filter, </span><span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span>, Width, Height)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>问题2：缺陷信号被过度抑制</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>现象</strong>：阈值分割后缺陷区域消失。</span></li>
<li><span style="font-size: 18px">​<strong>调试步骤</strong>：</span><ol>
<li><span style="font-size: 18px">检查滤波器类型（误用低通会抑制缺陷）。</span></li>
<li><span style="font-size: 18px">可视化功率谱：</span></li>
</ol></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">power_real (ImageConvol, PowerSpectrum)
dev_display (PowerSpectrum)  </span>* 确认缺陷频率是否保留</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>与空域卷积的对比</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">特性</span></th><th><span style="font-size: 18px">频域卷积 (<code>convol_fft</code>)</span></th><th><span style="font-size: 18px">空域卷积 (<code>convol_image</code>)</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">​<strong>速度</strong></span></td>
<td><span style="font-size: 18px">O(n log n) → 快（大核优势）</span></td>
<td><span style="font-size: 18px">O(n²m²) → 慢（m为滤波器尺寸）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>适用场景</strong></span></td>
<td><span style="font-size: 18px">大尺寸滤波器（&gt;15x15）</span></td>
<td><span style="font-size: 18px">小尺寸滤波器（&lt;15x15）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>内存占用</strong></span></td>
<td><span style="font-size: 18px">较高（需存储复数图像）</span></td>
<td><span style="font-size: 18px">较低（实数运算）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">​<strong>功能扩展</strong></span></td>
<td><span style="font-size: 18px">支持复杂频域操作（如带阻滤波）</span></td>
<td><span style="font-size: 18px">限于简单核（高斯、Sobel等）</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 18px"><strong>完整案例代码（织物瑕疵检测）​</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">dev_update_off ()
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">fabric_01.jpg</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
get_image_size (Image, Width, Height)
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 尺寸优化

</span>*<span style="color: rgba(0, 0, 0, 1)"> 频域转换
fft_image (Image, ImageFFT)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设计带阻滤波器（抑制织物纹理）
gen_gauss_filter (LowPass, </span><span style="color: rgba(128, 0, 128, 1)">40</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
gen_gauss_filter (HighPass, </span><span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
sub_image (LowPass, HighPass, BandStopFilter, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 频域卷积
convol_fft (ImageFFT, BandStopFilter, ImageConvol)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 逆变换与检测
fft_image_inv (ImageConvol, ImageFiltered)
threshold (ImageFiltered, Defects, </span><span style="color: rgba(128, 0, 128, 1)">70</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
connection (Defects, ConnectedRegions)
select_shape (ConnectedRegions, FinalDefects, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">area</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">&gt;</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">50</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>总结</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">操作要点</span></th><th><span style="font-size: 18px">工业检测意义</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">正确设计滤波器Sigma值</span></td>
<td><span style="font-size: 18px">决定缺陷与背景的分离效果</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">功率谱可视化调试</span></td>
<td><span style="font-size: 18px">快速定位频率干扰源</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">结合<code>optimize_rft_speed</code></span></td>
<td><span style="font-size: 18px">提升产线实时检测速度（尤其4K以上图像）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">频域+空域联合处理</span></td>
<td><span style="font-size: 18px">复杂缺陷检测（如同时存在划痕和孔洞）</span></td>
</tr>
</tbody>
</table>
</div>
<p><span style="font-size: 18px">通过合理使用<code>convol_fft</code>，您可以在半导体、汽车零部件、纺织品等行业中，高效解决复杂背景下的微观缺陷检测难题。</span></p>
<p>&nbsp;</p>
<br>
<p><strong><strong><strong><strong><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>4.频域转空间域算子<strong>fft_image_inv</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#ImageFFTInv" rel="noopener nofollow"><em>ImageFFTInv</em></a>&nbsp;: : )详解：</strong></strong></span></span></strong></strong></strong></strong></p>
<h4><span style="font-size: 18px"><strong>功能描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心作用</strong>：将频域图像（复数形式）逆变换回空间域图像（实数形式）。</span></li>
<li><span style="font-size: 18px">​<strong>数学原理</strong>：执行快速傅里叶逆变换（IFFT），恢复滤波后的空域图像。</span></li>
<li><span style="font-size: 18px">​<strong>工业价值</strong>：将频域处理结果（如去噪、缺陷增强）转换为可视化的检测图像。</span></li>


</ul>
<h3><span style="font-size: 18px"><strong>参数说明</strong></span></h3>
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th><th><span style="font-size: 18px">工业检测注意事项</span></th></tr>


</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>Image</code></span></td>
<td><span style="font-size: 18px">输入</span></td>
<td><span style="font-size: 18px">频域图像（复数形式，实部+虚部）</span></td>
<td><span style="font-size: 18px">必须经过<code>fft_image</code>或<code>convol_fft</code>处理</span></td>


</tr>
<tr>
<td><span style="font-size: 18px"><code>ImageFFTInv</code></span></td>
<td><span style="font-size: 18px">输出</span></td>
<td><span style="font-size: 18px">逆变换后的空间域图像（实数类型）</span></td>
<td><span style="font-size: 18px">需进行后续阈值分割或形态学操作</span></td>


</tr>


</tbody>


</table>
<h3><span style="font-size: 18px"><strong>工业应用场景（半导体晶圆缺陷检测）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>场景需求</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>问题</strong>：晶圆表面存在微小金属残留（高频缺陷），但被电路纹理（低频）干扰。</span></li>
<li><span style="font-size: 18px">​<strong>目标</strong>：抑制电路纹理，增强缺陷信号。</span></li>


</ul>
<h4><span style="font-size: 18px">​<strong>处理流程</strong></span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 读取图像并转灰度
read_image (Wafer, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">wafer_01.tiff</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
rgb1_to_gray (Wafer, GrayWafer)

</span>* <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 优化FFT尺寸
get_image_size (GrayWafer, Width, Height)
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 转换到频域
fft_image (GrayWafer, WaferFFT)

</span>* <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">. 高通滤波（增强缺陷）
gen_gauss_filter (HighPassFilter, </span><span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
convol_fft (WaferFFT, HighPassFilter, FilteredFFT)

</span>* <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">. 逆FFT转回空间域
fft_image_inv (FilteredFFT, ProcessedWafer)  </span>*<span style="color: rgba(0, 0, 0, 1)"> 关键步骤！

</span>* <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">. 检测缺陷
threshold (ProcessedWafer, Defects, </span><span style="color: rgba(128, 0, 128, 1)">120</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (Defects)</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>关键参数详解</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. 输入图像要求</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>必须为复数图像</strong>：通过<code>fft_image</code>或<code>convol_fft</code>生成。</span></li>
<li><span style="font-size: 18px">​<strong>尺寸验证</strong>：必须与原图尺寸一致（可通过<code>get_image_size</code>检查）。</span></li>
</ul>
<h4><span style="font-size: 18px">​<strong>2. 输出图像特性</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>数据类型</strong>：输出为实数图像（<code>real</code>类型），值域可能为负。</span></li>
<li><span style="font-size: 18px">​<strong>动态范围调整</strong>：建议使用<code>scale_image</code>调整亮度：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">scale_image (ProcessedWafer, ScaledImage, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>)  * 放大10倍便于显示</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>典型问题解决方案</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>问题1：逆变换后图像全黑</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>原因</strong>：频域滤波器过度抑制所有频率。</span></li>
<li><span style="font-size: 18px">​<strong>调试</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 检查滤波器功率谱
power_real (HighPassFilter, PowerFilter)
dev_display (PowerFilter)  </span>* 应有非零区域</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>问题2：图像边缘出现振铃伪影</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>解决</strong>：</span><ol>
<li><span style="font-size: 18px">使用渐变滤波器（如高斯滤波器代替理想滤波器）。</span></li>
<li><span style="font-size: 18px">逆变换前应用窗函数：</span></li>
</ol></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">multiply_image (FilteredFFT, WindowFunction, FilteredFFT, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>)</span></pre>
</div>
<h4><span style="font-size: 18px"><strong>问题3：亮度偏移</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>现象</strong>：逆变换后整体亮度异常。</span></li>
<li><span style="font-size: 18px">​<strong>处理</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 重新计算均值并校正
mean_image (ProcessedWafer, MeanImage)
sub_image (ProcessedWafer, MeanImage, CorrectedImage, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>完整代码示例（LCD面板检测）​</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">dev_update_off ()
read_image (LCD, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lcd_panel_01.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
get_image_size (LCD, Width, Height)
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">explore</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 深度优化

</span>*<span style="color: rgba(0, 0, 0, 1)"> 频域转换与滤波
fft_image (LCD, LCD_FFT)
gen_gauss_filter (BandStop, </span><span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
convol_fft (LCD_FFT, BandStop, FilteredFFT)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 逆FFT转换
fft_image_inv (FilteredFFT, FilteredLCD)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 增强对比度并检测亮点缺陷
emphasize (FilteredLCD, EnhancedLCD, Width, Height, </span><span style="color: rgba(128, 0, 128, 1)">1.5</span><span style="color: rgba(0, 0, 0, 1)">)
threshold (EnhancedLCD, Defects, </span><span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
connection (Defects, ConnectedRegions)
select_shape (ConnectedRegions, FinalDefects, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">circularity</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">&gt;</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">0.85</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>总结</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">操作步骤</span></th><th><span style="font-size: 18px">工业检测意义</span></th><th><span style="font-size: 18px">参数调整建议</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>fft_image_inv</code></span></td>
<td><span style="font-size: 18px">将频域处理结果可视化</span></td>
<td><span style="font-size: 18px">确保输入为正确滤波后的复数图像</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">动态范围调整</span></td>
<td><span style="font-size: 18px">使缺陷更易观察</span></td>
<td><span style="font-size: 18px">使用<code>scale_image</code>或<code>emphasize</code>增强对比度</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">振铃抑制</span></td>
<td><span style="font-size: 18px">提高检测准确性</span></td>
<td><span style="font-size: 18px">应用窗函数或渐变滤波器</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">尺寸优化</span></td>
<td><span style="font-size: 18px">提升实时检测速度</span></td>
<td><span style="font-size: 18px">必用<code>optimize_rft_speed</code></span></td>
</tr>
</tbody>
</table>
</div>
<p><span style="font-size: 18px">通过合理使用<code>fft_image_inv</code>，您可以在电子元件、液晶面板、金属加工等领域，高效还原频域处理结果，实现高精度的缺陷检测。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><strong><strong><strong><strong><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>5.傅里叶变换算子<strong>rft_generic</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#ImageFFT" rel="noopener nofollow"><em>ImageFFT</em></a>&nbsp;:&nbsp;<a href="#Direction" rel="noopener nofollow"><em>Direction</em></a>,&nbsp;<a href="#Norm" rel="noopener nofollow"><em>Norm</em></a>,&nbsp;<a href="#ResultType" rel="noopener nofollow"><em>ResultType</em></a>,&nbsp;<a href="#Width" rel="noopener nofollow"><em>Width</em></a>&nbsp;: )详解：</strong></strong></span></span></strong></strong></strong></strong></strong></p>
<p>&nbsp;</p>
<h4><span style="font-size: 18px"><strong>功能描述</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心作用</strong>：执行灵活的傅里叶变换（FFT）或实傅里叶变换（RFT），支持多种输入输出模式和参数配置。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：比<code>fft_image</code>更灵活，可控制变换方向、归一化方式及窗函数。</span></li>
<li><span style="font-size: 18px">​<strong>工业应用</strong>：适用于需要精细控制频域处理的场景，如复杂纹理抑制、微小缺陷增强。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>参数说明</strong></span></h3>
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th><th><span style="font-size: 18px">工业检测推荐值</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>Image</code></span></td>
<td><span style="font-size: 18px">输入</span></td>
<td><span style="font-size: 18px">输入图像（实数类型）</span></td>
<td><span style="font-size: 18px">需为单通道灰度图（<code>byte</code>/<code>real</code>）</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>ImageFFT</code></span></td>
<td><span style="font-size: 18px">输出</span></td>
<td><span style="font-size: 18px">频域图像（复数或实数形式）</span></td>
<td><span style="font-size: 18px">根据<code>ResultType</code>选择输出类型</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Direction</code></span></td>
<td><span style="font-size: 18px">字符串</span></td>
<td><span style="font-size: 18px">变换方向：</span><br><span style="font-size: 18px"><code>'to_freq'</code>（空域→频域）</span><br><span style="font-size: 18px"><code>'from_freq'</code>（频域→空域）</span></td>
<td><span style="font-size: 18px"><code>'to_freq'</code>（正向变换）</span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>Norm</code></span></td>
<td><span style="font-size: 18px">字符串</span></td>
<td><span style="font-size: 18px">归一化方式：</span><br><span style="font-size: 18px"><code>'none'</code>（无）</span><br><span style="font-size: 18px"><code>'sqrt'</code>（平方根）</span><br><span style="font-size: 18px"><code>'n'</code>（单位能量）</span></td>
<td><span style="font-size: 18px">频域滤波用<code>'none'</code>，分析用<code>'n'</code></span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>ResultType</code></span></td>
<td><span style="font-size: 18px">字符串</span></td>
<td><span style="font-size: 18px">输出类型：</span><br><span style="font-size: 18px"><code>'complex'</code>（复数）</span><br><span style="font-size: 18px"><code>'real'</code>（实数）</span></td>
<td><span style="font-size: 18px">滤波操作选<code>'complex'</code>，功率谱分析选<code>'real'</code></span></td>



</tr>
<tr>
<td><span style="font-size: 18px"><code>Width</code></span></td>
<td><span style="font-size: 18px">整数</span></td>
<td><span style="font-size: 18px">图像宽度（需与输入图像一致）</span></td>
<td><span style="font-size: 18px">通过<code>get_image_size</code>获取</span></td>



</tr>



</tbody>


</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>关键参数详解</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>1. Direction（变换方向）​</strong></span></h4>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">模式</span></th><th><span style="font-size: 18px">使用场景</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>'to_freq'</code></span></td>
<td><span style="font-size: 18px">空域→频域，用于滤波、频率分析（95%工业应用场景）</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'from_freq'</code></span></td>
<td><span style="font-size: 18px">频域→空域，恢复处理后的图像（需与<code>'to_freq'</code>成对使用）</span></td>

</tr>

</tbody>

</table>

</div>
<h4><span style="font-size: 18px">​<strong>2. Norm（归一化方式）​</strong></span></h4>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">模式</span></th><th><span style="font-size: 18px">数学公式</span></th><th><span style="font-size: 18px">适用场景</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>'none'</code></span></td>
<td><span style="font-size: 18px">无缩放</span></td>
<td><span style="font-size: 18px">频域滤波（保持能量不变）</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'sqrt'</code></span></td>
<td><span style="font-size: 18px">输出值乘以1/√N</span></td>
<td><span style="font-size: 18px">图像重建（防止能量溢出）</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'n'</code></span></td>
<td><span style="font-size: 18px">输出值乘以1/N</span></td>
<td><span style="font-size: 18px">频谱分析（确保能量守恒）</span></td>

</tr>

</tbody>

</table>

</div>
<h4><span style="font-size: 18px">​<strong>3. ResultType（输出类型）​</strong></span></h4>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">数据格式</span></th><th><span style="font-size: 18px">典型应用</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>'complex'</code></span></td>
<td><span style="font-size: 18px">复数（实部+虚部）</span></td>
<td><span style="font-size: 18px">频域滤波、相位分析</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'real'</code></span></td>
<td><span style="font-size: 18px">实数（幅度或实部）</span></td>
<td><span style="font-size: 18px">功率谱可视化、简单频域操作</span></td>

</tr>

</tbody>

</table>

</div>
<h3><span style="font-size: 18px"><strong>窗函数（Window）的作用与选择</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>常用窗函数类型</strong></span></h4>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">窗函数</span></th><th><span style="font-size: 18px">特性</span></th><th><span style="font-size: 18px">适用场景</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>'none'</code></span></td>
<td><span style="font-size: 18px">矩形窗（无衰减）</span></td>
<td><span style="font-size: 18px">快速检测，边缘信息重要时</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'hann'</code></span></td>
<td><span style="font-size: 18px">平滑衰减，减少频谱泄漏</span></td>
<td><span style="font-size: 18px">大多数工业检测（推荐默认）</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>'hamming'</code></span></td>
<td><span style="font-size: 18px">类似Hann，但首尾不归零</span></td>
<td><span style="font-size: 18px">需要更高频率分辨率时</span></td>

</tr>

</tbody>

</table>

</div>
<h4><span style="font-size: 18px">​<strong>选择建议</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>缺陷检测</strong>：优先使用<code>'hann'</code>窗，平衡频谱泄漏抑制和边缘保留。</span></li>
<li><span style="font-size: 18px">​<strong>尺寸测量</strong>：使用<code>'none'</code>窗避免边缘模糊。</span></li>

</ul>
<p><span style="font-size: 18px">&nbsp;</span></p>

<br>
<h3><span style="font-size: 18px"><strong>总结</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数/操作</span></th><th><span style="font-size: 18px">工业检测最佳实践</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">​<strong>Direction</strong></span></td>
<td><span style="font-size: 18px"><code>'to_freq'</code>用于滤波，<code>'from_freq'</code>用于重建</span></td>

</tr>
<tr>
<td><span style="font-size: 18px">​<strong>Norm</strong></span></td>
<td><span style="font-size: 18px">滤波用<code>'none'</code>，分析用<code>'n'</code></span></td>

</tr>
<tr>
<td><span style="font-size: 18px">​<strong>Window</strong></span></td>
<td><span style="font-size: 18px">默认<code>'hann'</code>，边缘敏感场景用<code>'none'</code></span></td>

</tr>
<tr>
<td><span style="font-size: 18px">​<strong>ResultType</strong></span></td>
<td><span style="font-size: 18px">滤波操作选<code>'complex'</code>，简单分析选<code>'real'</code></span></td>

</tr>
<tr>
<td><span style="font-size: 18px">​<strong>性能优化</strong></span></td>
<td><span style="font-size: 18px">必用<code>optimize_rft_speed</code>，大图启用多线程</span></td>

</tr>

</tbody>

</table>

</div>
<p><span style="font-size: 18px">通过合理配置<code>rft_generic</code>参数，您可以在半导体、汽车零部件、纺织品等行业的复杂检测场景中，高效实现背景纹理抑制与微小缺陷增强，提升检测系统的准确性和鲁棒性。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong>接下来看一些实战案例，基本都在halcon的程序集里</strong></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">示例1：塑料表面纹理缺陷检测程序（基于频域分析）</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321163120219-931109050.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">两张原图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321163134235-1645854640.bmp" alt="" loading="lazy"></p>
<p><span style="font-size: 18px">这张有个小点 看出来没？</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321163137007-907179190.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">实例代码：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* ​*************************************************************
*<span style="color: rgba(0, 0, 0, 1)"> 塑料表面纹理缺陷检测程序（基于频域分析）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 检测原理：
</span>*   <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">. 构造高斯带阻滤波器消除正常纹理
</span>*   <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. FFT频域卷积增强缺陷特征
</span>*   <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">. 形态学处理定位异常区域
</span>*<span style="color: rgba(0, 0, 0, 1)"> 工业应用：注塑件表面质量检测
</span>*<span style="color: rgba(0, 0, 0, 1)"> 支持文件格式：BMP格式工业图像（推荐8bit灰度）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 硬件要求：500万像素以上工业相机，同轴照明系统
</span>*<span style="color: rgba(0, 0, 0, 1)"> 检测精度：最小缺陷检测尺寸0.1mm²（200dpi下约4像素）
</span>* ​*************************************************************


* ​*************** 检测流程示意图 ​***************
*<span style="color: rgba(0, 0, 0, 1)"> 原始图像 
</span>*<span style="color: rgba(0, 0, 0, 1)"> → FFT频域变换（使用优化算法加速）
</span>*<span style="color: rgba(0, 0, 0, 1)"> → 高斯带阻滤波（抑制背景纹理）
</span>*<span style="color: rgba(0, 0, 0, 1)"> → 逆FFT变换（获取滤波后图像）
</span>*<span style="color: rgba(0, 0, 0, 1)"> → 局部对比度增强（突出缺陷边缘）
</span>*<span style="color: rgba(0, 0, 0, 1)"> → 动态阈值分割（自适应亮度变化）
</span>* → 形态学优化（去噪+<span style="color: rgba(0, 0, 0, 1)">区域合并）
</span>*<span style="color: rgba(0, 0, 0, 1)"> → 缺陷标记与结果输出


</span>* ​*************** 系统初始化模块 ​***************
*<span style="color: rgba(0, 0, 0, 1)"> 关闭窗口自动更新（提升大图像处理时的执行效率）
dev_update_off ()
</span>*<span style="color: rgba(0, 0, 0, 1)"> 清理可能存在的残留窗口
dev_close_window ()
</span>*<span style="color: rgba(0, 0, 0, 1)"> 加载基准图像（用于获取系统参数）
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastics/plastics_01</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 获取图像尺寸参数（用于窗口创建和滤波器设计）
get_image_size (Image, Width, Height)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 创建与图像等大的显示窗口（黑色背景利于缺陷观察）
dev_open_window (</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, Width, Height, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, WindowHandle)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 配置显示字体（等宽字体确保字符对齐，14号字适合1080P显示）
set_display_font (WindowHandle, </span><span style="color: rgba(128, 0, 128, 1)">14</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mono</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置绘制模式为轮廓显示（节省GPU显存资源）
dev_set_draw (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">margin</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置轮廓线宽（3像素宽度确保缺陷标记明显可见）
dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置默认报警颜色为红色（符合工业标准报警色）
dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* ​*************** FFT性能优化模块 ​***************
*<span style="color: rgba(0, 0, 0, 1)"> 根据特定图像尺寸优化FFT计算（选择最优的FFT算法实现）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 平衡模式（兼顾速度和内存使用）
</span>*   其他可选模式：<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">explore</span><span style="color: rgba(128, 0, 0, 1)">'</span>深度优化（耗时）/<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">estimate</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">快速估算
optimize_rft_speed (Width, Height, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">standard</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* ​*************** 滤波器设计模块 ​***************
*<span style="color: rgba(0, 0, 0, 1)"> 构建复合高斯带阻滤波器（消除周期性背景纹理）
</span>*<span style="color: rgba(0, 0, 0, 1)"> Sigma1: 低频截止参数（控制背景纹理抑制范围）
</span>*   - 推荐值 = 正常纹理周期/<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">（例如纹理间隔20像素则设10）
</span>*   -<span style="color: rgba(0, 0, 0, 1)"> 当前值10.0适用于0.5mm间距网格纹理（200dpi下）
Sigma1 :</span>= <span style="color: rgba(128, 0, 128, 1)">10.0</span>
*<span style="color: rgba(0, 0, 0, 1)"> Sigma2: 高频截止参数（控制缺陷特征保留范围）
</span>*   - 推荐值 = 最小缺陷尺寸/<span style="color: rgba(128, 0, 128, 1)">2</span>（例如6像素缺陷设3.<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">）
</span>*   -<span style="color: rgba(0, 0, 0, 1)"> 当前值3.0对应0.3mm²微小缺陷检测
Sigma2 :</span>= <span style="color: rgba(128, 0, 128, 1)">3.0</span>
*<span style="color: rgba(0, 0, 0, 1)"> 生成低频抑制高斯滤波器（大σ值滤波器）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   GaussFilter1 -<span style="color: rgba(0, 0, 0, 1)"> 输出滤波器对象
</span>*   <span style="color: rgba(128, 0, 128, 1)">10.0</span> -<span style="color: rgba(0, 0, 0, 1)"> X方向σ值（与Sigma1对应）
</span>*   <span style="color: rgba(128, 0, 128, 1)">10.0</span> -<span style="color: rgba(0, 0, 0, 1)"> Y方向σ值（各向同性滤波）
</span>*   <span style="color: rgba(128, 0, 128, 1)">0.0</span> -<span style="color: rgba(0, 0, 0, 1)"> 滤波器旋转角度（0度表示无旋转）
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 无标准化
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 频域滤波器类型
</span>*   Width, Height -<span style="color: rgba(0, 0, 0, 1)"> 滤波器尺寸（必须与图像一致）
gen_gauss_filter (GaussFilter1, Sigma1, Sigma1, </span><span style="color: rgba(128, 0, 128, 1)">0.0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 生成高频保留高斯滤波器（小σ值滤波器）
gen_gauss_filter (GaussFilter2, Sigma2, Sigma2, </span><span style="color: rgba(128, 0, 128, 1)">0.0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">rft</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height)
</span>* 合成带阻滤波器（Gauss1 -<span style="color: rgba(0, 0, 0, 1)"> Gauss2）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 效果：抑制低频（背景纹理）同时保留高频（缺陷）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   <span style="color: rgba(128, 0, 128, 1)">1</span> -<span style="color: rgba(0, 0, 0, 1)"> 缩放因子（保持滤波器强度范围）
</span>*   <span style="color: rgba(128, 0, 128, 1)">0</span> -<span style="color: rgba(0, 0, 0, 1)"> 偏移量（不做亮度调整）
sub_image (GaussFilter1, GaussFilter2, Filter, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* ​*************** 主检测流程模块 ​***************
*<span style="color: rgba(0, 0, 0, 1)"> 定义检测图像数量（支持批量处理）
NumImages :</span>= <span style="color: rgba(128, 0, 128, 1)">2</span>
*<span style="color: rgba(0, 0, 0, 1)"> 开始多图像批处理循环
</span><span style="color: rgba(0, 0, 255, 1)">for</span> Index := <span style="color: rgba(128, 0, 128, 1)">1</span> to NumImages by <span style="color: rgba(128, 0, 128, 1)">1</span>
    * ​*************** 图像采集与预处理模块 ​***************
    *<span style="color: rgba(0, 0, 0, 1)"> 读取当前检测图像（支持序列号补零命名格式）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 文件名示例：plastics_01.bmp, plastics_02.bmp...
    read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">plastics_</span><span style="color: rgba(128, 0, 0, 1)">'</span> + Index+<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">.bmp</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 转换为灰度图像（兼容彩色相机输入）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 注意：使用rgb1_to_gray保持亮度线性转换
    rgb1_to_gray (Image, Image)
    
    </span>* ​*************** 频域处理模块 ​***************
    *<span style="color: rgba(0, 0, 0, 1)"> 执行FFT正变换（空间域→频域）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">to_freq</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 正变换方向
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 不进行窗函数处理
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">complex</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 输出复数格式频域数据
    rft_generic (Image, ImageFFT, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">to_freq</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">complex</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 频域卷积运算（应用预设计滤波器）
    </span>* 原理：F(f*h) =<span style="color: rgba(0, 0, 0, 1)"> F(f)·F(h)（频域乘法等效空域卷积）
    convol_fft (ImageFFT, Filter, ImageConvol)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 执行FFT逆变换（频域→空间域）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">from_freq</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 逆变换方向
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">n</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 无标准化（保持动态范围）
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">real</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 输出实数图像
    rft_generic (ImageConvol, ImageFiltered, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">from_freq</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">n</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">real</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Width)
    
    </span>* ​*************** 后处理与缺陷提取模块 ​***************
    *<span style="color: rgba(0, 0, 0, 1)"> 计算局部灰度范围（增强缺陷对比度）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*<span style="color: rgba(0, 0, 0, 1)">   10x10邻域窗口（需大于缺陷尺寸）
    </span>*<span style="color: rgba(0, 0, 0, 1)">   效果：突出缺陷边缘与纹理异常
    gray_range_rect (ImageFiltered, ImageResult, </span><span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算图像灰度极值（用于动态阈值设定）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*   <span style="color: rgba(128, 0, 128, 1)">0</span> -<span style="color: rgba(0, 0, 0, 1)"> 忽略边界像素（避免边缘效应影响）
    min_max_gray (ImageResult, ImageResult, </span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, Min, Max, Range)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 动态阈值分割（双阈值保护机制）
    </span>* 阈值逻辑：取固定阈值5.55和最大值的80%<span style="color: rgba(0, 0, 0, 1)">中较大者
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 设计目的：既防止低对比度缺陷漏检，又避免噪声干扰
    threshold (ImageResult, RegionDynThresh, max([</span><span style="color: rgba(128, 0, 128, 1)">5.55</span>,Max * <span style="color: rgba(128, 0, 128, 1)">0.8</span>]), <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 连通域分析（分离独立缺陷区域）
    connection (RegionDynThresh, ConnectedRegions)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 初级面积筛选（过滤4像素以下噪声）
    select_shape (ConnectedRegions, SelectedRegions, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">area</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">and</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">99999</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 区域合并（防止同一缺陷被分割为多个区域）
    union1 (SelectedRegions, RegionUnion)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 闭运算处理（填充微小孔洞，平滑缺陷边缘）
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*<span style="color: rgba(0, 0, 0, 1)">   10像素结构元（确保相邻缺陷合并）
    closing_circle (RegionUnion, RegionClosing, </span><span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 二次连通域分析
    connection (RegionClosing, ConnectedRegions1)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 最终面积筛选（确认有效缺陷区域）
    select_shape (ConnectedRegions1, SelectedRegions1, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">area</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">and</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">99999</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算缺陷质心坐标（为后续定位提供数据）
    area_center (SelectedRegions1, Area, Row, Column)
    
    </span>* ​*************** 可视化与结果输出模块 ​***************
    *<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像（保持背景参考）
    dev_display (Image)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 统计缺陷数量
    Number :</span>= |Area|
    *<span style="color: rgba(0, 0, 0, 1)"> 生成缺陷标记图形（30像素半径红色圆圈）
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (Number)
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 创建圆形轮廓对象（XLD格式）
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
        </span>*   <span style="color: rgba(128, 0, 128, 1)">30</span> -<span style="color: rgba(0, 0, 0, 1)"> 圆环半径（根据缺陷尺寸调整）
        </span>*   <span style="color: rgba(128, 0, 128, 1)">0</span> -<span style="color: rgba(0, 0, 0, 1)"> 起始角度（完整圆环）
        </span>*   rad(<span style="color: rgba(128, 0, 128, 1)">360</span>) -<span style="color: rgba(0, 0, 0, 1)"> 结束角度
        </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">positive</span><span style="color: rgba(128, 0, 0, 1)">'</span> -<span style="color: rgba(0, 0, 0, 1)"> 顺时针方向
        </span>*   <span style="color: rgba(128, 0, 128, 1)">1</span> -<span style="color: rgba(0, 0, 0, 1)"> 相邻点间距（高分辨率绘制）
        gen_circle_contour_xld (ContCircle, Row, Column, gen_tuple_const(Number,</span><span style="color: rgba(128, 0, 128, 1)">30</span>), gen_tuple_const(Number,<span style="color: rgba(128, 0, 128, 1)">0</span>), gen_tuple_const(Number,rad(<span style="color: rgba(128, 0, 128, 1)">360</span>)), <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">positive</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">)
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 构造报警信息（显示缺陷数量）
        ResultMessage :</span>= [<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">Not OK</span><span style="color: rgba(128, 0, 0, 1)">'</span>,Number + <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> defect(s) found</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">]
        Color :</span>= [<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">red</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">]  
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 多颜色信息显示
        dev_display (ContCircle)
    </span><span style="color: rgba(0, 0, 255, 1)">else</span>
        *<span style="color: rgba(0, 0, 0, 1)"> 合格品显示绿色OK标识
        ResultMessage :</span>= <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">OK</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">
        Color :</span>= <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">forest green</span><span style="color: rgba(128, 0, 0, 1)">'</span>  
        *<span style="color: rgba(0, 0, 0, 1)"> 工业标准通过色
    endif
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 在图像左上角显示检测结果（坐标12,12避开检测区域）
    disp_message (WindowHandle, ResultMessage, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">window</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 128, 1)">12</span>, Color, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 非最后一张时显示继续提示（模拟产线节拍控制）
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (Index !=<span style="color: rgba(0, 0, 0, 1)"> NumImages)
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示标准继续提示（底部右对齐）
        disp_continue_message (WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        stop ()  
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 暂停等待操作员确认
    endif
endfor

</span>* ​*************** 参数说明表（供工程调试参考） ​***************
* | 参数                  | 作用                                   | 工业调参建议               |
* |-----------------------|----------------------------------------|--------------------------|
* | Sigma1=<span style="color: rgba(128, 0, 128, 1)">10.0</span>          | 控制背景纹理抑制范围                   | 根据正常纹理周期调整       |
* |                       | 公式：Sigma1 ≈ 纹理周期/<span style="color: rgba(128, 0, 128, 1)">2</span>              | 使用FFT频谱分析确定周期    |
* | Sigma2=<span style="color: rgba(128, 0, 128, 1)">3.0</span>           | 控制缺陷特征保留范围                   | 根据最小缺陷尺寸调整       |
* |                       | 公式：Sigma2 ≈ 最小缺陷半径             | 需考虑点扩散函数影响       |
* | gray_range_rect(<span style="color: rgba(128, 0, 128, 1)">10</span>,<span style="color: rgba(128, 0, 128, 1)">10</span>)| 局部对比度增强窗口                     | 窗口尺寸=<span style="color: rgba(128, 0, 128, 1)">2</span>×缺陷直径        |
* | threshold(<span style="color: rgba(128, 0, 128, 1)">5.55</span>/<span style="color: rgba(128, 0, 128, 1)">0</span>.8Max)| 动态双阈值机制                         | <span style="color: rgba(128, 0, 128, 1)">5</span>.55对应3σ噪声水平（8bit） |
* | closing_circle(<span style="color: rgba(128, 0, 128, 1)">10</span>)    | 缺陷区域平滑参数                       | 结构元直径=允许缺陷间距     |</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">结果图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250321163239785-678849688.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">未完待续。。。。。。。。。。。。</span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    转发和使用本文，请注明作者信息和原文地址---本文原作者为aircraft

---大家好我是徐飞机，有没有大佬们的公司招c++开发/图像处理/opengl/opencv/halcon实习的啊，带上我一个呗QAQ。。。hhhhhh  想要免费获取前端，后端，c/c++,matlab，Python，opencv，机器学习，深度学习，安卓，java，等等全套视频教程请关注机器视觉开发公众号，转发集赞28即可百度云获得hhhhhhhh
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8705383238912037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 17:27">2025-03-21 17:26</span>&nbsp;
<a href="https://www.cnblogs.com/DOMLX">aircraft</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18785484" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18785484);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18785484', targetLink: 'https://www.cnblogs.com/DOMLX/p/18785484', title: 'halcon 入门教程（五） 缺陷检测' })">举报</a>
</div>
        