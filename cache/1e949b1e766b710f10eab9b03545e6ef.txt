
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18928233" title="发布于 2025-06-14 13:27">
    <span role="heading" aria-level="2">智能指针</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 C++ 中，智能指针（smart pointers）是用于管理动态分配对象生命周期的类模板。它们旨在帮助开发者自动管理内存，避免常见的内存泄漏问题，并简化资源管理。C++ 标准库提供了三种主要类型的智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。每种类型都有其特定的应用场景。</p>
<h1 id="智能指针的作用">智能指针的作用</h1>
<ol>
<li><strong>自动内存管理</strong>：智能指针能够自动释放所指向的对象，从而避免了手动调用 <code>delete</code> 可能导致的内存泄漏。</li>
<li><strong>所有权语义</strong>：
<ul>
<li><code>std::unique_ptr</code> 实现独占所有权（exclusive ownership），即一个对象只能由一个 <code>std::unique_ptr</code> 所有。</li>
<li><code>std::shared_ptr</code> 支持共享所有权（shared ownership），允许多个 <code>std::shared_ptr</code> 共同拥有同一个对象。</li>
<li><code>std::weak_ptr</code> 用于解决循环引用的问题，它提供了一种非拥有的引用方式来观察 <code>std::shared_ptr</code> 管理的对象。</li>
</ul>
</li>
</ol>
<h1 id="如何使用智能指针">如何使用智能指针</h1>
<h2 id="1-stdunique_ptr">1. <code>std::unique_ptr</code></h2>
<ul>
<li><strong>作用</strong>：确保只有一个指针可以指向某个对象，当该 <code>std::unique_ptr</code> 超出作用域或被显式删除时，其所管理的对象会被自动销毁。</li>
<li><strong>使用示例</strong>：</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt; // 包含智能指针相关的头文件

int main() {
    // 创建一个 unique_ptr 指向一个新的 int 对象
    std::unique_ptr&lt;int&gt; smartPtr = std::make_unique&lt;int&gt;(10);
    
    if (smartPtr) {
        std::cout &lt;&lt; "Value: " &lt;&lt; *smartPtr &lt;&lt; std::endl;
    }

    // 不需要手动调用 delete，离开作用域时自动释放
    return 0;
}
</code></pre>
<ul>
<li><strong>转移所有权</strong>：</li>
</ul>
<pre><code class="language-cpp">auto anotherPtr = std::move(smartPtr); // 将所有权从 smartPtr 转移到 anotherPtr
// 此时 smartPtr 已经不再拥有任何对象，anotherPtr 拥有原始对象
</code></pre>
<h2 id="2-stdshared_ptr">2. <code>std::shared_ptr</code></h2>
<ul>
<li><strong>作用</strong>：允许多个 <code>std::shared_ptr</code> 同时指向同一个对象，并且只有当最后一个 <code>std::shared_ptr</code> 被销毁时，该对象才会被释放。</li>
<li><strong>使用示例</strong>：</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(20);
    
    {
        std::shared_ptr&lt;int&gt; sp2 = sp1; // 增加引用计数
        std::cout &lt;&lt; "sp1 use count: " &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出 2
    } // sp2 超出作用域，引用计数减少

    std::cout &lt;&lt; "sp1 use count after sp2 is destroyed: " &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出 1
    
    return 0;
}
</code></pre>
<h2 id="3-stdweak_ptr">3. <code>std::weak_ptr</code></h2>
<h3 id="主要作用">主要作用：</h3>
<h3 id="1-解决循环引用reference-cycle问题">1. <strong>解决循环引用（reference cycle）问题</strong></h3>
<p>当两个或多个 <code>shared_ptr</code> 相互引用时，会导致内存泄漏（因为引用计数永远不为0）。用 <code>weak_ptr</code> 打破这种循环引用是它最主要的用途。</p>
<pre><code class="language-cpp">struct B;
struct A {
    std::shared_ptr&lt;B&gt; b_ptr;
};
struct B {
    std::weak_ptr&lt;A&gt; a_ptr;  // 用 weak_ptr 避免循环引用
};
</code></pre>
<h3 id="2-临时访问共享资源不延长资源生命周期">2. <strong>临时访问共享资源，不延长资源生命周期</strong></h3>
<p>有时你希望访问某个资源，但不希望因为你访问它就延长它的生命，这时候就用 <code>weak_ptr</code>。</p>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(42);
std::weak_ptr&lt;int&gt; wp = sp; // 不增加引用计数

if (auto spt = wp.lock()) {  // lock() 返回 shared_ptr，如果资源已释放则返回空指针
    std::cout &lt;&lt; *spt &lt;&lt; '\n';
} else {
    std::cout &lt;&lt; "资源已经被释放\n";
}
</code></pre>
<h2 id="weak_ptr-和-shared_ptr关系"><code>weak_ptr</code> 和 <code>shared_ptr</code>关系</h2>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 是 C++ 智能指针库中的两个紧密相关的类型，它们的关系可以从以下几个方面来理解：</p>
<ol>
<li>
<h3 id="weak_ptr-是对-shared_ptr-的一种非拥有引用"><strong><code>weak_ptr</code> 是对 <code>shared_ptr</code> 的一种“非拥有”引用</strong></h3>
</li>
</ol>
<ul>
<li><code>shared_ptr</code> 管理资源的<strong>生命周期</strong>，并维护<strong>引用计数（use_count）</strong>。</li>
<li><code>weak_ptr</code> 观察由 <code>shared_ptr</code> 管理的资源，但<strong>不参与引用计数</strong>，也不会影响资源的释放时间。</li>
</ul>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(10);
std::weak_ptr&lt;int&gt; wp = sp;  // wp 不增加引用计数
</code></pre>
<hr>
<h3 id="2-weak_ptr-可以从-shared_ptr-构造而来反之不能直接构造">2. <strong><code>weak_ptr</code> 可以从 <code>shared_ptr</code> 构造而来，反之不能直接构造</strong></h3>
<ul>
<li>✅ 从 <code>shared_ptr</code> 创建 <code>weak_ptr</code>（不会增加引用计数）：</li>
</ul>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; sp = std::make_shared&lt;MyClass&gt;();
std::weak_ptr&lt;MyClass&gt; wp = sp;
</code></pre>
<ul>
<li>❌ 不能直接从 <code>weak_ptr</code> 获得裸指针或引用，需要先调用 <code>.lock()</code> 获取 <code>shared_ptr</code>：</li>
</ul>
<pre><code class="language-cpp">if (auto spt = wp.lock()) {
    // 使用 spt 访问对象
}
</code></pre>
<hr>
<h3 id="3-共享相同的引用控制块control-block">3. <strong>共享相同的引用控制块（control block）</strong></h3>
<ul>
<li><code>shared_ptr</code> 和由它生成的 <code>weak_ptr</code> 都共享同一个控制块。
<ul>
<li>控制块中包含：
<ul>
<li><code>use_count</code>：当前有多少个 <code>shared_ptr</code> 拥有资源。</li>
<li><code>weak_count</code>：当前有多少个 <code>weak_ptr</code> 引用控制块。</li>
</ul>
</li>
</ul>
</li>
<li>当 <code>use_count == 0</code> 时，资源被释放；</li>
<li>当 <code>use_count == 0 &amp;&amp; weak_count == 0</code> 时，控制块本身也被销毁。</li>
</ul>
<hr>
<h3 id="4-典型应用场景解决循环引用">4. <strong>典型应用场景：解决循环引用</strong></h3>
<p>在两个类相互引用时，如果都用 <code>shared_ptr</code>，就可能发生资源无法释放的问题（循环引用）。这时，应该让其中一方使用 <code>weak_ptr</code>。</p>
<pre><code class="language-cpp">struct Node {
    std::shared_ptr&lt;Node&gt; next;
    std::weak_ptr&lt;Node&gt; prev;  // 防止循环引用
};
</code></pre>
<hr>
<h3 id="总结一句话">总结一句话：</h3>
<blockquote>
<p><code>shared_ptr</code> 是资源的“所有者”，<code>weak_ptr</code> 是资源的“旁观者”；<code>weak_ptr</code> 依赖 <code>shared_ptr</code> 存在，不能单独使用。</p>
</blockquote>
<hr>
<p>如果你希望一个对象共享资源 → 用 <code>shared_ptr</code>； 如果你希望访问但不拥有资源（避免循环引用或延长生命周期）→ 用 <code>weak_ptr</code>。</p>
<h3 id="使用-weak_ptr-的几个关键点">使用 weak_ptr 的几个关键点：</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>weak_ptr&lt;T&gt;</code></td>
<td>不拥有资源，不增加引用计数</td>
</tr>
<tr>
<td><code>.lock()</code></td>
<td>尝试获取资源的 <code>shared_ptr</code>，可能为空</td>
</tr>
<tr>
<td><code>.expired()</code></td>
<td>判断资源是否已经被销毁</td>
</tr>
<tr>
<td><code>.use_count()</code></td>
<td>返回当前资源被多少个 <code>shared_ptr</code> 拥有</td>
</tr>
</tbody>
</table>
<h1 id="智能指针的生命周期">智能指针的生命周期</h1>
<p><strong><code>shared_ptr</code>、<code>weak_ptr</code> 和 <code>unique_ptr</code> 这些智能指针对象本身在离开作用域时会立刻被析构。</strong>智能指针对象本身（<code>shared_ptr</code>、<code>weak_ptr</code>、<code>unique_ptr</code>）在离开作用域时都会<strong>立刻析构</strong>；是否释放资源，取决于它是否拥有资源，以及资源的引用计数是否归零。</p>
<hr>
<h2 id="关键点总结">关键点总结：</h2>
<table>
<thead>
<tr>
<th>智能指针类型</th>
<th>指针对象（自身）离开作用域是否立刻析构？</th>
<th>资源是否一定被释放？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unique_ptr</code></td>
<td>✅ 是，立刻析构</td>
<td>✅ 是，立即释放资源</td>
</tr>
<tr>
<td><code>shared_ptr</code></td>
<td>✅ 是，立刻析构</td>
<td>⚠️ 仅当引用计数为 0 时释放资源</td>
</tr>
<tr>
<td><code>weak_ptr</code></td>
<td>✅ 是，立刻析构</td>
<td>❌ 否，不影响资源是否释放（不拥有资源）</td>
</tr>
</tbody>
</table>
<h3 id="-unique_ptr">🔹 <code>unique_ptr</code></h3>
<ul>
<li><strong>拥有唯一资源</strong>，离开作用域时：
<ul>
<li>智能指针对象本身被析构 ✅</li>
<li>所管理的资源也立即 <code>delete</code> ✅</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">{
    std::unique_ptr&lt;int&gt; up = std::make_unique&lt;int&gt;(10);
} // up 被销毁，对象立即释放
</code></pre>
<hr>
<h3 id="-shared_ptr">🔹 <code>shared_ptr</code></h3>
<ul>
<li><strong>拥有共享资源</strong>，离开作用域时：
<ul>
<li>智能指针对象本身析构 ✅</li>
<li>资源只有在所有 <code>shared_ptr</code> 都销毁（引用计数 = 0）时才被释放 ⚠️</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">{
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(20);
    {
        std::shared_ptr&lt;int&gt; sp2 = sp1; // use_count = 2
    } // sp2 析构，但资源还没释放
} // sp1 析构，use_count = 0，资源释放
</code></pre>
<hr>
<h3 id="-weak_ptr">🔹 <code>weak_ptr</code></h3>
<ul>
<li><strong>不拥有资源</strong>，离开作用域时：
<ul>
<li><code>weak_ptr</code> 对象立刻析构 ✅</li>
<li>它观察的资源不会受影响 ❌</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">{
    std::weak_ptr&lt;int&gt; wp;
    {
        std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(30);
        wp = sp;
    } // sp 析构，资源释放
} // wp 析构，但没影响资源释放时机
</code></pre>
<p>下面是一个完整的 C++ 示例程序，<strong>清晰演示了 <code>shared_ptr</code>、<code>weak_ptr</code> 和 <code>unique_ptr</code> 在何时被销毁</strong>（对象析构）。</p>
<p>我们定义一个简单的类，打印构造与析构，以便观察指针何时释放资源：</p>
<hr>
<h3 id="-示例代码含注释">✅ 示例代码（含注释）：</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass {
public:
    MyClass(int val) : value(val) {
        std::cout &lt;&lt; "MyClass(" &lt;&lt; value &lt;&lt; ") constructed.\n";
    }
    ~MyClass() {
        std::cout &lt;&lt; "MyClass(" &lt;&lt; value &lt;&lt; ") destructed.\n";
    }

private:
    int value;
};

void demo_shared_ptr() {
    std::cout &lt;&lt; "\n[shared_ptr demo]\n";
    std::shared_ptr&lt;MyClass&gt; sp1 = std::make_shared&lt;MyClass&gt;(1);
    {
        std::shared_ptr&lt;MyClass&gt; sp2 = sp1;
        std::cout &lt;&lt; "shared_ptr use_count: " &lt;&lt; sp1.use_count() &lt;&lt; "\n";
    } // sp2 离开作用域，use_count 减 1
    std::cout &lt;&lt; "shared_ptr use_count: " &lt;&lt; sp1.use_count() &lt;&lt; "\n";
} // sp1 离开作用域，对象析构

void demo_weak_ptr() {
    std::cout &lt;&lt; "\n[weak_ptr demo]\n";
    std::weak_ptr&lt;MyClass&gt; wp;
    {
        std::shared_ptr&lt;MyClass&gt; sp = std::make_shared&lt;MyClass&gt;(2);
        wp = sp;
        std::cout &lt;&lt; "Inside scope, expired? " &lt;&lt; std::boolalpha &lt;&lt; wp.expired() &lt;&lt; "\n";
    } // sp 被销毁，资源被释放
    std::cout &lt;&lt; "Outside scope, expired? " &lt;&lt; std::boolalpha &lt;&lt; wp.expired() &lt;&lt; "\n";
    if (auto locked = wp.lock()) {
        std::cout &lt;&lt; "locked shared_ptr is valid\n";
    } else {
        std::cout &lt;&lt; "locked shared_ptr is null\n";
    }
}

void demo_unique_ptr() {
    std::cout &lt;&lt; "\n[unique_ptr demo]\n";;

    std::unique_ptr&lt;MyClass&gt; up1 = std::make_unique&lt;MyClass&gt;(3);
    std::cout &lt;&lt; "up1 owns the resource\n";

    // std::unique_ptr&lt;MyClass&gt; up2 = up1; // ❌ 错误：不能拷贝
    std::unique_ptr&lt;MyClass&gt; up2 = std::move(up1); // ✅ 移动所有权

    if (!up1) {
        std::cout &lt;&lt; "up1 is now null after move\n";
    }
    if (up2) {
        std::cout &lt;&lt; "up2 owns the resource after move\n";
    }

    // 用 reset() 释放当前对象
    up2.reset();  // 调用析构函数，释放 MyClass(3)
    std::cout &lt;&lt; "up2.reset() called, resource released\n";

    // 用 reset(new T) 替换为新的对象
    up2.reset(new MyClass(4));
    std::cout &lt;&lt; "up2 now owns a new object\n";

    // 离开作用域后，up2 自动释放新对象 MyClass(4)
}


int main() {
    demo_shared_ptr();
    demo_weak_ptr();
    demo_unique_ptr();
    std::cout &lt;&lt; "\n[Program End]\n";
    return 0;
}

</code></pre>
<hr>
<h3 id="-输出示例说明资源释放时机">🧾 输出示例（说明资源释放时机）：</h3>
<pre><code class="language-text">[shared_ptr demo]
MyClass(1) constructed.
shared_ptr use_count: 2
shared_ptr use_count: 1
MyClass(1) destructed.

[weak_ptr demo]
MyClass(2) constructed.
Inside scope, expired? false
MyClass(2) destructed.
Outside scope, expired? true
locked shared_ptr is null

[unique_ptr demo with move and reset]
MyClass(3) constructed.
up1 owns the resource
up1 is now null after move
up2 owns the resource after move
MyClass(3) destructed.
up2.reset() called, resource released
MyClass(4) constructed.
up2 now owns a new object
MyClass(4) destructed.

[Program End]
</code></pre>
<hr>
<h2 id="总结">总结</h2>
<ul>
<li><strong><code>std::unique_ptr</code></strong>：适用于单一所有权的情况，是最轻量级的选择，性能最优。</li>
<li><strong><code>std::shared_ptr</code></strong>：适用于需要多个指针共享同一资源的场景，但要注意潜在的性能开销和循环引用问题。</li>
<li><strong><code>std::weak_ptr</code></strong>：通常与 <code>std::shared_ptr</code> 结合使用，用来解决循环引用问题，或者仅作为临时引用而不影响对象生命周期。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18928233" target="_blank">https://www.cnblogs.com/aslanvon/p/18928233</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-14 13:27">2025-06-14 13:27</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">44</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18928233);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18928233', targetLink: 'https://www.cnblogs.com/aslanvon/p/18928233', title: '智能指针' })">举报</a>
</div>
        