
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fnng/p/18744210" title="发布于 2025-02-28 22:02">
    <span role="heading" aria-level="2">一文搞懂 MCP Servers</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.008386952782407408" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 22:03">2025-02-28 22:02</span>&nbsp;
<a href="https://www.cnblogs.com/fnng">虫师</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18744210" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18744210);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18744210', targetLink: 'https://www.cnblogs.com/fnng/p/18744210', title: '一文搞懂 MCP Servers' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="一文搞懂-mcp-servers">一文搞懂 MCP Servers</h1>
<h2 id="什么是mcp">什么是MCP</h2>
<h3 id="mcp概念">MCP概念</h3>
<p>MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 提出并于 2024 年 11 月开源的一种通信协议，旨在解决大型语言模型（LLM）与外部数据源及工具之间无缝集成的需求。</p>
<p>它通过标准化 AI 系统与数据源的交互方式，帮助模型获取更丰富的上下文信息，从而生成更准确、更相关的响应。</p>
<h3 id="主要功能">主要功能</h3>
<ul>
<li><code>上下文共享</code>：应用程序可以通过 MCP 向模型提供所需的上下文信息（如文件内容、数据库记录等），增强模型的理解能力。</li>
<li><code>工具暴露</code>：MCP 允许应用程序将功能（如文件读写、API 调用）暴露给模型，模型可以调用这些工具完成复杂任务。</li>
<li><code>可组合的工作流</code>：开发者可以利用 MCP 集成多个服务和组件，构建灵活、可扩展的 AI 工作流。</li>
<li><code>安全性</code>：通过本地服务器运行，MCP 避免将敏感数据上传至第三方平台，确保数据隐私。</li>
</ul>
<h3 id="mcp架构">MCP架构</h3>
<p>MCP 采用客户端-服务器架构：</p>
<ul>
<li><code>MCP 客户端（Client）</code>：通常是 AI 应用程序（如 Claude Desktop 或其他 LLM 工具），负责发起请求并与服务器通信。</li>
<li><code>MCP 服务器（Server）</code>：轻量级程序，负责暴露特定的数据源或工具功能，并通过标准化协议与客户端交互。</li>
</ul>
<p><strong>通信格式</strong>：基于 <code>JSON-RPC 2.0</code>，支持请求、响应和通知三种消息类型，确保通信的标准化和一致性。</p>
<h2 id="mcp-servers主要功能">MCP Servers主要功能</h2>
<p>MCP Servers 作为一个轻量级的本地服务，旨在为客户端提供数据访问和功能执行的接口。</p>
<p><strong>1. 资源暴露（Resource Exposure）</strong></p>
<p>资源是服务器提供给客户端的数据实体，可以是文件、数据库记录、内存中的对象等。</p>
<p>例如：</p>
<ul>
<li>文件资源：<code>file:///home/user/report.txt</code></li>
<li>内存资源：<code>memo://recent-insights</code></li>
</ul>
<p><strong>2. 工具提供（Tool Provisioning）</strong></p>
<p>工具是服务器暴露的可执行功能，客户端可以通过调用这些工具完成特定任务。</p>
<p>例如：</p>
<ul>
<li>查询数据库：<code>query_database</code>（参数：SQL 语句，返回：查询结果）</li>
<li>文件写入：<code>write_file</code>（参数：文件路径、内容）</li>
</ul>
<p><strong>3. 动态通知（Dynamic Notification）</strong></p>
<p>当资源发生变化时，服务器可以通过通知机制（如 notification 消息）主动推送更新到客户端。</p>
<p><strong>4. 会话管理（Session Management）</strong></p>
<p>处理客户端的连接初始化、能力协商和会话关闭。</p>
<h3 id="自定义-mcp-servers">自定义 MCP Servers</h3>
<ol>
<li>本地实现一个文件资源服务，创建 <code>mcp_server.py</code> 文件。</li>
</ol>
<pre><code class="language-python">import json
import sys

# 处理客户端请求
def handle_request(request):
    method = request.get("method")
    params = request.get("params", {})
    request_id = request.get("id")

    if method == "initialize":
        return {
            "jsonrpc": "2.0",
            "result": {"version": "1.0", "capabilities": ["resources", "tools"]},
            "id": request_id
        }
    elif method == "read_resource":
        uri = params.get("uri")
        with open(uri.replace("file:///", ""), "r") as f:
            content = f.read()
        return {"jsonrpc": "2.0", "result": content, "id": request_id}
    elif method == "call_tool":
        tool_name = params.get("name")
        if tool_name == "echo":
            return {"jsonrpc": "2.0", "result": params.get("message"), "id": request_id}
    else:
        return {"jsonrpc": "2.0", "error": {"code": -32601, "message": "Method not found"}, "id": request_id}

# 主循环：通过 Stdio 通信
def main():
    while True:
        # 从 stdin 读取请求
        raw_input = sys.stdin.readline().strip()
        if not raw_input:
            break
        request = json.loads(raw_input)
        
        # 处理请求并返回响应
        response = handle_request(request)
        sys.stdout.write(json.dumps(response) + "\n")
        sys.stdout.flush()

if __name__ == "__main__":
    main()
</code></pre>
<ol start="2">
<li>通过 python 启动服务</li>
</ol>
<pre><code class="language-shell">python mcp_server.py
</code></pre>
<ol start="3">
<li>在相同的目录下创建 <code>test.txt</code> 文件。</li>
</ol>
<pre><code class="language-txt">Hello, this is a test file!
</code></pre>
<ol start="4">
<li>另外启动一个命令窗口，输入：</li>
</ol>
<pre><code class="language-shell">echo '{"jsonrpc": "2.0", "method": "read_resource", "params": {"uri": "file:///D:/path/to/test.txt"}, "id": 2}' | python mcp_server.py

{"jsonrpc": "2.0", "result": "Hello, this is a test file!", "id": 2}
</code></pre>
<blockquote>
<p>注：此处使用的是 PowerShell，我们看到服务返回了文件的内容。</p>
</blockquote>
<h3 id="使用现有-mcp-servers">使用现有 MCP Servers</h3>
<p>GitHub：在 GitHub 上查找 MCP servers：</p>
<ul>
<li><a href="https://github.com/modelcontextprotocol/servers" target="_blank" rel="noopener nofollow">https://github.com/modelcontextprotocol/servers</a></li>
<li><a href="https://github.com/punkpeye/awesome-mcp-servers" target="_blank" rel="noopener nofollow">https://github.com/punkpeye/awesome-mcp-servers</a></li>
</ul>
<p>网站：通过下面的网站查找 MCP servers：</p>
<ul>
<li><a href="https://mcpservers.org" target="_blank" rel="noopener nofollow">https://mcpservers.org</a></li>
<li><a href="https://mcp.so" target="_blank" rel="noopener nofollow">https://mcp.so</a></li>
<li><a href="https://glama.ai/mcp/servers" target="_blank" rel="noopener nofollow">https://glama.ai/mcp/servers</a></li>
<li><a href="https://www.pulsemcp.com/" target="_blank" rel="noopener nofollow">https://www.pulsemcp.com/</a></li>
</ul>
<p>UI自动化相关的 MCP servers</p>
<ul>
<li><code>playwright</code>: <a href="https://github.com/executeautomation/mcp-playwright" target="_blank" rel="noopener nofollow">https://github.com/executeautomation/mcp-playwright</a></li>
<li><code>browserbase</code>: <a href="https://github.com/browserbase/mcp-server-browserbase" target="_blank" rel="noopener nofollow">https://github.com/browserbase/mcp-server-browserbase</a></li>
<li><code>puppeteer</code> <a href="https://github.com/modelcontextprotocol/servers/tree/HEAD/src/puppeteer" target="_blank" rel="noopener nofollow">https://github.com/modelcontextprotocol/servers/tree/HEAD/src/puppeteer</a></li>
</ul>
<p>我们以 Playwright 项目为例子。</p>
<p>playwright 项目：<a href="https://github.com/AutoTestClass/playwright-mind" target="_blank" rel="noopener nofollow">https://github.com/AutoTestClass/playwright-mind</a></p>
<p>在项目里添加 <code>playwright-mcp-server</code>：</p>
<pre><code class="language-shell">git clone https://github.com/AutoTestClass/playwright-mind
cd playwright-mind
npm install -g @executeautomation/playwright-mcp-server # &lt;--添加--
</code></pre>
<h2 id="mcp-client">MCP Client</h2>
<p>MCP client 一般选用 AI 应用程序（如 Claude Desktop、cline 或其他 LLM 工具），负责发起请求并与服务器通信。</p>
<p>我们这里选用 VSCode + cline 的组合，关于二者的使用，铺天盖地都是使用的文章，这里就不介绍了。</p>
<ol>
<li>首先，在 VSCode 中打开 cline 插件，在 MCP servers 中搜索 <code>playwright</code> 插件安装。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/311516/202502/311516-20250228220138838-1104260440.jpg" alt="" loading="lazy"></p>
<ol start="2">
<li>然后，配置 <code>playwright mcp servers</code> 的启动配置。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/311516/202502/311516-20250228220153092-1999222913.png" alt="" loading="lazy"></p>
<pre><code class="language-json">{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["-y", "@executeautomation/playwright-mcp-server"]
    }
  }
}
</code></pre>
<ol start="3">
<li>最后，通过 LLM 大模型，描述需求（UI 自动化相关操作），LLM 大模型会通过 <code>playwright MCP servers</code> 启动浏览器完成一些 UI 自动化操作。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/311516/202502/311516-20250228220111494-817815781.png" alt="" loading="lazy"></p>
<h2 id="mcp-servers的作用">MCP Servers的作用</h2>
<p>最后，我们再来总结 MCP Servers 的作用。懒得画图了，下面是我网上找的一张图。结合前面的操作流程，相信你已经知道 MCP Servers 可以做什么了。</p>
<p><img src="https://img2024.cnblogs.com/blog/311516/202502/311516-20250228220052485-1773961888.png" alt="" loading="lazy"></p>
<p>MCP Servers 真正的价值不在于我们传统的 UI 自动化测试，因为它是通过文字描述操作浏览器去完成一些工作。并没有自动化的脚本沉淀，当然，如果你把 <code>Prompt</code> 沉淀下来当作自动化脚本也是可以的，这确实颠覆了我们写自动化脚本的形式。<br>
当然，MCP Servers 更多的价值不是浏览器自动化，而是利用 LLM 操作本地资源，例如，本地文件，数据库、git 等。想想 <strong>你不需要写复杂的 SQL 语句，通过自然语言描述就可以轻松完成本地数据库的操作。</strong> 这种效率的提升是非常明显。</p>
<p><img src="https://img2024.cnblogs.com/blog/311516/202502/311516-20250228220031097-892932542.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="fnng" blog-id="91739" post-id="18744210"></vc:categories-tags>
    </ul>
