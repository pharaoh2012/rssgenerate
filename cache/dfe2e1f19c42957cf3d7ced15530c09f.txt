
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nogeek-cn/p/18725586" title="发布于 2025-02-19 23:34">
    <span role="heading" aria-level="2">百万架构师第四十课：RabbitMq：RabbitMq-工作模型与JAVA编程｜JavaGuide</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://javaguide.net" target="_blank" rel="noopener nofollow">来源</a>：<a href="https://javaguide.net" target="_blank" rel="noopener nofollow">https://javaguide.net</a></p>
<h1 id="rabbitmq-1-工作模型与java编程">RabbitMQ 1-工作模型与Java编程</h1>
<h1 id="课前准备">课前准备</h1>
<h2 id="预习资料">预习资料</h2>
<p><a href="https://blog.csdn.net/qq_31634461/article/details/79377256" target="_blank" rel="noopener nofollow">Windows安装步骤</a></p>
<p><a href="http://blog.51cto.com/zengestudy/1870247" target="_blank" rel="noopener nofollow">Linux安装步骤</a></p>
<p><a href="https://www.jianshu.com/p/a6460b4b155f" target="_blank" rel="noopener nofollow">官网文章中文翻译系列</a></p>
<h2 id="环境说明">环境说明</h2>
<p>操作系统：CentOS 7 JDK：1.8</p>
<p>Erlang：19.0.4或<a href="http://www.rabbitmq.com/releases/erlang/" target="_blank" rel="noopener nofollow">最新版</a></p>
<p>RabbitMQ：3.6.12或<a href="http://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener nofollow">最新版</a> <a href="http://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener nofollow">版本对应关系</a></p>
<h1 id="典型应用场景">典型应用场景</h1>
<ol>
<li>跨系统的异步通信。人民银行二代支付系统，使用重量级消息队列 IBM MQ，异步，解耦，削峰都有体现。</li>
<li>应用内的同步变成异步。秒杀：自己发送给自己</li>
<li>基于Pub/Sub模型实现的事件驱动。放款失败通知、提货通知、购买碎屏保、系统间同步数据、摒弃ELT（比如全量同步商户数据）； 摒弃API（比如定时增量获取用户、获取产品，变成增量广播）。</li>
<li>利用RabbitMQ实现事务的最终一致性</li>
</ol>
<h1 id="基本介绍">基本介绍</h1>
<h2 id="amqp协议">AMQP协议</h2>
<p>​	AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。</p>
<p>​	AMQP的实现有：RabbitMQ、OpenAMQ、Apache Qpid、Redhat Enterprise MRG、AMQP Infrastructure、MQ、Zyre等。</p>
<h2 id="rabbitmq的特性">RabbitMQ的特性</h2>
<p>RabbitMQ使用Erlang语言编写，使用Mnesia数据库存储消息。</p>
<p>（1）可靠性（Reliability） RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p>
<p>（2）灵活的路由（Flexible Routing） 在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p>
<p>（3）消息集群（Clustering） 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p>
<p>（4）高可用（Highly Available Queues） 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p>
<p>（5）多种协议（Multi-protocol） RabbitMQ 支持多种消息队列协议，比如 AMQP、STOMP、MQTT 等等。</p>
<p>（6）多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby、PHP、C#、JavaScript 等等。</p>
<p>（7）管理界面（Management UI） RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点。</p>
<p>（8）插件机制（Plugin System）</p>
<p>RabbitMQ提供了许多插件，以实现从多方面扩展，当然也可以编写自己的插件。</p>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233418821-1814938729.png" alt="RabbitMQ_工作模型与Java编程_工作模型.png" loading="lazy"></p>
<h2 id="工作模型">工作模型</h2>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>即RabbitMQ的实体服务器。提供一种传输服务，维护一条从生产者到消费者的传输线路， 保证消息数据能按照指定的方式传输。</td>
</tr>
<tr>
<td>Exchange</td>
<td>消息交换机。指定消息按照什么规则路由到哪个队列Queue。</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。</td>
</tr>
<tr>
<td>Binding</td>
<td>绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。</td>
</tr>
<tr>
<td>Routing Key</td>
<td>路由关键字。Exchange根据Routing   Key进行消息投递。定义绑定时指定的关键字称为Binding Key。</td>
</tr>
<tr>
<td>Vhost</td>
<td>虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者。消息的接收者，一般是独立的程序。</td>
</tr>
<tr>
<td>Connection</td>
<td>Producer 和 Consumer 与Broker之间的TCP长连接。</td>
</tr>
<tr>
<td>Channel</td>
<td>消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一 个会话任务。在RabbitMQ Java Client   API中，channel上定义了大量的编程接口。</td>
</tr>
</tbody>
</table>
<p><strong>三种主要的交换机</strong></p>
<h3 id="direct-exchange-直连交换机">Direct Exchange 直连交换机</h3>
<p>定义：直连类型的交换机与一个队列绑定时，需要指定一个明确的binding key。</p>
<p>路由规则：发送消息到直连类型的交换机时，只有routing key跟binding  key完全匹配时，绑定的队列才能收到消息。</p>
<p>例如：</p>
<pre><code class="language-java">// 只有队列1能收到消息
channel.basicPublish("MY_DIRECT_EXCHANGE", "key1", null, msg.getBytes());
</code></pre>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233419283-943513821.png" alt="RabbitMQ_工作模型与Java编程_队列模型.png" loading="lazy"></p>
<h3 id="topic-exchange-主题交换机">Topic Exchange 主题交换机</h3>
<p>定义：主题类型的交换机与一个队列绑定时，可以指定按模式匹配的routing key。</p>
<p>通配符有两个，*代表匹配一个单词。#代表匹配零个或者多个单词。单词与单词之间用 . 隔开。</p>
<p>路由规则：发送消息到主题类型的交换机时，routing key符合binding key的模式时，绑定的队列才能收到消息。</p>
<p>例如：</p>
<pre><code class="language-java">// 只有队列1能收到消息
channel.basicPublish("MY_TOPIC_EXCHANGE", "sh.abc", null, msg.getBytes());
// 队列2和队列3能收到消息
channel.basicPublish("MY_TOPIC_EXCHANGE", "bj.book", null, msg.getBytes());
// 只有队列4能收到消息
channel.basicPublish("MY_TOPIC_EXCHANGE", "abc.def.food", null, msg.getBytes());
</code></pre>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233419695-2117883533.png" alt="RabbitMQ_工作模型与Java编程_队列模型_2.png" loading="lazy"></p>
<h3 id="fanout-exchange-广播交换机">Fanout Exchange 广播交换机</h3>
<p>定义：广播类型的交换机与一个队列绑定时，不需要指定binding key。</p>
<p>路由规则：当消息发送到广播类型的交换机时，不需要指定routing key，所有与之绑定的队列都能收到消息。</p>
<p>例如：</p>
<pre><code class="language-java">// 3个队列都会收到消息
channel.basicPublish("MY_FANOUT_EXCHANGE", "", null, msg.getBytes());
</code></pre>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233420033-8723175.png" alt="RabbitMQ_工作模型与Java编程_队列收到消息.png" loading="lazy"></p>
<h1 id="java-api-编程">Java API 编程</h1>
<h3 id="创建maven工程pomxml引入依赖">创建Maven工程，pom.xml引入依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
    &lt;version&gt;4.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>生产者</strong></p>
<pre><code class="language-java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
public class MyProducer {
   private final static String QUEUE_NAME = "ORIGIN_QUEUE";
   public static void main(String[] args) throws Exception {
       ConnectionFactory factory = new ConnectionFactory();
       // 连接IP
       factory.setHost("127.0.0.1");
       // 连接端口
       factory.setPort(5672);
       // 虚拟机
       factory.setVirtualHost("/");
       // 用户
       factory.setUsername("guest");
       factory.setPassword("guest");
       // 建立连接
       Connection conn = factory.newConnection();
       // 创建消息通道
       Channel channel = conn.createChannel();
       String msg = "Hello world, Rabbit MQ";
       // 声明队列
       // String queue, boolean durable, boolean exclusive, boolean autoDelete,
       Map&lt;String, Object&gt; arguments
           channel.queueDeclare(QUEUE_NAME, false, false, false, null);
       // 发送消息（发送到默认交换机AMQP Default，Direct）
       // 如果有一个队列名称跟Routing Key相等，那么消息会路由到这个队列
       // String exchange, String routingKey, BasicProperties props, byte[] body
       channel.basicPublish("", QUEUE_NAME, null, msg.getBytes());
       channel.close();
       conn.close();
   }
}
</code></pre>
<h3 id="消费者">消费者</h3>
<pre><code class="language-java">import com.rabbitmq.client.*;
import java.io.IOException;
public class MyConsumer {
   private final static String QUEUE_NAME = "ORIGIN_QUEUE";
   public static void main(String[] args) throws Exception {
       ConnectionFactory factory = new ConnectionFactory();
       // 连接IP
       factory.setHost("127.0.0.1");
       // 默认监听端口
       factory.setPort(5672);
       // 虚拟机
       factory.setVirtualHost("/");
       // 设置访问的用户
       factory.setUsername("guest");
       factory.setPassword("guest");
       // 建立连接
       Connection conn = factory.newConnection();
       // 创建消息通道
       Channel channel = conn.createChannel();
       // 声明队列
       // String queue, boolean durable, boolean exclusive, boolean autoDelete,
       Map&lt;String, Object&gt; arguments
           channel.queueDeclare(QUEUE_NAME, false, false, false, null);
       System.out.println(" Waiting for message....");
       // 创建消费者
       Consumer consumer = new DefaultConsumer(channel) {
           @Override
           public void handleDelivery(String consumerTag, Envelope envelope,
                                      AMQP.BasicProperties properties, byte[] body) throws IOException {
               String msg = new String(body, "UTF-8");
               System.out.println("Received message : '" + msg + "'");
           }
       };
       // 开始获取消息
       // String queue, boolean autoAck, Consumer callback
       channel.basicConsume(QUEUE_NAME, true, consumer);
   }
}
</code></pre>
<h3 id="参数说明">参数说明</h3>
<h4 id="声明交换机的参数">声明交换机的参数</h4>
<ul>
<li>String type：交换机的类型，direct, topic, fanout中的一种。</li>
<li>boolean durable：是否持久化，代表交换机在服务器重启后是否还存在。</li>
</ul>
<h4 id="声明队列的参数">声明队列的参数</h4>
<ul>
<li>boolean durable：是否持久化，代表队列在服务器重启后是否还存在。</li>
<li>boolean exclusive：是否排他性队列。排他性队列只能在声明它的Connection中使用，连接断开时自动删除。</li>
<li>boolean  autoDelete：是否自动删除。如果为true，至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，队列会自动删除。</li>
<li>Map&lt;String, Object&gt; arguments：队列的其他属性，例如
<ul>
<li>x-message-ttl、x-expires、x-max-length、x-max- length-bytes、x-dead-letter-exchange、x-dead-letter-routing-key、x-max-priority。</li>
</ul>
</li>
</ul>
<h4 id="消息属性basicproperties">消息属性BasicProperties</h4>
<p>消息的全部属性有14个，以下列举了一些主要的参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>释义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Map&lt;String,Object&gt; headers</td>
<td>消息的其他自定义参数</td>
</tr>
<tr>
<td>Integer deliveryMode</td>
<td>2持久化，其他：瞬态</td>
</tr>
<tr>
<td>Integer priority</td>
<td>消息的优先级</td>
</tr>
<tr>
<td>String correlationId</td>
<td>关联ID，方便RPC响应与请求关联</td>
</tr>
<tr>
<td>String replyTo</td>
<td>回调队列</td>
</tr>
<tr>
<td>String expiration</td>
<td>TTL，消息过期时间，单位毫秒</td>
</tr>
</tbody>
</table>
<h1 id="进阶知识">进阶知识</h1>
<h2 id="1ttltime-to-live">1、TTL（Time To Live）</h2>
<h3 id="a消息的过期时间">a、消息的过期时间</h3>
<p>有两种设置方式：</p>
<p>通过队列属性设置消息过期时间：</p>
<pre><code class="language-java">Map&lt;String, Object&gt; argss = new HashMap&lt;String, Object&gt;();
argss.put("x-message-ttl",6000);
channel.queueDeclare("TEST_TTL_QUEUE", false, false, false, argss);
</code></pre>
<p>设置单条消息的过期时间：</p>
<pre><code class="language-java">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
    .deliveryMode(2) // 持久化消息
    .contentEncoding("UTF-8")
    .expiration("10000") // TTL
    .build();
channel.basicPublish("", "TEST_TTL_QUEUE", properties, msg.getBytes());
</code></pre>
<h3 id="b队列的过期时间">b、队列的过期时间</h3>
<pre><code class="language-java">Map&lt;String, Object&gt; argss = new HashMap&lt;String, Object&gt;();
argss.put("x-message-ttl",6000);

channel.queueDeclare("TEST_TTL_QUEUE", false, false, false, argss);
</code></pre>
<p>队列的过期时间决定了在没有任何消费者以后，队列可以存活多久。</p>
<p>参考：</p>
<p>com.gupaoedu.ttl</p>
<h2 id="2死信队列">2、死信队列</h2>
<p>有三种情况消息会进入DLX（Dead Letter Exchange）死信交换机。</p>
<ol>
<li>(NACK || Reject ) &amp;&amp; requeue == false</li>
<li>消息过期</li>
<li>队列达到最大长度（先入队的消息会被发送到DLX）</li>
</ol>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233420314-1766433536.png" alt="RabbitMQ_工作模型与Java编程_死信队列.png" loading="lazy"></p>
<p>可以设置一个死信队列（Dead Letter Queue）与DLX绑定，即可以存储Dead Letter，消费者可以监听这个队列取走消息。</p>
<pre><code class="language-java">Map&lt;String,Object&gt; arguments = new HashMap&lt;String,Object&gt;();
arguments.put("x-dead-letter-exchange","DLX_EXCHANGE");
// 指定了这个队列的死信交换机
channel.queueDeclare("TEST_DLX_QUEUE", false, false, false, arguments);
// 声明死信交换机
channel.exchangeDeclare("DLX_EXCHANGE","topic", false, false, false, null);
// 声明死信队列
channel.queueDeclare("DLX_QUEUE", false, false, false, null);
// 绑定
channel.queueBind("DLX_QUEUE","DLX_EXCHANGE","#");
</code></pre>
<p>参考：</p>
<p>com.gupaoedu.dlx</p>
<h2 id="3优先级队列">3、优先级队列</h2>
<p>设置一个队列的最大优先级：</p>
<pre><code class="language-java">Map&lt;String, Object&gt; argss = new HashMap&lt;String, Object&gt;();
argss.put("x-max-priority",10); // 队列最大优先级

channel.queueDeclare("ORIGIN_QUEUE", false, false, false, argss);
</code></pre>
<p>发送消息时指定消息当前的优先级：</p>
<pre><code class="language-java">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
    .priority(5) // 消息优先级
    .build();
channel.basicPublish("", "ORIGIN_QUEUE", properties, msg.getBytes());
</code></pre>
<p>优先级高的消息可以优先被消费。但是：只有消息堆积（消息的发送速度大于消费者的消费速度）的情况下优先级才有意义。</p>
<p>参考：</p>
<p>com.gupaoedu.message</p>
<h2 id="4延迟队列">4、延迟队列</h2>
<p>RabbitMQ本身不支持延迟队列。可以使用TTL结合DLX的方式来实现消息的延迟投递，即把DLX跟某个队列绑定，  到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。</p>
<p>另一种方式是使用rabbitmq-delayed-message-exchange插件。</p>
<p>当然，将需要发送的信息保存在数据库，使用任务调度系统扫描然后发送也是可以实现的。</p>
<p>参考：</p>
<p>com.gupaoedu.dlx</p>
<h2 id="5rpc">5、RPC</h2>
<p>RabbitMQ实现RPC的原理：服务端处理消息后，把响应消息发送到一个响应队列，客户端再从响应队列获取到结果。</p>
<p>其中的问题：Client收到消息后，怎么知道应答消息是回复哪一条消息的？所以必须有一个唯一ID来关联，就是 correlationId。</p>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233420561-1963372419.png" alt="RabbitMQ_工作模型与Java编程_RabbitMq_RPC队列.png" loading="lazy"></p>
<p>参考：</p>
<p>com.gupaoedu.rpc</p>
<h2 id="6服务端流控flow-control">6、服务端流控（Flow Control）</h2>
<p>RabbitMQ 会在启动时检测机器的物理内存数值。默认当 MQ 占用 40% 以上内存时，MQ 会主动抛出一个内存警告并阻塞所有连接（Connections）。可以通过修改 <code>rabbitmq.conﬁg</code> 文件来调整内存阈值，默认值是  0.4，如下所示： [{rabbit, [{vm_memory_high_watermark, 0.4}]}].</p>
<p>默认情况，如果剩余磁盘空间在 1GB 以下，RabbitMQ 主动阻塞所有的生产者。这个阈值也是可调的。注意队列长度只在消息堆积的情况下有意义，而且会删除先入队的消息，不能实现服务端限流。</p>
<h2 id="7消费端限流">7、消费端限流</h2>
<p>在AutoACK为false的情况下，如果一定数目的消息（通过基于consumer或者channel设置Qos的值）未被确认前，不进行消费新的消息。</p>
<pre><code class="language-java">channel.basicQos(2); // 如果超过2条消息没有发送ACK，当前消费者不再接收队列消息
channel.basicConsume(QUEUE_NAME, false, consumer);
</code></pre>
<p>参考：com.gupaoedu.limit</p>
<h1 id="ui管理界面的使用">UI管理界面的使用</h1>
<p>管理插件提供了更简单的管理方式。</p>
<h3 id="启-用-管-理-插-件">启 用 管 理 插 件</h3>
<h4 id="windows启用管理插件">Windows启用管理插件</h4>
<pre><code class="language-powershell">cd C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.6\sbin
rabbitmq-plugins.bat enable rabbitmq_management
</code></pre>
<h4 id="linux启用管理插件">Linux启用管理插件</h4>
<pre><code class="language-bash">cd /usr/lib/rabbitmq/bin
./rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h3 id="管理界面访问端口">管理界面访问端口</h3>
<p>默认端口是15672，默认用户guest，密码guest。guest用户默认只能在本机访问。</p>
<h3 id="linux-创建-rabbitmq-用户">Linux 创建 RabbitMQ 用户</h3>
<p>例如：创建用户admin，密码admin，授权访问所有的Vhost</p>
<pre><code class="language-bash">firewall-cmd --permanent --add-port=15672/tcp
firewall-cmd --reload
rabbitmqctl add_user admin admin
rabbitmqctl set_user_tags admin administrator
rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
</code></pre>
<h1 id="spring配置方式集成rabbitmq">Spring配置方式集成RabbitMQ</h1>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250219233420934-823143119.png" alt="RabbitMQ_工作模型与Java编程_Spring集成方式.png" loading="lazy"></p>
<p>参考gitlab工程步骤：</p>
<p>1、创建Maven工程，pom.xml引入依赖</p>
<p>2、src/main/resouces目录，创建rabbitMQ.xml</p>
<p>3、配置applicationContext.xml</p>
<p>4、src/main/resouces目录，log4j.properties</p>
<p>5、编写生产者</p>
<p>6、编写4个消费者</p>
<p>7、编写单元测试类</p>
<h1 id="spring-boot集成rabbitmq">Spring Boot集成RabbitMQ</h1>
<p>参考gitlab工程</p>
<p>来源于:  <a href="https://javaguide.net" target="_blank" rel="noopener nofollow">https://javaguide.net</a></p>
<p>微信公众号：不止极客</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.030852649743055554" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-19 23:34">2025-02-19 23:34</span>&nbsp;
<a href="https://www.cnblogs.com/nogeek-cn">nogeek_cn</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18725586" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18725586);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18725586', targetLink: 'https://www.cnblogs.com/nogeek-cn/p/18725586', title: '百万架构师第四十课：RabbitMq：RabbitMq-工作模型与JAVA编程｜JavaGuide' })">举报</a>
</div>
        