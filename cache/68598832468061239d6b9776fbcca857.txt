
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/19034861" title="发布于 2025-08-13 22:56">
    <span role="heading" aria-level="2">用块状数组求解区间众数问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上期回顾：<a href="https://www.cnblogs.com/ofnoname/p/18994725" target="_blank">https://www.cnblogs.com/ofnoname/p/18994725</a></p>
<p>在上一篇文章中，我们介绍了块状数组的基本原理。</p>
<p>而<strong>区间众数问题</strong>就是一个典型的适合用分块解决的问题。由于众数不满足区间可加性，直接使用传统数据结构（如线段树）较为困难。但块状数组通过预处理块内信息，结合零散点处理，能在亚线性时间内完成查询。</p>
<h2 id="问题描述">问题描述</h2>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(m\)</span> 次查询，每次查询区间 <span class="math inline">\([l, r]\)</span> 的众数（出现次数最多，相同取最小）。<br>
<strong>数据范围</strong>：<span class="math inline">\(n, m \leq 4 \times 10^4\)，\(a_i \leq 10^9\)</span>。</p>
<p>（强制在线，仅查询而没有修改）</p>
<h3 id="分块设置">分块设置</h3>
<p>块大小 <span class="math inline">\(B = \lceil \sqrt{n} \rceil\)</span>，块数 <span class="math inline">\(T = \lceil n / B \rceil\)</span>。</p>
<pre><code class="language-cpp">int B = ceil(sqrt(n)), T = (n + B - 1) / B; // B: 块大小 T: 块数量
vector&lt;int&gt; b(n), L(T), R(T);
for (int i = 0; i &lt; n; i++) b[i] = i / B;
for (int i = 0; i &lt; T; i++) {
    L[i] = i * B;
    R[i] = min(n - 1, (i + 1) * B - 1); // 闭区间
}
</code></pre>
<h3 id="预处理">预处理</h3>
<p>由于众数是无法由子区间众数合并的，因此无论如何我们总需要查询一个数的区间出现次数。</p>
<p>预处理的内容基于这样一个事实：一个区间的众数，要么是所有中间完整块（他们一起）的众数，要么是一个出现在不完整块中的数（想想看）。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202508/1545207-20250813184805220-842610384.png" alt="image" loading="lazy"></p>
<p>所以候选数的总数量是根号数量级，我们要快速解决单个数出现次数的查询</p>
<p><strong>(1) 前缀和数组</strong><br>
<code>cnt[k][x]</code> 表示前 <span class="math inline">\(k\)</span> 块中元素 <span class="math inline">\(x\)</span> 的出现次数：</p>
<pre><code class="language-cpp">vector&lt;unordered_map&lt;int, int&gt;&gt; cnt(T + 1);
for (int k = 0; k &lt; T; k++) {
    auto &amp;r = cnt[k];
    if (k) r = cnt[k - 1];
    for (int i = L[k]; i &lt;= R[k]; i++) {
        r[a[i]]++;
    }
}
</code></pre>
<p>这样一来，统计时我们可以前缀和相减，快速查询某个数的次数，再加上不完整块的次数即可。</p>
<p><strong>(2) 块区间众数 <code>mode</code></strong><br>
<code>mode[i][j]</code> 存储块 <span class="math inline">\(i\)</span> 到块 <span class="math inline">\(j\)</span> 的众数（离散化值）：</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; mode(T, vector&lt;int&gt;(T, 0));
for (int i = 0; i &lt; T; i++) {
    unordered_map&lt;int, int&gt; cnt;
    int cur_mode = 0; // 当前众数
    for (int j = i; j &lt; T; j++) {
        for (int pos = L[j]; pos &lt;= R[j]; pos++) {
            cnt[a[pos]]++;
            if (!cur_mode || cnt[a[pos]] &gt; cnt[cur_mode] || 
                (cnt[a[pos]] == cnt[cur_mode] &amp;&amp; a[pos] &lt; cur_mode)) {
                cur_mode = a[pos];
            }
        }
        mode[i][j] = cur_mode;
    }
}
</code></pre>
<h3 id="查询处理">查询处理</h3>
<p>查询区间 <span class="math inline">\([l, r]\)</span> 的众数：</p>
<ol>
<li>
<p><strong>相邻块</strong>：暴力统计。</p>
</li>
<li>
<p><strong>跨块查询</strong>：</p>
<ul>
<li>中间完整块 <span class="math inline">\([p+1, q-1]\)</span> 的众数（通过 <code>mode</code> 获取）和零散点（左右边界）的所有数构成候选集。</li>
<li>对候选集中的每个元素，计算其在完整块中的出现次数（通过 <code>cnt_block</code> 差分），加上零散部分出现次数（统计一次），比较得众数。</li>
</ul>
</li>
</ol>
<pre><code class="language-cpp">while (m--) {
    int l, r; cin &gt;&gt; l &gt;&gt; r;
    l = (l + lastans - 1) % n; r = (r + lastans - 1) % n;
    if (l &gt; r) swap(l, r);

    int p = b[l], q = b[r];
    if (q - p &lt;= 1) { // 相邻块，暴力统计
        unordered_map&lt;int, int&gt; cnt;
        int res = 0;
        for (int i = l; i &lt;= r; i++) {
            cnt[a[i]]++;
            if (cnt[a[i]] &gt; cnt[res] || (cnt[a[i]] == cnt[res] &amp;&amp; a[i] &lt; res)) {
                res = a[i];
            }
        }
        cout &lt;&lt; (lastans = res) &lt;&lt; "\n";
        continue;
    }

    // 跨块查询
    vector&lt;int&gt; cand;
    cand.push_back(mode[p + 1][q - 1]);
    unordered_map&lt;int, int&gt; tmp_cnt;
    // 处理零散点
    for (int i = l; i &lt;= R[p]; i++) {
        tmp_cnt[a[i]]++;
        cand.push_back(a[i]);
    }
    for (int i = L[q]; i &lt;= r; i++) {
        tmp_cnt[a[i]]++;
        cand.push_back(a[i]);
    }
    // 去重
    sort(cand.begin(), cand.end());
    cand.erase(unique(cand.begin(), cand.end()), cand.end());

    int best = 0, max_cnt = 0;
    for (int x : cand) {
        int total = tmp_cnt[x] + cnt[q-1][x] - cnt[p][x];
        if (total &gt; max_cnt || (total == max_cnt &amp;&amp; x &lt; best)) {
            max_cnt = total;
            best = x;
        }
    }
    cout &lt;&lt; (lastans = best) &lt;&lt; "\n";
}
</code></pre>
<h3 id="离散化">离散化</h3>
<p>参考题目：<a href="https://www.luogu.com.cn/problem/P4168" target="_blank" rel="noopener nofollow">https://www.luogu.com.cn/problem/P4168</a>。但是这道题是由于元素值范围大，要先将序列离散化至 <span class="math inline">\([1, t]\)（\(t \leq n\)</span>），将哈希表改为数组才能通过：</p>
<pre><code class="language-cpp">vector&lt;int&gt; val = a;
sort(val.begin(), val.end());
val.erase(unique(val.begin(), val.end()), val.end());
for (int i = 0; i &lt; n; i++) {
    a[i] = lower_bound(val.begin(), val.end(), a[i]) - val.begin() + 1;
}
</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>预处理</strong>：频率处理 <span class="math inline">\(O(n)\)</span>，分块众数 <span class="math inline">\(O(T^2 B) = O(n \sqrt{n})\)</span>。</li>
<li><strong>查询</strong>：<span class="math inline">\(O(\sqrt{n})\)</span></li>
</ul>
<p>本文题核心在于分块与预处理平衡。分块可以让预处理的规模降维。将序列划分为若干块，将问题分解为“块内”和“块间”两部分处理，将全局复杂问题转化为了局部简单问题。</p>
<p>而我们还在分块问题里引入了预处理，预处理的东西由思考问题性质得到，由于预处理的数组规模和块数相关，其大小也不会很大。这样需要一些思维量，但降低查询时开销。</p>
<p>这一思想可推广至其他无区间可加性或需动态维护统计量的问题，例如：</p>
<ol>
<li><strong>区间数值出现次数问题</strong>：如查询区间内某值的出现次数、大于某阈值的元素个数。</li>
<li><strong>区间最小绝对差</strong>：维护块内有序结构，结合二分查找。</li>
<li><strong>其他非线性统计量</strong>：需要自己构造巧思，维护合适的东西来降低复杂度。</li>
</ol>
<p><strong>拓展思考：支持单点修改的区间众数问题</strong></p>
<p>假如在原有问题基础上增加单点修改操作：给定位置 <code>pos</code> 和值 <code>x</code>，将 <code>a[pos]</code> 修改为 <code>x</code>。应该怎么办呢？此时，预处理失效。这个思考题困难要得多。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007638888888888889" data-date-updated="2025-08-13 23:07">2025-08-13 22:56</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19034861);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19034861', targetLink: 'https://www.cnblogs.com/ofnoname/p/19034861', title: '用块状数组求解区间众数问题' })">举报</a>
</div>
        