
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kitty-38/p/18680607" title="发布于 2025-01-20 00:58">
    <span role="heading" aria-level="2">JavaScript —— 类、事件</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3588703/202501/3588703-20250121142342178-1863665101.png" alt="JavaScript —— 类、事件" class="desc_img">
        JS的类、事件(●'◡'●)
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<h1 id="类">类</h1>
</blockquote>
<ul>
<li>
<h3 id="与c中的class类似但是不存在私有成员全都是公开的">与C++中的<code>Class</code>类似。但是不存在私有成员（全都是公开的）。</h3>
</li>
<li>
<h3 id="this指向类的实例"><code>this</code>指向类的实例。</h3>
</li>
<li>
<h3 id="类名一般使用驼峰命名法">类名一般使用驼峰命名法。</h3>
</li>
</ul>
<br>
<blockquote>
<h2 id="定义">定义：</h2>
</blockquote>
<pre><code>class 类名 {  // 定义一个类
    constructor() {  // 构造函数（如果不写构造函数，会默认有一个无参构造函数）

    }
}
</code></pre>
<p>例如：<br>
test.js中的内容为：</p>
<pre><code>class Point {  // 定义一个类叫Point
    constructor(x, y) {  // 构造函数（如果不写构造函数，会默认有一个无参构造函数）
        this.x = x;  // 定义成员变量
        this.y = y;
    }

    init() {  // 定义成员函数
        this.sum = this.x + this.y;  // 成员变量可以在任意的成员函数中定义
    }

    toString() {  // 定义成员函数
        //return '(' + this.x + ',' + this.y + ')';
        return `(${this.x}, ${this.y})`;
    }
}

let main = function() {
    let p = new Point(3, 4);  // 实例

    console.log(p.x, p.y);  // 返回3，4
    console.log(p.toString());  //返回(3, 4)
}

export {
    main
}
</code></pre>
<p>test.html中的内容为：</p>
<pre><code>&lt;body&gt;
    &lt;script type="module"&gt;
        import {main} from "/test/test.js";

        main();
    &lt;/script&gt;
    
&lt;/body&gt;
</code></pre>
<br>
<h3 id="ps每一个class都可以对应前端的每一个组件可以用class去维护每一个组件的各种行为等">ps：每一个class都可以对应前端的每一个组件，可以用class去维护每一个组件的各种行为等。</h3>
<br>
<blockquote>
<h2 id="继承">继承：</h2>
</blockquote>
<p>test.js中的内容为：</p>
<pre><code>class Point {  // 定义一个类叫Point
    constructor(x, y) {  // 构造函数（如果不写构造函数，会默认有一个无参构造函数）
        this.x = x;  // 定义成员变量
        this.y = y;
    }

    toString() {  // 定义成员函数
        //return '(' + this.x + ',' + this.y + ')';
        return `(${this.x}, ${this.y})`;
    }
}


class ColorPoint extends Point {  // extends:继承
    constructor(x, y, color) {
        super(x, y);  // 这里的super是指基类（父类）的构造函数，先进行初始化
        this.color = color;
    }

    toString() {
        return `${this.color} ${super.toString()}`;
    }
}

let main = function() {
    let p = new ColorPoint(3, 4, 'pink');  // 实例

    console.log(p.toString());  // 返回pink (3, 4)
}

export {
    main
}
</code></pre>
<p>test.html中的内容为：</p>
<pre><code>&lt;body&gt;
    &lt;script type="module"&gt;
        import {main} from "/test/test.js";

        main();
    &lt;/script&gt;
    
&lt;/body&gt;
</code></pre>
<br>
<h2 id="ps">ps：</h2>
<ul>
<li>
<h3 id="super这个关键字既可以当作函数使用也可以当作对象使用"><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。</h3>
</li>
<li>
<h3 id="作为函数调用时代表父类的构造函数且只能用在子类的构造函数之中">作为函数调用时，代表父类的构造函数，且只能用在子类的构造函数之中。</h3>
</li>
<li>
<h3 id="super作为对象时指向父类的原型对象"><code>super</code>作为对象时，指向父类的原型对象。</h3>
</li>
<li>
<h3 id="在子类的构造函数中只有调用super之后才可以使用this关键字">在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字。</h3>
</li>
<li>
<h3 id="成员重名时子类的成员会覆盖父类的成员类似于c中的多态同一个函数可以表现出多种不同的状态">成员重名时，子类的成员会覆盖父类的成员。类似于C++中的多态（同一个函数可以表现出多种不同的状态）。</h3>
</li>
</ul>
<br>
<blockquote>
<h2 id="静态方法">静态方法：</h2>
</blockquote>
<ul>
<li>
<h3 id="在成员函数前添加static关键字即可">在成员函数前添加<code>static</code>关键字即可。</h3>
</li>
<li>
<h3 id="静态方法不会被类的实例继承所以只能通过类来调用通过类名--函数名来访问">静态方法不会被类的实例继承，所以只能通过类来调用，通过“类名 . 函数名”来访问。</h3>
</li>
<li>
<h3 id="静态函数是所有实例公共的函数相当于全局变量">静态函数是所有实例公共的函数（相当于全局变量）。</h3>
</li>
</ul>
<p>例如：<br>
test.js中的内容为：</p>
<pre><code>class Point {  // 定义一个类叫Point
    constructor(x, y) {  // 构造函数（如果不写构造函数，会默认有一个无参构造函数）
        this.x = x;  // 定义成员变量
        this.y = y;
    }

    toString() {  // 定义成员函数
        //return '(' + this.x + ',' + this.y + ')';
        return `(${this.x}, ${this.y})`;
    }

    static print_class_name() {
        console.log("Point");
    }
}

let main = function() {
    let p = new Point(3, 4);  // 初始化实例（非静态的成员变量和成员函数）

    Point.print_class_name();  // 通过类名访问静态函数，返回Point
    p.print_class_name();  // 会报错
}

export {
    main
}
</code></pre>
<p>test.html中的内容为：</p>
<pre><code>&lt;body&gt;
    &lt;script type="module"&gt;
        import {main} from "/test/test.js";

        main();
    &lt;/script&gt;
    
&lt;/body&gt;
</code></pre>
<br>
<blockquote>
<h2 id="静态变量">静态变量：</h2>
</blockquote>
<ul>
<li>
<h3 id="在es6中只能通过classpropname定义和访问静态成员必须通过类本身来访问">在ES6中，只能通过<code>class.propname</code>定义和访问，静态成员必须通过类本身来访问。</h3>
</li>
<li>
<h3 id="静态变量是所有实例公共的变量相当于全局变量">静态变量是所有实例公共的变量（相当于全局变量）。</h3>
</li>
</ul>
<p>例如：<br>
test.js中的内容为：</p>
<pre><code>class Point {  // 定义一个类叫Point
    constructor(x, y) {  // 构造函数（如果不写构造函数，会默认有一个无参构造函数）
        this.x = x;  // 定义成员变量
        this.y = y;

        Point.cnt++;
    }

    toString() {  // 定义成员函数
        //return '(' + this.x + ',' + this.y + ')';
        return `(${this.x}, ${this.y})`;
    }

    static print_class_name() {
        console.log("Point");
    }
}

Point.cnt = 0;  // 定义Point的静态成员变量cnt

let main = function() {
    // 初始化五个点
    for (let i = 0; i &lt; 5; i++) {  
        new Point(3, 4);
    }

    console.log(Point.cnt);  // 返回5
}

export {
    main
}
</code></pre>
<p>test.html中的内容为：</p>
<pre><code>&lt;body&gt;
    &lt;script type="module"&gt;
        import {main} from "/test/test.js";

        main();
    &lt;/script&gt;
    
&lt;/body&gt;
</code></pre>
<br>
<blockquote>
<h1 id="事件">事件</h1>
</blockquote>
<ul>
<li>
<h3 id="javascript的代码一般通过-事件-触发">JavaScript的代码一般通过 事件 触发。</h3>
</li>
<li>
<h3 id="可以通过addeventlistener函数常用api为元素绑定事件的触发函数">可以通过<code>addEventListener</code>函数（常用API）为元素绑定事件的触发函数。</h3>
</li>
</ul>
<p>例如：<br>
test.js中的内容为：</p>
<pre><code>let div = document.querySelector('div');  // 获取文档中id="div" 的元素。querySelector() 方法返回文档中匹配指定CSS选择器的一个元素。
let input = document.querySelector('input');

let main = function() {
    div.addEventListener('click', function(event) {  // 鼠标左键点击事件
        console.log(event.type);  // 返回事件的类型，每点击一次输出一次
    });

    input.addEventListener('input', function(event) {  // 键盘输入事件
        console.log(event.type);  // 返回事件的类型，连续触发
    });

    input.addEventListener('focus', function(event) {  // 聚焦事件
        console.log(event.type);  // 返回事件的类型
    });

    window.addEventListener('resize', function(e) {
        console.log(e.type);
    }) 

}

export {
    main
}
</code></pre>
<p>test.html中的内容为：</p>
<pre><code>&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;

    &lt;input type="text"&gt;

    &lt;script type="module"&gt;
        import {main} from "/test/test.js";

        main();
    &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>test.css中的内容为：</p>
<pre><code>div {
    width: 300px;
    height: 300px;
    background-color: pink;
}
</code></pre>
<br>
<blockquote>
<h2 id="常见的触发函数有">常见的触发函数有：</h2>
</blockquote>
<h2 id="鼠标">鼠标</h2>
<ul>
<li>
<h3 id="click鼠标左键点击">click：鼠标左键点击</h3>
</li>
<li>
<h3 id="dblclick鼠标左键双击">dblclick：鼠标左键双击</h3>
</li>
<li>
<h3 id="contextmenu鼠标右键点击">contextmenu：鼠标右键点击</h3>
</li>
<li>
<h3 id="mouseup鼠标弹起包括左键滚轮右键">mouseup：鼠标弹起，包括左键、滚轮、右键</h3>
</li>
<li>
<h3 id="mousedown鼠标按下包括左键滚轮右键">mousedown：鼠标按下，包括左键、滚轮、右键</h3>
</li>
<li>
<h3 id="eventbutton0表示左键1表示中键2表示右键">event.button：0表示左键，1表示中键，2表示右键</h3>
</li>
</ul>
<br>
<h2 id="键盘">键盘</h2>
<ul>
<li>
<h3 id="keyup某个按键是否被释放">keyup：某个按键是否被释放</h3>
</li>
<li>
<h3 id="keydown某个键是否被按住事件会连续触发">keydown：某个键是否被按住，事件会连续触发</h3>
</li>
<li>
<h3 id="keypress紧跟在keydown事件后触发只有按下字符键时触发适用于判定用户输入的字符">keypress：紧跟在keydown事件后触发，只有按下字符键时触发。适用于判定用户输入的字符。</h3>
</li>
<li>
<h3 id="keydownkeyupkeypress的关系类似于鼠标的mousedownmouseupclick">keydown、keyup、keypress的关系类似于鼠标的mousedown、mouseup、click</h3>
</li>
<li>
<h3 id="eventcode返回按的是哪个键">event.code：返回按的是哪个键</h3>
</li>
<li>
<h3 id="eventaltkeyeventctrlkeyeventshiftkey分别表示是否同时按下了altctrlshift键">event.altKey、event.ctrlKey、event.shiftKey分别表示是否同时按下了alt、ctrl、shift键。</h3>
</li>
<li>
<h3 id="event常用属性同上">event常用属性同上</h3>
</li>
</ul>
<br>
<h2 id="表单">表单</h2>
<ul>
<li>
<h3 id="focus聚焦某个元素">focus：聚焦某个元素</h3>
</li>
<li>
<h3 id="blur取消聚焦某个元素">blur：取消聚焦某个元素</h3>
</li>
<li>
<h3 id="change某个元素的内容发生了改变">change：某个元素的内容发生了改变</h3>
</li>
</ul>
<br>
<h2 id="窗口">窗口</h2>
<h3 id="需要作用到window元素上">需要作用到window元素上。</h3>
<ul>
<li>
<h3 id="resize当窗口大小发生变化">resize：当窗口大小发生变化</h3>
</li>
<li>
<h3 id="scroll滚动指定的元素">scroll：滚动指定的元素</h3>
</li>
<li>
<h3 id="load当元素被加载完成">load：当元素被加载完成</h3>
</li>
</ul>
<br>
<blockquote>
<h2 id="库函数和api的区别">库函数和API的区别：</h2>
</blockquote>
<h3 id="库函数顾名思义就是把函数放到库里是把一些常用的函数编完放到一个文件里供别人用库函数调用通常用于应用程序中对一般文件的访问主要由两方面提供一是操作系统提供的另一类是由第三方提供的">库函数顾名思义就是把函数放到库里，是把一些常用的函数编完放到一个文件里，供别人用。库函数调用通常用于应用程序中对一般文件的访问。主要由两方面提供：一是操作系统提供的；另一类是由第三方提供的。</h3>
<h3 id="apiapplication-programming-interface是应用程序编程接口windows不允许应用程序直接访问硬件但是会提供api函数让用户间接地访问这样就会调用系统级apiapi分为两种一是用户级api替用户写好函数方便调用二是系统级api如果应用程序想要和硬件交互必须调用此类函数程序员调用的是apiapi函数然后通过与系统调用共同完成函数的功能">API（Application Programming Interface）是应用程序编程接口。windows不允许应用程序直接访问硬件，但是会提供API函数让用户间接地访问，这样就会调用系统级API。API分为两种：一是用户级API，替用户写好函数，方便调用；二是系统级API，如果应用程序想要和硬件交互，必须调用此类函数。程序员调用的是API（api函数），然后通过与系统调用共同完成函数的功能。</h3>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.043649272101852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-21 21:13">2025-01-20 00:58</span>&nbsp;
<a href="https://www.cnblogs.com/kitty-38">kitty又困了</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18680607" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18680607);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18680607', targetLink: 'https://www.cnblogs.com/kitty-38/p/18680607', title: 'JavaScript —— 类、事件' })">举报</a>
</div>
        