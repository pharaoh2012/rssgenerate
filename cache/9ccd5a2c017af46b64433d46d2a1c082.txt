
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuhuacong/p/18767053" title="发布于 2025-03-12 12:47">
    <span role="heading" aria-level="2">使用PySide6/PyQt6实现Python跨平台通用列表页面的基类设计</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        我在随笔《使用PySide6/PyQt6实现Python跨平台GUI框架的开发》中介绍过PySide6/PyQt6 框架架构的整体设计，本篇随笔继续深入探讨框架的设计开发工作，主要针对通用列表页面的基类设计进行介绍，分析基类的各个模块的功能，以及介绍如何抽象一些公用的逻辑，实现对子类页面的简化处理。
对于不同的页面，我们可以公用同一个列表界面的基类，可以简化子类的很多操作，并能够统一整体的界面效果，提供更多通用的功能入口，是一种比较好的设计模式。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>我在随笔《<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-02-26 15:29" href="https://www.cnblogs.com/wuhuacong/p/18738199">使用PySide6/PyQt6实现Python跨平台GUI框架的开发</a>》中介绍过PySide6/PyQt6 框架架构的整体设计，本篇随笔继续深入探讨框架的设计开发工作，主要针对通用列表页面的基类设计进行介绍，分析基类的各个模块的功能，以及介绍如何抽象一些公用的逻辑，实现对子类页面的简化处理。</p>
<h3>1、通用列表界面的设计</h3>
<p>大多数情况下，界面的表现逻辑可以使用不同的规则进行抽象，如自定义控件、列表界面、弹出对话框界面等，我们把它抽象出来进行不同的处理。子类界面进行一定程度的扩张即可获得更好的使用、更简化的代码。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202502/8867-20250226144241472-1488282641.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>&nbsp;对于列表和对话框界面的封装，能够简化对泛型模型数据的统一处理，因此可以简化继承子类的代码，提供代码维护开发和维护的效率。&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202502/8867-20250226144827166-1872796228.png" alt="" width="971" height="410" class="medium-zoom-image" loading="lazy"></p>
<p>其中用户管理界面的列表界面如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202502/8867-20250226150837369-1973720112.png" alt="" width="962" height="643" class="medium-zoom-image" loading="lazy"></p>
<p>树列表或者表格控件，右键可以弹出相关的右键菜单</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202502/8867-20250226151428450-2123208062.png" alt="" width="413" height="362" class="medium-zoom-image" loading="lazy"></p>
<p>列表包含有有树形列表、条件查询框、通用条件（查询、新增、编辑、删除、导出）等、列表展示、分页导航、右键菜单等内容。这些都是在基类中进行了统一的抽象处理，子类根据需要调整属性或重写相关函数即可实现个性化的界面定义。</p>
<h3>2、通用列表界面的分析处理</h3>
<p>如果我们需要设计通用列表界面窗体的基类，那么我们需要尽可能的减少子类的代码，把常用的功能封装在基类里面，以及特殊的内容，可以通过封装逻辑，下发具体实现给子类进行重写实现即可。</p>
<p>前面我们介绍过，常用列表包含有有树形列表、条件查询框、通用条件（查询、新增、编辑、删除、导出）等、列表展示、分页导航、右键菜单等内容，另外还有详细的需要接受一些子类的列表字段显示和中文参考，以及表格处理的功能按钮的权限控制等方面。</p>
<p>由于我们需要子类传入的相关DTO类型，因此我们定义泛型类型来传入处理。</p>
<p>基类定义如下所示。</p>
<div class="cnblogs_code">
<pre>ModelType = TypeVar(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">ModelType</span><span style="color: rgba(128, 0, 0, 1)">"</span>)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 定义泛型基类</span>

<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建泛型基类 BaseListFrame ，并继承 QMainWindow</span>
<span style="color: rgba(0, 0, 255, 1)">class</span> BaseListFrame(QMainWindow, Generic[ModelType]):</pre>
</div>
<p>另外我们初始化函数，需要接受子类的一些信息，用于对显示内容进行精准的控制处理，因此构造函数__init__里面定义好相关的参数，如下所示。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建泛型基类 BaseListFrame ，并继承 QMainWindow</span>
<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> BaseListFrame(QMainWindow, Generic[ModelType]): 
   </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span><span style="color: rgba(0, 0, 0, 1)">(
        self,
        parent,
        model: Optional[ModelType] </span>=<span style="color: rgba(0, 0, 0, 1)"> None,
        display_columns: str </span>=<span style="color: rgba(0, 0, 0, 1)"> display_columns,
        column_mapping: dict </span>=<span style="color: rgba(0, 0, 0, 1)"> column_mapping,
        items_per_page: int </span>=<span style="color: rgba(0, 0, 0, 1)"> items_per_page,
        EVT_FLAGS: EventFlags </span>=<span style="color: rgba(0, 0, 0, 1)"> EVT_FLAGS,
        show_menu_tips: bool </span>=<span style="color: rgba(0, 0, 0, 1)"> show_menu_tips,
        menu_tips: str </span>=<span style="color: rgba(0, 0, 0, 1)"> DEFAULT_MENU_TIPS,
        use_left_panel: bool </span>=<span style="color: rgba(0, 0, 0, 1)"> False,
        column_widths</span>={<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">id</span><span style="color: rgba(128, 0, 0, 1)">"</span>: 50<span style="color: rgba(0, 0, 0, 1)">},
        plugins</span>=<span style="color: rgba(0, 0, 0, 1)">None,
    ):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化窗体

        :param parent: 父窗口
        :param model: 实体类
        :param display_columns: 显示的字段名称，逗号分隔,如：id,name,customid,authorize,note
        :param column_mapping: 列名映射（字段名到显示名的映射）dict格式：{"name": "显示名称"}
        :param items_per_page: 每页显示的行数
        :param EVT_FLAGS: 设置可以显示的操作按钮
        :param show_menu_tips: 是否显示提示信息
        :param menu_tips: 设置菜单提示信息
        :param use_left_panel: 是否使用树控件
        :param column_widths: Grid列的宽度设置
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span></pre>
</div>
<h4>1）树列表的控制和实现</h4>
<p>我们在init函数里面，主要通过_create_content()函数进行创建界面元素。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _create_content(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建主要内容面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建左侧树控件</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.use_left_panel:
            self._merge_tree_panel()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> "创建右侧主要内容面板</span>
        content_panel =<span style="color: rgba(0, 0, 0, 1)"> self._create_content_panel()
        self.setCentralWidget(content_panel)</span></pre>
</div>
<p>它负责判断是否需要展示树列表，如果打开显示树的开关，就根据树形列表的集合进行构建左侧的树列表显示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _merge_tree_panel(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">合并左侧树控件</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        tree_panels </span>=<span style="color: rgba(0, 0, 0, 1)"> self.<span style="color: rgba(255, 0, 0, 1)"><strong>create_tree_panels</strong></span>()
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> tree_panels <span style="color: rgba(0, 0, 255, 1)">is</span> None <span style="color: rgba(0, 0, 255, 1)">or</span> len(tree_panels.keys()) ==<span style="color: rgba(0, 0, 0, 1)"> 0:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">

        self.dock_widget </span>= dock_widget =<span style="color: rgba(0, 0, 0, 1)"> QDockWidget(self)
        dock_widget.setWindowTitle(</span><span style="color: rgba(128, 0, 0, 1)">""</span>)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 左侧树控件</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建 QTabWidget,并存储self.tree_tab_widget</span>
        self.tree_tab_widget = tree_tab_widget =<span style="color: rgba(0, 0, 0, 1)"> QTabWidget()
        tree_tab_widget.setTabPosition(QTabWidget.TabPosition.South)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 添加树控件到 QTabWidget</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> name, panel <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"><strong><span style="color: rgba(255, 0, 0, 1)"> tree_panels.items()</span></strong>:
            tree_tab_widget.addTab(panel, name)
</span><span style="color: rgba(0, 0, 0, 1)">
        dock_widget.setWidget(tree_tab_widget)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 防止面板浮动</span>
<span style="color: rgba(0, 0, 0, 1)">        dock_widget.setFloating(False)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 禁止关闭按钮</span>
<span style="color: rgba(0, 0, 0, 1)">        dock_widget.setFeatures(QDockWidget.DockWidgetFeature.NoDockWidgetFeatures)</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 将 QDockWidget 添加到主窗口的左侧</span>
        self.addDockWidget(<span style="color: rgba(255, 0, 0, 1)"><strong>Qt.DockWidgetArea.LeftDockWidgetArea</strong></span>, dock_widget)</pre>
</div>
<p>上面代码就是在左侧构建一个&nbsp;QDockWidget 的停靠区域，我们把所有树列表的集合放到其中容器的&nbsp;QTabWidget 里面即可。</p>
<p>在抽象的父类里面，我们只需要给出一个默认的 <strong>create_tree_panels</strong> 实现函数即可，如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> create_tree_panels(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> dict[str, QWidget]:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写该方法，创建左侧树列表面板-可以多个树列表</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">

        tree_panels: dict[str, QWidget] </span>=<span style="color: rgba(0, 0, 0, 1)"> {}
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建树控件</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> tree_panels["Tab 1"] = QLabel(self)</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> tree_panels["Tab 2"] = QLabel(self)</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> tree_panels</pre>
</div>
<p>而&nbsp;<strong>create_tree_panels 具体的实现&nbsp;</strong>我们是留给子类进行重写的，因为我们不清楚具体的显示，但是我们可以把它们逻辑上组合起来即可。</p>
<p>如对于上面展示的用户列表界面，这部分<strong>create_tree_panels</strong>&nbsp; 的代码实现如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> <strong><span style="color: rgba(255, 0, 0, 1)">create_tree_panels</span></strong>(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> dict[str, QWidget]:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写该方法，创建左侧树列表面板-可以多个树列表</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        dict </span>=<span style="color: rgba(0, 0, 0, 1)"> {}

        self.tree_dept </span>=<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(255, 0, 0, 1)"><strong> ctrl.MyTreePanel</strong></span>(
            self,
            on_tree_selected_handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnDeptTreeSelected,
            expand_all</span>=<span style="color: rgba(0, 0, 0, 1)">True,
            on_menu_handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnDeptTreeMenu,
        )
        self.tree_role </span>=<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(255, 0, 0, 1)"><strong> ctrl.MyTreePanel</strong></span>(
            self,
            on_tree_selected_handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnRoleTreeSelected,
            expand_all</span>=<span style="color: rgba(0, 0, 0, 1)">True,
            on_menu_handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnRoleTreeMenu,
        )
        dict[</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">按组织机构查看</span><span style="color: rgba(128, 0, 0, 1)">"</span>] =<span style="color: rgba(0, 0, 0, 1)"> self.tree_dept
        dict[</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">按角色查看</span><span style="color: rgba(128, 0, 0, 1)">"</span>] =<span style="color: rgba(0, 0, 0, 1)"> self.tree_role

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> dict</pre>
</div>
<p>其中ctrl.MyTreePanel的控件是我们自定义的一个树列表控件，用于减少重复性的代码，抽象一个树列表的展示，有利于我们保持更好的控制，统一界面效果的处理。</p>
<p>在子类的构造函数处理上，我们只需要设置参数&nbsp;use_left_panel = True，并且实现&nbsp;create_tree_panels 函数即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250312115642526-2118752474.png" alt="" width="816" height="637" loading="lazy"></p>
<h4>2）查询条件控件内容</h4>
<p>&nbsp;</p>
<p>介绍完毕树列表的处理，我们再次来到基类的界面构建处理函数上。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _create_content(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建主要内容面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建左侧树控件</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.use_left_panel:
            self._merge_tree_panel()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> "创建右侧主要内容面板</span>
        content_panel =<span style="color: rgba(0, 0, 0, 1)"> self.<span style="color: rgba(255, 0, 0, 1)"><strong>_create_content_panel</strong></span>()
        self.setCentralWidget(content_panel)</span></pre>
</div>
<p>其中的<strong><span style="font-size: 14px">_create_content_panel</span>&nbsp;</strong>是我们构建主查询面板内容的，其中包括输入条件展示、常见按钮显示、以及列表、分页栏目等。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_content_panel(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> QWidget:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建右侧主要内容面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> QWidget(self)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个垂直布局</span>
        main_layout =<span style="color: rgba(0, 0, 0, 1)"> QVBoxLayout()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个折叠的查询条件框</span>
        search_bar =<span style="color: rgba(0, 0, 0, 1)"> self.<span style="color: rgba(255, 0, 0, 1)"><strong>_create_search_bar</strong></span>(panel)
        main_layout.addWidget(search_bar)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建显示数据的表格</span>
        table_widget =<span style="color: rgba(0, 0, 0, 1)"> self.<span style="color: rgba(255, 0, 0, 1)"><strong>_create_grid</strong></span>(panel)
        main_layout.addWidget(table_widget, </span>1)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 拉伸占用全部高度</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个分页控件</span>
        self.pager_bar =<span style="color: rgba(0, 0, 0, 1)"> ctrl.<span style="color: rgba(255, 0, 0, 1)"><strong>MyPager</strong></span>(panel, self.items_per_page, self.update_grid)
        main_layout.addWidget(self.pager_bar)</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置布局</span>
<span style="color: rgba(0, 0, 0, 1)">        panel.setLayout(main_layout)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> panel</pre>
</div>
<p>上面标注特殊的代码，就是对不同模块的逻辑进行分离实现，从而让我们关注点集中一些。其中的create_search_bar里面，主要封装了查询条件框、常规按钮、自定义按钮等内容。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_search_bar(self, parent: QWidget = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> QWidget:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建折叠的查询条件框，包含查询条件输入框和常规按钮</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> QWidget(parent)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个垂直布局</span>
        layout =<span style="color: rgba(0, 0, 0, 1)"> QVBoxLayout()
        panel.setLayout(layout)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 添加查询条件控件</span>
        input_sizer =<span style="color: rgba(0, 0, 0, 1)"> self.CreateConditionsWithSizer(panel)
        layout.addLayout(input_sizer, 0)
        layout.addSpacing(</span>5)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 增加间距</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 添加常规按钮</span>
        btns_sizer =<span style="color: rgba(0, 0, 0, 1)"> self._CreateCommonButtons(panel)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 自定义按钮</span>
<span style="color: rgba(0, 0, 0, 1)">        self.CreateCustomButtons(panel, btns_sizer)
        layout.addLayout(btns_sizer, 0)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> panel</pre>
</div>
<p>我在基类窗体的抽象类里面，定义了默认的布局规则，如下代码所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> CreateConditionsWithSizer(self, parent: QWidget = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> QGridLayout:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类可重写该方法，创建折叠面板中的查询条件,包括布局 QGridLayout</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        layout </span>=<span style="color: rgba(0, 0, 0, 1)"> QGridLayout()
        layout.setAlignment(Qt.AlignmentFlag.AlignLeft </span>|<span style="color: rgba(0, 0, 0, 1)"> Qt.AlignmentFlag.AlignVCenter)
        layout.setSpacing(</span>5)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 增加间距</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 统一处理查询条件控件的添加，使用默认的布局方式</span>
        cols = 4 * 2<span style="color: rgba(0, 0, 0, 1)">
        list </span>=<span style="color: rgba(0, 0, 0, 1)"> self.CreateConditions(parent)

        </span><span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(len(list)):
            control: QWidget </span>=<span style="color: rgba(0, 0, 0, 1)"> list[i]
            control.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            layout.addWidget(control, i </span>// cols, i %<span style="color: rgba(0, 0, 0, 1)"> cols)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> layout

    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(255, 0, 0, 1)"><strong>CreateConditions</strong></span>(self, parent: QWidget = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> list[QWidget]:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类可重写该方法，创建折叠面板中的查询条件输入框控件，不包括布局，使用默认的布局方式 QGridLayout</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        list </span>=<span style="color: rgba(0, 0, 0, 1)"> [QWidget]
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 示例代码：</span>
        lblName = QLabel(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">名称:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        self.txtName </span>= ctrl.MyTextCtrl(parent, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">请输入名称</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        list.append(lblName)
        list.append(self.txtName)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> list</pre>
</div>
<p>如果我们不改变布局，那么我们主要实现&nbsp;<strong>CreateConditions&nbsp;</strong>函数即可。这个函数也是比较简单的，构建所需的输入几个条件即可。</p>
<p>如对于简单的客户信息界面，它的条件输入框里面就几个条件。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250312120700517-2042333731.png" alt="" width="1040" height="779" loading="lazy"></p>
<p>我们根据上面的界面效果，可以看到客户窗体子类实现&nbsp;CreateConditions 函数的代码如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> CreateConditions(self, parent: QWidget = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> list[QWidget]:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建折叠面板中的查询条件输入框控件</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建控件，不用管布局，交给CreateConditionsWithSizer控制逻辑</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 默认的QGridLayout 为4*2=8列，每列间隔5px</span><span style="color: rgba(0, 0, 0, 1)">
        self.txtName </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyTextCtrl(parent)
        self.txtAge </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyNumericRange(parent)
        self.txtCustomerType </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyComboBox(parent)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> ControlUtil 可以方便的创建文本标签和控件的组合，并返回所有的控件列表</span>
        util =<span style="color: rgba(0, 0, 0, 1)"> ControlUtil(parent)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">姓名:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtName)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">年龄:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtAge)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">客户类型:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtCustomerType)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> util.get_controls()</pre>
</div>
<p>这样，具体实现部分，对于WxPython和PySide6/PyQt6来说，代码都是差不多的，因为我们用了自定义用户控件类，并使用辅助函数，让它们和标签更好的粘合起来。</p>
<p>&nbsp;对于自定义控件，我们对其封装，使之能够在开发使用习惯上更一致，下面是我们根据需要对常见的原生控件进行一些自定义控件的封装列表。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202502/8867-20250226145049058-1815324359.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>对于常规的按钮，我们根据权限集合进行判断是否显示即可，自定义按钮则留给子类进一步实现。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 添加常规按钮</span>
        btns_sizer =<span style="color: rgba(0, 0, 0, 1)"> self.<strong><span style="color: rgba(255, 0, 0, 1)">_CreateCommonButtons</span></strong>(panel)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 自定义按钮</span>
        self.<span style="color: rgba(255, 0, 0, 1)"><strong>CreateCustomButtons</strong></span>(panel, btns_sizer)</pre>
</div>
<p>&nbsp;</p>
<p>对于常规的按钮，代码如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250312121535034-242300177.png" alt="" width="909" height="1242" loading="lazy"></p>
<p>&nbsp;而自定义按钮的处理，我们留给子类实现，父类给出一个默认的函数即可。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> CreateCustomButtons(self, parent: QWidget, btns_sizer: QHBoxLayout) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类可重写该方法，创建折叠面板中的自定义按钮</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 增加按钮</span>
        <span style="color: rgba(0, 0, 255, 1)">pass</span></pre>
</div>
<h4>3）表格数据显示</h4>
<p>我们回到前面介绍的代码。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_content_panel(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> QWidget:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建右侧主要内容面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> QWidget(self)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个垂直布局</span>
        main_layout =<span style="color: rgba(0, 0, 0, 1)"> QVBoxLayout()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个折叠的查询条件框</span>
        search_bar =<span style="color: rgba(0, 0, 0, 1)"> self._create_search_bar(panel)
        main_layout.addWidget(search_bar)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建显示数据的表格</span>
        table_widget =<span style="color: rgba(0, 0, 0, 1)"> self.<span style="color: rgba(255, 0, 0, 1)"><strong>_create_grid</strong></span>(panel)
        main_layout.addWidget(table_widget, </span>1)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 拉伸占用全部高度</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个分页控件</span>
        self.pager_bar =<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyPager(panel, self.items_per_page, self.update_grid)
        main_layout.addWidget(self.pager_bar)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置布局</span>
<span style="color: rgba(0, 0, 0, 1)">        panel.setLayout(main_layout)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> panel</pre>
</div>
<p>其中&nbsp;<strong>_create_grid&nbsp;</strong>就是我们创建表格内容的逻辑函数了，它负责创建一个QTableView 元素进行展示，表格数据的绑定，通过只定义模型MyTableModel 来绑定界面显示的。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_grid(self, parent: QWidget) -&gt;<span style="color: rgba(0, 0, 0, 1)"><strong> QTableView</strong>:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建显示数据的表格</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">

        self.total_count: int </span>=<span style="color: rgba(0, 0, 0, 1)"> 0

        self.table_model </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.<span style="color: rgba(255, 0, 0, 1)"><strong>MyTableModel</strong></span>(
            self.data,
            self.display_columns,
            self.column_mapping,
            primary_key</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">id</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
            column_widths</span>=<span style="color: rgba(0, 0, 0, 1)">self.column_widths,
            replace_values_handler</span>=self.replace_values,  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 替换内容函数</span>
            forground_color_handler=self.paint_foreground,  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 前景色渲染函数</span>
<span style="color: rgba(0, 0, 0, 1)">        )</span>
        self.table_view =<span style="color: rgba(0, 0, 0, 1)"> QTableView(parent)
        self.table_view.setModel(self.table_model)

        self._set_grid_options()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 绑定行选中事件</span>
<span style="color: rgba(0, 0, 0, 1)">        self.table_view.selectionModel().selectionChanged.connect(self.on_row_selected)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 异步绑定双击行事件</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> self.has_edit <span style="color: rgba(0, 0, 255, 1)">or</span><span style="color: rgba(0, 0, 0, 1)"> self.has_view:
            self.table_view.doubleClicked.connect(self.on_row_double_clicked)</span></pre>
</div>
<p>表格头部排序、右键菜单、表格特殊的选中和内容转义、背景色处理、导出Excel、导出PDF、打印预览等，我能都可以通过对表格的一些属性或者方法进行跟踪处理即可实现。这里由于篇幅原因，不在深入探讨。</p>
<h4>4）分页信息展示</h4>
<p>对于分页内容，表格显示是不负责的，因此我们需要根据模型对象，构建一个分页控件来显示，把它剥离基类列表的主界面，有利于减少我们的关注点分散，也有利于重用控件。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250312122504002-824191927.png" alt="" width="811" height="55" loading="lazy"></p>
<p>&nbsp;前面的逻辑代码中。</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_content_panel(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> QWidget:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建右侧主要内容面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> QWidget(self)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个垂直布局</span>
        main_layout =<span style="color: rgba(0, 0, 0, 1)"> QVBoxLayout()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个折叠的查询条件框</span>
        search_bar =<span style="color: rgba(0, 0, 0, 1)"> self._create_search_bar(panel)
        main_layout.addWidget(search_bar)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建显示数据的表格</span>
        table_widget =<span style="color: rgba(0, 0, 0, 1)"> self._create_grid(panel)
        main_layout.addWidget(table_widget, </span>1)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 拉伸占用全部高度</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个分页控件</span>
        self.pager_bar =<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(255, 0, 0, 1)"><strong> ctrl.MyPager</strong></span>(panel, self.items_per_page, self.update_grid)
        main_layout.addWidget(self.pager_bar)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置布局</span>
<span style="color: rgba(0, 0, 0, 1)">        panel.setLayout(main_layout)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> panel</pre>
</div>
<p>分页控件是独立的一个用户控件。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MyPager(QWidget):
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">列表的分页控件</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

    <span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span>(self, parent=None, items_per_page=10, on_update=None, total_count=<span style="color: rgba(0, 0, 0, 1)">0):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化

        :param parent: 父控件
        :param items_per_page: 每页的行数
        :param on_update: 查询数据的回调函数,为异步函数
        :param total_count: 总记录数
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">

        self.items_per_page </span>=<span style="color: rgba(0, 0, 0, 1)"> items_per_page
        self.total_count </span>=<span style="color: rgba(0, 0, 0, 1)"> total_count
        self.total_pages </span>= (total_count + items_per_page - 1) //<span style="color: rgba(0, 0, 0, 1)"> items_per_page
        self.current_page </span>=<span style="color: rgba(0, 0, 0, 1)"> 0
        self.on_update </span>=<span style="color: rgba(0, 0, 0, 1)"> on_update

        super().</span><span style="color: rgba(128, 0, 128, 1)">__init__</span>(parent)</pre>
</div>
<p>通过有效的隔离，使得我们每次只需要关注特定部分的处理，而具体的逻辑由基类统一控制，特殊的具体实现交给子类重写基类函数即可。</p>
<p>完成了上面的处理后，我们发现业务模块的子类需要实现的内容比较少了，大多数交给抽象父类实现了。</p>
<h4>5）数据的初始化处理</h4>
<p>完成了界面元素的创建后，我们还需要再基类中统一一些数据初始化的函数，如我们在构造函数里面创建好内容后，调用了init_ui的函数初始化界面元素。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建泛型基类 BaseListFrame ，并继承 QMainWindow</span>
<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> BaseListFrame(QMainWindow, Generic[ModelType]):
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">列表窗口的基类定义</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span><span style="color: rgba(0, 0, 0, 1)">(
        self,
        parent,
        model: Optional[ModelType] </span>=<span style="color: rgba(0, 0, 0, 1)"> None,
        display_columns: str </span>=<span style="color: rgba(0, 0, 0, 1)"> display_columns,
        column_mapping: dict </span>=<span style="color: rgba(0, 0, 0, 1)"> column_mapping,
        items_per_page: int </span>=<span style="color: rgba(0, 0, 0, 1)"> items_per_page,
        EVT_FLAGS: EventFlags </span>=<span style="color: rgba(0, 0, 0, 1)"> EVT_FLAGS,
        show_menu_tips: bool </span>=<span style="color: rgba(0, 0, 0, 1)"> show_menu_tips,
        menu_tips: str </span>=<span style="color: rgba(0, 0, 0, 1)"> DEFAULT_MENU_TIPS,
        use_left_panel: bool </span>=<span style="color: rgba(0, 0, 0, 1)"> False,
        column_widths</span>={<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">id</span><span style="color: rgba(128, 0, 0, 1)">"</span>: 50<span style="color: rgba(0, 0, 0, 1)">},
        plugins</span>=<span style="color: rgba(0, 0, 0, 1)">None,
    ):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化窗体

        :param parent: 父窗口
        :param model: 实体类
        :param display_columns: 显示的字段名称，逗号分隔,如：id,name,customid,authorize,note
        :param column_mapping: 列名映射（字段名到显示名的映射）dict格式：{"name": "显示名称"}
        :param items_per_page: 每页显示的行数
        :param EVT_FLAGS: 设置可以显示的操作按钮
        :param show_menu_tips: 是否显示提示信息
        :param menu_tips: 设置菜单提示信息
        :param use_left_panel: 是否使用树控件
        :param column_widths: Grid列的宽度设置
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        super().<span style="color: rgba(128, 0, 128, 1)">__init__</span><span style="color: rgba(0, 0, 0, 1)">(parent)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 日志对象</span>
        self.log =<span style="color: rgba(0, 0, 0, 1)"> settings.log.get_logger()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 初始化属性</span>
        self.model =<span style="color: rgba(0, 0, 0, 1)"> model
        self.display_columns </span>= display_columns  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 显示的字段名称，逗号分隔,如：id,name</span>
        self.column_mapping = column_mapping  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 列名映射</span>
        self.items_per_page = items_per_page  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 每页显示的行数</span>
        self.EVT_FLAGS = EVT_FLAGS  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置可以显示的操作按钮</span>
        self.show_menu_tips = show_menu_tips  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 是否显示提示信息</span>
        self.menu_tips = menu_tips  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置菜单提示信息</span>
        self.use_left_panel = use_left_panel  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 是否使用树控件</span>
        self.column_widths = column_widths  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> Grid列的宽度设置</span>
        self.plugins = plugins <span style="color: rgba(0, 0, 255, 1)">or</span> {}  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 单元格的渲染列表,格式：{"列名称": 插件实例}</span>
        self.columns_permit = {}  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 字段权限</span><span style="color: rgba(0, 0, 0, 1)">
        self.total_count </span>= 0  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 记录总数</span>
<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建主要内容面板</span>
<span style="color: rgba(0, 0, 0, 1)">        self.<span style="color: rgba(255, 0, 0, 1)"><strong>_create_content</strong></span>()</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 调度异步任务, 使用@asyncSlot()装饰器后，你可以像同步函数一样调用异步方法</span>
<span style="color: rgba(0, 0, 0, 1)">        self.<span style="color: rgba(255, 0, 0, 1); font-size: 16px"><strong>init_ui</strong></span>()

    @asyncSlot()
    async </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(255, 0, 0, 1); font-size: 16px"><strong> init_ui</strong></span>(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化界面</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 使用 @asyncSlot 装饰器后，你可以像同步函数一样调用异步方法，Qt 会自动管理异步任务的调度和执行，</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 不需要显式使用 await 或者 asyncio.create_task 来启动异步任务。</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 如果你在子类中重写了 init_ui，你仍然需要在子类中显式地添加 @asyncSlot() 装饰器。</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 在子类中，Python 会将其视为新的方法定义，因此你必须在子类中的方法上再次应用 @asyncSlot() 装饰器来确保它仍然被处理为异步槽。</span>
<span style="color: rgba(0, 0, 0, 1)">
        await self.<strong>init_dict_items</strong>()
        await self.<strong>init_treedata</strong>()
        await self.<strong>update_grid</strong>()

    async </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> init_dict_items(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化字典数据-子类可重写</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> await self.txtCustomerType.bind_dictType("客户类型")</span>
        <span style="color: rgba(0, 0, 255, 1)">pass</span><span style="color: rgba(0, 0, 0, 1)">

    async </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> init_treedata(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">初始化树控件数据-子类可重写</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 0, 255, 1)">pass</span><span style="color: rgba(0, 0, 0, 1)">

    async </span><span style="color: rgba(0, 0, 255, 1)">def</span> update_grid(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">更新表格的内容</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 查询数据</span>
<span style="color: rgba(0, 0, 0, 1)">        await self.<span style="color: rgba(255, 0, 0, 1)"><strong>OnQuery</strong></span>()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取当前用户有权限查看的列</span>
        self.columns_permit =<span style="color: rgba(0, 0, 0, 1)"> await self.get_columns_permit()
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 更新表格数据</span>
<span style="color: rgba(0, 0, 0, 1)">        self.table_model.UpdateData(self.data, self.columns_permit)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 更新页码信息</span>
        self._update_pager()</pre>
</div>
<p>而各个子类负责各自模块内容的初始化即可。</p>
<h3>3、子类列表界面代码分析</h3>
<p>由于父类已经抽象了很多相关的元素创建、数据初始化的逻辑函数，因此子类根据需要重写函数实现即可。</p>
<p>如对于简单的业务表，客户信息表，它的子类只需要实现下面几个函数即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250312123947967-322200798.png" alt="" width="1028" height="1261" loading="lazy"></p>
<div>CreateConditions函数负责查询条件的构建，前面介绍过。</div>
<div>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> CreateConditions(self, parent: QWidget = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> list[QWidget]:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建折叠面板中的查询条件输入框控件</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建控件，不用管布局，交给CreateConditionsWithSizer控制逻辑</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 默认的QGridLayout 为4*2=8列，每列间隔5px</span>
<span style="color: rgba(0, 0, 0, 1)">
        self.txtName </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyTextCtrl(parent)
        self.txtAge </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyNumericRange(parent)
        self.txtCustomerType </span>=<span style="color: rgba(0, 0, 0, 1)"> ctrl.MyComboBox(parent)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> ControlUtil 可以方便的创建文本标签和控件的组合，并返回所有的控件列表</span>
        util =<span style="color: rgba(0, 0, 0, 1)"> ControlUtil(parent)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">姓名:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtName)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">年龄:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtAge)
        util.add_control(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">客户类型:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, self.txtCustomerType)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> util.get_controls()</pre>
</div>
<p>OnQuery函数负责提取输入条件，并提交服务端获取数据返回。</p>
<div class="cnblogs_code">
<pre>    async <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> OnQuery(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类实现-发送查询请求, 需设置self.data，self.total_count</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取默认查询参数,包括skipCount,maxResultCount,sorting</span>
        params =<span style="color: rgba(0, 0, 0, 1)"> self.GetDefaultParams()
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 新的数据，可以从控件获取，也可以是动态生成的</span>
        search_params =<span style="color: rgba(0, 0, 0, 1)"> { </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">name</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: self.txtName.GetValue()}
        ****#其他条件</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 将 search_params 合并到 params 中</span>
<span style="color: rgba(0, 0, 0, 1)">        params.update(search_params)</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 发送查询请求</span>
        data =<span style="color: rgba(0, 0, 0, 1)"> await api.GetList(params)</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> data.success:
            result </span>=<span style="color: rgba(0, 0, 0, 1)"> data.result
            self.data </span>=<span style="color: rgba(0, 0, 0, 1)"> result.items
            self.total_count </span>= result.totalCount</pre>
</div>
<p>而OnAdd用于打开新增对话框。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> OnAdd(self) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写-打开新增对话框</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        dlg </span>= FrmCustomerEdit(self, columns_permit=<span style="color: rgba(0, 0, 0, 1)">self.columns_permit)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> dlg.<span style="color: rgba(0, 0, 255, 1)">exec</span>() ==<span style="color: rgba(0, 0, 0, 1)"> QDialog.DialogCode.Accepted:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 新增成功，刷新表格</span>
<span style="color: rgba(0, 0, 0, 1)">            asyncio.run(self.update_grid())
        dlg.deleteLater()</span></pre>
</div>
<p>而&nbsp;OnEditById 用于编辑对话框的打开</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> OnEditById(self, entity_id: Any |<span style="color: rgba(0, 0, 0, 1)"> str):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写-根据主键值打开编辑对话框</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 使用列表窗体获得的字段权限</span>
        dlg = FrmCustomerEdit(self, entity_id, columns_permit=<span style="color: rgba(0, 0, 0, 1)">self.columns_permit)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取对话框结果</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> dlg.<span style="color: rgba(0, 0, 255, 1)">exec</span>() ==<span style="color: rgba(0, 0, 0, 1)"> QDialog.DialogCode.Accepted:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 编辑成功，刷新表格</span>
<span style="color: rgba(0, 0, 0, 1)">            asyncio.run(self.update_grid())
        dlg.deleteLater()</span></pre>
</div>
<p>而删除对话框的处理，如下函数所示。</p>
<div class="cnblogs_code">
<pre>    async <span style="color: rgba(0, 0, 255, 1)">def</span> OnDeleteByIdList(self, id_list: List[Any |<span style="color: rgba(0, 0, 0, 1)"> str]):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写-根据主键值删除记录</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 发送删除请求</span>
        result =<span style="color: rgba(0, 0, 0, 1)"> await api.DeleteByIds(id_list)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> print(result)</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> result.success:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 删除成功，刷新表格</span>
<span style="color: rgba(0, 0, 0, 1)">            await self.update_grid()
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            error </span>= result.errorInfo.message <span style="color: rgba(0, 0, 255, 1)">if</span> result.errorInfo <span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">未知错误</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
            MessageUtil.show_error(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">删除失败：%s</span><span style="color: rgba(128, 0, 0, 1)">"</span> % error)</pre>
</div>
<p>以上就是我们对于基类列表界面的抽象，和具体子类的一些个性化函数重写的处理，以便实现更好的逻辑抽象并保证具体个性化页面内容的处理。</p>
<p>对于不同的页面，我们可以公用同一个列表界面的基类，可以简化子类的很多操作，并能够统一整体的界面效果，提供更多通用的功能入口，是一种比较好的设计模式。</p>
</div>
</div>
<div id="MySignature" role="contentinfo">
    <div style="border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;">
    <img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" align="top" alt="">
    <span style="color: #000000"><span class="Apple-tab-span" style="white-space: pre"></span>
     专注于代码生成工具、.Net/.NetCore 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架等框架产品。
     <br>&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href="http://www.iqidi.com/" target="_blank">http://www.iqidi.com</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.4804175882986111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-12 12:47">2025-03-12 12:47</span>&nbsp;
<a href="https://www.cnblogs.com/wuhuacong">伍华聪</a>&nbsp;
阅读(<span id="post_view_count">173</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18767053" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18767053);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18767053', targetLink: 'https://www.cnblogs.com/wuhuacong/p/18767053', title: '使用PySide6/PyQt6实现Python跨平台通用列表页面的基类设计' })">举报</a>

        </p>
    