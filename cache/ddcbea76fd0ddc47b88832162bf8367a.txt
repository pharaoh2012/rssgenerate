
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18827616" title="发布于 2025-04-15 21:44">
    <span role="heading" aria-level="2">Sentinel源码—2.Context和处理链的初始化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="4" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="5"><strong>1.Sentinel底层的核心概念</strong></p>
<p data-track="6"><strong>2.Sentinel中Context的设计思想与源码实现</strong></p>
<p data-track="7"><strong>3.Java SPI机制的引入</strong></p>
<p data-track="8"><strong>4.Java SPI机制在Sentinel处理链中的应用</strong></p>
<p data-track="9"><strong>5.Sentinel默认处理链ProcessorSlot的构建</strong></p>
<p data-track="10">&nbsp;</p>
<p data-track="11"><strong>1.Sentinel底层的核心概念</strong></p>
<p data-track="12"><strong>(1)资源和规则</strong></p>
<p data-track="13"><strong>(2)Context</strong></p>
<p data-track="14"><strong>(3)ProcessorSlot</strong></p>
<p data-track="15"><strong>(4)Node</strong></p>
<p data-track="16">&nbsp;</p>
<p data-track="17"><strong>(1)资源和规则</strong></p>
<p data-track="18"><strong>一.什么是资源、规则和Entry</strong></p>
<p data-track="19"><strong>二.使用责任链模式 + 过滤器来收集资源的调用数据</strong></p>
<p data-track="20"><strong>三.如何设计Entry资源访问类</strong></p>
<p data-track="21"><strong>四.如何设计Entry资源访问类的子类</strong></p>
<p data-track="22">&nbsp;</p>
<p data-track="23"><strong>一.什么是资源、规则和Entry</strong></p>
<p data-track="24"><strong>资源：</strong>可以是一个方法、一个接口或一段代码。资源是被Sentinel保护和管理的对象。</p>
<p data-track="25">&nbsp;</p>
<p data-track="26"><strong>规则：</strong>用来定义资源应遵循的约束条件。Sentinel支持多种规则类型，如流控规则、熔断降级规则等。</p>
<p data-track="27">&nbsp;</p>
<p data-track="28"><strong>Entry：</strong>可以理解为是对资源的一次访问。</p>
<p data-track="29">&nbsp;</p>
<p data-track="30">在Sentinel中，资源和规则是紧密相互关联的。Sentinel会根据配置的规则，对资源的调用进行控制，从而保证系统稳定。</p>
<p data-track="31">&nbsp;</p>
<p data-track="32"><strong>二.使用责任链模式 + 过滤器来收集资源的调用数据</strong></p>
<p data-track="33">Sentinel要实现流控、熔断降级等功能，首先需要收集资源的调用数据。比如：QPS、请求失败次数、请求成功次数、线程数、响应时间等。</p>
<p data-track="34">&nbsp;</p>
<p data-track="35">为了收集资源的这些调用数据，可以使用过滤器。将需要限制的资源配置在配置文件中，然后创建一个过滤器来拦截请求。当发现当前请求的接口已在配置文件中配置时，便需要进行数据收集。比如每次收到请求都将totalQps字段值 + 1，请求成功则再将successQps字段值 + 1。但使用一个过滤器是不够的，因为不仅有限制QPS的规则，也可能有限制异常比例的规则等。因此还需要使用责任链模式，让每一种规则都对应一个过滤器节点。这样拦截请求进行过滤时，便会形成一个过滤器处理链：开始 -&gt; 流控过滤器 -&gt; 黑白名单过滤器 -&gt; 熔断降级过滤器 -&gt; 业务 -&gt; 结束。</p>
<p data-track="36">&nbsp;</p>
<p data-track="37"><strong>三.如何设计Entry资源访问类</strong></p>
<p data-track="38">Entry可以理解为是对资源的一次访问。在使用责任链模式之前，需要先设计Entry资源访问类。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">已知资源可以是一个方法、一个接口甚至一段代码，那么资源就肯定要有资源名称，比如方法名、接口名、其他自定义名称。因此，可以设计如下Entry资源访问类：</p>
<pre class="highlighter-hljs"><code>//资源访问类
public class Entry {
    //资源名称
    private final String name;
}</code></pre>
<p data-track="42">一个资源作为API提供给第三方调用时，此时它属于入口流量。一个资源也会主动请求第三方API，此时它属于出口流量。第三方调用自己时，需要限制QPS。自己调用第三方时，第三方也有QPS限制。所以需要一个EntryType类：</p>
<pre class="highlighter-hljs"><code>public enum EntryType {
    //入口流量，资源被调用
    IN,
    //出口流量，资源调用其他接口
    OUT;
}</code></pre>
<p data-track="44">然后，还需要一个ResourceTypeConstants类来记录资源的类型，表明资源是HTTP接口、RPC接口、还是Gateway网关服务等。</p>
<pre class="highlighter-hljs"><code>//资源类
public final class ResourceTypeConstants {
    //默认类型
    public static final int COMMON = 0;
    //Web类型，也就是最常见的HTTP类型
    public static final int COMMON_WEB = 1;
    //RPC类型，如Dubbo RPC，Grpc，Thrift等
    public static final int COMMON_RPC = 2;
    //API网关
    public static final int COMMON_API_GATEWAY = 3;
    //数据库SQL操作
    public static final int COMMON_DB_SQL = 4;
}</code></pre>
<p data-track="46">因此，一个资源起码有三个字段：名称(name)、资源类型(resourceType)以及请求类型(entryType)。将这三个字段包装成一个ResourceWrapper类，如下所示：</p>
<pre class="highlighter-hljs"><code>//资源类(资源包装类)
public class ResourceWrapper {
    //资源名称
    protected final String name;
    //资源类型：入口流量还是出口流量
    protected final EntryType entryType;
    //请求类型：HTTP类型、RPC类型、API网关
    protected final int resourceType;
    
    public ResourceWrapper(String name, EntryType entryType, int resourceType) {
        this.name = name;
        this.entryType = entryType;
        this.resourceType = resourceType;
    }
}</code></pre>
<p data-track="48">接着，将这个ResourceWrapper资源类放入到Entry资源访问类中：</p>
<pre class="highlighter-hljs"><code>public class Entry {
    //封装了：名称(name)、请求类型(entryType)以及资源类型(resourceType)三个字段
    protected final ResourceWrapper resourceWrapper;
    
    public Entry(ResourceWrapper resourceWrapper) {
        this.resourceWrapper = resourceWrapper;
    }
}</code></pre>
<p data-track="50">类图如下：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f3f8b0e982614244940a0ec9a17cc162~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=ipW5m4FAx57ot3gquPdQmM6EwPg%3D" data-ic="false" data-width="1080" data-height="721" data-ic-uri=""></div>
<p data-track="51">同时，还需记录资源访问的开始时间和完成时间：</p>
<pre class="highlighter-hljs"><code>public class Entry {
    //资源访问的开始时间
    private final long createTimestamp;
    //资源访问的完成时间
    private long completeTimestamp;
    //封装了：名称(name)、请求类型(entryType)以及资源类型(resourceType)三个字段
    protected final ResourceWrapper resourceWrapper;
    
    public Entry(ResourceWrapper resourceWrapper) {
        this.resourceWrapper = resourceWrapper;
        //给开始时间赋值为当前系统时间
        this.createTimestamp = TimeUtil.currentTimeMillis();
    }
}</code></pre>
<p data-track="53">然后，还需记录这个资源总的请求数、请求成功、请求失败等指标。可以将获取这些指标的方法放到一个interface里，然后通过interface提供的方法获取这些指标，可称这个interface为Node。</p>
<pre class="highlighter-hljs"><code>//用于统计资源的各项指标数据
public interface Node {
    //总的请求数
    long totalRequest();
    //请求成功数
    long totalSuccess();
    ...
}</code></pre>
<p data-track="55">于是，Entry资源访问类变成如下：</p>
<pre class="highlighter-hljs"><code>public class Entry {
    //资源访问的开始时间
    private final long createTimestamp;
    //资源访问的完成时间
    private long completeTimestamp;
    //统计资源的各项数据指标
    private Node curNode;
    //封装了：名称(name)、请求类型(entryType)以及资源类型(resourceType)三个字段
    protected final ResourceWrapper resourceWrapper;
    
    public Entry(ResourceWrapper resourceWrapper) {
        this.resourceWrapper = resourceWrapper;
        //给开始时间赋值为当前系统时间
        this.createTimestamp = TimeUtil.currentTimeMillis();
    }
}</code></pre>
<p data-track="57">此外，当触发预设规则的阈值时，系统将抛出警告提示。因此还要自定义一个异常类BlockException。所以，Entry资源访问类最终如下：</p>
<pre class="highlighter-hljs"><code>//Each SphU.entry() will return an Entry.
//This class holds information of current invocation:
//createTime, the create time of this entry, using for rt statistics.
//current Node, that is statistics of the resource in current context.
//origin Node, that is statistics for the specific origin. 
//Usually the origin could be the Service Consumer's app name, see ContextUtil.enter(String name, String origin).
//ResourceWrapper, that is resource name.

//A invocation tree will be created if we invoke SphU.entry() multi times in the same Context,
//so parent or child entry may be held by this to form the tree. 
//Since Context always holds the current entry in the invocation tree, 
//every Entry.exit() call should modify Context.setCurEntry(Entry) as parent entry of this.
public abstract class Entry {
    //资源访问的开始时间
    private final long createTimestamp;
    //资源访问的完成时间
    private long completeTimestamp;
    //统计资源的各项数据指标
    private Node curNode;
    //异常
    private BlockException blockError;
    //封装了：名称(name)、请求类型(entryType)以及资源类型(resourceType)三个字段
    protected final ResourceWrapper resourceWrapper;
    
    public Entry(ResourceWrapper resourceWrapper) {
        this.resourceWrapper = resourceWrapper;
        //给开始时间赋值为当前系统时间
        this.createTimestamp = TimeUtil.currentTimeMillis();
    }
}</code></pre>
<p data-track="59"><strong>Entry资源访问类的设计总结：</strong></p>
<p data-track="60">每次资源被访问时都会创建一个Entry资源访问对象。Entry资源访问对象会包含：资源名称、资源类型、请求类型、操作资源的开始和结束时间、统计各项指标的接口以及自定义流控异常。</p>
<p data-track="61">&nbsp;</p>
<p data-track="62">根据这些字段可以完成以下需求：统计一个资源的出口流量、成功次数、失败次数等指标。根据规则配置判断是否超出阈值，若是则抛出自定义异常BlockException。这样的Entry资源访问类，能灵活方便管理和监控资源，满足不同的需求。</p>
<p data-track="63">&nbsp;</p>
<p data-track="64">为了方便子类继承，可以将Entry资源访问类设计为抽象类。</p>
<p data-track="65">&nbsp;</p>
<p data-track="66"><strong>四.如何设计Entry资源访问类的子类</strong></p>
<p data-track="67">假设需要提供一个外部接口(sms/send)用于发送短信服务，具体的短信发送操作是通过第三方云服务提供商提供的API或SDK完成的，第三方云服务提供商需要使用方对其提供的API或SKD进行QPS限流。</p>
<p data-track="68">&nbsp;</p>
<p data-track="69">当用户请求接口sms/send到达系统时，会生成一个名为sms/send的Entry。由于当接口sms/send请求第三方API时，也需要进行限流操作，因此还会生成一个名为yun/sms/api的Entry。</p>
<p data-track="70">&nbsp;</p>
<p data-track="71">可以发现这两个Entry都属于同一次请求，即这两个Entry是有关联的。</p>
<pre class="highlighter-hljs"><code>Entry(name=sms/send)的子节点是Entry(name=yun/sms/api)
Entry(name=yun/sms/api)的父节点是Entry(name=sms/send)</code></pre>
<p data-track="73">这显然是父子关系，可以使用双向链表表示，因此需要两个指针。</p>
<p data-track="74">&nbsp;</p>
<p data-track="75">此外，由于这两个Entry属于同一个请求，即它们位于同一个作用范围内。因此，需要一个字段来表示作用范围。</p>
<p data-track="76">&nbsp;</p>
<p data-track="77">最后，由于需要通过设置一系列的过滤器来采集Entry的各规则下的指标。所以，还需增加一个存放处理链(处理器插槽链条)类型的字段。</p>
<p data-track="78">&nbsp;</p>
<p data-track="79">综上，可以设计Entry的子类CtEntry如下：</p>
<pre class="highlighter-hljs"><code>//Entry的子类
class CtEntry extends Entry {
    //指向上一个节点，父节点，类型为Entry
    protected Entry parent = null;
    //指向下一个节点，子节点，类型为Entry
    protected Entry child = null;
    //作用域，上下文
    protected Context context;
    //处理链(处理器插槽链条)
    protected ProcessorSlot&lt;Object&gt; chain;
}</code></pre>
<p data-track="81"><strong>(2)Context</strong></p>
<p data-track="82">Context对象的用途是存储请求调用链中关联的Entry信息。在Sentinel中，每个请求都有一个与之关联的Context实例。当系统接收到一个请求时，就会创建出一个Context。请求的处理过程中可能会涉及多个资源，Context便会在多个资源中传递。</p>
<p data-track="83">&nbsp;</p>
<p data-track="84">Context类的设计如下：</p>
<pre class="highlighter-hljs"><code>public class Context {
    //名称
    private final String name;
    //处理到哪个Entry了
    private Entry curEntry;
    //来源，比如请求 IP
    private String origin = "";
}</code></pre>
<p data-track="86">可以发现Context比较简单，它就像一个容器一样。Context会关联此次请求的所有资源，即包含一个Entry双向链表。一个Context的生命周期内可能有多个资源操作，并非是一个接口对应一个Context，可以是多个接口对应一个Context。比如A调用B，B调用C，那么A、B、C三个资源就属于同一个Context。Context生命周期内的最后一个资源退出时就会清理并结束该Context。</p>
<p data-track="87">&nbsp;</p>
<p data-track="88"><strong>Context类的设计总结：</strong></p>
<p data-track="89">在处理一个请求对应的一个资源时或者多个资源时，这些资源的操作必须要建立在一个Context环境下，而且每一个资源的操作必须要通过Entry对象来完成。也就是一个请求对应一个Context，一个请求可能操作多个资源。而多个资源又对应多个Entry，但这些Entry却都属于同一个Context。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a7b8cb17e1f74a20afc4700094a413fe~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=VO%2BHrcFMpn1n5GVGDs3%2Bto4DoN8%3D" data-ic="false" data-width="920" data-height="534" data-ic-uri=""></div>
<p data-track="90"><strong>(3)ProcessorSlot</strong></p>
<p data-track="91">ProcessorSlot就是一个用于负责数据采集的处理链(处理器插槽链条)的节点。每当一个资源被调用时都会创建一个Entry资源访问对象。Entry资源访问对象中就有一条节点为ProcessorSlot的处理链，对应于Entry对象的chain属性。这意味着在创建Entry对象时，也会生成一系列ProcessorSlot处理槽，这些ProcessorSlot处理槽各自承担不同的职责。</p>
<p data-track="92">&nbsp;</p>
<p data-track="93"><strong>一.NodeSelectorSlot</strong></p>
<p data-track="94">NodeSelectorSlot负责构建资源的调用路径，然后将这些资源的调用路径以树状结构存储起来，方便后续根据资源的调用路径进行数据统计和限流降级。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96"><strong>二.ClusterBuilderSlot</strong></p>
<p data-track="97">ClusterBuilderSlot负责实现集群限流功能，ClusterBuilderSlot会将请求的流量信息汇报到集群的统计节点，然后根据集群限流规则决定是否应该限制请求。</p>
<p data-track="98">&nbsp;</p>
<p data-track="99"><strong>三.StatisticSlot</strong></p>
<p data-track="100">StatisticSlot负责记录资源的访问统计信息，比如通过的请求数、阻塞的请求数、响应时间等。StatisticSlot会将每次资源访问的信息记录在资源的统计节点中，这些统计信息是Sentinel执行流量控制(如限流、熔断降级等)的重要指标。</p>
<p data-track="101">&nbsp;</p>
<p data-track="102"><strong>四.SystemSlot</strong></p>
<p data-track="103">SystemSlot用于实现系统保护功能，它会提供基于系统负载、系统平均响应时间和系统入口QPS的保护策略。</p>
<p data-track="104">&nbsp;</p>
<p data-track="105"><strong>五.AuthoritySlot</strong></p>
<p data-track="106">AuthoritySlot用于实现授权规则功能，比如基于黑白名单的访问权限。</p>
<p data-track="107">&nbsp;</p>
<p data-track="108"><strong>六.FlowSlot</strong></p>
<p data-track="109">FlowSlot用于实现流量控制功能，比如对不同来源的流量进行限制、基于调用关系对流量进行控制。</p>
<p data-track="110">&nbsp;</p>
<p data-track="111"><strong>七.DegradeSlot</strong></p>
<p data-track="112">DegradeSlot用于实现熔断降级功能，可以支持基于异常比例、异常数和响应时间的降级策略，处理链(处理器插槽链条)之间的关系图如下：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5caab90bf45a4daabbd180dfc5a37414~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=A4hQMKShwWlitFYPjtO3YrsWlLU%3D" data-ic="false" data-width="1080" data-height="489" data-ic-uri=""></div>
<p data-track="113">ProcessorSlot的用途总结：负责构建调用路径树、进行数据采集、实施流量控制和熔断降级等规则。</p>
<p data-track="114">&nbsp;</p>
<p data-track="115"><strong>(4)Node</strong></p>
<p data-track="116">Node的用途很简单，就是基于处理槽采集的数据进行统计。比如统计总的请求量、请求成功量、请求失败量等指标。因此可以定义如下接口：</p>
<pre class="highlighter-hljs"><code>public interface Node {
    //获取总请求量
    long totalRequest();
    //获取请求成功量
    long successRequest();
    //获取请求失败量
    long failedRequest();
    ...
}</code></pre>
<p data-track="118">即然Node是一个接口，那么需要提供一个具体的实现类。由于Node接口主要关注统计相关功能，因此可将实现类命名为StatisticNode，如下所示：</p>
<pre class="highlighter-hljs"><code>public class StatisticNode implements Node {
    ...
}</code></pre>
<p data-track="120">通过StatisticNode类可完成Node接口定义的各种性能指标的收集和计算。但为了更多维度的计算，比如：上下文Context维度、资源维度等，还需要额外设计如下三个子类：</p>
<p data-track="121">&nbsp;</p>
<p data-track="122"><strong>一.DefaultNode(单机里的资源维度)</strong></p>
<p data-track="123">默认节点，用于统计名字相同的Context下的某个资源的调用数据，意味着DefaultNode是以Context和ResourceWrapper为维度进行统计。</p>
<p data-track="124">&nbsp;</p>
<p data-track="125"><strong>二.EntranceNode(接口维度)</strong></p>
<p data-track="126">继承自DefaultNode，是名字相同的Context的入口节点。用于统计名字相同的Context下的所有资源的调用数据，维度为Context。注意：默认创建的Context都是名字相同的，一个线程对应一个Context。所以EntranceNode可以理解为统计某接口被所有线程访问的调用数据。</p>
<p data-track="127">&nbsp;</p>
<p data-track="128"><strong>三.ClusterNode(集群中的资源维度)</strong></p>
<p data-track="129">ClusterNode保存的是同一个资源的相关的统计信息，ClusterNode是以资源为维度的，不区分Context。</p>
<pre class="highlighter-hljs"><code>//Holds real-time statistics for resources.
public interface Node extends OccupySupport, DebugSupport {
    ...
}

public class StatisticNode implements Node {
    ...
}

//A Node used to hold statistics for specific resource name in the specific context.
//Each distinct resource in each distinct Context will corresponding to a DefaultNode.
//This class may have a list of sub DefaultNodes.
//Child nodes will be created when calling SphU.entry() multiple times in the same Context.
public class DefaultNode extends StatisticNode {
    ...
}

//A Node represents the entrance of the invocation tree.
//One Context will related to a EntranceNode, which represents the entrance of the invocation tree. 
//New EntranceNode will be created if current context does't have one. 
//Note that same context name will share same EntranceNode globally.
public class EntranceNode extends DefaultNode {
    ...
}

//This class stores summary runtime statistics of the resource, including rt, thread count, qps and so on. 
//Same resource shares the same ClusterNode globally, no matter in which Context.
public class ClusterNode extends StatisticNode {
    ...
}

//The ClusterNode is uniquely identified by the ResourceId.
//The DefaultNode is identified by both the resource id and Context. 
//In other words, one resource id will generate multiple DefaultNode for each distinct context,
//but only one ClusterNode.</code></pre>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0321c03df1354310908079b6081990d3~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=nb74g75loaAL6rBvJrRNpv1Rggs%3D" data-ic="false" data-width="1080" data-height="550" data-ic-uri=""></div>
<p data-track="131"><strong>三者的区别：</strong>DefaultNode统计的是名字相同的Context下的某个资源的调用数据，EntranceNode统计的是名字相同的Context下的全部资源的调用数据，ClusterNode统计的是某个资源在所有Context下的调用数据。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/27cd4a3e5a96477896dde3abf8b16a3d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=FWdU8ZKwGtuGJaOArhkYWZvhK%2F0%3D" data-ic="false" data-width="1080" data-height="668" data-ic-uri=""></div>
<p data-track="132">注意：资源可以是一个方法、一个接口或一段代码。一个请求会对应一个Context，一个请求可能包含多个方法，所以一个请求可能操作多个资源，一个Context可能包含多个资源。</p>
<p data-track="133">&nbsp;</p>
<p data-track="134"><strong>Node的用途总结：</strong>统计各种维度的各种数据指标。</p>
<p data-track="135">&nbsp;</p>
<p data-track="136"><strong>(5)总结</strong></p>
<p data-track="137"><strong>一.资源访问对象Entry</strong></p>
<p data-track="138">每次访问资源都会创建一个Entry资源访问对象。每个Entry对象都会包含资源的基本信息(如名称、请求类型、资源类型等)、数据采集链和获取指标信息的方法(如QPS、成功请求数、失败请求数等)。由于一次请求可能涉及多个资源，因此Entry资源访问对象采用双向链表结构。</p>
<p data-track="139">&nbsp;</p>
<p data-track="140"><strong>二.管理资源对象的上下文Context</strong></p>
<p data-track="141">资源的操作要在一个Context环境下进行，一个Context可包含多个资源。</p>
<p data-track="142">&nbsp;</p>
<p data-track="143"><strong>三.请求、Entry、Context、ProcessorSlot、Node之间的关系</strong></p>
<p data-track="144">每次访问资源都要创建一个Entry对象，资源操作要建立在一个Context环境下。一个请求对应一个Context，一个Context可以包含多个资源，也就是一个Context会包含一条完整请求链路中涉及的所有资源。每个资源都通过ProcessorSlot进行数据采集和规则验证，而采集完的数据交由Node去做聚合统计分析。</p>
<p data-track="145">&nbsp;</p>
<p data-track="146"><strong>总之：</strong>每个请求都需要与Context绑定，一个Context可以关联多个资源。每个资源都通过处理链ProcessorSlot进行数据采集和规则验证。ProcessorSlot数据采集完成后，会通过Node进行统计和分析。</p>
<p data-track="147">&nbsp;</p>
<p data-track="148"><strong>2.Sentinel中Context的设计思想与源码实现</strong></p>
<p data-track="149"><strong>(1)初始化Entry和Context的设计思想</strong></p>
<p data-track="150"><strong>(2)初始化Entry的源码—将处理链、Context与Entry对象绑定</strong></p>
<p data-track="151"><strong>(3)初始化Context的源码—如何创建Context和EntranceNode</strong></p>
<p data-track="152"><strong>(4)总结</strong></p>
<p data-track="153">&nbsp;</p>
<p data-track="154"><strong>(1)初始化Entry和Context的设计思想</strong></p>
<p data-track="155"><strong>一.Context对象的name属性一般取默认值</strong></p>
<p data-track="156">Context对象是有一个name属性的，所以如果没有指定Context对象的name属性，则Context对象的name默认为sentinel_default_context。</p>
<pre class="highlighter-hljs"><code>Context context = InternalContextUtil.internalEnter("sentinel_default_context");</code></pre>
<p data-track="158"><strong>二.使用ThreadLocal绑定线程和Context对象</strong></p>
<p data-track="159">由于一个请求要与一个Context对象进行绑定，一个请求由一个线程处理。所以可以定义一个ThreadLocal变量，让一个线程与一个Context对象绑定。</p>
<pre class="highlighter-hljs"><code>//存放线程与Context的绑定关系
private static ThreadLocal&lt;Context&gt; contextHolder = new ThreadLocal&lt;&gt;();</code></pre>
<p data-track="161"><strong>三.如何初始化Entry对象</strong></p>
<p data-track="162">由于一个请求涉及多个资源，即一个Context对象会包含多个Entry对象，所以每个Entry对象必然属于某个Context对象。因此初始化Entry对象时需要将Context对象绑定到Entry对象中，这可以在Entry的构造方法中传入一个Context对象。当然Entry的构造方法也会传入一个ResourceWrapper对象，因为Entry的基本属性(名称、请求类型、资源类型)会封装在ResourceWrapper对象中。当然，Entry对象还需要的关键属性有：ProcessorSlot和Node。</p>
<pre class="highlighter-hljs"><code>//初始化Entry的基本属性
ResourceWrapper resource = new ResourceWrapper("/hello/world", EntryType.OUT, ResourceTypeConstants.COMMON);
//初始化Context
Context context = InternalContextUtil.internalEnter("sentinel_default_context");
//放到Entry当中
CtEntry entry = new CtEntry(resourceWrapper, context);</code></pre>
<p data-track="164"><strong>(2)初始化Entry的源码—将处理链、Context与Entry对象绑定</strong></p>
<p data-track="165">Sentinel创建资源访问对象的入口是：SphU.entry("/hello/world")，在执行SphU.entry()方法时会初始化一个Context对象，其中便会调用CtSph.entry()方法创建一个Entry资源访问对象。</p>
<p data-track="166">&nbsp;</p>
<p data-track="167">在CtSph的entry()方法中，首先会创建一个StringResourceWrapper对象，然后调用CtSph的entryWithPriority()方法执行如下的处理逻辑：初始化Context -&gt; 将Context与线程绑定 -&gt; 初始化Entry -&gt; 将Context和ResourceWrapper放入Entry中。</p>
<p data-track="168">&nbsp;</p>
<p data-track="169">在CtSph的entryWithPriority()方法中，由于创建一个Entry资源访问对象时，需要传入当前线程对应的Context，所以首先会调用ContextUtil的getContext()方法从当前线程中获取Context。如果获取到的Context为空，也就是当前线程没有绑定Context，那么就调用InternalContextUtil的internalEnter()方法创建一个Context对象，也就是调用ContextUtil的trueEnter()方法创建一个Context对象，并把这个Context对象放入ThreadLocal线程变量contextHolder中。然后调用CtSph的lookProcessChain()方法初始化处理链，接着创建一个Entry资源访问对象并将处理链、Context与该Entry资源访问对象绑定，最后调用ProcessorSlot的entry()方法执行处理链节点的数据采集 + 规则验证。</p>
<pre class="highlighter-hljs"><code>//The fundamental Sentinel API for recording statistics and performing rule checking for resources.
public class SphU {
    private static final Object[] OBJECTS0 = new Object[0];
    ...
    //Record statistics and perform rule checking for the given resource.
    //@param name the unique name of the protected resource
    public static Entry entry(String name) throws BlockException {
        //调用CtSph.entry()方法创建一个Entry资源访问对象，默认的请求类型为OUT
        return Env.sph.entry(name, EntryType.OUT, 1, OBJECTS0);
    }
    ...
}

//Sentinel Env. This class will trigger all initialization for Sentinel.
public class Env {
    //创建一个CtSph对象
    public static final Sph sph = new CtSph();
    static {
        //If init fails, the process will exit.
        InitExecutor.doInit();
    }
}

public class CtSph implements Sph {
    ...
    //Record statistics and perform rule checking for the given resource.
    //@param name the unique name for the protected resource
    //@param type the traffic type (inbound, outbound or internal).
    //This is used to mark whether it can be blocked when the system is unstable, only inbound traffic could be blocked by SystemRule
    //@param count the amount of calls within the invocation (e.g. batchCount=2 means request for 2 tokens)
    //@param args args for parameter flow control or customized slots
    @Override
    public Entry entry(String name, EntryType type, int count, Object... args) throws BlockException {
        //StringResourceWrapper是ResourceWrapper的子类，且StringResourceWrapper的构造方法默认了资源类型为COMMON
        StringResourceWrapper resource = new StringResourceWrapper(name, type);
        return entry(resource, count, args);
    }
    
    //Do all {@link Rule}s checking about the resource.
    public Entry entry(ResourceWrapper resourceWrapper, int count, Object... args) throws BlockException {
        //调用CtSph.entryWithPriority()方法，执行如下处理：
        //初始化Context -&gt; 将Context与线程绑定 -&gt; 初始化Entry -&gt; 将Context和ResourceWrapper放入Entry中
        return entryWithPriority(resourceWrapper, count, false, args);
    }
    
    private Entry entryWithPriority(ResourceWrapper resourceWrapper, int count, boolean prioritized, Object... args) throws BlockException {
        //从当前线程中获取Context
        Context context = ContextUtil.getContext();
        if (context instanceof NullContext) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //如果没获取到Context
        if (context == null) {
            //Using default context.
            //创建一个名为sentinel_default_context的Context，并且与当前线程绑定
            context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);
        }
        //Global switch is close, no rule checking will do.
        if (!Constants.ON) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //调用CtSph.lookProcessChain()方法初始化处理链(处理器插槽链条)
        ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);
        if (chain == null) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //创建出一个Entry资源访问对象，将处理链(处理器插槽链条)、Context与Entry资源访问对象绑定
        //其中会将Entry的三个基础属性(封装在resourceWrapper里)以及当前Entry所属的Context作为参数传入CtEntry的构造方法
        Entry e = new CtEntry(resourceWrapper, chain, context);
        try {
            //处理链(处理器插槽链条)入口，负责采集数据，规则验证
            //调用DefaultProcessorSlotChain.entry()方法执行处理链每个节点的逻辑(数据采集+规则验证)
            chain.entry(context, resourceWrapper, null, count, prioritized, args);
        } catch (BlockException e1) {
            //规则验证失败，比如：被流控、被熔断降级、触发黑白名单等
            e.exit(count, args);
            throw e1;
        } catch (Throwable e1) {
            RecordLog.info("Sentinel unexpected exception", e1);
        }
        return e;
    }
    ...
    private final static class InternalContextUtil extends ContextUtil {
        static Context internalEnter(String name) {
            //调用ContextUtil.trueEnter()方法创建一个Context对象
            return trueEnter(name, "");
        }
        static Context internalEnter(String name, String origin) {
            return trueEnter(name, origin);
        }
    }
}

public class StringResourceWrapper extends ResourceWrapper {
    public StringResourceWrapper(String name, EntryType e) {
        //调用父类构造方法，且默认资源类型为COMMON
        super(name, e, ResourceTypeConstants.COMMON);
    }
    ...
}</code></pre>
<p data-track="171">初始化Context的核心源码总结：</p>
<pre class="highlighter-hljs"><code>1.从当前ThreadLocal里获取Context

2.获取不到Context，则创建Context并将Context放到ThreadLocal里，与当前请求线程绑定

3.初始化处理链(处理器插槽链条)

4.将处理链(处理器插槽链条)、Context与Entry资源访问对象绑定

5.执行每一个链条的逻辑(数据采集 + 规则验证)

6.验证失败抛出BlockException</code></pre>
<p data-track="173"><strong>(3)初始化Context的源码—如何创建Context和EntranceNode</strong></p>
<p data-track="174">ContextUtil的trueEnter()方法会尝试从ThreadLocal获取一个Context对象。如果获取不到，那么再创建一个Context对象然后放入到ThreadLocal中。</p>
<p data-track="175">&nbsp;</p>
<p data-track="176">由于当前线程可能会涉及创建多个Entry，所以该方法需要注意并发问题。但是并非在创建Context时需要注意并发，因为一个线程本就需要一个Context。而是在创建Context对象所需的EntranceNode对象时才需注意并发，因为相同名字的Context对象会共用同一个EntranceNode对象。默认情况下，创建的Context对象都是有相同名字的，这样一个EntranceNode对象就可以对当前机器的所有请求进行统计。</p>
<p data-track="177">&nbsp;</p>
<p data-track="178">其中在创建EntranceNode对象时，会使用Double Check + 锁的机制，先从缓存EntranceNode对象的Map中尝试获取已存在的EntranceNode。如果获取不到EntranceNode，那么再去创建EntranceNode对象，然后使用写时复制 + 锁去更新缓存EntranceNode对象的Map。</p>
<pre class="highlighter-hljs"><code>//Utility class to get or create Context in current thread.
//Each SphU.entry() should be in a Context.
//If we don't invoke ContextUtil.enter() explicitly, DEFAULT context will be used.
public class ContextUtil {
    //Store the context in ThreadLocal for easy access.
    //存放线程与Context的绑定关系
    //每个请求对应一个线程，每个线程绑定一个Context，所以每个请求对应一个Context
    private static ThreadLocal&lt;Context&gt; contextHolder = new ThreadLocal&lt;&gt;();
    //Holds all EntranceNode. Each EntranceNode is associated with a distinct context name.
    //以Context的name作为key，EntranceNode作为value缓存到HashMap中
    private static volatile Map&lt;String, DefaultNode&gt; contextNameNodeMap = new HashMap&lt;&gt;();
    private static final ReentrantLock LOCK = new ReentrantLock();
    private static final Context NULL_CONTEXT = new NullContext();
    ...
    //ContextUtil.trueEnter()方法会尝试从ThreadLocal获取一个Context对象
    //如果获取不到，再创建一个Context对象然后放入ThreadLocal中
    //入参name其实一般就是默认的Constants.CONTEXT_DEFAULT_NAME=sentinel_default_context
    //由于当前线程可能会涉及创建多个Entry资源访问对象，所以trueEnter()方法需要注意并发问题
    protected static Context trueEnter(String name, String origin) {
        //从ThreadLocal中获取当前线程绑定的Context对象
        Context context = contextHolder.get();
        //如果当前线程还没绑定Context对象，则初始化Context对象并且与当前线程进行绑定
        if (context == null) {
            //首先要获取或创建Context对象所需要的EntranceNode对象，EntranceNode会负责统计名字相同的Context下的指标数据
            //将全局缓存contextNameNodeMap赋值给一个临时变量localCacheNameMap
            //因为后续会对contextNameNodeMap的内容进行修改，所以这里需要将原来的contextNameNodeMap复制一份出来
            //从而避免后续对contextNameNodeMap的内容进行修改时，可能造成对接下来读取contextNameNodeMap内容的影响
            Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;

            //从缓存副本localCacheNameMap中获取EntranceNode
            //这个name其实一般就是默认的sentinel_default_context
            DefaultNode node = localCacheNameMap.get(name);
            //如果获取的EntranceNode为空
            if (node == null) {
                //为了防止缓存无限制地增长，导致内存占用过高，需要设置一个上限，只要超过上限，就直接返回NULL_CONTEXT
                if (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) {
                    setNullContext();
                    return NULL_CONTEXT;
                } else {
                    //如果Context还没创建，缓存里也没有当前Context名称对应的EntranceNode，并且缓存数量尚未达到2000
                    //那么就创建一个EntranceNode，创建EntranceNode时需要加锁，否则会有线程不安全问题
                    //毕竟需要修改HashMap类型的contextNameNodeMap

                    //通过加锁 + 缓存 + 写时复制更新缓存，避免并发情况下创建出多个EntranceNode对象
                    //一个线程对应一个Context对象，多个线程对应多个Context对象
                    //这些Context对象会使用ThreadLocal进行隔离，但它们的name默认都是sentinel_default_context
                    //根据下面的代码逻辑：
                    //多个线程(对应多个Context的name默认都是sentinel_default_context)会共用同一个EntranceNode
                    //于是可知，多个Context对象会共用一个EntranceNode对象
                    LOCK.lock();
                    try {
                        //从缓存中获取EntranceNode
                        node = contextNameNodeMap.get(name);
                        //对node进行Double Check
                        //如果没获取到EntranceNode
                        if (node == null) {
                            if (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) {
                                setNullContext();
                                return NULL_CONTEXT;
                            } else {
                                //创建EntranceNode，缓存到contextNameNodeMap当中
                                node = new EntranceNode(new StringResourceWrapper(name, EntryType.IN), null);
                                //Add entrance node.
                                //将新创建的EntranceNode添加到ROOT中，ROOT就是每个Node的根结点
                                Constants.ROOT.addChild(node);

                                //写时复制，将新创建的EntranceNode添加到缓存中
                                Map&lt;String, DefaultNode&gt; newMap = new HashMap&lt;&gt;(contextNameNodeMap.size() + 1);
                                newMap.putAll(contextNameNodeMap);
                                newMap.put(name, node);
                                contextNameNodeMap = newMap;
                            }
                        }
                    } finally {
                        //解锁
                        LOCK.unlock();
                    }
                }
            }
            //此处可能会有多个线程同时执行到此处，并发创建多个Context对象
            //但这是允许的，因为一个请求对应一个Context，一个请求对应一个线程，所以一个线程本来就需要创建一个Context对象

            //初始化Context，将刚获取到或刚创建的EntranceNode放到Context的entranceNode属性中
            context = new Context(node, name);
            context.setOrigin(origin);
            //将创建出来的Context对象放入ThreadLocal变量contextHolder中，实现Context对象与当前线程的绑定
            contextHolder.set(context);
        }
        return context;
    }
    ...
}</code></pre>
<p data-track="180"><strong>(4)总结</strong></p>
<p data-track="181">初始化Entry和Context的整体流程：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1d51f88211644553832e19610fabbf2b~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=OZrIfjPD3fgKcNxrUMfFfNh3zRs%3D" data-ic="false" data-width="1080" data-height="880" data-ic-uri=""></div>
<p data-track="182">&nbsp;</p>
<p data-track="183"><strong>3.Java SPI机制的引入</strong></p>
<p data-track="184"><strong>(1)Java SPI机制的简介</strong></p>
<p data-track="185"><strong>(2)基于Java SPI机制开发日志框架的示例</strong></p>
<p data-track="186"><strong>(3)ServiceLoader的原理简介</strong></p>
<p data-track="187">&nbsp;</p>
<p data-track="188"><strong>(1)Java SPI机制的简介</strong></p>
<p data-track="189">SPI(Service Provider Interface)是Java提供的一种轻量级的服务发现机制，可以让开发者通过约定的方式，在程序运行时动态加载和替换接口的实现，从而提高程序的扩展性和灵活性。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191">比如在写框架时可以先写一个接口，然后内置几种实现类(实现不同算法)。但是业务系统接入这个框架时应该选择哪种算法、采取哪个实现类呢？这时就可以通过配置来完成。</p>
<p data-track="192">&nbsp;</p>
<p data-track="193">首先将接口实现类的全限定名配置在配置文件中，然后当业务系统启动时，框架会读取配置文件并解析出配置类的全限定名，接着通过反射机制在运行时动态替换接口的默认实现类。</p>
<p data-track="194">&nbsp;</p>
<p data-track="195"><strong>(2)基于Java SPI机制开发日志框架的示例</strong></p>
<p data-track="196">假设要开发一个日志框架，其中需要实现一个Logger接口，用于记录日志。我们希望在框架中预置两个Logger实现类：ConsoleLogger和FileLogger，同时也希望用户可以根据自己的需要扩展Logger实现类。</p>
<p data-track="197">&nbsp;</p>
<p data-track="198"><strong>步骤一：定义Logger接口</strong></p>
<pre class="highlighter-hljs"><code>public interface Logger {
    void log(String message);
}</code></pre>
<p data-track="200"><strong>步骤二：在框架中内置ConsoleLogger和FileLogger实现类</strong></p>
<pre class="highlighter-hljs"><code>public class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        //直接打印到控制台
        System.out.println("[ConsoleLogger] " + message);
    }
}

public class FileLogger implements Logger {
    @Override
    public void log(String message) {
        //将日志写入文件
    }
}</code></pre>
<p data-track="202"><strong>步骤三：实现SPI机制 + 扩展Logger实现类</strong></p>
<p data-track="203">首先，在META-INF/services目录下创建文件"com.example.Logger"，文件内容为Logger实现类的全限定名。例如，如下的MyLogger就是用户自定义的Logger实现类。</p>
<pre class="highlighter-hljs"><code>com.example.MyLogger</code></pre>
<p data-track="205">然后，在框架中读取Logger实现类的全限定名，并实例化Logger实现类，这可以通过以下代码实现。这段代码会从META-INF/services目录下读取Logger实现类的全限定名，然后通过Java反射机制实例化对应的Logger实现类，并调用其log()方法。</p>
<pre class="highlighter-hljs"><code>public static void main(String[] args){
    ServiceLoader&lt;Logger&gt; loggerServiceLoader = ServiceLoader.load(Logger.class);
    for (Logger logger : loggerServiceLoader) {
        logger.log("Hello, Java SPI!");
    }
}</code></pre>
<p data-track="207"><strong>(3)ServiceLoader的原理简介</strong></p>
<p data-track="208">ServiceLoader是Java提供的一种基于SPI机制的服务加载器，它可以在程序运行时动态加载和实例化实现了某个接口的类。所以通过ServiceLoader机制，可以方便地扩展和替换程序中的实现类。</p>
<p data-track="209">&nbsp;</p>
<p data-track="210">ServiceLoader的使用非常简单，只要首先按照规范创建接口和实现类，然后在META-INF/services目录下创建以接口全限定名命名的文件，接着在文件中写入实现类的全限定名，最后调用ServiceLoader的load()方法便可以加载并实例化实现类。</p>
<p data-track="211">&nbsp;</p>
<p data-track="212">ServiceLoader的load()方法会根据传入的接口获取接口的全类名，然后将前缀/META-INF/services与接口的全类名拼接来定位到配置文件，接着读取配置文件的内容获取文件中的字符串，最后解析字符串得到实现类的全类名并添加到一个数组。</p>
<p data-track="213">&nbsp;</p>
<p data-track="214">ServiceLoader实现了迭代器Iterable接口，当遍历ServiceLoader时，ServiceLoader会调用Class的forName()方法加载类并通过反射创建实例。如果没有指定类加载器，则会使用当前线程的上下文类加载器来加载类。通过这种方式，就可以方便地扩展和替换程序中的实现类。</p>
<p data-track="215">&nbsp;</p>
<p data-track="216"><strong>(4)总结</strong></p>
<p data-track="217">Java SPI是一种轻量级的服务发现机制，可以动态加载和替换接口实现类。通过约定的方式，开发者可在程序运行时动态地加载和替换接口的实现，从而提高程序的扩展性和灵活性。</p>
<p data-track="218">&nbsp;</p>
<p data-track="219">Java SPI机制通常与ServiceLoader一起使用，ServiceLoader会从META-INF/services目录下的配置文件中，读取接口实现类的全限定名，并通过Java反射机制实例化对应的类，从而实现对接口实现类的动态加载和替换。</p>
<p data-track="220">&nbsp;</p>
<p data-track="221">SPI机制在开源项目中被广泛使用，例如SpringBoot、RocketMQ、Dubbo、Sentinel等。</p>
<p data-track="222">&nbsp;</p>
<p data-track="223">Java SPI的使用流程图如下：</p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a9f3cd999d874423bf1d38cb035f76fd~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172909C0EDC243EF36B279CA45&amp;x-expires=2147483647&amp;x-signature=Lq48RUk8aZgGGYkvvtnN63%2BBY1Y%3D" data-ic="false" data-width="1080" data-height="636" data-ic-uri=""></div>
<p>&nbsp;</p>
<p data-track="222" data-pm-slice="1 1 []"><strong>4.Java SPI机制在Sentinel处理链中的应用</strong></p>
<p data-track="223"><strong>(1)初始化Entry会初始化处理链</strong></p>
<p data-track="224"><strong>(2)初始化处理链的设计分析</strong></p>
<p data-track="225"><strong>(3)Sentinel初始化处理链的完整流程</strong></p>
<p data-track="226"><strong>(4)Sentinel初始化处理任链之加载SPI文件</strong></p>
<p data-track="227"><strong>(5)Sentinel初始化处理链之实例化Class</strong></p>
<p data-track="228">&nbsp;</p>
<p data-track="229"><strong>(1)初始化Entry会初始化处理链</strong></p>
<p data-track="230">初始化Entry时会调用两个与处理链相关的核心方法：一是调用CtSph的lookProcessChain()方法初始化处理链，二是调用ProcessorSlot的entry()方法执行处理链节点的逻辑。</p>
<pre class="highlighter-hljs"><code>public class CtSph implements Sph {
    ...
    //Record statistics and perform rule checking for the given resource.
    //@param name the unique name for the protected resource
    //@param type the traffic type (inbound, outbound or internal).
    //This is used to mark whether it can be blocked when the system is unstable, only inbound traffic could be blocked by SystemRule
    //@param count the amount of calls within the invocation (e.g. batchCount=2 means request for 2 tokens)
    //@param args args for parameter flow control or customized slots
    @Override
    public Entry entry(String name, EntryType type, int count, Object... args) throws BlockException {
        //StringResourceWrapper是ResourceWrapper的子类，且StringResourceWrapper的构造方法默认了资源类型为COMMON
        StringResourceWrapper resource = new StringResourceWrapper(name, type);
        return entry(resource, count, args);
    }
    
    //Do all {@link Rule}s checking about the resource.
    public Entry entry(ResourceWrapper resourceWrapper, int count, Object... args) throws BlockException {
        //调用CtSph.entryWithPriority()方法，执行如下处理：
        //初始化Context -&gt; 将Context与线程绑定 -&gt; 初始化Entry -&gt; 将Context和ResourceWrapper放入Entry中
        return entryWithPriority(resourceWrapper, count, false, args);
    }
    
    private Entry entryWithPriority(ResourceWrapper resourceWrapper, int count, boolean prioritized, Object... args) throws BlockException {
        //从当前线程中获取Context
        Context context = ContextUtil.getContext();
        if (context instanceof NullContext) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //如果没获取到Context
        if (context == null) {
            //Using default context.
            //创建一个名为sentinel_default_context的Context，并且与当前线程绑定
            context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);
        }
        //Global switch is close, no rule checking will do.
        if (!Constants.ON) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //调用CtSph.lookProcessChain()方法初始化处理链(处理器插槽链条)
        ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);
        if (chain == null) {
            return new CtEntry(resourceWrapper, null, context);
        }
        //创建出一个Entry对象，将处理链(处理器插槽链条)、Context与Entry绑定
        //其中会将Entry的三个基础属性(封装在resourceWrapper里)以及当前Entry所属的Context作为参数传入CtEntry的构造方法
        Entry e = new CtEntry(resourceWrapper, chain, context);
        try {
            //处理链(处理器插槽链条)入口，负责采集数据，规则验证
            //调用DefaultProcessorSlotChain.entry()方法执行处理链每个节点的逻辑(数据采集+规则验证)
            chain.entry(context, resourceWrapper, null, count, prioritized, args);
        } catch (BlockException e1) {
            //规则验证失败，比如：被流控、被熔断降级、触发黑白名单等
            e.exit(count, args);
            throw e1;
        } catch (Throwable e1) {
            RecordLog.info("Sentinel unexpected exception", e1);
        }
        return e;
    }
    ...
    private final static class InternalContextUtil extends ContextUtil {
        static Context internalEnter(String name) {
            //调用ContextUtil.trueEnter()方法创建一个Context对象
            return trueEnter(name, "");
        }
        
        static Context internalEnter(String name, String origin) {
            return trueEnter(name, origin);
        }
    }
}</code></pre>
<p data-track="232"><strong>(2)初始化处理链的设计分析</strong></p>
<p data-track="233"><strong>一.初始化处理链需要加锁确保线程安全</strong></p>
<p data-track="234">由于每个线程在执行CtSph的entry()方法创建一个Entry对象时，都需要首先调用CtSph的lookProcessChain()方法获取一个处理链，然后再根据这个处理链去初始化一个Entry对象，所以多个同样的Entry对象会共用一个处理链对象。</p>
<p data-track="235">&nbsp;</p>
<p data-track="236">需要注意：即便是多个线程访问同样的资源(ResourceWrapper对象的属性一样)，多个线程也会对应多个Entry对象(Entry对象之间的基本属性一样)，多个线程也会对应多个Context对象(使用ThreadLocal存放Context对象)，从而多个Entry对象会对应各自的Context对象。多个Entry对象会共用一个处理链对象(使用HashMap来缓存处理链对象)，多个Context对象会共用一个Node对象(使用HashMap来缓存Node对象)，多个Entry对象会共用一个Node对象(使用HashMap来缓存Node对象)。</p>
<p data-track="237">&nbsp;</p>
<p data-track="238">因此当出现多线程并发创建多个Entry对象时，CtSph的lookProcessChain()方法自然就会被多线程并发调用。所以在初始化处理链时，需要考虑线程安全和性能问题。</p>
<p data-track="239">&nbsp;</p>
<p data-track="240">为了确保线程安全，可以采用加锁的方式来初始化处理链，然后将处理链缓存到HashMap中来提高性能，如下伪代码所示：</p>
<pre class="highlighter-hljs"><code>//缓存处理链，key为资源，value为处理链
//多个线程创建多个Entry对象时，也会创建多个ResourceWrapper对象
//但这些ResourceWrapper对象，在同一个资源下，其属性是一样的
private static volatile Map&lt;ResourceWrapper, ProcessorSlotChain&gt; chainMap = new HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;();

//加锁synchronized
synchronized ProcessorSlot&lt;Object&gt; lookProcessChain(ResourceWrapper resourceWrapper) {
    ProcessorSlotChain chain = chainMap.get(resourceWrapper);
    if (chain == null) {
        //构建(初始化)处理链(处理器插槽链条)
        chain = SlotChainProvider.newSlotChain();
        //将处理链(处理器插槽链条)放到缓存中
        chainMap.put(resourceWrapper, chain);
    }
    return chain;
}</code></pre>
<p data-track="242"><strong>二.初始化处理链通过SPI机制动态管理节点</strong></p>
<p data-track="243">初始化处理链时可使用List硬编码添加每个节点。</p>
<pre class="highlighter-hljs"><code>public class DefaultSlotChainBuilder implements SlotChainBuilder {
    @Override
    public ProcessorSlotChain build() {
        //硬编码
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();
        chain.addLast(new NodeSelectorSlot());
        chain.addLast(new ClusterBuilderSlot());
        chain.addLast(new StatisticSlot());
        chain.addLast(new AuthoritySlot());
        chain.addLast(new SystemSlot());
        chain.addLast(new FlowSlot());
        chain.addLast(new DegradeSlot());
        return chain;
    }
}</code></pre>
<p data-track="245">但硬编码的缺点是无法动态增减ProcessorSlot。比如不需要授权AuthoritySlot，硬编码时就不好删除了。比如内置的几个ProcessorSlot不符合业务需求，硬编码难以实现自定义。因此，需要使用SPI机制来解决硬编码带来的问题。也就是在配置文件中注册多个实现类，然后通过迭代器的方式逐个加载。</p>
<p data-track="246">&nbsp;</p>
<p data-track="247">具体就是在META-INF/services目录下创建一个接口文件，然后将需要注册的实现类的全类名每行一个写入该文件中。框架启动时依次读取该文件中的实现类，并按照文件中注册的顺序加载。如果业务系统也创建了META-INF/services目录以及一个接口文件，那么业务系统的实现类并不会覆盖框架内置的实现类，而是叠加起来使用。</p>
<p data-track="248">&nbsp;</p>
<p data-track="249">利用SPI机制，可以实现责任链模式的可插拔式扩展，处理链(处理器插槽链条)的每个节点都可以动态添加、删除、替换。</p>
<p data-track="250">&nbsp;</p>
<p data-track="251"><strong>三.使用SPI机制的两大步骤</strong></p>
<p data-track="252"><strong>步骤一：</strong>创建META-INF/services目录，然后在该目录下创建一个文件名为如下的文件，文件内容为定义了处理链由哪些节点组成的类的类名全路径。</p>
<pre class="highlighter-hljs"><code>com.alibaba.csp.sentinel.slotchain.SlotChainBuilder</code></pre>
<p data-track="254"><strong>步骤二：</strong>通过ServiceLoader初始化处理链节点。</p>
<pre class="highlighter-hljs"><code>public static void main(String[] args){
    ServiceLoader&lt;SlotChainBuilder&gt; serviceLoader = ServiceLoader.load(SlotChainBuilder.class);
    ...
}</code></pre>
<p data-track="256"><strong>四.初始化处理链的设计要点总结</strong></p>
<p data-track="257">要点一：初始化处理链时加锁</p>
<p data-track="258">要点二：使用HashMap缓存处理链</p>
<p data-track="259">要点三：使用SPI机制初始化处理链</p>
<p data-track="260">&nbsp;</p>
<p data-track="261"><strong>(3)Sentinel初始化处理链的完整流程</strong></p>
<p data-track="262"><strong>一.将处理链存储在全局缓存 + 使用锁初始化处理链</strong></p>
<p data-track="263">如果对CtSph的lookProcessChain()方法加锁，则锁的粒度过大。所以可以在操作缓存处理链的HashMap时才加synchronized锁，而且在操作缓存处理链的HashMap时，使用了Double Check + 写时复制。</p>
<p data-track="264">&nbsp;</p>
<p data-track="265"><strong>二.利用SPI机制完成处理链的初始化</strong></p>
<p data-track="266">为了增加扩展性，Sentinel初始化处理链时使用了SPI机制两次。第一次使用SPI机制，是为了可以自定义处理链的节点编排。第二次使用SPI机制，是为了可以自定义处理链各节点的具体逻辑。</p>
<pre class="highlighter-hljs"><code>public class CtSph implements Sph {
    //Same resource will share the same ProcessorSlotChain}, no matter in which Context.
    //Same resource is that ResourceWrapper#equals(Object).
    private static volatile Map&lt;ResourceWrapper, ProcessorSlotChain&gt; chainMap = new HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;();
    private static final Object LOCK = new Object();
    ...
    //Get ProcessorSlotChain of the resource.
    //new ProcessorSlotChain will be created if the resource doesn't relate one.
    //Same resource will share the same ProcessorSlotChain globally, no matter in which Context.
    //Same resource is that ResourceWrapper#equals(Object).
    //Note that total ProcessorSlot count must not exceed Constants.MAX_SLOT_CHAIN_SIZE, otherwise null will return.
    ProcessorSlot&lt;Object&gt; lookProcessChain(ResourceWrapper resourceWrapper) {
        ProcessorSlotChain chain = chainMap.get(resourceWrapper);
        if (chain == null) {
            //操作chainMap时才加锁
            synchronized (LOCK) {
                chain = chainMap.get(resourceWrapper);
                if (chain == null) {//Double Check
                    //Entry size limit.
                    if (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) {
                        return null;
                    }
                    //初始化处理链(处理器插槽链条)
                    chain = SlotChainProvider.newSlotChain();
                    //写时复制
                    Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = new HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(chainMap.size() + 1);
                    newMap.putAll(chainMap);
                    newMap.put(resourceWrapper, chain);
                    chainMap = newMap;
                }
            }
        }
        return chain;
    }
    ...
}

//A provider for creating slot chains via resolved slot chain builder SPI.
public final class SlotChainProvider {
    private static volatile SlotChainBuilder slotChainBuilder = null;

    //The load and pick process is not thread-safe,
    //but it's okay since the method should be only invoked via CtSph.lookProcessChain() under lock.
    public static ProcessorSlotChain newSlotChain() {
        //如果存在，则直接返回
        if (slotChainBuilder != null) {
            return slotChainBuilder.build();
        }

        //Resolve the slot chain builder SPI.
        //第一次使用SPI: 通过SPI机制初始化SlotChainBuilder
        slotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();

        if (slotChainBuilder == null) {
            //Should not go through here.
            RecordLog.warn("[SlotChainProvider] Wrong state when resolving slot chain builder, using default");
            slotChainBuilder = new DefaultSlotChainBuilder();
        } else {
            RecordLog.info("[SlotChainProvider] Global slot chain builder resolved: {}", slotChainBuilder.getClass().getCanonicalName());
        }
        return slotChainBuilder.build();
    }
    private SlotChainProvider() {}
}

public final class SpiLoader&lt;S&gt; {
    //Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance
    private static final ConcurrentHashMap&lt;String, SpiLoader&gt; SPI_LOADER_MAP = new ConcurrentHashMap&lt;&gt;();
    //Cache the classes of Provider
    private final List&lt;Class&lt;? extends S&gt;&gt; classList = Collections.synchronizedList(new ArrayList&lt;Class&lt;? extends S&gt;&gt;());
    //Cache the sorted classes of Provider
    private final List&lt;Class&lt;? extends S&gt;&gt; sortedClassList = Collections.synchronizedList(new ArrayList&lt;Class&lt;? extends S&gt;&gt;());
    ...
    //Create SpiLoader instance via Service class Cached by className, and load from cache first
    public static &lt;T&gt; SpiLoader&lt;T&gt; of(Class&lt;T&gt; service) {
        AssertUtil.notNull(service, "SPI class cannot be null");
        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()), "SPI class[" + service.getName() + "] must be interface or abstract class");

        String className = service.getName();
        SpiLoader&lt;T&gt; spiLoader = SPI_LOADER_MAP.get(className);
        if (spiLoader == null) {
            synchronized (SpiLoader.class) {
                spiLoader = SPI_LOADER_MAP.get(className);
                if (spiLoader == null) {//Double Check
                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader&lt;&gt;(service));
                    spiLoader = SPI_LOADER_MAP.get(className);
                }
            }
        }
        return spiLoader;
    }
    
    //Load the first-found Provider instance,if not found, return default Provider instance
    public S loadFirstInstanceOrDefault() {
        //SPI机制加载Class，然后将加载的Class放到classList数组里
        load();

        //循环遍历，根据classList里的Class来初始化对应的实例
        for (Class&lt;? extends S&gt; clazz : classList) {
            if (defaultClass == null || clazz != defaultClass) {
                return createInstance(clazz);
            }
        }
        //初始化默认的DefaultSlotChainBuilder
        return loadDefaultInstance();
    }
    
    //Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation
    public List&lt;S&gt; loadInstanceListSorted() {
        //比如读取com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件里的Class名字
        //然后根据这些Class名字加载Class
        //接着将Class放到sortedClassList集合中
        load();

        //实例化sortedClassList集合里的每个Class
        return createInstanceList(sortedClassList);
    }
    ...
}

//Builder for a default {@link ProcessorSlotChain}.
@Spi(isDefault = true)
public class DefaultSlotChainBuilder implements SlotChainBuilder {
    @Override
    public ProcessorSlotChain build() {
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();
        //通过SPI机制加载责任链的节点ProcessorSlot实现类
        //然后按照@Spi注解的order属性进行排序并进行实例化
        //最后将ProcessorSlot实例放到sortedSlotList中
        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();
        //遍历已排好序的ProcessorSlot集合
        for (ProcessorSlot slot : sortedSlotList) {
            //安全检查，防止业务系统也写了一个SPI文件，但没按规定继承AbstractLinkedProcessorSlot
            if (!(slot instanceof AbstractLinkedProcessorSlot)) {
                RecordLog.warn("The ProcessorSlot(" + slot.getClass().getCanonicalName() + ") is not an instance of AbstractLinkedProcessorSlot, can't be added into ProcessorSlotChain");
                continue;
            }
            //调用DefaultProcessorSlotChain.addLast()方法构建单向链表
            //将责任链的节点ProcessorSlot实例放入DefaultProcessorSlotChain中
            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);
        }
        //返回单向链表
        return chain;
    }
}</code></pre>
<p data-track="268">第一次使用SPI机制是初始化SlotChainBuilder，在com.alibaba.csp.sentinel.slotchain.SlotChainBuilder文件中，框架默认的是com.alibaba.csp.sentinel.slots.DefaultSlotChainBuilder。</p>
<p data-track="269">&nbsp;</p>
<p data-track="270">在SpiLoader的loadFirstInstanceOrDefault()方法中，根据"if (defaultClass == null || clazz != defaultClass)"可知，系统接入Sentinel时可以自定义SPI接口文件来替换DefaultSlotChainBuilder。</p>
<p data-track="271">&nbsp;</p>
<p data-track="272">比如想删除AuthoritySlot，那么可以在META-INF/services目录下，创建文件名如下，文件值为自定义接口的实现类全路径，如下：</p>
<pre class="highlighter-hljs"><code>文件名：com.alibaba.csp.sentinel.slotchain.SlotChainBuilder
文件值：com.example.MyCustomSlotChainBuilder</code></pre>
<p data-track="274">然后在MyCustomSlotChainBuilder中就可以自定义一套处理链的规则。</p>
<pre class="highlighter-hljs"><code>public class MyCustomSlotChainBuilder implements SlotChainBuilder {
    @Override
    public ProcessorSlotChain build() {
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();
        chain.addLast(new NodeSelectorSlot());
        chain.addLast(new ClusterBuilderSlot());
        chain.addLast(new StatisticSlot());
        chain.addLast(new FlowSlot());
        return chain;
    }
}</code></pre>
<p data-track="276">第二次使用SPI机制是执行DefaultSlotChainBuilder的build()方法初始化处理链，其中的核心代码是SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted()。所调用的方法会读取com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件内容，然后根据文件内容加载Class，接着将Class放到sortedClassList集合中，最后实例化sortedClassList集合中的Class并返回ProcessorSlot实例列表。</p>
<p data-track="277">&nbsp;</p>
<p data-track="278">注意：ProcessorSlot实现类是有序的，即处理链的节点是有序的。比如ClusterBuilderSlot的前一个节点必须是NodeSelectorSlot，StatisticSlot的前一个节点必须是ClusterBuilderSlot等。</p>
<p data-track="279">&nbsp;</p>
<p data-track="280"><strong>(4)Sentinel初始化处理链之加载SPI文件</strong></p>
<p data-track="281">Sentinel初始化处理链时会先后调用如下两个方法，这两个方法都会调用SpiLoader的load()方法来加载SPI文件。</p>
<pre class="highlighter-hljs"><code>SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault()
SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted()</code></pre>
<p data-track="283">SpiLoader的load()方法的执行过程就是加载SPI文件的过程。但是由于SPI文件可能会有很多个，比如负责管控整个处理链的Builder对应的SPI文件：</p>
<pre class="highlighter-hljs"><code>com.alibaba.csp.sentinel.slotchain.SlotChainBuilder</code></pre>
<p data-track="285">以及处理链节点的ProcessorSlot对应的SPI文件：</p>
<pre class="highlighter-hljs"><code>com.alibaba.csp.sentinel.slotchain.ProcessorSlot</code></pre>
<p data-track="287">虽然它们都隶属于META-INF/services下，但其文件名是不一样的。所以按理应在load()方法添加一个参数如：load(String fileName)。但是Sentinel却没这么做，因为Sentinel使用配置去替代参数。</p>
<p data-track="288">&nbsp;</p>
<p data-track="289">具体做法就是：先在SpiLoader内定义常量SPI_FILE_PREFIX = "META-INF/services/"。有了SPI文件夹后，还需接口全路径名为名称的文件，就可读取文件了。</p>
<p data-track="290">&nbsp;</p>
<p data-track="291">于是SpiLoader提供了一个静态的of()方法，来指定要加载那一类接口。也就是SpiLoader的of()方法会返回一个指定加载某种接口的SpiLoader实例。</p>
<p data-track="292">&nbsp;</p>
<p data-track="293">然后在执行指定加载某一类接口的SpiLoader实例的load()方法时，就能将指定要加载的接口的名称拼接上SPI_FILE_PREFIX文件夹前缀，得到一份完整的文件路径，接着就可通过IO流读取文件里的内容。</p>
<p data-track="294">&nbsp;</p>
<p data-track="295">从文件中获取到指定加载的某一类接口的实现类类名之后，就可以通过Class.forName() + 线程上下文类加载器去加载对应的实现类，加载到的实现类会放入到classList和sortedClassList两个列表中。</p>
<p data-track="296">&nbsp;</p>
<p data-track="297">注意：Sentinel的SPI机制没有使用JDK内置的ServiceLoader，而是自己实现。因为Sentinel的SPI有一些定制化逻辑，比如@Spi注解的order属性可以指定实例化类时的顺序。但本质上和JDK内置的ServiceLoader一致，只是多了个性化的逻辑。</p>
<pre class="highlighter-hljs"><code>public final class SpiLoader&lt;S&gt; {
    //Default path for the folder of Provider configuration file
    //SPI文件夹路径
    private static final String SPI_FILE_PREFIX = "META-INF/services/";
    //Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance
    //每个接口Class对应的SpiLoader，只需new一次即可，new完就可以将其缓存起来
    private static final ConcurrentHashMap&lt;String, SpiLoader&gt; SPI_LOADER_MAP = new ConcurrentHashMap&lt;&gt;();
    //Cache the classes of Provider
    private final List&lt;Class&lt;? extends S&gt;&gt; classList = Collections.synchronizedList(new ArrayList&lt;Class&lt;? extends S&gt;&gt;());
    //Cache the sorted classes of Provider
    private final List&lt;Class&lt;? extends S&gt;&gt; sortedClassList = Collections.synchronizedList(new ArrayList&lt;Class&lt;? extends S&gt;&gt;());
    //The Service class, must be interface or abstract class
    //指定要使用SPI进行加载的实现类的接口的Class，比如SlotChainBuilder.class、ProcessorSlot.class
    private Class&lt;S&gt; service;
    ...
    private SpiLoader(Class&lt;S&gt; service) {
        this.service = service;
    }
    
    //Create SpiLoader instance via Service class
    //Cached by className, and load from cache first
    //@param service Service class 指定要使用SPI加载的实现类的接口的Class
    public static &lt;T&gt; SpiLoader&lt;T&gt; of(Class&lt;T&gt; service) {
        //判断是不是null
        AssertUtil.notNull(service, "SPI class cannot be null");
        //判断是不是interface类型
        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()), "SPI class[" + service.getName() + "] must be interface or abstract class");


        //获取接口的全路径名，判断缓存里是否已经存在
        String className = service.getName();
        SpiLoader&lt;T&gt; spiLoader = SPI_LOADER_MAP.get(className);
        //缓存里没有，则使用Double Check + 锁机制去初始化SpiLoader，然后将初始化好的SpiLoader实例放到缓存
        if (spiLoader == null) {
            synchronized (SpiLoader.class) {
                spiLoader = SPI_LOADER_MAP.get(className);
                if (spiLoader == null) {
                    //new SpiLoader&lt;&gt;(service)初始化SpiLoader实例
                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader&lt;&gt;(service));
                    spiLoader = SPI_LOADER_MAP.get(className);
                }
            }
        }
        //返回SpiLoader实例
        return spiLoader;
    }
    
    //Load the first-found Provider instance,if not found, return default Provider instance
    public S loadFirstInstanceOrDefault() {
        //SPI机制加载Class，然后将加载的Class放到classList数组里
        load();
        //循环遍历，根据classList里的Class来初始化对应的实例
        for (Class&lt;? extends S&gt; clazz : classList) {
            if (defaultClass == null || clazz != defaultClass) {
                return createInstance(clazz);
            }
        }
        //初始化默认的DefaultSlotChainBuilder
        return loadDefaultInstance();
    }
    
    //Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation
    public List&lt;S&gt; loadInstanceListSorted() {
        //比如读取com.alibaba.csp.sentinel.slotchain.ProcessorSlot文件里的Class名字
        //然后根据这些Class名字加载Class
        //接着将Class放到sortedClassList集合中
        load();
        //实例化sortedClassList集合里的每个Class
        return createInstanceList(sortedClassList);
    }
    
    //Load the Provider class from Provider configuration file
    public void load() {
        ...
        //IO流读取文件内容
        while (urls.hasMoreElements()) {
            ...
            clazz = (Class&lt;S&gt;) Class.forName(line, false, classLoader);
            //加入到集合中
            classList.add(clazz);
            ...
        }
        ...
        //生成新的按照order排序的集合
        sortedClassList.addAll(classList);
        //进行排序
        Collections.sort(sortedClassList, new Comparator&lt;Class&lt;? extends S&gt;&gt;() {
            @Override
            public int compare(Class&lt;? extends S&gt; o1, Class&lt;? extends S&gt; o2) {
                //获取Spi注解
                Spi spi1 = o1.getAnnotation(Spi.class);
                //获取Spi注解的order属性
                int order1 = spi1 == null ? 0 : spi1.order();
                Spi spi2 = o2.getAnnotation(Spi.class);
                int order2 = spi2 == null ? 0 : spi2.order();
                return Integer.compare(order1, order2);
            }
        });
    }
    ...
}</code></pre>
<p data-track="299"><strong>(5)Sentinel初始化处理链之实例化Class</strong></p>
<p data-track="300">执行完SpiLoader的load()方法加载好指定的实现类的Class后，就会调用SpiLoader的createInstance()方法或createInstanceList()方法实例化Class。</p>
<p data-track="301">&nbsp;</p>
<p data-track="302">SpiLoader放入createInstance(clazz)方法内部会判断是否是单例，如果是单例则放到缓存当中，如果不是单例则每次都通过clazz.newInstance()方法创建一个新的对象。</p>
<pre class="highlighter-hljs"><code>public final class SpiLoader&lt;S&gt; {
    //Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance
    private final ConcurrentHashMap&lt;String, S&gt; singletonMap = new ConcurrentHashMap&lt;&gt;();
    ...
    //Create Provider instance list
    private List&lt;S&gt; createInstanceList(List&lt;Class&lt;? extends S&gt;&gt; clazzList) {
        if (clazzList == null || clazzList.size() == 0) {
            return Collections.emptyList();
        }

        List&lt;S&gt; instances = new ArrayList&lt;&gt;(clazzList.size());
        for (Class&lt;? extends S&gt; clazz : clazzList) {
            S instance = createInstance(clazz);
            instances.add(instance);
        }
        return instances;
    }
    
    //Create Provider instance
    private S createInstance(Class&lt;? extends S&gt; clazz) {
        Spi spi = clazz.getAnnotation(Spi.class);
        boolean singleton = true;
        if (spi != null) {
            singleton = spi.isSingleton();
        }
        return createInstance(clazz, singleton);
    }
    
    //Create Provider instance
    private S createInstance(Class&lt;? extends S&gt; clazz, boolean singleton) {
        S instance = null;
        try {
            if (singleton) {
                instance = singletonMap.get(clazz.getName());
                if (instance == null) {
                    synchronized (this) {
                        instance = singletonMap.get(clazz.getName());
                        if (instance == null) {
                            instance = service.cast(clazz.newInstance());
                            singletonMap.put(clazz.getName(), instance);
                        }
                    }
                }
            } else {
                instance = service.cast(clazz.newInstance());
            }
        } catch (Throwable e) {
            fail(clazz.getName() + " could not be instantiated");
        }
        return instance;
    }
    ...
}</code></pre>
<p data-track="304"><strong>(6)总结</strong></p>
<p data-track="305"><strong>一.初始化处理链时需要加锁和使用缓存</strong></p>
<p data-track="306">初始化一个Entry对象时需要根据一个处理链对象进行初始化，并发请求同一接口时的多个同样的Entry对象会共用一个处理链对象，所以初始化处理链的过程中需要加锁来保证线程安全性，初始化完处理链后需要将其放到全局缓存里来提高性能。</p>
<p data-track="307">&nbsp;</p>
<p data-track="308"><strong>二.初始化处理链时分两步使用SPI</strong></p>
<p data-track="309">首先初始化Builder，负责管控处理链整体即编排处理链节点。Sentinel要求Builder只能存在一个，而且是外部系统优先原则。可以在com.alibaba.csp.sentinel.slotchain.SlotChainBuilder文件中，指定替代默认的DefaultSlotChainBuilder的自定义接口实现类。</p>
<p data-track="310">&nbsp;</p>
<p data-track="311">然后通过Builder初始化完整的处理链，这里也是通过SPI机制进行初始化。因此可以进行扩展，比如外部系统自定义ProcessorSlot添加到处理链。注意ProcessorSlot是有顺序的，如果顺序没指定正确，则可能造成异常。ProcessorSlot的顺序可以通过@Spi注解的order属性设置。为了防止出现bug，建议直接将自定义的ProcessorSlot放到最后。</p>
<p data-track="312">&nbsp;</p>
<p data-track="313"><strong>三.Sentinel通过配置的方式来替代传入参数</strong></p>
<p data-track="314">SpiLoader的of()方法会返回一个指定加载某种实现类的SpiLoader实例，这样就可以使用类似SpiLoader.of().load()的方式通过SPI进行加载。</p>
<p data-track="315">&nbsp;</p>
<p data-track="316"><strong>四.Sentinel没有采用JDK内置的ServiceLoader来实现SPI机制</strong></p>
<p data-track="317">Sentinel单独写一套SPI的实现逻辑，核心原因是需要支持个性化的配置。比如@Spi注解支持order排序属性以及isSingleton是否单例属性。如果是单例，则每个类全局只能实例化一次(通过Map缓存实现)。如果不是单例，则每次都new一个新的对象。</p>
<p data-track="318">&nbsp;</p>
<p data-track="319"><strong>五.Sentinel的这套SPI机制可以当作工具类拷贝到业务系统中</strong></p>
<p data-track="320">因为没有其他外部依赖，它被单独放到一个包里。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7e35b444cf06475cb2f411f0f2259cfc~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250415172914FFC5A3E9A50809D27077&amp;x-expires=2147483647&amp;x-signature=y9adXTNi8CKy%2BuOJqi5zawJzAaM%3D" data-ic="false" data-width="1080" data-height="458" data-ic-uri=""></div>
<p data-track="321">&nbsp;</p>
<p data-track="322"><strong>5.Sentinel默认处理链ProcessorSlot的构建</strong></p>
<p data-track="323"><strong>(1)Sentinel默认处理链的节点</strong></p>
<p data-track="324"><strong>(2)Sentinel默认处理链的构建</strong></p>
<p data-track="325">&nbsp;</p>
<p data-track="326"><strong>(1)Sentinel默认处理链的节点</strong></p>
<p data-track="327">Sentinel中的ProcessorSlot是流量控制处理过程中的处理器，每个ProcessorSlot处理器子类负责处理特定的任务。Sentinel默认的处理链会基于SPI配置在sentinel-core模块的如下文件中：</p>
<pre class="highlighter-hljs"><code># Sentinel-1.8.6/sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot
# Sentinel default ProcessorSlots
com.alibaba.csp.sentinel.slots.nodeselector.NodeSelectorSlot
com.alibaba.csp.sentinel.slots.clusterbuilder.ClusterBuilderSlot
com.alibaba.csp.sentinel.slots.logger.LogSlot
com.alibaba.csp.sentinel.slots.statistic.StatisticSlot
com.alibaba.csp.sentinel.slots.block.authority.AuthoritySlot
com.alibaba.csp.sentinel.slots.system.SystemSlot
com.alibaba.csp.sentinel.slots.block.flow.FlowSlot
com.alibaba.csp.sentinel.slots.block.degrade.DegradeSlot</code></pre>
<p data-track="329">一共8个Slot，每个Slot都是一个过滤器，各自承担不同的职责。这些Slot整体可以划分为两类：指标数据采集的Slot和规则验证的Slot。其中规则验证的Slot包括：授权验证、流控验证、熔断降级验证。</p>
<p data-track="330">&nbsp;</p>
<p data-track="331">每个Slot都有自己在整个处理链(处理器插槽链条)中的顺序，具体的顺序(也就是实例化顺序)并不是根据SPI文件的编写顺序来确定的，而是基于修饰每个Slot的@Spi注解来确定的。</p>
<p data-track="332">&nbsp;</p>
<p data-track="333">@Spi注解有一个order属性用于设置顺序。SpiLoader的load()方法在读取SPI文件时，会按order属性对Slot进行排序，并将排好序的ProcessorSlot实现类放入sortedClassList中。这样后续就可以遍历sortedClassList，按照顺序实例化这些Slot的实现类。</p>
<p data-track="334">&nbsp;</p>
<p data-track="335"><strong>一.NodeSelectorSlot</strong></p>
<p data-track="336">负责创建和维护资源调用树(资源调用关系)，同时为资源访问对象Entry关联对应的统计节点DefaultNode。这样不仅可实现对资源调用链路的监控，还能统计每个资源的调用信息。</p>
<p data-track="337">&nbsp;</p>
<p data-track="338"><strong>二.ClusterBuilderSlot</strong></p>
<p data-track="339">负责根据资源的统计信息，计算集群维度的统计数据。集群维度统计数据是从资源维度的统计数据中整合得到的，这些统计数据用于实现资源在集群中的流量控制、熔断降级等功能。</p>
<p data-track="340">&nbsp;</p>
<p data-track="341"><strong>三.LogSlot</strong></p>
<p data-track="342">负责记录请求异常时的日志，可用于故障排查。</p>
<p data-track="343">&nbsp;</p>
<p data-track="344"><strong>四.StatisticsSlot</strong></p>
<p data-track="345">负责统计资源的调用数据，如成功调用次数、异常次数、响应时间等。这些数据可用于分析资源的性能，或驱动其他Slot(如限流降级Slot)运行。</p>
<p data-track="346">&nbsp;</p>
<p data-track="347"><strong>五.AuthoritySlot</strong></p>
<p data-track="348">负责进行授权控制，根据资源的授权规则来判断是否允许请求进行访问。如果请求不被允许访问，AuthoritySlot将抛出AuthorityException异常。</p>
<p data-track="349">&nbsp;</p>
<p data-track="350"><strong>六.SystemSlot</strong></p>
<p data-track="351">负责进行系统保护，根据系统保护规则(如CPU使用率、负载等)判断请求是否需要被限制。如果需要被限制，SystemSlot将抛出SystemException异常。</p>
<p data-track="352">&nbsp;</p>
<p data-track="353"><strong>七.FlowSlot</strong></p>
<p data-track="354">负责进行流量控制，根据资源的流量控制规则(如QPS限制等)来判断请求是否需要被限流。如果需要被限流，FlowSlot将抛出一个FlowException异常。</p>
<p data-track="355">&nbsp;</p>
<p data-track="356"><strong>八.DegradeSlot</strong></p>
<p data-track="357">负责进行熔断降级，根据资源的熔断降级规则(如异常比例等)来判断请求是否需要被降级。如果需要被降级，DegradeSlot将抛出一个DegradeException异常。</p>
<p data-track="358">&nbsp;</p>
<p data-track="359"><strong>(2)Sentinel默认处理链的构建</strong></p>
<p data-track="360">处理链(处理器插槽链条)ProcessorSlotChain其实就是一条责任链，由于责任链是典型的单向链表结构，所以每个Slot必须要有一个next属性，用于指向下一个节点。</p>
<p data-track="361">&nbsp;</p>
<p data-track="362">为了实现单向链表结构：可以利用已排好序的Slot列表以及每个Slot都有的next引用的特性。只需遍历已排序的Slot列表，让每个Slot的next引用指向下一个Slot即可。这是一个非常简单的单向链表操作，可将这个过程封装到DefaultProcessorSlotChain类中的addLast()方法中。</p>
<pre class="highlighter-hljs"><code>//Builder for a default {@link ProcessorSlotChain}.
@Spi(isDefault = true)
public class DefaultSlotChainBuilder implements SlotChainBuilder {
    @Override
    public ProcessorSlotChain build() {
        //创建一个DefaultProcessorSlotChain对象实例
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();
        //通过SPI机制加载责任链的节点ProcessorSlot实现类
        //然后按照@Spi注解的order属性进行排序并进行实例化
        //最后将ProcessorSlot实例放到sortedSlotList中
        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();
        //遍历已排好序的ProcessorSlot列表
        for (ProcessorSlot slot : sortedSlotList) {
            //安全检查，防止业务系统也写了一个SPI文件，但没按规定继承AbstractLinkedProcessorSlot
            if (!(slot instanceof AbstractLinkedProcessorSlot)) {
                RecordLog.warn("The ProcessorSlot(" + slot.getClass().getCanonicalName() + ") is not an instance of AbstractLinkedProcessorSlot, can't be added into ProcessorSlotChain");
                continue;
            }
            //调用DefaultProcessorSlotChain.addLast()方法构建单向链表
            //将责任链的节点ProcessorSlot实例放入DefaultProcessorSlotChain中
            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);
        }
        //返回单向链表
        return chain;
    }
}

public class DefaultProcessorSlotChain extends ProcessorSlotChain {
    AbstractLinkedProcessorSlot&lt;?&gt; first = new AbstractLinkedProcessorSlot&lt;Object&gt;() {
        @Override
        public void entry(Context context, ResourceWrapper resourceWrapper, Object t, int count, boolean prioritized, Object... args) throws Throwable {
            super.fireEntry(context, resourceWrapper, t, count, prioritized, args);
        }

        @Override
        public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {
            super.fireExit(context, resourceWrapper, count, args);
        }
    };
    
    AbstractLinkedProcessorSlot&lt;?&gt; end = first;

    @Override
    public void addFirst(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor) {
        protocolProcessor.setNext(first.getNext());
        first.setNext(protocolProcessor);
        if (end == first) {
            end = protocolProcessor;
        }
    }
    
    @Override
    public void addLast(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor) {
        end.setNext(protocolProcessor);
        end = protocolProcessor;
    }
    
    @Override
    public void setNext(AbstractLinkedProcessorSlot&lt;?&gt; next) {
        addLast(next);
    }
    
    @Override
    public AbstractLinkedProcessorSlot&lt;?&gt; getNext() {
        return first.getNext();
    }
    
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, Object t, int count, boolean prioritized, Object... args) throws Throwable {
        first.transformEntry(context, resourceWrapper, t, count, prioritized, args);
    }
    
    @Override
    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {
        first.exit(context, resourceWrapper, count, args);
    }
}

public abstract class AbstractLinkedProcessorSlot&lt;T&gt; implements ProcessorSlot&lt;T&gt; {
    private AbstractLinkedProcessorSlot&lt;?&gt; next = null;
    
    @Override
    public void fireEntry(Context context, ResourceWrapper resourceWrapper, Object obj, int count, boolean prioritized, Object... args) throws Throwable {
        if (next != null) {
            next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);
        }
    }
    
    @SuppressWarnings("unchecked")
    void transformEntry(Context context, ResourceWrapper resourceWrapper, Object o, int count, boolean prioritized, Object... args) throws Throwable {
        T t = (T)o;
        entry(context, resourceWrapper, t, count, prioritized, args);
    }
    
    @Override
    public void fireExit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {
        if (next != null) {
            next.exit(context, resourceWrapper, count, args);
        }
    }
    
    public AbstractLinkedProcessorSlot&lt;?&gt; getNext() {
        return next;
    }
    
    public void setNext(AbstractLinkedProcessorSlot&lt;?&gt; next) {
        this.next = next;
    }
}</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.023032094076388888" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-15 21:44">2025-04-15 21:44</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18827616);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18827616', targetLink: 'https://www.cnblogs.com/mjunz/p/18827616', title: 'Sentinel源码—2.Context和处理链的初始化' })">举报</a>
</div>
        