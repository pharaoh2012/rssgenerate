
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18716162" title="发布于 2025-02-14 21:18">
    <span role="heading" aria-level="2">【忍者算法】从生活场景到回文链表：探索对称性检测｜LeetCode 234 回文链表</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从生活场景到回文链表探索对称性检测">从生活场景到回文链表：探索对称性检测</h1>
<h2 id="生活中的回文现象">生活中的回文现象</h2>
<p>在日常生活中，回文无处不在。比如"上海自来水来自海上"、"12321"这样正着读和倒着读都一样的字符串或数字，就是回文。把这个概念扩展到链表，我们就得到了今天要讨论的回文链表问题：一个链表从前往后读和从后往前读的结果是否相同。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第234题"回文链表"要求：给你一个单链表的头节点 head，请判断该链表是否为回文链表。</p>
<p>例如：</p>
<pre><code>输入：1 → 2 → 2 → 1
输出：true

输入：1 → 2 → 3 → 2 → 1
输出：true

输入：1 → 2 → 3 → 3 → 1
输出：false
</code></pre>
<h2 id="基础知识准备">基础知识准备</h2>
<p>这道题的核心是利用我们之前学过的"反转链表"。如果不熟悉链表反转，建议先复习上一篇文章。记住，链表反转是一块基石，在这里我们要用它来解决更复杂的问题。</p>
<h2 id="直观解法转换为数组">直观解法：转换为数组</h2>
<p>最简单的想法是：把链表转换成数组，然后用双指针从两端向中间移动比较。这就像把一摞扑克牌摊开在桌上，从两端开始对比每张牌是否相同。</p>
<h3 id="数组法实现">数组法实现</h3>
<pre><code class="language-java">public boolean isPalindrome(ListNode head) {
    List&lt;Integer&gt; vals = new ArrayList&lt;&gt;();
    
    // 将链表值复制到数组中
    ListNode current = head;
    while (current != null) {
        vals.add(current.val);
        current = current.next;
    }
    
    // 使用双指针判断是否回文
    int left = 0, right = vals.size() - 1;
    while (left &lt; right) {
        if (!vals.get(left).equals(vals.get(right))) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}
</code></pre>
<h2 id="优化解法反转后半部分">优化解法：反转后半部分</h2>
<p>仔细思考，我们其实不需要额外的数组。可以用这个巧妙的方法：</p>
<ol>
<li>找到链表中点</li>
<li>反转后半部分</li>
<li>比较前后两半是否相同</li>
<li>（可选）恢复链表原状</li>
</ol>
<p>这就像把一叠纸牌分成两半，把后半部分倒过来，然后一张张对比。</p>
<h3 id="寻找中点快慢指针法">寻找中点：快慢指针法</h3>
<p>想象两个人在跑道上跑步，一个速度是另一个的两倍。当快跑者跑到终点时，慢跑者正好在中点！</p>
<h3 id="详细代码实现">详细代码实现</h3>
<pre><code class="language-java">public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    
    // 第1步：找到中点
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null &amp;&amp; fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // 第2步：反转后半部分
    ListNode secondHalf = reverseList(slow.next);
    
    // 第3步：比较两半是否相同
    ListNode firstHalf = head;
    ListNode temp = secondHalf; // 保存开始位置，用于之后恢复
    boolean result = true;
    while (secondHalf != null) {
        if (firstHalf.val != secondHalf.val) {
            result = false;
            break;
        }
        firstHalf = firstHalf.next;
        secondHalf = secondHalf.next;
    }
    
    // 第4步：恢复链表（可选）
    slow.next = reverseList(temp);
    
    return result;
}

// 链表反转函数（使用我们之前学过的方法）
private ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
</code></pre>
<h3 id="图解过程">图解过程</h3>
<p>以1→2→3→2→1为例：</p>
<pre><code>1) 初始状态：
1 → 2 → 3 → 2 → 1

2) 找到中点：
1 → 2 → [3] → 2 → 1
slow指向3

3) 反转后半部分：
1 → 2 → 3 ← 2 ← 1

4) 比较两半：
(1 → 2) 和 (1 → 2) 比较

5) 恢复原状：
1 → 2 → 3 → 2 → 1
</code></pre>
<h2 id="复杂度分析">复杂度分析</h2>
<p>空间优化解法：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，只使用几个指针</li>
<li>优点：空间效率高，且思路优雅</li>
<li>缺点：修改了原链表结构（虽然最后恢复了）</li>
</ul>
<h2 id="重要思维方式总结">重要思维方式总结</h2>
<ol>
<li>
<p><strong>问题转化</strong>：将回文判断转化为对称性比较</p>
</li>
<li>
<p><strong>空间优化思维</strong>：</p>
<ul>
<li>不用额外数组存储</li>
<li>利用原有空间进行操作</li>
</ul>
</li>
<li>
<p><strong>分步思想</strong>：</p>
<ul>
<li>找中点（快慢指针）</li>
<li>反转后半段（链表反转）</li>
<li>对比（双指针）</li>
<li>恢复（再次反转）</li>
</ul>
</li>
<li>
<p><strong>边界处理</strong>：</p>
<ul>
<li>空链表</li>
<li>单节点链表</li>
<li>偶数/奇数长度的处理</li>
</ul>
</li>
</ol>
<h2 id="实用技巧总结">实用技巧总结</h2>
<p>解决类似问题的关键点：</p>
<ol>
<li>熟练掌握基础操作（如链表反转）</li>
<li>善用快慢指针找中点</li>
<li>考虑空间优化的可能性</li>
<li>注意保护原始数据结构</li>
</ol>
<p>相关的思维训练：</p>
<ul>
<li>回文数判断</li>
<li>回文子串问题</li>
<li>链表中点问题</li>
<li>链表反转的各种变体</li>
</ul>
<h2 id="小结">小结</h2>
<p>回文链表问题是一个很好的例子，展示了如何将基础算法（如链表反转、快慢指针）组合起来解决更复杂的问题。它教会我们：</p>
<ol>
<li>基础算法的重要性</li>
<li>空间优化的思维方式</li>
<li>问题分解的方法</li>
<li>代码的优雅性</li>
</ol>
<p>下次遇到类似的对称性判断问题，不要急着用额外空间，想想是否可以通过改变数据结构本身来解决问题！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0372171369814815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 21:19">2025-02-14 21:18</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18716162" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18716162);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18716162', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18716162', title: '【忍者算法】从生活场景到回文链表：探索对称性检测｜LeetCode 234 回文链表' })">举报</a>
</div>
        