
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/grey-wolf/p/18665853" title="发布于 2025-01-11 16:43">
    <span role="heading" aria-level="2">利用mybatis拦截器记录sql，辅助我们建立索引(一)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="背景">背景</h1>
<p>由于现在的工作变成了带别的小伙子一起做项目，就导致，整个项目中的代码不再全部都是自己熟悉的，可能主要是熟悉其中的部分代码。</p>
<p>但是最终项目上线，作为技术责任人，线上出任何问题，我都有责任（不管是不是我的代码）。其中，慢sql就是其中的一个风险点，解决这个风险的办法，一般就是建索引。建索引的前提是熟悉代码，熟悉代码中的sql语句是怎么写的，查询条件是怎么构造的，那么，我们在不完全掌控所有代码的情况下，怎么解决这个问题呢？</p>
<p>我以前的方式是，使用阿里的druid数据库连接池，这个连接池自带一个web页面，上面可以看到执行了哪些sql，我就根据sql去建立索引。</p>
<p>由于目前的项目中，主要使用spring boot自带的HikariCP连接池，之前研究过一次，发现这个连接池各方面也还挺不错的，也就没有把它换成druid的想法，那，我们怎么来实现sql记录的工作呢？</p>
<p>想必你猜到了，就是用mybatis的拦截器，拦截器拦截到sql后，就记录到某处，可以是db、可以是redis，都行，记录下来后，再去分析如何建索引就行了。</p>
<p>今天这一篇，会先讲下mybatis（mybatis-plus）的大致的主流程代码（初始化、执行sql）。spring boot版本2.7，mybatis版本大致如下：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111621512.png" alt="image-20250111162136395" loading="lazy"></p>
<h1 id="mybatis-mapper初始化过程">mybatis mapper初始化过程</h1>
<h2 id="mapperscan注解处理器">MapperScan注解处理器</h2>
<p>趁着这次写文章，把代码流程看了下，这里也记录下。</p>
<p>一般来说，现在都是spring boot集成mybaits或mybatis plus，在main类中，会注解：</p>
<pre><code>import org.mybatis.spring.annotation.MapperScan;

@MapperScan({"com.xxx.platform.mapper"})
@@SpringBootApplication
public class AdminBootstrap {
</code></pre>
<p>MapperScan定义如下：</p>
<pre><code class="language-shell">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(MapperScannerRegistrar.class)
@Repeatable(MapperScans.class)
public @interface MapperScan
</code></pre>
<p>其中的@Import(MapperScannerRegistrar.class)，会来解析MapperScan注解：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111245226.png" alt="image-20250111124507024" loading="lazy"></p>
<p>这里解析了MapperScan注解后，会注册一个类型为MapperScannerConfigurer的bean。</p>
<h2 id="mapperscannerconfigurer">MapperScannerConfigurer</h2>
<pre><code class="language-shell">package org.mybatis.spring.mapper;

public class MapperScannerConfigurer
    implements BeanDefinitionRegistryPostProcessor
</code></pre>
<p>这个类的介绍是：</p>
<pre><code class="language-shell">searches recursively starting from a base package for interfaces and registers them as MapperFactoryBean.
</code></pre>
<p>递归搜索base package包名下的接口，并把他们注册为bean（工厂bean，类型为MapperFactoryBean）</p>
<p>它是在什么时机来做这个事呢，它实现了BeanDefinitionRegistryPostProcessor.，这个后置处理器是在没有任何bean开始创建前，允许大家注册更多的bean definition进去，或者对已有的beandefinition进行修改。</p>
<p>它的逻辑就是扫描指定包下的mapper接口，注册为bean：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111252367.png" alt="image-20250111125256257" loading="lazy"></p>
<p>注意这个ClassPathMapperScanner，它是继承了spring自带的扫描器ClassPathBeanDefinitionScanner，做了一点定制化的事，比如，某个包名下的类假设有100个，但其实不是所有的类都是我们的mapper，我们这里就可以自己定义如何识别，比如实现了某个markerInterface才算：</p>
<blockquote>
<p>A ClassPathBeanDefinitionScanner that registers Mappers by basePackage, annotationClass, or markerInterface.</p>
</blockquote>
<p>简单来说，对于一个简单的mapper接口：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111300973.png" alt="image-20250111130024871" loading="lazy"></p>
<p>在扫描成bean definition后，定义如下：</p>
<p>bean class为工厂bean类型，要获取具体的bean，还需要调用getObject方法来生产。</p>
<pre><code class="language-shell">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt;{

}
</code></pre>
<p>这个bean中有几个主要的属性：</p>
<p>1、mapper class：</p>
<pre><code>private Class&lt;T&gt; mapperInterface;
</code></pre>
<p>这个属性就是对应的业务的mapper类，如我这里的<code>com.xxx.platform.mapper.EntityBusinessDetailInfoMapper</code></p>
<p>2、SqlSessionTemplate</p>
<p>由于该类型继承了SqlSessionDaoSupport，而SqlSessionDaoSupport中有如下定义：</p>
<pre><code class="language-shell">public abstract class SqlSessionDaoSupport extends DaoSupport {

  private SqlSessionTemplate sqlSessionTemplate;
</code></pre>
<p>这个SqlSessionTemplate是什么呢，其实里面封装了SqlSessionFactory：</p>
<pre><code class="language-java">  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
      this.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);
  }
</code></pre>
<pre><code class="language-java">  protected SqlSessionTemplate createSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    return new SqlSessionTemplate(sqlSessionFactory);
  }
</code></pre>
<h2 id="mapperfactorybean的创建">MapperFactoryBean的创建</h2>
<p>启动过程中，由于我们的mapper一般被autowired到其他的bean中，此时，就需要先完成mapper bean的创建。</p>
<p>我们前面说了，mapper bean的实际类型为MapperFactoryBean，所以实际的创建也很简单，new一个MapperFactoryBean就行了。</p>
<p>new完后，spring会帮我们注入属性，如上面的mapperInterface、SqlSessionTemplate；注入SqlSessionTemplate是通过方法setSqlSessionFactory完成的（set方法默认会被认为是属性注入）。</p>
<p>此时，就会去spring bean中查找SqlSessionFactory类型的bean。</p>
<h3 id="sqlsessionfactory-bean的创建">SqlSessionFactory bean的创建</h3>
<p>在使用了mybatis plus的starter情况下，默认就会注册SqlSessionFactory类型的bean：</p>
<pre><code class="language-shell">com.baomidou.mybatisplus.autoconfigure.MybatisPlusAutoConfiguration#sqlSessionFactory
</code></pre>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111318707.png" alt="image-20250111131826573" loading="lazy"></p>
<p>这里还标红了一处，这就是后续要说的mybatis拦截器：</p>
<pre><code class="language-java">import org.apache.ibatis.plugin.Interceptor;

private final Interceptor[] interceptors;

if (!ObjectUtils.isEmpty(this.interceptors)) {
    factory.setPlugins(this.interceptors);
}
</code></pre>
<p>在完成上述的SqlSessionFactory创建后，被注入到MapperFactoryBean中：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111354548.png" alt="image-20250111135451418" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111355818.png" alt="image-20250111135532729" loading="lazy"></p>
<p>最终也就完成了SqlSessionTemplate的创建，这个SqlSessionTemplate是如下mybatis-spring.jar中的，说白了，就是spring去集成mybatis时，封装了一层，用户只需要使用SqlSessionTemplate即可：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111357805.png" alt="image-20250111135747700" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111356551.png" alt="image-20250111135644460" loading="lazy"></p>
<h2 id="mapperfactorybeangetobject">MapperFactoryBean.getObject</h2>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111400455.png" alt="image-20250111140047364" loading="lazy"></p>
<pre><code class="language-java">public SqlSession getSqlSession() {
  return this.sqlSessionTemplate;
}
</code></pre>
<p>这里其实就是调用：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111414421.png" alt="image-20250111141447278" loading="lazy"></p>
<p>这里的getConfiguration，也是调用底层mybatis的sqlSessionFactory的configuration：</p>
<pre><code class="language-java">  public Configuration getConfiguration() {
    return this.sqlSessionFactory.getConfiguration();
  }
</code></pre>
<p>而在下述调用getMapper时：</p>
<pre><code class="language-java">org.mybatis.spring.SqlSessionTemplate#getMapper
    
public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
    return getConfiguration().getMapper(type, this);
}

</code></pre>
<p>上面可以看到，传下面方法的第二个入参时，把当前对象this传入了，诶，当前不是SqlSessionTemplate吗？</p>
<p>仔细一看，原来是实现了SqlSession接口的：</p>
<p><code>public class SqlSessionTemplate implements SqlSession</code></p>
<p>在系统没使用mybatis-plus的情况下，是会执行如下方法：</p>
<pre><code class="language-java">org.apache.ibatis.session.Configuration#getMapper
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
	return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre>
<p>由于我这边集成的是mybatis-plus，实际执行了如下方法：</p>
<pre><code class="language-java">com.baomidou.mybatisplus.core.MybatisConfiguration#getMapper

public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mybatisMapperRegistry.getMapper(type, sqlSession);
}
</code></pre>
<p>其实，也就是mybatis-plus，把原来mybatis的configuration换成了自己的MybatisConfiguration（继承了原来的），道理还是相通的：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111428165.png" alt="image-20250111142838054" loading="lazy"></p>
<p>我们继续看上面的方法：</p>
<pre><code class="language-shell">com.baomidou.mybatisplus.core.MybatisConfiguration#getMapper

public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mybatisMapperRegistry.getMapper(type, sqlSession);
}
</code></pre>
<p>mybatisMapperRegistry也被换成了mybatis-plus的<code>com.baomidou.mybatisplus.core.MybatisMapperRegistry</code></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111434591.png" alt="image-20250111143441493" loading="lazy"></p>
<p>这个类，看名字就能猜到，里面是注册了所有的mapper类型。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111436786.png" alt="image-20250111143606672" loading="lazy"></p>
<p>所以，如下代码也就是从上述的map中，根据mapper的class类型，获取到一个MybatisMapperProxyFactory对象。</p>
<pre><code class="language-java">mybatisMapperRegistry.getMapper(type, sqlSession)
</code></pre>
<p>这个MybatisMapperProxyFactory也是从mybatis中扩展来的：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111437127.png" alt="image-20250111143736011" loading="lazy"></p>
<p>获取到MybatisMapperProxyFactory后，接下来就是调用它的如下newInstance方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111438238.png" alt="image-20250111143842128" loading="lazy"></p>
<p>newInstance如下：</p>
<pre><code class="language-java">public T newInstance(SqlSession sqlSession) {
    final MybatisMapperProxy&lt;T&gt; mapperProxy = new MybatisMapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
}
</code></pre>
<p>上述方法，先是new了一个MybatisMapperProxy对象，传入了sqlSession、mapperInterface等。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111440768.png" alt="image-20250111144052653" loading="lazy"></p>
<p>接下来，如下2处代码，会生成一个mapper接口的jdk动态代理，代理的invocationHandler就是创建的MybatisMapperProxy对象：</p>
<pre><code class="language-java">public T newInstance(SqlSession sqlSession) {
    final MybatisMapperProxy&lt;T&gt; mapperProxy = new MybatisMapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
    // 2
    return newInstance(mapperProxy);
}
protected T newInstance(MybatisMapperProxy&lt;T&gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy);
}
</code></pre>
<p>到此为止，mapper接口的动态代理就算是生成了。</p>
<h2 id="过程总结">过程总结</h2>
<p>简单来说，在MapperScan的处理过程中，在指定包名下扫到了n个mapper.java，注册为bean，bean类型为MapperFactoryBean。</p>
<p>在创建完MapperFactoryBean后，初始化的过程中，要注入属性，属性中包括SqlSessionFactory 等，此时就会先去spring中查找SqlSessionFactory bean的definition，然后实例化、初始化，完成后，放到spring中。</p>
<p>接下来，SqlSessionFactory 被注入到MapperFactoryBean 中，工厂bean就算创建完成。</p>
<p>接下来，调用MapperFactoryBean 工厂bean的getObject方法，生成每个mapper接口对应的bean。</p>
<p>此处最终会创建一个动态代理对象，invocationHandler类型为：MybatisMapperProxy。</p>
<p>我们下图可以看到，一个具体的mapper，它是一个动态代理类型，其中包含一个MybatisMapperProxy类型的属性：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111454388.png" alt="image-20250111145404252" loading="lazy"></p>
<h1 id="mapper执行过程">mapper执行过程</h1>
<h2 id="sqlsessionproxy">sqlSessionProxy</h2>
<p>在执行mapper中的业务方法的过程中，由于mapper这个动态代理对象中的invocationHandler是MybatisMapperProxy（mybatis-plus包中），所以自然是先在mybatis-plus包中的类溜达了一会，然后，还是开始调用spring-mybatis jar包中的SqlSessionTemplate来实现底层逻辑：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111500307.png" alt="image-20250111150008165" loading="lazy"></p>
<p>在SqlSessionTemplate执行方法时，没想到，还要交给另一个对象sqlSessionProxy来执行：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111507162.png" alt="image-20250111150738022" loading="lazy"></p>
<p>这个sqlSessionProxy是一个jdk动态代理对象，代理了SqlSession接口（SqlSessionTemplate是实现了该接口的）中的方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111509561.png" alt="image-20250111150909453" loading="lazy"></p>
<p>为什么要代理给这样一个对象呢？</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111511985.png" alt="image-20250111151119859" loading="lazy"></p>
<p>这里意思是，主要的考虑就是获取SqlSession要结合spring的事务来获取，比如，开启事务的时候，底层需要保证一直使用同一个数据库连接，在同一个连接上进行sql操作、事务开启和回滚，所以，一般开启事务后，第一个sql获取到数据库连接（对应到上层就是一个session）后，存储到线程局部变量中；后续都一直从线程局部变量中获取。</p>
<p>如下：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111516746.png" alt="image-20250111151655621" loading="lazy"></p>
<h2 id="sessionfactoryopensession">sessionFactory.openSession</h2>
<p>由于我们是第一次调用，此时没有会话存储在线程局部变量中，因此需要新建一个session。</p>
<p>此时，就调用到了mybatis这一层。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111521215.png" alt="image-20250111152117113" loading="lazy"></p>
<pre><code class="language-java">  public SqlSession openSession(ExecutorType execType) {
    return openSessionFromDataSource(execType, null, false);
  }
</code></pre>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111524186.png" alt="image-20250111152412046" loading="lazy"></p>
<p>上述看到，会先创建一个Executor，再创建一个DefaultSqlSession。</p>
<p>这个executor类型有三种：</p>
<pre><code class="language-java">public enum ExecutorType {
  SIMPLE, REUSE, BATCH
}
</code></pre>
<p>这几种具体类型，我也并没有深入了解，可以看出，BATCH是批量操作相关的，应该是提高性能。</p>
<p>在创建完成后，会尝试调用org.apache.ibatis.plugin.InterceptorChain#pluginAll，试图对Executor进行jdk动态代理，代理后，调用方法时，都会先进入拦截器链，在拦截器链中执行完成后，才会继续原有的方法执行：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111530143.png" alt="image-20250111152846981" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111531564.png" alt="image-20250111153109458" loading="lazy"></p>
<p>此处我们先不深入拦截器链的创建。</p>
<h2 id="session执行sql">session执行sql</h2>
<h3 id="创建statementhandler">创建statementHandler</h3>
<p>获取完成session后，会继续如下处理，进行方法调用：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111536192.png" alt="image-20250111153607052" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111537920.png" alt="image-20250111153701786" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111538291.png" alt="image-20250111153838158" loading="lazy"></p>
<p>如下获取到对应的statement，传入参数：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111539460.png" alt="image-20250111153917357" loading="lazy"></p>
<p>下图中，获取到boundSql后，其中就包含了完整sql（已完成parameter的拼接）：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111549104.png" alt="image-20250111154922966" loading="lazy"></p>
<p>接下来，会执行到如下代码：</p>
<pre><code class="language-java">@Override
  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      // 1
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      // 2
      stmt = prepareStatement(handler, ms.getStatementLog());
      // 3
      return handler.query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
</code></pre>
<h3 id="1处创建statementhandler">1处，创建statementHandler</h3>
<pre><code class="language-java">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
  // 1.1
  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
  // 1.2
  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
  return statementHandler;
}
</code></pre>
<p>上图的1.1处，如下，判断是预编译语句还是普通语句或者是存储过程：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111557745.png" alt="image-20250111155721614" loading="lazy"></p>
<p>在new PreparedStatementHandler的过程中，还会创建parameterHandler/resultSetHandler</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111558530.png" alt="image-20250111155833386" loading="lazy"></p>
<h4 id="创建parameterhandler">创建parameterHandler</h4>
<pre><code class="language-java">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
  // 尝试进行拦截器链代理
  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
  return parameterHandler;
}
</code></pre>
<p>这里创建具体的ParameterHandler，并进行拦截器链代理。</p>
<h4 id="创建resultsethandler">创建resultsetHandler</h4>
<pre><code class="language-java">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
      ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
  }
</code></pre>
<p>创建结果集handler，并进行拦截器链代理。</p>
<h3 id="2处使用statementhandler创建statement">2处，使用statementHandler创建statement</h3>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111605405.png" alt="image-20250111160541264" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111606496.png" alt="image-20250111160603385" loading="lazy"></p>
<h3 id="statement执行">statement执行</h3>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111607492.png" alt="image-20250111160706371" loading="lazy"></p>
<p>至此，执行过程基本结束了。</p>
<h1 id="拦截器链作用的部分">拦截器链作用的部分</h1>
<p>在上述源码过程中，有4处，拦截器链对这些生成的对象进行了代理，代理后，这些对象的方法在执行时，就会先进入拦截器。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111610082.png" alt="image-20250111161027970" loading="lazy"></p>
<p>这几个接口中的方法，都有可能被拦截，具体取决于，拦截器中配置了要拦截哪些方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111611403.png" alt="image-20250111161120295" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111611021.png" alt="image-20250111161151910" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111612381.png" alt="image-20250111161222263" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111612844.png" alt="image-20250111161241733" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p>mybatis和spring的代码，结合得还是很紧密，有时候会弄混其中的边界，今天也算是简单理了下。</p>
<p>druid、HikariCP这些，算是底层，是datasource一层，mybatis要依赖这一层；</p>
<p>mybatis对外：SqlSessionFactory、SqlSession；</p>
<p>spring呢，使用sqlSessionTemplate（mybatis-spring-xxx.jar）去封装了mybatis的上述两个概念，主要是综合考虑了spring的事务。</p>
<p>mybatis-plus呢，替换了mybatis原本的SqlSessionFactory（其他方面的还没太研究），另一方面，继续封装，上层只需要使用mybatis-plus即可。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.39907789028125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-11 16:43">2025-01-11 16:43</span>&nbsp;
<a href="https://www.cnblogs.com/grey-wolf">三国梦回</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18665853" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18665853);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18665853', targetLink: 'https://www.cnblogs.com/grey-wolf/p/18665853', title: '利用mybatis拦截器记录sql，辅助我们建立索引(一)' })">举报</a>
</div>
        