
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/19042708" title="发布于 2025-08-18 07:45">
    <span role="heading" aria-level="2">Java 集合--快速掌握涵盖三大场景实现的Set集合底层原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>掌握Map集合相当于同时掌握了Set集合。</p>
<p>Set集合底层实现--委派成员变量Map集合完成具体实现。</p>
</blockquote>
<h2 id="set-集合概览">Set 集合概览</h2>
<p>在 Java 集合框架中，<strong>Set</strong> 表示<strong>不包含重复元素</strong>的集合类型。</p>
<p>本文讲解三种常用实现：<code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816215857926-1446255400.png" alt="Set集合" loading="lazy"></p>
<h3 id="1-set-接口概述">1. Set 接口概述</h3>
<p><strong>定义</strong>：<code>java.util.Set&lt;E&gt;</code> 继承自 <code>Collection&lt;E&gt;</code>，用于存储无重复元素的集合。</p>
<p><strong>核心特性</strong>：元素唯一性。</p>
<p><strong>常见操作</strong>：</p>
<ul>
<li><code>add(E e)</code>、<code>remove(Object o)</code>、<code>contains(Object o)</code></li>
<li>批量操作：<code>addAll</code>、<code>removeAll</code>、<code>retainAll</code></li>
<li>遍历：增强 for、迭代器</li>
</ul>
<h3 id="2-基本实现对比">2. 基本实现对比</h3>
<p><code>Set</code>类的这三种实现类的实现逻辑，都是通过<strong>委派给内部的<code>Map</code>集合对象</strong>来实现具体处理逻辑，完全屏蔽了调用者对<code>Set</code>集合细节的感知。</p>
<p>类似于<strong>可重入锁</strong>，在 <code>ReentrantLock</code>（或 <code>ReentrantReadWriteLock</code>）中，所有对外的方法（<code>lock()</code>、<code>unlock()</code>……）都是简单地<strong>委派给内部的 <code>Sync sync</code>（<code>FairSync</code> 或 <code>NonfairSync</code>）来执行</strong>，完全屏蔽了调用者对 <code>AQS</code> 细节的感知。</p>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>三者对比：</p>
<table>
<thead>
<tr>
<th>Set类</th>
<th>底层结构</th>
<th>特性</th>
<th>允许 null</th>
<th>迭代顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashSet</td>
<td>HashMap&lt;E,Object&gt;</td>
<td>无序、高效</td>
<td>是</td>
<td>不确定（受 hash 冲突和容量影响）</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>LinkedHashMap&lt;E,Object&gt;</td>
<td>插入顺序(无访问顺序)</td>
<td>是</td>
<td>插入顺序(无访问顺序)</td>
</tr>
<tr>
<td>TreeSet</td>
<td>TreeMap&lt;E,Object&gt;</td>
<td>有序、排序、范围操作</td>
<td>否</td>
<td>元素排序顺序</td>
</tr>
</tbody>
</table>
<h2 id="2-hashset-集合">2 HashSet 集合</h2>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816223505181-590974033.jpg" alt="HashSet的数据结构" loading="lazy"></p>
<h3 id="21-底层数据结构">2.1. 底层数据结构</h3>
<p>底层维护一个 <code>HashMap&lt;E, Object&gt;</code>，实际的<code>value</code>值为静态常量 <code>PRESENT</code>，这样Set集合的所有<code>key</code>指向同一个静态常量<code>PRESENT</code>，避免浪费内存空间。</p>
<pre><code class="language-java">private transient HashMap&lt;E,Object&gt; map;

private static final Object PRESENT = new Object();

public HashSet() {
	map = new HashMap&lt;&gt;();
}

public boolean add(E e) {
	return map.put(e, PRESENT)==null;
}
</code></pre>
<p><code>HashSet</code>委派成员变量<code>HashMap</code> 来完成底层实现，在整个类的实现中，只需要关注<code>HashMap</code>的key如何处理即可。</p>
<p>比如，Set集合迭代的过程只需要迭代key即可</p>
<pre><code class="language-java">public Iterator&lt;E&gt; iterator() {
	return map.keySet().iterator();
}
</code></pre>
<h3 id="22-应用与注意">2.2. 应用与注意</h3>
<p><strong>适用场景</strong>：快速去重、大量元素的快速查找。</p>
<p><strong>注意点</strong>：集合元素的类需要实现<code>hashCode</code>和<code>equals</code>方法，这跟HashMap的key对象特性一致。</p>
<p>学习<code>HashSet</code>前，可以先掌握<code>HashMap</code>。往期文章可视化的讲过了<code>HashMap</code>集合。</p>
<h2 id="3-linkedhashset-详解">3 LinkedHashSet 详解</h2>
<p><code>LinkedHashSet</code> 继承于<code>HashSet</code>，<code>LinkedHashSet</code>所有构造方法都是使用父类来完成对象创建，源码如下：</p>
<pre><code class="language-java">public class LinkedHashSet&lt;E&gt;
    extends HashSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {

	...
	
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }
	
	...
}

public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{
	
	...
	
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
    }
	
	...
}
</code></pre>
<p>细心的会发现，构成方法中有个参数<code>boolean dummy</code>，是没有被使用到的！！<strong>这很重要</strong>！！</p>
<p>然而<code>LinkedHashSet</code> 所有构造方法都是调用<code>HashSet(int initialCapacity, float loadFactor, boolean dummy)</code> 来完成对象实例化的，也就是说<code>LinkedHashSet</code>无法通过构造方法使用<code>LinkedHashMap</code>集合的<strong>访问顺序</strong>，也无法直接实现<code>LRU</code>缓存，因为默认<code>accessOrder</code>始终为<code>false</code>，并且也无法指定<code>accessOrder</code>为true。</p>
<pre><code class="language-java">public LinkedHashMap(int initialCapacity, float loadFactor) {
	super(initialCapacity, loadFactor);
	accessOrder = false;
}
</code></pre>
<p>但是<code>LinkedHashSet</code>构造方法默认都给了个<code>true</code>，<strong>有点迷惑人的设计和默认值</strong>。尽管他在方法上做了说明：<code>@param dummy被忽略（区分这一点）</code>。</p>
<p><strong>为什么不需要访问顺序特性？</strong></p>
<p>Set集合并不需要这种“最近用过”的跟踪——它们只需要保证不重复，或者按插入顺序迭代就够了。并且Set集合没有提供get方法访问元素，不存咋访问这个概念，也就不需要访问顺序这个特性。Set集合不像List集合那样可以根据下标进行随机访问方法，只能通过遍历的方式进行节点访问。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816223542114-1946910693.jpg" alt="LinkedHashSet数据结构双链表关系" loading="lazy"></p>
<h3 id="31-底层数据结构">3.1. 底层数据结构</h3>
<p><code>LinkedHashSet</code>本质基于 <code>LinkedHashMap</code>，内部每个节点有 <code>before</code>/<code>after</code> 双向链指针，维护插入顺序。</p>
<p><code>LinkedHashSet</code> 的构造器<strong>只接受初始容量和加载因子</strong>，它内部使用的是默认的插入顺序的 <code>LinkedHashMap</code>，<strong>并不提供切换到访问顺序</strong>的选项，构造时不可指定 <code>accessOrder</code> 为 <code>true</code>。</p>
<p><strong>每个节点的内部结构为</strong>：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816223603512-670682770.jpg" alt="数据结构简图" loading="lazy"></p>
<h3 id="32-如何实现linkedhashset集合的lru-缓存">3.2. 如何实现<code>LinkedHashSet</code>集合的LRU 缓存？</h3>
<p>构造时不可指定 <code>accessOrder</code> 为 <code>true</code>，默认只有插入顺序。那只能“曲线救国”，使用<code>Collections.newSetFromMap</code>来创建Set集合。</p>
<p>如果需要“按访问顺序”并自动淘汰最老元素（LRU），可以基于 <code>LinkedHashMap</code>＋<code>Collections.newSetFromMap(...)</code> 来实现一个带缓存特性的 <code>Set</code>。</p>
<p>以下是通过<code>LinkedHashMap</code>集合实现的自定义LRU 缓存：</p>
<pre><code class="language-java">// 按访问顺序
Set&lt;String&gt; lruSet = Collections.newSetFromMap(
		new LinkedHashMap&lt;String, Boolean&gt;(16, 0.75f, true) { // accessOrder = true
			@Override
			protected boolean removeEldestEntry(Map.Entry&lt;String, Boolean&gt; eldest) {
				return size() &gt; 4;
			}
		}
);
lruSet.add("A");
lruSet.add("B");
lruSet.add("C");
lruSet.add("D");
lruSet.add("E"); // A 会被移除
System.out.println(lruSet); // 执行结果：[B, C, D, E]
</code></pre>
<h3 id="33-场景与性能">3.3. 场景与性能</h3>
<p><strong>适用场景</strong>：需要既去重，又按插入顺序遍历</p>
<p><strong>性能开销</strong>：比 <code>HashSet</code> 多维护链表指针，插入/删除略慢</p>
<p><strong>注意点</strong>：</p>
<ul>
<li>集合元素的类需要实现<code>hashCode</code>和<code>equals</code>方法，这跟LinkedHashMap的key对象特性一致；</li>
<li>构造时不可指定 <code>accessOrder</code> 为 <code>true</code>，默认只有插入顺序。</li>
</ul>
<h2 id="4-treeset-详解">4 TreeSet 详解</h2>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816223747563-40846708.jpg" alt="TreeSet数据结构--红黑树" loading="lazy"></p>
<h3 id="41-底层结构与红黑树特性">4.1 底层结构与红黑树特性</h3>
<p><code>TreeSet</code>本质基于 <code>TreeMap&lt;E, Object&gt;</code>，红黑树保证插入/删除后的平衡性。</p>
<p><code>TreeSet</code>的特性与<strong>红黑树特性</strong>一致，</p>
<p><strong>每个红黑树节点的内部结构为</strong>：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202508/1209017-20250816223832685-1670564707.jpg" alt="TreeSet数据结构" loading="lazy"></p>
<h3 id="42-排序与范围操作示例">4.2 排序与范围操作示例</h3>
<pre><code class="language-java">TreeSet&lt;String&gt; tree = new TreeSet&lt;&gt;(Arrays.asList("C", "A", "B", "D"));
System.out.println(tree);// 自然排序：[A, B, C, D]

TreeSet&lt;String&gt; desc = new TreeSet&lt;&gt;(Comparator.reverseOrder());
desc.addAll(tree);
System.out.println(desc);// 反序：[D, C, B, A]

// 范围视图
SortedSet&lt;String&gt; range = tree.subSet("B", true, "D", false);
System.out.println(range);// 包含 B，不包含 D：结果 [B, C]
</code></pre>
<h3 id="43-场景与注意">4.3 场景与注意</h3>
<p><strong>适用场景</strong>：需要有序集合、区间查询、按顺序访问元素。</p>
<p><strong>注意点</strong>：</p>
<ul>
<li>
<p>元素类型必须实现 <code>Comparable</code> 或通过构造方法提供自定义比较器 <code>Comparator</code>。</p>
</li>
<li>
<p>不支持 <code>null</code>，否则抛 <code>NullPointerException</code>。</p>
</li>
</ul>
<h2 id="4-三者详细对比">4. 三者详细对比</h2>
<p>下面从底层数据结构、迭代顺序、主要操作性能、内存开销、空元素支持、典型场景等维度，对比 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 三种常用 <code>Set</code> 实现：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>HashSet</th>
<th>LinkedHashSet</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>底层结构</strong></td>
<td>哈希表（数组 + 链表/红黑树）</td>
<td>哈希表 + 双向链表</td>
<td>红黑树（Self‑balancing BST）</td>
</tr>
<tr>
<td><strong>迭代顺序</strong></td>
<td>无序</td>
<td><strong>插入顺序</strong></td>
<td><strong>排序顺序</strong>（自然顺序或自定义 Comparator）</td>
</tr>
<tr>
<td><strong>add / remove / contains</strong></td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td><strong>iteration（遍历）</strong></td>
<td>O(n)，顺序不确定</td>
<td>O(n)，按照插入顺序</td>
<td>O(n)，按照排序顺序</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>最小（仅哈希桶 + 链表/树节点）</td>
<td>略高（每个节点多维护前后指针）</td>
<td>最高（树节点需维护父/左右子指针及颜色信息）</td>
</tr>
<tr>
<td><strong>null 支持</strong></td>
<td>支持一个 <code>null</code></td>
<td>支持一个 <code>null</code></td>
<td>不支持 <code>null</code>（会抛 NPE）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要最快速的无序去重</td>
<td>需要去重，并保持元素插入顺序</td>
<td>需要去重，并有序访问或范围查询（如子集、headSet、tailSet）</td>
</tr>
<tr>
<td><strong>访问顺序（LRU）</strong></td>
<td>不支持</td>
<td>不支持（只能保持<strong>插入</strong>顺序）</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>子集/范围操作</strong></td>
<td>不提供</td>
<td>不提供</td>
<td>支持 <code>subSet</code>、<code>headSet</code>、<code>tailSet</code> 等导航方法</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>这三者同属 <code>Set</code> 家族，共享“<strong>无重复元素</strong>”、高效去重的核心特性，又各司其职、在“顺序”与“性能”上做出不同取舍。Set集合底层通过委派成员变量Map集合完成具体实现，但特性稍有差异，使用时需要注意。如果没有掌握Map集合的，建议先把Map集合的<code>HashMap</code>，<code>LinkedHashMap</code>和<code>TreeMap</code>都学习一遍，关于这块的知识，之前已经通过可视化的方式分享过，感兴趣的可以前往学习。</p>
<h2 id="往期推荐">往期推荐</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>往期文章</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java集合底层原理可视化</td>
<td><a href="https://mp.weixin.qq.com/s/jKt7IidUNDh8N0INrqsV3A" target="_blank" rel="noopener nofollow">ArrayDeque双端队列--底层原理可视化</a><br><a href="https://mp.weixin.qq.com/s/KmMhSDt4DH98-pHFFkXWgg" target="_blank" rel="noopener nofollow">“子弹弹夹”装弹和出弹的抽象原理实战：掌握栈的原理与实战</a><br><a href="https://mp.weixin.qq.com/s/sHl-skrq5zIZihtcxfQE4g" target="_blank" rel="noopener nofollow">TreeMap集合--底层原理、源码阅读及它在Java集合框架中扮演什么角色？</a><br><a href="https://mp.weixin.qq.com/s/bLNWiluCExxzsEcrPYZtBg" target="_blank" rel="noopener nofollow">LinkedHashMap集合--原理可视化</a><br><a href="https://mp.weixin.qq.com/s/cbXqfEhKBn-fbR-7laMnKQ" target="_blank" rel="noopener nofollow">HashMap集合--基本操作流程的源码可视化</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486835&amp;idx=1&amp;sn=9f61a14e91141059c95efa300266f87e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合--HashMap底层原理可视化，秒懂扩容、链化、树化</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486816&amp;idx=1&amp;sn=81e12bd3920c4ca68afd659e93d62a41&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合--从本质出发理解HashMap</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486793&amp;idx=1&amp;sn=b738749f16e5fcdad26e3874fc388444&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合--LinkedList源码可视化</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486763&amp;idx=1&amp;sn=214926d8cfaba2cada66106f26918764&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合源码--ArrayList的可视化操作过程</a></td>
</tr>
<tr>
<td>设计模式秘籍<br>（已全部开源）</td>
<td><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486720&amp;idx=1&amp;sn=739bdfc99dc52128f9d9eb31a70a4c03&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式的两个秘籍</a><br>往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></td>
</tr>
<tr>
<td>软件设计师</td>
<td><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></td>
</tr>
<tr>
<td>Java学习路线<br>和相应资源</td>
<td><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></td>
</tr>
</tbody>
</table>
<p>原创不易，觉得还不错的，三连支持：点赞、分享、推荐↓</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-18 07:46">2025-08-18 07:45</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19042708);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19042708', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/19042708', title: 'Java 集合--快速掌握涵盖三大场景实现的Set集合底层原理' })">举报</a>
</div>
        