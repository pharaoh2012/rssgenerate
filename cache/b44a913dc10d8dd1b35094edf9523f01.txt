
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/codegb/p/18810662" title="发布于 2025-04-05 23:00">
    <span role="heading" aria-level="2">从零开始：在Qt中使用OpenGL绘制指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文详解如何通过Qt的QOpenGLWidget和QOpenGLFunctions实现跨平台GPU渲染，以绘制三角形为例。从OpenGL函数跨平台加载原理切入，解析Qt对底层API的封装价值，逐步讲解顶点缓冲、着色器编译及渲染流程，提供完整代码和常见问题解决思路，助力开发者高效降低CPU负载，掌握Qt与OpenGL整合的核心实践。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文只介绍基本的 QOpenGLWidget 和 QOpenGLFunctions 的使用，想要学习 OpenGL 的朋友，建议访问经典 OpenGL 学习网站：<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener nofollow">LearnOpenGL CN</a></p>
</blockquote>
<p>本篇文章，我们将以绘制一个经典的三角形为例，讲一讲，怎么在 Qt 中使用 OpenGL 来进行 GPU 绘制。</p>
<h2 id="前言">前言</h2>
<p>在高性能渲染场景中，CPU资源常被过度消耗，导致界面卡顿。而OpenGL作为业界标准的图形API，能通过GPU硬件加速显著降低CPU负载。本文将以绘制三角形为例，教你如何通过Qt的QOpenGLWidget和QOpenGLFunctions实现跨平台GPU渲染。</p>
<h2 id="qopenglfunctions">QOpenGLFunctions</h2>
<p><font style="color: rgba(64, 64, 64, 1)">OpenGL函数在不同平台（Windows/Linux/Mac）的实现存在差异。例如：</font></p>
<table>
<thead>
<tr>
<th><strong>平台</strong></th>
<th><strong>函数加载方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><font style="color: rgba(64, 64, 64, 1)">Windows</font></td>
<td><code>wglGetProcAddress</code></td>
</tr>
<tr>
<td><font style="color: rgba(64, 64, 64, 1)">Linux</font></td>
<td><code>glXGetProcAddress</code></td>
</tr>
</tbody>
</table>
<p><font style="color: rgba(64, 64, 64, 1)">Qt通过</font><code>QOpenGLFunctions</code><font style="color: rgba(64, 64, 64, 1)">封装了这些底层差异，开发者只需继承此类，即可用</font><code>glClear()</code><font style="color: rgba(64, 64, 64, 1)"> 等统一接口调用OpenGL函数，无需编写平台特定代码。通过这样，我们就可以用一套代码，在不同平台下使用 OpenGL 相。要使用这个类也很简单，让我们的类直接继承 </font><code>QOpenGLFuntions</code><font style="color: rgba(64, 64, 64, 1)"> 就好了。同时也可以配合 </font><code>QOpenGLWidget</code><font style="color: rgba(64, 64, 64, 1)"> 来使用，在 </font><code>initializeGL</code><font style="color: rgba(64, 64, 64, 1)"> 函数里，调用 </font><code>initializeOpenGLFunctions</code><font style="color: rgba(64, 64, 64, 1)"> 后，就可以</font><strong>直接使用 OpenGL 的函数</strong><font style="color: rgba(64, 64, 64, 1)">。</font></p>
<h3 id="windows-下加载wglgetprocaddress"><font style="color: rgba(64, 64, 64, 1)">Windows 下加载（</font><code>wglGetProcAddress</code><font style="color: rgba(64, 64, 64, 1)">）</font></h3>
<p><font style="color: rgba(64, 64, 64, 1)">例如在 Windows 下，我们使用 </font><code>wglGetProcAddress</code><font style="color: rgba(64, 64, 64, 1)">来动态加载这些函数（例如 </font><code>glClear</code><font style="color: rgba(64, 64, 64, 1)">），下面是加载代码：</font></p>
<ul>
<li>
<p><strong><font style="color: rgba(64, 64, 64, 1)">包含必要的头文件</font></strong></p>
<pre><code class="language-cpp">#include &lt;windows.h&gt;
#include &lt;GL/gl.h&gt;
#include &lt;GL/glext.h&gt;  // 提供 OpenGL 扩展声明
</code></pre>
</li>
<li>
<p><strong><font style="color: rgba(64, 64, 64, 1)">定义函数指针类型</font></strong></p>
<pre><code class="language-cpp">// 示例：定义 glClear 的函数指针类型
typedef void (APIENTRY *PFNGLCLEARPROC)(GLbitfield);
PFNGLCLEARPROC glClear;
</code></pre>
</li>
<li>
<p><strong><font style="color: rgba(64, 64, 64, 1)">加载 OpenGL 函数</font></strong></p>
<pre><code class="language-cpp">// 初始化 OpenGL 函数
void initOpenGLFunctions() {
    // 1. 加载 OpenGL 1.1 函数（由 opengl32.dll 提供）
    glClear = (PFNGLCLEARPROC)wglGetProcAddress("glClear");

    // 2. 检查是否加载成功
    if (!glClear) {
        // 如果失败，可能是驱动不支持该函数
        MessageBoxA(NULL, "Failed to load glClear", "Error", MB_OK);
        exit(1);
    }

    // 3. 类似方式加载其他函数...
    // glDrawArrays = (PFNGLDRAWARRAYSPROC)wglGetProcAddress("glDrawArrays");
    // ...
}
</code></pre>
</li>
<li>
<p><strong><font style="color: rgba(64, 64, 64, 1)">使用加载的函数</font></strong></p>
<pre><code class="language-cpp">glClear(GL_COLOR_BUFFER_BIT);  // 现在可以正常调用
</code></pre>
</li>
</ul>
<h3 id="linux-下加载glxgetprocaddress-">Linux 下加载（<code>glXGetProcAddress</code><font style="color: rgba(64, 64, 64, 1)"> </font>）</h3>
<p>而在 linux 下，加载的函数变成了：<code>glXGetProcAddress</code><font style="color: rgba(64, 64, 64, 1)"> ，对应的代码是：</font></p>
<ul>
<li>
<p><strong>包含必要的头文件</strong></p>
<pre><code class="language-cpp">#include &lt;GL/gl.h&gt;
#include &lt;GL/glx.h&gt;  // X11 的 OpenGL 扩展
#include &lt;GL/glext.h&gt;
</code></pre>
</li>
<li>
<p><strong>定义函数指针类型</strong></p>
<pre><code class="language-cpp">// 示例：定义 glClear 的函数指针类型
typedef void (*PFNGLCLEARPROC)(GLbitfield);
PFNGLCLEARPROC glClear;
</code></pre>
</li>
<li>
<p><strong>加载 OpenGL 函数</strong></p>
<pre><code class="language-cpp">void initOpenGLFunctions() {
    // 1. 加载 glClear
    glClear = (PFNGLCLEARPROC)glXGetProcAddress((const GLubyte*)"glClear");
    
    // 2. 检查是否加载成功
    if (!glClear) {
        fprintf(stderr, "Failed to load glClear\n");
        exit(1);
    }
    
    // 3. 类似方式加载其他函数...
    // glDrawArrays = (PFNGLDRAWARRAYSPROC)glXGetProcAddress((const GLubyte*)"glDrawArrays");
    // ...
}
</code></pre>
</li>
<li>
<p><strong>使用加载的函数</strong></p>
<pre><code class="language-cpp">glClear(GL_COLOR_BUFFER_BIT);  // 现在可以正常调用
</code></pre>
</li>
</ul>
<h2 id="qopenglwidget">QOpenGLWidget</h2>
<p><code>QOpenGLWidget</code><font style="color: rgba(64, 64, 64, 1)"> 是 Qt 提供的一个 widget 类，用于在 Qt 应用程序中嵌入 OpenGL 渲染内容。它继承自 </font><code>QWidget</code><font style="color: rgba(64, 64, 64, 1)">，内部管理了一个 OpenGL 上下文（例如 windows 下调用 </font><code>wglMakeCurrent</code><font style="color: rgba(64, 64, 64, 1)"> / </font><code>wglDoneCurrent</code><font style="color: rgba(64, 64, 64, 1)">）和帧缓冲区，并提供了与 Qt 窗口系统无缝集成的能力。</font>详细内容可看：<a href="https://doc.qt.io/qt-5/qopenglwidget.html" target="_blank" rel="noopener nofollow">QOpenGLWidget Class</a></p>
<p>我们可以创建自己的窗口，并继承 QOpenGLWidget，然后重写下面三个函数，来处理一些 OpenGL 相关的工作。</p>
<h3 id="initializegl">initializeGL</h3>
<p>初始化一些 OpenGL 相关的资源或者状态。<strong>这个函数在在第一次调用 <code>resizeGL</code>或者 <code>paintGL</code>之前被调用。</strong></p>
<h3 id="paintgl">paintGL</h3>
<p>渲染 OpenGL 的场景，类似于我们平常使用的 <code>QWidget::paintEvent</code>，在窗口需要更新时调用。</p>
<h3 id="resizegl">resizeGL</h3>
<p>调整 OpenGL Viewport 的大小或者投影等，在窗口需要调整大小时调用。</p>
<h2 id="完整代码">完整代码</h2>
<pre><code class="language-cpp">#pragma once

#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;

#include "FrameObserver.h"

class COpenGLRenderWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
    Q_OBJECT

public:
    explicit COpenGLRenderWidget(QWidget *parent = nullptr);
    ~COpenGLRenderWidget() override;

private:
    void InitShaders();

private:
    void initializeGL() override;
    void paintGL() override;
    void resizeGL(int w, int h) override;
    
private:
    QOpenGLShaderProgram m_shaderProgram;
    QOpenGLBuffer m_vbo;
};

</code></pre>
<pre><code class="language-cpp">#include "OpenGLRenderWidget.h"

static const GLfloat coordinateBasic[] = {
    // 顶点坐标，存储3个xyz坐标
    // x     y     z
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f,
};

constexpr auto VERTEX_SHADER_BASIC = R"(
attribute vec3 vertexIn; 
varying vec2 textureOut; 

void main(void)
{
    gl_Position = vec4(vertexIn, 1.0);
}
)";

constexpr auto FRAGMENT_SHADER_BASIC = R"(
varying vec2 textureOut;

void main(void) 
{ 
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
}
)";

COpenGLRenderWidget::COpenGLRenderWidget(QWidget *parent)
    : QOpenGLWidget(parent)
{}

COpenGLRenderWidget::~COpenGLRenderWidget()
{}

void COpenGLRenderWidget::initializeGL()
{
    initializeOpenGLFunctions();
    glDisable(GL_DEPTH_TEST);

    m_vbo.create();
    m_vbo.bind();
    m_vbo.allocate(coordinateBasic, sizeof(coordinateBasic));

    InitShaders();

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
}

void COpenGLRenderWidget::paintGL()
{
    m_shaderProgram.bind();

    glDrawArrays(GL_TRIANGLES, 0, 3);

    m_shaderProgram.release();
}

void COpenGLRenderWidget::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
    update();
}

void COpenGLRenderWidget::InitShaders()
{
    QOpenGLShader vertexShader(QOpenGLShader::Vertex);
    if (!vertexShader.compileSourceCode(VERTEX_SHADER_BASIC))
    {
        qDebug() &lt;&lt; "Vertex shader compilation failed. Error: " &lt;&lt; vertexShader.log();
        return;
    }

    QOpenGLShader fragmentShader(QOpenGLShader::Fragment);
    if (!fragmentShader.compileSourceCode(FRAGMENT_SHADER_BASIC))
    {
        qDebug() &lt;&lt; "Fragment shader compilation failed. Error: " &lt;&lt; fragmentShader.log();
        return;
    }

    m_shaderProgram.addShader(&amp;vertexShader);
    m_shaderProgram.addShader(&amp;fragmentShader);

    m_shaderProgram.link();
    m_shaderProgram.bind();

    m_shaderProgram.setAttributeBuffer("vertexIn", GL_FLOAT, 0, 3, 3 * sizeof(float));
    m_shaderProgram.enableAttributeArray("vertexIn");
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7203434345451389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-05 23:01">2025-04-05 23:00</span>&nbsp;
<a href="https://www.cnblogs.com/codegb">师从名剑山</a>&nbsp;
阅读(<span id="post_view_count">40</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18810662" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18810662);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18810662', targetLink: 'https://www.cnblogs.com/codegb/p/18810662', title: '从零开始：在Qt中使用OpenGL绘制指南' })">举报</a>
</div>
        