
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tianqing/p/18705834" title="发布于 2025-02-09 10:45">
    <span role="heading" aria-level="2">.NET 进程 stackoverflow异常后，还可以接收 TCP 连接请求吗？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>昨天线上有几个进程因为 StackOverFlowException 导致进程 Crash 了，但是 TCP 请求还是可以连接，具体可不可以连接一个出现StackOverFlowException的微服务应用进程，</p>
<p>做个研究和分享：</p>
<p>在 .NET 进程发生 <code>StackOverflowException</code> 之后，<strong>通常无法继续接收 TCP 连接请求</strong>，原因如下：</p>
<ol>
<li>
<p><strong><code>StackOverflowException</code> 默认不可捕获</strong></p>
<ul>
<li>在 .NET Core 和 .NET 5+，<code>StackOverflowException</code> <strong>无法被 <code>try-catch</code> 捕获</strong>，一旦发生，<strong>进程会直接崩溃</strong>。</li>
<li>在 .NET Framework（如 4.x），即使能通过 <code>AppDomain.UnhandledException</code> 监听，<strong>进程仍可能进入不稳定状态</strong>，很难保证继续处理网络请求。</li>
</ul>
</li>
<li>
<p><strong>线程栈溢出导致进程崩溃</strong></p>
<ul>
<li><code>StackOverflowException</code> 发生时，通常意味着<strong>栈空间已耗尽</strong>（如递归过深、无限递归等）。</li>
<li>由于 TCP 连接通常依赖 <code>ThreadPool</code> 线程或 <code>async/await</code> 任务调度，一旦 <code>StackOverflowException</code> 触发，<strong>整个进程可能崩溃，所有连接都无法继续处理</strong>。</li>
</ul>
</li>
<li>
<p><strong>特殊情况下的可能性</strong></p>
<ul>
<li>如果 <code>StackOverflowException</code> 仅发生在<strong>单个线程</strong>（非主线程或关键任务线程），而应用没有崩溃，仍有可能继续接收 TCP 连接。</li>
<li>但这极端依赖于应用的架构，且在 .NET Core/.NET 5+ 下，<strong>进程基本上会直接崩溃</strong>。</li>
</ul>
</li>
</ol>
<h3><strong>如何防止 <code>StackOverflowException</code> 影响 TCP 连接？</strong></h3>
<ol>
<li><strong>避免递归导致栈溢出</strong>（如使用 <code>while</code> 代替递归，或控制递归深度）。</li>
<li><strong>使用 <code>ThreadPool</code> 隔离任务</strong>，尽量避免在核心线程（如 <code>Main()</code> 线程）中执行可能导致 <code>StackOverflowException</code> 的代码。</li>
<li><strong>启用进程监控</strong>（如 <code>supervisor</code>、<code>systemd</code> 或 <code>Kubernetes</code>），一旦进程崩溃，<strong>自动拉起新进程</strong>，尽快恢复服务。</li>
</ol>
<h3><span style="font-size: 14px">在现代 .NET 运行时（.NET Core 及 .NET 5+），<code>StackOverflowException</code> 通常会导致进程崩溃，TCP 服务器无法继续接受连接。</span></h3>
<h3><span style="font-size: 14px">若在 .NET Framework 下，并且 <code>StackOverflowException</code> 仅影响非核心线程，理论上 TCP 监听仍可能继续工作。</span></h3>
<p><span style="font-size: 14px">在 <strong>.NET Framework</strong> 下，如果 <code>StackOverflowException</code> <strong>仅影响非核心线程</strong>，那么 <strong>TCP 监听仍可能继续工作</strong>，原因如下：</span></p>
<p>&nbsp;</p>
<h3><strong>1. .NET Framework 允许进程存活</strong></h3>
<p>&nbsp;</p>
<ul>
<li>在 <strong>.NET Framework</strong>（尤其是 4.x 及更早版本）中，<code>StackOverflowException</code> <strong>不会</strong> 总是导致进程立即崩溃。</li>
<li>进程是否崩溃取决于：
<ul>
<li><strong>发生异常的线程类型</strong>：
<ul>
<li><strong>工作线程（非主线程）</strong>：如果 <code>StackOverflowException</code> 发生在 <strong>普通线程（ThreadPool 线程、手动创建的线程等）</strong>，该线程会崩溃 <strong>但不影响整个进程</strong>。</li>
<li><strong>主线程或关键任务线程</strong>：如果 <code>StackOverflowException</code> 发生在 <strong>主线程（如 <code>Main()</code> 线程）或关键任务线程（如监听 TCP 连接的线程）</strong>，整个进程可能会崩溃。</li>
</ul>
</li>
<li><strong>异常处理策略</strong>：
<ul>
<li>在 .NET Framework <strong>早期版本（2.0 及之前）</strong>，甚至可以在 <code>AppDomain.UnhandledException</code> 事件中尝试记录并继续运行（尽管不推荐）。</li>
<li><strong>.NET Framework 4.0+</strong> 默认行为是让进程崩溃，但如果 <code>StackOverflowException</code> 只发生在某个单独的线程上，进程<strong>仍可能存活</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3><strong>2. TCP 监听通常在独立线程运行</strong></h3>
<p>&nbsp;</p>
<ul>
<li><strong>TCP 监听（如 <code>TcpListener</code> 或 <code>Socket</code>）一般在独立线程中运行</strong>，如：
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">
<div class="cnblogs_code">
<pre>TcpListener listener = <span style="color: rgba(0, 0, 255, 1)">new</span> TcpListener(IPAddress.Any, <span style="color: rgba(128, 0, 128, 1)">8080</span><span style="color: rgba(0, 0, 0, 1)">);
listener.Start();

Task.Run(() </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        TcpClient client </span>= listener.AcceptTcpClient(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 阻塞等待连接</span>
<span style="color: rgba(0, 0, 0, 1)">        ProcessClient(client);
    }
});</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div>
</li>
<li>如果 <code>StackOverflowException</code> 发生在 <strong>某个处理请求的线程</strong>（<code>ProcessClient()</code> 内部）：
<ul>
<li>该线程会崩溃，但<strong>不会影响 <code>TcpListener</code> 本身</strong>。</li>
<li>监听线程 <strong>仍然可以接受新的连接</strong>，但部分旧连接会丢失。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3><strong>3. 线程崩溃对进程的影响</strong></h3>
<p>&nbsp;</p>
<ul>
<li>
<p>在 .NET Framework 下，<strong>单个线程崩溃不会直接导致进程终止</strong>，除非：</p>
<ol>
<li>该线程是 <code>Main()</code> 线程（或其他关键线程）。</li>
<li>进程启用了 <code>legacyCorruptedStateExceptionsPolicy</code>（某些情况下会导致进程崩溃）。</li>
<li>发生 <code>StackOverflowException</code> 的线程持有重要的 <code>lock</code>，导致死锁或影响其他线程的正常运行。</li>
</ol></li>
<li>
<p>如果 <code>StackOverflowException</code> 只影响非监听线程（如处理业务逻辑的线程），则：</p>
<ul>
<li><strong>TCP 监听线程仍然存活</strong>，可以继续接受新连接。</li>
<li>但如果 <code>StackOverflowException</code> 频繁发生，可能导致连接处理能力下降。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3><strong>4. 实际测试示例</strong></h3>
<p>&nbsp;</p>
<p>我们可以在 .NET Framework 4.x 下模拟 <code>StackOverflowException</code> 发生在非监听线程，看 TCP 监听是否还能接受连接：</p>
<p>&nbsp;</p>
<h4><strong>代码示例</strong></h4>
<p>&nbsp;</p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Net;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Net.Sockets;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Threading;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Threading.Tasks;

</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Program
{
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> Main()
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 启动 TCP 监听</span>
        TcpListener listener = <span style="color: rgba(0, 0, 255, 1)">new</span> TcpListener(IPAddress.Any, <span style="color: rgba(128, 0, 128, 1)">8080</span><span style="color: rgba(0, 0, 0, 1)">);
        listener.Start();
        Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">TCP 服务器已启动，监听端口 8080</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 监听线程</span>
        Task.Run(() =&gt;<span style="color: rgba(0, 0, 0, 1)">
        {
            </span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
            {
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
                {
                    TcpClient client </span>=<span style="color: rgba(0, 0, 0, 1)"> listener.AcceptTcpClient();
                    Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">接受到连接</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
                    Task.Run(() </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> ProcessClient(client));
                }
                </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception ex)
                {
                    Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">监听异常: </span><span style="color: rgba(128, 0, 0, 1)">"</span> +<span style="color: rgba(0, 0, 0, 1)"> ex.Message);
                }
            }
        });

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 模拟 StackOverflowException 发生在非监听线程</span>
        Task.Run(() =&gt;<span style="color: rgba(0, 0, 0, 1)">
        {
            Thread.Sleep(</span><span style="color: rgba(128, 0, 128, 1)">5000</span><span style="color: rgba(0, 0, 0, 1)">);
            Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">模拟递归调用导致栈溢出...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            CauseStackOverflow();
        });

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 保持主线程运行</span>
<span style="color: rgba(0, 0, 0, 1)">        Console.ReadLine();
    }

    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> ProcessClient(TcpClient client)
    {
        Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">处理客户端连接...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        client.Close();
    }

    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> CauseStackOverflow()
    {
        CauseStackOverflow(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 递归调用导致 StackOverflowException</span>
<span style="color: rgba(0, 0, 0, 1)">    }
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div>
<p>&nbsp;</p>
<h3><strong>5. 运行结果</strong></h3>
<p>&nbsp;</p>
<ol>
<li>
<p><strong>TCP 监听线程继续运行</strong></p>
<ul>
<li><code>StackOverflowException</code> 发生在 <strong>非监听线程</strong>（如 <code>ProcessClient()</code> 内部），会导致该线程崩溃。</li>
<li>但是 <code>TcpListener</code> 线程 <strong>不会受到影响</strong>，仍然可以接受新的连接。</li>
</ul>
</li>
<li>
<p><strong>部分连接处理失败</strong></p>
<ul>
<li>由于 <code>StackOverflowException</code> 可能导致部分线程终止，某些请求可能会失败。</li>
<li>但主 TCP 监听仍然存活，可以处理新的连接。</li>
</ul>
</li>
<li>
<p><strong>如果 <code>StackOverflowException</code> 发生在监听线程，则进程会崩溃</strong></p>
<ul>
<li>如果 <code>StackOverflowException</code> 发生在 <code>TcpListener.AcceptTcpClient()</code> 线程中，整个 TCP 服务可能会崩溃。</li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<h3><strong>总结</strong></h3>
<p>&nbsp;</p>
<ul>
<li>在 <strong>.NET Framework</strong> 下，如果 <code>StackOverflowException</code> <strong>仅影响非核心线程</strong>：
<ul>
<li>该线程会崩溃，但 <strong>TCP 监听线程可能仍然存活</strong>，可以继续接受连接。</li>
<li>但如果 <code>StackOverflowException</code> 发生在 <strong>监听线程</strong>，或者导致关键资源损坏，进程仍然可能崩溃。</li>
</ul>
</li>
<li><strong>推荐做法</strong>
<ul>
<li>在 <code>.NET Framework</code> 下使用 <strong>独立线程</strong> 运行 TCP 监听，避免 <code>StackOverflowException</code> 影响主线程。</li>
<li>在 <code>.NET Core</code> / <code>.NET 5+</code>，由于 <code>StackOverflowException</code> <strong>会导致整个进程崩溃</strong>，需要使用 <strong>进程监控机制</strong>（如 <code>supervisor</code>、<code>systemd</code>）来自动重启。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p><span style="font-size: 16px">周国庆</span></p>
<p><span style="font-size: 16px">2025/2/9</span></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06059441373958333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-09 10:53">2025-02-09 10:45</span>&nbsp;
<a href="https://www.cnblogs.com/tianqing">Eric zhou</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18705834" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18705834);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18705834', targetLink: 'https://www.cnblogs.com/tianqing/p/18705834', title: '.NET 进程 stackoverflow异常后，还可以接收 TCP 连接请求吗？' })">举报</a>
</div>
        