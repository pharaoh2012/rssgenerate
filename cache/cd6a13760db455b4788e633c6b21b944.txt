
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/felix-space/p/19057306" title="发布于 2025-08-25 16:49">
    <span role="heading" aria-level="2">Uniswap core源码学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>uniswap的core代码分为两部分，<code>Factory</code>和<code>Pair</code>，其中<code>Factory</code>是工厂合约，主要用来创建交易对，而<code>Pair</code>就是交易对合约，控制LP的<code>mint</code>和<code>burn</code>，以及用户的<code>swap</code>交易。</p>
<h1 id="factory">Factory</h1>
<p>首先来看一下Factory合约，定义了四个变量：</p>
<pre><code class="language-solidity">  address public feeTo;
    address public feeToSetter;

    mapping(address =&gt; mapping(address =&gt; address)) public getPair;
    address[] public allPairs;
    
    constructor(address _feeToSetter) public {
	    feeToSetter = _feeToSetter;
	  }
</code></pre>
<p><code>feeTo</code>和<code>feeToSetter</code>负责协议手续费的去向控制，构造合约的时候需要设置<code>feeToSetter</code>，做好权限控制。</p>
<p><code>getPair</code>和<code>allPairs</code>用于记录所有的流动性交易对以及映射关系。</p>
<pre><code class="language-solidity">  function setFeeTo(address _feeTo) external {
      require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
      feeTo = _feeTo;
  }

  function setFeeToSetter(address _feeToSetter) external {
      require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
      feeToSetter = _feeToSetter;
  }
}
</code></pre>
<p>提供了两个可以用来修改手续费<code>setter</code>和<code>to</code>地址的方法。</p>
<p>最重要的核心就是下面的<code>createPair</code>，用于创建交易对。</p>
<pre><code class="language-solidity">  function createPair(address tokenA, address tokenB) external returns (address pair) {
      require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
      (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
      require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient
      bytes memory bytecode = type(UniswapV2Pair).creationCode;
      bytes32 salt = keccak256(abi.encodePacked(token0, token1));
      assembly {
          pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
      }
      IUniswapV2Pair(pair).initialize(token0, token1);
      getPair[token0][token1] = pair;
      getPair[token1][token0] = pair; // populate mapping in the reverse direction
      allPairs.push(pair);
      emit PairCreated(token0, token1, pair, allPairs.length);
  }
</code></pre>
<h2 id="权限控制">权限控制</h2>
<p>第一部分的代码写了三个require：</p>
<ul>
<li>交易对两端token不可相同</li>
<li>交易对token不可为零地址</li>
<li>交易对还未创建</li>
</ul>
<p>可以看到这里对<code>tokenA</code>和<code>tokenB</code>做了一个排序，这是为了保证唯一性，不论传入什么样顺序的交易对，都能输出一样的结果。</p>
<p>因为<code>token0</code>小于<code>token1</code>，所以在检查零地址的时候只需要检查一个即可。</p>
<h2 id="部署合约">部署合约</h2>
<p>此处部署了新交易对的合约，使用了内联<code>assembly</code>，<code>create2</code>是创建合约的方法，它有一个特性就是创建得到的地址可预测：</p>
<pre><code class="language-solidity">address = keccak256(
    0xff,                    // 固定前缀
    deployer,                // 部署者地址（Factory）
    salt,                    // 盐值
    keccak256(bytecode)      // 字节码哈希
)
</code></pre>
<p>这里的<code>salt</code>是用交易对中两个token的地址生成的，这也就意味着<strong>对于任意一对token，最终生成的合约地址是唯一且可预测的</strong>，即使合约没部署也可以通过计算提前知道合约地址。</p>
<h2 id="初始化">初始化</h2>
<p>部署好合约后，调用了<code>initialize()</code>对合约进行了初始化，并在map里登记了交易对互相之间的映射关系，然后发出一条event，标志着交易对创建完成。</p>
<blockquote>
<p>为什么使用<code>initialize</code>调用进行初始化，而不是在create创建合约的时候通过构造函数初始化呢？</p>
</blockquote>
<p>这是因为如果定义了构造函数，那在create的时候传入的字节码里就需要带上参数类型并且传入实参，导致最终得到的hash都不相同。</p>
<p>特别是外部合约或者其他代码中计算<code>pair address</code>时，只需要传入一个固定的常量<code>creationCodeHash</code>即可（直接由uniswap分享出来），而不需要试图去获取uniswap的creationCode（得不到）。</p>
<h1 id="pair">Pair</h1>
<p>Pair合约是uniswap core代码里面最复杂的部分，负责交易对的相关内容。</p>
<p>首先从变量定义开始：</p>
<pre><code class="language-solidity">uint public constant MINIMUM_LIQUIDITY = 10**3;
bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
</code></pre>
<p>两个常量<code>MINIMUM_LIQUIDITY</code>和<code>SELECTOR</code>。</p>
<p>其中<code>MINIMUM_LIQUIDITY</code>是对最小流动性的要求，在初次添加流动性的时候会有<code>MINIMUM_LIQUIDITY</code>数量的LP token被永久锁定，即使所有的LP都赎回，也保证了池子不会被抽干，LP计算公式永远有效。</p>
<p>而<code>SELECTOR</code>的预定义是solidity中节约gas的方法，<strong>提前计算selector的字节码在合约编译的时候写入</strong>，后续调用的时候就无需花费gas重复计算。</p>
<pre><code class="language-solidity">uint112 private reserve0;           // uses single storage slot, accessible via getReserves
uint112 private reserve1;           // uses single storage slot, accessible via getReserves
uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
</code></pre>
<p><code>reserve</code>是流动性池中代币的存量，但是和单纯的<code>balance</code>不同，因为合约是支持接收转账的，所以<code>balance</code>的数量可能因为其他的行为而发生改变，但<code>reserve</code>的值是统计所有符合Pair逻辑的行为之后得到的流动性池中合法的代币存量。</p>
<p>所以reserve并不是一个实时量，而是需要依赖更新操作，因此还需要一个时间变量<code>blockTimestampLast</code>来记录上次的更新时间。</p>
<p>在数据类型的设计上，reserve用了<code>uint112</code>而不是<code>uint256</code>之类常见的int长度，这是因为<code>blockTimestampLast</code>需要32位存储，对于一个<code>uint256</code>来说，还剩下224位，正好分给两个<code>reserve</code>，112位已经能够满足单个代币的供应量。</p>
<p>这种设计可以将三个变量放在一个slot中，节约存储空间，减少gas的使用。</p>
<blockquote>
<p>在solidity中支持任意8的倍数的int类型，如<code>uint16</code>，<code>uint32</code>都是可以的</p>
</blockquote>
<pre><code class="language-solidity">address public factory;
address public token0;
address public token1;
</code></pre>
<p>定义了最基本的三个元素：</p>
<ul>
<li><code>factory</code>，创建工厂的地址，避免非法调用</li>
<li><code>token0</code>和<code>token1</code>：<code>交易对的两侧</code></li>
</ul>
<pre><code class="language-solidity">uint public price0CumulativeLast;
uint public price1CumulativeLast;
uint public kLast;
</code></pre>
<p><code>priceCumulativeLast</code>代表了代币价格的累积值，用于计算代币的时间加权平均价格（TWAP），可以提供给外部作为预言机使用。</p>
<p><code>kLast</code>是上次k值（x与y的乘积常量）变动时存储的值，使用场景在协议手续费的计算中。</p>
<pre><code class="language-solidity">event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
    address indexed sender,
    uint amount0In,
    uint amount1In,
    uint amount0Out,
    uint amount1Out,
    address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);

</code></pre>
<p>Pair里面有四个事件，分别代表着LP的添加和减少，代币的swap，还有流动性池数量的更新。</p>
<h2 id="mint">mint</h2>
<pre><code class="language-solidity">function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
       _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    } else {
        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
    }
    require(liquidity &gt; 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}

</code></pre>
<p><code>mint</code>是Pair里面的关键方法之一，调用时间在合约转入流动性池资产之后，根据转入的数量会给对应的用户mint出LP token。</p>
<p>首先通过<code>reserve</code>和<code>balance</code>的差值计算出<code>amount</code>，也就是用户转入作为lp的代币数量。</p>
<p><code>feeOn</code>是uniswap中手续费的设计，不影响主流程，放到最后再讲。</p>
<p>在<code>_mintFee</code>之后，读取了当前lp token的总供应量，这里有两个注意的点：</p>
<ul>
<li>顺序问题，<code>_mintFee</code>中会影响supply的数量，所以必须在其之后读取</li>
<li>gas优化问题，在方法如果要读取合约的成员变量，应当使用一个临时变量去做记录，方法内变量的使用gas要低于读取合约的变量。</li>
</ul>
<p>根据totalSupply分成两种逻辑：</p>
<ul>
<li>初次添加流动性，计算公式为$\sqrt {x*y}$，额外还需要减去<code>MINIMUM_LIQUIDITY</code>，这也是上面提到过的锁定流动性，然后这部分流动性会被打到零地址去。</li>
<li>正常有池子的情况下流动性的计算公式是$\frac{totalSupply}{reserve}*amount$，也就是保证<code>totalSupply</code>和<code>reserve</code>比值不变的情况下增加amount的数量，
<ul>
<li>如果在添加单个代币流动性的情况下，直接这么计算就可以，用户得到的LP token价值与当前流动性池子内的LP token价值是相等的。</li>
<li>如果是双代币添加，那么就要取两个值中的较小值。</li>
</ul>
</li>
</ul>
<pre><code class="language-solidity">function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
    require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
</code></pre>
<p><code>block.timestamp</code>的类型是uint256，但这里只保留了低32位，这样设计是因为uniswap中用的是时间差值而非时间本身，即  <code>uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</code>，因为是无符号整数，只要两次时间的差值不超过uint32的表示范围，那么即使是溢出取模的情况下依然可以保证差值是正确的。</p>
<p>在计算Cumulative的时候要注意，这里出现了<code>UQ112x112</code>，<code>UQ112x112</code>是uniswap自己实现的库，作用是用一个<code>uint224</code>表示定点数，整数和小数部分各分配112位，这是因为solidity没有原生的小数类型，而此处又涉及到了除法。<code>encode</code>的作用是将uint值左移112位，右边的112位用于表示小数，uqdiv是<code>UQ112x112</code>中自定义的除法，计算的结果依然是<code>UQ112x112</code>类型。</p>
<p>回到方法本身，<code>timeElapsed * （reserve1/reserve0）</code>表示<code>price（reserve1/reserve0）</code>持续了<code>timeElapsed</code>这么久，称为时间加权的价格累计。使用的时候将两个时间点的累积值相减再除以间隔时间，就可以得到这段时间内的<strong>时间加权平均价格。</strong></p>
<p>最后更新合约变量，输出事件，<code>_update</code>结束。</p>
<h2 id="burn">burn</h2>
<pre><code class="language-solidity">function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
    require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}

</code></pre>
<p>在mint中，可以看到计算提取出代币数量<code>amount</code>的时候，基数用的是<code>balance/totalSupply</code>而不是<code>reserve</code>，这是因为reserve的更新有滞后性，并且uniswap认为Pair中的所有资产都是属于LP的，即使是不通过合约方法存入的部分，都可以根据lp token获得分成。</p>
<p>其他部分与mint基本类似，就不重复说明了。</p>
<h2 id="swap">swap</h2>
<pre><code class="language-solidity">function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
    require(amount0Out &gt; 0 || amount1Out &gt; 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
    address _token0 = token0;
    address _token1 = token1;
    require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');
    if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
    if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
    if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    }
    uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In &gt; 0 || amount1In &gt; 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
    { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
    uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
    uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
    require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}

</code></pre>
<p>可以看到swap方法的参数中只有<code>amountOut</code>的值，而没有<code>amountIn</code>，说明在swap中<code>amountIn</code>是依赖于<code>amountOut</code>计算出来的，并且在实现中是先转出<code>out</code>资产，再去判断<code>in</code>是否满足，这种设计有以下的原因：</p>
<ul>
<li>支持闪电贷功能，因为闪电贷的功能依赖于转出资产套利后再补回，用户先要得到<code>out</code>资产才可以</li>
<li>保证<code>balance</code>的正确性，因为swap中的流动性池需要满足常数k条件，必须用新的balance参与计算得到另一个token的balance</li>
</ul>
<p>进入具体方法里面，首先是对数值有效性的判断，然后就直接将<code>amountOut</code>通过<code>_safeTransfer</code>转给了<code>to</code>地址，这也是我们前面提到的先<code>out</code>再<code>in</code>。</p>
<p>转账之后做了一个<code>data</code>长度的判断，此处就是对闪电贷支持的实现，借贷的对象需要实现<code>IUniswapV2Callee</code>中的<code>uniswapV2Call</code>方法供uniswap调用，并在其中实现<strong>套利-还款</strong>的逻辑，保证最终的<code>amountIn</code>与out的资产相匹配。</p>
<p><code>amountIn</code>的计算公式是：<code>balance - (_reserve - amountOut)</code>，虽然通常在dex中都是单边输入单边输出，但swap的底层实现其实是支持<strong>双输出和双输入</strong>的，只要保证最后的<strong>余额满足常数k的约束</strong>即可。</p>
<p><code>uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));</code>是uniswap计算手续费的公式，首先<code>mul(1000)</code>是为了用整数的精度计算，其实等价于为<code>balance-(amountIn*0.003)</code>，即收取<code>amountIn</code> 0.3%的手续费。 而<code>require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');</code>规定了收取手续费之后的balance的常数k需要不小于流动性池现有存储的常数k。那么<strong>再加上手续费，流动性池的k值其实是上升的，意外着LP能够兑换的资产也变多了，所有的LP都能够通过手续费受益。</strong></p>
<p>对于uniswap来说，用户发起swap后会马上用户转出<code>out</code>资产，但在最后结算时，合约中必须新增满足条件的<code>in</code>资产，即扣减手续费之后流动性池的常数k值不能减少，至于中间发生了什么，合约并不关心。</p>
<h2 id="协议费">协议费</h2>
<p>uniswap中协议费是可以手动控制开启关闭的，协议费的来源就是手续费，开启feeOn的情况下，uniswap可以从手续费中得到协议分成。</p>
<pre><code class="language-solidity">function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
    uint _kLast = kLast; // gas savings
    if (feeOn) {
        if (_kLast != 0) {
            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
            uint rootKLast = Math.sqrt(_kLast);
            if (rootK &gt; rootKLast) {
                uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                uint denominator = rootK.mul(5).add(rootKLast);
                uint liquidity = numerator / denominator;
                if (liquidity &gt; 0) _mint(feeTo, liquidity);
            }
        }
    } else if (_kLast != 0) {
        kLast = 0;
    }
}
</code></pre>
<p>协议费的公式可以写作：<code>协议费LP代币 = S × (rootK - rootKLast) / (5 × rootK + rootKLast)</code>，其中S为totalSupply，这个公式是由<code>[S × (rootK - rootKLast)/rootKLast] × (1/6)</code>得到的，也就是要分成从上次kLast到这次k中间新增LP数量的1/6。</p>
<p>kLast只有在swap的过程中才会变更，并且保证了k缓慢增长的时候，协议能够根据这些额外增长的k去<code>mint</code>出LP token，再根据LP token来获取分成受益。</p>
<p>如果池子里：</p>
<ul>
<li>纯粹的 mint/burn 操作（不涉及 swap）</li>
<li>没有交易活动的静态池子</li>
<li>刚刚收取过协议费的池子（此时 kLast 会被更新）</li>
</ul>
<p>那么也就无法计算出协议费，因为k未改变。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-25 16:49">2025-08-25 16:49</span>&nbsp;
<a href="https://www.cnblogs.com/felix-space">Felix07</a>&nbsp;
阅读(<span id="post_view_count">42</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19057306);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19057306', targetLink: 'https://www.cnblogs.com/felix-space/p/19057306', title: 'Uniswap core源码学习' })">举报</a>
</div>
        