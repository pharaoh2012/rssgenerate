<!----> <meta itemprop="headline" content="埋头苦干Vue3项目一年半，总结出了16个代码规范"> <meta itemprop="keywords" content="前端,面试,Vue.js"> <meta itemprop="datePublished" content="2025-02-20T11:15:52.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LiuMingXin"> <meta itemprop="url" content="https://juejin.cn/user/1644525125113245"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-b21437b8="">
            埋头苦干Vue3项目一年半，总结出了16个代码规范
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-b21437b8=""><div class="author-info-box" data-v-b21437b8=""><div class="author-name" data-v-b21437b8=""><a href="/user/1644525125113245/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-b21437b8=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    LiuMingXin
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-b21437b8=""><time datetime="2025-02-20T11:15:52.000Z" title="Thu Feb 20 2025 11:15:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-b21437b8="">
                    2025-02-20
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-b21437b8=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-b21437b8=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-b21437b8=""></circle></svg> <span class="views-count" data-v-b21437b8="">
                    8,863
                  </span> <span class="read-time" data-v-b21437b8=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-b21437b8=""><rect width="16" height="16" fill="none" data-v-b21437b8=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-b21437b8=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-b21437b8=""></path></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-b21437b8=""></div> <!----> <!----></div> <!----> <!----> <!----> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/img/banner.a5c9f88.jpg" style="width:100%;height:auto;display:block;" data-v-b21437b8=""> <div id="article-root" itemprop="articleBody" class="main" data-v-b21437b8=""><div class="article-viewer markdown-body cache result"><p><strong>从实战中提炼的Vue3开发经验与规范要点全解析，愿你我一同进步！</strong></p>
<h2 data-id="heading-0">1、Vue3规范</h2>
<h3 data-id="heading-1">1.1、箭头函数</h3>
<p>推荐使用箭头函数(保持this指向不变，避免后期定位问题的发杂度)。</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//【建议】业务开发中提倡的做法, 箭头函数配合const函数一起使用</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTableListData</span> = (<span class="hljs-params"></span>) =&gt; { <span class="hljs-comment">// TODO }</span>

<span class="hljs-comment">//【反例】尽量不要出现混用，如下：</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getDomeData</span> () {}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getDome1Data</span> = (<span class="hljs-params"></span>) =&gt; {}

<span class="hljs-comment">// 混用会导致可读性变差，而开发首要元素的可读性。</span>
</code></pre>
<h3 data-id="heading-2">1.2、变量提升</h3>
<p>在项目或者开发过程中，尽量使用let或者const定义变量，可以有效的规避变量提升的问题，不在赘述，注意const一般用于声明常量或者值不允许改变的变量。</p>
<h3 data-id="heading-3">1.3、数据请求</h3>
<p>数据请求类、异步操作类需要使用try…catch捕捉异常。尽量避免回调地狱出现。</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 推荐写法</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 获取列表数据
 * <span class="hljs-doctag">@return</span> <span class="hljs-variable">void</span>
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTableListData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">// 自己的业务处理TODO</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTableListDataApi</span>();
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTableListDataApi1</span>();
    <span class="hljs-comment">// TODO</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 异常处理相关</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 最终处理</span>
  }
};

<span class="hljs-comment">//【提倡】推荐接口定义带着Api结尾，比如我的方法是getTableListData，</span>
<span class="hljs-comment">//【提倡】内部逻辑调用的后端接口，那我的接口便可以定位为getTableListDataApi。</span>
</code></pre>
<p>当然也可以使用下面的方式：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 获取列表数据
 * <span class="hljs-doctag">@return</span> <span class="hljs-variable">void</span>
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTableListData</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-title function_">getTableListDataApi</span>({....}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// TODO</span>
  }).<span class="hljs-keyword">catch</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// TODO</span>
  }).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// TODO</span>
  })
}

<span class="hljs-comment">// 注意使用这种方式避免嵌套层级太深，如下反例：</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTableListData1</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-title function_">getTableListDataApi</span>({....}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
     <span class="hljs-title function_">getTableListDataApi1</span>({....}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">getTableListDataApi2</span>({....}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
             <span class="hljs-comment">// TODO 这种就是典型的回调地狱，禁止出现这种</span>
          })
       })
  })
}
</code></pre>
<p>合理使用数据并发请求：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景描述：表头和表格数据都需要请求接口获取，可以使用并发请求。</span>
<span class="hljs-comment">/**
* 查询列表数据
*/</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTableList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">// TODO</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 并行获取表格列数据和列表数据</span>
    <span class="hljs-keyword">const</span> [resColumns, resData] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
      <span class="hljs-title function_">getTableColumnsApi</span>({....}),
      <span class="hljs-title function_">getTableListApi</span>({...}),
    ]);
    <span class="hljs-comment">// TODO</span>
  } <span class="hljs-keyword">catch</span> (error) {
   <span class="hljs-comment">// TODO</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// TODO</span>
  }
};

<span class="hljs-comment">//  Promise.all的一些执行细节不在赘述，但是注意区分和Promise.allSettled用法</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Promise.all()方法会在任何一个输入的 Promise 被拒绝时立即拒绝。</span>
<span class="hljs-comment">// 相比之下，Promise.allSettled() 方法返回的 Promise 会等待所有</span>
<span class="hljs-comment">// 输入的 Promise 完成，不管其中是否有 Promise 被拒绝。如果你需</span>
<span class="hljs-comment">// 要获取输入可迭代对象中每个 Promise 的最终结果，则应使用allSettled()方法。</span>
</code></pre>
<p>合理使用数据竞速请求：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景描述：某些业务需要请求多个接口，但是只要一个接口先返回便处理逻辑</span>

<span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'数据请求1'</span>);
  }, <span class="hljs-number">1000</span>);
});

<span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'数据请求2'</span>);
  }, <span class="hljs-number">500</span>);
});

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 "数据请求2"</span>
});
</code></pre>
<p>注意：</p>
<blockquote>
<p><strong>数据请求时一定要做好异常的捕获和处理，异常的捕获和处理可以增加程序的健壮性和提升用户使用体验。</strong></p>
</blockquote>
<p>下面的反例要禁止：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 获取表格数据
 */</span>
<span class="hljs-keyword">function</span>  <span class="hljs-title function_">getTableListData</span> () {
    <span class="hljs-title function_">getTableListData</span>({
        pageNum： <span class="hljs-number">1</span>,
        <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// pageSize: 100000</span>
    }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
        tableList.<span class="hljs-property">value</span> = res.<span class="hljs-property">rows</span>;
        tableTotal.<span class="hljs-property">value</span> = res.<span class="hljs-property">total</span>;
        <span class="hljs-comment">//【提倡】</span>
        tableList.<span class="hljs-property">value</span> = res?.<span class="hljs-property">code</span> === <span class="hljs-number">200</span> ? res.<span class="hljs-property">rows</span> : [];
    })
}

<span class="hljs-comment">// 上面写法，界面可能没报错，功能也实现了，但是....</span>
</code></pre>
<h3 data-id="heading-4">1.4、响应性变量</h3>
<p>合理的使用响应性变量。数据量很大的对象或者数组，同时属性又是嵌套的对象，你的业务场景只需要第一层属性具有响应性，推荐使用shallowRef和shallowReactive定义响应性变量，这时不在推荐使用ref和reactive了。</p>
<h3 data-id="heading-5">1.5、单一职责原则</h3>
<p>组件或者方法的编写一定要遵循单一职责原则(概念不在赘述，自行了解)。</p>
<h3 data-id="heading-6">1.6、文件命名</h3>
<p>功能菜单的入口文件一定要带着name，同时其他编写的业务组件也推荐带着name，同时name的命名规则大写驼峰，且尽量要全局唯一(避免后期定位问题增加复杂度)。</p>
<p>文件名命名中，Vue中没有强制的规则，这里借鉴React的规则，大写驼峰。</p>
<blockquote>
<p>React component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.</p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup  name=<span class="hljs-string">'CustomName'</span>&gt; &lt;/script&gt;

<span class="hljs-comment">// 或者</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'CustomName'</span>,
    .......
})
</code></pre>
<h3 data-id="heading-7">1.7、监听器使用</h3>
<p>在Vue3中使用监听器watchEffect和watch时，需要留意使用方式，先看watchEffect：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">const</span> a = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)

<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (a.<span class="hljs-property">value</span> || b.<span class="hljs-property">value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行了更新操作'</span>);
  }
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; b.<span class="hljs-property">value</span> = !b.<span class="hljs-property">value</span>;
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"test"</span>&gt;</span>改变b的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前b的值:{{ b }}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>答案：当模板中改变b的值时，watchEffect无法监听 '执行了更新操作'。</p>
<p>在看下面的示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>)
    }, <span class="hljs-number">2000</span>)
  })
}

<span class="hljs-title function_">watchEffect</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// 请求信息</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">getInfo</span>()
  <span class="hljs-keyword">if</span> (b.<span class="hljs-property">value</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行了更新操作'</span>);
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt;  b.<span class="hljs-property">value</span> = !b.<span class="hljs-property">value</span>;
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"test"</span>&gt;</span>改变b的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前b的值:{{ b }}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>答案：当模板中改变b的值时，watchEffect无法监听 '执行了更新操作'。</p>
<p>在继续看下面示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">const</span> a = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (a.<span class="hljs-property">value</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行了更新操作'</span>);
    }
  })
}, <span class="hljs-number">2000</span>)

<span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; b.<span class="hljs-property">value</span> = !b.<span class="hljs-property">value</span>;
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"test"</span>&gt;</span>改变b的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前b的值:{{ b }}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>答案：当模板中改变b的值时，watchEffect无法监听 '执行了更新操作'。
使用watchEffect一定要注意两点：</p>
<blockquote>
<p>1、要使watchEffect可以第一时间捕捉到响应性变量；</p>
<p>2、异步操作触发微任务会影响watchEffect第一时间捕捉响应性变量。</p>
<p>当你watchEffect使用不是很熟悉的话，建议尽量使用watch。</p>
</blockquote>
<p>watch注意点：当你的组件内部使用watch较多或者你想手动消除watch的复杂度。</p>
<p>建议如下：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup&gt;
   ....
    <span class="hljs-keyword">const</span> currentScope = <span class="hljs-title function_">effectScope</span>();

    currentScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">watch</span>(
        <span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">currentRow</span>,
        <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
          <span class="hljs-comment">// TODO</span>
        },
        { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> }
      );
      <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">if</span> (queryObj.<span class="hljs-property">visitId</span>) {
          <span class="hljs-comment">// TODO</span>
        }
      });
    });

    <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> {
      currentScope.<span class="hljs-title function_">stop</span>();
    });
&lt;/script&gt;
</code></pre>
<p>需要留意的是Vue3.5+中新增了deep属性可以直接传入数字，告诉wacth监听到响应性数据到第几层。</p>
<h3 data-id="heading-8">1.8、Hooks使用</h3>
<p>在Vue3的项目中强烈推荐使用hooks进行功能的拆分和复用，这是Vue官方团队推荐的编写方式，下面来看一个列子，比如说，我要实现一个弹框的功能，下面常见的写法，第一种偏后端思维的写法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> editModel = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">isShow</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">form</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'ANDROID'</span>,
    <span class="hljs-comment">// ......</span>
  },
  <span class="hljs-attr">showFunc</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 显示逻辑</span>
  },
  <span class="hljs-attr">cancelFunc</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 取消逻辑</span>
  },
  <span class="hljs-attr">submitFunc</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 提交逻辑</span>
  },
});
</code></pre>
<p>或者其他的类似写法，不在赘述。
其实都可以换成hooks的写法：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useEditModel</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> isShow = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-comment">/**
   * 显示弹框
   */</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">showModal</span> = (<span class="hljs-params"></span>) =&gt; {};

  <span class="hljs-comment">/**
   * 关闭弹框
   */</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">cancelModal</span> = (<span class="hljs-params"></span>) =&gt; {};

  <span class="hljs-comment">/**
   * 提交操作
   */</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">submitModal</span> = (<span class="hljs-params"></span>) =&gt; {};

  <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// TODO</span>
  });

  <span class="hljs-keyword">return</span> {
    isShow,
    showModal,
    cancelModal,
    submitModal,
  };
};

<span class="hljs-comment">// 其他地方使用</span>
<span class="hljs-keyword">const</span> { isShow, showModal, cancelModal, submitModal } = <span class="hljs-title function_">useEditModel</span>();
</code></pre>
<p>简单总结一下hooks编写的思想：</p>
<blockquote>
<p><strong>在函数作用域内定义、使用响应式\非响应性状态、变量或者从多个函数中得到的状态、变量、方法进行组合，从而处理复杂问题。</strong></p>
</blockquote>
<h3 data-id="heading-9">1.9、暴露方法</h3>
<p>当我们想要暴露第三方组件的所有属性时，我们怎么快速的暴露？</p>
<p>使用expose需要一个一个写，显然太麻烦，可以使用下面的方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">expose</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(
    {},
    {
      <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
        <span class="hljs-comment">// CustomDomRef是定义的模板中的ref dom节点</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">CustomDomRef</span>.<span class="hljs-property">value</span>?.[key];
      },
      <span class="hljs-title function_">has</span>(<span class="hljs-params">target, key</span>) {
        <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> <span class="hljs-title class_">CustomDomRef</span>.<span class="hljs-property">value</span>;
      },
    },
  ),
);
</code></pre>
<h3 data-id="heading-10">1.10、挑选属性</h3>
<p>某些业务场景下我们需要挑选出，部分属性传递给接口，如何优雅的挑选属性，可以参考如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
  <span class="hljs-attr">sex</span>: <span class="hljs-string">'男'</span>,
  <span class="hljs-attr">name1</span>: <span class="hljs-string">'张三1'</span>,
};

<span class="hljs-comment">// 当不需要name1传递时，怎么做呢？</span>

<span class="hljs-comment">// 方式1</span>
<span class="hljs-keyword">delete</span> obj.<span class="hljs-property">name1</span>;

<span class="hljs-comment">// 方式2</span>
<span class="hljs-keyword">const</span> newObj = {
  <span class="hljs-attr">name</span>: obj.<span class="hljs-property">name</span>,
  <span class="hljs-attr">age</span>: obj.<span class="hljs-property">age</span>,
  <span class="hljs-attr">sex</span>: obj.<span class="hljs-property">sex</span>,
};

<span class="hljs-comment">// 方式3</span>
<span class="hljs-keyword">const</span> newObj = {
  ...obj,
  <span class="hljs-attr">name1</span>: <span class="hljs-literal">undefined</span>,
};

<span class="hljs-comment">// 其实可以使用一种更优雅的方式</span>
<span class="hljs-keyword">const</span> { name1, ...newObj } = obj;

<span class="hljs-comment">// 或者使用lodash的omit或者pick方法</span>
</code></pre>
<h3 data-id="heading-11">1.11、组合式API</h3>
<p>组合式API本身是为了灵活，但是项目中使用时出现了五花八门的情况，有的把expose写到了最开始，把组件引入放到最下面，当你不确定setup语法糖下使用顺序时，可以参考下面的顺序：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;script setup&gt;
  <span class="hljs-comment">// import语句</span>
  <span class="hljs-comment">// Props(defineProps) </span>
  <span class="hljs-comment">// Emits(defineEmits) </span>
  <span class="hljs-comment">// 响应性变量定义 </span>
  <span class="hljs-comment">// Computed </span>
  <span class="hljs-comment">// Watchers </span>
  <span class="hljs-comment">// 函数 </span>
  <span class="hljs-comment">// 生命周期 </span>
  <span class="hljs-comment">// Expose(defineExpose)</span>
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-12">1.12、逻辑分支</h3>
<p>当我们编写业务代码时，经常会遇到下面这种写法，写法没有对错只是有更好的优化方式：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景一</span>
<span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) {
  <span class="hljs-comment">// TODO</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) {
  <span class="hljs-comment">// TODO</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">3</span>) {
  <span class="hljs-comment">// TODO</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">4</span>) {
  <span class="hljs-comment">// TODO</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">5</span>) {
  <span class="hljs-comment">// TODO</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// TODO</span>
}

<span class="hljs-comment">// 场景二</span>
<span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">if</span> (type1 === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (type2 === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">if</span> (type3 === <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// TODO</span>
      }
    }
  }
}
</code></pre>
<p>场景一：违背了<strong>开闭原则</strong>(对扩展开放、对修改关闭)和<strong>单一职责原则</strong>。场景一可以进行如下的优化：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 优化方式一：字典映射方式</span>
<span class="hljs-keyword">const</span> typeHandlers = {
  <span class="hljs-number">1</span>: handleType1,
  <span class="hljs-number">2</span>: handleType2,
  <span class="hljs-number">3</span>: handleType3,
  <span class="hljs-number">4</span>: handleType4,
  <span class="hljs-number">5</span>: handleType5,
  <span class="hljs-attr">default</span>: handleDefault,
};
<span class="hljs-keyword">const</span> handler = typeHandlers[type] || typeHandlers.<span class="hljs-property">default</span>;
<span class="hljs-title function_">handler</span>();

<span class="hljs-comment">// 优化方式二：高阶函数方式</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleType1</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">/* TODO for type 1 */</span>
};
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleType2</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">/* TODO for type 2 */</span>
};
<span class="hljs-comment">// 其他处理函数...</span>
<span class="hljs-keyword">const</span> handlers = [handleType1, handleType2 <span class="hljs-comment">/*...*/</span>];
<span class="hljs-keyword">const</span> <span class="hljs-title function_">processType</span> = (<span class="hljs-params">type</span>) =&gt; {
  <span class="hljs-keyword">if</span> (handlers[type - <span class="hljs-number">1</span>]) handlers[type - <span class="hljs-number">1</span>]();
};
<span class="hljs-title function_">processType</span>(type);
</code></pre>
<p>场景二：违背了<strong>圈复杂度原则</strong>和<strong>单一职责原则</strong>，场景二可以进行如下优化：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 优化方式一</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isValidType</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> type === <span class="hljs-number">1</span> &amp;&amp; type1 === <span class="hljs-number">1</span> &amp;&amp; type2 === <span class="hljs-number">1</span> &amp;&amp; type3 === <span class="hljs-number">1</span>;
};
<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValidType</span>()) {
}

<span class="hljs-comment">// 优化方式二：使用"早返回原则"或者叫"错误前置原则"进行优化</span>
<span class="hljs-keyword">if</span> (type !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
<span class="hljs-keyword">if</span> (type1 !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
<span class="hljs-keyword">if</span> (type2 !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
<span class="hljs-keyword">if</span> (type3 !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
<span class="hljs-comment">// TODO</span>
</code></pre>
<p>上面只是简单列举的优化的思路，方案有很多，合理即可。</p>
<h3 data-id="heading-13">1.13、删除冗余</h3>
<p>在业务开发过程中，我们经常会对代码进行注释，有些文件中会出现好多处注释，当然这些注释后边可能会放开，但是官方提倡的做法是<strong>尽量删除掉这些注释的代码，真正需要哪些代码，在还原回来即可</strong>。</p>
<p>另一个常见的问题是：console打印和debugger之类的，虽然说可以通过插件配置在打包的时候删除掉，但是官方提倡的是<strong>在源码层面一旦调试完成就立即删除</strong>。</p>
<p><strong>还有单文件不要超过600行代码，当然也可以适当根据实际情况放宽，一般情况下超过这个行数就要进行代码的拆分，拆分的方式包括组件、方法、样式、配置项等。但是过度拆分也会导致碎片化的问题，需要合理把握。</strong></p>
<h3 data-id="heading-14">1.14、异步组件</h3>
<p>Vue3中提供了异步组件(defineAsyncComponent)的定义，异步组件的优点：</p>
<blockquote>
<p>1、在运行时是懒加载的，可以更好的让浏览器渲染其他功能。</p>
<p>2、有利于vite打包时进行代码分割。</p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 简单示例</span>
&lt;script setup&gt;
<span class="hljs-keyword">import</span> { defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">AdminPage</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/AdminPageComponent.vue'</span>)
)
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">AdminPage</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="hljs-comment">// 复杂示例</span>

<span class="hljs-comment">// 异步组件的定义</span>
<span class="hljs-keyword">import</span> { defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PreferenceItemComs</span>: any = {
  <span class="hljs-title class_">Residence</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./Residence.vue"</span>)),
  <span class="hljs-title class_">PastHistory</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./PastHistory.vue"</span>)),
  <span class="hljs-title class_">AllergyHistory</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./AllergyHistory.vue"</span>)),
  <span class="hljs-title class_">Diagnose</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./Diagnose.vue"</span>)),
};
<span class="hljs-comment">// 异步组件的使用</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span>
    <span class="hljs-attr">:is</span>=<span class="hljs-string">"getCurrentComponents()"</span>
  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>

<span class="hljs-comment">/**
 * 获取当前需要渲染的组件
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getCurrentComponents</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> projectType = activeName.<span class="hljs-property">value</span>;
  <span class="hljs-keyword">if</span> (projectType &amp;&amp; <span class="hljs-title class_">PreferenceItemComs</span>[projectType]) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">PreferenceItemComs</span>[projectType];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};
</code></pre>
<p><strong>复杂功能的拆分可以考虑使用异步组件。</strong></p>
<h3 data-id="heading-15">1.15、路由懒加载</h3>
<p>现有框架里面一般不需要我们接触这块，因为菜单和路由已经是封装完善的，但是我们也需要知道路由懒加载的概念：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 将</span>
<span class="hljs-comment">// import UserDetails from './views/UserDetails.vue'</span>
<span class="hljs-comment">// 替换成</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserDetails</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/UserDetails.vue'</span>)

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/users/:id'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span> }
    <span class="hljs-comment">// 或在路由定义里直接使用它</span>
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/users/:id'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/UserDetails.vue'</span>) },
  ],
})
</code></pre>
<p>路由懒加载有利于vite对不同的菜单功能进行代码分割，降低打包之后的代码体积，从而增加访问速度。
需要注意的是：<strong>不要</strong>在路由中使用<strong>异步组件</strong>。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。</p>
<h3 data-id="heading-16">1.16、运算符</h3>
<p>es新特性中有几个新增的运算符你需要了解，因为它可以简化你的编码编写。</p>
<blockquote>
<p>?? ( 空值合并运算符)</p>
<p>?. (可选链式运算符)</p>
<p>??= (空值合并赋值操作符)</p>
<p>?= (安全复制运算符)</p>
</blockquote>
<p>示例</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ?? ( 空值合并运算符)：这个运算符主要是左侧为null和undefined，直接返回右侧值</span>
<span class="hljs-comment">// 请在开发过程中合理使用||和??</span>
<span class="hljs-keyword">let</span> result = value ?? <span class="hljs-string">'默认值'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'result'</span>, result);



<span class="hljs-comment">// ?.(可选链运算符): 用于对可能为 null 或 undefined 的对象进行安全访问。</span>
<span class="hljs-comment">// 建议这个属性要用起来，防止数据不规范时控制台直接报错</span>
<span class="hljs-keyword">const</span> obj = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> prop = obj?.<span class="hljs-property">property</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'prop'</span>, prop);



<span class="hljs-comment">// ??= (空值合并赋值操作符): 用于在变量已有非空值，避免重复赋值。</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>;
x ??= <span class="hljs-number">5</span>; <span class="hljs-comment">// 如果 x 为 null 或 undefined，则赋值为 5</span>



<span class="hljs-comment">// ?= (安全复制运算符)：旨在简化错误处理。改运算符与 Promise、async 函数以及任何实现了 Symbol.result 方法的对象兼容，简化了常见的错误处理流程。</span>
<span class="hljs-comment">// 注意：任何实现了 Symbol.result 方法的对象都可以与 ?= 运算符一起使用，Symbol.result 方法返回一个数组，第一个元素为错误，第二个元素为结果。</span>
<span class="hljs-keyword">const</span> [error, response] ?= <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://blog.conardli.top"</span>);
</code></pre>
<h2 data-id="heading-17">2、代码注释</h2>
<blockquote>
<p>代码的可读性和可迭代性是编写代码时首要考虑因素。</p>
</blockquote>
<h3 data-id="heading-18">2.1、文件注释</h3>
<p>单个文件注释规范，每个独立的VUE文件开头可进行文件注释，表明该文件的描述信息、作者、创建时间等。</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;!--
 * @<span class="hljs-title class_">FileDescription</span>: 该文件的描述信息
 * @<span class="hljs-title class_">Author</span>: 作者信息
 * @<span class="hljs-title class_">Date</span>: 文件创建时间
 * @<span class="hljs-title class_">LastEditors</span>: 最后更新作者
 * @<span class="hljs-title class_">LastEditTime</span>: 最后更新时间
 --&gt;
</code></pre>
<h3 data-id="heading-19">2.2、方法注释</h3>
<p>功能开发时编写的相关方法要进行方法注释和说明，注释要遵循JSDOC规范。</p>
<p>方法注释格式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span>: 方法描述 （可以不带<span class="hljs-doctag">@description</span>）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">参数类型</span>} 参数名称
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">参数类型</span>} 参数名称
 * <span class="hljs-doctag">@return</span> 没有返回信息写 void / 有返回信息 {返回类型} 描述信息
 */</span>
</code></pre>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 获取解析统计相关数据
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">userInfo</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">lists</span>
 * <span class="hljs-doctag">@return</span> <span class="hljs-variable">void</span>
 */</span>

或者;

<span class="hljs-comment">/**
 * 获取解析统计相关数据
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} userInfo 用户信息
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} lists 用户列表
 * <span class="hljs-doctag">@return</span> <span class="hljs-variable">void</span>
 */</span>
</code></pre>
<h3 data-id="heading-20">2.3、变量注释</h3>
<p>关键的变量要进行注释说明，变量注释一般包括两种：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 提倡(vscode可以给出提示的写法)</span>
<span class="hljs-comment">/* 描述信息 */</span>
<span class="hljs-attr">activeName</span>: <span class="hljs-string">'first'</span>;

<span class="hljs-attr">activeName</span>: <span class="hljs-string">'first'</span>; <span class="hljs-comment">// 默认激活的Tab页</span>
或者;

<span class="hljs-comment">// 默认激活的Tab页</span>
<span class="hljs-attr">activeName</span>: <span class="hljs-string">'first'</span>;
</code></pre>
<h3 data-id="heading-21">2.4、行内注释</h3>
<p>关键业务代码必须进行行内注释，行内注释建议按照以下格式进行：</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 根据指定的属性对数据进行分类</span>

或者;

<span class="hljs-comment">// 根据指定的属性对数据进行分类，</span>
<span class="hljs-comment">// 分类之后按住时间进行降序排序</span>
<span class="hljs-comment">// ......</span>

或者;
<span class="hljs-comment">/**
 * 根据指定的属性对数据进行分类，
 * 分类之后按住时间进行降序排序
 * ......
 */</span>
</code></pre>
<h3 data-id="heading-22">2.5、折叠代码块注释</h3>
<p>耦合度非常高的变量或者方法建议进行代码折叠注释</p>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// #region 升序、降序处理逻辑</span>

<span class="hljs-comment">/**
 * 升序、降序处理逻辑说明：
 *
 * 根据指定的属性对数据进行分类，
 * 分类之后按住时间进行降序排序
 * ......
 */</span>

<span class="hljs-keyword">const</span> asceOrderLists = []; <span class="hljs-comment">// 升序数组</span>
<span class="hljs-keyword">const</span> descOrderLists = []; <span class="hljs-comment">// 降序数组</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 升序操作
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">lists</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arrs</span>
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAsceOrder</span> = (<span class="hljs-params">lists</span>) =&gt; {
    <span class="hljs-comment">// .........</span>
    <span class="hljs-keyword">return</span> arrs
}



<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 降序操作
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">lists</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arrs</span>
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDescOrder</span> = (<span class="hljs-params">lists</span>) =&gt; {
    <span class="hljs-comment">// .........</span>
    <span class="hljs-keyword">return</span> arrs
}

......
<span class="hljs-comment">// #endregion</span>
</code></pre>
<h3 data-id="heading-23">2.6、其他</h3>
<p>日常开发中，常见的问题修改和功能开发建议按下列方式进行注释：</p>
<pre><code class="hljs language-javascript" lang="javascript">- 新功能点开发
<span class="hljs-comment">// FEAT-001: 进行了XXXXX功能开发(LMX-2024-09-24)</span>
- 问题修复
<span class="hljs-comment">// BUGFIX-001: 进行了XXXXX功能修复(LMX-2024-09-24)</span>

....
</code></pre>
<p>说明：</p>
<pre><code class="hljs language-javascript" lang="javascript">格式说明：
[${a1}-${a2}]: 相关描述信息(${a3}-${a4})

- a1：类型描述，建议遵循git提交规范，但是使用全驼峰大写。（feat、fix、bugfix、docs、style、refactor、perf、chore）
- <span class="hljs-attr">a2</span>: 编号，可以使用bug单号、功能特性单号或者自增序号，建议使用bug单号、功能特性单号。
- <span class="hljs-attr">a3</span>: git账户或者能标识自己的账号即可。
- <span class="hljs-attr">a4</span>: 新增或者修改时间，建议精确到天。
</code></pre>
<h2 data-id="heading-24">3、目录结构</h2>
<p>针对于项目功能开发，怎样划分一个功能的目录结构？怎么的目录结构可以提高代码的可读性？</p>
<p>下面是一个相对完善业务功能文件目录，可以进行参考:</p>
<pre><code class="hljs language-plain" lang="plain">custom_module                   # 业务模块
│   ├── api                     # 业务模块私有接口
│   ├── components/modules      # 业务组件(涉及业务处理)
│   ├── composable              # 业务组件(不涉及具体业务)
│   ├── functional              # 业务函数式组件
│   ├── methods/hooks           # 业务hooks
│   ├── config                  # 业务配置项
│   ├── styles                  # 业务样式
│   └── utils                   # 业务私有工具类
|── index.vue                   # 业务入口文件
|── .pubrc.js                   # 业务后期模块联邦入口
└── README.md                   # 业务说明文档
</code></pre>
<p>具体的业务功能划分，可以根据自己的具体业务划定，总之合理即可。如果是公用性组件的话，可以不需要按照上面的目录结构进行划分。</p>
<h2 data-id="heading-25">4、性能优化</h2>
<h3 data-id="heading-26">减小代码打包体积</h3>
<ul>
<li>减少源代码重复，复用功能抽取共用组件或者方法</li>
<li>优化前端依赖，防止新依赖的加入导致包体积的增大，例如lodash-es要优于lodash</li>
<li>代码分割(ESM动态导入，路由懒加载)</li>
<li>合理的配置vite.config.ts中配置项。例如rollupOptions配置项中的output.manualChunks,sourceMap等</li>
</ul>
<h3 data-id="heading-27">优化资源加载速度</h3>
<ul>
<li>部分静态资源或者依赖项可以考虑cdn方式，增加访问速度</li>
<li>开启浏览器的gzip压缩，减少带宽请求</li>
<li>某些关键性资源是否可以考虑预加载</li>
<li>部分图片和视频是否可以考虑延迟加载</li>
</ul>
<h3 data-id="heading-28">业务代码层面优化</h3>
<ul>
<li>较少接口请求数量，耗时接口如何优化</li>
<li>大数据量的场景处理(分页、虚拟滚动)</li>
<li>减少非必要的更新(父子组件之间的更新, key禁止使用index)</li>
<li>减少大数量下的响应性开销</li>
<li>减少人为的内存泄露和溢出操作</li>
<li>优化JS中执行较长时间的任务(比如是否可以考虑异步、requestAnimationFrame、requestIdleCallback)</li>
</ul>
<h3 data-id="heading-29">合理利用缓存</h3>
<ul>
<li>浏览器的协商缓存</li>
<li>浏览器的强缓存</li>
<li>浏览器本地的存储(localStorage、sessionStorage、indexedDB这些是否可以使用)</li>
</ul></div></div>