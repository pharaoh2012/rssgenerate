
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MingsonZheng/p/18696241" title="发布于 2025-02-01 20:00">
    <span role="heading" aria-level="2">【译】MongoDB EF Core 提供程序：有什么新功能？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>原文 | Rishit, Luce</p>
<p>翻译 | 郑子铭</p>
<p>这是 Rishit Bhatia 和 Luce Carter 的客座文章。Rishit 是 MongoDB 的高级产品经理，专注于 .NET 开发人员体验，在进入产品管理部门之前，他已经使用 C# 工作多年。Luce 是 MongoDB 的开发倡导者、Microsoft MVP，热爱代码、阳光和学习。本博客由 Microsoft .NET 团队针对 EF Core 进行了审阅。</p>
<p><a href="https://www.mongodb.com/" target="_blank" rel="noopener nofollow">MongoDB</a> 的 EF Core 提供程序于 2024 年 5 月<a href="https://www.mongodb.com/blog/post/mongodb-provider-entity-framework-core-now-generally-available" target="_blank" rel="noopener nofollow">正式发布</a>。自六个月前首次发布此软件包的预览版以来，我们已经取得了长足的进步。我们想分享一些我们一直在研究的有趣功能，如果没有 Microsoft .NET 数据和实体框架团队的支持和合作，这些功能是不可能实现的。</p>
<p>在这篇文章中，我们将使用 <a href="https://www.mongodb.com/docs/drivers/csharp/current/" target="_blank" rel="noopener nofollow">MongoDB EF Core 提供程序</a>和 <a href="https://www.mongodb.com/products/platform/atlas-database" target="_blank" rel="noopener nofollow">MongoDB Atlas</a> 来展示以下内容：</p>
<ul>
<li>向实体添加属性并进行更改跟踪</li>
<li>利用出口创建索引</li>
<li>执行复杂查询</li>
<li>事务和乐观并发</li>
</ul>
<p>与本博客相关的代码可以在 <a href="https://github.com/mongodb-developer/efcore_highlights" target="_blank" rel="noopener nofollow">Github</a> 上找到。入门样板代码位于“start”分支中。包含下面提到的所有功能亮点的完整代码位于“main”分支中。</p>
<h2 id="先决条件">先决条件</h2>
<p>我们将使用<a href="https://www.mongodb.com/docs/atlas/sample-data/" target="_blank" rel="noopener nofollow">示例数据集</a> — 具体来说，本示例中 MongoDB Atlas 可用的 sample_mflix 数据库中的电影集合。要使用示例数据设置 Atlas 集群，您可以按照<a href="https://www.mongodb.com/docs/atlas/getting-started/" target="_blank" rel="noopener nofollow">文档中</a>的步骤操作。我们将创建一个简单的 .NET 控制台应用程序来开始使用 MongoDB EF Core 提供程序。有关如何执行此操作的更多详细信息，您可以查看<a href="https://www.mongodb.com/docs/entity-framework/current/quick-start/" target="_blank" rel="noopener nofollow">快速入门指南</a>。</p>
<p>此时，您应该已连接到 Atlas 并能够从快速入门指南中正在读取的电影中输出电影情节。</p>
<h2 id="功能亮点">功能亮点</h2>
<h3 id="添加属性和更改跟踪">添加属性和更改跟踪</h3>
<p>MongoDB 文档模型的优点之一是它支持灵活的架构。再加上 EF Core 支持 Code First 方法的能力，您可以动态向实体添加属性。为了展示这一点，我们将向我们的模型类添加一个名为 <code>adapted_from_book</code> 的新可空布尔属性。这将使我们的模型类如下所示：</p>
<pre><code>public class Movie
{
    public ObjectId Id { get; set; }

    [BsonElement("title")]
    public string Title { get; set; }

    [BsonElement("rated")]
    public string Rated { get; set; }

    [BsonElement("plot")]
    public string Plot { get; set; }

    [BsonElement("adaptedFromBook")]
    public bool? AdaptedFromBook { get; set; }
}
</code></pre>
<p>现在，我们将为找到的电影实体设置这个新添加的属性，并在保存更改后查看 <a href="https://learn.microsoft.com/ef/core/change-tracking/" target="_blank" rel="noopener nofollow">EF Core 的更改跟踪功能</a>。为此，我们将在打印电影情节后添加以下代码行：</p>
<pre><code>movie.AdaptedFromBook = false;
await db.SaveChangesAsync();
</code></pre>
<p>在运行程序之前，让我们转到 Atlas 中的集合并找到这部电影，以确保这个新创建的字段 <code>adapted_from_book</code> 不存在于我们的数据库中。为此，只需转到 Atlas Web UI 中的集群并选择浏览集合。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122059567-1024402088.png" alt="" loading="lazy"></p>
<p>然后，从 sample_mflix 数据库中选择电影集合。在过滤器选项卡中，我们可以使用以下查询找到我们的电影：</p>
<pre><code>{title: "Back to the Future"}
</code></pre>
<p>这应该可以找到我们的电影，并且我们可以确认我们想要添加的新字段确实没有被看到。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122117099-408388599.png" alt="" loading="lazy"></p>
<p>接下来，让我们在刚刚添加的两行代码中添加一个断点，以确保我们可以在继续操作时实时跟踪更改。选择“开始调试”按钮来运行应用程序。当第一个断点被击中时，我们可以看到本地字段值已被分配。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122128398-1519033640.png" alt="" loading="lazy"></p>
<p>让我们点击“继续”并检查数据库中的文档。我们可以看到新字段尚未添加。让我们跳过将结束程序的“保存更改”调用。此时，如果我们检查数据库中的文档，我们会注意到新字段已添加，如下所示！</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122138064-1542185470.png" alt="" loading="lazy"></p>
<h3 id="索引管理">索引管理</h3>
<p>MongoDB EF Core 提供程序建立在现有的 <a href="https://www.mongodb.com/docs/drivers/csharp/current/" target="_blank" rel="noopener nofollow">.NET/C# 驱动程序</a>之上。此架构的一个优点是，我们可以重用已为 <code>DbContext</code> 创建的 <code>MongoClient</code>，以利用 MongoDB 开发人员数据平台公开的其他功能。这包括但不限于<a href="https://www.mongodb.com/docs/drivers/csharp/upcoming/fundamentals/indexes/#list-indexes" target="_blank" rel="noopener nofollow">索引管理</a>、<a href="https://www.mongodb.com/docs/drivers/csharp/upcoming/fundamentals/atlas-search/" target="_blank" rel="noopener nofollow">Atlas 搜索</a>和<a href="https://www.mongodb.com/docs/atlas/atlas-vector-search/tutorials/vector-search-quick-start/" target="_blank" rel="noopener nofollow">矢量搜索</a>等功能。</p>
<p>我们将了解如何在同一个应用程序中使用驱动程序创建新索引。首先，我们将列出集合中的索引，以查看哪些索引已经存在。MongoDB 默认在 <code>_id</code> 字段上创建索引。我们将创建一个辅助函数来打印索引：</p>
<pre><code>var moviesCollection = client.GetDatabase("sample_mflix").GetCollection&lt;Movie&gt;("movies");
Console.WriteLine("Before creating a new Index:");
PrintIndexes();

void PrintIndexes()
{
    var indexes = moviesCollection.Indexes.List();
    foreach (var index in indexes.ToList())
    {
        Console.WriteLine(index);
    }
}
</code></pre>
<p>预期输出如下所示：</p>
<pre><code>{ "v" : 2, "key" : { "_id" : 1 }, "name" : "_id_" }
</code></pre>
<p>现在，我们将在我们的集合中的标题和评级字段上创建一个<a href="https://www.mongodb.com/docs/manual/core/indexes/index-types/index-compound/" target="_blank" rel="noopener nofollow">复合索引</a>，并再次打印索引。</p>
<pre><code>var moviesIndex = new CreateIndexModel&lt;Movie&gt;(Builders&lt;Movie&gt;.IndexKeys
    .Ascending(m =&gt; m.Title)
    .Ascending(x =&gt; x.Rated));
await moviesCollection.Indexes.CreateOneAsync(moviesIndex);

Console.WriteLine("After creating a new Index:");
PrintIndexes();
</code></pre>
<p>我们可以看到，一个名为<code>title_1_rated_1</code>的新索引已经创建。</p>
<pre><code>After creating a new Index:
{ "v" : 2, "key" : { "_id" : 1 }, "name" : "_id_" }
{ "v" : 2, "key" : { "title" : 1, "rated" : 1 }, "name" : "title_1_rated_1" }
</code></pre>
<h3 id="查询数据">查询数据</h3>
<p>由于 EF Core 已经支持语言集成查询 (LINQ) 语法，因此使用 C# 编写强类型查询变得很容易。根据模型类中可用的字段，我们可以尝试从我们的收藏中查找一些有趣的电影。假设我想查找所有评级为“PG-13”且情节包含单词“shark”的电影，但我希望按标题字段对它们进行排序。我可以使用以下查询轻松完成此操作：</p>
<pre><code>var myMovies = await db.Movies
    .Where(m =&gt; m.Rated == "PG-13" &amp;&amp; m.Plot.Contains("shark"))
    .OrderBy(m =&gt; m.Title)
    .ToListAsync();

foreach (var m in myMovies)
{
    Console.WriteLine(m.Title);
}
</code></pre>
<p>然后，我们可以使用上面的代码打印出查询，并使用 <code>dotnet run</code> 运行程序以查看结果。我们应该能够在控制台中看到我们收藏的 20K+ 部电影中的两部电影名称，如下所示。</p>
<pre><code>Jaws: The Revenge
Shark Night 3D
</code></pre>
<p>如果您想查看发送到服务器的查询（在本例中为 MQL），那么您可以在 DbContext 上的 <code>Create</code> 函数中启用日志记录，如下所示：</p>
<pre><code>   public static MflixDbContext Create(IMongoDatabase database) =&gt;
       new(new DbContextOptionsBuilder&lt;MflixDbContext&gt;()
           .UseMongoDB(database.Client, database.DatabaseNamespace.DatabaseName)
           .LogTo(Console.WriteLine)
           .EnableSensitiveDataLogging()
           .Options);
</code></pre>
<p>这样，当我们再次运行程序时，我们就可以看到以下内容作为详细日志的一部分：</p>
<pre><code>Executed MQL query
sample_mflix.movies.aggregate([{ "$match" : { "rated" : "PG-13", "plot" : /shark/s } }, { "$sort" : { "title" : 1 } }])
</code></pre>
<h3 id="自动事务和乐观并发">自动事务和乐观并发</h3>
<p>是的，你没看错！MongoDB EF Core 提供程序从其 8.1.0 版本开始支持事务和乐观并发。这意味着默认情况下，<code>SaveChanges</code> 和 <code>SaveChangesAsync</code> 是事务性的。这将使生产级工作负载中的操作在发生任何故障时自动回滚，并确保所有操作都以<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener nofollow">乐观并发</a>的方式完成。</p>
<p>如果您想关闭事务，您可以在调用任何 <code>SaveChanges</code> 操作之前的初始化阶段进行关闭。</p>
<pre><code>db.Database.AutoTransactionBehavior = AutoTransactionBehavior.Never;
</code></pre>
<p>根据您的需求，提供程序支持两种乐观并发方法，即通过并发检查或行版本。您可以<a href="https://www.mongodb.com/docs/entity-framework/current/fundamentals/optimistic-concurrency/" target="_blank" rel="noopener nofollow">在文档中</a>阅读更多相关信息。我们将使用 RowVersion 来演示此用例。这将利用模型类中的 <code>Version</code> 字段，该字段将由 MongoDB EF 提供程序自动更新。要添加版本，我们将以下内容添加到模型类中。</p>
<pre><code> [Timestamp]
 public long? Version { get; set; }
</code></pre>
<p>首先，让我们创建一个名为 <code>myMovie</code> 的新电影实体，如下所示，并将其添加到 <code>DbSet</code>，然后添加 <code>SaveChangesAsync</code>。</p>
<pre><code>Movie myMovie1= new Movie {
    Title = "The Rise of EF Core 1",
    Plot = "Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology.",
    Rated = "G"
};

db.Movies.Add(myMovie1);
await db.SaveChangesAsync();
</code></pre>
<p>现在，让我们创建一个类似于上面创建的 <code>DbContext</code> 的新 DbContext。我们可以将数据库创建移到变量中，这样我们就不必再次定义数据库的名称。有了这个新上下文，让我们为电影添加续集并将其添加到 DbSet。我们还将添加第三部分（是的，这是三部曲），但使用与第二部电影实体相同的 ID 到这个新上下文，然后保存我们的更改。</p>
<pre><code>var dbContext2 = MflixDbContext.Create(database);
dbContext2.Database.AutoTransactionBehavior = AutoTransactionBehavior.Never;
var myMovie2 = new Movie { title = "The Rise of EF Core 2" };
dbContext2.Movies.Add(myMovie2);

var myMovie3 = new Movie { Id = myMovie2.Id,Title = "The Rise of EF Core 3" };
dbContext2.Movies.Add(myMovie3);
await dbContext2.SaveChangesAsync();
</code></pre>
<p>现在支持事务了，对于后两个电影实体的第二组操作不应该通过，因为我们试图用已经存在的 <code>_id</code> 添加它们。我们应该看到一个异常，事务应该只在我们的数据库中看到一部电影。让我们运行一下，看看这是否属实。</p>
<p>我们正确地看到了一个异常，我们可以确认我们只有一部电影（第一部分）插入了数据库。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122155751-1849806265.png" alt="" loading="lazy"></p>
<p>由于事务已回滚，以下仅显示数据库中的单个文档。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122205216-593866209.png" alt="" loading="lazy"></p>
<p>别担心，我们会正确地将我们的三部曲添加到数据库中。让我们删除第三个实体上的 <code>_id</code> 分配，让 MongoDB 自动为我们插入它。</p>
<pre><code>var myMovie3 = new Movie { Title = "The Rise of EF Core 3" };
</code></pre>
<p>一旦我们重新运行该程序，我们可以看到所有实体都已添加到数据库中。</p>
<p><img src="https://img2024.cnblogs.com/blog/1412316/202502/1412316-20250201122216222-697636113.png" alt="" loading="lazy"></p>
<h2 id="摘要">摘要</h2>
<p>我们能够使用 <a href="https://www.mongodb.com/docs/drivers/csharp/current/" target="_blank" rel="noopener nofollow">MongoDB EF Core 提供程序</a>和 <a href="https://www.mongodb.com/products/platform/atlas-database" target="_blank" rel="noopener nofollow">MongoDB Atlas</a> 来展示不同的功能，例如动态向实体添加属性、利用 Escape Hatch 创建索引、通过 LINQ 执行复杂查询以及演示新添加的事务和乐观并发支持。</p>
<h2 id="了解更多">了解更多</h2>
<p>要了解有关 EF Core 和 MongoDB 的更多信息：</p>
<ul>
<li>请参阅 <a href="https://learn.microsoft.com/ef/core/" target="_blank" rel="noopener nofollow">EF Core 文档</a>，了解有关使用 EF Core 访问各种数据库的更多信息。</li>
<li>请参阅 <a href="https://www.mongodb.com/docs/" target="_blank" rel="noopener nofollow">MongoDB 文档</a>，了解有关从任何平台使用 MongoDB 的更多信息。</li>
<li>有关如何开始的更多信息，请参阅 <a href="https://www.mongodb.com/docs/entity-framework/current/quick-start/" target="_blank" rel="noopener nofollow">MongoDB EF Core 提供程序文档</a>。</li>
<li>在 Microsoft Youtube 频道上观看有关 <a href="https://www.youtube.com/watch?v=LuvdiUggQrU&amp;list=PLdo4fOcmZ0oUZz7p8H1HsQjgv5tRRIvAS&amp;index=19" target="_blank" rel="noopener nofollow">EF Core 9：在 .NET 中发展数据访问</a>的演讲。</li>
</ul>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://devblogs.microsoft.com/dotnet/mongodb-ef-core-provider-whats-new/" target="_blank" rel="noopener nofollow">MongoDB EF Core Provider: What’s New?</a></p>
<p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener nofollow"><img alt="知识共享许可协议" style="border-width: 0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener nofollow">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
<p>欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： <a href="http://www.cnblogs.com/MingsonZheng/" target="_blank">http://www.cnblogs.com/MingsonZheng/</a> ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。</p>
<p>如有任何疑问，请与我联系 (<a href="mailto:MingsonZheng@outlook.com" target="_blank" rel="noopener nofollow">MingsonZheng@outlook.com</a>)</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.17758853885532408" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-01 20:00">2025-02-01 20:00</span>&nbsp;
<a href="https://www.cnblogs.com/MingsonZheng">郑子铭</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18696241" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18696241);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18696241', targetLink: 'https://www.cnblogs.com/MingsonZheng/p/18696241', title: '【译】MongoDB EF Core 提供程序：有什么新功能？' })">举报</a>
</div>
        