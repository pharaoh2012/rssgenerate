
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/geek1116/p/18627931" title="发布于 2024-12-24 23:42">
    <span role="heading" aria-level="2">基于Three.js的大屏3D地图（一）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="依赖安装">依赖安装</h2>
<pre><code class="language-shell">yarn add three
yarn add @types/three
yarn add d3-geo
</code></pre>
<p><code>three</code>库安装后在<code>node_modules</code>下其还包含核心<code>three/src</code>和插件<code>three/example/jsm</code>的源码，在开发调试时可以直接查阅。使用Three.js过程中会涉及到许多的类、方法及参数配置，所以建议安装<code>@types/three</code>库；不仅能提供类型提示，还有助于加快理解Three.js中的众多概念及关联关系。</p>
<p><code>d3-geo</code>是<code>d3</code>库中独立出来专门用于处理地理数据可视化的模块。我们需要使用<code>d3-geo</code>中的部分方法来对原始的经纬度数据做<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BA%A5%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1%E6%B3%95&amp;oldformat=true&amp;variant=zh-cn" target="_blank" rel="noopener nofollow">墨卡托投影</a>以在二维平面上正确定位。</p>
<h2 id="数据处理">数据处理</h2>
<h3 id="geojson数据">GeoJSON数据</h3>
<p>我们是通过<a href="https://geojson.org/" target="_blank" rel="noopener nofollow">GeoJSON</a>数据格式来绘制地图的。在开发测试阶段可以直接从<a href="https://datav.aliyun.com/portal/school/atlas/area_selector" target="_blank" rel="noopener nofollow">阿里云的DataV地理工具</a>中在线获取地图数据。</p>
<p>获取到的GeoJSON格式框架如下：</p>
<pre><code class="language-json">{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "adcode": 110000,
        "name": "北京市",
        "center": [116.405285, 39.904989],
        "centroid": [116.41995, 40.18994]
      },
      "geometry": {
        "type": "MultiPolygon",
        "coordinates": [[[[]]]]
      }
    }
  ]
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155317530-1894644655.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155323714-1663849528.png" alt="" loading="lazy"></p>
<p>我们处理地图数据需要考虑的是<code>MultiPolygon</code>和<code>Polygon</code>类型。</p>
<h3 id="墨卡托投影">墨卡托投影</h3>
<p>经纬度坐标是记录某点在地球表面这一“曲面”结构上的确切位置，如果我们直接使用这些点坐标在二维平面上绘制是会产生形变的，因而需要先对所有的坐标做一次墨卡托投影转换以使它们能够在同一平面上展示。</p>
<p>在渲染地图前还要确保地图位于场景的中心，因此需要先计算出当前地图数据的中心点，将该中心点作为投影中心：</p>
<pre><code class="language-typescript">/**
 * 计算边界和中心位置
 */
calcSide(geojson: any) {
    const mapSideInfo = this.mapSideInfo = { minLon: Infinity, maxLon: -Infinity, minLat: Infinity, maxLat: -Infinity }
    const { features } = geojson
    features.forEach(feature =&gt; {
        const { coordinates, type } = feature.geometry

        coordinates.forEach(coordinate =&gt; {
            if(type === "MultiPolygon") coordinate.forEach(item =&gt; dealWithCoord(item))
            if(type === "Polygon") dealWithCoord(coordinate)
        })
    })

    this.centerPos = {
        x: (mapSideInfo.maxLon + mapSideInfo.minLon) / 2,
        y: (mapSideInfo.maxLat + mapSideInfo.minLat) / 2
    }


    function dealWithCoord(lonlatArr) {
        lonlatArr.forEach(([lon, lat]) =&gt; {
            if(lon &gt; mapSideInfo.maxLon) mapSideInfo.maxLon = lon
            if(lon &lt; mapSideInfo.minLon) mapSideInfo.minLon = lon
            if(lat &gt; mapSideInfo.maxLat) mapSideInfo.maxLat = lat
            if(lat &lt; mapSideInfo.minLat) mapSideInfo.minLat = lat
        })
    }
}
</code></pre>
<p>得出中心位置后，调用<code>d3-geo</code>的<code>geoMercator</code>生成转换方法：</p>
<pre><code class="language-typescript">this.coordTrans = geoMercator().center([this.centerPos.x, this.centerPos.y]).translate([0, 0])
</code></pre>
<p>将中心点坐标作为参数传入<code>center()</code>后返回一个变更了投影中心的新方法。接着我们还需要调用<code>translate</code>来修改默认的偏移量（见文档：<a href="https://d3js.org/d3-geo/projection#projection_translate" target="_blank" rel="noopener nofollow">https://d3js.org/d3-geo/projection#projection_translate</a> ）</p>
<br>
<h2 id="绘制地图">绘制地图</h2>
<h3 id="基础场景搭建">基础场景搭建</h3>
<pre><code class="language-typescript">init(initData: confData) {
    const { width, height, container } = initData
    this.cfg = initData

    // 创建场景与透视相机
    const scene = new THREE.Scene()
    this.scene = scene
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000)
    camera.position.set(0, 0, 200)
    this.camera = camera
    // Webgl渲染器
    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(width, height)
    this.renderer = renderer
    // 轨道控制器
    new OrbitControls(camera, renderer.domElement)

    container.appendChild(renderer.domElement)

    // 2D渲染器
    const labelRenderer = new CSS2DRenderer()
    labelRenderer.domElement.style.position = "absolute"
    labelRenderer.domElement.style.top = "0px"
    labelRenderer.domElement.style.pointerEvents = "none"
    labelRenderer.setSize(width, height)
    container.appendChild(labelRenderer.domElement)
    this.css2DRenderer = labelRenderer

    // 开启循环渲染帧
    const animate = () =&gt; {
        renderer.render(scene, camera)
        labelRenderer.render(scene, camera)

        this.requestID = requestAnimationFrame(animate)
    }
    animate()
}
</code></pre>
<p>在开发阶段还可以引入坐标轴和性能检测面板来辅助开发：</p>
<pre><code class="language-typescript">// 坐标轴参考
this.axesHelper = new THREE.AxesHelper(150)
this.scene.add(this.axesHelper)
// 性能监测
this.stats = new Stats()
this.cfg.container.appendChild(this.stats.dom)

const animate = () =&gt; {
    // ...
    this.stats?.update()
}
</code></pre>
<h3 id="绘制平面地图">绘制平面地图</h3>
<p>首先利用<code>THREE.Shape</code>对象根据GeoJSON中的所有点连接成线，构造出地图在平面的轮廓：</p>
<pre><code class="language-typescript">createMapModel(geojson) {
    features.forEach(feature =&gt; {
        const { coordinates, type } = feature.geometry

        coordinates.forEach(coordinate =&gt; {
            if(type === "MultiPolygon") coordinate.forEach(item =&gt; dealWithCoord(item))
            if(type === "Polygon") dealWithCoord(coordinate)
        })
    })
    
    function dealWithCoord(lonlatArr) {
        const pieceMesh = _this.createPieceMesh(lonlatArr)
        _this.scene.add(pieceMesh)
    }
}

createPieceMesh(lonlatArr) {
    // 绘制区块形状
    const shape = new THREE.Shape()
    lonlatArr.forEach((lonlat, index) =&gt; {
        let [x, y] = this.coordTrans(lonlat)
        y = -y

        if(!index) shape.moveTo(x, y)
        else shape.lineTo(x, y)
    })
    
    // todo
}
</code></pre>
<h3 id="threeextrudegeometry挤出三维效果">THREE.ExtrudeGeometry挤出三维效果</h3>
<p>有用过Blender或3DMax之类三维设计软件的同学应该对<em>Extrude</em>挤出操作不陌生，该操作就是将模型上的某一个平面沿着其法线方向拉伸出来。ThreeJS中有一个<code>ExtrudeGeometry</code>方法可以达到同样的目的。我们直接用下面的动图来生动展示下是如何从二维平面上挤出3D地图的：</p>
<pre><code class="language-typescript">createPieceMesh(lonlatArr: number[][]): THREE.Mesh {
    // 绘制区块形状
    // ...

    // 构造几何体
    const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: this.cfg.depth,
        bevelEnabled: false
    })

    const material = new THREE.MeshBasicMaterial({ color: 0xffffff })
    const mesh = new THREE.Mesh(geometry, material)
    return mesh
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155345370-1371371152.gif" alt="" loading="lazy"></p>
<h2 id="描边">描边</h2>
<p>上一步渲染的模型是纯白色材质的，为了方面观察还加上了黑色描边，下面补上代码：</p>
<pre><code class="language-typescript">createLine(lonlatArr: number[][]) {
    const points: number[] = []
    lonlatArr.forEach(lonlat =&gt; {
        let [x, y] = this.coordTrans(lonlat)
        y = -y
        points.push(x, y, 0)
    })
    
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points)
    const meterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
    
    const line = new THREE.Line(lineGeometry, meterial)
    return line
}
</code></pre>
<h3 id="线宽问题">线宽问题</h3>
<p>线条材质的参数中有一个<code>linewidth</code>，可以供我们配置线条的宽度。但在实际使用中发现线宽只能固定为1不变，官方文档中给出了如下解释：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155414600-1901668004.png" alt="" loading="lazy"></p>
<p>同时也给出了解决方案，可以使用拓展包中的<code>Line2</code>来渲染不同宽度的线条：</p>
<pre><code class="language-typescript">import { Line2 } from 'three/examples/jsm/lines/Line2'
import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry'
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial'

createLine(lonlatArr: number[][]) {
    const points: number[] = []
    lonlatArr.forEach(lonlat =&gt; {
        let [x, y] = this.coordTrans(lonlat)
        y = -y
        points.push(x, y, 0)
    })

    const lineGeometry = new LineGeometry()
    lineGeometry.setPositions(points)

    const lineMaterial = new LineMaterial({ color: 0x000000, linewidth: 2 })
    const line = new Line2(lineGeometry, lineMaterial)
    line.position.z = this.cfg.depth + 0.01

    return line
}
</code></pre>
<h3 id="linegeometry缺陷">LineGeometry缺陷</h3>
<p>在构造<code>LineGeometry</code>时需要注意使用的是<code>setPositions</code>方法而不是<code>setFromPoints</code>。在three.js的171版本之前是不能使用<code>setFromPoints</code>方法来构造geometry的。</p>
<pre><code class="language-typescript">const points: THREE.Vector3[] = []
lonlatArr.forEach(lonlat =&gt; {
    let [x, y] = this.coordTrans(lonlat)
    y = -y
    points.push(new THREE.Vector3(x, y, 0))
})

// Error:
const lineGeometry = new LineGeometry()
lineGeometry.setFromPoints(points)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155444183-423943574.png" alt="" loading="lazy"></p>
<p>因为<code>LineGeometry</code>是继承自<a href="https://github.com/mrdoob/three.js/blob/dev/examples/jsm/lines/LineSegmentsGeometry.js#L30" target="_blank" rel="noopener nofollow">LineSegmentsGeometry</a>，但该类在实例化中会有预设的<code>position</code>属性，从而导致执行<code>setFromPoints</code>时发生数组下标越界的问题：<a href="https://github.com/mrdoob/three.js/commit/add7f9ba79a7f23732cf6e9e25ebcd4987550d45%E3%80%82" target="_blank" rel="noopener nofollow">https://github.com/mrdoob/three.js/commit/add7f9ba79a7f23732cf6e9e25ebcd4987550d45。</a></p>
<br>
<h2 id="为地图正面和侧面应用不同的样式">为地图正面和侧面应用不同的样式</h2>
<p>目前为止我们的地图有一种样式，整个模型表面都是白色的。</p>
<pre><code class="language-typescript">const material = new THREE.MeshBasicMaterial({ color: 0xffffff })	// 纯白色材质
const mesh = new THREE.Mesh(geometry, material)
</code></pre>
<p>我们的大屏3D地图需要更为多样的表现，能对模型正面侧面应用上不同的样式。官方文档在<code>ExtrudeGeometry</code>构造函数的下面有这么一段说明：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155501308-288194772.png" alt="" loading="lazy"></p>
<p>在构造<code>Mesh</code>对象的第二个参数中传入材质数组的话，则可以将不同材质分别应用到模型的正面和侧面。我们用一个泥红色的半透明材质用作正面材质，草绿色材质用于侧面，渲染出一副水彩风格的地图：</p>
<pre><code class="language-typescript">const material = new THREE.MeshBasicMaterial({
    color: 0xdd8787,
    transparent: true,	// 开启透明度
    opacity: 0.7
})
const materialSide = new THREE.MeshBasicMaterial({
    color: 0x9bda8c
})

// ...

const mesh = new THREE.Mesh(geometry, [material, materialSide])
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155540769-728957339.png" alt="" loading="lazy"></p>
<br>
<h2 id="纹理贴图">纹理贴图</h2>
<p>创建材质<code>Material</code>的时候除了可以通过<code>color</code>字段配置颜色，还可以通过<code>map</code>字段传入<code>Texture</code>对象来为模型贴上贴图。</p>
<pre><code class="language-typescript">const material = new THREE.MeshBasicMaterial({
    map: new THREE.TextureLoader().load('./top_image.jpg')
})
const materialSide = new THREE.MeshBasicMaterial({
    map: new THREE.TextureLoader().load('./side_image.jpg')
})

// ...

const mesh = new THREE.Mesh(geometry, [material, materialSide])
</code></pre>
<p>读者可以用任意图片用作贴图看下渲染的效果，会发现贴图以一种非常奇怪的方式拉伸。这是因为我们没有定义好模型的<a href="https://zh.wikipedia.org/zh-cn/UV%E6%98%A0%E5%B0%84" target="_blank" rel="noopener nofollow">UV映射</a>坐标，即<code>geometry.attributes.uv</code>；该属性定义了应该如何将纹理贴图上的像素应用在我们的模型表面。</p>
<p>为了方便讲解，笔者这里不使用地图数据构造的<code>geometry</code>，而是一个相对更加简单的几何体：</p>
<pre><code class="language-typescript">const shape = new THREE.Shape()
shape.moveTo(-4, 4)
shape.lineTo(-4, -4)
shape.lineTo(4, -4)
shape.lineTo(4, 1)
shape.lineTo(1, 1)
shape.lineTo(1, 4)

const shape2 = new THREE.Shape()
shape2.moveTo(3, 4)
shape2.lineTo(4, 4)
shape2.lineTo(4, 3)
shape2.lineTo(3, 3)

const m1 = new THREE.MeshLambertMaterial({ color: 0xF0B5B5 }), m2 = new THREE.MeshLambertMaterial({ color: 0xffffff })
const geometry = new THREE.ExtrudeGeometry(shape, { depth: this.cfg.depth, bevelEnabled: false })
const geometry2 = new THREE.ExtrudeGeometry(shape2, { depth: this.cfg.depth, bevelEnabled: false })
const mesh = new THREE.Mesh(geometry, [m1, m2])
const mesh2 = new THREE.Mesh(geometry2, [m1, m2])
this.scene.add(mesh, mesh2)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155556615-351876004.png" alt="" loading="lazy"></p>
<p>接着为这两个几何体应用下面的UV测试图片作为纹理贴图：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155603151-210801197.jpg" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155615228-549912408.gif" alt="" loading="lazy"></p>
<p>可以看到我们的UV测试图只以1X1单位大小显示在模型表面上的一小部分地方，其他部分则由图片的四边拉伸填充至整个表面。而另外还有某些面连贴图都无法完整显示。</p>
<p>将几何体的<code>position</code>及<code>uv</code>属性打印出来：</p>
<pre><code class="language-typescript">console.log(mesh.geometry.getAttribute('position'))
console.log(mesh.geometry.getAttribute('uv'))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155634602-566892411.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155641684-1910204138.png" alt="" loading="lazy"></p>
<p>可以看到uv值并不都在[0-1]的区间内。对于uv值小于0的区域，会直接从贴图u/v坐标=0处采样像素点填充；同理，大于1的区域则是从u/v坐标=1处采样。这也就是上一步中贴图被异常拉伸的原因。</p>
<p>那么，打印的这些uv属性是如何得来的呢？我们看回文档<code>ExtrudeGeometry</code>的构造函数中有一个<code>UVGenerator</code>选项：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155653150-670365157.png" alt="" loading="lazy"></p>
<p>通过<code>ExtrudeGeometry</code>对象生成几何体时可以传入<code>UVGenerator</code>函数来决定几何体的uv应该如何计算。但文档中并没有进一步介绍该函数如何使用，需要直接看源码才能知道细节。打开<code>ExtrudeGeometry</code>的源码处，在构造函数中有这么一行对uv生成函数的处理逻辑<a href="https://github.com/mrdoob/three.js/blob/dev/src/geometries/ExtrudeGeometry.js" target="_blank" rel="noopener nofollow">[constructor -&gt; addShape]</a>：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155710469-963462833.png" alt="" loading="lazy"></p>
<p>在外部没有传入<code>UVGenerator</code>的情况下则会使用内置的<code>WorldUVGenerator</code> 。在<code>WorldUVGenerator</code>中有<code>generateTopUV</code>和<code>generateSideWallUV</code>两个函数分别用于定义顶面和侧面的uv生成逻辑：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155805597-1789387360.png" alt="" loading="lazy"></p>
<p>结合命名和代码大致逻辑很容易看出来，默认的生成规则其实就是根据世界坐标的x/y/z值来作为uv值。顶面的生成规则很简单，直接使用顶点的xy坐标值用作uv值。侧面的生成规则相对复杂些，需要考虑前两个顶点的x/y值的差异量来判断是x·z平面来用作贴图还是y·z平面。</p>
<h3 id="侧面纹理">侧面纹理</h3>
<p>既然可以自定义UV生成规则，就好解决了。我们先从<code>generateSideWallUV</code>开始。对于<code>ExtrudeGeometry</code>中的每一个侧面矩形，都会调用一次<code>generateSideWallUV</code>，传入的四个顶点下标<code>index</code>顺序是固定的：<strong>从该侧边平面的法线方向观察（即我们Extrude出来的几何体面向摄像机的一面，另一面默认是不可见的），垂直于shape平面的边作为底边来看的话，读取顺序是从左下角逆时针开始</strong>。</p>
<p>明白了上述原理后，结合笔者的需求：对于上传的侧面贴图，应用到每一个侧面并将其撑满。修改后的<code>generateSideWallUV</code>代码就很简单了：</p>
<pre><code class="language-typescript">generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    return [
        new Vector2(0, 0),
        new Vector2(1, 0),
        new Vector2(1, 1),
        new Vector2(0, 1)
    ]
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155823820-1389541809.gif" alt="" loading="lazy"></p>
<h3 id="顶面纹理">顶面纹理</h3>
<p>顶面的贴图需求和侧面类似，也是期望贴图能够撑满该面。有所不同的是顶面不是像侧面那样的矩形，而是一个不规则形状。需要知道顶面的“包围矩形”，然后让贴图撑满该矩形，就能达到我们的目的。</p>
<p>在ThreeJS中有一个<code>Box3</code>类可以帮助我们计算场景中物体的包围盒：</p>
<pre><code class="language-typescript">const box = new THREE.Box3()
box.setFromObject(this.scene)
const size = new THREE.Vector3()
box.getSize(size)

console.log('box: ', box)
console.log('size: ', size)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155849360-85557272.png" alt="" loading="lazy"></p>
<p>有了包围盒信息后就可以计算顶面中每个顶点所对应的UV值了。但是笔者这里不打算调整默认的<code>generateTopUV</code>；相较于在每次调用的<code>generateTopUV</code>中做计算，我们可以在创建纹理的时候就配置好它的缩放及偏移量：</p>
<pre><code class="language-typescript">const texture = new THREE.TextureLoader().load('./uv_test.jpg')
texture.colorSpace = THREE.SRGBColorSpace

const box = new THREE.Box3()
box.setFromObject(this.mapPieceGroup)
const size = new THREE.Vector3()
box.getSize(size)

texture.repeat.set(1 / size.x, 1 / size.y)
texture.offset.set(Math.abs(box.min.x / size.x), Math.abs(box.min.y / size.y))
</code></pre>
<p><code>texture.repeat</code>的传参可以是小于1的值，相当于将贴图放大了。传入<code>1 / size.x, 1 / size.y</code>使得贴图的宽高同顶面的包围矩形一样。</p>
<p>接着设置纹理偏移<code>texture.offset</code>，使得缩放后的贴图和包围矩形对齐。</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155858137-1999848534.png" alt="" loading="lazy"></p>
<p>至此，纹理贴图也大功告成。让我们回到3D地图配置，整合本文的所有代码，根据设计图和相应的素材，检验下我们的demo成果：</p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155904343-419801423.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/841228/202412/841228-20241224155917772-405251623.gif" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02026711955439815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 23:47">2024-12-24 23:42</span>&nbsp;
<a href="https://www.cnblogs.com/geek1116">爱喝可乐的咖啡</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18627931" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18627931);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18627931', targetLink: 'https://www.cnblogs.com/geek1116/p/18627931', title: '基于Three.js的大屏3D地图（一）' })">举报</a>
</div>
        