
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaoxi666/p/18946775" title="发布于 2025-06-24 20:20">
    <span role="heading" aria-level="2">使用Lean4进行形式化建模（以Java线程池为例）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">前言</span></span></h1>
<p data-tool="mdnice编辑器">前段时间，我们处理了一则Java线程池配置不当导致的线上问题（参见 <a href="https://mp.weixin.qq.com/s/v_VZRhX2HVb-lAPTzzpZDg" target="_blank" rel="noopener nofollow">好端端的线程池，怎么就卡死了？</a>），本文将以此为案例，使用形式化语言，从数学角度进行证明。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">形式化证明简介</span></span></h1>
<p data-tool="mdnice编辑器">首先需要搞清楚一个概念，形式化证明，也是通过编程的形式进行的，只不过这段代码使用形式化编程语言进行表达，从数理层面来看更为严谨，常见的形式化语言有：</p>
<ul data-tool="mdnice编辑器">
<li>Coq：广泛用于学术研究和软件形式化验证，历史悠久。</li>
<li>Lean4：最近在数学界引起了广泛关注，适合开发严格的数学证明。</li>
<li>Dafny：与C#和Java有相似的语法，适合编程语言内置规范。</li>
<li>ACSL：基于C语言的注释，适合进行语法和语义检查。</li>
<li>TLA+：用于建模算法和程序的形式语言，特别适合并发和分布式系统。</li>
</ul>
<p data-tool="mdnice编辑器">某些领域也有特定的工具，比如 Java Pathfinder (JPF) 用于Java程序的形式化验证，支持线程和并发的验证。</p>
<p>鉴于Lean4使用最为广泛，本次首先使用Lean4进行尝试。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">Lean4 的安装</span></span></h1>
<p data-tool="mdnice编辑器">Lean4 可以在 vscode 中安装使用，也需要安装 Mathlib 数学库（类似于我们常用的三方依赖库）。本节将介绍其安装和使用方法。</p>
<blockquote class="custom-blockquote multiquote-1" data-tool="mdnice编辑器">
<p>Lean4 也有网页版 https://live.lean-lang.org/，但实测网站响应速度较差，推荐本地安装使用。</p>
</blockquote>
<ol data-tool="mdnice编辑器">
<li>安装 vscode，我们使用这个 IDE 创建和运行 Lean 工程。</li>
<li>安装 Lean4 插件：打开 vscode 中的插件市场，搜索 Lean4，点击安装。</li>
</ol><img src="https://files.mdnice.com/user/102576/4475c184-a174-400d-a3af-117646482b63.png" alt=""><ol start="3" data-tool="mdnice编辑器">
<li>安装 elan：它是Lean4版本管理工具，类似于node里面的nvm。到官方网站 https://github.com/leanprover/elan?tab=readme-ov-file#elan-lean-version-manager 参考即可：</li>
</ol><img src="https://files.mdnice.com/user/102576/804f780a-2da9-4613-935b-f6904e9091e7.png" alt=""><ol start="4" data-tool="mdnice编辑器">
<li>配置 mathlib：创建项目时使用 lean 的项目构建工具，指定 mathlib4，会自动安装 mathlib 依赖包：</li>
</ol>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">lake&nbsp;+leanprover-community/mathlib4:lean-toolchain&nbsp;new&nbsp;&lt;your_project_name&gt;&nbsp;math<br></code></pre>
<p data-tool="mdnice编辑器">到这里，就可以开始编写 Lean 代码了（vscode会启动lean4服务器，允许即可）。</p>
<p data-tool="mdnice编辑器">常用功能：</p>
<img src="https://files.mdnice.com/user/102576/3c0d954a-4da0-442e-94b0-7f924bb54183.png" alt="">
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">形式化证明</span></span></h1>
<p data-tool="mdnice编辑器">前面我们遇到的问题是：当任务数量大于线程池的核心线程数量后，由于任务间的依赖关系导致线程无法释放，最终导致新提交的任务被放到无界阻塞队列中，无法得到处理，最终系统处于假死状态。</p>
<p data-tool="mdnice编辑器">为验证线程池资源是否存在资源耗尽的漏洞，可以参考如下Prompt（比较粗糙，作为示例已经够用了），让AI编写一段 Lean4 形式化代码：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">你是形式化证明专家，也是各种语言编程专家，尤其精通Java和Lean4。<br><br>我想用一段Lean4脚本验证：<br><br>配置场景：定义了一个线程池，其核心线程数为5、配置了无界阻塞队列、最大线程数为&nbsp;Integer.MAX_VALUE（约21亿）<br><br>验证场景：当任务数量大于线程池的数量时，任务就会卡死，因为后续的节点已经没有线程可用了，对应的任务始终无法完成，因此已经被占用的线程无法释放（因为属于同一个任务）。此后继续提交的新任务会被放到无界阻塞队列中，表现出来就是系统处于假死状态。<br><br>请写一段Lean4程序。务必保持简洁。<br></code></pre>
<blockquote class="custom-blockquote multiquote-1" data-tool="mdnice编辑器">
<p>为降低理解难度，做了一定程度的简化。</p>
</blockquote>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">import&nbsp;Mathlib.Data.Real.Basic<br><br>structure&nbsp;ThreadPool&nbsp;<span class="hljs-built_in">where<br>&nbsp;&nbsp;corePoolSize&nbsp;:&nbsp;ℕ<br>&nbsp;&nbsp;maxPoolSize&nbsp;:&nbsp;ℕ<br>&nbsp;&nbsp;unboundedQueue&nbsp;:&nbsp;Bool&nbsp;:=&nbsp;<span class="hljs-literal">true&nbsp;&nbsp;--&nbsp;<span class="hljs-literal">true&nbsp;表示无界队列<br><br>def&nbsp;isDeadlocked&nbsp;(pool&nbsp;:&nbsp;ThreadPool)&nbsp;(tasks&nbsp;:&nbsp;ℕ)&nbsp;:&nbsp;Prop&nbsp;:=<br>&nbsp;&nbsp;pool.corePoolSize&nbsp;&lt;&nbsp;tasks&nbsp;∧<br>&nbsp;&nbsp;pool.unboundedQueue&nbsp;∧<br>&nbsp;&nbsp;pool.maxPoolSize&nbsp;&gt;=&nbsp;pool.corePoolSize<br><br>theorem&nbsp;unbounded_queue_causes_deadlock&nbsp;:<br>&nbsp;&nbsp;∃&nbsp;(pool&nbsp;:&nbsp;ThreadPool)&nbsp;(tasks&nbsp;:&nbsp;ℕ),<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.corePoolSize&nbsp;=&nbsp;5&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.maxPoolSize&nbsp;=&nbsp;2147483647&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.unboundedQueue&nbsp;=&nbsp;<span class="hljs-literal">true&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;tasks&nbsp;&gt;&nbsp;5&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;isDeadlocked&nbsp;pool&nbsp;tasks&nbsp;:=<br>by<br>&nbsp;&nbsp;<span class="hljs-built_in">let&nbsp;pool&nbsp;:&nbsp;ThreadPool&nbsp;:=&nbsp;{&nbsp;corePoolSize&nbsp;:=&nbsp;5,&nbsp;maxPoolSize&nbsp;:=&nbsp;2147483647,&nbsp;unboundedQueue&nbsp;:=&nbsp;<span class="hljs-literal">true&nbsp;}<br>&nbsp;&nbsp;use&nbsp;pool,&nbsp;6<br>&nbsp;&nbsp;simp&nbsp;[isDeadlocked]<br>&nbsp;&nbsp;constructor&nbsp;&lt;;&gt;&nbsp;trivial<br></span></span></span></span></span></span></code></pre>
<p data-tool="mdnice编辑器">解释一下：</p>
<p data-tool="mdnice编辑器"><code>1. import Mathlib.Data.Real.Basic</code>：导入数学库（本例会使用实数定义，因此需要导入）;</p>
<p data-tool="mdnice编辑器"><code>2. structure</code>定义线程池结构：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">structure&nbsp;ThreadPool&nbsp;<span class="hljs-built_in">where<br>&nbsp;&nbsp;corePoolSize&nbsp;:&nbsp;ℕ<br>&nbsp;&nbsp;maxPoolSize&nbsp;:&nbsp;ℕ<br>&nbsp;&nbsp;unboundedQueue&nbsp;:&nbsp;Bool&nbsp;:=&nbsp;<span class="hljs-literal">true&nbsp;&nbsp;--&nbsp;<span class="hljs-literal">true&nbsp;表示无界队列<br></span></span></span></code></pre>
<p>3. 定义死锁条件（符号<code>∧</code>表示 “与”）:</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">def&nbsp;isDeadlocked&nbsp;(pool&nbsp;:&nbsp;ThreadPool)&nbsp;(tasks&nbsp;:&nbsp;ℕ)&nbsp;:&nbsp;Prop&nbsp;:=<br>&nbsp;&nbsp;pool.corePoolSize&nbsp;&lt;&nbsp;tasks&nbsp;∧<br>&nbsp;&nbsp;pool.unboundedQueue&nbsp;∧<br>&nbsp;&nbsp;pool.maxPoolSize&nbsp;&gt;&nbsp;pool.corePoolSize<br></code></pre>
<p>4. 声明定理和证明</p>
<p data-tool="mdnice编辑器">先了解一下声明定理的语法，属于三段式结构：<code>theorem name : Prop := proof</code>：</p>
<img src="https://files.mdnice.com/user/102576/2f9f9ea8-dc54-4c5b-87a6-8c9089347f40.png" alt="">
<p data-tool="mdnice编辑器">Prop 在我们的代码中对应：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">∃&nbsp;(pool&nbsp;:&nbsp;ThreadPool)&nbsp;(tasks&nbsp;:&nbsp;ℕ),<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.corePoolSize&nbsp;=&nbsp;5&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.maxPoolSize&nbsp;=&nbsp;2147483647&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;pool.unboundedQueue&nbsp;=&nbsp;<span class="hljs-literal">true&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;tasks&nbsp;&gt;&nbsp;5&nbsp;∧<br>&nbsp;&nbsp;&nbsp;&nbsp;isDeadlocked&nbsp;pool&nbsp;tasks<br></span></code></pre>
<p data-tool="mdnice编辑器">其中的符号<code>∃</code>表示存在性命题，翻译成人话就是：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">存在一个线程池&nbsp;pool&nbsp;和任务数&nbsp;tasks，满足以下所有条件时，会导致死锁（isDeadlocked）：<br>1.&nbsp;核心线程数&nbsp;=&nbsp;5<br>2.&nbsp;最大线程数&nbsp;=&nbsp;Integer.MAX_VALUE<br>3.&nbsp;使用无界队列<br>4.&nbsp;任务数&nbsp;&gt;&nbsp;5<br></code></pre>
<p data-tool="mdnice编辑器">然后构造具体例子，证明命题成立。对应的代码：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">&nbsp;&nbsp;<span class="hljs-built_in">let&nbsp;pool&nbsp;:&nbsp;ThreadPool&nbsp;:=&nbsp;{&nbsp;corePoolSize&nbsp;:=&nbsp;5,&nbsp;maxPoolSize&nbsp;:=&nbsp;2147483647,&nbsp;unboundedQueue&nbsp;:=&nbsp;<span class="hljs-literal">true&nbsp;}<br>&nbsp;&nbsp;use&nbsp;pool,&nbsp;6<br></span></span></code></pre>
<p data-tool="mdnice编辑器">其中，<code>let</code> 定义具体线程池实例参数，<code>use pool, 6</code>提供例子（核心线程5时，提交6个任务），就可以准备证明了。</p>
<p data-tool="mdnice编辑器">在随后的证明过程中，使用<code>simp [isDeadlocked]</code>把 isDeadlocked 的定义展开（类似于内联的概念），并自动把能计算出来的部分（比如 5 &lt; 6）直接化简成 True，让证明变简单。</p>
<p data-tool="mdnice编辑器">最后<code>constructor &lt;;&gt; trivial</code>的意思是：把目标拆成多个小条件（<code>constructor</code>），然后逐个（<code>&lt;;&gt;</code>）用“自动验证”（<code>trivial</code>，表示显然会成立的命题）解决。在我们的场景中：</p>
<ol data-tool="mdnice编辑器">
<li>目标是 5 &lt; 6 ∧ true ∧ 2147483647 &gt; 5。</li>
<li>constructor 将其拆成 3 个子目标：<code>5 &lt; 6</code>、<code>true</code>、<code>2147483647 &gt; 5</code>。</li>
<li>trivial 自动验证这些显然成立的子目标。</li>
</ol>
<p data-tool="mdnice编辑器">最终可以看到，我们定义的定理 unbounded_queue_causes_deadlock ，被成功地证明了：</p>
<img src="https://files.mdnice.com/user/102576/7f26b2c0-854f-4e93-9c13-973221ee3171.png" alt="">
<blockquote class="custom-blockquote multiquote-1" data-tool="mdnice编辑器">
<p>Lean4 与 Rust</p>
<p>大家可能已经发现，Lean4 与 Rust 这两种编程语言的语法非常相似，其实不仅如此，他们的工具链也很相似：比如 Lean 的版本管理工具elan，类似于 Rust 的 rustup； Lean 的包管理器和构建工具lake ，类似于 Rust 的 cargo）。熟悉 Rust 的同学狂喜，哈哈。</p>
</blockquote>
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">后记</span></span></h1>
<p data-tool="mdnice编辑器">2025年，随着大模型能力的提升，多家模型引入了形式化证明，用来验证大模型解决数学问题的能力，比较常见的训练方法是提供一段形式化代码，并挖去某些内容（或本身就存在待证明的部分），让大模型进行补充，然后验证它补充的内容是否能使得形式化证明通过（参见 <a href="https://mp.weixin.qq.com/s/9W96l135KTqIw8-JMf9x4Q" target="_blank" rel="noopener nofollow">DeepSeek又在节前放大招！</a>以及 <a href="https://zhuanlan.zhihu.com/p/1903048180444161236" target="_blank" rel="noopener nofollow">DeepSeek-Prover-V2：让 AI 学会严谨证明</a>）。这与我们的场景略有差异（我们是直接用大模型生成形式化验证代码，并且想办法用在工程领域）。</p>
<p data-tool="mdnice编辑器">在当下的 AI 浪潮中，我们可以借助大模型的能力，在实践过程中不断学习 Lean4 语法，不断构建工程领域的各种“定理”库，并进行开放复用。随着这个库的不断丰富，我们对业务领域的抽象和构建能力也会有所提升。</p>
<p data-tool="mdnice编辑器">需要说明的是，本文中的例子非常简单，大家可以作为入门材料参考。在实际的应用中，若要验证某个领域的执行逻辑是否符合预期（如状态机中的状态变化），需要精确理解领域含义和各种动作条件，才能做出明确的抽象，这个过程是比较费力的。不过恰恰在这个过程中，我们能够有机会从具体的业务实现中抽离出来，更为严谨地描述系统行为（从这个角度看，形式化证明与单元测试、集成测试等概念有相似之处）。</p>
<p data-tool="mdnice编辑器">另外，单纯靠 AI 写形式化代码会很痛苦，因为很难确认写出来的形式化代码是否正确，导致需要反复修改。因此，有必要熟悉特定形式化语言的语法和编写规范，就好比使用 AI 生成业务代码，需要具备一定的 Java/GoLang 等语言功底。</p>
<p data-tool="mdnice编辑器">说了这么多，好像还没提到形式化语言在工程领域的特定落地场景（因为还没完全想清楚）。先别急，我会继续探索 TLA+、Dafny、Coq 等形式化编程语言，看看哪种更适合软件领域的工程化落地，边实践边想。</p>
<p data-tool="mdnice编辑器">若有探索形式化方法应用落地的同学，欢迎交流。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"><span class="content">学习资源</span></span></h1>
<p data-tool="mdnice编辑器">一些 Lean4 学习资源，包括一些博客文章，以及官方的参考手册。</p>
<ul data-tool="mdnice编辑器">
<li><a href="https://zhuanlan.zhihu.com/p/669124637" rel="noopener nofollow">写给一般CS人的 Lean4 安利</a></li>
<li><a href="https://lean-lang.org/doc/reference/latest/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/" rel="noopener nofollow">The Lean Language Reference</a></li>
<li><a href="https://lean-lang.org/functional_programming_in_lean/" rel="noopener nofollow">Functional Programming in Lean</a></li>
<li><a href="https://subfish-zhou.github.io/theorem_proving_in_lean4_zh_CN/title_page.html" rel="noopener nofollow">Lean 4 定理证明</a></li>
<li><a href="https://leanprover-community.github.io/learn.html" rel="noopener nofollow">Learning Lean 4</a></li>
<li><a href="https://leanprover-community.github.io/mathlib4_docs/" rel="noopener nofollow">mathlib4_docs</a></li>
</ul>
</div>
<div id="MySignature" role="contentinfo">
    『注:本文来自博客园“小溪的博客”，若非声明均为原创内容，请勿用于商业用途，转载请注明出处http://www.cnblogs.com/xiaoxi666/』
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.001388888888888889" data-date-updated="2025-06-24 20:22">2025-06-24 20:20</span>&nbsp;
<a href="https://www.cnblogs.com/xiaoxi666">xiaoxi666</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18946775);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18946775', targetLink: 'https://www.cnblogs.com/xiaoxi666/p/18946775', title: '使用Lean4进行形式化建模（以Java线程池为例）' })">举报</a>
</div>
        