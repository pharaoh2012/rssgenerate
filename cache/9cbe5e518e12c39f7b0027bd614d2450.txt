
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/duyuanshang/p/18856762" title="发布于 2025-05-17 16:36">
    <span role="heading" aria-level="2">自制体积不到 2kB 的代码编辑器，areaEditor.js，增强 textarea 标签的代码编辑体验</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#起因" rel="noopener nofollow">起因</a></li><li><a href="#快速使用" rel="noopener nofollow">快速使用</a></li><li><a href="#缩进功能" rel="noopener nofollow">缩进功能</a></li><li><a href="#缩进类型" rel="noopener nofollow">缩进类型</a></li><li><a href="#自动补全括号" rel="noopener nofollow">自动补全括号</a></li><li><a href="#犯难" rel="noopener nofollow">犯难</a></li><li><a href="#自动补全" rel="noopener nofollow">自动补全</a></li><li><a href="#阻止补全" rel="noopener nofollow">阻止补全</a></li><li><a href="#编辑框抖动" rel="noopener nofollow">编辑框抖动</a></li><li><a href="#在空行按下删除键清空" rel="noopener nofollow">在空行按下删除键，清空</a></li><li><a href="#封装代码" rel="noopener nofollow">封装代码</a></li><li><a href="#怎么压缩-javascript-代码" rel="noopener nofollow">怎么压缩 JavaScript 代码</a></li><li><a href="#更多的功能" rel="noopener nofollow">更多的功能？</a></li></ul></div><p></p>
<h2 id="起因">起因</h2>
<p>前两天我搞的那个在线 HTML 新标签页预览功能 <a href="https://www.cnblogs.com/duyuanshang/p/18829312" target="_blank">https://www.cnblogs.com/duyuanshang/p/18829312</a> ，很好用，最近在我工作上帮了很大的忙，它可以让我不用打开本地代码编辑器就能快速调试一些前端代码，我也逐步完善它的了很多功能。可是，很快它就有了一个问题： 使用 <code>&lt;textarea&gt;</code> 写代码很不舒服。</p>
<p>当然，使用它来接受粘贴过后的代码还好，如果想再编辑一下、删删改改调整调整缩进，那简直难受死了。</p>
<p>最显而易见的解决方案，是使用一个第三方的 在线代码编辑器 的 js 库，像如 <a href="https://codemirror.net/" title="Code Mirror" rel="noopener nofollow">Code Mirror</a> 或 <a href="https://ace.c9.io/" title="Ace" rel="noopener nofollow">Ace</a> 这些成熟又著名的编辑器，可是..... 它们体积有点大，虽然大力压缩处理后也不过 100kb 左右，但依然重量级。</p>
<p>在很久以前，我就感觉到代码编辑框的重要性了，很多前端页面都会有在线写一些脚本的需求，如果使用频率非常高的话一般就引入第三方库了，但我真的不想引入，觉得德不配位，于是我看着那个 textarea 框开始发呆。我在想，有没有办法能让它在写代码时，体验好一点。</p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517150538748-1805162333.png" alt="image" loading="lazy"></p>
<p>于是这几天我就捣鼓了一个很迷你的 js 库，<a href="https://github.com/kohunglee/areaEditor" target="_blank" rel="noopener nofollow">https://github.com/kohunglee/areaEditor</a>  areaEditor.js，用着还真挺舒服。这个是一个演示 ： <a href="https://www.ccgxk.com/areaEditor.html" target="_blank" rel="noopener nofollow">https://www.ccgxk.com/areaEditor.html</a>  ，<strong>欢迎赏个 star ，谢谢您 Thanks♪(･ω･)ﾉ</strong></p>
<p><a href="https://github.com/kohunglee/areaEditor" rel="noopener nofollow"><img width="100px" src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517140603390-1976620324.png" alt="image">  👈🏻 单击这里</a></p>
<p>（又花了半个月，逐渐优化到能出山了，虽然用习惯了 IDE 的人可能觉得它用处不大，但 <code>textarea</code> 是真的没法用，况且它只有 2kb！小到忽略不计，作用却不容小觑，所以一定会有人能用到！）</p>
<h2 id="快速使用">快速使用</h2>
<p>只需这样即可：</p>
<pre><code class="language-html">&lt;script src="https://cdn.jsdelivr.net/gh/kohunglee/areaeditor/src/areaeditor.2.0.x.min.js" integrity="sha256-sP3tIYbNNHejSjhs3X0SBLULz54YEbR3g1dSJMvpCME=" crossorigin="anonymous"&gt;&lt;/script&gt;
&lt;script&gt;
    var editor = new AreaEditor('textarea', {indentType : { type: 'space', count: 4 }});
&lt;/script&gt;
</code></pre>
<p>这样，您的网页上所有的 <code>&lt;textarea&gt;</code> 就都可以缩进了。当然，<code>{indentType : { type: 'space', count: 4 }}</code> 是控制缩进的类型，<code>space</code> 是空格缩进，目前是 4 个空格。如果写成 <code>{indentType : { type: 'tab', count: 1 }}</code>，则是一个 <code>'\t'</code> TAB 制表符。</p>
<p>（不写这个配置，直接 <code>new AreaEditor('textarea')</code> 也可以，默认是 4 个空格 ）</p>
<p>后续也可以动态进行更改。比如：</p>
<pre><code class="language-javascript">editor.indentType.type = 'tab';  // 这样可以动态修改缩进
</code></pre>
<p>当然，如果是特定元素，也可以使用选择器：</p>
<pre><code class="language-javascript">var editor = new AreaEditor('textarea');  // 选中所有的 textarea 元素
var editor = new AreaEditor('.code-editor');  // 选中所有 class 为 code-editor 的 textarea 元素
var editor = new AreaEditor('#code-editor');  // 选中 id 为 code-editor 的 textarea 元素
</code></pre>
<h2 id="缩进功能">缩进功能</h2>
<p>最开始，我找了很多资料，发现貌似没人有针对 <code>&lt;textarea&gt;</code> 的直接优化。代码编辑器是很多，大部分都是另辟一大堆 <code>&lt;div&gt;</code> 模拟新编辑框了，或者直接在大轮子 Code Mirror 基础上进一步改进。</p>
<p>其实，有时我们需要的并不多。比如，这些代码编辑器有高亮的功能，能五颜六色显示关键词，其实这个属于「消费升级」的非刚需功能了，真正在编辑时的刚需是 <strong>代码缩进</strong>！</p>
<pre><code class="language-markdown">代码缩进 &gt; 自动缩进 &gt;&gt; 高亮提示 &gt; 智能补全 &gt; 括号补全  &gt; 纠错提示 &gt; 语法高亮
</code></pre>
<p>我们肯定很讨厌在 <code>&lt;textarea&gt;</code> 写代码时，一按 TAB 键，然后光标跑外星的那种感觉。其实我们完全可以使用 js 来改良这个。</p>
<p>（可以试试在 <a href="https://www.ccgxk.com/cellhtmleditor.html" target="_blank" rel="noopener nofollow">https://www.ccgxk.com/cellhtmleditor.html</a> 这个实时编辑页面进行调试下面的这些代码 ~）</p>
<pre><code class="language-html">&lt;textarea id="editor" placeholder="演示 tab 键缩进"&gt;&lt;/textarea&gt;
&lt;script&gt;
    editor.addEventListener('keydown', function(e){
        var start = e.target.selectionStart;  // 光标开始的位置
        var end = e.target.selectionEnd;  // 光标结束的位置
        var value = e.target.value;  // 编辑器里的内容
 
        if (e.key === 'Tab') {  // 按下 TAB 键
            e.preventDefault();  // 阻止默认事件
            e.target.value = value.substring(0, start) + '\t' + value.substring(end);  // 添加 tab 字符
            e.target.selectionStart = e.target.selectionEnd = start + 1;  // 光标向前 +1
        }
    });
&lt;/script&gt;
</code></pre>
<p>首先，我们阻止了 tab 的默认事件（跳到下一个表单元素）<code>e.preventDefault(); </code>，然后我们调用 <code>textarea</code> 元素的 <code>.value</code> api 重新为其填充内容。</p>
<p>然后是 <code>e.target.selectionStart = e.target.selectionEnd = ...</code> 让我们的光标位置放到应该到达的地方。</p>
<p><code>.selectionStart</code> 、 <code>.selectionEnd</code> 、 <code>.value</code> 这三个 API 现在实现这样一个小功能，然后还是这三个 API ，渐渐贯彻了整个代码。一切从这里开始。</p>
<h2 id="缩进类型">缩进类型</h2>
<p>目前，缩进格式并不统一，主流的缩进是 4 个空格，所以，就得需要能切换。</p>
<p>（可以试试在 <a href="https://www.ccgxk.com/cellhtmleditor.html" target="_blank" rel="noopener nofollow">https://www.ccgxk.com/cellhtmleditor.html</a> 这个实时编辑页面进行调试下面的这些代码 ~）</p>
<pre><code class="language-javascript">&lt;textarea id="editor" placeholder="演示缩进类型"&gt;&lt;/textarea&gt;
&lt;script&gt;
    editor.addEventListener('keydown', function(e){
        var type = 'space';  // 缩进类型
        var indentCount = 4;  // 缩进的字符数量
        var tabChar = (type === 'tab') ? '\t' : Array(indentCount + 1).join(' ');  // 缩进字符

        var start = e.target.selectionStart;  // 光标开始的位置
        var end = e.target.selectionEnd;  // 光标结束的位置
        var value = e.target.value;  // 编辑器里的内容
 
        if (e.key === 'Tab') {  // 按下 TAB 键
            e.preventDefault();  // 阻止默认事件
            e.target.value = value.substring(0, start) + tabChar + value.substring(end);  // 添加 tab 字符
            e.target.selectionStart = e.target.selectionEnd = start + indentCount;  // 光标向前 +1
        }
    });
&lt;/script&gt;
</code></pre>
<p>代码里 <code>Array(indentCount + 1).join(' ')</code> 是一种技巧，可以返回 n 个空格，比如 <code>Array(5 + 1).join(' ')</code> 就是 5 个空格，<code>Array(3 + 1).join(' ')</code> 就等于 3 个空格。</p>
<p>根据这个原理，代码的收缩也实现了。不过，还是有很多坑，习惯上的坑：</p>
<ul>
<li>收缩后，光标的选择怎么计算？</li>
<li>如果光标的 start 位于缩进，比如空格上，又该怎么计算？？</li>
<li>...</li>
</ul>
<p>增加缩进很简单，减少缩进没想到这么复杂，计算逻辑还挺抽象，花了好几个小时润色，才算完美解决，下面是最终的代码：</p>
<pre><code class="language-javascript">// TAB 键盘的处理
if (e.key === 'Tab') {
	e.preventDefault();
	if (start === end) {  // 光标未选中多个字符
		e.target.value = value.substring(0, start) + this.tabChar + value.substring(end);
		e.target.selectionStart = e.target.selectionEnd = start + this.tabLength;
		return;
	} else {
		var contentArr = value.split('\n');
		var contentArrOriginal = value.split('\n');
		var startLine = (value.substring(0, start).match(/\n/g) || []).length;
		var endLine = (value.substring(0, end).match(/\n/g) || []).length;
		if (event.shiftKey) {  // 按下 Shift 键（减少缩进）。
			for (var _i = startLine; _i &lt;= endLine; _i++) {
				contentArr[_i] = this._removeLeadingSpaces(contentArr[_i], this.tabLength);
			}
			e.target.value = contentArr.join('\n');
			var lengthDiff = contentArrOriginal[startLine].length -
				contentArrOriginal[startLine].trimStart().length; // 计算光标起始点位于那一行
			var moveLength = Math.min(this.tabLength, lengthDiff);
			
			// 计算最小可缩进值，以防止起始位置（如行5）缩进至行4。
			var limitLineNum = this._arrSum(contentArr, startLine);
			
			// 处理选区起始在缩进（空白）处的情况。
			var startPoint = limitLineNum &gt; start - moveLength - startLine ? limitLineNum + startLine : start - moveLength;
			
			e.target.selectionStart = lengthDiff &gt; 0 ? startPoint : start;
			e.target.selectionEnd = end - (contentArrOriginal.join('\n').length - e.target.value.length);
		} else {  // 单独按 Tab 键（增加缩进），这个简单，文章上面已经写了
			for (var _i = startLine; _i &lt;= endLine; _i++) {
				contentArr[_i] = this.tabChar + contentArr[_i];
			}
			e.target.value = contentArr.join('\n');
			e.target.selectionStart = start + this.tabLength;
			e.target.selectionEnd = end + this.tabLength * (startLine === endLine ? 1 : endLine - startLine + 1);
		}
	}
}
</code></pre>
<h2 id="自动补全括号">自动补全括号</h2>
<p>但，只有这种缩进，肯定还不够，我们还需要那种写下括号后，再回车，产生的那种自动换行和缩进的效果。</p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517142325188-2087958505.png" alt="image" loading="lazy"></p>
<p>按下回车：</p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517142334270-2024456078.png" alt="image" loading="lazy"></p>
<p>顺便把自动括号也实现。</p>
<p>于是哐哐一顿实现，计算还简单，但逐渐发现一个问题。</p>
<p>这是程序 1.0 时候的一个案例:</p>
<pre><code class="language-html">&lt;textarea placeholder="演示 enter 键 bug"&gt;&lt;/textarea&gt;
&lt;script src="https://cdn.jsdelivr.net/gh/kohunglee/areaeditor/src/areaeditor.1.0.x.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var editor = new AreaEditor('textarea');
&lt;/script&gt;
</code></pre>
<p>当我们用中文输入法输入时，一回车（按照习惯，应该只会输入 jtxql 这六个字符），会产生这样的效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517143124888-1382386749.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517143151753-1326766658.png" alt="image" loading="lazy"></p>
<p>显然使用 <code>addEventListener('keydown', ... )</code> 是不行的。</p>
<p>于是又加入了 <code>addEventListener('input', ... )</code> 。<code>keydown</code> 和 <code>input</code> 是不一样的。前者是在键盘按下的一瞬间触发，在字符输入前（也因此可以阻止字符输入），而后者 <code>input</code> 是在字符输入后探测你按下了哪个按键。</p>
<h2 id="犯难">犯难</h2>
<p>这就犯了难，我到底是使用哪个来监测 <code>enter</code> 键的按下。如果是前者，那我避免不了这个 bug，如果是后者，那画面会跳动一下，很诡异。</p>
<p>最后我还是使用后者，只不过我不是监测的按钮，而是字符 <code>if(lastChar === '\n'){ ... } </code>，然后重新生成缩进内容，里面多来一个换行符即可。</p>
<h2 id="自动补全">自动补全</h2>
<p>自动补全倒是没有什么好说的。唯一要说的，【若用户仍选择手动完成，则忽略】这个功能，让这个自动补全变得非常流畅。但我没想到，要判断用户有没有手动补全，竟然要判断三个布尔：前一个字符，是否属于要补全的符号，后一个字符是否等于应补全的符号，用户输入的是否等于已经补全的符号。</p>
<pre><code class="language-javascript">var autoPairs = { 
	'{': '}',
	'[': ']',
	'(': ')',
	'"': '"',
	"'": "'",
	'`': '`',
};
if (['{', '(', '[', '"', "'", '`', ']', '}', ')'].includes(lastChar) &amp;&amp; start === end) {
	if(this.isPreventAuto){
		this.isPreventAuto = false;
		return;
	}
	var pairChar = autoPairs[lastChar]  || '';
	for (var leftBrace in autoPairs) {
	
		// 若用户仍选择手动完成，则忽略
		if (leftBrace === secondLastChar &amp;&amp; autoPairs[leftBrace] === lastChar &amp;&amp; nextChar === lastChar) {
			e.target.value = value.substring(0, start) + value.substring(start + 1);
			e.target.selectionStart = e.target.selectionEnd = start;
			return;
		}
	}
	e.target.value = value.substring(0, start) + pairChar + value.substring(start);
	e.target.selectionStart = e.target.selectionEnd = start;
}
</code></pre>
<h2 id="阻止补全">阻止补全</h2>
<p>其实，上面的这些行为，并不能一直都有效。所以我又设立了阻止补全。不能说我们按快捷键复制粘贴的时候，也顺手补全了，也不能说我们在按删除键的时候也给补全了（o(￣▽￣)ｄ  这样就陷入死循环了 ~ 一个永远也删不掉的右括号）</p>
<pre><code class="language-js">AreaEditor.prototype.isPreventAuto = false;  // 是否阻止某些自动脚本
</code></pre>
<p>检测到一些按键 或 粘贴事件 <code>addEventListener('paste', ...);</code> 后，就不再执行。</p>
<h2 id="编辑框抖动">编辑框抖动</h2>
<p>一个不知起源于何时的 <code>textarea</code> 特性，当行数比较大时，回车会让输入框抖一下，十分影响..... 起码影响心情：</p>
<p>（可以试试在 <a href="https://www.ccgxk.com/cellhtmleditor.html" target="_blank" rel="noopener nofollow">https://www.ccgxk.com/cellhtmleditor.html</a> 这个实时编辑页面进行调试下面的这些代码 ~）</p>
<pre><code class="language-html">&lt;textarea id=demoEditor rows=10 placeholder="演示编辑框抖动"&gt;&lt;/textarea&gt;
&lt;script src="https://cdn.jsdelivr.net/gh/kohunglee/areaeditor/src/areaeditor.1.0.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var content = '';
    for(var i = 0; i &lt; 200; i++){
        content += i+'\n'
    }
    demoEditor.value = content;
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517151157858-947281075.png" alt="image" loading="lazy"></p>
<p>于是</p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517151246272-632260747.png" alt="image" loading="lazy"></p>
<p>这是浏览器的原生特性（bug），意义不明。</p>
<p>当然，这个问题好解决，只需要记录下高度，在完成我们的操作后将高度还原即可。</p>
<h2 id="在空行按下删除键清空">在空行按下删除键，清空</h2>
<p>在一个只存在缩进、空格的行，我们按下删除键，不出意外，目的只有一个，就是将这行删干净。所以，我又加上这样一个功能，在空行按下删除键，清空。</p>
<p>本以为只是一两行代码才能完成，最后搞了一坨：</p>
<pre><code class="language-javascript">if (e.key === 'Backspace') {
	var contentArr = value.split('\n');
	var startLine = (value.substring(0, start).match(/\n/g) || []).length;
	
	// 当前行仅包含空格和制表符
	if(start === end &amp;&amp; (/^[\s\t]*$/.test(contentArr[startLine]) &amp;&amp; contentArr[startLine] !== '')){
		e.target.selectionStart = this._arrSum(contentArr, startLine) + startLine;
		e.target.selectionEnd = start;
	}
}
</code></pre>
<p>体验感大大的好。</p>
<h2 id="封装代码">封装代码</h2>
<p>我想把它做成一个第三方的引用库，那么我就要尽可能写的标准一点。</p>
<p>模仿  jQuery、Zepto 将它封装了一下。</p>
<p>首先是 UMD 模块化，</p>
<pre><code class="language-javascript">(function (global, factory) {
    if (typeof define === 'function' &amp;&amp; define.amd) {  // UMD 模式
        define([], factory);  // AMD
    } else if (typeof module === 'object' &amp;&amp; module.exports) {
        module.exports = factory();  // CommonJS
    } else {
        global.AreaEditor = factory();  // 这样写，可以不用 new 关键字来调用
    }
}(this, function () {
    'use strict';
	
	// 构造函数
	function AreaEditor(element, options = {indentType : { type: 'space', count: 4 }}) {
	
	.....
	
	.....
	
	return AreaEditor;
}));
</code></pre>
<p>第一个，是依照过去我们常用的 <a href="https://requirejs.org/" title="requireJS" target="_blank" rel="noopener nofollow">requireJS</a> 要求的格式来定义的，这是一个模块化工具，让我们的 JS 文件们可以按需加载。虽然在 ES6 时代日薄西山，但还是能用得到。学习这个可以看阮一峰大佬的<a href="https://www.ruanyifeng.com/blog/2012/11/require_js.html" title="这篇文章" target="_blank" rel="noopener nofollow">这篇文章</a>。</p>
<p>第二个是 CommonJS 环境使用的，也就是服务器端。主要用于 node.js 。可以供 <code>require('./logger.js')</code> 这种语法使用。</p>
<p>第三个就是我们现在使用的这种方式，即浏览器直接调用。</p>
<p>里面的 <code>factory()</code> 是工厂函数， <code> 'use strict';</code> 及以下就是这个函数的内容。我们只需将我们的 <code>AreaEditor</code> 函数写入即可。</p>
<p><code>AreaEditor()</code> 是构造函数，通常使用大写字母开头。就好像一个对象一样，不过调用的时候需要写 new ，有了上面的 <code>factory()</code> 的处理后，不写 new 关键字也可以。</p>
<hr>
<h2 id="怎么压缩-javascript-代码">怎么压缩 JavaScript 代码</h2>
<p>初步压缩，主流的有三个选择：</p>
<ul>
<li><a href="https://developers.google.com/closure/compiler?hl=zh-cn" title="Google Closure Compiler" target="_blank" rel="noopener nofollow">Google Closure Compiler</a>  （感觉谷歌快放弃它了）</li>
<li><a href="https://github.com/mishoo/UglifyJS" title="UglifyJS " target="_blank" rel="noopener nofollow">UglifyJS </a></li>
<li><a href="https://terser.org/" title="Terser" target="_blank" rel="noopener nofollow">Terser</a></li>
</ul>
<p>第一个是谷歌公司使用 Java 搞的智能压缩，可以分析代码把冗余给铲除，确保结果不变。不过效果和下面两个差不多。</p>
<p>第三个 Terser 我们可能都间接用过，它是 webpack 这个打包工具的默认压缩工具。其实它是在 UglifyJS 基础上迭代的。</p>
<p>在这里，我使用了 UglifyJS 。它也会智能将代码里的多余的地方优化，以实现尽可能小的体积：</p>
<pre><code>var a=1;var a=2;
// 合并重复变量
var a=2

alert('a' + 'b');
// 优化
alert("ab");

function a(){
    var info = 'a' + 'b';
    alert(info);
}
// 优化
function a(){alert("ab")}
</code></pre>
<p>它本身是一个 node.js 库，无法直接在浏览器上运行，不过有大佬将其转化为了浏览器端。我又将其配置表和界面给翻译成中文，就是下面这个地址：</p>
<p><a href="https://git.ccgxk.com/jscompression/jsminifier.html" target="_blank" rel="noopener nofollow">https://git.ccgxk.com/jscompression/jsminifier.html</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517160908672-929448955.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517162134968-2110038408.png" alt="image" loading="lazy"></p>
<p>使用它生成后的代码，还没有到 2kb 这个阶段，然后我又找到了个利用字母出现频次，构成字典，然后进行压缩的 js 压缩工具。</p>
<p>常出现在一些 代码高尔夫 炫技比赛里，比比谁能用更小的体积实现更复杂的功能或游戏这种比赛里，类似于 <a href="https://js13kgames.com/" target="_blank" rel="noopener nofollow">https://js13kgames.com/</a> 。</p>
<p>我把那个界面搞的漂亮了一点，然后将全局变量改了一下名，就是这个页面：</p>
<p><a href="https://git.ccgxk.com/jscompression/jscrush.html" target="_blank" rel="noopener nofollow">https://git.ccgxk.com/jscompression/jscrush.html</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1669501/202505/1669501-20250517162503791-1471234915.png" alt="image" loading="lazy"></p>
<p>这样就差不多 2kb 了。</p>
<p>但是，这个 js crush 压缩，其实在有 Gzip 的服务器情况下，并不是必需品，Gzip 的压缩率和这个差不多。</p>
<h2 id="更多的功能">更多的功能？</h2>
<p>以后不会添加更多的功能了，因为没必要 ~ textarea 的特性就决定了它无法完美实现代码高亮，而自动语法又是很复杂的事情，需要大量代码，所以没有必要。</p>
<p>我的这个 areaEditor.js 的存在意义是，为那些极端情况下准备的：比如 在线改一些简单的代码、一些轻量级的库、一些对网络有限制的场景、一些简单的页面、一些黑白页面....</p>
<p>另外，功能再多一点，就到「结界」了：毕竟体积大了，我为什么不选择更专业的？</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/duyuanshang/" target="_blank">独元殇</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/duyuanshang/p/18856762" target="_blank">https://www.cnblogs.com/duyuanshang/p/18856762</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.0514414733854167" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-17 19:17">2025-05-17 16:36</span>&nbsp;
<a href="https://www.cnblogs.com/duyuanshang">独元殇</a>&nbsp;
阅读(<span id="post_view_count">353</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18856762);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18856762', targetLink: 'https://www.cnblogs.com/duyuanshang/p/18856762', title: '自制体积不到 2kB 的代码编辑器，areaEditor.js，增强 textarea 标签的代码编辑体验' })">举报</a>
</div>
        