
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18930715" title="发布于 2025-06-16 10:06">
    <span role="heading" aria-level="2">Spring用到的10种设计模式，真巧妙！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>作为一名有多年开发经验的老司机，每次翻看Spring源码都让我感叹："这哪是框架，分明是设计模式的百科全书！"</p>
<p>有些小伙伴在工作中可能只会用<code>@Autowired</code>，却不知背后藏着多少精妙设计。</p>
<p>今天这篇文章跟大家一起聊聊Spring中最常用的10种设计模式，希望对你会有所帮助。</p>
<h2 id="1-模板方法模式流程骨架大师">1 模板方法模式：流程骨架大师</h2>
<p><strong>场景</strong>：处理重复流程但允许细节变化<br>
<strong>Spring应用</strong>：<code>JdbcTemplate</code>、<code>RestTemplate</code>等</p>
<pre><code class="language-java">// 伪代码展示模板方法核心
public abstract class JdbcTemplate {
    // 定义算法骨架（不可重写）
    public final Object execute(String sql) {
        Connection conn = getConnection(); // 抽象方法
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(sql);
        Object result = mapResult(rs);     // 抽象方法
        releaseResources(conn, stmt, rs);
        return result;
    }
    
    // 留给子类实现的钩子方法
    protected abstract Connection getConnection();
    protected abstract Object mapResult(ResultSet rs);
}
</code></pre>
<p><strong>为什么用</strong>：</p>
<ol>
<li>复用资源管理（连接获取/释放）等通用逻辑</li>
<li>允许子类只关注业务差异（如结果映射）<br>
<strong>思考</strong>：当你写重复流程时，想想能否抽出模板骨架</li>
</ol>
<h2 id="2-工厂模式对象出生管理局">2 工厂模式：对象出生管理局</h2>
<p><strong>场景</strong>：解耦对象创建与使用<br>
<strong>Spring应用</strong>：<code>BeanFactory</code>核心接口</p>
<pre><code class="language-java">public interface BeanFactory {
    Object getBean(String name);
    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType);
}

// 实现类：DefaultListableBeanFactory
public class UserService {
    // 使用者无需关心Bean如何创建
    @Autowired 
    private OrderService orderService; 
}
</code></pre>
<p><strong>设计精髓</strong>：</p>
<ul>
<li>隐藏复杂的对象初始化过程（如循环依赖处理）</li>
<li>统一管理对象生命周期（单例/原型等作用域）<br>
<strong>类比</strong>：就像点外卖不需要知道厨师怎么做菜</li>
</ul>
<h2 id="3-代理模式隐形护卫">3 代理模式：隐形护卫</h2>
<p><strong>场景</strong>：无侵入增强对象功能</p>
<p><strong>Spring应用</strong>：AOP动态代理</p>
<pre><code class="language-java">// JDK动态代理示例
public class LogProxy implements InvocationHandler {
    private Object target;
    
    public Object createProxy(Object target) {
        this.target = target;
        return Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        System.out.println("【日志】调用方法: " + method.getName());
        return method.invoke(target, args); // 执行原方法
    }
}

// Spring中通过@Aspect实现类似功能
@Aspect
@Component
public class LogAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logMethodCall(JoinPoint jp) {
        System.out.println("调用方法: " + jp.getSignature().getName());
    }
}
</code></pre>
<p><strong>动态代理两板斧</strong>：</p>
<ol>
<li>JDK代理：基于接口（要求目标类实现接口）</li>
<li>CGLIB代理：基于继承（可代理普通类）<br>
<strong>价值</strong>：业务逻辑与横切关注点（日志/事务等）彻底解耦</li>
</ol>
<h2 id="4-单例模式全局唯一指挥官">4 单例模式：全局唯一指挥官</h2>
<p><strong>场景</strong>：减少资源消耗，保证全局一致性</p>
<p><strong>Spring实现</strong>：Bean默认作用域</p>
<pre><code class="language-java">// 源码片段：AbstractBeanFactory
public Object getBean(String name) {
    Object bean = getSingleton(name); // 先查缓存
    if (bean == null) {
        bean = createBean(name);      // 不存在则创建
        addSingleton(name, bean);     // 放入缓存
    }
    return bean;
}
</code></pre>
<p><strong>关键设计</strong>：</p>
<ul>
<li>三级缓存解决循环依赖（singletonObjects, earlySingletonObjects, singletonFactories）</li>
<li>并发安全通过<code>synchronized</code>+双重检查锁定实现<br>
<strong>警示</strong>：切忌在单例Bean中保存状态变量！</li>
</ul>
<h2 id="5-观察者模式事件广播网">5 观察者模式：事件广播网</h2>
<p><strong>场景</strong>：解耦事件生产者和消费者</p>
<p><strong>Spring应用</strong>：<code>ApplicationEvent</code>机制</p>
<pre><code class="language-java">// 1. 定义事件
public class OrderCreatedEvent extends ApplicationEvent {
    public OrderCreatedEvent(Order source) {
        super(source);
    }
}

// 2. 发布事件
@Service
public class OrderService {
    @Autowired ApplicationEventPublisher publisher;
    
    public void createOrder(Order order) {
        // 业务逻辑...
        publisher.publishEvent(new OrderCreatedEvent(order));
    }
}

// 3. 监听事件
@Component
public class EmailListener {
    @EventListener
    public void handleOrderEvent(OrderCreatedEvent event) {
        // 发送邮件通知
    }
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>事件源与监听器完全解耦</li>
<li>支持异步处理（加<code>@Async</code>注解即可）</li>
</ul>
<h2 id="6-策略模式算法切换器">6 策略模式：算法切换器</h2>
<p><strong>场景</strong>：动态选择算法实现</p>
<p><strong>Spring应用</strong>：<code>Resource</code>资源加载</p>
<pre><code class="language-java">// 资源加载策略族
Resource res1 = new ClassPathResource("config.xml"); // 类路径策略
Resource res2 = new UrlResource("http://config.com");// 网络策略
Resource res3 = new FileSystemResource("/opt/config");// 文件系统策略

// 统一调用接口
InputStream is = res1.getInputStream();
</code></pre>
<p><strong>源码设计亮点</strong>：</p>
<ul>
<li><code>Resource</code>接口统一抽象</li>
<li>通过<code>ResourceLoader</code>自动选择策略<br>
<strong>应用场景</strong>：支付方式切换（微信/支付宝/银联）</li>
</ul>
<h2 id="7-适配器模式接口转换器">7 适配器模式：接口转换器</h2>
<p><strong>场景</strong>：兼容不兼容的接口</p>
<p><strong>Spring应用</strong>：Spring MVC的<code>HandlerAdapter</code></p>
<pre><code class="language-java">// 伪代码：处理多种Controller
public class RequestMappingHandlerAdapter implements HandlerAdapter {
    
    public boolean supports(Object handler) {
        return handler instanceof Controller;
    }
    
    public ModelAndView handle(HttpRequest req, HttpResponse res, Object handler) {
        Controller controller = (Controller) handler;
        return controller.handleRequest(req, res); // 统一适配调用
    }
}

// 实际Spring源码中处理了：
// 1. @Controller注解类 2. HttpRequestHandler 3. Servlet实现等
</code></pre>
<p><strong>价值</strong>：</p>
<ul>
<li>让DispatcherServlet无需关心Controller具体类型</li>
<li>新增Controller类型只需扩展适配器</li>
</ul>
<h2 id="8-装饰器模式功能增强包">8 装饰器模式：功能增强包</h2>
<p><strong>场景</strong>：动态添加功能</p>
<p><strong>Spring应用</strong>：<code>HttpServletRequest</code>包装</p>
<pre><code class="language-java">// 典型应用：缓存请求体
ContentCachingRequestWrapper wrappedRequest = 
    new ContentCachingRequestWrapper(rawRequest);

// 可在filter中多次读取body
byte[] body = wrappedRequest.getContentAsByteArray();
</code></pre>
<p><strong>源码实现</strong>：</p>
<pre><code class="language-java">public class ContentCachingRequestWrapper extends HttpServletRequestWrapper {
    private ByteArrayOutputStream cachedContent;
    
    @Override
    public ServletInputStream getInputStream() {
        // 装饰原方法：缓存流数据
    }
}
</code></pre>
<p><strong>设计本质</strong>：通过包装器在不修改原对象基础上增强功能</p>
<h2 id="9-建造者模式复杂对象组装工">9 建造者模式：复杂对象组装工</h2>
<p><strong>场景</strong>：分步构建复杂对象</p>
<p><strong>Spring应用</strong>：<code>BeanDefinitionBuilder</code></p>
<pre><code class="language-java">// 构建复杂的Bean定义
BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(UserService.class);
builder.addPropertyValue("maxRetry", 3);
builder.setInitMethodName("init");
builder.setScope(BeanDefinition.SCOPE_SINGLETON);

// 注册到容器
registry.registerBeanDefinition("userService", builder.getBeanDefinition());
</code></pre>
<p><strong>对比传统构造</strong>：</p>
<ul>
<li>解决多参数构造的混乱（尤其可选参数多时）</li>
<li>构建过程更加清晰可读</li>
</ul>
<h2 id="10-责任链模式拦截器的骨架设计">10 责任链模式：拦截器的骨架设计</h2>
<p><strong>场景</strong>：解耦多步骤处理流程</p>
<p><strong>Spring应用</strong>：<code>HandlerInterceptor</code>拦截器链</p>
<pre><code class="language-java">// Spring MVC核心执行链
public class HandlerExecutionChain {
    private final List&lt;HandlerInterceptor&gt; interceptors = new ArrayList&lt;&gt;();
    
    // 执行前置处理（责任链核心）
    public boolean applyPreHandle(HttpServletRequest request, 
                                 HttpServletResponse response) {
        for (int i = 0; i &lt; interceptors.size(); i++) {
            HandlerInterceptor interceptor = interceptors.get(i);
            // 任意拦截器返回false则中断链条
            if (!interceptor.preHandle(request, response, this.handler)) {
                triggerAfterCompletion(request, response, i); // 清理已完成
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<p><strong>实战配置</strong>：</p>
<pre><code class="language-java">@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 构建责任链
        registry.addInterceptor(new LogInterceptor()).order(1);
        registry.addInterceptor(new AuthInterceptor()).order(2);
        registry.addInterceptor(new RateLimitInterceptor()).order(3);
    }
}

// 独立拦截器实现
public class AuthInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {
        if (!checkToken(req.getHeader("Authorization"))) {
            res.sendError(401); // 认证失败
            return false; // 中断链
        }
        return true; // 放行
    }
}
</code></pre>
<p><strong>设计价值</strong>：</p>
<ol>
<li><strong>开闭原则</strong>：新增拦截器无需修改现有代码</li>
<li><strong>单一职责</strong>：每个拦截器只关注单一功能</li>
<li><strong>动态编排</strong>：通过<code>order()</code>灵活调整执行顺序</li>
<li><strong>流程控制</strong>：任意节点可中断或继续传递</li>
</ol>
<blockquote>
<p><strong>典型反模式</strong>：在拦截器中注入其他拦截器，这将破坏责任链独立性，导致循环依赖！</p>
</blockquote>
<h2 id="总结">总结</h2>
<ol>
<li>
<p><strong>解耦的艺术</strong><br>
工厂模式解耦创建/使用，观察者模式解耦事件/处理</p>
</li>
<li>
<p><strong>扩展性的智慧</strong><br>
策略模式支持算法扩展，装饰器模式支持功能扩展</p>
</li>
<li>
<p><strong>复杂性的封装</strong><br>
模板方法封装流程，建造者模式封装构建</p>
</li>
<li>
<p><strong>性能的权衡</strong><br>
单例模式减少资源消耗，代理模式按需增强</p>
</li>
</ol>
<p>最后送给小伙伴们的建议：<strong>不要为了用模式而用模式</strong>。</p>
<p>就像Spring的作者Rod Johnson说的："<strong>优雅的代码不是模式的堆砌，而是恰到好处的抽象</strong>。"</p>
<p>当你下次写代码感到别扭时，不妨想想这些经典模式，或许能豁然开朗。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，我的所有文章都会在公众号上首发，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-16 10:07">2025-06-16 10:06</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18930715);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18930715', targetLink: 'https://www.cnblogs.com/12lisu/p/18930715', title: 'Spring用到的10种设计模式，真巧妙！' })">举报</a>
</div>
        