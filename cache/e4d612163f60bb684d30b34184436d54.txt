
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/changelzj/p/18738111" title="发布于 2025-02-26 11:27">
    <span role="heading" aria-level="2">芋道源码解析之数据权限</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong><a href="https://blog.liuzijian.com/post/source-code-yudao-data-permission.html" target="_blank" rel="noopener nofollow">文章首发于我的博客：https://blog.liuzijian.com/post/source-code-yudao-data-permission.html</a></strong></p>
<blockquote>
<p>博主和芋道源码作者及其官方开发团队无任何关联</p>
</blockquote>
<h2 id="一引言">一、引言</h2>
<p>芋道的数据权限模块代码，涉及的类和方法很多，环环相扣，需要运行项目一步一步debug分析才能看懂。该模块的代码按照功能细分，大致可以分为两部分：</p>
<p><strong>1.数据权限SQL拦截器</strong>：根据定义好的数据权限规则来为涉及到的表在更新、查询和删除时重写（追加）SQL条件，使得用户只能访问到权限范围内的数据。</p>
<p><strong>2.数据权限注解处理器</strong>：基于Spring AOP实现，通过自定义一个数据权限注解并实现一个注解处理器来为某些方法单独指定数据权限规则。</p>
<p>两个部分需要配合使用。</p>
<h2 id="二数据权限sql拦截器">二、数据权限SQL拦截器</h2>
<p>2.4.0-jdk8-SNAPSHOT版本的数据权限功能是基于mybatis-plus的插件机制实现的，具体是对执行修改、删除和查询的SQL进行拦截、解析，然后再根据数据权限规则对需要限制的表重写(追加)查询条件。使用该插件需要实现<code>MultiDataPermissionHandler</code>接口。</p>
<h3 id="21-主要涉及类和接口">2.1 主要涉及类和接口</h3>
<h4 id="211-class-diagram">2.1.1 Class Diagram</h4>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112235244-184382502.png" alt="image" loading="lazy"></p>
<h4 id="212-mybatis-plus">2.1.2 mybatis-plus</h4>
<ul>
<li>
<p><code>com.baomidou.mybatisplus.extension.plugins.inner.DataPermissionInterceptor</code> 类，数据权限的入口，执行解析和重写逻辑，并加入到mp插件队列中。</p>
</li>
<li>
<p><code>com.baomidou.mybatisplus.extension.plugins.inner.BaseMultiTableInnerInterceptor</code> 抽象类，被<code>DataPermissionInterceptor</code>类继承，继承自<code>JsqlParserSupport</code>。提供SQL深度解析能力，遍历SQL语句中各个需要拼接条件的位置，在调用子类来根据不同的表和字段进行SQL重写。</p>
</li>
<li>
<p><code>com.baomidou.mybatisplus.extension.parser.JsqlParserSupport</code> 抽象类，是mp对jsqlparser的封装，更好的实现SQL的解析。</p>
</li>
<li>
<p><code>com.baomidou.mybatisplus.extension.plugins.inner.InnerInterceptor</code> 接口，被<code>DataPermissionInterceptor</code>类实现，由mp调用，在适当时机触发实现类去执行相关方法，进而使实现类执行SQL解析和重写的功能。</p>
</li>
<li>
<p><code>com.baomidou.mybatisplus.extension.plugins.handler.MultiDataPermissionHandler</code> 接口，用于获取数据权限，由实现类来根据不同的表和字段进行SQL重写。</p>
</li>
<li>
<p><code>com.baomidou.mybatisplus.extension.plugins.handler.DataPermissionHandler</code> 接口，作用同<code>MultiDataPermissionHandler</code>。</p>
</li>
</ul>
<h4 id="213-yudao">2.1.3 yudao</h4>
<ul>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.db.DataPermissionRuleHandler</code> 类，间接实现<code>DataPermissionHandler</code>接口，根据mp传来的表名和对应where条件，寻找匹配的数据权限规则来进行数据权限SQL条件的重写，并将符合的多个数据权限策略各自生成的条件进行拼接，返回给mp权限插件。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.rule.DataPermissionRuleFactory</code> 接口，数据权限工厂，实现类来根据实际场景对所有适用的数据权限类根据实际情况进行一些筛选或修改，实现在一些特殊场景下改变数据权限的范围，效力以及优先级。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.rule.DataPermissionRuleFactoryImpl</code> 类，<code>DataPermissionRuleFactory</code>的实现。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.rule.DataPermissionRule</code> 接口，由实现类继承后来实现某种数据权限规则。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.rule.dept.DeptDataPermissionRule</code> 类，yudao项目默认的数据权限，通过实现<code>DataPermissionRule</code>接口实现了部门级别的数据权限规则。</p>
</li>
</ul>
<h3 id="22-执行流程源码解读">2.2 执行流程源码解读</h3>
<h4 id="221-sequence-diagram">2.2.1 Sequence Diagram</h4>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112256060-379521017.png" alt="image" loading="lazy"></p>
<h4 id="222-datapermissioninterceptor">2.2.2 DataPermissionInterceptor</h4>
<p>该类是mybatis-plus数据权限插件的执行入口，是SQL解析和重写功能的起点。</p>
<p>该类在SQL执行前，会对执行的动作进行拦截，并拿到要执行的SQL，递归对SQL语句各处进行扫描，扫描到表和条件时，调用DataPermissionHandler获取当前表的数据权限where条件(Expression)对象，再和业务逻辑的where条件拼在一起，从而实现数据库层面的数据权限控制。</p>
<pre><code class="language-java">public class DataPermissionInterceptor extends BaseMultiTableInnerInterceptor implements InnerInterceptor {

    private DataPermissionHandler dataPermissionHandler;

    @SuppressWarnings("RedundantThrows")
    @Override
    public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        if (InterceptorIgnoreHelper.willIgnoreDataPermission(ms.getId())) {
            return;
        }
        PluginUtils.MPBoundSql mpBs = PluginUtils.mpBoundSql(boundSql);
        mpBs.sql(parserSingle(mpBs.sql(), ms.getId()));
    }

    @Override
    public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) {
        PluginUtils.MPStatementHandler mpSh = PluginUtils.mpStatementHandler(sh);
        MappedStatement ms = mpSh.mappedStatement();
        SqlCommandType sct = ms.getSqlCommandType();
        if (sct == SqlCommandType.UPDATE || sct == SqlCommandType.DELETE) {
            if (InterceptorIgnoreHelper.willIgnoreDataPermission(ms.getId())) {
                return;
            }
            PluginUtils.MPBoundSql mpBs = mpSh.mPBoundSql();
            mpBs.sql(parserMulti(mpBs.sql(), ms.getId()));
        }
    }

    ......

    @Override
    public Expression buildTableExpression(final Table table, final Expression where, final String whereSegment) {
        if (dataPermissionHandler == null) {
            return null;
        }
        // 只有新版数据权限处理器才会执行到这里
        final MultiDataPermissionHandler handler = (MultiDataPermissionHandler) dataPermissionHandler;
        return handler.getSqlSegment(table, where, whereSegment);
    }    

}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112358292-646750726.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112405343-1680557064.png" alt="image" loading="lazy"></p>
<p>解读：</p>
<ol>
<li>
<p><code>beforeQuery()</code>和<code>beforePrepare()</code>是从接口<code>InnerInterceptor</code>继承来的方法，由mybatis-plus在SQL查询前或者预编译(增删改)前回调并传入要执行的SQL，从而叫该类对即将执行的SQL进行某些操作。两个方法都会调用<code>mpBs.sql(parserXxxx(......))</code>方法对SQL进行解析重写，<code>beforeQuery()</code>调用的是<code>parserSingle(......)</code>，只能处理单条SQL。<code>beforePrepare()</code>调用的是<code>parserMulti(......)</code>，可以处理多条SQL，因为jdbc能一次执行用分号间隔的多条增删改SQL语句，就需要parserMulti将每次执行的语句分开，如果确实是一次执行多条的情况，就需要逐个进行解析和重写，再将新的拼接在一起，而查询一次只能执行一条，故采用parserSingle即可。</p>
</li>
<li>
<p><code>parserSingle()</code>和<code>parserMulti()</code>都是间接继承自抽象类<code>JsqlParserSupport</code>的方法，用于启动多条和单条SQL的递归解析，解析获取SQL语句每个部分上的表和对应的条件信息，再调用<code>buildTableExpression()</code>方法，并在方法内再调用<code>handler.getSqlSegment(table, where, whereSegment);</code>，将解析到的表table及条件where和当前执行目标whereSegment传入，向<code>DataPermissionRuleHandler</code>获取当前表的数据权限规则。</p>
</li>
<li>
<p>为了更好的对要处理的SQL进行改写，<code>beforeQuery()</code>将mybatis的<code>BoundSql boundSql</code>对象转换为mybatis-plus的<code>MPBoundSql mpBs</code>对象。<code>beforePrepare()</code>将mybatis的<code>StatementHandler sh</code>转换为mybatis-plus的<code>MPStatementHandler mpSh</code>对象后再获取mybatis-plus的<code>MPBoundSql mpBs</code>对象。</p>
</li>
<li>
<p>新增不涉及数据权限，因此<code>beforePrepare()</code>方法中不会针对insert的情况进行处理。</p>
</li>
</ol>
<h4 id="223-datapermissionrulehandler">2.2.3 DataPermissionRuleHandler</h4>
<p>该类是接口<code>DataPermissionHandler</code>的实现，供拦截器<code>DataPermissionInterceptor</code>调用，用于找到某个表在当前业务下适用的所有的数据权限规则，并汇总，然后再返回一个总的数据权限规则对象给拦截器</p>
<pre><code class="language-java">@RequiredArgsConstructor
public class DataPermissionRuleHandler implements MultiDataPermissionHandler {

    private final DataPermissionRuleFactory ruleFactory;

    @Override
    public Expression getSqlSegment(Table table, Expression where, String mappedStatementId) {
        // 获得 Mapper 对应的数据权限的规则
        List&lt;DataPermissionRule&gt; rules = ruleFactory.getDataPermissionRule(mappedStatementId);
        if (CollUtil.isEmpty(rules)) {
            return null;
        }

        // 生成条件
        Expression allExpression = null;
        for (DataPermissionRule rule : rules) {
            // 判断表名是否匹配
            String tableName = MyBatisUtils.getTableName(table);
            if (!rule.getTableNames().contains(tableName)) {
                continue;
            }

            // 单条规则的条件
            Expression oneExpress = rule.getExpression(tableName, table.getAlias());
            if (oneExpress == null) {
                continue;
            }
            // 拼接到 allExpression 中
            allExpression = allExpression == null ? oneExpress
                    : new AndExpression(allExpression, oneExpress);
        }
        return allExpression;
    }

}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112509271-280585703.png" alt="image" loading="lazy"></p>
<p>解读：</p>
<ol>
<li>
<p>拦截器<code>DataPermissionInterceptor</code>解析到具体的表时会调用该类的<code>getSqlSegment(Table table, Expression where, String mappedStatementId)</code>方法，传入表table，已有条件where和当前执行的目标mappedStatementId，数据权限这里只会用到参数table，没有用到where和mappedStatementId。</p>
</li>
<li>
<p><code>List&lt;DataPermissionRule&gt; rules = ruleFactory.getDataPermissionRule(mappedStatementId);</code>用于从<code>ruleFactory</code>数据权限规则工厂对象获取所有当前业务下生效了的数据权限，如果没有数据权限规则直接返回<code>null</code>，如果有定义好的数据权限规则对象则进行下一步的匹配，参数<code>mappedStatementId</code>在这个版本的源码中并没有实际用到。</p>
</li>
<li>
<p><code>for (DataPermissionRule rule : rules)</code>循环遍历当前生效的所有数据权限规则对象<code>List&lt;DataPermissionRule&gt; rules</code>，通过<code>if (!rule.getTableNames().contains(tableName))</code>判断当前表在哪些规则下不需要数据权限进行跳过，没有跳过的都需要进行数据权限条件拼接，如果都跳过了就等于返回<code>null</code>。</p>
</li>
<li>
<p>最终返回的规则对象是一个总的规则<code>allExpression</code>，如果某个表匹配了多个DataPermissionRule规则，则用<code>AndExpression(allExpression, oneExpress)</code>拼接每个表的规则<code>oneExpress</code>到总的规则<code>allExpression</code>上面，最终<code>allExpression</code>作为当前表的数据权限规则返回。</p>
<blockquote>
<p>如果一个表适用多个数据权限规则，则最终的SQL条件之间是<code>and</code>的关系</p>
</blockquote>
</li>
</ol>
<h4 id="224-datapermissionrulefactory">2.2.4 DataPermissionRuleFactory</h4>
<p>数据权限规则"工厂"，供<code>DataPermissionRuleHandler</code>调用来获取当前业务下适用的数据权限规则，该类会配合数据权限注解处理器来使用，从线程上下文<code>DataPermissionContextHolder</code>中获取加了<code>@DataPermission</code>数据权限注解且是最近一级调用当前mapper执行SQL的那个业务方法上面的<code>@DataPermission</code>注解，根据注解上的数据权限规则进行匹配，返回当前业务方法下具体适用的数据权限规则，而不是简单的把所有定义好了的数据权限规则都返回。</p>
<pre><code class="language-java">public interface DataPermissionRuleFactory {

    /**
     * 获得所有数据权限规则数组
     *
     * @return 数据权限规则数组
     */
    List&lt;DataPermissionRule&gt; getDataPermissionRules();

    /**
     * 获得指定 Mapper 的数据权限规则数组
     *
     * @param mappedStatementId 指定 Mapper 的编号
     * @return 数据权限规则数组
     */
    List&lt;DataPermissionRule&gt; getDataPermissionRule(String mappedStatementId);

}
</code></pre>
<pre><code class="language-java">@RequiredArgsConstructor
public class DataPermissionRuleFactoryImpl implements DataPermissionRuleFactory {

    /**
     * 数据权限规则数组
     */
    private final List&lt;DataPermissionRule&gt; rules;

    @Override
    public List&lt;DataPermissionRule&gt; getDataPermissionRules() {
        return rules;
    }

    @Override // mappedStatementId 参数，暂时没有用。以后，可以基于 mappedStatementId + DataPermission 进行缓存
    public List&lt;DataPermissionRule&gt; getDataPermissionRule(String mappedStatementId) {
        // 1. 无数据权限
        if (CollUtil.isEmpty(rules)) {
            return Collections.emptyList();
        }
        // 2. 未配置，则默认开启
        DataPermission dataPermission = DataPermissionContextHolder.get();
        if (dataPermission == null) {
            return rules;
        }
        // 3. 已配置，但禁用
        if (!dataPermission.enable()) {
            return Collections.emptyList();
        }

        // 4. 已配置，只选择部分规则
        if (ArrayUtil.isNotEmpty(dataPermission.includeRules())) {
            return rules.stream().filter(rule -&gt; ArrayUtil.contains(dataPermission.includeRules(), rule.getClass()))
                    .collect(Collectors.toList()); // 一般规则不会太多，所以不采用 HashSet 查询
        }
        // 5. 已配置，只排除部分规则
        if (ArrayUtil.isNotEmpty(dataPermission.excludeRules())) {
            return rules.stream().filter(rule -&gt; !ArrayUtil.contains(dataPermission.excludeRules(), rule.getClass()))
                    .collect(Collectors.toList()); // 一般规则不会太多，所以不采用 HashSet 查询
        }
        // 6. 已配置，全部规则
        return rules;
    }

}
</code></pre>
<p>解读：</p>
<ol>
<li><code>DataPermissionContextHolder.get()</code>从线程上下文获取数据权限注解处理器为当前执行的SQL具体指定的数据权限规则。</li>
</ol>
<h4 id="225-datapermissionrule">2.2.5 DataPermissionRule</h4>
<p>DataPermissionRule，数据权限规则接口，用于定义某种数据权限规则，需要通过<code>getTableNames()</code>来声明适用的表，再通过<code>Expression getExpression(String tableName, Alias tableAlias)</code>来定义某个表的数据权限条件</p>
<pre><code class="language-java">public interface DataPermissionRule {

    /**
     * 返回需要生效的表名数组
     * 为什么需要该方法？Data Permission 数组基于 SQL 重写，通过 Where 返回只有权限的数据
     *
     * 如果需要基于实体名获得表名，可调用 {@link TableInfoHelper#getTableInfo(Class)} 获得
     *
     * @return 表名数组
     */
    Set&lt;String&gt; getTableNames();

    /**
     * 根据表名和别名，生成对应的 WHERE / OR 过滤条件
     *
     * @param tableName 表名
     * @param tableAlias 别名，可能为空
     * @return 过滤条件 Expression 表达式
     */
    Expression getExpression(String tableName, Alias tableAlias);

}
</code></pre>
<p>DeptDataPermissionRule，yudao自带的一个默认的数据权限规则实现类，可以针对系统中所有的表实现本人、本部门、本部门及以下、指定部门、无任何权限和无任何限制的6种数据权限。需要使用该规则的模块只需要将需要限制数据权限的表和其中对应的字段注册到这个类中，即可实现根据每个用户的数据权限范围对不同的表进行个人和部门级别的数据权限控制，实现这6种权限。</p>
<pre><code class="language-java">@AllArgsConstructor
@Slf4j
public class DeptDataPermissionRule implements DataPermissionRule {

    /**
     * LoginUser 的 Context 缓存 Key
     */
    protected static final String CONTEXT_KEY = DeptDataPermissionRule.class.getSimpleName();

    private static final String DEPT_COLUMN_NAME = "dept_id";
    private static final String USER_COLUMN_NAME = "user_id";

    static final Expression EXPRESSION_NULL = new NullValue();

    private final PermissionApi permissionApi;

    /**
     * 基于部门的表字段配置
     * 一般情况下，每个表的部门编号字段是 dept_id，通过该配置自定义。
     *
     * key：表名
     * value：字段名
     */
    private final Map&lt;String, String&gt; deptColumns = new HashMap&lt;&gt;();
    /**
     * 基于用户的表字段配置
     * 一般情况下，每个表的部门编号字段是 dept_id，通过该配置自定义。
     *
     * key：表名
     * value：字段名
     */
    private final Map&lt;String, String&gt; userColumns = new HashMap&lt;&gt;();
    /**
     * 所有表名，是 {@link #deptColumns} 和 {@link #userColumns} 的合集
     */
    private final Set&lt;String&gt; TABLE_NAMES = new HashSet&lt;&gt;();

    @Override
    public Set&lt;String&gt; getTableNames() {
        return TABLE_NAMES;
    }

    @Override
    public Expression getExpression(String tableName, Alias tableAlias) {
        // 只有有登陆用户的情况下，才进行数据权限的处理
        LoginUser loginUser = SecurityFrameworkUtils.getLoginUser();
        if (loginUser == null) {
            return null;
        }
        // 只有管理员类型的用户，才进行数据权限的处理
        if (ObjectUtil.notEqual(loginUser.getUserType(), UserTypeEnum.ADMIN.getValue())) {
            return null;
        }

        // 获得数据权限
        DeptDataPermissionRespDTO deptDataPermission = loginUser.getContext(CONTEXT_KEY, DeptDataPermissionRespDTO.class);
        // 从上下文中拿不到，则调用逻辑进行获取
        if (deptDataPermission == null) {
            deptDataPermission = permissionApi.getDeptDataPermission(loginUser.getId());
            if (deptDataPermission == null) {
                log.error("[getExpression][LoginUser({}) 获取数据权限为 null]", JsonUtils.toJsonString(loginUser));
                throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 未返回数据权限",
                        loginUser.getId(), tableName, tableAlias.getName()));
            }
            // 添加到上下文中，避免重复计算
            loginUser.setContext(CONTEXT_KEY, deptDataPermission);
        }

        // 情况一，如果是 ALL 可查看全部，则无需拼接条件
        if (deptDataPermission.getAll()) {
            return null;
        }

        // 情况二，即不能查看部门，又不能查看自己，则说明 100% 无权限
        if (CollUtil.isEmpty(deptDataPermission.getDeptIds())
            &amp;&amp; Boolean.FALSE.equals(deptDataPermission.getSelf())) {
            return new EqualsTo(null, null); // WHERE null = null，可以保证返回的数据为空
        }

        // 情况三，拼接 Dept 和 User 的条件，最后组合
        Expression deptExpression = buildDeptExpression(tableName,tableAlias, deptDataPermission.getDeptIds());
        Expression userExpression = buildUserExpression(tableName, tableAlias, deptDataPermission.getSelf(), loginUser.getId());
        if (deptExpression == null &amp;&amp; userExpression == null) {
            // TODO 芋艿：获得不到条件的时候，暂时不抛出异常，而是不返回数据
            log.warn("[getExpression][LoginUser({}) Table({}/{}) DeptDataPermission({}) 构建的条件为空]",
                    JsonUtils.toJsonString(loginUser), tableName, tableAlias, JsonUtils.toJsonString(deptDataPermission));
//            throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 构建的条件为空",
//                    loginUser.getId(), tableName, tableAlias.getName()));
            return EXPRESSION_NULL;
        }
        if (deptExpression == null) {
            return userExpression;
        }
        if (userExpression == null) {
            return deptExpression;
        }
        // 目前，如果有指定部门 + 可查看自己，采用 OR 条件。即，WHERE (dept_id IN ? OR user_id = ?)
        return new ParenthesedExpressionList(new OrExpression(deptExpression, userExpression));
    }

    private Expression buildDeptExpression(String tableName, Alias tableAlias, Set&lt;Long&gt; deptIds) {
        // 如果不存在配置，则无需作为条件
        String columnName = deptColumns.get(tableName);
        if (StrUtil.isEmpty(columnName)) {
            return null;
        }
        // 如果为空，则无条件
        if (CollUtil.isEmpty(deptIds)) {
            return null;
        }
        // 拼接条件
        return new InExpression(MyBatisUtils.buildColumn(tableName, tableAlias, columnName),
                // Parenthesis 的目的，是提供 (1,2,3) 的 () 左右括号
                new ParenthesedExpressionList(new ExpressionList&lt;LongValue&gt;(CollectionUtils.convertList(deptIds, LongValue::new))));
    }

    private Expression buildUserExpression(String tableName, Alias tableAlias, Boolean self, Long userId) {
        // 如果不查看自己，则无需作为条件
        if (Boolean.FALSE.equals(self)) {
            return null;
        }
        String columnName = userColumns.get(tableName);
        if (StrUtil.isEmpty(columnName)) {
            return null;
        }
        // 拼接条件
        return new EqualsTo(MyBatisUtils.buildColumn(tableName, tableAlias, columnName), new LongValue(userId));
    }

    // ==================== 添加配置 ====================

    public void addDeptColumn(Class&lt;? extends BaseDO&gt; entityClass) {
        addDeptColumn(entityClass, DEPT_COLUMN_NAME);
    }

    public void addDeptColumn(Class&lt;? extends BaseDO&gt; entityClass, String columnName) {
        String tableName = TableInfoHelper.getTableInfo(entityClass).getTableName();
       addDeptColumn(tableName, columnName);
    }

    public void addDeptColumn(String tableName, String columnName) {
        deptColumns.put(tableName, columnName);
        TABLE_NAMES.add(tableName);
    }

    public void addUserColumn(Class&lt;? extends BaseDO&gt; entityClass) {
        addUserColumn(entityClass, USER_COLUMN_NAME);
    }

    public void addUserColumn(Class&lt;? extends BaseDO&gt; entityClass, String columnName) {
        String tableName = TableInfoHelper.getTableInfo(entityClass).getTableName();
        addUserColumn(tableName, columnName);
    }

    public void addUserColumn(String tableName, String columnName) {
        userColumns.put(tableName, columnName);
        TABLE_NAMES.add(tableName);
    }

}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112548634-474913712.png" alt="image" loading="lazy"></p>
<p>解读：</p>
<ol>
<li>
<p><code>Map&lt;String, String&gt; deptColumns</code>将需要部门数据权限约束的表的表名和部门ID的字段名通过键值对关联起来，<code>Map&lt;String, String&gt; userColumns</code>则是将需要本人数据权限约束的表的表名和用户ID的字段名通过键值对关联起来，用于之后对不同的表和字段拼接条件。<code>Set&lt;String&gt; TABLE_NAMES</code>则是将适用本类规则的所有表的表名都保存进去，供<code>DataPermissionRuleHandler</code>判断当前解析到的某个表是否匹配本类的数据权限规则。业务模块需要将模块中用到该规则的表名和对应字段名注册到这些集合中。</p>
</li>
<li>
<p><code>addDeptColumn(String tableName, String columnName)</code>和<code>addUserColumn(String tableName, String columnName)</code>方法以及它们的重载方法，会在该类创建时被各业务模块的配置类<code>DataPermissionConfiguration</code>调用，将每个模块需要用到该规则类的表和对应字段名注册到该类中。</p>
</li>
<li>
<p><code>getExpression(String tableName, Alias tableAlias)</code>方法中拼接表的数据权限SQL条件，首先要通过<code>permissionApi.getDeptDataPermission(loginUser.getId())</code>获取当前登录用户的数据权限范围，如果是无限制，直接返回<code>null</code>表示没有规则限制，无论哪个表都查出所有数据。如果既不能查看自己的数据又不能访问任何部门的数据，说明无论哪个表都没有数据权限，直接返回<code>WHERE null = null</code>，执行结果就是空集。剩下的情况就需要根据具体表和字段来返回具体的数据权限条件了，会先后调用<code>buildDeptExpression(String tableName, Alias tableAlias, Set&lt;Long&gt; deptIds)</code>和<code>buildUserExpression(String tableName, Alias tableAlias, Boolean self, Long userId)</code>方法来对当前表拼接部门或本人，或同时拼接部门和本人的数据权限条件，返回对应的<code>Expression</code>对象，找不到表或无权限时返回<code>null</code>，两个方法至少返回一个非空的对象，部门为<code>null</code>则返回本人，本人为<code>null</code>则返回部门，两者都不为<code>null</code>则用<code>OR</code>拼接返回<code>new ParenthesedExpressionList(new OrExpression(deptExpression, userExpression))</code>，既然当前表适用该类定义的规则且当前用户是有权限的，部门和本人的条件便不能同时为<code>null</code>，如出现同时为<code>null</code>的情况则返回<code>new NullValue()</code>，SQL执行会返回空集。</p>
</li>
</ol>
<h4 id="226-deptdatapermissionrulecustomizer">2.2.6 DeptDataPermissionRuleCustomizer</h4>
<p>个人及部门级别数据权限的表和字段回调接口，由业务模块实现，将<code>DeptDataPermissionRule</code>对象传入回调方法<code>customize</code>，供各业务模块将需要数据权限控制的表和字段信息注册到<code>DeptDataPermissionRule</code>中。</p>
<pre><code class="language-java">@FunctionalInterface
public interface DeptDataPermissionRuleCustomizer {

    /**
     * 自定义该权限规则
     * 1. 调用 {@link DeptDataPermissionRule#addDeptColumn(Class, String)} 方法，配置基于 dept_id 的过滤规则
     * 2. 调用 {@link DeptDataPermissionRule#addUserColumn(Class, String)} 方法，配置基于 user_id 的过滤规则
     *
     * @param rule 权限规则
     */
    void customize(DeptDataPermissionRule rule);

}
</code></pre>
<h4 id="227-yudaodeptdatapermissionautoconfiguration">2.2.7 YudaoDeptDataPermissionAutoConfiguration</h4>
<p>个人及部门级别数据权限规则的配置类，用于注册<code>DeptDataPermissionRule</code>到Spring容器中，每个模块实现的<code>DeptDataPermissionRuleCustomizer</code>接口实例也会被注入到<code>List&lt;DeptDataPermissionRuleCustomizer&gt; customizers</code>中，遍历调用<code>customize(rule)</code>方法后，所有业务模块配置的本人和部门数据权限相关的表和字段信息就全部注册到了<code>DeptDataPermissionRule</code>对象中。</p>
<pre><code class="language-java">@AutoConfiguration
@ConditionalOnClass(LoginUser.class)
@ConditionalOnBean(value = {PermissionApi.class, DeptDataPermissionRuleCustomizer.class})
public class YudaoDeptDataPermissionAutoConfiguration {

    @Bean
    public DeptDataPermissionRule deptDataPermissionRule(PermissionApi permissionApi,
                                                         List&lt;DeptDataPermissionRuleCustomizer&gt; customizers) {
        // 创建 DeptDataPermissionRule 对象
        DeptDataPermissionRule rule = new DeptDataPermissionRule(permissionApi);
        // 补全表配置
        customizers.forEach(customizer -&gt; customizer.customize(rule));
        return rule;
    }

}
</code></pre>
<h4 id="228-datapermissionconfiguration">2.2.8 DataPermissionConfiguration</h4>
<p>system业务模块的数据权限配置类，位于<code>cn.iocoder.yudao.module.system.framework.datapermission.config.DataPermissionConfiguration</code>下，用于实例化<code>DeptDataPermissionRuleCustomizer</code>的对象将system模块下需要<code>DeptDataPermissionRule</code>规则限制的表的表名和字段名进行注册。</p>
<p>每一个需要使用<code>DeptDataPermissionRule</code>规则的业务模块(biz)都可以通过创建配置类返回<code>DeptDataPermissionRuleCustomizer</code>的方式实现部门和个人级别的数据权限控制。</p>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
public class DataPermissionConfiguration {

    @Bean
    public DeptDataPermissionRuleCustomizer sysDeptDataPermissionRuleCustomizer() {
        return rule -&gt; {
            // dept
            rule.addDeptColumn(AdminUserDO.class);
            rule.addDeptColumn(DeptDO.class, "id");
            // user
            rule.addUserColumn(AdminUserDO.class, "id");
        };
    }

}
</code></pre>
<h4 id="229-yudaodatapermissionautoconfiguration">2.2.9 YudaoDataPermissionAutoConfiguration</h4>
<p>数据权限拦截器插件的配置类，将各种规则对象<code>DataPermissionRule</code>注入到<code>DataPermissionRuleFactory</code>规则工厂中，将数据权限拦截器<code>DataPermissionInterceptor</code>注册到mybatis-plus插件队列中。</p>
<pre><code class="language-java">@AutoConfiguration
public class YudaoDataPermissionAutoConfiguration {

    @Bean
    public DataPermissionRuleFactory dataPermissionRuleFactory(List&lt;DataPermissionRule&gt; rules) {
        return new DataPermissionRuleFactoryImpl(rules);
    }

    @Bean
    public DataPermissionRuleHandler dataPermissionRuleHandler(MybatisPlusInterceptor interceptor,
                                                               DataPermissionRuleFactory ruleFactory) {
        // 创建 DataPermissionInterceptor 拦截器
        DataPermissionRuleHandler handler = new DataPermissionRuleHandler(ruleFactory);
        DataPermissionInterceptor inner = new DataPermissionInterceptor(handler);
        // 添加到 interceptor 中
        // 需要加在首个，主要是为了在分页插件前面。这个是 MyBatis Plus 的规定
        MyBatisUtils.addInterceptor(interceptor, inner, 0);
        return handler;
    }

    .........

}

</code></pre>
<h2 id="三数据权限注解处理器">三、数据权限注解处理器</h2>
<p>数据权限SQL拦截器将系统中定义了的全部数据权限规则适用于所有的场景，但是有些业务下的一些方法是不能适用某些数据权限的，例如某人在OA中只有个人数据权限，但是选择审批人时需要能找到他的领导，这时就需要对某些具体的业务方法进行特殊处理。</p>
<h3 id="31-主要涉及类和接口">3.1 主要涉及类和接口</h3>
<ul>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.annotation.DataPermission</code> 注解，加在类上或方法上，用于为某个具体的业务方法进行具体的数据权限规则控制。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.aop.DataPermissionAnnotationAdvisor</code> 类，封装一个切点(Pointcut)和通知(Advice)的Advisor接口，用于把<code>DataPermission</code>注解和注解处理器<code>DataPermissionAnnotationInterceptor</code>进行关联。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.aop.DataPermissionAnnotationInterceptor</code> 类，<code>DataPermission</code>注解的处理器。</p>
</li>
<li>
<p><code>cn.iocoder.yudao.framework.datapermission.core.aop.DataPermissionContextHolder</code> 类，封装了透传数据权限注解的上下文对象<code>ThreadLocal&lt;LinkedList&lt;DataPermission&gt;&gt; DATA_PERMISSIONS</code>和一些操作它的方法。</p>
</li>
</ul>
<h3 id="32-实现原理">3.2 实现原理</h3>
<p>在线程上下文中维护一个<code>LinkedList&lt;DataPermission&gt; list</code>，带有<code>DataPermission</code>注解的方法执行前，注解处理器会拦截到并获取注解存入list，执行完成注解处理器还会再将对应注解从list中移除，由于方法执行顺序是栈结构，后进先出，因此维护注解的list也要和方法栈一样后进先出，这样数据权限SQL拦截器在<code>DataPermissionRuleFactoryImpl</code>中获取注解时便能获取到最近一级业务方法上的注解了。</p>
<p>实现比较抽象，伪代码举例说明：</p>
<pre><code class="language-text">@anno(scope = 1)
service1() {

    mapper.sql(a);

    @anno(scope = 2)
    service2() {
        mapper.sql(b);

        @anno(scope = 3)
        service3() {
            mapper.sql(c);
        }

        mapper.sql(d);
    }

    service4() {
        mapper.sql(e);
    }
}
</code></pre>
<ol>
<li>
<p><code>service1()</code>执行<code>mapper.sql(a);</code>时，list中只有一个<code>@anno(scope = 1)</code>，<code>mapper.sql(a);</code>适用<code>@anno(scope = 1)</code>，执行到调用<code>service2()</code>时，<code>service2()</code>在方法栈的最外，list也会将<code>@anno(scope = 2)</code>维护在最外面，这样<code>mapper.sql(b);</code>被数据权限拦截器拦截时，从上下文获取到的就是<code>@anno(scope = 2)</code>，<code>service2()</code>执行完成从方法栈退出，list也会将最外的<code>@anno(scope = 2)</code>移除，只剩下<code>@anno(scope = 1)</code>，然后<code>service1()</code>继续执行调用<code>service4()</code>，因为<code>service4()</code>没有加注解，因此其中的<code>mapper.sql(e);</code>便依然适用<code>@anno(scope = 1)</code>。</p>
</li>
<li>
<p><code>service2()</code>调用<code>service3()</code>也是一样的道理，由于<code>service3()</code>也加了注解，因此执行到调用<code>service3()</code>时，list最外面就是<code>@anno(scope = 3)</code>，<code>mapper.sql(c);</code>适用<code>@anno(scope = 3)</code>，<code>service3()</code>执行完毕退出方法栈后<code>@anno(scope = 3)</code>被从list移除，<code>mapper.sql(d);</code>便还适用<code>@anno(scope = 2)</code></p>
</li>
</ol>
<p>图例说明：<br>
<img src="https://img2024.cnblogs.com/blog/3570203/202502/3570203-20250226112622058-266270440.png" alt="image" loading="lazy"></p>
<p>注解处理器根据被拦截的方法的入栈出栈顺序在线程上下文中同步维护了一个栈结构的list来存储从方法上获取的数据权限注解，方法进栈注解也"进栈"，方法出栈注解也"出栈"，注解处理器在业务方法前"抢先一步"获取业务方法上面的数据权限注解维护到线程上下文，mapper执行时数据权限SQL拦截器在规则工厂<code>DataPermissionRuleFactoryImpl</code>中从线程上下文获取到的，永远是"栈"的最顶部的那个注解，注解上设置的权限规则也刚好适用于当前mapper方法要执行的SQL，这一精巧的设计实现了对某个业务方法进行特殊的数据权限控制，而且可以保证加在最近一级方法上的注解优先生效。</p>
<h3 id="33-源码解读">3.3 源码解读</h3>
<h4 id="331-datapermission">3.3.1 @DataPermission</h4>
<p>自定义数据权限注解，可以配置数据权限是否开启、适用的数据权限规则有哪些和不适用的数据权限规则有哪些，<code>DataPermissionRuleFactoryImpl</code>从线程上下文获取到该注解后，根据这些属性和匹配逻辑进行进一步的数据权限规则处理。</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataPermission {

    /**
     * 当前类或方法是否开启数据权限
     * 即使不添加 @DataPermission 注解，默认是开启状态
     * 可通过设置 enable 为 false 禁用
     */
    boolean enable() default true;

    /**
     * 生效的数据权限规则数组，优先级高于 {@link #excludeRules()}
     */
    Class&lt;? extends DataPermissionRule&gt;[] includeRules() default {};

    /**
     * 排除的数据权限规则数组，优先级最低
     */
    Class&lt;? extends DataPermissionRule&gt;[] excludeRules() default {};

}

</code></pre>
<h4 id="332-datapermissioncontextholder">3.3.2 DataPermissionContextHolder</h4>
<p>封装了一个<code>LinkedList&lt;DataPermission&gt;</code>到线程上下文<code>ThreadLocal&lt;LinkedList&lt;DataPermission&gt;&gt; DATA_PERMISSIONS</code>中，又封装了一些对LinkedList的进出栈操作。</p>
<pre><code class="language-java">public class DataPermissionContextHolder {

    /**
     * 使用 List 的原因，可能存在方法的嵌套调用
     */
    private static final ThreadLocal&lt;LinkedList&lt;DataPermission&gt;&gt; DATA_PERMISSIONS =
            TransmittableThreadLocal.withInitial(LinkedList::new);

    /**
     * 获得当前的 DataPermission 注解
     *
     * @return DataPermission 注解
     */
    public static DataPermission get() {
        return DATA_PERMISSIONS.get().peekLast();
    }

    /**
     * 入栈 DataPermission 注解
     *
     * @param dataPermission DataPermission 注解
     */
    public static void add(DataPermission dataPermission) {
        DATA_PERMISSIONS.get().addLast(dataPermission);
    }

    /**
     * 出栈 DataPermission 注解
     *
     * @return DataPermission 注解
     */
    public static DataPermission remove() {
        DataPermission dataPermission = DATA_PERMISSIONS.get().removeLast();
        // 无元素时，清空 ThreadLocal
        if (DATA_PERMISSIONS.get().isEmpty()) {
            DATA_PERMISSIONS.remove();
        }
        return dataPermission;
    }

    /**
     * 获得所有 DataPermission
     *
     * @return DataPermission 队列
     */
    public static List&lt;DataPermission&gt; getAll() {
        return DATA_PERMISSIONS.get();
    }

    /**
     * 清空上下文
     *
     * 目前仅仅用于单测
     */
    public static void clear() {
        DATA_PERMISSIONS.remove();
    }

}

</code></pre>
<p>解读：</p>
<ol>
<li>
<p><code>get()</code>方法，取出最后一个添加进来的元素，用于<code>DataPermissionRuleFactoryImpl</code>从线程上下文获取到当前要执行的SQL适用的数据权限规则，当每个线程首次调用该方法时，ThreadLocal中的<code>LinkedList&lt;DataPermission&gt;</code>对象将被(new)创建。</p>
</li>
<li>
<p><code>add(DataPermission dataPermission)</code>方法，添加一个元素在最后面，用于注解处理器<code>DataPermissionAnnotationInterceptor</code>在方法开始前将方法上的注解存到LinkedList。</p>
</li>
<li>
<p><code>remove()</code>方法，删除最后一个添加进来的元素，用于注解处理器<code>DataPermissionAnnotationInterceptor</code>在方法执行结束后将当前方法上的注解从LinkedList中移除，当LinkedList里面没有元素时，说明方法栈最外层带有注解的业务方法也已经执行完毕，此时直接<code>DATA_PERMISSIONS.remove()</code>销毁线程上下文中的LinkedList。</p>
</li>
</ol>
<h4 id="333-datapermissionannotationadvisor">3.3.3 DataPermissionAnnotationAdvisor</h4>
<p>封装一个切点(Pointcut)和通知(Advice)的Advisor接口，用于指定<code>DataPermission</code>注解的处理器是<code>DataPermissionAnnotationInterceptor</code>。</p>
<pre><code class="language-java">@Getter
@EqualsAndHashCode(callSuper = true)
public class DataPermissionAnnotationAdvisor extends AbstractPointcutAdvisor {

    private final Advice advice;

    private final Pointcut pointcut;

    public DataPermissionAnnotationAdvisor() {
        this.advice = new DataPermissionAnnotationInterceptor();
        this.pointcut = this.buildPointcut();
    }

    protected Pointcut buildPointcut() {
        Pointcut classPointcut = new AnnotationMatchingPointcut(DataPermission.class, true);
        Pointcut methodPointcut = new AnnotationMatchingPointcut(null, DataPermission.class, true);
        return new ComposablePointcut(classPointcut).union(methodPointcut);
    }

}
</code></pre>
<p>解读：</p>
<ol>
<li>
<p><code>this.advice = new DataPermissionAnnotationInterceptor()</code>指定了切面(通知)是<code>DataPermissionAnnotationInterceptor</code></p>
</li>
<li>
<p><code>this.pointcut = this.buildPointcut()</code>指定了切点是<code>new ComposablePointcut(classPointcut).union(methodPointcut)</code></p>
</li>
<li>
<p><code>Pointcut classPointcut = new AnnotationMatchingPointcut(DataPermission.class, true)</code> 注解加在类上，类(不含父类)中所有方法都将被注解处理器拦截</p>
</li>
<li>
<p><code>Pointcut methodPointcut = new AnnotationMatchingPointcut(null, DataPermission.class, true);</code> 只根据方法的注解来匹配且只匹配直接标注该注解的方法</p>
</li>
<li>
<p><code>new ComposablePointcut(classPointcut).union(methodPointcut)</code> 无论类上的注解还是只加在方法上的注解，都进行拦截</p>
</li>
</ol>
<h4 id="334-datapermissionannotationinterceptor">3.3.4 DataPermissionAnnotationInterceptor</h4>
<p>注解处理器，加了注解的(类)方法被执行前后获取注解，保存到线程上下文的<code>LinkedList&lt;DataPermission&gt;</code>中。</p>
<pre><code class="language-java">@DataPermission // 该注解，用于 {@link DATA_PERMISSION_NULL} 的空对象
public class DataPermissionAnnotationInterceptor implements MethodInterceptor {

    /**
     * DataPermission 空对象，用于方法无 {@link DataPermission} 注解时，使用 DATA_PERMISSION_NULL 进行占位
     */
    static final DataPermission DATA_PERMISSION_NULL = DataPermissionAnnotationInterceptor.class.getAnnotation(DataPermission.class);

    @Getter
    private final Map&lt;MethodClassKey, DataPermission&gt; dataPermissionCache = new ConcurrentHashMap&lt;&gt;();

    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        // 入栈
        DataPermission dataPermission = this.findAnnotation(methodInvocation);
        if (dataPermission != null) {
            DataPermissionContextHolder.add(dataPermission);
        }
        try {
            // 执行逻辑
            return methodInvocation.proceed();
        } finally {
            // 出栈
            if (dataPermission != null) {
                DataPermissionContextHolder.remove();
            }
        }
    }

    private DataPermission findAnnotation(MethodInvocation methodInvocation) {
        // 1. 从缓存中获取
        Method method = methodInvocation.getMethod();
        Object targetObject = methodInvocation.getThis();
        Class&lt;?&gt; clazz = targetObject != null ? targetObject.getClass() : method.getDeclaringClass();
        MethodClassKey methodClassKey = new MethodClassKey(method, clazz);
        DataPermission dataPermission = dataPermissionCache.get(methodClassKey);
        if (dataPermission != null) {
            return dataPermission != DATA_PERMISSION_NULL ? dataPermission : null;
        }

        // 2.1 从方法中获取
        dataPermission = AnnotationUtils.findAnnotation(method, DataPermission.class);
        // 2.2 从类上获取
        if (dataPermission == null) {
            dataPermission = AnnotationUtils.findAnnotation(clazz, DataPermission.class);
        }
        // 2.3 添加到缓存中
        dataPermissionCache.put(methodClassKey, dataPermission != null ? dataPermission : DATA_PERMISSION_NULL);
        return dataPermission;
    }

}

</code></pre>
<p>解读：</p>
<ol>
<li>
<p><code>DataPermissionContextHolder.add(dataPermission)</code> 执行前获取方法上的注解，存入线程上下文中的List(进栈)</p>
</li>
<li>
<p><code>methodInvocation.proceed();</code> 目标方法执行</p>
</li>
<li>
<p><code>DataPermissionContextHolder.remove();</code> 执行完毕后从线程上下文中的List移除(出栈)</p>
</li>
</ol>
<h4 id="335-yudaodatapermissionautoconfiguration">3.3.5 YudaoDataPermissionAutoConfiguration</h4>
<p>将数据权限注解处理器Advisor加入Spring容器</p>
<pre><code class="language-java">@AutoConfiguration
public class YudaoDataPermissionAutoConfiguration {

    .........

    @Bean
    public DataPermissionAnnotationAdvisor dataPermissionAnnotationAdvisor() {
        return new DataPermissionAnnotationAdvisor();
    }

}

</code></pre>
<h2 id="四总结">四、总结</h2>
<p>数据权限是一个比较常用的功能，芋道源码通过mybatis-plus自定义插件在SQL执行前拦截并解析到对应的表，根据数据权限规则对这些表追加where条件来实现数据权限控制，对于一些需要单独指定数据权限的业务方法，通过数据权限注解和结合线程上下文对加了注解的方法进行前置和后置的处理，把当前方法适用的数据权限规则传递给数据权限SQL解析器进行额外处理，使得数据权限规则既能全局生效又能局部调整。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03600717606134259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 11:27">2025-02-26 11:27</span>&nbsp;
<a href="https://www.cnblogs.com/changelzj">LiuZijian</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18738111" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18738111);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18738111', targetLink: 'https://www.cnblogs.com/changelzj/p/18738111', title: '芋道源码解析之数据权限' })">举报</a>
</div>
        