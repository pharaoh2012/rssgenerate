
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/PJRAWA/p/18900927" title="发布于 2025-05-28 17:01">
    <span role="heading" aria-level="2">从实际的编程示例中看i++与++i的区别</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>举一个简单的例子，我们希望<code>给一个长字符串出现的每个字符的数量进行打表</code></p>
<p>这里给出部分代码</p>
<pre><code class="language-java">String p;
HashMap&lt;Character,Integer&gt; map =new HashMap&lt;&gt;();//使用hashmap存键值对
for(int i =0;i&lt;stringLong;i++){
    int count =map.getOrDefault(p.charAt(i),0);//map中有值取值，没值默认为0
    map.put(p.charAt(i),count++);
}
</code></pre>
<p>我们来看看结果：</p>
<pre><code class="language-java">//假设这个p是“abcdabcd”
//运行后你会发现map中的值为{‘a’:0,'b':0,'c':0,'d':0}
</code></pre>
<hr>
<h3 id="为什么字符数量都为零呢因为在java中count是后置递增操作符在执行中导致在count值为0时存入map">为什么字符数量都为零呢？因为在Java中，<mark>count++是后置递增操作符</mark>在执行中导致在<code>count</code>值为0时存入<code>map</code>。</h3>
<hr>
<p>在 Java 中，<code>i++</code>（后置递增）和 <code>++i</code>（前置递增）是自增运算符的两种形式，它们的核心区别在于<strong>操作顺序</strong>和<strong>返回值</strong></p>
<ul>
<li>
<p><strong><code>i++</code></strong>：先返回变量的当前值，再执行自增操作。<br>
示例：</p>
<pre><code class="language-java">int i = 5;
int a = i++;  // a=5，之后i=6
</code></pre>
<p><em>此时 <code>i++</code> 将原值用于表达式，后自增</em>。</p>
</li>
<li>
<p><strong><code>++i</code></strong>：先执行自增操作，再返回新值。<br>
示例：</p>
<pre><code class="language-java">int i = 5;
int b = ++i;  // i先变为6，之后b=6
</code></pre>
<p><em><code>++i</code> 立即更新变量值，再参与运算</em>。</p>
</li>
</ul>
<p><strong>表达式中的优先级</strong></p>
<ul>
<li>
<p><strong>i++</strong>的优先级高于<strong>++i</strong></p>
<p>特别需注意与其他运算符结合时的行为：</p>
<pre><code class="language-java">int i = 3;
System.out.println(i++ * 2);  // 输出6（3 * 2）
int j = 3;
System.out.println(++j * 2);  // 输出8（4 * 2）
</code></pre>
</li>
</ul>
<p><strong>性能细微差异</strong></p>
<pre><code class="language-java">for (int i = 0; i &lt; 10; i++);    // 与 ++i 等效
</code></pre>
<p>循环中实际编译后生成的字节码甚至可能完全一致。</p>
<p>但是对于一个对象Object obj:</p>
<ul>
<li><strong><code>obj++</code></strong>：需要生成临时对象保存原值，可能产生额外开销（如拷贝构造函数调用）。</li>
<li><strong><code>++obj</code></strong>：直接修改对象，无需临时对象，效率更高。<br>
<em>因此建议在处理迭代器或自定义类时优先使用 <code>++obj</code></em>。这也是为什么Leetcode答案中循环代码喜欢用<code>++i</code></li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li>
<p>同一表达式中多次自增可能导致不同结果：</p>
<pre><code class="language-java">int i = 0;
int x = i++ + ++i;  // 不同编译器可能结果不同，而且难以阅读
</code></pre>
<p>应避免此类写法。</p>
</li>
<li>
<p>运算符优先级陷阱</p>
<p>i++的优先级高于大部分运算符，可能导致逻辑错误：</p>
<pre><code class="language-java">int j = 5;
int k = j++ * 2;  // k=10，j=6（而非 5 * 2=10）容易犯错，还是老老实实写j+1吧
</code></pre>
</li>
</ol>
<hr>
<hr>
<hr>
<h1 id="总结一句话i在前面是原值i在后面先计算">总结一句话：i在前面是原值，i在后面先计算</h1>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong><code>i++</code></strong></th>
<th><strong><code>++i</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>返回值</strong></td>
<td>原值</td>
<td>新值</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需保留旧值的计算</td>
<td>需直接使用新值的操作</td>
</tr>
<tr>
<td><strong>性能建议</strong></td>
<td>基本类型无差异，对象类慎用</td>
<td>对象类优先使用</td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.46797483858912037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-28 17:03">2025-05-28 17:01</span>&nbsp;
<a href="https://www.cnblogs.com/PJRAWA">IPJRI</a>&nbsp;
阅读(<span id="post_view_count">99</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18900927);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18900927', targetLink: 'https://www.cnblogs.com/PJRAWA/p/18900927', title: '从实际的编程示例中看i++与++i的区别' })">举报</a>
</div>
        