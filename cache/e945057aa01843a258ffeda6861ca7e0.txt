
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rikkkkka/p/19015833" title="发布于 2025-07-31 20:06">
    <span role="heading" aria-level="2">[浅谈数据结构] 浅谈树状数组</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1作用">1.作用</h2>
<p>树状数组是一种<strong>高效</strong>而简单的数据结构，用于*大部分<strong>区间修改</strong>和<strong>查询问题</strong>，形如<span class="math inline">\(a[1]+a[2]+a[3]+a[4]+...+a[n]\)</span>（其不支持的可以由<strong>线段树</strong>替代）</p>
<h2 id="2选择原因">2.选择原因</h2>
<p>优点：树状数组的<strong>码量</strong>明显比线段树<strong>短</strong>，<strong>时间复杂度</strong>比朴素算法与线段树更<strong>优</strong>，<strong>空间复杂度</strong>则<strong>吊打</strong>线段树</p>
<p>缺点：部分线段树能解决的问题树状数组解决不了</p>
<h2 id="3基本原理实现方法">3.基本原理&amp;实现方法</h2>
<p>如图(from OIWiki)<br>
<img src="https://oi-wiki.org/ds/images/fenwick.svg" alt="" loading="lazy"></p>
<p>在求解<span class="math inline">\(a[1]+a[2]+a[3]+a[4]+...+a[n]\)</span>这类问题时，根据上图这种数据结构，我们可以高效的进行查询</p>
<h3 id="30lowbit">3.0.<strong>lowbit</strong></h3>
<h4 id="301思路">3.0.1.思路</h4>
<p><strong>干什么的</strong>：求一个非负整数<span class="math inline">\(n\)</span>在二进制下的最低为1的位的个数（1）及其后面的0的位数构成的数（1+后面0的个数）</p>
<p><strong>怎么干</strong>:<code>return x&amp;(-x)</code></p>
<p><strong>原理</strong>（不会可以跳过，但要背结论）:</p>
<p>我们得到lowbit的值，只需要得到最后一个1的位置，并且把除了这个位置之外的所有位置全部置成零。然后输出就可以。思路有了，如何操作？</p>
<p>根据计算机补码的性质，补码就是原码的反码加一</p>
<p>如：</p>
<p><span class="math inline">\((110)_{2}\)</span></p>
<p>反码：</p>
<p><span class="math inline">\((001)_{2}\)</span></p>
<p>加一：</p>
<p><span class="math inline">\((010)_{2}\)</span></p>
<p>可以发现变为反码后 <span class="math inline">\(x\)</span> 与反码数字位每一位都不同， 所以当反码加<span class="math inline">\(1\)</span>后会逢<span class="math inline">\(1\)</span>一直进位直到遇到<span class="math inline">\(0\)</span>，这个<span class="math inline">\(0\)</span>变成了<span class="math inline">\(1\)</span>，操作停止。</p>
<p>进位的部分相当于再一次取反，也就还原原著。而最后变为1的部分又停在最后一个为0的位置，也就是取反前1的位置了，正好完成操作</p>
<p>又有人要问了：主播主播，我也没得到最终结果啊，如果停止进位后前面还有0呢？操作前二进制后的数我们默认它不存在前导零，也就是最高位不可能是0，也就必定是1，取反后为0，得到的一定是一最高位为0的数，而0又可以舍去，因此合理</p>
<p>举个例子，110000~001111  形如0001000可以转化为1000，也就是说最高位不可能是0</p>
<h4 id="302代码">3.0.2.代码</h4>
<pre><code class="language-cpp">int lowbit(int x)
{
	return x&amp;(-x);
}
</code></pre>
<h3 id="31如何修改单点">3.1.如何修改单点？</h3>
<h3 id="311思路">3.1.1.思路</h3>
<p>更新一个点也要更新其祖上十八代，祖上十八代怎么推？<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/f06db84c2ece21dcd2069fae8bfb95ee.png" alt="" loading="lazy"><br>
我们发现每向上一层<span class="math inline">\(lowbit\)</span>值都增加<span class="math inline">\(1\)</span>,因此得到增加单点代码：</p>
<h3 id="312-代码">3.1.2 代码</h3>
<p>修改单点：</p>
<pre><code class="language-cpp">void build(int x,int k)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
	{
		c[i]+=k;
	}
}
</code></pre>
<p>修改单点的扩大既是建树（只进行浅谈篇的操作）：</p>
<pre><code class="language-cpp">void build(int x,int k)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
	{
		c[i]+=k;
	}
}
//...
int main()
{
	for (int i = 1; i &lt;= n; i++) 
	{
		add(i, c[i]);
	}
}

</code></pre>
<h3 id="32如何查询1x的和">3.2.<strong>如何查询1~x的和？</strong></h3>
<h4 id="321思路">3.2.1.思路</h4>
<p>举例计算<span class="math inline">\(a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]\)</span>的和</p>
<p>从<span class="math inline">\(a[7]\)</span>开始跳，跳到<span class="math inline">\(c[7]\)</span>上，发现<span class="math inline">\(c[7]\)</span>只管辖<span class="math inline">\(a[7]\)</span>,再跳到<span class="math inline">\(c[6]\)</span>上，发现其管辖<span class="math inline">\(a[5]+a[6]\)</span>,再跳到<span class="math inline">\(a[4]\)</span>上，发现其管辖<span class="math inline">\(a[1]+a[2]+a[3]+a[4]\)</span>,发现我们得到最终答案。</p>
<p>完整推导:</p>
<p><span class="math inline">\(a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]=c[7]+c[6]+c[4]\)</span></p>
<p>关注等式右侧三个数在树上的关系<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/1bf4a100bdd81505142ccdaf4b3faf4f.png" alt="" loading="lazy"><br>
再关注等式右侧本身的关系，先推导出<span class="math inline">\(4,6,7\)</span>的二进制表示</p>
<p><span class="math inline">\(4=11_{2},6=110_{2},7=111_{2}\)</span></p>
<p>研究其关系，发现<span class="math inline">\(6=7-lowbit(7),4=6-lowbit(6)\)</span></p>
<p>所以<span class="math inline">\(code\)</span>:</p>
<h4 id="322代码">3.2.2.代码</h4>
<pre><code class="language-cpp">int ask(int x)
{
	int ans=0;
	for(int i=1;i&lt;=x;i-=lowbit(x))
	{
		ans+=c[i];
	}
	return ans;
}
</code></pre>
<h3 id="33如何查询任意数x的和">3.3.如何查询任意数~x的和？</h3>
<h4 id="331思路">3.3.1.思路</h4>
<p>前缀和相减（听着很抽象）</p>
<p>公式：<span class="math inline">\(a[1,r]-a[1,l-1]=a[l,r]\)</span></p>
<h4 id="332代码">3.3.2.代码</h4>
<pre><code class="language-cpp">int ask(int x)
{
	int ans=0;
	for(int i=L-1;i;i-=lowbit(i))
	{
		ans-=c[i];
	}
	for(int i=R;i;i-=lowbit(i))
	{
		ans+=c[i];
	}
	return ans;
}
</code></pre>
<h2 id="4总结练习展望">4.总结&amp;练习&amp;展望</h2>
<h3 id="41总结">4.1.总结</h3>
<p>在浅谈篇中，注意到我们使用树状数组进行了<strong>查询区间和</strong>与<strong>修改单点</strong>的操作。这是最基本的使用。回忆一下，该二操作关键点在于<span class="math inline">\(lowbit\)</span>。</p>
<h3 id="42练习">4.2.练习</h3>
<p>建议同学们完成:</p>
<p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener nofollow">模板：树状数组1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1908" target="_blank" rel="noopener nofollow">找逆序对</a></p>
<h3 id="43展望">4.3.展望</h3>
<p>在下一篇再谈篇中，我们将学习使用前缀和与差分实现区间修改与单点查询，~~~然后就可以开YNOI毒瘤了~</p>
<p>注意到本文由<strong>博客园</strong> @OIRikka,<strong>洛谷</strong> @March7thDev撰写，禁止<strong>任何形式</strong>的转载！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-07-31 20:13">2025-07-31 20:06</span>&nbsp;
<a href="https://www.cnblogs.com/rikkkkka">OIRikka</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19015833);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19015833', targetLink: 'https://www.cnblogs.com/rikkkkka/p/19015833', title: '[浅谈数据结构] 浅谈树状数组' })">举报</a>
</div>
        