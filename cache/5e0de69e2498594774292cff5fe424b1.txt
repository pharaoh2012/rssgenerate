
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/XuYueming/p/18857581" title="发布于 2025-05-04 15:52">
    <span role="heading" aria-level="2">仙人掌生成器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>网上找不到正确生成仙人掌的 gen，唯一的一篇似乎是错误的，所以手写一篇。</p>
<h2 id="仙人掌的定义">仙人掌的定义</h2>
<p>仙人掌：任意一条边最多出现在一个简单环中的无向连通图。</p>
<h2 id="生成算法">生成算法</h2>
<p>给定 <span class="math inline">\(n\)</span> 作为仙人掌结点数。先随机生成一棵树，作为目标仙人掌的一棵 dfs 树，这保证了图连通这一条件，接下来要做的就是不断往这棵树上加非树边，同时满足「任意一条边最多出现在一个简单环中」这一限制条件。可选地，我们可以限制边数上界。</p>
<p>考虑 dfs 这棵树，当前在 <span class="math inline">\(u\)</span>，尝试添加一条以 <span class="math inline">\(u\)</span> 为上端点的非树边，那么下端点 <span class="math inline">\(v\)</span> 需要满足：<span class="math inline">\(u\rightarrow v\)</span> 路径上的树边均未被环包含。于是我们可以在 dfs 的时候 <code>return</code> 出一个 <span class="math inline">\(v\)</span>，作为未来可能作为下端点的点。</p>
<p><span class="math inline">\(u\)</span> 的初始返回值就是其本身。考虑 dfs 完 <span class="math inline">\(u\)</span> 的一个孩子 <span class="math inline">\(v\)</span>，返回值为 <span class="math inline">\(t\)</span>，我们有一定概率用 <span class="math inline">\(t\)</span> 替换 <span class="math inline">\(u\)</span> 的返回值，如果不作为范围值，有一定概率尝试将 <span class="math inline">\(u,t\)</span> 之间加一条非树边。</p>
<p>另外，我们可以在此基础上进行适当扩展，例如，要求环必须全都是奇环，要求不能有重边。注意，在允许重边的前提下，重边的个数不能超过 <span class="math inline">\(2\)</span> 条。</p>
<h2 id="算法分析">算法分析</h2>
<p>该算法的时间复杂度为：<span class="math inline">\(\mathcal{O}(n+m)\)</span>。</p>
<p>虽然该算法不能保证等概率地，在所有 <span class="math inline">\(n\)</span> 个结点的仙人掌中，随机选择一棵仙人掌，但是作为对拍的 gen 已经足够了。</p>
<h2 id="代码实现">代码实现</h2>
<p>使用 C++ 实现，请使用 C++14 及以上版本编译。</p>
<p>支持修改随机数种子（默认为当前时间戳）、是否允许重边、是否只允许奇环、点数、边数上界（默认为 <span class="math inline">\(-1\)</span> 即不限制）。</p>
<p>将生成的仙人掌输出到标准输出流，额外的信息、错误信息输出到标准错误流。程序返回值为 <span class="math inline">\(0\)</span> 表示生成成功。</p>
<p>输出格式：第一行两个以空格分隔的整数 <span class="math inline">\(n,m\)</span>，分别表示仙人掌的结点数、边数；接下来 <span class="math inline">\(m\)</span> 行表示仙人掌的边。</p>
<details codes="">
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;random&gt;
#include &lt;chrono&gt;
using namespace std;

/* =========== Parameter =========== */

const int SEED = chrono::system_clock::now().time_since_epoch().count();

bool multiedge = false;
bool onlyOddCircle = false;

int n = 1000000;
int m_limit = -1;  // -1 for not limit

/* =========== Parameter =========== */

void _err(const char* msg, int lineNum) {
    fprintf(stderr, "Error at line #%d: %s\n", lineNum, msg);
    exit(1);
}
#define err(msg) _err(msg, __LINE__)

inline int rand(int l, int r) {
    static mt19937 rnd(SEED);
    if (l &gt; r) err("invalid range");
    return l + rnd() % (r - l + 1);
}

vector&lt;pair&lt;int, int&gt;&gt; edges;
vector&lt;vector&lt;int&gt;&gt; son(n, vector&lt;int&gt;());
vector&lt;int&gt; dpt(n);

int dfs(int u) {
    int res = u;
	int cnt = 0;
    for (size_t i = 0; i &lt; son[u].size(); ++i) {
        int v = son[u][i];
		dpt[v] = dpt[u] + 1;
        int t = dfs(v);
        if (rand(0, son[u].size()) == 0)
            res = t;
        else if ((t != v || (multiedge &amp;&amp; cnt &lt; 2))
                &amp;&amp; ((dpt[t] - dpt[u] + 1) % 2 == 1 || !onlyOddCircle)
                &amp;&amp; (m_limit == -1 || (int)edges.size() &lt; m_limit))
            edges.emplace_back(u, t), cnt += t == v;
    }
    return res;
}

signed main() {
    // freopen("yzh", "w", stdout);
    
    if (n &lt; 1) err("n shouldn't be less than 1");
    if (m_limit != -1 &amp;&amp; m_limit &lt; n - 1)
        err("m_limit shouldn't less than n-1");
    
    for (int i = 1; i &lt; n; ++i) {
        int fa = rand(0, i - 1);
        edges.emplace_back(fa, i);
        son[fa].emplace_back(i);
    }
    dfs(0);
    
    for (size_t i = 1; i &lt; edges.size(); ++i)
        swap(edges[i], edges[rand(0, i)]);
    
    printf("%d %d\n", n, (int)edges.size());
    for (size_t i = 0; i &lt; edges.size(); ++i) {
        int u = edges[i].first;
        int v = edges[i].second;
        if (rand(0, 1)) swap(u, v);
        printf("%d %d\n", u + 1, v + 1);
    }
    
    fprintf(stderr, "Success!\n");
    fprintf(stderr, "n = %d, m = %d\n", n, (int)edges.size());
    fprintf(stderr, "circle = %d\n", (int)edges.size() - (n - 1));
    return 0;
}
</code></pre>
</details>
<h2 id="checker">Checker</h2>
<p>写了一个程序用来验证 gen 的正确性。使用并查集判断连通性、dfs 序求 <span class="math inline">\(\operatorname{lca}\)</span>、差分完成树链覆盖。时间复杂度是 <span class="math inline">\(\mathcal{O}(m+n\log n)\)</span> 的，尽管可以优化到线性 <span class="math inline">\(\mathcal{O}(n+m)\)</span>。</p>
<p>支持修改是否检查仅允许奇环。</p>
<p>从标准输入流读入图，程序返回值为 <span class="math inline">\(0\)</span> 表示图为仙人掌。</p>
<details codes="">
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

/* =========== Parameter =========== */

bool checkOnlyOddCircle = false;
const int N = 1e6 + 10;

/* =========== Parameter =========== */

void _err(const char* msg, int lineNum) {
    fprintf(stderr, "Error at line #%d: %s\n", lineNum, msg);
    exit(1);
}
#define err(msg) _err(msg, __LINE__)

const int lgN = __lg(N) + 1;

int n, m;

namespace $dsu {
int fa[N];
int get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }
}

vector&lt;int&gt; son[N];
vector&lt;pair&lt;int, int&gt;&gt; edges;

int fa[N], dpt[N];
int st[lgN][N], idx[N], timer;

void dfs(int u) {
    st[0][idx[u] = ++timer] = u;
    for (int v : son[u]) {
        if (v == fa[u]) continue;
        fa[v] = u, dpt[v] = dpt[u] + 1;
        dfs(v);
    }
}
inline int Min(int u, int v) {
    return dpt[u] &lt; dpt[v] ? u : v;
}
inline int lca(int u, int v) {
    if (u == v) return u;
    if ((u = idx[u]) &gt; (v = idx[v]))
        swap(u, v);
    int p = __lg(v - u++);
    return fa[Min(st[p][u], st[p][v - (1 &lt;&lt; p) + 1])];
}

int sum[N];
void redfs(int u) {
    for (int v : son[u]) {
        if (v == fa[u]) continue;
        redfs(v);
        sum[u] += sum[v];
    }
    if (sum[u] &gt; 2) err("an edge appears in more than one simple circle");
}

signed main() {
    scanf("%d%d", &amp;n, &amp;m);
    if (n &lt; 1) err("n shouldn't be less than 1");
    if (n &gt; 1000000) err("n is too big that input can't be determined");
    for (int i = 1; i &lt;= n; ++i) $dsu::fa[i] = i;
    for (int i = 1, u, v; i &lt;= m; ++i) {
        scanf("%d%d", &amp;u, &amp;v);
        if (u == v) err("self-loop exists");
        if (u &lt; 1 || u &gt; n) err("node number out of range");
        if (v &lt; 1 || v &gt; n) err("node number out of range");
        int tu = $dsu::get(u), tv = $dsu::get(v);
        if (tu == tv) {
            edges.emplace_back(u, v);
        } else {
            $dsu::fa[tu] = tv;
            son[u].emplace_back(v);
            son[v].emplace_back(u);
        }
    }
    for (int i = 2; i &lt;= n; ++i)
        if ($dsu::get(i) != $dsu::get(1))
            err("graph not connected");
    dfs(1);
    for (int k = 1; k &lt; lgN; ++k)
        for (int i = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; ++i)
            st[k][i] = Min(st[k - 1][i], st[k - 1][i + (1 &lt;&lt; (k - 1))]);
    for (size_t i = 0; i &lt; edges.size(); ++i) {
        int u = edges[i].first;
        int v = edges[i].second;
        int p = lca(u, v);
        ++sum[u], ++sum[v];
        sum[p] -= 2;
        
        int len = dpt[u] + dpt[v] - 2 * dpt[p] + 1;
        if (len % 2 == 0 &amp;&amp; checkOnlyOddCircle)
            err("odd circle exists");
    }
    redfs(1);
    fprintf(stderr, "Success!\n");
    fprintf(stderr, "the input is a cactus with %d circle(s)!\n", (int)edges.size());
    return 0;
}
</code></pre>
</details>
<h2 id="广告">广告</h2>
<p>我的博文<a href="https://www.cnblogs.com/XuYueming/p/18313014" target="_blank">《圆方树学习笔记 —— 一种关于点双连通分量的思考方式》</a>历时一个半月的编写，即将发布，欢迎前来学习！</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>
  本文作者：<a href="https://www.cnblogs.com/XuYueming/" target="_blank">XuYueming</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/XuYueming/p/18857581" target="_blank">https://www.cnblogs.com/XuYueming/p/18857581</a>。
</p>

<p>
  若未作特殊说明，本作品采用
  <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="license">
    知识共享署名-非商业性使用 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19143195457291667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-04 15:52">2025-05-04 15:52</span>&nbsp;
<a href="https://www.cnblogs.com/XuYueming">XuYueming</a>&nbsp;
阅读(<span id="post_view_count">57</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18857581);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18857581', targetLink: 'https://www.cnblogs.com/XuYueming/p/18857581', title: '仙人掌生成器' })">举报</a>
</div>
        