
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Imageshop/p/18878608" title="发布于 2025-05-16 15:29">
    <span role="heading" aria-level="2">【工程应用十】 基于Hessian矩阵的Frangi滤波算法 == 血管图像增强 == Matlab中fibermetric函数的自我实现、加速和优化。</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        基于Hessian矩阵特征值的纤维状目标增强算法，在医学领域，特别适合于血管方面的提取，前几天在翻一翻matlab中的帮助文档，无意中发现一个叫fibermetric的图像处理函数，正好是和这个有关的，因此，花费了几天时间予以优化和实现，本文记录了相关的研究过程和经验。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-size: 13px">　　前几天在翻一翻matlab中的帮助文档，无意中发现一个叫fibermetric的图像处理函数，感觉有点意思，可以增强或者说突出一些类似于管状的对象，后面看了下算法的帮助文档，在百度上找了找，原来这也是一种比较经典的增强算法。</span></p>
<p><span style="font-size: 13px">　　核心的论文是《Multiscale vessel enhancement filtering》，可以从这里下载得到：https://www.researchgate.net/publication/2388170_Multiscale_Vessel_Enhancement_Filtering；</span></p>
<p><span style="font-size: 13px">　　至于论文的思想，除了直接看原始论文，我也还参考了一下几篇文章：</span></p>
<p><span style="font-size: 13px">　　<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter%20Hessian%20based%20Frangi%20Vesselness%20filter%20" target="_blank" rel="noopener nofollow">https://ww2.mathworks.cn/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter Hessian based Frangi Vesselness filter&nbsp;</a> &nbsp;原始作者的matlab实现</span><br><span style="font-size: 13px">　　<a href="https://github.com/BoguslawObara/vesselness2d" target="_blank" rel="noopener nofollow">https://github.com/BoguslawObara/vesselness2d</a>	　　　　	　　	　&nbsp; &nbsp;2d multiscale vessel enhancement filtering</span><br><span style="font-size: 13px">&nbsp;　&nbsp; <a href="https://www.cnblogs.com/jsxyhelu/p/18157603%20" target="_blank">https://www.cnblogs.com/jsxyhelu/p/18157603	</a>　　　　	　　	　　&nbsp; &nbsp;Hessian矩阵以及在血管增强中的应用——OpenCV实现【2024年更新】</span><br><span style="font-size: 13px">&nbsp; &nbsp; &nbsp; <a href="https://blog.csdn.net/piaoxuezhong/article/details/78428785" target="_blank" rel="noopener nofollow">https://blog.csdn.net/piaoxuezhong/article/details/78428785</a>　　　　眼底图像血管增强与分割--（5）基于Hessian矩阵的Frangi滤波算法</span><br><span style="font-size: 13px">　&nbsp; <a href="https://blog.csdn.net/lwzkiller/article/details/55050275%20" target="_blank" rel="noopener nofollow">https://blog.csdn.net/lwzkiller/article/details/55050275	</a>　　　　	　　										Hessian矩阵以及在图像中的应用</span><br><span style="font-size: 13px">&nbsp;　 <a href="https://zhuanlan.zhihu.com/p/127951058%20" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/127951058	</a>　　　　　　　　　　　　																Multiscale Vessel Enhancement Filtering(多尺度血管增强滤波，基本是对原英文的翻译）</span></p>
<p><span style="font-size: 13px">　　但是说实在的我没有看明白原理，懵懵懂懂的，反正大概就是知道通过判断Hessian矩阵的两个特征值之间的某些关系可以确定某个位置是否属于血管或者说管状结构，我觉得呢大概看懂论文里这个表可能就比较好了：</span></p>
<p><span style="font-size: 13px"><img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516122410089-1042491480.png" width="1000" loading="lazy"></span></p>
<p><span style="font-size: 13px">　　我们重点关注2D的情况。</span></p>
<p><span style="font-size: 13px">　　表中Lambda1和Lambda2分别为某个尺度下的Hessian矩阵的特征值，并且是|Lambda1| &lt; |Lambda2|，对于管状对象，一般是|Lambda1| &lt;&lt; |Lambda2|，其中 &lt;&lt;表示远远小于，另外呢，一个先验就是在血管图像中背景部分的像素其Hessian矩阵的特征值一般都比较小，因此，基于这两个特征呢，构造了一下两个中间变量来衡量一个位置的像素是属于血管还是背景：</span></p>
<p><span style="font-size: 13px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516123451610-640896620.png" width="600" loading="lazy">　　　　</span></p>
<p><span style="font-size: 13px">　&nbsp; 　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516123512325-1678873539.png" width="400" loading="lazy"></span></p>
<p><span style="font-size: 13px">　　对于2D图像，R<sub>B</sub>可以简化为&nbsp; R<sub>B</sub>&nbsp;= |Lambda1| / |Lambda2|，而S则即为&nbsp; &nbsp;S = sqrt(Lambda1^2 + Lambda2^2)；</span></p>
<p><span style="font-size: 13px">　　利用这两个中间变量，然后构架了下式作为某个像素的输出响应：</span></p>
<p><span style="font-size: 13px">　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516124058935-1635703856.png" width="600" loading="lazy"></span></p>
<p><span style="font-size: 13px">　　其中Beta和C是一些可调节参数，Beta默认可设置为0.5。C后面再说。　　</span></p>
<p><span style="font-size: 13px">　　注意观察，上面公式的下半部分是两个指数函数的乘积，而指数函数内部的参数必然是负值（2个平方数相除在求负），这个指数函数范围的有效值为【0,1】，后面部分的1-exp(//)的范围也必然是【0,1】。 因此2项的乘积必然也是在【0,1】之间。</span></p>
<p><span style="font-size: 13px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516132239139-56332795.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　第一个指数项中，如果R<sub>B</sub>值越小，则指数值越大，第二个项目中，如果S值越大，则指数值越大， 这恰好正确的反映了前面所说血管区域的特征。&nbsp;</span></p>
<p><span style="font-size: 13px">　　对于某一个尺度下的响应使用上述公式，而为了获得更为理想的效果，可以使用连续的多个尺度进行计算，然后取每个尺度下的最大值作为最终的响应值。</span></p>
<p><span style="font-size: 13px">　　具体到实现代码，我们首先参考了论文作者自己的代码，这个可在<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter%20Hessian%20based%20Frangi%20Vesselness%20filter%20" target="_blank" rel="noopener nofollow">https://ww2.mathworks.cn/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter Hessian based Frangi Vesselness filter</a>下载。</span></p>
<p><span style="font-size: 13px">　　我们贴一下这个代码的主要函数：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">sigmas=options.FrangiScaleRange(<span style="color: rgba(128, 0, 128, 1)">1</span>):options.FrangiScaleRatio:options.FrangiScaleRange(<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">);
sigmas </span>= sort(sigmas, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">ascend</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);
beta  </span>= <span style="color: rgba(128, 0, 128, 1)">2</span>*options.FrangiBetaOne^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">;
c     </span>= <span style="color: rgba(128, 0, 128, 1)">2</span>*options.FrangiBetaTwo^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">;
</span>%<span style="color: rgba(0, 0, 0, 1)"> Make matrices to store all filterd images
ALLfiltered</span>=<span style="color: rgba(0, 0, 0, 1)">zeros([size(I) length(sigmas)]);
ALLangles</span>=<span style="color: rgba(0, 0, 0, 1)">zeros([size(I) length(sigmas)]);
</span>% Frangi filter <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> all sigmas
</span><span style="color: rgba(0, 0, 255, 1)">for</span> i = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">:length(sigmas),</span>%<span style="color: rgba(0, 0, 0, 1)"> Make 2D hessian
    [Dxx,Dxy,Dyy] </span>=<span style="color: rgba(0, 0, 0, 1)"> Hessian2D(I,sigmas(i));
    </span>% Correct <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> scale
    Dxx </span>= (sigmas(i)^<span style="color: rgba(128, 0, 128, 1)">2</span>)*<span style="color: rgba(0, 0, 0, 1)">Dxx;
    Dxy </span>= (sigmas(i)^<span style="color: rgba(128, 0, 128, 1)">2</span>)*<span style="color: rgba(0, 0, 0, 1)">Dxy;
    Dyy </span>= (sigmas(i)^<span style="color: rgba(128, 0, 128, 1)">2</span>)*<span style="color: rgba(0, 0, 0, 1)">Dyy;
    </span>%<span style="color: rgba(0, 0, 0, 1)"> Calculate (abs sorted) eigenvalues and vectors
    [Lambda2,Lambda1,Ix,Iy]</span>=<span style="color: rgba(0, 0, 0, 1)">eig2image(Dxx,Dxy,Dyy);
    </span>%<span style="color: rgba(0, 0, 0, 1)"> Compute the direction of the minor eigenvector
    angles </span>=<span style="color: rgba(0, 0, 0, 1)"> atan2(Ix,Iy);
    </span>%<span style="color: rgba(0, 0, 0, 1)"> Compute some similarity measures
    Lambda1(Lambda1</span>==<span style="color: rgba(128, 0, 128, 1)">0</span>) =<span style="color: rgba(0, 0, 0, 1)"> eps;
    Rb </span>= (Lambda2./Lambda1).^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">;
    S2 </span>= Lambda1.^<span style="color: rgba(128, 0, 128, 1)">2</span> + Lambda2.^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">;
    </span>%<span style="color: rgba(0, 0, 0, 1)"> Compute the output image
    Ifiltered </span>= exp(-Rb/beta) .*(ones(size(I))-exp(-S2/<span style="color: rgba(0, 0, 0, 1)">c));
    
    </span>% see pp. <span style="color: rgba(128, 0, 128, 1)">45</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(options.BlackWhite)
        Ifiltered(Lambda1</span>&lt;<span style="color: rgba(128, 0, 128, 1)">0</span>)=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
        Ifiltered(Lambda1</span>&gt;<span style="color: rgba(128, 0, 128, 1)">0</span>)=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
    end
    </span>% store the results <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> 3D matrices
    ALLfiltered(:,:,i) </span>=<span style="color: rgba(0, 0, 0, 1)"> Ifiltered;
    ALLangles(:,:,i) </span>=<span style="color: rgba(0, 0, 0, 1)"> angles;
end</span></span></pre>
</div>
<p><span style="font-size: 13px">　　其中Hessian2D的主要代码如下：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">function [Dxx,Dxy,Dyy] =<span style="color: rgba(0, 0, 0, 1)"> Hessian2D(I,Sigma)
</span><span style="color: rgba(0, 0, 255, 1)">if</span> nargin &lt; <span style="color: rgba(128, 0, 128, 1)">2</span>, Sigma = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">; end
</span>%<span style="color: rgba(0, 0, 0, 1)"> Make kernel coordinates
[X,Y]   </span>= ndgrid(-round(<span style="color: rgba(128, 0, 128, 1)">3</span>*Sigma):round(<span style="color: rgba(128, 0, 128, 1)">3</span>*<span style="color: rgba(0, 0, 0, 1)">Sigma));
</span>%<span style="color: rgba(0, 0, 0, 1)"> Build the gaussian 2nd derivatives filters
DGaussxx </span>= <span style="color: rgba(128, 0, 128, 1)">1</span>/(<span style="color: rgba(128, 0, 128, 1)">2</span>*pi*Sigma^<span style="color: rgba(128, 0, 128, 1)">4</span>) * (X.^<span style="color: rgba(128, 0, 128, 1)">2</span>/Sigma^<span style="color: rgba(128, 0, 128, 1)">2</span> - <span style="color: rgba(128, 0, 128, 1)">1</span>) .* exp(-(X.^<span style="color: rgba(128, 0, 128, 1)">2</span> + Y.^<span style="color: rgba(128, 0, 128, 1)">2</span>)/(<span style="color: rgba(128, 0, 128, 1)">2</span>*Sigma^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">));
DGaussxy </span>= <span style="color: rgba(128, 0, 128, 1)">1</span>/(<span style="color: rgba(128, 0, 128, 1)">2</span>*pi*Sigma^<span style="color: rgba(128, 0, 128, 1)">6</span>) * (X .* Y)           .* exp(-(X.^<span style="color: rgba(128, 0, 128, 1)">2</span> + Y.^<span style="color: rgba(128, 0, 128, 1)">2</span>)/(<span style="color: rgba(128, 0, 128, 1)">2</span>*Sigma^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">));
DGaussyy </span>= DGaussxx<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">;</span>
Dxx = imfilter(I,DGaussxx,<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">conv</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);
Dxy </span>= imfilter(I,DGaussxy,<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">conv</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);
Dyy </span>= imfilter(I,DGaussyy,<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">conv</span><span style="color: rgba(128, 0, 0, 1)">'</span>);</span></pre>
</div>
<pre><span style="font-size: 13px">　　eig2image的主要代码为：</span></pre>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">function [Lambda1,Lambda2,Ix,Iy]=<span style="color: rgba(0, 0, 0, 1)">eig2image(Dxx,Dxy,Dyy)
</span>% | Dxx  Dxy |
% |          |
% | Dxy  Dyy |
%<span style="color: rgba(0, 0, 0, 1)"> Compute the eigenvectors of J, v1 and v2
tmp </span>= sqrt((Dxx - Dyy).^<span style="color: rgba(128, 0, 128, 1)">2</span> + <span style="color: rgba(128, 0, 128, 1)">4</span>*Dxy.^<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">);
v2x </span>= <span style="color: rgba(128, 0, 128, 1)">2</span>*Dxy; v2y = Dyy - Dxx +<span style="color: rgba(0, 0, 0, 1)"> tmp;
</span>%<span style="color: rgba(0, 0, 0, 1)"> Normalize
mag </span>= sqrt(v2x.^<span style="color: rgba(128, 0, 128, 1)">2</span> + v2y.^<span style="color: rgba(128, 0, 128, 1)">2</span>); i = (mag ~= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
v2x(i) </span>= v2x(i)./<span style="color: rgba(0, 0, 0, 1)">mag(i);
v2y(i) </span>= v2y(i)./<span style="color: rgba(0, 0, 0, 1)">mag(i);
</span>%<span style="color: rgba(0, 0, 0, 1)"> The eigenvectors are orthogonal
v1x </span>= -<span style="color: rgba(0, 0, 0, 1)">v2y; 
v1y </span>=<span style="color: rgba(0, 0, 0, 1)"> v2x;
</span>%<span style="color: rgba(0, 0, 0, 1)"> Compute the eigenvalues
mu1 </span>= <span style="color: rgba(128, 0, 128, 1)">0.5</span>*(Dxx + Dyy +<span style="color: rgba(0, 0, 0, 1)"> tmp);
mu2 </span>= <span style="color: rgba(128, 0, 128, 1)">0.5</span>*(Dxx + Dyy -<span style="color: rgba(0, 0, 0, 1)"> tmp);
</span>% Sort eigen values by absolute value abs(Lambda1)&lt;<span style="color: rgba(0, 0, 0, 1)">abs(Lambda2)
check</span>=abs(mu1)&gt;<span style="color: rgba(0, 0, 0, 1)">abs(mu2);
Lambda1</span>=mu1; Lambda1(check)=<span style="color: rgba(0, 0, 0, 1)">mu2(check);
Lambda2</span>=mu2; Lambda2(check)=<span style="color: rgba(0, 0, 0, 1)">mu1(check);
Ix</span>=v1x; Ix(check)=<span style="color: rgba(0, 0, 0, 1)">v2x(check);
Iy</span>=v1y; Iy(check)=v2y(check);</span></pre>
</div>
<p><span style="font-size: 13px">　　其实不是很复杂，抛开多个尺度取最大值部分，对于单个尺度的结果的计算，主要是以下几个部分：</span></p>
<p><span style="font-size: 13px">　　1、某个尺度下的图像的二级导数（f<sub>xx</sub>,f<sub>yy</sub>以及f<sub>xy</sub>）.</span></p>
<p><span style="font-size: 13px">　　2、由这些导数构成了图像的Hessian矩阵，求解这个矩阵的特征值。</span></p>
<p><span style="font-size: 13px">　　3、根据特征值按照前面所描述的公式计算响应值。</span></p>
<p><span style="font-size: 13px">　　这里所谓某个尺度下图像，就是对原始图像进行该尺度的高斯模糊后得到的图像，在所有的可搜索的博文或者代码中，我们都看到了大家都是按照论文作者提供的matlab代码的方式，直接根据高斯模糊卷积核的公式，先求出其3种二级偏导数的理论计算公式，然后在根据公式取求取卷积的结果，直接得到二级偏导数，即如下过程：</span></p>
<p><span style="font-size: 13px">　　对于2维的高斯模糊，其卷积核为：</span></p>
<p><span style="font-size: 13px">　　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516135520277-1057508600.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　其一阶偏导数为：</span></p>
<p><span style="font-size: 13px">　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516135605040-705968742.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　二阶偏导数为：　　　　</span></p>
<p><span style="font-size: 13px">　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516135649283-1493101008.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　在上述Hessian2D的matlab代码中，我们可以找到和这个二级导数对应的离散计算表达式，注意一般高斯相关的计算，因为在3*Sigma范围外，其权重基本已经衰减到了99%以外了，因此，一般只需要计算3*Sigma半径内的卷积，如下面的曲面所示：</span></p>
<p><span style="font-size: 13px">　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516142756519-1405877988.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">　　Hessian2D中的imfilter函数即为实现该卷积的过程。</span></p>
<p><span style="font-size: 13px">　　至于Hessian2D的特征值的计算，因为有固定的计算公式，直接算就可以了，这个没有什么好说的。</span></p>
<p><span style="font-size: 13px">　　后续响应值的计算，也就是按步就班的来。也没有什么可谈的。</span></p>
<p><span style="font-size: 13px">　　前几天我也一直按照这个思路来编码实现效果，那么做完后呢，确实有结果，不过和matlab的fibermetric相比呢，结果总是有一些区别，而且速度也有较大的差异。我就一直在想，为什么计算某个尺度下二级导数，一定要直接从那个高斯函数求导后做卷积呢，不能先计算出高斯模糊后的结果后，然后在利用这个结果直接求离散化的二阶导数吗。</span></p>
<p><span style="font-size: 13px">　　幸好matlab是个相对不封闭的工具，我们在matlab的窗口中输入 edit&nbsp;fibermetric，后可以看到他的具体实现，相关代码如下（做了精简）：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">% Output can be <span style="color: rgba(0, 0, 255, 1)">double</span><span style="color: rgba(0, 0, 0, 1)"> or single
B </span>= zeros(size(V),<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">like</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">,V);
numel(thickness)
</span><span style="color: rgba(0, 0, 255, 1)">for</span> id = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">:numel(thickness)
    sigma </span>= thickness(id)/<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (ismatrix(V))
        Ig </span>= imgaussfilt(V, sigma, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">FilterSize</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">2</span>*ceil(<span style="color: rgba(128, 0, 128, 1)">3</span>*sigma)+<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
    elseif (ndims(V)</span>==<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)
        Ig </span>= imgaussfilt3(V,sigma, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">FilterSize</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">2</span>*ceil(<span style="color: rgba(128, 0, 128, 1)">3</span>*sigma)+<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
    end
    </span><span style="color: rgba(0, 0, 255, 1)">out</span> = images.<span style="color: rgba(0, 0, 255, 1)">internal</span><span style="color: rgba(0, 0, 0, 1)">.builtins.fibermetric(Ig, c, isBright, sigma);    
    B </span>= max(B,<span style="color: rgba(0, 0, 255, 1)">out</span><span style="color: rgba(0, 0, 0, 1)">);
end</span></span></pre>
</div>
<p><span style="font-size: 13px">　　代码不多，但是给出的信息量还是蛮大的，第一输入参数的thickness和卷积核的参数关系有了对应，即 :</span></p>
<pre><span style="font-size: 13px">　　　　sigma = thickness(id)/6;</span></pre>
<p><span style="font-size: 13px">　　为什么是除以6，我想和刚才那个3*Sigma里的3应该精密相关吧。</span></p>
<p><span style="font-size: 13px">　　第二，可以明显的看到他是先对原始图像进行了高斯模糊的，然后在调用一个内部的函数builtins.fibermetric对这个模糊后的图像进行处理的。由于matlab里buildins函数是不可以看到源代码的，所以其具体的进一步实现我们无从得知。但是，这无疑和原始论文作者提供的思路是不一样，而和我刚才的怀疑则高度一致。于是我按照我自己的想法写了个过程，其中模糊使用如下方式：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">unsigned <span style="color: rgba(0, 0, 255, 1)">char</span>* Blur = (unsigned <span style="color: rgba(0, 0, 255, 1)">char</span>*)malloc(Height * Stride * <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(unsigned <span style="color: rgba(0, 0, 255, 1)">char</span><span style="color: rgba(0, 0, 0, 1)">));
IM_GaussBlur_SSE(Src, Blur, Width, Height, Stride, Sigma);</span></span></pre>
</div>
<p><span style="font-size: 13px">　　得到的结果趋势和matlab的结果基本一致，但是细节上有很多噪点和干扰。</span></p>
<p><span style="font-size: 13px">　　开始的时候我一直认为是这样做不行，但是看到matlab的实现，我又可以肯定是没有问题的。因此一直耽搁咋这里。</span></p>
<p><span style="font-size: 13px">　　后面某一刻，我就在想，因为高斯模糊或者或其他的模糊，都会把图像的细节减少，把尖锐的地方磨平，因此，模糊的Sigma越大，在离散化计算梯度的时候，如果使用字节版本的模糊呢，由于现相关领域内的像素差异实际上很小了（由浮点数据裁剪到字节数据时丢失了很多信息），因此，就会出现较大的误差，导致趋势对，而结果不够完美。</span></p>
<p><span style="font-size: 13px">　　因此，后续我把这个模糊改为浮点版本的模糊，结果就非常的完美了。</span></p>
<p><span style="font-size: 13px">　　这里还有个细节，关于图像的二阶离散的梯度的计算，我们在百度上能搜到的结果是这样的：&nbsp; &nbsp;</span></p>
<p><span style="font-size: 13px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516142951797-425706615.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">　　对于f<sub>xx</sub>,f<sub>yy</sub>我觉得还是比较合理的，而对于f<sub>xy</sub>这个结果明显不太对称和合理，总感觉有点问题。</span></p>
<p><span style="font-size: 13px">　　这个问题的解惑呢，也还是要看机遇，在继续翻matlab的函数时，我又发现他还有一个maxhessiannorm函数，并且他和fibermetric是精密相关，通过edit&nbsp;maxhessiannorm发现这个函数是完全分享代码的，其核心代码如下：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">sigma = thickness/<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">;
[Gxx, Gyy, Gxy]     </span>= images.<span style="color: rgba(0, 0, 255, 1)">internal</span><span style="color: rgba(0, 0, 0, 1)">.hessian2D(I, sigma);
[eigVal1, eigVal2]  </span>= images.<span style="color: rgba(0, 0, 255, 1)">internal</span><span style="color: rgba(0, 0, 0, 1)">.find2DEigenValues(Gxx, Gyy, Gxy);
absEigVal1 </span>=<span style="color: rgba(0, 0, 0, 1)"> abs(eigVal1);
absEigVal2 </span>=<span style="color: rgba(0, 0, 0, 1)"> abs(eigVal2);
maxHessianNorm </span>=<span style="color: rgba(0, 0, 0, 1)"> max([max(absEigVal1(:)), max(absEigVal2)]);
C </span>= maxHessianNorm;</span></pre>
</div>
<p><span style="font-size: 13px">　　他的作用是获取最大的Hessian矩阵的特征值，而且和fibermetric的过程是对应的。</span></p>
<p><span style="font-size: 13px">　　我们看这里的images.internal.hessian2D，还好这个internal是可以看到代码的。</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">Ig = imgaussfilt(I, sigma, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">FilterSize</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">2</span>*ceil(<span style="color: rgba(128, 0, 128, 1)">3</span>*sigma)+<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
[Gx, Gy]   </span>= imgradientxy(Ig, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">central</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);
[Gxx, Gxy] </span>= imgradientxy(Gx, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">central</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);
[ </span>~ , Gyy] = imgradientxy(Gy, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">central</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);

Gxx </span>= (sigma^<span style="color: rgba(128, 0, 128, 1)">2</span>)*<span style="color: rgba(0, 0, 0, 1)">Gxx;
Gyy </span>= (sigma^<span style="color: rgba(128, 0, 128, 1)">2</span>)*<span style="color: rgba(0, 0, 0, 1)">Gyy;
Gxy </span>= (sigma^<span style="color: rgba(128, 0, 128, 1)">2</span>)*Gxy;</span></pre>
</div>
<p><span style="font-size: 13px">　　第一行和fibermetric函数是一模一样的，而后续的三行就是计算二阶梯度，在去看imgradientxy的相关注释，有下面的语句</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px"> <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">central</span><span style="color: rgba(128, 0, 0, 1)">'</span>               : Central difference gradient dI/dx = (I(x+<span style="color: rgba(128, 0, 128, 1)">1</span>)- I(x-<span style="color: rgba(128, 0, 128, 1)">1</span>))/ <span style="color: rgba(128, 0, 128, 1)">2</span></span></pre>
</div>
<p><span style="font-size: 13px">　　这样，我们一步一步的做个推导，具体如下：</span></p>
<p><span style="font-size: 13px"><img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516143743578-631817210.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　简单来说，对于如下的一个中线点像素 P12，</span></p>
<p><span style="font-size: 13px">　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516143841625-769262888.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 13px">&nbsp;　　其二级偏导数分别为：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 13px">           <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">    求该尺度下图像的二阶梯度</span>
            <span style="color: rgba(0, 0, 255, 1)">float</span> Dxx = (P14 + P10 - P12 - P12) * <span style="color: rgba(128, 0, 128, 1)">0.25f</span><span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 0, 255, 1)">float</span> Dyy = (P22 + P2 - P12 - P12) * <span style="color: rgba(128, 0, 128, 1)">0.25f</span><span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 0, 255, 1)">float</span> Dxy = (P18 + P6 - P16 - P8) * <span style="color: rgba(128, 0, 128, 1)">0.25f</span>;</span></pre>
</div>
<p><span style="font-size: 13px">　　这个时候在去看Dxy则是完全对称的了。</span></p>
<p><span style="font-size: 13px">　　同时，这个地方还给我解惑了另外一个问题，即在fibermetric的代码中，还有这样一句话</span></p>
<pre><span style="font-size: 13px"> 　　　　out = images.internal.builtins.fibermetric(Ig, c, isBright, sigma); <br><br>　按理说，前面高斯模糊需要这个Sigma是无可厚非的，那后面这里这个函数怎么还需要传递sigma呢，一直不理解，后面看看这个images.internal.hessian2D就明白了，原来是要在这里用sigma方法放大。<br></span></pre>
<pre><span>　　　　　　Gxx = (sigma^2)*<span>Gxx;
　　　　　　Gyy = (sigma^2)*<span>Gyy;
　　　　　　Gxy = (sigma^2)*Gxy;<br>　　最后，在matlab的函数里，还有一个</span></span></span>StructureSensitivity参数，这个我测试了半天，我认为他就是公式中的c变量，这里有一个很好的理由支撑他， 因为在maxhessiannorm的解释文档中，有如下内容：</pre>
<div class="rtcContent">
<div class="lineNode">　　% C = maxhessiannorm(I) calculates the maximum of Frobenius norm of the</div>
<div class="lineNode">　　% hessian of intensity image I. As this function is used in the context</div>
<div class="lineNode">　　% of fibermetric, default thickness of 4 is used to find the hessian and</div>
<div class="lineNode">　　% returns the obtained value as C.</div>
<div class="lineNode">　　</div>
<div class="lineNode">　　第一，这里直接用的字母C作为返回值，这个是一种遥相呼应，第二，这个函数计算的是特征值的最大值，和前面的公式变量S精密相关，而S又和C在计算时绑定在一起，因此，他应该就是C的一个外在表现。</div>
<div class="lineNode">　　至此，大部分的工作都已经完成了，而通过这样的改动，我所实现的结果基本和maltab的完全一致，并且速度方面有高斯模糊有快速的算法，因此算法的执行速度和参数基本无关了。而传统的那种卷积实现，当尺度较大时，必然会影响速度。&nbsp;</div>
<div class="lineNode">　　</div>
<div class="lineNode">　　<span style="color: rgba(255, 0, 0, 1)"><strong>使用相同的图做测试，500*500的，单尺度时matlab大概需要15ms， 我实现的版本大概在3ms，还是有相当大的提高的。&nbsp;</strong></span></div>
<div class="lineNode">&nbsp;</div>
<div class="lineNode">　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516145731992-1062580926.png" alt="">&nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516145739952-1061652473.png" alt=""></div>
<div class="lineNode">　　　　　　　　　　　　　　matlab测试图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Thickness等于7时的结果图<br>
<p>　　那一副医学图像做测试，效果确实不错：</p>
<p><img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516150930083-816831569.png" width="400">&nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516151131287-1889804649.png" width="800" loading="lazy"></p>
<p>&nbsp;　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　尺度数量为5，最大尺度为16的结果&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516151326458-1375404711.png" alt="" loading="lazy"></p>
<p>&nbsp;　　　　　　　　　　　　　　同样参数原始作者版本的结果，明显没有maltab的清晰　　</p>
<p>　　这个算法我测试确实对血管图像的提取效果比较显著，在贴几个图片。</p>
<p>　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516151719983-535126967.png" alt="">　　　　<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516151727212-1086024557.png" alt=""></p>
<p>　　另外，在Halcon中有个lines_gauss函数，以前我就研究过他，并且小有成果，我现在可以100%肯定这个函数和我现在研究的这个东西有很大的关联，也许在不久就可以把这个函数研究成功，因为，我们用lines_gauss这个常用的几个图片测试，会得到类似这样的结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516152425543-2027455284.png" width="400">&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202505/349293-20250516152401454-1797228549.png" width="800" loading="lazy"></p>
<p>　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　分析结果</p>
<p>　　&nbsp;&nbsp;本文Demo下载地址： &nbsp;<a href="https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar" target="_blank">https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar</a>，本算法位于Detection(检测相关）--》 FiberMetric（纤维分析） 菜单下，里面的所有算法都是基于SSE实现的。</p>
<p>　　</p>

</div>

</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6134662391944444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-16 15:30">2025-05-16 15:29</span>&nbsp;
<a href="https://www.cnblogs.com/Imageshop">Imageshop</a>&nbsp;
阅读(<span id="post_view_count">125</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18878608);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18878608', targetLink: 'https://www.cnblogs.com/imageshop/p/18878608', title: '【工程应用十】 基于Hessian矩阵的Frangi滤波算法 == 血管图像增强 == Matlab中fibermetric函数的自我实现、加速和优化。' })">举报</a>
</div>
        