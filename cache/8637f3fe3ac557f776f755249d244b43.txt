
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18702001" title="发布于 2025-02-07 08:49">
    <span role="heading" aria-level="2">C#  Winform 实现静态变量属性的值变了，触发事件，类似WPF的双向绑定</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在C# WinForms中，虽然没有像WPF那样内置的双向绑定机制，但你可以通过事件和属性封装来实现类似的功能。具体来说，你可以在静态属性的<code>set</code>访问器中触发一个自定义事件，然后在需要的地方订阅这个事件，以便在属性值发生变化时执行相应的操作。</p>
<p><strong>全局状态的隐患</strong></p>
<ul>
<li>问题：静态类和静态事件引入了全局状态，这意味着任何代码都可以订阅或触发这个事件。这种全局状态可能导致代码难以维护和调试，尤其是在大型项目中。</li>
<li>风险：如果多个模块或类订阅了该事件，事件的触发可能会导致意外的副作用，甚至引发难以追踪的 bug。</li>
</ul>
<p><strong>内存泄漏风险</strong></p>
<ul>
<li>静态事件的生命周期与应用程序域相同，除非显式取消订阅，否则订阅者（尤其是对象实例）永远不会被垃圾回收。</li>
<li>如果订阅者没有正确取消订阅，可能会导致内存泄漏。</li>
</ul>
<p><font color="red">Form 窗体释放后，记得取消订阅</font></p>
<pre><code class="language-c#">public void MyForm_Closing(object sender, FormClosingEventArgs e)
{
   //显式取消订阅
   GlobalEvents.SomeGlobalEvent -= HandleEvent;
}
//或者
public void Dispose()
{
   //显式取消订阅
   GlobalEvents.SomeGlobalEvent -= HandleEvent;
}
</code></pre>
<p>以下是一个简单的示例，展示了如何实现这一功能：</p>
<pre><code class="language-c#">using System;
using System.Windows.Forms;

public static class MyStaticClass
{
    // 定义事件
    public static event EventHandler&lt;EventArgs&gt; MyPropertyChanged;

    private static string _myProperty;
    public static string MyProperty
    {
        get { return _myProperty; }
        set
        {
            if (_myProperty != value)
            {
                _myProperty = value;
                // 触发事件
                OnMyPropertyChanged();
            }
        }
    }

    // 触发事件的方法
    private static void OnMyPropertyChanged()
    {
        MyPropertyChanged?.Invoke(null, EventArgs.Empty);
    }
}

public class MyForm : Form
{
    private Label myLabel;

    public MyForm()
    {
        myLabel = new Label();
        myLabel.Text = "Initial Value";
        myLabel.Location = new System.Drawing.Point(10, 10);
        this.Controls.Add(myLabel);

        // 订阅事件
        MyStaticClass.MyPropertyChanged += MyStaticClass_MyPropertyChanged;
    }

    // 事件处理程序
    private void MyStaticClass_MyPropertyChanged(object sender, EventArgs e)
    {
        // 当属性值变化时，更新Label的文本
        myLabel.Text = MyStaticClass.MyProperty;
    }

    [STAThread]
    public static void Main()
    {
        Application.EnableVisualStyles();
        Application.Run(new MyForm());
    }
}
</code></pre>
<p>使用示例：<br>
你可以在其他地方修改 MyStaticClass.MyProperty 的值，例如：</p>
<pre><code class="language-c#">MyStaticClass.MyProperty = "New Value";
</code></pre>
<p>注意事项：</p>
<ul>
<li>由于 MyProperty 是静态的，它的值在整个应用程序生命周期内是共享的。</li>
<li>如果你需要在多个窗体或控件之间共享状态，这种方法是有效的。</li>
</ul>
<p>通过这种方式，你可以在WinForms中实现类似WPF的双向绑定效果。<br>
这里使用的是 <code>EventHandler&lt;TEventArgs&gt;</code> 泛型委托，其中 <code>TEventArgs</code> 是 <code>EventArgs</code> 类型（或派生类型）。这种定义方式已经隐式地使用了委托，因此不需要显式地定义一个新的委托类型。</p>
<p>如果显式定义委托，好处是什么？<br>
<strong>1. 自定义事件参数：</strong><br>
如果你需要传递更多信息（不仅仅是 sender 和 EventArgs），可以定义一个自定义的事件参数类，并为其定义一个专门的委托。</p>
<pre><code class="language-c#">public class MyPropertyChangedEventArgs : EventArgs
{
    public string OldValue { get; }
    public string NewValue { get; }

    public MyPropertyChangedEventArgs(string oldValue, string newValue)
    {
        OldValue = oldValue;
        NewValue = newValue;
    }
}

// 定义自定义委托
public delegate void MyPropertyChangedEventHandler(object sender, MyPropertyChangedEventArgs e);

// 使用自定义委托定义事件
public static event MyPropertyChangedEventHandler MyPropertyChanged;
</code></pre>
<p>这样，事件处理程序可以接收到更多信息（如旧值和新值）。</p>
<p><strong>2. 提高代码可读性：</strong><br>
显式定义委托可以让代码更具可读性，尤其是当事件的用途非常明确时。</p>
<pre><code class="language-c#">public delegate void MyPropertyChangedDelegate(string newValue);

public static event MyPropertyChangedDelegate MyPropertyChanged;
</code></pre>
<p>这种方式更直观地表达了事件的用途。</p>
<p><strong>3.灵活性：</strong><br>
自定义委托可以定义更灵活的参数列表，而不仅限于 object sender, EventArgs e 的标准模式。<br>
例如，你可以定义一个没有 sender 参数的事件：</p>
<pre><code class="language-c#">public delegate void MyPropertyChangedDelegate(string newValue);

public static event MyPropertyChangedDelegate MyPropertyChanged;
</code></pre>
<h3 id="显式定义委托">显式定义委托</h3>
<p>以下是显式定义委托的完整示例：</p>
<pre><code class="language-c#">using System;
using System.Windows.Forms;

public static class MyStaticClass
{
    // 定义自定义委托
    public delegate void MyPropertyChangedDelegate(string newValue);

    // 定义事件
    public static event MyPropertyChangedDelegate MyPropertyChanged;

    private static string _myProperty;
    public static string MyProperty
    {
        get { return _myProperty; }
        set
        {
            if (_myProperty != value)
            {
                string oldValue = _myProperty;
                _myProperty = value;
                // 触发事件
                OnMyPropertyChanged(value);
            }
        }
    }

    // 触发事件的方法
    private static void OnMyPropertyChanged(string newValue)
    {
        MyPropertyChanged?.Invoke(newValue);
    }
}

public class MyForm : Form
{
    private Label myLabel;

    public MyForm()
    {
        myLabel = new Label();
        myLabel.Text = "Initial Value";
        myLabel.Location = new System.Drawing.Point(10, 10);
        this.Controls.Add(myLabel);

        // 订阅事件
        MyStaticClass.MyPropertyChanged += MyStaticClass_MyPropertyChanged;
    }

    // 事件处理程序
    private void MyStaticClass_MyPropertyChanged(string newValue)
    {
        // 当属性值变化时，更新Label的文本
        myLabel.Text = newValue;
    }

    [STAThread]
    public static void Main()
    {
        Application.EnableVisualStyles();
        Application.Run(new MyForm());
    }
}
</code></pre>
<p>总结<br>
使用 EventHandler 的好处：</p>
<ul>
<li>简单、标准化，适合大多数场景。</li>
<li>符合 .NET 的事件模式（object sender, EventArgs e）。</li>
</ul>
<p>显式定义委托的好处：</p>
<ul>
<li>更灵活，可以自定义参数列表。</li>
<li>提高代码可读性和表达力。</li>
<li>适合需要传递更多信息的场景。</li>
</ul>
<p>在实际开发中，选择哪种方式取决于具体需求。如果只是简单的值变化通知，使用 EventHandler 就足够了；如果需要更复杂的事件参数或更高的灵活性，则可以显式定义委托。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18702001" target="_blank">https://www.cnblogs.com/vipsoft/p/18702001</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.2717924438101855" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-07 19:48">2025-02-07 08:49</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">601</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18702001" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18702001);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18702001', targetLink: 'https://www.cnblogs.com/vipsoft/p/18702001', title: 'C#  Winform 实现静态变量属性的值变了，触发事件，类似WPF的双向绑定' })">举报</a>
</div>
        