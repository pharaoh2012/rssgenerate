
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nogeek-cn/p/18737163" title="发布于 2025-02-25 20:18">
    <span role="heading" aria-level="2">百万架构师第四十三课：Nginx：Nginx 应用实战｜JavaGuide</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="百万架构师系列文章阅读体验感更佳"><center><a href="https://javaguide.net" target="_blank" rel="noopener nofollow">百万架构师系列文章阅读体验感更佳</a></center></h2>
<h2 id="原文链接httpsjavaguidenet"><center>原文链接：<a href="https://javaguide.net" target="_blank" rel="noopener nofollow">https://javaguide.net</a></center></h2>
<h2 id="公众号不止极客"><center>公众号：不止极客</center></h2>
<h3 id="课程目标">课程目标：</h3>
<ol>
<li>Nginx 反向代理功能配置</li>
<li>Nginx 负载均衡实战</li>
<li>Nginx 动静分离配置</li>
<li>Nginx 配置文件分析</li>
<li>Nginx 多进程模型原理</li>
<li>Nginx 高可用集群实战</li>
</ol>
<h2 id="反向代理">反向代理</h2>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201854642-734417405.png" alt="JavaGuide_Nginx_应用实战_反向代理.png" loading="lazy"></p>
<p>​	我们把请求发送到 proxy （代理服务器），转发到后端的服务器上，返回到代理，返回到浏览器，去做一个解析。</p>
<p>作用:</p>
<ul>
<li>代理的是服务端（我们客户端不需要直接去跟服务端去打交道，我通过代理来做。比如说我要找房子，我找中介，他会帮我做一些筛选。）</li>
</ul>
<p><code>nginx.conf</code></p>
<pre><code class="language-c">#keepalive_timeout  0;
keepalive_timeout  65;


# 扫描这个目录下的配置文件（配置在 HTTP 里边）
include extra/*.conf;
</code></pre>
<blockquote>
<p>注意： 扫描目录的路径一定要配置正确！（相对路径，相对于 <code>nginx.conf</code> 的路径）</p>
</blockquote>
<pre><code class="language-c">[root@Darian1 nginx]# vim conf/nginx.conf
[root@Darian1 nginx]# mkdir extra
[root@Darian1 nginx]# cd extra/
[root@Darian1 extra]# vim proxy_dem o.conf

server{
        listen 80;
        server_name localhost;
        location /{
                proxy_pass http:192.168.40.128:8080;   
        }
}

</code></pre>
<p>​	<strong>nginx</strong> 反向代理的指令不需要新增额外的模块，默认自带 proxy_pass 指令，只需要修改配置文件就可以实现反向代理。</p>
<p>​	 <code>proxy_pass</code> 既可以是ip地址，也可以是域名，同时还可以指定端口</p>
<p>Nginx反向代理实战</p>
<ol>
<li>启动 tomcat 服务器</li>
<li>nginx配置的统一维护，将Nginx.conf文件的内容修改成如下配置</li>
</ol>
<table>
<thead>
<tr>
<th>Nginx</th>
<th>Tomcat</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201854864-261633246.png" alt="JavaGuide_Nginx_应用实战_Nginx访问结果.png" loading="lazy"></td>
<td><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201855081-1158073097.png" alt="JavaGuide_Nginx_应用实战_Tomcat访问结果.png" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>proxy_demo.conf</p>
<pre><code class="language-c">server {
    listen 80;
    server_name localhost;
    location /  {
        proxy_pass http://192.168.40.128:8080;
        # 拿到端口
        proxy_set_header Host $host;
        # 拿到远端的 IP，真实的IP
        proxy_set_header X-Real-IP $remote_addr;
        # 这个可以让 tomcat 拿到所有代理服务器的地址。如果有多个，那么他就可以拿到多个
        proxy_set_header X-Forworded-For $proxy_add_x_forwarded_for;
    }
}
</code></pre>
<ol start="3">
<li>在 extra 文件夹中添加 <code>proxy_demo.conf</code></li>
<li>./nginx -s reload 重新加载</li>
</ol>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201855339-1130375327.png" alt="JavaGuide_Nginx_应用实战_Tomcat的地址_IP_代理地址.png" loading="lazy"></p>
<blockquote>
<p>Nginx 可以利用 Http 的 header 来传递一些信息。</p>
</blockquote>
<h2 id="负载均衡">负载均衡</h2>
<p>​	网络负载均衡的大致原理是利用一定的分配策略将网络负载平衡地分摊到网络集群的各个操作单元上，使得单个重负载任务能够分担到多个单元上并行处理，使得大量并发访问或数据流量分担到多个单元上分别处理，从而减少用户的等待响应时间</p>
<h5 id="负载均衡器">负载均衡器</h5>
<ul>
<li>硬件负载
<ul>
<li>F5 、 Array</li>
</ul>
</li>
<li>软件负载
<ul>
<li>Nginx 、 Lvx 、 HAProxy</li>
</ul>
</li>
</ul>
<p>​	<code>upstream</code> 是 <strong>Nginx</strong> 的 <code>HTTP Upstream</code> 模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡</p>
<ol>
<li>
<p><code>Upstream</code><br>
语法：server address [paramters]</p>
</li>
<li>
<p>负载均衡策略或者算法</p>
<ul>
<li>
<p>轮询算法（默认）， 如果后端服务器宕机以后，会自动踢出</p>
</li>
<li>
<p>ip_hash 根据请求的ip地址进行hash（同一个 IP 只会落到一个 后台服务器上）</p>
<pre><code class="language-c">upstream tomcat{
    # 如果想要用 ip hash 算法
    ip_hash;

    # 对应我们后端服务器真实的 IP 地址
    server 192.168.40.128:8080  ;
    server 192.168.40.131:8080 ;
}
</code></pre>
</li>
<li>
<p>权重轮询。当你后端节点的配置有好有坏，就需要按照权重来配置。</p>
<pre><code class="language-c">upstream tomcat{
    # 对应我们后端服务器真实的 IP 地址
    server 192.168.40.128:8080 weight = 1 ;
    server 192.168.40.131:8080 weight = 2 ;
}
</code></pre>
</li>
<li>
<p>响应时间，可以按照服务器处理请求的响应时间来处理请求。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code class="language-c">.nginx -s reload
</code></pre>
</blockquote>
<h5 id="jsp-页面的配置">JSP 页面的配置</h5>
<blockquote>
<p>修改 JSP 来提示自己</p>
</blockquote>
<pre><code class="language-html">&lt;div id="asf-box"&gt;
    &lt;h1&gt;${pageContext.servletContext.serverInfo}&lt;/h1&gt;
&lt;/div&gt;

&lt;h1 style="color:red"&gt; 请求的地址：  &lt;%=request.getRemoteAddr()%&gt;&lt;/h1&gt;
&lt;h1 style="color:red"&gt; 请求的真实IP：  &lt;%=request.getHeader("X-Real-IP")%&gt;&lt;/h1&gt;
&lt;h1 style="color:red"&gt; 请求的转发的代理：  &lt;%=request.getHeader("X-Forworded-For")%&gt;&lt;/h1&gt;
    
</code></pre>
<h3 id="演示效果">演示效果</h3>
<pre><code class="language-c">upstream tomcat{
    # 对应我们后端服务器真实的 IP 地址
    server 192.168.40.128:8080;
    server 192.168.40.131:8080;
}

server {
    listen 80;
    server_name localhost;
    location /  {
        proxy_pass http://tomcat;
        # 拿到端口
        proxy_set_header Host $host;
        # 拿到远端的 IP，真实的IP
        proxy_set_header X-Real-IP $remote_addr;
        # 这个可以让 tomcat 拿到所有代理服务器的地址。如果有多个，那么他就可以拿到多个
        proxy_set_header X-Forworded-For $proxy_add_x_forwarded_for;
    }
}
</code></pre>
<p>随机访问。会转发到不同的 <strong>Tomcat</strong> 上边。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201855870-1707771063.png" alt="JavaGuide_Nginx_应用实战_随机转发_Tomcat1.png" loading="lazy"></td>
<td><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201856148-766380757.png" alt="JavaGuide_Nginx_应用实战_随机转发_Tomcat2.png" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3 id="其他配置信息">其他配置信息</h3>
<h4 id="proxy_next_upstream">proxy_next_upstream</h4>
<ul>
<li>语法：proxy_next_upstream [error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 |http_404 | off ];</li>
<li>默认：proxy_next_upstream error timeout;</li>
<li>配置块：http、server、location</li>
</ul>
<p>​	这个配置表示当向一台上游服务器转发请求出现错误的时候，继续换一台上游服务器来处理这个请求。</p>
<p>​	默认情况下，上游服务器一旦开始发送响应数据， Nginx 反向代理服务器会立刻把应答包转发给客户端。因此，一旦Nginx开始向客户端发送响应包，如果中途出现错误也不允许切换到下一个上游服务器继续处理。这样做的目的是保证客户端只收到来自同一个上游服务器的应答。</p>
<h4 id="proxy_connect_timeout">proxy_connect_timeout</h4>
<ul>
<li>语法: <code>proxy_connect_timeout time;</code></li>
<li>默认: <code>proxy_connect_timeout 60s;</code></li>
<li>范围: http, server, location</li>
</ul>
<p>用于设置nginx与upstream server的连接超时时间，比如我们直接在location中设置</p>
<p><code>proxy_connect_timeout</code></p>
<p>1ms， 1ms很短，如果无法在指定时间建立连接，就会报错。</p>
<h4 id="proxy_send_timeout">proxy_send_timeout</h4>
<p>​	向后端写数据的超时时间，两次写操作的时间间隔如果大于这个值，也就是过了指定时间后端还没有收到数据，连接会被关闭</p>
<h4 id="proxy_read_timeout">proxy_read_timeout</h4>
<pre><code class="language-c">upstream tomcat{
    # 如果想要用 ip hash 算法
    # ip_hash;

    # 对应我们后端服务器真实的 IP 地址
    # 允许他的失败次数
    # 失败以后多长时间以内不再去请求它
    server 192.168.40.128:8080 max_fails=2 fail_timeout=60s ;
    server 192.168.40.131:8080 ;
}

server {
    listen 80;
    server_name localhost;
    location /  {
        proxy_pass http://tomcat;
        # 拿到端口
        proxy_set_header Host $host;
        # 拿到远端的 IP，真实的IP
        proxy_set_header X-Real-IP $remote_addr;
        # 这个可以让 tomcat 拿到所有代理服务器的地址。如果有多个，那么他就可以拿到多个。
        proxy_set_header X-Forworded-For $proxy_add_x_forwarded_for;
        # 当我们的 niginx 对后端的请求进行转发的时候，哪些场景下允许进行切换。
        proxy_next_upstream error timeout http_500 http_503;
        # Nginx 和我们后端上游的服务器之间的连接超时时间————发起握手等候响应超时时间
        proxy_connect_timeout 60s;
        #  后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据
        proxy_send_timeout 60;
        # 连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器&gt;处理请求的时间）
        proxy_read_timeout
    }
}
</code></pre>
<p>从后端读取数据的超时时间，两次读取操作的时间间隔如果大于这个值，那么nginx和后端的连接会被关闭，如果一个请求的处理时间比较长，可以把这个值设置得大一些</p>
<h4 id="proxy_upstream_fail_timeout">proxy_upstream_fail_timeout</h4>
<p>设置了某一个upstream后端失败了指定次数（max_fails）后，在fail_timeout时间内不再去请求它，默认为10秒<br>
语法 server address [fail_timeout=30s]</p>
<pre><code class="language-c">upstream backend {
    #服务器集群名字
    #server 192.168.218.129:8080 weight=1 max_fails=2 fail_timeout=600s;
    #server 192.168.218.131:8080 weight=1 max_fails=2 fail_timeout=600s;
}
</code></pre>
<h2 id="nginx动静分离">Nginx动静分离</h2>
<h4 id="什么是动静分离">什么是动静分离</h4>
<p>​	后端的应用一定会存在动态资源和静态资源。必须依赖服务器生存的我们称为动态资源。不需要依赖容器的比如 <code>css/js</code> 或者图片等，这类就叫静态资源。</p>
<p>​	我们可以把静态资源放在 Nginx 上。静态资源不会频繁变动。</p>
<p>​</p>
<h5 id="静态资源的类型">静态资源的类型</h5>
<pre><code class="language-c">types {
    text/html html htm shtml;
    text/css css;
    text/xml xml;
    image/gif gif;
    image/jpeg jpeg jpg;
    application/javascript js;
    application/atom+xml atom;
    application/rss+xml rss;
    text/mathml mml;
    text/plain txt;
    text/vnd.sun.j2me.app-descriptor jad;
    text/vnd.wap.wml wml;
    text/x-component htc;
    image/png png;
    image/svg+xml svg svgz;
    image/tiff tif tiff;
    image/vnd.wap.wbmp wbmp;
    image/webp webp;
    image/x-icon ico;
    image/x-jng jng;
    image/x-ms-bmp bmp;
    application/font-woff woff;
    application/java-archive jar war ear;
    application/json json;
    application/mac-binhex40 hqx;
    application/msword doc;
    application/pdf pdf;
    application/postscript ps eps ai;
    application/rtf rtf;
    application/vnd.apple.mpegurl m3u8;
    application/vnd.google-earth.kml+xml kml;
    application/vnd.google-earth.kmz kmz;
    application/vnd.ms-excel xls;
    application/vnd.ms-fontobject eot;
    application/vnd.ms-powerpoint ppt;
    application/vnd.oasis.opendocument.graphics odg;
    application/vnd.oasis.opendocument.presentation odp;
    application/vnd.oasis.opendocument.spreadsheet ods;
    application/vnd.oasis.opendocument.text odt;
    application/vnd.openxmlformats-officedocument.presentationml.presentation
        pptx;
    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
        xlsx;
    application/vnd.openxmlformats-officedocument.wordprocessingml.document
        docx;
    application/vnd.wap.wmlc wmlc;
    application/x-7z-compressed 7z;
    application/x-cocoa cco;
    application/x-java-archive-diff jardiff;
    application/x-java-jnlp-file jnlp;
    application/x-makeself run;
    application/x-perl pl pm;
    application/x-pilot prc pdb;
    application/x-rar-compressed rar;
    application/x-redhat-package-manager rpm;
    application/x-sea sea;
    application/x-shockwave-flash swf;
    application/x-stuffit sit;
    application/x-tcl tcl tk;
    application/x-x509-ca-cert der pem crt;
    application/x-xpinstall xpi;
    application/xhtml+xml xhtml;
    application/xspf+xml xspf;
    application/zip zip;
    application/octet-stream bin exe dll;
    application/octet-stream deb;
    application/octet-stream dmg;
    application/octet-stream iso img;
    application/octet-stream msi msp msm;
    audio/midi mid midi kar;
    audio/mpeg mp3;
    audio/ogg ogg;
    audio/x-m4a m4a;
    audio/x-realaudio ra;
    video/3gpp 3gpp 3gp;
    video/mp2t ts;
    video/mp4 mp4;
    video/mpeg mpeg mpg;
    video/quicktime mov;
    video/webm webm;
    video/x-flv flv;
    video/x-m4v m4v;
    video/x-mng mng;
    video/x-ms-asf asx asf;
    video/x-ms-wmv wmv;
    video/x-msvideo avi;
}
</code></pre>
<p>Nginx</p>
<p>​	在 <strong>Nginx</strong> 的 conf 目录下，有一个 <code>mime.types</code> 文件</p>
<p>​	用户访问一个网站，然后从服务器端获取相应的资源通过浏览器进行解析渲染最后展示给用户，而服务端可以返回各种类型的内容，比如 <code>xml</code>、<code>jpg</code>、<code>png</code>、<code>gif</code>、<code>flash</code>、<code>MP4</code>、<code>html</code>、<code>css</code> 等等，那么浏览器就是根据 <code>mime-type</code> 来决定用什么形式来展示的</p>
<p>​	图片可以放在 CDN ，（很多都是放在 阿里云 上）</p>
<p>​	服务器返回的资源给到浏览器时，会把 <strong>媒体类型</strong> 告知浏览器，这个告知的标识就是 <code>Content-Type</code> ，比如 <code>Content-Type:text/html</code> 。</p>
<h4 id="演示代码">演示代码</h4>
<pre><code class="language-c">location ~ .*\.(js|css|png|svg|ico|jpg)$ {
    valid_referers none blocked 192.168.11.160 www.gupaoedu.com;
    if ($invalid_referer) {
        return 404;
    }
    root static-resource;
    expires 1d;
}
</code></pre>
<blockquote>
<ul>
<li>把 <strong>Tomcat</strong> 目录  <code>webapps/ROOT/</code> 下除了 <code>index.jsp</code> 和 <code>web.xml</code> 全部删除，</li>
<li>清除浏览器的缓存，图片等就会加载失败。</li>
<li>然后把相关的文件放到 nginx 的 <code>static-resource</code> 文件夹下。</li>
</ul>
</blockquote>
<h3 id="动静分离的好处">动静分离的好处</h3>
<ul>
<li>第一个， <strong>Nginx</strong> 本身就是一个高性能的静态 <strong>web</strong> 服务器；</li>
<li>第二个，其实静态文件有一个特点就是基本上变化不大，所以动静分离以后我们可以对静态文件进行缓存、或者压缩提高网站性能</li>
</ul>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201856410-208320379.png" alt="JavaGuide_Nginx_应用实战_动静分离.png" loading="lazy"></p>
<h4 id="缓存">缓存</h4>
<p><code>Cache-Control</code> / <code>Pragma</code> / <code>Expries</code></p>
<p>服务端可以告诉客户端，有没有这些信息，需不需要缓存。</p>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201856631-1492816946.png" alt="JavaGuide_Nginx_应用实战_Response缓存.png" loading="lazy"></p>
<p>​	谷歌浏览器，拿到服务器的信息，自动缓存。什么时候过期是由浏览器决定的。实际过程中，仍然需要我们自己去决定缓存。</p>
<p>​	当一个客户端请求web服务器，请求的内容可以从以下几个地方获取：服务器、浏览器缓存中或缓存服务器中。这取决于服务器端输出的页面信息。</p>
<p>​	浏览器缓存将文件保存在客户端，好的缓存策略可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担nginx缓存配置</p>
<h4 id="nginx缓存配置">Nginx缓存配置</h4>
<p>​	Nginx可以通过expires设置缓存，比如我们可以针对图片做缓存，因为图片这类信息基本上不会改变。<br>
在location中设置expires<br>
格式： expires 30s|m|h|d</p>
<pre><code class="language-c">location ~ .*.(jpg|jpeg|gif|bmp|png|js|css|ico)$ {
    root static;
    expires 1d;
}
</code></pre>
<h4 id="压缩">压缩</h4>
<h5 id="gzip">Gzip</h5>
<p>​	我们一个网站一定会包含很多的静态文件，比如图片、脚本、样式等等，而这些 <code>css/js</code> 可能本身会比较大，那么在网络传输的时候就会比较慢，从而导致网站的渲染速度。因此 <strong>Nginx</strong>中提供了一种 <code>Gzip</code> 的压缩优化手段，可以对后端的文件进行压缩传输，压缩以后的好处在于能够降低文件的大小来提高传输效率。</p>
<blockquote>
<p>我们在一些网络上打开某些 CSS，然后实际大小一般大于它的传输大小。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201856865-1721211615.png" alt="JavaGuide_Nginx_应用实战_nginx压缩.png" loading="lazy"></p>
<h5 id="配置信息">配置信息</h5>
<ul>
<li><code>Gzip on|off</code> 是否开启gzip压缩</li>
<li><code>Gzip_buffers 4 16k</code> #设置gzip申请内存的大小，作用是按指定大小的倍数申请内存空间。4 16k代表按照原始数据大小以16k为单位的4倍申请内存。</li>
<li><code>Gzip_comp_level[1-9]</code> 压缩级别， 级别越高，压缩越小，但是会占用CPU资源</li>
<li><code>Gzip_disable</code> #正则匹配UA 表示什么样的浏览器不进行gzip</li>
<li><code>Gzip_min_length</code> #开始压缩的最小长度（小于多少就不做压缩），可以指定单位，比如 1k</li>
<li><code>Gzip_http_version 1.0|1.1</code> 表示开始压缩的http协议版本</li>
<li><code>Gzip_proxied</code> （nginx 做前端代理时启用该选项，表示无论后端服务器的headers头返回什么信息，都无条件启用压缩）</li>
<li><code>Gzip_type text/pliain,application/xml</code> 对哪些类型的文件做压缩 （conf/mime.conf）</li>
<li><code>Gzip_vary on|off</code> 是否传输gzip压缩标识；启用应答头"Vary: Accept-Encoding";给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩</li>
</ul>
<h4 id="演示效果-1">演示效果</h4>
<h5 id="nginxconf">nginx.conf</h5>
<pre><code class="language-c"># 扫描这个目录下的配置文件
include    extra/*.conf;

	# 是否打开 gzip
    gzip on;
    # 超过多长长度再进行压缩
    gzip_min_length 5K;
    # 压缩的等级越高，压缩后的文件越小，占用的 CPU 越高
    gzip_comp_level 3;
    # 对哪些文件做压缩
    gzip_types application/javascript image/jpeg;
    # 设置缓冲区，按照我们我们指定大小的倍数去申请内存，
    # 按照我们原始文件的大小，以 32K 为单位的四倍去申请内存。
    gzip_buffers 4 32k;
    # 是否传输 “vary: Accept-Encoding” 的文件头标志
    # 根据客户端的头去判断我们是不是要去做压缩。
    gzip_vary on;
}  
</code></pre>
<blockquote>
<p>​	有些文件是很难压缩的。 有些文件是没有必要做压缩的。比如说 <code>图片</code>，<code>视频</code> 等。肯定要对图片做压缩，最后会失真的。</p>
<p>​	图片一般要放在 CDN 上的。</p>
</blockquote>
<h2 id="防盗链">防盗链</h2>
<p>​	一个网站上会有很多的图片，如果你不希望其他网站直接用你的图片地址访问自己的图片，或者希望对图片有版权保护。再或者不希望被第三方调用造成服务器的负载以及消耗比较多的流量问题，那么防盗链就是你必须要做的。</p>
<blockquote>
<p>​	CSDN 上的文章，粘贴下来，图片展示不出来，微信公众号的文章粘贴出来，图片也显示不出来。</p>
<blockquote>
<p>refer 是可以进行修改的。</p>
</blockquote>
</blockquote>
<h3 id="防盗链配置">防盗链配置</h3>
<p>在Nginx中配置防盗链其实很简单，<br>
语法: valid_referers none | blocked | server_names | string ...;</p>
<p>默认值: —<br>
上下文: server, location</p>
<p>​	“Referer”请求头为指定值时，内嵌变量 <code>$invalid_referer</code> 被设置为空字符串，否则这个变量会被置成“1”。查找匹配时不区分大小写，其中 <code>none</code> 表示缺少 <code>referer</code> 请求头、 <code>blocked</code> 表示请求头存在，但是它的值被防火墙或者代理服务器删除、<code>server_names</code>表示<code>referer</code>请求头包含指定的虚拟主机名。</p>
<ol>
<li>配置如下</li>
</ol>
<pre><code class="language-c">location ~ .*.(gif|jpg|ico|png|css|svg|js)$ {
    valid_referers none blocked 192.168.11.153;
    if ($invalid_referer) {
        return 404;
    }
    root static;
}
</code></pre>
<p>​	需要注意的是伪造一个有效的“<code>Referer</code>”请求头是相当容易的，因此这个模块的预期目的不在于彻底地阻止这些非法请求，而是为了阻止由正常浏览器发出的大规模此类请求。还有一点需要注意，即使正常浏览器发送的合法请求，也可能没有“<code>Referer</code>”请求头。</p>
<p>​	主要是防止转载，COPY 来 COPY 去的，量级的增长是很恐怖的。</p>
<h2 id="跨域访问">跨域访问</h2>
<p>​	他不光可以解决请求转发的问题。动静分离、防盗、限流。做集群。</p>
<p>​	什么叫跨域呢？如果两个节点的协议、域名、端口、子域名不同，那么进行的操作都是跨域的，浏览器为了安全问题都是限制跨域访问，所以跨域其实是浏览器本身的限制。</p>
<blockquote>
<p>阿里云的图片库也是跨域的，需要实现对应的方法。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/other/2396776/202502/2396776-20250225201857085-574940693.png" alt="JavaGuide_Nginx_应用实战_跨域问题.png" loading="lazy"></p>
<h3 id="解决办法">解决办法</h3>
<p>修改 <code>proxy_demo.conf</code> 配置</p>
<pre><code class="language-c">server{
    listen 80;
    server_name localhost;
    location / {
        proxy_pass http://192.168.11.154:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_connect_timeout 60s;
        # 允许来自所有的访问地址
        add_header 'Access-Control-Allow-Origin' '';
        # 支持的请求方式
        add_header 'Access-Control-Allow-Methods' 'GET,PUT,POST,DELETE,OPTIONS';
        #  支持的媒体类型   
        add_header 'Access-Control-Allow-Header' 'Content-Type,';
    }
    location ~ .*.(gif|jpg|ico|png|css|svg|js)$ {
        root static;
    }
}
</code></pre>
<h2 id="qa">QA</h2>
<ol>
<li>
<p>面试时，多线程的问题，如何全面地回答？</p>
<p>答： 面试官给你的感觉是，他感觉你回答得不好。</p>
<ul>
<li>你没有很强的语言表达能力。你没有办法把这个业务场景和它的特性梳理出来。</li>
<li>都知道，怎么去做。如何去做？没有一种逻辑上的回答。</li>
<li>多线程在某个阶段没有用过是很正常的。不代表我不会用。他心里会有点慌，会有种不敢讲的感觉。</li>
</ul>
<p>​</p>
<p>​	面试官会有他擅长的领域。而自己会有自己擅长的领域，他能决定的就是他是否录用你。除此之外。只是一场简单地技术交流。让对方了解你的技术体系。你要了解到公司的情况，这是一个双向的选择的过程。</p>
</li>
<li>
<p>怎么去实现 <strong>灰度发布</strong>，怎么去实现 <strong>限流</strong> 。</p>
</li>
</ol>
<h2 id="百万架构师系列文章阅读体验感更佳-1"><center><a href="https://javaguide.net" target="_blank" rel="noopener nofollow">百万架构师系列文章阅读体验感更佳</a></center></h2>
<h2 id="原文链接httpsjavaguidenet-1"><center>原文链接：<a href="https://javaguide.net" target="_blank" rel="noopener nofollow">https://javaguide.net</a></center></h2>
<h2 id="公众号不止极客-1"><center>公众号：不止极客</center></h2>
<p>来源于:  <a href="https://javaguide.net" target="_blank" rel="noopener nofollow">https://javaguide.net</a></p>
<p>微信公众号：不止极客</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.006670812424768519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-25 20:19">2025-02-25 20:18</span>&nbsp;
<a href="https://www.cnblogs.com/nogeek-cn">nogeek_cn</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737163" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737163);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737163', targetLink: 'https://www.cnblogs.com/nogeek-cn/p/18737163', title: '百万架构师第四十三课：Nginx：Nginx 应用实战｜JavaGuide' })">举报</a>
</div>
        