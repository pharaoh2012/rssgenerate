
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/DOMLX/p/18806214" title="发布于 2025-04-02 16:33">
    <span role="heading" aria-level="2">halcon 入门教程（三） 边缘检测</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-size: 14pt">原文作者：aircraft</span></p>
<p><span style="font-size: 14pt">原文链接：<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-04-02 16:33" href="https://www.cnblogs.com/DOMLX/p/18806214"> <span>halcon 入门教程（三） 边缘检测 <img src="https://www.cnblogs.com/images/visibility.svg" alt="审核中" class="text-tail-icon" title="审核中，审核通过后方可公开访问"> </span></a></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<span style="font-size: 18px">有兴趣可以多看其他的halcon教程</span></p>
<p><span style="font-size: 18pt">&nbsp;<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-18 17:21" href="https://www.cnblogs.com/DOMLX/p/18779348">halcon 学习教程目录</a></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">　　本篇讲一下边缘检测（边缘提取），因为这个我发现也是比较常用的，放在入门教程（三）会比较好，在入门教程（一）（二）学完了形态学，和Blob分析，再来学边缘检测并且结合案例感觉会掌握学习的很快。跟openCV一样主流的还是那几个检测算子Sobel、Canny<span style="font-size: 18px">、</span>Laplacian等等。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">一.边缘检测简介</span></strong></p>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>1. 边缘检测的基本原理</strong></span></h3>
<p><span style="font-size: 16px">边缘是图像中<strong>灰度、颜色或纹理发生显著变化</strong>的区域，通常对应物体的边界。边缘检测的目标是定位这些变化的区域，方法可分为：</span></p>
<ul>
<li><span style="font-size: 16px">​<strong>基于梯度</strong>：通过计算像素的梯度幅值和方向（如Sobel、Canny）。</span></li>
<li><span style="font-size: 16px">​<strong>基于二阶导数</strong>：利用拉普拉斯算子检测过零点（如Laplacian）。</span></li>
<li><span style="font-size: 16px">​<strong>基于模板匹配</strong>：使用预定义的边缘模板进行卷积。</span></li>
</ul>
<h3><span style="font-size: 16px"><strong>2. Halcon边缘检测的核心算法</strong></span></h3>
<h4><span style="font-size: 16px">​**(1) 一阶梯度法（Sobel, Prewitt）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>原理</strong>：通过卷积核计算像素在水*和垂直方向的梯度（<span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em"><span class="mord"><span class="mord mathnormal">G<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em"><span style="top: -2.55em; margin-left: 0; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x<span class="vlist-s">​<span class="vlist-r"><span class="vlist" style="height: 0.15em">和<span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em"><span class="mord"><span class="mord mathnormal">G<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em"><span style="top: -2.55em; margin-left: 0; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.03588em">y<span class="vlist-s">​<span class="vlist-r"><span class="vlist" style="height: 0.2861em">），合成梯度幅值和方向。 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402143446908-1910846380.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;halcon示例：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">sobel_amp(Image, EdgeAmplitude, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">sum_abs</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Sobel算子，3x3卷积核</span>
edges_image(Image, ImaAmp, ImaDir, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nms</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 综合梯度计算</span></span></pre>
</div>
<h4><span style="font-size: 16px">(2) Canny边缘检测**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>步骤</strong>：</span><ol>
<li><span style="font-size: 16px">​<strong>高斯滤波</strong>：去噪。</span></li>
<li><span style="font-size: 16px">​<strong>梯度计算</strong>：类似Sobel。</span></li>
<li><span style="font-size: 16px">​<strong>非极大值抑制（NMS）​</strong>：保留梯度方向上的局部最大值，细化边缘。</span></li>
<li><span style="font-size: 16px">​<strong>滞后阈值</strong>：使用高低阈值（<code>LowThreshold</code>, <code>HighThreshold</code>）连接边缘。</span></li>
</ol></li>
</ul>
<p><span style="font-size: 16px">&nbsp;halcon示例：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image, Edges, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Canny算法，亚像素精度</span></span></pre>
</div>
<h4><span style="font-size: 16px">(3) 亚像素边缘检测**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>原理</strong>：在像素级边缘检测的基础上，通过<strong>插值</strong>或<strong>梯度模型拟合</strong>​（如高斯函数、多项式）将精度提升到亚像素级别（精度可达0.1像素）。</span></li>
</ul>
<p><span style="font-size: 16px">halcon 示例：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image, Edges, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 直接输出亚像素边缘轮廓</span></span></pre>
</div>
<h3>&nbsp;</h3>
<h3><span style="font-size: 16px"><strong>3. Halcon边缘检测的关键技术</strong></span></h3>
<h4><span style="font-size: 16px">​**(1) 高斯滤波与尺度控制**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：通过调节高斯滤波的<code>Sigma</code>参数控制边缘检测的灵敏度。​<strong>示例</strong>：</span>
<ul>
<li>​<strong>大Sigma</strong>：检测粗边缘，抗噪能力强。</li>
<li>​<strong>小Sigma</strong>：检测细边缘，但易受噪声干扰。</li>
</ul>
</li>
<li></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image, Edges, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, Sigma, LowThresh, HighThresh)</span></pre>
</div>
<h4><span style="font-size: 16px">(2) 非极大值抑制（NMS）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：在梯度方向上仅保留局部最大值的像素，消除边缘的“宽线”现象。</span></li>
<li><span style="font-size: 16px">​<strong>Halcon参数</strong>：</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_image(Image, ImaAmp, ImaDir, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nms</span><span style="color: rgba(128, 0, 0, 1)">'</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用NMS</span></span></pre>
</div>
<h4><span style="font-size: 16px">(3) 滞后阈值（双阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>原理</strong>：​<strong>参数示例</strong>：</span>
<ul>
<li>​<strong>高阈值</strong>：强边缘必须超过此值。</li>
<li>​<strong>低阈值</strong>：弱边缘若与强边缘连接则保留。</li>
</ul>
</li>
<li></li>
</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image, Edges, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Low=20, High=40</span></span></pre>
</div>
<h3>&nbsp;</h3>
<h3><span style="font-size: 16px"><strong>4. Halcon边缘检测的优势</strong></span></h3>
<ol>
<li><span style="font-size: 16px">​<strong>亚像素精度</strong>：通过模型拟合实现超像素级边缘定位，适合高精度测量。</span></li>
<li><span style="font-size: 16px">​<strong>灵活性</strong>：支持多种算法（Canny、Sobel、Lanser等）和参数调节。</span></li>
<li><span style="font-size: 16px">​<strong>抗噪能力</strong>：高斯滤波和滞后阈值有效抑制噪声。</span></li>
<li><span style="font-size: 16px">​<strong>实时性</strong>：高度优化的算法实现，适用于工业实时检测。</span></li>
</ol>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>5. 总结</strong></span></h3>
<p><span style="font-size: 16px">Halcon的边缘检测通过<strong>梯度计算</strong>、<strong>非极大值抑制</strong>、<strong>双阈值分割</strong>和<strong>亚像素优化</strong>，实现了高精度和强鲁棒性的边缘提取。其核心在于*衡噪声抑制与细节保留，广泛应用于工业检测、自动驾驶、医学成像等领域。实际使用时需根据场景特点调整算法参数，并结合形态学操作（如膨胀、填充）优化结果。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong><span style="font-size: 18pt">二.算子与案例学习</span></strong></span></p>
<p>&nbsp;</p>
<p>　　<span style="font-size: 16px">这里正常我是想让大家先学习相关的算子函数的，但是因为我自己也学习过，我们学习的心态都是不见兔子不撒鹰，没有看到一些效果之前，我们都难以产生比较大的学习热情，所以这里先上一个车道线提取的案例学习，注释都会详细打清楚。在大一上学期的时候自己买了本单片机来学，发现学的太枯燥了，后来就放弃的硬件的路，后面偶然得到了个c语言的学习视频，然后跟着视频学，大一就把c语言c++，MFC那些东西都自学完了。对于初学的人没有能直观看到效果的学习，都是没有太大兴趣的。书本和文字冷冰冰的，怎么让初学者去学！！！</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">1.案例：车道线检测（autobahn.hdev）</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402145739569-842365938.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px">老规矩，先上图，我们的目的是把一定距离内的车道的车道线给提取出来</span></p>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402145813707-382214932.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;</span></p>
<p><span style="font-size: 16px">实例代码：autobahn.hdev</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">*<span style="color: rgba(0, 0, 0, 1)"> autobahn.hdev: Fast detection of lane markers
</span>*<span style="color: rgba(0, 0, 0, 1)"> 
dev_update_window (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)       
</span>*<span style="color: rgba(0, 0, 0, 1)"> 关闭窗口自动更新，避免频繁刷新提升执行速度
dev_close_window ()             
</span>*<span style="color: rgba(0, 0, 0, 1)"> 关闭所有已打开的图形窗口
dev_open_window (</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">768</span>, <span style="color: rgba(128, 0, 128, 1)">575</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, WindowID)  
</span>* 打开新窗口，位置(<span style="color: rgba(128, 0, 128, 1)">0</span>,<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)，尺寸768x575，背景黑色
MinSize :</span>= <span style="color: rgba(128, 0, 128, 1)">30</span>                   
*<span style="color: rgba(0, 0, 0, 1)"> 定义形态学膨胀的核大小（30x30矩形）
get_system (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">init_new_image</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Information)  
</span>* 获取系统默认的<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">init_new_image</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">参数值
set_system (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">init_new_image</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)      
</span>*<span style="color: rgba(0, 0, 0, 1)"> 禁止系统自动初始化新图像，避免覆盖已有图像

</span>*<span style="color: rgba(0, 0, 0, 1)"> 生成网格区域，用于限制后续处理的ROI（感兴趣区域）  注意这里只是提取宽度为30像素的网格线区域出来
gen_grid_region (Grid, MinSize, MinSize, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lines</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">512</span>, <span style="color: rgba(128, 0, 128, 1)">512</span><span style="color: rgba(0, 0, 0, 1)">)  
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*<span style="color: rgba(0, 0, 0, 1)">   Grid        : 输出网格区域
</span>*<span style="color: rgba(0, 0, 0, 1)">   MinSize     : 网格线间距（水*和垂直均为30像素）
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lines</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">     : 生成线型网格（非矩形块）
</span>*   <span style="color: rgba(128, 0, 128, 1)">512</span>, <span style="color: rgba(128, 0, 128, 1)">512</span><span style="color: rgba(0, 0, 0, 1)">    : 网格覆盖的原始图像尺寸（此处可能与实际图像尺寸不一致，后续通过裁剪修正）

</span>* 裁剪网格区域，仅保留道路部分（坐标范围：行130~<span style="color: rgba(128, 0, 128, 1)">450</span>，列10~<span style="color: rgba(128, 0, 128, 1)">502</span><span style="color: rgba(0, 0, 0, 1)">）
clip_region (Grid, StreetGrid, </span><span style="color: rgba(128, 0, 128, 1)">130</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">450</span>, <span style="color: rgba(128, 0, 128, 1)">502</span><span style="color: rgba(0, 0, 0, 1)">)  

dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)          
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置显示线宽为3（用于网格和边缘的高亮显示）
dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">green</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)         
</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置显示颜色为绿色（用于网格）
read_image (ActualImage, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">autobahn/scene_00</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)  
</span>*<span style="color: rgba(0, 0, 0, 1)"> 读取第一帧图像（scene_00）
dev_display (ActualImage)       
</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示图像
stop ()                         
</span>*<span style="color: rgba(0, 0, 0, 1)"> 暂停程序，等待用户按F5继续
dev_display (StreetGrid)        
</span>*<span style="color: rgba(0, 0, 0, 1)"> 在图像上叠加显示裁剪后的网格区域（绿色）
stop ()                         
</span>*<span style="color: rgba(0, 0, 0, 1)"> 再次暂停

</span><span style="color: rgba(0, 0, 255, 1)">for</span> i := <span style="color: rgba(128, 0, 128, 1)">0</span> to <span style="color: rgba(128, 0, 128, 1)">28</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
    *<span style="color: rgba(0, 0, 0, 1)"> 读取当前帧图像（例如：scene_00, scene_01,..., scene_28）
    read_image (ActualImage, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">autobahn/scene_</span><span style="color: rgba(128, 0, 0, 1)">'</span> + (i$<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">02</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">))  
    </span>* i$<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">02</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">表示两位数字补零
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 将处理区域限制到StreetGrid网格内
    reduce_domain (ActualImage, StreetGrid, Mask)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 作用：生成一个掩膜图像Mask，仅保留StreetGrid区域内的像素
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> Sobel边缘检测（梯度幅值计算）
    sobel_amp (Mask, Gradient, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">sum_abs</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">sum_abs</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">   : 梯度计算方法（水*与垂直方向绝对值之和）
    </span>*   <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">           : Sobel算子尺寸（3x3核）
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 初次阈值分割提取边缘点   <span style="font-size: 16px"><span style="color: rgba(0, 0, 0, 1)">Gradient</span></span>这个是得到的梯度图，只有在边缘区域(也就是道路和道路线交汇的区域)才会有较高的灰度值存在
    threshold (Gradient, Points, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)  
    </span>* 提取梯度值在[<span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">]之间的区域（初步筛选车道线边缘）
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 形态学膨胀（连接离散边缘点）
    dilation_rectangle1 (Points, RegionDilation, MinSize, MinSize)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 使用30x30矩形核对边缘点进行膨胀，连接相邻点形成连续区域
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 限制处理区域到膨胀后的区域
    reduce_domain (ActualImage, RegionDilation, StripGray)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> StripGray为仅包含RegionDilation区域的灰度图像
    
    </span>* 高亮度区域提取（车道线通常为白色/<span style="color: rgba(0, 0, 0, 1)">黄色）
    threshold (StripGray, Strip, </span><span style="color: rgba(128, 0, 128, 1)">190</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)  
    </span>* 提取灰度值在[<span style="color: rgba(128, 0, 128, 1)">190</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">]之间的区域（高亮度车道线）
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 填充区域内的孔洞
    fill_up (Strip, RegionFillUp)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 确保车道线区域连续无断裂
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示处理结果
    dev_display (ActualImage)    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像
    dev_display (RegionFillUp)   
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 叠加显示检测到的车道线区域（默认颜色）
endfor

dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">)          
</span>*<span style="color: rgba(0, 0, 0, 1)"> 恢复默认线宽为1
dev_update_window (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">on</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)        
</span>*<span style="color: rgba(0, 0, 0, 1)"> 重新启用窗口自动更新
set_system (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">init_new_image</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, Information)  
</span>* 恢复系统参数<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">init_new_image</span><span style="color: rgba(128, 0, 0, 1)">'</span>的默认值</span></pre>
</div>
<h3><span style="font-size: 16px"><strong>关键步骤总结</strong></span></h3>
<ol>
<li><span style="font-size: 16px">​<strong>ROI限制</strong>：通过网格裁剪 (<code>clip_region</code>) 和域缩减 (<code>reduce_domain</code>) 聚焦道路区域，减少计算量。</span></li>
<li><span style="font-size: 16px">​<strong>边缘检测</strong>：Sobel算子提取梯度，阈值分割初步筛选边缘点。</span></li>
<li><span style="font-size: 16px">​<strong>形态学处理</strong>：膨胀操作连接离散点，填充操作确保车道线连续。</span></li>
<li><span style="font-size: 16px">​<strong>亮度阈值</strong>：假设车道线高亮，通过二次阈值分割精确定位。</span></li>
</ol>
<p>&nbsp;</p>
<p><span style="font-size: 18px">效果图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402150449104-149783337.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">　　第一个案例有我的注释在理解起来应该还是比较简单的，也发现了里面开始运用到了一些边缘检测的算子，接下来我们就学习一下几个常用的边缘检测的算子。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px">1.<span style="font-size: 18px">sobel</span>算子sobel_amp(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#EdgeAmplitude" rel="noopener nofollow"><em>EdgeAmplitude</em></a>&nbsp;:&nbsp;<a href="#FilterType" rel="noopener nofollow"><em>FilterType</em></a>,&nbsp;<a href="#Size" rel="noopener nofollow"><em>Size</em></a>&nbsp;: )详解：</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">sobel_amp(Image : EdgeAmplitude : FilterType, Size : )</span></pre>
</div>
<ul>
<li><span style="font-size: 16px"><strong>功能</strong>：通过 Sobel 算子计算图像的梯度幅值，用于边缘检测。</span></li>
<li><span style="font-size: 16px">​<strong>输入/输出</strong>：</span>
<ul>
<li><span style="font-size: 16px"><code>Image</code>：输入图像（单通道灰度图像）。</span></li>
<li><span style="font-size: 16px"><code>EdgeAmplitude</code>：输出图像，表示梯度幅值（边缘强度）。</span></li>
<li><span style="font-size: 16px"><code>FilterType</code>：梯度计算方法（如 'sum_abs'）。</span></li>
<li><span style="font-size: 16px"><code>Size</code>：Sobel 核的大小（3, 5, 7, 9, 11 等奇数）。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 16px">1. ​**<code>FilterType参数</code>（梯度计算方式）​**</span></h4>
<p><span style="font-size: 16px">控制梯度幅值的计算方法，常见选项如下：</span></p>
<ul>
<li>
<p>​**<code>'sum_abs'</code>**​（默认）：</p>
<ul>
<li>计算水*和垂直方向梯度的绝对值之和：&nbsp;
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402151245569-553696789.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
</li>
<li><span style="font-size: 16px">计算速度快，适用于实时性要求高的场景。</span></li>
</ul>
</li>
<li>
<p>​**<code>'thin_sum_abs'</code>**：</p>
<ul>
<li><span style="font-size: 16px">类似 <code>'sum_abs'</code>，但使用更小的卷积核（仅适用于 <code>Size=3</code>）。</span></li>
</ul>
</li>
<li>
<p>​**<code>'x'</code>** 或 ​**<code>'y'</code>**：</p>
<ul>
<li><span style="font-size: 16px">仅计算水*方向（<code>'x'</code>）或垂直方向（<code>'y'</code>）的梯度。</span></li>
</ul>
</li>
<li>
<p>​**<code>'frei_chen'</code>**：</p>
<ul>
<li><span style="font-size: 16px">使用 Frei-Chen 算子，增强对角边缘的响应。</span></li>
<li><span style="font-size: 16px">适用于复杂纹理或对角边缘检测。</span></li>
</ul>
</li>
<li>
<p>​**<code>'sobel'</code>**：</p>
<span style="font-size: 16px"><span class="katex-display"><span class="katex"><span class="katex-html"><span class="base"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span>
<ul>
<li>计算欧几里得距离（*方和开根号）：
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402151234088-2127615215.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<span class="katex-display"><span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em"><span class="mord mathnormal"><span class="mspace" style="margin-right: 0.2778em"><span class="mrel"><span class="mspace" style="margin-right: 0.2778em"><span class="base"><span class="strut" style="height: 1.84em; vertical-align: -0.6276em"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.2124em"><span class="svg-align" style="top: -3.8em"><span class="pstrut" style="height: 3.8em"><span class="mord" style="padding-left: 1em"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7401em"><span style="top: -2.453em; margin-left: 0; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight"><span style="top: -2.989em; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="vlist-s"><span class="vlist-r"><span class="vlist" style="height: 0.247em"><span class="mspace" style="margin-right: 0.2222em"><span class="mbin"><span class="mspace" style="margin-right: 0.2222em"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7401em"><span style="top: -2.453em; margin-left: 0; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.03588em"><span style="top: -2.989em; margin-right: 0.05em"><span class="pstrut" style="height: 2.7em"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li></li>
<li><span style="font-size: 16px">更接*理论梯度，但计算量较大。</span></li>
</ul>
<br>
<h4><span style="font-size: 16px">2. ​**<code>Size</code>（卷积核大小）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>取值范围</strong>：3, 5, 7, 9, 11 等奇数。</span></li>
<li><span style="font-size: 16px">​<strong>影响</strong>：</span>
<ul>
<li>​<span style="font-size: 16px"><strong>小尺寸（如 3）​</strong>：检测细边缘，但对噪声敏感。</span></li>
<li><span style="font-size: 16px">​<strong>大尺寸（如 5）​</strong>：检测粗边缘，抗噪能力强，但可能丢失细节。</span></li>

</ul>

</li>
<li><span style="font-size: 16px">​<strong>典型选择</strong>：</span>
<ul>
<li><span style="font-size: 16px">大多数场景：<code>Size=3</code>。</span></li>
<li><span style="font-size: 16px">高噪声图像：<code>Size=5</code> 或 <code>7</code>。</span></li>

</ul>

</li>

</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>使用示例</strong></span></h3>
<h4><span style="font-size: 16px">示例 1：基本边缘检测</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">read_image(Image, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">part.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
sobel_amp(Image, EdgeAmplitude, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">sum_abs</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)
threshold(EdgeAmplitude, Edges, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">255</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 阈值分割提取边缘</span></span></pre>
</div>
<h3><span style="font-size: 16px"><strong>应用场景</strong></span></h3>
<ol>
<li>
<p>​<strong>工业检测</strong>：</p>
<ul>
<li><span style="font-size: 16px">检测零件轮廓、缺陷边缘。</span></li>
<li><span style="font-size: 16px">参数建议：<code>FilterType='sum_abs'</code>, <code>Size=3</code>。</span></li>
</ul>
</li>
<li>
<p>​<strong>车道线检测（如 autobahn.hdev）​</strong>：</p>
<ul>
<li><span style="font-size: 16px">提取车道线边缘，需*衡噪声抑制和边缘连续性。</span></li>
<li><span style="font-size: 16px">参数建议：<code>FilterType='sum_abs'</code>, <code>Size=3</code>。</span></li>
</ul>
</li>
<li>
<p>​<strong>医学图像处理</strong>：</p>
<ul>
<li><span style="font-size: 16px">检测组织边界或血管。</span></li>
<li><span style="font-size: 16px">参数建议：<code>FilterType='frei_chen'</code>, <code>Size=5</code>（增强复杂边缘）。</span></li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>参数选择建议</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>场景需求</strong></span></th><th><span style="font-size: 16px">​<strong>推荐参数</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px">实时性要求高</span></td>
<td><span style="font-size: 16px"><code>FilterType='sum_abs'</code>, <code>Size=3</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">高精度边缘定位</span></td>
<td><span style="font-size: 16px"><code>FilterType='sobel'</code>, <code>Size=3</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">抗噪需求强</span></td>
<td><span style="font-size: 16px"><code>Size=5</code> 或 <code>7</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">检测对角边缘</span></td>
<td><span style="font-size: 16px"><code>FilterType='frei_chen'</code></span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>与其他算子的对比</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>算子</strong></span></th><th><span style="font-size: 16px">​<strong>特点</strong></span></th><th><span style="font-size: 16px">​<strong>适用场景</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px"><code>sobel_amp</code></span></td>
<td><span style="font-size: 16px">灵活调节核大小，多种梯度计算方式</span></td>
<td><span style="font-size: 16px">通用边缘检测</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>edges_image</code></span></td>
<td><span style="font-size: 16px">集成非极大值抑制（NMS）和亚像素精度</span></td>
<td><span style="font-size: 16px">高精度边缘（如测量）</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>canny</code></span></td>
<td><span style="font-size: 16px">双阈值和NMS，抗噪能力强但计算量大</span></td>
<td><span style="font-size: 16px">复杂背景下的弱边缘检测</span></td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px"><span style="font-size: 18px">2.<span style="font-size: 18px">亚像素精度边缘提取算子（常用）<strong>edges_sub_pix</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#Edges" rel="noopener nofollow"><em>Edges</em></a>&nbsp;:&nbsp;<a href="#Filter" rel="noopener nofollow"><em>Filter</em></a>,&nbsp;<a href="#Alpha" rel="noopener nofollow"><em>Alpha</em></a>,&nbsp;<a href="#Low" rel="noopener nofollow"><em>Low</em></a>,&nbsp;<a href="#High" rel="noopener nofollow"><em>High</em></a>&nbsp;: )详解：</span></span></span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image : Edges : Filter, Alpha, Low, High : )</span></pre>
</div>
<ul>
<li><span style="font-size: 16px"><strong>功能</strong>：​<strong>亚像素级精度的边缘检测</strong>，输出连续的边缘轮廓（XLD格式）。</span></li>
<li><span style="font-size: 16px">​<strong>输入/输出</strong>：</span>
<ul>
<li><span style="font-size: 16px"><code>Image</code>：输入图像（单通道灰度图像）。</span></li>
<li><span style="font-size: 16px"><code>Edges</code>：输出的亚像素边缘轮廓（XLD对象）。</span></li>
<li><span style="font-size: 16px"><code>Filter</code>：边缘检测滤波器类型（如 'canny', 'lanser2', 'deriche1'）。</span></li>
<li><span style="font-size: 16px"><code>Alpha</code>：滤波器的*滑参数（控制边缘锐度与抗噪性）。</span></li>
<li><span style="font-size: 16px"><code>Low</code>, <code>High</code>：滞后阈值（用于边缘连接）。</span></li>
</ul>
</li>
</ul>
<h3><span style="font-size: 16px"><strong>参数详解</strong></span></h3>
<h4><span style="font-size: 16px">1. ​**<code>Filter</code>（滤波器类型）​**</span></h4>
<p><span style="font-size: 16px">不同滤波器对应不同的边缘检测算法：</span></p>
<ul>
<li>
<p>​**<code>'canny'</code>**​（默认）：</p>
<ul>
<li><span style="font-size: 16px">基于高斯导数，支持亚像素精度。</span></li>
<li><span style="font-size: 16px">适用于通用场景，计算效率高。</span></li>
<li><span style="font-size: 16px">​<strong>Alpha</strong>：高斯滤波器的标准差（推荐值：1.0~3.0）。</span></li>
</ul>
</li>
<li>
<p>​**<code>'lanser2'</code>**：</p>
<ul>
<li><span style="font-size: 16px">使用 Lanser 滤波器，边缘定位更精确。</span></li>
<li><span style="font-size: 16px">适用于高精度测量，但计算量较大。</span></li>
<li><span style="font-size: 16px">​<strong>Alpha</strong>：*滑参数（推荐值：0.3~0.7）。</span></li>
</ul>
</li>
<li>
<p>​**<code>'deriche1'</code>** 和 ​**<code>'deriche2'</code>**：</p>
<ul>
<li><span style="font-size: 16px">基于递归滤波器，适合实时处理。</span></li>
<li><span style="font-size: 16px">​<strong>Alpha</strong>：控制*滑程度（值越大，*滑越强）。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 16px">2. ​**<code>Alpha</code>（*滑参数）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：*衡边缘锐度与噪声抑制。</span>
<ul>
<li>​<span style="font-size: 16px"><strong>小Alpha</strong>​（如 0.5）：保留细节，但易受噪声干扰。</span></li>
<li><span style="font-size: 16px">​<strong>大Alpha</strong>​（如 3.0）：强*滑，适合高噪声图像。</span></li>
</ul>
</li>
<li><span style="font-size: 16px">​<strong>典型值</strong>：</span>
<ul>
<li><span style="font-size: 16px"><code>'canny'</code>：1.0~3.0。</span></li>
<li><span style="font-size: 16px"><code>'lanser2'</code>：0.3~0.7。</span></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 16px">3. ​**<code>Low</code> 和 <code>High</code>（滞后阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：​<strong>经验规则</strong>：<code>High ≈ 2 * Low</code>。</span>
<ul>
<li>​<span style="font-size: 16px"><strong>High</strong>：边缘强度的最低阈值，高于此值的边缘被保留。</span></li>
<li><span style="font-size: 16px">​<strong>Low</strong>：低于此值的边缘被忽略；介于两者之间的边缘需与高阈值边缘连接。</span></li>
</ul>
</li>
<li></li>
<li><span style="font-size: 16px">​<strong>示例</strong>：</span>
<ul>
<li><span style="font-size: 16px">若图像对比度低，设置 <code>Low=10</code>, <code>High=20</code>。</span></li>
<li><span style="font-size: 16px">若对比度高，设置 <code>Low=30</code>, <code>High=60</code>。</span></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>使用示例</strong></span></h3>
<h4><span style="font-size: 16px">示例 1：Canny 边缘检测</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">read_image(Image, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">part.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
edges_sub_pix(Image, Edges, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 128, 1)">25</span>, <span style="color: rgba(128, 0, 128, 1)">50</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display(Edges)  </span>* 显示亚像素边缘</span></pre>
</div>
<h4>&nbsp;</h4>
<h4><span style="font-size: 16px">示例 2：Lanser 滤波器（高精度）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_sub_pix(Image, Edges, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lanser2</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 16px"><strong>应用场景</strong></span></h3>
<ol>
<li>
<p>​<strong>工业测量</strong>：</p>
<ul>
<li><span style="font-size: 16px">检测零件边缘，用于尺寸测量。</span></li>
<li><span style="font-size: 16px">参数建议：<code>Filter='lanser2'</code>, <code>Alpha=0.5</code>, <code>Low=20</code>, <code>High=40</code>。</span></li>
</ul>
</li>
<li>
<p>​<strong>车道线检测</strong>：</p>
<ul>
<li><span style="font-size: 16px">提取车道线轮廓，结合形态学处理。</span></li>
<li><span style="font-size: 16px">参数建议：<code>Filter='canny'</code>, <code>Alpha=1.5</code>, <code>Low=15</code>, <code>High=30</code>。</span></li>
</ul>
</li>
<li>
<p>​<strong>医学图像分析</strong>：</p>
<ul>
<li><span style="font-size: 16px">定位组织或器官边界。</span></li>
<li><span style="font-size: 16px">参数建议：<code>Filter='canny'</code>, <code>Alpha=2.0</code>, <code>Low=10</code>, <code>High=20</code>。</span></li>
</ul>
</li>
</ol>
<h3><span style="font-size: 16px"><strong>参数调优策略</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>问题现象</strong></span></th><th><span style="font-size: 16px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px">边缘断裂</span></td>
<td><span style="font-size: 16px">降低 <code>Low</code> 或增大 <code>Alpha</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">噪声过多</span></td>
<td><span style="font-size: 16px">增大 <code>Alpha</code> 或提高 <code>Low</code>/<code>High</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">边缘模糊</span></td>
<td><span style="font-size: 16px">减小 <code>Alpha</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">漏检弱边缘</span></td>
<td><span style="font-size: 16px">降低 <code>High</code> 或 <code>Low</code></span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>对比其他边缘检测算子</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>算子</strong></span></th><th><span style="font-size: 16px">​<strong>精度</strong></span></th><th><span style="font-size: 16px">​<strong>抗噪性</strong></span></th><th><span style="font-size: 16px">​<strong>速度</strong></span></th><th><span style="font-size: 16px">​<strong>适用场景</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px"><code>edges_sub_pix</code></span></td>
<td><span style="font-size: 16px">亚像素</span></td>
<td><span style="font-size: 16px">高</span></td>
<td><span style="font-size: 16px">中</span></td>
<td><span style="font-size: 16px">高精度测量</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>sobel_amp</code></span></td>
<td><span style="font-size: 16px">像素级</span></td>
<td><span style="font-size: 16px">中</span></td>
<td><span style="font-size: 16px">快</span></td>
<td><span style="font-size: 16px">快速边缘检测</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>canny</code></span></td>
<td><span style="font-size: 16px">像素级</span></td>
<td><span style="font-size: 16px">高</span></td>
<td><span style="font-size: 16px">慢</span></td>
<td><span style="font-size: 16px">复杂背景下的边缘</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>总结</strong></span></h3>
<p><span style="font-size: 16px"><code>edges_sub_pix</code> 是 Halcon 中实现亚像素边缘检测的核心算子，通过合理选择滤波器类型（<code>Filter</code>）、*滑参数（<code>Alpha</code>）和阈值（<code>Low</code>, <code>High</code>），可在噪声抑制与细节保留之间取得*衡。典型场景包括工业零件测量、车道线识别和医学图像分析。实际应用中需结合后处理操作（如边缘连接和拟合）以提升结果质量。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong><span style="font-size: 18px"><span style="font-size: 18px">3.<span style="font-size: 18px">像素精度边缘提取算子<strong>edges_image</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;:&nbsp;<a href="#ImaAmp" rel="noopener nofollow"><em>ImaAmp</em></a>,&nbsp;<a href="#ImaDir" rel="noopener nofollow"><em>ImaDir</em></a>&nbsp;:&nbsp;<a href="#Filter" rel="noopener nofollow"><em>Filter</em></a>,&nbsp;<a href="#Alpha" rel="noopener nofollow"><em>Alpha</em></a>,&nbsp;<a href="#NMS" rel="noopener nofollow"><em>NMS</em></a>,&nbsp;<a href="#Low" rel="noopener nofollow"><em>Low</em></a>,&nbsp;<a href="#High" rel="noopener nofollow"><em>High</em></a>&nbsp;: )详解：</span></span></span></strong></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_image(Image : ImaAmp, ImaDir : Filter, Alpha, NMS, Low, High : )</span></pre>
</div>
<ul>
<li><span style="font-size: 16px"><strong>功能</strong>：执行<strong>像素级边缘检测</strong>，输出梯度幅值图像（<code>ImaAmp</code>）和方向图像（<code>ImaDir</code>），支持多种滤波器和非极大值抑制（NMS）。</span></li>
<li><span style="font-size: 16px">​<strong>输入/输出</strong>：</span>
<ul>
<li><span style="font-size: 16px"><code>Image</code>：输入图像（单通道灰度图像）。</span></li>
<li><span style="font-size: 16px"><code>ImaAmp</code>：输出梯度幅值图像（灰度图，高值对应边缘）。</span></li>
<li><span style="font-size: 16px"><code>ImaDir</code>：输出梯度方向图像（角度图，范围0~180°）。</span></li>
<li><span style="font-size: 16px"><code>Filter</code>：边缘检测滤波器类型（如 'canny', 'sobel_fast'）。</span></li>
<li><span style="font-size: 16px"><code>Alpha</code>：滤波器*滑参数。</span></li>
<li><span style="font-size: 16px"><code>NMS</code>：非极大值抑制模式（'none', 'nms', 'thin'）。</span></li>
<li><span style="font-size: 16px"><code>Low</code>, <code>High</code>：滞后阈值（用于边缘连接）。</span></li>
</ul>
</li>
</ul>
<h3><span style="font-size: 16px"><strong>参数详解</strong></span></h3>
<h4><span style="font-size: 16px">1. ​**<code>Filter</code>（滤波器类型）​**</span></h4>
<ul>
<li>
<p>​**<code>'canny'</code>**：<br>
基于高斯导数的Canny算法，支持亚像素级精度。</p>
<ul>
<li>​<span style="font-size: 16px"><strong>Alpha</strong>：高斯滤波的标准差（推荐值1.0~3.0）。</span></li>
<li><span style="font-size: 16px">​<strong>特点</strong>：抗噪能力强，适用于复杂场景。</span></li>


</ul>



</li>
<li>
<p>​**<code>'sobel_fast'</code>**：<br>
优化的Sobel算子，计算速度快。</p>
<ul>
<li>​<span style="font-size: 16px"><strong>Alpha</strong>：无意义（可设为任意值）。</span></li>
<li><span style="font-size: 16px">​<strong>特点</strong>：适合实时处理，但精度较低。</span></li>


</ul>



</li>
<li>
<p>​**<code>'lanser2'</code>** 或 ​**<code>'deriche2'</code>**：<br>
高精度滤波器，适合测量任务。</p>
<ul>
<li>​<span style="font-size: 16px"><strong>Alpha</strong>：控制*滑强度（参考值0.3~0.7）。</span></li>


</ul>



</li>


</ul>
<h4><span style="font-size: 16px">2. ​**<code>Alpha</code>（*滑参数）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：控制滤波器的*滑程度。</span>
<ul>
<li>​<span style="font-size: 16px"><strong>小Alpha</strong>​（如0.5）：保留细节，适合清晰边缘。</span></li>
<li><span style="font-size: 16px">​<strong>大Alpha</strong>​（如3.0）：强*滑，适合高噪声图像。</span></li>


</ul>



</li>


</ul>
<h4><span style="font-size: 16px">3. ​**<code>NMS</code>（非极大值抑制模式）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​**<code>'none'</code>**：不进行非极大值抑制，输出宽边缘。</span></li>
<li><span style="font-size: 16px">​**<code>'nms'</code>**：标准非极大值抑制，细化边缘至单像素宽。</span></li>
<li><span style="font-size: 16px">​**<code>'thin'</code>**：优化细化模式，适合高精度测量。</span></li>


</ul>
<h4><span style="font-size: 16px">4. ​**<code>Low</code> 和 <code>High</code>（滞后阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：​<strong>经验规则</strong>：<code>High ≈ 2 * Low</code>。</span>
<ul>
<li><span style="font-size: 16px"><code>High</code>：边缘强度的最低阈值，高于此值的像素被保留为强边缘。</span></li>
<li><span style="font-size: 16px"><code>Low</code>：低于此值的像素被忽略；介于两者之间的像素需与强边缘连接。</span></li>


</ul>



</li>
<li></li>
<li><span style="font-size: 16px">​<strong>示例</strong>：</span>
<ul>
<li><span style="font-size: 16px">低对比度图像：<code>Low=10</code>, <code>High=20</code>。</span></li>
<li><span style="font-size: 16px">高对比度图像：<code>Low=30</code>, <code>High=60</code>。</span></li>


</ul>



</li>


</ul>
<h3><span style="font-size: 16px"><strong>使用示例</strong></span></h3>
<h4><span style="font-size: 16px">示例1：Canny边缘检测（带NMS）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">read_image(Image, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">part.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
edges_image(Image, Amp, Dir, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nms</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span><span style="color: rgba(0, 0, 0, 1)">)
threshold(Amp, Edges, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">255</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 二值化边缘</span></span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 16px">示例2：Sobel快速检测（无NMS）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">edges_image(Image, Amp, Dir, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">sobel_fast</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>)</span></pre>
</div>
<div class="agent-chat__conv--ai__speech_show" data-conv-index="13" data-speech-index="0">
<div class="hyc-component-reasoner">
<div class="hyc-component-reasoner__text">
<div class="hyc-content-md">
<div class="hyc-common-markdown hyc-common-markdown-style">
<h3><span style="font-size: 16px"><strong>应用场景</strong></span></h3>
<ol>
<li>
<p>​<strong>工业零件检测</strong>：</p>
<ul>
<li>​<strong>参数</strong>：<code>Filter='canny'</code>, <code>Alpha=1.5</code>, <code>NMS='nms'</code>, <code>Low=20</code>, <code>High=40</code>。</li>
<li>​<strong>效果</strong>：高精度定位边缘，用于尺寸测量。</li>
</ul>
</li>
<li>
<p>​<strong>实时视频处理（如车道线检测）​</strong>：</p>
<ul>
<li>​<strong>参数</strong>：<code>Filter='sobel_fast'</code>, <code>NMS='none'</code>, <code>Low=15</code>, <code>High=30</code>。</li>
<li>​<strong>特点</strong>：牺牲精度换速度，适合嵌入式设备。</li>
</ul>
</li>
<li>
<p>​<strong>医学图像分析（如血管分割）​</strong>：</p>
<ul>
<li>​<strong>参数</strong>：<code>Filter='lanser2'</code>, <code>Alpha=0.5</code>, <code>NMS='thin'</code>, <code>Low=10</code>, <code>High=20</code>。</li>
<li>​<strong>效果</strong>：增强弱边缘检测能力。</li>
</ul>
</li>
</ol>
<h3><span style="font-size: 16px"><strong>参数调优策略</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>问题现象</strong></span></th><th><span style="font-size: 16px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px">边缘过宽</span></td>
<td><span style="font-size: 16px">启用 <code>NMS='nms'</code> 或 <code>NMS='thin'</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">噪声过多</span></td>
<td><span style="font-size: 16px">增大 <code>Alpha</code> 或提高 <code>Low</code>/<code>High</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">弱边缘漏检</span></td>
<td><span style="font-size: 16px">降低 <code>Low</code> 和 <code>High</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">计算速度慢</span></td>
<td><span style="font-size: 16px">改用 <code>Filter='sobel_fast'</code></span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>与其他算子的对比</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>算子</strong></span></th><th><span style="font-size: 16px">​<strong>精度</strong></span></th><th><span style="font-size: 16px">​<strong>抗噪性</strong></span></th><th><span style="font-size: 16px">​<strong>输出类型</strong></span></th><th><span style="font-size: 16px">​<strong>适用场景</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px"><code>edges_image</code></span></td>
<td><span style="font-size: 16px">像素级</span></td>
<td><span style="font-size: 16px">高</span></td>
<td><span style="font-size: 16px">梯度幅值+方向</span></td>
<td><span style="font-size: 16px">通用边缘检测</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>edges_sub_pix</code></span></td>
<td><span style="font-size: 16px">亚像素</span></td>
<td><span style="font-size: 16px">高</span></td>
<td><span style="font-size: 16px">XLD轮廓</span></td>
<td><span style="font-size: 16px">高精度测量</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>sobel_amp</code></span></td>
<td><span style="font-size: 16px">像素级</span></td>
<td><span style="font-size: 16px">中</span></td>
<td><span style="font-size: 16px">梯度幅值</span></td>
<td><span style="font-size: 16px">快速边缘检测</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>总结</strong></span></h3>
<p><span style="font-size: 16px"><code>edges_image</code> 是 Halcon 中灵活的边缘检测算子，支持多种滤波器和非极大值抑制模式。其核心优势在于：</span></p>
<ol>
<li><span style="font-size: 16px">​<strong>灵活性</strong>：通过 <code>Filter</code> 和 <code>NMS</code> 适配不同场景（速度、精度、抗噪性）。</span></li>
<li><span style="font-size: 16px">​<strong>可调性</strong>：通过 <code>Alpha</code> 和阈值*衡噪声抑制与细节保留。</span></li>
<li><span style="font-size: 16px">​<strong>输出丰富</strong>：梯度幅值和方向信息可用于后续处理（如边缘跟踪或方向分析）。</span></li>
</ol>
<p><span style="font-size: 16px">典型应用包括工业检测、医学图像处理和实时视频分析。实际使用中需根据具体需求调整参数，并配合阈值分割或形态学操作优化结果。</span></p>
</div>
</div>
</div>
</div>
</div>
<div class="agent-chat__conv--ai__toolbar" data-conv-index="13" data-speech-index="0">
<div class="agent-chat__toolbar agent-chat__toolbar_new">
<div class="agent-chat__toolbar__left">&nbsp;</div>
<div class="agent-chat__toolbar__right">
<div class="agent-chat__toolbar__item agent-chat__toolbar__copy">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__collect">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__suitable">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__suitable">&nbsp;　<span style="font-size: 18px">　写到这里我想的是边缘检测都学了，霍夫变换也可以了解学习一下，反正基本都是可以配合起来一起使用的：</span></div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__suitable">
<h3><span style="font-size: 16px"><strong>霍夫变换的基本原理</strong></span></h3>
<p><span style="font-size: 16px">　　Halcon 中的霍夫变换（Hough Transform）是一种强大的工具，主要用于从图像中检测几何形状（如直线、圆、椭圆等）</span></p>
<p><span style="font-size: 16px">霍夫变换通过将图像空间中的点映射到参数空间（极坐标系），利用投票机制检测几何形状。</span><br><span style="font-size: 16px">
对于直线检测，每个边缘点 <span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em"><span class="mopen">(<span class="mord mathnormal">x<span class="mpunct">,<span class="mspace" style="margin-right: 0.1667em"><span class="mord mathnormal" style="margin-right: 0.03588em">y<span class="mclose">) 对应极坐标中的一条正弦曲线：</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402153336357-1300337739.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;</span></p>

<br>
<ul>
<li><span class="katex" style="font-size: 16px"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"><span class="mord mathnormal" style="margin-right: 0.02778em">r：直线到原点的距离（像素）</span></span></span></span></span></li>
<li><span class="katex" style="font-size: 16px"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em"><span class="mord mathnormal" style="margin-right: 0.02778em">θ：直线与图像x轴的夹角（弧度，范围：-<span class="katex"><span class="katex-html"><span class="base"><span class="mord mathnormal" style="margin-right: 0.03588em">π </span></span></span></span>/ 2 ~ <span class="katex"><span class="katex-html"><span class="base"><span class="mord mathnormal" style="margin-right: 0.03588em">π </span></span></span></span>/ 2)</span></span></span></span></span></li>


</ul>
<p><span style="font-size: 16px"><strong>关键步骤</strong>：</span></p>
<ol><ol>
<li><span style="font-size: 16px">​<strong>参数空间量化</strong>：将 <span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em"><span class="mord mathnormal" style="margin-right: 0.02778em">θ 和 <span class="katex"><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em"><span class="mord mathnormal" style="margin-right: 0.02778em">r 离散化为有限区间。</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span style="font-size: 16px">​<strong>累加器投票</strong>：每个边缘点在参数空间中对应的曲线经过的区间投票计数。</span></li>
<li><span style="font-size: 16px">​<strong>峰值检测</strong>：累加器值超过阈值的区间视为检测到的直线参数。</span></li>


</ol></ol></div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__suitable">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat"><span style="font-size: 16px">&nbsp;<strong>霍夫变换在halcon中的算子有：hough_lines（），hough_circles（），hough_line_trans（），hough_circle_trans（）等等。然后继续我们的算子学习正题：</strong></span></div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat">&nbsp;</div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__repeat"><strong><span style="font-size: 18px"><strong><span style="font-size: 18px"><span style="font-size: 18px">4.<span style="font-size: 18px">霍夫变换直线检测算子<strong>hough_lines</strong>(<a href="#RegionIn" rel="noopener nofollow"><em>RegionIn</em></a>&nbsp;: :&nbsp;<a href="#AngleResolution" rel="noopener nofollow"><em>AngleResolution</em></a>,&nbsp;<a href="#Threshold" rel="noopener nofollow"><em>Threshold</em></a>,&nbsp;<a href="#AngleGap" rel="noopener nofollow"><em>AngleGap</em></a>,&nbsp;<a href="#DistGap" rel="noopener nofollow"><em>DistGap</em></a>&nbsp;:&nbsp;<a href="#Angle" rel="noopener nofollow"><em>Angle</em></a>,&nbsp;<a href="#Dist" rel="noopener nofollow"><em>Dist</em></a>)详解（像刚才的车道线的提取就可以用这个函数来实现）：</span></span></span></strong></span></strong></div>
<div class="agent-chat__toolbar__item agent-chat__toolbar__share"><span class="yb-icon iconfont-yb icon-yb-share" style="font-size: 18px">&nbsp;</span></div>

</div>

</div>

</div>
<h4><span style="font-size: 16px">示例1：基础直线检测</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">*<span style="color: rgba(0, 0, 0, 1)"> 读取图像并提取边缘
read_image(Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">road.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
edges_sub_pix(Image, Edges, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">canny</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1.5</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span><span style="color: rgba(0, 0, 0, 1)">)
threshold(Edges, RegionEdges, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 霍夫变换检测直线
hough_lines(RegionEdges, </span><span style="color: rgba(128, 0, 128, 1)">0.02</span>, <span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">0.1</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">, Angle, Dist)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 绘制检测到的直线
gen_region_hline(RegionLines, Angle, Dist)
dev_display(Image)
dev_display(RegionLines)</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">hough_lines(RegionIn : : AngleResolution, Threshold, AngleGap, DistGap : Angle, Dist)</span></pre>
</div>
<ul>
<li><span style="font-size: 16px"><strong>功能</strong>：使用霍夫变换（Hough Transform）从二值区域中检测直线，返回直线的角度和距离参数。</span></li>
<li><span style="font-size: 16px">​<strong>输入/输出</strong>：</span>
<ul>
<li>​<strong>输入</strong>：
<ul>
<li><code>RegionIn</code>：输入区域（通常为边缘检测后的二值图像）。</li>
</ul>
</li>
<li>​<strong>参数</strong>：
<ul>
<li><code>AngleResolution</code>：角度分辨率（控制角度检测精度）。</li>
<li><code>Threshold</code>：累加器阈值（决定直线的最小支持点数）。</li>
<li><code>AngleGap</code>：角度合并阈值（合并相*角度的直线）。</li>
<li><code>DistGap</code>：距离合并阈值（合并相*距离的直线）。</li>
</ul>
</li>
<li>​<strong>输出</strong>：
<ul>
<li><code>Angle</code>：检测到的直线的角度（弧度制，范围：-π/2 ~ π/2）。</li>
<li><code>Dist</code>：直线到原点的距离（像素单位，基于极坐标公式：<code>r = x*cosθ + y*sinθ</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span style="font-size: 16px"><strong>参数详解</strong></span></h3>
<h4><span style="font-size: 16px">1. ​**<code>AngleResolution</code>（角度分辨率）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：定义霍夫空间中角度θ的步长（分辨率）。</span></li>
<li><span style="font-size: 16px">​<strong>取值范围</strong>：通常为 <code>0.01</code> ~ <code>1.0</code>（弧度）。</span></li>
<li><span style="font-size: 16px">​<strong>影响</strong>：</span>
<ul>
<li>​<strong>小值</strong>​（如 <code>0.01</code>）：角度划分精细，检测精度高，但计算量大。</li>
<li>​<strong>大值</strong>​（如 <code>0.1</code>）：角度划分粗糙，计算速度快，可能漏检细节。</li>
</ul>
</li>
</ul>
<h4><span style="font-size: 16px">2. ​**<code>Threshold</code>（累加器阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：直线在霍夫空间中的累加器值需超过此阈值才被保留。</span></li>
<li><span style="font-size: 16px">​<strong>示例</strong>：​<strong>调优建议</strong>：根据图像中边缘点密度调整，避免漏检或噪声干扰。</span>
<ul>
<li><code>Threshold=50</code>：直线至少需要50个边缘点支持。</li>
</ul>
</li>
<li></li>
</ul>
<h4><span style="font-size: 16px">3. ​**<code>AngleGap</code>（角度合并阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：合并角度差小于此值的相邻直线。</span></li>
<li><span style="font-size: 16px">​<strong>单位</strong>：弧度。</span></li>
<li><span style="font-size: 16px">​<strong>示例</strong>：</span>
<ul>
<li><code>AngleGap=0.05</code>（约2.86°）：若两条直线角度差小于0.05弧度，视为同一方向。</li>
</ul>
</li>
</ul>
<h4><span style="font-size: 16px">4. ​**<code>DistGap</code>（距离合并阈值）​**</span></h4>
<ul>
<li><span style="font-size: 16px">​<strong>作用</strong>：合并距离差小于此值的相邻直线。</span></li>
<li><span style="font-size: 16px">​<strong>单位</strong>：像素。</span></li>
<li><span style="font-size: 16px">​<strong>示例</strong>：</span>
<ul>
<li><code>DistGap=10</code>：若两条直线距离差小于10像素，视为同一位置。</li>
</ul>
</li>
</ul>
<h4><span style="font-size: 16px">示例2：合并相*直线</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">* 合并角度差&lt;<span style="color: rgba(128, 0, 128, 1)">5</span>°、距离差&lt;<span style="color: rgba(0, 0, 0, 1)">20像素的直线
AngleGap :</span>= radians(<span style="color: rgba(128, 0, 128, 1)">5</span>)  *<span style="color: rgba(0, 0, 0, 1)"> 5度转弧度
DistGap :</span>= <span style="color: rgba(128, 0, 128, 1)">20</span><span style="color: rgba(0, 0, 0, 1)">
hough_lines(RegionEdges, </span><span style="color: rgba(128, 0, 128, 1)">0.02</span>, <span style="color: rgba(128, 0, 128, 1)">30</span>, AngleGap, DistGap, Angle, Dist)</span></pre>
</div>
<ol>
<li>
<p><strong>车道线检测</strong>​（如 <code>autobahn.hdev</code>）：</p>
<ul>
<li>​<strong>参数建议</strong>：<code>AngleResolution=0.02</code>, <code>Threshold=50</code>, <code>AngleGap=0.1</code>, <code>DistGap=15</code>。</li>
<li>​<strong>说明</strong>：合并相*的水*和倾斜车道线。</li>
</ul>
</li>
<li>
<p>​<strong>工业零件几何检测</strong>：</p>
<ul>
<li>​<strong>参数建议</strong>：<code>AngleResolution=0.01</code>, <code>Threshold=100</code>, <code>AngleGap=0.05</code>, <code>DistGap=5</code>。</li>
<li>​<strong>说明</strong>：高精度检测零件边缘的直线特征。</li>
</ul>
</li>
<li>
<p>​<strong>文档表格线提取</strong>：</p>
<ul>
<li>​<strong>参数建议</strong>：<code>AngleResolution=0.05</code>, <code>Threshold=30</code>, <code>AngleGap=0.2</code>, <code>DistGap=10</code>。</li>
<li>​<strong>说明</strong>：快速提取水*和垂直线。</li>
</ul>
</li>
</ol>
<h3><span style="font-size: 16px"><strong>参数调优策略</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>问题现象</strong></span></th><th><span style="font-size: 16px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px">检测到过多短线段</span></td>
<td><span style="font-size: 16px">提高 <code>Threshold</code>，减少噪声影响</span></td>
</tr>
<tr>
<td><span style="font-size: 16px">漏检长直线</span></td>
<td><span style="font-size: 16px">降低 <code>Threshold</code>，增大 <code>AngleGap</code></span></td>
</tr>
<tr>
<td><span style="font-size: 16px">直线断裂</span></td>
<td><span style="font-size: 16px">合并参数（<code>AngleGap</code>和<code>DistGap</code>）设置过小，适当增大</span></td>
</tr>
<tr>
<td><span style="font-size: 16px">计算速度慢</span></td>
<td><span style="font-size: 16px">增大 <code>AngleResolution</code>，降低精度以换取速度</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>关键注意事项</strong></span></h3>
<ol>
<li>
<p>​<strong>输入区域预处理</strong>：</p>
<ul>
<li>输入 <code>RegionIn</code> 应为二值化的边缘区域，建议先用 <code>edges_sub_pix</code> 或 <code>sobel_amp</code> 提取边缘。</li>
</ul>
</li>
<li>
<p>​<strong>极坐标系原点</strong>：</p>
<ul>
<li>原点默认为图像左上角（Halcon坐标系），距离 <code>Dist</code> 是直线到原点的极坐标距离。</li>
</ul>
</li>
<li>
<p>​<strong>角度范围</strong>：</p>
<ul>
<li>输出角度 <code>Angle</code> 范围为 <code>-π/2</code> 到 <code>π/2</code>，对应直线方向（与x轴夹角）。</li>
</ul>
</li>
</ol>
<h3><span style="font-size: 16px"><strong>与其他直线检测方法的对比</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 16px">​<strong>方法</strong></span></th><th><span style="font-size: 16px">​<strong>优点</strong></span></th><th><span style="font-size: 16px">​<strong>缺点</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 16px"><code>hough_lines</code></span></td>
<td><span style="font-size: 16px">直接输出参数，支持合并相*直线</span></td>
<td><span style="font-size: 16px">计算量较大，需精细调参</span></td>
</tr>
<tr>
<td><span style="font-size: 16px"><code>fit_line_contour_xld</code></span></td>
<td><span style="font-size: 16px">基于轮廓拟合，精度高</span></td>
<td><span style="font-size: 16px">需先提取边缘轮廓，无法合并直线</span></td>
</tr>
<tr>
<td><span style="font-size: 16px">深度学习（如HoughNet）</span></td>
<td><span style="font-size: 16px">鲁棒性强，适应复杂场景</span></td>
<td><span style="font-size: 16px">需要大量训练数据和算力</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 16px"><strong>总结</strong></span></h3>
<p><span style="font-size: 16px"><code>hough_lines</code> 是 Halcon 中基于霍夫变换的经典直线检测算子，通过调节角度分辨率、阈值和合并参数，可适应不同场景的直线检测需求。其核心优势在于直接输出直线的极坐标参数，便于后续几何分析。实际应用中需结合预处理（边缘检测）和后处理（参数合并）以优化结果，适用于工业检测、自动驾驶和文档分析等领域。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">OK，接下来在看个案例道路图像的边缘提取edge_segments.hdev：</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402155917069-1061571511.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;</span></p>
<p><span style="font-size: 16px">图像：</span></p>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402155955065-384640002.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;效果图：</span></p>
<p><span style="font-size: 16px"><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402160011284-1247598939.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 16px">&nbsp;</span></p>
<p><span style="font-size: 16px">实例代码：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 16px">*<span style="color: rgba(0, 0, 0, 1)"> 关闭窗口自动更新以提升执行速度
dev_update_off ()

</span>*<span style="color: rgba(0, 0, 0, 1)"> 关闭所有已打开的图形窗口
dev_close_window ()

</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 步骤1: 读取图像并初始化窗口
</span>* ​****************************
* 读取图像文件<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mreut</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mreut</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 获取图像尺寸
get_image_size (Image, Width, Height)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 根据图像尺寸自适应打开显示窗口
dev_open_window_fit_image (Image, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, Width, Height, WindowID)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置窗口字体为等宽字体，字号12
set_display_font (WindowID, </span><span style="color: rgba(128, 0, 128, 1)">12</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">mono</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置绘图模式为仅绘制区域边界（不填充）
dev_set_draw (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">margin</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 设置绘图线宽为3像素
dev_set_line_width (</span><span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示原始图像
dev_display (Image)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示继续提示信息（黑底白字）
disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 暂停执行，等待用户按键
stop ()


</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 步骤2: 边缘检测与滤波处理
</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 使用Lanser2滤波器进行边缘检测
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lanser2</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)"> : 滤波器类型（*衡精度与抗噪性）
</span>*   <span style="color: rgba(128, 0, 128, 1)">0.5</span><span style="color: rgba(0, 0, 0, 1)">       : *滑系数（Alpha值）
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nms</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">     : 非极大值抑制
</span>*   <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span>    : 滞后阈值（Low=<span style="color: rgba(128, 0, 128, 1)">20</span>, High=<span style="color: rgba(128, 0, 128, 1)">40</span><span style="color: rgba(0, 0, 0, 1)">）
edges_image (Image, ImaAmp, ImaDir, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">lanser2</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nms</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">40</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示梯度幅值图像
dev_display (ImaAmp)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示继续提示信息
disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 暂停执行
stop ()


</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 步骤3: 阈值分割与连通域提取
</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 对梯度幅值图像进行阈值分割（保留所有非零像素）
threshold (ImaAmp, Region, </span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 分割连通域（每个边缘段为一个独立区域）
connection (Region, ConnectedRegions)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 清空窗口并设置彩色显示模式
dev_clear_window ()
dev_set_colored (</span><span style="color: rgba(128, 0, 128, 1)">12</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示所有连通域（不同颜色区分）
dev_display (ConnectedRegions)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示继续提示信息
disp_continue_message (WindowID, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 暂停执行
stop ()


</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 步骤4: 边缘分段处理与XLD生成
</span>* ​****************************
*<span style="color: rgba(0, 0, 0, 1)"> 清空窗口准备显示最终结果
dev_clear_window ()

</span>*<span style="color: rgba(0, 0, 0, 1)"> 计算连通域总数
count_obj (ConnectedRegions, Number)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 创建空对象容器存储XLD轮廓
gen_empty_obj (XLDContours)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 遍历所有连通域
</span><span style="color: rgba(0, 0, 255, 1)">for</span> i := <span style="color: rgba(128, 0, 128, 1)">1</span> to Number by <span style="color: rgba(128, 0, 128, 1)">1</span>
    *<span style="color: rgba(0, 0, 0, 1)"> 选择第i个连通域
    select_obj (ConnectedRegions, SingleEdgeObject, i)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 将骨架线分割为独立线段
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
    </span>*   <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)"> : 最小线段长度（短于2像素的线段被丢弃）
    split_skeleton_lines (SingleEdgeObject, </span><span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">, BeginRow, BeginCol, EndRow, EndCol)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 遍历当前连通域分割出的所有线段
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> k := <span style="color: rgba(128, 0, 128, 1)">0</span> to |BeginRow| - <span style="color: rgba(128, 0, 128, 1)">1</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
        *<span style="color: rgba(0, 0, 0, 1)"> 根据起点和终点坐标生成XLD线段
        gen_contour_polygon_xld (Contour, [BeginRow[k],EndRow[k]], [BeginCol[k],EndCol[k]])
        
        </span>*<span style="color: rgba(0, 0, 0, 1)"> 将线段添加到容器中
        concat_obj (XLDContours, Contour, XLDContours)
    endfor
endfor

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示最终生成的XLD轮廓集合
dev_display (XLDContours)</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">上面传统的主要的边缘提取都在halcon的官方示例里了，有兴趣的话还可以学习一下halcon深度学习示例里面的边缘提取segment_edges_deep_learning.hdev（把ROI区域设置好，提取参数设置好的话，提取起来也不错的）：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402162750263-571322822.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px">原图提取边缘：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402162902007-1752664563.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402163110674-519305899.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px">&nbsp;添加噪声干扰图后再提取边缘：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402163020364-1197281092.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202504/1251892-20250402163049779-233628316.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    转发和使用本文，请注明作者信息和原文地址---本文原作者为aircraft

---大家好我是徐飞机，有没有大佬们的公司招c++开发/图像处理/opengl/opencv/halcon实习的啊，带上我一个呗QAQ。。。hhhhhh  想要免费获取前端，后端，c/c++,matlab，Python，opencv，机器学习，深度学习，安卓，java，等等全套视频教程请关注机器视觉开发公众号，转发集赞28即可百度云获得hhhhhhhh
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23805461546527779" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-02 16:34">2025-04-02 16:33</span>&nbsp;
<a href="https://www.cnblogs.com/DOMLX">aircraft</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18806214" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18806214);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18806214', targetLink: 'https://www.cnblogs.com/DOMLX/p/18806214', title: 'halcon 入门教程（三） 边缘检测' })">举报</a>
</div>
        