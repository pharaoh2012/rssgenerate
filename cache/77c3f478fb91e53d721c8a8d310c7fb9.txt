<!----> <meta itemprop="headline" content="作为一名前端架构师，我是怎么搭建前端工程化滴"> <meta itemprop="keywords" content="前端,架构"> <meta itemprop="datePublished" content="2025-02-07T02:50:10.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="至简简"> <meta itemprop="url" content="https://juejin.cn/user/4212984286819384"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-fcbde74a="">
            作为一名前端架构师，我是怎么搭建前端工程化滴
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-fcbde74a=""><div class="author-info-box" data-v-fcbde74a=""><div class="author-name" data-v-fcbde74a=""><a href="/user/4212984286819384/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-fcbde74a=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    至简简
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-fcbde74a=""><time datetime="2025-02-07T02:50:10.000Z" title="Fri Feb 07 2025 02:50:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-fcbde74a="">
                    2025-02-07
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-fcbde74a=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-fcbde74a=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-fcbde74a=""></circle></svg> <span class="views-count" data-v-fcbde74a="">
                    13,112
                  </span> <span class="read-time" data-v-fcbde74a=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-fcbde74a=""><rect width="16" height="16" fill="none" data-v-fcbde74a=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-fcbde74a=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-fcbde74a=""></path></svg>
                    阅读1小时+
                  </span> <!----></div></div> <div style="flex:1;" data-v-fcbde74a=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-fcbde74a=""><div class="article-viewer markdown-body result"><p>笔者作为公司的一名前端架构师，先后经历过各种大中小型前端项目，将自己的经验总结如下，从空文件到项目上线到后续维护。欢迎各位前端小伙伴Review，有不对地方请指出，互相学习</p>
<h2 data-id="heading-0">编码规范</h2>
<p>开篇最重要的不是选用前端框架，也不是选用UI组件库，而是最重要的 JavaScript 编码规范。</p>
<p><strong>编码规范</strong>是指对编写代码的一组规则和约定，主要目的是确保团队中的每个成员都遵循一致的编程风格，减少代码中的差异，提高代码的可读性和可维护性。它通常包括代码格式化、命名约定、代码结构、注释等方面的规定</p>
<p>在技术生涯中，笔者一直认为编码规范非常重要，代码首先是写给人看的，遵循合理的代码规范让代码便于阅读和修改。</p>
<p>JS社区对前端项目中合理的代码规范进行归纳总结，下面是比较受欢迎的两份JS代码规范：</p>
<h3 data-id="heading-1">Airbnb JavaScript Style Guide</h3>
<p><strong>Airbnb JavaScript Style Guide</strong> 是一个广泛使用的、针对 JavaScript 编程语言的编码规范，旨在帮助开发人员编写一致、易读且可维护的 JavaScript 代码。这个风格指南由 Airbnb 团队创建，并被许多开发者和公司采纳。它涵盖了 JavaScript 编程的各个方面，包括语法、代码风格、最佳实践等。</p>
<p>这份规范包含<strong>代码风格</strong>、<strong>语法与结构</strong>、<strong>命令约定</strong>、<strong>对象与数组</strong>、<strong>错误处理</strong>、<strong>异步代码</strong>和其他等</p>
<h3 data-id="heading-2">Google JavaScript Style Guide</h3>
<p><strong>Google JavaScript Style Guide</strong> 是由 Google 提供的一套 JavaScript 编程规范和最佳实践指南，旨在帮助开发者编写一致、清晰和高质量的 JavaScript 代码。它为 JavaScript 开发者提供了统一的编码风格，以确保代码的一致性、可读性和可维护性。Google 的这份 JavaScript 风格指南不仅适用于前端开发，还适用于 Node.js 等后端开发</p>
<p><strong>Google JavaScript Style Guide</strong> 比较简洁，旨在提供实用的规则，以帮助开发者更好地编写符合最佳实践的代码。它的主要目标是确保团队合作时，代码风格的一致性</p>
<p>笔者是强烈推荐将这两份编码规范纳入公司的开发规范中，让团队中的小伙伴熟悉规范里的内容，非常有助于之后的协作</p>
<h2 data-id="heading-3">npm/Yarn/pnpm</h2>
<p>上面说完编码规范，现在说说2025年了，现代化前端有哪些变化？在JQ流行的时候，讲究JQ一把梭，JQ可以搞点一切，但是后来开始流行前端工程化，前端圈大变天。</p>
<p>说到前端工程化，首先离不开 Node.js 和包管理器。</p>
<ul>
<li>
<p><strong>Node.js</strong> 是一个基于 <strong>Chrome V8 引擎</strong> 的开源 JavaScript 运行时环境，允许开发者在服务器端运行 JavaScript。它使得 JavaScript 从浏览器端的客户端语言，扩展到服务器端的应用开发，具有非阻塞、事件驱动的特性</p>
</li>
<li>
<p><strong>包管理器</strong>。<code>npm</code>、<code>Yarn</code> 和 <code>pnpm</code> 都是 JavaScript 包管理工具，它们的主要作用是帮助开发者管理项目中的依赖包。通过这些工具，开发者可以轻松地安装、升级、删除和管理项目所需的各种外部库或模块。</p>
</li>
</ul>
<h3 data-id="heading-4">npm</h3>
<p><code>npm</code> 是 Node.js 默认的包管理工具，只要安装 Node.js，就包含对应版本的 npm。它允许开发者下载和管理 JavaScript 库、工具等依赖。它通过 <code>package.json</code> 文件来记录项目的依赖关系。</p>
<p><code>npm</code> 作为 Node.js 默认的包管理工具，<code>npm</code> 使用广泛，生态系统成熟。</p>
<h3 data-id="heading-5">Yarn</h3>
<p><code>Yarn</code> 是 Facebook 提供的一个 JavaScript 包管理工具，旨在解决 <code>npm</code> 的一些问题，特别是关于速度和一致性的问题。它与 <code>npm</code> 兼容，但提供了一些额外的功能和优化。</p>
<p><code>Yarn</code> 通过缓存和并行化安装等方式，<code>Yarn</code> 的安装速度通常比 <code>npm</code> 更快。<code>yarn.lock</code> 确保所有开发者都安装相同版本的依赖，避免了由于依赖版本不同而导致的潜在问题。如果之前安装过某个依赖，Yarn 可以从本地缓存中安装，而不需要重新从网络上下载。</p>
<h3 data-id="heading-6">pnpm</h3>
<p><code>pnpm</code> 是一种更高效的 JavaScript 包管理工具，旨在解决 <code>npm</code> 和 <code>Yarn</code> 在处理大量依赖时的性能瓶颈问题。<code>pnpm</code> 通过优化存储和管理方式来提高包管理效率。</p>
<p><code>pnpm</code> 通过硬链接和全局缓存，<code>pnpm</code> 极大地减少了磁盘占用，尤其是在多个项目共享相同依赖的情况下。安装依赖时，不会为每个项目创建独立的依赖副本，而是通过共享缓存来节省空间。</p>
<p><code>pnpm</code> 的优点有</p>
<ul>
<li><strong>高效的磁盘使用</strong>：<code>pnpm</code> 使用硬链接技术，使得多个项目可以共享相同的依赖，减少了磁盘空间的浪费。</li>
<li><strong>性能优越</strong>：<code>pnpm</code> 对大量依赖的处理效率非常高，能够在不同的项目间重用依赖，减少冗余的下载和安装时间。</li>
<li><strong>更严格的依赖管理</strong>：<code>pnpm</code> 在安装依赖时采用严格的隔离策略，防止出现隐式的依赖，确保每个包只有显式声明的依赖。</li>
</ul>
<h3 data-id="heading-7"><strong>总结对比</strong></h3>















































<table><thead><tr><th>特性</th><th>npm</th><th>Yarn</th><th>pnpm</th></tr></thead><tbody><tr><td>安装速度</td><td>较慢（但近年有改善）</td><td>更快（并行安装、缓存机制）</td><td>非常快（高效缓存和硬链接技术）</td></tr><tr><td>依赖锁定</td><td>使用 <code>package-lock.json</code></td><td>使用 <code>yarn.lock</code></td><td>使用 <code>pnpm-lock.yaml</code></td></tr><tr><td>磁盘占用</td><td>较高，重复依赖存储</td><td>较高，类似于 npm</td><td>较低，使用硬链接共享依赖</td></tr><tr><td>离线支持</td><td>较弱</td><td>良好（缓存机制）</td><td>非常好（高效的离线安装支持）</td></tr><tr><td>兼容性</td><td>与 Node.js 和 NPM 仓库完全兼容</td><td>与 NPM 基本兼容</td><td>兼容 NPM 和 Yarn 项目，但使用自己的存储和依赖解析方式</td></tr><tr><td>社区和生态</td><td>最大的 JavaScript 社区，生态非常成熟</td><td>由 Facebook 维护，广泛使用</td><td>新兴工具，正在获得越来越多的关注</td></tr></tbody></table>
<p>这些工具各有优缺点，具体使用哪一个取决于你的项目需求、团队习惯以及性能需求。笔者常用 <code>Yarn</code></p>
<h2 data-id="heading-8">Webpack/Vite</h2>
<p>说到前端工程化，自然离不开构建工具。Webpack 和 Vite 都是现代前端开发中常用的构建工具，主要用于打包 JavaScript 代码、CSS、图片等静态资源，并优化前端应用的构建和开发流程。它们的主要作用是提升开发效率、构建速度、代码优化等，但它们在实现方式和功能上有一些显著的区别。</p>
<p>Webpack是老牌的构建工具，而Vite是后起之秀，两个构建工具在原理上不一样</p>
<h3 data-id="heading-9">Webpack</h3>
<p><strong>Webpack</strong> 是一个模块打包工具，可以将应用中的各种资源（JS、CSS、图片、字体等）都看作模块，然后将它们打包成一个或多个最终文件。它提供了强大的插件和加载器机制，使得它在前端构建工具中非常灵活和强大。</p>
<p>主要功能包括不限于</p>
<ol>
<li><strong>模块打包</strong>：将 JS、CSS、图片等资源打包成最终的静态文件。</li>
<li><strong>代码拆分</strong>：将大文件拆分成多个小文件，优化性能。</li>
<li><strong>静态资源处理</strong>：通过各种 Loader 处理 CSS、图片、字体等静态资源。</li>
<li><strong>热更新</strong>：提供开发模式下的热更新（HMR），加速开发过程。</li>
</ol>
<p>Webpack的功能强大，生态丰富，适应多种需求。支持多种插件，扩展性强。但是Webpack 的配置文件通常比较复杂，需要一定的学习成本，学习曲线比较陡，另外构建速度较慢，尤其在大型项目中，构建速度可能较慢。</p>
<h3 data-id="heading-10">Vite</h3>
<p><strong>Vite</strong> 是一个现代化的构建工具，设计理念是快速开发和高效的构建，它的核心优势是采用了原生 ES 模块（ESM）作为开发模式，并且利用浏览器对 ESM 的支持，来避免传统打包工具中常见的冗长的打包时间。</p>
<p>主要功能包括不限于</p>
<ol>
<li><strong>开发时快速启动</strong>：Vite 利用原生 ES 模块，实现快速启动，几乎是即时热更新。</li>
<li><strong>打包优化</strong>：使用 Rollup 作为生产环境下的打包工具，构建速度快且优化效果好。</li>
<li><strong>模块热更新（HMR）</strong> ：比 Webpack 更加快速和精确，不需要全局重载。</li>
</ol>
<p>Vite的开发环境启动速度极快，热更新响应非常快。默认有许多合理的配置，开发者无需进行复杂的配置，由于利用原生 ESM，无需编译整个项目，在开发模式下不需要进行打包。Vite是新工具，整个生态不如Webpack 丰富，某些插件和集成可能不如 Webpack 完备。生产模式下利用Rollup对项目打包，可能会带来某些问题</p>
<p>以下是 <strong>Vite</strong> 和 <strong>Webpack</strong> 的区别对比表：</p>























































<table><thead><tr><th>特性</th><th><strong>Vite</strong></th><th><strong>Webpack</strong></th></tr></thead><tbody><tr><td><strong>启动速度</strong></td><td>利用原生 ES 模块实现即时启动，启动速度极快</td><td>需要全量打包，启动速度较慢，特别是大型项目</td></tr><tr><td><strong>热更新</strong></td><td>极快的热更新，基于 ES 模块的增量更新</td><td>热更新速度较慢，需要重建整个模块</td></tr><tr><td><strong>打包过程</strong></td><td>仅在生产环境下使用 Rollup 进行打包</td><td>开发环境也进行打包，速度较慢</td></tr><tr><td><strong>配置</strong></td><td>配置简洁，默认配置能满足大部分需求</td><td>配置复杂，需要对插件和 Loader 有较多了解</td></tr><tr><td><strong>生态和兼容性</strong></td><td>生态逐步扩展，但仍较年轻</td><td>成熟的插件生态，几乎支持所有前端框架和工具</td></tr><tr><td><strong>生产环境打包</strong></td><td>使用 Rollup 打包，优化较好，速度快</td><td>使用 Webpack 打包，打包速度较慢，且配置复杂</td></tr><tr><td><strong>支持的功能</strong></td><td>提供对现代框架的开箱即用支持，适合新项目</td><td>支持更广泛的功能，适合传统的、复杂的项目</td></tr><tr><td><strong>支持的模块系统</strong></td><td>基于原生 ES 模块进行开发</td><td>支持 CommonJS 和 ES 模块系统，兼容性更好</td></tr><tr><td><strong>适用场景</strong></td><td>适用于现代项目和快速开发</td><td>适合大型项目、复杂的构建需求和老旧项目</td></tr></tbody></table>
<h3 data-id="heading-11"><strong>总结</strong>：</h3>
<ul>
<li><strong>Vite</strong> 在启动速度和开发体验上占优，适合现代项目和快速开发，但相对来说生态和插件支持还在不断完善中。</li>
<li><strong>Webpack</strong> 在生态成熟度、配置灵活性和处理大型项目的能力上更强，适合需要高度定制和复杂打包需求的项目。</li>
</ul>
<p>构建工具在前端工程化中非常重要，必须掌握如何使用构建工具。Webpack强调将所有模块打包成bundle文件，而Vite强调less bundle，在开发模式下直接利用浏览器加载ESM模块。这两个构建工具各有优缺点，在实际项目中都有应用场景。</p>
<p>如果你是一个正在构建新项目的开发者，尤其是小到中型项目，Vite 无疑是一个非常值得考虑的选择。对于需要大量定制化或者已有 Webpack 配置的大型项目，Webpack 仍然是一个非常强大的工具。</p>
<h2 data-id="heading-12">React/Vue/Angular</h2>
<p>标题写了Angular，但是Angular在国内用的比较少，就不怎么谈论。重点看看React和Vue两个现代化前端框架</p>
<p><strong>React</strong> 和 <strong>Vue</strong> 都是流行的前端 JavaScript 框架/库，用于构建用户界面，尤其是单页面应用（SPA）。它们都解决了前端开发中的组件化、状态管理、响应式渲染等问题，并且都是当今前端开发的重要工具。不过，React 和 Vue 在设计哲学、功能特性、开发体验等方面有一些显著的差异。</p>
<h3 data-id="heading-13">React</h3>
<p><strong>React</strong> 是由 Facebook 开发并维护的一个开源 JavaScript 库，主要用于构建用户界面，特别是在处理复杂的单页面应用时。它的核心概念是“组件化”和“声明式编程”，让开发者可以将 UI 分成小的、可重用的组件。</p>
<p>主要特点：</p>
<ol>
<li><strong>组件化</strong>：React 的应用是由组件构成的，每个组件是一个独立的、封装的 UI 单元。组件可以通过 props 和 state 来管理数据和行为。</li>
<li><strong>虚拟 DOM</strong>：React 使用虚拟 DOM 来优化界面更新的性能，减少了不必要的 DOM 操作，提高渲染效率。</li>
<li><strong>声明式 UI</strong>：React 的 UI 是声明式的，开发者描述想要的 UI，React 会根据数据的变化自动更新视图。</li>
<li><strong>单向数据流</strong>：React 使用单向数据流，组件的数据通过 props 传递，数据更新通过 state 来触发视图更新。</li>
</ol>
<h3 data-id="heading-14">优点：</h3>
<ul>
<li><strong>灵活性高</strong>：React 是一个库，而不是框架，所以它只关注视图层，开发者可以自由选择如何组织其他部分（如路由、状态管理）。</li>
<li><strong>社区支持强</strong>：React 拥有庞大的社区和丰富的生态系统，包括大量的第三方库、插件和工具。</li>
<li><strong>React Native</strong>：React 也可以用于开发原生移动应用，React Native 使得 Web 开发者能够快速上手移动应用开发。</li>
</ul>
<h3 data-id="heading-15">缺点：</h3>
<ul>
<li><strong>学习曲线</strong>：虽然 React 核心 API 简单，但要掌握 React 生态中的各种工具和库（如 React Router、Redux、Context API 等）可能需要一定的时间。</li>
<li><strong>繁琐的 JSX</strong>：React 使用 JSX 语法，这使得 HTML 和 JavaScript 混合在一起，可能对初学者不太友好。</li>
</ul>
<h3 data-id="heading-16">Vue</h3>
<p><strong>Vue</strong> 是由前 Google 工程师尤雨溪（Evan You）开发的一个渐进式 JavaScript 框架。Vue 的设计目标是尽可能简单和灵活，特别注重开发体验。Vue 的学习曲线相对较低，非常适合入门级开发者。</p>
<p>主要特点：</p>
<ol>
<li><strong>双向数据绑定</strong>：Vue 提供了双向数据绑定功能，可以让数据的变化自动反映到视图层，反之亦然。这种特性借鉴了 Angular 的做法。</li>
<li><strong>组件化</strong>：和 React 一样，Vue 也采用组件化开发，开发者可以将 UI 拆分成多个小的组件。</li>
<li><strong>响应式系统</strong>：Vue 内置响应式系统，当数据发生变化时，视图会自动更新。这使得开发者不需要手动管理 DOM 更新。</li>
<li><strong>渐进式框架</strong>：Vue 是一个渐进式框架，可以根据需要逐步引入不同的功能模块。开发者可以选择只使用它的一部分（如 Vue Router、Vuex）或者使用完整的 Vue 全家桶。</li>
</ol>
<h3 data-id="heading-17">优点：</h3>
<ul>
<li><strong>开发体验优秀</strong>：Vue 的文档非常详细，学习曲线相对较平缓，适合初学者。</li>
<li><strong>内置的工具链</strong>：Vue 提供了 Vue Router 和 Vuex 等内置工具，开发者不需要依赖第三方库即可构建完整的应用。</li>
<li><strong>响应式数据</strong>：Vue 的响应式系统非常高效，开发者只需专注于数据和逻辑，框架会自动处理 UI 更新。</li>
<li><strong>模板语法简洁</strong>：Vue 使用类似 HTML 的模板语法，较为直观和易懂。</li>
</ul>
<h3 data-id="heading-18">缺点：</h3>
<ul>
<li><strong>生态较小</strong>：虽然 Vue 的社区和生态不断壮大，但相比 React，其生态规模仍然较小，某些第三方库和工具可能没有 React 那么丰富。</li>
<li><strong>灵活性略低</strong>：Vue 是一个更为框架化的工具，提供了很多默认的配置和功能，有时可能让开发者感到约束。</li>
</ul>
<h3 data-id="heading-19">主要区别</h3>























































<table><thead><tr><th>特性</th><th><strong>React</strong></th><th><strong>Vue</strong></th></tr></thead><tbody><tr><td><strong>框架 vs 库</strong></td><td>React 是一个 UI 库，专注于视图层</td><td>Vue 是一个渐进式框架，包含更多功能模块</td></tr><tr><td><strong>数据绑定</strong></td><td>单向数据流（props 和 state）</td><td>双向数据绑定（v-model）</td></tr><tr><td><strong>学习曲线</strong></td><td>学习曲线较陡，需要学习很多工具和库</td><td>学习曲线平缓，更易上手</td></tr><tr><td><strong>灵活性</strong></td><td>非常灵活，开发者可以自由选择工具链</td><td>提供了更多默认配置和工具，灵活性较低</td></tr><tr><td><strong>虚拟 DOM</strong></td><td>使用虚拟 DOM 优化性能</td><td>也使用虚拟 DOM 优化性能</td></tr><tr><td><strong>模板语法</strong></td><td>JSX（JavaScript 和 HTML 混合）</td><td>传统模板语法，HTML 和 JavaScript 分离</td></tr><tr><td><strong>生态和社区支持</strong></td><td>社区庞大，插件和第三方库丰富</td><td>社区规模较小，生态逐步发展</td></tr><tr><td><strong>移动开发</strong></td><td>React Native 支持跨平台开发</td><td>Vue 支持跨平台开发，但生态不如 React</td></tr><tr><td><strong>状态管理</strong></td><td>使用 Redux 或 Context API</td><td>使用 Vuex 状态管理</td></tr></tbody></table>
<h3 data-id="heading-20">总结</h3>
<ul>
<li><strong>React</strong>：更适合那些希望有极高自由度和灵活性的开发者，适合大规模应用、需要可重用组件以及高性能的项目。React 的生态成熟，适合那些需要大量定制化的项目。</li>
<li><strong>Vue</strong>：更适合初学者以及追求简单、快速开发的项目，Vue 提供了一个更为完整的框架，内置了很多开发所需的功能模块。Vue 的开发体验非常好，非常适合中小型项目。</li>
</ul>
<p>如果你是初学者，Vue 可能是一个比较容易上手的选择。如果你追求灵活性和想要更广泛的社区支持，React 会是一个很好的选择。</p>
<p>站在个人角度，我不喜欢说那个框架比另一个框架好，项目适合用那个框架就用那个框架！</p>
<h2 data-id="heading-21">React/Vue相关生态</h2>
<p>说到React和Vue框架，就离不开配套使用其他第三方依赖。React 和 Vue 的生态系统是指它们周围围绕着的一系列工具、库、插件、框架和社区资源，旨在提升开发效率、提供扩展功能，并让开发者能够更加高效地构建和管理应用。这些生态系统的成熟度和广度对开发者的选择有很大的影响。</p>
<h3 data-id="heading-22">React 生态</h3>
<p>React 的生态非常成熟、庞大，涵盖了开发过程中的方方面面。由于 React 是一个专注于视图层的库，它通常需要其他工具和库来配合使用。</p>
<h3 data-id="heading-23">1. <strong>状态管理</strong></h3>
<ul>
<li><strong>Redux</strong>：React 最经典的状态管理库，用于全局状态的管理，尤其适用于大型应用。通过中心化存储和纯函数来管理应用状态。</li>
<li><strong>React Context API</strong>：React 官方提供的轻量级状态管理方式，适用于小型应用或局部状态管理。</li>
<li><strong>Recoil</strong>：由 Facebook 提供的轻量级状态管理库，特别适合处理 React 的复杂状态。</li>
<li><strong>MobX</strong>：一个响应式的状态管理库，通过自动追踪状态和更新视图，简化了复杂状态的管理。</li>
</ul>
<h3 data-id="heading-24">2. <strong>路由</strong></h3>
<ul>
<li><strong>React Router</strong>：React 最常用的路由库，支持动态路由、嵌套路由、懒加载等功能，是 React 项目中几乎必不可少的工具。</li>
</ul>
<h3 data-id="heading-25">3. <strong>表单处理</strong></h3>
<ul>
<li><strong>Formik</strong>：一个高效的 React 表单库，用于管理表单的状态、验证和提交。</li>
<li><strong>React Hook Form</strong>：另一个流行的 React 表单库，性能非常优秀，尤其适合大型表单。</li>
</ul>
<h3 data-id="heading-26">4. <strong>UI 组件库</strong></h3>
<ul>
<li><strong>Material-UI (MUI)</strong> ：一个流行的 React UI 组件库，提供了丰富的 UI 组件，基于 Google 的 Material Design 规范。</li>
<li><strong>Ant Design</strong>：一个企业级的 UI 组件库，适合构建复杂的管理后台和企业级应用。</li>
<li><strong>Chakra UI</strong>：一个轻量级、现代化的 React UI 库，提供简洁的 API 和易于定制的组件。</li>
</ul>
<h3 data-id="heading-27">5. <strong>数据获取</strong></h3>
<ul>
<li><strong>Axios</strong>：一个流行的 HTTP 请求库，通常与 React 一起使用来进行网络请求。</li>
<li><strong>React Query</strong>：一个强大的数据获取库，提供缓存、分页、自动刷新等功能，简化了异步数据管理。</li>
</ul>
<h3 data-id="heading-28">6. <strong>样式管理</strong></h3>
<ul>
<li><strong>Styled Components</strong>：一个 CSS-in-JS 库，允许开发者在 JavaScript 中直接写样式，提供了更强的样式封装性。</li>
<li><strong>Emotion</strong>：与 Styled Components 类似，也是一个 CSS-in-JS 库，但性能上有些许差异，Emotion 更注重速度和灵活性。</li>
</ul>
<h3 data-id="heading-29">7. <strong>测试工具</strong></h3>
<ul>
<li><strong>Jest</strong>：React 官方推荐的 JavaScript 测试框架，集成了测试运行器、断言库和模拟功能，适用于单元测试和集成测试。</li>
<li><strong>React Testing Library</strong>：一个专注于 UI 测试的工具，鼓励开发者编写更接近用户行为的测试用例。</li>
</ul>
<h3 data-id="heading-30">8. <strong>构建工具</strong></h3>
<ul>
<li><strong>Webpack</strong>：常用的构建工具，能够打包 JavaScript、CSS 和其他资源。React 项目中常与 Babel 和其它插件一起使用。</li>
<li><strong>Create React App</strong>：一个官方的脚手架工具，帮助快速启动 React 项目，内置 Webpack 配置，方便开发者进行开发。</li>
<li><strong>Vite</strong>：现代化的构建工具，支持更快的热更新和模块加载，越来越多的 React 开发者开始转向 Vite。</li>
</ul>
<h3 data-id="heading-31">9. <strong>跨平台开发</strong></h3>
<ul>
<li><strong>React Native</strong>：一个用 React 编写移动应用的框架，可以让开发者用相同的技术栈开发 iOS 和 Android 应用。</li>
</ul>
<h3 data-id="heading-32">10. <strong>开发工具</strong></h3>
<ul>
<li><strong>React DevTools</strong>：React 的开发者工具，提供了用于调试和查看 React 组件树、状态、Props 的功能。</li>
</ul>
<h3 data-id="heading-33">Vue 生态</h3>
<p>Vue 的生态系统也非常强大，尤其在 Vue 3 发布之后，它的生态逐渐完善并被广泛接受。与 React 相比，Vue 提供了一个更加完整的框架，许多常用的工具都由 Vue 官方或社区提供。</p>
<h3 data-id="heading-34">1. <strong>状态管理</strong></h3>
<ul>
<li><strong>Vuex</strong>：Vue 官方的状态管理库，用于集中管理应用中的状态，支持模块化、插件、时间旅行调试等功能。</li>
</ul>
<h3 data-id="heading-35">2. <strong>路由</strong></h3>
<ul>
<li><strong>Vue Router</strong>：Vue 官方提供的路由库，支持动态路由、嵌套路由、懒加载等功能，与 Vue 配合得天衣无缝。</li>
</ul>
<h3 data-id="heading-36">3. <strong>UI 组件库</strong></h3>
<ul>
<li><strong>Element Plus</strong>：一个流行的 Vue UI 组件库，适合开发后台管理系统，提供了一整套精美的组件。</li>
<li><strong>Vuetify</strong>：基于 Material Design 的 Vue UI 组件库，提供丰富的组件和主题定制选项。</li>
<li><strong>Quasar</strong>：一个全栈 UI 框架，提供了用于开发响应式应用的组件，还支持 SSR、PWA 和移动端应用开发。</li>
</ul>
<h3 data-id="heading-37">4. <strong>表单处理</strong></h3>
<ul>
<li><strong>VeeValidate</strong>：一个表单验证库，用于在 Vue 应用中轻松进行表单输入验证。</li>
<li><strong>Vue Formulate</strong>：用于构建动态表单的库，提供了强大的表单元素和验证功能。</li>
</ul>
<h3 data-id="heading-38">5. <strong>数据获取</strong></h3>
<ul>
<li><strong>Axios</strong>：同样，Axios 在 Vue 中也很常见，用于执行 HTTP 请求。</li>
<li><strong>Vue Query</strong>：一个高效的异步数据管理库，类似于 React Query，专为 Vue 设计，能够处理缓存、分页、自动更新等功能。</li>
</ul>
<h3 data-id="heading-39">6. <strong>样式管理</strong></h3>
<ul>
<li><strong>Vue Styleguidist</strong>：一个用于 Vue 组件库的开发工具，可以生成可交互的组件文档。</li>
<li><strong>Vue Styled Components</strong>：类似于 React 中的 Styled Components，也是一个 CSS-in-Vue 的库，允许直接在 Vue 组件中编写样式。</li>
</ul>
<h3 data-id="heading-40">7. <strong>测试工具</strong></h3>
<ul>
<li><strong>Jest</strong>：Vue 支持 Jest 测试框架，用于单元测试和集成测试。</li>
<li><strong>Vue Test Utils</strong>：Vue 官方提供的单元测试工具，专门用于测试 Vue 组件。</li>
</ul>
<h3 data-id="heading-41">8. <strong>构建工具</strong></h3>
<ul>
<li><strong>Vite</strong>：Vite 的出现使 Vue 构建和开发的速度大大提高。Vite 是一个现代化的构建工具，支持 Vue 项目的开发和打包。</li>
<li><strong>Vue CLI</strong>：Vue 的官方脚手架工具，支持快速创建 Vue 项目并配置构建流程。</li>
</ul>
<h3 data-id="heading-42">9. <strong>跨平台开发</strong></h3>
<ul>
<li><strong>NativeScript Vue</strong>：一个基于 Vue 的跨平台框架，允许开发者用 Vue 写原生 iOS 和 Android 应用。</li>
</ul>
<h3 data-id="heading-43">10. <strong>开发工具</strong></h3>
<ul>
<li><strong>Vue DevTools</strong>：Vue 的官方开发者工具，提供了强大的调试功能，可以检查 Vue 组件、数据、事件等。</li>
</ul>
<h3 data-id="heading-44">总结</h3>
<ul>
<li><strong>React 生态</strong>：React 的生态系统非常庞大，涵盖了从状态管理到路由、UI 组件、构建工具等各个方面。React 的灵活性使得开发者可以根据需求选择适合的工具和库，但是这也意味着 React 开发者往往需要花更多时间去学习和集成不同的工具。</li>
<li><strong>Vue 生态</strong>：Vue 提供了一个更为集成化的解决方案，官方和社区提供了从状态管理到路由、UI 组件库等多个功能模块。Vue 生态的工具通常与 Vue 紧密集成，适合那些希望使用一个“全家桶”来进行开发的团队。</li>
</ul>
<p>两者的生态系统都非常强大，最终选择哪个取决于开发者的需求、项目规模以及对灵活性和集成度的偏好。</p>
<h2 data-id="heading-45">CSS</h2>
<p>CSS一直是前端项目的重中之重。在前端工程化项目中，CSS 解决方案的选择对项目的可维护性、开发效率和性能有着重要影响。随着前端开发的不断演进，各种 CSS 解决方案应运而生，用于解决传统 CSS 中存在的一些问题，比如命名冲突、全局样式污染、模块化开发等问题。以下是一些常见的 CSS 解决方案及其特点：</p>
<p>这个表格清晰地展示了不同 CSS 解决方案的优缺点</p>













































<table><thead><tr><th><strong>样式方案</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>传统 CSS</strong></td><td>- 简单直观，学习曲线低- 不需要引入额外的工具和框架</td><td>- <strong>命名冲突</strong>：样式通常是全局的，容易导致命名冲突- <strong>样式污染</strong>：全局样式可能影响到其他部分- 随着项目规模扩大，样式管理复杂</td></tr><tr><td><strong>CSS 预处理器（Sass、Less、Stylus）</strong></td><td>- <strong>增强的功能</strong>：支持变量、嵌套规则、函数、混入等- <strong>模块化</strong>：通过 <code>@import</code> 或 <code>@use</code> 实现样式模块化- <strong>代码复用</strong>：通过混入、函数等复用代码</td><td>- <strong>编译步骤</strong>：需要通过构建工具编译为标准 CSS- <strong>增加复杂度</strong>：对于小项目，引入预处理器增加不必要的复杂度</td></tr><tr><td><strong>CSS-in-JS</strong></td><td>- <strong>组件化</strong>：每个组件拥有自己的样式，避免了全局样式污染- <strong>动态样式</strong>：根据 props 或状态动态生成样式- <strong>支持 JS 变量</strong>：直接使用 JS 变量和逻辑</td><td>- <strong>性能开销</strong>：增加运行时性能开销- <strong>学习成本</strong>：需要学习新的语法和工具，尤其对于不熟悉 JS 的开发者</td></tr><tr><td><strong>BEM（块元素修饰符）命名规范</strong></td><td>- <strong>避免命名冲突</strong>：确保类名唯一- <strong>模块化</strong>：组件样式与组件关联- <strong>可维护性</strong>：层次结构清晰，便于维护</td><td>- <strong>类名冗长</strong>：命名规则可能导致类名过长- <strong>依赖手动命名</strong>：需要严格遵循命名规范，增加学习成本</td></tr><tr><td><strong>PostCSS 和 Autoprefixer</strong></td><td>- <strong>自动化</strong>：自动添加浏览器前缀，减少手动修改- <strong>插件化</strong>：灵活配置插件，扩展功能- <strong>CSS 优化</strong>：进行压缩、合并等优化</td><td>- <strong>构建工具依赖</strong>：需要借助构建工具配置执行- <strong>插件依赖</strong>：需要选择合适的插件进行支持</td></tr><tr><td><strong>CSS Modules</strong></td><td>- <strong>作用域隔离</strong>：避免全局样式污染，解决命名冲突- <strong>易于集成</strong>：可以与 Sass 等一起使用</td><td>- <strong>配置要求</strong>：需要构建工具支持（如 Webpack）- <strong>学习成本</strong>：适应模块化的方式需要时间</td></tr><tr><td><strong>Tailwind CSS</strong></td><td>- <strong>快速开发</strong>：大量预定义工具类，快速实现复杂 UI- <strong>可定制性</strong>：高度配置选项，自定义颜色、间距、字体等- <strong>响应式设计</strong>：内建支持响应式设计和状态变换</td><td>- <strong>类名冗长</strong>：HTML 中类名可能非常冗长- <strong>学习曲线</strong>：需要掌握大量工具类，初学者可能不直观</td></tr></tbody></table>
<h3 data-id="heading-46">总结</h3>
<p>前端工程化项目中常用的 CSS 解决方案有很多，每种方案都针对不同的问题提供了解决方案。选择合适的 CSS 解决方案需要根据项目的规模、开发团队的需求以及应用的性能要求来权衡：</p>
<ul>
<li><strong>传统 CSS</strong> 适合小型项目或简单的网页设计。</li>
<li><strong>CSS 预处理器</strong>（如 Sass、Less）适合中小型项目，提供了更强的样式管理能力。</li>
<li><strong>CSS-in-JS</strong> 适合组件化强的应用（如 React），可以将样式与组件逻辑结合。</li>
<li><strong>BEM</strong> 适用于大型项目，通过规范化类名来确保样式的模块化和可维护性。</li>
<li><strong>PostCSS 和 Autoprefixer</strong> 适合处理浏览器兼容性和样式优化。</li>
<li><strong>Tailwind CSS</strong> 适合快速开发，尤其是那些要求快速构建 UI 的项目。</li>
</ul>
<h2 data-id="heading-47">EditorConfig</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Feditorconfig.org%2F" title="https://link.juejin.cn/?target=https%3A%2F%2Feditorconfig.org%2F" target="_blank">EditorConfig</a>&nbsp;有助于跨不同编辑器和 IDE 处理同一项目的多个开发人员保持一致的编码风格。</p>
<p>对于多人协作的项目，有小伙伴喜欢用<strong>VSCode</strong>，还有小伙伴喜欢用 <strong>WebStorm</strong>，但是对于一些公共的文本格式需要保持统一，而EditorConfig可以做好这件事</p>
<p><code>EditorConfig</code> 的重要规则如下</p>
<h3 data-id="heading-48">insert_final_newline</h3>
<p><code>insert_final_newline</code>&nbsp;是一个在许多文本编辑器和版本控制系统（如 Git）中常见的设置选项。当这个选项被启用时，它会在文本文件的末尾自动插入一个空行（也称为最终新行或尾随新行）。</p>
<h3 data-id="heading-49">end_of_line</h3>
<p><code>end_of_line</code> 指定了文本文件中的行结束字符。在不同的操作系统（Unix/Windows/Linux等）中，行结束的表示方式可能不同：</p>
<ul>
<li>在 Unix/Linux 系统中，通常使用单个换行符（LF，即 <code>\n</code>）来表示行结束</li>
<li>在 Windows 系统中，通常使用回车符（CR，即 <code>\r</code>）后跟换行符（LF，即 <code>\n</code>），即 <code>\r\n</code> 来表示行结束</li>
<li>在早期 Mac 系统中，使用单个回车符（CR，即 <code>\r</code>）来表示行结束，但现代 Mac 系统已经改为使用 Unix 风格的换行符（LF）</li>
</ul>
<p><code>end_of_line</code> 设置的作用是确保文件在不同的操作系统之间传输或协作时，行结束符能够被正确识别和处理。例如，如果你在 Windows 系统上编写了一个文本文件，然后将它上传到 Git 仓库，<code>end_of_line</code> 设置可以确保文件在 Unix/Linux 系统上的用户拉取时，行结束符能够被转换为 Unix 风格的 <code>\n</code>，以避免出现不必要的差异或错误。</p>
<p>保持 <code>end_of_line</code> 设置的一致性对于跨平台项目和协作是非常重要的，因为它可以避免由于行结束符差异引起的不必要的文件差异或冲突。</p>
<h3 data-id="heading-50">indent_style</h3>
<p><code>indent_style</code>&nbsp;用于控制代码或文本文件的缩进风格。缩进风格通常有两种主要类型：</p>
<ul>
<li>空格（space）：在这种风格中，缩进是通过使用空格字符来完成的</li>
<li>制表符（tab）：在这种风格中，缩进是通过使用制表符字符来完成的</li>
</ul>
<h3 data-id="heading-51">indent_size</h3>
<p><code>indent_size</code> 用于控制代码或文本文件的每一级缩进应该使用多少个空格或制表符。这个设置通常与 <code>indent_style</code> 配合使用，后者决定了缩进是使用空格还是制表符。</p>
<p>在实际使用中，如果你配置 <code>indent_style</code> 为 <code>space</code>，那么 indent_size 将决定每次缩进插入多少个空格，而 tab_width 则决定了当你在代码中遇到制表符时，它在编辑器中显示为多少个空格的宽度。如果你配置 indent_style 为 tab，那么 indent_size 可能会决定每次缩进插入一个制表符，而 tab_width 则决定了这个制表符在编辑器中显示为多少个空格的宽度。</p>
<p>在不同的编辑器和 IDE 中，这两个设置可能会有不同的默认值和配置方式。例如，在 Visual Studio Code 中，你可以通过设置面板搜索这两个选项来更改它们的值。在 <code>.editorconfig</code> 文件中，你也可能会看到这两个设置，以确保跨不同编辑器和开发环境的一致性。</p>
<h3 data-id="heading-52">charset</h3>
<p><code>charset</code> 用于表示文本的一组字符以及每个字符的编码方法。常见的字符集有 <code>UTF-8</code>、<code>UTF-16</code> 和 <code>ASCII</code> 等等，工作中主要使用 <code>UTF-8</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/050a4add24fd4736ab5f972bab56a087~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iez566A566A:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742548016&amp;x-signature=gdHzxMCYDKz%2FcD4qS7kbsJPv8Ls%3D" alt="image.png" loading="lazy"></p>
<p>可以通过 VS Code 底部状态栏查看当前文件的字符编码</p>
<p>有关 EditorConfig 的详细配置可以看看笔者写的 <a href="https://juejin.cn/post/7360227160705433610" target="_blank" title="https://juejin.cn/post/7360227160705433610">Oxc 出来了，我却还在学 EditorConfig</a>文章</p>
<h2 data-id="heading-53">Prettier</h2>
<p><code>Prettier</code> 是一个强约束的代码格式化工具，将原始格式的源代码按照设定的规则进行格式化， 然后输出格式化后的代码。支持常见的&nbsp;<code>js</code>、<code>jsx</code>、<code>html</code>、<code>json</code>&nbsp;等等编程语言或数据格式。</p>
<p>有关 Prettier 的详细配置可以看看笔者写的 <a href="https://juejin.cn/post/6844904150027730952" target="_blank" title="https://juejin.cn/post/6844904150027730952">谈一谈格式化工具 Prettier</a>文章</p>
<h2 data-id="heading-54">ESLint</h2>
<p>ESLint 是一个流行的 JavaScript 静态代码分析工具，它用来识别和报告代码中的潜在问题或不符合规范的地方，从而帮助开发者写出更干净、更一致的代码。ESLint 主要的功能是：</p>
<ol>
<li><strong>代码质量检查</strong>：它能够检查代码中可能存在的错误，如未使用的变量、语法错误等。</li>
<li><strong>风格一致性</strong>：它可以根据特定的规则来保证代码风格的一致性（如缩进、命名规范等），帮助团队在协作中保持一致的编码风格。</li>
<li><strong>自定义规则</strong>：可以根据项目需求配置或编写自定义的规则。</li>
<li><strong>插件和扩展</strong>：支持通过插件扩展，增加对不同语言（如 TypeScript）、框架（如 React）等的支持。</li>
</ol>
<p>你可以通过配置文件（如 <code>.eslintrc</code>）来设置 ESLint，或者通过命令行工具集成到开发流程中。</p>
<p>ESLint 通常与代码编辑器的插件一起使用，或者在构建工具链中作为一个步骤（例如与 Webpack、Gulp、Grunt 等工具结合）。</p>
<h2 data-id="heading-55">Stylelint</h2>
<p><strong>Stylelint</strong> 是一个用于 CSS、Sass、Less 等样式表语言的静态代码分析工具，类似于 ESLint，但专注于样式代码的质量和一致性。它的作用是帮助开发者检测和修复样式代码中的潜在问题，确保样式代码符合一定的风格规范。</p>
<p>Stylelint 的主要作用：</p>
<ul>
<li><strong>代码质量检查</strong>： 检查 CSS、Sass 等代码中的语法错误、无效的属性或重复的选择器等问题。</li>
<li><strong>风格一致性</strong>：保证样式代码的风格一致性，比如属性顺序、缩进方式、空格使用、命名规范等。这样团队可以在多人协作时保持统一的代码风格。</li>
<li><strong>自定义规则</strong>：你可以根据项目需求创建自定义规则，或者调整默认规则，来满足团队或个人的编码风格。</li>
<li><strong>插件支持</strong>：支持扩展插件，能够增强功能，比如支持新的 CSS 语法、添加对 CSS 预处理器（如 Sass、Less）的支持等。</li>
<li><strong>提高代码可维护性</strong>：强制一致的代码风格有助于提高样式表的可读性和可维护性，尤其是在大型项目中尤为重要。</li>
</ul>
<h3 data-id="heading-56">使用方式：</h3>
<p>Stylelint 可以作为开发工具链的一部分，在构建工具中自动运行（比如通过 Gulp、Webpack 等），或者通过编辑器插件实时提示潜在问题。</p>
<h3 data-id="heading-57">主要特点：</h3>
<ul>
<li>支持多种样式语言（CSS、SCSS、Sass、Less 等）。</li>
<li>强大的规则系统，可以灵活配置。</li>
<li>能与其他工具（如 Prettier）配合使用，进一步增强代码的自动格式化功能。</li>
</ul>
<p>总的来说，Stylelint 通过静态分析帮助开发者保持样式代码质量，并且减少因为风格不一致引起的潜在问题。</p>
<h2 data-id="heading-58">commitlint</h2>
<p><strong>Commitlint</strong> 是一个用于检查 Git 提交消息（commit message）是否符合预定规范的工具。它的目的是确保团队成员在提交代码时，遵循一致的提交规范，从而提升代码仓库的可读性、可维护性，并使得提交历史更加清晰和结构化。</p>
<h3 data-id="heading-59">Commitlint 的主要作用：</h3>
<ol>
<li>
<p><strong>强制规范化提交信息</strong>：通过定义和检查提交消息格式，确保所有的提交信息符合预定的格式或规范（如 <strong>Conventional Commits</strong>）。这有助于统一团队的提交标准，避免不同风格的提交信息混杂在一起，导致历史记录难以阅读和理解。</p>
</li>
<li>
<p><strong>自动化检查</strong>：Commitlint 通常集成在 Git 钩子中（如 <code>commit-msg</code> 钩子），在每次提交代码时自动检查提交信息是否符合规范。如果不符合规范，提交将被拒绝，强制开发者修改提交信息，直到符合要求为止。</p>
</li>
<li>
<p><strong>增强版本管理和发布流程</strong>：当遵循类似 <strong>Conventional Commits</strong> 这样的标准时，可以自动化地生成 <strong>Changelog</strong>（变更日志），并且配合版本管理工具（如 <strong>Semantic Release</strong>）自动管理版本号（根据提交的类型，自动增加版本号）。</p>
<ul>
<li>例如：<code>feat:</code> 表示新增功能，<code>fix:</code> 表示修复问题，<code>chore:</code> 表示一些琐碎的任务等，借此可以自动化发布流程，轻松推送新版本。</li>
</ul>
</li>
<li>
<p><strong>提高团队协作效率</strong>：团队成员之间可以快速了解每次提交的目的和内容，尤其是在大型项目中，规范化的提交信息有助于提升团队沟通效率和代码审核流程的顺畅度。</p>
</li>
</ol>
<h3 data-id="heading-60">常见的提交消息规范：</h3>
<ol>
<li>
<p><strong>Conventional Commits</strong>：这是一种常用的提交信息规范格式，通常包括以下几个部分：</p>
<ul>
<li><code>&lt;type&gt;(&lt;scope&gt;): &lt;message&gt;</code></li>
<li>例如：<code>feat(user): add login functionality</code> 或 <code>fix(button): resolve styling issue</code>.</li>
<li><code>type</code> 可以是 <code>feat</code>（功能）、<code>fix</code>（修复）、<code>chore</code>（琐事）、<code>docs</code>（文档）等，<code>scope</code> 是可选的，用来描述影响的模块或功能。</li>
</ul>
</li>
<li>
<p><strong>其他规范</strong>：也有团队或项目可能采用自定义的格式来管理提交消息。Commitlint 提供了高度的自定义能力，可以根据项目需求来配置规则。</p>
</li>
</ol>
<h3 data-id="heading-61">使用方式：</h3>
<ul>
<li><strong>Git 钩子</strong>：通常使用 <strong>Husky</strong> 这样的工具来自动化执行 commitlint，确保每次提交都会被检查。</li>
<li><strong>命令行工具</strong>：开发者可以使用 commitlint 在命令行上手动检查提交消息。</li>
<li><strong>集成到 CI/CD 流程中</strong>：在 CI 工具（如 GitHub Actions、Jenkins 等）中集成 commitlint，确保提交规范在合并到主分支之前得到验证。</li>
</ul>
<h3 data-id="heading-62">主要优点：</h3>
<ul>
<li><strong>可读性</strong>：规范化的提交信息使得其他开发者能够迅速了解每个提交的目的。</li>
<li><strong>自动化发布</strong>：配合工具，能够自动生成版本号、发布日志等。</li>
<li><strong>团队协作</strong>：提高团队开发效率和代码审查流程。</li>
</ul>
<p>总之，Commitlint 通过确保提交信息格式的一致性，帮助团队更好地管理代码仓库，并增强发布流程的自动化。</p>
<h2 data-id="heading-63">CSpell</h2>
<p>在编程中，百分之九十的问题可能是粗心大意导致的，而拼写错误是粗心大意的主要原因</p>
<p>社区中推出一个解决Typo的自动化工具 CSpell, 用于检查项目中的 typo。<strong>CSpell</strong> 是一个开源的拼写检查工具，专门用于检查源代码文件中的拼写错误。它通常用于开发环境，帮助开发者确保代码中的注释、文档、变量名、字符串等文本部分没有拼写错误，从而提升代码的可读性和质量</p>
<p>CSpell 提供 npm 安装包，下面开始在项目中安装 cspell</p>
<h2 data-id="heading-64">快速开始</h2>
<p>在项目中安装 cspell</p>
<pre><code class="hljs language-shell" lang="shell">yarn add cspell -D
</code></pre>
<p>然后在根目录的 package.json 中添加 <code>npm script</code></p>
<pre><code class="hljs language-shell" lang="shell">"cspell": "cspell src/**/*.{ts,tsx,js,mjs,jsx}"
</code></pre>
<p>在项目中的某个文件里写一个错误的单词</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7713ac4c6e2454b90964e32fb85d6d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iez566A566A:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742548016&amp;x-signature=XeVi1ziwkWrnN07hOFueDk6fvUo%3D" alt="image.png" loading="lazy"></p>
<p>在终端里运行 <code>yarn cspell</code>， 其结果如下</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07bd537422d04fd489424c3e6212eb62~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iez566A566A:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742548016&amp;x-signature=261IzO2NAaHQf9gtS%2BKMbNVTgM4%3D" alt="image.png" loading="lazy"></p>
<p>cspell 会检查出有typo的单词，并且给出提示。</p>
<pre><code class="hljs language-shell" lang="shell">cspell "src/**/*.js"
<span class="hljs-meta prompt_"># </span><span class="bash">or</span>
cspell lint "src/**/*.js"
</code></pre>
<p>表示检查 <code>src</code> 文件下所有的 <code>js</code> 文件</p>
<pre><code class="hljs language-shell" lang="shell">cspell "**"
</code></pre>
<p>检查项目中的所有文件</p>
<h2 data-id="heading-65">如何设置配置文件</h2>
<p>CSpell  支持使用配置文件对 CSpell 进行更详细的控制。CSpell 可以使用 JSON、Yaml 和 JavaScript 文件进行配置。它会自动搜索以下之一：<code>cspell.json</code>、<code>cspell.config.yaml</code>、<code>cspell.config.cjs</code>。笔者使用 <code>cspell.json</code></p>
<p>请看下面这个配置例子</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"$schema"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.2"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dictionaryDefinitions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"typo-words"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./typo-words.txt"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"addWords"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dictionaries"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"typo-words"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ignorePaths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"dist"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"build"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><code>"name": "typo-words"</code>：定义了一个自定义词典的名称，叫做&nbsp;<code>typo-words</code>。</li>
<li><code>"path": "./typo-words.txt"</code>：指定了自定义词典文件的路径，这里是当前目录下的&nbsp;<a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">typo-words.txt</a>&nbsp;文件。</li>
<li><code>"addWords": true</code>：表示可以向这个自定义词典中添加新词。</li>
<li><code>"dictionaries": ["typo-words"]</code>：指定了要使用的词典，这里使用了前面定义的&nbsp;<code>typo-words</code>&nbsp;自定义词典。</li>
<li><code>"ignorePaths": ["node_modules", "dist", "build"]</code>：指定了要忽略的路径，Code Spell Checker 在这些路径下的文件中不会进行拼写检查。这里忽略了&nbsp;<a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">node_modules</a>、<code>dist</code>&nbsp;和&nbsp;<code>build</code>&nbsp;目录。</li>
</ul>
<p>在根目录添加 typo-words.txt 文件，在里面添加 helol, 再执行 yarn cspell, 结果如下</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7910dff07134d3eb2878ffaa4dfa46e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iez566A566A:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742548016&amp;x-signature=mg0RSvlCffo02L9VvYkVT5dURJ4%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-66">其他命令参数</h2>
<p>一般情况下，项目的文件很多，在执行 cspell 检查的时候，不需要显示查询进度，可以使用命令参数</p>
<pre><code class="hljs language-shell" lang="shell">cspell src/**/*.{ts,tsx,js,mjs,jsx} --no-progress
</code></pre>
<h2 data-id="heading-67">Unit Test</h2>
<p>说完一些Lint工具，现在来看一下<strong>单元测试</strong>/<strong>集成测试</strong>/<strong>E2E测试</strong>和<strong>视觉回归测试</strong></p>
<p>单元测试（Unit Testing）是指对前端应用中的单个最小功能单元进行测试，以验证其是否按预期工作。这个"最小功能单元"通常是一个函数、方法、组件或模块。</p>
<p>单元测试的目的是确保每个独立的单元在隔离环境下能够正常工作，通常不涉及外部依赖，比如后端接口或数据库等。</p>
<p>目前流行的单元测试框架主要是Jest和Vitest，这个两个测试框架的官方文档非常详细</p>
<p>Jest 是一个流行的 JavaScript 测试框架，由 Facebook 开发和维护。它广泛用于 React 应用程序的单元测试、集成测试和端到端测试。Jest 的主要特点包括：</p>
<ol>
<li><strong>零配置</strong>：Jest 是开箱即用的，你不需要做很多配置就可以开始写测试。</li>
<li><strong>快照测试</strong>：Jest 支持快照测试，能够记录组件的输出，并在后续测试中比较这些输出是否发生了变化，这对于 React 组件尤为有用。</li>
<li><strong>并行测试</strong>：Jest 会并行执行测试以提高速度。</li>
<li><strong>内置断言库</strong>：Jest 内置了断言库，不需要额外安装其他库。</li>
<li><strong>覆盖率报告</strong>：Jest 可以自动生成代码覆盖率报告，帮助开发者了解哪些部分的代码没有被测试到。</li>
<li><strong>模拟功能</strong>：Jest 允许模拟函数和模块，以便进行隔离测试。</li>
</ol>
<p>Vitest 是一个现代的、快速的 JavaScript 测试框架，专为 Vite 开发环境而设计。它与 Jest 类似，但有一些独特的优势，尤其是在与 Vite 配合使用时。Vitest 的目标是提供更高的性能和更现代的开发体验。</p>
<p>Vitest 的主要特点：</p>
<ol>
<li><strong>高性能</strong>：Vitest 使用 Vite 的构建工具，因此它能够非常快速地启动和运行测试，特别是在热重载和模块替换方面，比传统的测试框架更快。</li>
<li><strong>与 Vite 完全集成</strong>：由于它是为 Vite 设计的，Vitest 在与 Vite 项目协作时表现得非常顺畅，支持 ES 模块、TypeScript 等，提供开发者友好的体验。</li>
<li><strong>Jest 兼容性</strong>：Vitest 在 API 设计上与 Jest 非常相似，许多 Jest 的测试语法和功能都可以直接在 Vitest 中使用。如果你已经熟悉 Jest，那么迁移到 Vitest 会比较容易。</li>
<li><strong>内建模拟功能</strong>：Vitest 提供强大的模块模拟功能，可以在测试中模拟函数、模块和时间等，使得测试更加灵活和可靠。</li>
<li><strong>断言库</strong>：Vitest 默认集成了断言库，如 <code>expect</code>，并且支持各种常用的测试方法和匹配器。</li>
<li><strong>热重载</strong>：Vitest 支持热重载功能，可以实时反映代码修改，减少了手动重新运行测试的频率。</li>
<li><strong>支持 TypeScript</strong>：Vitest 天生支持 TypeScript，能够在不需要额外配置的情况下进行类型检查和代码高亮。</li>
</ol>
<p>Vitest 是一个现代化、快速且与 Vite 深度集成的测试框架，它旨在提供比传统框架（如 Jest）更好的性能和体验。如果你使用 Vite 作为构建工具，Vitest 会是一个非常理想的选择。</p>
<p>如果选用Webpack构建项目，选Jest作为测试框架比较适合，使用 Vite 作为构建工具，更倾向选 Vitest 作为测试框架。</p>
<p>选完测试框架后，接下来就是选用与测试框架配套使用的断言库等。在React项目中，还需要添加<code>jsdom</code>、<code>happy-dom</code>和<code>@testing-library</code> 系列依赖。在Vue项目中，还需要添加<code>jsdom</code>、<code>happy-dom</code>和<code>@vue/test-utils</code>等依赖</p>
<p>与单元测试相关还有如何mock外部资源，如何书写测试用例等内容，请小伙伴们阅读官方文档学习</p>
<p>有关单元测试有关的内容请看笔者的这篇文章《<a href="https://juejin.cn/post/7481294563958325289" target="_blank" title="https://juejin.cn/post/7481294563958325289">单元测试入门与进阶</a>》</p>
<h2 data-id="heading-68">Integration Testing</h2>
<p>集成测试（Integration Testing）是指对多个前端组件或模块进行组合测试，以确保它们在一起协作时能够正常工作。它的目的是检查不同模块之间的交互和数据流，验证前端应用在实际使用场景中的表现是否符合预期。</p>
<p>与单元测试不同，集成测试并不关注单个组件的实现，而是更侧重于多个组件或模块的结合点和接口是否正确。它的测试粒度比单元测试大，跟业务场景是强相关，</p>
<p>下面是常见的集成测试场景：</p>
<ul>
<li><strong>多个组件的协作</strong>：测试不同前端组件或模块在组合后的行为，比如一个表单组件与数据处理组件的结合。</li>
<li><strong>与后端接口的交互</strong>：模拟前端与服务器的请求与响应，确保前端能够正确处理和展示从后端获取的数据。</li>
<li><strong>状态管理的正确性</strong>：如果应用使用了状态管理库（如 Redux、Vuex 等），集成测试会验证多个组件如何共享和更新状态。</li>
<li><strong>UI 和 UX 测试</strong>：确保多个组件在用户交互后能够正常更新 UI，比如点击按钮后，UI 是否正确反应。</li>
</ul>
<h3 data-id="heading-69">集成测试的常见工具：</h3>
<ol>
<li><strong>Jest/Vitest</strong>：一个广泛使用的 JavaScript 测试框架，可以与其他工具配合进行集成测试。</li>
<li><strong>React Testing Library/Vue Test Utils</strong>：专门为 React 和 Vue 设计的测试库，支持组件渲染、模拟交互等。</li>
<li><strong>Cypress</strong>：一个端到端的测试框架，也可以用于集成测试，模拟真实用户行为，进行跨组件或页面的测试。</li>
</ol>
<h3 data-id="heading-70">集成测试的常见场景：</h3>
<ul>
<li><strong>表单提交与 API 通信</strong>：用户填写表单并提交数据，前端应该向后端发出请求并处理返回的响应。</li>
<li><strong>组件间数据流</strong>：父子组件通过 props 传递数据，或通过共享的状态进行交互，集成测试可以验证这种数据流是否正常。</li>
<li><strong>路由与页面跳转</strong>：验证点击链接或按钮后，路由是否正确跳转，页面是否正常加载。</li>
</ul>
<h3 data-id="heading-71">为什么需要集成测试：</h3>
<ol>
<li><strong>提高可靠性</strong>：集成测试能够及早发现组件之间集成时的潜在问题。</li>
<li><strong>防止回归</strong>：随着项目复杂度的增加，集成测试能够确保新功能或修改不会破坏现有的功能。</li>
<li><strong>模拟用户行为</strong>：集成测试通常涉及与用户界面的交互，能够更好地模拟真实使用场景。</li>
</ol>
<p>总之，前端的集成测试对于确保各个模块、组件在一起正常运行非常重要。它帮助开发团队发现问题，减少集成阶段的调试工作，并提高整体应用的质量。</p>
<p>集成测试给我的感觉是对单元测试更高维度的一种概念，介于单元测试与 E2E 测试之间</p>
<h2 data-id="heading-72">E2E Test</h2>
<p>E2E（End-to-End）测试是指对整个应用系统进行的全面测试，模拟用户的操作路径，从前端到后端，确保整个系统在真实使用环境中的功能和性能都符合预期。</p>
<h3 data-id="heading-73">前端的E2E测试</h3>
<p>在前端开发中，E2E 测试主要关注的是应用的用户交互和 UI 行为是否符合设计要求。E2E 测试通常会模拟用户的完整操作流程，检查从前端到后端各个环节的交互是否正常。与单元测试或集成测试不同，E2E测试会涵盖整个应用，包括前端界面、API请求、数据库操作等。</p>
<h3 data-id="heading-74">常见场景有：</h3>
<ol>
<li><strong>模拟用户行为</strong>：例如用户点击按钮、填写表单、提交请求、页面跳转等，确保这些操作能够顺利完成。</li>
<li><strong>验证应用功能的正确性</strong>：检查应用的不同功能模块是否按预期工作。</li>
<li><strong>确保系统的集成性</strong>：前端和后端的交互是否顺畅，API 调用是否正常，数据流是否符合预期。</li>
</ol>
<h3 data-id="heading-75">前端E2E测试工具：</h3>
<p>前端E2E测试通常借助一些自动化测试框架和工具来实现，常见的工具有：</p>
<ul>
<li><strong>Cypress</strong>：现代的前端E2E测试工具，支持快速的浏览器自动化，使用简单，文档完善，适合测试单页面应用（SPA）。</li>
<li><strong>Playwright</strong>：一个由Microsoft开发的自动化测试框架，支持多浏览器测试，且具备高效的性能。</li>
<li><strong>Puppeteer</strong>：由Google开发的Node库，主要用于Chrome浏览器的自动化测试。</li>
</ul>
<p>现在流行使用 Playwright 来写 E2E 测试</p>
<h3 data-id="heading-76">前端E2E测试的步骤：</h3>
<ol>
<li><strong>设置测试环境</strong>：启动应用的测试版本，通常会在测试环境中运行前端代码。</li>
<li><strong>编写测试脚本</strong>：使用测试工具编写用户行为的模拟脚本，如点击按钮、输入文本、验证UI显示等。</li>
<li><strong>执行测试</strong>：运行测试脚本，模拟真实用户的操作。</li>
<li><strong>结果验证</strong>：检查测试结果，确保应用的各个部分能够正确地响应用户的操作，且无任何功能错误。</li>
<li><strong>报告和修复</strong>：如果测试失败，根据报告的错误信息修复代码。</li>
</ol>
<h3 data-id="heading-77">为什么要做前端的 E2E 测试？</h3>
<ul>
<li><strong>确保整体功能的完整性</strong>：单独的单元测试和集成测试可能无法覆盖整个应用的业务流程，而E2E测试通过模拟真实的用户行为，能确保前后端各部分的集成效果。</li>
<li><strong>提高用户体验</strong>：E2E测试能够提前发现并修复界面交互上的问题，避免用户在真实环境中遇到问题。</li>
<li><strong>自动化回归测试</strong>：在频繁发布新版本时，E2E测试能够帮助自动化检测系统的回归问题。</li>
</ul>
<p>总的来说，前端 E2E 测试是确保前端应用功能与用户需求相符的一个重要环节，<strong>它关注的更多是从用户的角度来检验应用是否按预期工作</strong>。</p>
<p>前端E2E测试是非常重要的，它可以保证产品的稳定运行</p>
<h2 data-id="heading-78">Visual Regression Testing</h2>
<p>视觉回归测试（Visual Regression Testing）是指通过对比应用的不同版本之间的界面视觉差异，确保 UI 在开发、更新或修复过程中没有出现不期望的变化。这种测试方法主要用于发现那些难以通过传统的功能性测试捕获的视觉问题，如布局错乱、颜色变化、字体变化等。</p>
<h3 data-id="heading-79">视觉回归测试的主要流程：</h3>
<ol>
<li>
<p><strong>初始化基准（Baseline）截图</strong>：</p>
<ul>
<li>在测试的初始阶段，首先需要捕获当前应用的“基准”截图。这些截图应该涵盖应用的关键页面或组件，确保测试的广泛性。</li>
<li>基准截图需要在稳定的环境下生成，确保没有干扰因素（如分辨率、浏览器版本等）。</li>
</ul>
</li>
<li>
<p><strong>开发和更改（开发新功能或修复 bug）</strong> ：</p>
<ul>
<li>开发人员在基准截图的基础上进行开发工作（如新增功能、修复 bug 或调整 UI）。</li>
<li>这些开发更改可能会影响到 UI，尤其是在页面布局、样式、颜色等方面。</li>
</ul>
</li>
<li>
<p><strong>生成新截图</strong>：</p>
<ul>
<li>在更改完成后，再次捕获新版本的截图。这些截图应与基准截图相同，确保覆盖的页面、组件和分辨率一致。</li>
<li>新截图的生成通常是在测试环境中进行的，以避免生产环境的波动影响测试结果。</li>
</ul>
</li>
<li>
<p><strong>对比截图</strong>：</p>
<ul>
<li>对比基准截图和新截图，检查它们之间的视觉差异。</li>
<li>对比过程可以通过专门的工具自动完成，如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpercy.io%2F" target="_blank" title="https://percy.io/" ref="nofollow noopener noreferrer">Percy</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgarris%2FBackstopJS" target="_blank" title="https://github.com/garris/BackstopJS" ref="nofollow noopener noreferrer">BackstopJS</a> 或 <a href="https://link.juejin.cn?target=https%3A%2F%2Fapplitools.com%2F" target="_blank" title="https://applitools.com/" ref="nofollow noopener noreferrer">Applitools</a> 等。它们通常会高亮显示任何差异，帮助开发人员快速定位问题。</li>
</ul>
</li>
<li>
<p><strong>评估差异</strong>：</p>
<ul>
<li>根据测试工具的输出，开发团队可以评估视觉差异是否是预期中的。例如，某些变化可能是故意的（如新的 UI 设计），而其他变化则可能是无意的 bug 或破坏性更改。</li>
<li>一些测试工具提供了差异阈值设置功能，允许开发团队定义可接受的视觉差异范围（如容忍微小像素差异）。</li>
</ul>
</li>
<li>
<p><strong>修复问题</strong>：</p>
<ul>
<li>如果发现了不希望的视觉差异，开发人员需要分析原因并进行修复。这可能涉及样式调整、布局修改或前端代码修复。</li>
<li>在修复后，需要重新进行回归测试，确保修复没有引入新的视觉问题。</li>
</ul>
</li>
<li>
<p><strong>集成与持续测试</strong>：</p>
<ul>
<li>视觉回归测试通常会集成到持续集成（CI）管道中，以确保每次代码更新后都能自动执行视觉回归测试。</li>
<li>这确保了任何视觉上的回归都会被及时捕捉，而不会在生产环境中造成问题。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-80">视觉回归测试的工具：</h3>
<ul>
<li><strong>Percy</strong>：一个自动化的视觉回归测试平台，支持与 CI/CD 流程集成。</li>
<li><strong>BackstopJS</strong>：一个开源工具，支持基于截图的视觉回归测试，适用于任何 Web 应用程序。</li>
<li><strong>Applitools</strong>：提供 AI 驱动的视觉回归测试，能够智能地检测并报告界面差异。</li>
<li><strong>Storybook</strong>：与视觉回归测试工具（如 Percy）集成，用于测试 React 组件的 UI 变化。</li>
</ul>
<p>视觉回归测试的解决方案主要有两种，第一种是利用webdriver，第二种使用playwright。笔者推荐使用playwright去做</p>
<p>上面提到的<strong>单元测试</strong>/<strong>集成测试</strong>/<strong>E2E测试</strong>和<strong>视觉回归测试</strong>的四种测试都要配置到CI中，每一次代码改动都需要进行代码把关</p>
<h2 data-id="heading-81">Github/Gitlab/Gitee/Gitea</h2>
<p><strong>GitHub、GitLab、Gitee 和 Gitea</strong> 都是 Git 仓库托管平台，用于代码托管、版本控制和团队协作。它们提供了类似的功能，但在一些细节上有所不同，尤其在部署方式、功能、使用场景等方面。</p>
<h3 data-id="heading-82">简单介绍：</h3>
<ol>
<li>
<p><strong>GitHub</strong>：</p>
<ul>
<li>全球最受欢迎的开源代码托管平台，提供强大的协作功能，广泛应用于开源项目和私有项目。</li>
<li>支持公共和私有仓库，提供 Git 仓库托管、持续集成/持续部署（CI/CD）、问题跟踪、项目管理等功能。</li>
<li>GitHub Actions 提供 CI/CD 服务。</li>
</ul>
</li>
<li>
<p><strong>GitLab</strong>：</p>
<ul>
<li>一个功能全面的 DevOps 平台，除了 Git 仓库托管，还提供从开发到生产的整个软件生命周期管理（如 CI/CD、监控、部署等）。</li>
<li>GitLab 提供自托管和 SaaS 服务，功能较 GitHub 更加全面，特别是在 DevOps 和 CI/CD 流程中。</li>
</ul>
</li>
<li>
<p><strong>Gitee</strong>：</p>
<ul>
<li>由开源中国（OSChina）推出的代码托管平台，主要面向中国市场，具有较好的国内访问速度。</li>
<li>提供类似 GitHub 的代码托管和协作功能，支持 Git 仓库、问题跟踪、CI/CD 等功能。</li>
</ul>
</li>
<li>
<p><strong>Gitea</strong>：</p>
<ul>
<li>一个轻量级的 Git 仓库托管平台，适用于小型团队或个人，支持自托管。</li>
<li>Gitea 是开源的，并且资源消耗较小，适合在资源有限的情况下运行。它的界面和功能都比较简洁，常用于小型团队或个人项目的托管。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-83">各平台的区别：</h3>
































































































<table><thead><tr><th>特性</th><th><strong>GitHub</strong></th><th><strong>GitLab</strong></th><th><strong>Gitee</strong></th><th><strong>Gitea</strong></th></tr></thead><tbody><tr><td><strong>主要定位</strong></td><td>开源代码托管与协作平台</td><td>全面的 DevOps 平台，支持 CI/CD</td><td>中国本土的代码托管平台</td><td>轻量级的自托管 Git 平台</td></tr><tr><td><strong>是否支持自托管</strong></td><td>不支持自托管（提供 GitHub Enterprise）</td><td>支持自托管（GitLab CE &amp; EE）</td><td>不支持自托管</td><td>支持自托管</td></tr><tr><td><strong>托管服务</strong></td><td>公共和私有仓库</td><td>公共和私有仓库</td><td>公共和私有仓库</td><td>公共和私有仓库</td></tr><tr><td><strong>CI/CD 支持</strong></td><td>GitHub Actions</td><td>内置 CI/CD</td><td>支持 CI/CD（但功能较简单）</td><td>支持 CI/CD（通过插件）</td></tr><tr><td><strong>社区活跃度</strong></td><td>最大的开源社区，全球化</td><td>强大的社区，尤其在 DevOps 领域</td><td>主要面向国内开发者</td><td>小众社区，适合小型团队或个人使用</td></tr><tr><td><strong>集成工具</strong></td><td>GitHub Actions、第三方工具（如 Travis CI）</td><td>GitLab CI、Kubernetes、Jenkins 等</td><td>支持集成第三方 CI 工具</td><td>支持与外部工具集成（如 Jenkins、Travis）</td></tr><tr><td><strong>项目管理功能</strong></td><td>Issues、Projects、Discussions</td><td>Issues、Boards、Milestones、Wiki</td><td>Issues、Pull Requests、Wiki</td><td>Issues、Milestones、Labels、Wiki</td></tr><tr><td><strong>开源与否</strong></td><td>非开源（私有版本为 GitHub Enterprise）</td><td>GitLab CE（开源），GitLab EE（商业版）</td><td>开源，提供免费版和企业版</td><td>开源</td></tr><tr><td><strong>目标用户</strong></td><td>开源社区开发者、大型企业开发者</td><td>企业级用户、DevOps 工程师</td><td>中国开发者，面向国内市场</td><td>小型团队、个人开发者、简易自托管需求者</td></tr><tr><td><strong>语言支持</strong></td><td>多语言（支持全球开发者）</td><td>多语言（支持全球开发者）</td><td>中文为主（但支持多语言）</td><td>多语言（支持全球开发者）</td></tr><tr><td><strong>性能与资源需求</strong></td><td>大型平台，资源消耗较大</td><td>中型平台，资源消耗较大</td><td>轻量级，性能较好（国内访问快）</td><td>轻量级，资源消耗小</td></tr><tr><td><strong>界面/使用体验</strong></td><td>用户友好，功能丰富</td><td>界面功能全面，稍显复杂</td><td>界面简洁，优化国内使用体验</td><td>简洁，资源消耗小，适合快速部署</td></tr></tbody></table>
<h3 data-id="heading-84">总结：</h3>
<ul>
<li><strong>GitHub</strong> 适合开源项目，全球开发者社区最活跃，但不支持自托管。</li>
<li><strong>GitLab</strong> 提供更全面的 DevOps 管理和 CI/CD 支持，适合企业级用户并支持自托管。</li>
<li><strong>Gitee</strong> 适合国内开发者，提供良好的国内访问体验，并支持私有和公共仓库。</li>
<li><strong>Gitea</strong> 是一个轻量级的 Git 仓库平台，适合需要自托管且对资源消耗要求较低的小型团队和个人。</li>
</ul>
<p>相信各位小伙伴最熟悉的应该是GitHub，GitHub除了代码托管外，还提供非常丰富的其他功能，比如下文讲到的GitHub CI/CD等</p>
<h2 data-id="heading-85">Pull Request</h2>
<p><strong>Pull Request（PR）</strong> 是一种协作开发流程中用于合并代码的机制，常见于 Git 版本控制系统中（例如 GitHub、GitLab、Bitbucket 等平台）。开发者通过创建一个 PR 来请求将自己在某个分支上的更改合并到另一个分支，通常是主分支（<code>main</code> 或 <code>master</code>）或开发分支。</p>
<h3 data-id="heading-86"><strong>PR 的基本流程</strong>：</h3>
<ol>
<li><strong>开发者创建一个分支</strong>：开发者首先从主分支（或其他合适的分支）创建一个新的分支，进行某项功能的开发或 bug 修复。</li>
<li><strong>提交代码到分支</strong>：开发者在这个分支上进行代码修改，并将更改提交到版本控制系统中。</li>
<li><strong>创建 Pull Request</strong>：开发者完成修改后，创建一个 PR，请求将自己分支的更改合并到目标分支（如主分支）。</li>
<li><strong>代码审核（Code Review）</strong> ：项目的其他开发者（通常是团队成员或项目维护者）会查看 PR 中的代码更改，并进行审核。</li>
<li><strong>评论和讨论</strong>：如果代码存在问题或需要改进，审查者可以在 PR 中评论，开发者根据反馈进行修改。PR 提供了讨论和交流的空间，帮助团队更好地协作。</li>
<li><strong>合并（Merge）</strong> ：一旦代码审核通过并解决了所有问题，PR 就可以合并到目标分支中。通常，PR 会通过平台的界面进行合并操作，也可以使用命令行完成。</li>
</ol>
<h3 data-id="heading-87"><strong>PR 的关键功能和优点</strong>：</h3>
<ul>
<li><strong>代码审查</strong>：通过 PR，团队成员可以互相审核彼此的代码，发现潜在问题，保持代码质量。代码审查有助于提高代码的可维护性、可读性和减少错误。</li>
<li><strong>讨论与协作</strong>：PR 提供了一个集中讨论代码变更的地方，开发者可以在此讨论设计、实现方案、技术细节等，提高团队协作效率。</li>
<li><strong>持续集成（CI）和自动化测试</strong>：PR 创建时，通常会触发自动化构建和测试，帮助开发者检查代码更改是否会破坏现有功能。很多项目配置了 CI 工具（如 Jenkins、GitHub Actions、GitLab CI）来自动进行构建和测试。</li>
<li><strong>版本控制</strong>：PR 使得团队能够更容易地跟踪不同分支之间的变更历史，清晰地记录每次代码的合并和变动。</li>
<li><strong>避免冲突</strong>：PR 通过分支管理避免了直接在主分支上开发的风险，使得不同开发者的工作可以并行进行，减少了代码冲突。</li>
</ul>
<h3 data-id="heading-88"><strong>PR 常见的工作流</strong>：</h3>
<ul>
<li><strong>Fork &amp; PR</strong>：在开源项目中，开发者常常先 <code>fork</code> 一个项目的仓库到自己的账户中，做完修改后，通过提交 PR 将更改推送回原仓库。这种方式常见于 GitHub 等平台的开源项目。</li>
<li><strong>Feature Branch Workflow</strong>：开发者为每个新特性或修复创建一个独立的分支，开发完成后通过 PR 将其合并到主分支。这个工作流非常适合团队开发，可以保持主分支的稳定性。</li>
<li><strong>Gitflow Workflow</strong>：Gitflow 是一种基于分支的工作流，通常会使用不同的分支来管理功能开发、版本发布和修复。PR 是将功能分支合并到主分支或开发分支的常见方式。</li>
</ul>
<h3 data-id="heading-89"><strong>PR 的合并方式</strong>：</h3>
<ul>
<li><strong>Merge Commit</strong>：通过一个额外的合并提交将分支合并到目标分支，保留合并历史。</li>
<li><strong>Squash and Merge</strong>：将 PR 的所有提交合并成一个提交后再合并到目标分支。这有助于保持主分支的提交历史干净。</li>
<li><strong>Rebase and Merge</strong>：通过将目标分支的最新提交应用到当前分支的基础上，使得 PR 变得像是在目标分支上直接开发的，避免了合并提交的产生。</li>
</ul>
<h3 data-id="heading-90"><strong>总结</strong>：</h3>
<p>Pull Request 是一个非常重要的协作工具，帮助开发团队保持代码质量、追踪变更历史，并通过审查和讨论提升代码的质量和团队的协作效率。在现代软件开发流程中，PR 已经成为必不可少的一部分。</p>
<h2 data-id="heading-91">GitHub CI/CD</h2>
<p><strong>GitHub CI/CD</strong> 是 GitHub 提供的一种持续集成（CI）和持续部署（CD）服务。它允许开发者自动化代码的构建、测试、部署等过程，使得开发团队能够高效地进行版本控制、测试和发布。GitHub 的 CI/CD 功能通常通过 <strong>GitHub Actions</strong> 来实现。</p>
<h3 data-id="heading-92">GitHub CI/CD</h3>
<p>GitHub Actions 是 GitHub 提供的 CI/CD 服务，它允许你自动化代码的构建、测试、部署等过程。GitHub Actions 使得 CI/CD 流程能够直接集成到 GitHub 仓库中，开发者无需依赖外部 CI/CD 工具。</p>
<h3 data-id="heading-93">GitHub Actions 的主要优点</h3>
<ol>
<li><strong>集成紧密</strong>：GitHub Actions 集成在 GitHub 中，开发者无需跳转到外部 CI/CD 工具，直接在 GitHub 仓库中设置和查看工作流。</li>
<li><strong>高度可定制</strong>：你可以自定义工作流、任务、步骤，甚至创建自己的 Action，满足各种不同的需求。</li>
<li><strong>自动化与并行执行</strong>：支持并行执行任务，可以同时构建、测试多个平台或环境，提高效率。</li>
<li><strong>易于配置</strong>：通过简单的 YAML 文件来配置 CI/CD 流程，格式简洁且易于理解。</li>
<li><strong>集成 GitHub Marketplace</strong>：GitHub Actions 与 GitHub Marketplace 紧密集成，可以直接使用数千个现成的 Actions，快速集成第三方工具（如 AWS、Docker、Slack 等）。</li>
<li><strong>免费额度</strong>：对于公共仓库，GitHub Actions 是免费的。对于私有仓库，GitHub 提供了免费额度，超出部分需要付费。</li>
</ol>
<h3 data-id="heading-94"><strong>GitHub CI/CD 使用场景</strong>：</h3>
<ol>
<li><strong>自动化构建和测试</strong>：每次代码提交后，自动化构建和测试可以确保新提交的代码不会破坏现有功能，保持代码质量。</li>
<li><strong>自动化部署</strong>：当代码通过测试后，可以自动部署到测试、预生产或生产环境，简化发布流程。</li>
<li><strong>集成第三方工具</strong>：例如将测试结果发送到 Slack、将构建结果上传到 Docker Hub、将日志发送到监控平台等。</li>
<li><strong>开源项目自动化</strong>：开源项目通常需要频繁地构建和测试代码，GitHub Actions 使得这些操作更容易和高效。</li>
</ol>
<h3 data-id="heading-95"><strong>总结</strong>：</h3>
<p>GitHub CI/CD（通过 GitHub Actions）是一个强大的自动化工具，可以帮助开发者在 GitHub 仓库中直接实现持续集成、持续交付和持续部署。它提供了灵活的工作流管理、并行执行任务和自动化部署的功能，极大地提升了开发和发布效率，特别适合与 GitHub 仓库紧密集成的项目。</p>
<h2 data-id="heading-96">Docker</h2>
<p>2025年了，前端开发人员也需要掌握Docker技术</p>
<p><strong>Docker</strong> 是一个开源的容器化平台，它允许开发者将应用程序及其依赖打包到一个“容器”中。容器是一种轻量级的、可移植的、和操作系统隔离的运行环境，确保应用程序在不同环境下都能以相同的方式运行。</p>
<p>Docker 主要解决的问题是环境不一致性问题：传统的开发流程中，应用在开发环境、测试环境和生产环境中可能因为依赖版本、操作系统配置等问题而表现不同，而 Docker 则通过容器化技术使得应用在任何环境下都能保持一致。</p>
<h3 data-id="heading-97"><strong>作为前端工程师需要学习的 Docker 知识</strong>：</h3>
<p>虽然 Docker 最初是为后端开发和运维设计的，但作为前端工程师，学习 Docker 也会给你带来很多便利，尤其是在以下几个方面：</p>
<ol>
<li>
<p><strong>理解 Docker 镜像和容器的基础</strong>：</p>
<ul>
<li>学习如何构建自己的镜像，理解镜像与容器之间的关系。</li>
<li>理解 Dockerfile 的结构，学会如何创建一个合适的 Dockerfile 来构建前端应用的镜像。</li>
</ul>
</li>
<li>
<p><strong>容器化前端应用</strong>：</p>
<ul>
<li>学会将前端应用（如 React、Vue、Angular 等）容器化，使用 Docker 来打包前端应用，确保开发环境与生产环境的一致性。</li>
<li>了解如何在 Docker 容器中运行前端构建工具，如 Webpack、Parcel 等。</li>
</ul>
</li>
<li>
<p><strong>Docker Compose</strong>：</p>
<ul>
<li>学会使用 Docker Compose 来管理多容器的应用。例如，你可能需要一个前端容器和一个后端 API 容器，或者使用数据库（如 MySQL 或 MongoDB）。</li>
<li>使用 <code>docker-compose.yml</code> 文件来配置这些服务的环境，方便开发和测试。</li>
</ul>
</li>
<li>
<p><strong>跨平台一致性</strong>：</p>
<ul>
<li>使用 Docker 来确保前端应用在不同平台（如 macOS、Linux、Windows）上具有一致的开发环境，解决因为操作系统差异导致的 “它在我机器上能跑”的问题。</li>
</ul>
</li>
<li>
<p><strong>CI/CD 集成</strong>：</p>
<ul>
<li>在 CI/CD 流程中使用 Docker 进行前端自动化构建和测试。前端工程师可以在 Docker 容器中构建和测试代码，确保构建过程的可靠性。</li>
<li>将 Docker 集成到 Jenkins、GitLab CI、GitHub Actions 等自动化构建工具中，以实现自动化部署。</li>
</ul>
</li>
<li>
<p><strong>调试与日志</strong>：</p>
<ul>
<li>学习如何使用 Docker 容器调试前端应用，检查容器中的日志，排查问题。Docker 容器提供了非常方便的命令行工具来查看容器的输出和日志。</li>
</ul>
</li>
<li>
<p><strong>前端开发环境的容器化</strong>：</p>
<ul>
<li>将前端开发环境（包括 Node.js、npm、yarn 等工具）容器化，确保开发人员可以在任何机器上获得相同的开发环境配置。</li>
<li>使用 Docker 运行本地开发服务器（如开发时的 Webpack Dev Server），避免环境不一致导致的开发问题。</li>
</ul>
</li>
<li>
<p><strong>部署静态资源</strong>：</p>
<ul>
<li>将前端构建后的静态资源（如 HTML、CSS、JavaScript 文件）容器化，并通过 Docker 部署到生产环境中。</li>
</ul>
</li>
<li>
<p><strong>自动化测试</strong>：</p>
<ul>
<li>在 Docker 容器中进行端到端（E2E）测试，例如使用 Cypress 或 Selenium 进行浏览器测试，确保前端应用在不同环境下都能正常运行。</li>
</ul>
</li>
</ol>
<p>作为一名前端工程师，起码会购买云服务主机，域名，在云主机上安装docker，使用Nginx部署前端项目</p>
<h2 data-id="heading-98">Jenkins</h2>
<p><strong>Jenkins</strong> 是一个开源的自动化服务器，用于持续集成（CI）和持续交付（CD）过程。它可以帮助开发团队自动化构建、测试、部署等任务，从而提高开发效率和软件质量。Jenkins 主要用于自动化软件开发生命周期中的各个环节，尤其是在代码的构建、测试和部署过程中。</p>
<h3 data-id="heading-99"><strong>Jenkins 的核心功能</strong>：</h3>
<ol>
<li>
<p><strong>持续集成（CI）</strong> ：</p>
<ul>
<li>Jenkins 可以自动化地将开发者提交的代码集成到共享的版本控制仓库（如 Git）中。每当有新代码提交时，Jenkins 会自动拉取最新代码、编译、运行测试，并生成构建结果。</li>
</ul>
</li>
<li>
<p><strong>持续交付（CD）</strong> ：</p>
<ul>
<li>Jenkins 还支持持续交付功能，将构建后的代码自动部署到测试环境或生产环境。通过自动化部署过程，减少手动操作和人为错误。</li>
</ul>
</li>
<li>
<p><strong>自动化测试</strong>：</p>
<ul>
<li>Jenkins 可以集成自动化测试框架（如 JUnit、Selenium、Cypress 等），自动执行单元测试、集成测试和端到端测试，确保代码质量和应用稳定性。</li>
</ul>
</li>
<li>
<p><strong>可扩展性</strong>：</p>
<ul>
<li>Jenkins 拥有丰富的插件生态系统，几乎可以与所有开发工具、版本控制系统、测试框架、云平台等进行集成。通过插件，Jenkins 可以支持自定义构建步骤、通知方式、代码质量检查等。</li>
</ul>
</li>
<li>
<p><strong>Pipeline（流水线）</strong> ：</p>
<ul>
<li>Jenkins 引入了流水线（Pipeline）概念，可以通过编写 Pipeline 脚本（通常是 Groovy 语言）来定义复杂的构建、测试和部署过程。流水线可以使自动化流程更加灵活和可控。</li>
</ul>
</li>
<li>
<p><strong>分布式构建</strong>：</p>
<ul>
<li>Jenkins 支持分布式构建架构，可以通过配置多个 <strong>构建节点</strong>（slave）来将任务分配到不同的机器上，从而加快构建速度和扩展能力。</li>
</ul>
</li>
</ol>
<p>笔者认为前端工程师有必要了解Jenkins的使用</p>
<h2 data-id="heading-100">APM</h2>
<p>当项目部署上线后，需要使用一系列工具监控产品的运行情况</p>
<p><strong>APM</strong>是用于监控和管理应用程序性能的技术，旨在确保应用程序的可用性、稳定性和响应速度。APM 工具可以帮助开发团队和运维人员实时检测和诊断应用程序中的性能瓶颈，快速定位和解决问题，从而提高用户体验和业务效率。</p>
<p><strong>New Relic、Sentry 和 Dynatrace</strong> 都是流行的应用性能管理（APM）和监控工具，它们帮助开发团队监控和诊断生产环境中的应用程序和系统。每个工具的焦点和功能有所不同，但它们都旨在提高应用程序的稳定性、性能和用户体验。</p>
<h3 data-id="heading-101"><strong>工具简介：</strong></h3>
<ol>
<li>
<p><strong>New Relic</strong>：</p>
<ul>
<li><strong>New Relic</strong> 是一个全面的 <strong>应用性能管理</strong>（APM）工具，帮助团队监控应用的性能、实时获取健康状况、日志和用户行为等信息。它适用于多种技术栈（如 Java、Node.js、Python、Ruby 等），并支持全栈监控，包括前端、后端和基础设施。</li>
<li>主要功能：应用性能监控、分布式追踪、日志管理、基础设施监控、实时分析。</li>
</ul>
</li>
<li>
<p><strong>Sentry</strong>：</p>
<ul>
<li><strong>Sentry</strong> 是一个开源的错误跟踪平台，主要聚焦于 <strong>错误日志管理</strong> 和 <strong>异常跟踪</strong>。它帮助开发者实时捕获和跟踪应用中的错误、异常和崩溃，尤其是在生产环境中。Sentry 允许开发者快速定位问题，减少应用的停机时间。</li>
<li>主要功能：错误和异常监控、实时错误报告、错误上下文分析、性能监控。</li>
</ul>
</li>
<li>
<p><strong>Dynatrace</strong>：</p>
<ul>
<li><strong>Dynatrace</strong> 是一个 <strong>全栈智能监控平台</strong>，为企业提供综合的 <strong>应用性能管理（APM）</strong> 、<strong>基础设施监控</strong> 和 <strong>云监控</strong>。它不仅能够监控应用程序的性能，还能深入到每个交易、服务、容器和虚拟机的监控。Dynatrace 使用人工智能（AI）驱动的分析来自动检测异常。</li>
<li>主要功能：自动化监控、分布式追踪、深度分析、智能日志、AI 驱动的异常检测、云原生监控。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-102"><strong>工具的主要区别：</strong></h3>



















































































<table><thead><tr><th>特性</th><th><strong>New Relic</strong></th><th><strong>Sentry</strong></th><th><strong>Dynatrace</strong></th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td>应用性能管理（APM）、基础设施监控、日志管理</td><td>错误和异常跟踪，性能监控</td><td>应用性能管理（APM）、基础设施监控、云监控</td></tr><tr><td><strong>聚焦领域</strong></td><td>全栈性能监控、分布式追踪</td><td>错误捕获、异常跟踪和调试</td><td>全栈监控、AI 驱动的智能分析</td></tr><tr><td><strong>支持的技术栈</strong></td><td>支持多种技术栈，如 Java、Node.js、Python、Ruby 等</td><td>JavaScript、Python、Django、React 等</td><td>支持多种语言和平台，尤其在云原生环境中</td></tr><tr><td><strong>错误追踪</strong></td><td>支持，但以性能监控为主</td><td>强项，专注于实时错误跟踪和异常报告</td><td>支持，但主要以应用性能为主</td></tr><tr><td><strong>分布式追踪</strong></td><td>支持，追踪请求和事务的完整生命周期</td><td>部分支持，但侧重于异常跟踪</td><td>完全支持，深入到每个服务、交易和容器</td></tr><tr><td><strong>实时监控</strong></td><td>提供实时性能数据，应用、基础设施、用户行为等</td><td>仅提供错误和异常的实时报告</td><td>提供实时的性能和健康状况监控</td></tr><tr><td><strong>日志管理</strong></td><td>提供日志管理功能，集成日志分析</td><td>无专门的日志管理功能</td><td>提供智能日志管理，自动识别问题</td></tr><tr><td><strong>AI 和自动化</strong></td><td>无 AI 自动化分析</td><td>无 AI 自动化分析</td><td>内置 AI 驱动的智能监控和异常检测</td></tr><tr><td><strong>自动化根因分析</strong></td><td>提供自动根因分析，但不如 Dynatrace 强大</td><td>不支持</td><td>强大的自动根因分析，AI 驱动的智能分析</td></tr><tr><td><strong>部署方式</strong></td><td>SaaS 和自托管两种方式</td><td>云端服务</td><td>SaaS 或自托管，并支持混合部署</td></tr><tr><td><strong>适合的使用场景</strong></td><td>广泛适用于各种应用的全栈监控和性能管理</td><td>主要用于开发中的错误跟踪和异常报告</td><td>大型企业、云环境和微服务架构中的全栈监控</td></tr><tr><td><strong>价格</strong></td><td>按使用量计费（基于指标和用户数）</td><td>免费版和企业版，企业版按使用量计费</td><td>高价，适用于大企业，按使用量计费</td></tr></tbody></table>
<h3 data-id="heading-103"><strong>总结：</strong></h3>
<ul>
<li><strong>New Relic</strong> 是一个全面的 <strong>APM 平台</strong>，专注于应用性能和基础设施监控，适用于全栈监控，尤其适合大规模应用。</li>
<li><strong>Sentry</strong> 是一个 <strong>错误跟踪平台</strong>，专注于 <strong>异常监控</strong>，适用于捕捉和处理应用中的错误和崩溃，特别适合开发者进行问题调试。</li>
<li><strong>Dynatrace</strong> 提供强大的 <strong>AI 驱动的全栈监控</strong>，不仅监控应用性能，还可以深入到云原生架构、容器、微服务等多个层级，适用于企业级应用和复杂环境。</li>
</ul>
<h3 data-id="heading-104"><strong>适用场景</strong>：</h3>
<ul>
<li>如果你的主要需求是 <strong>应用性能监控</strong> 和 <strong>分布式追踪</strong>，并且需要全栈支持，<strong>New Relic</strong> 和 <strong>Dynatrace</strong> 是较好的选择。</li>
<li>如果你主要关注 <strong>错误跟踪</strong> 和 <strong>异常管理</strong>，尤其是开发阶段，<strong>Sentry</strong> 更为合适。</li>
</ul>
<p>这些工具之间的选择很大程度上取决于你的项目需求，团队规模以及你所在的技术栈。APM 产品有很多，大部分产品需要付费才能使用全部功能，根据业务需求和公司规定选择合适的工具</p></div></div>