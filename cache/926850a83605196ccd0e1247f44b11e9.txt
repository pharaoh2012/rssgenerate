
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18707002" title="发布于 2025-02-10 01:47">
    <span role="heading" aria-level="2">【忍者算法】从照片旋转到矩阵变换：探索图像旋转问题｜LeetCode 48 旋转图像</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从照片旋转到矩阵变换探索图像旋转问题">从照片旋转到矩阵变换：探索图像旋转问题</h1>
<h2 id="生活中的旋转">生活中的旋转</h2>
<p>在这个自拍时代，我们经常需要调整照片的方向。有时拍出来的照片歪了，需要旋转90度；有时想要换个角度看看效果，来回旋转照片。这种旋转操作不仅存在于我们的日常生活中，在计算机图形学、图像处理等领域也是一个基础且重要的操作。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第48题"旋转图像"要求我们：给定一个 n × n 的二维矩阵 matrix 表示一个图像，将图像顺时针旋转 90 度。要求必须在原地旋转图像，也就是说，你需要直接修改输入的二维矩阵。</p>
<p>例如：</p>
<pre><code>输入：matrix = [[1,2,3],
                [4,5,6],
                [7,8,9]]
输出：[[7,4,1],
       [8,5,2],
       [9,6,3]]
</code></pre>
<p>就像我们在手机相册里旋转照片一样，每个像素点都要移动到新的位置，但我们需要保证不使用额外的存储空间！</p>
<h2 id="最直观的解法辅助数组">最直观的解法：辅助数组</h2>
<p>最简单的想法就像我们复印一张照片，在新的纸上重新排列像素。虽然这种方法使用了额外空间，不符合题目要求，但它帮助我们理解旋转的本质。</p>
<h3 id="辅助数组的实现">辅助数组的实现</h3>
<pre><code class="language-java">public void rotate(int[][] matrix) {
    int n = matrix.length;
    // 创建一个新的n×n数组
    int[][] temp = new int[n][n];
    
    // 将原矩阵旋转90度后的结果存入临时数组
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            // 关键转换：第i行第j列的元素，旋转后变成第j行第(n-1-i)列
            temp[j][n-1-i] = matrix[i][j];
        }
    }
    
    // 将结果复制回原矩阵
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            matrix[i][j] = temp[i][j];
        }
    }
}
</code></pre>
<h2 id="优化解法原地旋转">优化解法：原地旋转</h2>
<p>仔细观察，我们发现90度旋转可以通过两步简单的操作完成：先沿对角线翻转，再沿竖直中线翻转。就像折纸一样，通过两次折叠就能达到旋转的效果！</p>
<h3 id="原地旋转的原理">原地旋转的原理</h3>
<p>想象你在玩魔方：</p>
<ol>
<li>第一步：沿主对角线翻转（左上到右下的对角线）
<ul>
<li>[i,j] 变成 [j,i]</li>
</ul>
</li>
<li>第二步：沿竖直中线翻转
<ul>
<li>[i,j] 变成 [i,n-1-j]</li>
</ul>
</li>
</ol>
<h3 id="示例运行">示例运行</h3>
<p>用3×3矩阵来说明：</p>
<pre><code>原始矩阵：    对角线翻转：    竖直中线翻转：
1 2 3         1 4 7          7 4 1
4 5 6   →     2 5 8    →     8 5 2
7 8 9         3 6 9          9 6 3

第一步：对角线翻转
- (1,2)和(2,1)交换
- (1,3)和(3,1)交换
- (2,3)和(3,2)交换

第二步：竖直中线翻转
- 第1列和第3列交换
- 第2列保持不变
</code></pre>
<h3 id="java代码实现">Java代码实现</h3>
<pre><code class="language-java">public void rotate(int[][] matrix) {
    int n = matrix.length;
    
    // 步骤1：沿主对角线翻转
    for (int i = 0; i &lt; n; i++) {
        for (int j = i; j &lt; n; j++) {
            // 交换matrix[i][j]和matrix[j][i]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    // 步骤2：沿竖直中线翻转
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n/2; j++) {
            // 交换matrix[i][j]和matrix[i][n-1-j]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n-1-j];
            matrix[i][n-1-j] = temp;
        }
    }
}
</code></pre>
<h2 id="解法比较">解法比较</h2>
<p>让我们比较这两种方法：</p>
<p>辅助数组法：</p>
<ul>
<li>时间复杂度：O(n²)</li>
<li>空间复杂度：O(n²)</li>
<li>优点：直观易懂，容易实现</li>
<li>缺点：需要额外空间，不满足原地旋转的要求</li>
</ul>
<p>原地旋转法：</p>
<ul>
<li>时间复杂度：O(n²)</li>
<li>空间复杂度：O(1)</li>
<li>优点：不需要额外空间，完美满足题目要求</li>
<li>缺点：需要理解矩阵变换的数学原理</li>
</ul>
<h2 id="实用技巧总结">实用技巧总结</h2>
<p>解决矩阵旋转问题的关键点：</p>
<ol>
<li>观察旋转前后元素位置的对应关系</li>
<li>寻找可以分解的子操作（如翻转）</li>
<li>正确处理边界情况</li>
<li>小心不要重复交换元素</li>
</ol>
<p>相关的矩阵变换问题：</p>
<ul>
<li>矩阵转置</li>
<li>矩阵对称变换</li>
<li>顺时针/逆时针旋转任意角度</li>
</ul>
<h2 id="小结">小结</h2>
<p>通过旋转图像这道题，我们学会了如何通过巧妙的数学变换来完成矩阵旋转。这种思维方式不仅能解决算法题，在图像处理、计算机图形学等领域都有广泛应用。记住，当遇到需要变换矩阵的问题时，可以考虑将复杂的变换分解为简单的操作组合，这样往往能得到更优雅的解决方案！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.020413142606481482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 01:47">2025-02-10 01:47</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18707002" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18707002);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18707002', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18707002', title: '【忍者算法】从照片旋转到矩阵变换：探索图像旋转问题｜LeetCode 48 旋转图像' })">举报</a>
</div>
        