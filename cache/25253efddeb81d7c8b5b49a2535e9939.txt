
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18860975" title="发布于 2025-05-06 15:13">
    <span role="heading" aria-level="2">RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 区别及应用场景</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="randomaccessfilefileinputstreammappedbytebufferfilechannel-比较">RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 比较</h1>
<p>这些类都是Java中用于文件I/O操作的类，但各有特点和适用场景。下面我将详细介绍它们的区别、使用场景以及相关类。</p>
<h2 id="主要区别">主要区别</h2>
<table>
<thead>
<tr>
<th>类/接口</th>
<th>特点</th>
<th>线程安全</th>
<th>性能</th>
<th>功能丰富度</th>
</tr>
</thead>
<tbody>
<tr>
<td>RandomAccessFile</td>
<td>可随机读写，功能全面但API较老</td>
<td>是</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>只能顺序读取，简单易用</td>
<td>是</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td>MappedByteBuffer</td>
<td>内存映射文件，高性能随机访问</td>
<td>否</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>FileChannel</td>
<td>NIO的核心通道，支持多种操作(传输、锁定、内存映射等)，功能强大且灵活</td>
<td>是</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2 id="详细说明及使用场景">详细说明及使用场景</h2>
<h3 id="1-randomaccessfile">1. RandomAccessFile</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>可读可写，支持随机访问(通过seek()方法)</li>
<li>支持基本数据类型(如readInt(), writeDouble()等)</li>
<li>基于文件指针操作</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要同时读写文件的场景</li>
<li>需要随机访问文件的场景(如数据库实现)</li>
<li>需要操作基本数据类型的场景</li>
</ul>
<p><strong>示例</strong>：<br>
<a href="https://www.cnblogs.com/vipsoft/p/16252698.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16252698.html</a><br>
断点续传（上传）Java版: <a href="https://www.cnblogs.com/vipsoft/p/15951660.html" target="_blank">https://www.cnblogs.com/vipsoft/p/15951660.html</a></p>
<pre><code class="language-java">RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");
raf.seek(100);  // 移动到第100字节
raf.writeInt(123);
raf.close();
</code></pre>
<h3 id="2-fileinputstream">2. FileInputStream</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>只能顺序读取，不能写入</li>
<li>简单的字节流读取</li>
<li>通常与BufferedInputStream配合使用提高性能</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>只需顺序读取文件的简单场景</li>
<li>读取小文件</li>
<li>与其他装饰器流配合使用(如BufferedInputStream)</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">FileInputStream fis = new FileInputStream("file.txt");
byte[] buffer = new byte[1024];
int bytesRead = fis.read(buffer);
fis.close();
</code></pre>
<h3 id="3-mappedbytebuffer">3. MappedByteBuffer</h3>
<p><img src="https://img2022.cnblogs.com/blog/80824/202207/80824-20220729174651639-1736363270.png" alt="image" loading="lazy"></p>
<p><strong>特点</strong>：</p>
<ul>
<li>通过内存映射文件提供高性能访问</li>
<li>直接操作内存，避免了用户空间和内核空间的数据拷贝</li>
<li>适合大文件操作</li>
<li>非线程安全</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要高性能随机访问大文件</li>
<li>内存数据库实现</li>
<li>文件共享场景</li>
</ul>
<p><strong>示例</strong>：<br>
<a href="https://www.cnblogs.com/vipsoft/p/16533152.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16533152.html</a><br>
<a href="https://www.cnblogs.com/vipsoft/p/16458161.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16458161.html</a></p>
<pre><code class="language-java">RandomAccessFile file = new RandomAccessFile("largefile.dat", "rw");
FileChannel channel = file.getChannel();
MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());

// 直接操作buffer
buffer.put(0, (byte)123);
buffer.force();  // 强制刷新到磁盘
</code></pre>
<h3 id="4-filechannel">4. FileChannel</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>NIO的核心文件操作类</li>
<li>支持多种高级功能：文件锁定、内存映射、分散/聚集I/O、文件间传输等</li>
<li>通常比传统I/O性能更好</li>
<li>线程安全</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要高性能文件操作的场景</li>
<li>需要文件锁定的场景</li>
<li>大文件传输(transferTo/transferFrom)</li>
<li>与Selector配合实现非阻塞I/O(虽然文件通道不能完全非阻塞)</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
FileChannel channel = file.getChannel();

// 文件锁定
FileLock lock = channel.lock();

// 文件传输
FileChannel destChannel = new FileOutputStream("dest.txt").getChannel();
channel.transferTo(0, channel.size(), destChannel);

channel.close();
</code></pre>
<h2 id="相关联的重要类">相关联的重要类</h2>
<ol>
<li><strong>BufferedInputStream/BufferedOutputStream</strong>：提供缓冲功能，提高I/O性能</li>
<li><strong>BufferedReader/BufferedWriter</strong>：提供字符缓冲功能，支持按行读写</li>
<li><strong>FileOutputStream</strong>：对应FileInputStream的写入类</li>
<li><strong>ByteBuffer</strong>：NIO中的缓冲区类，与Channel配合使用 <a href="https://www.cnblogs.com/vipsoft/p/16547142.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16547142.html</a></li>
<li><strong>Selector</strong>：NIO多路复用器，用于非阻塞I/O(虽然文件通道不完全支持)</li>
<li><strong>Files</strong> (Java 7+ NIO.2)：提供很多实用静态方法操作文件</li>
<li><strong>Path/Paths</strong> (Java 7+ NIO.2)：现代文件路径操作类</li>
<li><strong>AsynchronousFileChannel</strong> (Java 7+)：异步文件通道</li>
<li><strong>FileLock</strong>：文件锁定功能: <a href="https://www.cnblogs.com/vipsoft/p/16540562.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16540562.html</a></li>
</ol>
<h2 id="性能比较">性能比较</h2>
<p>一般来说性能排序(从高到低)：</p>
<ol>
<li>MappedByteBuffer (内存映射文件)</li>
<li>FileChannel (特别是使用transferTo/transferFrom时)</li>
<li>BufferedInputStream/BufferedOutputStream (有缓冲)</li>
<li>RandomAccessFile</li>
<li>原始FileInputStream/FileOutputStream (无缓冲)</li>
</ol>
<h2 id="选择建议">选择建议</h2>
<ul>
<li><strong>简单读取</strong>：FileInputStream + BufferedInputStream</li>
<li><strong>需要随机访问</strong>：RandomAccessFile 或 FileChannel + MappedByteBuffer</li>
<li><strong>高性能需求</strong>：FileChannel + MappedByteBuffer</li>
<li><strong>大文件传输</strong>：FileChannel的transferTo/transferFrom</li>
<li><strong>现代Java开发</strong>：优先考虑NIO.2 (Java 7+)的Files和Path API</li>
</ul>
<p>Java 7引入的NIO.2 (java.nio.file包)提供了更现代的API，对于新项目推荐优先考虑使用这些新API。</p>
<p>在 Java 中，你可以使用 <code>RandomAccessFile</code> 或 <code>FileInputStream</code> 来从指定偏移量（offset）读取指定长度的字节数据。以下是两种实现方式：</p>
<hr>
<h3 id="方法-1使用-randomaccessfile推荐"><strong>方法 1：使用 <code>RandomAccessFile</code>（推荐）</strong></h3>
<p><code>RandomAccessFile</code> 可以直接跳转到文件的指定位置进行读取，适合随机访问文件。</p>
<pre><code class="language-java">import java.io.IOException;
import java.io.RandomAccessFile;

public class ReadFileFromOffset {
    public static void main(String[] args) {
        String filePath = "your_file.bin"; // 替换为你的文件路径
        int offset = 10;                  // 起始偏移量
        int length = 2;                   // 要读取的字节数

        try (RandomAccessFile raf = new RandomAccessFile(filePath, "r")) {
            // 跳转到指定偏移量
            raf.seek(offset);

            // 读取指定长度的字节
            byte[] buffer = new byte[length];
            int bytesRead = raf.read(buffer);

            if (bytesRead != length) {
                System.err.println("未能读取足够字节，可能已到文件末尾");
            } else {
                System.out.println("读取的字节数据: " + bytesToHex(buffer));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 辅助方法：将字节数组转为十六进制字符串（方便查看）
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString();
    }
}
</code></pre>
<hr>
<h3 id="方法-2使用-fileinputstream"><strong>方法 2：使用 <code>FileInputStream</code></strong></h3>
<p><code>FileInputStream</code> 也可以读取指定偏移量的数据，但需要手动跳过前面的字节。</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class ReadFileFromOffsetWithStream {
    public static void main(String[] args) {
        String filePath = "your_file.bin"; // 替换为你的文件路径
        int offset = 10;                  // 起始偏移量
        int length = 2;                   // 要读取的字节数

        try (FileInputStream fis = new FileInputStream(filePath)) {
            // 跳过 offset 之前的字节
            long skipped = fis.skip(offset);
            if (skipped != offset) {
                System.err.println("无法跳过足够字节，可能文件太小");
                return;
            }

            // 读取指定长度的字节
            byte[] buffer = new byte[length];
            int bytesRead = fis.read(buffer);

            if (bytesRead != length) {
                System.err.println("未能读取足够字节，可能已到文件末尾");
            } else {
                System.out.println("读取的字节数据: " + bytesToHex(buffer));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 辅助方法：将字节数组转为十六进制字符串
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString();
    }
}
</code></pre>
<hr>
<h3 id="关键点说明"><strong>关键点说明</strong></h3>
<ol>
<li>
<p><strong><code>RandomAccessFile</code> vs <code>FileInputStream</code></strong>：</p>
<ul>
<li><code>RandomAccessFile</code> 更适合随机访问（如频繁跳转偏移量）。</li>
<li><code>FileInputStream</code> 适用于顺序读取，但也可以手动 <code>skip()</code> 到指定位置。</li>
</ul>
</li>
<li>
<p><strong><code>seek(offset)</code> 和 <code>skip(offset)</code></strong>：</p>
<ul>
<li><code>RandomAccessFile.seek(offset)</code> 直接定位到 <code>offset</code>。</li>
<li><code>FileInputStream.skip(offset)</code> 跳过 <code>offset</code> 字节，但可能受流限制（如网络流可能无法跳过）。</li>
</ul>
</li>
<li>
<p><strong>字节读取</strong>：</p>
<ul>
<li><code>read(byte[])</code> 返回实际读取的字节数，可能小于请求的长度（如文件末尾）。</li>
</ul>
</li>
<li>
<p><strong>异常处理</strong>：</p>
<ul>
<li>需处理 <code>IOException</code>（如文件不存在或权限问题）。</li>
</ul>
</li>
<li>
<p><strong>字节转十六进制</strong>：</p>
<ul>
<li>示例代码提供了 <code>bytesToHex()</code> 方法方便查看字节数据（如 <code>1A 2B</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="输出示例"><strong>输出示例</strong></h3>
<p>如果文件 <code>your_file.bin</code> 在 <code>offset=10</code> 处的 2 个字节是 <code>0x41</code> 和 <code>0x42</code>（即 ASCII 字符 <code>A</code> 和 <code>B</code>），输出：</p>
<pre><code>读取的字节数据: 41 42
</code></pre>
<hr>
<h3 id="适用场景"><strong>适用场景</strong></h3>
<ul>
<li>读取二进制文件（如 <code>.bin</code>、<code>.dat</code>）。</li>
<li>解析文件头、特定偏移量的数据（如文件格式解析）。</li>
<li>网络协议解析（如从固定位置读取字段）。</li>
</ul>
<p>如果需要更复杂的文件操作（如内存映射），可以考虑 <code>java.nio</code> 的 <code>FileChannel</code> 和 <code>MappedByteBuffer</code>。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18860975" target="_blank">https://www.cnblogs.com/vipsoft/p/18860975</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7433778695578703" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-06 15:20">2025-05-06 15:13</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">106</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18860975);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18860975', targetLink: 'https://www.cnblogs.com/vipsoft/p/18860975', title: 'RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 区别及应用场景' })">举报</a>
</div>
        