
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18860975" title="发布于 2025-05-06 15:13">
    <span role="heading" aria-level="2">RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 区别、应用场景及示例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#主要区别" rel="noopener nofollow">主要区别</a></li><li><a href="#详细说明及使用场景" rel="noopener nofollow">详细说明及使用场景</a><ul><li><a href="#1-randomaccessfile" rel="noopener nofollow">1. RandomAccessFile</a></li><li><a href="#2-fileinputstream" rel="noopener nofollow">2. FileInputStream</a></li><li><a href="#3-mappedbytebuffer" rel="noopener nofollow">3. MappedByteBuffer</a></li><li><a href="#4-filechannel" rel="noopener nofollow">4. FileChannel</a></li></ul></li><li><a href="#相关联的重要类" rel="noopener nofollow">相关联的重要类</a></li><li><a href="#性能比较" rel="noopener nofollow">性能比较</a></li><li><a href="#选择建议" rel="noopener nofollow">选择建议</a><ul><li><a href="#方法-1使用-randomaccessfile推荐" rel="noopener nofollow"><strong>方法 1：使用 <code>RandomAccessFile</code>（推荐）</strong></a></li><li><a href="#方法-2使用-fileinputstream" rel="noopener nofollow"><strong>方法 2：使用 <code>FileInputStream</code></strong></a></li><li><a href="#关键点说明" rel="noopener nofollow"><strong>关键点说明</strong></a></li><li><a href="#输出示例" rel="noopener nofollow"><strong>输出示例</strong></a></li><li><a href="#适用场景" rel="noopener nofollow"><strong>适用场景</strong></a></li></ul></li><li><a href="#filechannel-示例" rel="noopener nofollow">FileChannel 示例</a><ul><li><a href="#1-使用-filechannel-写入文件推荐" rel="noopener nofollow"><strong>1. 使用 <code>FileChannel</code> 写入文件（推荐）</strong></a></li><li><a href="#2-关键优化点说明" rel="noopener nofollow"><strong>2. 关键优化点说明</strong></a><ul><li><a href="#1性能优势" rel="noopener nofollow"><strong>（1）性能优势</strong></a></li><li><a href="#2跳过前5字节的写法" rel="noopener nofollow"><strong>（2）跳过前5字节的写法</strong></a></li></ul></li><li><a href="#3-高级用法内存映射文件超大文件优化" rel="noopener nofollow"><strong>3. 高级用法：内存映射文件（超大文件优化）</strong></a></li><li><a href="#4-多线程写入示例" rel="noopener nofollow"><strong>4. 多线程写入示例</strong></a></li><li><a href="#逐行处理--直接写入-filechannel推荐" rel="noopener nofollow">逐行处理 → 直接写入 FileChannel（推荐）</a></li><li><a href="#5-性能对比测试" rel="noopener nofollow"><strong>5. 性能对比测试</strong></a></li><li><a href="#6-总结" rel="noopener nofollow"><strong>6. 总结</strong></a></li></ul></li><li><a href="#何时使用-randomaccessfile--filechannel" rel="noopener nofollow"><strong>何时使用 <code>RandomAccessFile + FileChannel</code>？</strong></a><ul><li><a href="#最终建议" rel="noopener nofollow"><strong>最终建议</strong></a></li></ul></li><li><a href="#缓冲区的管理" rel="noopener nofollow">缓冲区的管理</a><ul><li><a href="#1-缓冲区的管理步骤" rel="noopener nofollow"><strong>1. 缓冲区的管理步骤</strong></a><ul><li><a href="#1-初始化缓冲区" rel="noopener nofollow"><strong>(1) 初始化缓冲区</strong></a></li><li><a href="#2-填充缓冲区" rel="noopener nofollow"><strong>(2) 填充缓冲区</strong></a></li><li><a href="#3-触发写入条件" rel="noopener nofollow"><strong>(3) 触发写入条件</strong></a></li></ul></li><li><a href="#2-完整代码示例带缓冲区管理" rel="noopener nofollow"><strong>2. 完整代码示例（带缓冲区管理）</strong></a></li><li><a href="#3-关键注意事项" rel="noopener nofollow"><strong>3. 关键注意事项</strong></a><ul><li><a href="#1-缓冲区模式切换" rel="noopener nofollow"><strong>(1) 缓冲区模式切换</strong></a></li><li><a href="#2-直接缓冲区-vs-堆缓冲区" rel="noopener nofollow"><strong>(2) 直接缓冲区 vs 堆缓冲区</strong></a></li><li><a href="#3-异常处理" rel="noopener nofollow"><strong>(3) 异常处理</strong></a></li><li><a href="#4-性能调优" rel="noopener nofollow"><strong>(4) 性能调优</strong></a></li></ul></li><li><a href="#4-高级优化内存映射文件mappedbytebuffer" rel="noopener nofollow"><strong>4. 高级优化：内存映射文件（MappedByteBuffer）</strong></a></li><li><a href="#总结" rel="noopener nofollow"><strong>总结</strong></a></li></ul></li></ul></div><br>
RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 比较<p></p>
<p>这些类都是Java中用于文件I/O操作的类，但各有特点和适用场景。下面我将详细介绍它们的区别、使用场景以及相关类。</p>
<h2 id="主要区别">主要区别</h2>
<table>
<thead>
<tr>
<th>类/接口</th>
<th>特点</th>
<th>线程安全</th>
<th>性能</th>
<th>功能丰富度</th>
</tr>
</thead>
<tbody>
<tr>
<td>RandomAccessFile</td>
<td>可随机读写，功能全面但API较老</td>
<td>是</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>只能顺序读取，简单易用</td>
<td>是</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td>MappedByteBuffer</td>
<td>内存映射文件，高性能随机访问</td>
<td>否</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>FileChannel</td>
<td>NIO的核心通道，支持多种操作(传输、锁定、内存映射等)，功能强大且灵活</td>
<td>是</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2 id="详细说明及使用场景">详细说明及使用场景</h2>
<h3 id="1-randomaccessfile">1. RandomAccessFile</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>可读可写，支持随机访问(通过seek()方法)</li>
<li>支持基本数据类型(如readInt(), writeDouble()等)</li>
<li>基于文件指针操作</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要同时读写文件的场景</li>
<li>需要随机访问文件的场景(如数据库实现)</li>
<li>需要操作基本数据类型的场景</li>
</ul>
<p><strong>示例</strong>：<br>
<a href="https://www.cnblogs.com/vipsoft/p/16252698.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16252698.html</a><br>
断点续传（上传）Java版: <a href="https://www.cnblogs.com/vipsoft/p/15951660.html" target="_blank">https://www.cnblogs.com/vipsoft/p/15951660.html</a></p>
<pre><code class="language-java">RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");
raf.seek(100);  // 移动到第100字节
raf.writeInt(123);
raf.close();
</code></pre>
<h3 id="2-fileinputstream">2. FileInputStream</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>只能顺序读取，不能写入</li>
<li>简单的字节流读取</li>
<li>通常与BufferedInputStream配合使用提高性能</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>只需顺序读取文件的简单场景</li>
<li>读取小文件</li>
<li>与其他装饰器流配合使用(如BufferedInputStream)</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">FileInputStream fis = new FileInputStream("file.txt");
byte[] buffer = new byte[1024];
int bytesRead = fis.read(buffer);
fis.close();
</code></pre>
<h3 id="3-mappedbytebuffer">3. MappedByteBuffer</h3>
<p><img src="https://img2022.cnblogs.com/blog/80824/202207/80824-20220729174651639-1736363270.png" alt="image" loading="lazy"></p>
<p><strong>特点</strong>：</p>
<ul>
<li>通过内存映射文件提供高性能访问</li>
<li>直接操作内存，避免了用户空间和内核空间的数据拷贝</li>
<li>适合大文件操作</li>
<li>非线程安全</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要高性能随机访问大文件</li>
<li>内存数据库实现</li>
<li>文件共享场景</li>
</ul>
<p><strong>示例</strong>：<br>
<a href="https://www.cnblogs.com/vipsoft/p/16533152.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16533152.html</a><br>
<a href="https://www.cnblogs.com/vipsoft/p/16458161.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16458161.html</a></p>
<pre><code class="language-java">RandomAccessFile file = new RandomAccessFile("largefile.dat", "rw");
FileChannel channel = file.getChannel();
MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());

// 直接操作buffer
buffer.put(0, (byte)123);
buffer.force();  // 强制刷新到磁盘
</code></pre>
<h3 id="4-filechannel">4. FileChannel</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>NIO的核心文件操作类</li>
<li>支持多种高级功能：文件锁定、内存映射、分散/聚集I/O、文件间传输等</li>
<li>通常比传统I/O性能更好</li>
<li>线程安全</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要高性能文件操作的场景</li>
<li>需要文件锁定的场景</li>
<li>大文件传输(transferTo/transferFrom)</li>
<li>与Selector配合实现非阻塞I/O(虽然文件通道不能完全非阻塞)</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
FileChannel channel = file.getChannel();

// 文件锁定
FileLock lock = channel.lock();

// 文件传输
FileChannel destChannel = new FileOutputStream("dest.txt").getChannel();
channel.transferTo(0, channel.size(), destChannel);

channel.close();
</code></pre>
<h2 id="相关联的重要类">相关联的重要类</h2>
<ol>
<li><strong>BufferedInputStream/BufferedOutputStream</strong>：提供缓冲功能，提高I/O性能</li>
<li><strong>BufferedReader/BufferedWriter</strong>：提供字符缓冲功能，支持按行读写</li>
<li><strong>FileOutputStream</strong>：对应FileInputStream的写入类</li>
<li><strong>ByteBuffer</strong>：NIO中的缓冲区类，与Channel配合使用 <a href="https://www.cnblogs.com/vipsoft/p/16547142.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16547142.html</a></li>
<li><strong>Selector</strong>：NIO多路复用器，用于非阻塞I/O(虽然文件通道不完全支持)</li>
<li><strong>Files</strong> (Java 7+ NIO.2)：提供很多实用静态方法操作文件</li>
<li><strong>Path/Paths</strong> (Java 7+ NIO.2)：现代文件路径操作类</li>
<li><strong>AsynchronousFileChannel</strong> (Java 7+)：异步文件通道</li>
<li><strong>FileLock</strong>：文件锁定功能: <a href="https://www.cnblogs.com/vipsoft/p/16540562.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16540562.html</a></li>
</ol>
<h2 id="性能比较">性能比较</h2>
<p>一般来说性能排序(从高到低)：</p>
<ol>
<li>MappedByteBuffer (内存映射文件)</li>
<li>FileChannel (特别是使用transferTo/transferFrom时)</li>
<li>BufferedInputStream/BufferedOutputStream (有缓冲)</li>
<li>RandomAccessFile</li>
<li>原始FileInputStream/FileOutputStream (无缓冲)</li>
</ol>
<h2 id="选择建议">选择建议</h2>
<ul>
<li><strong>简单读取</strong>：FileInputStream + BufferedInputStream</li>
<li><strong>需要随机访问</strong>：RandomAccessFile 或 FileChannel + MappedByteBuffer</li>
<li><strong>高性能需求</strong>：FileChannel + MappedByteBuffer</li>
<li><strong>大文件传输</strong>：FileChannel的transferTo/transferFrom</li>
<li><strong>现代Java开发</strong>：优先考虑NIO.2 (Java 7+)的Files和Path API</li>
</ul>
<p>Java 7引入的NIO.2 (java.nio.file包)提供了更现代的API，对于新项目推荐优先考虑使用这些新API。</p>
<p>在 Java 中，你可以使用 <code>RandomAccessFile</code> 或 <code>FileInputStream</code> 来从指定偏移量（offset）读取指定长度的字节数据。以下是两种实现方式：</p>
<hr>
<h3 id="方法-1使用-randomaccessfile推荐"><strong>方法 1：使用 <code>RandomAccessFile</code>（推荐）</strong></h3>
<p><code>RandomAccessFile</code> 可以直接跳转到文件的指定位置进行读取，适合随机访问文件。</p>
<pre><code class="language-java">import java.io.IOException;
import java.io.RandomAccessFile;

public class ReadFileFromOffset {
    public static void main(String[] args) {
        String filePath = "your_file.bin"; // 替换为你的文件路径
        int offset = 10;                  // 起始偏移量
        int length = 2;                   // 要读取的字节数

        try (RandomAccessFile raf = new RandomAccessFile(filePath, "r")) {
            // 跳转到指定偏移量
            raf.seek(offset);

            // 读取指定长度的字节
            byte[] buffer = new byte[length];
            int bytesRead = raf.read(buffer);

            if (bytesRead != length) {
                System.err.println("未能读取足够字节，可能已到文件末尾");
            } else {
                System.out.println("读取的字节数据: " + bytesToHex(buffer));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 辅助方法：将字节数组转为十六进制字符串（方便查看）
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString();
    }
}
</code></pre>
<hr>
<h3 id="方法-2使用-fileinputstream"><strong>方法 2：使用 <code>FileInputStream</code></strong></h3>
<p><code>FileInputStream</code> 也可以读取指定偏移量的数据，但需要手动跳过前面的字节。</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class ReadFileFromOffsetWithStream {
    public static void main(String[] args) {
        String filePath = "your_file.bin"; // 替换为你的文件路径
        int offset = 10;                  // 起始偏移量
        int length = 2;                   // 要读取的字节数

        try (FileInputStream fis = new FileInputStream(filePath)) {
            // 跳过 offset 之前的字节
            long skipped = fis.skip(offset);
            if (skipped != offset) {
                System.err.println("无法跳过足够字节，可能文件太小");
                return;
            }

            // 读取指定长度的字节
            byte[] buffer = new byte[length];
            int bytesRead = fis.read(buffer);

            if (bytesRead != length) {
                System.err.println("未能读取足够字节，可能已到文件末尾");
            } else {
                System.out.println("读取的字节数据: " + bytesToHex(buffer));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 辅助方法：将字节数组转为十六进制字符串
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString();
    }
}
</code></pre>
<hr>
<h3 id="关键点说明"><strong>关键点说明</strong></h3>
<ol>
<li>
<p><strong><code>RandomAccessFile</code> vs <code>FileInputStream</code></strong>：</p>
<ul>
<li><code>RandomAccessFile</code> 更适合随机访问（如频繁跳转偏移量）。</li>
<li><code>FileInputStream</code> 适用于顺序读取，但也可以手动 <code>skip()</code> 到指定位置。</li>
</ul>
</li>
<li>
<p><strong><code>seek(offset)</code> 和 <code>skip(offset)</code></strong>：</p>
<ul>
<li><code>RandomAccessFile.seek(offset)</code> 直接定位到 <code>offset</code>。</li>
<li><code>FileInputStream.skip(offset)</code> 跳过 <code>offset</code> 字节，但可能受流限制（如网络流可能无法跳过）。</li>
</ul>
</li>
<li>
<p><strong>字节读取</strong>：</p>
<ul>
<li><code>read(byte[])</code> 返回实际读取的字节数，可能小于请求的长度（如文件末尾）。</li>
</ul>
</li>
<li>
<p><strong>异常处理</strong>：</p>
<ul>
<li>需处理 <code>IOException</code>（如文件不存在或权限问题）。</li>
</ul>
</li>
<li>
<p><strong>字节转十六进制</strong>：</p>
<ul>
<li>示例代码提供了 <code>bytesToHex()</code> 方法方便查看字节数据（如 <code>1A 2B</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="输出示例"><strong>输出示例</strong></h3>
<p>如果文件 <code>your_file.bin</code> 在 <code>offset=10</code> 处的 2 个字节是 <code>0x41</code> 和 <code>0x42</code>（即 ASCII 字符 <code>A</code> 和 <code>B</code>），输出：</p>
<pre><code>读取的字节数据: 41 42
</code></pre>
<hr>
<h3 id="适用场景"><strong>适用场景</strong></h3>
<ul>
<li>读取二进制文件（如 <code>.bin</code>、<code>.dat</code>）。</li>
<li>解析文件头、特定偏移量的数据（如文件格式解析）。</li>
<li>网络协议解析（如从固定位置读取字段）。</li>
</ul>
<p>如果需要更复杂的文件操作（如内存映射），可以考虑 <code>java.nio</code> 的 <code>FileChannel</code> 和 <code>MappedByteBuffer</code>。</p>
<h2 id="filechannel-示例">FileChannel 示例</h2>
<p>将 <code>FileOutputStream</code> 改为 <code>FileChannel</code> 可以提高文件写入性能，尤其是在处理大文件或多线程场景时。以下是使用 <strong>FileChannel</strong> 的优化实现，并对比两者的性能差异：</p>
<hr>
<h3 id="1-使用-filechannel-写入文件推荐"><strong>1. 使用 <code>FileChannel</code> 写入文件（推荐）</strong></h3>
<pre><code class="language-java">import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class HexToFileWithFileChannel {
    public static void main(String[] args) {
        String hexStr = "02fc0b..."; // 你的完整十六进制字符串
        String filePath = "output.bin";

        try {
            // 1. 转换十六进制字符串为 byte[]
            byte[] bytes = hexStringToByteArray(hexStr);

            // 2. 使用 FileChannel 写入（高性能）
            try (FileChannel channel = FileChannel.open(
                    Paths.get(filePath),
                    StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE,
                    StandardOpenOption.TRUNCATE_EXISTING)) {

                ByteBuffer buffer = ByteBuffer.wrap(bytes);
                channel.write(buffer); // 写入全部字节

                // 如果需要跳过前5字节：
                // buffer.position(5); // 设置偏移量
                // channel.write(buffer); // 从第5字节开始写入
            }
            System.out.println("FileChannel 写入成功！");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static byte[] hexStringToByteArray(String hexStr) {
        hexStr = hexStr.replaceAll("\\s+", "");
        if (hexStr.length() % 2 != 0) {
            throw new IllegalArgumentException("十六进制字符串长度必须是偶数");
        }
        byte[] bytes = new byte[hexStr.length() / 2];
        for (int i = 0; i &lt; hexStr.length(); i += 2) {
            bytes[i / 2] = (byte) Integer.parseInt(hexStr.substring(i, i + 2), 16);
        }
        return bytes;
    }
}
</code></pre>
<hr>
<h3 id="2-关键优化点说明"><strong>2. 关键优化点说明</strong></h3>
<h4 id="1性能优势"><strong>（1）性能优势</strong></h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>FileOutputStream</code></th>
<th><code>FileChannel</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>底层实现</strong></td>
<td>基于阻塞式流</td>
<td>基于 NIO 的缓冲区和非阻塞操作</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（但多线程写入需同步）</td>
<td>是（<code>FileChannel</code> 内部已同步）</td>
</tr>
<tr>
<td><strong>大文件处理</strong></td>
<td>慢（逐字节或小缓冲区写入）</td>
<td>快（支持内存映射和直接缓冲区）</td>
</tr>
<tr>
<td><strong>跳过字节</strong></td>
<td>需创建新数组或调整偏移量</td>
<td>直接修改 <code>ByteBuffer.position()</code></td>
</tr>
</tbody>
</table>
<h4 id="2跳过前5字节的写法"><strong>（2）跳过前5字节的写法</strong></h4>
<pre><code class="language-java">ByteBuffer buffer = ByteBuffer.wrap(bytes);
buffer.position(5); // 跳过前5字节
channel.write(buffer); // 从第6字节开始写入
</code></pre>
<hr>
<h3 id="3-高级用法内存映射文件超大文件优化"><strong>3. 高级用法：内存映射文件（超大文件优化）</strong></h3>
<p>对于超大文件（如 GB 级），使用 <code>MappedByteBuffer</code> 进一步提升性能：</p>
<pre><code class="language-java">try (FileChannel channel = FileChannel.open(
        Paths.get(filePath),
        StandardOpenOption.CREATE,
        StandardOpenOption.READ,
        StandardOpenOption.WRITE)) {

    MappedByteBuffer mappedBuffer = channel.map(
        FileChannel.MapMode.READ_WRITE, 0, bytes.length);
    mappedBuffer.put(bytes); // 直接操作内存映射区
}
</code></pre>
<hr>
<h3 id="4-多线程写入示例"><strong>4. 多线程写入示例</strong></h3>
<p><code>FileChannel</code> 是线程安全的，适合多线程并发写入：</p>
<pre><code class="language-java">ExecutorService executor = Executors.newFixedThreadPool(4);
try (FileChannel channel = FileChannel.open(
        Paths.get(filePath),
        StandardOpenOption.CREATE,
        StandardOpenOption.WRITE)) {

    List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 4; i++) {
        final int threadId = i;
        futures.add(executor.submit(() -&gt; {
            ByteBuffer buffer = ByteBuffer.wrap(getThreadData(threadId));
            synchronized (channel) { // 确保写入顺序（按需）
                channel.write(buffer);
            }
        }));
    }
    for (Future&lt;?&gt; future : futures) future.get(); // 等待所有线程完成
}
executor.shutdown();
</code></pre>
<h3 id="逐行处理--直接写入-filechannel推荐">逐行处理 → 直接写入 FileChannel（推荐）</h3>
<p><strong>优缺点</strong><br>
<strong>优点：</strong></p>
<ul>
<li>内存友好（逐行处理，缓冲区写入）。</li>
<li>适合大文件（无需加载全部内容到内存）。</li>
</ul>
<p><strong>缺点：</strong>代码稍复杂，需手动管理缓冲区。</p>
<pre><code class="language-java">import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class ProcessHexFileStreaming {
    public static void main(String[] args) {
        Path sourcePath = Paths.get("D:\\BLE.txt");
        Path targetPath = Paths.get("D:\\output.bin");

        try (BufferedReader reader = Files.newBufferedReader(sourcePath);
             FileChannel channel = FileChannel.open(
                     targetPath,
                     StandardOpenOption.CREATE,
                     StandardOpenOption.WRITE,
                     StandardOpenOption.TRUNCATE_EXISTING)) {

            ByteBuffer buffer = ByteBuffer.allocate(8192); // 8KB 缓冲区
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim().replaceAll("\\s+", "");
                if (line.length() &gt; 5) {
                    byte[] lineBytes = hexStringToByteArray(line.substring(5));
                    buffer.put(lineBytes);
                    if (buffer.position() &gt;= 4096) { // 缓冲区半满时写入
                        buffer.flip();
                        channel.write(buffer);
                        buffer.clear();
                    }
                }
            }
            // 写入剩余数据
            buffer.flip();
            channel.write(buffer);
            System.out.println("文件写入成功！");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static byte[] hexStringToByteArray(String hexStr) {
        // 同上
    }
}
</code></pre>
<hr>
<h3 id="5-性能对比测试"><strong>5. 性能对比测试</strong></h3>
<p>测试写入 100MB 数据的耗时：</p>
<pre><code class="language-java">byte[] data = new byte[100 * 1024 * 1024]; // 100MB

// FileOutputStream
try (FileOutputStream fos = new FileOutputStream("file_output.bin")) {
    long start = System.currentTimeMillis();
    fos.write(data);
    System.out.println("FileOutputStream: " + (System.currentTimeMillis() - start) + "ms");
}

// FileChannel
try (FileChannel channel = FileChannel.open(
        Paths.get("file_channel.bin"), StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
    long start = System.currentTimeMillis();
    channel.write(ByteBuffer.wrap(data));
    System.out.println("FileChannel: " + (System.currentTimeMillis() - start) + "ms");
}
</code></pre>
<p><strong>结果示例</strong>（环境：JDK 17，NVMe SSD）：</p>
<pre><code>FileOutputStream: 1200ms
FileChannel: 350ms
</code></pre>
<hr>
<h3 id="6-总结"><strong>6. 总结</strong></h3>
<ul>
<li><strong>优先选择 <code>FileChannel</code></strong>：<br>
适合高性能、大文件、多线程场景，API 更灵活（支持偏移量、内存映射）。</li>
<li><strong><code>FileOutputStream</code> 仍有用武之地</strong>：<br>
简单小文件写入或兼容旧代码时可用。</li>
<li><strong>注意事项</strong>：
<ul>
<li><code>FileChannel</code> 的 <code>write()</code> 默认不保证原子性，多线程需同步。</li>
<li>内存映射文件（<code>MappedByteBuffer</code>）操作后需调用 <code>force()</code> 确保数据刷盘。</li>
</ul>
</li>
</ul>
<h2 id="何时使用-randomaccessfile--filechannel"><strong>何时使用 <code>RandomAccessFile + FileChannel</code>？</strong></h2>
<p><code>RandomAccessFile</code> 和 <code>FileChannel</code> 的组合通常在以下场景中使用：</p>
<ol>
<li>
<p><strong>随机访问文件</strong>：</p>
<ul>
<li>需要频繁跳转到文件的特定位置（如修改文件中间部分）。</li>
<li>示例：<pre><code class="language-java">RandomAccessFile file = new RandomAccessFile("largefile.dat", "rw");
FileChannel channel = file.getChannel();
channel.position(1000); // 跳转到第1000字节
channel.write(ByteBuffer.wrap(newData));
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>内存映射文件（<code>MappedByteBuffer</code>）</strong>：</p>
<ul>
<li>需要将文件直接映射到内存中操作（超高性能，适合大文件）。</li>
<li>示例：<pre><code class="language-java">FileChannel channel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);
MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());
buffer.put(newData);
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>多线程读写</strong>：</p>
<ul>
<li><code>FileChannel</code> 是线程安全的，适合多线程并发操作同一文件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="最终建议"><strong>最终建议</strong></h3>
<ul>
<li><strong>小文件</strong>：用 <strong>方案1</strong>（代码简洁）。</li>
<li><strong>大文件</strong>：用 <strong>方案2</strong>（流式处理 + 缓冲区写入）。</li>
<li>仅当需要 <strong>随机访问</strong> 或 <strong>内存映射</strong> 时，才使用 <code>RandomAccessFile + FileChannel</code>。</li>
</ul>
<p>通过合理选择方案，可以平衡内存占用、性能和代码可读性。</p>
<hr>
<h2 id="缓冲区的管理">缓冲区的管理</h2>
<h3 id="1-缓冲区的管理步骤"><strong>1. 缓冲区的管理步骤</strong></h3>
<h4 id="1-初始化缓冲区"><strong>(1) 初始化缓冲区</strong></h4>
<pre><code class="language-java">ByteBuffer buffer = ByteBuffer.allocate(8192); // 分配 8KB 缓冲区（可根据需求调整大小）
</code></pre>
<ul>
<li><strong>缓冲区大小选择</strong>：
<ul>
<li>太小（如 1KB）→ 频繁触发写入，增加 I/O 开销。</li>
<li>太大（如 100MB）→ 内存浪费，失去流式处理的优势。</li>
<li><strong>推荐值</strong>：<code>8KB</code>（默认文件系统块大小）或 <code>64KB</code>（适合大文件）。</li>
</ul>
</li>
</ul>
<h4 id="2-填充缓冲区"><strong>(2) 填充缓冲区</strong></h4>
<pre><code class="language-java">byte[] lineBytes = hexStringToByteArray(line.substring(5)); // 处理当前行
buffer.put(lineBytes); // 将字节写入缓冲区
</code></pre>
<ul>
<li><strong>检查缓冲区剩余空间</strong>：<br>
每次写入前检查缓冲区是否已满（或接近满），避免溢出：<pre><code class="language-java">if (buffer.remaining() &lt; lineBytes.length) {
    buffer.flip();      // 切换为读模式
    channel.write(buffer); // 写入文件
    buffer.clear();     // 清空缓冲区，切换回写模式
}
</code></pre>
</li>
</ul>
<h4 id="3-触发写入条件"><strong>(3) 触发写入条件</strong></h4>
<ul>
<li><strong>条件 1：缓冲区半满或全满</strong>（平衡性能和内存）<pre><code class="language-java">if (buffer.position() &gt;= buffer.capacity() / 2) {
    buffer.flip();
    channel.write(buffer);
    buffer.clear();
}
</code></pre>
</li>
<li><strong>条件 2：处理完所有行后</strong><br>
确保缓冲区中剩余数据被写入：<pre><code class="language-java">buffer.flip();
if (buffer.hasRemaining()) {
    channel.write(buffer);
}
</code></pre>
</li>
</ul>
<hr>
<h3 id="2-完整代码示例带缓冲区管理"><strong>2. 完整代码示例（带缓冲区管理）</strong></h3>
<pre><code class="language-java">import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class BufferedHexFileWriter {
    public static void main(String[] args) {
        Path sourcePath = Paths.get("D:\\BLE.txt");
        Path targetPath = Paths.get("D:\\output.bin");

        try (BufferedReader reader = Files.newBufferedReader(sourcePath);
             FileChannel channel = FileChannel.open(
                     targetPath,
                     StandardOpenOption.CREATE,
                     StandardOpenOption.WRITE,
                     StandardOpenOption.TRUNCATE_EXISTING)) {

            ByteBuffer buffer = ByteBuffer.allocateDirect(8192); // 直接缓冲区（性能更高）
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim().replaceAll("\\s+", "");
                if (line.length() &gt; 5) {
                    byte[] lineBytes = hexStringToByteArray(line.substring(5));
                    
                    // 检查缓冲区空间
                    if (buffer.remaining() &lt; lineBytes.length) {
                        buffer.flip();
                        channel.write(buffer);
                        buffer.clear();
                    }
                    buffer.put(lineBytes);
                }
            }
            // 写入剩余数据
            buffer.flip();
            channel.write(buffer);
            System.out.println("文件写入完成！");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static byte[] hexStringToByteArray(String hexStr) {
        if (hexStr.length() % 2 != 0) {
            throw new IllegalArgumentException("Invalid hex string length");
        }
        byte[] bytes = new byte[hexStr.length() / 2];
        for (int i = 0; i &lt; hexStr.length(); i += 2) {
            bytes[i / 2] = (byte) Integer.parseInt(hexStr.substring(i, i + 2), 16);
        }
        return bytes;
    }
}
</code></pre>
<hr>
<h3 id="3-关键注意事项"><strong>3. 关键注意事项</strong></h3>
<h4 id="1-缓冲区模式切换"><strong>(1) 缓冲区模式切换</strong></h4>
<ul>
<li><strong><code>flip()</code></strong>：写模式 → 读模式（准备写入文件）。</li>
<li><strong><code>clear()</code></strong>：读模式 → 写模式（重置位置，允许新数据写入）。</li>
<li><strong>错误示例</strong>：忘记 <code>flip()</code> 直接写入 → 数据丢失；忘记 <code>clear()</code> → 缓冲区无法复用。</li>
</ul>
<h4 id="2-直接缓冲区-vs-堆缓冲区"><strong>(2) 直接缓冲区 vs 堆缓冲区</strong></h4>
<ul>
<li><strong><code>ByteBuffer.allocateDirect()</code></strong>：
<ul>
<li>直接分配堆外内存，减少 JVM 堆压力，适合大文件。</li>
<li>但创建和销毁成本较高，适合长期复用的缓冲区。</li>
</ul>
</li>
<li><strong><code>ByteBuffer.allocate()</code></strong>：
<ul>
<li>分配在 JVM 堆上，适合小数据或临时缓冲区。</li>
</ul>
</li>
</ul>
<h4 id="3-异常处理"><strong>(3) 异常处理</strong></h4>
<ul>
<li><strong>资源泄漏</strong>：确保 <code>BufferedReader</code> 和 <code>FileChannel</code> 在 <code>try-with-resources</code> 中自动关闭。</li>
<li><strong>数据完整性</strong>：写入后检查 <code>channel.write()</code> 的返回值（实际写入字节数），确保全部数据落盘。</li>
</ul>
<h4 id="4-性能调优"><strong>(4) 性能调优</strong></h4>
<ul>
<li><strong>缓冲区大小</strong>：根据文件大小调整（如 1MB 文件用 8KB 缓冲区，1GB 文件用 64KB）。</li>
<li><strong>批量写入</strong>：合并多次小写入（如每 10 行处理一次写入）。</li>
<li><strong>零拷贝优化</strong>：对于超大文件，考虑 <code>FileChannel.transferTo()</code> 或内存映射（<code>MappedByteBuffer</code>）。</li>
</ul>
<hr>
<h3 id="4-高级优化内存映射文件mappedbytebuffer"><strong>4. 高级优化：内存映射文件（MappedByteBuffer）</strong></h3>
<p>如果文件极大（如 &gt;100MB），可直接映射到内存操作：</p>
<pre><code class="language-java">try (FileChannel channel = FileChannel.open(
        targetPath,
        StandardOpenOption.CREATE,
        StandardOpenOption.READ,
        StandardOpenOption.WRITE)) {

    MappedByteBuffer mappedBuffer = channel.map(
        FileChannel.MapMode.READ_WRITE, 0, estimatedSize);
    
    // 直接操作 mappedBuffer
    mappedBuffer.put(hexStringToByteArray(processedLine));
    mappedBuffer.force(); // 强制刷盘
}
</code></pre>
<ul>
<li><strong>优点</strong>：避免缓冲区拷贝，最高性能。</li>
<li><strong>缺点</strong>：需要提前知道文件大小，且映射区域不可动态扩展。</li>
</ul>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li><strong>核心流程</strong>：初始化缓冲区 → 填充数据 → 触发写入 → 处理剩余数据。</li>
<li><strong>避坑指南</strong>：
<ul>
<li>始终检查 <code>buffer.remaining()</code>。</li>
<li>正确切换 <code>flip()</code>/<code>clear()</code> 模式。</li>
<li>优先使用 <code>try-with-resources</code> 管理资源。</li>
</ul>
</li>
<li><strong>性能选择</strong>：
<ul>
<li>小文件：堆缓冲区 + 普通写入。</li>
<li>大文件：直接缓冲区或内存映射。</li>
</ul>
</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18860975" target="_blank">https://www.cnblogs.com/vipsoft/p/18860975</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04294788872916667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-07 11:18">2025-05-06 15:13</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">137</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18860975);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18860975', targetLink: 'https://www.cnblogs.com/vipsoft/p/18860975', title: 'RandomAccessFile、FileInputStream、MappedByteBuffer、FileChannel 区别、应用场景及示例' })">举报</a>
</div>
        