
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18771897" title="发布于 2025-03-14 13:13">
    <span role="heading" aria-level="2">【快速判断是否存在利器】布隆过滤器和布谷鸟过滤器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="从入门到精通布隆过滤器和布谷鸟过滤器">从入门到精通：布隆过滤器和布谷鸟过滤器</h2>
<p>在计算机科学领域，过滤器（Filter）是一种用于快速判断元素是否属于某个集合的数据结构。布隆过滤器（Bloom Filter）和布谷鸟过滤器（Cuckoo Filter）是两种常用的概率型过滤器，它们以高效的空间利用率和查询速度著称，广泛应用于缓存系统、数据库、网络爬虫等场景。</p>
<p>本文将带你从入门到精通，深入了解布隆过滤器和布谷鸟过滤器的原理、优缺点、应用场景以及实现细节，并基于 Spring Boot 项目提供保姆级的代码示例。</p>
<hr>
<h3 id="一布隆过滤器-bloom-filter">一、布隆过滤器 (Bloom Filter)</h3>
<h4 id="11-简介">1.1 简介</h4>
<p>布隆过滤器是由 Burton Howard Bloom 在 1970 年提出的一种空间效率很高的概率型数据结构。它利用多个哈希函数将一个元素映射到一个位数组中，用于判断一个元素是否属于某个集合。</p>
<h4 id="12-工作原理">1.2 工作原理</h4>
<ol>
<li><strong>初始化</strong>：创建一个长度为 m 的位数组，所有位初始化为 0。</li>
<li><strong>添加元素</strong>：使用 k 个独立的哈希函数将元素映射到位数组中的 k 个位置，并将这些位置置为 1。</li>
<li><strong>查询元素</strong>：使用相同的 k 个哈希函数计算元素对应的 k 个位置，如果所有位置都为 1，则认为元素可能存在；如果有任何一个位置为 0，则元素一定不存在。</li>
</ol>
<h4 id="13-底层剖析">1.3 底层剖析</h4>
<p>布隆过滤器的核心在于<strong>多哈希函数映射</strong>和<strong>位数组存储</strong>。以下是其底层实现的关键点：</p>
<ul>
<li><strong>哈希函数</strong>：布隆过滤器使用 k 个独立的哈希函数，每个哈希函数将输入元素映射到位数组中的一个位置。为了减少冲突，哈希函数应具有良好的均匀分布性。</li>
<li><strong>位数组</strong>：位数组是布隆过滤器的存储结构，每个元素通过哈希函数映射到位数组中的多个位置。位数组的长度 m 和哈希函数的数量 k 共同决定了布隆过滤器的误判率。</li>
<li><strong>误判率</strong>：布隆过滤器的误判率取决于位数组的长度 m、哈希函数的数量 k 以及插入的元素数量 n。误判率的计算公式为：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1465907/202503/1465907-20250314131418116-668643156.png" alt="" loading="lazy"></p>
<p>通过调整 m 和 k，可以控制误判率。</p>
<h4 id="14-优缺点">1.4 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>空间效率高</strong>：布隆过滤器使用位数组存储数据，空间复杂度为 O(m)。</li>
<li><strong>查询速度快</strong>：查询时间复杂度为 O(k)，k 为哈希函数的数量。</li>
<li><strong>支持动态添加</strong>：可以动态地向布隆过滤器中添加元素。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>存在误判率</strong>：布隆过滤器可能会出现误判，即判断一个不存在的元素为存在。</li>
<li><strong>不支持删除</strong>：由于多个元素可能共享同一个位，删除操作会影响其他元素的判断。</li>
</ul>
<h4 id="15-应用场景">1.5 应用场景</h4>
<ul>
<li><strong>缓存系统</strong>：用于快速判断数据是否在缓存中，避免缓存穿透。</li>
<li><strong>数据库查询优化</strong>：用于快速判断某个键是否在数据库中，减少磁盘 I/O。</li>
<li><strong>网络爬虫</strong>：用于记录已访问的 URL，避免重复爬取。</li>
</ul>
<h4 id="16-spring-boot-实现示例">1.6 Spring Boot 实现示例</h4>
<p>以下是一个基于 Spring Boot 的布隆过滤器实现示例：</p>
<h5 id="161-添加依赖">1.6.1 添加依赖</h5>
<p>在 <code>pom.xml</code> 中添加 Guava 库依赖（Guava 提供了布隆过滤器的实现）：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;32.1.2-jre&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="162-实现布隆过滤器">1.6.2 实现布隆过滤器</h5>
<pre><code class="language-java">import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;

@Service
public class BloomFilterService {

    // 初始化布隆过滤器，预计插入 1000 个元素，误判率为 0.01
    private BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(
            Funnels.stringFunnel(StandardCharsets.UTF_8), 1000, 0.01);

    /**
     * 添加元素到布隆过滤器
     */
    public void add(String element) {
        bloomFilter.put(element);
    }

    /**
     * 判断元素是否可能存在
     */
    public boolean mightContain(String element) {
        return bloomFilter.mightContain(element);
    }
}
</code></pre>
<h5 id="163-测试布隆过滤器">1.6.3 测试布隆过滤器</h5>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BloomFilterController {

    @Autowired
    private BloomFilterService bloomFilterService;

    @GetMapping("/add")
    public String addElement(@RequestParam String element) {
        bloomFilterService.add(element);
        return "Added: " + element;
    }

    @GetMapping("/check")
    public String checkElement(@RequestParam String element) {
        boolean exists = bloomFilterService.mightContain(element);
        return "Element " + element + " might exist: " + exists;
    }
}
</code></pre>
<h5 id="164-运行测试">1.6.4 运行测试</h5>
<p>启动 Spring Boot 项目后，访问以下 URL 进行测试：</p>
<ul>
<li>添加元素：<code>http://localhost:8080/add?element=test</code></li>
<li>检查元素：<code>http://localhost:8080/check?element=test</code></li>
</ul>
<hr>
<h3 id="二布谷鸟过滤器-cuckoo-filter">二、布谷鸟过滤器 (Cuckoo Filter)</h3>
<h4 id="21-简介">2.1 简介</h4>
<p>布谷鸟过滤器是布隆过滤器的一种改进版本，由 Bin Fan 等人在 2014 年提出。它通过使用布谷鸟哈希（Cuckoo Hashing）来解决布隆过滤器不支持删除操作的问题。</p>
<h4 id="22-工作原理">2.2 工作原理</h4>
<ol>
<li><strong>初始化</strong>：创建一个包含多个桶的数组，每个桶可以存储多个指纹（fingerprint）。</li>
<li><strong>添加元素</strong>：使用两个哈希函数计算元素的两个候选桶，并将元素的指纹存储到其中一个桶中。如果两个桶都满了，则进行“踢出”操作，将原有元素踢出并重新插入。</li>
<li><strong>查询元素</strong>：使用相同的两个哈希函数计算元素的两个候选桶，并检查这两个桶中是否包含该元素的指纹。</li>
<li><strong>删除元素</strong>：通过查找元素的指纹并将其从桶中删除。</li>
</ol>
<h4 id="23-底层剖析">2.3 底层剖析</h4>
<p>布谷鸟过滤器的核心在于<strong>布谷鸟哈希</strong>和<strong>指纹存储</strong>。以下是其底层实现的关键点：</p>
<ul>
<li><strong>布谷鸟哈希</strong>：布谷鸟过滤器使用两个哈希函数 h1 和 h2 来计算元素的候选桶。具体来说，给定一个元素 x，它的两个候选桶分别为 h1(x) 和 h2(x)。如果其中一个桶有空位，则将元素的指纹存储到该桶中；如果两个桶都满了，则进行“踢出”操作，将原有元素踢出并重新插入。</li>
<li><strong>指纹</strong>：指纹是元素的哈希值的一部分，通常较短（例如 8 位）。指纹的唯一性决定了误判率。布谷鸟过滤器通过存储指纹而不是完整的元素来节省空间。</li>
<li><strong>误判率</strong>：布谷鸟过滤器的误判率取决于指纹的长度和桶的大小。指纹越长，误判率越低，但空间占用越大。</li>
</ul>
<h4 id="24-优缺点">2.4 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>支持删除操作</strong>：布谷鸟过滤器支持删除操作，且不会影响其他元素的判断。</li>
<li><strong>空间效率高</strong>：与布隆过滤器相比，布谷鸟过滤器在相同误判率下，空间利用率更高。</li>
<li><strong>查询速度快</strong>：查询时间复杂度为 O(1)。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>实现复杂</strong>：布谷鸟过滤器的实现比布隆过滤器复杂，尤其是在处理哈希冲突时。</li>
<li><strong>插入性能可能下降</strong>：在高负载情况下，插入操作可能会因为频繁的“踢出”操作而性能下降。</li>
</ul>
<h4 id="25-应用场景">2.5 应用场景</h4>
<ul>
<li><strong>缓存系统</strong>：与布隆过滤器类似，但支持删除操作，适用于需要动态更新缓存的场景。</li>
<li><strong>数据库查询优化</strong>：支持删除操作，适用于需要频繁更新数据的场景。</li>
<li><strong>分布式系统</strong>：用于快速判断数据是否在分布式系统中存在。</li>
</ul>
<h4 id="26-spring-boot-实现示例">2.6 Spring Boot 实现示例</h4>
<p>以下是一个基于 Spring Boot 的布谷鸟过滤器实现示例：</p>
<h5 id="261-添加依赖">2.6.1 添加依赖</h5>
<p>在 <code>pom.xml</code> 中添加 Caffeine 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
    &lt;version&gt;3.1.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="262-实现布谷鸟过滤器">2.6.2 实现布谷鸟过滤器</h5>
<pre><code class="language-java">import com.github.benmanes.caffeine.cache.BloomFilter;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.stereotype.Service;

@Service
public class CuckooFilterService {

    // 初始化布谷鸟过滤器，预计插入 1000 个元素，误判率为 0.01
    private BloomFilter&lt;String&gt; cuckooFilter = Caffeine.newBuilder()
            .maximumSize(1000)
            .buildFilter();

    /**
     * 添加元素到布谷鸟过滤器
     */
    public void add(String element) {
        cuckooFilter.put(element);
    }

    /**
     * 判断元素是否可能存在
     */
    public boolean mightContain(String element) {
        return cuckooFilter.mightContain(element);
    }

    /**
     * 删除元素（布谷鸟过滤器不支持直接删除，可以通过重建过滤器实现）
     */
    public void clear() {
        cuckooFilter = Caffeine.newBuilder()
                .maximumSize(1000)
                .buildFilter();
    }
}
</code></pre>
<h5 id="263-测试布谷鸟过滤器">2.6.3 测试布谷鸟过滤器</h5>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/cuckoo")
public class CuckooFilterController {

    @Autowired
    private CuckooFilterService cuckooFilterService;

    @PostMapping("/add")
    public String addElement(@RequestParam String element) {
        cuckooFilterService.add(element);
        return "Added: " + element;
    }

    @GetMapping("/check")
    public String checkElement(@RequestParam String element) {
        boolean exists = cuckooFilterService.mightContain(element);
        return "Element " + element + " might exist: " + exists;
    }

    @DeleteMapping("/clear")
    public String clearFilter() {
        cuckooFilterService.clear();
        return "Filter cleared";
    }
}
</code></pre>
<h5 id="264-运行测试">2.6.4 运行测试</h5>
<p>启动 Spring Boot 项目后，访问以下 URL 进行测试：</p>
<ul>
<li>添加元素：<code>http://localhost:8080/cuckoo/add?element=test</code></li>
<li>检查元素：<code>http://localhost:8080/cuckoo/check?element=test</code></li>
<li>清空过滤器：<code>http://localhost:8080/cuckoo/clear</code></li>
</ul>
<hr>
<h3 id="三布隆过滤器-vs-布谷鸟过滤器">三、布隆过滤器 vs 布谷鸟过滤器</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>布隆过滤器</th>
<th>布谷鸟过滤器</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>空间效率</strong></td>
<td>高</td>
<td>更高</td>
</tr>
<tr>
<td><strong>查询速度</strong></td>
<td>O(k)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>误判率</strong></td>
<td>可控制</td>
<td>可控制</td>
</tr>
<tr>
<td><strong>删除操作</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>插入性能</strong></td>
<td>稳定</td>
<td>高负载时可能下降</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="四总结">四、总结</h3>
<p>布隆过滤器和布谷鸟过滤器都是高效的概率型数据结构，适用于需要快速判断元素是否属于某个集合的场景。布隆过滤器实现简单，空间效率高，但不支持删除操作；布谷鸟过滤器在支持删除操作的同时，进一步提高了空间效率，但实现复杂度较高。</p>
<p>在实际应用中，可以根据具体需求选择合适的过滤器。如果不需要删除操作，布隆过滤器是一个简单高效的选择；如果需要支持删除操作，布谷鸟过滤器则更为合适。</p>
<hr>
<h3 id="五参考资料">五、参考资料</h3>
<ol>
<li>Bloom, B. H. (1970). Space/time trade-offs in hash coding with allowable errors. Communications of the ACM, 13(7), 422-426.</li>
<li>Fan, B., Andersen, D. G., Kaminsky, M., &amp; Mitzenmacher, M. (2014). Cuckoo filter: Practically better than bloom. In Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies (pp. 75-88).</li>
</ol>
<p>希望这篇博客能帮助你从入门到精通布隆过滤器和布谷鸟过滤器。如果你有任何问题或建议，欢迎在评论区留言！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04745962206597222" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-14 13:14">2025-03-14 13:13</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18771897" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18771897);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18771897', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18771897', title: '【快速判断是否存在利器】布隆过滤器和布谷鸟过滤器' })">举报</a>
</div>
        