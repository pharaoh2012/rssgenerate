
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/alineverstop/p/18982110" title="发布于 2025-07-13 11:42">
    <span role="heading" aria-level="2">SpringBoot--如何整体读取多个配置属性及其相关操作</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上篇文章讲到使用@Value注解每次只能读取一个配置属性，若要整体读取多个属性，或者读取具有某种结构关系的一组属性可使用@ConfigurationProperties注解来处理。</p>
<p>@ConfigurationProperties注解的两种用法：</p>
<ol>
<li>修饰属性处理类：当@ConfigurationProperties修饰的类被部署为容器中的Bean时，改注解指定的属性会被注入该Bean的属性。因此，@ConfigurationProperties修饰的类称为“属性处理类”。</li>
<li>修饰@Bean注解修饰的方法：使用@Bean修饰的方法蒋会配置一个容器中的Bean，而@ConfigurationProperties指定的属性会被注入该Bean的属性。</li>
</ol>
<p>看不懂没关系，下面会有代码示例。</p>
<p>在使用@ConfigurationProperties时可指定如下属性：</p>
<ol>
<li>prefix（或value）：指定要加载的属性的前缀</li>
<li>ignoreInvaildFields():指定是否忽略无效属性值。比如处理类定义了某个字段的类型是Integer，但在配置文件中的值是abc，这就是无效值。</li>
<li>ignoreUnknowFields():指定是否忽略未知的字段值。如果在配置文件中配置的属性比处理类需要的属性更多，那么多出来的属性就是未知属性。</li>
</ol>
<h1 id="使用属性处理类获取配置属性">使用属性处理类获取配置属性</h1>
<p>直接来看代码示例：</p>
<p>\resources\application.properties文件内容：</p>
<pre><code class="language-java">org.crazyit.enabled=true
org.crazyit.name=Crazy Java
org.crazyit.remoteAddress=192.168.1.188
org.crazyit.item.brand=Tesla
org.crazyit.item.comments=Good, Excellent
</code></pre>
<p>(使用IDEA开发属性处理类时，添加spring-boot-configuration-processor依赖，IDEA会提供“代码补全”功能。</p>
<pre><code class="language-java">&lt;!-- 添加该依赖后IDEA可以提供自动补全功能 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
   &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>)</p>
<p>SpringBoot不会自动启用@ConfigurationProperties注解，启用该注解有如下方式：</p>
<ol>
<li>为@ConfigurationProperties注解修饰的类加@Component注解</li>
<li>为@ConfigurationProperties注解修饰的类显式配置成容器中的bean</li>
<li>使用@EnableConfigurationProperties注解，该注解显式指定一个或多个属性处理类，SpringBoot会启用这些属性处理类上的@ConfigurationProperties注解</li>
<li>使用@ConfigurationPropertiesScan注解，该注解指定一个或多个包及其子包下所有带@ConfigurationProperties注解的类</li>
</ol>
<p>@ConfigurationProperties注解修饰的属性处理类代码:</p>
<pre><code class="language-java">// 指定读取以org.crazyit.*开头的属性
@ConfigurationProperties(prefix = "org.crazyit", ignoreUnknownFields=false)
@Component
public class CrazyitProperties
{
    // 指定同名的实例变量和setter方法。SpringBoot会通过反射调用setter方法来完成属性值注入
   private boolean enabled;
   private String name;
   private InetAddress remoteAddress;
   private final Item item = new Item();
         // 省略getter\setter 
   public static class Item
   {
      private String brand;
      private List&lt;String&gt; comments = new ArrayList&lt;&gt;(Collections.singleton("GREAT"));
            // 省略getter\setter 
   }
}
</code></pre>
<p>控制器类代码示例：</p>
<pre><code class="language-java">@RestController
public class HelloController
{
   private final CrazyitProperties crazyitProperties;
   // 依赖注入CrazyitProperties属性处理Bean
   @Autowired
   public HelloController(CrazyitProperties crazyitProperties)
   {
      this.crazyitProperties = crazyitProperties;
   }

   @GetMapping
   public CrazyitProperties hello()
   {
      return crazyitProperties;
   }
}
</code></pre>
<p>运行结果：</p>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/growingbambi/typora/master/ali2_3_1.png" class="lazyload"></p>
<p>属性处理类也支持使用构造器完成属性值注入，但是要额外使用@ConstructorBinding修饰用于执行构造注入的构造器。注意：使用构造器注入，必须使用@EnableConfigurationProperties或者@ConfigurationPropertiesScan注解来启用@ConfigurationProperties注解。</p>
<p>属性处理类示例：</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = "org.crazyit", ignoreUnknownFields=false)
public class CrazyitProperties
{
   private boolean enabled;
   private String name;
   private InetAddress remoteAddress;
   private final Item item;

   @ConstructorBinding
   public CrazyitProperties(boolean enabled, String name, InetAddress remoteAddress, Item item)
   {
      this.enabled = enabled;
      this.name = name;
      this.remoteAddress = remoteAddress;
      this.item = item;
   }
       // 省略getter\setter 

   public static class Item
   {
      private String brand;
      private List&lt;String&gt; comments = new ArrayList&lt;&gt;(Collections.singleton("GREAT"));
       // 省略getter\setter 
   }
}
</code></pre>
<p>application.yml</p>
<pre><code class="language-java">org:
  crazyit:
    enabled: true
    name: 哈利波特
    remote-address: 192.168.1.188
    item:
      brand: Apple
      comments:
        - Good
        - Excellent
</code></pre>
<p>上面配置的属性为org.crazyit.remote-address与CrazyitProperties类中定义的remoteAddress属性不完全相同，SpringBoot能成功注入吗？</p>
<p>答案是肯定的，因为SpringBoot支持宽松绑定（Relaxed Binding）。它不要求配置的属性名和属性处理类中的属性名完全相同。</p>
<h2 id="宽松绑定的四种情况这4种情况都能完成注入">宽松绑定的四种情况（这4种情况都能完成注入）：</h2>
<ol>
<li>org.crazyit.remote-address</li>
<li>org.crazyit. remoteAddress</li>
<li>org.crazyit. remote_address</li>
<li>ORG_CRAZYIT_REMOTEADDRESS</li>
</ol>
<p>在*.properties和 *.yml文件中配置List类型的属性有较小的区别：</p>
<ol>
<li>在*.properties文件中配置List有2种方式：英文逗号隔开多个值；用标准方括号</li>
<li>在 *.yml文件中配置List有2种方式：英文逗号隔开多个值；用短横线开头（例子所示）</li>
</ol>
<p>因此，*.properties和 *.yml文件中，都可以用英文逗号隔开多个值来构建List。</p>
<p>App.java示例</p>
<pre><code class="language-java">@SpringBootApplication
// 指定扫描org.crazyit.app.config包及其子包下的@ConfigurationProperties注解修饰的类
@ConfigurationPropertiesScan("org.crazyit.app.config")
public class App
{
   public static void main(String[] args)
   {
      // 创建Spring容器、运行Spring Boot应用
      SpringApplication.run(App.class, args);
   }
}
</code></pre>
<h1 id="为容器中的bean注入配置属性">为容器中的bean注入配置属性</h1>
<p>@ConfigurationProperties注解除了可修饰类，还可修饰@Bean注解修饰的方法。</p>
<p>代码示例：Book类</p>
<pre><code class="language-java">public class Book
{
   private String title;
   private double price;
   private String author;
   private List&lt;String&gt; keywords;
	// 省略getter、setter
}
</code></pre>
<p>代码示例：配置类</p>
<pre><code class="language-java">@Configuration
public class MyConfig
{
   @Bean
   // @ConfigurationProperties注解会驱动Spring自动调用该Bean的setter方法
   @ConfigurationProperties("fkjava.book")
   public Book book()
   {
      return new Book();
   }
}
</code></pre>
<p>代码示例：application.yml</p>
<pre><code class="language-java">fkjava:
  book:
    title: "美语音标"
    price: 128
    author: "赖世雄"
    keywords:
      - 英语
      - 音标
</code></pre>
<p>代码示例：控制器类</p>
<pre><code class="language-java">@RestController
public class HelloController
{
   private final Book book;
    // 通过构造器注入Book对象
   @Autowired
   public HelloController(Book book)
   {
      this.book = book;
   }
   @GetMapping
   public Book hello()
   {
      return book;
   }
}
</code></pre>
<p>运行结果：</p>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/growingbambi/typora/master/ali2_3_2.png" class="lazyload"></p>
<p>@Value和   @ConfigurationProperties的对比</p>
<table>
<thead>
<tr>
<th style="text-align: center">特征</th>
<th style="text-align: center">@ConfigurationProperties</th>
<th style="text-align: center">@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">注入的属性个数</td>
<td style="text-align: center">批量</td>
<td style="text-align: center">单个</td>
</tr>
<tr>
<td style="text-align: center">宽松绑定</td>
<td style="text-align: center">支持</td>
<td style="text-align: center">部分支持</td>
</tr>
<tr>
<td style="text-align: center">SpEL</td>
<td style="text-align: center">不支持</td>
<td style="text-align: center">支持</td>
</tr>
<tr>
<td style="text-align: center">元数据支持</td>
<td style="text-align: center">支持</td>
<td style="text-align: center">不支持</td>
</tr>
</tbody>
</table>
<h1 id="属性转换">属性转换</h1>
<p>SpringBoot内置了常用的类型转换机制，如果在转换失败，则应用启动会失败，并抛出异常。如果要忽略转换失败的属性，可将@ConfigurationProperties注解的ignoreInvaildFields属性设为true（默认是false）。</p>
<p>SpringBoot可自动转换如下类型：Duration、Period、DataSize，并支持为属性值指定单位。</p>
<ol>
<li>Duration类型可指定的单位：ns纳秒、μs微妙、ms毫秒、s秒、m分钟、h小时、d天。</li>
<li>Period类型可指定的单位：y年、m月、w星期、d天。（例如配置1y3d,代表1年3天）。</li>
<li>DataSize类型可指定的单位：B字节、KB千字节、MB兆字节、GB吉字节、TB太字节</li>
</ol>
<p>代码示例：属性处理类</p>
<pre><code class="language-java">// 指定读取以org.crazyit.*开头的属性
@ConfigurationProperties(prefix = "org.crazyit")
@Component
public class CrazyitProperties
{
   private Duration timeout;
    //   @DurationUnit注解指定默认的时间单位
   @DurationUnit(ChronoUnit.SECONDS)
   private Duration lastTime;
   private Period runPeriod;
    // @DataSizeUnit注解指定默认的数据单位
   @DataSizeUnit(DataUnit.MEGABYTES)
   private DataSize maxSize;
	// 省略getter、setter
}
</code></pre>
<p>代码示例：application.properties</p>
<pre><code class="language-java">org.crazyit.timeout=30000
# 默认单位是秒
org.crazyit.last-time=45
org.crazyit.run-period=2m5d
org.crazyit.max-size=2
</code></pre>
<p>代码示例：控制器类</p>
<pre><code class="language-java">@RestController
public class HelloController
{
   private final CrazyitProperties crazyitProperties;
   // 依赖注入CrazyitProperties属性处理Bean
   @Autowired
   public HelloController(CrazyitProperties crazyitProperties)
   {
      this.crazyitProperties = crazyitProperties;
   }

   @GetMapping
   public Map&lt;String, Object&gt; hello()
   {
      System.out.println(crazyitProperties.getMaxSize().toKilobytes());
      return Map.of("props", crazyitProperties,
            "maxSize", crazyitProperties.getMaxSize().toKilobytes());
   }
}
</code></pre>
<p>运行结果：</p>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/growingbambi/typora/master/ali2_3_3.png" class="lazyload"></p>
<h1 id="校验configurationproperties">校验@ConfigurationProperties</h1>
<p>只要为属性处理类添加@Validated注解，并使用JSR303的校验注解修饰需要校验的示例变量，SpringBoot会自动校验配置文件中的属性值。如果某个属性校验不通过，应用会启动失败，并用FailureAnalyzer显式校验错误。</p>
<p>如果属性处理类包含复合类型的属性，且要对复合类型的子属性进行校验，则应为该复合类型的属性添加@Valid注解。</p>
<p>@ConfigurationProperties校验基于JSR303，因此必须添加JSR303依赖，spring-boot-starter-validation依赖库包含了JSR303的依赖，因此要在pom文件中添加以下依赖</p>
<pre><code class="language-java">&lt;!-- 添加Spring Boot Validation依赖库 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>属性处理类示例：</p>
<pre><code class="language-java">// 指定读取以org.crazyit.*开头的属性
@ConfigurationProperties(prefix = "org.crazyit", ignoreUnknownFields=false)
@Component
@Validated
public class CrazyitProperties
{
   @NotEmpty
   private String name;
   @Range(max = 150, min=90, message = "价格必须位于90～150之间")
   private double price;
   @Pattern(regexp = "[1][3-8][0-9]{9}", message = "必须输入有效的手机号")
   private String mobile;
   @Valid
   private final Item item = new Item();
	// 省略getter setter

   public static class Item
   {
      @Length(min=5, max=10, message = "品牌名长度必须在5到10个字符")
      private String brand;
      @Size(min = 1, message = "comments至少包含一个元素")
      private List&lt;String&gt; comments = new ArrayList&lt;&gt;(Collections.singleton("GREAT"));
	// 省略getter、setter
   }
}
</code></pre>
<p>代码示例：application.properties</p>
<pre><code class="language-java">org.crazyit.name=Crazy Java
org.crazyit.price=89
org.crazyit.mobile=13334444
org.crazyit.item.brand=Apple
org.crazyit.item.comments=Great, Excellent
</code></pre>
<p>运行结果：</p>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/growingbambi/typora/master/ali2_3_4.png" class="lazyload"></p>
<p>对于使用@ConfigurationProperties修饰@Bean方法的情况，同样可对配置属性进行校验，主要为@Bean方法添加@Validated注解即可。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/alineverstop/" target="_blank">NE_STOP</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/alineverstop/p/18982110" target="_blank">https://www.cnblogs.com/alineverstop/p/18982110</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-13 11:42">2025-07-13 11:42</span>&nbsp;
<a href="https://www.cnblogs.com/alineverstop">NE_STOP</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18982110);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18982110', targetLink: 'https://www.cnblogs.com/alineverstop/p/18982110', title: 'SpringBoot--如何整体读取多个配置属性及其相关操作' })">举报</a>
</div>
        