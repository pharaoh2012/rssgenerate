
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zlt2000/p/18824279" title="发布于 2025-04-14 10:25">
    <span role="heading" aria-level="2">Spring AI与DeepSeek实战四：系统API调用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1769816/202504/1769816-20250414102409286-1958117236.png" alt="" loading="lazy"></p>
<h2 id="一概述">一、概述</h2>
<p>在 <code>AI</code> 应用开发中，工具调用 <code>Tool Calling</code> 是增强大模型能力的核心技术。通过让模型与外部 <code>API</code> 或工具交互，可实现 <strong>实时信息检索</strong>（如天气查询、新闻获取）、<strong>系统操作</strong>（如创建任务、发送邮件）等功能。</p>
<p><code>Spring AI</code> 作为企业级 <code>AI</code> 开发框架，在 <code>1.0.0.M6</code> 版本中进行了重要升级：废弃 <code>Function Calling</code> 引入 <code>Tool Calling</code> 以更贴合行业术语；本文结合 <code>Spring AI</code> 与大模型，演示如何通过 <code>Tool Calling</code> 实现系统 <code>API</code> 调用，同时处理多轮对话中的会话记忆。</p>
<p>关于 Spring AI 与 DeepSeek 的集成，以及 API-KEY 的申请等内容，可参考文章《<a href="https://mp.weixin.qq.com/s/Y4hRX5gmmGcSxc_YK0TAgw" target="_blank" rel="noopener nofollow">Spring AI与DeepSeek实战一：快速打造智能对话应用</a>》</p>
<p>&nbsp;</p>
<h2 id="二函数调用原理">二、函数调用原理</h2>
<p>大模型仅负责 <strong>决定是否调用工具</strong> 和 <strong>提供参数</strong>，实际执行逻辑由客户端（Spring 应用）实现，确保工具调用的可控性与安全性。</p>
<p><img src="https://img2024.cnblogs.com/blog/1769816/202504/1769816-20250414102420526-2145105587.png" alt="" loading="lazy"></p>
<h3 id="21-工具元数据注入">2.1. 工具元数据注入</h3>
<p>在发起Chat Request时，将工具描述（name/description）、参数结构（input schema）等元数据封装至请求体，建立大模型的工具调用能力基线。</p>
<h3 id="22-模型决策响应">2.2. 模型决策响应</h3>
<p>大模型根据上下文推理生成工具调用指令（tool_calls字段），返回包含选定工具名称及结构化参数的中间响应。</p>
<h3 id="23-服务端路由执行">2.3. 服务端路由执行</h3>
<p>Spring AI模块解析工具调用指令，通过服务发现机制定位目标工具实例，注入参数并触发同步/异步执行。</p>
<h3 id="24-执行结果标准化">2.4. 执行结果标准化</h3>
<p>工具返回原始执行结果后，系统进行数据类型校验、异常捕获和JSON序列化处理，生成模型可解析的标准化数据结构。</p>
<h3 id="25-上下文增强推理">2.5. 上下文增强推理</h3>
<p>将标准化结果作为新增上下文（tool_outputs）回传大模型，触发基于增强上下文的二次推理流程。</p>
<h3 id="26-终端响应生成">2.6. 终端响应生成</h3>
<p>模型综合初始请求与工具执行结果，生成最终自然语言响应，完成工具增强的对话闭环。</p>
<p>&nbsp;</p>
<h2 id="三核心代码">三、核心代码</h2>
<h3 id="31-定义工具">3.1. 定义工具</h3>
<p>创建类 <code>TestTools</code> 并用 <code>@Tool</code> 注解定义 tool 的描述</p>
<pre><code class="language-java">public static class TestTools {
    @Tool(description = "获取今天日期")
    String getCurrentDateTime() {
        System.out.println("======getCurrentDateTime");
        return LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy年MM月dd日"));
    }

    @Tool(description = "获取当前温度")
    String getCurrentTemperature(MyToolReques  toolReques) {
        System.out.println("======getCurrentTemperature: " + toolReques.localName + "__" + toolReques.date);
        return toolReques.date + toolReques.localName + "温度为20摄氏度";
    }

    public record MyToolReques(String localName, String date) {}
}
</code></pre>
<p>这里定义了两个方法，并通过注解的 description 参数告诉大模型方法的用途。</p>
<blockquote>
<p>record 类型是 Java17 的新特性，可用于替代传统的 POJO 类。</p>
</blockquote>
<h3 id="32-创建对话接口">3.2. 创建对话接口</h3>
<pre><code class="language-java">private ChatMemory chatMemory = new InMemoryChatMemory();
private MessageChatMemoryAdvisor messageChatMemoryAdvisor = new MessageChatMemoryAdvisor(chatMemory);

@GetMapping(value = "/chat")
public String chat(@RequestParam String input, String sessionId, HttpServletResponse response) {
    response.setCharacterEncoding("UTF-8");

    return chatClient.prompt().user(input)
            .tools(new TestTools())
            .advisors(messageChatMemoryAdvisor)
            .advisors(spec -&gt; spec
                    .param(MessageChatMemoryAdvisor.CHAT_MEMORY_CONVERSATION_ID_KEY, sessionId))
            .call()
            .content();
}
</code></pre>
<ul>
<li><strong>tools</strong> 给大模型注册可以调用的方法。</li>
<li><strong>MessageChatMemoryAdvisor</strong> 实现聊天记忆，<code>InMemoryChatMemory</code> 为 <code>SpringAI</code> 自带的实现（基于内存）。</li>
<li>可以使用 <strong>CHAT_MEMORY_CONVERSATION_ID_KEY</strong> 参数指定对话ID，不同的会话ID用于隔离记忆。</li>
</ul>
<h3 id="33-测试">3.3. 测试</h3>
<p><img src="https://img2024.cnblogs.com/blog/1769816/202504/1769816-20250414102432724-1419595107.png" alt="" loading="lazy"></p>
<p>通过后台打印信息可以看到大模型会自动识别，先调用 <code>getCurrentDate</code> 方法获取今天日期，再调用 <code>getCurrentTemperature</code> 方法获取天气。</p>
<blockquote>
<p>======getCurrentDate</p>
<p>======getCurrentTemperature: 广州__2025年04月13日</p>
</blockquote>
<p>&nbsp;</p>
<p>加一个聊天框，测试多轮对话效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/1769816/202504/1769816-20250414102443091-839425980.png" alt="" loading="lazy"></p>
<blockquote>
<p>第二次会话直接输入 <strong>广州</strong> 大模型就知道我要问什么了，说明聊天记忆功能已生效。</p>
</blockquote>
<p>&nbsp;</p>
<h2 id="四总结">四、总结</h2>
<p>本文以问天气为场景，通过 <code>Tool Calling</code> 实现系统 <code>API</code> 调用，同时实现多轮对话中的会话记忆。需要注意的是 <code>InMemoryChatMemory</code> 只能作为测试使用，在企业应用中需要使用其他实现方式，把聊天记录存储在 <code>Redis</code> 或者 <code>数据库</code>中，并且需要考虑消息的保存时间、容量、如何清除等问题。</p>
<p>&nbsp;</p>
<h2 id="五完整代码">五、完整代码</h2>
<ul>
<li>Gitee地址：</li>
</ul>
<p><a href="https://gitee.com/zlt2000/zlt-spring-ai-app" target="_blank" rel="noopener nofollow">https://gitee.com/zlt2000/zlt-spring-ai-app</a></p>
<ul>
<li>Github地址：</li>
</ul>
<p><a href="https://github.com/zlt2000/zlt-spring-ai-app" target="_blank" rel="noopener nofollow">https://github.com/zlt2000/zlt-spring-ai-app</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3283241665717593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 10:26">2025-04-14 10:25</span>&nbsp;
<a href="https://www.cnblogs.com/zlt2000">zlt2000</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18824279);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18824279', targetLink: 'https://www.cnblogs.com/zlt2000/p/18824279', title: 'Spring AI与DeepSeek实战四：系统API调用' })">举报</a>
</div>
        