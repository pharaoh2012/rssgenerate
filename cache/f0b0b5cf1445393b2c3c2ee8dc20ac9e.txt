
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Cookies-Tang/p/18956241" title="发布于 2025-06-29 15:07">
    <span role="heading" aria-level="2">一次 .NET 性能优化之旅：将 GC 压力降低 99%</span>
    

</a>

		</h2>
		<div class="postText"><div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<blockquote>
<p>字数 1128，阅读大约需 6 分钟</p>
</blockquote>
<h1 data-heading="true">一次 .NET 性能优化之旅：将 GC 压力降低 99%</h1>
<h2 data-heading="true">前言：问题的浮现</h2>
<p>最近，我使用 ScottPlot 库开发一个频谱分析应用。应用的核心功能之一是实时显示频谱图，这可以看作是一个高频刷新热力图（Heatmap）。然而，在程序运行一段时间后，我注意到整体性能开始逐渐下降，界面也出现了卡顿。直觉告诉我，这背后一定隐藏着性能瓶颈。</p>
<h2 data-heading="true">分析：探寻性能瓶颈</h2>
<p>面对性能问题，我首先打开了 Visual Studio 的诊断工具，重点关注计数器（Counters）的变化。</p>
<img src="https://img2024.cnblogs.com/blog/633822/202506/633822-20250629150254247-162456676.png" alt="图片" width="461" height="852" class="rich_pages wxw-img" data-imgfileid="100000122" data-ratio="1.8480565371024735" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/dy5VTnqhmDEwYVHO5WVVzoDZ6PAND2sk3xHkdEshAjec24eGVKr4uA34cJicNVyDr63UXlUQFVTOibcmglpmQkhQ/640?wx_fmt=png&amp;from=appmsg&amp;watermark=1" data-w="849" data-original-style="null" data-index="1" data-report-img-idx="0" data-fail="0">
<p id="1751180576190">&nbsp;</p>
VS 诊断工具
<p>上图揭示了几个严重的问题：</p>
<ol class="list-paddingleft-1">
<li>1.&nbsp;<strong>GC 频繁</strong>：进程内存图表中，GC（垃圾回收）标记几乎连成一片，表明垃圾回收异常频繁。</li>
<li>2.&nbsp;<strong>GC 耗时过长</strong>：% Time in GC since last GC 的值非常高，说明 GC 占用了大量的 CPU 时间。</li>
<li>3.&nbsp;<strong>高内存分配率</strong>：Allocation Rate 居高不下，意味着程序在以极高的速率分配内存。</li>
</ol>
<p>显然，问题出在 GC 上。但究竟是哪部分代码导致了如此巨大的 GC 压力呢？</p>
<h2 data-heading="true">定位：追踪 GC 的“元凶”</h2>
<p>为了找出问题的根源，我使用了 Visual Studio 的性能探查器（Performance Profiler），并选择了 .NET 对象分配跟踪（.NET Object Allocation Tracking）模式。</p>
<p>在程序运行一段时间后，我停止了分析，并查看了分配（Allocations）选项卡。结果令人震惊：<code>System.Double</code>&nbsp;类型的分配次数和字节数都异常巨大。这正是导致 GC 频繁的“元凶”。</p>
<p>通过调用堆栈，我迅速定位到了问题代码：</p>
<img src="https://img2024.cnblogs.com/blog/633822/202506/633822-20250629150327985-2001020077.png" alt="图片" width="1024" height="539" class="rich_pages wxw-img" data-imgfileid="100000123" data-ratio="0.5268518518518519" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/dy5VTnqhmDEwYVHO5WVVzoDZ6PAND2skOhExdibeSklkCUbvQG6C0gsSkMHdaON9Nc8hiaptiaMRDbAmomoWCadeA/640?wx_fmt=png&amp;from=appmsg&amp;watermark=1" data-w="1080" data-original-style="null" data-index="2" data-report-img-idx="1" data-fail="0">
<p id="1751180609096">&nbsp;</p>
调用堆栈
<pre class="highlighter-hljs"><code>函数名 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;分配 &nbsp; &nbsp; &nbsp; &nbsp;字节 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;模块名称
+ ScottPlot.NumericConversion.Clamp&lt;T&gt;(T, T, T) &nbsp; &nbsp;3,592,245 &nbsp; &nbsp;86,213,880 &nbsp; &nbsp;scottplot</code></pre>
<p>所有的矛头都指向了&nbsp;<code>ScottPlot.NumericConversion.Clamp&lt;T&gt;(T, T, T)</code>&nbsp;这个函数。</p>
<h2 data-heading="true">探究：泛型与装箱的“陷阱”</h2>
<p>为了弄清真相，我翻阅了 ScottPlot 的源代码，并梳理了整个调用流程：</p>
<ol class="list-paddingleft-1">
<li>1. 在绘制热力图时，程序会调用&nbsp;<code>NumericConversion.Clamp</code>&nbsp;函数，将数据归一化到 0-1 的范围内。</li>
<li>2. 接着，程序会根据归一化后的值，从颜色映射表（ColorMap）中获取对应的颜色。</li>
</ol>
<pre class="highlighter-hljs"><code>public&nbsp;Color&nbsp;GetColor(double&nbsp;position)
{
&nbsp; &nbsp; position = NumericConversion.Clamp(position,&nbsp;0,&nbsp;1);
&nbsp; &nbsp;&nbsp;int&nbsp;index = (int)((Colors.Length -&nbsp;1) * position);
&nbsp; &nbsp;&nbsp;return&nbsp;Colors[index];
}</code></pre>
<p>问题就出在&nbsp;<code>NumericConversion.Clamp</code>&nbsp;函数的实现上：</p>
<pre class="highlighter-hljs"><code>public&nbsp;static&nbsp;T&nbsp;Clamp&lt;T&gt;(T input, T min, T max)&nbsp;where&nbsp;T : IComparable
{
&nbsp; &nbsp;&nbsp;if&nbsp;(input.CompareTo(min) &lt;&nbsp;0)&nbsp;return&nbsp;min;
&nbsp; &nbsp;&nbsp;if&nbsp;(input.CompareTo(max) &gt;&nbsp;0)&nbsp;return&nbsp;max;
&nbsp; &nbsp;&nbsp;return&nbsp;input;
}</code></pre>
<p>这是一个泛型方法，并且&nbsp;<code>double</code>&nbsp;是值类型。当&nbsp;<code>double</code>&nbsp;作为参数传递给这个泛型方法时，会发生<strong>装箱（boxing）</strong>，即&nbsp;<code>double</code>&nbsp;被转换为&nbsp;<code>IComparable</code>&nbsp;接口。在每秒数万次的调用下，这会导致频繁的堆分配，从而引发巨大的 GC 压力。</p>
<h2 data-heading="true">优化：小改动，大提升</h2>
<p>找到了问题的根源，解决方案也就水到渠成了。我为&nbsp;<code>Clamp</code>&nbsp;函数添加了一个&nbsp;<code>double</code>&nbsp;类型的重载版本，从而避免了装箱操作：</p>
<pre class="highlighter-hljs"><code>public&nbsp;static&nbsp;double&nbsp;Clamp(double&nbsp;input,&nbsp;double&nbsp;min,&nbsp;double&nbsp;max)
{
&nbsp; &nbsp;&nbsp;if&nbsp;(input &lt; min)&nbsp;return&nbsp;min;
&nbsp; &nbsp;&nbsp;if&nbsp;(input &gt; max)&nbsp;return&nbsp;max;
&nbsp; &nbsp;&nbsp;return&nbsp;input;
}</code></pre>
<h2 data-heading="true">测试：验证优化效果</h2>
<p>为了验证优化效果，我使用 LinqPad 和 BenchmarkDotNet 进行了性能测试。</p>
<pre class="highlighter-hljs"><code>#load "BenchmarkDotNet"

void&nbsp;Main()
{
&nbsp; &nbsp; RunBenchmark();
}

privatedoublevalue&nbsp;=&nbsp;0.75;
privatedouble&nbsp;min =&nbsp;0.0;
privatedouble&nbsp;max =&nbsp;1.0;

[Benchmark]
public&nbsp;double&nbsp;Clamp_Double()
&nbsp; &nbsp; =&gt; NumericConversion.Clamp(value, min, max);

[Benchmark]
public&nbsp;double&nbsp;Clamp_Generic()
&nbsp; &nbsp; =&gt; NumericConversion.Clamp&lt;double&gt;(value, min, max);

publicstaticclassNumericConversion
{
&nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;double&nbsp;Clamp(double&nbsp;value,&nbsp;double&nbsp;min,&nbsp;double&nbsp;max)
&nbsp; &nbsp; &nbsp; &nbsp; =&gt;&nbsp;value&nbsp;&lt; min ? min : (value&nbsp;&gt; max ? max :&nbsp;value);

&nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;T&nbsp;Clamp&lt;T&gt;(T input, T min, T max)&nbsp;where&nbsp;T : IComparable
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(input.CompareTo(min) &lt;&nbsp;0)&nbsp;return&nbsp;min;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(input.CompareTo(max) &gt;&nbsp;0)&nbsp;return&nbsp;max;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;input;
&nbsp; &nbsp; }
}</code></pre>
<p>测试结果如下：</p>
<img src="https://img2024.cnblogs.com/blog/633822/202506/633822-20250629150345739-86729128.png" alt="图片" width="810" height="314" class="rich_pages wxw-img" data-imgfileid="100000124" data-ratio="0.38796296296296295" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/dy5VTnqhmDEwYVHO5WVVzoDZ6PAND2skxIBsFibBFkAkjad6AA9VMOTAF04lIlLgeJP03Sj13EJV66rLj7j9Q1w/640?wx_fmt=png&amp;from=appmsg&amp;watermark=1" data-w="1080" data-original-style="null" data-index="3" data-report-img-idx="2" data-fail="0">
<p id="1751180626510">&nbsp;</p>
性能测试结果
<p>从上图可以看出，新添加的&nbsp;<code>Clamp_Double</code>&nbsp;方法在性能上远超泛型版本。</p>
<p>再次打开 Visual Studio 的诊断工具，GC 压力几乎消失了：</p>
<img src="https://img2024.cnblogs.com/blog/633822/202506/633822-20250629150359518-1772228549.png" alt="图片" width="461" height="848" class="rich_pages wxw-img" data-imgfileid="100000125" data-ratio="1.840855106888361" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/dy5VTnqhmDEwYVHO5WVVzoDZ6PAND2skypBabq0gB8h7g2ia4JOYyJedKdZxh9mbRln4AMRO30ELmKGls7iaMuQw/640?wx_fmt=png&amp;from=appmsg&amp;watermark=1" data-w="842" data-original-style="null" data-index="4" data-report-img-idx="3" data-fail="0">
<p id="1751180640448">&nbsp;</p>
优化后诊断工具
<h2 data-heading="true">总结：性能优化的启示</h2>
<p>通过对 GC 压力的分析和优化，我成功解决了程序中的性能瓶颈。这次优化的核心在于，通过为&nbsp;<code>NumericConversion.Clamp</code>&nbsp;函数添加&nbsp;<code>double</code>&nbsp;类型的重载，避免了高频调用下的装箱操作，从而显著提升了性能，并将 GC 压力降低了 99% 以上。</p>
<p>这次经历不仅提升了程序的运行效率，也为我未来的性能调优工作积累了宝贵的经验。</p>
<p>目前，我已经将针对 ScottPlot 源码的修改提交了 PR：https://github.com/ScottPlot/ScottPlot/pull/4985</p>
<p>&nbsp;</p>
<h1 data-heading="true" data-pm-slice="0 0 []">&nbsp;</h1>
<p data-pm-slice="0 0 []">欢迎关注我的公众号“<strong>nodered-co</strong>”，原创技术文章第一时间推送。</p>
<center><img src="https://img2024.cnblogs.com/blog/633822/202506/633822-20250629150458400-918773760.webp" alt="图片" width="125" height="125" class="rich_pages wxw-img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/dy5VTnqhmDGvbKHDr0TDia5l9UnviaiajPuCfdPDoDXycNonIMObBH8suDrsqmnMXjUmYoic05UyIfXExfiaicPwVp4g/640?wx_fmt=jpeg&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" data-ratio="1" data-type="jpeg" data-w="344" data-cropselx1="0" data-cropselx2="258" data-cropsely1="0" data-cropsely2="258" data-imgfileid="100000113" data-original-style="-webkit-tap-highlight-color: transparent;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;vertical-align: middle;height: auto !important;border-width: 0px;border-style: solid;border-color: rgb(10, 10, 10);display: block;width: 258px !important;visibility: visible !important;" data-index="5" data-report-img-idx="4" data-fail="0">
<p id="1751180703340">&nbsp;</p>
</center>
</div>
<div class="clear"></div>
</div>
		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-29 15:08">2025-06-29 15:07</span>&nbsp;
<a href="https://www.cnblogs.com/Cookies-Tang">智汇IOT</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18956241);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18956241', targetLink: 'https://www.cnblogs.com/Cookies-Tang/p/18956241', title: '一次 .NET 性能优化之旅：将 GC 压力降低 99%' })">举报</a>

		</p>
	