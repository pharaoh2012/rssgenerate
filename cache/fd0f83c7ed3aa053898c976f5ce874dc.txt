<!----> <meta itemprop="headline" content="实现大文件上传全流程详解(补偿版本)"> <meta itemprop="keywords" content="前端,JavaScript,面试"> <meta itemprop="datePublished" content="2025-08-23T16:58:18.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="再学一点就睡Orz"> <meta itemprop="url" content="https://juejin.cn/user/671151992348125"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实现大文件上传全流程详解(补偿版本)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/671151992348125/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    再学一点就睡Orz
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-08-23T16:58:18.000Z" title="Sat Aug 23 2025 16:58:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-08-23
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>之前分享了大文件上传的前端实现后，但是还有很多细节没有说明，隔了这么久又来考古一下Orz.</p>
<p>在日常开发中，大文件上传是个绕不开的坎——动辄几百 MB 甚至 GB 级的文件，直接上传不仅容易超时，还会让用户体验大打折扣。最近我用 Vue+Express 实现了一套完整的大文件上传方案，支持分片上传、断点续传、秒传和手动中断，今天就带大家从头到尾盘清楚其中的技术细节。</p>
<h2 data-id="heading-0">一、先看效果：我们要实现什么？</h2>
<p>先上核心功能清单，确保大家明确目标，知道我们要解决哪些实际问题：</p>
<ul>
<li>
<p><strong>大文件分片上传</strong>：将文件切成固定大小的小片段分批上传，避免单次请求超时</p>
</li>
<li>
<p>&nbsp;<strong>秒传</strong>：服务器已存在完整文件时，直接返回成功，无需重复上传</p>
</li>
<li>
<p><strong>断点续传</strong>：刷新页面或上传中断后，仅上传未完成的分片，无需从头开始</p>
</li>
<li>
<p><strong>并发控制</strong>：限制同时上传的分片数量，避免请求过多导致浏览器 / 服务器崩溃</p>
</li>
<li>
<p><strong>手动中断</strong>：支持用户随时停止上传，且中断后已传分片不丢失</p>
</li>
</ul>
<p>最终交互很简洁：一个文件选择框 + 上传中的中断按钮，但背后是一整套覆盖「上传前 - 上传中 - 上传后」的完整逻辑。</p>
<h2 data-id="heading-1">二、全流程拆解：从选文件到合并</h2>
<p>我们先从宏观视角梳理整个流程，再拆分成前端和后端的具体实现。整个过程可总结为「5 步走」，每一步都有明确的目标和技术要点：</p>
<pre><code class="hljs language-流程" lang="流程">用户选择文件 → 前端分片+算哈希 → 校验文件状态（秒传/断点续传） → 并发上传分片 → 后端合并分片
</code></pre>
<h3 data-id="heading-2">第一步：用户选择文件（前端触发）</h3>
<p>这是流程的起点，通过原生&nbsp;<code>&lt;input type="file"&gt;</code>&nbsp;获取用户选择的文件，在&nbsp;<code>onchange</code>&nbsp;事件中触发后续逻辑。</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="upload-container"&gt;
    &lt;h2&gt;大文件上传演示&lt;/h2&gt;
    &lt;input @change="handleUpload" type="file" class="file-input" /&gt;
    &lt;!-- 上传中才显示中断按钮 --&gt;
    &lt;button @click="abortUpload" v-if="isUploading" class="abort-btn"&gt;
      中断上传
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from "vue";

// 上传状态管理
const isUploading = ref(false); // 是否正在上传
const abortControllers = ref([]); // 存储所有请求的中断控制器

const handleUpload = async (e) =&gt; {
  const file = e.target.files[0]; // 获取用户选择的单个文件
  if (!file) return; // 未选文件则退出

  // 后续核心逻辑：分片、算哈希、校验...
  // （下文逐步展开）
};
&lt;/script&gt;

&lt;style scoped&gt;
.upload-container { margin: 20px; }
.file-input { margin-right: 10px; }
.abort-btn { padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; }
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-3">第二步：前端分片 + 计算文件哈希</h3>
<p>大文件直接上传会触发超时，因此必须先「拆小」；而哈希值是实现「秒传」和「断点续传」的核心 —— 它是文件的唯一标识，用于告诉服务器 “这是哪个文件”。</p>
<h4 data-id="heading-4">2.1 文件分片：把大文件切成小片段</h4>
<p>用浏览器原生 API&nbsp;<code>File.slice()</code>&nbsp;按固定大小（这里设为 1MB）切割文件，得到多个&nbsp;<code>Blob</code>&nbsp;对象（即「分片」）。</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 分片大小：1MB（可根据需求调整，如5MB/10MB）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; 

<span class="hljs-comment">/**
 * 生成文件分片数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">File</span>} <span class="hljs-variable">file</span> - 用户选择的原始文件
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Blob[]</span>} 分片数组
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">createChunks</span> = (<span class="hljs-params">file</span>) =&gt; {
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前切割位置</span>
  <span class="hljs-keyword">let</span> chunks = [];
  <span class="hljs-keyword">while</span> (cur &lt; file.<span class="hljs-property">size</span>) {
    <span class="hljs-comment">// 从当前位置切割到「当前位置+分片大小」，最后一片可能不足1MB</span>
    <span class="hljs-keyword">const</span> blob = file.<span class="hljs-title function_">slice</span>(cur, cur + <span class="hljs-variable constant_">CHUNK_SIZE</span>);
    chunks.<span class="hljs-title function_">push</span>(blob);
    cur += <span class="hljs-variable constant_">CHUNK_SIZE</span>;
  }
  <span class="hljs-keyword">return</span> chunks;
};

<span class="hljs-comment">// 示例：3.5MB 的文件会生成 4 个分片（1MB+1MB+1MB+0.5MB）</span>
</code></pre>
<h4 data-id="heading-5">2.2 计算文件哈希：生成唯一标识</h4>
<p>用&nbsp;<code>spark-md5</code>&nbsp;库计算文件哈希，但有个关键优化：<strong>不读取整个文件</strong>，而是抽样读取部分片段（首尾分片全量 + 中间分片抽样），既能保证哈希唯一性，又能大幅提升大文件的计算速度。</p>
<p>先安装依赖：</p>
<pre><code class="hljs language-bash" lang="bash">npm install spark-md5 --save
</code></pre>
<p>再实现哈希计算逻辑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> sparkMD5 <span class="hljs-keyword">from</span> <span class="hljs-string">"spark-md5"</span>;

<span class="hljs-comment">/**
 * 计算文件哈希值（抽样优化）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Blob[]</span>} <span class="hljs-variable">chunks</span> - 分片数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;string&gt;</span>} 文件哈希值
 */</span>
 <span class="hljs-keyword">const</span> <span class="hljs-title function_">calHash</span> = (<span class="hljs-params">chunks</span>) =&gt; {
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> sparkMD5.<span class="hljs-title class_">ArrayBuffer</span>(); <span class="hljs-comment">// 初始化MD5计算器</span>
 <span class="hljs-keyword">const</span> fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(); <span class="hljs-comment">// 用于读取Blob内容</span>
 <span class="hljs-keyword">const</span> targets = []; <span class="hljs-comment">// 存放抽样的片段（用于计算哈希）</span>

 <span class="hljs-comment">// 抽样策略：首尾分片全量，中间分片取3个2字节片段（共6字节）</span>
 chunks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">chunk, index</span>) =&gt;</span> {
 <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span> || index === chunks.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 首尾分片：全量加入抽样</span>
    targets.<span class="hljs-title function_">push</span>(chunk);
  } <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 中间分片：取前2字节、中间2字节、后2字节</span>
    targets.<span class="hljs-title function_">push</span>(chunk.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));
    targets.<span class="hljs-title function_">push</span>(chunk.<span class="hljs-title function_">slice</span>(<span class="hljs-variable constant_">CHUNK_SIZE</span> / <span class="hljs-number">2</span>, <span class="hljs-variable constant_">CHUNK_SIZE</span> / <span class="hljs-number">2</span> + <span class="hljs-number">2</span>));
    targets.<span class="hljs-title function_">push</span>(chunk.<span class="hljs-title function_">slice</span>(<span class="hljs-variable constant_">CHUNK_SIZE</span> - <span class="hljs-number">2</span>, <span class="hljs-variable constant_">CHUNK_SIZE</span>));
   }
 });

 <span class="hljs-comment">// 读取抽样片段并计算哈希</span>
 fileReader.<span class="hljs-title function_">readAsArrayBuffer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(targets));
 fileReader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
 spark.<span class="hljs-title function_">append</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>); <span class="hljs-comment">// 累加数据</span>
 <span class="hljs-title function_">resolve</span>(spark.<span class="hljs-title function_">end</span>()); <span class="hljs-comment">// 生成最终哈希值（如："a1b2c3d4e5"）</span>
   };
  });
 };
</code></pre>
<p><strong>为什么抽样？</strong><br>
如果是 1GB 的文件，全量读取计算哈希可能需要几秒甚至十几秒；抽样后仅读取几十字节，耗时可压缩到几百毫秒，用户几乎无感知。</p>
<h3 data-id="heading-6">第三步：校验文件状态（前后端配合）</h3>
<p>拿到文件哈希后，前端需要先向后端发「校验请求」，判断两个关键信息：</p>
<ol>
<li>服务器是否已存在完整文件？（决定是否秒传）</li>
<li>服务器是否有部分已上传的分片？（决定断点续传时要补传哪些分片）</li>
</ol>
<h4 data-id="heading-7">3.1 前端发起校验请求</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fileHash</span> = ref(<span class="hljs-string">""</span>)<span class="hljs-comment">; // 文件哈希值</span>
const <span class="hljs-attr">fileName</span> = ref(<span class="hljs-string">""</span>)<span class="hljs-comment">; // 原始文件名（用于取后缀）</span>

/**
 * 向服务器校验文件状态
 * @returns {Promise&lt;Object&gt;} 校验结果（shouldUpload: 是否需要上传, existChunks: 已上传分片列表）
 */
const <span class="hljs-attr">verify</span> = async () =&gt; {
  const <span class="hljs-attr">res</span> = await fetch(<span class="hljs-string">"http://localhost:3000/verify"</span>, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      fileHash: fileHash.value,
      fileName: fileName.value,
    }),
  })<span class="hljs-comment">;</span>
  return res.json()<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 在handleUpload中调用校验
const <span class="hljs-attr">handleUpload</span> = async (e) =&gt; {
  const <span class="hljs-attr">file</span> = e.target.files[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
  if (!file) return<span class="hljs-comment">;</span>

  <span class="hljs-attr">fileName.value</span> = file.name<span class="hljs-comment">;</span>
  const <span class="hljs-attr">chunks</span> = createChunks(file)<span class="hljs-comment">;</span>
  <span class="hljs-attr">fileHash.value</span> = await calHash(chunks)<span class="hljs-comment">; // 计算哈希</span>

  // 发起校验
  const <span class="hljs-attr">verifyRes</span> = await verify()<span class="hljs-comment">;</span>
  if (!verifyRes.data.shouldUpload) {
    // 服务器已存在完整文件 → 秒传成功
    alert("秒传成功！文件已存在")<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;</span>
  }

  // 需上传：进入分片上传环节（下文展开）
  await uploadChunks(chunks, verifyRes.data.existChunks)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-8">3.2 后端处理校验逻辑</h4>
<p>后端需要检查「完整文件」和「已上传分片」的存在性，返回给前端决策依据。</p>
<p>先初始化后端项目并安装依赖：
# 1. 初始化
npm init -y</p>
<pre><code class="hljs language-lua" lang="lua"># <span class="hljs-number">2.</span> 安装依赖
npm install express cors multiparty fs-extra <span class="hljs-built_in">path</span> <span class="hljs-comment">--save</span>
</code></pre>
<p>再实现&nbsp;<code>/verify</code>&nbsp;接口：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">express</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fse</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"fs-extra"</span>); <span class="hljs-comment">// 文件操作工具（比原生fs更易用）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">cors</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"cors"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">bodyParser</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">"body-parser"</span>);

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">app</span> = <span class="hljs-title function_ invoke__">express</span>();
app.<span class="hljs-keyword">use</span>(<span class="hljs-title function_ invoke__">cors</span>()); <span class="hljs-comment">// 解决跨域</span>
app.<span class="hljs-keyword">use</span>(bodyParser.<span class="hljs-title function_ invoke__">json</span>()); <span class="hljs-comment">// 解析JSON请求体</span>

<span class="hljs-comment">// 上传根目录（所有分片和完整文件都存在这里）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UPLOAD_DIR</span> = path.<span class="hljs-title function_ invoke__">resolve</span>(__dirname, <span class="hljs-string">"uploads"</span>);
<span class="hljs-comment">// 确保上传目录存在</span>
fse.<span class="hljs-title function_ invoke__">ensureDirSync</span>(UPLOAD_DIR);

<span class="hljs-comment">/**
 * 提取文件名后缀（如："test.pdf" → ".pdf"）
 * <span class="hljs-doctag">@param</span> {string} fileName - 原始文件名
 * <span class="hljs-doctag">@returns</span> {string} 文件后缀
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">extractExt</span> = (fileName) =&gt; {
  <span class="hljs-keyword">return</span> fileName.<span class="hljs-title function_ invoke__">slice</span>(fileName.<span class="hljs-title function_ invoke__">lastIndexOf</span>(<span class="hljs-string">"."</span>));
};

<span class="hljs-comment">// 校验接口：/verify</span>
app.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">"/verify"</span>, <span class="hljs-title function_ invoke__">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { fileHash, fileName } = req.body;
  // 完整文件路径 = 上传目录 + 文件哈希 + 原文件后缀（确保文件名唯一）
  <span class="hljs-keyword">const</span> completeFilePath = path.<span class="hljs-title function_ invoke__">resolve</span>(UPLOAD_DIR, `${fileHash}${<span class="hljs-title function_ invoke__">extractExt</span>(fileName)}`);

  // <span class="hljs-number">1</span>. 检查完整文件是否存在 → 秒传逻辑
  <span class="hljs-keyword">if</span> (fse.<span class="hljs-title function_ invoke__">existsSync</span>(completeFilePath)) {
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_ invoke__">json</span>({
      <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">data</span>: { <span class="hljs-attr">shouldUpload</span>: <span class="hljs-literal">false</span> } // 无需上传
    });
  }

  <span class="hljs-comment">// 2. 检查已上传的分片 → 断点续传逻辑</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">chunkDir</span> = path.<span class="hljs-title function_ invoke__">resolve</span>(UPLOAD_DIR, fileHash); <span class="hljs-comment">// 分片临时目录（用文件哈希命名）</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">existChunks</span> = fse.<span class="hljs-title function_ invoke__">existsSync</span>(chunkDir) 
    ? await fse.<span class="hljs-title function_ invoke__">readdir</span>(chunkDir) <span class="hljs-comment">// 已上传的分片列表（如：["a1b2-0", "a1b2-1"]）</span>
    : [];

  res.<span class="hljs-title function_ invoke__">json</span>({
    <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">shouldUpload</span>: <span class="hljs-literal">true</span>, // 需要上传
      <span class="hljs-attr">existChunks</span>: existChunks // 已上传的分片标识，供前端过滤
    }
  });
});

<span class="hljs-comment">// 启动服务器</span>
app.<span class="hljs-title function_ invoke__">listen</span>(<span class="hljs-number">3000</span>, () =&gt; {
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">"服务器运行在 http://localhost:3000"</span>);
});
</code></pre>
<h3 data-id="heading-9">第四步：并发上传分片（前端核心）</h3>
<p>这是前端最复杂的环节，需要解决三个关键问题：</p>
<ol>
<li>过滤已上传的分片（只传缺失的）</li>
<li>控制并发请求数（避免请求爆炸）</li>
<li>支持手动中断上传（用户可随时停止）</li>
</ol>
<h4 data-id="heading-10">4.1 过滤已上传的分片</h4>
<p>根据后端返回的&nbsp;<code>existChunks</code>（已上传分片标识列表），过滤掉不需要重新上传的分片，只生成待上传的&nbsp;<code>FormData</code>。</p>
<pre><code class="hljs language-ini" lang="ini">/**
 * 上传分片（核心函数）
 * @param {Blob<span class="hljs-section">[]</span>} chunks - 所有分片数组
 * @param {string<span class="hljs-section">[]</span>} existChunks - 已上传的分片标识列表
 */
const <span class="hljs-attr">uploadChunks</span> = async (chunks, existChunks) =&gt; {
  <span class="hljs-attr">isUploading.value</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">abortControllers.value</span> = []<span class="hljs-comment">; // 清空历史中断控制器</span>

  // 1. 生成所有分片的基础信息（文件哈希、分片标识、分片数据）
  const <span class="hljs-attr">chunkInfoList</span> = chunks.map((chunk, index) =&gt; ({
    fileHash: fileHash.value,
    chunkHash: `${fileHash.value}-${index}`, // 分片标识：文件哈希-序号（确保唯一）
    chunk: chunk
  }))<span class="hljs-comment">;</span>

  // 2. 过滤已上传的分片 → 只保留待上传的
  const <span class="hljs-attr">formDatas</span> = chunkInfoList
    .filter(<span class="hljs-attr">item</span> =&gt; !existChunks.includes(item.chunkHash))
    .map(<span class="hljs-attr">item</span> =&gt; {
      const <span class="hljs-attr">formData</span> = new FormData()<span class="hljs-comment">;</span>
      formData.append("filehash", item.fileHash)<span class="hljs-comment">;</span>
      formData.append("chunkhash", item.chunkHash)<span class="hljs-comment">;</span>
      formData.append("chunk", item.chunk)<span class="hljs-comment">; // 分片二进制数据</span>
      return formData<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>

  if (<span class="hljs-attr">formDatas.length</span> === <span class="hljs-number">0</span>) {
    // 所有分片已上传 → 直接请求合并
    mergeRequest()<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;</span>
  }

  // 3. 并发上传分片（下文展开）
  await uploadWithConcurrencyControl(formDatas)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-11">4.2 控制并发请求数</h4>
<p>用「请求池 +&nbsp;<code>Promise.race</code>」限制同时上传的分片数量（这里设为 6 个），避免请求过多导致浏览器 / 服务器压力过大。</p>
<pre><code class="hljs language-ini" lang="ini">/**
 * 带并发控制的分片上传
 * @param {FormData<span class="hljs-section">[]</span>} formDatas - 待上传的FormData列表
 */
const <span class="hljs-attr">uploadWithConcurrencyControl</span> = async (formDatas) =&gt; {
  const <span class="hljs-attr">MAX_CONCURRENT</span> = <span class="hljs-number">6</span><span class="hljs-comment">; // 最大并发数（可根据需求调整）</span>
  let <span class="hljs-attr">currentIndex</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // 当前待上传的分片索引</span>
  const <span class="hljs-attr">taskPool</span> = []<span class="hljs-comment">; // 存储当前正在执行的请求（请求池）</span>

  while (currentIndex &lt; formDatas.length) {
    // 为每个请求创建独立的中断控制器（AbortController）
    const <span class="hljs-attr">controller</span> = new AbortController()<span class="hljs-comment">;</span>
    const { signal } = controller<span class="hljs-comment">;</span>
    abortControllers.value.push(controller)<span class="hljs-comment">; // 存入控制器列表</span>

    // 发起分片上传请求
    const <span class="hljs-attr">task</span> = fetch(<span class="hljs-string">"http://localhost:3000/upload"</span>, {
      method: "POST",
      body: formDatas<span class="hljs-section">[currentIndex]</span>,
      signal: signal // 绑定中断信号
    })
    .then(<span class="hljs-attr">res</span> =&gt; {
      // 请求完成后，从请求池和控制器列表中移除
      taskPool.splice(taskPool.indexOf(task), 1)<span class="hljs-comment">;</span>
      <span class="hljs-attr">abortControllers.value</span> = abortControllers.value.filter(c =&gt; c !== controller)<span class="hljs-comment">;</span>
      return res<span class="hljs-comment">;</span>
    })
    .catch(<span class="hljs-attr">err</span> =&gt; {
      // 捕获错误：区分「用户中断」和「其他错误」
      if (err.name !== "AbortError") {
        console.error("分片上传失败：", err)<span class="hljs-comment">;</span>
        // 可在这里加「错误重试」逻辑（如重试3次）
      }
      // 无论何种错误，都清理状态
      taskPool.splice(taskPool.indexOf(task), 1)<span class="hljs-comment">;</span>
      <span class="hljs-attr">abortControllers.value</span> = abortControllers.value.filter(c =&gt; c !== controller)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>

    taskPool.push(task)<span class="hljs-comment">;</span>

    // 当请求池满了，等待最快完成的一个请求再继续（释放并发名额）
    if (<span class="hljs-attr">taskPool.length</span> === MAX_CONCURRENT) {
      await Promise.race(taskPool)<span class="hljs-comment">;</span>
    }

    currentIndex++<span class="hljs-comment">;</span>
  }

  // 等待所有剩余请求完成
  await Promise.all(taskPool)<span class="hljs-comment">;</span>
  // 所有分片上传完成 → 请求合并
  mergeRequest()<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-12">4.3 手动中断上传</h4>
<p>用&nbsp;<code>AbortController</code>&nbsp;中断所有正在进行的请求，并清理状态，确保中断后下次上传能正常恢复。</p>
<pre><code class="hljs language-ini" lang="ini">/**
 * 中断上传（用户触发）
 */
const <span class="hljs-attr">abortUpload</span> = () =&gt; {
  if (!isUploading.value) return<span class="hljs-comment">;</span>

  // 1. 中断所有正在进行的请求
  abortControllers.value.forEach(<span class="hljs-attr">controller</span> =&gt; {
    controller.abort()<span class="hljs-comment">; // 调用中断方法，触发请求的AbortError</span>
  })<span class="hljs-comment">;</span>

  // 2. 清理状态
  <span class="hljs-attr">abortControllers.value</span> = []<span class="hljs-comment">;</span>
  <span class="hljs-attr">isUploading.value</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>

  // 3. 通知用户
  alert("上传已中断，下次可继续上传")<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-13">第五步：后端接收分片并合并</h3>
<p>所有分片上传完成后，前端需要通知后端「合并分片」，后端按分片序号排序，用「流（Stream）」拼接成完整文件（避免内存溢出）。</p>
<h4 data-id="heading-14">5.1 后端接收分片（/upload 接口）</h4>
<p>用&nbsp;<code>multiparty</code>&nbsp;解析前端发送的&nbsp;<code>FormData</code>，将分片保存到临时目录（以文件哈希命名）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 后端：/upload 接口（接收分片）</span>
<span class="hljs-keyword">const</span> multiparty = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multiparty"</span>);

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/upload"</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> multiparty.<span class="hljs-title class_">Form</span>(); <span class="hljs-comment">// 解析FormData的工具</span>

  <span class="hljs-comment">// 解析请求（fields：普通字段，files：文件字段）</span>
  form.<span class="hljs-title function_">parse</span>(req, <span class="hljs-keyword">async</span> (err, fields, files) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"分片解析失败："</span>, err);
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">status</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"分片上传失败"</span> });
    }

    <span class="hljs-comment">// 提取字段</span>
    <span class="hljs-keyword">const</span> fileHash = fields[<span class="hljs-string">"filehash"</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 文件哈希</span>
    <span class="hljs-keyword">const</span> chunkHash = fields[<span class="hljs-string">"chunkhash"</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 分片标识</span>
    <span class="hljs-keyword">const</span> chunkFile = files[<span class="hljs-string">"chunk"</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 分片临时文件（multiparty生成的临时文件）</span>

    <span class="hljs-comment">// 分片临时目录（如：uploads/a1b2c3）</span>
    <span class="hljs-keyword">const</span> chunkDir = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, fileHash);
    <span class="hljs-comment">// 确保临时目录存在</span>
    <span class="hljs-keyword">await</span> fse.<span class="hljs-title function_">ensureDir</span>(chunkDir);

    <span class="hljs-comment">// 目标路径：将分片从临时位置移动到临时目录</span>
    <span class="hljs-keyword">const</span> targetChunkPath = path.<span class="hljs-title function_">resolve</span>(chunkDir, chunkHash);
    <span class="hljs-keyword">await</span> fse.<span class="hljs-title function_">move</span>(chunkFile.<span class="hljs-property">path</span>, targetChunkPath);

    <span class="hljs-comment">// 响应前端：分片上传成功</span>
    res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"分片上传成功"</span> });
  });
});
</code></pre>
<h4 data-id="heading-15">5.2 后端合并分片（/merge 接口）</h4>
<p>合并的核心是「按序号排序分片」+「用流拼接」，边读边写，避免一次性加载大文件到内存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 前端：请求合并分片的函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeRequest</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:3000/merge"</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span> },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">fileHash</span>: fileHash.<span class="hljs-property">value</span>,
      <span class="hljs-attr">fileName</span>: fileName.<span class="hljs-property">value</span>,
      <span class="hljs-attr">size</span>: <span class="hljs-variable constant_">CHUNK_SIZE</span> <span class="hljs-comment">// 分片大小（用于计算写入位置）</span>
    }),
  });

  <span class="hljs-comment">// 合并完成后的清理</span>
  isUploading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">"文件上传完成！"</span>);
};

<span class="hljs-comment">// 后端：/merge 接口（合并分片）</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/merge"</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { fileHash, fileName, <span class="hljs-attr">size</span>: <span class="hljs-variable constant_">CHUNK_SIZE</span> } = req.<span class="hljs-property">body</span>;
  <span class="hljs-comment">// 完整文件路径（上传目录 + 文件哈希 + 后缀）</span>
  <span class="hljs-keyword">const</span> completeFilePath = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, <span class="hljs-string">`<span class="hljs-subst">${fileHash}</span><span class="hljs-subst">${extractExt(fileName)}</span>`</span>);
  <span class="hljs-comment">// 分片临时目录</span>
  <span class="hljs-keyword">const</span> chunkDir = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, fileHash);

  <span class="hljs-comment">// 检查分片目录是否存在（防止恶意请求）</span>
  <span class="hljs-keyword">if</span> (!fse.<span class="hljs-title function_">existsSync</span>(chunkDir)) {
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">status</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"分片目录不存在"</span> });
  }

  <span class="hljs-comment">// 1. 读取所有分片并按序号排序</span>
  <span class="hljs-keyword">const</span> chunkPaths = <span class="hljs-keyword">await</span> fse.<span class="hljs-title function_">readdir</span>(chunkDir);
  chunkPaths.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-comment">// 从分片标识中提取序号（如："a1b2-0" → 0）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(a.<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">parseInt</span>(b.<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">1</span>]);
  });

  <span class="hljs-comment">// 2. 用流拼接分片（边读边写，低内存占用）</span>
  <span class="hljs-keyword">const</span> mergePromises = chunkPaths.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">chunkName, index</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> chunkPath = path.<span class="hljs-title function_">resolve</span>(chunkDir, chunkName);
      <span class="hljs-keyword">const</span> readStream = fse.<span class="hljs-title function_">createReadStream</span>(chunkPath); <span class="hljs-comment">// 分片读流</span>
      <span class="hljs-keyword">const</span> writeStream = fse.<span class="hljs-title function_">createWriteStream</span>(completeFilePath, {
        <span class="hljs-attr">start</span>: index * <span class="hljs-variable constant_">CHUNK_SIZE</span>, <span class="hljs-comment">// 写入起始位置（精确到字节）</span>
        <span class="hljs-attr">end</span>: (index + <span class="hljs-number">1</span>) * <span class="hljs-variable constant_">CHUNK_SIZE</span> <span class="hljs-comment">// 写入结束位置</span>
      });

      <span class="hljs-comment">// 分片读取完成后：删除分片文件 +  resolve</span>
      readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, <span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-keyword">await</span> fse.<span class="hljs-title function_">unlink</span>(chunkPath); <span class="hljs-comment">// 删除单个分片</span>
        <span class="hljs-title function_">resolve</span>();
      });

      <span class="hljs-comment">// 管道流：将分片内容写入完整文件</span>
      readStream.<span class="hljs-title function_">pipe</span>(writeStream);
    });
  });

  <span class="hljs-comment">// 3. 等待所有分片合并完成</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(mergePromises);
  <span class="hljs-comment">// 4. 删除分片临时目录（合并完成后清理）</span>
  <span class="hljs-keyword">await</span> fse.<span class="hljs-title function_">remove</span>(chunkDir);

  <span class="hljs-comment">// 响应前端：合并成功</span>
  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"文件合并成功"</span> });
});
</code></pre>
<p><strong>为什么用流？</strong><br>
如果直接用&nbsp;<code>fs.readFile</code>&nbsp;读取所有分片内容再拼接，1GB 的文件会占用 1GB 内存，可能导致服务器内存溢出；而流操作（<code>createReadStream</code>/<code>createWriteStream</code>）是边读边写，内存占用始终很低（仅几 KB/MB）。</p>
<h2 data-id="heading-16">三、核心难点与解决方案总结</h2>
<p>大文件上传的核心痛点已在方案中解决，这里整理成表格，方便大家快速回顾：</p>








































<table><thead><tr><th>核心难点</th><th>解决方案</th><th>代码关键位置</th></tr></thead><tbody><tr><td>大文件哈希计算慢</td><td>抽样读取片段（首尾全量 + 中间分片抽样）</td><td><code>calHash</code>&nbsp;函数</td></tr><tr><td>并发请求过多导致崩溃</td><td>用「请求池 + Promise.race」限制并发数</td><td><code>uploadChunks</code>&nbsp;函数</td></tr><tr><td>用户需要手动中断上传</td><td>用&nbsp;<code>AbortController</code>&nbsp;中断请求 + 清理状态</td><td><code>abortUpload</code>&nbsp;函数</td></tr><tr><td>分片合并顺序错乱</td><td>按分片序号排序，用流按固定位置写入</td><td>后端&nbsp;<code>/merge</code>&nbsp;接口的排序逻辑</td></tr><tr><td>刷新页面后需从头上传</td><td>校验时返回已上传分片，前端过滤后再上传</td><td>前端&nbsp;<code>filter</code>&nbsp;逻辑 + 后端&nbsp;<code>/verify</code>&nbsp;接口</td></tr><tr><td>大文件合并内存溢出</td><td>用流（Stream）边读边写，避免全量加载</td><td>后端&nbsp;<code>/merge</code>&nbsp;接口的流操作</td></tr></tbody></table>
<h2 data-id="heading-17">四、最后</h2>
<p>大文件上传看似复杂，拆解后其实是「分片→校验→上传→合并」四个核心步骤，每个步骤解决一个具体问题。这套方案用 Vue+Express 实现，代码简洁易懂，可直接作为项目基础版本，再根据实际需求扩展优化。</p>
<p>实际开发中，还需要结合业务场景补充异常处理（如文件大小限制、格式校验）、日志监控（上传失败告警）等功能。如果大家在实践中遇到问题，欢迎在评论区交流。</p>
<hr>
<p>如果您觉得这篇文章对您有帮助，欢迎点赞和收藏，大家的支持是我继续创作优质内容的动力🌹🌹🌹也希望您能在😉😉😉<a href="https://juejin.cn/user/671151992348125" target="_blank" title="https://juejin.cn/user/671151992348125">我的主页</a> 😉😉😉找到更多对您有帮助的内容。</p>
<ul>
<li>致敬每一位赶路人</li>
</ul></div></div>