
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18685651" title="发布于 2025-01-22 13:39">
    <span role="heading" aria-level="2">Svelte 最新中文文档翻译（3）—— 符文（Runes）上</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>Svelte，一个非常“有趣”、用起来“很爽”的前端框架。从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://github.com/user-attachments/assets/2b3963ee-cca7-4378-9bdf-ca491e09d10d" alt="Image" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目，也是我做个人项目的首选技术栈。</strong></p>
<p>目前 Svelte 基于 Svelte 5 发布了最新的官方文档，但却缺少对应的中文文档。为了帮助大家学习 Svelte，为爱发电翻译了官方文档。</p>
<p>我同时搭建了 Svelte 最新的中文文档站点：<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">https://svelte.yayujs.com</a> ，如果需要辅助学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>虽说是翻译，但个人并不喜欢严格遵守原文，为了保证中文阅读流畅，会删减部分语句，对难懂的部分也会另做补充解释，希望能给大家带来一个好的中文学习体验。</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“低调务实优秀中国好青年”</a>前端社群，分享技术，带你成长。</p>
<h2 id="什么是符文">什么是符文？</h2>
<blockquote>
<p>[!NOTE] <strong>符文</strong> /ro͞on/ <em>名词</em></p>
<p>一个用作神秘或魔法符号的字母或标记。</p>
</blockquote>
<p>符文是你在 <code>.svelte</code> 和 <code>.svelte.js</code>/<code>.svelte.ts</code> 文件中用来控制 Svelte 编译器的符号。如果你把 Svelte 看作一门语言，符文就是语法的一部分 — 它们是 <em>关键字</em>。</p>
<p>符文有一个 <code>$</code> 前缀，看起来像函数：</p>
<pre><code class="language-js">let message = $state('hello');
</code></pre>
<p>然而，它们与普通的 JavaScript 函数有很大不同：</p>
<ul>
<li>你不需要导入它们 — 它们是语言的一部分</li>
<li>它们不是值 — 你不能将它们赋值给变量或作为参数传递给函数</li>
<li>就像 JavaScript 关键字一样，它们只在特定位置有效（如果你把它们放在错误的地方，编译器会提示你）</li>
</ul>
<blockquote>
<p>[!LEGACY]<br>
在 Svelte 5 之前，符文是不存在的。</p>
</blockquote>
<h2 id="state">$state</h2>
<h3 id="state-1">$state</h3>
<p><code>$state</code> 符文允许你创建响应式状态，这意味着当状态改变时，你的 UI 会作出响应。</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;
	点击次数: {count}
&lt;/button&gt;
</code></pre>
<p>与你可能遇到的其他框架不同，这里没有用于操作状态的 API —— <code>count</code> 只是一个数字，而不是对象或函数，你可以像更新任何其他变量一样更新它。</p>
<h4 id="深层状态">深层状态</h4>
<p>如果 <code>$state</code> 用于数组或简单对象，结果将是一个深度响应式的<em>状态代理</em>。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener nofollow">代理（Proxies）</a>允许 Svelte 在你读取或写入属性时运行代码，包括通过像 <code>array.push(...)</code> 这样的方法，触发精确的更新。</p>
<blockquote>
<p>[!NOTE] 像 <code>Set</code> 和 <code>Map</code> 这样的类不会被代理，但 Svelte 为这些内置类型提供了响应式实现，可以从 <a href="https://svelte.yayujs.com/docs/svelte/svelte-reactivity" target="_blank" rel="noopener nofollow"><code>svelte/reactivity</code></a> 导入。</p>
</blockquote>
<p>状态会递归地进行代理，直到 Svelte 找到数组或简单对象以外的东西。在像这样的情况下...</p>
<pre><code class="language-js">let todos = $state([
	{
		done: false,
		text: '添加更多待办事项'
	}
]);
</code></pre>
<p>...修改单个待办事项的属性将触发 UI 中依赖该特定属性的任何内容的更新：</p>
<pre><code class="language-js">let todos = [{ done: false, text: '添加更多待办事项' }];
// ---cut---
todos[0].done = !todos[0].done;
</code></pre>
<p>如果你向数组推入一个新对象，它也会被代理：</p>
<pre><code class="language-js">// @filename: ambient.d.ts
declare global {
	const todos: Array&lt;{ done: boolean, text: string }&gt;
}

// @filename: index.js
// ---cut---
todos.push({
	done: false,
	text: '吃午饭'
});
</code></pre>
<blockquote>
<p>[!NOTE] 当你更新代理的属性时，原始对象不会被改变。</p>
</blockquote>
<p>注意，如果你解构一个响应式值，解构后的引用不是响应式的 —— 就像普通的 JavaScript 一样，它们在解构时就被求值了：：</p>
<pre><code class="language-js">let todos = [{ done: false, text: '添加更多待办事项' }];
// ---cut---
let { done, text } = todos[0];

// 这不会影响 `done` 的值
todos[0].done = !todos[0].done;
</code></pre>
<h4 id="类">类</h4>
<p>你也可以在类字段中使用 <code>$state</code>（无论是公共的还是私有的）：</p>
<pre><code class="language-js">// @errors: 7006 2554
class Todo {
	done = $state(false);
	text = $state();

	constructor(text) {
		this.text = text;
	}

	reset() {
		this.text = '';
		this.done = false;
	}
}
</code></pre>
<blockquote>
<p>[!NOTE] 编译器将 <code>done</code> 和 <code>text</code> 转换为类原型上引用私有字段的 <code>get</code>/<code>set</code> 方法。这意味着这些属性是不可枚举的。</p>
</blockquote>
<p>在 JavaScript 中调用方法时，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener nofollow"><code>this</code></a> 的值很重要。下面这种写法不会起作用，因为 <code>reset</code> 方法中的 <code>this</code> 将是 <code>&lt;button&gt;</code> 而不是 <code>Todo</code>：</p>
<pre><code class="language-svelte">&lt;button onclick={todo.reset}&gt;
	重置
&lt;/button&gt;
</code></pre>
<p>你可以使用内联函数...</p>
<pre><code class="language-svelte">&lt;button onclick=+++{() =&gt; todo.reset()}&gt;+++
	重置
&lt;/button&gt;
</code></pre>
<p>...或者在类定义中使用箭头函数：</p>
<pre><code class="language-js">// @errors: 7006 2554
class Todo {
	done = $state(false);
	text = $state();

	constructor(text) {
		this.text = text;
	}

	+++reset = () =&gt; {+++
		this.text = '';
		this.done = false;
	}
}
</code></pre>
<h3 id="stateraw"><code>$state.raw</code></h3>
<p>在不希望对象和数组具有深度响应性的情况下，你可以使用 <code>$state.raw</code>。</p>
<p>使用 <code>$state.raw</code> 声明的状态不能被改变；它只能被重新赋值。换句话说，与其给对象的属性赋值或使用数组方法如 <code>push</code>，不如在想要更新时完全替换对象或数组：</p>
<pre><code class="language-js">let person = $state.raw({
	name: 'Heraclitus',
	age: 49
});

// 这将不会生效
person.age += 1;

// 这将生效，因为我们创建了一个新的 person
person = {
	name: 'Heraclitus',
	age: 50
};
</code></pre>
<p>这可以提高性能，特别是对于那些你本来就不打算改变的大型数组和对象，因为它避免了使它们变成响应式的开销。注意，原始状态可以包含响应式状态（例如，一个包含响应式对象的原始数组）。</p>
<h3 id="statesnapshot"><code>$state.snapshot</code></h3>
<p>要获取深度响应式 <code>$state</code> 代理的静态快照，使用 <code>$state.snapshot</code>：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let counter = $state({ count: 0 });

	function onclick() {
		// 将输出 `{ count: ... }` 而不是 `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
&lt;/script&gt;
</code></pre>
<p>当你想要将某些状态传递给不希望接收代理的外部库或 API（如 <code>structuredClone</code>）时，这会很有用。</p>
<h3 id="将状态传递给函数">将状态传递给函数</h3>
<p>JavaScript 是一种按值传递的语言 —— 当你调用一个函数时，参数是值而不是变量。换句话说：</p>
<pre><code class="language-js">/// file: index.js
// @filename: index.js
// ---cut---
/**
 * @param {number} a
 * @param {number} b
 */
function add(a, b) {
	return a + b;
}

let a = 1;
let b = 2;
let total = add(a, b);
console.log(total); // 3

a = 3;
b = 4;
console.log(total); // 仍然是 3！
</code></pre>
<p>如果 <code>add</code> 想要访问 <code>a</code> 和 <code>b</code> 的当前值，并返回当前的 <code>total</code> 值，你需要使用函数：</p>
<pre><code class="language-js">/// file: index.js
// @filename: index.js
// ---cut---
/**
 * @param {() =&gt; number} getA
 * @param {() =&gt; number} getB
 */
function add(+++getA, getB+++) {
	return +++() =&gt; getA() + getB()+++;
}

let a = 1;
let b = 2;
let total = add+++(() =&gt; a, () =&gt; b)+++;
console.log(+++total()+++); // 3

a = 3;
b = 4;
console.log(+++total()+++); // 7
</code></pre>
<p>Svelte 中的状态也不例外 —— 当你引用使用 <code>$state</code> 符文声明的内容时...</p>
<pre><code class="language-js">let a = +++$state(1)+++;
let b = +++$state(2)+++;
</code></pre>
<p>...你访问的是它的当前值。</p>
<p>注意，"函数"的范围很广 —— 它包括代理的属性和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noopener nofollow"><code>get</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="noopener nofollow"><code>set</code></a> 属性...</p>
<pre><code class="language-js">/// file: index.js
// @filename: index.js
// ---cut---
/**
 * @param {{ a: number, b: number }} input
 */
function add(input) {
	return {
		get value() {
			return input.a + input.b;
		}
	};
}

let input = $state({ a: 1, b: 2 });
let total = add(input);
console.log(total.value); // 3

input.a = 3;
input.b = 4;
console.log(total.value); // 7
</code></pre>
<p>...不过如果你发现自己在写这样的代码，考虑使用<a href="https://svelte.yayujs.com/docs/svelte/$state#Classes" target="_blank" rel="noopener nofollow">类</a>代替。</p>
<h2 id="derived">$derived</h2>
<p>派生状态通过 <code>$derived</code> 符文声明：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
	let doubled = $derived(count * 2);
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;
	{doubled}
&lt;/button&gt;

&lt;p&gt;{count} 的两倍是 {doubled}&lt;/p&gt;
</code></pre>
<p><code>$derived(...)</code> 内的表达式应该没有副作用。Svelte 将不允许在派生表达式内进行状态更改（例如 <code>count++</code>）。</p>
<p>与 <code>$state</code> 一样，你可以将类字段标记为 <code>$derived</code>。</p>
<blockquote>
<p>[!NOTE] Svelte 组件中的代码仅在创建时执行一次。如果没有 <code>$derived</code> 符文，即使 <code>count</code> 发生变化，<code>doubled</code> 也会保持其原始值。</p>
</blockquote>
<h3 id="derivedby"><code>$derived.by</code></h3>
<p>有时你需要创建不适合放在简短表达式中的复杂派生。在这些情况下，你可以使用 <code>$derived.by</code>，它接受一个函数作为参数。</p>
<pre><code class="language-svelte">&lt;script&gt;
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() =&gt; {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
&lt;/script&gt;

&lt;button onclick={() =&gt; numbers.push(numbers.length + 1)}&gt;
	{numbers.join(' + ')} = {total}
&lt;/button&gt;
</code></pre>
<p>本质上，<code>$derived(expression)</code> 等同于 <code>$derived.by(() =&gt; expression)</code>。</p>
<h3 id="理解依赖关系">理解依赖关系</h3>
<p>在 <code>$derived</code> 表达式（或 <code>$derived.by</code> 函数体）内同步读取的任何内容都被视为派生状态的<em>依赖项</em>。当状态发生变化时，派生将被标记为<em>脏数据（dirty）</em>，并在下次读取时重新计算。</p>
<p>要使一段状态不被视为依赖项，请使用 <a href="https://svelte.yayujs.com/docs/svelte/svelte#untrack" target="_blank" rel="noopener nofollow"><code>untrack</code></a>。</p>
<h2 id="effect">$effect</h2>
<h3 id="effect-1">$effect</h3>
<p>Effects 使你的应用程序能够 <em>做点事情</em>。当 Svelte 运行一个 effect 函数时，它会跟踪被访问（除非在 <a href="https://svelte.yayujs.com/docs/svelte/svelte#untrack" target="_blank" rel="noopener nofollow"><code>untrack</code></a> 中访问）的状态（和派生状态），并在该状态后续发生变化时重新运行该函数。</p>
<p>Svelte 应用程序中的大多数 effects 是由 Svelte 本身创建的——例如，当 <code>name</code> 变化时，更新 <code>&lt;h1&gt;hello {name}!&lt;/h1&gt;</code> 中的文本。</p>
<p>但你也可以使用 <code>$effect</code> 符文创建自己的 effects，当你需要将外部系统（无论是库、<code>&lt;canvas&gt;</code> 元素，还是跨网络的某些东西）与 Svelte 应用程序内部的状态同步时，这非常有用。</p>
<blockquote>
<p>[!NOTE] 避免过度使用 <code>$effect</code>！当你在 effects 中做太多工作时，代码通常会变得难以理解和维护。请参阅 <a href="https://svelte.yayujs.com/docs/svelte/$effect#When-not-to-use-$effect" target="_blank" rel="noopener nofollow">何时不使用 <code>$effect</code></a> 了解替代方法。</p>
</blockquote>
<p>你的 effects 在组件挂载到 DOM 之后运行，并在状态变化后的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener nofollow">微任务</a> 中运行（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE31S246bMBD9lZF3pSRSAqTVvrCAVPUP2sdSKY4ZwJJjkD0hSVH-vbINuWxXfQH5zMyZc2ZmZLVUaFn6a2R06ZGlHmBrpvnBvb71fWQHVOSwPbf4GS46TajJspRlVhjZU1HqkhQSWPkHIYdXS5xw-Zas3ueI6FRn7qHFS11_xSRZhIxbFtcDtw7SJb1iXaOg5XIFeQGjzyPRaevYNOGZIJ8qogbpe8CWiy_VzEpTXiQUcvPDkSVrSNZz1UlW1N5eLcqmpdXUvaQ4BmqlhZNUCgxuzFHDqUWNAxrYeUM76AzsnOsdiJbrBp_71lKpn3RRbii-4P3f-IMsRxS-wcDV_bL4PmSdBa2wl7pKnbp8DMgVvJm8ZNskKRkEM_OzyOKQFkgqOYBQ3Nq89Ns0nbIl81vMFN-jKoLMTOr-SOBOJS-Z8f5Y6D1wdcR8dFqvEBdetK-PHwj-z-cH8oHPY54wRJ8Ys7iSQ3Bg3VA9azQbmC9k35kKzYa6PoVtfwbbKVnBixBiGn7Pq0rqJoUtHiCZwAM3jdTPWCVtr_glhVrhecIa3vuksJ_b7TqFs4DPyriSjd5IwoNNQaAmNI-ESfR2p8zimzvN1swdCkvJHPH6-_oX8o1SgcIDAAA=" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let size = $state(50);
	let color = $state('#ff3e00');

	let canvas;

	$effect(() =&gt; {
		const context = canvas.getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);

		// 只要 `color` 或 `size` 发生变化，这段代码就会重新执行
		context.fillStyle = color;
		context.fillRect(0, 0, size, size);
	});
&lt;/script&gt;

&lt;canvas bind:this={canvas} width="100" height="100" /&gt;
</code></pre>
<p>重新运行是批量处理的（即在同一时刻更改 <code>color</code> 和 <code>size</code> 不会导致两次单独的运行），并在所有 DOM 更新完成后发生。</p>
<p>你可以将 <code>$effect</code> 放在任何地方，不仅仅在组件的顶层，只要在组件初始化时调用它（或者在父 effect 处于激活状态时）。它就会与组件（或父 effect）的生命周期绑定，因此当组件卸载（或父 effect 被销毁）时，它会自行销毁。</p>
<p>你可以从 <code>$effect</code> 返回一个函数，该函数将在 effect 重新运行之前立即运行，并在它被销毁之前运行（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE42RQY-bMBCF_8rI2kPopiXpMQtIPfbeW6m0xjyKtWaM7CFphPjvFVB2k2oPe7LmzXzyezOjaqxDVKefo5JrD3VaBLVXrLu5-tb3X-IZTmat0hHv6cazgCWqk8qiCbaXouRSHISMH1gop4coWrA7JE9bp7PO2QjjuY5vA8fDYZ3hUh7QNDCy2yWUFzTOUilpSj9aG-linaMKFGACtKCmSwvGGYGeLQvCWbtnMq3m34grajxHoa1JOUXI93_V_Sfz7Oz7Mafj0ypN-zvHm8dSAmQITP_xaUq2IU1GO1dp80I2Uh_82dao92Rl9R8GvgF0QrbrUFstcFeq0PgAkha0LoICPoeB4w1SJUvsZcj4rvcMlvmvGlGCv6J-DeSgw2vabQnJlm55p7nM0rcTctYei3HZxZSl7XHVqkHEM3k2zpqXfFyj393zU05fpyI6f0HI0hUoPoamC9roKDeo2ivBH1EnCQOmX9NfYw2GHrgCAAA=" target="_blank" rel="noopener nofollow">demo</a>）。</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
	let milliseconds = $state(1000);

	$effect(() =&gt; {
		// 每当 `milliseconds` 变化时，这段代码都会被重新创建
		const interval = setInterval(() =&gt; {
			count += 1;
		}, milliseconds);

		return () =&gt; {
			// 如果提供了回调，它将在
			// a) effect 重新运行之前立即被调用
			// b) 当组件被销毁时被调用
			clearInterval(interval);
		};
	});
&lt;/script&gt;

&lt;h1&gt;{count}&lt;/h1&gt;

&lt;button onclick={() =&gt; (milliseconds *= 2)}&gt;慢一点&lt;/button&gt;
&lt;button onclick={() =&gt; (milliseconds /= 2)}&gt;快一点&lt;/button&gt;
</code></pre>
<h4 id="理解依赖关系-1">理解依赖关系</h4>
<p><code>$effect</code> 会自动获取在其函数体内 <em>同步</em> 读取的任何响应值（<code>$state</code>、<code>$derived</code>、<code>$props</code>），并将它们注册为依赖关系。当这些依赖关系发生变化时，<code>$effect</code> 会安排重新运行。</p>
<p>在 <code>await</code> 之后或在 <code>setTimeout</code> 内部等情况下读取的值将不会被追踪。在这里，当 <code>color</code> 变化时，canvas 会重新绘制，但当 <code>size</code> 变化时将不会变化（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE31T246bMBD9lZF3pWSlBEirfaEQqdo_2PatVIpjBrDkGGQPJGnEv1e2IZfVal-wfHzmzJyZ4cIqqdCy9M-F0blDlnqArZjmB3f72XWRHVCRw_bc4me4aDWhJstSlllhZEfbQhekkMDKfwg5PFvihMvX5OXH_CJa1Zrb0-Kpqr5jkiwC48rieuDWQbqgZ6wqFLRcvkC-hYvnkWi1dWqa8ESQTxFRjfQWsOXiWzmr0sSLhEJu3p1YsoJkNUcdZUnN9dagrBu6FVRQHAM10sJRKgUG16bXcGxQ44AGdt7SDkTDdY02iqLHnJVU6hedlWuIp94JW6Tf8oBt_8GdTxlF0b4n0C35ZLBzXb3mmYn3ae6cOW74zj0YVzDNYXRHFt9mprNgHfZSl6mzml8CMoLvTV6wTZIUDEJv5us2iwMtiJRyAKG4tXnhl8O0yhbML0Wm-B7VNlSSSd31BG7z8oIZZ6dgIffAVY_5xdU9Qrz1Bnx8fCfwtZ7v8Qc9j3nB8PqgmMWlHIID6-bkVaPZwDySfWtKNGtquxQ23Qlsq2QJT0KIqb8dL0up6xQ2eIBkAg_c1FI_YqW0neLnFCqFpwmreedJYT7XX8FVOBfwWRhXstZrSXiwKQjUhOZeMIleb5JZfHWn2Yq5pWEpmR7Hv-N_wEqT8hEEAAA=" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-ts">// @filename: index.ts
declare let canvas: {
	width: number;
	height: number;
	getContext(type: '2d', options?: CanvasRenderingContext2DSettings): CanvasRenderingContext2D;
};
declare let color: string;
declare let size: number;

// ---cut---
$effect(() =&gt; {
	const context = canvas.getContext('2d');
	context.clearRect(0, 0, canvas.width, canvas.height);

	// 每当 `color` 发生变化时，这段代码都会重新运行...
	context.fillStyle = color;

	setTimeout(() =&gt; {
		// ...但当 `size` 发生变化时却不会
		context.fillRect(0, 0, size, size);
	}, 0);
});
</code></pre>
<p>effect 仅在它读取的对象发生变化时才重新运行，而不是在对象内部的属性发生变化时。（如果你想在开发时观察一个对象内部的变化，可以使用 <a href="https://svelte.yayujs.com/docs/svelte/$inspect" target="_blank" rel="noopener nofollow"><code>$inspect</code></a>。）</p>
<pre><code class="language-svelte">&lt;script&gt;
	let state = $state({ value: 0 });
	let derived = $derived({ value: state.value * 2 });

	// 这只会运行一次，因为 `state` 从未被重新分配（仅被修改）
	$effect(() =&gt; {
		state;
	});

	// 这将在每当 `state.value` 变化时运行...
	$effect(() =&gt; {
		state.value;
	});

	// ...这一点也是如此，因为 `derived` 每次都是一个新对象
	$effect(() =&gt; {
		derived;
	});
&lt;/script&gt;

&lt;button onclick={() =&gt; (state.value += 1)}&gt;
	{state.value}
&lt;/button&gt;

&lt;p&gt;{state.value} 的两倍是 {derived.value}&lt;/p&gt;
</code></pre>
<p>effect 仅依赖于它上次运行时读取的值。如果 <code>a</code> 为真，则对 <code>b</code> 的更改不会 <a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE3WQ0WrDMAxFf0U1hTow1vcsMfQ7lj3YjlxEXTvEymC4_vfFC6Ewtidxde8RkrJw5DGJ9j2LoO8oWnGZJvEi-GuqIn2iZ1x1istsa6dLdqaJ1RAG9sigoYdjYs0onfYJm7fdMX85q3dE59CylA30CnJtDWxjSNHjq49XeZqXEChcT9usLUAOpIbHA0yzM78oColGhDVofLS3neZSS6mqOz-XD51ZmGOAGKwne-vztk-956CL0kAJsi7decupf4l658EUZX4I8yTWt93jSI5wFC3PC5aP8g0Aje5DcQEAAA==" target="_blank" rel="noopener nofollow">导致该 effect 重新运行</a>:</p>
<pre><code class="language-ts">let a = false;
let b = false;
// ---cut---
$effect(() =&gt; {
	console.log('运行中');

	if (a || b) {
		console.log('在 if 块内');
	}
});
</code></pre>
<h3 id="effectpre"><code>$effect.pre</code></h3>
<p>在极少数情况下，你可能需要在 DOM 更新 <em>之前</em> 运行代码。为此，我们可以使用 <code>$effect.pre</code> 符文：</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { tick } from 'svelte';

	let div = $state();
	let messages = $state([]);

	// ...

	$effect.pre(() =&gt; {
		if (!div) return; // 尚未挂载

		// 引用 `messages` 数组长度，以便当它改变时，此代码重新运行
		messages.length;

		// 当新消息被添加时自动滚动
		if (div.offsetHeight + div.scrollTop &gt; div.scrollHeight - 20) {
			tick().then(() =&gt; {
				div.scrollTo(0, div.scrollHeight);
			});
		}
	});
&lt;/script&gt;

&lt;div bind:this={div}&gt;
	{#each messages as message}
		&lt;p&gt;{message}&lt;/p&gt;
	{/each}
&lt;/div&gt;
</code></pre>
<p>除了时机不同，<code>$effect.pre</code> 的工作方式与 <code>$effect</code> 完全相同。</p>
<h3 id="effecttracking"><code>$effect.tracking</code></h3>
<p><code>$effect.tracking</code> 符文是一个高级特性，用于告知你代码是否在跟踪上下文中运行，例如 effect 或模板内部 (<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACn3PwYrCMBDG8VeZDYIt2PYeY8Dn2HrIhqkU08nQjItS-u6buAt7UDzmz8ePyaKGMWBS-nNRcmdU-hHUTpGbyuvI3KZvDFLal0v4qvtIgiSZUSb5eWSxPfWSc4oB2xDP1XYk8HHiSHkICeXKeruDDQ4Demlldv4y0rmq6z10HQwuJMxGVv4mVVXDwcJS0jP9u3knynwtoKz1vifT_Z9Jhm0WBCcOTlDD8kyspmML5qNpHg40jc3fFryJ0iWsp_UHgz3180oBAAA=" target="_blank" rel="noopener nofollow">demo</a>)：</p>
<pre><code class="language-svelte">&lt;script&gt;
	console.log('在组件设置中:', $effect.tracking()); // false

	$effect(() =&gt; {
		console.log('在效果中:', $effect.tracking()); // true
	});
&lt;/script&gt;

&lt;p&gt;在模板中: {$effect.tracking()}&lt;/p&gt; &lt;!-- true --&gt;
</code></pre>
<p>这允许你（例如）添加诸如订阅之类的内容而不会导致内存泄漏，方法是将它们放在子 effects 中。以下是一个 <code>readable</code> 函数，只要它在跟踪上下文中就会监听回调函数的变化：</p>
<pre><code class="language-ts">import { tick } from 'svelte';

export default function readable&lt;T&gt;(
	initial_value: T,
	start: (callback: (update: (v: T) =&gt; T) =&gt; T) =&gt; () =&gt; void
) {
	let value = $state(initial_value);

	let subscribers = 0;
	let stop: null | (() =&gt; void) = null;

	return {
		get value() {
			// 如果在跟踪上下文中 ...
			if ($effect.tracking()) {
				$effect(() =&gt; {
					// ...且订阅者还没有
					if (subscribers === 0) {
						// ...调用函数并监听变化以更新状态
						stop = start((fn) =&gt; (value = fn(value)));
					}

					subscribers++;

					// 返回的回调在监听器取消监听时调用
					return () =&gt; {
						tick().then(() =&gt; {
							subscribers--;
							// 如果是最后一个订阅者...
							if (subscribers === 0) {
								// ...停止监听变化
								stop?.();
								stop = null;
							}
						});
					};
				});
			}

			return value;
		}
	};
}
</code></pre>
<h3 id="effectroot"><code>$effect.root</code></h3>
<p><code>$effect.root</code> 符文是一个高级特性，它创建了一个不会自动清理的非跟踪作用域。这对于需要手动控制的嵌套 effects 很有用。这个符文还允许在组件初始化阶段之外创建 effects。</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);

	const cleanup = $effect.root(() =&gt; {
		$effect(() =&gt; {
			console.log(count);
		});

		return () =&gt; {
			console.log('effect root cleanup');
		};
	});
&lt;/script&gt;
</code></pre>
<h3 id="什么时候不应该使用-effect">什么时候不应该使用 <code>$effect</code></h3>
<p>总体而言，<code>$effect</code> 最好被视为一种逃生舱口——适用于分析和直接 DOM 操作等场景——而不是一个应该频繁使用的工具。特别是要避免使用它来同步状态。千万不要这样做...</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
	let doubled = $state();

	// 不要这样做！
	$effect(() =&gt; {
		doubled = count * 2;
	});
&lt;/script&gt;
</code></pre>
<p>...请这样做：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
	let doubled = $derived(count * 2);
&lt;/script&gt;
</code></pre>
<blockquote>
<p>[!NOTE] 对于比像 <code>count * 2</code> 这样的简单表达式更复杂的内容，你也可以使用 <code>$derived.by</code>。</p>
</blockquote>
<p>你可能会想用 effects 以复杂的方式将一个值链接到另一个值。以下示例展示了两个输入框："已花费金额"和"剩余金额"，它们彼此关联。如果你更新其中一个，另一个应该相应更新。不要为此使用 effects（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACpVRy26DMBD8FcvKgUhtoIdeHBwp31F6MGSJkBbHwksEQvx77aWQqooq9bgzOzP7mGTdIHipPiZJowOpGJAv0po2VmfnDv4OSBErjYdneHWzBJaCjcx91TWOToUtCIEE3cig0OIty44r5l1oDtjOkyFIsv3GINQ_CNYyGegd1DVUlCR7oU9iilDUcP8S8roYs9n8p2wdYNVFm4csTx872BxNCcjr5I11fdgonEkXsjP2CoUUZWMv6m6wBz2x7yxaM-iJvWeRsvSbSVeUy5i0uf8vKA78NIeJLSZWv1I8jQjLdyK4XuTSeIdmVKJGGI4LdjVOiezwDu1yG74My8PLCQaSiroe5s_5C2PHrkVGAgAA" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let total = 100;
	let spent = $state(0);
	let left = $state(total);

	$effect(() =&gt; {
		left = total - spent;
	});

	$effect(() =&gt; {
		spent = total - left;
	});
&lt;/script&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={spent} max={total} /&gt;
	{spent}/{total} 已花费
&lt;/label&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={left} max={total} /&gt;
	{left}/{total} 剩余
&lt;/label&gt;
</code></pre>
<p>相反，尽可能使用回调（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACo1SMW6EMBD8imWluFMSIEUaDiKlvy5lSOHjlhOSMRZeTiDkv8deMEEJRcqdmZ1ZjzzxqpZgePo5cRw18JQA_sSVaPz0rnVk7iDRYxdhYA8vW4Wg0NnwzJRdrfGtUAVKQIYtCsly9pIkp4AZ7cQOezAoEA7JcWUkVBuCdol0dNWrEutWsV5fHfnhPQ5wZJMnCwyejxCh6G6A0V3IHk4zu_jOxzzPBxBld83PTr7xXrb3rUNw8PbiYJ3FP22oTIoLSComq5XuXTeu8LzgnVA3KDgj13wiQ8taRaJ82rzXskYM-URRlsXktejjgNLoo9e4fyf70_8EnwncySX1GuunX6kGRwnzR_BgaPNaGy3FmLJKwrCUeBM6ZUn0Cs2mOlp3vwthQJ5i14P9st9vZqQlsQIAAA==" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let total = 100;
	let spent = $state(0);
	let left = $state(total);

	function updateSpent(e) {
		spent = +e.target.value;
		left = total - spent;
	}

	function updateLeft(e) {
		left = +e.target.value;
		spent = total - left;
	}
&lt;/script&gt;

&lt;label&gt;
	&lt;input type="range" value={spent} oninput={updateSpent} max={total} /&gt;
	{spent}/{total} 已花费
&lt;/label&gt;

&lt;label&gt;
	&lt;input type="range" value={left} oninput={updateLeft} max={total} /&gt;
	{left}/{total} 剩余
&lt;/label&gt;
</code></pre>
<p>如果您出于任何原因需要使用绑定（例如当您想要某种"可写的 <code>$derived</code>"时），请考虑使用 getter 和 setter 来同步状态(<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACpWRwW6DMBBEf8WyekikFOihFwcq9TvqHkyyQUjGsfCCQMj_XnvBNKpy6Qn2DTOD1wu_tRocF18Lx9kCFwT4iRvVxenT2syNoDGyWjl4xi93g2AwxPDSXfrW4oc0EjUgwzsqzSr2VhTnxJwNHwf24lAhHIpjVDZNwy1KS5wlNoGMSg9wOCYksQccerMlv65p51X0p_Xpdt_4YEy9yTkmV3z4MJT579-bUqsaNB2kbI0dwlnCgirJe2UakJzVrbkKaqkWivasU1O1ULxnOVk3JU-Uxti0p_-vKO4no_enbQ_yXhnZn0aHs4b1jiJMK7q2zmo1C3bTMG3LaZQVrMjeoSPgaUtkDxePMCEX2Ie6b_8D4WyJJEwCAAA=" target="_blank" rel="noopener nofollow">demo</a>)：</p>
<pre><code class="language-svelte">&lt;script&gt;
	let total = 100;
	let spent = $state(0);

	let left = {
		get value() {
			return total - spent;
		},
		set value(v) {
			spent = total - v;
		}
	};
&lt;/script&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={spent} max={total} /&gt;
	{spent}/{total} spent
&lt;/label&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={left.value} max={total} /&gt;
	{left.value}/{total} left
&lt;/label&gt;
</code></pre>
<p>如果您必须在 effect 中更新 <code>$state</code> 并且因为你读取和写入的是同一个 <code>$state</code> 而陷入无限循环，请使用 <a href="https://svelte.yayujs.com/docs/svelte/svelte#untrack" target="_blank" rel="noopener nofollow">untrack</a>。</p>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>本篇已收录在掘金专栏 <a href="https://juejin.cn/column/7459299646696374284" target="_blank" rel="noopener nofollow">《Svelte 中文文档》</a>，该系列预计 40 篇。</p>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>通过文字建立交流本身就是一种缘分，欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“低调务实优秀中国好青年”</a>前端社群，分享技术，带你成长。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02829721463541667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 13:40">2025-01-22 13:39</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18685651" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18685651);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18685651', targetLink: 'https://www.cnblogs.com/yayujs/p/18685651', title: 'Svelte 最新中文文档翻译（3）—— 符文（Runes）上' })">举报</a>
</div>
        