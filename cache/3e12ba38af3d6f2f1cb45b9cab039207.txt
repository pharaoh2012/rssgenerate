
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18837899" title="发布于 2025-04-21 09:30">
    <span role="heading" aria-level="2">markdown文本编辑器--核心功能（解析和渲染）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>🙌<strong>开源项目地址</strong></p>
<blockquote>
<p>🌍 <a href="https://github.com/yuantingyue/YtyMark-java" target="_blank" rel="noopener nofollow">GitHub 开源地址（YtyMark-java）</a></p>
</blockquote>
<p>欢迎提交 PR、Issue、Star ⭐️！</p>
<h2 id="1-简述">1. 简述</h2>
<p>YtyMark-java项目分为两大模块：</p>
<ul>
<li>
<p>UI界面（ytyedit-mark）</p>
</li>
<li>
<p>markdown文本解析和渲染（ytymark）</p>
</li>
</ul>
<p>本文主要内容为<strong>核心模块--markdown文本解析和渲染</strong>。</p>
<p>关于markdown文本解析器怎么设计，渲染器怎么实现，怎么解耦解析和渲染。在这整个流程中，如果通过设计模式实现高内聚低耦合，可重用，易于阅读，易于扩展，易于维护等。</p>
<p>该模块的主要目录结构：</p>
<pre><code>YtyMark-java
├── ytymark/
│ ├── src/
│ │ ├── main/
│ │ │ ├── java/
│ │ │ │ ├── annotation/ # 自定义注解
│ │ │ │ ├── enums/ # 枚举值
│ │ │ │ ├── node/ # 树节点（块级和行级节点）
│ │ │ │ ├── parser/ # 解析器（块级和行级元素）
│ │ │ │ ├── renderer/ # 渲染器（块级和行级元素）
│ │ │ └── resources/
│ ├── README.md
│ └──pom.xml
</code></pre>
<h2 id="2解析器">2.解析器</h2>
<p><strong>目标</strong>：将 Markdown 文本解析为节点树。</p>
<p><strong>使用到的设计模式</strong>：</p>
<ul>
<li>
<p><strong>构建者模式</strong>：创建复杂<strong>解析器</strong>和<strong>渲染器</strong>。</p>
</li>
<li>
<p><strong>状态模式</strong>：对markdown文本不同语法做一些前置处理，裁剪成块级元素。</p>
</li>
<li>
<p><strong>责任链模式</strong>：按优先级匹配不同，处理复杂的<strong>块级元素解析</strong>及嵌套解析。</p>
</li>
<li>
<p><strong>策略模式</strong>：动态选择解析器完成<strong>行内元素的解析</strong>。</p>
</li>
<li>
<p><strong>组合模式</strong>：表示 Markdown 语法结构（如段落、标题、列表）之间的树形结构。</p>
</li>
<li>
<p><strong>迭代器模式</strong>：通过迭代器结合递归来<strong>遍历节点树</strong>，遍历块级元素进行行内元素解析。</p>
</li>
</ul>
<p>根据使用顺序逐一讲述。</p>
<h3 id="21-构建者模式">2.1. 构建者模式</h3>
<p>通过构建者模式来创建复杂的<strong>解析器</strong>和<strong>渲染器</strong>，包括<strong>自定义解析器</strong>的加入。</p>
<p>最简单的解析器（默认支持的语法解析器）和HTML渲染器</p>
<pre><code class="language-java">// 构建解析器
Parser parser = ParserBuilder.builder().build();
// 构建渲染器
Renderer renderer = RendererBuilder.builder().build(HtmlRenderer.class);
</code></pre>
<p>加入自定义块级元素解析器或者行级元素的解析器：</p>
<pre><code class="language-java">Parser parser = ParserBuilder.builder()
                .addDelimiter("_")
                .addBlockParser(new ParagraphParserHandler())
                .addInlineParser("_", new ItalicParser())
                .build();
</code></pre>
<p>除此之外，程序会在启动时，扫描<code>org.ytymark.parser</code>包中带有注解<code>BlockParserHandlerType</code>的类，所以还可以通过注解加入新的块级元素解析器。</p>
<p>比如表格解析器：只需要在块解析器类上面加入这个注解和对应的枚举类即可</p>
<pre><code class="language-java">// 枚举类
public enum BlockParserHandlerEnum {
    TABLE("TABLE",6),
// 通过注解加入块级元素解析器
@BlockParserHandlerType(type = BlockParserHandlerEnum.TABLE)
public class TableParserHandler extends AbstractBlockParser implements ParserHandler {
</code></pre>
<h3 id="22-状态模式">2.2. 状态模式</h3>
<p>对markdown文本不同语法做一些前置处理，裁剪成块级元素。</p>
<p>在正式进行块级元素解析前，对原始markdown文本进行分割，<strong>分割成一块</strong>一块的。</p>
<p>由于markdown语法很多，不进行一些设计，那将是一坨难以阅读理解、难以维护和扩展的代码。</p>
<p>通过状态模式实现类似状态机的机制，当状态（语法）匹配时，自动流转到专门处理这个语法的程序，处理完之后分割成一个“块”（这个块就是一个块元素），再回到默认状态，然后继续处理后续的文本。具体代码位于：<code>org.ytymark.parser.block.state</code>包。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250421082440052-1877388630.jpg" alt="image" loading="lazy"></p>
<h3 id="23-责任链模式">2.3. 责任链模式</h3>
<p>按优先级匹配不同，处理复杂的<strong>块级元素解析</strong>及嵌套解析。</p>
<p>在正式进行块级元素解析前，状态模式将元素文本处理成<strong>块数据集合</strong>，这就像流水线上简单的打了包，但并不区分包裹里面是什么内容。接着将这些包裹丢上流水线（责任链）上，责任链根据程序初始化时定好的顺序，逐一检测包裹里的内容是什么，匹配得上的就直接丢给机器处理（解析），最终给包裹打上标签（包装成节点对象）。对应包裹里还有包裹的，便继续丢回流水线上进行打标签。</p>
<p>整个处理流程，如图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250421082455560-1105412622.jpg" alt="image" loading="lazy"></p>
<p>块解析的代码</p>
<pre><code class="language-java">    public void parser(String text, Node node) {
        List&lt;String&gt; blocks = this.splitBlock(text);

        // 逐块处理文本
        for (String block : blocks) {
            blockParserChain.parser(block, node);
        }

    }
</code></pre>
<h3 id="24-策略模式">2.4. 策略模式</h3>
<p>动态选择解析器完成<strong>行级元素的解析</strong>。</p>
<p>块级元素解析完成后，会形成块节点的节点树，再进行<strong>行级元素解析</strong>。</p>
<pre><code class="language-java">public Node parse(String markdownText) {
        Node root = new DocumentNode();
        // 统一换行符，替换所有 \r\n 或 \r 为 \n
        String normalizedText = markdownText.replaceAll("\r\n|\r", "\n");

        // 块级元素解析
        blockParserContext.parser(normalizedText, root);

        // 行级元素解析
        this.parseInlines(root);

        return root;
    }
</code></pre>
<p>行级元素并不是所有块元素都需要进行处理，目前<strong>只对标题和段落块节点进行解析</strong>，因为其它块级元素的内容最终会通过段落节点进行保存。</p>
<p>根据语法特点，动态选择解析器完成<strong>行级元素的解析</strong>，关键代码如下：</p>
<pre><code class="language-java">// 检查字符对或单个字符，选择对应的解析器
String possibleDelimiter = this.getPossibleDelimiter(line, i);
InlineParser inlineParser = inlineParserMap.get(possibleDelimiter);

if (inlineParser != null) {
    // 找到合适地解析器，尝试解析
    InlineNode inlineNode = inlineParser.parser(sourceLine, this);
    if(inlineNode!=null){
        node.addChildNode(inlineNode);
    }
}
</code></pre>
<h3 id="25-组合模式和迭代器模式">2.5. 组合模式和迭代器模式</h3>
<p>表示 Markdown 语法结构（如段落、标题、列表）之间的树形结构，每个语法对应一个<code>Node</code>节点，在块级元素和行级元素的解析过程，最终组合成节点树。节点和迭代器源码位于<code>org.ytymark.node</code>包。</p>
<p>通过迭代器结合递归来<strong>遍历节点树</strong>，在解析阶段，用于遍历块级元素进行行内元素解析。</p>
<p>使用迭代器完成兄弟节点的遍历（广度遍历），再结合递归完成子节点遍历（深度遍历），具体源码如下：</p>
<pre><code class="language-java">/**
 * 行级元素解析
 * @param parent 父节点
 */
@Override
public void parseInlines(Node parent) {
    Iterator&lt;Node&gt; iterator = parent.createIterator();
    while (iterator.hasNext()) {
        // 获取下一个兄弟节点
        Node node = iterator.next();
        // 解析子节点行
        if(node instanceof ParagraphNode){
            inlineParserContext.parser(((ParagraphNode) node).getText(),node);
        }
        if(node instanceof HeadingNode) {
            inlineParserContext.parser(((HeadingNode) node).getText(), node);
        }

        if(node.getFirstChild()!=null)
            parseInlines(node);
    }
}
</code></pre>
<h2 id="3-渲染器">3. 渲染器</h2>
<p><strong>目标</strong>：将 AST 语法树渲染为 HTML 文本预览。</p>
<p><strong>使用到的设计模式</strong>：</p>
<ul>
<li>
<p><strong>中介者模式思想</strong>：加入AST节点树<strong>解耦</strong>解析器和渲染器，使其<strong>灵活地渲染</strong>成不同的文档。</p>
</li>
<li>
<p><strong>迭代器模式</strong>：通过迭代器结合递归来<strong>遍历节点树</strong>，比如遍历节点树完成渲染操作。</p>
</li>
<li>
<p><strong>访问者模式</strong>：负责<strong>分离节点数据与渲染操作</strong>，提高渲染的扩展性。</p>
</li>
</ul>
<h3 id="31-中介者模式思想">3.1. 中介者模式思想</h3>
<p>在解析和渲染中间加入AST节点树，<strong>解耦</strong>解析器和渲染器，使得一次解析可以<strong>灵活地渲染</strong>成不同的文档。为了将低耦合，常常会在两者间多加一层。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250421082526876-1128313138.jpg" alt="image" loading="lazy"></p>
<h3 id="32-迭代器模式">3.2. 迭代器模式</h3>
<p>通过迭代器结合递归来<strong>遍历节点树</strong>，在渲染阶段，遍历节点树完成渲染操作。</p>
<pre><code class="language-java">/**
 * 循环渲染兄弟节点
 *    在实现这个抽象类的渲染器中，如果存在子节点行为就需要调用这个方法实现递归遍历子节点
 */
protected void renderChildren(Node parent) {
    Iterator&lt;Node&gt; iterator = parent.createIterator();
    while (iterator.hasNext()) {
        // 获取下一个兄弟节点
        Node next = iterator.next();
        // 渲染节点
        next.render(this);
    }
}
</code></pre>
<h3 id="33-访问者模式">3.3. 访问者模式</h3>
<p>负责<strong>分离Node节点数据与渲染操作行为</strong>，提高渲染的扩展性。在每个节点类中，实现渲染逻辑时只需要编写以下代码：</p>
<pre><code class="language-java">@Override
public void render(Renderer renderer) {
    renderer.render(this);
}
</code></pre>
<p>将渲染逻辑抽离出来，由渲染器接口实现类来<strong>实现具体的渲染逻辑</strong>，不同的实现类对应不同的渲染行为，目前只实现了HTML的渲染。<br>
在构建器中选择渲染器类型：</p>
<pre><code class="language-java">Renderer renderer = RendererBuilder.builder().build(HtmlRenderer.class);
</code></pre>
<p><strong>解决渲染的扩展性（多样性）问题</strong></p>
<p>如果需要将markdown文本渲染成<strong>普通文本</strong>，则只需要继承<code>AbstractRenderer</code> 抽象类，实现<code>Renderer</code>接口中所有方法即可。并且实现渲染逻辑非常简单，只需要关注当前节点要做的事情即可。</p>
<p>比如，表格最外层的渲染源码</p>
<pre><code class="language-java">@Override
public void render(TableNode tableNode) {
    sbHTML.append("&lt;table&gt;\n");
    renderChildren(tableNode);
    sbHTML.append("&lt;/table&gt;\n");
}
</code></pre>
<p>而兄弟节点（广度遍历）和嵌套子节点（深度遍历），只需要调用抽象类<code>AbstractRenderer</code>的&nbsp;<code>renderChildren(Node parent)</code>方法即可完成渲染，使得渲染逻辑只需要关注当前节点的行为即可。比如上面的表格渲染代码<code>renderChildren(tableNode);</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250421082536804-583275079.jpg" alt="image" loading="lazy"></p>
<h2 id="4-项目亮点">🚀4. 项目亮点</h2>
<ul>
<li>
<p>💡 <strong>高度模块化</strong>，任何 Markdown 语法都能独立添加/修改。</p>
</li>
<li>
<p>🧠 <strong>设计模式实战</strong>，适合做设计模式学习的项目。</p>
</li>
<li>
<p>🖥️ <strong>可按需获取</strong>，用户界面和文本解析渲染分为两个模块</p>
<ul>
<li>
<p>只使用用户界面源码，然后轻松切换成熟的解析器依赖，开发一个完整的markdown文本编辑器；</p>
</li>
<li>
<p>仅学习文本解析渲染模块源码，不用关注用户界面源码。</p>
</li>
</ul>
</li>
<li>
<p>🧪 <strong>解析性能毫秒级</strong>，确保解析效率。</p>
</li>
<li>
<p>🎯 <strong>轻松上手</strong>，使用JDK8 自带JavaFX模块，无需做额外处理。</p>
</li>
<li>
<p>📦 <strong>开源项目，文档完善</strong>，方便学习和贡献。</p>
</li>
</ul>
<h2 id="️5-总结">✏️5. 总结</h2>
<p>markdown 文本解析和渲染将多种设计模式融入到实际应用中，是一次系统性的 <strong>设计模式实践</strong>或<strong>架构设计实践</strong>。</p>
<p>更多详细内容可以前往笔者微信公众号回复：<strong>设计模式</strong>，来获取，后续有关设计模式的新资料都可以从这个入口获取到。</p>
<ul>
<li>
<p><strong>秘籍1</strong>设计模式手册：《掌握设计模式：23种经典模式实践、选择、价值与思想》</p>
</li>
<li>
<p><strong>秘籍2</strong>练手项目：设计模式实战项目--markdown文本编辑器软件开发（<strong>已开源</strong>）</p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_gif/7Lm51TENjPvf3H8pfO0H2PZIbnf9wlqswianUspot3NicoZ5yGk9MOFGOfEtvtDMVCRm3tmhL5SRYHBP7ofoQw7g/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;tp=webp" alt="图片" loading="lazy"></p>
<p>查看往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>
<p>三连支持！！！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06922060669328704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-21 09:30">2025-04-21 09:30</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18837899);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18837899', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18837899', title: 'markdown文本编辑器--核心功能（解析和渲染）' })">举报</a>
</div>
        