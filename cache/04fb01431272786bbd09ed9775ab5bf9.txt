
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sharpeye/p/18738577" title="发布于 2025-02-26 15:31">
    <span role="heading" aria-level="2">PowerShell开发游戏 · 打蜜蜂</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202502/944545-20250226145922384-1676591952.gif" width="600">&nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202502/944545-20250226145944103-1839006031.gif" width="600"></p>
<hr>
<p id="1740553189325"></p>
<p>可以看到，虽然非常抽象简单，但是基础游戏框架已经搭建，游戏机制完善，就缺美工了，哈哈~~~~</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 16px">【首先】</span></strong></p>
<p>Powershell不是用来开发游戏的，但是没人规定不能开发。因为它可以调取windows下的程序集，比如 .net framework。因此我们可以猜想，只要能开启一个实时刷新的窗口，就可以在窗口内绘制图形和文字。至于实时刷新的窗口如何实现，则需要调取程序集，如下:</p>
<pre class="language-powershell highlighter-hljs"><code>Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Windows.Forms</code></pre>
<p>Drawing 负责绘制任务</p>
<p>WindowsForm负责管理窗口</p>
<p>然后关键的操作是，设计一个定时器，让其不断地触发，不断地让其绘制新的图形。</p>
<pre class="language-powershell highlighter-hljs"><code># 定时器用于控制游戏更新，每秒触发 60 次（约 16.67 毫秒）
$timer = New-Object System.Windows.Forms.Timer
$timer.Interval = 16.67</code></pre>
<p>&nbsp;然后设计定时器触发事件</p>
<pre class="language-powershell highlighter-hljs"><code>$timer.Add_Tick({
  //  ...
})</code></pre>
<p>在定时器触发事件中写上这句：</p>
<pre class="language-powershell highlighter-hljs"><code>$form.Invalidate()</code></pre>
<p>即让每次触发时，让窗体重新paint一次，因此，需要定义窗体的 Paint 事件处理程序</p>
<pre class="language-powershell highlighter-hljs"><code>$form.Add_Paint({
    // ...
})</code></pre>
<p>剩下的就是交互动画设计基础了，三部曲 【初始化 - 更新 - 绘画】</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px"><strong>【程序】</strong></span></p>
<pre class="language-powershell highlighter-hljs"><code># 加载必要的程序集
Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Windows.Forms

# 创建窗体
$form = New-Object System.Windows.Forms.Form
$form.Text = "打蜜蜂小游戏"
$form.Size = New-Object System.Drawing.Size(800, 600)
$form.BackColor = [System.Drawing.Color]::Black
$form.StartPosition = "CenterScreen"
$form.KeyPreview = $true

# 启用双缓冲以减少闪烁
$doubleBufferProperty = $form.GetType().GetProperty("DoubleBuffered", [System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)
$doubleBufferProperty.SetValue($form, $true, $null)

# 定义飞机
$planeWidth = 50
$planeHeight = 30
$planeX = ($form.ClientSize.Width - $planeWidth) / 2
$planeY = $form.ClientSize.Height - $planeHeight - 10

# 定义蜜蜂
$beeSize = 40
$bees = New-Object System.Collections.Generic.List[object]
$beeFallSpeed = 0.5

# 定义子弹
$bulletSize = 5
$bullets = New-Object System.Collections.Generic.List[object]
$bulletSpeed = 10

# 定义计分板，初始分数设为 100
$score = 100
$font = New-Object System.Drawing.Font("Arial", 20)
$brush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::White)

# 定时器用于控制游戏更新，每秒触发 60 次（约 16.67 毫秒，设为 17 毫秒）
$timer = New-Object System.Windows.Forms.Timer
$timer.Interval = 17
$beeSpawnCounter = 0

# 重置游戏的函数
function ResetGame {
    $script:planeX = ($form.ClientSize.Width - $planeWidth) / 2
    $script:bees.Clear()
    $script:bullets.Clear()
    $script:score = 100
    $script:beeSpawnCounter = 0
}

# 定时器的 Tick 事件处理程序
$timer.Add_Tick({
    param($sender, $e)
    try {
        $script:beeSpawnCounter++
        Write-Host "定时器触发，当前计数: $beeSpawnCounter"  # 调试信息，显示定时器触发及计数情况

        # 控制蜜蜂每秒生成 1 只
        if ($beeSpawnCounter % 60 -eq 0) {  # 每秒触发 60 次，每 60 次生成 1 只蜜蜂
            $beeX = Get-Random -Minimum 0 -Maximum ($form.ClientSize.Width - $beeSize)
            $bees.Add(@{
                X = $beeX
                Y = 0
            })
            Write-Host "生成蜜蜂，X: $beeX, Y: 0"  # 调试信息，显示蜜蜂生成信息
        }

        # 更新蜜蜂位置
        for ($i = $bees.Count - 1; $i -ge 0; $i--) {
            $bee = $bees[$i]
            $bee.Y += $beeFallSpeed
            if ($bee.Y -ge $form.ClientSize.Height) {
                $bees.RemoveAt($i)
                # 蜜蜂到达画面底部，扣 10 分
                $script:score = [Math]::Max(0, $score - 10)
            }
        }

        # 更新子弹位置
        for ($i = $bullets.Count - 1; $i -ge 0; $i--) {
            $bullet = $bullets[$i]
            $bullet.Y -= $bulletSpeed
            if ($bullet.Y -lt 0) {
                $bullets.RemoveAt($i)
            }
        }

        # 检查子弹是否击中蜜蜂
        for ($i = $bullets.Count - 1; $i -ge 0; $i--) {
            $bullet = $bullets[$i]
            for ($j = $bees.Count - 1; $j -ge 0; $j--) {
                $bee = $bees[$j]
                if ($bullet.X -lt $bee.X + $beeSize -and $bullet.X + $bulletSize -gt $bee.X -and
                    $bullet.Y -lt $bee.Y + $beeSize -and $bullet.Y + $bulletSize -gt $bee.Y) {
                    $bees.RemoveAt($j)
                    $bullets.RemoveAt($i)
                    break
                }
            }
        }

        # 检查蜜蜂是否碰撞到飞机（不做得分和消失处理）
        foreach ($bee in $bees) {
            if ($bee.Y + $beeSize -ge $planeY -and $bee.X + $beeSize -ge $planeX -and $bee.X -le $planeX + $planeWidth) {
                # 不做任何处理，蜜蜂继续下落
            }
        }

        # 检查分数是否为 0，为 0 则重置游戏
        if ($score -eq 0) {
            ResetGame
        }

        $form.Invalidate()
    }
    catch {
        Write-Host "定时器 Tick 事件处理出错: $_"
        Write-Host $_.ScriptStackTrace
    }
})

# 窗体的 MouseMove 事件处理程序，用于通过鼠标控制飞机位置
$form.Add_MouseMove({
    param($sender, $e)
    $newX = $e.X - $planeWidth / 2
    if ($newX -ge 0 -and $newX + $planeWidth -le $form.ClientSize.Width) {
        $script:planeX = $newX
    }
})

# 窗体的 MouseClick 事件处理程序，用于通过鼠标点击发射子弹
$form.Add_MouseClick({
    param($sender, $e)
    $bullets.Add(@{
        X = $planeX + $planeWidth / 2 - $bulletSize / 2
        Y = $planeY
    })
})

# 窗体的 Paint 事件处理程序，用于绘制游戏元素
$form.Add_Paint({
    param($sender, $e)
    $graphics = $e.Graphics

    # 绘制飞机
    $graphics.FillRectangle([System.Drawing.Brushes]::Blue, $planeX, $planeY, $planeWidth, $planeHeight)

    # 绘制蜜蜂
    foreach ($bee in $bees) {
        $graphics.FillEllipse([System.Drawing.Brushes]::Yellow, $bee.X, $bee.Y, $beeSize, $beeSize)
    }

    # 绘制子弹
    foreach ($bullet in $bullets) {
        $graphics.FillRectangle([System.Drawing.Brushes]::Red, $bullet.X, $bullet.Y, $bulletSize, $bulletSize)
    }

    # 绘制计分板
    $graphics.DrawString("Score: $score", $font, $brush, 10, 10)
})

# 窗体关闭事件处理程序，用于清空数据缓存
$form.Add_FormClosing({
    param($sender, $e)
    ResetGame
    Write-Host "数据缓存已清空"
})

# 启动定时器
$timer.Start()

# 显示窗体
$form.ShowDialog()</code></pre>
<p><strong>PS</strong>:</p>
<p>注意程序健壮性，添加异常捕获，注意数据的冗余，即时清空消除。</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px"><strong>【最后】</strong></span></p>
<p>可以看到，Powershell可以开发游戏，这只是象征性尝试，我们还是关注它擅长的领域。不过，这次尝试让笔者很开心，因为即使不借助任何软件或程序开发框架也能开发应用，想想就很酷 😍！~！··· ···</p>
<p id="1740553167756"></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.033829289519675926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 15:32">2025-02-26 15:31</span>&nbsp;
<a href="https://www.cnblogs.com/sharpeye">SHARP-EYE</a>&nbsp;
阅读(<span id="post_view_count">77</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18738577" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18738577);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18738577', targetLink: 'https://www.cnblogs.com/sharpeye/p/18738577', title: 'PowerShell开发游戏 &amp;#183; 打蜜蜂' })">举报</a>
</div>
        