
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ahappyfool/p/18668496" title="发布于 2025-01-13 13:41">
    <span role="heading" aria-level="2">unordered_map比map慢？</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>先说结论：unordered_map不维护键的顺序，因此不能按顺序访问元素，因此如果你需要遍历表时若选用unordered_map就肯定比map慢</p>
<h3 id="1-数据结构与底层实现"><strong>1. 数据结构与底层实现</strong></h3>
<ul>
<li>
<p><strong><code>unordered_map</code></strong>：基于 <strong>哈希表</strong> 实现。</p>
<ul>
<li>优点：平均情况下插入、查找和删除操作的时间复杂度为 O(1)O(1)O(1)。</li>
<li>缺点：最坏情况下，时间复杂度可能退化为 O(n)O(n)O(n)（当哈希冲突严重时）。</li>
<li>无序存储，不能按键排序。</li>
</ul>
</li>
<li>
<p><strong><code>map</code></strong>：基于 <strong>红黑树（自平衡二叉搜索树）</strong> 实现。</p>
<ul>
<li>优点：插入、查找和删除操作的时间复杂度始终为 O(log⁡n)O(\log n)O(logn)。</li>
<li>缺点：由于需要维护树的平衡，常数因子较大。</li>
<li>按键排序，支持有序遍历。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-插入和查找性能"><strong>2. 插入和查找性能</strong></h3>
<ul>
<li><strong><code>unordered_map</code> 优势</strong>：在大多数情况下，<code>unordered_map</code> 插入和查找的性能优于 <code>map</code>，因为其平均时间复杂度为 O(1)O(1)O(1)。</li>
<li><strong><code>map</code> 劣势</strong>：<code>map</code> 的插入和查找性能稍慢，时间复杂度为 O(log⁡n)O(\log n)O(logn)。</li>
</ul>
<p><strong>例外情况</strong>：</p>
<ol>
<li><strong>哈希冲突严重</strong>：如果 <code>unordered_map</code> 的哈希函数设计不佳或数据分布极端（如大量相同的哈希值），性能可能退化为 O(n)O(n)O(n)。</li>
<li><strong>小规模数据</strong>：对于数据规模较小的情况，<code>map</code> 的性能可能优于 <code>unordered_map</code>，因为红黑树的实现有较少的额外开销。</li>
</ol>
<hr>
<h3 id="3-内存使用"><strong>3. 内存使用</strong></h3>
<ul>
<li><strong><code>unordered_map</code> 缺点</strong>：由于哈希表需要额外的存储空间（如空槽和链表节点），<code>unordered_map</code> 通常比 <code>map</code> 占用更多内存。</li>
<li><strong><code>map</code> 优势</strong>：<code>map</code> 是基于树的实现，占用内存相对较少。</li>
</ul>
<hr>
<h3 id="4-顺序访问"><strong>4. 顺序访问</strong></h3>
<ul>
<li><strong><code>unordered_map</code> 缺点</strong>：<code>unordered_map</code> 不维护键的顺序，因此不能按顺序访问元素。</li>
<li><strong><code>map</code> 优势</strong>：<code>map</code> 自动按键的升序（或指定的比较函数）维护元素顺序，支持有序遍历。</li>
</ul>
<hr>
<h3 id="5-插入删除时对迭代器的影响"><strong>5. 插入、删除时对迭代器的影响</strong></h3>
<ul>
<li><strong><code>unordered_map</code></strong>：当发生哈希表的重哈希（rehash）操作时，会使所有迭代器失效。</li>
<li><strong><code>map</code></strong>：插入和删除元素只会影响相关位置的迭代器，其余迭代器不会失效。</li>
</ul>
<hr>
<h3 id="6-适用场景"><strong>6. 适用场景</strong></h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐使用容器</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速查找/插入操作</td>
<td><code>unordered_map</code></td>
<td>平均时间复杂度 O(1)O(1)O(1)。</td>
</tr>
<tr>
<td>数据需要按键排序</td>
<td><code>map</code></td>
<td>支持有序遍历。</td>
</tr>
<tr>
<td>数据规模较小</td>
<td><code>map</code></td>
<td>红黑树常数因子较小。</td>
</tr>
<tr>
<td>内存有限</td>
<td><code>map</code></td>
<td><code>unordered_map</code> 占用内存较大。</td>
</tr>
<tr>
<td>哈希函数性能不佳或数据分布差</td>
<td><code>map</code></td>
<td><code>unordered_map</code> 性能退化明显。</td>
</tr>
</tbody>
</table>
<h3 id="7举例">7.举例</h3>
<p><a href="https://codeforces.com/contest/2057/problem/B" title="B. Gorilla and the Exam" target="_blank" rel="noopener nofollow">B. Gorilla and the Exam</a><br>
代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    int t;
    scanf("%d", &amp;t);
    while (t--) {
        int n, k;
        scanf("%d %d", &amp;n, &amp;k);

        // 统计频次
        map&lt;int, int&gt; times;
        for (int i = 0; i &lt; n; i++) {
            int c;
            scanf("%d", &amp;c);
            times[c]++;
        }

        // 提取频次并排序
        vector&lt;int&gt; freq;
        for (auto it : times) {
            freq.push_back(it.second);
        }
        sort(freq.begin(), freq.end());

        // 计算移除最小的 k 次后剩余种类
        int m = freq.size();
        for (int i = 0; i &lt; m; i++) {
            if (freq[i] &gt; k) {
                printf("%d\n", m - i);
                goto next_case;
            }
            k -= freq[i];
        }
        printf("1\n");
    next_case:;
    }
    return 0;
}
</code></pre>
<p>若这个代码改为unordered_map将会超时，有兴趣的同学可以去提交试试！</p>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li>如果需要快速插入、删除和查找操作且不关心顺序，<strong>优先选择 <code>unordered_map</code></strong>。</li>
<li>如果需要按键排序或者可能遇到哈希冲突问题，选择 <strong><code>map</code></strong>。</li>
<li>如果内存占用敏感，选择 <strong><code>map</code></strong>。</li>
</ul>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.12814531226851852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 15:13">2025-01-13 13:41</span>&nbsp;
<a href="https://www.cnblogs.com/ahappyfool">fool_king</a>&nbsp;
阅读(<span id="post_view_count">19</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18668496" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18668496);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18668496', targetLink: 'https://www.cnblogs.com/ahappyfool/p/18668496', title: 'unordered_map比map慢？' })">举报</a>
</div>
	