
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/YangJieCheng/p/18768844" title="发布于 2025-03-12 22:49">
    <span role="heading" aria-level="2">Laravel11 从0开发 Swoole-Reverb 扩展包（四） - 触发一个广播事件到reverb服务之后是如何转发给前端订阅的呢（下）？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前情提要">前情提要</h1>
<p>上一篇我们讲到了reverb服务的通信上下文和路由处理，路由实现了pusher关联的几种请求。那么这一篇我们主要来讲混响服务Server</p>
<h1 id="混响-server">混响 Server</h1>
<p>负责基于 ReactPHP 的 SocketServer 和事件循环构建一个 HTTP 服务器（实现了一个轻量级、异步的 HTTP 服务器。通过注册事件、请求解析、异常捕获等机制，保证了请求的正确处理和异常情况下的优雅响应）。它主要实现了以下功能： 连接管理：通过监听新连接（__invoke 方法）来处理数据事件，并将其传递给请求处理逻辑。 请求解析与分发：将原始数据转换为 PSR-7 Request 对象，并交由路由器分发。 异常处理与错误响应：捕获请求调度过程中的异常，返回对应 HTTP 状态码和消息。 垃圾回收优化：通过定时器调用垃圾回收，降低内存碎片。 TLS 检测：判断服务器是否支持加密连接。</p>
<h1 id="server启动">server启动</h1>
<p>我们走到 <code>vendor/laravel/reverb/src/Servers/Reverb/Http/Server.php</code>文件，代码不多，我先贴出来</p>
<pre><code class="language-php">&lt;?php

namespace Laravel\Reverb\Servers\Reverb\Http;

use Illuminate\Support\Str;
use Laravel\Reverb\Loggers\Log;
use Laravel\Reverb\Servers\Reverb\Concerns\ClosesConnections;
use OverflowException;
use Psr\Http\Message\RequestInterface;
use React\EventLoop\Loop;
use React\EventLoop\LoopInterface;
use React\Socket\ConnectionInterface;
use React\Socket\ServerInterface;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Throwable;

class Server
{
    use ClosesConnections;

    /**
     * Create a new Http server instance.
     */
    public function __construct(protected ServerInterface $socket, protected Router $router, protected int $maxRequestSize, protected ?LoopInterface $loop = null)
    {
        gc_disable();

        $this-&gt;loop = $loop ?: Loop::get();

        $this-&gt;loop-&gt;addPeriodicTimer(30, fn () =&gt; gc_collect_cycles());

        $socket-&gt;on('connection', $this);
    }

    /**
     * Start the Http server
     */
    public function start(): void
    {
        $this-&gt;loop-&gt;run();
    }

    /**
     * Handle an incoming request.
     */
    protected function handleRequest(string $message, Connection $connection): void
    {
        if ($connection-&gt;isConnected()) {
            return;
        }

        if (($request = $this-&gt;createRequest($message, $connection)) === null) {
            return;
        }

        $connection-&gt;connect();

        try {
            $this-&gt;router-&gt;dispatch($request, $connection);
        } catch (HttpException $e) {
            $this-&gt;close($connection, $e-&gt;getStatusCode(), $e-&gt;getMessage());
        } catch (Throwable $e) {
            Log::error($e-&gt;getMessage());
            $this-&gt;close($connection, 500, 'Internal server error.');
        }
    }

    /**
     * Create a Psr7 request from the incoming message.
     */
    protected function createRequest(string $message, Connection $connection): ?RequestInterface
    {
        try {
            $request = Request::from($message, $connection, $this-&gt;maxRequestSize);
        } catch (OverflowException $e) {
            $this-&gt;close($connection, 413, 'Payload too large.');
        } catch (Throwable $e) {
            $this-&gt;close($connection, 400, 'Bad request.');
        }

        return $request ?? null;
    }

    /**
     * Stop the Http server
     */
    public function stop(): void
    {
        $this-&gt;loop-&gt;stop();

        $this-&gt;socket-&gt;close();
    }

    /**
     * Invoke the server with a new connection instance.
     */
    public function __invoke(ConnectionInterface $connection): void
    {
        $connection = new Connection($connection);

        $connection-&gt;on('data', function ($data) use ($connection) {
            $this-&gt;handleRequest($data, $connection);
        });
    }

    /**
     * Determine whether the server has TLS support.
     */
    public function isSecure(): bool
    {
        return Str::startsWith($this-&gt;socket-&gt;getAddress(), 'tls://');
    }
}

</code></pre>
<p>首先我们关注start方法，这个方法就是外层工厂调用服务启动的方法：启动服务</p>
<pre><code class="language-php">    public function start(): void
    {
        $this-&gt;loop-&gt;run();
    }
</code></pre>
<p>start() 方法简单地启动事件循环。所有注册到事件循环的定时器、IO 事件和连接处理都将在 run() 方法调用后开始执行。 这是整个 HTTP 服务器的入口，调用后服务器进入阻塞状态等待事件发生。<br>
在走到我们的构造函数：</p>
<pre><code class="language-php">  public function __construct(protected ServerInterface $socket, protected Router $router, protected int $maxRequestSize, protected ?LoopInterface $loop = null)
    {
	  // 调用 gc_disable() 禁用 PHP 的自动垃圾回收
        gc_disable();
        $this-&gt;loop = $loop ?: Loop::get();
		//然后使用事件循环的定时器每 30 秒手动触发一次 gc_collect_cycles()，以便更好地控制内存管理，防止自动垃圾回收带来的性能波动
        $this-&gt;loop-&gt;addPeriodicTimer(30, fn () =&gt; gc_collect_cycles());
        $socket-&gt;on('connection', $this);
    }
</code></pre>
<p>大家在这里可以停下来🤔️下，我们会发现这里有两点是值得我们学习的，接下来我就和大家一起来学习以下两点：</p>
<h2 id="垃圾回收机制">垃圾回收机制</h2>
<p>由于PHP 的垃圾回收不会立即执行，而是满足条件后触发，因此，php提供了手动操作gc的方法，那么通过reverb的案例，我们也有机会用到自己的项目代码中。</p>
<p>下面是AI的总结：</p>
<h3 id="1-php-7-及以后的垃圾回收机制"><strong>1. PHP 7 及以后的垃圾回收机制</strong></h3>
<p>PHP 7 继续使用 <strong>引用计数（Reference Counting）</strong> 作为主要的内存管理机制，并配合 <strong>循环引用检测（Cycle Detection）</strong> 进行垃圾回收。</p>
<h4 id="11-主要组成部分"><strong>1.1 主要组成部分</strong></h4>
<ol>
<li>
<p><strong>引用计数（Reference Counting, RC）</strong></p>
<ul>
<li>PHP 的变量是基于引用计数进行管理的，每个变量都有一个 <strong>引用计数器（refcount）</strong>。</li>
<li>当变量被赋值或传递时，引用计数增加。</li>
<li>当变量的作用域结束或 unset() 释放变量时，引用计数减少。</li>
<li>当引用计数归零时，变量占用的内存被立即释放。</li>
</ul>
</li>
<li>
<p><strong>循环引用检测（Cycle Collection）</strong></p>
<ul>
<li>PHP 7 及以后版本采用 <strong>三代垃圾回收机制（Generational GC）</strong> 解决循环引用问题（即两个或多个对象互相引用，导致引用计数永远不会归零）。</li>
<li>采用 <strong>分代收集（Generational Collection）</strong>，将变量分为 <strong>年轻代（young）、中生代（middle-aged）、老年代（old）</strong>，减少不必要的垃圾回收操作。</li>
</ul>
</li>
<li>
<p><strong>分代垃圾回收（Generational Garbage Collection）</strong></p>
<ul>
<li><strong>年轻代（young）</strong>：刚创建的变量，GC 触发频率高。</li>
<li><strong>中生代（middle-aged）</strong>：已存活一段时间的变量，GC 触发频率较低。</li>
<li><strong>老年代（old）</strong>：存活很久的变量，GC 触发最少。</li>
<li>这种策略减少了垃圾回收对性能的影响，提高了执行效率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-php-7-及以后的垃圾回收策略"><strong>2. PHP 7 及以后的垃圾回收策略</strong></h3>
<h4 id="21-触发条件"><strong>2.1 触发条件</strong></h4>
<p>PHP 的垃圾回收不会立即执行，而是满足以下条件时触发：</p>
<ol>
<li><strong>变量的引用计数降为 0</strong>，立即释放内存（适用于无循环引用的变量）。</li>
<li><strong>垃圾回收阈值触发</strong>，即：
<ul>
<li><strong>当创建的新变量数量超过 GC 阈值</strong>（默认 10,000），GC 可能会运行。</li>
<li><strong>当 PHP 发现有循环引用</strong>，会进入 GC 过程，释放循环引用的内存。</li>
</ul>
</li>
</ol>
<h4 id="22-关键优化点"><strong>2.2 关键优化点</strong></h4>
<ul>
<li><strong>减少不必要的 GC 触发</strong>
<ul>
<li>由于采用了<strong>分代垃圾回收</strong>，PHP 不会每次都扫描所有变量，而是优先回收<strong>年轻代变量</strong>，减少影响。</li>
</ul>
</li>
<li><strong>提升 GC 执行效率</strong>
<ul>
<li>PHP 7 优化了 GC 算法，使得清理循环引用的操作更快。</li>
</ul>
</li>
<li><strong>优化变量管理</strong>
<ul>
<li>PHP 7 对 <code>zend_mm_heap</code>（PHP 内存管理器）进行了改进，提高了变量分配和回收的效率。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-常见问题及优化建议"><strong>3. 常见问题及优化建议</strong></h3>
<h4 id="31-避免循环引用"><strong>3.1 避免循环引用</strong></h4>
<p>如果 PHP 代码中存在对象相互引用，GC 可能不会立即释放内存。解决方法：</p>
<ul>
<li>
<p><strong>使用 <code>WeakReference</code>（PHP 7.4+）</strong>：</p>
<pre><code class="language-php">$obj1 = new stdClass();
$obj2 = new stdClass();

$obj1-&gt;ref = WeakReference::create($obj2);
$obj2-&gt;ref = WeakReference::create($obj1);
</code></pre>
<p>这样不会增加引用计数，GC 触发时可以正常回收。</p>
</li>
<li>
<p><strong>手动释放引用</strong></p>
<pre><code class="language-php">$obj1-&gt;ref = null;
$obj2-&gt;ref = null;
</code></pre>
</li>
</ul>
<h4 id="32-手动触发垃圾回收"><strong>3.2 手动触发垃圾回收</strong></h4>
<p>如果内存使用过高，可以手动调用 <code>gc_collect_cycles()</code> 进行垃圾回收：</p>
<pre><code class="language-php">gc_collect_cycles();
</code></pre>
<p>但通常情况下，PHP 的 GC 机制已经足够智能，不需要手动调用。</p>
<h4 id="33-关闭调整-gc"><strong>3.3 关闭/调整 GC</strong></h4>
<ul>
<li>
<p><strong>禁用 GC</strong>（在特定情况下提高性能）：</p>
<pre><code class="language-php">gc_disable();
</code></pre>
<p>适用于短生命周期的脚本，例如 CLI 工具、任务队列等，避免 GC 影响执行速度。</p>
</li>
<li>
<p><strong>重新启用 GC</strong></p>
<pre><code class="language-php">gc_enable();
</code></pre>
</li>
<li>
<p><strong>调整 GC 阈值</strong><br>
可以通过 <code>gc_mem_caches()</code> 调整回收策略，优化长时间运行的应用。</p>
</li>
</ul>
<hr>
<h3 id="4-总结"><strong>4. 总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>PHP 版本</strong></th>
<th><strong>垃圾回收机制</strong></th>
<th><strong>优化点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PHP 7+</strong></td>
<td>引入 <strong>分代垃圾回收（Generational GC）</strong></td>
<td>提高 GC 效率，减少性能开销</td>
</tr>
<tr>
<td><strong>PHP 7.4+</strong></td>
<td>引入 <code>WeakReference</code></td>
<td>避免不必要的引用计数</td>
</tr>
</tbody>
</table>
<h2 id="__invoke使用">__invoke使用</h2>
<p>__invoke 是 PHP 的魔术方法之一，允许对象像函数一样被调用。它的主要作用是 让类的实例可以像函数一样执行，从而提供更灵活的代码设计</p>
<p><code> $socket-&gt;on('connection', $this);</code>,connection 对应的是$this，新连接处理就在__invoke。因此我们关注的点就在__invoke上了，可以看到laravel框架有很多的地方使用了__invoke，那么对于我们来说也是有机会用到自己的代码里的。</p>
<hr>
<h1 id="新连接处理">新连接处理</h1>
<p>我们现在重点关心__invoke里面的代码，当有数据到达时调用 handleRequest() 方法处理，深入到handleRequest里面。</p>
<h2 id="handlerequest-处理流程">handleRequest 处理流程</h2>
<ul>
<li>连接状态判断： 开始检查连接是否已经建立（isConnected()），如果已经连接，则直接返回，避免重复处理</li>
<li>调用 createRequest() 将原始消息转换为 PSR-7 Request 对象。如果请求创建失败（返回 null），则直接返回，不进行后续调度。</li>
<li>连接激活： 成功创建请求后，调用 $connection-&gt;connect() 激活连接，表示已准备好处理请求。</li>
<li>路由分发： 使用注入的 $router 对象，根据请求内容分发到对应的控制器或处理逻辑。</li>
<li>异常处理： 如果调度过程中捕获到 HttpException，则根据异常状态码和消息关闭连接。捕获所有其他异常时，先记录错误日志，然后返回 500 状态码，告知客户端服务器内部错误。</li>
</ul>
<h2 id="路由分发">路由分发</h2>
<p>我们现在就来到了<code>vendor/laravel/reverb/src/Servers/Reverb/Http/Router.php</code>,路由类里面，继续看核心的<code>dispatch</code></p>
<pre><code class="language-php"> public function dispatch(RequestInterface $request, Connection $connection): mixed
    {
        $uri = $request-&gt;getUri();
        $context = $this-&gt;matcher-&gt;getContext();

        $context-&gt;setMethod($request-&gt;getMethod());
        $context-&gt;setHost($uri-&gt;getHost());

        try {
            $route = $this-&gt;matcher-&gt;match($uri-&gt;getPath());
        } catch (MethodNotAllowedException $e) {
            return $this-&gt;close($connection, 405, 'Method not allowed.', ['Allow' =&gt; $e-&gt;getAllowedMethods()]);
        } catch (ResourceNotFoundException $e) {
            return $this-&gt;close($connection, 404, 'Not found.');
        }

        $controller = $this-&gt;controller($route);

        if ($this-&gt;isWebSocketRequest($request)) {
            $wsConnection = $this-&gt;attemptUpgrade($request, $connection);

            return $controller($request, $wsConnection, ...Arr::except($route, ['_controller', '_route']));
        }

        $routeParameters = Arr::except($route, [
            '_controller',
            '_route',
        ]) + ['request' =&gt; $request, 'connection' =&gt; $connection];

        $response = $controller(
            ...$this-&gt;arguments($controller, $routeParameters)
        );

        return $response instanceof PromiseInterface ?
            $response-&gt;then(fn ($response) =&gt; $connection-&gt;send($response)-&gt;close()) :
            $connection-&gt;send($response)-&gt;close();
    }
</code></pre>
<p>这个路由分发写的也很好，很好的利用了Symfony 的Route 来实现，写到这里就让想起了上家公司框架里面也是大量使用symfony的route http command process 等核心组件来构建api服务，不得不说symfony才是精品。同时对于我们来说，也可以把symfony的好的组件用于自己的项目。<br>
同时路由也共同处理着http request 以及 ws on message 的流程。<br>
除了路由，我们这里还能学到的一个点就是：webscoket 协议的处理。因此，我们就重点来看下这个。</p>
<h2 id="webscoket-协议的处理">webscoket 协议的处理</h2>
<h3 id="协议升级">协议升级</h3>
<p>我们先关注核心的代码逻辑：</p>
<pre><code class="language-php">        if ($this-&gt;isWebSocketRequest($request)) {
            $wsConnection = $this-&gt;attemptUpgrade($request, $connection);

            return $controller($request, $wsConnection, ...Arr::except($route, ['_controller', '_route']));
        }
</code></pre>
<ul>
<li>如果请求是一个 WebSocket 请求（通过 Upgrade: websocket 头部判断），就尝试进行协议升级。</li>
<li>升级成功后，将请求 $request 和升级后的连接对象 $wsConnection 传递给控制器 $controller 处理。</li>
<li>Arr::except($route, ['_controller', '_route']) 是 Laravel 的辅助函数，表示排除控制器相关信息，传递剩余路由参数</li>
</ul>
<p>也就是我们前端发起建立的ws连接后（比如是：<code>ws://localhost:8083/app/2lza6dryoslsyxss6ub4?protocol=7&amp;client=js&amp;version=8.4.0&amp;flash=false</code>)，就会走到协议升级的$controller处理。那具体处理在哪呢，这个就要回到我们上节提到的：<code>pusherRoutes</code>里定义的路由了。那么，我们快马加鞭的回到那里去，同时也说明下，这里对ws协议没有讲完。我准备在下面的内容在进行说明<br>
<img src="https://img2024.cnblogs.com/blog/990003/202503/990003-20250312222123784-902846808.png" alt="image" loading="lazy"></p>
<h3 id="业务具体处理">业务具体处理</h3>
<p>我们回到了<code>vendor/laravel/reverb/src/Servers/Reverb/Factory.php</code> 的<code>pusherRoutes</code>方法里面，然后就看第一条路由：</p>
<pre><code class="language-php">$routes-&gt;add('sockets', Route::get('/app/{appKey}', new PusherController(app(PusherServer::class), app(ApplicationProvider::class))));
</code></pre>
<p>是不是一下子就破案了呢，这个路由匹配了ws连接地址<code>/app/2lza6dryoslsyxss6ub4</code>,因此<code>PusherController</code> 就是ws的处理。因此我们就继续走，来到：<code>vendor/laravel/reverb/src/Protocols/Pusher/Http/Controllers/PusherController.php</code><br>
同样的controller也是用到了__invoke，因此我们直接盘它。</p>
<hr>
<h2 id="pusher-协议">Pusher 协议</h2>
<h3 id="1-消息格式"><strong>1. 消息格式</strong></h3>
<p>Pusher 协议中的消息格式是 JSON，一般结构如下：</p>
<pre><code class="language-json">{
  "event": "event-name",
  "data": "stringified JSON",
  "channel": "optional-channel-name"
}
</code></pre>
<p>例子：</p>
<pre><code class="language-json">{
  "event": "pusher:subscribe",
  "data": {
    "channel": "private-chat.123"
  }
}
</code></pre>
<p>或者消息推送：</p>
<pre><code class="language-json">{
  "event": "client-message",
  "data": {
    "text": "Hello"
  },
  "channel": "chat.123"
}
</code></pre>
<hr>
<h3 id="2-控制器中处理的-websocket-生命周期"><strong>2. 控制器中处理的 WebSocket 生命周期</strong></h3>
<p>控制器里注册了三种 WebSocket 事件监听：</p>
<pre><code class="language-php">$connection-&gt;onMessage(fn ($message) =&gt; ... );
$connection-&gt;onControl(fn (FrameInterface $message) =&gt; ... );
$connection-&gt;onClose(fn () =&gt; ... );
</code></pre>
<h4 id="onmessage"><strong>onMessage()</strong></h4>
<p>当浏览器发送 WebSocket 消息时：</p>
<pre><code class="language-php">fn ($message) =&gt; $this-&gt;server-&gt;message($reverbConnection, (string) $message)
</code></pre>
<ul>
<li>将接收到的消息字符串传给 <code>PusherServer::message()</code> 处理。</li>
<li>这个方法里会解析 JSON，判断 event 类型，比如：
<ul>
<li><code>pusher:subscribe</code>：表示客户端订阅频道。</li>
<li><code>client-event</code>：客户端发送自定义消息。</li>
<li><code>ping/pong</code>：心跳检查。</li>
</ul>
</li>
<li>然后进行路由、鉴权、广播等逻辑。</li>
</ul>
<h4 id="oncontrol"><strong>onControl()</strong></h4>
<pre><code class="language-php">fn (FrameInterface $message) =&gt; $this-&gt;server-&gt;control($reverbConnection, $message)
</code></pre>
<ul>
<li>控制帧，如 <code>ping</code>、<code>pong</code>、<code>close</code> 等帧。</li>
<li>比如，客户端发送 ping，这里可以回应 pong。</li>
<li>这部分属于 WebSocket 协议的低层部分，保证连接活跃。</li>
</ul>
<h4 id="onclose"><strong>onClose()</strong></h4>
<pre><code class="language-php">fn () =&gt; $this-&gt;server-&gt;close($reverbConnection)
</code></pre>
<ul>
<li>当连接关闭时，做清理，比如移除连接、取消订阅、广播离线消息等。</li>
</ul>
<hr>
<h3 id="3-连接初始化"><strong>3. 连接初始化</strong></h3>
<pre><code class="language-php">$this-&gt;server-&gt;open($reverbConnection);
</code></pre>
<ul>
<li>通知 <code>PusherServer</code> 有一个新的连接建立了。</li>
<li>它可能会给客户端推送一个 <code>pusher:connection_established</code> 消息：</li>
</ul>
<pre><code class="language-json">{
  "event": "pusher:connection_established",
  "data": {
    "socket_id": "some-unique-id",
    "activity_timeout": 120
  }
}
</code></pre>
<p>这个是 Pusher 协议里约定的，客户端拿到 <code>socket_id</code> 后，才能订阅私有频道等。</p>
<p>当 appKey 无效时，会推送一个标准的错误：</p>
<pre><code class="language-php">$connection-&gt;send('{"event":"pusher:error","data":"{\"code\":4001,\"message\":\"Application does not exist\"}"}');
</code></pre>
<hr>
<ul>
<li>作为 WebSocket 路由的入口</li>
<li>实现 <strong>Pusher 协议的握手、订阅、消息处理</strong>等</li>
<li>封装了低层的 <code>Connection</code> 和高层的 <code>Application</code> 为 <code>ReverbConnection</code></li>
<li>注册了完整的 WebSocket 生命周期事件（消息、控制帧、关闭）</li>
</ul>
<p>而 <strong>Pusher 协议的数据结构</strong> 是基于 JSON 的，所有通信事件都通过 <code>event + data (+channel)</code> 来传递和解析，保持了高度的灵活性和可扩展性。</p>
<hr>
<p>为了一起学习，我们用gpt4来系统总结下websocket的知识。</p>
<h2 id="一websocket-是什么"><strong>一、WebSocket 是什么？</strong></h2>
<p>WebSocket 是一种 <strong>基于 TCP 的双向通信协议</strong>，它允许浏览器和服务器之间建立一个 <strong>持久的连接</strong>，双方可以随时互发数据，而无需每次都重新建立连接（像 HTTP 那样）。</p>
<p>它最初由 <a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener nofollow">RFC 6455</a> 规范定义。</p>
<hr>
<h2 id="二websocket-建立过程"><strong>二、WebSocket 建立过程</strong></h2>
<h3 id="1-握手阶段http-协议完成升级">1. <strong>握手阶段（HTTP 协议完成升级）</strong></h3>
<p>WebSocket 连接开始于一个 <strong>HTTP GET 请求</strong>，客户端发送如下请求：</p>
<pre><code class="language-http">GET /app/abc123 HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
</code></pre>
<p>关键字段说明：</p>
<ul>
<li><code>Upgrade: websocket</code>：告诉服务器要升级为 WebSocket 协议。</li>
<li><code>Connection: Upgrade</code>：和上面的配套，表示连接要升级。</li>
<li><code>Sec-WebSocket-Key</code>：一个随机的 base64 编码字符串，用于安全校验。</li>
<li><code>Sec-WebSocket-Version</code>：WebSocket 协议版本，当前为 <code>13</code>。</li>
</ul>
<h3 id="2-服务器响应握手">2. <strong>服务器响应握手</strong></h3>
<p>服务器验证合法后，会响应如下内容：</p>
<pre><code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</code></pre>
<ul>
<li><code>Sec-WebSocket-Accept</code> 是通过客户端的 <code>Sec-WebSocket-Key</code> 计算得来的：<pre><code class="language-php">base64_encode(sha1($clientKey . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));
</code></pre>
</li>
</ul>
<p>一旦握手完成，HTTP 连接就升级为 WebSocket，之后传输的所有数据都不再是 HTTP 格式，而是 <strong>WebSocket 帧格式</strong>。</p>
<hr>
<h2 id="三websocket-数据帧结构"><strong>三、WebSocket 数据帧结构</strong></h2>
<p>WebSocket 的通信是以 <strong>帧（frame）</strong> 为单位的，每一帧都包含：</p>
<h3 id="帧结构简化图"><strong>帧结构（简化图）</strong></h3>
<pre><code>0               1               2               3
+-------+-------+---------------+-------------------------------+
|FIN| RSV | OPCODE | MASK | Payload Len | Extended Len | MASK Key |
+-------+-------+---------------+-------------------------------+
|         Payload Data (possibly masked)                        |
+---------------------------------------------------------------+
</code></pre>
<h3 id="重要字段">重要字段：</h3>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FIN</strong></td>
<td>1 位，是否是消息最后一帧。通常为 1。</td>
</tr>
<tr>
<td><strong>Opcode</strong></td>
<td>表示帧的类型（文本、二进制、ping 等）。</td>
</tr>
<tr>
<td><strong>MASK</strong></td>
<td>1 位，是否启用掩码（客户端必须设置为 1，服务端返回为 0）。</td>
</tr>
<tr>
<td><strong>Payload Length</strong></td>
<td>数据长度（可能需要扩展长度字段）。</td>
</tr>
<tr>
<td><strong>Masking Key</strong></td>
<td>4 字节，客户端加密数据使用的密钥。</td>
</tr>
<tr>
<td><strong>Payload Data</strong></td>
<td>实际传输的数据，客户端发出时必须被掩码处理。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="opcode-类型"><strong>Opcode 类型</strong></h3>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>连续帧（后续帧）</td>
</tr>
<tr>
<td>0x1</td>
<td>文本帧（UTF-8）</td>
</tr>
<tr>
<td>0x2</td>
<td>二进制帧</td>
</tr>
<tr>
<td>0x8</td>
<td>关闭连接</td>
</tr>
<tr>
<td>0x9</td>
<td>Ping（心跳）</td>
</tr>
<tr>
<td>0xA</td>
<td>Pong（回应）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例发送一条文本消息-hi客户端---服务端"><strong>示例：发送一条文本消息 "hi"（客户端 -&gt; 服务端）</strong></h3>
<ul>
<li><code>Opcode = 0x1</code>（文本帧）</li>
<li><code>Payload = "hi"</code>，长度为 2 字节</li>
<li><code>MASK = 1</code>（客户端发送时必须掩码）</li>
<li>使用掩码 key 加密 payload</li>
</ul>
<p>服务端接收到后会反掩码还原出原始文本。</p>
<hr>
<h2 id="四控制帧"><strong>四、控制帧</strong></h2>
<p>控制帧是管理连接用的：</p>
<ul>
<li><strong>Ping / Pong</strong>：用于心跳机制，确保连接活跃。</li>
<li><strong>Close</strong>：通知对方关闭连接，可以携带关闭原因和状态码。</li>
</ul>
<hr>
<h2 id="五连接关闭"><strong>五、连接关闭</strong></h2>
<p>当任意一方想关闭连接，会发送一个 <code>Opcode = 0x8</code> 的帧，并可附带一个状态码（如 1000 表示正常关闭）。</p>
<hr>
<h2 id="六与-laravel-reverb-的对应关系"><strong>六、与 Laravel Reverb 的对应关系</strong></h2>
<p>你之前看到的 <code>onMessage</code>, <code>onControl</code>, <code>onClose</code> 实际就是对上述底层帧的响应封装：</p>
<ul>
<li><code>onMessage</code>：处理 <code>Opcode=0x1</code> 的文本帧。</li>
<li><code>onControl</code>：处理 <code>Ping</code> / <code>Pong</code> / <code>Close</code> 控制帧。</li>
<li><code>onClose</code>：对应连接断开（可能是收到 Close 帧，或 TCP 断了）。</li>
</ul>
<hr>
<h2 id="总结一句话"><strong>总结一句话</strong></h2>
<blockquote>
<p>WebSocket 是在 TCP 上建立的持久双向通信协议，先通过 HTTP 升级，然后通过一套专门的二进制帧结构进行通信，帧可以是文本、二进制、Ping/Pong 或 Close。</p>
</blockquote>
<h2 id="websocket-帧结构图">WebSocket 帧结构图</h2>
<p><img src="https://img2024.cnblogs.com/blog/990003/202503/990003-20250312223711059-896897989.png" alt="image" loading="lazy"></p>
<hr>
<h3 id="各字段说明">各字段说明：</h3>
<ol>
<li><strong>FIN (1 bit)</strong>：是否为消息最后一帧（1 表示是，0 表示后面还有）。</li>
<li><strong>RSV1, RSV2, RSV3 (各 1 bit)</strong>：保留位，通常为 0。</li>
<li><strong>Opcode (4 bits)</strong>：
<ul>
<li><code>0x1</code>：文本帧</li>
<li><code>0x2</code>：二进制帧</li>
<li><code>0x8</code>：关闭连接</li>
<li><code>0x9</code>：Ping</li>
<li><code>0xA</code>：Pong</li>
</ul>
</li>
<li><strong>MASK (1 bit)</strong>：
<ul>
<li>客户端必须设置为 1（数据经过掩码处理）</li>
<li>服务端必须设置为 0（不使用掩码）</li>
</ul>
</li>
<li><strong>Payload Len (7 bits)</strong>：
<ul>
<li>小于 126：直接写长度</li>
<li>等于 126：后面扩展 16 位表示长度</li>
<li>等于 127：后面扩展 64 位表示长度</li>
</ul>
</li>
<li><strong>Extended Payload Len</strong>：只有在 Payload 长度大于等于 126 时才出现。</li>
<li><strong>Masking Key (32 bits)</strong>：
<ul>
<li>客户端发送数据时用此 key 掩码实际内容</li>
</ul>
</li>
<li><strong>Payload Data</strong>：真正的数据内容（可能是掩码处理的）</li>
</ol>
<hr>
<p>好，我们继续看一个真实的 <strong>WebSocket 抓包数据示例</strong>，演示一次客户端发送文本消息 <code>"hi"</code> 的原始帧数据，以及如何解析它。</p>
<hr>
<h2 id="场景浏览器向服务器发送消息-hi"><strong>场景：浏览器向服务器发送消息 <code>"hi"</code></strong></h2>
<p>我们抓包看到 WebSocket 帧如下（十六进制）：</p>
<pre><code>81 82 37 fa 21 3d 5f 9f 44 52
</code></pre>
<hr>
<h3 id="逐字节解析"><strong>逐字节解析：</strong></h3>
<table>
<thead>
<tr>
<th>字节</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>81</code></td>
<td><strong>FIN=1</strong>, <strong>Opcode=1</strong>（文本帧）</td>
</tr>
<tr>
<td><code>82</code></td>
<td><strong>MASK=1</strong>, <strong>Payload length=2</strong>（表示2个字节的内容）</td>
</tr>
<tr>
<td><code>37 fa 21 3d</code></td>
<td><strong>掩码 key</strong>（masking key）</td>
</tr>
<tr>
<td><code>5f 9f</code></td>
<td>被掩码处理过的 <code>"hi"</code> 数据</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="掩码还原-payload"><strong>掩码还原 Payload</strong></h3>
<p>掩码算法（RFC6455 标准）：<br>
<code>payload[i] = encoded[i] ^ masking_key[i % 4]</code></p>
<p>还原过程：</p>
<pre><code class="language-text">原始数据（masked）:   0x5f 0x9f
掩码 key:           0x37 0xfa 0x21 0x3d

还原：
byte 1: 0x5f ^ 0x37 = 0x68 = 'h'
byte 2: 0x9f ^ 0xfa = 0x69 = 'i'
</code></pre>
<p><strong>→ 得出还原结果："hi"</strong></p>
<hr>
<h2 id="图解总结"><strong>图解总结：</strong></h2>
<pre><code>[81]     -&gt; FIN + Opcode（0x1 = 文本帧）
[82]     -&gt; MASK=1, Payload长度=2
[37 fa 21 3d] -&gt; 掩码 key
[5f 9f]  -&gt; 掩码后的 payload（hi）

还原后 payload: "hi"
</code></pre>
<hr>
<h2 id="再举个服务端发送回客户端的数据帧"><strong>再举个服务端发送回客户端的数据帧</strong></h2>
<p>假设服务端发回文本消息 <code>"ok"</code>，不需要掩码：</p>
<pre><code>81 02 6f 6b
</code></pre>
<table>
<thead>
<tr>
<th>字节</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>81</code></td>
<td>FIN=1, Opcode=1（文本帧）</td>
</tr>
<tr>
<td><code>02</code></td>
<td>MASK=0, Payload 长度 = 2</td>
</tr>
<tr>
<td><code>6f 6b</code></td>
<td>字符 <code>"o"</code> 和 <code>"k"</code> 的 ASCII（0x6F 0x6B）</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="总结"><strong>总结</strong></h1>
<p>这一节就到这里了，希望对你有用。同时，提前也提前吹下swoole的风：swoole底层处理了很多步骤，比如：<br>
<img src="https://img2024.cnblogs.com/blog/990003/202503/990003-20250312224546558-1341024445.png" alt="image" loading="lazy"><br>
这样简化了上层开发，同时也放开了上层开发的处理，因此我们在使用技术框架、组件的时候应当更仔细阅读其文档。</p>

</div>
<div id="MySignature" role="contentinfo">
    有耕耘、有搬运、共学习
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7307808428206019" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-12 22:49">2025-03-12 22:49</span>&nbsp;
<a href="https://www.cnblogs.com/YangJieCheng">wanzij</a>&nbsp;
阅读(<span id="post_view_count">42</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18768844" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18768844);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18768844', targetLink: 'https://www.cnblogs.com/YangJieCheng/p/18768844', title: 'Laravel11 从0开发 Swoole-Reverb 扩展包（四） - 触发一个广播事件到reverb服务之后是如何转发给前端订阅的呢（下）？' })">举报</a>
</div>
        