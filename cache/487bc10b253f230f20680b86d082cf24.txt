
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaoxiblog/p/18832594" title="发布于 2025-04-18 11:46">
    <span role="heading" aria-level="2">gRPC 和传统 RPC 有啥不一样？一篇讲清楚！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p class="md-end-block md-p"><span class="md-plain">现在大家做系统开发，都喜欢搞"微服务架构"——简单说就是把一个大系统拆成很多小服务，这样更灵活也更容易扩展。那这些服务之间怎么沟通呢？就得靠一种技术叫 </span><span class="md-pair-s "><strong><span class="md-plain">RPC（远程过程调用）</span></strong></span><span class="md-plain">。今天我们就来聊聊它的"进化版"：</span><span class="md-pair-s "><strong><span class="md-plain">gRPC</span></strong></span><span class="md-plain">，看看它和传统的 RPC 到底有啥不一样。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">一、先搞懂几个概念</span></h2>
<h3 class="md-end-block md-heading"><span class="md-plain">什么是 RPC？</span></h3>
<p class="md-end-block md-p"><span class="md-plain">可以把它理解成"跨机器调用函数"的方式。就像你在本地调用一个函数一样，但其实它是在另一台服务器上运行的。传统 RPC 有很多种实现，比如 XML-RPC、JSON-RPC、SOAP 等，数据格式多是 XML 或 JSON。</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">那 gRPC 是啥？</span></h3>
<p class="md-end-block md-p"><span class="md-plain">Google 出品的一个更高效的 RPC 框架，基于 HTTP/2 协议，数据格式用的是 Protocol Buffers（简称 Protobuf）。性能好、效率高，还能自动生成代码，听起来就很香对吧？</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">二、gRPC 和传统 RPC 的几大区别（白话版）</span></h2>
<figure class="md-table-fig">
<table class="md-table">
<thead>
<tr class="md-end-block">
<th><span class="td-span"><span class="md-plain">对比点</span></span></th>
<th><span class="td-span"><span class="md-plain">传统 RPC</span></span></th>
<th><span class="td-span"><span class="md-plain">gRPC</span></span></th>
</tr>
</thead>
<tbody>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">传输协议</span></span></td>
<td><span class="td-span"><span class="md-plain">通常用 HTTP/1 或 TCP</span></span></td>
<td><span class="td-span"><span class="md-plain">HTTP/2，支持多路复用，速度快</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">数据格式</span></span></td>
<td><span class="td-span"><span class="md-plain">XML/JSON，可读但体积大</span></span></td>
<td><span class="td-span"><span class="md-plain">Protobuf，体积小，解析快</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">代码生成</span></span></td>
<td><span class="td-span"><span class="md-plain">通常手动写</span></span></td>
<td><span class="td-span"><span class="md-plain">支持自动生成客户端/服务端代码</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">流式处理</span></span></td>
<td><span class="td-span"><span class="md-plain">一般不支持</span></span></td>
<td><span class="td-span"><span class="md-plain">支持四种调用模式，支持双向流</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">跨语言支持</span></span></td>
<td><span class="td-span"><span class="md-plain">有点费劲</span></span></td>
<td><span class="td-span"><span class="md-plain">官方支持多语言（Go、Python 等）</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span class="md-plain">错误处理</span></span></td>
<td><span class="td-span"><span class="md-plain">用 HTTP 状态码处理</span></span></td>
<td><span class="td-span"><span class="md-plain">用标准错误码机制，支持详细描述</span></span></td>
</tr>
</tbody>
</table>
</figure>
<h2 class="md-end-block md-heading"><span class="md-plain">三、举个例子更直观</span></h2>
<h3 class="md-end-block md-heading"><span class="md-plain">用传统 JSON-RPC 调接口</span></h3>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="json" tabindex="0" spellcheck="false"><code>{
  "jsonrpc": "2.0",
  "method": "getUserProfile",
  "params": {
    "userId": 123,
    "includeDetails": true
  },
  "id": 1
}</code></pre>
<p class="md-end-block md-p"><span class="md-plain">人类能看懂，但数据量大，解析速度也慢。</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">用 gRPC + Protobuf</span></h3>
<p class="md-end-block md-p"><span class="md-plain">首先定义协议：</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="protobuf" tabindex="0" spellcheck="false"><code>syntax = "proto3";
​
service UserService {
  rpc GetUserProfile(UserRequest) returns (UserProfile) {}
}
​
message UserRequest {
  int32 user_id = 1;
  bool include_details = 2;
}
​
message UserProfile {
  int32 user_id = 1;
  string username = 2;
  string email = 3;
}</code></pre>
<p class="md-end-block md-p"><span class="md-plain">然后就可以这样调用：</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>request = user_pb2.UserRequest(user_id=123, include_details=True)
response = stub.GetUserProfile(request)
print(f"用户名: {response.username}")</code></pre>
<p class="md-end-block md-p"><span class="md-plain">结构更清晰、体积更小、传输效率更高。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">四、请求处理方式对比</span></h2>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">传统RPC的调用方式</span></h3>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code># XML-RPC示例
import xmlrpc.client
​
# 创建客户端
server = xmlrpc.client.ServerProxy("http://localhost:8000")
​
# 每次调用都会建立新连接
result = server.get_user_info(user_id=123)
print(f"用户信息: {result}")
​
# 又得重新连接
another_result = server.get_product_details(product_id=456)</code></pre>
<p class="md-end-block md-p"><span class="md-plain">就像每次打电话都要重新拨号一样，费时间！</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">gRPC的调用方式</span></h3>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>import grpc
import user_service_pb2
import user_service_pb2_grpc
​
# 创建一个连接通道
with grpc.insecure_channel('localhost:50051') as channel:
    # 创建调用对象
    stub = user_service_pb2_grpc.UserServiceStub(channel)
    
    # 同一个连接可以调用多个方法
    response1 = stub.GetUser(user_service_pb2.GetUserRequest(user_id=123))
    response2 = stub.GetProduct(user_service_pb2.GetProductRequest(product_id=456))
    
    # 还能做流式调用，像看视频一样一点点接收数据
    for product in stub.ListProducts(user_service_pb2.ListProductsRequest(category="手机")):
        print(f"产品: {product.name}, 价格: {product.price}")</code></pre>
<p class="md-end-block md-p"><span class="md-plain">就像建立一条专线，通话不断，还能边说边听，太方便了！</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">五、性能差距有多大？</span></h2>
<p class="md-end-block md-p"><span class="md-plain">场景：获取 1000 个用户信息</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">传统 REST（HTTP/1 + JSON）版本：</span></h3>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>import requests
import time
​
start_time = time.time()
users = []
​
# 发送1000个独立的HTTP请求，每次都要建连接
for i in range(1000):
    response = requests.get(f"http://api.example.com/users/{i}")
    users.append(response.json())
​
duration = time.time() - start_time
print(f"REST API: 获取了{len(users)}个用户，耗时{duration:.2f}秒")
# 输出: REST API: 获取了1000个用户，耗时10.45秒</code></pre>
<h3 class="md-end-block md-heading"><span class="md-plain">gRPC 版本：</span></h3>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>import grpc
import user_pb2
import user_pb2_grpc
import time
​
start_time = time.time()
​
with grpc.insecure_channel('api.example.com:50051') as channel:
    stub = user_pb2_grpc.UserServiceStub(channel)
    
    # 一次请求获取所有用户，批量处理
    users = list(stub.GetUsers(user_pb2.GetUsersRequest(limit=1000)))
​
duration = time.time() - start_time
print(f"gRPC: 获取了{len(users)}个用户，耗时{duration:.2f}秒")
# 输出: gRPC: 获取了1000个用户，耗时1.23秒</code></pre>
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">总结</span></strong></span><span class="md-plain">：gRPC 更快，因为它：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">支持连接复用（不用每次都重新连）</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">使用 Protobuf，数据更轻更快</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">流式处理，批量效率高</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">六、错误处理方式对比</span></h2>
<h3 class="md-end-block md-heading"><span class="md-plain">REST 错误处理：</span></h3>
<p class="md-end-block md-p"><span class="md-plain">服务端返回的错误：</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded highlighter-prismjs language-none prismjs-lines-highlighted" lang="json" tabindex="0" spellcheck="false"><code>{
  "error": {
    "code": 404,
    "message": "User not found",
    "details": "The user with ID 12345 does not exist"
  }
}</code></pre>
<p class="md-end-block md-p"><span class="md-plain">客户端处理：</span></p>
<pre class="md-fences mock-cm md-end-block highlighter-prismjs language-none prismjs-lines-highlighted" lang="javascript" tabindex="0" spellcheck="false"><code>fetch('/api/users/12345')
  .then(response =&gt; {
    if (!response.ok) {
      return response.json().then(err =&gt; {
        throw new Error(`${err.error.message}: ${err.error.details}`);
      });
    }
    return response.json();
  })
  .catch(error =&gt; console.error('错误:', error));</code></pre>
<p class="md-end-block md-p"><span class="md-plain">靠 HTTP 状态码，但格式不统一，需要手动解析。</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">gRPC 错误处理：</span></h3>
<p class="md-end-block md-p"><span class="md-plain">服务端定义错误：</span></p>
<pre class="md-fences mock-cm md-end-block highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>def GetUser(self, request, context):
    user = database.find_user(request.user_id)
    if not user:
        context.set_code(grpc.StatusCode.NOT_FOUND)
        context.set_details(f"找不到用户 {request.user_id}")
        return user_pb2.UserProfile()  # 返回空对象
    return user</code></pre>
<p class="md-end-block md-p"><span class="md-plain">客户端处理错误：</span></p>
<pre class="md-fences mock-cm md-end-block highlighter-prismjs language-none prismjs-lines-highlighted" lang="python" tabindex="0" spellcheck="false"><code>try:
    response = stub.GetUser(request)
    print(f"用户信息: {response}")
except grpc.RpcError as e:
    if e.code() == grpc.StatusCode.NOT_FOUND:
        print(f"错误: 用户不存在 - {e.details()}")
    else:
        print(f"RPC错误: {e.code()} - {e.details()}")</code></pre>
<p class="md-end-block md-p"><span class="md-plain">标准的错误码 + 描述，客户端可以直接 catch。像处理本地异常一样方便！</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">七、实际应用场景选择</span></h2>
<h3 class="md-end-block md-heading"><span class="md-plain">什么时候用传统REST API？</span></h3>
<ol class="ol-list" start="">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">前端直接调API</span></strong></span></p>
<pre class="md-fences mock-cm md-end-block highlighter-prismjs language-none prismjs-lines-highlighted" lang="javascript" tabindex="0" spellcheck="false"><code>// 浏览器调REST API就很方便
fetch('/api/products')
  .then(res =&gt; res.json())
  .then(products =&gt; console.log(products));</code></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">接第三方平台</span></strong></span> <span class="md-plain">比如接微信支付、支付宝API，人家都是REST的，你也得跟着来</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">简单系统</span></strong></span> <span class="md-plain">小项目不追求性能，REST开发速度快</span></p>
</li>
</ol>
<h3 class="md-end-block md-heading"><span class="md-plain">什么时候用gRPC？</span></h3>
<ol class="ol-list" start="">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">微服务内部通信</span></strong></span> <span class="md-plain">服务多了，内部调用频繁，用gRPC又快又稳</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">实时数据应用</span></strong></span></p>
<pre class="md-fences mock-cm md-end-block highlighter-prismjs language-none prismjs-lines-highlighted" lang="go" tabindex="0" spellcheck="false"><code>// 股票价格实时推送
func (s *StockServer) PriceStream(request *pb.StockRequest, stream pb.StockService_PriceStreamServer) error {
  for {
    price := getLatestPrice(request.Symbol)
    stream.Send(&amp;pb.StockPrice{
      Symbol: request.Symbol,
      Price: price,
      Timestamp: time.Now().Unix(),
    })
    time.Sleep(1 * time.Second)
  }
}</code></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">移动端应用</span></strong></span> <span class="md-plain">手机流量金贵，gRPC数据小，省流量</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">多语言系统</span></strong></span> <span class="md-plain">Python服务调Go服务，Java服务调C#服务，都不是问题</span></p>
</li>
</ol>
<h2 class="md-end-block md-heading"><span class="md-plain">八、总结一句话</span></h2>
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">REST API就像普通话，大家都听得懂；gRPC像高速公路，虽然有门槛，但一旦上了路就飞快！</span></strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">如果你在做面向普通用户的接口，或者简单系统，REST API足够了。</span></p>
<p class="md-end-block md-p"><span class="md-plain md-expand">但如果你在构建微服务、需要高性能、多语言、流式处理能力，那就果断上gRPC！</span></p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiaoxiblog/" target="_blank">萧熙</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiaoxiblog/p/18832594" target="_blank">https://www.cnblogs.com/xiaoxiblog/p/18832594</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.361139542164352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 11:46">2025-04-18 11:46</span>&nbsp;
<a href="https://www.cnblogs.com/xiaoxiblog">萧熙</a>&nbsp;
阅读(<span id="post_view_count">360</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18832594);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18832594', targetLink: 'https://www.cnblogs.com/xiaoxiblog/p/18832594', title: 'gRPC 和传统 RPC 有啥不一样？一篇讲清楚！' })">举报</a>
</div>
        