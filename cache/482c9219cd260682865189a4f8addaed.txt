
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rmb0591/p/18742824" title="发布于 2025-02-28 11:10">
    <span role="heading" aria-level="2">机械图纸文章标题搜索增强实现过程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-为什么需要使用搜索增强技术">1. 为什么需要使用搜索增强技术</h2>
<details>
  <summary>点击展开</summary>
<ul>
<li><strong>机械图纸标题搜索的挑战</strong>：
<ul>
<li>机械图纸标题通常包含专业术语、缩写和特定格式（如“土豆分拣机 DWG-001 不锈钢”）。</li>
<li>用户查询可能模糊或表述不同（如“马铃薯筛选机”），传统搜索难以匹配语义相似的标题。</li>
<li>标题信息有限，传统搜索容易遗漏相关图纸或返回无关结果。</li>
</ul>
</li>
<li><strong>搜索增强的优势</strong>：
<ul>
<li><strong>语义理解</strong>：通过大模型生成语义嵌入向量，理解标题和查询的深层含义，支持模糊匹配和语义相关性排序。
<ul>
<li>示例：用户搜索“土豆分拣机”，传统搜索只能匹配标题中包含“土豆分拣机”的图纸；增强搜索可匹配语义相似的标题，如“马铃薯筛选机”，因为 AI 模型能够理解“土豆”和“马铃薯”是同义词，“分拣”和“筛选”是近义词。</li>
</ul>
</li>
<li><strong>多维度匹配</strong>：结合标题中的专业术语和元数据（如材料、尺寸），提升搜索的准确性和全面性。</li>
<li><strong>高效索引</strong>：使用向量存储（如 Redis）支持快速的相似度搜索，满足实时性需求。</li>
<li><strong>用户体验提升</strong>：返回更相关、更精准的图纸标题结果，减少用户反复调整查询的成本。</li>
</ul>
</li>
</ul>
</details>
<h3 id="11-体验">1.1 体验</h3>
<p>微信小程序名称 <strong>极客共享</strong> 输入搜索内容 有没有土豆分拣机</p>
<details>
  <summary>点击展开</summary>
<p><img src="https://img2024.cnblogs.com/blog/96846/202502/96846-20250228115006044-6273025.png" alt="" loading="lazy"></p>
</details>
<h3 id="12-与传统全文检索elasticsearch的对比">1.2 与传统全文检索（Elasticsearch）的对比</h3>
<details>
  <summary>点击展开</summary>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>传统全文检索（Elasticsearch）</strong></th>
<th><strong>搜索增强（基于语义向量）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>技术原理</strong></td>
<td>基于倒排索引和关键词匹配，依赖分词和词频统计（如 BM25）。</td>
<td>基于大模型生成语义嵌入向量，使用向量相似度（如余弦相似度）匹配。</td>
</tr>
<tr>
<td><strong>语义理解</strong></td>
<td>仅匹配关键词，缺乏语义理解。</td>
<td>理解标题和查询的语义，支持模糊匹配和同义词匹配。</td>
</tr>
<tr>
<td><strong>查询灵活性</strong></td>
<td>用户查询需与标题关键词高度一致，否则结果不准确。</td>
<td>支持模糊查询和不同表述的匹配（如“土豆分拣机”匹配“马铃薯筛选机”）。</td>
</tr>
<tr>
<td><strong>专业术语处理</strong></td>
<td>依赖分词器，专业术语可能被错误切分（如“土豆分拣机”被切为“土豆”和“分拣机”）。</td>
<td>通过预训练模型理解专业术语和同义词的语义，减少分词错误。</td>
</tr>
<tr>
<td><strong>结果相关性</strong></td>
<td>基于词频和位置排序，可能返回无关结果。</td>
<td>基于语义相似度排序，结果更相关。</td>
</tr>
<tr>
<td><strong>实时性与性能</strong></td>
<td>倒排索引查询速度快，但语义匹配需额外插件（如 Elasticsearch KNN）。</td>
<td>向量搜索需高效索引（如 RedisSearch），实时性稍逊但可优化。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适合关键词明确、标题格式标准化的场景。</td>
<td>适合标题复杂、查询模糊或需语义理解的场景。</td>
</tr>
<tr>
<td><strong>机械图纸标题搜索示例</strong></td>
<td>查询“土豆分拣机”，仅匹配标题中包含“土豆分拣机”的图纸，遗漏“马铃薯筛选机”。</td>
<td>查询“土豆分拣机”，可匹配语义相似的标题，如“马铃薯筛选机”，因为 AI 模型理解“土豆”和“马铃薯”、“分拣”和“筛选”是同义词。</td>
</tr>
</tbody>
</table>
</details>
<ul>
<li><strong>总结</strong>：
<ul>
<li>传统全文检索（Elasticsearch）适合关键词明确、标题格式标准化的场景，但对机械图纸标题的语义理解能力有限，容易遗漏相关结果（如“马铃薯筛选机”）。</li>
<li>搜索增强通过语义向量匹配，解决了模糊查询、专业术语处理和同义词匹配的问题，特别适合机械图纸标题搜索的复杂场景。</li>
</ul>
</li>
</ul>
<h3 id="13-搜索增强的含义">1.3 搜索增强的含义</h3>
<ul>
<li><strong>搜索增强的定义</strong>：
<ul>
<li>搜索增强是指通过引入语义理解、向量嵌入等技术，改进传统搜索的局限性，提升搜索结果的相关性和准确性。</li>
<li>在机械图纸标题搜索中，搜索增强通过大模型（如 Sentence-Transformers）将标题文本转化为语义向量，支持基于语义的相似度匹配，而不仅仅依赖关键词匹配。</li>
</ul>
</li>
<li><strong>核心优势</strong>：
<ul>
<li>理解查询和标题的语义，支持模糊匹配、同义词匹配和跨语言匹配。</li>
<li>结合图纸标题的上下文，提供更相关的搜索结果。</li>
<li>提升用户体验，减少因查询表述差异导致的搜索失败。</li>
</ul>
</li>
</ul>
<h2 id="2-系统架构设计">2. 系统架构设计</h2>
<h3 id="21-整体架构">2.1 整体架构</h3>
<ul>
<li><strong>前端</strong>：微信小程序 极客共享  用户输入机械图纸标题相关的查询（如“有没有土豆分拣机”）。</li>
<li><strong>后端</strong>：
<ul>
<li>.NET Core 应用程序，负责处理用户请求、调用 Python API 存储和搜索向量。</li>
<li>Python API 服务，提供机械图纸标题的语义嵌入功能。</li>
</ul>
</li>
<li><strong>向量存储</strong>：
<ul>
<li>使用 Redis 存储机械图纸标题的语义向量，支持快速索引和相似度匹配。</li>
</ul>
</li>
<li><strong>数据流</strong>：
<ol>
<li>机械图纸标题信息 -&gt; .NET Core -&gt; Python API -&gt; 返回向量 -&gt; 存储到 Redis。</li>
<li>用户查询 -&gt; .NET Core -&gt; Python API -&gt; 生成查询向量 -&gt; Redis 搜索 -&gt; 返回结果。</li>
</ol>
</li>
</ul>
<h2 id="2-实现步骤">2. 实现步骤</h2>
<h3 id="21-机械图纸标题向量生成与存储">2.1 机械图纸标题向量生成与存储</h3>
<h4 id="211-准备机械图纸标题数据">2.1.1 准备机械图纸标题数据</h4>
<details>
  <summary>点击展开</summary>
<p><img src="https://img2024.cnblogs.com/blog/96846/202502/96846-20250228111021211-265033952.png" alt="" loading="lazy"></p>
</details>
<h4 id="212-net-core-调用-python-api-生成向量">2.1.2 .NET Core 调用 Python API 生成向量</h4>
<ul>
<li><strong>目标</strong>： 将标题文本和元数据发送到 Python API，获取语义嵌入向量,大模型是bge-large-zh-noinstruct_embeddings）：</li>
</ul>
<details>
    <summary>Python向量生成范例</summary> 
<pre><code class="language-python">from FlagEmbedding import FlagModel 
import pandas as pd 
import numpy as np
from datasets import Dataset
from scipy.spatial import distance 
import datetime
import configparser
import pymysql  
 
model = None 

def getModel():
    global model
    if model is None:
        model = FlagModel("./model",
                    query_instruction_for_retrieval="Represent this sentence for searching relevant passages:",
                    use_fp16=True) 
    return model
#获取向量
def getFlagEmbedding(title):
    global model
    model = getModel()
    embedding = model.encode(title)
    return embedding
  
</code></pre>
</details>
<details>
    <summary>.NET Core调用生成接口（其实就是普通的api请求）</summary> 
<pre><code class="language-csharp"> /// &lt;summary&gt;
 /// 获取向量
 /// &lt;/summary&gt;
 /// &lt;param name="keyword"&gt;&lt;/param&gt;
 /// &lt;returns&gt;&lt;/returns&gt;
 public async Task&lt;double[]&gt; GetFlagEmbedding(string keyword)
 {
     var vector = new double[] { };
     vector = null;
     try
     {
         var req = new
         {
             action = "getFlagEmbedding",
             keyword
         };
         var content = new StringContent(
                        JsonSerializer.Serialize(req)
                        , Encoding.UTF8, "application/json");
         var response = await _client.PostAsync(ConfigHelp.FlagSerachUrl, content);
         if (response.IsSuccessStatusCode)
         {
             var result = await response.Content.ReadAsStringAsync();
             var data = JsonSerializer.Deserialize&lt;GetFlagEmbeddingRoot&gt;(result);
             if (data.op)
             {
                 vector = data.msg.Split(',').Select(double.Parse).ToArray();
             }
         }
     }
     catch (Exception ex)
     {
         LogUtils.Error("GetFlagEmbedding ", ex);
     }

     return vector;
 }
</code></pre>
</details>
<h4 id="213-存储向量到-redis">2.1.3 存储向量到 Redis</h4>
<ul>
<li><strong>目标</strong>：将生成的向量存储到 Redis，支持后续的相似度搜索。</li>
</ul>
<details>
    <summary>搜索数据</summary> 
<pre><code class="language-csharp">   public class RedisVectorHelp
   {
       private readonly IDatabase _db;
       private string _freefix;
       private string _indexName;
       private SearchCommands ft;
       public RedisVectorHelp(string freefix,string redisConnectionString,int dbNum=0)
       {
           var redis = ConnectionMultiplexer.Connect(redisConnectionString);
           _db = redis.GetDatabase(dbNum);
           _freefix = freefix;
           _indexName = _freefix + "_index";
           ft = new SearchCommands(_db, null);
       } 
       /// &lt;summary&gt;
       /// 创建索引
       /// &lt;/summary&gt;
       public void CreateFt()
       {
           var list = ft._List();
           var indexList = list.Select(result =&gt; result.ToString()).ToArray();
           //判断是否存在索引
           if (indexList.Contains(_indexName))
           {
               Console.WriteLine("Index already exists.");
               return;
           }
           ft.Create(_indexName,
 new FTCreateParams()
     .On(IndexDataType.HASH)
     .Prefix(_freefix + ":"),
 new Schema()
     .AddTextField("id")
     .AddVectorField("vector",
     VectorField.VectorAlgo.FLAT,
         new Dictionary&lt;string, object&gt;
         {
             ["TYPE"] = "FLOAT32",
             ["DIM"] = 1024,
             ["DISTANCE_METRIC"] = "COSINE"
         })
     );
       }
       /// &lt;summary&gt;
       /// 存储向量
       /// &lt;/summary&gt;
       /// &lt;param name="id"&gt;&lt;/param&gt;
       /// &lt;param name="vector"&gt;&lt;/param&gt;
       public void StoreVectorData(string id, float[] vector)
       {
           // 构造键名
           var key = $"{_freefix}:{id}";
           VectorDom dom = new VectorDom
           {
               id = id,
               vector = vector
           };
           byte[] vectorBinary = vector.SelectMany(f =&gt; BitConverter.GetBytes(f)).ToArray();
           _db.HashSet(key, "id", dom.id);
           _db.HashSet(key, "vector", vectorBinary);
       }
       /// &lt;summary&gt;
       /// 向量搜索
       /// &lt;/summary&gt;
       /// &lt;param name="queryVector"&gt;&lt;/param&gt;
       /// &lt;param name="topK"&gt;&lt;/param&gt;
       public List&lt;string&gt; SearchSimilarVectors(float[] queryVector, int topK = 50)
       {
           byte[] vectorQueryBinary = queryVector.SelectMany(f =&gt; BitConverter.GetBytes(f)).ToArray();
           //十六进制字符串
           //string vectorQueryBinaryStr = BitConverter.ToString(vectorQueryBinary).Replace("-", "");
           Query q = new Query($"*=&gt;[KNN {topK} @vector $vec as score]");
           q.SortBy = "score";
           q.AddParam("vec", vectorQueryBinary);
           q.ReturnFields("id", "vector");
           q.Limit(0, topK);
           q.Dialect(2);
           var obj = ft.Search(_indexName, q);
           var docList = obj.Documents;
           var list = new List&lt;string&gt;(); 
           foreach (var doc in docList)
           {
               list.Add(doc["id"]);
           }
           return list;
       } 
   }
   public class VectorDom
   {
       public string id { get; set; }
       public float[] vector { get; set; }
   }
</code></pre>
</details>
<h4 id="221-使用查询向量在-redis-中搜索">2.2.1 使用查询向量在 Redis 中搜索</h4>
<details>
    <summary>RedisVector核心操作类</summary> 
<pre><code class="language-csharp"> var searchVector = await GetFlagEmbedding(keyword);
 if (searchVector != null)
 {
     var queryVector = Array.ConvertAll(searchVector, x =&gt; (float)x);
     var temp = bykcsjRVHelp.SearchSimilarVectors(queryVector, 30);
     foreach (var id in temp)
     {
         if (!ids.Contains(id))
         {
             ids.Add(id);
         }
     }
 }
</code></pre>
</details>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="5.014215383459491" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 11:59">2025-02-28 11:10</span>&nbsp;
<a href="https://www.cnblogs.com/rmb0591">xiecb</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18742824" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18742824);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18742824', targetLink: 'https://www.cnblogs.com/rmb0591/p/18742824', title: '机械图纸文章标题搜索增强实现过程' })">举报</a>
</div>
        