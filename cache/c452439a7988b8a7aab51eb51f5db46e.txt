<!----> <meta itemprop="headline" content="面试被问到如何一次性渲染十万条数据，我该怎么答？"> <meta itemprop="keywords" content="前端,面试,性能优化"> <meta itemprop="datePublished" content="2024-10-02T02:48:03.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="今天一定晴q"> <meta itemprop="url" content="https://juejin.cn/user/130163910913867"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            面试被问到如何一次性渲染十万条数据，我该怎么答？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/130163910913867/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    今天一定晴q
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-02T02:48:03.000Z" title="Wed Oct 02 2024 02:48:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-02
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    11,292
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">引言</h2>
<p>在前端开发中，性能优化是一个永恒的话题。我们经常需要处理和展示大量的数据，所以当面试官问到：“如何一次性渲染十万条数据而不影响用户体验？”你会怎么回答？直接渲染十万条数据可能会导致页面卡顿、响应迟缓，甚至浏览器崩溃。本篇文章详细介绍时间分片和虚拟列表的解决方案，帮助你轻松拿下面试~</p>
<h2 data-id="heading-1">前置知识</h2>
<p>js是单线程的，会有一个同步和异步的概念，为了确保主线程不会被长时间阻塞，js引擎就会依照<strong>事件循环机制</strong>来执行代码：</p>
<ol>
<li>先执行同步代码（也属于是宏任务）</li>
<li>同步执行完毕后，检查是否有异步代码需要执行</li>
<li>执行所有的微任务</li>
<li>微任务执行完毕后，若有需要就会渲染页面</li>
<li>执行宏任务（也就是下一次事件循环开始）</li>
</ol>
<ul>
<li><em>微任务</em>：Promise.then()、process.nextTick()、async/await、MutationObserver()等</li>
<li><em>宏任务</em>：script(开启一整份代码的执行)、setTimeout、setInterval、setImmediate、I/O操作、UI-Rendering、同步代码等</li>
</ul>
<h2 data-id="heading-2">时间分片</h2>
<p>v8引擎执行 js 代码速度很快，然而渲染页面时间相对来说要长很多。如果直接将十万条数据给到渲染引擎，很容易造成页面卡顿或白屏，所以一次性渲染十万条数据的关键在于——要让浏览器的渲染线程尽量均匀流畅地将数据渲染上去。</p>
<p>时间分片的核心思想是将一个大的任务分解成多个小的任务，使用&nbsp;&nbsp;<code>setTimeout</code>或<code>requestAnimationFrame</code>&nbsp;分批次地渲染一部分数据。</p>
<h3 data-id="heading-3">使用 setTimeout</h3>
<ol>
<li><strong>初始化</strong>：定义总数据条数&nbsp;<code>total</code>、每次渲染的数据条数&nbsp;<code>once</code>、需要渲染的总次数&nbsp;<code>page</code>&nbsp;和当前渲染的索引&nbsp;<code>index</code>。</li>
<li><strong>递归渲染</strong>：<code>loop</code>&nbsp;函数通过递归调用来逐步渲染数据。每次for循环渲染&nbsp;<code>once</code>&nbsp;条数据，并使用&nbsp;<code>setTimeout</code>&nbsp;将渲染操作放入下一个事件循环中。</li>
<li><strong>定时器</strong>：<code>setTimeout</code>&nbsp;确保每次渲染操作不会阻塞主线程，从而保持页面的流畅性和响应性。</li>
<li><strong>结束条件</strong>：当所有数据都渲染完毕后（即&nbsp;<code>curTotal - pageCount &lt;= 0</code>），递归调用停止。</li>
</ol>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    
        <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'container'</span>);
        
        <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>        <span class="hljs-comment">// 总数据条数</span>
        <span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span>               <span class="hljs-comment">// 每次渲染条数</span>
        <span class="hljs-keyword">let</span> page = total / once     <span class="hljs-comment">// 需要渲染的总次数</span>
        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>               <span class="hljs-comment">// 每条记录的索引，防止数据丢失或没有渲染到最后一条</span>

        <span class="hljs-comment">// 两个参数：剩余需要渲染的数据条数，当前渲染的索引</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">curTotal, curIndex</span>) {  
            <span class="hljs-keyword">let</span> pageCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(once, curTotal)

            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++) {
                    <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>);
                    li.<span class="hljs-property">innerText</span> = curIndex + i + <span class="hljs-string">':'</span> + ~~(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total); 
                    ul.<span class="hljs-title function_">appendChild</span>(li);
                }
                <span class="hljs-title function_">loop</span>(curTotal - pageCount, curIndex + pageCount)
            })
        }
        
        <span class="hljs-title function_">loop</span>(total, index)

    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>不让v8一次事件循环就把js部分执行掉，浏览器一次性暴力渲染十万条，而是让v8执行五千次事件循环，浏览器每次只渲染二十条。这样v8分摊了浏览器渲染线程的压力，能减少页面加载时间</p>
<h3 data-id="heading-4">requestAnimationFrame + document.createDocumentFragment()</h3>
<p>使用 <code>setTimeout</code> 将渲染操作放入下一个事件循环会有个小问题：假设浏览器页面刷新时间为 16.7ms，如果v8引擎的性能不够高，进行完一次事件循环的时间比 16.7ms 要长，那么浏览器在 16.7ms 内渲染完了 20 条数据，而 v8引擎还没将下一个20条数据给出来，这样就很可能会造成页面的闪屏或卡顿。</p>
<p>要解决定时器带来的事件循环与屏幕刷新不同步的问题，我们可以用 <code>requestAnimationFrame()</code> 取代 <code>setTimeout()</code>。</p>
<p>在此基础上，我们需要尽量人为地减少回流重绘次数。如果每一次for循环都渲染一条数据，那这样高频地操作DOM会浪费开销影响性能。</p>
<p>所以，我们可以使用文档碎片 <code>document.createDocumentFragment()</code>——一个虚拟的DOM， 来批量插入 <code>li</code> 元素。使得生成好一条数据后，先不要往 ul 里面添加，固定每20个li只回流一次</p>
<pre><code class="hljs language-ini" lang="ini">&lt;body&gt;
    &lt;ul <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;&lt;/ul&gt;

    &lt;script&gt;
        let <span class="hljs-attr">ul</span> = document.getElementById(<span class="hljs-string">'container'</span>)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">total</span> = <span class="hljs-number">100000</span>
        let <span class="hljs-attr">once</span> = <span class="hljs-number">20</span>
        let <span class="hljs-attr">page</span> = total / <span class="hljs-literal">on</span>ce  
        let <span class="hljs-attr">index</span> = <span class="hljs-number">0</span>  

        function loop(curTotal, curIndex) {  
            let <span class="hljs-attr">pageCount</span> = Math.min(<span class="hljs-literal">on</span>ce, curTotal)

            requestAnimationFrame(() =&gt; {
                // 创建一个文档碎片，是一个虚拟的DOM结构
                let <span class="hljs-attr">fragment</span> = document.createDocumentFragment()<span class="hljs-comment">;</span>

                for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; pageCount; i++) {</span>
                    let <span class="hljs-attr">li</span> = document.createElement(<span class="hljs-string">'li'</span>)<span class="hljs-comment">;</span>
                    <span class="hljs-attr">li.innerText</span> = curIndex + i + <span class="hljs-string">':'</span> + ~~(Math.random() * total)<span class="hljs-comment">; </span>
                    
                    fragment.appendChild(li)<span class="hljs-comment">;</span>
                }
                
                // 固定每20个li只回流一次
                ul.appendChild(fragment)<span class="hljs-comment">;</span>

                loop(curTotal - pageCount, curIndex + pageCount)
            })
        }
        loop(total, index)
        
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 data-id="heading-5">虚拟列表</h2>
<p>虚拟列表技术通过<strong>只渲染当前可见区域的数据</strong>来提高性能，而不是一次性渲染所有数据。这样可以显著减少 DOM 元素的数量，从而提高页面的加载速度和滚动流畅性。</p>
<h3 data-id="heading-6">核心思想</h3>
<ol>
<li><strong>初始化容器和数据</strong>：创建固定高度的容器，准备数据源。</li>
<li><strong>计算可视区域</strong>：获取容器高度，计算每个项的高度和可视区域的数据条数。</li>
<li><strong>渲染初始可见区域</strong>：计算起始和结束索引，渲染初始数据。</li>
<li><strong>监听滚动事件</strong>：绑定滚动事件，计算新的起始和结束索引，更新渲染数据。</li>
<li><strong>调整样式</strong>：计算偏移量，处理实际列表跟随父容器一起移动的情况</li>
</ol>
<p>接下来用 vue 技术栈展示虚拟列表实现步骤：</p>
<h3 data-id="heading-7">根组件 App.vue 中：</h3>
<ul>
<li>定义数据源 <code>data</code>，里面存放一千个对象，每个对象包含&nbsp;<code>id</code>&nbsp;和&nbsp;<code>value</code>&nbsp;属性</li>
<li>引入自定义的&nbsp;<code>virtualList</code>&nbsp;组件，并通过&nbsp;<code>:listData</code>&nbsp;属性将&nbsp;<code>data</code>&nbsp;传递给它</li>
<li>设置&nbsp;<code>.app</code>&nbsp;类的样式，使其具有固定的宽度和高度，并添加边框以区分容器区域</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">virtualList</span> <span class="hljs-attr">:listData</span>=<span class="hljs-string">"data"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> virtualList <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/virtualList.vue'</span>;

<span class="hljs-comment">// 数据源</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>([])

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  data.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>({<span class="hljs-attr">id</span>: i, <span class="hljs-attr">value</span>: i})
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"css"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.app</span>{
  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">自定义 virtualList&nbsp;组件中：</h3>
<p>模板部分——</p>
<ul>
<li>根元素<code>infinite-list-container</code>：绑定了&nbsp;<em>ref</em>&nbsp;为&nbsp;<em>listRef</em>，用于后续获取 DOM 元素，并且绑定滚动事件处理器&nbsp;<em>scrollEvent</em></li>
<li>虚拟占位元素<code>infinite-list-phantom</code>：用于撑开父容器的高度，确保可以滚动。其高度由&nbsp;<em>listHeight</em>&nbsp;计算得出</li>
<li>实际列表元素<code>infinite-list</code>：使用&nbsp;<em>transform</em>&nbsp;属性来控制列表的位置</li>
<li>列表项元素<code>infinite-list-item</code>：通过&nbsp;v-for&nbsp;循环渲染 <em>visibleData</em> &nbsp;中的数据项。每个项的高度和行高由&nbsp;<em>itemSize</em>&nbsp;控制</li>
</ul>

<pre><code class="hljs language-ruby" lang="ruby">&lt;template&gt;
    &lt;div ref=<span class="hljs-string">"listRef"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"infinite-list-container"</span> <span class="hljs-variable">@scroll</span>=<span class="hljs-string">"scrollEvent()"</span>&gt;
       
        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"infinite-list-phantom"</span> <span class="hljs-symbol">:style=<span class="hljs-string">"{height: listHeight + 'px'}"</span>&gt;&lt;/div&gt;</span>

        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"infinite-list"</span> <span class="hljs-symbol">:style=<span class="hljs-string">"{transform: getTransform}"</span>&gt;</span>
            &lt;div 
                <span class="hljs-keyword">class</span>=<span class="hljs-string">"infinite-list-item"</span> 
                v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in visibleData"</span> 
                <span class="hljs-symbol">:key=<span class="hljs-string">"item.id"</span></span>
                <span class="hljs-symbol">:style=<span class="hljs-string">"{height: itemSize + 'px', lineHeight: itemSize + 'px'}"</span></span>
            &gt;
                {{ item.value }}
            &lt;<span class="hljs-regexp">/div&gt;
        &lt;/div</span>&gt;
    &lt;<span class="hljs-regexp">/div&gt;
&lt;/template</span>&gt;
</code></pre>
<p>脚本及样式部分——</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { onMounted, reactive, ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
    <span class="hljs-attr">listData</span>: [],
    <span class="hljs-comment">// 每个item的高度</span>
    <span class="hljs-attr">itemSize</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-number">50</span>
    }
})

<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
    <span class="hljs-attr">screenHeight</span>: <span class="hljs-number">0</span>,   <span class="hljs-comment">// 可视区域的高度</span>
    <span class="hljs-attr">startOffset</span>: <span class="hljs-number">0</span>,    <span class="hljs-comment">// 偏移量</span>
    <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,          <span class="hljs-comment">// 起始数据下标</span>
    <span class="hljs-attr">end</span>: <span class="hljs-number">0</span>             <span class="hljs-comment">// 结束数据下标</span>
})

<span class="hljs-comment">// 可视区域显示的数据条数</span>
<span class="hljs-keyword">const</span> visibleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> state.<span class="hljs-property">screenHeight</span> / props.<span class="hljs-property">itemSize</span>
})

<span class="hljs-comment">// 可视区域显示的真实数据</span>
<span class="hljs-keyword">const</span> visibleData = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> { 
    <span class="hljs-keyword">return</span> props.<span class="hljs-property">listData</span>.<span class="hljs-title function_">slice</span>(state.<span class="hljs-property">start</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(props.<span class="hljs-property">listData</span>.<span class="hljs-property">length</span>, state.<span class="hljs-property">end</span>))
})

<span class="hljs-comment">// 当前列表总高度</span>
<span class="hljs-keyword">const</span> listHeight = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> props.<span class="hljs-property">listData</span>.<span class="hljs-property">length</span> * props.<span class="hljs-property">itemSize</span>
})

<span class="hljs-comment">// list跟着父容器移动了，现在列表要移回来</span>
<span class="hljs-keyword">const</span> getTransform = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`translateY(<span class="hljs-subst">${state.startOffset}</span>px)`</span>
})


<span class="hljs-comment">// 获取可视区域的高度</span>
<span class="hljs-keyword">const</span> listRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
    state.<span class="hljs-property">screenHeight</span> = listRef.<span class="hljs-property">value</span>.<span class="hljs-property">clientHeight</span>
    state.<span class="hljs-property">end</span> = state.<span class="hljs-property">start</span> + visibleCount.<span class="hljs-property">value</span>
})


<span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollEvent</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">let</span> scrollTop = listRef.<span class="hljs-property">value</span>.<span class="hljs-property">scrollTop</span>
    state.<span class="hljs-property">start</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / props.<span class="hljs-property">itemSize</span>)
    state.<span class="hljs-property">end</span> = state.<span class="hljs-property">start</span> + visibleCount.<span class="hljs-property">value</span>
    state.<span class="hljs-property">startOffset</span> = scrollTop - (scrollTop % props.<span class="hljs-property">itemSize</span>)
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"css"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.infinite-list-container</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">overflow</span>: auto;
    <span class="hljs-attribute">position</span>: relative;
    -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch; <span class="hljs-comment">/* 启用触摸滚动 */</span>
}
<span class="hljs-selector-class">.infinite-list-phantom</span>{
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;    <span class="hljs-comment">/* 置于背景层 **/</span>
}
<span class="hljs-selector-class">.infinite-list</span>{
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">text-align</span>: center;
}
<span class="hljs-selector-class">.infinite-list-item</span> {
    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span>, solid, <span class="hljs-number">#000</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>效果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65a6171d25c343069e0b285cf0518a32~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LuK5aSp5LiA5a6a5pm0cQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735107439&amp;x-signature=zwdgsy%2FXWtfpxK%2Bod0JXVPeziSE%3D" alt="ezgif-7-76e7928919.gif" loading="lazy"></p>
<h2 data-id="heading-9">总结</h2>
<ul>
<li><strong>时间分片</strong>：
<ul>
<li>根据事件循环机制，每一次事件循环都会先进行页面渲染，再执行宏任务。</li>
<li>所以可以使用 <code>setTimeout</code> 或 <code>requestAnimationFrame</code>&nbsp;定时器将生成数据的js线程操作和渲染数据的渲染线程操作隔离到两次事件循环中，这样浏览器就能分批次地渲染一部分数据。</li>
<li>再配合文档碎片 <code>document.createDocumentFragment()</code>减少回流次数，提高性能</li>
</ul>
</li>
<li><strong>虚拟列表</strong>：
<ul>
<li>拿到所有数据，计算出所有数据应有列表高度；</li>
<li>获取可视区域的高度，计算出可视区域中能渲染的数据条数</li>
<li>在实时滚动时计算要渲染的数据起始和截止下标，仅渲染那些在当前视口中的数据项</li>
<li>计算偏移量，调整样式</li>
</ul>
</li>
</ul>
<p>除了以上这两种方法，还可以采用懒加载、Web Workers等方法对渲染大量数据的操作进行优化，希望对你有所帮助。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77e4987fd3274d1f9ceba2d2a4618e2a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LuK5aSp5LiA5a6a5pm0cQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735107439&amp;x-signature=A3JDESJeP6u3bIjy4nlpJI%2FBRvs%3D" alt="撒花.gif" loading="lazy">
（都看到这了，点赞收藏一下再走吧~）</p></div></div>