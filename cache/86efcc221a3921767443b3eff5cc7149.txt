
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18991755" title="发布于 2025-07-18 16:54">
    <span role="heading" aria-level="2">面试官：如何实现大模型连续对话？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>所有的大模型本身是不进行信息存储的，也不提供连续对话功能，<strong>所以想要实现连续对话功能需要开发者自己写代码才能实现</strong>。那怎么才能实现大模型的连续对话功能呢？</p>
<p>大模型连续对话功能<strong>不同的框架实现也是不同的</strong>，以行业使用最多的 Java AI 框架 Spring AI 和 Spring AI Alibaba 为例，给大家演示一下它们连续对话是如何实现的。</p>
<h2 id="1springai连续对话实现">1.SpringAI连续对话实现</h2>
<p>Spring AI 以 MySQL 数据库为例，我们来实现一下它的连续对话功能。</p>
<blockquote>
<p>PS：我们只有先讲对话存储起来，才能实现连续对话功能，所以我们需要借助数据库存储来连续对话。</p>
</blockquote>
<h3 id="11-准备工作">1.1 准备工作</h3>
<p>1.创建表</p>
<pre><code class="language-plsql">CREATE TABLE chat_message (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  conversation_id VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL,
  context TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
</code></pre>
<p>2.添加数据库和 MyBatisPlus 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;
  &lt;version&gt;3.5.11&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.设置配置文件：</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/testdb?characterEncoding=utf8
    username: root
    password: 12345678
    driver-class-name: com.mysql.cj.jdbc.Driver
# 配置打印 MyBatis 执行的 SQL
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# 配置打印 MyBatis 执行的 SQL
logging:
  level:
    com:
      ai:
        deepseek: debug
</code></pre>
<p>4.编写实体类</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;
import java.util.Date;

@Getter
@Setter
@TableName("chat_message")
public class ChatMessageDO implements Serializable {

    private static final long serialVersionUID = 1L;

    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    private String conversationId;

    private String role;

    private String context;

    private Date createdAt;
}
</code></pre>
<p>5.编写 Mapper：</p>
<pre><code class="language-java">import com.ai.chat.entity.ChatMessageDO;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ChatMessageMapper extends BaseMapper&lt;ChatMessageDO&gt; {
}
</code></pre>
<h3 id="12-自定义chatmemory类">1.2 自定义ChatMemory类</h3>
<p>自定义的 ChatMemory 实现类，将对话记录存储到 MySQL：</p>
<pre><code class="language-java">import com.ai.deepseek.entity.ChatMessageDO;
import com.ai.deepseek.mapper.ChatMessageMapper;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class MySQLChatMemory implements ChatMemory {
    @Autowired
    private ChatMessageMapper repository;

    @Override
    public void add(String conversationId, Message message) {
        ChatMessageDO entity = new ChatMessageDO();
        entity.setConversationId(conversationId);
        entity.setRole(message.getMessageType().name());
        entity.setContext(message.getText());
        repository.insert(entity);
    }

    @Override
    public void add(String conversationId, List&lt;Message&gt; messages) {
        messages.forEach(message -&gt; add(conversationId, message));
    }

    @Override
    public List&lt;Message&gt; get(String conversationId, int lastN) {
        LambdaQueryWrapper&lt;ChatMessageDO&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(ChatMessageDO::getConversationId, conversationId);
        // queryWrapper.orderByDesc(ChatMessageDO::getId);
        return repository.selectList(queryWrapper)
        .stream()
        .limit(lastN)
        .map(e -&gt; new UserMessage(e.getContext()))
        .collect(Collectors.toList());
    }

    @Override
    public void clear(String conversationId) {
        LambdaQueryWrapper&lt;ChatMessageDO&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(ChatMessageDO::getConversationId, conversationId);
        repository.delete(queryWrapper);
    }
}
</code></pre>
<h3 id="13-代码调用">1.3 代码调用</h3>
<p>编写代码测试历史对话保存到 MySQL 的功能：</p>
<pre><code class="language-java">import com.ai.deepseek.component.MySQLChatMemory;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/multi")
public class MultiChatController {

    @Autowired
    private ChatClient chatClient;
    @Autowired
    private MySQLChatMemory chatMemory;

    @RequestMapping("/chat")
    public Flux&lt;String&gt; chat(@RequestParam("msg") String msg,
                             @RequestParam(defaultValue = "default") String sessionId) {
        // 添加MessageChatMemoryAdvisor，自动管理上下文
        MessageChatMemoryAdvisor advisor =
        new MessageChatMemoryAdvisor(chatMemory, sessionId, 10); // 保留最近5条历史
        return chatClient.prompt()
        .user(msg)
        .advisors(advisor) // 关键：注入记忆管理
        .stream()
        .content();
    }
}
</code></pre>
<p>以上程序执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202507/172074-20250718165423154-1137658848.jpg" alt="未命名__2025-07-18+16_45_29" loading="lazy"></p>
<h2 id="2springaialibaba实现连续对话">2.SpringAIAlibaba实现连续对话</h2>
<p>Spring AI Alibaba 连续对话的实现就简单很多了，因为它内置了 MySQL 和 Redis 的连续对话存储方式，接下来以 Redis 为例演示 SAA 的连续对话实现，它的实现步骤如下：</p>
<ol>
<li>添加依赖。</li>
<li>设置配置文件，配置 Redis 连接信息。</li>
<li>添加 Redis 配置类，注入 RedisChatMemoryRepository 对象。</li>
<li>配置 ChatClient 实现连续对话。</li>
</ol>
<p>具体实现如下。</p>
<h3 id="21-添加依赖">2.1 添加依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba.cloud.ai&lt;/groupId&gt;
  &lt;artifactId&gt;spring-ai-alibaba-starter-memory-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="22-设置配置文件">2.2 设置配置文件</h3>
<p>设置配置文件，配置 Redis 连接信息：</p>
<pre><code class="language-yaml">spring:
  ai:
    memory:
      redis:
        host: localhost
        port: 6379
        timeout: 5000
</code></pre>
<h3 id="23-添加redis配置类">2.3 添加Redis配置类</h3>
<p>添加 Redis 配置类，注入 RedisChatMemoryRepository 对象，实现 Redis 自定义存储器注入：</p>
<pre><code class="language-java">import com.alibaba.cloud.ai.memory.redis.RedisChatMemoryRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RedisMemoryConfig {

    @Value("${spring.ai.memory.redis.host}")
    private String redisHost;
    @Value("${spring.ai.memory.redis.port}")
    private int redisPort;
    //    @Value("${spring.ai.memory.redis.password}")
    //    private String redisPassword;
    @Value("${spring.ai.memory.redis.timeout}")
    private int redisTimeout;

    @Bean
    public RedisChatMemoryRepository redisChatMemoryRepository() {
        return RedisChatMemoryRepository.builder()
        .host(redisHost)
        .port(redisPort)
        // 若没有设置密码则注释该项
        //           .password(redisPassword)
        .timeout(redisTimeout)
        .build();
    }
}
</code></pre>
<h3 id="24-配置chatclient实现连续对话">2.4 配置ChatClient实现连续对话</h3>
<pre><code class="language-java">import com.alibaba.cloud.ai.memory.redis.RedisChatMemoryRepository;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import static org.springframework.ai.chat.memory.ChatMemory.CONVERSATION_ID;

@RestController
@RequestMapping("/redis")
public class RedisMemoryController {

    private final ChatClient chatClient;
    private final int MAXMESSAGES = 10;
    private final MessageWindowChatMemory messageWindowChatMemory;

    public RedisMemoryController(ChatModel dashscopeChatModel,
                                 RedisChatMemoryRepository redisChatMemoryRepository) {
        this.messageWindowChatMemory = MessageWindowChatMemory.builder()
        .chatMemoryRepository(redisChatMemoryRepository)
        .maxMessages(MAXMESSAGES)
        .build();

        this.chatClient = ChatClient.builder(dashscopeChatModel)
        .defaultAdvisors(
            MessageChatMemoryAdvisor.builder(messageWindowChatMemory)
            .build()
        )
        .build();
    }

    @GetMapping("/call")
    public String call(String msg, String cid) {
        return chatClient.prompt(msg)
        .advisors(
            a -&gt; a.param(CONVERSATION_ID, cid)
        )
        .call().content();
    }
}
</code></pre>
<h2 id="小结">小结</h2>
<p>通过以上代码大家也可以看出来，使用 Spring AI 实现连续对话是比较复杂的，需要自己实现数据库增删改查的代码，并且重写 ChatMemory 才能实现连续对话功能；而 Spring AI Alibaba 因为内置了连续对话的多种实现（Redis 和其他数据库），所以只需要简单配置就可以实现了。</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：场景题、SpringAI、SpringAIAlibaba、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列、AI常见面试题等。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-18 16:54">2025-07-18 16:54</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">194</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18991755);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18991755', targetLink: 'https://www.cnblogs.com/vipstone/p/18991755', title: '面试官：如何实现大模型连续对话？' })">举报</a>
</div>
        