
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Draina/p/18784550" title="发布于 2025-03-21 09:35">
    <span role="heading" aria-level="2">使用命令行工具控制wireshark对抓包文件进行针对性处理的总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        近日，工作中有开发对抓包文件进行针对性过滤的小工具的需求，兜兜转转踩了很多坑后还是绕回了wireshark。
作为最出名的开源软件之一，wireshark也具有使用命令行进行操作的功能，这就是我们今天会总结到的“tshark.exe”。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>近日，工作中有开发对抓包文件进行针对性过滤的小程序的需求，兜兜转转踩了很多坑后还是绕回了wireshark。</p>
<p>作为最出名的开源软件之一，wireshark也具有使用命令行进行操作的功能，这就是我们今天会总结到的“tshark.exe”。</p>
<p>通常，当你安装好wireshark，这个"tshark"就会和你的wireshark在同一路径下默默的躺着，就长这样：<br><img src="https://img2024.cnblogs.com/blog/3481847/202503/3481847-20250321090803543-1756867805.png" width="626" height="105"></p>
<p>这个程序和图形化的wireshark功能基本相同，接下来我会针对性地对使用该软件对已经完成抓包生成的抓包文件（.pacpng、.pacp）进行解析的功能命令进行总结。</p>
<h2>先上一个例子：</h2>
<p><code>D:\**你的路径**\tshark.exe -r "C:\**你的路径**\抓包数据.pcap" -Y esp -T fields -e esp.spi -e esp.sequence &nbsp;-e ip.src -e ip.dst</code></p>
<p>运行输出结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3481847/202503/3481847-20250321091145535-1823029507.png" width="795" height="89"></p>
<p>这个代码以tshark的绝对路径开头（配置环境变量会更方便），然后是抓包文件的路径指定文件，然后是各种过滤指令和字段选择，达到了针对某文件输出我们需要的字段的效果。</p>
<p>下面开始系统性介绍。</p>
<h3>1、读取抓包文件</h3>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-r</code> 读取已有的抓包文件：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs prismjs-lines-highlighted language-bash" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt;</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;infile&gt;</code> 是输入的抓包文件名。</div>
<h3>2. 过滤数据</h3>
<h4>2.1 显示过滤器</h4>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-Y</code> 选项指定显示过滤器，过滤解码数据或写入文件的包：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs language-bash prismjs-lines-highlighted" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt; -Y &lt;display filter&gt;</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;display filter&gt;</code> 是显示过滤器表达式，使用读/显示过滤器的语法，而不是捕获过滤器的语法。</div>
<h4>2.2 读取过滤器</h4>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-R</code> 选项指定读取过滤器，在分析的第一遍中应用，不匹配的包将不考虑后续遍历：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs language-bash prismjs-lines-highlighted" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt; -R &lt;read filter&gt;</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;read filter&gt;</code> 是读取过滤器表达式，同样使用读/显示过滤器的语法。</div>
<h3>3. 输出格式</h3>
<h4>3.1 输出格式类型</h4>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-T</code> 选项设置输出格式：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs language-bash prismjs-lines-highlighted" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt; -T &lt;format&gt;</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;format&gt;</code> 可以是以下之一：</div>
<ul>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">ek</code>：用于批量导入 Elasticsearch 的换行符分隔 JSON 格式。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">fields</code>：指定字段的值，格式由 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-E</code> 选项控制。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">json</code>：JSON 文件格式。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">jsonraw</code>：仅包含原始十六进制编码包数据的 JSON 文件格式。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">pdml</code>：XML 格式的包详情。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">ps</code>：PostScript 格式。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">psml</code>：XML 格式的包摘要。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">tabs</code>：类似于默认文本报告，但使用制表符分隔。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">text</code>：默认的人可读文本格式。</div>
</li>
</ul>
<h4>3.2 指定输出字段</h4>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-e</code> 选项添加要显示的字段，智能与 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-T ek|fields|json|pdml</code> 之一配合使用：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs language-bash prismjs-lines-highlighted" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt; -T fields -e &lt;field1&gt; -e &lt;field2&gt; ...</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;field1&gt;</code>, <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;field2&gt;</code> 等是要显示的字段。</div>
<h4>3.3 设置字段打印选项</h4>
<div class="paragraph">使用 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">-E</code> 选项控制字段打印格式：</div>
<div class="segment-code" data-v-a57c44a4="" data-v-758d6774="">
<div class="syntax-highlighter dark segment-code-content" data-v-b760b6bb="" data-v-a57c44a4="">
<pre class="highlighter-prismjs language-bash prismjs-lines-highlighted" data-v-b760b6bb=""><code>tshark -r &lt;infile&gt; -T fields -E &lt;option&gt;</code></pre>
</div>
</div>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">&lt;option&gt;</code> 可以是以下之一：</div>
<ul>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">bom=y|n</code>：是否添加 UTF-8 字节顺序标记，默认为 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">n</code>。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">header=y|n</code>：是否打印字段名作为输出的第一行，默认为 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">n</code>。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">separator=/t|/s|&lt;character&gt;</code>：设置字段分隔符，默认为制表符。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">occurrence=f|l|a</code>：选择字段的出现次数，默认为 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">a</code>。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">aggregator=,|/s|&lt;character&gt;</code>：设置字段聚合符，默认为逗号。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">quote=d|s|n</code>：设置字段的引用字符，默认为无。</div>
</li>
<li>
<div class="paragraph"><code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">escape=y|n</code>：是否对字段值中的空白控制字符进行转义，默认为 <code class="segment-code-inline" data-v-a57c44a4="" data-v-dbe669ce="">y</code>。</div>
</li>
</ul>
<p>&nbsp;</p>
<div class="paragraph">到这里我们就可以系统性地输出数据包中我们想要的值了！</div>
<div class="paragraph">这时候有小伙伴们要问了“博主博主，命令行我们明白了，但该怎么用到程序里呢？”</div>
<div class="paragraph">欸，我演示一个函数你就明白了，调用起来不要太轻松：</div>
<div class="paragraph">
<pre class="highlighter-prismjs language-python prismjs-lines-highlighted"><code>    def process_certificates(self, file_path, display_filter):
        command = [
            self.tshark_path,
            '-r', file_path,
            '-Y', f'tls.handshake.type==11&amp;&amp;{display_filter}',
            '-T', 'fields',
            '-e', 'ip.src',
            '-e', 'ip.dst',
            '-e', 'tls.handshake.certificate'
        ]
        lines = self.run_tshark_command(command)

        for line in lines:
            parts = line.split('\t')
            if len(parts) &lt; 3:
                continue
            src_ip, dst_ip, certs_hex = parts
            try:
                certs = certs_hex.split(',')
                for cert_hex in certs:
                    cert_der = bytes.fromhex(cert_hex)
                    self.process_single_cert(cert_der, src_ip, dst_ip)
            except ValueError:
                continue
                
    def run_tshark_command(self, command):
        try:
            result = subprocess.run(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
                text=True
            )
            return result.stdout.splitlines()</code></pre>
<p>通过调用上面的函数，我们就完成了对命令的拼接，对输出的读取。</p>
<p>经过进一步简单处理，我们就达到了筛选所有TLS握手过程中传递的证书的效果，还顺带得到了他们的源IP目的IP等信息。</p>
<p>最后经过同理的简单开发，可得到这样的效果<br><img src="https://img2024.cnblogs.com/blog/3481847/202503/3481847-20250321092929798-1252063741.png" width="760" height="381"></p>
<p>——END——</p>

</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5113849335868056" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 10:00">2025-03-21 09:35</span>&nbsp;
<a href="https://www.cnblogs.com/Draina">Draina</a>&nbsp;
阅读(<span id="post_view_count">173</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18784550" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18784550);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18784550', targetLink: 'https://www.cnblogs.com/Draina/p/18784550', title: '使用命令行工具控制wireshark对抓包文件进行针对性处理的总结' })">举报</a>
</div>
        