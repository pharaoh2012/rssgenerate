
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/strick/p/18965620" title="发布于 2025-07-16 11:01">
    <span role="heading" aria-level="2">Node.js躬行记（30）——SkyWalking使用和排查分析</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　公司使用了阿里云的服务，其中可以在项目中使用全链路监测，最近要排查慢响应，所以就在 Node 项目中接了一下 <span style="color: rgba(51, 102, 255, 1)"><a href="https://github.com/apache/skywalking-nodejs/tree/master" target="_blank" rel="noopener nofollow"><span style="color: rgba(51, 102, 255, 1)">SkyWalking</span></a></span>。</p>
<p>　　本文还会记录在使用时遇到的问题，以及解决思路。</p>
<h1>一、初始化</h1>
<p><span style="font-size: 16px"><strong>1）参数配置</strong></span></p>
<p>　　SkyWalking支持自动埋点和手动埋点，自动埋点只要初始化后，就可以开始工作，很便捷。</p>
<p>　　<img src="https://img2024.cnblogs.com/blog/211606/202507/211606-20250704143132289-1676716990.png" width="500"></p>
<p><span style="font-size: 16px"><strong>2）下载依赖</strong></span></p>
<p>　　下载 SkyWalking Node.js Agent</p>
<div class="cnblogs_code">
<pre>npm install --save skywalking-backend-js</pre>
</div>
<p><span style="font-size: 16px"><strong>3）初始化</strong></span></p>
<p>　　在项目的 app.js 中配置和启用 SkyWalking。</p>
<div class="cnblogs_code">
<pre>const {<span style="color: rgba(0, 0, 255, 1)">default</span>: agent} = require("skywalking-backend-js"<span style="color: rgba(0, 0, 0, 1)">);

agent.start({
    serviceName: </span>'web-api-pro'<span style="color: rgba(0, 0, 0, 1)">,
    collectorAddress: </span>'xxx'<span style="color: rgba(0, 0, 0, 1)">,       
    authorization: </span>'xxx'<span style="color: rgba(0, 0, 0, 1)">
});</span></pre>
</div>
<h1>二、分析</h1>
<p><span style="font-size: 16px"><strong>1）应用概览</strong></span></p>
<p>　　在应用列表，选择web-api进入后，就能看到如下的分析页面。</p>
<p>　　<img src="https://img2024.cnblogs.com/blog/211606/202507/211606-20250704143436615-1649764449.png" width="800"></p>
<p>　　SkyWalking默认会上报项目内的所有接口通信、MySQL查询、MongoDB查询等。</p>
<p>　　但这样会增加存储成本，所以我需要将不相关的接口过滤去除。</p>
<p><span style="font-size: 16px"><strong>2）过滤接口</strong></span></p>
<p>　　翻阅官方文档，发现有个参数有这个过滤作用，字符串类型，默认是空字符串。</p>
<table border="0">
<tbody>
<tr>
<td>SW_TRACE_IGNORE_PATH</td>
<td>The paths of endpoints that will be ignored (not traced), comma separated</td>
<td>``</td>
</tr>
</tbody>
</table>
<p>　　而跳转到源码中，也发现了对应的字段：traceIgnorePath。</p>
<div class="cnblogs_code">
<pre>export declare type AgentConfig =<span style="color: rgba(0, 0, 0, 1)"> {
    serviceName</span>?<span style="color: rgba(0, 0, 0, 1)">: string;
    collectorAddress</span>?<span style="color: rgba(0, 0, 0, 1)">: string;
    authorization</span>?<span style="color: rgba(0, 0, 0, 1)">: string;
    ignoreSuffix</span>?<span style="color: rgba(0, 0, 0, 1)">: string;
    traceIgnorePath</span>?<span style="color: rgba(0, 0, 0, 1)">: string;
    reIgnoreOperation</span>?<span style="color: rgba(0, 0, 0, 1)">: RegExp;
};</span></pre>
</div>
<p>　　在 deepseek 上提问，AI 给了我如何使用参数的示例，通配符的作用也详细的说明了。</p>
<div class="cnblogs_code">
<pre>traceIgnorePath: "/healthcheck/*,/static/**"</pre>
</div>
<p>　　但是，提交到测试环境后，并没有像预想的那样，将指定路径的接口过滤掉。</p>
<p>　　在将配置路径，翻来覆去的更改后，仍然不见效，遂去查看源码，在源码中的确包含 traceIgnorePath 参数。</p>
<p><span style="font-size: 16px"><strong>3）求助阿里云</strong></span></p>
<p>　　由于这是阿里云提供的可选类型，所以就去阿里云上创建工单。</p>
<p>　　<img src="https://img2024.cnblogs.com/blog/211606/202507/211606-20250704143821326-1022985531.png" alt=""></p>
<p>　　马上就自动创建了一个小群，与对方的人员语音沟通了下，并且共享了屏幕代码。</p>
<p>　　他表示需要花点时间，自己操作一下，在此期间，我自己也继续查看源码，最终发现了端倪。</p>
<p>　　阿里云的响应还是很快的，特别及时。</p>
<p><span style="font-size: 16px"><strong>4）源码分析</strong></span></p>
<p>　　在 node_modules 目录中的文件，也可以打印日志，我将传入的参数都打印了出来。</p>
<div class="cnblogs_code">
<pre>serviceName: 'web-api'<span style="color: rgba(0, 0, 0, 1)">,
serviceInstance: </span>'MacBook-Pro.local'<span style="color: rgba(0, 0, 0, 1)">,
collectorAddress: </span>'xxxx'<span style="color: rgba(0, 0, 0, 1)">,
authorization: </span>'xxxx'<span style="color: rgba(0, 0, 0, 1)">,
ignoreSuffix: </span>'.gif'<span style="color: rgba(0, 0, 0, 1)">,
traceIgnorePath: </span>'/audiostream/audit/callback'<span style="color: rgba(0, 0, 0, 1)">,
reIgnoreOperation: </span>/^.+(?:\.gif)$|^(?:\/audiostream\/audit\/callback)$/,</pre>
</div>
<p>　　看到 reIgnoreOperation 参数被赋值了，一段正则，这个很关键，过滤接口，其实就是匹配正则。</p>
<p>　　用 reIgnoreOperation 搜索，搜到了被使用的一段代码，operation 是一个传递进来的参数。</p>
<div class="cnblogs_code">
<pre>SpanContext.prototype.ignoreCheck = <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> (operation, type, carrier) {
 </span><span style="color: rgba(0, 0, 255, 1)">if</span> (operation.match(AgentConfig_1.<span style="color: rgba(0, 0, 255, 1)">default</span>.reIgnoreOperation) ||<span style="color: rgba(0, 0, 0, 1)"> 
    (carrier </span>&amp;&amp; !<span style="color: rgba(0, 0, 0, 1)">carrier.isValid()))
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> DummySpan_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">.create();
  </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> undefined;
};</span></pre>
</div>
<p>　　然后再用用 traceIgnorePath 去搜索代码，并没有得到有用的信息，于是将关键字改成 Ignore。</p>
<p>　　<img src="https://img2024.cnblogs.com/blog/211606/202507/211606-20250704144128710-1818654675.png" width="500"></p>
<p>　　果然找到了合适的代码，在 HttpPlugin.prototype.interceptServerRequest 方法中，找到一段创建 span 的代码。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> operation = reqMethod + ':' + (req.url || '/').replace(/\?.*/g, ''<span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> span =<span style="color: rgba(0, 0, 0, 1)"> AgentConfig_1.ignoreHttpMethodCheck(reqMethod)
   </span>? DummySpan_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">.create()
   : ContextManager_1.</span><span style="color: rgba(0, 0, 255, 1)">default</span>.current.newEntrySpan(operation, carrier);</pre>
</div>
<p>　　链路（即<span style="color: rgba(51, 102, 255, 1)"><a href="https://www.cnblogs.com/strick/p/18146195" target="_blank"><span style="color: rgba(51, 102, 255, 1)">链路追踪</span></a></span>）可深入了解请求路径、性能瓶颈和系统依赖关系，多个处理数据的片段（也叫 span，跨度）通过链路 ID 进行串联，组成一条链路追踪。</p>
<p>　　span 中有个三目运算，经过测试发现，如果没有配置要过滤的请求方法，那么就是 false。</p>
<p>　　所以会进入到 newEntrySpan() 方法中，而在此方法中，恰恰会调用 ignoreCheck() 方法。</p>
<p>　　那么其传入的 operation，其实就是要匹配的路径值，原来我配错了，官方需要带请求方法，如下所示。</p>
<div class="cnblogs_code">
<pre>traceIgnorePath: 'POST:/audiostream/audit/callback',</pre>
</div>
<p>　　不要过渡依赖 AI，我这次就非常相信 AI 给的示例，结果绕了大弯。</p>
<p><span style="font-size: 16px"><strong>5）运行原理</strong></span></p>
<p>　　在执行 start() 方法时，会进行参数合并，参数修改等操作。</p>
<div class="cnblogs_code">
<pre>Agent.prototype.start = <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> (options) {
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 传入参数和默认参数合并</span>
  Object.assign(AgentConfig_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">, options);
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 初始化参数，例如拼接正则等</span>
  AgentConfig_1.finalizeConfig(AgentConfig_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">);
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 挂载插件，就是注入链路代码</span>
  <span style="color: rgba(0, 0, 255, 1)">new</span> PluginInstaller_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">().install();
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 上报</span>
  <span style="color: rgba(0, 0, 255, 1)">this</span>.protocol = <span style="color: rgba(0, 0, 255, 1)">new</span> GrpcProtocol_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">().heartbeat().report();
  </span><span style="color: rgba(0, 0, 255, 1)">this</span>.started = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
};</span></pre>
</div>
<p>　　其中在 report() 中，会创建一个定时任务，每秒运行一次。</p>
<div class="cnblogs_code">
<pre>setTimeout(<span style="color: rgba(0, 0, 255, 1)">this</span>.reportFunction.bind(<span style="color: rgba(0, 0, 255, 1)">this</span>), 1000).unref();</pre>
</div>
<p>　　.unref() 告诉 Node.js 事件循环：“此定时器不重要，如果它是唯一剩余的任务，可以忽略它并退出进程”。</p>
<p>　　优化进程生命周期管理，避免无关任务阻塞退出。</p>
<p>　　最核心的插件有HttpPlugin、IORedisPlugin、MongoosePlugin、AxiosPlugin、MySQLPlugin 等。</p>
<p>　　以 HttpPlugin 为例，在 install() 时，会调用 interceptServerRequest() 方法注入链路操作。</p>
<div class="cnblogs_code">
<pre>HttpPlugin.prototype.install = <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> () {
  </span><span style="color: rgba(0, 0, 255, 1)">var</span> http = require('http'<span style="color: rgba(0, 0, 0, 1)">);
  </span><span style="color: rgba(0, 0, 255, 1)">this</span>.interceptServerRequest(http, 'http'<span style="color: rgba(0, 0, 0, 1)">);
};</span></pre>
</div>
<p>　　在 interceptServerRequest() 中，会修改 addListener()、on() 方法，并且会包装响应。</p>
<div class="cnblogs_code">
<pre>HttpPlugin.prototype.interceptServerRequest = <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> (module, protocol) {
  </span><span style="color: rgba(0, 0, 255, 1)">var</span> plugin = <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
  </span><span style="color: rgba(0, 0, 255, 1)">var</span> _addListener =<span style="color: rgba(0, 0, 0, 1)"> module.Server.prototype.addListener;
  module.Server.prototype.addListener </span>= module.Server.prototype.on = 
  <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> (event, handler) {
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> addArgs =<span style="color: rgba(0, 0, 0, 1)"> [];
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 复制参数</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> _i = 2; _i &lt; arguments.length; _i++<span style="color: rgba(0, 0, 0, 1)">) {
      addArgs[_i </span>- 2] =<span style="color: rgba(0, 0, 0, 1)"> arguments[_i];
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 执行事件</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _addListener.call.apply(
       _addListener, 
       tslib_1.__spreadArrays([</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, event, 
         event </span>=== 'request' 
         ?<span style="color: rgba(0, 0, 0, 1)"> _sw_request 
         : handler
       ], 
       addArgs)
    );
    </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> _sw_request(req, res) {
       </span><span style="color: rgba(0, 0, 255, 1)">var</span> _this = <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
       </span><span style="color: rgba(0, 0, 255, 1)">var</span><span style="color: rgba(0, 0, 0, 1)"> _a;
       </span><span style="color: rgba(0, 0, 255, 1)">var</span> reqArgs =<span style="color: rgba(0, 0, 0, 1)"> [];
       </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 复制参数</span>
       <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> _i = 2; _i &lt; arguments.length; _i++<span style="color: rgba(0, 0, 0, 1)">) {
         reqArgs[_i </span>- 2] =<span style="color: rgba(0, 0, 0, 1)"> arguments[_i];
       }
       </span><span style="color: rgba(0, 0, 255, 1)">var</span> carrier = ContextCarrier_1.ContextCarrier.from(req.headers ||<span style="color: rgba(0, 0, 0, 1)"> {});
       </span><span style="color: rgba(0, 0, 255, 1)">var</span> reqMethod = (_a = req.method) !== <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; _a !== <span style="color: rgba(0, 0, 255, 1)">void</span> 0 ? _a : 'GET'<span style="color: rgba(0, 0, 0, 1)">;
       </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 拼接请求方法和接口路径</span>
       <span style="color: rgba(0, 0, 255, 1)">var</span> operation = reqMethod + ':' + (req.url || '/').replace(/\?.*/g, ''<span style="color: rgba(0, 0, 0, 1)">);
       </span><span style="color: rgba(0, 0, 255, 1)">var</span> span =<span style="color: rgba(0, 0, 0, 1)"> AgentConfig_1.ignoreHttpMethodCheck(reqMethod)
           </span>? DummySpan_1.<span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">.create()
           : ContextManager_1.</span><span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">.current.newEntrySpan(operation, carrier);
       span.component </span>=<span style="color: rgba(0, 0, 0, 1)"> Component_1.Component.HTTP_SERVER;
       span.tag(Tag_1.</span><span style="color: rgba(0, 0, 255, 1)">default</span>.httpURL(protocol + '://' + (req.headers.host || '') +<span style="color: rgba(0, 0, 0, 1)"> req.url));
       </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 包装响应信息</span>
       <span style="color: rgba(0, 0, 255, 1)">return</span> plugin.wrapHttpResponse(span, req, res, <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> () { 
         </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> handler.call.apply(
            handler, 
            tslib_1.__spreadArrays([_this, req, res], reqArgs)
         ); 
       });
     }
   };
};</span></pre>
</div>
<p>　　不过在上线后，发生了意想不到的意外，就是原先可以链式调用的 Mongoose 的方法：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">this</span>.liveApplyRecord.find({ userId }).sort({ createTime: -1 });</pre>
</div>
<p>　　在调用时会出现报错：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">this</span>.liveApplyRecord.find(...).sort is not a <span style="color: rgba(0, 0, 255, 1)">function</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

	<div class="postDesc"><img src="/skins/gray/images/speech.gif" align="absmiddle">&nbsp;posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 11:02">2025-07-16 11:01</span>&nbsp;
<a href="https://www.cnblogs.com/strick">咖啡机（K.F.J）</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18965620);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18965620', targetLink: 'https://www.cnblogs.com/strick/p/18965620', title: 'Node.js躬行记（30）——SkyWalking使用和排查分析' })">举报</a>
</div>
