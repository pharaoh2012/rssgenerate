
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/damaoa/p/18932748" title="发布于 2025-06-17 11:56">
    <span role="heading" aria-level="2">Java并发利器：CountDownLatch深度解析与实战应用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="java并发利器countdownlatch深度解析与实战应用">Java并发利器：CountDownLatch深度解析与实战应用</h1>
<blockquote>
<p>多线程编程中，让主线程等待所有子任务完成是个常见需求。CountDownLatch就像一个倒计时器，当所有任务完成后，主线程才继续执行。本文将通过简单易懂的方式，带你掌握这个强大的并发工具。</p>
</blockquote>
<h2 id="一countdownlatch是什么">一、CountDownLatch是什么？</h2>
<h3 id="1-基本概念">1. 基本概念</h3>
<p>CountDownLatch就是一个"倒计数门闩"：</p>
<ul>
<li><strong>倒计数</strong>：从指定数字开始递减到0</li>
<li><strong>门闩</strong>：当计数为0时，门闩打开，等待的线程继续执行</li>
<li><strong>一次性</strong>：用完即弃，不能重置</li>
</ul>
<div class="mermaid">graph TD
    A[创建CountDownLatch 3] --&gt; B[启动3个任务]
    B --&gt; C[任务1完成 countDown]
    B --&gt; D[任务2完成 countDown]
    B --&gt; E[任务3完成 countDown]
    C --&gt; F{计数器=0?}
    D --&gt; F
    E --&gt; F
    F --&gt;|是| G[主线程继续执行]
    F --&gt;|否| H[继续等待]
</div><h3 id="2-基本用法">2. 基本用法</h3>
<pre><code class="language-java">public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建计数器，初始值为3
        CountDownLatch latch = new CountDownLatch(3);
      
        // 启动3个任务
        for (int i = 0; i &lt; 3; i++) {
            final int taskId = i;
            new Thread(() -&gt; {
                System.out.println("任务" + taskId + "开始执行");
                try {
                    Thread.sleep(2000); // 模拟任务执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("任务" + taskId + "执行完成");
                latch.countDown(); // 计数器减1
            }).start();
        }
      
        System.out.println("主线程等待所有任务完成...");
        latch.await(); // 等待计数器变为0
        System.out.println("所有任务完成，主线程继续执行");
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code>主线程等待所有任务完成...
任务0开始执行
任务1开始执行
任务2开始执行
任务0执行完成
任务1执行完成
任务2执行完成
所有任务完成，主线程继续执行
</code></pre>
<h2 id="二核心api介绍">二、核心API介绍</h2>
<p>CountDownLatch只有4个关键方法：</p>
<pre><code class="language-java">public class CountDownLatchAPI {
    public void demonstrateAPI() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
      
        // 1. countDown() - 计数器减1
        latch.countDown();
      
        // 2. await() - 等待计数器变为0
        latch.await();
      
        // 3. await(时间, 单位) - 超时等待
        boolean finished = latch.await(5, TimeUnit.SECONDS);
      
        // 4. getCount() - 获取当前计数值
        long count = latch.getCount();
        System.out.println("剩余计数: " + count);
    }
}
</code></pre>
<h2 id="三经典应用场景">三、经典应用场景</h2>
<h3 id="场景1等待多个任务完成">场景1：等待多个任务完成</h3>
<p>最常用的场景，主线程等待所有子任务完成：</p>
<pre><code class="language-java">public class WaitMultipleTasksDemo {
  
    // 模拟订单处理：需要等待库存检查、用户验证、支付验证都完成
    public void processOrder(String orderId) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
      
        // 库存检查
        new Thread(() -&gt; {
            try {
                System.out.println("开始库存检查...");
                Thread.sleep(1000);
                System.out.println("库存检查完成");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        }).start();
      
        // 用户验证
        new Thread(() -&gt; {
            try {
                System.out.println("开始用户验证...");
                Thread.sleep(1500);
                System.out.println("用户验证完成");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        }).start();
      
        // 支付验证
        new Thread(() -&gt; {
            try {
                System.out.println("开始支付验证...");
                Thread.sleep(800);
                System.out.println("支付验证完成");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        }).start();
      
        System.out.println("等待所有验证完成...");
        latch.await();
        System.out.println("订单处理完成: " + orderId);
    }
}
</code></pre>
<h3 id="场景2控制并发启动">场景2：控制并发启动</h3>
<p>让多个线程同时开始执行：</p>
<pre><code class="language-java">public class ConcurrentStartDemo {
  
    // 模拟赛跑：所有选手同时起跑
    public void startRace() throws InterruptedException {
        int runnerCount = 5;
        CountDownLatch startGun = new CountDownLatch(1); // 发令枪
        CountDownLatch finish = new CountDownLatch(runnerCount); // 终点线
      
        // 创建选手
        for (int i = 0; i &lt; runnerCount; i++) {
            final int runnerId = i;
            new Thread(() -&gt; {
                try {
                    System.out.println("选手" + runnerId + "准备就绪");
                    startGun.await(); // 等待发令枪
                  
                    // 开始跑步
                    System.out.println("选手" + runnerId + "开始跑步");
                    Thread.sleep(new Random().nextInt(3000)); // 模拟跑步时间
                    System.out.println("选手" + runnerId + "到达终点");
                  
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    finish.countDown();
                }
            }).start();
        }
      
        Thread.sleep(2000); // 等待选手准备
        System.out.println("预备...开始！");
        startGun.countDown(); // 发令
      
        finish.await(); // 等待所有选手完成
        System.out.println("比赛结束！");
    }
}
</code></pre>
<h3 id="场景3分段计算">场景3：分段计算</h3>
<p>将大任务拆分成小任务并行计算：</p>
<pre><code class="language-java">public class ParallelCalculationDemo {
  
    // 并行计算数组的和
    public long calculateSum(int[] array) throws InterruptedException {
        int threadCount = 4;
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicLong totalSum = new AtomicLong(0);
      
        int chunkSize = array.length / threadCount;
      
        for (int i = 0; i &lt; threadCount; i++) {
            final int start = i * chunkSize;
            final int end = (i == threadCount - 1) ? array.length : (i + 1) * chunkSize;
          
            new Thread(() -&gt; {
                long partialSum = 0;
                for (int j = start; j &lt; end; j++) {
                    partialSum += array[j];
                }
                totalSum.addAndGet(partialSum);
                System.out.println("线程计算范围[" + start + "," + end + ")，结果：" + partialSum);
                latch.countDown();
            }).start();
        }
      
        latch.await();
        return totalSum.get();
    }
  
    public static void main(String[] args) throws InterruptedException {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        ParallelCalculationDemo demo = new ParallelCalculationDemo();
        long result = demo.calculateSum(array);
        System.out.println("总和：" + result);
    }
}
</code></pre>
<h2 id="四使用注意事项">四、使用注意事项</h2>
<h3 id="1-异常处理要点">1. 异常处理要点</h3>
<p><strong>核心原则：无论是否异常，都要调用countDown()</strong></p>
<pre><code class="language-java">// ✅ 正确写法
new Thread(() -&gt; {
    try {
        // 业务逻辑
        doSomething();
    } catch (Exception e) {
        System.err.println("任务异常：" + e.getMessage());
    } finally {
        latch.countDown(); // 确保在finally中调用
    }
}).start();

// ❌ 错误写法
new Thread(() -&gt; {
    try {
        doSomething();
        latch.countDown(); // 异常时不会执行，导致死锁
    } catch (Exception e) {
        System.err.println("任务异常：" + e.getMessage());
        // 忘记调用countDown()
    }
}).start();
</code></pre>
<h3 id="2-避免无限等待">2. 避免无限等待</h3>
<pre><code class="language-java">// 设置超时时间，避免无限等待
boolean finished = latch.await(10, TimeUnit.SECONDS);
if (finished) {
    System.out.println("所有任务完成");
} else {
    System.out.println("等待超时，可能有任务失败");
}
</code></pre>
<h3 id="3-合理使用线程池">3. 合理使用线程池</h3>
<pre><code class="language-java">public void useWithThreadPool() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(5);
    ExecutorService executor = Executors.newFixedThreadPool(3);
  
    for (int i = 0; i &lt; 5; i++) {
        final int taskId = i;
        executor.submit(() -&gt; {
            try {
                System.out.println("执行任务" + taskId);
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        });
    }
  
    latch.await();
    executor.shutdown(); // 关闭线程池
    System.out.println("所有任务完成");
}
</code></pre>
<h2 id="五实际项目案例">五、实际项目案例</h2>
<h3 id="案例系统启动初始化">案例：系统启动初始化</h3>
<pre><code class="language-java">public class SystemInitializer {
  
    public boolean initializeSystem() {
        System.out.println("开始系统初始化...");
      
        CountDownLatch latch = new CountDownLatch(4);
        AtomicBoolean success = new AtomicBoolean(true);
      
        // 数据库初始化
        new Thread(() -&gt; {
            try {
                System.out.println("初始化数据库连接...");
                Thread.sleep(2000);
                System.out.println("数据库初始化完成");
            } catch (InterruptedException e) {
                success.set(false);
            } finally {
                latch.countDown();
            }
        }).start();
      
        // Redis初始化
        new Thread(() -&gt; {
            try {
                System.out.println("初始化Redis连接...");
                Thread.sleep(1000);
                System.out.println("Redis初始化完成");
            } catch (InterruptedException e) {
                success.set(false);
            } finally {
                latch.countDown();
            }
        }).start();
      
        // 配置加载
        new Thread(() -&gt; {
            try {
                System.out.println("加载系统配置...");
                Thread.sleep(800);
                System.out.println("配置加载完成");
            } catch (InterruptedException e) {
                success.set(false);
            } finally {
                latch.countDown();
            }
        }).start();
      
        // 服务注册
        new Thread(() -&gt; {
            try {
                System.out.println("注册服务...");
                Thread.sleep(1500);
                System.out.println("服务注册完成");
            } catch (InterruptedException e) {
                success.set(false);
            } finally {
                latch.countDown();
            }
        }).start();
      
        try {
            boolean finished = latch.await(10, TimeUnit.SECONDS);
            if (finished &amp;&amp; success.get()) {
                System.out.println("系统初始化成功！");
                return true;
            } else {
                System.out.println("系统初始化失败！");
                return false;
            }
        } catch (InterruptedException e) {
            System.out.println("初始化被中断");
            return false;
        }
    }
  
    public static void main(String[] args) {
        SystemInitializer initializer = new SystemInitializer();
        initializer.initializeSystem();
    }
}
</code></pre>
<h2 id="六总结">六、总结</h2>
<p>CountDownLatch是Java并发编程中的实用工具，它的核心价值在于：</p>
<h3 id="-核心特点">🎯 核心特点</h3>
<ul>
<li><strong>简单易用</strong>：API简洁，概念清晰</li>
<li><strong>线程安全</strong>：内部实现保证多线程安全</li>
<li><strong>灵活应用</strong>：适合多种并发协作场景</li>
</ul>
<h3 id="-使用要点">📝 使用要点</h3>
<ol>
<li><strong>异常安全</strong>：在finally中调用countDown()</li>
<li><strong>超时控制</strong>：使用带超时的await()方法</li>
<li><strong>一次性使用</strong>：CountDownLatch不能重置</li>
<li><strong>合理设计</strong>：根据实际任务数量设置计数器</li>
</ol>
<h3 id="-适用场景">🚀 适用场景</h3>
<ul>
<li>主线程等待多个子任务完成</li>
<li>控制多个线程同时开始执行</li>
<li>分段并行计算后汇总结果</li>
<li>系统启动时的组件初始化</li>
</ul>
<p>掌握CountDownLatch，让你的多线程程序更加优雅和高效！</p>
<hr>
<blockquote>
<p>觉得文章有用？欢迎关注我的微信公众号【一只划水的程序猿】，持续分享Java并发编程、性能优化等技术干货，一起在技术路上精进成长！</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-17 11:57">2025-06-17 11:56</span>&nbsp;
<a href="https://www.cnblogs.com/damaoa">大毛啊</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18932748);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18932748', targetLink: 'https://www.cnblogs.com/damaoa/p/18932748', title: 'Java并发利器：CountDownLatch深度解析与实战应用' })">举报</a>
</div>
        