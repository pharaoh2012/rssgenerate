
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Evsward/p/18771017/FedAvg" title="发布于 2025-03-13 21:13">
    <span role="heading" aria-level="2">联邦学习：去中心化数据下的深度网络优化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1233551/202503/1233551-20250313212322214-124955571.png" alt="联邦学习：去中心化数据下的深度网络优化" class="desc_img">
        本文分析《Communication-Efficient Learning of Deep Networks from Decentralized Data》，聚焦联邦学习在去中心化数据中的通信优化，探讨高效训练深度网络与数据隐私保护的方法。这不仅为AI与安全应用奠基，还为未来与区块链的融合提供潜力，建设去中心化的安全模型。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>摘要：本文分析《Communication-Efficient Learning of Deep Networks from Decentralized Data》，聚焦联邦学习在去中心化数据中的通信优化，探讨高效训练深度网络与数据隐私保护的方法。这不仅为AI与安全应用奠基，还为未来与区块链的融合提供潜力，建设去中心化的安全模型。</p>
<p>关键字：联邦学习，通信效率，去中心化数据，深度网络，AI，数据隐私，安全性，区块链</p>
</blockquote>
<h1 id="引言数据安全与去中心化挑战">引言：数据安全与去中心化挑战</h1>
<h2 id="区块链安全挑战">区块链安全挑战</h2>
<ul>
<li>Dexx安全事故，2024年11月16日，损失超2100万美元。事故原因是中心化私钥管理缺乏加密防护。</li>
<li>Bybit安全事故，2025年02月21日，损失约14.6亿美元，史上最大的加密盗窃案。事故原因是多签UI欺诈。</li>
<li>Infini安全事故，2025年02月24日，损失约5000万美元。事故原因是权限控制和未审计合约。</li>
</ul>
<h2 id="ai安全挑战">AI安全挑战</h2>
<blockquote>
<p>目前AI全赛道在快速发展阶段，AI安全作为潜在大课题即将伴随发生。目前可预估的安全事故类型包括：</p>
</blockquote>
<ul>
<li>
<p>AI模型投毒，在训练数据中注入恶意样本，导致模型输出错误预测，可导致金融类AI错误交易。</p>
</li>
<li>
<p>AI推理劫持，与传统网络攻击相似，通过API劫持篡改推理结果，甚至逆向工程窃取AI模型。</p>
</li>
<li>
<p>恶意AI代理，AI Agent被控制执行恶意操作。2025年AI Agent 激增，安全岌岌可危。</p>
</li>
</ul>
<blockquote>
<p>然而，除传统网络安全范畴以外，AI安全还包括AI伦理、自主性、数据主权、社会风险等。</p>
</blockquote>
<ul>
<li>智能驾驶事故责任如何划分，AI生成的虚假信息传播造成社会动荡谁来负责。</li>
<li>AI代理超预期行动，权限过高，导致行为越界，引发经济损失甚至危及物理世界安全。</li>
<li>AI训练数据的隐私问题，如泄露或被解密，会侵犯数据主权人权益。</li>
</ul>
<h1 id="安全视角下的联邦学习需求">安全视角下的联邦学习需求</h1>
<blockquote>
<p>一句话解释：联邦学习试图在海量个人设备以及语言、图像等富和种类数据下，通过去中心化本地执行计算、集成模型和接收更新，来解决用户个人数据隐私问题和数据集中处理能效问题。</p>
</blockquote>
<h2 id="去中心化">去中心化</h2>
<p>去中心化可同时解决用户个人数据隐私问题和数据集中处理能效问题。每台设备都是一个客户端，用户可以选择参与到这个松散自由的联盟组织，通过一个中心化服务器进行统一管理和调度。</p>
<p>每个客户端都有一个永不上传的本地数据集，成千上万个客户端与全局大模型将会有同步拉取、本地计算和更新推送三个动作，其中同步拉取和更新推送才会涉及到与中心化服务器通讯。解耦模型训练需求与直连原始数据。</p>
<blockquote>
<p>数据最小化原则，即收集和存储的数据应仅限于必要的部分。源自2012年消费者数据隐私白宫报告。</p>
</blockquote>
<h2 id="数据要求">数据要求</h2>
<ul>
<li>来自真实用户设备产生的数据要比数据中心的代理数据有明显优势。</li>
<li>这些数据属于隐私敏感型，或者数据量很大，出于模型训练的目的，勿将其记录到数据中心。</li>
<li>对于监督性任务，数据上的标签可从用户交互中自然地推断出来。</li>
</ul>
<h2 id="任务示例">任务示例</h2>
<p>（1）图像分类，预测哪些图片在未来最有可能被多次查看或分享。</p>
<p>（2）语言建模，改进语音识别、触屏键盘的文字输入、下一个词预测、预测整段回复。</p>
<p>这些任务的训练数据，明显需要大量用户隐私数据，包括用户持有的所有照片，以及他们通过手机键盘输入的所有文字，包括密码、网址、短信等等。</p>
<p>这些数据的分散性远大于容易获得的代理数据集。例如：</p>
<ul>
<li>通过标准网络语料库，Wikipedia、Baidu、Google等网络文档。</li>
<li>Flickr照片库。</li>
</ul>
<p>此外，用户交互的数据是自带标签的，这些标签是自然客观的定义，远比二手代理数据的标签更具多样性。</p>
<blockquote>
<p>以上解释了AI智能搜索与传统搜索（Baidu、Google）的区别，前者是通过大量自然数据标签进行预测，后者是二手代理数据标签进行索引。前者是可思考的智能大脑，后者是图书馆索引思维。</p>
</blockquote>
<p>这两个任务都非常适合神经网络学习。对于图像分类而言，前馈深度网络尤其是卷积网络可提供最先进的结果。对于语言建模任务的递归神经网络，尤其是LSTM（Long Short-Term Memory，长短时记忆网络）取得了最先进的成果。</p>
<h2 id="隐私保护">隐私保护</h2>
<h3 id="比数据中心优秀">比数据中心优秀</h3>
<ul>
<li>
<p>在传统的数据中心训练中，数据通常需要被收集和存储，而即使是“匿名化”的数据集，也可能会通过与其他数据的结合暴露用户的隐私。</p>
</li>
<li>
<p>联邦学习的信息是最小更新，仅包含改善特定模型所需的最少信息。由于这些信息只是模型参数的变化，而非直接的原始数据，因此他们本身不会比原始训练数据包含更多的隐私信息。</p>
</li>
<li>
<p>这种更新可以并且应该是短暂的，以确保信息最小化。同时，传输这些更新时不需要标识来源，因此可以通过混合网络（如Tor）或可信第三方传输，进一步增强隐私保护。</p>
</li>
</ul>
<h3 id="更新的隐私影响">更新的隐私影响</h3>
<ul>
<li>如果更新内容是所有本地数据的总梯度，而特征是稀疏的词袋模型，那么这些非零梯度可以暴露用户在设备上输入的具体单词。</li>
<li>对于更密集的模型（如卷积神经网络，CNN），梯度的总和更难成为攻击者获取单个训练实例信息的目标，但攻击仍然是可能的。</li>
</ul>
<blockquote>
<p>词袋模型是一种忽略词序、仅统计词频的文本向量化方法。</p>
<p>CNN通过卷积操作提取特征，再用池化和全连接层进行分类，尤其擅长处理图像。</p>
<p>梯度是模型参数的变化方向，非零梯度指这些变化中不为零的部分，可能泄露用户输入的具体词。</p>
<p>在词袋模型中，每个词对应一个特征位置，如果用户输入某个词，模型更新时只有这些词的梯度会变成非零，攻击者通过观察非零梯度就能推测出具体输入的词。</p>
</blockquote>
<h1 id="联邦优化通信效率的核心">联邦优化：通信效率的核心</h1>
<h2 id="1联邦优化的特质">1、联邦优化的特质：</h2>
<ul>
<li><strong>非IID（非独立同分布）</strong></li>
</ul>
<p>由于每个客户端的训练数据通常基于特定用户的设备使用，数据集通常不会代表整个群体的分布。</p>
<ul>
<li><strong>数据不平衡性</strong></li>
</ul>
<p>有些用户会比其他用户更频繁地使用服务或应用，从而导致本地训练数据量的差异。</p>
<ul>
<li><strong>大规模分布式</strong></li>
</ul>
<p>参与优化的客户端数量通常远远大于每个客户端的平均数据点数。</p>
<ul>
<li><strong>有限通信</strong></li>
</ul>
<p>移动设备经常处于离线状态，或者连接速度慢且通信费用高。</p>
<h2 id="2联邦优化的实践问题">2、联邦优化的实践问题</h2>
<ul>
<li><strong>客户端数据变化：</strong>随着数据的增删，客户端的数据集会发生变化。</li>
<li><strong>客户端的可用性：</strong>客户端的可用性与本地数据分布密切相关。例如，讲美式英语的手机和讲英式英语的手机可能会在不同时间连接。</li>
<li><strong>丢失或损坏的更新：</strong>有些客户端可能无法响应或发送损坏的更新。</li>
</ul>
<blockquote>
<p>为了应对这些问题，实验中使用了一个受控环境，专注于客户端的可用性以及不平衡和非IID数据的挑战。</p>
</blockquote>
<h2 id="3同步更新机制说明">3、同步更新机制说明</h2>
<p>我们假设一个同步更新机制，该机制以多轮通讯进行：</p>
<ol>
<li>设，共有一个固定的客户端结合K，每个均有自己的本地数据集。</li>
<li>每轮通讯的开始阶段，一个随机的少量的C个客户端会被选中，均会接收到来自服务端的当前全局算法状态（例如当前模型参数集合）。</li>
<li>为了效率，我们只选择少量客户端，因为我们的实验表明，当增加的客户端超过一定数量时，收益会递减。</li>
<li>每个被选中的客户端会基于全局状态和本地数据集立即执行本地运算，然后给服务端发送更新。</li>
<li>服务端会接收这些更新并合入全局状态 ，然后重复这个流程。</li>
</ol>
<h2 id="4非凸目标函数公式解析">4、非凸目标函数公式解析</h2>
<h3 id="有限和目标函数形式">①有限和目标函数形式</h3>
<p>尽管我们关注的是非凸神经网络目标（即损失函数或优化目标是非凸的），但是我们考虑的算法适用于任何具有以下形式的有限和目标函数：</p>
<blockquote>
<p>“非凸”指的是一个函数或集合不是凸的，意思是它没有一个唯一的最小点，可能有多个局部最小点或鞍点。简单来说，就是函数图像不呈现单一的“山谷”形状，可能有多个低谷。</p>
</blockquote>
<p>这是总目标函数的形式：</p>
<p></p><div class="math display">\[\min_{w \in \mathbb{R}^d} f(w)
\]</div><p></p><blockquote>
<p>这个公式表示要最小化一个目标函数 f(w)，其中 w 是优化参数向量，位于 \mathbb{R}^d 空间中，表示一个 d-维的参数空间。优化问题的目标是找到一个最优的 w，使得 f(w) 达到最小值。</p>
</blockquote>
<p>这是目标函数的定义：</p>
<p></p><div class="math display">\[f(w) = \frac{1}{n} \sum_{i=1}^n f_i(w)
\]</div><p></p><blockquote>
<p>这个公式定义了目标函数 f(w) 为多个子目标函数 f_i(w) 的平均值。具体来说，f_i(w) 是第 i 个子目标函数，通常代表一个数据点或任务的损失函数。这里，总目标函数是所有 f_i(w) 的平均值，因此优化问题变成了最小化这些子目标的平均损失。</p>
</blockquote>
<h3 id="机器学习中的损失函数">②机器学习中的损失函数</h3>
<p>在机器学习中，损失函数<code>f_i(w)</code>通常表示模型在给定输入 <code>x_i</code> 和真实标签 <code>y_i</code> 下的预测误差，记作</p>
<p></p><div class="math display">\[\ell(x_i, y_i; w)
\]</div><p></p><p>，其中 w 是模型的参数。</p>
<p>也就是说，对于每一个训练样本 <code>(x_i, y_i)</code>，我们计算损失函数 <code>f_i(w)</code>，它反映了模型在该样本上的预测误差。整个目标是通过优化这些损失函数的平均值 <code>f(w)</code> 来最小化模型的整体误差。</p>
<h3 id="客户端数据分布">③客户端数据分布</h3>
<p>在该算法中，假设数据集被分配到 K 个客户端上，客户端 k 上的数据集索引为 <code>P_k</code>，其中 <code>n_k = |P_k|</code> 是客户端 k 上的数据量。这样，我们可以将目标函数 f(w) 重写为：</p>
<p></p><div class="math display">\[f(w) = \sum_{k=1}^{K} \frac{n_k}{n} F_k(w)
\]</div><p></p><blockquote>
<p>表示全局目标函数 <code>f(w)</code> 是由每个客户端 k 的局部目标函数 <code>F_k(w)</code> 加权平均得到的，其中 <code>n_k</code> 是客户端 k 上的数据点数量，n 是总的数据点数量。</p>
</blockquote>
<p>其中 F_k(w) 表示客户端 k 上的局部目标函数，定义为：</p>
<p></p><div class="math display">\[F_k(w) = \frac{1}{n_k} \sum_{i \in P_k} f_i(w)
\]</div><p></p><p>换句话说，F_k(w) 是客户端 k 上的数据的损失函数的平均值。<strong><u>目标函数 f(w) 是这些局部目标函数的加权平均。</u></strong></p>
<blockquote>
<p>表示客户端 k 上的局部目标函数 F_k(w)，它是客户端 k 上所有数据点 i 的损失函数 f_i(w) 的平均值，其中 n_k 是客户端 k 上的数据点数量，P_k 是客户端 k 上数据点的索引集合。</p>
</blockquote>
<h3 id="iid假设">④IID假设</h3>
<blockquote>
<p><strong>IID</strong>（独立同分布）指的是数据中的每个样本既相互独立，又遵循相同的概率分布。</p>
</blockquote>
<p>接下来，假设数据 P_k 是通过将训练样本均匀随机地分配到各个客户端上形成的。在这种情况下，每个客户端上的局部目标函数 F_k(w) 的期望值应当与全局目标函数 f(w) 相等，即：</p>
<p></p><div class="math display">\[E_{P_k}[F_k(w)] = f(w)
\]</div><p></p><p>这里的期望是对分配给固定客户端 k 的数据进行计算的。换句话说，在IID（独立同分布）假设下，每个客户端上的数据分布是相同的，因此每个客户端计算的损失函数期望值与全局损失函数一致。</p>
<blockquote>
<p>表示当数据均匀随机地分配到各个客户端 k 时，客户端 k 上的局部目标函数 F_k(w) 的期望值等于全局目标函数 f(w)，即每个客户端的数据分布是独立同分布（IID）的情况下，局部目标函数的期望与全局目标函数相等。</p>
</blockquote>
<h3 id="非iid设置">⑤非IID设置</h3>
<p>然而，在实际的联邦学习设置中，数据往往不满足IID假设。也就是说，客户端上的数据分布可能不同，这会导致每个客户端上的局部目标函数 F_k(w) 与全局目标函数 f(w) 之间存在偏差。对于非IID的情况，我们称 F_k(w) 可能是对全局目标函数 f(w) 的一个非常不准确的近似。</p>
<blockquote>
<p>如果数据在客户端之间分布不均或存在偏差（即数据不再是IID的），那么每个客户端的局部目标函数可能与全局目标函数的关系会变得不那么精确。这种情况被称为<strong>非IID设置</strong>，它是联邦学习中必须考虑的一个重要因素。</p>
</blockquote>
<h2 id="5联邦优化的核心挑战">5、联邦优化的核心挑战</h2>
<ul>
<li><strong>通信成本的主导地位</strong></li>
</ul>
<p>在联邦学习中，通信成本成为了瓶颈，因为每个客户端的数据集相对于整个系统来说较小，并且每个客户端的带宽通常受限，上传速度可能低至1MB/s或更低。此外，客户端参与优化的条件较为严格，通常只有在电池充足、连接Wi-Fi且不计流量费用时才会参与。因此，通信的频繁交换增加了成本，并限制了优化的效率。</p>
<ul>
<li><strong>计算成本的相对优势</strong></li>
</ul>
<p>与数据中心环境不同，现代智能手机的计算能力较强（包括内置的GPU），并且计算的成本相对较低。因此，相比于通信，计算成本几乎可以忽略不计。这意味着，<strong>增加计算量比增加通信回合数更具优势。</strong></p>
<ul>
<li>
<p><strong>如何解决通信成本问题</strong></p>
<p>为了减少通信回合次数，从而提高训练效率，必须采取增加计算量的策略。具体来说，解决方案包括：</p>
<ul>
<li><strong>增加并行性</strong>：通过更多的客户端在每次通信回合之间独立工作，分担计算任务，从而加快训练速度。</li>
<li><strong>增加每个客户端的计算量</strong>：每个客户端在本地进行更复杂的计算，而不仅仅是简单的梯度计算。这可以通过让每个客户端处理更多的计算任务，减少需要进行的通信回合次数。</li>
</ul>
</li>
<li>
<p><strong>最终目标</strong></p>
</li>
</ul>
<p><strong>通过适当的计算量增加和并行化，减少联邦学习所需的通信轮次，从而提高整体优化效率，降低通信成本。</strong></p>
<h1 id="技术细节联邦平均算法fedavg">技术细节：联邦平均算法（FedAvg）</h1>
<blockquote>
<p>FederatedAveraging (FedAvg) 算法是一种用于联邦学习（Federated Learning, FL）的优化方法。它通过在多个客户端上进行本地训练，并在服务器端进行参数聚合，以提高计算效率并减少通信成本。</p>
</blockquote>
<h2 id="1背景">1、背景</h2>
<p>传统深度学习依赖 <strong>随机梯度下降（SGD）</strong>【<strong>全局性质</strong>】 进行优化，但在 <strong>联邦学习</strong> 场景下，数据是去中心化的，存储在不同的客户端上，不能直接访问所有数据进行全局优化。</p>
<p><strong>FedSGD（Federated SGD）</strong> 是一种直接在联邦学习环境中应用 SGD 的方法，但每轮训练都需要所有选定客户端上传梯度，通信开销较大。</p>
<p><strong>FedAvg</strong> 通过让客户端执行 <strong>多步本地梯度更新</strong> 再聚合，提高了计算效率，减少了通信轮数。</p>
<blockquote>
<p>SGD 通过每次随机挑选一个样本计算梯度（误差）并更新模型参数，来逐步逼近损失函数的最优解。</p>
</blockquote>
<h2 id="2算法思路">2、算法思路</h2>
<p>FedAvg 通过 <strong>三个关键参数</strong> 控制训练过程：</p>
<ol>
<li><strong>C</strong>：每轮选取的客户端比例（C-fraction）。</li>
<li><strong>E</strong>：每个客户端的本地训练 epoch 数，即每个客户端本地训练多少轮后才向服务器汇报参数。</li>
<li><strong>B</strong>：本地小批量（minibatch）大小。若 B=∞，则使用整个本地数据集进行训练。</li>
</ol>
<p>核心思想：</p>
<ul>
<li>选取 C% 的客户端。</li>
<li>在每个客户端上运行 <strong>E 轮本地 SGD 训练</strong>（即执行多个梯度下降步骤）。</li>
<li>客户端将本地模型参数返回给服务器，而不是梯度。</li>
<li>服务器执行 <strong>加权平均</strong>，合并客户端更新的模型。</li>
</ul>
<h2 id="3fedavg代码实现">3、FedAvg代码实现</h2>
<pre><code class="language-python">import random
import numpy as np

def compute_loss(model, data):
    """计算模型在给定数据上的损失值（这里使用简单的均方误差）"""
    # 假设数据的最后一列是标签
    X = data[:, :-1]
    y = data[:, -1]
    predictions = np.dot(X, model)
    loss = np.mean((predictions - y) ** 2)
    return loss

def initialize_model():
    """初始化全局模型参数"""
    return np.random.rand(9)  # 改为9维，因为最后一列是标签

def client_update(model, data, epochs, lr):
    """客户端本地训练"""
    losses = []
    for _ in range(epochs):
        gradient = compute_gradient(model, data)
        model -= lr * gradient
        loss = compute_loss(model, data)
        losses.append(loss)
    return model, np.mean(losses)

def compute_gradient(model, data):
    """计算梯度（使用均方误差的梯度）"""
    X = data[:, :-1]
    y = data[:, -1]
    predictions = np.dot(X, model)
    gradient = -2 * np.dot(X.T, (y - predictions)) / len(data)
    return gradient

def aggregate_models(client_models, num_samples):
    """聚合客户端模型参数（加权平均）"""
    total_samples = sum(num_samples)
    weights = [n / total_samples for n in num_samples]
    new_global_model = np.zeros_like(client_models[0])
    for model, weight in zip(client_models, weights):
        new_global_model += model * weight
    return new_global_model

def federated_training(num_rounds, num_clients, fraction, local_epochs, lr):
    """联邦训练过程"""
    global_model = initialize_model()
    # 生成模拟数据：每个客户端100条数据，每条数据9个特征和1个标签
    client_data = {
        i: np.concatenate([
            np.random.rand(100, 9),  # 特征
            np.random.rand(100, 1)   # 标签
        ], axis=1) 
        for i in range(num_clients)
    }
    
    global_losses = []
    
    for round in range(num_rounds):
        selected_clients = random.sample(range(num_clients), max(1, int(fraction * num_clients)))
        client_models = []
        client_losses = []
        num_samples = []
        
        for client in selected_clients:
            local_model = global_model.copy()
            updated_model, local_loss = client_update(local_model, client_data[client], local_epochs, lr)
            client_models.append(updated_model)
            client_losses.append(local_loss)
            num_samples.append(len(client_data[client]))
        
        # 计算这一轮的平均损失
        avg_loss = np.mean(client_losses)
        global_losses.append(avg_loss)
        
        global_model = aggregate_models(client_models, num_samples)
        print(f"Round {round+1}: Average Loss = {avg_loss:.6f}")
    
    print("\n训练完成！")
    print(f"初始损失值: {global_losses[0]:.6f}")
    print(f"最终损失值: {global_losses[-1]:.6f}")
    print(f"损失下降率: {((global_losses[0] - global_losses[-1]) / global_losses[0] * 100):.2f}%")
    
    return global_model, global_losses

# 运行联邦学习
final_model, losses = federated_training(num_rounds=10, num_clients=5, fraction=0.6, local_epochs=5, lr=0.1)
</code></pre>
<h2 id="4fedavg-vs-fedsgd">4、FedAvg VS. FedSGD</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>FedSGD (Federated SGD)</th>
<th>FedAvg (Federated Averaging)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>优化方式</strong></td>
<td>服务器端聚合单次梯度更新</td>
<td>服务器端聚合多轮本地训练后的模型</td>
</tr>
<tr>
<td><strong>计算频率</strong></td>
<td>每轮通信时，每个选中客户端计算一次梯度</td>
<td>每轮通信时，每个选中客户端进行多次本地训练</td>
</tr>
<tr>
<td><strong>通信开销</strong></td>
<td>高，每次迭代都需要通信</td>
<td>低，本地训练多轮后才通信</td>
</tr>
<tr>
<td><strong>客户端计算量</strong></td>
<td>低，每次只进行一个 mini-batch 的计算</td>
<td>高，每轮进行多个 epoch 的本地训练</td>
</tr>
<tr>
<td><strong>全局模型更新</strong></td>
<td>直接聚合所有客户端梯度更新</td>
<td>先在本地训练多次，再进行模型参数平均</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于高通信带宽、计算资源受限的设备</td>
<td>适用于计算能力较强、通信受限的场景</td>
</tr>
<tr>
<td><strong>收敛速度</strong></td>
<td>需要更多轮通信才能收敛</td>
<td>收敛更快，减少通信轮次</td>
</tr>
</tbody>
</table>
<h2 id="5关键优点">5、关键优点</h2>
<ul>
<li><strong>减少通信轮数：</strong>这是分布式用户设备的关键特性，FedAvg允许客户端执行多个本地更新，而不是每次迭代都发送梯度，从而减少通信开销。</li>
<li><strong>模型平均化：</strong>FedAvg直接对本地模型参数求均值，而不是梯度求和，在深度神经网络的优化上表现较好。</li>
<li><strong>避免不好的局部最优解：</strong>当所有客户端从相同的随机初始化开始训练时，FedAvg的参数平均化方式在某些场景下表现优于单个客户端训练模型。</li>
</ul>
<h1 id="训练剖析联邦学习实验分析">训练剖析：联邦学习实验分析</h1>
<blockquote>
<p>目标：通过选取适当规模的数据集，以便深入研究FedAvg的超参数，从而提高移动设备上的模型可用性，主要研究<strong>图像分类</strong>和<strong>语言建模</strong>任务。</p>
</blockquote>
<h2 id="实验设计">实验设计</h2>
<h3 id="1数据集和模型">1、数据集和模型</h3>
<ul>
<li><strong>MNIST（手写数字识别）</strong>
<ul>
<li><strong>2NN（双层全连接神经网络）：</strong>2层隐藏层，每层200个神经元，共199,210个参数。</li>
<li><strong>CNN（卷积神经网络）：</strong>两个5x5 卷积层（分别有32和64个通道），池化层，全连接层（512单元），Softmax输出层，总参数1,663,370。</li>
</ul>
</li>
<li><strong>CIFAR-10（图像分类）</strong>
<ul>
<li>论文这里未介绍实验细节，但后续分析会涉及该任务。</li>
</ul>
</li>
<li><strong>Shakespeare（语言建模）</strong>
<ul>
<li>构建数据集的方法：基于莎士比亚戏剧中的角色台词，每个角色至少有两行台词，被视为一个独立的客户端。</li>
<li>训练模型：<strong>字符级LSTM</strong>，使用8维字符嵌入，2层LSTM（256单元），最终输出层位Softmax，总参数866,578。</li>
</ul>
</li>
</ul>
<h3 id="2数据分布方式">2、数据分布方式</h3>
<ul>
<li><strong>IID（独立同分布）：</strong>数据随机分配个客户端，例如MNIST数据集分成100个客户端，每个客户端有600个样本。</li>
<li><strong>Non-IID（非独立同分布）：</strong>数据按类别排序，在分成200份，每个客户端仅获得2类数据的样本。这种情况下，单个客户端的样本类别较少，更具挑战性。</li>
</ul>
<h3 id="3实验变量">3、实验变量</h3>
<ul>
<li><strong>E（本地训练轮数）：</strong>每个客户端在本地训练的迭代次数。</li>
<li><strong>B（本地批量大小）：</strong>训练过程中，每次使用的样本量。</li>
<li><strong>C（客户端参与比例）：</strong>每轮训练时，参与更新的客户端比例。</li>
</ul>
<h2 id="实验结果">实验结果</h2>
<h3 id="1mnist实验">1、MNIST实验</h3>
<ul>
<li><strong>影响客户端参与比例（C）</strong>
<ul>
<li>C从0.0（每轮1个客户端）增加到1.0（所有100个客户端），通信轮数减少，训练加速。</li>
<li>非IID数据情况下，提高C对训练效率提升更明显，C=1.0时2NN的训练速度比C=0.0快<strong>8.6倍</strong>，CNN任务快<strong>9.9倍</strong>。</li>
</ul>
</li>
<li><strong>FedAvg VS. FedSGD</strong>
<ul>
<li>FedSGD 直接在所有客户端上进行梯度下降并平均，而FedAvg允许每个客户端进行多轮本地训练（E&gt;1），然后在汇总。</li>
</ul>
</li>
<li><strong>实验结果</strong>
<ul>
<li>MNIST（CNN，目标99%准确率）：FedAvg（E=5,B=10）训练20轮即达成目标，而FedSGD需要626轮（提升<strong>31.3倍</strong>）。</li>
<li>Shakespeare（LSTM，目标54%准确率）：FedAvg（E=5,B=10）训练41轮，而FedSGD需要3906轮（提升<strong>95.3倍</strong>）。</li>
</ul>
</li>
</ul>
<h3 id="2cifar-10实验">2、CIFAR-10实验</h3>
<ul>
<li><strong>数据集</strong>
<ul>
<li>CIFAR-10数据集包含50,000个训练样本和10,000个测试样本，每张图像大小为32x32像素，具有3个RGB通道。</li>
<li>实验中将数据集划分为100个客户端，每个客户端包含500个训练样本和100个测试样本。</li>
</ul>
</li>
<li><strong>模型架构</strong>
<ul>
<li>使用了一个从TensorFlow教程中获得的标准卷积神经网络模型，包括两个卷积层、两个全连接层和一个线性变换层，总共有大约106个参数。</li>
</ul>
</li>
<li><strong>训练</strong>
<ul>
<li>数据预处理包括裁剪图像为24x24，随机所有翻转，以及调整对比度、亮度和白化等。</li>
<li>采用了FedAvg与标准的FedSGD方法进行对比。<strong>FedAvg的表现远超FedSGD，显示其具有较好的通信效率。</strong></li>
</ul>
</li>
<li><strong>实验结果</strong>
<ul>
<li>标准SGD方法经过<strong>197,500次小批量更新后达到了86%的测试精度</strong>，而FedAvg方法仅通过<strong>2000次通信轮次就达到了85%的测试精度</strong>。</li>
<li>这个结果显示，FedAvg在通信效率上比传统的SGD方法有显著提升。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>进一步分析</strong>：通过对比不同批量大小（B = 50）下的SGD和FedAvg实验，FedAvg在每个小批量计算中取得了类似的进展。进一步，增加客户端数目有助于平滑精度波动，减少标准SGD和FedAvg中仅有一个客户端时的波动。</p>
</blockquote>
<h3 id="3大规模lstm实验">3、大规模LSTM实验</h3>
<ul>
<li>任务背景
<ul>
<li>实验中的大规模任务是一个基于LSTM的下一个单词预测任务，数据集来自一个大型社交网络，共有1000万个公共帖子，数据按作者分组，客户端数目超过50万个。</li>
<li>每个客户端的数据集最多包含5000个单词，测试集包含10万个不同作者的帖子。</li>
</ul>
</li>
<li>模型
<ul>
<li>使用了一个256节点的LSTM模型，词汇表大小为10,000个单词，每个单词的输入和输出嵌入维度为192，共有495万多个参数。</li>
<li>输入序列为10个单词。</li>
</ul>
</li>
<li>训练与结果
<ul>
<li>为了验证FedAvg的有效性，采用了200个客户端进行每轮训练，FedAvg使用B=8和E=1的配置。</li>
<li>实验结果表明，<strong>FedAvg</strong>在35轮通信内达到了10.5%的准确率，而<strong>FedSGD</strong>需要18轮通信才达到相同的准确率，这表明<strong>FedAvg</strong>在通信轮次上的效率更低（需要更多的轮次才能达到同样的准确率）。</li>
<li>这<strong>并不意味着FedAvg表现更差</strong>，而是表明<strong>FedAvg的优势在于处理更大规模的分布式数据时的稳定性和长远表现</strong>。FedAvg能够通过更多的客户端参与和更好的平均化，减少由于个别客户端数据分布差异造成的噪声，最终取得更好的整体性能。对于FedAvg，减少通信轮次可能会带来更多的计算量和通信开销，但其<strong>精度的稳定性</strong>是一个长期的优势。</li>
</ul>
</li>
</ul>
<h2 id="主要结论">主要结论</h2>
<ul>
<li>FedAvg使用非IID数据，尤其在E（本轮训练轮数）较大时，能够大幅减少通信轮数，提高训练效率。</li>
<li>在较小批量（B=10）时，FedAvg训练收敛速度更快。</li>
<li>适当增加客户端参与比例（C&gt;=0.1）能显著提高非IID数据情况下的训练速度。</li>
</ul>
<blockquote>
<p>这个实验验证了FedAvg在去中心化数据场景（如移动设备）下的高效性，尤其适用于真实世界数据分布不均的情况。</p>
</blockquote>
<h1 id="联邦学习提高通信效率与隐私保护的未来方向"><strong>联邦学习：提高通信效率与隐私保护的未来方向</strong></h1>
<h2 id="模型实用性">模型实用性</h2>
<p>实验表明，<strong>联邦学习</strong>（Federated Learning）可以通过较少的通信轮次训练出高质量的模型，实验结果在多种模型架构上都有体现，包括：</p>
<ul>
<li>多层感知机（MLP）</li>
<li>两种不同的卷积神经网络（CNN）</li>
<li>两层字符级LSTM（长短时记忆网络）</li>
<li>大规模的词级LSTM模型</li>
</ul>
<blockquote>
<p><strong>联邦学习的优势</strong>：这些实验结果证明了<strong>FedAvg</strong>算法（联邦学习中的一种常用算法）能够在较少的通信轮次下，训练出效果较好的模型，表明联邦学习具有实用性，尤其是在分布式、隐私保护和大规模数据处理方面。</p>
</blockquote>
<h2 id="隐私保护和安全性">隐私保护和安全性</h2>
<ul>
<li><strong>隐私保护的优势</strong>：联邦学习本身就具有隐私保护的优势，因为数据并不会离开客户端，避免了数据集中存储可能带来的隐私泄露风险。</li>
<li><strong>差分隐私</strong>、<strong>安全多方计算</strong>（Secure Multi-Party Computation，SMPC）等技术：为了进一步增强隐私保护，未来的研究可以考虑引入这些技术，提供更强的隐私保证。这些技术可以与联邦学习结合，进一步提升数据的隐私性和安全性。
<ul>
<li><strong>差分隐私</strong>：是一种强大的隐私保护方法，<strong>通过加入噪声来保证任何单个用户的数据不会泄露</strong>，适用于联邦学习中的数据保护。</li>
<li><strong>安全多方计算</strong>：可以确保在多个方之间进行计算时，数据保持加密状态，避免泄露私人信息。</li>
</ul>
</li>
</ul>
<h2 id="同步算法的适用性"><strong>同步算法的适用性</strong></h2>
<p>上述隐私保护技术（差分隐私、安全多方计算）最自然地应用于<strong>同步算法</strong>，如<strong>FedAvg</strong>。这是因为同步算法的训练过程依赖于各客户端的更新结果的汇聚，而<strong>隐私保护方法通常需要在全局聚合时引入噪声或加密技术</strong>，适合在同步框架下实施。</p>
<h1 id="参考资料">参考资料</h1>
<p><a href="https://proceedings.mlr.press/v54/mcmahan17a/mcmahan17a.pdf" target="_blank" rel="noopener nofollow">Communication-Efficient Learning of Deep Networks from Decentralized Data</a></p>
<p><a href="https://github.com/Elliot438b/FedAvg" target="_blank" rel="noopener nofollow">FedAvg Github</a></p>
<h1 id="更多文章请转到一面千人的博客园">更多文章请转到<a href="https://www.cnblogs.com/Evsward/" target="_blank">一面千人的博客园</a></h1>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3689453488564815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 21:23">2025-03-13 21:13</span>&nbsp;
<a href="https://www.cnblogs.com/Evsward">一面千人</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18771017" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18771017);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18771017', targetLink: 'https://www.cnblogs.com/Evsward/p/18771017/FedAvg', title: '联邦学习：去中心化数据下的深度网络优化' })">举报</a>
</div>
        