
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18712130" title="发布于 2025-02-13 08:15">
    <span role="heading" aria-level="2">Git指南-从入门到精通</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="代码提交和同步命令">代码提交和同步命令</h2>
<p>流程图如下：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032226465.png" alt="" loading="lazy"></p>
<ul>
<li>第零步: 工作区与仓库保持一致</li>
<li>第一步: 文件增删改，变为已修改状态</li>
<li>第二步: git add ，变为已暂存状态</li>
</ul>
<pre><code class="language-bash">$ git status
$ git add --all # 当前项目下的所有更改
$ git add .  # 当前目录下的所有更改
$ git add xx/xx.py xx/xx2.py  # 添加某几个文件
</code></pre>
<ul>
<li>第三步: git commit，变为已提交状态</li>
</ul>
<pre><code class="language-bash">$ git commit -m "&lt;这里写commit的描述&gt;"
</code></pre>
<ul>
<li>第四步: git push，变为已推送状态</li>
</ul>
<pre><code class="language-bash">$ git push -u origin master # 第一次需要关联上
$ git push # 之后再推送就不用指明应该推送的远程分支了
$ git branch # 可以查看本地仓库的分支
$ git branch -a # 可以查看本地仓库和本地远程仓库(远程仓库的本地镜像)的所有分支
</code></pre>
<p>一般来说，在某个分支下，最常用的操作如下：</p>
<pre><code class="language-bash">$ git status
$ git add -a
$ git status
$ git commit -m 'xxx'
$ git pull --rebase
$ git push origin xxbranch
</code></pre>
<h2 id="代码撤销和撤销同步命令">代码撤销和撤销同步命令</h2>
<p>流程图如下：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032227058.png" alt="" loading="lazy"></p>
<h3 id="已修改但未暂存">已修改，但未暂存</h3>
<pre><code class="language-bash">$ git diff # 列出所有的修改
$ git diff xx/xx.py xx/xx2.py # 列出某(几)个文件的修改

$ git checkout # 撤销项目下所有的修改
$ git checkout . # 撤销当前文件夹下所有的修改
$ git checkout xx/xx.py xx/xx2.py # 撤销某几个文件的修改
$ git clean -f # untracked状态，撤销新增的文件
$ git clean -df # untracked状态，撤销新增的文件和文件夹

# Untracked files:
#  (use "git add &lt;file&gt;..." to include in what will be committed)
#
#	xxx.py
</code></pre>
<blockquote>
<p><code>git checkout</code> 与后文的切换分支命令几乎一致，事实上，<code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能），因此在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code></p>
</blockquote>
<h3 id="已暂存未提交">已暂存，未提交</h3>
<blockquote>
<p>这个时候已经执行过git add，但未执行git commit，但是用git diff已经看不到任何修改。 因为git diff检查的是工作区与暂存区之间的差异。</p>
</blockquote>
<pre><code class="language-bash">$ git diff --cached # 这个命令显示暂存区和本地仓库的差异

$ git reset # 暂存区的修改恢复到工作区
$ git reset --soft # 与git reset等价，回到已修改状态，修改的内容仍然在工作区中
$ git reset --hard # 回到未修改状态，清空暂存区和工作区
</code></pre>
<blockquote>
<p>git reset --hard 操作等价于 git reset 和 git checkout 2步操作</p>
</blockquote>
<h3 id="已提交未推送">已提交，未推送</h3>
<blockquote>
<p>执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值回退到这次提交。</p>
</blockquote>
<pre><code class="language-bash">$ git diff &lt;branch-name1&gt; &lt;branch-name2&gt; # 比较2个分支之间的差异
$ git diff master origin/master # 查看本地仓库与本地远程仓库的差异

$ git reset --hard origin/master # 回退与本地远程仓库一致
$ git reset --hard HEAD^ # 回退到本地仓库上一个版本
$ git reset --hard &lt;hash code&gt; # 回退到任意版本
$ git reset --soft/git reset # 回退且回到已修改状态，修改仍保留在工作区中。
</code></pre>
<h3 id="已推送到远程">已推送到远程</h3>
<pre><code class="language-java">$ git push -f orgin master # 强制覆盖远程分支
$ git push -f # 如果之前已经用 -u 关联过，则可省略分支名
</code></pre>
<blockquote>
<p>慎用，一般情况下，本地分支比远程要新，所以可以直接推送到远程，但有时推送到远程后发现有问题，进行了版本回退，旧版本或者分叉版本推送到远程，需要添加 -f参数，表示强制覆盖。</p>
</blockquote>
<h2 id="其它常用命令">其它常用命令</h2>
<h3 id="关联远程仓库">关联远程仓库</h3>
<ul>
<li>如果还没有Git仓库，需要初始化</li>
</ul>
<pre><code class="language-bash">$ git init
</code></pre>
<ul>
<li>如果想关联远程仓库</li>
</ul>
<pre><code class="language-bash">$ git remote add &lt;name&gt; &lt;git-repo-url&gt;
# 例如 git remote add origin https://github.com/xxxxxx # origin是远程仓库的名称
</code></pre>
<ul>
<li>如果想关联多个远程仓库</li>
</ul>
<pre><code class="language-bash">$ git remote add &lt;name&gt; &lt;another-git-repo-url&gt;
# 例如 git remote add coding https://coding.net/xxxxxx
</code></pre>
<ul>
<li>查看关联了哪些仓库或者地址</li>
</ul>
<pre><code class="language-bash">$ git remote -v
# origin https://github.com/Seven-97/SevenBlog.git (fetch)
# origin https://github.com/Seven-97/SevenBlog.git (push)
</code></pre>
<ul>
<li>如果远程有仓库，需要clone到本地</li>
</ul>
<pre><code class="language-bash">$ git clone &lt;git-repo-url&gt;
# 关联的远程仓库将被命名为origin，这是默认的。
</code></pre>
<ul>
<li>如果想把别人仓库的地址改为自己的</li>
</ul>
<pre><code class="language-bash">$ git remote set-url origin &lt;your-git-url&gt;
</code></pre>
<h3 id="配置自己的git">配置自己的Git</h3>
<ul>
<li>查看当前的配置</li>
</ul>
<pre><code class="language-bash">$ git config --list
</code></pre>
<ul>
<li>配置自己的名字</li>
</ul>
<pre><code class="language-bash">$ git config --global user.name "&lt;name&gt;"
#  --global为可选参数，该参数表示配置全局信息
</code></pre>
<ul>
<li>希望别人看到你的commit可以联系到你</li>
</ul>
<pre><code class="language-bash">$ git config --global user.email "&lt;email address&gt;"
</code></pre>
<ul>
<li>有些命令很长，能不能简化一下</li>
</ul>
<pre><code class="language-bash">$ git config --global alias.logg "log --graph --decorate --abbrev-commit --all"
# 之后就可以开心地使用 git log了
</code></pre>
<p>​</p>
<h3 id="切换分支">切换分支</h3>
<blockquote>
<p>新建仓库后，默认生成了master分支</p>
</blockquote>
<ul>
<li>新建分支并切换</li>
</ul>
<pre><code class="language-bash">$ git checkout -b &lt;new-branch-name&gt;
# 例如 git checkout -b dev
# 如果仅新建，不切换，则去掉参数 -b
</code></pre>
<ul>
<li>查看当前有哪些分支</li>
</ul>
<pre><code class="language-bash">$ git branch
# * dev
#   master # 标*号的代表当前所在的分支
</code></pre>
<ul>
<li>查看当前本地&amp;远程有哪些分支</li>
</ul>
<pre><code class="language-bash">$ git branch -a
# * dev
#   master
#   remotes/origin/master
</code></pre>
<ul>
<li>切换到现有的分支</li>
</ul>
<pre><code class="language-bash">$ git checkout master
</code></pre>
<h3 id="更新本地远端代码-pushpoll">更新本地/远端代码 push/poll</h3>
<ul>
<li>将本地master分支推送到远程去</li>
</ul>
<pre><code class="language-bash">$ git push origin master
# 你可以使用git push -u origin master将本地分支与远程分支关联，之后仅需要使用git push即可。
</code></pre>
<ul>
<li>远程分支更新了，需要更新代码</li>
</ul>
<pre><code class="language-bash">$ git pull origin &lt;branch-name&gt;
# 之前如果push时使用过-u，那么就可以省略为git pull
</code></pre>
<ul>
<li>本地有修改，能不能先git pull</li>
</ul>
<pre><code class="language-shell">$ git stash # 工作区修改暂存
$ git pull  # 更新分支
$ git stash pop # 暂存修改恢复到工作区
</code></pre>
<p><code>git pull</code> 实际上包含了两个操作：fetch和merge。当使用<code>git pull</code>命令时，Git会自动下载最新代码，并尝试将最新代码合并到当前分支。<code>git fetch</code>命令只是从远程库下载最新代码，但并不自动合并到本地分支。</p>
<ul>
<li>如果我们希望自动合并最新代码到当前分支，并且不需要查看最新代码的变动，可以使用<code>git pull</code>命令。</li>
<li>如果我们只想下载最新代码到本地，并需要查看最新代码的变动后才决定是否进行合并，可以使用<code>git fetch</code>命令。</li>
</ul>
<h3 id="撤销操作-reset">撤销操作 reset</h3>
<ul>
<li>恢复<strong>暂存区文件到工作区</strong></li>
</ul>
<pre><code class="language-bash">$ git checkout &lt;file-name&gt;
</code></pre>
<ul>
<li>恢复<strong>暂存区的所有文件到工作区</strong></li>
</ul>
<pre><code class="language-bash">$ git checkout .
</code></pre>
<ul>
<li>重置暂存区的某文件，与上一次commit保持一致，但<strong>工作区不变</strong></li>
</ul>
<pre><code class="language-bash">$ git reset &lt;file-name&gt;
</code></pre>
<ul>
<li>重置<strong>暂存区与工作区</strong>，与上一次commit保持一致</li>
</ul>
<pre><code class="language-bash">$ git reset --hard &lt;file-name&gt;
# 如果是回退版本(commit)，那么file，变成commit的hash码就好了。
</code></pre>
<ul>
<li>去掉某个commit</li>
</ul>
<pre><code class="language-bash">$ git revert &lt;commit-hash&gt;
# 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果
</code></pre>
<ul>
<li>reset回退错误恢复</li>
</ul>
<pre><code class="language-bash">$ git reflog #查看最近操作记录
$ git reset --hard HEAD{5} #恢复到前五笔操作
$ git pull origin backend-log #再次拉取代码
</code></pre>
<h3 id="版本回退与前进-statuslogreflog">版本回退与前进 status、log、reflog</h3>
<ul>
<li>查看当前状态</li>
</ul>
<pre><code class="language-bash">$ git status
</code></pre>
<ul>
<li>查看历史版本</li>
</ul>
<pre><code class="language-bash">$ git log
commit 9a3d34be1e26563e198ee6aea72d32ad68b607d0 (HEAD -&gt; main, origin/main, origin/HEAD)
Author: seven &lt;415849169@qq.com&gt;
Date:   Tue Jul 9 19:10:11 2024 +0800

    更新

commit 47c32de67a28df58ea3bd0b88137f1bd19a12969
Author: Seven &lt;415849169@qq.com&gt;
Date:   Tue Jul 9 00:30:11 2024 +0800

    更新

commit 294814faf55fc4f01e3b0a28c96b5acdf1348333
Author: Seven &lt;415849169@qq.com&gt;
Date:   Tue Jul 9 00:22:15 2024 +0800

    更新内容

commit 15026d42c4d3a6093bde4578484e2bb64824b9e8
Author: Seven &lt;415849169@qq.com&gt;
</code></pre>
<ul>
<li>这样的log不好看，可以试试以下命令</li>
</ul>
<pre><code class="language-bash">$ git log --graph --decorate --abbrev-commit --all
* commit 9a3d34b (HEAD -&gt; main, origin/main, origin/HEAD)
| Author: seven &lt;415849169@qq.com&gt;
| Date:   Tue Jul 9 19:10:11 2024 +0800
|
|     更新
|
* commit 47c32de
| Author: Seven &lt;415849169@qq.com&gt;
| Date:   Tue Jul 9 00:30:11 2024 +0800
|
|     更新
|
* commit 294814f
| Author: Seven &lt;415849169@qq.com&gt;
| Date:   Tue Jul 9 00:22:15 2024 +0800
|
|     更新内容
|
* commit 15026d4
| Author: Seven &lt;415849169@qq.com&gt;
| Date:   Tue Jul 9 00:16:23 2024 +0800
</code></pre>
<ul>
<li>检出到任意版本</li>
</ul>
<pre><code class="language-bash">$ git checkout a5d88ea
# hash码很长，通常6-7位就够了
</code></pre>
<ul>
<li>远程仓库的版本很新，但是还是想用老版本覆盖</li>
</ul>
<pre><code class="language-bash">$ git push origin master --force
# 或者 git push -f origin master
</code></pre>
<ul>
<li>觉得commit太多了? 可以使用rebase将多个commit合并为1个</li>
</ul>
<pre><code class="language-bash">$ git rebase -i HEAD~4
# 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。将进入VIM界面，你可以修改提交信息。推送到远程分支的commit，不建议这样做，多人合作时，通常不建议修改历史。
</code></pre>
<ul>
<li>想回退到某一个版本</li>
</ul>
<pre><code class="language-bash">$ git reset --hard &lt;hash&gt;
# 例如 git reset --hard a3hd73r
# --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，--soft参数代表保留工作区的修改。
</code></pre>
<ul>
<li>想回退到上一个版本，有没有简便方法?</li>
</ul>
<pre><code class="language-bash">$ git reset --hard HEAD^
</code></pre>
<ul>
<li>回退到上上个版本呢?</li>
</ul>
<pre><code class="language-bash">$ git reset --hard HEAD^^
# HEAD^^可以换作具体版本hash值。
</code></pre>
<ul>
<li>回退错了，想到下一个版本</li>
</ul>
<pre><code class="language-bash">$ git reflog
# 这个命令保留了最近执行的操作及所处的版本，每条命令前的hash值，则是对应版本的hash值。使用上述的git checkout 或者 git reset命令 则可以检出或回退到对应版本。
</code></pre>
<ul>
<li>刚才commit信息写错了，修改上一次提交的commit信息</li>
</ul>
<pre><code class="language-bash">$ git commit --amend
</code></pre>
<h3 id="分支合并-merge">分支合并 merge</h3>
<p>每个分支上都有各自独有的提交，这意味着没有一个分支包含了修改的所有内容。因此通过合并分支来解决这个问题。</p>
<p>git merge 用来做分支合并，将其他分支中的内容合并到当前分支中。比如分支结构如下：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032318912.png" alt="" loading="lazy"></p>
<h4 id="其它分支合并到master分支">其它分支合并到master分支</h4>
<p>当前分支是master</p>
<pre><code class="language-shell">git checkout master
</code></pre>
<p>把issueFix中的内容Merge进来：</p>
<pre><code class="language-shell">git merge issueFix
</code></pre>
<p>如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：</p>
<pre><code class="language-shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:test.c
printf (“test1″);
=======
printf (“test2″);
\&gt;&gt;&gt;&gt;&gt;&gt;&gt; issueFix:test.c
</code></pre>
<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在 issueFix 分支中的内容。</p>
<p>解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<pre><code class="language-shell">printf (“test2″);
</code></pre>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，和&gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决（resolved）。因为一旦暂存，就表示冲突已经解决。</p>
<p>合并后的分支图如下：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032320674.png" alt="" loading="lazy"><br>
注意，这次合并的实现，由于当前 master 分支所指向的 commit (C4)并非想要并入分支（issueFix）的直接祖先，Git 不得不进行一些处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）和它们的共同祖先（C2）进行一次简单的三方合并。对三方合并的结果作一新的快照，并自动创建一个指向它的 commit（C6)</p>
<p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。然后可以用 git commit 来完成这次合并提交。</p>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用git push origin 推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！</li>
<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。</li>
</ol>
<h4 id="master分支合并到当前分支">master分支合并到当前分支</h4>
<p>以下是合并master分支到你的当前分支的基本步骤：</p>
<ol>
<li>
<p>确保在正确的分支上：首先，确保当前所在的分支是想要合并master分支到的地方。例如，如果想要将master合并到feature-branch，需要先切换到feature-branch：</p>
<pre><code class="language-shell">git checkout feature-branch
</code></pre>
</li>
<li>
<p>更新分支：在合并之前，最好先更新分支，以确保它是最新的。可以通过拉取master分支的最新更改来实现这一点：</p>
<pre><code class="language-shell">git pull origin master
</code></pre>
<p>这会从远程仓库的master分支拉取最新的更改，并尝试将它们合并到你的当前分支。如果master分支有新的提交，这可能会导致合并冲突。</p>
</li>
<li>
<p>合并master分支：一旦分支是最新的，可以开始合并过程。使用git merge命令来合并master分支：</p>
<pre><code class="language-shell">git merge master
</code></pre>
<p>这会将master分支的更改合并到当前分支。如果两个分支之间没有冲突，合并将自动完成。如果有冲突，Git会告诉你哪些文件有冲突，此时就需要手动解决这些冲突。</p>
</li>
<li>
<p>解决冲突（如果有）：如果合并过程中出现冲突，Git会暂停合并并告诉你哪些文件需要手动解决冲突。你需要打开这些文件，找到并解决冲突。解决冲突后，使用以下命令标记冲突已解决：</p>
<pre><code class="language-shell">git add &lt;冲突文件&gt;
</code></pre>
<p>然后继续合并：</p>
<pre><code class="language-shell">git commit
</code></pre>
<p>这将创建一个新的合并提交，包含所有解决的冲突。</p>
</li>
<li>
<p>推送更改：一旦合并完成并且所有冲突都已解决，你可以将更改推送到远程仓库：</p>
<pre><code class="language-shell">git push origin feature-branch
</code></pre>
<p>确保替换feature-branch为你的分支名称。</p>
</li>
</ol>
<h4 id="注意事项">注意事项</h4>
<ul>
<li>在合并之前，始终确保你的分支是最新的，以避免不必要的冲突。</li>
<li>如果你在合并过程中遇到问题，可以使用<code>git merge --abort</code>来中止合并并返回到合并前的状态。</li>
<li>使用git log或gitk可以帮助理解分支的历史和可能的冲突点。</li>
</ul>
<h2 id="git代码管理规范">Git代码管理规范</h2>
<h3 id="分支命名">分支命名</h3>
<h4 id="master-分支">master 分支</h4>
<p>master 为主分支，也是用于部署生产环境的分支，需要确保master分支稳定性。master 分支一般由 release 以及 hotfix 分支合并，任何时间都不能直接修改代码。</p>
<h4 id="develop-分支">develop 分支</h4>
<p>develop 为开发环境分支，始终保持最新完成以及bug修复后的代码，用于前后端联调。一般开发的新功能时，feature分支都是基于develop分支创建的。</p>
<h4 id="feature-分支">feature 分支</h4>
<p>开发新功能时，以develop为基础创建feature分支。</p>
<p>分支命名时以 <code>feature/</code> 开头，后面可以加上开发的功能模块， 命名示例：<code>feature/user_module</code>、<code>feature/cart_module</code></p>
<h4 id="test分支">test分支</h4>
<p>test为测试环境分支，外部用户无法访问，专门给测试人员使用，版本相对稳定。</p>
<h4 id="release分支">release分支</h4>
<p>release 为预上线分支（预发布分支），UAT测试阶段使用。一般由 test 或 hotfix 分支合并，不建议直接在 release 分支上直接修改代码。</p>
<h4 id="hotfix-分支">hotfix 分支</h4>
<p>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支。修复完成后，需要合并到 master 分支和 develop 分支。</p>
<p>分支命名以<code>hotfix/</code> 开头的为修复分支，它的命名规则与 feature 分支类似。</p>
<h3 id="分支与环境对应关系">分支与环境对应关系</h3>
<p>在系统开发过程中常用的环境：</p>
<ul>
<li>DEV 环境（Development environment）：用于开发者调试使用</li>
<li>FAT环境（Feature Acceptance Test environment）：功能验收测试环境，用于测试环境下的软件测试者测试使用</li>
<li>UAT环境 （User Acceptance Test environment）：用户验收测试环境，用于生产环境下的软件测试者测试使用</li>
<li>PRO 环境（Production environment）：生产环境</li>
</ul>
<p>对应关系：</p>
<table>
<thead>
<tr>
<th style="text-align: left">分支</th>
<th style="text-align: left">功能</th>
<th style="text-align: left">环境</th>
<th style="text-align: left">可访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">master</td>
<td style="text-align: left">主分支，稳定版本</td>
<td style="text-align: left">PRO</td>
<td style="text-align: left">是</td>
</tr>
<tr>
<td style="text-align: left">develop</td>
<td style="text-align: left">开发分支，最新版本</td>
<td style="text-align: left">DEV</td>
<td style="text-align: left">是</td>
</tr>
<tr>
<td style="text-align: left">feature</td>
<td style="text-align: left">开发分支，实现新特性</td>
<td style="text-align: left"></td>
<td style="text-align: left">否</td>
</tr>
<tr>
<td style="text-align: left">test</td>
<td style="text-align: left">测试分支，功能测试</td>
<td style="text-align: left">FAT</td>
<td style="text-align: left">是</td>
</tr>
<tr>
<td style="text-align: left">release</td>
<td style="text-align: left">预上线分支，发布新版本</td>
<td style="text-align: left">UAT</td>
<td style="text-align: left">是</td>
</tr>
<tr>
<td style="text-align: left">hotfix</td>
<td style="text-align: left">紧急修复分支，修复线上bug</td>
<td style="text-align: left"></td>
<td style="text-align: left">否</td>
</tr>
</tbody>
</table>
<h4 id="分支合并流程规范">分支合并流程规范</h4>
<p>业界常见的两大主分支（master、develop）、三个辅助分支（feature、release、hotfix）的生命周期：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032242353.webp" alt="" loading="lazy"></p>
<p>以上生命周期仅作参考，不同开发团队可能有不同的规范，可自行灵活定义。</p>
<h3 id="git-commit-message规范">Git Commit Message规范</h3>
<p>Git commit message规范指提交代码时编写的规范注释，编写良好的Commit messages可以达到3个重要的目的：</p>
<ul>
<li>加快代码review的流程</li>
<li>帮助我们编写良好的版本发布日志</li>
<li>让之后的维护者了解代码里出现特定变化和feature被添加的原因</li>
</ul>
<h4 id="angular-git-commit-guidelines">Angular Git Commit Guidelines</h4>
<p>业界应用的比较广泛的是Angular Git Commit Guidelines：</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<ul>
<li>type：提交类型</li>
<li>scope：可选项，本次 commit 波及的范围</li>
<li>subject：简明扼要的阐述下本次 commit 的主旨，在<code>Angular Git Commit Guidelines</code>中强调了三点。使用祈使句，首字母不要大写，结尾无需添加标点</li>
<li>body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机</li>
<li>footer: 描述下与之关联的 issue 或 break change</li>
</ul>
<h4 id="简易版">简易版</h4>
<p>项目中实际可以采用简易版规范：</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;
</code></pre>
<h4 id="type规范">type规范</h4>
<p><code>Angular Git Commit Guidelines</code>中推荐的type类型如下：</p>
<ul>
<li>feat: 新增功能</li>
<li>fix: 修复bug</li>
<li>docs: 仅文档更改</li>
<li>style: 不影响代码含义的更改（空白、格式设置、缺失 分号等）</li>
<li>refactor: 既不修复bug也不添加特性的代码更改</li>
<li>perf: 改进性能的代码更改</li>
<li>test: 添加缺少的测试或更正现有测试</li>
<li>chore: 对构建过程或辅助工具和库（如文档）的更改</li>
</ul>
<p>除此之外，还有一些常用的类型：</p>
<ul>
<li>delete：删除功能或文件</li>
<li>modify：修改功能</li>
<li>build：改变构建流程，新增依赖库、工具等（例如webpack、gulp、npm修改）</li>
<li>test：测试用例的新增、修改</li>
<li>ci：自动化流程配置修改</li>
<li>revert：回滚到上一个版本</li>
</ul>
<h4 id="单次提交注意事项">单次提交注意事项</h4>
<ul>
<li>提交问题必须为同一类别</li>
<li>提交问题不要超过3个</li>
<li>提交的commit发现不符合规范，<code>git commit --amend -m "新的提交信息"</code>或 <code>git reset --hard HEAD</code> 重新提交一次</li>
</ul>
<h3 id="配置gitignore文件">配置.gitignore文件</h3>
<p><code>.gitignore</code>是一份用于忽略不必提交的文件的列表，项目中可以根据实际需求统一<code>.gitignore</code>文件，减少不必要的文件提交和冲突，净化代码库环境。</p>
<p>通用文件示例：</p>
<pre><code>HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

# Log file
*.log
/logs*

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear
*.zip
*.tar.gz
*.rar
*.cmd
</code></pre>
<h3 id="其他">其他</h3>
<p>此外，还有一些其他建议：</p>
<ul>
<li>master 分支的每一次更新，都建议打 tag 添加标签，通常为对应版本号，便于管理</li>
<li>feature分支、hotfix分支在合并后可以删除，避免分支过多管理混乱</li>
<li>每次 pull 代码前，提交本地代码到本地库中，否则可能回出现合并代码出错，导致代码丢失</li>
</ul>
<h2 id="学习书籍及网站">学习书籍及网站</h2>
<ul>
<li>
<p>推荐书籍：</p>
<ul>
<li>
<p><a href="https://github.com/progit/progit2" target="_blank" rel="noopener nofollow">Git Pro2英文Github仓库</a></p>
</li>
<li>
<p><a href="https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/about-version-control.html" target="_blank" rel="noopener nofollow">Git Pro2中文Gitbook</a></p>
</li>
<li>
<p><a href="https://github.com/bingohuang/progit2-gitbook" target="_blank" rel="noopener nofollow">Git Pro2对应的中文Markdown版本的仓库地址</a></p>
</li>
<li>
<p><a href="http://git.oschina.net/progit/index.html" target="_blank" rel="noopener nofollow">Git Pro中文阅读</a></p>
</li>
</ul>
</li>
<li>
<p>在线学习</p>
<ul>
<li>git在线学习网站： <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener nofollow">https://learngitbranching.js.org/</a></li>
</ul>
</li>
</ul>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202405032218260.png" alt="" loading="lazy"></p>
<h2 id="面试题专栏">面试题专栏</h2>
<p><a href="https://www.seven97.top/interview/" target="_blank" rel="noopener nofollow">Java面试题专栏</a>已上线，欢迎访问。</p>
<ul>
<li>如果你不知道简历怎么写，简历项目不知道怎么包装；</li>
<li>如果简历中有些内容你不知道该不该写上去；</li>
<li>如果有些综合性问题你不知道怎么答；</li>
</ul>
<p>那么可以私信我，我会尽我所能帮助你。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03231981333449074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 08:15">2025-02-13 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712130" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712130);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712130', targetLink: 'https://www.cnblogs.com/seven97-top/p/18712130', title: 'Git指南-从入门到精通' })">举报</a>
</div>
        