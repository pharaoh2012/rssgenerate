
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18740773/Montgomery" title="发布于 2025-02-27 23:04">
    <span role="heading" aria-level="2">详解蒙哥马利算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文从蒙哥马利算法的背景入手，详细介绍了算法的原理及算法主要流程步骤，最后结合一个简单的实例介绍了该算法计算过程。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1 背景</h1>
<p>在密码学中，最常见的一类基础运算大概就是模算术(Modular Arithmetic)了，特别地，<span style="color: rgba(255, 0, 0, 1)">模乘(Modular Multiplication)是其中最复杂的运算</span>。而且在实际的密码算法中各个运算都是基于大数运算，正常的大数模乘运算计算和存储开销尤其大。以基于模16位数N运算为例，对于加法模运算，两个小于N的数a，b相加，要么a+b小于N，这时a+b的值就是最终模运算结果，如果a+b大于或等于N，则a+b-N即为最终模运算结果，而且a+b最多为一个17位的数，存储和计算开销都较小；但是如果是乘法模运算，a*b最大可以产生32位的数，存储空间直接翻倍，这时再对结果取余要么基于除法运算，要么进行多次减法运算，可以想象存储和运算开销都大大增加。蒙哥马利模乘算法正是基于此背景产生，借助该算法可以大大减小模乘运算开销。</p>
<h1>2 原理讲解</h1>
<p>蒙哥马利算法并不是一个独立得算法，而是三个相互独立又相互联系的算法集合，其中包括：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227144140505-396344216.png" alt="" loading="lazy"></p>
<h2>2.1 蒙哥马利模乘</h2>
<p>先给出算法解决的问题描述，即：</p>
<div class="cnblogs_code">
<pre>已知正整数 N，欲在不使用“除法运算”的条件下，对输入的两个整数a, b，计算 c = a*b mod N。</pre>
</div>
<p>模乘是为了计算a*b mod N，普通算法中，在计算模N时，利用的是带余除法，除法运算需要太多次乘法，计算复杂度较高，蒙哥马利算法的思想就是<span style="color: rgba(255, 0, 0, 1)">利用进制表示简化除法运算，转化成位运算</span>。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227142540249-1056217377.png" alt="" width="584" height="112" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>为了计算一开始的a*b mod N，需要用到上面的蒙哥马利形式，令X=a'b'，我们可以设计<span style="color: rgba(255, 0, 0, 1)">一个函数MontgomeryReduction(X, R, N)来计算XR<sup>-1</sup> mod N</span>，简单计算发现这个函数的计算结果为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227143139165-1190629919.png" alt="" width="368" height="31" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>这样再调用一遍函数计算MontgomeryReduction(X<sub>1</sub>, R, N)就得到我们最终需要的结果X<sub>1</sub>*R<sup>-1</sup> mod N = a*b mod N，称这个函数运算叫蒙哥马利约减算法，所以说，蒙哥马利约减的产生是为了蒙哥马利模乘计算服务的。</p>
<h2>2.2 蒙哥马利约减</h2>
<p>蒙哥马利算法的核心在于蒙哥马利约简，而且前面提到，蒙哥马利算法的主要思想是把<span style="color: rgba(255, 0, 0, 1)">取模运算变得简单</span>，蒙哥马利约减是计算X*R<sup>-1</sup> mod N，相当于X/R mod N，由之前约定可知R=2<sup>k</sup>，所以X/R = X&gt;&gt;k（X右移k位），但是X不一定被R整除，右移操作会抹掉X中的低位，这个不是精确计算，而是向下取整除法。为了使得右移位操作不损失精度，我们需要找一个m，使得X+m*N是R的倍数，<span style="color: rgba(255, 0, 0, 1)">在模N意义下X+m*N&nbsp;≡ X mod N，所以增加mN在模N运算下不影响最终结果，但是却能使得X+m*N可以直接进行右移运算且不损失精度</span>，接下来重点分析如何求m。</p>
<p>根据R的定义，gcd(R, N) = 1，根据扩展欧几里德算法如下图，有RR' – NN' = 1并且有0&lt;N'&lt;R，0&lt;=R'&lt;N&lt;R，这里-N'是N在模R下的逆元，即-N'≡N<sup>-1</sup> mod R，所以<span style="color: rgba(255, 0, 0, 1)">N'=-N<sup>-1</sup> mod R</span>。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227155049521-44609656.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;由如下推导可知要是X+m*N≡0 mod R，只要取<span style="color: rgba(255, 0, 0, 1)">m≡X*N' mod R</span>即可，这样就求出了使X+m*N能被R整除的m。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227160055513-2031499951.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>约减算法总流程<br>提前工作：已知a，b，N，确定R，并计算出蒙哥马利形式中的a'，b'以及X。下面给出蒙哥马利约减详细过程：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227183230959-2128987094.png" alt="" width="441" height="284" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;下面给出基于蒙哥马利约减的蒙哥马利模乘算法完整流程：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202502/465567-20250227183310922-101960538.png" alt="" width="687" height="140" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>复杂度分析</p>
<p>从蒙哥马利约减算法过程看来，算法1，2，3步骤中模R实际上就是移位运算，这很容易实现，而第1步的-N的模逆可以提前预运算获得，第4步中最多有一个减法运算，蒙哥马利约简的复杂度确实很低。但是看蒙哥马利模乘的流程，在第1步中进行蒙哥马利表示时就计算了两次模乘N运算（a'≡a*R mod N和b'≡b*R mod N），貌似复杂度没有降低，但是实际上，第一步可以看成是蒙哥马利的预先计算，在硬件实现中，先把预先计算的算好，在后面运行就会快很多，尤其是在幂模运算中，如果幂很大（相当于连续进行大量的模乘运算），最开始的两步预运算和后面反复模乘相比可以直接忽略；另外，其实还以先预运算出R<sup>2</sup> mod N，则求a*R mod N，可以直接调用MontgomeryReduction(a, R<sup>2</sup>, N)获得，同理可求b*R mod N，这样就降低了蒙哥马利模乘的复杂度。</p>
<h2>2.3 蒙哥马利幂模</h2>
<p>&nbsp;最后介绍蒙哥马利幂模运算，先看一下百度百科上对<a href="https://baike.baidu.com/item/%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E5%B9%82%E6%A8%A1%E8%BF%90%E7%AE%97" target="_blank" rel="noopener nofollow">蒙哥马利幂模运算</a>的介绍（其实该文章就是普通的幂模运算，并不涉及蒙哥马利算法）</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">针对快速模幂运算这一课题，西方现代数学家提出了大量的解决方案，通常都是先将幂模运算转化为乘模运算。
例如求D</span>=C^15%<span style="color: rgba(0, 0, 0, 1)">N
由于：a</span>*b % n = (a % n)*(b % n) %<span style="color: rgba(0, 0, 0, 1)"> n
所以令：
C1 </span>=C*C % N =C^2 %<span style="color: rgba(0, 0, 0, 1)"> N
C2 </span>=C1*C % N =C^3 %<span style="color: rgba(0, 0, 0, 1)"> N
C3 </span>=C2*C2 % N =C^6 %<span style="color: rgba(0, 0, 0, 1)"> N
C4 </span>=C3*C % N =C^7 %<span style="color: rgba(0, 0, 0, 1)"> N
C5 </span>=C4*C4 % N =C^14 %<span style="color: rgba(0, 0, 0, 1)"> N
C6 </span>=C5*C % N =C^15 %<span style="color: rgba(0, 0, 0, 1)"> N
即：对于E</span>=<span style="color: rgba(0, 0, 0, 1)">15的幂模运算可分解为6个乘模运算，归纳分析以上方法可以发现：
对于任意指数E，都可采用以下算法计算D</span>=C^E %<span style="color: rgba(0, 0, 0, 1)"> N：
D</span>=1<span style="color: rgba(0, 0, 0, 1)">
WHILE E</span>&gt;<span style="color: rgba(0, 0, 0, 1)">0
  IF E</span>%2=<span style="color: rgba(0, 0, 0, 1)">0
    C</span>=C*C %<span style="color: rgba(0, 0, 0, 1)"> N
    E</span>=E/2<span style="color: rgba(0, 0, 0, 1)">
  ELSE
    D</span>=D*C %<span style="color: rgba(0, 0, 0, 1)"> N
    E</span>=E-1<span style="color: rgba(0, 0, 0, 1)">
RETURN D
继续分析会发现，要知道E何时能整除2，并不需要反复进行减一或除二的操作，只需验证E的二进制各位是0还是1就可以了，从左至右或从右至左验证都可以，从左至右会更简洁，
设E</span>=Sum[i=0 to n](ei*2^i)，0&lt;=ei&lt;=1<span style="color: rgba(0, 0, 0, 1)">
则：
D</span>=1<span style="color: rgba(0, 0, 0, 1)">
FOR i</span>=<span style="color: rgba(0, 0, 0, 1)">n TO 0
  D</span>=D*D %<span style="color: rgba(0, 0, 0, 1)"> N
  IF ei</span>=1<span style="color: rgba(0, 0, 0, 1)">
    D</span>=D*C %<span style="color: rgba(0, 0, 0, 1)"> N
RETURN D
这样，模幂运算就转化成了一系列的模乘运算。</span></pre>
</div>
<p>在开始算法前先将C转换为蒙哥马利形式，然后中间模乘进行蒙哥马利模乘，在算法最后在将蒙哥马利形式转回正常形式，即可实现基于蒙哥马利的幂模运算，由文章分析可知，模数越大该算法相比普通方式的幂模运算优势也越大！</p>
<h1>3 实例</h1>
<p>下面通过一个简单的实例介绍该算法的计算过程，首先a=18，b=29，N=59，那么根据R的选取原则，可以取R=64=2<sup>6</sup>（即k=6），R二进制表示为0b1000000，由于N是质数，所以N和R满足gcd(R, N)=1。所以首先可以得出如下预运算值</p>
<p>a'≡a*R mod N≡31 mod N，b'≡b*R mod N≡27 mod N，N'≡-N<sup>-1</sup> mod R≡13 mod R，R<sup>2</sup> mod N≡25 mod N</p>
<p>则MontgomeryMultiply算法有以下计算</p>
<p>1 X=a'*b'=837</p>
<p>2 调用MontgomeryReduction(837, R, N)<br>&nbsp; &nbsp;2.1 N'运算已算出<br>&nbsp; &nbsp;2.2 m≡X*N' mod R≡837*13 mod R≡10881&nbsp;mod 64≡0b10101010000001&nbsp;mod&nbsp;0b1000000≡1 mod R，由于R选取的特殊性，可知模R运算很好计算<br>&nbsp; &nbsp;2.3 y=(X+m*N)/R=(837+1*59)/64=896/64=0b1110000000/0b1000000=14，可见X+m*N能被R整除，所以该步进行简单右移k=6位操作即可<br>&nbsp; &nbsp;2.4 y &lt; N，无需任何操作<br>&nbsp; &nbsp;2.5 返回y=14</p>
<p>3 再次调用MontgomeryReduction(14, R, N)，该步和步骤2完全相同，不再进行详述，最终返回50</p>
<p>4 50即为18*29 mod 59的最终结果</p>
<p>以下给出上述实例的python版源码</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> math

</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MontMul:
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">docstring for ClassName</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
    <span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span><span style="color: rgba(0, 0, 0, 1)">(self, R, N):
        self.N </span>=<span style="color: rgba(0, 0, 0, 1)"> N
        self.R </span>=<span style="color: rgba(0, 0, 0, 1)"> R
        self.logR </span>= int(math.log(R, 2<span style="color: rgba(0, 0, 0, 1)">))
        N_inv </span>=<span style="color: rgba(0, 0, 0, 1)"> MontMul.modinv(N, R)
        self.N_inv_neg </span>= R -<span style="color: rgba(0, 0, 0, 1)"> N_inv
        self.R2 </span>= (R*R)%<span style="color: rgba(0, 0, 0, 1)">N

    @staticmethod        
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> egcd(a, b):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> a ==<span style="color: rgba(0, 0, 0, 1)"> 0:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> (b, 0, 1<span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            g, y, x </span>= MontMul.egcd(b %<span style="color: rgba(0, 0, 0, 1)"> a, a)
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> (g, x - (b // a) *<span style="color: rgba(0, 0, 0, 1)"> y, y)

    @staticmethod
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> modinv(a, m):
        g, x, y </span>=<span style="color: rgba(0, 0, 0, 1)"> MontMul.egcd(a, m)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> g != 1<span style="color: rgba(0, 0, 0, 1)">:
            </span><span style="color: rgba(0, 0, 255, 1)">raise</span> Exception(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">modular inverse does not exist</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> x %<span style="color: rgba(0, 0, 0, 1)"> m

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> MontgomeryReduction(self, T):
        N, R, logR, N_inv_neg </span>=<span style="color: rgba(0, 0, 0, 1)"> self.N, self.R, self.logR, self.N_inv_neg
        
        m </span>= ((T&amp;int(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">1</span><span style="color: rgba(128, 0, 0, 1)">'</span>*logR, 2)) * N_inv_neg)&amp;int(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">1</span><span style="color: rgba(128, 0, 0, 1)">'</span>*logR, 2) <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> m = (T%R * N_inv_neg)%R        </span>
<span style="color: rgba(0, 0, 0, 1)">        
        t </span>= (T+m*N) &gt;&gt; logR <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> t = int((T+m*N)/R)</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> t &gt;=<span style="color: rgba(0, 0, 0, 1)"> N:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> t-<span style="color: rgba(0, 0, 0, 1)">N
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> t

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> MontgomeryMultiply(self, a, b):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> a &gt;= self.N <span style="color: rgba(0, 0, 255, 1)">or</span> b &gt;=<span style="color: rgba(0, 0, 0, 1)"> self.N:
            </span><span style="color: rgba(0, 0, 255, 1)">raise</span> Exception(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">input integer must be smaller than the modulus N</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

        R2 </span>=<span style="color: rgba(0, 0, 0, 1)"> self.R2
        aR </span>= self.MontgomeryReduction(a*R2) <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> convert a to Montgomery form</span>
        bR = self.MontgomeryReduction(b*R2) <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> convert b to Montgomery form</span>
        T = aR*bR <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> standard multiplication</span>
        <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">aR {} bR {}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">.format(aR, bR))
        abR </span>= self.MontgomeryReduction(T) <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> Montgomery reduction</span>
        <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">abR </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, abR)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> self.MontgomeryReduction(abR) <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> covnert abR to normal ab</span>

<span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(128, 0, 128, 1)">__name__</span> == <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">__main__</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">:
    N </span>= 59<span style="color: rgba(0, 0, 0, 1)">
    R </span>= 64<span style="color: rgba(0, 0, 0, 1)">
    g, x, y </span>=<span style="color: rgba(0, 0, 0, 1)"> MontMul.egcd(N,R)
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> R&lt;=N <span style="color: rgba(0, 0, 255, 1)">or</span> g !=1<span style="color: rgba(0, 0, 0, 1)">: 
        </span><span style="color: rgba(0, 0, 255, 1)">raise</span> Exception(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">N must be larger than R and gcd(N,R) == 1</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    inst </span>=<span style="color: rgba(0, 0, 0, 1)"> MontMul(R, N)

    a, b </span>= 18, 29<span style="color: rgba(0, 0, 0, 1)">
    mul </span>=<span style="color: rgba(0, 0, 0, 1)"> inst.MontgomeryMultiply(a, b)
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> mul == (a*b)%<span style="color: rgba(0, 0, 0, 1)">N:
        </span><span style="color: rgba(0, 0, 255, 1)">print</span> (<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">({a}*{b})%{N} is {mul}</span><span style="color: rgba(128, 0, 0, 1)">'</span>.format(a = a, b = b, N = N, mul = mul))</pre>
</div>
<h1>参考</h1>
<p>本文参考了以下文章，一并表示感谢</p>
<p><a href="https://blog.csdn.net/weixin_46395886/article/details/112988136" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_46395886/article/details/112988136</a></p>
<p><a href="https://blog.csdn.net/zgzczzw/article/details/52712980" target="_blank" rel="noopener nofollow">https://blog.csdn.net/zgzczzw/article/details/52712980</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/566190498" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/566190498</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/581656171" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/581656171</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2163844957986111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-27 23:04">2025-02-27 23:04</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18740773" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18740773);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18740773', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18740773/Montgomery', title: '详解蒙哥马利算法' })">举报</a>
</div>
        