
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18898217" title="发布于 2025-05-27 10:58">
    <span role="heading" aria-level="2">AI智能体策略FunctionCalling和ReAct有什么区别？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Dify 内置了两种 Agent 策略：<strong>Function Calling 和 ReAct</strong>，但二者有什么区别呢？在使用时又该如何选择呢？接下来我们一起来看。</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202505/172074-20250527105834053-1492931131.png" alt="" loading="lazy"></p>
<h2 id="1function-calling">1.Function Calling</h2>
<p>Function Call 会通过将用户指令映射到预定义函数或工具，LLM 先识别用户意图，再决定调用哪个函数并提取所需参数。</p>
<p>它的核心是调用外部函数或工具，<strong>属于一种明确的工具调用机制</strong>。</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202505/172074-20250527105842597-84803302.png" alt="" loading="lazy"></p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>精确</strong>：对于明确的任务，可以直接调用相应的工具，无需复杂的推理过程。</li>
<li><strong>易于集成外部功能</strong>可以将各种外部 API 或工具封装成函数供模型调用。</li>
<li><strong>结构化输出</strong>：模型输出的是结构化的函数调用信息，方便下游节点处理。</li>
<li><strong>执行效率高</strong>：对于简单、明确的任务，执行速度快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果任务定义不明确或用户意图模糊，LLM 可能难以准确选择工具或提取参数。</li>
<li>对于需要多轮推理才能确定调用哪个工具的任务，不够灵活。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要根据用户意图精确调用特定工具的自动化任务。</li>
<li>需要与外部 API 或服务进行交互的场景。</li>
<li>数据检索、信息查询并以特定格式呈现的应用</li>
</ul>
<h2 id="2react">2.ReAct</h2>
<p><strong>ReAct=Reason+Act，推理+行动</strong>，LLM 首先思考当前状态和目标，然后选择并调用合适的工具，工具的输出结果又将引导 LLM 进行下一步的思考和行动，如此循环，直到问题解决。</p>
<h3 id="举例说明">举例说明</h3>
<p>举个例子，正常情况下，当我们在计算一个商品的价格时，它的执行步骤是这样的：</p>
<ol>
<li>查询商品原价。</li>
<li>计算商品优惠价。</li>
<li>计算商品最终价格=商品原价-优惠价。</li>
</ol>
<p>但某个商品情况比较特殊，它在以上第二步中存储的不是优惠价，而是折扣价（例如 8 折优惠），那么此时商品的最终价格的计算公式就变成了以下方式：</p>
<ol>
<li>查询商品原价。</li>
<li><strong>查询商品折扣价。</strong></li>
<li><strong>计算商品最终价格=商品原价 X 商品折扣价。</strong></li>
</ol>
<p>在这种情况下就要使用 ReAct 策略了，因为 ReAct 策略会根据第二步的观测结果，分析并改变第三步的计算公式，保证任务的精准执行，这种情况下就要使用 React 策略。</p>
<p><strong>核心机制</strong>：</p>
<ul>
<li>ReAct 是一个迭代过程，LLM 在“思考（Reason）-&gt; 行动（Act）-&gt; 观察（Observe）”的循环中逐步推进任务。</li>
<li>LLM 首先分析当前状态和目标，选择并调用工具，然后根据工具的输出进行下一步的思考和行动，直到问题解决。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>利用外部信息</strong>：可以有效使用外部工具来收集模型单独无法处理的任务所需的信息。</li>
<li><strong>可解释性好</strong>：推理和行动步骤交织在一起，允许一定程度上跟踪 Agent 的过程。</li>
<li><strong>广泛适用性</strong>：适用于需要外部知识或特定行动的任务，例如问答、信息检索和任务执行。</li>
<li><strong>灵活性高</strong>：对于复杂、多步骤的任务，以及需要探索和动态调整策略的场景，具有更好的适应性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>执行速度和成本</strong>：由于涉及多次 LLM 调用，ReAct 通常比 Function Calling 更慢，并且消耗更多的 tokens。</li>
<li><strong>推理稳定性</strong>：在很大程度上取决于 LLM 的推理能力以及提示（Instruction）的质量。</li>
<li><strong>输出解析复杂</strong>：ReAct 过程中 LLM 产生的“思考”文本格式可能不一致，给解析和提取关键信息带来挑战。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要进行探索性研究、从多个来源收集和综合信息的任务。</li>
<li>问题解决方案路径不明确，需要通过迭代尝试和调整来找到答案的复杂问题。</li>
<li>需要较高可解释性，希望了解 Agent 决策过程的场景。</li>
</ul>
<h2 id="3function-calling-vs-react">3.Function Calling VS React</h2>
<p>Function Calling 和 React 区别如下：</p>
<ul>
<li>Function Calling 更适合简单、明确的任务，强调直接调用工具的高效性。</li>
<li>ReAct 更适合复杂、多步骤的任务，强调推理过程的灵活性和可解释性。</li>
</ul>
<blockquote>
<p>本文已收录到我的技术小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：Spring AI、LangChain4j、Dify、AI Agent、MCP、Function Call、RAG、向量数据库、Prompt、多模态、向量数据库、嵌入模型等内容。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.006584396866898148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 10:59">2025-05-27 10:58</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18898217);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18898217', targetLink: 'https://www.cnblogs.com/vipstone/p/18898217', title: 'AI智能体策略FunctionCalling和ReAct有什么区别？' })">举报</a>
</div>
        