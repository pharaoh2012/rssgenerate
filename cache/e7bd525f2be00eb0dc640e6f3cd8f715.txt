
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18682229" title="发布于 2025-01-28 17:27">
    <span role="heading" aria-level="2">【编码】自定义通信协议——支持更多请求类型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>前言</h3>
<p>上一篇随笔"<a href="https://www.cnblogs.com/longfurcat/p/18653392" target="_blank">如何实现一套自定义网络协议</a>"，介绍了自定义协议的粘拆包的处理，消息体的编解码等。</p>
<p>其中包含一个案例，演示怎么实现一个RPC实现。</p>
<p>不过案例中的Request格式是固定的，实际应用中，RPC协议需要支持不同的API。</p>
<p>所以需要有一个字段来表示API类型，而字段的存放位置有两种选择</p>
<p>1）消息头的第一个字节</p>
<p>2）消息体</p>
<p>一个字节能表示值0~255。如果使用这个字节来表示请求类型，可能不够用。</p>
<p>所以本文具体的API定义在消息体中。</p>
<h3>协议回顾</h3>
<p>数据包=消息头（4字节）+消息体（n字节）</p>
<p>消息头=类型（1字节）+消息体长度（3字节）</p>
<p>类型值：</p>
<ul>
<li>1 =&gt; 请求</li>
<li>2 =&gt; 响应</li>
<li>3 =&gt; Ping</li>
<li>4 =&gt; Pong</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250128153430626-1712297009.png" alt="" width="482" height="287" loading="lazy"></p>
<h3>协议补充</h3>
<p>以下格式设计针对“<strong>请求-响应</strong>”的消息体</p>
<p><strong>1）请求</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">message Header {
    required string key </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    required string value </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
}

message BaseRequest {
    required int32 api </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    required int32 version </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
    required int32 msgId </span>= 3<span style="color: rgba(0, 0, 0, 1)">;
    repeated Header headers </span>= 4<span style="color: rgba(0, 0, 0, 1)">;
    optional bytes data </span>= 5<span style="color: rgba(0, 0, 0, 1)">;
}

message HelloRequestData {
    required string content </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>固定部分</p>
<ul>
<li>api：请求类型，int32</li>
<li>version：请求版本，int32</li>
<li>msgId：请求ID，int32</li>
</ul>
<p>可变Header</p>
<ul>
<li>headers：key-value</li>
</ul>
<p>可变Data</p>
<ul>
<li>bytes</li>
</ul>
<p>解析方式：</p>
<p>1.处理粘拆包，得到完整消息体</p>
<p>2.使用protobuf解析消息体，读取消息体中的api字段</p>
<p>3.根据api字段知道请求类型，使用对应的protobuf解析data，得到请求payload对象</p>
<p><strong>2）响应</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">message BaseResponse {
    required int32 msgId </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    repeated Header headers </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
    optional bytes data </span>= 3<span style="color: rgba(0, 0, 0, 1)">;
}

message HelloResponseData {
    required int32 code </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    required string content </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>固定部分</p>
<ul>
<li>msgId: 请求ID，int32</li>
</ul>
<p>可变Header部分</p>
<ul>
<li>headers: key-value</li>
</ul>
<p>可变Data</p>
<ul>
<li>bytes</li>
</ul>
<p>处理方式：</p>
<p>1.构建响应Data</p>
<p>2.构建BaseResponse</p>
<p>3.将Data转成ByteString塞入BaseResponse</p>
<h3>基础建设——连接管理</h3>
<p>连接管理包含两部分：</p>
<ul>
<li>存储Socket关联关系
<ul>
<li>使用Map存储每个Socket的关联关系，便于后续引用。</li>
</ul>
</li>
<li>Socket心跳检查
<ul>
<li>通过Ping-Pong机制，定期检查客户端的连接状态，及时识别无响应的客户端并释放服务端资源。</li>
</ul>
</li>
</ul>
<p><strong>释放什么资源？</strong></p>
<p>socket需要占用服务端的内存资源（发送和接收缓冲区），还有文件描述符</p>
<p><strong>客户端什么时候会出现无响应？</strong></p>
<ul>
<li>客户端进程卡死，例如死锁或CPU饱和。</li>
<li>客户端意外断开（如断电，系统崩溃），无法发送TCP的FIN包来关闭连接。服务端无法感知到连接关闭</li>
</ul>
<p>ConnectionManager</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_8ff16325-1656-4e37-aae8-00ee207e6f91" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_8ff16325-1656-4e37-aae8-00ee207e6f91" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_8ff16325-1656-4e37-aae8-00ee207e6f91" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ConnectionManager {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> final Timer timer = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HashedWheelTimer();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> final <span style="color: rgba(0, 0, 255, 1)">long</span> HEARTBEAT_INTERVAL = <span style="color: rgba(128, 0, 128, 1)">10</span>;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 10秒</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> final <span style="color: rgba(0, 0, 255, 1)">long</span> HEARTBEAT_TIMEOUT = <span style="color: rgba(128, 0, 128, 1)">30</span>;    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 30秒超时</span>

    <span style="color: rgba(0, 0, 255, 1)">private</span> final Map&lt;String, ChannelHandlerContext&gt; connectionMap = <span style="color: rgba(0, 0, 255, 1)">new</span> ConcurrentHashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> final Map&lt;String, HeartBeatTask&gt; taskMap = <span style="color: rgba(0, 0, 255, 1)">new</span> ConcurrentHashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> addConnection(String id, ChannelHandlerContext ctx) {
        connectionMap.put(id, ctx);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建心跳定时任务</span>
        HeartBeatTask heartBeatTask = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HeartBeatTask(ctx.channel());
        timer.newTimeout(heartBeatTask, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);
        taskMap.put(id, heartBeatTask);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ChannelHandlerContext getConnection(String id) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> connectionMap.<span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">(id);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> removeConnection(String id) {
        System.</span><span style="color: rgba(0, 0, 255, 1)">out</span>.println(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">断开连接：</span><span style="color: rgba(128, 0, 0, 1)">"</span>+<span style="color: rgba(0, 0, 0, 1)">id);
        connectionMap.remove(id);
        taskMap.remove(id);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onHeartbeatResponse(String id) {
        System.</span><span style="color: rgba(0, 0, 255, 1)">out</span>.println(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">收到Pong:</span><span style="color: rgba(128, 0, 0, 1)">"</span>+<span style="color: rgba(0, 0, 0, 1)">id);
        HeartBeatTask task </span>= taskMap.<span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">(id);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(task)) {
            task.onHeartbeatReceived();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> clear() {
        connectionMap.clear();
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> HeartBeatTask implements TimerTask {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> final Channel channel;
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">long</span><span style="color: rgba(0, 0, 0, 1)"> lastHeartbeatTime;


        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> HeartBeatTask(Channel channel) {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.channel =<span style="color: rgba(0, 0, 0, 1)"> channel;
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.lastHeartbeatTime =<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();
        }


        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> run(Timeout timeout) throws Exception {
            </span><span style="color: rgba(0, 0, 255, 1)">long</span> now =<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();

            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(now - lastHeartbeatTime &gt; HEARTBEAT_TIMEOUT * <span style="color: rgba(128, 0, 128, 1)">1000</span><span style="color: rgba(0, 0, 0, 1)">) {
                System.</span><span style="color: rgba(0, 0, 255, 1)">out</span>.println(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Heartbeat timeout, disconnecting channel </span><span style="color: rgba(128, 0, 0, 1)">"</span> +<span style="color: rgba(0, 0, 0, 1)"> channel.id().asLongText());
                channel.close();
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            }

            sendHeartbeat();
        }

        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> sendHeartbeat() {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(channel.isActive()) {
                System.</span><span style="color: rgba(0, 0, 255, 1)">out</span>.println(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">发送Ping:</span><span style="color: rgba(128, 0, 0, 1)">"</span>+<span style="color: rgba(0, 0, 0, 1)">channel.id().asLongText());

                channel.pipeline().writeAndFlush(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Ping());

                timer.newTimeout(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);
            }
        }

        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onHeartbeatReceived() {
            lastHeartbeatTime </span>=<span style="color: rgba(0, 0, 0, 1)"> System.currentTimeMillis();
        }
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">查看代码</span></div>
<p>ServerMessageHandler</p>
<div class="cnblogs_code">
<pre>   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接建立后，塞入ConnectionManager </span>
<span style="color: rgba(0, 0, 0, 1)">   @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelActive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.channelActive(ctx);
        Container.getBean(ConnectionManager.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).addConnection(ctx.channel().id().asLongText(), ctx);
    }

   </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接断开后，从ConnectionManager移除
   </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">这里是TCP能检测到的断连。</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelInactive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.channelInactive(ctx);
        Container.getBean(ConnectionManager.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).removeConnection(ctx.channel().id().asLongText());
    }</span></pre>
</div>
<p>ClientMessageHandler</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead0(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> BaseResponse) {
            ClientApi clientApi </span>= Container.getBean(ClientApi.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(clientApi)) {
                clientApi.onResponse((BaseResponse) msg);
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Ping) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">立即返回Pong包</span>
            ctx.writeAndFlush(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Pong());
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            System.out.println(</span>"未知消息："+<span style="color: rgba(0, 0, 0, 1)">msg);
        }
    }</span></pre>
</div>
<p>其中Ping-Pong都是空对象，编码成报文的时候，只有消息头，也就是只有4个字节。</p>
<h3>基础建设——Handler线程池</h3>
<p>在现行的框架中，NIO网络线程都是只负责数据包的解析工作，其他的业务逻辑处理则交由独立的线程池进行。</p>
<p><strong>为什么这样做呢？</strong></p>
<p>这种设计的核心目的是避免阻塞NIO线程。如果将数据包的解析和后续的业务处理都放在NIO线程中进行，肯会导致该线程忙于处理当前的数据包，从而无法及时处理其他客户端的请求。这不仅会影响系统的响应性能，还可能导致Socket阻塞或线程饥饿，最终导致系统吞吐量下降，响应延迟增大。</p>
<p><strong>处理模型</strong></p>
<p>所以我们可以将解析出来的请求，放到一个请求队列，然后由线程池去异步处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250128155051239-1907016007.png" alt="" width="708" height="270" loading="lazy"></p>
<p>RequestChannel</p>
<p>只有一个ArrayBlockingQueue队列</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_09e99fec-8603-4083-b6d0-decaef84c48b" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_09e99fec-8603-4083-b6d0-decaef84c48b" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_09e99fec-8603-4083-b6d0-decaef84c48b" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RequestChannel {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> ArrayBlockingQueue&lt;WrapRequest&gt; queue = <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayBlockingQueue&lt;&gt;(50<span style="color: rgba(0, 0, 0, 1)">);

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> addRequest(WrapRequest helloRequest) {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            queue.put(helloRequest);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (InterruptedException e) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> RuntimeException("写入队列失败"<span style="color: rgba(0, 0, 0, 1)">);
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> WrapRequest getRequest(<span style="color: rgba(0, 0, 255, 1)">long</span> timeout, TimeUnit timeUnit) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> InterruptedException {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> queue.poll(timeout, timeUnit);
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>RequestHandlerPool</p>
<p>多个处理线程并发从请求队列中拉取请求，然后根据API选择处理函数进行处理。</p>
<p>这里处理函数直接写在RequestHandlerPool，后续可以改成注册式的。一个API一个处理函数。</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_e4eab802-0523-4c92-995f-e0e1ec2cd0ff" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_e4eab802-0523-4c92-995f-e0e1ec2cd0ff" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_e4eab802-0523-4c92-995f-e0e1ec2cd0ff" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RequestHandlerPool {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> threadSize;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> List&lt;Thread&gt;<span style="color: rgba(0, 0, 0, 1)"> workerThreads;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> RequestChannel requestChannel;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> ConnectionManager connectionManager;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> RequestHandlerPool(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> threadSize) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.threadSize =<span style="color: rgba(0, 0, 0, 1)"> threadSize;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> start() {
        requestChannel </span>= Container.getBean(RequestChannel.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        connectionManager </span>= Container.getBean(ConnectionManager.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        workerThreads </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayList&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">(threadSize);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; threadSize; i++<span style="color: rgba(0, 0, 0, 1)">) {
            Thread worker </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> Thread(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">::pollAndHandle);
            worker.start();
            workerThreads.add(worker);
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> pollAndHandle() {
        </span><span style="color: rgba(0, 0, 255, 1)">while</span>(!<span style="color: rgba(0, 0, 0, 1)">Thread.interrupted()) {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                WrapRequest request </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                    request </span>= requestChannel.getRequest(5<span style="color: rgba(0, 0, 0, 1)">, TimeUnit.SECONDS);
                } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (InterruptedException e) {
                    e.printStackTrace();
                }
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.isNull(request)) {
                    </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                ChannelHandlerContext ctx </span>=<span style="color: rgba(0, 0, 0, 1)"> connectionManager.getConnection(request.getChannelId());
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.isNull(ctx)) {
                    </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                BaseRequest baseRequest </span>=<span style="color: rgba(0, 0, 0, 1)"> request.getRequest();

                </span><span style="color: rgba(0, 0, 255, 1)">int</span> apiKey =<span style="color: rgba(0, 0, 0, 1)"> baseRequest.getApi();
                </span><span style="color: rgba(0, 0, 255, 1)">switch</span><span style="color: rgba(0, 0, 0, 1)"> (apiKey) {
                    </span><span style="color: rgba(0, 0, 255, 1)">case</span> ApiKeys.HELLO: handleHelloRequest(baseRequest, ctx);<span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                    </span><span style="color: rgba(0, 0, 255, 1)">case</span> ApiKeys.DOWNLOAD: handleDownloadRequest(baseRequest, ctx);<span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                    </span><span style="color: rgba(0, 0, 255, 1)">default</span>: <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                }
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                System.out.println(</span>"处理请求失败"+<span style="color: rgba(0, 0, 0, 1)">e);
                e.printStackTrace();
            }

        }

    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> shutdown() {
        </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (Thread workerThread : workerThreads) {
            workerThread.interrupt();
        }
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>ServerMessageHandler</p>
<p>收到解析好的请求，包装后塞入队列</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead0(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> BaseRequest) {
            System.out.println(</span>"收到消息："+<span style="color: rgba(0, 0, 0, 1)">msg);
            BaseRequest baseRequest </span>=<span style="color: rgba(0, 0, 0, 1)"> (BaseRequest) msg;

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">塞入队列
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">需要包装一下，增加字段说明来自哪个channel，响应的时候知道如何处理
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">TODO也可增加入队时间，开始处理时间，完成处理时间。用于判断是否调整线程数量，以及是否丢弃超时请求</span>
            Container.getBean(RequestChannel.<span style="color: rgba(0, 0, 255, 1)">class</span>).addRequest(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> WrapRequest(ctx.channel().id().asLongText(), baseRequest));
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Pong) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">交由连接管理器处理</span>
            Container.getBean(ConnectionManager.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).onHeartbeatResponse(ctx.channel().id().asLongText());
        }
    }</span></pre>
</div>
<h3>案例——Hello请求</h3>
<p>1）客户端</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_139f2fb0-ef9e-4d32-b22d-fcdcfa33c090" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_139f2fb0-ef9e-4d32-b22d-fcdcfa33c090" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_139f2fb0-ef9e-4d32-b22d-fcdcfa33c090" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Test {
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main(String[] args) {
        ClientApi clientApi </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> ClientApi("127.0.0.1", 9090<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; 5; i++<span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                BaseRequest request </span>= buildHelloRequest(1000+<span style="color: rgba(0, 0, 0, 1)">i);

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">同步请求，收到响应后才会发下一个请求
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                BaseResponse response = clientApi.sendRequest(request);
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                System.out.println("同步收到：" + response.getMsgId() + "\n解析内容：" + HelloResponseData.parseFrom(response.getData().toByteArray()));
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">异步请求，发送完成即可发送下一个请求</span>
                clientApi.sendRequestAsync(request, response2 -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                    </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                        System.out.println(</span>"异步收到："+response2.getMsgId() + "\n解析内容：" +<span style="color: rgba(0, 0, 0, 1)"> HelloResponseData.parseFrom(response2.getData().toByteArray()));
                    } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (InvalidProtocolBufferException e) {
                        e.printStackTrace();
                    }
                    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
                });

            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                e.printStackTrace();
            }
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建请求</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> BaseRequest buildHelloRequest(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> id) {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> randomStrLength = RandomUtil.randomInt(100, 200<span style="color: rgba(0, 0, 0, 1)">);
        String content </span>=<span style="color: rgba(0, 0, 0, 1)"> RandomUtil.randomString(randomStrLength);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建请求内容proto</span>
        HelloRequestData data =<span style="color: rgba(0, 0, 0, 1)"> HelloRequestData.newBuilder()
                .setContent(content)
                .build();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建请求proto，指定API，塞入请求内容</span>
        BaseRequest request =<span style="color: rgba(0, 0, 0, 1)"> BaseRequest.newBuilder()
                .setApi(ApiKeys.HELLO)
                .setVersion(</span>1<span style="color: rgba(0, 0, 0, 1)">)
                .setMsgId(id)
                .setData(data.toByteString())
                .build();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> request;
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>2）服务端</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_f1991639-0cac-4718-9865-63153395f72e" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_f1991639-0cac-4718-9865-63153395f72e" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_f1991639-0cac-4718-9865-63153395f72e" class="cnblogs_code_hide">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> handleHelloRequest(BaseRequest baseRequest, ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] data =<span style="color: rgba(0, 0, 0, 1)"> baseRequest.getData().toByteArray();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解析请求内容proto</span>
        HelloRequestData helloRequestData =<span style="color: rgba(0, 0, 0, 1)"> HelloRequestData.parseFrom(data);
        String content </span>=<span style="color: rgba(0, 0, 0, 1)"> helloRequestData.getContent();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建响应内容proto</span>
        HelloResponseData helloResponseData =<span style="color: rgba(0, 0, 0, 1)"> HelloResponseData.newBuilder()
                .setCode(</span>200<span style="color: rgba(0, 0, 0, 1)">)
                .setContent(</span>"Handled:"+<span style="color: rgba(0, 0, 0, 1)">content)
                .build();
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建响应proto，塞入响应内容</span>
        BaseResponse response =<span style="color: rgba(0, 0, 0, 1)"> BaseResponse.newBuilder()
                .setMsgId(baseRequest.getMsgId())
                .setData(helloResponseData.toByteString())
                .build();
        ctx.writeAndFlush(response);
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>客户端输出：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">开始连接
发出消息：api: </span>1<span style="color: rgba(0, 0, 0, 1)">
version: </span>1<span style="color: rgba(0, 0, 0, 1)">
msgId: </span>1000<span style="color: rgba(0, 0, 0, 1)">
data: </span>"\n\203\001orL4AaLqgytpVNPc1fmhGV5TpSw8z41FdsqUzG1tpXloxWkwpxFh9gf8UF51vysakK0KrJd9K6R7BJGIC7ha9UIjA1VjaaNmJ6Crx5zhPZHuCUM4byAiS6XDpnXDU2XCVxe"<span style="color: rgba(0, 0, 0, 1)">

异步收到：</span>1000<span style="color: rgba(0, 0, 0, 1)">
解析内容：code: </span>200<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Handled:orL4AaLqgytpVNPc1fmhGV5TpSw8z41FdsqUzG1tpXloxWkwpxFh9gf8UF51vysakK0KrJd9K6R7BJGIC7ha9UIjA1VjaaNmJ6Crx5zhPZHuCUM4byAiS6XDpnXDU2XCVxe"<span style="color: rgba(0, 0, 0, 1)">

发出消息：api: </span>1<span style="color: rgba(0, 0, 0, 1)">
version: </span>1<span style="color: rgba(0, 0, 0, 1)">
msgId: </span>1001<span style="color: rgba(0, 0, 0, 1)">
data: </span>"\n\230\001Wsq1EGAZgE9NmHFSOdRUloqshSeA0yx6ZUspKrsO6PGF4fN3oNk5CDzjsUKYFCMfCFBjHkdjPpnSHPRNUSqS1kexFKAs06UQ9v9J28sK7alUCigx0AtoyE1Cxa4bPYoaqixkcG0sCfShIK8zglWAgRma"<span style="color: rgba(0, 0, 0, 1)">

发出消息：api: </span>1<span style="color: rgba(0, 0, 0, 1)">
version: </span>1<span style="color: rgba(0, 0, 0, 1)">
msgId: </span>1002<span style="color: rgba(0, 0, 0, 1)">
data: </span>"\n\247\00187Eh4Cw8FE29xBOWnR3RIH2efvMxT2LzMkCvRHxthStqcfspRZLsEYfX5q9YHBzgCswX0ManKbQXxticCnArmuhPX9qgP8epuisGnnrPzVO7FbyowkWPFu5vLbgW2w5QIr4rdIVmRCQAQliLyS56EtEaRn10AB4wEDpgJWL"<span style="color: rgba(0, 0, 0, 1)">

发出消息：api: </span>1<span style="color: rgba(0, 0, 0, 1)">
version: </span>1<span style="color: rgba(0, 0, 0, 1)">
msgId: </span>1003<span style="color: rgba(0, 0, 0, 1)">
data: </span>"\n\203\001sWCpHDYZpReZvOypclgQz6PQs901kbCPyzkhSEeS6nwGHQ7tO5Lzl9pT2V5xm8Vb89G9oy5K7OWlrdrAPag5JZ9dZY40WEgvbc5W0UFgIqKeS95dHqeWT8K1ifUzpy23dLQ"<span style="color: rgba(0, 0, 0, 1)">

异步收到：</span>1002<span style="color: rgba(0, 0, 0, 1)">
解析内容：code: </span>200<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Handled:87Eh4Cw8FE29xBOWnR3RIH2efvMxT2LzMkCvRHxthStqcfspRZLsEYfX5q9YHBzgCswX0ManKbQXxticCnArmuhPX9qgP8epuisGnnrPzVO7FbyowkWPFu5vLbgW2w5QIr4rdIVmRCQAQliLyS56EtEaRn10AB4wEDpgJWL"<span style="color: rgba(0, 0, 0, 1)">

异步收到：</span>1001<span style="color: rgba(0, 0, 0, 1)">
解析内容：code: </span>200<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Handled:Wsq1EGAZgE9NmHFSOdRUloqshSeA0yx6ZUspKrsO6PGF4fN3oNk5CDzjsUKYFCMfCFBjHkdjPpnSHPRNUSqS1kexFKAs06UQ9v9J28sK7alUCigx0AtoyE1Cxa4bPYoaqixkcG0sCfShIK8zglWAgRma"<span style="color: rgba(0, 0, 0, 1)">

发出消息：api: </span>1<span style="color: rgba(0, 0, 0, 1)">
version: </span>1<span style="color: rgba(0, 0, 0, 1)">
msgId: </span>1004<span style="color: rgba(0, 0, 0, 1)">
data: </span>"\n\300\001EUTkCNd5PV7IMzvTlTKLoM65CMhYjKo4r9jAodOugWfvudBEIxHJnlDed3MwpiyYxzmnDkoUdJY1r2pe8BU97iprzuDpyuPQp80Ds8BkccGZP2nBllIR28epbY1Du3ZoYV552hGKucpSwysqgSFVfc7hmEuo4iKsaJ9yl807l91hr6jqWc7PGZ4iime6Xzpo"<span style="color: rgba(0, 0, 0, 1)">

异步收到：</span>1003<span style="color: rgba(0, 0, 0, 1)">
解析内容：code: </span>200<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Handled:sWCpHDYZpReZvOypclgQz6PQs901kbCPyzkhSEeS6nwGHQ7tO5Lzl9pT2V5xm8Vb89G9oy5K7OWlrdrAPag5JZ9dZY40WEgvbc5W0UFgIqKeS95dHqeWT8K1ifUzpy23dLQ"<span style="color: rgba(0, 0, 0, 1)">

异步收到：</span>1004<span style="color: rgba(0, 0, 0, 1)">
解析内容：code: </span>200<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Handled:EUTkCNd5PV7IMzvTlTKLoM65CMhYjKo4r9jAodOugWfvudBEIxHJnlDed3MwpiyYxzmnDkoUdJY1r2pe8BU97iprzuDpyuPQp80Ds8BkccGZP2nBllIR28epbY1Du3ZoYV552hGKucpSwysqgSFVfc7hmEuo4iKsaJ9yl807l91hr6jqWc7PGZ4iime6Xzpo"</pre>
</div>
<h3>基于此协议实现文件下载——零拷贝</h3>
<p>//TBD</p>
<h3>基于此协议实现Raft选主</h3>
<p>//TBD</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03351054976273148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-28 17:27">2025-01-28 17:27</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18682229" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18682229);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18682229', targetLink: 'https://www.cnblogs.com/longfurcat/p/18682229', title: '【编码】自定义通信协议——支持更多请求类型' })">举报</a>
</div>
        