
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18855000" title="发布于 2025-04-30 16:15">
    <span role="heading" aria-level="2">原码、反码、补码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-原码sign-magnitude" rel="noopener nofollow"><strong>1. 原码（Sign-Magnitude）</strong></a><ul><li><a href="#定义" rel="noopener nofollow"><strong>定义</strong></a></li><li><a href="#特点" rel="noopener nofollow"><strong>特点</strong></a></li><li><a href="#使用场景" rel="noopener nofollow"><strong>使用场景</strong></a></li></ul></li><li><a href="#2-反码ones-complement" rel="noopener nofollow"><strong>2. 反码（Ones' Complement）</strong></a><ul><li><a href="#定义-1" rel="noopener nofollow"><strong>定义</strong></a></li><li><a href="#特点-1" rel="noopener nofollow"><strong>特点</strong></a></li><li><a href="#使用场景-1" rel="noopener nofollow"><strong>使用场景</strong></a></li></ul></li><li><a href="#3-补码twos-complement" rel="noopener nofollow"><strong>3. 补码（Two's Complement）</strong></a><ul><li><a href="#定义-2" rel="noopener nofollow"><strong>定义</strong></a></li><li><a href="#特点-2" rel="noopener nofollow"><strong>特点</strong></a></li><li><a href="#使用场景-2" rel="noopener nofollow"><strong>使用场景</strong></a></li></ul></li><li><a href="#4-为什么需要反码和补码" rel="noopener nofollow"><strong>4. 为什么需要反码和补码？</strong></a><ul><li><a href="#1解决-0-和--0-问题" rel="noopener nofollow"><strong>（1）解决 <code>+0</code> 和 <code>-0</code> 问题</strong></a></li><li><a href="#2统一加减运算" rel="noopener nofollow"><strong>（2）统一加减运算</strong></a></li><li><a href="#3硬件优化" rel="noopener nofollow"><strong>（3）硬件优化</strong></a></li></ul></li><li><a href="#5-实际应用示例" rel="noopener nofollow"><strong>5. 实际应用示例</strong></a><ul><li><a href="#1java-中的-byte-类型" rel="noopener nofollow"><strong>（1）Java 中的 <code>byte</code> 类型</strong></a></li><li><a href="#2无符号转换" rel="noopener nofollow"><strong>（2）无符号转换</strong></a></li><li><a href="#3网络协议--文件解析" rel="noopener nofollow"><strong>（3）网络协议 &amp; 文件解析</strong></a></li></ul></li><li><a href="#6-总结" rel="noopener nofollow"><strong>6. 总结</strong></a></li><li><a href="#示例" rel="noopener nofollow">示例</a><ul><li><a href="#为什么-在java中-0xfc-变成--4" rel="noopener nofollow"><strong>为什么 在Java中 <code>0xFC</code> 变成 <code>-4</code>？</strong></a></li><li><a href="#示例代码" rel="noopener nofollow"><strong>示例代码</strong></a></li><li><a href="#如何正确查看-0xfc" rel="noopener nofollow"><strong>如何正确查看 <code>0xFC</code>？</strong></a></li><li><a href="#关键点总结" rel="noopener nofollow"><strong>关键点总结</strong></a></li><li><a href="#为什么-java-的-byte-是有符号的" rel="noopener nofollow"><strong>为什么 Java 的 <code>byte</code> 是有符号的？</strong></a></li><li><a href="#适用场景" rel="noopener nofollow"><strong>适用场景</strong></a></li></ul></li></ul></div><br>
在计算机中，<strong>原码、反码、补码</strong> 是表示有符号整数的三种方式，主要用于解决 <strong>负数存储和运算</strong> 的问题。它们的定义、作用及使用场景如下：<p></p>
<hr>
<h2 id="1-原码sign-magnitude"><strong>1. 原码（Sign-Magnitude）</strong></h2>
<h3 id="定义"><strong>定义</strong></h3>
<ul>
<li><strong>最高位表示符号</strong>（<code>0</code> 为正，<code>1</code> 为负），其余位表示数值。</li>
<li>例如，8 位二进制：
<ul>
<li><code>+5</code> 的原码：<code>0000 0101</code></li>
<li><code>-5</code> 的原码：<code>1000 0101</code></li>
</ul>
</li>
</ul>
<h3 id="特点"><strong>特点</strong></h3>
<ul>
<li>直观，人类容易理解。</li>
<li><strong>问题</strong>：
<ul>
<li><strong><code>+0</code> 和 <code>-0</code> 不唯一</strong>（<code>0000 0000</code> 和 <code>1000 0000</code>）。</li>
<li><strong>加减运算复杂</strong>，需要额外判断符号位。</li>
</ul>
</li>
</ul>
<h3 id="使用场景"><strong>使用场景</strong></h3>
<ul>
<li>早期计算机（如 IBM 701）使用原码，但现代计算机基本不再使用。</li>
</ul>
<hr>
<h2 id="2-反码ones-complement"><strong>2. 反码（Ones' Complement）</strong></h2>
<h3 id="定义-1"><strong>定义</strong></h3>
<ul>
<li><strong>正数</strong>：反码 = 原码。</li>
<li><strong>负数</strong>：符号位不变，其余位 <strong>按位取反</strong>。</li>
<li>例如：
<ul>
<li><code>+5</code> 的反码：<code>0000 0101</code>（同原码）</li>
<li><code>-5</code> 的反码：<code>1111 1010</code>（符号位 <code>1</code>，数值位取反）</li>
</ul>
</li>
</ul>
<h3 id="特点-1"><strong>特点</strong></h3>
<ul>
<li>解决了 <code>+0</code> 和 <code>-0</code> 的问题（反码下 <code>-0</code> 是 <code>1111 1111</code>，但仍有冗余）。</li>
<li><strong>缺点</strong>：
<ul>
<li>加减运算仍需处理进位（如 <code>-5 + 5 = 1111 1010 + 0000 0101 = 1111 1111</code>，即 <code>-0</code>）。</li>
<li>硬件实现复杂。</li>
</ul>
</li>
</ul>
<h3 id="使用场景-1"><strong>使用场景</strong></h3>
<ul>
<li>早期计算机（如 PDP-1）使用反码，但已被补码取代。</li>
</ul>
<hr>
<h2 id="3-补码twos-complement"><strong>3. 补码（Two's Complement）</strong></h2>
<h3 id="定义-2"><strong>定义</strong></h3>
<ul>
<li><strong>正数</strong>：补码 = 原码。</li>
<li><strong>负数</strong>：反码 + 1（即 <strong>取反后加 1</strong>）。</li>
<li>例如：
<ul>
<li><code>+5</code> 的补码：<code>0000 0101</code>（同原码）</li>
<li><code>-5</code> 的补码：<pre><code>原码：1000 0101
反码：1111 1010
补码：1111 1011 （反码 + 1）
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="特点-2"><strong>特点</strong></h3>
<ul>
<li><strong>解决了 <code>+0</code> 和 <code>-0</code> 问题</strong>（补码下 <code>-0</code> 表示为 <code>0000 0000</code>，与 <code>+0</code> 相同）。</li>
<li><strong>加减运算统一</strong>（直接按二进制加法计算，无需额外处理符号位）。</li>
<li><strong>硬件实现简单</strong>（只需加法器，无需额外电路）。</li>
</ul>
<h3 id="使用场景-2"><strong>使用场景</strong></h3>
<ul>
<li><strong>现代计算机（包括 Java）全部使用补码存储有符号整数</strong>。</li>
<li>例如：
<ul>
<li>Java 的 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 均用补码表示。</li>
<li><code>0xFC</code>（<code>1111 1100</code>）在 <code>byte</code> 类型中表示 <code>-4</code>（因为补码计算：<code>~1111 1100 + 1 = 0000 0100</code>，即 <code>-4</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-为什么需要反码和补码"><strong>4. 为什么需要反码和补码？</strong></h2>
<h3 id="1解决-0-和--0-问题"><strong>（1）解决 <code>+0</code> 和 <code>-0</code> 问题</strong></h3>
<ul>
<li>原码和反码中，<code>+0</code> 和 <code>-0</code> 的表示不同，导致比较和运算复杂。</li>
<li>补码中 <code>0</code> 只有一种表示（<code>0000 0000</code>），简化逻辑。</li>
</ul>
<h3 id="2统一加减运算"><strong>（2）统一加减运算</strong></h3>
<ul>
<li>补码下，<strong>减法可以转换为加法</strong>（<code>A - B = A + (-B)</code>），硬件只需加法器。
<ul>
<li>例如：<code>5 - 3 = 5 + (-3)</code>：<pre><code>5 的补码：0000 0101
-3 的补码：1111 1101
相加：0000 0101 + 1111 1101 = 0000 0010 （即 2）
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3硬件优化"><strong>（3）硬件优化</strong></h3>
<ul>
<li>补码运算无需额外判断符号位，减少电路复杂度。</li>
</ul>
<hr>
<h2 id="5-实际应用示例"><strong>5. 实际应用示例</strong></h2>
<h3 id="1java-中的-byte-类型"><strong>（1）Java 中的 <code>byte</code> 类型</strong></h3>
<pre><code class="language-java">byte b = (byte) 0xFC; // 0xFC = 1111 1100（补码）
System.out.println(b); // 输出 -4（因为补码 1111 1100 表示 -4）
</code></pre>
<h3 id="2无符号转换"><strong>（2）无符号转换</strong></h3>
<p>由于 Java 没有无符号 <code>byte</code>，需用 <code>&amp; 0xFF</code> 转换：</p>
<pre><code class="language-java">int unsignedValue = b &amp; 0xFF; // 0xFC（252）
System.out.println(unsignedValue); // 输出 252
</code></pre>
<h3 id="3网络协议--文件解析"><strong>（3）网络协议 &amp; 文件解析</strong></h3>
<ul>
<li>读取 TCP/IP 报文、二进制文件时，数据可能是补码形式，需按补码解析：<pre><code class="language-java">// 从文件读取 2 字节的 short（补码存储）
short value = (short) ((bytes[0] &lt;&lt; 8) | (bytes[1] &amp; 0xFF));
</code></pre>
</li>
</ul>
<hr>
<h2 id="6-总结"><strong>6. 总结</strong></h2>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原码</strong></td>
<td>符号位 + 绝对值</td>
<td>直观</td>
<td><code>±0</code> 问题，运算复杂</td>
<td>早期计算机</td>
</tr>
<tr>
<td><strong>反码</strong></td>
<td>负数：符号位 + 取反</td>
<td>解决 <code>±0</code> 问题</td>
<td>运算仍有进位问题</td>
<td>过渡方案（如 PDP-1）</td>
</tr>
<tr>
<td><strong>补码</strong></td>
<td>负数：反码 + 1</td>
<td>统一加减法，硬件简单</td>
<td>无</td>
<td>现代计算机（Java/C/C++）</td>
</tr>
</tbody>
</table>
<p><strong>补码是现代计算机的标准选择</strong>，因其运算高效、硬件友好。理解补码是处理二进制数据、网络协议、文件解析的基础。</p>
<h2 id="示例">示例</h2>
<p><img src="https://img2024.cnblogs.com/blog/80824/202504/80824-20250430145218235-533981990.png" alt="image" loading="lazy"></p>
<p>在 Java 中，<code>byte</code> 类型是 <strong>有符号的 8 位整数</strong>，<strong>现代计算机（包括 Java）全部使用补码存储有符号整数</strong>，第一位为符号位，取值范围是 <code>10000000 ~ 01111111</code>，即：<strong>-128 到 127</strong> （即 <code>0x80</code> 到 <code>0x7F</code>）。<br>
<code>0xFC</code>（二进制 <code>1111 1100</code>）到 <code>byte</code> 变量时，Java 会将其解释为 <strong>有符号的补码（two's complement）</strong>，因此 <code>0xFC</code> 会被视为 <code>-4</code>。</p>
<hr>
<h3 id="为什么-在java中-0xfc-变成--4"><strong>为什么 在Java中 <code>0xFC</code> 变成 <code>-4</code>？</strong></h3>
<ol>
<li>
<p><strong><code>byte</code> 是有符号的</strong>：</p>
<ul>
<li><code>0xFC</code>（二进制 <code>1111 1100</code>）的最高位是 <code>1</code>，表示它是一个负数。</li>
<li>Java 使用 <strong>补码（two's complement）</strong> 表示负数。</li>
</ul>
</li>
<li>
<p><strong>补码转十进制</strong>：</p>
<ul>
<li>补码的规则：<code>负数值 = 原码取反 + 1</code>。</li>
<li><code>0xFC</code>（<code>1111 1100</code>）是某个负数的补码，计算它的原码：<pre><code>补码: 1111 1100 (0xFC)
取反: 1000 0011
+1  : 1000 0100 (结果是 -4)
</code></pre>
</li>
<li>因此，<code>0xFC</code> 表示 <code>-4</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例代码"><strong>示例代码</strong></h3>
<pre><code class="language-java">byte b = (byte) 0xFC; // 0xFC 被强制转换为 byte 类型
System.out.println(b); // 输出 -4
System.out.println(Integer.toHexString(b &amp; 0xFF)); // 输出 "fc"（正确显示无符号值）
</code></pre>
<hr>
<h3 id="如何正确查看-0xfc"><strong>如何正确查看 <code>0xFC</code>？</strong></h3>
<p>如果你希望在调试或打印时看到 <code>0xFC</code> 而不是 <code>-4</code>，可以：</p>
<ol>
<li>
<p><strong>用 <code>&amp; 0xFF</code> 转为无符号 int</strong>：</p>
<pre><code class="language-java">byte b = (byte) 0xFC; // 0xFC 被强制转换为 byte 类型
int unsignedValue = b &amp; 0xFF; // 0xFC (252)
System.out.println(unsignedValue); // 输出 252
System.out.println(Integer.toHexString(unsignedValue)); // 输出 "fc"
</code></pre>
<ul>
<li><code>&amp; 0xFF</code> 的作用是清除高位符号扩展，保留低 8 位。 <a href="https://www.cnblogs.com/vipsoft/p/16241685.html" target="_blank">https://www.cnblogs.com/vipsoft/p/16241685.html</a></li>
</ul>
</li>
<li>
<p><strong>使用 <code>Byte.toUnsignedInt()</code>（Java 8+）</strong>：</p>
<pre><code class="language-java">byte b = (byte) 0xFC; // 0xFC 被强制转换为 byte 类型
int unsignedValue = Byte.toUnsignedInt(b); // 252
</code></pre>
</li>
</ol>
<hr>
<h3 id="关键点总结"><strong>关键点总结</strong></h3>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>值（十进制）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0xFC</code>（原始值）</td>
<td>-4</td>
<td>Java <code>byte</code> 是有符号的，<code>0xFC</code> 是 <code>-4</code> 的补码</td>
</tr>
<tr>
<td><code>b &amp; 0xFF</code></td>
<td>252</td>
<td>转为无符号整数，正确显示 <code>0xFC</code></td>
</tr>
<tr>
<td><code>Byte.toUnsignedInt(b)</code></td>
<td>252</td>
<td>Java 8 提供的无符号转换方法</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="为什么-java-的-byte-是有符号的"><strong>为什么 Java 的 <code>byte</code> 是有符号的？</strong></h3>
<ul>
<li>Java 的设计遵循了 C/C++ 的传统，<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 默认都是有符号的。</li>
<li>如果需要无符号操作，可以通过 <code>&amp; 0xFF</code> 或 <code>Byte.toUnsignedInt()</code> 转换。</li>
</ul>
<hr>
<h3 id="适用场景"><strong>适用场景</strong></h3>
<ul>
<li>处理二进制协议或文件时，可能需要无符号字节（如 RGB 颜色值、网络协议字段）。</li>
<li>调试时若看到负数，记得用 <code>&amp; 0xFF</code> 转换查看原始十六进制值。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18855000" target="_blank">https://www.cnblogs.com/vipsoft/p/18855000</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0036165850069445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-30 16:16">2025-04-30 16:15</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">139</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18855000);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18855000', targetLink: 'https://www.cnblogs.com/vipsoft/p/18855000', title: '原码、反码、补码' })">举报</a>
</div>
        