
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vivotech/p/19037415" title="发布于 2025-08-14 11:28">
    <span role="heading" aria-level="2">vivo Pulsar 万亿级消息处理实践（4）-Ansible运维部署</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本篇文章主要从Pulsar运维痛点、Ansible简介、Ansible核心模块详解、Ansible自动化部署zk集群、Ansible自动化部署Pulsar集群几个维度向大家介绍vivo Pulsar万亿级消息处理实践之运维部署。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<blockquote data-pm-slice="0 0 []">
<p>作者：Liu Sikang、互联网大数据团队-Luo Mingbo</p>
<p>Pulsar作为下一代云原生架构的分布式消息中间件，存算分离的架构设计能有效解决大数据场景下分布式消息中间件老牌一哥“Kafka”存在的诸多问题，2021年vivo 分布式消息中间件团队正式开启对Pulsar的调研，2022年正式引入Pulsar作为大数据场景下的分布式消息中间件，本篇文章主要从Pulsar运维痛点、Ansible简介、Ansible核心模块详解、Ansible自动化部署zk集群、Ansible自动化部署Pulsar集群几个维度向大家介绍vivo Pulsar万亿级消息处理实践之运维部署。</p>
<p>注：本文是《vivo Pulsar万亿级消息处理实践》系列文章第4篇。</p>
</blockquote>
<p>&nbsp;</p>
<p>1分钟看图掌握核心观点👇</p>
<p><img alt="图片" data-pm-attrs="{&quot;src&quot;:&quot;https://static001.geekbang.org/infoq/03/035c9f5b5de28e1a73c5033ffd56c052.gif&quot;,&quot;alt&quot;:&quot;图片&quot;,&quot;title&quot;:null,&quot;style&quot;:[{&quot;key&quot;:&quot;width&quot;,&quot;value&quot;:&quot;75%&quot;},{&quot;key&quot;:&quot;bordertype&quot;,&quot;value&quot;:&quot;none&quot;}],&quot;href&quot;:null,&quot;fromPaste&quot;:true,&quot;pastePass&quot;:true}" data-src="https://static001.geekbang.org/infoq/03/035c9f5b5de28e1a73c5033ffd56c052.gif" class="lazyload"></p>
<p>&nbsp;</p>
<h1>1、简介</h1>
<h2>1.1 Pulsar 运维面临的问题</h2>
<p>新业务增长快，很多新业务接入需要搭建独立的集群或者资源组。</p>
<p>升级频次高，对于bug修复，配置更改以及依赖组件替换等，都需要对全集群进行升级、配置更改或组件替换。</p>
<p>人力投入大，在集群运维时，需要对公共的执行步骤进行批处理封装，否则会耗费大量人力在集群的部署和升级上。</p>
<p>&nbsp;</p>
<h2>1.2 什么是 Ansible Playbook</h2>
<p>Asnible Playbooks是Ansible自动化工具的核心部分。它是基于YAML文件格式，用于在多个主机上执行的任务。通过在Playbook中设置变量、处理器、角色和任务标签等功能，可以大大提高自动化脚本的复用性和可维护性。可以理解为批处理任务。</p>
<p><img alt="图片" data-pm-attrs="{&quot;src&quot;:&quot;https://static001.geekbang.org/infoq/7d/7d2e4e90dc040b59c77998db065ee4a6.png&quot;,&quot;alt&quot;:&quot;图片&quot;,&quot;title&quot;:null,&quot;style&quot;:[{&quot;key&quot;:&quot;width&quot;,&quot;value&quot;:&quot;75%&quot;},{&quot;key&quot;:&quot;bordertype&quot;,&quot;value&quot;:&quot;none&quot;}],&quot;href&quot;:null,&quot;fromPaste&quot;:true,&quot;pastePass&quot;:true}" data-src="https://static001.geekbang.org/infoq/7d/7d2e4e90dc040b59c77998db065ee4a6.png" class="lazyload"></p>
<p>&nbsp;</p>
<p>上图中我们看到Playbook的主要模块如下：</p>
<ul>
<li>
<p><strong>Ansible</strong>：Ansible 的核心程序。</p>
</li>
<li>
<p><strong>HostInventory</strong>：记录由 Ansible 管理的主机信息，包括端口、密码、ip 等。</p>
</li>
<li>
<p><strong>Playbooks</strong>：“剧本” YAML 格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。</p>
</li>
<li>
<p><strong>CoreModules</strong>：核心模块，主要操作是通过调用核心模块来完成管理任务。</p>
</li>
<li>
<p><strong>CustomModules</strong>：自定义模块，完成核心模块无法完成的功能，支持多种语言。</p>
</li>
<li>
<p><strong>ConnectionPlugins</strong>：连接插件，Ansible 和 Host 通信使用。</p>
</li>
</ul>
<p>&nbsp;</p>
<h1>2、Playbook 语法</h1>
<h2>2.1 书写格式</h2>
<p>playbook 常用到的YMAL格式：</p>
<ul>
<li>
<p>文件的第一行应该以 "---" (三个连字符)开始，表明 YMAL 文件的开始。</p>
</li>
<li>
<p>在同一行中，# 之后的内容表示注释，类似于 shell，python 和 ruby。</p>
</li>
<li>
<p>YMAL 中的列表元素以 ”-” 开头然后紧跟着一个空格，后面为元素内容。</p>
</li>
<li>
<p>同一个列表中的元素应该保持相同的缩进。否则会被当做错误处理。</p>
</li>
<li>
<p>play 中 hosts，variables，roles，tasks 等对象的表示方法都是键值中间以 ":" 分隔表示，":" 后面还要增加一个空格。</p>
</li>
</ul>
<p>以下是 Playbook 的基本语法书写格式：</p>
<pre class="highlighter-hljs"><code>- name: playbook的名称
&nbsp; hosts: 目标主机或主机组 &nbsp; &nbsp;&nbsp;# 可以使用普通的 IP 地址或域名，也可以使用主机组名称
&nbsp; remote_user: 远程用户 &nbsp; &nbsp; &nbsp; &nbsp;# 使用 SSH 登录远程主机时使用的用户名
&nbsp; become:&nbsp;yes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 是否使用特权（例如 sudo）运行命令
&nbsp; tasks: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# Playbook 中的任务列表
&nbsp; &nbsp; &nbsp;- name: 任务名称
&nbsp; &nbsp; &nbsp; &nbsp;module_name: 参数 &nbsp; &nbsp; &nbsp;&nbsp;# Ansible 模块的名称和参数组成的字典，用于执行操作
&nbsp; &nbsp; &nbsp; &nbsp;tags: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 与该任务相关的标记列表，用于执行特定的任务
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 标签名称
&nbsp; &nbsp; &nbsp; &nbsp;when: 条件 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 指定该任务在满足特定条件下才会被执行
&nbsp; &nbsp; &nbsp; &nbsp;notify: 通知列表 &nbsp; &nbsp; &nbsp;&nbsp;# 指定依赖于该任务的另一个任务列表，当这个任务被执行后会自动触发这些任务</code></pre>
<p>&nbsp;</p>
<h2>2.2 Tasks &amp; Modules</h2>
<p>在Ansible Playbook的语法中，</p>
<p>"Tasks"和"Modules"是两个核心概念。</p>
<p><strong>Tasks（任务）</strong>：Tasks是Playbook中的操作步骤或任务，它们定义了要在目标主机上执行的操作。可以在Playbook中定义一个或多个任务。Tasks按照顺序执行，并且可以有条件地执行或跳过。</p>
<p><strong>Modules（模块）</strong>：Modules提供了执行特定任务的功能单元。每个模块负责处理不同的操作，如管理文件、安装软件包、查询系统信息等。Ansible提供了许多内置模块，可以满足大多数常见的操作。</p>
<p>通过组合不同的模块和任务，可以构建复杂的Playbooks来执行各种操作和配置任务。</p>
<p>&nbsp;</p>
<h2>2.3 任务之间的依赖关系</h2>
<p>在 Ansible 的 playbook 中，任务之间可以有依赖关系，你可以使用 dependencies 或者 notify 语句来定义。</p>
<p>&nbsp;</p>
<h3>2.3.1 使用 dependencies 定义任务依赖关系</h3>
<p>如果任务 A 依赖任务 B 完成，可以使用 dependencies 定义任务依赖关系，语法如下：</p>
<pre class="highlighter-hljs"><code>- hosts: web
&nbsp; tasks:
&nbsp; &nbsp; - name: Install Nginx
&nbsp; &nbsp; &nbsp; yum:
&nbsp; &nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;state: present

&nbsp; &nbsp; - name: Start Nginx
&nbsp; &nbsp; &nbsp; service:
&nbsp; &nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;state: started
&nbsp; &nbsp; &nbsp; become: true
&nbsp; &nbsp; &nbsp; dependencies:
&nbsp; &nbsp; &nbsp; &nbsp; - Install Nginx</code></pre>
<p>在上面的示例中，Start Nginx 任务在 Install Nginx 任务完成之后才会执行。如果在执行 Start Nginx 任务之前，Install Nginx 任务未完成或者执行失败，则 Start Nginx 任务也会失败。</p>
<p>&nbsp;</p>
<h3>2.3.2 使用 notify 定义任务依赖关系</h3>
<p>如果任务 A 完成后需要通知任务 B 执行，可以使用 notify 定义任务依赖关系，语法如下：</p>
<pre class="highlighter-hljs"><code>-&nbsp;hosts: web
&nbsp; tasks:
&nbsp; &nbsp;&nbsp;-&nbsp;name: Install Nginx
&nbsp; &nbsp; &nbsp; yum:
&nbsp; &nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; &nbsp; state: present
&nbsp; &nbsp; &nbsp; notify:
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;-Start&nbsp;Nginx
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;&nbsp;-&nbsp;name:&nbsp;Start&nbsp;Nginx
&nbsp; &nbsp; &nbsp; service:
&nbsp; &nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; &nbsp; state: started
&nbsp; &nbsp; &nbsp; become:&nbsp;true
&nbsp; &nbsp; &nbsp; listen:&nbsp;Start&nbsp;Nginx</code></pre>
<p>在上面的示例中，Install Nginx 任务完成后会通知 Start Nginx 任务执行。然后 Start Nginx 任务会通过 listen 参数监听，等待通知执行。</p>
<p>总之，Ansible 支持在 playbook 中定义任务之间的依赖关系。你可以使用 dependencies 或 notify 语句来定义任务之间的顺序和依赖关系。</p>
<p>&nbsp;</p>
<h2>2.4 条件判断</h2>
<p>在Playbook中，可以使用when关键字来添加条件判断。when关键字后面跟一个条件表达式，如果表达式返回True，则任务会被执行；如果返回False，则任务会被跳过。</p>
<p>条件表达式可以使用Ansible的Jinja2模板来编写，例如：</p>
<pre class="highlighter-hljs"><code>tasks:
&nbsp; - name: Install Apache&nbsp;if&nbsp;not&nbsp;installed
&nbsp; &nbsp;&nbsp;package:
&nbsp; &nbsp; &nbsp; name: apache2
&nbsp; &nbsp; &nbsp;&nbsp;state: present
&nbsp; &nbsp;&nbsp;when: ansible_pkg_mgr ==&nbsp;'apt'</code></pre>
<p>在这个例子中，如果ansible_pkg_mgr变量等于"apt"，则安装Apache；否则跳过这个任务。</p>
<p>除了使用任务级别的条件判断，还可以使用Play级别的条件判断来控制整个Playbook的执行。这可以通过在Play的开始处添加when关键字来实现，例如：</p>
<pre class="highlighter-hljs"><code>-&nbsp;name: Deploy Web App
&nbsp; hosts:&nbsp;all
&nbsp; vars:
&nbsp; &nbsp; deploy_web_app:&nbsp;true
&nbsp; tasks:
&nbsp; &nbsp;&nbsp;-&nbsp;name: Install Dependencies
&nbsp; &nbsp; &nbsp; apt:
&nbsp; &nbsp; &nbsp; &nbsp; name: "{{ item }}"
&nbsp; &nbsp; &nbsp; &nbsp; state: present
&nbsp; &nbsp; &nbsp; with_items:
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;-&nbsp;python3
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;-&nbsp;python3-pip
&nbsp; &nbsp; &nbsp;&nbsp;when: deploy_web_app</code></pre>
<p>在这个例子中，deploy_web_app变量的值为True时，才会执行任务Install Dependencies。如果deploy_web_app变量的值为False，则跳过整个Playbook的执行。</p>
<p>&nbsp;</p>
<h2>2.5 循环</h2>
<p>在Playbook中，可以使用循环结构来遍历列表或其他可迭代对象，并对每个迭代项执行相同的任务。这可以使用Ansible的with_*系列模块来实现。</p>
<p>以下是一些常见的循环结构的示例：</p>
<p>&nbsp;</p>
<h3>2.5.1 使用with_items模块来遍历列表</h3>
<pre class="highlighter-hljs"><code>tasks:
&nbsp; - name: Install packages
&nbsp; &nbsp; apt:
&nbsp; &nbsp; &nbsp; name:&nbsp;"{{ item }}"
&nbsp; &nbsp; &nbsp; state: present
&nbsp; &nbsp; with_items:
&nbsp; &nbsp; &nbsp; - python3
&nbsp; &nbsp; &nbsp; - python3-pip
&nbsp; &nbsp; &nbsp; - git</code></pre>
<p>在这个例子中，将依次安装python3、python3-pip和git。</p>
<p>&nbsp;</p>
<h1>3、Playbook 组织</h1>
<h2>3.1 Inclusions</h2>
<p>在Playbook的组织中，include和import两个指令都可以用来将其他的yaml文件（也就是Tasks文件）包含到当前的Playbook中。</p>
<p>它们的区别在于，当主Playbook执行到include指令时，它将处理包含的文件中的所有任务，并且在处理完之后继续主Playbook的执行。而当主Playbook执行到import指令时，它只会处理被导入的文件中的变量定义，而不会处理任务，任务只有在需要的时候才会被引入执行。</p>
<p>下面是一个使用include指令包含其他文件的例子：</p>
<pre class="highlighter-hljs"><code>- hosts: webservers
&nbsp; tasks:
&nbsp; &nbsp; - name: Include web tasks
&nbsp; &nbsp; &nbsp; include: web-tasks.yml</code></pre>
<p>在这个例子中，主Playbook从web-tasks.yml文件中导入任务，并在执行完后继续执行余下的任务。</p>
<p>下面是一个使用import指令包含其他文件的例子：</p>
<pre class="highlighter-hljs"><code>- name: Load variables
&nbsp; import_vars: vars.yml

- name: Deploy web app
&nbsp; hosts: webservers
&nbsp; tasks:
&nbsp; &nbsp; - name: Install dependencies
&nbsp; &nbsp; &nbsp; apt:
&nbsp; &nbsp; &nbsp; &nbsp; name: "{{ item }}"
&nbsp; &nbsp; &nbsp; &nbsp; state: present
&nbsp; &nbsp; &nbsp; with_items:
&nbsp; &nbsp; &nbsp; &nbsp; - python3
&nbsp; &nbsp; &nbsp; &nbsp; - python3-pip

&nbsp; &nbsp; - name: Deploy app
&nbsp; &nbsp; &nbsp; include: app-tasks.yml</code></pre>
<p>在这个例子中，在主Playbook中使用import_vars指令来导入变量定义，然后在每个任务中都可以使用这些变量。然后我们使用include指令从app-tasks.yml文件中包含任务，这些任务可以使用在vars.yml文件中定义的变量。这种方式可以在需要时懒加载任务，提高性能。</p>
<p>需要注意的是，在被引入的文件中，不能再次使用- hosts:指令定义新的主机组，因为Ansible只允许在主Playbook中定义主机组。被引入的文件只包含任务，任务必须使用被定义的主机组来指定目标主机。</p>
<p>&nbsp;</p>
<h2>3.2 Roles</h2>
<p>Ansible的Roles是一种组织Playbook的方式，它将Playbook和相关的变量、模板和其他资源打包在一起，并且可以轻松地在Playbook中重用和分享。一个Role通常适用于一种操作或功能，比如安装和配置一个应用程序、部署Web服务、安装软件包等等。</p>
<p>一个Role目录通常包含以下文件和目录：</p>
<pre class="highlighter-hljs"><code>my-role/
├── README.md
├── defaults/
│ &nbsp; └──&nbsp;main.yml
├── files/
├── handlers/
│ &nbsp; └──&nbsp;main.yml
├── meta/
│ &nbsp; └──&nbsp;main.yml
├── tasks/
│ &nbsp; └──&nbsp;main.yml
├── templates/
├── tests/
│ &nbsp; ├── inventory
│ &nbsp; └── test.yml
└── vars/
&nbsp; &nbsp; └──&nbsp;main.yml</code></pre>
<ul>
<li>
<p><strong>README.md</strong>：Role的说明文档。</p>
</li>
<li>
<p><strong>defaults/main.yml</strong>：默认变量定义文件。</p>
</li>
<li>
<p><strong>files</strong>：包含角色使用的文件。</p>
</li>
<li>
<p><strong>handlers/main.yml</strong>：Role的处理程序。</p>
</li>
<li>
<p><strong>meta/main.yml</strong>：Role的元数据，例如角色名称、作者、依赖等。</p>
</li>
<li>
<p><strong>tasks/main.yml</strong>：包含Role组成部分的主要任务。</p>
</li>
<li>
<p><strong>templates</strong>：包含角色使用的Jinja2模板。</p>
</li>
<li>
<p><strong>tests</strong>：Role的测试脚本。</p>
</li>
<li>
<p><strong>vars/main.yml</strong>：包含Role的变量。</p>
</li>
</ul>
<p>要使用Role，需要在Playbook中定义roles扩展，例如：</p>
<pre class="highlighter-hljs"><code>- hosts: webservers
&nbsp; roles:
&nbsp; &nbsp; - my-role</code></pre>
<p>这将运行my-role目录中包含的所有任务。</p>
<p>通过使用Role，可以更好地组织和重复使用代码，并提高代码的可读性和可维护性。它还可以帮助您在Ansible社区中分享自己的工作，或从其他用户那里获得高质量的Roles。</p>
<p>&nbsp;</p>
<h2>3.3 引用/定义变量</h2>
<p>在Playbook中，可以使用vars关键字来定义变量。例如：</p>
<pre class="highlighter-hljs"><code>vars:
&nbsp; my_var:&nbsp;"Hello World"</code></pre>
<p>这将定义一个名为my_var的变量，其值为字符串"Hello World"。</p>
<p>要在Playbook中访问这个变量，可以使用{{ my_var }}语法。例如：</p>
<pre class="highlighter-hljs"><code>tasks:
&nbsp; - name: Print Message
&nbsp; &nbsp; debug:
&nbsp; &nbsp; &nbsp; msg:&nbsp;"{{ my_var }}"</code></pre>
<p>除了在vars中定义变量，还可以通过set_fact模块来动态设置变量。例如：</p>
<pre class="highlighter-hljs"><code>tasks:
&nbsp; - name: SetDynamic Variable
&nbsp; &nbsp; set_fact:
&nbsp; &nbsp; &nbsp; my_var:&nbsp;"{{ inventory_hostname }} is awesome"</code></pre>
<p>&nbsp;</p>
<h2>3.4 使用插件和模板</h2>
<p>Ansible提供了插件和模板的功能，使得在Playbook中使用动态内容变得更加简单和方便。</p>
<p>插件是一种可以扩展和定制Ansible功能的机制，可以在Playbook中调用和使用。常见的插件包括Action、Lookup、Filter、Callback等。使用插件和模板可以使Playbook更加具有可读性和可维护性，使得动态内容的生成更加灵活和方便。</p>
<p>&nbsp;</p>
<h1>4、服务安装与主机管理</h1>
<h2>4.1 安装服务器依赖</h2>
<p>Playbook是Ansible的核心组件之一，用于定义和执行一系列任务。在使用Playbook之前，需要确保服务器上已经安装了Ansible和相关的依赖项。以下是安装服务器依赖的步骤：</p>
<p>&nbsp;</p>
<h3>4.1.1 安装Python3及其相关依赖项</h3>
<pre class="highlighter-hljs"><code>sudo apt&nbsp;update
sudo apt-get&nbsp;install&nbsp;-y python3 python3-pip python3-dev build-essential libssl-dev libffi-dev</code></pre>
<p>&nbsp;</p>
<h3>4.1.2 安装Ansible</h3>
<pre class="highlighter-hljs"><code>sudo apt-add-repository ppa:ansible/ansible
sudo apt&nbsp;update
sudo apt-get&nbsp;install&nbsp;-y ansible</code></pre>
<p>&nbsp;</p>
<h3>4.1.3 （可选）安装 git</h3>
<pre class="highlighter-hljs"><code>sudo apt&nbsp;update
sudo apt-get&nbsp;install&nbsp;-y git</code></pre>
<p>&nbsp;</p>
<h3>4.1.4 &nbsp;检查Ansible是否安装</h3>
<pre class="highlighter-hljs"><code>ansible&nbsp;--version</code></pre>
<p>这样，您的服务器就已经安装了所需的依赖项以及Ansible。如果您计划在多台服务器上使用Ansible，则需要在每台服务器上重复这些步骤。</p>
<p>&nbsp;</p>
<h2>4.2 配置远程服务器</h2>
<p>在使用Playbook配置远程服务器之前，需要确保Ansible已经正确安装在本地机器上。然后，您需要做以下几个步骤：</p>
<p>&nbsp;</p>
<h3>4.2.1 创建inventory文件</h3>
<p>创建新的inventory文件，用于定义您要配置的远程服务器的IP地址或域名。例如，您可以创建一个名为inventory的文件，并包含以下内容：</p>
<pre class="highlighter-hljs"><code>[webservers]
192.168.1.100
192.168.1.101

[dbservers]
192.168.1.102</code></pre>
<p>在此示例中，我们定义了两个组，webservers和dbservers，并列出了它们中每个服务器的IP地址。</p>
<p>&nbsp;</p>
<h3>4.2.2 编写Playbook</h3>
<p>编写一个Playbook，用于在远程服务器上执行特定的任务。例如，您可以创建一个名为web.yml的Playbook，并包含以下内容：</p>
<pre class="highlighter-hljs"><code>- name: Install andstart Nginx
&nbsp; hosts: webservers
&nbsp; become:&nbsp;true
&nbsp; tasks:
&nbsp; - name: Install Nginx
&nbsp; &nbsp; apt:
&nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; update_cache:&nbsp;yes
&nbsp; &nbsp; &nbsp; state: latest
&nbsp; - name: Start Nginx
&nbsp; &nbsp; service:
&nbsp; &nbsp; &nbsp; name: nginx
&nbsp; &nbsp; &nbsp; state: started
&nbsp; &nbsp; &nbsp; enabled:&nbsp;true</code></pre>
<p>在这个Playbook示例中，我们定义了一个名为Install and start Nginx的任务，它会在webservers组中的服务器上启动Nginx服务器。</p>
<p>&nbsp;</p>
<h3>4.2.3 运行Playbook</h3>
<p>运行Playbook，在远程服务器上执行配置任务。例如，要在远程服务器上运行示例中的web.yml Playbook，可以使用以下命令：</p>
<p>ansible-playbook -i inventory web.yml</p>
<p>在执行此命令后，Ansible将使用inventory文件中定义的远程服务器的IP地址，并执行web.yml Playbook中定义的任务。</p>
<p>这是一个基本的Playbook配置远程服务器的示例。需要根据具体的场景和任务需求来进行个性化配置和修改。</p>
<p>&nbsp;</p>
<h2>4.3 部署应用程序</h2>
<p>Playbook部署应用程序一般步骤：</p>
<pre class="highlighter-hljs"><code>1、准备应用程序的部署包。这通常是一个.tar.gz或.zip文件，包含应用程序代码、依赖项和其他必要文件。
2、在目标主机上安装所需的依赖项和软件包。例如，在部署Python应用程序时，需要安装Python解释器、pip和其他依赖项。
3、创建一个目录用于应用程序的部署。这通常是在目标主机上的一个新目录，例如/home/user/myapp。
4、上传应用程序部署包到目标主机并解压缩。您可以使用copy模块将部署包部署到目标主机上。
5、配置应用程序的运行环境。例如，在部署Flask应用程序时，需要设置环境变量、安装必要的Python包等。
6、配置Web服务器以侦听应用程序的请求。例如，您可以使用Nginx或Apache等Web服务器来代理应用程序请求。</code></pre>
<p>&nbsp;</p>
<h1>5、常用模块的 playbook 语法</h1>
<ul>
<li>
<p><strong>file模块</strong>：可以管理文件系统中的文件和目录。下面是该模块的常用参数：</p>
</li>
<li>
<p><strong>copy模块</strong>：可以将本地文件复制到远程服务器上。</p>
</li>
<li>
<p><strong>unarchive模块</strong>：Ansible 中用于将压缩文件解压缩的模块。</p>
</li>
<li>
<p><strong>apt模块</strong>：可以在Ubuntu或Debian系统上安装、升级、删除软件包。</p>
</li>
<li>
<p><strong>service模块</strong>：可以在系统上管理服务。</p>
</li>
<li>
<p><strong>user模块</strong>：可以管理系统用户。</p>
</li>
<li>
<p><strong>shell模块</strong>：可以在远程服务器上运行基于命令行的任务。该模块只能运行命令，不能使用管道、重定向和通配符。</p>
</li>
<li>
<p><strong>script模块</strong>：可以将本地脚本或可执行文件上传到远程服务器并在远程服务器上运行。该模块适用于运行复杂的命令和复杂的脚本。</p>
</li>
<li>
<p><strong>template模块</strong>：可以将在Ansible中定义的Jinja2模板应用于远程服务器上的文件。在应用模板时，您可以使用变量来一次生成多个文件的不同版本。</p>
</li>
<li>
<p><strong>lineinfile模块</strong>：可以从文件中添加、修改或删除单行文本。该模块可用于修改文件中的配置文件或语言文件，或添加新行。</p>
</li>
<li>
<p><strong>blockinfile模块</strong>：可以在远程服务器文件中添加、修改或删除代码块。该模块可以替代lineinfile模块，以单个块更新文件。</p>
</li>
<li>
<p><strong>debug模块</strong>：可以输出调试信息。该模块在编写Playbooks时非常有用，因为可以检查任务的变量和结果。</p>
</li>
</ul>
<p>&nbsp;</p>
<h1>6、Ansible部署Pulsar集群运维实战</h1>
<h2>6.1 部署zookeeper集群</h2>
<h3>6.1.1 定义host文件</h3>
<p>host 文件指定了要在哪些主机上执行任务。在 playbook 中，可以将 hosts 指定为一个变量，也可以通过 -i 参数指定一个主机清单文件，该文件包含要操作的主机列表。</p>
<pre class="highlighter-hljs"><code>[all:vars]
ansible_ssh_user=xxx
ansible_ssh_pass=xxx

[zk]
127.xxx.xxx.1 myid=1
127.xxx.xxx.2 myid=2
127.xxx.xxx.3 myid=3
127.xxx.xxx.4 myid=4
127.xxx.xxx.5 myid=5</code></pre>
<p>&nbsp;</p>
<h3>6.1.2 定义变量</h3>
<p>group_vars 目录用于存放针对不同主机组的变量文件，其中 all 文件是一种特殊的变量文件，它包含了全局的变量定义，将适用于所有主机组。路径结构如下：</p>
<pre class="highlighter-hljs"><code>group_vars/
├──&nbsp;all</code></pre>
<p>在all文件中，我们可以定义安装路径、JDK版本为、zookeeper版本以及zookeeper相关的配置信息。比如：</p>
<pre class="highlighter-hljs"><code>inst_home: /opt/bigdata/inst
app_home: /opt/bigdata/app
zk_inst_home: zookeeper-3.6.3
zk_app_home: zookeeper
jdk_inst_home: jdk1.8.0_192
jdk_app_home: jdk
jdk_tgz: jdk1.8.0_192.tar.gz
zk_tgz: zookeeper-3.6.3.tar.gz

cluster_name=clusterName
client_port=2181
server_port1=2881
server_port2=2882
jmx_port=9012
admin_port=18080
dataDir="/data/bigdata/zookeeper_{{cluster_name}}/zkDataDir"
dataLogDir="/data/bigdata/zookeeper_{{cluster_name}}/zkDataLogDir"
zoo_log_dir="/opt/bigdata/inst/zookeeper-3.6.3-{{cluster_name}}/logs/"</code></pre>
<p>&nbsp;</p>
<h3>6.1.3 编辑roles模块</h3>
<p><strong>① check_port：检查端口</strong></p>
<p>判断配置的端口是否被占用，如果被占用，则不能执行后续的步骤。</p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>check_port/
├── tasks/
│ &nbsp; └──&nbsp;main.yml
main.yml</code></pre>
<p>#循环检查端口是否是停用状态</p>
<pre class="highlighter-hljs"><code>-&nbsp;name:&nbsp;Check&nbsp;port
&nbsp; wait_for:
&nbsp; &nbsp; host: "{{ inventory_hostname }}"
&nbsp; &nbsp; port: "{{ item }}"
&nbsp; &nbsp; delay:&nbsp;2
&nbsp; &nbsp; timeout:&nbsp;3
&nbsp; &nbsp; state: stopped
&nbsp; register:&nbsp;result
&nbsp; with_items:
&nbsp; &nbsp;&nbsp;-&nbsp;"{{ client_port }}"
&nbsp; &nbsp;&nbsp;-&nbsp;"{{ server_port1 }}"
&nbsp; &nbsp;&nbsp;-&nbsp;"{{ server_port2 }}"
&nbsp; &nbsp;&nbsp;-&nbsp;"{{ jmx_port }}"
&nbsp; &nbsp;&nbsp;-&nbsp;"{{ admin_port }}"

-&nbsp;name: print&nbsp;result
&nbsp; debug:
&nbsp; &nbsp; msg: "Port {{ item.item }} is {{ item.state }}"
&nbsp; with_items: "{{ result.results }}"</code></pre>
<p>&nbsp;</p>
<p><strong>② dispatch_zk：分发安装包</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>dispatch_zk/
├── files/
│ &nbsp; └── zookeeper-3.6.3.tar.gz
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>files：放zookeeper安装包文件。</p>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#分发zk安装包并解压到/tmp路径下
- name: dispatch_zk
&nbsp; unarchive:
&nbsp; &nbsp; src:&nbsp;"{{zk_tgz}}"
&nbsp; &nbsp; dest:&nbsp;"/tmp"
&nbsp; &nbsp; mode:&nbsp;755
&nbsp; &nbsp; owner: root
&nbsp; &nbsp;&nbsp;group: root</code></pre>
<p>&nbsp;</p>
<p><strong>③ config_zk：配置zookeeper</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>config_zk/
├── tasks/
│ &nbsp; └──&nbsp;main.yml
├── templates/
│ &nbsp; └── zoo.cfg</code></pre>
<p>&nbsp;</p>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#zoo.cfg模板文件应用到指定的路径下
- name: zoo.cfg
&nbsp; template:
&nbsp; &nbsp; src: zoo.cfg
&nbsp; &nbsp; dest:&nbsp;"{{ app_home }}/zk-{{ cluster_name }}/conf"
#创建zoo_log_dir目录
- name:&nbsp;mkdir&nbsp;forlog
&nbsp; shell:&nbsp;mkdir&nbsp;-p&nbsp;"{{zoo_log_dir}}"

#创建zk数据目录
- name:&nbsp;mkdir&nbsp;for&nbsp;dataDir
&nbsp; shell:&nbsp;mkdir&nbsp;-p&nbsp;"{{dataDir}}"

#创建zk日志目录
- name:&nbsp;mkdir&nbsp;for&nbsp;dataLogDir
&nbsp; shell:&nbsp;mkdir&nbsp;-p&nbsp;"{{dataLogDir}}"

#myid文件中输入每台主机的编号
- name: myid file
&nbsp; shell:&nbsp;echo&nbsp;"{{myid}}"&nbsp;&gt; {{dataDir}}/myid</code></pre>
<p>&nbsp;</p>
<p>zoo.cfg：zookeeper配置文件模板。</p>
<pre class="highlighter-hljs"><code>tickTime=2000
initLimit=10
syncLimit=5
maxClientCnxns=65535
autopurge.snapRetainCount=30
autopurge.purgeInterval=48
clientPort={{client_port}}
admin.serverPort={{admin_port}}
dataDir={{dataDir}}
dataLogDir={{dataLogDir}}
{% for host in groups.zk%}
server.{{ hostvars[host]['myid'] }}={{host}}:{{server_port1}}:{{server_port2}}
{% endfor %}</code></pre>
<p>&nbsp;</p>
<p><strong>④ deploy_zk：部署zookeeper服务</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>deploy_zk/
├── files/
│ &nbsp; └── env.sh
│ &nbsp; └── jdk1.8.0_192.tar.gz
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>&nbsp;</p>
<p>env.sh：jdk环境变量配置</p>
<pre class="highlighter-hljs"><code>JAVA_HOME=/opt/bigdata/app/jdk
JRE_HOME=$JAVA_HOME/jre
PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar:$CLASSPATH</code></pre>
<p>&nbsp;</p>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#创建/opt/bigdata/inst目录
- name:&nbsp;mkdir&nbsp;for&nbsp;inst_home
&nbsp; shell:&nbsp;mkdir&nbsp;-p {{ inst_home }}

#创建/opt/bigdata/app目录
- name:&nbsp;mkdir&nbsp;for&nbsp;app_home
&nbsp; shell:&nbsp;mkdir&nbsp;-p {{ app_home }}

#注册zk_dir变量
- name: stat_dir
&nbsp;&nbsp;stat: path={{ inst_home }}/{{zk_inst_home}}-{{cluster_name}}
&nbsp; register: zk_dir

#当zk_dir存在时，将/tmp路径安装包移到指定目录并重命名
- name: rename zookeeper&nbsp;dir
&nbsp;&nbsp;command:&nbsp;mv&nbsp;/tmp/{{zk_inst_home}} {{ inst_home }}/{{zk_inst_home}}-{{cluster_name}}
&nbsp; when: zk_dir.stat.exists == False

#创建zk集群软连接
- name: soft&nbsp;link
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ app_home }}/zk-{{ cluster_name }}"
&nbsp; &nbsp; src:&nbsp;"{{ inst_home }}/{{ zk_inst_home }}-{{ cluster_name }}"
&nbsp; &nbsp; state:&nbsp;link

#分发并解压jdk安装包
- name: deploy jdk
&nbsp; unarchive:
&nbsp; &nbsp; src:&nbsp;"{{ jdk_tgz }}"
&nbsp; &nbsp; dest:&nbsp;"{{ inst_home }}"

#创建jdk软连接
- name: create soft&nbsp;link&nbsp;for&nbsp;jdk
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ app_home }}/{{ jdk_app_home }}"
&nbsp; &nbsp; src:&nbsp;"{{ inst_home }}/{{ jdk_inst_home }}"
&nbsp; &nbsp; state:&nbsp;link

#运行jdk环境变量，使其生效
- name:&nbsp;env
&nbsp; script: env.sh</code></pre>
<p>&nbsp;</p>
<p><strong>⑤ start_zk：启动zookeeper服务</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>start_zk/
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<p>#启动zk服务</p>
<pre class="highlighter-hljs"><code>- name: start zookeeper
&nbsp; shell:&nbsp;cd&nbsp;{{ app_home }}/zk-{{cluster_name}}; sh bin/zkServer.sh start</code></pre>
<p>&nbsp;</p>
<h3>6.1.4 编辑任务执行和启动脚本</h3>
<p>zookeeper.yml：任务执行脚本</p>
<pre class="highlighter-hljs"><code>---
- name: check_port
&nbsp; hosts: zk
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - check_port
&nbsp; tags: check_port

- name: dispatch_zk
&nbsp; hosts: zk
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - dispatch_zk
&nbsp; tags: dispatch_zk

- name: deploy_zk
&nbsp; hosts: zk
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - deploy_zk
&nbsp; tags: deploy_zk

- name: config_zk
&nbsp; hosts: zk
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - config_zk
&nbsp; tags: config_zk
&nbsp; &nbsp;
- name: start_zk
&nbsp; hosts: zk
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - start_zk
&nbsp; tags: start_zk</code></pre>
<p>&nbsp;</p>
<h3>6.1.5 部署并启动zookeeper服务</h3>
<pre class="highlighter-hljs"><code># 部署并启动zookeeper服务
ansible-playbook -i hosts-clusterName zookeeper.yml

#只检查端口和分发安装包
ansible-playbook -i hosts-clusterName zookeeper.yml --tags&nbsp;"check_port,dispatch_packages"</code></pre>
<p>&nbsp;</p>
<h2>6.2 部署Pulsar集群</h2>
<h3>6.2.1 定义hosts文件</h3>
<pre class="highlighter-hljs"><code>[all:vars]
ansible_ssh_user=xxx
ansible_ssh_pass=xxx

[pulsar]
127.xxx.xxx.1
127.xxx.xxx.2
127.xxx.xxx.3
127.xxx.xxx.4
127.xxx.xxx.5</code></pre>
<p>&nbsp;</p>
<h3>6.2.2 定义全局变量</h3>
<p>group_vars 目录用于存放针对不同主机组的变量文件，其中 all 文件是一种特殊的变量文件，它包含了全局的变量定义，将适用于所有主机组。路径结构如下：</p>
<pre class="highlighter-hljs"><code>group_vars/
├──&nbsp;all</code></pre>
<p>all文件内容中定义变量信息，如下：</p>
<pre class="highlighter-hljs"><code>bigdata_home: /opt/bigdata
inst_home: /opt/bigdata/inst
app_home: /opt/bigdata/app
pulsar_app_home: pulsar
pulsar_inst_home: apache-pulsar-2.9.2-1.3
pulsar_tgz: apache-pulsar-2.9.2-1.3-bin.tar.gz
pulsar_conf:&nbsp;"{{ app_home }}/pulsar/conf"
secret_key_dir:&nbsp;"{{ app_home }}/pulsar/data"

#bookkeeper.conf
ledgerDirectories: /data1/bookkeeper/ledger,/data2/bookkeeper/ledger,/data3/bookkeeper/ledger,/data4/bookkeeper/ledger

#broker.conf or client.conf
zkServers:&nbsp;"127.xxx.xxx.1:2183,127.xxx.xxx.2:2183,127.xxx.xxx.3:2183/clusterName"
clusterName: wenzhu
webServiceUrl: http://clusterNamexxxx:8080
brokerServiceUrl: pulsar://clusterNamexxxx:6650</code></pre>
<p>&nbsp;</p>
<h3>6.2.3 编辑roles模块</h3>
<p>&nbsp;</p>
<p><strong>① dispatch_pulsar：分发安装包</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>dispatch_pulsar/
├── files/
│ &nbsp; └── apache-pulsar-2.9.2-1.3-bin.tar.gz
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#创建inst_home定义的目录
- name: mkdir_inst_home
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ inst_home }}"
&nbsp; &nbsp;&nbsp;state: directory

#创建app_home定义的目录
- name: mkdir_app_home
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ app_home }}"
&nbsp; &nbsp;&nbsp;state: directory

#分发并解压pulsar安装包到指定目录
- name: dispatch_packages
&nbsp; unarchive:
&nbsp; &nbsp; src:&nbsp;"{{ pulsar_tgz }}"
&nbsp; &nbsp; dest:&nbsp;"{{ inst_home }}"

#创建pulsar软连接
- name: soft_link
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ app_home }}/pulsar"
&nbsp; &nbsp; src:&nbsp;"{{ inst_home }}/{{ pulsar_inst_home }}"
&nbsp; &nbsp;&nbsp;state:&nbsp;link</code></pre>
<p><strong>② check_nar：校验分层存储和kop扩展的依赖包</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>check_nar/
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#匹配指定路径protocols和offloaders下是否有nar后缀的文件
- name: check nar
&nbsp; find:
&nbsp; &nbsp; paths:&nbsp;"{{ app_home }}/pulsar/{{ item }}/"
&nbsp; &nbsp; patterns:&nbsp;"*.nar"
&nbsp; register: result
&nbsp; with_items:
&nbsp; &nbsp; -&nbsp;"offloaders"
&nbsp; &nbsp; -&nbsp;"protocols"

#设置文件匹配的结果（大于0表示文件存在）
- name:&nbsp;set&nbsp;nar_files_exist variable
&nbsp; set_fact:
&nbsp; &nbsp; nar_files_exist_{{item.item}}:&nbsp;"{{ item.matched &gt; 0 }}"
&nbsp; with_items:&nbsp;"{{ result.results }}"

#如果文件不存在，进行提示
- name: nar files&nbsp;not&nbsp;exist
&nbsp; fail:
&nbsp; &nbsp; msg:&nbsp;"{{ item.item }} nar files not found"
&nbsp;&nbsp;when: nar_files_exist_{{ item.item }} ==&nbsp;false
&nbsp; ignore_errors:&nbsp;true
&nbsp; with_items:&nbsp;"{{ result.results }}"

#如果文件存在，列出存在的文件名
- name: print nar files list
&nbsp; debug:
&nbsp; &nbsp; msg:&nbsp;"{{ item.files | map(attribute='path') | list }}"
&nbsp;&nbsp;when: nar_files_exist_{{item.item}}
&nbsp; with_items:&nbsp;"{{ result.results }}"</code></pre>
<p><strong>③ config_pulsar：配置pulsar</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>config_pulsar/
├── tasks/
│ &nbsp; └──&nbsp;main.yml
├── templates/
│ &nbsp; └── bkenv.sh
│ &nbsp; └── pulsar_env.sh</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#匹配broker.conf中的advertisedAddress值并设置为远程主机ip地址
- name: config_advertisedAddress
&nbsp; lineinfile:
&nbsp; &nbsp; path:&nbsp;"{{ pulsar_conf }}/broker.conf"
&nbsp; &nbsp; regexp:&nbsp;"^advertisedAddress="
&nbsp; &nbsp; line:&nbsp;"advertisedAddress={{ inventory_hostname }}"

#配置broker.conf中的zookeeperServers值
- name: config_zookeeperServers
&nbsp; lineinfile:
&nbsp; &nbsp; path:&nbsp;"{{ pulsar_conf }}/broker.conf"
&nbsp; &nbsp; regexp:&nbsp;"^zookeeperServers="
&nbsp; &nbsp; line:&nbsp;"zookeeperServers={{ zkServers }}"

#配置broker.conf中的clusterName值
- name: config_clusterName
&nbsp; lineinfile:
&nbsp; &nbsp; path:&nbsp;"{{ pulsar_conf }}/broker.conf"
&nbsp; &nbsp; regexp:&nbsp;"^clusterName="
&nbsp; &nbsp; line:&nbsp;"clusterName={{ clusterName }}"
&nbsp; &nbsp; &nbsp;
#配置broker.conf中的kafkaAdvertisedListeners值
- name: config_kafkaAdvertisedListeners
&nbsp; lineinfile:
&nbsp; &nbsp; path:&nbsp;"{{ pulsar_conf }}/broker.conf"
&nbsp; &nbsp; regexp:&nbsp;"^kafkaAdvertisedListeners="
&nbsp; &nbsp; line:&nbsp;"kafkaAdvertisedListeners=PLAINTEXT://{{ inventory_hostname }}:9093"

#配置bookkeeper.conf中的advertisedAddress值，设置为主机ip地址
- name: config_bk_advertisedAddress
&nbsp; lineinfile:
&nbsp; &nbsp; path:&nbsp;"{{ pulsar_conf }}/bookkeeper.conf"
&nbsp; &nbsp; regexp:&nbsp;"^advertisedAddress="
&nbsp; &nbsp; line:&nbsp;"advertisedAddress={{ inventory_hostname }}"

#将模板文件bkenv.sh应用到pulsar的配置文件中
- name: config_bkenv.sh
&nbsp; template:
&nbsp; &nbsp; src: bkenv.sh
&nbsp; &nbsp; dest:&nbsp;"{{ pulsar_conf }}"

#将模板文件pulsar_env.sh应用到pulsar的配置文件中
- name: config_pulsar_env.sh
&nbsp; template:
&nbsp; &nbsp; src: pulsar_env.sh
&nbsp; &nbsp; dest:&nbsp;"{{ pulsar_conf }}"</code></pre>
<p><strong>④ create_data_dir：创建存储数据的目录</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>create_data_dir/
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<p>#循环创建with_items中的数据目录</p>
<pre class="highlighter-hljs"><code>- name: mkdir_data_dir
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ item }}"
&nbsp; &nbsp; state: directory
&nbsp; with_items:
&nbsp; &nbsp; - /data1/bookkeeper/ledger
&nbsp; &nbsp; - /data2/bookkeeper/ledger
&nbsp; &nbsp; - /data3/bookkeeper/ledger
&nbsp; &nbsp; - /data4/bookkeeper/ledger</code></pre>
<p><strong>⑤ config_secret_key：配置安全秘钥</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>config_secret_key/
├── files/
│ &nbsp; └── admin-secret.key
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#创建存放安全秘钥的目录
- name: create_secret_key_dir
&nbsp; file:
&nbsp; &nbsp; path:&nbsp;"{{ secret_key_dir }}"
&nbsp; &nbsp; owner: root
&nbsp; &nbsp;&nbsp;group: root
&nbsp; &nbsp; state: directory

#将安装秘钥文件分发到指定的路径下
- name: dispatch_secret.key
&nbsp;&nbsp;copy:
&nbsp; &nbsp; src: admin-secret.key
&nbsp; &nbsp; dest:&nbsp;"{{ secret_key_dir }}"</code></pre>
<p><strong>⑥ init_meta：初始化集群元数据</strong></p>
<p>目录结构如下：</p>
<pre class="highlighter-hljs"><code>init_meta/
├── tasks/
│ &nbsp; └──&nbsp;main.yml
├── templates/
│ &nbsp; └── init_meta.sh</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#应用init_meta.sh脚本到远程主机
- name: scp init_meta.sh
&nbsp; template:
&nbsp; &nbsp; src: init_meta.sh
&nbsp; &nbsp; dest:&nbsp;"{{ app_home }}/pulsar"

#执行初始化脚本文件
- name: init_meta
&nbsp; shell:&nbsp;nohup&nbsp;sh {{ app_home }}/pulsar/init_meta.sh &gt; {{ app_home }}/pulsar/init.log2&gt;&amp;1 &amp;

#等待20s查询初始化日志中是否出现初始化成功的日志
- name: wait20s
&nbsp; wait_for:
&nbsp; &nbsp; path:&nbsp;"{{ app_home }}/pulsar/init.log"
&nbsp; &nbsp; search_regex:&nbsp;"Cluster metadata for '{{ clusterName }}' setup correctly"
&nbsp; &nbsp; delay: 20

#杀掉集群元数据初始化进程
- name:&nbsp;kill&nbsp;metadata
&nbsp; shell: ps -efww|grep PulsarClusterMetadataSetup|grep -v grep|cut&nbsp;-c 9-15|xargs&nbsp;kill&nbsp;-9
init_meta.sh：初始化集群元数据脚本

{{ app_home }}/pulsar/bin/pulsar initialize-cluster-metadata \
--cluster {{ clusterName }} \
--zookeeper {{ zkServers }} \
--configuration-store {{ zkServers }} \
--web-service-url {{ webServiceUrl }} \
--broker-service-url {{ brokerServiceUrl }}</code></pre>
<p><strong>⑦ start_service：启动broker和bookkeeper服务</strong></p>
<pre class="highlighter-hljs"><code>start_service/
├── tasks/
│ &nbsp; └──&nbsp;main.yml</code></pre>
<p>main.yml</p>
<pre class="highlighter-hljs"><code>#启动远程主机bookkeeper服务
- name:&nbsp;start&nbsp;bookie
&nbsp; shell: sh {{ app_home }}/pulsar/bin/pulsar-daemon&nbsp;start&nbsp;bookie

#启动远程主机broker服务
- name:&nbsp;start&nbsp;broker
&nbsp; shell: sh {{ app_home }}/pulsar/bin/pulsar-daemon&nbsp;start&nbsp;broker</code></pre>
<p>&nbsp;</p>
<h3>6.2.4 编辑任务执行脚本</h3>
<p>pulsar.yml：任务执行脚本</p>
<pre class="highlighter-hljs"><code>---
#分发pulsar安装包
- name: dispatch_pulsar
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - dispatch_pulsar
&nbsp; tags: dispatch_pulsar

#检查安装包中kop和分层存储nar包是否存在
- name: check_nar
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; roles:
&nbsp; &nbsp; - check_nar
&nbsp; tags: check_nar

#修改pulsar配置
- name: config_pulsar
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - config_pulsar
&nbsp; tags: config_pulsar
&nbsp; &nbsp;
&nbsp;&nbsp;#创建磁盘数据目录
- name: create_data_dir
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - create_data_dir
&nbsp; tags: create_data_dir

#配置证书文件
- name: config_secret_key
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - config_secret_key
&nbsp; tags: config_secret_key

#初始化meta信息
- name: init_meta
&nbsp; hosts: pulsar[0]
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - init_meta
&nbsp; tags: init_meta
&nbsp; &nbsp;
#启动broker和bookkeeper服务
- name: start_service
&nbsp; hosts: pulsar
&nbsp; remote_user: root
&nbsp; become:&nbsp;yes
&nbsp; become_flags:&nbsp;'-i'
&nbsp; roles:
&nbsp; &nbsp; - start_service
&nbsp; tags: start_service</code></pre>
<p>&nbsp;</p>
<h3>6.2.5 执行playbook任务</h3>
<pre class="highlighter-hljs"><code>#执行所有pulsar.yml中的任务
ansible-playbook -i hosts pulsar.yml

#只执行pulsar.yml中标签为dispatch_pulsar,check_nar的任务
ansible-playbook -i hosts pulsar.yml --tags&nbsp;"dispatch_pulsar,check_nar"</code></pre>
<p>&nbsp;</p>
<h1>7、Playbooks运维Pulsar集群总结</h1>
<h2>7.1 Pulsar运维实践总结</h2>
<p>Pulsar作为新一代云原生架构的分布式消息中间件，目前再超大流量规模、海量分区、超高QPS等场景下缺乏长时间的稳定性验证，在极端场景下还存在较多稳定性风险，当前社区版本迭代活跃；Pulsar集群在vivo内部日均处理消息达万亿+，需要不断的合并社区issue及灰度升级高版本。运维事项较多、投入的运维人力较大。vivo分布式消息中间件团队通过借助Ansible的模块化、任务依赖、配置check、批量脚本执行等能力实现Pulsar集群从zk集群搭建、Pulsar安装包编译、自动化配置填充、批量分发部署、服务启动的一键运维部署能力。大大缩减了Pulsar集群的运维人力投入，Pulsar组件存算分离的架构设计优秀，但部署配置项非常繁杂，通过自动化配置填充可有效规避配置信息不一致、版本不一致等高频错误。</p>
<p>&nbsp;</p>
<h2>7.2 playbooks服务部署步骤</h2>
<p>根据以上实战经验，我们可以总结出部署某个服务时编写playbooks脚本的一般步骤如下：</p>
<p><img alt="图片" data-pm-attrs="{&quot;src&quot;:&quot;https://static001.geekbang.org/infoq/66/6667655076aff9741459816a159cc9a8.png&quot;,&quot;alt&quot;:&quot;图片&quot;,&quot;title&quot;:null,&quot;style&quot;:[{&quot;key&quot;:&quot;width&quot;,&quot;value&quot;:&quot;75%&quot;},{&quot;key&quot;:&quot;bordertype&quot;,&quot;value&quot;:&quot;none&quot;}],&quot;href&quot;:null,&quot;fromPaste&quot;:true,&quot;pastePass&quot;:true}" data-src="https://static001.geekbang.org/infoq/66/6667655076aff9741459816a159cc9a8.png" class="lazyload"></p>
<p>Ansible更多运维实践可参考：<a href="https://github.com/ansible/ansible-examples" data-type="link" data-id="link566514" rel="noopener nofollow">https://github.com/ansible/ansible-examples</a></p>
<p>&nbsp;</p>
<p>猜你喜欢</p>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjY4MTU5Nw==&amp;mid=2247501335&amp;idx=1&amp;sn=3701be0b8b7b789e29c1ca53ba142e9d&amp;scene=21#wechat_redirect" data-type="link" data-id="link566514" rel="noopener nofollow">vivo Pulsar万亿级消息处理实践（1）-数据发送原理解析和性能调优</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjY4MTU5Nw==&amp;mid=2247501426&amp;idx=1&amp;sn=76c04879cfa2c6b38a731b5c49f19d3a&amp;scene=21#wechat_redirect" data-type="link" data-id="link566514" rel="noopener nofollow">vivo Pulsar万亿级消息处理实践（2）-从0到1建设Pulsar指标监控链路</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjY4MTU5Nw==&amp;mid=2247505310&amp;idx=1&amp;sn=541f7a56e7db9a0909f649a412c82d6d&amp;scene=21#wechat_redirect" data-type="link" data-id="link566514" rel="noopener nofollow">vivo Pulsar万亿级消息处理实践（3）-KoP指标异常修复</a></p>
</li>
</ul>
</div>
<div id="MySignature" role="contentinfo">
    分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-14 11:29">2025-08-14 11:28</span>&nbsp;
<a href="https://www.cnblogs.com/vivotech">vivo互联网技术</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19037415);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19037415', targetLink: 'https://www.cnblogs.com/vivotech/p/19037415', title: 'vivo Pulsar 万亿级消息处理实践（4）-Ansible运维部署' })">举报</a>
</div>
        