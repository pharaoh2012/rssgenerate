
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18794585" title="发布于 2025-04-03 09:04">
    <span role="heading" aria-level="2">掌握设计模式--解释器模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="解释器模式interpreter-pattern">解释器模式（Interpreter Pattern）</h2>
<p>解释器模式（Interpreter Pattern）是一种行为型设计模式，用于定义一种语言的文法表示，并提供一个解释器来解释该语言中的句子。这种模式通常用于开发需要解析、解释和执行特定语言或表达式的应用程序。</p>
<p><strong>主要目的</strong>是为特定类型的问题定义一种语言，然后用该语言的解释器来解决问题。</p>
<h3 id="主要组成部分">主要组成部分</h3>
<p>解释器模式的结构通常包括以下几个部分：</p>
<ol>
<li>
<p><strong>抽象表达式（AbstractExpression）</strong> ：定义解释操作的接口。</p>
</li>
<li>
<p><strong>终结符表达式（TerminalExpression）</strong> ：表示语言中的<strong>基本元素</strong>，如数字或变量。</p>
</li>
<li>
<p><strong>非终结符表达式（NonTerminalExpression）</strong>：表示更复杂的<strong>语法规则</strong>，通过组合终结符表达式和其他非终结符表达式实现。</p>
</li>
<li>
<p><strong>上下文（Context）</strong>：存储解释器在解析表达式时需要的<strong>全局信息</strong>，比如变量值或共享数据。</p>
</li>
<li>
<p><strong>客户端（Client）</strong>：构建（或从外部获取）需要解析的表达式，并使用解释器处理表达式。</p>
</li>
</ol>
<p>区分终结符和非终结符主要看它是不是<strong>最终的输出</strong>，是不是不可再分的组成部分。</p>
<h2 id="案例实现">案例实现</h2>
<p>设计一个动态查询SQL 的解析器，<strong>查询SQL模板</strong> + <strong>输入的参数</strong> 动态的生成所需要的查询SQL 。</p>
<p><strong>本案例的主要功能</strong>：</p>
<ol>
<li>支持占位符替换：如 <code>#{key}</code> 替换为参数值。</li>
<li>支持动态条件解析：如 <code>&lt;if&gt;</code> 标签根据条件决定是否生成部分 SQL。</li>
<li>支持集合操作：如 <code>&lt;foreach&gt;</code> 动态生成 <code>IN</code> 子句。</li>
<li>使用解释器模式解析查询SQL 模板，分离模板的不同语义块。</li>
</ol>
<h3 id="案例类图">案例类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202503/1209017-20250326202039518-766332752.png" alt="image" loading="lazy"></p>
<p><strong>类图简述</strong></p>
<ol>
<li>
<p><strong>上下文 (<code>Context</code>)</strong> ：存储输入参数，供解释器在解析时访问。</p>
</li>
<li>
<p><strong>抽象表达式 (<code>SQLExpression</code>)</strong> ：表示 SQL 模板中的一个语义块，定义 <code>interpret</code> 方法解析该块，参数为<code>Context</code>输入参数。</p>
</li>
<li>
<p><strong>终结符表达式</strong></p>
</li>
</ol>
<ul>
<li>
<p><strong>文本表达式(<code>TextExpression</code>)</strong>：不可再分的文本部分（如静态 SQL 片段）；</p>
</li>
<li>
<p><strong>占位符表达式 (<code>PlaceholderExpression</code>)</strong>：解析并替换 <code>#{key}</code>。</p>
</li>
</ul>
<ol start="4">
<li><strong>非终结符表达式</strong></li>
</ol>
<ul>
<li><strong>条件组表达式(<code>ConditionalGroupExpression</code>)</strong>：解析<code>&lt;where&gt;</code> 标签中的一组条件；</li>
<li><strong>条件表达式 (<code>IfExpression</code>)</strong>：解析 <code>&lt;if&gt;</code> 标签中的动态 SQL；</li>
<li><strong>集合表达式 (<code>ForEachExpression</code>)</strong>：解析 <code>&lt;foreach&gt;</code> 动态生成 SQL；</li>
<li><strong>复合表达式(<code>CompositeExpression</code>)</strong>：将多个表达式组合成一个整体。</li>
</ul>
<h3 id="上下文">上下文</h3>
<p>存储动态 SQL 的参数，供解释器在解析时访问。</p>
<pre><code class="language-java">public class Context {
    private Map&lt;String, Object&gt; parameters;

    public Context(Map&lt;String, Object&gt; parameters) {
        this.parameters = parameters;
    }

    public Object getParameter(String key) {
        return parameters.get(key);
    }
}
</code></pre>
<h3 id="抽象表达式">抽象表达式</h3>
<p>表示 SQL 模板中的一个语义块，定义 <code>interpret</code> 方法解析该块。</p>
<pre><code class="language-java">public interface SQLExpression {
    String interpret(Context context);
}
</code></pre>
<h3 id="终结符表达式">终结符表达式</h3>
<p><strong>文本表达式(<code>TextExpression</code>)</strong>：不可再分的文本部分（如静态 SQL 片段）；</p>
<p><strong>占位符表达式 (<code>PlaceholderExpression</code>)</strong>：解析并替换 <code>#{key}</code>。</p>
<pre><code class="language-java">// 终结符表达式：文本片段
public class TextExpression implements SQLExpression {
    private String text;

    public TextExpression(String text) {
        this.text = text;
    }

    @Override
    public String interpret(Context context) {
        return text;
    }
}

// 终结符表达式：占位符替换
class PlaceholderExpression implements SQLExpression {
    private String text;

    public PlaceholderExpression(String text) {
        this.text = text;
    }

    @Override
    public String interpret(Context context) {
        // 替换 #{key} 为参数值
        Pattern pattern = Pattern.compile("#\\{(\\w+)}");
        Matcher matcher = pattern.matcher(text);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            String key = matcher.group(1);
            Object value = context.getParameter(key);
            if (value == null) {
                throw new RuntimeException("参数 " + key + " 未提供");
            }
            String replacement = (value instanceof String) ? "'" + value + "'" : value.toString();
            matcher.appendReplacement(result, replacement);
        }
        matcher.appendTail(result);

        return result.toString();
    }
}
</code></pre>
<h3 id="非终结符表达式">非终结符表达式</h3>
<p><strong>条件组表达式(<code>ConditionalGroupExpression</code>)</strong>：解析<code>&lt;where&gt;</code> 标签中的一组条件；</p>
<p><strong>条件表达式 (<code>IfExpression</code>)</strong>：解析 <code>&lt;if&gt;</code> 标签中的动态 SQL；</p>
<p><strong>集合表达式 (<code>ForEachExpression</code>)</strong>：解析 <code>&lt;foreach&gt;</code> 动态生成 SQL；</p>
<p><strong>复合表达式(<code>CompositeExpression</code>)</strong>：将多个表达式组合成一个整体。</p>
<pre><code class="language-java">// 非终结符表达式：条件组，自动管理 WHERE/AND/OR
public class ConditionalGroupExpression implements SQLExpression {
    private List&lt;SQLExpression&gt; conditions = new ArrayList&lt;&gt;();

    public void addCondition(SQLExpression condition) {
        conditions.add(condition);
    }

    @Override
    public String interpret(Context context) {
        StringBuilder result = new StringBuilder();
        int validConditions = 0;

        for (SQLExpression condition : conditions) {
            String conditionResult = condition.interpret(context).trim();
            if (!conditionResult.isEmpty()) {
                // 对首个有效条件去掉前缀
                if (validConditions == 0) {
                    if (conditionResult.toUpperCase().startsWith("AND ")) {
                        conditionResult = conditionResult.substring(4);
                    } else if (conditionResult.toUpperCase().startsWith("OR ")) {
                        conditionResult = conditionResult.substring(3);
                    }
                } else {
                    // 非首条件，确保没有多余的空格或重复逻辑
                    if (!conditionResult.toUpperCase().startsWith("AND") &amp;&amp; !conditionResult.toUpperCase().startsWith("OR")) {
                        result.append(" AND ");
                    } else {
                        result.append(" ");
                    }
                }
                result.append(conditionResult);
                validConditions++;
            }
        }

        return validConditions &gt; 0 ? "WHERE " + result.toString().trim() : "";
    }
}
// 非终结符表达式：条件
class IfExpression implements SQLExpression {
    private String condition;
    private SQLExpression innerExpression;

    public IfExpression(String condition, SQLExpression innerExpression) {
        this.condition = condition;
        this.innerExpression = innerExpression;
    }

    @Override
    public String interpret(Context context) {
        // 解析条件，支持 key != null 和 key == value 等
        if (evaluateCondition(condition, context)) {
            return innerExpression.interpret(context);
        }
        return ""; // 条件不满足时返回空字符串
    }

    // 解析条件语法
    private boolean evaluateCondition(String condition, Context context) {
        // 简单支持 key != null 和 key == value 的逻辑
        if (condition.contains("!=")) {
            String[] parts = condition.split("!=");
            String key = parts[0].trim();
            Object value = context.getParameter(key);
            return value != null; // 判断 key 是否存在
        } else if (condition.contains("==")) {
            String[] parts = condition.split("==");
            String key = parts[0].trim();
            String expectedValue = parts[1].trim().replace("'", ""); // 移除单引号
            Object actualValue = context.getParameter(key);
            return expectedValue.equals(actualValue != null ? actualValue.toString() : null);
        }
        throw new RuntimeException("不支持的条件: " + condition);
    }
}

// 非终结符表达式：集合操作
class ForEachExpression implements SQLExpression {
    private String itemName;
    private String collectionKey;
    private String open;
    private String separator;
    private String close;

    public ForEachExpression(String itemName, String collectionKey, String open, String separator, String close) {
        this.itemName = itemName;
        this.collectionKey = collectionKey;
        this.open = open;
        this.separator = separator;
        this.close = close;
    }

    @Override
    public String interpret(Context context) {
        Object collection = context.getParameter(collectionKey);
        if (!(collection instanceof Collection)) {
            throw new RuntimeException("参数 " + collectionKey + " 必须是集合");
        }
        Collection&lt;?&gt; items = (Collection&lt;?&gt;) collection;
        StringJoiner joiner = new StringJoiner(separator, open, close);
        for (Object item : items) {
            joiner.add(item instanceof String ? "'" + item + "'" : item.toString());
        }
        return joiner.toString();
    }
}

// 复合表达式：将多个表达式组合成一个整体
class CompositeExpression implements SQLExpression {
    private List&lt;SQLExpression&gt; expressions = new ArrayList&lt;&gt;();

    public CompositeExpression(SQLExpression... expressions) {
        this.expressions.addAll(Arrays.asList(expressions));
    }

    @Override
    public String interpret(Context context) {
        StringBuilder result = new StringBuilder();
        for (SQLExpression expression : expressions) {
            result.append(expression.interpret(context));
        }
        return result.toString();
    }
}
</code></pre>
<h3 id="测试客户端">测试客户端</h3>
<p>两条动态查询SQL的生成测试</p>
<pre><code class="language-java">public class DynamicSQLInterpreterDemo {
    public static void main(String[] args) {
        // 动态 SQL 模板
        List&lt;SQLExpression&gt; expressions = new ArrayList&lt;&gt;();
        expressions.add(new TextExpression("SELECT * FROM t_users"));

        // WHERE 条件组
        ConditionalGroupExpression whereGroup = new ConditionalGroupExpression();
        whereGroup.addCondition(new IfExpression("id != null", new PlaceholderExpression("and id = #{id}")));
        whereGroup.addCondition(new IfExpression("name != null", new PlaceholderExpression("OR name = #{name}")));
        whereGroup.addCondition(new IfExpression("ids != null &amp;&amp; !ids.isEmpty()", new CompositeExpression(
                new TextExpression("AND id IN "),
                new ForEachExpression("id", "ids", "(", ",", ")")
        )));
        expressions.add(whereGroup);

        // 测试参数
        Map&lt;String, Object&gt; parameters1 = new HashMap&lt;&gt;();
        parameters1.put("id", 1);
        parameters1.put("name", "Alice");
        parameters1.put("ids", Arrays.asList(1, 2, 3));

        Map&lt;String, Object&gt; parameters2 = new HashMap&lt;&gt;();
        parameters2.put("ids", Arrays.asList(1, 2, 3));

        // 输出最终 SQL
        System.out.println("测试 1:");
        generateSQL(expressions, parameters1);
        System.out.println("测试 2:");
        generateSQL(expressions, parameters2);
    }

    private static void generateSQL(List&lt;SQLExpression&gt; expressions, Map&lt;String, Object&gt; parameters) {
        Context context = new Context(parameters);
        StringBuilder parsedSQL = new StringBuilder();

        for (SQLExpression expression : expressions) {
            String result = expression.interpret(context).trim();
            if (!result.isEmpty()) {
                parsedSQL.append(" ").append(result);
            }
        }
        System.out.println(parsedSQL.toString().trim());
    }
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<pre><code class="language-plaintext">测试 1:
SELECT * FROM t_users WHERE id = 1 OR name = 'Alice' AND id IN (1,2,3)
测试 2:
SELECT * FROM t_users WHERE id IN (1,2,3)
</code></pre>
<p>该案例简单实现了动态查询SQL的生成。<code>List&lt;SQLExpression&gt; expressions</code> 变量在动态SQL表达式只执行两次<code>add()</code>操作，第一次是<code>SELECT * FROM t_user</code>，第二次是<code>where条件语句</code>，然后再根据参数值替换占位符来实现动态SQL的生成。</p>
<p>所有的<code>表达式</code>都可以独立进行扩展调整而不相互影响（灵活性、扩展性）。比如、新增分组查询、查询结果排序等表达式，以及原有表达式的不断优化调整。</p>
<p>也可以，将动态SQL模版改为<code>xml</code>文档进行SQL配置化。解析过程变为：先经过xml文档解析，根据请求参数再进行动态SQL解释，从而灵活生成SQL。这看起来有点MyBatis的味道。</p>
<h2 id="解释器模式的应用">解释器模式的应用</h2>
<p><strong>Hibernate</strong>：使用 ORM 技术，通过<strong>对象关系映射</strong>来执行查询；</p>
<p><strong>MyBatis</strong>：通过映射器和 XML 配置来处理动态 SQL；</p>
<p>两者都使用了解释器模式来处理查询的解析。</p>
<h2 id="优缺点和适用场景">优缺点和适用场景</h2>
<h3 id="优点">优点</h3>
<ul>
<li><strong>扩展性好</strong>：可以轻松地添加新的表达式解析规则。</li>
<li><strong>直观性强</strong>：语言的规则和实现代码一一对应，清晰明了。</li>
<li><strong>适用于领域特定语言</strong>：非常适合解决领域特定问题。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li><strong>复杂性增加</strong>：对于复杂的语法规则，类的数量会迅速增加，导致维护成本高。</li>
<li><strong>性能问题</strong>：解释器模式效率较低，特别是在需要解析大量复杂表达式时。</li>
</ul>
<h3 id="适用场景">适用场景</h3>
<p>解释器模式适合在以下情况下使用：</p>
<ul>
<li><strong>特定语法或规则</strong>：需要为某个特定领域设计一个语言或表达式处理工具。</li>
<li><strong>重复问题</strong>：问题可以通过一组标准规则或语法重复解决。</li>
<li><strong>可扩展性需求</strong>：希望能够轻松添加新规则或表达式。</li>
</ul>
<p><strong>常见示例：</strong></p>
<ul>
<li>计算器程序（解析数学表达式）。</li>
<li>SQL解析器。</li>
<li>编译器中的语法解析器。</li>
<li>简单的脚本解释器。</li>
</ul>
<h2 id="总结">总结</h2>
<p>解释器模式适合用于实现轻量级的解析器或简单的领域特定语言，但在面对复杂语法或高性能需求的场景时，可能需要其他更高效的解析工具（如正则表达式、ANTLR等）。</p>
<p>解释器模式提供了一种创建领域特定语言（DSL）的方法。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202503/1209017-20250326202016446-1158855701.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1350079087986111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-03 09:05">2025-04-03 09:04</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18794585" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18794585);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18794585', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18794585', title: '掌握设计模式--解释器模式' })">举报</a>
</div>
        