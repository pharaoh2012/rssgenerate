
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mingupupu/p/19044527" title="发布于 2025-08-18 13:46">
    <span role="heading" aria-level="2">Stylet启动机制详解：从Bootstrap到View显示</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>今天以<code>Stylet.Samples.Hello</code>这个demo为例，学习一下Stylet的启动机制。</p>
<p>平常我们新建一个WPF程序结构是这样的：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250818134623882-333452870.png" class="lazyload"><br>
启动之后就是这样的：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250818134623921-360684700.png" class="lazyload"></p>
<p>为什么启动之后是这样的呢？</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250818134623902-1511613059.png" class="lazyload"><br>
我们知道是因为在App.xaml中我们设置了<code>StartupUri="MainWindow.xaml"</code>。</p>
<p>现在来看看<code>Stylet.Samples.Hello</code>的结构：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250818134623902-570982831.png" class="lazyload"></p>
<p>再来看看它的App.xaml：</p>
<pre><code class="language-xaml">&lt;Application x:Class="Stylet.Samples.Hello.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:s="https://github.com/canton7/Stylet"
             xmlns:local="clr-namespace:Stylet.Samples.Hello"&gt;
    &lt;Application.Resources&gt;
        &lt;s:ApplicationLoader&gt;
            &lt;s:ApplicationLoader.Bootstrapper&gt;
                &lt;local:HelloBootstrapper/&gt;
            &lt;/s:ApplicationLoader.Bootstrapper&gt;
        &lt;/s:ApplicationLoader&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre>
<p>我们发现它删掉了<code>StartupUri</code>，然后多了一个<code>&lt;s:ApplicationLoader&gt;</code>。</p>
<p>说明启动起来就显示<code>ShellView</code>的玄机就在其中！！</p>
<h2 id="stylet启动机制">Stylet启动机制</h2>
<p>Stylet的启动流程可以分为以下几个关键阶段：</p>
<ul>
<li>WPF应用程序启动（Application.Startup）</li>
<li>ApplicationLoader初始化（XAML解析阶段）</li>
<li>Bootstrapper配置与启动</li>
<li>IoC容器初始化</li>
<li>根视图模型创建</li>
<li>视图定位与创建</li>
<li>窗口显示</li>
</ul>
<p>看似一个简单的启动过程，其实作者做了很多的处理！！</p>
<p>现在就让我们来看看吧！！</p>
<p><em>阶段1：WPF应用程序启动</em></p>
<pre><code class="language-xaml">&lt;Application x:Class="Stylet.Samples.Hello.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:s="https://github.com/canton7/Stylet"
             xmlns:local="clr-namespace:Stylet.Samples.Hello"&gt;
    &lt;Application.Resources&gt;
        &lt;s:ApplicationLoader&gt;
            &lt;s:ApplicationLoader.Bootstrapper&gt;
                &lt;local:HelloBootstrapper/&gt;
            &lt;/s:ApplicationLoader.Bootstrapper&gt;
        &lt;/s:ApplicationLoader&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre>
<p>当WPF解析App.xaml时，会创建ApplicationLoader实例。ApplicationLoader是Stylet提供的特殊资源字典，继承自ResourceDictionary，ApplicationLoader的构造函数会立即执行，加载Stylet的基础资源。</p>
<p>来看下ApplicationLoader的源码：</p>
<pre><code class="language-csharp">public class ApplicationLoader : ResourceDictionary
{
    private readonly ResourceDictionary styletResourceDictionary;
    
    public ApplicationLoader()
    {
        // 加载Stylet的基础样式资源
        this.styletResourceDictionary = new ResourceDictionary() { 
            Source = new Uri("pack://application:,,,/Stylet;component/Xaml/StyletResourceDictionary.xaml", UriKind.Absolute) 
        };
        this.LoadStyletResources = true;
    }

    public IBootstrapper Bootstrapper
    {
        get =&gt; this._bootstrapper;
        set
        {
            this._bootstrapper = value;
            // 关键：立即调用Setup方法
            this._bootstrapper.Setup(Application.Current);
        }
    }
}
</code></pre>
<p>当XAML解析器遇到<code>&lt;local:HelloBootstrapper/&gt;</code>时，会：</p>
<ul>
<li>创建HelloBootstrapper实例</li>
<li>设置给ApplicationLoader.Bootstrapper属性</li>
<li>触发Bootstrapper.Setup(Application.Current)调用</li>
</ul>
<p><em>阶段2：Bootstrapper配置与启动</em></p>
<p>HelloBootstrapper：</p>
<pre><code class="language-csharp">public class HelloBootstrapper : Bootstrapper&lt;ShellViewModel&gt;
{
    // 空实现！所有功能都在基类中
}
</code></pre>
<p>虽然HelloBootstrapper看起来很简单，但它继承的Bootstrapper<shellviewmodel>提供了完整的启动逻辑。</shellviewmodel></p>
<p>现在来看看HelloBootstrapper的继承链：</p>
<pre><code class="language-csharp">  HelloBootstrapper
    ↓
Bootstrapper&lt;ShellViewModel&gt;
    ↓
StyletIoCBootstrapperBase
    ↓
BootstrapperBase
</code></pre>
<p>刚刚在阶段1中看到的<code>Setup</code>方法在BootstrapperBase中，现在来看看：</p>
<pre><code class="language-csharp">public void Setup(Application application)
{
  this.Application = application;
  
  // 设置UI线程调度器
  Execute.Dispatcher = new ApplicationDispatcher(this.Application.Dispatcher);

  // 关键：注册Startup事件
  this.Application.Startup += (o, e) =&gt; this.Start(e.Args);
  
  // 注册其他生命周期事件
  this.Application.Exit += (o, e) =&gt;
  {
      this.OnExit(e);
      this.Dispose();
  };
  
  this.Application.DispatcherUnhandledException += (o, e) =&gt;
  {
      LogManager.GetLogger(typeof(BootstrapperBase)).Error(e.Exception, "Unhandled exception");
      this.OnUnhandledException(e);
  };
}
</code></pre>
<p><code>Setup</code>方法在XAML解析阶段就被调用,但实际的启动逻辑在<code>Application.Startup</code>事件触发时才执行,这确保了所有配置都在UI线程上完成。</p>
<p><em>阶段3：IoC容器初始化</em></p>
<p>现在重点看看这个：</p>
<pre><code class="language-csharp">  // 关键：注册Startup事件
  this.Application.Startup += (o, e) =&gt; this.Start(e.Args);
</code></pre>
<p>我们看到作者为<code>this.Application.Startup</code>事件增加了事件处理函数/程序<code> (o, e) =&gt; this.Start(e.Args)</code>。</p>
<p>现在我们来看看这个事件处理函数/程序：</p>
<pre><code class="language-csharp">public virtual void Start(string[] args)
{
  // 1. 保存命令行参数
  this.Args = args;
  this.OnStart();
  
  // 2. 配置Bootstrapper（主要是IoC容器）
  this.ConfigureBootstrapper();
  
  // 3. 注册ViewManager到应用程序资源
  this.Application?.Resources.Add(View.ViewManagerResourceKey, this.GetInstance(typeof(IViewManager)));
  
  // 4. 用户自定义配置
  this.Configure();
  
  // 5. 显示根视图
  this.Launch();
  
  // 6. 启动完成通知
  this.OnLaunch();
}
</code></pre>
<p>先来看看StyletIoC容器配置：</p>
<pre><code class="language-csharp">protected sealed override void ConfigureBootstrapper()
{
  var builder = new StyletIoCBuilder();
  builder.Assemblies = new List&lt;Assembly&gt;(new List&lt;Assembly&gt;() { this.GetType().Assembly });

  // 用户自定义IoC配置
  this.ConfigureIoC(builder);
  
  // 默认配置
  this.DefaultConfigureIoC(builder);
  
  // 构建容器
  this.Container = builder.BuildContainer();
}

protected virtual void DefaultConfigureIoC(StyletIoCBuilder builder)
{
  // 配置ViewManager
  var viewManagerConfig = new ViewManagerConfig()
  {
      ViewFactory = this.GetInstance,
      ViewAssemblies = new List&lt;Assembly&gt;() { this.GetType().Assembly }
  };
  builder.Bind&lt;ViewManagerConfig&gt;().ToInstance(viewManagerConfig).AsWeakBinding();

  // 注册核心服务
  builder.Bind&lt;IViewManager&gt;().And&lt;ViewManager&gt;().To&lt;ViewManager&gt;().InSingletonScope();
  builder.Bind&lt;IWindowManager&gt;().To&lt;WindowManager&gt;().InSingletonScope();
  builder.Bind&lt;IEventAggregator&gt;().To&lt;EventAggregator&gt;().InSingletonScope();
  
  // 自动绑定特性
  builder.Autobind();
}
</code></pre>
<p>注册的默认服务：</p>
<ul>
<li>IViewManager → ViewManager（视图管理器）</li>
<li>IWindowManager → WindowManager（窗口管理器）</li>
<li>IEventAggregator → EventAggregator（事件聚合器）</li>
</ul>
<p><em>阶段4：根视图模型创建</em></p>
<p>现在来看看<code>Bootstrapper&lt;TRootViewModel&gt;</code>：</p>
<pre><code class="language-csharp">public abstract class Bootstrapper&lt;TRootViewModel&gt; : StyletIoCBootstrapperBase 
  where TRootViewModel : class
{
  private TRootViewModel _rootViewModel;

  // 延迟加载根视图模型
  protected virtual TRootViewModel RootViewModel =&gt; 
      this._rootViewModel ??= this.Container.Get&lt;TRootViewModel&gt;();

  // 启动时显示根视图
  protected override void Launch()
  {
      this.DisplayRootView(this.RootViewModel);
  }
}
</code></pre>
<p>关键点：</p>
<ul>
<li>使用延迟加载模式，只有在需要时才创建TRootViewModel</li>
<li>通过IoC容器解析ShellViewModel，支持构造函数注入</li>
<li>在HelloBootstrapper中，TRootViewModel就是ShellViewModel</li>
</ul>
<p><em>阶段5：视图定位与创建</em></p>
<p>现在来看看<code>DisplayRootView</code>方法：</p>
<pre><code class="language-csharp">protected virtual void DisplayRootView(object rootViewModel)
{
  var windowManager = (IWindowManager)this.GetInstance(typeof(IWindowManager));
  windowManager.ShowWindow(rootViewModel);
}
</code></pre>
<p>现在来看看<code>ShowWindow</code>方法：</p>
<pre><code class="language-csharp">public void ShowWindow(object viewModel)
{
  this.CreateWindow(viewModel, false, null).Show();
}
</code></pre>
<p>现在来看看<code>CreateWindow</code>方法：</p>
<pre><code class="language-csharp">protected virtual Window CreateWindow(object viewModel, bool isDialog, IViewAware ownerViewModel)
{
  // 1. 通过ViewManager创建视图
  UIElement view = this.viewManager.CreateAndBindViewForModelIfNecessary(viewModel);
  
  // 2. 确保视图是Window类型
  if (view is not Window window)
  {
      throw new StyletInvalidViewTypeException(...);
  }
  
  // 3. 设置窗口属性
  if (viewModel is IHaveDisplayName haveDisplayName)
  {
      window.SetBinding(Window.TitleProperty, new Binding("DisplayName"));
  }
  
  // 4. 设置窗口位置
  if (window.WindowStartupLocation == WindowStartupLocation.Manual)
  {
      window.WindowStartupLocation = WindowStartupLocation.CenterScreen;
  }
  
  return window;
}
</code></pre>
<p>现在再来看看<code>CreateAndBindViewForModelIfNecessary</code>方法：</p>
<pre><code class="language-csharp">  public virtual UIElement CreateAndBindViewForModelIfNecessary(object model)
{
    if (model is IViewAware modelAsViewAware &amp;&amp; modelAsViewAware.View != null)
    {
        logger.Info("ViewModel {0} already has a View attached to it. Not attaching another", model);
        return modelAsViewAware.View;
    }

    return this.CreateAndBindViewForModel(model);
}
</code></pre>
<p>在这里得到了ViewModel所绑定的View。</p>
<p><em>阶段6：ShellView显示全过程</em></p>
<pre><code class="language-csharp">WPF Application
    ↓
Application Startup
    ↓
ApplicationLoader.Setup()
    ↓
Bootstrapper.Setup()
    ↓
注册Startup事件
    ↓
Application.Startup触发
    ↓
Bootstrapper.Start()
    ↓
ConfigureBootstrapper()
    ↓
IoC容器构建
    ↓
Launch()调用
    ↓
DisplayRootView(ShellViewModel)
    ↓
WindowManager.ShowWindow()
    ↓
ViewManager.CreateViewForModel()
    ↓
定位ShellView类型
    ↓
创建ShellView实例
    ↓
绑定ShellView到ShellViewModel
    ↓
显示ShellView窗口
</code></pre>
<p>看似一个简单的操作，其实作者做了很多工作。</p>
<p>从这个探索中我们可以了解什么？</p>
<ul>
<li>声明式配置：通过XAML配置启动器</li>
<li>约定优于配置：自动的ViewModel-View映射</li>
<li>依赖注入：自动的依赖解析</li>
<li>生命周期管理：完整的应用程序生命周期钩子</li>
<li>可扩展性：通过继承和重写实现自定义</li>
</ul>
<p>Stylet的设计哲学是让简单的事情保持简单，让复杂的事情成为可能。通过理解这些基础机制，你可以构建出更加优雅和可维护的WPF应用程序。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-18 13:46">2025-08-18 13:46</span>&nbsp;
<a href="https://www.cnblogs.com/mingupupu">mingupupup</a>&nbsp;
阅读(<span id="post_view_count">137</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19044527);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19044527', targetLink: 'https://www.cnblogs.com/mingupupu/p/19044527', title: 'Stylet启动机制详解：从Bootstrap到View显示' })">举报</a>
</div>
        