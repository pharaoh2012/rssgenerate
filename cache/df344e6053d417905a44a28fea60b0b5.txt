
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18750049" title="发布于 2025-03-04 10:51">
    <span role="heading" aria-level="2">别再混淆了！JVM内存模型和Java内存模型的本质区别</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>JVM 内存模型（JVM Memory Model）和 Java 内存模型（Java Memory Model, JMM）是 Java 开发中两个非常重要的概念，但这两个概念很容易被搞混，所以本文就来通俗易懂的讲讲二者的区别。</p>
<p>首先，我们先来看看各自的概念，以及其解决的问题。</p>
<h2 id="1jvm内存模型">1.JVM内存模型</h2>
<ul>
<li><strong>定位</strong>：JVM 在运行 Java 程序时对物理内存的<strong>具体划分和管理方式</strong>，用来保证 Java 程序正常执行的。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1741055049164-5e58f068-376b-48fe-a33f-d643f554726f.png" alt="" loading="lazy"></p>
<ul>
<li><strong>目的</strong>：定义 Java 程序在运行时如何分配、使用和回收内存。</li>
<li><strong>核心组成</strong>：
<ul>
<li><strong>堆（Heap）</strong>：存储对象实例（所有线程共享）。</li>
<li><strong>方法区（Method Area）</strong>：存储类信息、常量等（JDK8 后由元空间实现）。</li>
<li><strong>虚拟机栈（VM Stack）</strong>：存储方法的局部变量、操作数栈（每个线程私有）。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：服务于 JVM 调用本地方法。</li>
<li><strong>程序计数器（Program Counter Register）</strong>：记录线程当前执行的指令地址。</li>
</ul>
</li>
<li><strong>关注点</strong>：内存的分配、垃圾回收（GC）、内存泄漏等问题。</li>
</ul>
<h3 id="jvm不划分5大内存区域行不行">JVM不划分5大内存区域行不行？</h3>
<p>从理论上来讲可能是可行的，但从程序的运行效率、垃圾回收的效率等方面来讲不划分内存区域，所有的信息放到一起，其效率是非常慢的，是不能被允许的。</p>
<p>并且不划分区域可能会导致<strong>关键数据易被污染的问题</strong>，例如方法区存储的类元数据（如类结构、静态变量）需要长期存在且全局共享，若与临时变量混存，可能导致类信息被意外覆盖。例如，在热加载类时，新类元数据可能覆盖正在被其他线程使用的旧版本，引发不可预知的错误。</p>
<p>所以综合来看，JVM 必须按存储的数据类型划分为不同的数据区域，以提升程序的执行和垃圾回收的效率，并且可以减少程序在运行时的一些不必要的问题，这就是 JVM 内存模型所解决的问题。</p>
<h2 id="2java内存模型">2.Java内存模型</h2>
<ul>
<li><strong>定位</strong>：Java 语言规范（JLS）定义的<strong>多线程环境下内存访问的规则和约束的一种规范</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1741055049294-7ac20715-f1b5-4ce3-bf2d-f7930e90a6e0.png" alt="" loading="lazy"></p>
<ul>
<li><strong>目的</strong>：解决多线程并发时的<strong>内存可见性、原子性、有序性</strong>问题，确保线程间正确通信。</li>
<li><strong>核心概念</strong>：
<ul>
<li><strong>主内存（Main Memory）</strong>：所有线程共享的内存区域。</li>
<li><strong>工作内存（Working Memory）</strong>：每个线程私有的内存副本（可能对应 CPU 寄存器或缓存）。</li>
<li><strong>happens-before原则</strong>：定义操作之间的偏序关系，确保可见性。</li>
<li><strong>内存屏障（Memory Barriers）</strong>：禁止指令重排序的机制。</li>
</ul>
</li>
<li><strong>关注点</strong>：如何通过 synchronized、volatile 等关键字或并发工具类保证线程安全。</li>
<li><strong>示例场景</strong>：解决多线程下共享变量的不可见性（如使用 volatile 禁止指令重排序）。</li>
</ul>
<blockquote>
<p>PS：也就是说“Java 内存模型”主要是保证 Java 在多线程下正常运行的一种机制（或规定）。</p>
</blockquote>
<h2 id="小结">小结</h2>
<table>
<thead>
<tr>
<th></th>
<th><strong>JVM内存模型</strong></th>
<th><strong>Java内存模型（JMM）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>范畴</td>
<td>JVM 实现层面的内存区域划分</td>
<td>多线程并发编程的内存访问规则</td>
</tr>
<tr>
<td>主要目标</td>
<td>内存分配、回收和管理</td>
<td>解决线程间的可见性、有序性和原子性问题</td>
</tr>
<tr>
<td>具体实现</td>
<td>堆、栈、方法区等物理内存划分</td>
<td>volatile、synchronized 等语义</td>
</tr>
</tbody>
</table>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：场景题、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列等模块。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.001631879068287037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-04 10:52">2025-03-04 10:51</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18750049" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18750049);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18750049', targetLink: 'https://www.cnblogs.com/vipstone/p/18750049', title: '别再混淆了！JVM内存模型和Java内存模型的本质区别' })">举报</a>
</div>
        