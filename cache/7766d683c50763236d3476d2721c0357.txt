
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/WindrunnerMax/p/18840221" title="发布于 2025-04-22 10:42">
    <span role="heading" aria-level="2">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>数据模型的设计是编辑器的核心基础，其直接影响了选区模型、<code>DOM</code>模型、状态管理等模块的设计。例如在<code>quill</code>中的选区模型是<code>index + len</code>的表达，而<code>slate</code>中则是<code>anchor + focus</code>的表达，这些都是基于数据模型的设计而来的。因此我们从零实现的富文本编辑器就需要从数据模型的设计开始，之后就可以逐步实现其他模块。</p>
<ul>
<li>开源地址: <a href="https://github.com/WindRunnerMax/BlockKit" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/BlockKit</a></li>
<li>在线编辑: <a href="https://windrunnermax.github.io/BlockKit/" target="_blank" rel="noopener nofollow">https://windrunnermax.github.io/BlockKit/</a></li>
<li>项目笔记: <a href="https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md</a></li>
</ul>
<p>从零实现富文本编辑器项目的相关文章:</p>
<ul>
<li><a href="https://www.cnblogs.com/WindrunnerMax/p/18816107" target="_blank">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>
<li><a href="https://www.cnblogs.com/WindrunnerMax/p/18826249" target="_blank">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>
<li><a href="" rel="noopener nofollow">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>
</ul>
<h2 id="delta">Delta</h2>
<p>在先前的架构设计中我们已经提到了，我们实现的扁平数据结构且独立分包设计，无论是在编辑器中操作，还是在服务端数据解析，都可以更加方便地处理。相比较来说，嵌套的数据结构能够更好地对齐<code>DOM</code>表达，然而这样对于数据的操作却变得更加复杂。</p>
<p>因此在数据结构的设计上，我们是基于<code>quill</code>的<code>delta</code>结构进行了改造。最主要的部分是将其改造为<code>immutable</code>的实现，在编辑器中实际是维护的状态而不是本身的<code>delta</code>结构。并且精简了整个数据模型的表达，将复杂的<code>insert</code>与<code>Attribute</code>类型缩减，那么其操作逻辑的复杂度也会降低。</p>
<p><code>delta</code>是一种简洁而功能强大的格式，用于描述文档内容及其变化。该格式基于<code>JSON</code>，不仅便于阅读，同时也易于机器解析。通过使用<code>delta</code>描述的内容，可以准确地描述任何富文本文档的内容和格式信息，避免了<code>HTML</code>中常见的歧义和复杂性。</p>
<p><code>delta</code>由一系列操作组成，这些操作描述了对文档进行的更改。常见的操作包括<code>insert</code>、<code>delete</code>、<code>retain</code>。需要注意的是，这些操作不依赖于具体的索引位置，其总是描述当前索引位置的更改，并且可以通过<code>retain</code>来移动指针位置。</p>
<p><code>delta</code>既可以表示整个文档，也可以表示对文档进行的更改。那么在这里我们将<code>delta</code>的主要类对象及相关操作逻辑进行描述，特别是在编辑器中实际应用场景，以及主要的改造和相关类型声明。</p>
<h3 id="insert">insert</h3>
<p><code>insert</code>方法是将数据插入到<code>delta</code>的操作，这就是<code>delta</code>。当描述整个文档内容时，整个数据的内容应该全部都是<code>insert</code>。首个参数是要插入的文本内容，第二个参数是可选的属性对象，用于描述文本的格式信息。</p>
<pre><code class="language-js">const delta = new Delta();
delta.insert("123").insert("567", { a: "1" });
// [{"insert":"123"},{"insert":"567","attributes":{"a":"1"}}]
</code></pre>
<p>原始的<code>insert</code>参数是可以对象类型的<code>Embed</code>结构，这种结构可以表达<code>Image</code>、<code>Video</code>、<code>Mention</code>等非文本结构的数据，而属性<code>AttributeMap</code>参数是<code>Record&lt;string, unknown&gt;</code>类型，这样用来描述复杂属性值。</p>
<p>在这里我们将其精简了，<code>insert</code>参数仅支持<code>string</code>类型，而具体的<code>schema</code>则在编辑器的初始化时定义，格式信息则收归于<code>Attrs</code>中描述。而<code>AttributeMap</code>则改为<code>Record&lt;string, string&gt;</code>类型，并且可以避免诸如<code>CloneDeep</code>、<code>isEqual</code>等对于复杂数据结构的实现。</p>
<p>其实在<code>EtherPad</code>中就是将<code>Attribute</code>就是<code>[string, string]</code>类型，在这里我们也是使用了类似的设计。在这种基础结构设计下，我们更推荐将属性值扁平地放置于<code>attributes</code>属性中，而不是使用单个属性值作为<code>key</code>，将所有属性值嵌套地放置于<code>value</code>中。</p>
<pre><code class="language-js">export interface AttributeMap {
  [key: string]: string;
}
</code></pre>
<p><code>delta</code>整个名字通常会用于描述变更，那么除了描述整个文档内容外，当然还可以描述文档内容的变更。不过应用变更的内容需要用到<code>compose</code>，这个方法的描述我们在后边再看。</p>
<pre><code class="language-js">const delta1 = new Delta().insert("123");
const delta2 = new Delta().insert("456");
delta1.compose(delta2); // [{"insert":"456123"}]
</code></pre>
<h3 id="delete">delete</h3>
<p><code>delete</code>方法描述了删除内容的长度，由于上述的定义我们现在的内容全部都是文本，在原始的数据定义中嵌入<code>Embed</code>的长度为<code>1</code>。</p>
<pre><code class="language-js">const delta = new Delta().insert("123");
delta.compose(new Delta().delete(1)); // [{"insert":"23"}]
</code></pre>
<p>其实这里是比较有趣的事情，通过<code>delete</code>来描述变更时，无法得知究竟删除了哪些内容。那么这种情况下，进行<code>invert</code>的时候就需要额外的数据来构造<code>insert</code>操作。类似的场景在<code>OT-JSON</code>中，内容描述是直接写入<code>op</code>的，因此可以直接根据<code>op</code>来进行<code>invert</code>操作。</p>
<pre><code class="language-js">const delta = new Delta().insert("123");
const del = new Delta().delete(1);
const invert1 = del.invert(delta); // [{"insert":"1"}]
const delta2 = delta.compose(del); // [{"insert":"23"}]
delta2.compose(invert1); // [{"insert":"123"}]
</code></pre>
<h3 id="retain">retain</h3>
<p><code>retain</code>方法描述了保留内容的长度，换句话说，这个操作可以用来移动指针。</p>
<pre><code class="language-js">const delta = new Delta().insert("123");
delta.compose(new Delta().retain(1).insert("a")); // [{"insert":"1a23"}]
</code></pre>
<p>同时<code>retain</code>操作也可以用于修改内容的属性值，此外如果想删除某个属性，只需要将<code>value</code>设置为<code>""</code>即可。</p>
<pre><code class="language-js">const delta = new Delta().insert("123");
const d2 = new Delta().retain(1).retain(1, { "a": "1" });
const d3 = delta.compose(d2); // [{"insert":"1"},{"insert":"2","attributes":{"a":"1"}},{"insert":"3"}]
d3.compose(new Delta().retain(1).retain(1, { "a": "" })); // [{"insert":"123"}]
</code></pre>
<h3 id="push">push</h3>
<p><code>push</code>方法是上述的<code>insert</code>、<code>delete</code>、<code>retain</code>依赖的基础方法，主要实现是将内容推入到<code>delta</code>维护的数组中。这里的实现非常重要部分是<code>op</code>的合并，当属性值相同时，则需要将其合并为单个<code>op</code>。</p>
<pre><code class="language-js">const delta = new Delta();
delta.push({ insert: "123" }).push({ insert: "456" }); // [{"insert": "123456"}]
</code></pre>
<p>当然这里不仅仅是<code>insert</code>操作会合并，对于<code>delete</code>、<code>retain</code>操作也是一样的。这里的合并操作是基于<code>op</code>的<code>attributes</code>属性值，如果<code>attributes</code>属性值不同，则会被视为不同的<code>op</code>，不会自动合并。</p>
<pre><code class="language-js">const delta = new Delta();
delta.push({ delete: 1 }).push({ delete: 1 }); // [{"delete": 2}]
const delta2 = new Delta();
delta2.push({ retain: 1 }).push({ retain: 1 }); // [{"retain": 2}]
const delta3 = new Delta();
delta3.push({ retain: 1 }).push({ retain: 1, attributes: { a: "1"} }); // [{"retain": 1}, {"retain": 1, "attributes": {"a": "1"}}]
</code></pre>
<h3 id="slice">slice</h3>
<p><code>slice</code>方法是用于截取<code>delta</code>的操作，这个方法是基于<code>op</code>的<code>length</code>属性值进行截取的。</p>
<pre><code class="language-js">const delta = new Delta().insert("123").insert("456", {a: "1"});
delta.slice(2, 4); // [{"insert":"3"},{"insert":"4","attributes":{"a":"1"}}]
</code></pre>
<h3 id="eachline">eachLine</h3>
<p><code>eachLine</code>方法用于按行迭代整个<code>delta</code>，我们的整体数据结构是线性的，但是编辑器<code>DOM</code>需要按行来划分内容，因此基于<code>\n</code>来划分行就是比较常规的操作了。</p>
<p>这个方法对于编辑器的初始化非常重要，而当初始化完毕后，我们的变更就需要基于状态来实现，而不是每次都需要经过该方法。在这里我们也对其进行了改造，原始的<code>eachLine</code>方法是不会携带<code>\n</code>节点。</p>
<pre><code class="language-js">const delta = new Delta().insert("123\n456\n789");
delta.eachLine((line, attributes) =&gt; {
  console.log(line, attributes);
});
// [{insert:"123"},{insert:"\n"}] {}
// [{insert:"456"},{insert:"\n"}] {}
// [{insert:"789"},{insert:"\n"}] {}
</code></pre>
<h3 id="diff">diff</h3>
<p><code>diff</code>方法用于对比两个<code>delta</code>之间的差异，这个方法实际上是基于纯文本的<code>myers diff</code>来实现。通过将<code>delta</code>转换为纯文本，在<code>diff</code>过后不断挑选较短的操作部分来实现<code>delta</code>之间的<code>diff</code>。</p>
<p>其实在我们的实现中完全可以将<code>diff</code>方法独立出来，这里唯一引用了外部的<code>fast-diff</code>依赖。在<code>quill</code>中<code>diff</code>是必要的，因为其完全是非受控的输入方式，文本的输入依赖于对<code>DOM</code>文本的<code>diff</code>来实现，而我们的输入是依赖<code>beforeinput</code>事件的半受控输入，因此并不强依赖<code>diff</code>。</p>
<pre><code class="language-js">const delta1 = new Delta().insert("123");
const delta2 = new Delta().insert("126");
delta1.diff(delta2); // [{"retain":2},{"insert":"6"},{"delete":1}]
</code></pre>
<h3 id="chop">chop</h3>
<p><code>chop</code>方法用于裁剪末尾的<code>retain</code>操作，当存在末尾的<code>retain</code>且没有属性操作时，其本身是没有意义的，因此可以调用该方法检查并移除。</p>
<pre><code class="language-js">const delta = new Delta().insert("123").retain(1);
delta.chop(); // [{"insert":"123"}]
</code></pre>
<h3 id="compose">compose</h3>
<p><code>compose</code>方法可以将两个<code>delta</code>合并为一个<code>delta</code>，具体来说则是将<code>B</code>的<code>delta</code>操作应用到<code>A</code>的<code>delta</code>上，此时返回的是一个新的<code>delta</code>对象。当然在我们的实现中，继承了原始<code>Delta</code>类重写了<code>compose</code>方法，做到了<code>immutable</code>。</p>
<p><code>compose</code>在编辑器中的应用场景非常多，例如输入事件、内容粘贴、历史操作等场景中，类似于编辑器的<code>apply</code>方法，相当于应用内容变更。</p>
<pre><code class="language-js">const delta1 = new Delta().insert("123");
const delta2 = new Delta().retain(1).delete(1);
delta1.compose(delta2); // [{"insert":"13"}]
</code></pre>
<h3 id="invert">invert</h3>
<p><code>invert</code>方法是将<code>delta</code>的操作进行反转，这个方法在历史操作中非常重要，因为本身<code>undo</code>就是需要将当前的操作进行反转。此外，在实现<code>OT</code>的<code>local-cs</code>中，<code>invert</code>也是非常重要的方法。</p>
<p>值得关注的是，上边也提到了<code>delete</code>操作和<code>retain</code>操作在本身执行时是不会记录原始内容的，因此在<code>invert</code>是需要原始的<code>delta</code>作为数据源来进行操作，注意这里的<code>delta</code>是最初的<code>delta</code>，而不是<code>invert</code>后的<code>delta</code>。</p>
<pre><code class="language-js">const delta = new Delta().insert("123");
const del = new Delta().delete(1);
const invert1 = del.invert(delta); // [{"insert":"1"}]
const delta2 = delta.compose(del); // [{"insert":"23"}]
delta2.compose(invert1); // [{"insert":"123"}]
</code></pre>
<h3 id="concat">concat</h3>
<p><code>concat</code>方法可以连接两个<code>delta</code>到新的<code>delta</code>中。这个操作与<code>compose</code>不同，<code>compose</code>是将<code>B</code>的操作应用到<code>A</code>上，而<code>concat</code>则是将<code>B</code>的操作追加到<code>A</code>的操作后。</p>
<pre><code class="language-js">const delta1 = new Delta().insert("123");
const delta2 = new Delta().insert("456");
delta1.compose(delta2); // [{"insert":"456123"}]
delta1.concat(delta2); // [{"insert":"123456"}]
</code></pre>
<h3 id="transform">transform</h3>
<p><code>transform</code>方法是实现操作<code>OT</code>协同的基础，即使不实现协同编辑，在编辑器中的历史操作模块中也会需要这部分实现。假设我们现在有用户<code>A[uid:1]</code>和用户<code>B[uid:2]</code>，此时我们以<code>uid</code>定义优先级，则<code>A</code>的操作优先级高于<code>B</code>，且当前的文档内容为<code>12</code>。</p>
<p>如果是在协同中的话，<code>b'=a.t(b)</code>的意思是，假设<code>a</code>和<code>b</code>都是从相同的<code>draft</code>分支出来的，那么<code>b'</code>就是假设<code>a</code>已经应用了，此时<code>b</code>需要在<code>a</code>的基础上变换出<code>b'</code>才能直接应用，我们也可以理解为<code>transform</code>解决了<code>a</code>操作对<code>b</code>操作造成的影响。</p>
<p>那么我们假设<code>A</code>在<code>12</code>后的位置插入了<code>A</code>字符，<code>B</code>在<code>12</code>后的位置插入了<code>B</code>字符。如果进行协同操作，那么两者相当于同时在同一个位置插入了字符，如果不进行操作变换而直接应用的话，两者的数据就会出现冲突，<code>A</code>的数据是<code>12BA</code>，而<code>B</code>的数据是<code>12AB</code>，因此就需要先转换再应用。</p>
<pre><code class="language-js">// User A
const base = new Delta().insert("12");
const delta = new Delta().retain(2).insert("A");
let current = base.compose(delta); // 12A
// Accept Remote B
const remote = new Delta().retain(2).insert("B");
// ob1=OT(oa, ob)
const remote2 = delta.transform(remote, true); // [{"retain":3},{"insert":"B"}] 
current = current.compose(remote2); // 12AB
</code></pre>
<pre><code class="language-js">// User B
const base = new Delta().insert("12");
const delta = new Delta().retain(2).insert("B");
let current = base.compose(delta); // 12B
// Accept Remote A
const remote = new Delta().retain(2).insert("A");
// oa2=OT(ob, oa)
const remote2 = delta.transform(remote, false); // [{"retain":2},{"insert":"A"}] 
current = current.compose(remote2); // 12AB
</code></pre>
<h3 id="transformposition">transformPosition</h3>
<p><code>transformPosition</code>方法用于将指定的位置进行转换，这个方法的主要场景是编辑器中的选区/光标的位置变换，例如光标此时在<code>1</code>后面，构造<code>delta</code>在<code>1</code>之前增加了内容的话，那么光标就需要跟随移动。</p>
<pre><code class="language-js">const delta = new Delta().retain(5).insert("a");
delta.transformPosition(4); // 4
delta.transformPosition(5); // 6
</code></pre>
<h3 id="opiterator">OpIterator</h3>
<p><code>OpIterator</code>类定义一个迭代器，用于迭代<code>delta</code>中的<code>op</code>操作。迭代器大量用于<code>diff</code>、<code>compose</code>、<code>transform</code>等方法中，需要注意的是该迭代器调用<code>next</code>时不会跨越<code>op</code>，即使传递的<code>length</code>大于当前<code>op</code>的长度。</p>
<pre><code class="language-js">const delta = new Delta()
  .insert("Hello", { bold: "true" })
  .insert(" World", { italic: "true" });
  .retain(3);
iter.next(2); // { insert: "He", attributes: { bold: "true" } }
iter.next(10); // { insert: "llo", attributes: { bold: "true" } }
</code></pre>
<h2 id="etherpad">EtherPad</h2>
<p><code>EtherPad</code>同样是非常优秀的协同编辑器，其内置实现的数据结构同样是线性的，文档整体描述称为<code>ClientVars</code>，数据结构变更被称为<code>ChangeSet</code>。协同算法的实现是<code>EasySync</code>，且其文档中对如何进行服务端调度也有较为详细的描述。</p>
<p><code>ClientVars/Changeset</code>同样是一种基于<code>JSON</code>的数据格式，用于描述文档的内容及其变更。但是其并没有像<code>Delta</code>那么清晰的表达，<code>JSON</code>结构主要是<code>AttributePool</code>内，而对于文本内容的表达则是纯文本的结构。</p>
<h3 id="文档描述">文档描述</h3>
<p>文档内容是使用<code>ClientVars</code>的数据结构表示的，其中包含了三个部分，<code>apool</code>文本属性池、<code>text</code>文本内容、<code>attribs</code>属性描述。在下面的例子中，我们描述了标题、加粗、斜体、纯文本的内容，那么这其中的内容如下所示。</p>
<pre><code class="language-js">({
  initialAttributedText: {
    text: "short description\n*Heading1\ntext\n*Heading2\nbold italic\nplain text\n\n",
    attribs: "*0|1+i*0*1*2*3+1*0|2+e*0*4*2*3+1*0|1+9*0*5+4*0+1*0*6+6*0|2+c|1+1",
  },
  apool: {
    numToAttrib: {
      "0": ["author", "a.XYe86foM7oYgmpuu"],
      "1": ["heading", "h1"],
      "2": ["insertorder", "first"],
      "3": ["lmkr", "1"],
      "4": ["heading", "h2"],
      "5": ["bold", "true"],
      "6": ["italic", "true"],
    },
    nextNum: 7,
  },
});
</code></pre>
<p>对于这个内容直接看上去是比较复杂的，当然实际上也是比较复杂的。<code>apool</code>是一个属性池，所有对于文本内容的装饰都是在这里存储的，也就是其中的<code>numToAttrib</code>属性存储的<code>[string, string]</code>值，<code>nextNum</code>则是下个要放置的索引。<code>text</code>则是纯文本的内容，相当于此时文档的纯文本内容。<code>attribs</code>则是根据<code>text</code>的纯文本内容，并且取得<code>apool</code>中的属性值，相当于装饰文本内容的编码。</p>
<p>因此<code>attribs</code>需要单独拿出来解析，<code>*n</code>表示取第<code>n</code>个属性应用到文本上，通常需要配合<code>|n</code>和<code>+n</code>属性使用，<code>|n</code>表示影响<code>n</code>行，仅对于<code>\n</code>属性需要使用该属性，<code>+n</code>则表示取出<code>n</code>个字符数，相当于<code>retain</code>操作，不仅可以移动指针，还可以用来持有属性变更。特别需要注意的是<code>|m</code>不会单独出现，其总是与<code>+n</code>一同表达，表示这<code>n</code>个字符中存在<code>m</code>个换行，且最后一个应用的字符必然是<code>\n</code>。</p>
<p>此外，<code>EasySync</code>里面的数字大都是<code>36</code>进制的，因此这里的<code>+i/+e</code>等都不是特殊的符号，需要用<code>0-9</code>数字来表示<code>0-9</code>的字符，而<code>10-35</code>则是表示<code>a-z</code>，例如<code>+i</code>就是<code>i - a = 8 =&gt; 8 + 10 = 18</code>。</p>
<ul>
<li><code>*0</code>表示取出<code>author</code>的属性，<code>|1+i</code>表示将其应用到了<code>i</code>长度即<code>18</code>，字符为<code>short description\n</code>，由于其包含<code>\n</code>则定义<code>|1</code>。</li>
<li><code>*0*1*2*3</code>表示取出前<code>4</code>个属性，<code>+1</code>表示将其应用<code>1</code>个字符，即<code>*</code>字符，在<code>EasySync</code>中行首的该字符承载了行属性，而非放置<code>\n</code>中。</li>
<li><code>*0</code>表示取出<code>author</code>的属性，<code>|2+e</code>表示应用了<code>e</code>长度即<code>14</code>，字符为<code>Heading1\ntext\n</code>，其包含两个<code>\n</code>则定义<code>|2</code>。</li>
<li><code>*0*4*2*3</code>表示取出相关属性，<code>+1</code>表示将其应用<code>1</code>个字符，即<code>*</code>字符表示行属性内容。</li>
<li><code>*0|1+9</code>表示取出<code>author</code>的属性，<code>+9</code>表示将其应用<code>9</code>个字符，即<code>Heading2\n</code>，末尾是<code>\n</code>则定义<code>|1</code>。</li>
<li><code>*0*5+4</code>表示取出加粗等属性，应用<code>4</code>个字符，即<code>bold</code>。</li>
<li><code>*0+1</code>表示取出<code>author</code>的属性，应用<code>1</code>个字符即空格。</li>
<li><code>*0*6+6</code>表示取出斜体等属性，应用<code>6</code>个字符，即<code>italic</code>。</li>
<li><code>*0|2+c</code>表示取出相关属性，应用<code>12</code>个字符即<code>\nplain text\n</code>，存在两个<code>\n</code>则定义<code>|2</code>。</li>
<li><code>|1+1</code>表示末尾的<code>\n</code>属性，在<code>EasySync</code>中行末的该字符需要单独定义。</li>
</ul>
<h3 id="变更描述">变更描述</h3>
<p><code>OT</code>操作变换的基准原子实现就是<code>insert</code>、<code>delete</code>、<code>retain</code>三种操作，那么<code>ChangeSet</code>的内容描述自然也是类似，但是数据的变更描述并非像<code>delta</code>的结构那么清晰，而是特别设计了一套数据结构描述。</p>
<p>文档在最开始创建或是导入的时候是初始的<code>ClientVars</code>，而此后每次对于文档内容的修改则是会生成<code>ChangeSet</code>。针对于上述的三种操作对应了三种符号，<code>=</code>表示<code>retain</code>、<code>+</code>表示<code>insert</code>、<code>-</code>表示<code>delete</code>，这三种符号的组合就可以描述文档内容的变更，除此之外还有额外的定义:</p>
<ul>
<li><code>Z</code>: 首字母为<code>MagicNumber</code>，表示为符号位。</li>
<li><code>:N</code>: 文档原始内容长度为<code>N</code>。</li>
<li><code>&gt;N</code>: 最终文档长度会比原始文档长度长<code>N</code>。</li>
<li><code>&lt;N</code>: 最终文档长度会比原始文档长度短<code>N</code>。</li>
<li><code>+N</code>: 实际执行操作，表示插入了<code>N</code>个字符。</li>
<li><code>-N</code>: 实际实际操作，表示操作删除了<code>N</code>个字符。</li>
<li><code>=N</code>: 实际执行操作，表示操作保留了<code>N</code>个字符，移动指针或应用属性。</li>
<li><code>|N</code>: 表示影响了<code>N</code>行，与上述文档描述一致需要与<code>+/-/=N</code>使用，操作的长度包含<code>N</code>个<code>\n</code>，且末尾操作必须是<code>\n</code>。文档最末尾的<code>\n</code>需要表示的话，则必须要用<code>|1=1</code>表示。</li>
<li><code>*I</code>: 表示应用属性，<code>I</code>为<code>apool</code>中的索引值，在一个<code>+</code>、<code>=</code>或<code>|</code>之前可以有任意数量的<code>*</code>操作。</li>
<li><code>$</code>: 表示结束符号，用于标记<code>Operation</code>部分的结束。</li>
<li><code>char bank</code>: 用于存储<code>insert</code>操作具体的字符内容，在执行插入操作时按序取用。</li>
</ul>
<p>同样是上述的例子，现在的文档中已经存在<code>exist text\n\n</code>的文本内容，紧接着将上述的内容粘贴到文档中，那么发生的<code>User ChangeSet</code>的变更描述如下:</p>
<pre><code class="language-js">({
  changeset:
    "Z:c&gt;1t|1=b*0|1+i*0*1*2*3+1*0|2+e*0*4*2*3+1*0|1+9*0+5*0*5+6*0|1+1*0+a$short description\n*Heading1\ntext\n*Heading2\nbold italic\nplain text",
  apool: {
    numToAttrib: {
      "0": ["author", "a.XYe86foM7oYgmpuu"],
      "1": ["heading", "h1"],
      "2": ["insertorder", "first"],
      "3": ["lmkr", "1"],
      "4": ["heading", "h2"],
      "5": ["italic", "true"],
    },
    nextNum: 6,
  },
});
</code></pre>
<ul>
<li><code>Z</code>表示<code>MagicNumber</code>，即符号位。</li>
<li><code>c</code>表示文档原始内容长度为<code>12</code>，即<code>exist text\n\n</code>内容长度。</li>
<li><code>&gt;1t</code>表示最终文档会比原始内容长度多<code>1t</code>，<code>36</code>进制转换<code>1t</code>为<code>64</code>，具体为<code>char bank</code>索引。</li>
<li><code>|1=b</code>表示移动指针长度为<code>b</code>，转换长度为<code>11</code>，文本内容为<code>exist text\n</code>，末尾为<code>\n</code>定义<code>|1</code>。</li>
<li><code>*0|1+i</code>表示从<code>apool</code>中取出<code>0</code>属性，应用<code>i</code>转换长度为<code>18</code>，文本内容为<code>short description\n</code>，末尾为<code>\n</code>定义<code>|1</code>。</li>
<li><code>*0*1*2*3+1</code>表示取出<code>4</code>个属性，应用为<code>1</code>，文本内容为<code>*</code>，具体则是行属性的起始标记。</li>
<li><code>*0|2+e</code>表示取出<code>0</code>属性，应用<code>e</code>转换长度为<code>14</code>，文本内容为<code>Heading1\ntext\n</code>，末尾为<code>\n</code>且包含两个<code>\n</code>定义<code>|2</code>。</li>
<li><code>*0*4*2*3+1</code>表示取出<code>4</code>个属性，应用为<code>1</code>，文本内容为<code>*</code>，同样是行属性的起始标记。</li>
<li><code>*0|1+9</code>表示取出<code>0</code>属性，应用长度为<code>9</code>，文本内容为<code>Heading2\n</code>，末尾为<code>\n</code>定义<code>|1</code>。</li>
<li><code>*0+5</code>表示取出<code>0</code>属性，应用长度为<code>5</code>，文本内容为<code>bold </code>。</li>
<li><code>*0*5+6</code>表示取出斜体等属性，应用长度为<code>6</code>，文本内容为<code>italic</code>。</li>
<li><code>*0|1+1</code>表示取出<code>0</code>属性，应用长度为<code>1</code>，末尾为<code>\n</code>则定义<code>|1</code>，文本内容为<code>\n</code>。</li>
<li><code>*0+a</code>表示取出<code>0</code>属性，应用长度为<code>a</code>即<code>10</code>，文本内容为<code>plain text</code>。</li>
<li><code>$</code>表示结束符号，后续的内容符号则为<code>char bank</code>，最末尾的<code>\n</code>通常不需要表示，即使表示也需要<code>|1=1</code>单独表示。</li>
</ul>
<h2 id="slate">Slate</h2>
<p><code>slate</code>的数据结构以及选区的设计几乎完全对齐了<code>DOM</code>结构，且数据结构设计并未独立出来，同样基于<code>JSON</code>的结构，非常类似于低代码的结构设计。操作变换是直接在<code>slate</code>的核心模块<code>Transform</code>中实现，且位置相关操作变换的实现分散在<code>Point</code>、<code>Path</code>对象中。</p>
<pre><code class="language-js">[
  {
    type: "paragraph",
    children: [
      { text: "This is editable " },
      { text: "rich", bold: true },
      { text: " text." },
    ],
  },
  { type: "block-quote", children: [{ text: "A wise quote." }] },
];
</code></pre>
<h3 id="operation">Operation</h3>
<p>同样是基于<code>OT</code>实现操作变换算法，线性的数据结构仅需要<code>insert</code>、<code>delete</code>、<code>retain</code>三种基本操作即可实现，而在<code>slate</code>中则实现了<code>9</code>种原子操作来描述变更，这其中包含了文本处理、节点处理、选区变换的操作等。</p>
<ul>
<li><code>insert_node</code>: 插入节点。</li>
<li><code>insert_text</code>: 插入文本。</li>
<li><code>merge_node</code>: 合并节点。</li>
<li><code>move_node</code>: 移动节点。</li>
<li><code>remove_node</code>: 移除节点。</li>
<li><code>remove_text</code>: 移除文本。</li>
<li><code>set_node</code>: 设置节点。</li>
<li><code>set_selection</code>: 设置选区。</li>
<li><code>split_node</code>: 分割节点。</li>
</ul>
<p>实际上仅实现应用还好，其相对应的<code>invert</code>、<code>transform</code>则会更加复杂。在<code>slate</code>中的<code>inverse</code>相关操作在<code>operation.ts</code>中实现，与位置相关的<code>transform</code>在<code>path.ts</code>、<code>point.ts</code>中有相关实现。</p>
<p>而实际上这些操作通常都不会在编辑器中直接调用，<code>slate</code>针对这些最基础的操作进行了封装，实现了<code>Transforms</code>模块。在这个模块中实现了诸多具体的操作，例如<code>insertNodes</code>、<code>liftNodes</code>、<code>mergeNodes</code>、<code>moveNodes</code>、<code>removeNodes</code>等等，这里的操作就远不止<code>9</code>种类型了。</p>
<ul>
<li><code>insertFragment</code>: 在指定的位置插入节点的片段。</li>
<li><code>insertNodes</code>: 在指定的位置插入节点。</li>
<li><code>removeNodes</code>: 在文档中指定的位置删除节点。</li>
<li><code>mergeNodes</code>: 在某个节点与同级的前节点合并。</li>
<li><code>splitNodes</code>: 在某个节点中的指定位置分割节点。</li>
<li><code>wrapNodes</code>: 在某个节点中的指定位置包裹一层节点。</li>
<li><code>unwrapNodes</code>: 在某个节点中的指定位置解除一层包裹节点。</li>
<li><code>setNodes</code>: 在某个节点中的指定位置设置节点属性。</li>
<li><code>unsetNodes</code>: 在某个节点中的指定位置取消节点属性。</li>
<li><code>liftNodes</code>: 在某个节点中的指定位置提升一层节点。</li>
<li><code>moveNodes</code>: 在文档中的指定位置移动节点。</li>
<li><code>collapse</code>: 将选区折叠为插入符。</li>
<li><code>select</code>: 主动设置选区位置。</li>
<li><code>deselect</code>: 取消选区位置。</li>
<li><code>move</code>: 移动选区位置。</li>
<li><code>setPoint</code>: 设置选区的单侧位置。</li>
<li><code>setSelection</code>: 设置新选区位置。</li>
<li><code>delete</code>: 删除选区内容。</li>
<li><code>insertText</code>: 在选区位置插入文本。</li>
<li><code>transform</code>: 在编辑器上<code>immutable</code>地执行<code>op</code>。</li>
</ul>
<h3 id="ot-json">OT-JSON</h3>
<p>类似的，在<code>OT-JSON(json0)</code>中实现了<code>11</code>种操作，富文本场景中<code>SubType</code>仍然需要扩展，那自然就需要更多的操作来描述变更。因此，实际上以<code>JSON</code>嵌套的数据格式来描述内容变更，要比线形的操作复杂得多。</p>
<p>在<code>slate</code>中是自行封装了编辑器的基础<code>op</code>，如果其本身是在<code>OT-JSON</code>的基础上封装<code>Transforms</code>的话，对于实现<code>OT</code>的协同会更方便一些，<code>ShareDB</code>等协同框架都是要参考<code>OTTypes</code>的定义的。当然，基于<code>CRDT</code>实现的协同看起来更加容易处理。</p>
<ul>
<li><code>{p:[path], na:x}</code>: 在指定的路径<code>[path]</code>值上加<code>x</code>数值。</li>
<li><code>{p:[path,idx], li:obj}</code>: 在列表<code>[path]</code>的索引<code>idx</code>前插入对象<code>obj</code>。</li>
<li><code>{p:[path,idx], ld:obj}</code>: 从列表<code>[path]</code>的索引<code>idx</code>中删除对象<code>obj</code>。</li>
<li><code>{p:[path,idx], ld:before, li:after}</code>: 用对象<code>after</code>替换列表<code>[path]</code>中索引<code>idx</code>的对象<code>before</code>。</li>
<li><code>{p:[path,idx1], lm:idx2}</code>: 将列表<code>[path]</code>中索引<code>idx1</code>的对象移动到索引<code>idx2</code>处。</li>
<li><code>{p:[path,key], oi:obj}</code>: 向路径<code>[path]</code>中的对象添加键<code>key</code>和对象<code>obj</code>。</li>
<li><code>{p:[path,key], od:obj}</code>: 从路径<code>[path]</code>中的对象中删除键<code>key</code>和值<code>obj</code>。</li>
<li><code>{p:[path,key], od:before, oi:after}</code>: 用对象<code>after</code>替换路径<code>[path]</code>中键<code>key</code>的对象<code>before</code>。</li>
<li><code>{p:[path], t:subtype, o:subtypeOp}</code>: 对路径<code>[path]</code>中的对象应用类型为<code>t</code>的子操作<code>o</code>，子类型操作。</li>
<li><code>{p:[path,offset], si:s}</code>: 在路径<code>[path]</code>的字符串的偏移量<code>offset</code>处插入字符串<code>s</code>，内部使用子类型。</li>
<li><code>{p:[path,offset], sd:s}</code>: 从路径<code>[path]</code>的字符串的偏移量<code>offset</code>处删除字符串<code>s</code>，内部使用子类型。</li>
</ul>
<h2 id="总结">总结</h2>
<p>数据结构的设计是非常重要的，对于编辑器来说，数据结构的设计直接影响着选区模型、<code>DOM</code>模型、状态管理等模块的设计。在这里我们聊到了很多的数据结构设计，<code>Delta</code>、<code>Changeset</code>的线性结构，<code>Slate</code>的嵌套结构，每种数据都有着各自的设计与考量。</p>
<p>那么在选定好了数据结构后，就可以在此基础上实现编辑器的各个模块。我们接下来会从数据模型出发，设计选区模型的表示，然后在此基础上实现浏览器选区与编辑器选区模型的同步。通过选区模型作为操作的目标，来实现编辑器的基础操作，例如插入、删除、格式化等操作。</p>
<h2 id="每日一题">每日一题</h2>
<ul>
<li><a href="https://github.com/WindRunnerMax/EveryDay" target="_blank" rel="noopener nofollow">https://github.com/WindRunnerMax/EveryDay</a></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/slab/delta/blob/main/src/Delta.ts" target="_blank" rel="noopener nofollow">https://github.com/slab/delta/blob/main/src/Delta.ts</a></li>
<li><a href="https://github.com/slab/delta/blob/main/src/AttributeMap.ts" target="_blank" rel="noopener nofollow">https://github.com/slab/delta/blob/main/src/AttributeMap.ts</a></li>
<li><a href="https://github.com/ether/etherpad-lite/tree/develop/doc/public/easysync" target="_blank" rel="noopener nofollow">https://github.com/ether/etherpad-lite/tree/develop/doc/public/easysync</a></li>
<li><a href="https://github.com/ether/etherpad-lite/blob/develop/src/static/js/Changeset.ts" target="_blank" rel="noopener nofollow">https://github.com/ether/etherpad-lite/blob/develop/src/static/js/Changeset.ts</a></li>
<li><a href="https://github.com/ether/etherpad-lite/blob/develop/src/static/js/AttributePool.ts" target="_blank" rel="noopener nofollow">https://github.com/ether/etherpad-lite/blob/develop/src/static/js/AttributePool.ts</a></li>
<li><a href="https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/interfaces/operation.ts" target="_blank" rel="noopener nofollow">https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/interfaces/operation.ts</a></li>
<li><a href="https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/interfaces/transforms/general.ts" target="_blank" rel="noopener nofollow">https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/interfaces/transforms/general.ts</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013701747261574073" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-22 10:43">2025-04-22 10:42</span>&nbsp;
<a href="https://www.cnblogs.com/WindrunnerMax">WindRunnerMax</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18840221);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18840221', targetLink: 'https://www.cnblogs.com/WindrunnerMax/p/18840221', title: '从零实现富文本编辑器#3-基于Delta的线性数据结构模型' })">举报</a>
</div>
        