
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19017202" title="发布于 2025-08-01 16:34">
    <span role="heading" aria-level="2">微服务Token鉴权的7种方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>最近有球友问我：微服务中Token鉴权除了使用JWT之外，还有什么其他的方案？</p>
<p>今天这篇文章跟大家一起聊聊微服务Token鉴权的7种方案，希望对会有所帮助。</p>
<h2 id="1-为什么必须做token鉴权">1. 为什么必须做Token鉴权？</h2>
<p><strong>传统Session的致命缺陷</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163155896-325084826.png" class="lazyload"></p>
<p>多个服务无法共享Session。</p>
<p>重复认证，导致系统性能严重下降。</p>
<p><strong>2023年某电商平台发送安全事故</strong>：</p>
<pre><code class="language-http">GET /api/users/balance HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIn0.Gfx6VO9tcxwk6xqx9yYzSfebbeKDTHkQKh0xhu4nJE0
</code></pre>
<p>黑客通过XSS攻击窃取此Token后，在<strong>2小时内盗取5万用户余额</strong>，暴露三大漏洞：</p>
<ol>
<li>Token未绑定IP/设备指纹</li>
<li>敏感操作未二次认证</li>
<li>无异常行为检测机制</li>
</ol>
<h2 id="2常见的token鉴权方案">2.常见的Token鉴权方案</h2>
<h3 id="方案1基础jwtredis方案">方案1：基础JWT+Redis方案</h3>
<p>该方案适合初创系统。</p>
<p><strong>核心架构</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163210648-659914258.png" class="lazyload"></p>
<p><strong>致命陷阱</strong>：</p>
<pre><code class="language-java">// 错误示例：未校验Token有效性
public Claims parseJwt(String token) {
    return Jwts.parser() 
        .setSigningKey(SECRET_KEY)
        .parseClaimsJws(token)
        .getBody(); // 若Token被注销仍能解析通过！
}
</code></pre>
<p><strong>正确实现</strong>：</p>
<pre><code class="language-java">// 结合Redis校验Token状态
public boolean validateToken(String token, UserDetails details) {
    String username = extractUsername(token);
    String redisToken = redisTemplate.opsForValue().get("token:"+username);
    
    // 双重验证：签名有效且未注销
    return (username.equals(details.getUsername()) 
        &amp;&amp; !isTokenExpired(token) 
        &amp;&amp; token.equals(redisToken);
}
</code></pre>
<p><strong>适用场景</strong>：用户量&lt;100万的中小型系统</p>
<h3 id="方案2oauth20授权框架">方案2：OAuth2.0授权框架</h3>
<p>该方案是第三方接入的首选。</p>
<p><strong>OAuth2.0包含了4种授权模式</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163227563-1311124976.png" class="lazyload"></p>
<p><strong>授权码模式流程</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163237019-1960405895.png" class="lazyload"></p>
<p><strong>Spring Boot配置示例</strong>：</p>
<pre><code class="language-yaml">spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_SECRET}
            scope: user:email,read:user
        provider:
          github:
            token-uri: https://github.com/login/oauth/access_token
            user-info-uri: https://api.github.com/user
</code></pre>
<blockquote>
<p>关键点：<strong>必须使用PKCE扩展</strong>防止授权码截持攻击</p>
</blockquote>
<h3 id="方案3sa-token轻量级框架">方案3：Sa-Token轻量级框架</h3>
<p>该方案是的国产Token鉴权方案的精品。</p>
<p><strong>三大核心优势</strong>：</p>
<ol>
<li>一行代码实现登录鉴权</li>
</ol>
<pre><code class="language-java">// 登录
StpUtil.login(10001); 

// 鉴权
@SaCheckPermission("user:delete")
public void deleteUser(Long id) {
  // 业务代码
}
</code></pre>
<ol start="2">
<li>内置会话管理</li>
</ol>
<pre><code class="language-java">// 查询所有会话
List&lt;String&gt; sessionList = StpUtil.searchSessionId("user:*", 0, 10);
</code></pre>
<ol start="3">
<li>踢人下线机制</li>
</ol>
<pre><code class="language-java">// 根据账号ID踢人
StpUtil.kickout(10001);

// 根据Token值踢人
StpUtil.kickoutByTokenValue("xxxx");
</code></pre>
<p><strong>网关集成方案</strong>：</p>
<pre><code class="language-java">@Bean
public SaReactorFilter saReactorFilter() {
    return new SaReactorFilter()
        .addInclude("/**")
        .setAuth(obj -&gt; {
            SaRouter.match("/user/**").check(r -&gt; StpUtil.checkPermission("USER"));
            SaRouter.match("/admin/**").check(r -&gt; StpUtil.checkPermission("ADMIN"));
        });
}
</code></pre>
<blockquote>
<p>性能实测：QPS 12,000（Redis集群模式）</p>
</blockquote>
<h3 id="方案4api网关统一鉴权">方案4：API网关统一鉴权</h3>
<p>该方案是微服务的标配。</p>
<p><strong>架构设计</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163252654-1700787460.png" class="lazyload"></p>
<p><strong>响应式鉴权过滤器</strong>：</p>
<pre><code class="language-java">public class AuthFilter implements GlobalFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 提取Token
        String token = extractToken(exchange.getRequest());
        
        // 2. 响应式鉴权调用
        return reactiveAuthService.validateToken(token)
                .flatMap(valid -&gt; {
                    if (!valid) {
                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                        return exchange.getResponse().setComplete();
                    }
                    return chain.filter(exchange);
                });
    }
}
</code></pre>
<p><strong>性能优化技巧</strong>：</p>
<ol>
<li>本地缓存：使用Caffeine缓存验证结果</li>
<li>批量验证：聚合10ms内请求统一鉴权</li>
<li>热点Token特殊处理</li>
</ol>
<h3 id="方案5token中继模式">方案5：Token中继模式</h3>
<p>该方案适合服务链调用。</p>
<p><strong>核心问题</strong>：服务A调用服务B时Token如何传递</p>
<p><strong>解决方案</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163305262-398268086.png" class="lazyload"></p>
<p><strong>Feign中继实现</strong>：</p>
<pre><code class="language-java">@FeignClient(name = "service-b")
public interface ServiceBClient {
    
    @GetMapping("/data")
    Data getData(@RequestHeader("Authorization") String token);
}

// 调用方
public Data getData(String token) {
    // 原样传递Token
    return serviceBClient.getData("Bearer " + token); 
}
</code></pre>
<blockquote>
<p><strong>安全加固</strong>：使用JWT嵌套加密防止内部Token泄露</p>
</blockquote>
<h3 id="方案6jwe加密令牌">方案6：JWE加密令牌</h3>
<p>该方案能保证金融级安全。</p>
<p><strong>与JWT的核心区别</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163317400-729395922.png" class="lazyload"></p>
<p><strong>Java生成示例</strong>：</p>
<pre><code class="language-java">public String createJwe(User user) throws JOSEException {
    // 1. 组装Header
    JWEHeader header = new JWEHeader.Builder(JWEAlgorithm.A256GCMKW, 
            EncryptionMethod.A256GCM).build();
    
    // 2. 创建Payload
    Payload payload = new Payload(new JSONObject()
        .put("sub", user.getId())
        .put("ssn", encrypt(user.getSsn()))); // 敏感信息加密
    
    // 3. 加密Token
    JWEObject jwe = new JWEObject(header, payload);
    jwe.encrypt(new AESEncrypter(SECRET_KEY.getBytes()));
    
    return jwe.serialize();
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>支付凭证</li>
<li>身份证号传输</li>
<li>医疗健康数据</li>
</ul>
<h3 id="方案7双向tls认证">方案7：双向TLS认证</h3>
<p>该方案是零信任架构。</p>
<p><strong>工作流程</strong>：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163330014-168297706.png" class="lazyload"></p>
<p><strong>Spring Boot配置</strong>：</p>
<pre><code class="language-yaml">server:
  ssl:
    key-store: classpath:server-keystore.p12
    key-store-password: changeit
    key-alias: server
    client-auth: need # 关键配置
    trust-store: classpath:client-truststore.p12
    trust-store-password: changeit
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>服务网格内部通信</li>
<li>银行核心系统</li>
<li>政府机密数据交换</li>
</ul>
<h2 id="3性能压测对比">3.性能压测对比</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>平均延时</th>
<th>CPU消耗</th>
<th>安全等级</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础JWT</td>
<td>3ms</td>
<td>15%</td>
<td>★★☆</td>
<td>内部微服务</td>
</tr>
<tr>
<td>OAuth2.0</td>
<td>35ms</td>
<td>40%</td>
<td>★★★☆</td>
<td>第三方开放平台</td>
</tr>
<tr>
<td>Sa-Token</td>
<td>5ms</td>
<td>18%</td>
<td>★★★</td>
<td>快速开发项目</td>
</tr>
<tr>
<td>网关统一鉴权</td>
<td>8ms</td>
<td>25%</td>
<td>★★★☆</td>
<td>多语言混合架构</td>
</tr>
<tr>
<td>Token中继</td>
<td>12ms</td>
<td>30%</td>
<td>★★★</td>
<td>服务链调用</td>
</tr>
<tr>
<td>JWE加密</td>
<td>45ms</td>
<td>60%</td>
<td>★★★★☆</td>
<td>金融敏感数据</td>
</tr>
<tr>
<td>mTLS</td>
<td>20ms</td>
<td>50%</td>
<td>★★★★★</td>
<td>零信任网络</td>
</tr>
</tbody>
</table>
<blockquote>
<p>测试环境：AWS c5.4xlarge 16核32GB × 3节点</p>
</blockquote>
<h2 id="4安全攻防">4.安全攻防</h2>
<h3 id="41-四大攻击手段及防御">4.1 四大攻击手段及防御</h3>
<table>
<thead>
<tr>
<th><strong>攻击类型</strong></th>
<th><strong>防御方案</strong></th>
<th><strong>代码实现</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Token窃取</td>
<td>绑定设备指纹</td>
<td><code>StpUtil.getToken().setExtra("deviceId", fingerprint)</code></td>
</tr>
<tr>
<td>重放攻击</td>
<td>Nonce校验+时间戳</td>
<td><code>redis.opsForValue().setIfAbsent(nonce, "used", 5, TimeUnit.SECONDS)</code></td>
</tr>
<tr>
<td>越权访问</td>
<td>动态权限校验</td>
<td><code>@SaCheckPermission("#user.id")</code></td>
</tr>
<tr>
<td>Token破解</td>
<td>定期轮换签名密钥</td>
<td><code>Jwts.parserBuilder().setSigningKeyResolver(new KeyRotationResolver())</code></td>
</tr>
</tbody>
</table>
<h3 id="42-审计日志必备字段">4.2 审计日志必备字段</h3>
<p>为了保证系统的操作安全，我们需要增加审计日志表。</p>
<p>审计日志必备字段如下：</p>
<pre><code class="language-java">public class AuditLog {
    private String tokenId;      // Token唯一标识
    private String userId;       // 用户ID
    private String operation;    // 操作类型
    private String resource;     // 访问资源
    private String clientIp;     // 客户端IP
    private String deviceInfo;   // 设备信息
    private LocalDateTime time;  // 操作时间
}
</code></pre>
<h2 id="5方案如何选型">5.方案如何选型？</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250801163348322-821544924.png" class="lazyload"></p>
<h2 id="总结">总结</h2>
<ol>
<li><strong>初创期</strong>：基础JWT+Redis方案</li>
<li><strong>发展期</strong>：OAuth2.0+网关鉴权</li>
<li><strong>成熟期</strong>：JWE加密+双向TLS</li>
<li><strong>高级期</strong>：零信任架构+AI风控</li>
</ol>
<blockquote>
<p>微服务安全如同城堡防御——<br>
单一的护城河无法阻挡所有入侵，<br>
需要城墙、箭塔、卫兵的多层防护。<br>
没有绝对安全的系统，只有不断提高的攻击成本。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-01 16:35">2025-08-01 16:34</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">121</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19017202);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19017202', targetLink: 'https://www.cnblogs.com/12lisu/p/19017202', title: '微服务Token鉴权的7种方案' })">举报</a>
</div>
        