
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/VAllen/p/18656600/system-reactive-intro" title="发布于 2025-01-07 00:18">
    <span role="heading" aria-level="2">.NET 响应式编程 System.Reactive 系列文章（一）：基础概念</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        在.NET中，响应式编程的核心库是System.Reactive，通常简称为Rx。本篇文章将介绍响应式编程的基础概念以及System.Reactive的核心组件，为后续深入学习奠定基础。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="net-响应式编程-systemreactive-系列文章一基础概念"><strong>.NET 响应式编程 System.Reactive 系列文章（一）：基础概念</strong></h1>
<h2 id="引言"><strong>引言</strong></h2>
<p>在现代软件开发中，处理<strong>异步事件</strong>和<strong>数据流</strong>已经成为常见的需求，比如用户输入、网络请求、传感器数据等。这些数据流通常是<strong>无限的、异步的、实时的</strong>，而传统的编程方式往往无法优雅地处理这些情况。<b>响应式编程(Reactive Programming)</b>为我们提供了一种新的思路，帮助开发者更自然、更高效地管理数据流和异步事件。</p>
<p>在 .NET 中，响应式编程的核心库是 <strong>System.Reactive</strong>，通常简称为 <strong>Rx</strong>。本篇文章将介绍响应式编程的基础概念以及 <strong>System.Reactive</strong> 的核心组件，为后续深入学习奠定基础。</p>
<hr>
<h2 id="什么是响应式编程"><strong>什么是响应式编程？</strong></h2>
<p><strong>响应式编程（Reactive Programming）</strong>是一种<strong>声明式编程范式</strong>，专注于<strong>异步数据流</strong>和<strong>变化传播</strong>。简单来说，它是一种处理<strong>事件驱动</strong>和<strong>数据变化</strong>的编程方式，可以让程序自动对外部的变化做出反应。</p>
<p>在响应式编程中：</p>
<ul>
<li>数据流可以是<strong>有界的</strong>或<strong>无界的</strong>（无限的）。</li>
<li>数据流的变化可以触发<strong>订阅者</strong>的行为。</li>
<li>订阅者（Observer）可以随时<strong>订阅</strong>或<strong>取消订阅</strong>这些数据流。</li>
</ul>
<h3 id="传统编程-vs-响应式编程"><strong>传统编程 vs. 响应式编程</strong></h3>
<table>
<thead>
<tr>
<th>传统编程</th>
<th>响应式编程</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过轮询来获取数据变化</td>
<td>自动响应数据流的变化</td>
</tr>
<tr>
<td>使用回调函数处理异步</td>
<td>通过订阅和流式操作符处理异步</td>
</tr>
<tr>
<td>不擅长处理无限数据流</td>
<td>专注于处理无限、异步的数据流</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="systemreactive-概述"><strong>System.Reactive 概述</strong></h2>
<p><strong>System.Reactive</strong> 是微软推出的 <strong>Reactive Extensions（Rx）</strong> 的实现，为 .NET 提供了一个强大的<strong>观察者模式</strong>和<strong>操作符库</strong>，让我们可以轻松地管理数据流和异步事件。</p>
<h3 id="核心组件"><strong>核心组件</strong></h3>
<table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IObservable&lt;T&gt;</code></td>
<td>表示一个数据流的<strong>生产者</strong></td>
</tr>
<tr>
<td><code>IObserver&lt;T&gt;</code></td>
<td>表示一个数据流的<strong>消费者</strong>（订阅者）</td>
</tr>
<tr>
<td><code>Subject&lt;T&gt;</code></td>
<td>既是<strong>生产者</strong>也是<strong>消费者</strong></td>
</tr>
<tr>
<td>操作符（Operators）</td>
<td>用于对数据流进行转换、过滤、组合等操作</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="观察者模式简介"><strong>观察者模式简介</strong></h2>
<p><strong>System.Reactive</strong> 的核心是基于<strong>观察者模式（Observer Pattern）</strong>，这是一种常见的设计模式，广泛用于处理事件和回调。</p>
<h3 id="观察者模式的核心接口"><strong>观察者模式的核心接口</strong></h3>
<ol>
<li>
<p><strong>IObservable<t></t></strong>（可观察对象）</p>
<ul>
<li>负责<strong>生产</strong>数据流。</li>
<li>提供 <code>Subscribe</code> 方法，允许观察者订阅它的数据流。</li>
</ul>
</li>
<li>
<p><strong>IObserver<t></t></strong>（观察者）</p>
<ul>
<li>负责<strong>消费</strong>数据流。</li>
<li>定义了以下三个方法：
<ul>
<li><code>OnNext(T value)</code>: 当有新数据时被调用。</li>
<li><code>OnError(Exception error)</code>: 当数据流发生错误时被调用。</li>
<li><code>OnCompleted()</code>: 当数据流结束时被调用。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="简单的示例代码"><strong>简单的示例代码</strong></h3>
<pre><code class="language-csharp">using System;
using System.Reactive.Subjects;

public class Program
{
    public static void Main()
    {
        // 创建一个 Subject，它既是 IObservable 也是 IObserver
        var subject = new Subject&lt;string&gt;();

        // 订阅数据流
        subject.Subscribe(
            onNext: value =&gt; Console.WriteLine($"Received: {value}"),
            onError: error =&gt; Console.WriteLine($"Error: {error.Message}"),
            onCompleted: () =&gt; Console.WriteLine("Completed")
        );

        // 发布数据
        subject.OnNext("Hello");
        subject.OnNext("Reactive Extensions");
        subject.OnCompleted();
    }
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Received: Hello
Received: Reactive Extensions
Completed
</code></pre>
<hr>
<h2 id="observable-vs-task"><strong>Observable vs. Task</strong></h2>
<p>许多人会将 <strong>Observable</strong> 和 <strong>Task</strong> 进行比较，因为它们都用于处理异步操作。但两者之间有一些显著的区别。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Observable</th>
<th>Task</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据流</td>
<td>多个值 / 无限值</td>
<td>单个值</td>
</tr>
<tr>
<td>生命周期</td>
<td>可被取消订阅</td>
<td>一次性操作</td>
</tr>
<tr>
<td>时间维度</td>
<td>持续的时间序列</td>
<td>单次完成的任务</td>
</tr>
<tr>
<td>支持的操作符</td>
<td>丰富的转换、过滤、组合操作符</td>
<td>少数操作符</td>
</tr>
</tbody>
</table>
<p><strong>简单总结：</strong></p>
<ul>
<li><strong>Task</strong> 更适合处理<strong>单次异步操作</strong>。</li>
<li><strong>Observable</strong> 更适合处理<strong>连续的数据流</strong>或<strong>多次异步事件</strong>。</li>
</ul>
<hr>
<h2 id="数据流的三个阶段"><strong>数据流的三个阶段</strong></h2>
<p>在响应式编程中，数据流有三个阶段：</p>
<ol>
<li><strong>OnNext</strong>: 数据流的每一个值都会通过 <code>OnNext</code> 方法传递给订阅者。</li>
<li><strong>OnError</strong>: 如果数据流中出现错误，会通过 <code>OnError</code> 方法通知订阅者。</li>
<li><strong>OnCompleted</strong>: 当数据流结束时，会通过 <code>OnCompleted</code> 方法通知订阅者。</li>
</ol>
<hr>
<h2 id="热数据流和冷数据流"><strong>热数据流和冷数据流</strong></h2>
<p>在 <strong>System.Reactive</strong> 中，数据流可以分为两种类型：</p>
<h3 id="1-冷数据流cold-observable"><strong>1. 冷数据流（Cold Observable）</strong></h3>
<ul>
<li>冷数据流是<strong>被订阅时才开始产生数据</strong>。</li>
<li>每个订阅者都会从<strong>头开始</strong>接收数据。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-csharp">var cold = Observable.Range(1, 5);
cold.Subscribe(x =&gt; Console.WriteLine($"Subscriber 1: {x}"));
cold.Subscribe(x =&gt; Console.WriteLine($"Subscriber 2: {x}"));
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>Subscriber 1: 1
Subscriber 1: 2
Subscriber 1: 3
Subscriber 1: 4
Subscriber 1: 5
Subscriber 2: 1
Subscriber 2: 2
Subscriber 2: 3
Subscriber 2: 4
Subscriber 2: 5
</code></pre>
<h3 id="2-热数据流hot-observable"><strong>2. 热数据流（Hot Observable）</strong></h3>
<ul>
<li>热数据流是<strong>数据流开始时就产生数据</strong>。</li>
<li>每个订阅者会从<strong>当前数据流的位置</strong>开始接收数据。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-csharp">var hot = new Subject&lt;int&gt;();
hot.OnNext(1);
hot.Subscribe(x =&gt; Console.WriteLine($"Subscriber: {x}"));
hot.OnNext(2);
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>Subscriber: 2
</code></pre>
<hr>
<h2 id="总结"><strong>总结</strong></h2>
<p>在本篇文章中，我们介绍了响应式编程的基础概念以及 <strong>System.Reactive</strong> 的核心组件：</p>
<ul>
<li>响应式编程专注于处理<strong>异步数据流</strong>。</li>
<li><strong>System.Reactive</strong> 提供了核心接口 <code>IObservable</code> 和 <code>IObserver</code>。</li>
<li>数据流的生命周期包含 <code>OnNext</code>、<code>OnError</code> 和 <code>OnCompleted</code>。</li>
<li>区分了<strong>冷数据流</strong>和<strong>热数据流</strong>。</li>
</ul>
<p>下一篇文章将介绍 <strong>System.Reactive</strong> 的基础操作符，包括创建、转换和过滤数据流的方法，敬请期待！</p>

</div>
<div id="MySignature" role="contentinfo">
    作者：<a href="http://www.cnblogs.com/vallen/" target="_blank" title="VAllen">VAllen</a><br>出处：<a href="http://www.cnblogs.com/vallen" target="_blank" title="http://www.cnblogs.com/vallen">http://www.cnblogs.com/vallen</a><br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br><b>唯有偏执者得以生存。</b>
<img src="http://www.cnblogs.com/images/xml.gif" style="display:none;" onload="var s3=document.createElement('script');s3.text=decodeURIComponent(escape(window.atob('JCgiPGRpdiBjbGFzcz0nYmRzaGFyZWJ1dHRvbmJveCcgc3R5bGU9J21hcmdpbi10b3A6MTBweDsnPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfbW9yZScgZGF0YS1jbWQ9J21vcmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3F6b25lJyBkYXRhLWNtZD0ncXpvbmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RzaW5hJyBkYXRhLWNtZD0ndHNpbmEnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RxcScgZGF0YS1jbWQ9J3RxcSc+PC9hPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfcmVucmVuJyBkYXRhLWNtZD0ncmVucmVuJz48L2E+PGEgaHJlZj0nIycgY2xhc3M9J2Jkc193ZWl4aW4nIGRhdGEtY21kPSd3ZWl4aW4nPjwvYT48L2Rpdj4iKS5pbnNlcnRBZnRlcigiI015U2lnbmF0dXJlIik7d2luZG93Ll9iZF9zaGFyZV9jb25maWc9eyJjb21tb24iOnsiYmRTbnNLZXkiOnt9LCJiZFRleHQiOiIiLCJiZE1pbmkiOiIyIiwiYmRQaWMiOiIiLCJiZFN0eWxlIjoiMCIsImJkU2l6ZSI6IjMyIn0sInNoYXJlIjp7fSwiaW1hZ2UiOnsidmlld0xpc3QiOlsicXpvbmUiLCJ0c2luYSIsInRxcSIsInJlbnJlbiIsIndlaXhpbiJdLCJ2aWV3VGV4dCI6IuWIhuS6q+WIsO+8miIsInZpZXdTaXplIjoiMTYifSwic2VsZWN0U2hhcmUiOnsiYmRDb250YWluZXJDbGFzcyI6bnVsbCwiYmRTZWxlY3RNaW5pTGlzdCI6WyJxem9uZSIsInRzaW5hIiwidHFxIiwicmVucmVuIiwid2VpeGluIl19fTt3aXRoKGRvY3VtZW50KTBbKGdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF18fGJvZHkpLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKS5zcmM9J2h0dHA6Ly9iZGltZy5zaGFyZS5iYWlkdS5jb20vc3RhdGljL2FwaS9qcy9zaGFyZS5qcz92PTg5ODYwNTkzLmpzP2NkbnZlcnNpb249Jyt+KC1uZXcgRGF0ZSgpLzM2ZTUpXTs=')));s3.setAttribute('type','text/javascript');document.body.appendChild(s3);">
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.015059762023148147" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-07 10:27">2025-01-07 00:18</span>&nbsp;
<a href="https://www.cnblogs.com/VAllen">VAllen</a>&nbsp;
阅读(<span id="post_view_count">282</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656600" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656600);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656600', targetLink: 'https://www.cnblogs.com/VAllen/p/18656600/system-reactive-intro', title: '.NET 响应式编程 System.Reactive 系列文章（一）：基础概念' })">举报</a>
</div>
	