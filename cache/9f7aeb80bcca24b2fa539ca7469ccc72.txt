
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19024111" title="发布于 2025-08-05 21:43">
    <span role="heading" aria-level="2">分布式事务问题的7种常见解决方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>分布式事务问题，无论在面试，还是工作中经常会遇到。</p>
<p>分布式系统下，数据一致性不再是数据库事务那么简单的。</p>
<p>分布式事务作为其中最复杂的挑战之一，曾让无数团队深夜加班、焦头烂额。</p>
<p>今天这篇文章就跟大家一起聊聊分布式事务问题的7种常见解决方案，希望对你会有所帮助。</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250805214145685-2072071939.png" class="lazyload"></p>
<h2 id="1为什么分布式事务如此棘手">1.为什么分布式事务如此棘手？</h2>
<p>在单体应用时代，数据库的ACID事务保证了数据一致性。</p>
<p>但在微服务架构下，<strong>一个业务操作需要跨多个服务、多个数据库</strong>，传统事务模型不再适用。</p>
<p>想象一下电商下单场景：</p>
<ol>
<li>订单服务创建订单（订单数据库）</li>
<li>库存服务扣减库存（库存数据库）</li>
<li>支付服务处理支付（支付数据库）</li>
<li>积分服务增加积分（积分数据库）</li>
</ol>
<p>这四个操作要么<strong>全部成功，要么全部失败</strong>。</p>
<p>这就是分布式事务要解决的核心问题。</p>
<p>那么，如何解决问题呢？</p>
<h2 id="2-常见的解决方案">2. 常见的解决方案</h2>
<h3 id="21-2pc两阶段提交">2.1 2PC（两阶段提交）</h3>
<p>该方案是强一致性方案。</p>
<p>2PC是最经典的分布式事务协议，通过<strong>协调者（Coordinator）</strong> 统一调度<strong>参与者（Participant）</strong> 的执行。</p>
<p>分为两个阶段：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250805214158568-1787005453.png" class="lazyload"></p>
<p><strong>第一阶段：准备阶段</strong><br>
协调者询问所有参与者：“能否提交事务？”</p>
<p>参与者执行本地事务但不提交，锁定资源并回复YES/NO。</p>
<pre><code class="language-java">// 参与者伪代码
public boolean prepare() {
    try {
        startTransaction();
        executeSql("UPDATE account SET frozen = 100 WHERE id = 1"); // 预留资源
        return true; // 返回YES
    } catch (Exception e) {
        rollback();
        return false; // 返回NO
    }
}
</code></pre>
<p><strong>第二阶段：提交/回滚阶段</strong></p>
<ul>
<li>若所有参与者返回YES，协调者发送commit命令，参与者提交事务</li>
<li>若有任一参与者返回NO，协调者发送rollback命令，参与者回滚事务</li>
</ul>
<p><strong>致命缺陷</strong>：</p>
<ul>
<li><strong>同步阻塞</strong>：所有参与者在prepare后锁定资源，直到收到commit/rollback（高并发下吞吐量骤降）</li>
<li><strong>单点故障</strong>：协调者宕机导致参与者永久阻塞</li>
<li><strong>数据不一致</strong>：网络分区时部分参与者可能提交成功</li>
</ul>
<h3 id="22-3pc三阶段提交">2.2 3PC（三阶段提交）</h3>
<p>该方案也是强一致性方案。</p>
<p>3PC可以解决2PC阻塞问题。</p>
<p>3PC在2PC基础上增加<strong>预提交阶段</strong>，并引入<strong>超时机制</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250805214218326-1278100.png" class="lazyload"></p>
<ol>
<li><strong>CanCommit阶段</strong>：协调者询问参与者状态（不锁定资源）</li>
<li><strong>PreCommit阶段</strong>：参与者锁定资源并执行SQL（不提交）</li>
<li><strong>DoCommit阶段</strong>：正式提交</li>
</ol>
<p><strong>改进点</strong>：</p>
<ul>
<li>参与者超时未收到命令自动提交（降低阻塞风险）</li>
<li>预提交阶段发现异常可提前终止</li>
</ul>
<p><strong>但依然存在问题</strong>：</p>
<ul>
<li>网络分区时仍可能数据不一致</li>
<li>实现复杂度显著增加</li>
</ul>
<h3 id="23-tcctry-confirm-cancel">2.3 TCC（Try-Confirm-Cancel）</h3>
<p>该方案是最终一致性方案。</p>
<p>它是业务层面的2PC。</p>
<p>TCC将业务逻辑拆分为三个阶段：</p>
<ul>
<li><strong>Try</strong>：预留资源（如冻结库存）</li>
<li><strong>Confirm</strong>：确认操作（正式扣减库存）</li>
<li><strong>Cancel</strong>：释放资源（解冻库存）</li>
</ul>
<pre><code class="language-java">// 积分服务TCC实现
public class PointsService {
    
    @Transactional
    public boolean tryDeductPoints(Long userId, int points) {
        // 检查用户积分是否充足
        UserPoints user = userPointsDao.selectForUpdate(userId);
        if (user.getAvailable() &lt; points) {
            throw new InsufficientPointsException();
        }
        // 冻结积分
        userPointsDao.freeze(userId, points);
    }
    
    public boolean confirmDeductPoints(Long userId, int points) {
        // 实际扣减冻结积分
        userPointsDao.confirmDeduct(userId, points);
    }
    
    public boolean cancelDeductPoints(Long userId, int points) {
        // 释放冻结积分
        userPointsDao.unfreeze(userId, points);
    }
}
</code></pre>
<p><strong>执行流程</strong>：</p>
<ol>
<li>主业务调用所有服务的try方法</li>
<li>全部try成功则调用confirm；任一try失败则调用cancel</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>无全局锁</strong>：只在try阶段锁定局部资源</li>
<li><strong>高可用</strong>：协调者可集群部署</li>
</ul>
<p><strong>挑战</strong>：</p>
<ul>
<li>需<strong>手动实现回滚逻辑</strong>（业务侵入性强）</li>
<li>所有服务需提供三种接口</li>
</ul>
<blockquote>
<p>金融核心系统首选：某银行跨境支付系统采用TCC方案，日均处理200万笔交易，跨5个服务的事务成功率99.99%</p>
</blockquote>
<h3 id="24-可靠消息最终一致性">2.4 可靠消息最终一致性</h3>
<p>该方案也是最终一致性方案。</p>
<p>可以使用RocketMQ的事务消息。</p>
<p>RocketMQ的事务消息完美解决<strong>本地操作与消息发送的一致性</strong>问题：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250805214234363-55543163.png" class="lazyload"></p>
<p><strong>关键步骤</strong>：</p>
<ol>
<li>发送half消息（对消费者不可见）</li>
<li>执行本地事务</li>
<li>根据本地事务结果commit/rollback</li>
<li>MQ定时回查未决事务</li>
</ol>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-java">// 订单服务使用事务消息
public class OrderService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void createOrder(Order order) {
        // 1. 发送half消息
        Message msg = MessageBuilder.withPayload(order).build();
        TransactionSendResult result = rocketMQTemplate.sendMessageInTransaction(
            "order_topic", msg, null);
        
        // 2. 执行本地事务（在TransactionListener中实现）
    }
}

// 事务监听器
@RocketMQTransactionListener
class OrderTransactionListener implements RocketMQLocalTransactionListener {

    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        try {
            Order order = (Order) msg.getPayload();
            orderDao.save(order); // 本地事务
            return RocketMQLocalTransactionState.COMMIT;
        } catch (Exception e) {
            return RocketMQLocalTransactionState.ROLLBACK;
        }
    }

    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) {
        // 回查逻辑
        return checkOrderStatus(msg);
    }
}
</code></pre>
<h3 id="25-最大努力通知">2.5 最大努力通知</h3>
<p>该方案是弱一致性方案。</p>
<p>适用于<strong>对实时性要求低</strong>的场景（如短信通知）：</p>
<ol>
<li>业务主流程完成后发送通知</li>
<li>失败后按策略重试（如间隔1min、5min、10min）</li>
<li>达到阈值后人工干预</li>
</ol>
<pre><code class="language-java">// 最大努力通知服务
public class BestEffortNotifier {
    
    private static final int[] RETRY_INTERVALS = {1, 5, 10, 30, 60}; // 分钟
    
    public void notify(String event) {
        int retryCount = 0;
        while (retryCount &lt; RETRY_INTERVALS.length) {
            try {
                if (sendNotification(event)) {
                    return; // 通知成功
                }
            } catch (Exception e) {
                // 记录日志
            }
            Thread.sleep(RETRY_INTERVALS[retryCount] * 60 * 1000);
            retryCount++;
        }
        alertManualIntervention(event); // 人工介入
    }
}
</code></pre>
<blockquote>
<p>实战经验：支付回调采用此方案，重试8次跨12小时，99.5%的通知在30分钟内成功</p>
</blockquote>
<h3 id="26-seata-at模式">2.6 Seata AT模式</h3>
<p>该方案是自动化的TCC。</p>
<p>Seata的<strong>AT（Auto Transaction）模式</strong>在<strong>不侵入业务代码</strong>的前提下实现分布式事务：</p>
<p><strong>核心机制</strong>：</p>
<ol>
<li><strong>全局锁</strong>：TC（事务协调器）管理内存级全局锁（替代数据库行锁）</li>
<li><strong>SQL代理</strong>：解析业务SQL自动生成回滚日志</li>
<li><strong>二阶段异步提交</strong>：极大提升吞吐量</li>
</ol>
<pre><code class="language-sql">/* 原始SQL */
UPDATE product SET stock = stock - 10 WHERE id = 1001;

/* Seata自动记录回滚日志 */
INSERT INTO undo_log (branch_id, xid, 
  before_image, after_image) 
VALUES (?, ?, 
  '{"stock":100}',  -- 更新前值
  '{"stock":90}');  -- 更新后值
</code></pre>
<p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>锁持有时间</th>
<th>锁冲突检测耗时</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>传统2PC</td>
<td>500~2000ms</td>
<td>5~20ms</td>
<td>低并发强一致性</td>
</tr>
<tr>
<td>Seata AT</td>
<td>1~10ms</td>
<td>0.01ms</td>
<td>高并发最终一致性</td>
</tr>
</tbody>
</table>
<p><strong>局限</strong>：</p>
<ul>
<li>不支持嵌套事务</li>
<li>热点数据更新冲突率高</li>
</ul>
<h3 id="27-ebay事件队列">2.7 eBay事件队列</h3>
<p>该方案是基于本地事务的最终一致性方案。</p>
<p>eBay提出的经典方案：</p>
<ol>
<li>将分布式操作拆分为<strong>本地事务+异步事件</strong></li>
<li>使用<strong>事件表</strong>确保事件不丢失</li>
<li>通过<strong>补偿机制</strong>解决失败场景</li>
</ol>
<pre><code class="language-sql">-- 订单服务数据库
BEGIN TRANSACTION;
-- 1. 创建订单
INSERT INTO orders (...) VALUES (...); 
-- 2. 记录事件（与订单在同一个事务）
INSERT INTO event_queue (event_type, payload, status) 
VALUES ('ORDER_CREATED', '{"orderId":1001}', 'PENDING');
COMMIT;

-- 定时任务扫描事件表并发布
</code></pre>
<blockquote>
<p>该方案在早期eBay系统中每天处理1亿+事件，保证核心交易链路最终一致</p>
</blockquote>
<h2 id="3方案的选型指南">3.方案的选型指南</h2>
<p>根据业务场景选择合适方案：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>一致性级别</th>
<th>性能</th>
<th>复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>2PC/3PC</td>
<td>强一致性</td>
<td>低</td>
<td>中</td>
<td>银行核心系统</td>
</tr>
<tr>
<td>TCC</td>
<td>最终一致</td>
<td>高</td>
<td>高</td>
<td>电商交易、积分体系</td>
</tr>
<tr>
<td>RocketMQ事务消息</td>
<td>最终一致</td>
<td>高</td>
<td>中</td>
<td>订单创建、物流通知</td>
</tr>
<tr>
<td>最大努力通知</td>
<td>弱一致</td>
<td>高</td>
<td>低</td>
<td>短信提醒、运营通知</td>
</tr>
<tr>
<td>Seata AT</td>
<td>最终一致</td>
<td>高</td>
<td>低</td>
<td>微服务架构的常规业务</td>
</tr>
<tr>
<td>eBay事件队列</td>
<td>最终一致</td>
<td>高</td>
<td>中</td>
<td>内部状态同步</td>
</tr>
</tbody>
</table>
<p><strong>黄金法则</strong>：</p>
<ul>
<li><strong>强一致性需求</strong>：选择2PC/ZooKeeper（牺牲性能）</li>
<li><strong>高并发场景</strong>：选择可靠消息/Seata AT（最终一致）</li>
<li><strong>弱一致性场景</strong>：最大努力通知（成本最低）</li>
</ul>
<h2 id="总结">总结</h2>
<p>经过十年演进，分布式事务解决方案已从<strong>强一致性</strong>向<strong>高性能最终一致性</strong>发展。</p>
<blockquote>
<p>技术没有绝对的好坏，只有适合与否。</p>
</blockquote>
<p>我曾见过团队为了追求理论上的强一致性，把系统搞得复杂不堪；也见过过度追求性能导致资金损失的血泪教训。</p>
<p>分布式事务的本质，是在业务需求与技术可行性之间找到平衡点。</p>
<p><strong>致开发者</strong>：不必追求完美的分布式事务解决方案，<strong>适合业务场景的才是最好的</strong>。</p>
<p>在设计时多问自己：</p>
<ol>
<li>业务能容忍多长时间不一致？</li>
<li>事务失败后如何补偿？</li>
<li>是否有完善的监控和人工介入机制？</li>
</ol>
<p>愿你在分布式系统的海洋中，乘风破浪，游刃有余。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-05 21:44">2025-08-05 21:43</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">51</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19024111);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19024111', targetLink: 'https://www.cnblogs.com/12lisu/p/19024111', title: '分布式事务问题的7种常见解决方案' })">举报</a>
</div>
        