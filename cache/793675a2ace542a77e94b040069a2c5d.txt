
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18799072" title="发布于 2025-03-29 02:05">
    <span role="heading" aria-level="2">【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（4）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1153" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18799072" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18799072" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18799072</a></p>
<h2 id="开题--补题情况">开题 + 补题情况</h2>
<p>和前三场比起来前期的签到题发挥稳定了许多，没有被卡很久，不过 1001 还是因为自己读错题挂了三发，不太应该。<br>
虽然 rank 比之前有提升了，但是还是没有开出除了签到题之外的题，开的题价值不大，自己能力的提升还任重道远啊。<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250329013737447-604785608.png" alt="image" loading="lazy"></p>
<h2 id="1006---进步">1006 - 进步</h2>
<p>第一题就开的这个题。<br>
此题涉及到修改某一天的进步量，查询某个时间区间的进步量，所以是单点修改，区间查询，很容易想到使用树状数组来维护。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; t;
    int n;

    BIT(int n) {
        this -&gt; n = n;
        t = std::vector&lt;T&gt;(n + 1, T(0));
    }

    int lowbit(int x) {
        return x &amp; -x;
    }

    void add(int ix, T v) {
        for(int i = ix;i &lt;= n;i += lowbit(i)) {
            t[i] += v;
        }
    }

    T query(int ix) {
        T res = 0;
        for(int i = ix;i &gt; 0;i -= lowbit(i)) {
            res += t[i];
        }
        return res;
    }
};

void solve()
{
    int n, q;std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;i64&gt; a(n + 1);

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    BIT&lt;i64&gt; t(n + 1);

    for(int i = 1;i &lt;= n;i ++) {
        t.add(i, a[i]);
    }

    i64 ans = 0;
    int sum = 0;

    while(q --) {
        int op;std::cin &gt;&gt; op;
        if(op == 1) {
            int x, y;std::cin &gt;&gt; x &gt;&gt; y;
            t.add(x, y - a[x]);
            a[x] = y;
        } else {
            sum ++;
            int l, r;std::cin &gt;&gt; l &gt;&gt; r;
            i64 e = t.query(r);
            i64 s = t.query(l - 1);

            e = e / 100;
            s = s / 100;
            
            ans ^= ((e - s) * sum);
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1008---制衡">1008 - 制衡</h2>
<p>一开始看到题目，以为是一个需要人类智慧的 DP 题，直到发现了这两个重要线索：</p>
<ul>
<li>允许某些段留空。</li>
<li><span class="math inline">\(j\)</span> 的最大值刚好就是 <span class="math inline">\(k\)</span>。</li>
</ul>
<p>那么转化一下就可以发现，我们的选择，只会往下方及右下方转移。<br>
那么 DP 转移方程就很明显了：<span class="math inline">\(dp_{i, j} = \max(dp_{i - 1, l}) + a_{i, j},l \in [1, j]\)</span>。<br>
因此，在处理完了每一行的 DP 值后，要转化为前缀最值，便于优化转移。<br>
时间复杂度：<span class="math inline">\(O(nk)\)</span>。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

void solve()
{
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;std::vector&lt;int&gt;&gt; a(n, std::vector&lt;int&gt;(k));
    auto dp = a;

    for(auto &amp;i : a) {
        for(auto &amp;j : i) {
            std::cin &gt;&gt; j;
        }
    }

    for(int j = 0;j &lt; k;j ++) {
        dp[0][j] = a[0][j];
        if(j &gt; 0)dp[0][j] = std::max(dp[0][j], dp[0][j - 1]);
    }

    for(int i = 1;i &lt; n;i ++) {
        for(int j = 0;j &lt; k;j ++) {
            dp[i][j] = dp[i - 1][j] + a[i][j];
        }

        for(int j = 1;j &lt; k;j ++) {
            dp[i][j] = std::max(dp[i][j], dp[i][j - 1]);
        }
    }

    std::cout &lt;&lt; dp[n - 1][k - 1] &lt;&lt; '\n';
}

</code></pre>
</details>
<h2 id="1005---持家">1005 - 持家</h2>
<p>这个题和 <a href="https://codeforces.com/contest/2078/problem/D" title="CF2078D" target="_blank" rel="noopener nofollow">CF2078D</a> 有异曲同工之妙。<br>
首先，根据小学数学知识可以知道，打 <span class="math inline">\(x\)</span> 折的意思是当前价格乘 <span class="math inline">\(x / 10\)</span>。<br>
也就是说，打折是和当前价格相关的，而减价是和当前价格无关的，无论当前价格多少，减的是多少就是多少。<br>
而根据乘法的知识我们又能知道，若当前的价格越高，优惠力度会越大，因此对于打折券，一定是价格越高的时候用越好。<br>
那么，<strong>如果我们使用了降价券，就一定不会再次使用任何一张打折券</strong>，因为此时只需要交换打折券和降价券的使用顺序，先打折后降价，我们就能获得更大的优惠力度。<br>
因此，此题的做法就很明显了，我们枚举打折券的使用数量，剩下的就是降价券的使用数量，对于打折券，越低的折扣越优先使用，对于降价券，越高的降价越优先使用，因此可以对两种券分别排序，然后记录一下前缀乘积和前缀和，然后枚举计算取最优解即可。<br>
时间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

void solve()
{
    double p;std::cin &gt;&gt; p;
    int n, k;std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;double&gt; dazhe;
    std::vector&lt;i64&gt; jian;
    for(int i = 1;i &lt;= n;i ++) {
        int op;std::cin &gt;&gt; op;
        i64 v;std::cin &gt;&gt; v;

        if(op == 0) {
            dazhe.push_back(1.0 * v / 10);
        } else {
            jian.push_back(v);
        }
    }

    sort(dazhe.begin(), dazhe.end());
    sort(jian.begin(), jian.end(), std::greater());

    
    for(int i = 1;i &lt; dazhe.size();i ++) {
        dazhe[i] *= dazhe[i - 1];
    }
    
    for(int i = 1;i &lt; jian.size();i ++) {
        jian[i] += jian[i - 1];
    }

    double ans = p;
    for(int i = 0;i &lt;= std::min(k, (int)dazhe.size());i ++) {
        int d = i;
        int j = k - d;

        
        if(d &gt; dazhe.size() || j &gt; jian.size())continue;
        double tmp = p;
        if(d &lt;= 0) {
            tmp = tmp - jian[j - 1];
        } else if(j &lt;= 0) {
            tmp = tmp * dazhe[d - 1];
        } else {
            tmp = tmp * dazhe[d - 1] - jian[j - 1];
        }
        
        ans = std::min(ans, tmp);
        ans = std::max(ans, 0.00);
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>
<h2 id="1001---战斗爽">1001 - 战斗爽</h2>
<p>就是这个题，读假了，读成了怪物每多受一次攻击，下次受到的伤害就要继续减半。<br>
这个题纯模拟题，按题意模拟即可。<br>
我们开一个结构体，存储怪物的编号，血量，攻击力，被攻击次数的信息，并且按题意重载小于号运算符，存入一个优先队列 <span class="math inline">\(pq\)</span>。<br>
再开一个结构体，存储怪物的攻击力，编号信息，并且按攻击力从小到大重载小于运算符，存入一个优先队列 <span class="math inline">\(sha\)</span>。<br>
再开一个数组，存储怪物的血量。</p>
<p>然后就可以开始模拟了，只要我们还活着，并且怪物还有活着的，就从优先队列 <span class="math inline">\(pq\)</span> 中取出堆顶的怪物，并对它进行攻击，更新怪物的血量和被攻击次数，如果他还有血量，并且被攻击次数不满 <span class="math inline">\(k\)</span> 次，就放回优先队列 <span class="math inline">\(pq\)</span> 中，若没有血量了，就添加到答案中，然后检查优先队列 <span class="math inline">\(sha\)</span> 的堆顶怪物是否存活，若死亡，则弹出优先队列，直到堆顶怪物存活，并对我们进行攻击，按照此逻辑模拟至我们死掉或是怪物全死掉为止，输出答案。<br>
时间复杂度：<span class="math inline">\(O(tn\log n)\)</span>，非常的极限。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

struct monster {
    int id, g, x, cnt;
    bool operator &lt; (const monster &amp;v) const {
        if(x != v.x)return x &gt; v.x;
        else if(g != v.g)return g &gt; v.g;
        else if(id != v.id)return id &gt; v.id;
    }
};

struct guai {
    int id, g;
    bool operator &lt; (const guai &amp;v) const {
        return g &lt; v.g;
    }
};

void solve()
{
    int n, u, k, h;std::cin &gt;&gt; n &gt;&gt; u &gt;&gt; k &gt;&gt; h;
    std::vector&lt;int&gt; a(n + 1);

    std::priority_queue&lt;monster&gt; pq;
    std::priority_queue&lt;guai&gt; sha;

    for(int i = 1;i &lt;= n;i ++) {
        int g, x;std::cin &gt;&gt; g &gt;&gt; x;
        a[i] = x;

        pq.push({i, g, x, 0});
        sha.push({i, g});
    }

    int ans = 0;
    while(h &amp;&amp; pq.size()) {
        monster now = pq.top();
        pq.pop();

        if(now.cnt)now.x -= u / 2;
        else now.x -= u;
        now.cnt ++;
        now.x = std::max(0, now.x);
        a[now.id] = now.x;
        if(now.x &amp;&amp; now.cnt &lt; k)pq.push(now);
        if(!now.x)ans ++;

        while(sha.size() &amp;&amp; a[sha.top().id] == 0) {
            sha.pop();
        }

        
        if(sha.size()) {
            h -= sha.top().g;
            h = std::max(h, 0);
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008627535769675926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-29 02:09">2025-03-29 02:05</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18799072" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18799072);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18799072', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18799072', title: '【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（4）' })">举报</a>
</div>
        