
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18816553" title="发布于 2025-04-10 09:10">
    <span role="heading" aria-level="2">重生之我是操作系统(五)----CPU调度</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>当CPU有大量任务要处理，但由于资源有限，无法同时处理。所有就需要<code>某种规则</code>来决定任务处理的顺序，这就是调度。</p>
<h1 id="调度层次">调度层次</h1>
<p>根据调度频率与层次，共分为三种</p>
<ol>
<li>高级调度<br>
也称为作业调度(Long-Trem Scheduling),频次很低，它决定哪些进程从<code>外存(硬盘)加载到内存</code></li>
<li>中级调度<br>
也称为内存调度(Medium-Term Scheduing),频次中等，将暂时无法运行的进程(阻塞进程)交换到外存，也就是所谓的挂起。释放内存资源，后续再重新加载到内存中。</li>
<li>低级调度<br>
也称为进程调度(Short-Term Scheduing),频次极高，每秒可达数千次。它直接决定当前哪个就绪进程获得CPU。</li>
</ol>
<table>
<thead>
<tr>
<th>----</th>
<th>做什么？</th>
<th>发生在哪？</th>
<th>频率</th>
<th>对进程的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>高级调度</td>
<td>选择合适的作业调入内存，并创建进程</td>
<td>外存=&gt;内存</td>
<td>最低</td>
<td>NULL=&gt;初始态=&gt;就绪态</td>
</tr>
<tr>
<td>中级调度</td>
<td>从阻塞队列中选择合适的进程调回内存</td>
<td>外存=&gt;内存</td>
<td>中等</td>
<td>阻塞态=&gt;就绪态</td>
</tr>
<tr>
<td>低级调度</td>
<td>从就绪队列中选择合适的进程配合CPU</td>
<td>内存=&gt;CPU</td>
<td>极高</td>
<td>就绪态=&gt;运行态</td>
</tr>
</tbody>
</table>
<h2 id="进程调度的模型">进程调度的模型</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250409152110825-720500132.png" alt="image" loading="lazy"></p>
<p>相对进程的状态模型，这里出现了两种新状态，就绪挂起和阻塞挂起。<br>
这本质上是一种优化，比如进程进入了就绪态/阻塞态。但该进程优先级很低，CPU根本调度不到该进程，该进程还白白占用内存，那不如将它挂起，从内存移入外存。释放内存为更高优先级的进程服务。</p>
<blockquote>
<p>比如你的屏保程序，是CPU完全没事干的时候，才会运行。如果一直占用内存，只会白白浪费。</p>
</blockquote>
<h3 id="眼见为实">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250409152801424-239525966.png" alt="image" loading="lazy"></p>
<h1 id="常见调度算法">常见调度算法</h1>
<p>调度算法的选择直接影响系统性能，常见算法为<code>抢占式</code>(直接中断)和<code>非抢占式</code>（进程自愿释放）</p>
<ol>
<li>
<p>先来先服务(First-Come First-Served,FCFS)<br>
按照进程进入就绪队列的顺序分配CPU，先到先得。<br>
优点：实现简单，公平性基于到达顺序<br>
缺点：可能导致"护航消息"，短CPU时间的进程要等待长CPU进程执行完成，周转性较差</p>
</li>
<li>
<p>短作业优先(Shortest Job First,SJF)<br>
选择预计执行最短的进程优先运行。<br>
优点：平均周转时间最小化<br>
缺点：需要预知运行时间，实现很难。谁家好人算这个啊！</p>
</li>
<li>
<p>轮转法(Round Robin,RR)<br>
为每个进程分配固定的时间片(比如15ms)，进程时间片用完后，返回就绪队列。<br>
优点：保证程序快速响应，适合交互式系统<br>
缺点：上下文切换频繁，降低系统性能</p>
</li>
<li>
<p>优先级调度(Priority Scheduling)<br>
为每个进程分配优先级，高优先级先执行。<br>
分为静态优先级：进程创建时即确定好优先级，动态优先级：根据运行情况动态调整优先级<br>
优点：按需运行，高优先级进程能占用大量CPU。<br>
缺点：低优先级进程可能一直得不到调用。动态设置优先级时，优先级难以界定。</p>
</li>
<li>
<p>多级反馈队列(Multilevel Feedback Queues)<br>
设置多个优先级队列，比如按照时间片的长短分组。新进程首先进入高优先级队列，如果未在时间片内完成，则降级到下一级队列</p>
</li>
</ol>
<h1 id="进程调度时机与方式">进程调度时机与方式</h1>
<h2 id="什么时候需要进程调度">什么时候需要进程调度？</h2>
<ol>
<li>主动放弃
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>主动阻塞，比如等待I/O，Sleep</li>
</ul>
</li>
<li>被动放弃
<ul>
<li>分配的时间片用完</li>
<li>更高优先级进程的插入，比如I/O中断</li>
</ul>
</li>
</ol>
<h2 id="什么时候不能进程调度">什么时候不能进程调度？</h2>
<ol>
<li>处理中断的过程</li>
<li>进程处于操作系统内核临界区</li>
<li>系统原语操作过程</li>
</ol>
<blockquote>
<p>说人话就时，当系统执行原子操作时，就不能调度。<br>
你都是原子操作了，要是能被调度，那还叫原子操作吗？</p>
</blockquote>
<h2 id="进程调度方式">进程调度方式</h2>
<ol>
<li>抢占式<br>
由操作系统剥夺当前进程的CPU使用权</li>
<li>非抢占式<br>
进程主动放弃CPU，全凭良心。</li>
</ol>
<h2 id="进程调度程序">进程调度程序</h2>
<ol>
<li>支持内核级线程的操作系统，调度的对象是线程</li>
<li>不支持内核级线程的操作系统，调度的对象是进程</li>
</ol>
<h2 id="idle进程">Idle进程</h2>
<p>CPU通电后，就需要一直运行。就算没有工作，也要给CPU几条指令，组成一个循环，在那里<code>空转</code>。<br>
因此系统会创建这么一个特殊的<code>Idle进程</code>。<br>
从它的工作性质不难猜出它的特性：</p>
<ol>
<li>优先级最低</li>
<li>能耗低</li>
<li>啥也不干</li>
</ol>
<h3 id="眼见为实-1">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250224165850356-469942342.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.38049089941087966" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-10 09:10">2025-04-10 09:10</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">257</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18816553" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18816553);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18816553', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18816553', title: '重生之我是操作系统(五)----CPU调度' })">举报</a>

		</p>
	