
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/18850225" title="发布于 2025-04-29 09:13">
    <span role="heading" aria-level="2">毛玻璃实现交友软件心动嘉宾模糊效果</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="线上效果图">线上效果图</h4>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427183319566-1248404628.png" alt="" loading="lazy"></p>
<h4 id="思路分析">思路分析</h4>
<p>图片我们使用背景图片的方式插入<br>
如果我们的图片大于容器的话<br>
我们使用background-size: cover 进行比例缩放,覆盖整个容器<br>
毛玻璃效果使用 backdrop-filter 来进行处理，值越大模糊程度越大</p>
<h4 id="使用毛玻璃实现图片模糊效果">使用毛玻璃实现图片模糊效果</h4>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;使用毛玻璃实现图片模糊效果&lt;/title&gt;
    &lt;style&gt;
      *{
        padding: 0;
        margin: 0;
      }
      /* 设置圆角的大小 */
      :root {
        --radius-value: 8px
      }
      body{
       margin: 400px;
      }
      .box{
        width: 200px;
        height: 280px;
        /* 引入图片 */
        background-image: url("./person1.png");
        /* 图片不平铺 */
        background-repeat: no-repeat;
        /* 图片按比例缩放，覆盖整个容器 */
        background-size: cover; 
        position: relative;
        border-radius: var(--radius-value);
      }
      .set-img-blur{
        width: 100%;
        height: 100%;
        /* 值越大模糊程度越大 */
        backdrop-filter: blur(10px);
        border-radius: 3%;
        border-radius: var(--radius-value);
      }
      .text-info{
        color: #fff;
        position: absolute;
        left: 10px;
        bottom: 10px;
        font-size: 13px;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="box"&gt;
      &lt;div class="set-img-blur"&gt;
        &lt;div class="text-info"&gt;
          &lt;div&gt;成都 | 28岁&lt;/div&gt;
          &lt;div&gt; 研究生&lt;/div&gt;
          &lt;div&gt;Ta看过你10次&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427183451816-1499011285.png" alt="" loading="lazy"></p>
<h4 id="发现问题控制台去掉backdrop-filter属性">发现问题:控制台去掉backdrop-filter属性</h4>
<p>没有想到吧，这么简单就实现了这个效果<br>
但是机智的小伙伴沉思片刻就发现了一个问题<br>
若是用户操作控制台去掉backdrop-filter属性<br>
那不是就可以看见真实的图像了？<br>
这样肯定是不得行的，产品肯定喊你小子改<br>
好嘛，我只有老老实实的去解决这个问题<br>
<img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427183645532-467995706.png" alt="" loading="lazy"></p>
<h4 id="解决用户在控制台去掉backdrop-filter属性问题">解决用户在控制台去掉backdrop-filter属性问题</h4>
<p>方法1：禁用使用操作控制台，通过去监听用户的按键来进行处理<br>
方法2: 使用 MutationObserver 方法来解决</p>
<h4 id="mutationobserver-的简单介绍">MutationObserver 的简单介绍</h4>
<p>用于监测DOM树的变化,它提供了一种异步的方式来监听DOM元素的增加、删除、属性变化、文本节点等变化。<br>
通过MutationObserver,我们可以实时地知道到DOM的变化，并做出相应的操作。<br>
首先我们要选择一个观察的元素对象。<br>
然后通过 new MutationObserver 创建观察者对象，观察发生变化后触发回调函数 。<br>
配置观察选项,这个非常重要，我们等会要详细去了解<br>
最后通过 observer.observe传入需要观察的元素和配置选项</p>
<pre><code>// 第一步:选择目标节点
var targetElement = document.getElementById('domID');

// 回调函数
function callBackFun(mutationsList, observer){
 // mutationsList：一个数组，包含所有检测到的变化。
 // observer：此回调函数的 MutationObserver 实例。
}

// 第二步： 创建观察者对象，观察发生变化后触发回调函数 
let observer = new MutationObserver(callBackFun);

// 第三步：配置观察选项:
let configObj = { attributes: true, childList: true, characterData: true }

//第四步： 传入目标节点和观察选项
observer.observe(targetElement, configObj);

// 适当的时机，停止观察的方法
observer.disconnect();
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427212721556-111012353.jpg" alt="" loading="lazy"></p>
<h4 id="配置观察选项">配置观察选项</h4>
<pre><code>const config = {
  attributes: true,        // 监听属性变化,等会详细介绍一下这个属性，场景：防样式篡改行为
  childList: true,         // 监听某个元素下的子节点变化(不包含目标节点),如:用户在控制台删除(新增)节点，场景：动态内容加载监控
  subtree: true,           // 监听目标节点自身 + 所有后代节点,单独配置{subtree:true}不会产生任何效果，
  attributeFilter: ['id'], // 只监听特定属性(此处为 id),  attributeFilter: ['data-*']监听 data-* 属性的变化
  characterData: true      // 监听目标节点及其所有后代节点的文本内容变化，场景：富文本编辑器内容追踪
};
</code></pre>
<h4 id="attributes-true-的详细介绍">attributes: true 的详细介绍</h4>
<p>1,通过控制台去除了css行内样式的属性<br>
2,通过js给元素新增了某个属性<br>
如:ele.setAttribute()、ele.removeAttribute()、ele.id = 'newId'、ele.className = 'newClass'<br>
3,通过 style 属性修改：如 element.style.color = 'red'。<br>
特别提醒：内部样式表，如:类名{ }这种，在控制台去除样式属性是监听不到的。</p>
<h4 id="subtree-true-的详细介绍">subtree: true 的详细介绍</h4>
<p>监听所有后代节点,单独配置 { subtree:true }不会产生任何效果。<br>
因为 subtree 本身只是一个范围扩展标记，而不是独立的监听类型。<br>
通常需要配合其他选项，如：attributes: true, 监听属性变化。<br>
childList: true, 监听某个元素下的子节点变化(删除，新增)</p>
<h4 id="关于-mutationobserver的回调">关于 MutationObserver的回调</h4>
<p>如果在同一时间,某个被监听的元素属性发生了1000次变化。<br>
MutationObserver的回调函数会执行1000次嘛？<br>
答：不会。只会执行一次。<br>
MutationObserver的回调是异步执行的，并且会将多个变化合并到一个回调函数中去处理。<br>
也就是说，如果在同一时间(或者同一事件循环中)发生了多次变化，这些变化会被收集起来。<br>
然后一次性传递给回调函数，而不是每次变化都立即触发回调。</p>
<h4 id="mutationobserver的使用场景">MutationObserver的使用场景</h4>
<p>总体来讲：只要DOM发生变化，就可以使用MutationObserver。<br>
具体的场景：echarts 容器大小发生变化。用户通过控制台更改了元素的属性。响应式网页。窗口大小发生变化的场景。</p>
<h4 id="使用mutationobserver监听元素的属性是否发生变化">使用MutationObserver监听元素的属性是否发生变化</h4>
<pre><code>&lt;style&gt;
...其他css不变...
.set-img-blur{
  border-radius: var(--radius-value);
}
...其他css不变...
&lt;/style&gt;
&lt;body&gt;
  &lt;div class="box" id="imgbox"&gt;
    &lt;div class="set-img-blur" id="watchElementNode" style="backdrop-filter: blur(10px)"&gt;
      &lt;div class="text-info"&gt;
        &lt;div&gt;成都 | 28岁&lt;/div&gt;
        &lt;div&gt; 研究生&lt;/div&gt;
        &lt;div&gt;Ta看过你10次&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
  // 获取目标元素
  const watchElementNode = document.getElementById('watchElementNode');
  // 声明观察对象
  let observer;
  // 设置配置
  const setConfig = { attributes: true }
  // 修改DOM重新调用
  function watchCallBack(element) {
    console.log('修改DOM重新调用' )
    // 先停止监听避免循环，造成内存异常
    observer.disconnect();
    //重新添加上这个属性
    watchElementNode.style.backdropFilter = 'blur(10px)';
    watchElementNode.style.width = '100%';
    watchElementNode.style.height = '100%';
    // 重新监听（使用异步避免错过中间修改）
    setTimeout(() =&gt; observer.observe(watchElementNode, setConfig), 0);
  }
  // 观察者
  function watchElement(){
    observer = new MutationObserver(watchCallBack)
    observer.observe(watchElementNode, setConfig)
  }
  watchElement()
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427192430997-1323054157.jpg" alt="" loading="lazy"></p>
<h4 id="又发现问题">又发现问题</h4>
<p>我们的背景图是插入在 <code>&lt;div class="box" id="imgbox"&gt;</code> 这个元素上的<br>
毛玻璃的效果是用在<br>
<code>&lt;div class="set-img-blur" id="watchElementNode"&gt; </code> 这个节点上的。<br>
如果用户删除watchElementNode这个节点的话，一样可以看到真实的图像。<br>
怎么来解决这个问题呢?<br>
监听 <code>&lt;div class="box" id="imgbox"&gt;</code>这个元素的子节点是否有变化。<br>
如果监听到发生变化了,给这个节点隐藏起来同时不影响文档布局<br>
<img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427192439528-743673844.jpg" alt="" loading="lazy"></p>
<h4 id="使用mutationobserver监听子节点是否发生变化">使用MutationObserver监听子节点是否发生变化</h4>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;使用毛玻璃实现图片模糊效果&lt;/title&gt;
    &lt;style&gt;
      *{
        padding: 0;
        margin: 0;
      }
      /* 设置圆角的大小 */
      :root {
        --radius-value: 8px
      }
      body{
       margin: 400px;
      }
      .box{
        width: 200px;
        height: 280px;
        /* 引入图片 */
        background-image: url("./person1.png");
        /* 图片不平铺 */
        background-repeat: no-repeat;
        /* 图片按比例缩放，覆盖整个容器 */
        background-size: cover; 
        position: relative;
        border-radius: var(--radius-value);
      }
      .set-img-blur{
        border-radius: var(--radius-value);
      }
      .text-info{
        color: #fff;
        position: absolute;
        left: 10px;
        bottom: 10px;
        font-size: 13px;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="box" id="imgbox"&gt;
      &lt;div class="set-img-blur" id="watchElementNode" style=" backdrop-filter: blur(10px); width: 100%;height: 100%;"&gt;
        &lt;div class="text-info"&gt;
          &lt;div&gt;成都 | 28岁&lt;/div&gt;
          &lt;div&gt; 研究生&lt;/div&gt;
          &lt;div&gt;Ta看过你10次&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;

&lt;/html&gt;
&lt;script&gt;
  // 获取目标元素
  const watchElementNode = document.getElementById('watchElementNode');
  // 声明观察对象
  let observer;
  // 设置配置
  const setConfig = { attributes: true }
  // 修改DOM重新调用
  function watchCallBack(element) {
    console.log('修改DOM重新调用' )
    // 先停止监听避免循环
    observer.disconnect();
    //重新添加上这个属性
    watchElementNode.style.backdropFilter = 'blur(10px)';
    watchElementNode.style.width = '100%';
    watchElementNode.style.height = '100%';
    // 重新监听（使用异步避免错过中间修改）
    setTimeout(() =&gt; observer.observe(watchElementNode, setConfig), 0);
  }
  // 观察者
  function watchElement(){
    observer = new MutationObserver(watchCallBack)
    observer.observe(watchElementNode, setConfig)
  }
  watchElement()

  // 监听 imgbox 以元素的子节点是否发生变化
  const imgBox = document.getElementById('imgbox');
  // 声明观察对象
  let observerImgBox;
  // 设置监听子节点变化以及属性
  const setConfig2 ={ childList: true, attributes: true }
  // 修改DOM后的回调函数
  function imgBoxNodeCallback(element) {
    console.log('imgBoxNode', element )
    // 先停止监听避免循环，造成内存异常
    observerImgBox.disconnect();
    // 隐藏这个元素，同时不影响布局
    imgBox.style.visibility = 'hidden';
    // 重新监听（使用异步避免错过中间修改）
    setTimeout(() =&gt; observerImgBox.observe(imgBox, setConfig2), 0);
  }
  // 观察者
  function watchImgBoxElement2(){
    observerImgBox = new MutationObserver(imgBoxNodeCallback)
    observerImgBox.observe(imgBox, setConfig2)
  }
  watchImgBoxElement2()
  &lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427192448621-239228883.jpg" alt="" loading="lazy"></p>
<h4 id="可以优化一下吗">可以优化一下吗？</h4>
<p>有机制的小伙伴说：我们可以直接去监听 id = imgbox这会元素。<br>
如果这个元素的子节点和子节点的属性发生变化了。<br>
我们直接将这个 id = imgbox 隐藏起来。<br>
这样就不需要写2个监听器了,大佬果然有点东西。<br>
那我们就按照这个思路再来优化一下</p>
<h4 id="监听子节点和子节点的属性是否发生变化">监听子节点和子节点的属性是否发生变化</h4>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;使用毛玻璃实现图片模糊效果&lt;/title&gt;
    &lt;style&gt;
      *{
        padding: 0;
        margin: 0;
      }
      /* 设置圆角的大小 */
      :root {
        --radius-value: 8px
      }
      body{
       margin: 400px;
      }
      .box{
        width: 200px;
        height: 280px;
        /* 引入图片 */
        background-image: url("./person1.png");
        /* 图片不平铺 */
        background-repeat: no-repeat;
        /* 图片按比例缩放，覆盖整个容器 */
        background-size: cover; 
        position: relative;
        border-radius: var(--radius-value);
      }
      .set-img-blur{
        border-radius: var(--radius-value);
      }
      .text-info{
        color: #fff;
        position: absolute;
        left: 10px;
        bottom: 10px;
        font-size: 13px;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="box" id="imgbox"&gt;
      &lt;div class="set-img-blur" id="watchElementNode" style=" backdrop-filter: blur(10px); width: 100%;height: 100%;"&gt;
        &lt;div class="text-info"&gt;
          &lt;div&gt;成都 | 28岁&lt;/div&gt;
          &lt;div&gt; 研究生&lt;/div&gt;
          &lt;div&gt;Ta看过你10次&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
  // 获取需要监听 imgbox 节点
  const imgBox = document.getElementById('imgbox');
  // 声明观察对象
  let observerImgBox;
  // 监听子节点变化，监听属性变化， 监听所有后代节点的变化以及后代节点的属性
  const setConfig2 ={ childList: true, attributes: true, subtree: true,  }
  // 修改DOM后的回调函数
  function imgBoxNodeCallback(element) {
    console.log('imgBoxNode', element )
    // 先停止监听避免循环，造成内存异常
    observerImgBox.disconnect();
    // 隐藏这个元素，同时不影响布局
    imgBox.style.visibility = 'hidden';
    // 重新监听（使用异步避免错过中间修改）
    setTimeout(() =&gt; observerImgBox.observe(imgBox, setConfig2), 0);
  }
  // 观察者
  function watchImgBoxElement(){
    observerImgBox = new MutationObserver(imgBoxNodeCallback)
    observerImgBox.observe(imgBox, setConfig2)
  }
  watchImgBoxElement()
  &lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250427192458444-1336935305.png" alt="" loading="lazy"></p>
<h4 id="最后说一下">最后说一下</h4>
<p>看到最后，我们会发现写的更多的是关于MutationObserver的使用。<br>
而不是毛玻璃的实现。<br>
如机智的小伙伴们说的那样:通过网络就可以看到真实的图片。<br>
因此：要想真正实现这个效果，必须从服务端返回一张模糊图片。<br>
否则，都有办法看到真实的图像</p>
<h4 id="尾声">尾声</h4>
<p>如果你觉得我写的不错的话<br>
请给我点个赞，收藏等于学会哦<br>
对了，求大佬们推荐一个好用的gif录制软件</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.00011931345023148148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-29 11:05">2025-04-29 09:13</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">127</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18850225);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18850225', targetLink: 'https://www.cnblogs.com/IwishIcould/p/18850225', title: '毛玻璃实现交友软件心动嘉宾模糊效果' })">举报</a>
</div>
        