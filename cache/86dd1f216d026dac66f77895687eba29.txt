
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/javadaydayup/p/18631330" title="发布于 2024-12-25 20:06">
    <span role="heading" aria-level="2">哪里有 class 告诉我？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200531518-545706757.png" alt="哪里有 class 告诉我？" class="desc_img">
        本文介绍用户类路径的设置的参数以及不同设置方法的优先级以及从 JVM 源码角度分析了引导类路径是如何设置的，让你对不同的类路径有更深刻的理解。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="说明">说明</h2>
<p>本文中的 JVM 参数和代码在 JDK 8 版本生效。</p>
<h2 id="哪里有用户类">哪里有用户类？</h2>
<p>用户类是由开发者和第三方定义的类，它是由应用程序类加载器加载的。</p>
<p>Java 程序可以通过<code>CLASSPATH</code> 环境变量，JVM 启动参数 <code>-cp</code> 或者 <code>-classpath</code> 指定用户需要加载的类的路径。这两个配置的优先级从低到高，后面的配置会覆盖前面的配置，默认值是「.」，即当前路径。</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400785-209640951.png" alt="image.png" loading="lazy"></p>
<p>接下来对默认值和优先级进行验证：</p>
<h3 id="验证默认值是当前路径">验证默认值是当前路径</h3>
<p>现在有一个 Temp.java 类，它不在任何包路径下：</p>
<pre><code class="language-java">public class Temp {  
    public static void main(String[] args) {  
        System.out.println("Executed!");  
    }  
}
</code></pre>
<p>同时这个时候系统没有配置 <code>CLASSPATH</code> 这个环境变量，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400808-401891996.png" alt="image.png" loading="lazy"></p>
<p>然后拷贝这个编译后的 <code>Temp.class</code> 文件放到 E 盘的下，然后执行命令 <code>java Temp</code> 命令，是能够正常运行这个 Class 文件的。这个时候并没有配置 <code>CLASSPATH</code> 环境变量，同时也没有在执行命令时指定任何参数，说明类加载器是根据 class path 的默认值去找到这个 Class 文件的，这个默认值就是当前路径。如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400850-1538959924.png" alt="image.png" loading="lazy"></p>
<p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html" target="_blank" rel="noopener nofollow">官方文档</a>所说 Java 程序启动的时候会把 class path 的值放到 <code>java.class.path</code> 这个系统属性中，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400882-1043734228.png" alt="image.png" loading="lazy"></p>
<p>修改上面的代码，在程序运行的时候把实际的 class path 打印出来，代码如下：</p>
<pre><code class="language-java">public class Temp {  
    public static void main(String[] args) {  
        System.out.println("Executed!");  
        System.out.println("The actual class path is :" + System.getProperty("java.class.path"));  
    }  
}
</code></pre>
<p>代码执行结果如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400875-106702631.png" alt="image.png" loading="lazy"></p>
<p>可以看到代码打印的结果是「.」，即当前路径。</p>
<h3 id="验证-classpath-环境变量的作用">验证 CLASSPATH 环境变量的作用</h3>
<p>增加 Windows 系统环境变量，因为上面是把 Temp.class 文件放到了 E 盘下面，所以这里设置的 CLASSPATH 环境变量也是 E 盘，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400848-359443434.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400899-1671943105.png" alt="image.png" loading="lazy"></p>
<p>再次运行程序，执行结果如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400804-75311691.png" alt="image.png" loading="lazy"></p>
<p>程序能够正常执行说明通过配置的 E: 这个路径，类加载器能够找到 <code>Temp.class</code> 文件。同时打印的 class path 也是 E: ，符合设置。</p>
<h3 id="验证--cp-或者--classpath-参数的作用">验证 <code>-cp</code> 或者 <code>-classpath</code> 参数的作用</h3>
<p>把上面设置的 <code>CLASSPATH</code> 环境变量删除，然后通过执行 java 命令的时候指定 <code>-cp</code> 参数来设置 class path 的路径。如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400808-401891996.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400857-2002880540.png" alt="image.png" loading="lazy"></p>
<p>程序执行的效果和通过 <code>CLASSPATH</code> 环境变量设置的相同。</p>
<h3 id="验证--cp或--classpath-参数的优先级高于-classpath-环境变量">验证 <code>-cp</code>或 <code>-classpath</code> 参数的优先级高于 <code>CLASSPATH</code> 环境变量</h3>
<p>设置 <code>CLASSPATH</code> 环境变量为 D: ，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400806-230912413.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400839-122539851.png" alt="image.png" loading="lazy"></p>
<p>如果不带 <code>-cp</code> 参数执行执行会提示找不到类，因为 D: 路径下没有 <code>Temp.class</code> 这个文件。如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400834-1503699015.png" alt="image.png" loading="lazy"></p>
<p>带上 <code>-cp</code> 参数后就能够正常执行，这个时候两个配置都有，但是 <code>-cp</code> 参数的配置生效了，说明 <code>-cp</code> 参数的优先级高于 <code>CLASSPAHTH</code> 环境变量，如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400807-1491236696.png" alt="image.png" loading="lazy"></p>
<h2 id="哪里有引导类">哪里有引导类？</h2>
<h3 id="sunbootclasspath-系统属性的值"><code>sun.boot.class.path</code> 系统属性的值</h3>
<p>引导类指的是构成 Java 平台的类，包括 rt.jar 中的类以及其他几个重要的 jar 文件中的类，它们是由引导类加载器（Bootstrap ClassLoader）加载的。</p>
<p>在前面可以看到如果直接在 <code>Temp.class</code> 文件所在的路径下执行 <code>java Temp</code>命令就能够正常执行。那这个 <code>Temp</code> 类的父类是 <code>Object</code> 类，这个类是在 <code>jre/lib</code> 目录下的 <code>rt.jar</code> 包中，但是没有任何地方指定了这个路径，那引导类加载器（BootstrapClassLoader） 是如何找 Object 类并加载的呢？</p>
<p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html" target="_blank" rel="noopener nofollow">官方文档</a>说的引导类加载器加载的 class path 可以通过 <code>sun.boot.class.path</code> 这个系统属性获取到，如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400831-601370254.png" alt="image.png" loading="lazy"></p>
<p>把上面的代码修改为如下：</p>
<pre><code class="language-java">public class Temp {  
    public static void main(String[] args) {  
        System.out.println("Executed!");  
        System.out.println("The actual class path is :" + System.getProperty("sun.boot.class.path"));  
    }  
}
</code></pre>
<p>通过 <code>java Temp</code> 命令执行后(不配置 <code>CLASSPATH</code> 环境变量，让它使用默认值)，结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400870-1538029927.png" alt="image.png" loading="lazy"></p>
<p>可以看到输出结果里面有 rt.jar 包的绝对路径。实际上并没有任何地方指定了这个路径，那么这个路径怎么获取到并设置到 <code>sun.boot.class.path</code> 这个系统属性中的呢？</p>
<h3 id="sunbootclasspath-系统属性赋值源码分析"><code>sun.boot.class.path</code> 系统属性赋值源码分析</h3>
<p>这里以 Windows 平台为例分析一下 HotSpot 虚拟机的源码实现。这里主要涉及到三个文件的内容，分别是：<br>
<code>hotspot\src\share\vm\runtime\arguments.cpp</code><br>
<code>hotspot\src\share\vm\runtime\os.cpp</code><br>
<code>hotspot\src\os\windows\vm\os_windows.cpp</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400893-1031315151.png" alt="image.png" loading="lazy"></p>
<p>源代码的调用链路如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400854-797629742.jpg" alt="arguments.jpg" loading="lazy"></p>
<p><code>arguments.cpp</code> 负责处理 JVM 启动的参数，在这个文件中会初始化 <code>_java_home</code> 和<code>_sun_boot_class_path</code> 系统属性，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400885-1827808804.png" alt="image.png" loading="lazy"></p>
<p>然后调用 <code>os_windows.cpp</code> 的 <code>init_system_properties_values()</code> 方法，在该方法中又会调用 <code>os_windows.cpp</code> 中的 <code>jvm_path()</code> 方法，该方法中会尝试去获取 <code>jvm.dll</code> 的绝对路径，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400890-1634386459.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400879-1414173540.png" alt="image.png" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400877-2099225419.png" alt="image.png" loading="lazy"></p>
<p>然后返回到<code>os_windows.cpp</code> 的 <code>init_system_properties_values()</code> 方法，去除掉路径中的 <code>jvm.dll</code>，<code>server/client</code>，<code>bin</code> 然后放入到前面创建的 <code>_java_home</code> 系统属性中，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400912-2072552421.png" alt="image.png" loading="lazy"></p>
<p>然后再继续调用 <code>os.cpp</code> 中的 <code>set_boot_path()</code> 方法，在这个方法中获取 <code>_java_home</code> 系统属性中的值，用来格式化引导类 jar 包的路径，然后放入到 <code>_sun_boot_class_path</code> 中。 如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400884-606655374.png" alt="image.png" loading="lazy"></p>
<p>这就是 <code>sun.boot.class.path</code> 系统属性值在 Java 程序启动时的设置过程。</p>
<p><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener nofollow">深入理解Java虚拟机</a>中介绍到「引导类加载器负责加载存放在&lt;JAVA_HOME&gt;/lib 目录下或者被 <code>-Xbootclasspath</code> 参数所指定的路径中存放的，且是 Java 虚拟机能够识别的（按照文件名识别，例如 rt.jar，名字不符合的类库即使是放在 lib 目录中也不会被加载）」。这里所描述的「按照文件名识别」指的应该就是上面 <code>os.cpp</code> 的 <code>set_boot_path()</code> 方法中定义的路径常量，只有这些路径常量才会被格式化最终放到 <code>sun.boot.class.path</code> 系统属性中。</p>
<p>目前这个系统属性在 JDK 9 中已经被移除了，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400888-2142499927.png" alt="image.png" loading="lazy"></p>
<p>引导类的路径可以通过 <code>sun.boot.class.path</code> 系统属性或者 <code>-Xbootclasspath</code> JVM 参数设置。</p>
<h3 id="神奇的--xbootclasspathp-参数">神奇的 <code>-Xbootclasspath/p</code> 参数</h3>
<p>除此之外 JVM 还提供了两个参数 <code>-Xbootclasspath/p</code> 和 <code>-Xbootclasspath/a</code>，分别用于在默认的引导类路径前面和后面增加所配置的路径。如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400935-1313464796.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400917-651089151.png" alt="image.png" loading="lazy"></p>
<p><code>-Xbootclasspath/p</code> 这个参数有点意思，它可以用来修复引导类的 Bug 或者扩展类的功能。</p>
<p>比如现在把 <code>java.util.Collections</code> 类拷贝出来，给它增加一个方法 <code>extendMethod()</code>，然后打包成 jar 包，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400801-1964854146.png" alt="image.png" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400947-708567613.png" alt="image.png" loading="lazy"></p>
<p>在代码中通过反射的方式调用 <code>extendMethod()</code> 方法，代码如下所示：</p>
<pre><code class="language-java">public class Temp {  
    public static void main(String[] args) throws Exception {  
        Method method = Collections.class.getDeclaredMethod("extendMethod");  
        method.invoke(null);  
    }  
}
</code></pre>
<p>在执行 java 命令时通过 <code>-Xbootclasspath/p</code> 配置上这个 jar 包。可以看到新增的方法被成功调用了，说明 <code>extend.jar</code> 包中的 <code>Collections</code> 类覆盖了默认的 <code>java.util.Collections</code> 类，因为它在所有的路径前面，所以先被类加载器加载。如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400895-1694870917.png" alt="image.png" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400950-1549125271.png" alt="image.png" loading="lazy"></p>
<p>这个参数在 JDK 9 中也被移除了，取而代之的是 <code>--patch-module</code> 参数，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1878162/202412/1878162-20241225200400887-1940428450.png" alt="image.png" loading="lazy"></p>
<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html" target="_blank" rel="noopener nofollow">findingclasses</a><br>
<a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html" target="_blank" rel="noopener nofollow">PATH and CLASSPATH</a><br>
<a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html#JSERN9" target="_blank" rel="noopener nofollow">JDK 9 Release Notes</a><br>
<a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener nofollow">JEP 261</a><br>
<a href="https://stackoverflow.com/questions/63420048/how-can-we-overwrite-java-base-java-lang-integer-from-openjdk-11-using-patch-m" target="_blank" rel="noopener nofollow">How can we overwrite java.base/java.lang.Integer from OpenJDK 11 using --patch-module?</a><br>
<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener nofollow">深入理解Java虚拟机</a></p>

</div>
<div id="MySignature" role="contentinfo">
    欢迎大家关注我的公众号【javadaydayup】
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007136430071759259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 20:15">2024-12-25 20:06</span>&nbsp;
<a href="https://www.cnblogs.com/javadaydayup">javadaydayup</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18631330" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18631330);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18631330', targetLink: 'https://www.cnblogs.com/javadaydayup/p/18631330', title: '哪里有 class 告诉我？' })">举报</a>
</div>
        