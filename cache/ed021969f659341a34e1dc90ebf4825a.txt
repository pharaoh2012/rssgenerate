<!----> <meta itemprop="headline" content="网页疯狂自动刷新，发生了什么？业务：我传了一张两亿像素的图片而已"> <meta itemprop="keywords" content="React.js"> <meta itemprop="datePublished" content="2024-12-30T00:00:01.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="古茗前端团队"> <meta itemprop="url" content="https://juejin.cn/user/3233040624266695"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-b21437b8="">
            网页疯狂自动刷新，发生了什么？业务：我传了一张两亿像素的图片而已
            <!----> <!----></h1> <div class="container team-follow" data-v-127e663e="" data-v-b21437b8=""><div class="left" data-v-127e663e=""><a href="/team/7198439419173404711/posts" data-v-127e663e=""><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dafcebf7c91d402abd52f072a32deba8~tplv-k3u1fbpfcp-watermark.image?" class="icon" data-v-127e663e=""></a> <div class="content" data-v-127e663e=""><div style="display: flex" data-v-127e663e=""><a href="/team/7198439419173404711/posts" data-v-127e663e=""><p class="title-line" data-v-127e663e=""><span title="古茗前端团队" class="title" data-v-127e663e="">古茗前端团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-127e663e=""></p></a></div> <div class="meta-box team" data-v-127e663e="" data-v-b21437b8=""><time datetime="2024-12-30T00:00:01.000Z" title="Mon Dec 30 2024 00:00:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-127e663e="" data-v-b21437b8="">
                2024-12-30
              </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-127e663e="" data-v-b21437b8=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-127e663e="" data-v-b21437b8=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-127e663e="" data-v-b21437b8=""></circle></svg> <span class="views-count" style="display:none;" data-v-127e663e="" data-v-b21437b8="">
                12,326
              </span> <span class="read-time" data-v-127e663e="" data-v-b21437b8=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-127e663e="" data-v-b21437b8=""><rect width="16" height="16" fill="none" data-v-127e663e="" data-v-b21437b8=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-127e663e="" data-v-b21437b8=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-127e663e="" data-v-b21437b8=""></path></svg>
                阅读15分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-090b3d46="" data-v-127e663e=""><span data-v-090b3d46="" data-v-127e663e=""><i class="byte-icon byte-icon--plus" data-v-127e663e=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"></path><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"></path></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-b21437b8=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-b21437b8=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""> </div> <!----> <span class="position ellipsis" data-v-b21437b8="">
              @古茗科技
            </span></div> <!----> <!----> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/img/banner.a5c9f88.jpg" style="width:100%;height:auto;display:block;" data-v-b21437b8=""> <div id="article-root" itemprop="articleBody" class="main" data-v-b21437b8=""><div class="article-viewer markdown-body cache result"><blockquote>
<p>杨鹏</p>
</blockquote>
<h2 data-id="heading-0">一、背景</h2>
<p>在一个普通的工作日，BUG反馈群突然发来一个视频。视频中显示，我们的H5应用在打开某个下发的资料时，加载图片的过程中陷入了不断刷新的死循环。这个问题直接影响了用户体验，也引发了我们的深入调查。</p>
<h2 data-id="heading-1">二、问题分析</h2>
<p>收到反馈后，我立即在浏览器中打开该资料进行测试。虽然网页没有出现无限刷新的现象，但加载速度明显变慢，操作也非常卡顿。查看控制台和网络请求后，并未发现任何错误提示。然而，在对比加载其他资料时，这些问题并未出现，网页运行正常。因此，可以判断是某篇资料导致的性能问题，而不是网络或环境方面的问题。</p>
<h3 data-id="heading-2">1.性能分析</h3>
<p>遇到性能问题时，第一步肯定是使用工具分析具体原因。我们使用 Safari 浏览器的时间线工具录制了性能数据。我的电脑是 MacBook Pro M3 芯片（16GB 内存），从中可以看到，平均 CPU 利用率竟然达到了 89.7%，并且主线程的大部分性能都用于渲染。由此我们可以推测，网页卡顿的问题大概率出现在浏览器的渲染过程中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38924ce554f540b890a0b9a1fd3e5048~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<h3 data-id="heading-3">2.问题根源</h3>
<p>我们的资料是通过后台富文本配置的，为了深入排查，我检查了问题资料的 HTML 元素，特别关注了页面中的富文本配置的内容。在此过程中，我惊讶地发现，这张图片的分辨率高达 <strong>4505px × 60615px</strong>，是一张超大像素的图片。通过对比其他资料中的图片，发现它们的分辨率明显较低，因此可以初步排除是其他因素引发的问题，最终确定是这张超大分辨率图片导致了浏览器性能瓶颈，进而引发了不断刷新的现象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e487239ebb644b988cee51ad7e041b03~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>那么，不断刷新的原因是什么呢？在尝试过不同浏览器后，我们对这个问题有了些许线索：不同浏览器对于错误的处理行为是不同的。</p>
<ul>
<li><strong>谷歌浏览器</strong>：在谷歌浏览器中，浏览器会提示崩溃。</li>
<li><strong>Safari 浏览器</strong>：在 Safari 浏览器中，浏览器会提示该网页重复出现问题。</li>
<li><strong>钉钉内嵌浏览器</strong>：在我们的复现场景中，钉钉内嵌的浏览器则会导致页面不断刷新。</li>
</ul>
<p>大家可以尝试使用不同的浏览器查看错误处理的方式，这对于选择合适的浏览器也有一定参考意义。</p>
<h2 data-id="heading-4">三、两亿像素图片如何被渲染的</h2>
<p>为了进一步理解问题，我们先了解一下浏览器的渲染过程。按照浏览器渲染的时间顺序，一个网页从获取资源到最终展示在屏幕上，通常会经历以下几个子阶段：</p>
<ul>
<li><strong>构建 DOM 树</strong>：浏览器从网络或磁盘中获取<code>HTML文档</code>，并将其转换为<code>DOM树</code>。该树表示<code>HTML文档</code>的层级关系。</li>
<li><strong>样式合成</strong>：浏览器将获取到的 <code>CSS</code>文件经过标准化、继承和层叠之后计算出最终的形成一个<code>styleSheets</code>表，也有另一种说法叫做<code>CSSOM树</code></li>
<li><strong>布局阶段</strong>：根据 <code>DOM树</code>和样式信息计算页面中每个可见元素的位置和大小，形成布局树，包括滚动条、文字换行等。</li>
<li><strong>分层</strong>：根据布局树将页面划分为多个图层，方便独立渲染和优化性能。</li>
<li><strong>绘制</strong>：渲染线程将图层拆成一个个绘制指令，最后集合成一个绘制列表。</li>
<li><strong>分块</strong>：将图层进一步划分为小块（<code>tiles</code>），提升渲染效率。</li>
<li><strong>光栅化</strong>：将矢量图形的每个小块转化为像素图，生成最终的位图。</li>
<li><strong>合成</strong>：将多个图层和小块按照正确的顺序合成，调用<code>OpenGL</code>（意为"开放图形库"，可以在不同操作系统、不同编程语言间适配2D，3D矢量图的渲染。）生成最终的屏幕显示内容。</li>
</ul>
<h3 data-id="heading-5">1.首次进入页面</h3>
<p>当浏览器解析<code>HTML</code>时，遇到<code>&lt;img&gt;</code>标签便会创建相应的 DOM 节点，同时开始加载图片资源。加载图片时，浏览器会尝试根据<code>CSS</code>样式计算图片的渲染大小。然而，<code>HTML</code>的解析和样式计算是<code>同步</code>进行的，而图片资源加载通常被标记为低优先级，因此是<code>异步</code>完成的。</p>
<p>浏览器的渲染机制会优先保证页面的快速可见性（First Paint）。所以在第一次加载的时候，因为图片还没加载完成无法得知图片的真实宽高的，浏览器会先为其预留默认占位大小。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad7cc0d6d38349698c517cd0e2a2b4c4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<h3 data-id="heading-6">2.绘制</h3>
<p>在绘制阶段，渲染线程将页面的每个图层拆解为绘制指令。</p>
<p>开发者的<code>图层</code>工具中，我们可以看到图层以及相应的渲染指令，在渲染那张两亿像素的图片中，其他的切割和绘制线条指令使用的时间在 0.1 微秒到 2 毫秒不等，但是那张两亿像素的图片绘制指令的执行时间相比于其他指令来说已经是惊人的 78 毫秒了。</p>
<h3 data-id="heading-7">3.分块</h3>
<p>在分块阶段，通过<code>safari</code> 浏览器的时间线工具我们可以看到，在图片加载完成后，合成线程将图片分成几千到几十万像素不等的小块进行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947d6d95424a4a33a8dd8b5cfa6c257b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<h3 data-id="heading-8">4.光栅化</h3>
<p>光栅化阶段是将分块的矢量图形转化为屏幕上的像素数据：</p>
<ul>
<li>每个小块单独处理并通过插值算法（如最近邻插值、双线性插值）调整分辨率。</li>
<li>处理后的光栅数据上传至 GPU 的纹理内存，供最终显示使用。</li>
</ul>
<p>在处理两亿像素图片时，浏览器会使用相应的解码算法将压缩的图片解码为位图（Bitmap）。这一步涉及大量的解码计算，尤其对于两亿像素图片，对 CPU 和 GPU 的计算需求极高。如果在性能较弱的手机设备上运行，可能会导致显著的卡顿，甚至页面崩溃。</p>
<h3 data-id="heading-9">5.图片加载完成</h3>
<p>当图片加载完成，浏览器会触发页面的重新布局。在本案例中，富文本内容中的<code>&lt;img&gt;</code>元素的宽度被富文本编辑器设置为 <code>100%</code>，而父元素的宽度也为 <code>100%</code>。由于图片未显式指定宽高，浏览器在初次渲染时会按照默认行为显示图片的原始尺寸。因此，在渲染过程中，页面可能会短暂地显示几帧图片的原始尺寸。随后，随着父元素的宽度被计算确定，浏览器会将图片调整为父元素的 100% 适配容器的宽度。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1409853d1c7b49c0ba9844fafe8079ba~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<h2 data-id="heading-10">四、解决方案</h2>
<p>经过排查，我们已经明确问题的根本原因是浏览器直接渲染这张超大分辨率图片，导致浏览器在渲染过程中消耗过多资源，从而引发了网页的重复刷新。因此，我们的解决方案主要集中在优化图片的加载和渲染过程，以避免浏览器因处理超大图片而产生性能瓶颈。</p>
<h3 data-id="heading-11">1.上传前校验</h3>
<p>在富文本上传图片的时候，会将图片文件通过接口上传给后端，后端返回预览链接。为了避免因图片尺寸过大而导致的页面卡顿或浏览器崩溃，所以我们需要在图片上传的流程中加入尺寸校验机制。</p>
<h4 data-id="heading-12">a. 前端校验</h4>
<p>我们以常用的<code>wangEditor5</code>富文本编辑器为例，在自定义上传回调中，通过<code>FileReader</code>和<code>Image</code>读取上传的图片文件，对图片进行校验。</p>
<ul>
<li>FileReader：<code>FileReader</code> 是 HTML5 中提供的一个对象，允许我们在客户端读取文件内容。它通常与 <code>&lt;input type="file"&gt;</code> 元素配合使用，能够读取用户选择的文件，并提供不同格式的读取方式（如文本、数据URL、二进制字符串等）。</li>
<li>Image：<code>Image</code> 是 JavaScript 提供的一个构造函数，通常用于在网页中动态创建和操作图像。它允许你加载图像并获取图像的相关信息（如宽度、高度等），并能够在页面中动态插入图像元素。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">editorConfig.<span class="hljs-property">MENU_CONF</span>[<span class="hljs-string">'uploadImage'</span>] = {
  <span class="hljs-comment">// 自定义上传回调</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">customUpload</span>(<span class="hljs-params">file, insertFn</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 创建一个 FileReader 对象，用于读取文件内容</span>
      <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();
      <span class="hljs-comment">// 使用 Promise 包装 FileReader 的异步操作</span>
      <span class="hljs-keyword">const</span> fileData = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// 当文件读取成功时，调用 resolve 并传入读取的结果</span>
        reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>);
        <span class="hljs-comment">// 当文件读取失败时，调用 reject 并传入错误信息</span>
        reader.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err);
        <span class="hljs-comment">// 以 Data URL 的形式读取文件内容</span>
        reader.<span class="hljs-title function_">readAsDataURL</span>(file);
      });

      <span class="hljs-comment">// 创建一个 Image 对象，用于加载图片</span>
      <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
      <span class="hljs-comment">// 使用 Promise 包装 Image 的异步加载操作</span>
      <span class="hljs-keyword">const</span> imgLoad = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// 当图片加载成功时，检查图片尺寸</span>
        img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-comment">// 获取图片宽高</span>
          <span class="hljs-keyword">const</span> { width, height } = img;

          <span class="hljs-comment">// 校验图片尺寸是否超过 2000x2000</span>
          <span class="hljs-keyword">if</span> (width &gt; <span class="hljs-number">2000</span> || height &gt; <span class="hljs-number">2000</span>) {
            <span class="hljs-comment">// 如果超过，调用 reject 并传入错误信息</span>
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'图片尺寸超过 2000x2000'</span>));
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果尺寸合适，调用 resolve</span>
            <span class="hljs-title function_">resolve</span>();
          }
        };
        <span class="hljs-comment">// 当图片加载失败时，调用 reject 并传入错误信息</span>
        img.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err);
        <span class="hljs-comment">// 设置图片的 src 属性为文件数据</span>
        img.<span class="hljs-property">src</span> = fileData;
      });

      <span class="hljs-comment">// 模拟上传时间，等待 1 秒</span>
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
      <span class="hljs-comment">// 调用 insertFn 函数插入图片，传入文件数据、文件名和文件数据</span>
      <span class="hljs-title function_">insertFn</span>(fileData, file.<span class="hljs-property">name</span>, fileData);
      <span class="hljs-comment">// 上传成功的操作...</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'上传成功'</span>);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 上传失败的操作...</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'上传失败'</span>, error);
    }
  },

  <span class="hljs-comment">// ...其他可能需要的回调函数</span>
};
<span class="hljs-comment">// ...将editorConfig配置到wangEditor的实例中</span>
</code></pre>
<p>参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.wangeditor.com%2Fv5%2Fmenu-config.html%23%25E4%25B8%258A%25E4%25BC%25A0%25E5%259B%25BE%25E7%2589%2587" target="_blank" title="https://www.wangeditor.com/v5/menu-config.html#%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87" ref="nofollow noopener noreferrer">www.wangeditor.com/v5/menu-con…</a></p>
<h4 data-id="heading-13">b. 后端校验</h4>
<p>除了在前端直接处理图片的尺寸校验，我们也可以选择将图片上传到后端后，再由后端进行尺寸校验。如果图片尺寸不符合预期，后端可以返回错误信息，告知前端图片上传失败。这种方法的好处在于能够避免浏览器处理超大图片时带来的性能问题，同时也能更灵活地控制上传流程，确保图片符合业务需求。</p>
<p>但是，后端校验也会存在着一些缺点：</p>
<ul>
<li><strong>增加服务器负担</strong>：每次上传图片时，后端需要处理图片的校验工作，这会额外增加服务器的计算和存储压力，尤其是在高并发情况下，可能会影响服务器性能和响应速度。</li>
<li><strong>用户体验差</strong>：图片需要先上传到服务器，再进行校验和返回结果，这会导致上传过程的延迟，尤其对于较大的图片文件，这种延迟会更加明显，影响用户体验。</li>
</ul>
<h3 data-id="heading-14">2.通过阿里云参数对图片进行在线处理</h3>
<p>我们的图床托管在阿里云，因此可以使用数据处理（x-oss-process）对图片进行在线处理。</p>
<p>例如使用缩放功能<code>x-oss-process=image/resize</code> 在我们的图片链接上添加缩放，确保图片在渲染前就是已经优化后的图片。这一方案同样也可以减少渲染负担。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4e7b55c87294cd1b2a30946855b6d84~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>参考链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Foss%2Fuser-guide%2Fresize-images-4%3Fspm%3Da2c4g.11186623.help-menu-31815.d_2_13_1_1_0.3d8179a70ZsAzB" target="_blank" title="https://help.aliyun.com/zh/oss/user-guide/resize-images-4?spm=a2c4g.11186623.help-menu-31815.d_2_13_1_1_0.3d8179a70ZsAzB" ref="nofollow noopener noreferrer">如何缩放图片_对象存储(OSS)-阿里云帮助中心</a></p>
<p>但是这种方案的缺点在于，图床中任然会存在不符合规范的图片（如尺寸过大或格式不合适），会占用图床的存储资源。而且，图像处理的参数依赖于图床服务是否支持自动处理和参数化，若图床不支持或处理能力有限，则可能导致图片加载不如预期。</p>
<h3 data-id="heading-15">3.分块懒加载</h3>
<p>假如，业务说，我就是要渲染一张这么大像素的图片呢？当然，我们也有办法解决——分块懒加载。</p>
<ul>
<li><strong>图像分块</strong><br>
在分块懒加载中，一张超大图像会被分割成多个小块（称为<strong>chunk</strong>）。每个小块包含图像的一部分，通常根据设定的分块大小来决定每个小块的宽高。分块后，整个大图像就变成了一个个小的矩形区域。</li>
<li><strong>按需加载（懒加载）</strong><br>
与传统的图片加载方式不同，分块懒加载会根据用户当前的可视区域（视口）动态加载图片块。只有用户滚动到特定区域时，相关的小块才会被加载。这种方式避免了在页面加载时一次性加载所有的图片数据，从而节省了带宽并优化了性能。</li>
</ul>
<h4 data-id="heading-16">实现步骤</h4>
<p>我们可以思考一下，我们需要将一张大图分块懒加载，我们需要怎么做：</p>
<ol>
<li><strong>获取图片原始宽高</strong>：在渲染前获取图片的实际尺寸。</li>
<li><strong>设定分块大小</strong>：确定每个分块的尺寸，并计算出需要的横向和纵向分块数量。</li>
<li><strong>裁切图片</strong>：在渲染前裁切图片，使每个小块的尺寸符合设定的分块大小。</li>
<li><strong>分块坐标</strong>：遍历计算出的分块数量，生成每个分块的坐标信息。</li>
<li><strong>懒加载</strong>：使用 <code>&lt;img&gt;</code> 标签渲染每个分块，并通过 <code>loading="lazy"</code> 属性实现懒加载。</li>
</ol>
<p>其中，渲染前获取图片信息和裁切是通过浏览器技术无法支持的，因为我都还没渲染出来，我怎么能拿到一个网络图片的信息呢？所以我们同样需要使用到阿里云的数据处理（x-oss-process）对图片进行在线处理。</p>
<h4 data-id="heading-17">x-oss-process=image/info</h4>
<p>通过在图片URL中添加info参数的方式，会返回图片的基本信息，例如图片大小、格式、图片高度以及图片宽度等。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"FileSize"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"21839"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"Format"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"jpg"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"FrameCount"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ImageHeight"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"267"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ImageWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"400"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ResolutionUnit"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"XResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1/1"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"YResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1/1"</span><span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>参考链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Foss%2Fuser-guide%2Fquery-the-exif-data-of-an-image-4%3Fspm%3Da2c4g.11186623.help-menu-31815.d_2_13_1_1_5.5befb783ucisb8%26scm%3D20140722.H_44975._.OR_help-T_cn~zh-V_1" target="_blank" title="https://help.aliyun.com/zh/oss/user-guide/query-the-exif-data-of-an-image-4?spm=a2c4g.11186623.help-menu-31815.d_2_13_1_1_5.5befb783ucisb8&amp;scm=20140722.H_44975._.OR_help-T_cn~zh-V_1" ref="nofollow noopener noreferrer">如何获取图片的EXIF信息_对象存储(OSS)-阿里云帮助中心</a></p>
<h4 data-id="heading-18">x-oss-process=image/crop</h4>
<p>自定义裁剪功能可以根据自己的需要在原图的基础上裁切出需要的图片。</p>
<p>我们此次用到的参数有下面几个：</p>






























<table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td><strong>w</strong></td><td>指定裁剪宽度。</td><td>[0,图片宽度]默认为最大值。</td></tr><tr><td><strong>h</strong></td><td>指定裁剪高度。</td><td>[0,图片高度]默认为最大值。</td></tr><tr><td><strong>x</strong></td><td>指定裁剪起点横坐标（默认左上角为原点）。</td><td>[0,图片边界]</td></tr><tr><td><strong>y</strong></td><td>指定裁剪起点纵坐标（默认左上角为原点）。</td><td>[0,图片边界]</td></tr></tbody></table>
<p>参考链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Foss%2Fuser-guide%2Fcustom-crop%3Fspm%3Da2c4g.11186623.help-menu-31815.d_2_13_1_1_2.186db7831yKbXI" target="_blank" title="https://help.aliyun.com/zh/oss/user-guide/custom-crop?spm=a2c4g.11186623.help-menu-31815.d_2_13_1_1_2.186db7831yKbXI" ref="nofollow noopener noreferrer">通过自定义裁剪获取符合指定大小的OSS图片_对象存储(OSS)-阿里云帮助中心</a></p>
<h4 data-id="heading-19">具体实现</h4>
<p>特别需要注意的是，在计算图片的边界情况时，需要计算边界的实际宽高，而不是直接使用固定的分块大小。这样可以避免出现渲染重复内容的问题。</p>
<pre><code class="hljs language-ini" lang="ini">import { useEffect, useState } from "react"<span class="hljs-comment">;</span>
import "./App.css"<span class="hljs-comment">;</span>
import axios from "axios"<span class="hljs-comment">;</span>

function App() {
  const <span class="hljs-section">[imageInfo, setImageInfo]</span> = useState({
    width: 0,
    height: 0,
  })<span class="hljs-comment">;</span>
  const <span class="hljs-section">[chunks, setChunks]</span> = useState&lt;{ x: number<span class="hljs-comment">; y: number }[]&gt;([]);</span>

  // 分块大小 可以根据需求调整
  const <span class="hljs-attr">CHUNK_SIZE</span> = <span class="hljs-number">500</span><span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    async function fetchImageInfo() {
      const <span class="hljs-attr">res</span> = (
        await axios.get(
          `xxxx.png?<span class="hljs-attr">x-oss-process</span>=image/info` //替换成某个阿里云托管图片的 url
        )
      )?.data<span class="hljs-comment">;</span>

      const <span class="hljs-attr">info</span> = {
        width: res.ImageWidth.value,
        height: res.ImageHeight.value,
      }<span class="hljs-comment">;</span>
      setImageInfo(info)<span class="hljs-comment">;</span>

      // 根据设定的分块大小（CHUNK_SIZE），计算需要的横向和纵向分块数量。
      // 使用 Math.ceil() 确保即使最后一块不足 CHUNK_SIZE 也会被覆盖。
      const <span class="hljs-attr">horizontalChunks</span> = Math.ceil(info.width / CHUNK_SIZE)<span class="hljs-comment">;</span>
      const <span class="hljs-attr">verticalChunks</span> = Math.ceil(info.height / CHUNK_SIZE)<span class="hljs-comment">;</span>

      // 创建一个空数组来存储分块信息
      const <span class="hljs-attr">newChunks</span> = []<span class="hljs-comment">;</span>
      // 遍历纵向分块
      for (let <span class="hljs-attr">y</span> = <span class="hljs-number">0</span><span class="hljs-comment">; y &lt; verticalChunks; y++) {</span>
        // 遍历横向分块
        for (let <span class="hljs-attr">x</span> = <span class="hljs-number">0</span><span class="hljs-comment">; x &lt; horizontalChunks; x++) {</span>
          // 将每个分块的坐标添加到数组中
          newChunks.push({ x, y })<span class="hljs-comment">;</span>
        }
      }
      setChunks(newChunks)<span class="hljs-comment">;</span>
    }
    fetchImageInfo()<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  return (
    &lt;div
      <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>
      <span class="hljs-attr">style</span>={{
        position: "relative",
        // 设置容器的大小为图片的尺寸
        width: imageInfo?.width || "100%",
        height: imageInfo?.height || "100%",
        margin: "0 auto",
        overflow: "auto",
      }}
    &gt;
      {chunks.map(({ x, y }) =&gt; {
        // 计算实际的宽度，取分块大小和剩余宽度的最小值
        const <span class="hljs-attr">actualWidth</span> = Math.min(
          CHUNK_SIZE,
          imageInfo.width - x * CHUNK_SIZE
        )<span class="hljs-comment">;</span>
        // 计算实际的高度，取分块大小和剩余高度的最小值
        const <span class="hljs-attr">actualHeight</span> = Math.min(
          CHUNK_SIZE,
          imageInfo.height - y * CHUNK_SIZE
        )<span class="hljs-comment">;</span>

        return (
          &lt;img
            <span class="hljs-attr">key</span>={`<span class="hljs-variable">${x}</span>-<span class="hljs-variable">${y}</span>`}
            <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span>
            <span class="hljs-attr">src</span>={`xxxx.png?x-oss-process=image/crop,x_${
              x * CHUNK_SIZE
            },y_${y * CHUNK_SIZE},w_${actualWidth},h_${actualHeight}`}
            <span class="hljs-attr">style</span>={{
              position: "absolute",
              left: x * CHUNK_SIZE,
              top: y * CHUNK_SIZE,
              width: actualWidth,
              height: actualHeight,
              // 设置分块的边框为红色，方便查看分块
              border: "1px solid red",
            }}
            <span class="hljs-attr">alt</span>={`chunk-<span class="hljs-variable">${x}</span>-<span class="hljs-variable">${y}</span>`}
            <span class="hljs-attr">onError</span>={(e) =&gt; console.error(<span class="hljs-string">"加载失败:"</span>, e)}
            <span class="hljs-attr">onLoad</span>={() =&gt; console.log(`加载分块成功: <span class="hljs-variable">${x}</span>-<span class="hljs-variable">${y}</span>`)}
          /&gt;
        )<span class="hljs-comment">;</span>
      })}
    &lt;/div&gt;
  )<span class="hljs-comment">;</span>
}

export default App<span class="hljs-comment">;</span>
</code></pre>
<p>通过这种分块懒加载的方式，我们显著提高了渲染超大图片的性能。因为我们只渲染用户当前视口内可见的部分，其他部分则通过懒加载的方式动态加载。这样不仅能减少初始加载时间，还能显著降低对设备性能的需求，尤其是在移动设备上，能够有效避免因图片过大导致的卡顿或崩溃问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a5cca4b97e147bab05fd654eb7db5aa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c1b17c1b095496783b30b0a26a36489~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<h2 data-id="heading-20">五、总结</h2>
<p>此次问题的根源在于浏览器渲染机制对超大像素图片的处理。当图片分辨率超出设备性能的承载范围时，渲染阶段的计算量急剧增加，导致浏览器崩溃甚至页面进入无限刷新的死循环。通过对浏览器渲染流程的分析，我们发现，图片的加载、重排和光栅化等阶段是性能瓶颈的关键所在。尤其是在光栅化阶段，浏览器需要将超大图像转化为位图，这一过程对CPU和GPU的计算资源需求非常高，进一步加重了性能负担。</p>
<p>这个案例提醒我们，在设计和开发过程中，必须时刻关注性能瓶颈，尤其是在涉及大规模资源（如图片、视频等）的加载和渲染时，更应该小心谨慎。我们应当预见到潜在的性能问题，采用优化手段（如分块加载、懒加载、图像压缩等）来确保应用在各种设备上的流畅体验。此外，及时的性能分析和工具使用（如浏览器的性能分析工具）能够帮助我们迅速定位问题，并采取针对性措施进行优化。总之，只有充分考虑性能因素，才能在保证功能实现的同时，避免应用出现卡顿或崩溃等影响用户体验的情况。</p></div></div>