
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/echo-sama/p/18995636" title="发布于 2025-07-21 13:49">
    <span role="heading" aria-level="2">[WPF]在WPF中使用ObservableCollections显示Microsoft.Extensions.Logging的日志信息</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>先前一段时间用RichTextBox实现了Microsoft.Extension.Logger的日志显示。虽然是用RichTextBox总感觉哪里不对劲，想要添加过滤显得非常复杂。最近了解并学习了ObservableCollection这个库（有点火星救援了啊），遂想到了一个更好的实现方式。</p>
<h2 id="引入observablecollections库">引入ObservableCollections库</h2>
<ol>
<li>在包管理中引入ObservableCollections库</li>
</ol>
<h2 id="可观察的日志">可观察的日志</h2>
<ol>
<li>首先定义一个Log实体<code>LogMessage</code>。为了后面更好实现Filiter功能，添加LogLevel，EventId等属性。</li>
<li>在应用程序运行期间，需要有个存储<code>LogMessage</code>的地方，这里定义接口<code>ILogMessageHolder</code>, 使用<code>ObservableFixedSizeRingBuffer</code>做容器（环形数组，可以使用指定大小的size），整个Observable Logs就是这个ObservableCollections库里的容器。</li>
</ol>
<pre><code class="language-csharp">
public struct LogMessage
{
    public LogLevel LogLevel { get; set;}
    public EventId EventId { get; set;}
    public string Category { get; set;}
    public DateTime Time { get; set;}
    public string Message { get; set;}
}

public interface ILoggerMessageHolder
{
    public ObservableFixedSizeRingBuffer&lt;LogMessage&gt; LogMessages {get;}
}
</code></pre>
<h2 id="实现logger等其他东西">实现Logger等其他东西</h2>
<ol>
<li>实现LogMessageProcessor, 这里依然参照ConsoleLoggerProcessor的实现。（有个疑问，直接往LogMessage容器里添加新项，性能能开销应该不大，这里还需要使用工作线程来执行Enqueue操作吗?）</li>
</ol>
<pre><code class="language-csharp">internal class LogMessageProcessor
{
    //... 省略字段和其余方法实现

    public LogMessageProcessor(ILogMessageHolder logMessageHolder, LoggerQueueFullMode fullMode, int maxQueueLength)
    {
        _logMessageHolder = logMessageHolder;
        _messageQueue = new();
        FullMode = fullMode;
        MaxQueueLength = maxQueueLength;
        _outputThread = new Thread(ProcessMessageQueue)
        {
            IsBackground = true,
            Name = "LogMessage queue processing thread"
        };
        _outputThread.Start();
    }

    //将 WriteMessage 中写入Console的部分修改为往LogMessage容器里添加LogMessage
    internal void WriteMessage(LogMessage message)
    {
        try
        {
            _logMessageHolder.LogMessages.AddLast(message);
        }
        catch
        {
            CompleteAdding();
        }
    }
}
</code></pre>
<ol start="2">
<li>实现Logger。其实这里的LogFormatter属性可要可不要，因为这里的Formatter只对TState做格式化，可以直接做成一个内部的格式化器。当然，这里使用LogFormatter方便后期直接在配置中直接替换实现</li>
</ol>
<pre><code class="language-csharp">internal class Logger : ILogger
{
    private readonly string _category;
    private readonly LogMessageProcessor _processor;
    private StringWriter? t_stringWriter;
    internal IExternalScopeProvider ScopeProvider { get; set; }
    public Logger(string category, LogMessageProcessor processor, LogFormatter formatter,IExternalScopeProvider scopeProvider)
    {
        _category = category;
        _processor = processor;
        Formatter = formatter;
        ScopeProvider = scopeProvider;
    }

    public LogFormatter Formatter { get; set; }

    public IDisposable? BeginScope&lt;TState&gt;(TState state) where TState : notnull
    {
        return ScopeProvider.Push(state) ?? NullScope.Instance;
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        return true;
    }

    public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
    {
        t_stringWriter ??= new StringWriter();
        var entry = new LogEntry&lt;TState&gt;(logLevel, _category, eventId, state, exception, formatter);

        Formatter.Write(entry, t_stringWriter);

        var sb = t_stringWriter.GetStringBuilder();
        var computedString = sb.ToString();
        sb.Clear();
        _processor.WriteMessage(new LogMessage()
        {
            Time = DateTime.Now,
            Id = eventId,
            Level = logLevel,
            Category = _category,
            Message = computedString,
        });
    }
}
</code></pre>
<ol start="3">
<li>实现LoggerProvider和LoggingBuilderExtension</li>
</ol>
<pre><code class="language-csharp">internal class LoggerProvider : ILoggerProvider
{
    private readonly LogFormatter _formatter;
    private readonly ConcurrentDictionary&lt;string, Logger&gt; _loggers = [];
    private readonly LogMessageProcessor _processor;

    public LoggerProvider(ILogMessageHolder holder, LogFormatter formatter)
    {
        _formatter = formatter;
        _processor = new LogMessageProcessor(holder, LoggerQueueFullMode.Wait, 2500);
    }

    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, new Logger(categoryName, _processor, _formatter));
    }

    public void Dispose()
    {
        _processor.Dispose();
    }
}

public static class LoggingBuilderExtension
{
    public static ILoggingBuilder AddObservableLogs(this ILoggingBuilder builder)
    {
        builder.Services.AddSingleton&lt;ILoggerProvider, LoggerProvider&gt;();
        builder.Services.AddSingleton&lt;IMfgLoggerProvider, LoggerProvider&gt;();
        builder.Services.AddTransient&lt;LogFormatter, SimpleLogFormatter&gt;();
        builder.Services.AddSingleton&lt;ILogMessageHolder, LogMessageHolder&gt;();
        return builder;
    }
}
</code></pre>
<ul>
<li>至此，Logger的核心已经完成，接下来是在View中显示Log</li>
</ul>
<h2 id="简单实现logviewer">简单实现LogViewer</h2>
<ol>
<li>创建LogWindow,使用ItemsControl显示LogMessage。<br>
实际上，LogMessage的Formatter，是下文的LogMessageConverter。</li>
</ol>
<pre><code class="language-csharp">public class LogMessageConverter : IValueConverter
{
public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
{
    if (value is not LogMessage message)
    {
        return "";
    }
    return $"{message.Time:yyyy-MM-dd HH:mm:ss,fff} {GetLogLevelString(message.LogLevel)}: {message.Category} [{message.EventId}]\r\n{message.Message}";
}

public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
{
    throw new NotImplementedException();
}

private static string GetLogLevelString(LogLevel logLevel) =&gt; logLevel switch
{
    LogLevel.Trace =&gt; "trce",
    LogLevel.Debug =&gt; "dbug",
    LogLevel.Information =&gt; "info",
    LogLevel.Warning =&gt; "warn",
    LogLevel.Error =&gt; "fail",
    LogLevel.Critical =&gt; "crit",
    _ =&gt; throw new ArgumentOutOfRangeException(nameof(logLevel))
};
}
</code></pre>
<pre><code class="language-xml">&lt;!--省略Window的命名空间和其余属性--&gt;
&lt;ItemsControl ItemsSource="{Binding LogMessages}"&gt;
    &lt;ItemsControl.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            &lt;!--如果想要显示日志等级的颜色，需要其他TextBlock和添加trigger--&gt;
            &lt;TextBlock Text="{Binding ., Converter={StaticResource LogMessageConverter}}"&gt;&lt;/TextBlock&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.ItemTemplate&gt;
&lt;/ItemsControl&gt;
</code></pre>
<ol start="2">
<li>创建LogWindow的DataContext<br>
这里就涉及到ObservableCollections库的知识了，最后绑定到View上的是LogMessages属性。如果想对LogMessages进行过滤，比如选取LogLevel.Information等，使用_viewList的AttachFiliter就好啦。</li>
</ol>
<pre><code class="language-csharp">public class LogWindowViewModel
{
    private readonly ISynchronizedView&lt;LogMessage, LogMessage&gt; _viewList;
    private readonly ILogMessageHolder _logMessageHolder;
      
    public LogWindowViewModel(ILogMessageHolder logMessageHolder)
    {
        _logMessageHolder = logMessageHolder;
        _viewList = logMessageHolder.LogMessages.CreateView(x =&gt; x);
        LogMessages = _viewList.ToNotifyCollectionChanged();
    }

    public INotifyCollectionChangedSynchronizedViewList&lt;LogMessage&gt; LogMessages { get; }
}
</code></pre>
<h2 id="结尾">结尾</h2>
<p>使用ObservableCollections可以非常简单的将LogMessage显示到某个UI上，并且LogMessages的生命周期是跟随应用程序，随时可以打开查看应用程序的日志。由于ObservableCollections是纯C#实现，理论上是可以在Avalonia中使用的。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004166666666666667" data-date-updated="2025-07-21 13:55">2025-07-21 13:49</span>&nbsp;
<a href="https://www.cnblogs.com/echo-sama">Echo_HR910</a>&nbsp;
阅读(<span id="post_view_count">186</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18995636);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18995636', targetLink: 'https://www.cnblogs.com/echo-sama/p/18995636', title: '[WPF]在WPF中使用ObservableCollections显示Microsoft.Extensions.Logging的日志信息' })">举报</a>
</div>
        