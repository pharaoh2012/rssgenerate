
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18822660" title="发布于 2025-04-12 22:14">
    <span role="heading" aria-level="2">【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（6）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1155" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18822660" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18822660" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18822660</a></p>
<h2 id="开题--补题情况">开题 + 补题情况</h2>
<p>今天打完蓝桥杯，还是 ACM 赛制好玩啊~~<br>
这场题相对而言比较简单，也是汲取了上次的教训，做题节奏放慢了，稍微细心了点，打出了历史最佳战绩，虽然还是不小心 WA 了两发。<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202504/3572902-20250412212137749-506782805.png" alt="image" loading="lazy"></p>
<h2 id="1001---烤羊">1001 - 烤羊</h2>
<p>签到题，枚举调料的使用，可以使用二进制枚举，注意选取的不能超过目的值。</p>
<details>
<summary>点击查看代码（赛时代码写得依托）</summary>
<pre><code class="language-cpp">void solve()
{
    i64 k, a, b, c;std::cin &gt;&gt; k &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    if(a == k || b == k || c == k) {
        std::cout &lt;&lt; 0 &lt;&lt; '\n';
        return;
    }

    if(a + b == k || b + c == k || a + c == k) {
        std::cout &lt;&lt; 0 &lt;&lt; '\n';
        return;
    }

    if(a + b + c == k) {
        std::cout &lt;&lt; 0 &lt;&lt; '\n';
        return;
    }

    if(a + b + c &lt; k) {
        std::cout &lt;&lt; k - a - b - c &lt;&lt; '\n';
        return;
    }

    auto get = [&amp;](i64 x) -&gt; i64 {
        if(x &gt; k)return inf64;

        return k - x;
    };

    i64 ans = inf64;
    if(a + b + c &gt; k) {
        ans = std::min(ans, get(a));
        ans = std::min(ans, get(b));
        ans = std::min(ans, get(c));
        ans = std::min(ans, get(a + b));
        ans = std::min(ans, get(a + c));
        ans = std::min(ans, get(b + c));
        ans = std::min(ans, get(a + b + c));

        if(ans == inf64)ans = k;
        std::cout &lt;&lt; ans &lt;&lt; '\n';
        return;
    }
}
</code></pre>
</details>
<h2 id="1003---抹茶">1003 - 抹茶</h2>
<p>连续区间贪心选取，很明显的双指针题。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;i64&gt; a(n + 1), b(n + 1);

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; b[i];
    }

    i64 ans = 0;

    for(int i = 1, j = 0;i &lt;= n;i = j + 1) {
        while(j + 1 &lt;= n &amp;&amp; a[j + 1] + b[j + 1] == a[i] + b[i]) {
            j ++;
        }

        i64 tmp = 0;
        for(int k = i;k &lt;= j;k ++) {
            tmp += a[k] * (j - i + 1);
        }

        ans = std::max(ans, tmp);
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1007---双相">1007 - 双相</h2>
<p>要想最大，肯定是优先选最大的，将两种颜色的分数分别放入两个优先队列，然后模拟选取，直到选不了一人无法移动为止。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;i64&gt; a(n + 1);
    std::string s;

    for(int i = 1;i &lt;= n;i ++)std::cin &gt;&gt; a[i];
    std::cin &gt;&gt; s;
    s = ' ' + s;

    std::priority_queue&lt;i64&gt; r, b;

    for(int i = 1;i &lt;= n;i ++) {
        if(s[i] == 'R') {
            r.push(a[i]);
        } else {
            b.push(a[i]);
        }
    }

    i64 ans = 0;
    int sum = 0;

    while(true) {
        sum ++;
        if(sum &amp; 1) {
            if(!r.size()) {
                break;
            }
            ans += r.top();
            r.pop();
        } else {
            if(!b.size()) {
                break;
            }
            ans += b.top();
            b.pop();
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1008---天使">1008 - 天使</h2>
<p>对于此题，我们可以先将范围缩小，假设只有三个使徒，考虑他们的结合顺序，不难发现：</p>
<p></p><div class="math display">\[a \times b + (a + b) \times c = a \times c + (a + c) \times b = b \times c + (b + c) \times a
\]</div><p></p><p>因此，不管怎么结合，最后的答案都不会变化，结合后的又可以和其他的进行结合，那么，把这个结论推广到 <span class="math inline">\(n\)</span> 个使徒同样成立。<br>
因此不管怎么结合，最后的答案都一样。<br>
所以，我们只需要从左到右结合算出答案，然后用 <span class="math inline">\(\sum_{i = 2}^n C_i^2\)</span> 算出种类数即可。</p>
<details>
<summary>点击查看代码（省略了取模类）</summary>
<pre><code class="language-cpp">Z C(Z n) {
    return n * (n - 1) / 2;
}

void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;i64&gt; a(n + 1);

    for(int i = 1;i &lt;= n;i ++)std::cin &gt;&gt; a[i];

    Z ans = 0;
    Z now = a[1];
    for(int i = 2;i &lt;= n;i ++) {
        ans += now * a[i];
        now += a[i];
    }

    Z sum = 1;
    for(int i = n;i &gt;= 2;i --) {
        sum *= C(i);
    }

    std::cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1002---英逃">1002 - 英逃</h2>
<p>首先需要观察出答案是具有单调性的。<br>
为什么？<br>
假设修改区间 <span class="math inline">\([l, r]\)</span> 是可以达到题目要求的，那么对于 <span class="math inline">\([l - 1, r]\)</span>，可以分析以下两种情况（区间 <span class="math inline">\([l, r + 1]\)</span> 同理）：</p>
<ul>
<li><span class="math inline">\(a_{l - 1} \geq \max_{i = l}^ra_i\)</span>（如下图，黑色为修改前，红色为修改后，下同）：<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202504/3572902-20250412215151514-1778072047.png" alt="image" loading="lazy"><br>
对于区间 <span class="math inline">\([l, r]\)</span>，它们对代价的贡献无变化，仍为 <span class="math inline">\(0\)</span>，但对于左边这个新增的 <span class="math inline">\(a_{l - 1}\)</span>，由于相邻两个数的差值变为了 <span class="math inline">\(0\)</span>，因此对代价的贡献变小了，那么如果修改区间 <span class="math inline">\([l, r]\)</span> 能达到题目目的，修改区间 <span class="math inline">\([l - 1, r]\)</span> 同样能达到题目目的。</li>
<li><span class="math inline">\(a_{l - 1} &lt; \max_{i = l}^ra_i\)</span>，此时继续分两种情况讨论：
<ul>
<li><span class="math inline">\(a_{l - 2} \leq a_{l - 1}\)</span>（如下图）：<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202504/3572902-20250412215605920-1975647930.png" alt="image" loading="lazy"><br>
对于这种情况，我们可以发现，<span class="math inline">\(a_{l - 1}\)</span> 和 <span class="math inline">\(\max_{i = l}^ra_i\)</span> 的差值缩小了 <span class="math inline">\(\max_{i = l}^ra_i - a_{l - 1}\)</span>，<span class="math inline">\(a_{l - 1}\)</span> 和 <span class="math inline">\(a_{l - 2}\)</span> 的差值增大了 <span class="math inline">\(\max_{i = l}^ra_i - a_{l - 1}\)</span>，因此对代价的贡献无变化，那么如果修改区间 <span class="math inline">\([l, r]\)</span> 能达到题目目的，修改区间 <span class="math inline">\([l - 1, r]\)</span> 同样能达到题目目的。</li>
<li><span class="math inline">\(a_{l - 2} &gt; a_{l - 1}\)</span>（如下图）：<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202504/3572902-20250412220026834-1087956234.png" alt="image" loading="lazy"><br>
对于这种情况，我们可以发现，<span class="math inline">\(a_{l - 1}\)</span> 和 <span class="math inline">\(\max_{i = l}^ra_i\)</span> 的差值缩小了 <span class="math inline">\(\max_{i = l}^ra_i - a_{l - 1}\)</span>，<span class="math inline">\(a_{l - 1}\)</span> 和 <span class="math inline">\(a_{l - 2}\)</span> 的差值缩小了 <span class="math inline">\(\max_{i = l}^ra_i - a_{l - 1}\)</span>，因此对代价的贡献缩小了 <span class="math inline">\(2 \times (\max_{i = l}^ra_i - a_{l - 1})\)</span>，那么如果修改区间 <span class="math inline">\([l, r]\)</span> 能达到题目目的，修改区间 <span class="math inline">\([l - 1, r]\)</span> 同样能达到题目目的。</li>
</ul>
</li>
</ul>
<p>因此，答案具有单调性，可以二分。<br>
我们首先记录一下差分的绝对值以及差分的绝对值的前缀和，使用 ST 表来维护区间最值，然后进行二分答案，对每个二分到的区间长度，遍历所有可能的修改区间，更改修改后的代价总和，判断是否可能达到题目要求，在所有可能的答案中取最小即可。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;
    i64 x;
    std::cin &gt;&gt; n &gt;&gt; x;

    std::vector&lt;i64&gt; a(n + 1);
    for(int i = 1;i &lt;= n;i ++)std::cin &gt;&gt; a[i];
    
    std::vector&lt;i64&gt; d(n + 1);
    for(int i = 2;i &lt;= n;i ++) {
        d[i] = abs(a[i] - a[i - 1]);
    }
    
    std::vector&lt;i64&gt; pre(n + 1);
    for(int i = 2;i &lt;= n;i ++) {
        pre[i] = pre[i - 1] + d[i];
    }
    
    if(pre[n] &lt;= x) {
        std::cout &lt;&lt; 0 &lt;&lt; '\n';
        return;
    }
    
    std::vector&lt;std::array&lt;i64, 40&gt;&gt; st(n + 1);
    
    for(int i = 1;i &lt;= n;i ++) {
        st[i][0] = a[i];
    }
    
    int mx = std::__lg(n);
    for(int k = 1;k &lt;= mx;k ++) {
        for(int i = 1;i + (1 &lt;&lt; (k - 1)) &lt;= n;i ++) {
            st[i][k] = std::max(st[i][k - 1], st[i + (1 &lt;&lt; (k - 1))][k - 1]);
        }
    }

    auto getmx = [&amp;](int l, int r) -&gt; i64 {
        int s = std::__lg(r - l + 1);
        return std::max(st[l][s], st[r - (1 &lt;&lt; s) + 1][s]);
    };
    
    auto check = [&amp;](i64 m) -&gt; bool {
        i64 tmp = pre[n];
        for(int i = 1;i &lt;= n - m + 1;i ++) {
            tmp = pre[n];
            tmp -= pre[i + m - 1] - pre[i];
            if(i != 1)tmp -= abs(a[i] - a[i - 1]);
            if(i + m - 1 != n)tmp -= abs(a[i + m] - a[i + m - 1]);

            i64 mx = getmx(i, i + m - 1);
            if(i != 1)tmp += abs(mx - a[i - 1]);
            if(i + m - 1 != n)tmp += abs(a[i + m] - mx);
            
            if(tmp &lt;= x)return true;
        }
        return false;
    };
    
    int l = 0, r = n + 1;
    while(l + 1 &lt; r) {
        int mid = l + r &gt;&gt; 1;
        if(check(mid))r = mid;
        else l = mid;
    }

    std::cout &lt;&lt; r &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1010---章鱼">1010 - 章鱼</h2>
<p>这题是很明显的换根 DP。<br>
首先我们考虑一下，当一个点是一对点的 <span class="math inline">\(LCA\)</span> 时，什么样的点对的 <span class="math inline">\(LCA\)</span> 是它。</p>
<ul>
<li>自己和自己的 <span class="math inline">\(LCA\)</span> 都是自己。</li>
<li>对于这个点，它的子树（不包含父节点那个子树）中任选两个子树，两个子树中各自任选一个点，<span class="math inline">\(LCA\)</span> 是它自己。</li>
<li>对于这个点，从它的子树（不包含父节点那个子树）中任选一个点，和这个点的 <span class="math inline">\(LCA\)</span> 是它自己。</li>
</ul>
<p>那么，思路也就出来了，对于每个结点为 <span class="math inline">\(LCA\)</span> 时，逐个计算，当一个结点作为根时，除了根所在的这棵子树，对其他的子树按上述规则进行计数，对于每一棵子树，无论这棵子树哪个结点作为根，计算得到的答案都是相同的，因为都相当于是把这棵子树变成了父子树，这棵子树的结点都不可能和任何结点的 <span class="math inline">\(LCA\)</span> 是当前结点。<br>
当然，还要考虑自己为根的时候，此时和任何其他结点的 <span class="math inline">\(LCA\)</span> 都是它自己。<br>
换根 DP 足以解决这个问题。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt;&gt; g(n + 1);

    for(int i = 1;i &lt; n;i ++) {
        int u, v;std::cin &gt;&gt; u &gt;&gt; v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    std::vector&lt;int&gt; sz(n + 1);

    auto dfs = [&amp;](auto &amp;&amp;self, int st, int pre) -&gt; void {
        sz[st] = 1;

        for(auto &amp;i : g[st]) {
            if(i == pre)continue;
            self(self, i, st);
            sz[st] += sz[i];
        }
    };

    dfs(dfs, 1, 0);
    std::vector&lt;i64&gt; ans(n + 1);

    auto C = [](i64 n) -&gt; i64 {
        return n * (n - 1) / 2;
    };

    auto dfs1 = [&amp;](auto &amp;&amp;self, int st, int pre) -&gt; void {
        int n = g[st].size();
        std::vector&lt;i64&gt; szpre(n + 1), Cpre(n + 1);
        for(int i = 1;i &lt;= n;i ++) {
            if(g[st][i - 1] == pre)szpre[i] = szpre[i - 1] + sz[1] - sz[st];
            else szpre[i] = szpre[i - 1] + sz[g[st][i - 1]];

            if(g[st][i - 1] == pre)Cpre[i] = Cpre[i - 1] + C(sz[1] - sz[st]);
            else Cpre[i] = Cpre[i - 1] + C(sz[g[st][i - 1]]);
        }

        for(int i = 1;i &lt;= n;i ++) {
            ans[st] += (szpre[i] - szpre[i - 1]) * (C(szpre[i - 1] + szpre[n] - szpre[i]) - (Cpre[i - 1] + Cpre[n] - Cpre[i]));
            ans[st] += (szpre[i] - szpre[i - 1]) * (szpre[i - 1] + szpre[n] - szpre[i]);
        }

        ans[st] += sz[1] - 1;
        ans[st] += C(szpre[n]) - Cpre[n];

        for(auto &amp;i : g[st]) {
            if(i == pre)continue;
            self(self, i, st);
        }
    };

    dfs1(dfs1, 1, 0);

    for(int i = 1;i &lt;= n;i ++) {
        ans[i] += sz[1];
        std::cout &lt;&lt; ans[i] &lt;&lt; " \n"[i == n];
    }
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0922331891597221" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-13 00:07">2025-04-12 22:14</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">195</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18822660);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18822660', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18822660', title: '【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（6）' })">举报</a>
</div>
        