
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18764866" title="发布于 2025-03-12 14:55">
    <span role="heading" aria-level="2">重生之数据结构与算法----常见排序算法(一)</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>排序算法有三个重要的指标：</p>
<ol>
<li>时间/空间复杂度<br>
在前面的文章中，虽然经常强调空间换时间能解决大多数问题。但如果时间与空间都比较小，自然是更好的选择。</li>
<li>排序稳定性<br>
相同的元素，如果排序之后<code>相对位置没有发生改变</code>，那可以被称为稳定排序，否则就是不稳定排序。<br>
比如说两个相同的数，排序前它们的顺序是 a 在前，b 在后，排序后如果 a 仍然在 b 前面，那么这个排序算法就是稳定的</li>
</ol>
<pre><code>   Date    OrderId
2025-03-01  1
2025-03-01  2
2025-03-02  1
2025-03-02  1
2025-03-03  1
2025-03-03  2
//根据OrderId降序排序后，依旧根据Data有序排序，这被称为稳定排序。
2025-03-01  2
2025-03-01  1
2025-03-02  2
2025-03-02  1
2025-03-03  2
2025-03-03  1
...
</code></pre>
<ol start="3">
<li>是否原地排序<br>
是否需要额外的空间来辅助排序的过程，比如temp等。对于大数据量的排序来说，原地排序肯定是更优解。</li>
</ol>
<h1 id="万物的起源选择排序selectionsort">万物的起源：选择排序(SelectionSort)</h1>
<p>选择排序是最简单的算法，属于<code>最笨的办法</code>。且不是稳定排序，所以其它排序算法都是基于选择排序的<code>优化</code>。</p>
<pre><code>    public class SelectionSort
    {
        public static void Run()
        {
            var arr = new int[] { 5, 7, 1, 8, 6,2,-1,100,15 ,-2};
            new SelectionSort().Sort(arr);

            foreach (var item in arr)
            {
                Console.WriteLine(item);
            }
        }

        /// &lt;summary&gt;
        /// 时间复杂度O(n^2)
        /// 空间复杂度O(1)
        /// &lt;/summary&gt;
        /// &lt;param name="arr"&gt;&lt;/param&gt;
        public void Sort(int[] arr)
        {
            //从一个位置开始遍历,找到最小的，然后再找第二小，第三小。
            for (int i = 0; i &lt; arr.Length; i++)
            {
                for (int j = i+1; j&lt; arr.Length; j++)
                {
                    if (arr[i] &gt; arr[j])
                    {
                        //swap
                        var temp = arr[i];
                        arr[i] = arr[j];
                        arr[j] = temp;
                    }
                        
                }
            }
        }
    }
</code></pre>
<h1 id="进一步优化冒泡排序bubblesort">进一步优化：冒泡排序(BubbleSort)</h1>
<p>上面的选择排序有很多问题：</p>
<ol>
<li>排序不稳定<br>
每次都是拿最小元素与当前元素对比，这样可能会改变元素位置</li>
<li>时间复杂度高<br>
由于嵌套两层for循环，无法突破O(n^2)的限制</li>
<li>有序初素不敏感<br>
如果初始元素本身就是有序，复杂度依旧是O(n^2)，并没有提前终止。</li>
</ol>
<h2 id="优化第一步让排序变稳定">优化第一步，让排序变稳定</h2>
<pre><code>var arr = new int[] {2,2,2,1,3};

[2, (另一个2), (再另外一个2), 1, 3]

//这里可以看到，如果在选择排序中，会发生什么情况呢？
[1, (另一个2), (再另外一个2), 2, 3]
当交换后，2的位置发生了变化。相对之前的位置，它从 (另一个2)之前移动到了(再另外一个2)后。这就破坏了相对位置。
根据定义，同样的元素不应该产生移动，所以我们的代码优化一下，变成这个样子

        public void Sort2(int[] arr)
        {
            for (int i = 0; i &lt; arr.Length; i++)
            {
                for (int j = i + 1; j &lt; arr.Length ; j++)
                {
                    if (arr[i] &gt; arr[j])
                    {
                        var temp = arr[i];
                        arr[i] = arr[j];


                        //主要在这一步，不换位置。而是将元素整体往后移
                        //arr[j] = temp;

                        for (int k = j; k &gt;i+1 ; k--)
                        {
                            arr[k] = arr[k - 1];
                        }
                        arr[i + 1] = temp;
                    }
                }
            }
        }
</code></pre>
<blockquote>
<p>这样的话，相同元素的相对位置是没有变化的。保证了相对稳定性！<br>
但又出现了一个新的问题，引入的一个新的for循环，复杂度又退化到了O(n^3)。</p>
</blockquote>
<h2 id="优化第二步复杂度重回on2">优化第二步，复杂度重回O(n^2)</h2>
<p>观察上述代码，其核心主要在做两件事。</p>
<ol>
<li>找到当前循环最小的那个值</li>
<li>填补最小值的空缺，保持排序相对稳定</li>
</ol>
<p>思考一个问题:有没有一种可能将两步合二为一？找到最小的值的时候<code>交换位置的同时又不影响排序稳定</code>。</p>
<pre><code>        public void Sort3(int[] arr)
        {
            for (int i = 0; i &lt; arr.Length; i++)
            {
                for (int j = 0 ; j &lt; arr.Length-1; j++)
                {
                    //当前元素与右边对比大小，并顺带移动位置，这样并不会破坏同元素的相对位置
                    //同元素，在左边的始终在左边，不可能移动到右边。
                    if (arr[j] &gt; arr[j+1])
                    {
                        var temp = arr[j + 1];
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }

                }
            }
        }
</code></pre>
<blockquote>
<p>经过这样一优化，复杂度又升级为O(N^2)，同时又具备了排序稳定性。<br>
这就是冒泡排序法，只与相邻元素对比，这样就不会破坏排序稳定性。</p>
</blockquote>
<h2 id="优化第三步有序提前终止">优化第三步，有序提前终止</h2>
<p>上面的排序算法中，有可能循环几轮后，元素就已经完成了排序，但程序并不知道，还是傻乎乎的完成整个循环。<br>
因此，我们需要当排序完成后，提前终止循环。</p>
<pre><code>        public void Sort4(int[] arr)
        {
            
            for(int i = 0;i &lt; arr.Length; i++)
            {
                int notSwapNum = 1;
                for (int j = 0; j &lt; arr.Length-1; j++)
                {
                    if (arr[j] &gt; arr[j + 1])
                    {
                        (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);
                    }
                    else
                    {
                        notSwapNum++;
                    }
                }

                //说明元素已经是全部有序的，提前终止循环
                if (notSwapNum == arr.Length)
                {
                    break;
                }
            }
        }
</code></pre>
<p>这就是完整版的冒泡排序，针对选择排序，我们优化了<code>排序稳定性</code>以及<code>在数据有序时提前退出</code>。唯一遗憾的是时间复杂度并没有降低。</p>
<h1 id="倒序对比插入排序insertionsort">倒序对比：插入排序(InsertionSort)</h1>
<p>在冒泡排序中，虽然我们能在数组有序时提前提出。但面对如下场景</p>
<pre><code>var arr = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 };
</code></pre>
<p>冒泡排序还是会完成整个循环，这明显还有很大的优化空间。接下来我们再思考，如何在大部分都有序的情况下完成快速排序。</p>
<pre><code>        public void Sort(int[] arr)
        {
            for (int i = 0; i &lt; arr.Length; i++)
            {
                for (int j = i ; j &gt; 0; j--)
                {
                    //与左边已排好序的元素进行对比，因为有序，所以插入很快速。
                    //有点类似打扑克，把抓到的牌按序排列
                    if (arr[j] &lt; arr[j - 1])
                    {
                        //swap
                        (arr[j], arr[j - 1]) = (arr[j - 1], arr[j]);
                    }
                    else
                    {
                        break;
                    }
                }

            }
        }
</code></pre>
<p>与冒泡排序相比，插入排序在面对<code>初始数据有序程度高</code>时，时间复杂度会降低不少，直逼O(n)，但面对完全无序的情况，时间复杂度依旧是O(n^2)。<br>
但总体来说，插入排序的<code>综合性能要高于</code>冒泡排序。</p>
<h1 id="突破on2希尔排序shellsort">突破O(N^2):希尔排序(ShellSort)</h1>
<p>在上面的插入排序中，对数组初始有序度要求很高。所以我们优化的重点就是降低时间复杂度，我们可以通过预处理数据的局部数据，从而突破O(N^2).</p>
<p>希尔排序（Shell Sort），也称为缩小增量排序，是插入排序的一种改进版本。它通过将原始数据分成多个子序列来改善插入排序的性能，使得元素能够更快地移动到它们大致所在的位置，最终完成整个排序过程。</p>
<blockquote>
<p>简单来说就是分而治之思想</p>
</blockquote>
<pre><code>        public void Sort(int[] arr)
        {
            
            var h = 1;
            //根据数组长度确定h高度，也就是分多少组
            while (h &lt; arr.Length / 3)
            {
                h = h * 3 + 1;
            }

            while (h &gt;= 1)
            {
                //初始化为h,从h开始对比
                for (var i = h; i &lt; arr.Length; i++)
                {
                    for (var j = i; j &gt;= h; j = j - h)
                    {
                        //因为不再是对比相邻元素，所以排序不稳定
                        if (arr[j] &lt; arr[j - h])
                        {
                            (arr[j], arr[j - h]) = (arr[j - h], arr[j]);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                //完成有序数组分组后，h高度降低
                h = h / 3;

            }
        }
</code></pre>
<blockquote>
<p>不过由于h&gt;1，所以不是对比相邻元素，因此排序失去了稳定性。终究有所取舍</p>
</blockquote>
<h2 id="如何证明复杂度突破了on2">如何证明复杂度突破了O(N^2)？</h2>
<p>从代码伤看，循环也一个都没少啊。而且还多了一个算高度的过程，这真的降低了时间复杂度吗？<br>
我也不好解释，使用LeetCode作为佐证吧，前面几个算法都会超时，而希尔排序能成功。<br>
<a href="https://leetcode.cn/problems/sort-an-array/submissions/609504025/" target="_blank" rel="noopener nofollow">https://leetcode.cn/problems/sort-an-array/submissions/609504025/</a></p>
<table>
<thead>
<tr>
<th>插入排序</th>
<th>希尔排序</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250312145316779-297619713.png" alt="image" loading="lazy"></td>
<td><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250312145512721-615087403.png" alt="image" loading="lazy"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.8336610752673611" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-12 14:56">2025-03-12 14:55</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">96</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18764866" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18764866);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18764866', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18764866', title: '重生之数据结构与算法----常见排序算法(一)' })">举报</a>

		</p>
	