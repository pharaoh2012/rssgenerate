
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18995042" title="发布于 2025-07-21 07:23">
    <span role="heading" aria-level="2">Docker 磁盘占用分析和清理方法</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-21 07:23">2025-07-21 07:23</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">91</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18995042);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18995042', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18995042', title: 'Docker 磁盘占用分析和清理方法' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本地或测试环境使用 Docker 时，常出现 Docker 占用磁盘空间大，导致系统磁盘资源不足等问题。基于此，总结了 Docker 磁盘占用分析及清理方法。</p>
<h2 id="一分析方法">一、分析方法</h2>
<h3 id="1-使用-docker-system-分析占用整体分布">1. 使用 docker system 分析占用整体分布</h3>
<pre><code class="language-bash">[root@linux7 data]# docker system df 
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              181                 81                  182.2GB             131.9GB (72%)
Containers          349                 23                  565GB               156.7GB (27%)
Local Volumes       91                  37                  4.706GB             2.67MB (0%)
Build Cache         11                  0                   199.7MB             199.7MB

[root@linux7 data]# docker system df -v  # -v 输出分布明细
</code></pre>
<p>（1）TYPE：表示 Docker 资源类型，包括 Images（镜像文件）、Containers（容器）、Local Volumes（本地数据卷）和 Build Cache（构建缓存）。</p>
<p>（2）TOTAL：表示该类型资源的总数量。</p>
<p>（3）ACTIVE：表示当前正在使用的资源数量。</p>
<p>（4）SIZE：表示该类型资源占用的磁盘空间总量。</p>
<p>（5）RECLAIMABLE：表示未占用可以回收的磁盘空间大小及百分比。</p>
<h3 id="2-分析各类资源具体占用">2. 分析各类资源具体占用</h3>
<p>（1）查看镜像占用并其排序</p>
<pre><code class="language-bash">[root@linux7 data]# docker images --format "{{.Repository}}:{{.Tag}}\t{{.Size}}" | sort -k 2 -h -r
</code></pre>
<p>（2）查看容器占用并其排序</p>
<pre><code class="language-bash">[root@linux7 data]# docker ps -a --format "{{.ID}}\t{{.Names}}\t{{.Size}}" | sort -k 3 -h -r 
</code></pre>
<p>（3）查看卷占用</p>
<pre><code class="language-bash">[root@linux7 data]# docker volume ls # 查看卷占用

[root@linux7 data]# docker volume inspect &lt;VOLUME_NAME&gt;  # 查看具体卷详情

[root@linux7 data]# du -sh &lt;MOUNT_POINT&gt; #查看卷真实占用磁盘大小
</code></pre>
<h2 id="二清理方法">二、清理方法</h2>
<h3 id="1-清理未运行的容器">1. 清理未运行的容器</h3>
<p>(1) 列出所有容器</p>
<pre><code class="language-bash">[root@linux7 data]# docker ps
CONTAINER ID   IMAGE          COMMAND       STATUS      NAMES
a1b2c3d4e5f6   nginx:latest   "nginx -g"    Exited      my-nginx

[root@linux7 data]# docker ps -a # -a 输出所有容器，含已停止
</code></pre>
<p>(2) 清理指定容器</p>
<pre><code class="language-bash">[root@linux7 data]# docker rm &lt;CONTAINER_ID&gt;  # 清理已停止的容器

[root@linux7 data]# docker rm -f &lt;CONTAINER_ID&gt;  # 强制清理（运行中的容器也会被停止并清理）
</code></pre>
<p>(3) 清理所有已停止的容器</p>
<pre><code class="language-bash">[root@linux7 data]#  docker container prune # 清理所有处于停止状态的容器

[root@linux7 data]#  docker container prune -f # 强制清理所有处于停止状态的容器，跳过确认

[root@linux7 data]#  docker container prune --filter "until=24h" # 仅清理 24 小时前停止的容器
</code></pre>
<h3 id="2-清理未使用的镜像">2. 清理未使用的镜像</h3>
<p>(1) 列出所有镜像</p>
<pre><code class="language-bash">[root@linux7 data]# docker images
REPOSITORY          TAG       IMAGE ID       CREATED        SIZE
nginx               latest    abc123456      2 weeks ago    133MB
ubuntu              20.04     def789012      1 month ago    72.8MB
</code></pre>
<p>(2) 清理指定镜像</p>
<pre><code class="language-bash">[root@linux7 data]# docker rmi &lt;IMAGE_ID&gt;  # 按 ID 清理

[root@linux7 data]# docker rmi -f &lt;IMAGE_ID&gt; # 强制清理（即使被容器引用）

[root@linux7 data]# docker rmi nginx:latest  # 按名称清理
</code></pre>
<p>(3) 清理所有未使用的镜像</p>
<p>命令格式：<code>docker image prune [OPTIONS]</code>，默认情况下会清理所有未被容器引用的悬空镜像（dangling images）。</p>
<p>常用选项：</p>
<p><code>-a, --all</code>：清理所有未被使用的镜像，含悬空镜像。</p>
<p><code>-f, --force</code>：不提示确认，直接清理。</p>
<p><code>--filter</code>：支持条件过滤需清理的镜像。</p>
<p><code>--dry-run</code>：仅显示将要清理的镜像，不实际执行清理。</p>
<p>使用示例：</p>
<pre><code class="language-bash">[root@linux7 data]# docker image prune # 清理悬空镜像

[root@linux7 data]# docker image prune -a # 清理所有未被使用的镜像，含悬空镜像

[root@linux7 data]# docker image prune -af # 强制清理不提示确认

[root@linux7 data]# docker image prune --filter "until=24h" # 使用过滤器清理

[root@linux7 data]# docker image prune --dry-run # 仅显示将要清理的镜像，不实际执行清理，清理操作不可逆，【建议】先使用`--dry-run`查看将要清理的镜像
</code></pre>
<h3 id="3-清理未使用的网络">3. 清理未使用的网络</h3>
<p>(1) 列出所有网络</p>
<pre><code class="language-bash">[root@linux7 data]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
9e14a4176c29        bridge              bridge              local
65b36b928672        host                host                local
99c1c095900c        none                null                local

[root@linux7 data]# docker network inspect host # 查看
</code></pre>
<p>(2) 清理指定网络</p>
<pre><code class="language-bash">[root@linux7 data]# docker network rm &lt;NETWORK_ID | NAME&gt; &lt;NETWORK_ID | NAME&gt;  # 清理已停止的网络
</code></pre>
<p>(3) 清理所有已停止的网络</p>
<pre><code class="language-bash">[root@linux7 data]# docker network prune
</code></pre>
<h3 id="4-清理-docker-所有未使用的资源">4. 清理 Docker 所有未使用的资源</h3>
<p>docker system prune 是 Docker 提供的系统级清理命令，主要用于清理不再使用的 Docker 对象（悬空资源）。</p>
<p><strong>清理范围：</strong></p>
<p>（1）停止的容器</p>
<p>（2）未被任何容器引用的网络</p>
<p>（3）悬空的镜像（未被标记且未被任何容器引用的镜像层）</p>
<p>（4）悬空的构建缓存</p>
<p><strong>参数详解：</strong></p>
<p>（1）--all / -a：清理所有未使用的镜像（而不仅仅是悬空镜像）</p>
<p>（2）--force / -f：跳过确认提示直接执行清理</p>
<p>（3）--volumes：清理未被容器使用的卷，务必谨慎</p>
<p>（4）--filter：按条件过滤要删除的对象</p>
<p><strong>示例：</strong></p>
<pre><code class="language-bash">[root@linux7 data]# docker system prune # 标准清理

[root@linux7 data]# docker system prune -a -f # 强制清理所有未使用资源

[root@linux7 data]# docker system prune --volumes # 清理未被容器使用的卷，务必谨慎

[root@linux7 data]# docker system prune --filter "until=48h" # 清理超过 48 小时未被使用的资源。
</code></pre>
<h2 id="三相关知识点">三、相关知识点</h2>
<h3 id="1-悬空镜像dangling-images">1. 悬空镜像（Dangling Images）</h3>
<p>（1）定义：指没有标签且没有被任何容器引用的镜像层。</p>
<p>（2）特征：通常显示为<code>&lt;none&gt;:&lt;none&gt;</code>的镜像。</p>
<p>（3）查看方法：</p>
<pre><code class="language-bash">[root@linux7 data]# docker images -f "dangling=true"
</code></pre>
<p>（4）产生场景：</p>
<p>多阶段构建时的中间镜像：当使用 Dockerfile 进行多阶段构建时，每个<code>FROM</code>语句都会产生一个中间镜像。构建完成后，这些中间镜像会变成悬空状态。</p>
<p>构建失败残留：构建过程中如果失败，可能会留下未完成的镜像层，这些也会成为悬空镜像。</p>
<p>重新构建同名镜像：当构建一个与现有镜像同名但不同内容的新镜像时，旧镜像会失去标签变成悬空镜像。</p>
<p>镜像标签变更：使用<code>docker tag</code>命令修改镜像标签后，原镜像如果没有其他标签引用，就会变成悬空镜像。</p>
<p>使用<code>docker commit</code>创建新镜像：基于容器创建新镜像后，原基础镜像如果没有其他引用，可能变成悬空状态。</p>
<h3 id="2-未使用镜像unused-images">2. 未使用镜像（Unused Images）</h3>
<p>（1）定义：指当前没有被任何容器使用的镜像（无论是否有标签），所以所有悬空镜像都属于未使用镜像。</p>
<p>（2）特征：可能有明确的镜像标签；但没有任何运行或停止的容器基于该镜像。</p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18995042"></vc:categories-tags>
    </ul>
