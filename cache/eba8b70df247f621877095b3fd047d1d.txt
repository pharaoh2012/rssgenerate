
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zpcdbky/p/18773538" title="发布于 2025-03-28 08:38">
    <span role="heading" aria-level="2">虚函数表里有什么？（一）——从一个普通类开始</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本系列文章，旨在探究C++虚函数表中除函数地址以外的条目，以及这些条目的设计意图和作用，并介绍与此相关的C++类对象内存布局，最后将两者用图解的形式结合起来，给读者带来全局性的视角。让我们从一个简单的类出发，开启我们的探索之旅。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>前言</h1>
<p>本系列文章，旨在探究C++虚函数表中除函数地址以外的条目，以及这些条目的设计意图和作用，并介绍与此相关的C++类对象内存布局，最后将两者用图解的形式结合起来，给读者带来全局性的视角。</p>
<p>这是本系列的第一篇文章，让我们从一个简单的类开始。</p>
<p>本系列文章的实验环境如下：</p>
<ul>
<li>OS:&nbsp;Ubuntu 22.04.1 LTS x86_64 (virtual machine)</li>
<li>g++: 11.4.0</li>
<li>gdb: 12.1</li>
</ul>
<h1>对象与虚函数表内存布局</h1>
<p>我们的探究基于下面这段代码。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> #include &lt;stdlib.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 2</span> #include &lt;stdint.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 3</span> #include &lt;<span style="color: rgba(0, 0, 255, 1)">string</span>.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 4</span> 
<span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> <span style="color: rgba(0, 0, 0, 1)">    Base(uint32_t len)
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> <span style="color: rgba(0, 0, 0, 1)">        : len_(len)
</span><span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">11</span>         buf_ = (<span style="color: rgba(0, 0, 255, 1)">char</span> *)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(len_ * <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">char</span><span style="color: rgba(0, 0, 0, 1)">));
</span><span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">13</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base()
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">15</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (nullptr !=<span style="color: rgba(0, 0, 0, 1)"> buf_)
</span><span style="color: rgba(0, 128, 128, 1)">16</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">17</span>             <span style="color: rgba(0, 0, 255, 1)">free</span><span style="color: rgba(0, 0, 0, 1)">(buf_);
</span><span style="color: rgba(0, 128, 128, 1)">18</span>             buf_ =<span style="color: rgba(0, 0, 0, 1)"> nullptr;
</span><span style="color: rgba(0, 128, 128, 1)">19</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">20</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">21</span>     <span style="color: rgba(0, 0, 255, 1)">void</span> set_buf(<span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">str)
</span><span style="color: rgba(0, 128, 128, 1)">22</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">23</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (nullptr != str &amp;&amp; nullptr != buf_ &amp;&amp; len_ &gt; <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">24</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">25</span> <span style="color: rgba(0, 0, 0, 1)">            strncpy(buf_, str, len_);
</span><span style="color: rgba(0, 128, 128, 1)">26</span>             buf_[len_ - <span style="color: rgba(128, 0, 128, 1)">1</span>] = <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\0</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">27</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">28</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">29</span> 
<span style="color: rgba(0, 128, 128, 1)">30</span> <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">31</span> <span style="color: rgba(0, 0, 0, 1)">    uint32_t len_;
</span><span style="color: rgba(0, 128, 128, 1)">32</span>     <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">buf_;
</span><span style="color: rgba(0, 128, 128, 1)">33</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)">34</span> 
<span style="color: rgba(0, 128, 128, 1)">35</span> <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">argv[])
</span><span style="color: rgba(0, 128, 128, 1)">36</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">37</span>     Base <span style="color: rgba(0, 0, 255, 1)">base</span>(<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">38</span>     <span style="color: rgba(0, 0, 255, 1)">base</span>.set_buf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">hello</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">39</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">40</span> }</pre>
</div>
<p>通过<a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCDSAA6oCoRODB7evnoJSY4CQSHhLFEx0naYDilCBEzEBGk%2Bfly2mPY5DJXVBHlhkdGxtlU1dRmNCgOdwd2FvZIAlLaoXsTI7BzmAMzByN5YANQma26j6LR4EQB0CPvYJhoAguub25h7B0fBBBdXN/dmGwxbXl2%2B0OBGIwWAnzW1zu3y2TAUCh2FnhmG%2BJgA7FY7nEvBETsgQN8dsSkSiIF53mszAB9Ag7egMGZEkkskD0xjUiAMpl3FkYrG3FksiJeKjUl4AER2EGQCGqOwAVDMWGJaKhkFyOYqdkkAF6YVBUGVy4gzJlrAV89ES5nEgBueBqXjEOwAfsilBAeYKSfzbUK8FRpQwvLRaHFQTswGB9lKRWLvULfZj/UniVRiJhMBB49TzZa08LReLYzsQ2GI8R9gWkxibbzk/WffbUHh0DrMARqfGZQJRjtZfKFaNTf6/Q2k4Hg6Hw5Ho6WR3szAA2czLsszytRmNrOPFperlfshglqE7DSJtPj5uFnWg/5xACeOeLpDvZGPeerqbTuZMAFYLAZcUAFodi4ACpVLMBVn/NwNBg78JyFOsx2tNFsTBO0mAIdh/QpQQqVpT8kJvQdiEVP8LTRdDqJhO53h2FVgggRjqmAZA33IxV2LtACrH/CVvWvFkPWeCIyQADnzf0JKUM4lC7HtzDMBBmjVFSZOQzMCEWBhz1IusODmWhOH/Xg/A4LRSFQTg3GsawdQWJZnnWHhSAITRjLmABrEB/w0fROEkCyvJszheAUEBAs8qzjNIOBYBgRAUFQFg4joaJyEoNB0symJgCkMw%2BDoXDiCinMwoiYJqkfTh3Oq5hiEfAB5CJtDKWL3NythBBahhaDquLSCwEVgDcVUou4XgsBVIxxGG/BM3KO1MCm6zMFUMovFwsL3maMKTgiYhao8LAwtBPAWHq3hVuICJEkwCVMDm4ATiMLy5ioAxgAUAA1PBMAAdxauJGBumRBBEMR2CkSH5CUNQwt0RoDA%2B0xLGsfRTiiyA5lQCMUimkDgB2ECWrMMmqAYVAQOCd7nhAo5YwxqxLDMDQyYAdVVXhUDusEsFxr0mhaFIXAYdxPHqfxJa6AoikyRJkgEIYGlILIVYYeWehiEZmk6ioxjVvRSnKAR2hqHWpj1/oOhNkYxmtxWuDmBRnOWCQTLM0LhtsjgdlUSTlxA5dJB2DjkHAyQzkpiBcEIEglzWV3eFirQzVIPyAqCjgQtIa70Rj/8uHRZdJMkSTJKL/8AE5JMaSzrP9yLoo8z6EuSiAkAWAgcQIbLezy%2BhiFCVgViDkOw4HNHSdLs4NDOdzMHwIhBb0fgodEcQ4c3hGVHUYaUdIIGTriG7vY4czSCbvnOBanb%2B52Q1A%2BD0Pw8j6PY%2BlDxh%2BiZPU7tzipnNSTAsAxBFqZPOvBrpmH/GcSuvwuAly4HAyQGguC1xvmFFutg27p28lnfygUoFrF9s3CKQCM6XzMOQu%2BHA06fTmHdJIzhJBAA%3D" target="_blank" rel="noopener nofollow">Compiler Explorer</a>，可以看到生成的虚函数表的布局以及typeinfo相关内容（这个后文会详细介绍）：</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250315232814951-748632018.png" alt="" loading="lazy"></p>
<p>接下来，让我们通过gdb调试更深入地探究虚函数表和对象内存布局。</p>
<p>首先，执行下列命令：</p>
<div class="cnblogs_code">
<pre>g++ -g -O2 -fno-inline -std=c++20 -Wall main.<span style="color: rgba(0, 0, 255, 1)">cpp</span> -o main  # 编译代码，假设示例代码命名为main.<span style="color: rgba(0, 0, 255, 1)">cpp</span><span style="color: rgba(0, 0, 0, 1)">
gdb main  # gdb调试可执行文件，此后进入gdb
b </span><span style="color: rgba(128, 0, 128, 1)">38  </span># 在38行处打断点<br>r # run</pre>
</div>
<p>接下来，打印对象和虚函数表的内存布局</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250315235654187-1236577091.png" alt="" loading="lazy"></p>
<p>&nbsp;<span class="cnblogs_code">x</span>&nbsp;命令显示的符号是经过Name Mangling的，可以使用&nbsp;<span class="cnblogs_code">c++filt</span>&nbsp;命令将其还原。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250316011159789-413118502.png" alt="" loading="lazy"></p>
<p>整体的内存布局如下。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250318213959119-1712282989.png" alt="" loading="lazy"></p>
<p>&nbsp;可以看出：</p>
<ol>
<li>&nbsp;<span class="cnblogs_code">Base</span>&nbsp;对象的虚表指针并没有指向vtable的起始位置，而是指向了偏移了16个字节的位置，即第一个虚函数地址的位置。</li>
<li>为了内存对齐，&nbsp;&nbsp;<span class="cnblogs_code">Base</span>&nbsp;对象中插入了4个字节的padding，它的值无关紧要。</li>
</ol>
<p>到这里， 可能有些读者会有疑问，比如，什么是top_offset？为什么会有两个析构函数？别急，往下看。</p>
<h1>深入探索</h1>
<h2>vtable在哪个segment？</h2>
<p>我们知道，Linux下可执行文件采用ELF (Executable and Linkable Format) 格式，那么，vtable存放在哪个段 (segment)呢？</p>
<p>要回答这个问题，我们可以在gdb调试中使用&nbsp;<span class="cnblogs_code">info files</span>&nbsp;命令打印可执行程序的段信息，然后看看vtable的首地址&nbsp;<span class="cnblogs_code">0x555555557d68</span>&nbsp;在哪个段。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250316210219434-14143526.png" alt="" loading="lazy"></p>
<p>可以看到，是存储在.data.rel.ro段。这是一个什么段呢？.data表示数据段，.rel表示重定位 (relocation)，.ro表示只读 (readonly)。.data和.ro都好理解，毕竟vtable显然应该是一种只读的数据，在程序运行期间不应该被修改。那为什么需要重定位呢？</p>
<p>考虑下面这段代码。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> base.h</span>
<span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span>   <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> is_odd(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> n);
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span>   <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base() {}
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> 
<span style="color: rgba(0, 128, 128, 1)"> 9</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> base.cpp</span>
<span style="color: rgba(0, 128, 128, 1)">10</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">base.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">11</span> 
<span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> Base::is_odd(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> n)
</span><span style="color: rgba(0, 128, 128, 1)">13</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">14</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span> == n % <span style="color: rgba(128, 0, 128, 1)">2</span> ? <span style="color: rgba(0, 0, 255, 1)">false</span> : <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">15</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">16</span> 
<span style="color: rgba(0, 128, 128, 1)">17</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> derived.h</span>
<span style="color: rgba(0, 128, 128, 1)">18</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">base.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">19</span> 
<span style="color: rgba(0, 128, 128, 1)">20</span> <span style="color: rgba(0, 0, 255, 1)">class</span> Derived : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)">21</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">22</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">23</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> is_even(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> n);
</span><span style="color: rgba(0, 128, 128, 1)">24</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Derived() {}
</span><span style="color: rgba(0, 128, 128, 1)">25</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)">26</span> 
<span style="color: rgba(0, 128, 128, 1)">27</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> derived.cpp</span>
<span style="color: rgba(0, 128, 128, 1)">28</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">derived.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">29</span> 
<span style="color: rgba(0, 128, 128, 1)">30</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> Derived::is_even(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> n)
</span><span style="color: rgba(0, 128, 128, 1)">31</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">32</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> !<span style="color: rgba(0, 0, 0, 1)">is_odd(n);
</span><span style="color: rgba(0, 128, 128, 1)">33</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">34</span> 
<span style="color: rgba(0, 128, 128, 1)">35</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> main.cpp</span>
<span style="color: rgba(0, 128, 128, 1)">36</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">derived.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">37</span> #include &lt;iostream&gt;
<span style="color: rgba(0, 128, 128, 1)">38</span> 
<span style="color: rgba(0, 128, 128, 1)">39</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main()
</span><span style="color: rgba(0, 128, 128, 1)">40</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">41</span>     Derived *p = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Derived;
</span><span style="color: rgba(0, 128, 128, 1)">42</span>     std::cout &lt;&lt; p-&gt;is_even(<span style="color: rgba(128, 0, 128, 1)">10</span>) &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">43</span>     <span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p;
</span><span style="color: rgba(0, 128, 128, 1)">44</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">45</span> }</pre>
</div>
<p>对于&nbsp;<span class="cnblogs_code">Derived</span>&nbsp;类对象，其vtable中指向&nbsp;<span class="cnblogs_code">is_odd</span>&nbsp;函数的指针，其实就是指向&nbsp;<span class="cnblogs_code">Base::is_odd</span>&nbsp;，而在编译derived.cpp时，编译器是不知道这个地址的，因为&nbsp;<span class="cnblogs_code">Base::is_odd</span>&nbsp;定义在base.cpp，是另一个编译单元。因此，只有在链接时，&nbsp;<span class="cnblogs_code">Derived</span>&nbsp;类对象的vtable中，才能填入正确的地址，这就是所谓的链接时重定位（还有一种加载时重定位，如加载.so或者.ddl，这里不再详述）。</p>
<p>vtable这种数据，它具有只读属性，但编译时又不能确定，只能在链接时重定位，因此它被放入了.data.rel.ro段中。</p>
<h2>什么是top_offset?</h2>
<p>在没有虚拟继承的情况下（正如本文中的例子），vtable的起始8个字节中会保存一个偏移量，通常被称为top_offset。它记录了基类子对象首地址到最派生类对象（也称为完整对象，就是继承体系中辈分最小的那个对象）首地址的偏移量。它的本质作用就是通过基类子对象找到完整对象，具体地，通常在以下场景中使用。</p>
<ul>
<li>调用虚函数时调整&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针。</li>
<li>通过&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;进行向下类型转换。</li>
<li>在异常处理中需要定位完整对象。</li>
</ul>
<p>需要注意的是，这里的基类子对象必须是多态对象（<a href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects" target="_blank" rel="noopener nofollow">polymorphic objects</a>），即声明或继承了至少一个虚拟函数的对象。如果一个基类不是多态对象，那么在派生类的虚函数表中，就不会有对应的top_offset条目，因为非多态对象的相关信息在编译时都确定了，不存在运行时多态，用不到top_offset。另外，一个vtable里可能有多个top_offset条目，这出现在多重继承中。</p>
<p>在本文的例子中，由于只有一个对象，“基类子对象”就是它本身，因此，偏移量是0。</p>
<p>读者可能对本小节的内容感到疑惑，没有关系，这里只需有个笼统的印象，等后续文章讲到类的继承体系时，我们会继续探讨这一主题，到时结合例子，大家就能有一个具体而深刻的认识了。</p>
<h2>什么是typeinfo?</h2>
<p>typeinfo与RTII (Run-Time Type Information) 相关，它记录了一个对象的运行时类型信息。通过gdb看，vtable中的typeinfo同样是存放在.data.rel.ro段的一个指针，它指向了一个&nbsp;<span class="cnblogs_code">__cxxabiv1::__class_type_info</span>&nbsp;实例。&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;是一个在命名空间&nbsp;<span class="cnblogs_code">__cxxabiv1</span>&nbsp;中的类，它继承自&nbsp;<span class="cnblogs_code">std::type_info</span>&nbsp;，其中 <span class="cnblogs_code">std::type_info</span>&nbsp;中的&nbsp;<span class="cnblogs_code">__name</span>&nbsp;成员保存了一个字符串常量，即类型的名字。(&nbsp;<span class="cnblogs_code">std::type_info</span>&nbsp;在<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01094_source.html" target="_blank" rel="noopener nofollow">typeinfo</a>中定义，&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;在<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a00848_source.html" target="_blank" rel="noopener nofollow">cxxabi.h</a>中定义)</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250317002754167-139579108.png" alt="" loading="lazy"></p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250317003240867-48340463.png" alt=""></p>
<p>typeinfo通常在多态场景下发挥作用，一般有两个用途：</p>
<ul>
<li>获取运行时类型信息：通过&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;操作符获取对象的类型信息。即使我们只有一个基类的指针，我们也能在运行时知道该指针指向的对象的具体类型。</li>
<li>确保动态类型转换的安全性：&nbsp;<span class="cnblogs_code">dynamic_case</span>&nbsp;会根据typeinfo的信息，判断转换是否可行，若不可行，&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;将返回&nbsp;<span class="cnblogs_code">nullptr</span>&nbsp;（对于指针）或者抛出一个&nbsp;<span class="cnblogs_code">std::bad_cast</span>&nbsp;异常（对于引用）。</li>
</ul>
<p>在后面的系列中，我们会继续深入探讨在类的继承体系下，C++是如何通过typeinfo来获取指针或引用所指向的对象的运行时类型信息的。本篇文章，让我们先通过&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;的实现来感受下typeinfo的工作原理。</p>
<h3>有vtable时typeid的实现</h3>
<p>我们来看一个简单的例子。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> #include &lt;iostream&gt;
<span style="color: rgba(0, 128, 128, 1)"> 2</span> #include &lt;typeinfo&gt;
<span style="color: rgba(0, 128, 128, 1)"> 3</span> 
<span style="color: rgba(0, 128, 128, 1)"> 4</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span>     <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>         <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base() {}
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> 
<span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">char</span> *get_type(<span style="color: rgba(0, 0, 255, 1)">const</span> Base *<span style="color: rgba(0, 0, 0, 1)">p)
</span><span style="color: rgba(0, 128, 128, 1)">11</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">12</span>     <span style="color: rgba(0, 0, 255, 1)">const</span> std::type_info &amp;info = typeid(*<span style="color: rgba(0, 0, 0, 1)">p);
</span><span style="color: rgba(0, 128, 128, 1)">13</span>     <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> info.name();
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">15</span> 
<span style="color: rgba(0, 128, 128, 1)">16</span> <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">argv[])
</span><span style="color: rgba(0, 128, 128, 1)">17</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">18</span>     Base *p = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Base;
</span><span style="color: rgba(0, 128, 128, 1)">19</span>     std::cout &lt;&lt; get_type(p) &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">20</span>     <span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p;
</span><span style="color: rgba(0, 128, 128, 1)">21</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">22</span> }</pre>
</div>
<p>同样，我们用gdb来调试，在第13行打断点后run代码，打印出git_type函数的汇编代码：</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250318215728109-1823046604.png" alt="" loading="lazy"></p>
<p>这段汇编代码的大致含义是：先检查入参，若是&nbsp;<span class="cnblogs_code">nullptr</span>&nbsp;，则抛出&nbsp;<span class="cnblogs_code">bad_typeid</span>&nbsp;异常（注意这里传给&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;的是&nbsp;<span class="cnblogs_code">*p</span>&nbsp;，因此会校验空指针，因为空指针不能解引用）；否则，从虚函数表开始，逐步找到typeinfo name信息，即&nbsp;<span class="cnblogs_code">std::type_info::__name</span>&nbsp;成员，然后参数执行&nbsp;<span class="cnblogs_code">std::type_info::name()</span>&nbsp;返回字符串常量。详细解释下实现&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;的3句核心汇编代码。</p>
<div class="cnblogs_code">
<pre># %rdi是我们定义的get_type函数的第一个入参，这里就是对象的首地址，根据内存布局，
# vtable指针恰好是对象的前8个字节，因此
# %rdi: 对象首地址，
# (%rdi): 对象前8个字节的内容，即vtable指针
mov  (%rdi),%rax

# 如前所述，vtable指针并不指向vtable的起始位置，而是指向+16字节的偏移处，因此，
# %rax: vtable指针，即vtable首地址 + 16的位置
# %rax - 8: vtable首地址 + 8的位置，如前所述，这里存放的是指向typeinfo信息，
            即__cxxabiv1::__class_type_info对象的指针
# -0x8(%rax): 取 vtable首地址 + 8 这个地址里的内容，
              即__cxxabiv1::__class_type_info的首地址
mov  -0x8(%rax),%rax

# 如前所述，__cxxabiv1::__class_type_info的前8个字节也是一个vtable指针，
# 接下来才是指向typeinfo name这个字符串常量的指针，因此，
# 0x8(%rax): 取出__cxxabiv1::__class_type_info对象首地址 + 8处的内容，
             即指向typeinfo name的指针
mov  0x8(%rax),%rdi</pre>
</div>
<p>用gdb手动还原上述3句汇编：</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250320043018324-2064928425.png" alt="" loading="lazy"></p>
<p>结合下面的图示，可以更好地理解。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250320043654049-1511520956.png" alt="" loading="lazy"></p>
<h3>无vtable时typeid的实现</h3>
<p>如果我们将上述代码的第6行和第7行，即虚析构函数删除，那么就不会有vtable了，此时的&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;是如何实现的呢？</p>
<p>可以看到，这种情况下编译器不会再生成typeinfo，但会生成typeinfo name这个表示类型信息的字符串常量，&nbsp;<span class="cnblogs_code">typeid</span>&nbsp;会直接读取该常量。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250320051539689-29781466.png" alt=""></p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250320051641973-333239746.png" alt="" loading="lazy"></p>
<h2>关于destructor</h2>
<h3>背景知识</h3>
<p>按<a href="https://web.archive.org/web/20100315072857/http://www.codesourcery.com/public/cxx-abi/abi.html#mangling" target="_blank" rel="noopener nofollow">Itanium C++ ABI</a>描述，一共有三个destructor，符号中分别带D2、D1、D0，对应名称和作用如下：</p>
<blockquote>
<pre><span style="color: rgba(0, 0, 255, 1)"><code>&lt;ctor-dtor-name&gt; ::= C1	# complete object constructor
		         ::= C2	# base object constructor
		         ::= C3	# complete object allocating constructor
		         ::= D0	# deleting destructor
		         ::= D1	# complete object destructor
		         ::= D2	# base object destructor</code></span></pre>
</blockquote>
<blockquote>
<p><em>base object destructor</em>&nbsp;of a class T<br>A function that runs the destructors for non-static data members of T and non-virtual direct base classes of T.</p>
<p><em>complete object destructor</em>&nbsp;of a class T<br>A function that, in addition to the actions required of a base object destructor, runs the destructors for the virtual base classes of T.</p>
<p><em>deleting destructor</em>&nbsp;of a class T<br>A function that, in addition to the actions required of a complete object destructor, calls the appropriate deallocation function (i.e,.&nbsp;<code>operator delete</code>) for T.</p>























</blockquote>
<p>即：</p>
<ul>
<li>D2 -- base object destructor：负责销毁类的非静态数据成员以及非虚直接基类。</li>
<li>D1 -- complete object destructor：相比base object destructor，还会析构虚基类。</li>
<li>D0 -- deleting destructor：相比complete object destructor，还会调用释放内存相关的函数（比如&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;操作符）来释放对象占用的内存。</li>





















</ul>
<p>细心的读者可能发现了，根据前面的截图，vtable中的析构函数应该是base object destructor（&nbsp;<span class="cnblogs_code">_ZN4BaseD2Ev</span>&nbsp;），而我给出的图示中，写的却是complete object destructor（&nbsp;<span class="cnblogs_code">_ZN4BaseD1Ev</span>&nbsp;），为什么？</p>
<p>因为在我们的例子中，不涉及虚基类，因此complete object destructor和base object destructor的实现可以是一样的，编译器将符号&nbsp;<span class="cnblogs_code">_ZN4BaseD1Ev</span>&nbsp;作为&nbsp;<span class="cnblogs_code">_ZN4BaseD2Ev</span>&nbsp;的别名，两者对应相同的地址，共享同一份函数代码。</p>
<p>假设我们的例子名为example.cpp，使用&nbsp;<span class="cnblogs_code">g++ -S example.cpp</span>&nbsp;将代码编译成汇编代码example.s，然后在example.s中就能看到下面的语句。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250321085758979-325584465.png" alt="" loading="lazy"></p>
<p>使用&nbsp;<span class="cnblogs_code">g++ -g -O2 -fno-inline -std=c++20 -Wall example.cpp -o example</span>&nbsp;命令得到最终的二进制文件，查看符号，两者的地址确实是一样的。&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250322233305846-1259883680.png" alt=""></p>
<p>既然两者实际上是一个函数，那为什么我的图示中要写complete object destructor，而不是base object destructor呢？这也是ABI规定好的。</p>
<blockquote>
<p>The entries for virtual destructors are actually pairs of entries. The first destructor, called the complete object destructor, performs the destruction without calling delete() on the object. The second destructor, called the deleting destructor, calls delete() after destroying the object. Both destroy any virtual bases; a separate, non-virtual function, called the base object destructor, performs destruction of the object but not its virtual base subobjects, and does not call delete().</p>





















</blockquote>
<p>即，base object destructor是non-virtual function，因此它不在虚拟表里边。</p>
<h3>为什么虚拟表里要有两个destructor</h3>
<p>对一个对象而言，它可能是临时对象或者&nbsp;<span class="cnblogs_code">static</span>&nbsp;对象，这种情况下不需要显式&nbsp;<span class="cnblogs_code">delete</span>&nbsp;；它也可能是在堆上&nbsp;<span class="cnblogs_code">new</span>&nbsp;出来的，需要显式&nbsp;<span class="cnblogs_code">delete</span>&nbsp;，这时会有两件事发生，一是destructor会被调用，以完成类的非静态成员以及基类子对象的销毁（如关闭文件描述符等等），二是调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;，以释放这个对象本身占用的堆内存。这里顺带说一句，&nbsp;<span class="cnblogs_code">delete p</span>&nbsp;中的&nbsp;<span class="cnblogs_code">delete</span>&nbsp;和&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;中的&nbsp;<span class="cnblogs_code">delete</span>&nbsp;不是一回事，前者是delete expression，后者是deallocation functions，详情可以参考<a href="https://en.cppreference.com/w/cpp/keyword/delete" target="_blank" rel="noopener nofollow">cppreference</a>。</p>
<p>因此，需要两个destructor，complete object destructor内部不调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;，用于析构临时对象或者&nbsp;<span class="cnblogs_code">static</span>&nbsp;对象；deleting destructor内部会调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;，用于释放堆对象。通常，deleting destructor内部会先调用complete object destructor，再调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;。比如，本文开头的例子，deleting destructor对应的汇编代码是这样的：</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250323003935252-1052654379.png" alt="" loading="lazy"></p>
<h4>为什么不是三个？</h4>
<p>为什么不把base object destructor也放入虚函数表呢？分两种情况讨论：</p>
<ul>
<li>如果对象&nbsp;<span class="cnblogs_code">obj</span>&nbsp;没有虚基类，那么complete object destructor和base object destructor共享同一份代码，没必要在虚函数表中重复登记。</li>
<li>如果对象&nbsp;<span class="cnblogs_code">obj</span>&nbsp;有虚基类，那么编译器不会生成base object destructor，因为用不到。（是的，编译器并不会总是为对象生成这3个函数，它们是按需生成的）。</li>












</ul>
<h4>为什么不是一个？</h4>
<p>complete object destructor和deleting destructor的区别在于，后者多了一个在内部调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;的步骤。为什么非要在destructor内部调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;呢？完全可以删掉deleting destructor，只保留complete object destructor呀？如果不是动态创建的对象，那么只需要调用complete object destructor就可以了；如果是堆上的对象，那么在调用complete object destructor后，再调用一次&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;不就可以了吗？这么看来，deleting destructor似乎是多余的。</p>
<p>其实不是。</p>
<p>C++规定，不管是否显式声明，&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;都是&nbsp;<span class="cnblogs_code">static</span>&nbsp;的，因此它不能是虚函数，但是，它又是可以overload的。假设指针&nbsp;<span class="cnblogs_code">p_base</span>&nbsp;指向了一个派生类对象，而该派生类overload了&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;，那么我们希望在&nbsp;<span class="cnblogs_code">delete p_base</span>&nbsp;时，调用派生类中定义的&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;，即我们希望操作符&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;表现得像虚函数一样。如何能做到这一点呢？那就是在destructor内部调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;。关于这部分内容，<a href="https://stackoverflow.com/questions/44558119/why-do-i-have-two-destructor-implementations-in-my-assembly-output?answertab=scoredesc#tab-top" target="_blank" rel="noopener nofollow">StackOverflow上的回答</a>和<a href="https://eli.thegreenplace.net/2015/c-deleting-destructors-and-virtual-operator-delete/" target="_blank" rel="noopener nofollow">Eli Bendersky的博文</a>已经讲得很清楚了，我这里就不再班门弄斧了，读者可以参考这些资料进行更深入的了解。</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_cb7c31ba-23f4-4936-a228-f4c2e5f8d5eb" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_cb7c31ba-23f4-4936-a228-f4c2e5f8d5eb" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_cb7c31ba-23f4-4936-a228-f4c2e5f8d5eb" class="cnblogs_code_hide">
<pre>#include &lt;iostream&gt;

<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Base
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base() {}
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">(std::size_t sz)
    {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">new in Base called</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> ::<span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">(sz);
    }
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> <span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">delete</span>(<span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">ptr)
    {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">delete in Base called</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
        ::</span><span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)">(ptr);
    }
};

</span><span style="color: rgba(0, 0, 255, 1)">class</span> Derived : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Base
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Derived() {}
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">(std::size_t sz)
    {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">new in Derived called</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> ::<span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">(sz);
    }
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> <span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">delete</span>(<span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">ptr)
    {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">delete in Derived called</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
        ::</span><span style="color: rgba(0, 0, 255, 1)">operator</span> <span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)">(ptr);
    }
};

</span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main()
{
    Base </span>*p_base = <span style="color: rgba(0, 0, 255, 1)">new</span> Derived; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> new in Derived called</span>
    <span style="color: rgba(0, 0, 255, 1)">delete</span> p_base;              <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> delete in Derived called</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">示例代码：operator delete表现得像虚函数</span></div>
<p>综上，不能把在deleting destructor内部调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;的行为换成在外面调用。</p>
<p>但是，确实可以把complete object destructor和deleting destructor合成一个，只需要加一个额外参数来控制是否要调用&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;就可以了。MSVC编译器就是这么干的。</p>
<h1>总结</h1>
<p>本文从一个包含虚函数的简单对象（没有继承）入手，探索了vtable以及vtable中的各个条目。</p>
<ul>
<li>vtable位于.data.rel.ro段，这是因为，一方面，vtable是只读的，另一方面，它的内容，只有在链接时通过重定位才能确定。</li>
<li>top_offset记录了基类子对象（必须是多态对象）到完整对象的偏移，用于从基类子对象地址转换到完整对象地址。后续文章中还会详细介绍它。</li>
<li>typeinfo记录了对象的类型信息，用于RTII。本文仅仅窥得了它的冰山一角，后续文章会继续探索。</li>
<li>C++中一共有3种destructor，其中两种位于vtable中。deleting destructor用于析构堆对象，complete object destructor用于析构其它类型的对象（栈对象、static对象、基类子对象等）。需要两个需析构函数的原因是想让&nbsp;<span class="cnblogs_code">operator delete</span>&nbsp;也表现出“多态性”。当然，使用两个析构函数并不是实现这种“多态性”的唯一方式，比如，MSVC就采用了“一个destructor + 额外参数”的方案。</li>
</ul>
<p>由于在下才疏学浅，能力有限，错误疏漏之处在所难免，恳请广大读者批评指正，您的批评是在下前进的不竭动力。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.14996066016319445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-28 08:44">2025-03-28 08:38</span>&nbsp;
<a href="https://www.cnblogs.com/zpcdbky">同勉共进</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18773538" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18773538);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18773538', targetLink: 'https://www.cnblogs.com/zpcdbky/p/18773538', title: '虚函数表里有什么？（一）——从一个普通类开始' })">举报</a>
</div>
        