
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seamount3/p/18691760" title="发布于 2025-01-26 14:15">
    <span role="heading" aria-level="2">ReentrantLock实现机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="掌握reentrantlock">掌握Reentrantlock</h1>
<h3 id="具体结构">具体结构</h3>
<blockquote>
<p>下文Reentrantlock简称RL,阅读之前强烈建议读一下AQS源码解析: <a href="https://www.cnblogs.com/seamount3/p/18690818" target="_blank">https://www.cnblogs.com/seamount3/p/18690818</a></p>
</blockquote>
<p>其实RL和AQS有关系,但不是直接有关系,是RL内部有一个Sync变量,RL其实是实现LOCK接口好来实现对应的LOCK方法</p>
<blockquote>
<p>何为Sync,其实是一个内部类 extends AQS,内部又有两个子类分别是公平锁与非公平锁</p>
</blockquote>
<p>RL的核心就是在对应的内部类Sync的子类上</p>
<h3 id="子类之fairsync">子类之FairSync</h3>
<h4 id="lock">lock</h4>
<pre><code class="language-java">final void lock() {
    acquire(1);
}
</code></pre>
<p>没太多好说的,其实就只是包装了一下,调用AQS的 acquire方法</p>
<p>相对有意思的就是为什么要是1?</p>
<p>1其实是AQS抽象出来的参数,在此地是代表线程请求锁时需要获取的许可数量</p>
<p>这里的 <code>1</code> 表示当前线程请求 <strong>一个</strong> 锁的许可，锁的操作是以许可为基础的。</p>
<p>具体看下面的tryAcquire</p>
<h4 id="tryacquire">tryAcquire</h4>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
</code></pre>
<p>相对简单,流程如下:</p>
<ol>
<li>获取当前state变量
<ol>
<li>state=0,判断CLH是否有节点
<ol>
<li>如果没有那么进行CAS操作state</li>
<li>操作成功的话,设置为独占线程</li>
</ol>
</li>
</ol>
</li>
<li>为了实现可重入,那么还要考虑是否独占线程为当前线程
<ol>
<li>是的话,int nextc = c + acquires;并且setState</li>
</ol>
</li>
</ol>
<h3 id="子类之nonfairsync">子类之NonfairSync</h3>
<h4 id="lock-1">lock</h4>
<pre><code class="language-java">final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
</code></pre>
<h4 id="tryacquire-1">tryAcquire</h4>
<p>和公平锁差不多,只不过不进行判断是否有前驱节点</p>
<h3 id="sync父类实现了什么功能">Sync父类实现了什么功能?</h3>
<h4 id="核心之tryrelease">核心之tryRelease</h4>
<blockquote>
<p>本方法的实现是为了给AQS实现对应的钩子方法,在RL的unlock方法最终会调用AQS的release</p>
</blockquote>
<pre><code class="language-java">protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<p>核心的流程如下:</p>
<ol>
<li>判断当前线程是否是锁资源持有的线程
<ol>
<li>不是的话,抛异常</li>
</ol>
</li>
<li>1ok后,修改state
<ol>
<li>如果state改完==0,那么彻底释放锁</li>
<li>如果不等于只是修改state,不释放锁,为了支持可重入嘛</li>
</ol>
</li>
</ol>
<h2 id="如果面试官让介绍reentrantlock如何介绍">如果面试官让介绍ReentrantLock如何介绍?</h2>
<ol>
<li>快速简单介绍(包括功能)</li>
<li>详细介绍下如何实现</li>
</ol>
<h4 id="快速简单介绍包括功能">快速简单介绍(包括功能)</h4>
<p>首先ReentrantLock实现了对应的Lock接口,他的功能基本上起到的就是本地锁的作用,</p>
<p>ReentrantLock在功能上支持:</p>
<ol>
<li>互斥性(RL是互斥锁,同一时刻只允许一个线程获取锁进入临界区，写操作自然也是互斥的。)</li>
<li>可重入性</li>
<li>公平与非公平</li>
<li>可中断,<code>lockInterruptibly()</code> 方法，允许线程在等待锁的过程中被中断</li>
<li>限时性,例如TryLock可以允许线程在指定的时间内尝试获取锁。如果在指定时间内没有获取到锁，线程会返回 <code>false</code>。</li>
</ol>
<p>上述的功能大多是借助AQS的已有代码,以及ReentrantLock内部类像FairSync等继承了AQS并且实现了对应的钩子方法例如tryAcquire来实现总体的功能</p>
<h4 id="详细介绍下如何实现">详细介绍下如何实现</h4>
<p><strong>讲一下lock流程:</strong></p>
<ol>
<li>首先入口是RL的lock方法,而底层其实是调用内部变量Sync的acquire方法(也就是AQS的acquire模板方法)</li>
<li>这里就体现出公平与非公共的区别了,在构造器中我们会生成公平锁的实例或者非公平锁的实例通过这一点就实现了公平与非公平</li>
<li>以公平为例,那么我们会进行AQS的acquire流程
<ol>
<li>先调用对应公平锁实现的tryAcquire
<ol>
<li>获取当前state变量
<ol>
<li>state=0,判断CLH是否有节点
<ol>
<li>如果没有那么进行CAS操作state</li>
<li>操作成功的话,设置为独占线程</li>
</ol>
</li>
</ol>
</li>
<li>为了实现可重入,那么还要考虑是否独占线程为当前线程
<ol>
<li>是的话,int nextc = c + acquires;并且setState</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如果tryAcquire失败,那么就进入把当前线程转换为Node添加到CLH队尾流程,然后等待唤醒,然后对应还有一个重要的方法就是acquireQueued,相当于是死循环,然后每个线程会再次tryAcquire如果失败再阻塞,之后就等待唤醒</li>
</ol>
<p><strong>讲一下unlock流程</strong>:</p>
<ol>
<li>内部会调用对应Sync类的release方法(也就是AQS实现的模板方法)</li>
<li>然后执行对应的tryRelease流程</li>
<li>最后唤醒队列中的下一个节点</li>
</ol>
<p>而刚刚提到的可中断也是AQS锁支持的,以及超时机制,都是AQS在特定代码,例如可中断则是在循环中会去判断下线程状态而超时则是在循环过程中结合当前时间与起始时间之间求差进行判断</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.14072660959143518" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 22:56">2025-01-26 14:15</span>&nbsp;
<a href="https://www.cnblogs.com/seamount3">海山了-</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18691760" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18691760);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18691760', targetLink: 'https://www.cnblogs.com/seamount3/p/18691760', title: 'ReentrantLock实现机制' })">举报</a>
</div>
        