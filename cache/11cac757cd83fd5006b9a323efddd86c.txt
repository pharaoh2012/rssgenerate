
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18731266" title="发布于 2025-02-22 19:13">
    <span role="heading" aria-level="2">动态代理到AOP</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="动态代理">动态代理</h1>
<blockquote>
<p>代理(proxy)是一种设计模式,通过了目标对象的另外访问方法,即通过代理对象访问目标对象.动态代理是再程序运行时动态地生成一个代理类代替原本的类.该类会拦截对目标对象的方法调用</p>
</blockquote>
<h3 id="为什么使用动态代理">为什么使用动态代理</h3>
<ul>
<li>动态代理可以帮我们减少许多冗余的代码,当你必须在类中做相同的事时,如日志记录,权限校验.若不想在每个方法里重复写这些代码,<strong>动态代理</strong> 就是帮你实现这一目标的工具,它通过拦截方法调用,在方法执行前后做一些额外的事情比如记录日志,验证权限</li>
</ul>
<h2 id="动态代理的实现">动态代理的实现</h2>
<blockquote>
<p>动态代理分别分为:JDK动态代理和CGLIB动态代理</p>
</blockquote>
<h3 id="jdk动态代理">JDK动态代理</h3>
<ul>
<li>适用于代理接口类型的对象</li>
</ul>
<pre><code class="language-java">//业务接口
public interface UserService {
    void addUser();
}
//实现类
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("添加用户业务逻辑...");
    }
}

</code></pre>
<pre><code class="language-java">public class LoggingInvocationHandler implements InvocationHandler {

    private Object target;

    //封装一个绑定方法获取
    public Object newProxyInsatance(Object target) {

        this.target = target;
				
				//Proxy.newProxyInstance()方法用于在运行时动态生成代理类和实例
				
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),//被代理类类加载器
                target.getClass().getInterfaces(),//被代理类需要实现的接口列表
                this//方法调用处理器
        );
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println("方法执行之前执行" + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("方法执行之后执行" + method.getName());

        return result;
    }
}

</code></pre>
<pre><code class="language-java">public class Test01 {
    public static void main(String[] args) {
        LoggingInvocationHandler handler = new LoggingInvocationHandler();

        UserService userService = new UserServiceImpl();

        UserService insatance = (UserService) handler.newProxyInsatance(userService);

        insatance.addUser();

    }
}
//output
//方法执行之前执行addUser
//添加用户业务逻辑...
//方法执行之后执行addUser

</code></pre>
<ul>
<li>
<p><code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h</code></p>
<p><code>)</code></p>
</li>
<li>
<p>这是JDK动态代理和核心方法,用于在运行时动态生成代理类和实例,其需要传入三个参数,分别为<code>ClassLoader loader</code>被代理类的类加载器,<code>Class&lt;?&gt;[] interfaces</code>代理类需要实现的接口列表,<code>InvocationHandler h</code>,方法调用处理器</p>
</li>
</ul>
<h3 id="cglib动态代理">CGLIB动态代理</h3>
<ul>
<li>
<p>CGLIB是通过生成目标类的子类来实现代理,Spring在目标类没有实现的接口时,就会采用CGLIB动态代理,<strong>CGLIB生成的代理类是目标类的子类,并覆盖目标类方法,因此其能代理没有接口的类</strong></p>
</li>
<li>
<p>导入CGLIB依赖</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<p>一个没有接口的UserService</p>
<pre><code class="language-java">public class UserService {
    public void addUser() {
        System.out.println("添加逻辑...");
    }
}

//实现MethodInterceptor类
public class LoggingMethodInterceptor implements MethodInterceptor {

    private Object target;

    public Object newProxyInstance(Object target) {

        this.target = target;

        //创建CGLIB字节增强对象,用于生成目标类的子类代理
        Enhancer enhancer = new Enhancer();
        //设置代理类的父类
        enhancer.setSuperclass(target.getClass());

        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {

        methodProxy.invokeSuper(o, objects);

        return null;
    }
}
</code></pre>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {

        UserService userService = new UserService();
        LoggingMethodInterceptor interceptor = new LoggingMethodInterceptor();

        UserService instance = (UserService) interceptor.newProxyInstance(userService);

        instance.addUser();
    }
}
</code></pre>
<h1 id="aopaspect-oriented-programming">AOP(Aspect Oriented Programming)</h1>
<blockquote>
<p>动态代理是AOP的底层实现,其作用是把<strong>横切关注点(</strong>如日志,事务<strong>)</strong>从核心业务逻辑中分离出,形成一个独立的模块.这就可以做到在不修改源代码的情况下,给程序动态统一地添加功能</p>
</blockquote>
<ul>
<li>
<p>作用:减少代码冗余,提高开发效率,易于维护</p>
</li>
<li>
<p>进一步理解</p>
<blockquote>
<p>在Spring中,AOP基于动态代理实现,其会为目标对象创建一个代理对象,在目标方法执行之前,后,或异常时执行你的配置的增强</p>
</blockquote>
<ul>
<li>如图:原有四个接口要验证参数,日志.我们发现这些代码太冗余.比较繁琐.使用切面后将验证参数,日志等功能提取出来,四个接口我们只需要通过配置就可以直接调用对应功能,让我们更加专注于实际业务逻辑</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202502/3423316-20250222191205163-1066755353.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="aop-的关键术语">AOP 的关键术语</h2>
<ul>
<li>目标对象(Target):
<ul>
<li><strong>目标对象指的是业务逻辑的实现类,</strong>这些实现类是切面增强的对象.</li>
<li>作用:目标对象是我们通常定义的业务类,切面提供了切点的功能如(日志记录,业务管理等等)</li>
<li>假设有一个<code>UserService</code>业务类,其包含了一个<code>addUser()</code>方法.UserService类就是目标对象,AOP会在<code>addUser()</code>中增强功能</li>
</ul>
</li>
<li>织入(Weaving):
<ul>
<li>织入是将切面(通知和切入点)用于到目标对象的过程.</li>
<li>作用:织入的过程是把定义好的增强逻辑插入到目标对象中去.这是AOP实现的关键步骤,Spring AOP通过动态代理实现</li>
</ul>
</li>
<li>切面(Aspect):
<ul>
<li>切面是对横切关注点的模块化,其包含了切入点和通知,切面提取出业务中一些相同的功能进行统一管理</li>
<li>作用:切面将横切关注点上的功能封装在一起,方便重用.一个切面可以有多个增强方法(通知),这些通知可以应用到目标对象的多个方法上</li>
<li>例如一个<code>LogAspect</code>就可以包含多个通知,用于不同的方法前执行插入日志记录功能等等</li>
</ul>
</li>
<li>通知(Advice):
<ul>
<li>通知是指在切点执行时,执行增强的代码,通知可以在方法执行的不同阶段执行,包括方法执行前,执行后,围绕方法执行的前后</li>
<li>常见分为
<ul>
<li>前置通知(Before):在目标方法执行之前执行</li>
<li>后置通知(After):在目标方法执行之后执行,无论是否抛出异常</li>
<li>后置返回通知(AfterReturning):在目标方法执行之后执行,有异常时不执行</li>
<li>后置异常通知(AfterThrowing):在目标方法抛出异常时执行</li>
<li>环绕通知(Around):最为常用的通知,在目标方法执行前后执行</li>
</ul>
</li>
</ul>
</li>
<li>切入点(PointCut):
<ul>
<li>切入点指通知应用的具体位置条件,其决定了哪些连接点可以被增强,通常使用切入点达式来定义</li>
<li>作用:切入点是AOP的核心,其决定了哪些方法可以被增强.通过切入点表达式,开发者可以灵活选择要增强的方法</li>
<li>通过<code>execution(* com.company.service.UserService.*(..))</code>切入点表达式,可以表示<code>UserService</code>类中的所有方法都被增强,下面的内容会展开讲解</li>
</ul>
</li>
<li>连接点(JoinPoint):
<ul>
<li>连接点是程序执行的一个具体位置,其指的是可以被切面拦截的方法.连接点是AOP的关键概念.所有的通知都会在某个连接点处执行.在Spring AOP中通常指的是方法调用</li>
<li>作用:连接点定义了切面可以织入的程序位置,通常是目标方法执行的位置.在 <strong>Spring AOP中,连接点仅限于方法的执行</strong>.</li>
</ul>
</li>
</ul>
<h2 id="aop的使用">AOP的使用</h2>
<h3 id="导入依赖">导入依赖</h3>
<ul>
<li>对于普通的Spring项目导入的AOP依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>对于SpringBoot项目导入的AOP依赖</li>
</ul>
<pre><code class="language-xml">   &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>AOP的实现分为XML文件配置和注解配置,XML文件配置都是老掉骨头的东西我们就不学了,注解配置避免了繁琐的XM 配置,使得开发更加灵活,易于理解.我们着重对注解配置进行掌握即可</p>
</blockquote>
<h3 id="使用注解实现aop">使用注解实现AOP</h3>
<ul>
<li>
<p>配置类</p>
<ul>
<li>配置类是用于启动Spring AOP的注解和扫描指定位置的包.我们创建一个<code>AppConfig</code>类,使用<code>@Comfiguration</code>,<code>@ComponentScan</code>和<code>EnableAspectAutoProxy</code>来启动Spring AOP</li>
</ul>
<pre><code class="language-java">@Configuration
@ComponentScan({"com.mashang.service", "com.mashang.aspect"})
@EnableAspectJAutoProxy
public class APPConfig {
}
</code></pre>
<ul>
<li><code>@Comfiguration</code>:指明当前类为一个配置类,类似于XML配置文件</li>
<li><code>@EnableAspectAutoProxy</code>:启用Spring AOP注解支持,允许在上下文中应用<code>@Aspect</code>注解标记切面</li>
<li><code>@ComponentScan({"com.mashang.service", "com.mashang.aspect"})</code>:扫描指定包中的组件</li>
</ul>
</li>
<li>
<p>切面类</p>
<ul>
<li>接着创建切面类,使用<code>@Aspect</code>注解来标记该类是切面类,切面类中可以通过注解标记不同的增强方法(如<code>@Before</code>,<code>@After</code>,<code>@Around</code>)</li>
</ul>
<pre><code class="language-java">@Component
//配置切面类得注解
@Aspect
@Order(1)
public class LogAspect {

    //定义切点,拦截service包下所有方法
    @Pointcut("execution(* com.mashang.service.*.*(..))")
    public void serviceMethod() {

    }

    //前置通知
    @Before("serviceMethod()")
    public void before() {
        System.out.println("[前置通知] 方法执行");
    }

    //环绕通知,通常用于记录性能耗时
    @Around("serviceMethod()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {

        Long startTime = System.currentTimeMillis();
        for (int i = 0; i &lt; 100000; i++) {

        }
        System.out.println("[环绕通知]开始执行方法 " + pjp.getSignature().getName());

        Object proceed = pjp.proceed();

        Long endTime = System.currentTimeMillis();
        System.out.println("方法耗时: " + (endTime - startTime) + "ms");

        return proceed;
    }
    
		//后置通知
    @After("serviceMethod()")
    public void after() {
        System.out.println("[后置通知] 方法执行");
    }

    //异常通知
    @AfterThrowing(pointcut = "serviceMethod()", throwing = "e")
    public void afterThrowing(Exception e) {
        System.out.println("[异常通知]" + e.getMessage());
    }
}

</code></pre>
<ul>
<li><code>＠Aspect</code>表示该类为切面类</li>
<li><code>@Order(int)</code>:<strong>控制切面类的顺序</strong></li>
<li><code>@Component</code>标记交为Spring容器管理,允许注入容器中</li>
<li><code>@Before,@After,@Around,@AroundThrowing</code>表明不同类型的通知</li>
<li>切入点表达式
<ul>
<li>
<p>切入点表达式是AOP的核心语法,用于定义哪些方法需要被增强,与<code>@PointCut</code>注解一同使用</p>
</li>
<li>
<p>核心语法结构</p>
<pre><code class="language-java">execution([修饰符] 返回类型 [包名.类名.方法名(参数列表) [throws 异常类型]])
</code></pre>
<ul>
<li>可以使用通配符
<ul>
<li><code>*</code>表示匹配任意字符除了<code>.</code></li>
<li><code>..</code>表示任意子包或任意参数</li>
</ul>
</li>
<li>如匹配com.mashang.service下包的所有方法</li>
</ul>
<pre><code class="language-java">@PointCut("excution(* com.mashang.service.*.*(..))")
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //加载Spring配置
        AnnotationConfigApplicationContext cxt
                = new AnnotationConfigApplicationContext(APPConfig.class);

        //获取Userservice实例
        UserService userService = cxt.getBean(UserService.class);

        System.out.println("=======测试正常方法=========");
        userService.getUser("张三");

        System.out.println("=======测试异常方法=========");

        try {
            userService.throwException();
        } catch (Exception e) {
            e.printStackTrace();
        }

        cxt.close();
    }
}

</code></pre>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7115425884988426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-22 19:13">2025-02-22 19:13</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">43</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18731266" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18731266);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18731266', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18731266', title: '动态代理到AOP' })">举报</a>
</div>
        