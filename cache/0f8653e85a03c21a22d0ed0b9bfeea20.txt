
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18848678" title="发布于 2025-04-27 18:04">
    <span role="heading" aria-level="2">[设计模式/Java] 设计模式之解释器模式【27】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概述解释器模式--interpreter-pattern--行为型模式">概述：解释器模式 := Interpreter Pattern ∈ 行为型模式</h1>
<h2 id="模式定义">模式定义</h2>
<ul>
<li><strong>解释器模式</strong>（<code>Interpreter Pattern</code>）提供了<strong>评估语言的语法</strong>或<strong>表达式</strong>的方式</li>
</ul>
<blockquote>
<p>属于<strong>行为型模式</strong>。</p>
</blockquote>
<ul>
<li>
<p>解释器模式给定一个<strong>语言</strong>，定义它的<strong>文法的一种表示</strong>，并定义一个<strong>解释器</strong>，这个<strong>解释器</strong>使用该表示来<strong>解释语言中的句子</strong>。</p>
</li>
<li>
<p>这种模式被用在 <code>SQL</code> <strong>解析</strong>、<strong>符号处理引擎</strong>等。</p>
</li>
<li>
<p>模式的意图</p>
</li>
</ul>
<blockquote>
<p>定义一种语言的文法表示，并创建一个解释器，该解释器能够解释该语言中的句子。。</p>
</blockquote>
<ul>
<li><strong>主要解决的问题</strong></li>
</ul>
<blockquote>
<p>解释器模式用于构建一个<strong>能够解释特定语言或文法</strong>的<strong>句子的解释器</strong>。</p>
</blockquote>
<h2 id="模式结构">模式结构</h2>
<blockquote>
<p>解释器模式包含以下几个主要角色：</p>
</blockquote>
<ul>
<li><strong>抽象表达式（Abstract Expression）</strong>：定义了解释器的抽象接口，声明了解释操作的方法，通常是一个抽象类或接口。</li>
<li><strong>终结符表达式（Terminal Expression）</strong>：实现了抽象表达式接口的终结符表达式类，用于表示语言中的终结符（如变量、常量等），并实现了对应的解释操作。</li>
<li><strong>非终结符表达式（Non-terminal Expression）</strong>：实现了抽象表达式接口的非终结符表达式类，用于表示语言中的非终结符（如句子、表达式等），并实现了对应的解释操作。</li>
<li><strong>上下文（Context）</strong>：包含解释器之外的一些<strong>全局</strong>信息，在解释过程中提供给解释器使用，通常用于存储<strong>变量</strong>的值、保存解释器的<strong>状态</strong>等。</li>
<li><strong>客户端（Client）</strong>：创建并配置具体的解释器对象，并将需要解释的表达式传递给解释器进行解释。</li>
</ul>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当某一特定类型的问题频繁出现，并且可以通过一种简单的语言来表达这些问题的实例时。</li>
</ul>
<h2 id="实现方式">实现方式</h2>
<ul>
<li><strong>定义【文法】</strong>：明确语言的终结符和非终结符。</li>
<li><strong>构建【语法树】</strong>：根据语言的句子构建对应的语法树结构。</li>
<li><strong>创建【环境类】</strong>：包含解释过程中所需的全局信息，通常是一个HashMap。</li>
</ul>
<h2 id="关键代码">关键代码</h2>
<ul>
<li><strong>终结符与非终结符</strong>：定义语言的文法结构。</li>
<li><strong>环境类</strong>：存储解释过程中需要的外部环境信息。</li>
</ul>
<h2 id="模式特点">模式特点</h2>
<h3 id="优点">优点</h3>
<ul>
<li><strong>可扩展性好</strong>：容易添加新的解释表达式的方式。</li>
<li><strong>灵活性</strong>：可以根据需要轻松扩展或修改文法。</li>
<li><strong>易于实现简单文法</strong>：对于简单的语言，实现起来相对容易。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ol>
<li><strong>使用场景有限</strong>：只适用于适合使用解释的简单文法。</li>
<li><strong>维护困难</strong>：对于复杂的文法，维护和扩展变得困难。</li>
<li><strong>类膨胀</strong>：可能会产生很多类，每个文法规则对应一个类。</li>
<li><strong>递归调用</strong>：解释器模式通常使用【递归调用】，这可能难以理解和跟踪。</li>
</ol>
<h3 id="使用建议">使用建议</h3>
<ul>
<li>在需要解释执行语言中的句子时，考虑使用解释器模式。</li>
<li>确保文法简单，以避免系统变得过于复杂。</li>
<li>解释器模式在 Java 中可能不是首选，如果遇到适用场景，可以考虑使用如<code>expression4J</code>之类的库来代替。</li>
</ul>
<h1 id="案例实践">案例实践</h1>
<h2 id="案例总结">案例总结</h2>
<ul>
<li><strong>编译器</strong>：解释器模式可以用于编译器设计，将源代码解释为目标代码。</li>
<li><strong>正则表达式</strong>：解释器模式可以用于解析和执行正则表达式。</li>
<li><strong>SQL解析</strong>：解释器模式可以用于解析和执行SQL语句。</li>
<li><strong>文本模板渲染引擎</strong> : 用于将各层级的环境信息渲染到文本模板中，生成最终的SQL、HTML等。著名的文本模板渲染引擎有：Jinjia(2) / Thymeleaf / Freemaker 等。</li>
</ul>
<h2 id="case-解释器模式的简单实现性别婚姻">CASE 解释器模式的简单实现(性别/婚姻)</h2>
<ul>
<li>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。</li>
<li>定义作为上下文中主要解释器的 TerminalExpression 类。</li>
<li>其他的类 OrExpression、AndExpression 用于创建<strong>组合式表达式</strong>。</li>
<li>InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250427091714054-2099561607.png" alt="" loading="lazy"></p>
<h3 id="表达式接口--expression">表达式接口 : Expression</h3>
<pre><code class="language-java">public interface Expression {
   public boolean interpret(String context);
}
</code></pre>
<h3 id="表达式接口的实现类-terminalexpression--orexpression--andexpression">表达式接口的实现类: TerminalExpression / OrExpression / AndExpression</h3>
<ul>
<li>TerminalExpression</li>
</ul>
<pre><code class="language-java">public class TerminalExpression implements Expression {
   
   private String data;
 
   public TerminalExpression(String data){
      this.data = data; 
   }
 
   @Override
   public boolean interpret(String context) {
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}
</code></pre>
<ul>
<li>OrExpression</li>
</ul>
<pre><code class="language-java">public class OrExpression implements Expression {
   private Expression expr1 = null;
   private Expression expr2 = null;
 
   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }
 
   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) || expr2.interpret(context);
   }
}
</code></pre>
<ul>
<li>AndExpression</li>
</ul>
<pre><code class="language-java">public class AndExpression implements Expression {
   private Expression expr1 = null;
   private Expression expr2 = null;
 
   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }
 
   @Override
   public boolean interpret(String context) {      
      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);
   }
}
</code></pre>
<h3 id="client--interpreterpatterndemo">Client : InterpreterPatternDemo</h3>
<ul>
<li>InterpreterPatternDemo : 使用 Expression 类来创建规则，并解析它们。</li>
</ul>
<pre><code class="language-java">public class InterpreterPatternDemo {
   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression("Robert");
      Expression john = new TerminalExpression("John");
      return new OrExpression(robert, john);    
   }
 
   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression("Julie");
      Expression married = new TerminalExpression("Married");
      return new AndExpression(julie, married);    
   }
 
   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();
 
      System.out.println("John is male? " + isMale.interpret("John"));
      System.out.println("Julie is a married women? " 
      + isMarriedWoman.interpret("Married Julie"));
   }
}
</code></pre>
<blockquote>
<p>out</p>
</blockquote>
<pre><code class="language-log">John is male? true
Julie is a married women? true
</code></pre>
<h2 id="case-开源-sql-解析引擎---apche-calcite">CASE 开源 SQL 解析引擎 - Apche Calcite</h2>
<ul>
<li>推荐文献</li>
</ul>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/454943287" target="_blank" rel="noopener nofollow">Calcite - SQL 解析框架 - Zhihu/廖嘉逸</a></li>
</ul>
</blockquote>
<h2 id="case-开源语法分析工具---antlr">CASE 开源语法分析工具 - Antlr</h2>
<ul>
<li>推荐文献</li>
</ul>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/69294769" target="_blank" rel="noopener nofollow">Antlr - 强大的开源语法分析工具 - Zhihu</a></li>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18849096" target="_blank">Antlr : 开源语法分析工具 - 博客园/千千寰宇</a></li>
</ul>
</blockquote>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/17189752.html" target="_blank">设计模式之总述 - 博客园/千千寰宇</a></li>
<li><a href="https://blog.csdn.net/2401_85480529/article/details/140137578" target="_blank" rel="noopener nofollow">常见的Java模板引擎 - CSDN</a></li>
</ul>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://www.runoob.com/design-pattern/interpreter-pattern.html" target="_blank" rel="noopener nofollow">解释器模式 - 菜鸟教程</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3434631753425926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-27 18:05">2025-04-27 18:04</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18848678);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18848678', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18848678', title: '[设计模式/Java] 设计模式之解释器模式【27】' })">举报</a>
</div>
        