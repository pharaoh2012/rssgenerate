
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/BDFFZI/p/18733944" title="发布于 2025-02-24 14:09">
    <span role="heading" aria-level="2">【质点弹簧实现】如何做一个绝对不会崩溃的质点弹簧模型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="质点弹簧实现如何做一个绝对不会崩溃的质点弹簧模型">【质点弹簧实现】如何做一个绝对不会崩溃的质点弹簧模型</h1>
<p>在绳索、布料、软体等软性物质的模拟上，质点弹簧绝对是最流行的一种物理模型，相关资料在网上非常多。但无一例外的都绕不过一个痛点：动不动就崩溃给你看。那有没有一种能实现绝对不会崩溃的质点弹簧模型，或者说我们能始终确切的知道它崩溃的边缘在哪里，而不是和传统质点弹簧模型一样，总是在调参。</p>
<h2 id="传统质点弹簧的三个缺陷">传统质点弹簧的三个缺陷</h2>
<p>传统质点弹簧为什么那么容易崩溃？其实总结起来就那几个原因：</p>
<ul>
<li>迭代时间没设置好</li>
<li>弹力系数没设置好</li>
<li>弹簧阻力没设置好</li>
</ul>
<p>我们当然可以说这是质点弹簧模型精密性的表现，但换句话说，它是不是太脆弱了？而且这三个系数真的很抽象，我们只能大概描述它们的作用，却不能精准预判它们的效果：</p>
<ul>
<li>迭代时间太长：崩溃给你看；迭代时间太短：电脑带不动。</li>
<li>弹力系数太大：崩溃给你看；弹力系数太小：软塌塌的没劲。</li>
<li>弹簧阻力太小：崩溃给你看；弹簧阻力太大：崩溃给你看。</li>
</ul>
<p>说到底，这三个参数从设计上就会引发崩溃，因此想要解决问题，必须对这三个家伙优化。</p>
<h2 id="去除迭代时间">去除迭代时间</h2>
<p>迭代时间是真的可以从根本上解决，因为我们实际上有不依赖时间的位置积分方式。</p>
<h3 id="确定质点位置的积分方式">确定质点位置的积分方式</h3>
<p>总所周知质点弹簧模型里一般也就两种实现质点位置积分方式：</p>
<ul>
<li>欧拉积分：<span class="math inline">\(p(t+\Delta t)= p(t) + v(t)\Delta t + a(t)\Delta t^2\)</span>（这里用常见的半隐式欧拉）</li>
<li>Verlet 积分：<span class="math inline">\(p(t+\Delta t) = p(t)+(p(t)-p(t-\Delta t))+a(t)\Delta t^2\)</span></li>
</ul>
<p>可以观察到与位移有关项基本都依赖 <span class="math inline">\(\Delta t\)</span>，但很巧的是 Verlet 积分中的第二项 <span class="math inline">\(p(t)-p(t-\Delta t)\)</span> 却是与时间无关。而由于加速度实际上可以转换为位移，所以我们可以使 <span class="math inline">\(a(t)\)</span>永远等于 0，因此第三项我们是完全可以去除的。</p>
<p>划下来我们便能得到一种特别的位置积分方式，一种与时间完全无关的方法：</p>
<p></p><div class="math display">\[p(t+\Delta t) = p(t)+(p(t)-p(t-\Delta t))
\]</div><p></p><p>这里的 <span class="math inline">\(p(t)-p(t-\Delta t)\)</span> 其实对应的就是欧拉积分中的 <span class="math inline">\(v(t)\Delta t\)</span>，虽然具体数值和含义不同，但效果是一样的，因此后续我们将这一项也简称为“速度”。</p>
<h3 id="确定力对质点的作用入口">确定力对质点的作用入口</h3>
<p>该公式中提供了我们两个影响质点的入口：</p>
<ul>
<li><span class="math inline">\(p(t)\)</span>（当前位置）</li>
<li><span class="math inline">\(p(t-\Delta t)\)</span>（上次位置）</li>
</ul>
<p>修改上次位置显然不太适合，因为这会使其含义与实际值不匹配，例如如果后续要做 ccd（连续碰撞检测），这个本应该可以用上的参数就完全废掉了。</p>
<p>那便只能<strong>修改当前位置</strong>了。从公式的效果上来看，这样的结果就相当于力使质点立即发生的位移，并将速度累计了下来（当前位置和上次位置差值变化了）。</p>
<p>（此外这还隐藏了一些额外的好处，我们后续再说。）</p>
<h3 id="确定质点位置积分的时序">确定质点位置积分的时序</h3>
<p>传统的积分方式是在质点当前的所有力都施加完毕后，即每帧的末尾再对质点的位置进行积分。但该积分流程如果用在我们的积分方案上就会存在问题，因为我们每次施加力是直接位移，然后累加下速度，接着积分通过速度再次位移，算下来一帧就位移了两次，即多了一次。</p>
<p>所以我们需要调整积分时序，<strong>在每帧的开头时进行积分</strong>，释放上一帧累加的速度，而后续的力计算，因为是直接作用于位移，因此也不依赖位置积分。</p>
<p>（此外这种迭代方式还隐藏了一些其他好处，我们后续再说。）</p>
<h3 id="总结">总结</h3>
<p>新的质点弹簧模型，我们将使用如下方式迭代质点：</p>
<ol>
<li>每帧开始时对质点积分，积分方式采用：<span class="math inline">\(p(t+\Delta t) = p(t)+(p(t)-p(t-\Delta t))\)</span>。</li>
<li>对质点积分后再进行弹簧等力计算，结算力的方式为直接修改质点当前位置。</li>
<li>完成帧迭代，后续直接用质点当前位置进行渲染等操作。</li>
</ol>
<h2 id="优化弹力系数">优化弹力系数</h2>
<p>胡可定律表明：<code>弹力=弹力系数*距离*方向</code>。我相信该公式在现实世界的正确性，但在一个存在时间误差的模拟系统中，弹力系数并不是一个可以随便设置的值，而且由于上述“去除迭代时间”的操作，我们也无法直接使用力、速度（这里指欧拉积分里的常规速度概念）等与时间相关的参数。</p>
<p>弹力系数到底是什么？说到底，实现弹力现象的关键有两点：</p>
<ol>
<li>是一种力，所以会改变物体的速度。</li>
<li>这种力是距离约束，却不会立即将物体拉到规定的距离上。</li>
</ol>
<p>第一点我们已经实现，因为当前使用的积分方法中，修改位置就会累计速度。而第二点中，在“非规定距离”的选择上隐含了一些很重要的限制条件：</p>
<p><img src="https://img2023.cnblogs.com/blog/2454431/202502/2454431-20250224144949885-130006473.svg" alt="" loading="lazy"></p>
<p>若当前质点距离弹簧约束的最佳距离位置为 <span class="math inline">\(a\)</span>，那么质点下一次可移动到的距离只能在 <span class="math inline">\([0,2a]\)</span> 间选择，因为超过这些距离后，质点每次迭代只会离目标越来越远，最终崩溃。考虑弹簧还会累计速度，若不存在阻力的话，那距离选择更是被限制在了 <span class="math inline">\([0,a]\)</span>。这一很关键的限制在传统的弹力系数上却没有体现，这就是为什么调大了就会崩溃。</p>
<p>恰好我们这里使用位移施加力，因此我们不再使用传统的弹力系数，而是改成一个 <span class="math inline">\([0,2]\)</span> 的比例值，对应的就是上述的 <span class="math inline">\([0,2a]\)</span>。这样我们才能更清晰更稳定的控制弹簧弹力的大小。</p>
<h2 id="处理弹簧阻力">处理弹簧阻力</h2>
<p>很多传统质点弹簧除了弹簧本身的力之外，往往还会多一个步骤处理弹簧阻力，为什么？</p>
<p>观察实验现象很容易发现一点：</p>
<ul>
<li>仅有一个弹簧时，不处理弹簧阻力也不容易崩溃。</li>
<li>但一旦多个弹簧共同作用，不施加阻力，就很容易崩溃了。</li>
</ul>
<p>说到底原因就是多弹簧的弹力累加后使质点一次移动超过了 <span class="math inline">\(2a\)</span>，最终弹簧发散崩溃，所以必须要额外的步骤实现阻力，来解决累计弹力过大的问题。</p>
<p>一种常见的阻力处理方式是检测在弹簧方向上的弹力的总和，然后用额外的阻力系数计算阻力。从原理上看这很类似与传统的弹力实现，只是这是基于力约束而不是距离约束。但也因此存在和传统弹力系数一样，阻力系数不够明确的问题。</p>
<ul>
<li>
<p>最佳的阻力计算应该是什么样的？</p>
<p>实际就是就是要考虑弹簧间的相互作用，确保在上一个弹簧处理后，再加上当前的弹簧力，始终不会使质点位移距离不超过 <span class="math inline">\(2a\)</span>。</p>
</li>
<li>
<p>这种阻力有这种实现方式吗？</p>
<p>有，另一种类似半隐式欧拉思想的阻力实现上，会始终利用质点在结算当前持有力后的位置来计算弹簧约束，从而确保了在与多个弹簧的相互作用后，质点相对当前弹簧的位移距离依然在约束范围内。但代价就是使原本每帧一次质点积分，变成了每次计算弹簧都要进行质点积分。</p>
</li>
</ul>
<p>那有没有一种既能实现这种半隐式欧拉的弹簧阻力，同时又不用花费精力去不断积分的方法？很幸运的是，由于我们在积分方式上埋下的伏笔，我们弹簧的每一次力计算都是基于这种半隐式欧拉的：</p>
<ol>
<li>我们是先进行质点积分，再计算力，所以质点的当前位置始终是结算了当前速度的。</li>
<li>我们的每一次力都是直接作用在位置上，所以质点的当前位置始终是考虑了力间相互作用的。</li>
</ol>
<p>所以总结下来，若已按前两步“去除迭代时间”和“优化弹力系数”，那么这一步我们什么都不用做，因为我们的质点弹簧默认就已经考虑了阻力问题。</p>
<p><em>但实际上弹簧真的需要阻力吗？放在现实里，若一个物体同时被两个弹簧拉拽，显然它应该受到两个弹簧的合力，而不是一个弹簧力会变小。因此上述这种考虑力相互作用的弹簧是非真实的，结果就是这样的弹簧在摆球实验中，不能满足能量守恒定律。不过因此换来的稳定性确实是巨大的，相比之下，显然还是这种假弹簧更适用。</em></p>
<h2 id="具体代码">具体代码</h2>
<p>下面是在 Unity 中基于上述质点弹簧模型实现的一个 Demo 的简化代码片段，你可以直观看到这种质点弹簧的实现方式，完整的代码见：<a href="https://www.cnblogs.com/BDFFZI/p/18732684" target="_blank">https://www.cnblogs.com/BDFFZI/p/18732684</a></p>
<pre><code class="language-c#">void Update()
{
    foreach (Transform point in allPoints)
    {
        Vector3 position = point.position;
        point.position += (position - lastPositions[point]);
        lastPositions[point] = position;
    }
    foreach (Spring spring in allSprings)
    {
        Transform pointA = spring.pointA;
        Transform pointB = spring.pointB;
        Vector3 positionA = pointA.position;
        Vector3 positionB = pointB.position;

        //胡克定律：弹力=弹力系数*距离*方向
        Vector3 vector = positionA - positionB;
        float distance = vector.magnitude - spring.length; //距离
        Vector3 direction = vector.normalized; //方向
        Vector3 move = elasticity * distance * direction;//弹力系数为[0,2]，无阻力时应小于1
        
        pointB.position += 0.5f * move;
        pointA.position += 0.5f * -move;
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06325735861458333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-24 14:50">2025-02-24 14:09</span>&nbsp;
<a href="https://www.cnblogs.com/BDFFZI">BDFFZI</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18733944" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18733944);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18733944', targetLink: 'https://www.cnblogs.com/BDFFZI/p/18733944', title: '【质点弹簧实现】如何做一个绝对不会崩溃的质点弹簧模型' })">举报</a>
</div>
        