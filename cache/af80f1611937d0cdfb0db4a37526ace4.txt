
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wubayue/p/18785718" title="发布于 2025-03-21 19:35">
    <span role="heading" aria-level="2">依赖注入（DI）与控制反转（IoC）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/11504/202503/11504-20250321193435881-1499266085.png" alt="依赖注入（DI）与控制反转（IoC）" class="desc_img">
        依赖注入（DI）与控制反转（IoC）可能是一些开发小伙伴耳熟但又不能详的两个词，经常看到它们的名字，但又不理解。这两个词来源于英文直译，看似高深莫测，其实非常简单，并且在一些开发场景中扮演着不可或缺的角色，比如单元测试离不开依赖注入，IoC容器是插件框架的最佳拍档等，本文尝试以最简单的方式阐述这两种思想在开发中的应用。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">



<p class="wj_title_1">导航</p>
<p class="wj_nav pl1r"><span>1</span><a href="#chapter1" rel="noopener nofollow">前言</a></p>
<p class="wj_nav pl1r"><span>2</span><a href="#chapter2" rel="noopener nofollow">什么是依赖注入与控制反转</a></p>
<p class="wj_nav pl2r"><span>2.1</span><a href="#chapter2.1" rel="noopener nofollow">控制反转</a></p>
<p class="wj_nav pl2r"><span>2.2</span><a href="#chapter2.2" rel="noopener nofollow">依赖注入</a></p>
<p class="wj_nav pl1r"><span>3</span><a href="#chapter3" rel="noopener nofollow">为什么要使用依赖注入与控制反转</a></p>
<p class="wj_nav pl2r"><span>3.1</span><a href="#chapter3.1" rel="noopener nofollow">解耦</a></p>
<p class="wj_nav pl2r"><span>3.2</span><a href="#chapter3.2" rel="noopener nofollow">单元测试</a></p>
<p class="wj_nav pl1r"><span>4</span><a href="#chapter4" rel="noopener nofollow">IoC容器</a></p>
<p class="wj_nav pl1r"><span>5</span><a href="#chapter5" rel="noopener nofollow">结束语</a></p>

<p id="chapter1" class="wj_title_1 mt0625r">1 前言</p>
<p class="wj_cont">依赖注入（DI）与控制反转（IoC）可能是一些开发小伙伴耳熟但又不能详的两个词，经常看到它们的名字，但又不理解。这两个词来源于英文直译，看似高深莫测，其实非常简单，并且在一些开发场景中扮演着不可或缺的角色，比如单元测试离不开依赖注入，IoC容器是插件框架的最佳拍档等，本文尝试以最简单的方式阐述这两种思想在开发中的应用。<a class="wj_watermark" href="https://www.wubayue.com" target="_blank" rel="noopener nofollow">文章来源：https://www.wubayue.com</a></p>
<p id="chapter2" class="wj_title_1">2 什么是依赖注入与控制反转</p>
<p id="chapter2.1" class="wj_title_2">2.1 控制反转</p>
<p class="wj_cont">在解释控制反转前，首先需要理解什么是“正转”：A依赖于B，并且A掌控B的创建销毁，此时A控制了B，即为“正转”。</p>
<p class="wj_cont">当B的创建销毁在A之外完成，B脱离了A的控制，称之为控制反转（IoC：Invertion of Control）。</p>
<pre class="wj_code"><code class="language-csharp">public class A
{
&nbsp; &nbsp; private B _b;
&nbsp; &nbsp; public A()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; // 因为A掌控B的创建，因此A控制了B，此为“正转”
&nbsp; &nbsp; &nbsp; &nbsp; _b = new B();
&nbsp; &nbsp; }
} </code></pre>
<p id="chapter2.2" class="wj_title_2">2.2 依赖注入</p>
<p class="wj_cont">对象之间的依赖不再由内部创建，而是由外部传递，称之为依赖注入（DI：Dependency Injection）。</p>
<p class="wj_cont"><span class="wj_important">控制反转是设计思想，依赖注入是实现手段。</span>两者缺一不可：</p>
<pre class="wj_code"><code class="language-csharp">public class A
{
&nbsp; &nbsp; private B _b;

&nbsp; &nbsp; // B由外部注入，称之为依赖注入
&nbsp; &nbsp; public A(B b)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; // B由外部创建，脱离了A的控制，称之为控制反转
&nbsp; &nbsp; &nbsp; &nbsp; _b = b;
&nbsp; &nbsp; }
} </code></pre>
<p class="wj_cont">如上代码示例的是构造函数注入，另一种常见的依赖注入方式是属性注入：</p>
<pre class="wj_code"><code class="language-csharp">public class A
{
&nbsp; &nbsp; public B B { get; set; }
}

void main()
{
&nbsp; &nbsp; A a = new A();
&nbsp; &nbsp; B b = new B();
&nbsp; &nbsp; // 属性注入
&nbsp; &nbsp; a.B = b;
} </code></pre>
<p id="chapter3" class="wj_title_1">3 为什么要使用依赖注入与控制反转</p>
<p id="chapter3.1" class="wj_title_2">3.1 解耦</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250316140655_126_1200.jpg" alt="高内聚低耦合" width="802" height="361" class="img-fluid" title="高内聚低耦合"></p>
<p class="wj_cont">在软件行业，有一条黄金法则叫“<span class="wj_important">高内聚，低耦合</span>”。耦合表示使用（或称为依赖），比如B使用了A，即B耦合了A，只要类的数量一多，类之间千丝万缕的耦合关系会成为巨大挑战，高内聚就是把相同的功能放在一起，这样类之间的耦合关系就会减少，通过提升内聚来减少类之间的耦合是一种常见的解耦方式。如上图，C依赖B，B依赖A，原本是两级依赖关系，通过将B中的部分功能向A内聚（前提是这部分功能原本就具有相关性），实现了B、C都依赖于A的一级依赖关系，B、C之间完成了解耦。</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250321111804_136_1200.jpg" alt="紧耦合转换为松散耦合" width="801" height="361" class="img-fluid" title="紧耦合转换为松散耦合"></p>
<p class="wj_cont">解耦除了完全消除依赖关系以外，另一种方式是将紧耦合转换为松耦合。先解释一下松紧耦合的概念，我们打开电脑机箱找到主机板上的南北桥芯片，可以看到它们是完全焊接在主板上的，这种不可替换的连接即为紧耦合；再找到内存条，发现它们可以拆卸并更换为其它品牌，这种可替换的连接即为松耦合。大部分时候，在软件设计开发时都应使用松散耦合，而依赖注入就是实现松散耦合非常好的一种方式。</p>
<p class="wj_cont">如果我们再稍思考一下，主板上的内存条为什么能安装不同的品牌？原因是有相关技术标准，比如长宽尺寸，针脚数量，通信标准等，不同的内存条厂商，只要遵循标准生产出来的内存条就能安装到同一块主板上。在软件开发中，让主板支持不同厂商的内存条称之为可扩展性，定义内存条接口标准称之为抽象，根据标准生产内存条称之为面向抽象编程（或面向接口编程）。因此为了使软件模块具备更好的扩展性，除了使用依赖注入，还应注入抽象而非具体。</p>
<p id="chapter3.2" class="wj_title_2">3.2 单元测试</p>
<p class="wj_cont">不了解单元测试的小伙伴可先阅读我的另一篇文章<a class="wj_link" href="https://www.wubayue.com/article/unit-test.html" target="_blank" rel="noopener nofollow">《单元测试从入门到精通》</a>。在单元测试中如果没有依赖注入，几乎寸步难行，通过简单的代码来示例：</p>
<p class="wj_cont">难以测试的代码：</p>
<pre class="wj_code"><code class="language-csharp">// 被测对象
public class House
{
&nbsp; &nbsp; private Bedroom _bedroom;
&nbsp; &nbsp; House()&nbsp;
&nbsp; &nbsp; {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // 内部构造协作对象，难以被测试。
&nbsp; &nbsp; &nbsp; &nbsp; _bedroom = new Bedroom();&nbsp;
&nbsp; &nbsp; }
&nbsp; &nbsp; // ...
}

// 测试用例
public void TestThisIsReallyHard()
{
&nbsp; &nbsp; House house = new House();
&nbsp; &nbsp; // 无法在测试过程中对Bedroom进行属性赋值、行为方法调用等，测试寸步难行
&nbsp; &nbsp; // ...
} </code></pre>
<p class="wj_cont">易于测试的代码：</p>
<pre class="wj_code"><code class="language-csharp">// 被测对象
public class House
{
&nbsp; &nbsp; private Bedroom _bedroom;
&nbsp; &nbsp; // 注入协作对象，可测试性好。
&nbsp; &nbsp; House(Bedroom b)&nbsp;
&nbsp; &nbsp; {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; _bedroom = b;
&nbsp; &nbsp; }
&nbsp; &nbsp; // ...
}

// 测试用例
public void TestThisIsEasyAndFlexible()
{
&nbsp; &nbsp; // Bedroom对象在掌控之中，易于测试
&nbsp; &nbsp; Bedroom bedroom = new Bedroom();
&nbsp; &nbsp; House house = new House(bedroom);
&nbsp; &nbsp; // ...
} </code></pre>
<p id="chapter4" class="wj_title_1">4 Ioc容器</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250316140654_125_1200.jpg" alt="IoC容器" width="721" height="341" class="img-fluid" title="IoC容器"></p>
<p class="wj_cont">在稍复杂的软件产品中，通常会遇到两个关于对象的问题：一是对象的数量众多，如何统一对它们进行管理，比如统一管理对象的创建销毁过程，每个对象的生命周期；二是对象之间可能存在多重复杂的依赖关系，如何对这些依赖关系进行管理，比如谁先创建谁后创建，被依赖的对象如何注入依赖对象等。</p>
<p class="wj_cont">针对如上两个问题的解决方案就是IoC容器（IoC Container），IoC容器是一个对象管理器，它统一管理对象的创建销毁过程、生命周期、依赖关系，以及提供自动注入、根据配置创建对象等一系列便捷功能。如下代码使用 <a class="wj_link" href="https://github.com/autofac/Autofac" target="_blank" rel="noopener nofollow">Autofac</a>（C#开源IoC容器）进行了简单示例：</p>
<pre class="wj_code"><code class="language-csharp">// 使用开源IoC容器Autofac
using Autofac;

namespace AutofacDemo
{
&nbsp; &nbsp; class A
&nbsp; &nbsp; { }

&nbsp; &nbsp; class B
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; A _a;
&nbsp; &nbsp; &nbsp; &nbsp; // 只需要声明需要注入的对象，由容器自动完成依赖对象的创建与注入
&nbsp; &nbsp; &nbsp; &nbsp; public B(A a)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _a = a;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp; internal class Program
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; static void Main(string[] args)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将类型注册至容器中
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ContainerBuilder builder = new ContainerBuilder();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.RegisterType&lt;A&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 设置对象的生命周期（单例模式）
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.RegisterType&lt;B&gt;().SingleInstance();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 构造IoC容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IContainer container = builder.Build();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从容器中获取对象
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B b = container.Resolve&lt;B&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
} </code></pre>
<p id="chapter5" class="wj_title_1">5 结束语</p>
<p class="wj_cont">依赖注入与控制反转的思想诞生于软件开发追求高内聚、低耦合的历史进程中，20世纪90年代末已在软件设计模式、单元测试中使用。2002年Java的Spring框架搭载IoC容器、AOP等大杀器风靡全球，DI与IoC被更多的开发者关注。直到最近的项目中涉及插件化框架，而IoC容器又是插件架构的最佳拍档，因此将其整理成文。如能给人予帮助，不甚荣幸。</p>
<p class="wj_cont">&lt;全文完&gt;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.280441673224537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 19:36">2025-03-21 19:35</span>&nbsp;
<a href="https://www.cnblogs.com/wubayue">吴八月</a>&nbsp;
阅读(<span id="post_view_count">116</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18785718" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18785718);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18785718', targetLink: 'https://www.cnblogs.com/wubayue/p/18785718', title: '依赖注入（DI）与控制反转（IoC）' })">举报</a>
</div>
        