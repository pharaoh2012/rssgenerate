
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/densen2014/p/18710286" title="发布于 2025-02-11 18:46">
    <span role="heading" aria-level="2">另辟新径实现 Blazor/MAUI 本机交互(二)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="nativeapics">NativeApi.cs</h2>
<p>内部部分类，该类提供了几个与文件操作相关的方法。</p>
<h4 id="set_config-get_config-方法">set_config(), get_config() 方法：</h4>
<pre><code>    private string PrinterNameKey = "PrinterName";
    private string printerName = "Unknown";

    public Task&lt;string&gt; set_config(string printerName)
    {
        Preferences.Set(PrinterNameKey, printerName);
        return Task.FromResult("ok");
    }

   public Task&lt;string&gt; get_config()
   {
       printerName = Preferences.Default.Get(PrinterNameKey, printerName);
       return Task.FromResult(printerName);
   }   
</code></pre>
<ul>
<li>该方法从应用程序的首选项中设置或获取打印机名称 (printerName)。<a href="https://www.cnblogs.com/densen2014/p/18710319" target="_blank">Maui 基础 - Preferences 存储和检索应用程序的首选项</a></li>
<li>使用 Preferences.Default.Get 方法获取存储的打印机名称，如果没有存储，则返回默认值。</li>
<li>返回一个包含打印机名称的任务。</li>
</ul>
<h4 id="open_file_dialog-方法">open_file_dialog() 方法：</h4>
<pre><code>   public async Task&lt;string&gt; open_file_dialog()
   {
       //work in ui thread
       var res =
       await MainThread.InvokeOnMainThreadAsync(async () =&gt;
       {
           try
           {
               var result = await FilePicker.Default.PickAsync(new PickOptions());
               if (result == null)
               {
                   return "";
               }
               using var stream = await result.OpenReadAsync();
               StreamReader reader = new StreamReader(stream);
               return Convert.ToBase64String(Encoding.UTF8.GetBytes(reader.ReadToEnd()));
           }
           catch (Exception e)
           {
               var err = e.Message;
               return err;
           }
       });
       return res;
   }   
</code></pre>
<ul>
<li>该方法在 UI 线程上运行，打开文件选择对话框。</li>
<li>使用 FilePicker.Default.PickAsync 方法打开文件选择器。</li>
<li>如果用户没有选择文件，返回空字符串。</li>
<li>如果选择了文件，读取文件内容并将其转换为 Base64 编码的字符串。</li>
<li>如果发生异常，返回异常消息。</li>
</ul>
<h4 id="save_filestring-data-string-filename-方法">save_file(string data, string fileName) 方法：</h4>
<pre><code>   public async Task&lt;string&gt; save_file(string data, string fileName)
   {
       try
       {
           string targetFile = System.IO.Path.Combine(FileSystem.Current.AppDataDirectory, fileName);

           using FileStream outputStream = File.OpenWrite(targetFile);
           using StreamWriter streamWriter = new(outputStream);

           await streamWriter.WriteAsync(data);
           return $"file path:{targetFile.Replace("\\","\\\\")}";
       }
       catch (Exception e)
       {
           var err = e.Message;
           return err;
       }
    }
</code></pre>
<ul>
<li>该方法将给定的数据保存到指定文件名的文件中。</li>
<li>使用 Path.Combine 方法构建目标文件路径，该路径位于应用程序的数据目录中。</li>
<li>使用 File.OpenWrite 方法打开文件流，并使用 StreamWriter 写入数据。</li>
<li>写入完成后，返回文件路径。</li>
<li>如果发生异常，返回异常消息。</li>
</ul>
<p>这些方法提供了基本的文件操作功能，包括获取配置、打开文件对话框和保存文件</p>
<h4 id="如何在-preferences-中存储自定义对象">如何在 Preferences 中存储自定义对象？</h4>
<p><a href="https://www.cnblogs.com/densen2014/p/18710319" target="_blank">Maui 基础 - Preferences 存储和检索应用程序的首选项</a></p>
<h3 id="完整代码">完整代码</h3>
<pre><code>using System.Text;
using System.Text.Json;

namespace MauiBridge;

internal partial class NativeApi : object
{
    private string PrinterNameKey = "PrinterName";
    private string printerName = "Unknown";

    /// &lt;summary&gt;
    /// 从应用程序的首选项中获取打印机名称 (printerName)
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public Task&lt;string&gt; get_config()
    {
        printerName = Preferences.Default.Get(PrinterNameKey, printerName);
        return Task.FromResult(printerName);
    }

    /// &lt;summary&gt;
    /// 打开文件选择对话框,读取文件内容并将其转换为 Base64 编码的字符串返回
    /// &lt;/summary&gt;
    /// &lt;returns&gt;文件内容 Base64 编码的字符串&lt;/returns&gt;
    public async Task&lt;string&gt; open_file_dialog()
    {
        //work in ui thread
        var res =
        await MainThread.InvokeOnMainThreadAsync(async () =&gt;
        {
            try
            {
                var result = await FilePicker.Default.PickAsync(new PickOptions());
                if (result == null)
                {
                    return "";
                }
                using var stream = await result.OpenReadAsync();
                StreamReader reader = new StreamReader(stream);
                return Convert.ToBase64String(Encoding.UTF8.GetBytes(reader.ReadToEnd()));
            }
            catch (Exception e)
            {
                var err = e.Message;
                return err;
            }
        });
        return res;
    }

    /// &lt;summary&gt;
    /// 将给定的数据保存到指定文件名的文件,返回文件路径
    /// &lt;/summary&gt;
    /// &lt;param name="data"&gt;&lt;/param&gt;
    /// &lt;param name="fileName"&gt;&lt;/param&gt;
    /// &lt;returns&gt;文件路径&lt;/returns&gt;
    public async Task&lt;string&gt; save_file(string data, string fileName)
    {
        try
        {
            string targetFile = System.IO.Path.Combine(FileSystem.Current.AppDataDirectory, fileName);

            using FileStream outputStream = File.OpenWrite(targetFile);
            using StreamWriter streamWriter = new(outputStream);

            await streamWriter.WriteAsync(data);
            return $"file path:{targetFile.Replace("\\", "\\\\")}";
        }
        catch (Exception e)
        {
            var err = e.Message;
            return err;
        }
    }

    /// &lt;summary&gt;
    /// 存储自定义对象 User, 将自定义对象序列化为 string 类型，然后再存储
    /// &lt;/summary&gt;
    /// &lt;param name="user"&gt;&lt;/param&gt;
    public void SaveUser(User user)
    {
        string jsonString = JsonSerializer.Serialize(user);
        Preferences.Set("user", jsonString);
    }

    /// &lt;summary&gt;
    /// 检索自定义对象 User, 从 Preferences 中检索字符串，然后将其反序列化为自定义对象
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public User? GetUser()
    {
        string jsonString = Preferences.Get("user", string.Empty);
        if (string.IsNullOrEmpty(jsonString))
        {
            return null;
        }
        return JsonSerializer.Deserialize&lt;User&gt;(jsonString);
    }

}

/// &lt;summary&gt;
/// 在 Preferences 中存储自定义对象, https://www.cnblogs.com/densen2014/p/18710319
/// &lt;/summary&gt;
public class User
{
    public string? Name { get; set; }
    public int Age { get; set; }
}

</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <h4 id="关联项目">关联项目</h4>
<p><font color="blue">FreeSql QQ群：4336577</font></p>
<p><font color="blue">BA &amp; Blazor QQ群：795206915</font></p>
<p><font color="blue">Maui Blazor 中文社区 QQ群：645660665</font></p>
<h4 id="知识共享许可协议">知识共享许可协议</h4>
<p>本作品采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但务必保留文章署名AlexChow（包含链接： <a href="https://github.com/densen2014" target="_blank" rel="noopener">https://github.com/densen2014</a> ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请<a href="zhouchuanglin@gmail.com" target="_blank" rel="noopener">与我联系</a> 。</p>
<h4 id="转载声明">转载声明</h4>
<p>本文来自博客园，作者：周创琳 <a href="https://www.cnblogs.com/densen2014/" target="_blank">AlexChow</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/densen2014/p/18710286" target="_blank">https://www.cnblogs.com/densen2014/p/18710286</a></p>
<h4 id="alexchow">AlexChow</h4>
<p><a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAGMBzlmgJx0rytwH08AEEY8F0wIVXB2soJXXdUP3ohAE/?" target="_blank" rel="noopener">今日头条</a> | <a href="https://www.cnblogs.com/densen2014" target="_blank" rel="noopener">博客园</a> | <a href="https://www.zhihu.com/people/alex-chow-54" target="_blank" rel="noopener">知乎</a> | <a href="https://gitee.com/densen2014" target="_blank" rel="noopener">Gitee</a> | <a href="https://github.com/densen2014?WT.mc_id=DT-MVP-5005078" target="_blank" rel="noopener">GitHub</a></p>

<p><img src="https://img2023.cnblogs.com/blog/1980213/202302/1980213-20230201233143321-1727894703.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.32968171161921295" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 20:20">2025-02-11 18:46</span>&nbsp;
<a href="https://www.cnblogs.com/densen2014">AlexChow</a>&nbsp;
阅读(<span id="post_view_count">44</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710286" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710286);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710286', targetLink: 'https://www.cnblogs.com/densen2014/p/18710286', title: '另辟新径实现 Blazor/MAUI 本机交互(二)' })">举报</a>
</div>
        