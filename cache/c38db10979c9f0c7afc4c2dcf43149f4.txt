
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vstral/p/19038748" title="发布于 2025-08-14 23:23">
    <span role="heading" aria-level="2">BFS 广度优先搜索算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="bfs-广度搜索算法">BFS 广度搜索算法</h2>
<p>BFS主要使用对图的遍历，通过队列的逐层扩展，按层次搜索所有可能的节点，确保找到最短的路径（无权图），BFS的本质是对图的暴力穷举，适合解决一些寻路的问题，比如找迷宫的最短路径</p>
<h3 id="核心机制">核心机制</h3>
<p>使用队列驱动，时间复杂度通常为O(N)，N为状态数。空间复杂度为O(N)，储存所有当前层节点。</p>
<ol>
<li>初始化：标记地图和障碍物，标记已经访问过的节点</li>
<li>循环处理：从队列的头节点来遍历之下的相邻位置</li>
<li>当队列为空遍历结束/找到终点</li>
</ol>
<p>特点：使用队列（FIFO）保证操作顺序</p>
<h3 id="优化及其变种">优化及其变种</h3>
<ul>
<li>双向BFS（bidirectional BFS）：从起点和终端同时进行BFS，相遇时停下</li>
<li>A*搜索：结合BFS和启发式函数，优先搜索更接近目标的节点</li>
</ul>
<h3 id="示例">示例：</h3>
<ul>
<li>问题：
<ul>
<li>给定一个&nbsp;<code>N x M</code>&nbsp;的二维矩阵表示迷宫</li>
<li>
<ul>
<li><code>0</code>&nbsp;表示可以通行的空地。</li>
</ul>
</li>
<li><code>1</code>&nbsp;表示障碍物，不可通行。</li>
<li>起点为&nbsp;<code>(0, 0)</code>，终点为&nbsp;<code>(N-1, M-1)</code>。</li>
<li>每次移动可以向上、下、左、右四个方向行走一格，求从起点到终点的<strong>最短路径步数</strong>。如果无法到达终点，返回&nbsp;<code>-1</code>。</li>
</ul>
</li>
</ul>
<h4 id="步骤">步骤</h4>
<ol>
<li>初始化地图 标记数组 方向数组：</li>
</ol>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int maze[4][4] = {

&nbsp; &nbsp; {0, 0, 0, 0},

&nbsp; &nbsp; {1, 1, 0, 1},

&nbsp; &nbsp; {0, 0, 0, 0},

&nbsp; &nbsp; {0, 1, 1, 0}

};
int visited[4][4];

struct point {

&nbsp; &nbsp; int x;

&nbsp; &nbsp; int y;

&nbsp; &nbsp; int step;

&nbsp; &nbsp; queue&lt;point&gt; backpoint;

};

int dx[4] = {0, 0, -1, 1}; // 上 下 左 右

int dy[4] = {-1, 1, 0, 0};

queue&lt;point&gt; r;

int main() {

&nbsp; &nbsp; int n = 3,m = 3;

&nbsp; &nbsp; int startx = 0, starty = 0; // 起点位置

&nbsp; &nbsp; int endx = 3, endy = 3;

}
</code></pre>
<ol start="2">
<li>初始化队列</li>
</ol>
<pre><code class="language-cpp">	point p;

&nbsp; &nbsp; p.x = startx;

&nbsp; &nbsp; p.y = starty;

&nbsp; &nbsp; p.step = 0;

&nbsp; &nbsp; visited[startx][starty] = 1;

  

&nbsp; &nbsp; r.push(p);

  

&nbsp; &nbsp; while(!r.empty()) {

&nbsp; &nbsp; &nbsp; &nbsp; if (r.front().x == endx &amp;&amp; r.front().y == endy) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("到达终点，坐标(%d, %d), 共%d步\n", r.front().x, r.front().y, r.front().step);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;

&nbsp; &nbsp; }
</code></pre>
<ol start="3">
<li>访问头节点附近节点</li>
</ol>
<pre><code class="language-cpp">&nbsp;for (int i = 0; i &lt; 4; i++) {

&nbsp; &nbsp; &nbsp; &nbsp; point temp;

&nbsp; &nbsp; &nbsp; &nbsp; int tx = r.front().x + dx[i];

&nbsp; &nbsp; &nbsp; &nbsp; int ty = r.front().y + dy[i];

&nbsp; &nbsp; &nbsp; &nbsp; if (tx &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; m &amp;&amp; maze[tx][ty] == 0 &amp;&amp; visited[tx][ty] == 0) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.x = tx;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.y = ty;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.step = r.front().step + 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.backpoint = r.front().backpoint;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visited[tx][ty] = 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r.push(temp);

&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; }

&nbsp; &nbsp; r.pop();
</code></pre>
<p>到达终点，坐标(3, 3), 共6步</p>
<h3 id="通过队列回溯输出路径">通过队列回溯输出路径</h3>
<p>定义一个parent来记录每一次的前驱节点坐标，注意要初始化起始点的前驱</p>
<pre><code class="language-cpp">pair&lt;int, int&gt; parent[4][4]; // 记录前驱节点

void printPath(int endX, int endY) {

&nbsp; &nbsp; vector&lt;pair&lt;int, int&gt;&gt; path;

&nbsp; &nbsp; int x = endX, y = endY;

&nbsp; &nbsp; // 从终点回溯到起点

&nbsp; &nbsp; while (x != -1 &amp;&amp; y != -1) {

&nbsp; &nbsp; &nbsp; &nbsp; path.push_back({x, y});

&nbsp; &nbsp; &nbsp; &nbsp; auto p = parent[x][y];

&nbsp; &nbsp; &nbsp; &nbsp; x = p.first;

&nbsp; &nbsp; &nbsp; &nbsp; y = p.second;

&nbsp; &nbsp; }

&nbsp; &nbsp; // 逆序输出路径

&nbsp; &nbsp; reverse(path.begin(), path.end());

&nbsp; &nbsp; cout &lt;&lt; "最短路径：" &lt;&lt; endl;

&nbsp; &nbsp; for (auto p : path) {

&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ") ";

&nbsp; &nbsp; }

&nbsp; &nbsp; cout &lt;&lt; endl;

}



</code></pre>
<h4 id="完整代码">完整代码：</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

  

int maze[4][4] = {

&nbsp; &nbsp; {0, 0, 0, 0},

&nbsp; &nbsp; {1, 1, 0, 1},

&nbsp; &nbsp; {0, 0, 0, 0},

&nbsp; &nbsp; {0, 1, 1, 0}

};

  

int visited[4][4];

  

struct point {

&nbsp; &nbsp; int x;

&nbsp; &nbsp; int y;

&nbsp; &nbsp; int step;

};

  

int dx[4] = {0, 0, -1, 1}; // 上 下 左 右

int dy[4] = {-1, 1, 0, 0};

  

queue&lt;point&gt; r;

pair&lt;int, int&gt; parent[4][4]; // 记录前驱节点

  

int flag = 0;

  

void printPath(int endX, int endY) {

&nbsp; &nbsp; vector&lt;pair&lt;int, int&gt;&gt; path;

&nbsp; &nbsp; int x = endX, y = endY;

&nbsp; &nbsp; // 从终点回溯到起点

&nbsp; &nbsp; while (x != -1 &amp;&amp; y != -1) {

&nbsp; &nbsp; &nbsp; &nbsp; path.push_back({x, y});

&nbsp; &nbsp; &nbsp; &nbsp; auto p = parent[x][y];

&nbsp; &nbsp; &nbsp; &nbsp; x = p.first;

&nbsp; &nbsp; &nbsp; &nbsp; y = p.second;

&nbsp; &nbsp; }

&nbsp; &nbsp; // 逆序输出路径

&nbsp; &nbsp; reverse(path.begin(), path.end());

&nbsp; &nbsp; cout &lt;&lt; "最短路径：" &lt;&lt; endl;

&nbsp; &nbsp; for (auto p : path) {

&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ") ";

&nbsp; &nbsp; }

&nbsp; &nbsp; cout &lt;&lt; endl;

}

  

int main() {

&nbsp; &nbsp; int n = 4,m = 4;

&nbsp; &nbsp; int startx = 0, starty = 0; // 起点位置

&nbsp; &nbsp; int endx = 3, endy = 3;

  

&nbsp; &nbsp; point p;

&nbsp; &nbsp; p.x = startx;

&nbsp; &nbsp; p.y = starty;

&nbsp; &nbsp; p.step = 0;

&nbsp; &nbsp; visited[startx][starty] = 1;

&nbsp; &nbsp; parent[startx][starty] = {-1, -1}; // 起点无前驱

  

&nbsp; &nbsp; r.push(p);

  

&nbsp; &nbsp; while(!r.empty()) {

&nbsp; &nbsp; &nbsp; &nbsp; if (r.front().x == endx &amp;&amp; r.front().y == endy) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("到达终点，坐标(%d, %d), 共%d步\n", r.front().x, r.front().y, r.front().step);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag = 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;

&nbsp; &nbsp; }

  

&nbsp; &nbsp; for (int i = 0; i &lt; 4; i++) {

&nbsp; &nbsp; &nbsp; &nbsp; point temp;

&nbsp; &nbsp; &nbsp; &nbsp; int tx = r.front().x + dx[i];

&nbsp; &nbsp; &nbsp; &nbsp; int ty = r.front().y + dy[i];

&nbsp; &nbsp; &nbsp; &nbsp; if (tx &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; m &amp;&amp; maze[tx][ty] == 0 &amp;&amp; visited[tx][ty] == 0) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.x = tx;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.y = ty;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.step = r.front().step + 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visited[tx][ty] = 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent[tx][ty] = {r.front().x, r.front().y}; // 记录前驱

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r.push(temp);

&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; }

&nbsp; &nbsp; r.pop();

}

  

if (flag == 1) {

&nbsp; &nbsp; printPath(endx, endy);

}

  
  

if (flag == 0) puts("无法到达目标");

return 0;

  
  

}
</code></pre>
<h3 id="应用">应用</h3>
<p>用一个ctf逆向题来学习这个算法：</p>
<p>使用c++的队列来处理，先完成一次寻路，到达终点后再回溯最短路径</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

  

int maps[58][58] = {{1,0,1}}; //省略地图
  

int visited[60][60] = {0};

struct point {

&nbsp; &nbsp; int x;

&nbsp; &nbsp; int y;

&nbsp; &nbsp; int step;

&nbsp; &nbsp; vector&lt;pair&lt;int, int&gt;&gt; path;

};

int dx[4] = {0, 0, -1, 1}; // 上 下 左 右

int dy[4] = {-1, 1, 0, 0};

queue&lt;point&gt; r;

string path1 = "S";

int main() {

&nbsp; &nbsp; int n = 56, m = 56; &nbsp;// 实际地图大小

&nbsp; &nbsp; int startx = 1, starty = 1;

&nbsp; &nbsp; int endx = 15, endy = 32;

&nbsp; &nbsp; // 检查起始点和终点

&nbsp; &nbsp; if (maps[startx][starty] != 0) {

&nbsp; &nbsp; &nbsp; &nbsp; printf("起始点不可通行！起始点值：%d\n", maps[startx][starty]);

&nbsp; &nbsp; &nbsp; &nbsp; return 0;

&nbsp; &nbsp; }

&nbsp; &nbsp; if (maps[endx][endy] != 0) {

&nbsp; &nbsp; &nbsp; &nbsp; printf("终点不可通行！终点值：%d\n", maps[endx][endy]);

&nbsp; &nbsp; &nbsp; &nbsp; return 0;

&nbsp; &nbsp; }

&nbsp; &nbsp; printf("起始点：(%d,%d)，终点：(%d,%d)\n", startx, starty, endx, endy);

&nbsp; &nbsp; point p;

&nbsp; &nbsp; p.x = startx;

&nbsp; &nbsp; p.y = starty;

&nbsp; &nbsp; p.step = 0;

&nbsp; &nbsp; visited[startx][starty] = 1;

&nbsp; &nbsp; r.push(p);

&nbsp; &nbsp; while (!r.empty()) {

&nbsp; &nbsp; &nbsp; &nbsp; point current = r.front();

&nbsp; &nbsp; &nbsp; &nbsp; int x = r.front().x, y = r.front().y;

&nbsp; &nbsp; &nbsp; &nbsp; // 判断是否到达终点

&nbsp; &nbsp; &nbsp; &nbsp; if (x == endx &amp;&amp; y == endy) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("到达终点，共%d步\n", r.front().step);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; current.path.size(); i++) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("第%d步: (%d, %d)", i+1, current.path[i].first, current.path[i].second);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i &gt; 0) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int dx = current.path[i].first - current.path[i-1].first;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int dy = current.path[i].second - current.path[i-1].second;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (dx == -1) printf(" [从(%d,%d)向上移动]", current.path[i-1].first, current.path[i-1].second), path1 += "W";

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (dx == 1) printf(" [从(%d,%d)向下移动]", current.path[i-1].first, current.path[i-1].second), path1 += "S";

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (dy == -1) printf(" [从(%d,%d)向左移动]", current.path[i-1].first, current.path[i-1].second), path1 += "A";

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (dy == 1) printf(" [从(%d,%d)向右移动]", current.path[i-1].first, current.path[i-1].second), path1 += "D";

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");

&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; "结果为：" &lt;&lt; path1 &lt;&lt; '\n';

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;

&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; 4; j++) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int tx = x + dx[j];

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ty = y + dy[j];

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 修正边界检查和通行条件

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &lt; m &amp;&amp;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maps[tx][ty] == 0 &amp;&amp; visited[tx][ty] == 0) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; point temp;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.x = tx;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.y = ty;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.step = current.step + 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.path = current.path; &nbsp;// 复制当前路径

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.path.push_back({tx, ty}); &nbsp;// 添加新位置

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r.push(temp);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visited[tx][ty] = 1;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; r.pop();

&nbsp; &nbsp; }

&nbsp; &nbsp; puts("未找到结果！");

&nbsp; &nbsp; return 0;

}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vstral/" target="_blank">vstral</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/vstral/p/19038748" target="_blank">https://www.cnblogs.com/vstral/p/19038748</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-14 23:23">2025-08-14 23:23</span>&nbsp;
<a href="https://www.cnblogs.com/vstral">vstral</a>&nbsp;
阅读(<span id="post_view_count">178</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19038748);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19038748', targetLink: 'https://www.cnblogs.com/vstral/p/19038748', title: 'BFS 广度优先搜索算法' })">举报</a>
</div>
        