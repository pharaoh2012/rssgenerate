
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18753005" title="发布于 2025-03-05 16:55">
    <span role="heading" aria-level="2">『Python底层原理』--异步机制（async/await）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在现代编程中，<strong>并发</strong>是提高程序效率的关键技术之一，它允许程序同时执行多个任务，充分利用系统资源。</p>
<p>本文将深入探讨 <code>Python</code> 中的<code>async/await</code>机制，从并发编程基础讲起，逐步剖析其工作原理和实现方式。</p>
<h1 id="1-并发编程基础">1. 并发编程基础</h1>
<p>计算机程序的执行方式主要有两种：<strong>顺序执行</strong>和<strong>并发执行</strong>。</p>
<p><strong>顺序执行</strong>是按代码顺序逐条运行，而并发执行则允许同时运行多个任务。</p>
<p><strong>并发</strong>又分为<strong>并发</strong>（<code>concurrency</code>）和<strong>并行</strong>（<code>parallelism</code>），<strong>并发</strong>是指多个任务同时进行，但不一定同时运行；<strong>并行</strong>则是多个任务同时运行，通常需要多核处理器支持。</p>
<p>假设有3个任务，每个任务有若干步骤，每个任务情况如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250305165435008-1042083457.png" alt="" loading="lazy"></p>
<p><strong>顺序执行</strong>的情况如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250305165435161-2120779567.png" alt="" loading="lazy"></p>
<p><strong>并发</strong>（<code>concurrency</code>）执行的情况如下，三个任务交替执行，感觉像是同时在运行。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250305165435009-995586753.png" alt="" loading="lazy"></p>
<p><strong>并行</strong>（<code>parallelism</code>）执行的情况如下，三个任务同时运行。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250305165435153-1715290578.png" alt="" loading="lazy"></p>
<p>不同的编程语言对并发编程的支持各有不同。</p>
<p><code>Python</code> 通过 <code>GIL</code>（全局解释器锁）限制了多线程的并行能力，但提供了多种并发编程方式，如线程、多进程、事件循环等，这些方式各有优缺点，适用于不同的场景。</p>
<h1 id="2-asyncawait-语法">2. async/await 语法</h1>
<p>从<code>Python 3.5</code>开始，引入了一种新的异步编程语法<code>async/await</code>，用于简化异步操作的编写。</p>
<p>它基于生成器和事件循环，使得异步代码更加直观和易于理解。</p>
<p>其中，<code>async</code>关键字用于定义一个异步函数。</p>
<p>当一个函数被定义为<code>async</code>时，它会返回一个<strong>协程</strong>对象。</p>
<p><strong>协程</strong>是一种特殊的函数，它可以在执行过程中暂停和恢复，非常适合处理<code> I/O</code> 密集型任务。</p>
<p>比如：</p>
<pre><code class="language-python">async def fetch_data():
    await asyncio.sleep(2)  # 模拟异步操作
    return "Data fetched"
</code></pre>
<p>调用<code>async</code>函数时，不会立即执行函数体，而是返回一个协程对象。要运行协程，需要将其提交到事件循环中。</p>
<p><code>await</code>关键字用于暂停当前协程的执行，等待一个可等待对象（如协程、Future 或 Task）完成。</p>
<p><code>await</code>后面的表达式必须是一个可等待对象，否则会抛出<code>TypeError</code>。</p>
<p>比如：</p>
<pre><code class="language-python">async def main():
    result = await fetch_data()  # 暂停 main，直到 fetch_data 完成
    print(result)
</code></pre>
<p>当遇到<code>await</code>时，当前协程会暂停执行，并将控制权交还给事件循环。</p>
<p>事件循环会继续执行其他任务，直到<code>await</code>的异步操作完成。</p>
<h2 id="21-执行流程">2.1. 执行流程</h2>
<p><code>async/await</code>的执行流程一般分为3步：</p>
<ol>
<li><strong>协程的启动</strong>：调用async函数会返回一个协程对象，要执行这个协程，需要将其提交给事件循环，比如通过<code>asyncio.run()</code>或<code>loop.run_until_complete()</code>方法。</li>
<li><strong>暂停与恢复</strong>：当协程遇到 <code>await</code> 时，它会暂停并将控制权交给事件循环。事件循环接着执行其他任务，直到 <code>await</code> 的操作完成，然后恢复该协程的执行。</li>
<li><strong>异常处理</strong>：<code>async/await</code>支持在协程中使用<code>try/except</code>捕获异常，这使得错误处理更加直观和方便。</li>
</ol>
<pre><code class="language-python">async def risky_task():
    raise ValueError("Something went wrong")

async def main():
    try:
        await risky_task()
    except ValueError as e:
        print(f"Caught an exception: {e}")
</code></pre>
<h2 id="22-asyncawait的优势">2.2. async/await的优势</h2>
<p>其实不用<code>async/await</code>的语法，也可以实现异步，<code>Python</code>引入这个语法的主要是因为可以带来一下的好处：</p>
<ol>
<li><strong>代码简洁易读</strong>：<code>async/await</code>使得异步代码更加接近同步代码，避免了回调地狱和复杂的链式调用</li>
<li><strong>错误处理方便</strong>： 使用<code>try/except</code>可以直接捕获协程中的异常，而无需在每个异步操作中处理错误</li>
<li><strong>性能优化</strong>：<code>async/await</code>基于事件循环和协程，避免了线程切换的开销，适合处理大量 <code>I/O</code> 密集型任务</li>
</ol>
<h2 id="23-基于asyncawait的服务器实现">2.3. 基于async/await的服务器实现</h2>
<p>以下是使用<code>async/await</code>和<code>asyncio</code>实现的 <code>TCP Echo</code> 服务器代码。</p>
<p>与<code>async/await</code>之前的<code>Python</code>语法相比，代码更加简洁易读。</p>
<pre><code class="language-python">import asyncio

async def echo_handler(reader, writer):
    addr = writer.get_extra_info("peername")
    print(f"Connected from {addr}")
    while True:
        data = await reader.read(1024)  # 非阻塞读取数据
        if not data:
            break
        writer.write(data)  # 非阻塞写入数据
        await writer.drain()  # 等待数据发送完成
    writer.close()
    print(f"Connection closed from {addr}")

async def run_server():
    server = await asyncio.start_server(echo_handler, "127.0.0.1", 8080)
    async with server:
        await server.serve_forever()

if __name__ == "__main__":
    asyncio.run(run_server())

</code></pre>
<h1 id="3-asyncio-库">3. asyncio 库</h1>
<p><code>async/await</code>只是<code>Python</code>语言层面的特性，而<code>asyncio</code>是<code>Python</code>的标准异步编程库，提供了一套完整的工具和接口，用于构建异步应用程序。</p>
<p><code>asyncio</code>的核心功能围绕事件循环展开，通过事件循环，<code>asyncio</code>能够高效地管理并发任务，实现 <code>I/O</code> 操作的异步执行。</p>
<p>它的主要功能和组件包括：</p>
<h2 id="31-事件循环event-loop">3.1. 事件循环（Event Loop）</h2>
<p><strong>事件循环</strong>是<code>asyncio</code>的核心，它负责调度和管理异步任务。</p>
<p><strong>事件循环</strong>的主要职责包括：</p>
<ol>
<li><strong>任务调度</strong>：事件循环会跟踪所有注册的任务，并根据任务的状态（如等待 I/O 操作或定时器到期）调度它们的执行。</li>
<li><strong>I/O 多路复用</strong>：通过底层的 I/O 多路复用机制（如<code>select</code>、<code>epoll</code>或<code>kqueue</code>），事件循环能够高效地处理多个并发的 I/O 操作。</li>
<li><strong>异步任务的生命周期管理</strong>：事件循环负责启动、暂停、恢复和取消异步任务。</li>
</ol>
<p>在 <code>Python</code> 中，可以通过<code>asyncio.get_event_loop()</code>获取当前的事件循环，或者使用<code>asyncio.run()</code>启动一个新的事件循环。</p>
<h2 id="32-协程coroutines">3.2. 协程（Coroutines）</h2>
<p>协程是<code>asyncio</code>的基本执行单元，它通过<code>async</code>和<code>await</code>关键字定义。</p>
<p>协程可以暂停和恢复执行，非常适合处理 I/O 密集型任务。</p>
<p>以下是一个简单的协程示例：</p>
<pre><code class="language-python">async def fetch_data():
    await asyncio.sleep(2)  # 模拟异步 I/O 操作
    return "Data fetched"

async def main():
    result = await fetch_data()
    print(result)

asyncio.run(main())
</code></pre>
<p>在<code>asyncio</code>中，协程通过事件循环进行调度。</p>
<p>当遇到<code>await</code>时，当前协程会暂停执行，事件循环会继续处理其他任务，直到<code>await</code>的异步操作完成。</p>
<h2 id="33-任务tasks">3.3. 任务（Tasks）</h2>
<p><strong>任务</strong>是协程的封装，它允许对协程进行更细粒度的控制，<strong>任务</strong>可以被取消、等待或加入到任务组中。</p>
<p>以下是一个使用<strong>任务</strong>的示例：</p>
<pre><code class="language-python">async def worker(name, delay):
    await asyncio.sleep(delay)
    print(f"Worker {name} completed")

async def main():
    task1 = asyncio.create_task(worker("A", 2))
    task2 = asyncio.create_task(worker("B", 3))
    await task1
    await task2

asyncio.run(main())
</code></pre>
<p>在<code>asyncio</code>中，<strong>任务</strong>是通过<code>asyncio.create_task()</code>创建的。<strong>任务</strong>可以被加入到任务组中，以便并行执行多个任务。</p>
<h2 id="34-future-对象">3.4. Future 对象</h2>
<p><code>Future</code>是一个表示异步操作结果的对象。</p>
<p>它通常用于低层次的异步编程，例如在回调函数中处理异步操作的结果。</p>
<p><code>Future</code>对象可以通过<code>set_result()</code>或<code>set_exception()</code>设置结果或异常。</p>
<pre><code class="language-python">async def main():
    loop = asyncio.get_running_loop()
    future = loop.create_future()
    loop.call_soon(future.set_result, "Hello, Future!")
    result = await future
    print(result)

asyncio.run(main())
</code></pre>
<p>在<code>asyncio</code>中，<code>Future</code>对象通常用于与底层事件循环交互，而协程和任务则更常用于高层的异步编程。</p>
<h2 id="35-回调管理">3.5. 回调管理</h2>
<p><code>asyncio</code>提供了强大的<strong>回调管理</strong>功能，允许在特定事件发生时执行回调函数。</p>
<p>例如，可以通过<code>loop.call_soon()</code>或<code>loop.call_later()</code>将回调函数加入到事件循环中。</p>
<pre><code class="language-python">async def main():
    loop = asyncio.get_running_loop()
    loop.call_soon(lambda: print("Callback executed immediately"))
    loop.call_later(2, lambda: print("Callback executed after 2 seconds"))
    await asyncio.sleep(3)  # 等待足够的时间以触发回调

asyncio.run(main())
</code></pre>
<p><strong>回调管理</strong>是<code>asyncio</code>的一个重要特性，它允许开发者在事件循环中插入自定义的逻辑。</p>
<h2 id="36-优势与局限性">3.6. 优势与局限性</h2>
<p><code>asyncio</code>的优势非常明显：</p>
<ol>
<li><strong>高性能</strong>：<code>asyncio</code>基于单线程事件循环，避免了线程切换的开销，适合处理大量并发的<code> I/O</code> 密集型任务</li>
<li><strong>简洁易读</strong>：<code>async/await</code>语法使得异步代码更加接近同步代码，易于理解和维护</li>
<li><strong>强大的功能</strong>：<code>asyncio</code>提供了丰富的功能，包括任务调度、回调管理、异步网络通信等</li>
</ol>
<p>不过，它的局限性也不能忽视：</p>
<ol>
<li><strong>CPU密集型任务的限制</strong>：由于<code>asyncio</code>基于<strong>单线程</strong>事件循环，它不适合处理 <strong>CPU 密集型</strong>任务。对于这类任务，建议使用多进程或其他并发模型</li>
<li><strong>兼容性问题</strong>：<code>asyncio</code>的某些功能可能与传统的同步代码不兼容，需要开发者进行适当的适配</li>
<li><strong>调试复杂性</strong>：虽然<code>asyncio</code>提供了强大的异步编程能力，但调试异步代码可能比调试同步代码更复杂</li>
</ol>
<h1 id="4-总结">4. 总结</h1>
<p><code>async/await</code>模式是<code>Python</code>中一种高效的并发编程方式。</p>
<p>它结合了生成器和事件循环的优点，提供了简洁易读的代码。</p>
<p>然而，它也有缺点，例如对 <code>CPU-bound</code> 任务支持不足，除了<code>async/await</code>，<code>Python</code> 还有其他并发编程模型，如多进程、线程池等。</p>
<p>此外，也介绍了<code>asyncio</code>库，它也在不断改进和扩展。</p>
<p>例如，<code>Python 3.10</code> 引入了<code>asyncio.run()</code>的改进版本，使得异步程序的启动更加简洁。</p>
<p>并且<code>asyncio</code>也在不断优化其性能和兼容性，以更好地支持现代异步应用的开发。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.39253128202314813" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-05 16:56">2025-03-05 16:55</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">34</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18753005" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18753005);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18753005', targetLink: 'https://www.cnblogs.com/wang_yb/p/18753005', title: '『Python底层原理』--异步机制（async/await）' })">举报</a>
</div>
        