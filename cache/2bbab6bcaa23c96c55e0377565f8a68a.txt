
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18947950" title="发布于 2025-06-25 14:32">
    <span role="heading" aria-level="2">Java源码分析系列笔记-9.CountDownLatch</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-如何使用" rel="noopener nofollow">2. 如何使用</a><ul><li><a href="#21-countdownlatch-vs-cyclicbarrier" rel="noopener nofollow">2.1. CountDownLatch VS CyclicBarrier</a></li></ul></li><li><a href="#3-uml" rel="noopener nofollow">3. uml</a></li><li><a href="#4-构造方法" rel="noopener nofollow">4. 构造方法</a><ul><li><a href="#41-syncaqs子类" rel="noopener nofollow">4.1. Sync【AQS子类】</a></li></ul></li><li><a href="#5-countdown方法" rel="noopener nofollow">5. countDown方法</a><ul><li><a href="#51-使用aqs释放锁" rel="noopener nofollow">5.1. 使用AQS释放锁</a><ul><li><a href="#511-尝试释放锁" rel="noopener nofollow">5.1.1. 尝试释放锁</a></li><li><a href="#512-所有锁释放成功后移除aqs队列中signal的节点并一个个唤醒" rel="noopener nofollow">5.1.2. 所有锁释放成功后，移除AQS队列中SIGNAL的节点，并一个个唤醒</a><ul><li><a href="#5121-把头节点从aqs队列中移除" rel="noopener nofollow">5.1.2.1. 把头节点从AQS队列中移除</a></li></ul></li></ul></li></ul></li><li><a href="#6-await方法" rel="noopener nofollow">6. await方法</a><ul><li><a href="#61-使用aqs加锁" rel="noopener nofollow">6.1. 使用AQS加锁</a><ul><li><a href="#611-判断是否需要加锁" rel="noopener nofollow">6.1.1. 判断是否需要加锁</a></li><li><a href="#612-需要加锁那么加入aqs队列阻塞等待其他线程执行完" rel="noopener nofollow">6.1.2. 需要加锁，那么加入AQS队列阻塞等待其他线程执行完</a><ul><li><a href="#6121-构造节点加入aqs队列" rel="noopener nofollow">6.1.2.1. 构造节点加入AQS队列</a></li><li><a href="#6122-判断是否需要阻塞" rel="noopener nofollow">6.1.2.2. 判断是否需要阻塞</a></li><li><a href="#6123-真正阻塞" rel="noopener nofollow">6.1.2.3. 真正阻塞</a></li></ul></li><li><a href="#613-不需要加锁" rel="noopener nofollow">6.1.3. 不需要加锁</a></li></ul></li></ul></li><li><a href="#7-总结" rel="noopener nofollow">7. 总结</a></li><li><a href="#8-参考" rel="noopener nofollow">8. 参考</a></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<p>不能重复使用的计数器。让一个线程等待其他线程完事再往下执行，类似于Thread.join()<br>
底层使用AQS实现</p>
<h2 id="2-如何使用">2. 如何使用</h2>
<pre><code class="language-java">public class CountDownLatchTest
{
    public static void main(String[] args) throws InterruptedException
    {
        CountDownLatch latch = new CountDownLatch(10);
        for (int i = 0; i &lt; 10; i++)
        {
            int finalI = i;
            new Thread(() -&gt; {
                try
                {
                    if (finalI == 5)
                    {
                        TimeUnit.SECONDS.sleep(10L);
                    }
                    System.out.println(String.format("线程%s，时间【%s】 countdown", Thread.currentThread().getName(),LocalDateTime.now()));

                    latch.countDown();
                    System.out.println(String.format("线程%s，时间【%s】 执行完毕", Thread.currentThread().getName(),LocalDateTime.now()));

                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
                
            }).start();
        }
        
        
        latch.await();
        System.out.println(Thread.currentThread().getName() + "开始执行");
    }
}

</code></pre>
<ul>
<li>注意<br>
这里countdown的线程不会互相等待，谁先执行完谁就先退出</li>
</ul>
<h3 id="21-countdownlatch-vs-cyclicbarrier">2.1. CountDownLatch VS CyclicBarrier</h3>
<table>
<thead>
<tr>
<th></th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用场景</td>
<td>一个线程等待其他线程执行完毕，再往下执行</td>
<td>所有线程相互等待直到最后一个线程到达，再往下执行</td>
</tr>
<tr>
<td>能否重复使用</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>底层实现</td>
<td>AQS</td>
<td>Lock+Condition</td>
</tr>
</tbody>
</table>
<h2 id="3-uml">3. uml</h2>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20191230160645.png" class="lazyload"></p>
<h2 id="4-构造方法">4. 构造方法</h2>
<pre><code class="language-java">public class CountDownLatch {

	//继承了AQS
	private final Sync sync;

	public CountDownLatch(int count) {
	    if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0");
	    //默认就设置了count个信号量（即相当于一开始就加锁了count次）
	    this.sync = new Sync(count);
	}	

}
</code></pre>
<h3 id="41-syncaqs子类">4.1. Sync【AQS子类】</h3>
<pre><code class="language-java">private static final class Sync extends AbstractQueuedSynchronizer {

    Sync(int count) {
        setState(count);
    }

    int getCount() {
        return getState();
    }

	//重写的是AQS共享获取锁的方法
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

	//重写的是AQS共享释放锁的方法
    protected boolean tryReleaseShared(int releases) {
        // Decrement count; signal when transition to zero
        for (;;) {
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c-1;
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        }
    }
}
</code></pre>
<h2 id="5-countdown方法">5. countDown方法</h2>
<pre><code class="language-java">public void countDown() {
	//调用了AQS的releaseShared方法
    sync.releaseShared(1);
}
</code></pre>
<h3 id="51-使用aqs释放锁">5.1. 使用AQS释放锁</h3>
<ul>
<li>AQS releaseShared</li>
</ul>
<pre><code class="language-java">public final boolean releaseShared(int arg) {
	//调用Sync重写的tryReleaseShared释放信号量
    if (tryReleaseShared(arg)) {
    	//释放锁成功后调用Sync的doReleaseShared方法
        doReleaseShared();
        return true;
    }
    return false;
}

</code></pre>
<ul>
<li>3行：调用AQS的tryReleaseShared方法释放锁，由于Sync重写了这个方法，所以调用的是Sync重写的tryReleaseShared释放锁。当锁的数量减为0返回ture，表明所有线程都准备就绪</li>
<li>5行：使用tryReleaseShared释放锁成功后调用Sync的doReleaseShared方法。移除AQS队列中SIGNAL的节点并一个个唤醒</li>
</ul>
<p>下面具体说明：</p>
<h4 id="511-尝试释放锁">5.1.1. 尝试释放锁</h4>
<ul>
<li>Sync.tryReleaseShared</li>
</ul>
<pre><code class="language-java">protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    //不断尝试
    for (;;) {
    	//信号量为0,表明还没有人加锁，自然没法解锁，返回失败
        int c = getState();
        if (c == 0)
            return false;
        //CAS设置信号量-1。
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
        	//看是否为0，是则返回成功
            return nextc == 0;
    }
}
</code></pre>
<h4 id="512-所有锁释放成功后移除aqs队列中signal的节点并一个个唤醒">5.1.2. 所有锁释放成功后，移除AQS队列中SIGNAL的节点，并一个个唤醒</h4>
<ul>
<li>doReleaseShared</li>
</ul>
<pre><code class="language-java">private void doReleaseShared() {
    //不断尝试
    for (;;) {
    	
        Node h = head;
        //AQS队列不为空,把队列中SIGNAL的节点移除
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            //头节点状态为SIGNAL
            if (ws == Node.SIGNAL) {
            	//在头节点状态为signal的情况设置为0，失败了继续直到成功
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                //把头节点从AQS队列中移除
                unparkSuccessor(h);
            }
            //头节点状态为0，那么设置为PROPAGATE，失败了继续直到成功
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }

        //队列中没有SIGNAL的节点
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre>
<h5 id="5121-把头节点从aqs队列中移除">5.1.2.1. 把头节点从AQS队列中移除</h5>
<ul>
<li>unparkSuccessor</li>
</ul>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        //当前节点的状态&lt;0,则把状态改为0
        //0是空的状态，因为node这个节点的线程释放了锁后续不需要做任何
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

  
         //当前节点的下一个节点为空或者状态&gt;0（即是取消状态）
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            //那么从队尾开始往前遍历找到离当前节点最近的下一个状态&lt;=0的节点（即非取消状态）
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
    	//唤醒下一个节点
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>
<h2 id="6-await方法">6. await方法</h2>
<pre><code class="language-java">public void await() throws InterruptedException {
	//调用AQS的acquireSharedInterruptibly方法加锁
    sync.acquireSharedInterruptibly(1);
}
</code></pre>
<h3 id="61-使用aqs加锁">6.1. 使用AQS加锁</h3>
<ul>
<li>AQS acquireSharedInterruptibly</li>
</ul>
<pre><code class="language-java">public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    //调用Sync重写的tryAcquireShared判断是否加锁。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
</code></pre>
<ul>
<li>6行：调用Sync重写的tryAcquireShared判断是否需要加锁，而不是真的加锁。可以看出当tryAcquireShared返回&lt;0的时候需要往下执行doAcquireSharedInterruptibly进行加锁。<br>
而tryAcquireShared返回&lt;0指的是一开始设置的count个信号量没有被用完，说明其他线程任务没执行完</li>
<li>7行：加锁。准确说是加入AQS队列，阻塞等待其他线程执行完</li>
</ul>
<p>下面详细说明：</p>
<h4 id="611-判断是否需要加锁">6.1.1. 判断是否需要加锁</h4>
<ul>
<li>Sync tryAcquireShared</li>
</ul>
<pre><code class="language-java">protected int tryAcquireShared(int acquires) {
	//当前锁的数量为0，即所有线程任务都执行完了，那么返回1不用加锁
	//否则&gt;0指的是一开始设置的count个信号量没有被用完，说明其他线程任务没执行完。那么该线程需要进行加锁，故返回-1
    return (getState() == 0) ? 1 : -1;
}
</code></pre>
<h4 id="612-需要加锁那么加入aqs队列阻塞等待其他线程执行完">6.1.2. 需要加锁，那么加入AQS队列阻塞等待其他线程执行完</h4>
<p>当state&gt;0说明有信号量没被释放完，那么需要加锁</p>
<ul>
<li>doAcquireSharedInterruptibly</li>
</ul>
<pre><code class="language-java">private void doAcquireSharedInterruptibly(int arg)
	throws InterruptedException {
	//以SHARE模式加入AQS队列
	final Node node = addWaiter(Node.SHARED);
	boolean failed = true;
	try {
	//死循环直到获取锁成功
		for (;;) {
			//逻辑1.
			//当前节点的前一个节点是头节点的时候（公平锁：即我的前面没有人等待获取锁），尝试获取锁
		    final Node p = node.predecessor();
		    if (p == head) {
		    	//state == 0(即没人加锁的情况下才执行加锁--其实并没有真的加锁)
		        int r = tryAcquireShared(arg);
		        if (r &gt;= 0) {
		        	//获取锁成功后设置头节点为当前节点
		            setHeadAndPropagate(node, r);
		            p.next = null; // help GC
		            failed = false;
		            return;
		        }
		    }
			//逻辑2.
			//当前节点的前一个节点状态时SIGNAL（承诺唤醒当前节点）的时候，阻塞当前线程。
			//什么时候唤醒？释放锁的时候
			//唤醒之后干什么？继续死循环执行上面的逻辑1
		    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
		        parkAndCheckInterrupt())
		        throw new InterruptedException();
		}
	//如果发生了异常，那么执行下面的逻辑
	} finally {
		//除了获取锁成功的情况都会执行cancelAcquire方法
		if (failed)
		    cancelAcquire(node);
	}
}
</code></pre>
<h5 id="6121-构造节点加入aqs队列">6.1.2.1. 构造节点加入AQS队列</h5>
<ul>
<li>AQS.addWaiter</li>
</ul>
<pre><code class="language-java"> private Node addWaiter(Node mode) {
 	//用当前线程、SHARED模式构造节点
    Node node = new Node(Thread.currentThread(), mode);
    // 队列不为空
    Node pred = tail;
    if (pred != null) {
    	//插入到队尾
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //队列为空或者插入到队尾失败
    enq(node);
    return node;
}
</code></pre>
<p>队列为空或者插入到队尾失败的情况执行enq，如下</p>
<ul>
<li>AQS.enq</li>
</ul>
<pre><code class="language-java">private Node enq(final Node node) {
	//死循环直到入队成功
    for (;;) {
        Node t = tail;
    	//队列为空，那么初始化头节点。注意是new Node而不是当前node（即队头是个占位符）
        if (t == null) {
            if (compareAndSetHead(new Node()))
                tail = head;
		//队列不为空，插入到队尾
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<h5 id="6122-判断是否需要阻塞">6.1.2.2. 判断是否需要阻塞</h5>
<ul>
<li>shouldParkAfterFailedAcquire</li>
</ul>
<pre><code class="language-java">//根据（前一个节点，当前节点）-&gt;是否阻塞当前线程
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
	//前一个节点的状态时SIGNAL，即释放锁后承诺唤醒当前节点，那么返回true可以阻塞当前线程
    if (ws == Node.SIGNAL)
        return true;
    //前一个节点状态&gt;0，即CANCEL。
    //那么往前遍历找到没有取消的前置节点。同时从链表中移除CANCEL状态的节点
    if (ws &gt; 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
	// 前置节点状态&gt;=0，即0或者propagate。
	//这里通过CAS把前置节点状态改成signal成功获取锁，失败的话再阻塞。why？
    } else {
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<h5 id="6123-真正阻塞">6.1.2.3. 真正阻塞</h5>
<ul>
<li>parkAndCheckInterrupt</li>
</ul>
<pre><code class="language-java">private final boolean parkAndCheckInterrupt() {
	//使用Unsafe阻塞当前线程，这里会清除线程中断的标记，因此需要返回中断的标记
    LockSupport.park(this);
    return Thread.interrupted();
}
</code></pre>
<h4 id="613-不需要加锁">6.1.3. 不需要加锁</h4>
<p>当state=0说明所有信号量已被释放完，那么直接返回，执行业务逻辑</p>
<h2 id="7-总结">7. 总结</h2>
<ul>
<li>让一个线程等待其他线程完事再往下执行，类似于Thread.join()</li>
<li>主线程创建CountDownLatch的时候初始化了信号量，相当于一开始就有N个人加锁。</li>
<li>主线程调用await的时候检查信号量是否为0，不为0说明其他线程没有执行完，那么加入AQS队列阻塞，等待唤醒</li>
<li>其他线程调用countDown的时候会使信号量-1，最后一个线程减为0的时候会唤醒AQS队列中的所有节点（主线程），让其继续往下执行</li>
<li>主线程被唤醒继续往下执行</li>
</ul>
<h2 id="8-参考">8. 参考</h2>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/CountDownLatch/" target="_blank" rel="noopener nofollow">【死磕 Java 并发】—– J.U.C 之并发工具类：CountDownLatch | 芋道源码 —— 纯源码解析博客</a></li>
<li><a href="http://ifeve.com/countdownlatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener nofollow">CountDownLatch源码解析 | 并发编程网 – ifeve.com</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-25 14:32">2025-06-25 14:32</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">85</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18947950);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18947950', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18947950', title: 'Java源码分析系列笔记-9.CountDownLatch' })">举报</a>
</div>
        