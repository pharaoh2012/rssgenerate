
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18974497" title="发布于 2025-07-09 10:55">
    <span role="heading" aria-level="2">【线程池饱和策略】线程池饱和策略及自定义方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="常见的线程池饱和策略及使用场景">常见的线程池饱和策略及使用场景</h3>
<p>当线程池的任务队列已满且线程数达到最大值时，新的任务会触发饱和策略（拒绝策略）。Java 提供了四种默认策略：</p>
<ol>
<li>
<p><strong>AbortPolicy（默认策略）</strong><br>
<strong>行为</strong>：直接抛出 <code>RejectedExecutionException</code> 异常。<br>
<strong>适用场景</strong>：</p>
<ul>
<li>需要严格保证任务不丢失的场景（如支付交易）。</li>
<li>调用方需明确感知任务提交失败，以便回滚或重试。<br>
<strong>示例</strong>：金融系统中订单处理，失败需立即告警。</li>
</ul>
</li>
<li>
<p><strong>CallerRunsPolicy</strong><br>
<strong>行为</strong>：由提交任务的线程（调用者线程）直接执行该任务。<br>
<strong>适用场景</strong>：</p>
<ul>
<li>需要避免任务丢失，且能接受任务执行速度下降。</li>
<li>利用调用线程执行任务，变相限制新任务提交速率（负反馈）。<br>
<strong>示例</strong>：Web 服务器处理请求，高峰期用用户线程执行任务，防止雪崩。</li>
</ul>
</li>
<li>
<p><strong>DiscardPolicy</strong><br>
<strong>行为</strong>：直接丢弃新任务，无任何通知。<br>
<strong>适用场景</strong>：</p>
<ul>
<li>允许静默丢弃非关键任务（如日志收集）。</li>
<li>对实时性要求低且可容忍数据丢失的场景。<br>
<strong>示例</strong>：监控数据上报，丢弃部分数据不影响整体统计。</li>
</ul>
</li>
<li>
<p><strong>DiscardOldestPolicy</strong><br>
<strong>行为</strong>：丢弃队列中最旧的任务（队首），然后重试提交新任务。<br>
<strong>适用场景</strong>：</p>
<ul>
<li>新任务优先级高于旧任务（如实时消息推送）。</li>
<li>可容忍历史任务延迟或丢失。<br>
<strong>注意</strong>：优先队列中“最旧”不一定是提交时间最早，而是优先级最低。<br>
<strong>示例</strong>：股票价格更新，最新价格比历史价格更重要。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何自定义饱和策略">如何自定义饱和策略？</h3>
<p>通过实现 <code>RejectedExecutionHandler</code> 接口并重写 <code>rejectedExecution</code> 方法：</p>
<pre><code class="language-java">import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;

public class CustomRejectionPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable task, ThreadPoolExecutor executor) {
        // 自定义处理逻辑（示例：记录日志 + 重试一次）
        System.err.println("任务被拒绝: " + task);
        
        if (!executor.isShutdown()) {
            // 重试一次
            executor.execute(task);
            System.out.println("任务重试提交成功");
        }
    }
}
</code></pre>
<h4 id="使用自定义策略">使用自定义策略</h4>
<pre><code class="language-java">import java.util.concurrent.*;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 创建线程池并指定自定义策略
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, // 核心线程数
            4, // 最大线程数
            60, TimeUnit.SECONDS,
            new ArrayBlockingQueue&lt;&gt;(2), // 容量为2的队列
            new CustomRejectionPolicy()   // 自定义饱和策略
        );

        // 提交任务（模拟饱和）
        for (int i = 0; i &lt; 10; i++) {
            executor.execute(() -&gt; {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        executor.shutdown();
    }
}
</code></pre>
<h4 id="自定义策略的常见实践">自定义策略的常见实践</h4>
<ol>
<li>
<p><strong>记录日志/告警</strong>：</p>
<pre><code class="language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    log.error("任务拒绝: {}", r, new RejectedException());
}
</code></pre>
</li>
<li>
<p><strong>暂存到数据库/Redis</strong>：</p>
<pre><code class="language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    taskRedisQueue.save(r); // 保存到外部存储，后续恢复
}
</code></pre>
</li>
<li>
<p><strong>有限次重试</strong>：</p>
<pre><code class="language-java">private int maxRetries = 3;
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (retryCount.getAndIncrement() &lt; maxRetries) {
        e.execute(r); // 重试提交
    }
}
</code></pre>
</li>
<li>
<p><strong>降级处理</strong>：</p>
<pre><code class="language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    runFallbackService((Task) r); // 执行降级逻辑
}
</code></pre>
</li>
</ol>
<hr>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>行为</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AbortPolicy</code></td>
<td>抛出异常</td>
<td>需严格保证任务不丢失（如交易系统）</td>
</tr>
<tr>
<td><code>CallerRunsPolicy</code></td>
<td>调用者线程执行任务</td>
<td>限制提交速率，避免雪崩（如Web服务）</td>
</tr>
<tr>
<td><code>DiscardPolicy</code></td>
<td>静默丢弃新任务</td>
<td>容忍数据丢失（如日志收集）</td>
</tr>
<tr>
<td><code>DiscardOldestPolicy</code></td>
<td>丢弃队首任务并重试提交新任务</td>
<td>新任务优先级更高（如实时推送）</td>
</tr>
</tbody>
</table>
<p><strong>自定义策略</strong>：通过实现 <code>RejectedExecutionHandler</code> 接口，可结合业务需求实现降级、重试、持久化等灵活逻辑。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-09 10:56">2025-07-09 10:55</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18974497);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18974497', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18974497', title: '【线程池饱和策略】线程池饱和策略及自定义方法' })">举报</a>
</div>
        