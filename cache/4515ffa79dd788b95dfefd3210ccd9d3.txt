
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18653392" title="发布于 2025-01-07 17:20">
    <span role="heading" aria-level="2">【编码】如何实现一套自定义网络协议？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>前言</h2>
<p>下文介绍的自定义协议仅作为学习示例，纯粹是玩具项目，没有实际可用性。无需过度关注和讨论其合理性</p>
<h3>进行通信的双方是谁？</h3>
<p>常见的模型</p>
<p>客户端-服务器，例如HTTP协议，浏览器&lt;=&gt;Web服务器。</p>
<p>中转站模型，如MQTT协议，应用服务&lt;=&gt;中转站&lt;=&gt;硬件客户端</p>
<p>对等模型，例如Thrift协议，应用服务&lt;=&gt;应用服务。</p>
<h3>通用协议如此丰富，还需要自定义协议吗？</h3>
<p>需要。许多中间件服务在构建集群时，服务节点之间需要进行高效的内部通信。</p>
<p>在这种场景下，自定义协议能发挥巨大的作用：</p>
<ul>
<li><strong>去除冗余字段</strong>：自定义协议能够减少无用字段，最大化优化通信吞吐量</li>
<li><strong>灵活性</strong>：自定义协议可以根据需求进行灵活扩展，支持注入优先级控制，解压缩控制等特点。</li>
</ul>
<p>自定义协议可以减少无用字段，最大限度地优化通信吞吐量；也更加灵活，可以进行优先级控制。</p>
<p>例如，<strong>Kafka</strong> 就使用了自定义协议来满足高效的消息传递需求。</p>
<h2>自定义协议设计</h2>
<p>所谓网络协议，就是传输的报文格式，以及收发双方处理报文的规则。</p>
<p>报文格式做如下设计：</p>
<ul>
<li>固定头部（4字节）
<ul>
<li>字节1：消息类型
<ul>
<li>1=req，2=res, 3=pub, 4=sub, 5=msg</li>
<li>用一个字节来表示类型有点浪费了。</li>
</ul>
</li>
<li>字节2~字节4：消息体长度
<ul>
<li>这三个字节能够表示最大值为 16777215，即最大消息体长度为 <strong>16MB</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>消息体（可变长度）</li>
</ul>
<p>规则：</p>
<p>1.服务端收到req包，需返回res包</p>
<p>2.服务端收到sub包，需更新订阅情况</p>
<p>3.服务端收到pub包，需根据订阅情况发送msg包</p>
<h2>粘拆包问题</h2>
<p>在设计网络协议时，不可不谈粘拆包问题。</p>
<h3><strong>什么是粘包和拆包？</strong></h3>
<p>这两个都是接收端在接收数据时遇到的问题，其中</p>
<ul>
<li>粘包：多个数据包合并成一个包接收</li>
<li>拆包：一个数据包被拆分成多个包接收</li>
</ul>
<h3><strong>为什么会出现粘包与拆包？</strong></h3>
<p>根本原因就是传输层的TCP协议，是面向字节流的，它不知道数据边界。</p>
<p>此外，TCP根据网络情况（如最大传输单元MTU）动态调整报文大小，导致数据包的分段与合并。</p>
<p>从而产生粘包和拆包问题</p>
<p><strong>传输流程：</strong></p>
<p>1.发送缓冲区：当应用层产生数据后，这些数据会首先进入Socket连接的发送缓冲区</p>
<p>2.数据拆分：网卡根据缓冲区中的数据内容，将数据拆分成多个小的TCP数据报进行发送</p>
<p>3.接收与重组：接收端的TCP栈会将接收到的多个TCP数据包重新组装成完整的字节流（Socket接收缓冲区）</p>
<h3>案例场景</h3>
<p>一个常见的场景是，客户端连续发送多个消息（如 100 个字符串），而服务端接收到的数据可能并不完全是 100 条。</p>
<p>要复现这种问题也很简单，只要客户端连续发100个字符串，检查服务端收到的数据条数。</p>
<p>客户端代码：连接建立后，连续发送100次字符串</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelActive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">        ctx.writeAndFlush(Unpooled.copiedBuffer("Netty rocks!", CharsetUtil.UTF_8));</span>
        <span style="color: rgba(0, 0, 255, 1)">new</span> Thread(() -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; 100; i++<span style="color: rgba(0, 0, 0, 1)">) {
                ctx.writeAndFlush(Unpooled.copiedBuffer(</span>"Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!"<span style="color: rgba(0, 0, 0, 1)">, CharsetUtil.UTF_8));
            }
        }).start();
    }</span></pre>
</div>
<p>服务端代码：每收到一个包，就打印一次。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        ByteBuf in </span>=<span style="color: rgba(0, 0, 0, 1)"> (ByteBuf) msg;
        System.out.println(</span>"Server Receive:"+<span style="color: rgba(0, 0, 0, 1)">in.toString(CharsetUtil.UTF_8));
        ctx.write(in);
    }</span></pre>
</div>
<p>结果：仅收到两个包，同时存在粘包和拆包问题。一个Siuuuu被截断了</p>
<div class="cnblogs_code">
<pre>Server Receive:Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!<span style="color: rgba(0, 0, 0, 1)">Siuuuuuuuuuuuuuu
Server Receive:uuuuuuuuuuuuuuuuuuuuuuuuu</span>!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!Siuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu!</pre>
</div>
<h3>如何处理粘包和拆包？</h3>
<p>处理方式由消息格式决定</p>
<ul>
<li>固定长度：每条消息的长度固定，不足部分使用填充</li>
<li>特殊分隔符：每条消息的末尾添加特定的分隔符</li>
<li>消息头+消息体：消息头长度固定，包含消息体长度信息</li>
</ul>
<p>由于我们采用的时第三种方式，也是最复杂的一种。</p>
<p>处理的核心在于<strong>消息头</strong>，因为它携带了消息体的长度信息，是判断消息边界的关键。</p>
<p><strong>粘包的处理</strong></p>
<p>步骤如下：</p>
<ol>
<li>提取消息头：首先提取消息头，从中获取消息体的长度信息</li>
<li>读取完整消息：根据消息体的长度，从数据流中读取完整的消息内容</li>
<li>重复执行：重复步骤1和步骤2，直到没有更多的数据，或当前数据不足以构成完整的消息</li>
</ol>
<p><strong>拆包的处理</strong></p>
<p>拆包的处理方式与粘包类似：</p>
<ol>
<li>缓存数据：如果接收到的数据不足一条完整消息，则将数据存入缓冲区。</li>
<li>合并新数据：在接收到新数据时，判断缓冲区和新数据是否可以组成完整消息，直到消息完整为止。</li>
<li>继续缓存：剩下的数据如果不足，则继续缓存</li>
</ol>
<p><strong>代码案例</strong></p>
<p>1）客户端</p>
<p>根据上面的协议格式，构建消息。（这里的消息体内容是随机字符串，实际应用中通常是序列化后的POJO对象。）</p>
<p>连接建立后连续发送200条随机长度的消息。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> EchoClientHandler <span style="color: rgba(0, 0, 255, 1)">extends</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;<span style="color: rgba(0, 0, 0, 1)"> {


    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelInactive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.channelInactive(ctx);
        System.out.println(</span>"断开连接"<span style="color: rgba(0, 0, 0, 1)">);
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelActive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">new</span> Thread(() -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连续发送200条消息</span>
            <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; 200; i++<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                    ctx.writeAndFlush(Unpooled.copiedBuffer(buildRandomMsg()));
                } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();

    }

    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        System.out.println(</span>"Client receive:"+<span style="color: rgba(0, 0, 0, 1)">byteBuf.toString(CharsetUtil.UTF_8));
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        cause.printStackTrace();
        ctx.close();
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建消息，其中body内容为随机长度的随机字符串</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[] buildRandomMsg() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IOException {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> length = RandomUtil.randomInt(100, 200<span style="color: rgba(0, 0, 0, 1)">);
        String body </span>=<span style="color: rgba(0, 0, 0, 1)"> RandomUtil.randomString(length);

        System.out.println(</span>"长度："+length+"||内容："+<span style="color: rgba(0, 0, 0, 1)">body);

        </span><span style="color: rgba(0, 0, 255, 1)">byte</span> type = 1<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] lengthBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[3<span style="color: rgba(0, 0, 0, 1)">];
        lengthBytes[</span>0] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 16<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>1] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 8<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>2] = (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">) length;
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] bodyBytes =<span style="color: rgba(0, 0, 0, 1)"> body.getBytes(CharsetUtil.UTF_8);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> concatByteArrays(<span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[]{type}, lengthBytes, bodyBytes);
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">拼接字节数组</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[] concatByteArrays(<span style="color: rgba(0, 0, 255, 1)">byte</span>[]... byteArrays) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IOException {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用 ByteArrayOutputStream 来拼接字节数组</span>
        ByteArrayOutputStream byteArrayOutputStream = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ByteArrayOutputStream();

        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[] array : byteArrays) {
            byteArrayOutputStream.write(array);
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 返回拼接后的字节数组</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> byteArrayOutputStream.toByteArray();
    }
}</span></pre>
</div>
<p>2）服务端</p>
<p>在看代码前，先说明一下channelRead的调用流程</p>
<ul>
<li>Socket接收到TCP报文，将数据写入内核缓冲区</li>
<li>NIO线程检测到此Socket有可读消息</li>
<li>NIO线程从内核缓冲区读取消息，得到ByteBuf msg</li>
<li>NIO线程调用channelRead</li>
</ul>
<p>得到两个信息</p>
<ol>
<li>msg是从缓冲区读取的，它可能包含多条完整消息 + 一条残缺消息。</li>
<li>msg已经从缓冲区读出，缓冲区数据已清空。对于不完整的消息需要自行缓存</li>
</ol>
<p>下面代码是直接实现的，主要用来介绍完整的处理逻辑。</p>
<p>实际应用中推荐继承Netty提供的ByteToMessageDecoder，它帮你实现了缓存管理。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> EchoServerHandler <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> ChannelInboundHandlerAdapter {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span> HEADER_LENGTH = 4; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头部长度</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> ByteBuf buffer = Unpooled.buffer(1024); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存残缺消息</span>
<span style="color: rgba(0, 0, 0, 1)">
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        ByteBuf income </span>=<span style="color: rgba(0, 0, 0, 1)"> (ByteBuf) msg;

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">上一次有缓存存在，则本数据包不是消息头开头，</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span>(buffer.readableBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {<br>            buffer.ensureWritable(income.readableBytes()); //进行必要的扩容
            income.readBytes(buffer, income.readableBytes());

            readMsgFromBuffer(buffer);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩下一点残缺消息</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span>(buffer.readableBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">保留剩下的数据，重置读索引为0</span>
                System.out.println("缓存剩余字节："+<span style="color: rgba(0, 0, 0, 1)">buffer.readableBytes());
                buffer.discardReadBytes();
            } </span><span style="color: rgba(0, 0, 255, 1)">else</span> { <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">刚刚好，则清空数据</span>
<span style="color: rgba(0, 0, 0, 1)">                buffer.clear();
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            readMsgFromBuffer(income);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩下的数据全部写入缓存</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (income.readableBytes() &gt;0<span style="color: rgba(0, 0, 0, 1)">) {
                System.out.println(</span>"剩余字节:"+<span style="color: rgba(0, 0, 0, 1)">income.readableBytes());
                income.readBytes(buffer, income.readableBytes());
            }
        }

    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">从字节数组中读取完整的消息</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> readMsgFromBuffer(ByteBuf byteBuf) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩余可读消息是否包含一个消息头</span>
        <span style="color: rgba(0, 0, 255, 1)">while</span>(byteBuf.readableBytes() &gt;=<span style="color: rgba(0, 0, 0, 1)"> HEADER_LENGTH) {
            byteBuf.markReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">由于可能读不到完整的消息，所以读之前先标记索引位置，方便重置
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">读取消息头</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] headerBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[4<span style="color: rgba(0, 0, 0, 1)">];
            byteBuf.readBytes(headerBytes);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取类型</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> type = headerBytes[0] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取消息体长度</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> bodyLength = ((headerBytes[1] &amp; 0xFF) &lt;&lt; 16) |<span style="color: rgba(0, 0, 0, 1)">
                    ((headerBytes[</span>2] &amp; 0xFF) &lt;&lt; 8) |<span style="color: rgba(0, 0, 0, 1)">
                    (headerBytes[</span>3] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">不包含请求体</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (byteBuf.readableBytes() &lt;<span style="color: rgba(0, 0, 0, 1)"> bodyLength) {
                byteBuf.resetReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">重置读索引到当前消息头位置</span>
                <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
            }

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 完整消息体已经接收，处理消息</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] body = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[bodyLength];
            byteBuf.readBytes(body);
            System.out.println(</span>"type:"+type+"||length:"+bodyLength+"||body:"+<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
        }
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelReadComplete(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span>
<span style="color: rgba(0, 0, 0, 1)">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        cause.printStackTrace();
        ctx.close();
    }
}</span></pre>
</div>
<p>服务端输出：服务端逐行打印出消息类型，长度，消息体。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">...
type:</span>1||length:175||body:0cDDAkum0F9DNwF511AKitTe2zRoSc27IjBYwgoODkXxx78xp0cowcDDNWTZ6xjCZyn6wmI2UxXLYB25TjUnOG9ZyjiZ9Jge3kbxabRjZAo0qsCYFfKMyzxApp953z1N7uDbP9rmlxeyYbYiif3y3ybtnnaAkuKFcspje6SLRnY69Nz</pre>
</div>
<h2>消息体编解码（序列化）</h2>
<p>在经过前面粘包和拆包处理后，我们已经能够成功地从数据流中分离并组装出完整的消息。然而，在实际应用中，消息体通常需要进一步转换为对象，才能提交给上层的业务逻辑。</p>
<p>这是传输层的关键职责之一。</p>
<h3>常见序列化方法</h3>
<p>常见的POJO对象序列化方式包括：</p>
<p><strong>Java序列化（Serializable）</strong></p>
<p>优点：内置，无需额外依赖。</p>
<p>缺点：</p>
<ul>
<li>性能较差，序列化和反序列化速度较慢。</li>
<li>无法跨语言使用，限制了不同语言（如Java服务端和C++客户端）之间的数据交换。</li>
</ul>
<p><strong>JSON</strong></p>
<p>优点：可读性好，方便调试，支持各种语言</p>
<p>缺点：相较于二进制格式，JSON的键（key）通常占用较多空间，大规模数据传输时，带宽开销大。</p>
<p class="_mce_tagged_br"><strong>Protocol Buffers（ProtoBuf）</strong><br>优势：</p>
<ul>
<li>高效的二进制序列化，体积小，序列化和反序列化速度快。</li>
<li>支持跨语言使用，适用于不同编程语言之间的通信。</li>

</ul>
<h3>代码案例</h3>
<p>这里我们使用ProtoBuf。</p>
<p><strong>构建消息类</strong></p>
<p>写一个.proto文件，定义消息格式。</p>
<p>hello_request.proto</p>
<div class="cnblogs_code">
<pre>option java_multiple_files = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
option java_package </span>= "protocol"<span style="color: rgba(0, 0, 0, 1)">;
option java_outer_classname </span>= "Request"<span style="color: rgba(0, 0, 0, 1)">;

message HelloRequest {
    required string requestId </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    optional string content </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>下载ProtoBuf编译工具包，protoc-{version}-win64.zip</p>
<div class="cnblogs_code">
<pre>https:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">github.com/protocolbuffers/protobuf/releases</span></pre>
</div>
<p>编译，得到Java文件</p>
<div class="cnblogs_code">
<pre>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/hello_request.proto</pre>
</div>
<p>引入对应版本的Jar包。（jar包版本要和protoc版本一致，否则报错）</p>
<div class="cnblogs_code">
<pre>https:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">mvnrepository.com/artifact/com.google.protobuf/protobuf-java</span></pre>
</div>
<p>接着就可以使用类构建POJO对象和对象的编解码了。</p>
<p><strong>客户端</strong></p>
<p>其他地方不变，使用上面生成好的HelloRequest类，构建对象。通过setter塞入数据，然后通过toByteArray()得到序列化后的二进制数据。</p>
<p>注意：现在的length应该是整个消息体的字节数，不再是随机字符串的长度。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[] buildRandomMsg() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IOException {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> randomStrLength = RandomUtil.randomInt(100, 200<span style="color: rgba(0, 0, 0, 1)">);
        String msgId </span>=<span style="color: rgba(0, 0, 0, 1)"> UUID.randomUUID().toString();
        String content </span>=<span style="color: rgba(0, 0, 0, 1)"> RandomUtil.randomString(randomStrLength);
        HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.newBuilder()
                .setRequestId(msgId)
                .setContent(content)
                .build();
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] bodyBytes =<span style="color: rgba(0, 0, 0, 1)"> request.toByteArray();
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> length =<span style="color: rgba(0, 0, 0, 1)"> bodyBytes.length;

        System.out.println(</span>"发送消息："+<span style="color: rgba(0, 0, 0, 1)">request.toString());

        </span><span style="color: rgba(0, 0, 255, 1)">byte</span> type = 1<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] lengthBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[3<span style="color: rgba(0, 0, 0, 1)">];
        lengthBytes[</span>0] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 16<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>1] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 8<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>2] = (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">) length;

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> concatByteArrays(<span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[]{type}, lengthBytes, bodyBytes);
    }</span></pre>
</div>
<p><strong>服务端</strong></p>
<p>其他地方不变，解析body的时候，使用HelloRequest.parseFrom(byte[] bytes)进行解码，得到HellpRequest对象。</p>
<div class="cnblogs_code">
<pre>   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">System.out.println("type:"+type+"||length:"+bodyLength+"||body:"+new String(body, CharsetUtil.UTF_8));</span>
   <span style="color: rgba(0, 0, 255, 1)">if</span>(type == 1<span style="color: rgba(0, 0, 0, 1)">) {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
              HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.parseFrom(body);
              System.out.println(</span>"收到消息:"+<span style="color: rgba(0, 0, 0, 1)">request.toString());
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
              System.out.println(</span>"解析失败："+<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
        }
    } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
              System.out.println(</span>"消息类型未知："+<span style="color: rgba(0, 0, 0, 1)">type);
    }</span></pre>
</div>
<p><strong>结果</strong></p>
<p>客户端输出</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">...
发送消息：requestId: </span>"ca9b3e07-0662-467c-9bed-843b519c2480"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"q82EuHvGgMhwbHl1t0qfv4M2NCJLikxahpEc8q9ezpCWUbU9M1Oh6U6zfIOnBC50ex5BweYfZ2JB0NoLmP4hgIsNzZ8mtfFPayi8KlDWRQw3gj7ENRgxjbm4HxJgrdDNobuguc8EPQ3SccWXGTsZytLEeOHJXskiGlH4oEf"</pre>
</div>
<p>服务端输出</p>
<div class="cnblogs_code">
<pre>....</pre>
<pre>收到消息:requestId: "ca9b3e07-0662-467c-9bed-843b519c2480"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"q82EuHvGgMhwbHl1t0qfv4M2NCJLikxahpEc8q9ezpCWUbU9M1Oh6U6zfIOnBC50ex5BweYfZ2JB0NoLmP4hgIsNzZ8mtfFPayi8KlDWRQw3gj7ENRgxjbm4HxJgrdDNobuguc8EPQ3SccWXGTsZytLEeOHJXskiGlH4oEf"</pre>
</div>
<h2>实现异步请求</h2>
<h3>结构设计</h3>
<p>底层Socket是天然支持异步的，因为发送和接收是可以同时进行的，不会互相影响。</p>
<p>要实现异步请求的效果，上层API只要做到以下几点：</p>
<ol>
<li>请求发送后，不会阻塞当前执行线程</li>
<li>响应到达后可以触发回调</li>
<li>超时（指定时间内没有收到响应）也可以触发回调</li>
</ol>
<p>实现方式</p>
<ol>
<li>请求接口发送请求后返回Future对象，可选择同步等待</li>
<li>客户端保留请求和对应的callback</li>
<li>服务端响应的时候返回请求ID</li>
<li>客户端根据ID获取关联请求，执行callback。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250106121717750-94160340.png" alt="" width="832" height="291" loading="lazy"></p>
<p>首先，项目结构图如下:</p>
<p>1.划线部分是废弃类</p>
<p>2.【变更】解码方式修改，新增通用的MessageDecoder可供双方解码，其继承于ByteToMessageDecoder。</p>
<p>3.【新增】新增HelloResponse</p>
<p>4.【新增】新增通用MessageEncoder，继承于MessageToByteEncoder</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250107154844848-19601071.png" alt="" width="351" height="459" loading="lazy"></p>
<h3>&nbsp;代码实现</h3>
<p>1. MessageDecoder.java</p>
<p>相比前面直接实现的，这里不用去管理缓存。另外，这里解析好的消息会写入List，但它其实是逐个传给下一个Handler。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> MessageDecoder <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> ByteToMessageDecoder {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span> HEADER_LENGTH = 4; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头部长度</span>
<span style="color: rgba(0, 0, 0, 1)">
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查是否足够的字节来读取一个消息头</span>
        <span style="color: rgba(0, 0, 255, 1)">while</span> (in.readableBytes() &gt;=<span style="color: rgba(0, 0, 0, 1)"> HEADER_LENGTH) {
            in.markReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 标记当前读取位置，便于重置

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读取消息头部</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] headerBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[4<span style="color: rgba(0, 0, 0, 1)">];
            in.readBytes(headerBytes);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取类型</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> type = headerBytes[0] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取消息体长度</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> bodyLength = ((headerBytes[1] &amp; 0xFF) &lt;&lt; 16) |<span style="color: rgba(0, 0, 0, 1)">
                    ((headerBytes[</span>2] &amp; 0xFF) &lt;&lt; 8) |<span style="color: rgba(0, 0, 0, 1)">
                    (headerBytes[</span>3] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查缓冲区中的数据是否足够读取整个消息体</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (in.readableBytes() &lt;<span style="color: rgba(0, 0, 0, 1)"> bodyLength) {
                in.resetReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 重置读指针，等待更多数据</span>
                <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
            }

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读取消息体</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] body = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[bodyLength];
            in.readBytes(body);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理消息，根据消息头中的类型，解析成不同的对象</span>
            <span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                Object msg </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 0, 255, 1)">if</span>(type == 1<span style="color: rgba(0, 0, 0, 1)">) {
                    msg </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.parseFrom(body);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(type == 2<span style="color: rgba(0, 0, 0, 1)">) {
                    msg </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloResponse.parseFrom(body);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    System.out.println(</span>"未知消息："+<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
                }
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(msg)) {
                    out.add(msg);
                }

            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                System.out.println(</span>"解析失败: " + <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
            }
        }
    }
}</span></pre>
</div>
<p>2.MessageEncoder.java</p>
<p>ProtoBuf生成的类可以调用toByteArray()序列化成字节数组。这样消息体的二进制数据就有了。</p>
<p>而消息头则根据消息类型和消息体长度进行构建</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> MessageEncoder <span style="color: rgba(0, 0, 255, 1)">extends</span> MessageToByteEncoder&lt;Object&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(!(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> GeneratedMessage)) {
            System.out.println(</span>"未知类型："+<span style="color: rgba(0, 0, 0, 1)">msg.getClass());
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> type = 0<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> HelloRequest) {
            type </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> HelloResponse) {
            type </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] bodyBytes =<span style="color: rgba(0, 0, 0, 1)"> ((GeneratedMessage) msg).toByteArray();
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> length =<span style="color: rgba(0, 0, 0, 1)"> bodyBytes.length;
        </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] lengthBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[3<span style="color: rgba(0, 0, 0, 1)">];
        lengthBytes[</span>0] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 16<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>1] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length &gt;&gt; 8<span style="color: rgba(0, 0, 0, 1)">);
        lengthBytes[</span>2] = (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">) length;
        out.writeByte(type);
        out.writeBytes(lengthBytes);
        out.writeBytes(bodyBytes);
    }
}</span></pre>
</div>
<p>3.ServerMessageHandler</p>
<p>服务器得到Decoder解析好的消息后，间隔一段时间（1-4秒）发回响应内容。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> ServerMessageHandler <span style="color: rgba(0, 0, 255, 1)">extends</span> SimpleChannelInboundHandler&lt;Object&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">异步线程</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> ScheduledExecutorService mockRequestHandler =<span style="color: rgba(0, 0, 0, 1)"> Executors.newSingleThreadScheduledExecutor();

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead0(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> HelloRequest) {
            System.out.println(</span>"收到消息："+<span style="color: rgba(0, 0, 0, 1)">msg);
            HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> (HelloRequest) msg;

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">使用处理线程，不阻塞NIO线程
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">模拟处理请求，处理时间随机1~4秒</span>
            mockRequestHandler.schedule(() -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                ctx.writeAndFlush(HelloResponse.newBuilder()
                        .setRequestId(request.getRequestId()) 
                        .setStatus(</span>200<span style="color: rgba(0, 0, 0, 1)">)
                        .setData(</span>"Handled:"+request.getContent()) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">增加一个前缀，表示服务器已处理</span>
<span style="color: rgba(0, 0, 0, 1)">                        .build()
                );
            }, RandomUtil.randomInt(</span>1, 4<span style="color: rgba(0, 0, 0, 1)">), TimeUnit.SECONDS);

        }
    }
}</span></pre>
</div>
<p>4.EchoServer</p>
<p>服务端启动类，配置Handler，启动端口监听。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> EchoServer {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> port;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> EchoServer(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> port) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.port =<span style="color: rgba(0, 0, 0, 1)"> port;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> start() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        EventLoopGroup bossGroup </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> NioEventLoopGroup(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">处理CONNECT的线程</span>
        EventLoopGroup workerGroup = <span style="color: rgba(0, 0, 255, 1)">new</span> NioEventLoopGroup(4); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">Worker线程</span>
        <span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            ServerBootstrap b </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">)
                    .localAddress(port)
                    .childHandler(</span><span style="color: rgba(0, 0, 255, 1)">new</span> ChannelInitializer&lt;SocketChannel&gt;<span style="color: rgba(0, 0, 0, 1)">() {
                        </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> initChannel(SocketChannel socketChannel) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
                            socketChannel.pipeline()
                                    .addLast(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MessageDecoder())
                                    .addLast(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MessageEncoder())
                                    .addLast(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerMessageHandler());
                        }
                    });
            ChannelFuture f </span>= b.bind().sync(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">开始监听</span>
            System.out.println("启动监听："+<span style="color: rgba(0, 0, 0, 1)">port);
            f.channel().closeFuture().sync(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">阻塞直到程序退出</span>
        } <span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            bossGroup.shutdownGracefully().sync();
            workerGroup.shutdownGracefully().sync();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> main(String[] args) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">new</span> EchoServer(9090<span style="color: rgba(0, 0, 0, 1)">).start();
    }
}</span></pre>
</div>
<p>5.ClientMessageHandler</p>
<p>对接ClientApi</p>
<p>1.连接建立后告知ClientApi</p>
<p>2.收到响应后提交给ClientApi</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> ClientMessageHandler <span style="color: rgba(0, 0, 255, 1)">extends</span> SimpleChannelInboundHandler&lt;Object&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead0(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> HelloResponse) {
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">            System.out.println("收到消息："+msg);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">收到响应内容，则触发回调</span>
            ClientApi clientApi =<span style="color: rgba(0, 0, 0, 1)"> Container.getClientApi();
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(clientApi)) {
                clientApi.onResponse((HelloResponse) msg);
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            System.out.println(</span>"未知消息："+<span style="color: rgba(0, 0, 0, 1)">msg);
        }
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelActive(ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.channelActive(ctx);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接成功，告知ClientApi</span>
        ClientApi clientApi =<span style="color: rgba(0, 0, 0, 1)"> Container.getClientApi();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(clientApi)) {
            clientApi.onConnected(ctx);
        } 

    }
    
}</span></pre>
</div>
<p>6.EchoClient</p>
<p>客户端启动类，配置编解码类和消息处理类，最后连接到目标地址。</p>
<p>注意：这里没有main入口，入口在Test类。</p>
<div class="cnblogs_code">
<pre>public class<span> EchoClient {
    private final<span> String host;
    private final int<span> port;

    public EchoClient(String host, int<span> port) {
        this.host =<span> host;
        this.port =<span> port;
    }

    public void start() throws<span> Exception {
        EventLoopGroup group = new<span> NioEventLoopGroup();
        try<span> {
            Bootstrap b = new<span> Bootstrap();
            b.group(group)
                    .channel(NioSocketChannel.class<span>)
                    .remoteAddress(new<span> InetSocketAddress(host, port))
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;<span>() {
                        protected void initChannel(SocketChannel socketChannel) throws<span> Exception {
                            socketChannel.pipeline()
                                    .addLast(new<span> MessageDecoder())
                                    .addLast(new<span> MessageEncoder())
                                    .addLast(new<span> ClientMessageHandler());
                        }
                    });
            ChannelFuture f =<span> b.connect().sync();
            System.out.println("开始连接"<span>);
            f.channel().closeFuture().sync();
        } finally<span> {
            group.shutdownGracefully().sync();
        }
    }
<span>
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<div><span>&nbsp;</span></div>
</div>
<p>7.Container</p>
<p>很简单，就是一个静态类。用来存放ClientApi的引用</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Container {
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> ClientApi clientApi;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> setClientApi(ClientApi clientApi) {
        Container.clientApi </span>=<span style="color: rgba(0, 0, 0, 1)"> clientApi;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> ClientApi getClientApi() {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> clientApi;
    }
}</span></pre>
</div>
<p>8.ClientApi</p>
<p>ClientApi负责建立连接，发送请求，回调响应。支持同步和异步两种请求方式。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ClientApi {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> String host;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> port;

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Map&lt;String, CompletableFuture&lt;HelloResponse&gt;&gt; waitingRequests = <span style="color: rgba(0, 0, 255, 1)">new</span> HashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> ScheduledExecutorService timer =<span style="color: rgba(0, 0, 0, 1)"> Executors.newSingleThreadScheduledExecutor();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> ReentrantLock lock = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ReentrantLock();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> ChannelHandlerContext ctx = <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> CompletableFuture&lt;ChannelHandlerContext&gt;<span style="color: rgba(0, 0, 0, 1)"> waitConnectionFuture;

    ClientApi(String host, </span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> port) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.host =<span style="color: rgba(0, 0, 0, 1)"> host;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.port =<span style="color: rgba(0, 0, 0, 1)"> port;
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">初始化后注册到Container中，方便其他类引用</span>
        Container.setClientApi(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接建立后，回调Context</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onConnected(ChannelHandlerContext ctx) {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(waitConnectionFuture != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                waitConnectionFuture.complete(ctx);
                waitConnectionFuture </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取连接</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> ChannelHandlerContext getConnection() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接已存在，直接发</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span>(ctx != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ctx;
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接不存在，建立连接</span>
            waitConnectionFuture = <span style="color: rgba(0, 0, 255, 1)">new</span> CompletableFuture&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
            </span><span style="color: rgba(0, 0, 255, 1)">new</span> Thread(()-&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                    </span><span style="color: rgba(0, 0, 255, 1)">new</span> EchoClient(host, port).start(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">这个会阻塞当前线程，所以另启线程</span>
                } <span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                    e.printStackTrace();
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">连接断开，也触发回调</span>
                    <span style="color: rgba(0, 0, 255, 1)">if</span>(waitConnectionFuture != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                        waitConnectionFuture.completeExceptionally(e);
                    }
                }
            }).start();
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">get()等待之前，需要释放锁</span>
        ctx =<span style="color: rgba(0, 0, 0, 1)"> waitConnectionFuture.get();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ctx;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> CompletableFuture&lt;HelloResponse&gt;<span style="color: rgba(0, 0, 0, 1)"> baseRequest(HelloRequest request) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">先注册回调</span>
        CompletableFuture&lt;HelloResponse&gt; future = <span style="color: rgba(0, 0, 255, 1)">new</span> CompletableFuture&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
        addToMap(request.getRequestId(), future);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">再发送请求</span>
        <span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            getConnection().writeAndFlush(request);
            System.out.println(</span>"发出消息："+<span style="color: rgba(0, 0, 0, 1)">request);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
            removeFromMap(request.getRequestId());
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> RuntimeException("请求错误："+<span style="color: rgba(0, 0, 0, 1)">e);
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">添加超时，防止服务器没响应，造成泄露</span>
        timer.schedule(() -&gt; timeout(request.getRequestId()), 5<span style="color: rgba(0, 0, 0, 1)">, TimeUnit.SECONDS);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> future;
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">同步请求</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> HelloResponse sendRequest(HelloRequest request) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.baseRequest(request).get();
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">异步请求</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> sendRequestAsync(HelloRequest request, Function&lt;HelloResponse, Boolean&gt;<span style="color: rgba(0, 0, 0, 1)"> callback) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.baseRequest(request).thenApply(callback);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> addToMap(String requestId, CompletableFuture&lt;HelloResponse&gt;<span style="color: rgba(0, 0, 0, 1)"> future) {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            waitingRequests.put(requestId, future);
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> removeFromMap(String requestId) {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            waitingRequests.remove(requestId);
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> timeout(String requestId) {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            CompletableFuture</span>&lt;HelloResponse&gt; future1 =<span style="color: rgba(0, 0, 0, 1)"> waitingRequests.get(requestId);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(future1)) {
                future1.completeExceptionally(</span><span style="color: rgba(0, 0, 255, 1)">new</span> RuntimeException("请求超时"<span style="color: rgba(0, 0, 0, 1)">));
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onResponse(HelloResponse response) {
        lock.lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">收到响应后，根据请求ID获取回调。</span>
            CompletableFuture&lt;HelloResponse&gt; future1 =<span style="color: rgba(0, 0, 0, 1)"> waitingRequests.get(response.getRequestId());
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(future1)) {
                future1.complete(response);
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            lock.unlock();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> close() {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(ctx != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            ctx.close();
        }
    }

}</span></pre>
</div>
<p>9.测试类</p>
<p>测试类，使用ClientApi，发送请求。</p>
<p>下面代码分别是同步发送5个请求和异步发送5个请求</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Test {
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main(String[] args) {
        ClientApi clientApi </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> ClientApi("127.0.0.1", 9090<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; 5; i++<span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> buildHelloRequest();

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">同步请求，收到响应后才会发下一个请求</span>
                HelloResponse response =<span style="color: rgba(0, 0, 0, 1)"> clientApi.sendRequest(request);
                System.out.println(</span>"同步收到：" +<span style="color: rgba(0, 0, 0, 1)"> response);
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">异步请求，发送完成即可发送下一个请求
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                clientApi.sendRequestAsync(request, response2 -&gt; {
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                    System.out.println("异步收到："+response2);
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                    return true;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">                });</span>
<span style="color: rgba(0, 0, 0, 1)">
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                e.printStackTrace();
            }
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构建请求</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> HelloRequest buildHelloRequest() {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> randomStrLength = RandomUtil.randomInt(100, 200<span style="color: rgba(0, 0, 0, 1)">);
        String msgId </span>=<span style="color: rgba(0, 0, 0, 1)"> UUID.randomUUID().toString();
        String content </span>=<span style="color: rgba(0, 0, 0, 1)"> RandomUtil.randomString(randomStrLength);
        HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.newBuilder()
                .setRequestId(msgId)
                .setContent(content)
                .build();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> request;
    }
}</span></pre>
</div>
<h3>运行效果</h3>
<p><strong>1）同步请求</strong></p>
<p>可以看到，只有收到前一个请求的响应后，才会发下一个请求</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">开始连接
发出消息：requestId: </span>"7ac9008f-8532-4740-bb1f-f5fe2d60fd62"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"zYU1oWKiJdLX2K87J0306Xdeq0BmlkijpD1p6t831A3b2fEP0JCZT9QqaT7oWnCpoKMIpZRZ2gJWbSvEIhxs56m8Zr0YhsvaPdQj1x8f4Q1HuLh"<span style="color: rgba(0, 0, 0, 1)">

同步收到：requestId: </span>"7ac9008f-8532-4740-bb1f-f5fe2d60fd62"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:zYU1oWKiJdLX2K87J0306Xdeq0BmlkijpD1p6t831A3b2fEP0JCZT9QqaT7oWnCpoKMIpZRZ2gJWbSvEIhxs56m8Zr0YhsvaPdQj1x8f4Q1HuLh"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"d74a8a83-28dd-4e40-9956-dfdd3d890bda"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"83LzAdgxQ8MYz1CmzRXfEn3ibz9WqiJHcQCRtkE4dCEZUnW44UNGfKtHR0nBNE7al7PdvdexEDDTth3Aoy6mati8TVOP54xRUT26MAaV0DP0UhU7V7QWaMfiKwV2oVpxMPqg2thwNdd5WCG53"<span style="color: rgba(0, 0, 0, 1)">

同步收到：requestId: </span>"d74a8a83-28dd-4e40-9956-dfdd3d890bda"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:83LzAdgxQ8MYz1CmzRXfEn3ibz9WqiJHcQCRtkE4dCEZUnW44UNGfKtHR0nBNE7al7PdvdexEDDTth3Aoy6mati8TVOP54xRUT26MAaV0DP0UhU7V7QWaMfiKwV2oVpxMPqg2thwNdd5WCG53"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"e47f4135-dc92-4a25-9fed-ca7b4ced41f5"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"1St23ktz7nhXcICb0Yqo3QoLNRoeKJ4V4jKcaO8psUZRXnhXtIUG2WZC7d0TCbS221pUxqTlTDojSbtQvCzjIcL3JTgPkBg46rk8uRIpX3yvx0RHmZhwjBkpPoCTtWfTzk6r5SK0SK7g0QAjQacULIDXS5K1Z1U9q"<span style="color: rgba(0, 0, 0, 1)">

同步收到：requestId: </span>"e47f4135-dc92-4a25-9fed-ca7b4ced41f5"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:1St23ktz7nhXcICb0Yqo3QoLNRoeKJ4V4jKcaO8psUZRXnhXtIUG2WZC7d0TCbS221pUxqTlTDojSbtQvCzjIcL3JTgPkBg46rk8uRIpX3yvx0RHmZhwjBkpPoCTtWfTzk6r5SK0SK7g0QAjQacULIDXS5K1Z1U9q"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"5122e929-be13-488e-b3ea-6e5acf7ebbbc"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"pj9sWOqhFGzplbUNieLOOzMKzSUEumgd2rMzR1cO4GwrmcXHb5vma32LbuHVQl8tkigKMHk9HCKM9xnUAdbCqopeTzbo0ixQkGzclud78hVFTV4PM2qYZDeWMBRDMrUXOJS0sCIxgyGFudz7XUGfJNSuJjio8dch8JPDRmHkZsABRxobZeafxiqGT"<span style="color: rgba(0, 0, 0, 1)">

同步收到：requestId: </span>"5122e929-be13-488e-b3ea-6e5acf7ebbbc"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:pj9sWOqhFGzplbUNieLOOzMKzSUEumgd2rMzR1cO4GwrmcXHb5vma32LbuHVQl8tkigKMHk9HCKM9xnUAdbCqopeTzbo0ixQkGzclud78hVFTV4PM2qYZDeWMBRDMrUXOJS0sCIxgyGFudz7XUGfJNSuJjio8dch8JPDRmHkZsABRxobZeafxiqGT"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"0cd23413-303d-4414-8cf1-20bd46a691d2"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"YWnQxVh0Z4yLPQeM6q3aiz7JYD6fEqZHFiE45KgebiZlwW7DlYnhZTZ7sG4rZqrvsHXQ65PCoN569kfJMHuJFp9kqnlBKeJ1iawYBFQfI5EqspxsaB7vkMuC1vA5ula2jwagoQoU6Yk0gi0EKEX1fpLIYvtYdMqTWjAfLFqc5s8yjPr0G"<span style="color: rgba(0, 0, 0, 1)">

同步收到：requestId: </span>"0cd23413-303d-4414-8cf1-20bd46a691d2"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:YWnQxVh0Z4yLPQeM6q3aiz7JYD6fEqZHFiE45KgebiZlwW7DlYnhZTZ7sG4rZqrvsHXQ65PCoN569kfJMHuJFp9kqnlBKeJ1iawYBFQfI5EqspxsaB7vkMuC1vA5ula2jwagoQoU6Yk0gi0EKEX1fpLIYvtYdMqTWjAfLFqc5s8yjPr0G"</pre>
</div>
<p><strong>2）异步请求</strong></p>
<p>可以看到5个请求会直接发出，不会等待响应。响应顺序也跟请求顺序不一样。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">开始连接
发出消息：requestId: </span>"2096b54f-825c-4fdf-817e-97b3a4b99fb2"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"ckp1dXcnYItdXafrURU6gJ9b5qW19rqPKLB22qlA2sHRfkSZEpmT4qi0TOAaDbM43v62svI1K6IccnlJtCjlpcu8RAdpfuO5hNBWsXpOaSGUgY4loLNlNFIDE5o7juhfCD2skV2"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"e8c501e0-a4e2-4972-a6be-f92539141252"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"ZpOz1YK6e9VOrX69xqNovUXfapY6Ito7z6LlsM6o1Vzeo1hibzvOcxAzYD8hIsOFvGAqk024XbL7yidlgPk4F9GId6ydRxzjjNdg8csxG9FdBXzzr6xuESJ"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"2c56fc02-5fd8-4c17-bca5-ab0def66493c"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"FzoUaLvHxA0Tm7eU4GL9bIE6mEMNRIUSZILPLiREPXGfhcgoasYd1W5jEfAooE697LQr2DMw6fBdwEqHunQcl6doxrnxSQAZorHztHvyKXAFmbnF3aDkYgO82HaHGXuC"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"477cbb82-77c0-4270-b161-555da7b6a5e2"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"Ow81y5qPraVcobOiZ6sCH72jJGNC0784ox5crQYP5fZ6CXoWphRdC9WW4NKSiChbci6aGutnWJbO1HlpR0FV4m9qahbWGkFI0Zr2uvMbuaj8SPpH6X"<span style="color: rgba(0, 0, 0, 1)">

发出消息：requestId: </span>"98db5068-1a85-455f-8fea-4b6c8a562776"<span style="color: rgba(0, 0, 0, 1)">
content: </span>"nWnNIaJFt1otie04SWoaoN08f2BOuTMyRbtFuEhj0LiYilRjeKswzqrbKlze30ZBFNIuvEz6P97rP9lM5bkuDYLv1QuKOd1wctfeF9K2RbKh6hvOfgHE5wl2xUk0B6nBFK5fI1sdj3hhoiPLApQZjGzFaSHZGVtLdM4yPBC6BhmsNCPkAo2AxcQ0iZuVEHkihs"<span style="color: rgba(0, 0, 0, 1)">

异步收到：requestId: </span>"2096b54f-825c-4fdf-817e-97b3a4b99fb2"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:ckp1dXcnYItdXafrURU6gJ9b5qW19rqPKLB22qlA2sHRfkSZEpmT4qi0TOAaDbM43v62svI1K6IccnlJtCjlpcu8RAdpfuO5hNBWsXpOaSGUgY4loLNlNFIDE5o7juhfCD2skV2"<span style="color: rgba(0, 0, 0, 1)">

异步收到：requestId: </span>"e8c501e0-a4e2-4972-a6be-f92539141252"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:ZpOz1YK6e9VOrX69xqNovUXfapY6Ito7z6LlsM6o1Vzeo1hibzvOcxAzYD8hIsOFvGAqk024XbL7yidlgPk4F9GId6ydRxzjjNdg8csxG9FdBXzzr6xuESJ"<span style="color: rgba(0, 0, 0, 1)">

异步收到：requestId: </span>"477cbb82-77c0-4270-b161-555da7b6a5e2"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:Ow81y5qPraVcobOiZ6sCH72jJGNC0784ox5crQYP5fZ6CXoWphRdC9WW4NKSiChbci6aGutnWJbO1HlpR0FV4m9qahbWGkFI0Zr2uvMbuaj8SPpH6X"<span style="color: rgba(0, 0, 0, 1)">

异步收到：requestId: </span>"2c56fc02-5fd8-4c17-bca5-ab0def66493c"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:FzoUaLvHxA0Tm7eU4GL9bIE6mEMNRIUSZILPLiREPXGfhcgoasYd1W5jEfAooE697LQr2DMw6fBdwEqHunQcl6doxrnxSQAZorHztHvyKXAFmbnF3aDkYgO82HaHGXuC"<span style="color: rgba(0, 0, 0, 1)">

异步收到：requestId: </span>"98db5068-1a85-455f-8fea-4b6c8a562776"<span style="color: rgba(0, 0, 0, 1)">
status: </span>200<span style="color: rgba(0, 0, 0, 1)">
data: </span>"Handled:nWnNIaJFt1otie04SWoaoN08f2BOuTMyRbtFuEhj0LiYilRjeKswzqrbKlze30ZBFNIuvEz6P97rP9lM5bkuDYLv1QuKOd1wctfeF9K2RbKh6hvOfgHE5wl2xUk0B6nBFK5fI1sdj3hhoiPLApQZjGzFaSHZGVtLdM4yPBC6BhmsNCPkAo2AxcQ0iZuVEHkihs"</pre>
</div>
<p>&nbsp;</p>
<h2>实现订阅发布</h2>
<p>//TBD</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2516235437951389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-07 17:21">2025-01-07 17:20</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">25</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18653392" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18653392);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18653392', targetLink: 'https://www.cnblogs.com/longfurcat/p/18653392', title: '【编码】如何实现一套自定义网络协议？' })">举报</a>
</div>
        