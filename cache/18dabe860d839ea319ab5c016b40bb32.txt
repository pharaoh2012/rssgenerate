
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18867841" title="发布于 2025-05-09 11:18">
    <span role="heading" aria-level="2">SpringBoot中的拦截器江湖</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>很多小伙伴在工作中遇到拦截需求就无脑写HandlerInterceptor，结果被复杂场景搞得鼻青脸肿。</p>
<p>作为一名有多年开发经验的程序员，今天领大家到SpringBoot的山头认认6把交椅：</p>
<p><img src="https://files.mdnice.com/user/5303/5408302e-9c97-4193-9bc7-2ff9fed5e8c6.png" alt="" loading="lazy"></p>
<p>这篇文章以梁山为背景的介绍SpringBoot中的拦截器，可能更通俗易懂。</p>
<p>希望对你会有所帮助，记得点赞和收藏。</p>
<h2 id="第一把交椅filter">第一把交椅：Filter</h2>
<p>Filter是梁山中的总寨主。</p>
<p><strong>典型战斗场面</strong>：全局鉴权/接口耗时统计</p>
<pre><code class="language-java">@WebFilter("/*") 
public class CostFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
        long start = System.currentTimeMillis();
        chain.doFilter(req, res); // 放行江湖令箭
        System.out.println("接口耗时："+(System.currentTimeMillis()-start)+"ms");
    }
}
</code></pre>
<p><strong>起义缘由</strong>：必须是最高寨主，因为他在Servlet容器滚刀肉层面出手。想当年有个兄弟在Filter里调用Spring Bean，结果NPE错杀千人（要用WebApplicationContextUtils拿Bean才是正解）</p>
<h2 id="第二把交椅handlerinterceptor">第二把交椅：HandlerInterceptor</h2>
<p>HandlerInterceptor是梁山中的二当家。</p>
<p><strong>必杀场景</strong>：接口权限验证/请求参数自动装填</p>
<pre><code class="language-java">public class AuthInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String token = request.getHeader("X-Token");
        if(!"vip666".equals(token)){
            response.setStatus(403);
            return false; // 关门放狗
        }
        return true;
    }
}

// 衙门张贴告示
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/login");
    }
}
</code></pre>
<p><strong>二当家的雷区</strong>：</p>
<ol>
<li>postHandle里修改了Response但内容已提交（注意response.isCommitted()判断）</li>
<li>拦截资源请求要配置静态路径排出（例如/exclude/**）</li>
<li>多拦截器顺序要调准确（Order值越小越早执行）</li>
</ol>
<h2 id="第三把交椅aop拦截器">第三把交椅：AOP拦截器</h2>
<p>AOP是梁山中的军师智多星。</p>
<p><strong>运筹帷幄场景</strong>：服务层方法缓存/事务管理</p>
<pre><code class="language-java">@Aspect
@Component
public class CacheAspect {
    @Around("@annotation(com.example.anno.Cacheable)")
    public Object aroundCache(ProceedingJoinPoint jp) {
        String cacheKey = buildKey(jp);
        Object cacheVal = redisTemplate.opsForValue().get(cacheKey);
        if(cacheVal != null) return cacheVal;
        
        Object result = jp.proceed();
        redisTemplate.opsForValue().set(cacheKey, result, 5, TimeUnit.MINUTES);
        return result;
    }
}
</code></pre>
<p><strong>军师锦囊</strong>：</p>
<ul>
<li>只可拦截Spring管理的Bean（new的对象拦截不了）</li>
<li>与Transactional注解的顺序要注意（建议AOP切面Order大于事务切面）</li>
<li>自定义注解要写在接口方法上才生效（要是实现类方法需要用@within）</li>
</ul>
<h2 id="第四把交椅resttemplate拦截器">第四把交椅：RestTemplate拦截器</h2>
<p>RestTemplate是梁山中的水军头领。</p>
<p><strong>远程战事</strong>：统一添加请求头/加密请求参数</p>
<pre><code class="language-java">public class TraceInterceptor implements ClientHttpRequestInterceptor {
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) {
        request.getHeaders().add("X-TraceId", UUID.randomUUID().toString());
        return execution.execute(request, body);
    }
}

// 注册水军
@Bean 
public RestTemplate restTemplate() {
    RestTemplate rt = new RestTemplate();
    rt.getInterceptors().add(new TraceInterceptor());
    return rt;
}
</code></pre>
<p><strong>总督黑历史</strong>：</p>
<ol>
<li>编码问题：body若是字符串需要自行转字节数组（避免乱码）</li>
<li>多次拦截：拦截器按添加顺序执行（第一个最后执行）</li>
<li>访问HTTPS需要额外配置SSL（记得补上SSLContext）</li>
</ol>
<h2 id="第五把交椅feign拦截器">第五把交椅：Feign拦截器</h2>
<p>Feign拦截器是梁山中的外交使节。</p>
<p><strong>出使外国</strong>：统一签名计算/Header透传</p>
<pre><code class="language-java">public class FeignAuthInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        template.header("Authorization", "Bearer " + SecurityContext.getToken());
    }
}

// 缔结合约
@Configuration
public class FeignConfig {
    @Bean
    public FeignAuthInterceptor feignAuthInterceptor() {
        return new FeignAuthInterceptor();
    }
}
</code></pre>
<p><strong>使节烫手山芋</strong>：</p>
<ul>
<li>GET请求Body丢失问题（要自己特殊处理）</li>
<li>Form表单参数要手动编码（使用feign-form扩展）</li>
<li>Path参数需要Expression表达式解析（动态值要用@Param注明）</li>
</ul>
<h2 id="第六把交椅webfilter">第六把交椅：WebFilter</h2>
<p>WebFilter是梁山中的特种兵。</p>
<p><strong>闪电战场景</strong>：响应式编程统一编码/跨域处理</p>
<pre><code class="language-java">@Component
public class CorsWebFilter implements WebFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().add("Access-Control-Allow-Origin", "*");
        return chain.filter(exchange);
    }
}
</code></pre>
<p><strong>作战条件</strong>：</p>
<ul>
<li>必须在WebFlux环境下（传统MVC无效）</li>
<li>响应式编程模式（函数式声明）</li>
<li>非阻塞管道（异步要配合Mono/Flux）</li>
</ul>
<h2 id="各派武功排行榜">各派武功排行榜</h2>
<table>
<thead>
<tr>
<th>门派</th>
<th>攻击范围</th>
<th>招式复杂度</th>
<th>内力消耗</th>
<th>首选战场</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filter</td>
<td>全局最外层</td>
<td>★★☆☆☆</td>
<td>低</td>
<td>安全校验/日志记录</td>
</tr>
<tr>
<td>Handler</td>
<td>MVC控制器层</td>
<td>★★★☆☆</td>
<td>中</td>
<td>权限控制</td>
</tr>
<tr>
<td>AOP</td>
<td>业务方法级</td>
<td>★★★★☆</td>
<td>高</td>
<td>缓存/事务</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>HTTP客户端</td>
<td>★★★☆☆</td>
<td>中</td>
<td>服务间调用</td>
</tr>
<tr>
<td>Feign</td>
<td>声明式客户端</td>
<td>★★★★☆</td>
<td>高</td>
<td>微服务通信</td>
</tr>
<tr>
<td>WebFilter</td>
<td>响应式全链路</td>
<td>★★★★★</td>
<td>极高</td>
<td>WebFlux应用</td>
</tr>
</tbody>
</table>
<h2 id="武林秘笈">武林秘笈</h2>
<h3 id="1-顺序就是力量">1. 顺序就是力量</h3>
<p>Filter -&gt; Interceptor -&gt; AOP ，越早拦截越省力（但别在Filter里做业务）</p>
<h3 id="2-量力而行选兵器">2. 量力而行选兵器</h3>
<ul>
<li>简单鉴权用HandlerInterceptor</li>
<li>方法级管控上AOP</li>
<li>微服务用FeignInterceptor</li>
</ul>
<h3 id="3-性能损耗要监控">3. 性能损耗要监控</h3>
<p>用Arthas监控拦截链路耗时，避免拦截器连环夺命call</p>
<pre><code class="language-java"># 查看HandlerInterceptor耗时
trace *.preHandle '#cost&gt;10'
 
# 诊断AOP切面
watch com.example.aop.*Aspect * '{params,returnObj}' -x 3
</code></pre>
<p>最后送给各位江湖儿女一句话：<strong>拦截是门艺术，别让好刀砍了自己人！</strong></p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。<br>
求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的50万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5437574734108797" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-09 11:18">2025-05-09 11:18</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">188</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18867841);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18867841', targetLink: 'https://www.cnblogs.com/12lisu/p/18867841', title: 'SpringBoot中的拦截器江湖' })">举报</a>
</div>
        