
        <div class="postTitle">
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mysticbinary/p/18818605" title="发布于 2025-04-11 14:53">
    <span role="heading" aria-level="2">Python 迭代器和生成器概念</span>
    

</a>

        </div>
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#迭代器的介绍" rel="noopener nofollow">迭代器的介绍</a></li><li><a href="#自定义迭代器" rel="noopener nofollow">自定义迭代器</a></li><li><a href="#省略的迭代器" rel="noopener nofollow">省略的迭代器</a></li><li><a href="#生产器的介绍" rel="noopener nofollow">生产器的介绍</a></li><li><a href="#yield的普通用法" rel="noopener nofollow">yield的普通用法</a></li><li><a href="#yield的高级用法" rel="noopener nofollow">yield的高级用法</a></li><li><a href="#yidle的实际应用案例" rel="noopener nofollow">yidle的实际应用案例</a></li><li><a href="#总结" rel="noopener nofollow">总结</a></li></ul></div><p></p>
<hr>
<h1 id="迭代器的介绍">迭代器的介绍</h1>
<p><strong>迭代器的定义：</strong><br>
迭代器（Iterator）是 Python 中用于<strong>遍历数据集合</strong>的核心机制。它提供了一种统一的方式来访问容器（如列表、字典、文件等）中的元素，而无需关心底层数据结构的具体实现。迭代器的核心特点是<strong>按需生成数据</strong>，避免一次性加载所有数据到内存。</p>
<p>迭代器适合处理大型数据、无限序列或需要惰性计算的场景。</p>
<hr>
<p><strong>迭代器的核心概念：</strong></p>
<ol>
<li>
<p><strong>迭代器协议</strong>：</p>
<ul>
<li>一个对象要成为迭代器，必须实现以下两个方法：
<ul>
<li><code>__iter__()</code>：返回迭代器对象本身（通常直接 <code>return self</code>）。</li>
<li><code>__next__()</code>：返回下一个元素，若没有更多元素则抛出 <code>StopIteration</code> 异常。</li>
</ul>
</li>
<li>Python 的 <code>for</code> 循环、<code>next()</code> 函数等底层都依赖这一协议。</li>
</ul>
</li>
<li>
<p><strong>可迭代对象（Iterable） VS 迭代器（Iterator）</strong>：</p>
<ul>
<li><strong>可迭代对象</strong>：实现了 <code>__iter__()</code> 方法，可以返回一个迭代器的对象（如列表、元组、字典）。</li>
<li><strong>迭代器</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。</li>
<li>所有迭代器都是可迭代对象，但可迭代对象本身不一定是迭代器。</li>
</ul>
<p>差异体现在遍历机制：</p>
<ul>
<li>
<p><strong>可迭代对象</strong>：<br>
每次调用 <code>iter()</code> 会生成<strong>新的迭代器</strong>，因此可被多次遍历：</p>
<pre><code class="language-python">my_list = [1, 2, 3]
for x in my_list: print(x)  # 输出 1,2,3
for x in my_list: print(x)  # 再次输出 1,2,3
</code></pre>
</li>
<li>
<p><strong>迭代器</strong>：<br>
遍历是<strong>一次性</strong>的，遍历完成后无法重置：</p>
<pre><code class="language-python">iterator = iter(my_list)
for x in iterator: print(x)  # 输出 1,2,3
for x in iterator: print(x)  # 无输出（迭代器已耗尽）
</code></pre>
</li>
</ul>
</li>
</ol>
<h1 id="自定义迭代器">自定义迭代器</h1>
<p><strong>示例 1：</strong> 通过类实现迭代器</p>
<pre><code class="language-python">class CountUpTo:
    def __init__(self, max_num):
        self.max_num = max_num
        self.current = 0

    def __iter__(self):
        return self  # 返回迭代器本身

    def __next__(self):
        if self.current &lt; self.max_num:
            self.current += 1
            return self.current
        else:
            raise StopIteration  # 终止迭代

# 使用自定义迭代器
counter = CountUpTo(3)
for num in counter:
    print(num)  # 输出 1, 2, 3
</code></pre>
<p><strong>示例 2：</strong> 通过生成器函数实现（简化版）<br>
生成器函数（使用 <code>yield</code>）是创建迭代器的快捷方式：</p>
<pre><code class="language-python">def count_up_to(max_num):
    current = 0
    while current &lt; max_num:
        current += 1
        yield current

# 生成器返回的也是迭代器
for num in count_up_to(3):
    print(num)  # 输出 1, 2, 3
</code></pre>
<hr>
<h1 id="省略的迭代器">省略的迭代器</h1>
<p>写过for循环的都知道，我没用迭代器呀！<br>
用了！只不过是编译器帮你用了。</p>
<p>以下两段代码完全等价：</p>
<pre><code class="language-python"># 直接遍历列表
my_list = [1, 2, 3, 4, 5]
for x in my_list:
    print(x)
</code></pre>
<pre><code class="language-python"># 等价的手动迭代器操作
iterator = iter(my_list)  # 自动调用 __iter__() 获取迭代器
while True:
    try:
        x = next(iterator)  # 自动调用 __next__()
        print(x)
    except StopIteration:
        break  # 自动处理终止
</code></pre>
<p>为什么不需要显式写迭代器？</p>
<ul>
<li>
<p>语法糖（Syntactic Sugar）：for 循环是 Python 提供的一种简化语法，隐藏了迭代器的创建和异常处理细节。</p>
</li>
<li>
<p>统一接口：所有可迭代对象（如列表、元组、字典、集合、字符串等）都可以通过 for 循环统一处理，无需关心底层是列表还是其他数据结构。</p>
</li>
</ul>
<h1 id="生产器的介绍">生产器的介绍</h1>
<p>yield是个英文动词，也是名词，含义是生产的意思。<br>
<img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250411100956000-1185468998.png" alt="image" loading="lazy"></p>
<p>yield 在 Python里就是生成器。</p>
<p><strong>yield的定义：</strong><br>
Python 的 yield 关键字用于定义生成器函数（Generator Function），生成器是一种特殊的迭代器，能够按需生成值并暂停/恢复执行状态。它的核心特性是惰性求值（Lazy Evaluation），适用于处理大数据流、无限序列或需要节省内存的场景。</p>
<p><strong>核心概念：</strong></p>
<ol>
<li>
<p><strong>生成器函数</strong>：</p>
<ul>
<li>使用 <code>yield</code> 代替 <code>return</code> 的函数。</li>
<li>调用生成器函数时，返回一个<strong>生成器对象</strong>（迭代器），而非直接执行函数体。</li>
<li>生成器通过 <code>next()</code> 或 <code>for</code> 循环逐步执行，每次遇到 <code>yield</code> 时暂停，返回 <code>yield</code> 后的值，并在下次调用时从暂停处继续执行。</li>
</ul>
</li>
<li>
<p><strong>与普通函数的区别</strong>：</p>
<ul>
<li>普通函数一次执行完毕，返回一个结果。</li>
<li>生成器函数逐步产生多个值，并在 <code>yield</code> 处保持状态。</li>
</ul>
</li>
</ol>
<p>与 <strong>return</strong> 的区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>yield</code></th>
<th><code>return</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值数量</td>
<td>可多次返回值</td>
<td>仅返回一次</td>
</tr>
<tr>
<td>函数状态</td>
<td>暂停并保留状态</td>
<td>终止函数执行</td>
</tr>
<tr>
<td>返回类型</td>
<td>生成器对象（迭代器）</td>
<td>直接返回值</td>
</tr>
<tr>
<td>内存占用</td>
<td>低（按需生成）</td>
<td>高（一次性生成所有数据）</td>
</tr>
</tbody>
</table>
<h1 id="yield的普通用法">yield的普通用法</h1>
<p><strong>示例 1：</strong> 简单生成器</p>
<pre><code class="language-python">def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # 输出 1
print(next(gen))  # 输出 2
print(next(gen))  # 输出 3
# 继续调用 next(gen) 会抛出 StopIteration 异常
</code></pre>
<p><strong>示例 2：</strong> 用 <code>for</code> 循环遍历生成器</p>
<pre><code class="language-python">def count_up_to(n):
    i = 0
    while i &lt; n:
        yield i
        i += 1

for num in count_up_to(5):
    print(num)  # 输出 0, 1, 2, 3, 4
</code></pre>
<h1 id="yield的高级用法">yield的高级用法</h1>
<ol>
<li>
<p><strong>通过 <code>send()</code> 传递值</strong><br>
生成器可以通过 <code>send(value)</code> 接收外部传入的值，赋值给 <code>yield</code> 表达式：</p>
<pre><code class="language-python">def generator_with_send():
	value = yield "Ready to receive"
	yield f"Received: {value}"

gen = generator_with_send()
print(next(gen))         # 输出 "Ready to receive"
print(gen.send("Hello")) # 输出 "Received: Hello"
</code></pre>
</li>
<li>
<p><strong><code>yield from</code> 委托生成</strong><br>
Python 3.3+ 引入 <code>yield from</code>，用于简化嵌套生成器的操作：</p>
<pre><code class="language-python">def sub_generator():
	yield "A"
	yield "B"

def main_generator():
	yield from sub_generator()
	yield "C"

for item in main_generator():
	print(item)  # 输出 A, B, C
</code></pre>
</li>
<li>
<p><strong>异常处理</strong><br>
生成器可以通过 <code>throw()</code> 方法接收异常：</p>
<pre><code class="language-python">def generator_with_exception(value):
	try:
		yield 10 / value
	except ZeroDivisionError as e:
		yield "Caught ValueError"


gen = generator_with_exception(2)
print(next(gen))

gen = generator_with_exception(0)
print(next(gen))
</code></pre>
<p>out:</p>
<pre><code>5.0
Caught ValueError
</code></pre>
</li>
</ol>
<h1 id="yidle的实际应用案例">yidle的实际应用案例</h1>
<ol>
<li>
<p><strong>大数据处理</strong>：</p>
<pre><code class="language-python">def read_large_file(file_path):
    with open(file_path, "r") as file:
        for line in file:
            yield line.strip()  # 逐行生成，避免一次性加载到内存

for line in read_large_file("data.txt"):
    process(line)
</code></pre>
</li>
<li>
<p><strong>生成无限序列</strong>：</p>
<pre><code class="language-python">def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
print([next(fib) for _ in range(10)])  # 前10个斐波那契数
</code></pre>
</li>
<li>
<p><strong>协程（Coroutine）</strong>：</p>
<pre><code class="language-python">def coroutine():
    while True:
        task = yield
        print(f"Processing: {task}")

worker = coroutine()
next(worker)       # 启动协程
worker.send("Task1")  # 输出 "Processing: Task1"
worker.send("Task2")  # 输出 "Processing: Task2"
</code></pre>
<p>在 Python 中，协程（Coroutine） 是一种可以暂停和恢复执行的函数，它能与调用方进行双向通信（接收和发送数据），常用于实现协作式多任务（非抢占式任务切换）。</p>
<p>上文提供的代码是一个典型的基于生成器的协程（Generator-based Coroutine）。</p>
</li>
</ol>
<h1 id="总结">总结</h1>
<p><code>yield</code> 是 Python 中实现<strong>惰性计算</strong>和<strong>协程</strong>的核心工具，结合 <code>send()</code>、<code>throw()</code>、<code>close()</code> 等方法，能够构建高效、灵活的数据流和控制流模型。</p>

</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.06052220459375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-11 14:54">2025-04-11 14:53</span>&nbsp;
<a href="https://www.cnblogs.com/mysticbinary">Mysticbinary</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18818605" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18818605);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18818605', targetLink: 'https://www.cnblogs.com/mysticbinary/p/18818605', title: 'Python 迭代器和生成器概念' })">举报</a>
</div>
    