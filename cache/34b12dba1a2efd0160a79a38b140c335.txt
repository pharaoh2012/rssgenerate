
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/songyao666/p/18707544" title="发布于 2025-02-10 11:52">
    <span role="heading" aria-level="2">深入剖析Base64加解密中遇到的坑点</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>最近开发过程中遇到了关于使用<code>base64</code>加密传输遇到的神奇问题。需求就是用户的<code>id</code>在链接上露出时需要加密处理，于是后端把下发的用户<code>id</code>改成了<code>base64</code>加密处理后下发了，前端只需要把加密后的用户<code>id</code>原样传给后端就行。就是这个看似简单的流程，前端啥也没干只是原样透传，但后端有概率拿到的用户<code>id</code>不对。</p>
<h2 id="问题描述">问题描述</h2>
<p>本地写个后端服务模拟当时的情景：</p>
<p>后端框架：<code>nest</code></p>
<pre><code class="language-js">@Get('getUserInfo') 
getUserInfo(@Req() req) {
  const query = req.query
  const cookie = req.cookies
  console.log('cookie', cookie)
  // 优先取参数中的userId，没有则取cookie中的uid
  const userId = query.userId || cookie.uid
  // base64加密
  const token = Buffer.from(userId).toString('base64')
  console.log('加密后的token', token)
  // 返回base64加密后的token
  return {
    code: 0,
    data: {
      userId,
      // base64加密
      token
    }
  }
}
</code></pre>
<p>前端请求后：</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210114909582-1577003206.png" alt="" loading="lazy"></p>
<p>服务这边能够正常拿到cookie并使用base64加密，然后把加密后的token返回给前端</p>
<p>前端也正常拿到了后端返回的加密后的token</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210114921481-1556470067.png" alt="" loading="lazy"></p>
<p>最后前端只需要在用户分享时把加密的token带在链接上，从这个链接进入时再把链接上加密的<code>token</code>带给后端即可，中间不需要做任何处理。</p>
<p>就是这个过程，出现了奇怪的现象，绝大多数用户都是OK，但是会有一些用户的token带给后端时，后端解不出来了。</p>
<p>心想这跟前端好像没啥关系，因为前端压根没处理后端返回的<code>token</code>，后端给我啥，我只是原样给他传了啥。</p>
<p><strong>经排查发现，所有有问题的用户id都是加密后的<code>token</code>中包含了<code>+</code>符号</strong></p>
<p>比如这样的：<code>zm+3DQ/gYeMzQ/HM2L76+CA==</code>传到后端时，所有的<code>+</code>都变成了空格，导致后端解出来是错的</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210114932241-1294455996.png" alt="" loading="lazy"></p>
<h2 id="url是如何进行编码的">URL是如何进行编码的</h2>
<p>这个问题的主要原因还是因为URL被编码造成的，由于请求是<code>get</code>请求，所以最终所有的参数都是拼接在链接上的，最开始前端传给后端的<code>token</code>是没有经过编码的，那它为什么自己编码了？并且编码后与预期的还不一致？</p>
<p>由于种种历史原因，RFC与W3C都定义过URL的编码标准</p>
<h3 id="rfc规范">RFC规范</h3>
<p>在RFC3986中提到：除了 <code>数字</code> 、 <code>字母</code> 、<code> -_.~</code> 不会被转义，其他字符都会被以<code>百分号（%）后跟两位十六进制数 %{hex}</code> 的方式进行转义。在这个规则中<code>空格</code>会被转为<code>%20</code>，而<code>+</code>会被转为<code>%2B</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210114945217-2044897389.png" alt="" loading="lazy"></p>
<h3 id="w3c规范">W3C规范</h3>
<p>在W3C规范中却又说空格可以被编码为<code>+</code>或<code>%20</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210114956198-855198485.png" alt="" loading="lazy"></p>
<p>为什么会同时存在两种规范，这不是在挖坑吗？</p>
<blockquote>
<p>因为URL中不能存在空格，所以在URL中的空格会自动替换成<code>+</code>或<code>%20</code></p>
</blockquote>
<p>这就是上面出现+变空格的原因，在你不确定正在以哪一个规范进行编解码时，就很容易出现这个问题。它可能是浏览器造成的，也可能是开发语言的规范不同造成的。</p>
<p>比如Google搜索：</p>
<p>当我们搜索<code>s+2</code>时，地址栏出现的是<code>s%2B2</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115007631-193302057.png" alt="" loading="lazy"></p>
<p>当我们搜索<code>s 2</code>时，地址栏出现的却是<code>s+2</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115018241-1437461386.png" alt="" loading="lazy"></p>
<blockquote>
<p>这里就是空格被编码为<code>+</code>了，你要是不了解<code>W3C</code>这条规范，是不是觉得匪夷所思了🤔</p>
</blockquote>
<h2 id="前端编码规范">前端编码规范</h2>
<p>在JS中对字符串进行编码的方法有三个：<code>escape</code>、<code>encodeURI</code>、<code>encodeURIComponent</code></p>
<blockquote>
<p><code>escape</code>已经被废弃了，不再推荐使用，所以我们这里只需要关注后面两个的区别</p>
</blockquote>
<h3 id="encodeuri">encodeURI</h3>
<blockquote>
<p>该函数只会编码URI中完全禁止的字符。该函数的目的是对URI进行完整的编码，因此对以下在URI中具有特殊含义的 ASCII 标点符号，<code>encodeURI</code>是不会进行转义的(;/?😡&amp;=+$,#)</p>
</blockquote>
<p>所以对于<code>encodeURI</code>来说，空格会被编码为<code>%20</code>，但是<code>+</code>并不会编码。因为空格是URI中禁止的字符，而<code>+</code>不是</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115029691-661417361.png" alt="" loading="lazy"></p>
<p>总结来说就是：</p>
<blockquote>
<p>encodeURL除了这些<strong>A-Z a-z 0-9 ; , / ? : @ &amp; = + $ – _ . ! ~ * ‘ ( ) #</strong> 不会被编码，其余字符都会被编码</p>
</blockquote>
<h3 id="encodeuricomponent">encodeURIComponent</h3>
<blockquote>
<p>功能与encodeURI类似，但是<code>encodeURIComponent</code>编码的范围更广，并且该函数一般用于对URI的参数部分进行编码</p>
</blockquote>
<p>对于<code>encodeURIComponent</code>来说，空格会被编码为<code>%20</code>，<code>+</code>会被编码为<code>%2B</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115042682-2072739761.png" alt="" loading="lazy"></p>
<p>总结来说就是：</p>
<blockquote>
<p>encodeURLComponent除了这些<strong>A-Z a-z 0-9 - _ . ! ~ * ' ( )</strong> 不会被编码，其余字符都会被编码</p>
</blockquote>
<h3 id="两者使用场景的差异">两者使用场景的差异</h3>
<ul>
<li>当encode的内容不作为URI参数时，使用<code>encodeURI</code>进行编码</li>
</ul>
<pre><code class="language-js">const url = encodeURI('https://www.qidian.com')
// 'https://www.qidian.com'
</code></pre>
<ul>
<li>当encode的内容作为URI参数时，使用<code>encodeURIComponent</code>进行编码</li>
</ul>
<pre><code class="language-js">const deepLink = `weixin://webview?url=${encodeURIComponent('https://www.baidu.com')}`
//  weixin://webview?url=https%3A%2F%2Fwww.baidu.com
</code></pre>
<h3 id="结论">结论</h3>
<p>对于JS的编码方法来说，只有<code>encodeURIComponent</code>会对<code>+</code>进行编码，并且编码规范是<code>RFC3986</code>，也就是说使用这个方法<code>空格</code>会被转为<code>%20</code>，而<code>+</code>会被转为<code>%2B</code>。从而也就不会出现<code>+</code>变空格或空格变<code>+</code>的问题。</p>
<h2 id="上述问题是如何产生的">上述问题是如何产生的？</h2>
<p>上面分别介绍了URL的编码规范，以及前端编码方法应用的规范。<strong>总结下来就是<code>空格</code>不会在前端产生，前端应用的编码规范不会将空格编码成<code>+</code>，也不会把<code>+</code>解码成空格。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115055468-1186196641.png" alt="" loading="lazy"></p>
<p>并且特意写了个<code>node</code>服务来模拟当时的场景。</p>
<p>结论是：只要传给后端的<code>base64</code>字符串在前端经过了编码就不会有问题。因为上面我们介绍过浏览器的编码规范，确实是会存在<code>+</code>变空格的问题。所以我们需要主动编码，不要把编码的机会留给浏览器。</p>
<ol>
<li>前端编码了，后端拿到的也是正常的</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115107812-284049970.png" alt="" loading="lazy"></p>
<ol start="2">
<li>没编码，后端拿到的<code>+</code>变成空格了</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115124774-369948396.png" alt="" loading="lazy"></p>
<p>所以当时前端未进行编码时，从CURL中就能看到<code>+</code>已经变成了空格，但后面前端编码后，curl看是正常的，后端解码出来却还是有问题的。</p>
<p>我这边怎么都复现不了<strong>当时传给后端是编码过的<code>base64</code>字符串，后端拿到的却还是<code>+</code>变成了空格</strong></p>
<p>没办法，只好找后端同学问问他当时是怎么解码的...</p>
<p>经过一番验证后，结论是他那边多解码了一次，他们框架层有一次自动解码</p>
<pre><code class="language-js">'zm%2B3DQ%2FgYeMzQ%2FHM2L76CA%3D%3D'   ----&gt;  'zm+3DQ/gYeMzQ/HM2L76CA=='
</code></pre>
<p>实际上这里就已经是正确的了，但后端同学又自己解码了一次，按理来说再次解码应该也不会有问题</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115136533-685409205.png" alt="" loading="lazy"></p>
<p>但是！！！这是因为<code>javascript</code>遵循的是<code>RFC3986</code>规范，但<code>java</code>好像并不是</p>
<p><code>java</code>自带的<code>decode</code>方法底层是这样实现的</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202502/1525717-20250210115146580-422886622.png" alt="" loading="lazy"></p>
<p>这里是按<code>W3C</code>的规范，由于<code>URL</code>中不能存在<code>空格</code>，所以<code>URL Encode</code> 会把<code>空格</code>替换成<code>+</code>，然后解码也同样会将<code>+</code>替换成<code>空格</code>。真相了....</p>
<h2 id="解决方案">解决方案</h2>
<ul>
<li>按理来说我们只需要保证传给后端的<code>+</code>字符按<code>RFC3986</code>规范编码成了<code>%2B</code>就不会有问题，不要把编码的机会留给浏览器，在JS中只需调用<code>encodeURIComponent</code>即可</li>
<li>后端接收到带空格的<code>base64</code>字符串时，通过正则将空格替换为<code>+</code>，因为<code>base64</code>中不会出现空格</li>
<li>由于标准<code>Base64</code>编码包含64个字符<code>A-Z, a-z,0-9,+,/,=</code>，有一种URL safe的<code>base64</code>格式，把其中的<code>+</code>,<code>/</code>换成<code>-</code>,<code>_</code>，也能够解决上面的问题。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div style="color: blueviolet">
<div>作者：<a href="https://bettersong.github.io/nanjiu/">前端南玖</a></div>
<div>出处：<a href="https://www.cnblogs.com/songyao666/">https://www.cnblogs.com/songyao666/
</a></div>
<div>每日面试题：<a href="https://github.com/bettersong/interview" target="new">Github</a></div>
<p>-------------------------------------------</p>
<p>如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 前端南玖 第一时间获取最新的文章～</p>
<p>扫描下方二维码关注公众号，回复进群，拉你进前端学习交流群</p>
<div style="display:flex">
<img src="https://blog-static.cnblogs.com/files/songyao666/nanjiu.gif?t=2" alt="逐梦wx" width="380" height="190">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.017884008391203705" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 11:52">2025-02-10 11:52</span>&nbsp;
<a href="https://www.cnblogs.com/songyao666">前端南玖</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18707544" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18707544);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18707544', targetLink: 'https://www.cnblogs.com/songyao666/p/18707544', title: '深入剖析Base64加解密中遇到的坑点' })">举报</a>
</div>
        