
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fiveyobody/p/19005976/go-pprof" title="发布于 2025-07-26 13:10">
    <span role="heading" aria-level="2">Golang 性能分析神器 pprof 详解与实践（图文教程）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Golang 性能分析神器 pprof 详解与实践（图文教程）
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一简介">一、简介</h2>
<p>pprof（性能剖析工具）是 Go 语言标准库提供的用于 go 程序性能分析的工具。可以帮助你分析程序在 CPU使用率、内存堆栈分配、内存占用、协程、锁等方面的表现并且生成相应的性能分析报告。<strong>零侵入性</strong>，无需修改服务代码，导入即可生效，<strong>生产级安全</strong>，采样开销极低，并且具有可视化界面帮助开发者快速定位问题</p>
<h2 id="二用法">二、用法</h2>
<h3 id="一开启-pprof">（一）开启 pprof</h3>
<p>首先，导入包</p>
<pre><code class="language-go">import (
    _ "net/http/pprof"
)
</code></pre>
<p>然后，开启一个 http 服务方便获取性能数据</p>
<pre><code class="language-go">go func() {
        logs.Info(http.ListenAndServe(":30552", nil))
    }()
</code></pre>
<p>完整参考代码例子</p>
<pre><code class="language-go">import _ "net/http/pprof"
func StartPprof() {
    go func() {
        logs.Info(http.ListenAndServe(":30552", nil)) // 表示启动端口为 30552 的 pprof 服务
    }()
}
func main(){

  ....

  // 开启 pprof 性能服务
  StartPprof() 

  // 启动自己的程序
  err = router.Run(address)
    if err != nil {
        panic(err)
    }
  ....
}
</code></pre>
<h3 id="二用法一直接访问">（二）用法一：直接访问</h3>
<p>直接访问 pprof 服务提供的接口</p>
<pre><code class="language-bash"># pprof 的入口首页
http://0.0.0.0:30552/debug/pprof/ 
</code></pre>
<p><img alt="pprof" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130935106-37564512.png" class="lazyload"></p>
<p><strong>常用的功能界面如下：</strong></p>
<pre><code class="language-bash">http://0.0.0.0:30552/debug/pprof/heap?debug=1 # 内存堆栈分析（哪些函数一直占用内存）

http://0.0.0.0:30552/debug/pprof/allocs?debug=1 # 内存分配分析（哪些函数在分配内存）

http://0.0.0.0:30552/debug/pprof/goroutine?debug=1 # 协程的情况（总览）
http://0.0.0.0:30552/debug/pprof/goroutine?debug=2 # 协程的具体阻塞堆栈情况

http://0.0.0.0:30552/debug/pprof/block?debug=1   # 阻塞分析
http://0.0.0.0:30552/debug/pprof/block?debug=2   # 阻塞分析

http://0.0.0.0:30552/debug/pprof/mutex?debug=1  # 锁分析
http://0.0.0.0:30552/debug/pprof/mutex?debug=2  # 锁分析
</code></pre>
<p>⚠️：注意加上参数 debug ，否则访问会直接下载文件，debug=2 展示的信息更全</p>
<h3 id="三用法二go-tool-pprof推荐">（三）用法二：go tool pprof（推荐）</h3>
<p>直接访问展示是纯文本，不是很直观，所以我们可以使用 go tool pprof 工具展示火焰图，更佳直观的排查问题</p>
<blockquote>
<p>需要安装渲染工具：graphviz ；才能正常展示火焰图</p>
<p>graphviz 安装步骤请移步文章：<a href="https://blog.fiveyoboy.com/articles/graphviz-install/" target="_blank" rel="noopener nofollow">开源的图形可视化工具graphviz安装教程</a></p>
</blockquote>
<p>使用方式：</p>
<pre><code class="language-bash">go tool pprof &lt;参数&gt; &lt;pprof 数据&gt;

# eg：开启 8081 服务展示：采样时间为 60s 的 CPU 耗时数据
# go tool pprof -http=0.0.0.0:8081 -seconds=60 http://0.0.0.0:30552/debug/pprof/profile
</code></pre>
<ul>
<li>
<p>&lt;<strong>参数</strong>&gt;：</p>
<ul>
<li>
<p><strong>-http=</strong>  指定一个 ip:port ,启动一个web服务来展示，若未指定，则会下载 xxx.pb.gz 文件，并进入【控制台 cmd 模式】</p>
</li>
<li>
<p><strong>-seconds=</strong> 指定采样时间，比如 -seconds=60, 表开始采样 60s 的数据，若未指定，则表示进 程启动以来的总数据</p>
</li>
</ul>
</li>
<li>
<p>&lt;<strong>pprof 数据</strong>&gt;：</p>
</li>
</ul>
<p>​    可以是 pprof 提供的接口，比如 <code>http://0.0.0.0:30552/debug/pprof/profile</code></p>
<p>​    也可以是 pprof 数据文件：比如 xxx.pb.gz</p>
<p>pporf 数据文件可以通过：go tool pprof 下载</p>
<pre><code class="language-bash"># 直接访问可以下载
go tool pprof http://0.0.0.0:30552/debug/pprof/profile # CPU 耗时分析
go tool pprof http://0.0.0.0:30552/debug/pprof/heap # 内存堆栈分析（哪些函数一直占用内存）
go tool pprof http://0.0.0.0:30552/debug/pprof/allocs # CPU 耗时分析
go tool pprof http://0.0.0.0:30552/debug/pprof/goroutine # 协程的情况
go tool pprof http://0.0.0.0:30552/debug/pprof/block   # 阻塞分析
go tool pprof http://0.0.0.0:30552/debug/pprof/mutex  # 锁分析
</code></pre>
<blockquote>
<p>执行后会保存 xxx.pb.gz 文件，同时进入【控制台 cmd 模式】</p>
</blockquote>
<p><strong>常见的指标分析命令如下：</strong></p>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/profile # CPU 耗时分析

go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/heap # 内存堆栈分析（哪些函数一直占用内存）

go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/allocs # 内存分配分析（哪些函数在分配内存）

http://0.0.0.0:30552/debug/pprof/goroutine?debug=1 # 协程的情况（总览）
http://0.0.0.0:30552/debug/pprof/goroutine?debug=1 # 协程的具体阻塞堆栈情况


http://0.0.0.0:30552/debug/pprof/block?debug=1   # 阻塞分析
http://0.0.0.0:30552/debug/pprof/block?debug=2   # 阻塞分析

http://0.0.0.0:30552/debug/pprof/mutex?debug=1  # 锁分析
http://0.0.0.0:30552/debug/pprof/mutex?debug=2  # 锁分析
</code></pre>
<p>以上是常见的指标分析命令，后续步骤会对每个命令展示的界面进行详细说明</p>
<h2 id="三cpu-耗时分析">三、CPU 耗时分析</h2>
<p>分析哪些函数耗时比较久</p>
<h3 id="一参考命令">（一）参考命令</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/profile # CPU 耗时分析
</code></pre>
<blockquote>
<p>浏览器会自动（手动）打开 0.0.0.0:8081/ui</p>
<p>这里不加 -seconds=，直接查看进程启动以来的 CPU 耗时数据</p>
</blockquote>
<h3 id="二火焰图分析">（二）火焰图分析</h3>
<p><strong>火焰图如下：</strong></p>
<p><img alt="CPU耗时分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130935332-71644606.png" class="lazyload"></p>
<p><strong>关于图形的说明</strong>：</p>
<ul>
<li>
<p><strong>框</strong>：每个框代表一个函数，理论上框的越大颜色越深表示占用的CPU资源越多。</p>
</li>
<li>
<p><strong>框的颜色</strong>：红色表示新增，绿色表示减少，颜色深度表示占用 CPU 资源的多少，比如越红表示 CPU 占用越多</p>
</li>
<li>
<p><strong>框的粗细</strong>：和颜色一样，越粗，表示占用 CPU 资源的多少，比如又红又粗，则表示 CPU 占用越多</p>
</li>
<li>
<p><strong>箭头</strong>：常见几种如下表</p>
<table>
<thead>
<tr>
<th style="text-align: center">示例</th>
<th style="text-align: center">含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><strong>普通调用箭头</strong></td>
<td style="text-align: center"><code>FuncA ──→ FuncB</code></td>
<td>显示函数直接调用关系</td>
</tr>
<tr>
<td style="text-align: center"><strong>带资源分配标签的箭头</strong></td>
<td style="text-align: center"><code>FuncA ── 50ms → FuncB</code></td>
<td>FuncA 调用 FuncB 的过程中耗时 50ms</td>
</tr>
<tr>
<td style="text-align: center"><strong>虚箭头/虚线箭头</strong></td>
<td style="text-align: center"><code>FuncA ···→ runtime.mallocgc</code></td>
<td>编译器隐式插入的耗时操作</td>
</tr>
<tr>
<td style="text-align: center"><strong>双向箭头</strong></td>
<td style="text-align: center">FuncA &lt;──&gt; FuncB</td>
<td><strong>相互调用</strong>，循环调用，这种可能存在潜在风险</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>(inline)</strong>：表示该函数在编译时被<strong>内联优化 (Inlining)</strong>处理了</p>
</li>
<li>
<p><strong>框中数字的含义</strong>：</p>
<p><img alt="函数耗时分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130934156-456428942.png" class="lazyload"></p>
</li>
</ul>
<h3 id="三指标分析">（三）指标分析</h3>
<p>访问  <code>0.0.0.0:8081/ui/top</code></p>
<p><img alt="CPU指标分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130933060-862603866.png" class="lazyload"></p>
<p>结果和火焰图是一致的，只是展示方式不一样</p>
<p><strong>指标说明：</strong></p>
<ol>
<li>flat：指定函数直接执行的时间，即不考虑它调用的任何其他函数的时间。以ms毫秒为单位进行测量。</li>
<li>flat%：（函数直接执行时间）/ （总执行时间），即 flat / sum * 100。</li>
<li>sum%：（函数总执行时间）/ （总执行时间），即（flat + 子函数执行时间）/ sum * 100。</li>
<li>cum：函数总的执行时间，即包括它调用的所有子函数的执行时间。以ms毫秒为单位进行测量。</li>
<li>cum%：（函数总的执行时间）/ 总执行时间，即（cumulative time for function）/ sum * 100。</li>
</ol>
<h3 id="四总结">（四）总结</h3>
<ul>
<li>
<p>查看火焰图：<code>哪个框又红又粗</code>，就是耗时最多的函数，通过函数之间的调用链（箭头）快速定位到函数所在的代码，</p>
<p>​            然后进行优化（见文末【<strong>常见优化措施</strong>】）</p>
</li>
<li>
<p>查看 <code>top</code> 视图：若火焰图不太能定位函数代码实际位置，可以查看 top 视图，会展示问题函数所在的代码文件</p>
</li>
</ul>
<h2 id="四内存堆栈分析">四、内存堆栈分析</h2>
<p>分析哪些函数一直在占用内存（常驻内存）</p>
<h3 id="一命令">（一）命令</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/heap
</code></pre>
<blockquote>
<p>浏览器会自动（手动）打开 0.0.0.0:8081/ui</p>
<p>这里不加 -seconds=，直接查看进程启动以来的内存堆栈数据</p>
</blockquote>
<h3 id="二火焰图分析-1">（二）火焰图分析</h3>
<p><img alt="pprof 内存堆栈分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130933853-674016338.png" class="lazyload"></p>
<h3 id="三指标分析-1">（三）指标分析</h3>
<p><img alt="pprof 内存堆栈指标分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130932718-2005212469.png" class="lazyload"></p>
<blockquote>
<p>该图为样例图，和上面的火焰图不是同一个采样数据，因此数据是对不上的</p>
</blockquote>
<ol>
<li>flat：函数直接执行的堆栈内存，即不考虑它调用的任何其他函数的时间。以kb为单位进行测量。</li>
<li>flat%：（函数直接执行堆栈内存）/ （总执行堆栈内存），即 flat / sum * 100。</li>
<li>sum%：（函数总执行堆栈内存）/ （总执行堆栈内存），即（flat + 子函数执行堆栈内存）/ sum * 100。</li>
<li>cum：函数总的执行堆栈内存，即包括它调用的所有子函数的执行堆栈内存。以kb为单位进行测量。</li>
<li>cum%：（函数总的执行堆栈内存）/ 总执行堆栈内存，即 cum / sum * 100。</li>
</ol>
<h3 id="四总结-1">（四）总结</h3>
<ul>
<li>
<p>查看火焰图：<code>哪个框又红又粗</code>，就是堆栈内存（常驻）最多的函数，通过函数之间的调用链（箭头）快速定位到函数所在的代码，</p>
<p>​            然后进行优化（见文末【<strong>常见优化措施</strong>】）</p>
</li>
<li>
<p>查看 <code>top</code> 视图：若火焰图不太能定位函数代码实际位置，可以查看 top 视图，会展示问题函数所在的代码文件</p>
</li>
</ul>
<h2 id="五内存分配分析">五、内存分配分析</h2>
<p>分析哪些函数在分配内存</p>
<h3 id="一命令-1">（一）命令</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/allocs
</code></pre>
<blockquote>
<p>浏览器会自动（手动）打开 0.0.0.0:8081/ui</p>
<p>这里不加 -seconds=，直接查看进程启动以来的内存分配数据</p>
</blockquote>
<h3 id="二火焰图分析-2">（二）火焰图分析</h3>
<p><strong>火焰图如下：</strong></p>
<p><img alt="pprof内存分配分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130934024-239170672.png" class="lazyload"></p>
<blockquote>
<p>从上面可以分析出：</p>
<ol>
<li>OperatuonRecord 存在循环调用，需要确认是否是正常的</li>
<li>CreateImgCompress：该函数内存分配很多，通过火焰图分析该函数的调用函数的内存分配情况，找到存在问题函数</li>
</ol>
</blockquote>
<h3 id="三指标分析-2">（三）指标分析</h3>
<p><img alt="pprof内存分配指标分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130933740-238344300.png" class="lazyload"></p>
<blockquote>
<p>该图为样例图，和上面的火焰图不是同一个采样数据，因此数据可能对不上</p>
</blockquote>
<ol>
<li>flat：函数直接执行的分配内存，即不考虑它调用的任何其他函数的时间。以kb为单位进行测量。</li>
<li>flat%：（函数直接执行分配内存）/ （总执行分配内存），即 flat / sum * 100。</li>
<li>sum%：（函数总执行分配内存）/ （总执行分配内存），即（flat + 子函数执行分配内存）/ sum * 100。</li>
<li>cum：函数总的执行分配内存，即包括它调用的所有子函数的执行分配内存。以kb为单位进行测量。</li>
<li>cum%：（函数总的执行分配内存）/ 总执行分配内存，即 cum / sum * 100。</li>
</ol>
<h3 id="四总结-2">（四）总结</h3>
<ul>
<li>
<p>查看火焰图：<code>哪个框又红又粗</code>，就是内存分配最多的函数，通过函数之间的调用链（箭头）快速定位到函数所在的代码，</p>
<p>​            然后进行优化（见文末【<strong>常见优化措施</strong>】）</p>
</li>
<li>
<p>查看 <code>top</code> 视图：若火焰图不太能定位函数代码实际位置，可以查看 top 视图，会展示问题函数所在的代码文件</p>
</li>
</ul>
<h2 id="六协程分析">六、协程分析</h2>
<p>分析进程中协程的运行情况</p>
<h3 id="一命令-2">（一）命令</h3>
<p>浏览器直接打开一下地址即可</p>
<pre><code class="language-bash"># 协程的情况（总览）
http://0.0.0.0:30552/debug/pprof/goroutine?debug=1 

# 协程的具体阻塞堆栈情况
http://0.0.0.0:30552/debug/pprof/goroutine?debug=1 
</code></pre>
<blockquote>
<p>协程的分析可以直接打开 pporf 服务提供的接口</p>
<p>debug: 表示以纯文本的方式展示，值：1-总览；2-具体堆栈信息</p>
</blockquote>
<h3 id="二数据分析">（二）数据分析</h3>
<p>协程总览</p>
<p><img alt="pprof协程分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130933548-206225834.png" class="lazyload"></p>
<blockquote>
<p>可以看得进程一共有 27 个协程，数量多和少没有绝对好坏，主要看这个数量是否是业务需求所需的</p>
</blockquote>
<p>协程具体运行信息</p>
<p><img alt="pprof协程堆栈信息" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130933655-1343614580.png" class="lazyload"></p>
<blockquote>
<p>这里会列出所有协程的运行堆栈信息，注意：协程ID不是越大就有问题，主要看这个协程所在堆栈是不是存在阻塞问题</p>
</blockquote>
<h3 id="三总结">（三）总结</h3>
<ul>
<li>
<p>1.查看总的协程数量，如果过多，可能存在协程泄漏</p>
</li>
<li>
<p>2.查看协程的运行堆栈信息，看看是不是业务所需的</p>
<p>比如这里就存在一个 trace 的协程，但是我服务并没有这块需求，如下图：</p>
<p><img alt="pprof协程泄漏" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130935226-1584755191.png" class="lazyload"></p>
</li>
</ul>
<p>从这个堆栈看到有个第三方的包开启了这个协程，排查代码发现，程序确实导入这个包，但是这块功能并没有用，因此直接注释掉相应的代码和导包即可</p>
<h2 id="七锁分析">七、锁分析</h2>
<p>分析程序锁的竞争使用情况</p>
<h3 id="一命令-3">（一）命令</h3>
<p>浏览器直接打开一下地址即可</p>
<pre><code class="language-bash">http://0.0.0.0:30552/debug/pprof/mutex?debug=1
</code></pre>
<blockquote>
<p>锁的分析可以直接打开 pporf 服务提供的接口</p>
</blockquote>
<h3 id="二数据分析-1">（二）数据分析</h3>
<p><img alt="pprof 锁分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250726130931456-366376318.png" class="lazyload"></p>
<h3 id="总结">总结</h3>
<ul>
<li>从界面上可以看到执行锁的竞争次数最多的堆栈信息，然后看下堆栈是不是你的业务代码，确定代码位置，确实是否需要优化</li>
</ul>
<h2 id="八阻塞分析">八、阻塞分析</h2>
<p>分析程序阻塞的情况</p>
<h3 id="一命令-4">（一）命令</h3>
<p>浏览器直接打开一下地址即可</p>
<pre><code class="language-bash">http://0.0.0.0:30552/debug/pprof/block?debug=1
</code></pre>
<blockquote>
<p>阻塞分析可以直接打开 pporf 服务提供的接口</p>
</blockquote>
<h3 id="二数据分析-2">（二）数据分析</h3>
<p>以上就是常见的 pprof 性能指标分析</p>
<h2 id="九单元测试">九、单元测试</h2>
<p>除了开启 pprof web 服务采样性能分析，我们还可以使用单元测试，生成 pprof 数据，这在某个函数的性能优化上非常有用</p>
<p>参考代码如下：</p>
<pre><code class="language-go">func main() {
    // --- cpu 分析示例 start---
    // 创建cpu分析文件
    fc, err := os.Create("./cpu.pprof")
    if err != nil {
        fmt.Println("create cpu.pprof err:", err.Error())
        return
    }
    defer fc.Close()

    err = pprof.StartCPUProfile(fc)     // 开始分析cpu
    if err == nil {
        defer pprof.StopCPUProfile()
    }

    var count int
    for i := 0; i &lt; 10000; i++ {
        count++
    }
  // --- cpu 分析示例 end---

    // --- 内存 分析示例 start---
    fm, err := os.Create("./memory.pprof")
    if err != nil {
        fmt.Println("create memory.pprof err:", err.Error())
        return
    }
    defer fm.Close()


    err = pprof.WriteHeapProfile(fm)     // 开始分析内存
    if err != nil {
        fmt.Println("write heap pprof err:", err.Error())
        return
    }

    for i := 0; i &lt; 10000; i++ {
        count++
    }
    fmt.Println("do finish......count:", count)
}
// --- 内存 分析示例 end---
</code></pre>
<p>生成的 pprof 数据文件就可以使用 go tool pprof  &lt;pprof 数据文件&gt; 进行分析了，具体分析方法和前面的步骤一致</p>
<h2 id="常见优化措施">常见优化措施</h2>
<h3 id="1-字符串拼接性能">1. 字符串拼接性能</h3>
<p>这是非常的性能问题，我们都很习惯用 += 进行字符串拼接，但是在大量字符串拼接时性能非常低下<br>
<strong>请移步文章</strong>：<a href="https://blog.fiveyoboy.com/articles/go-concat-string/" target="_blank" rel="noopener nofollow">Go语言字符串拼接性能对比与最佳实践 - 深度优化指南</a></p>
<p>结论：<strong>就是使用 strings.Builder</strong></p>
<h3 id="2-数据库-sql-语句阻塞">2. 数据库 sql 语句阻塞</h3>
<p>一般都是慢查询sql导致，优化下sql语句即可</p>
<h3 id="3-内存频繁分配">3. 内存频繁分配</h3>
<p>如果你从 pprof 中看到<code> growSlice</code> ，那大概率是切片频繁进行了内存分配</p>
<p>我们可以通过预分配切片的方式减少内存分配次数</p>
<pre><code class="language-go">var slice=make([]any,0,cap) // cap 为容量
var m=make(map[string]any,cap) // cap 为容量
</code></pre>
<h3 id="4-协程泄漏">4. 协程泄漏</h3>
<p>从协程的分析中，看到一些本应该关闭但是阻塞的协程堆栈，就可以定位代码，是否有正常关闭协程，可以给协程添加 context 超时机制，避免协程泄漏</p>
<h3 id="5-json-分配内存过多">5. json 分配内存过多</h3>
<p>如果频繁的使用 json.Marshal ，推荐替换 <code>encoding/json</code> ---&gt;<code>github.com/json-iterator/go</code> 性能有极大的提升</p>
<h2 id="常见问题">常见问题</h2>
<h3 id="1-开启-pprof-会影响服务性能吗">1. 开启 pprof 会影响服务性能吗</h3>
<p>肯定是会的，虽然 pprof 对服务性能的影响通常很小，但是高负载或特定分析场景下可能会有一定影响，所以不建议在生产环境长期开启，在需要性能排查时再开启</p>
<h3 id="2-内存堆栈和内存分配有什么区别作用">2. 内存堆栈和内存分配有什么区别作用？</h3>
<p>pprof 内存堆栈（heap） 和内存分配（allocs）的区别作用如下</p>
<table>
<thead>
<tr>
<th style="text-align: center"><strong>维度</strong></th>
<th style="text-align: center"><code>heap</code> (堆内存分析)</th>
<th style="text-align: center"><code>allocs</code> (内存分配分析)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><strong>观察对象</strong></td>
<td style="text-align: center"><strong>当前存活对象</strong></td>
<td style="text-align: center"><strong>所有分配行为</strong>（含已释放对象）</td>
</tr>
<tr>
<td style="text-align: center"><strong>数据来源</strong></td>
<td style="text-align: center">实时内存堆快照</td>
<td style="text-align: center">内存分配器事件采样</td>
</tr>
<tr>
<td style="text-align: center"><strong>时间视角</strong></td>
<td style="text-align: center">空间维度（当前内存占用）</td>
<td style="text-align: center">时间维度（历史分配总量）</td>
</tr>
<tr>
<td style="text-align: center"><strong>关键指标</strong></td>
<td style="text-align: center">inuse_space/inuse_objects</td>
<td style="text-align: center">alloc_space/alloc_objects</td>
</tr>
<tr>
<td style="text-align: center"><strong>最佳适用场景</strong></td>
<td style="text-align: center">内存泄漏/常驻内存过大</td>
<td style="text-align: center">GC压力/分配热点/频繁短命对象</td>
</tr>
<tr>
<td style="text-align: center"><strong>分析侧重点</strong></td>
<td style="text-align: center">"谁占着内存不放"</td>
<td style="text-align: center">"谁在不断申请内存"</td>
</tr>
</tbody>
</table>
<blockquote>
<p>谁一直在占用内存：用 heap</p>
<p>谁一直在申请内存：用 allocs</p>
</blockquote>
<h3 id="3-如何分析哪些函数占用cpu-耗时比较多">3. 如何分析哪些函数占用CPU 耗时比较多？</h3>
<p>见步骤【三、CPU 耗时分析】</p>
<h3 id="4-如何分析哪些函数占用内存比较多">4. 如何分析哪些函数占用内存比较多？</h3>
<p>见步骤【四、内存堆栈分析】</p>
<h3 id="5-如何分析哪些函数分配内存比较多">5. 如何分析哪些函数分配内存比较多？</h3>
<p>见步骤【五、内存分配分析】</p>
<h3 id="6-如何排查协程-goroutine-泄漏">6. 如何排查协程 goroutine 泄漏？</h3>
<p>见步骤【六、协程分析】</p>
<h3 id="7-pprof-控制台模式常见命令">7. pprof 控制台模式常见命令</h3>
<p>go tool pprof 不使用 -http 时，便会进入控制台模式</p>
<pre><code class="language-bash">Fetching profile over HTTP from http://0.0.0.0:30552/debug/pprof/profile
Type: cpu
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top
Showing nodes accounting for 150ms, 83.33% of 180ms total
Showing top 10 nodes out of 143
      flat  flat%   sum%        cum   cum%
      30ms 16.67% 16.67%       40ms 22.22%  runtime.lock2
      30ms 16.67% 33.33%       30ms 16.67%  syscall.Syscall
      20ms 11.11% 44.44%       20ms 11.11%  runtime.step
      10ms  5.56% 50.00%       10ms  5.56%  golang.org/x/net/http2.(*Framer).readMetaFrame
      10ms  5.56% 55.56%       10ms  5.56%  google.golang.org/protobuf/internal/impl.(*enumConverter).PBValueOf
</code></pre>
<ul>
<li>
<p>help</p>
<p>可以获取帮助，最先会列出支持的命令</p>
</li>
<li>
<p>top</p>
<p>按指标大小列出前10个函数，top 5 列出前5个</p>
</li>
<li>
<p>list</p>
<p>可以使用 list 函数名 命令查看具体的函数分析</p>
</li>
<li>
<p>traces</p>
<p>打印所有调用栈，以及调用栈的指标信息</p>
<p>每个<code>- - - - -</code> 隔开的是一个调用栈</p>
</li>
</ul>
<p><strong>原文地址</strong></p>
<p><a href="https://blog.fiveyoboy.com/articles/go-pprof" target="_blank" rel="noopener nofollow">Golang 性能分析神器 pprof 详解与实践（图文教程）</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-26 13:10">2025-07-26 13:10</span>&nbsp;
<a href="https://www.cnblogs.com/fiveyobody">五岁小孩</a>&nbsp;
阅读(<span id="post_view_count">72</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19005976);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19005976', targetLink: 'https://www.cnblogs.com/fiveyobody/p/19005976/go-pprof', title: 'Golang 性能分析神器 pprof 详解与实践（图文教程）' })">举报</a>
</div>
        