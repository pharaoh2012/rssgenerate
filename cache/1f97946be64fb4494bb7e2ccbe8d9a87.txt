
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiezhr/p/18837877" title="发布于 2025-04-21 07:22">
    <span role="heading" aria-level="2">SpringBoot3整合SpringSecurity6(二)SpringSecurity默默的干了些啥</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="写在前面">写在前面</h3>
<p>第一节中，我们基本上就引入<code>SpringSecurity</code>依赖，其他什么都没做就完成了认证功能。</p>
<p>之所以我们不用做什么，是因为<code>SpringSecurity</code>默认实现了很多功能。</p>
<p>当然了，这里默认实现都是基于内存的用户认证，即用户都是创建在内存当中的，实际应用都是基于数据库的。</p>
<p>小伙伴们不用着急，只要我们理解了基于内存的用户认证，那基于数据库也是一样的原理，不同的只是一个从内存中获取用户信息，一个从数据库中获取用户信息而已。</p>
<p>接下来，我们来简单看看其基本原理。</p>
<h3 id="一官方文档">一、官方文档</h3>
<p>官方文档对<code>SpringSecurity</code> 实现原理其实写的挺详细了。感兴趣的小伙伴可以点下面链接查看</p>
<p><a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html" target="_blank" rel="noopener nofollow">https://docs.spring.io/spring-security/reference/servlet/architecture.html</a></p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202504/2381533-20250421071803129-1803421850.png" alt="官方文档" loading="lazy"></p>
<p>但对于不少初学者，看官方文档可能会比较吃力。</p>
<p>所以晓凡将其简化，请接着往下看.</p>
<h3 id="二原理初探">二、原理初探</h3>
<p>我们以上一篇文章中案例，来看一下<code>SpringSecurity</code>流程。</p>
<p><code>SpringSecurity</code>的原理其实就是一个过滤器链,如下图所示，每个过滤器各司其职。</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202504/2381533-20250421071803157-625623458.png" alt="过滤器流程" loading="lazy"></p>
<p>上图中，并没有将所有过滤器都例举出来，刚开始，也没必要了解所有过滤器。</p>
<p>下面，我们来看看这几个主要过滤器</p>
<p>① <strong><code>UsernamePasswordAuthenticationFilter</code></strong></p>
<p>这个过滤器处理用户登录的请求。</p>
<p>就像是保安检查你的门禁卡和密码，确认你是不是小区的合法居民。</p>
<p>② <strong><code>ExceptionTranslationFilter</code></strong></p>
<p>这个过滤器捕获安全相关的异常，并将其转换为HTTP响应。</p>
<p>就像是保安发现了问题，他会采取相应的措施，比如不让你进入或者给你一个警告信息。</p>
<p>③ <strong><code>FilterSecurityInterceptor</code></strong></p>
<p>这个过滤器是授权的核心，它决定用户是否有权限执行特定的请求。</p>
<p>就像是保安检查你有没有权限去某个特定的区域。</p>
<h3 id="三--defaultsecurityfilterchain类">三、  <code>DefaultSecurityFilterChain</code>类</h3>
<p>为啥<code>SpringSecurity</code>默认帮我们实现那么多，其实主要是<code>DefaultSecurityFilterChain</code>的功劳，它加载了默认的15个Filter。</p>
<p>① 我们在源码中找到<code>DefaultSecurityFilterChain</code> 类，并如下图所示加上断点看一下</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202504/2381533-20250421071803154-1718593450.png" alt="添加断点" loading="lazy"></p>
<p>② 程序启动后，默认加载15个过滤器</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202504/2381533-20250421071803105-2116068009.png" alt="默认加载15个过滤器" loading="lazy"></p>
<h3 id="四各个过滤器作用">四、各个过滤器作用</h3>
<p>这里将例举出15个过滤器的作用，小伙伴们简单<strong>了解即可，切忌死记硬背，用得多了自然就记住了</strong>。</p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DisableEncodeUrlFilter</code></td>
<td>用来禁用URL编码。有时候，为了防止CSRF攻击，Spring Security会对重定向的URL进行编码。但如果你确定你的应用环境是安全的，可以用这个过滤器来禁用这个功能。</td>
</tr>
<tr>
<td><code>WebAsyncManagerIntegrationFilter</code></td>
<td>确保异步请求也能正确处理安全上下文。就像是小区保安需要确保即使是快递或者外卖这样的非正常访问，也能被正确地记录和管理。</td>
</tr>
<tr>
<td><code>SecurityContextHolderFilter</code></td>
<td>确保每个请求都能正确地获取到安全上下文，也就是知道当前是谁在访问。就像是小区保安需要知道是谁在小区里。</td>
</tr>
<tr>
<td><code>HeaderWriterFilter</code></td>
<td>会在HTTP响应中添加一些安全相关的头部，比如防止XSS攻击的头部。就像是小区保安会在小区的围墙上安装一些安全设备。</td>
</tr>
<tr>
<td><code>CsrfFilter</code></td>
<td>防止跨站请求伪造攻击，确保用户的操作是他们自己发起的。就像是小区保安会检查每个人的出入证，确保他们不是被坏人操控。</td>
</tr>
<tr>
<td><code>LogoutFilter</code></td>
<td>处理用户注销的请求，清除用户的身份信息。就像是小区保安在居民离开时，会注销他们的临时通行证。</td>
</tr>
<tr>
<td><code>UsernamePasswordAuthenticationFilter</code></td>
<td>处理基于用户名和密码的登录请求。就像是小区保安检查居民的门禁卡和密码。</td>
</tr>
<tr>
<td><code>DefaultLoginPageGeneratingFilter</code></td>
<td>在需要时生成默认的登录页面。就像是小区保安会给没有门禁卡的访客一个标准的表格来填写信息。</td>
</tr>
<tr>
<td><code>DefaultLogoutPageGeneratingFilter</code></td>
<td>在需要时生成默认的注销页面。就像是小区保安会给需要离开的居民一个标准的流程来完成注销。</td>
</tr>
<tr>
<td><code>BasicAuthenticationFilter</code></td>
<td>处理基本的身份验证，也就是基于用户名和密码的认证，但不加密。就像是小区保安检查居民的未加密的门禁卡和密码。</td>
</tr>
<tr>
<td><code>RequestCacheAwareFilter</code></td>
<td>记住用户最初的请求，如果因为认证被重定向，认证成功后可以回到最初的页面。就像是小区保安记得你最初想去的地方，即使你需要去验证身份，回来后他还能指引你去那里。</td>
</tr>
<tr>
<td><code>SecurityContextHolderAwareRequestFilter</code></td>
<td>确保每个请求都能正确地访问到安全上下文。就像是小区保安确保每个访客都能被正确地记录和管理。</td>
</tr>
<tr>
<td><code>AnonymousAuthenticationFilter</code></td>
<td>为匿名用户创建一个认证 token。就像是小区保安会给没有门禁卡的访客一个临时的通行证。</td>
</tr>
<tr>
<td><code>ExceptionTranslationFilter</code></td>
<td>捕获安全相关的异常，并将其转换为HTTP响应，比如401未授权或403禁止访问。就像是小区保安在发现问题时，会采取相应的措施，比如不让进入或者给出一个错误信息。</td>
</tr>
<tr>
<td><code>AuthorizationFilter</code></td>
<td>负责检查用户是否有权限执行特定的请求。就像是小区保安会检查你有没有权限去某个特定的区域。</td>
</tr>
</tbody>
</table>
<h3 id="五基于内存的用户认证">五、基于内存的用户认证</h3>
<p>在上面流程图中，我们提到了<code>UsernamePasswordAuthenticationFilter</code> 这个过滤器。用户认证就是在这个过滤器中完成的。</p>
<p>这个过滤器的职责就是：将内存中的用户信息获取出来，再和我们界面上输入的用户名和密码进行比较。</p>
<p>如果比较成功，认证成功，允许用户访问资源；如果比较失败，用户认证失败，拒绝访问。</p>
<h4 id="51-认证流程">5.1 认证流程</h4>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202504/2381533-20250421071803168-1935755042.png" alt="认证流程" loading="lazy"></p>
<ol>
<li><strong>用户提交登录请求</strong>：用户在登录页面输入用户名和密码，然后提交给服务器。</li>
<li><strong>UsernamePasswordAuthenticationFilter拦截用户请求</strong>：这个过滤器会拦截登录请求，从请求中提取用户名和密码，创建一个<code>UsernamePasswordAuthenticationToken</code>对象。</li>
<li><strong>AuthenticationManager处理认证</strong>：<code>UsernamePasswordAuthenticationFilter</code>将<code>UsernamePasswordAuthenticationToken</code>传递给<code>AuthenticationManager</code>进行认证。</li>
<li><strong>ProviderManager遍历AuthenticationProvider</strong>：<code>AuthenticationManager</code>的默认实现<code>ProviderManager</code>会遍历所有的<code>AuthenticationProvider</code>，找到能够处理<code>UsernamePasswordAuthenticationToken</code>的<code>DaoAuthenticationProvider</code>。</li>
<li><strong>DaoAuthenticationProvider认证</strong>：<code>DaoAuthenticationProvider</code>会调用<code>UserDetailsService</code>的<code>loadUserByUsername</code>方法获取用户信息，然后使用<code>PasswordEncoder</code>对比密码。</li>
<li><strong>认证成功或失败</strong>：
<ul>
<li>如果密码正确，<code>DaoAuthenticationProvider</code>会创建一个新的<code>Authentication</code>对象，包含用户的权限信息，返回给<code>AuthenticationManager</code>。</li>
<li>如果密码不正确，会抛出<code>BadCredentialsException</code>异常。</li>
</ul>
</li>
<li><strong>SecurityContextHolder设置认证信息</strong>：认证成功后，<code>AuthenticationManager</code>会将认证信息设置到<code>SecurityContextHolder</code>中。</li>
<li><strong>用户登录成功</strong>：用户登录成功后，就可以访问系统资源了。</li>
</ol>
<h4 id="52-代码实现">5.2 代码实现</h4>
<p>相信通过上面流程图，大家对认证流程已经很清楚了。</p>
<p>下面我们看看怎么把用户存入内存中，我们参照官方给出的实例即可</p>
<p><a href="https://docs.spring.io/spring-security/reference/servlet/configuration/java.html" target="_blank" rel="noopener nofollow">https://docs.spring.io/spring-security/reference/servlet/configuration/java.html</a></p>
<p>①创建一个<code>WebSecurityConfig</code>配置类：</p>
<p>②然后定义一个@Bean，类型是<code>UserDetailsService</code>，实现是<code>InMemoryUserDetailsManager</code></p>
<p>具体代码如下</p>
<pre><code class="language-java">@Configuration  //标明这个类为配置类，spring应用程序一启动，类中的been 就会被初始化在spring容器中
@EnableWebSecurity  //开启spring security 自定义配置
public class WebSecurityConfig {

    @Bean
    public UserDetailsService userDetailsService(){

        //1、创建基于内存的用户管理器
        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
        // 3、将第二步创建的UserDetail对象交给UserDetailsManager 管理
        inMemoryUserDetailsManager.createUser(
                //2、创建UserDetail 对象，用于管理用户名、用户密码、用户角色、用户权限
                //下面代码创建了一个用户名为user,密码为123456，角色为user的用户对象
                User.withDefaultPasswordEncoder()
                .username("user")
                .password("123456")
                .roles("user")
                .build());
        return inMemoryUserDetailsManager;
    }
}
</code></pre>
<p>通过上面配置类，在程序启动的时候。就会将用户名：user 密码：123456 角色：user这样一个用户存入内存中。</p>
<p>当用户想要获取资源时，就会走5.1小节认证流程。</p>
<h3 id="六小结">六、小结</h3>
<p>通过这篇的学习，我们知道了<code>SpringSecurity</code> 默认为我们干了些啥？基于内存的认证是怎么实现的？</p>
<p>当然了，实际开发中，我们不可能把用户存于内存中，而是需要将用户存于数据库中。通过数据库获取用户和权限信息。</p>
<p>由于文章篇幅原因，这篇就到这儿了。下一篇我们来看看实际开发中，怎么基于数据库进行认证。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiezhr/" target="_blank">程序员晓凡</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiezhr/p/18837877" target="_blank">https://www.cnblogs.com/xiezhr/p/18837877</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07539668871527777" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-21 07:23">2025-04-21 07:22</span>&nbsp;
<a href="https://www.cnblogs.com/xiezhr">程序员晓凡</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18837877);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18837877', targetLink: 'https://www.cnblogs.com/xiezhr/p/18837877', title: 'SpringBoot3整合SpringSecurity6(二)SpringSecurity默默的干了些啥' })">举报</a>
</div>
        