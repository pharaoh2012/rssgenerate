
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18963669/secp256k1_3" title="发布于 2025-07-08 12:02">
    <span role="heading" aria-level="2">secp256k1算法详解三（点操作关键理论及源码分析）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文详细介绍了椭圆曲线上点加及倍点相关理论，并给出了有关公式详细的推导过程，最后给出secp256k1源码进行佐证！
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1 基础概念</h1>
<h2>1.1&nbsp;Short Weierstrass Curve</h2>
<p>椭圆曲线（Elliptic Curve，EC）是密码学中非常重要的代数结构，在几何上，椭圆曲线是由三次方程描述的一些曲线。不同的公式给出了不同曲线形式，对于维尔斯特拉斯形式的椭圆曲线，其定义在域K上的椭圆曲线<em>E</em>由下述方程定义：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704162921616-702183333.png" alt="" width="567" height="197" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>例如椭圆曲线y<sup>2</sup> + xy + y = x<sup>3</sup> - x + 1图形如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707140750957-1598451416.png" alt="" width="555" height="423" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>详细内容可以参考：张焕国著《椭圆曲线密码学导论》。由于一般形式的维尔斯特拉斯方程系数太多不利于分析，一般多基于短维尔斯特拉斯曲线（当域K的特征≠2，3时，一般形式维尔斯特拉斯可以简化为短维尔斯特拉斯）进行研究，它是有以下方程描述的椭圆曲线：</p>
<p style="text-align: center">y<sup>2</sup>&nbsp;= x<sup>3</sup>&nbsp;+ ax + b</p>
<p>参数a，b满足条件：4a<sup>3</sup>+27b<sup>2</sup>≠0，限定条件是为了保证曲线不包含奇点（singularities某些特定方面不再表现良好的点，例如缺乏可微性或可分析性）。在椭圆曲线密码学中x，y以及参数a，b都属于有限域Fp，如对于secp256k1曲线，参数a=0，b=7，即公式进一步简化为y<sup>2</sup>&nbsp;= x<sup>3</sup>&nbsp;+ 7。</p>
<h2>1.2 点加及倍点</h2>
<p>在椭圆曲线上定义了两个点的加法运算，两个点P和点Q之和点为R，则R是过P，Q点直线与椭圆曲线交点关于x轴的对称点，这里P和Q的横坐标不同时，当P和Q重合时（横纵坐标都相同），则R是过P点切线与椭圆曲线交点关于x轴的对称点，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703154147195-1506540359.png" alt="" width="525" height="304" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>为了理论的完整性，还引入无穷远点的概念，这时对应P和Q横坐标相同纵坐标不同，则它们和点即为无穷远点（此时P和Q互为对方逆元），这里不再详细介绍相关内容，请自行查阅有关资料。</p>
<h2>1.3 仿射坐标(Affine Coordinates)</h2>
<p>维尔斯特拉斯形式曲线上点的坐标就是椭圆曲线点的仿射坐标(x, y)，接下来基于仿射坐标分析下点加及倍点运算。对于椭圆曲线上两个点P(x<sub>1</sub>, y<sub>1</sub>)，Q(x<sub>2</sub>, y<sub>2</sub>)，令R(x<sub>3</sub>, y<sub>3</sub>) = P + Q，当x<sub>1</sub> ≠ x<sub>2</sub>时，过P，Q点直线坐标为y=λx + m，代入到椭圆曲线方程得</p>
<p style="text-align: center">x<sup>3</sup> - λ<sup>2</sup>x<sup>2</sup> + (a - 2λm)x + b - m<sup>2</sup> = 0</p>
<p>设直线与椭圆曲线交点为R'(x', y')，则可知x<sub>1</sub>，x<sub>2</sub>，x'是以上一元三次方程的根，由韦达定理可知：-x<sub>1</sub>&nbsp;- x<sub>2</sub>&nbsp;- x' = -λ<sup>2</sup>，则有：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704161811019-88409943.png" alt="" width="345" height="97" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>其中λ是直线斜率。因为R是R'关于x轴对称点，所以R坐标为(λ<sup>2</sup> - x<sub>1</sub> - x<sub>2</sub>, (2x<sub>1</sub> + x<sub>2</sub> - λ<sup>2</sup>)λ -y<sub>1</sub>)，带入λ有以下计算公式：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703162912180-2050368969.png" alt="" width="324" height="90" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>当P和Q重合时（且y&nbsp;≠ 0），对椭圆曲线公式两边关于x求导得斜率：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703170411404-617113408.png" alt="" width="135" height="74" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>进而得倍点公式：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703170443558-881740564.png" alt="" width="327" height="87" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h2>1.4 射影坐标(Projective Coordinates)</h2>
<p>在数学和密码学领域，射影坐标（Projective Coordinates）&nbsp;是一种通过引入额外维度来避免除法运算的坐标表示方法，<span>在传统的<span>仿射坐标（Affine Coordinates）<span>&nbsp;中，平面上的点用二维坐标<span class="container-rkuXQi math-inline" data-custom-copy-text="\((x, y)\)">(x, y)<span>表示，对应笛卡尔坐标系中的位置。但仿射坐标在处理涉及除法的运算（如椭圆曲线的点加法、点加倍）时，会引入计算成本较高的逆元操作（有限域中的除法等价于乘以逆元）。<span>射影坐标<span>通过引入一个额外的非零参数Z<span class="container-rkuXQi math-inline single-Z69glH" data-custom-copy-text="z"><span>，将仿射坐标<span class="container-rkuXQi math-inline" data-custom-copy-text="\((x, y)\)">(x, y)<span>扩展为三维坐标<span class="container-rkuXQi math-inline" data-custom-copy-text="\((X, Y, Z)\)">(X, Y, Z)<span>，其中Z&nbsp;≠ 0，且满足x = X / Z，y = Y / Z（或其他等价变换，具体形式取决于坐标系定义）。<span>这一变换的核心是<span><strong>用乘法和加法替代除法</strong><span>：通过将仿射坐标中的除法转化为射影坐标中对<span class="container-rkuXQi math-inline single-Z69glH" data-custom-copy-text="Z">Z<span>分量的乘法操作，避免了计算逆元的高成本步骤，尤其在有限域等代数结构中能显著提升运算效率。</span></span></span></span></span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(z \neq 0\)"><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3>1.4.1 标准射影坐标（Standard Projective Coordinates，简称P3)</h3>
<p><span><strong>定义</strong><span>：对于仿射点<span class="container-rkuXQi math-inline" data-custom-copy-text="\((x, y)\)">(x, y)<span>，射影坐标表示为<span class="container-rkuXQi math-inline" data-custom-copy-text="\((X, Y, Z)\)">(X, Y, Z)<span>，满足：<span class="container-rkuXQi math-inline" data-custom-copy-text="\(x = X/Z\)">x = X/Z<span>，<span class="container-rkuXQi math-inline" data-custom-copy-text="\(y = Y/Z\)">y = Y/Z<span>，其中<span class="container-rkuXQi math-inline" data-custom-copy-text="\(Z \neq 0\)">Z&nbsp;≠ 0。</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\((x, y)\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\((X, Y, Z)\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(x = X/Z\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(y = Y/Z\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(Z \neq 0\)"><strong>等价性</strong>：若λ&nbsp;≠&nbsp;0，则(X, Y, Z)与(λX,&nbsp;λY,&nbsp;λZ)表示同一个仿射点（即坐标具有齐次性）。</span></span></span></span></span></span></span></span></span></span></span></p>
<h3><span><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\((x, y)\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\((X, Y, Z)\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(x = X/Z\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(y = Y/Z\)"><span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(Z \neq 0\)">1.4.2 雅可比射影坐标（Jacobian Projective Coordinates，简称J3)</span></span></span></span></span></span></span></span></span></span></span></h3>
<p><strong>定义</strong>：<span>为进一步优化椭圆曲线运算（尤其是点加倍）而设计，满足：<span class="container-rkuXQi math-inline" data-custom-copy-text="\(x = X/Z^2\)">x = X/Z<sup>2</sup><span>，<span class="container-rkuXQi math-inline" data-custom-copy-text="\(y = Y/Z^3\)">y = Y/Z<sup>3</sup><span>，其中Z&nbsp;≠&nbsp;0。</span></span></span></span></span></p>
<p><strong>优势</strong>：在椭圆曲线的点加倍运算中，能减少乘法和平方操作的次数，是 ECC 实现中最常用的坐标形式之一。</p>
<h1>2 公式推导</h1>
<p>由于secp256k1射影坐标用的是雅可比坐标，所以只介绍其公式推导。</p>
<h2>2.1 倍点公式推导</h2>
<p>雅可比坐标用(X, Y, Z)表示仿射坐标(x, y) = (X/Z<sup>2</sup>, Y/Z<sup>3</sup>)，需要将仿射坐标得倍点公式转换为雅可比坐标。</p>
<h3>2.1.1 将斜率用雅可比表示</h3>
<p>仿射斜率：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703171140028-285259975.png" alt="" width="452" height="163" loading="lazy"></p>
<h3>2.1.2 计算X<sub>3</sub>, Y<sub>3</sub>, Z<sub>3</sub></h3>
<p>将以上以及x<sub>1</sub>雅可比表示代入公式（3）中有：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703174140454-1621184361.png" alt="" loading="lazy"></p>
<p>进一步进行通分得：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703174306562-1321508149.png" alt="" loading="lazy"></p>
<p>同理由公式（4）可得：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703180335526-959373970.png" alt="" width="562" height="69" loading="lazy"></p>
<p>观察以上两式，只要令：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703181014629-1642228953.png" alt="" width="287" height="84" loading="lazy"></p>
<p>则有x<sub>3</sub>&nbsp;= X<sub>3</sub>/Z<sub>3</sub><sup>2</sup>，y<sub>3</sub>&nbsp;= Y<sub>3</sub>/Z<sub>3</sub><sup>3</sup>，完全满足推导出来的等式，所以以上即雅可比倍点公式。</p>
<h3>2.1.3 优化计算步骤</h3>
<p>计算中间变量：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703182101635-1594701917.png" alt="" width="217" height="92" loading="lazy"></p>
<p>则X<sub>3</sub>，Y<sub>3</sub>，Z<sub>3</sub>由以下计算公式给出：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703182225198-1104446091.png" alt="" width="154" height="88" loading="lazy"></p>
<p>其实以上<span class="base"><span class="mord mathnormal">D<span class="mspace"><span class="mrel">=<span class="mspace"><span class="base"><span class="strut"><span class="mord">4<span class="mord"><span class="mord mathnormal">X<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><sub>1</sub><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="mord"><span class="mord mathnormal">Y<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><sub>1</sub><sup><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></sup>，该计算方式只有在<span class="katex"><span class="katex-html"><span class="base"><span class="mopen">(<span class="mord"><span class="mord mathnormal">X<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><sub>1</sub><span class="vlist-s"><sub>​</sub><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin">+<span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">B<span class="mclose"><span class="mclose">)<span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><sup>2</sup>比单独计算&nbsp;<span class="katex"><span class="katex-mathml">X<sub>1</sub>⋅B<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">更快才有价值，否则可直接使用无D版本公式：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703183853745-1106890764.png" alt="" width="196" height="162" loading="lazy"></p>
<p>对于secp256k1来说因为a=0，所以<a href="https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l" target="_blank" rel="noopener nofollow">hyperelliptic.org</a>给出了两种简化后的计算对比，M：乘法（Multiplication），指有限域上的元素乘法操作；S：平方（Squaring），指有限域上的元素平方操作（通常比一般乘法成本低，故单独统计）；add：加法（Addition），指有限域上的元素加法或减法操作（成本较低，有时可忽略，但此处单独列出）；3*2、1*3、1*8：表示特定常数乘法的次数（如乘以常数 2、3、8 的操作，这类操作可通过优化实现，成本通常低于一般乘法）。因此，第一个公式表示该算法共需：2次乘法 + 5次平方 + 6次加法 + 3次乘以2的操作 + 1次乘以3的操作 + 1次乘以8的操作。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250703184040304-1581314130.png" alt="" width="780" height="595" loading="lazy"></p>
<h2>2.2 点加公式推导</h2>
<h3>2.2.1 x<sub>3</sub>雅可比坐标表示</h3>
<p>雅可比坐标用(X, Y, Z)表示仿射坐标(x, y) = (X/Z<sup>2</sup>, Y/Z<sup>3</sup>)，将雅可比表示的坐标直接代入公式（1）可知：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704104203422-1706110150.png" alt="" width="468" height="364" loading="lazy"></p>
<h3>2.2.2 y<sub>3</sub>雅可比坐标表示</h3>
<p>求y<sub>3</sub>时，由于：y<sub>3</sub> = λ(x<sub>1</sub> - x<sub>3</sub>) - y<sub>1</sub>&nbsp; &nbsp;且&nbsp; &nbsp; y<sub>3</sub> = λ(x<sub>2</sub> - x<sub>3</sub>) - y<sub>2</sub>，等式两侧分别相加可知：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704183500829-1729276379.png" alt="" width="798" height="211" loading="lazy"></p>
<p>等式两边除于2即得y<sub>3</sub>。</p>
<h3>2.2.3 两点和公式</h3>
<p>观察以上得出x<sub>3</sub>和y<sub>3</sub>表达式，只要令：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704103239776-1380411868.png" alt="" width="631" height="95" loading="lazy"></p>
<p>则有：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704103633280-656936277.png" alt="" width="78" height="98" loading="lazy"></p>
<p>为了使得计算流程更为清晰，可引入如下中间变量：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704104039870-1979514128.png" alt="" width="138" height="243" loading="lazy"></p>
<p>则求解公式可简化为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704104132374-617801678.png" alt="" width="194" height="114" loading="lazy"></p>
<p>对于secp256k1来说因为a=0，<a href="https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-1986-cc" target="_blank" rel="noopener nofollow">hyperelliptic.org</a>给出详细的计算复杂度，如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704112905195-363747503.png" alt="" width="694" height="556" loading="lazy"></p>
<p>&nbsp;在源码中使用的正是add-1998-cmo方法，很容易验算它和add-1986-cc方法是一致的。</p>
<h2>2.3 统一倍点及点和公式</h2>
<h3>2.3.1 侧信道攻击&nbsp;</h3>
<p>维基百科是这么定义的：“在密码学中，侧信道攻击（Side-channel attack）是一种攻击方式，它基于从密码系统的物理实现中获取的信息，而非暴力破解法或是算法中的理论性缺陷，例如利用时间信息、功率消耗、电磁泄露或甚是声音可以提供额外的信息，来对系统的破解”。简单一点理解就是利用一些“旁门左道”的手法来获取我们需要的机密信息；比如经常在电视剧中看到的一个场景：一个窃贼将听诊器压在保险柜的前面板上，通过内部的机械声来打开保险柜。小偷会慢慢地转动转盘，听着内部机械结构所泄露出的咔哒声或阻力声，来分析保险箱齿轮的内部运作，并从而得知其密码的组合。除了拨号盘上的数字和保险柜“是”或“否”的打开状态以外，这个保险柜并不会给用户任何反馈，但保险箱的物理机械所产生的那些微小的触动和声音线索，这也是一个典型的侧信道攻击。</p>
<p>SPA-Like Attacks 通常是指类似简单功率分析（Simple Power Analysis，SPA）的攻击方式。SPA 是一种侧信道攻击方法，它通过分析密码设备在运行过程中的功率消耗情况，来获取设备操作和密钥等信息。其攻击原理是：密码设备在执行不同操作时，其功率消耗会有所不同。例如，乘法运算通常比加法运算消耗更多的功率，对不同数据的处理也会导致不同的功率消耗模式。攻击者通过测量密码设备的功率消耗，观察其功率波形，就可以推断出设备正在执行的操作，进而分析出密钥等敏感信息。在椭圆曲线密码体制中，标量乘算法常采用 “倍点 - 点加” 算法。由于倍点和点加运算的时间和消耗能量不同，攻击者可以通过分析功率波形，识别出这两种运算，从而获取关于标量（通常与密钥相关）的信息，对椭圆曲线密码系统构成威胁。标量乘法算法如下，如果从功率追踪显示倍点运算后又进行了一次加法运算，则当前位k<sub>i</sub>应该等于1，否则等于0。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704155853354-771110958.png" alt="" width="396" height="156" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h3>2.3.2 统一公式</h3>
<p>分析倍点及点和公式，它们最大的不同就在于关联直线（“chord-and-tangent”弦与切线）的斜率λ表示不同，如果能用相同的公式表达λ，则公式（1）、（2）和公式（3）、（4）就能统一起来。</p>
<p>首先给出一个基于一般维尔斯特拉斯方程的命题：E是基于域K的椭圆曲线，其方程为：y<sup>2</sup> + a<sub>1</sub>xy + a<sub>3</sub>y = x<sup>3</sup> + a<sub>2</sub>x<sup>2</sup> + a<sub>4</sub>x + a<sub>6</sub>，同样P = (x<sub>1</sub>, y<sub>1</sub>)，Q = (x<sub>2</sub>, y<sub>2</sub>)是椭圆曲线上的点，且y(P)&nbsp;≠ y(-Q)（保证两点不关于曲线对称，避免点加退化为倍点或无穷远点），令P + Q = (x<sub>3</sub>, y<sub>3</sub>)，则有：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704172119600-1430208603.png" alt="" width="369" height="130" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>下面给出以上结论的证明过程，对于Q(x<sub>2</sub>, y<sub>2</sub>)假设其<span>负元-Q坐标为(x', y')，则有x'=x<sub>2</sub>，即它们是直线x=x<sub>2</sub>和椭圆曲线的两个交点，将直线方程代入椭圆方程，并将其看作是关于y的一元二次方程，由韦达定理可知y<sub>2</sub>+y'=-a<sub>1</sub>x<sub>2</sub> - a<sub>3</sub>，即y' = -y<sub>2</sub> - a<sub>1</sub>x<sub>2</sub> - a<sub>3</sub>，所以条件y(P)&nbsp;≠ y(-Q)等价于y<sub>1</sub>&nbsp;≠&nbsp; -y<sub>2</sub>&nbsp;- a<sub>1</sub>x<sub>2</sub>&nbsp;- a<sub>3</sub>，首先看下P&nbsp;≠ Q时λ推导过程：<span><span class="container-rkuXQi math-inline" data-custom-copy-text="\(-\mathbf{Q}\)"><br></span></span></span></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250704183810909-1346367310.png" alt="" width="519" height="185" loading="lazy"></p>
<p>假如P = Q，则可以将x<sub>2</sub>用x<sub>1</sub>取代，y<sub>2</sub>用y<sub>1</sub>取代，则上述λ公式可以转换为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707114524039-652825045.png" alt="" width="269" height="50" loading="lazy"></p>
<p>这正对于倍点计算时求切线时的求导公式，即已将倍点和点和求斜率的公式统一了起来。进而，对于椭圆曲线y<sup>2</sup> = x<sup>3</sup> + ax + b来说，统一公式可以简化为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707123108484-1328907060.png" alt="" width="364" height="131" loading="lazy"></p>
<p>对于secp256k1来说，统一公式可进一步将a忽略。</p>
<h1>3 源码分析</h1>
<p>本节给出典型函数的源码，并有选择的对函数进行分析。</p>
<h2>3.1 secp256k1_gej_double_nonzero</h2>
<p>该函数用于执行非零点的倍点计算，第13~14行相当于计算无D版本公式中Z<sub>3</sub>=2*Y<sub>1</sub>*Z<sub>1</sub>；第15~16行求得无D版本公式中E，第17行求得T2=E<sup>2</sup>，第18行求得B，第19~21行求得8B<sup>2</sup>，第22~25行求得-2M，第26行求得X<sub>3</sub>；最后第27~32行给出了Y<sub>3</sub>。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">static</span> SECP256K1_INLINE <span style="color: rgba(0, 0, 255, 1)">void</span> secp256k1_gej_double_nonzero(secp256k1_gej *r, <span style="color: rgba(0, 0, 255, 1)">const</span> secp256k1_gej *<span style="color: rgba(0, 0, 0, 1)">a) {
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> <span style="color: rgba(0, 128, 0, 1)">     * Note that there is an implementation described at
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 128, 0, 1)">     *     </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html</span><span style="color: rgba(0, 128, 0, 1)">#doubling-dbl-2009-l
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 128, 0, 1)">     * which trades a multiply for a square, but in practice this is actually slower,
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 128, 0, 1)">     * mainly because it requires more normalizations.
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>      <span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 9</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_fe t1,t2,t3,t4;
</span><span style="color: rgba(0, 128, 128, 1)">10</span> 
<span style="color: rgba(0, 128, 128, 1)">11</span>     r-&gt;infinity = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">12</span> 
<span style="color: rgba(0, 128, 128, 1)">13</span>     secp256k1_fe_mul(&amp;r-&gt;z, &amp;a-&gt;z, &amp;a-&gt;<span style="color: rgba(0, 0, 0, 1)">y);
</span><span style="color: rgba(0, 128, 128, 1)">14</span>     secp256k1_fe_mul_int(&amp;r-&gt;z, <span style="color: rgba(128, 0, 128, 1)">2</span>);       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Z' = 2*Y*Z (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">15</span>     secp256k1_fe_sqr(&amp;t1, &amp;a-&gt;<span style="color: rgba(0, 0, 0, 1)">x);
</span><span style="color: rgba(0, 128, 128, 1)">16</span>     secp256k1_fe_mul_int(&amp;t1, <span style="color: rgba(128, 0, 128, 1)">3</span>);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T1 = 3*X^2 (3) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">17</span>     secp256k1_fe_sqr(&amp;t2, &amp;t1);           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T2 = 9*X^4 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">18</span>     secp256k1_fe_sqr(&amp;t3, &amp;a-&gt;<span style="color: rgba(0, 0, 0, 1)">y);
</span><span style="color: rgba(0, 128, 128, 1)">19</span>     secp256k1_fe_mul_int(&amp;t3, <span style="color: rgba(128, 0, 128, 1)">2</span>);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T3 = 2*Y^2 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">20</span>     secp256k1_fe_sqr(&amp;t4, &amp;<span style="color: rgba(0, 0, 0, 1)">t3);
</span><span style="color: rgba(0, 128, 128, 1)">21</span>     secp256k1_fe_mul_int(&amp;t4, <span style="color: rgba(128, 0, 128, 1)">2</span>);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T4 = 8*Y^4 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">22</span>     secp256k1_fe_mul(&amp;t3, &amp;t3, &amp;a-&gt;x);    <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T3 = 2*X*Y^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">23</span>     r-&gt;x =<span style="color: rgba(0, 0, 0, 1)"> t3;
</span><span style="color: rgba(0, 128, 128, 1)">24</span>     secp256k1_fe_mul_int(&amp;r-&gt;x, <span style="color: rgba(128, 0, 128, 1)">4</span>);       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> X' = 8*X*Y^2 (4) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">25</span>     secp256k1_fe_negate(&amp;r-&gt;x, &amp;r-&gt;x, <span style="color: rgba(128, 0, 128, 1)">4</span>); <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> X' = -8*X*Y^2 (5) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">26</span>     secp256k1_fe_add(&amp;r-&gt;x, &amp;t2);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> X' = 9*X^4 - 8*X*Y^2 (6) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">27</span>     secp256k1_fe_negate(&amp;t2, &amp;t2, <span style="color: rgba(128, 0, 128, 1)">1</span>);     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T2 = -9*X^4 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">28</span>     secp256k1_fe_mul_int(&amp;t3, <span style="color: rgba(128, 0, 128, 1)">6</span>);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T3 = 12*X*Y^2 (6) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">29</span>     secp256k1_fe_add(&amp;t3, &amp;t2);           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T3 = 12*X*Y^2 - 9*X^4 (8) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">30</span>     secp256k1_fe_mul(&amp;r-&gt;y, &amp;t1, &amp;t3);    <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Y' = 36*X^3*Y^2 - 27*X^6 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">31</span>     secp256k1_fe_negate(&amp;t2, &amp;t4, <span style="color: rgba(128, 0, 128, 1)">2</span>);     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> T2 = -8*Y^4 (3) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">32</span>     secp256k1_fe_add(&amp;r-&gt;y, &amp;t2);         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Y' = 36*X^3*Y^2 - 27*X^6 - 8*Y^4 (4) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">33</span> }</pre>
</div>
<p>之后的secp256k1_gej_double_var函数正式调用了该函数实现倍点操作，只不过在secp256k1_gej_double_var函数中对无穷远点做了特殊处理。</p>
<div>
<h2>3.2 secp256k1_gej_add_var</h2>
<p>&nbsp;2.2节已经详细分析了公式推导相关过程，所以不再对该函数进行详细分析，请根据注释自行理解。</p>
<div class="cnblogs_code">
<pre> 1 /*
 2 * lambda1 = x1*z2^2
 3 * lambda2 = x2*z1^2
 4 * lambda3 = lambda2 - lambda1
 5 * lambda4 = y1*z2^3
 6 * lambda5 = y2*z1^3
 7 * lambda6 = lambda5 - lambda4
 8 * lambda7 = lambda1 + lambda2
 9 * lambda8 = lambda4 + lambda5
10 * x3 = lambda6^2 - (2*lambda1*lambda3^2 + lambda3^3)
11 * lambda9 = lambda7*lambda3^2 - 2*x3
12 * y3 = (lambda5 - lambda4)*(lambda1*lambda3^2 - x3) - lambda4*lambda3^3
13 * z3 = z1*z2*lambda3
14 */
15 static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {
16     /* Operations: 12 mul, 4 sqr, 2 normalize, 12 mul_int/add/negate */
17     secp256k1_fe z22, z12, u1, u2, s1, s2, h, i, i2, h2, h3, t;
18 
19     if (a-&gt;infinity) {
20         *r = *b;
21         return;
22     }
23 
24     if (b-&gt;infinity) {
25         if (rzr != NULL) {
26             secp256k1_fe_set_int(rzr, 1);
27         }
28         *r = *a;
29         return;
30     }
31 
32     r-&gt;infinity = 0;
33     secp256k1_fe_sqr(&amp;z22, &amp;b-&gt;z);
34     secp256k1_fe_sqr(&amp;z12, &amp;a-&gt;z);
35     secp256k1_fe_mul(&amp;u1, &amp;a-&gt;x, &amp;z22);        // u1=lambda1
36     secp256k1_fe_mul(&amp;u2, &amp;b-&gt;x, &amp;z12);        // u2=lambda2
37     
38     secp256k1_fe_mul(&amp;s1, &amp;a-&gt;y, &amp;z22); secp256k1_fe_mul(&amp;s1, &amp;s1, &amp;b-&gt;z);    // s1=lambda4
39     secp256k1_fe_mul(&amp;s2, &amp;b-&gt;y, &amp;z12); secp256k1_fe_mul(&amp;s2, &amp;s2, &amp;a-&gt;z);    // s2=lambda5
40     secp256k1_fe_negate(&amp;h, &amp;u1, 1); secp256k1_fe_add(&amp;h, &amp;u2);        // lambda3
41     secp256k1_fe_negate(&amp;i, &amp;s1, 1); secp256k1_fe_add(&amp;i, &amp;s2);        // i=lambda6
42     if (secp256k1_fe_normalizes_to_zero_var(&amp;h)) {
43         if (secp256k1_fe_normalizes_to_zero_var(&amp;i)) {
44             secp256k1_gej_double_var(r, a, rzr);
45         } else {
46             if (rzr != NULL) {
47                 secp256k1_fe_set_int(rzr, 0);
48             }
49             r-&gt;infinity = 1;
50         }
51         return;
52     }
53     secp256k1_fe_sqr(&amp;i2, &amp;i);            // i2=lambda6^2
54     secp256k1_fe_sqr(&amp;h2, &amp;h);            // h2=lambda3^2
55     secp256k1_fe_mul(&amp;h3, &amp;h, &amp;h2);    // h3=lambda3^3
56     secp256k1_fe_mul(&amp;h, &amp;h, &amp;b-&gt;z);    // Z2*lambda3
57     if (rzr != NULL) {
58         *rzr = h;
59     }
60     secp256k1_fe_mul(&amp;r-&gt;z, &amp;a-&gt;z, &amp;h);    // Z1*Z2*lambda3
61     secp256k1_fe_mul(&amp;t, &amp;u1, &amp;h2);        // t=lambda1*lambda3^2
62     r-&gt;x = t; secp256k1_fe_mul_int(&amp;r-&gt;x, 2); secp256k1_fe_add(&amp;r-&gt;x, &amp;h3); secp256k1_fe_negate(&amp;r-&gt;x, &amp;r-&gt;x, 3); secp256k1_fe_add(&amp;r-&gt;x, &amp;i2);
63     secp256k1_fe_negate(&amp;r-&gt;y, &amp;r-&gt;x, 5); secp256k1_fe_add(&amp;r-&gt;y, &amp;t); secp256k1_fe_mul(&amp;r-&gt;y, &amp;r-&gt;y, &amp;i);
64     secp256k1_fe_mul(&amp;h3, &amp;h3, &amp;s1); secp256k1_fe_negate(&amp;h3, &amp;h3, 1);
65     secp256k1_fe_add(&amp;r-&gt;y, &amp;h3);
66 }</pre>
</div>
<h2>3.3&nbsp;&nbsp;secp256k1_gej_add_ge</h2>
<p>该函数用于计算射影坐标和仿射坐标相加，由2.3节可知统一公式如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707180906541-1335427508.png" alt="" width="328" height="124" loading="lazy"></p>
<p>代入x1=X<sub>1</sub>/Z<sub>1</sub><sup>2</sup>，y<sub>1</sub>=Y<sub>1</sub>/Z<sub>1</sub><sup>3</sup>，x<sub>2</sub>=X<sub>2</sub>/Z<sub>2</sub><sup>2</sup>，y<sub>2</sub>=Y<sub>2</sub>/Z<sub>2</sub><sup>3</sup>，可得：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707182330836-567244101.png" alt="" width="233" height="46" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707174203842-935666292.png" alt="" width="518" height="257" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250707174247964-1075877881.png" alt="" width="921" height="198" loading="lazy"></p>
<p>函数源码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> secp256k1_gej_add_ge(secp256k1_gej *r, <span style="color: rgba(0, 0, 255, 1)">const</span> secp256k1_gej *a, <span style="color: rgba(0, 0, 255, 1)">const</span> secp256k1_ge *<span style="color: rgba(0, 0, 0, 1)">b) {
</span><span style="color: rgba(0, 128, 128, 1)">  2</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Operations: 7 mul, 5 sqr, 4 normalize, 21 mul_int/add/negate/cmov </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">  3</span>     <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">const</span> secp256k1_fe fe_1 = SECP256K1_FE_CONST(<span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">  4</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_fe zz, u1, u2, s1, s2, t, tt, m, n, q, rr;
</span><span style="color: rgba(0, 128, 128, 1)">  5</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_fe m_alt, rr_alt;
</span><span style="color: rgba(0, 128, 128, 1)">  6</span>     <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> infinity, degenerate;
</span><span style="color: rgba(0, 128, 128, 1)">  7</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (b-&gt;<span style="color: rgba(0, 0, 0, 1)">infinity) {
</span><span style="color: rgba(0, 128, 128, 1)">  8</span>         *r = *<span style="color: rgba(0, 0, 0, 1)">a;
</span><span style="color: rgba(0, 128, 128, 1)">  9</span>         <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 10</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 11</span> 
<span style="color: rgba(0, 128, 128, 1)"> 12</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* In:
</span><span style="color: rgba(0, 128, 128, 1)"> 13</span> <span style="color: rgba(0, 128, 0, 1)">     *    Eric Brier and Marc Joye, Weierstrass Elliptic Curves and Side-Channel Attacks.
</span><span style="color: rgba(0, 128, 128, 1)"> 14</span> <span style="color: rgba(0, 128, 0, 1)">     *    In D. Naccache and P. Paillier, Eds., Public Key Cryptography, vol. 2274 of Lecture Notes in Computer Science, pages 335-345. Springer-Verlag, 2002.
</span><span style="color: rgba(0, 128, 128, 1)"> 15</span> <span style="color: rgba(0, 128, 0, 1)">     *  we find as solution for a unified addition/doubling formula:
</span><span style="color: rgba(0, 128, 128, 1)"> 16</span> <span style="color: rgba(0, 128, 0, 1)">     *    lambda = ((x1 + x2)^2 - x1 * x2 + a) / (y1 + y2), with a = 0 for secp256k1's curve equation.
</span><span style="color: rgba(0, 128, 128, 1)"> 17</span> <span style="color: rgba(0, 128, 0, 1)">     *    x3 = lambda^2 - (x1 + x2)
</span><span style="color: rgba(0, 128, 128, 1)"> 18</span> <span style="color: rgba(0, 128, 0, 1)">     *    2*y3 = lambda * (x1 + x2 - 2 * x3) - (y1 + y2).
</span><span style="color: rgba(0, 128, 128, 1)"> 19</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 20</span> <span style="color: rgba(0, 128, 0, 1)">     *  Substituting x_i = Xi / Zi^2 and yi = Yi / Zi^3, for i=1,2,3, gives:
</span><span style="color: rgba(0, 128, 128, 1)"> 21</span> <span style="color: rgba(0, 128, 0, 1)">     *    U1 = X1*Z2^2, U2 = X2*Z1^2
</span><span style="color: rgba(0, 128, 128, 1)"> 22</span> <span style="color: rgba(0, 128, 0, 1)">     *    S1 = Y1*Z2^3, S2 = Y2*Z1^3
</span><span style="color: rgba(0, 128, 128, 1)"> 23</span> <span style="color: rgba(0, 128, 0, 1)">     *    Z = Z1*Z2
</span><span style="color: rgba(0, 128, 128, 1)"> 24</span> <span style="color: rgba(0, 128, 0, 1)">     *    T = U1+U2
</span><span style="color: rgba(0, 128, 128, 1)"> 25</span> <span style="color: rgba(0, 128, 0, 1)">     *    M = S1+S2
</span><span style="color: rgba(0, 128, 128, 1)"> 26</span> <span style="color: rgba(0, 128, 0, 1)">     *    Q = T*M^2
</span><span style="color: rgba(0, 128, 128, 1)"> 27</span> <span style="color: rgba(0, 128, 0, 1)">     *    R = T^2-U1*U2
</span><span style="color: rgba(0, 128, 128, 1)"> 28</span> <span style="color: rgba(0, 128, 0, 1)">     *    X3 = 4*(R^2-Q)
</span><span style="color: rgba(0, 128, 128, 1)"> 29</span> <span style="color: rgba(0, 128, 0, 1)">     *    Y3 = 4*(R*(3*Q-2*R^2)-M^4)
</span><span style="color: rgba(0, 128, 128, 1)"> 30</span> <span style="color: rgba(0, 128, 0, 1)">     *    Z3 = 2*M*Z
</span><span style="color: rgba(0, 128, 128, 1)"> 31</span> <span style="color: rgba(0, 128, 0, 1)">     *  (Note that the paper uses xi = Xi / Zi and yi = Yi / Zi instead.)
</span><span style="color: rgba(0, 128, 128, 1)"> 32</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 33</span> <span style="color: rgba(0, 128, 0, 1)">     *  This formula has the benefit of being the same for both addition
</span><span style="color: rgba(0, 128, 128, 1)"> 34</span> <span style="color: rgba(0, 128, 0, 1)">     *  of distinct points and doubling. However, it breaks down in the
</span><span style="color: rgba(0, 128, 128, 1)"> 35</span> <span style="color: rgba(0, 128, 0, 1)">     *  case that either point is infinity, or that y1 = -y2. We handle
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span> <span style="color: rgba(0, 128, 0, 1)">     *  these cases in the following ways:
</span><span style="color: rgba(0, 128, 128, 1)"> 37</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 38</span> <span style="color: rgba(0, 128, 0, 1)">     *    - If b is infinity we simply bail by means of a VERIFY_CHECK.
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span> <span style="color: rgba(0, 128, 0, 1)">     *    - If a is infinity, we detect this, and at the end of the
</span><span style="color: rgba(0, 128, 128, 1)"> 41</span> <span style="color: rgba(0, 128, 0, 1)">     *      computation replace the result (which will be meaningless,
</span><span style="color: rgba(0, 128, 128, 1)"> 42</span> <span style="color: rgba(0, 128, 0, 1)">     *      but we compute to be constant-time) with b.x : b.y : 1.
</span><span style="color: rgba(0, 128, 128, 1)"> 43</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span> <span style="color: rgba(0, 128, 0, 1)">     *    - If a = -b, we have y1 = -y2, which is a degenerate case.
</span><span style="color: rgba(0, 128, 128, 1)"> 45</span> <span style="color: rgba(0, 128, 0, 1)">     *      But here the answer is infinity, so we simply set the
</span><span style="color: rgba(0, 128, 128, 1)"> 46</span> <span style="color: rgba(0, 128, 0, 1)">     *      infinity flag of the result, overriding the computed values
</span><span style="color: rgba(0, 128, 128, 1)"> 47</span> <span style="color: rgba(0, 128, 0, 1)">     *      without even needing to cmov.
</span><span style="color: rgba(0, 128, 128, 1)"> 48</span> <span style="color: rgba(0, 128, 0, 1)">     *
</span><span style="color: rgba(0, 128, 128, 1)"> 49</span> <span style="color: rgba(0, 128, 0, 1)">     *    - If y1 = -y2 but x1 != x2, which does occur thanks to certain
</span><span style="color: rgba(0, 128, 128, 1)"> 50</span> <span style="color: rgba(0, 128, 0, 1)">     *      properties of our curve (specifically, 1 has nontrivial cube
</span><span style="color: rgba(0, 128, 128, 1)"> 51</span> <span style="color: rgba(0, 128, 0, 1)">     *      roots in our field, and the curve equation has no x coefficient)
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span> <span style="color: rgba(0, 128, 0, 1)">     *      then the answer is not infinity but also not given by the above
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span> <span style="color: rgba(0, 128, 0, 1)">     *      equation. In this case, we cmov in place an alternate expression
</span><span style="color: rgba(0, 128, 128, 1)"> 54</span> <span style="color: rgba(0, 128, 0, 1)">     *      for lambda. Specifically (y1 - y2)/(x1 - x2). Where both these
</span><span style="color: rgba(0, 128, 128, 1)"> 55</span> <span style="color: rgba(0, 128, 0, 1)">     *      expressions for lambda are defined, they are equal, and can be
</span><span style="color: rgba(0, 128, 128, 1)"> 56</span> <span style="color: rgba(0, 128, 0, 1)">     *      obtained from each other by multiplication by (y1 + y2)/(y1 + y2)
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span> <span style="color: rgba(0, 128, 0, 1)">     *      then substitution of x^3 + 7 for y^2 (using the curve equation).
</span><span style="color: rgba(0, 128, 128, 1)"> 58</span> <span style="color: rgba(0, 128, 0, 1)">     *      For all pairs of nonzero points (a, b) at least one is defined,
</span><span style="color: rgba(0, 128, 128, 1)"> 59</span> <span style="color: rgba(0, 128, 0, 1)">     *      so this covers everything.
</span><span style="color: rgba(0, 128, 128, 1)"> 60</span>      <span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 61</span> 
<span style="color: rgba(0, 128, 128, 1)"> 62</span>     secp256k1_fe_sqr(&amp;zz, &amp;a-&gt;z);                       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> z = Z1^2 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 63</span>     u1 = a-&gt;x; secp256k1_fe_normalize_weak(&amp;u1);        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> u1 = U1 = X1*Z2^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 64</span>     secp256k1_fe_mul(&amp;u2, &amp;b-&gt;x, &amp;zz);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> u2 = U2 = X2*Z1^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 65</span>     s1 = a-&gt;y; secp256k1_fe_normalize_weak(&amp;s1);        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> s1 = S1 = Y1*Z2^3 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 66</span>     secp256k1_fe_mul(&amp;s2, &amp;b-&gt;y, &amp;zz);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> s2 = Y2*Z1^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 67</span>     secp256k1_fe_mul(&amp;s2, &amp;s2, &amp;a-&gt;z);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> s2 = S2 = Y2*Z1^3 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 68</span>     t = u1; secp256k1_fe_add(&amp;t, &amp;u2);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = T = U1+U2 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 69</span>     m = s1; secp256k1_fe_add(&amp;m, &amp;s2);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> m = M = S1+S2 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 70</span>     secp256k1_fe_sqr(&amp;rr, &amp;t);                          <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> rr = T^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 71</span>     secp256k1_fe_negate(&amp;m_alt, &amp;u2, <span style="color: rgba(128, 0, 128, 1)">1</span>);                <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Malt = -X2*Z1^2 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 72</span>     secp256k1_fe_mul(&amp;tt, &amp;u1, &amp;m_alt);                 <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> tt = -U1*U2 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 73</span>     secp256k1_fe_add(&amp;rr, &amp;tt);                         <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> rr = R = T^2-U1*U2 (3) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 74</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* If lambda = R/M = 0/0 we have a problem (except in the "trivial"
</span><span style="color: rgba(0, 128, 128, 1)"> 75</span> <span style="color: rgba(0, 128, 0, 1)">     *  case that Z = z1z2 = 0, and this is special-cased later on). </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 76</span>     degenerate = secp256k1_fe_normalizes_to_zero(&amp;m) &amp;
<span style="color: rgba(0, 128, 128, 1)"> 77</span>                  secp256k1_fe_normalizes_to_zero(&amp;<span style="color: rgba(0, 0, 0, 1)">rr);
</span><span style="color: rgba(0, 128, 128, 1)"> 78</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> This only occurs when y1 == -y2 and x1^3 == x2^3, but x1 != x2.
</span><span style="color: rgba(0, 128, 128, 1)"> 79</span> <span style="color: rgba(0, 128, 0, 1)">     * This means either x1 == beta*x2 or beta*x1 == x2, where beta is
</span><span style="color: rgba(0, 128, 128, 1)"> 80</span> <span style="color: rgba(0, 128, 0, 1)">     * a nontrivial cube root of one. In either case, an alternate
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span> <span style="color: rgba(0, 128, 0, 1)">     * non-indeterminate expression for lambda is (y1 - y2)/(x1 - x2),
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span> <span style="color: rgba(0, 128, 0, 1)">     * so we set R/M equal to this. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 83</span>     rr_alt =<span style="color: rgba(0, 0, 0, 1)"> s1;
</span><span style="color: rgba(0, 128, 128, 1)"> 84</span>     secp256k1_fe_mul_int(&amp;rr_alt, <span style="color: rgba(128, 0, 128, 1)">2</span>);       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> rr = Y1*Z2^3 - Y2*Z1^3 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 85</span>     secp256k1_fe_add(&amp;m_alt, &amp;u1);          <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Malt = X1*Z2^2 - X2*Z1^2 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 86</span> 
<span style="color: rgba(0, 128, 128, 1)"> 87</span>     secp256k1_fe_cmov(&amp;rr_alt, &amp;rr, !<span style="color: rgba(0, 0, 0, 1)">degenerate);
</span><span style="color: rgba(0, 128, 128, 1)"> 88</span>     secp256k1_fe_cmov(&amp;m_alt, &amp;m, !<span style="color: rgba(0, 0, 0, 1)">degenerate);
</span><span style="color: rgba(0, 128, 128, 1)"> 89</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Now Ralt / Malt = lambda and is guaranteed not to be 0/0.
</span><span style="color: rgba(0, 128, 128, 1)"> 90</span> <span style="color: rgba(0, 128, 0, 1)">     * From here on out Ralt and Malt represent the numerator
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span> <span style="color: rgba(0, 128, 0, 1)">     * and denominator of lambda; R and M represent the explicit
</span><span style="color: rgba(0, 128, 128, 1)"> 92</span> <span style="color: rgba(0, 128, 0, 1)">     * expressions x1^2 + x2^2 + x1x2 and y1 + y2. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 93</span>     secp256k1_fe_sqr(&amp;n, &amp;m_alt);                       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> n = Malt^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 94</span>     secp256k1_fe_mul(&amp;q, &amp;n, &amp;t);                       <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> q = Q = T*Malt^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 95</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> These two lines use the observation that either M == Malt or M == 0,
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span> <span style="color: rgba(0, 128, 0, 1)">     * so M^3 * Malt is either Malt^4 (which is computed by squaring), or
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span> <span style="color: rgba(0, 128, 0, 1)">     * zero (which is "computed" by cmov). So the cost is one squaring
</span><span style="color: rgba(0, 128, 128, 1)"> 98</span> <span style="color: rgba(0, 128, 0, 1)">     * versus two multiplications. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 99</span>     secp256k1_fe_sqr(&amp;n, &amp;<span style="color: rgba(0, 0, 0, 1)">n);
</span><span style="color: rgba(0, 128, 128, 1)">100</span>     secp256k1_fe_cmov(&amp;n, &amp;m, degenerate);              <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> n = M^3 * Malt (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">101</span>     secp256k1_fe_sqr(&amp;t, &amp;rr_alt);                      <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = Ralt^2 (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">102</span>     secp256k1_fe_mul(&amp;r-&gt;z, &amp;a-&gt;z, &amp;m_alt);             <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;z = Malt*Z (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">103</span>     infinity = secp256k1_fe_normalizes_to_zero(&amp;r-&gt;z) * (<span style="color: rgba(128, 0, 128, 1)">1</span> - a-&gt;<span style="color: rgba(0, 0, 0, 1)">infinity);
</span><span style="color: rgba(0, 128, 128, 1)">104</span>     secp256k1_fe_mul_int(&amp;r-&gt;z, <span style="color: rgba(128, 0, 128, 1)">2</span>);                     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;z = Z3 = 2*Malt*Z (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">105</span>     secp256k1_fe_negate(&amp;q, &amp;q, <span style="color: rgba(128, 0, 128, 1)">1</span>);                     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> q = -Q (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">106</span>     secp256k1_fe_add(&amp;t, &amp;q);                           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = Ralt^2-Q (3) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">107</span>     secp256k1_fe_normalize_weak(&amp;<span style="color: rgba(0, 0, 0, 1)">t);
</span><span style="color: rgba(0, 128, 128, 1)">108</span>     r-&gt;x = t;                                           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;x = Ralt^2-Q (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">109</span>     secp256k1_fe_mul_int(&amp;t, <span style="color: rgba(128, 0, 128, 1)">2</span>);                        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = 2*x3 (2) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">110</span>     secp256k1_fe_add(&amp;t, &amp;q);                           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = 2*x3 - Q: (4) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">111</span>     secp256k1_fe_mul(&amp;t, &amp;t, &amp;rr_alt);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = Ralt*(2*x3 - Q) (1) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">112</span>     secp256k1_fe_add(&amp;t, &amp;n);                           <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> t = Ralt*(2*x3 - Q) + M^3*Malt (3) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">113</span>     secp256k1_fe_negate(&amp;r-&gt;y, &amp;t, <span style="color: rgba(128, 0, 128, 1)">3</span>);                  <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;y = Ralt*(Q - 2x3) - M^3*Malt (4) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">114</span>     secp256k1_fe_normalize_weak(&amp;r-&gt;<span style="color: rgba(0, 0, 0, 1)">y);
</span><span style="color: rgba(0, 128, 128, 1)">115</span>     secp256k1_fe_mul_int(&amp;r-&gt;x, <span style="color: rgba(128, 0, 128, 1)">4</span>);                     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;x = X3 = 4*(Ralt^2-Q) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">116</span>     secp256k1_fe_mul_int(&amp;r-&gt;y, <span style="color: rgba(128, 0, 128, 1)">4</span>);                     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> r-&gt;y = Y3 = 4*Ralt*(Q - 2x3) - 4*M^3*Malt (4) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">117</span> 
<span style="color: rgba(0, 128, 128, 1)">118</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* In case a-&gt;infinity == 1, replace r with (b-&gt;x, b-&gt;y, 1). </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">119</span>     secp256k1_fe_cmov(&amp;r-&gt;x, &amp;b-&gt;x, a-&gt;<span style="color: rgba(0, 0, 0, 1)">infinity);
</span><span style="color: rgba(0, 128, 128, 1)">120</span>     secp256k1_fe_cmov(&amp;r-&gt;y, &amp;b-&gt;y, a-&gt;<span style="color: rgba(0, 0, 0, 1)">infinity);
</span><span style="color: rgba(0, 128, 128, 1)">121</span>     secp256k1_fe_cmov(&amp;r-&gt;z, &amp;fe_1, a-&gt;<span style="color: rgba(0, 0, 0, 1)">infinity);
</span><span style="color: rgba(0, 128, 128, 1)">122</span>     r-&gt;infinity =<span style="color: rgba(0, 0, 0, 1)"> infinity;
</span><span style="color: rgba(0, 128, 128, 1)">123</span> }</pre>
</div>
<p>注释中第22~30行正是由之前的公式而来，源码中参数b是一个仿射坐标的曲线点(x<sub>2</sub>, y<sub>2</sub>)，其对应雅可比射影坐标可表示为(x<sub>2</sub>, y<sub>2</sub>, 1)。源码第33~59行注释说了如何对4中特殊情况进行处理的，尤其是第4中情况degenerate case，它特指如下情形：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250708111403622-945607086.png" alt="" width="292" height="112" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>下图展示了一个典型的secp256k1椭圆曲线 <span class="katex"><span class="katex-mathml">y<sup>2</sup>=x<sup>3</sup>+7</span></span>中的退化情况示例，P和Q满足以上1和3两个条件，却在实数域中不可能满足第2个条件，但是有限域<span class="katex"><span class="katex-mathml">Fp<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathbb"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight"><span class="vlist-s">​<span class="vlist-r"><span class="vlist">中该条件却有可能成立，所以代码中也把这种情况考虑进去了，其他特殊情况比较显而易见，不再详细说明。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250708113655587-191097796.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h1>参考：</h1>
<p><a href="https://link.springer.com/chapter/10.1007/3-540-45664-3_24" target="_blank" rel="noopener nofollow">weierstrass elliptic curves and side-channel attacks</a></p>
<p><a href="https://blog.csdn.net/qq_50680426/article/details/120940244" target="_blank" rel="noopener nofollow">https://blog.csdn.net/qq_50680426/article/details/120940244</a></p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-08 12:02">2025-07-08 12:02</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18963669);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18963669', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18963669/secp256k1_3', title: 'secp256k1算法详解三（点操作关键理论及源码分析）' })">举报</a>
</div>
        