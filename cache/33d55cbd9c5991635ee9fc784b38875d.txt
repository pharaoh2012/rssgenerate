
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/blbl-blog/p/18897109" title="发布于 2025-05-26 16:57">
    <span role="heading" aria-level="2">如何通过接口实现动态二维码的定时刷新</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="如何通过接口实现动态二维码的定时刷新"><strong>如何通过接口实现动态二维码的定时刷新？</strong></h1>
<p>感觉本篇对你有帮助可以关注一下我的<mark>微信公众号（深入浅出谈java）</mark>，会不定期更新知识和面试资料、技巧！！！</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202504/2719585-20250424145859162-898697358.png" alt="" loading="lazy"></p>
<h2 id="一需求场景"><strong>一、需求场景</strong></h2>
<p>在Web应用中，动态二维码常用于以下场景：</p>
<ol>
<li><strong>登录验证</strong>：微信扫码登录、APP扫码授权</li>
<li><strong>支付场景</strong>：支付宝/微信支付码定时刷新</li>
<li><strong>票务系统</strong>：电子票二维码防截屏盗用</li>
<li><strong>会员系统</strong>：动态会员码累计积分</li>
</ol>
<h2 id="二技术方案设计"><strong>二、技术方案设计</strong></h2>
<p><strong>1、 整体流程</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250526164322628-1168891807.png" alt="" loading="lazy"></p>
<h1 id="三前端部分">三、前端部分</h1>
<h2 id="大致流程">大致流程</h2>
<p>1、请求后端接口（按照现有项目格式即可）</p>
<p>2、后端接口的返回类型定义（byte[]）</p>
<p>3、前端接收时定义响应类型（<strong>重点：</strong><mark>responseType: 'arraybuffer'</mark>）</p>
<p>4、对后端返回数据进行转化：arrayBufferToBase64</p>
<p>5、对数据和标签进行绑定</p>
<h2 id="具体实现">具体实现</h2>
<p>1、获取后端 二维码 图片接口</p>
<pre><code class="language-js">	import {
		generateMemberCode
	} from '@/api/inter/member-code.js';

data() {
			return {
				codeImg: '',
				timer: null, // 添加定时器引用,
			}
		},
		onShow() {
			// 立即加载一次
			this.makeMemberCode();

			// 设置定时器（注意保存引用）
			this.timer = setInterval(() =&gt; {
				this.makeMemberCode();
			}, 30000);
		},
		onHide() {
			// 页面隐藏时清除定时器
			if (this.timer) {
				clearInterval(this.timer);
				this.timer = null;
			}
		},
        methods: {
			async makeMemberCode() {
				const memberId = 1; // 使用假数据中的 id
				const memberName = '张三'; // 使用假数据中的 nickname
				const params = {
					memberId,
					memberName
				};
				try {
                    // 调用后端接口（这里可改成符合你项目的请求方式）
					const response = await generateMemberCode(params);
					console.log('完整响应:', response);

					// 调试数据类型
					console.log('响应数据类型:', typeof response);

					// 处理二进制数据（适用于小程序）
					if (typeof response === 'object' &amp;&amp; response instanceof ArrayBuffer) {
						const base64 = uni.arrayBufferToBase64(response);
						this.codeImg = `data:image/png;base64,${base64}`;
						console.log('新的 codeImg:', this.codeImg); // 调试输出
					} else if (typeof response.data === 'string') {
						this.codeImg = `data:image/png;base64,${response.data}`;
					}
					// 处理URL
					else if (response.data.imageUrl) {
						this.codeImg = response.data.imageUrl;
					}
				} catch (error) {
					console.error('请求失败:', error);
					uni.showToast({
						title: '会员码加载失败',
						icon: 'none'
					});
				}
			}
        }
</code></pre>
<p>上面部分用到的代码:  <strong>member-code.js</strong></p>
<pre><code class="language-js">import { HttpClient } from '@/api/utils/request.js'; // 确保路径正确
import api from '../../config/api.js'; // 导入 API 配置

const http = new HttpClient(api.base);


/**
 * 获取后端二维码
 */
export async function generateMemberCode(params) {
    try {
        const response = await http.getbuffer('/api/wx/generate-qrcode',params);
        console.log('Response:', response);
        return response; // 返回响应数据
    } catch (error) {
        console.error('Error:', error);
        throw error; // 继续抛出错误以供上层处理
    }
}
</code></pre>
<p>请求接口工具类：<strong>request.js</strong></p>
<pre><code class="language-js">class HttpClient {
	constructor(baseURL) {
		this.baseURL = baseURL;
	}

async getbuffer(url, params = {}) {
		try {
			//await this.checkTokenAndNavigate(); // 在发送请求前检查 token
			const queryString = this.buildQueryString(params);
			const fullURL = `${this.baseURL}${url}${queryString}`;
	
			return new Promise((resolve, reject) =&gt; {
				uni.request({
					url: fullURL,
					method: 'GET',
					header: {
						'Content-Type': 'application/json',
						'X-Auth-Token': `${uni.getStorageSync('token')}` // 如果需要在 header 中发送 token
					},
					responseType: 'arraybuffer', // 指定响应类型为 arraybuffer
					success: (response) =&gt; {
						resolve(response.data);
					},
					fail: (error) =&gt; {
						console.error('GET request error:', error);
						reject(error);
					}
				});
			});
		} catch (error) {
			// 如果 checkTokenAndNavigate 抛出错误（例如没有 token），则这里处理错误
			return Promise.reject(error);
		}
	}
    buildQueryString(params) {
	  if (!params || Object.keys(params).length === 0) {
	    return '';
	  }
	  return '?' + Object.keys(params)
	    .map(key =&gt; encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
	    .join('&amp;');
	}
}

export {
	HttpClient
};
</code></pre>
<p>接口地址Api 配置类：<strong>API.js</strong></p>
<pre><code class="language-js">// 生产环境
const prod = {
  base: "http://XXXXXX:8099",
};

// 开发环境
const dev = {
  base: "http://XXXXXXX:8099",
};

// 默认生产环境
let api = prod;

// 如果是开发环境
if (process.env.NODE_ENV === "development") {
  api = dev;
}

// 微信小程序和App的打包方式建议为生产环境，所以这块直接条件编译赋值()
// #ifdef MP-WEIXIN || APP-PLUS
// 这个直接使用的是 dev 地址
api = dev;
// #endif

export default {
  ...api,
};
</code></pre>
<p>2、模板进行渲染</p>
<pre><code class="language-vue">	&lt;view class="qrcode d-flex just-content-center align-items-center"&gt;
					&lt;image :src="`${codeImg}`" style="width: 350rpx; height: 350rpx;"&gt;&lt;/image&gt;
				&lt;/view&gt;
</code></pre>
<h1 id="四后端部分">四、后端部分</h1>
<h2 id="具体实现-1">具体实现</h2>
<p>1、添加依赖</p>
<pre><code class="language-xml">&lt;!-- ZXing Core and Java SE --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
        &lt;artifactId&gt;core&lt;/artifactId&gt;
        &lt;version&gt;3.4.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
        &lt;artifactId&gt;javase&lt;/artifactId&gt;
        &lt;version&gt;3.4.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>2、接口实现controller</p>
<pre><code class="language-java">import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayOutputStream;
import java.nio.file.FileSystems;
import java.util.HashMap;
import java.util.Map;

@RestController
public class QRCodeController {

    @GetMapping("/generate-qrcode")
    public ResponseEntity&lt;byte[]&gt; generateQRCode(
            @RequestParam String memberId,
            @RequestParam String memberName) throws WriterException {
        
        // 构建二维码内容（内容可根据自己业务动态修改）
        // 建议加上唯一标识，安全码、起始时间、状态等，保证二维码安全性
        String qrContent = "Member ID: " + memberId + ", Member Name: " + memberName;

        // 设置二维码参数
        int width = 300;
        int height = 300;
        String imageFormat = "PNG"; // 图片格式

        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;();
        hints.put(EncodeHintType.CHARACTER_SET, "UTF-8");

        // 生成二维码
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(qrContent, BarcodeFormat.QR_CODE, width, height, hints);

        // 将二维码写入字节数组输出流
        ByteArrayOutputStream pngOutputStream = new ByteArrayOutputStream();
        MatrixToImageWriter.writeToStream(bitMatrix, imageFormat, pngOutputStream);

        // 返回二维码图片
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.IMAGE_PNG);
        return new ResponseEntity&lt;&gt;(pngOutputStream.toByteArray(), headers, HttpStatus.OK);
    }
}

</code></pre>
<p><strong>接口测试</strong></p>
<p>GET <a href="http://localhost:8080/generate-qrcode?memberId=12345&amp;memberName=JohnDoe" target="_blank" rel="noopener nofollow">http://localhost:8080/generate-qrcode?memberId=12345&amp;memberName=JohnDoe</a></p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250526164358909-300084117.png" alt="" loading="lazy"></p>
<p>前端处理后端的数据时，在一定要指定相应类型：<strong>responseType: 'arraybuffer'</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250526164412938-673168969.png" alt="" loading="lazy"></p>
<h1 id="五效果展示">五、效果展示</h1>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250526165108162-3474732.gif" alt="" loading="lazy"></p>
<h1 id="六安全性设计"><strong>六、安全性设计</strong></h1>
<table>
<thead>
<tr>
<th style="text-align: left">风险</th>
<th style="text-align: left">防御方案</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">二维码盗用</td>
<td style="text-align: left">30秒短时效性 + 单次有效性验证</td>
</tr>
<tr>
<td style="text-align: left">接口暴力请求</td>
<td style="text-align: left">限流策略（如Guava RateLimiter）</td>
</tr>
<tr>
<td style="text-align: left">中间人攻击</td>
<td style="text-align: left">全站HTTPS + 数据签名</td>
</tr>
<tr>
<td style="text-align: left">XSS攻击</td>
<td style="text-align: left">前端输入过滤 + CSP安全策略</td>
</tr>
</tbody>
</table>
<h1 id="七总结"><strong>七、总结</strong></h1>
<p><strong>关键技术栈</strong>：</p>
<ul>
<li>前端定时器 + 二进制流处理</li>
<li>后端二维码生成 + 状态管理</li>
<li>高效的缓存策略</li>
</ul>
<p><strong>最佳实践建议</strong>：</p>
<ol>
<li>始终为二维码添加时效性和唯一性标识</li>
<li>敏感操作需二次确认（如扫码后的授权确认）</li>
<li>监控二维码使用率，优化生成策略</li>
</ol>
<p>通过前后端协作，动态二维码既能提升用户体验，又能有效保障系统安全性。</p>
<p>最后文章有啥不对，欢迎大佬在评论区指点！！！<br>
如果感觉对你有帮助就点赞推荐或者关注一下吧！！！<br>
<img src="https://img2024.cnblogs.com/blog/2719585/202409/2719585-20240927091023464-1188976011.gif" alt="img" loading="lazy"></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.22101052199189813" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-26 16:57">2025-05-26 16:57</span>&nbsp;
<a href="https://www.cnblogs.com/blbl-blog">古渡蓝按</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18897109);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18897109', targetLink: 'https://www.cnblogs.com/blbl-blog/p/18897109', title: '如何通过接口实现动态二维码的定时刷新' })">举报</a>
</div>
	