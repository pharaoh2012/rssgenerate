
	<h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/YLTFY1998/p/18850683" title="发布于 2025-04-27 23:56">
    <span role="heading" aria-level="2">2个小时1.5w字｜ React &amp; Golang 全栈微服务实战</span>
    

</a>
</h1>
	    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1754362/202504/1754362-20250427235258288-1692383903.png" alt="2个小时1.5w字｜ React &amp;amp; Golang 全栈微服务实战" class="desc_img">
        本文分为6个小节，带你全方位入门 React &amp; Golang 微服务全栈开发。
&gt; 1. golang
&gt; 2. kratos
&gt; 3. react
&gt; 4. next.js
&gt; 5. docker
&gt; 6. 博客案例
每一个小节均有丰富的代码案例，仓库地址如下：
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#前言" rel="noopener nofollow">前言</a></li><li><a href="#golang-入门教程" rel="noopener nofollow">Golang 入门教程</a><ul><li><a href="#1-下载与环境配置" rel="noopener nofollow">1. 下载与环境配置</a><ul><li><a href="#安装-go" rel="noopener nofollow">安装 Go</a><ul><li><a href="#windows-安装" rel="noopener nofollow">Windows 安装</a></li><li><a href="#macos-安装" rel="noopener nofollow">macOS 安装</a></li><li><a href="#linux-安装" rel="noopener nofollow">Linux 安装</a></li></ul></li><li><a href="#理解-goroot-和-gopath" rel="noopener nofollow">理解 GOROOT 和 GOPATH</a><ul><li><a href="#goroot" rel="noopener nofollow">GOROOT</a></li><li><a href="#gopath" rel="noopener nofollow">GOPATH</a></li><li><a href="#go-modules-与-gopath-的关系" rel="noopener nofollow">Go Modules 与 GOPATH 的关系</a></li><li><a href="#查看和设置-go-环境变量" rel="noopener nofollow">查看和设置 Go 环境变量</a></li></ul></li><li><a href="#配置-gopath" rel="noopener nofollow">配置 GOPATH</a></li></ul></li><li><a href="#2-语法与包管理" rel="noopener nofollow">2. 语法与包管理</a><ul><li><a href="#go-基础语法" rel="noopener nofollow">Go 基础语法</a></li><li><a href="#运行-go-程序" rel="noopener nofollow">运行 Go 程序</a></li><li><a href="#构建-go-程序" rel="noopener nofollow">构建 Go 程序</a></li><li><a href="#包管理-go-modules" rel="noopener nofollow">包管理 (Go Modules)</a></li><li><a href="#常用标准库" rel="noopener nofollow">常用标准库</a></li><li><a href="#推荐学习资源" rel="noopener nofollow">推荐学习资源</a></li></ul></li><li><a href="#扩展练习" rel="noopener nofollow">扩展练习</a></li></ul></li><li><a href="#kratos-微服务框架入门" rel="noopener nofollow">Kratos 微服务框架入门</a><ul><li><a href="#1-kratos-核心介绍" rel="noopener nofollow">1. Kratos 核心介绍</a><ul><li><a href="#11-核心理念" rel="noopener nofollow">1.1 核心理念</a></li><li><a href="#12-主要特性" rel="noopener nofollow">1.2 主要特性</a></li><li><a href="#13-设计架构" rel="noopener nofollow">1.3 设计架构</a></li></ul></li><li><a href="#2-项目初始化方法" rel="noopener nofollow">2. 项目初始化方法</a><ul><li><a href="#21-安装-kratos-命令行工具" rel="noopener nofollow">2.1 安装 Kratos 命令行工具</a></li><li><a href="#22-创建新项目" rel="noopener nofollow">2.2 创建新项目</a></li><li><a href="#23-添加-api-定义" rel="noopener nofollow">2.3 添加 API 定义</a></li><li><a href="#24-生成-api-代码" rel="noopener nofollow">2.4 生成 API 代码</a></li></ul></li><li><a href="#3-cli-工具详解" rel="noopener nofollow">3. CLI 工具详解</a><ul><li><a href="#31-主要命令" rel="noopener nofollow">3.1 主要命令</a></li><li><a href="#32-proto-相关命令" rel="noopener nofollow">3.2 Proto 相关命令</a></li><li><a href="#33-工具依赖" rel="noopener nofollow">3.3 工具依赖</a></li></ul></li><li><a href="#4-依赖注入" rel="noopener nofollow">4. 依赖注入</a><ul><li><a href="#41-wire-基础" rel="noopener nofollow">4.1 Wire 基础</a></li><li><a href="#42-provider-定义" rel="noopener nofollow">4.2 Provider 定义</a></li><li><a href="#43-wire-注入点" rel="noopener nofollow">4.3 Wire 注入点</a></li><li><a href="#44-生成注入代码" rel="noopener nofollow">4.4 生成注入代码</a></li></ul></li><li><a href="#5-项目结构详解" rel="noopener nofollow">5. 项目结构详解</a><ul><li><a href="#51-标准目录结构" rel="noopener nofollow">5.1 标准目录结构</a></li><li><a href="#52-各目录职责" rel="noopener nofollow">5.2 各目录职责</a></li></ul></li><li><a href="#6-项目运行链路分析" rel="noopener nofollow">6. 项目运行链路分析</a><ul><li><a href="#61-启动流程" rel="noopener nofollow">6.1 启动流程</a></li><li><a href="#62-请求处理流程" rel="noopener nofollow">6.2 请求处理流程</a></li><li><a href="#63-http服务示例" rel="noopener nofollow">6.3 HTTP服务示例</a></li><li><a href="#64-完整服务架构" rel="noopener nofollow">6.4 完整服务架构</a></li></ul></li><li><a href="#扩展阅读与资源" rel="noopener nofollow">扩展阅读与资源</a></li></ul></li><li><a href="#react-入门教程" rel="noopener nofollow">React 入门教程</a><ul><li><a href="#1-下载与环境配置-1" rel="noopener nofollow">1. 下载与环境配置</a><ul><li><a href="#安装-nodejs-和-pnpm" rel="noopener nofollow">安装 Node.js 和 pnpm</a></li><li><a href="#创建新的-react-应用" rel="noopener nofollow">创建新的 React 应用</a></li></ul></li><li><a href="#2-react-基本语法与包管理" rel="noopener nofollow">2. React 基本语法与包管理</a><ul><li><a href="#基本概念" rel="noopener nofollow">基本概念</a></li><li><a href="#函数组件示例" rel="noopener nofollow">函数组件示例</a></li><li><a href="#使用-state-hook" rel="noopener nofollow">使用 State Hook</a></li><li><a href="#使用-effect-hook" rel="noopener nofollow">使用 Effect Hook</a></li><li><a href="#包管理与依赖" rel="noopener nofollow">包管理与依赖</a></li></ul></li><li><a href="#本目录代码示例说明" rel="noopener nofollow">本目录代码示例说明</a><ul><li><a href="#如何运行示例代码" rel="noopener nofollow">如何运行示例代码</a></li></ul></li><li><a href="#pnpm-常用命令参考" rel="noopener nofollow">pnpm 常用命令参考</a></li><li><a href="#学习资源" rel="noopener nofollow">学习资源</a></li><li><a href="#练习建议" rel="noopener nofollow">练习建议</a></li></ul></li><li><a href="#nextjs-入门教程" rel="noopener nofollow">Next.js 入门教程</a><ul><li><a href="#1-项目目录与优雅实践" rel="noopener nofollow">1. 项目目录与优雅实践</a><ul><li><a href="#nextjs-项目结构-app-router" rel="noopener nofollow">Next.js 项目结构 (App Router)</a></li><li><a href="#nextjs-app-router-优雅实践" rel="noopener nofollow">Next.js App Router 优雅实践</a></li></ul></li><li><a href="#2-快速启动案例前端" rel="noopener nofollow">2. 快速启动案例前端</a><ul><li><a href="#安装-nodejs-和-pnpm-1" rel="noopener nofollow">安装 Node.js 和 pnpm</a></li><li><a href="#创建-nextjs-项目" rel="noopener nofollow">创建 Next.js 项目</a></li><li><a href="#项目结构设置" rel="noopener nofollow">项目结构设置</a></li><li><a href="#创建首页" rel="noopener nofollow">创建首页</a></li><li><a href="#创建页面" rel="noopener nofollow">创建页面</a></li><li><a href="#创建布局" rel="noopener nofollow">创建布局</a></li><li><a href="#创建动态路由" rel="noopener nofollow">创建动态路由</a></li><li><a href="#创建-api-路由" rel="noopener nofollow">创建 API 路由</a></li><li><a href="#数据获取" rel="noopener nofollow">数据获取</a></li><li><a href="#安装依赖" rel="noopener nofollow">安装依赖</a></li><li><a href="#运行开发服务器" rel="noopener nofollow">运行开发服务器</a></li><li><a href="#构建和部署" rel="noopener nofollow">构建和部署</a></li></ul></li><li><a href="#pnpm-优势" rel="noopener nofollow">pnpm 优势</a></li><li><a href="#pnpm-常用命令" rel="noopener nofollow">pnpm 常用命令</a></li><li><a href="#nodejs-与-nextjs-的关系" rel="noopener nofollow">Node.js 与 Next.js 的关系</a><ul><li><a href="#nodejs-与-nextjs-的基本关系" rel="noopener nofollow">Node.js 与 Next.js 的基本关系</a></li><li><a href="#nextjs-的运行时环境" rel="noopener nofollow">Next.js 的运行时环境</a><ul><li><a href="#开发环境" rel="noopener nofollow">开发环境</a></li><li><a href="#生产环境" rel="noopener nofollow">生产环境</a></li></ul></li><li><a href="#渲染模式与nodejs的关系" rel="noopener nofollow">渲染模式与Node.js的关系</a></li><li><a href="#nodejs-环境的限制" rel="noopener nofollow">Node.js 环境的限制</a></li><li><a href="#部署架构" rel="noopener nofollow">部署架构</a></li></ul></li><li><a href="#本目录示例代码说明" rel="noopener nofollow">本目录示例代码说明</a></li><li><a href="#app-router-和-pages-router-的区别" rel="noopener nofollow">App Router 和 Pages Router 的区别</a></li><li><a href="#进阶资源" rel="noopener nofollow">进阶资源</a></li><li><a href="#练习建议-1" rel="noopener nofollow">练习建议</a></li></ul></li><li><a href="#容器知识入门教程" rel="noopener nofollow">容器知识入门教程</a><ul><li><a href="#docker-背景介绍" rel="noopener nofollow">Docker 背景介绍</a><ul><li><a href="#什么是-docker" rel="noopener nofollow">什么是 Docker</a></li><li><a href="#docker-的发展历史" rel="noopener nofollow">Docker 的发展历史</a></li><li><a href="#为什么需要-docker" rel="noopener nofollow">为什么需要 Docker</a></li><li><a href="#docker-vs-虚拟机" rel="noopener nofollow">Docker vs 虚拟机</a></li></ul></li><li><a href="#1-docker-安装" rel="noopener nofollow">1. Docker 安装</a><ul><li><a href="#windows-安装-1" rel="noopener nofollow">Windows 安装</a></li><li><a href="#macos-安装-1" rel="noopener nofollow">macOS 安装</a></li><li><a href="#linux-安装-ubuntu" rel="noopener nofollow">Linux 安装 (Ubuntu)</a></li><li><a href="#验证安装" rel="noopener nofollow">验证安装</a></li></ul></li><li><a href="#2-常用-docker-命令" rel="noopener nofollow">2. 常用 Docker 命令</a><ul><li><a href="#镜像相关命令" rel="noopener nofollow">镜像相关命令</a></li><li><a href="#容器相关命令" rel="noopener nofollow">容器相关命令</a></li><li><a href="#docker-compose-命令" rel="noopener nofollow">Docker Compose 命令</a></li><li><a href="#网络和存储命令" rel="noopener nofollow">网络和存储命令</a></li></ul></li><li><a href="#示例项目说明" rel="noopener nofollow">示例项目说明</a><ul><li><a href="#如何运行示例项目" rel="noopener nofollow">如何运行示例项目</a></li><li><a href="#项目文件说明" rel="noopener nofollow">项目文件说明</a><ul><li><a href="#dockerfile" rel="noopener nofollow">Dockerfile</a></li><li><a href="#docker-composeyml" rel="noopener nofollow">docker-compose.yml</a></li><li><a href="#appjs" rel="noopener nofollow">app.js</a></li></ul></li></ul></li><li><a href="#docker-网络详解" rel="noopener nofollow">Docker 网络详解</a><ul><li><a href="#docker-网络的主要作用" rel="noopener nofollow">Docker 网络的主要作用</a></li><li><a href="#常用网络类型" rel="noopener nofollow">常用网络类型</a><ul><li><a href="#网络驱动类型" rel="noopener nofollow">网络驱动类型</a></li></ul></li></ul></li><li><a href="#docker-卷详解" rel="noopener nofollow">Docker 卷详解</a><ul><li><a href="#docker-卷的主要作用" rel="noopener nofollow">Docker 卷的主要作用</a></li><li><a href="#卷的使用方式" rel="noopener nofollow">卷的使用方式</a><ul><li><a href="#卷的类型" rel="noopener nofollow">卷的类型</a></li></ul></li></ul></li><li><a href="#docker-进阶概念" rel="noopener nofollow">Docker 进阶概念</a></li><li><a href="#相关资源" rel="noopener nofollow">相关资源</a></li><li><a href="#练习建议-2" rel="noopener nofollow">练习建议</a></li></ul></li><li><a href="#全栈博客案例" rel="noopener nofollow">全栈博客案例</a><ul><li><a href="#代码仓库" rel="noopener nofollow">代码仓库</a></li></ul></li></ul></div><p></p>
<h1 id="前言">前言</h1>
<p>本文分为6个小节，带你全方位入门 React &amp; Golang 微服务全栈开发。</p>
<blockquote>
<ol>
<li>golang</li>
<li>kratos</li>
<li>react</li>
<li>next.js</li>
<li>docker</li>
<li>博客案例</li>
</ol>
</blockquote>
<p>每一个小节均有丰富的代码案例，仓库地址如下：<a href="https://github.com/BaiZe1998/go-learning" target="_blank" rel="noopener nofollow">https://github.com/BaiZe1998/go-learning</a></p>
<p><img src="https://baize-blog-images.oss-cn-shanghai.aliyuncs.com/img/image-20250427231439177.png" alt="image-20250427231439177" loading="lazy"></p>
<blockquote>
<p>Golang｜AI 主题知识星球：<a href="https://wx.zsxq.com/group/51111852421224" target="_blank" rel="noopener nofollow">白泽说</a> 试运营当中，添加 wx：baize_talk02 咨询，免费加入。</p>
</blockquote>
<p><img src="https://baize-blog-images.oss-cn-shanghai.aliyuncs.com/img/image-20250427221707115.png" alt="image-20250427221707115" loading="lazy"></p>
<h1 id="golang-入门教程">Golang 入门教程</h1>
<h2 id="1-下载与环境配置">1. 下载与环境配置</h2>
<h3 id="安装-go">安装 Go</h3>
<h4 id="windows-安装">Windows 安装</h4>
<ol>
<li>访问 <a href="https://golang.org/dl/" target="_blank" rel="noopener nofollow">Go 官方下载页面</a></li>
<li>下载 Windows 安装包 (MSI)</li>
<li>运行安装程序，按照提示完成安装</li>
<li>安装完成后，打开命令提示符，输入 <code>go version</code> 确认安装成功</li>
</ol>
<h4 id="macos-安装">macOS 安装</h4>
<ol>
<li>访问 <a href="https://golang.org/dl/" target="_blank" rel="noopener nofollow">Go 官方下载页面</a></li>
<li>下载 macOS 安装包 (PKG)</li>
<li>运行安装程序，按照提示完成安装</li>
<li>或者使用 Homebrew: <code>brew install go</code></li>
<li>安装完成后，打开终端，输入 <code>go version</code> 确认安装成功</li>
</ol>
<h4 id="linux-安装">Linux 安装</h4>
<ol>
<li>
<p>访问 <a href="https://golang.org/dl/" target="_blank" rel="noopener nofollow">Go 官方下载页面</a></p>
</li>
<li>
<p>下载对应的 Linux 压缩包</p>
</li>
<li>
<p>解压到 <code>/usr/local</code>：</p>
<pre><code class="language-bash">sudo tar -C /usr/local -xzf go1.x.x.linux-amd64.tar.gz
</code></pre>
</li>
<li>
<p>添加环境变量到 <code>~/.profile</code> 或 <code>~/.bashrc</code>：</p>
<pre><code class="language-bash">export PATH=$PATH:/usr/local/go/bin
</code></pre>
</li>
<li>
<p>使环境变量生效：<code>source ~/.profile</code> 或 <code>source ~/.bashrc</code></p>
</li>
<li>
<p>验证安装：<code>go version</code></p>
</li>
</ol>
<h3 id="理解-goroot-和-gopath">理解 GOROOT 和 GOPATH</h3>
<h4 id="goroot">GOROOT</h4>
<p>GOROOT 是 Go 语言的安装目录，它包含了 Go 标准库、编译器、工具等。安装 Go 时会自动设置这个环境变量。</p>
<ul>
<li>
<p><strong>作用</strong>：告诉 Go 工具链在哪里可以找到 Go 的标准库和工具</p>
</li>
<li>
<p><strong>默认位置</strong>：</p>
<ul>
<li>Windows: <code>C:\go</code></li>
<li>macOS/Linux: <code>/usr/local/go</code> 或 Homebrew 安装位置</li>
</ul>
</li>
<li>
<p><strong>查看 GOROOT</strong>：</p>
<pre><code class="language-bash">go env GOROOT
</code></pre>
</li>
<li>
<p><strong>手动设置</strong>（通常不需要，除非安装在非标准位置）：</p>
<ul>
<li>Windows: 添加系统环境变量 <code>GOROOT=C:\path\to\go</code></li>
<li>macOS/Linux: 在 <code>~/.profile</code> 或 <code>~/.bashrc</code> 中添加 <code>export GOROOT=/path/to/go</code></li>
</ul>
</li>
</ul>
<h4 id="gopath">GOPATH</h4>
<p>GOPATH 是 Go 的工作目录，用于存放 Go 代码、包和依赖等。</p>
<ul>
<li>
<p><strong>作用</strong>：</p>
<ul>
<li>在 Go Modules 出现前（Go 1.11之前），所有 Go 项目必须位于 GOPATH 内</li>
<li>在 Go Modules 时代，GOPATH 主要用于存储下载的依赖包和编译后的二进制文件</li>
</ul>
</li>
<li>
<p><strong>默认位置</strong>：</p>
<ul>
<li>Windows: <code>%USERPROFILE%\go</code> (例如：<code>C:\Users\YourName\go</code>)</li>
<li>macOS/Linux: <code>$HOME/go</code> (例如：<code>/home/username/go</code> 或 <code>/Users/username/go</code>)</li>
</ul>
</li>
<li>
<p><strong>GOPATH 目录结构</strong>：</p>
<ul>
<li><code>src</code>: 存放源代码（如你的项目和依赖包的源码）</li>
<li><code>pkg</code>: 存放编译后的包文件</li>
<li><code>bin</code>: 存放编译后的可执行文件</li>
</ul>
</li>
<li>
<p><strong>设置多个 GOPATH</strong>：<br>
可以设置多个目录，用冒号（Unix）或分号（Windows）分隔</p>
<pre><code class="language-bash"># Unix/macOS
export GOPATH=$HOME/go:$HOME/projects/go

# Windows
set GOPATH=%USERPROFILE%\go;D:\projects\go
</code></pre>
</li>
</ul>
<h4 id="go-modules-与-gopath-的关系">Go Modules 与 GOPATH 的关系</h4>
<p>从 Go 1.11 开始，Go 引入了 Go Modules 作为官方的依赖管理解决方案，逐渐弱化了 GOPATH 的作用：</p>
<ul>
<li>
<p><strong>Go Modules 模式下</strong>：</p>
<ul>
<li>项目可以位于任何目录，不必在 GOPATH 内</li>
<li>依赖通过 <code>go.mod</code> 文件管理，而不是通过 GOPATH 目录结构</li>
<li>下载的依赖缓存在 <code>$GOPATH/pkg/mod</code> 目录</li>
<li>编译的命令仍安装到 <code>$GOPATH/bin</code></li>
</ul>
</li>
<li>
<p><strong>环境变量 GO111MODULE</strong>：</p>
<ul>
<li><code>GO111MODULE=off</code>: 禁用模块支持，使用 GOPATH 模式</li>
<li><code>GO111MODULE=on</code>: 启用模块支持，忽略 GOPATH</li>
<li><code>GO111MODULE=auto</code>: 在 GOPATH 内禁用模块支持，在 GOPATH 外启用模块支持</li>
</ul>
</li>
</ul>
<h4 id="查看和设置-go-环境变量">查看和设置 Go 环境变量</h4>
<pre><code class="language-bash"># 查看所有 Go 环境变量
go env

# 查看特定环境变量
go env GOPATH
go env GOROOT

# 设置环境变量（Go 1.14+）
go env -w GOPATH=/custom/path
</code></pre>
<h3 id="配置-gopath">配置 GOPATH</h3>
<p>GOPATH 是工作目录，用于存放 Go 代码、包和依赖等：</p>
<ol>
<li>创建 GOPATH 目录，例如：<code>mkdir -p $HOME/go</code></li>
<li>设置环境变量：
<ul>
<li>Windows: 添加 <code>GOPATH</code> 系统环境变量，值为你创建的目录路径</li>
<li>macOS/Linux: 在 <code>~/.profile</code> 或 <code>~/.bashrc</code> 中添加 <code>export GOPATH=$HOME/go</code></li>
</ul>
</li>
<li>GOPATH 目录结构：
<ul>
<li><code>src</code>: 源代码</li>
<li><code>pkg</code>: 包文件</li>
<li><code>bin</code>: 可执行文件</li>
</ul>
</li>
</ol>
<h2 id="2-语法与包管理">2. 语法与包管理</h2>
<h3 id="go-基础语法">Go 基础语法</h3>
<p>查看 <code>hello.go</code> 文件了解 Go 的基本语法，包括：</p>
<ul>
<li>包声明与导入</li>
<li>变量声明与使用</li>
<li>基本数据类型</li>
<li>控制流（条件语句、循环）</li>
<li>函数定义与调用</li>
<li>切片与数组操作</li>
</ul>
<h3 id="运行-go-程序">运行 Go 程序</h3>
<pre><code class="language-bash">go run hello.go
</code></pre>
<h3 id="构建-go-程序">构建 Go 程序</h3>
<pre><code class="language-bash">go build hello.go
./hello  # 运行编译后的可执行文件
</code></pre>
<h3 id="包管理-go-modules">包管理 (Go Modules)</h3>
<p>从 Go 1.11 开始，Go 引入了 Go Modules 作为官方的依赖管理解决方案：</p>
<ol>
<li>
<p>初始化一个新模块：</p>
<pre><code class="language-bash">go mod init example.com/myproject
</code></pre>
</li>
<li>
<p>添加依赖：</p>
<pre><code class="language-bash">go get github.com/some/dependency
</code></pre>
</li>
<li>
<p>整理和更新依赖：</p>
<pre><code class="language-bash">go mod tidy
</code></pre>
</li>
<li>
<p>查看所有依赖：</p>
<pre><code class="language-bash">go list -m all
</code></pre>
</li>
</ol>
<h3 id="常用标准库">常用标准库</h3>
<ul>
<li><code>fmt</code>: 格式化输入输出</li>
<li><code>io</code>: 基本 I/O 接口</li>
<li><code>os</code>: 操作系统功能</li>
<li><code>net/http</code>: HTTP 客户端和服务器</li>
<li><code>encoding/json</code>: JSON 编解码</li>
<li><code>time</code>: 时间相关功能</li>
<li><code>sync</code>: 同步原语</li>
</ul>
<h3 id="推荐学习资源">推荐学习资源</h3>
<ul>
<li><a href="https://golang.org/doc/" target="_blank" rel="noopener nofollow">Go 官方文档</a></li>
<li><a href="https://gobyexample.com/" target="_blank" rel="noopener nofollow">Go by Example</a></li>
<li><a href="https://tour.golang.org/" target="_blank" rel="noopener nofollow">Go Tour</a></li>
</ul>
<h2 id="扩展练习">扩展练习</h2>
<ol>
<li>修改 <code>hello.go</code> 添加更多功能</li>
<li>创建一个简单的 HTTP 服务器</li>
<li>实现文件读写操作</li>
<li>使用 Go 实现一个简单的 CLI 工具</li>
</ol>
<h1 id="kratos-微服务框架入门">Kratos 微服务框架入门</h1>
<p><a href="https://github.com/go-kratos/kratos" target="_blank" rel="noopener nofollow">Kratos</a> 是一个轻量级的、模块化的、可插拔的Go微服务框架，专注于帮助开发人员快速构建微服务。本教程将带你深入了解 Kratos 的核心概念和使用方法。</p>
<h2 id="1-kratos-核心介绍">1. Kratos 核心介绍</h2>
<p>Kratos 是哔哩哔哩开源的一款Go微服务框架，具有以下核心特点：</p>
<h3 id="11-核心理念">1.1 核心理念</h3>
<ul>
<li><strong>简洁</strong>：提供了简洁、统一的接口定义和使用方式</li>
<li><strong>模块化</strong>：各个组件可独立使用，也可组合使用</li>
<li><strong>可扩展</strong>：支持各类中间件和插件的扩展</li>
<li><strong>高性能</strong>：追求极致的性能优化</li>
</ul>
<h3 id="12-主要特性">1.2 主要特性</h3>
<ul>
<li><strong>传输层</strong>：支持 HTTP 和 gRPC 服务，并提供统一抽象</li>
<li><strong>中间件</strong>：丰富的内置中间件，如日志、指标、跟踪、限流等</li>
<li><strong>注册发现</strong>：支持多种服务注册与发现机制</li>
<li><strong>配置管理</strong>：灵活的配置加载和动态配置</li>
<li><strong>错误处理</strong>：统一的错误处理和错误码管理</li>
<li><strong>API定义</strong>：使用 Protocol Buffers 作为 API 定义语言</li>
<li><strong>依赖注入</strong>：使用 Wire 进行依赖管理和注入</li>
</ul>
<h3 id="13-设计架构">1.3 设计架构</h3>
<p>Kratos 采用领域驱动设计 (DDD) 的六边形架构，将应用分为以下层次：</p>
<ul>
<li><strong>API层</strong>：定义服务接口，通常使用Proto文件</li>
<li><strong>Service层</strong>：处理服务业务逻辑的实现</li>
<li><strong>Biz层</strong>：核心业务逻辑和领域模型</li>
<li><strong>Data层</strong>：数据访问层，负责与持久化存储交互</li>
<li><strong>Server层</strong>：传输层，提供HTTP/gRPC服务</li>
</ul>
<h2 id="2-项目初始化方法">2. 项目初始化方法</h2>
<p>Kratos 提供了完善的项目初始化流程，帮助开发者快速创建项目骨架。</p>
<h3 id="21-安装-kratos-命令行工具">2.1 安装 Kratos 命令行工具</h3>
<pre><code class="language-bash"># 安装最新版本的 Kratos 命令行工具
go install github.com/go-kratos/kratos/cmd/kratos/v2@latest
</code></pre>
<h3 id="22-创建新项目">2.2 创建新项目</h3>
<pre><code class="language-bash"># 创建名为 myproject 的新项目
kratos new myproject

# 进入项目目录
cd myproject
</code></pre>
<h3 id="23-添加-api-定义">2.3 添加 API 定义</h3>
<pre><code class="language-bash"># 创建 API 文件
kratos proto add api/myproject/v1/myproject.proto
</code></pre>
<h3 id="24-生成-api-代码">2.4 生成 API 代码</h3>
<p>在编写完 proto 文件后，使用 kratos 命令生成相应代码：</p>
<pre><code class="language-bash"># 生成客户端代码
kratos proto client api/myproject/v1/myproject.proto

# 生成服务端代码
kratos proto server api/myproject/v1/myproject.proto -t internal/service
</code></pre>
<h2 id="3-cli-工具详解">3. CLI 工具详解</h2>
<p>Kratos CLI 是 Kratos 框架的命令行工具，提供了丰富的功能帮助开发者提高效率。</p>
<h3 id="31-主要命令">3.1 主要命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>用法示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new</code></td>
<td>创建新项目</td>
<td><code>kratos new myproject</code></td>
</tr>
<tr>
<td><code>proto</code></td>
<td>管理 Proto 文件与代码生成</td>
<td><code>kratos proto add/client/server</code></td>
</tr>
<tr>
<td><code>run</code></td>
<td>运行项目</td>
<td><code>kratos run</code></td>
</tr>
<tr>
<td><code>build</code></td>
<td>构建项目</td>
<td><code>kratos build</code></td>
</tr>
<tr>
<td><code>upgrade</code></td>
<td>更新 Kratos 工具</td>
<td><code>kratos upgrade</code></td>
</tr>
</tbody>
</table>
<h3 id="32-proto-相关命令">3.2 Proto 相关命令</h3>
<pre><code class="language-bash"># 添加新的 proto 文件
kratos proto add api/helloworld/v1/greeter.proto

# 生成 client 代码
kratos proto client api/helloworld/v1/greeter.proto

# 生成 server 代码
kratos proto server api/helloworld/v1/greeter.proto -t internal/service

# 生成所有代码
kratos proto all api/helloworld/v1/greeter.proto -t internal/service
</code></pre>
<h3 id="33-工具依赖">3.3 工具依赖</h3>
<p>使用 Kratos 相关功能需要安装以下组件：</p>
<pre><code class="language-bash"># 安装 protoc 编译器依赖
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
go install github.com/go-kratos/kratos/cmd/protoc-gen-go-http/v2@latest
go install github.com/go-kratos/kratos/cmd/protoc-gen-go-errors/v2@latest
</code></pre>
<h2 id="4-依赖注入">4. 依赖注入</h2>
<p>Kratos 使用 <a href="https://github.com/google/wire" target="_blank" rel="noopener nofollow">Wire</a> 框架进行依赖注入，实现了组件的松耦合和代码的可测试性。</p>
<h3 id="41-wire-基础">4.1 Wire 基础</h3>
<p>Wire 是 Google 开发的编译时依赖注入工具，通过代码生成而非反射实现依赖注入。</p>
<h3 id="42-provider-定义">4.2 Provider 定义</h3>
<p>在 Kratos 中，各个组件通过 Provider 函数提供实例：</p>
<pre><code class="language-go">// data层 provider
func NewData(conf *conf.Data, logger log.Logger) (*Data, func(), error) {
    // 实例化数据层
    cleanup := func() {
        // 清理资源
    }
    return &amp;Data{}, cleanup, nil
}

// biz层 provider
func NewGreeterUsecase(repo GreeterRepo, logger log.Logger) *GreeterUsecase {
    return &amp;GreeterUsecase{repo: repo}
}

// service层 provider
func NewGreeterService(uc *biz.GreeterUsecase, logger log.Logger) *GreeterService {
    return &amp;GreeterService{uc: uc}
}
</code></pre>
<h3 id="43-wire-注入点">4.3 Wire 注入点</h3>
<p>在 <code>cmd/server/wire.go</code> 中定义依赖注入：</p>
<pre><code class="language-go">// ProviderSet 是各层的依赖集合
var ProviderSet = wire.NewSet(
    data.ProviderSet,
    biz.ProviderSet,
    service.ProviderSet,
    server.ProviderSet,
)

// 应用实例化函数
func initApp(*conf.Server, *conf.Data, log.Logger) (*kratos.App, error) {
    panic(wire.Build(ProviderSet, newApp))
}
</code></pre>
<h3 id="44-生成注入代码">4.4 生成注入代码</h3>
<pre><code class="language-bash"># 生成依赖注入代码
cd cmd/server
wire
</code></pre>
<h2 id="5-项目结构详解">5. 项目结构详解</h2>
<p>Kratos 项目结构遵循 DDD 六边形架构，组织清晰。</p>
<h3 id="51-标准目录结构">5.1 标准目录结构</h3>
<pre><code>├── api                    # API 定义目录 (protobuf)
│   └── helloworld
│       └── v1
│           └── greeter.proto
├── cmd                    # 应用程序入口
│   └── server
│       ├── main.go
│       ├── wire.go        # 依赖注入
│       └── wire_gen.go    # 自动生成的依赖注入代码
├── configs                # 配置文件目录
│   └── config.yaml
├── internal               # 私有应用代码
│   ├── biz                # 业务逻辑层 (领域模型)
│   │   ├── biz.go
│   │   └── greeter.go
│   ├── conf               # 配置处理代码
│   │   ├── conf.proto
│   │   └── conf.pb.go
│   ├── data               # 数据访问层 (持久化)
│   │   ├── data.go
│   │   └── greeter.go
│   ├── server             # 传输层(HTTP/gRPC)
│   │   ├── server.go
│   │   ├── http.go
│   │   └── grpc.go
│   └── service            # 服务实现层
│       └── greeter.go
├── third_party            # 第三方 proto 文件
└── go.mod
</code></pre>
<h3 id="52-各目录职责">5.2 各目录职责</h3>
<ol>
<li><strong>api</strong>: 定义服务 API 接口，使用 Protocol Buffers</li>
<li><strong>cmd</strong>: 程序入口，包含 main 函数和依赖注入</li>
<li><strong>configs</strong>: 配置文件</li>
<li><strong>internal</strong>: 私有代码，不对外暴露
<ul>
<li><strong>biz</strong>: 核心业务逻辑，包含领域模型和业务规则</li>
<li><strong>data</strong>: 数据访问层，实现数据库操作和缓存</li>
<li><strong>server</strong>: 服务器定义，包括 HTTP 和 gRPC 服务器配置</li>
<li><strong>service</strong>: 服务实现，连接 API 和业务逻辑</li>
</ul>
</li>
<li><strong>third_party</strong>: 第三方依赖的 proto 文件</li>
</ol>
<h2 id="6-项目运行链路分析">6. 项目运行链路分析</h2>
<p>Kratos 应用从启动到处理请求的完整流程。</p>
<h3 id="61-启动流程">6.1 启动流程</h3>
<ol>
<li><strong>初始化配置</strong>：加载 configs 目录的配置文件</li>
<li><strong>依赖注入</strong>：通过 Wire 构建应用依赖关系</li>
<li><strong>创建服务器</strong>：初始化 HTTP/gRPC 服务器</li>
<li><strong>注册服务</strong>：注册 API 实现</li>
<li><strong>启动服务</strong>：启动服务监听</li>
</ol>
<pre><code class="language-go">// main.go 中的启动流程
func main() {
    // 1. 初始化 logger
    logger := log.NewStdLogger(os.Stdout)
    
    // 2. 加载配置
    c := config.New(config.WithSource(file.NewSource(flagconf)))
    if err := c.Load(); err != nil {
        panic(err)
    }
    
    // 3. 通过依赖注入创建 app 实例
    app, cleanup, err := wireApp(c, logger)
    if err != nil {
        panic(err)
    }
    defer cleanup()
    
    // 4. 启动应用
    if err := app.Run(); err != nil {
        panic(err)
    }
}
</code></pre>
<h3 id="62-请求处理流程">6.2 请求处理流程</h3>
<p>HTTP 请求从接收到响应的完整流程：</p>
<ol>
<li><strong>接收请求</strong>：HTTP/gRPC 服务器接收请求</li>
<li><strong>中间件处理</strong>：请求经过中间件链（日志、跟踪、限流等）</li>
<li><strong>路由匹配</strong>：根据路径匹配对应处理器</li>
<li><strong>参数解析</strong>：解析和验证请求参数</li>
<li><strong>服务层处理</strong>：Service 层实现请求处理</li>
<li><strong>业务逻辑</strong>：调用 Biz 层的领域逻辑</li>
<li><strong>数据访问</strong>：通过 Data 层访问数据库或缓存</li>
<li><strong>响应构建</strong>：构建响应数据</li>
<li><strong>中间件后处理</strong>：响应经过中间件链</li>
<li><strong>返回响应</strong>：返回给客户端</li>
</ol>
<h3 id="63-http服务示例">6.3 HTTP服务示例</h3>
<p>以下是一个简化的 HTTP 服务示例：</p>
<pre><code class="language-go">import (
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos/v2/middleware/recovery"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func main() {
    // 初始化 logger
    logger := log.NewStdLogger(os.Stdout)
    
    // 创建 HTTP 服务器
    httpSrv := http.NewServer(
        http.Address(":8000"),
        http.Middleware(
            recovery.Recovery(), // 异常恢复中间件
        ),
    )
    
    // 注册路由
    r := httpSrv.Route("/")
    r.GET("/hello", func(ctx http.Context) error {
        return ctx.String(200, "Hello Kratos!")
    })
    
    // 创建 Kratos 应用
    app := kratos.New(
        kratos.Name("example"),
        kratos.Server(httpSrv),
        kratos.Logger(logger),
    )
    
    // 启动应用
    if err := app.Run(); err != nil {
        log.Error(err)
    }
}
</code></pre>
<h3 id="64-完整服务架构">6.4 完整服务架构</h3>
<p>在实际项目中，请求处理链路涉及多个组件和层次：</p>
<pre><code>客户端 → 负载均衡 → HTTP/gRPC服务器 → 中间件链 → 路由 → Service层 → Biz层 → Data层 → 数据库/缓存
             ↑                                                             ↓
服务注册/发现 ← ←  ←  ←  ←  ←  ←  ←  ←  ←  ←  ←  ←  ← 响应  ←  ←  ←  ←  ← ←
</code></pre>
<h2 id="扩展阅读与资源">扩展阅读与资源</h2>
<ul>
<li><a href="https://github.com/go-kratos/kratos" target="_blank" rel="noopener nofollow">Kratos GitHub</a></li>
<li><a href="https://go-kratos.dev/docs/" target="_blank" rel="noopener nofollow">Kratos 文档</a></li>
<li><a href="https://github.com/go-kratos/examples" target="_blank" rel="noopener nofollow">Kratos 示例</a></li>
<li><a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener nofollow">Protocol Buffers</a></li>
<li><a href="https://github.com/google/wire" target="_blank" rel="noopener nofollow">Wire 依赖注入</a></li>
</ul>
<h1 id="react-入门教程">React 入门教程</h1>
<p>React 是由 Facebook 开发的一个用于构建用户界面的 JavaScript 库。React 使开发人员能够构建快速、可扩展的 Web 应用程序。</p>
<h2 id="1-下载与环境配置-1">1. 下载与环境配置</h2>
<p>要开始使用 React，您需要一个现代的 JavaScript 环境和 Node.js 开发环境。</p>
<h3 id="安装-nodejs-和-pnpm">安装 Node.js 和 pnpm</h3>
<p>首先，安装 Node.js（包含 npm）：</p>
<ul>
<li><strong>Windows/macOS</strong>: 从 <a href="https://nodejs.org/" target="_blank" rel="noopener nofollow">Node.js 官网</a> 下载并安装</li>
<li><strong>macOS (使用 Homebrew)</strong>: <code>brew install node</code></li>
<li><strong>Linux</strong>: <code>sudo apt install nodejs npm</code> 或 <code>sudo yum install nodejs npm</code></li>
</ul>
<p>验证安装：</p>
<pre><code class="language-bash">node -v
</code></pre>
<p>然后安装 pnpm (性能更好的包管理器)：</p>
<pre><code class="language-bash"># 使用npm安装pnpm
npm install -g pnpm

# 验证pnpm安装
pnpm --version
</code></pre>
<h3 id="创建新的-react-应用">创建新的 React 应用</h3>
<p>使用 Create React App 工具创建新的 React 应用：</p>
<pre><code class="language-bash"># 创建新项目
pnpm create react-app my-react-app

# 进入项目目录
cd my-react-app

# 启动开发服务器
pnpm start
</code></pre>
<p>或者使用 Vite 创建（更快的启动速度，推荐）：</p>
<pre><code class="language-bash"># 使用 Vite 创建 React 项目
pnpm create vite my-react-app --template react

# 进入项目目录
cd my-react-app

# 安装依赖
pnpm install

# 启动开发服务器
pnpm dev
</code></pre>
<h2 id="2-react-基本语法与包管理">2. React 基本语法与包管理</h2>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p><strong>组件 (Components)</strong>：React 应用由组件构成</p>
<ul>
<li>函数组件（推荐）</li>
<li>类组件</li>
</ul>
</li>
<li>
<p><strong>JSX</strong>：JavaScript 的语法扩展，允许在 JS 中编写类似 HTML 的代码</p>
</li>
<li>
<p><strong>Props</strong>：向组件传递数据的方式</p>
</li>
<li>
<p><strong>State</strong>：组件的内部状态</p>
</li>
<li>
<p><strong>Hooks</strong>：在函数组件中使用状态和其他 React 特性的 API</p>
</li>
</ol>
<h3 id="函数组件示例">函数组件示例</h3>
<pre><code class="language-jsx">import React from 'react';

function Greeting(props) {
  return &lt;h1&gt;你好，{props.name}！&lt;/h1&gt;;
}

export default Greeting;
</code></pre>
<h3 id="使用-state-hook">使用 State Hook</h3>
<pre><code class="language-jsx">import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;你点击了 {count} 次&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        点击我
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="使用-effect-hook">使用 Effect Hook</h3>
<pre><code class="language-jsx">import React, { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(seconds =&gt; seconds + 1);
    }, 1000);
    
    return () =&gt; clearInterval(interval);
  }, []);

  return &lt;div&gt;计时器：{seconds} 秒&lt;/div&gt;;
}
</code></pre>
<h3 id="包管理与依赖">包管理与依赖</h3>
<p>React 项目使用 pnpm 管理依赖（pnpm比npm和yarn更快、更高效）：</p>
<pre><code class="language-bash"># 安装依赖
pnpm add react-router-dom

# 安装开发依赖
pnpm add -D typescript @types/react

# 更新所有依赖
pnpm update

# 运行脚本
pnpm run dev
</code></pre>
<p>pnpm的主要优势：</p>
<ul>
<li><strong>磁盘空间高效</strong>：pnpm使用内容寻址存储来避免重复安装</li>
<li><strong>快速安装</strong>：比npm和yarn快2-3倍</li>
<li><strong>严格的依赖管理</strong>：更好的避免依赖地狱问题</li>
<li><strong>支持monorepo</strong>：内置对工作空间的支持</li>
</ul>
<p>常用的包：</p>
<ul>
<li><strong>react-router-dom</strong>: 路由管理</li>
<li><strong>axios</strong>: HTTP 请求</li>
<li><strong>zustand</strong> 或 <strong>redux-toolkit</strong>: 状态管理</li>
<li><strong>styled-components</strong> 或 <strong>emotion</strong>: CSS-in-JS 解决方案</li>
<li><strong>MUI</strong> 或 <strong>Ant Design</strong>: UI 组件库</li>
</ul>
<h2 id="本目录代码示例说明">本目录代码示例说明</h2>
<p>本目录包含两个主要文件：</p>
<ol>
<li>
<p><strong>App.jsx</strong>: 包含三个示例组件</p>
<ul>
<li>计数器：展示基本的状态管理</li>
<li>计时器：展示 useEffect 的使用</li>
<li>待办事项列表：展示更复杂的状态管理</li>
</ul>
</li>
<li>
<p><strong>App.css</strong>: 为组件提供样式</p>
</li>
</ol>
<h3 id="如何运行示例代码">如何运行示例代码</h3>
<p>要运行本示例，需要将这些文件集成到一个 React 项目中：</p>
<ol>
<li>
<p>创建新的 React 应用：</p>
<pre><code class="language-bash">pnpm create vite react-demo --template react
cd react-demo
pnpm install
</code></pre>
</li>
<li>
<p>替换 <code>src/App.jsx</code> 和 <code>src/App.css</code> 为本目录中的文件</p>
</li>
<li>
<p>启动应用：</p>
<pre><code class="language-bash">pnpm dev
</code></pre>
</li>
</ol>
<h2 id="pnpm-常用命令参考">pnpm 常用命令参考</h2>
<pre><code class="language-bash"># 初始化新项目
pnpm init

# 安装依赖
pnpm add [package]

# 安装开发依赖
pnpm add -D [package]

# 全局安装
pnpm add -g [package]

# 运行脚本
pnpm [script]

# 移除依赖
pnpm remove [package]

# 更新依赖
pnpm update

# 查看过时依赖
pnpm outdated
</code></pre>
<h2 id="学习资源">学习资源</h2>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener nofollow">React 官方文档</a></li>
<li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener nofollow">React Hooks 文档</a></li>
<li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener nofollow">pnpm 官方文档</a></li>
<li><a href="https://vitejs.dev/guide/" target="_blank" rel="noopener nofollow">Vite 官方文档</a></li>
<li><a href="https://reactrouter.com/web/guides/quick-start" target="_blank" rel="noopener nofollow">React Router 文档</a></li>
</ul>
<h2 id="练习建议">练习建议</h2>
<ol>
<li>修改计数器组件，添加最大值和最小值限制</li>
<li>为待办事项添加优先级功能</li>
<li>添加一个新的表单组件，练习表单处理</li>
<li>尝试使用 Context API 在组件之间共享状态</li>
</ol>
<h1 id="nextjs-入门教程">Next.js 入门教程</h1>
<p>Next.js 是一个基于 React 的轻量级框架，用于构建静态和服务器渲染的应用程序。它提供了丰富的功能，如服务器端渲染、静态网站生成、API 路由、自动代码分割等。本教程基于 Next.js 13+ 的 App Router。</p>
<h2 id="1-项目目录与优雅实践">1. 项目目录与优雅实践</h2>
<h3 id="nextjs-项目结构-app-router">Next.js 项目结构 (App Router)</h3>
<p>一个典型的 Next.js 项目结构如下：</p>
<pre><code>my-nextjs-app/
│
├── app/               # App Router 目录（基于文件约定的路由）
│   ├── layout.tsx     # 根布局组件
│   ├── page.tsx       # 首页 (/)
│   ├── about/         # 关于页面路由
│   │   └── page.tsx   # 关于页面 (/about)
│   ├── blogs/         # 博客路由
│   │   ├── [id]/      # 动态路由
│   │   │   └── page.tsx # 博客文章页面 
│   │   ├── new/       # 创建新博客
│   │   │   └── page.tsx # 创建博客页面
│   │   └── page.tsx   # 博客列表页面 
│   ├── api/           # API 路由
│   │   └── route.ts   # API 处理器 
│   ├── globals.css    # 全局样式
│   └── error.tsx      # 错误处理页面
│
├── components/        # React 组件
│   ├── ui/            # UI 组件
│   └── ClientComponent.tsx # 客户端组件示例
│
├── lib/               # 工具函数和库
│   └── utils.ts
│
├── public/            # 静态资源
│   ├── favicon.ico    
│   └── images/
│
├── .next/             # Next.js 构建输出 (git ignored)
├── node_modules/      # 依赖 (git ignored)
├── package.json       # 项目依赖和脚本
├── pnpm-lock.yaml     # pnpm 锁文件
├── next.config.js     # Next.js 配置
├── tsconfig.json      # TypeScript 配置
└── README.md          # 项目说明
</code></pre>
<h3 id="nextjs-app-router-优雅实践">Next.js App Router 优雅实践</h3>
<ol>
<li>
<p><strong>文件系统路由约定</strong></p>
<ul>
<li><code>app/page.tsx</code> → <code>/</code> (首页)</li>
<li><code>app/about/page.tsx</code> → <code>/about</code> (关于页面)</li>
<li><code>app/blogs/[id]/page.tsx</code> → <code>/blogs/:id</code> (动态路由)</li>
<li>特殊文件：
<ul>
<li><code>layout.tsx</code>: 布局组件</li>
<li><code>loading.tsx</code>: 加载状态</li>
<li><code>error.tsx</code>: 错误处理</li>
<li><code>not-found.tsx</code>: 404页面</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据获取方法</strong></p>
<ul>
<li>React Server Components 中的直接获取</li>
<li><code>generateStaticParams</code>: 静态路径生成</li>
<li><code>revalidatePath</code>/<code>revalidateTag</code>: 按需重新验证</li>
<li>客户端数据获取: SWR 或 React Query</li>
</ul>
</li>
<li>
<p><strong>API 路由</strong></p>
<ul>
<li><code>app/api/*/route.ts</code> 文件定义 API 端点</li>
<li>使用 <code>NextResponse</code> 进行响应处理</li>
</ul>
</li>
<li>
<p><strong>布局系统</strong></p>
<ul>
<li>嵌套布局</li>
<li>平行路由和拦截路由</li>
<li>模板和分组</li>
</ul>
</li>
<li>
<p><strong>渲染策略</strong></p>
<ul>
<li>服务器组件（默认）</li>
<li>客户端组件 ('use client')</li>
<li>流式渲染和部分渲染</li>
</ul>
</li>
</ol>
<h2 id="2-快速启动案例前端">2. 快速启动案例前端</h2>
<h3 id="安装-nodejs-和-pnpm-1">安装 Node.js 和 pnpm</h3>
<p>首先，确保你已安装 Node.js 和 pnpm：</p>
<pre><code class="language-bash"># 安装 pnpm (如果尚未安装)
npm install -g pnpm

# 验证安装
pnpm --version
</code></pre>
<h3 id="创建-nextjs-项目">创建 Next.js 项目</h3>
<p>使用 pnpm 创建新的 Next.js 项目：</p>
<pre><code class="language-bash"># 使用 create-next-app 创建TypeScript项目
pnpm create next-app my-nextjs-app --typescript

# 进入项目目录
cd my-nextjs-app
</code></pre>
<p>在创建项目过程中，会提示你选择一些选项。请确保选择 "Yes" 当询问是否使用 App Router 时。</p>
<h3 id="项目结构设置">项目结构设置</h3>
<p>默认情况下，<code>create-next-app</code> 生成的项目已经包含基本结构。您可以根据需要添加额外的目录。</p>
<h3 id="创建首页">创建首页</h3>
<p>首页是访问者首先看到的页面，在 <code>app/page.tsx</code> 文件中创建：</p>
<pre><code class="language-tsx">// app/page.tsx
import Link from 'next/link';

export default function Home() {
  return (
    &lt;div className="container mx-auto px-4 py-8"&gt;
      &lt;section className="py-12 text-center"&gt;
        &lt;h1 className="text-4xl font-bold mb-4"&gt;欢迎来到我的博客&lt;/h1&gt;
        &lt;p className="text-lg text-gray-600 mb-8"&gt;探索技术、设计和创意的世界&lt;/p&gt;
        &lt;Link 
          href="/blog" 
          className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
        &gt;
          浏览博客文章
        &lt;/Link&gt;
      &lt;/section&gt;
      
      &lt;section className="py-8"&gt;
        &lt;h2 className="text-2xl font-bold mb-6 text-center"&gt;最新文章&lt;/h2&gt;
        &lt;div className="grid md:grid-cols-3 gap-6"&gt;
          &lt;div className="border rounded-lg p-6 hover:shadow-md transition-shadow"&gt;
            &lt;h3 className="text-xl font-semibold mb-3"&gt;Next.js入门指南&lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;了解如何使用Next.js构建现代Web应用&lt;/p&gt;
            &lt;Link href="/blog/1" className="text-blue-600 hover:underline"&gt;
              阅读更多 &amp;rarr;
            &lt;/Link&gt;
          &lt;/div&gt;
          &lt;div className="border rounded-lg p-6 hover:shadow-md transition-shadow"&gt;
            &lt;h3 className="text-xl font-semibold mb-3"&gt;React服务器组件详解&lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;深入理解React服务器组件的工作原理&lt;/p&gt;
            &lt;Link href="/blog/2" className="text-blue-600 hover:underline"&gt;
              阅读更多 &amp;rarr;
            &lt;/Link&gt;
          &lt;/div&gt;
          &lt;div className="border rounded-lg p-6 hover:shadow-md transition-shadow"&gt;
            &lt;h3 className="text-xl font-semibold mb-3"&gt;TypeScript与Next.js&lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;如何在Next.js项目中充分利用TypeScript&lt;/p&gt;
            &lt;Link href="/blog/3" className="text-blue-600 hover:underline"&gt;
              阅读更多 &amp;rarr;
            &lt;/Link&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
      
      &lt;section className="py-8"&gt;
        &lt;h2 className="text-2xl font-bold mb-6 text-center"&gt;关于客户端组件&lt;/h2&gt;
        &lt;div className="border rounded-lg p-6"&gt;
          &lt;p className="text-gray-700 mb-4"&gt;
            Next.js的App Router架构区分&lt;strong&gt;服务器组件&lt;/strong&gt;和&lt;strong&gt;客户端组件&lt;/strong&gt;。
            默认情况下，所有组件都是服务器组件，在服务器上渲染并发送到客户端。
          &lt;/p&gt;
          &lt;p className="text-gray-700 mb-4"&gt;
            当需要使用浏览器API、添加交互性或使用React hooks时，应该使用客户端组件。
            通过在文件顶部添加 &lt;code className="bg-gray-100 px-2 py-1 rounded"&gt;'use client'&lt;/code&gt; 指令来声明客户端组件。
          &lt;/p&gt;
          &lt;div className="bg-gray-50 p-4 rounded-lg"&gt;
            &lt;h3 className="font-semibold mb-2"&gt;客户端组件示例：&lt;/h3&gt;
            &lt;pre className="bg-gray-800 text-white p-4 rounded overflow-x-auto"&gt;
              &lt;code&gt;{`'use client'

import { useState, useEffect } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)
  
  return (
    &lt;div&gt;
      &lt;h3&gt;计数器: {count}&lt;/h3&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        增加
      &lt;/button&gt;
    &lt;/div&gt;
  )
}`}&lt;/code&gt;
            &lt;/pre&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section className="py-8"&gt;
        &lt;h2 className="text-2xl font-bold mb-6 text-center"&gt;功能演示&lt;/h2&gt;
        &lt;div className="grid md:grid-cols-2 gap-6"&gt;
          &lt;div className="border rounded-lg p-6 hover:shadow-md transition-shadow"&gt;
            &lt;h3 className="text-xl font-semibold mb-3"&gt;博客列表&lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;查看使用服务器组件和模拟数据实现的博客列表页面&lt;/p&gt;
            &lt;Link href="/blog" className="text-blue-600 hover:underline"&gt;
              查看示例 &amp;rarr;
            &lt;/Link&gt;
          &lt;/div&gt;
          &lt;div className="border rounded-lg p-6 hover:shadow-md transition-shadow"&gt;
            &lt;h3 className="text-xl font-semibold mb-3"&gt;客户端组件&lt;/h3&gt;
            &lt;p className="text-gray-600 mb-4"&gt;了解如何在Next.js中使用客户端组件实现交互功能&lt;/p&gt;
            &lt;Link href="/client-example" className="text-blue-600 hover:underline"&gt;
              查看示例 &amp;rarr;
            &lt;/Link&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>首页包含了以下元素：</p>
<ul>
<li>欢迎区域，包含标题和指向博客列表的链接</li>
<li>最新文章区域，展示最近的博客文章</li>
</ul>
<h3 id="创建页面">创建页面</h3>
<p>在 <code>app</code> 目录中创建 <code>page.tsx</code> 文件以添加新页面：</p>
<pre><code class="language-tsx">// app/about/page.tsx
export default function AboutPage() {
  return (
    &lt;div&gt;
      &lt;h1&gt;关于我们&lt;/h1&gt;
      &lt;p&gt;这是 Next.js 示例项目的关于页面。&lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="创建布局">创建布局</h3>
<p>使用 <code>layout.tsx</code> 文件创建布局：</p>
<pre><code class="language-tsx">// app/layout.tsx
import type { ReactNode } from 'react';

interface RootLayoutProps {
  children: ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    &lt;html lang="zh"&gt;
      &lt;body&gt;
        &lt;header&gt;
          &lt;nav&gt;
            {/* 导航栏组件 */}
          &lt;/nav&gt;
        &lt;/header&gt;
        &lt;main&gt;{children}&lt;/main&gt;
        &lt;footer&gt;© {new Date().getFullYear()} 我的 Next.js 应用&lt;/footer&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</code></pre>
<h3 id="创建动态路由">创建动态路由</h3>
<p>使用方括号语法创建动态路由：</p>
<pre><code class="language-tsx">// app/blogs/[id]/page.tsx
import { notFound } from 'next/navigation';
import Link from 'next/link';

// 模拟博客数据
const blogPosts = [
  { 
    id: '1', 
    title: 'Next.js入门指南',
    content: `
      &lt;p&gt;Next.js是一个基于React的强大框架，它提供了许多内置功能，使得构建现代Web应用变得更加简单。&lt;/p&gt;
      &lt;h2&gt;主要特性&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li&gt;服务器端渲染 (SSR)&lt;/li&gt;
        &lt;li&gt;静态站点生成 (SSG)&lt;/li&gt;
        &lt;li&gt;API路由&lt;/li&gt;
        &lt;li&gt;文件系统路由&lt;/li&gt;
        &lt;li&gt;内置CSS和Sass支持&lt;/li&gt;
        &lt;li&gt;代码分割和打包优化&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;使用Next.js，你可以快速开发出高性能的React应用，无需复杂的配置。&lt;/p&gt;
    `,
    author: {
      name: '张三',
      avatar: 'https://randomuser.me/api/portraits/men/1.jpg'
    },
    publishedAt: '2023-05-15',
    tags: ['Next.js', 'React', '前端开发']
  },
  { 
    id: '2', 
    title: 'React服务器组件详解',
    content: `
      &lt;p&gt;React服务器组件是React的一项新特性，它允许开发者创建在服务器上渲染的组件，从而提高性能并减少客户端JavaScript的体积。&lt;/p&gt;
      &lt;h2&gt;服务器组件的优势&lt;/h2&gt;
      &lt;ol&gt;
        &lt;li&gt;减少客户端JavaScript包大小&lt;/li&gt;
        &lt;li&gt;直接访问服务器资源（数据库、文件系统等）&lt;/li&gt;
        &lt;li&gt;自动代码分割&lt;/li&gt;
        &lt;li&gt;改善首次加载性能&lt;/li&gt;
      &lt;/ol&gt;
      &lt;p&gt;在Next.js的App Router中，所有组件默认都是服务器组件，除非你显式声明为客户端组件。&lt;/p&gt;
    `,
    author: {
      name: '李四',
      avatar: 'https://randomuser.me/api/portraits/women/2.jpg'
    },
    publishedAt: '2023-06-22',
    tags: ['React', '服务器组件', '性能优化']
  },
  { 
    id: '3', 
    title: 'TypeScript与Next.js',
    content: `
      &lt;p&gt;TypeScript是JavaScript的超集，添加了静态类型检查，在Next.js项目中使用TypeScript可以带来诸多好处。&lt;/p&gt;
      &lt;h2&gt;TypeScript的优势&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li&gt;静态类型检查，减少运行时错误&lt;/li&gt;
        &lt;li&gt;更好的IDE支持，包括代码补全和智能提示&lt;/li&gt;
        &lt;li&gt;更容易维护的代码库&lt;/li&gt;
        &lt;li&gt;自文档化的代码&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h2&gt;在Next.js中使用TypeScript&lt;/h2&gt;
      &lt;p&gt;Next.js原生支持TypeScript，你可以直接创建.tsx或.ts文件，无需额外配置。&lt;/p&gt;
      &lt;p&gt;对于页面和API路由，你可以使用TypeScript接口来定义props和请求参数的类型。&lt;/p&gt;
    `,
    author: {
      name: '王五',
      avatar: 'https://randomuser.me/api/portraits/men/3.jpg'
    },
    publishedAt: '2023-07-10',
    tags: ['TypeScript', 'Next.js', '类型安全']
  }
];

// 获取博客帖子函数
const getBlogPost = (id: string) =&gt; {
  return blogPosts.find(post =&gt; post.id === id);
};

// 博客详情页面组件
export default function BlogPostPage({ params }: { params: { id: string } }) {
  const post = getBlogPost(params.id);
  
  // 如果没有找到文章，返回404
  if (!post) {
    notFound();
  }
  
  return (
    &lt;div className="container mx-auto px-4 py-8"&gt;
      &lt;article className="max-w-3xl mx-auto"&gt;
        &lt;div className="mb-8"&gt;
          &lt;Link href="/blog" className="text-blue-600 hover:underline mb-4 inline-block"&gt;
            &amp;larr; 返回博客列表
          &lt;/Link&gt;
          &lt;h1 className="text-4xl font-bold mb-4"&gt;{post.title}&lt;/h1&gt;
          
          &lt;div className="flex items-center mb-6"&gt;
            &lt;img 
              src={post.author.avatar} 
              alt={post.author.name}
              className="w-10 h-10 rounded-full mr-3"
            /&gt;
            &lt;div&gt;
              &lt;p className="font-medium"&gt;{post.author.name}&lt;/p&gt;
              &lt;p className="text-gray-500 text-sm"&gt;发布于 {post.publishedAt}&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          
          &lt;div className="flex flex-wrap gap-2 mb-8"&gt;
            {post.tags.map(tag =&gt; (
              &lt;span key={tag} className="bg-blue-100 text-blue-800 text-sm px-3 py-1 rounded-full"&gt;
                {tag}
              &lt;/span&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div 
          className="prose prose-lg max-w-none"
          dangerouslySetInnerHTML={{ __html: post.content }}
        /&gt;
        
        &lt;div className="mt-12 pt-8 border-t border-gray-200"&gt;
          &lt;h3 className="text-xl font-bold mb-4"&gt;分享这篇文章&lt;/h3&gt;
          &lt;div className="flex space-x-4"&gt;
            &lt;button className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"&gt;
              分享到微信
            &lt;/button&gt;
            &lt;button className="px-4 py-2 bg-blue-400 text-white rounded hover:bg-blue-500"&gt;
              分享到微博
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
} 
</code></pre>
<h3 id="创建-api-路由">创建 API 路由</h3>
<p>在 <code>app/api</code> 目录中创建 API 端点：</p>
<pre><code class="language-ts">// app/api/hello/route.ts
// app/api/route.ts
import { NextRequest, NextResponse } from 'next/server'

// 模拟用户数据
const users = [
  { id: '1', name: '张三', email: 'zhangsan@example.com' },
  { id: '2', name: '李四', email: 'lisi@example.com' },
  { id: '3', name: '王五', email: 'wangwu@example.com' }
];

export async function GET() {
  return NextResponse.json({ 
    success: true,
    data: users,
    timestamp: new Date().toISOString()
  })
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // 验证请求数据
    if (!body.name) {
      return NextResponse.json(
        { success: false, error: '名称不能为空' },
        { status: 400 }
      )
    }
    
    // 模拟创建新用户
    const newUser = {
      id: (users.length + 1).toString(),
      name: body.name,
      email: body.email || null
    }
    
    // 在真实应用中，这里会将用户添加到数据库
    // 这里只是模拟
    
    return NextResponse.json({ 
      success: true, 
      data: newUser 
    }, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { success: false, error: '请求处理失败' },
      { status: 500 }
    )
  }
}
</code></pre>
<h3 id="数据获取">数据获取</h3>
<p>在服务器组件中进行数据获取（默认情况下，<code>page.tsx</code> 是服务器组件）：</p>
<pre><code class="language-tsx">// app/blog/page.tsx - 服务器组件
import Link from 'next/link';
import BlogActions from './components/BlogActions';

// 模拟博客数据
const blogs = [
  { 
    id: '1', 
    title: 'Next.js入门指南',
    excerpt: '了解如何使用Next.js构建现代Web应用',
    author: {
      name: '张三',
      avatar: 'https://randomuser.me/api/portraits/men/1.jpg'
    },
    publishedAt: '2023-05-15',
    tags: ['Next.js', 'React', '前端开发']
  },
  { 
    id: '2', 
    title: 'React服务器组件详解',
    excerpt: '深入理解React服务器组件的工作原理',
    author: {
      name: '李四',
      avatar: 'https://randomuser.me/api/portraits/women/2.jpg'
    },
    publishedAt: '2023-06-22',
    tags: ['React', '服务器组件', '性能优化']
  },
  { 
    id: '3', 
    title: 'TypeScript与Next.js',
    excerpt: '如何在Next.js项目中充分利用TypeScript',
    author: {
      name: '王五',
      avatar: 'https://randomuser.me/api/portraits/men/3.jpg'
    },
    publishedAt: '2023-07-10',
    tags: ['TypeScript', 'Next.js', '类型安全']
  }
];

// 模拟获取博客列表函数
async function getBlogs() {
  // 模拟网络延迟
  await new Promise(resolve =&gt; setTimeout(resolve, 500));
  return blogs;
}

export default async function BlogsPage() {
  // 获取博客数据
  const blogList = await getBlogs();
  
  return (
    &lt;div className="container mx-auto px-4 py-8"&gt;
      &lt;div className="flex justify-between items-center mb-8"&gt;
        &lt;h1 className="text-3xl font-bold"&gt;博客列表&lt;/h1&gt;
        &lt;Link 
          href="/blog/new" 
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition"
        &gt;
          创建新博客
        &lt;/Link&gt;
      &lt;/div&gt;
      
      &lt;div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3"&gt;
        {blogList.map(blog =&gt; (
          &lt;div key={blog.id} className="border rounded-lg overflow-hidden hover:shadow-md transition"&gt;
            &lt;div className="p-6"&gt;
              &lt;h2 className="text-xl font-bold mb-3"&gt;{blog.title}&lt;/h2&gt;
              &lt;p className="text-gray-600 mb-4"&gt;{blog.excerpt}&lt;/p&gt;
              
              &lt;div className="flex flex-wrap gap-2 mb-4"&gt;
                {blog.tags.map(tag =&gt; (
                  &lt;span 
                    key={tag} 
                    className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded"
                  &gt;
                    {tag}
                  &lt;/span&gt;
                ))}
              &lt;/div&gt;
              
              &lt;div className="flex items-center text-sm text-gray-500 mb-4"&gt;
                &lt;img 
                  src={blog.author.avatar} 
                  alt={blog.author.name}
                  className="w-6 h-6 rounded-full mr-2"
                /&gt;
                &lt;span&gt;{blog.author.name}&lt;/span&gt;
                &lt;span className="mx-2"&gt;•&lt;/span&gt;
                &lt;span&gt;{new Date(blog.publishedAt).toLocaleDateString('zh-CN')}&lt;/span&gt;
              &lt;/div&gt;
              
              &lt;div className="flex space-x-2"&gt;
                &lt;Link 
                  href={`/blog/${blog.id}`} 
                  className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
                &gt;
                  查看全文
                &lt;/Link&gt;
                &lt;Link 
                  href={`/blog/edit/${blog.id}`} 
                  className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm"
                &gt;
                  编辑
                &lt;/Link&gt;
                &lt;BlogActions blogId={blog.id} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {blogList.length === 0 &amp;&amp; (
        &lt;div className="text-center py-12"&gt;
          &lt;p className="text-gray-500 mb-4"&gt;暂无博客内容&lt;/p&gt;
          &lt;Link 
            href="/blog/new" 
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          &gt;
            创建第一篇博客
          &lt;/Link&gt;
        &lt;/div&gt;
      )}
      
      &lt;div className="mt-8 text-center"&gt;
        &lt;Link 
          href="/" 
          className="text-blue-600 hover:underline"
        &gt;
          返回首页
        &lt;/Link&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
} 
</code></pre>
<p>使用客户端组件进行交互：</p>
<pre><code class="language-tsx">// blog/components/BlogActions.tsx
'use client';

interface BlogActionsProps {
  blogId: string;
}

export default function BlogActions({ blogId }: BlogActionsProps) {
  const handleDelete = () =&gt; {
    alert(`删除功能尚未实现：${blogId}`);
    // 这里可以实现实际的删除逻辑
  };

  return (
    &lt;button 
      className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
      onClick={handleDelete}
    &gt;
      删除
    &lt;/button&gt;
  );
} 
</code></pre>
<h3 id="安装依赖">安装依赖</h3>
<p>使用 pnpm 安装项目依赖：</p>
<pre><code class="language-bash"># 安装依赖
pnpm add axios swr

# 安装开发依赖
pnpm add -D typescript @types/react eslint
</code></pre>
<h3 id="运行开发服务器">运行开发服务器</h3>
<pre><code class="language-bash">pnpm dev
</code></pre>
<h3 id="构建和部署">构建和部署</h3>
<pre><code class="language-bash"># 构建应用
pnpm build

# 启动生产环境服务器
pnpm start
</code></pre>
<h2 id="pnpm-优势">pnpm 优势</h2>
<p>pnpm相比npm和yarn有以下优势：</p>
<ol>
<li><strong>磁盘空间效率</strong>：pnpm使用硬链接和内容寻址存储，减少了重复的依赖</li>
<li><strong>安装速度快</strong>：比npm和yarn快2-3倍</li>
<li><strong>更严格的依赖管理</strong>：通过使用符号链接确保依赖访问更安全</li>
<li><strong>内置monorepo支持</strong>：无需额外工具即可管理多包项目</li>
</ol>
<h2 id="pnpm-常用命令">pnpm 常用命令</h2>
<pre><code class="language-bash"># 初始化项目
pnpm init

# 安装所有依赖
pnpm install

# 添加依赖
pnpm add [package]

# 添加开发依赖
pnpm add -D [package]

# 更新依赖
pnpm update

# 运行脚本
pnpm [script]

# 删除依赖
pnpm remove [package]
</code></pre>
<h2 id="nodejs-与-nextjs-的关系">Node.js 与 Next.js 的关系</h2>
<h3 id="nodejs-与-nextjs-的基本关系">Node.js 与 Next.js 的基本关系</h3>
<p>Next.js 是构建在 Node.js 之上的 React 框架。这种关系可以从多个方面理解：</p>
<ol>
<li><strong>运行时环境</strong>：Next.js 使用 Node.js 作为其服务器端运行时环境</li>
<li><strong>构建工具</strong>：Next.js 利用 Node.js 生态系统中的工具（如 webpack、babel）进行代码构建和转换</li>
<li><strong>包管理</strong>：Next.js 项目通过 npm、yarn 或 pnpm 等 Node.js 包管理器管理依赖</li>
<li><strong>API 实现</strong>：Next.js 的服务器端 API 路由基于 Node.js 的 HTTP 模块实现</li>
</ol>
<h3 id="nextjs-的运行时环境">Next.js 的运行时环境</h3>
<p>Next.js 确实在 Node.js 环境中启动了一个服务器来接收来自浏览器的请求。这个过程在不同模式下有所不同：</p>
<h4 id="开发环境">开发环境</h4>
<p>(<code>pnpm dev</code>)</p>
<p>在开发模式下：</p>
<ol>
<li>Next.js 启动一个 Node.js HTTP 服务器（默认监听 3000 端口）</li>
<li>该服务器具有热模块替换(HMR)功能，允许实时更新</li>
<li>当浏览器请求到达时，Next.js 服务器根据请求的路径：
<ul>
<li>对于页面请求：执行服务器端渲染(SSR)或提供静态生成(SSG)的内容</li>
<li>对于 API 请求：执行相应的 API 路由处理函数</li>
<li>对于静态资源：提供 public 目录中的文件</li>
</ul>
</li>
<li>开发服务器还处理源代码编译、打包和监视文件变化</li>
</ol>
<pre><code>浏览器请求 → Node.js服务器(Next.js) → 路由解析 → 页面渲染/API处理 → 响应返回
</code></pre>
<h4 id="生产环境">生产环境</h4>
<p>(<code>pnpm build</code> 然后 <code>pnpm start</code>)</p>
<p>在生产模式下：</p>
<ol>
<li>
<p><code>pnpm build</code> 预先构建所有可能的页面和资源</p>
<ul>
<li>静态生成(SSG)的页面被预渲染为HTML</li>
<li>服务器组件被优化和序列化</li>
<li>JavaScript包被优化和代码分割</li>
</ul>
</li>
<li>
<p><code>pnpm start</code> 启动一个优化的 Node.js 生产服务器</p>
<ul>
<li>这个服务器比开发服务器轻量得多</li>
<li>它主要负责：
<ul>
<li>提供预构建的静态资源</li>
<li>处理动态SSR请求</li>
<li>执行API路由</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>浏览器请求 → Node.js生产服务器 → 提供预构建资源/动态渲染 → 响应返回
</code></pre>
<h3 id="渲染模式与nodejs的关系">渲染模式与Node.js的关系</h3>
<ol>
<li>
<p><strong>服务器端渲染(SSR)</strong></p>
<ul>
<li>每次请求都在 Node.js 环境中执行React组件渲染</li>
<li>生成HTML并发送给浏览器</li>
<li>适用于需要最新数据的页面</li>
</ul>
</li>
<li>
<p><strong>静态站点生成(SSG)</strong></p>
<ul>
<li>在构建时在 Node.js 环境中预渲染HTML</li>
<li>请求来临时直接提供静态HTML</li>
<li>适用于内容不经常变化的页面</li>
</ul>
</li>
<li>
<p><strong>增量静态再生成(ISR)</strong></p>
<ul>
<li>结合SSG和SSR的优点</li>
<li>预渲染HTML，但在指定间隔后在Node.js环境中重新生成</li>
</ul>
</li>
<li>
<p><strong>客户端渲染</strong></p>
<ul>
<li>初始HTML由服务器提供</li>
<li>后续渲染和数据获取在浏览器中发生</li>
<li>减轻Node.js服务器负载</li>
</ul>
</li>
</ol>
<h3 id="nodejs-环境的限制">Node.js 环境的限制</h3>
<p>在使用Next.js时，需要注意Node.js环境的一些特点和限制：</p>
<ol>
<li>
<p><strong>服务器组件 vs 客户端组件</strong></p>
<ul>
<li>服务器组件在Node.js环境中运行，可以访问文件系统、环境变量等</li>
<li>客户端组件无法访问Node.js特有的功能和API</li>
</ul>
</li>
<li>
<p><strong>API路由的Node.js能力</strong></p>
<ul>
<li>API路由在Node.js环境中执行，可以使用完整的Node.js功能</li>
<li>包括数据库连接、文件系统操作、复杂计算等</li>
</ul>
</li>
<li>
<p><strong>边缘运行时</strong></p>
<ul>
<li>Next.js还支持Edge Runtime（一种轻量级运行时）</li>
<li>Edge Runtime比Node.js更受限，但部署和冷启动更快</li>
</ul>
</li>
</ol>
<h3 id="部署架构">部署架构</h3>
<p>Next.js应用的部署涉及到Node.js服务器的管理：</p>
<ol>
<li>
<p><strong>传统服务器</strong></p>
<ul>
<li>部署完整的Node.js服务器</li>
<li>例如在AWS EC2、DigitalOcean等上运行</li>
</ul>
</li>
<li>
<p><strong>无服务器函数</strong></p>
<ul>
<li>将Next.js应用部署为无服务器函数</li>
<li>例如AWS Lambda、Vercel等</li>
</ul>
</li>
<li>
<p><strong>静态导出</strong></p>
<ul>
<li>完全静态导出，不需要Node.js服务器</li>
<li>使用 <code>next export</code> 命令</li>
<li>适用于不需要SSR或API路由的项目</li>
</ul>
</li>
</ol>
<h2 id="本目录示例代码说明">本目录示例代码说明</h2>
<p>本目录包含以下示例文件：</p>
<ol>
<li>
<p><strong>page.tsx</strong>: 一个简单的 Next.js 首页示例，展示了：</p>
<ul>
<li>页面组件结构</li>
<li>使用 <code>next/head</code> 管理头部元素</li>
<li>使用 <code>next/link</code> 进行客户端导航</li>
<li>React hooks 在 Next.js 中的使用</li>
</ul>
</li>
<li>
<p><strong>[id].tsx</strong>: 展示动态路由的实现，包括：</p>
<ul>
<li>动态路由参数获取</li>
<li>静态生成 (generateStaticParams)</li>
<li>数据获取模式</li>
</ul>
</li>
<li>
<p><strong>route.ts</strong>: API 路由示例，展示了：</p>
<ul>
<li>基于请求方法的处理逻辑</li>
<li>响应处理</li>
<li>错误处理</li>
</ul>
</li>
</ol>
<p>注意：这些示例基于 App Router 模式实现。</p>
<h2 id="app-router-和-pages-router-的区别">App Router 和 Pages Router 的区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>App Router (app/)</th>
<th>Pages Router (pages/)</th>
</tr>
</thead>
<tbody>
<tr>
<td>组件模型</td>
<td>React Server Components</td>
<td>客户端组件</td>
</tr>
<tr>
<td>数据获取</td>
<td>组件中的 fetch 函数</td>
<td>getServerSideProps/getStaticProps</td>
</tr>
<tr>
<td>布局</td>
<td>layout.tsx</td>
<td>_app.tsx 和布局组件</td>
</tr>
<tr>
<td>嵌套布局</td>
<td>多个 layout.tsx</td>
<td>需手动实现</td>
</tr>
<tr>
<td>加载状态</td>
<td>loading.tsx</td>
<td>需手动实现</td>
</tr>
<tr>
<td>错误处理</td>
<td>error.tsx</td>
<td>需手动实现或使用 Error Boundaries</td>
</tr>
<tr>
<td>API 路由</td>
<td>route.ts 处理程序</td>
<td>pages/api/*.ts</td>
</tr>
</tbody>
</table>
<h2 id="进阶资源">进阶资源</h2>
<ul>
<li><a href="https://nextjs.org/docs" target="_blank" rel="noopener nofollow">Next.js 官方文档</a></li>
<li><a href="https://nextjs.org/docs/app" target="_blank" rel="noopener nofollow">Next.js App Router 文档</a></li>
<li><a href="https://nextjs.org/learn" target="_blank" rel="noopener nofollow">Next.js 学习课程</a></li>
<li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener nofollow">pnpm 官方文档</a></li>
<li><a href="https://vercel.com" target="_blank" rel="noopener nofollow">Vercel 平台</a>（Next.js 的创建者提供的托管服务）</li>
<li><a href="https://github.com/vercel/next.js" target="_blank" rel="noopener nofollow">Next.js GitHub 仓库</a></li>
</ul>
<h2 id="练习建议-1">练习建议</h2>
<ol>
<li>创建一个包含多个页面的 Next.js 应用（使用 App Router）</li>
<li>实现动态路由和数据获取</li>
<li>添加多级嵌套布局</li>
<li>创建 API 路由</li>
<li>实现错误处理和加载状态</li>
<li>将项目部署到 Vercel 或其他托管平台</li>
</ol>
<h1 id="容器知识入门教程">容器知识入门教程</h1>
<p>容器技术是现代应用开发和部署的基石，本教程将介绍 Docker 容器的基础知识。</p>
<h2 id="docker-背景介绍">Docker 背景介绍</h2>
<h3 id="什么是-docker">什么是 Docker</h3>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 或 Windows 操作系统的机器上。Docker 使用了 Linux 内核的多种功能（如 Namespaces、Cgroups）来创建独立的容器。</p>
<h3 id="docker-的发展历史">Docker 的发展历史</h3>
<ul>
<li><strong>2013年</strong>：Docker 由 dotCloud 公司（后更名为 Docker Inc.）推出，最初是 dotCloud 平台的内部项目</li>
<li><strong>2014年</strong>：Docker 1.0 发布，正式进入生产环境</li>
<li><strong>2015年</strong>：Docker Compose、Docker Swarm 和 Docker Machine 等工具发布，生态系统开始繁荣</li>
<li><strong>2016年</strong>：引入内置的编排功能</li>
<li><strong>2017年</strong>：集成 Kubernetes 支持</li>
<li><strong>至今</strong>：持续迭代发展，成为容器化技术的事实标准</li>
</ul>
<h3 id="为什么需要-docker">为什么需要 Docker</h3>
<p>在 Docker 出现之前，开发者面临以下问题：</p>
<ol>
<li><strong>环境不一致</strong>：开发、测试、生产环境的差异导致"在我电脑上能运行"的问题</li>
<li><strong>部署复杂</strong>：应用依赖安装复杂，配置繁琐</li>
<li><strong>资源利用率低</strong>：传统虚拟化方案资源占用高，启动慢</li>
<li><strong>应用隔离困难</strong>：不同应用之间相互影响</li>
<li><strong>扩展性差</strong>：难以快速扩容和缩容</li>
</ol>
<p>Docker 通过容器化技术解决了这些问题：</p>
<ol>
<li><strong>一致的环境</strong>：无论在哪里运行，容器内的环境都是一样的</li>
<li><strong>轻量级</strong>：容器共享主机系统内核，比传统虚拟机占用资源少，启动更快</li>
<li><strong>隔离</strong>：容器之间彼此隔离，不会相互影响</li>
<li><strong>可移植性</strong>：构建一次，到处运行</li>
<li><strong>微服务支持</strong>：适合现代微服务架构，每个服务独立容器化</li>
</ol>
<h3 id="docker-vs-虚拟机">Docker vs 虚拟机</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker 容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动时间</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>存储空间</td>
<td>MB级</td>
<td>GB级</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>有所损耗</td>
</tr>
<tr>
<td>系统资源</td>
<td>共享宿主机内核</td>
<td>独立内核</td>
</tr>
<tr>
<td>隔离性</td>
<td>进程级隔离</td>
<td>完全隔离</td>
</tr>
<tr>
<td>运行密度</td>
<td>单机可运行数十至数百个容器</td>
<td>单机通常运行数个虚拟机</td>
</tr>
</tbody>
</table>
<h2 id="1-docker-安装">1. Docker 安装</h2>
<h3 id="windows-安装-1">Windows 安装</h3>
<ol>
<li>下载 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener nofollow">Docker Desktop for Windows</a></li>
<li>双击安装程序并按照提示完成安装</li>
<li>安装完成后，Docker Desktop 会自动启动</li>
<li>在系统托盘中可以看到 Docker 图标，表示 Docker 服务正在运行</li>
</ol>
<h3 id="macos-安装-1">macOS 安装</h3>
<ol>
<li>下载 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener nofollow">Docker Desktop for Mac</a></li>
<li>将下载的 <code>.dmg</code> 文件拖到应用程序文件夹</li>
<li>启动 Docker Desktop 应用</li>
<li>等待 Docker 初始化完成，顶部状态栏会显示 Docker 图标</li>
</ol>
<h3 id="linux-安装-ubuntu">Linux 安装 (Ubuntu)</h3>
<pre><code class="language-bash"># 更新软件包索引
sudo apt-get update

# 安装依赖
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# 添加 Docker 官方 GPG 密钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# 设置稳定版仓库
echo \
  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# 安装 Docker Engine
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io

# 将当前用户添加到 docker 组（避免每次都使用 sudo）
sudo usermod -aG docker $USER
# 需要重新登录使配置生效
</code></pre>
<h3 id="验证安装">验证安装</h3>
<pre><code class="language-bash"># 查看 Docker 版本
docker --version

# 运行测试容器
docker run hello-world
</code></pre>
<h2 id="2-常用-docker-命令">2. 常用 Docker 命令</h2>
<h3 id="镜像相关命令">镜像相关命令</h3>
<pre><code class="language-bash"># 搜索镜像
docker search ubuntu

# 拉取镜像
docker pull ubuntu:latest

# 列出本地镜像
docker images

# 删除镜像
docker rmi ubuntu:latest

# 构建镜像
docker build -t myapp:1.0 .
</code></pre>
<h3 id="容器相关命令">容器相关命令</h3>
<pre><code class="language-bash"># 创建并启动容器
docker run -d -p 8080:80 --name mywebserver nginx

# 列出所有运行中的容器
docker ps

# 列出所有容器（包括已停止的）
docker ps -a

# 停止容器
docker stop mywebserver

# 启动已停止的容器
docker start mywebserver

# 重启容器
docker restart mywebserver

# 删除容器
docker rm mywebserver

# 进入容器交互式终端
docker exec -it mywebserver bash

# 查看容器日志
docker logs mywebserver

# 查看容器资源使用情况
docker stats mywebserver
</code></pre>
<h3 id="docker-compose-命令">Docker Compose 命令</h3>
<pre><code class="language-bash"># 启动所有服务
docker-compose up -d

# 停止所有服务
docker-compose down

# 查看服务状态
docker-compose ps

# 查看服务日志
docker-compose logs

# 重建服务
docker-compose build
</code></pre>
<h3 id="网络和存储命令">网络和存储命令</h3>
<pre><code class="language-bash"># 创建网络
docker network create mynetwork

# 列出网络
docker network ls

# 创建卷
docker volume create mydata

# 列出卷
docker volume ls
</code></pre>
<h2 id="示例项目说明">示例项目说明</h2>
<p>本目录包含一个简单的 Docker 示例项目，包括：</p>
<ol>
<li><strong>Dockerfile</strong>: 定义如何构建应用容器镜像</li>
<li><strong>docker-compose.yml</strong>: 定义多容器应用的服务、网络和卷</li>
<li><strong>app.js</strong>: 一个简单的 Node.js Express 应用</li>
<li><strong>package.json</strong>: Node.js 应用依赖定义</li>
</ol>
<h3 id="如何运行示例项目">如何运行示例项目</h3>
<ol>
<li>
<p>确保已安装 Docker 和 Docker Compose</p>
</li>
<li>
<p>在此目录下运行：</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p>访问应用：</p>
<ul>
<li>Web 应用: <a href="http://localhost:3000" target="_blank" rel="noopener nofollow">http://localhost:3000</a></li>
<li>健康检查: <a href="http://localhost:3000/health" target="_blank" rel="noopener nofollow">http://localhost:3000/health</a></li>
</ul>
</li>
</ol>
<h3 id="项目文件说明">项目文件说明</h3>
<h4 id="dockerfile">Dockerfile</h4>
<p>这个文件定义了如何构建应用容器：</p>
<ul>
<li>使用 Node.js 16 Alpine 作为基础镜像</li>
<li>设置工作目录</li>
<li>复制和安装依赖</li>
<li>配置环境变量</li>
<li>指定启动命令</li>
</ul>
<h4 id="docker-composeyml">docker-compose.yml</h4>
<p>这个文件定义了完整的应用栈：</p>
<ul>
<li>Web 应用服务 (使用 Dockerfile 构建)</li>
<li>PostgreSQL 数据库服务</li>
<li>Redis 缓存服务</li>
<li>网络配置</li>
<li>卷配置（持久存储）</li>
</ul>
<h4 id="appjs">app.js</h4>
<p>一个简单的 Express 服务器，展示容器环境信息和健康检查端点。</p>
<h2 id="docker-网络详解">Docker 网络详解</h2>
<p>Docker 网络是容器化环境中的关键组件，提供了容器间的通信基础设施。</p>
<h3 id="docker-网络的主要作用">Docker 网络的主要作用</h3>
<ol>
<li><strong>容器间通信</strong>：允许不同容器在不暴露端口到主机的情况下相互通信</li>
<li><strong>隔离环境</strong>：可以创建完全隔离的网络环境，提高应用安全性</li>
<li><strong>服务发现</strong>：容器可以通过容器名称而非IP地址相互访问，简化服务发现</li>
<li><strong>多主机连接</strong>：使用overlay网络可以连接不同主机上的容器</li>
<li><strong>网络策略控制</strong>：可以精细控制哪些容器可以相互通信</li>
</ol>
<h3 id="常用网络类型">常用网络类型</h3>
<pre><code class="language-bash"># 查看可用的网络驱动
docker info | grep "Network"

# 创建自定义网络
docker network create --driver bridge my-network

# 在创建容器时连接到指定网络
docker run --network=my-network -d --name container1 nginx

# 将已有容器连接到网络
docker network connect my-network container2
</code></pre>
<h4 id="网络驱动类型">网络驱动类型</h4>
<ul>
<li><strong>bridge</strong>: 默认网络驱动，适用于同一主机上的容器</li>
<li><strong>host</strong>: 直接使用主机网络，移除容器与主机间的网络隔离</li>
<li><strong>overlay</strong>: 用于Docker Swarm环境中，连接多个Docker守护进程</li>
<li><strong>macvlan</strong>: 允许容器拥有独立的MAC地址，直接连接到物理网络</li>
<li><strong>none</strong>: 禁用所有网络</li>
</ul>
<h2 id="docker-卷详解">Docker 卷详解</h2>
<p>Docker卷提供了容器数据的持久化存储解决方案，解决了容器销毁后数据丢失的问题。</p>
<h3 id="docker-卷的主要作用">Docker 卷的主要作用</h3>
<ol>
<li><strong>数据持久化</strong>：即使容器被删除，存储在卷中的数据依然保留</li>
<li><strong>数据共享</strong>：多个容器可以挂载相同的卷，实现数据共享</li>
<li><strong>备份与恢复</strong>：简化数据备份和恢复流程</li>
<li><strong>性能优化</strong>：与容器内部存储相比，卷通常提供更好的I/O性能</li>
<li><strong>存储解耦</strong>：将应用与数据分离，提高系统灵活性和可维护性</li>
</ol>
<h3 id="卷的使用方式">卷的使用方式</h3>
<pre><code class="language-bash"># 创建卷
docker volume create my-data

# 查看卷的详细信息
docker volume inspect my-data

# 在容器中使用卷
docker run -d --name my-container -v my-data:/app/data nginx

# 使用绑定挂载（挂载主机目录）
docker run -d --name my-container -v $(pwd):/app/data nginx

# 备份卷中的数据
docker run --rm -v my-data:/source -v $(pwd):/backup alpine tar -czvf /backup/my-data-backup.tar.gz -C /source .
</code></pre>
<h4 id="卷的类型">卷的类型</h4>
<ul>
<li><strong>命名卷</strong>: 由Docker管理的命名存储空间</li>
<li><strong>绑定挂载</strong>: 直接映射主机文件系统的路径到容器</li>
<li><strong>tmpfs挂载</strong>: 将数据存储在主机的内存中，不写入文件系统</li>
</ul>
<p>使用卷时要考虑权限、备份策略和数据生命周期管理，以确保数据安全和可靠性。</p>
<h2 id="docker-进阶概念">Docker 进阶概念</h2>
<ol>
<li><strong>Docker 多阶段构建</strong>：优化镜像大小和构建过程</li>
<li><strong>Docker 网络</strong>：bridge、host、overlay 等不同网络驱动</li>
<li><strong>Docker 卷</strong>：持久化数据存储</li>
<li><strong>Docker Swarm</strong>：Docker 原生集群和编排工具</li>
<li><strong>Docker 安全</strong>：最佳实践和安全配置</li>
<li><strong>Docker Registry</strong>：镜像仓库和分发</li>
</ol>
<h2 id="相关资源">相关资源</h2>
<ul>
<li><a href="https://docs.docker.com/" target="_blank" rel="noopener nofollow">Docker 官方文档</a></li>
<li><a href="https://hub.docker.com/" target="_blank" rel="noopener nofollow">Docker Hub</a></li>
<li><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener nofollow">Docker Compose 文档</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener nofollow">Dockerfile 最佳实践</a></li>
</ul>
<h2 id="练习建议-2">练习建议</h2>
<ol>
<li>尝试为不同语言的应用创建 Dockerfile</li>
<li>练习使用 Docker Compose 设置多容器应用</li>
<li>探索 Docker 卷和网络</li>
<li>学习如何在生产环境中安全地部署 Docker 容器</li>
</ol>
<h1 id="全栈博客案例">全栈博客案例</h1>
<h2 id="代码仓库">代码仓库</h2>
<p>go-learning：<a href="https://github.com/BaiZe1998/go-learning/tree/main/doutok-course/basic-knowledge" target="_blank" rel="noopener nofollow">https://github.com/BaiZe1998/go-learning/tree/main/doutok-course/basic-knowledge</a></p>

</div>
<div id="MySignature" role="contentinfo">
    如果有任何意见请在评论区积极留言
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.385752250162037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-27 23:56">2025-04-27 23:56</span>&nbsp;
<a href="https://www.cnblogs.com/YLTFY1998">白泽talk</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18850683);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18850683', targetLink: 'https://www.cnblogs.com/YLTFY1998/p/18850683', title: '2个小时1.5w字｜ React &amp;amp; Golang 全栈微服务实战' })">举报</a>
</div>
