
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kybs0/p/18636585" title="发布于 2024-12-27 19:27">
    <span role="heading" aria-level="2">.NET 结构体</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>我们都知道结构体struct，在大量创建、引用的场景下相比类class能提升很大性能。本文介绍下如何正确使用struct</p>
<h2>struct定义</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> Point
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> X;
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> Y;
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> 
<span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Rect
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Point Position;
</span><span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">11</span> 
<span style="color: rgba(0, 128, 128, 1)">12</span> Rect rect = <span style="color: rgba(0, 0, 255, 1)">new</span> Rect();</pre>
</div>
<p>上述代码中，rect的Position字段并没有分配到栈上，反而是和Rect的实例一起被分配到了托管堆中。除此之外，装箱也会导致结构体实例分配到托管堆：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> Point point = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Point();
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 255, 1)">object</span> obj = point; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 装箱，结构体转移到托管堆</span></pre>
</div>
<p>所以如果因为性能要求或者其它原因想限制struct只分配到栈上的话，可以添加ref：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">ref</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> Point
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> X;
</span><span style="color: rgba(0, 128, 128, 1)">4</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> Y;
</span><span style="color: rgba(0, 128, 128, 1)">5</span> }</pre>
</div>
<p>这种情况下，struct关键字前添加ref是指将结构体声明为只能在栈上分配的结构体，对于这种结构体，任何可能将其转移到托管堆的行为都将被阻止（例如在引用类型中定义ref结构体字段，或者进行装箱操作）：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Rect
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> Point Position; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 错误，Position会随着Rect实例转移到托管堆</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">5</span> 
<span style="color: rgba(0, 128, 128, 1)">6</span> Point point = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Point();
</span><span style="color: rgba(0, 128, 128, 1)">7</span> <span style="color: rgba(0, 0, 255, 1)">object</span> obj = point; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 错误，point会被装箱到托管堆</span></pre>
</div>
<p>另外，ref声明的struct可以继续作为字段在新struct内声明：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">ref</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> PointNew
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> Point Point; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 允许，因为XPoint同样保证了栈上分配</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> }</pre>
</div>
<p>还可以声明只读的ref结构体：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> <span style="color: rgba(0, 0, 255, 1)">ref</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> PointNew
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> Point Point; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 允许，因为XPoint同样保证了栈上分配</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> }</pre>
</div>
<h3>使用struct</h3>
<p>1. 结构体作为参数传递</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> Point p = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Point();
</span><span style="color: rgba(0, 128, 128, 1)">2</span> TestAdd(<span style="color: rgba(0, 0, 255, 1)">ref</span><span style="color: rgba(0, 0, 0, 1)"> p);
</span><span style="color: rgba(0, 128, 128, 1)">3</span> 
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 255, 1)">void</span> TestAdd(<span style="color: rgba(0, 0, 255, 1)">ref</span><span style="color: rgba(0, 0, 0, 1)"> Point point)
</span><span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">6</span>     point.X += <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">7</span> }</pre>
</div>
<p>如果不是只传值而是需要变更数据，需要添加ref，否则TestAdd中point只会作为原来p的副本生成一个新结构体。那最终p中的X值还是初始值0。ref我们都熟悉了，值类型如果作为参数输入后，外部同步修改也是使用ref</p>
<p>2. 结构体存储大小</p>
<p>看下面这段代码，输出结构体在栈上所需的内存大小：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 0, 1)">    [StructLayout(LayoutKind.Auto)]
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span>     <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> TestStorage
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span>         <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)"> A;
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span>         <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> B;
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span>         <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)"> C;
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>         <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)"> D;
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>         <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)"> E;
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">10</span>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出</span>
<span style="color: rgba(0, 128, 128, 1)">11</span>     <span style="color: rgba(0, 0, 255, 1)">unsafe</span>
<span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">13</span>         Debug.WriteLine(<span style="color: rgba(0, 0, 255, 1)">sizeof</span><span style="color: rgba(0, 0, 0, 1)">(TestStorage));
</span><span style="color: rgba(0, 128, 128, 1)">14</span>     }</pre>
</div>
<p>上面输出的值是12。我们聊下内存布局：</p>
<p>1）Sequential：顺序布局，按字段的声明顺序布局，是默认行为</p>
<p>2）Auto：自动布局，自动排列字段顺序以用最小的空间来储存字段</p>
<p>3）Explicit：显式布局，手动指定字段地址的偏移</p>
<p>一般来说，byte是1，int是4。</p>
<p>在不添加[StructLayout(LayoutKind.Auto)]标记时，由于需要内存对齐，字段B是4，那内存大小就需要以4+4+4=12来分配，前面4存储字段A 1的内存，后面4存储字段CDE一共3的内存大小</p>
<p>添加[StructLayout(LayoutKind.Auto)]后，内存对齐，只需要4+4=8的内存大小</p>
<p>&nbsp;</p>
<p>我们使用Struct场景主要有以下使用场景：</p>
<ul>
<li>一般是某类数据使用较多、有较大的内存问题 -&nbsp; 对于不需要频繁分配和释放的大量小对象，可以使用结构体减少堆内存的压力</li>
<li>现有类对象创建回收过于频繁，性能有较大损耗 - 可以使用结构体，减少对象创建、垃圾回收的开销</li>
</ul>
<p>结构体适合用于封装简单的数据，例如坐标点（Point）、复数（Complex Number）、时间段（TimeSpan）等</p>
<p>参考文章：</p>
<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct" rel="noopener nofollow">结构类型 - C# reference | Microsoft Learn</a><br>
<p><a href="https://blog.csdn.net/ProgramNovice/article/details/136900034" rel="noopener nofollow">Struct 和 Class 的区别以及使用场景_struct和class使用场景-CSDN博客</a></p>
</div>
<div id="MySignature" role="contentinfo">
    <div>作者：<a href="http://www.cnblogs.com/kybs0/" target="_blank">唐宋元明清2188</a></div>
<div>出处：<a href="http://www.cnblogs.com/kybs0/" target="_blank">http://www.cnblogs.com/kybs0/</a></div>
<div>让学习成为习惯，假设明天就有重大机遇等着你，你准备好了么</div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="6.696030775818287" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 19:36">2024-12-27 19:27</span>&nbsp;
<a href="https://www.cnblogs.com/kybs0">唐宋元明清2188</a>&nbsp;
阅读(<span id="post_view_count">69</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18636585" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18636585);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18636585', targetLink: 'https://www.cnblogs.com/kybs0/p/18636585', title: '.NET 结构体' })">举报</a>
</div>
        