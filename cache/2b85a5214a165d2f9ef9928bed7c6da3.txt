
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19063921" title="发布于 2025-08-29 09:40">
    <span role="heading" aria-level="2">【渲染管线】UnityURP中[渲染路径]选择‌</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250829095314919-888288675.png" alt="【渲染管线】UnityURP中[渲染路径]选择‌" class="desc_img">
        本文深入解析Unity URP渲染管线技术特点，重点对比了Build-in与URP的核心差异。URP基于SRP架构，支持在渲染流程中插入自定义Pass，提供Forward、Deferred、Forward+等多种渲染路径。文章详细拆解了URP的渲染阶段顺序（从BeforeRendering到AfterRendering共11个关键节点），并着重分析了延迟渲染路径的技术实现，包括GBuffer处理、光照计算流程和半透明物体前向渲染的特殊规则。通过Shader配置示例和调试方法，展示了URP延迟渲染路径下&amp;qu
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>URP基于SRP，相比于Build-in的渲染管线，进一步开放了渲染流水线中各个Pass的配置与可编程性。除了内置的Forward前向渲染路径、Deferred延迟渲染路径、Forward+前向加渲染路径，这几种渲染路径中特定需要的渲染Pass以外，可以在渲染管线<em><strong>各个阶段</strong></em>插入自定义Pass来完成自定义操作。Build-in不具备修改管线中的各个阶段插入自定义Pass的能力。</p>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="渲染的各个阶段的事件">渲染的各个阶段的事件</h1>
<ul>
<li>
<p>这里列出渲染的各个阶段的事件枚举<code>RenderPassEvent</code>（com.unity.render-pipelines.universal@14.0.12/Runtime/Passes/ScriptableRenderPass.cs），依此也可快速看出渲染的流程顺序：</p>
<blockquote>
<p>BeforeRendering（开始渲染前） → RenderingShadows（阴影渲染） →<br>
RenderingPrePasses（预渲染） → RenderingGbuffer（G-buffer） →<br>
RenderingDeferredLights（延迟着色） → RenderingOpaques（渲染不透明） →<br>
RenderingSkybox（渲染天空盒） → RenderingTransparents（渲染透明） →<br>
RenderingPostProcessing（后处理） → AfterRendering（渲染结束后）</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>数值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeforeRendering</td>
<td>0</td>
<td>在渲染管线中其他所有通道之前执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。可用于绘制后期管线中使用的自定义输入纹理，如LUT纹理。</td>
</tr>
<tr>
<td>BeforeRenderingShadows</td>
<td>50</td>
<td>在渲染阴影贴图之前执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。</td>
</tr>
<tr>
<td>AfterRenderingShadows</td>
<td>100</td>
<td>在渲染阴影贴图之后执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。</td>
</tr>
<tr>
<td>BeforeRenderingPrePasses</td>
<td>150</td>
<td>在渲染预通道(如深度预通道)之前执行ScriptableRenderPass。此时相机矩阵和立体渲染已经设置完成。</td>
</tr>
<tr>
<td>AfterRenderingPrePasses</td>
<td>200</td>
<td>在渲染预通道(如深度预通道)之后执行ScriptableRenderPass。此时相机矩阵和立体渲染已经设置完成。</td>
</tr>
<tr>
<td>BeforeRenderingGbuffer</td>
<td>210</td>
<td>在渲染G-buffer通道之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingGbuffer</td>
<td>220</td>
<td>在渲染G-buffer通道之后执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>BeforeRenderingDeferredLights</td>
<td>230</td>
<td>在渲染延迟着色通道之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingDeferredLights</td>
<td>240</td>
<td>在渲染延迟着色通道之后执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>BeforeRenderingOpaques</td>
<td>250</td>
<td>在渲染不透明物体之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingOpaques</td>
<td>300</td>
<td>在渲染不透明物体之后执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>BeforeRenderingSkybox</td>
<td>350</td>
<td>在渲染天空盒之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingSkybox</td>
<td>400</td>
<td>在渲染天空盒之后执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>BeforeRenderingTransparents</td>
<td>450</td>
<td>在渲染透明物体之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingTransparents</td>
<td>500</td>
<td>在渲染透明物体之后执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>BeforeRenderingPostProcessing</td>
<td>550</td>
<td>在渲染后处理效果之前执行ScriptableRenderPass。</td>
</tr>
<tr>
<td>AfterRenderingPostProcessing</td>
<td>600</td>
<td>在渲染后处理效果之后执行ScriptableRenderPass，但在最终blit、后处理AA效果和色彩分级之前。</td>
</tr>
<tr>
<td>AfterRendering</td>
<td>1000</td>
<td>在所有效果渲染完成后执行ScriptableRenderPass。</td>
</tr>
</tbody>
</table>
<h1 id="前向渲染">‌<strong>前向渲染</strong>‌</h1>
<ul>
<li>逐物体处理光照，适合移动端和简单光照场景。</li>
</ul>
<h1 id="延迟渲染">‌<strong>延迟渲染</strong>‌</h1>
<ul>
<li>分离几何与光照计算，在屏幕空间执行光照，支持大量动态光源，但需更高显存开销 ‌。配置方式：URP Asset 中设置渲染路径。</li>
<li><strong>延迟渲染路径下GBufferPass阶段后，管线内部会固定处理LightingPass阶段，计算光照输出到缓冲区的</strong></li>
</ul>
<h2 id="一光照计算流程"><strong>一、光照计算流程‌</strong></h2>
<h3 id="输入数据来源">‌<strong>输入数据来源</strong>‌</h3>
<ul>
<li>读取GBuffer纹理（RT0-RT3）中的材质属性（漫反射、法线、高光等）</li>
<li>深度缓冲区用于可见性判断和光源裁剪</li>
</ul>
<h3 id="计算方式">‌<strong>计算方式</strong>‌</h3>
<ul>
<li>全屏四边形或光源几何体逐像素处理</li>
<li>定向光全局计算，点/聚光灯通过模板测试局部渲染</li>
</ul>
<h3 id="输出目标">‌<strong>输出目标</strong>‌</h3>
<ul>
<li>直接写入帧缓冲区（Frame Buffer）形成最终颜色</li>
</ul>
<hr>
<h2 id="二关键实现文件"><strong>‌二、关键实现文件‌</strong></h2>
<h3 id="核心着色器">‌<strong>核心着色器</strong>‌</h3>
<ul>
<li><code>Internal-DeferredShading.shader</code>：内置延迟光照计算逻辑‌</li>
<li>包含光源类型分支（定向光、点光源、聚光灯）和阴影处理</li>
</ul>
<h3 id="hlsl工具库">‌<strong>HLSL工具库</strong>‌</h3>
<ul>
<li><code>UnityDeferredLibrary.hlsl</code>：提供光照模型函数（如Blinn-Phong/PBR）‌</li>
<li><code>UnityGBuffer.hlsl</code>：定义GBuffer数据编码/解码方法‌</li>
</ul>
<h3 id="c管线控制">‌<strong>C#管线控制</strong>‌</h3>
<ul>
<li><code>DeferredLights.cs</code>：管理GBuffer创建与光照Pass调度‌</li>
</ul>
<hr>
<h2 id="三技术特性"><strong>‌三、技术特性‌</strong></h2>
<h3 id="性能优化">‌<strong>性能优化</strong>‌</h3>
<ul>
<li>通过光源体积剔除和模板测试减少无效计算</li>
</ul>
<h3 id="扩展性">‌<strong>扩展性</strong>‌</h3>
<ul>
<li>可通过替换<code>Internal-DeferredShading.shader</code>自定义光照模型‌</li>
<li>延迟渲染路径下，透明序列的物体使用LightMode为UniversalForward的pass来渲染半透明物体</li>
<li>在Unity URP延迟渲染路径下，‌<strong>设置<code>LightMode="UniversalForward"</code>的Pass会被执行</strong>‌，但仅针对特定类型的物体。以下是具体规则：</li>
</ul>
<h2 id="一延迟渲染路径下的前向pass执行规则"><strong>‌一、延迟渲染路径下的前向Pass执行规则‌</strong></h2>
<h3 id="半透明物体强制前向渲染">‌<strong>半透明物体强制前向渲染</strong>‌</h3>
<ul>
<li>所有标记为<code>"Queue"="Transparent"</code>的物体，即使管线使用延迟渲染路径，其<code>LightMode="UniversalForward"</code>的Pass仍会被执行</li>
<li>原因：延迟渲染无法处理透明度混合，需退回前向路径</li>
</ul>
<h3 id="不透明物体的例外">‌<strong>不透明物体的例外</strong>‌</h3>
<ul>
<li>不透明物体（<code>"Queue"="Geometry"</code>）的<code>UniversalForward</code>&nbsp;Pass在延迟路径下‌<strong>不会执行</strong>‌</li>
<li>此类物体统一由GBuffer Pass（<code>LightMode="UniversalGBuffer"</code>）处理</li>
</ul>
<hr>
<h2 id="二技术实现原理"><strong>‌二、技术实现原理‌</strong></h2>
<table>
<thead>
<tr>
<th>‌<strong>管线阶段</strong>‌</th>
<th>‌<strong>执行内容</strong>‌</th>
<th>‌<strong>相关Pass的LightMode</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>不透明物体阶段</strong>‌</td>
<td>写入GBuffer（颜色、法线、材质属性等）</td>
<td><code>UniversalGBuffer</code></td>
</tr>
<tr>
<td>‌<strong>光照计算阶段</strong>‌</td>
<td>基于GBuffer进行屏幕空间光照叠加</td>
<td>内置管线Pass（无LightMode标签）</td>
</tr>
<tr>
<td>‌<strong>半透明物体阶段</strong>‌</td>
<td>按前向渲染方式逐物体计算光照，混合到帧缓冲区</td>
<td><code>UniversalForward</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>光照计算由URP内置着色器<s>Internal-DeferredShading.shader</s>完成，不依赖材质Shader中的Pass</p>
</blockquote>
<hr>
<h2 id="三验证与实践要点"><strong>‌三、验证与实践要点‌</strong></h2>
<h3 id="shader配置示例">‌<strong>Shader配置示例</strong>‌</h3>
<ul>
<li>半透明物体必须显式声明前向标签：</li>
</ul>
<pre><code class="language-c">SubShader {
    Tags { "Queue" = "Transparent" }
    Pass {
        Tags { "LightMode" = "UniversalForward" } // 延迟路径下仍会执行
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        ...
    }
} 
</code></pre>
<h3 id="调试方法">‌<strong>调试方法</strong>‌</h3>
<ul>
<li>使用‌<strong>Frame Debugger</strong>‌工具可观察到：
<ul>
<li>不透明物体仅显示<code>Render Opaques</code>和<code>GBuffer</code>相关条目</li>
<li>半透明物体显示<code>Render Transparents</code>条目并执行<code>UniversalForward</code>&nbsp;Pass</li>
</ul>
</li>
</ul>
<hr>
<h2 id="四底层机制说明"><strong>‌四、底层机制说明‌</strong></h2>
<ul>
<li>
<p>URP延迟路径本质上是‌<strong>混合渲染方案</strong>‌：</p>
</li>
<li>
<p>不透明物体 → ‌<strong>延迟渲染</strong>‌（GBuffer + 屏幕空间光照）</p>
</li>
<li>
<p>半透明/特殊效果物体 → ‌<strong>前向渲染</strong>‌（逐物体光照计算）这种设计兼顾了不透明物体的光照性能与特殊材质的灵活性</p>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.009027777777777777" data-date-updated="2025-08-29 09:53">2025-08-29 09:40</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19063921);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19063921', targetLink: 'https://www.cnblogs.com/SmalBox/p/19063921', title: '【渲染管线】UnityURP中[渲染路径]选择‌' })">举报</a>
</div>
        