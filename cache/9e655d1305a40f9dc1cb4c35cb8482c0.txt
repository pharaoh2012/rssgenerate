
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18973662" title="发布于 2025-07-08 19:22">
    <span role="heading" aria-level="2">【工厂和策略设计模式妙用】解决接口选择与多重if-else 问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="利用工厂和策略模式解决接口选择与多重if-else问题">利用工厂和策略模式解决接口选择与多重if-else问题</h1>
<p>在软件开发中，我们经常会遇到需要根据不同的条件选择不同实现的情况。传统的if-else或switch-case方式虽然直观，但随着业务逻辑复杂度的增加，会导致代码难以维护和扩展。工厂模式和策略模式的组合可以优雅地解决这个问题。</p>
<h2 id="问题场景">问题场景</h2>
<p>假设我们有一个支付系统，需要根据不同的支付方式（支付宝、微信、银行卡等）调用不同的支付接口。传统实现可能是：</p>
<pre><code class="language-java">public void pay(String paymentType, BigDecimal amount) {
    if ("alipay".equals(paymentType)) {
        // 调用支付宝支付逻辑
    } else if ("wechat".equals(paymentType)) {
        // 调用微信支付逻辑
    } else if ("bank".equals(paymentType)) {
        // 调用银行卡支付逻辑
    }
    // 更多支付方式...
}
</code></pre>
<p>这种实现方式存在以下问题：</p>
<ol>
<li>违反开闭原则 - 新增支付方式需要修改原有代码</li>
<li>代码臃肿 - 随着支付方式增加，方法会越来越长</li>
<li>难以维护 - 所有逻辑集中在一个方法中</li>
</ol>
<h2 id="解决方案工厂--策略模式">解决方案：工厂 + 策略模式</h2>
<h3 id="1-定义策略接口">1. 定义策略接口</h3>
<pre><code class="language-java">public interface PaymentStrategy {
    void pay(BigDecimal amount);
}
</code></pre>
<h3 id="2-实现具体策略类">2. 实现具体策略类</h3>
<pre><code class="language-java">public class AlipayStrategy implements PaymentStrategy {
    @Override
    public void pay(BigDecimal amount) {
        // 支付宝支付具体实现
        System.out.println("使用支付宝支付：" + amount);
    }
}

public class WechatPayStrategy implements PaymentStrategy {
    @Override
    public void pay(BigDecimal amount) {
        // 微信支付具体实现
        System.out.println("使用微信支付：" + amount);
    }
}

public class BankCardStrategy implements PaymentStrategy {
    @Override
    public void pay(BigDecimal amount) {
        // 银行卡支付具体实现
        System.out.println("使用银行卡支付：" + amount);
    }
}
</code></pre>
<h3 id="3-创建策略工厂">3. 创建策略工厂</h3>
<pre><code class="language-java">public class PaymentStrategyFactory {
    private static final Map&lt;String, PaymentStrategy&gt; strategies = new HashMap&lt;&gt;();
    
    static {
        strategies.put("alipay", new AlipayStrategy());
        strategies.put("wechat", new WechatPayStrategy());
        strategies.put("bank", new BankCardStrategy());
    }
    
    public static PaymentStrategy getStrategy(String paymentType) {
        if (paymentType == null || paymentType.isEmpty()) {
            throw new IllegalArgumentException("支付类型不能为空");
        }
        PaymentStrategy strategy = strategies.get(paymentType);
        if (strategy == null) {
            throw new IllegalArgumentException("不支持的支付类型: " + paymentType);
        }
        return strategy;
    }
}
</code></pre>
<h3 id="4-使用策略模式">4. 使用策略模式</h3>
<pre><code class="language-java">public class PaymentService {
    public void pay(String paymentType, BigDecimal amount) {
        PaymentStrategy strategy = PaymentStrategyFactory.getStrategy(paymentType);
        strategy.pay(amount);
    }
}
</code></pre>
<h2 id="优势分析">优势分析</h2>
<ol>
<li><strong>符合开闭原则</strong>：新增支付方式只需添加新的策略类并在工厂中注册，无需修改现有代码</li>
<li><strong>代码清晰</strong>：每个支付方式的逻辑封装在各自的类中</li>
<li><strong>易于维护</strong>：支付逻辑分散到各个策略类，降低复杂度</li>
<li><strong>可扩展性强</strong>：可以轻松添加新的支付方式</li>
<li><strong>便于测试</strong>：每个策略类可以单独测试</li>
</ol>
<h2 id="进阶优化">进阶优化</h2>
<h3 id="使用spring框架的依赖注入">使用Spring框架的依赖注入</h3>
<p>如果使用Spring框架，可以进一步优化：</p>
<pre><code class="language-java">@Service
public class PaymentStrategyFactory {
    @Autowired
    private Map&lt;String, PaymentStrategy&gt; strategies;
    
    public PaymentStrategy getStrategy(String paymentType) {
        PaymentStrategy strategy = strategies.get(paymentType);
        if (strategy == null) {
            throw new IllegalArgumentException("不支持的支付类型: " + paymentType);
        }
        return strategy;
    }
}

// 策略实现类添加@Component注解
@Component("alipay")
public class AlipayStrategy implements PaymentStrategy {
    // 实现
}

@Component("wechat")
public class WechatPayStrategy implements PaymentStrategy {
    // 实现
}
</code></pre>
<h3 id="结合枚举类型">结合枚举类型</h3>
<pre><code class="language-java">public enum PaymentType {
    ALIPAY("alipay", "支付宝支付"),
    WECHAT("wechat", "微信支付"),
    BANK("bank", "银行卡支付");
    
    private String code;
    private String desc;
    
    // 构造方法、getter等
}
</code></pre>
<p>然后在工厂中使用枚举值作为key，提高类型安全性。</p>
<h2 id="总结">总结</h2>
<p>工厂模式和策略模式的组合是解决条件分支过多问题的经典方案。它将选择逻辑与业务逻辑分离，使系统更加灵活、可扩展。在实际开发中，可以根据项目具体情况选择适合的实现方式，结合框架特性进一步优化。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-08 19:22">2025-07-08 19:22</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18973662);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18973662', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18973662', title: '【工厂和策略设计模式妙用】解决接口选择与多重if-else 问题' })">举报</a>
</div>
        