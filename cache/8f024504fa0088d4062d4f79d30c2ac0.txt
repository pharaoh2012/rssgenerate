
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18908447" title="发布于 2025-06-03 14:17">
    <span role="heading" aria-level="2">高并发下如何防止商品超卖？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>"快看我们的秒杀系统！库存显示-500了！"</p>
<p>3年前的这个电话让我记忆犹新。</p>
<p>当时某电商大促，我们自认为完美的分布式架构，在0点整瞬间被击穿。</p>
<p>数据库连接池耗尽，库存表出现负数，客服电话被打爆...</p>
<p>今天这篇文章跟大家一起聊聊商品超卖的问题，希望对你会有所帮助。</p>
<h2 id="1-为什么会发生超卖">1 为什么会发生超卖？</h2>
<p>首先我们一起看看为什么会发送超卖？</p>
<h3 id="11-数据库的最后防线漏洞">1.1 数据库的"最后防线"漏洞</h3>
<p>我们用下面的列子，给大家介绍一下商品超卖是如何发生的。</p>
<pre><code class="language-java">public boolean buy(int goodsId) {
    // 1. 查询库存
    int stock = getStockFromDatabase(goodsId);
    if (stock &gt; 0) {
        // 2. 扣减库存
        updateStock(goodsId, stock - 1);
        return true;
    }
    return false;
}
</code></pre>
<p>在并发场景下可能变成下图这样的：</p>
<p><img src="https://files.mdnice.com/user/5303/f2852491-a472-4fc7-a036-128160583d28.png" alt="" loading="lazy"></p>
<p>请求1和请求2都将库存更新成9。</p>
<p><strong>根本原因</strong>：数据库的查询和更新操作，不是原子性校验，多个事务可能同时通过stock&gt;0的条件检查。</p>
<h3 id="12-超卖的本质">1.2 超卖的本质</h3>
<p><strong>商品超卖的本质是</strong>：多个请求同时穿透缓存，同一时刻读取到相同库存值，最终在数据库层发生覆盖。</p>
<p>就像100个人同时看上一件衣服，都去试衣间前看了眼牌子，出来时都觉得自己应该拿到那件衣服。</p>
<h2 id="2-防止超卖的方案">2 防止超卖的方案</h2>
<h3 id="21-数据库乐观锁">2.1 数据库乐观锁</h3>
<p>数据库乐观锁的核心原理是通过版本号控制并发。</p>
<p>例如下面这样的：</p>
<pre><code class="language-sql">UPDATE product 
SET stock = stock -1, version=version+1 
WHERE id=123 AND version=#{currentVersion};
</code></pre>
<p>Java的实现代码如下：</p>
<pre><code class="language-java">@Transactional
public boolean deductStock(Long productId) {
    Product product = productDao.selectForUpdate(productId);
    if (product.getStock() &lt;= 0) return false;
    
    int affected = productDao.updateWithVersion(
        productId, 
        product.getVersion(),
        product.getStock()-1
    );
    return affected &gt; 0;
}
</code></pre>
<p>基于数据库乐观锁方案的架构图如下：</p>
<p><img src="https://files.mdnice.com/user/5303/0b9ea248-6949-441a-b1e4-a29482b392b1.png" alt="" loading="lazy"></p>
<p><strong>优缺点分析</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align: center"><strong>优点</strong></th>
<th style="text-align: center"><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">无需额外中间件</td>
<td style="text-align: center">高并发时DB压力大</td>
</tr>
<tr>
<td style="text-align: center">实现简单</td>
<td style="text-align: center">可能出现大量更新失败</td>
</tr>
</tbody>
</table>
<p><strong>适用场景</strong>：日订单量1万以下的中小系统。</p>
<h3 id="22-redis原子操作">2.2 Redis原子操作</h3>
<p>Redis原子操作的核心原理是使用：Redis + Lua脚本。</p>
<p>核心代码如下：</p>
<pre><code class="language-java">// Lua脚本保证原子性
String lua = "if redis.call('get', KEYS &gt;= ARGV[1] then " +
             "return redis.call('decrby', KEYS[1], ARGV " +
             "else return -1 end";

public boolean preDeduct(String itemId, int count) {
    RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(lua, Long.class);
    Long result = redisTemplate.execute(script, 
        Collections.singletonList(itemId), count);
    return result != null &amp;&amp; result &gt;= 0;
}
</code></pre>
<p>该方案的架构图如下：</p>
<p><img src="https://files.mdnice.com/user/5303/f66162f1-674a-454b-9303-9ad60e5898ac.png" alt="" loading="lazy"></p>
<p><strong>性能对比</strong>：</p>
<ul>
<li>单节点QPS：数据库方案500 vs Redis方案8万</li>
<li>响应时间：&lt;1ms vs 50ms+</li>
</ul>
<h3 id="23-分布式锁">2.3 分布式锁</h3>
<p>目前最常用的分布式锁的方案是Redisson。</p>
<p>下面是Redisson的实现：</p>
<pre><code class="language-java">RLock lock = redisson.getLock("stock_lock:"+productId);
try {
    if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {
        // 执行库存操作
    }
} finally {
    lock.unlock();
}
</code></pre>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>1.锁粒度要细化到商品级别</li>
<li>2.必须设置等待时间和自动释放</li>
<li>3.配合异步队列使用效果更佳</li>
</ol>
<p>该方案的架构图如下：</p>
<p><img src="https://files.mdnice.com/user/5303/1f137288-3e7f-400a-b8ce-4da506950f46.png" alt="" loading="lazy"></p>
<h3 id="24-消息队列削峰">2.4 消息队列削峰</h3>
<p>可以使用 RocketMQ的事务消息。</p>
<p>核心代码如下：</p>
<pre><code class="language-java">// RocketMQ事务消息示例
TransactionMQProducer producer = new TransactionMQProducer("stock_group");
producer.setExecutor(new TransactionListener() {
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg) {
        // 扣减数据库库存
        return LocalTransactionState.COMMIT_MESSAGE;
    }
});
</code></pre>
<p>该方案的架构图如下：</p>
<p><img src="https://files.mdnice.com/user/5303/1fa85ecb-d6d6-48fa-b925-d59bb0ac2835.png" alt="" loading="lazy"></p>
<p><strong>技术指标</strong>：</p>
<ul>
<li>削峰能力：10万QPS → 2万TPS</li>
<li>订单处理延迟：&lt;1秒（正常时段）</li>
</ul>
<h3 id="25-预扣库存">2.5 预扣库存</h3>
<p>预扣库存是防止商品超卖的终极方案。</p>
<p>核心算法如下：</p>
<pre><code class="language-java">// Guava RateLimiter限流
RateLimiter limiter = RateLimiter.create(1000); // 每秒1000个令牌

public boolean preDeduct(Long itemId) {
    if (!limiter.tryAcquire()) return false;
    
    // 写入预扣库存表
    preStockDao.insert(itemId, userId);
    return true;
}
</code></pre>
<p>该方案的架构图如下：</p>
<p><img src="https://files.mdnice.com/user/5303/6721e67f-c8c1-4e2d-8f63-aed3c300da3d.png" alt="" loading="lazy"></p>
<p><strong>性能数据</strong>：</p>
<ul>
<li>百万级并发支撑能力</li>
<li>库存准确率99.999%</li>
<li>订单处理耗时200ms内</li>
</ul>
<h2 id="3-避坑指南">3 避坑指南</h2>
<h3 id="31-缓存与数据库不一致">3.1 缓存与数据库不一致</h3>
<p>某次大促因缓存未及时失效，导致超卖1.2万单。</p>
<p>错误示例如下：</p>
<pre><code class="language-java">// 错误示例：先删缓存再写库
redisTemplate.delete("stock:"+productId);
productDao.updateStock(productId, newStock); // 存在并发写入窗口
</code></pre>
<h3 id="32-未考虑库存回滚">3.2 未考虑库存回滚</h3>
<p>秒杀取消后，忘记恢复库存，引发后续超卖。</p>
<p>正确做法是使用事务补偿。</p>
<p>例如下面这样的：</p>
<pre><code class="language-java">@Transactional
public void cancelOrder(Order order) {
    stockDao.restock(order.getItemId(), order.getCount());
    orderDao.delete(order.getId());
}
</code></pre>
<p>库存回滚和订单删除，在同一个事务中。</p>
<h3 id="33-锁粒度过大">3.3 锁粒度过大</h3>
<p>锁粒度过大，全局限流导致10%的请求被误杀。</p>
<p>错误示例如下：</p>
<pre><code class="language-java">// 错误示例：全局限锁
RLock globalLock = redisson.getLock("global_stock_lock");
</code></pre>
<h2 id="总结">总结</h2>
<p>其实在很多大厂中，一般会将防止商品超卖的多种方案组合使用。</p>
<p>架构图如下：<br>
<img src="https://files.mdnice.com/user/5303/5c2b9b56-a62e-472b-87ec-99190f26f47d.png" alt="" loading="lazy"></p>
<p>通过组合使用：</p>
<ol>
<li>Redis做第一道防线（承受80%流量）</li>
<li>分布式锁控制核心业务逻辑</li>
<li>预扣库存+消息队列保证最终一致性</li>
</ol>
<p><strong>实战经验</strong>：某电商在2023年双11中：</p>
<ul>
<li>Redis集群承载98%请求</li>
<li>分布式锁拦截异常流量</li>
<li>预扣库存保证最终准确性</li>
</ul>
<p>系统平稳支撑了每秒12万次秒杀请求，0超卖事故发生！</p>
<p><strong>记住：没有银弹方案，只有适合场景的组合拳！</strong></p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，我的所有文章都会在公众号上首发，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1674319705775463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-03 14:17">2025-06-03 14:17</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">256</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18908447);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18908447', targetLink: 'https://www.cnblogs.com/12lisu/p/18908447', title: '高并发下如何防止商品超卖？' })">举报</a>
</div>
        