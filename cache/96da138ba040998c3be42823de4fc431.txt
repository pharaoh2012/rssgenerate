
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18788852" title="发布于 2025-03-24 10:03">
    <span role="heading" aria-level="2">接口重试的7种常用方案！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>记得五年前的一个深夜，某个电商平台的订单退款接口突发异常，因为银行系统网络抖动，退款请求连续失败。</p>
<p>原本技术团队只是想“好心重试几次”，结果开发小哥写的重试代码竟疯狂调用了银行的退款接口 <strong>82次</strong>！</p>
<p>最终导致用户账户重复退款，平台损失过百万。</p>
<p><strong>老板在复盘会上质问：“接口重试这么基础的事，为什么还能捅出大篓子？”</strong></p>
<p>大家哑口无言，因为所有人都以为只要加个 <code>for</code> 循环，再睡几秒就完事了……</p>
<p>这篇文章跟大家一起聊聊重试的7种常用方案，希望对你会有所帮助。</p>
<h2 id="1-暴力轮回法">1 暴力轮回法</h2>
<h3 id="问题场景">问题场景</h3>
<p>某实习生写的用户注册短信发送接口。</p>
<p>在一个while循环中，重复调用第三方的发短信接口给用户发送短信。</p>
<p>代码如下：</p>
<pre><code class="language-java">public void sendSms(String phone) {
    int retry = 0;
    while (retry &lt; 5) { // 无脑循环
        try {
            smsClient.send(phone);
            break;
        } catch (Exception e) {
            retry++;
            Thread.sleep(1000); // 固定1秒睡眠
        }
    }
}
</code></pre>
<h3 id="事故现场">事故现场</h3>
<p>某次短信服务器出现了过载问题，导致所有请求都延迟了3秒。</p>
<p>这个暴力循环的代码在 <strong>0.5秒内同时发起数万次重试</strong>，直接打爆短信平台，触发了 <strong>熔断封禁</strong>，连正常请求也被拒绝。</p>
<h3 id="教训">教训</h3>
<ul>
<li>💥 <strong>不做延迟间隔调整</strong>：固定间隔导致重试请求集中爆发</li>
<li>💥 <strong>无视异常类型</strong>：非临时性错误（如参数错误）也尝试重试</li>
<li>🔑 <strong>修复方案</strong>：加上随机的重试间隔，并过滤不可重试的异常</li>
</ul>
<h2 id="2-spring-retry">2 Spring Retry</h2>
<h3 id="应用场景">应用场景</h3>
<p>Spring Retry适用于中小项目，通过注解快速实现基本重试和熔断（如订单状态查询接口）。</p>
<p>通过声明@Retryable注解，来实现接口重试的功能。</p>
<h3 id="配置示例">配置示例</h3>
<pre><code class="language-java">@Retryable(
    value = {TimeoutException.class}, // 只重试超时异常
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2) // 1秒→2秒→4秒
)
public boolean queryOrderStatus(String orderId) {
    return httpClient.get("/order/" + orderId);
}

@Recover // 兜底回退方法
public boolean fallback() {
    return false; 
}
</code></pre>
<h3 id="优势">优势</h3>
<ul>
<li><strong>声明式注解</strong>：代码简洁，与业务逻辑解耦</li>
<li><strong>指数退避</strong>：自动拉长重试间隔</li>
<li><strong>熔断集成</strong>：结合 <code>@CircuitBreaker</code> 可快速阻断异常流量</li>
</ul>
<h2 id="3-resilience4j">3 Resilience4j</h2>
<h3 id="高阶场景">高阶场景</h3>
<p>对于有些需要自定义退避算法、熔断策略和多层防护的大中型系统（如支付核心接口），我们可以使用 Resilience4j。</p>
<p>核心代码如下：</p>
<pre><code class="language-java">// 1. 重试配置：指数退避 + 随机抖动
RetryConfig retryConfig = RetryConfig.custom()
    .maxAttempts(3)
    .intervalFunction(IntervalFunction.ofExponentialRandomBackoff(
        1000L, // 初始间隔1秒
        2.0,   // 指数倍数
        0.3    // 随机抖动系数
    ))
    .retryOnException(e -&gt; e instanceof TimeoutException)
    .build();

// 2. 熔断配置：错误率超50%时熔断
CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
    .slidingWindow(10, 10, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED) 
    .failureRateThreshold(50)
    .build();

// 组合使用
Retry retry = Retry.of("payment", retryConfig);
CircuitBreaker cb = CircuitBreaker.of("payment", cbConfig);

// 执行业务逻辑
Supplier&lt;Boolean&gt; supplier = () -&gt; paymentService.pay();
Supplier&lt;Boolean&gt; decorated = Decorators.ofSupplier(supplier)
    .withRetry(retry)
    .withCircuitBreaker(cb)
    .decorate();
</code></pre>
<h3 id="效果">效果</h3>
<p>某电商大厂上线此方案后，支付接口 <strong>超时率下降60%</strong> ，且熔断触发频率降低近 <strong>90%</strong></p>
<p>真正做到了“打不还手，骂不还口”。</p>
<h2 id="4-mq队列">4 MQ队列</h2>
<h3 id="适用场景">适用场景</h3>
<p>高并发、允许延时的异步场景（如物流状态同步）。</p>
<h3 id="实现原理">实现原理</h3>
<ol>
<li>首次请求失败后，将消息投递至 <strong>延时队列</strong></li>
<li>队列根据预设的延时时间（如5秒、30秒、1分钟）重试消费</li>
<li>若达到最大重试次数，则转存至 <strong>死信队列</strong>（人工处理）</li>
</ol>
<p>RocketMQ代码片段如下：</p>
<pre><code class="language-java">// 生产者发送延时消息
Message&lt;String&gt; message = new Message();
message.setBody("订单数据");
message.setDelayTimeLevel(3); // RocketMQ预设的10秒延迟级别
rocketMQTemplate.send(message);

// 消费者重试
@RocketMQMessageListener(topic = "DELAY_TOPIC")
public class DelayConsumer {
    @Override
    public void handleMessage(Message message) {
        try {
            syncLogistics(message);
        } catch (Exception e) {
            // 重试次数 + 1，并重新发送到更高延迟级别
            resendWithDelay(message, retryCount + 1);
        }
    }
}
</code></pre>
<p>如何RocketMQ的消费者消费失败，会自动发起重试。</p>
<h2 id="5-定时任务">5 定时任务</h2>
<h3 id="适用场景-1">适用场景</h3>
<p>对于有些不需要实时反馈，允许批量处理的任务（如文件导入）的业务场景，我们可以使用定时任务。</p>
<p>在这里以Quartz为例。</p>
<p>具体代码如下：</p>
<pre><code class="language-java">@Scheduled(cron = "0 0/5 * * * ?") // 每5分钟执行
public void retryFailedTasks() {
    List&lt;FailedTask&gt; list = failedTaskDao.listUnprocessed(5); // 查失败任务
    list.forEach(task -&gt; {
        try {
            retryTask(task);
            task.markSuccess();
        } catch (Exception e) {
            task.incrRetryCount();
        }
        failedTaskDao.update(task);
    });
}
</code></pre>
<h2 id="6-两阶段提交">6 两阶段提交</h2>
<h3 id="适用场景-2">适用场景</h3>
<p>对于严格保证数据一致性的场景（如资金转账），我们可以使用两阶段提交机制。</p>
<h3 id="关键实现">关键实现</h3>
<ol>
<li><strong>第一阶段</strong>：记录操作流水到数据库（状态为“进行中”）</li>
<li><strong>第二阶段</strong>：调用远程接口，并根据结果更新流水状态</li>
<li><strong>定时补偿</strong>：扫描超时的“进行中”流水重新提交</li>
</ol>
<p>大致代码如下：</p>
<pre><code class="language-java">@Transactional
public void transfer(TransferRequest req) {
    // 1. 记录流水
    transferRecordDao.create(req, PENDING);
    
    // 2. 调用银行接口
    boolean success = bankClient.transfer(req);
    
    // 3. 更新流水状态
    transferRecordDao.updateStatus(req.getId(), success ? SUCCESS : FAILED);
    
    // 4. 失败转异步重试
    if (!success) {
        mqTemplate.send("TRANSFER_RETRY_QUEUE", req);
    }
}
</code></pre>
<h2 id="7-分布式锁">7 分布式锁</h2>
<h3 id="应用场景-1">应用场景</h3>
<p>对于一些多服务实例、多线程环境的防重复提交（如秒杀）的业务场景，我们可以使用分布式锁。</p>
<p>这里以Redis + Lua的分布式锁为例。</p>
<p>代码如下：</p>
<pre><code class="language-java">public boolean retryWithLock(String key, int maxRetry) {
    String lockKey = "api_retry_lock:" + key;
    for (int i = 0; i &lt; maxRetry; i++) {
        // 尝试获取分布式锁
        if (redis.setnx(lockKey, "1", 30, TimeUnit.SECONDS)) {
            try {
                return callApi();
            } finally {
                redis.delete(lockKey);
            }
        }
        Thread.sleep(1000 * (i + 1)); // 等待释放锁
    }
    return false;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>重试就像机房里的灭火器——永远不希望用到它，但必须保证关键时刻能救命。</p>
<p>我们工作中选择哪种方案？</p>
<p>别只看技术潮流，而要看业务的长矛和盾牌，需要哪种配合。</p>
<p>最后送大家一句话：<strong>系统稳定的秘诀，是永远对重试保持敬畏。</strong></p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3434149856712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-24 10:04">2025-03-24 10:03</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">263</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18788852" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18788852);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18788852', targetLink: 'https://www.cnblogs.com/12lisu/p/18788852', title: '接口重试的7种常用方案！' })">举报</a>
</div>
        