
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/springcoming/p/18868544" title="发布于 2025-05-09 17:04">
    <span role="heading" aria-level="2">C++11——右值引用&amp;完美转发</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>总而言之，右值引用，完美转发，std::move()都是为了在程序运行过程中，避免变量多次重复的申请和释放内存空间，使用移动语义将申请的空间通过这几种方式进行循环使用，避免重新开辟新空间和拷贝浪费算力。</p>
</blockquote>
<h1 id="右值引用">右值引用</h1>
<h2 id="一什么是右值引用">一、什么是右值引用？</h2>
<p>在 C++ 中：</p>
<ul>
<li><strong>左值（Lvalue）</strong>：有名字、有地址、可以被引用（如变量 <code>x</code>）</li>
<li><strong>右值（Rvalue）</strong>：临时对象、没有名字、无法被再次引用（如字面值 <code>5</code>，表达式 <code>x + y</code>）</li>
</ul>
<h3 id="语法">语法：</h3>
<pre><code class="language-cpp">int&amp;&amp; r = 10; // r 是一个右值引用
</code></pre>
<p>右值引用使用 <code>&amp;&amp;</code> 定义。</p>
<hr>
<h2 id="二为什么需要右值引用">二、为什么需要右值引用？</h2>
<p><strong>传统的 C++（C++03）只有拷贝语义</strong>，会频繁复制对象，性能开销大。</p>
<p><strong>右值引用的目的：</strong></p>
<ul>
<li><strong>避免不必要的拷贝</strong></li>
<li><strong>支持移动语义</strong></li>
</ul>
<hr>
<h2 id="三右值引用与移动构造函数">三、右值引用与移动构造函数</h2>
<p>来看一个例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class Buffer {
public:
    int* data;
    size_t size;

    Buffer(size_t s) : size(s) {
        data = new int[s];
        cout &lt;&lt; "Constructor" &lt;&lt; endl;
    }

    ~Buffer() {
        delete[] data;
        cout &lt;&lt; "Destructor" &lt;&lt; endl;
    }

    // 拷贝构造函数
    Buffer(const Buffer&amp; other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        cout &lt;&lt; "Copy Constructor" &lt;&lt; endl;
    }

    // 移动构造函数
    Buffer(Buffer&amp;&amp; other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr; // 接管资源
        other.size = 0;
        cout &lt;&lt; "Move Constructor" &lt;&lt; endl;
    }
};

int main() {
    Buffer b1(100);
    Buffer b2 = std::move(b1); // 调用移动构造函数
}
</code></pre>
<h3 id="输出">输出：</h3>
<pre><code>Constructor
Move Constructor
Destructor
</code></pre>
<p>👉 这里的 <code>std::move</code> 是 <strong>把左值转换成右值引用</strong>，以启用移动语义。</p>
<hr>
<h2 id="四移动-vs-拷贝-的区别">四、移动 vs 拷贝 的区别</h2>
<ul>
<li><strong>拷贝构造函数</strong>：复制数据（深拷贝），两份资源。</li>
<li><strong>移动构造函数</strong>：<strong>窃取资源指针</strong>，避免分配内存，效率更高。</li>
</ul>
<hr>
<h2 id="五右值引用的常见用法">五、右值引用的常见用法</h2>
<h3 id="-1-移动构造--移动赋值">✅ 1. 移动构造 / 移动赋值</h3>
<pre><code class="language-cpp">Buffer(Buffer&amp;&amp; other);              // 移动构造
Buffer&amp; operator=(Buffer&amp;&amp; other);  // 移动赋值
</code></pre>
<h3 id="-2-stdmove-转换左值为右值引用">✅ 2. <code>std::move</code> 转换左值为右值引用</h3>
<pre><code class="language-cpp">Buffer a(10);
Buffer b = std::move(a); // a 不再使用，资源移动给 b
</code></pre>
<h3 id="-3-完美转发在模板中">✅ 3. 完美转发（在模板中）</h3>
<pre><code class="language-cpp">template &lt;typename T&gt;
void wrapper(T&amp;&amp; arg) {
    process(std::forward&lt;T&gt;(arg)); // 保留左/右值特性
}
</code></pre>
<hr>
<h2 id="六右值引用-vs-const-引用">六、右值引用 vs const 引用</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>const T&amp;</code></th>
<th><code>T&amp;&amp;</code>（右值引用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否可修改</td>
<td>否</td>
<td>可以（除非你加 const）</td>
</tr>
<tr>
<td>是否绑定右值</td>
<td>✅ 可以</td>
<td>✅ 可以，仅右值</td>
</tr>
<tr>
<td>是否绑定左值</td>
<td>✅ 可以</td>
<td>❌ 不行</td>
</tr>
<tr>
<td>是否触发移动构造</td>
<td>❌ 不会</td>
<td>✅ 会</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七小结右值引用是为临时对象优化而生">七、小结：右值引用是为“临时对象优化而生”</h2>
<ul>
<li>节省资源分配与拷贝成本（性能提升显著）</li>
<li>和 <code>std::move</code>、<code>std::forward</code> 配合使用</li>
<li>支持自定义类的资源管理（RAII）更高效</li>
</ul>
<hr>
<h1 id="完美转发">完美转发</h1>
<h2 id="一什么是完美转发">一、什么是完美转发？</h2>
<p>完美转发的目标是：<strong>在模板中接收到参数后，不改变它的值类别（左值/右值）传递给其他函数。</strong></p>
<hr>
<h3 id="-举个问题">🧠 举个问题：</h3>
<p>你写了一个模板函数，想把参数“原封不动”地传给另一个函数，但：</p>
<pre><code class="language-cpp">void func(int&amp; x) { cout &lt;&lt; "Lvalue" &lt;&lt; endl; }
void func(int&amp;&amp; x) { cout &lt;&lt; "Rvalue" &lt;&lt; endl; }

template&lt;typename T&gt;
void wrapper(T t) {
    func(t); // 始终是左值，即使调用时是右值！
}

int main() {
    int a = 5;
    wrapper(a);        // Lvalue
    wrapper(10);       // ❌ 还是 Lvalue
}
</code></pre>
<p>问题在于：<strong>模板参数 t 是一个左值变量</strong>，哪怕传进来的是右值，也会退化为左值。</p>
<hr>
<h2 id="二解决方案stdforwardtt">二、解决方案：<code>std::forward&lt;T&gt;(t)</code></h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
void wrapper(T&amp;&amp; t) {
    func(std::forward&lt;T&gt;(t)); // 保留原始类型特性
}
</code></pre>
<h3 id="️-注意">⚠️ 注意：</h3>
<ul>
<li><code>T&amp;&amp; t</code> 是 <strong>万能引用（Universal Reference）</strong>，也叫<strong>转发引用（Forwarding Reference）</strong></li>
<li><code>std::forward&lt;T&gt;(t)</code> 是 <strong>完美转发</strong> 的关键，作用是：<strong>如果传进来是右值，就转发为右值；否则为左值</strong></li>
</ul>
<hr>
<h2 id="三标准库中的使用案例emplace_back">三、标准库中的使用案例：<code>emplace_back</code></h2>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; vec;
vec.push_back("hello");           // 拷贝构造或移动构造
vec.emplace_back("hello");       // 直接构造在容器内部
</code></pre>
<h3 id="emplace_back-原理简化"><code>emplace_back</code> 原理（简化）：</h3>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void emplace_back(Args&amp;&amp;... args) {
    // Args... 是参数类型包
    // Args&amp;&amp;... 是万能引用
    construct(std::forward&lt;Args&gt;(args)...); // 完美转发给构造函数
}
</code></pre>
<p>➡️ 这样就可以避免临时对象的生成，直接在容器内部原地构造，提高效率！</p>
<hr>
<h2 id="四小结完美转发的关键词">四、小结：完美转发的关键词</h2>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T&amp;&amp;</code> 在模板中</td>
<td>是万能引用（不是右值引用）</td>
</tr>
<tr>
<td><code>std::forward&lt;T&gt;(x)</code></td>
<td>保持 <code>x</code> 原来的值类别（左值/右值）</td>
</tr>
<tr>
<td>使用场景</td>
<td>构造函数转发、函数封装、容器的 <code>emplace</code> 系列等</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五一个完整的例子构造任意类型">五、一个完整的例子（构造任意类型）</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;

using namespace std;

class MyClass {
public:
    MyClass(int x) { cout &lt;&lt; "int ctor" &lt;&lt; endl; }
    MyClass(const MyClass&amp; other) { cout &lt;&lt; "copy ctor" &lt;&lt; endl; }
    MyClass(MyClass&amp;&amp; other) noexcept { cout &lt;&lt; "move ctor" &lt;&lt; endl; }
};

template&lt;typename T, typename... Args&gt;
T* create(Args&amp;&amp;... args) {
    return new T(std::forward&lt;Args&gt;(args)...); // 完美转发构造对象
}

int main() {
    MyClass* a = create&lt;MyClass&gt;(10);     // 调用 int 构造函数
    MyClass b;
    MyClass* c = create&lt;MyClass&gt;(b);      // 调用 copy ctor
    MyClass* d = create&lt;MyClass&gt;(std::move(b)); // move ctor
}
</code></pre>
<hr>
<h1 id="stdmove">std::move</h1>
<h2 id="-一句话">🧠 一句话：</h2>
<blockquote>
<p><code>std::move()</code> 是现代 C++ 中处理 <strong>右值引用、移动语义</strong> 的关键工具。<code>std::move(obj)</code> 并不会“移动”对象，而是把 <code>obj</code> <strong>强制转换为右值引用</strong>，以便触发移动构造/移动赋值。是一个 <strong>类型转换工具函数</strong>。</p>
</blockquote>
<hr>
<h2 id="一stdmove-的作用">一、<code>std::move()</code> 的作用</h2>
<p>C++ 中，<strong>只有右值可以绑定到右值引用 <code>T&amp;&amp;</code></strong>。但是我们常常有一个左值变量，我们想“偷”它的资源（如在容器中或返回对象时）。这就需要：</p>
<pre><code class="language-cpp">std::move(x); // 把 x 转成右值，让移动构造函数或移动赋值被调用
</code></pre>
<hr>
<h2 id="二stdmove-的常见用法">二、<code>std::move()</code> 的常见用法</h2>
<h3 id="-1-移动构造--赋值">✅ 1. 移动构造 / 赋值</h3>
<pre><code class="language-cpp">Buffer b1;
Buffer b2 = std::move(b1); // 触发移动构造函数
</code></pre>
<h3 id="-2-函数返回值优化">✅ 2. 函数返回值优化</h3>
<pre><code class="language-cpp">Buffer generateBuffer() {
    Buffer temp;
    return std::move(temp); // 可选，现代编译器可自动优化（NRVO）
}
</code></pre>
<h3 id="-3-容器中移动元素">✅ 3. 容器中移动元素</h3>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; vec;
std::string str = "hello";

vec.push_back(std::move(str)); // 移动 str，避免拷贝
</code></pre>
<hr>
<h2 id="三底层实现源码原理">三、底层实现（源码原理）</h2>
<pre><code class="language-cpp">// 位于 &lt;utility&gt;
template&lt;typename T&gt;
typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t) noexcept {
    return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
}
</code></pre>
<h3 id="解读">解读：</h3>
<ol>
<li><code>T&amp;&amp; t</code> 是万能引用（可能是左值也可能是右值）</li>
<li><code>remove_reference&lt;T&gt;::type</code> 去掉引用修饰</li>
<li>最终执行一个 <strong><code>static_cast&lt;T&amp;&amp;&gt;</code></strong> —— 把值转换为<strong>右值引用类型</strong></li>
</ol>
<p>🔁 所以本质是：<strong>一个显式类型转换成右值引用的封装</strong>。</p>
<hr>
<h2 id="四使用-stdmove-的注意事项-️">四、使用 <code>std::move()</code> 的注意事项 ⚠️</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否应该用 <code>std::move</code>？</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量将来还会使用</td>
<td>❌ 不推荐</td>
<td>被移动的对象通常处于“空壳”状态，后续使用容易出错</td>
</tr>
<tr>
<td>返回局部变量</td>
<td>✅ 可选</td>
<td>编译器可能已自动优化，但加 <code>move</code> 明确意图</td>
</tr>
<tr>
<td>函数参数是右值引用（T&amp;&amp;）变量</td>
<td>✅ 推荐</td>
<td>因为它是<strong>左值变量</strong>，仍需显式转换为右值</td>
</tr>
<tr>
<td>const 对象</td>
<td>❌ 无意义</td>
<td>const 对象不能移动，只能拷贝（移动构造需要非 const）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五例子const-对象不能用-move">五、例子：const 对象不能用 <code>move</code></h2>
<pre><code class="language-cpp">const std::string s = "hello";
std::string t = std::move(s); // ❌ 实际是拷贝，因为 s 是 const，不能 move
</code></pre>
<hr>
<h2 id="六配套使用stdmove-vs-stdforward">六、配套使用：<code>std::move</code> vs <code>std::forward</code></h2>
<table>
<thead>
<tr>
<th>工具</th>
<th>用于哪里</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::move(obj)</code></td>
<td>强制为右值</td>
<td>总是把 <code>obj</code> 转换成右值引用（<code>T&amp;&amp;</code>）</td>
</tr>
<tr>
<td><code>std::forward&lt;T&gt;(obj)</code></td>
<td>完美转发（模板中）</td>
<td>保留 <code>obj</code> 的左/右值本性（用于泛型转发）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七小结">七、小结</h2>
<p>✅ <code>std::move()</code> 本质是 <code>static_cast&lt;T&amp;&amp;&gt;</code><br>
✅ 用来<strong>启用移动语义</strong>，而不是实际移动<br>
✅ 被移动的对象不能再继续用<br>
✅ 与移动构造函数、移动赋值配合使用</p>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7468877392476851" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-09 17:07">2025-05-09 17:04</span>&nbsp;
<a href="https://www.cnblogs.com/springcoming">江海余生</a>&nbsp;
阅读(<span id="post_view_count">86</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18868544);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18868544', targetLink: 'https://www.cnblogs.com/springcoming/p/18868544', title: 'C++11——右值引用&amp;amp;完美转发' })">举报</a>
</div>
        