
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/io-T-T/p/18663921" title="发布于 2025-01-10 14:20">
    <span role="heading" aria-level="2">python SQLAlchemy ORM——从零开始学习03 如何针对数据库信息进行排序</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="03-如何进行排序">03 如何进行排序</h3>
<h4 id="3-1准备工作">3-1准备工作：</h4>
<p>因为要排序，所以需要随机多谢数据，<code>model</code>见后文。也需要<code>random</code>进行随机</p>
<pre><code class="language-python">from model import User, Engine
from sqlalchemy.orm import sessionmaker
import random

Session = sessionmaker(bind=Engine)
session = Session()
</code></pre>
<pre><code class="language-python">def add_random():
    names = ['arthur', 'Abigail Williams', 'caster', 'Lilith']
    ages = [14, 18, 20, 21, 23, 25, 28, 30, 31, 100]
    for x in range(20):
        user = User(name=random.choice(names), age=random.choice(ages))  # 创建随机user
        session.add(user)  # 这里每次添加，会存放到缓冲区，之后一并提交，虽然可以使用users存放再add_all，但是这增加了开销，不过可读性增加了
    session.commit()
</code></pre>
<p>数据库可以看到【不一定相等，毕竟是随机，但数量是20就行】：</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202501/3244923-20250110141926322-2083981272.png" alt="image-20250108205432355" loading="lazy"></p>
<p>如果多次点击了导致多于20个怎么办，我确实是点多了一次，用我自己写的这个接口就能删到只剩20了，或者你自己修改都可以</p>
<pre><code class="language-python">def remove_at_lest_20():
    users = session.query(User).filter(User.id &gt; 20).all()

    for user_one in users:
        session.delete(user_one)
    session.commit()
</code></pre>
<h4 id="3-2-排序">3-2 排序</h4>
<p>其实只需要了解<code>order_by()</code>这个接口就好，先看看官方对这个接口的eg：</p>
<blockquote>
<p>q = session.query(Entity).order_by(Entity.id, Entity.name)</p>
</blockquote>
<p>其实基本上同理，他可以接收多个参数</p>
<pre><code class="language-python">def order_sort():
    Users = session.query(User).order_by(User.age, User.name).all()
    # Users = session.query(User).order_by(User.age.desc(), User.name).all()    #其中使用.desc可以进行倒序排序
    for user in Users:
        print(user)
</code></pre>
<p>顺序的结果是（部分）：</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202501/3244923-20250110141925713-1896914512.png" alt="image-20250108211219133" loading="lazy"></p>
<p>倒叙的结果也是没问题的：</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202501/3244923-20250110141927026-1074658586.png" alt="image-20250108211248641" loading="lazy"></p>
<p><strong>PS：注意，如果后面commit是没有效果的，因为需要显式修改数据库才能记录【如add、del、修改】这里使用排序是不会对源数据进行修改的。</strong></p>
<h4 id="3-3-code">3-3 code</h4>
<p><strong>model</strong></p>
<pre><code class="language-python">from sqlalchemy import create_engine, Integer, String
from sqlalchemy.orm import DeclarativeBase, mapped_column,Mapped
from typing import Optional
url = "sqlite:///database_02.db"                        #记得修改一下自己的数据库
Engine = create_engine(url,echo=True)
class Base(DeclarativeBase):                            #通过类构造，这样子会有语法提示
    pass

class User(Base):                                      #构造自己的User表
    __tablename__ = "User"
    id:Mapped[int] = mapped_column(primary_key=True)       #构造方法和之前不一样，但是效果是一样的，我这里偷学了，不用管，直接复制就好
    name:Mapped[str] = mapped_column(nullable=True)
    age:Mapped[Optional[int]]
    def __repr__(self):                                     #方便后续直接print的，有兴趣可以了解一下
        return f"id:{self.id}, name:{self.name}, age:{self.age}"

Base.metadata.create_all(Engine)
</code></pre>
<p><strong>lesson2</strong></p>
<pre><code class="language-python">from model import User, Engine
from sqlalchemy.orm import sessionmaker
import random

Session = sessionmaker(bind=Engine)
session = Session()


def add_random():
    names = ['arthur', 'Abigail Williams', 'caster', 'Lilith']
    ages = [14, 18, 20, 21, 23, 25, 28, 30, 31, 100]
    for x in range(20):
        user = User(name=random.choice(names), age=random.choice(ages))  # 创建随机user
        session.add(user)  # 这里每次添加，会存放到缓冲区，之后一并提交，虽然可以使用users存放再add_all，但是这增加了开销，不过可读性增加了
    session.commit()
def remove_at_lest_20():
    users = session.query(User).filter(User.id &gt; 20).all()

    for user_one in users:
        session.delete(user_one)
    session.commit()

def order_sort():
    # Users = session.query(User).order_by(User.age, User.name).all()
    Users = session.query(User).order_by(User.age.desc(), User.name).all()    #其中使用.desc可以进行倒序排序
    for user in Users:
        print(user)

if __name__ == '__main__':
    order_sort()
    # remove_at_lest_20()
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9143551019699074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 14:21">2025-01-10 14:20</span>&nbsp;
<a href="https://www.cnblogs.com/io-T-T">io_T_T</a>&nbsp;
阅读(<span id="post_view_count">103</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18663921" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18663921);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18663921', targetLink: 'https://www.cnblogs.com/io-T-T/p/18663921', title: 'python SQLAlchemy ORM——从零开始学习03 如何针对数据库信息进行排序' })">举报</a>
</div>
        