
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hhhlxmh/p/18939162" title="å‘å¸ƒäº 2025-06-20 20:16">
    <span role="heading" aria-level="2">GAMES101ä½œä¸š2</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        åŒ…å›´ç›’ï¼›æ’å€¼è®¡ç®—ï¼›æ·±åº¦æµ‹è¯•ï¼›åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼›å…‰æ …åŒ–ï¼›
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>å£°æ˜ï¼šä½¿ç”¨çš„æ˜¯vs2022ç‰ˆï¼Œä»¥ä¸‹å†…å®¹å¦‚æœ‰é—®é¢˜ï¼Œæ„Ÿè°¢å„ä½å¤§ä½¬æŒ‡æ­£ï¼<br>
ä½œä¸šè¦æ±‚ï¼š</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201032696-1387741420.png" class="lazyload"></p>
<p>ä½œä¸šç›®çš„ï¼šåœ¨å±å¹•ä¸Šç”»å‡ºä¸€ä¸ªå®å¿ƒçš„ä¸‰è§’å½¢ï¼ˆæ·±åº¦æµ‹è¯•ï¼‰</p>
<p>æˆ‘ä»¬éœ€è¦åšçš„ï¼š</p>
<aside>
ğŸ’¡åœ¨main.cppä¸­ä¿®æ”¹
<ol>
<li>Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();//ä¸­<strong>ç²˜è´´è‡ªå·±ç¬¬ä¸€æ¬¡çš„ä»£ç </strong></li>
<li>rasterize_triangle(): æ‰§è¡Œä¸‰è§’å½¢æ …æ ¼åŒ–ç®—æ³•//<strong>å†™åŒ…å›´ç›’ã€åˆ¤æ–­é‡‡æ ·ç‚¹ã€é€è§†çŸ«æ­£æ’å€¼è®¡ç®—ã€æ·±åº¦æµ‹è¯•ã€åƒç´ æ›´æ–°</strong></li>
<li>static bool insideTriangle(): <strong>æµ‹è¯•ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ã€‚ä½ å¯ä»¥ä¿®æ”¹æ­¤å‡½æ•°çš„å®šä¹‰ï¼Œè¿™æ„å‘³ç€ï¼Œä½ å¯ä»¥æŒ‰ç…§è‡ªå·±çš„æ–¹å¼æ›´æ–°è¿”å›ç±»å‹æˆ–å‡½æ•°å‚æ•°ã€‚</strong></li>
</ol>
</aside>
<p>å…³é”®è¯ï¼šåŒ…å›´ç›’ï¼›æ’å€¼è®¡ç®—ï¼›æ·±åº¦æµ‹è¯•ï¼›åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼›å…‰æ …åŒ–ï¼›</p>
<p><strong>1.ç²˜è´´è‡ªå·±ç¬¬ä¸€æ¬¡ä»£ç </strong></p>
<pre><code class="language-cpp">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,float zNear, float zFar)
{
    // Students will implement this function

    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    // TODO: Implement this function
    // Create the projection matrix for the given parameters.
    // Then return it.
    
    //ç²˜è´´ç¬¬ä¸€æ¬¡ä½œä¸š
    float n = zNear;
    float f = zFar;
    Eigen::Matrix4f M_persp2Ortho;
    M_persp2Ortho &lt;&lt; n, 0, 0, 0,
        0, n, 0, 0,
        0, 0, n + f, -n * f,
        0, 0, 1, 0;

    float fov = eye_fov * MY_PI / 180.0;
    float t = -n * tan(fov / 2.);//è§£å†³åŸä¸‰è§’å€’ç€çš„æ–¹æ³•ï¼Œå°†tæ¢ä¸º-t
    float b = -t;
    float r = aspect_ratio * t;
    float l = -r;
    
    Eigen::Matrix4f M_ortho, trans, scale;
    trans &lt;&lt; 1, 0, 0, -(r + l) / 2,
        0, 1, 0, -(t + b) / 2,
        0, 0, 1, -(n + f) / 2,
        0, 0, 0, 1;
    scale &lt;&lt; 2 / (r - l), 0, 0, 0,
        0, 2 / (t - b), 0, 0,
        0, 0, 2 / (n - f), 0,
        0, 0, 0, 1;
    M_ortho = scale * trans;

    projection = M_ortho * M_persp2Ortho;
    return projection;
}
</code></pre>
<p><strong>2.rasterize_triangle(): æ‰§è¡Œä¸‰è§’å½¢æ …æ ¼åŒ–ç®—æ³•</strong></p>
<p><strong>åˆ†ä¸‰æ­¥ï¼š</strong></p>
<p><strong>1.å†™ä¸‰è§’å½¢åŒ…å›´ç›’ï¼Œè®¡ç®—ä¸‰è§’å½¢åœ¨å±å¹•ç©ºé—´çš„è¾¹ç•Œå€¼</strong></p>
<pre><code class="language-cpp">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t)
{
    auto v = t.toVector4();//v æ˜¯ä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹çš„é½æ¬¡åæ ‡ï¼ˆx,y,z,wï¼‰
    
    // TODO : Find out the bounding box of current triangle.
    
    //åŒ…å›´ç›’ï¼ˆè®¡ç®—ä¸‰è§’å½¢åœ¨å±å¹•ç©ºé—´ä¸­çš„è¾¹ç•Œå€¼ï¼‰AABB
    float min_x = width;
    float max_x = 0;
    float min_y = height;
    float max_y = 0;

    for (int i = 0; i &lt; 3; i++)
    {
        min_x = std::min(v[i].x(), min_x);
        max_x = std::max(v[i].x(), max_x);
        min_y = std::min(v[i].y(), min_y);
        max_y = std::max(v[i].y(), max_y);
    }
</code></pre>
<p><strong>2.åˆ¤æ–­é‡‡æ ·ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼Œè®¡ç®—é‡‡æ ·ç‚¹çš„é‡å¿ƒåæ ‡ï¼Œç„¶åé€è§†çŸ«æ­£æ’å€¼è®¡ç®—æ·±åº¦å’Œé¢œè‰²</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/403259571#:~:text=%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%87%87%E7%94%A8%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0P%27%3DA%27%2Bm%20%28B%27-A%27%29%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BE%7CA%27B%27%7C%E4%B8%BA1%EF%BC%8C%E5%88%99%7CA%27P%27%7C%E4%B8%BAm%EF%BC%8C%7CP%27B%27%7C%E4%B8%BA1-m%E3%80%82%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%EF%BC%9A%E5%B7%B2%E7%9F%A5%E5%B1%8F%E5%B9%95%E4%B8%8A%E4%B8%80%E7%82%B9P%27%EF%BC%8C%E4%B8%94%20P%27%3D%20%281-m%29A%27%2BmB%27%20%EF%BC%8C%E8%BF%98%E6%9C%89%E9%A1%B6%E7%82%B9A%E5%92%8CB%E7%9A%84%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%EF%BC%8C,%E9%9C%80%E8%A6%81%E6%B1%82%E5%87%BA%E4%B8%8EP%27%E5%AF%B9%E5%BA%94%E7%9A%84%E7%82%B9P%E5%85%B3%E4%BA%8EAB%E7%9A%84%E8%A1%A8%E7%A4%BA%EF%BC%9A%20P%3D%20%281-n%29A%2BnB%20%E3%80%82%20%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%20%E8%BF%99%E9%87%8C%E6%88%91%E6%B7%BB%E5%8A%A0%E4%B8%A4%E6%9D%A1%E8%BE%85%E5%8A%A9%E7%BA%BF%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%EF%BC%9A%E4%BB%8EA%E5%92%8CB%E4%BD%9C%E7%AB%96%E7%9B%B4%E7%BA%BF%EF%BC%8C%E5%88%86%E5%88%AB%E4%BA%A4P%27P%E5%BB%B6%E9%95%BF%E7%BA%BF%E4%B8%8A%E7%9A%84G%E5%92%8CK%E3%80%82//%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E%E6%96%87%E7%AB%A0%E2%80%94" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/403259571#:~:text=è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨çº¿æ€§æ’å€¼ï¼Œå¯ä»¥å¾—åˆ°P'%3DA'%2Bm (B'-A')ï¼Œå¦‚æœè®¾|A'B'|ä¸º1ï¼Œåˆ™|A'P'|ä¸ºmï¼Œ|P'B'|ä¸º1-mã€‚ ç°åœ¨æˆ‘ä»¬çš„é—®é¢˜æ˜¯ï¼šå·²çŸ¥å±å¹•ä¸Šä¸€ç‚¹P'ï¼Œä¸” P'%3D (1-m)A'%2BmB' ï¼Œè¿˜æœ‰é¡¶ç‚¹Aå’ŒBçš„ä¸–ç•Œåæ ‡ï¼Œ,éœ€è¦æ±‚å‡ºä¸P'å¯¹åº”çš„ç‚¹På…³äºABçš„è¡¨ç¤ºï¼š P%3D (1-n)A%2BnB ã€‚ å…¬å¼æ¨å¯¼ è¿™é‡Œæˆ‘æ·»åŠ ä¸¤æ¡è¾…åŠ©çº¿ï¼Œæ–¹ä¾¿å…¬å¼æ¨å¯¼ï¼šä»Aå’ŒBä½œç«–ç›´çº¿ï¼Œåˆ†åˆ«äº¤P'På»¶é•¿çº¿ä¸Šçš„Gå’ŒKã€‚//æ¥è‡ªçŸ¥ä¹æ–‡ç« â€”</a><strong>å›¾å½¢å­¦ - å…³äºé€è§†çŸ«æ­£æ’å€¼é‚£äº›äº‹</strong></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201234430-1584716442.png" class="lazyload"></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201242210-549768080.png" class="lazyload"></p>
<pre><code class="language-cpp">    // iterate through the pixel and find if the current pixel is inside the triangle
    //éå†åƒç´ ï¼Œæ‰¾å‡ºå½“å‰åƒç´ æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
    // If so, use the following code to get the interpolated z value.
    //å¦‚æœæ˜¯è¿™æ ·ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹ä»£ç è·å–æ’å€¼zå€¼ã€‚
    //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
    //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
    //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
    //z_interpolated *= w_reciprocal;
    
    for (int y = min_y; y &lt; max_y; y++)
    {
        for (int x = min_x; x &lt; max_x; x++)
        {
            //éå†è¾¹ç•Œæ¡†å†…çš„æ‰€æœ‰åƒç´ ï¼Œæ£€æŸ¥ä¸­å¿ƒç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
            if (insideTriangle(x + 0.5, y + 0.5, t.v))//ä½¿ç”¨ (x + 0.5, y + 0.5) ä½œä¸ºåƒç´ ä¸­å¿ƒç‚¹
            {
                //é€è§†çŸ«æ­£æ’å€¼è®¡ç®—æ·±åº¦å’Œé¢œè‰²
                auto [alpha, beta, gamma] = computeBarycentric2D(x + 0.5, y + 0.5, t.v);//è®¡ç®—è¯¥ç‚¹çš„é‡å¿ƒåæ ‡
                // è®¡ç®—ï¼š1/ï¼ˆÎ± + Î² + Î³ï¼‰
                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                // è®¡ç®—ï¼šÎ±(zâ‚€/wâ‚€) + Î²(zâ‚/wâ‚) + Î³(zâ‚‚/wâ‚‚)
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                // ç›¸ä¹˜ï¼Œå¾—åˆ°æœ€ç»ˆæ’å€¼ç»“æœ
                z_interpolated *= w_reciprocal;

                
</code></pre>
<p><strong>3.æ·±åº¦æµ‹è¯•ä¸åƒç´ æ›´æ–°</strong></p>
<pre><code class="language-cpp">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.

                int index = get_index(x, y);
                if (z_interpolated &lt; depth_buf[index]) 
                {
                    Eigen::Vector3f p;
                    p &lt;&lt; x, y, z_interpolated;
                    set_pixel(p, t.getColor());
                    depth_buf[index] = z_interpolated;
                }
            }
        }
    }
}
</code></pre>
<p>2.<strong>rasterize_triangle():çš„å®Œæ•´ä»£ç </strong></p>
<pre><code class="language-cpp">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t)
{
    auto v = t.toVector4();//v æ˜¯ä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹çš„é½æ¬¡åæ ‡ï¼ˆx,y,z,wï¼‰
    
    // TODO : Find out the bounding box of current triangle.
    
    //åŒ…å›´ç›’ï¼ˆè®¡ç®—ä¸‰è§’å½¢åœ¨å±å¹•ç©ºé—´ä¸­çš„è¾¹ç•Œå€¼ï¼‰AABB
    float min_x = width;
    float max_x = 0;
    float min_y = height;
    float max_y = 0;

    for (int i = 0; i &lt; 3; i++)
    {
        min_x = std::min(v[i].x(), min_x);
        max_x = std::max(v[i].x(), max_x);
        min_y = std::min(v[i].y(), min_y);
        max_y = std::max(v[i].y(), max_y);
    }

    // iterate through the pixel and find if the current pixel is inside the triangle
    // If so, use the following code to get the interpolated z value.
    //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
    //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
    //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
    //z_interpolated *= w_reciprocal;
    
    for (int y = min_y; y &lt; max_y; y++)
    {
        for (int x = min_x; x &lt; max_x; x++)
        {
            //éå†è¾¹ç•Œæ¡†å†…çš„æ‰€æœ‰åƒç´ ï¼Œæ£€æŸ¥ä¸­å¿ƒç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
            if (insideTriangle(x + 0.5, y + 0.5, t.v))//ä½¿ç”¨ (x + 0.5, y + 0.5) ä½œä¸ºåƒç´ ä¸­å¿ƒç‚¹
            {
                //é€è§†çŸ«æ­£æ’å€¼è®¡ç®—æ·±åº¦å’Œé¢œè‰²
                auto [alpha, beta, gamma] = computeBarycentric2D(x + 0.5, y + 0.5, t.v);//è®¡ç®—è¯¥ç‚¹çš„é‡å¿ƒåæ ‡
                // è®¡ç®—ï¼š1/ï¼ˆÎ± + Î² + Î³ï¼‰
                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                // è®¡ç®—ï¼šÎ±(zâ‚€/wâ‚€) + Î²(zâ‚/wâ‚) + Î³(zâ‚‚/wâ‚‚)
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                // ç›¸ä¹˜ï¼Œå¾—åˆ°æœ€ç»ˆæ’å€¼ç»“æœ
                z_interpolated *= w_reciprocal;

                // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.
                // æ·±åº¦æµ‹è¯•ä¸åƒç´ æ›´æ–°
                int index = get_index(x, y);//å°†åæ ‡è½¬åŒ–ä¸ºç´¢å¼•
                if (z_interpolated &lt; depth_buf[index]) //å°†å½“å‰åƒç´ çš„æ·±åº¦å€¼å’Œç¼“å†²åŒºä¸­çš„è¿›è¡Œæ¯”è¾ƒ
                {
                    //z å€¼è¶Šå°è¶Šè¿‘
                    //å¦‚æœå½“å‰åƒç´ æ›´è¿‘ï¼Œå°±æ›´æ–°é¢œè‰²å’Œæ·±åº¦ç¼“å†²åŒº
                    Eigen::Vector3f p;
                    p &lt;&lt; x, y, z_interpolated;
                    //æ›´æ–°å¸§ç¼“å†²åŒºçš„é¢œè‰²
                    set_pixel(p, t.getColor());
                    //æ›´æ–°æ·±åº¦ç¼“å†²åŒºçš„å€¼
                    depth_buf[index] = z_interpolated;
                }
            }
        }
    }
}
</code></pre>
<p>3.æµ‹è¯•ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼ˆå‰ç§¯ï¼‰Cross product</p>
<pre><code class="language-cpp">static bool insideTriangle(float x, float y, const Vector3f* _v)
{   
    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]

    int flag = -1;

    for (int i = 0; i &lt; 3; i++)
    {
        Eigen::Vector3f p0 = { x,y,0 };       //å¾…æ£€æµ‹ç‚¹
        Eigen::Vector3f p1 = _v[i];           //å½“å‰è¾¹çš„èµ·ç‚¹
        Eigen::Vector3f p2 = _v[(i + 1) % 3]; //å½“å‰è¾¹çš„ç»ˆç‚¹

        Eigen::Vector3f v1 = p1 - p0;         //ä»å¾…æ£€æµ‹ç‚¹åˆ°è¾¹èµ·ç‚¹çš„å‘é‡
        Eigen::Vector3f v2 = p1 - p2;         //è¾¹çš„æ–¹å‘å‘é‡

        float cp = v1.cross(v2).z();          //è®¡ç®—å‰ç§¯çš„zåˆ†é‡
        if (cp == 0) continue;                // ç‚¹åœ¨è¾¹ä¸Šï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€æ¡è¾¹

        int sign = cp &lt; 0 ? 0 : 1;            // è·å–å‰ç§¯çš„ç¬¦å·ï¼ˆ0ä¸ºè´Ÿï¼Œ1ä¸ºæ­£ï¼‰
        if (flag == -1) flag = sign;          // è®°å½•ç¬¬ä¸€ä¸ªéé›¶å‰ç§¯çš„ç¬¦å·
        if (flag != sign)return false;        // ç¬¦å·ä¸ä¸€è‡´ï¼Œç‚¹åœ¨ä¸‰è§’å½¢å¤–éƒ¨
    }

    return true;                              // æ‰€æœ‰è¾¹çš„å‰ç§¯ç¬¦å·ä¸€è‡´ï¼Œç‚¹åœ¨ä¸‰è§’å½¢å†…éƒ¨
    
 }
</code></pre>
<p>æœ€åè¿è¡Œï¼Œå¾—åˆ°è¿™å¹…å›¾</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201453804-565870999.png" class="lazyload"></p>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008333333333333333" data-date-updated="2025-06-20 20:28">2025-06-20 20:16</span>&nbsp;
<a href="https://www.cnblogs.com/hhhlxmh">é±¼é±¼è²</a>&nbsp;
é˜…è¯»(<span id="post_view_count">0</span>)&nbsp;
è¯„è®º(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18939162);return false;">æ”¶è—</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18939162', targetLink: 'https://www.cnblogs.com/hhhlxmh/p/18939162', title: 'GAMES101ä½œä¸š2' })">ä¸¾æŠ¥</a>
</div>
        