
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hhhlxmh/p/18939162" title="发布于 2025-06-20 20:16">
    <span role="heading" aria-level="2">GAMES101作业2</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        包围盒；插值计算；深度测试；判断点是否在三角形内；光栅化；
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>声明：使用的是vs2022版，以下内容如有问题，感谢各位大佬指正！<br>
作业要求：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201032696-1387741420.png" class="lazyload"></p>
<p>作业目的：在屏幕上画出一个实心的三角形（深度测试）</p>
<p>我们需要做的：</p>
<aside>
💡在main.cpp中修改
<ol>
<li>Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();//中<strong>粘贴自己第一次的代码</strong></li>
<li>rasterize_triangle(): 执行三角形栅格化算法//<strong>写包围盒、判断采样点、透视矫正插值计算、深度测试、像素更新</strong></li>
<li>static bool insideTriangle(): <strong>测试点是否在三角形内。你可以修改此函数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。</strong></li>
</ol>
</aside>
<p>关键词：包围盒；插值计算；深度测试；判断点是否在三角形内；光栅化；</p>
<p><strong>1.粘贴自己第一次代码</strong></p>
<pre><code class="language-cpp">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,float zNear, float zFar)
{
    // Students will implement this function

    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    // TODO: Implement this function
    // Create the projection matrix for the given parameters.
    // Then return it.
    
    //粘贴第一次作业
    float n = zNear;
    float f = zFar;
    Eigen::Matrix4f M_persp2Ortho;
    M_persp2Ortho &lt;&lt; n, 0, 0, 0,
        0, n, 0, 0,
        0, 0, n + f, -n * f,
        0, 0, 1, 0;

    float fov = eye_fov * MY_PI / 180.0;
    float t = -n * tan(fov / 2.);//解决原三角倒着的方法，将t换为-t
    float b = -t;
    float r = aspect_ratio * t;
    float l = -r;
    
    Eigen::Matrix4f M_ortho, trans, scale;
    trans &lt;&lt; 1, 0, 0, -(r + l) / 2,
        0, 1, 0, -(t + b) / 2,
        0, 0, 1, -(n + f) / 2,
        0, 0, 0, 1;
    scale &lt;&lt; 2 / (r - l), 0, 0, 0,
        0, 2 / (t - b), 0, 0,
        0, 0, 2 / (n - f), 0,
        0, 0, 0, 1;
    M_ortho = scale * trans;

    projection = M_ortho * M_persp2Ortho;
    return projection;
}
</code></pre>
<p><strong>2.rasterize_triangle(): 执行三角形栅格化算法</strong></p>
<p><strong>分三步：</strong></p>
<p><strong>1.写三角形包围盒，计算三角形在屏幕空间的边界值</strong></p>
<pre><code class="language-cpp">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t)
{
    auto v = t.toVector4();//v 是三角形三个顶点的齐次坐标（x,y,z,w）
    
    // TODO : Find out the bounding box of current triangle.
    
    //包围盒（计算三角形在屏幕空间中的边界值）AABB
    float min_x = width;
    float max_x = 0;
    float min_y = height;
    float max_y = 0;

    for (int i = 0; i &lt; 3; i++)
    {
        min_x = std::min(v[i].x(), min_x);
        max_x = std::max(v[i].x(), max_x);
        min_y = std::min(v[i].y(), min_y);
        max_y = std::max(v[i].y(), max_y);
    }
</code></pre>
<p><strong>2.判断采样点是否在三角形内，计算采样点的重心坐标，然后透视矫正插值计算深度和颜色</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/403259571#:~:text=%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%87%87%E7%94%A8%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0P%27%3DA%27%2Bm%20%28B%27-A%27%29%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BE%7CA%27B%27%7C%E4%B8%BA1%EF%BC%8C%E5%88%99%7CA%27P%27%7C%E4%B8%BAm%EF%BC%8C%7CP%27B%27%7C%E4%B8%BA1-m%E3%80%82%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%EF%BC%9A%E5%B7%B2%E7%9F%A5%E5%B1%8F%E5%B9%95%E4%B8%8A%E4%B8%80%E7%82%B9P%27%EF%BC%8C%E4%B8%94%20P%27%3D%20%281-m%29A%27%2BmB%27%20%EF%BC%8C%E8%BF%98%E6%9C%89%E9%A1%B6%E7%82%B9A%E5%92%8CB%E7%9A%84%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%EF%BC%8C,%E9%9C%80%E8%A6%81%E6%B1%82%E5%87%BA%E4%B8%8EP%27%E5%AF%B9%E5%BA%94%E7%9A%84%E7%82%B9P%E5%85%B3%E4%BA%8EAB%E7%9A%84%E8%A1%A8%E7%A4%BA%EF%BC%9A%20P%3D%20%281-n%29A%2BnB%20%E3%80%82%20%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%20%E8%BF%99%E9%87%8C%E6%88%91%E6%B7%BB%E5%8A%A0%E4%B8%A4%E6%9D%A1%E8%BE%85%E5%8A%A9%E7%BA%BF%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%EF%BC%9A%E4%BB%8EA%E5%92%8CB%E4%BD%9C%E7%AB%96%E7%9B%B4%E7%BA%BF%EF%BC%8C%E5%88%86%E5%88%AB%E4%BA%A4P%27P%E5%BB%B6%E9%95%BF%E7%BA%BF%E4%B8%8A%E7%9A%84G%E5%92%8CK%E3%80%82//%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E%E6%96%87%E7%AB%A0%E2%80%94" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/403259571#:~:text=这里我们采用线性插值，可以得到P'%3DA'%2Bm (B'-A')，如果设|A'B'|为1，则|A'P'|为m，|P'B'|为1-m。 现在我们的问题是：已知屏幕上一点P'，且 P'%3D (1-m)A'%2BmB' ，还有顶点A和B的世界坐标，,需要求出与P'对应的点P关于AB的表示： P%3D (1-n)A%2BnB 。 公式推导 这里我添加两条辅助线，方便公式推导：从A和B作竖直线，分别交P'P延长线上的G和K。//来自知乎文章—</a><strong>图形学 - 关于透视矫正插值那些事</strong></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201234430-1584716442.png" class="lazyload"></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201242210-549768080.png" class="lazyload"></p>
<pre><code class="language-cpp">    // iterate through the pixel and find if the current pixel is inside the triangle
    //遍历像素，找出当前像素是否在三角形内
    // If so, use the following code to get the interpolated z value.
    //如果是这样，请使用以下代码获取插值z值。
    //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
    //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
    //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
    //z_interpolated *= w_reciprocal;
    
    for (int y = min_y; y &lt; max_y; y++)
    {
        for (int x = min_x; x &lt; max_x; x++)
        {
            //遍历边界框内的所有像素，检查中心点是否在三角形内
            if (insideTriangle(x + 0.5, y + 0.5, t.v))//使用 (x + 0.5, y + 0.5) 作为像素中心点
            {
                //透视矫正插值计算深度和颜色
                auto [alpha, beta, gamma] = computeBarycentric2D(x + 0.5, y + 0.5, t.v);//计算该点的重心坐标
                // 计算：1/（α + β + γ）
                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                // 计算：α(z₀/w₀) + β(z₁/w₁) + γ(z₂/w₂)
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                // 相乘，得到最终插值结果
                z_interpolated *= w_reciprocal;

                
</code></pre>
<p><strong>3.深度测试与像素更新</strong></p>
<pre><code class="language-cpp">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.

                int index = get_index(x, y);
                if (z_interpolated &lt; depth_buf[index]) 
                {
                    Eigen::Vector3f p;
                    p &lt;&lt; x, y, z_interpolated;
                    set_pixel(p, t.getColor());
                    depth_buf[index] = z_interpolated;
                }
            }
        }
    }
}
</code></pre>
<p>2.<strong>rasterize_triangle():的完整代码</strong></p>
<pre><code class="language-cpp">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t)
{
    auto v = t.toVector4();//v 是三角形三个顶点的齐次坐标（x,y,z,w）
    
    // TODO : Find out the bounding box of current triangle.
    
    //包围盒（计算三角形在屏幕空间中的边界值）AABB
    float min_x = width;
    float max_x = 0;
    float min_y = height;
    float max_y = 0;

    for (int i = 0; i &lt; 3; i++)
    {
        min_x = std::min(v[i].x(), min_x);
        max_x = std::max(v[i].x(), max_x);
        min_y = std::min(v[i].y(), min_y);
        max_y = std::max(v[i].y(), max_y);
    }

    // iterate through the pixel and find if the current pixel is inside the triangle
    // If so, use the following code to get the interpolated z value.
    //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
    //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
    //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
    //z_interpolated *= w_reciprocal;
    
    for (int y = min_y; y &lt; max_y; y++)
    {
        for (int x = min_x; x &lt; max_x; x++)
        {
            //遍历边界框内的所有像素，检查中心点是否在三角形内
            if (insideTriangle(x + 0.5, y + 0.5, t.v))//使用 (x + 0.5, y + 0.5) 作为像素中心点
            {
                //透视矫正插值计算深度和颜色
                auto [alpha, beta, gamma] = computeBarycentric2D(x + 0.5, y + 0.5, t.v);//计算该点的重心坐标
                // 计算：1/（α + β + γ）
                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
                // 计算：α(z₀/w₀) + β(z₁/w₁) + γ(z₂/w₂)
                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
                // 相乘，得到最终插值结果
                z_interpolated *= w_reciprocal;

                // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.
                // 深度测试与像素更新
                int index = get_index(x, y);//将坐标转化为索引
                if (z_interpolated &lt; depth_buf[index]) //将当前像素的深度值和缓冲区中的进行比较
                {
                    //z 值越小越近
                    //如果当前像素更近，就更新颜色和深度缓冲区
                    Eigen::Vector3f p;
                    p &lt;&lt; x, y, z_interpolated;
                    //更新帧缓冲区的颜色
                    set_pixel(p, t.getColor());
                    //更新深度缓冲区的值
                    depth_buf[index] = z_interpolated;
                }
            }
        }
    }
}
</code></pre>
<p>3.测试点是否在三角形内（叉积）Cross product</p>
<pre><code class="language-cpp">static bool insideTriangle(float x, float y, const Vector3f* _v)
{   
    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]

    int flag = -1;

    for (int i = 0; i &lt; 3; i++)
    {
        Eigen::Vector3f p0 = { x,y,0 };       //待检测点
        Eigen::Vector3f p1 = _v[i];           //当前边的起点
        Eigen::Vector3f p2 = _v[(i + 1) % 3]; //当前边的终点

        Eigen::Vector3f v1 = p1 - p0;         //从待检测点到边起点的向量
        Eigen::Vector3f v2 = p1 - p2;         //边的方向向量

        float cp = v1.cross(v2).z();          //计算叉积的z分量
        if (cp == 0) continue;                // 点在边上，继续检查下一条边

        int sign = cp &lt; 0 ? 0 : 1;            // 获取叉积的符号（0为负，1为正）
        if (flag == -1) flag = sign;          // 记录第一个非零叉积的符号
        if (flag != sign)return false;        // 符号不一致，点在三角形外部
    }

    return true;                              // 所有边的叉积符号一致，点在三角形内部
    
 }
</code></pre>
<p>最后运行，得到这幅图</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3596796/202506/3596796-20250620201453804-565870999.png" class="lazyload"></p>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008333333333333333" data-date-updated="2025-06-20 20:28">2025-06-20 20:16</span>&nbsp;
<a href="https://www.cnblogs.com/hhhlxmh">鱼鱼莲</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18939162);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18939162', targetLink: 'https://www.cnblogs.com/hhhlxmh/p/18939162', title: 'GAMES101作业2' })">举报</a>
</div>
        