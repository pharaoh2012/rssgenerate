
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ITnoteforlsy/p/18812368" title="发布于 2025-04-08 12:51">
    <span role="heading" aria-level="2">继承 QPaintEngine 利用 QSvgRenderer 从SVG 图片中提取路径（QPainterPath）的方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>SVG 作为为可缩放矢量图形（Scalable Vector Graphics），易于编辑和维护，基于XML的文本文件存储，在网页设计、图标制作、数据可视化和其他图形相关的领域应用广泛。在应用工程中总会有动态修改路径、绘制颜色等需求，这就需要能够动态的解析 svg 文件，获取对应的路径、颜色等参数。有许多解析 svg 文件的类库，例如：<a href="https://github.com/sorrowfeng/svgHelper" title="svgHelper" target="_blank" rel="noopener nofollow">svgHelper</a>。svgHelper 通过 QDomDocument 对 svg 文件进行了解析并提取出了路径和颜色信息，虽然该方法可行，但是具体的解析过程还是相当繁琐，稍有不慎就会出现错误。另外，渐变色、画刷类型、字体、是否显示等属性该库就无法表示。下面通过对SVG库源码进行分析来找到一种通过 render() 方法就可以获取到解析后的路径信息。</p>
<p>QT 提供了svg 库用于svg 的解析，但是大部分代码被封装起来，只提供了 QSvgRenderer 类和 QSvgGenerator 类给用户使用。而 QSvgRenderer 类能使用的只有 render() 方法。从 svg 库的文件目录可以看出来，svg 图像对应的节点、样式、字体等信息都有对应的描述类。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407112353614-1714485844.png" alt="image" loading="lazy"></p>
<p>QSvgRenderer 加载 svg 文件后，由 QSvgTinyDocument 类负责解析文件。QSvgTinyDocument 通过 QSvgHandler 执行具体的解析工作，QSvgTinyDocument 存储了解析后的 SVG 结构、样式等信息。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407135812483-1529847184.png" alt="image" loading="lazy"></p>
<p>QSvgTinyDocument 提供了 size()、 width() 、height() 、viewBox()、QSvgNode *namedNode(const QString &amp;id) const; QSvgPaintStyleProperty *namedStyle(const QString &amp;id) const;等方法，可以获取 SVG 解析后的相关信息。但是这些方法都在私有头文件中隐藏了起来。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407140934682-761566658.png" alt="image" loading="lazy"></p>
<p>如果要使用 QT 的 svg 库只有通过 render() 方法，该方法的具体执行由 QSvgTinyDocument 类的 draw() 方法负责。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407141743877-2108488615.png" alt="image" loading="lazy"></p>
<p>QSvgTinyDocument 类的 draw() 方法调用 QSvgNode 类的 draw() 方法绘制具体的 node，而 QSvgNode 类的 draw() 方法中通过虚函数 drawCommand() 将具体的图形绘制工作交给了其子类。QSvgNode 子类定义在 qsvggraphics_p.h 文件中，其定义了 SVG 支持的各种图形、路径、动画等的描述类，这些类都继承自 QSvgNode 并实现了虚函数 drawCommand(QPainter *p, QSvgExtraStates &amp;states) 定义了对应图像如何在 QPainter 上绘制。</p>
<pre><code>void QSvgTinyDocument::draw(QPainter *p, const QString &amp;id,
                            const QRectF &amp;bounds)
{
    QSvgNode *node = scopeNode(id);

    if (!node) {
        qCDebug(lcSvgHandler, "Couldn't find node %s. Skipping rendering.", qPrintable(id));
        return;
    }
    if (m_time == 0)
        m_time = QDateTime::currentMSecsSinceEpoch();

    if (node-&gt;displayMode() == QSvgNode::NoneMode)
        return;

    p-&gt;save();

    const QRectF elementBounds = node-&gt;transformedBounds();

    mapSourceToTarget(p, bounds, elementBounds);
    QTransform originalTransform = p-&gt;worldTransform();

    //XXX set default style on the painter
    QPen pen(Qt::NoBrush, 1, Qt::SolidLine, Qt::FlatCap, Qt::SvgMiterJoin);
    pen.setMiterLimit(4);
    p-&gt;setPen(pen);
    p-&gt;setBrush(Qt::black);
    p-&gt;setRenderHint(QPainter::Antialiasing);
    p-&gt;setRenderHint(QPainter::SmoothPixmapTransform);

    QStack&lt;QSvgNode*&gt; parentApplyStack;
    QSvgNode *parent = node-&gt;parent();
    while (parent) {
        parentApplyStack.push(parent);
        parent = parent-&gt;parent();
    }

    for (int i = parentApplyStack.size() - 1; i &gt;= 0; --i)
        parentApplyStack[i]-&gt;applyStyle(p, m_states);

    // Reset the world transform so that our parents don't affect
    // the position
    QTransform currentTransform = p-&gt;worldTransform();
    p-&gt;setWorldTransform(originalTransform);
    // 此处调用节点的 draw() 方法
    node-&gt;draw(p, m_states);

    p-&gt;setWorldTransform(currentTransform);

    for (int i = 0; i &lt; parentApplyStack.size(); ++i)
        parentApplyStack[i]-&gt;revertStyle(p, m_states);

    //p-&gt;fillRect(bounds.adjusted(-5, -5, 5, 5), QColor(0, 0, 255, 100));

    p-&gt;restore();
}
</code></pre>
<p>drawCommand 方法通过 QPainter 提供的绘制函数进行图形绘制。QPainter 的绘制动作由 QPaintDevice 通过 QPaintEngine 实现。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407145027915-905851439.png" alt="image" loading="lazy"></p>
<p>通过以上分析可知，如果实现一个 SVG 的绘制引擎，那么所有的绘制动作都可以被该引擎截获并重新解释。GitHub项目 <a href="https://github.com/lsyeei/dashboard" title="Compelling Data Designer" target="_blank" rel="noopener nofollow">Compelling Data Designer</a> 通过继承 QPaintEngine 实现了 SVG 的绘制引擎，通过 QSvgRenderer 的 render（）方法重新获取了 QPainterPath 及其填充、线条等属性。</p>
<pre><code>// svgpathdevice.h
class SvgEngine : public QPaintEngine
{
public:
    SvgEngine();
    QList&lt;PainterPathEx&gt; getSvgPath();
    // QPaintEngine interface
    bool begin(QPaintDevice *pdev) override;
    bool end() override;
    void updateState(const QPaintEngineState &amp;state) override;
    void drawPath(const QPainterPath &amp;path) override;
    void drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode) override;
    void drawPixmap(const QRectF &amp;r, const QPixmap &amp;pm, const QRectF &amp;sr) override;
    void drawTextItem(const QPointF &amp;p, const QTextItem &amp;textItem) override;
    QPaintEngine::Type type() const override;
private:
    QList&lt;PainterPathEx&gt; pathList;

};

class SvgPathDevice : public QPaintDevice
{
public:

    SvgPathDevice(int w, int h);
    SvgPathDevice(const QSize &amp;size);
    ~SvgPathDevice();
    QList&lt;PainterPathEx&gt; getSvgPath();

    qreal devicePixelRatio() const;
    void setDevicePixelRatio(qreal scaleFactor);
    // QPaintDevice interface
    QPaintEngine *paintEngine() const override;
    int devType() const override;

protected:
    int metric(PaintDeviceMetric metric) const override;
private:
    SvgEngine *engine;
    qreal pixelRatio{1};
    int width;
    int height;
    int qt_defaultDpiX() const;
    int qt_defaultDpiY() const;
};

// endtypefactory.cpp
QList&lt;PainterPathEx&gt; EndTypeFactory::extractPath(QSvgRenderer *render, QString id)
{
    if (!render-&gt;elementExists(id)) {
        return QList&lt;PainterPathEx&gt;();
    }
    render-&gt;setAspectRatioMode(Qt::KeepAspectRatio);
    auto size = render-&gt;defaultSize();
    SvgPathDevice svgPath(size);
    QPainter p(&amp;svgPath);
    render-&gt;render(&amp;p, id, QRectF{0, 0, size.width()*1.0, size.height()*1.0});
    p.end();
    return svgPath.getSvgPath();
}
</code></pre>
<p>该项目中线条的终端形状全部使用 SVG 文件进行定义，使用 EndTypeFactory 类作为终端形状的工厂类管理所有 svg 图形。EndTypeFactory 类加载 svg 图像时，通过 SvgPathDevice 类获取了图像的 PainterPath，保证了后续绘制过程中使用矢量图进行绘制。具体代码可以查看 plugins/lineplugin 目录下的 svgpathdevice 和 endtypefactory 类文件。</p>
<p><a href="https://github.com/lsyeei/dashboard" target="_blank" rel="noopener nofollow"><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407155307364-1160310946.gif" alt="image" loading="lazy"></a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8345794241388889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-08 13:06">2025-04-08 12:51</span>&nbsp;
<a href="https://www.cnblogs.com/ITnoteforlsy">永不停转</a>&nbsp;
阅读(<span id="post_view_count">78</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18812368" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18812368);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18812368', targetLink: 'https://www.cnblogs.com/ITnoteforlsy/p/18812368', title: '继承 QPaintEngine 利用 QSvgRenderer 从SVG 图片中提取路径（QPainterPath）的方法' })">举报</a>
</div>
        