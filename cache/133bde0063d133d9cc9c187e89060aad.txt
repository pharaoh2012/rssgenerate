
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/goodcitizen/p/18655303/macro_knowledges_what_you_dont_know" title="发布于 2025-01-20 10:43">
    <span role="heading" aria-level="2">你所不知道的 C/C++ 宏知识——基于《C/C++ 宏编程的艺术》</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1707550/202501/1707550-20250107163554339-1574162417.png" alt="你所不知道的 C/C++ 宏知识——基于《C/C++ 宏编程的艺术》" class="desc_img">
        C/C++ 宏缺陷这么多，它过时了吗？预处理器如何替换宏，有次数限制吗？何时终止？何为预扫描、后扫描？如何利用它们来实现延迟拼接、惰性求值，这些技术又有什么用处，宏与 C++ 模板元编程有何区别和联系？如何利用宏来生成代码？本文为你一一解答。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1><span style="font-size: 18px">前言</span></h1>
<p><span style="font-size: 18px">刚学 C++ 的时候，就知道它糅合了四种编程模式：基于预处理器的宏、基于 C 语言的面向过程、基于类的面向对象、以及基于模板的泛型编程。其中，宏和模板元编程因为是在编译期出结果，能有效提升程序运行期性能，有着独特的价值。</span></p>
<h1><span style="font-size: 18px">宏的缺陷</span></h1>
<p><span style="font-size: 18px">之前了解的宏编程，大多数在数说它的缺陷，以及如何避免，以下面的宏为例</span></p>
<pre class="language-c highlighter-hljs"><code>#define max(a,b) a&gt;b?a:b</code></pre>
<p><span style="font-size: 18px">就中了不少的招：</span></p>
<ul>
<li><span style="font-size: 18px">参数要用括号包围，例如 max(2+1,2)<br></span></li>
<li><span style="font-size: 18px">宏表达式要用括号包围，例如 max(1,2)*3</span></li>
<li><span style="font-size: 18px">多次求值，例如 max(n++,2)</span></li>
<li><span style="font-size: 18px">多个语句的宏应该用 do{}while(0) 包含，例如 if (x&gt;y) SWAP(x,y)，其中 SWAP 宏的实现至少需要三条语句<br></span></li>
<li><span style="font-size: 18px">不受命名空间限制，命名易冲突，例如参数名也使用 max 时会被展开</span></li>
<li><span style="font-size: 18px">...</span></li>
</ul>
<p><span style="font-size: 18px">总而言之就是少用宏、不用宏，为此想出了各种方式来替代宏：</span></p>
<ul>
<li><span style="font-size: 18px">typedef 与 using 定义类型别名</span></li>
<li><span style="font-size: 18px">inline 函数内联短小函数提升执行效率</span></li>
<li><span style="font-size: 18px">const 定义常量</span></li>
<li><span style="font-size: 18px">...</span></li>
</ul>
<p><span style="font-size: 18px">即使是使用宏，也加入很多改进，例如 </span><span style="font-size: 18px">GNU C 引入了 typeof 关键字，来解决参数多次求值、未被括号包围等问题</span></p>
<pre class="language-c highlighter-hljs"><code>#define max(x, y) ({            \
    typeof(x) _max1 = (x);      \
    typeof(y) _max2 = (y);      \
    (void) (&amp;_max1 == &amp;_max2);  \
    _max1 &gt; _max2 ? _max1 : _max2; })</code></pre>
<p><span style="font-size: 18px">宏很像结构化编程中的 goto 语句，不能说过街老鼠，也是日暮西山了。</span></p>
<h1><span style="font-size: 18px">宏的能力</span></h1>
<p><span style="font-size: 18px">直到我看了一篇文章：《<a href="https://bot-man-jl.github.io/articles/?post=2020/Macro-Programming-Art" target="_blank" rel="noopener nofollow">C/C++ 宏编程的艺术</a>》，才发现宏原来还可以这么玩。<br></span></p>
<p><span style="font-size: 18px">作者 BOT Man 主要是谈 GMOCK_PP 库中各个宏的依赖关系，我整理如下：</span></p>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1707550/202501/1707550-20250106170327517-1204550850.png"></span></p>
<p><span style="font-size: 18px">复杂的如 PP_WHILE-&gt;PP_ADD/PP_SUB-&gt;PP_MUL-&gt;PP_EQUAL/PP_CMP-&gt;PP_LESS-&gt;PP_DIV/PP_MOD，就没画了，主要是没看懂~</span></p>
<p><span style="font-size: 18px">另外，使用宏实现 256 以内的算术运算，有什么实际意义吗？我是持保留态度的。</span></p>
<p><span style="font-size: 18px">本文不会鹦鹉学舌再重复一遍 BOT Man 论证过的逻辑，而是梳理下预处理器的工作原理与宏编程遵循的规则，有一些是之前没注意到的，总结出来自己都感觉新鲜，呵呵。</span></p>
<h1><span style="font-size: 18px">宏的语法</span></h1>
<p><span style="font-size: 18px">宏虽然只进行文本替换，没有类型的概念，但也有以下基本的语法规则</span></p>
<ul>
<li><span style="font-size: 18px">宏参数使用逗号分隔，因此参数不能再包含逗号，除非使用元组</span></li>
<li><span style="font-size: 18px">宏参数不能包含不匹配的括号</span></li>
<li><span style="font-size: 18px">非可变参数的宏函数，参数个数必需严格匹配声明</span></li>
</ul>
<p><span style="font-size: 18px">对于规则 I，有些读者可能觉得没必要，毕竟参数名中也不可能有逗号，但是别忘了参数也可能是模板的实例，像下面这样：</span></p>
<pre class="language-c highlighter-hljs"><code>#define FOO(return,param) return foo(param); 
FOO(bool, std::pair&lt;int, int&gt;)</code></pre>
<p><span style="font-size: 18px">第二个模板参数中的逗号会使 FOO 的参数个数变为 3，从而导致预处理器报错：</span></p>
<pre class="language-c highlighter-hljs"><code>&lt;source&gt;:2:30: error: macro 'FOO' passed 3 arguments, but takes just 2
    2 | FOO(bool, std::pair&lt;int, int&gt;)
      |                              ^
&lt;source&gt;:1:9: note: macro 'FOO' defined here
    1 | #define FOO(return,param) return foo(param);
      |   </code></pre>
<p><span style="font-size: 18px">这里使用了 BOT Man 也推荐的 <a href="https://godbolt.org/" target="_blank" rel="noopener nofollow">Compile Explorer</a> 在线编译环境，编译器选择的是 <code>x86-64 gcc trunk</code>、编译参数是&nbsp; <code>-E -P -std=c++20</code>，后面统一使用这个设置进行测试。</span></p>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1707550/202501/1707550-20250106173257439-559800688.png"></span></p>
<p><span style="font-size: 18px">上例中如果使用元组，就不会报错了：</span></p>
<pre class="language-c highlighter-hljs"><code>FOO(bool, (std::pair&lt;int, int&gt;))
// =&gt; bool foo((std::pair&lt;int, int&gt;));</code></pre>
<p><span style="font-size: 18px">结果多了一对儿括号，追求完美的人，可以使用 PP_REMOVE_PARENS 去除，这个宏的实现，后面还会涉及，现在先不展开。</span></p>
<p><span style="font-size: 18px">对于规则 III，简单补充下宏的 4 种形态、以及规则的应用情况：</span></p>
<table style="border-collapse: collapse; width: 88.2353%" border="1">
<tbody>
<tr>
<td style="width: 47.2477%">形态</td>
<td style="width: 22.5917%">说明</td>
<td style="width: 30.2752%">规则 III</td>
</tr>
<tr>
<td style="width: 47.2477%"><span style="font-size: 14px">#define identifier replacement-list (optional)</span></td>
<td style="width: 22.5917%">仅文本替换</td>
<td style="width: 30.2752%">--</td>
</tr>
<tr>
<td style="width: 47.2477%"><span style="font-size: 14px">#define identifier (parameters ) replacement-list (optional)</span></td>
<td style="width: 22.5917%">固定参数个数的宏函数</td>
<td style="width: 30.2752%">参数个数严格匹配</td>
</tr>
<tr>
<td style="width: 47.2477%"><span style="font-size: 14px">#define identifier (parameters , ...) replacement-list (optional)&nbsp;</span></td>
<td style="width: 22.5917%">部分可变参数个数的宏函数</td>
<td style="width: 30.2752%">参数个数不能少于已出现的固定参数个数</td>
</tr>
<tr>
<td style="width: 47.2477%"><span style="font-size: 14px">#define identifier (...) replacement-list (optional)</span></td>
<td style="width: 22.5917%">全可变参数个数的宏函数</td>
<td style="width: 30.2752%">参数个数不做要求，可为 0 即空参数</td>
</tr>
</tbody>
</table>
<h1><span style="font-size: 18px">宏的运行</span></h1>
<p><span style="font-size: 18px">宏运行时遵循的规则先都列出来：</span></p>
<ol style="list-style-type: lower-alpha">
<li><span style="font-size: 18px">预处理器会对代码进行多遍扫描，展开所有遇到的宏，直到触发以下条件</span>
<ol style="list-style-type: lower-roman">
<li><span style="font-size: 18px">到达展开次数上限</span></li>
<li><span style="font-size: 18px">遇到自参照宏，即宏曾经展开过的模样<br></span></li>
</ol>
</li>
<li><span style="font-size: 18px">宏函数展开前先对所有参数进行一次预扫描并展开，除非遇到以下条件</span><br>
<ol style="list-style-type: lower-roman">
<li><span style="font-size: 18px">用于拼接的参数不展开 (##)<br></span></li>
<li><span style="font-size: 18px">用于宏字面量的参数不展开 (#)</span></li>
</ol>
</li>
<li><span style="font-size: 18px">在宏函数展开后，替换后的文本会进行后扫描 (二次扫描)，对遇到的宏继续进行展开</span></li>
<li><span style="font-size: 18px">预扫描和后扫描都遵循条件 a，会进行多遍扫描</span></li>
<li><span style="font-size: 18px">每次扫描前后，都会进行宏的语法检查</span></li>
</ol>
<p><span style="font-size: 18px">下面分别对每条规则进行说明。</span></p>
<h2><span style="font-size: 18px">自参照宏</span></h2>
<p><span style="font-size: 18px">写个简单的宏代码测试下：</span></p>
<pre class="language-c highlighter-hljs"><code>#define X0 X1
#define X1 X2
#define X2 X3
#define X3 X0

X0    // -&gt; X0
X1    // -&gt; X1
X2    // -&gt; X2
X3    // -&gt; X3</code></pre>
<p><span style="font-size: 18px">这是一个循环定义，X0-&gt;X1-&gt;X2-&gt;X3-&gt;X0，输出已列在代码注释，</span><span style="font-size: 18px">貌似什么也没发生，以 X0 为准，看下整个替换过程：</span></p>
<table style="border-collapse: collapse; width: 30.5158%" border="1">
<tbody>
<tr>
<td style="width: 32.2773%">状态</td>
<td style="width: 67.958%">应用宏</td>
</tr>
<tr>
<td style="width: 32.2773%">X0</td>
<td style="width: 67.958%">初始</td>
</tr>
<tr>
<td style="width: 32.2773%">X1</td>
<td style="width: 67.958%">#define X0 X1</td>
</tr>
<tr>
<td style="width: 32.2773%">X2</td>
<td style="width: 67.958%">#define X1 X2</td>
</tr>
<tr>
<td style="width: 32.2773%">X3</td>
<td style="width: 67.958%">#define X2 X3</td>
</tr>
<tr>
<td style="width: 32.2773%">X0</td>
<td style="width: 67.958%">#define X3 X0</td>
</tr>
<tr>
<td style="width: 32.2773%">X0</td>
<td style="width: 67.958%">自参照，停止替换</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">将最后一行宏定义改为：</span></p>
<pre class="language-c highlighter-hljs"><code>#define X3 X1</code></pre>
<p><span style="font-size: 18px">输出变为：</span></p>
<pre class="language-c highlighter-hljs"><code>X1
X1
X2
X3</code></pre>
<p><span style="font-size: 18px">这时 X0 的定义变为为 X1，整个过程列表如下：</span></p>
<table style="border-collapse: collapse; width: 30.0143%" border="1">
<tbody>
<tr>
<td style="width: 31.6229%">状态</td>
<td style="width: 68.3771%">应用宏</td>
</tr>
<tr>
<td style="width: 31.6229%">X0</td>
<td style="width: 68.3771%">初始</td>
</tr>
<tr>
<td style="width: 31.6229%">X1</td>
<td style="width: 68.3771%">#define X0 X1</td>
</tr>
<tr>
<td style="width: 31.6229%">X2</td>
<td style="width: 68.3771%">#define X1 X2</td>
</tr>
<tr>
<td style="width: 31.6229%">X3</td>
<td style="width: 68.3771%">#define X2 X3</td>
</tr>
<tr>
<td style="width: 31.6229%">X1</td>
<td style="width: 68.3771%">#define X3 X1</td>
</tr>
<tr>
<td style="width: 31.6229%">X1</td>
<td style="width: 68.3771%">自参照，停止替换</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">换句话说，预处理器会<strong>记录每个宏每次展开的历史值</strong>，避免与之重复，从而产生无限循环。</span></p>
<p><span style="font-size: 18px">这个特性，导致<strong>宏无法进行任何递归或重入</strong>，要进行任何推导，必需辛辛苦苦写 MACRO_1 / MACRO_2 ... MACRO_N 的代码，且 N 一般有上限。这是和模板元编程区别最大的地方，后者可以重载，进行模板偏特化，从而直接指定推导的结束条件。</span></p>
<h2><span style="font-size: 18px">展开次数上限</span></h2>
<p><span style="font-size: 18px">上面的例子中预处理器扫描了 4~5 次，为了考察它的扫描次数上限，使用下面的 shell 脚本批量制造测试代码：<br></span></p>
<pre class="language-bash highlighter-hljs"><code>for((i=0;i&lt;10000;++i)); do echo "#define X$i X$((i+1))"; done | pbcopy</code></pre>
<p><span style="font-size: 18px">mac 上的 pbcopy 负责将代码复制到剪贴板，也可以直接重定向到文件再复制出来。在 Compiler Explorer 中运行：</span></p>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1707550/202501/1707550-20250107113819268-482034965.png"></span></p>
<p><span style="font-size: 18px">居然没问题，看起来 10000 并不是上限。切换编译器为 <code>x86-64 clang (trunk)</code> 也正常，直到 <code>x64 msvc v19.latest</code> 时失败：</span></p>
<pre class="language-c highlighter-hljs"><code>&lt;source&gt;(10002): fatal error C1009: compiler limit: macros nested too deeply</code></pre>
<p><span style="font-size: 18px">经过多次探测，msvc 最终的最大宏定义是 X255，也就是说扫描次数最大为 256。</span></p>
<p><span style="font-size: 18px">不过 Compiler Explorer 上提供的 msvc 最新只到 VS2017，不过用实体机上的 VS2019 测试，结果也是一样的，看起来 msvc 对宏编程支持一般，怪不道 BOT Man 说 BOOST_PP 里有很多对 msvc 的兼容和 work around，汗~</span></p>
<h2><span style="font-size: 18px">延迟拼接</span></h2>
<p><span style="font-size: 18px">规则 b 使用 BOT Man 的例子就不错：</span></p>
<pre class="language-c highlighter-hljs"><code>#define FOO(SYMBOL) foo_ ## SYMBOL
#define LITERAL(SYMBOL) #SYMBOL
#define BAR() bar

FOO(bar)    // -&gt; foo_bar
FOO(BAR())  // -&gt; foo_BAR()
LITERAL(BAR())  // -&gt; "BAR()"</code></pre>
<p><span style="font-size: 18px">如果参数是用于拼接或取字面量的，预扫描将不会对它进行展开。</span></p>
<p><span style="font-size: 18px">注意，这里预处理器对宏参数的预扫描，也遵循规则 a，即在没有 ## 和 # 干扰时，它会一直展开直到 1) 达到最大展开次数 2)遇到自参照宏 时结束，并不是字面意思只扫描一次，这条就是规则 d。</span></p>
<p><span style="font-size: 18px">如果希望预处理器忽略 ## &amp; # 操作展开所有传入的宏函数参数，则需借助延迟拼接技术，这个技术听起来很高大上，其实原理很简单，直白说就是不直接实现宏函数而是调用另一个宏函数实现之：</span></p>
<pre class="language-c highlighter-hljs"><code>#define FOO(SYMBOL) FOO_IMPL(foo_, SYMBOL)
#define FOO_IMPL(A, B) A##B

FOO(bar)    // -&gt; foo_bar
FOO(BAR())  // -&gt; foo_bar</code></pre>
<p><span style="font-size: 18px">一般命名此类宏函数的惯例是：<code>MACRO</code> &amp; <code>MACRO_IMPL</code>，后者就是真正干活的宏了。下面列表推理下展开过程：</span></p>
<table style="border-collapse: collapse; width: 79.4413%; height: 126px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 29.7233%; height: 21px">状态</td>
<td style="width: 70.3365%; height: 21px">应用宏</td>
</tr>
<tr style="height: 21px">
<td style="width: 29.7233%; height: 21px">FOO(BAR())</td>
<td style="width: 70.3365%; height: 21px">初始</td>
</tr>
<tr>
<td style="width: 29.7233%; height: 21px">FOO(bar)</td>
<td style="width: 70.3365%; height: 21px">#define BAR bar 且 FOO 的实现没有对参数拼接或取字面量的操作</td>
</tr>
<tr style="height: 21px">
<td style="width: 29.7233%; height: 21px">FOO_IMPL(foo_, bar)</td>
<td style="width: 70.3365%; height: 21px">#define FOO(SYMBOL)&nbsp; FOO_IMPL(foo_, SYMBOL)</td>
</tr>
<tr style="height: 21px">
<td style="width: 29.7233%; height: 21px">foo_bar</td>
<td style="width: 70.3365%; height: 21px">#define FOO_IMPL(A, B) A##B</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">另外一个有实战意义的例子是在 Windows 上常用的宽字符前缀 L，如果定义一个 <code>TO_UNICODE</code> 的宏为任意窄字符串增加 L 前缀，可以这样做：</span></p>
<pre class="language-c highlighter-hljs"><code>#define TO_UNICODE(x) L##x
#define PRODUCT_NAME "Chrome"
// #define PRODUCT_NAME_W TO_UNICODE("Chrome")
#define PRODUCT_NAME_W TO_UNICODE(PRODUCT_NAME)
std::wstring product_name = PRODUCT_NAME_W;     // -&gt; LPRODUCT_NAME</code></pre>
<p><span style="font-size: 18px">使用 <code>TO_UNICODE</code> 宏为字符常量添加 L 前缀时，如果作用于常量字符串，是正常的；如果作用于经过宏定义的字符串 (<code>PRODUCT_NAME</code>)，基于规则 b.i 就会出现非预期结果 (<code>LPRODUCT_NAME</code>)，为了解决 L 拼接时宏不展开的问题，就需要借助延迟拼接技术：</span></p>
<pre class="language-c highlighter-hljs"><code>#define TO_UNICODE_IMPL(y) L##y
#define TO_UNICODE(x) TO_UNICODE_IMPL(x)
#define PRODUCT_NAME "Chrome"
#define PRODUCT_NAME_W TO_UNICODE(PRODUCT_NAME)
std::wstring product_name = PRODUCT_NAME_W;     // -&gt; L"Chrome"</code></pre>
<p><span style="font-size: 18px">关于这个例子，具体可参考附录 7。</span></p>
<h2><span style="font-size: 18px">惰性求值</span></h2>
<p><span style="font-size: 18px">惰性求值与后处理相关，技术不难理解，难的是场景不好说明，先来看一个宏语法错误：</span></p>
<pre class="language-c highlighter-hljs"><code>#define PP_COMMA() ,
#define PP_EMPTY()

#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
#define PP_CONCAT_IMPL(A, B) A##B

PP_CONCAT(x PP_COMMA() y) 
PP_CONCAT(x, PP_COMMA()) </code></pre>
<p><span style="font-size: 18px">预处理器会报下面的错误：</span></p>
<pre class="language-c highlighter-hljs"><code>&lt;source&gt;:25:25: error: macro 'PP_CONCAT' requires 2 arguments, but only 1 given
   25 | PP_CONCAT(x PP_COMMA() y)
      |                         ^
&lt;source&gt;:4:9: note: macro 'PP_CONCAT' defined here
    4 | #define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
      |         ^~~~~~~~~
&lt;source&gt;:26:24: error: macro 'PP_CONCAT_IMPL' passed 3 arguments, but takes just 2
   26 | PP_CONCAT(x, PP_COMMA())
      |                        ^
&lt;source&gt;:5:9: note: macro 'PP_CONCAT_IMPL' defined here
    5 | #define PP_CONCAT_IMPL(A, B) A##B
      |         ^~~~~~~~~~~~~~</code></pre>
<p><span style="font-size: 18px">第一个表达式出错，是错在预扫描前进行的语法检查，此时 PP_COMMA() 还未替换为 ',' 整个是一个参数：<code>x PP_COMMA() y</code>，<code>PP_CONCAT</code> 要求 2 个参数而只提供了 1 个；</span></p>
<p><span style="font-size: 18px">第二个表达式出错，是错在预扫描后进行的语法检查，此时 PP_COMMA() 替换为了 ',' 整个是三个参数：<code>x</code>、<code>空</code>、<code>空</code>，<code>PP_CONCAT</code> 要求 2 个参数而提供了 3 个。</span></p>
<p><span style="font-size: 18px">也就是说，宏的语法检查是时刻进行的，在每次替换前后都会进行，这就是规则 e。</span><span style="font-size: 18px">有了这个基础，再看下面这个例子，它更贴近真实场景：</span></p>
<pre class="language-c highlighter-hljs"><code>#define PP_COMMA() ,
#define PP_EMPTY()

#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
#define PP_CONCAT_IMPL(A, B) A##B

#define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)
#define PP_BOOL_0 0
#define PP_BOOL_1 1
#define PP_BOOL_2 1

#define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
#define PP_IF_1(THEN, ELSE) THEN
#define PP_IF_0(THEN, ELSE) ELSE

#define PP_COMMA_IF(N) PP_IF(N, PP_COMMA(), PP_EMPTY())
#define log(format, n, ...) printf(format PP_COMMA_IF(n) __VA_ARGS__)

log("%d%f", 2, 1, .2); 
log("hello", 0); </code></pre>
<p><span style="font-size: 18px">重点是 log 宏函数的实现，委托给了 printf，在格式 format 与参数 <code>__VA_ARGS__</code> 之间，要不要加个逗号做分隔，完全看用户传递的参数个数，大于 0 则需要，否则不需要，不然后期会出现编译期语法错误。</span></p>
<p><span style="font-size: 18px">这里为了简化例子，参数个数是用户手动传递的，参考上面的两个 case，分别有 2 个参数和 0 个参数。</span></p>
<p><span style="font-size: 18px">现在焦点就集中在 <code>PP_COMMA_IF</code> 宏的实现上了，它根据 n 的值，决定输出 PP_COMMA()，还是 PP_EMPTY()，这之前那一堆宏都是为了实现 PP_IF，看不懂也没关系。</span></p>
<p><span style="font-size: 18px">到这里似乎没有什么问题，然而编译却报错：</span></p>
<pre class="language-c highlighter-hljs"><code>&lt;source&gt;:20:1: error: macro 'PP_IF_1' passed 3 arguments, but takes just 2
   20 | log("%d%f", 2, 1, .2);
      | ^~~~~~~
&lt;source&gt;:13:9: note: macro 'PP_IF_1' defined here
   13 | #define PP_IF_1(THEN, ELSE) THEN
      |         ^~~~~~~
&lt;source&gt;:21:1: error: macro 'PP_IF_0' passed 3 arguments, but takes just 2
   21 | log("hello", 0);
      | ^~~~~~~
&lt;source&gt;:14:9: note: macro 'PP_IF_0' defined here
   14 | #define PP_IF_0(THEN, ELSE) ELSE
      |         ^~~~~~~</code></pre>
<p><span style="font-size: 18px">错误有点不知所云，列个表推理下宏展开过程，先看第一个 case：</span></p>
<table style="border-collapse: collapse; width: 98.7822%; height: 126px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 40.0617%; height: 21px">状态</td>
<td style="width: 59.9383%; height: 21px">应用宏</td>
</tr>
<tr style="height: 21px">
<td style="width: 40.0617%; height: 21px">log("%d%f", 2, 1, .2);&nbsp;</td>
<td style="width: 59.9383%; height: 21px">初始</td>
</tr>
<tr>
<td style="width: 40.0617%; height: 21px">printf(“%d%f" PP_COMMA_IF(2) 1, .2);</td>
<td style="width: 59.9383%; height: 21px">#define log(format, n, ...) printf(format PP_COMMA_IF(n) __VA_ARGS__)</td>
</tr>
<tr style="height: 21px">
<td style="width: 40.0617%; height: 21px">printf(“%d%f" PP_IF(2, PP_COMMA(), PP_EMPTY()) 1, .2);</td>
<td style="width: 59.9383%; height: 21px">#define PP_COMMA_IF(N) PP_IF(N, PP_COMMA(), PP_EMPTY())</td>
</tr>
<tr style="height: 21px">
<td style="width: 40.0617%; height: 21px">printf(“%d%f" PP_IF(2, , , ) 1, .2);</td>
<td style="width: 59.9383%; height: 21px">#define PP_COMMA() , 和 #define PP_EMPTY() 且 PP_IF 实现没有对参数 ## &amp; #</td>
</tr>
<tr style="height: 21px">
<td style="width: 40.0617%; height: 21px">报错</td>
<td style="width: 59.9383%; height: 21px">PP_IF 参数个数不匹配，需要 3 个，实际 4 个</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">推导显示是在 <code>PP_IF</code> 处报错，实际报错信息显示是 <code>PP_IF_1</code>，预处理器似乎走的更远，切换为 clang 看得更明白：</span></p>
<pre class="language-c highlighter-hljs"><code>clang++: warning: argument unused during compilation: '-S' [-Wunused-command-line-argument]
&lt;source&gt;:21:1: error: too many arguments provided to function-like macro invocation
   21 | log("%d%f", 2, 1, .2); 
      | ^
&lt;source&gt;:20:43: note: expanded from macro 'log'
   20 | #define log(format, n, ...) printf(format PP_COMMA_IF(n) __VA_ARGS__)
      |                                           ^
&lt;source&gt;:17:24: note: expanded from macro 'PP_COMMA_IF'
   17 | #define PP_COMMA_IF(N) PP_IF(N, PP_COMMA(), PP_EMPTY())
      |                        ^
&lt;source&gt;:12:70: note: expanded from macro 'PP_IF'
   12 | #define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)
      |                                                                      ^
&lt;source&gt;:14:9: note: macro 'PP_IF_1' defined here
   14 | #define PP_IF_1(THEN, ELSE) THEN
      |         ^
1 error generated.</code></pre>
<p><span style="font-size: 18px"><code>PP_COMMA()</code> 似乎是延迟到 <code>PP_IF_1</code> 中后才展开，这个和我的理解有 gap，有了解的大神还望不吝指点。</span></p>
<p><span style="font-size: 18px">不管怎么说，预扫描展开宏函数参数导致参数个数不匹配，导致了这个问题，而我们又不打算拼接参数或取字面量，所以无法通过规则 b 解决问题。</span></p>
<p><span style="font-size: 18px">好在传递给 <code>PP_IF</code> 的这两个参数，都是宏函数，这种场景下可以只传递宏函数名，括号放在 <code>PP_IF</code> 后，让宏函数在后扫描中再生效：</span></p>
<pre class="language-c highlighter-hljs"><code>#define PP_COMMA_IF(N) PP_IF(N, PP_COMMA, PP_EMPTY)()</code></pre>
<p><span style="font-size: 18px">这就是规则 c，现在能得到正确的结果了：</span></p>
<pre class="language-c highlighter-hljs"><code>printf("%d%f" , 1, .2);
printf("hello" );</code></pre>
<p><span style="font-size: 18px">下面仍为第一个 case 为例，推理下整个展开过程：</span></p>
<table style="border-collapse: collapse; width: 100%; height: 126px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">状态</td>
<td style="width: 49.149%; height: 21px">应用宏</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">log("%d%f", 2, 1, .2);&nbsp;</td>
<td style="width: 49.149%; height: 21px">初始</td>
</tr>
<tr>
<td style="width: 50.851%; height: 21px">printf(“%d%f" PP_COMMA_IF(2) 1, .2);</td>
<td style="width: 49.149%; height: 21px">#define log(format, n, ...) printf(format PP_COMMA_IF(n) __VA_ARGS__)</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“%d%f" PP_IF(2, PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%; height: 21px">#define PP_COMMA_IF(N) PP_IF(N, PP_COMMA, PP_EMPTY)()</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_CONCAT(PP_IF_, PP_BOOL(2))(PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%">#define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_CONCAT(PP_IF_, PP_CONCAT(PP_BOOL_, 2))(PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%">#define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_CONCAT(PP_IF_, PP_BOOL_2)(PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%">#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B) 和 #define PP_CONCAT_IMPL(A, B) A##B</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_CONCAT(PP_IF_, 1)(PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%">#define PP_BOOL_2 1</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_IF_1(PP_COMMA, PP_EMPTY)() 1, .2);</td>
<td style="width: 49.149%">#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B) 和 #define PP_CONCAT_IMPL(A, B) A##B</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“%d%f" PP_COMMA() 1, .2);</td>
<td style="width: 49.149%">#define PP_IF_1(THEN, ELSE) THEN</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“%d%f" , 1, .2);</td>
<td style="width: 49.149%; height: 21px">#define PP_COMMA() ,</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“%d%f" , 1, .2);</td>
<td style="width: 49.149%; height: 21px">无可替换符号，结束</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">出于练习目的，再看下第二个 case：</span></p>
<table style="border-collapse: collapse; width: 100%; height: 126px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">状态</td>
<td style="width: 49.149%; height: 21px">应用宏</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">log("hello", 0);&nbsp;</td>
<td style="width: 49.149%; height: 21px">初始</td>
</tr>
<tr>
<td style="width: 50.851%; height: 21px">printf(“hello" PP_COMMA_IF(0) );</td>
<td style="width: 49.149%; height: 21px">#define log(format, n, ...) printf(format PP_COMMA_IF(n) __VA_ARGS__)</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“hello" PP_IF(0, PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%; height: 21px">#define PP_COMMA_IF(N) PP_IF(N, PP_COMMA, PP_EMPTY)()</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_CONCAT(PP_IF_, PP_BOOL(0))(PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%">#define PP_IF(PRED, THEN, ELSE) PP_CONCAT(PP_IF_, PP_BOOL(PRED))(THEN, ELSE)</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_CONCAT(PP_IF_, PP_CONCAT(PP_BOOL_, 0))(PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%">#define PP_BOOL(N) PP_CONCAT(PP_BOOL_, N)</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_CONCAT(PP_IF_, PP_BOOL_0)(PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%">#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B) 和 #define PP_CONCAT_IMPL(A, B) A##B</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_CONCAT(PP_IF_, 0)(PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%">#define PP_BOOL_0 0</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_IF_0(PP_COMMA, PP_EMPTY)() );</td>
<td style="width: 49.149%">#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B) 和 #define PP_CONCAT_IMPL(A, B) A##B</td>
</tr>
<tr>
<td style="width: 50.851%">printf(“hello" PP_EMPTY() 1, .2);</td>
<td style="width: 49.149%">#define PP_IF_0(THEN, ELSE) ELSE</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“hello"&nbsp;&nbsp; );</td>
<td style="width: 49.149%; height: 21px">#define PP_EMPTY()</td>
</tr>
<tr style="height: 21px">
<td style="width: 50.851%; height: 21px">printf(“hello"&nbsp; );</td>
<td style="width: 49.149%; height: 21px">无可替换符号，结束</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 18px">其实主要区别就是 <code>PP_IF_1</code> 与 <code>PP_IF_0</code> 选择 <code>PP_COMMA</code> 还是 <code>PP_EMPTY</code> 的问题。将预扫描变为后扫描，是惰性求值的关键。</span></p>
<h1><span style="font-size: 18px">宏 VS 模板元</span></h1>
<p><span style="font-size: 18px">与模板元编程相比，由于规则 a.ii 宏无法递归和重入，要想支持多个参数，必需老老实实先写 N 个 #define，比较笨。反过来的好处是，他不会生成编译实体，对于控制代码体积有帮助。<br></span></p>
<p><span style="font-size: 18px">最后借用 BOT Man 的话对两者做个总结：<br></span></p>
<p>C++ <strong>模板元编程</strong> <em>(template metaprogramming)</em> 虽然功能强大，但也有 <strong>局限性</strong>：</p>
<ul>
<li>不能通过 模板展开 生成新的 <strong>标识符</strong> <em>(identifier)</em>
<ul>
<li>例如 生成新的 函数名、类名、名字空间名 等</li>
<li>使用者 只能使用 预先定义的标识符</li>
</ul>
</li>
<li>不能通过 模板参数 获取 <strong>符号/标记</strong> <em>(token)</em> 的 <strong>字面量</strong> <em>(literal)</em>
<ul>
<li>例如 在反射中获取 实参参数名的字面量，在断言中获取 表达式的字面量</li>
<li>使用者 只能通过 传递字符串参数 绕开</li>
</ul>
</li>
</ul>
<p>所以，在需要直接 <strong>操作标识符</strong> 的情况下，还需要借助 <strong>宏</strong>，进行 <strong>预处理阶段的元编程</strong>：</p>
<ul>
<li>和 <strong>编译时</strong> <em>(compile-time)</em> 的 <strong>模板</strong> 展开不同，<strong>宏</strong> 在编译前的 <a href="https://en.cppreference.com/w/cpp/preprocessor" rel="noopener nofollow"><strong>预处理</strong> <em>(preprocess)</em></a> 阶段全部展开 —— 狭义上，编译器 看不到且不处理 宏代码</li>
<li>通过 <code>#define</code>/<code>TOKEN1##TOKEN2</code>/<code>#TOKEN</code> 定义 <strong>宏对象</strong> <em>(object-like macro)</em> 和 <strong>宏函数</strong> <em>(function-like macro)</em>，可以实现 <a href="https://en.cppreference.com/w/cpp/preprocessor/replace" rel="noopener nofollow">替换文本、拼接标识符、获取字面量</a> 等功能</li>
</ul>
<p><span style="font-size: 18px">总结一下就是<strong>：各有所长、结合使用</strong>。</span></p>
<h1><span style="font-size: 18px">总结</span></h1>
<p><span style="font-size: 18px">BOT Man 主要介绍的是 Mock PP 库，它是 Boost PP 库的精减版，后者有更为强大的代码生成能力，感兴趣的读者可以进一步探索，这里只举几个例子：</span></p>
<pre class="language-cpp highlighter-hljs"><code>// case 1
#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;
#define DECL(z, n, text) text ## n = n;
BOOST_PP_REPEAT(5, DECL, int x)
---
int x0 = 0; int x1 = 1; int x2 = 2; int x3 = 3; int x4 = 4;

// case 2
#include &lt;boost/preprocessor/repetition/enum_params.hpp&gt; 
template &lt;BOOST_PP_ENUM_PARAMS(3, class T)&gt;
struct a{};
---
template &lt; class T0 , class T1 , class T2&gt;
struct a{};

// case 3
#include &lt;boost/preprocessor/arithmetic/inc.hpp&gt;
#include &lt;boost/preprocessor/repetition/enum_params.hpp&gt;
#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;

#define MACRO(z, n, _) \
return_type constructor(\
            BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(n),type param))\
{;};

BOOST_PP_REPEAT(2, MACRO, nil)
---
return_type constructor(type param0) { ; };
return_type constructor(type param0, type param1) { ; };

// case 4
#include &lt;boost/preprocessor/arithmetic/inc.hpp&gt;
#include &lt;boost/preprocessor/repetition/enum.hpp&gt;

#define TEXT(z, n, text) text
#define TTP(z, n, _) \
   template&lt;  BOOST_PP_ENUM_ ## z(BOOST_PP_INC(n), TEXT, class)  &gt; \
   class T ## n 
BOOST_PP_ENUM(3, TTP, nil)
---
template &lt;class&gt; class T0 ,
template &lt;class, class&gt; class T1 ,
template &lt;class, class, class&gt; class T2
    
// case 5
#define n BOOST_PP_ITERATION()
#define TINY_print(z, n, data) data

template&lt;BOOST_PP_ENUM_PARAMS(n, class T)&gt;
struct tiny_size&lt; BOOST_PP_ENUM_PARAMS(n, T) BOOST_PP_COMMA_IF(n) BOOST_PP_ENUM(BOOST_PP_SUB(M, n), TINY_print, none)&gt;
: mpl::int_ &lt;n&gt;
{

};

#undef n

// case 5.1
#include &lt;boost/preprocessor/repetition.hpp&gt;
#include &lt;boost/preprocessor/arithmetic/sub.hpp&gt;
#include &lt;boost/preprocessor/punctuation/comma_if.hpp&gt;
#include &lt;boost/preprocessor/iteration/iterate.hpp&gt;

#define M 3

#define BOOST_PP_ITERATION_LIMITS (0,M-1)
#define BOOST_PP_FILENAME_1       "pattern.h"
#include BOOST_PP_ITERATE()
---
template&lt;&gt;
struct tiny_size&lt; none , none , none&gt;
: mpl::int_ &lt;0&gt;
{
};
template&lt; class T0&gt;
struct tiny_size&lt; T0 , none , none&gt;
: mpl::int_ &lt;1&gt;
{
};
template&lt; class T0 , class T1&gt;
struct tiny_size&lt; T0 , T1 , none&gt;
: mpl::int_ &lt;2&gt;
{
};</code></pre>
<p><span style="font-size: 18px">看看有没有满足你需求的 (我也没看懂原理，库嘛，拿来用就好了)。</span></p>
<h1>参考</h1>
<p><span style="font-size: 18px">[1].&nbsp;<a href="https://saferules.github.io/index.html#precompile" target="_blank" rel="noopener nofollow">360 安全规则集合</a></span></p>
<p><span style="font-size: 18px">[2].&nbsp;<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2015-12-03 22:08" href="https://www.cnblogs.com/findumars/p/5017820.html"><span role="heading" aria-level="2">C++ 下 typeof 的实现</span></a></span></p>
<p><span style="font-size: 18px">[3]. <a href="https://en.cppreference.com/w/cpp/preprocessor/replace" target="_blank" rel="noopener nofollow">Replacing text macros</a></span></p>
<p><span style="font-size: 18px">[4]. <a href="https://bot-man-jl.github.io/articles/?post=2020/Macro-Programming-Art" target="_blank" rel="noopener nofollow">C/C++ 宏编程的艺术</a></span></p>
<p><span style="font-size: 18px">[5]. </span><a class="u-url url" href="https://www.cppmore.com/2023/09/27/generative-metaprogramming-chapter1/" rel="noopener nofollow"><span style="font-size: 18px">《产生式元编程》第一章 宏编程计数引原理</span></a></p>
<p><span style="font-size: 18px">[6].&nbsp;<a href="https://gcc.gnu.org/onlinedocs/cpp/Self-Referential-Macros.html" target="_blank" rel="noopener nofollow">Self-Referential Macros</a></span></p>
<p><span style="font-size: 18px">[7].&nbsp;<a href="https://bingoli.github.io/2019/04/04/macro-char-to-wchar/" target="_blank" rel="noopener nofollow">使用C++宏嵌套实现窄字符转换为宽字符</a></span></p>
<p><span style="font-size: 18px">[8].&nbsp;<a href="https://zhuanlan.zhihu.com/p/352710851" target="_blank" rel="noopener nofollow">Boost Preprocessor (PP库) 中的奇技淫巧</a></span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/goodcitizen/" target="_blank">goodcitizen</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/goodcitizen/p/18655303/macro_knowledges_what_you_dont_know" target="_blank">https://www.cnblogs.com/goodcitizen/p/18655303/macro_knowledges_what_you_dont_know</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.15415564221527778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 10:43">2025-01-20 10:43</span>&nbsp;
<a href="https://www.cnblogs.com/goodcitizen">goodcitizen</a>&nbsp;
阅读(<span id="post_view_count">83</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18655303" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18655303);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18655303', targetLink: 'https://www.cnblogs.com/goodcitizen/p/18655303/macro_knowledges_what_you_dont_know', title: '你所不知道的 C/C++ 宏知识——基于《C/C++ 宏编程的艺术》' })">举报</a>
</div>
        