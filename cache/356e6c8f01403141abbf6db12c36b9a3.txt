
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nanyanxin/p/18678902" title="发布于 2025-01-18 21:55">
    <span role="heading" aria-level="2">3 运输层</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="3-运输层">3 运输层</h1>
<h2 id="31-概述">3.1 概述</h2>
<p>运输层：为运行在不同主机上的应用<strong>进程</strong>之间提供了<strong>逻辑通信（logical communication）</strong>功能。</p>
<p>（网络层：提供了<strong>主机</strong>之间的逻辑通信）</p>
<p>运输层分组（数据传输单元）：<strong>报文段（segment）</strong>。</p>
<p>运输层协议：在<strong>端系统</strong>（而不是路由器）中实现，负责将来自应用程序的报文移动到网络边缘（网络层），或将网络层的数据报分发给各个进程端口，即多路复用与多路分解（基本服务）。</p>
<ul>
<li>TCP：可靠传输服务、面向连接的服务、流量控制、拥塞控制</li>
<li>UDP：进程到进程的数据交付（不可靠、无连接）、差错检查</li>
</ul>
<p>基于不同运输层协议的应用层协议</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213458296-274335519.png" alt="" loading="lazy"></p>
<h2 id="32-多路复用与多路分解">3.2 多路复用与多路分解</h2>
<p><strong>多路复用（multiplexing）</strong>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（用于分解）生成报文段，然后将报文段传递到网络层。</p>
<p><strong>多路分解（demultiplexing）</strong>：将运输层中的数据交付到正确的套接字。</p>
<p>要求：</p>
<ul>
<li>套接字有唯一标识符（一个进程可以有多个套接字）。</li>
<li>报文段中有字段（源端口号、目的端口号）用于指示该报文段要交付到的套接字。</li>
</ul>
<p>通常，应用程序的客户端让运输层自动地（透明地）分配端口号，服务器端分配一个特定的端口号。</p>
<h3 id="321-无连接的多路复用与多路分解">3.2.1 无连接的多路复用与多路分解</h3>
<p>UDP套接字标识：<strong>二元组（目的IP地址，目的端口号）</strong></p>
<p>不同源进程的报文段到达同一目的进程使用同一套接字。</p>
<h3 id="322-面向连接的多路复用与多路分解">3.2.2 面向连接的多路复用与多路分解</h3>
<p>TCP套接字标识：<strong>四元组（源IP地址，源端口号，目的IP地址，目的端口号）</strong></p>
<p>不同源进程的报文段到达同一目的进程使用不同套接字。</p>
<p>Web服务器使用端口号的方法：</p>
<ul>
<li>为每一个用户连接创建一个具有新套接字的新进程。</li>
<li>只使用一个进程，为每个用户连接创建一个具有新套接字的新线程。</li>
</ul>
<h2 id="33-udp">3.3 UDP</h2>
<p>UDP（User Datagram Protocol，用户数据报协议）</p>
<p><strong>工作流程</strong></p>
<ul>
<li>UDP从应用程序得到数据，附加上首部字段，交付给网络层。</li>
<li>网络层将该运输层报文段封装到一个IP数据报中，尽力而为将其交付给接收主机。</li>
<li>若报文段到达接收主机，UDP将报文段中的数据交付给目的端口号对应的套接字。</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><strong>无连接</strong>：发送报文段之前，发送方和接收方的运输层实体没有握手。</li>
<li><strong>不可靠</strong>：提供差错检测，但无法进行恢复（<strong>丢弃受损报文段</strong>或<strong>交给应用程序并发出警告</strong>）。
<ul>
<li>注：使用UDP的应用仍可以通过在应用程序自身建立可靠性机制实现可靠数据传输。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>关于发送什么数据以及何时发送数据的应用层控制更为精细：TCP的拥塞控制机制可能遏制TCP发送方。</li>
<li>无须建立连接：建立TCP连接需要进行三次握手，时延较大。</li>
<li>无连接状态：不需要在端系统中维护连接状态（接受和发送缓存、拥塞控制参数、序号与确认号参数）。</li>
<li>分组首部开销小：仅8B，TCP报文段首部为20B+。</li>
</ul>
<p><strong>UDP报文段结构</strong></p>
<ul>
<li>首部（8B）：源端口号（16b）、目的端口号（16b）、长度（首部+数据，16b）、检验和（16b）</li>
<li>应用数据（报文）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213521234-1529220784.png" alt="" loading="lazy"></p>
<p><strong>检验和（checksum）</strong></p>
<ul>
<li>在发送端，计算所有16bits字（除检验和字段）的检验和，填写在报文段的检验和字段。</li>
<li>在接收端，计算所有16bits字（包括检验和字段）的检验和，若没有差错，则结果为全1（1111111111111111）。</li>
</ul>
<p>计算方法：</p>
<ul>
<li>对两个16bits字做二进制加法，若有溢出（结果&gt;16位），则将溢出部分与剩余部分做二进制加法，最终得到一个新的16bits字。</li>
<li>将得到的结果与第三个字做相同操作，以此类推，将所有字相加。</li>
<li>将最终结果按位取反（反码），即可得到检验和。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213607759-1324432723.png" alt="" loading="lazy"></p>
<h2 id="34-可靠数据传输原理">3.4 可靠数据传输原理</h2>
<h3 id="341-可靠数据传输协议reliable-data-transfer-protocolrdt">3.4.1 可靠数据传输协议（reliable data transfer protocol，rdt）</h3>
<ol>
<li>
<p><strong>经完全可靠信道的可靠数据传输</strong></p>
<p>rdt1.0：</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213619396-1517212138.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>rdt_send(data)：接收到上层协议传入的数据data</p>
</li>
<li>
<p>make_pkt(data)：将data打包成分组</p>
</li>
<li>
<p>udt_send(packet)：将分组packet发送到信道中</p>
</li>
<li>
<p>rdt_rcv(packet)：接收到下层协议传入的数据data</p>
</li>
<li>
<p>extract(packet, data)：从分组packet中取出数据</p>
</li>
<li>
<p>deliver_data(data)：将数据data上传给上层协议</p>
</li>
</ul>
</li>
<li>
<p><strong>经具有比特差错信道的可靠数据传输</strong></p>
<p>rdt2.0：</p>
<p><strong>自动重传请求（Automatic Repeat reQuest，ARQ）协议</strong>：<strong>停等（stop-and-wait）</strong>协议（发送方处于等待ACK和NAK的状态时，不能从上层获得更多的数据）</p>
<ul>
<li>
<p>差错检测：使用检验和等差错检测和纠错技术。</p>
</li>
<li>
<p>接收方反馈：若经过检测发现分组正确，则发送肯定确认ACK；若分组受损，则发送否定确认NAK。</p>
</li>
<li>
<p>重传：若发送方收到了NAK，则要重传分组。</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213634762-306443791.png" alt="" loading="lazy"></p>
<ul>
<li>make_pkt(data, checksum)：为提供差错检测服务，发送方在生成分组时应携带检验和或其他额外比特</li>
<li>make_pkt(ACK/NAK)：创建ACK/NAK分组</li>
<li>isNAK(rcvpkt)：判定rcvpkt是一个NAK</li>
<li>isACK(rcvpkt)：判定rcvpkt是一个ACK</li>
<li>corrupt(rcvpkt)：判定rcvpkt受损</li>
<li>notcorrupt(rcvpkt)：判定rcvpkt正确</li>
</ul>
<p>rdt2.1：</p>
<ul>
<li>
<p>ACK和NAK有可能受损：一旦发送方收到含糊不清的ACK或NAK时，只需重传当前数据分组即可（引入了冗余分组（duplicate packet），接收方无法判定接收到的分组是新的分组还是重传的分组）。</p>
</li>
<li>
<p><strong>序号（sequence number）</strong>字段：发送方为每个分组分配一个序号，放在分组首部的序号字段中，接收方只需检查序号即可确定收到的分组是否为重传（接收方只要收到了连续两个序号相同的分组，就证明这是一个重传，发送方没有正确接收接收方的ACK或接收到了NAK）。</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213648897-792201015.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213700160-427553796.png" alt="" loading="lazy"></p>
<ul>
<li>make_pkt(seq, data, checksum)：加入序号字段（seq=0/1）</li>
<li>make_pkt(ACK/NAK, checksum)：在ACK/NAK分组中加入检验和字段</li>
<li>has_seq0/1(rcvpkt)：判定收到的rcvpkt的序号是0/1</li>
</ul>
<p>rdt2.2：</p>
<ul>
<li>无NAK：在ACK分组中加入序号字段。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213712294-425435384.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213722042-826850233.png" alt="" loading="lazy"></p>
<ul>
<li>make_pkt(ACK, seq, checksum)：在ACK分组中加入序号字段，表明收到了seq=0/1的分组</li>
<li>is_ACK(rcvpkt, seq)：发送方收到了接收方对seq=0/1的分组的肯定确认</li>
</ul>
</li>
<li>
<p><strong>经具有比特差错的丢包信道的可靠数据传输</strong></p>
<p>rdt3.0：</p>
<p><strong>倒计时定时器（countdown timer）</strong>：每次发送一个分组（新分组和重传分组）时，发送方启动一个定时器；超时（timeout）时，重传分组并重启定时器；接收到正确ACK后，终止定时器。</p>
<p><strong>比特交替协议（alternating-bit protocol）</strong>：rdt3.0的分组序号在0和1之间交替，故被称为比特交替协议。</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213733233-1066057043.png" alt="" loading="lazy"></p>
<p>rdt3.0接收方的FSM（有限状态机）与rdt2.2接收方相同</p>
<ul>
<li>start_timer/stop_timer：启动/重启/终止定时器</li>
<li>timeout：超时</li>
</ul>
</li>
</ol>
<h3 id="342-流水线pipeline可靠数据传输协议">3.4.2 流水线（pipeline）可靠数据传输协议</h3>
<p>rdt3.0的性能问题：停等（stop-and-wait）</p>
<p><strong>流水线（pipeline）</strong>：允许发送方发送多个分组而无需等待确认。</p>
<ul>
<li>增加序号范围：每个传输中的分组必须有唯一的序号。</li>
<li>发送缓存和接收缓存：发送方要缓存已发送但未确认的分组，接收方可能也要缓存已正确接收的分组。</li>
</ul>
<h4 id="3421-回退n步go-back-ngbn">3.4.2.1 回退N步（Go-Back-N，GBN）</h4>
<p><strong>发送方看到的GBN协议序号范围</strong></p>
<ul>
<li>窗口长度N：流水线中未确认的分组数不能超过N，GBN协议也称为<strong>滑动窗口协议（sliding-window protocol）</strong>。</li>
<li>基序号（base）：最早未确认分组的序号。</li>
<li>下一个序号（nextseqnum）：最小的未使用序号（下一个待发分组序号）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213750258-1075875160.png" alt="" loading="lazy"></p>
<p><strong>发送方需要响应的事件</strong></p>
<ul>
<li>上层的调用：先检查发送窗口是否已满，若未满，则生成分组并发送，然后更新相关变量；若已满，则将数据返回给上层/缓存数据/仅在窗口未满时允许上层调用。若发送的分组序号等于基序号（最早的已发送但未确认分组），则启动定时器。</li>
<li>收到ACK：若收到ACK但仍有未确认分组，则重启定时器；若无未确认分组，则终止定时器。</li>
<li>超时：重传所有已发送但未确认的分组。启动定时器。</li>
</ul>
<p><strong>接收方的操作</strong></p>
<ul>
<li>接收方对序号为n的分组的确认采用<strong>累积确认（cumulative acknowledgment）</strong>，表明接收方正确接收到序号为n及n以前的所有分组。</li>
<li>若正确接收一个按序分组n，则发送ACK n；若接收到失序分组，则丢弃该分组（该分组将因超时被重传），无需缓存任何失序分组，继续发送上一个ACK。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213804762-623271779.png" alt="" loading="lazy"></p>
<h4 id="3422-选择重传selective-repeatsr">3.4.2.2 选择重传（Selective Repeat，SR）</h4>
<p>GBN的缺点：大量<strong>不必要重传的分组</strong>可能充斥整条流水线。</p>
<p><strong>选择重传</strong>：发送方仅重传那些它怀疑在接收方出错（丢失/受损）的分组，从而避免不必要的重传。</p>
<p>接收方采用<strong>选择确认（selective acknowledgment）</strong>对正确接收的分组进行确认：确认所有正确接收的分组，不论其是否按序。失序的分组将被缓存，直到它前面的所有分组都被正确接收为止，它才会被按序交付给上层。</p>
<p><strong>SR中发送方和接收方看到的窗口是不同的</strong>：若序号空间过小，则接收方无法确定收到的分组是新的还是重传的，序号空间大小必须大于等于窗口长度的二倍。</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213821496-428856976.png" alt="" loading="lazy"></p>
<p><strong>发送方的操作</strong></p>
<ul>
<li>从上层收到数据：发送方检查下一个可用序号是否在窗口内，若在，则生成分组并发送；否则，返回上层或缓存数据。</li>
<li>超时：每个分组拥有自己的逻辑定时器，用定时器防止丢包。</li>
<li>收到ACK：若ACK序号在窗口内，则将该分组标记为已接收，若序号等于基序号（send_base），则窗口前移至基序号等于最小未确认分组序号处。</li>
</ul>
<p><strong>接收方的操作</strong></p>
<ul>
<li>正确接收窗口内的分组n：发送ACK n，若该分组没收到过，则缓存该分组，若分组序号等于基序号（rcv_base），则将该分组及其连续分组交付给上层，并将窗口前移至基序号等于最小未接收分组序号处。</li>
<li>正确接收前一个窗口内的分组n：发送ACK n。</li>
<li>其他：忽略该分组。</li>
</ul>
<h2 id="35-tcp面向连接可靠传输流量控制">3.5 TCP：面向连接、可靠传输、流量控制</h2>
<h3 id="351-面向连接connection-oriented">3.5.1 面向连接（connection-oriented）</h3>
<p><strong>连接（connection）</strong></p>
<ul>
<li>是一条逻辑连接：共同状态仅保留在两个通信端系统的TCP程序中，不是一条物理电路。</li>
<li>全双工（full-duplex）：数据可以在两个进程间相互流动。</li>
<li>点对点（point-to-point）：单个发送方对单个接收方，不能多播（一对多）。</li>
<li>组成：两台主机中的发送缓存和接收缓存、进程的套接字、变量。</li>
</ul>
<p>建立连接——<strong>三次握手（three-way handshake）</strong></p>
<ul>
<li>客户向服务器发起连接：发送一个特殊的TCP报文段（SYN segment），其中字段SYN=1，随机选择一个初始序号（client_isn）放置于序号字段，不包含应用层数据。</li>
<li>服务器向客户表示允许：服务器为该连接分配缓存和变量，并发送允许报文段（SYNACK segment），其中字段SYN=1，确认号字段=client_isn+1，随机选择一个初始序号（server_isn）放置于序号字段，不包含应用层数据。</li>
<li>客户向服务器确认收到：客户为该连接分配缓存和变量，并发送一个报文段，其中字段SYN=0，确认号字段=server_isn+1，序号字段=client_isn+1，可以包含应用层数据。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213843022-1430243698.png" alt="" loading="lazy"></p>
<p>关闭连接——<strong>四次挥手（four-way wavehand）</strong></p>
<p>假设客户（服务器也可以发起关闭连接）决定关闭连接</p>
<ul>
<li>
<p>客户通知服务器关闭连接：发送一个特殊的TCP报文段，其中字段FIN=1。</p>
</li>
<li>
<p>服务器确认收到：发送响应TCP报文段，其中字段FIN=0，ACK=1。</p>
<p>（服务器等待一段时间，直到所有报文传输完毕再告知客户关闭连接）</p>
</li>
<li>
<p>服务器告知客户关闭连接：发送一个特殊的TCP报文段，其中字段FIN=1。</p>
</li>
<li>
<p>客户确认收到：发送响应TCP报文段，其中字段FIN=0，ACK=1。</p>
<p>（客户等待一段时间，若确认报文丢失，则重传确认报文，直到没有一段时间内没有服务器传来的报文，释放资源；服务器一旦收到客户的确认报文，则释放资源）</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213854362-222940748.png" alt="" loading="lazy"></p>
<h3 id="352-可靠传输reliable-transfer">3.5.2 可靠传输（reliable transfer）</h3>
<p><strong>TCP报文段结构</strong></p>
<ul>
<li>
<p>源端口号（16b）/目的端口号（16b）</p>
</li>
<li>
<p><strong>序号</strong>（32b）：报文段首字节的字节流编号</p>
</li>
<li>
<p><strong>确认号</strong>（32b）：表示接收方期望收到的下一字节的序号，因此TCP是提供累积确认的</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213910937-865219773.png" alt="" loading="lazy"></p>
</li>
<li>
<p>首部长度（4b）：首部中有不定长的选项字段（options），当其为空时，首部长度为20B</p>
</li>
<li>
<p>SYN（1b）/FIN（1b）：连接管理</p>
</li>
<li>
<p>接收窗口（16b）：流量控制</p>
</li>
<li>
<p>检验和（16b）：差错检测</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213921130-648495388.png" alt="" loading="lazy"></p>
<p><strong>往返时间与超时间隔</strong></p>
<ul>
<li>往返时间（RTT）：从一个报文段发出到它被确认的时间</li>
<li><strong>超时间隔（TimeoutInterval）</strong>：必须大于该连接的往返时间</li>
<li><strong>样本RTT（SampleRTT）</strong>：测得的一个实际RTT，但不测量重传报文段的样本RTT</li>
<li><strong>估算RTT（EstimatedRTT）</strong>：样本RTT的<strong>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</strong></li>
<li><strong>RTT偏差（DevRTT）</strong>：样本RTT偏离估算RTT的程度</li>
</ul>
<p>一旦测得了一个新的SampleRTT，TCP根据以下公式更新EstimatedRTT和DevRTT，其中 α 推荐值为 0.125，β 推荐值为 0.25<br>
$$<br>
EstimatedRTT=(1-\alpha)\ EstimatedRTT+\alpha \ SampleRTT<br>
$$<br>
$$<br>
DevRTT=(1-\beta)\ DevRTT+\beta\ |SampleRTT-EstimatedRTT|<br>
$$<br>
若已知EstimatedRTT和DevRTT，可由以下公式得出TimeoutInterval的值，其中推荐的初始TimeoutInterval值为1s<br>
$$<br>
TimeoutInterval=EstimatedRTT+4\ DevRTT<br>
$$<br>
<strong>可靠数据传输</strong></p>
<pre><code>/* 假定发送方不受流量控制和拥塞控制的限制，来自上层的数据长度小于MSS（最大报文段长度），且数据传输单向进行 */

NextSeqNum=InitialSeqNumber
SendBase=InitialSeqNumber

loop (forever) {
	switch(event)
	
		event: data received from application above
			create TCP segment with sequence number NextSeqNum
			if (timer currently not running)
				start timer
			pass segment to IP
			NextSeqNum=NextSeqNum+length(data)
			break;
			
		event: timer timeout
			retransmit not-yet-acknowledged segment with smallest sequence number
			start timer
			break;
			
		event: ACK received, with ACK field value of y
			if (y &gt; SendBase) { //累积确认
				SendBase=y
				if (there are currently any not-yet-acknowledged segments)
					start timer
			}
			break;
			
} /* end of loop forever */
</code></pre>
<ul>
<li>
<p>发送方不会重传序号小于收到的ACK号的任何报文段。</p>
</li>
<li>
<p>若发生重传，则TCP将下一次超时间隔设置为原值的2倍，而不使用EstimatedRTT和DevRTT推算的值，这种修改提供了一个形式受限的拥塞控制。</p>
</li>
<li>
<p><strong>快速重传（fast retransmit）</strong></p>
<ul>
<li>长超时周期迫使发送方延迟重传丢失的分组，增加了端到端时延。</li>
<li>机制：收到<strong>三个冗余ACK</strong>（即<strong>连续出现四个相同的ACK</strong>），则快速重传序号为ACK的确认号的分组。</li>
<li>可以使用以下伪代码替换上述循环分支中的第三个事件：</li>
</ul>
<pre><code>event: ACK received, with ACK field value of y
	if (y &gt; SendBase) {
		SendBase=y
		if (there are currently any not yet acknowledged segments)
 			start timer
 	}
	else {/* a duplicate ACK for already ACKed segment */
		increment number of duplicate ACKs received for y
		if (number of duplicate ACKS received for y==3)
			/* TCP fast retransmit */
			resend segment with sequence number y
	}
	break;
</code></pre>
</li>
</ul>
<h3 id="353-流量控制flow-control">3.5.3 流量控制（flow-control）</h3>
<p><strong>流量控制</strong>：使发送方的发送速率与接收方的读取速率相匹配，消除发送方使接收方缓存溢出的可能性。</p>
<ul>
<li>rwnd（receive window，接收窗口）：发送方维护这一变量，表示接收方还有多少可用的缓存空间。</li>
<li>RcvBuffer（接收方的接收缓存）</li>
<li>LastByteRead（接收方从缓存读取的最后一个字节编号）</li>
<li>LastByteRcvd（接收方接收到并放入缓存的最后一个字节编号）</li>
<li>LastByteSend（发送方已发送的最后一个字节编号）</li>
<li>LastByteAcked（发送方收到确认的最后一个字节编号）</li>
</ul>
<p><strong>接收方</strong>通过以下公式计算出当前rwnd值，并将其放入发给发送方的报文段的接收窗口字段中<br>
$$<br>
LastByteRcvd-LastByteRead\leq RcvBuffer<br>
$$<br>
$$<br>
rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]<br>
$$<br>
<strong>发送方</strong>通过以下公式确保未确认的数据量不大于接收方的接收窗口<br>
$$<br>
LastByteSend-LastByteAcked\leq rwnd<br>
$$<br>
当接收方rwnd=0时，发送方继续发送只有一个字节数据的报文段，接收方将会确认这些报文段。直至接收方rwnd&gt;0，它将发送一个包含非零rwnd值的确认报文段，此时接收方可以继续传输数据。</p>
<h2 id="36-拥塞控制原理">3.6 拥塞控制原理</h2>
<p><strong>流量控制（flow-control）</strong>：使发送方的发送速率与接收方的读取速率相匹配，消除发送方使接收方缓存溢出的可能性。</p>
<p><strong>拥塞控制（congestion control）</strong>：TCP发送方因IP网络拥塞而被遏制，防止发送方在网络拥塞时发送大量数据致使网络更加拥塞（路由器缓存溢出）。</p>
<p><strong>网络拥塞代价</strong></p>
<ul>
<li>分组到达速率接近链路容量时，分组经历巨大的排队时延。</li>
<li>发送方必须重传分组，以补偿因缓存溢出而被丢弃的分组，在遇到大时延时，发送方可能会进行不必要的重传，使拥塞更加严重。</li>
<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量被浪费掉了。</li>
</ul>
<p><strong>拥塞控制方法</strong></p>
<ul>
<li>端到端拥塞控制：TCP通过<strong>超时</strong>和<strong>三个冗余ACK</strong>得知网络可能拥塞（还可能通过增加的往返时延得知拥塞的程度），从而<strong>减小拥塞窗口长度</strong>，进行端到端拥塞控制。</li>
<li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息。</li>
</ul>
<h2 id="37-tcp拥塞控制">3.7 TCP：拥塞控制</h2>
<p>拥塞窗口（congestion window，cwnd）：发送方中未确认的数据量小于等于min(cwnd, rwnd)</p>
<p>简化：仅考虑接收缓存足够大的情况（忽略rwnd的限制）</p>
<p>发送方的发送速率约等于cwnd/RTT</p>
<p>发送方判定丢包（网络拥塞）：<strong>超时</strong>、<strong>三个冗余ACK</strong></p>
<p><strong>TCP拥塞控制算法</strong></p>
<ul>
<li>
<p><strong>慢启动（slow start）</strong></p>
<ul>
<li>
<p>初始化cwnd值为1个<strong>MSS（最大报文段长度）</strong></p>
</li>
<li>
<p>每当已发送的报文段首次被确认，cwnd = cwnd + MSS，因此慢启动状态cwnd呈指数增长</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118213953961-732268341.png" alt="" loading="lazy"></p>
</li>
<li>
<p>超时：ssthresh = cwnd / 2（ssthresh为慢启动阈值），cwnd = 1MSS</p>
</li>
<li>
<p>达到阈值ssthresh：进入<strong>拥塞避免</strong>状态</p>
</li>
<li>
<p>检测到三个冗余ACK：ssthresh = cwnd / 2，cwnd = cwnd + 3MSS，执行<strong>快速重传</strong>，然后进入<strong>快速恢复</strong>状态</p>
</li>
</ul>
</li>
<li>
<p><strong>拥塞避免（congestion avoidance）</strong></p>
<ul>
<li>每经过一个RTT，cwnd = cwnd + MSS，cwnd呈线性增长（实现：每收到一个新的确认，cwnd = cwnd + MSS (MSS / cwnd) ）</li>
<li>超时：ssthresh = cwnd / 2，cwnd = 1MSS，进入<strong>慢启动</strong>状态</li>
<li>检测到三个冗余ACK：ssthresh = cwnd / 2，cwnd = cwnd + 3MSS，执行<strong>快速重传</strong>，然后进入<strong>快速恢复</strong>状态</li>
</ul>
</li>
<li>
<p><strong>快速恢复（fast recovery）</strong></p>
<ul>
<li>
<p>每再次收到一个冗余ACK，cwnd = cwnd + MSS，cwnd呈指数增长</p>
</li>
<li>
<p>当收到需要的ACK，cwnd = ssthresh，进入<strong>拥塞避免</strong>状态</p>
</li>
<li>
<p>超时：ssthresh = cwnd / 2，cwnd = 1MSS，进入<strong>慢启动</strong>状态</p>
</li>
<li>
<p>快速恢复是TCP推荐的而非必需的构件：Reno版TCP在收到三个冗余ACK时使用快速恢复，超时时进入慢启动状态，而Tahoe版TCP在超时和收到三个冗余ACK时均进入慢启动状态</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118214008460-855748168.png" alt="" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p>FSM</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118214021090-85055763.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>加性增、乘性减（Additive-Increase Multiplicative-Decrease，ACMD）</strong></p>
<ul>
<li>忽略一条连接开始时的慢启动状态，假定丢包由三个冗余ACK而不是超时指示</li>
<li>拥塞避免状态中，每经过1个RTT，cwnd增加1个MSS，即线性（加性）增加</li>
<li>检测到三个冗余ACK时，cwnd减半，即乘性减</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250118214033064-1714572402.png" alt="" loading="lazy"></p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.012365576361111111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 22:05">2025-01-18 21:55</span>&nbsp;
<a href="https://www.cnblogs.com/nanyanxin">nanyanxin</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678902" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678902);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678902', targetLink: 'https://www.cnblogs.com/nanyanxin/p/18678902', title: '3 运输层' })">举报</a>
</div>
        