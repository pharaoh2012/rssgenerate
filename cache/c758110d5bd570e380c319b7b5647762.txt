
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fs7744/p/18978275" title="发布于 2025-07-11 10:22">
    <span role="heading" aria-level="2">留个VKProxy性能测试记录</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>其实原本是打算OpenTelemetry对应内容搞好后再做个简单的性能测试，也算表明自己写(抄)代码的能力（不至于用了反射什么的就把Kestrel这么好的底子的性能拖垮了）</p>
<p>但是最近看见一篇go的文章 <a href="https://www.infoq.cn/article/k53EgWhQg0bxocOgxS7b" target="_blank" rel="noopener nofollow">报告揭示 OpenTelemetry 对 Go 的性能影响</a>，说OpenTelemetry 拖慢了 go 30+% 的性能，</p>
<p>虽然个人还是保守持怀疑态度，但万一本人代码写得臭，到时候找不到地方怪怎么办</p>
<p>所以先留份简单的性能测试记录，后面搞好OpenTelemetry再做个比较</p>
<h2 id="基准项目">基准项目</h2>
<p>一切从简，就选大家都熟悉的初始demo项目做基准好了</p>
<pre><code class="language-csharp">[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    private static readonly string[] Summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };

    private readonly ILogger&lt;WeatherForecastController&gt; _logger;

    public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)
    {
        _logger = logger;
    }

    [HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable&lt;WeatherForecast&gt; Get()
    {
        this.Response.Headers["x-p"] = this.Request.Protocol;
        return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }
}
</code></pre>
<h2 id="代理配置">代理配置</h2>
<p>启动最简单的代理配置（主要想看看最理想情况下的结果）</p>
<pre><code class="language-json">{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "ServerOptions": {
    "AddServerHeader": false
  },
  "ReverseProxy": {
    "ConnectionTimeout": "00:00:01.000",
    "Listen": {
      "https": {
        "Protocols": [ "Http1", "Http2", "Http3" ],
        "Address": [ "127.0.0.1:5001" ],
        "UseSni": true,
        "SniId": "test"
      },
      "http": {
        "Protocols": [ "Http1" ],
        "Address": [ "127.0.0.1:5000" ]
      },
      "tcptest": {
        "Protocols": [ "Tcp" ],
        "Address": [ "127.0.0.1:5002" ],
        "RouteId": "tcpTest"
      }
    },
    "Sni": {
      "test": {
        "Host": [ "*" ],
        "CheckCertificateRevocation": false,
        "Certificate": {
          "PEM": "-----BEGIN CERTIFICATE-----xxxxx\n-----END CERTIFICATE-----",
          "PEMKey": "-----BEGIN ENCRYPTED PRIVATE KEY-----\nxxxx\n-----END ENCRYPTED PRIVATE KEY-----",
          "Password": "testPassword"
        }
      }
    },
    "Routes": {
      "HTTPTEST": {
        "Match": {
          "Hosts": [ "*" ],
          "Paths": [ "*" ]
        },
        "ClusterId": "apidemo",
        "Timeout": "00:10:11"
      },
      "tcpTest": {
        "ClusterId": "apidemo",
        "Timeout": "00:10:11"
      }
    },
    "Clusters": {
      "apidemo": {
        "HttpClientConfig": {
          "DangerousAcceptAnyServerCertificate": true
        },
        "LoadBalancingPolicy": "RoundRobin",
        "Destinations": [
          {
            "Address": "https://127.0.0.1:4001"
          }
        ]
      }
    }
  }
}
</code></pre>
<pre><code class="language-bash">vkproxy -c D:\code\github\VKProxy\samples\CoreDemo\test.json
</code></pre>
<h2 id="测试工具">测试工具</h2>
<p>这里会在本人电脑内测试理想情况，主要没有精力去搭建真实网络环境测试（贫穷的眼泪），哈哈</p>
<p>个人电脑情况：<br>
Windows 11 (10.0.26100.4351)<br>
Intel Core i7-10700 CPU 2.90GHz, 1 CPU, 16 logical and 8 physical cores<br>
32G Memory<br>
INTEL SSDPEKNW512GB</p>
<p>以前用过 ali 这个go写的测试工具，因为它会实时在命令行终端绘制性能测试图，在简单测试使用很方便，但可惜断更了，并且有个大bug没有修复：绘制的性能测试图错位了，非常影响观看，非常惋惜呀</p>
<p>所以这里找了个同样go写的工具 <a href="https://github.com/tsenart/vegeta" target="_blank" rel="noopener nofollow">vegeta</a> 主要看重它有命令可以生成图， 但可惜好像不支持 http3</p>
<p>测试命令</p>
<pre><code class="language-bash">// 性能测试
.\vegeta.exe attack -insecure -rate=10000/s -duration=60s -format=http -targets=test -output=results -http2 

// 汇总报告
.\vegeta.exe report .\results

// 绘图
.\vegeta.exe plot .\results  &gt; plot.html
</code></pre>
<h2 id="测试结果">测试结果</h2>
<h4 id="基准-http2---weatherforecast-api">基准 HTTP2 -&gt; WeatherForecast api</h4>
<pre><code class="language-bash">.\vegeta.exe attack -insecure -rate=10000/s -duration=60s -format=http -targets=base -output=baseresults -http2 
// base content:
// GET https://127.0.0.1:4001/WeatherForecast
</code></pre>
<p><img alt="base" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711095906292-1335493593.jpg" class="lazyload"></p>
<p><img alt="baseplot" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711100131390-751040204.jpg" class="lazyload"></p>
<p>汇总</p>
<pre><code class="language-bash">Requests      [total, rate, throughput]         599930, 9998.35, 9998.35
Duration      [total, attack, wait]             1m0s, 1m0s, 0s
Latencies     [min, mean, 50, 90, 95, 99, max]  0s, 676.024µs, 0s, 2.56ms, 3.705ms, 5.367ms, 26.437ms
Bytes In      [total, mean]                     232052167, 386.80
Bytes Out     [total, mean]                     0, 0.00
Success       [ratio]                           100.00%
Status Codes  [code:count]                      200:599930
Error Set:
</code></pre>
<h4 id="http2---vkproxyhttps---http2---weatherforecast-api">HTTP2 -&gt; VKProxy(https) -&gt; HTTP2 -&gt; WeatherForecast api</h4>
<pre><code class="language-bash">.\vegeta.exe attack -insecure -rate=10000/s -duration=60s -format=http -targets=http2proxy -output=http2proxyresults -http2 
// http2proxy content:
// GET https://127.0.0.1:5001/WeatherForecast
</code></pre>
<p><img alt="HTTP2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711101035815-1408107803.jpg" class="lazyload"></p>
<p><img alt="http2plot" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711101046126-795480850.jpg" class="lazyload"></p>
<p>汇总</p>
<pre><code class="language-bash">Requests      [total, rate, throughput]         599980, 9999.85, 9999.85
Duration      [total, attack, wait]             59.999s, 59.999s, 0s
Latencies     [min, mean, 50, 90, 95, 99, max]  0s, 2.199ms, 1.845ms, 5.162ms, 6.359ms, 9.217ms, 108.78ms
Bytes In      [total, mean]                     232078680, 386.81
Bytes Out     [total, mean]                     0, 0.00
Success       [ratio]                           100.00%
Status Codes  [code:count]                      200:599980
Error Set:
</code></pre>
<h4 id="http2---vkproxytcp---scoket---weatherforecast-api">HTTP2 -&gt; VKProxy(tcp) -&gt; scoket -&gt; WeatherForecast api</h4>
<pre><code class="language-bash">.\vegeta.exe attack -insecure -rate=10000/s -duration=60s -format=http -targets=tcpproxy -output=tcpproxyresults -http2 
// tcpproxy content:
// GET https://127.0.0.1:5002/WeatherForecast
</code></pre>
<p><img alt="tcp" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711101331500-1401462445.jpg" class="lazyload"></p>
<p><img alt="tcpplot" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250711101652541-643934889.jpg" class="lazyload"></p>
<p>汇总</p>
<pre><code class="language-bash">Requests      [total, rate, throughput]         599976, 9998.48, 9998.48
Duration      [total, attack, wait]             1m0s, 1m0s, 0s
Latencies     [min, mean, 50, 90, 95, 99, max]  0s, 1.809ms, 1.004ms, 4.736ms, 5.744ms, 8.995ms, 98.922ms
Bytes In      [total, mean]                     232069758, 386.80
Bytes Out     [total, mean]                     0, 0.00
Success       [ratio]                           100.00%
Status Codes  [code:count]                      200:599976
Error Set:
</code></pre>
<p>结果大致就是这样了，看起来个人写的代码也不至于太臭，至少理想情况下没有拖慢多少，</p>
<p>客官，你们怎么看？</p>
<p><a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">VKProxy</a> 是使用c#开发的基于 Kestrel 实现 L4/L7的代理（感兴趣的同学烦请点个<a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">github</a>小赞赞呢）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-11 10:22">2025-07-11 10:22</span>&nbsp;
<a href="https://www.cnblogs.com/fs7744">victor.x.qu</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18978275);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18978275', targetLink: 'https://www.cnblogs.com/fs7744/p/18978275', title: '留个VKProxy性能测试记录' })">举报</a>
</div>
        