
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huntto/p/19019059" title="发布于 2025-08-02 17:39">
    <span role="heading" aria-level="2">匀速二阶贝塞尔曲线（二）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>根据<a href="https://www.cnblogs.com/huntto/p/19007435" target="_blank">上一篇文章</a>介绍的方法进行匀速贝塞尔曲线运动时，实际使用时会发现两个问题。</p>
<h2 id="计算失效问题">计算失效问题</h2>
<p>当<span class="math inline">\(A=0\)</span>，此时不能用<span class="math inline">\(L(t)\)</span>计算二阶贝塞尔曲线的长度：</p>
<p></p><div class="math display">\[\begin{align}

L(t) =&amp; \frac{1}{8A^\frac{3}{2}} \big(T_1T_0-T_2ln(T_1+T_0) \\
&amp;- BT_3+T_2ln(B+T_3) \big) \\

T_0 =&amp; 2\sqrt{A}\sqrt{C+Bt+At^2} \\
T_1 =&amp; B+2At \\
T_2 =&amp; B^2-4AC \\
T_3 =&amp; 2\sqrt{AC}

\end{align}

\]</div><p></p><p>同时当<span class="math inline">\(P_0\)</span> <span class="math inline">\(P_1\)</span> <span class="math inline">\(P_2\)</span>三点共线时，<span class="math inline">\(L(1.0)=Nan\)</span>，需要使用匀速直线运动方法进行计算。</p>
<h2 id="加速度问题">加速度问题</h2>
<p>当把Python代码中三个点的坐标替换为：</p>
<pre><code class="language-python">P0 = np.array([636.593750,684.976562])  # 起点
P1 = np.array([636.593750,685.218750])  # 控制点
P2 = np.array([672.511719,682.589844])  # 终点
</code></pre>
<p>会得到如下结果：</p>
<p><img alt="Figure_1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3093519/202508/3093519-20250802173748534-912307597.png" class="lazyload"></p>
<p>通过打印<span class="math inline">\(t_n\)</span>的值发现其部分<span class="math inline">\(&gt;1\)</span>，通过回顾<span class="math inline">\(t_n\)</span>的计算公式：</p>
<p></p><div class="math display">\[\begin{align}

t_n=t_{n-1}+\frac{\frac{n}{N}L(1.0)-L(t_{n-1})}{s(t_{n-1})} \quad,\quad n\in[1, N]

\end{align}
\]</div><p></p><p>我们只考虑了速度<span class="math inline">\(s(t)\)</span>，并没有考虑加速度，通过对<span class="math inline">\(V(t)\)</span>求导可以得到加速度：</p>
<p></p><div class="math display">\[\begin{align}
F(t)=&amp;V'(t) \\
=&amp;2
\begin{bmatrix}
x_0 \\
y_0 \\
\end{bmatrix}
-4
\begin{bmatrix}
x_1 \\
y_1 \\
\end{bmatrix}
+2
\begin{bmatrix}
x_2 \\
y_2 \\
\end{bmatrix}

\end{align}
\]</div><p></p><p>同样对其取模，舍弃方向：</p>
<p></p><div class="math display">\[\begin{align}
f =&amp; \Vert F(t) \Vert \\
=&amp; \sqrt{a_x^2+a_y^2} \\
=&amp; \sqrt{A}
\end{align}
\]</div><p></p><p>加速度为固定值，也就是恒加速度运动。最终<span class="math inline">\(t_n\)</span>公式修改为：</p>
<p></p><div class="math display">\[\begin{align}

t_n =&amp; t_{n-1} + \Delta{t} \\
\Delta{t} =&amp; \frac{-s(t_{n-1})+\sqrt{s^2(t_{n-1})+2f\Big(\frac{n}{N}L(1.0)-L(t_{n-1})\Big)}}{f}
\end{align}
\]</div><p></p><p>将之前的Python进行修改如下：</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import sys


def bezier_length(A, B, C, t):  # 二阶贝塞尔曲线长度
    T0 = 2 * np.sqrt(A) * np.sqrt(C + B * t + A * t * t)
    T1 = B + 2 * A * t
    T2 = B * B - 4 * A * C
    T3 = 2 * np.sqrt(A * C)
    return 1 / (8 * np.pow(A, 1.5)) * (T0 * T1 - T2 * np.log(T1 + T0) - B * T3 + T2 * np.log(B + T3))


def bezier_velocity(A, B, C, t):  # 二阶贝塞尔曲线速度
    return np.sqrt(C + B * t + A * t * t)


def bezier_movement(p0, p1, p2, N):  # 二阶贝塞尔曲线等距移动
    a = 2 * p0 - 4 * p1 + 2 * p2
    b = -2 * p0 + 2 * p1
    A = a[0] * a[0] + a[1] * a[1]
    B = 2 * a[0] * b[0] + 2 * a[1] * b[1]
    C = b[0] * b[0] + b[1] * b[1]
    f = np.sqrt(A)
    L1 = bezier_length(A, B, C, 1)
    print(A, B, C, L1)
    tn = 0
    res = np.zeros((N + 1, 2))
    for n in range(N + 1):
        print(tn)
        res[n] = (1 - tn) * (1 - tn) * p0 + 2 * tn * (1 - tn) * p1 + tn * tn * p2
        v = bezier_velocity(A, B, C, tn)
        l = ((n + 1) / N * L1 - bezier_length(A, B, C, tn))
        delta_t = (-v + np.sqrt(v * v + 2 * f * l)) / f
        tn = tn + delta_t
    return res


P0 = np.array([636.593750, 684.976562])  # 起点
P1 = np.array([636.593750, 685.218750])  # 控制点
P2 = np.array([672.511719, 682.589844])  # 终点

N = 10
if len(sys.argv) &gt; 1:
    N = int(sys.argv[1])

curve = bezier_movement(P0, P1, P2, N)

plt.figure(figsize=(10, 6))

plt.plot([P0[0], P1[0], P2[0]], [P0[1], P1[1], P2[1]], 'ro--', label='Control-Line')
plt.plot(curve[:, 0], curve[:, 1], 'o', linewidth=2, label='Bezier movement')

plt.text(P0[0], P0[1], 'P0', fontsize=12, ha='right', va='top')
plt.text(P1[0], P1[1], 'P1', fontsize=12, ha='center', va='bottom')
plt.text(P2[0], P2[1], 'P2', fontsize=12, ha='left', va='top')

plt.title('Bezier Curve(N=' + str(N) + ')', fontsize=14)
plt.xlabel('X-axis', fontsize=12)
plt.ylabel('Y-axis', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.7)
plt.legend()
plt.axis('equal')
plt.show()
</code></pre>
<p>最终运行结果如下图所示：</p>
<p><img alt="Figure_2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3093519/202508/3093519-20250802173801138-2062374512.png" class="lazyload"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-02 17:39">2025-08-02 17:39</span>&nbsp;
<a href="https://www.cnblogs.com/huntto">Huntto</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19019059);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19019059', targetLink: 'https://www.cnblogs.com/huntto/p/19019059', title: '匀速二阶贝塞尔曲线（二）' })">举报</a>
</div>
        