
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wucy/p/18864044/dotnet_webapi_mcp" title="发布于 2025-05-08 09:45">
    <span role="heading" aria-level="2">如何把ASP.NET Core WebApi打造成Mcp Server</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="前言">前言</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;MCP (Model Context Protocol)即模型上下文协议目前不要太火爆了，关于它是什么相信大家已经很熟悉了。目前主流的AI开发框架和AI工具都支持集成<code>MCP</code>，这也正是它的意义所在。毕竟作为一个标准的协议，当然是更多的生态接入进来才会有意义。使用MCP我们可以把<code>Tools调用标准化</code>，这意味着我们可以忽略语言、框架快速把工具融合到不同的模型中去。现在，如何把现有的业务逻辑快速的接入到模型中，成为模型落地很关键的一步，今天我们就借助微软的<code>Semantic Kernel</code>和<code>Microsoft.Extensions.AI</code>框架，通过简单的示例展示，如何把现有的<code>ASP NET Core WebApi</code>转换成<code>MCP Server</code>。</p>
<h3 id="概念相关">概念相关</h3>
<p>接下来我们大致介绍一下本文设计到的相关的概念以及涉及到的相关类库</p>
<h4 id="mcp">MCP</h4>
<p>MCP是一个开放协议，它为应用程序向 LLM 提供上下文的方式进行了标准化。它的重点是标准化，而不是取代谁。它涉及到几个核心的概念</p>
<ul>
<li>MCP Hosts: 如<code>Claude Desktop</code>、<code>IDE</code>、<code>AI</code>工具、或者是你开发的AI程序等</li>
<li>MCP Clients: 维护与<code>MCP Servers</code>一对一连接的协议客户端</li>
<li>MCP Servers: 轻量级程序，通过标准的<code>Model Context Protocol</code>提供特定能力</li>
</ul>
<p>简单来说就是你写的AI应用就是<code>MCP Hosts</code>，因为<code>MCP</code>是一个协议，所以你需要通过<code>MCP Clients</code>访问<code>MCP Servers</code>，<code>MCP Servers</code>提供的就是工具或者一些其他能力。需要说明的是，如果想在AI应用中使用<code>MCP</code>，模型需要支持<code>Function Calling</code>，当然如果你能通过<code>提示词</code>的方式调试出来也是可以的，但是效果肯定不如本身就支持<code>Function Calling</code>。</p>
<p>因为MCP是一个开放协议，所以我们可以把原来固定在AI应用里的工具代码单独抽离出来，使用不同的开发语言形成独立的应用，这样这个Tools应用就可以和AI应用隔离，他们可以不是同一种语言，甚至可以在不同的机器上。所以现在很多开源的组件和平台都可以提供自己的<code>MCP Server</code>了。就和没有微服务概念之前我们代码都写到一个项目里，有了微服务之后我们可以把不同的模块形成单独的项目，甚至可以使用不同的开发语言。可以通过HTTP、RPC等多种方式进行通信。</p>
<h4 id="框架">框架</h4>
<p>简单介绍一下本文涉及到的相关框架及地址：</p>
<ul>
<li>
<p>Microsoft.Extensions.AI：微软提供的通过.NET实现AIGC操作的开发基础框架，提供了基础<code>对话</code>和<code>Function Calling</code>等基础操作，使用简单扩展性强，支持OTEL要测协议监控模型调用情况。目前已适配Ollama、OpenAI、Azure OpenAI等。项目地址<a href="https://github.com/dotnet/extensions/tree/main/src/Libraries/Microsoft.Extensions.AI" target="_blank" rel="noopener nofollow">https://github.com/dotnet/extensions/tree/main/src/Libraries/Microsoft.Extensions.AI</a></p>
</li>
<li>
<p>Semantic Kernel：以<code>Microsoft.Extensions.AI</code>为基础(低版本的不是)打造的更强大的AI开发框架，提供了基础<code>对话</code>和<code>Function Calling</code>功能的同时，还提供了多模态、RAG、智能体、流程处理等强大的应用级功能,有.NET、Python、Java三种语言版本。项目地址<a href="https://github.com/microsoft/semantic-kernel" target="_blank" rel="noopener nofollow">https://github.com/microsoft/semantic-kernel</a></p>
</li>
<li>
<p>mcpdotnet(modelcontextprotocol/csharp-sdk)：原名为mcpdotnet，现在是.NET构建MCP的官方项目，可以使的Microsoft.Extensions.AI和Semantic Kernel快速的适配到MCP。项目地址<a href="https://github.com/modelcontextprotocol/csharp-sdk" target="_blank" rel="noopener nofollow">https://github.com/modelcontextprotocol/csharp-sdk</a></p>
</li>
</ul>
<h3 id="实现">实现</h3>
<p>整体来说实现的思路也很简单，因为<code>Semantic Kernel</code>支持加载<code>OpenAPI</code>格式的数据加载成它的<code>Plugins</code>，我们可以把<code>Plugins</code>转换成<code>Microsoft.Extensions.AI</code>提供的标准的<code>AIFunction</code>类型，通过<code>mcpdotnet</code>可以把<code>AIFunction</code>标准类型转换成<code>mcpdotnet</code>的<code>Tools</code>。</p>
<h4 id="webapi">WebApi</h4>
<p>我们需要新建一个<code>ASP.NET Core WebAPI</code>项目，用来完成查询天气的功能。首先，添加<code>Swagger</code>支持。当然你使用别的库也可以，这里的重点就是可以得到该项目接口的<code>OpenAPI</code>数据信息。</p>
<pre><code>&lt;PackageReference Include="Swashbuckle.AspNetCore" Version="8.1.1" /&gt;
</code></pre>
<p>其次，添加根据IP查询地址信息的功能</p>
<pre><code>&lt;PackageReference Include="IPTools.China" Version="1.6.0" /&gt;
</code></pre>
<p>因为<code>IPTools</code>使用的是<code>sqlite</code>数据库，所以需要把db加载到项目里。具体使用细节可以查看该库的具体地址<a href="https://github.com/stulzq/IPTools" target="_blank" rel="noopener nofollow">https://github.com/stulzq/IPTools</a></p>
<pre><code>&lt;ItemGroup&gt;
 &lt;None Update="ip2region.db"&gt;
    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
  &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>接下来实现具体功能的<code>Controller</code>代码</p>
<pre><code class="language-csharp"> /// &lt;summary&gt;
 /// 获取城市天气
 /// &lt;/summary&gt;
 [ApiController]
 [Route("api/[controller]/[action]")]
 public class WeatherController(IHttpClientFactory _httpClientFactory) : ControllerBase
 {
     /// &lt;summary&gt;
     /// 获取当前时间
     /// &lt;/summary&gt;
     /// &lt;returns&gt;当前时间&lt;/returns&gt;
     [HttpGet]
     public string GetCurrentDate()
     {
         return DateTime.Now.ToString("MM/dd");
     }

     /// &lt;summary&gt;
     /// 获取当前城市信息
     /// &lt;/summary&gt;
     /// &lt;returns&gt;当前城市信息&lt;/returns&gt;
     [HttpGet]
     public async Task&lt;IpInfo&gt; GetLocation()
     {
         var httpClient = _httpClientFactory.CreateClient();
         IpData ipInfo = await httpClient.GetFromJsonAsync&lt;IpData&gt;("https://ipinfo.io/json");
         var ipinfo = IpTool.Search(ipInfo!.ip);
         return ipinfo;
     }

     /// &lt;summary&gt;
     /// 获取天气信息
     /// &lt;/summary&gt;
     /// &lt;param name="region"&gt;省份&lt;/param&gt;
     /// &lt;param name="city"&gt;城市&lt;/param&gt;
     /// &lt;param name="currentDate"&gt;日期(格式：月份/日期)&lt;/param&gt;
     /// &lt;returns&gt;天气信息&lt;/returns&gt;
     [HttpGet]
     public async Task&lt;string&gt; GetCurrentWeather(string region, string city, string currentDate)
     {
         var httpClient = _httpClientFactory.CreateClient();
         WeatherRoot weatherRoot = await httpClient.GetFromJsonAsync&lt;WeatherRoot&gt;($"https://cn.apihz.cn/api/tianqi/tqybmoji15.php?id=88888888&amp;key=88888888&amp;sheng={region!}&amp;place={city!}")!;
         DataItem today = weatherRoot!.data!.FirstOrDefault(i =&gt; i.week2 == currentDate)!;
         return $"{today!.week2} {today.week1},天气{today.wea1}转{today.wea2}。最高气温{today.wendu1}摄氏度,最低气温{today.wendu2}摄氏度。";
     }
 }

public class IpData
{
    public string ip { get; set; }
    public string city { get; set; }
    public string region { get; set; }
    public string country { get; set; }
    public string loc { get; set; }
    public string org { get; set; }
    public string postal { get; set; }
    public string timezone { get; set; }
    public string readme { get; set; }
}

public class DataItem
{
    public string week1 { get; set; }
    public string week2 { get; set; }
    public string wea1 { get; set; }
    public string wea2 { get; set; }
    public string wendu1 { get; set; }
    public string wendu2 { get; set; }
    public string img1 { get; set; }
    public string img2 { get; set; }
}

public class WeatherRoot
{
    public List&lt;DataItem&gt; data { get; set; }
    public int code { get; set; }
    public string place { get; set; }
}
</code></pre>
<p>代码里实现了三个action，分别是获取城市天气、获取当前城市信息、获取天气信息接口。接下来添加项目配置</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =&gt;
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Version = "v1",
        Title = "",
        Description = "",
    });

    var xmlFilename = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename));
});
builder.Services.AddHttpClient();

var app = builder.Build();

//使用OpenApi的版本信息
app.UseSwagger(options =&gt;
{
    options.OpenApiVersion = Microsoft.OpenApi.OpenApiSpecVersion.OpenApi3_0;
});
app.UseSwaggerUI(options =&gt;
{
    options.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
});

app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<p>完成上面的代码之后，可以运行起来该项目。通过<code>http://项目地址:端口/swagger/v1/swagger.json</code>获取<code>WebApi</code>接口的<code>OpenAPI</code>的数据格式。</p>
<h4 id="mcp-server">MCP Server</h4>
<p>接下来搭建<code>MCP Server</code>项目，来把上面的<code>WebApi</code>项目转换成<code>MCP Server</code>。首先添加<code>MCP</code>和<code>SemanticKernel OpenApi</code>涉及到的类库，因为我们需要使用<code>SemanticKernel</code>来把<code>swagger.json</code>加载成<code>Plugins</code></p>
<pre><code>&lt;ItemGroup&gt;
  &lt;PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" /&gt;
  &lt;PackageReference Include="Microsoft.SemanticKernel.Plugins.OpenApi" Version="1.47.0" /&gt;
  &lt;PackageReference Include="ModelContextProtocol" Version="0.1.0-preview.11" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>接下来我们来编写具体的代码实现</p>
<pre><code class="language-csharp">IKernelBuilder kernelBuilder = Kernel.CreateBuilder();;
Kernel kernel = kernelBuilder.Build();

#pragma warning disable SKEXP0040

//把swagger.json加载成Plugin
//这里也可以是本地路径或者是文件流
await kernel.ImportPluginFromOpenApiAsync(
   pluginName: "city_date_weather",
   uri: new Uri("http://localhost:5021/swagger/v1/swagger.json"),
   executionParameters: new OpenApiFunctionExecutionParameters 
   { 
       EnablePayloadNamespacing = true
   }
 );

#pragma warning restore SKEXP0040

var builder = Host.CreateEmptyApplicationBuilder(settings: null);
builder.Services
    //添加MCP Server
    .AddMcpServer()
    //使用Stdio模式
    .WithStdioServerTransport()
    //把Plugins转换成McpServerTool
    .WithTools(kernel.Plugins);

await builder.Build().RunAsync();


public static class McpServerBuilderExtensions
{
    /// &lt;summary&gt;
    /// 把Plugins转换成McpServerTool
    /// &lt;/summary&gt;
    public static IMcpServerBuilder WithTools(this IMcpServerBuilder builder, KernelPluginCollection plugins)
    {
        foreach (var plugin in plugins)
        {
            foreach (var function in plugin)
            {
                builder.Services.AddSingleton(services =&gt; McpServerTool.Create(function.AsAIFunction()));
            }
        }

        return builder;
    }
}
</code></pre>
<blockquote>
<p>MCP的传输层协议可以使用<code>stdio(既标准输入输出)</code>、<code>sse</code>或者是<code>streamable</code>，甚至是自定义的方式进行通信。其中<code>stdio</code>可以本机进程间通信，<code>sse</code>或者是<code>streamable</code>进行远程通信。它的消息格式，或者理解为数据传输的格式是<code>JSON-RPC 2.0</code>。</p>
</blockquote>
<p>其中<code>ImportPluginFromOpenApiAsync</code>方法是其中比较关键的点，它是把<code>OpenApi</code>接口信息转换成<code>Kernel Plugins</code>。它通过读取<code>swagger.json</code>里的接口信息的元数据构建成<code>KernelFunction</code>实例，而具体的触发操作则转换成Http调用。具体的实现方式可以通过阅读<a href="https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Functions/Functions.OpenApi/OpenApiKernelPluginFactory.cs#L251" target="_blank" rel="noopener nofollow">CreateRestApiFunction</a>方法源码的实现。</p>
<p>再次<code>AsAIFunction</code>方法则是把<code>KernelFunctionFromMethod</code>转换成<code>KernelAIFunction</code>，因为<code>KernelFunctionFromMethod</code>是继承了<code>KernelFunction</code>类，<code>KernelAIFunction</code>则是继承了<code>AIFunction</code>类，所以这个操作是把<code>KernelFunction</code>转换成<code>AIFunction</code>。可以把<code>KernelAIFunction</code>理解成<code>KernelFunction</code>的外观类，它只是包装了<code>KernelFunction</code>的操作，所以触发的时候还是<code>KernelFunctionFromMethod</code>里的操作。具体的实现可以查看<a href="https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/SemanticKernel.Abstractions/Functions/KernelFunction.cs#L529" target="_blank" rel="noopener nofollow"> KernelAIFunction</a>类的实现。</p>
<p>几句简单的代码既可以实现一个<code>Mcp Server</code>，虽然上面我们使用的是<code>Uri</code>的方式加载的<code>OpenAPI</code>文档地址，但是它也支持<code>本地文件地址</code>或者<code>文件流</code>的方式。不得不说微软体系下的框架在具体的落地方面做得确实够实用，因为具体的逻辑都是<code>WebApi</code>实现的，<code>Mcp Server</code>只是一个媒介。</p>
<h4 id="mcp-client">MCP Client</h4>
<p>最后实现的是<code>MCP Client</code>是为了验证<code>Mcp Server</code>效果用的，这里可以使用任何框架来实现，需要引入<code>ModelContextProtocol</code>和具体的AI框架，AI框架可以是<code>Microsoft.Extensions.AI</code>，也可以是<code>Semantic Kernel</code>。这里我们使用<code>Microsoft.Extensions.AI</code>，因为它足够简单也足够简洁，引入相关的类库</p>
<pre><code class="language-csharp">&lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Extensions.AI.OpenAI" Version="9.4.3-preview.1.25230.7" /&gt;
    &lt;PackageReference Include="ModelContextProtocol" Version="0.1.0-preview.12" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>其中<code>ModelContextProtocol</code>提供了<code>McpClient</code>功能，<code>Microsoft.Extensions.AI</code>提供具体的AI功能集成。具体实现如下所示</p>
<pre><code class="language-csharp">//加载McpServer，以为我们构建的是使用Stdio的方式，所以这里直接使用McpServer路径即可
await using IMcpClient mcpClient = await McpClientFactory.CreateAsync(new StdioClientTransport(new()
{
    Name = "city_date_weather",
    Command = "..\\..\\..\\..\\McpServerDemo\\bin\\Debug\\net9.0\\McpServerDemo.exe"
}));

//加载MCP Tools
var tools = await mcpClient.ListToolsAsync();
foreach (AIFunction tool in tools)
{
    Console.WriteLine($"Tool Name: {tool.Name}");
    Console.WriteLine($"Tool Description: {tool.Description}");
    Console.WriteLine();
}

//中文的function calling，国内使用qwen-max系列效果最好
string apiKey = "sk-****";
var chatClient = new ChatClient("qwen-max-2025-01-25", new ApiKeyCredential(apiKey), new OpenAIClientOptions
{
    Endpoint = new Uri("https://dashscope.aliyuncs.com/compatible-mode/v1")
}).AsIChatClient();

IChatClient client = new ChatClientBuilder(chatClient)
    //开启function calling支持
    .UseFunctionInvocation()
    .Build();

//构建Tools
ChatOptions chatOptions = new()
{
    Tools = [.. tools],
};

//创建对话代码
List&lt;Microsoft.Extensions.AI.ChatMessage&gt; chatList = [];

string question = "";
do
{
    Console.Write($"User:");
    question = Console.ReadLine();

    if (string.IsNullOrWhiteSpace(question) || question == "exists")
    {
        break;
    }

    chatList.Add(new Microsoft.Extensions.AI.ChatMessage(ChatRole.User, question));

    Console.Write($"Assistant:");
    StringBuilder sb = new StringBuilder();
    await foreach (var update in client.GetStreamingResponseAsync(chatList, chatOptions))
    {
        if (string.IsNullOrWhiteSpace(update.Text))
        {
            continue;
        }
        sb.Append(update.Text);

        Console.Write(update.Text);
    }

    chatList.Add(new Microsoft.Extensions.AI.ChatMessage(ChatRole.Assistant, sb.ToString()));

    Console.WriteLine();

} while (true);

Console.ReadLine();
</code></pre>
<p>上面的代码实现了<code>McpClient</code>接入AI应用</p>
<ul>
<li>首先，通过<code>McpClient</code>加载<code>McpServer</code>里的工具</li>
<li>其次，把<code>MCP Tools</code>加载到<code>Microsoft.Extensions.AI</code>里</li>
<li>最后，在和AI模型对话的时候把Tools转换成<code>function calling</code>。中文的<code>function calling</code>，个人体验下来国内使用<code>qwen-max</code>系列效果最好</li>
</ul>
<p>其中<code>mcpClient.ListToolsAsync()</code>获取到的是<code>McpClientTool</code>集合，而<code>McpClientTool</code>继承自<code>AIFunction</code>类，具体可查看<a href="https://github.com/modelcontextprotocol/csharp-sdk/blob/main/src/ModelContextProtocol/Client/McpClientTool.cs#L28" target="_blank" rel="noopener nofollow">McpClientTool</a>实现源码。由此可以看出微软封装<code>Microsoft.Extensions.AI</code>基座的重要性，以后更多的框架都可以围绕<code>Microsoft.Extensions.AI</code>进行封装统一操作，这样大大提升了扩展的便捷性。</p>
<p>当然，你也可以使用<code>Semantic Kernel</code>框架进行上面的操作，这里就不过多赘述了，直接上代码</p>
<pre><code class="language-csharp">//加载McpServer，以为我们构建的是使用Stdio的方式，所以这里直接使用McpServer路径即可
await using IMcpClient mcpClient = await McpClientFactory.CreateAsync(new StdioClientTransport(new()
{
    Name = "city_date_weather",
    Command = "..\\..\\..\\..\\McpServerDemo\\bin\\Debug\\net9.0\\McpServerDemo.exe"
}));

//加载MCP Tools
var tools = await mcpClient.ListToolsAsync();

using HttpClientHandler handler = new HttpClientHandler
{
    ClientCertificateOptions = ClientCertificateOption.Automatic
};

using HttpClient httpClient = new(handler)
{
    BaseAddress = new Uri("https://dashscope.aliyuncs.com/compatible-mode/v1")
};

#pragma warning disable SKEXP0070
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion("qwen-max-2025-01-25", "sk-***", httpClient: httpClient);
//把Tools加载成sk的Plugins
kernelBuilder.Plugins.AddFromFunctions("weather", tools.Select(aiFunction =&gt; aiFunction.AsKernelFunction()));

Kernel kernel = kernelBuilder.Build();
var chatCompletionService = kernel.GetRequiredService&lt;IChatCompletionService&gt;();

PromptExecutionSettings promptExecutionSettings = new()
{
    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto()
};

var history = new ChatHistory();

while (true)
{
    Console.Write($"User:");
    string input = Console.ReadLine();

    if (string.IsNullOrWhiteSpace(input) || input == "exists")
    {
        break;
    }

    history.AddUserMessage(input);
    var chatMessage = await chatCompletionService.GetChatMessageContentAsync(
    history,
    executionSettings: promptExecutionSettings,
    kernel: kernel);

    Console.WriteLine("Assistant:" + chatMessage.Content);

    history.AddAssistantMessage(chatMessage.Content);
}

Console.ReadLine();
</code></pre>
<p>因为<code>MCP</code>是一个协议标准，所以<code>MCP Server</code>可以做到一次构建，到处使用。</p>
<h4 id="运行效果">运行效果</h4>
<p>运行的时候需要先运行起来<code>WebApi</code>项目，然后把<code>McpServer</code>编译成<code>exe</code>文件，然后运行<code>McpClient</code>项目，我们打印出来了可用的<code>Tools</code>列表。在Client项目进行对话，询问当前天气效果如下</p>
<p><img src="https://img2024.cnblogs.com/blog/2042116/202505/2042116-20250507112852579-1003140213.png" alt="" loading="lazy"></p>
<p>感兴趣的如果想运行具体的代码示例，可以查看我上传的代码示例<a href="https://github.com/softlgl/McpDemo" target="_blank" rel="noopener nofollow">https://github.com/softlgl/McpDemo</a></p>
<h4 id="总结">总结</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;本文演示了如何把ASP.NET Core WebApi打造成Mcp Server，通过讲解基本概念，介绍使用的框架，以及简单的示例展示了这一过程，整体来说是比较简单的。<code>MCP</code>的重点是标准化，而不是取代。如果想在AI应用中使用<code>MCP</code>，模型需要支持<code>Function Calling</code>.我们可以把原来固定在AI应用里的工具代码单独抽离出来，形成独立的应用，这样这个Tools应用就可以和AI应用隔离，形成独立可复用的工具。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;现在AI大部分时候确实很好用，但是它也不是银弹。至于它的边界在哪里，只有不断地使用实践。你身边的事情都可以先用AI尝试去做，不断地试探它的能力。AI帮你做完的事情，如果能达到你的预期，你可以看它的实现方式方法，让自己学习到更好的思路。如果是完全依赖AI，而自己不去思考，那真的可能会被AI取代掉。只有你自己不断的进步，才能进一步的探索AI，让它成为你的好工具。<br>
<br></p>
<div align="center">
  <span style="font-size: 15px">👇欢迎扫码关注我的公众号👇</span>
  <img src="https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png">
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.059055609956018516" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-08 09:46">2025-05-08 09:45</span>&nbsp;
<a href="https://www.cnblogs.com/wucy">yi念之间</a>&nbsp;
阅读(<span id="post_view_count">38</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18864044);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18864044', targetLink: 'https://www.cnblogs.com/wucy/p/18864044/dotnet_webapi_mcp', title: '如何把ASP.NET Core WebApi打造成Mcp Server' })">举报</a>
</div>
        