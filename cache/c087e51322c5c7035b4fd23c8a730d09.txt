
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/caoruipeng/p/18766501" title="发布于 2025-03-12 12:00">
    <span role="heading" aria-level="2">Windows编程----结束进程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>进程有启动就有终止，通过CreateProcess函数可以启动一个新的子进程，但是如何终结子进程呢？主要有四种方法：</p>
<h2>通过主线程的入口函数（main函数、WinMain函数）的return关键字终止进程</h2>
<p>一个应用程序只有一个入口函数，对于控制台来说是main函数，对于GUI程序来说这个入口函数一般是WinMain。入口函数通过return关键字返回或者程序自上而下执行完成之后，进程可以自动终止，进程相关的所有资源都会被操作清理。这也是开发中最常用的进程终止方法，也是强烈推荐大家使用的终止进程的方式。</p>
<p>那么如何能获取到子进程的返回值呢，以下面代码为例，这是一个最简单的控制台程序，它返回-3。</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main()
{
	return -3;
}</code></pre>
<p>首先演示在cmd控制台或者bat脚本中如何获取该进程的最终返回值：通过<code>echo %errorlevel%</code>命令可以获取到上一个cmd命令的返回值。如下：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250311233921774-779562231.png" height="367" width="983"></figure>
<p>在程序中获取子进程的返回值，CreateProcess函数创建子进程成功之后，主进程可以拿到子进程的句柄。通过调用<code>GetExitCodeProcess</code>函数可以获取到某个进程的返回值，函数原型如下：</p>
<pre class="highlighter-hljs"><code>BOOL GetExitCodeProcess(
  HANDLE  hProcess,//子进程句柄
  LPDWORD lpExitCode//用于接受子进程的返回值
);</code></pre>
<p>请看以下代码：</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main()
{
	//即将启动的exe程序路径
	LPCWSTR lpApplicationName = L"D:\\project\\ConsoleApp1\\x64\\Debug\\NewApp.exe";

	// 定义启动信息和进程信息结构
	STARTUPINFOW si;
	PROCESS_INFORMATION pi;

	// 初始化启动信息结构
	ZeroMemory(&amp;si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&amp;pi, sizeof(pi));

	BOOL ret = CreateProcess(lpApplicationName,
		NULL,
		NULL,
		NULL,
		FALSE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&amp;si,
		&amp;pi);
	// 等待进程结束
	WaitForSingleObject(pi.hProcess, INFINITE);

	// 获取子进程的返回值
	DWORD exitCode;
	GetExitCodeProcess(pi.hProcess, &amp;exitCode);
	// 将无符号整数转换为有符号整数
	int signedExitCode = static_cast&lt;int&gt;(exitCode);
	std::cout &lt;&lt; "Child process exited with code: " &lt;&lt; signedExitCode &lt;&lt; std::endl;
	return 0;
}</code></pre>
<p>主程序在创建子进程之后，首先调用<code>WaitForSingleObject</code>等待子进程结果，然后调用<code>GetExitCodeProcess</code>函数获取子进程的返回值。但是这里注意，如果子进程返回0或者正数是没问题的，因为<code>DWORD</code>是一个无符号的整数类型，但是如果子进程返回负数的话，就需要我们手动将无符号整数转换为有符号整数。最后执行结果如下，可以看到正常获取到了子进程的返回值。</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250311233921743-869035313.png" height="162" width="978"></figure>
<h2>通过ExitProcess函数终止进程</h2>
<p><code>ExitProcess</code>函数可以终止进程，并且会设置一个进程的返回值。该函数原型只有一个参数，就是进程的返回值：</p>
<pre class="highlighter-hljs"><code>void ExitProcess(
  UINT uExitCode //进程返回值
);</code></pre>
<p>注意：调用<code>ExitProcess</code>之后，进程会直接退出，<code>ExitProcess</code>之后的函数都不会继续执行，在程序中，一定要尽量避免直接调用这个函数，我们以下面的代码为例：</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main(int argc, char** argv)
{
	ExitProcess(-4);
	std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
	return -3;
}</code></pre>
<p>当我们双击编译好的控制台程序之后，会发现<code>hello World!</code>并没有被执行，并且成功的返回了-4，效果如下：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250311233921748-1839631357.png" height="216" width="967"></figure>
<h2>通过TerminateProcess函数终止进程</h2>
<p>我们首先来修改子进程程序，通过一个无限while循环使进程永远不会退出：</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main(int argc, char** argv)
{
	while (true) {
		std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
		Sleep(1000);
	}
}</code></pre>
<p>然后按照上面的代码，创建完子进程之后，我们可以调用<code>TerminateProcess</code>函数直接终止子进程。</p>
<pre class="highlighter-hljs"><code>	BOOL ret = CreateProcess(lpApplicationName,
		NULL,
		NULL,
		NULL,
		FALSE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&amp;si,
		&amp;pi);

	TerminateProcess(pi.hProcess, -3);</code></pre>
<p><code>TerminateProcess</code>函数非常的简单粗暴，会强制将子进程终结，也应该尽量避免直接调用该函数终止进程，只有在其他办法都无法强制终结子进程的情况下，才可以使用该函数强制终结进程。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4284757665983796" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-12 12:00">2025-03-12 12:00</span>&nbsp;
<a href="https://www.cnblogs.com/caoruipeng">caoruipeng</a>&nbsp;
阅读(<span id="post_view_count">159</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18766501" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18766501);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18766501', targetLink: 'https://www.cnblogs.com/caoruipeng/p/18766501', title: 'Windows编程----结束进程' })">举报</a>
</div>
        