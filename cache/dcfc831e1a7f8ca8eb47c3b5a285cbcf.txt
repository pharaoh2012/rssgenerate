
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhennann/p/19023597" title="发布于 2025-08-05 16:58">
    <span role="heading" aria-level="2">Prisma不能优雅的支持DTO，试试Vona ORM吧</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165731822-418121312.png" alt="Prisma不能优雅的支持DTO，试试Vona ORM吧" class="desc_img">
        Prisma不能优雅的支持DTO。而Vona ORM就提供了非常便利的工具，使我们可以非常直观的动态推断出DTO，就像推断类型一样，从而解放我们的双手，显著提升生产力。甚至可以说，能够自动推断DTO，为Nodejs后端框架打开了一扇窗。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在Nodejs生态中，Prisma是一个非常流行的ORM库，支持Typescript，提供了非常友好的类型推断能力。但是，Prisma却不能优雅的支持DTO。在与其他后端框架整合时，DTO是进行参数验证、生成Swagger元数据的关键节点。如果不能像推断类型一样自动推断出DTO，那么，我们就仍然需要手工创建DTO。随着业务的增长，复杂的表间关系会让手工补充DTO的工作日益繁重。</p>
<p>而Vona ORM就提供了非常便利的工具，使我们可以非常直观的动态推断出DTO，就像推断类型一样，从而解放我们的双手，显著提升生产力。甚至可以说，能够自动推断DTO，为Nodejs后端框架打开了一扇窗。</p>
<p>Vona本身就是一款更直观的Nodejs框架，如果大家第一次接触，可以先参考这篇文章：<a href="https://juejin.cn/post/7509709812857110582" target="_blank" rel="noopener nofollow">你认为Vonajs提供的这些特性会比Nestjs更好用吗？</a></p>
<p>限于篇幅，这里不展开讲解Vona ORM所有的知识点，而是以<code>目录树</code>为例，演示如何查询一棵目录树，以及如何动态生成DTO，并最终生成Swagger元数据。Vona框架作者正在直播撰写Vona文档。围观官方文档的实时编写过程，有利于加深对框架设计的理解，探索不一样的架构设计路径。有兴趣的欢迎移步：<a href="https://space.bilibili.com/454737998" target="_blank" rel="noopener nofollow">B站濮水代码直播间</a></p>
<h2 id="1-创建entity">1. 创建Entity</h2>
<p>在VSCode中，可以通过右键菜单<code>Vona Create/Entity</code>创建Entity的代码骨架：</p>
<pre><code class="language-typescript">@Entity('demoStudentCategory')
export class EntityCategory extends EntityBase {
  @Api.field()
  name: string;

  @Api.field(v.optional())
  categoryIdParent?: TableIdentity;
}
</code></pre>
<ul>
<li>行2: 继承自EntityBase，就会自动提供5个基础字段：id、createdAt、updatedAt、deleted、iid
<ul>
<li>iid：是实例Id，通过多实例的机制支持多租户系统的开发</li>
</ul>
</li>
<li>行4、7: 定义两个业务字段：name、categoryIdParent</li>
<li>@Api.field：通过此装饰器定义的信息，可同时应用于参数验证和Swagger元数据</li>
<li>v.optional：声明为可选字段</li>
<li>更多信息，参见：<a href="https://vona.js.org/zh/guide/essentials/scope/entity.html" target="_blank" rel="noopener nofollow">Vona Entity</a></li>
</ul>
<h2 id="2-创建model">2. 创建Model</h2>
<p>在VSCode中，可以通过右键菜单<code>Vona Create/Model</code>创建Model的代码骨架：</p>
<pre><code class="language-typescript">import { EntityCategory } from '../entity/category.ts';

@Model({ entity: EntityCategory })
export class ModelCategory extends BeanModelBase&lt;EntityCategory&gt; {}
</code></pre>
<ul>
<li>行3: entity：指定Model所对应的Entity</li>
<li>行4: 继承自BeanModelBase，从而拥有大量操作数据库的方法，如：CRUD、聚合、分组，等等</li>
</ul>
<h2 id="3-创建树形结构">3. 创建树形结构</h2>
<p>如果要创建一棵目录树，本质就是建立Model引用自身的递归结构。Vona ORM同样支持4种关系：<code>1对1</code>、<code>1对多</code>、<code>多对1</code>，<code>多对多</code>。那么，在这里，我们就需要采用<code>1对多</code>来创建目录的自身引用关系。</p>
<pre><code class="language-diff">import { EntityCategory } from '../entity/category.ts';

@Model({
  entity: EntityCategory,
+ relations: {
+   children: $relation.hasMany(() =&gt; ModelCategory, 'categoryIdParent', {
+     autoload: true,
+     columns: ['id', 'name'],
+   }),
+ },
})
export class ModelCategory extends BeanModelBase&lt;EntityCategory&gt; {}
</code></pre>
<ul>
<li>行5: relations：可以定义多个关系</li>
<li>行6: children：定义一个1对多的关系</li>
<li>$relation.hasMany：
<ul>
<li>参数1: 引用自身ModelCategory</li>
<li>参数2: 设置关联外键categoryIdParent</li>
<li>参数3: 关联选项
<ul>
<li>autoload：是否自动加载关联数据</li>
<li>columns：控制关联数据的字段列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-创建controller">4. 创建Controller</h2>
<p>在VSCode中，可以通过右键菜单<code>Vona Create/Controller</code>创建Controller的代码骨架：</p>
<pre><code class="language-typescript">@Controller()
export class ControllerCategory extends BeanBase {}
</code></pre>
<p>接下来我们创建一个Api，用于获取目录树：</p>
<pre><code class="language-typescript">export class ControllerCategory extends BeanBase {
  @Web.get('getCategoryTree')
  async getCategoryTree() {
  }
}
</code></pre>
<ul>
<li>行2: 通过@Web.get定义一个api，path为getCategoryTree</li>
</ul>
<h2 id="5-查询目录树">5. 查询目录树</h2>
<p>一般而言，我们还需要创建一个Service，从而实现以下调用链：Controller-&gt;Service-&gt;Model-&gt;操作数据库。为了简化起见，在这里，我们直接在Controller中调用Model方法：</p>
<pre><code class="language-typescript">export class ControllerCategory extends BeanBase {
  @Web.get('getCategoryTree')
  async getCategoryTree() {
    const tree = await this.scope.model.category.select({
      columns: ['id', 'name'],
    });
    return tree;
  }
}
</code></pre>
<ul>
<li>行4: 通过<code>this.scope</code>取得Category Model，然后调用select方法
<ul>
<li>columns：指定要查询的字段列表</li>
</ul>
</li>
</ul>
<p>由于前面我们设置children关系为<code>autoload: true</code>，因此，查询结果<code>tree</code>就是一棵完整的目录树。下面我们看一下<code>tree</code>的类型推断效果：</p>
<p><img alt="1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165621079-1039551856.png" class="lazyload"></p>
<p><img alt="2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165628819-2043501211.png" class="lazyload"></p>
<h2 id="6-自动推断dto">6. 自动推断DTO</h2>
<p>现在我们自动推断DTO，并且设为API的返回数据的类型：</p>
<pre><code class="language-diff">export class ControllerCategory extends BeanBase {
  @Web.get('getCategoryTree')
+ @Api.body(v.array(v.object($Dto.get(() =&gt; ModelCategory, { columns: ['id', 'name'] }))))
  async getCategoryTree() {
    const tree = await this.scope.model.category.select({
      columns: ['id', 'name'],
    });
    return tree;
  }
}
</code></pre>
<ul>
<li>行3: 通过@Api.body定义API返回数据的类型：
<ul>
<li>v.array：定义数组类型</li>
<li>v.object：定义对象类型</li>
</ul>
</li>
<li>$Dto.get：动态推断DTO
<ul>
<li>参数1：指定目标Model</li>
<li>参数2：指定选项
<ul>
<li>columns：指定要提取的字段列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>同样，由于前面我们设置children关系为<code>autoload: true</code>，因此，<code>$Dto.get</code>生成的DTO就是一棵完整的目录树。下面我们看一下API的Swagger效果：</p>
<p><img alt="3" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165638869-354298901.png" class="lazyload"></p>
<p><img alt="4" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165645798-1911441351.png" class="lazyload"></p>
<p><img alt="5" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250805165652894-1679226419.png" class="lazyload"></p>
<p>从示意图中，我们可以清晰的看到，这棵树引用的children类型是名称为<code>demo-student.entity.category_2c7d642ee581efa300341e343180fbb0ecdc785d</code>的动态Entity的数组，从而形成一种递归的引用关系。</p>
<h2 id="7-封装dto">7. 封装DTO</h2>
<p>虽然我们已经实现了预期的目标，但是Vona ORM提供的能力还没有结束。我们可以创建一个新的DTO，将前面的代码<code>$Dto.get(() =&gt; ModelCategory, { columns: ['id', 'name'] })</code>封装起来，从而用于其他地方：</p>
<p>在VSCode中，可以通过右键菜单<code>Vona Create/Dto</code>创建DTO的代码骨架：</p>
<pre><code class="language-typescript">@Dto()
export class DtoCategoryTree {}
</code></pre>
<p>然后我们通过继承机制来封装DTO：</p>
<pre><code class="language-diff">@Dto()
export class DtoCategoryTree 
+ extends $Dto.get(() =&gt; ModelCategory, { columns: ['id', 'name'] }) {}
</code></pre>
<p>现在，我们再使用新创建的DTO来改造前面的API代码：</p>
<pre><code class="language-diff">export class ControllerCategory extends BeanBase {
  @Web.get('getCategoryTree')
+ @Api.body(v.array(v.object(DtoCategoryTree)))
+ async getCategoryTree(): Promise&lt;DtoCategoryTree[]&gt;{
    const tree = await this.scope.model.category.select({
      columns: ['id', 'name'],
    });
    return tree;
  }
}
</code></pre>
<ul>
<li>行3: 直接传入<code>DtoCategoryTree</code></li>
<li>行4: 返回类型为<code>Promise&lt;DtoCategoryTree[]&gt;</code></li>
</ul>
<h2 id="结语">结语</h2>
<p>Vonajs已开源：<a href="https://github.com/vonajs/vona" target="_blank" rel="noopener nofollow">https://github.com/vonajs/vona</a>。</p>
<p>Vonajs作者正在B站直播撰写技术文档，工作日每晚8:30，欢迎围观：<a href="https://space.bilibili.com/454737998" target="_blank" rel="noopener nofollow">濮水代码直播间</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-05 16:59">2025-08-05 16:58</span>&nbsp;
<a href="https://www.cnblogs.com/zhennann">濮水大叔</a>&nbsp;
阅读(<span id="post_view_count">80</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19023597);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19023597', targetLink: 'https://www.cnblogs.com/zhennann/p/19023597', title: 'Prisma不能优雅的支持DTO，试试Vona ORM吧' })">举报</a>
</div>
        