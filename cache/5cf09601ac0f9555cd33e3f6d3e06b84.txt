
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hihaojie/p/18697759/abnormal-use-z1v7wu8" title="发布于 2025-02-03 21:23">
    <span role="heading" aria-level="2">异常的使用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="异常的使用">异常的使用</h1>
<p>不管是网络还是出版读物，关于 C# 异常系统性的资料都比较少，我所在的工控领域也很少有开发者使用异常。异常实际上是一种非常好的机制，很值得推广。为此我根据过往的学习积累，结合一些项目经验，撰写本文。</p>
<h2 id="1-为什么应该使用异常">1. 为什么应该使用异常</h2>
<p>在开始本文之前，我们先看一下常用的几种“报告错误”的方式：</p>
<ul>
<li>方式一：返回错误码</li>
</ul>
<p>缺点：</p>
<ol>
<li>使用者不得不对返回值进行判断，导致“圈复杂度”增加；</li>
<li>如果方法需要返回值，返回内容不得不通过“out”参数传出。</li>
</ol>
<p>下面是一段伪代码，我们可以看到使用错误码有诸多不便：</p>
<pre><code class="language-c#">Client client = new Client();
if (client.Connect() == 1)
{
    if (client.Receive(out string content) == 1)
    {
        // 执行其他动作
    }
}

class Client
{
    public int Connect()
    {
        // 执行其他动作
        if (successeded)
        {
            // 执行成功，返回 1
            return 1;
        }
        else
        {
            // 执行失败，返回错误码
            return errorCode;
        }
    }

    public int Receive(out string result)
    {
        if (successeded)
        {
            result = result;
            return 1;
        }
        else
        {
            result = null;
            return errorCode;
        }
    }
}
</code></pre>
<ul>
<li>方式二：全局属性记录错误信息</li>
</ul>
<p>缺点：</p>
<ol>
<li>需要对全局属性进行判断，使用者很容易遗漏；</li>
<li>同样会造成“圈复杂度”增加。</li>
</ol>
<pre><code class="language-c#">Client value = new Client();
value.Connect();
if (value.ErrorCode == 1)
{
    string content = value.Receive();
    if (value.ErrorCode == 1)
    {
        // 执行其他动作
    }
}

class Client
{
    public int ErrorCode { get; private set; }
    public void Connect()
    {
        // 执行其他动作
        if (successeded)
        {
            // 执行成功，全局属性置为 1
            ErrorCode = 1;
            return;
        }
        else
        {
            // 执行失败，设置错误码
            ErrorCode = errorCode;
            return;
        }
    }

    public string Receive()
    {
        if (successeded)
        {
            ErrorCode = 1;
            return result;
        }
        else
        {
            ErrorCode = errorCode;
            return null;
        }
    }
}
</code></pre>
<p>上述两种机制不光使用繁琐，返回错误码在部分没有返回值的场景下还无法使用：</p>
<ul>
<li>构造函数执行失败</li>
<li>设置属性值执行失败</li>
</ul>
<p>而异常刚好可以弥补这些缺陷。</p>
<blockquote>
<p>Info</p>
<p>《框架设计指南》这本书对异常的好处进行了详细的阐释，我在这里进行引述（有删改）：</p>
<ul>
<li>
<p>异常与面向对象语言结合精密。就构造函数、运算符重载和属性而言，开发者无法选择返回值。出于这个原因，对于面向对象的框架来说，基于返回值的错误报告是不可能标准化的。</p>
</li>
<li>
<p>异常促进了 API 的一致性，因为它们只被设计用于错误报告。相比之下，返回值有很多用途，错误报告只是其中一个子集。出于这个原因，尽管异常可以被限制在特定的模式中，然而通过返回值报告错误的 API 很可能会利用大量的模式。Win32 API 就是这种不一致的一个典型例子：它使用了 BOOL、HRESULTS 和 GetLastError 等。</p>
</li>
<li>
<p>在基于返回值的错误报告中，错误处理代码总是被放置在靠近故障点的地方。然而，对于异常处理，应用程序的开发者可以有自己的选择，他们既可以在故障点附近捕获异常，也可以将错误处理代码集中在调用栈的更上方。</p>
</li>
<li>
<p>错误处理代码更容易被本地化。如果通过返回值报告错误的代码非常健壮，则往往意味着几乎每一行功能代码中都有一个 if 语句。这些 if 语句用于处理失败的情况。有了基于异常的错误报告，通常可以这样书写健壮的代码：顺序执行多个方法或操作，然后在 try 语法块后面按组去处理错误，甚至可以在调用栈更高层级位置处理错误。</p>
</li>
<li>
<p>错误码很容易被忽略掉，并且在大多数情况下都是如此。</p>
</li>
<li>
<p>异常携带的丰富信息可描述导致错误的原因。</p>
</li>
<li>
<p>异常允许面向未经处理异常的处理器。</p>
<p>这里的“未经处理异常的处理器”指诸如 <code>Application.DispatcherUnhandledException</code>​、<code>Application.ThreadException</code>​ 支持订阅全局的异常处理事件。</p>
</li>
<li>
<p>异常促进工具的发展。异常是一种定义明确的方法失败模型。正因为如此，调试器、分析器、性能计数器等工具才有可能密切关注异常。</p>
</li>
</ul>
</blockquote>
<h2 id="2-异常的使用示例">2. 异常的使用示例</h2>
<p>上一节的伪代码改为使用异常后如下：</p>
<pre><code class="language-c#">try
{
    Client value = new Client();
    value.Connect();
    string content = value.Receive();
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}

class Client
{
    public void Connect()
    {
        // 执行其他动作
        if (successeded)
        {
            return;
        }
        else
        {
            // 执行失败，抛出异常
            throw new InvalidOperationException("因...，连接失败。");
        }
    }

    public string Receive()
    {
        if (successeded)
        {
            return result;
        }
        else
        {
            throw new InvalidOperationException("因...，接受数据失败。");
        }
    }
}
</code></pre>
<p>前面我们还提到返回错误码无法在没有返回值的场景下使用，下面是在构造函数和属性 setter 中使用异常的一个简单示例：</p>
<pre><code class="language-c#">class Client
{
    public bool IsConnected { get; private set; }
    private string _hostname;
    private int _port;

    // 通过异常限制 Hostname 和 Port 只能在未连接状态下修改。
    public string Hostname
    {
        get =&gt; _hostname;
        set
        {
            if (IsConnected)
            {
                throw new InvalidOperationException("客户端处于连接状态，无法修改主机名称。");
            }
            _hostname = value;
        }
    }

    public int Port
    {
        get =&gt; _port;
        set
        {
            if (IsConnected)
            {
                throw new InvalidOperationException("客户端处于连接状态，无法修改端口。");
            }
            _port = value;
        }
    }

    public Client(string hostname, int port)
    {
        if (string.IsNullOrWhiteSpace(hostname))
        {
            throw new ArgumentException("参数无效。", nameof(hostname));
        }
        Hostname = hostname;
        Port = port;
    }

    public void Connect()
    {
        IsConnected = true;
    }
}
</code></pre>
<p>可以看到，通过异常反馈执行错误代码更为整洁，并且能通过异常的 <code>Message</code>​ 属性报告错误信息。</p>
<h2 id="3-应该抛出哪个异常">3. 应该抛出哪个异常？</h2>
<p>对于异常，简单使用并不复杂。但是异常的种类繁多，开发者常常困惑应该抛出哪个异常。异常和错误相关，错误一般分为两类：</p>
<ul>
<li>
<p>使用错误</p>
</li>
<li>
<p>执行错误</p>
<p>又分为两类：</p>
<ul>
<li>程序错误</li>
<li>系统失败</li>
</ul>
</li>
</ul>
<p><strong>使用错误</strong>：错误调用导致的错误，例如传入了 null 参数。此类错误不应该由框架处理，而应该修改调用方代码。</p>
<p>此类错误对应的常用异常有 3 个：</p>
<ul>
<li>​<code>ArgumentException</code>​：<code>ArgumentNullException</code>​ 和 <code>ArgumentOutOfRangeException</code>​ 的基类，用于表示传入的参数错误</li>
<li>​<code>ArgumentNullException</code>​：参数为空异常，当传入方法的参数为 null，应该抛出该异常</li>
<li>​<code>ArgumentOutOfRangeException</code>​：参数值超出范围异常，当传入方法的参数超过限定范围，应该抛出该异常</li>
</ul>
<p>下面是一个简单的示例：</p>
<pre><code class="language-c#">class Client
{
    public void Connect(string hostname, int port)
    {
        if (string.IsNullOrWhiteSpace(hostname))
        {
            throw new ArgumentException("参数无效。", nameof(hostname));
        }
        // 执行其他操作
    }
}
</code></pre>
<p><strong>执行错误-程序错误</strong>：可以在程序中处理的错误。如 <code>File.Open</code>​ 未找到相应文件抛出 <code>FileNotFoundException</code>​ 异常，我们可以创建一个新文件并继续运行。</p>
<p>此类错误对应的异常有很多，最常用的异常是：</p>
<ul>
<li>​<code>InvalidOperationException</code>​：对象处于不正确的状态时，抛出该异常</li>
</ul>
<p>下面是一个简单的示例：</p>
<pre><code class="language-c#">class Client
{
    public bool IsConnected { get; private set; }

    public void Connect()
    {
        if (IsConnected)
        {
            throw new InvalidOperationException("客户端已连接。");
        }
        // 其他操作
        IsConnected = true;
    }
}
</code></pre>
<p><strong>执行错误-系统失败</strong>：无法在程序中进行处理的执行错误。如即时编译器（Just-In-Time compiler）用尽了内存而引发的 <code>OutOfMemoryException</code>​。</p>
<p>此类错误对应的异常也有很多，但是这些异常都不应该由开发者抛出，而是由 CLR 负责。例如：</p>
<ul>
<li>​<code>OutOfMemoryException</code>​：内层分配失败时抛出该异常，只有 CLR 才能抛出该异常</li>
</ul>
<blockquote>
<p>Info</p>
<p>关于更多的异常分类，见<a href="https://www.cnblogs.com/hihaojie/p/18666342/chapter-7-2agy54" target="_blank">第7章 异常 - hihaojie - 博客园</a> 7.3 标准异常类型的使用</p>
</blockquote>
<h2 id="4-异常的捕捉">4. 异常的捕捉</h2>
<p>有抛出，自然有捕捉。异常的捕捉并不复杂，不过仍然有诸多细节需要注意。这里我们通过几个问题厘清异常的捕捉。我们假设有如下 <code>Connect()</code>​ 方法：</p>
<pre><code class="language-c#">void Connect(string hostname)
{
    if (hostname is null)
    {
        throw new ArgumentNullException(nameof(hostname));
    }
    // 执行其他操作
}
</code></pre>
<p>这里先提一点：<code>ArgumentException</code>​ 是 <code>ArgumentNullException</code>​ 和 <code>ArgumentOutOfRangeException</code>​ 的父类。</p>
<ul>
<li>问题一：如下三段代码，哪段可以通过编译？</li>
</ul>
<pre><code class="language-c#">// 代码1
try
{	    
    Connect(null!);
}
catch (ArgumentException ex)
{
    Console.WriteLine("捕捉到 ArgumentException 异常");
}
catch (ArgumentNullException ex)
{
    Console.WriteLine("捕捉到 ArgumentNullException 异常");
}
</code></pre>
<pre><code class="language-c#">// 代码2
try
{
    Connect(null!);
}
catch (ArgumentNullException ex)
{
    Console.WriteLine("捕捉到 Exception 异常");
}
catch (ArgumentException ex)
{
    Console.WriteLine("捕捉到 ArgumentException 异常");
}
</code></pre>
<pre><code class="language-c#">// 代码3
try
{
    Connect(null!);
}
catch (ArgumentNullException ex)
{
    Console.WriteLine("捕捉到 Exception 异常");
}
catch (ArgumentException ex)
{
    Console.WriteLine("捕捉到 ArgumentException 异常");
}
catch (InvalidOperationException ex)
{
    Console.WriteLine("捕捉到 InvalidOperationException 异常");
}
</code></pre>
<ul>
<li>问题二：如下代码会输出“捕捉到 ArgumentException 异常”吗？</li>
</ul>
<pre><code class="language-c#">try
{
    Connect(null!);
}
catch (ArgumentException ex)
{
    Console.WriteLine("捕捉到 ArgumentException 异常");
}
</code></pre>
<ul>
<li>问题三：如下代码会输出哪条信息？</li>
</ul>
<pre><code class="language-c#">try
{	      
    SentMessage("异常测试。");
}
catch (ArgumentException ex)
{
    Console.WriteLine("捕捉到 ArgumentException 异常");
}

void SentMessage(string message)
{
    try
    {
        Connect(null!);
    }
    catch (ArgumentOutOfRangeException ex)
    {
        Console.WriteLine("捕捉到 ArgumentOutOfRangeException 异常");
    }
}
</code></pre>
<p>‍</p>
<p>通过上述问题我们可以得出如下结论：</p>
<ol>
<li>
<p>要捕捉的异常存在父子关系时，需要子类异常在前，父类异常在后，否则无法编译；</p>
</li>
<li>
<p>子类异常可以通过捕捉父类异常完成捕捉；</p>
<p>​<code>Exception</code>​ 作为所有异常的基类，捕捉它可以捕获全部异常。</p>
</li>
<li>
<p>未捕获的异常会进一步向上抛出；</p>
</li>
</ol>
<p>‍</p>
<p>对应的，捕捉异常有这些惯例（准则）：</p>
<ol>
<li>处理方式相同的异常，可以捕获它们共同的父类；</li>
</ol>
<p>如“使用错误”异常（<code>ArgumentException</code>​ 三兄弟），它们的处理方式相同（应由调用者修改代码），可以直接捕获 <code>ArgumentException</code>​ 异常进行处理。</p>
<p>类似的还有 <code>OperationCanceledException</code>​ 和 <code>TaskCanceledException</code>​</p>
<ol start="2">
<li>只捕获知道如何处理的异常；</li>
</ol>
<p>对于未知的异常，应该进一步向上抛出，由上一级进行处理。</p>
<p>如下代码演示了处理已知异常 <code>TimeoutException</code>​，忽略未知异常 <code>ArgumentNullException</code>​</p>
<pre><code class="language-c#">try
{	    
    Connect(hostname);
}
catch (TimeoutException ex)
{
    Console.WriteLine("连接超时，尝试二次连接");
    Connect(hostname);
}

void Connect(string hostname)
{
    if (hostname is null)
    {
        throw new ArgumentNullException(nameof(hostname));
    }
    // 执行其他操作
    if (usedTime &gt; TimeSpan.FromSeconds(100))
    {
        throw new TimeoutException("连接用时超过 100s。");
    }
}
</code></pre>
<h2 id="5-异常的捕捉再抛出">5. 异常的捕捉、再抛出</h2>
<p>有时我们捕捉异常后并不想处理，而是想进行记录并二次抛出，或者将转为其他异常再抛出。我们先比较如下三段代码，看看它们的二次抛出有何不同：</p>
<pre><code class="language-c#">Exception holder = null;
try
{
    try
    {
        throw new Exception("原始异常");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.StackTrace);
        holder = ex;
        throw;
    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine(ex.StackTrace);
    Console.WriteLine(holder == ex);
}
</code></pre>
<pre><code class="language-c#">Exception holder = null;
try
{
    try
    {
        throw new Exception("原始异常");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.StackTrace);
        holder = ex;
        throw ex;
    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine(ex.StackTrace);
    Console.WriteLine(ex == holder);
}
</code></pre>
<pre><code class="language-c#">Exception holder = null;
try
{
    try
    {
        throw new Exception("原始异常");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.StackTrace);
        holder = ex;
        throw new Exception("二次抛出异常", ex);
    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine(ex.StackTrace);
    Console.WriteLine(holder == ex);
}
</code></pre>
<p>执行上述代码我们可以发现：</p>
<ul>
<li>直接使用 <code>throw</code>​ 二次抛出：<code>Exception.StackTrace</code>​ 属性会保留原始栈信息；</li>
<li>使用 <code>throw ex</code>​ 二次抛出：二次抛出的异常与原实例相同，但 <code>Exception.StackTrace</code>​ 存储的栈信息更新为二次抛出的位置；</li>
<li>使用 <code>throw new Exception()</code>​ 二次抛出：将异常进行了二次包装，<code>Exception.Message</code>​、<code>Exception.StrackTrace</code>​ 等诸多成员值都发生了变化。</li>
</ul>
<p>‍</p>
<p>我们可以根据需要采用相应的二次抛出方式，不过一般会遵循如下准则：</p>
<ol>
<li>若不需要二次包装异常，应直接使用 <code>throw</code>​ 二次抛出；</li>
<li>若需要二次包装异常，应使用 <code>throw new SomeException</code>​ 二次抛出异常，并将原异常传入新异常。</li>
</ol>
<p>‍</p>
<p>你可能对“并将原异常传入新异常”这句话感到困惑。这里我们看一下基类异常 <code>Exception</code>​ 的四个构造函数：</p>
<pre><code class="language-c#">public Exception();
public Exception(string message)
public Exception(string message, Exception innerException)
protected Exception(SerializationInfo info, StreamingContext context)
</code></pre>
<p>其中第三个构造函数 <code>Exception(string message, Exception innerException)</code>​ 需要一个 <code>Exception</code>​ 实例，是的，该参数是专门用于二次包装异常。当我们需要将原异常包装为其他异常时，需要将原异常实例通过该参数传入。二次包装时不传入该参数也是可以的，不过传入是标准做法，有利于开发者追溯原异常。下面是一个简单示例：</p>
<pre><code class="language-c#">try
{
    throw new TimeoutException("执行超时。");
}
catch (Exception ex)
{
    throw new InvalidOperationException("执行失败，请检查硬件状态。", ex);
}
</code></pre>
<h2 id="6-常见异常">6. 常见异常</h2>
<p>下面我们介绍一下常见的异常，以及它们的使用场景。</p>
<h3 id="61-基类异常">6.1 基类异常</h3>
<p>如下异常因表达的异常分类不明确，开发者不应抛出下列异常：</p>
<ul>
<li>​<code>Exception</code>​：基类异常，它是所有异常的基类。我们自定义异常时需要派生自该类或其子类。</li>
<li>​<code>ApplicationException</code>​ 和 <code>SystemException</code>​：设计之初，<code>SystemException</code>​ 的派生类用于表示 CLR（或系统）自身抛出的异常，<code>ApplicationException</code>​ 的派生类用于表示非 CLR 异常（应用程序异常）。但是很多异常类没有遵循这一模式，如 <code>TargetInvocationException</code>​ 派生自 <code>ApplicationException</code>​，却由 CLR 抛出。因此 <code>ApplicationException</code>​ 已失去原有意义。</li>
</ul>
<p>我们在自定义异常时，不再推荐以 <code>ApplicationException</code>​、<code>SystemException</code>​ 为基类。</p>
<h3 id="62-常用异常">6.2 常用异常</h3>
<ul>
<li>
<p>​<code>InvalidOperationException</code>​：如果对象处于不正确的状态，抛出该异常。</p>
<p>例如：往只读的 <code>FileStream</code>​ 写入数据。</p>
</li>
<li>
<p>​<code>ArgumentException</code>​、<code>ArgumentNullException</code>​、<code>ArgumentOutOfRangeException</code>​：用户传入错误参数时，要抛出 <code>ArgumentException</code>​ 或其派生类，并设置 <code>ParamName</code>​ 属性。如果可以，尽量选择位于继承层次末尾的异常类型。</p>
</li>
<li>
<p>​<code>OperationCanceledException</code>​、<code>TaskCanceledException</code>​：表示操作被取消。<code>TaskCanceledException</code>​ 用于异步编程，<code>OperationCanceledException</code>​ 可用于任意场景。</p>
<p>需要注意的是，在异步方法中手动抛出 <code>TaskCanceledException</code>​ 时，需要通过其构造函数传入 <code>CancellationToken</code>​，否则相应的 <code>Task</code>​ 的 <code>Status</code>​ 属性不会标记为 <code>Canceled</code>​</p>
</li>
<li>
<p>​<code>FormatException</code>​：表明文本解析方法中的输入字符串不符合要求或指定格式。</p>
</li>
<li>
<p>​<code>FileNotFoundException</code>​：表示文件未找到。</p>
</li>
<li>
<p>​<code>InvalidCastException</code>​：表示无效的类型转换，常见于强制转换、拆箱。</p>
<p>如下代码便会抛出该异常：</p>
<pre><code class="language-c#">object content = string.Empty;
int value = (int)content;
</code></pre>
</li>
<li>
<p>​<code>NotSupportedException</code>​：表示当前成员功能不支持。</p>
<p>以 <code>ReadOnlyCollection&lt;T&gt;</code>​ 为例，它不支持 <code>Add()</code>​ 方法，但又实现了 <code>IList&lt;T&gt;</code>​ 接口，因此它的 <code>Add()</code>​ 方法便抛出了该异常。</p>
</li>
<li>
<p>​<code>NotImplementedException</code>​：表示当前成员功能尚未实现。</p>
</li>
<li>
<p>​<code>TimeoutException</code>​：表示执行超时。因历史遗留原因，Web 通信超时并未抛出该异常。以 <code>WebRequest</code>​ 为例，它通信超时会抛出 <code>WebException</code>​ 异常，并令异常实例的 <code>Status</code>​ 属性值为 <code>WebExceptionStatus.Timeout</code>​ 枚举值。</p>
</li>
</ul>
<h3 id="63-clr-异常">6.3 CLR 异常</h3>
<p>这类异常通常由 CLR 抛出，开发者不应该使用这些异常。</p>
<ul>
<li>​<code>NullReferenceException</code>​、<code>IndexOutOfRangeException</code>​、<code>AccessViolationException</code>​：表示代码存在缺陷，需要开发者调整代码。</li>
<li>​<code>StackOverflowException</code>​：栈溢出时会抛出该异常，常见于无限递归。栈溢出时，几乎不可能让托管代码保持状态一致。发生该异常 CLR2.0 默认会让程序立即终止。开发者也不应该捕获该异常（是的，此时应该纵容程序崩溃）。</li>
<li>​<code>OutOfMemoryException</code>​：内存分配失败时会抛出该异常。</li>
</ul>
<h2 id="7-如何自定义异常">7. 如何自定义异常</h2>
<p>上一节我们讲了诸多预定义异常，当预定义异常不能满足我们的需要时，就需要自定义异常了。</p>
<p>自定义异常通常遵循如下准则：</p>
<ul>
<li>
<p>自定义异常应该派生自 <code>System.Exception</code>​ 或其他常用的基类异常；</p>
</li>
<li>
<p>继承层次不应该过深；</p>
</li>
<li>
<p>命名使用“Exception”后缀；</p>
</li>
<li>
<p>如果多种错误可以通过一种方式来处理，则它们应该属于同一类型的异常；</p>
</li>
<li>
<p>自定义异常应该至少有如下 4 个构造函数：</p>
<pre><code class="language-c#">public class SomeException : Exception, ISerializable
{
    public SomeException();
    public SomeExcepiton(string message);
    public SomeExcepiton(string message, Exception inner);

    // 序列化所需构造函数
    protected SomeException(SerializationInfo info, StreamingContext context);
}
</code></pre>
</li>
</ul>
<blockquote>
<p>Tips</p>
<p>关于自定义异常必须实现二进制序列化（即实现 <code>SomeException(SerializationInfo info, StreamingContext context)</code>​ 构造函数）在新版 .NET 中已不再要求，且 <code>Exception(SerializationInfo info, StreamingContext context)</code>​ 也被标记为了弃用（<code>[Obsolete]</code>​）。因此下面的例子忽略了二进制序列化的实现。</p>
</blockquote>
<p>‍</p>
<p>现在，我们假设有这么一个硬件设备：</p>
<ul>
<li>它是一个测距仪，计算机通过 TCP/IP 的方式与它通信（它是服务端）；</li>
<li>当它正在测量中，重复发送测量指令它不会进行响应（即会发生通信超时）；</li>
<li>如果测量的距离超出返回，它会返回“OutOfRange”字符串；</li>
<li>测量成功，则会返回数值，表示测得的距离。</li>
</ul>
<p>这里我们要自定义一个 <code>DeviceErrorException</code>​ 表示操作该硬件时的一切异常。请思考，该测距仪的类应该怎样定义？该异常又怎样定义？</p>
<p>‍</p>
<p>下面是我编写的一个测距仪类和对应的 <code>DeviceErrorException</code>​ 异常，大家可以作为参考：</p>
<pre><code class="language-c#">class Measurer
{
    private TcpClient _client;
    public bool IsConnected =&gt; _client != null &amp;&amp; _client.Connected;
    private const string Command = "Measure";
    private const string OutOfRangeResponse = "OutOfRange";

    public void Connect(string hostname, int port)
    {
        try
        {
            _client = new TcpClient(hostname, port);
        }
        catch (TimeoutException ex)
        {
            throw new DeviceErrorException("连接超时。", ex, DeviceState.Timeout);
        }
    }
  
    public double Measure()
    {
        try
        {
            if (!IsConnected)
            {
                throw new DeviceErrorException("测距仪尚未连接。请连接后再进行操作。", DeviceState.NotConnected);
            }

            byte[] writeBuffer = Encoding.ASCII.GetBytes(Command);
            Stream stream = _client.GetStream();
            _client.GetStream().Write(writeBuffer, 0, writeBuffer.Length);
        
            byte[] readBuffer = new byte[100];
            int count = stream.Read(readBuffer, 0, readBuffer.Length);
            string content = Encoding.ASCII.GetString(readBuffer, 0, count);
            if (content == OutOfRangeResponse)
            {
                throw new DeviceErrorException("数据读取失败，超出测量范围。", DeviceState.OutOfRange);
            }

            if (double.TryParse(content, out double result))
            {
                return result;
            }

            throw new DeviceErrorException($"转换数据失败。获取的内容为：[{content}]", DeviceState.DataParseError);
        }
        catch (TimeoutException ex)
        {
            throw new DeviceErrorException("通信超时。", ex, DeviceState.Timeout);
        }
        catch (DeviceErrorException)
        {
            throw;
        }
        catch (Exception ex)
        {
            throw new DeviceErrorException("未知异常。", ex);
        }
    }
}

class DeviceErrorException : InvalidOperationException
{
    public DeviceState State { get; }

    public DeviceErrorException() : this(DeviceState.Unknown)
    { }

    public DeviceErrorException(DeviceState state)
    {
        State = state;
    }
  
    public DeviceErrorException(string message) : this(message, DeviceState.Unknown)
    { }

    public DeviceErrorException(string message, DeviceState state) : base(message)
    {

        State = state;
    }
  
    public DeviceErrorException(string message, Exception innerException) : this(message, innerException, DeviceState.Unknown)
    { }
  
    public DeviceErrorException(string message, Exception innerException, DeviceState state) : base(message, innerException)
    {
        State = state;
    }
}

enum DeviceState
{
    Unknown,
    DataParseError,
    NotConnected,
    Timeout,
    OutOfRange,
}
</code></pre>
<h2 id="8-异常和性能">8. 异常和性能</h2>
<p>一些开发者不愿意使用异常的一个重要原因便是：影响性能（个人决定有点无稽之谈，至少在工控领域我觉得这点性能损失完全不必要担心）。</p>
<p>《框架设计指南》中提到：当抛出异常的频率高于每秒 100 个时，极有可能会带来显著的性能影响。此时我们可以使用“测试者-执行者模式”，或“Try 模式”，这两种模式在 .NET 中十分常见。</p>
<h3 id="81-测试者-执行者模式">8.1 测试者-执行者模式：</h3>
<p>我们以集合为例。以下代码我们并不知道 <code>numbers</code>​ 是否是只读集合，因此它有可能抛出 <code>NotSupportException</code>​：</p>
<pre><code class="language-c#">ICollection&lt;int&gt; numbers = ...
numbers.Add(1);
</code></pre>
<p>​<code>ICollection&lt;T&gt;</code>​ 刚好定义了 <code>IsReadOnly</code>​ 属性，我们可以先通过它判断集合是否是只读的，再进行 Add 操作：</p>
<pre><code class="language-c#">ICollection&lt;int&gt; numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
</code></pre>
<p>其中，<code>IsReadOnly</code>​ 是“测试者”，<code>Add()</code>​ 方法是“执行者”。</p>
<p>在“7. 如何自定义异常”中，我定义的 <code>Measurer</code>​ 类也添加了 <code>IsConnected</code>​ 属性，用于告知硬件是否已连接，这也是一种“测试者-执行者模式”。</p>
<blockquote>
<p>Notice</p>
<p>在多线程中使用该模式可能出现“竞态条件”，使用时要多加注意。</p>
</blockquote>
<h3 id="82-try-模式">8.2 Try 模式</h3>
<p>Try 模式的使用更加常见，如 <code>int.TryParse()</code>​、<code>Dictionary&lt;TKey, TValue&gt;.TryGetValu()</code>​ 等方法。</p>
<p>以 <code>DateTime</code>​ 的 Try 模式为例，大致形式如下：</p>
<pre><code class="language-c#">public struct DateTime
{
    public static DateTime Parse(string dateTime) { ... }
    public static DateTime TryParse(string dateTime, out DateTime Result) { ... }
}
</code></pre>
<p>Try 模式有诸多细节需要注意：</p>
<ul>
<li>
<p>如果成员在常用代码中都可能抛出异常，应使用 Try-Parse 模式避免因异常引起的性能问题。</p>
</li>
<li>
<p>Try-Parse 模式要使用“Try”前缀，用 bool 作为返回类型。</p>
</li>
<li>
<p>Try 方法返回 <code>false</code>​ 的原因只有一种，其余类的失败则要抛出异常。</p>
</li>
<li>
<p>要为 Try 方法提供等价抛出异常的方法。</p>
<p>如 <code>DateTime.TryParse()</code>​ 的等价方法 <code>DateTime.Parse()</code>​</p>
</li>
<li>
<p>要通过 out 参数，返回 Try 方法的值。</p>
</li>
<li>
<p>要在 Try 方法返回 false 时，将 default(T) 赋值给 out 参数。</p>
</li>
<li>
<p>避免在抛出异常时向 Try 方法的 out 参数写入数据。</p>
</li>
</ul>
<h2 id="9-怎么处理不知道如何处理的异常">9. 怎么处理“不知道如何处理”的异常</h2>
<p>当你调用的接口抛出了未知异常，应该怎么处理？答案可能出乎大多数人的意料：不要捕捉它，让程序崩溃是最好的解决方案。《框架设计指南》中有这么一段话：</p>
<blockquote>
<p>你的应用程序应该只处理它理解的那些异常。一般来说，在“某物”出问题之后，几乎不可能把应用程序从可能已被破坏的状态恢复到正常状态，此时只需处理那些你的应用程序可以合理响应的异常。对于其他所有的异常，无需处理，操作系统可中止你的应用程序。</p>
</blockquote>
<p>如果你认为当前应用程序已处于带病状态、它不应该继续运行，此时建议通过调用 <code>System.Enviroment.FailFast()</code>​ 方法来中止进程，而不是抛出异常。该方法接受一个 string 参数，我们可以通过该参数传递错误信息。这个错误信息最终会被操作系统记录在“计算机管理→系统工具→事件查看器→Windows 日志→应用程序”中。因未捕获异常导致的程序崩溃，其崩溃信息也会记录在此处。</p>
<p>最后，根据 Windows 日志信息，进一步排查程序崩溃原因，进行针对性修复。</p>
<p>​<code>Enviroment.FailFast()</code>​ 的用法如下：</p>
<pre><code class="language-C#">Enviroment.FailFast("发生了一个无法挽回的异常", ex)
</code></pre>
<h2 id="10-转移异常">10. 转移异常</h2>
<p>有时我们捕捉到异常并不想直接处理，又不想抛出，而是想转移至其他线程。使用一个字段/属性记录该异常，再在主线程抛出？不是很合适，这会破坏原有的调用栈信息。</p>
<p>.NET 早有预备，它提供了 <code>ExceptionDispatchInfo</code>​ 类，专门用于转移异常：</p>
<p>当从其他线程转移异常，或者 catch 后未使用空的 throw 语句再次抛出异常，要使用 <code>ExceptionDispatchInfo</code>​ 类，它会在重新抛出的过程中持续保存调用栈。下面是一个简单的用例：</p>
<pre><code class="language-C#">private ExceptionDispatchInfo _savedExceptionInfo;

private void BackgroundWorker() {
    try{
        ...
    } catch (Exception e){
        _savedExceptionInfo = ExceptionDispatchInfo.Capture(e);
    }
}

public object GetResult() {
    if(_done) {
        if(_savedExceptionInfo != null){
            _savedExceptionInfo.Throw();
            // 编译器无法理解该方法是抛出了一个异常，因此需要额外的return语句。
            return null;
        }
    }
}
</code></pre>
<h2 id="11-过滤异常">11. 过滤异常</h2>
<p>异常过滤器（exception filter）于 C#6 引入。通过异常过滤器我们可以重复捕获同类型异常：</p>
<pre><code class="language-csharp">catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{ ... }
catch (WebException ex) when (ex.Status == WebExceptionStatus.NameResolutionFailure)
{ ... }
</code></pre>
<p>when 子句中的布尔表达式可以包含副作用，例如调用一个方法记录诊断所需的异常的日志。</p>
<p>它的使用也有陷阱。试分析如下代码会发生什么：</p>
<pre><code class="language-c#">try
{	  
    throw new ArgumentException();
}
catch (ArgumentException ex) when (ex.ParamName == string.Empty)
{
    Console.WriteLine("命中第一个 when 子句");
}
catch (ArgumentException ex) when (ex.ParamName is null)
{
    Console.WriteLine("命中第二个 when 子句");
}
</code></pre>
<p>答案是：会输出“命中第二个 when 子句”。</p>
<p>你可能会疑惑：它不应该在第一个 when 字句那里抛出异常吗？毕竟 ParamName 属性未赋值，进行相等判断时应该抛出 <code>NullReferenceException</code>​ 才对。这是因为在过滤器中引发异常时，该异常由 CLR 捕获，并且该过滤器返回 false。该行为无法和过滤器执行并返回 false 区分开，因此很难进行调试。使用时要多加注意</p>
<h2 id="12-其他事项">12. 其他事项</h2>
<h3 id="121-切勿随意修改异常名称及其父类">12.1 切勿随意修改异常名称及其父类</h3>
<p>我们前面提到：</p>
<blockquote>
<p>处理方式相同的异常，可以捕获它们共同的父类</p>
</blockquote>
<p>这意味着我们不应该随意修改自定义异常的基类，否则原有的异常处理代码无法正常工作。以如下代码为例，因基类异常由 <code>InvalidOperationException</code>​ 改为 <code>Exception</code>​，原有的异常处理代码不再起作用：</p>
<pre><code class="language-c#">// 原异常
// class MyException : InvalidOperationException { }
// 修改基类后的异常
class MyException : Exception { }

// 原本可以正常运作的异常处理代码失效
try
{	    
    throw new MyException();
}
catch (InvalidOperationException ex)
{
    Console.WriteLine("捕捉到 InvalidOperationException 或其子类异常");
}
</code></pre>
<h3 id="122-捕捉后仍会向上抛出的异常threadabortexception">12.2 捕捉后仍会向上抛出的异常：<code>ThreadAbortException</code>​</h3>
<p>提到多线程显然离不开 <code>Thread</code>​。<code>Thread</code>​ 的 <code>Abort()</code>​ 方法用于终止相应线程，被终止的线程会抛出 <code>ThreadAbortException</code>​ 异常。不过该异常较为特别，捕捉后会继续向上抛出。试分析如下代码，会发生什么：</p>
<pre><code class="language-c#">Thread thread = new Thread(DoSomething);
thread.Start();
Thread.Sleep(100);
thread.Abort();

void DoSomething()
{
    try
    {
        try
        {
            while (true)
            {
                Thread.Sleep(20);
            }
        }
        catch (ThreadAbortException ex)
        {
            Console.WriteLine("第一次捕获到 ThreadAbortException 异常");
        }
    }
    catch (ThreadAbortException ex)
    {
        Console.WriteLine("第二次捕获到 ThreadAbortException 异常");
    }
}
</code></pre>
<p>答案是：它会依次输出“第一次捕获到 ThreadAbortException 异常”、“第二次捕获到 ThreadAbortException 异常”。若想终止该异常进一步向外抛出，需调用 <code>Thread.ResetAbort()</code>​ 方法，它会将线程状态（<code>ThreadState</code>​）从 <code>AbortRequested</code>​ 恢复至 <code>Running</code>​。</p>
<hr>
<p>参考文献：</p>
<ol>
<li>《框架设计指南：构建可复用.NET库的约定、惯例与模式》第三版</li>
<li>《C#7.0 核心技术指南》</li>
</ol>
<blockquote>
<p>Info</p>
<p>上述两本书的部分内容，可参阅我的阅读笔记<a href="https://www.cnblogs.com/hihaojie/p/18660776" target="_blank">阅读笔记目录汇总 - hihaojie - 博客园</a></p>
</blockquote>
<p>‍</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7048290088171296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-03 21:25">2025-02-03 21:23</span>&nbsp;
<a href="https://www.cnblogs.com/hihaojie">hihaojie</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18697759" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18697759);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18697759', targetLink: 'https://www.cnblogs.com/hihaojie/p/18697759/abnormal-use-z1v7wu8', title: '异常的使用' })">举报</a>
</div>
        