
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sunhy2012/p/18699391" title="发布于 2025-02-05 14:33">
    <span role="heading" aria-level="2">P1787 [入门赛 #22]非众数 Hard Version 题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="p1787-入门赛-22非众数-hard-version-题解">P1787 [入门赛 #22]非众数 Hard Version 题解</h1>
<p><a href="https://www.luogu.com.cn/problem/P1787" target="_blank" rel="noopener nofollow">原题传送门</a></p>
<p>这里对 pjh0625 的题解进行了详细解释</p>
<h3 id="1-读题">1. 读题</h3>
<p>题目要求计算给定字符串中非众数子串的数量。<br>
<strong>非众数子串</strong> 的定义是：子串中出现次数最多的字符的频率不超过子串长度的一半。<br>
<strong>非众数串</strong> 的定义是：一个字符串 <code>s</code> 中，没有任何字符的出现次数超过字符串长度的一半。</p>
<h3 id="2-解题思路">2. 解题思路</h3>
<p>直接暴力解法（遍历所有子串并判断）的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，在 <span class="math inline">\(n \le 10^5\)</span> 的数据范围内会超时。因此，我们需要一种更高效的算法 —— <strong>树状数组（Binary Indexed Tree, BIT）</strong>。</p>
<ul>
<li>
<p><strong>树状数组的作用</strong>：</p>
<ul>
<li>树状数组可以高效地维护和查询前缀和，时间复杂度为 <span class="math inline">\(O(\log n)\)</span>。</li>
<li>通过树状数组，我们可以快速统计子串中某个字符的频率。</li>
</ul>
</li>
<li>
<p><strong>离散化处理</strong>：</p>
<ul>
<li>为了处理负数索引问题，我们将每个字符的频率和位置信息离散化为正整数。</li>
<li>具体来说，对于每个字符 <code>c</code>，我们使用 <span class="math inline">\(2 \times \text{sum} - j + n\)</span> 作为树状数组的索引，其中 <code>sum</code> 是当前字符的频率，<code>j</code> 是当前索引。</li>
</ul>
</li>
<li>
<p><strong>动态计算众数子串</strong>：</p>
<ul>
<li>对于每个字符（a 到 z），遍历字符串中的每个位置。</li>
<li>使用树状数组统计以该字符为“众数”的子串数量。</li>
<li>最终，通过总子串数量减去众数子串数量，得到非众数子串的数量。</li>
</ul>
</li>
</ul>
<h3 id="3-代码逻辑">3. 代码逻辑</h3>
<ul>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>输入字符串并计算其长度。</li>
<li>初始化树状数组 <code>t</code> 和众数子串数量 <code>cnt</code>。</li>
</ul>
</li>
<li>
<p><strong>遍历每个字符（a 到 z）</strong>：</p>
<ul>
<li>对于每个字符 <code>c</code>，初始化树状数组并计算其频率。</li>
<li>遍历字符串中的每个位置 <code>j</code>，动态更新树状数组。</li>
</ul>
</li>
<li>
<p><strong>动态更新树状数组</strong>：</p>
<ul>
<li>如果当前字符是目标字符，频率 <code>sum</code> 加 1。</li>
<li>使用树状数组查询当前子串的贡献，并更新众数子串数量 <code>cnt</code>。</li>
<li>更新树状数组，将当前频率和位置信息离散化后存入树状数组。</li>
</ul>
</li>
<li>
<p><strong>计算非众数子串数量</strong>：</p>
<ul>
<li>总子串数量为 <span class="math inline">\(\frac{n(n + 1)}{2}\)</span>。</li>
<li>非众数子串数量 = 总子串数量 - 众数子串数量。</li>
</ul>
</li>
</ul>
<h3 id="4-代码分析">4. 代码分析</h3>
<ul>
<li><strong>变量定义</strong>：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 3e5 + 5;
typedef long long ll;
int n, t[maxn]; // n 为字符串长度，t 为树状数组
ll cnt; // 用于记录众数子串的数量
char s[maxn];
</code></pre>
<ul>
<li><strong>自定义函数：</strong></li>
</ul>
<pre><code>inline int lowbit(int x) { return x &amp; -x; }
// 更新树状数组
inline void gx(int x) {
	for (; x &lt;= n * 3; x += lowbit(x)) t[x]++;
}
// 查询树状数组的前缀和
inline int cx(int x, int res = 0) {
	for (; x; x -= lowbit(x)) res += t[x];
	return res;
}
</code></pre>
<ul>
<li><strong>输入字符串及获取长度（已进入主函数）：</strong></li>
</ul>
<pre><code>scanf("%s", s + 1);
n = strlen(s + 1);
</code></pre>
<p>用 cin 和 cout 的同学加上这两句：</p>
<pre><code>// 关闭同步不流，为 cin 和 cout 加速
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
</code></pre>
<ul>
<li><strong>遍历每个字符（a - z）：</strong></li>
</ul>
<pre><code>for (int i = 0; i &lt; 26; i++) {
	memset(t, 0, sizeof t); // 初始化树状数组
	int sum = 0; // 当前字符的频率
	// 遍历字符串中的每个位置
	for (int j = 0; j &lt;= n; j++) {
		if (s[j] == i + 'a') sum++; // 如果当前字符是目标字符，频率加一
		// 计算当前子串的贡献
		// 2 * sum - j + n 是离散化后的值，用于避免负数
		cnt += cx(2 * sum - j + n);
		// 更新树状数组
		gx(2 * sum - j + n + 1);
	}
}
</code></pre>
<ul>
<li><strong>输出及结束：</strong></li>
</ul>
<pre><code>// 总子串数量 - 众数子串数量 = 非众数子串数量
printf("%lld", 1ll * (n + 1) * n / 2 - cnt);
return 0; // 养成好习惯,比赛时可别忘了
</code></pre>
<h3 id="5-代码展示">5. 代码展示</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 3e5 + 5;
typedef long long ll;
int n, t[maxn]; // n 为字符串长度，t 为树状数组
ll cnt; // 用于记录众数子串的数量
char s[maxn];

// 计算树状数组的 lowbit
inline int lowbit(int x) { return x &amp; -x; }
// 更新树状数组
inline void gx(int x) {
    for (; x &lt;= n * 3; x += lowbit(x)) t[x]++;
}
// 查询树状数组的前缀和
inline int cx(int x, int res = 0) {
    for (; x; x -= lowbit(x)) res += t[x];
    return res;
}

int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    // 遍历每个字符（a-z）
    for (int i = 0; i &lt; 26; i++) {
        memset(t, 0, sizeof t); // 初始化树状数组
        int sum = 0; // 当前字符的频率
        // 遍历字符串中的每个位置
        for (int j = 0; j &lt;= n; j++) {
            if (s[j] == i + 'a') sum++; // 如果当前字符是目标字符，频率加一
            // 计算当前子串的贡献
            // 2 * sum - j + n 是离散化后的值，用于避免负数
            cnt += cx(2 * sum - j + n);
            // 更新树状数组
            gx(2 * sum - j + n + 1);
        }
    }
    // 总子串数量 - 众数子串数量 = 非众数子串数量
    printf("%lld", 1ll * (n + 1) * n / 2 - cnt);
    return 0; // 养成好习惯
}
</code></pre>
<p><a href="https://www.luogu.com.cn/record/200199025" target="_blank" rel="noopener nofollow">通过记录</a></p>
<p>看在<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/959g8lds.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/0dxn7ms2.png" alt="" loading="lazy"><br>
的份上，点个赞走吧！！！</p>
<p><s>管理员大大<a href="https://www.luogu.com.cn/paste/zc8w2b39" target="_blank" rel="noopener nofollow">看在我改了这么多遍的情况下</a>给过了吧</s><br>
<s>咱也算是熟人了</s></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.40631358623958336" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-05 14:34">2025-02-05 14:33</span>&nbsp;
<a href="https://www.cnblogs.com/sunhy2012">sunhy2012</a>&nbsp;
阅读(<span id="post_view_count">44</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18699391" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18699391);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18699391', targetLink: 'https://www.cnblogs.com/sunhy2012/p/18699391', title: 'P1787 [入门赛 #22]非众数 Hard Version 题解' })">举报</a>
</div>
        