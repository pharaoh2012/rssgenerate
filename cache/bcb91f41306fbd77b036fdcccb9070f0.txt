
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/209jkjkjk/p/18669760" title="发布于 2025-01-14 09:38">
    <span role="heading" aria-level="2">VisionMaster SDK C# 控制台应用 二次开发 代码示例</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>本文主要是个人开发经验，实用为主。可能有不严谨之处，欢迎指正</p>
<h2 id="开发环境准备">开发环境准备</h2>
<p>对于控制台应用，其实只要从 VisionMaster4.x.x\Development\V4.x\ComControls\Assembly 中引入相关包即可，不用像其它教程里拷贝各种wpf winform组件</p>
<p>唯一要注意的是在 VisionMaster4.x.x\Development\V4.x\ComControls\Assembly\3rdLib\Log4Net中，有一个log4Net.config<br>
需要和最终程序在一起，并且相对路径保持一致（3rdLib\Log4Net）。否则控制台会有警告（但其实也无所谓）<br>
只能说海康做的有点差，把Log4net绑定的太死</p>
<p>此外一般来说，引入VM.Core和VM.PlatformSDKCS即可</p>
<h2 id="重要参考资料">重要参考资料</h2>
<ol>
<li>软件里的帮助文档 <img src="https://img2024.cnblogs.com/blog/2079516/202501/2079516-20250114082427505-55895355.png" alt="" loading="lazy"></li>
<li>更重要的是在路径 VisionMaster4.x.x\Development\V4.x\Documentations 中 VisionMaster算法平台SDK开发指南V4.x.x(.NET)。该文档可以一览各种工具类的属性和函数</li>
</ol>
<h2 id="打开项目">打开项目</h2>
<pre><code class="language-C#">// 打开项目
VmSolution.Load("xxx.sol");
Console.WriteLine(VmSolution.Instance.GetSolutionVersion("xxx.sol", "")); // 获取方案版本号
</code></pre>
<h2 id="设置全局变量">设置全局变量</h2>
<pre><code class="language-C#">// 设置全局变量
GlobalVariableModuleTool globalVar = (GlobalVariableModuleTool)VmSolution.Instance["全局变量1"]; // 获取全局变量对象
globalVar.SetGlobalVar("失败图片文件名", "失败_" + DateTime.Now.ToString("yyyyMMddHHmmss"));
globalVar.SetGlobalVar("成功图片文件名", "成功_" + DateTime.Now.ToString("yyyyMMddHHmmss"));
</code></pre>
<h2 id="获得各组件的引用">获得各组件的引用</h2>
<p>注意这里的xxTool直接用是没有的，需要从 VisionMaster4.x.x\Development\V4.x\ComControls\Assembly 中引入。<br>
例如：从 ImageSourceModuleCs.dll 中引入 ImageSourceModuleTool<br>
从 IMVSBlobFindModu.dll 中引入 IMVSBlobFindModuTool<br>
从 SaveImageCs.dll 中引入 SaveImageTool</p>
<pre><code class="language-C#">// 获得相关工具，以备设置
VmProcedure process = (VmProcedure)VmSolution.Instance["流程1"];
ImageSourceModuleTool input1 = (ImageSourceModuleTool)VmSolution.Instance["流程1.输入1"];
IMVSBlobFindModuTool blob分析 = (IMVSBlobFindModuTool)VmSolution.Instance["流程1.blob分析"];
SaveImageTool output1 = (SaveImageTool)VmSolution.Instance["流程1.blob输出1"];
SaveImageTool output2 = (SaveImageTool)VmSolution.Instance["流程1.blob输出2"];
</code></pre>
<h2 id="输入-注意事项">输入 注意事项</h2>
<p>这里踩了很多坑，首先有两种方式，一种是指定路径读图，另一种是从内存中通过byte数组给图<br>
此外，给出通用模块参数设置，防止一些意外</p>
<pre><code class="language-C#">// ImageSourceModuleTool tool
tool.ResetParam();
// 设置SDK取图方式
tool.ModuParams.ImageSourceType = ImageSourceParam.ImageSourceTypeEnum.SDK;
// 输出Mono8格式，后面的模块要用
tool.ModuParams.OutMono8 = true;    // 要开启输出Mono8否则后面的模块可能会出错
</code></pre>
<ol>
<li>byte数组输入</li>
</ol>
<pre><code class="language-C#"> // 打开bmp图片
var bmp = new Bitmap(Pictest2);
var bmpBytes = bmpToBytes(bmp); // 这里只是举个例子，具体byte[]怎么来的请各显神通

VmProcedure process = (VmProcedure)VmSolution.Instance["流程1"];
ImageSourceModuleTool input1 = (ImageSourceModuleTool)VmSolution.Instance["流程1.状态1输入"];
// 设置输入1
input1.ModuParams.ImageSourceType = ImageSourceParam.ImageSourceTypeEnum.SDK;
input1.ModuParams.OutMono8 = true;
input1.ModuParams.PixelFormat = ImageSourceParam.PixelFormatEnum.MONO8;
input1.SetImageData(new ImageBaseData(bmpBytes, (uint)bmpBytes.Length, bmp.Width, bmp.Height, (int)PixelFormatF.MONO8));
</code></pre>
<p>bmpToBytes函数参考（代码来自于网络）</p>
<pre><code class="language-C#">private static byte[] bmpToBytes(Bitmap bmp)
    {
        // 获取图像的像素数据
        BitmapData bitmapData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height),
            ImageLockMode.ReadOnly, bmp.PixelFormat);

        // 计算Byte[]数组的大小
        int bytesCount = bitmapData.Stride * bitmapData.Height;
        byte[] bytes = new byte[bytesCount];

        // 将像素数据复制到Byte[]数组
        Marshal.Copy(bitmapData.Scan0, bytes, 0, bytesCount);

        // 释放资源
        bmp.UnlockBits(bitmapData);

        // 输出Byte[]数组
        return bytes;
    }
</code></pre>
<ol start="2">
<li>指定图像路径输入<br>
就是最后一句改为用SetImagePath函数，（经测试，输入方式要选择LocalImage</li>
</ol>
<pre><code class="language-C#">VmProcedure process = (VmProcedure)VmSolution.Instance["流程1"];
ImageSourceModuleTool input1 = (ImageSourceModuleTool)VmSolution.Instance["流程1.状态1输入"];
// 设置输入1
input1.ModuParams.ImageSourceType = ImageSourceParam.ImageSourceTypeEnum.LocalImage;
input1.ModuParams.OutMono8 = true;
input1.ModuParams.PixelFormat = ImageSourceParam.PixelFormatEnum.MONO8;
input1.SetImagePath(Pictest2);
</code></pre>
<h2 id="输出-注意事项">输出 注意事项</h2>
<p>踩了很多坑，建议参考如下代码</p>
<pre><code class="language-C#">// SaveImageTool tool
tool.ResetParam();
// 存图使能，必须开
tool.ModuParams.SaveImageEnable = true;
// 不创建目录，否则会出现日期格式的多级目录
tool.ModuParams.GenerateDir = false;
// 渲染图缓存数量1，即立刻保存（应该是这个意思吧，没试过
tool.ModuParams.RenderImgCache = 1;
// 保存间隔为1，即每一张都保存（应该是这个意思吧，没试过
tool.ModuParams.StorageInterval = 1;
// 渲染图输出
tool.ModuParams.RenderImgEnable = true;
// 保存格式 SaveImageParam.PixelFormatEnum format
tool.ModuParams.PixelFormat = format;
// 渲染图输出路径
tool.ModuParams.RenderImgPath = @"xxx\xxx\";
</code></pre>
<p>设置文件名，得通过全局变量间接处理。<br>
<img src="https://img2024.cnblogs.com/blog/2079516/202501/2079516-20250114093603354-174105882.png" alt="" loading="lazy"></p>
<h2 id="执行一次">执行一次</h2>
<pre><code class="language-C#">VmProcedure process = (VmProcedure)VmSolution.Instance["流程1"];
process.Run();
</code></pre>
<h2 id="获取识别模块的结果">获取识别模块的结果</h2>
<p>主要是要参考SDK开发手册，从ModuResult中读取</p>
<pre><code class="language-C#">// 读取Blob数量
blob分析1.ModuResult.BlobNum
</code></pre>
<h2 id="不完整的整体代码">不完整的整体代码</h2>
<pre><code class="language-C#">// 打开项目
VmSolution.Load(sol项目);
Console.WriteLine(VmSolution.Instance.GetSolutionVersion(sol项目, "")); // 获取方案版本号
// 打开bmp图片(模拟SDK取图)
// 略不重要

// 设置全局变量
GlobalVariableModuleTool globalVar = (GlobalVariableModuleTool)VmSolution.Instance["全局变量1"]; // 获取全局变量对象
globalVar.SetGlobalVar("状态正_失败图片文件名", "状态正失败" + DateTime.Now.ToString("yyyyMMddHHmmss"));
globalVar.SetGlobalVar("状态倒_失败图片文件名", "状态倒失败" + DateTime.Now.ToString("yyyyMMddHHmmss"));

// 获得相关工具，以备设置
VmProcedure process = (VmProcedure)VmSolution.Instance["流程1"];
ImageSourceModuleTool 全亮input = (ImageSourceModuleTool)VmSolution.Instance["流程1.输入_全亮"];
ImageSourceModuleTool 输入类型1 = (ImageSourceModuleTool)VmSolution.Instance["流程1.输入1"];
ImageSourceModuleTool 输入类型2 = (ImageSourceModuleTool)VmSolution.Instance["流程1.输入2"];
IMVSBlobFindModuTool blob分析1 = (IMVSBlobFindModuTool)VmSolution.Instance["流程1.blob分析1"];
IMVSBlobFindModuTool blob分析2 = (IMVSBlobFindModuTool)VmSolution.Instance["流程1.blob分析2"];
SaveImageTool output1 = (SaveImageTool)VmSolution.Instance["流程1.blob输出1"];
SaveImageTool output2 = (SaveImageTool)VmSolution.Instance["流程1.blob输出2"];

// 设置输入
// 请参考上面的输入要点

// 设置输出
// 请参考上面的输出要点

// 运行
process.Run();
// 打印结果
Console.WriteLine("状态1" + blob分析1.ModuResult.BlobNum);
Console.WriteLine("状态2" + blob分析2.ModuResult.BlobNum);
Console.WriteLine(process.Name + "success");
</code></pre>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.9820822906284722" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-15 14:46">2025-01-14 09:38</span>&nbsp;
<a href="https://www.cnblogs.com/209jkjkjk">卢晓春</a>&nbsp;
阅读(<span id="post_view_count">66</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18669760" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18669760);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18669760', targetLink: 'https://www.cnblogs.com/209jkjkjk/p/18669760', title: 'VisionMaster SDK C# 控制台应用 二次开发 代码示例' })">举报</a>

		</p>
	