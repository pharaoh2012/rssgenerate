
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Silenceneo-xw/p/18817323" title="发布于 2025-04-09 20:38">
    <span role="heading" aria-level="2">Codeforces Round 1016 (Div. 3)题解</span>
    

</a>

        </h2>
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="题目地址">题目地址</h1>
<p><a href="https://codeforces.com/contest/2093" target="_blank" rel="noopener nofollow">https://codeforces.com/contest/2093</a></p>
<h1 id="锐评">锐评</h1>
<p>在所有题意都理解正确的情况下，整体难度不算太难。但是偏偏存在F这么恶心的题意，样例都不带解释一下的，根本看不懂题。D题也恶心，在于递归过程的拆分，需要点数学，跟打印递归定义的图形一样，写麻了，好在过了。E题居然卡双 <span class="math inline">\(log\)</span> 做法常数，也是恶心。反而是G题很典，太裸了，可惜被D防住了，根本没看到G题。再次陷入“看完所有题不会写，不看完所有题却会写”的魔咒。主要还是自己太菜了，打破不了这个魔咒，大佬们就没这个烦恼。</p>
<h1 id="题解">题解</h1>
<h2 id="problem-a-ideal-generator">Problem A. Ideal Generator</h2>
<h3 id="题目大意">题目大意</h3>
<p>由 <span class="math inline">\(k\)</span> 个正整数组成的数组 <span class="math inline">\(a\)</span> 在 <span class="math inline">\([a_1, a_2, \dots, a_k] = [a_k, a_{k-1}, \dots, a_1]\)</span> 的情况下称为回文数组（其实就是正着读反着读是一样的）。例如，数组 <span class="math inline">\([1, 2, 1]\)</span> 和 <span class="math inline">\([5, 1, 1, 5]\)</span> 是回文数组，而数组 <span class="math inline">\([1, 2, 3]\)</span> 和 <span class="math inline">\([21, 12]\)</span> 不是回文数组。</p>
<p>如果任何整数 <span class="math inline">\(n\)</span> ( <span class="math inline">\(n \geq k\)</span> ) 都可以表示为一个长度正好为 <span class="math inline">\(k\)</span> 的回文数组的元素之和，我们就称这个数 <span class="math inline">\(k\)</span> 为理想生成数。数组中的每个元素都必须大于 <span class="math inline">\(0\)</span> 。</p>
<p>例如，数字 <span class="math inline">\(1\)</span> 是一个理想生成数，因为任何自然数 <span class="math inline">\(n\)</span> 都可以用数组 <span class="math inline">\([n]\)</span> 生成。然而，数字 <span class="math inline">\(2\)</span> 并不是一个理想生成数，因为不存在长度为 <span class="math inline">\(2\)</span> 的和为 <span class="math inline">\(3\)</span> 的回文数组。</p>
<p>请判断给定的数字 <span class="math inline">\(k\)</span> 是否是理想生成数。</p>
<h3 id="题解思路思维">题解思路：思维</h3>
<p>先通过样例观察，发现奇数可以，偶数不行。开始验证，假如和为 <span class="math inline">\(k\)</span> ，那么全部数组元素为 <span class="math inline">\(1\)</span> 即可，假如和为 <span class="math inline">\(k + 1\)</span> ，那么全部数组元素为 <span class="math inline">\(1\)</span> 的基础上，有一个数要加上 <span class="math inline">\(1\)</span> 还要是回文数组，那么只能放在最中间的位置上了，不然所放位置对称的那一个位置就不相等了。又因为 <span class="math inline">\(n\)</span> 是连续的，所以差值为 <span class="math inline">\(1\)</span> 只有数组长度是奇数才能满足，每次都在最中间位置加上 <span class="math inline">\(1\)</span> 。时间复杂度为 <span class="math inline">\(O(1)\)</span> 。</p>
<h3 id="参考代码c">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n;

void solve() {
    cin &gt;&gt; n;
    cout &lt;&lt; ((n &amp; 1) ? "YES\n" : "NO\n");
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-b-expensive-number">Problem B. Expensive Number</h2>
<h3 id="题目大意-1">题目大意</h3>
<p>正整数 <span class="math inline">\(n\)</span> 的代价被定义为数字 <span class="math inline">\(n\)</span> 除以其数位之和的结果。</p>
<p>例如，数字 <span class="math inline">\(104\)</span> 的代价是 <span class="math inline">\(\frac{104}{1 + 0 + 4} = 20.8\)</span> ，数字 <span class="math inline">\(111\)</span> 的代价是 <span class="math inline">\(\frac{111}{1 + 1 + 1} = 37\)</span> 。</p>
<p>给你一个不包含前导零的正整数 <span class="math inline">\(n\)</span> 。你可以从数字 <span class="math inline">\(n\)</span> 中删除任意数位(包括不删除)，这样剩下的数字至少包含一位数，并且<strong>严格大于零</strong>。剩下的数字<strong>不能重新排列</strong>。因此，你<strong>可能</strong>得到一个前导为零的数字。</p>
<p>例如，给你一个数字 <span class="math inline">\(103554\)</span> 。如果去掉 <span class="math inline">\(1\)</span> 、 <span class="math inline">\(4\)</span> 和一个数字 <span class="math inline">\(5\)</span> ，最后得到的数字是 <span class="math inline">\(035\)</span> ，其代价是 <span class="math inline">\(\frac{035}{0 + 3 + 5} = 4.375\)</span> 。</p>
<p>为了使代价最小，你需要从这个数字中删除最少多少个数字？</p>
<h3 id="题解思路贪心">题解思路：贪心</h3>
<p>首先，一个数字的数位之和是不可能大于这个数字的，最多和它相等。那么代价最小意味着什么？显然就是相等。所以只有一位数字时代价达到最小，代价为 <span class="math inline">\(1\)</span> 。因为题目删除数位后允许有前导 <span class="math inline">\(0\)</span> ，所以选定某个数字前面的 <span class="math inline">\(0\)</span> 可以不删除。又因为题目要求删除后组成的这个数必须严格大于 <span class="math inline">\(0\)</span> ，所以我们要找一个非 <span class="math inline">\(0\)</span> 数位。因为前导 <span class="math inline">\(0\)</span> 可以保留，后导 <span class="math inline">\(0\)</span> 不能保留（保留就不是个位数了），所以我们倒着枚举，找到第一个非 <span class="math inline">\(0\)</span> 数位位置，将这个位置前面的非 <span class="math inline">\(0\)</span> 数位删除以及后面的数位删除，删除的数位个数即是答案。时间复杂度为 <span class="math inline">\(O(n)\)</span> 。</p>
<h3 id="参考代码c-1">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
string str;

void solve() {
    cin &gt;&gt; str;
    int n = str.size();
    int id = n - 1;
    for (int i = n - 1; i &gt;= 0; --i)
        if (str[i] != '0') {
            id = i;
            break;
        }
    int ans = n - 1 - id;
    for (int i = id - 1; i &gt;= 0; --i)
        if (str[i] != '0')
            ++ans;
    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-c-simple-repetition">Problem C. Simple Repetition</h2>
<h3 id="题目大意-2">题目大意</h3>
<p>帕夏喜欢质数！为了找到生成质数的新方法，他再次对互联网上的一种算法产生了兴趣：</p>
<ul>
<li>要得到一个新数字 <span class="math inline">\(y\)</span> ，重复 <span class="math inline">\(k\)</span> 次数字 <span class="math inline">\(x\)</span> 的十进制表示 <span class="math inline">\(x\)</span> (不含前导零)。</li>
</ul>
<p>例如， <span class="math inline">\(x = 52\)</span> 和 <span class="math inline">\(k = 3\)</span> 可以得到 <span class="math inline">\(y = 525252\)</span> ， <span class="math inline">\(x = 6\)</span> 和 <span class="math inline">\(k = 7\)</span> 可以得到 <span class="math inline">\(y = 6666666\)</span> 。</p>
<p>帕夏非常希望得到的数字 <span class="math inline">\(y\)</span> 是质数，但他还不知道如何检验这种算法生成的数字的质性。请帮助帕夏，告诉他 <span class="math inline">\(y\)</span> 是否是质数！</p>
<blockquote>
<p>如果一个整数 x 只有 2 个不同的除数 1 和 x ，那么这个整数 x 就是质数。例如， 13 是质数，因为它只有 2 个除数： 1 和 13 。请注意，数字 1 不是质数，因为它只有一个除数。</p>
</blockquote>
<h3 id="题解思路思维分类讨论">题解思路：思维/分类讨论</h3>
<p>我们来一一分析下。</p>
<ul>
<li><span class="math inline">\(k = 1\)</span> ，显然只需要判定 <span class="math inline">\(x\)</span> 是否质数。</li>
<li><span class="math inline">\(k \gt 1\)</span> ，即 <span class="math inline">\(x\)</span> 至少重复了 <span class="math inline">\(2\)</span> 次，设 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(n\)</span> 个数位，那么 <span class="math inline">\(y\)</span> 显然有一个除数 <span class="math inline">\(x\)</span> ，使得 <span class="math inline">\(\frac{y}{x} = a_1 \underbrace{0 \cdots 0}_{n - 1个} a_2 \underbrace{0 \cdots 0}_{n - 1个} \dots a_k\)</span> ，其中 <span class="math inline">\(a_i = 1, 1 \leq i \leq k\)</span> 。那么只要  <span class="math inline">\(1 \lt x \lt y\)</span> ， <span class="math inline">\(y\)</span> 必然不是质数，显然 <span class="math inline">\(x \lt y\)</span> 必然成立，所以只需要再单独判断一下 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(1\)</span> 的情况即可。</li>
</ul>
<p>根据上面的分析，问题得解。时间复杂度为 <span class="math inline">\(O(1)\)</span> 。</p>
<h3 id="参考代码c-2">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, m;

bool check(int x) {
    if (x &lt; 2)
        return false;
    for (int i = 2; i * i &lt;= x; ++i)
        if (x % i == 0)
            return false;
    return true;
}

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    if (m == 1)
        cout &lt;&lt; (check(n) ? "YES\n" : "NO\n");
    else if (n == 1) {
        int x = 0;
        for (int i = 0; i &lt; m; ++i)
            x = x * 10 + 1;
        cout &lt;&lt; (check(x) ? "YES\n" : "NO\n");
    } else
        cout &lt;&lt; "NO\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-d-skibidi-table">Problem D. Skibidi Table</h2>
<h3 id="题目大意-3">题目大意</h3>
<p>瓦迪姆喜欢用整数填充方形表格。不过今天他想到了一个好玩的方法！以大小为 <span class="math inline">\(2 \times 2\)</span> 的表格为例，表格的行从上到下编号，列从左到右编号。我们将 <span class="math inline">\(1\)</span> 置于左上角单元格， <span class="math inline">\(2\)</span> 置于右下角单元格， <span class="math inline">\(3\)</span> 置于左下角单元格， <span class="math inline">\(4\)</span> 置于右上角单元格。这就是他所需要的全部乐趣！</p>
<p>幸运的是，瓦迪姆有一个大小为 <span class="math inline">\(2^n \times 2^n\)</span> 的表格。他计划用从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2^{2n}\)</span> 的整数按升序填满它。为了填满这样一个大表，瓦迪姆将把它分成 <span class="math inline">\(4\)</span> 个相等的方表，先填满左上角的表，然后填满右下角的表，接着填满左下角的表，最后填满右上角的表。在填满每张小方表的过程中，他又会把每张小方表分割成更小的表，直到填满 <span class="math inline">\(2 \times 2\)</span> 大小的方表为止。</p>
<p>现在瓦迪姆迫不及待地想开始填表，但是他有两类 <span class="math inline">\(q\)</span> 个问题：</p>
<ul>
<li>第 <span class="math inline">\(x\)</span> 行第 <span class="math inline">\(y\)</span> 列的单元格中的数字是多少</li>
<li>数字 <span class="math inline">\(d\)</span> 位于哪个单元格坐标</li>
</ul>
<p>帮助回答瓦迪姆的问题。</p>
<h3 id="题解思路dfs">题解思路：DFS</h3>
<p>题意倒是很直接，思路也很明确，就是不断DFS缩小区域。但是这个区域怎么设计还真是恶心，会的很会，不会的真的会卡很久，看群友有被卡两小时的。</p>
<p>首先对于块的大小，假如当前处于第 <span class="math inline">\(n\)</span> 层，块的大小为 <span class="math inline">\(2^{n - 1} \times 2^{n - 1}\)</span> ，即是宽高各减一半。其次是对于坐标步长，根据前面分析（宽高各减一半），可知步长就是 <span class="math inline">\(2^{n - 1}\)</span> 。知道这两个性质就好办了，只需要知道当前处于第几层，以及当前层的左上角坐标，即可一步步缩小范围，直到不能再缩小，即是答案，详见代码。时间复杂度为 <span class="math inline">\(O(nq)\)</span> 。</p>
<h3 id="参考代码c-3">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
int n, q;

ll dfs1(int cur, int l, int r, int x, int y) {
    // cout &lt;&lt; "dfs1:" &lt;&lt; cur &lt;&lt; ':' &lt;&lt; l &lt;&lt; ':' &lt;&lt; r &lt;&lt; ':' &lt;&lt; x &lt;&lt; ':' &lt;&lt; y &lt;&lt; '\n';
    if (l == x &amp;&amp; r == y)
        return 1;
    ll dt = 1LL &lt;&lt; (cur - 1);
    ll dd = dt * dt;
    if (x &gt;= l + dt &amp;&amp; y &gt;= r + dt)
        return dd + dfs1(cur - 1, l + dt, r + dt, x, y);
    if (x &gt;= l + dt)
        return (dd &lt;&lt; 1) + dfs1(cur - 1, l + dt, r, x, y);
    if (y &gt;= r + dt)
        return 3 * dd + dfs1(cur - 1, l, r + dt, x, y);
    return dfs1(cur - 1, l, r, x, y);
}

pii dfs2(int cur, int l, int r, ll d) {
    // cout &lt;&lt; "dfs2:" &lt;&lt; cur &lt;&lt; ':' &lt;&lt; l &lt;&lt; ':' &lt;&lt; r &lt;&lt; ':' &lt;&lt; d &lt;&lt; '\n';
    if (d == 1)
        return {l, r};
    ll dt = 1LL &lt;&lt; (cur - 1);
    ll dd = dt * dt;
    if (d &gt; 3 * dd)
        return dfs2(cur - 1, l, r + dt, d - 3 * dd);
    if (d &gt; (dd &lt;&lt; 1))
        return dfs2(cur - 1, l + dt, r, d - (dd &lt;&lt; 1));
    if (d &gt; dd)
        return dfs2(cur - 1, l + dt, r + dt, d - dd);
    return dfs2(cur - 1, l, r, d);
}

void solve() {
    cin &gt;&gt; n &gt;&gt; q;
    string op;
    int x, y;
    ll d;
    while (q--) {
        cin &gt;&gt; op;
        if (op == "-&gt;") {
            cin &gt;&gt; x &gt;&gt; y;
            cout &lt;&lt; dfs1(n, 1, 1, x, y) &lt;&lt; '\n';
        } else {
            cin &gt;&gt; d;
            pii ans = dfs2(n, 1, 1, d);
            cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; '\n';
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-e-min-max-mex">Problem E. Min Max MEX</h2>
<h3 id="题目大意-4">题目大意</h3>
<p>给你一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 和一个数字 <span class="math inline">\(k\)</span> 。</p>
<p>子数组的定义是数组中一个或多个连续元素的序列。你需要将数组 <span class="math inline">\(a\)</span> 分割成 <span class="math inline">\(k\)</span> 个不重叠的子数组 <span class="math inline">\(b_1, b_2, \dots, b_k\)</span> ，使得这些子数组的合集等于整个数组。此外，你需要最大化 <span class="math inline">\(x\)</span> 的值，即 <span class="math inline">\(x = \min(MEX(b_i)), 1 \leq i \leq k\)</span> 。</p>
<p><span class="math inline">\(MEX(v)\)</span> 表示数组 <span class="math inline">\(v\)</span> 中没有的最小非负整数。</p>
<h3 id="题解思路二分">题解思路：二分</h3>
<p>对于 <span class="math inline">\(u = MEX(v)\)</span> ，如果选择数组 <span class="math inline">\(v\)</span> 的一部分数组成数组 <span class="math inline">\(vt\)</span> ，那么对于所有 <span class="math inline">\(w \lt u\)</span> ，是否都能找到 <span class="math inline">\(w = MEX(vt)\)</span> ？答案是肯定的。所以我们考虑二分，下限 <span class="math inline">\(l = 0\)</span> ，上限 <span class="math inline">\(r = n\)</span> （因为数组顶多是 <span class="math inline">\([0, 1, \dots, n - 1]\)</span> ）。那么我们怎么去check呢？对于 <span class="math inline">\(MEX\)</span> 为 <span class="math inline">\(u\)</span> ，我们只需要维护一个集合，然后遍历整个数组，对于每个元素，满足 <span class="math inline">\(a_i \lt u, 0 \leq i \lt n\)</span> ，就将其加入集合，当集合元素个数达到了 <span class="math inline">\(u\)</span> ，然后计数加一（表示可以划分为一个子数组，满足 <span class="math inline">\(MEX \geq u\)</span>），并且清空当前集合。这样到最后，只要计数大于等于 <span class="math inline">\(k\)</span> ，表示可以合理划分。时间复杂度为 <span class="math inline">\(O(nlognlogn)\)</span> （check用到了set，换成数组每次标记取反可以降到 <span class="math inline">\(O(nlogn)\)</span> ）。</p>
<p>PS：此题居然卡双 <span class="math inline">\(log\)</span> 做法常数，真是无语啊！</p>
<h3 id="参考代码c-4">参考代码（C++）</h3>
<p>双 <span class="math inline">\(log\)</span> 超时代码。</p>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
const int maxn = 200'005;
int a[maxn];
int n, m;

bool check(int x) {
    set&lt;int&gt; st;
    for (int i = 0; i &lt; x; ++i)
        st.insert(i);
    if (st.empty())
        return true;
    set&lt;int&gt; stc;
    int cnt = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (a[i] &lt; x)
            stc.insert(a[i]);
        if (stc.size() == st.size()) {
            ++cnt;
            stc.clear();
            if (cnt &gt;= m)
                return true;
        }
    }
    return cnt &gt;= m;
}

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; ++i)
        cin &gt;&gt; a[i];
    int l = 0, r = n + 1, ans = -1;
    while (l &lt;= r) {
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else
            r = mid - 1;
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<p>双 <span class="math inline">\(log\)</span> 通过代码。</p>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
const int maxn = 200'005;
int a[maxn];
int n, m;

bool check(int x) {
    set&lt;int&gt; st;
    int cnt = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (a[i] &lt; x)
            st.insert(a[i]);
        if (st.size() == x) {
            ++cnt;
            st.clear();
            if (cnt &gt;= m)
                return true;
        }
    }
    return cnt &gt;= m;
}

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; ++i)
        cin &gt;&gt; a[i];
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else
            r = mid - 1;
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<p>单 <span class="math inline">\(log\)</span> 通过代码。</p>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
const int maxn = 200'005;
int a[maxn];
bool vis[maxn];
int n, m;

bool check(int x) {
    for (int i = 0; i &lt; x; ++i)
        vis[i] = false;
    bool f = true;
    int cnt = 0, cur = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (a[i] &lt; x) {
            if (vis[a[i]] != f) {
                ++cur;
                vis[a[i]] = f;
            }
        }
        if (cur == x) {
            ++cnt;
            cur = 0;
            f = !f;
            if (cnt &gt;= m)
                return true;
        }
    }
    return cnt &gt;= m;
}

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; ++i)
        cin &gt;&gt; a[i];
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else
            r = mid - 1;
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-f-hackers-and-neural-networks">Problem F. Hackers and Neural Networks</h2>
<h3 id="题目大意-5">题目大意</h3>
<p>黑客们再次试图利用神经网络的输出创建娱乐短语。这一次，他们想获得长度为 <span class="math inline">\(n\)</span> 的字符串数组 <span class="math inline">\(a\)</span> 。</p>
<p>最初，他们有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(c\)</span> ，其中充满了空白，用符号 <span class="math inline">\(*\)</span> 表示。因此，如果 <span class="math inline">\(n = 4\)</span> ，则初始值为 <span class="math inline">\(c=[*, *, *, *]\)</span> 。</p>
<p>黑客可以访问 <span class="math inline">\(m\)</span> 个神经网络，每个神经网络都有自己的请求答案版本--长度为 <span class="math inline">\(n\)</span> 的字符串数组 <span class="math inline">\(b_i\)</span> 。</p>
<p>黑客试图通过以下操作从数组 <span class="math inline">\(c\)</span> 中获取数组 <span class="math inline">\(a\)</span> ：</p>
<ul>
<li>
<p>选择神经网络 <span class="math inline">\(i\)</span> ，对数组 <span class="math inline">\(c\)</span> 执行下一步操作：选择一个<strong>随机</strong>的<strong>空白</strong>，例如在位置 <span class="math inline">\(j\)</span> 处，将 <span class="math inline">\(c_j\)</span> 替换为 <span class="math inline">\(b_{i, j}\)</span> 。</p>
<p>例如，如果选择了第一个神经网络 <span class="math inline">\(b_1 = [\text{«I»}, \text{«love»}, \text{«apples»}]\)</span> ，当前 <span class="math inline">\(c = [*, \text{«like»}, *]\)</span> ，那么在对第一个神经网络进行操作后， <span class="math inline">\(c\)</span> 可能会变成 <span class="math inline">\([\text{«I»}, \text{«like»}, *]\)</span> 或 <span class="math inline">\([*, \text{«like»}, \text{«apples»}]\)</span> 。</p>
</li>
<li>
<p>选择位置 <span class="math inline">\(j\)</span> 并将 <span class="math inline">\(c_j\)</span> 替换为空白。</p>
</li>
</ul>
<p>不幸的是，由于黑客访问神经网络的方式，他们只能在所有操作完成后才能看到修改后的数组 <span class="math inline">\(c\)</span> ，因此他们必须事先指定整个操作序列。</p>
<p>然而，神经网络的随机行为可能会导致永远无法获得所需的数组，或者获得所需的数组需要过多的操作。</p>
<p>因此，黑客们希望您能帮助他们选择一个操作序列，以保证在最少的操作次数内获得数组 <span class="math inline">\(a\)</span> 。</p>
<p>更具体地说，如果存在一个操作序列可以<strong>保证</strong>从数组 <span class="math inline">\(c\)</span> 中获得数组 <span class="math inline">\(a\)</span> ，那么在所有这样的序列中，找出一个操作次数<strong>最少</strong>的序列，并输出其中的操作次数。</p>
<p>如果没有将数组 <span class="math inline">\(c\)</span> 转换成数组 <span class="math inline">\(a\)</span> 的操作序列，则输出 <span class="math inline">\(-1\)</span> 。</p>
<h3 id="题解思路贪心-1">题解思路：贪心</h3>
<p>题意真的很长且很拉，真的看完好像不知道要求什么？让我们再细细品味一下！反正就是进行两个操作嘛，只要对应位置的字符串不对就一定要继续操作。只要操作，那么操作次数必然会增加。</p>
<p>假如某个操作后，某个位置已经是正确的，下一次操作你会不会去改它？显然不会了，不然你还得再至少进行一次操作二以及至少随机一次操作一，而且随机后不一定是对的，何必呢？</p>
<p>如果所有位置都是空的，你会不会进行操作二？显然也不会，白白浪费一次操作嘛。所以第一次操作肯定是操作一，这是个随机过程。</p>
<p>通过上面的分析，我们唯一能决定的就是可以选择跑哪个神经网络。从概率论角度来说，我们当然希望选择命中概率更高的，这样所得的期望就越大，后续所需要的操作就更少。所以第一次操作就至关重要了，我们就选命中概率最大的神经网络，这样我们就能保证 <span class="math inline">\(n\)</span> 次操作后，随机正确位置最大。这样所有位置都被填满了，最后对不正确的位置，我们只需要先执行一次操作二，再找到一个神经网络，其对应位置存在正确字符串，因为只会空白位置随机，而当前空白位置只有一个，显然这是一个必然事件。</p>
<p>上面操作一定是最优的吗？一定的。假设你选择某个神经网络的命中率是 <span class="math inline">\(\frac{x}{y}\)</span> ，你把其他所有的神经网络全部组合起来，命中率形如 <span class="math inline">\(\frac{x + a}{y + b}\)</span> ，其不可能更大。</p>
<p>对于不存在的情况，显然所有对应位置都没有目标串，就无法做到。时间复杂度为 <span class="math inline">\(O(mn \max(|b_{i, j}|))\)</span> 。</p>
<h3 id="参考代码c-5">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
const int maxn = 505;
string p[maxn], str[maxn][maxn];
int cntr[maxn], cntc[maxn];
int n, m;

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; p[i];
        cntc[i] = 0;
    }
    for (int i = 0; i &lt; m; ++i) {
        cntr[i] = 0;
        for  (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; str[i][j];
            if (str[i][j] == p[j]) {
                ++cntc[j];
                ++cntr[i];
            }
        }
    }
    for (int i = 0; i &lt; n; ++i)
        if (cntc[i] == 0) {
            cout &lt;&lt; "-1\n";
            return;
        }
    int maxc = 0;
    for (int i = 0; i &lt; m; ++i)
        maxc = max(maxc, cntr[i]);
    cout &lt;&lt; (n + ((n - maxc) &lt;&lt; 1)) &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
<h2 id="problem-g-shorten-the-array">Problem G. Shorten the Array</h2>
<h3 id="题目大意-6">题目大意</h3>
<p>长度为 <span class="math inline">\(m\)</span> 的数组 <span class="math inline">\(b\)</span> 的美感定义为所有可能数对 <span class="math inline">\(1 \leq i \leq j \leq m\)</span> 中的 <span class="math inline">\(\max(b_i \oplus b_j)\)</span> ，其中 <span class="math inline">\(x \oplus y\)</span> 是数字 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的 <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR" target="_blank" rel="noopener nofollow">bitwise XOR</a>。我们将数组 <span class="math inline">\(b\)</span> 的美感表示为 <span class="math inline">\(f(b)\)</span> 。</p>
<p>如果数组 <span class="math inline">\(b\)</span> 中有 <span class="math inline">\(f(b) \geq k\)</span> ，那么这个数组 <span class="math inline">\(b\)</span> 就叫做美丽数组。</p>
<p>最近，科斯佳从商店买了一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 。他认为这个数组太长了，所以打算从中剪切出一些美丽的子数组。也就是说，他想选择数字 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> ( <span class="math inline">\(1 \leq l \leq r \leq n\)</span> )，这样数组 <span class="math inline">\(a_{l \dots r}\)</span> 就很美丽了。这样一个子数组的长度为 <span class="math inline">\(r - l + 1\)</span> 。整个数组 <span class="math inline">\(a\)</span> 也被视为一个子数组(包含 <span class="math inline">\(l = 1\)</span> 和 <span class="math inline">\(r = n\)</span> )。</p>
<p>你的任务是找出数组 <span class="math inline">\(a\)</span> 中最短的美丽子数组的长度。如果没有一个子数组是美丽的，那么你应该输出数字 <span class="math inline">\(-1\)</span> 。</p>
<h3 id="题解思路双指针字典树trie">题解思路：双指针+字典树Trie</h3>
<p>首先，对于每个 <span class="math inline">\(l\)</span> ，如果找到第一个满足条件的 <span class="math inline">\(r(r \geq l)\)</span> ，那么显然 <span class="math inline">\(r + 1(r \lt n)\)</span> 也可以。既然这样，那么我们维护一个双指针，对于每个左指针，不断扩展右指针，直到找到第一个满足条件的位置，更新答案即可。那么怎么快速计算出当前区间是否可以满足条件呢？很容易就会想到<strong>字典树</strong>求当前区间可以得到的最大异或值。时间复杂度为 <span class="math inline">\(O(n)\)</span> （计算次数实际为 <span class="math inline">\(30n\)</span> ，常数忽略，但实际运行时间还是要考虑的）。</p>
<h3 id="参考代码c-6">参考代码（C++）</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
const int maxn = 200'005;
const int maxnode = 6'000'005;
const int sigma_size = 2;
struct trie {
    int child[maxnode][sigma_size];
    int value[maxnode];
    int size;

    void init() {
        size = 1;
        memset(child[0], 0, sizeof(child[0]));
    }

    void insert(int x, int y) {
        int pos = 0;
        for (int i = 29; i &gt;= 0; --i) {
            int id = (x &gt;&gt; i) &amp; 1;
            if (!child[pos][id]) {
                memset(child[size], 0, sizeof(child[size]));
                value[size] = 0;
                child[pos][id] = size++;
            }
            pos = child[pos][id];
            value[pos] += y;
        }
    }

    int query(int x) {
        // cout &lt;&lt; "query: " &lt;&lt; x &lt;&lt; '\n';
        int pos = 0, ans = 0;
        for (int i = 29; i &gt;= 0; --i) {
            int id = (x &gt;&gt; i) &amp; 1;
            int idx = id ^ 1;
            int p = child[pos][idx];
            if (p &amp;&amp; value[p]) {
                ans |= 1 &lt;&lt; i;
                pos = p;
            } else {
                p = child[pos][id];
                if (p &amp;&amp; value[p])
                    pos = p;
                else
                    return -1;
            }
        }
        // cout &lt;&lt; "query: ans = " &lt;&lt; ans &lt;&lt; '\n';
        return ans;
    }
} tr;
int a[maxn];
int n, m;

void solve() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; ++i)
        cin &gt;&gt; a[i];
    if (m == 0) {
        cout &lt;&lt; "1\n";
        return;
    }
    tr.init();
    int l = 0, r = 0, ans = n + 1;
    while (r &lt; n) {
        // cout &lt;&lt; l &lt;&lt; ", " &lt;&lt; r &lt;&lt; endl;
        while (r &lt; n &amp;&amp; tr.query(a[r]) &lt; m)
            tr.insert(a[r++], 1);
        if (r &lt; n)
            ans = min(ans, r - l + 1);
        tr.insert(a[l++], -1);
        if (l &gt; r)
            r = l;
    }
    cout &lt;&lt; (ans == n + 1 ? -1 : ans) &lt;&lt; '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    本文为博主原创文章，转载请注明出处：http://www.cnblogs.com/Silenceneo-xw/
</div>
<div class="clear"></div>

        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.7392014950405092" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-09 20:38">2025-04-09 20:38</span>&nbsp;
<a href="https://www.cnblogs.com/Silenceneo-xw">Silenceneo</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18817323" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18817323);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18817323', targetLink: 'https://www.cnblogs.com/Silenceneo-xw/p/18817323', title: 'Codeforces Round 1016 (Div. 3)题解' })">举报</a>

        </p>
    