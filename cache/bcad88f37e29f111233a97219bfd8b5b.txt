
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18684303" title="发布于 2025-01-22 09:25">
    <span role="heading" aria-level="2">DeepSeek V3 两周使用总结</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.021017960400462964" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 10:15">2025-01-22 09:25</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">117</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18684303" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18684303);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18684303', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18684303', title: 'DeepSeek V3 两周使用总结' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>2024 年 12 月 26 日，杭州深度求索人工智能基础技术研究有限公司发布 DeepSeek-V3 大模型。官方宣称：（1）基于自研的 MoE 模型和 671B 参数，在 14.8T token 上进行了预训练；（2）多项评测成绩超越了 Qwen2.5 - 72B 和 Llama - 3.1 - 405B 等其他开源模型，在性能上与世界顶尖的闭源模型 GPT-4o 以及 Claude-3.5-Sonnet 不分伯仲。个人自 2025 年 1 月 3 日开始试用，至今两周零两天，以下是使用过程中的心得体会与经验总结，仅供参考。</p>
<p>DeepSeek V3 免费使用地址：<a href="https://chat.deepseek.com/" target="_blank" rel="noopener nofollow">https://chat.deepseek.com/</a></p>
<h2 id="一先说结论">一、先说结论</h2>
<p>以下结论仅针对免费使用版（非开源版）：</p>
<p>（1）<strong>优点</strong>：整体回答效果优于 GPT-4o（GPT-4o 温度设置为 0.8，下同）。</p>
<p>（2）<strong>不足</strong>：给出错误答案的概率高于 GPT-4o。</p>
<p>（3）<strong>适用范围</strong>：相比 GPT-4o，DeepSeek V3 更适合用于解答开放式问题。对于较为具体的细节问题，两者各有优势，GPT-4o 更保守且更可靠，DeepSeek 广度和维度更高但也更容易出错。建议根据实际需求选用或两者参照使用。</p>
<p>（4）<strong>个人选择</strong>：目前在日常工作中，开放性问题以 DeepSeek V3 为主、GPT4-o 为辅；细节问题则对照两者使用，且仍以 DeepSeek V3 的回答为主并二次验证。</p>
<h2 id="二使用过程">二、使用过程</h2>
<h3 id="1-一天尝鲜试用---确实不错">1. 一天尝鲜试用 - 确实不错</h3>
<p>1 月 3 日周五，在上班路上刷阮一峰的 <a href="https://www.ruanyifeng.com/blog/2025/01/weekly-issue-332.html" target="_blank" rel="noopener nofollow">科技爱好者周刊（第 332 期）：西蒙·威利森的年终总结，梁文锋的访谈</a>。看到阮大师分享及推荐了 DeepSeek V3，而后在朋友圈也看到一些推荐和分享。当天是周五，组内有<a href="https://www.cnblogs.com/zengzuo613/p/18104431" target="_blank">新技术探索</a>安排，于是我抱着好奇、尝鲜、<strong>怀疑</strong>和谨慎的态度测试了一下，看看 DeepSeek V3 是否真如宣传所说那么好？</p>
<p>我承认刚开始我是怀疑的，以为又是个嘴炮，毕竟类似的事情遇到不少，前几天刚被 Logback 坑了，<a href="https://logback.qos.ch/performance.html" target="_blank" rel="noopener nofollow">Logback 官方自称其性能远高于 Log4j2</a>，实际上只是在某个时间点（2021 年），在特定配置和特定版本下的<a href="https://github.com/ceki/logback-perf" target="_blank" rel="noopener nofollow">极限测试结果</a>，且其测试基准不符合实际生产环境需求，比如将 FileAppender 的 immediateFlush 设置为 false，所以无实际指导性意义。时至今日，两者真实性能已截然不同，在当前最新版本和相同配置下，两者性能总体相当，甚至在部分场景下 Logback 性能反而不如 Log4j2，向作者反馈后，他仍旧选择了沉默，更别说同步更新或撤销<a href="https://logback.qos.ch/performance.html" target="_blank" rel="noopener nofollow">Logback 性能说明文档</a>。</p>
<p>由于之前有多次类似工作，积累了不少 CASE，于是选取了其中部分典型的研发 CASE，以 GPT-4o 为基准，快速测试及验证。</p>
<p><strong>当时的结果及初步结论如下：</strong></p>
<p>（1）DeepSeek V3 在研发技术方面的回答效果略好于 GPT-4o，得分为 106.5 分（以 GPT-4o 为基线，总分为 100 分）。</p>
<p>（2）官方文档比较简陋，WEB 页面功能少，设计和交互体验一般。</p>
<p>（3）部分问答结果感觉是在 GPT-4 基础之上做了升华和补充，有些怀疑其使用了 GPT-4 的训练数据。网络上也有类似的声音：<a href="https://baijiahao.baidu.com/s?id=1819855537769519169&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener nofollow">DeepSeek 把自己误认成了 ChatGPT？分析人士称，或用了 GPT 生成文本做训练数据</a>。</p>
<p><strong>部分测试 CASE 如下：</strong></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>问题</strong></th>
<th><strong>DeepSeek V3 回答评分（GPT-4o 为 10 分）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>以下内容是否包含敏感信息：XXX</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>Ingress 中可以配置超时时间为 30ms 么</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>Java 中使用 Thread.sleep() 设置等待时间可能有误差么</td>
<td>11</td>
</tr>
<tr>
<td>4</td>
<td>微服务架构有哪些组成部分？在 Java 中有哪些实现方案，应该如何选型？</td>
<td>11</td>
</tr>
<tr>
<td>5</td>
<td>ts 中如何避免滥用 any 类型</td>
<td>12</td>
</tr>
<tr>
<td>6</td>
<td>wrk2 解决了 wrk 哪些不足</td>
<td>11</td>
</tr>
<tr>
<td>7</td>
<td>Maven enforce 插件解决什么问题？有哪些功能？</td>
<td>12</td>
</tr>
<tr>
<td>8</td>
<td>Java 中如何评估一个方法的性能？</td>
<td>12</td>
</tr>
<tr>
<td>9</td>
<td>js 中如何获取用户网络情况？</td>
<td>10.5</td>
</tr>
<tr>
<td>10</td>
<td>基于 snowflake 算法，使用 Java 实现分布式 id</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong> 以上 CASE 仅供参考，评分结果依赖个人主观评价。由于大语言模型先天存在幻觉问题，无法保证答案及其效果的可重复性。</p>
<h3 id="2-一周进阶使用---缺点很致命">2. 一周进阶使用 - 缺点很致命</h3>
<p>尝鲜后，感觉 DeepSeek V3 确实不错，远超预期。不过心中仍有所保留，国产大模型（含商业版）各个都说自己不亚于 GPT-4，但实际使用来看，暂时还没有综合实力比 GPT-4 强的产品。此外，既然 DeepSeek V3 效果比 GPT-4o 好，是否应该将其作为我日常工作的第一 LLM？我不可能长时间将同一问题，同时向 GPT-4o 和 DeepSeek 发问，而后细看两者回答，最后再取长补短。所以本阶段我将日常工作中遇到的各类问题，同时向 DeepSeek V3 和 GPT-4o 提问，通过对比两者效果，以帮助我更客观和更全面地判断两者优劣，便于我未来二选一。</p>
<p><strong>使用总结：</strong></p>
<p>（1）DeepSeek V3 的问答效果波动性较大，不靠谱的概率较高，好的时候比 GPT-4 好不少，差的时候则各种瞎说。</p>
<p><strong>举例三个明显坑爹的回答：</strong></p>
<p>（1）RandomAccessFile 竟然使用了内存映射文件的技术？事实当然不是</p>
<p><img src="https://img2024.cnblogs.com/blog/2292062/202501/2292062-20250121191657586-2020821841.png" alt="img" loading="lazy"></p>
<p>（2）FileAppender 竟然不支持无 GC 模式，MemoryMappedFileAppender 竟然支持文件滚定？事实与之相反</p>
<p><img src="https://img2024.cnblogs.com/blog/2292062/202501/2292062-20250121191716527-156874498.png" alt="img" loading="lazy"></p>
<p>（3）RandomAccessFile 中 immediateFlush 默认值竟然是 false？实际上 immediateFlush 默认值是 true</p>
<p><img src="https://img2024.cnblogs.com/blog/2292062/202501/2292062-20250121191727221-1415168030.png" alt="img" loading="lazy"></p>
<h3 id="3-一周深度使用---选对场景避短扬长">3. 一周深度使用 - 选对场景避短扬长</h3>
<p>经上阶段使用后，由于 DeepSeek V3 的缺点（给出错误答案的概率高于 GPT-4o）很致命，一度让我想放弃。然而，它的优点（整体回答效果优于 GPT-4o）又让我十分不舍，比如在尝鲜阶段测试 CASE 中的“ts 中如何避免滥用 any 类型”问题上，DeepSeek V3 的回答是迄今为止我见过的最好的，没有之一。相比坑爹的回答，优秀案例比例更高。所以在本阶段，继续使用 DeepSeek V3，希望能总结其特点，找到合适的适用场景，从而最大化地发挥它的优势。</p>
<p>经过一周使用后，<strong>个人认为：</strong>DeepSeek V3 更适合用于解答开放式问题。对于较为具体的细节问题，两者各有优势，GPT-4o 更保守且更可靠，DeepSeek 广度和维度更高但也更容易出错。建议用户根据实际需求选用，或两者参照使用。</p>
<h2 id="三总结与建议">三、总结与建议</h2>
<p>（1）从个人使用来看，DeepSeek V3 效果确实很好，还能免费使用，NB。期望 DeepSeek V3 能越做越好，能优先支持自定义 BOT。</p>
<p>（2）个人建议在日常工作中，开放性问题可以以 DeepSeek V3 为主、GPT4-o 为辅；细节问题则对照两者使用，以 DeepSeek V3 的回答为主，并进行二次验证。</p>
<h2 id="四附优秀案例---deepseek-v3-关于ts-中如何避免滥用-any-类型问题的解答">四、附优秀案例 - DeepSeek V3 关于“ts 中如何避免滥用 any 类型”问题的解答</h2>
<p>在 TypeScript 中，<code>any</code> 类型是一种“逃逸舱”，它可以绕过类型检查，但过度使用 <code>any</code> 会削弱 TypeScript 的类型安全性。为了避免使用 <code>any</code>，可以采取以下策略：</p>
<h3 id="1-明确类型">1. 明确类型</h3>
<p>始终为变量、函数参数和返回值指定明确的类型，而不是使用 <code>any</code>。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">// 不推荐
function processData(data: any) {
    // ...
}

// 推荐
function processData(data: { id: number; name: string }) {
    // ...
}
</code></pre>
<h3 id="2-使用联合类型">2. 使用联合类型</h3>
<p>当某个值可能是多种类型时，使用联合类型（<code>|</code>）而不是 <code>any</code>。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">// 不推荐
let value: any;

// 推荐
let value: string | number;
</code></pre>
<h3 id="3-使用类型别名或接口">3. 使用类型别名或接口</h3>
<p>对于复杂的数据结构，使用类型别名（<code>type</code>）或接口（<code>interface</code>）定义类型。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">// 不推荐
function getUser(user: any) {
    // ...
}

// 推荐
interface User {
    id: number;
    name: string;
    email: string;
}

function getUser(user: User) {
    // ...
}
</code></pre>
<h3 id="4-使用泛型">4. 使用泛型</h3>
<p>当函数或类需要处理多种类型时，使用泛型（<code>Generic</code>）而不是 <code>any</code>。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">// 不推荐
function identity(value: any): any {
    return value;
}

// 推荐
function identity&lt;T&gt;(value: T): T {
    return value;
}
</code></pre>
<h3 id="5-使用类型断言">5. 使用类型断言</h3>
<p>如果明确知道某个值的类型，可以使用类型断言（<code>as</code>）而不是 <code>any</code>。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">let value: unknown = "Hello, TypeScript";

// 不推荐
let length = (value as any).length;

// 推荐
let length = (value as string).length;
</code></pre>
<hr>
<h3 id="6-使用-unknown-类型">6. 使用 <code>unknown</code> 类型</h3>
<p>当类型不确定时，使用 <code>unknown</code> 类型而不是 <code>any</code>。<code>unknown</code> 是类型安全的，因为它要求在使用前进行类型检查。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">// 不推荐
function processValue(value: any) {
    // ...
}

// 推荐
function processValue(value: unknown) {
    if (typeof value === "string") {
        console.log(value.toUpperCase());
    } else if (typeof value === "number") {
        console.log(value.toFixed(2));
    }
}
</code></pre>
<h3 id="7-使用类型守卫">7. 使用类型守卫</h3>
<p>通过类型守卫（Type Guard）缩小 <code>unknown</code> 或联合类型的范围。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">function isString(value: unknown): value is string {
    return typeof value === "string";
}

function processValue(value: unknown) {
    if (isString(value)) {
        console.log(value.toUpperCase());
    }
}
</code></pre>
<h3 id="8-使用工具类型">8. 使用工具类型</h3>
<p>TypeScript 提供了许多工具类型（Utility Types），可以帮助避免 <code>any</code>。</p>
<p>示例：</p>
<pre><code class="language-typescript">// 使用 Partial&lt;T&gt; 表示部分属性可选
interface User {
    id: number;
    name: string;
    email: string;
}

function updateUser(user: Partial&lt;User&gt;) {
    // ...
}
</code></pre>
<h3 id="9-启用严格模式">9. 启用严格模式</h3>
<p>在 <code>tsconfig.json</code> 中启用严格模式，可以避免隐式的 <code>any</code>。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-json">{
  "compilerOptions": {
    "strict": true
  }
}
</code></pre>
<p><strong>严格模式包括以下选项：</strong></p>
<ul>
<li><code>noImplicitAny</code>：禁止隐式的 <code>any</code> 类型。</li>
<li><code>strictNullChecks</code>：确保变量不能为 <code>null</code> 或 <code>undefined</code>。</li>
<li><code>strictFunctionTypes</code>：确保函数参数类型严格匹配。</li>
<li>等等。</li>
</ul>
<h3 id="10-使用第三方库的类型定义">10. 使用第三方库的类型定义</h3>
<p>如果使用第三方库，确保安装了对应的类型定义文件（<code>@types</code> 包）。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-bash">npm install --save lodash
npm install --save-dev @types/lodash
</code></pre>
<h3 id="11-逐步替换-any">11. 逐步替换 <code>any</code></h3>
<p>如果项目中已经存在大量 <code>any</code>，可以逐步替换：</p>
<ol>
<li>使用 <code>eslint</code> 或 <code>tslint</code> 禁止使用 <code>any</code>。</li>
<li>逐步为每个 <code>any</code> 添加明确的类型。</li>
</ol>
<h3 id="12-使用-never-类型">12. <strong>使用 <code>never</code> 类型</strong></h3>
<p>对于不可能存在的值，使用 <code>never</code> 类型。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-typescript">function throwError(message: string): never {
    throw new Error(message);
}
</code></pre>
<h3 id="总结">总结</h3>
<p>避免使用 <code>any</code> 是编写高质量 TypeScript 代码的关键。通过明确类型、使用联合类型、泛型、类型断言、<code>unknown</code> 类型、类型守卫和工具类型，可以显著提高代码的类型安全性和可维护性。同时，启用严格模式和逐步替换 <code>any</code> 也是有效的策略。</p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18684303"></vc:categories-tags>
    </ul>
