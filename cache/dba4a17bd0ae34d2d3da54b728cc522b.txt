
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18957204" title="发布于 2025-06-30 09:59">
    <span role="heading" aria-level="2">Java集合--HashMap底层原理可视化，秒懂扩容、链化、树化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095840936-1336659591.png" alt="Java集合--HashMap底层原理可视化，秒懂扩容、链化、树化" class="desc_img">
        HashMap做一个全面梳理，涵盖：冲突处理（链地址法）、扩容流程、链表–红黑树（树化/链化）转换的处理。通过四次扩容，渐进式的对&nbsp;HashMap&nbsp;扩容及相关操作有一个基本而完整的理解。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>文章内容较长，带着疑问慢慢读。</p>
<p>文章对应的视频连接：<a href="https://www.bilibili.com/video/BV1wM3KzaE3d/" target="_blank" rel="noopener nofollow">https://www.bilibili.com/video/BV1wM3KzaE3d/</a></p>
</blockquote>
<h2 id="哈希冲突问题如何高效解决">哈希冲突问题如何高效解决？</h2>
<h2 id="1-什么是冲突">1. 什么是冲突？</h2>
<p>准确的说是解决<strong>哈希值映射冲突</strong>，而非解决哈希冲突。</p>
<p>哈希冲突指的是不同的key计算出来的哈希值相同而产生的冲突。</p>
<p>但这里是，<strong>不同的哈希值映射到相同的数组槽位置</strong>，而产生的存储位置冲突。</p>
<p>哈希表把 key 计算出哈希值后映射成整数 index，放到固定长度的数组槽（bucket）里。</p>
<p>当两个不同的 key 经过哈希函数后映射到相同的槽位，就发生了冲突。例如：</p>
<pre><code>hash("abc") &amp; (tableSize - 1) == 3  
hash("xyz") &amp; (tableSize - 1) == 3  
</code></pre>
<p>这两个不同的<code>key</code> 计算出来的哈希值不同，但都会被放到索引 3 的桶里。</p>
<p>关于这个问题可查阅上一篇文章：HashMap如何快速定位数据存储在内存地址的位置？。</p>
<img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095426989-1326565250.jpg" alt="" width="50%">
<p>但很多人都会将其称为哈希冲突，为了“达成共识”，后面都会把<strong>映射冲突</strong>和<strong>哈希冲突</strong>都称为<strong>哈希冲突</strong>。</p>
<h2 id="2-如何解决哈希冲突">2. 如何解决哈希冲突？</h2>
<p>主要有 <strong>两大类方法</strong>：</p>
<h3 id="开放寻址法open-addressing">开放寻址法（Open Addressing）</h3>
<p>所有元素都直接存放在哈希表数组里，没有链表。</p>
<p>一旦发生冲突，就在数组里按一定探测规则继续找下一个空槽位。</p>
<p>常见策略：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线性探测（Linear Probing）</strong></td>
<td>下一个槽位是 <code>(index + 1) % tableSize</code></td>
</tr>
<tr>
<td><strong>二次探测（Quadratic Probing）</strong></td>
<td>距离按平方增加，如 <code>(index + i^2) % tableSize</code></td>
</tr>
<tr>
<td><strong>双重哈希（Double Hashing）</strong></td>
<td>用另一个哈希函数求探测步长</td>
</tr>
</tbody>
</table>
<p>特点：适合占用率低时（负载因子 &lt; 0.7）；一旦负载高就容易产生聚集，效率下降。</p>
<h3 id="链地址法separate-chaining">链地址法（Separate Chaining）</h3>
<p>每个槽位维护一个 <strong>桶</strong>（链表或红黑树）；冲突的元素插入到该槽位的桶结构里。</p>
<p>HashMap 就是这样做的：</p>
<ul>
<li>
<p>早期 JDK：每个桶是一个链表</p>
</li>
<li>
<p>JDK 8+：当链表长度超过阈值 8，同时桶的大小&gt;=64时，自动转成红黑树，提升查找效率</p>
</li>
</ul>
<p>特点：实现简单，扩容后负载高也不怕冲突太多；空间换时间（每个桶需要额外引用）；适合高负载且需要稳定性能的场景。</p>
<p>HashMap的数据结构：<strong>数组+链表/红黑树</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095447538-144888791.jpg" alt="image" loading="lazy"></p>
<h2 id="3-怎么提升效率">3. 怎么提升效率？</h2>
<p><strong>好的哈希函数</strong>：<code>HashMap</code> 会对 <code>hashCode</code> 做扰动（高位参与低位），保证桶索引分布更均匀。</p>
<p><strong>链地址法</strong>：每个槽位维护一个 <strong>桶</strong>；冲突的元素插入到该槽位的桶结构里。</p>
<p><strong>优秀桶结构</strong>：链表长度有阈值（8）控制，确保不会退化成<code>O(n)</code>；自平衡二叉查找树--红黑树，确保查找效率为 <code>O(log n)</code>。并且有负载阈值触发动态扩容，不会让红黑树无限扩大。</p>
<p><strong>动态扩容</strong>：当负载因子（元素数量 / 桶数量）超过阈值（默认 0.75），就会扩容（桶数量 * 2），扩容会重新计算所有元素的桶索引，让冲突的元素再次分散开来，从而减少冲突。</p>
<p>HashMap高效归纳为：好哈希函数 + 链地址法 + 优秀桶结构 + 动态扩容四件套组合，保证冲突多时依然高效。</p>
<h2 id="4-扩容">4. 扩容</h2>
<p>扩容，扩的都是数组的容量。</p>
<p>有三种情况会触发扩容</p>
<ul>
<li>
<p>初次插入数据时的扩容，不管是否构造函数指定大小创建<code>HashMap</code>都是插入才扩容；</p>
</li>
<li>
<p>数组（桶）小于64，并且单链表 &gt;8 时的扩容</p>
</li>
<li>
<p>默认情况，使用容量 &gt; 存储容量的loadFactor倍（存储容量的75%）</p>
</li>
</ul>
<p>比如，大于阈值的扩容过程</p>
<p><strong>触发条件满足</strong>：<code>size &gt; threshold = newCap × loadFactor</code></p>
<p>计算<strong>新容量</strong>：<code>newCap = oldCap &lt;&lt; 1</code>（翻倍），最高 <code>MAXIMUM_CAPACITY</code>。</p>
<p>接着<strong>重设阈值</strong>：<code>threshold = newCap × loadFactor</code>。</p>
<p>最后<strong>迁移节点</strong>（再哈希）：所有已有节点需重新按照新容量 <code>newCap</code> 计算索引，分布到新的桶数组中。链表可按 <code>hash &amp; oldCap</code> 判定留在原地或移到 <code>index + oldCap</code>，减少再次哈希开销。</p>
<p>以下将从四次扩容来逐渐掌握整个HashMap的扩容机制。</p>
<h2 id="5-第一次扩容首次扩容">5. 第一次扩容（首次扩容）</h2>
<p>在首次插入元素时，先进行首次扩容，默认扩容为16。</p>
<h3 id="链表挂载">链表挂载</h3>
<p>插入元素时<strong>初次冲突：链表挂载</strong>，非首次冲突的需要遍历链表找相同 key 或添加到尾部，部分源码如下：</p>
<pre><code class="language-java">if (table[index] == null) {
table[index] = newNode(hash, key, value, null);
} else {
// 已有节点，遍历链表找相同 key 或添加到尾部
}
</code></pre>
<p>若 <code>table[idx]</code> 为空，则直接放入新节点。</p>
<p>否则沿链表遍历：</p>
<ul>
<li>若遇 <code>key.equals(oldKey)</code>，则替换旧值。</li>
<li>否则追加到链表尾。</li>
</ul>
<h3 id="tablesizefor-方法的巧妙作用">tableSizeFor 方法的巧妙作用</h3>
<p>如果指定大小的情况，会被方法<code>int tableSizeFor(int cap)</code>转为2的倍数大小。比如指定大小为5，那么得到的是大小为8；指定大小为16，那得到的大小为16。</p>
<blockquote>
<p><code>tableSizeFor</code> 方法的作用：让哈希表内部桶数组的长度总是 2 的幂，保证 <code>hash &amp; (length - 1)</code> 能高效工作。</p>
<p>只要保存了hash值，就可以通过<code>hash &amp; (length - 1)</code>来获取到key的桶位置，这个运算在源码中会经常用到。</p>
</blockquote>
<p>该方法的源码如下：</p>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<p>该方法是后续高效处理 key 的重要基础。</p>
<p>首次插入元素图示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095519668-855022348.jpg" alt="image" loading="lazy"></p>
<p><strong>每次扩容</strong>都会：</p>
<blockquote>
<p>重新计算<strong>新容量</strong>：<code>newCap = oldCap &lt;&lt; 1</code>（翻倍），</p>
<p><strong>重设阈值</strong>：<code>threshold = newCap × loadFactor</code>。</p>
</blockquote>
<p>当使用容量超过阈值<code>threshold</code>，便会触发下一次扩容，比如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095535287-1117588484.jpg" alt="image" loading="lazy"></p>
<h2 id="6-第二次扩容树化前扩容">6. 第二次扩容（树化前扩容）</h2>
<p>树化前的扩容规则都相对简单</p>
<blockquote>
<p>只有一个节点的链表，直接计算<code>hash &amp; (32 - 1)</code>新位置插入即可;</p>
<p>不止一个节点的链表，按照<code>hash &amp; 16==0</code> 拆分成低位、高位两个链表，然后再插入。</p>
</blockquote>
<p>重点在于理解：<strong><code>hash &amp; oldCap ==0</code> 为什么可以区分高低位？</strong></p>
<h3 id="hash--oldcap-0的完全理解"><code>hash &amp; oldCap ==0</code>的完全理解</h3>
<p><code>oldCap</code>是<strong>扩容前</strong>的容量，我们都知道扩容前数组（桶）的位置计算公式为<code>hash&amp;(oldCap-1)</code>，下面通过一个案例来完全理解并掌握它：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095547472-1739307790.jpg" alt="image" loading="lazy"></p>
<p>认真看完图中的案例，我们可以发现公式<code>hash &amp; 16 ==0</code>的计算使用到的二进制位，正是扩容后公式<code>hash&amp;(32-1)</code>使用的最高位二进制位，即案例中哈希值的第5位二进制位。</p>
<p>而哈希值的二进制只有0 和1，故，<code>hash &amp; oldCap</code> 计算结果为0，说明扩容后，该节点保持原位不动；不为0，则必为<strong>原数组大小</strong>。</p>
<p>所以你会看到源代码会有这么一行代码：<code>newTab[j + oldCap] = hiHead;</code></p>
<pre><code class="language-java">if (loTail != null) {
    loTail.next = null;
    newTab[j] = loHead;
}
if (hiTail != null) {
    hiTail.next = null;
    newTab[j + oldCap] = hiHead;
}
</code></pre>
<p>这个拆分规则成立的前提条件是：哈希表内部桶数组的长度总是 2 的幂，并且每次扩容都是翻倍。</p>
<h3 id="为什么要拆分成高低位链表">为什么要拆分成高低位链表？</h3>
<p>直接计算<code>hash &amp; (32 - 1)</code>便可轻松实现扩容后的插入了，而且计算效率一致，为什么还要拆来拆去搞得那么复杂呢？</p>
<blockquote>
<p>为了更高效</p>
</blockquote>
<p>如果直接计算数组索引位置，那就需要遍历变量数组（桶）上的链表，找到最后一个节点才可以插入。而拆分高低位只需要插入最多两次数组（桶）即可，通过临时定义的尾部节点，计算完即可尾部插入形成链表，最后在插入到数组（桶），本质也是空间换时间。</p>
<h2 id="7-第三次扩容树化前扩容">7. 第三次扩容（树化前扩容）</h2>
<p>这次让<strong>单个链表插入第9个节点</strong>，从而触发扩容。注：插入超过容量阈值也可以触发扩容，这里为了展示</p>
<p>树化前的扩容规则都相对简单，和第二次扩容规则完全一样，只是触发扩容的条件不同而已。</p>
<blockquote>
<p>只有一个节点的链表，直接计算<code>hash &amp; (64 - 1)</code>新位置插入即可;</p>
<p>不止一个节点的链表，按照<code>hash &amp; 32==0</code> 拆分成低位、高位两个链表，然后再插入。</p>
</blockquote>
<p>拆分低位、高位的大概过程动画如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095607311-1267143132.gif" alt="image" loading="lazy"></p>
<h3 id="链表树化treeify">链表树化（Treeify）</h3>
<p>这次扩容重点在于链表树化的学习。</p>
<p><strong>树化的条件</strong>：<code>TREEIFY_THRESHOLD</code>为链表长度阈值</p>
<ol>
<li>当前桶链表长度 &gt; <code>TREEIFY_THRESHOLD</code>（8）</li>
<li>整个表容量 ≥ <code>MIN_TREEIFY_CAPACITY</code>（64）</li>
</ol>
<p>如果条件符合，将该桶的链表转换为红黑树，节点类型由链表节点 <code>Node&lt;K,V&gt;</code> 被替换为 <code>TreeNode&lt;K,V&gt;</code>，查找、插入、删除最坏 O(log n)。若容量 &lt; 64，则优先扩容而非树化。</p>
<p>触发链表树化的主要源码：</p>
<pre><code class="language-java">for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &amp;&amp;
        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
        break;
    p = e;
}
</code></pre>
<p>触发链表树化的条件<code>if (binCount &gt;= TREEIFY_THRESHOLD - 1) </code>，binCount=7的时候就会触发树化，因为binCount是<code>p.next</code>的次数，并且<code>binCount</code>从0开始的，也就是说循环了8次，在这里别搞混了。</p>
<p>还有一点就是，链表是插入第9个节点时才进行的树化，可看源码，是先插入节点后进行判断的；故此树化前的链表长度已变成9了，所以链表树化前的链表长度为9。</p>
<h4 id="链表树化分两步">链表树化分两步</h4>
<p>通过<code>treeifyBin(tab,hash)</code>方法完成链表树化操作。主要分为两步：</p>
<ul>
<li>
<p>先将链表的Node节点，转化成TreeNode节点，关键源码：<code>TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null)</code>；</p>
</li>
<li>
<p>再进行真正树化，关键源码：<code>hd.treeify(tab)</code>。</p>
</li>
</ul>
<p>通过案例感受下：</p>
<p>将单个链表插入第9个节点，使其超过单链表长度阈值，此时数组大小为64，条件满足触发链表树化，可视化过程如图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095630059-31223657.gif" alt="image" loading="lazy"></p>
<p>红黑树节点插入、染色、平衡的过程，不在这里展开，可单独学习红黑树数据结构。如果想要看HashMap红黑树数据结构的可视化视频的，可以在评论区留言，我抽时间把源代码完全还原出来。</p>
<p>红黑树插入、删除和树化完成都会调用这个方法<code>moveRootToFront(tab, root)</code>，因为这些操作都有可能导致根节点发生变化，该方法的作用是<strong>确保数组（桶）始终指向红黑树的根节点</strong>。</p>
<h2 id="8-第四次扩容树化后扩容">8. 第四次扩容（树化后扩容）</h2>
<p>然后插入满75%的容量，触发第四次扩容。扩容规则如下：</p>
<blockquote>
<p>1.只有一个节点的链表直接计算位置插入;</p>
<p>2.如果是红黑树，按照hash&amp;64==0？分低位、高位拆分成两个链表，\n判断双链表的长度，节点数&lt;=6 时，树转链表；节点数&gt;6时，正常树化"，再插入；</p>
<p>3.不止一个节点的链表，按照hash&amp;64==0？分低位、高位拆分成两个链表，再插入</p>
</blockquote>
<p>链表的调整前面已经讲过，重点关注红黑树在扩容期间如何操作的。</p>
<p>扩容期间，如果数组（桶）指向的是红黑树节点，那么就会调用<code>split</code>方法完成处理。</p>
<p>处理过程分为三步：</p>
<ol>
<li>
<p>使用红黑树的双链结构TreeNode的next节点进行遍历；</p>
</li>
<li>
<p>根据<code>(hash &amp; bit) == 0</code> 拆分成低位和高位两条TreeNode节点的双链结构；</p>
</li>
<li>
<p>判断低位和高位双链表长度是否 &lt;= 链化阈值<code>UNTREEIFY_THRESHOLD</code>，阈值默认为6；</p>
</li>
<li>
<p>长度&lt;=6的，先链化，再放入数组（桶）；反之，先放入数组（桶），再树化，树化逻辑和前面的一样。</p>
</li>
</ol>
<h3 id="红黑树链化untreeify">红黑树链化（untreeify）</h3>
<p><strong>链化操作</strong>其实很简单，只要将TreeNode节点转化为Node节点即可，关键源码<code>Node&lt;K,V&gt; p = map.replacementNode(q, null)</code>。</p>
<p>看一个可视化案例就明白了：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095656878-839080315.gif" alt="image" loading="lazy"></p>
<h2 id="9-总结">9. 总结</h2>
<p>HashMap做一个全面梳理，涵盖：冲突处理（链地址法）、扩容流程、链表–红黑树（树化/链化）转换的处理。通过四次扩容，渐进式的对 <code>HashMap</code> 扩容及相关操作有一个基本而完整的理解。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250630095718240-2085330307.gif" alt="image" loading="lazy"></p>
<p><a href="https://mp.weixin.qq.com/s/e0g1nWnyMN2MSMnKkHgjMg" target="_blank" rel="noopener nofollow">Java集合--从本质出发理解HashMap</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486793&amp;idx=1&amp;sn=b738749f16e5fcdad26e3874fc388444&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合--LinkedList源码可视化</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486763&amp;idx=1&amp;sn=214926d8cfaba2cada66106f26918764&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合源码--ArrayList的可视化操作过程</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486720&amp;idx=1&amp;sn=739bdfc99dc52128f9d9eb31a70a4c03&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式的两个秘籍</a></p>
<p>查看往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>
<p>原创不易，觉得还不错的，三连支持：点赞、分享、推荐↓</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.009722222222222222" data-date-updated="2025-06-30 10:13">2025-06-30 09:59</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">29</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18957204);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18957204', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18957204', title: 'Java集合--HashMap底层原理可视化，秒懂扩容、链化、树化' })">举报</a>
</div>
        