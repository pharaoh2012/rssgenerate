
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tianqing/p/18639550" title="发布于 2024-12-30 10:00">
    <span role="heading" aria-level="2">.NET 9 new features-Memory Caching 和 Collections 优化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>一、内存缓存（Memory Caching）</h2>
<h3>1. 具体的原理</h3>
<p>内存缓存是一种在应用程序内存中存储数据的机制，旨在减少对外部数据源的频繁访问，从而提高应用程序的性能。</p>
<p>在 .NET 中，<code>MemoryCache</code> 类提供了内存缓存的实现。它允许开发者将经常使用的数据存储在内存中，以便快速检索。</p>
<p>在 .NET 9 中，<code>MemoryCache</code> 的实现是 <code>ConcurrentDictionary&lt;TKey,TValue&gt;</code> 的包装器，提供了功能丰富的 API。</p>
<h3>2. 设计初衷</h3>
<p>内存缓存的设计初衷是为了提高应用程序的性能，特别是在需要频繁访问不经常变化的数据时。</p>
<p>通过将这些数据存储在内存中，可以减少对数据库或其他外部数据源的访问次数，从而降低延迟和资源消耗。</p>
<p>这对于需要高性能和快速响应的应用程序尤为重要。</p>
<h3>3. 应用场景</h3>
<p>内存缓存适用于以下场景：</p>
<ul>
<li>
<p><strong>频繁读取的静态数据</strong>：例如，应用程序配置、常量列表等，这些数据不经常变化，但需要频繁读取。</p>
</li>
<li>
<p><strong>计算成本高的数据</strong>：一些数据的计算过程复杂且耗时，将其结果缓存可以提高性能。</p>
</li>
<li>
<p><strong>会话状态管理</strong>：在某些情况下，可以使用内存缓存来存储用户的会话信息。</p>
</li>
</ul>
<h3>4. 示例代码</h3>
<p>以下是使用 <code>MemoryCache</code> 的示例代码：</p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> Microsoft.Extensions.Caching.Memory;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System;

</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> CacheExample
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IMemoryCache _cache;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> CacheExample(IMemoryCache cache)
    {
        _cache </span>=<span style="color: rgba(0, 0, 0, 1)"> cache;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span> GetOrSetCacheItem(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> key)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!_cache.TryGetValue(key, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> cacheValue))
        {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 数据不在缓存中，执行获取数据的逻辑</span>
            cacheValue = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">获取的数据</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置缓存选项</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> cacheEntryOptions = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MemoryCacheEntryOptions()
                .SetSlidingExpiration(TimeSpan.FromMinutes(</span><span style="color: rgba(128, 0, 128, 1)">5</span>)); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置滑动过期时间

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 将数据存储到缓存中</span>
<span style="color: rgba(0, 0, 0, 1)">            _cache.Set(key, cacheValue, cacheEntryOptions);
        }

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> cacheValue;
    }
}</span></pre>
</div>
</div>
</div>
<p>在上述代码中，<code>GetOrSetCacheItem</code> 方法尝试从缓存中获取数据，如果不存在，则获取数据并将其添加到缓存中，设置滑动过期时间为 5 分钟。</p>
<h2>二、集合（Collections）优化</h2>
<h3>1. 具体的原理</h3>
<p>在 .NET 9 中，对集合的优化主要体现在<strong>性能提升和内存使用</strong>的改进上。</p>
<p>例如，对循环的优化，通过将向上计数的循环转换为向下计数的循环，减少指令数量，从而提高性能。</p>
<p>此外，还引入了循环中的强度降低优化，将昂贵的操作替换为更便宜的操作，减少对迭代变量的依赖。</p>
<h3>2. 设计初衷</h3>
<p>这些优化的设计初衷是为了提高集合操作的效率，减少不必要的计算和内存分配，从而提升应用程序的整体性能。</p>
<p>特别是在处理大量数据或频繁操作集合的场景下，这些优化能够显著减少 CPU 和内存的消耗。</p>
<h3>3. 应用场景</h3>
<p>集合优化适用于以下场景：</p>
<ul>
<li>
<p><strong>大数据量处理</strong>：当需要处理大量数据时，优化的集合操作可以提高处理速度。</p>
</li>
<li>
<p><strong>高性能要求的应用</strong>：对于对性能有严格要求的应用程序，优化的集合操作可以减少延迟。</p>
</li>
<li>
<p><strong>实时系统</strong>：在需要实时响应的系统中，集合优化可以确保系统的及时性。</p>
</li>
</ul>
<h3>4. 示例代码</h3>
<p>以下是一个使用向下计数循环的示例代码：</p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span> SumArray(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">[] array)
{
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> sum = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = array.Length - <span style="color: rgba(128, 0, 128, 1)">1</span>; i &gt;= <span style="color: rgba(128, 0, 128, 1)">0</span>; i--<span style="color: rgba(0, 0, 0, 1)">)
    {
        sum </span>+=<span style="color: rgba(0, 0, 0, 1)"> array[i];
    }
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> sum;
}</span></pre>
</div>
<p>在上述代码中，循环从数组的末尾向前遍历，减少了比较操作的指令数量，从而提高了性能。</p>
<p>以上是.NET 9 new features-Memory Caching 和 Collections 优化的研究和分享。</p>
<p>&nbsp;</p>
<p>周国庆</p>
<p>2024/12/30</p>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.34401297920601853" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 10:01">2024-12-30 10:00</span>&nbsp;
<a href="https://www.cnblogs.com/tianqing">Eric zhou</a>&nbsp;
阅读(<span id="post_view_count">168</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18639550" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18639550);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18639550', targetLink: 'https://www.cnblogs.com/tianqing/p/18639550', title: '.NET 9 new features-Memory Caching 和 Collections 优化' })">举报</a>
</div>
        