<!----> <meta itemprop="headline" content="9个高级前端必会的性能优化API你都知道几个？"> <meta itemprop="keywords" content="性能优化,前端"> <meta itemprop="datePublished" content="2025-03-25T03:21:55.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="至简简"> <meta itemprop="url" content="https://juejin.cn/user/4212984286819384"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-799d3073="">
            9个高级前端必会的性能优化API你都知道几个？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-799d3073=""><div class="author-info-box" data-v-799d3073=""><div class="author-name" data-v-799d3073=""><a href="/user/4212984286819384/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-6a576a98="" data-v-799d3073=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-6a576a98="">
    至简简
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-799d3073=""><time datetime="2025-03-25T03:21:55.000Z" title="Tue Mar 25 2025 03:21:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-799d3073="">
                    2025-03-25
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-799d3073=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-799d3073=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-799d3073=""></circle></svg> <span class="views-count" data-v-799d3073="">
                    3,946
                  </span> <span class="read-time" data-v-799d3073=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-799d3073=""><rect width="16" height="16" fill="none" data-v-799d3073=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-799d3073=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-799d3073=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-799d3073=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-799d3073=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">requestIdleCallback</h2>
<p><code>requestIdleCallback</code> 是 <strong>浏览器提供的 API</strong>，用于在 <strong>浏览器空闲时执行低优先级任务</strong>，不会阻塞主线程，也不会影响动画和用户交互。</p>
<h3 data-id="heading-1">使用场景</h3>
<ol>
<li><strong>非紧急任务</strong>（如日志上报、数据同步、预加载）</li>
<li><strong>避免影响 UI 渲染</strong>（不会卡顿）</li>
<li><strong>Web3 DApp</strong>（如区块链数据同步、NFT 预加载）</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统方式(可能阻塞交互，导致界面发生卡顿)</span>
<span class="hljs-built_in">setTimeout</span>(processAnalyticsData, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// 优化方式</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doWork</span>(<span class="hljs-params">deadline</span>) {
  <span class="hljs-keyword">while</span> (deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-title function_">processDataChunk</span>(); <span class="hljs-comment">//分块处理数据</span>
    <span class="hljs-title function_">requestIdleCallback</span>(doWork);
  }
}
</code></pre>
<h2 data-id="heading-2">IntersectionObserver</h2>
<p><code>IntersectionObserver</code> 是浏览器提供的一个 API，用于异步观察一个元素（target element）与其祖先元素或顶级文档视口（viewport）之间的交集变化。简单来说，它可以监听某个元素是否进入或离开视口，以及可见部分的比例。</p>
<h3 data-id="heading-3">主要用途</h3>
<ol>
<li><strong>懒加载（Lazy Loading）</strong> ：当图片或组件进入视口时才加载，提高性能。</li>
<li><strong>无限滚动（Infinite Scroll）</strong> ：监测滚动到底部，自动加载新内容。</li>
<li><strong>动画触发</strong>：当元素进入视口时，触发 CSS 动画或 JavaScript 事件。</li>
<li><strong>广告曝光统计</strong>：检测广告是否被用户看到，以进行数据分析。</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统懒加载</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"scroll"</span>, <span class="hljs-function">() =&gt;</span> {
  imgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (rect.<span class="hljs-property">top</span> &lt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>) {
      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;
    }
  });
});

<span class="hljs-comment">// 优化实现（无布局抖动）</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"DOMContentLoaded"</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'img.lazy-load'</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">lazyLoad</span> = (<span class="hljs-params">entries, observer</span>) =&gt; {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
        <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>;
        img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;
        img.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'lazy-load'</span>);
        observer.<span class="hljs-title function_">unobserve</span>(img);
      }
    });
  };

  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(lazyLoad, {
    <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'0px'</span>,
    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span>
  });

  images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> {
    observer.<span class="hljs-title function_">observe</span>(img);
  });
});
</code></pre>
<h2 data-id="heading-4">WeakMap</h2>
<p><code>WeakMap</code> 是 JavaScript 提供的一种 <strong>弱引用（Weak References）</strong> 的 <code>Map</code> 结构，主要用于 <strong>存储对象的临时数据，而不会阻止垃圾回收</strong>。它的键（<code>key</code>）<strong>必须是对象</strong>，而 <strong>值（<code>value</code>）可以是任意类型</strong>。</p>
<h3 data-id="heading-5">代码示例</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统方式(内存泄漏风险):</span>
<span class="hljs-keyword">const</span> domDataMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
domDataMap.<span class="hljs-title function_">set</span>(element, { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });

<span class="hljs-comment">// 优化方案:</span>
<span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
weakMap.<span class="hljs-title function_">set</span>(element, { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }); <span class="hljs-comment">// 当element被移除D0M时，关联数据自动GC</span>
</code></pre>
<h2 data-id="heading-6">ResizeObserver</h2>
<p><code>ResizeObserver</code> 是 <strong>原生 JavaScript API</strong>，用于监听 <strong>DOM 元素尺寸的变化</strong>，并在尺寸变化时执行回调函数。它可以检测元素的 <code>width</code> 和 <code>height</code> 变化，而 <strong>不需要监听 <code>window.resize</code> 事件</strong>。</p>
<h3 data-id="heading-7">常见用途</h3>
<ol>
<li><strong>响应式布局</strong>：当元素大小变化时，调整 UI。</li>
<li><strong>动态文本溢出检测</strong>：监听文本容器大小变化，动态调整样式。</li>
<li><strong>Canvas / SVG 适配</strong>：根据容器大小调整绘制区域。</li>
<li><strong>Web3 / DApp 开发</strong>：适用于自适应的 NFT 画廊、区块链数据可视化等。</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统响应式布局</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">"resize"</span>,
  <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> width = container.<span class="hljs-property">offsetWidth</span>;
    <span class="hljs-title function_">adjustElements</span>(width);
  }, <span class="hljs-number">200</span>),
);

<span class="hljs-comment">// 优化方案</span>
<span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Element:'</span>, entry.<span class="hljs-property">target</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Content Rect:'</span>, entry.<span class="hljs-property">contentRect</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Width:'</span>, entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">width</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Height:'</span>, entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">height</span>);
  }
});

<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#myElement'</span>);

resizeObserver.<span class="hljs-title function_">observe</span>(element);
</code></pre>
<h2 data-id="heading-8">Web Workers</h2>
<p><code>Web Workers</code> 是 <strong>浏览器提供的多线程技术</strong>，用于 <strong>在后台运行 JavaScript 代码</strong>，避免主线程阻塞，提高应用的 <strong>性能和响应速度</strong>。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 主线程阻塞案例:</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-comment">// 30秒计算...</span>
  <span class="hljs-title function_">updateUI</span>(); <span class="hljs-comment">//界面卡死</span>
}

<span class="hljs-comment">// 并行优化方案:</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">"processor.js')
worker.postMessage(data)//处理完数据后会有消息通知
worker.onmessage =e =&gt; updateUI(e.data)
</span></code></pre>
<h2 data-id="heading-9">requestAnimationFrame</h2>
<p><code>requestAnimationFrame</code>（简称 <code>rAF</code>）是浏览器提供的 <strong>高性能动画 API</strong>，用于在 <strong>下一帧渲染时执行回调函数</strong>，使动画更加 <strong>流畅</strong>，并且 <strong>降低 CPU/GPU 资源消耗</strong>。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统动画卡顿</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) {
  element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = (pos += <span class="hljs-number">2</span>) + <span class="hljs-string">"px"</span>;
  <span class="hljs-built_in">setTimeout</span>(animate, <span class="hljs-number">16</span>); <span class="hljs-comment">//时间不精确</span>
}

<span class="hljs-comment">// 流畅动画方案</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"下一帧执行动画"</span>);
  <span class="hljs-title function_">requestAnimationFrame</span>(animate); <span class="hljs-comment">// 递归调用，创建动画循环</span>
}

<span class="hljs-title function_">requestAnimationFrame</span>(animate);
</code></pre>
<h2 data-id="heading-10">URL.createObjectURL</h2>
<p><code>URL.createObjectURL()</code> 是 <strong>浏览器提供的 API</strong>，用于创建 <strong>Blob 或 File 对象的临时 URL</strong>，可以用来 <strong>本地预览文件（如图片、视频）、下载文件</strong>，而不需要上传到服务器。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 传统 base64方式读取内容:</span>
<span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>()
reader.<span class="hljs-property">onload</span> =<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> img.<span class="hljs-property">src</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span> <span class="hljs-comment">// 内存膨胀</span>
reader.<span class="hljs-title function_">readAsDataURL</span>(100MBFile)<span class="hljs-comment">//耗时5s+</span>

<span class="hljs-comment">// 高性能方案:</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(100MBFile)
img.<span class="hljs-property">src</span> = url <span class="hljs-comment">// 瞬时完成</span>
<span class="hljs-comment">//使用后记得 revoke0bjectURL 释放内存</span>
</code></pre>
<h2 data-id="heading-11">content-visibility</h2>
<p>隐藏不在视口中的元素，减少不必要的渲染，提高滚动性能。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.lazy-load</span> {
  <span class="hljs-attribute">content-visibility</span>: auto;
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>长列表渲染</strong>（如消息流、新闻）</li>
<li>只渲染视口内的元素</li>
</ul>
<h2 data-id="heading-12">Fetch API + Streams</h2>
<p>支持流式传输，减少等待时间，适用于大文件加载。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/large-file'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
  reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">{ done, value }</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"流式加载部分数据:"</span>, value);
  });
});
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>大文件传输（如视频、JSON）</li>
<li>SSR（服务器端流式渲染）</li>
</ul></div></div>