
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Rong-/p/18696168" title="发布于 2025-02-01 09:15">
    <span role="heading" aria-level="2">DAB实现中用到的主要设计模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="dab-c-版本设计模式应用实践">DAB C++ 版本设计模式应用实践</h1>
<h2 id="1-命令模式-command-pattern">1. 命令模式 (Command Pattern)</h2>
<h3 id="设计目标">设计目标</h3>
<ul>
<li><strong>模块解耦</strong>：实现各模块独立编译、测试、运行，消除模块间直接依赖</li>
<li><strong>扩展准备</strong>：为桥接模式实现奠定基础</li>
<li><strong>依赖倒置</strong>：通过命令对象反转模块依赖方向</li>
<li><strong>耦合降低</strong>：将模块间耦合简化为命令对象耦合</li>
</ul>
<h3 id="11-mqtt-模块实现">1.1 MQTT 模块实现</h3>
<pre><code class="language-cpp">#pragma once
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

/**
 * @class HiMqttClient
 * @brief MQTT 客户端核心类，提供连接管理、消息发布订阅等功能
 * 
 * @note 采用命令模式实现消息处理回调机制
 */
class HiMqttClient {
public:
    // 连接管理接口
    static void start(const char* ip, int port, const char* user, 
                     const char* password, const char* clientId);
    static void stop();

    // 消息管理接口
    static void subscribe(const std::vector&lt;std::string&gt;&amp; topics);
    static bool publish(const char* topic, const char* body);

    // 命令模式回调设置
    static void onTopic(const std::function&lt;void(const char*, const char*, 
                                const char*, const char*)&gt;&amp; func);
};
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li>通过&nbsp;<code>onTopic()</code>&nbsp;设置命令对象实现消息处理解耦</li>
<li>支持模块独立单元测试</li>
<li>消除与其他业务模块的循环依赖</li>
</ul>
<h3 id="12-topic-处理器实现">1.2 Topic 处理器实现</h3>
<pre><code>#pragma once
#include &lt;map&gt;
#include &lt;functional&gt;
#include "context/dab_context.h"

/**
 * @class TopicHandler
 * @brief 基于命令模式的主题处理器
 * 
 * @note 使用注册机制替代传统 switch-case 分支处理
 */
class TopicHandler {
public:
    // 生命周期管理
    static void init(int maxThreads);
    static void destroy();

    // 命令注册接口
    static void registerHandler(const std::map&lt;std::string, 
        std::function&lt;void(DABContext&amp;)&gt;&gt;&amp; handles);

    // 统一消息入口
    static void onTopic(const char* topic, const char* body,
                      const char* response_topic, const char* correlation_data);
};
</code></pre>
<p><strong>创新点</strong>：</p>
<ul>
<li>动态注册机制实现处理逻辑可配置化</li>
<li>统一消息入口简化调用链路</li>
<li>天然支持多线程处理</li>
</ul>
<h3 id="13-上下文对象设计">1.3 上下文对象设计</h3>
<pre><code>#pragma once
#include "context/dab_status.h"
#include "context/dab_request.h"
#include "context/dab_response.h"

/**
 * @class DABContext
 * @brief 请求处理上下文对象
 * 
 * @note 采用命令模式封装消息发布功能
 */
class DABContext {
public:
    // 状态管理接口
    bool is_ok() const;
    void success();
    void clientFail(const char* out_log, const char* inner_log = nullptr);

    // 消息发布命令接口
    static void setPublishFunc(const std::function&lt;void(const char*, const char*)&gt;&amp; func);
    static void publish(DABContext&amp; context);
    
    // 数据成员
    DABStatus status;
    DABRequest request;
    DABResponse response;
};
</code></pre>
<p><strong>技术优势</strong>：</p>
<ul>
<li>隐藏 MQTT 实现细节</li>
<li>支持多种消息发布策略</li>
<li>上下文自包含设计简化单元测试</li>
</ul>
<h3 id="14-日志模块实现">1.4 日志模块实现</h3>
<pre><code>#pragma once

#include &lt;functional&gt;

/**
 * @enum DABLogLevel
 * @brief 日志级别枚举定义
 */
enum class DABLogLevel { INFO, WARNING, ERROR, FATAL, ALWAYS };

namespace dab {
    /**
     * @brief 日志回调设置接口
     * @param callback 日志处理函数原型：
     *        void(日志级别, 文件名, 函数名, 行号, 日志内容)
     */
    void set_log_callback(std::function&lt;void(DABLogLevel, const char*, 
                           const char*, int, const char*)&gt; callback);

    // 日志宏定义
    #define DABLOG_INFO(...)  dab::writeLog(DABLogLevel::INFO, __FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)
    #define DAB_ASSERT(expr, desc) \
        do { if (!(expr)) { \
            dab::on_assert_fail(__FILE__, __FUNCTION__, __LINE__); \
        }} while(0)
}

</code></pre>
<p><strong>核心价值</strong>：</p>
<ul>
<li>灵活适配不同日志实现</li>
<li>支持运行时日志策略切换</li>
<li>提供丰富的调试信息</li>
</ul>
<hr>
<h2 id="2-桥接模式-bridge-pattern">2. 桥接模式 (Bridge Pattern)</h2>
<h3 id="设计目标-1">设计目标</h3>
<ul>
<li><strong>架构解耦</strong>：分离抽象与具体实现</li>
<li><strong>独立演进</strong>：各模块可独立变化</li>
<li><strong>统一接口</strong>：提供标准化服务能力</li>
</ul>
<h3 id="系统桥接实现">系统桥接实现</h3>
<pre><code>void publish(const char* topic, const char* body) {
    HiMqttClient::publish(topic, body);     
}

extern "C" int runDabService() {
    // 初始化各模块
    TopicHandler::init(DABProperties::max_handle_threads);
    DABHandler::init();
    
    // 桥接关键点
    HiMqttClient::onTopic(TopicHandler::onTopic);
    DABContext::setPublishFunc(publish);

    // 订阅与注册
    HiMqttClient::subscribe(DABHandler::getTopics());
    TopicHandler::registerHandler(DABHandler::getTopicHandles());

    // 启动服务
    HiMqttClient::start(DABProperties::mqtt_ip.c_str(), 
                      DABProperties::mqtt_port, ...);
    return 0;
}
</code></pre>
<p><strong>桥接优势</strong>：</p>
<ul>
<li>业务逻辑与通信协议解耦</li>
<li>模块间通过抽象接口通信</li>
<li>新增协议支持成本最低化</li>
</ul>
<hr>
<h2 id="3-适配器模式-adapter-pattern">3. 适配器模式 (Adapter Pattern)</h2>
<h3 id="设计目标-2">设计目标</h3>
<ul>
<li><strong>接口标准化</strong>：统一不同系统的接口规范</li>
<li><strong>依赖倒置</strong>：反转系统接口依赖方向</li>
<li><strong>扩展支持</strong>：为策略模式实施奠定基础</li>
</ul>
<h3 id="典型应用">典型应用</h3>
<ol>
<li><strong>日志适配器</strong>：将系统日志接口转换为 DAB 标准日志接口</li>
<li><strong>服务适配</strong>：封装平台特性接口为统一服务接口</li>
</ol>
<p><strong>适配收益</strong>：</p>
<ul>
<li>业务代码不依赖具体实现</li>
<li>新增平台支持只需实现适配器</li>
<li>保持核心逻辑稳定性</li>
</ul>
<hr>
<h2 id="4-策略模式-strategy-pattern">4. 策略模式 (Strategy Pattern)</h2>
<h3 id="应用场景">应用场景</h3>
<table>
<thead>
<tr>
<th style="text-align: left">场景</th>
<th style="text-align: left">实现策略</th>
<th style="text-align: left">优势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">电视环境</td>
<td style="text-align: left">真实硬件接口实现</td>
<td style="text-align: left">完整功能支持</td>
</tr>
<tr>
<td style="text-align: left">云端环境</td>
<td style="text-align: left">Mock 接口实现</td>
<td style="text-align: left">无硬件依赖的自动化测试</td>
</tr>
<tr>
<td style="text-align: left">单元测试</td>
<td style="text-align: left">内存型轻量实现</td>
<td style="text-align: left">快速测试执行</td>
</tr>
</tbody>
</table>
<h3 id="策略配置">策略配置</h3>
<pre><code class="language-cpp">    // 测试环境初始化示例
    void dabInit() {
        DABContext::setPublishFunc([](const char* t, const char* b) {
            DABLOG_ALWAYS("Test Publish: %s -&gt; %s", t, b);
        });
        
        TopicHandler::registerHandler({
            {"test/topic1", [](DABContext&amp; ctx){ /* Mock处理逻辑 */ }},
            {"test/topic2", [](DABContext&amp; ctx){ /* Mock处理逻辑 */ }}
        });
    }
</code></pre>
<p><strong>策略优势</strong>：</p>
<ul>
<li>运行时动态切换实现</li>
<li>环境隔离保证测试可靠性</li>
<li>并行支持多种部署方案</li>
</ul>
<hr>
<h2 id="5单例模式">5.单例模式</h2>
<pre><code>在DAB的实现中，有意回避了单例模式，使用静态类代替。

```cpp

    class TopicHandler {
    public:
    static void init(int maxThreads);   // 显式初始化
    static void destroy();              // 显式资源释放
    static void registerHandler(/*...*/);
    TopicHandler() = delete;            // 禁止实例化
    };

```

**设计考量**：
1.  **生命周期可控**：通过`init()`/`destroy()`明确管理资源
2.  **测试友好**：支持不同测试用例的独立初始化
3.  **避免全局状态**：每个模块维护自身静态数据
4.  **编译期约束**：`= delete`禁止非法操作
    **对比传统单例**：
*   不强制全局唯一实例
*   无隐式初始化顺序问题
*   支持多环境配置（测试/生产）
</code></pre>
<hr>
<h2 id="6-测试体系设计">6. 测试体系设计</h2>
<h3 id="1-测试环境搭建">1. 测试环境搭建</h3>
<pre><code class="language-cpp">#include &lt;gtest/gtest.h&gt;
#include "dab/dab_api.h"

// 全局测试环境类
class TestEnv : public testing::Environment {
public:
    void SetUp() override { dabInit(); }    // 测试用例初始化
    void TearDown() override { dabDestory(); } // 测试资源回收
};

// 核心初始化逻辑
namespace {
    // 模拟消息发布函数
    void publish(const char* topic, const char* body) {
        DABLOG_ALWAYS("[TEST] Topic:%s\nPayload:%s", topic, body);
    }

    void dabInit() {
        DABProperties::device_id = "TEST_DEVICE"; // 设置测试设备ID
        TopicHandler::init(5);    // 初始化消息处理线程池
        DABHandler::init();       // 业务处理器初始化
        DABContext::setPublishFunc(publish); // 注入模拟发布器
        
        // 注册Topic处理函数
        TopicHandler::registerHandler(DABHandler::getTopicHandles());
    }

    void dabDestory() {
        TopicHandler::destroy();  // 清理消息处理器
        DABHandler::destroy();    // 清理业务处理器
    }
}

// 测试主入口
int main(int argc, char** argv) {
    testing::InitGoogleTest(&amp;argc, argv);
    testing::AddGlobalTestEnvironment(new TestEnv);
    return RUN_ALL_TESTS();
}
</code></pre>
<h3 id="2-设计模式应用解析">2. 设计模式应用解析</h3>
<table>
<thead>
<tr>
<th style="text-align: left">设计模式</th>
<th style="text-align: left">应用场景</th>
<th style="text-align: left">实现要点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>命令模式</strong></td>
<td style="text-align: left">消息处理函数注册</td>
<td style="text-align: left">通过<code>registerHandler</code>注册处理闭包</td>
</tr>
<tr>
<td style="text-align: left"><strong>桥接模式</strong></td>
<td style="text-align: left">业务处理与MQTT通信解耦</td>
<td style="text-align: left"><code>setPublishFunc</code>实现协议隔离</td>
</tr>
<tr>
<td style="text-align: left"><strong>策略模式</strong></td>
<td style="text-align: left">测试环境与生产环境配置切换</td>
<td style="text-align: left"><code>DABProperties</code>动态配置</td>
</tr>
</tbody>
</table>
<h3 id="3测试辅助工具实现">3.测试辅助工具实现</h3>
<h4 id="1-topic处理工具类">1. Topic处理工具类</h4>
<pre><code>namespace {
    // 生成标准Topic格式
    std::string formatTopic(const std::string&amp; baseTopic) {
        std::ostringstream oss;
        oss &lt;&lt; "dab/" &lt;&lt; DABProperties::device_id &lt;&lt; "/" &lt;&lt; baseTopic;
        return oss.str();
    }
}

// 统一测试入口函数
void onTopicTest(const std::string&amp; topic, const std::string&amp; request) {
    TopicHandler::onTopic(
        formatTopic(topic).c_str(),  // 格式化请求Topic
        request.c_str(),             // 测试请求载荷
        "_response/" + formatTopic(topic).c_str(), // 响应Topic
        ""                           // 关联数据
    );
}
</code></pre>
<h4 id="2-工具类设计亮点">2. 工具类设计亮点</h4>
<ol>
<li><strong>Topic规范化</strong>：自动添加设备ID前缀</li>
<li><strong>响应隔离</strong>：生成专用的响应Topic通道</li>
<li><strong>异常防护</strong>：内置空指针检查等安全机制</li>
<li><strong>日志追踪</strong>：自动记录测试消息流向</li>
</ol>
<h3 id="4应用功能测试案例">4.应用功能测试案例</h3>
<h4 id="1-应用管理测试集">1. 应用管理测试集</h4>
<pre><code>TEST(DABHandler, ApplicationManagement) {
    // 基础功能测试
    onTopicTest("applications/list", "{}"); // 空参数查询
    
    // 典型场景测试
    onTopicTest("applications/launch", 
        R"({"appId":"YouTube"})"); // 标准应用启动
    
    // 带参数启动测试
    onTopicTest("applications/launch", 
        R"({
            "appId": "Netflix",
            "parameters": [
                "-KEY", 
                "https%3A%2F%2Fwww.example.com%2F",
                "-STANDALONE_PARAM"
            ]
        })");
    
    // 状态管理测试
    onTopicTest("applications/get-state", 
        R"({"appId":"YouTube"})");
    
    // 退出机制测试
    onTopicTest("applications/exit", 
        R"({"appId":"YouTube"})"); // 常规退出
    onTopicTest("applications/exit", 
        R"({"appId":"YouTube","background":true})"); // 后台退出
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3710702006226852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-01 09:20">2025-02-01 09:15</span>&nbsp;
<a href="https://www.cnblogs.com/Rong-">荣--</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18696168" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18696168);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18696168', targetLink: 'https://www.cnblogs.com/Rong-/p/18696168', title: 'DAB实现中用到的主要设计模式' })">举报</a>
</div>
        