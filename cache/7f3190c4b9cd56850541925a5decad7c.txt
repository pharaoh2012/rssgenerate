
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18685674" title="发布于 2025-01-22 13:53">
    <span role="heading" aria-level="2">Svelte 最新中文文档翻译（4）——  符文（Runes）下</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>Svelte，一个非常“有趣”、用起来“很爽”的前端框架。从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://github.com/user-attachments/assets/48df16b1-939c-489b-8d52-6071869893f0" alt="Image" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目，也是我做个人项目的首选技术栈。</strong></p>
<p>目前 Svelte 基于 Svelte 5 发布了最新的官方文档，但却缺少对应的中文文档。为了帮助大家学习 Svelte，为爱发电翻译了官方文档。</p>
<p>我同时搭建了 Svelte 最新的中文文档站点：<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">https://svelte.yayujs.com</a> ，如果需要辅助学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>虽说是翻译，但个人并不喜欢严格遵守原文，为了保证中文阅读流畅，会删减部分语句，对难懂的部分也会另做补充解释，希望能给大家带来一个好的中文学习体验。</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“低调务实优秀中国好青年”</a>前端社群，分享技术，带你成长。</p>
<h2 id="props">$props</h2>
<p>组件的输入称为 <em>props</em>，这是 <em>properties</em> 的缩写。你将 props 传递给组件，就像将属性传递给元素一样：</p>
<pre><code class="language-svelte">&lt;!--- file: App.svelte ---&gt;
&lt;script&gt;
	import MyComponent from './MyComponent.svelte';
&lt;/script&gt;

&lt;MyComponent adjective="cool" /&gt;
</code></pre>
<p>另一方面，在 <code>MyComponent.svelte</code> 内部，我们可以使用 <code>$props</code> 符文接收 props...</p>
<pre><code class="language-svelte">&lt;!--- file: MyComponent.svelte ---&gt;
&lt;script&gt;
	let props = $props();
&lt;/script&gt;

&lt;p&gt;这个组件是 {props.adjective}&lt;/p&gt;
</code></pre>
<p>...更常见的是，你会 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener nofollow"><em>解构</em></a> 你的 props：</p>
<pre><code class="language-svelte">&lt;!--- file: MyComponent.svelte ---&gt;
&lt;script&gt;
	let +++{ adjective }+++ = $props();
&lt;/script&gt;

&lt;p&gt;这个组件是 {+++adjective+++}&lt;/p&gt;
</code></pre>
<h3 id="后备值fallback-values">后备值（Fallback values）</h3>
<p>解构允许我们声明后备值，如果父组件没有设置给定的 prop，就会使用这些后备值：</p>
<pre><code class="language-js">let { adjective = 'happy' } = $props();
</code></pre>
<blockquote>
<p>[!NOTE] 后备值不会变成响应式状态代理（有关更多信息，请参见<a href="https://svelte.yayujs.com/docs/svelte/$props#Updating-props" target="_blank" rel="noopener nofollow">更新 props</a>）</p>
</blockquote>
<h3 id="重命名-props">重命名 props</h3>
<p>我们也可以用解构赋值来重命名 props，如果它们是无效标识符，或者是像 <code>super</code> 这样的 JavaScript 关键字，这样做是必要的：</p>
<pre><code class="language-js">let { super: trouper = '光芒终会照亮我' } = $props();
</code></pre>
<h3 id="剩余-props">剩余 props</h3>
<p>最后，我们可以使用 <em>剩余属性</em> 来获取，其实就是获取剩下的 props：</p>
<pre><code class="language-js">let { a, b, c, ...others } = $props();
</code></pre>
<h3 id="更新-props">更新 props</h3>
<p>当 prop 本身更新时，组件内部对该 prop 的引用也会更新——当 <code>count</code> 在 <code>App.svelte</code> 中发生变化时，它在 <code>Child.svelte</code> 内部也会相应改变。但是子组件能暂时覆盖 prop 的值，这对未保存的临时状态很有用（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE6WQ0WrDMAxFf0WIQR0Wmu3VTQJln7HsIfVcZubIxlbGRvC_DzuBraN92qPula50tODZWB1RPi_IX16jLALWSOOUq6P3-_ihLWftNEZ9TVeOWBNHlNhGFYznfqCBzeRdYHh6M_YVzsFNsNs3pdpGd4eBcqPVDMrNxNDBXeSRtXioDgO1zU8ataeZ2RE4Utao924RFXQ9iHXwvoPHKpW1xY4g_Bg0cSVhKS0p560Za95612ZC02ONrD8ZJYdZp_rGQ37ff_mSP86Np2TWZaNNmdcH56P4P67K66_SXoK9pG-5dF5Z9QEAAA==" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;!--- file: App.svelte ---&gt;
&lt;script&gt;
	import Child from './Child.svelte';

	let count = $state(0);
&lt;/script&gt;

&lt;button onclick={() =&gt; (count += 1)}&gt;
	点击次数（父组件）：{count}
&lt;/button&gt;

&lt;Child {count} /&gt;
</code></pre>
<pre><code class="language-svelte">&lt;!--- file: Child.svelte ---&gt;
&lt;script&gt;
	let { count } = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; (count += 1)}&gt;
	点击次数（子组件）：{count}
&lt;/button&gt;
</code></pre>
<p>虽然你可以临时 <em>重新赋值</em> props，但除非它们是 <a href="https://svelte.yayujs.com/docs/svelte/$bindable" target="_blank" rel="noopener nofollow">可绑定</a> 的 props，否则不应 <em>修改</em> props。</p>
<p>如果 prop 是一个普通对象，修改将没有效果（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2W1QmorQgJXk0RC3PkBwiExG9WQrC17U4Es_ztKUkQp9OjxzM7bjcjtSKjwyfKNp1aLORA4b13ADHszUED1HFE-3eyaBcy-Mw_O5eFAg8xa1wb6T9eWhVgCKiyD9sZJ3XAjZnTWCzzuzfAKvbcjbPJieR2jm_uGy-InweXqtd0baaliBG0nFgW3kBIUNWYo9CGoxE-UsgvIpw2_oc9-LmAPJBCPDJCggqvlVtvdH9puErEMlvVg9HsVtzuoaojzkKKAfRuALVDfk5ZZW0fmy05wXcFdwyktlUs-KIinljTXrRVnm7-kL9dYLVbUAQAA" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;!--- file: App.svelte ---&gt;
&lt;script&gt;
	import Child from './Child.svelte';
&lt;/script&gt;

&lt;Child object={{ count: 0 }} /&gt;
</code></pre>
<pre><code class="language-svelte">&lt;!--- file: Child.svelte ---&gt;
&lt;script&gt;
	let { object } = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; {
	// 没有效果
	object.count += 1
}}&gt;
	点击次数：{object.count}
&lt;/button&gt;
</code></pre>
<p>如果 prop 是一个响应式状态代理，那么修改它会产生效果，但你会看到一个 <a href="https://svelte.yayujs.com/docs/svelte/runtime-warnings#Client-warnings-ownership_invalid_mutation" target="_blank" rel="noopener nofollow"><code>ownership_invalid_mutation</code></a> 警告，因为该组件正在修改不“属于”它的状态（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE3WR0U7DMAxFf8VESBuiauG1WycheOEbKA9p67FA6kSNszJV-XeUZhMw2GN8r-1znUmQ7FGU4pn2UqsOes-SlSGRia3S6ET5Mgk-2OiJBZGdOh6szd0eNcdaIx3-V28NMRI7UYq1awdleVNTzaq3ZmB43CndwXYwPSzyYn4dWxermqJRI4Np3rFlqODasWRcTtAaT1zCHYSbVU3r4nsyrdPMKTUFKDYiE4yfLEoePIbsQpqfy3_nOVMuJIqg0wk1RFg7GOuWfwEbz2wIDLVatR_VtLyBagNTHFIUMCqtoZXeIfAOU1JoUJsR2IC3nWTMjt7GM4yKdyBhlAMpesvhydCC0y_i0ZagHByMh26WzUhXUUxKnpbcVnBfUwhznJnNlac7JkuIURL-2VVfwxflyrWcSQIAAA==" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;!--- file: App.svelte ---&gt;
&lt;script&gt;
	import Child from './Child.svelte';

	let object = $state({count: 0});
&lt;/script&gt;

&lt;Child {object} /&gt;
</code></pre>
<pre><code class="language-svelte">&lt;!--- file: Child.svelte ---&gt;
&lt;script&gt;
	let { object } = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; {
	// 会导致下面的 count 更新，
	// 但会有警告。不要修改
	// 你不拥有的对象！
	object.count += 1
}}&gt;
	点击次数：{object.count}
&lt;/button&gt;
</code></pre>
<p>未使用 <code>$bindable</code> 声明的 prop 的后备值将保持不变——它不会被转换为响应式状态代理——这意味着对其的修改不会触发更新（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2VkIbUVoYFraCIh7vwA4eC4G9Wta1vxpgJZ_nfkBEQp9OjxzOzTRGHlkUQlXpy9G0gq1idCL43ppDrAD84HUYheGwqieo2CP3y2Z0EU3-En79fhRIaz1slA_-nKWSbLQVRiE9SgPTetbVkfvRsYzztttugHd8RiXU6vr-jisbWb8idhN7O3bEQhmN5ZVDyMlIorcOddv_Eufq4AGmJEuG5PilEjQrnRcoV7JCTUuJlGWq7-YHYjs7NwVhmtDnVcrlA3iLmzLLGTAdaB-j736h68Oxv-JM1I0AFjoG1OzPfX023c1nhobUoT39QeKsRzS8owM8DFTG_pE6dcVl70AQAA" target="_blank" rel="noopener nofollow">demo</a>）：</p>
<pre><code class="language-svelte">&lt;!--- file: Child.svelte ---&gt;
&lt;script&gt;
	let { object = { count: 0 } } = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; {
	// 如果使用默认值，是没有效果的
	object.count += 1
}}&gt;
	点击次数：{object.count}
&lt;/button&gt;
</code></pre>
<p>总之：不要修改 props。要么使用回调 props 来传递变化，要么——如果父子组件应该共享同一个对象——使用 <a href="https://svelte.yayujs.com/docs/svelte/$bindable" target="_blank" rel="noopener nofollow"><code>$bindable</code></a> 符文。</p>
<h3 id="类型安全">类型安全</h3>
<p>通过对 props 进行注解，你可以为组件添加类型安全，就像对其他变量声明一样。在 TypeScript 中，它看起来是这样的...</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
	let { adjective }: { adjective: string } = $props();
&lt;/script&gt;
</code></pre>
<p>...而在 JSDoc 中你可以这样做：</p>
<pre><code class="language-svelte">&lt;script&gt;
	/** @type {{ adjective: string }} */
	let { adjective } = $props();
&lt;/script&gt;
</code></pre>
<p>当然，你也可以将类型声明与注解分开：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
	interface Props {
		adjective: string;
	}

	let { adjective }: Props = $props();
&lt;/script&gt;
</code></pre>
<p>建议添加类型，这样可以确保使用你组件的人可以轻松发现他们应该提供哪些 props。</p>
<h2 id="bindable">$bindable</h2>
<p>通常情况下，props 是单向的，从父组件流向子组件。这使得理解应用中的数据流向变得容易。</p>
<p>在 Svelte 中，组件的 props 可以被<em>绑定</em>，这意味着数据也可以从子组件流向父组件。这不是你应该经常做的事情，但如果谨慎且适度地使用，可以简化你的代码。</p>
<p>这也意味着状态代理可以在子组件中被<em>修改</em>。</p>
<blockquote>
<p>[!NOTE] 普通的 props 也可以被修改，但强烈不建议这样做 — 如果 Svelte 检测到一个组件正在修改它不"拥有"的状态，会发出警告。</p>
</blockquote>
<p>要将一个 prop 标记为可绑定的，我们使用 <code>$bindable</code> 符文：</p>

<pre><code class="language-svelte">/// file: FancyInput.svelte
&lt;script&gt;
	let { value = $bindable(), ...props } = $props();
&lt;/script&gt;

&lt;input bind:value={value} {...props} /&gt;

&lt;style&gt;
	input {
		font-family: 'Comic Sans MS';
		color: deeppink;
	}
&lt;/style&gt;
</code></pre>
<p>现在，使用 <code>&lt;FancyInput&gt;</code> 的组件可以添加 <a href="https://svelte.yayujs.com/docs/svelte/bind" target="_blank" rel="noopener nofollow"><code>bind:</code></a> 指令（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE3WQwWrDMBBEf2URBSfg2nfFMZRCoYeecqx6UJx1IyqvhLUONcb_XqSkTUOSk1az7DBvJtEai0HI90nw6FHIJIhckO7i78n7IhzQctS2OuAtvXHESByEFFVoeuO5VqTYdN71DC-amvGV_MDQ9q6DrCjP0skkWymKJxYZOgxBfyKs4SGwZlxke7TWZcuVoqo8-1P1z3lraCcP2g64nk4GM5S1osrXf0JV-lrkgvGbheR-wDm_g30V8JL-1vpOCZFogpQsEsWcemtxscyhKArfOx9gjps0Lq4hzRVfemaYfu-PoIqqwKPFY_XpaIqj4tYRP7a6M3aUkD27zjSw0RTgbZN6Z8WNs66XsEP03tBXUueUJFlelvYx_wCuI3leNwIAAA==" target="_blank" rel="noopener nofollow">demo</a>）:</p>

<pre><code class="language-svelte">/// App.svelte
&lt;script&gt;
	import FancyInput from './FancyInput.svelte';

	let message = $state('hello');
&lt;/script&gt;

&lt;FancyInput bind:value={message} /&gt;
&lt;p&gt;{message}&lt;/p&gt;
</code></pre>
<p>父组件不<em>一定</em>非要使用 <code>bind:</code> — 它可以只传递一个普通的 prop。有些父组件不想听取子组件要说的话。</p>
<p>在这种情况下，你可以为没有传递 prop 时指定一个后备值：</p>
<pre><code class="language-js">/// file: FancyInput.svelte
let { value = $bindable('fallback'), ...props } = $props();
</code></pre>
<h2 id="inspect">$inspect</h2>
<blockquote>
<p>[!NOTE] <code>$inspect</code> 仅在开发环境有效。在生产构建中它会变成空操作。</p>
</blockquote>
<p><code>$inspect</code> 符文大致等同于 <code>console.log</code>，不同之处在于当其参数发生变化时它会重新运行。<code>$inspect</code> 会深度跟踪响应式状态，这意味着使用细粒度响应性更新对象或数组内的内容会导致它重新触发(<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACkWQ0YqDQAxFfyUMhSotdZ-tCvu431AXtGOqQ2NmmMm0LOK_r7Utfby5JzeXTOpiCIPKT5PidkSVq2_n1F7Jn3uIcEMSXHSw0evHpAjaGydVzbUQCmgbWaCETZBWMPlKj29nxBDaHj_edkAiu12JhdkYDg61JGvE_s2nR8gyuBuiJZuDJTyQ7eE-IEOzog1YD80Lb0APLfdYc5F9qnFxjiKWwbImo6_llKRQVs-2u91c_bD2OCJLkT3JZasw7KLA2XCX31qKWE6vIzNk1fKE0XbmYrBTufiI8-_8D2cUWBA_AQAA" target="_blank" rel="noopener nofollow">demo</a>):</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);
	let message = $state('hello');

	$inspect(count, message); // 当 `count` 或 `message` 改变时会调用 console.log
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;递增&lt;/button&gt;
&lt;input bind:value={message} /&gt;
</code></pre>
<h3 id="inspectwith">$inspect(...).with</h3>
<p><code>$inspect</code> 返回一个 <code>with</code> 属性，你可以用回调函数调用它，该回调函数将代替 <code>console.log</code> 被调用。回调函数的第一个参数是 <code>"init"</code> 或 <code>"update"</code>；后续参数是传递给 <code>$inspect</code> 的值(<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAACkVQ24qDMBD9lSEUqlTqPlsj7ON-w7pQG8c2VCchmVSK-O-bKMs-DefKYRYx6BG9qL4XQd2EohKf1opC8Nsm4F84MkbsTXAqMbVXTltuWmp5RAZlAjFIOHjuGLOP_BKVqB00eYuKs82Qn2fNjyxLtcWeyUE2sCRry3qATQIpJRyD7WPVMf9TW-7xFu53dBcoSzAOrsqQNyOe2XUKr0Xi5kcMvdDB2wSYO-I9vKazplV1-T-d6ltgNgSG1KjVUy7ZtmdbdjqtzRcphxMS1-XubOITJtPrQWMvKnYB15_1F7KKadA_AQAA" target="_blank" rel="noopener nofollow">demo</a>):</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = $state(0);

	$inspect(count).with((type, count) =&gt; {
		if (type === 'update') {
			debugger; // 或者使用 `console.trace`，或任何你想要的
		}
	});
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;递增&lt;/button&gt;
</code></pre>
<p>一个找到某些更改的来源的便捷方法是将 <code>console.trace</code> 传递给 <code>with</code>：</p>
<pre><code class="language-js">// @errors: 2304
$inspect(stuff).with(console.trace);
</code></pre>
<h3 id="inspecttrace">$inspect.trace(...)</h3>
<p>这个符文在 5.14 版本中添加，会使周围的函数在开发环境中被追踪。每当函数作为 <a href="https://svelte.yayujs.com/docs/svelte/$effect" target="_blank" rel="noopener nofollow">effect</a> 或 <a href="https://svelte.yayujs.com/docs/svelte/$derived" target="_blank" rel="noopener nofollow">derived</a> 的一部分重新运行时，控制台都会打印出哪些响应式状态导致了 effect 触发。</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { doSomeWork } from './elsewhere';

	$effect(() =&gt; {
		+++$inspect.trace();+++
		doSomeWork();
	});
&lt;/script&gt;
</code></pre>
<p><code>$inspect.trace</code> 接受一个可选的第一参数，该参数将被用作标签。</p>
<h2 id="host">$host</h2>
<p>当将组件编译为自定义元素时，<code>$host</code> 符文提供了对宿主元素的访问，使您能够（例如）触发自定义事件（<a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE41Ry2rDMBD8FSECtqkTt1fHFpSSL-ix7sFRNkTEXglrnTYY_3uRlDgxTaEHIfYxs7szA9-rBizPPwZOZwM89wmecqxbF70as7InaMjltrWFR3mpkQDJ8pwXVnbKkKiwItUa3RGLVtk7gTHQXRDR2lXda4CY1D0SK9nCUk0QPyfrCovsRoNFe17aQOAwGncgO2gBqRzihJXiQrEs2csYOhQ-7HgKHaLIbpRhhBG-I2eD_8ciM4KnnOCbeE5dD2P6h0Dz0-Yi_arNhPLJXBtSGi2TvSXdbpqwdsXvjuYsC1veabvvUTog2ylrapKH2G2XsMFLS4uDthQnq2t1cwKkGOGLvYU5PvaQxLsxOkPmsm97Io1Mo2yUPF6VnOZFkw1RMoopKLKAE_9gmGxyDFMwMcwN-Bx_ABXQWmOtAgAA" target="_blank" rel="noopener nofollow">demo</a>）:</p>

<pre><code class="language-svelte">/// file: Stepper.svelte
&lt;svelte:options customElement="my-stepper" /&gt;

&lt;script&gt;
	function dispatch(type) {
		+++$host()+++.dispatchEvent(new CustomEvent(type));
	}
&lt;/script&gt;

&lt;button onclick={() =&gt; dispatch('decrement')}&gt;减少&lt;/button&gt;
&lt;button onclick={() =&gt; dispatch('increment')}&gt;增加&lt;/button&gt;
</code></pre>

<pre><code class="language-svelte">/// file: App.svelte
&lt;script&gt;
	import './Stepper.svelte';

	let count = $state(0);
&lt;/script&gt;

&lt;my-stepper
	ondecrement={() =&gt; count -= 1}
	onincrement={() =&gt; count += 1}
&gt;&lt;/my-stepper&gt;

&lt;p&gt;计数: {count}&lt;/p&gt;
</code></pre>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>本篇已收录在掘金专栏 <a href="https://juejin.cn/column/7459299646696374284" target="_blank" rel="noopener nofollow">《Svelte 中文文档》</a>，该系列预计 40 篇。</p>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>通过文字建立交流本身就是一种缘分，欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“低调务实优秀中国好青年”</a>前端社群，分享技术，带你成长。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.18141518287268518" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 13:53">2025-01-22 13:53</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18685674" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18685674);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18685674', targetLink: 'https://www.cnblogs.com/yayujs/p/18685674', title: 'Svelte 最新中文文档翻译（4）——  符文（Runes）下' })">举报</a>
</div>
        