
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18712729" title="发布于 2025-02-17 17:11">
    <span role="heading" aria-level="2">.NET Core常用集合的几个坑</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="c中的常见集合">C#中的常见集合</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250214142607576-1172321580.png" alt="image" loading="lazy"></p>
<blockquote>
<p>注意，箭头线不代表继承关系，只代表功能上的加强，如有错误，欢迎指出。</p>
</blockquote>
<h2 id="泛型集合时间复杂度">泛型集合时间复杂度</h2>
<table>
<thead>
<tr>
<th><strong>集合类型</strong></th>
<th><strong>添加</strong></th>
<th><strong>删除</strong></th>
<th><strong>查找</strong></th>
<th><strong>访问（索引/键）</strong></th>
<th><strong>遍历</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>List&lt;T&gt;</code></strong></td>
<td>O(1)（均摊）</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>动态数组；删除/插入中间元素需移动数据</td>
</tr>
<tr>
<td><strong><code>SortedList&lt;T&gt;</code></strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(1)（按索引）</td>
<td>O(n)</td>
<td>内部维护排序数组；插入需移动元素</td>
</tr>
<tr>
<td><strong><code>Dictionary&lt;T,K&gt;</code></strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>哈希表实现；最坏情况 O(n)（哈希冲突）</td>
</tr>
<tr>
<td><strong><code>HashSet&lt;T&gt;</code></strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>-</td>
<td>O(n)</td>
<td>哈希表实现；同 <code>Dictionary</code> 的哈希行为</td>
</tr>
<tr>
<td><strong><code>Stack&lt;T&gt;</code></strong></td>
<td>O(1)（Push）</td>
<td>O(1)（Pop）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>数组或链表实现</td>
</tr>
<tr>
<td><strong><code>Queue&lt;T&gt;</code></strong></td>
<td>O(1)（Enqueue）</td>
<td>O(1)（Dequeue）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>数组或链表实现</td>
</tr>
<tr>
<td><strong><code>PriorityQueue&lt;T&gt;</code></strong></td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>-</td>
<td>O(1)（Peek）</td>
<td>-</td>
<td>基于堆结构实现</td>
</tr>
<tr>
<td><strong><code>SortedSet&lt;T&gt;</code></strong></td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>-</td>
<td>O(n)</td>
<td>基于平衡二叉搜索树（如红黑树）</td>
</tr>
<tr>
<td><strong><code>SortedDictionary&lt;T,K&gt;</code></strong></td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>-</td>
<td>O(n)</td>
<td>基于平衡二叉搜索树（类似 <code>SortedSet</code>）</td>
</tr>
<tr>
<td><strong><code>LinkedList&lt;T&gt;</code></strong></td>
<td>O(1)（头/尾）</td>
<td>O(1)（已知节点）</td>
<td>O(n)</td>
<td>-</td>
<td>O(n)</td>
<td>双向链表；查找需遍历</td>
</tr>
</tbody>
</table>
<h2 id="线程安全集合时间复杂度">线程安全集合时间复杂度</h2>
<table>
<thead>
<tr>
<th><strong>集合类型</strong></th>
<th><strong>添加</strong></th>
<th><strong>删除</strong></th>
<th><strong>查找</strong></th>
<th><strong>访问（索引/键）</strong></th>
<th><strong>遍历</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ConcurrentBag&lt;T&gt;</code></td>
<td>平均 O(1)</td>
<td>平均 O(1)</td>
<td>O(n)</td>
<td>不支持</td>
<td>O(n)</td>
<td>线程安全无序集合，适用于多生产者 - 多消费者场景</td>
</tr>
<tr>
<td><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code></td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>O(n)</td>
<td>基于分段锁和哈希表实现的线程安全字典</td>
</tr>
<tr>
<td><code>ConcurrentStack&lt;T&gt;</code></td>
<td>平均 O(1)</td>
<td>平均 O(1)</td>
<td>O(n)</td>
<td>不支持</td>
<td>O(n)</td>
<td>线程安全的后进先出（LIFO）集合</td>
</tr>
<tr>
<td><code>ConcurrentQueue&lt;T&gt;</code></td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)</td>
<td>O(n)</td>
<td>不支持</td>
<td>O(n)</td>
<td>线程安全的先进先出（FIFO）集合</td>
</tr>
</tbody>
</table>
<h2 id="不可变集合时间复杂度">不可变集合时间复杂度</h2>
<p>以下是 C# 中 <code>ImmutableList&lt;T&gt;</code>、<code>ImmutableSortedDictionary&lt;TKey, TValue&gt;</code>、<code>ImmutableDictionary&lt;TKey, TValue&gt;</code>、<code>ImmutableHashSet&lt;T&gt;</code>、<code>ImmutableStack&lt;T&gt;</code> 和 <code>ImmutableQueue&lt;T&gt;</code> 这些不可变集合常见操作的时间复杂度表格：</p>
<table>
<thead>
<tr>
<th><strong>集合类型</strong></th>
<th><strong>添加</strong></th>
<th><strong>删除</strong></th>
<th><strong>查找</strong></th>
<th><strong>访问（索引/键）</strong></th>
<th><strong>遍历</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ImmutableList&lt;T&gt;</code></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>基于数组实现的不可变列表，每次修改操作都会创建新列表，访问指定索引元素较快</td>
</tr>
<tr>
<td><code>ImmutableSortedDictionary&lt;TKey, TValue&gt;</code></td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>基于红黑树实现的按键排序的不可变字典，元素按键排序，操作复杂度基于树的高度</td>
</tr>
<tr>
<td><code>ImmutableDictionary&lt;TKey, TValue&gt;</code></td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>O(n)</td>
<td>基于哈希表实现的不可变字典，操作复杂度受哈希冲突影响</td>
</tr>
<tr>
<td><code>ImmutableHashSet&lt;T&gt;</code></td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>不适用</td>
<td>O(n)</td>
<td>基于哈希表实现的不可变集合，存储唯一元素，操作复杂度受哈希冲突影响</td>
</tr>
<tr>
<td><code>ImmutableStack&lt;T&gt;</code></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>不适用</td>
<td>O(n)</td>
<td>基于链表实现的不可变栈，后进先出，添加和删除操作在栈顶进行</td>
</tr>
<tr>
<td><code>ImmutableQueue&lt;T&gt;</code></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>不适用</td>
<td>O(n)</td>
<td>基于链表实现的不可变队列，先进先出，添加和删除操作分别在队尾和队首进行</td>
</tr>
</tbody>
</table>
<h2 id="只读集合时间复杂度">只读集合时间复杂度</h2>
<table>
<thead>
<tr>
<th><strong>集合类型</strong></th>
<th><strong>添加</strong></th>
<th><strong>删除</strong></th>
<th><strong>查找</strong></th>
<th><strong>访问（索引/键）</strong></th>
<th><strong>遍历</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ReadOnlyCollection&lt;T&gt;</code></td>
<td>不支持</td>
<td>不支持</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>对 <code>IList&lt;T&gt;</code> 的只读包装，可通过索引直接访问元素，查找需遍历集合</td>
</tr>
<tr>
<td><code>ReadOnlyObservableCollection&lt;T&gt;</code></td>
<td>不支持</td>
<td>不支持</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>继承自 <code>ReadOnlyCollection&lt;T&gt;</code> 且实现 <code>INotifyCollectionChanged</code>，基本操作复杂度与 <code>ReadOnlyCollection&lt;T&gt;</code> 相同</td>
</tr>
<tr>
<td><code>ReadOnlyDictionary&lt;TKey, TValue&gt;</code></td>
<td>不支持</td>
<td>不支持</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>平均 O(1)，最坏 O(n)</td>
<td>O(n)</td>
<td>对 <code>IDictionary&lt;TKey, TValue&gt;</code> 的只读包装，基于哈希表，操作复杂度受哈希冲突影响</td>
</tr>
</tbody>
</table>
<h1 id="list">List</h1>
<p>当你创建一个新的List对象时，若没有指定初始容量，默认为0，不过当第一个元素被添加进去时，它会自动将容量初始化为4.并在下次扩容时，以双倍的容量进行扩容。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250214152622507-163499998.png" alt="image" loading="lazy"></p>
<h2 id="listinsert0-item-的坑">List.Insert(0, item) 的坑</h2>
<p>List基于数组实现，数组在内存中是连续存储的。当使用 Insert(0, item) 在列表开头插入元素时，列表中现有的所有元素都需要向后移动一个位置，以便为新元素腾出空间。这意味着插入操作的时间复杂度为O(n) ，其中n是列表中现有元素的数量。元素数量越多，移动元素所花费的时间就越长，性能也就越低。</p>
<pre><code>        public void Insert(int index, T item)
        {
            // Note that insertions at the end are legal.
            if ((uint)index &gt; (uint)_size)
            {
                ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);
            }
            if (_size == _items.Length) Grow(_size + 1);
            if (index &lt; _size)
            {
				//如果index很靠前，且数组size很大的话。这将是一场灾难。
                Array.Copy(_items, index, _items, index + 1, _size - index);
            }
            _items[index] = item;
            _size++;
            _version++;
        }
</code></pre>
<h1 id="hashsetdictionary">HashSet/Dictionary</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217105338235-21506395.png" alt="image" loading="lazy"></p>
<p>Dictionary&lt;TKey, TValue&gt; 的底层结构主要由以下几个部分组成：</p>
<ol>
<li>桶（Bucket）数组：这是一个一维数组，数组的每个元素称为一个桶。桶数组的大小是 Dictionary 的容量，初始容量通常是一个较小的质数，后续会根据元素数量的增加而动态调整。</li>
<li>条目（Entry）数组：每个桶对应一个或多个条目，条目是一个结构体，包含三个重要的字段：<br>
*. int hashCode：键的哈希码，用于确定键在桶数组中的位置。<br>
*. int next：指向下一个条目的索引，用于处理哈希冲突。如果该值为 -1，表示这是该桶中的最后一个条目。<br>
*. TKey key：存储的键。<br>
*. TValue value：存储的值。</li>
</ol>
<h2 id="add的坑">Add的坑</h2>
<pre><code>private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior)
{
	//计算出key的hash
	uint hashCode = (uint)((typeof(TKey).IsValueType &amp;&amp; comparer == null) ? key.GetHashCode() : comparer!.GetHashCode(key));
	//将哈希码与桶数组的长度进行取模运算（hashCode % bucket.Length），得到该键值对应在桶数组中的索引位置。
	ref int bucket = ref GetBucket(hashCode);
	int i = bucket - 1; // Value in _buckets is 1-based
	
	uint collisionCount = 0;
	
	while (true)
	{
		// Should be a while loop https://github.com/dotnet/runtime/issues/9422
		// Test uint in if rather than loop condition to drop range check for following array access
		if ((uint)i &gt;= (uint)entries.Length)
		{
			break;
		}
		//
		if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))
		{
			return false;
		}
		//如果该桶已经有其他条目（即发生了哈希冲突），则通过 next 字段将新条目链接到该桶的链表中。
		i = entries[i].next;
		
		
		collisionCount++;
		//如果循环次数&gt;Entry的长度，说明有死循环，抛出异常。
		if (collisionCount &gt; (uint)entries.Length)
		{
			// 在Framework时代，并发情况下会导致entries[i].next被错误定位。
			// 从而形成一个‌‌‌死链表，导致Contains查询时，陷入死循环，CPU异常高。
			// 在.NET Core中,通过collisionCount来计数，从而规避死循环。
			ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
		}
	}
}
</code></pre>
<h1 id="concurrentdictionary">ConcurrentDictionary</h1>
<p>ConcurrentDictionary&lt;TKey, TValue&gt; 的底层核心是由多个分段（Segment）组成，每个分段本质上是一个小型的哈希表，并且每个分段都有自己独立的锁。这种设计将整个字典划分为多个部分，不同线程可以同时访问不同的分段，从而减少锁的竞争，提高并发性能。</p>
<blockquote>
<p>简单来说就是多个Dictionary组合<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217143609585-424918771.png" alt="image" loading="lazy"></p>
</blockquote>
<ol>
<li>VolatileNode[]<br>
内部的Node类和Dictionary的Entry一致<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217143735432-119658328.png" alt="image" loading="lazy"></li>
<li>Locks[]<br>
将一个大锁拆成多个小锁，提高锁的颗粒度，尽可能小的避免锁竞争。</li>
</ol>
<h2 id="keysvalues的坑">keys/values的坑</h2>
<p>不要高频次调用属性，因为它们会返回一个全新的List<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217144256836-963768065.png" alt="image" loading="lazy"></p>
<h2 id="valuefactory的坑">ValueFactory的坑</h2>
<p>在使用ConcurrentDictionary的过程中，大家会理所当然认为所有操作是线程安全的。但面对GetOrAdd/GetOrUpdate中的ValueFactory方法时，却是线程不安全的。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217144805061-38246170.png" alt="image" loading="lazy"></p>
<p>原因也很简单，ValueFactory会被先执行，再执行从TryUpdateInternal。因此，你有几个线程就会重复执行几次。</p>
<blockquote>
<p>举个例子，偷懒用其它大佬的例子。<a href="https://www.cnblogs.com/CreateMyself/p/6086752.html" target="_blank">https://www.cnblogs.com/CreateMyself/p/6086752.html</a><br>
如果要确保线程安全，需要搭配Lazy&lt;&gt;.</p>
</blockquote>
<h1 id="concurrentqueue">ConcurrentQueue</h1>
<p>ConcurrentQueue 底层主要基于链表（Linked List）数据结构实现，链表是一种动态的数据结构，由一系列节点（ConcurrentQueueSegment）组成，每个节点包含一个数据元素和一个指向下一个节点的引用。为了保证线程安全，ConcurrentQueue 在链表的基础上使用了无锁（Lock - Free）算法，主要借助原子操作（如 Interlocked 类提供的方法）来避免传统锁带来的性能开销和潜在的死锁问题<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250217155513250-1640567869.png" alt="image" loading="lazy"></p>
<ol>
<li>头指针（head）<br>
头指针指向队列的第一个节点，用于出队操作</li>
<li>尾指针（tail）<br>
尾指针指向队列的最后一个节点，用于入队操作</li>
</ol>
<h2 id="count的坑">Count的坑</h2>
<p>不要高频次调用Count属性，因为内部调用逻辑非常复杂，需要遍历每一个Segment的head,tail之间的差值，动态计算出最终的大小，且还有加锁操作，消耗也不低。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>        public int Count
        {
            get
            {
                SpinWait spinner = default;
                while (true)
                {
                    // Capture the head and tail, as well as the head's head and tail.
                    ConcurrentQueueSegment&lt;T&gt; head = _head;
                    ConcurrentQueueSegment&lt;T&gt; tail = _tail;
                    int headHead = Volatile.Read(ref head._headAndTail.Head);
                    int headTail = Volatile.Read(ref head._headAndTail.Tail);

                    if (head == tail)
                    {
                        // There was a single segment in the queue.  If the captured segments still
                        // match, then we can trust the values to compute the segment's count. (It's
                        // theoretically possible the values could have looped around and still exactly match,
                        // but that would required at least ~4 billion elements to have been enqueued and
                        // dequeued between the reads.)
                        if (head == _head &amp;&amp;
                            tail == _tail &amp;&amp;
                            headHead == Volatile.Read(ref head._headAndTail.Head) &amp;&amp;
                            headTail == Volatile.Read(ref head._headAndTail.Tail))
                        {
                            return GetCount(head, headHead, headTail);
                        }
                    }
                    else if (head._nextSegment == tail)
                    {
                        // There were two segments in the queue.  Get the positions from the tail, and as above,
                        // if the captured values match the previous reads, return the sum of the counts from both segments.
                        int tailHead = Volatile.Read(ref tail._headAndTail.Head);
                        int tailTail = Volatile.Read(ref tail._headAndTail.Tail);
                        if (head == _head &amp;&amp;
                            tail == _tail &amp;&amp;
                            headHead == Volatile.Read(ref head._headAndTail.Head) &amp;&amp;
                            headTail == Volatile.Read(ref head._headAndTail.Tail) &amp;&amp;
                            tailHead == Volatile.Read(ref tail._headAndTail.Head) &amp;&amp;
                            tailTail == Volatile.Read(ref tail._headAndTail.Tail))
                        {
                            return GetCount(head, headHead, headTail) + GetCount(tail, tailHead, tailTail);
                        }
                    }
                    else
                    {
                        // There were more than two segments in the queue.  Fall back to taking the cross-segment lock,
                        // which will ensure that the head and tail segments we read are stable (since the lock is needed to change them);
                        // for the two-segment case above, we can simply rely on subsequent comparisons, but for the two+ case, we need
                        // to be able to trust the internal segments between the head and tail.
                        lock (_crossSegmentLock)
                        {
                            // Now that we hold the lock, re-read the previously captured head and tail segments and head positions.
                            // If either has changed, start over.
                            if (head == _head &amp;&amp; tail == _tail)
                            {
                                // Get the positions from the tail, and as above, if the captured values match the previous reads,
                                // we can use the values to compute the count of the head and tail segments.
                                int tailHead = Volatile.Read(ref tail._headAndTail.Head);
                                int tailTail = Volatile.Read(ref tail._headAndTail.Tail);
                                if (headHead == Volatile.Read(ref head._headAndTail.Head) &amp;&amp;
                                    headTail == Volatile.Read(ref head._headAndTail.Tail) &amp;&amp;
                                    tailHead == Volatile.Read(ref tail._headAndTail.Head) &amp;&amp;
                                    tailTail == Volatile.Read(ref tail._headAndTail.Tail))
                                {
                                    // We got stable values for the head and tail segments, so we can just compute the sizes
                                    // based on those and add them. Note that this and the below additions to count may overflow: previous
                                    // implementations allowed that, so we don't check, either, and it is theoretically possible for the
                                    // queue to store more than int.MaxValue items.
                                    int count = GetCount(head, headHead, headTail) + GetCount(tail, tailHead, tailTail);

                                    // Now add the counts for each internal segment. Since there were segments before these,
                                    // for counting purposes we consider them to start at the 0th element, and since there is at
                                    // least one segment after each, each was frozen, so we can count until each's frozen tail.
                                    // With the cross-segment lock held, we're guaranteed that all of these internal segments are
                                    // consistent, as the head and tail segment can't be changed while we're holding the lock, and
                                    // dequeueing and enqueueing can only be done from the head and tail segments, which these aren't.
                                    for (ConcurrentQueueSegment&lt;T&gt; s = head._nextSegment!; s != tail; s = s._nextSegment!)
                                    {
                                        Debug.Assert(s._frozenForEnqueues, "Internal segment must be frozen as there's a following segment.");
                                        count += s._headAndTail.Tail - s.FreezeOffset;
                                    }

                                    return count;
                                }
                            }
                        }
                    }

                    // We raced with enqueues/dequeues and captured an inconsistent picture of the queue.
                    // Spin and try again.
                    spinner.SpinOnce();
                }
            }
        }
		private static int GetCount(ConcurrentQueueSegment&lt;T&gt; s, int head, int tail)
        {
            if (head != tail &amp;&amp; head != tail - s.FreezeOffset)
            {
                head &amp;= s._slotsMask;
                tail &amp;= s._slotsMask;
                return head &lt; tail ? tail - head : s._slots.Length - head + tail;
            }
            return 0;
        }
</code></pre>
</details>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.04552996057291667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-17 17:12">2025-02-17 17:11</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712729" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712729);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712729', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18712729', title: '.NET Core常用集合的几个坑' })">举报</a>

		</p>
	