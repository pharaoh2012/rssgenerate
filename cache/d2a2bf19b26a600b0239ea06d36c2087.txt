
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chang-an-22-lyh/p/19006619/mo_dui_er_ci_li_xian-zj" title="发布于 2025-07-26 21:08">
    <span role="heading" aria-level="2">莫队二次离线 学习笔记</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>莫队二次离线，是由数据结构题之神lxl所发明的一种数据结构。因为莫队中 <span class="math inline">\(ans\)</span> 的变化同样不要求立刻反应，所以我们可以离线求解莫队中每次 <span class="math inline">\(ans\)</span> 修改值 <span class="math inline">\(F(x,[l,r])\)</span>。设单次求解修改值的时间复杂度为 <span class="math inline">\(O(k)\)</span>，那么莫队二次离线可以将时间复杂度从 <span class="math inline">\(O(nk\sqrt n)\)</span> 变为 <span class="math inline">\(O(n\sqrt n+nk)\)</span>。</p>
<p>注：上文、下文的 <span class="math inline">\(F(x,[l,r])\)</span> 表示区间 <span class="math inline">\([l,r]\)</span> 对 <span class="math inline">\(ans_x\)</span> 的贡献，<span class="math inline">\(f(x,a)=F(x,[1,a])\)</span>。</p>
<h1 id="莫队二次离线的一些限制">莫队二次离线的一些限制</h1>
<p>莫队二次离线有以下几种限制：</p>
<ol>
<li>当前答案不会影响下一次修改的决策（我就没见过这种情况，有见过的大佬讨论区发一下，谢谢）。</li>
<li>满足 <span class="math inline">\(F(x,[l,r])=f(x,r)-f(x,l-1)\)</span>。</li>
</ol>
<p>当然，假如 <span class="math inline">\(O(k)=O(1)\)</span> 的话，你也没有必要进行莫队二次离线。</p>
<h1 id="莫队二次离线空间-">莫队二次离线（空间 <span class="math inline">\(O(n\sqrt n)\)</span>）</h1>
<p>我们先考虑右指针右移的情况。</p>
<p>设当前右指针为 <span class="math inline">\(r\)</span>，左指针为 <span class="math inline">\(l\)</span>，那么一次右指针右移操作对 <span class="math inline">\(ans\)</span> 的贡献即为 <span class="math inline">\(F_{r+1,[l,r]}\)</span>，同时 <span class="math inline">\(r\to r+1\)</span>。</p>
<p>根据限制 2，我们可以将贡献差分为 <span class="math inline">\(f_{r+1,r}-f_{r+1,l-1}\)</span>。</p>
<p>同理，右端点左移的贡献就是 <span class="math inline">\(f_{r,l-1}-f_{r,r-1}\)</span>，左端点右移的贡献就是 <span class="math inline">\(f_{l,l}-f_{l,r}\)</span>，左端点左移的贡献就是 <span class="math inline">\(f_{l-1,r}-f_{l-1,l-1}\)</span>。</p>
<p>我们在移动端点的同时，记录这些需要求的贡献，然后在遍历序列的同时进行求解即可。</p>
<p>例如模板题 luogu4887，普通莫队的时间复杂度为 <span class="math inline">\(O(\binom{14}kn+n\sqrt n)\)</span>，空间复杂度平颈为记录所有贡献，为 <span class="math inline">\(O(n\sqrt n)\)</span>。这样并不能通过此题，因为时间常数和空间过大了。但还是附上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N=1e5+5,M=(1&lt;&lt;14);
int n,m,k,a[N],c[M],cn,tg[M],nw1[N],nw2[N];
struct que2{int x,id,v;};vector&lt;que2&gt;qe[N];
struct que1{int l,r,id;}qu[N];ll ans[N];
int cmp(que1 x,que1 y){
	if(x.l/300!=y.l/300) return x.l/300&lt;y.l/300;
	if((x.l/300)&amp;1) return x.r&gt;y.r;return x.r&lt;y.r;
}void dfs(int x,int now,int num){
	if(x&gt;14) return;if(num==k) return c[++cn]=now,void();
	dfs(x+1,now|(1&lt;&lt;x),num+1),dfs(x+1,now,num);
}int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k,dfs(0,0,0);
	//这个马上讲
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i],nw1[i]=tg[a[i]];
		for(int j=1;j&lt;=cn;j++)
			tg[a[i]^c[j]]++;nw2[i]=tg[a[i]];
	}//塞入贡献
	for(int i=1;i&lt;=m;i++)
		cin&gt;&gt;qu[i].l&gt;&gt;qu[i].r,qu[i].id=i;
	memset(tg,0,sizeof(tg));
	sort(qu+1,qu+m+1,cmp);
	for(int i=1,l=1,r=0;i&lt;=m;i++){
		while(r&gt;qu[i].r){
			ans[qu[i].id]-=nw1[r];
			qe[l-1].push_back({r--,qu[i].id,1});
		}while(l&lt;qu[i].l){
			ans[qu[i].id]+=nw2[l];
			qe[r].push_back({l++,qu[i].id,-1});
		}while(r&lt;qu[i].r){
			ans[qu[i].id]+=nw1[++r];
			qe[l-1].push_back({r,qu[i].id,-1});
		}while(l&gt;qu[i].l){
			ans[qu[i].id]-=nw2[--l];
			qe[r].push_back({l,qu[i].id,1});
		}
	}//求解贡献
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=cn;j++) tg[a[i]^c[j]]++;
		for(auto x:qe[i]) ans[x.id]+=x.v*tg[a[x.x]];
	}//注意到我们算的是增量，所以还要再做一次前缀和
	for(int i=1;i&lt;=m;i++)
		ans[qu[i].id]+=ans[qu[i-1].id];
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
<h1 id="真莫队二次离线">真·莫队二次离线</h1>
<p>发现实际上我们可以将贡献分为两部分：<span class="math inline">\(f(x,x)/f(x,x-1)\)</span> 和 <span class="math inline">\(f(x,l-1)/f(x,r)\)</span>。</p>
<p>前面两个最多只有 <span class="math inline">\(O(n)\)</span> 种确定情况，可以预处理。</p>
<p>而后面两个，我们仍然挑选右指针右移进行举例。设当前右指针为 <span class="math inline">\(r\)</span>，目标位置为 <span class="math inline">\(R\)</span>，则实际上所有 <span class="math inline">\(f(x,l-1)\)</span> 的贡献可以表示为 <span class="math inline">\(\sum\limits_{i=R+1}^rf(i,l-1)\)</span>。那么我们可以将所有的状态 <span class="math inline">\((x,l-1)\)</span> 压缩成一个新状态 <span class="math inline">\((R+1,r,l-1)\)</span>。这样我们就可以用总计 <span class="math inline">\(O(n)\)</span> 的状态数记录贡献。时间常数和空间都大大降低了。</p>
<p>最终，真·二次离线莫队的时空复杂度为 <span class="math inline">\(O(nk+n\sqrt n),O(n)\)</span>。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int N=1e5+5,M=(1&lt;&lt;14);
int n,m,k,a[N],c[M],cn,tg[M];ll nw1[N],nw2[N];
struct que2{int l,r,id,v;};vector&lt;que2&gt;qe[N];
struct que1{int l,r,id;}qu[N];ll ans[N];
int cmp(que1 x,que1 y){
	if(x.l/300!=y.l/300) return x.l/300&lt;y.l/300;
	if((x.l/300)&amp;1) return x.r&gt;y.r;return x.r&lt;y.r;
}void dfs(int x,int now,int num){
	if(x&gt;14) return;if(num==k) return c[++cn]=now,void();
	dfs(x+1,now|(1&lt;&lt;x),num+1),dfs(x+1,now,num);
}int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k,dfs(0,0,0);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i],nw1[i]=tg[a[i]];
		for(int j=1;j&lt;=cn;j++)
			tg[a[i]^c[j]]++;nw2[i]=tg[a[i]];
		nw1[i]+=nw1[i-1],nw2[i]+=nw2[i-1];
	}for(int i=1;i&lt;=m;i++)
		cin&gt;&gt;qu[i].l&gt;&gt;qu[i].r,qu[i].id=i;
	memset(tg,0,sizeof(tg));
	sort(qu+1,qu+m+1,cmp);
	for(int i=1,l=1,r=0;i&lt;=m;i++){
		if(r&gt;qu[i].r){
			qe[l-1].push_back({qu[i].r+1,r,qu[i].id,1});
			ans[qu[i].id]-=nw1[r]-nw1[qu[i].r],r=qu[i].r;
		}if(l&lt;qu[i].l){
			qe[r].push_back({l,qu[i].l-1,qu[i].id,-1});
			ans[qu[i].id]+=nw2[qu[i].l-1]-nw2[l-1],l=qu[i].l;
		}if(r&lt;qu[i].r){
			qe[l-1].push_back({r+1,qu[i].r,qu[i].id,-1});
			ans[qu[i].id]+=nw1[qu[i].r]-nw1[r],r=qu[i].r;
		}if(l&gt;qu[i].l){
			qe[r].push_back({qu[i].l,l-1,qu[i].id,1});
			ans[qu[i].id]-=nw2[l-1]-nw2[qu[i].l-1],l=qu[i].l;
		}
	}for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=cn;j++) tg[a[i]^c[j]]++;
		for(auto x:qe[i])
			for(int j=x.l;j&lt;=x.r;j++) ans[x.id]+=x.v*tg[a[j]];
	}for(int i=1;i&lt;=m;i++)
		ans[qu[i].id]+=ans[qu[i-1].id];
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-26 21:08">2025-07-26 21:08</span>&nbsp;
<a href="https://www.cnblogs.com/chang-an-22-lyh">长安一片月_22</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19006619);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19006619', targetLink: 'https://www.cnblogs.com/chang-an-22-lyh/p/19006619/mo_dui_er_ci_li_xian-zj', title: '莫队二次离线 学习笔记' })">举报</a>
</div>
        