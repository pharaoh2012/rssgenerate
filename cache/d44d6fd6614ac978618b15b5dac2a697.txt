
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/justnow/p/18920352" title="发布于 2025-06-09 14:53">
    <span role="heading" aria-level="2">GGTalk 开源即时通讯系统源码剖析之：远程磁盘 （低调赠送GGTalk最新源码）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        GGTalk开源即时通讯IM的最新版中增加访问好友磁盘的功能：在一对一的对话窗口，请求方可以发起访问对方磁盘的请求，如果对方同意，则请求方就可以通过远程磁盘的窗口来操作对方的磁盘了。那么这个功能是如何实现的了？我们来剖析一下。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>&nbsp; &nbsp; &nbsp; 继上篇《<a href="https://www.cnblogs.com/justnow/p/18234498" target="_blank">GGTalk 开源即时通讯系统源码剖析之：聊天消息防错漏机制</a>》介绍了&nbsp;<a href="https://www.cnblogs.com/justnow/p/16600781.html" target="_blank"><strong>GGTalk</strong></a>&nbsp;对消息的可靠性，即消息的不丢失和不重复做了一系列优化处理，以保证不会错漏消息。这篇我们来剖析 GGTalk 新增的远程磁盘功能其对应的源码实现。</p>
<p>&nbsp; &nbsp; &nbsp; 在之前的博文《<a href="https://www.cnblogs.com/justnow/p/18877201" target="_blank">实现远程磁盘：像访问自己的电脑硬盘一样访问对方的电脑硬盘</a> 》，我们通过一个Demo介绍了访问远程磁盘如何实现。最近，我们已经在GGTalk开源即时通讯IM的最新版中增加访问好友磁盘的功能：在一对一的对话窗口，请求方可以发起访问对方磁盘的请求，如果对方同意，则请求方就可以通过远程磁盘的窗口来操作对方的磁盘了。现在我们来看看GGTalk的远程磁盘这一功能具体是如何实现的，大家可以先<a href="https://www.cnblogs.com/justnow/p/4990065.html" target="_blank">下载GGTalk的最新源码</a>，然后对照源码，更容易理解本文的内容。</p>
<h2>一. 定义消息协议</h2>
<p>&nbsp; &nbsp; &nbsp; 在远程磁盘请求方和应答方相互通信之前，我们先定义好远程磁盘这一功能需要用到的消息协议。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 交互媒体的类型。
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">enum</span><span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateMediaType</span>
{
    Video </span>= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">,
    Audio,
    RemoteHelp,
    RemoteControl,
    <span style="color: rgba(255, 0, 0, 1)">RemoteDisk</span>,
    GroupVideo
}</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 在交互媒体的类型枚举上，我们增加了 远程磁盘（RemoteDisk）这个类型。</p>
<p>&nbsp; &nbsp; &nbsp; 再结合原先的 CommunicateType 枚举，我们就可以组合出远程磁盘相关的业务通信：请求、应答（同意或拒绝）、中断等。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 交互的类型。比如 请求视频会话，同意视频会话，拒绝视频会话，终止视频会话
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">enum</span><span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateType</span>
{
    Request </span>= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">,
    Agree,
    Reject,
    Terminate,
    Busy
}</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;有了上面的铺垫，我们就可以来实现整个远程磁盘功能的业务流程了。</p>
<h2>二. 远程磁盘请求方实现</h2>
<p>&nbsp; &nbsp; &nbsp; &nbsp;首先，使用VS 2022 打开 GGTalk 解决方案，找到GGTalk 客户端项目（Windows版）：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609111559194-1249016505.png" alt=""></p>
<p>　　我们在一对一的聊天窗口 FriendChatForm （在Forms文件夹下）上增加“请求访问对方磁盘”的按钮，如下图所示：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609111859584-981218858.png" alt="" width="496" height="402"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;点击该按钮时，将执行如下动作：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> RequestControlFriendDisk()
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果自己掉线，则直接返回。</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.ClientGlobalCache.CurrentUser.UserStatus ==<span style="color: rgba(0, 0, 0, 1)"> UserStatus.OffLine)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }           

    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.ClientOutter.<strong>SendMediaCommunicate</strong>(<span style="color: rgba(0, 0, 255, 1)">this</span>.currentFriend.ID, <span style="color: rgba(0, 128, 128, 1)">CommunicateMediaType</span>.<span style="color: rgba(255, 0, 0, 1)">RemoteDisk</span>, CommunicateType.<span style="color: rgba(255, 0, 0, 1)">Request</span>, <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
    NDiskOutter diskOutter </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> NDiskOutter(<span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.RapidPassiveEngine, <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.resourceCenter.NDiskPassiveHandler);            
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.remoteDiskForm = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 128, 128, 1)">RemoteDiskForm</span>(<span style="color: rgba(0, 0, 255, 1)">this</span>.currentFriend.ID,ClientType.DotNET,<span style="color: rgba(0, 0, 255, 1)">this</span>.currentFriend.DisplayName, diskOutter, <span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.RapidPassiveEngine.FileOutter, <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.resourceCenter.CurrentUserID);
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.remoteDiskForm.RemoteDiskRequestCancelled += <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> CbGeneric(remoteDiskForm_RemoteDiskRequestCancelled);
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.remoteDiskForm.RemoteDiskEnded += <span style="color: rgba(0, 0, 255, 1)">new</span> CbGeneric&lt;<span style="color: rgba(0, 0, 255, 1)">bool</span>&gt;<span style="color: rgba(0, 0, 0, 1)">(remoteDiskForm_RemoteDiskEnded);
    </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.remoteDiskForm.Show();
}</span></pre>
</div>
<p>（1）客户端通过调用 IClientOutter 的&nbsp;SendMediaCommunicate 方法，来实现与远程磁盘功能相关的业务通信。</p>
<p>（2）通过 CommunicateMediaType.RemoteDisk 和 CommunicateType.Request 来表名这次交互发送的是一个远程磁盘请求。</p>
<p>（3）在等待对方应答期间，使用 RemoteDiskForm 来显示正在等待对方回复。如下图所示：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609113149334-1869537173.png" alt="" width="490" height="369"></p>
<p>（4）如果对方同意了远程磁盘请求，那么RemoteDiskForm 将改变状态，请求方就能通过该窗体来操作对方的磁盘，如下图所示：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609142306244-1360036672.png" alt="" width="493" height="336"></p>
<p>&nbsp; &nbsp; &nbsp; 关于&nbsp;RemoteDiskForm 的具体实现细节，可以参考 《<a href="https://www.cnblogs.com/justnow/p/18877201" target="_blank">实现远程磁盘：像访问自己的电脑硬盘一样访问对方的电脑硬盘</a>&nbsp;》。</p>
<h2>三. 远程磁盘应答方实现</h2>
<p>　　当应答方收到跟远程磁盘相关的业务消息时，会进入到 RemoteDiskManager的 HandleRemoteDisk 方法，如下代码所示：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> HandleRemoteDisk(<span style="color: rgba(0, 128, 128, 1)">CommunicateType</span> communicateType, <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> tag)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (communicateType ==<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateType</span>.Request)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.<span style="color: rgba(255, 0, 0, 1)">OnRemoteDiskRequestReceived</span>();
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.FlashWindow();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (communicateType ==<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateType</span>.Agree)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.OnRemoteDiskAnswerReceived(<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.FlashWindow();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (communicateType ==<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateType</span>.Reject)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.OnRemoteDiskAnswerReceived(<span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.FlashWindow();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (communicateType ==<span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 128, 128, 1)"> CommunicateType</span>.Terminate)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tag == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">owner</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.OnOwnerTerminateRemoteDisk();
        }
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
        {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.OnGuestCloseRemoteDisk();
        }
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.FlashWindow();
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }    
}</span></pre>
</div>
<p>（1）在 OnRemoteDiskRequestReceived 方法中，会在窗体的右侧，显示远程磁盘请求，如下截图：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609113624644-1091581231.png" alt="" width="523" height="424"></p>
<p>（2）当应答方点击“接受”或“拒绝”按钮时，也将通过调用 IClientOutter 的&nbsp;SendMediaCommunicate 方法（位于RemoteDiskManager类），来将回复消息发送给请求方。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span> remoteDiskRequestPanel_RemoteRequestAnswerd(<span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> agree)
{
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.ownerForm.RemoveDisplayedPanel(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.Title_Disk);    
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.ClientOutter.<span style="color: rgba(255, 0, 0, 1)">SendMediaCommunicate</span>(<span style="color: rgba(0, 0, 255, 1)">this</span>.currentFriend.ID, <span style="color: rgba(0, 128, 128, 1)">CommunicateMediaType</span>.RemoteDisk, agree ? <span style="color: rgba(0, 128, 128, 1)">CommunicateType</span>.Agree : <span style="color: rgba(0, 128, 128, 1)">CommunicateType</span>.Reject, <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">string</span> showText = <span style="color: rgba(0, 0, 255, 1)">string</span>.Format(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">您{0}了对方的磁盘访问请求。</span><span style="color: rgba(128, 0, 0, 1)">"</span>, agree ? <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">同意</span><span style="color: rgba(128, 0, 0, 1)">"</span> : <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">拒绝</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.AppendSysMessage(showText);

    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (agree)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.remoteDiskHandlePanel.OnAgree();
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.ownerForm.AddDisplayedPanel(<span style="color: rgba(0, 0, 255, 1)">this</span>.Title_Disk, <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.remoteDiskHandlePanel);
    }
}</span></pre>
</div>
<p>&nbsp;（3）如果点击“接受”按钮，则聊天窗体右侧将会出现“远程磁盘的控制面板”，以随时可以收回远程磁盘控制权。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/20404/202506/20404-20250609141935364-95326177.png" alt="" width="515" height="418"></p>
<p>（4）在对方控制自己磁盘的过程中，应答方点击上方的“终止”按钮，即可结束控制。这是给对方发送一个“终止控制”的 CommunicateType.Terminate 消息：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> remoteDiskHandlePanel_RemoteDiskTerminated()
{
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.ownerForm.RemoveDisplayedPanel(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.Title_Disk);
    </span><span style="color: rgba(0, 0, 255, 1)">this</span>.resourceCenter.ClientOutter.SendMediaCommunicate(<span style="color: rgba(0, 0, 255, 1)">this</span>.currentFriend.ID, <span style="color: rgba(0, 128, 128, 1)">CommunicateMediaType</span>.RemoteDisk, <span style="color: rgba(0, 128, 128, 1)">CommunicateType</span>.<span style="color: rgba(255, 0, 0, 1)">Terminate</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">owner</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">string</span> showText = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">您关闭了磁盘共享。</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.ownerForm.AppendSysMessage(showText);
}</span></pre>
</div>
<h2>四.&nbsp;结语</h2>
<p>&nbsp; &nbsp; &nbsp; 以上就是关于 GGTalk 远程磁盘功能的设计与实现的核心了。在某些办公场景中，远程磁盘这个功能还是很有用的，所以，GGTalk 即时通讯就实现该功能，方便那些有需要的人。</p>
<p>&nbsp; &nbsp; &nbsp; 如果你觉得还不错，请点赞支持啊！下篇再见！</p>
<p>&nbsp; &nbsp; &nbsp; 若需下载GGTalk最新源码，请移不到&nbsp;<a href="https://www.cnblogs.com/justnow/p/4990065.html" target="_blank">&nbsp;GGTalk 源码下载中心</a>&nbsp;，谢谢&nbsp;。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06168775887384259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-09 14:54">2025-06-09 14:53</span>&nbsp;
<a href="https://www.cnblogs.com/justnow">C#开源即时通讯GGTalk</a>&nbsp;
阅读(<span id="post_view_count">102</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18920352);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18920352', targetLink: 'https://www.cnblogs.com/justnow/p/18920352', title: 'GGTalk 开源即时通讯系统源码剖析之：远程磁盘 （低调赠送GGTalk最新源码）' })">举报</a>
</div>
        