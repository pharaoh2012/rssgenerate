
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/DAYceng/p/18925165" title="发布于 2025-06-12 11:13">
    <span role="heading" aria-level="2">一则复杂 SQL 改写后有感</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>抱歉很久没写技术博客。<br>
自从LLM爆发之后，写概念堆叠的所谓“博客”已经没有意义了，那么我会思考我的博客还有什么作用。</p>
<p>得出的结论是：<strong>具体业务的讨论仍然是有价值的</strong></p>
<p>所以之后会随缘更新一些强业务相关的博客</p>
<p>为什么说随缘呢？因为这段时间经历了一些事情，让我感觉比起死磕技术（工作），体验生活才是我的首要目标</p>
<blockquote>
<p>别说什么裁员的，真裁员我还来不及高兴呢</p>
</blockquote>
<p>以上，2025.06.12</p>
<h2 id="背景维护中遇到一段屎山-sql">背景：维护中遇到一段“屎山 SQL”</h2>
<p>近期在优化一个业务接口性能时，发现其背后依赖了一段极为复杂的 SQL 查询，执行时间长达 <strong>20 多秒</strong>。这段 SQL 看似在统计一些业务数据，但结构混乱、嵌套严重、含义难懂，最严重的是，<strong>其中一段使用了过度复杂的窗口函数嵌套，成为性能瓶颈</strong>。</p>
<p>本文记录我分析、重构并优化该 SQL 的过程，并结合实际经验，聊聊 SQL 优化中“理解数据关系 vs 语法技巧”的重要性。</p>
<hr>
<h2 id="原始-sql-功能分析">原始 SQL 功能分析</h2>
<p>该 SQL 由三部分构成，通过 <code>UNION ALL</code> 拼接。表结构如下：</p>
<ul>
<li><code>sdd_t_ace</code>: 主表，记录交易信息。字段有 <code>scan_seq_no</code>, <code>tr_date</code>, <code>status</code>, <code>b_code</code> 等。</li>
<li><code>aaa_t_tr_over_log</code>: 记录交易“处理完成”的日志。字段有 <code>scan_seq_no</code>, <code>finished_time</code></li>
<li><code>aaa_t_tr_obtain_log</code>: 记录交易“领取处理”的日志。字段有 <code>ace_id</code>, <code>tr_date</code></li>
</ul>
<h3 id="sql-三段查询的业务目标推测">SQL 三段查询的业务目标（推测）：</h3>
<p>太难看了只能靠猜</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>SQL 功能</th>
<th>推测业务目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>查询今日内所有交易记录数量</td>
<td>统计交易总量</td>
</tr>
<tr>
<td>②</td>
<td>查询今日内未完成的交易记录</td>
<td>统计待处理数量</td>
</tr>
<tr>
<td>③</td>
<td>查询今日内<strong>已完成但处理时间晚于某时间点</strong>，且<strong>已被领取</strong>的任务</td>
<td>检查延迟处理的任务</td>
</tr>
</tbody>
</table>
<h3 id="第三段-sql屎山核心原样示例已简化">第三段 SQL（屎山核心）原样示例（已简化）：</h3>
<pre><code class="language-sql">select scan_seq_no, finished_time, obtain_time
from (
    select scan_seq_no, finished_time
    from (
        select t1.scan_seq_no, t2.finished_time,
            row_number() over(partition by t2.scan_seq_no order by t2.finished_time desc) as rank1
        from sdd_t_ace t1
        left join aaa_t_tr_over_log t2 on t1.scan_seq_no = t2.scan_seq_no
        where t1.status != 0
          and t1.tr_date between curdate() and '2025-06-06 16:30'
    ) k1
    where finished_time &gt;= '2025-06-06 16:30' and rank1 = 1
) m1
left join aaa_t_tr_obtain_log m2 on m1.scan_seq_no = m2.scan_seq_no
where m2.tr_date &lt;= '2025-06-06 16:30'
</code></pre>
<h2 id="存在的问题分析">存在的问题分析</h2>
<table>
<thead>
<tr>
<th>问题点</th>
<th>描述</th>
<th>技术影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>多层嵌套</td>
<td>三层 SELECT 嵌套，逻辑难以理解</td>
<td>执行计划难优化，难排查</td>
</tr>
<tr>
<td>重复排序</td>
<td>两次 <code>row_number()</code> 排序</td>
<td>触发多次 <code>filesort</code>，严重拖慢性能</td>
</tr>
<tr>
<td>LEFT JOIN + WHERE</td>
<td>使用 LEFT JOIN 却又筛选右表字段</td>
<td>实际等同 INNER JOIN，但影响优化器判断</td>
</tr>
<tr>
<td>字段使用混乱</td>
<td><code>m1.scan_seq_no = m2.scan_seq_no</code> 实为业务等价字段，但未解释</td>
<td>增加阅读成本</td>
</tr>
</tbody>
</table>
<h2 id="重写目标保证结果一致逻辑清晰性能提升">重写目标：保证结果一致，逻辑清晰，性能提升</h2>
<p>优化后的 SQL（最终版本），如下：</p>
<pre><code class="language-sql">select substring(b_code, 1, 3) as b_code_per3, count(*) as dealTask_cnt
from (
  select distinct sdd.scan_seq_no, sdd.b_code
  from sdd_t_ace sdd
  inner join aaa_t_tr_over_log log on sdd.scan_seq_no = log.scan_seq_no
  inner join aaa_t_tr_obtain_log m2 on sdd.scan_seq_no = m2.ace_id
  where sdd.status != 0
    and log.finished_time &gt;= '2025-06-06 16:30'
    and sdd.tr_date between curdate() and '2025-06-06 16:30'
    and m2.tr_date &lt;= '2025-06-06 16:30'
) grouped
group by substring(b_code, 1, 3)
</code></pre>
<hr>
<h2 id="优化思路解析">优化思路解析</h2>
<h3 id="1-用-distinct-替代-row_number">1. 用 <code>distinct</code> 替代 <code>row_number()</code></h3>
<blockquote>
<p>原意是“每个 scan_seq_no 取最新的一条”，但如果我们能提前确认一条记录只会对应唯一一条日志，则无需 <code>row_number</code>，使用 <code>distinct</code> 更高效。</p>
</blockquote>
<h3 id="2-使用-inner-join-替代-left-join--where">2. 使用 <code>INNER JOIN</code> 替代 <code>LEFT JOIN + WHERE</code></h3>
<blockquote>
<p>原始代码中 <code>LEFT JOIN ... WHERE m2.tr_date &lt;= ...</code> 实际相当于 <code>INNER JOIN</code>，直接明确意图。</p>
</blockquote>
<h3 id="3-消除嵌套子查询">3. 消除嵌套子查询</h3>
<blockquote>
<p>去掉所有 <code>SELECT FROM (SELECT FROM (SELECT ...))</code> 的结构，提升可读性，也让优化器更好地生成执行计划。</p>
</blockquote>
<h3 id="4-预判数据范围--合理过滤条件">4. 预判数据范围 + 合理过滤条件</h3>
<blockquote>
<p>结合业务逻辑判断只需要查 <code>today</code> 到 <code>目标时间</code> 的数据，避免全表扫描。</p>
</blockquote>
<h2 id="实际执行效果对比">实际执行效果对比</h2>
<table>
<thead>
<tr>
<th>比较项</th>
<th>原始 SQL</th>
<th>优化后 SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询耗时</td>
<td>约 20 秒</td>
<td>&lt; 1 秒</td>
</tr>
<tr>
<td>可读性</td>
<td>嵌套复杂，字段混乱</td>
<td>简洁清晰，一目了然</td>
</tr>
<tr>
<td>可维护性</td>
<td>差，修改易出错</td>
<td>高，字段含义明确</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="技术反思sql-优化靠什么">技术反思：SQL 优化靠什么？</h2>
<h3 id="错误理解优化-sql-就是写法要帅函数要高级">错误理解：“优化 SQL 就是写法要帅，函数要高级”</h3>
<p>这种想法容易导致用 <code>row_number</code>、CTE、嵌套写法堆叠逻辑，<strong>表面花哨，实则低效</strong>。</p>
<h3 id="正确理解sql-优化-80-是理解数据20-是写法技巧">正确理解：<strong>SQL 优化 80% 是理解数据，20% 是写法技巧</strong></h3>
<table>
<thead>
<tr>
<th>能力</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>理解表关系</td>
<td>哪些字段是一对一？一对多？是外键？</td>
</tr>
<tr>
<td>理解字段语义</td>
<td>字段如 <code>status</code>, <code>finished_time</code>，分别代表什么状态？何时更新？</td>
</tr>
<tr>
<td>理解数据分布</td>
<td><code>status=0</code> 的比例？<code>b_code</code> 的稀疏度？</td>
</tr>
<tr>
<td>清楚业务目标</td>
<td>查询是统计量？查异常？查明细？</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="一些思考">一些思考</h2>
<h3 id="sql-优化怎么问怎么做">SQL 优化怎么问、怎么做？</h3>
<h4 id="面对陌生-sql-的优化流程">面对陌生 SQL 的优化流程：</h4>
<ol>
<li><strong>理解业务意图</strong>：这条 SQL 是做什么的？统计？监控？导出？</li>
<li><strong>理清字段含义</strong>：问清楚字段和表的关系，不怕问错，只怕想当然。</li>
<li><strong>观察数据量和索引</strong>：<code>EXPLAIN</code> + <code>SHOW INDEX</code> 是必须工具。</li>
<li><strong>写小查询试水</strong>：验证表连接关系和过滤逻辑，减少误解。</li>
<li><strong>一步步重构</strong>：每改一段先测一次，再合并。</li>
</ol>
<hr>
<h2 id="总结">总结</h2>
<blockquote>
<p>真正复杂的 SQL 往往不是难在语法，而是难在“它试图一口气表达太多复杂业务意图”。</p>
</blockquote>
<p>而优化 SQL 的关键，并不是你能写多炫技的语句，而是你是否能——</p>
<ul>
<li>看懂它背后真正想干什么；</li>
<li>拆解出最小单元；</li>
<li>找到正确字段连接路径；</li>
<li>用最朴素的方式表达业务意图。</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-12 11:14">2025-06-12 11:13</span>&nbsp;
<a href="https://www.cnblogs.com/DAYceng">dayceng</a>&nbsp;
阅读(<span id="post_view_count">473</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18925165);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18925165', targetLink: 'https://www.cnblogs.com/DAYceng/p/18925165', title: '一则复杂 SQL 改写后有感' })">举报</a>
</div>
        