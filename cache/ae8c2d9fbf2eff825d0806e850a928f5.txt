
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lyhabc/p/18693118/understanding-fill-factor-in-sql-server-and-postgresql" title="发布于 2025-07-18 08:00">
    <span role="heading" aria-level="2">揭开SQL Server和PostgreSQL填充因子的神秘面纱</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 style="text-align: center;">揭开SQL Server和PostgreSQL填充因子的神秘面纱</h1>
<p>&nbsp;</p>
<h3 data-tool="mdnice编辑器">理解SQL Server和PostgreSQL中的填充因子</h3>
<p data-tool="mdnice编辑器">在调优数据库性能时，一些小设置往往能带来显著的差异。填充因子就是其中一个经常讨论的设置。SQL Server和PostgreSQL都支持这一概念，但它们的处理方式有所不同。 如果你在管理这两种系统中的数据库，了解填充因子的工作原理可以帮助你避免因索引页拆分、索引碎片以及不必要的磁盘I/O带来的头疼问题。</p>
<h3 data-tool="mdnice编辑器">填充因子的概念</h3>
<p data-tool="mdnice编辑器">让我们先从一个比喻开始。假设你在整理书架。如果你把书架填得满满的，除非你拿出一些书或重新排列，否则就没有空间再放新书。这基本上就是数据库页面的工作方式。当数据库页面变满并且需要容纳更多数据时，它就必须拆分，这会消耗时间和资源。而填充因子就是一个设置，它允许你在每个页面上留出一些“空间”，就像在书架上留出空间以便以后放置新书一样。</p>
<img src="https://img2024.cnblogs.com/blog/257159/202501/257159-20250128130335717-1613406076.png" alt="" width="687" height="459">
<p id="1738040615413">&nbsp;</p>
<h3 data-tool="mdnice编辑器">SQL Server中的填充因子</h3>
<p data-tool="mdnice编辑器">在SQL Server中，填充因子是一个专门的索引设置。当你定义或重建索引时，可以设置填充因子来控制每个索引页面的填充程度。 例如，如果你将填充因子设置为90%，SQL Server会在每个索引页面上留出10%的空间，为将来的插入新数据或更新保留空间。 这可以减少页拆分发生的可能性，页拆分是一项成本较高的操作，可能会导致查询变慢。 默认情况下，SQL Server的填充因子设置为80%，意味着它会将每个索引页面填满。这对于读取密集型的工作负载效果很好，因为数据更改较少。但是，如果你的工作负载涉及频繁的更新或插入，较低的填充因子可以减少索引碎片。 假设有一个名为“Orders”的表，在“OrderDate”字段上有一个聚集索引。该表每天都会接收频繁的更新和插入新记录。 以下是如何设置自定义填充因子的示例：</p>
<pre class="highlighter-hljs" data-tool="mdnice编辑器"><code>-- 使用自定义填充因子重建索引
ALTER INDEX idx_OrderDate ON Orders &nbsp;REBUILD WITH (FILLFACTOR = 90);</code></pre>
<p data-tool="mdnice编辑器">在这个示例中，SQL Server在重建索引时会将每个索引页面留出10%的空间。这个额外的空间确保未来的插入或更新不太可能触发页拆分，从而提高整体性能。我们还可以使用以下命令设置服务器范围的默认填充因子：</p>
<pre class="highlighter-hljs" data-tool="mdnice编辑器"><code>-- 设置服务器范围的填充因子为90
EXEC sp_configure&nbsp;'fill factor', 90;
RECONFIGURE;</code></pre>
<h3 data-tool="mdnice编辑器">PostgreSQL中的填充因子</h3>
<p data-tool="mdnice编辑器">在PostgreSQL中，填充因子的作用范围更广，它既可以应用于表，也可以应用于索引。这是因为PostgreSQL的架构造成的，尤其是它使用的MVCC（多版本并发控制）架构。当PostgreSQL中的一行数据被更新时，系统会创建该行的一个新版本，而旧版本会保留在原页面，直到执行“清理”操作（vacuum）。如果同一页面上没有足够的空间存储新版本，PostgreSQL将不得不将其写到其他地方，这会导致表膨胀并增加“清理”过程中的额外开销。通过设置较低的填充因子，我们可以为更新留出更多空间，这样更新就能在同一页面上进行。 例如，填充因子为90意味着每个页面初始只使用90%的空间，留出10%的空间供未来更新使用。这减少了行数据移动的可能性，最小化了PostgreSQL在更新后进行“清理”时的开销。 假设有一个名为“customers”的表，频繁更新其中的“last_login”字段。以下是如何为这个表设置自定义填充因子的示例：</p>
<pre class="highlighter-hljs" data-tool="mdnice编辑器"><code>-- 创建具有自定义填充因子的表
CREATE TABLE customers (
&nbsp; &nbsp; customer_id SERIAL PRIMARY KEY,
&nbsp; &nbsp; name TEXT,
&nbsp; &nbsp; last_login TIMESTAMP
) WITH (fillfactor = 90);</code></pre>
<p data-tool="mdnice编辑器">此配置为每个页面保留了10%的空间，用于将来的更新，确保“last_login”字段的更新不会导致不必要的行数据移动。我们还可以调整现有表或索引的填充因子：</p>
<pre class="highlighter-hljs" data-tool="mdnice编辑器"><code>-- 修改现有表的填充因子，PostgreSQL才会有的选项
ALTER TABLE customers SET (fillfactor = 90);

-- 创建具有自定义填充因子的索引
CREATE INDEX idx_last_login ON customers (last_login) WITH (fillfactor = 90);</code></pre>
<h3 data-tool="mdnice编辑器">默认值和关键差异</h3>
<p data-tool="mdnice编辑器">有趣的是，PostgreSQL的默认填充因子是100%，这对于写操作密集型的工作负载来说似乎有些违反直觉。 这个默认值是一个折衷，平衡了存储效率和性能，以适应一般的使用场景。这两个数据库之间的关键差异在于它们的作用范围和目的。SQL Server的填充因子专注于索引，旨在减少特定场景中的索引碎片和索引页拆分。 另一方面，PostgreSQL将填充因子作为一个更广泛的工具，不仅用于索引，还用于处理与MVCC相关的表级别的挑战。 这使得PostgreSQL的填充因子在写操作密集型环境中尤为有价值，因为在这些环境中，更新和行版本管理非常频繁。</p>
<h3 data-tool="mdnice编辑器">实际考虑</h3>
<p data-tool="mdnice编辑器">如何在数据库中使用填充因子呢？答案取决于你的工作负载。 在SQL Server中，对于那些经常进行更新或插入操作的索引，较低的填充因子是必需的。 而在PostgreSQL中，你可能会考虑调整表和索引的填充因子，特别是对于那些经常需要大量写入的表，以减少膨胀并优化“清理”操作。</p>
<h3 data-tool="mdnice编辑器">总结</h3>
<p data-tool="mdnice编辑器">归根结底，填充因子是一个值得通过实验和观察来调整的设置。 通过了解它在每个系统中的工作原理，并在你的特定环境中进行测试，你可以在性能和存储效率之间找到合适的平衡。 毕竟，数据库就像书架，一些额外的空间可以带来很大的帮助。</p>
<p data-tool="mdnice编辑器">&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/257159/202409/257159-20240908204310924-1005667056.png" alt="" class="medium-zoom-image"></p>
<p><strong>本文版权归作者所有，未经作者同意不得转载。</strong></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-18 08:00">2025-07-18 08:00</span>&nbsp;
<a href="https://www.cnblogs.com/lyhabc">桦仔</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18693118);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18693118', targetLink: 'https://www.cnblogs.com/lyhabc/p/18693118/understanding-fill-factor-in-sql-server-and-postgresql', title: '揭开SQL Server和PostgreSQL填充因子的神秘面纱' })">举报</a>
</div>
        