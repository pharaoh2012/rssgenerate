
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wusixuan/p/18814901" title="发布于 2025-04-11 15:17">
    <span role="heading" aria-level="2">同余最短路</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><s>余同最短路</s>。</p>
<p>最短路我们学过，那同余最短路又是什么东西呢？？可以用来解决什么问题？？往下看。</p>
<p>我们从一道题来得到这个算法的思路。</p>
<h1 id="t494899-硬币问题">T494899 硬币问题</h1>
<h2 id="正宗的同余最短路">正宗的同余最短路</h2>
<p>有 <span class="math inline">\(n\)</span> 种面值的硬币（每种有无限枚），问使用这些硬币能够凑出 <span class="math inline">\([1,m]\)</span> 的多少种金额。<span class="math inline">\(n \le 100,m \le 10^{12},w_i \le 10^6\)</span>。</p>
<p>显然这个东西可以使用完全背包做。这样是 <span class="math inline">\(O(nm)\)</span> 的，可是缺点太大。</p>
<p>于是，一个很神奇的解决方法就出现了：同余最短路。</p>
<hr>
<p>我们观察一个性质：如果对于某一个 <span class="math inline">\(w_i\)</span>，如果 <span class="math inline">\(x\)</span> 是可以通过若干面额凑出来的，则 <span class="math inline">\(x+w_i\)</span> 也一定可以凑出来。</p>
<p>所以对于 <span class="math inline">\(x \bmod w_i = d\)</span> 的情况，如果能够找到<strong>可以凑出来的</strong> <span class="math inline">\(x\)</span> 的最小值，则就可以通过数学方式计算出 <span class="math inline">\([1,m]\)</span> 中的所有 <span class="math inline">\(\bmod w_i = d\)</span> 的合法方案数。</p>
<p>具体地，根据左边界可以得出 <span class="math inline">\(x + k \times w_i \ge 1\)</span>，根据右边界可以得出 <span class="math inline">\(x + k \times w_i \le m\)</span>，其中 <span class="math inline">\(k\)</span> 是一个<strong>自然数</strong>。</p>
<p>解不等式就可以得出 <span class="math inline">\(k\)</span> 的区间，也可以 <span class="math inline">\(O(1)\)</span> 计算出 <span class="math inline">\(\bmod w_i = d\)</span> 的所有合法方案数。</p>
<hr>
<p>于是这里的问题就变成了如何找到每种余数下的最小的 <span class="math inline">\(x\)</span>。这个时候就需要请出我们的同余最短路了。</p>
<p>考虑到直接对于每一个 <span class="math inline">\(w_i\)</span> 算 <span class="math inline">\(\bmod w_i = d\)</span> 的合法方案数会算重，很麻烦。</p>
<p>不妨直接使用最小的 <span class="math inline">\(w_a\)</span>。</p>
<p>可以证明，使用 <span class="math inline">\(\bmod w_a = d (0 \le d &lt; w_a)\)</span> 的一定是全体的答案。很容易证明，也很容易理解。</p>
<hr>
<p>考虑从举例来理解这个算法的过程。<span class="math inline">\(n=3,m=1000,w=\{3,7,8\}\)</span>。</p>
<p>最短路一定是需要建图的。为了便于理解，所以这个时候就建 <span class="math inline">\(8\)</span> 个点 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(7\)</span>，表示对 <span class="math inline">\(8\)</span> 的余数。</p>
<p><strong>你应该可以猜到最短路就是什么了，没错就是对于 <span class="math inline">\(8\)</span> 的余数 <span class="math inline">\(0 \le d \le 7\)</span> 的可以凑出来的最小 <span class="math inline">\(x\)</span>。</strong></p>
<p>显然 <span class="math inline">\(0\)</span> 的最短路就是 <span class="math inline">\(0\)</span>。</p>
<p>虽然这样是不符合条件的因为 $0 &lt;1 $，但是为了正确地跑出最短路也只能这样做。为了补救一下，算完最后把答案 <span class="math inline">\(-1\)</span> 即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411085709389-1699598957.png" alt="" loading="lazy"></p>
<p>显然对于 <span class="math inline">\(0\)</span> 这个点，有三种选择：加上 <span class="math inline">\(3\)</span>、加上 <span class="math inline">\(7\)</span> 或者加上 <span class="math inline">\(8\)</span>。</p>
<p>因为 <span class="math inline">\(d \equiv d+8 \ (\bmod 8)\)</span>，所以不考虑加上 <span class="math inline">\(8\)</span>（这样就会形成自环，反而不好处理）。</p>
<p>而 <span class="math inline">\(0 + 7 \equiv 7 \ (\bmod 8)\)</span>，因此存在 <span class="math inline">\(0 \to 7\)</span> 的边权为 <span class="math inline">\(7\)</span>。<span class="math inline">\(0 \to 3\)</span> 的边权为 <span class="math inline">\(3\)</span> 同理。</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411090845267-656797481.png" alt="" loading="lazy"></p>
<p>因为这个例子只有两种边，所以这里设边权为 <span class="math inline">\(7\)</span> 的边为蓝边，边权为 <span class="math inline">\(3\)</span> 的边为红边。</p>
<p>把边权为 <span class="math inline">\(3\)</span> 的边连完，就可以得到：</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411090926885-921321669.png" alt="" loading="lazy"></p>
<p>把边权为 <span class="math inline">\(7\)</span> 的边连完，就可以得到：</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411091050255-1079697491.png" alt="" loading="lazy"></p>
<hr>
<p>至此所有的边都连完了，于是就可以幸福愉快地跑最短路了。果断选择 dijkstra，因为 <span class="math inline">\(w_i\)</span> 都是正的所以 dijkstra 一定是正确的。</p>
<p>如果有 <span class="math inline">\(w_i\)</span> 是负数，就只能另想办法了。</p>
<p>dijkstra 的过程这里不再阐述，最后跑出来就是这个结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411091339330-1747326227.png" alt="" loading="lazy"></p>
<p>目测可以发现，除去 <span class="math inline">\(0\)</span> 以外，其他所有点得出来的结果都是正确的！</p>
<p>总结一下，算出来所有余数的最小能够凑出来的面值的过程为：</p>
<ul>
<li>
<p>先建出 <span class="math inline">\([0,w_a -1]\)</span> 的所有点。</p>
</li>
<li>
<p>对于每一个点 <span class="math inline">\(x\)</span>，对于 <span class="math inline">\(1 \le i \le n\)</span>，连边 <span class="math inline">\(x \to (x + w_i) \bmod w_a\)</span>。</p>
</li>
<li>
<p>设 <span class="math inline">\(dis_0\)</span> 为 <span class="math inline">\(0\)</span>。以 <span class="math inline">\(0\)</span> 为源点跑 dijkstra，最终的 <span class="math inline">\(dis\)</span> 值就是每一个余数的最小面值（<span class="math inline">\(0\)</span> 除外，<span class="math inline">\(dis_0\)</span> 理应当是 <span class="math inline">\(w_a\)</span>），采用数学方式就可以算出来最终的结果。</p>
</li>
</ul>
<hr>
<p>于是就做完了。这里的东西只和 <span class="math inline">\(w_i\)</span> 和 <span class="math inline">\(n\)</span> 有关，而 <span class="math inline">\(w_i\)</span> 的范围是不大的，和 <span class="math inline">\(m\)</span> 没有半毛钱关系。</p>
<p>建出来的图有 <span class="math inline">\(w_a \approx 10^6\)</span> 个点，一共有 <span class="math inline">\(O(w_a \times n) \approx O(10^8)\)</span> 条边。</p>
<p>如果存图还是太占用空间了，<strong>于是考虑直接无实物建图</strong>，因为每一条边的起点和终点都是很有规律的。复杂度应该是 <span class="math inline">\(O(n \log n + m)\)</span> 的，可以跑过去，但还是有一些慢，毕竟 <span class="math inline">\(m \approx 10^8\)</span> 嘛。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 1000010
int n, w[N];
int dis[N], m;
bool vis[N];

void Dijkstra(int start) {
	priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;
	for (int i = 0; i &lt; w[1]; ++i)
		dis[i] = 1e17, vis[i] = 0;
	dis[start] = 0;
	q.push({0, start});
	while (q.empty() == 0) {
		auto [tmp, u] = q.top();
		q.pop();
		if (vis[u] == 1)
			continue;
		else
			vis[u] = 1;
		for (int i = 2; i &lt;= n; ++i) {
			int v = (u + w[i]) % w[1];
			if (vis[v] == 0 &amp;&amp; dis[v] &gt; dis[u] + w[i]) {
				dis[v] = dis[u] + w[i];
				q.push({dis[v], v});
			}
		}
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
		cin &gt;&gt; w[i];
	sort(w + 1, w + n + 1);
	Dijkstra(0);
	int ans = 0;
	for (int i = 0; i &lt; w[1]; ++i)//为了节省时间，所以采用最小的 w_1
		if (dis[i] &lt; 1e17 &amp;&amp; dis[i] &lt;= m)
			ans += (m - dis[i]) / w[1] + 1;
	cout &lt;&lt; ans - 1 &lt;&lt; endl;
	return 0;
}
</code></pre>
<p><strong>注意，这种方法只是解决同余最短路问题的解法中的一种。还有另一种方法，比想象中的要简单。</strong></p>
<h2 id="转圈背包">转圈背包</h2>
<p>转圈背包还是一种背包，容易想到，可能是完全背包的优化版本。</p>
<p>于是试图使用完全背包来计算 <span class="math inline">\(dis_i\)</span>。</p>
<p>于是我们思考，在同余 <span class="math inline">\(w\)</span> 的情况下，另外一个物品 <span class="math inline">\(w_a\)</span> 最多用几次（假设所有 <span class="math inline">\(w_a\)</span> 已经对 <span class="math inline">\(w\)</span> 取模）。根据数学，显然是 <span class="math inline">\(w / \gcd(w,w_a) - 1\)</span>（<span class="math inline">\(w / \gcd{w,w_a}\)</span> 是环的长度，这是一个经典的数学结论）。</p>
<p>于是这就从一个完全背包换成了一个多重背包。</p>
<hr>
<p>当我们画出来状态转移的有向图的时候：</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411144812967-1329563837.png" alt="" loading="lazy"></p>
<p>于是就可以类似转圈地进行 dp 了。</p>
<p>但是我们发现，这东西你会超过限制吧？对于单个物品，就一共需要转移 <span class="math inline">\(w \times \frac{w}{\gcd(w,w_a)}\)</span> 次。</p>
<p>整合起来，最多就需要跑 <span class="math inline">\(n \times w^2\)</span> 的量级，显然是不可以接受的。</p>
<hr>
<p><strong>于是！就需要请出我们重量级的转圈背包了。</strong></p>
<p>考虑假设一个例子，假设 <span class="math inline">\(w = 8\)</span>，而 <span class="math inline">\(w_a = 2\)</span>。</p>
<p>则很容易提取到其中的一个 <span class="math inline">\(4\)</span> 元环：<img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411145622762-525990636.png" alt="" loading="lazy"></p>
<p>我们发现每一条边都被走了 <span class="math inline">\(3\)</span> 次，而共有 <span class="math inline">\(4\)</span> 条边，也就是一共转移了 <span class="math inline">\(3 \times 4 = 12\)</span> 次。这也是它慢的原因。</p>
<p><strong>接下来，我们需要做一个模型的转化，这个转化超级简单。</strong></p>
<p>我们将其转化为：从 <span class="math inline">\(0\)</span> 开始，先转移一遍。然后（不同的点）再绕整个环一遍进行转移。</p>
<p><img src="https://img2024.cnblogs.com/blog/3576981/202504/3576981-20250411145903750-1115857323.png" alt="" loading="lazy"></p>
<p>因为转移 <span class="math inline">\(4\)</span> 次和转移 <span class="math inline">\(0\)</span> 次的效果一模一样，所以这样是正确的。</p>
<p><strong>所以，更上面的图片的转移次数为 <span class="math inline">\(w \times (\frac{w}{\gcd(w,w_a)}-1)\)</span>，但是下面的这张图片转移次数大约为 <span class="math inline">\(2w\)</span>。</strong></p>
<p>所以拼起来就是 <span class="math inline">\(O(n \times \min\{w_i\})\)</span> 的。勉强能够过去这道题。</p>
<p>代码还是很好写的。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std; 
#define int long long
#define N 1001000
int t,n,m,w[N],dp[N];
int cal(int dis,int x) {return (dis &lt;= x) ? (x - dis) / w[1] + 1 : 0;}//计算
int circle(int l,int r)
{
    sort(w + 1,w + n + 1);//物品一定要从小到大考虑
    memset(dp,0x3f,sizeof(dp));
    dp[0] = 0;//dp[i] 表示模 w[1] 为 i 的情况下，最小能够凑出来的金额

    for(int i = 2;i &lt;= n;++i)//依次考虑物品 w[2] to w[n]
        for(int st = 0,up = __gcd(w[i],w[1]) - 1;st &lt;= up;++st)//刚好 0 ~ __gcd(w[i],w[1]) - 1 能够作为每一个环的起点
//枚举每一个环的起点
            for(int u = st,c = 0;c &lt; 2;c += (u == st)) {//c 表示走过了起点多少次，用来统计转圈的圈数
                int v = (u + w[i]) % w[1];//计算要转移的位置
                dp[v] = min(dp[v],dp[u] + w[i]);//转移
                u = v;
            }
        
    int ans = 0;
    for(int i = 0;i &lt; w[1];i++) ans += cal(dp[i],r) - cal(dp[i],l - 1);//计算得到答案
//cal(x,y) 表示从 1 到 y 有多少个数对 w[1] 取模和 x 同于
    return ans;
}
signed main()
{
    ios::sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1;i &lt;= n;++i) cin &gt;&gt; w[i];
    cout &lt;&lt; circle(1, m) &lt;&lt; endl;

    return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6237288295902778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-11 15:17">2025-04-11 15:17</span>&nbsp;
<a href="https://www.cnblogs.com/wusixuan">wusixuan</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18814901" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18814901);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18814901', targetLink: 'https://www.cnblogs.com/wusixuan/p/18814901', title: '同余最短路' })">举报</a>
</div>
        