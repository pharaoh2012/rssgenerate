
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mengps/p/18673575" title="发布于 2025-01-15 18:13">
    <span role="heading" aria-level="2">Qml 中实现任意角为圆角的矩形</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/802097/202501/802097-20250115181231002-90789923.png" alt="Qml 中实现任意角为圆角的矩形" class="desc_img">
        在 Qml 中，矩形（Rectangle）是最常用的元素之一。
然而，标准的矩形元素仅允许设置统一的圆角半径。
在实际开发中，我们经常需要更灵活的圆角设置，例如只对某些角进行圆角处理，或者设置不同角的圆角半径。
本文将介绍如何通过自定义 Qml 元素实现一个任意角可为圆角的矩形。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="写在前面">【写在前面】</h3>
<p>在 Qml 中，矩形（Rectangle）是最常用的元素之一。</p>
<p>然而，标准的矩形元素仅允许设置统一的圆角半径。</p>
<p>在实际开发中，我们经常需要更灵活的圆角设置，例如只对某些角进行圆角处理，或者设置不同角的圆角半径。</p>
<p>本文将介绍如何通过自定义 Qml 元素实现一个任意角可为圆角的矩形。</p>
<hr>
<h3 id="正文开始">【正文开始】</h3>
<h4 id="效果图">效果图</h4>
<p><img src="https://img2024.cnblogs.com/blog/802097/202501/802097-20250115181056921-289165805.gif" alt="" loading="lazy"></p>
<h4 id="自定义-qml-元素delrectangle">自定义 Qml 元素：DelRectangle</h4>
<p>我们将创建一个名为 <code>DelRectangle</code> 的自定义 Qml 元素，它继承自 <code>QQuickPaintedItem</code>，并重写其 <code>paint()</code> 方法来自定义绘制逻辑。</p>
<h4 id="头文件delrectangleh">头文件（delrectangle.h）</h4>
<pre><code class="language-cpp">#ifndef DELRECTANGLE_H
#define DELRECTANGLE_H

#include &lt;QQuickPaintedItem&gt;

class DelPen: public QObject
{
    Q_OBJECT
    Q_PROPERTY(qreal width READ width WRITE setWidth NOTIFY widthChanged FINAL)
    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged FINAL)
    QML_NAMED_ELEMENT(DelPen)
public:
    DelPen(QObject *parent = nullptr);
    qreal width() const;
    void setWidth(qreal width);
    QColor color() const;
    void setColor(const QColor &amp;color);
    bool isValid() const;
signals:
    void widthChanged();
    void colorChanged();
private:
    qreal m_width = 1;
    QColor m_color = Qt::transparent;
};

class DelRectangle: public QQuickPaintedItem
{
    Q_OBJECT
    Q_PROPERTY(qreal radius READ radius WRITE setRadius NOTIFY radiusChanged FINAL)
    Q_PROPERTY(qreal topLeftRadius READ topLeftRadius WRITE setTopLeftRadius NOTIFY topLeftRadiusChanged FINAL)
    Q_PROPERTY(qreal topRightRadius READ topRightRadius WRITE setTopRightRadius NOTIFY topRightRadiusChanged FINAL)
    Q_PROPERTY(qreal bottomLeftRadius READ bottomLeftRadius WRITE setBottomLeftRadius NOTIFY bottomLeftRadiusChanged FINAL)
    Q_PROPERTY(qreal bottomRightRadius READ bottomRightRadius WRITE setBottomRightRadius NOTIFY bottomRightRadiusChanged FINAL)
    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged FINAL)
    Q_PROPERTY(DelPen* border READ border CONSTANT)
    QML_NAMED_ELEMENT(DelRectangle)
public:
    explicit DelRectangle(QQuickItem *parent = nullptr);
    ~DelRectangle();
    qreal radius() const;
    void setRadius(qreal radius);
    qreal topLeftRadius() const;
    void setTopLeftRadius(qreal radius);
    qreal topRightRadius() const;
    void setTopRightRadius(qreal radius);
    qreal bottomLeftRadius() const;
    void setBottomLeftRadius(qreal radius);
    qreal bottomRightRadius() const;
    void setBottomRightRadius(qreal radius);
    QColor color() const;
    void setColor(QColor color);
    DelPen *border();
    void paint(QPainter *painter) override;
signals:
    void radiusChanged();
    void topLeftRadiusChanged();
    void topRightRadiusChanged();
    void bottomLeftRadiusChanged();
    void bottomRightRadiusChanged();
    void colorChanged();
private:
    Q_DECLARE_PRIVATE(DelRectangle);
    QSharedPointer&lt;DelRectanglePrivate&gt; d_ptr;
};

#endif // DELRECTANGLE_H
</code></pre>
<h4 id="实现文件delrectanglecpp">实现文件（delrectangle.cpp）</h4>
<pre><code class="language-cpp">#include "delrectangle.h"

#include &lt;QPainter&gt;
#include &lt;QPainterPath&gt;
#include &lt;private/qqmlglobal_p.h&gt;

class DelRectanglePrivate
{
public:
    QColor m_color = { 0xffffff };
    DelPen *m_pen = nullptr;
    qreal m_radius = 0;
    qreal m_topLeftRadius = 0;
    qreal m_topRightRadius = 0;
    qreal m_bottomLeftRadius = 0;
    qreal m_bottomRightRadius = 0;
};

DelRectangle::DelRectangle(QQuickItem *parent)
    : QQuickPaintedItem{parent}
    , d_ptr(new DelRectanglePrivate)
{
}

DelRectangle::~DelRectangle()
{
}

qreal DelRectangle::radius() const
{
    Q_D(const DelRectangle);
    return d-&gt;m_radius;
}

void DelRectangle::setRadius(qreal radius)
{
    Q_D(DelRectangle);
    if (d-&gt;m_radius != radius) {
        d-&gt;m_radius = radius;
        d-&gt;m_topLeftRadius = radius;
        d-&gt;m_topRightRadius = radius;
        d-&gt;m_bottomLeftRadius = radius;
        d-&gt;m_bottomRightRadius = radius;
        emit radiusChanged();
        update();
    }
}

// 其他 getter 和 setter 方法省略...

QColor DelRectangle::color() const
{
    Q_D(const DelRectangle);
    return d-&gt;m_color;
}

void DelRectangle::setColor(QColor color)
{
    Q_D(DelRectangle);
    if (d-&gt;m_color != color) {
        d-&gt;m_color = color;
        emit colorChanged();
        update();
    }
}

DelPen *DelRectangle::border()
{
    Q_D(DelRectangle);
    if (!d-&gt;m_pen) {
        d-&gt;m_pen = new DelPen;
        QQml_setParent_noEvent(d-&gt;m_pen, this);
        connect(d-&gt;m_pen, &amp;DelPen::colorChanged, this, [this]{ update(); });
        connect(d-&gt;m_pen, &amp;DelPen::widthChanged, this, [this]{ update(); });
        update();
    }
    return d-&gt;m_pen;
}

void DelRectangle::paint(QPainter *painter)
{
    Q_D(DelRectangle);
    painter-&gt;save();
    painter-&gt;setRenderHint(QPainter::Antialiasing);
    QRectF rect = boundingRect();
    if (d-&gt;m_pen &amp;&amp; d-&gt;m_pen-&gt;isValid()) {
        rect = boundingRect();
        if (rect.width() &gt; d-&gt;m_pen-&gt;width() * 2) {
            auto dx = d-&gt;m_pen-&gt;width() * 0.5;
            rect.adjust(dx, 0, -dx, 0);
        }
        if (rect.height() &gt; d-&gt;m_pen-&gt;width() * 2) {
            auto dy = d-&gt;m_pen-&gt;width() * 0.5;
            rect.adjust(0, dy, 0, -dy);
        }
        painter-&gt;setPen(QPen(d-&gt;m_pen-&gt;color(), d-&gt;m_pen-&gt;width(), Qt::SolidLine, Qt::SquareCap, Qt::SvgMiterJoin));
    }
    QPainterPath path;
    path.moveTo(rect.bottomRight() - QPointF(0, d-&gt;m_bottomRightRadius));
    path.lineTo(rect.topRight() + QPointF(0, d-&gt;m_topRightRadius));
    path.arcTo(QRectF(QPointF(rect.topRight() - QPointF(d-&gt;m_topRightRadius * 2, 0)), QSize(d-&gt;m_topRightRadius * 2, d-&gt;m_topRightRadius * 2)), 0, 90);
    path.lineTo(rect.topLeft() + QPointF(d-&gt;m_topLeftRadius, 0));
    path.arcTo(QRectF(QPointF(rect.topLeft()), QSize(d-&gt;m_topLeftRadius * 2, d-&gt;m_topLeftRadius * 2)), 90, 90);
    path.lineTo(rect.bottomLeft() - QPointF(0, d-&gt;m_bottomLeftRadius));
    path.arcTo(QRectF(QPointF(rect.bottomLeft().x(), rect.bottomLeft().y() - d-&gt;m_bottomLeftRadius * 2), QSize(d-&gt;m_bottomLeftRadius * 2, d-&gt;m_bottomLeftRadius * 2)), 180, 90);
    path.lineTo(rect.bottomRight() - QPointF(d-&gt;m_bottomRightRadius, 0));
    path.arcTo(QRectF(QPointF(rect.bottomRight() - QPointF(d-&gt;m_bottomRightRadius * 2, d-&gt;m_bottomRightRadius * 2)), QSize(d-&gt;m_bottomRightRadius * 2, d-&gt;m_bottomRightRadius * 2)), 270, 90);
    painter-&gt;setBrush(d-&gt;m_color);
    painter-&gt;drawPath(path);
    painter-&gt;restore();
}
</code></pre>
<h4 id="关键点解析">关键点解析</h4>
<ol>
<li>
<p><strong>自定义 Qml 元素</strong>：通过继承 <code>QQuickPaintedItem</code> 并使用 <code>QML_NAMED_ELEMENT</code> 宏，我们可以将自定义的 C++ 类注册为 Qml 元素。</p>
</li>
<li>
<p><strong>属性定义</strong>：我们定义了多个属性来控制矩形的圆角半径和颜色，例如 <code>radius</code>、<code>topLeftRadius</code>、<code>color</code> 等，并提供了相应的 getter 和 setter 方法。</p>
</li>
<li>
<p><strong>边框管理</strong>：通过 <code>DelPen</code> 类来管理矩形的边框样式，包括边框颜色和宽度。</p>
</li>
<li>
<p><strong>绘制逻辑</strong>：在 <code>paint()</code> 方法中，我们使用 <code>QPainterPath</code> 来绘制具有不同圆角的矩形。通过组合使用直线和弧线，我们可以实现任意角的圆角效果。</p>
</li>
</ol>
<h4 id="使用示例">使用示例</h4>
<p>在 Qml 文件中，我们可以像使用标准的 <code>Rectangle</code> 元素一样使用 <code>DelRectangle</code>：</p>
<pre><code class="language-qml">import QtQuick 2.15
import QtQuick.Window 2.15
import DelegateUI.Controls 1.0

Window {
    visible: true
    width: 400
    height: 300
    title: "DelRectangle Example"

    DelRectangle {
        anchors.centerIn: parent
        width: 200
        height: 150
        color: "lightblue"
        topLeftRadius: 20
        bottomRightRadius: 30
        border {
            width: 2
            color: "blue"
        }
    }
}
</code></pre>
<hr>
<h3 id="总结">总结</h3>
<p>通过自定义 Qml 元素 <code>DelRectangle</code>，我们实现了对矩形圆角的更灵活控制，使其能够满足更多实际开发需求。</p>
<p>要注意的是，在 Qt 6.7 版本以后，内置的 <code>Rectangle</code> 将提供同等功能( 作为技术预览 )，并且效果更好：</p>
<p><img src="https://img2024.cnblogs.com/blog/802097/202501/802097-20250115181123834-1449985603.png" alt="" loading="lazy"></p>
<p>最后：项目链接(多多star呀..⭐_⭐)：</p>
<p>Github: <a href="https://github.com/mengps/QmlControls" target="_blank" rel="noopener nofollow">https://github.com/mengps/QmlControls</a></p>
<p>Gitee: <a href="https://gitee.com/MenPenS/QmlControls" target="_blank" rel="noopener nofollow">https://gitee.com/MenPenS/QmlControls</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0018618401712962964" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-15 18:13">2025-01-15 18:13</span>&nbsp;
<a href="https://www.cnblogs.com/mengps">梦起丶</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18673575" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18673575);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18673575', targetLink: 'https://www.cnblogs.com/mengps/p/18673575', title: 'Qml 中实现任意角为圆角的矩形' })">举报</a>
</div>
        