
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18846985" title="发布于 2025-04-25 16:45">
    <span role="heading" aria-level="2">Netty 心跳机制实现（客户端与服务端）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="netty-心跳机制实现客户端与服务端">Netty 心跳机制实现（客户端与服务端）</h1>
<p>Netty 的心跳机制是保持长连接有效性的重要手段，可以检测连接是否存活并及时释放无效连接。下面介绍客户端和服务端的完整实现方案。</p>
<h2 id="一服务端实现">一、服务端实现</h2>
<h3 id="1-基础心跳检测">1. 基础心跳检测</h3>
<pre><code class="language-java">public class HeartbeatServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {
    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        
        // 添加编解码器
        pipeline.addLast(new StringDecoder());
        pipeline.addLast(new StringEncoder());
        
        // 心跳检测
        // 参数说明：readerIdleTime, writerIdleTime, allIdleTime, 时间单位
        pipeline.addLast(new IdleStateHandler(5, 0, 0, TimeUnit.SECONDS));
        pipeline.addLast(new HeartbeatServerHandler());
    }
}

public class HeartbeatServerHandler extends ChannelInboundHandlerAdapter {
    // 心跳丢失计数器
    private Map&lt;String, Integer&gt; lossConnectMap = new HashMap&lt;&gt;();
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            if (event.state() == IdleState.READER_IDLE) {
                String socketAddress = ctx.channel().remoteAddress().toString();
                int lossConnectCount = 0;
                if (lossConnectMap.containsKey(socketAddress)) {
                    lossConnectCount = lossConnectMap.get(socketAddress);
                }
                lossConnectCount++;
                lossConnectMap.put(socketAddress, lossConnectCount);
                logger.info("关闭不活跃: " + ctx.channel().remoteAddress() + " " + lossConnectCount);
                if (lossConnectCount &gt; 2) {
                    logger.info("关闭不活跃连接: " + ctx.channel());
                    ctx.channel().close();
                }
            }
        } else {
            super.userEventTriggered(ctx, evt);
        }
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // 收到任何消息都重置计数器
        if ("HEARTBEAT".equals(msg)) {
            if (lossConnectMap.containsKey(socketAddress)) {
                lossConnectMap.put(socketAddress, 0);
            }
            System.out.println("收到心跳: " + ctx.channel());
            ctx.writeAndFlush("HEARTBEAT_RESPONSE");
        } else {
            // 处理其他业务消息
        }
    }
}
</code></pre>
<h3 id="2-完整心跳交互方案">2. 完整心跳交互方案</h3>
<pre><code class="language-java">public class AdvancedHeartbeatServerHandler extends ChannelInboundHandlerAdapter {
    private static final ByteBuf HEARTBEAT_SEQUENCE = 
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("HEARTBEAT", CharsetUtil.UTF_8));
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleState state = ((IdleStateEvent) evt).state();
            if (state == IdleState.READER_IDLE) {
                // 读空闲(没有收到客户端消息)
                System.out.println("读空闲，关闭连接: " + ctx.channel());
                ctx.close();
            } else if (state == IdleState.WRITER_IDLE) {
                // 写空闲(可以主动发送心跳包)
                System.out.println("写空闲，发送心跳包");
                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())
                   .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            }
        } else {
            super.userEventTriggered(ctx, evt);
        }
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String message = (String) msg;
        if ("HEARTBEAT_REQUEST".equals(message)) {
            // 响应客户端心跳
            ctx.writeAndFlush("HEARTBEAT_RESPONSE");
        } else {
            // 处理业务消息
        }
    }
}
</code></pre>
<h2 id="二客户端实现">二、客户端实现</h2>
<h3 id="1-基础心跳实现">1. 基础心跳实现</h3>
<pre><code class="language-java">public class HeartbeatClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; {
    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        
        pipeline.addLast(new StringDecoder());
        pipeline.addLast(new StringEncoder());
        
        // 客户端设置写空闲检测（定期发送心跳）
        pipeline.addLast(new IdleStateHandler(0, 4, 0, TimeUnit.SECONDS));
        pipeline.addLast(new HeartbeatClientHandler());
    }
}

public class HeartbeatClientHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            if (event.state() == IdleState.WRITER_IDLE) {
                // 写空闲时发送心跳
                ctx.writeAndFlush("HEARTBEAT");
                System.out.println("客户端发送心跳");
            }
        }
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if ("HEARTBEAT_RESPONSE".equals(msg)) {
            System.out.println("收到服务端心跳响应");
        }
    }
}
</code></pre>
<h3 id="2-完整心跳交互方案-1">2. 完整心跳交互方案</h3>
<pre><code class="language-java">public class AdvancedHeartbeatClientHandler extends ChannelInboundHandlerAdapter {
    private static final ByteBuf HEARTBEAT_SEQUENCE = 
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("HEARTBEAT_REQUEST", CharsetUtil.UTF_8));
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        // 连接建立后立即发送一次心跳
        sendHeartbeat(ctx);
        super.channelActive(ctx);
    }
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleState state = ((IdleStateEvent) evt).state();
            if (state == IdleState.WRITER_IDLE) {
                // 写空闲时发送心跳
                sendHeartbeat(ctx);
            } else if (state == IdleState.READER_IDLE) {
                // 读空闲(未收到服务端响应)
                System.out.println("服务端无响应，关闭连接");
                ctx.close();
            }
        } else {
            super.userEventTriggered(ctx, evt);
        }
    }
    
    private void sendHeartbeat(ChannelHandlerContext ctx) {
        ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())
           .addListener(future -&gt; {
               if (!future.isSuccess()) {
                   System.err.println("心跳发送失败: " + future.cause());
               }
           });
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String message = (String) msg;
        if ("HEARTBEAT".equals(message)) {
            // 响应服务端心跳
            ctx.writeAndFlush("HEARTBEAT_RESPONSE");
        } else if ("HEARTBEAT_RESPONSE".equals(message)) {
            // 收到服务端对客户端心跳的响应
            System.out.println("心跳正常");
        }
    }
}
</code></pre>
<h2 id="三websocket-心跳实现">三、WebSocket 心跳实现</h2>
<p>对于 WebSocket 连接，心跳机制需要特殊处理：</p>
<h3 id="服务端实现">服务端实现</h3>
<pre><code class="language-java">public class WebSocketHeartbeatServerHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
        String text = msg.text();
        if ("HEARTBEAT".equals(text)) {
            ctx.writeAndFlush(new TextWebSocketFrame("HEARTBEAT_RESPONSE"));
        } else {
            // 处理其他WebSocket消息
        }
    }
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent idleEvent = (IdleStateEvent) evt;
            if (idleEvent.state() == IdleState.READER_IDLE) {
                ctx.close();
            } else if (idleEvent.state() == IdleState.WRITER_IDLE) {
                ctx.writeAndFlush(new TextWebSocketFrame("HEARTBEAT"));
            }
        }
    }
}
</code></pre>
<h3 id="客户端实现">客户端实现</h3>
<pre><code class="language-java">public class WebSocketHeartbeatClientHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
        String text = msg.text();
        if ("HEARTBEAT".equals(text)) {
            ctx.writeAndFlush(new TextWebSocketFrame("HEARTBEAT_RESPONSE"));
        }
    }
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            if (event.state() == IdleState.WRITER_IDLE) {
                ctx.writeAndFlush(new TextWebSocketFrame("HEARTBEAT"));
            }
        }
    }
}
</code></pre>
<h2 id="四最佳实践建议">四、最佳实践建议</h2>
<ol>
<li>
<p><strong>合理设置超时时间</strong>：</p>
<ul>
<li>生产环境建议读空闲时间设置为60-120秒</li>
<li>写空闲时间设置为30-60秒</li>
</ul>
</li>
<li>
<p><strong>心跳协议设计</strong>：</p>
<ul>
<li>使用固定格式的心跳消息（如"HEARTBEAT"）</li>
<li>可以考虑携带时间戳或序列号用于调试</li>
</ul>
</li>
<li>
<p><strong>重连机制</strong>：</p>
<pre><code class="language-java">// 客户端重连示例
public class ReconnectHandler extends ChannelInboundHandlerAdapter {
    private final Bootstrap bootstrap;
    private int retries = 0;
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        if (retries &lt; 3) {
            long delay = 1L &lt;&lt; retries;
            retries++;
            ctx.channel().eventLoop().schedule(() -&gt; {
                System.out.println("尝试重连..." + retries);
                bootstrap.connect();
            }, delay, TimeUnit.SECONDS);
        }
        ctx.fireChannelInactive();
    }
}
</code></pre>
</li>
<li>
<p><strong>监控与日志</strong>：</p>
<ul>
<li>记录心跳异常情况</li>
<li>监控连接存活率</li>
</ul>
</li>
<li>
<p><strong>性能考虑</strong>：</p>
<ul>
<li>使用共享的ByteBuf作为心跳消息</li>
<li>避免在心跳处理器中执行耗时操作</li>
</ul>
</li>
</ol>
<p>通过以上实现，可以构建健壮的Netty心跳机制，有效维护长连接的可靠性。</p>
<h1 id="netty-心跳机制中写空闲检测的考量">Netty 心跳机制中写空闲检测的考量</h1>
<p>在 Netty 心跳机制中，写空闲（WRITER_IDLE）检测和读空闲（READER_IDLE）检测各有不同的应用场景和考量因素。是否需要同时使用两者取决于具体业务需求。</p>
<h2 id="一写空闲检测的主要考虑场景">一、写空闲检测的主要考虑场景</h2>
<ol>
<li>
<p><strong>客户端主动保活</strong>（最常见场景）</p>
<ul>
<li>当客户端需要维持与服务端的连接时（如移动设备通过NAT网关连接）</li>
<li>防止中间设备（路由器、防火墙等）因长时间无数据流动而断开连接</li>
<li>典型实现：客户端定期发送心跳包</li>
</ul>
</li>
<li>
<p><strong>服务端主动检测</strong>（特殊场景）</p>
<ul>
<li>当服务端需要确认客户端是否存活但客户端无法主动发送心跳时</li>
<li>双向心跳检测机制中</li>
<li>需要服务端主动推送数据的场景（如实时监控系统）</li>
</ul>
</li>
<li>
<p><strong>对称性心跳设计</strong></p>
<ul>
<li>在金融、支付等对可靠性要求高的系统中</li>
<li>双方向都保持活跃检测，提高连接可靠性</li>
</ul>
</li>
</ol>
<h2 id="二是否只需要读空闲检测">二、是否只需要读空闲检测？</h2>
<h3 id="可以仅使用读空闲检测的场景">可以仅使用读空闲检测的场景：</h3>
<ol>
<li>
<p><strong>纯服务端检测模式</strong></p>
<ul>
<li>客户端会定期发送数据（包括业务数据和心跳）</li>
<li>服务端只需要检测是否在指定时间内收到任何数据</li>
</ul>
</li>
<li>
<p><strong>客户端可靠主动发送心跳</strong></p>
<ul>
<li>客户端能保证按时发送心跳包</li>
<li>网络环境稳定（如内网通信）</li>
</ul>
</li>
<li>
<p><strong>节省资源考虑</strong></p>
<ul>
<li>减少不必要的写操作</li>
<li>简化心跳逻辑</li>
</ul>
</li>
</ol>
<h3 id="需要同时使用写空闲检测的场景">需要同时使用写空闲检测的场景：</h3>
<ol>
<li>
<p><strong>NAT环境下的长连接</strong></p>
<pre><code class="language-java">// 典型NAT环境下的客户端配置
pipeline.addLast(new IdleStateHandler(0, 30, 0, TimeUnit.SECONDS)); // 只检测写空闲
</code></pre>
</li>
<li>
<p><strong>需要服务端主动保活的系统</strong></p>
<pre><code class="language-java">// 服务端需要保持连接活跃
pipeline.addLast(new IdleStateHandler(60, 30, 0, TimeUnit.SECONDS)); // 读写都检测
</code></pre>
</li>
<li>
<p><strong>双向心跳验证</strong></p>
<pre><code class="language-java">// 高可靠性系统的心跳设计
// 服务端：
pipeline.addLast(new IdleStateHandler(60, 45, 0, TimeUnit.SECONDS));

// 客户端：
pipeline.addLast(new IdleStateHandler(75, 30, 0, TimeUnit.SECONDS));
</code></pre>
</li>
</ol>
<h2 id="三实际应用建议">三、实际应用建议</h2>
<h3 id="推荐方案1客户端单边心跳最常见">推荐方案1：客户端单边心跳（最常见）</h3>
<pre><code class="language-java">// 客户端配置
pipeline.addLast(new IdleStateHandler(0, 30, 0, TimeUnit.SECONDS)); // 只检测写空闲
pipeline.addLast(new HeartbeatClientHandler());

// 服务端配置
pipeline.addLast(new IdleStateHandler(90, 0, 0, TimeUnit.SECONDS)); // 只检测读空闲
</code></pre>
<p><strong>适用场景</strong>：大多数移动应用、WebSocket通信等</p>
<p><strong>优点</strong>：</p>
<ul>
<li>客户端主动保活，避免NAT超时</li>
<li>服务端只需检测客户端是否存活</li>
<li>实现简单</li>
</ul>
<h3 id="推荐方案2双向心跳检测">推荐方案2：双向心跳检测</h3>
<pre><code class="language-java">// 服务端配置
pipeline.addLast(new IdleStateHandler(60, 45, 0, TimeUnit.SECONDS));

// 客户端配置
pipeline.addLast(new IdleStateHandler(75, 30, 0, TimeUnit.SECONDS));
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>金融支付系统</li>
<li>物联网关键设备通信</li>
<li>对连接可靠性要求极高的场景</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>双方向连接状态确认</li>
<li>更高的可靠性</li>
<li>能更快发现单向网络中断情况</li>
</ul>
<h3 id="推荐方案3自适应心跳">推荐方案3：自适应心跳</h3>
<pre><code class="language-java">// 可根据网络条件动态调整
public class AdaptiveIdleStateHandler extends IdleStateHandler {
    private boolean isMobileNetwork;
    
    public AdaptiveIdleStateHandler() {
        super(60, 30, 0, TimeUnit.SECONDS);
    }
    
    @Override
    protected long nextDelay(IdleState state) {
        if (isMobileNetwork &amp;&amp; state == IdleState.WRITER_IDLE) {
            return 25; // 移动网络下更频繁发送
        }
        return super.nextDelay(state);
    }
}
</code></pre>
<h2 id="四关键决策因素">四、关键决策因素</h2>
<ol>
<li>
<p><strong>网络环境</strong>：</p>
<ul>
<li>公网/NAT环境：需要写空闲检测</li>
<li>内网环境：可能只需读空闲检测</li>
</ul>
</li>
<li>
<p><strong>客户端类型</strong>：</p>
<ul>
<li>移动设备：需要主动保活（写空闲）</li>
<li>服务端：通常只需检测客户端是否存活（读空闲）</li>
</ul>
</li>
<li>
<p><strong>业务需求</strong>：</p>
<ul>
<li>普通消息推送：单边检测足够</li>
<li>金融交易：建议双向检测</li>
</ul>
</li>
<li>
<p><strong>资源消耗</strong>：</p>
<ul>
<li>写空闲检测会增加少量网络流量</li>
<li>读空闲检测不会产生额外流量</li>
</ul>
</li>
</ol>
<h2 id="五典型案例">五、典型案例</h2>
<h3 id="案例1im即时通讯系统">案例1：IM即时通讯系统</h3>
<pre><code class="language-java">// 客户端（移动设备）
pipeline.addLast(new IdleStateHandler(0, 25, 0, TimeUnit.SECONDS)); // 只写空闲

// 服务端
pipeline.addLast(new IdleStateHandler(120, 0, 0, TimeUnit.SECONDS)); // 只读空闲
</code></pre>
<p><strong>理由</strong>：移动设备需要保持NAT映射，服务端只需确认客户端是否在线</p>
<h3 id="案例2物联网数据采集">案例2：物联网数据采集</h3>
<pre><code class="language-java">// 设备端（客户端）
pipeline.addLast(new IdleStateHandler(0, 60, 0, TimeUnit.SECONDS));

// 服务端
pipeline.addLast(new IdleStateHandler(180, 120, 0, TimeUnit.SECONDS));
</code></pre>
<p><strong>理由</strong>：设备可能处于不稳定网络环境，需要双方向检测</p>
<h2 id="总结">总结</h2>
<p>是否需要写空闲检测取决于具体场景：</p>
<ul>
<li><strong>大多数情况下</strong>：客户端需要写空闲检测（主动保活），服务端只需读空闲检测</li>
<li><strong>高可靠性系统</strong>：建议使用双向检测</li>
<li><strong>内网稳定环境</strong>：可能只需读空闲检测</li>
</ul>
<p>最佳实践是根据实际网络条件和业务需求，选择适当的组合方式。对于公网应用，特别是移动端，写空闲检测通常是必要的。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18846985" target="_blank">https://www.cnblogs.com/vipsoft/p/18846985</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.35230331547569443" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 17:54">2025-04-25 16:45</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">66</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18846985);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18846985', targetLink: 'https://www.cnblogs.com/vipsoft/p/18846985', title: 'Netty 心跳机制实现（客户端与服务端）' })">举报</a>
</div>
        