
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18920960" title="发布于 2025-06-09 16:47">
    <span role="heading" aria-level="2">【Zookeeper从入门到实战】SpringBoot整合完整指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="zookeeper从入门到实战springboot整合完整指南">Zookeeper从入门到实战：SpringBoot整合完整指南</h1>
<h2 id="一zookeeper概述">一、Zookeeper概述</h2>
<h3 id="11-什么是zookeeper">1.1 什么是Zookeeper</h3>
<p>Zookeeper是一个开源的分布式协调服务，由Apache软件基金会维护。它最初是为Hadoop生态系统设计的，但现在已被广泛应用于各种分布式系统中。Zookeeper提供了一种简单而健壮的方式，用于管理分布式环境中的配置信息、命名服务、分布式同步和组服务等。</p>
<h3 id="12-zookeeper的核心特性">1.2 Zookeeper的核心特性</h3>
<ul>
<li><strong>顺序一致性</strong>：客户端的更新请求将按照它们被发送的顺序进行应用</li>
<li><strong>原子性</strong>：更新操作要么成功要么失败，没有中间状态</li>
<li><strong>单一系统映像</strong>：无论客户端连接到哪个服务器，都将看到相同的服务视图</li>
<li><strong>可靠性</strong>：一旦更新被应用，它将从那时起保持，直到客户端覆盖更新</li>
<li><strong>及时性</strong>：系统的客户端视图保证在一定时间范围内是最新的</li>
</ul>
<h3 id="13-zookeeper的典型应用场景">1.3 Zookeeper的典型应用场景</h3>
<ol>
<li><strong>配置管理</strong>：集中式配置管理</li>
<li><strong>分布式锁</strong>：实现跨JVM的互斥机制</li>
<li><strong>集群管理</strong>：监控集群节点状态</li>
<li><strong>命名服务</strong>：类似DNS的服务</li>
<li><strong>分布式队列</strong>：简单的队列实现</li>
<li><strong>Leader选举</strong>：分布式系统中的主节点选举</li>
</ol>
<h2 id="二zookeeper安装与配置">二、Zookeeper安装与配置</h2>
<h3 id="21-单机模式安装">2.1 单机模式安装</h3>
<h4 id="下载zookeeper">下载Zookeeper</h4>
<pre><code class="language-bash">wget https://downloads.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz
tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz
cd apache-zookeeper-3.7.0-bin
</code></pre>
<h4 id="配置zookeeper">配置Zookeeper</h4>
<p>创建配置文件<code>conf/zoo.cfg</code>：</p>
<pre><code class="language-properties"># 基本时间单位(毫秒)
tickTime=2000
# 数据目录
dataDir=/tmp/zookeeper
# 客户端连接端口
clientPort=2181
# 初始化连接时能容忍的最长心跳间隔(tickTime的倍数)
initLimit=10
# 发送请求和接收响应能容忍的最长心跳间隔
syncLimit=5
</code></pre>
<h4 id="启动zookeeper">启动Zookeeper</h4>
<pre><code class="language-bash">bin/zkServer.sh start
</code></pre>
<h4 id="验证安装">验证安装</h4>
<pre><code class="language-bash">bin/zkCli.sh -server 127.0.0.1:2181
</code></pre>
<h3 id="22-集群模式安装">2.2 集群模式安装</h3>
<p>对于生产环境，建议至少部署3个节点的Zookeeper集群。修改每个节点的<code>zoo.cfg</code>：</p>
<pre><code class="language-properties">tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=10
syncLimit=5
# 集群配置 server.id=host:port1:port2
server.1=node1:2888:3888
server.2=node2:2888:3888
server.3=node3:2888:3888
</code></pre>
<p>在每个节点的dataDir目录下创建<code>myid</code>文件，内容为对应的server.id中的id：</p>
<pre><code class="language-bash"># 在node1上
echo 1 &gt; /var/lib/zookeeper/myid

# 在node2上
echo 2 &gt; /var/lib/zookeeper/myid

# 在node3上
echo 3 &gt; /var/lib/zookeeper/myid
</code></pre>
<h2 id="三zookeeper基础操作">三、Zookeeper基础操作</h2>
<h3 id="31-基本命令操作">3.1 基本命令操作</h3>
<p>通过zkCli.sh连接后可以执行以下命令：</p>
<pre><code class="language-bash"># 查看根节点
ls /

# 创建持久节点
create /myapp "myapp data"

# 创建临时节点(会话结束自动删除)
create -e /myapp/tempnode "temp data"

# 创建顺序节点
create -s /myapp/seqnode "seq data"

# 获取节点数据
get /myapp

# 设置节点数据
set /myapp "new data"

# 删除节点
delete /myapp/seqnode0000000001

# 递归删除节点
rmr /myapp

# 查看节点状态
stat /myapp
</code></pre>
<h3 id="32-zookeeper节点类型">3.2 Zookeeper节点类型</h3>
<ol>
<li><strong>持久节点(PERSISTENT)</strong>：创建后一直存在，除非显式删除</li>
<li><strong>临时节点(EPHEMERAL)</strong>：客户端会话结束时自动删除</li>
<li><strong>持久顺序节点(PERSISTENT_SEQUENTIAL)</strong>：持久节点，但节点名后会附加一个单调递增的数字后缀</li>
<li><strong>临时顺序节点(EPHEMERAL_SEQUENTIAL)</strong>：临时节点，带有序号后缀</li>
</ol>
<h3 id="33-zookeeper-watch机制">3.3 Zookeeper Watch机制</h3>
<p>Watch是Zookeeper的一个重要特性，它允许客户端在节点发生变化时收到通知。</p>
<pre><code class="language-bash"># 设置watch
get /myapp watch

# 另一个会话修改/myapp节点数据
set /myapp "changed data"

# 原会话会收到NodeDataChanged事件
</code></pre>
<h2 id="四zookeeper-java客户端api">四、Zookeeper Java客户端API</h2>
<h3 id="41-原生java客户端">4.1 原生Java客户端</h3>
<p>首先添加Maven依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="基本操作示例">基本操作示例</h4>
<pre><code class="language-java">import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;

public class ZookeeperDemo {
    private static final String CONNECT_STRING = "localhost:2181";
    private static final int SESSION_TIMEOUT = 5000;
    private static ZooKeeper zk;
    private static final CountDownLatch connectedSemaphore = new CountDownLatch(1);

    public static void main(String[] args) throws IOException, InterruptedException, KeeperException {
        // 创建连接
        zk = new ZooKeeper(CONNECT_STRING, SESSION_TIMEOUT, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (Event.KeeperState.SyncConnected == event.getState()) {
                    connectedSemaphore.countDown();
                }
            }
        });
        connectedSemaphore.await();
        System.out.println("Zookeeper连接成功");
        
        // 创建节点
        String path = "/test-node";
        String data = "test data";
        zk.create(path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        System.out.println("创建节点: " + path);
        
        // 获取节点数据
        byte[] nodeData = zk.getData(path, false, null);
        System.out.println("节点数据: " + new String(nodeData));
        
        // 修改节点数据
        String newData = "new test data";
        zk.setData(path, newData.getBytes(), -1);
        System.out.println("修改节点数据");
        
        // 删除节点
        zk.delete(path, -1);
        System.out.println("删除节点: " + path);
        
        // 关闭连接
        zk.close();
    }
}
</code></pre>
<h4 id="watch示例">Watch示例</h4>
<pre><code class="language-java">public class ZookeeperWatchDemo {
    // ... 同上连接代码
    
    public static void watchDemo() throws KeeperException, InterruptedException {
        String path = "/watch-node";
        
        // 创建节点
        zk.create(path, "init".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        
        // 设置watch
        Stat stat = new Stat();
        byte[] data = zk.getData(path, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                System.out.println("收到事件: " + event);
                if (event.getType() == Event.EventType.NodeDataChanged) {
                    try {
                        // 再次设置watch，实现持续监听
                        byte[] newData = zk.getData(path, this, null);
                        System.out.println("数据已修改，新值为: " + new String(newData));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }, stat);
        
        System.out.println("初始数据: " + new String(data));
        
        // 修改数据触发watch
        zk.setData(path, "changed".getBytes(), stat.getVersion());
        
        // 等待watch触发
        Thread.sleep(1000);
        
        // 删除节点
        zk.delete(path, -1);
    }
}
</code></pre>
<h3 id="42-curator客户端">4.2 Curator客户端</h3>
<p>Curator是Netflix开源的Zookeeper客户端，提供了更高级的API和常用模式的实现。</p>
<h4 id="添加依赖">添加依赖</h4>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="基本操作示例-1">基本操作示例</h4>
<pre><code class="language-java">import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;

public class CuratorDemo {
    private static final String CONNECT_STRING = "localhost:2181";
    private static final int SESSION_TIMEOUT = 5000;
    private static final int CONNECTION_TIMEOUT = 3000;

    public static void main(String[] args) throws Exception {
        // 创建客户端
        CuratorFramework client = CuratorFrameworkFactory.builder()
                .connectString(CONNECT_STRING)
                .sessionTimeoutMs(SESSION_TIMEOUT)
                .connectionTimeoutMs(CONNECTION_TIMEOUT)
                .retryPolicy(new ExponentialBackoffRetry(1000, 3))
                .build();
        
        // 启动客户端
        client.start();
        
        // 创建节点
        String path = "/curator-node";
        client.create()
                .creatingParentsIfNeeded()
                .withMode(CreateMode.PERSISTENT)
                .forPath(path, "init".getBytes());
        System.out.println("创建节点: " + path);
        
        // 获取节点数据
        byte[] data = client.getData().forPath(path);
        System.out.println("节点数据: " + new String(data));
        
        // 修改节点数据
        Stat stat = client.setData().forPath(path, "changed".getBytes());
        System.out.println("修改节点数据，版本号: " + stat.getVersion());
        
        // 删除节点
        client.delete()
                .guaranteed()
                .deletingChildrenIfNeeded()
                .forPath(path);
        System.out.println("删除节点: " + path);
        
        // 关闭客户端
        client.close();
    }
}
</code></pre>
<h2 id="五springboot整合zookeeper">五、SpringBoot整合Zookeeper</h2>
<h3 id="51-项目搭建">5.1 项目搭建</h3>
<p>创建SpringBoot项目并添加依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;version&gt;5.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
        &lt;version&gt;5.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="52-配置类">5.2 配置类</h3>
<p>创建Zookeeper配置类：</p>
<pre><code class="language-java">import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ZookeeperConfig {
    
    @Value("${zookeeper.connect-string}")
    private String connectString;
    
    @Value("${zookeeper.session-timeout}")
    private int sessionTimeout;
    
    @Value("${zookeeper.connection-timeout}")
    private int connectionTimeout;
    
    @Bean(initMethod = "start", destroyMethod = "close")
    public CuratorFramework curatorFramework() {
        return CuratorFrameworkFactory.builder()
                .connectString(connectString)
                .sessionTimeoutMs(sessionTimeout)
                .connectionTimeoutMs(connectionTimeout)
                .retryPolicy(new ExponentialBackoffRetry(1000, 3))
                .namespace("springboot-demo")  // 命名空间隔离
                .build();
    }
}
</code></pre>
<p>在<code>application.properties</code>中添加配置：</p>
<pre><code class="language-properties"># Zookeeper配置
zookeeper.connect-string=localhost:2181
zookeeper.session-timeout=5000
zookeeper.connection-timeout=3000
</code></pre>
<h3 id="53-服务类">5.3 服务类</h3>
<p>创建Zookeeper操作服务类：</p>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.ChildData;
import org.apache.curator.framework.recipes.cache.CuratorCache;
import org.apache.curator.framework.recipes.cache.CuratorCacheListener;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.util.List;

@Slf4j
@Service
public class ZookeeperService {
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    /**
     * 创建节点
     */
    public String createNode(String path, String data, CreateMode createMode) throws Exception {
        byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);
        String createdPath = curatorFramework.create()
                .creatingParentsIfNeeded()
                .withMode(createMode)
                .forPath(path, dataBytes);
        log.info("节点创建成功: {}", createdPath);
        return createdPath;
    }
    
    /**
     * 获取节点数据
     */
    public String getNodeData(String path) throws Exception {
        byte[] dataBytes = curatorFramework.getData().forPath(path);
        return new String(dataBytes, StandardCharsets.UTF_8);
    }
    
    /**
     * 更新节点数据
     */
    public Stat updateNodeData(String path, String data) throws Exception {
        byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);
        return curatorFramework.setData().forPath(path, dataBytes);
    }
    
    /**
     * 删除节点
     */
    public void deleteNode(String path) throws Exception {
        curatorFramework.delete()
                .guaranteed()
                .deletingChildrenIfNeeded()
                .forPath(path);
        log.info("节点删除成功: {}", path);
    }
    
    /**
     * 检查节点是否存在
     */
    public boolean isNodeExist(String path) throws Exception {
        Stat stat = curatorFramework.checkExists().forPath(path);
        return stat != null;
    }
    
    /**
     * 获取子节点列表
     */
    public List&lt;String&gt; getChildren(String path) throws Exception {
        return curatorFramework.getChildren().forPath(path);
    }
    
    /**
     * 添加节点监听
     */
    public void addNodeListener(String path, NodeListenerCallback callback) {
        CuratorCache cache = CuratorCache.build(curatorFramework, path);
        
        CuratorCacheListener listener = CuratorCacheListener.builder()
                .forCreates(node -&gt; callback.onNodeCreated(node.getPath(), new String(node.getData())))
                .forChanges((oldNode, node) -&gt; 
                        callback.onNodeUpdated(node.getPath(), new String(node.getData())))
                .forDeletes(node -&gt; callback.onNodeDeleted(node.getPath()))
                .forInitialized(() -&gt; callback.onInitialized()))
                .build();
        
        cache.listenable().addListener(listener);
        cache.start();
    }
    
    public interface NodeListenerCallback {
        default void onNodeCreated(String path, String data) {}
        default void onNodeUpdated(String path, String data) {}
        default void onNodeDeleted(String path) {}
        default void onInitialized() {}
    }
}
</code></pre>
<h3 id="54-控制器类">5.4 控制器类</h3>
<p>创建REST控制器：</p>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/zk")
public class ZookeeperController {
    
    @Autowired
    private ZookeeperService zookeeperService;
    
    @PostMapping("/node")
    public String createNode(@RequestParam String path, 
                           @RequestParam String data,
                           @RequestParam(defaultValue = "PERSISTENT") String mode) throws Exception {
        return zookeeperService.createNode(path, data, CreateMode.valueOf(mode));
    }
    
    @GetMapping("/node")
    public String getNodeData(@RequestParam String path) throws Exception {
        return zookeeperService.getNodeData(path);
    }
    
    @PutMapping("/node")
    public String updateNodeData(@RequestParam String path, 
                               @RequestParam String data) throws Exception {
        zookeeperService.updateNodeData(path, data);
        return "更新成功";
    }
    
    @DeleteMapping("/node")
    public String deleteNode(@RequestParam String path) throws Exception {
        zookeeperService.deleteNode(path);
        return "删除成功";
    }
    
    @GetMapping("/node/exists")
    public boolean isNodeExist(@RequestParam String path) throws Exception {
        return zookeeperService.isNodeExist(path);
    }
    
    @GetMapping("/node/children")
    public List&lt;String&gt; getChildren(@RequestParam String path) throws Exception {
        return zookeeperService.getChildren(path);
    }
}
</code></pre>
<h2 id="六zookeeper高级应用">六、Zookeeper高级应用</h2>
<h3 id="61-分布式锁实现">6.1 分布式锁实现</h3>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Slf4j
@Service
public class DistributedLockService {
    
    private static final String LOCK_PATH = "/locks";
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    /**
     * 获取分布式锁
     */
    public boolean acquireLock(String lockName, long waitTime, TimeUnit timeUnit) {
        InterProcessMutex lock = new InterProcessMutex(curatorFramework, LOCK_PATH + "/" + lockName);
        try {
            return lock.acquire(waitTime, timeUnit);
        } catch (Exception e) {
            log.error("获取分布式锁失败", e);
            return false;
        }
    }
    
    /**
     * 释放分布式锁
     */
    public void releaseLock(String lockName) {
        InterProcessMutex lock = new InterProcessMutex(curatorFramework, LOCK_PATH + "/" + lockName);
        try {
            if (lock.isAcquiredInThisProcess()) {
                lock.release();
            }
        } catch (Exception e) {
            log.error("释放分布式锁失败", e);
        }
    }
    
    /**
     * 执行带锁的操作
     */
    public &lt;T&gt; T executeWithLock(String lockName, long waitTime, TimeUnit timeUnit, LockOperation&lt;T&gt; operation) throws Exception {
        InterProcessMutex lock = new InterProcessMutex(curatorFramework, LOCK_PATH + "/" + lockName);
        try {
            if (lock.acquire(waitTime, timeUnit)) {
                return operation.execute();
            } else {
                throw new RuntimeException("获取锁超时");
            }
        } finally {
            if (lock.isAcquiredInThisProcess()) {
                lock.release();
            }
        }
    }
    
    public interface LockOperation&lt;T&gt; {
        T execute() throws Exception;
    }
}
</code></pre>
<h3 id="62-配置中心实现">6.2 配置中心实现</h3>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.CuratorCache;
import org.apache.curator.framework.recipes.cache.CuratorCacheListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Service
public class ConfigCenterService {
    
    private static final String CONFIG_PATH = "/config";
    private final Map&lt;String, String&gt; configCache = new ConcurrentHashMap&lt;&gt;();
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    @PostConstruct
    public void init() throws Exception {
        // 初始化配置
        loadAllConfigs();
        
        // 监听配置变化
        watchConfigChanges();
    }
    
    /**
     * 加载所有配置
     */
    private void loadAllConfigs() throws Exception {
        if (curatorFramework.checkExists().forPath(CONFIG_PATH) == null) {
            curatorFramework.create().creatingParentsIfNeeded().forPath(CONFIG_PATH);
        }
        
        List&lt;String&gt; children = curatorFramework.getChildren().forPath(CONFIG_PATH);
        for (String child : children) {
            String path = CONFIG_PATH + "/" + child;
            byte[] data = curatorFramework.getData().forPath(path);
            configCache.put(child, new String(data, StandardCharsets.UTF_8));
        }
    }
    
    /**
     * 监听配置变化
     */
    private void watchConfigChanges() {
        CuratorCache cache = CuratorCache.build(curatorFramework, CONFIG_PATH);
        
        CuratorCacheListener listener = CuratorCacheListener.builder()
                .forCreates(node -&gt; {
                    String key = node.getPath().replace(CONFIG_PATH + "/", "");
                    configCache.put(key, new String(node.getData()));
                    log.info("配置新增: {}={}", key, configCache.get(key));
                })
                .forChanges((oldNode, node) -&gt; {
                    String key = node.getPath().replace(CONFIG_PATH + "/", "");
                    configCache.put(key, new String(node.getData()));
                    log.info("配置修改: {}={}", key, configCache.get(key));
                })
                .forDeletes(node -&gt; {
                    String key = node.getPath().replace(CONFIG_PATH + "/", "");
                    configCache.remove(key);
                    log.info("配置删除: {}", key);
                })
                .build();
        
        cache.listenable().addListener(listener);
        cache.start();
    }
    
    /**
     * 获取配置
     */
    public String getConfig(String key) {
        return configCache.get(key);
    }
    
    /**
     * 获取所有配置
     */
    public Map&lt;String, String&gt; getAllConfigs() {
        return new HashMap&lt;&gt;(configCache);
    }
    
    /**
     * 设置配置
     */
    public void setConfig(String key, String value) throws Exception {
        String path = CONFIG_PATH + "/" + key;
        byte[] data = value.getBytes(StandardCharsets.UTF_8);
        
        if (curatorFramework.checkExists().forPath(path) == null) {
            curatorFramework.create().forPath(path, data);
        } else {
            curatorFramework.setData().forPath(path, data);
        }
    }
    
    /**
     * 删除配置
     */
    public void deleteConfig(String key) throws Exception {
        String path = CONFIG_PATH + "/" + key;
        curatorFramework.delete().forPath(path);
    }
}
</code></pre>
<h3 id="63-服务注册与发现">6.3 服务注册与发现</h3>
<h4 id="服务注册">服务注册</h4>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.curator.framework.CuratorFramework;
import org.apache.zookeeper.CreateMode;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.net.InetAddress;

@Slf4j
@Service
public class ServiceRegistry {
    
    private static final String REGISTRY_PATH = "/services";
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    @Value("${server.port}")
    private int port;
    
    private String servicePath;
    
    @PostConstruct
    public void register() throws Exception {
        // 创建服务根节点(持久节点)
        if (curatorFramework.checkExists().forPath(REGISTRY_PATH) == null) {
            curatorFramework.create()
                    .creatingParentsIfNeeded()
                    .forPath(REGISTRY_PATH, "Service Registry".getBytes());
        }
        
        // 获取本机IP地址
        String ip = InetAddress.getLocalHost().getHostAddress();
        String serviceInstance = ip + ":" + port;
        
        // 创建临时顺序节点
        servicePath = curatorFramework.create()
                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                .forPath(REGISTRY_PATH + "/instance-", serviceInstance.getBytes());
        
        log.info("服务注册成功: {}", servicePath);
    }
    
    public String getServicePath() {
        return servicePath;
    }
}
</code></pre>
<h4 id="服务发现">服务发现</h4>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.CuratorCache;
import org.apache.curator.framework.recipes.cache.CuratorCacheListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Service
public class ServiceDiscovery {
    
    private static final String REGISTRY_PATH = "/services";
    private final List&lt;String&gt; serviceInstances = new ArrayList&lt;&gt;();
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    @PostConstruct
    public void init() throws Exception {
        // 初始化服务列表
        discoverServices();
        
        // 监听服务变化
        watchServices();
    }
    
    /**
     * 发现可用服务
     */
    private void discoverServices() throws Exception {
        serviceInstances.clear();
        
        if (curatorFramework.checkExists().forPath(REGISTRY_PATH) != null) {
            List&lt;String&gt; instances = curatorFramework.getChildren().forPath(REGISTRY_PATH);
            for (String instance : instances) {
                String instancePath = REGISTRY_PATH + "/" + instance;
                byte[] data = curatorFramework.getData().forPath(instancePath);
                serviceInstances.add(new String(data));
            }
        }
        
        log.info("当前可用服务实例: {}", serviceInstances);
    }
    
    /**
     * 监听服务变化
     */
    private void watchServices() {
        CuratorCache cache = CuratorCache.build(curatorFramework, REGISTRY_PATH);
        
        CuratorCacheListener listener = CuratorCacheListener.builder()
                .forCreates(node -&gt; {
                    try {
                        discoverServices();
                    } catch (Exception e) {
                        log.error("处理服务新增事件失败", e);
                    }
                })
                .forChanges((oldNode, node) -&gt; {
                    try {
                        discoverServices();
                    } catch (Exception e) {
                        log.error("处理服务变更事件失败", e);
                    }
                })
                .forDeletes(node -&gt; {
                    try {
                        discoverServices();
                    } catch (Exception e) {
                        log.error("处理服务删除事件失败", e);
                    }
                })
                .build();
        
        cache.listenable().addListener(listener);
        cache.start();
    }
    
    /**
     * 获取所有服务实例
     */
    public List&lt;String&gt; getAllServiceInstances() {
        return new ArrayList&lt;&gt;(serviceInstances);
    }
    
    /**
     * 随机获取一个服务实例(简单的负载均衡)
     */
    public String getRandomServiceInstance() {
        if (serviceInstances.isEmpty()) {
            return null;
        }
        int index = (int) (Math.random() * serviceInstances.size());
        return serviceInstances.get(index);
    }
}
</code></pre>
<h2 id="七生产环境注意事项">七、生产环境注意事项</h2>
<h3 id="71-zookeeper性能优化">7.1 Zookeeper性能优化</h3>
<ol>
<li><strong>数据目录和事务日志目录分离</strong>：将dataDir和dataLogDir配置到不同的物理磁盘</li>
<li><strong>JVM调优</strong>：适当增加JVM堆内存，设置合适的GC参数</li>
<li><strong>快照清理</strong>：配置autopurge.snapRetainCount和autopurge.purgeInterval自动清理旧快照</li>
<li><strong>限制客户端连接数</strong>：合理设置maxClientCnxns参数</li>
</ol>
<h3 id="72-监控与运维">7.2 监控与运维</h3>
<ol>
<li>
<p><strong>使用四字命令监控</strong>：</p>
<ul>
<li><code>echo stat | nc localhost 2181</code> 查看服务器状态</li>
<li><code>echo mntr | nc localhost 2181</code> 查看监控信息</li>
<li><code>echo cons | nc localhost 2181</code> 查看客户端连接</li>
</ul>
</li>
<li>
<p><strong>JMX监控</strong>：启用JMX监控Zookeeper运行状态</p>
</li>
<li>
<p><strong>日志管理</strong>：合理配置日志级别和日志滚动策略</p>
</li>
</ol>
<h3 id="73-常见问题解决">7.3 常见问题解决</h3>
<ol>
<li>
<p><strong>连接问题</strong>：</p>
<ul>
<li>检查防火墙设置</li>
<li>确认Zookeeper服务是否正常运行</li>
<li>检查客户端和服务端版本是否兼容</li>
</ul>
</li>
<li>
<p><strong>节点已存在错误</strong>：</p>
<ul>
<li>使用带版本号的API操作节点</li>
<li>先检查节点是否存在再操作</li>
</ul>
</li>
<li>
<p><strong>会话过期</strong>：</p>
<ul>
<li>增加会话超时时间</li>
<li>实现会话过期后的重连逻辑</li>
</ul>
</li>
</ol>
<h2 id="八总结">八、总结</h2>
<p>本文从Zookeeper的基本概念讲起，详细介绍了安装配置、基本操作、Java客户端使用，到SpringBoot整合，再到高级应用如分布式锁、配置中心、服务注册与发现等。通过完整的代码示例和详细注释，希望能帮助读者从零开始掌握Zookeeper的使用。</p>
<p>Zookeeper作为分布式系统的基石，其强大的协调能力可以帮助我们解决分布式环境中的各种难题。但在实际生产环境中，还需要根据具体场景合理设计和使用，并注意性能优化和监控运维。</p>
<p>完整的SpringBoot整合Zookeeper项目代码可以在GitHub上找到：<a href="https://github.com/example/zookeeper-demo" target="_blank" rel="noopener nofollow">项目地址</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-09 16:47">2025-06-09 16:47</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">62</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18920960);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18920960', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18920960', title: '【Zookeeper从入门到实战】SpringBoot整合完整指南' })">举报</a>
</div>
        