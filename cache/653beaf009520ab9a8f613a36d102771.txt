
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18750484" title="发布于 2025-03-04 14:45">
    <span role="heading" aria-level="2">Linux系列：如何调试 malloc 的底层源码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>上一篇我们聊过 C# 调用 C 的 malloc 代码来演示heap的内存泄露问题，但要想深入研究得必须把 malloc 的实现库 libc.so 给调试起来，大家都知道在Linux 上 libc 和 Windows 的 Win32 API 是一个层级的，由于 Linux 重度依赖 libc，比较吐槽的是<strong>两者各自为政</strong>，如果手工编译 libc，容易搞出很多兼容性问题，这一点真的不如 Windows 的大一统来的痛快，手工编译比较繁琐，用此篇来记录下。</p>
<h2 id="二手工编译-libc">二：手工编译 libc</h2>
<h3 id="1-下载-libc-239-源代码">1. 下载 libc 2.39 源代码</h3>
<p>要想知道下载哪个版本的 libc，可以用 ldd 观察现存的 libc 版本，参考如下：</p>
<pre><code class="language-bash">
root@ubuntu2404:/data# ldd /bin/bash | grep libc
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x0000737556800000)
root@ubuntu2404:/data# /lib/x86_64-linux-gnu/libc.so.6
GNU C Library (Ubuntu GLIBC 2.39-0ubuntu8.4) stable release version 2.39.
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
Compiled by GNU CC version 13.3.0.
libc ABIs: UNIQUE IFUNC ABSOLUTE
Minimum supported kernel: 3.2.0
For bug reporting instructions, please see:
&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.

</code></pre>
<p>从卦象看，当前 libc 的版本是 <code>Ubuntu GLIBC 2.39-0ubuntu8.4</code>，接下来下载 2.39 版本的源代码进行编译即可。</p>
<pre><code class="language-C#">
root@ubuntu2404:/src# wget http://ftp.gnu.org/gnu/libc/glibc-2.39.tar.gz
root@ubuntu2404:/src# tar -xzf glibc-2.39.tar.gz &amp;&amp; cd glibc-2.39 &amp;&amp; mkdir build &amp;&amp; cd build
root@ubuntu2404:/src/glibc-2.39/build# ../configure --prefix=/usr --enable-debug=yes
root@ubuntu2404:/src/glibc-2.39/build# make -j$(nproc)
root@ubuntu2404:/src/glibc-2.39/build# ./libc.so --version
GNU C Library (GNU libc) stable release version 2.39.
Copyright (C) 2024 Free Software Foundation, Inc.
...

</code></pre>
<p>稍等片刻后，就可以看到源码编译出来的 libc.so ，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202503/214741-20250304144446519-1742960456.png" alt="" loading="lazy"></p>
<h3 id="2-配置-c-代码">2. 配置 C 代码</h3>
<p>写了一段简单的 C 代码，参考如下：</p>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    // getchar();    !!! 先注释掉的，后续放开
    void *ptr = malloc(100);
    if (ptr == NULL)
    {
        fprintf(stderr, "malloc failed\n");
        return 1;
    }
    free(ptr);
    printf("malloc and free succeeded\n");
    getchar();
    return 0;
}

为了能够加载我的libc库，使用 `LD_PRELOAD` 环境变量指定，本想用 gdb 启动调试的方式执行 main，无奈编译出来的 __vdso_timeDuring 和 kernel 有兼容性问题导致报错，输出如下：

``` C#
root@ubuntu2404:/data# gdb ./main
Reading symbols from ./main...
(gdb) set environment LD_PRELOAD /src/glibc-2.39/build/libc.so
(gdb) run
Starting program: /data/main 
     58340:	__vdso_timeDuring startup program terminated with signal SIGSEGV, Segmentation fault.
</code></pre>
<p>一定捣鼓之后，我发现不用 gdb 启动就没有问题，同时内存段也挂上了我的自定义libc，太棒了，输出如下：</p>
<pre><code class="language-C">
root@ubuntu2404:/data# LD_PRELOAD=/src/glibc-2.39/build/libc.so ./main
malloc and free succeeded

root@ubuntu2404:/src/glibc-2.39/build# ps -ef | grep main
root       58361    1251  0 13:55 pts/0    00:00:00 ./main
root       58366    1869  0 13:56 pts/1    00:00:00 grep --color=auto main

root@ubuntu2404:/src/glibc-2.39/build# cat /proc/58361/maps
60fc4cd29000-60fc4cd2a000 r--p 00000000 08:03 1703942                    /data/main
60fc4cd2a000-60fc4cd2b000 r-xp 00001000 08:03 1703942                    /data/main
60fc4cd2b000-60fc4cd2c000 r--p 00002000 08:03 1703942                    /data/main
60fc4cd2c000-60fc4cd2d000 r--p 00002000 08:03 1703942                    /data/main
60fc4cd2d000-60fc4cd2e000 rw-p 00003000 08:03 1703942                    /data/main
60fc8a96c000-60fc8a98d000 rw-p 00000000 00:00 0                          [heap]
7add43aaa000-7add43aad000 rw-p 00000000 00:00 0 
7add43aad000-7add43ad1000 r--p 00000000 08:03 2915675                    /src/glibc-2.39/build/libc.so
7add43ad1000-7add43c21000 r-xp 00024000 08:03 2915675                    /src/glibc-2.39/build/libc.so
7add43c21000-7add43c78000 r--p 00174000 08:03 2915675                    /src/glibc-2.39/build/libc.so
7add43c78000-7add43c7c000 r--p 001ca000 08:03 2915675                    /src/glibc-2.39/build/libc.so
7add43c7c000-7add43c7e000 rw-p 001ce000 08:03 2915675                    /src/glibc-2.39/build/libc.so
...

</code></pre>
<p>这就叫在绝望中寻找希望，既然能运行，那就用 gdb 附加调试吧，只要能研究到 malloc 的底层代码才是最终目的。。。</p>
<p>把 main() 函数入口的 <code>getchar()</code> 给注释掉，方便在 malloc 之前通过 attach 附加，为了能够在 vscode 中操作，新增一个对可执行文件可控的 launch.json，内容如下：</p>
<pre><code class="language-json">
{
    "configurations": [
        {
            "name": "C/C++: gcc build and debug active file",
            "type": "cppdbg",
            "request": "attach",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "processId": "${command:pickProcess}",      // 选择要附加的进程
            "stopAtEntry": false,
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
        }
    ],
    "version": "2.0.0"
}

</code></pre>
<p>再新增一个 gcc 编译的 task 任务文件 (task.json),内容如下：</p>
<pre><code class="language-json">
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc build active file",
            "command": "/usr/bin/gcc",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}

</code></pre>
<p>稍微解释一下：</p>
<ul>
<li><code>"processId": "${command:pickProcess}"</code> 表示弹框选择你要附加的进程。</li>
<li><code>"request": "attach"</code> 使用附加进程的模式</li>
</ul>
<p>在 vscode 中使用 <code>Ctrl+Shift+B</code> 或者 <code>gcc -g main.c -o main</code> 对代码进行构建，接下来执行代码。</p>
<pre><code class="language-bash">
root@ubuntu2404:/data# LD_PRELOAD=/src/glibc-2.39/build/libc.so ./main

root@ubuntu2404:/src/glibc-2.39/build# ps -ef | grep main
root       58992    1251  0 14:14 pts/0    00:00:00 ./main
root       58999    1869  0 14:16 pts/1    00:00:00 grep --color=auto main

</code></pre>
<p>点击UI中 <code>Run -&gt; Start Debugging</code> 选择要附加的 <code>pid=58992</code> ，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202503/214741-20250304144446512-2112762518.png" alt="" loading="lazy"></p>
<h3 id="3-观察效果">3. 观察效果</h3>
<p>vscode 附加成功后，在 UI 上 Enter 回车过掉 getchar()，单步 F11 调试即可进入 malloc 方法实现，挺有意思的，最后给大家截一张大图：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202503/214741-20250304144446557-1810323045.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>对 Win32 级别的 libc 进行源码调试，有助于我们对书籍中那些malloc的底层理论知识有一个很好的眼见为实，也是给Linux上的.NET高级调试打开了一扇窗！<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3990274753101852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-04 14:45">2025-03-04 14:45</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">156</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18750484" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18750484);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18750484', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18750484', title: 'Linux系列：如何调试 malloc 的底层源码' })">举报</a>
</div>
        