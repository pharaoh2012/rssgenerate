
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/testtraveler/p/18773721" title="发布于 2025-03-15 17:27">
    <span role="heading" aria-level="2">(Python)用栈实现计算器的原理及实现</span>
    

</a>

	</div>
	
	<div class="postText">
		    <div id="cnblogs_post_description" style="display: none">
        
        使用python，用栈实现计算器的运算逻辑，同时讨论了中缀表达式与后缀表达式的转换。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>我们日常使用的计算器是怎么实现计算的呢？能自己判断运算符的优先级去计算，能处理括号的匹配，这些都是怎么实现的呢？</p>
<p>一个大家熟知的答案是用栈，好的，那么为什么要用栈？为什么栈能实现呢？</p>
<hr>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#前言" rel="noopener nofollow">前言</a></li><li><a href="#前中后缀表达式" rel="noopener nofollow">（前|中|后）缀表达式？</a></li><li><a href="#计算器的实现逻辑" rel="noopener nofollow">计算器的实现逻辑</a><ul><li><a href="#总体实现逻辑" rel="noopener nofollow">总体实现逻辑</a></li><li><a href="#中缀表达式转后缀表达式" rel="noopener nofollow">中缀表达式转后缀表达式</a></li><li><a href="#计算后缀表达式的结果" rel="noopener nofollow">计算后缀表达式的结果</a></li><li><a href="#计算的整体实现" rel="noopener nofollow">计算的整体实现</a></li></ul></li><li><a href="#进一步简化" rel="noopener nofollow">进一步简化</a></li><li><a href="#参考资料" rel="noopener nofollow">参考资料</a></li></ul></div><p></p>
<hr>
<h2 id="前中后缀表达式">（前|中|后）缀表达式？</h2>
<p>我们最熟悉的应该是我们的中缀表达式，也就是形如 <code>1 + 3 * 2</code> 这样的式子，即操作符位于操作数之间。</p>
<p>从类似的概念出发，我们不难得到前缀表达式是 <code>+ 1 * 3 2</code>（操作符位于操作数之前），后缀表达式是 <code>1 3 2 * +</code></p>
<p><strong>前缀表达式</strong>又叫做波兰表示法（Polish notation，或波兰记法），<strong>后缀表达式</strong>叫做逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法）。</p>
<p>而我们给计算器输入的就是我们的中缀表达式，中缀表达式因为其只能按照顺序一个个计算下去，导致对于运算符的优先级的判断无法实现，因此，一个常见的操作就是，将中缀表达式转换为后缀表达式（可以判断运算的优先级），然后让我们的计算器进行计算。</p>
<p>对于中缀转后缀的过程的实现很简单，即使用<strong>运算符优先级栈</strong>：</p>
<ol>
<li>
<p><strong>初始化一个空栈</strong>，用于存储运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等），并初始化一个空的输出队列（用于存储后缀表达式的结果）。</p>
</li>
<li>
<p><strong>从左到右扫描中缀表达式</strong>，逐个处理每个字符：</p>
<ul>
<li>
<p>如果是<strong>操作数</strong>（如数字），直接加入输出队列。</p>
</li>
<li>
<p>如果是<strong>左括号</strong>（<code>(</code>），直接压入栈中。</p>
</li>
<li>
<p>如果是<strong>右括号</strong>（<code>)</code>），则依次弹出栈顶运算符并加入输出队列，直到遇到左括号（左括号出栈但不加入输出队列）。</p>
</li>
<li>
<p>如果是<strong>运算符</strong>（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等），则：</p>
<ul>
<li>
<p>如果栈为空，直接压入栈中。</p>
</li>
<li>
<p>如果栈不为空，比较当前运算符与栈顶运算符的优先级：</p>
<ul>
<li>如果当前运算符的优先级<strong>高于</strong>栈顶运算符，直接压入栈中。</li>
<li>如果当前运算符的优先级<strong>低于或等于</strong>栈顶运算符，依次弹出栈顶运算符并加入输出队列，直到栈为空或栈顶运算符的优先级低于当前运算符，然后将当前运算符压入栈中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>扫描结束后</strong>，如果栈中仍有运算符，依次弹出并加入输出队列。</p>
</li>
<li>
<p><strong>输出队列中的内容即为后缀表达式</strong>。</p>
<p>运算符优先级的判定，在没有括号的情况下是 <code>*</code> <code>/</code> &gt; <code>+</code> <code>-</code></p>
<p>同级遵循<strong>从左到右</strong>的顺序</p>
</li>
</ol>
<p>拿最简单的 <code>1 + 3 * 2 - 5</code> 举例</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
<th>输出(out)</th>
<th>栈(stack)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>1</code> -&gt; out</td>
<td><code>[1]</code></td>
<td><code>[]</code></td>
</tr>
<tr>
<td>2</td>
<td><code>+</code> -&gt; stack</td>
<td><code>[1]</code></td>
<td><code>[+]</code></td>
</tr>
<tr>
<td>3</td>
<td><code>3</code> -&gt; out</td>
<td><code>[1,3]</code></td>
<td><code>[+]</code></td>
</tr>
<tr>
<td>4</td>
<td><code>*</code> &gt; +, <code>*</code> -&gt; stack</td>
<td><code>[1,3]</code></td>
<td><code>[+,*]</code></td>
</tr>
<tr>
<td>5</td>
<td><code>2</code> -&gt; out</td>
<td><code>[1,3,2]</code></td>
<td><code>[+,*]</code></td>
</tr>
<tr>
<td>6</td>
<td><code>-</code> &lt; <code>*</code>, <code>*</code> &lt;- stack, <code>*</code> -&gt; out</td>
<td><code>[1,3,2,*]</code></td>
<td><code>[+]</code></td>
</tr>
<tr>
<td>7</td>
<td><code>-</code> = <code>+</code>, <code>+</code> &lt;- stack, <code>+</code> -&gt; out</td>
<td><code>[1,3,2,*,+]</code></td>
<td><code>[]</code></td>
</tr>
<tr>
<td>8</td>
<td><code>-</code> -&gt; stack</td>
<td><code>[1,3,2,*,+]</code></td>
<td><code>[-]</code></td>
</tr>
<tr>
<td>9</td>
<td><code>5</code> -&gt; out</td>
<td><code>[1,3,2,*,+,5]</code></td>
<td><code>[-]</code></td>
</tr>
<tr>
<td>10</td>
<td>stack is not <code>[]</code>, <code>-</code> &lt;- stack</td>
<td><code>[1,3,2,*,+,5,-]</code></td>
<td><code>[]</code></td>
</tr>
</tbody>
</table>
<p>使用后缀表达式的理由是，它只需要用一个从左到右的扫描，每次操作的时间复杂度只需要<span class="math inline">\(O(1)\)</span>，对于长度为<span class="math inline">\(n\)</span>的表达式，后缀表达式的计算复杂度为<span class="math inline">\(O(n)\)</span>，以及说，这种表达对于计算机是没有歧义的，优先级明确的，易于实现的。</p>
<hr>
<h2 id="计算器的实现逻辑">计算器的实现逻辑</h2>
<h3 id="总体实现逻辑">总体实现逻辑</h3>
<p>那么计算器的实现逻辑就可以写出如下：</p>
<div class="mermaid">graph LR;
	A[中缀表达式] --&gt; B[后缀表达式];
	B --&gt; C[栈操作计算后缀表达式]
</div><hr>
<h3 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h3>
<p>假如我们有表达式如下：</p>
<pre><code class="language-python">expression = "1-2*((60-30+(-40/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))"
</code></pre>
<p>中缀表达式转后缀表达式就用我们最爱的正则表达式解决。</p>
<ol>
<li><strong>​<code>\d+\.\d+</code>​</strong> ：匹配小数部分。</li>
<li><strong>​<code>\d+</code>​</strong> ：匹配整数部分。</li>
<li><strong>​<code>[+\-*/()]</code>​</strong> ：匹配运算符和括号。</li>
</ol>
<p>什么，负数怎么办，怎么将其跟<code>-</code>区分？把它标记出来单独处理就是，比方说用 <code>u-</code> 表示负号。</p>
<p>怎么标记呢？负号出现的位置只有两种情况：</p>
<ol>
<li>表达式的开头</li>
<li>前一个操作符的后面</li>
</ol>
<p>这样，解析的问题就迎刃而解了。</p>
<pre><code class="language-python">import re
def infix_expression2suffix_expression(infix_expression):
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0, 'u-': 3}
    op_stack = []
    suffix_expression = []
    # 匹配小数，整数和操作符
    tokens = re.findall(r'\d+\.\d+|\d+|[+\-*/()]', infix_expression)
    print(tokens)
  
    for i, token in enumerate(tokens):
        if re.match(r'\d+\.\d+|\d+', token):  # 如果是数字
            suffix_expression.append(token)
        elif token == '(':  # 如果是左括号
            op_stack.append(token)
        elif token == ')':  # 如果是右括号
            while op_stack and op_stack[-1] != '(':
                suffix_expression.append(op_stack.pop())
            op_stack.pop()  # 弹出左括号
        else:  # 如果是操作符
            # 处理负号（负数）,表达式开头，前一个操作符的后面
            if token == '-' and (i == 0 or tokens[i - 1] in "+-*/("):
                token = 'u-'  # 标记为负号
            while op_stack and precedence.get(token, 0) &lt;= precedence.get(op_stack[-1], 0):
                suffix_expression.append(op_stack.pop())
            op_stack.append(token)
    # 弹出操作符栈剩余的操作符添加到后缀表达式
    while op_stack:
        suffix_expression.append(op_stack.pop())
    print("Suffix expression:", " ".join(suffix_expression))
    return " ".join(suffix_expression)

if __name__ == '__main__':
    infix_expression = expression
    suffix_expression = infix_expression2suffix_expression(infix_expression)
    print("Suffix expression:", suffix_expression)
</code></pre>
<hr>
<h3 id="计算后缀表达式的结果">计算后缀表达式的结果</h3>
<p>怎么计算后缀表达式的结果呢？从左到右扫描，遇到数字压入栈，遇到操作符就运算，简单无困扰。</p>
<p>负数的话，只需要取出来计算负号，再压回栈就好了。</p>
<pre><code class="language-python">import re
def evaluate_suffix_expression(suffix_expression):
    stack = []
    tokens = suffix_expression.split()
    print(tokens)
    for token in tokens:
        if re.match(r'\d+\.\d+|\d+', token):
            stack.append(float(token))
        elif token == 'u-':
            stack.append(-stack.pop())
        else:
            operand2 = stack.pop()
            operand1 = stack.pop()
            if token == "+":
                stack.append(operand1 + operand2)
            elif token == "-":
                stack.append(operand1 - operand2)
            elif token == "*":
                stack.append(operand1 * operand2)
            elif token == "/":
                stack.append(operand1 / operand2)
            else:
                raise ValueError("Invalid operator: " + token)
            print(f'{operand1} {token} {operand2} = {stack[-1]}')
    if len(stack) != 1:
        raise ValueError("Invalid expression: " + suffix_expression)
    return stack[0]
if __name__ == "__main__":
    print(evaluate_suffix_expression(infix_expression2suffix_expression(expression)))
</code></pre>
<hr>
<h3 id="计算的整体实现">计算的整体实现</h3>
<p>接下来把上面的实现过程封装在一起，就可以毫无负担地实现计算器了。</p>
<pre><code class="language-python">def evaluate(expression):
    return evaluate_suffix_expression(infix_expression2suffix_expression(expression))
if __name__ == '__main__':
    expression = input("Enter an infix expression: ")
    print(evaluate(expression))
</code></pre>
<hr>
<h2 id="进一步简化">进一步简化</h2>
<p>前面我们做的是，将中缀表达式转换为后缀表达式，再用后缀表达式去计算得到结果，这个过程中都需要用到数字栈和运算符栈两个栈。</p>
<p>那么，我们可以边读边运算吗？当然可以。后缀表达式直接展示了运算的顺序，那么我们得到后缀表达式的过程，其实就是运算的过程。</p>
<pre><code class="language-python">import re

def evaluate_expression(expression):
    def four_rules_eval(sum_stack, op_stack):
        op = op_stack.pop()
        if op == 'u-':
            operand = sum_stack.pop()
            sum_stack.append(-operand)
            print(f'u-{operand} = {sum_stack[-1]}')
        else:
            operand2 = sum_stack.pop()
            operand1 = sum_stack.pop()
            if op == "+":
                sum_stack.append(operand1 + operand2)
            elif op == "-":
                sum_stack.append(operand1 - operand2)
            elif op == "*":
                sum_stack.append(operand1 * operand2)
            elif op == "/":
                sum_stack.append(operand1 / operand2)
            else:
                raise ValueError("Invalid operator: " + op)
            print(f'{operand1} {op} {operand2} = {sum_stack[-1]}')
  
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0, 'u-': 3}
    op_stack = []
    sum_stack = []
    tokens = re.findall(r'\d+\.\d+|\d+|[+\-*/()]', expression)
    print(tokens)
  
    for i, token in enumerate(tokens):
        if re.match(r'\d+\.\d+|\d+', token):  # 如果是数字
            sum_stack.append(float(token))
        elif token == '(':  # 如果是左括号
            op_stack.append(token)
        elif token == ')':  # 如果是右括号
            while op_stack and op_stack[-1] != '(':
                four_rules_eval(sum_stack, op_stack)
            op_stack.pop()  # 弹出左括号
        else:  # 如果是操作符
            # 处理负号（负数）,表达式开头，前一个操作符的后面
            if token == '-' and (i == 0 or tokens[i - 1] in "+-*/("):
                op_stack.append('u-')
            else:
                while op_stack and precedence.get(token, 0) &lt;= precedence.get(op_stack[-1], 0):
                    four_rules_eval(sum_stack, op_stack)
                op_stack.append(token)
    while op_stack:
        four_rules_eval(sum_stack, op_stack)
    return sum_stack[-1]

if __name__ == '__main__':

    expression = "1-2*((60-30+(-40/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))"
    result = evaluate_expression(expression)
    print(result)  # out: 2776672.6952380957
</code></pre>
<hr>
<h2 id="参考资料">参考资料</h2>
<p>前缀表达式、中缀表达式和后缀表达式：<a href="https://www.cnblogs.com/zzliu/p/10801113.html" target="_blank">https://www.cnblogs.com/zzliu/p/10801113.html</a></p>

</div>
<div class="clear"></div>

	</div>
	
	<div class="postfoot">
		posted on 
<span id="post-date" data-last-update-days="0.20240418956828704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-15 17:27">2025-03-15 17:27</span>&nbsp;
<a href="https://www.cnblogs.com/testtraveler">testtraveler</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18773721" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18773721);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18773721', targetLink: 'https://www.cnblogs.com/testtraveler/p/18773721', title: '(Python)用栈实现计算器的原理及实现' })">举报</a>

	</div>
