
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18674812" title="发布于 2025-01-16 13:43">
    <span role="heading" aria-level="2">Java Hutool 实现非对称加密（RSA)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#思路" rel="noopener nofollow">思路</a><ul><li><a href="#生成ras密钥" rel="noopener nofollow">生成RAS密钥</a></li><li><a href="#消息公钥加密私钥解密" rel="noopener nofollow">消息公钥加密、私钥解密</a></li></ul></li><li><a href="#代码demo" rel="noopener nofollow">代码Demo</a><ul><li><a href="#生成-a-的密钥" rel="noopener nofollow">生成 A 的密钥</a></li><li><a href="#生成-b-的密钥" rel="noopener nofollow">生成 B 的密钥</a></li><li><a href="#a-发送消息给-b" rel="noopener nofollow">A 发送消息给 B</a></li><li><a href="#b-解密-a-消息" rel="noopener nofollow">B 解密 A 消息</a></li></ul></li></ul></div><br>
<img src="https://img2024.cnblogs.com/blog/80824/202501/80824-20250116131120505-1730079892.png" alt="image" loading="lazy"><br>
对称加密中，我们只需要一个密钥，通信双方同时持有。而非对称加密需要4个密钥。通信双方各自准备一对公钥和私钥。其中公钥是公开的，由信息接受方提供给信息发送方。公钥用来对信息加密。私钥由信息接受方保留，用来解密。既然公钥是公开的，就不存在保密问题。也就是说非对称加密完全不存在密钥配送问题！<p></p>
<p><font color="red">公钥只能用做数据加密。公钥加密的数据，只能用对应的私钥才能解密。</font></p>
<h2 id="思路">思路</h2>
<h3 id="生成ras密钥">生成RAS密钥</h3>
<ul>
<li>A 生成 A 的 私钥(private_key_A.pem)、公钥(public_key_A.pem)</li>
<li>B 生成 B 的 私钥(private_key_B.pem)、公钥(public_key_B.pem)</li>
<li>A 将公钥(public_key_A.pem) 交给 B</li>
<li>B 将公钥(public_key_B.pem) 交给 A</li>
</ul>
<h3 id="消息公钥加密私钥解密">消息公钥加密、私钥解密</h3>
<p>A 发消息给 B</p>
<ul>
<li>A 用 B 的 公钥(public_key_B.pem)，将消息加密，发给 B</li>
<li>B 收到消息后，用 私钥(private_key_B.pem),将消息进行解密</li>
</ul>
<p>B 发消息给 A</p>
<ul>
<li>B 用 A 的 公钥(public_key_A.pem)，将消息加密，发给 A</li>
<li>A 收到消息后，用 A的私钥(private_key_A.pem),将消息进行解密</li>
</ul>
<h2 id="代码demo">代码Demo</h2>
<pre><code class="language-java">import cn.hutool.core.codec.Base64;
import cn.hutool.core.util.CharsetUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.crypto.SecureUtil;
import cn.hutool.crypto.asymmetric.AsymmetricAlgorithm;
import cn.hutool.crypto.asymmetric.KeyType;
import cn.hutool.crypto.asymmetric.RSA;
import com.alibaba.fastjson.JSON;
import com.thoth.his.base.util.FileUtil;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.HashMap;
import java.util.Map;
</code></pre>
<h3 id="生成-a-的密钥">生成 A 的密钥</h3>
<pre><code class="language-java">/**
 * 生成 A 的公钥、私钥
 */
@Test
public void generateKeyA() {
    KeyPair pair = SecureUtil.generateKeyPair(AsymmetricAlgorithm.RSA.getValue());
    PrivateKey privateKey = pair.getPrivate();
    PublicKey publicKey = pair.getPublic();
    //获得私钥
    String privateKeyStr = Base64.encode(privateKey.getEncoded());
    System.out.println("A私钥：" + privateKeyStr);
    FileUtil.writeString(privateKeyStr, "D:\\RAS\\private_key_A.pem");
    //获得公钥 -- 发给对方
    String publicKeyStr = Base64.encode(publicKey.getEncoded());
    System.out.println("A公钥：" + publicKeyStr);
    FileUtil.writeString(publicKeyStr, "D:\\RAS\\public_key_A.pem");
}
</code></pre>
<h3 id="生成-b-的密钥">生成 B 的密钥</h3>
<pre><code class="language-java">/**
 * 生成 B 的公钥、私钥
 */
@Test
public void generateKeyB() {
    KeyPair pair = SecureUtil.generateKeyPair(AsymmetricAlgorithm.RSA.getValue());
    PrivateKey privateKey = pair.getPrivate();
    PublicKey publicKey = pair.getPublic();
    //获得私钥
    String privateKeyStr = Base64.encode(privateKey.getEncoded());
    System.out.println("B私钥：" + privateKeyStr);
    FileUtil.writeString(privateKeyStr, "D:\\RAS\\private_key_B.pem");
    //获得公钥 -- 发给对方
    String publicKeyStr = Base64.encode(publicKey.getEncoded());
    System.out.println("B公钥：" + publicKeyStr);
    FileUtil.writeString(publicKeyStr, "D:\\RAS\\public_key_B.pem");
}
</code></pre>
<h3 id="a-发送消息给-b">A 发送消息给 B</h3>
<pre><code class="language-java">/**
 * A 发消息给B ，用 B 的公钥进行加密
 */
@Test
public void sendMsg() {
    String privateKeyStr = FileUtil.readUtf8String("D:\\RAS\\private_key_A.pem");
    String publicKeyStr = FileUtil.readUtf8String("D:\\RAS\\public_key_B.pem");
    RSA rsa = new RSA(privateKeyStr, publicKeyStr);
    System.out.println(rsa);

    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put("Name", "张三");
    map.put("Age", "30");
    String json = JSON.toJSONString(map);
    //公钥加密，私钥解密
    byte[] encrypt = rsa.encrypt(StrUtil.bytes(json, CharsetUtil.CHARSET_UTF_8), KeyType.PublicKey);
    String msg = Base64.encode(encrypt);
    //将消息存文件，模拟HTTP传送，供B去解密
    FileUtil.writeString(msg, "D:\\RAS\\msg_A.txt");
    System.out.println("A 公钥加密后的内容：" + msg);
}
</code></pre>
<h3 id="b-解密-a-消息">B 解密 A 消息</h3>
<pre><code class="language-java">/**
 * B 收到 A 的消息，用 B 的私钥进行解密
 */
@Test
public void receiveMsg() {
    String privateKeyStr = FileUtil.readUtf8String("D:\\RAS\\private_key_B.pem");
    String publicKeyStr = FileUtil.readUtf8String("D:\\RAS\\public_key_A.pem");
    //RSA rsa = new RSA(privateKeyStr, publicKeyStr);
    RSA rsa = new RSA(privateKeyStr, null); //单纯解密的话，可以不需要 A 的公钥
    String msgAStr = FileUtil.readUtf8String("D:\\RAS\\msg_A.txt");
    byte[] decrypt = rsa.decrypt(msgAStr, KeyType.PrivateKey);
    //把解密的结果转换成String字符串输出
    System.out.println("私钥解密：" + StrUtil.str(decrypt, StandardCharsets.UTF_8));
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/80824/202501/80824-20250116133706957-1199041976.png" alt="image" loading="lazy"></p>
<p><span style="display: none">参考：<a href="https://zhuanlan.zhihu.com/p/436455172" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/436455172</a></span></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18674812" target="_blank">https://www.cnblogs.com/vipsoft/p/18674812</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.39192467460069447" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 16:59">2025-01-16 13:43</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">175</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18674812" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18674812);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18674812', targetLink: 'https://www.cnblogs.com/vipsoft/p/18674812', title: 'Java Hutool 实现非对称加密（RSA)' })">举报</a>
</div>
        