
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ask-tang/p/18928037" title="发布于 2025-06-14 10:37">
    <span role="heading" aria-level="2">[GESP样题 七级] 最长不下降子序列题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://www.luogu.com.cn/problem/P10287" target="_blank" rel="noopener nofollow">题目传送门</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个有向图无环图<span class="math inline">\(G\)</span>，在这个图中寻找一条路径，是这条路径上的点权所组成的序列的最长不下降子序列的长度最长。</p>
<h2 id="思路部分">思路部分</h2>
<h3 id="解决无后效性">解决无后效性</h3>
<p>求一个有向无环图中的最长不下降子序列，不难想到这应该是一个图上dp，而在一个图中我们没法保证编号<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>去计算一定是满足了无后效性的，所以我们考虑找到一个顺序，这个顺序满足无后效性。</p>
<p>而在有向无环图中寻找一个序列，这个序列满足对于任意<span class="math inline">\(i(1≤i≤n)\)</span>，小于<span class="math inline">\(i\)</span>的所有节点都在<span class="math inline">\(i\)</span>的左边（或一样），大于<span class="math inline">\(i\)</span>的所有节点都在<span class="math inline">\(i\)</span>的右边（或一样）。</p>
<p>根据上述定义，不难看出这是这个有向图的拓扑序列。拓扑序的求法如下：</p>
<ol>
<li>找到入度为<span class="math inline">\(0\)</span>的点，入队。</li>
<li>重复执行直到队列为空，从队首取出一个元素<span class="math inline">\(u\)</span>，枚举这个点能够到达的点<span class="math inline">\(v\)</span>，把点<span class="math inline">\(v\)</span>的入度减一，判断如果点<span class="math inline">\(v\)</span>的入度为0，那么入队。</li>
</ol>
<p>在求拓扑序时，已经满足了无后效性这个条件，所以我们直接在这个过程中对答案求解。</p>
<h3 id="解决动态规划">解决动态规划</h3>
<p>接着，我们讨论该如何对答案进行求解。<br>
考虑在线性元素中对最长不下降子序列求解的定义为：以第<span class="math inline">\(i\)</span>个元素为结尾的最长长度。那么我们是否能再次运用这个定义呢？</p>
<p>答案是<strong>肯定不行</strong>。第一：时间复杂度接受不了<span class="math inline">\(o(N^2)\)</span>会炸。第二：我们无法知道以更加前面的节点为结尾的最长长度。<br>
那么我们该如何求解呢？</p>
<p>根据数据范围可知，虽然点和边的数量很大，但是每个节点的点权很小，最大也就才<span class="math inline">\(10\)</span>。所以我们可以想出以节点<span class="math inline">\(i\)</span>，点权为<span class="math inline">\(j\)</span>结尾的最长子序列。这时，我们不需要直到之前的节点了，只需要枚举颜色是什么即可。而转移方程类似于背包，代码入下：</p>
<pre><code class="language-cpp">for(int i = 1; i &lt;= n; i++)
		if(!in[i]){//寻找入度为0的点
			q.push(i);
			f[i][a[i]] = 1;//对dp数组初始化
		}
			
	while(!q.empty()){//寻找拓扑序
		int x = q.front(); q.pop();//队首出队
		
		for(auto y : mp[x]){//枚举它能到达的点
			for(int i = 1; i &lt;= 10; i++){
				f[y][i] = max(f[y][i], f[x][i]);//直接转移
				if(a[y] &gt;= i) //如果我的点权大于等于i，那我就可以把长度增加以（在f[x][i]的基础上）
					f[y][a[y]] = max(f[y][a[y]], f[x][i] + 1);//更新
			}
			
			if(-- in[y] == 0)//寻找入度为0的点，入队
				q.push(y);
		}
	}
</code></pre>
<p>这就是这个题的核心代码，读者看到这就可以自行实现一下了！但如果还是不会，那么完整代码入下。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10, A = 20;
int n, m, f[N][A], ans, in[N], a[N];
vector &lt;int&gt; mp[N];
queue &lt;int&gt; q;

int main(){
	scanf("%d %d", &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]);
	
	while(m --){
		int u, v; scanf("%d %d", &amp;u, &amp;v);
		
		mp[u].push_back(v);
		in[v] ++;
	}
	
	for(int i = 1; i &lt;= n; i++)
		if(!in[i]){
			q.push(i);
			f[i][a[i]] = 1;
		}
			
	while(!q.empty()){
		int x = q.front(); q.pop();
	
		
		for(auto y : mp[x]){
			for(int i = 1; i &lt;= 10; i++){
				f[y][i] = max(f[y][i], f[x][i]);
				if(a[y] &gt;= i) 
					f[y][a[y]] = max(f[y][a[y]], f[x][i] + 1);
			}
			
			if(-- in[y] == 0)
				q.push(y);
		}
	}
	
	
	for(int i = 1; i &lt;= n; i++)
		for(int j = 1; j &lt;= 10; j++)
			ans = max(ans, f[i][j]);
	printf("%d\n", ans);
	return 0;
}

</code></pre>
<h1 id="点个关注再走吧求求了qwq">点个关注再走吧~求求了qwq</h1>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-14 10:38">2025-06-14 10:37</span>&nbsp;
<a href="https://www.cnblogs.com/ask-tang">Ryan_L_F</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18928037);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18928037', targetLink: 'https://www.cnblogs.com/ask-tang/p/18928037', title: '[GESP样题 七级] 最长不下降子序列题解' })">举报</a>
</div>
        