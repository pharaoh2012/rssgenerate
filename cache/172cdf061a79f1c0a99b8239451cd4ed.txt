
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/czwy/p/18726159" title="发布于 2025-02-20 11:02">
    <span role="heading" aria-level="2">RFID实践——.NET IoT程序读取高频RFID卡/标签</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这篇文章是一份RFID实践的保姆级教程，将详细介绍如何用 Raspberry Pi 连接 PN5180 模块，并开发 .NET IoT 程序读写ISO14443 和 ISO15693协议的卡/标签。</p>
<h2 id="设备清单">设备清单</h2>
<ul>
<li>Raspberry Pi必需套件（主板、电源、TF卡）</li>
<li>PN5180</li>
<li>ISO15693标签</li>
<li>杜邦线</li>
<li>面包板&nbsp;(&nbsp;可选)</li>
<li>GPIO扩展板&nbsp;(可选&nbsp;)<br>
本文中用到的树莓派型号是 Raspberry Pi Zero 2 W，电源直接使用充电宝替代（官方电源是5.1V / 2.5A DC）。<br>
<a href="https://www.cnblogs.com/czwy/p/18711409" target="_blank">RFID基础——高频RFID协议、读写模块和标签</a>中介绍过 PN5180 是一款价格便宜且支持全部高频 RFID 协议的读写模块。网购 PN5180 模块时通常会送一张ICODE SLIX卡和 Mifare S50 卡。<br>
ISO15693标签选用的是国产的复旦微电子芯片的标签。额外购买是为了测试多张标签同时在射频场中防碰撞功能。<br>
杜邦线用于连接  Raspberry Pi Zero 2 W 和 PN5180 模块。GPIO扩展板会标注逻辑引脚，配合面包板使用，方便连接多种传感器。</li>
</ul>
<h2 id="树莓派连接-pn5180">树莓派连接 PN5180</h2>
<p>在 PN5180 上，您会注意到它上有13个引脚，这些引脚中只有9个是需要连接到树莓派的GPIO引脚。对应关系如下表所示。表中特意标注出逻辑引脚和物理引脚，是因为后边程序中需要设置引脚编号。详情在后续代码部分会进行解释。</p>
<table>
<thead>
<tr>
<th>NXP5180</th>
<th>逻辑引脚</th>
<th>物理引脚</th>
</tr>
</thead>
<tbody>
<tr>
<td>+5V</td>
<td>5V</td>
<td>2</td>
</tr>
<tr>
<td>+3.3V</td>
<td>3V3</td>
<td>1</td>
</tr>
<tr>
<td>RST</td>
<td>GPIO4(<em>GPCLK0</em>)</td>
<td>7</td>
</tr>
<tr>
<td>NSS</td>
<td>GPIO3(<em>SCL</em>)</td>
<td>5</td>
</tr>
<tr>
<td>MOSI</td>
<td>GPIO10(<em>SPI0-MOSI</em>)</td>
<td>19</td>
</tr>
<tr>
<td>MISO</td>
<td>GPIO9(<em>SPI0-MISO</em>)</td>
<td>21</td>
</tr>
<tr>
<td>SCK</td>
<td>GPIO11(<em>SPI0-SCLK</em>)</td>
<td>23</td>
</tr>
<tr>
<td>BUSY</td>
<td>GPIO2(<em>SDA</em>)</td>
<td>3</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
<td>9</td>
</tr>
<tr>
<td>GPIO</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>IRQ</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>AUX</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>REQ</td>
<td>-</td>
<td></td>
</tr>
</tbody>
</table>
<p>下图灰色区域中 1~40 是物理引脚编号，两侧标注的是逻辑引脚，例如物理引脚编号3的标注是 GPIO2 ，也就是对应的逻辑引脚编号为2。<br>
<img src="https://learn.microsoft.com/zh-cn/dotnet/iot/media/gpio-pinout-diagram.png#lightbox" alt="gpio-pinout-diagram.png (1881×1080)" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3056716/202502/3056716-20250220105250555-1456039128.jpg" alt="image" width="351" loading="lazy"></p>
<p>到了这里，准备工作已经完成，接下来就是编码了。</p>
<h2 id="编写net-iot程序">编写.NET IoT程序</h2>
<p>.NET IoT库中已经实现了 PN5180 的部分功能。比如轮询 ISO14443-A 和 ISO14443-B 类型的卡，以及对它们的读写操作，但是没有实现对 ISO15693 协议卡的支持。<br>
PN5180通过SPI和GPIO进行工作，它以特定的方式通过GPIO使用SPI进行通信。这就需要手动管理SPI的引脚选择，<code>Busy</code> 引脚用于了解 PN5180 什么时候可以接收和发送信息。<br>
首先，引用- <a href="https://www.nuget.org/packages/System.Device.Gpio/" target="_blank" rel="noopener nofollow">System.Device.Gpio</a>和 <a href="https://www.nuget.org/packages/Iot.Device.Bindings/" target="_blank" rel="noopener nofollow">Iot.Device.Bindings</a>两个包，然后用下面的代码创建SPI驱动程序、重置 PN5180 和创建 PN5180 实例。</p>
<pre><code class="language-csharp">var spi = SpiDevice.Create(new SpiConnectionSettings(0, 1) { ClockFrequency = Pn5180.MaximumSpiClockFrequency, Mode = Pn5180.DefaultSpiMode, DataFlow = DataFlow.MsbFirst });

// Reset the device
var gpioController = new GpioController();
gpioController.OpenPin(4, PinMode.Output);
gpioController.Write(4, PinValue.Low);
Thread.Sleep(10);
gpioController.Write(4, PinValue.High);
Thread.Sleep(10);

var pn5180 = new Pn5180(spi, 2, 3);
</code></pre>
<p>第1行代码创建 <code>SpiDevice</code> 实例，其中设置 <code>DataFlow = DataFlow.MsbFirst</code> ，即首先发送最高有效位。需要注意的是，这里指的是主机与 PN5180 模块之间的 SPI 总线的传输顺序，<a href="https://www.cnblogs.com/czwy/p/18721249" target="_blank">RFID基础——ISO15693标签存储结构及访问控制命令说明</a>中协议规定首先传输最低有效位指的是 VCD 与 VICC 之间的射频通信，两者是不同的数据传输过程。</p>
<p>第4行代码创建 <code>GpioController</code> 实例，<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.device.gpio.gpiocontroller?view=iot-dotnet-latest" target="_blank" rel="noopener nofollow">GpioController 类</a> 的无参构造函数使用逻辑引脚编号方案作为默认方案。</p>
<p>第5行代码开启编号4的引脚，这个编号也就是指的逻辑引脚编号 GPIO4。</p>
<p>第11行创建 PN5180 读写器实例。构造函数定义如下：</p>
<pre><code class="language-csharp">public Pn5180 (System.Device.Spi.SpiDevice spiDevice, int pinBusy, int pinNss, System.Device.Gpio.GpioController? gpioController = default, bool shouldDispose = true);
</code></pre>
<p>第一个参数是 spi 设备实例，第二个参数是 <code>Busy</code> 引脚编号，第三个参数是 <code>Nss</code> 引脚编号，这里都是指的逻辑编号。代码中的参数需和前面引脚对应表中指定的一致。</p>
<h3 id="访问iso14443协议卡">访问ISO14443协议卡</h3>
<p>访问ISO14443协议卡比较简单，调用 <code>ListenToCardIso14443TypeA</code>,&nbsp;<code>ListenToCardIso14443TypeB</code> 轮询射频场中的 PICC，然后选中卡进行操作，下边是监听 ISO14443-A 和 ISO14443-B 类型卡的示例代码：</p>
<pre><code class="language-csharp">do
{
   if (pn5180.ListenToCardIso14443TypeA(TransmitterRadioFrequencyConfiguration.Iso14443A_Nfc_PI_106_106, ReceiverRadioFrequencyConfiguration.Iso14443A_Nfc_PI_106_106, out Data106kbpsTypeA? cardTypeA, 1000))
   {
	   Console.WriteLine($"ISO 14443 Type A found:");
	   Console.WriteLine($"  ATQA: {cardTypeA.Atqa}");
	   Console.WriteLine($"  SAK: {cardTypeA.Sak}");
	   Console.WriteLine($"  UID: {BitConverter.ToString(cardTypeA.NfcId)}");
   }
   else
   {
	   Console.WriteLine($"{nameof(cardTypeA)} is not configured correctly.");
   }

   if (pn5180.ListenToCardIso14443TypeB(TransmitterRadioFrequencyConfiguration.Iso14443B_106, ReceiverRadioFrequencyConfiguration.Iso14443B_106, out Data106kbpsTypeB? card, 1000))
   {
	   Console.WriteLine($"ISO 14443 Type B found:");
	   Console.WriteLine($"  Target number: {card.TargetNumber}");
	   Console.WriteLine($"  App data: {BitConverter.ToString(card.ApplicationData)}");
	   Console.WriteLine($"  App type: {card.ApplicationType}");
	   Console.WriteLine($"  UID: {BitConverter.ToString(card.NfcId)}");
	   Console.WriteLine($"  Bit rates: {card.BitRates}");
	   Console.WriteLine($"  Cid support: {card.CidSupported}");
	   Console.WriteLine($"  Command: {card.Command}");
	   Console.WriteLine($"  Frame timing: {card.FrameWaitingTime}");
	   Console.WriteLine($"  Iso 14443-4 compliance: {card.ISO14443_4Compliance}");
	   Console.WriteLine($"  Max frame size: {card.MaxFrameSize}");
	   Console.WriteLine($"  Nad support: {card.NadSupported}");
   }
   else
   {
	   Console.WriteLine($"{nameof(card)} is not configured correctly.");
   }
}
while (!Console.KeyAvailable);
</code></pre>
<p>有关 ISO14443协议的更多操作可以查看<code>Iot.Device.Bindings</code>中 PN5180 的文档<a href="https://github.com/dotnet/iot/tree/main/src/devices/Pn5180" target="_blank" rel="noopener nofollow">iot/src/devices/Pn5180 at main · dotnet/iot</a>。</p>
<h3 id="访问iso15693协议卡">访问ISO15693协议卡</h3>
<p>由于<code>Iot.Device.Bindings</code>中的 PN5180 并没有实现对 ISO15693协议的支持，因此需要自行实现这部分功能。</p>
<p>PN5180 模块的工作原理可以简单的理解为主机向 PN5180 模块发送开启、配置射频场、操作卡/标签（VICC）的命令，PN5180 模块接收到操作卡/标签（VICC）的命令时，通过射频信号与卡/标签（VICC）进行数据交互。寻卡过程的步骤如下：</p>
<ol>
<li>加载ISO 15693协议到RF寄存器</li>
<li>开启射频场</li>
<li>清除中断寄存器IRQ_STATUS</li>
<li>把PN5180设置为IDLE状态</li>
<li>激活收发程序</li>
<li>向卡/标签（VICC）发送16时隙防冲突的寻卡指令</li>
<li>循环16次以下操作
<ol>
<li>读取RX_STATUS寄存器，判断是否有卡/标签响应</li>
<li>如果有响应，发送读卡指令然后读取卡的响应</li>
<li>在下一次射频通信中只发送EOF（帧结束）而不发送数据。</li>
<li>把PN5180设置为IDLE状态</li>
<li>激活收发程序</li>
<li>清除中断寄存器IRQ_STATUS</li>
<li>向卡/标签（VICC）发送EOF（帧结束）</li>
</ol>
</li>
<li>关闭射频场<br>
上述步骤中只有步骤6<code>向卡/标签（VICC）发送16时隙防冲突的寻卡指令</code>和步骤7.7<code>向卡/标签（VICC）发送EOF（帧结束）</code>是 PN5180 和卡/标签（VICC）之间的数据交互，其余的步骤都是PN5180 与主机之间通过SPI通信。</li>
</ol>
<h4 id="pn5180与主机通信">PN5180与主机通信</h4>
<p>PN5180设计了24个主机接口命令，涉及读写寄存器、读写EEPROM、写数据到发送缓冲区，从接收缓冲区读数据，加载RF配置到寄存器，开启关闭射频场。包含44个寄存器，它们控制着PN5180处理器的行为。每个寄存器占4个字节。主机处理器可以通过4个不同的命令改变寄存器的值：<code>write_register</code>、 <code>write_register_and_mask</code>、 <code>write_register_or_mask</code>、<code>write_register_multiple</code>。<br>
以下是本文中用到的主机接口命令说明：</p>
<h5 id="write_register">write_register</h5>
<p>这个命令将一个32位的值写入配置寄存器。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x00</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>寄存器地址</td>
</tr>
<tr>
<td>参数</td>
<td>4</td>
<td>寄存器内容</td>
</tr>
</tbody>
</table>
<h5 id="write_register_or_mask">WRITE_REGISTER_OR_MASK</h5>
<p>该命令使用逻辑或操作修改寄存器的内容。先读取寄存器的内容，并使用提供的掩码执行逻辑或操作，然后把修改后的内容写回寄存器。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x01</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>寄存器地址</td>
</tr>
<tr>
<td>参数</td>
<td>4</td>
<td>逻辑或操作的掩码</td>
</tr>
</tbody>
</table>
<h5 id="write_register_and_mask">WRITE_REGISTER_AND_MASK</h5>
<p>该命令使用逻辑与操作修改寄存器的内容。先读取寄存器的内容，并使用提供的掩码执行逻辑与操作，然后把修改后的内容写回寄存器。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x02</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>寄存器地址</td>
</tr>
<tr>
<td>参数</td>
<td>4</td>
<td>逻辑与操作的掩码</td>
</tr>
</tbody>
</table>
<h5 id="load_rf_config">LOAD_RF_CONFIG</h5>
<p>该命令用于将射频配置从EEPROM加载到配置寄存器中。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x11</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>发送器配置的值</td>
</tr>
<tr>
<td>写入的数据</td>
<td>1</td>
<td>接收机配置的值</td>
</tr>
</tbody>
</table>
<h5 id="rf_on">RF_ON</h5>
<p>该命令打开内部射频场。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x16</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>1,根据 ISO/IEC 18092 禁用冲突避免</td>
</tr>
</tbody>
</table>
<h5 id="rf_off">RF_OFF</h5>
<p>该命令关闭内部射频场</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x17</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>虚字节</td>
</tr>
</tbody>
</table>
<h4 id="pn5180和卡标签vicc数据交互">PN5180和卡/标签（VICC）数据交互</h4>
<p>PN5180和卡/标签（VICC）数据交互本质上也是主机发送命令给 PN5180 模块，然后 PN5180 把数据写入缓冲区，接着射频传输给卡/标签（VICC），卡/标签（VICC）响应后通过射频传出给 PN5180 模块的接收缓冲区，主机发送命令读取缓冲区数据。</p>
<h5 id="send_data">SEND_DATA</h5>
<p>该命令将数据写入射频传输缓冲区，开始射频传输。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x09</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>最后一个字节的有效位数</td>
</tr>
<tr>
<td>写入的数据</td>
<td>1~260</td>
<td>最大长度为260的数组</td>
</tr>
</tbody>
</table>
<p>最后一个字节的有效位数为0表示最后一字节所有的bit都被传输，1~7表示要传输的最后一个字节内的位数。</p>
<h5 id="read_data">READ_DATA</h5>
<p>从VICC成功接收数据后，该命令从射频接收缓冲区读取数据。</p>
<table>
<thead>
<tr>
<th>负载</th>
<th>长度</th>
<th>值/描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令编码</td>
<td>1</td>
<td>0x0A</td>
</tr>
<tr>
<td>参数</td>
<td>1</td>
<td>0x00</td>
</tr>
<tr>
<td>读取的数据</td>
<td>1~508</td>
<td>最大长度为508的数组</td>
</tr>
</tbody>
</table>
<h4 id="代码实现轮询iso15693卡">代码实现轮询ISO15693卡</h4>
<p>PN5180 和卡/标签（VICC）之间的数据交互都是遵循<a href="https://www.cnblogs.com/czwy/p/18721249" target="_blank">RFID基础——ISO15693标签存储结构及访问控制命令说明</a>中的命令。只需用代码实现 PN5180 的主机接口指令以及ISO15693的访问控制命令即可。首先Fork <a href="https://github.com/dotnet/iot" target="_blank" rel="noopener nofollow">dotnet/iot</a>版本库，然后在 <code>Pn5180.cs</code>中加入以下监听 ISO15693 协议卡的代码：</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Listen to 15693 cards with 16 slots
/// &lt;/summary&gt;
/// &lt;param name="transmitter"&gt;The transmitter configuration, should be compatible with 15693 card&lt;/param&gt;
/// &lt;param name="receiver"&gt;The receiver configuration, should be compatible with 15693 card&lt;/param&gt;
/// &lt;param name="cards"&gt;The 15693 cards once detected&lt;/param&gt;
/// &lt;param name="timeoutPollingMilliseconds"&gt;The time to poll the card in milliseconds. Card detection will stop once the detection time will be over&lt;/param&gt;
/// &lt;returns&gt;True if a 15693 card has been detected&lt;/returns&gt;
public bool ListenToCardIso15693(TransmitterRadioFrequencyConfiguration transmitter, ReceiverRadioFrequencyConfiguration receiver,
#if NET5_0_OR_GREATER
[NotNullWhen(true)]
#endif
out IList&lt;Data26_53kbps&gt;? cards, int timeoutPollingMilliseconds)
{
	cards = new List&lt;Data26_53kbps&gt;();
	var ret = LoadRadioFrequencyConfiguration(transmitter, receiver);
	// Switch on the radio frequence field and check it
	ret &amp;= SetRadioFrequency(true);

	Span&lt;byte&gt; inventoryResponse = stackalloc byte[10];
	Span&lt;byte&gt; dsfid = stackalloc byte[1];
	Span&lt;byte&gt; uid = stackalloc byte[8];

	int numBytes = 0;

	DateTime dtTimeout = DateTime.Now.AddMilliseconds(timeoutPollingMilliseconds);

	try
	{
		// Clears all interrupt
		SpiWriteRegister(Command.WRITE_REGISTER, Register.IRQ_CLEAR, new byte[] { 0xFF, 0xFF, 0x0F, 0x00 });
		// Sets the PN5180 into IDLE state
		SpiWriteRegister(Command.WRITE_REGISTER_AND_MASK, Register.SYSTEM_CONFIG, new byte[] { 0xF8, 0xFF, 0xFF, 0xFF });
		// Activates TRANSCEIVE routine
		SpiWriteRegister(Command.WRITE_REGISTER_OR_MASK, Register.SYSTEM_CONFIG, new byte[] { 0x03, 0x00, 0x00, 0x00 });
		// Sends an inventory command with 16 slots
		ret = SendDataToCard(new byte[] { 0x06, 0x01, 0x00 });
		if (dtTimeout &lt; DateTime.Now)
		{
			return false;
		}

		for (byte slotCounter = 0; slotCounter &lt; 16; slotCounter++)
		{
			(numBytes, _) = GetNumberOfBytesReceivedAndValidBits();
			if (numBytes &gt; 0)
			{
				ret &amp;= ReadDataFromCard(inventoryResponse, inventoryResponse.Length);
				if (ret)
				{
					cards.Add(new Data26_53kbps(slotCounter, 0, 0, inventoryResponse[1], inventoryResponse.Slice(2, 8).ToArray()));
				}
			}

			// Send only EOF (End of Frame) without data at the next RF communication
			SpiWriteRegister(Command.WRITE_REGISTER_AND_MASK, Register.TX_CONFIG, new byte[] { 0x3F, 0xFB, 0xFF, 0xFF });
			// Sets the PN5180 into IDLE state
			SpiWriteRegister(Command.WRITE_REGISTER_AND_MASK, Register.SYSTEM_CONFIG, new byte[] { 0xF8, 0xFF, 0xFF, 0xFF });
			// Activates TRANSCEIVE routine
			SpiWriteRegister(Command.WRITE_REGISTER_OR_MASK, Register.SYSTEM_CONFIG, new byte[] { 0x03, 0x00, 0x00, 0x00 });
			// Clears the interrupt register IRQ_STATUS
			SpiWriteRegister(Command.WRITE_REGISTER, Register.IRQ_CLEAR, new byte[] { 0xFF, 0xFF, 0x0F, 0x00 });
			// Send EOF
			SendDataToCard(new Span&lt;byte&gt; { });
		}

		if (cards.Count &gt; 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	catch (TimeoutException)
	{
		return false;
	}
}
</code></pre>
<p>需要注意的是，寻卡指令<code>SendDataToCard(new byte[] { 0x06, 0x01, 0x00 })</code>发送的数据只有请求标志、命令、掩码长度，并没有CRC校验码，我推测是 PN5180 m模块内部进行了CRC校验，目前并没有找到相关资料证实这个猜测。同样，用 PN5180 读写标签数据块以及其他访问控制指令也不需要CRC校验码。</p>
<h4 id="读写iso15693协议卡">读写ISO15693协议卡</h4>
<p>由于支持 ISO15693 协议的读写器不只是 PN5180 ，因此把对 ISO15693 协议卡的具体读写操作放在 PN5180 的实现类中不太合适。这里定义了一个 <code>IcodeCard</code> 的类型，该类实现了 ISO15693 协议中常用的命令，并在构造函数中注入 RFID 读写器。执行指定操作时，调用 RFID 读写器的 <code>Transceive</code> 方法传输请求指令并接收响应进行处理。以下是主要代码：</p>
<pre><code class="language-csharp">public class IcodeCard
{
	public IcodeCard(CardTransceiver rfid, byte target)
	{
		_rfid = rfid;
		Target = target;
		_logger = this.GetCurrentClassLogger();
	}
	
	/// &lt;summary&gt;
	/// Run the last setup command. In case of reading bytes, they are automatically pushed into the Data property
	/// &lt;/summary&gt;
	/// &lt;returns&gt;-1 if the process fails otherwise the number of bytes read&lt;/returns&gt;
	private int RunIcodeCardCommand()
	{
		byte[] requestData = Serialize();
		byte[] dataOut = new byte[_responseSize];

		var ret = _rfid.Transceive(Target, requestData, dataOut.AsSpan(), NfcProtocol.Iso15693);
		_logger.LogDebug($"{nameof(RunIcodeCardCommand)}: {_command}, Target: {Target}, Data: {BitConverter.ToString(requestData)}, Success: {ret}, Dataout: {BitConverter.ToString(dataOut)}");
		if (ret &gt; 0)
		{
			Data = dataOut;
		}

		return ret;
	}

	/// &lt;summary&gt;
	/// Serialize request data according to the protocol
	/// Request format: SOF, Flags, Command code, Parameters (opt.), Data (opt.), CRC16, EOF
	/// &lt;/summary&gt;
	/// &lt;returns&gt;The serialized bits&lt;/returns&gt;
	private byte[] Serialize()
	{
		byte[]? ser = null;
		switch (_command)
		{
			case IcodeCardCommand.ReadSingleBlock:
				// Flags(1 byte), Command code(1 byte), UID(8 byte), BlockNumber(1 byte)
				ser = new byte[2 + 8 + 1];
				ser[0] = 0x22;
				ser[1] = (byte)_command;
				ser[10] = BlockNumber;
				Uid?.CopyTo(ser, 2);
				_responseSize = 5;
				return ser;
			// 略去代码....
			default:
				return new byte[0];
		}
	}

	/// &lt;summary&gt;
	/// Perform a read and place the result into the 4 bytes Data property on a specific block
	/// &lt;/summary&gt;
	/// &lt;param name="block"&gt;The block number to read&lt;/param&gt;
	/// &lt;returns&gt;True if success. This only means whether the communication between VCD and VICC is successful or not &lt;/returns&gt;
	public bool ReadSingleBlock(byte block)
	{
	    BlockNumber = block;
	    _command = IcodeCardCommand.ReadSingleBlock;
	    var ret = RunIcodeCardCommand();
	    return ret &gt;= 0;
	}
}
</code></pre>
<p>只需以下代码就可以监听射频场中的 ISO15693 类型的卡并进行读写操作：</p>
<pre><code class="language-csharp">if (pn5180.ListenToCardIso15693(TransmitterRadioFrequencyConfiguration.Iso15693_ASK100_26, ReceiverRadioFrequencyConfiguration.Iso15693_26, out IList&lt;Data26_53kbps&gt;? cards, 20000))
{
    pn5180.ResetPN5180Configuration(TransmitterRadioFrequencyConfiguration.Iso15693_ASK100_26, ReceiverRadioFrequencyConfiguration.Iso15693_26);
    foreach (Data26_53kbps card in cards)
    {
        Console.WriteLine($"Target number: {card.TargetNumber}");
        Console.WriteLine($"UID: {BitConverter.ToString(card.NfcId)}");
        Console.WriteLine($"DSFID: {card.Dsfid}");
        if (card.NfcId[6] == 0x04)
{
    IcodeCard icodeCard = new IcodeCard(pn5180, card.TargetNumber)
    {
        Afi = 1,
        Dsfid= 1,
        Uid = card.NfcId,
        Capacity = IcodeCardCapacity.IcodeSlix,
    };
    
    for (byte i = 0; i &lt; 28; i++)
    {
        if (icodeCard.ReadSingleBlock(i))
        {
            Console.WriteLine($"Block {i} data is :{BitConverter.ToString(icodeCard.Data)}");
        }
        else
        {
            icodeCard.Data = new byte[] { };
        }
    }
}
else
{
    Console.WriteLine("Only Icode cards are supported");
}
    }
}
</code></pre>
<p>最后，就是把程序部署到 Raspberry pi 上，具体操作可以参照 <a href="https://www.cnblogs.com/czwy/p/18641846" title="发布于 2024-12-30 17:43" target="_blank">Raspberry pi 上部署调试.Net的IoT程序</a>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.113163289114583" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-21 09:36">2025-02-20 11:02</span>&nbsp;
<a href="https://www.cnblogs.com/czwy">czwy</a>&nbsp;
阅读(<span id="post_view_count">699</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18726159" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18726159);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18726159', targetLink: 'https://www.cnblogs.com/czwy/p/18726159', title: 'RFID实践——.NET IoT程序读取高频RFID卡/标签' })">举报</a>
</div>
        