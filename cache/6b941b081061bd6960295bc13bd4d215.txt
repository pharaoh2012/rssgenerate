
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18731902" title="发布于 2025-02-23 10:48">
    <span role="heading" aria-level="2">Svelte 最新中文文档教程（17）—— 生命周期钩子</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>Svelte，一个语法简洁、入门容易，面向未来的前端框架。从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://yayujs-blog.oss-cn-beijing.aliyuncs.com/405488775-48df16b1-939c-489b-8d52-6071869893f0.png" alt="image.png" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目，也是我做个人项目的首选技术栈。</strong></p>
<p>目前 Svelte 基于 Svelte 5 发布了最新的官方文档，但却缺少对应的中文文档。为了帮助大家学习 Svelte，为爱发电翻译了官方文档。</p>
<p>我同时搭建了 Svelte 最新的中文文档站点：<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">https://svelte.yayujs.com</a> ，如果需要辅助学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>虽说是翻译，但个人并不喜欢严格遵守原文，为了保证中文阅读流畅，会删减部分语句，对难懂的部分也会另做补充解释，希望能给大家带来一个好的中文学习体验。</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上前端大佬成长之路。</p>
<h2 id="生命周期钩子">生命周期钩子</h2>
<p>在 Svelte 5 中，组件生命周期仅由两部分组成：创建和销毁。中间的一切，比如当某些状态更新时，与整个组件无关，只有需要对状态变化做出响应的部分才会得到通知。</p>
<p>这是因为在底层，变化的最小单位实际上并不是组件，而是组件在初始化时设置的（渲染）effects。因此，不存在"更新前"/"更新后"这样的钩子。</p>
<h2 id="onmount"><code>onMount</code></h2>
<p><code>onMount</code> 函数传入一个回调函数，在组件挂载到 DOM 后立即运行。它必须在组件初始化期间被调用（但不需要位于组件内部；可以从外部模块调用）。</p>
<p><code>onMount</code> 不会在服务端渲染的组件中运行。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { onMount } from 'svelte';

  onMount(() =&gt; {
    console.log('组件已挂载');
  });
&lt;/script&gt;
</code></pre>
<p>如果 <code>onMount</code> 返回一个函数，它将在组件卸载时被调用。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { onMount } from 'svelte';

  onMount(() =&gt; {
    const interval = setInterval(() =&gt; {
      console.log('beep');
    }, 1000);

    return () =&gt; clearInterval(interval);
  });
&lt;/script&gt;
</code></pre>
<blockquote>
<p>[!NOTE] 这种行为只在传递给 <code>onMount</code> 的函数同步返回值时才有效。<code>async</code> 函数总是返回一个 <code>Promise</code>，因此不能同步返回一个函数。</p>
</blockquote>
<h2 id="ondestroy"><code>onDestroy</code></h2>
<p>安排一个回调在组件卸载前立即运行。</p>
<div class="ts-block">
```dts
function onDestroy(fn: () =&gt; any): void;
```
</div>
<p>在 <code>onMount</code>、<code>beforeUpdate</code>、<code>afterUpdate</code> 和 <code>onDestroy</code> 中，这是唯一一个在服务端组件内运行的。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { onDestroy } from 'svelte';

  onDestroy(() =&gt; {
    console.log('组件正在被销毁');
  });
&lt;/script&gt;
</code></pre>
<h2 id="tick"><code>tick</code></h2>
<p>虽然没有"更新后"钩子，但你可以使用 <code>tick</code> 来确保在继续之前 UI 已更新。<code>tick</code> 返回一个 promise，该 promise 在所有待处理的状态更改被应用后 resolve，如果没有待处理的状态更改，则在下一个微任务中 resolve。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { tick } from 'svelte';

  $effect.pre(() =&gt; {
    console.log('组件即将更新');
    tick().then(() =&gt; {
        console.log('组件刚刚更新');
    });
  });
&lt;/script&gt;
</code></pre>
<h2 id="已废弃beforeupdate--afterupdate">已废弃：<code>beforeUpdate</code> / <code>afterUpdate</code></h2>
<p>Svelte 4 有两个在组件整体更新前后运行的钩子。为了向后兼容，这些钩子在 Svelte 5 中被模拟实现，但在使用符文的组件中不可用。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { beforeUpdate, afterUpdate } from 'svelte';

  beforeUpdate(() =&gt; {
    console.log('组件即将更新');
  });

  afterUpdate(() =&gt; {
    console.log('组件刚刚更新');
  });
&lt;/script&gt;
</code></pre>
<p>不要使用 <code>beforeUpdate</code>，应该使用 <code>$effect.pre</code>；不要使用 <code>afterUpdate</code>，应该使用 <code>$effect</code> — 这些符文提供更细粒度的控制，只对你实际关心的更改做出响应。</p>
<h3 id="聊天窗口示例">聊天窗口示例</h3>
<p>我们来实现一个聊天窗口，当出现新消息时自动滚动到底部（前提是你已经滚动到底部了），我们需要在更新 DOM 之前先测量它。</p>
<p>在 Svelte 4 中，我们使用 <code>beforeUpdate</code> 来实现，但这是一个有缺陷的方法 — 它在每次更新前都会触发，无论是否相关。在下面的示例中，我们需要引入像 <code>updatingMessages</code> 这样的检查，以确保在有人切换暗黑模式时不会影响滚动位置。</p>
<p>使用符文，我们可以使用 <code>$effect.pre</code>，它的行为与 <code>$effect</code> 相同，但在 DOM 更新之前运行。只要我们在 effect 内明确引用 <code>messages</code>，它就会在 <code>messages</code> 改变时运行，而在 <code>theme</code> 改变时不会运行。</p>
<p>因此，<code>beforeUpdate</code> 以及同样麻烦的小伙伴 <code>afterUpdate</code> 在 Svelte 5 中已被废弃。</p>
<ul>
<li><a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE31WXa_bNgz9K6yL1QmWOLlrC-w6H8MeBgwY9tY9NfdBtmlbiywZkpyPBfnvo2zLcZK28AWuRPGI5OGhkEuQc4EmiL9eAskqDOLg97oOZoE9125jDigs0t6oRqfOsjap5rXd7uTO8qpW2sIFEsyVxn_qjFmcAcstar-xPN3DFXKtKgi768IVgQku0ELj3Lgs_kZjWIEGNpAzYXDlHWyJFZI1zJjeh4O5uvl_DY8oUkVeVoFuJKYls-_CGYS25Aboj0EtWNqel0wWoBoLTGZgmdgDS9zW4Uz4NsrswPHoyutN4xInkylstnBxdmIhh8m7xzqmoNE2Wq46n1RJQzEbq4g-JQSl7e-HDx-GdaTy3KD9E3lRWvj5Zu9QX1QN20dj7zyHz8s-1S6lW7Cpz3RnXTcm04hIlfdFuO8p2mQ5-3a06cqjrn559bF_2NHOnRZ5I1PLlXQNyQT-hedMHeUEDyjtdMxsa4n2eIbNhlTwhyRthaOKOmYtniwF6pwt0wXa6MBEg0OibZec27gz_dk3UrZ6hB2LLYoiv521Yd8Gt-foTrfhiCDP0lC9VUUhcDLU49Xe_9943cNvEArHfAjxeBTovvXiNpFynfEDpIIZs9kFbg52QbeNHWZzebz32s7xHco3nJAJl1nshmhz8dYOQJDyZetnbb2gTWe-vEeWlrfpZMavr56ldb29eNt6UXvgwgFbp_WC0tl2RK25rGk6lYz3nUI2lzvBXGHhPZPGWmKUXFNBKqdaW259wl_aHbiqoVIZdpE60Nax6IOujT0LbFFxIVTCxCRR2XloUcYNvSbnGHKBp763jHoj59xiZWJI0Wm0P_m3MSS985xkasn-cFq20xTDy3J5KFcjgUTD69BHdcHIjz431z28IqlxGcPSfdFnrGDZn6gD6lyo45zyHAD-btczf-98nhQxHEvKfeUtOVkSejD3q-9X7JbzjGtsdUxlKdFU8qGsT78uaw848syWMXz85Waq2Gnem4mAn3prweq4q6Y3JEpnqMmnPoFRgmd3ySW0LLRqSKlwYHriCvJvUs2yjMaaoA-XzTXLeGMe45zmhv_XAno3Mj0xF7USuqNvnE9H343QHlq-eAgxpbTPNR9yzUkgLjwSR0NK4wKoxy-jDg-9vy8sUSToakzW-9fX13Em9Q8T6Z26uZhBN36XUYo5q7ggLXBZoub2Ofv7g6GCZfTxe034NCjiudXj7Omla0eTfo7QBPOcYxbE7qG-vl3_B1G-_i_JCAAA" target="_blank" rel="noopener nofollow">之前</a></li>
<li><a href="https://svelte.yayujs.com/playground/untitled#H4sIAAAAAAAAE31WXa-jNhD9K7PsdknUQJLurtRLPqo-VKrU1327uQ8GBnBjbGSb5KZR_nvHgMlXtyIS9njO-MyZGZRzUHCBJkhez4FkNQZJ8HvTBLPAnhq3MQcUFmlvVKszZ1mbTPPGbndyZ3ndKG3hDJZne7hAoVUNYY8JV-RBPgIt2AprhA18MpZZnIQ50_twuvLHNRrDSjRXj9fwiCJTBLIKdCsxq5j9EM4gtBU3QD8GjWBZd14xWYJqLTCZg2ViDyx1W4cz4dv0hsiB49FRHkyfsCgws3GjcTKZwmYLZ2feWc9o1W8zJQ2Fb62i5JUQRNRHgs-fx3WsisKg_RN5WVn4-WrvUd9VA9tH4-AcwbfFQIpkLWByvWzqSe2sk3kyjUlOec_XPU-3TRaz_75tuvKoi19e3OvipSpamVmupJM2F_gXnnJ1lBM8oLQjHceys8R7PMFms4HwD2lRhzeEe-EsvluSrHe2TJdo4wMTLY48XKwPzm0KGm2r5ajFtRYU4TWOY7-ddWHfxhDP0QkQhnf5PWRnVVkKnIx8fZsOb5dR16nwG4TCCRdCMphWQ7z1_DoOcp3zA2SCGbPZBa5jd0G_TRxmc36Me-mG6A7l60XIlMs8ce2-OXtrDyBItdz6qVjPadObzx-RZdV1nJjx64tXad1sz962njceOHfAzmk9JzrbXqg1lw3NkZL7vgE257t-uMDcO6attSSokpmgFqVMO2U93e_dDlzOUKsc-3t6zNZp6K9cG3sS2KGSUqiUiUmq8tNYoJwbmvpTAoXA96GyjCojI26xNglk6DpwOPm7NdRYp4ia0JL94bTqRiGB5WJxqFY37RGPoz3c6i4jP3rcUA7wmhqNywQW7om_YQ2L4UQdUBdCHSPiOQJ8bFcxHzeK0jKBY0XcV95SkCWlD9t-9eOM3TLKucauiyktJdpaPqT19ddF4wFHntsqgS-_XE01e48GMwnw02AtWZP02QyGVOkcNfk072CU4PkduZSWpVYt9SkcmJ64hPwHpWF5ziVls3wIFmmW89Y83vMeGf5PBxjcyPSkXNy10J18t3x6-a6CDtBq6SGklNKeazFyLahB3PVIGo2UbhOgGi9vKjzW_j6xVFFD17difXx5ebll0vwvkcGpn4sZ9MN3vqFYsJoL6gUuK9TcPrO_PxgzWMRfflSEr2NHPJf6lj1957rRpH8CNMG84JgHidUtXt4u_wK21LXERAgAAA==" target="_blank" rel="noopener nofollow">之后</a></li>
</ul>

<pre><code class="language-svelte">&lt;script&gt;
  import { ---beforeUpdate, afterUpdate,--- tick } from 'svelte';

  ---let updatingMessages = false;---
  let theme = +++$state('dark')+++;
  let messages = +++$state([])+++;

  let viewport;

  ---beforeUpdate(() =&gt; {---
  +++$effect.pre(() =&gt; {+++
    ---if (!updatingMessages) return;---
    +++messages;+++
    const autoscroll = viewport &amp;&amp; viewport.offsetHeight + viewport.scrollTop &gt; viewport.scrollHeight - 50;

    if (autoscroll) {
      tick().then(() =&gt; {
        viewport.scrollTo(0, viewport.scrollHeight);
      });
    }

    ---updatingMessages = false;---
  });

  function handleKeydown(event) {
    if (event.key === 'Enter') {
      const text = event.target.value;
      if (!text) return;

      ---updatingMessages = true;---
      messages = [...messages, text];
      event.target.value = '';
    }
  }

  function toggle() {
    toggleValue = !toggleValue;
  }
&lt;/script&gt;

&lt;div class:dark={theme === 'dark'}&gt;
  &lt;div bind:this={viewport}&gt;
    {#each messages as message}
      &lt;p&gt;{message}&lt;/p&gt;
    {/each}
  &lt;/div&gt;

  &lt;input +++onkeydown+++={handleKeydown} /&gt;

  &lt;button +++onclick+++={toggle}&gt; 切换暗黑模式 &lt;/button&gt;
&lt;/div&gt;
</code></pre>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>本篇已收录在掘金专栏 <a href="https://juejin.cn/column/7459299646696374284" target="_blank" rel="noopener nofollow">《Svelte 中文文档》</a>，该系列预计 40 篇。</p>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上前端大佬成长之路。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="17.478312009097223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-23 10:49">2025-02-23 10:48</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18731902" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18731902);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18731902', targetLink: 'https://www.cnblogs.com/yayujs/p/18731902', title: 'Svelte 最新中文文档教程（17）—— 生命周期钩子' })">举报</a>
</div>
        