
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Starry---sky/p/18679034" title="发布于 2025-01-18 23:33">
    <span role="heading" aria-level="2">使用PythonDEAP库实现简单遗传算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>​<br>
<a href="https://lkasnive.github.io/2025/01/18/%E4%BD%BF%E7%94%A8PythonDEAP%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener nofollow">本人博客食用体验更佳哦</a></p>
<p>DEAP（Distributed Evolutionary Algorithms in Python）是一个用于快速原型设计和实验的进化计算框架。它支持多种进化算法，包括遗传算法、遗传编程、进化策略、粒子群优化等。DEAP 的设计目标是灵活性和易用性，使得研究人员和开发者能够轻松地实现和测试各种进化算法。</p>
<p><a href="https://deap.readthedocs.io/en/master/" target="_blank" rel="noopener nofollow">官方文档</a></p>
<p><a href="https://github.com/DEAP/deap?tab=readme-ov-file" target="_blank" rel="noopener nofollow">官方GitHub仓库</a></p>
<p>因本人主攻方向并不是Python甚至可以说之前对Python一窍不通，如有错误，还望各位读者指正。</p>
<p>本篇也以讲解用法为主，具体的类的继承和原理并不涉及。</p>
<p>这里以求 <span class="math inline">\(f(x) = (x - 5) ^ 2\)</span> 和 <span class="math inline">\(f(x) = -x ^ 2 + 4x + 4\)</span> 在 <span class="math inline">\([0, 31]\)</span> 上都尽可能大为目标的，多目标优化为例。</p>
<h2 id="0载入deap库">0.载入DEAP库</h2>
<pre><code class="language-python">
import random

from deap import base, creator, tools, algorithms

</code></pre>
<p>由于并不需要deap库所有的功能，这里仅载入要用到的几个模块。</p>
<h2 id="1-创建适应度函数">1. 创建适应度函数</h2>
<pre><code class="language-python">
def evaluate(individual):

    ans = 0

    for i in range(len(individual)):

        ans += (individual[i] &lt;&lt; i)

    return ((ans - 5) ** 2, -ans ** 2 + ans * 4 + 4)

</code></pre>
<p>因为适应度默认是一个元组，这里选择返回一个元组。而每个整数采用二进制存储，则是因为在后面的基因交换中，要求两个基因是列表，整数无法进行交换操作。</p>
<h2 id="2-创建个体种群">2. 创建个体，种群</h2>
<pre><code class="language-python">
def init_individual(icls):

    content = [toolbox.attr_int() for _ in range(5)]

    individual = icls(content)

    individual.fitness.values = (0.0, 0.0) #初始化适应度

    return individual

creator.create("FitnessMulti", base.Fitness, weights=(1.0, 1.0)) #创建适应度

creator.create("Individual", list, fitness=creator.FitnessMulti) #创建个体类，个体为一个列表，并将适应度作为其中的一个属性

toolbox = base.Toolbox()

toolbox.register("attr_int", random.randint, 0, 1) #随即生成0或1作为二进制的每一位

toolbox.register("individual", init_individual, creator.Individual)#注册个体生成函数

toolbox.register("population", tools.initRepeat, list, toolbox.individual)#注册种群生成函数，生成种群为一个列表

</code></pre>
<p>此处第六行weights是适应度，库默认为一个元组。因为此次举例是双函数得到多目标优化，因此元组有两个元素，每个元素的绝对值表示该维函数的权重，正负则表示是最大化还是最小化；为正，则表示目的是使该维元素最大化。</p>
<h3 id="各个函数介绍">各个函数介绍</h3>
<h4 id="creatorcreat基本用法">creator.creat基本用法</h4>
<p>在 DEAP 库中，creator.create 是一个非常重要的函数，用于动态创建新的类型。这些类型通常用于定义个体的表示方式（如染色体）和适应度函数。creator.create 的灵活性使得 DEAP 能够适应各种不同的进化算法需求。</p>
<pre><code class="language-python">
creator.create(name, base, **kwargs)

</code></pre>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">类型</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">name</td>
<td style="text-align: left">字符串</td>
<td style="text-align: left">新类型的名称 。</td>
</tr>
<tr>
<td style="text-align: left">base</td>
<td style="text-align: left">python内置类或自定义类</td>
<td style="text-align: left">用于生成每个对象的函数（例如生成随机个体的函数）。</td>
</tr>
<tr>
<td style="text-align: left">**kwargs</td>
<td style="text-align: left">视情况而定</td>
<td style="text-align: left">额外的属性，通常用于添加适应度函数或其他自定义属性   。</td>
</tr>
</tbody>
</table>
<h4 id="toolboxregister基本用法">toolbox.register基本用法</h4>
<p>toolbox.register 用于将函数或操作注册到 toolbox 对象中，方便在算法中调用。通常用于注册个体生成、交叉、变异、选择等操作。如所给代码中，注册后individual和population就是可以直接调用的函数。</p>
<pre><code class="language-python">
toolbox.register(alias, method, *args, **kargs)

</code></pre>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">类型</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">lias</td>
<td style="text-align: left">类型</td>
<td style="text-align: left">这是你为操作定义的名称，后续可以通过 toolbox.alias 调用该操作。</td>
</tr>
<tr>
<td style="text-align: left">method</td>
<td style="text-align: left">可调用对象</td>
<td style="text-align: left">这是实际执行操作的函数或方法。</td>
</tr>
<tr>
<td style="text-align: left">*args</td>
<td style="text-align: left">可变位置参数</td>
<td style="text-align: left">如果 method 需要若干个参数，可以通过 *args 传递。</td>
</tr>
<tr>
<td style="text-align: left">**kargs</td>
<td style="text-align: left">可变关键字参数</td>
<td style="text-align: left">如果 method 需要关键字参数，可以通过 **kargs 传递。</td>
</tr>
</tbody>
</table>
<p>以原代码中的为例</p>
<pre><code class="language-python">
toolbox.register("individual", init_individual, creator.Individual)

</code></pre>
<p>我们注册了一个名为individual的函数，后续可通过toolbox.individual()调用，函数实际上执行的是init_individual函数的内容,creator.Individual是之前创造的个体类，作为参数传入init_individual。</p>
<h4 id="toolsinitrepeat基本用法">tools.initRepeat基本用法</h4>
<p>在 DEAP 库中，tools.initRepeat 是一个用于生成重复结构的工具函数。它通常用于初始化个体或种群，生成包含重复元素的列表或其他数据结构。以下是 tools.initRepeat 的详细参数及其用法：</p>
<pre><code class="language-python">
deap.tools.initRepeat(container, func, n)

</code></pre>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">类型</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">container</td>
<td style="text-align: left">类型</td>
<td style="text-align: left">用于存储生成对象的容器类型（例如 list、set 等）。</td>
</tr>
<tr>
<td style="text-align: left">func</td>
<td style="text-align: left">可调用对象</td>
<td style="text-align: left">用于生成每个对象的函数（例如生成随机个体的函数）。</td>
</tr>
<tr>
<td style="text-align: left">n</td>
<td style="text-align: left">整数</td>
<td style="text-align: left">需要生成的对象数量（例如种群大小）。</td>
</tr>
</tbody>
</table>
<p>实际上是执行func函数n次，并将其存入container类型中。</p>
<p>以原代码中的为例</p>
<pre><code class="language-python">
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

</code></pre>
<p>我们注册了一个名为population的函数函数，实际上执行的是tools.initRepeat函数的内容,list表明生成的对象，也就是种群，是一个列表，作为参数传入tools.initRepeat，toolbox.individual是initRepeat重复执行的内容。注意到，此处并未写出重复执行次数n。这样我们在后续的种群生成中就可以自由选择生成种群的大小。</p>
<p>同时，因为此例我们的个体是一个整数，也就是一个五个元素的列表。但在某些情况下，我们的个体未必是一个元素，这时，生成个体的函数也可以通过同样的方法实现。例如：我可以定义一个个体是由五个列表构成，每个列表有五个元素（0或1）。toolbox.individual可以如此注册：</p>
<pre><code class="language-python">
toolbox.register("individual", tools.initRepeat, list, init_individual, creator.Individual, n = 5)

</code></pre>
<p><em>注意：</em> 此处的注册函数有误，因为此种写法会导致creator.Individual被视作tools.initRepeat的第三个参数也就是重复次数，而不会被视作init_individual的参数。因此init_individual应使用匿名函数形式，以避免这种情况。这里没做修改。</p>
<h2 id="3-创建其他需要的参数和函数">3. 创建其他需要的参数和函数</h2>
<pre><code class="language-python">
toolbox.register("evaluate", evaluate) #注册适应度函数

toolbox.register("mate", tools.cxTwoPoint) #采用两点交叉方法

toolbox.register("mutate", tools.mutFlipBit, indpb=0.1) #采用位翻转变异发，每个基因变异概率0.1

toolbox.register("select", tools.selNSGA2)  # 因为是多目标优化问题，使用 NSGA-II 选择机制

population_size = 50 # 种群规模

generations = 40 # 繁殖代数

crossover_prob = 0.9 # 交叉概率

mutation_prob = 0.2# 个体变异概率

population = toolbox.population(n = population_size) #生成规模为50的种群

</code></pre>
<p>在这个过程中，基因交叉，变异，选择机制都有很多，各位读者可以根据需求自由选择。</p>
<h2 id="4执行遗传算法">4.执行遗传算法</h2>
<pre><code class="language-python">
for gen in range(generations):

    offspring = algorithms.varAnd(population, toolbox, cxpb = crossover_prob, mutpb = mutation_prob)

    fits = map(toolbox.evaluate, offspring)

    for fit, ind in zip(fits, offspring):

        ind.fitness.values = fit

    population = toolbox.select(offspring + population, k = population_size)

</code></pre>
<h4 id="algorithmsvarand基本用法">algorithms.varAnd基本用法</h4>
<pre><code class="language-python">
algorithms.varAnd(population, toolbox, cxpb, mutpb)

</code></pre>
<table>
<thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">类型</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">population</td>
<td style="text-align: left">注册的种群类</td>
<td style="text-align: left">当前种群。</td>
</tr>
<tr>
<td style="text-align: left">toolbox</td>
<td style="text-align: left">Toolbox 对象</td>
<td style="text-align: left">包含注册的交叉、变异和选择操作。</td>
</tr>
<tr>
<td style="text-align: left">cxpb</td>
<td style="text-align: left">浮点数</td>
<td style="text-align: left">表示两个个体进行交叉的概率。</td>
</tr>
<tr>
<td style="text-align: left">mutpb</td>
<td style="text-align: left">浮点数</td>
<td style="text-align: left">表示个体发生变异的概率。</td>
</tr>
</tbody>
</table>
<p>varAnd 会从 toolbox 中调用注册的函数；toolbox.mate：交叉操作；toolbox.mutate：变异操作。</p>
<p>之后如有需要，可以输出最后的种群，也可结合matplotlib绘制图表。</p>
<p>​</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.46684519409837966" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 23:34">2025-01-18 23:33</span>&nbsp;
<a href="https://www.cnblogs.com/Starry---sky">Starry___sky</a>&nbsp;
阅读(<span id="post_view_count">23</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18679034" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18679034);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18679034', targetLink: 'https://www.cnblogs.com/Starry---sky/p/18679034', title: '使用PythonDEAP库实现简单遗传算法' })">举报</a>
</div>
        