
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/oberon-zjt0806/p/18710283" title="发布于 2025-02-11 18:20">
    <span role="heading" aria-level="2">从零开始的函数式编程(2) —— Church Boolean 编码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>[!quote] 关于λ表达式……<br>
详见<a href="https://www.cnblogs.com/oberon-zjt0806/p/18708237" target="_blank">λ表达式</a></p>
</blockquote>
<blockquote>
<p>⚠ <strong>本文导出自Obsidian</strong>，可能存在格式偏差（例如链接、Callout等）<br>
本文地址：<a href="https://www.cnblogs.com/oberon-zjt0806/p/18710283" target="_blank">https://www.cnblogs.com/oberon-zjt0806/p/18710283</a></p>
</blockquote>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#λ演算与λ代数" rel="noopener nofollow">λ演算与λ代数</a><ul><li><a href="#church-编码" rel="noopener nofollow">Church 编码</a><ul><li><a href="#church-boolean-逻辑编码" rel="noopener nofollow">Church-Boolean 逻辑编码</a><ul><li><a href="#条件选择函数" rel="noopener nofollow">条件选择函数</a></li><li><a href="#真与假--true--false" rel="noopener nofollow">真与假 | True | False</a></li><li><a href="#逻辑运算--and--or--not" rel="noopener nofollow">逻辑运算 | AND | OR | NOT</a><ul><li><a href="#合取--且--and" rel="noopener nofollow">合取 | 且 | AND</a></li><li><a href="#析取--或--or" rel="noopener nofollow">析取 | 或 | OR</a></li><li><a href="#反转--非--not" rel="noopener nofollow">反转 | 非 | NOT</a></li></ul></li></ul></li></ul></li></ul></li></ul></div><p></p>
<h1 id="λ演算与λ代数">λ演算与λ代数</h1>
<p>上一整节我们利用λ符号体系构建了一套表达式系统，从这里开始，我们将正式开始利用这套系统进行代数应用，在进行演算之前，需要先利用符号体系构建一个<strong>代数运算系统</strong>。</p>
<blockquote>
<p>[!note] 命名终究只是命名<br>
虽然我们之前使用了很多诸如<code>(+ x 1)</code>等等这样的形式，但它们只是我们定义的命名，所以无论是<code>x</code>还是<code>+</code>和<code>1</code>，都<strong>只是一个记号</strong>而已，尽管我们根据以往的经验为这些符号赋予了某些我们所熟知的含义，但在当前的λ演算语境下，这些东西都还<strong>没定义</strong>过。</p>
</blockquote>
<h2 id="church-编码">Church 编码</h2>
<p>为了使λ演算能够<strong>具体应用</strong>到计算机和程序上，那么就意味着λ代数系统必须能够表示如下两种东西——</p>
<ul>
<li><strong>数值</strong>（逻辑值、整数……）</li>
<li><strong>运算</strong>（算符、函数、操作……）</li>
</ul>
<p>也就是说，这些东西要在λ演算中<strong>映射为λ表达式</strong>（使用表达式来表示）。</p>
<blockquote>
<p>[!tip]<br>
粗暴地说，Church编码就是<strong>一种</strong>把数值和运算<strong>编码为λ表达式</strong>的过程。</p>
<ul>
<li>但注意！Church编码<strong>并非唯一</strong>的编码方式，还有其他的编码方式，如<strong>Scott编码</strong>等。</li>
<li>Church编码的特点在于以<strong>数值</strong>表示为<strong>起点</strong>进行编码，并在基础上构建其他编码。</li>
</ul>
</blockquote>
<h3 id="church-boolean-逻辑编码">Church-Boolean 逻辑编码</h3>
<blockquote>
<p>[!abstract] Church-Boolean 编码汇总<br>
为了方便查阅，这里将本节所有的编码定义列出来，正文是比较冗长的推导过程</p>
<pre><code>DEF T = λx.λy.x
DEF F = λx.λy.y
DEF AND = λP.λQ.(P Q P)
DEF OR = λP.λQ.(P P Q)
DEF NOT = λP.λQ.(P F T)
</code></pre>
</blockquote>
<p>首先我们需要通过Church编码构建出<strong>布尔运算系统</strong>。之所以先选择布尔代数，是因为布尔代数的结构简单，性质清晰，比较容易构建。</p>
<p><strong>布尔代数</strong>（Boolean Algebra）包含的内容非常简单——</p>
<ul>
<li>布尔域<span class="math inline">\(\mathbb B\)</span>中只包含<strong>两个元素</strong><span class="math inline">\(\mathrm T\)</span>和<span class="math inline">\(\mathrm F\)</span></li>
<li>支持三种基本运算<span class="math inline">\(\wedge\)</span> 、<span class="math inline">\(\vee\)</span>、<span class="math inline">\(\neg\)</span> 。</li>
<li>运算对域封闭，且对于<span class="math inline">\(\wedge\)</span>和<span class="math inline">\(\vee\)</span>都在<span class="math inline">\(\mathbb B\)</span>上分别存在上界和下界</li>
</ul>
<h4 id="条件选择函数">条件选择函数</h4>
<p>在介绍Church-Boolean中的真假值前，我们先来考察<strong>条件选择函数</strong>，所谓条件选择函数就是下面这样的一个三元函数——</p>
<p></p><div class="math display">\[\operatorname{COND} (c,x,y) = \begin{cases} 
x, &amp;c=\mathrm{T} \\
y, &amp;c=\mathrm{F}
\end{cases}
\]</div><p></p><p>其中<span class="math inline">\(c\)</span>是条件值，条件选择函数根据<span class="math inline">\(c\)</span>的值就在<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>中做出选择。可以发现，实际上，这个条件选择函数就对应了大多数编程语言中的<strong>三元运算符</strong><code>c ? x : y</code>。</p>
<p>我们将这个运算表示为<code>IF-THEN-ELSE</code>形式，可以表示为——</p>
<pre><code>IF c THEN x ELSE y
</code></pre>
<p>可以发现这里分为3个子部——</p>
<ul>
<li><code>IF c</code> ：判断<code>c</code>的条件；</li>
<li><code>THEN x</code>：当<code>c == true</code>被满足时，选择<code>x</code>；</li>
<li><code>ELSE y</code>：上述条件不成立时，选择<code>y</code>；</li>
</ul>
<p>至此，我们可以把这三个部分<strong>抽象</strong>为<strong>三个λ表达式</strong>。</p>
<pre><code>DEF cond = λc.λx.λy.(c x y)
</code></pre>
<p>由于<strong>真假值</strong>承载于<code>c</code>中，因此我们就利用<code>c</code>来对真假值进行编码。</p>
<h4 id="真与假--true--false">真与假 | True | False</h4>
<p>基于上面的想法，我们就能够通过Church编码定义出逻辑的真值<code>T</code>和假值<code>F</code>。讨论<code>c</code>的情况，根据定义，<code>cond</code>函数应当满足——</p>
<pre><code>cond T x y =&gt; λc.λx.λy.(c x y) T x y =&gt; λx.λy.(T x y) x y =&gt; T x y =&gt; x
COND F x y =&gt; λc.λx.λy.(c x y) T x y =&gt; λx.λy.(F x y) x y =&gt; F x y =&gt; y
</code></pre>
<p>观察<strong>倒数两步归约</strong>，我们发现</p>
<ul>
<li>欲使<code>T x y =&gt; x</code>，那么就要求<code>(T x) y</code>必须发生<strong>η归约</strong>。
<ul>
<li>也就是说<code>(T x)</code>中<strong>约束不生效</strong>，可以构建自由表达式<code>(T x) == λb.x</code>
<ul>
<li>再脱去对<code>x</code>的运用，解开约束对，意味着我们需要引入一个新的约束变量</li>
<li>于是我们就可以得到<code>T == λa.λb.a</code>。</li>
</ul>
</li>
</ul>
</li>
<li>欲使<code>F x y =&gt; y</code>，那么就要求<code>(F x) y</code>必须发生<strong>β归约</strong>。
<ul>
<li>而且更进一步地，<code>(F x) == identity == λb.b</code>
<ul>
<li>类似地，再脱去对<code>x</code>的运用，解开约束对，引入另外的约束变量 <code>λa</code></li>
<li>于是<code>F == λa.λb.b</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!tip] 反归约技巧<br>
我们知道对于运用<code>(f x)</code>进行归约时，会将<code>f</code>中受约束的变量替换为参数<code>x</code>，例如<code>(λa.a x) =&gt; x</code><br>
那么，反过来对于已知的某一表达式<code>x</code>如果想要引入约束，或者把<code>x</code>作为参数提出来，那么就需要引入新的不冲突的约束命名，<code>x =&gt; (λy.y x)</code>。<br>
利用这种性质在已知<code>(f x)</code>的情况下可以展开<code>f == λa.(f a)</code></p>
</blockquote>
<p>^9b9507</p>
<p>经过α转换，将<code>a</code>更名为<code>x</code>，<code>b</code>更名为<code>y</code>，我们就可以得出<code>T</code>和<code>F</code>的定义</p>
<pre><code>DEF T = λx.λy.x
DEF F = λx.λy.y
</code></pre>
<p>这种定义下的<code>T</code>和<code>F</code>被映射为λ函数，因此可以作为一种条件选择函数来运用。</p>
<p>可以将上述定义代入表达式<code>(c x y)</code>通过[[λ表达式#归约 消解|归约]]来证明这个编码的<strong>正确性</strong>——</p>
<blockquote>
<p>[!warning] 注意<br>
归约化简时，不要忘记<strong>变量约束的右结合律</strong>和<strong>函数运用的左结合律</strong></p>
</blockquote>
<pre><code>(T T F) =&gt; (λx.λy.x λx.λy.x λx.λy.y)
    β|=&gt; (λx.λy.(λx.λy.x) λx.λy.y) 
    α|=&gt; (λy.(λa.λb.a) λx.λy.y)
    η|=&gt; (λa.λb.a)
    α|=&gt; (λx.λy.x) =&gt; T

(F T F) =&gt; (λx.λy.y λx.λy.x λx.λy.y)
    η|=&gt; (λy.y λx.λy.y)
    β|=&gt; (λx.λy.y) =&gt; F // alternatively, ==&gt; identity F =&gt; F
</code></pre>
<h4 id="逻辑运算--and--or--not">逻辑运算 | AND | OR | NOT</h4>
<p>接下来要对<strong>逻辑运算</strong>进行Church编码，这里先给出三种<strong>基本逻辑运算</strong>的<strong>真值表</strong>——</p>
<table>
<thead>
<tr>
<th style="text-align: center">A</th>
<th style="text-align: center">B</th>
<th style="text-align: center">A <strong>AND</strong> B</th>
<th style="text-align: center">A <strong>OR</strong> B</th>
<th style="text-align: center"><strong>NOT</strong> A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">F</td>
<td style="text-align: center">F</td>
<td style="text-align: center">F</td>
<td style="text-align: center">F</td>
<td style="text-align: center">T</td>
</tr>
<tr>
<td style="text-align: center">F</td>
<td style="text-align: center">T</td>
<td style="text-align: center">F</td>
<td style="text-align: center">T</td>
<td style="text-align: center">T</td>
</tr>
<tr>
<td style="text-align: center">T</td>
<td style="text-align: center">F</td>
<td style="text-align: center">F</td>
<td style="text-align: center">T</td>
<td style="text-align: center">F</td>
</tr>
<tr>
<td style="text-align: center">T</td>
<td style="text-align: center">T</td>
<td style="text-align: center">T</td>
<td style="text-align: center">T</td>
<td style="text-align: center">F</td>
</tr>
</tbody>
</table>
<p>XOR、NAND之类的都可以在这三种基本运算的基础上组合出来。所以我们姑且只定义上面三个基本运算即可。</p>
<p>在正式开始之前，我们先考察一个东西——既然<code>T</code>和<code>F</code>都被映射为<strong>函数</strong>，那么意味着他们可以<strong>相互</strong>作为函数和参数<strong>构成约束对</strong>进行运用，那么约束对能否<strong>归约</strong>，以及归约后的<strong>结果</strong>是什么，这里给出两个基本函数相互运用的归约结果——</p>
<pre><code>T T =&gt; (λx.λy.x) (λx.λy.x) β|=&gt; λy.(λx.λy.x) α|=&gt; λy.(λa.λb.a) =&gt; λy.T
T F =&gt; (λx.λy.x) (λx.λy.y) β|=&gt; λy.(λx.λy.y) α|=&gt; λy.(λa.λb.b) =&gt; λy.F
[i.e.]  T P =&gt; λy.P
        T P Q =&gt; P
F T =&gt; (λx.λy.y) (λx.λy.x) η|=&gt; λy.y =&gt; identity
F F =&gt; (λx.λy.y) (λx.λy.y) η|=&gt; λy.y =&gt; identity
[i.e.]  F P =&gt; λy.y =&gt; identity
        F P Q =&gt; Q
</code></pre>
<p>^6686a8</p>
<p>需要注意的是，归约结果中的<code>T</code>和<code>F</code>中的<code>x</code>和<code>y</code>和外层约束的<code>y</code><strong>没有任何关系</strong>，而是出现了<strong>命名冲突</strong>（如果要展开那么需要进行一次<strong>α转换</strong>），所以实际上这里的<code>T</code>是<strong>自由表达式</strong>。在上面的归约过程中，我们可以归纳出如下性质——</p>
<ul>
<li>如果以<code>T</code>作为函数运用<code>(T P)</code>（其中<code>P,Q in {T, F}</code>），那么会通过<strong>β归约</strong>将<code>x</code>替换为<code>P</code>从而得到一个新的函子<code>λy.P</code>，且<code>Q</code>不受<code>y</code>的约束。
<ul>
<li>把这个结果<code>λy.P</code>再作为函数并传入参数<code>Q</code>构成约束对，那么下一步将发生<strong>η归约</strong>，消去<code>λy</code>约束，最终只会剩下<code>P</code>（<code>T P Q =&gt; λy.Q Q =&gt; Q</code>）</li>
</ul>
</li>
<li>如果以<code>F</code>作为函数，那么由于<code>F</code>的<code>λx</code>并<strong>没有进行约束</strong>，所以先进行<strong>η归约</strong>，消去<code>λx</code>约束，最终总会留下<code>λy.y</code>，好巧不巧地，这正好是<strong>恒等函数</strong><code>identity</code>
<ul>
<li>那接下来就很清晰了，如果再传入参数<code>Q</code>，由于<code>identity</code>的性质，或者直接通过<strong>β归约</strong>替换，则会只留下后面的这个参数<code>P</code>（<code>F P Q =&gt; identity Q =&gt; λy.y Q =&gt; Q</code>）</li>
</ul>
</li>
</ul>
<p>![Church T F.svg]]</p>
<p>完成上面的工作有助于我们通过Church编码来<strong>定义逻辑运算</strong>。</p>
<h5 id="合取--且--and">合取 | 且 | AND</h5>
<p>首先来看一下合取运算，合取的要求是只有当两个输入均为<code>T</code>，才可以被归约为<code>T</code>，其他情形全部为<code>F</code>——</p>
<pre><code>AND T Q =&gt; Q
    AND T =&gt; (F P)
AND F Q =&gt; F
    AND F =&gt; (T P)
</code></pre>
<p>观察上面的形式，对于<code>AND P Q</code> ，我们可以做出如下归纳</p>
<ul>
<li>当<code>P==T</code>时，<code>AND P Q =&gt; AND T Q =&gt; Q</code>
<ul>
<li>这种情况对应[[#^6686a8|上面]]的<code>(F P)</code>，于是<code>AND T Q =&gt; F P Q</code></li>
</ul>
</li>
<li>当<code>P==F</code>时，<code>AND P Q =&gt; AND F Q =&gt; F</code>
<ul>
<li>这种情况对应[[#^6686a8|上面]]的<code>(T P)</code>，于是<code>AND F Q =&gt; T P Q</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>[!question] 麻烦了<br>
目前我们归纳出的结论是<code>AND P == (NOT P) P</code>，然而问题在于我们还<strong>没有定义过</strong><code>NOT</code>， 这怎么办呢？</p>
</blockquote>
<blockquote>
<p>[!tip] 还好<br>
<code>AND</code>满足<strong>交换律</strong>，也就是说应当有<code>AND P Q == AND Q P</code></p>
</blockquote>
<p>通过交换律将<code>AND P Q</code>换成<code>AND Q P</code>，不影响先前的结论，除了讨论对象此时从<code>AND P</code>变成了<code>AND Q</code>。</p>
<pre><code>AND Q P[P:=T] =&gt; Q
    AND Q =&gt; (T Q)
AND Q P[P:=F] =&gt; AND Q F =&gt; F
    AND Q =&gt; (F Q)
AND Q =&gt; (P Q)
</code></pre>
<p>终于我们可以得出<code>AND</code>的Church编码——</p>
<pre><code>DEF AND = λP.λQ.(P Q P)
</code></pre>
<h5 id="析取--或--or">析取 | 或 | OR</h5>
<p>与合取<strong>类似</strong>，析取也具有<strong>交换律</strong>，并且我们也可以<strong>效仿刚才</strong>的过程完成<code>OR</code>的定义，首先考察</p>
<pre><code>OR T Q =&gt; T
    OR T =&gt; (T P)
OR F Q =&gt; Q
    OR F =&gt; (F P)
</code></pre>
<p>这次无需交换律了，直接替换就能够得到<code>OR</code>的定义——</p>
<pre><code>DEF OR = λP.λQ.(P P Q)
</code></pre>
<h5 id="反转--非--not">反转 | 非 | NOT</h5>
<p><code>NOT</code>比较特别，因为<code>NOT</code>是一个<strong>一元</strong>运算，需要单独讨论。</p>
<pre><code>NOT T == NOT λx.λy.x =&gt; F == λx.λy.y
NOT F == NOT λx.λy.y =&gt; T == λx.λy.x
</code></pre>
<p>简单来说，输入的参数是选择其中一个，那么<code>NOT</code>的输出总是选择另外一个。考虑到真假值<code>T</code>和<code>F</code>均是通过<code>cond</code>定义的，那么，如果<strong>直接反转</strong><code>cond</code>的<strong>定义</strong>是不是就能够得到相反的输出？</p>
<pre><code>cond == λc.λx.λy.(c x y)
ncond == λc.λx.λy.(c y x)
</code></pre>
<p>于是我们得到了<strong>一种</strong><code>NOT</code>的定义形式</p>
<pre><code>DEF NOT1 = λP.λx.λy.(P y x)
</code></pre>
<p>这个形式看起来比较底层，我们能不能利用已有的<strong>逻辑值</strong>来定义呢？</p>
<p>再次考察 <code>cond P</code> ——</p>
<pre><code>cond P =&gt; λP.λx.λy.(P x y) P =&gt; λx.λy.(P x y)
</code></pre>
<p>如果考虑将<code>x</code>替换为<code>F</code>，<code>y</code>替换为<code>T</code>，也能达成同样的效果，于是我们进一步提供参数——</p>
<pre><code>cond P F T =&gt; λx.λy.(P x y) F T =&gt; P F T
</code></pre>
<p>于是我们得到了<strong>另一种</strong><code>NOT</code>的定义——</p>
<pre><code>DEF NOT2 = λP.(P F T)
</code></pre>
<p>通过归约可证明，<code>NOT1 &lt;=&gt; NOT2</code></p>
<p>至此，两个逻辑值和三个基本逻辑运算被<strong>定义完毕</strong>，Church-Boolean编码完成，可以使用λ表达式进行逻辑演算了。</p>
<blockquote>
<p>[!question] 思考<br>
不妨试试用类似的方式定义出更多的逻辑运算，例如异或<code>XOR</code>、与非<code>NAND</code>等……</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <hr>
<div>作者：<a href="https://www.cnblogs.com/oberon-zjt0806/" target="_blank">Oberon</a></div>
<div>出处：<a href="https://www.cnblogs.com/oberon-zjt0806/" target="_blank">https://www.cnblogs.com/oberon-zjt0806/</a></div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.09427853508101852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 18:25">2025-02-11 18:20</span>&nbsp;
<a href="https://www.cnblogs.com/oberon-zjt0806">Oberon</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710283" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710283);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710283', targetLink: 'https://www.cnblogs.com/oberon-zjt0806/p/18710283', title: '从零开始的函数式编程(2) —— Church Boolean 编码' })">举报</a>
</div>
        