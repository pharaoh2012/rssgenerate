
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zwwhnly/p/18838062" title="发布于 2025-04-21 10:16">
    <span role="heading" aria-level="2">【深度思考】自定义日期格式，为什么@JSONField生效，@JsonFormat不生效？</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.17131731800810185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-21 10:17">2025-04-21 10:16</span>&nbsp;
<a href="https://www.cnblogs.com/zwwhnly">申城异乡人</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18838062);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18838062', targetLink: 'https://www.cnblogs.com/zwwhnly/p/18838062', title: '【深度思考】自定义日期格式，为什么@JSONField生效，@JsonFormat不生效？' })">举报</a>
</small>
    <div class="entry">
            <div id="cnblogs_post_description" style="display: none">
        
        自定义日期格式，为什么@JSONField生效，@JsonFormat不生效？
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-前言">1. 前言</h2>
<p>最近在自测接口时，发现一个问题：字段类型定义的是Date，但接口返回值里却是时间戳(1744959978674)，</p>
<p>而不是预期的2025-04-18 15:06:18。</p>
<pre><code class="language-java">private Date useTime;
</code></pre>
<pre><code class="language-json">{
    "code": "200",
    "message": "",
    "result": [
        {
            "id": 93817601,
            "useTime": 1744959978674
        }
    ]
}
</code></pre>
<p>这种返回值，无法快速的知道是哪个时间，如果想知道时间对不对，还得找一个时间戳转换工具做下转换才能确定，非常不方便。</p>
<p>因此想让接口直接返回预期的2025-04-18 15:06:18格式。</p>
<p>刚开始，在字段上添加了<code>@JsonFormat</code>注解，发现没生效，返回的还是时间戳：</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonFormat;

@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss")
private Date useTime;
</code></pre>
<p>然后，改成了<code>@JSONField</code>注解，发现生效了，达到了预期的结果：</p>
<pre><code class="language-java">import com.alibaba.fastjson.annotation.JSONField;

@JSONField(format = "yyyy-MM-dd HH:mm:ss")
private Date useTime;
</code></pre>
<pre><code class="language-json">{
    "code": "200",
    "message": "",
    "result": [
        {
            "id": 93817601,
            "useTime": "2025-04-18 15:06:18"
        }
    ]
}
</code></pre>
<p>那么问题来了，<strong>为啥@JSONField生效，@JsonFormat不生效？</strong></p>
<h2 id="2-原因分析">2. 原因分析</h2>
<p>默认情况下，Spring Boot使用的JSON消息转换器是Jackson的<code>MappingJackson2HttpMessageConverter</code>，核心依赖为：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.8.11.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>现在使用Jackson的<code>@JsonFormat</code>注解不生效，说明Spring Boot没有使用默认的<code>MappingJackson2HttpMessageConverter</code>。</p>
<p>使用fastjson的<code>@JSONField</code>注解生效了，说明Spring Boot使用的是fastjson下的JSON消息转换器，也就是</p>
<p><code>FastJsonHttpMessageConverter</code>，依赖为：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.83&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>那么怎么找到代码在哪配置的呢？</p>
<p>第一步，先在项目中全局搜索<code>FastJsonHttpMessageConverter</code>（Windows快捷键：Ctrl+Shift+F），不过大概率是搜索不到，因为</p>
<p>公司里的项目一般都继承自公司公共的xxx-spring-boot-starter。</p>
<p>第二步，连按2次Shift键搜索<code>FastJsonHttpMessageConverter</code>，然后查找该类的引用或者子类（子类很可能是公司底层框架中写的）。</p>
<p>然后，很可能会找到类似下面的代码：</p>
<pre><code class="language-java">@Configuration
public class FastJsonMessageConverterConfig {
    @Bean
    public HttpMessageConverters customConverters() {
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
        return new HttpMessageConverters(new HttpMessageConverter[]{fastJsonHttpMessageConverter});
    }
}
</code></pre>
<p>以上代码显式注册了一个<code>FastJsonHttpMessageConverter</code>，并通过<code>HttpMessageConverters</code>覆盖了默认的HTTP 消息转换器</p>
<p>（Jackson的<code>MappingJackson2HttpMessageConverter</code>），所以Spring MVC将只使用fastjson处理JSON序列化/反序列化。</p>
<p>这也是<code>@JSONField</code>生效，<code>@JsonFormat</code>不生效的根本原因。</p>
<h2 id="3-默认行为及全局配置">3. 默认行为及全局配置</h2>
<p>fastjson 1.2.36及以上版本，默认将日期序列化为时间戳（如1744959978674），如果要默认将日期序列化为yyyy-MM-dd HH:mm:ss</p>
<p>（如2025-04-18 15:06:18），需要启用<code>WriteDateUseDateFormat</code>特性：</p>
<pre><code class="language-java">@Configuration
public class FastJsonMessageConverterConfig {
    @Bean
    public HttpMessageConverters customConverters() {
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        // 启用日期格式化特性（禁用时间戳）
   		fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteDateUseDateFormat);
        // 设置日期格式（不指定时，默认为yyyy-MM-dd HH:mm:ss，但即使与默认值一致，也建议明确指定）
	    fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");
        
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
        return new HttpMessageConverters(new HttpMessageConverter[]{fastJsonHttpMessageConverter});
    }
}
</code></pre>
<p>如果某个日期字段有特殊序列化要求，可以使用<code>@JSONField</code>注解灵活配置（该注解会覆盖全局配置）：</p>
<pre><code class="language-java">import com.alibaba.fastjson.annotation.JSONField;

@JSONField(format = "yyyy-MM-dd")
private Date anotherUseTime;
</code></pre>
<p><strong>注意事项：</strong></p>
<p>修改全局配置需慎重，如果一个老项目，原来日期类型返回的都是时间戳，突然全部改为返回字符串，可能会造成调用方报错。</p>
<blockquote>
<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>
</blockquote>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zwwhnly" blog-id="121761" post-id="18838062"></vc:categories-tags>
    </ul>
