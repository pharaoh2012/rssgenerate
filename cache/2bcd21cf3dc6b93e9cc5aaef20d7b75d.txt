
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/N-lim/p/18824927" title="发布于 2025-04-14 15:19">
    <span role="heading" aria-level="2">C++数据的共享和保护</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>1、函数原型作用域：C++中最小的作用域</p>
<p>①在函数原型声明时，形参的作用范围就是函数原型作用域。</p>
<p>2、局部作用域/块作用域<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151453507-292329417.png" alt="image" loading="lazy"><br>
3、类作用域</p>
<p>类可以被看做是一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有如下三种：</p>
<p>①如果在X的成员函数中，没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m</p>
<p>②通过表达式X.m或X::m（访问静态成员变量）访问。</p>
<p>③通过ptr→m这样的表达式，ptr为指向X类的一个对象的指针</p>
<p>对象的成员函数具有类作用域</p>
<p>4、文件作用域</p>
<p>eg：全局变量<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151518594-1381436908.png" alt="image" loading="lazy"><br>
5、限定作用域的enum枚举类</p>
<p>定义限定作用域的枚举类型的方式是enum class{...}，即多了class或struct限定符，此时枚举元素的名字遵循类作用域，在枚举类型的作用域外是不可访问的。相反，在不限定作用域的枚举类型中，枚举元素的作用域与枚举类型本身的作用域相同。<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151541822-431961148.png" alt="image" loading="lazy"><br>
6、可见性</p>
<p>①如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。</p>
<p>7、对象的生存期</p>
<p>①静态生存期</p>
<ul>
<li>如果对象的生存期与程序的运行期相同，我们称它具有静态生存期。</li>
<li>使用static可以在函数内部的局部作用域中声明具有静态生存期的对象</li>
<li>局部作用域中静态变量的特点：当一个函数返回后，下一次再调用时，该变量还会保持上一回的值，即使发生了递归调用，也不会为该变量建立新的副本，该变量会在各次调用间共享。</li>
<li>定义静态变量的同时可以为它赋初值，只有第一次调用时赋值语句才生效。</li>
<li>定义时未指定初值的基本类型静态生存期变量，会被以0值初始化</li>
</ul>
<p>②动态生存期</p>
<p>8、静态数据成员</p>
<p>static的作用域为类</p>
<p>①static关键字可以实现同一类的不同对象之间的数据共享，静态数据成员具有静态生存期</p>
<p>②由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法是“类名::标识符”</p>
<p>③在类的定义中仅仅对静态数据成员进行引用性声明，必须在文件作用域的某个地方使用类名限定进行定义性声明，这时也可以进行初始化</p>
<p>④C++11标准支持常量表达式类型修饰（constexpr,const）的静态常量在类内初始化，此时仍可在类外定义该静态成员，但不能做再次初始化操作。</p>
<p>【注】之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无须以此方式定义，因为它们的空间是与它们所属对象的空间同时分配的。</p>
<p>9、静态函数成员</p>
<p>①在静态函数成员中访问类的非静态成员需要指明对象，因为对静态成员函数的调用是没有目的对象的<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151602452-404877751.png" alt="image" loading="lazy"><br>
10、传对象参数时，习惯传引用，传引用可以降低开销</p>
<p>11、友元：提供不同类或对象之间的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制</p>
<p>①从一定程度上讲，友元是对数据隐蔽和封装的破坏</p>
<p>②在一个类中，可以利用关键字friend将其他函数或类声明为友元。</p>
<p>③三点友元声明</p>
<ul>
<li>友元关系是不能传递的</li>
<li>友元关系是单向的</li>
<li>友元关系是不能被继承的。（理解：别人信任你，不见得信任你的孩子）</li>
</ul>
<p>12、友元函数：在类中用friend修饰的非成员函数</p>
<p>①虽然<strong>友元函数不是本类的成员函数</strong>，但是在它的函数体中可以通过对象名访问类的私有和保护成员。<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151623151-1739393582.png" alt="image" loading="lazy"><br>
②友元函数不能通过对象调用【因为友元函数不是类的成员函数，不属于该类】</p>
<p>③友元函数必须在参数表中显示地指明要访问的对象，而成员函数则在它的对象上操作</p>
<p>13、友元类</p>
<p>①若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。<br>
14、常对象</p>
<p>①常对象的数据成员的值在对象的整个生存期内不能被改变。</p>
<p>②常对象必须进行初始化，而且不能被更新。<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151651415-1185943192.png" alt="image" loading="lazy"><br>
15、用const修饰的类成员</p>
<p>①常成员函数：使用const修饰的函数为常成员函数，常成员函数<strong>声明</strong>的格式如下：<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151711391-1333421880.png" alt="image" loading="lazy"><br>
【注1】const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字</p>
<p>【注2】如果将一个对象说明为常对象，则通过该常对象只能调用它的常成员函数，而不能调用其他成员函数</p>
<p>【注3】无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都被视为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数</p>
<p>【注4】const关键字可以用于对重载函数的区分<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151730213-159188051.png" alt="image" loading="lazy"><br>
如果仅以const关键字区分对成员函数的重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的函数——不带const关键字的函数<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151749688-1796462683.png" alt="image" loading="lazy"><br>
②常数据成员</p>
<ul>
<li>构造函数对常数据成员进行初始化，只能通过初始化列表</li>
<li>类成员中的常静态变量和常量都应当在类体之外加以定义，C++中规定：类的静态常量如果具有整数类型或枚举类型，那么可以直接在类定义中为它指定常量值<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151821357-1015027348.png" alt="image" loading="lazy"><br>
16、常引用</li>
</ul>
<p>①如果在声明引用时用const修饰，被声明的引用就是常引用。常引用所引用的对象不能被更新。常引用的声明形式如下：<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151840584-861532414.png" alt="image" loading="lazy"><br>
②非const的引用只能绑定到普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象</p>
<p>③一个常引用，无论绑定到一个普通对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象。</p>
<p>17、多文件结构和编译预处理命令</p>
<p>①通常一个项目至少划分为3个文件：类定义文件(<em>.h文件)、类实现文件(</em>.cpp文件)、类使用文件(*.cpp,注函数文件)</p>
<p>18、静态函数成员的访问<br>
<img src="https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151912597-1381008216.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0438299892962963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 15:19">2025-04-14 15:19</span>&nbsp;
<a href="https://www.cnblogs.com/N-lim">风归去</a>&nbsp;
阅读(<span id="post_view_count">24</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18824927);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18824927', targetLink: 'https://www.cnblogs.com/N-lim/p/18824927', title: 'C++数据的共享和保护' })">举报</a>
</div>
        