
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/madtom/p/18655530" title="发布于 2025-01-06 16:14">
    <span role="heading" aria-level="2">[.NET] API网关选择：YARP还是Ocelot？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        随着微服务架构的流行，API网关在系统架构中扮演着越来越重要的角色。在.NET生态中，YARP（Yet Another Reverse Proxy）和Ocelot是两种常用的API网关解决方案。那么，在实际应用中，我们该如何选择？本文将从易用性、文档、负载均衡、限流、身份验证、授权和性能等多个方面，对YARP和Ocelot进行详细对比，并附上具体的代码示例，帮助大家更好地理解和选择适合的API网关。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="api网关选择yarp还是ocelot">API网关选择：YARP还是Ocelot？</h1>
<h2 id="摘要">摘要</h2>
<p>随着微服务架构的流行，API网关在系统架构中扮演着越来越重要的角色。在.NET生态中，YARP（Yet Another Reverse Proxy）和Ocelot是两种常用的API网关解决方案。那么，在实际应用中，我们该如何选择？本文将从易用性、文档、负载均衡、限流、身份验证、授权和性能等多个方面，对YARP和Ocelot进行详细对比，并附上具体的代码示例，帮助大家更好地理解和选择适合的API网关。</p>
<h2 id="概述">概述</h2>
<h3 id="yarp">YARP</h3>
<p>YARP（Yet Another Reverse Proxy）是由微软维护的一个反向代理库，专为构建高度自定义的反向代理而设计。尽管它是一个较新的项目，但在GitHub上已经获得了超过8.7k的星标。YARP的优势在于其高性能、灵活的配置和丰富的文档支持。</p>
<p>GitHub地址：<a href="https://github.com/microsoft/reverse-proxy" target="_blank" rel="noopener nofollow">https://github.com/microsoft/reverse-proxy</a></p>
<h3 id="ocelot">Ocelot</h3>
<p>Ocelot也是一个流行的API网关解决方案，已经存在了相当长的时间，积累了丰富的功能和社区支持。在GitHub上，Ocelot拥有超过8.4k的星标。尽管曾经有一段时间维护不积极，但近期又重新活跃起来。Ocelot提供了开箱即用的服务发现、请求聚合等功能。</p>
<p>GitHub地址：<a href="https://github.com/ThreeMammals/Ocelot" target="_blank" rel="noopener nofollow">https://github.com/ThreeMammals/Ocelot</a></p>
<h2 id="功能对比">功能对比</h2>
<h3 id="负载均衡">负载均衡</h3>
<p>两者都支持负载均衡，且配置方式相似。都可以通过配置多个下游服务，实现请求的负载均衡，并支持多种负载均衡策略，如轮询、随机等。</p>
<h3 id="限流">限流</h3>
<p><strong>YARP</strong></p>
<p>YARP利用<strong>ASP.NET Core内置的限流中间件</strong>，提供了灵活的限流策略。支持固定窗口、滑动窗口、令牌桶、并发限制等多种算法。此外，YARP还支持自定义限流算法，满足特殊需求。</p>
<p><strong>Ocelot</strong></p>
<p>Ocelot也提供了限流功能，但在灵活性上略逊一筹。Ocelot的限流主要基于固定窗口，配置相对简单，但自定义能力有限。</p>
<h3 id="身份验证与授权">身份验证与授权</h3>
<p><strong>YARP</strong></p>
<p>YARP支持与<strong>ASP.NET Core的身份验证和授权机制</strong>集成。可以定义自定义的授权策略，支持基于声明、角色等多种方式的授权。配置灵活，能够满足复杂的安全需求。</p>
<p><strong>Ocelot</strong></p>
<p>Ocelot也支持身份验证和授权，但主要以基于声明的授权为主。相比之下，Ocelot的授权配置较为简单，灵活性不如YARP。</p>
<h3 id="性能">性能</h3>
<p>在性能测试中，YARP显著优于Ocelot。在相同的测试条件下，YARP每秒处理的请求数比Ocelot高出约50%。对于高负载、高并发的应用场景，YARP的性能优势更加明显。</p>
<h2 id="实践示例">实践示例</h2>
<p>接下来，我们通过具体的代码示例，展示如何使用YARP和Ocelot构建API网关，并实现负载均衡、限流等功能。</p>
<h3 id="项目结构">项目结构</h3>
<p>我们使用基架自带的<code>weatherforecast</code>API。我们的目标是将该API置于API网关之后，使用YARP和Ocelot分别实现。</p>
<h3 id="使用yarp构建api网关">使用YARP构建API网关</h3>
<h4 id="1-创建yarp网关项目">1. 创建YARP网关项目</h4>
<p>新建一个空的ASP.NET Core Web应用程序，命名为<code>YarpGateway</code>。</p>
<h4 id="2-安装yarp包">2. 安装YARP包</h4>
<p>在<code>YarpGateway</code>项目中，安装YARP的NuGet包：</p>
<pre><code class="language-bash">Install-Package Yarp.ReverseProxy
</code></pre>
<h4 id="3-配置programcs">3. 配置<code>Program.cs</code></h4>
<p>在<code>Program.cs</code>中，添加YARP所需的服务和中间件：</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

// 添加YARP反向代理服务，并加载配置
builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

var app = builder.Build();

// 配置YARP中间件
app.MapReverseProxy();

app.Run();
</code></pre>
<h4 id="4-配置appsettingsjson">4. 配置<code>appsettings.json</code></h4>
<p>在<code>appsettings.json</code>中，添加<code>ReverseProxy</code>配置节：</p>
<pre><code class="language-json">{
  "ReverseProxy": {
    "Routes": {
      "forecast-routes": {
        "ClusterId": "forecastCluster",
        "Match": {
          "Path": "/forecast/{**catch-all}"
        }
      }
    },
    "Clusters": {
      "forecastCluster": {
        "Destinations": {
          "destination1": {
            "Address": "http://localhost:5001/"
          },
          "destination2": {
            "Address": "http://localhost:5002/"
          }
        },
        "LoadBalancingPolicy": "RoundRobin"
      }
    }
  }
}
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li><code>Routes</code>：定义了请求匹配规则，将匹配到<code>/forecast/*</code>的请求路由到<code>forecastCluster</code>。</li>
<li><code>Clusters</code>：定义了下游服务的集合，这里配置了两个目标地址，用于负载均衡。</li>
<li><code>LoadBalancingPolicy</code>：设置负载均衡策略为<code>RoundRobin</code>（轮询）。</li>
</ul>
<h4 id="5-添加限流">5. 添加限流</h4>
<p>在YARP中，可以利用ASP.NET Core的限流中间件进行配置。</p>
<p>首先，在<code>Program.cs</code>中添加限流服务：</p>
<pre><code class="language-csharp">builder.Services.AddRateLimiter(_ =&gt; 
{
    _.AddFixedWindowLimiter("fixed", options =&gt;
    {
        options.Window = TimeSpan.FromSeconds(10);
        options.PermitLimit = 10;
        options.QueueLimit = 0;
        options.QueueProcessingOrder = System.Threading.RateLimiting.QueueProcessingOrder.OldestFirst;
    });
});
</code></pre>
<p>然后，在YARP的路由配置中，添加限流策略：</p>
<pre><code class="language-json">{
  "ReverseProxy": {
    "Routes": {
      "forecast-routes": {
        "ClusterId": "forecastCluster",
        "Match": {
          "Path": "/forecast/{**catch-all}"
        },
        "RateLimiterPolicy": "fixed"
      }
    },
    // 其他配置
  }
}
</code></pre>
<p>最后，在<code>Program.cs</code>中添加限流中间件：</p>
<pre><code class="language-csharp">app.UseRateLimiter();
</code></pre>
<h4 id="6-配置身份验证与授权">6. 配置身份验证与授权</h4>
<p>假设需要对<code>/products</code>路由进行授权，我们可以在YARP的路由配置中添加<code>AuthorizationPolicy</code>：</p>
<pre><code class="language-json">{
  "AuthorizationPolicy": "RequireAuthenticatedUser"
}
</code></pre>
<p>在<code>Program.cs</code>中，添加身份验证和授权服务，这里以<code>JWT</code> Scheme为例：</p>
<pre><code class="language-csharp">builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =&gt;
    {
        options.Authority = "https://your-auth-server";
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = false
        };
    });

builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("RequireAuthenticatedUser", policy =&gt;
    {
        policy.RequireAuthenticatedUser();
    });
});
</code></pre>
<p>并添加中间件：</p>
<pre><code class="language-csharp">app.UseAuthentication();
app.UseAuthorization();
</code></pre>
<h3 id="使用ocelot构建api网关">使用Ocelot构建API网关</h3>
<h4 id="1-创建ocelot网关项目">1. 创建Ocelot网关项目</h4>
<p>新建一个空的ASP.NET Core Web应用程序，命名为<code>OcelotGateway</code>。</p>
<h4 id="2-安装ocelot包">2. 安装Ocelot包</h4>
<p>在<code>OcelotGateway</code>项目中，安装Ocelot的NuGet包：</p>
<pre><code class="language-bash">Install-Package Ocelot
</code></pre>
<h4 id="3-配置programcs-1">3. 配置<code>Program.cs</code></h4>
<p>在<code>Program.cs</code>中，添加Ocelot所需的服务和中间件：</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

// 添加Ocelot服务
builder.Services.AddOcelot();

// 加载Ocelot配置文件
builder.Configuration.AddJsonFile("ocelot.json", optional: false, reloadOnChange: true);

var app = builder.Build();

// 配置Ocelot中间件，要加一个await还挺奇怪的
await app.UseOcelot();

app.Run();
</code></pre>
<h4 id="4-创建ocelotjson">4. 创建<code>ocelot.json</code></h4>
<p>在项目根目录下，添加<code>ocelot.json</code>配置文件：</p>
<pre><code class="language-json">{
  "Routes": [
    {
      "DownstreamPathTemplate": "/forecast/{everything}",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5001
        },
        {
          "Host": "localhost",
          "Port": 5002
        }
      ],
      "UpstreamPathTemplate": "/forecast/{everything}",
      "UpstreamHttpMethod": [ "GET", "POST", "PUT", "DELETE" ],
      "LoadBalancerOptions": {
        "Type": "RoundRobin"
      }
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://localhost:4000"
  }
}
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li><code>Routes</code>：定义了请求的上游和下游路径模板，以及支持的HTTP方法。</li>
<li><code>DownstreamHostAndPorts</code>：配置了下游服务的主机和端口，用于负载均衡。</li>
<li><code>LoadBalancerOptions</code>：设置负载均衡策略为<code>RoundRobin</code>（轮询）。</li>
<li><code>GlobalConfiguration</code>：全局配置，可以配置API网关的基本地址。</li>
</ul>
<h4 id="5-添加限流-1">5. 添加限流</h4>
<p>在Ocelot中，可以在路由配置中添加限流选项：</p>
<pre><code class="language-json">{
  // 其他配置
  "RateLimitOptions": {
    "ClientWhitelist": [],
    "EnableRateLimiting": true,
    "Period": "10s",
    "PeriodTimespan": 10,
    "Limit": 10
  }
}
</code></pre>
<h4 id="6-配置身份验证与授权-1">6. 配置身份验证与授权</h4>
<p>在Ocelot的配置中，添加身份验证和授权选项：</p>
<pre><code class="language-json">{
  // 其他配置
  "AuthenticationOptions": {
    "AuthenticationProviderKey": "Bearer",
    "AllowedScopes": []
  },
  "RouteClaimsRequirement": {
    "role": "admin"
  }
}
</code></pre>
<p>在<code>Program.cs</code>中，添加身份验证和授权服务：</p>
<pre><code class="language-csharp">builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =&gt;
    {
        options.Authority = "https://your-auth-server";
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = false
        };
    });

// Ocelot会自动使用ASP.NET Core的授权策略
</code></pre>
<h3 id="测试配置">测试配置</h3>
<p>向YARP和Ocelot网关发送请求：</p>
<ul>
<li>
<p><strong>YARP网关</strong></p>
<pre><code class="language-http">GET http://localhost:3000/forecast/weatherforecast
</code></pre>
</li>
<li>
<p><strong>Ocelot网关</strong></p>
<pre><code class="language-http">GET http://localhost:4000/forecast/weatherforecast
</code></pre>
</li>
</ul>
<h4 id="3-验证负载均衡">3. 验证负载均衡</h4>
<p>多次发送请求，观察响应中服务器返回的实例信息，确认请求被轮询分配到不同的下游服务实例。</p>
<h4 id="4-验证限流">4. 验证限流</h4>
<p>快速连续地发送超过限制次数的请求，观察是否返回相应的限流错误信息：</p>
<ul>
<li>
<p><strong>YARP</strong>：默认返回<code>503 Service Unavailable</code>。</p>
</li>
<li>
<p><strong>Ocelot</strong>：返回<code>429 Too Many Requests</code>，并包含错误信息。Ocelot的返回值更人性化</p>
</li>
</ul>
<h4 id="5-验证身份验证与授权">5. 验证身份验证与授权</h4>
<p>使用dotnet签发本地测试JWT，尝试在不提供有效身份验证信息的情况下访问受保护的路由，验证是否被拒绝访问。<br>
<img src="https://img2024.cnblogs.com/blog/3358435/202501/3358435-20250106155036385-1410010991.png" alt="image" loading="lazy"></p>
<h3 id="性能测试">性能测试</h3>
<p>为了对比YARP和Ocelot的性能，我们使用<code>k6</code>工具进行压力测试。三个项目都将运行在.NET9.0 Runtime、Release、Logging=Warning模式下</p>
<h4 id="1-设置测试脚本">1. 设置测试脚本</h4>
<p>创建<code>yarp-test.js</code>和<code>ocelot-test.js</code>脚本，内容如下：</p>
<pre><code class="language-javascript">import http from 'k6/http';
import { check } from 'k6';

export const options = {
    stages: [
        { duration: '10s', target: 20 },
        { duration: '50s', target: 20 }
    ]
};

export default function () {
    const res = http.get('http://localhost:3000/forecast/weatherforecast');
    check(res, {
        'status was 200': (r) =&gt; r.status == 200,
    });
}
</code></pre>
<pre><code class="language-javascript">import http from 'k6/http';
import { check } from 'k6';

export const options = {
    stages: [
        { duration: '10s', target: 20 },
        { duration: '50s', target: 20 }
    ]
};

export default function () {
    const res = http.get('http://localhost:4000/forecast/weatherforecast');
    check(res, {
        'status was 200': (r) =&gt; r.status == 200,
    });
}
</code></pre>
<h4 id="2-运行性能测试">2. 运行性能测试</h4>
<p>使用以下命令运行测试：</p>
<pre><code class="language-bash">k6 run yarp-test.js
k6 run ocelot-test.js
</code></pre>
<h4 id="3-结果对比">3. 结果对比</h4>
<p><img src="https://img2024.cnblogs.com/blog/3358435/202501/3358435-20250106160949532-1304733846.png" alt="image" loading="lazy"></p>
<p>根据测试结果，统计每秒处理的请求数（RPS）：</p>
<ul>
<li><strong>YARP</strong>：约84120 RPS。</li>
<li><strong>Ocelot</strong>：约57126 RPS。</li>
</ul>
<p>YARP的性能明显优于Ocelot，快了47.3%，尤其是在高负载场景下。</p>
<h2 id="结论">结论</h2>
<p>通过以上对比，我们可以发现：</p>
<ul>
<li><strong>YARP</strong>在性能、限流和授权的灵活性方面更具优势，适合需要高性能和高度自定义的应用场景，也更适合熟悉ASP.NET Core中间件的开发人员。</li>
<li><strong>Ocelot</strong>提供了更丰富的功能，如服务发现、请求聚合等，开箱即用，适合快速构建和部署。</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://github.com/microsoft/reverse-proxy" target="_blank" rel="noopener nofollow">YARP GitHub仓库</a></li>
<li><a href="https://microsoft.github.io/reverse-proxy/" target="_blank" rel="noopener nofollow">YARP 官方文档</a></li>
<li><a href="https://github.com/ThreeMammals/Ocelot" target="_blank" rel="noopener nofollow">Ocelot GitHub仓库</a></li>
<li><a href="https://ocelot.readthedocs.io/en/latest/" target="_blank" rel="noopener nofollow">Ocelot 官方文档</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/rate-limit" target="_blank" rel="noopener nofollow">ASP.NET Core 限流中间件</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4725481028935185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 16:53">2025-01-06 16:14</span>&nbsp;
<a href="https://www.cnblogs.com/madtom">MadLongTom</a>&nbsp;
阅读(<span id="post_view_count">357</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18655530" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18655530);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18655530', targetLink: 'https://www.cnblogs.com/madtom/p/18655530', title: '[.NET] API网关选择：YARP还是Ocelot？' })">举报</a>
</div>
        