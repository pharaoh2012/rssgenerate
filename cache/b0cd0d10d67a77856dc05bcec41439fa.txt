
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18879511" title="发布于 2025-05-20 13:46">
    <span role="heading" aria-level="2">C#网络编程(五)----细嗦TCP粘包</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前情提要">前情提要</h1>
<p>四层网络模型各司其职，消息(SDU)在进入每一层时都会多加一个报头(PCI)，这个PCI记录着该SDU的一些<code>关键统计信息</code>。SDU+PCI合并起来就组成一个完整的消息，简称为PDU</p>
<ol>
<li>链路层：帧(Frame)头部作用<br>
源 MAC 地址 和 目的 MAC 地址，用于在局域网内通信唯一标识设备，实现数据在物理链路上的传输</li>
<li>网络层：数据包(Packet)头部作用<br>
包含 源IP 地址和 目的IP 地址，用户在互联网中实现端到端通信</li>
<li>传输层：段(Segment)/数据报(Datagram)头部作用<br>
包含 源端口号 和 目的端口号，用于标识同一主机上的不同应用程序</li>
<li>应用层：消息(Message)头部作用<br>
应用层协议根据具体需求定义头部格式，用于实现特定的业务逻辑</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250516094904235-1523287326.png" alt="image" loading="lazy"></p>
<blockquote>
<p>详见https://www.cnblogs.com/lmy5215006/p/18838393</p>
</blockquote>
<h1 id="数据切片">数据切片</h1>
<p>把互联网比作一条水管，那么这条水管是有一定的粗细的，而水管的粗细决定了流量的大小。因此，当我们发送"Hello World"时，当水管粗时，可以一次性发送完毕，当水管细时，就需要拆解成'He','llo','Wo','rld'。</p>
<blockquote>
<p>决定"水管粗细"的由底层的数据链路层决定，为一个MTU(通常为1500Byte)，当网络层(IP)数据包&lt;=1500byte时，一个数据包即可完成发送，如果&gt;1500byte就需要拆分为两个数据包。</p>
</blockquote>
<blockquote>
<p>MTU（Maximum Transmission Unit，最大传输单元）</p>
</blockquote>
<p><strong>举个例子：MTU为1500byte，IP头为20Byte，IP层传输了一个3000Byte的数据包</strong></p>
<ol>
<li>第一个数据包<br>
IP Header：20byte<br>
Payload：1480byte<br>
Total:1500byte</li>
<li>第二个数据包<br>
IP Header：20byte<br>
Payload：3000byte-1480byte=1520byte (超过MTU，需要再次分片，实际1480)<br>
Total:1500byte</li>
<li>第三个数据包<br>
IP Header：20byte<br>
Payload：40byte<br>
Total:60byte</li>
</ol>
<p>由此可以看到，一次传输被拆分成了三次，每个分配重复携带IP Header，增加了<code>额外的传输冗余</code>，且分配需要重组，增加了<code>延迟与丢包风险</code>。</p>
<h2 id="mtu与mss">MTU与MSS</h2>
<p>为了缓解上述的问题，传输层的TCP协议通过MSS(Maximum Segment Size,最大段大小)来避免IP分片。</p>
<ol>
<li>三次握手协商<br>
三次握手时，双方通过SYN报文交换MSS值，确保Segment 不超过MSS。<br>
MSS=MTU-IP Header-TCP Header，比如MTU=1500，那么MSS=1500-20-20=1460byte。</li>
<li>路径MTU发现<br>
IP协议通过ICMP协议探测传输路径中的最小MTU，动态调整数据包大小以减少分片。</li>
</ol>
<p>通过动态协商MTU，使得IP数据包使用不会超过MTU的值，从而避免了分片。不会出现MTU=1500，IP数据包3000Byte的现象。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250520113911318-1934145624.png" alt="image" loading="lazy"></p>
<h1 id="粘包">粘包</h1>
<blockquote>
<p>人生就像打电话，不是你挂就是我挂。<br>
切片也是，你链路层倒是爽了，不用拆包了，但传输层就遭殃了，因为总要有人负重前行。</p>
</blockquote>
<p>TCP是一种面向连接，可靠的，<code>基于字节流</code>的传输层通信协议，因为基于字节流的特点，数据由01组成，所以当我们在互联网中传输"hello World"时，是以0101010101这种格式的字节流发送。<br>
这些二进制数据，对于接收端来说，不知道要接收多少才能组成一个消息，因此其本质是<code>应用层消息边界在TCP流中消失</code>。</p>
<p>粘包发生的原因如下：</p>
<ol>
<li>数据包过小<br>
当Segment特别小，没有达到MSS的标准，TCP的<code>Nagle算法</code>会原地等待200ms，等下一个包一起发送。</li>
<li>数据包过大<br>
如果下一个包来之后，超过了MSS的标准，则会<code>拆包</code>。</li>
<li>接收端读取数据不及时<br>
接收端处理不及时，导致在Buff中好几个Segment的先后粘在一起，导致接收端无法区分。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428100739457-2111545445.png" alt="image" loading="lazy"></p>
<blockquote>
<p>说白了，粘包不是TCP的设计缺陷，而是一种取舍。</p>
</blockquote>
<h2 id="如何解决粘包">如何解决粘包</h2>
<p>既然原理知道了，那么解决它也很简单.</p>
<ol>
<li>消息定长<br>
每个数据包的长度固定，那么接收端只要固定读取特定长度的二进制流即可区分。</li>
<li>分割符标记<br>
通过特殊标记作为头/尾，比如EOF，回车，0xffffff等。当接收端处理到特殊标记时，就知道消息读取完了。</li>
<li>头部包含长度字段<br>
一般会配合上面的分割符标记来加强，在Header中加入消息长度，然后就如同消息定长一样读取即可。</li>
</ol>
<blockquote>
<p>如果某个数据里正好有EOF怎么办？<br>
还有标志位作为兜底，发送端在发送时加入16校验和(对完整数据进行CRC)，以供接收端校验。<br>
如同文件的MD5一样，下载完成后校验MD5，避免错误。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250520125826553-1576707997.png" alt="image" loading="lazy"></p>
<h1 id="faq">FAQ</h1>
<h2 id="udp会有粘包问题吗">UDP会有粘包问题吗?</h2>
<p>不会，原因如下:</p>
<ol>
<li>UDP 不存在合并数据的机制<br>
Datagram是独立的数据单元，是最小单位，包含完整的Head和Payload。接收方要设置合理的缓冲区来接收，否则数据会丢失。<br>
当Datagram，网络层(IP层)会对其分片，但传输层本身不处理分片。</li>
<li>Datagram边界明确<br>
UDP 协议保证接收方可以通过数据报的长度字段（头部中 Length 字段）准确区分每个数据包的起始和结束。</li>
</ol>
<blockquote>
<p>简单来说，UDP自己都不保证消息消息完整，就算发生粘包又怎么样呢？</p>
</blockquote>
<h2 id="网络层会有粘包问题吗">网络层会有粘包问题吗?</h2>
<p>虽然我们在传输层明确了MSS会小于MTU(1500byte)，避免了IP层的大包分片，但还会有漏网之鱼。比如在动态路径MTU发现中，发现某个路由器MTU只有500byte，那么IP层也需要对数据包进行切片。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250520133851565-173721612.png" alt="image" loading="lazy"></p>
<blockquote>
<p>再此之后会重新协商，传输层会调整MSS为500byte。</p>
</blockquote>
<p>回到正题，那么网络层会有粘包问题吗?<br>
答案是不会，再次强调一遍粘包本质是<code>应用层消息边界在TCP流中消失</code>。网络层只负责数据切片以及数据重组，它<code>不关心里面的内容是什么</code>，只是数据的搬运工，因此不会发生粘包。</p>
<h2 id="关闭nagle算法会减少粘包吗">关闭Nagle算法会减少粘包吗？</h2>
<p>关闭Nagle算法会减少粘包，因为小的数据包会立即发送，而不是等200ms。<br>
但治标不治本，接收方处理速度慢也是粘包的一个原因。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6867159696168982" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-20 13:46">2025-05-20 13:46</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">154</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18879511);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18879511', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18879511', title: 'C#网络编程(五)----细嗦TCP粘包' })">举报</a>
</div>
        