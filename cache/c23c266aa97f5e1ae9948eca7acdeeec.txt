<!----> <meta itemprop="headline" content="WebSocket太笨重？试试SSE的轻量级魅力！"> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"> <meta itemprop="datePublished" content="2024-12-25T01:45:28.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="秋天的一阵风"> <meta itemprop="url" content="https://juejin.cn/user/3588413946594925"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-b21437b8="">
            WebSocket太笨重？试试SSE的轻量级魅力！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-b21437b8=""><div class="author-info-box" data-v-b21437b8=""><div class="author-name" data-v-b21437b8=""><a href="/user/3588413946594925/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-b21437b8=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    秋天的一阵风
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-b21437b8=""><time datetime="2024-12-25T01:45:28.000Z" title="Wed Dec 25 2024 01:45:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-b21437b8="">
                    2024-12-25
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-b21437b8=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-b21437b8=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-b21437b8=""></circle></svg> <span class="views-count" data-v-b21437b8="">
                    8,741
                  </span> <span class="read-time" data-v-b21437b8=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-b21437b8=""><rect width="16" height="16" fill="none" data-v-b21437b8=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-b21437b8=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-b21437b8=""></path></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-b21437b8=""></div> <!----> <!----></div> <!----> <!----> <!----> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/img/banner.a5c9f88.jpg" style="width:100%;height:auto;display:block;" data-v-b21437b8=""> <div id="article-root" itemprop="articleBody" class="main" data-v-b21437b8=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">一、 前言</h2>
<p><strong></strong></p><p align="center"><strong>Hello~ 大家好。我是秋天的一阵风~</strong></p><p></p>
<p>关注我时间长一点的同学们应该会了解，我最近算是跟旧项目 <strong>“较上劲”</strong> 了哈哈哈。</p>
<p>刚发布了一篇清除项目里的“僵尸”文件文章，这不，我又发现了旧项目上的一个问题。请听我慢慢说来~</p>
<p>在2024年12月18日的午后，两点十八分，阳光透过窗帘的缝隙，洒在键盘上。我像往常一样，启动了那个熟悉的本地项目。浏览器的<code>network</code>面板静静地打开，准备迎接那个等待修复的bug。就在这时，一股尿意突然袭来，我起身，走向了厕所。</p>
<p>当我回来，坐回那把椅子，眼前的一幕让我愣住了。<code>network</code>面板上，不知何时，跳出了一堆<code>http请求</code>，它们像是一场突如其来的雨，让人措手不及。我的头皮开始发麻，那种麻，是那种从心底里涌上来的，让人无法忽视的麻。这堆请求，它们似乎在诉说着什么，又或许，它们只是在提醒我，这个世界，有时候，比我们想象的要复杂得多。</p>
<p>好了，矫情的话咱不说了，直接步入正题。😄😄😄</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d22241ac253342f1ab2716d9ec6f14d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56eL5aSp55qE5LiA6Zi16aOO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742374648&amp;x-signature=nunUahXwA2nkogR2WKrmDD9RxMU%3D" alt="image.png" width="50%" loading="lazy">
<p>在查看代码以后发现这些频繁的请求是因为我们的项目首页有一个<strong>待办任务数量和消息提醒数量</strong>的展示，所以之前的同事使用了<strong>定时器</strong>，每隔十秒钟发送一次请求到后端接口拿数据，这也就是我们常说的<strong>轮询做法</strong>。</p>
<h3 data-id="heading-1">1. 轮询的缺点</h3>
<p>我们都知道轮询的缺点有几种：</p>
<p><strong>资源浪费</strong>：</p>
<ul>
<li><strong>网络带宽</strong>：频繁的请求可能导致不必要的网络流量，增加带宽消耗。</li>
<li><strong>服务器负载</strong>：每次请求都需要服务器处理，即使是空返回，也会增加服务器的CPU和内存负载。</li>
</ul>
<p><strong>用户体验</strong>：</p>
<ul>
<li><strong>界面卡顿</strong>：频繁的请求和更新可能会造成用户界面的卡顿，影响用户体验。</li>
</ul>
<h3 data-id="heading-2">2. websocket的缺点</h3>
<p>那么有没有替代轮询的做法呢？ 聪明的同学肯定会第一时间想到用<code>websocket</code>，但是在目前这个场景下我觉得使用<code>websocket</code>是显得有些笨重。我从以下这几方面对比：</p>
<ol>
<li>
<p><strong>客户端实现</strong>：</p>
<ul>
<li>WebSocket 客户端实现需要处理连接的建立、维护和关闭，以及可能的重连逻辑。</li>
<li>SSE 客户端实现相对简单，只需要处理接收数据和连接关闭。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：</p>
<ul>
<li>WebSocket 适用于需要双向通信的场景，如聊天应用、在线游戏等。</li>
<li>SSE 更适合单向数据推送的场景，如股票价格更新、新闻订阅等。</li>
</ul>
</li>
<li>
<p><strong>实现复杂性</strong>：</p>
<ul>
<li>WebSocket 是一种全双工通信协议，需要在客户端和服务器之间建立一个持久的连接，这涉及到更多的编程复杂性。</li>
<li>SSE 是单向通信协议，实现起来相对简单，只需要服务器向客户端推送数据。</li>
</ul>
</li>
<li>
<p><strong>浏览器支持</strong>：</p>
<ul>
<li>尽管现代浏览器普遍支持 WebSocket，但 SSE 的支持更为广泛，包括一些较旧的浏览器版本。</li>
</ul>
</li>
<li>
<p><strong>服务器资源消耗</strong>：</p>
<ul>
<li>WebSocket 连接需要更多的服务器资源来维护，因为它们是全双工的，服务器需要监听来自客户端的消息。</li>
<li>SSE 连接通常是单向的，服务器只需要推送数据，减少了资源消耗。</li>
</ul>
</li>
</ol>
<h2 data-id="heading-3">二、 详细对比</h2>
<p>对于这三者的详细区别，你可以参考下面我总结的表格：</p>
<p>以下是 WebSocket、轮询和 SSE 的对比表格：</p>



















































































<table><thead><tr><th>特性</th><th>WebSocket</th><th>轮询Polling</th><th>Server-Sent Events (SSE)</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>全双工通信协议，支持服务器和客户端之间的双向通信。</td><td>客户端定期向服务器发送请求以检查更新。</td><td>服务器向客户端推送数据的单向通信协议。</td></tr><tr><td><strong>实时性</strong></td><td>高，服务器可以主动推送数据。</td><td>低，依赖客户端定时请求。</td><td>高，服务器可以主动推送数据。</td></tr><tr><td><strong>开销</strong></td><td>相对较高，需要建立和维护持久连接。</td><td>较低，但频繁请求可能导致高网络和服务器开销。</td><td>相对较低，只需要一个HTTP连接，服务器推送数据。</td></tr><tr><td><strong>浏览器支持</strong></td><td>现代浏览器支持，需要额外的库来支持旧浏览器。</td><td>所有浏览器支持。</td><td>现代浏览器支持良好，旧浏览器可能需要polyfill。</td></tr><tr><td><strong>实现复杂性</strong></td><td>高，需要处理连接的建立、维护和关闭。</td><td>低，只需定期发送请求。</td><td>中等，只需要处理服务器推送的数据。</td></tr><tr><td><strong>数据格式</strong></td><td>支持二进制和文本数据。</td><td>通常为JSON或XML。</td><td>仅支持文本数据，通常为JSON。</td></tr><tr><td><strong>控制流</strong></td><td>客户端和服务器都可以控制消息发送。</td><td>客户端控制请求发送频率。</td><td>服务器完全控制数据推送。</td></tr><tr><td><strong>安全性</strong></td><td>需要wss://（WebSocket Secure）来保证安全。</td><td>需要<a href="https://link.juejin.cn?target=https%3A%2F%2F%25E6%259D%25A5%25E4%25BF%259D%25E8%25AF%2581%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E5%25AE%2589%25E5%2585%25A8%25E3%2580%2582" target="_blank" title="https://%E6%9D%A5%E4%BF%9D%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E3%80%82" ref="nofollow noopener noreferrer">https://来保证请求的安全。</a></td><td>需要SSE通过HTTPS提供，以保证数据传输的安全。</td></tr><tr><td><strong>适用场景</strong></td><td>需要双向交互的应用，如聊天室、实时游戏。</td><td>适用于更新频率不高的场景，如轮询邮箱。</td><td>适用于服务器到客户端的单向数据流，如股票价格更新。</td></tr><tr><td><strong>跨域限制</strong></td><td>默认不支持跨域，需要服务器配置CORS。</td><td>默认不支持跨域，需要服务器配置CORS。</td><td>默认不支持跨域，需要服务器配置CORS。</td></tr><tr><td><strong>重连机制</strong></td><td>客户端可以实现自动重连逻辑。</td><td>需要客户端实现重连逻辑。</td><td>客户端可以监听连接关闭并尝试重连。</td></tr><tr><td><strong>服务器资源</strong></td><td>较高，因为需要维护持久连接。</td><td>较低，但频繁的请求可能增加服务器负担。</td><td>较低，只需要维护一个HTTP连接。</td></tr></tbody></table>
<p>这个表格概括了 WebSocket、轮询和 SSE 在不同特性上的主要对比点。每种技术都有其适用的场景和限制，选择合适的技术需要根据具体的应用需求来决定。</p>
<h2 data-id="heading-4">三、 SSE（Server-Sent Events）介绍</h2>
<p>我们先来简单了解一下什么是<code>Server-Sent Events</code> ？</p>
<p><code>Server-Sent Events (SSE)</code> 是一种允许服务器主动向客户端浏览器推送数据的技术。它基于 <code>HTTP 协议</code>，但与传统的 HTTP 请求-响应模式不同，SSE 允许服务器在建立连接后，通过一个持久的连接不断地向客户端发送消息。</p>
<h3 data-id="heading-5">工作原理</h3>
<ol>
<li>
<p><strong>建立连接</strong>：</p>
<ul>
<li>客户端通过一个普通的 HTTP 请求订阅一个 SSE 端点。</li>
<li>服务器响应这个请求，并保持连接打开，而不是像传统的 HTTP 响应那样关闭连接。</li>
</ul>
</li>
<li>
<p><strong>服务器推送消息</strong>：</p>
<ul>
<li>一旦服务器端有新数据可以发送，它就会通过这个持久的连接向客户端发送一个事件。</li>
<li>每个事件通常包含一个简单的文本数据流，遵循特定的格式。</li>
</ul>
</li>
<li>
<p><strong>客户端接收消息</strong>：</p>
<ul>
<li>客户端监听服务器发送的事件，并在收到新数据时触发相应的处理程序。</li>
</ul>
</li>
<li>
<p><strong>连接管理</strong>：</p>
<ul>
<li>如果连接由于任何原因中断，客户端可以自动尝试重新连接。</li>
</ul>
</li>
</ol>
<p>著名的计算机科学家<strong>林纳斯·托瓦兹（Linus Torvalds）</strong> 曾经说过：<code>talk is cheap ,show me your code</code> 。</p>
<p>我们直接上代码看看效果：</p>
<h3 data-id="heading-6">java代码</h3>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">bind</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">GetMapping</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">bind</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">RequestMapping</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">bind</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">RestController</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">mvc</span>.<span class="hljs-property">method</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">SseEmitter</span>;

<span class="hljs-keyword">import</span> javax.<span class="hljs-property">servlet</span>.<span class="hljs-property">http</span>.<span class="hljs-property">HttpServletRequest</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">IOException</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">ExecutorService</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">Executors</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">TimeUnit</span>;


@<span class="hljs-title class_">RestController</span>
@<span class="hljs-title class_">RequestMapping</span>(<span class="hljs-string">"platform/todo"</span>)
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoSseController</span> {

    private final <span class="hljs-title class_">ExecutorService</span> executor = <span class="hljs-title class_">Executors</span>.<span class="hljs-title function_">newCachedThreadPool</span>();

    @<span class="hljs-title class_">GetMapping</span>(<span class="hljs-string">"/endpoint"</span>)
    public <span class="hljs-title class_">SseEmitter</span> <span class="hljs-title function_">refresh</span>(<span class="hljs-params">HttpServletRequest request</span>) {
        final <span class="hljs-title class_">SseEmitter</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SseEmitter</span>(<span class="hljs-title class_">Long</span>.<span class="hljs-property">MAX_VALUE</span>);
        executor.<span class="hljs-title function_">execute</span>(() -&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// 无限循环发送事件，直到连接关闭</span>
                   <span class="hljs-comment">// 发送待办数量更新</span>
                    emitter.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">SseEmitter</span>.<span class="hljs-title function_">event</span>().<span class="hljs-title function_">data</span>(<span class="hljs-number">5</span>));
                    <span class="hljs-comment">// 等待5秒</span>
                    <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">5</span>);
                }
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) {
                emitter.<span class="hljs-title function_">completeWithError</span>(e);
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
                <span class="hljs-comment">// 当前线程被中断，结束连接</span>
                <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">interrupt</span>();
                emitter.<span class="hljs-title function_">complete</span>();
            }
        });
        <span class="hljs-keyword">return</span> emitter;
    }
}
</code></pre>
<h3 data-id="heading-7">前端代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"> <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">'/platform/todo/endpoint'</span>);
    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"evebt:"</span>,event)
    };
    eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'SSE error:'</span>, error);
      eventSource.<span class="hljs-title function_">close</span>();
    };

    <span class="hljs-variable language_">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (eventSource) {
      eventSource.<span class="hljs-title function_">close</span>();
    }
    });

  },
</code></pre>
<h3 data-id="heading-8">改造后的效果</h3>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9dc93fdbace3490eb8f62477f88d5649~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56eL5aSp55qE5LiA6Zi16aOO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742374648&amp;x-signature=fpr8Jokw3nnXoOefNKJlRdRYxJg%3D" alt="image.png" width="50%" loading="lazy">
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15ac7b10e6a445be910b86de2e58b14c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56eL5aSp55qE5LiA6Zi16aOO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742374648&amp;x-signature=6SmLgyD7tZdBZwfF9WxeVDhuUfQ%3D" alt="image.png" width="50%" loading="lazy">
<p>可以看到，客户端只发送了一次http请求，后续所有的返回结果都可以在<code>event.data</code>里面获取，先不谈性能，对于有强迫症的同学是不是一个很大改善呢？</p>
<h2 data-id="heading-9">总结</h2>
<p>虽然<code> SSE</code>（Server-Sent Events）因其简单性和实时性在某些场景下提供了显著的优势，比如在需要服务器向客户端单向推送数据时，它能够以较低的开销维持一个轻量级的连接，但 SSE 也存在一些局限性。例如，它<strong>不支持二进制数据传输</strong>，这对于需要传输图像、视频或复杂数据结构的应用来说可能是一个限制。此外，SSE <strong>只支持文本格式的数据流</strong>，这可能限制了其在某些数据传输场景下的应用。还有，SSE 的兼容性虽然在现代浏览器中较好，但<strong>在一些旧版浏览器中可能需要额外的 polyfill 或者降级方案。</strong></p>
<p>考虑到这些优缺点，我们在选择数据通信策略时，应该基于项目的具体需求和上下文来做出决策。如果项目需要双向通信或者传输二进制数据，WebSocket 可能是更合适的选择。</p>
<p>如果项目的数据更新频率不高，或者只需要客户端偶尔查询服务器状态，传统的轮询可能就足够了。</p>
<p>而对于需要服务器频繁更新客户端数据的场景，SSE 提供了一种高效的解决方案。</p>
<p>总之，选择最合适的技术堆栈需要综合考虑项目的需求、资源限制、用户体验和未来的可维护性。</p></div></div>