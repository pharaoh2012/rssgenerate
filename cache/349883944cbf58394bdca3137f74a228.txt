
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/graphics/p/18982034" title="发布于 2025-07-13 10:32">
    <span role="heading" aria-level="2">TypeScript枚举类型应用：前后端状态码映射的最简方案</span>
    

</a>

        </h2>
        <div class="postbody">
            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="介绍">介绍</h2>
<p>这篇文章来谈一下 TypeScript 中的枚举类型（Enum）以及一些最佳实践。事情的起因是这样的，今天看到自己之前写的一段代码，感觉不是很好，于是想优化一下，期间用到了枚举类型，遂记录一下。为了方便理解，我将原来的例子简化一下。</p>
<h2 id="业务需求">业务需求</h2>
<p>业务需求是这样的：我们要实现一个Job系统，你可以将其想象为Jenkins Job类似的东西，每个Job有一个状态，状态可以是以下几种：</p>
<ul>
<li><code>PENDING</code>：等待执行</li>
<li><code>RUNNING</code>：正在执行</li>
<li><code>SUCCESS</code>：执行成功</li>
<li><code>FAILED</code>：执行失败</li>
<li><code>CANCELED</code>：执行被取消</li>
<li></li>
</ul>
<p>Job的状态信息由后端返回，前端只负责展示，也不需要实时刷新。很简单的需求，对吧？我的原始代码如下：</p>
<h2 id="原始代码">原始代码</h2>
<p>前端数据类型定义， 首先定义一个字面量用来保存Job状态，然后定义一个Job接口来描述Job对象。</p>
<pre><code class="language-typescript">// 定义Job状态字面量
type JobStatus = 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED' | 'CANCELED';

// 每个Job包含id、name和status三个属性
interface Job {
  id: string;
  name: string;
  status: JobStatus;
}
</code></pre>
<p>后端返回数据如下，可以看到后端是用数字类型来表示状态的。</p>
<pre><code class="language-typescript">const jobData = [
  { id: '1', name: 'Job 1', status: 1 }, // PENDING
  { id: '2', name: 'Job 2', status: 2 }, // RUNNING
  { id: '3', name: 'Job 3', status: 3 }, // SUCCESS
  { id: '4', name: 'Job 4', status: 4 }, // FAILED
  { id: '5', name: 'Job 5', status: 5 }, // CANCELED
];
</code></pre>
<p>为了将后端返回的数字类型和前端定义的Job Status对应起来，我又额外写了一个映射函数：</p>
<pre><code class="language-typescript">function mapJobStatus(status: number): JobStatus {
  switch (status) {
    case 1:
      return 'PENDING';
    case 2:
      return 'RUNNING';
    case 3:
      return 'SUCCESS';
    case 4:
      return 'FAILED';
    case 5:
      return 'CANCELED';
    default:
      throw new Error(`Unknown status: ${status}`);
  }
}
</code></pre>
<p>接下来就是展示了，展示Job状态时，用户不想看到全大写的状态，而是想看到首字母大写的状态，所以我又写了一个函数来处理这个问题：</p>
<pre><code class="language-typescript">function getJobDisplayName(status: JobStatus): string {
  return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();
}

/* 转换后的状态字符串如下：
PENDING -&gt; Pending
RUNNING -&gt; Running
SUCCESS -&gt; Success
FAILED -&gt; Failed
CANCELED -&gt; Canceled
*/
</code></pre>
<p>好了，下面我们停下来思考一下，以上这些代码都解决了哪些问题，为什么需要两个转换函数，有没有更好的解决方式？</p>
<h2 id="问题分析">问题分析</h2>
<p>为了完成这个需求，上述代码做了以下几件事：</p>
<ol>
<li>后端状态码到前端状态的转换（1,2,3,4,5 -&gt; PENDING, RUNNING, SUCCESS, FAILED, CANCELED）</li>
<li>前端状态字面量到展示字符串的转换（PENDING, RUNNING, SUCCESS, FAILED, CANCELED -&gt; Pending, Running, Success, Failed, Canceled）</li>
</ol>
<p>对于第一点，可以使用枚举类型来实现，这样就不需要手动维护状态码和状态字面量之间的映射关系了。</p>
<p>对于第二点，原本的实现是将全大写的状态转换为首字母大写的形式，这种转换方式比较简单，但实际业务中，可能会有更复杂的需求，比如用户希望看到不同的展示字符串（例如将<code>RUNNING</code>显示为<code>In progress</code>）。因此，使用一个映射表来处理这种转换会更加灵活。</p>
<h2 id="优化后的代码">优化后的代码</h2>
<p>我们可以使用 TypeScript 的枚举类型来简化代码。首先定义一个枚举来表示 Job 状态：</p>
<pre><code class="language-typescript">enum JobStatus {
  PENDING = 1,
  RUNNING = 2,
  SUCCESS = 3,
  FAILED = 4,
  CANCELED = 5,
}
</code></pre>
<p>这样就可以省去第一个转换函数<code>mapJobStatus</code>，因为枚举本身就提供了状态码到状态字面量的映射，可以直接使用这个枚举来定义 Job 接口：</p>
<pre><code class="language-typescript">interface Job {
  id: string;
  name: string;
  status: JobStatus; // 使用枚举类型
}
</code></pre>
<p>接下来，重写<code>getJobDisplayName</code>, 这里使用typescript的<code>Record</code>类型来创建一个映射表（<code>Record</code>类型相当于一个键值对的映射，只不过键和值都是类型化的），将枚举值映射到展示字符串，与原本的实现方式相比，这种方式更加简洁易维护。</p>
<pre><code class="language-typescript">const getJobDisplayName: Record&lt;JobStatus, string&gt; = {
  [JobStatus.PENDING]: 'Pending',
  [JobStatus.RUNNING]: 'In progress',
  [JobStatus.SUCCESS]: 'Success',
  [JobStatus.FAILED]: 'Failed',
  [JobStatus.CANCELED]: 'Canceled',
};
</code></pre>
<p>最后是调用代码，如下：</p>
<pre><code class="language-typescript">const jobs = [
  { id: '1', name: 'Job 1', status: 1 },
  { id: '2', name: 'Job 2', status: 2 },
  { id: '3', name: 'Job 3', status: 3 },
  { id: '4', name: 'Job 4', status: 4 },
  { id: '5', name: 'Job 5', status: 5 },
];

jobs.forEach((job) =&gt; {
  console.log(
    `Job ID: ${job.id}, Name: ${job.name}, Status: ${
      getJobDisplayName[job.status as JobStatus]
    }`
  );
});
</code></pre>
<p>使用枚举类型的好处是：</p>
<ol>
<li><strong>可读性</strong>：枚举提供了更清晰的语义，</li>
<li><strong>类型安全</strong>：TypeScript 的枚举类型可以确保状态值的合法性，避免了手动维护映射关系的错误。</li>
<li><strong>简化代码</strong>：减少了转换函数的数量，使代码更简洁</li>
<li><strong>易于维护</strong>：如果需要添加新的状态，只需在枚举中添加即可，不需要修改多个地方。</li>
</ol>
<p>有没有更好的实现方式？很想听听大家的想法，欢迎留言讨论。</p>
<p>今天就到这里了，我们明天见。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="ZddSignature">
<div>作者：<a href="http://www.cnblogs.com/graphics/" target="_blank">zdd</a></div>
<div>出处：<a href="http://www.cnblogs.com/graphics/" target="_blank">http://www.cnblogs.com/graphics/</a>
<div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-13 10:33">2025-07-13 10:32</span>&nbsp;
<a href="https://www.cnblogs.com/graphics">前端风云志</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18982034);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18982034', targetLink: 'https://www.cnblogs.com/graphics/p/18982034', title: 'TypeScript枚举类型应用：前后端状态码映射的最简方案' })">举报</a>

        </p>
    