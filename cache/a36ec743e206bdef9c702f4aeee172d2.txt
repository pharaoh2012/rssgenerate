
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyzhangdd/p/18832055" title="发布于 2025-06-05 16:12">
    <span role="heading" aria-level="2">一文搞懂国际化（三）落地实践</span>
    

</a>

			</h2>
 			Posted on 
<span id="post-date" data-last-update-days="0.003603109269675926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-05 16:16">2025-06-05 16:12</span>&nbsp;
<a href="https://www.cnblogs.com/dennyzhangdd">只会一点java</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18832055);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18832055', targetLink: 'https://www.cnblogs.com/dennyzhangdd/p/18832055', title: '一文搞懂国际化（三）落地实践' })">举报</a>
			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><strong>专题目录</strong></p>
<p><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyzhangdd/p/18019586">一文搞懂国际化（一）背景概览</a></p>
<p><a href="https://www.cnblogs.com/dennyzhangdd/p/18354302">一文搞懂国际化（二）架构设计</a></p>
<p><a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-06-05 16:12" href="https://www.cnblogs.com/dennyzhangdd/p/18832055"><span>一文搞懂国际化（三）落地实践</span></a></p>
<p>一文搞懂国际化（四）总结提升</p>
<p>&nbsp;</p>
<h1>一、多语言落地</h1>
<p>按照之前第二节的设计，我们多语言翻译区分静态和动态两大类。静态翻译直接前端实现，动态翻译需要后端实现。下面我们看下详细步骤。</p>
<h2>1.1 前端静态多语言</h2>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605161423847-554646199.png" alt=""></p>
<h3>1.1.1 设计</h3>
<ul>
<li>1.个性化设置语言、时区。</li>
<li>2.登录后/设置完后，更新设置缓存。</li>
<li>3.前端读取缓存配置从本地语言包中选择制定语言、时区渲染。</li>
</ul>
<h3>1.1.2 使用逻辑</h3>
<ul>
<li>1.用户设置的</li>
<li>2.未设置，取系统的（APP取手机端的、web浏览器）</li>
<li>3.系统取不到，兜底默认中文（apollo可配置）</li>
</ul>
<h3>1.1.3 实现细节</h3>
<p>前端没啥特别的，根据不同前端（手机端APP、web浏览器）缓存使用不同技术即可，不展开细讲。</p>
<p>&nbsp;</p>
<h2>1.2后端动态多语言</h2>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605161523513-853852152.png" alt=""></p>
<h3>1.2.1 设计</h3>
<ul>
<li>1.后端应用启动时，缓存一份服务依赖的多语言包数据进内存缓存。</li>
<li>2.业务接口请求时，header传参制定语言，返回时（序列化），做翻译。</li>
</ul>
<h3>1.2.2 使用逻辑</h3>
<ul>
<li>1.前端请求header请求带过来的（用户设置/客户端local系统跟随）</li>
<li>2.未设置，兜底默认中文（apollo可配置）</li>
</ul>
<h3>1.2.3 实现细节</h3>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>二、时区时间改造</h1>
<h2>2.1 前后端接口改造</h2>
<h3>2.1.1 方案描述</h3>
<p><img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241018154620112-1689119964.jpg" alt=""></p>
<p>方案回顾：重新部署一套UTC0环境（<span style="color: rgba(255, 0, 0, 1)"><strong>后端服务、组件、</strong><strong>数据库</strong><strong>、洗数据</strong>）。</span></p>
<ol>
<li>前端：发起请求，传值<span style="color: rgba(255, 0, 0, 1)"><strong>ISO格式</strong>时间，<span style="color: rgba(0, 0, 0, 1)">例如：韩国东九区时间“2024-01-12T09:00:00+09:00”。ISO8601格式的时间（上跳第一章第三节），是为了有更好的可读性，且能表示唯一时间。</span></span></li>
<li>后端：请求到后端时，在入参接收时，框架把<span style="color: rgba(255, 0, 0, 1)"><strong>本地时区时间转换为系统默认时区（UTC0）的时间</strong>。<span style="color: rgba(0, 0, 0, 1)">（图中UTC9→UTC0）</span></span></li>
<li>后端：执行业务逻辑，数据落库（UTC0）。</li>
<li>后端：请求返回在序列化时，框架统一<span style="color: rgba(255, 0, 0, 1)"><strong>在序列化时返回</strong><span style="color: rgba(0, 0, 0, 1)">ISO零时区时间。</span></span></li>
<li>前端：拿到后端返回的数据，接收ISO时间<span style="color: rgba(255, 0, 0, 1)"><strong>自动转成客户端本地时区时间</strong><span style="color: rgba(0, 0, 0, 1)">，格式化后展示。</span></span></li>
</ol>
<h3>&nbsp;2.1.2 实现细节</h3>
<h4><strong>一、前端处理</strong></h4>
<p>1、接口入参格式化</p>
<p>dayjs <strong>默认本地时区的ISO-8601格式时间</strong></p>
<p><strong><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605152550555-1425394455.png" alt=""></strong></p>
<p>2、返回数据格式化方法</p>
<p>dayjs <strong>转为当地时区并格式化显示</strong></p>
<p><strong><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605152623633-1123060249.png" alt=""></strong></p>
<h4><strong>二、后端处理</strong></h4>
<p><strong>接口传输用OffsetDateTime即可表示瞬时时区偏移。</strong></p>
<ul>
<li>目前：使用LocalDateTime接收，对应数据库timestamp。</li>
<li>完美：使用OffsetDateTime接收，对应数据库timestampz，这个方案需要<strong>改数据库字段类型和Java类型</strong>，更加彻底，但是成本更大。</li>
</ul>
<p>Json格式的Spring默认使用了Jackson序列化和反序列化。由于LocalDateTime本生不带时区，现在想要转换时间，我们需要对LocalDateTime进行增强处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605152857898-1908774191.png" alt=""></p>
<p><strong>1.入参解析</strong></p>
<p><strong>1）base-mybatis查询map入参</strong>：LocalDateTime。QueryParamUtils的castType方法：</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605152956145-841417459.png" alt=""></p>
<p><strong>2）入参单个时间String</strong>：--&gt;后端LocalDateTime接收的情况，需要<strong>配置全局的日期转换器</strong>。借用Spring的启动机制加载进去。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153036613-415966257.png" alt=""></p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153059987-2092108434.png" alt=""></p>
<p><strong>3）json请求</strong>（<span class="treeLabel stringLabel">Content-Type=<span class="objectBox objectBox-string">application/json）：JSON反序列化。LocalDateTime Jackson默认反序列化包中已支持“2024-01-12T00:00:00Z”，只需要增强处理带时区的“+08:00”。</span></span></p>
<p>UTCLocalDateTimeDeserializer extends JsonDeserializer&lt;LocalDateTime&gt; implements ContextualDeserializer</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153211496-1761319735.png" alt=""></p>
<p>&nbsp;</p>
<p><strong>2.返回数据</strong></p>
<p><strong>JSON序列化：</strong>返回类型都是JSON格式的，直接在序列化方法中转换“2024-01-12T00:00:00Z”。即可。</p>
<p>继承JsonSerializer&lt;LocalDateTime&gt; 实现ContextualSerializer接口。定义LocalDateTime的序列化对象。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153344428-1924513877.png" alt=""></p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153351474-898899730.png" alt=""></p>
<h2>2.2&nbsp; 云边协同</h2>
<h3>2.2.1&nbsp;方案描述</h3>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153731052-2011748388.png" alt=""></p>
<p>步骤：</p>
<p>1）业务应用系统指令下发给IOT</p>
<p>2）IOT协议下发MQTT给到边缘端，</p>
<p>3）边缘端执行完后再协议上报给IOT</p>
<p>4）IOT结果上报给业务应用系统</p>
<h3>2.2.2 实现细节</h3>
<ul>
<li>边缘端、设备都设置成<span style="color: rgba(255, 0, 0, 1)"><strong>本地时区</strong>。<strong>边缘框架提供一个时区设置的通用协议</strong></span>，供引擎和设备同步时间时区用。</li>
<li>云边交互协议：普通下发、上报的协议、云边同步事件，创建时间，修改时间，业务操作时间，<span style="color: rgba(255, 0, 0, 1)"><strong>必须全部使用时间戳</strong></span>。</li>
<li>边端设置<span style="color: rgba(255, 0, 0, 1)"><strong>本地时区</strong></span>。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605153956505-1761822211.png" alt=""></p>
<p><strong>边端时区设置</strong></p>
<p>1、边缘引擎需要支持系统时区设置，包括操作系统、PG、Clickhouse需要保持一致（前期没有就只能手动设置）。</p>
<p>1.1 PG 默认跟随服务器时区（因为挂载了宿主机的timezone，所以修改宿主机时区即可）</p>
<p>1.2 CK 默认跟随服务器时区，需要更新镜像，移除配置文件指定时区（因为挂载了宿主机的timezone，所以修改宿主机时区即可）</p>
<p>考虑到日志分析便利性、技术实现的复杂度，<span style="color: rgba(255, 0, 0, 1)"><strong>直接修改边缘引擎系统时间</strong></span>是最合适的。</p>
<p>时区设置功能建议设计在 "边缘引擎主机管理" ，设备安装交付时统一设置，边缘引擎出厂<span style="color: rgba(255, 0, 0, 1)"><strong>默认UTC 8</strong></span>。</p>
<p><strong>边缘设备</strong></p>
<p>边端跟设备 交互都是时间戳，很标准的时间，不用修改。</p>
<p>不同业务用的设备都不一样，需要找硬件产品梳理。</p>
<p>注：</p>
<p>这里可能需要<span style="color: rgba(255, 0, 0, 1)"><strong>边缘框架提供一个时区设置的通用协议</strong></span>。</p>
<p>实际操作：----需要跟硬件嵌软沟通确认。</p>
<ul>
<li>旧设备要刷一下嵌软，刷成UTC0。</li>
<li>新设备统一固件，UTC0。</li>
</ul>
<h2>2.3&nbsp;&nbsp;大数据统计</h2>
<h3>2.3.1 场景描述</h3>
<p>典型应用场景：</p>
<ul>
<li>明细类： 通过前端传递时间 通过<strong>sql 方式，大数据网关查询明细表。</strong></li>
<li>聚合类： 如果是按天统计提前<strong>聚合跑数，大数据网关查询查询聚合表</strong>。</li>
</ul>
<p>大数据目前方案：按某原表字段，按天聚合，每小时跑一遍全量数据。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605155103720-1170848951.png" alt=""></p>
<p>&nbsp;</p>
<h3>2.3.2 实现细节</h3>
<p>业务原表-时间字段同步到大数据<span style="color: rgba(255, 0, 0, 1)"><strong>ODS层，做时区转换</strong></span>。</p>
<ul>
<li>方案1：<strong>原字段修改转换后数据</strong>：增量数据写Kafka时就转换时区（按照某业务区域划分时区）。后续有时区切换，源库变时间，大数据统一全量同步。----大数据分层表不变。</li>
<li>方案2：<strong>加表存储转换后数据</strong>：同步消费时去在ODS层再加一层表，doris、PG存储都需要增加一倍的表。较为繁琐，但原始业务数据保留下来。</li>
</ul>
<p>方案1如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605155326398-1134732386.png" alt=""></p>
<h2>2.4 后端定时任务</h2>
<h3>2.4.1 场景分析</h3>
<p>XXL-JOB中配置的、直接java代码程序启动线程。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605155726112-1040863290.png" alt=""></p>
<p>1.指定<strong>某时间点执行（低频执行）</strong>：由于数据统计期望根据猪场级别统计，而每个猪场可能在不同时区，会出现根据时间段的<strong><span style="color: rgba(255, 0, 0, 1)">时间偏移</span></strong>，导致数据统计不正确，需要处理。</p>
<p>2.指定<strong>时间间隔执行（高频轮训）</strong>：高频轮训的任务，例如每1分钟、每5分钟执行一次。<strong>不受时区影响</strong>（时区偏移最小单位为小时级），可以<strong>忽略</strong>不处理。</p>
<h3>2.4.2 实现细节</h3>
<p>针对低频任务（小时级），例如一天只有凌晨12点跑一次数据，或者固定几个时间点执行一次。</p>
<ul>
<li>方案1：所有小时级任务全部配置为一小时执行一次。如果涉及复杂计算，对数据库会增加额外负担且1小时不一定跑的完。---<strong>适合执行时间短（必须小于1小时），对数据库压力不大的任务</strong>。</li>
<li>方案:2：<strong>执行频率变为1分钟一次</strong>，进入任务后，<strong>判定时区转换后的时间点是否匹配</strong>，匹配时再执行。这样执行次数不变，只是增加了开始执行时间的判定逻辑。--<strong>适合执行时间长，对数据库压力大的任务</strong>。方案2如下图：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605160102026-1248290644.png" alt=""></p>
<h2>2.5 数据导入</h2>
<h3>2.5.1 场景描述</h3>
<p>存在需要通过上传EXCEL文件，把某时区的公司业务数据导入系统的场景。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605160307568-493709020.png" alt=""></p>
<p>此时，客户使用系统导入功能，一般EXCEL表格中填的业务时间，肯定是<span style="color: rgba(255, 0, 0, 1)"><strong>本地时间（实际发生时间）</strong></span>。如果直接导入系统，客户的本地时间的时区和服务端数据库的<span style="color: rgba(255, 0, 0, 1)"><strong>时区很有可能不一致，此时时间就错乱</strong>了</span>。</p>
<h3>2.5.2 实现细节</h3>
<ul>
<li>方案1：EXCEL中标明时间字段转换成ISO UTC0时区时间再上传。----要求客户转时间，执行难度大，不采纳。</li>
<li>方案2：请求头带时区，后端转换。具体方案如下图：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605160353929-995016272.png" alt=""></p>
<p>步骤：</p>
<p>1）前端文件上传，EXCEL中时间字段是本地时间。</p>
<p>2）后端解析EXCEL文件，根据请求头中的时区，做时区转换，转换成后端统一时区UTC0时间。</p>
<p>3）UTC0时区时间数据插入数据库。</p>
<h2>2.6 三方通信</h2>
<h3>2.6.1 场景描述</h3>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605160608278-1809120779.png" alt=""></p>
<p>&nbsp;</p>
<p>目前接入的都是UTC8时区的国内系统，问题没有暴露。但是将来<span style="color: rgba(255, 0, 0, 1)"><strong>对接国际化三方系统</strong></span>时，如果还是按照现在的UTC8时间去交互API，如果对接的三方时区不是UTC8，直接传UTC8时区的时间字符串，时间就错乱了。</p>
<h3>2.6.2 实现细节</h3>
<p>不可能要求第三方系统也要改造UTC0时间，因此基于第三方不改造前提下，需要针对第三方配置---&gt;第三方所属时区，接收和返回参数按照时区转化后处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202506/584866-20250605160739024-591390738.png" alt=""></p>
<ul>
<li>开放平台配置第三方是否支持国际化（时间都是时间戳/ISO格式）：如果不支持，<span style="color: rgba(255, 0, 0, 1)"><strong>配置好三方的时区</strong></span>。</li>
<li>第三方不支持国际化的（时间不是时间戳/ISO格式）：例如UTC9时区时间，根据开放平台配置的时区，<span style="color: rgba(255, 0, 0, 1)"><strong>做时间转换</strong></span>。</li>
<li>第三方支持国际化的（时间都是时间戳/ISO格式），<span style="color: rgba(255, 0, 0, 1)"><strong>不需要做转换直接调用</strong></span>即可。</li>
</ul>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    ------------------个人能力有限，大家多交流，一起壮哉我大JAVA！------------------
<p>如果你觉得本文对你有点帮助的话，记得在右下角点个<span>“推荐”</span>哦，博主在此感谢！</p>
</div>
<div class="clear"></div>
</div>
	