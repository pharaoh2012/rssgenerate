
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/LJianYu/p/18678484" title="发布于 2025-01-18 16:02">
    <span role="heading" aria-level="2">动态规划</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在其他博客看到的一句话：计算机归根结底只会做一件事情——穷举；所有的算法都是如何让计算机“聪明”的穷举。</p>
<h2>什么是动态规划</h2>
<p>动态规划是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各个子问题是相互独立的，而动态规划各个子问题是相互关联的。</p>
<h2>自顶向下</h2>
<p>递归是常见的自顶向下的问题。使用斐波那契数进行举例：要求f(10)的结果，需要知道f(9)的结果，之后类推直到需要知道f(1)和f(2)的值，最后逐步返回最终得到结果。<strong>这种从结果找到初始值的思路就叫做自顶向下</strong>。</p>
<p>&nbsp;```</p>
<div>
<div>int Fib(int n)</div>
<div>{</div>
<div>&nbsp; &nbsp; //初始值f(0)=1,f(1)=1</div>
<div>&nbsp; &nbsp; if(n==1||n==2)</div>
<div>&nbsp; &nbsp; return 1;</div>
<br>
<div>&nbsp; &nbsp; return Fib(n-1)+Fib(n-2);</div>



<br>
<div>}</div>



</div>
<p>```</p>
<h2>自底向上</h2>
<p>动态规划是一种自底向上的问题。同样是斐波那契数问题：还是要求f(10)的结果，这次从f(1)和f(2)开始向上求值，直到得到f(10)结果，最后返回结果。<strong>这种从初始条件推到结果得思路就为自顶向下</strong>。</p>
<p>```</p>
<div>
<div>int Fibi(int n)</div>
<div>{</div>
<div>&nbsp; &nbsp; std::vector&lt;int&gt; dp(n,0);</div>
<div>&nbsp; &nbsp; int i=0;</div>
<div>&nbsp; &nbsp; dp[0]=1;</div>
<div>&nbsp; &nbsp; dp[1]=1;</div>
<div>&nbsp; &nbsp; for(i=2;i&lt;n;i++)</div>
<div>&nbsp; &nbsp; {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; dp[i]=dp[i-1]+dp[i-2];</div>
<div>&nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; return dp[n-1];</div>
<div>}</div>


</div>
<p>```</p>
<p>自己认为这两种方式往往同时考虑，得出结果，最后根据实际情况选择具体得实现方式。</p>
<h3>状态转移方程</h3>
<p>状态转移方程其实就是解决问题的核心，上面的dp[i]=dp[i-1]+dp[i-2]就是状态转移方程。</p>
<h2>动态规划示例问题</h2>
<h3>爬楼梯题目 ：</h3>
<p>https://leetcode.com/problems/climbing-stairs/</p>
<p>有N级楼梯，一次可以爬1级或2级，问有几种爬法到顶。</p>
<p>解题思路：设定楼梯级数推理，得到结果类似斐波那契数列。</p>
<p>```</p>
<div>int climbStairs(int n)</div>
<div>{</div>
<div>&nbsp; &nbsp; std::vector&lt;int&gt; dp(n,0);</div>
<div>&nbsp; &nbsp; int i=0;</div>
<div>&nbsp; &nbsp; dp[0]=1;</div>
<div>&nbsp; &nbsp; dp[1]=2;</div>
<div>&nbsp; &nbsp; for(i=2;i&lt;n;i++)</div>
<div>&nbsp; &nbsp; {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; dp[i]=dp[i-1]+dp[i-2];</div>
<div>&nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; return dp[n-1];</div>
<div>}</div>
<p>```</p>
<h3>问题优化（滚动数组）</h3>
<p>根据对上述算法的分析，发现并不需要列举每个数组，只需要对三个状态数据保存即可。使用滚动数组的思想进行优化：</p>
<p>```</p>
<div>
<div>int Fibi(int n)</div>
<div>{</div>
<div>&nbsp; &nbsp; int dp;</div>
<div>&nbsp; &nbsp; int i=0,</div>
<div>&nbsp; &nbsp; pre1=1,</div>
<div>&nbsp; &nbsp; pre2=2;</div>
<div>&nbsp; &nbsp; for(i=2;i&lt;n;i++)</div>
<div>&nbsp; &nbsp; {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; dp=pre2+pre1;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; pre1=pre2;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; pre2=dp;</div>
<div>&nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; return dp;</div>
<div>}</div>

</div>
<p>```</p>
<p>滚动数组简单的理解就是让数组滚动起来，每次使用固定的几个空间存储，来达到压缩、节省存储空间的作用。</p>
<p>&nbsp;</p>
<h2>写到最后</h2>
<p>最后插一句，斐波那契数列其实可以直接使用<strong>公式</strong>得出结果。</p>
<p>还有这次的博客参考文章较少，很多有主观思想的存在，希望大佬即时指出问题，非常感谢。</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<h2>参考文章：</h2>
<p>https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp#dynamic-programming</p>
<p>https://mp.weixin.qq.com/s?__biz=MzI2OTE0ODY5Mw==&amp;mid=2247525996&amp;idx=1&amp;sn=3d76f5fc2feb0559b4c92949799975fa&amp;chksm=ebd22c9d8f67e1092763fb3e582a7141482e85220e61e5a359775545e902954f3228873b3b53&amp;scene=27</p>
<p>https://blog.csdn.net/qq_41655898/article/details/120174686</p>
<p>https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145</p>
<p>https://www.cnblogs.com/overxus/p/18167834</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010028667122685185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 16:02">2025-01-18 16:02</span>&nbsp;
<a href="https://www.cnblogs.com/LJianYu">JianYuBlog</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678484" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678484);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678484', targetLink: 'https://www.cnblogs.com/LJianYu/p/18678484', title: '动态规划' })">举报</a>
</div>
        