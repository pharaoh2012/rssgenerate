
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18388543/use_ffmpeg" title="发布于 2025-07-30 15:47">
    <span role="heading" aria-level="2">ffmpeg使用入门</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        ffmpeg是音视频处理领域的瑞士军刀，本文简单介绍了在windows下基于ffmpeg开发的入门知识，并结合实例介绍了下三个主要工具的基本用法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1 ffmpeg安装</h1>
<h2>1.1 安装vcpkg</h2>
<p>直接从github上下载Release版本，并进行安装</p>
<div class="cnblogs_code">
<pre>https:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">github.com/microsoft/vcpkg</span></pre>
</div>
<p>从GitHub克隆vcpkg存储库。存储库包含用于获取vcpkg可执行文件的脚本，以及由vcpkg社区维护的特选开放源代码库的注册表。要执行此操作，请运行：</p>
<div class="cnblogs_code">
<pre>git clone https:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">github.com/microsoft/vcpkg.git</span></pre>
</div>
<p>vcpkg特选注册表是一组数量超过2000个的开源库。 这些库已通过vcpkg的持续集成管道进行验证，可以协同工作。虽然vcpkg存储库不包含这些库的源代码，但它保存方案和元数据，以便在系统中生成和安装它们。</p>
<p>导航到<code>vcpkg</code>目录并执行启动脚本：</p>
<div class="cnblogs_code">
<pre>cd vcpkg &amp;&amp; bootstrap-vcpkg.bat</pre>
</div>
<p>启动脚本执行先决条件检查并下载vcpkg可执行文件。就这么简单，vcpkg已安装并可供使用。</p>
<p>配置VCPKG_ROOT环境变量。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">set</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VCPKG_ROOT=C:\path\to\vcpkg</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 0, 255, 1)">set</span> PATH=%VCPKG_ROOT%;%PATH%</pre>
</div>
<p>以这种方式设置环境变量只会影响当前终端会话。若要使这些更改在所有会话中永久存在，请通过“Windows 系统环境变量”面板进行设置。</p>
<h2>1.2 安装其他库</h2>
<p>一切准备就绪，在cmd命令行执行如下命令安装ffmpeg静态库：</p>
<div class="cnblogs_code">
<pre>vcpkg.exe install ffmpeg:x86-windows-<span style="color: rgba(0, 0, 255, 1)">static</span></pre>
</div>
<p>在cmd命令行执行如下命令安装ffmpeg动态库：</p>
<div class="cnblogs_code">
<pre>vcpkg.exe install ffmpeg:x86-windows</pre>
</div>
<p>安装过程如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202408/465567-20240830200824713-2092416895.png" alt="" width="1126" height="301" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>使用vcpkg list可以列出当前所有安装的库，使用vcpkg remove可以卸载安装的库。</p>
<h2>1.3 exe文件获取</h2>
<p>vcpkg install ffmpeg默认不会安装ffmpeg.exe等工具程序，它只安装了作为库使用的 FFmpeg C/C++开发接口，如：avcodec、avformat、avutil、swscale等.lib/.dll，以及include/*/*.h头文件，因为vcpkg的目标是为C/C++项目提供开发依赖（SDK/库），而不是提供命令行工具（像ffmpeg.exe这种完整可执行程序）。要想使用ffmpeg.exe这种命令行工具，可以从官网<a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener nofollow">https://ffmpeg.org/download.html</a>下载预编译版本：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250729111127390-829604429.png" alt="image" width="419" height="380" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>如下载 “release full”版本，解压后会包含ffmpeg.exe、ffplay.exe、ffprobe.exe三个可执行文件，将其路径添加到环境变量PATH中即可在cmd命令行直接使用这三个命令。</p>
<h1>2 命令使用介绍</h1>
<h2>2.1 ffmpeg.exe</h2>
<h3>1. 查看帮助</h3>
<p><strong>-h，-?，-help，--help [arg]</strong>：显示帮助。可以指定可选参数来打印有关特定项目的帮助，如果未指定参数 arg，则仅显示基本工具选项，若指定参数，arg 可能值为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250729114012942-575775992.png" alt="image" width="690" height="379" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p data-pid="OzlERYiH">long：除了基本工具选项之外，还打印高级工具选项。</p>
<p data-pid="OzlERYiH">full：输出完整的选项列表，包括编码器、解码器、解复用器、复用器、过滤器等的共享和私有选项。</p>
<p data-pid="OzlERYiH">type=name：输出相应类型的相关参数。如：decoder=msmpeg4v2，输出有关名为msmpeg4v2编码器的详细信息。</p>
<div class="cnblogs_code">
<pre>Decoder msmpeg4v2 [MPEG-<span style="color: rgba(128, 0, 128, 1)">4</span> part <span style="color: rgba(128, 0, 128, 1)">2</span> Microsoft variant version <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]:
    General capabilities: horizband dr1
    Threading capabilities: none</span></pre>
</div>
<p>接下来还有以下帮助选项</p>
<p data-pid="cRvmkgZl"><strong>-version</strong>：显示查看版本（包括子模块的详细版本信息）。</p>
<p data-pid="cRvmkgZl"><strong>-muxers</strong>：显示所有支持的封装格式（如mp4、mkv）</p>
<p><strong>-demuxers</strong>：显示所有支持的解封装格式</p>
<p><strong>-devices</strong>：显示支持的音视频输入/输出设备</p>
<p><strong>-decoders：</strong>显示所有可用的解码器</p>
<p><strong>-encoders：</strong>显示所有可用的编码器（如H.264、AAC等）</p>
<p data-pid="JZCO0_wn"><strong>-filters</strong>：显示可用过滤器。</p>
<p data-pid="JZCO0_wn"><strong>-pix_fmts：</strong>显示支持的像素格式（如yuv420p，rgb24）</p>
<p data-pid="PK20HGT2"><strong>-layouts</strong>：显示标准的音频通道布局（如stereo，5.1）</p>
<p data-pid="9dtal5sV"><strong>-sample_fmts</strong>：显示音频采样格式（如s16，flt，dbl）</p>
<p data-pid="RYAgcI1d">更多详细命令参数见官方文档及后续部分介绍，如果希望将帮助文档保存到文件中，可以输入ffmpeg -h full &gt; ffmpeg_h_full.log命令，将输出结果重定向到一个文件中，然后再打开该文件即可查看完整的帮助文档。</p>
<h3>2. 命令执行常用参数</h3>
<p><strong>-y：</strong>若输出目录已存在同名同容器格式的文件，直接输出当前文件将其覆盖而不再询问。</p>
<p><strong>-n：</strong>不要覆盖输出文件，如果已经存在同名同容器格式的文件，立即结束运行，效果与 -y 相反。</p>
<p><strong>-f：</strong>强制设定文件格式，需使用能力集列表中的名称（缺省是根据扩展名选择的）。</p>
<p><strong>-hide_banner：</strong>隐藏FFmpeg版本号及一些描述信息。</p>
<p><strong>-itsoffset：</strong>用于指定输入文件的偏移时间，后接时间值，正值向后偏移，负值向前偏移，可以对齐多个输入文件的时间轴，使它们在合并或处理时保持同步。</p>
<h3>3. 视频帧操作</h3>
<p>（1）基本时间剪辑</p>
<p data-pid="C5KJYgSf">-ss：设置媒体文件的起始时间，如想要从视频的2秒开始剪切处理，我们输入“-ss 2”，如想要更精确的时间也可以，如“-ss 1:23.789”表示设置从1分23秒789毫秒开始。</p>
<p data-pid="yfl3n5Bp">-t：设置媒体文件的<strong>持续时间</strong>，用法同上面-ss ，如“-t 0:13.234”表示持续13秒234毫秒。</p>
<p data-pid="eiqNB8h9">-to：设置媒体文件的<strong>截止时间</strong>，用法与前两个相同，-to和-t是互斥的，并且-t具有优先权，两者不能同时出现使用。</p>
<div class="cnblogs_code">
<pre>ffmpeg.exe -ss <span style="color: rgba(128, 0, 128, 1)">0</span>:<span style="color: rgba(128, 0, 128, 1)">10</span> -t <span style="color: rgba(128, 0, 128, 1)">0</span>:<span style="color: rgba(128, 0, 128, 1)">5</span> -i .\zhouxingchi.mp4 -c copy out.mp4</pre>
</div>
<p>如以上命令将mp4文件从10秒处开始截取并持续5秒，最后将该部分另存到out.mp4文件。</p>
<p>通常将-ss 、-t和-to放在-i之前，这些参数用于指定输入文件的开始时间（-ss）、持续时间（-t）或结束时间（-to），因此它们需要在输入文件（-i）之前进行设置，以确保正确地应用到指定的输入文件上，以防混乱。</p>
<p>（2）截取视频中某帧</p>
<div class="cnblogs_code">
<pre>ffmpeg -ss <span style="color: rgba(128, 0, 128, 1)">00</span>:<span style="color: rgba(128, 0, 128, 1)">00</span>:<span style="color: rgba(128, 0, 128, 1)">10</span> -i zhouxingchi.mp4 -frames:v <span style="color: rgba(128, 0, 128, 1)">1</span> -q:v <span style="color: rgba(128, 0, 128, 1)">2</span> out.jpg</pre>
</div>
<p>-ss 00:00:10：跳到第 10 秒，-frames:v 1：只保存一帧，-q:v 2：图像质量（1 为最好，31 最差，建议用 2~4）。</p>
<p>（3）导出片段视频帧</p>
<div class="cnblogs_code">
<pre>ffmpeg.exe -ss <span style="color: rgba(128, 0, 128, 1)">13</span> -to <span style="color: rgba(128, 0, 128, 1)">15</span> -i .\zhouxingchi.mp4 .\out\%03d.png</pre>
</div>
<p>导出从视频第13秒到15秒这两秒内所有帧图片。该命令还可以增加-vf "fps=1"参数，表示每秒截一帧：</p>
<div class="cnblogs_code">
<pre>ffmpeg.exe -ss <span style="color: rgba(128, 0, 128, 1)">13</span> -to <span style="color: rgba(128, 0, 128, 1)">20</span> -i .\zhouxingchi.mp4 -vf <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">fps=1</span><span style="color: rgba(128, 0, 0, 1)">"</span> .\out\%03d.png</pre>
</div>
<h3>4. 录屏操作</h3>
<p>直接使用ffmpeg内置的gdigrab对桌面进行录屏</p>
<div class="cnblogs_code">
<pre>ffmpeg -f gdigrab -i desktop -pix_fmt yuv420p D:\out.mp4</pre>
</div>
<p>这个命令使用FFmpeg工具来捕获Windows桌面并将其保存为一个mp4格式的视频文件。“-f gdigrab”表示使用 GDI (Graphics Device Interface) 来捕获屏幕；“-i desktop”指定要捕获的对象为desktop即桌面内容；“-pix_fmt yuv420p”指定输出视频的像素格式为 YUV 4:2:0 planar。</p>
<h3>5.&nbsp;解封装与解码</h3>
<p>通过ffmpeg命令，可以将MP4视频转为H.264流（裸流.264文件），然后再提取成YUV数据文件（原始像素数据）。</p>
<p>（1）将MP4转为H.264裸流</p>
<div class="cnblogs_code">
<pre>ffmpeg -i out.mp4 -c:v libx264 -bsf:v h264_mp4toannexb -an -f h264 out.<span style="color: rgba(128, 0, 128, 1)">264</span></pre>
</div>
<p>-c:v libx264：使用H.264编码器（libx264）对视频重新编码。如果不想重新编码，可以用-c:v copy保留原始流。<br>-bsf:v h264_mp4toannexb：将MP4封装格式中的H.264转为 Annex B 格式（常见裸流格式）。<br>-an：去除音频流，仅保留视频。<br>-f h264：指定输出文件格式为H.264裸流。</p>
<p>（2）将H.264裸流转为YUV数据</p>
<p>接着H.264裸流中的编码数据需要解码后才能获得原始YUV数据。</p>
<div class="cnblogs_code">
<pre>ffmpeg -i out.<span style="color: rgba(128, 0, 128, 1)">264</span> -pix_fmt yuv420p -vsync <span style="color: rgba(128, 0, 128, 1)">0</span> out.yuv</pre>
</div>
<p>&nbsp;-i output.264：输入文件为 H.264 裸流。</p>
<p>-pix_fmt yuv420p：指定输出像素格式为 YUV 4:2:0（标准格式）。</p>
<p>-vsync 0：禁用帧同步，确保输出的帧数与输入一致。</p>
<p>output.yuv：输出文件名。</p>
<p>（3）直接从MP4提取YUV</p>
<p>如果不需要中间的 H.264 裸流步骤，可以直接从 MP4 转为 YUV：</p>
<div class="cnblogs_code">
<pre>ffmpeg -i out.mp4 -pix_fmt yuv420p -fps_mode passthrough out.yuv</pre>
</div>
<h3>6. 码流提取</h3>
<p>（1）提取视频</p>
<p>通过移除音频流，可以单独提取视频使用，保留原始的视频编码。具体命令如下：</p>
<div class="cnblogs_code">
<pre>ffmpeg -i out.mp4 -vcodec copy -an video0.mp4</pre>
</div>
<p>（2）提取音频</p>
<p>利用ffmpeg命令，可轻松实现视频中的音频提取。具体命令如下：</p>
<div class="cnblogs_code">
<pre>ffmpeg -i out.mp4 -acodec copy -vn voice.aac</pre>
</div>
<p>如果需要将AAC音频流直接复制到MP3容器中，则需要执行如下命令：</p>
<h3>7. 添加LOGO</h3>
<p>使用ffmpeg命令将LOGO（例如logo.png）叠加到原始视频文件（例如out.mp4）上，可以通过调整overlay参数的位置来改变LOGO的放置位置。具体命令如下：</p>
<div class="cnblogs_code">
<pre>左上角：ffmpeg -i out.mp4 -i logo.png -<span style="color: rgba(0, 0, 0, 1)">filter_complex overlay out1.mp4
右上角：ffmpeg </span>-i out.mp4 -i logo.png -filter_complex overlay=W-<span style="color: rgba(0, 0, 255, 1)">w</span><span style="color: rgba(0, 0, 0, 1)"> out2.mp4
左下角：ffmpeg </span>-i out.mp4 -i logo.png -filter_complex overlay=<span style="color: rgba(128, 0, 128, 1)">0</span>:H-<span style="color: rgba(0, 0, 0, 1)">h out3.mp4
右下角：ffmpeg </span>-i out.mp4 -i logo.png -filter_complex overlay=W-<span style="color: rgba(0, 0, 255, 1)">w</span>:H-h out4.mp4</pre>
</div>
<p>以上命令中W是视频分辨率中的宽，w是logo文件图片的宽，H是视频分辨率中的高，h是logo文件图片的高。</p>
<h2>2.2 ffplay.exe</h2>
<p>ffplay是基于SDL与ffmpeg库实现的一个轻量级媒体播放器，可以使用它来播放原始的YUV/PCM 数据、编码后的H.264/H.265等数据，封装好的MP4/M4A等数据，还可以播放来自网络的流媒体数据。</p>
<h3>1. 命令行格式</h3>
<p>ffplay [选项] [输入文件路径]。它使用ffmpeg库进行解码和解码，并且可以通过命令行参数来控制播放行为，如调整音量、播放速度、画面比例等。</p>
<h3>2. 常用基本选项</h3>
<p data-pid="wSzMRNUZ"><strong>-x &lt;宽度&gt; 和 -y &lt;高度&gt;</strong>：强制设置视频显示的宽度和高度。</p>
<p data-pid="oMUzl9RV"><strong>-fs</strong>：以全屏模式启动。</p>
<p data-pid="rp3eFhtv"><strong>-an、-vn、-sn</strong>：分别禁用音频、视频和字幕。</p>
<p data-pid="a4nsR_He"><strong>-acodec、-vcodec、-scodec</strong>：分别强制使用设置的音频、视频和字幕解码器来播放。</p>
<p data-pid="OFquJ6Ly"><strong>-threads &lt;个数&gt;</strong>：设置线程个数，可以控制 ffplay 在解码和渲染过程中的并行度，从而提高播放性能。</p>
<p data-pid="zTuPYIIA"><strong>-ss &lt;开始时间&gt;</strong>：从特定的时间点开始播放。</p>
<p data-pid="FnsVj7vg"><strong>-t &lt;持续时间&gt;</strong>：设置播放的持续时间。</p>
<p data-pid="RqjCp9VU"><strong>-vol &lt;音量&gt;</strong>：设置播放的初始音量。</p>
<p data-pid="vXVRxdxE"><strong>-vf 和 -af</strong>：应用视频和音频滤镜。</p>
<p data-pid="EBbBI6e3"><strong>-autoexit</strong>：视频播放完毕后自动退出。</p>
<p data-pid="YtDiiwyJ"><strong>-loop &lt;循环播放次数&gt;</strong>：指定文件循环播放次数。</p>
<p data-pid="uQd57_56"><strong>-showmode [mode]</strong>：设置显示模式，mode 默认为0显示视频，为1显示音频波形，为2显示音频频谱。</p>
<h3>3. 播放中按键控制</h3>
<div>
<p data-pid="BB6p4uMl">w：切换播放模式，比如在音频波形图、音频频谱图、视频画面之间切换。</p>
<p data-pid="Oiilw85j">s：步进模式，每按一次就播放下一帧图像。</p>
<p data-pid="heOMICcZ">right：快进 10s。</p>
<p data-pid="RGWFPg46">left：快退 10s。</p>
<p data-pid="syIA884n">up：快进 1min。</p>
<p data-pid="u-klm4uE">down：快退 1min。</p>
<p data-pid="NwrshsPo">space：暂停。</p>
<p data-pid="kJ_f4KlI">esc/q：退出播放。</p>
</div>
<h2>2.3 ffprobe.exe</h2>
<p>ffprobe是FFmpeg源码编译后生成的一个可执行程序，可以从媒体文件或网络媒体流中获得音视频及媒体容器的参数信息，用于查看和分析多媒体文件。</p>
<h3>1. 命令行格式</h3>
<p>ffprobe [选项] [ [-i] 输入文件路径]，不加任何选项时输出如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250729142832400-607554220.png" alt="image" width="768" height="195" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>根据ffprobe的输出，视频文件"zhouxingchi.mp4"包含了两个流：一个是视频流，另一个是音频流。</p>
<ul>
<li data-pid="oNxjkG3s">视频流的信息：编解码器 av1 (libdav1d) (Main) (av01 / 0x31307661)、像素格式 yuv420p(tv, bt709)、分辨率 1920x1080、帧率 24 fps、比特率 845 kb/s。</li>
<li data-pid="0S98xWnX">音频流的信息：编解码器 aac (LC) (mp4a / 0x6134706D)、采样率 44100 Hz、stereo(立体声)、比特率 128 kb/s。</li>
</ul>
<h3 data-pid="n3oEYISi">2. 常用基本选项</h3>
<p data-pid="n3oEYISi">-show_format：查看媒体文件的封装信息，输出内容的前半部分和不加选项时的输出一样，后半部分会得到该视频文件的封装文件信息如下所示。</p>
<div>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250729174358443-551762048.png" alt="image" width="530" height="346" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>-show_streams：查看媒体文件的流信息，如下所示其中一条媒体流的信息：</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_983740b0-e863-4787-842f-d5498a3dab33" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_983740b0-e863-4787-842f-d5498a3dab33" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_983740b0-e863-4787-842f-d5498a3dab33" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 0, 1)">[STREAM]
index</span>=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">
codec_name</span>=<span style="color: rgba(0, 0, 0, 1)">av1
codec_long_name</span>=Alliance <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> Open Media AV1
profile</span>=<span style="color: rgba(0, 0, 0, 1)">Main
codec_type</span>=<span style="color: rgba(0, 0, 0, 1)">video
codec_tag_string</span>=<span style="color: rgba(0, 0, 0, 1)">av01
codec_tag</span>=<span style="color: rgba(128, 0, 128, 1)">0x31307661</span><span style="color: rgba(0, 0, 0, 1)">
width</span>=<span style="color: rgba(128, 0, 128, 1)">1920</span><span style="color: rgba(0, 0, 0, 1)">
height</span>=<span style="color: rgba(128, 0, 128, 1)">1080</span><span style="color: rgba(0, 0, 0, 1)">
coded_width</span>=<span style="color: rgba(128, 0, 128, 1)">1920</span><span style="color: rgba(0, 0, 0, 1)">
coded_height</span>=<span style="color: rgba(128, 0, 128, 1)">1080</span><span style="color: rgba(0, 0, 0, 1)">
closed_captions</span>=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">
film_grain</span>=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">
has_b_frames</span>=<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">
sample_aspect_ratio</span>=<span style="color: rgba(128, 0, 128, 1)">1</span>:<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">
display_aspect_ratio</span>=<span style="color: rgba(128, 0, 128, 1)">16</span>:<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">
pix_fmt</span>=<span style="color: rgba(0, 0, 0, 1)">yuv420p
level</span>=<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">
color_range</span>=<span style="color: rgba(0, 0, 0, 1)">tv
color_space</span>=<span style="color: rgba(0, 0, 0, 1)">bt709
color_transfer</span>=<span style="color: rgba(0, 0, 0, 1)">bt709
color_primaries</span>=<span style="color: rgba(0, 0, 0, 1)">bt709
chroma_location</span>=<span style="color: rgba(0, 0, 0, 1)">unspecified
field_order</span>=<span style="color: rgba(0, 0, 0, 1)">unknown
refs</span>=<span style="color: rgba(128, 0, 128, 1)">1</span>
<span style="color: rgba(0, 0, 255, 1)">id</span>=<span style="color: rgba(128, 0, 128, 1)">0x1</span><span style="color: rgba(0, 0, 0, 1)">
r_frame_rate</span>=<span style="color: rgba(128, 0, 128, 1)">24</span>/<span style="color: rgba(128, 0, 128, 1)">1</span></pre>
</div>
<span class="cnblogs_code_collapse">show_streams</span></div>
<p>-show_packets：查看文件的所有数据包信息，一个视频文件由多个数据包组成。</p>
</div>
<p>-show_frames：查看媒体文件的每一帧信息，我们分析其中两个如下所示。如下是音频帧类型，然后key_frame=1表示这是IDR frame，如果key_frame=0表示这是Non-IDR frame。</p>
<p>-select_streams &lt;type&gt;：选择特定类型的流进行显示，&lt;type&gt;可以是v（视频）、a（音频）或s（字幕）。</p>
<p>-of/-print_format &lt;format&gt;：指定输出格式，常用的输出格式有csv、json、flat、xml等。</p>
<div class="cnblogs_code">
<pre>ffprobe.exe -i .\out.mp4 -show_format -show_streams -of json</pre>
</div>
<h2>3 SDK使用Demo实例</h2>
<h2>3.1 SDL编译</h2>
<p>SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X等）的应用软件。该库编译比较简单，直接下载源码使用CMake进行配置编译即可，需要注意的是要确定编译版本是32位还是64位版本，这里编译器用的VS2019，编译的是64位版本。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250730145757818-494487795.png" alt="image" width="471" height="415" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>配置完成后，直接用VS打开生成的工程进行编译即可。</p>
<h2>3.2 基于SDL的视频播放demo</h2>
<p>可以直接在SDL解决方案下添加Console项目，主文件内容如下：</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_7c9e6f19-ddbd-4cbf-acf1-975969403174" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_7c9e6f19-ddbd-4cbf-acf1-975969403174" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_7c9e6f19-ddbd-4cbf-acf1-975969403174" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> <span style="color: rgba(0, 0, 255, 1)">extern</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">C</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> {
</span><span style="color: rgba(0, 128, 128, 1)">  2</span> #include &lt;libavcodec/avcodec.h&gt;
<span style="color: rgba(0, 128, 128, 1)">  3</span> #include &lt;libavformat/avformat.h&gt;
<span style="color: rgba(0, 128, 128, 1)">  4</span> #include &lt;libavutil/imgutils.h&gt;
<span style="color: rgba(0, 128, 128, 1)">  5</span> #include &lt;libswscale/swscale.h&gt;
<span style="color: rgba(0, 128, 128, 1)">  6</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">  7</span> 
<span style="color: rgba(0, 128, 128, 1)">  8</span> <span style="color: rgba(0, 0, 255, 1)">#define</span> SDL_MAIN_HANDLED
<span style="color: rgba(0, 128, 128, 1)">  9</span> #include &lt;SDL2/SDL.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 10</span> #include &lt;iostream&gt;
<span style="color: rgba(0, 128, 128, 1)"> 11</span> 
<span style="color: rgba(0, 128, 128, 1)"> 12</span> <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">argv[])
</span><span style="color: rgba(0, 128, 128, 1)"> 13</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 14</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (argc &lt; <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 15</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">请指定视频文件路径，例如：\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 16</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; argv[<span style="color: rgba(128, 0, 128, 1)">0</span>] &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)"> sample.mp4\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 17</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 18</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 19</span> 
<span style="color: rgba(0, 128, 128, 1)"> 20</span>     <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">char</span> *filepath = argv[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 21</span> 
<span style="color: rgba(0, 128, 128, 1)"> 22</span> <span style="color: rgba(0, 0, 0, 1)">    avformat_network_init();
</span><span style="color: rgba(0, 128, 128, 1)"> 23</span> 
<span style="color: rgba(0, 128, 128, 1)"> 24</span>     AVFormatContext *fmt_ctx =<span style="color: rgba(0, 0, 0, 1)"> nullptr;
</span><span style="color: rgba(0, 128, 128, 1)"> 25</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (avformat_open_input(&amp;fmt_ctx, filepath, nullptr, nullptr) &lt; <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 26</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">无法打开文件: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; filepath &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 27</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 28</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 29</span> 
<span style="color: rgba(0, 128, 128, 1)"> 30</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (avformat_find_stream_info(fmt_ctx, nullptr) &lt; <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 31</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">无法获取视频流信息\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 32</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 33</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 34</span> 
<span style="color: rgba(0, 128, 128, 1)"> 35</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> video_stream_idx = -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (unsigned <span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; fmt_ctx-&gt;nb_streams; ++<span style="color: rgba(0, 0, 0, 1)">i) {
</span><span style="color: rgba(0, 128, 128, 1)"> 37</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (fmt_ctx-&gt;streams[i]-&gt;codecpar-&gt;codec_type ==<span style="color: rgba(0, 0, 0, 1)"> AVMEDIA_TYPE_VIDEO) {
</span><span style="color: rgba(0, 128, 128, 1)"> 38</span>             video_stream_idx =<span style="color: rgba(0, 0, 0, 1)"> i;
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span>             <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)"> 41</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 42</span> 
<span style="color: rgba(0, 128, 128, 1)"> 43</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (video_stream_idx == -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">没有找到视频流\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 45</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 46</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 47</span> 
<span style="color: rgba(0, 128, 128, 1)"> 48</span>     AVCodecParameters *codecpar = fmt_ctx-&gt;streams[video_stream_idx]-&gt;<span style="color: rgba(0, 0, 0, 1)">codecpar;
</span><span style="color: rgba(0, 128, 128, 1)"> 49</span>     <span style="color: rgba(0, 0, 255, 1)">const</span> AVCodec *decoder = avcodec_find_decoder(codecpar-&gt;<span style="color: rgba(0, 0, 0, 1)">codec_id);
</span><span style="color: rgba(0, 128, 128, 1)"> 50</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">decoder) {
</span><span style="color: rgba(0, 128, 128, 1)"> 51</span>         std::cerr &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">找不到解码器\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 54</span> 
<span style="color: rgba(0, 128, 128, 1)"> 55</span>     AVCodecContext *codec_ctx =<span style="color: rgba(0, 0, 0, 1)"> avcodec_alloc_context3(decoder);
</span><span style="color: rgba(0, 128, 128, 1)"> 56</span> <span style="color: rgba(0, 0, 0, 1)">    avcodec_parameters_to_context(codec_ctx, codecpar);
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span> <span style="color: rgba(0, 0, 0, 1)">    avcodec_open2(codec_ctx, decoder, nullptr);
</span><span style="color: rgba(0, 128, 128, 1)"> 58</span> 
<span style="color: rgba(0, 128, 128, 1)"> 59</span>     AVFrame *frame =<span style="color: rgba(0, 0, 0, 1)"> av_frame_alloc();
</span><span style="color: rgba(0, 128, 128, 1)"> 60</span>     AVFrame *rgb_frame =<span style="color: rgba(0, 0, 0, 1)"> av_frame_alloc();
</span><span style="color: rgba(0, 128, 128, 1)"> 61</span>     AVPacket *pkt =<span style="color: rgba(0, 0, 0, 1)"> av_packet_alloc();
</span><span style="color: rgba(0, 128, 128, 1)"> 62</span> 
<span style="color: rgba(0, 128, 128, 1)"> 63</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> width = codec_ctx-&gt;<span style="color: rgba(0, 0, 0, 1)">width;
</span><span style="color: rgba(0, 128, 128, 1)"> 64</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> height = codec_ctx-&gt;<span style="color: rgba(0, 0, 0, 1)">height;
</span><span style="color: rgba(0, 128, 128, 1)"> 65</span>     <span style="color: rgba(0, 0, 255, 1)">enum</span> AVPixelFormat dst_pix_fmt =<span style="color: rgba(0, 0, 0, 1)"> AV_PIX_FMT_YUV420P;
</span><span style="color: rgba(0, 128, 128, 1)"> 66</span> 
<span style="color: rgba(0, 128, 128, 1)"> 67</span>     <span style="color: rgba(0, 0, 255, 1)">struct</span> SwsContext *sws_ctx =<span style="color: rgba(0, 0, 0, 1)"> sws_getContext(
</span><span style="color: rgba(0, 128, 128, 1)"> 68</span>         width, height, codec_ctx-&gt;<span style="color: rgba(0, 0, 0, 1)">pix_fmt,
</span><span style="color: rgba(0, 128, 128, 1)"> 69</span> <span style="color: rgba(0, 0, 0, 1)">        width, height, dst_pix_fmt,
</span><span style="color: rgba(0, 128, 128, 1)"> 70</span> <span style="color: rgba(0, 0, 0, 1)">        SWS_BILINEAR, nullptr, nullptr, nullptr);
</span><span style="color: rgba(0, 128, 128, 1)"> 71</span> 
<span style="color: rgba(0, 128, 128, 1)"> 72</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> num_bytes = av_image_get_buffer_size(dst_pix_fmt, width, height, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 73</span>     uint8_t *buffer = (uint8_t *)av_malloc(num_bytes * <span style="color: rgba(0, 0, 255, 1)">sizeof</span><span style="color: rgba(0, 0, 0, 1)">(uint8_t));
</span><span style="color: rgba(0, 128, 128, 1)"> 74</span>     av_image_fill_arrays(rgb_frame-&gt;data, rgb_frame-&gt;linesize, buffer, dst_pix_fmt, width, height, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 75</span> 
<span style="color: rgba(0, 128, 128, 1)"> 76</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 初始化 SDL</span>
<span style="color: rgba(0, 128, 128, 1)"> 77</span> <span style="color: rgba(0, 0, 0, 1)">    SDL_Init(SDL_INIT_VIDEO);
</span><span style="color: rgba(0, 128, 128, 1)"> 78</span>     SDL_Window *window = SDL_CreateWindow(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">FFmpeg Player</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
</span><span style="color: rgba(0, 128, 128, 1)"> 79</span> <span style="color: rgba(0, 0, 0, 1)">                                          SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
</span><span style="color: rgba(0, 128, 128, 1)"> 80</span> <span style="color: rgba(0, 0, 0, 1)">                                          width, height, SDL_WINDOW_SHOWN);
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span>     SDL_Renderer *renderer = SDL_CreateRenderer(window, -<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span>     SDL_Texture *texture =<span style="color: rgba(0, 0, 0, 1)"> SDL_CreateTexture(renderer,
</span><span style="color: rgba(0, 128, 128, 1)"> 83</span> <span style="color: rgba(0, 0, 0, 1)">                                             SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, width, height);
</span><span style="color: rgba(0, 128, 128, 1)"> 84</span> 
<span style="color: rgba(0, 128, 128, 1)"> 85</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 解码 &amp; 渲染循环</span>
<span style="color: rgba(0, 128, 128, 1)"> 86</span>     <span style="color: rgba(0, 0, 255, 1)">while</span> (av_read_frame(fmt_ctx, pkt) &gt;= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 87</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (pkt-&gt;stream_index ==<span style="color: rgba(0, 0, 0, 1)"> video_stream_idx) {
</span><span style="color: rgba(0, 128, 128, 1)"> 88</span>             <span style="color: rgba(0, 0, 255, 1)">if</span> (avcodec_send_packet(codec_ctx, pkt) == <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 89</span>                 <span style="color: rgba(0, 0, 255, 1)">while</span> (avcodec_receive_frame(codec_ctx, frame) == <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 90</span> <span style="color: rgba(0, 0, 0, 1)">                    sws_scale(sws_ctx,
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span>                               frame-&gt;data, frame-&gt;<span style="color: rgba(0, 0, 0, 1)">linesize,
</span><span style="color: rgba(0, 128, 128, 1)"> 92</span>                               <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, height,
</span><span style="color: rgba(0, 128, 128, 1)"> 93</span>                               rgb_frame-&gt;data, rgb_frame-&gt;<span style="color: rgba(0, 0, 0, 1)">linesize);
</span><span style="color: rgba(0, 128, 128, 1)"> 94</span> 
<span style="color: rgba(0, 128, 128, 1)"> 95</span> <span style="color: rgba(0, 0, 0, 1)">                    SDL_UpdateYUVTexture(texture, nullptr,
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span>                                          rgb_frame-&gt;data[<span style="color: rgba(128, 0, 128, 1)">0</span>], rgb_frame-&gt;linesize[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">],
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span>                                          rgb_frame-&gt;data[<span style="color: rgba(128, 0, 128, 1)">1</span>], rgb_frame-&gt;linesize[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">],
</span><span style="color: rgba(0, 128, 128, 1)"> 98</span>                                          rgb_frame-&gt;data[<span style="color: rgba(128, 0, 128, 1)">2</span>], rgb_frame-&gt;linesize[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 128, 128, 1)"> 99</span> 
<span style="color: rgba(0, 128, 128, 1)">100</span> <span style="color: rgba(0, 0, 0, 1)">                    SDL_RenderClear(renderer);
</span><span style="color: rgba(0, 128, 128, 1)">101</span> <span style="color: rgba(0, 0, 0, 1)">                    SDL_RenderCopy(renderer, texture, nullptr, nullptr);
</span><span style="color: rgba(0, 128, 128, 1)">102</span> <span style="color: rgba(0, 0, 0, 1)">                    SDL_RenderPresent(renderer);
</span><span style="color: rgba(0, 128, 128, 1)">103</span>                     SDL_Delay(<span style="color: rgba(128, 0, 128, 1)">1000</span> / <span style="color: rgba(128, 0, 128, 1)">30</span>); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 简单帧率控制</span>
<span style="color: rgba(0, 128, 128, 1)">104</span> <span style="color: rgba(0, 0, 0, 1)">                }
</span><span style="color: rgba(0, 128, 128, 1)">105</span> <span style="color: rgba(0, 0, 0, 1)">            }
</span><span style="color: rgba(0, 128, 128, 1)">106</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">107</span> <span style="color: rgba(0, 0, 0, 1)">        av_packet_unref(pkt);
</span><span style="color: rgba(0, 128, 128, 1)">108</span> 
<span style="color: rgba(0, 128, 128, 1)">109</span>         SDL_Event <span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">110</span>         SDL_PollEvent(&amp;<span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">111</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">event</span>.type ==<span style="color: rgba(0, 0, 0, 1)"> SDL_QUIT) {
</span><span style="color: rgba(0, 128, 128, 1)">112</span>             <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">113</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">114</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">115</span> 
<span style="color: rgba(0, 128, 128, 1)">116</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 清理</span>
<span style="color: rgba(0, 128, 128, 1)">117</span> <span style="color: rgba(0, 0, 0, 1)">    sws_freeContext(sws_ctx);
</span><span style="color: rgba(0, 128, 128, 1)">118</span> <span style="color: rgba(0, 0, 0, 1)">    av_free(buffer);
</span><span style="color: rgba(0, 128, 128, 1)">119</span>     av_frame_free(&amp;<span style="color: rgba(0, 0, 0, 1)">frame);
</span><span style="color: rgba(0, 128, 128, 1)">120</span>     av_frame_free(&amp;<span style="color: rgba(0, 0, 0, 1)">rgb_frame);
</span><span style="color: rgba(0, 128, 128, 1)">121</span>     av_packet_free(&amp;<span style="color: rgba(0, 0, 0, 1)">pkt);
</span><span style="color: rgba(0, 128, 128, 1)">122</span>     avcodec_free_context(&amp;<span style="color: rgba(0, 0, 0, 1)">codec_ctx);
</span><span style="color: rgba(0, 128, 128, 1)">123</span>     avformat_close_input(&amp;<span style="color: rgba(0, 0, 0, 1)">fmt_ctx);
</span><span style="color: rgba(0, 128, 128, 1)">124</span> 
<span style="color: rgba(0, 128, 128, 1)">125</span> <span style="color: rgba(0, 0, 0, 1)">    SDL_DestroyTexture(texture);
</span><span style="color: rgba(0, 128, 128, 1)">126</span> <span style="color: rgba(0, 0, 0, 1)">    SDL_DestroyRenderer(renderer);
</span><span style="color: rgba(0, 128, 128, 1)">127</span> <span style="color: rgba(0, 0, 0, 1)">    SDL_DestroyWindow(window);
</span><span style="color: rgba(0, 128, 128, 1)">128</span> <span style="color: rgba(0, 0, 0, 1)">    SDL_Quit();
</span><span style="color: rgba(0, 128, 128, 1)">129</span> 
<span style="color: rgba(0, 128, 128, 1)">130</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">131</span> }</pre>
</div>
<span class="cnblogs_code_collapse">main.cpp</span></div>
<p>注意第8行语句，如果不包含该语句编译时会提示错误：</p>
<div class="text-base my-auto mx-auto pt-12 [--thread-content-margin:--spacing(4)] @[37rem]:[--thread-content-margin:--spacing(6)] @[72rem]:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)">
<div class="[--thread-content-max-width:32rem] @[34rem]:[--thread-content-max-width:40rem] @[64rem]:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden relative flex w-full min-w-0 flex-col">
<div class="flex max-w-full flex-col grow">
<div class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-5" dir="auto" data-message-author-role="user" data-message-id="f025f8ac-b46e-4c73-b4cc-1f0f559a17ab">
<div class="flex w-full flex-col gap-1 empty:hidden items-end rtl:items-start">
<div class="user-message-bubble-color relative max-w-[var(--user-chat-width,70%)] rounded-[18px] px-4 py-1.5 data-[multiline]:py-3" data-multiline="">
<div class="whitespace-pre-wrap">
<div class="cnblogs_code">
<pre>MSVCRT.lib(exe_main.obj) : error LNK2001: 无法解析的外部符号 _main</pre>
</div>
<p>在网上查了下原因，因为SDL2在SDL_main.h中定义了如下代码：</p>
</div>
</div>
</div>
</div>
</div>
<div class="mx-[var(--mini-thread-content-inset)]">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">#if</span> defined(SDL_MAIN_NEEDED) || defined(SDL_MAIN_AVAILABLE)
<span style="color: rgba(0, 0, 255, 1)">#define</span> main    SDL_main
<span style="color: rgba(0, 0, 255, 1)">#endif</span></pre>
</div>
<p>它会把main重命名为SDL_main，然后SDL库中会试图用它自己的WinMain入口去调用你的SDL_main，从而接管程序，这在Windows GUI项目中是正常的，但现在用的是控制台项目（需要标准main函数），但是上面的语句已经将main重定向到SDL_main，所以链接时会提示“无法解析的外部符号 _main”。</p>
</div>
</div>
</div>
<p>头文件包含目录配置如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250730154002215-493517913.png" alt="image" width="687" height="264" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>链接器配置如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250730154059343-732649567.png" alt="image" width="730" height="314" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>输入库包含如下：</p>
<div class="cnblogs_code">
<pre>SDL2d.lib;avformat.lib;avcodec.lib;avutil.lib;swscale.lib;</pre>
</div>
<p>为了能在VS环境下直接运行调试，可以在调试选项配置中增加运行库目录到PATH环境变量，并给出要播放的文件为命令参数。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202507/465567-20250730154306805-705636265.png" alt="image" width="798" height="273" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/684158932" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/684158932</a></p>
<p><a href="https://blog.csdn.net/lsb2002/article/details/136568262" target="_blank" rel="noopener nofollow">https://blog.csdn.net/lsb2002/article/details/136568262</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-30 15:48">2025-07-30 15:47</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18388543);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18388543', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18388543/use_ffmpeg', title: 'ffmpeg使用入门' })">举报</a>
</div>
        