
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aoximin/p/18579017" title="发布于 2025-01-24 16:35">
    <span role="heading" aria-level="2">ef 值转换与值比较器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="前言">前言</h3>
<p>简单介绍一下，值转换器和值比较器。</p>
<h3 id="正文">正文</h3>
<p>为什么有值转换器这东西呢？</p>
<p>那就是这个东西一直必须存在。</p>
<p>比如说，我们的c# enum 对应数据库的什么呢？ 是int还是string呢？</p>
<p>一般情况下，我们没有去写enum，保存数据库里面了一个int对吧。</p>
<p>那么到底谁干了这件事呢？ 显然ef 是有默认的值转换器的对吧，这点是肯定的。</p>
<p>问题又来了，既然是有默认的值转换器，那么我的需求是不用默认的呢？</p>
<p>比如说:</p>
<pre><code>public enum TestEnum
{
    First,
    Second,
    Third,
    Fourth
}
</code></pre>
<p>我想存string 怎么办呢？ 为什么存string哈，姑且就说为了方便数仓清洗这一个理由，总有业务需求的嘛。</p>
<p>那么就需要这么做:</p>
<pre><code>modelBuilder.Entity&lt;Rider&gt;()
.Property(e=&gt; e.TestEnum)
.HasConversion(
	v=&gt; v.ToString(),
	v =&gt; (TestEnum)Enum.Parse(typeof(TestEnum), v));
</code></pre>
<p>这样就可以转换成string了。</p>
<p>还有一个问题，那就是比如说对象映射，同一个类型的对象，会是同一中映射，比如都映射成string或者decimal，但是多个地方使用，那怎么办呢？</p>
<pre><code>public class CurrencyConverter : ValueConverter&lt;Currency, decimal&gt;
{
    public CurrencyConverter()
        : base(
            v =&gt; v.Amount,
            v =&gt; new Currency(v))
    {
    }
}
</code></pre>
<pre><code>protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    configurationBuilder
        .Properties&lt;Currency&gt;()
        .HaveConversion&lt;CurrencyConverter&gt;();
}
</code></pre>
<p>嗯，还有一个问题，那就是比如说对象映射，同一个类型的对象，会是同一中映射，比如都映射成string或者decimal，但是只有一个类中多次使用呢？</p>
<p>如果是这样重新创建一个类，似乎不太优雅，封装性不够呀，其实我用谈一些什么封装啊啥的，就最简单一点就是不该知道的不要知道，这样大家都省心。</p>
<pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    var converter = new ValueConverter&lt;EquineBeast, string&gt;(
        v =&gt; v.ToString(),
        v =&gt; (EquineBeast)Enum.Parse(typeof(EquineBeast), v));

    modelBuilder
        .Entity&lt;Rider&gt;()
        .Property(e =&gt; e.Mount)
        .HasConversion(converter);
}
</code></pre>
<p>这样在内部创建ValueConverter 就可以了。</p>
<p>那么我们来看一些内部默认的怎么写的:</p>
<pre><code>var converter = new BoolToZeroOneConverter&lt;int&gt;();

modelBuilder
	.Entity&lt;Rider&gt;()
	.Property(e =&gt; e.TestBool)
	.HasConversion(converter);
</code></pre>
<p>看下BoolToZeroOneConverter怎么写的哈:</p>
<p><img src="https://img2024.cnblogs.com/blog/1289794/202501/1289794-20250124154602720-897518087.png" alt="" loading="lazy"></p>
<p>就是不同类型的转换哈，很多判断，就不看了。</p>
<p>当然还有非常多知识，但是用不到的知识，暂时就不用去学，生活很美好，不是吗？</p>
<p>然后一个值比较器，这个是啥子东西呢？</p>
<p>我们都知道ef的一个功能就是，当我们修改我们查询的值，那么就会帮我们生成语句。</p>
<p>首先，最实现最傻的方式，全部更新一遍，但是显然这效率感人吧。</p>
<p>那么优化下，就是字段更新的，才生成更新语句。</p>
<p>这个思路似乎可行,那么就出现了值比较器。</p>
<pre><code>modelBuilder.Entity&lt;Rider&gt;()
	.Property(e=&gt; e.TestList)
	.HasConversion(
		v=&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)null),
		v =&gt; JsonSerializer.Deserialize&lt;List&lt;string&gt;&gt;(v, (JsonSerializerOptions)null),
		new ValueComparer&lt;List&lt;string&gt;&gt;(
			(c1, c2)=&gt;c1.SequenceEqual(c2),
			c =&gt; c.Aggregate(0, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),
			// c tolist 的话就是复制一份
			c =&gt; c.ToList()
			));
</code></pre>
<p>为什么这里list要写这种比较呢？</p>
<p>那肯定是有默认的呗，默认的就是两者是否是同一个对象,如果默认情况下，引用类型赋值指向的是同一个地方，<br>
那么你猜猜是否相同呢？</p>
<p>答案肯定是相同的，那么可以自定义。</p>
<p>ValueComparer<t> 构造函数接受三个表达式：</t></p>
<ol>
<li>用于检查相等性的表达式</li>
<li>用于生成哈希代码的表达式</li>
<li>用于截取值的快照的表达式</li>
</ol>
<p>第一个和第二个肯定要必须存在的，比较是否相同嘛，我们知道hash和equal都是一起的，至于为什么后面equal章节会写的。</p>
<p>然后为什么有一个截取表达式，这个是因为其实c =&gt; c.ToList()是c进行一个快照，好为了跟后面对比，如果直接是c =&gt; c，那么无论后面增删改查都是对同一个对象比较。</p>
<h3 id="结">结</h3>
<p>大致描述了一下ef中比较重要的两个东西，下一节介绍一下ef 的关系，因为有些人刚开始学的时候不知道什么是属于，什么是拥有，这两者到底什么区别呢？</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.4842039833391203" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 16:36">2025-01-24 16:35</span>&nbsp;
<a href="https://www.cnblogs.com/aoximin">敖毛毛</a>&nbsp;
阅读(<span id="post_view_count">125</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18579017" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18579017);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18579017', targetLink: 'https://www.cnblogs.com/aoximin/p/18579017', title: 'ef 值转换与值比较器' })">举报</a>
</div>
        