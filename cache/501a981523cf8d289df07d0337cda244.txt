
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tangtang1997/p/18616866" title="发布于 2024-12-19 14:35">
    <span role="heading" aria-level="2">使用 .NET Core 实现一个自定义日志记录器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#引言" rel="noopener nofollow">引言</a></li><li><a href="#1-抽象包" rel="noopener nofollow">1. 抽象包</a><ul><li><a href="#11-定义日志记录接口" rel="noopener nofollow">1.1 定义日志记录接口</a></li><li><a href="#12-定义日志记录抽象类" rel="noopener nofollow">1.2 定义日志记录抽象类</a></li><li><a href="#13-表结构迁移" rel="noopener nofollow">1.3 表结构迁移</a></li></ul></li><li><a href="#2-entityframework-core-的实现" rel="noopener nofollow">2. EntityFramework Core 的实现</a><ul><li><a href="#21-数据库上下文" rel="noopener nofollow">2.1 数据库上下文</a></li><li><a href="#22-实现日志写入" rel="noopener nofollow">2.2 实现日志写入</a></li></ul></li><li><a href="#3-mysqlconnector-的实现" rel="noopener nofollow">3. MySqlConnector 的实现</a><ul><li><a href="#31-sql脚本" rel="noopener nofollow">3.1 SQL脚本</a></li><li><a href="#32-实现日志写入" rel="noopener nofollow">3.2 实现日志写入</a></li></ul></li><li><a href="#4-使用示例" rel="noopener nofollow">4. 使用示例</a></li></ul></div><p></p>
<h2 id="引言">引言</h2>
<p>在应用程序中，日志记录是一个至关重要的功能。不仅有助于调试和监控应用程序，还能帮助我们了解应用程序的运行状态。<br>
在这个示例中将展示如何实现一个自定义的日志记录器，先说明一下，这个实现和<code>Microsoft.Extensions.Logging</code>、<code>Serilog</code>、<code>NLog</code>什么的无关，这里只是将自定义的日志数据存入数据库中，或许你也可以理解为<strong>实现的是一个存数据的“Repository”，只不过用这个Repository来存的是日志</strong>🙈。这个实现包含一个抽象包和两个实现包，两个实现分别是用 EntityFramework Core 和 MySqlConnector 。日志记录操作将放在本地队列中异步处理，以确保不影响业务处理。</p>
<h2 id="1-抽象包">1. 抽象包</h2>
<h3 id="11-定义日志记录接口">1.1 定义日志记录接口</h3>
<p>首先，我们需要定义一个日志记录接口 <code>ICustomLogger</code>，它包含两个方法：LogReceived 和 LogProcessed。LogReceived 用于记录接收到的日志，LogProcessed 用于更新日志的处理状态。</p>
<pre><code class="language-csharp">namespace Logging.Abstractions;

public interface ICustomLogger
{
    /// &lt;summary&gt;
    /// 记录一条日志
    /// &lt;/summary&gt;
    void LogReceived(CustomLogEntry logEntry);

    /// &lt;summary&gt;
    /// 根据Id更新这条日志
    /// &lt;/summary&gt;
    void LogProcessed(string logId, bool isSuccess);
} 
</code></pre>
<p>定义一个日志结构实体<code>CustomLogEntry</code>，用于存储日志的详细信息：</p>
<pre><code class="language-csharp">namespace Logging.Abstractions;

public class CustomLogEntry
{
    /// &lt;summary&gt;
    /// 日志唯一Id，数据库主键
    /// &lt;/summary&gt;
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Message { get; set; } = default!;
    public bool IsSuccess { get; set; }
    public DateTime CreateTime { get; set; } = DateTime.UtcNow;
    public DateTime? UpdateTime { get; set; } = DateTime.UtcNow;
}
</code></pre>
<h3 id="12-定义日志记录抽象类">1.2 定义日志记录抽象类</h3>
<p>接下来，定义一个抽象类<code>CustomLogger</code>，它实现了<code>ICustomLogger</code>接口，并提供了日志记录的基本功能，将日志写入操作（插入or更新）放在本地队列中异步处理。使用<code>ConcurrentQueue</code>来确保线程安全，并开启一个后台任务异步处理这些日志。这个抽象类只负责将日志写入命令放到队列中，实现类负责消费队列中的消息，确定日志应该怎么写？往哪里写？这个示例中后边会有两个实现，一个是基于EntityFramework Core的实现，另一个是MySqlConnector的实现。</p>
<p><strong>封装一下日志写入命令</strong></p>
<pre><code class="language-csharp">namespace Logging.Abstractions;

public class WriteCommand(WriteCommandType commandType, CustomLogEntry logEntry)
{
    public WriteCommandType CommandType { get; } = commandType;
    public CustomLogEntry LogEntry { get; } = logEntry;
}

public enum WriteCommandType
{
    /// &lt;summary&gt;
    /// 插入
    /// &lt;/summary&gt;
    Insert,

    /// &lt;summary&gt;
    /// 更新
    /// &lt;/summary&gt;
    Update
}
</code></pre>
<p><code>CustomLogger</code>实现</p>
<pre><code class="language-csharp">using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

namespace Logging.Abstractions;

public abstract class CustomLogger : ICustomLogger, IDisposable, IAsyncDisposable
{
    protected ILogger&lt;CustomLogger&gt; Logger { get; }

    protected ConcurrentQueue&lt;WriteCommand&gt; WriteQueue { get; }

    protected Task WriteTask { get; }
    private readonly CancellationTokenSource _cancellationTokenSource;
    private readonly CancellationToken _cancellationToken;

    protected CustomLogger(ILogger&lt;CustomLogger&gt; logger)
    {
        Logger = logger;

        WriteQueue = new ConcurrentQueue&lt;WriteCommand&gt;();
        _cancellationTokenSource = new CancellationTokenSource();
        _cancellationToken = _cancellationTokenSource.Token;
        WriteTask = Task.Factory.StartNew(TryWriteAsync, _cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
    }

    public void LogReceived(CustomLogEntry logEntry)
    {
        WriteQueue.Enqueue(new WriteCommand(WriteCommandType.Insert, logEntry));
    }

    public void LogProcessed(string logId, bool isSuccess)
    {
        var logEntry = GetById(logId);
        if (logEntry == null)
        {
            return;
        }

        logEntry.IsSuccess = isSuccess;
        logEntry.UpdateTime = DateTime.UtcNow;
        WriteQueue.Enqueue(new WriteCommand(WriteCommandType.Update, logEntry));
    }

    private async Task TryWriteAsync()
    {
        try
        {
            while (!_cancellationToken.IsCancellationRequested)
            {
                if (WriteQueue.IsEmpty)
                {
                    await Task.Delay(1000, _cancellationToken);
                    continue;
                }

                if (WriteQueue.TryDequeue(out var writeCommand))
                {
                    await WriteAsync(writeCommand);
                }
            }

            while (WriteQueue.TryDequeue(out var remainingCommand))
            {
                await WriteAsync(remainingCommand);
            }
        }
        catch (OperationCanceledException)
        {
            // 任务被取消，正常退出
        }
        catch (Exception e)
        {
            Logger.LogError(e, "处理待写入日志队列异常");
        }
    }

    protected abstract CustomLogEntry? GetById(string logId);

    protected abstract Task WriteAsync(WriteCommand writeCommand);

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCore();
        Dispose(false);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            _cancellationTokenSource.Cancel();
            try
            {
                WriteTask.Wait();
            }
            catch (AggregateException ex)
            {
                foreach (var innerException in ex.InnerExceptions)
                {
                    Logger.LogError(innerException, "释放资源异常");
                }
            }
            finally
            {
                _cancellationTokenSource.Dispose();
            }
        }
    }

    protected virtual async Task DisposeAsyncCore()
    {
        _cancellationTokenSource.Cancel();
        try
        {
            await WriteTask;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "释放资源异常");
        }
        finally
        {
            _cancellationTokenSource.Dispose();
        }
    }
}
</code></pre>
<h3 id="13-表结构迁移">1.3 表结构迁移</h3>
<p>为了方便表结构迁移，我们可以使用<code>FluentMigrator.Runner.MySql</code>，在项目中引入：</p>
<pre><code class="language-csharp">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include="FluentMigrator.Runner.MySql" Version="6.2.0" /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p><strong>新建一个<code>CreateLogEntriesTable</code>，放在Migrations目录下</strong></p>
<pre><code class="language-csharp">[Migration(20241216)]
public class CreateLogEntriesTable : Migration
{
    public override void Up()
    {
        Create.Table("LogEntries")
            .WithColumn("Id").AsString(36).PrimaryKey()
            .WithColumn("Message").AsCustom(text)
            .WithColumn("IsSuccess").AsBoolean().NotNullable()
            .WithColumn("CreateTime").AsDateTime().NotNullable()
            .WithColumn("UpdateTime").AsDateTime();
    }

    public override void Down()
    {
        Delete.Table("LogEntries");
    }
}
</code></pre>
<p><strong>添加服务注册</strong></p>
<pre><code class="language-csharp">using FluentMigrator.Runner;
using Logging.Abstractions;
using Logging.Abstractions.Migrations;

namespace Microsoft.Extensions.DependencyInjection;

public static class CustomLoggerExtensions
{
    /// &lt;summary&gt;
    /// 添加自定义日志服务表结构迁移
    /// &lt;/summary&gt;
    /// &lt;param name="services"&gt;&lt;/param&gt;
    /// &lt;param name="connectionString"&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static IServiceCollection AddCustomLoggerMigration(this IServiceCollection services, string connectionString)
    {
        services.AddFluentMigratorCore()
            .ConfigureRunner(
                rb =&gt; rb.AddMySql5()
                    .WithGlobalConnectionString(connectionString)
                    .ScanIn(typeof(CreateLogEntriesTable).Assembly)
                    .For.Migrations()
            )
            .AddLogging(lb =&gt;
            {
                lb.AddFluentMigratorConsole();
            });

        using var serviceProvider = services.BuildServiceProvider();
        using var scope = serviceProvider.CreateScope();
        var runner = scope.ServiceProvider.GetRequiredService&lt;IMigrationRunner&gt;();
        runner.MigrateUp();

        return services;
    }
}
</code></pre>
<h2 id="2-entityframework-core-的实现">2. EntityFramework Core 的实现</h2>
<h3 id="21-数据库上下文">2.1 数据库上下文</h3>
<p>新建Logging.EntityFrameworkCore项目，添加对Logging.Abstractions项目的引用，并在项目中安装<code>Pomelo.EntityFrameworkCore.MySql</code>和<code>Microsoft.Extensions.ObjectPool</code>。</p>
<pre><code class="language-csharp">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Extensions.ObjectPool" Version="8.0.11" /&gt;
    &lt;PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="8.0.2" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\Logging.Abstractions\Logging.Abstractions.csproj" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p><strong>创建<code>CustomLoggerDbContext</code>类，用于管理日志实体</strong></p>
<pre><code class="language-csharp">using Logging.Abstractions;
using Microsoft.EntityFrameworkCore;

namespace Logging.EntityFrameworkCore;

public class CustomLoggerDbContext(DbContextOptions&lt;CustomLoggerDbContext&gt; options) : DbContext(options)
{
    public virtual DbSet&lt;CustomLogEntry&gt; LogEntries { get; set; }
}
</code></pre>
<p>使用 <strong>ObjectPool</strong> 管理 <strong>DbContext</strong>：提高性能，减少 DbContext 的创建和销毁开销。<br>
<strong>创建<code>CustomLoggerDbContextPoolPolicy</code></strong></p>
<pre><code class="language-csharp">using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.ObjectPool;

namespace Logging.EntityFrameworkCore;

/// &lt;summary&gt;
/// DbContext 池策略
/// &lt;/summary&gt;
/// &lt;param name="options"&gt;&lt;/param&gt;
public class CustomLoggerDbContextPoolPolicy(DbContextOptions&lt;CustomLoggerDbContext&gt; options) : IPooledObjectPolicy&lt;CustomLoggerDbContext&gt;
{
    /// &lt;summary&gt;
    /// 创建 DbContext
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public CustomLoggerDbContext Create()
    {
        return new CustomLoggerDbContext(options);
    }

    /// &lt;summary&gt;
    /// 回收 DbContext
    /// &lt;/summary&gt;
    /// &lt;param name="context"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public bool Return(CustomLoggerDbContext context)
    {
        // 重置 DbContext 状态
        context.ChangeTracker.Clear();
        return true; 
    }
} 
</code></pre>
<h3 id="22-实现日志写入">2.2 实现日志写入</h3>
<p>创建一个<code>EfCoreCustomLogger</code>，继承自<code>CustomLogger</code>，实现日志写入的具体逻辑</p>
<pre><code class="language-csharp">using Logging.Abstractions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.ObjectPool;

namespace Logging.EntityFrameworkCore;

/// &lt;summary&gt;
/// EfCore自定义日志记录器
/// &lt;/summary&gt;
public class EfCoreCustomLogger(ObjectPool&lt;CustomLoggerDbContext&gt; contextPool, ILogger&lt;EfCoreCustomLogger&gt; logger) : CustomLogger(logger)
{
    /// &lt;summary&gt;
    /// 根据Id查询日志
    /// &lt;/summary&gt;
    /// &lt;param name="logId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    protected override CustomLogEntry? GetById(string logId)
    {
        var dbContext = contextPool.Get();
        try
        {
            return dbContext.LogEntries.Find(logId);
        }
        finally
        {
            contextPool.Return(dbContext);
        }
    }

    /// &lt;summary&gt;
    /// 写入日志
    /// &lt;/summary&gt;
    /// &lt;param name="writeCommand"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="ArgumentOutOfRangeException"&gt;&lt;/exception&gt;
    protected override async Task WriteAsync(WriteCommand writeCommand)
    {
        var dbContext = contextPool.Get();

        try
        {
            switch (writeCommand.CommandType)
            {
                case WriteCommandType.Insert:
                    if (writeCommand.LogEntry != null)
                    {
                        await dbContext.LogEntries.AddAsync(writeCommand.LogEntry);
                    }

                    break;
                case WriteCommandType.Update:
                {
                    if (writeCommand.LogEntry != null)
                    {
                        dbContext.LogEntries.Update(writeCommand.LogEntry);
                    }

                    break;
                }
                default:
                    throw new ArgumentOutOfRangeException();
            }

            await dbContext.SaveChangesAsync();
        }
        finally
        {
            contextPool.Return(dbContext);
        }
    }
}
</code></pre>
<p><strong>添加服务注册</strong></p>
<pre><code class="language-csharp">using Logging.Abstractions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.ObjectPool;

namespace Logging.EntityFrameworkCore;

public static class EfCoreCustomLoggerExtensions
{
    public static IServiceCollection AddEfCoreCustomLogger(this IServiceCollection services, string connectionString)
    {
        if (string.IsNullOrEmpty(connectionString))
        {
            throw new ArgumentNullException(nameof(connectionString));
        }

        services.AddCustomLoggerMigration(connectionString);

        services.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();
        services.AddSingleton(serviceProvider =&gt;
        {
            var options = new DbContextOptionsBuilder&lt;CustomLoggerDbContext&gt;()
                .UseMySql(connectionString, ServerVersion.AutoDetect(connectionString))
                .Options;
            var poolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();
            return poolProvider.Create(new CustomLoggerDbContextPoolPolicy(options));
        });

        services.AddSingleton&lt;ICustomLogger, EfCoreCustomLogger&gt;();

        return services;
    }
}
</code></pre>
<h2 id="3-mysqlconnector-的实现">3. MySqlConnector 的实现</h2>
<p>MySqlConnector 的实现比较简单，利用原生SQL操作数据库完成日志的插入和更新。<br>
新建Logging.MySqlConnector项目，添加对Logging.Abstractions项目的引用，并安装<code>MySqlConnector</code>包</p>
<pre><code class="language-csharp">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include="MySqlConnector" Version="2.4.0" /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include="..\Logging.Abstractions\Logging.Abstractions.csproj" /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<h3 id="31-sql脚本">3.1 SQL脚本</h3>
<p>为了方便维护，我们把需要用到的SQL脚本放在一个<code>Consts</code>类中</p>
<pre><code class="language-csharp">namespace Logging.MySqlConnector;

public class Consts
{
    /// &lt;summary&gt;
    /// 插入日志
    /// &lt;/summary&gt;
    public const string InsertSql = """
                                    INSERT INTO `LogEntries` (`Id`, `TranceId`, `BizType`, `Body`, `Component`, `MsgType`, `Status`, `CreateTime`, `UpdateTime`, `Remark`)
                                    VALUES (@Id, @TranceId, @BizType, @Body, @Component, @MsgType, @Status, @CreateTime, @UpdateTime, @Remark);
                                    """;

    /// &lt;summary&gt;
    /// 更新日志
    /// &lt;/summary&gt;
    public const string UpdateSql = """
                                    UPDATE `LogEntries` SET `Status` = @Status, `UpdateTime` = @UpdateTime
                                    WHERE `Id` = @Id;
                                    """;

    /// &lt;summary&gt;
    /// 根据Id查询日志
    /// &lt;/summary&gt;
    public const string QueryByIdSql = """
                                        SELECT `Id`, `TranceId`, `BizType`, `Body`, `Component`, `MsgType`, `Status`, `CreateTime`, `UpdateTime`, `Remark`
                                        FROM `LogEntries`
                                        WHERE `Id` = @Id;
                                        """;
}
</code></pre>
<h3 id="32-实现日志写入">3.2 实现日志写入</h3>
<p><strong>创建<code>MySqlConnectorCustomLogger</code>类，实现日志写入的具体逻辑</strong></p>
<pre><code class="language-csharp">using Logging.Abstractions;
using Microsoft.Extensions.Logging;
using MySqlConnector;

namespace Logging.MySqlConnector;

/// &lt;summary&gt;
/// 使用 MySqlConnector 实现记录日志
/// &lt;/summary&gt;
public class MySqlConnectorCustomLogger : CustomLogger
{

    /// &lt;summary&gt;
    /// 数据库连接字符串
    /// &lt;/summary&gt;
    private readonly string _connectionString;

    /// &lt;summary&gt;
    /// 构造函数
    /// &lt;/summary&gt;
    /// &lt;param name="connectionString"&gt;MySQL连接字符串&lt;/param&gt;
    /// &lt;param name="logger"&gt;&lt;/param&gt;
    public MySqlConnectorCustomLogger(
        string connectionString, 
        ILogger&lt;MySqlConnectorCustomLogger&gt; logger)
        : base(logger)
    {
        _connectionString = connectionString;
    }

    /// &lt;summary&gt; 
    /// 根据Id查询日志
    /// &lt;/summary&gt;
    /// &lt;param name="logId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    protected override CustomLogEntry? GetById(string logId)
    {
        using var connection = new MySqlConnection(_connectionString);
        connection.Open();

        using var command = new MySqlCommand(Consts.QueryByIdSql, connection);
        command.Parameters.AddWithValue("@Id", logId);

        using var reader = command.ExecuteReader();
        if (!reader.Read())
        {
            return null;
        }

        return new CustomLogEntry
        {
            Id = reader.GetString(0),
            Message = reader.GetString(1),
            IsSuccess = reader.GetBoolean(2),
            CreateTime = reader.GetDateTime(3),
            UpdateTime = reader.GetDateTime(4)
        };
    }

    /// &lt;summary&gt;
    /// 处理日志
    /// &lt;/summary&gt;
    /// &lt;param name="writeCommand"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="ArgumentOutOfRangeException"&gt;&lt;/exception&gt;
    protected override async Task WriteAsync(WriteCommand writeCommand)
    {
        await using var connection = new MySqlConnection(_connectionString);
        await connection.OpenAsync();

        switch (writeCommand.CommandType)
        {
            case WriteCommandType.Insert:
                {
                    if (writeCommand.LogEntry != null)
                    {
                        await using var command = new MySqlCommand(Consts.InsertSql, connection);
                        command.Parameters.AddWithValue("@Id", writeCommand.LogEntry.Id);
                        command.Parameters.AddWithValue("@Message", writeCommand.LogEntry.Message);
                        command.Parameters.AddWithValue("@IsSuccess", writeCommand.LogEntry.IsSuccess);
                        command.Parameters.AddWithValue("@CreateTime", writeCommand.LogEntry.CreateTime);
                        command.Parameters.AddWithValue("@UpdateTime", writeCommand.LogEntry.UpdateTime);
                        await command.ExecuteNonQueryAsync();
                    }

                    break;
                }
            case WriteCommandType.Update:
                {
                    if (writeCommand.LogEntry != null)
                    {
                        await using var command = new MySqlCommand(Consts.UpdateSql, connection);
                        command.Parameters.AddWithValue("@Id", writeCommand.LogEntry.Id);
                        command.Parameters.AddWithValue("@IsSuccess", writeCommand.LogEntry.IsSuccess);
                        command.Parameters.AddWithValue("@UpdateTime", writeCommand.LogEntry.UpdateTime);
                        await command.ExecuteNonQueryAsync();
                    }

                    break;
                }
            default:
                throw new ArgumentOutOfRangeException();
        }
    }
}
</code></pre>
<p><strong>添加服务注册</strong></p>
<pre><code class="language-csharp">using Logging.Abstractions;
using Logging.MySqlConnector;
using Microsoft.Extensions.Logging;

namespace Microsoft.Extensions.DependencyInjection;

/// &lt;summary&gt;
/// MySqlConnector 日志记录器扩展
/// &lt;/summary&gt;
public static class MySqlConnectorCustomLoggerExtensions
{
    /// &lt;summary&gt;
    /// 添加 MySqlConnector 日志记录器
    /// &lt;/summary&gt;
    /// &lt;param name="services"&gt;&lt;/param&gt;
    /// &lt;param name="connectionString"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static IServiceCollection AddMySqlConnectorCustomLogger(this IServiceCollection services, string connectionString)
    {
        if (string.IsNullOrEmpty(connectionString))
        {
            throw new ArgumentNullException(nameof(connectionString));
        }

        services.AddSingleton&lt;ICustomLogger&gt;(s =&gt;
        {
            var logger = s.GetRequiredService&lt;ILogger&lt;MySqlConnectorCustomLogger&gt;&gt;();
            return new MySqlConnectorCustomLogger(connectionString, logger);
        });
        services.AddCustomLoggerMigration(connectionString);

        return services;
    }
}
</code></pre>
<h2 id="4-使用示例">4. 使用示例</h2>
<p>下边是一个EntityFramework Core的实现使用示例，MySqlConnector的使用方式相同。<br>
<strong>新建WebApi项目，添加Logging.EntityFrameworkCore</strong></p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// 添加EntityFrameworkCore日志记录器
var connectionString = builder.Configuration.GetConnectionString("MySql");
builder.Services.AddEfCoreCustomLogger(connectionString!);

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<p><strong>在控制器中使用</strong></p>
<pre><code class="language-csharp">namespace EntityFrameworkCoreTest.Controllers;

[ApiController]
[Route("[controller]")]
public class TestController(ICustomLogger customLogger) : ControllerBase
{
    [HttpPost("InsertLog")]
    public IActionResult Post(CustomLogEntry model)
    {
        customLogger.LogReceived(model);

        return Ok(); 
    }

    [HttpPut("UpdateLog")]
    public IActionResult Put(string logId, MessageStatus status)
    {
        customLogger.LogProcessed(logId, status);

        return Ok();
    }
} 
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.1702863640057872" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-20 10:54">2024-12-19 14:35</span>&nbsp;
<a href="https://www.cnblogs.com/Tangtang1997">贾光辉</a>&nbsp;
阅读(<span id="post_view_count">1122</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18616866" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18616866);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18616866', targetLink: 'https://www.cnblogs.com/Tangtang1997/p/18616866', title: '使用 .NET Core 实现一个自定义日志记录器' })">举报</a>
</div>
        