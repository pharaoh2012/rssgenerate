
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18771994" title="发布于 2025-03-15 16:07">
    <span role="heading" aria-level="2">前缀函数和 KMP "跳步骤"模式匹配</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在一篇由字符构成的长文中查找另一个短字符串出现的位置，这可以算是编程领域最最常见的问题（比如按下 Ctrl + F 就可以打开你浏览器的查找功能）。这个问题叫做<strong>字符串的模式匹配</strong>，我们把被查找的关键词叫做<strong>模式串</strong>，被查找的全文叫做<strong>主串</strong>。注意：本文的下标均从 0 开始。</p>
<p>当我们用最容易想到的朴素的暴力解法时，就像逐字逐句地翻动书页：将模式串的每个字符与主串逐一比对，一旦发现不匹配，就<strong>把模式串右移一位，重新从头比较</strong>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250315110111189-1483174345.png" alt="image" loading="lazy"></p>
<p>面对随机数据，算法可以高效工作。但这种老实人的做法，在遇到某些“狡猾”的数据时会彻底崩溃。比如：</p>
<ul>
<li><strong>主串</strong>：<code>AAAAA……AAB</code>（连续100万个A后跟一个B）</li>
<li><strong>模式串</strong>：<code>AAAAAAAC</code></li>
</ul>
<p>暴力解法会怎么做？它会在主串的每一个位置，逐个对比前7个字符，直到发现第7位的<code>A</code>与<code>C</code>不匹配，再右移一位重复这个过程，最终一共进行了八百万次匹配，最终还是没有找到。</p>
<p>💣 <strong>问题的核心</strong>：每次匹配失败时，必须全部重来。在主串的每一位匹配时，都可能遍历到模式串的最后一位。这种“一朝失足，从头再来”的策略，在极端情况下让时间复杂度飙升至 <span class="math inline">\(O(mn)\)</span>。</p>
<h2 id="前缀函数模式串的自省密码">前缀函数——模式串的"自省密码"</h2>
<p>既然暴力解法卡在「匹配失败就全体重来」的死胡同里，我们需要让模式串学会<strong>自我反省</strong>——这就是前缀函数（Prefix Function）的使命。它像一本预先生成的密码手册，记录了模式串中每个位置的<strong>最长重复头尾特征</strong>。</p>
<h3 id="定义与直觉">定义与直觉</h3>
<p>对于一个长度为 <span class="math inline">\(n\)</span> 的模式串 <span class="math inline">\(s\)</span>，前缀函数 <span class="math inline">\(π[i]\)</span> 表示子串 <span class="math inline">\(s[0..i]\)</span> 中，<strong>最长的相同真前缀与真后缀的长度</strong>。<br>
（真前缀：不包含整个字符串的前缀；真后缀同理）</p>
<p><strong>举个栗子🌰</strong>：模式串 <code>"ababcabab"</code></p>
<pre><code>索引：0 1 2 3 4 5 6 7 8  
字符：a b a b c a b a b  
π[i]:0 0 1 2 0 1 2 3 4  
</code></pre>
<ul>
<li><code>i=0</code> 时子串是 "a"，真前缀不应该包括自己（否则每个点的 π 都包含自身全部了） → π[0] 总是 0</li>
<li><code>i=3</code> 时子串是 "abab"，最长真前后缀是 "ab" → π[3]=2</li>
<li><code>i=8</code> 时子串是整个字符串，真前后缀 "abab" → π[8]=4</li>
</ul>
<h3 id="为什么能加速">为什么能加速？</h3>
<p>当我们在主串中匹配到某个位置失败时，前缀函数告诉我们可以<strong>保留已匹配部分的最大共同头尾</strong>，直接将模式串滑动到该位置继续匹配，跳过中间的重复检查。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250315113500126-120493589.png" alt="image" loading="lazy"></p>
<h2 id="动态规划构造前缀表模式串的自我匹配">动态规划构造前缀表：模式串的自我匹配</h2>
<p>我们怎么求解这个有大用的前缀函数呢？构造前缀函数的过程，本质上是在模式串内部<strong>用自己匹配自己</strong>。这听起来有点玄乎，但核心思想非常巧妙——<strong>利用已计算的前缀值指导后续计算</strong>，踩着之前的脚印过河。</p>
<pre><code class="language-cpp">// string s = "……"
vector&lt;int&gt; next; // π

for (int i = 1; i &lt; s.size(); ++i) {  // next[0]总是 0，从next[1]开始计算
    int j = next[i-1];               // 初始化为前一位的前缀值
    while (j &gt; 0 &amp;&amp; s[j] != s[i])    // 不匹配时回退
        j = next[j-1];               // 关键跳跃！
    next[i] = (s[j] == s[i]) ? j + 1 : 0; 
}
</code></pre>
<p>假设模式串为 <code>"abababc"</code>，我们手动模拟计算过程：</p>
<ol>
<li><strong>初始化</strong>：<code>next[0] = 0</code>（单个字符无真前后缀）</li>
<li><strong>i=1</strong>（字符 <code>b</code>）：
<ul>
<li><code>j = next[0] = 0</code></li>
<li><code>s[0] = 'a' ≠ 'b'</code> → <code>j</code> 保持 0</li>
<li><code>next[1] = 0</code></li>
</ul>
</li>
<li><strong>i=2</strong>（字符 <code>a</code>）：
<ul>
<li><code>j = next[1] = 0</code></li>
<li><code>s[0] = 'a' == 'a'</code> → <code>j += 1</code></li>
<li><code>next[2] = 1</code></li>
</ul>
</li>
<li><strong>i=3</strong>（字符 <code>b</code>）：
<ul>
<li><code>j = next[2] = 1</code> → 检查 <code>s[1] = 'b' == 'b'</code></li>
<li>匹配成功 → <code>next[3] = 2</code></li>
</ul>
</li>
<li><strong>i=4</strong>（字符 <code>a</code>）：
<ul>
<li><code>j = next[3] = 2</code> → 检查 <code>s[2] = 'a' == 'a'</code></li>
<li>匹配成功 → <code>next[4] = 3</code></li>
</ul>
</li>
<li><strong>i=5</strong>（字符 <code>b</code>）：
<ul>
<li><code>j = next[4] = 3</code> → 检查 <code>s[3] = 'b' == 'b'</code></li>
<li>匹配成功 → <code>next[5] = 4</code></li>
</ul>
</li>
<li><strong>i=6</strong>（字符 <code>c</code>）：
<ul>
<li><code>j = next[5] = 4</code> → <code>s[4] = 'a' ≠ 'c'</code></li>
<li><strong>回退</strong>：<code>j = next[3] = 2</code> → <code>s[2] = 'a' ≠ 'c'</code></li>
<li>继续回退：<code>j = next[1] = 0</code> → <code>s[0] = 'a' ≠ 'c'</code></li>
<li>最终 <code>next[6] = 0</code></li>
</ul>
</li>
</ol>
<p>每一次计算<code>next[i]</code>先尝试用<code>next[i-1]</code>，若下一个字符不匹配，无需重头开始，而是可以尝试用<code>next[next[i-1]]</code>来匹配再次尝试，直到其为 0 也不匹配的话，就只能归零了。</p>
<p><strong><code>j = next[j-1]</code></strong>：当 <code>s[j] ≠ s[i]</code> 时，跳跃到当前最长前缀的末尾继续尝试匹配。这相当于利用之前计算的<strong>次长相同前后缀</strong>，避免从头开始暴力枚举。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250315135225125-725721428.png" alt="image" loading="lazy"></p>
<h2 id="kmp-模式匹配">KMP 模式匹配</h2>
<p>有了模式串的前缀函数这张“地图”，KMP 算法就能像猎犬追踪气味一样高效搜索。KMP 算法首次出现在1977年，全称为 Knuth-Morris-Pratt 算法，是一种用于在字符串中进行模式匹配的高效算法。它由 Donald Knuth、Vaughan Pratt 和 James H. Morris 三位计算机科学家共同提出，因此命名为 KMP 算法。</p>
<p>它的核心逻辑是让主串指针 <code>i</code> <strong>永不回头</strong>，而模式串指针 <code>j</code> 在失败时<strong>智能跳跃</strong>。</p>
<p>和前缀函数的求解类似，当来到下标 i 时，我们已知主串下标 i-1 的后缀和模式串的前 j 个字符匹配，接下来应该比较<code>s[j] = text[i]</code>，相等则再推进一步，不等则可以退回到和 <code>s[next[j-1]]</code> 比较，直到有一个匹配成功（或者最终仍匹配失败）。</p>
<pre><code class="language-cpp">vector&lt;int&gt; match(const string &amp;text) {
    vector&lt;int&gt; result;
    for (int i = 0, j = 0; i &lt; text.size(); ++i) { 
        while (j &gt; 0 &amp;&amp; s[j] != text[i]) 
            j = next[j - 1];  
        // 当前字符匹配时，j向前推进
        if (s[j] == text[i]) ++j;
        if (j == s.size()) { // 完整匹配
            result.push_back(i - j + 1); 
            j = next[j - 1]; 
        }
    } 
    return result; 
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250315141404865-348479011.png" alt="image" loading="lazy"></p>
<p>假设：</p>
<ul>
<li><strong>主串</strong> <code>text = "ABABABABC"</code></li>
<li><strong>模式串</strong> <code>s = "ABABAC"</code>（前缀函数 <code>next = [0,0,1,2,3,0]</code>）</li>
</ul>
<ol>
<li>
<p><strong>初始状态</strong>：<code>i=0</code>（指向主串'A'），<code>j=0</code>（指向模式串'A'）</p>
<ul>
<li>匹配成功 → <code>j=1</code></li>
<li>未完全匹配 → 继续</li>
</ul>
</li>
<li>
<p><strong>i=1</strong>（主串'B'），<code>j=1</code>（模式串'B'）</p>
<ul>
<li>匹配成功 → <code>j=2</code></li>
</ul>
</li>
<li>
<p><strong>i=2</strong>（主串'A'），<code>j=2</code>（模式串'A'）</p>
<ul>
<li>匹配成功 → <code>j=3</code></li>
</ul>
</li>
<li>
<p><strong>i=3</strong>（主串'B'），<code>j=3</code>（模式串'B'）</p>
<ul>
<li>匹配成功 → <code>j=4</code></li>
</ul>
</li>
<li>
<p><strong>i=4</strong>（主串'A'），<code>j=4</code>（模式串'A'）</p>
<ul>
<li>匹配成功 → <code>j=5</code></li>
</ul>
</li>
<li>
<p><strong>i=5</strong>（主串'B'），<code>j=5</code>（模式串'C'）</p>
<ul>
<li><strong>失配</strong> → 执行 <code>j = next[4] = 3</code></li>
<li>此时模式串跳跃到 <code>j=3</code>，继续比较 <code>s[3]</code>（'B'）与当前主串字符'B'</li>
<li>匹配成功 → <code>j=4</code><br>
…………</li>
</ul>
</li>
</ol>
<h2 id="稳定的复杂度">稳定的复杂度</h2>
<p>初看代码中的 <code>while (j &gt; 0 &amp;&amp; s[j] != text[i])</code> 循环，似乎存在双重循环的风险。但仔细观察，<strong>主串指针 <code>i</code> 永远只向前移动</strong>，而模式串指针 <code>j</code> 的移动轨迹像弹簧一样——虽然会回缩，但整体趋势必然向前。</p>
<ol>
<li><strong>j 的移动范围</strong>：在任何时刻，<code>j</code> 的取值范围是 <code>[0, m]</code>（m为模式串长度）。</li>
<li><strong>j 的总增加量</strong>：外层循环中，<code>i</code> 从 0 移动到 <code>n</code>（主串长度），每次循环 <code>j</code> <strong>最多增加 1</strong>（<code>if (s[j] == text[i]) ++j</code>）。因此，<code>j</code> 在整个算法中<strong>最多增加 <code>n</code> 次</strong>。</li>
<li><strong>j 的回退成本</strong>：每次进入 <code>while</code> 循环回退 <code>j</code> 时，<code>j</code> 至少减少 1。由于 <code>j</code> 的总减少量不可能超过总增加量，<strong>整个算法的 <code>while</code> 循环最多执行 <code>n</code> 次</strong>。</li>
</ol>
<p>所以 KMP 模式匹配拥有稳定的线性复杂度。</p>
<ul>
<li><strong>构造前缀函数</strong>的时间复杂度：<code>O(m)</code>（模式串长度）</li>
<li><strong>匹配过程</strong>的时间复杂度：<code>O(n)</code>（主串长度）</li>
<li><strong>总时间复杂度</strong>：<code>O(m + n)</code>，严格线性！</li>
</ul>
<p>回到最初的灾难性案例：</p>
<ul>
<li><strong>主串</strong>：<code>AAAAA...AAB</code>（100万A + B）</li>
<li><strong>模式串</strong>：<code>AAAAAAAC</code></li>
<li><strong>KMP的表现</strong>：
<ol>
<li>主串指针 <code>i</code> 从 0 移动到 100万，全程无回溯</li>
<li>每次失配时，模式串指针 <code>j</code> 通过前缀函数迅速回退到 0</li>
<li><strong>总操作次数 ≈ 100万（主串长度） + 8（模式串长度）</strong></li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>暴力解法</th>
<th>KMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>主串指针移动</td>
<td>反复回退</td>
<td><strong>永不回退</strong></td>
</tr>
<tr>
<td>模式串指针移动</td>
<td>每次从头开始</td>
<td><strong>弹性跳跃</strong></td>
</tr>
<tr>
<td>极端案例复杂度</td>
<td>O(mn) → 爆炸</td>
<td>O(m+n) → 稳如狗</td>
</tr>
</tbody>
</table>
<h2 id="拓展思考预装导航地图">拓展思考：预装导航地图</h2>
<p>仔细观察会发现，KMP的匹配过程本质上是一个<strong>状态转移游戏</strong>：当前已匹配的字符数 <code>j</code> 构成状态，遇到主串字符 <code>text[i]</code> 时，根据模式串的规律跳转到新状态。</p>
<p>假设我们想用<strong>同一个模式串反复匹配不同主串</strong>，原始的KMP算法每次匹配时仍需执行 <code>while (j &gt; 0 &amp;&amp; s[j] != text[i])</code> 的跳跃逻辑。其实，若匹配时两次出现“已匹配5个字符，下一个字符是 c”的情况，他们经历的跳转是完全相同的。若我们提前为每个状态 <code>j</code> 和每个可能的字符 <code>c</code> 预计算跳转目标，就能实现<strong>查表式一步跳转</strong>，将匹配过程优化到极致。</p>
<p>构建一个二维数组 <code>aut[j][c]</code>，表示在状态 <code>j</code>（已匹配前 <code>j</code> 个字符）时，遇到字符 <code>c</code> 应该跳转到哪个新状态。预处理过程如下：</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; aut(m+1, vector&lt;int&gt;(256)); // m为模式串长度
for (int j = 0; j &lt;= m; ++j) {
    for (char c : 字符集) { // 如ASCII码
        if (j &lt; m &amp;&amp; c == s[j]) 
            aut[j][c] = j + 1;  // 直接匹配成功
        else 
            aut[j][c] = aut[next[j]][c]; // 关键递推！
    }
}
</code></pre>
<p>这样，我们直接处理出了每一个已匹配长度遇到每一个字符应跳转到哪里，再之后的匹配再也不会出现跳转了，更高效。这种改造将匹配过程中的 <code>while</code> 循环彻底消除，代价是增加了 <code>O(m*|Σ|)</code> 的空间。<strong>高频查询时，这是值得的</strong>——就像快递员第一次摸清路线后，后续送货直接走最优路径。</p>
<p>以模式串 <code>s = "ABABC"</code> 为例：</p>
<ul>
<li>原始前缀函数 <code>next = [0,0,1,2,0]</code></li>
<li>预处理后，<code>aut[2]['A']</code> 为3，；因为 AB 后刚好是 A；<code>aut[4]['A']</code> 也为 3.</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>预处理时间</th>
<th>单次匹配时间</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始KMP</td>
<td>O(m)</td>
<td>O(n)</td>
<td>低频次匹配</td>
</tr>
<tr>
<td>自动机优化</td>
<td>O(m*|Σ|)</td>
<td>常数更小的 O(n)</td>
<td><strong>高频次匹配</strong></td>
</tr>
</tbody>
</table>
<p>（其中 |Σ| 为字符集大小，ASCII为256，Unicode需优化存储）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8370873131793981" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-15 16:13">2025-03-15 16:07</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">38</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18771994" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18771994);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18771994', targetLink: 'https://www.cnblogs.com/ofnoname/p/18771994', title: '前缀函数和 KMP &amp;quot;跳步骤&amp;quot;模式匹配' })">举报</a>
</div>
        