
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cjsblog/p/18460884" title="发布于 2024-12-29 11:41">
    <span role="heading" aria-level="2">JSON字符串反序列化 动态泛型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>需求：定时任务扫描，反射调用目标对象，但是，方法的传参不是固定的。</p>
<p>方案一：将方法参数存成JSON字符串，然后JSON反序列化成对象，然后反射调用</p>
<p>目标方法时这样的：</p>
<pre class="language-java highlighter-hljs"><code>CommandResp sendXXX(BaseCommandApiDTO&lt;XXX&gt; baseCommandApiDTO);</code></pre>
<p>方式一：FastJson</p>
<pre class="language-java highlighter-hljs"><code>Class mainBody = Class.forName(entity.getMainBodyType());
ParameterizedTypeImpl parameterizedType = new ParameterizedTypeImpl(new Type[]{mainBody}, null, BaseCommandApiDTO.class);
Object obj = JSON.parseObject(entity.getMsgText(), parameterizedType);

CommandResp resp = ReflectUtil.invoke(serviceObj, methodName, obj);</code></pre>
<p>方式二：Jackson</p>
<pre class="language-java highlighter-hljs"><code>public class ObjectMapperHolder {
    private static final ObjectMapper objectMapper = new ObjectMapper();
    public static ObjectMapper getObjectMapper() {
        objectMapper.registerModule(new Jdk8Module());
        objectMapper.registerModule(new JavaTimeModule());
        return objectMapper;
    }
}


ObjectMapper mapper = ObjectMapperHolder.getObjectMapper();
JavaType javaType = mapper.getTypeFactory().constructParametricType(BaseCommandApiDTO.class, mainBody);
Object obj = mapper.readValue(entity.getMsgText(), javaType);

CommandResp resp = ReflectUtil.invoke(serviceObj, methodName, obj);</code></pre>
<p>实践中发现，这两种方式容易导致OOM</p>
<p>方案二：直接将参数对象存到数据库中</p>
<p>数据库对应字段设置BLOB类型（这里设置的是MEDIUMBLOB） ，对应的java字段类型是byte[]</p>
<pre class="language-java highlighter-hljs"><code>//  写入对象
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(baseCommandApiDTO);
oos.flush();
byte[] data = bos.toByteArray();

//  读取对象
ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(entity.getMsgObj()));
Object obj = ois.readObject();</code></pre>
<p>最后的最后，优化建议：</p>
<p>1、尽量不要在数据库中存json字符串，如果非要存，建议字段类型设置为json，这样可以节省空间。因为你无法控制json字符串的长度，所以长度设置是个问题，另外json反序列化比较占内存。</p>
<p>2、长度很大的字段（比如blob类型的）建议单独存一张关联表</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3633644042696759" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-29 11:41">2024-12-29 11:41</span>&nbsp;
<a href="https://www.cnblogs.com/cjsblog">废物大师兄</a>&nbsp;
阅读(<span id="post_view_count">75</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18460884" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18460884);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18460884', targetLink: 'https://www.cnblogs.com/cjsblog/p/18460884', title: 'JSON字符串反序列化 动态泛型' })">举报</a>
</div>
        