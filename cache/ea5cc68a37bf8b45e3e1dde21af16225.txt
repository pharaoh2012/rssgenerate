
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuhuacong/p/18643810" title="发布于 2025-01-02 11:08">
    <span role="heading" aria-level="2">WxPython跨平台开发框架之动态菜单的管理和功能权限的控制</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        在一个业务管理系统中，如果我们需要实现权限控制功能，我们需要定义好对应的权限功能点，然后在前端界面中对界面元素的可用性和功能点进行绑定，这样就可以在后台动态分配权限进行动态控制了，一般来说，权限功能点是针对角色进行控制的，也就是简称RBAC（Role Based Access Control）。对于登录系统后的用户，对用户的菜单（工具栏）、界面操作按钮的权限进行动态化的绑定和统一处理的操作过程，这样对于我们界面，只需要约定一些规则即可实现比较弹性化的操作，非常方便。本篇随笔介绍WxPython跨平台开发框架之动态菜单的管理和功能权限的控制。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在一个业务管理系统中，如果我们需要实现权限控制功能，我们需要定义好对应的权限功能点，然后在前端界面中对界面元素的可用性和功能点进行绑定，这样就可以在后台动态分配权限进行动态控制了，一般来说，权限功能点是针对角色进行控制的，也就是简称RBAC（Role Based Access Control）。对于登录系统后的用户，对用户的菜单（工具栏）、界面操作按钮的权限进行动态化的绑定和统一处理的操作过程，这样对于我们界面，只需要约定一些规则即可实现比较弹性化的操作，非常方便。本篇随笔介绍WxPython跨平台开发框架之动态菜单的管理和功能权限的控制。</p>
<h3>1、权限管理系统的相关资源</h3>
<p>权限管理系统主要的功能包括有：用户管理、组织机构管理、功能管理、角色管理和权限分配管理、菜单管理、系统类型管理、登录日志管理、操作日志管理、系统黑白名单管理等功能模块。对于每新增一个系统，我们只需要在权限管理系统中增加一个系统类型定义，以及相关的功能、菜单数据即可，非常方便管理。下图是一个简化的权限管理系统中涉及到角色相关资源的信息。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231132329901-381700152.png" alt="" loading="lazy"></p>
<p>菜单资源和权限功能点是基于不同系统前端定义的资源，因此可以一套系统管理多个终端的菜单、功能点，以便实现更好的控制。</p>
<p>权限系统分了两级管理员用户：超级管理员和公司管理员。超级管理员可以管理整个集团或者整个系统的人员和相关信息（包括组织机构、角色、登陆日志、操作日志等信息的分级）；公司管理员可以管理分子公司、事业单位处室/局级这样的组织机构的人员和相关信息。<br>分级管理组织机构、角色、用户等相关数据，能够减少管理员的相关工作，提高工作效率，并能增强权限管理系统对权限的控制和资源分配等管理，提高用户的认同感。</p>
<h4>1）功能点定义和管理</h4>
<p>权限功能点的管理就是对TB_Function的表的管理操作，这个表是我们定义用于系统控制的功能点。</p>
<p>权限功能点的管理为了展示它的树状结果，包括树列表的管理和明细列表的管理，如下图所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231133029024-1544495257.png" alt="" width="691" height="537" loading="lazy"></p>
<p>我们为了方便，在开始的时候，创建功能点的时候，一般通过批量添加的方式快速添加，如下界面所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231133155400-793975398.png" alt="" width="505" height="265" loading="lazy"></p>
<p>这样系统会根据主控制标识，为各个操作（增加、删除、修改等）增加对应的操作标识。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231133305040-623690116.png" alt="" width="720" height="559" loading="lazy"></p>
<p>&nbsp;为对应角色添加相关的操作功能点</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231133431168-1570178871.png" alt="" width="930" height="754" loading="lazy"></p>
<p>&nbsp;</p>
<h4>2）菜单资源的定义和管理</h4>
<p>一般的业务系统，需要对菜单进行动态配置管理，通过后台菜单的配置和权限的指定，能够实现菜单的动态加载和权限验证。<br>因此菜单也是权限分配的一部分，为了有效管理菜单资源，我们把菜单放到权限管理系统中进行管理控制，可根据用户权限进行动态控制显示。</p>
<p>菜单的管理界面如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102095805877-1537001107.png" alt="" width="948" height="588" loading="lazy"></p>
<p>&nbsp;菜单信息，包括名称和相关的图标定义等，这些需要再前端界面中构建工具栏显示用到的资源，而窗体类型则是定义我们需要动态展示的菜单对象的模块名和类名称。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102100001791-255720996.png" alt="" width="634" height="492" loading="lazy"></p>
<p>&nbsp;菜单定义好后，为了和实际用户进行关联，那么需要为角色添加相关的访问菜单，从而实现用户菜单的动态关联。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231133548224-1489136460.png" alt="" width="927" height="751" loading="lazy"></p>
<p>我们在开发初期，模拟定义了静态的菜单资源的信息，如下所示。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ToolbarUtil:
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">工具栏菜单的创建类</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">

    @staticmethod
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> create_tools():
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建工具栏菜单嵌套集合</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        menus </span>=<span style="color: rgba(0, 0, 0, 1)"> [
            MenuInfo(
                id</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">01</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                label</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">用户管理</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                icon</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">user</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                path</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">views.frm_user.FrmUser</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
            ),
            MenuInfo(
                id</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">02</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                label</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">组织机构管理</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                icon</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">organ</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                path</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">views.frm_ou.FrmOU</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
            ),
            ...............
        ]
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> menus</pre>
</div>
<p>那么我们有了动态定义的菜单和动态分配的功能后，我们就可以根据用户ID（角色ID）从后端系统接口中获得对应的菜单列表，然后统一展示即可。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    @staticmethod
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> create_tools_dynamic():
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">动态创建工具栏菜单</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 同步获取菜单信息</span>
        menus =<span style="color: rgba(0, 0, 0, 1)"> api_menu.get_all_nodes_by_user_sync(
            settings.CurrentUser.id, settings.SystemType
        )
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 定义字段映射</span>
        field_mapping = {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">name</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">label</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">winformtype</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">path</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">icon</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">icon</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">}
        newmenus </span>=<span style="color: rgba(0, 0, 0, 1)"> map_with_dynamic_alias(menus, MenuInfo, field_mapping)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> newmenus</pre>
</div>
<p>这样我们在主窗体界面中，构建菜单的函数如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _create_toolbar(self, d=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">H</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建工具栏</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        agwStyle </span>= aui.AUI_TB_TEXT |<span style="color: rgba(0, 0, 0, 1)"> aui.AUI_TB_OVERFLOW

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> d.upper() <span style="color: rgba(0, 0, 255, 1)">in</span> [<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">V</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VERTICAL</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">]:
            agwStyle </span>= aui.AUI_TB_TEXT |<span style="color: rgba(0, 0, 0, 1)"> aui.AUI_TB_VERTICAL

        tb </span>=<span style="color: rgba(0, 0, 0, 1)"> aui.AuiToolBar(
            self, </span>-1, wx.DefaultPosition, wx.DefaultSize, agwStyle=<span style="color: rgba(0, 0, 0, 1)">agwStyle
        )
        tb.SetToolBitmapSize(wx.Size(</span>16, 16<span style="color: rgba(0, 0, 0, 1)">))

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 动态创建工具栏</span>
       <span style="font-size: 18px"> <span style="color: rgba(255, 0, 0, 1); font-family: &quot;Microsoft YaHei&quot;; font-size: 16px">toolbars = ToolbarUtil.create_tools_dynamic()</span></span>

        <span style="color: rgba(0, 0, 255, 1)">for</span> item <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> toolbars:
            tool_id </span>=<span style="color: rgba(0, 0, 0, 1)"> wx.NewIdRef()
            bitmap </span>=<span style="color: rgba(0, 0, 0, 1)"> get_bitmap(item.icon)
            tb.AddSimpleTool(
                tool_id</span>=<span style="color: rgba(0, 0, 0, 1)">tool_id,
                label</span>=<span style="color: rgba(0, 0, 0, 1)">item.label,
                bitmap</span>=<span style="color: rgba(0, 0, 0, 1)">bitmap,
                short_help_string</span>=item.tips <span style="color: rgba(0, 0, 255, 1)">if</span> item.tips <span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> item.label,
            )

            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 绑定事件</span>
<span style="color: rgba(0, 0, 0, 1)">            self.Bind(
                wx.EVT_TOOL,
                partial(self.on_tool_event, item),  </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 这里传递菜单信息</span>
                id=<span style="color: rgba(0, 0, 0, 1)">tool_id,
            )

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 增加系统常用按钮</span>
<span style="color: rgba(0, 0, 0, 1)">        tb.AddSeparator()
        tb.AddSimpleTool(
            self.id_close_all, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">关闭所有</span><span style="color: rgba(128, 0, 0, 1)">"</span>, images.delete_all.Bitmap, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">关闭所有页面</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
        )
        tb.AddSimpleTool(self.id_quit, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">退出</span><span style="color: rgba(128, 0, 0, 1)">"</span>, images.close.Bitmap, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">退出程序</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)</span>
<span style="color: rgba(0, 0, 0, 1)">
        self.Bind(
            wx.EVT_TOOL, </span><span style="color: rgba(0, 0, 255, 1)">lambda</span> event: EventPub.show_about_dialog(), id=<span style="color: rgba(0, 0, 0, 1)">self.id_about
        )
        self.Bind(
            wx.EVT_TOOL, </span><span style="color: rgba(0, 0, 255, 1)">lambda</span> event: EventPub.close_all_page(), id=<span style="color: rgba(0, 0, 0, 1)">self.id_close_all
        )
        tb.Realize()
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> tb</pre>
</div>
<p>动态构建部分菜单后，并加上一些额外的操作功能项目即可。</p>
<p>要动态构建视图的实例，我们需要用到importlib库来导入模块，然后在模块中获得对应类型进行构造处理即可。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> importlib
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> wx

</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">要自动导入一个给定的类（比如 "views.testaui_panel.DocumentPanel"）并在 Python 中使用它，
可以利用 importlib 库来动态地导入模块和类。importlib 允许你在运行时加载模块，
而不需要在代码中显式地使用 import 语句。</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

<span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> dynamic_import(class_path: str):
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 拆分字符串为模块路径和类名</span>
    <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> print(f"Dynamic import: {class_path}")</span>
    module_path, class_name = class_path.rsplit(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">.</span><span style="color: rgba(128, 0, 0, 1)">"</span>, 1<span style="color: rgba(0, 0, 0, 1)">)

    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 动态导入模块</span>
    module =<span style="color: rgba(0, 0, 0, 1)"> importlib.import_module(module_path)

    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取类对象</span>
    class_obj =<span style="color: rgba(0, 0, 0, 1)"> getattr(module, class_name)

    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 返回类对象</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> class_obj</pre>
</div>
<p>例如可以通过下面类似的代码实现对话框展示或者窗口的展示。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span> show_window(class_path: str, parent=None, **<span style="color: rgba(0, 0, 0, 1)">kwargs):
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">根据路径和基类对象，显示窗口</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
    window_class </span>=<span style="color: rgba(0, 0, 0, 1)"> dynamic_import(class_path)
    window </span>= window_class(parent, **<span style="color: rgba(0, 0, 0, 1)">kwargs)
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 判断传入的窗口是 wx.Dialog 还是 wx.Panel</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> isinstance(window, wx.Dialog):
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 如果是 wx.Dialog，调用 ShowModal</span>
        result =<span style="color: rgba(0, 0, 0, 1)"> window.ShowModal()
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Dialog closed with result: {result}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        window.Destroy()  </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 在对话框关闭后销毁</span>
    <span style="color: rgba(0, 0, 255, 1)">elif</span><span style="color: rgba(0, 0, 0, 1)"> isinstance(window, wx.Panel):
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 如果是 wx.Panel，调用 Show</span>
<span style="color: rgba(0, 0, 0, 1)">        window.Show()
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Panel shown</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Unknown window type</span><span style="color: rgba(128, 0, 0, 1)">"</span>)</pre>
</div>
<p>&nbsp;</p>
<h3>2、功能点和按钮的控制处理</h3>
<p>在上面的菜单资源中，直接和角色关联，在用户登录系统后，自动构建对应的菜单（工具栏）显示，而对于功能点和按钮的关联控制处理，我们也是可以采用类似的方式处理的。</p>
<p>首先我们在当前终端的全局设置对象里面定义好拥有的功能点对象，如下代码所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102101803178-978554576.png" alt="" width="676" height="235" loading="lazy"></p>
<p>我们在用户成功登录系统（认证用户通过）后，获取用户的详细信息，以及相关联的资源（包括菜单、功能点、角色列表）等信息进行全局存储，方便在用到的地方进行调用判断，如下代码所示。</p>
<div class="cnblogs_code">
<pre>    async <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> SetLoginInfo(self):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">设置登录信息</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        userid </span>=<span style="color: rgba(0, 0, 0, 1)"> settings.AccessTokenResult.userid
        res </span>=<span style="color: rgba(0, 0, 0, 1)"> await api_user.Get(userid)</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> res.success:
            settings.CurrentUser </span>=<span style="color: rgba(0, 0, 0, 1)"> res.result
            await self.GetSystemType()
            await self.GetFunctionsByUser(userid)
            await self.GetRolesByUser(userid)

            EventPub.user_info_loaded()  </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 发布用户信息加载完成事件</span></pre>
</div>
<p>我们前面随笔介绍过，一般列表窗体是继承一个统一的基类的。</p>
<p>在我的WxPython跨平台开发框架中，我们对于常规窗体列表界面做了抽象处理，一般绝大多数的逻辑封装在基类上，基类提供一些可重写的函数给子类实现弹性化的处理。</p>
<p>如下是基类窗体和其他窗体之间的集成关系。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202411/8867-20241111131058275-415274506.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>由于基类是通过泛型类型的定义的，因此可以对子类的相关逻辑进行统一抽象处理，以便实现常规功能的控制（包括新增、编辑、删除、批量添加、打印、导入、导出等）。</p>
<p>如对于客户信息的列表窗体，我们的视图类如下所示（（通过代码生成工具Database2Sharp生成即可，之前随笔《<a class="postTitle2 vertical-middle pinned-post" href="https://www.cnblogs.com/wuhuacong/p/18583832">在自家的代码生成工具中，增加对跨平台WxPython项目的前端代码生成，简直方便的不得了</a>》介绍过）。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102102535184-1162207911.png" alt="" width="694" height="515" loading="lazy"></p>
<p>&nbsp;我们可以看到，其中model是由子类传入的一个对象类型，那么我们在父类也可以统一进行获取它的名称进行处理即可。</p>
<p>在BaseListFrame类里面，我们定义一个判断是否有对应功能点的函数，如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> HasAction(self, action_id: str, entity_name: str = None) -&gt;<span style="color: rgba(0, 0, 0, 1)"> bool:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">判断权限缓存是否存在指定操作功能id

        :param action_id: 操作功能id, 如Add,Edit,Delete, Import,Export等
        :param entity_name: 实体名称, 默认根据self.model的名称获取并替换后缀Dto，如Customer,Product等
        :return: 存在返回True，否则返回False
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(0, 0, 255, 1)">not</span><span style="color: rgba(0, 0, 0, 1)"> action_id:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> False

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(0, 0, 255, 1)">not</span><span style="color: rgba(0, 0, 0, 1)"> entity_name:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 根据self.model的名称获取并替换后缀Dto</span>
            entity_name = self.model.<span style="color: rgba(128, 0, 128, 1)">__qualname__</span>.replace(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Dto</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">""</span><span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 判断权限缓存是否存在类似"Customer:Add"格式的字符串</span>
        result = f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{entity_name}:{action_id}</span><span style="color: rgba(128, 0, 0, 1)">"</span> <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> settings.FunctionDict</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> result</pre>
</div>
<p>这样我们约定了模块和功能点的名称前缀后，就可以通用的处理判断了。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102103549250-1271720731.png" alt="" width="818" height="683" loading="lazy"></p>
<p>由于我们常规的新增、编辑、删除、导出等操作由父类统一生成标准的按钮，那么我们就可以根据是否有某些功能的标识进行构建了，如下代码所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _CreateCommonButtons(self, pane: wx.Window):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">父类窗口统一创建通用按钮</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 增加按钮</span>
        btns_sizer =<span style="color: rgba(0, 0, 0, 1)"> wx.BoxSizer(wx.HORIZONTAL)

        button_list </span>=<span style="color: rgba(0, 0, 0, 1)"> []
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置图标和位置</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> EventFlags.EVT_Search &amp;<span style="color: rgba(0, 0, 0, 1)"> self.EVT_FLAGS:
            btn_search </span>=<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
                pane,
                </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">查询</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">search</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                handler</span>=<span style="color: rgba(0, 0, 0, 1)">self._on_first_page,
                is_async</span>=<span style="color: rgba(0, 0, 0, 1)">True,
                id</span>=<span style="color: rgba(0, 0, 0, 1)">wx.ID_FIND,
            )
            button_list.append(btn_search)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_add:
            btn_add </span>=<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
                pane, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">新增</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">add</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=self.OnAdd, is_async=<span style="color: rgba(0, 0, 0, 1)">True
            )
            button_list.append(btn_add)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_edit:
            btn_edit </span>=<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
                pane, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">编辑</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">edit</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=self.OnEdit, is_async=<span style="color: rgba(0, 0, 0, 1)">True
            )
            button_list.append(btn_edit)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_delete:
            btn_delete </span>=<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
                pane, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">批量删除</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">delete</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=self.OnDelete, is_async=<span style="color: rgba(0, 0, 0, 1)">True
            )
            button_list.append(btn_delete)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_export:
            btn_export </span>=<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
                pane, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">导出Excel</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">xls</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=self.OnExport, is_async=<span style="color: rgba(0, 0, 0, 1)">True
            )
            button_list.append(btn_export)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 将按钮添加到按钮组中</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> btn <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> button_list:
            btns_sizer.Add(btn, 0, wx.ALL, </span>3<span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> btns_sizer</pre>
</div>
<p>我们这里使用了辅助类创建按钮&nbsp;ControlUtil.create_button 方便控制相关的内容。类似的右键菜单我们也可以如此操作，判断权限是否拥有再构建即可。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> _on_showmenu(self, event: wx.grid.GridEvent) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">父类窗体的右键菜单处理</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建右键菜单对象</span>
        menu: wx.Menu =<span style="color: rgba(0, 0, 0, 1)"> wx.Menu()

        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_add:
            ControlUtil.create_menu(
                self, menu, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">新增</span><span style="color: rgba(128, 0, 0, 1)">"</span>, icon_name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">add</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=<span style="color: rgba(0, 0, 0, 1)">self._OnMenuAdd
            )
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_edit:
            ControlUtil.create_menu(
                self, menu, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">编辑</span><span style="color: rgba(128, 0, 0, 1)">"</span>, icon_name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">edit</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=<span style="color: rgba(0, 0, 0, 1)">self._OnMenuEdit
            )
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_delete:
            ControlUtil.create_menu(
                self, menu, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">删除选中行</span><span style="color: rgba(128, 0, 0, 1)">"</span>, icon_name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">delete</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=<span style="color: rgba(0, 0, 0, 1)">self._OnMenuDelete
            )

        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_export:
            ControlUtil.create_menu(
                self, menu, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">导出Excel</span><span style="color: rgba(128, 0, 0, 1)">"</span>, icon_name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">xls</span><span style="color: rgba(128, 0, 0, 1)">"</span>, handler=<span style="color: rgba(0, 0, 0, 1)">self._OnMenuExport
            )

          ............</span></pre>
</div>
<p><img src="https://img2024.cnblogs.com/blog/8867/202501/8867-20250102105712753-1546984116.png" alt="" width="806" height="531" loading="lazy"></p>
<p>这些都是父类窗体，对通用操作的权限判断和创建处理，如果对于子类窗体，我们也可以使用这些判断标识来增加一些额外的操作按钮或者菜单的。</p>
<p>如对于字典模块列表界面中，判读它是否有批量添加的操作权限，并添加相关的功能入口。如下所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> CreateCustomMenus(self, parent_menu: wx.Menu) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">子类重写该方法，创建自定义菜单</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 父类已创建默认菜单，这里添加自定义菜单</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.has_batch_add:
            ControlUtil.create_menu(
                self,
                parent_menu,
                </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">批量添加字典</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">batch_add</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnMenuBatchAdd,
            )</span></pre>
</div>
<p>对于查看/编辑/新增的窗体，它们也是有一个通用的编辑对话框基类的，因此也可以和列表的方式实现同样的功能控制，这里不在赘述。</p>
<p>以上就是对于登录系统后的用户，对用户的菜单（工具栏）、界面操作按钮的权限进行动态化的绑定和统一处理的操作过程，这样对于我们界面，只需要约定一些规则即可实现比较弹性化的操作，非常方便。</p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <div style="border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;">
    <img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" align="top" alt="">
    <span style="color: #000000"><span class="Apple-tab-span" style="white-space: pre"></span>
     专注于代码生成工具、.Net/.NetCore 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架等框架产品。
     <br>&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href="http://www.iqidi.com/" target="_blank">http://www.iqidi.com</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.05132996701388889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-02 11:08">2025-01-02 11:08</span>&nbsp;
<a href="https://www.cnblogs.com/wuhuacong">伍华聪</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18643810" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18643810);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18643810', targetLink: 'https://www.cnblogs.com/wuhuacong/p/18643810', title: 'WxPython跨平台开发框架之动态菜单的管理和功能权限的控制' })">举报</a>

        </p>
    