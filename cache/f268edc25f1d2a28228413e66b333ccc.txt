
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tansm/p/18847143/AOTDemo" title="发布于 2025-04-25 18:03">
    <span role="heading" aria-level="2">使用 AOT 编译保护 .NET 核心逻辑，同时支持第三方扩展</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        在开发大型ERP .NET 应用程序时，如何创建一个可供第三方引用的组件（DLL）以便二次开发，但同时保护核心逻辑不被轻易反编译，还要支持反射机制（包括私有字段访问），并且坚持使用 C# 开发，而非 C++/CLI。在这篇博客中，我将分享我的探索历程，包括遇到的困难、尝试的方案，以及最终实现的解决方案。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>在开发大型ERP .NET 应用程序时，我面临一个挑战：如何创建一个可供第三方引用的组件（DLL）以便二次开发，但同时保护核心逻辑不被轻易反编译，还要支持反射机制（包括私有字段访问），并且坚持使用 C# 开发，而非 C++/CLI。在这篇博客中，我将分享我的探索历程，包括遇到的困难、尝试的方案，以及最终实现的解决方案。这个方案利用了 Ahead-of-Time（AOT）编译，成功实现了核心逻辑保护和第三方扩展的完美平衡。</p>
<h2 id="场景与需求">场景与需求</h2>
<p>我需要开发一个 .NET 组件（DLL），供第三方开发者引用，同时满足以下要求：</p>
<ul>
<li><strong>可作为 .NET 组件引用</strong>：第三方应能通过项目引用或 NuGet 包直接使用我的组件。</li>
<li><strong>保护核心逻辑</strong>：核心逻辑不能被简单反编译为可读的 C# 代码。</li>
<li><strong>支持反射</strong>：包括对私有字段的反射访问，需保持完整功能。</li>
<li><strong>使用 C# 开发</strong>：避免使用 C++/CLI，坚持使用 C# 以保持开发一致性。</li>
</ul>
<p>此外，我希望第三方开发者能够开发插件，扩展我的应用程序功能，同时在调试时只看到自己的代码，而不会暴露我的核心逻辑。</p>
<h2 id="尝试的方案及其优缺点">尝试的方案及其优缺点</h2>
<p>在找到最终解决方案之前，我尝试了多种方法，每种方法都有其优点和局限性。</p>
<h3 id="方案-1直接使用-aot-编译">方案 1：直接使用 AOT 编译</h3>
<p>我首先尝试使用 .NET 的 Native AOT 编译，将我的 DLL 编译为本地代码，以移除 IL（中间语言），从而增加反编译难度。然而，我发现：</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>AOT 编译生成纯机器码，难以反编译。</li>
<li>启动性能优异，适合高性能场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>AOT默认编译出单一的exe；</li>
<li>虽然后面成功让 AOT 编译生成的 DLL ，但他是本地库，无法作为标准 .NET 程序集被引用。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：AOT 编译不适合直接生成可引用的 .NET 组件。</p>
<h3 id="方案-2使用-publishreadytorun">方案 2：使用 PublishReadyToRun</h3>
<p>接下来，我尝试了 <code>PublishReadyToRun</code> 选项，它将 IL 预编译为本地代码，同时保留 IL。我希望这能提高性能并增加反编译难度。然而：</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>生成的 DLL 是标准 .NET 程序集，可被第三方引用。</li>
<li>启动性能有所提升。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>IL 仍然存在，仍然可以被反编译工具（如 ILSpy 或 dotPeek）读取。</li>
<li>无法完全保护核心逻辑。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：PublishReadyToRun 无法满足移除 IL 和防止反编译的要求。</p>
<h3 id="方案-3使用混淆工具">方案 3：使用混淆工具</h3>
<p>我还考虑了使用混淆工具（如 Eazfuscator.NET 或 .NET Reactor）来保护代码。这些工具通过重命名符号、加密字符串等方式使 IL 难以阅读。然而：</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>显著增加反编译难度。</li>
<li>支持通过属性（如 <code>ObfuscationAttribute</code>）保留反射功能。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>IL 仍然存在，理论上仍可被高级工具反编译。</li>
<li>配置复杂，尤其是需要保留反射的私有字段时。</li>
<li>仅使代码难以阅读，而非完全不可读。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：混淆工具虽有效，但无法完全消除 IL，且与反射需求存在潜在冲突。</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>经过多次尝试，我设计了一个结合 AOT 编译和插件架构的解决方案，成功满足了所有需求。以下是方案的详细说明。</p>
<h3 id="解决方案概述">解决方案概述</h3>
<p>我将组件分为以下四个部分：</p>
<ol>
<li>
<p><strong>AOTDemo.Services.dll</strong>：</p>
<ul>
<li>包含接口（<code>IDemoService</code>、<code>IPlugin</code>）和简单类（<code>QueryArgs</code>）。</li>
<li>作为标准 .NET 程序集，供第三方直接引用。</li>
<li>不包含核心逻辑，公开提供给第三方。</li>
</ul>
</li>
<li>
<p><strong>AOTDemo.dll</strong>：</p>
<ul>
<li>包含核心逻辑的实现（<code>DemoService</code>），实现 <code>IDemoService</code> 接口。</li>
<li>通过 AOT 编译为本地代码，保护核心逻辑不被反编译。</li>
<li>被主程序引用。</li>
</ul>
</li>
<li>
<p><strong>MyApp.exe</strong>：</p>
<ul>
<li>主程序，负责启动应用程序。</li>
<li>通过 AOT 编译，包含 <code>AOTDemo.dll</code> 的核心逻辑。</li>
<li>动态加载第三方插件，并通过服务容器提供核心服务。</li>
</ul>
</li>
<li>
<p><strong>MyPlugin.dll</strong>：</p>
<ul>
<li>第三方开发的插件，引用 <code>AOTDemo.Services.dll</code>。</li>
<li>实现 <code>IPlugin</code> 接口，通过服务容器访问核心服务。</li>
</ul>
</li>
</ol>
<h3 id="工作流程">工作流程</h3>
<ul>
<li>
<p><strong>开发阶段</strong>：</p>
<ul>
<li>我在 <code>AOTDemo.Services.dll</code> 中定义接口和简单类。</li>
<li>在 <code>AOTDemo.dll</code> 中实现核心逻辑。</li>
<li><code>MyApp.exe</code> 引用 <code>AOTDemo.dll</code> 并通过 AOT 编译。</li>
<li>第三方开发者引用 <code>AOTDemo.Services.dll</code>，开发插件（如 <code>MyPlugin.dll</code>）。</li>
</ul>
</li>
<li>
<p><strong>运行时</strong>：</p>
<ul>
<li><code>MyApp.exe</code> 启动，创建服务容器并注册核心服务（<code>DemoService</code>）。</li>
<li>动态加载第三方插件（<code>MyPlugin.dll</code>），通过反射创建插件实例。</li>
<li>插件通过服务容器调用核心服务，执行功能。</li>
<li>第三方调试时，堆栈仅显示插件代码，不包含 <code>MyApp.exe</code> 或 <code>AOTDemo.dll</code> 的内部方法。</li>
</ul>
</li>
</ul>
<h3 id="项目结构与代码示例">项目结构与代码示例</h3>
<p>以下是关键文件的内容和配置。</p>
<h4 id="aotdemoservicesdll">AOTDemo.Services.dll</h4>
<ul>
<li><strong>Services.cs</strong>：定义接口和数据类。</li>
</ul>
<pre><code class="language-csharp">namespace AOTDemo.Services
{
    public class QueryArgs
    {
        public string Name { get; set; } = string.Empty;
        public int Age { get; set; }
    }

    public interface IDemoService
    {
        string query(string query, QueryArgs args);
    }

    public interface IPlugin
    {
        int Run();
    }
}
</code></pre>
<h4 id="aotdemodll">AOTDemo.dll</h4>
<ul>
<li><strong>ServiceImpl.cs</strong>：实现核心逻辑。</li>
</ul>
<pre><code class="language-csharp">using AOTDemo.Services;
using System.Runtime.InteropServices;

namespace AOTDemo
{
    public class DemoService : IDemoService
    {
        public string query(string query, QueryArgs args)
        {
            return $"exe:{query}, Name: {args.Name}, Age: {args.Age}";
        }
    }
}
</code></pre>
<h4 id="myappexe">MyApp.exe</h4>
<ul>
<li><strong>Program.cs</strong>：主程序，加载插件并提供服务。</li>
</ul>
<pre><code class="language-csharp">// 创建一个服务容器
using AOTDemo;
using AOTDemo.Services;
using System.ComponentModel.Design;
using System.Reflection;

// 创建一个服务容器，将服务注册到容器中
var services = new ServiceContainer();
services.AddService(typeof(IDemoService), new DemoService());

// 并且 MyPlugin.dll 位于当前工作目录或指定路径
var pluginAssemblyPath = args[0]; // "MyPlugin.dll"; // 外部 DLL 的路径
var pluginAssembly = Assembly.LoadFrom(pluginAssemblyPath); // 加载 DLL

// 从参数的 1 参数，获取 一个 class 名称，模拟使用反射获取一个外部插件
var pluginName = args[1];
var pluginType = pluginAssembly.GetType(pluginName);
if (pluginType == null) {
    Console.WriteLine($"无法找到类型: {pluginName}");
    return;
}

// 创建插件实例
// 注意插件的构造函数第一个参数是一个 IServiceProvider
var plugin = (IPlugin?)Activator.CreateInstance(pluginType, services);
if (plugin == null) {
    Console.WriteLine($"无法创建插件实例: {pluginName}");
    return;
}

// 运行插件
plugin.Run();

// 演示即使加载的是外部 DLL，没有进行AOT编译，也可以使用反射
plugin.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance)
    .ToList()
    .ForEach(f =&gt; Console.WriteLine($"Field: {f.Name} , value = {f.GetValue(plugin)}"));
</code></pre>
<h4 id="myplugindll">MyPlugin.dll</h4>
<ul>
<li><strong>MyPlugin.cs</strong>：第三方插件示例。</li>
</ul>
<pre><code class="language-csharp">using AOTDemo.Services;
using System.Reflection;

namespace AOTDemo {
    public class MyPlugin : IPlugin {
        private IServiceProvider _serviceProvider;
        public MyPlugin(IServiceProvider serviceProvider) {
            _serviceProvider = serviceProvider;
        }

        public int Run() {
            // 假装获取一个服务
            var service = (IDemoService)_serviceProvider.GetService(typeof(IDemoService));
            var args = new QueryArgs() { Name = "AOT", Age = 18 };
            var result = service.query("Hello", args);
            Console.WriteLine(result);

            // 演示即使外部服务进行AOT编译，也可以使用反射
            var queryMethod = service.GetType().GetMethod("query", BindingFlags.Public | BindingFlags.Instance);
            result = (String)queryMethod.Invoke(service, new object[] { "Hello2", args });
            Console.WriteLine(result);

            return 0;
        }
    }
}
</code></pre>
<h3 id="发布与运行">发布与运行</h3>
<ul>
<li>
<p><strong>发布 MyApp.exe</strong>：</p>
<ul>
<li>使用Visual Studio 发布 AOT 编译的 <code>MyApp.exe</code>，我创建 win-x64,单个exe文件，你可以根据自己需要创建更多的类型；</li>
<li>因为主项目引用了 <code>AOTDemo.dll</code>，所以自然一并AOT了。</li>
</ul>
</li>
<li>
<p><strong>分发 AOTDemo.Services.dll</strong>：</p>
<ul>
<li>直接提供 <code>AOTDemo.Services.dll</code> 给第三方，他是标准 .NET 程序集，不经过AOT处理。</li>
</ul>
</li>
<li>
<p><strong>运行</strong>：</p>
<ul>
<li>最终执行只需要主 exe 和 第三方插件；</li>
<li>运行 <code>MyApp.exe</code>，指定插件 DLL 和类名：<pre><code class="language-bash">MyApp.exe MyPlugin.dll AOTDemo.MyPlugin
</code></pre>
</li>
<li>插件通过服务容器调用核心服务，输出结果。</li>
</ul>
</li>
</ul>
<p><img src="https://tansm.github.io/images/Run.png" alt="alt text" loading="lazy"></p>
<h3 id="调试体验">调试体验</h3>
<p>一个令人兴奋的成果是，第三方开发者在调试插件时，调用堆栈仅显示他们的代码（<code>MyPlugin.dll</code>），不包含 <code>MyApp.exe</code> 或 <code>AOTDemo.dll</code> 的内部方法。这得益于插件架构的隔离设计，确保核心逻辑对第三方完全透明。</p>
<p><img src="https://tansm.github.io/images/PluginDebug.png" alt="alt text" loading="lazy"></p>
<p>而且你可以看见，核心组件的字段和.net组件的调试信息仍然存在，没有降低开发体验；</p>
<h2 id="方案优点与局限性">方案优点与局限性</h2>
<h3 id="优点">优点</h3>
<ul>
<li><strong>核心逻辑保护</strong>：<code>AOTDemo.dll</code> 和 <code>MyApp.exe</code> 通过 AOT 编译为本地代码，无 IL，难以反编译。</li>
<li><strong>标准 .NET 引用</strong>：<code>AOTDemo.Services.dll</code> 是标准 .NET 程序集，第三方可轻松引用。</li>
<li><strong>反射支持</strong>：<code>AOTDemo.Services.dll</code> 保留完整元数据，支持反射，包括私有字段。</li>
<li><strong>扩展性</strong>：插件架构允许第三方开发自定义功能。</li>
<li><strong>C# 开发</strong>：整个解决方案使用 C#，无需 C++/CLI。</li>
<li><strong>调试隔离</strong>：第三方调试时仅看到自己的代码，保护核心逻辑隐私。</li>
</ul>
<h3 id="局限性">局限性</h3>
<ul>
<li><strong>AOT 编译限制</strong>：运维和调试流程与常见的.net组件不是完全一致，需要一些学习。</li>
<li><strong>分发复杂性</strong>：需要为不同平台（如 Windows、Linux）提供 AOT 编译的 <code>MyApp.exe</code>。</li>
</ul>
<h2 id="对比分析">对比分析</h2>
<p>以下表格总结了不同方案的优缺点：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>可作为 .NET 组件引用</th>
<th>保护代码效果</th>
<th>反射支持</th>
<th>开发复杂性</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接 AOT 编译</td>
<td>否</td>
<td>好（无 IL）</td>
<td>有限</td>
<td>中等</td>
<td>无法直接引用</td>
</tr>
<tr>
<td>PublishReadyToRun</td>
<td>是</td>
<td>一般（保留 IL）</td>
<td>是</td>
<td>低</td>
<td>可反编译</td>
</tr>
<tr>
<td>混淆工具</td>
<td>是</td>
<td>一般（IL 难以阅读）</td>
<td>是（需配置）</td>
<td>低</td>
<td>IL 仍存在</td>
</tr>
<tr>
<td>本方案（AOT + 接口）</td>
<td>是</td>
<td>好（核心逻辑无 IL）</td>
<td>是</td>
<td>低</td>
<td>推荐方案</td>
</tr>
</tbody>
</table>
<h2 id="结论">结论</h2>
<p>通过将组件分为接口定义（<code>AOTDemo.Services.dll</code>）、核心逻辑（<code>AOTDemo.dll</code>）和主程序（<code>MyApp.exe</code>），并结合 AOT 编译和插件架构，我成功实现了一个既保护核心逻辑又支持第三方扩展的 .NET 解决方案。这个方案不仅满足了我的所有需求，还提供了良好的调试体验，让第三方开发者能够专注于自己的代码，而无需接触核心逻辑。</p>
<p>我希望这个解决方案能为其他 .NET 开发者提供启发，特别是在需要保护知识产权和支持扩展性的场景中。感谢探索过程中的挑战，它们让我找到了这个令人满意的答案！</p>
<h2 id="代码">代码</h2>
<p>我已经将演示代码放在开源社区，有兴趣的朋友可以下载尝试。<br>
<a href="https://github.com/tansm/AOTDemo" target="_blank" rel="noopener nofollow">https://github.com/tansm/AOTDemo</a></p>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.8446128497002314" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 18:04">2025-04-25 18:03</span>&nbsp;
<a href="https://www.cnblogs.com/tansm">编写人生</a>&nbsp;
阅读(<span id="post_view_count">245</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18847143);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18847143', targetLink: 'https://www.cnblogs.com/tansm/p/18847143/AOTDemo', title: '使用 AOT 编译保护 .NET 核心逻辑，同时支持第三方扩展' })">举报</a>
</div>
