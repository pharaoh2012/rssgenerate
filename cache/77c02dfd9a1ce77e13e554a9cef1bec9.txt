
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/BNTang/p/19056157" title="发布于 2025-08-25 00:51">
    <span role="heading" aria-level="2">Spring 调试新姿势：一眼看清运行时，用 Spring Debugger 少踩 90% 坑</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>当你的 Spring 项目出现「本地复现不了」「配置生效顺序不明」「事务状态难判断」「Bean 注入链条太长」时，传统断点只让你盯着一片树叶。</p>
<p>IntelliJ IDEA Ultimate 的 Spring Debugger 能把整片「森林」摊开：哪个 Bean 被实例化、配置最终值是什么、数据库连接与事务此刻处于什么状态，你都能在 IDE 里一眼看清。</p>
<p>它把运行时细节可视化，帮助你更快定位问题、验证应用状态，进而写出更稳定、可维护的代码。可以把它理解为你 Spring 应用的运行时“X 光机”。</p>
<hr>
<h2 id="spring-debugger-到底是啥">Spring Debugger 到底是啥？</h2>
<p>这是 IntelliJ IDEA Ultimate（2025.2+）提供的针对 Spring 的调试增强能力。只要进入 Debug，会在编辑器、Debugger 工具窗口与项目视图中「活体显示」Spring 运行时信息：<code>ApplicationContext</code>、配置属性、数据源、事务、Bean 状态等。</p>
<p>你会收获：</p>
<ul>
<li>更快定位：可视化直达问题根因，少走弯路。</li>
<li>更准验证：运行时即看即得，配置值与 Bean 状态当场确认。</li>
<li>更稳交付：减少盲试错，提升代码与配置的可维护性。</li>
</ul>
<blockquote>
<p>注意：需要 IntelliJ IDEA Ultimate；社区版不支持。</p>
</blockquote>
<hr>
<h2 id="怎么启用两步搞定">怎么启用（两步搞定）</h2>
<ol>
<li><code>Ctrl</code> + <code>Alt</code> + <code>S</code> 打开设置 → 插件（Plugins）→ 搜索并安装「Spring Debugger」。若提示，重启 IDE。</li>
<li>用 Debug 模式运行你的 Spring 应用，即可体验所有能力。</li>
</ol>
<hr>
<h2 id="能力一配置最终值回显与来源追踪搞清楚到底哪个值生效">能力一：配置“最终值”回显与来源追踪（搞清楚到底哪个值生效）</h2>
<p>痛点：<code>.properties</code>/<code>.yml</code> 多来源、占位符与覆盖链一长串，最后谁生效？</p>
<p>Spring Debugger 会在编辑器相应行显示运行时的「最终值」，并支持跳转查看“谁覆盖了谁”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824223847432-1214591145.png" alt="" loading="lazy"><br>
图：编辑器内直接显示属性的最终运行时值</p>
<p>你可以这样试：</p>
<p>在 <code>application.properties</code>：</p>
<pre><code>my.test.value=from-properties
</code></pre>
<p>在 <code>application-dev.properties</code>：</p>
<pre><code>my.test.value=from-dev
</code></pre>
<p>以 Debug 启动并激活 <code>dev</code>：<code>--spring.profiles.active=dev</code>（也可在 <code>application.properties</code> 中指定）。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824224817016-1429405936.png" alt="" loading="lazy"><br>
图：同一属性在不同配置源下的最终值对比</p>
<p>更妙的是，若代码里在运行时更新了配置值（比如 <code>Environment</code>/<code>ConfigurablePropertyResolver</code> 相关逻辑），最新值也会直接显示，并且可以一键跳转到“覆盖它”的那段代码位置。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824233353747-571923563.png" alt="" loading="lazy"><br>
图：从最终值快速导航到覆盖来源</p>
<hr>
<h2 id="能力二bean-一览无余谁加载了谁没加载谁是-mock">能力二：Bean 一览无余（谁加载了、谁没加载、谁是 Mock）</h2>
<p>在调试模式下运行应用时，Project 工具窗口会按 Spring 视角标注每个 Bean 的运行时状态，加载与否一目了然：</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824233025456-1899761079.png" alt="" loading="lazy"></p>
<p>图标颜色含义：</p>
<ul>
<li>绿色（green）— 已加载</li>
<li>透明（transparent）— 未加载</li>
<li>黄色（yellow）— Mock（模拟）</li>
</ul>
<p>常见 Bean 类型（不同类型会用不同图标标识，便于快速分辨）：</p>
<h3 id="1-component--bean">1. <code>@Component</code> / <code>@Bean</code></h3>
<ul>
<li>自动发现的组件以及通过 <code>@Bean</code> 方法定义的 Bean。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824231937703-717927763.png" alt="" loading="lazy"></p>
<h3 id="2-configuration">2. <code>@Configuration</code></h3>
<ul>
<li>配置类 Bean（<code>@Configuration</code> 或隐式包含该注解的类）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824232023573-1400354909.png" alt="" loading="lazy"></p>
<h3 id="3-repository">3. <code>@Repository</code></h3>
<ul>
<li>存储库 Bean（<code>@Repository</code> 或实现 <code>org.springframework.data.repository.Repository</code>）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824232146064-251291452.png" alt="" loading="lazy"></p>
<h3 id="4-controller">4. <code>@Controller</code></h3>
<ul>
<li>控制器（<code>@Controller</code> / <code>@RestController</code>）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824232250622-642037777.png" alt="" loading="lazy"></p>
<h3 id="5-隐式-beanimplicit-beans">5. 隐式 Bean（implicit beans）</h3>
<ul>
<li>Spring 自带且非显式定义的基础服务类 Bean。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235314063-1111775175.png" alt="" loading="lazy"></p>
<h3 id="6-抽象-xml-bean">6. 抽象 XML Bean</h3>
<ul>
<li>在 XML 中使用 <code>abstract="true"</code> 定义的抽象 Bean。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235408633-348802528.png" alt="" loading="lazy"></p>
<h3 id="7-基础设施-beaninfrastructure-beans">7. 基础设施 Bean（infrastructure beans）</h3>
<ul>
<li>与配置/基础设施支持相关的 XML Bean，如 <code>ViewResolver</code> 或 <code>context:component-scan</code> 相关。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235444093-564055547.png" alt="" loading="lazy"></p>
<h3 id="8-原型作用域-bean">8. 原型作用域 Bean</h3>
<ul>
<li>在 XML 中 <code>scope="prototype"</code> 定义的原型 Bean。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235516978-1325733280.png" alt="" loading="lazy"></p>
<h3 id="9-其他-xml-定义的-bean">9. 其他 XML 定义的 Bean</h3>
<ul>
<li>除以上类别外的 XML Bean。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235542741-661962806.png" alt="" loading="lazy"></p>
<p>实战价值：快速确认某个 Bean 是否被容器加载、是否被 Mock 替代、是否被排除，从而定位“为什么没生效”。</p>
<hr>
<h2 id="能力三数据库连接自动发现不配数据源也能看">能力三：数据库连接自动发现（不配数据源也能看）</h2>
<p>调试模式下，IDE 会在数据库工具窗口自动展示应用当前使用的数据库连接。适用于：</p>
<ul>
<li>你还没在 IDE 里配置数据源</li>
<li>多数据源/微服务场景</li>
<li>通过 Docker Compose 启动的业务流程</li>
</ul>
<p>启动前：</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824233713908-1083603209.png" alt="" loading="lazy"></p>
<p>启动后：</p>
<ul>
<li>用 Debug 运行 Spring 应用</li>
<li>打开数据库工具窗口</li>
<li>点击刷新</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824233800121-1644806366.png" alt="" loading="lazy"></p>
<p>在发现出的数据库上，你可以查看表、直接执行 SQL、浏览 schema，和普通数据源的体验一致。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824234108981-1397302604.png" alt="" loading="lazy"></p>
<hr>
<h2 id="能力四在-debugger-表达式里直接用-spring-上下文随取随用">能力四：在 Debugger 表达式里直接用 Spring 上下文（随取随用）</h2>
<p>调试时，无论当前栈帧里有没有，你都可以在“计算表达式/监视”中访问 Spring 的属性与任意 Bean，直接调用其方法来取数、做假设验证。</p>
<h3 id="1从编辑器直接计算或添加监视">1）从编辑器直接计算或添加监视</h3>
<ul>
<li>按住 <code>Alt</code>，用鼠标点击要计算的表达式</li>
<li>或选择表达式后使用 <code>Ctrl</code> + <code>Alt</code> + <code>F8</code> 打开“计算表达式”</li>
<li>支持代码补全，避免拼写错误，写得更快</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825000105102-910532327.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825000630008-1946836811.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825000754707-1995652638.png" alt="" loading="lazy"></p>
<h3 id="2在变量页签里评估任意表达式">2）在变量页签里评估任意表达式</h3>
<ul>
<li>在 Variables 的“评估表达式”输入框中输入，回车即可</li>
<li>可将结果加入“监视”，后续持续观察</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825001007412-1633510863.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825001032612-580751749.png" alt="" loading="lazy"></p>
<p>为了更方便查看集合/大对象，可以使用“探索元素”在独立对话框分页浏览与筛选；若结果是 JSON/XML 字符串，还能按结构化文档方式折叠/导航。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825001636482-31720520.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825001742737-1639688409.png" alt="" loading="lazy"></p>
<h3 id="3直接评估-spring-属性">3）直接评估 Spring 属性</h3>
<ul>
<li>在表达式输入框右侧选择「Spring Properties」</li>
<li>输入属性名并回车即可查看值与来源详情</li>
<li>也可以把该属性加入“监视”</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825001941017-414245652.png" alt="" loading="lazy"></p>
<h3 id="4把表达式用到断点里条件与临时日志">4）把表达式用到断点里（条件与临时日志）</h3>
<ul>
<li>右键断点，给“条件”填写表达式，仅在满足时才挂起</li>
<li>或者在“更多”里使用“评估并日志”，打印表达式结果但不打断程序（可取消“挂起”）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002226720-1617799918.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002313138-1044811861.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002333674-2074092713.png" alt="" loading="lazy"></p>
<hr>
<h2 id="能力五把事务与实体状态摊开给你看">能力五：把事务与实体状态“摊开”给你看</h2>
<p>当你调试的代码运行在 JPA 事务里，Debugger 会显示会话上下文，包括：隔离级别、传播行为、缓存内容等。你还能直接看到 JPA 实体此刻到底是 managed 还是 detached。</p>
<h3 id="怎么看事务详情">怎么看事务详情</h3>
<ul>
<li>在事务里的执行行挂起应用</li>
<li>打开“调试”工具窗口 → 切到“变量”页签 → 展开“事务”节点</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002457991-2007447020.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002511726-999459267.png" alt="" loading="lazy"></p>
<p>还可以一键导航到“事务是从哪里开始的”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002542938-817864379.png" alt="" loading="lazy"></p>
<p>对于事务中的 JPA 实体，会在“变量”页签与代码引用位置展示它们的当前状态，排查“为啥更新没刷新/为啥变成了游离态”这类问题非常直观。</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250825002555550-139987316.png" alt="" loading="lazy"></p>
<hr>
<h2 id="需要时也能一键禁用">需要时，也能一键禁用</h2>
<p>如果某个 Run/Debug 配置不想启用 Spring Debugger：</p>
<ul>
<li>打开对应 Run/Debug 配置 → 点击「修改选项」→ 勾选「禁用 Spring Debugger」。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202508/2105804-20250824235107301-355809764.png" alt="" loading="lazy"></p>
<hr>
<h2 id="什么时候特别有用">什么时候特别有用？</h2>
<ul>
<li>配置值“说一套、跑一套”，需要快速确认最终值与来源</li>
<li>Bean 链条复杂，不确定到底加载了谁/被谁替换了谁</li>
<li>多数据源或微服务场景，想直接看到实时连接并执行验证 SQL</li>
<li>复杂断点逻辑，想临时打印/条件暂停而不改业务代码</li>
<li>事务边界模糊，JPA 实体状态难断</li>
</ul>
<hr>
<h2 id="小结与行动">小结与行动</h2>
<ul>
<li>这是一套“在运行时看清一切”的调试新姿势：配置、Bean、数据库、表达式、事务，一个窗口看全局。</li>
<li>今天就装上，用 Debug 打开你的项目，先挑一个最近卡住的小问题试试手：比如检查一个配置是否真生效，或看某个 Bean 到底有没有被加载。</li>
<li>如果这篇文章对你有用，转给同事一起少踩坑；也欢迎留言说说你在项目里遇到的“看不清”的调试难题，我们一起把坑填平。</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-25 00:51">2025-08-25 00:51</span>&nbsp;
<a href="https://www.cnblogs.com/BNTang">BNTang</a>&nbsp;
阅读(<span id="post_view_count">134</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19056157);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19056157', targetLink: 'https://www.cnblogs.com/BNTang/p/19056157', title: 'Spring 调试新姿势：一眼看清运行时，用 Spring Debugger 少踩 90% 坑' })">举报</a>
</div>
        