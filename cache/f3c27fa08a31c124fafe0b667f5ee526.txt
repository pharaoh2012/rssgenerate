
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ClownLMe/p/18856562" title="发布于 2025-05-01 14:54">
    <span role="heading" aria-level="2">勒索病毒分析-2024wdb-re2</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="检查相关信息"><strong>检查相关信息</strong></h3>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144117843-546376229.png" alt="" loading="lazy"><br>
可以看到病毒存在VMProtect虚拟壳</p>
<h3 id="简单脱壳"><strong>简单脱壳</strong></h3>
<p>首先我在x64debug中运行一次，发现没有中断退出，证明大概率没有反调试，但是有crc检测，所以尽量不下int3断点（脱壳时）。</p>
<h3 id="一找oep"><strong>一：找OEP</strong></h3>
<p><strong>法1：直接在.text段下内存执行断点</strong><br>
别问，问就是这个我调试了很多次。<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144146775-1201163361.png" alt="" loading="lazy"><br>
然后直接运行到断点处，到oep<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144206636-436202337.png" alt="" loading="lazy"><br>
<strong>法2：在ida中猜出oep</strong><br>
在上面我们看到，这个程序是用vs写的，vs默认开了堆栈安全检查，我们可以利用这点找oep,通过交叉引用，我们可以找到入口OEP，我看到的大多数wp都这样，但是一笔带过。（让我一脸懵逼,写了跟没写一样）<br>
<strong>具体过程</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144227517-200118817.png" alt="" loading="lazy"><br>
安全检查函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144238504-1996832080.png" alt="" loading="lazy"><br>
SEH函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144312772-1371811381.png" alt="" loading="lazy"><br>
添加seh函数的函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144328605-383766561.png" alt="" loading="lazy"><br>
调用添加seh函数的函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144339207-1841294097.png" alt="" loading="lazy"><br>
到达OEP</p>
<p><strong>所以你又明白了vs中安全检查的调用过程和原理</strong></p>
<pre><code>sub_4020a9(__security_init_cookie)中用___security_cookie初始化相关值(如果溢出会改变相关值)，然后通过跳到__tmainCRTStartup函数，正常执行程序，如果堆栈溢出，就抛出seh异常，这就是为什么数组等越界vs会提示异常
</code></pre>
<p>咳咳，跑题了。这样你就找到OEP了，动态运行到这就脱壳了。</p>
<p><strong>法3：堆栈平衡</strong><br>
刚进入时可以看到pushad，先F8走到下面。<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144353127-818145910.png" alt="" loading="lazy"><br>
在栈顶下一个硬件访问断点<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144402650-964199497.png" alt="" loading="lazy"><br>
然后不断F9运行,然后会看到提示<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144417507-160852606.png" alt="" loading="lazy"><br>
之后再F9运行6次，在栈中发现有一个神奇的地址（为什么是6次，因为我调试时运行7次后从vmp0到text段过了）<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144430714-1890293243.png" alt="" loading="lazy"><br>
其中跟随00B81D32后神奇的事情发生了，直接到oep（其实壳运行完后本来就要跳oep的，这个后面也要跳）<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144444044-1471317448.png" alt="" loading="lazy"></p>
<p>最后，我看网上说的在VirtualProtect下断点，我尝试过只断了两次（修改环境，回复环境），这两次的修改对象是rdata区段的，应该是动态解密，但是后面不知道怎么搞。</p>
<p><strong><mark>有人会的在评论区教教我</mark></strong></p>
<hr>
<h3 id="二修复iat"><strong>二：修复iat</strong></h3>
<p>如果想分析的时候能够显示系统api，逆向分析更爽。</p>
<h5 id="如果简单修复不考虑运行"><strong>如果简单修复不考虑运行</strong></h5>
<p><strong><mark>由于动态加载地址，这个是后面截图的，所以地址有点出入</mark></strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144531620-1689361490.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144541250-1153601412.png" alt="" loading="lazy"><br>
这样修复后能够让ida的api显示出来，下面分析足够了，但是不能运行。因为刚刚删的两个api地址是<strong>有效</strong>的</p>
<h5 id="手动寻找api"><strong>手动寻找api</strong></h5>
<p>刚刚两个api是被壳虚拟化了，想要还原就要知道他的功能，你也不想硬刚虚拟化吧。<br>
这张图是下面的，有两个函数（B83048，B83048+1）被虚拟化了，我们可以通过上下文推出api是什么。<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144554867-1992835325.png" alt="" loading="lazy"></p>
<h5 id="推理过程"><strong>推理过程</strong></h5>
<p>上面图可以看到，这两个函数的返回值被SizeofResource和LockResource调用，并且传入参数也确定了，接下来找文档。<br>
<strong>SizeofResource：</strong> <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource</a><br>
<strong>LockResource：</strong> <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource</a><br>
根据文档可以推出：<br>
B83048其实是<code>FindResourceA</code><br>
B83048+1其实是 <code>LoadResource</code><br>
<strong>动态调试</strong><br>
我们发现壳程序动态还原回iat表<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144609176-349337805.png" alt="" loading="lazy"><br>
继续运行发现，这两个地址发生了变化<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144620372-363994191.png" alt="" loading="lazy"><br>
这两个hook后的地址要后面<strong>动态填进去</strong>或者<strong>将程序的动态基址关闭<mark>pass</mark></strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144629692-1179595803.png" alt="" loading="lazy"></p>
<h5 id="重新修复"><strong>重新修复</strong></h5>
<p>将这两个地址替换后重新修复，经过比对发现第一个函数传入的参数对不上<br>
<strong><mark>很遗憾，运行不了，想让他运行，我大体是病了，有人会的分享在评论区</mark></strong></p>
<p><strong><mark>这就是典型的无效VMProtect保护，这两个函数对分析没有影响</mark></strong></p>
<hr>
<h3 id="三静态分析"><strong>三：静态分析</strong></h3>
<p>IDA打开后我们看到有调用了2个主要函数<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144718987-1769787694.png" alt="" loading="lazy"><br>
我们逐个分析</p>
<hr>
<h5 id="main函数中的sub_b81620"><strong>main函数中的sub_B81620</strong></h5>
<p><strong>分析过程</strong><br>
点进去可以看到一堆动态解密的字符串，简单分析可以知道，这是动态获取WindowsAPI函数到存放到buffer中<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144735020-2060648912.png" alt="" loading="lazy"><br>
接下来是获取<code>C:\WINDOWS\SysWOW64\</code>目录并拼接成<code>C:\WINDOWS\SysWOW64\svchost.exe</code><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144748134-1091562787.png" alt="" loading="lazy"><br>
之后是简单的进程伪装+远程线程注入执行代码<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144758414-720603598.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144809896-1377133407.png" alt="" loading="lazy"><br>
<strong>主要功能</strong></p>
<pre><code>sub_B81620先xor解密字符串，将动态申请api存方到buf中，挂起svchost进程远程执行sub_B814e0中的代码
</code></pre>
<h5 id="那么远程执行的代码有什么呢-分析sub_b814e0函数"><strong>那么远程执行的代码有什么呢-&gt;分析sub_B814e0函数</strong></h5>
<p><strong>分析思路</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144824784-1957235675.png" alt="" loading="lazy"><br>
<strong>主要功能</strong></p>
<pre><code>对文件中的字符串异或加密后写回文件中
</code></pre>
<hr>
<h5 id="main函数中的startaddr函数"><strong>main函数中的startaddr函数</strong></h5>
<p><strong>分析思路</strong><br>
其中有两个函数（B83048，B83048+1）被虚拟化了，下面是我猜的功能但不影响结果<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144839598-1840588869.png" alt="" loading="lazy"><br>
<strong>我们需要知道lpbuffer是什么东西，还有sub_B81100干了什么</strong></p>
<h5 id="先分析lpbuffer"><strong>先分析lpbuffer</strong></h5>
<p>我们通过x64debug动态分析<br>
在lockresource中下断点方便获取返回的lpbuffer地址（eax）<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144855815-1219728078.png" alt="" loading="lazy"><br>
转到返回后的lpbuffer地址（eax）中，运行前记录下刚刚的大小（esi中）是B800，然后运行到解密完，可以看到PE文件的标志，<strong>说明资源解密后是一个新的pe文件</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144908786-193948700.png" alt="" loading="lazy"><br>
将内存中的pe文件dump出来，保存到为<code>a.exe</code>文件<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144920118-1765986880.png" alt="" loading="lazy"><br>
<strong>接下来先分析刚刚没看完的sub_B81100函数</strong><br>
<strong><mark>这个函数主要是进程镂空的技术思路，可以学习下</mark></strong><br>
<strong>分析思路</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144932438-188000199.png" alt="" loading="lazy"><br>
<strong>这里有个分支它会先检查CPU标志考虑是否重定位</strong><br>
（为什么判断cpu架构决定重定位，我也不知道，我觉得直接修复也行）<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144940971-81221591.png" alt="" loading="lazy"><br>
下面是遍历重定位表重定位<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145007786-768637990.png" alt="" loading="lazy"><br>
修改跳转地址<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145019065-1196063220.png" alt="" loading="lazy"></p>
<h5 id="总结思路"><strong>总结思路</strong></h5>
<pre><code>这里是一个免杀的进程镂空，它先挂起svchost进程，再对svchost进程中的代码进行替换，达到隐藏进程的目的。
</code></pre>
<hr>
<h5 id="分析dump下来的aexe"><strong>分析dump下来的a.exe</strong></h5>
<p><strong>PE信息</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145032445-1366283023.png" alt="" loading="lazy"><br>
<strong>ida分析</strong><br>
main函数只有一个重要函数，<br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145044360-166239907.png" alt="" loading="lazy"><br>
<strong>分析sub_401000</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145054334-2112922016.png" alt="" loading="lazy"><br>
<strong>分析sub_401230</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145109680-901209287.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145118976-1661966943.png" alt="" loading="lazy"><br>
<strong><mark>一般勒索软件不会留着源文件</mark></strong><br>
<strong>进入加密函数sub_401360分析</strong><br>
<img src="https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501145129822-1293265271.png" alt="" loading="lazy"><br>
<strong><mark>用AES加密能够很快的加密，但是我感觉这个有跟没有一样，典型的无效加密</mark></strong></p>
<h3 id="整理程序运行流程"><strong>整理程序运行流程</strong></h3>
<p>程序运行-&gt;远程线程注入代码-&gt;对flag.txt进行xor加密-&gt;创建<strong>进程镂空(免杀)</strong>-&gt;运行病毒可执行文件-&gt;对flag.txt进行AES加密</p>
<h3 id="解密"><strong>解密</strong></h3>
<pre><code class="language-python">import Cryptodome.Cipher.AES as AES
key = [0x3B,0x7E,0x15![](https://img2024.cnblogs.com/blog/2450496/202505/2450496-20250501144002299-1902041684.png)
,0x16,0x38,0xAE,0xD2,0xA6,0xBB,0xF7,0x15,0x88,0x19,0xCF,0x4F,0x3C]
txt = open("./flag.txt.cry", "rb").read()
flag = AES.new(bytes(key), AES.MODE_ECB).decrypt(txt)
print(''.join(chr(i ^ 0x9) for i in flag))
</code></pre>
<h3 id="总结"><strong>总结</strong></h3>
<p>加密过程很简单，这道题在于理解进程镂空，动态加载shellcode, vmprotect脱壳等</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.060441479421296296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-01 14:54">2025-05-01 14:54</span>&nbsp;
<a href="https://www.cnblogs.com/ClownLMe">ClownLMe</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18856562);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18856562', targetLink: 'https://www.cnblogs.com/ClownLMe/p/18856562', title: '勒索病毒分析-2024wdb-re2' })">举报</a>
</div>
        