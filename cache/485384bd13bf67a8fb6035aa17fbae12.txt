
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18894045" title="发布于 2025-05-25 12:09">
    <span role="heading" aria-level="2">杂七杂八系列----浅谈.NET微服务架构的演变</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="服务架构的演变">服务架构的演变</h1>
<blockquote>
<p>单体架构=&gt;分布式架构=&gt;SOA架构=&gt;微服务架构=&gt;Service Mesh=&gt;Cloud Native</p>
</blockquote>
<h2 id="单体架构垂直架构">单体架构/垂直架构</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525105841130-669816846.png" alt="image" loading="lazy"></p>
<h2 id="分布式架构">分布式架构</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525105834679-1121298161.png" alt="image" loading="lazy"></p>
<h2 id="soa架构">SOA架构</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525110505385-766738942.png" alt="image" loading="lazy"></p>
<h2 id="微服务架构">微服务架构</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525110731646-171717451.png" alt="image" loading="lazy"></p>
<h1 id="微服务架构的核心">微服务架构的核心</h1>
<blockquote>
<p>需要注意一点，微服务架构是分布式架构的一种落地，它们之间是接口与实现类的关系。</p>
</blockquote>
<h2 id="服务发现">服务发现</h2>
<blockquote>
<p>为什么需要服务发现？</p>
</blockquote>
<ol>
<li>服务实例的动态变化<br>
在水平架构中，我们的服务集群往往是通过Nginx/IIS的<code>静态配置</code>来实现节点的增/减。加上节点少，因此，每次修改节点配置都是人工修改。<br>
而微服务架构天然的动态性与不确定性，服务实例通常需要动态扩容/缩容，故障重启，滚动升级等特点，因此服务示例的<code>网络地址是随时变化的</code>，加上微服务化之后，<code>服务实例呈指数级增加</code>，再由人工干预就不明智了。</li>
<li>分布式环境的网络复杂性<br>
服务实例可能步骤在不同的物理机，虚拟机，容器中，将它们整合非常麻烦，需要一个能够<code>屏蔽底层细节，提供统一入口</code>的组件，让调用方无需关心目标服务具体位置</li>
<li>抽象网络地址<br>
水平架构中，我们常常依赖IP+端口的形式来确定服务实例，在微服务架构中，使用Service-Name来提供一个<code>逻辑名称</code></li>
<li>去除不可用实例<br>
通过<code>心跳访问</code>实例提供的Healthcheck，当某个实例故障时，自动去除，避免访问到不可用节点。</li>
</ol>
<blockquote>
<p>简单来说，服务发现解决的是微服务实例之间的动态通信问题，主要用于内部服务间的调用。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250524132436118-1124537890.png" alt="image" loading="lazy"></p>
<h2 id="api网关">API网关</h2>
<blockquote>
<p>API 网关是什么，它具备什么功能?</p>
</blockquote>
<ol>
<li>统一路由<br>
根据请求路径将请求转发到后端实例，比如https://gateway.XXXXX.com/你的业务实例前缀/user/{id};</li>
<li>协议转换<br>
将前端的HTTP请求转换为服务内部的rbc协议</li>
<li>身份认证与鉴权<br>
集中处理JWT，OAuth2等鉴权操作，避免每个微服务都重复校验</li>
<li>流量管理<br>
实现服务的负载均衡，限流等操作，避免微服务收到冲击。</li>
<li>日志与指标分析<br>
作为统一入口，可以统一记录请求量，响应实践，成功率等指标，方便分析。</li>
</ol>
<blockquote>
<p>感觉服务发现与API网关重合了？</p>
</blockquote>
<p>服务发现解决的是微服务实例之间的动态通信问题，主要用于<code>内部服务间的调用</code>。<br>
API 网关是外部客户端访问微服务的统一入口，主要用于<code>客户端与微服务之间的通信</code>。</p>
<p>举个例子：</p>
<ol>
<li>客户端认证需求<br>
若没有API网关，客户端直接调用微服务，每个微服务都要重复检验用户的JWT。</li>
<li>多协议支持<br>
微服务内部使用gRPC协议，而客户端是HTTP协议，这中间无法转换。</li>
<li>流量保护<br>
服务发现仅能实现简单的负载均衡（如轮询），但 API 网关可通过限流策略（如令牌桶、漏桶算法）防止突发流量压垮后端服务，这是服务发现无法实现的</li>
<li>数据聚合优化<br>
比如客户端需要同时获取 user与order信息，若通过服务发现，需要分别调用user service与order service，产生多次网络请求，而API网关将多个响应结果合并为一个，减少客户端的请求量。</li>
</ol>
<blockquote>
<p>有人可能会问了，我让服务发现与API网关合并就好了，这样不就大而全了？<br>
合二为一的组件确实存在，如 Kong、Traefik、Istio Gateway 等，它们通过集成服务发现机制到网关中，简化了微服务架构的复杂度。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525103053814-1346252574.png" alt="image" loading="lazy"></p>
<h2 id="服务发现与api网关如何协同工作">服务发现与API网关如何协同工作？</h2>
<ol>
<li>API网关接收客户端请求后，根据route规则确定service.<br>
比如https://gateway.XXXXX.com/user-service/user/{id}<br>
根据user-service前缀，便可确定需要调用哪个微服务。</li>
<li>通过服务发现接口，查询获得可用服务列表<br>
调用注册中心 API。</li>
<li>选择一个实例转发<br>
基于负载均衡策略</li>
<li>微服务之间内部流转<br>
微服务 A 调用微服务 B 时，直接通过服务发现获取 B 的实例地址，无需经过 API 网关。微服务之间走轻量级通信方式，比如gRPC，避免使用HTTP协议提高性能。</li>
</ol>
<p><strong>网关+服务发现+服务实例=微服务架构的核心</strong>，这两个核心组件便已经组成了微服务基本实现，剩下的组件都是对微服务架构的<code>锦上添花</code>，但<code>不是雪中送炭</code>。</p>
<h2 id="为什么还有服务间负载均衡">为什么还有服务间负载均衡？</h2>
<p>API网关只负责外部HTTP请求，微服务内部之间通信不走API网关，因此需要一个服务间负载均衡的组件来承担内部流量的转发</p>
<h1 id="微服务架构的拓展">微服务架构的拓展</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525104132578-2097043458.png" alt="image" loading="lazy"></p>
<h2 id="分布式配置">分布式配置</h2>
<blockquote>
<p>为什么需要分布式配置中心?</p>
</blockquote>
<p>在单体架构或水平架构，抑或是简单的分布式架构中，配置文件通常以文件形式(appsettings.json)打包在application中，锁着系统规模的扩大，之前的管理方式就非常折磨人了。</p>
<blockquote>
<p>举个例子，你有10个微服务，每个微服务部署3个实例，此时你要修改数据库连接，那么你的工作就是要修改30次配置文件，并重启服务器，然后还要小心中途不出错，还要考虑敏感信息的加密。</p>
</blockquote>
<p>分布式配置中心是<strong>微服务中用于集中管理和动态推送配置的拓展组件</strong>。它通过统一的平台解决传统配置管理的痛点（如配置分散、修改复杂、环境隔离困难），是保障系统高可用、可维护的关键基础设施。</p>
<table>
<thead>
<tr>
<th><strong>传统配置管理的痛点</strong></th>
<th><strong>分布式配置中心的解决方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>配置分散在各服务实例中，修改需逐个操作（如修改Nginx限流阈值需登录100台服务器）</td>
<td>集中存储配置，通过统一界面或API修改，自动同步到所有实例</td>
</tr>
<tr>
<td>配置变更需重启服务（如Spring Boot修改<code>server.port</code>需重启）</td>
<td>支持<strong>动态推送</strong>，配置修改后服务无需重启即可生效</td>
</tr>
<tr>
<td>多环境（开发/测试/生产）配置重复，易因复制错误导致线上故障</td>
<td>支持<strong>环境隔离</strong>（如按<code>dev/test/prod</code>划分配置）</td>
</tr>
<tr>
<td>配置版本混乱（如回滚时找不到历史版本）</td>
<td>提供<strong>版本管理</strong>和<strong>回滚</strong>功能，记录每次修改的时间、操作人</td>
</tr>
<tr>
<td>敏感配置（如数据库密码）明文存储，存在安全风险</td>
<td>支持<strong>加密存储</strong>和<strong>权限控制</strong>（如仅管理员可修改数据库配置）</td>
</tr>
</tbody>
</table>
<h2 id="分布式日志">分布式日志</h2>
<p>分布式日志处理是指在分布式系统，对于分散在不同节点的日志进行集中收集，存储，分析和监控。<code>其核心目标是解决分布式环境下的日志的分散性，异构性，高并发问题</code>，帮助团队快速定位故障，挖掘数据。</p>
<blockquote>
<p>为什么需要分布式日志中心?</p>
</blockquote>
<ol>
<li>全链路追踪，快速定位问题<br>
通过唯一请求 ID（如 Trace ID）将跨服务的日志串联，形成完整调用链路，秒级定位故障节点。。</li>
<li>统一日志管理，提升可观测性<br>
将分散日志汇聚到统一平台（如 Elasticsearch），支持多维度查询（按时间、服务名、关键字、日志级别），通过标准化格式将日志转换为统一JSON格式。</li>
<li>数据驱动的决策与优化<br>
统计用户行为日志（如页面访问、按钮点击），优化产品功能设计。<br>
分析日志中的耗时数据，识别服务瓶颈（如数据库慢查询、接口响应超时）<br>
通过日志量趋势分析，预测服务器存储和计算资源需求。</li>
</ol>
<h3 id="结构化日志的重要性">结构化日志的重要性</h3>
<p>非结构化日志如同 “原始矿石”，而结构化日志是 “精雕细琢的宝石”—— 前者仅能提供原始信息，后者则通过标准化和字段化，让日志成为驱动系统优化、业务增长的核心资产。<br>
无论是故障排查、性能优化，还是合规审计，结构化日志都是实现 “数据驱动运维” 的必经之路。</p>
<blockquote>
<p>举个例子，你想统计出某个特定时间段用户登陆失败的次数。通过结构化日志，你可以轻松的以SQL的形式得出统计结果。<br>
再举个例子，通过提取response_time，设置 “当 95% 请求耗时&gt; 500ms 时触发告警</p>
</blockquote>
<pre><code>{
  "timestamp": "2025-05-24T14:30:00Z",
  "service_name": "user-service",
  "response_time":182ms,
  "level": "ERROR",
  "message": "用户登录失败",
  "metadata": {
    "user_id": "U12345",
    "error_code": "AUTH_001",
    "trace_id": "abc-123"
  }
}
</code></pre>
<blockquote>
<p>简单来说，结构化日志，使得日志变成了数据库中的字段，从而发生质变。从之前的仅用于故障排查，上升到挖掘商业价值，用户行为分析的高度，让日志拥有了无限种可能。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250524215203560-272590583.png" alt="image" loading="lazy"></p>
</blockquote>
<h2 id="分布式链路跟踪">分布式链路跟踪</h2>
<p>链路跟踪主要用于<code>追踪和记录跨多个服务/组件</code>的链路请求，并分析经过的每个节点的处理时间，状态和依赖关系。其核心目标是解决分布式系统中又臭又长的调用链路，并<code>结合分布式日志帮助开发者快速定位</code>性能瓶颈与故障点</p>
<blockquote>
<p>为什么需要链路跟踪？</p>
</blockquote>
<ol>
<li>
<p>线上故障快速排查<br>
一个请求可能设计到数十个服务，一个服务一个服务的查看，非常废人，效率也非常低下。<br>
比如用户支付失败，但无法确定是支付服务故障、库存服务超时，还是网络问题。链路跟踪通过 Trace ID 串联所有相关 Span，快速定位出错的服务或节点。</p>
</li>
<li>
<p>性能优化<br>
识别慢调用（如超时的 RPC 接口、低效的数据库查询），优化服务间调用逻辑或资源配置。</p>
</li>
<li>
<p>指导集群容量规划<br>
通过分析链路流量和资源消耗，评估各服务压力，指导集群扩/缩容</p>
</li>
<li>
<p>指导服务治理<br>
通过可视化的服务依赖关系，指导辅助熔断、限流策略的制定（如对高延迟服务设置降级规则）。</p>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525101929576-1100629894.png" alt="image" loading="lazy"></p>
<p><strong>根据我的血泪史，链路跟踪最大的好处就是跟其它项目组扯皮的时候有理有据，免得其它项目组不认账！</strong></p>
<h2 id="分布式事务">分布式事务</h2>
<p>分布式事务是指在分布式系统种，涉及多个服务节点或数据库节点的操作，需要保证其<code>操作原子性</code>，也就是要么全部成功，要么全部回滚。</p>
<blockquote>
<p>为什么需要链路跟踪？</p>
</blockquote>
<ol>
<li>
<p>微服务架构下的业务拆分<br>
例如电商系统中，用户下单时需要同时完成：<br>
*. 订单服务创建订单（写入订单数据库）<br>
*. 库存服务扣减库存（写入库存数据库）；<br>
*. 支付服务冻结预授权（调用第三方支付接口）。<br>
若其中某一步骤失败（如库存不足或支付超时），需回滚所有已完成的操作（如撤销订单、恢复库存），否则会导致数据不一致（例如用户下单成功但库存未扣减，或库存扣减但支付失败）。</p>
</li>
<li>
<p>分布式数据库的事务需求<br>
使用分库分表，一个事务可能涉及多个数据库节点的数据操作。<br>
传统数据库的本地事务无法跨节点保证一致性，需分布式事务机制（如 2PC、3PC）协调各节点的提交或回滚。<br>
根据业务不同，金融、电商等对数据敏感的领域必须保证强一致性。</p>
</li>
</ol>
<p>受限于CAP定理，一致性，可用性，分区容错性无法同事满足，因此需要根据业务场景权衡。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525095935871-90852901.png" alt="image" loading="lazy"></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>核心思想</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>两阶段提交（2PC）</strong></td>
<td>通过事务管理器协调各参与者的“准备”和“提交”阶段，保证强一致性但性能较低。</td>
<td>金融交易、实时数据同步</td>
</tr>
<tr>
<td><strong>三阶段提交（3PC）</strong></td>
<td>优化 2PC 的超时问题，引入“预提交”阶段，降低阻塞但实现复杂。</td>
<td>高可用分布式系统</td>
</tr>
<tr>
<td><strong>事务消息（最终一致性）</strong></td>
<td>通过消息中间件异步协调，允许短暂不一致，最终达到一致。</td>
<td>异步业务（如订单通知、物流更新）</td>
</tr>
<tr>
<td><strong>TCC（Try-Confirm-Cancel）</strong></td>
<td>自定义“尝试-确认-取消”逻辑，灵活处理部分成功的操作，适合复杂业务。</td>
<td>微服务架构中的复杂流程（如支付）</td>
</tr>
<tr>
<td><strong>最大努力通知</strong></td>
<td>通过重试机制和回调接口确保最终一致性，允许人工干预。</td>
<td>非核心业务（如短信通知）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果将微服务架构比作数学高考，那么分布式事务就是最后那道压轴题。这道题做好了，清华就离你不远了。<br>
别理解错了，我的意思不是让你玩好分布式事务，而是尽量避免使用分布式事务，它的收益其实很低，性能也不高。对于互联网业务，我们应该在设计阶段就尽量避免，能补偿就补偿，尽量不要高频次使用分布式事务。<br>
对于平庸的大多数而言，最后一道压轴题直接放弃会比较明智。</p>
</blockquote>
<p><code>微服务不是套公式，你的架构可以是Application微服务化，但底层数据库是同一个。你要相信SQL Server的能力，绝大多数公司业务达不到能让SQL Server出现瓶颈的时候</code></p>
<h1 id="微服务架构的演化简单介绍版">微服务架构的演化，简单介绍版</h1>
<h2 id="service-mesh">Service Mesh</h2>
<p>随着微服务规模扩大，传统 SDK 模式的弊端（如代码侵入、升级成本高）凸显，服务网格作为基础设施层应运而生。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525111558504-1330714590.png" alt="image" loading="lazy"></p>
<blockquote>
<p>服务网格解决了什么问题？</p>
</blockquote>
<p>在传统微服务架构中，服务间通信需要<code>处理大量复杂逻辑</code>，例如：<br>
服务发现：如何找到目标服务的地址？<br>
负载均衡：如何将请求均匀分配到多个实例？<br>
流量控制：如何处理超时、重试、熔断？<br>
安全通信：如何实现服务间的认证、授权和加密？<br>
可观测性：如何收集调用链、指标、日志以监控系统？</p>
<p>这些逻辑通常通过 SDK集成到服务代码中，<code>代码侵入性强，维护成本高</code>。</p>
<p>而Service Mesh将这些底层通信逻辑从业务代码中剥离，下沉到独立的基础设施层，实现透明化、标准化、自动化的服务间通信。</p>
<blockquote>
<p>简单来说，就是做了一层抽象，解决了微服务架构中最复杂的 “连接” 问题。服务网格就像微服务之间的 “智能路由器” 和 “通信管家”，自动处理所有网络相关的脏活累活，让服务只需关心 “做什么”，而不是 “如何连接”。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>传统微服务（如Spring Cloud）</strong></th>
<th><strong>服务网格</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通信实现</strong></td>
<td>通过SDK集成到服务代码中（侵入式）</td>
<td>独立Sidecar代理（无侵入）</td>
</tr>
<tr>
<td><strong>语言绑定</strong></td>
<td>强绑定（如Java用Spring Cloud）</td>
<td>语言无关（服务可由任意语言开发）</td>
</tr>
<tr>
<td><strong>升级成本</strong></td>
<td>需修改服务代码并重新部署</td>
<td>只需升级Sidecar或控制平面</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>服务代码包含底层逻辑，复杂度高</td>
<td>底层逻辑下沉到网格，服务逻辑更纯粹</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>低（无额外进程）</td>
<td>高（每个服务需运行Sidecar，Sidecar 的资源消耗通常为 “10%-20% 的额外 CPU / 内存）</td>
</tr>
</tbody>
</table>
<h2 id="cloud-native">Cloud Native</h2>
<p>Cloud Native（云原生） 是一种利用云计算特性设计、构建和运行应用的技术理念与实践方法，其核心目标是通过云的弹性、分布式和自动化能力，实现应用的高可用、可扩展、快速迭代。云原生并非单一技术，而是一套包含方法论、架构模式和工具链的完整体系<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525114205692-1567043550.png" alt="image" loading="lazy"></p>
<blockquote>
<p>云原生解决了什么问题？</p>
</blockquote>
<p>微服务解决了 “拆” 的问题，云原生解决了 “在云中管好、用好这些拆分后的服务” 的问题。</p>
<p>简单来说说，当服务上云后，云原生通过容器化、编排、服务网格等技术，解决了微服务在云环境中的部署、运维、治理难题，让微服务真正 “跑好” 在云中。<br>
极大的<code>简化了微服务架构的工作量</code>，协助开发人员更加专注于业务，而不是陷在微服务架构的技术细节中爬不出来。</p>
<blockquote>
<p>由于.NET 在互联网的生态不足，相对JAVA的Spring Cloud这种商店式脚手架，采用.NET技术栈的公司往往需要投入更大的资源才能完成微服务化建设，但上云后，由云厂商提供的简单快捷的SDK与UI ，极大简化了微服务架构的复杂性，甚至可以不需要架构师。</p>
</blockquote>
<h3 id="service-mesh与cloud-native的关系">Service Mesh与Cloud Native的关系？</h3>
<p>Cloud Native的核心是微服务架构，而微服务的高效运行依赖可靠的服务间通信。传统微服务通过 SDK实现通信逻辑，但存在代码侵入、语言绑定等问题。Service Mesh 通过 Sidecar 代理拦截流量，将通信逻辑下沉到基础设施层，完美契合 Cloud Native 对 “解耦” 和 “无侵入” 的要求。</p>
<blockquote>
<p>说人话就是在Service Mesh的基础上又做了一层抽象。</p>
</blockquote>
<h2 id="serverless">Serverless</h2>
<p>Serverless（无服务器架构） 是一种云原生时代的计算模型和开发模式，其核心是将服务器的运维和资源管理完全交给云服务商，开发者只需专注于编写业务代码（如函数、事件处理逻辑），无需关心服务器的采购、部署、扩容或故障修复。它通过 “按需付费” 和 “事件驱动” 的设计，彻底改变了传统应用的开发与运维方式。</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>传统架构（VM/容器）</strong></th>
<th><strong>Serverless架构</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>资源管理</strong></td>
<td>需手动申请/释放服务器，管理扩缩容</td>
<td>云服务商自动管理，开发者无需干预</td>
</tr>
<tr>
<td><strong>付费模式</strong></td>
<td>按服务器时长付费（如包年包月）</td>
<td>按实际使用的计算资源（执行时间、内存）付费</td>
</tr>
<tr>
<td><strong>开发重心</strong></td>
<td>需编写服务器配置、运维脚本、监控代码</td>
<td>仅需编写业务逻辑（函数或调用BaaS API）</td>
</tr>
<tr>
<td><strong>扩缩容能力</strong></td>
<td>需手动或脚本触发，响应延迟高（分钟级）</td>
<td>自动扩缩容，支持毫秒级启动（冷启动可能延迟）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>长生命周期、高并发、状态敏感的应用</td>
<td>短任务、事件驱动、无状态或轻状态的应用</td>
</tr>
</tbody>
</table>
<h1 id="参考资料">参考资料</h1>
<blockquote>
<p><a href="https://blog.51cto.com/universsky/5850036" target="_blank" rel="noopener nofollow">https://blog.51cto.com/universsky/5850036</a><br>
<a href="https://cloud.tencent.com/developer/article/1549492" target="_blank" rel="noopener nofollow">https://cloud.tencent.com/developer/article/1549492</a><br>
<a href="https://blog.csdn.net/weixin_43114209/article/details/144203876" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_43114209/article/details/144203876</a></p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005296484629629629" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-25 12:15">2025-05-25 12:09</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18894045);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18894045', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18894045', title: '杂七杂八系列----浅谈.NET微服务架构的演变' })">举报</a>
</div>
        