
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ludangxin/p/18682268" title="发布于 2025-01-20 20:34">
    <span role="heading" aria-level="2">1. Calcite元数据创建</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<p>Calcite 是一款来自 Apache 的开源动态数据管理框架，核心功能是提供 SQL 查询解析、优化及执行等基础能力，以灵活支持多种数据源，广泛应用于各类数据处理系统。以下从其功能特性、应用场景、优势三方面简单概述：</p>
<ul>
<li>功能特性
<ul>
<li><strong>SQL 解析</strong>：支持多种 SQL 方言，如标准 SQL 以及不同数据库特定的扩展语法，能将输入的 SQL 语句解析为抽象语法树（AST），便于后续处理。</li>
<li><strong>语义分析</strong>：对解析后的 SQL 进行语义检查，比如验证表名、列名是否存在，数据类型是否匹配等，确保 SQL 的语义正确。</li>
<li><strong>查询优化</strong>：运用基于规则（RBO）和基于代价（CBO）的优化策略。RBO 通过预设规则，如谓词下推等，重写查询；CBO 则基于统计信息，估算不同执行计划的代价，选择最优方案。</li>
<li><strong>执行计划生成</strong>：根据优化后的结果，生成可执行的物理执行计划，定义操作的具体执行顺序和方式。</li>
<li><strong>数据源适配</strong>：可连接多种数据源，如关系型数据库（MySQL、Oracle 等）、文件系统（CSV、JSON 文件）、NoSQL 数据库等，而且还支持自定义数据源适配器, 并为不同数据源生成相应的数据访问策略。</li>
<li><strong>跨数据源查询</strong>: 能够连接不同类型的数据源，通过适配器将不同数据源的操作进行统一抽象。在进行跨数据源连表查询时，它会将查询分解为各个数据源可以处理的子查询，然后将各个数据源的结果进行合并和进一步处理</li>
</ul>
</li>
</ul>
<h2 id="2-元数据准备">2. 元数据准备</h2>
<p><strong>准备两个数据库 <code>mysql</code> 和 <code>postgres</code></strong></p>
<p>库信息如下: <code>mysql</code>中有张表: user, <code>postgres</code>有张表role</p>
<p><img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250120181126266-1027121274.png" alt="" loading="lazy"></p>
<p><strong>表信息如下:</strong></p>
<pre><code class="language-sql">CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `username` varchar(255) DEFAULT NULL COMMENT '用户名称',
  `age` int(11) DEFAULT NULL COMMENT '性别',
  `sex` varchar(255) DEFAULT NULL COMMENT '性别',
  `role_key` int(11) DEFAULT NULL COMMENT '角色',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COMMENT='用户信息表';
</code></pre>
<pre><code class="language-sql">CREATE TABLE "public"."role" (
  "name" varchar(255) COLLATE "pg_catalog"."default",
  "role_key" int4
);
</code></pre>
<h2 id="3-maven依赖">3. maven依赖</h2>
<p>maven依赖如下:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;
  &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;
  &lt;version&gt;1.37.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;version&gt;8.0.29&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
  &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
  &lt;version&gt;42.2.23&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="4-元数据定义">4. 元数据定义</h2>
<p>calcite支持两种多种定义元数据方式 常用的是通过<code>json</code>方式，另一种是通过<code>SchemaFactory</code>的方式。</p>
<h3 id="41-json-model">4.1 Json Model</h3>
<p><strong>组织结构：</strong></p>
<pre><code class="language-bash">|- model # 数据模型
|	|- schema # 数据模式
|	|	|- tables # 表/视图
|	|	|- functions # 函数
|	|	|- type # 模式类型  custom: 自定义, map: 映射, jdbc: jdbc, inline: 嵌入式 (默认)
|	|	|- factory # 指定SchemaFactory的工厂类
|	|	|- operand # 指定额外参数
</code></pre>
<p><strong>示例内容：</strong></p>
<blockquote>
<p>创建两个数据源 mysql 和 postgres, 使用两种不同的声明方式</p>
</blockquote>
<pre><code class="language-json">{
  "version": "1.0",
  "defaultSchema": "my_mysql",
  "schemas": [
    {
      "type": "jdbc",
      "name": "my_mysql",
      "jdbcUser": "root",
      "jdbcPassword": "123456",
      "jdbcUrl": "jdbc:mysql://localhost:3306/test",
      "jdbcCatalog": "test",
      "jdbcSchema": null
    },
    {
      "name": "my_postgres",
      "type": "custom",
      "factory": "org.apache.calcite.adapter.jdbc.JdbcSchema$Factory",
      "operand": {
        "jdbcDriver": "org.postgresql.Driver",
        "jdbcUrl": "jdbc:postgresql://localhost:5432/test",
        "jdbcUser": "root",
        "jdbcPassword": "123456"
      }
    }
  ]
}
</code></pre>
<p>calcite model 实现类<code>org.apache.calcite.jdbc.Driver</code> --&gt; <code>org.apache.calcite.model.ModelHandler</code></p>
<p>calcite model doc：<a href="https://calcite.apache.org/docs/model.html" target="_blank" rel="noopener nofollow">https://calcite.apache.org/docs/model.html</a></p>
<p><strong>加载资源:</strong></p>
<blockquote>
<p>将json文件放到<code>resources</code>下, 然后创建connection的时候指定该文件即可</p>
</blockquote>
<pre><code class="language-java">Properties info = new Properties();
// 不区分sql大小写
info.setProperty("caseSensitive", "false");
// 设置引用标识符为反引号
info.setProperty(CalciteConnectionProperty.QUOTING.camelName(), Quoting.BACK_TICK.name());
// 指定model信息
info.setProperty("model", resourcePath("model/model.json"));
// 创建Calcite连接
Connection connection = DriverManager.getConnection("jdbc:calcite:", info);
CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
// 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
SchemaPlus rootSchema = calciteConnection.getRootSchema();
// 创建SQL语句执行查询
Statement statement = calciteConnection.createStatement();
</code></pre>
<h3 id="42-schemafactory">4.2 SchemaFactory</h3>
<p>schema UML图如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250120181141102-1299723113.svg" alt="" loading="lazy"></p>
<p><strong>先创建对应数据源的<code>datasource</code>对象</strong></p>
<pre><code class="language-java">private static DataSource getMysqlDataSource() {
  MysqlDataSource dataSource = new MysqlDataSource();
  dataSource.setUrl("jdbc:mysql://localhost:3306/test");
  dataSource.setUser("root");
  dataSource.setPassword("123456");

  return dataSource;
}

private static DataSource getPostgresDataSource() {
  final PGSimpleDataSource pgSimpleDataSource = new PGSimpleDataSource();
  pgSimpleDataSource.setUrl("jdbc:postgresql://localhost:5432/test");
  pgSimpleDataSource.setUser("root");
  pgSimpleDataSource.setPassword("123456");

  return pgSimpleDataSource;
}
</code></pre>
<p><strong>然后将<code>datasource</code>对象包装成<code>JdbcSchema</code>对象最后注册到<code>rootSchema</code>中</strong></p>
<pre><code class="language-java">Properties info = new Properties();
// 不区分sql大小写
info.setProperty("caseSensitive", "false");
// 设置引用标识符为双引号
info.setProperty(CalciteConnectionProperty.QUOTING.camelName(), Quoting.BACK_TICK.name());
// 创建Calcite连接
Connection connection = DriverManager.getConnection("jdbc:calcite:", info);
CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
// 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
SchemaPlus rootSchema = calciteConnection.getRootSchema();
// 设置默认的schema, 如果不设置需要加上对应数据源的名称
calciteConnection.setSchema("my_mysql");
final DataSource mysqlDataSource = getMysqlDataSource();
final JdbcSchema schemaWithMysql = JdbcSchema.create(rootSchema, "my_mysql", mysqlDataSource, "test", null);
final DataSource postgresDataSource = getPostgresDataSource();
final JdbcSchema schemaWithPostgres = JdbcSchema.create(rootSchema, "my_postgres", postgresDataSource, "test", "public");
rootSchema.add("my_mysql", schemaWithMysql);
rootSchema.add("my_postgres", schemaWithPostgres);
// 创建SQL语句执行查询
Statement statement = calciteConnection.createStatement();
</code></pre>
<blockquote>
<p><strong>rootSchema也可以使用创建</strong></p>
</blockquote>
<pre><code class="language-java">CalciteSchema calciteSchema = CalciteSchema.createRootSchema(true, true);
SchemaPlus rootSchema = calciteSchema.plus();
</code></pre>
<h2 id="5-测试查询">5. 测试查询</h2>
<h3 id="51-测试单个数据源的查询功能">5.1 测试单个数据源的查询功能</h3>
<pre><code class="language-java">@Test
@SneakyThrows
public void test_connection() {
  // 上述配置中都设置了默认的schema为my_mysql, 所以查询的时候可以不添加数据源key前缀
  final ResultSet resultSet = statement.executeQuery("SELECT * FROM `user`");
  final ResultSet resultSet = statement.executeQuery("SELECT * FROM my_mysql.`user`");
  printResultSet(resultSet);
}
</code></pre>
<p><strong>输出结果如下:</strong></p>
<pre><code class="language-bash">Number of columns: 5
{sex=1, role_key=1, id=1, age=23, username=张三}
{sex=2, role_key=2, id=2, age=18, username=李四}
{sex=2, role_key=1, id=3, age=26, username=张铁牛}
{sex=2, role_key=3, id=4, age=30, username=王麻子}
</code></pre>
<h3 id="52-测试不同数据源连表查询">5.2 测试不同数据源连表查询</h3>
<blockquote>
<p><strong>calcite支持将不同数据源的sql下推, 然后在内存中做对应的关联过滤等操作</strong></p>
</blockquote>
<pre><code class="language-java">@Test
@SneakyThrows
public void test_cross_db_query() {
    final ResultSet resultSet = statement.executeQuery("SELECT u.*,r.name FROM `user` u left join my_postgres.`role` r on u.role_key = r.role_key");
    printResultSet(resultSet);
}
</code></pre>
<p><strong>输出结果如下:</strong></p>
<pre><code class="language-bash">Number of columns: 6
{sex=1, role_key=1, name=管理员, id=1, age=23, username=张三}
{sex=2, role_key=1, name=管理员, id=3, age=26, username=张铁牛}
{sex=2, role_key=2, name=老师, id=2, age=18, username=李四}
{sex=2, role_key=3, name=学生, id=4, age=30, username=王麻子}
</code></pre>
<h2 id="6-完整测试代码">6. 完整测试代码</h2>
<h3 id="61-json-model">6.1 Json Model</h3>
<pre><code class="language-java">package com.ldx.calcite;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.avatica.util.Quoting;
import org.apache.calcite.config.CalciteConnectionProperty;
import org.apache.calcite.jdbc.CalciteConnection;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.util.Sources;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.testng.collections.Maps;

import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.Properties;

@Slf4j
public class CalciteModelTest {
    private static Statement statement;

    @BeforeAll
    @SneakyThrows
    public static void beforeAll() {
        Properties info = new Properties();
        // 不区分sql大小写
        info.setProperty("caseSensitive", "false");
        // 设置引用标识符为双引号
        info.setProperty(CalciteConnectionProperty.QUOTING.camelName(), Quoting.BACK_TICK.name());
        // 指定model信息
        info.setProperty("model", resourcePath("model/model.json"));
        // 创建Calcite连接
        Connection connection = DriverManager.getConnection("jdbc:calcite:", info);
        CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
        // 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
        SchemaPlus rootSchema = calciteConnection.getRootSchema();
        // 创建SQL语句执行查询
        statement = calciteConnection.createStatement();
    }

    @Test
    @SneakyThrows
    public void test_connection() {
        final ResultSet resultSet = statement.executeQuery("SELECT * FROM `user`");
        printResultSet(resultSet);
    }

    @Test
    @SneakyThrows
    public void test_cross_db_query() {
        final ResultSet resultSet = statement.executeQuery("SELECT u.*,r.name FROM `user` u left join my_postgres.`role` r on u.role_key = r.role_key");
        printResultSet(resultSet);
    }

    public static void printResultSet(ResultSet resultSet) throws SQLException {
        // 获取 ResultSet 元数据
        ResultSetMetaData metaData = resultSet.getMetaData();
        // 获取列数
        int columnCount = metaData.getColumnCount();
        log.info("Number of columns: {}",columnCount);

        // 遍历 ResultSet 并打印结果
        while (resultSet.next()) {
            final Map&lt;String, String&gt; item = Maps.newHashMap();
            // 遍历每一列并打印
            for (int i = 1; i &lt;= columnCount; i++) {
                String columnName = metaData.getColumnName(i);
                String columnValue = resultSet.getString(i);
                item.put(columnName, columnValue);
            }

            log.info(item.toString());
        }
    }

    private static String resourcePath(String path) {
        final URL url = CalciteCsvTest.class.getResource("/" + path);
        return Sources
                .of(url).file().getAbsolutePath();
    }
}
</code></pre>
<h3 id="62-schemafactory">6.2 SchemaFactory</h3>
<pre><code class="language-java">package com.ldx.calcite;

import com.mysql.cj.jdbc.MysqlDataSource;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.adapter.jdbc.JdbcSchema;
import org.apache.calcite.avatica.util.Quoting;
import org.apache.calcite.config.CalciteConnectionProperty;
import org.apache.calcite.jdbc.CalciteConnection;
import org.apache.calcite.jdbc.CalciteSchema;
import org.apache.calcite.schema.SchemaFactory;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.util.Sources;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.postgresql.ds.PGSimpleDataSource;
import org.postgresql.osgi.PGDataSourceFactory;
import org.testng.collections.Maps;

import javax.sql.DataSource;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.Properties;

@Slf4j
public class CalciteCreateMataDataTest {

    private static Statement statement;

    @BeforeAll
    @SneakyThrows
    public static void beforeAll() {
        Properties info = new Properties();
        // 不区分sql大小写
        info.setProperty("caseSensitive", "false");
        // 设置引用标识符为双引号
        info.setProperty(CalciteConnectionProperty.QUOTING.camelName(), Quoting.BACK_TICK.name());
        // 创建Calcite连接
        Connection connection = DriverManager.getConnection("jdbc:calcite:", info);
        CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
        // 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
        SchemaPlus rootSchema = calciteConnection.getRootSchema();
        // 设置默认的schema, 如果不设置需要加上对应数据源的名称
        calciteConnection.setSchema("my_mysql");
        final DataSource mysqlDataSource = getMysqlDataSource();
        final JdbcSchema schemaWithMysql = JdbcSchema.create(rootSchema, "my_mysql", mysqlDataSource, "test", null);
        final DataSource postgresDataSource = getPostgresDataSource();
        final JdbcSchema schemaWithPostgres = JdbcSchema.create(rootSchema, "my_postgres", postgresDataSource, "test", "public");
        rootSchema.add("my_mysql", schemaWithMysql);
        rootSchema.add("my_postgres", schemaWithPostgres);
        // 创建SQL语句执行查询
        statement = calciteConnection.createStatement();
    }

    private static DataSource getMysqlDataSource() {
        MysqlDataSource dataSource = new MysqlDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/test");
        dataSource.setUser("root");
        dataSource.setPassword("123456");

        return dataSource;
    }

    private static DataSource getPostgresDataSource() {
        final PGSimpleDataSource pgSimpleDataSource = new PGSimpleDataSource();
        pgSimpleDataSource.setUrl("jdbc:postgresql://localhost:5432/test");
        pgSimpleDataSource.setUser("root");
        pgSimpleDataSource.setPassword("123456");

        return pgSimpleDataSource;
    }

    @Test
    @SneakyThrows
    public void test_connection() {
        final ResultSet resultSet = statement.executeQuery("SELECT * FROM `user`");
        printResultSet(resultSet);
    }

    @Test
    @SneakyThrows
    public void test_cross_db_query() {
        final ResultSet resultSet = statement.executeQuery("SELECT u.*,r.name FROM `user` u left join my_postgres.`role` r on u.role_key = r.role_key");
        printResultSet(resultSet);
    }

    public static void printResultSet(ResultSet resultSet) throws SQLException {
        // 获取 ResultSet 元数据
        ResultSetMetaData metaData = resultSet.getMetaData();
        // 获取列数
        int columnCount = metaData.getColumnCount();
        log.info("Number of columns: {}",columnCount);

        // 遍历 ResultSet 并打印结果
        while (resultSet.next()) {
            final Map&lt;String, String&gt; item = Maps.newHashMap();
            // 遍历每一列并打印
            for (int i = 1; i &lt;= columnCount; i++) {
                String columnName = metaData.getColumnName(i);
                String columnValue = resultSet.getString(i);
                item.put(columnName, columnValue);
            }

            log.info(item.toString());
        }
    }

    private static String resourcePath(String path) {
        final URL url = CalciteCsvTest.class.getResource("/" + path);
        return Sources
                .of(url).file().getAbsolutePath();
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23029293702662038" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 20:47">2025-01-20 20:34</span>&nbsp;
<a href="https://www.cnblogs.com/ludangxin">张铁牛</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18682268" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18682268);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18682268', targetLink: 'https://www.cnblogs.com/ludangxin/p/18682268', title: '1. Calcite元数据创建' })">举报</a>
</div>
        