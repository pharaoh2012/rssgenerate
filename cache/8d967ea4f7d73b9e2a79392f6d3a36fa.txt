
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/expector/p/18704958/linear_recursion" title="发布于 2025-02-08 18:23">
    <span role="heading" aria-level="2">[OI 向] 深入理解二阶线性递推</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文主要面向普及/提高组 OIer 和 ACMer。考虑大多数 OIer 的情况，本文默认读者只会矩阵乘法，不了解矩阵的行列式，矩阵的秩等内容。本文使用 C++ 编写代码示例。</p>
</blockquote>
<h2 id="什么是二阶线性递推">什么是二阶线性递推</h2>
<p>二阶线性递推数列在 OI 界还有个著名的名字：<a href="https://www.luogu.com.cn/problem/P1349" target="_blank" rel="noopener nofollow">广义斐波那契数列</a>。其所指为如下数列 <span class="math inline">\(\{a_n\}\)</span>：</p>
<p></p><div class="math display">\[a_{n} = pa_{n - 1} + qa_{n - 2}
\]</div><p></p><p>其中，<span class="math inline">\(p,q\in \mathbb{R}\)</span>，数列前两项为 <span class="math inline">\(a_0, a_1\)</span>。</p>
<p>由于该数列的递推关系是线性的，且每一项都和前两项有关，因此称为二阶线性递推数列。</p>
<h3 id="斐波那契数列与朴素算法">斐波那契数列与朴素算法</h3>
<p>当前文的数列 <span class="math inline">\(\{a_n\}\)</span> 中 <span class="math inline">\(p=q=1,a_0=a_1=1\)</span> 时，该数列就是大名鼎鼎的斐波那契数列 <span class="math inline">\(\{f_n\}\)</span>：</p>
<p></p><div class="math display">\[f_n=f_{n-1}+f_{n-2}
\]</div><p></p><p>基于这样的递推关系，我们可以写出线性复杂度 <span class="math inline">\(\mathcal{O}(n)\)</span> 的朴素算法：</p>
<pre><code class="language-cpp">int f(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return f(n - 1) + f(n - 2);
}
</code></pre>
<p>对于较为<a href="https://www.luogu.com.cn/problem/P1720" target="_blank" rel="noopener nofollow">简单的情况</a>，这样的算法是可以接受的。</p>
<p>我们可以很容易的推广到更一般的情况，所以对于一般的二阶线性递推的朴素算法就留给读者练习吧。</p>
<h2 id="通过矩阵乘法来优化递推">通过矩阵乘法来优化递推</h2>
<p>直接根据递推式计算虽然简单，但是实在是太慢了，我们需要优化。如果你还没有学过矩阵乘法，请移步至 <a href="https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95" target="_blank" rel="noopener nofollow">OI Wiki</a>（记得顺便把方阵的逆看看，后面要用）。如果你学过矩阵乘法，应当对下面的式子不陌生（如果你对这个式子有点陌生的话，请尝试手动计算左面的矩阵乘法）：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 f_{n-1} &amp; f_{n-2}
\end{bmatrix}
\begin{bmatrix}
 1 &amp; 1\\
 1 &amp; 0
\end{bmatrix}
=
\begin{bmatrix}
 f_{n} &amp; f_{n-1}
\end{bmatrix}
\]</div><p></p><p>这个式子旨在将斐波那契递推关系用矩阵乘法表示，以进行进一步的操作。其中 <span class="math inline">\(\begin{bmatrix}f_{n-1} &amp; f_{n-2}\end{bmatrix}\)</span> 被称为状态矩阵（在本例中，它也是个向量），<span class="math inline">\(\begin{bmatrix} 1 &amp; 1\\ 1 &amp; 0\end{bmatrix}\)</span> 被称为转移矩阵。这样的转移在线性代数中属于线性变换，其中转移矩阵被称为线性算子。我们可以很容易的推广到一般的二阶线性递推上：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 a_{n-1} &amp; a_{n-2}
\end{bmatrix}
\begin{bmatrix}
 p &amp; 1\\
 q &amp; 0
\end{bmatrix}
=
\begin{bmatrix}
 a_{n} &amp; a_{n-1}
\end{bmatrix}
\]</div><p></p><p>据此可以得出使用矩阵乘法表示的二阶线性递推的通项公式：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 a_{n} &amp; a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
 a_0 &amp; a_1
\end{bmatrix}
\begin{bmatrix}
 p &amp; 1\\
 q &amp; 0
\end{bmatrix}^n
\]</div><p></p><p>通过矩阵快速幂算法就可以将算法优化到对数复杂度 <span class="math inline">\(\mathcal{O}(\log n)\)</span>，这在一般情况下已经是最优的了（至于是不是真的是最优的，我也不知道，我也不会证）。</p>
<p>代码也是很好实现的，以斐波那契为例：</p>
<pre><code class="language-cpp">using vec = array&lt;int, 2&gt;;
struct matrix : public array&lt;vec, 2&gt; {
    using array&lt;vec, 2&gt;::array;
    matrix(const vec &amp;a, const vec &amp;b) : array{a, b} {
        (*this)[0] = a;
        (*this)[1] = b;
    }
    matrix &amp;operator*=(const matrix &amp;other) {
        matrix res{};
        for (int i{0}; i &lt; 2; ++i)
            for (int j{0}; j &lt; 2; ++j)
                for (int k{0}; k &lt; 2; ++k)
                    res[i][j] += (*this)[i][k] * other[k][j];
        return *this = res;
    }
} e{{1, 0}, {0, 1}};

matrix qpow(matrix x, int n) {
    auto res{e};
    while (n) {
        if (n &amp; 1)
            res *= x;
        x *= x, n &gt;&gt;= 1;
    }
    return res;
}

int fib(int n) {
    return qpow(matrix{{1, 1}, {1, 0}}, n)[0][0];
}
</code></pre>
<h3 id="一种更有趣的优化算法">一种更有趣的优化算法</h3>
<blockquote>
<p>接下来的这部分内容会有点抽象，如果你学过抽象代数那看这部分内容就再好不过了。</p>
</blockquote>
<p>我们可以找到另一种递推的矩阵表示：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 a_{n-1}\color{red}{\cdot p+}qa_{n-2} &amp; a_{n-1}\color{red}{\cdot q}\\
 a_{n-1} &amp; qa_{n-2}
\end{bmatrix}
\begin{bmatrix}
 1\color{red}{\cdot p+}0 &amp; 1\color{red}{\cdot q}\\
 1 &amp; 0
\end{bmatrix}
=
\begin{bmatrix}
 a_{n}\color{red}{\cdot p+}qa_{n-1} &amp; a_{n}\color{red}{\cdot q}\\
 a_{n} &amp; qa_{n-1}
\end{bmatrix}
\]</div><p></p><p>如果你乍一眼看不出来，可以计算一下。为了找到这个式子，我思考了一个晚上。注意到在这个式子中所有的矩阵都形如：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 a\color{red}{\cdot p+}b &amp; a\color{red}{\cdot q}\\
 a &amp; b
\end{bmatrix}
\]</div><p></p><p>每个矩阵都只与两个元素有关，因此我们可以使用一个二元组来表示这类矩阵，并定义二元组上的乘法：</p>
<p></p><div class="math display">\[\begin{aligned}
(a,b)*(c,d)&amp;=\begin{bmatrix}
 a\color{red}{\cdot p+}b &amp; a\color{red}{\cdot q}\\
 a &amp; b
\end{bmatrix}
\begin{bmatrix}
 c\color{red}{\cdot p+}d &amp; c\color{red}{\cdot q}\\
 c &amp; d
\end{bmatrix}
\\&amp;=
\begin{bmatrix}
 (pac+ad+bc)\color{red}{\cdot p+}qac+bd &amp; (pac+ad+bc)\color{red}{\cdot q}\\
 pac+ad+bc &amp; qac+bd
\end{bmatrix}
\\&amp;=(pac+ad+bc,qac+bd)
\end{aligned}
\]</div><p></p><p>事实上，在抽象代数领域，这是找到了一个特定类型矩阵的同构：</p>
<p></p><div class="math display">\[\phi(a,b)=\begin{bmatrix}
 a\color{red}{\cdot p+}b &amp; a\color{red}{\cdot q}\\
 a &amp; b
\end{bmatrix}
\]</div><p></p><p>因此矩阵原有的代数性质对于二元组也是成立的，比如最重要的结合律，这是快速幂得以使用的基础。很容易得出使用这种二元组表示的通项公式：</p>
<p></p><div class="math display">\[(a_{n+1},a_n)=(a_1,a_0)*(1,0)^n
\]</div><p></p><p>很容易观察到二元组乘法的单位元：</p>
<p></p><div class="math display">\[(a,b)*(0,1)=(0,1)*(a,b)=(a,b)
\]</div><p></p><p>而且不难找到 <span class="math inline">\((1,0)\)</span> 的逆元：</p>
<p></p><div class="math display">\[(1,0)*\left(q^{-1},-pq^{-1}\right)=(0,1)
\]</div><p></p><p>这样我们就可以方便的实现倒推了。</p>
<p>理论上讲由于这个方法相比矩阵会少算两三次乘法或加法，因此常数会小一点，实际上没什么差距。下面是针对斐波那契数列的代码：</p>
<pre><code class="language-cpp">struct phi_tuple : pair&lt;int, int&gt; {
    using pair&lt;int, int&gt;::pair;
    phi_tuple &amp;operator*=(const phi_tuple &amp;other) {
        // 这里计算的时候提取了公因式以减少一次乘法
        return *this = {first * (other.first + other.second) +
                            second * other.first,
                        first * other.first + second * other.second};
    }
} e{0, 1};

phi_tuple qpow(phi_tuple x, int n) {
    auto res{e};
    while (n) {
        if (n &amp; 1)
            res *= x;
        x *= x, n &gt;&gt;= 1;
    }
    return res;
}

int fib(int n) {
    return qpow(phi_tuple{1, 0}, n + 1).first;
}
</code></pre>
<h2 id="特征根法求通项公式的线性代数理解">特征根法求通项公式的线性代数理解</h2>
<p>对于二阶线性递推，一种广为人知的求通项公式的方法是特征根法。对于二阶线性递推：</p>
<p></p><div class="math display">\[a_{n} = pa_{n - 1} + qa_{n - 2}
\]</div><p></p><p>有特征方程：</p>
<p></p><div class="math display">\[\varphi^2=p\varphi+q
\]</div><p></p><p>可以解出该方程的两个复根：</p>
<p></p><div class="math display">\[\varphi_1=\phi,\varphi_2=\psi
\]</div><p></p><p>当 <span class="math inline">\(\phi\neq\psi\)</span> 时（即 <span class="math inline">\(\Delta\neq0\)</span>），有：</p>
<p></p><div class="math display">\[a_n=s\phi^n+t\psi^n
\]</div><p></p><p>当 <span class="math inline">\(\phi=\psi\)</span> 时（即 <span class="math inline">\(\Delta=0\)</span>），有：</p>
<p></p><div class="math display">\[a_n=(s+tn)\varphi^n
\]</div><p></p><p>接下来只需要将 <span class="math inline">\(a_0,a_1\)</span> 代入求出 <span class="math inline">\(s,t\)</span> 即可。</p>
<hr>
<p>下面我们以斐波那契数列为例。斐波那契数列的特征方程为：</p>
<p></p><div class="math display">\[\varphi^2=\varphi+1
\]</div><p></p><p>解得：</p>
<p></p><div class="math display">\[\phi=\dfrac{1-\sqrt{5}}{2},\psi=\dfrac{1+\sqrt{5}}{2}
\]</div><p></p><p>于是：</p>
<p></p><div class="math display">\[f_n=s\left(\dfrac{1-\sqrt{5}}{2}\right)^n+t\left(\dfrac{1+\sqrt{5}}{2}\right)^n
\]</div><p></p><p>将 <span class="math inline">\(f_0=1,f_1=1\)</span> 代入，会得到一坨很复杂的东西，于是方便起见取 <span class="math inline">\(f_0=0,f_1=1\)</span>：</p>
<p></p><div class="math display">\[s=-\dfrac{1}{\sqrt{5}},t=\dfrac{1}{\sqrt{5}}
\]</div><p></p><p>这样我们就可以得到取 <span class="math inline">\(f_0=0,f_1=1\)</span> 时的斐波那契通项公式了：</p>
<p></p><div class="math display">\[f_n=\dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^n-\left(\dfrac{1-\sqrt{5}}{2}\right)^n\right]
\]</div><p></p><p>程序实现请继续往后看……</p>
<h3 id="相似对角化和矩阵特征值与特征向量">相似对角化和矩阵特征值与特征向量</h3>
<blockquote>
<p>方便起见，如无特殊说明，本节内容均以 <span class="math inline">\(2\times 2\)</span> 矩阵为例</p>
</blockquote>
<p>上面的方法有多种证明，在这里我们从线性代数的角度考虑。一种很自然的想法是想办法展开矩阵表示的通项公式：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 a_{n} &amp; a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
 a_0 &amp; a_1
\end{bmatrix}
\begin{bmatrix}
 p &amp; 1\\
 q &amp; 0
\end{bmatrix}^n
\]</div><p></p><p>显然问题的关键在于展开右侧的方阵幂。乍一看会有点没思路，不妨从更简单的对角矩阵考虑。对角矩阵指的是形如下面的方阵：</p>
<p></p><div class="math display">\[\boldsymbol{\Lambda}=\begin{bmatrix}
 m &amp; \\
  &amp; n
\end{bmatrix}
\]</div><p></p><p>其中空白的区域表示省略的 <span class="math inline">\(0\)</span>。观察对焦方阵的平方以及立方：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 m &amp; \\
  &amp; n
\end{bmatrix}^2=
\begin{bmatrix}
 m^2 &amp; \\
  &amp; n^2
\end{bmatrix}
\\\begin{bmatrix}
 m &amp; \\
  &amp; n
\end{bmatrix}^3=
\begin{bmatrix}
 m^3 &amp; \\
  &amp; n^3
\end{bmatrix}
\]</div><p></p><p>猜测对角矩阵的幂满足：</p>
<p></p><div class="math display">\[\begin{bmatrix}
 m &amp; \\
  &amp; n
\end{bmatrix}^k=
\begin{bmatrix}
 m^k &amp; \\
  &amp; n^k
\end{bmatrix},k\in\mathbb{N}
\]</div><p></p><p>很容易通过数学归纳法证明。于是我们找到了计算对角矩阵的幂次的方法，接下来考虑推广到一般的方阵。最直接的想法是将方阵转化为对角矩阵。考虑下面的式子：</p>
<p></p><div class="math display">\[\boldsymbol{A}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}
\]</div><p></p><p>注意到：</p>
<p></p><div class="math display">\[\boldsymbol{A}^n=\left(\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}\right)\left(\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}\right)\cdots\left(\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}\right)
\]</div><p></p><p>其中 <span class="math inline">\(\boldsymbol{P}\)</span> 和 <span class="math inline">\(\boldsymbol{P}^{-1}\)</span> 成对出现，于是：</p>
<p></p><div class="math display">\[\boldsymbol{A}^n=\boldsymbol{P}\boldsymbol{\Lambda}^n\boldsymbol{P}^{-1}
\]</div><p></p><p>接下来只需找到 <span class="math inline">\(\boldsymbol{A}\)</span> 对应的 <span class="math inline">\(\boldsymbol{P}\)</span> 和 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 即可，这个过程被称为矩阵的相似对角化。</p>
<p>在寻找相似对角化的方法之前，我们先补充一些知识。你也许已经知道线性方程组可以用矩阵乘法等价表示：</p>
<p></p><div class="math display">\[\left\{
    \begin{matrix}
        a_{11}x_1+a_{12}x_2=b_1\\
        a_{21}x_1+a_{22}x_2=b_2
    \end{matrix}
\right.
\iff
\begin{bmatrix}
    a_{11} &amp; a_{12}\\
    a_{21} &amp; a_{22}
\end{bmatrix}
\begin{bmatrix}
    b_1\\
    b_2
\end{bmatrix}
=
\begin{bmatrix}
    b_1\\
    b_2
\end{bmatrix}
\]</div><p></p><p>基于此，线性方程组均可视为 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{b}\)</span> 的形式。当 <span class="math inline">\(\boldsymbol{b}=\boldsymbol{0}\)</span> 时，称其为齐次线性方程组，每个方阵都唯一对应一个齐次线性方程组。</p>
<p>另外，你还可能听说过行列式：</p>
<p></p><div class="math display">\[\begin{vmatrix}
    a &amp; b\\
    c &amp; d
\end{vmatrix}
=ad-bc
\]</div><p></p><p>方阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的行列式可以显示方阵的一些性质，比如方阵对应的齐次方程组的解的情况和是否可逆：</p>
<ol>
<li><span class="math inline">\(|\boldsymbol{A}| = 0\)</span> 时，方阵不可逆，有无穷多解，且任意解之间都线性相关，也就是说每个解都可以通过数乘另一个解得到</li>
<li><span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span> 时，方阵可逆，只有零解</li>
</ol>
<p>因篇幅有限，在此不做证明。</p>
<p>相似对角化需要利用矩阵的特征值 <span class="math inline">\(\lambda\)</span> 和特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>，其满足：</p>
<p></p><div class="math display">\[\boldsymbol{A}x=\lambda \boldsymbol{x},\boldsymbol{x}\neq\boldsymbol{0}
\]</div><p></p><p>等号右侧可以乘上单位矩阵 <span class="math inline">\(\boldsymbol{E}\)</span> 来变形：</p>
<p></p><div class="math display">\[\left(\boldsymbol{A}-\lambda\boldsymbol{E}\right)\boldsymbol{x}=\boldsymbol{0}
\]</div><p></p><p>由于 <span class="math inline">\(\boldsymbol{x}\neq\boldsymbol{0}\)</span> 故</p>
<p></p><div class="math display">\[|\boldsymbol{A}-\lambda\boldsymbol{E}|=0
\]</div><p></p><p>这其实就是一个关于 <span class="math inline">\(\lambda\)</span> 的多项式方程，实际上等号左边被称为矩阵的特征多项式。由于本文以二阶方阵为例，因此特征多项式是一元二次的，那么就有两个根 <span class="math inline">\(\lambda_1,\lambda_2\)</span>，这两个根都是矩阵的特征值。将 <span class="math inline">\(\lambda\)</span> 回代即可得求出特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>，每个 <span class="math inline">\(\lambda_i\)</span> 均对应无穷多组解 <span class="math inline">\(k\boldsymbol{x_i},k\in\mathbb{R}\)</span>。</p>
<p>回到相似对角化，可以证明，如果一个矩阵是可以相似对角化的，那么必然有下面的相似对角化方案：</p>
<p></p><div class="math display">\[\boldsymbol{\Lambda}=\begin{bmatrix}
    \lambda_1 &amp; \\
     &amp; \lambda_2
\end{bmatrix},
\boldsymbol{P}=\begin{bmatrix}
    \boldsymbol{x}_1 &amp; \boldsymbol{x}_2
\end{bmatrix}
\]</div><p></p><p>其中 <span class="math inline">\(\boldsymbol{x}_i\)</span> 是任意一个特征值 <span class="math inline">\(\lambda_i\)</span> 对应的非零特征向量。其中 <span class="math inline">\(\boldsymbol{P}\)</span> 被称为特征矩阵。当且仅当 <span class="math inline">\(\lambda_i\)</span> 两两不同时，矩阵 <span class="math inline">\(\boldsymbol{P}\)</span> 可逆，读者自证不难。解线性方程组和求逆矩阵都可以通过高斯消元法，限于篇幅，这里就不展开了。</p>
<hr>
<p>接下来仍然以斐波那契数列为例。以 <span class="math inline">\(f_0=1\)</span> 为首项。有矩阵通项公式（其中 <span class="math inline">\(\odot\)</span> 表示不重要的元素，下同）：</p>
<p></p><div class="math display">\[\begin{bmatrix}
    f_n &amp; f_{n-1}\\
    \odot &amp; \odot
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1\\
    1 &amp; 0
\end{bmatrix}^n
\]</div><p></p><p>转移矩阵的特征多项式、特征值和特征向量：</p>
<p></p><div class="math display">\[\lambda^2-\lambda-1
\]</div><p></p><p></p><div class="math display">\[\lambda_1=\dfrac{1+\sqrt{5}}{2},\lambda_2=\dfrac{1-\sqrt{5}}{2}
\]</div><p></p><p></p><div class="math display">\[\boldsymbol{x}_1=\begin{bmatrix}1\\-\dfrac{1-\sqrt{5}}{2}\end{bmatrix},
\boldsymbol{x}_2=\begin{bmatrix}1\\-\dfrac{1+\sqrt{5}}{2}\end{bmatrix}
\]</div><p></p><p>相似对角矩阵和特征矩阵：</p>
<p></p><div class="math display">\[\boldsymbol{\Lambda}=\begin{bmatrix}
    \dfrac{1 + \sqrt{5}}{2}&amp;\\
    &amp;\dfrac{1 - \sqrt{5}}{2}
\end{bmatrix}
\]</div><p></p><p></p><div class="math display">\[\boldsymbol{P}=\begin{bmatrix}
    1&amp;1\\
    -\dfrac{1 - \sqrt{5}}{2}&amp;-\dfrac{1 + \sqrt{5}}{2}
\end{bmatrix}
\]</div><p></p><p>特征矩阵的逆：</p>
<p></p><div class="math display">\[\boldsymbol{P}^{-1}=\dfrac{1}{\sqrt{5}}\begin{bmatrix}
    \dfrac{1 + \sqrt{5}}{2}&amp;1\\
    -\dfrac{1 - \sqrt{5}}{2}&amp;-1
\end{bmatrix}
\]</div><p></p><p>相似对角化求幂次：</p>
<p></p><div class="math display">\[\begin{aligned}
\begin{bmatrix}
    1 &amp; 1\\
    1 &amp; 0
\end{bmatrix}^n
&amp;=\dfrac{1}{\sqrt{5}}
\begin{bmatrix}
    1&amp;1\\
    -\dfrac{1 - \sqrt{5}}{2}&amp;-\dfrac{1 + \sqrt{5}}{2}
\end{bmatrix}
\begin{bmatrix}
    \dfrac{1 + \sqrt{5}}{2}&amp;\\
    &amp;\dfrac{1 - \sqrt{5}}{2}
\end{bmatrix}^n
\begin{bmatrix}
    \dfrac{1 + \sqrt{5}}{2}&amp;1\\
    -\dfrac{1 - \sqrt{5}}{2}&amp;-1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
    \dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\dfrac{1-\sqrt{5}}{2}\right)^{n+1}\right]&amp;\odot\\
    \odot&amp;\odot
\end{bmatrix}
\end{aligned}
\]</div><p></p><p>于是我们就得到了通项公式：</p>
<p></p><div class="math display">\[f_n=\dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\dfrac{1-\sqrt{5}}{2}\right)^{n+1}\right]
\]</div><p></p><hr>
<p>接下来就是写代码了。方便起见，后文就以 <span class="math inline">\(f_0=0\)</span> 作为首项……（说实话我也不知道我为啥要在这里绕来绕去，但是懒得改了）我们有通项公式：</p>
<p></p><div class="math display">\[f_n=\dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\dfrac{1-\sqrt{5}}{2}\right)^{n}\right]
\]</div><p></p><p>如果只是要某一项的值的话，那直接在浮点数环境下计算就可以了。事实上，我们可以发现一个常数对半砍的公式：</p>
<p></p><div class="math display">\[f_n=\operatorname{round}\left[\dfrac{1}{\sqrt{5}}\left(\dfrac{1+\sqrt{5}}{2}\right)^{n}\right]
\]</div><p></p><p>其中 <span class="math inline">\(\mathrm{round}(x)\)</span> 表示四舍五入到整数。这是由于 <span class="math inline">\(\left|\tfrac{1}{\sqrt{5}}\left(\tfrac{1-\sqrt{5}}{2}\right)^{n}\right|&lt;\tfrac{1}{2}\)</span>，因此四舍五入可以忽略这部分影响。更加激进的，根据工程经验（其实是懒得误差分析），由于 <span class="math inline">\(\tfrac{1}{\sqrt{5}}\approx 0.447,\tfrac{1-\sqrt{5}}{2}\approx 1.618\)</span>，下面的公式可以完美作为通项公式：</p>
<p></p><div class="math display">\[f_n=\operatorname{round}\left(0.447\cdot1.618^n\right)
\]</div><p></p><p>代码也很好实现，适用于<a href="https://www.luogu.com.cn/problem/P1720" target="_blank" rel="noopener nofollow">不需要取模的情况</a>：</p>
<pre><code class="language-cpp">float qpow(float x, int n) {
    float r = 1;
    while (n) {
        if (n &amp; 1)
            r *= x;
        x *= x, n &gt;&gt;= 1;
    }
    return r;
}

int fib(int n) {
    return round(0.447 * qpow(1.618, n));
}
</code></pre>
<p>但是如果你的需求是斐波那契数列取模，因为涉及到 <span class="math inline">\(\sqrt5\)</span>，那就比较复杂了。第一想法是二次剩余，但是 <span class="math inline">\(5\)</span> 在很多常见模数下没有二次剩余（如果你不知道什么是二次剩余，可以简单的理解为模意义下的平方根，这是数论的内容）。如果你了解过抽象代数或者代数数论，你肯能会想到一个东西——二次整数环。</p>
<h3 id="二次整数环">二次整数环</h3>
<p>二次整数环就是所有由整数加上一个特殊无理数后，通过加减乘得到的数所组成的集合。这些数不仅保留了整数环的性质，还可以在更广的范围内进行带余除法等操作。如果你学过复数，那就像复数是由实数和虚数部分组成一样，二次整数环是由整数和一个特定的无理数（如 <span class="math inline">\(\sqrt5\)</span>）的整数倍组合而成的数，这通常表示为 <span class="math inline">\(\mathbb{Z}[\sqrt{d}]\)</span>。二次整数环 <span class="math inline">\(\mathbb{Z}[\sqrt{d}]\)</span> 上的运算和二次根式运算是一致的：</p>
<ol>
<li>加减法：<span class="math inline">\((a_1+a_2\sqrt{d})+(b_1+b_2\sqrt{d}) = (a_1+b_1)+(a_2+b_2)\sqrt{d}\)</span></li>
<li>乘法：<span class="math inline">\((a_1+a_2\sqrt{d})(b_1+b_2\sqrt{d})=(a_1b_1+a_2b_2d)+(a_1b_2+a_2b_1)\sqrt{d}\)</span></li>
</ol>
<p>由于除法较为复杂而且我们现在用不到，就不做讨论了。在模意义下，每次计算完分别对整数部分和根式部分的系数取模即可，这实际上构成了二次整数环的剩余类环，一般记作 <span class="math inline">\(\mathbb{Z}[\sqrt{d}]/\{p\}\)</span>，<span class="math inline">\(p\)</span> 是模数。在模意义下二次整数除以一个纯整数依旧是转化为乘上该整数的数论倒数（逆元）。除以二次整数的情况过于复杂且暂时本文用不到，就不做讨论了。</p>
<p>接下来就是愉快的代码实现环节：</p>
<pre><code class="language-cpp">using i64 = int64_t;

constexpr i64 m = 1e9 + 7;

template &lt;typename num&gt; constexpr num qpow(num a, i64 n) {
    num r = 1;
    while (n) {
        if (n &amp; 1)
            r *= a;
        a *= a, n &gt;&gt;= 1;
    }
    return r;
}

struct m64 {
    i64 x;
    constexpr m64(const i64 x) : x(((x % m) + m) % m) {
    }
    constexpr operator i64() const {
        return x;
    }
    constexpr m64 operator-() const {
        return m64(-x);
    }
    constexpr m64 operator*(const m64 &amp;o) const {
        return m64((x * o.x) % m);
    }
    constexpr m64 &amp;operator*=(const m64 &amp;o) {
        *this = *this * o;
        return *this;
    }
    constexpr m64 operator/(const m64 &amp;o) const {
        return m64(*this * qpow(o, m - 2));
    }
};

struct sr5m64 {
    m64 x, s;
    constexpr sr5m64(m64 x, m64 s) : x(x), s(s) {
    }
    constexpr sr5m64(i64 x) : x(x), s(0) {
    }
    constexpr sr5m64 operator-() const {
        return sr5m64(-x, -s);
    }
    constexpr sr5m64 operator+(const sr5m64 &amp;o) const {
        return sr5m64(x + o.x, s + o.s);
    }
    constexpr sr5m64 operator-(const sr5m64 &amp;o) const {
        return *this + (-o);
    }
    constexpr sr5m64 operator*(const sr5m64 &amp;o) const {
        return sr5m64(x * o.x + 5 * s * o.s, x * o.s + s * o.x);
    }
    constexpr sr5m64 &amp;operator*=(const sr5m64 &amp;o) {
        *this = *this * o;
        return *this;
    }
    constexpr sr5m64 operator/(const m64 &amp;o) const {
        return sr5m64(x / o, s / o);
    }
};

constexpr m64 fib(i64 n) {
    return ((qpow(sr5m64(1, 1) / 2, n) - qpow(sr5m64(1, -1) / 2, n)) * sr5m64(0, 1) / 5).x;
}
</code></pre>
<h2 id="二阶线性递推的一些性质">二阶线性递推的一些性质</h2>
<h3 id="模意义下的周期性">模意义下的周期性</h3>
<p>任何的二阶线性递推在模 <span class="math inline">\(m\)</span> 下都是具有周期性的。考虑矩阵表示中的状态模 <span class="math inline">\(m\)</span></p>
<p></p><div class="math display">\[\begin{bmatrix}
a_{n}\bmod{m}&amp;a_{n-1}\bmod{m}
\end{bmatrix}
\]</div><p></p><p>显然状态的每一项最多只有 <span class="math inline">\(m\)</span> 种，因此所有可能的状态最多有 <span class="math inline">\(m^2\)</span> 种，所以在二阶线性递推充分多次后必然产生两个相同的状态，因此会呈现出周期性。这个结论也可以推广到任意阶线性递推。</p>
<p>由于求解最小正周期需要用到二项式定理等内容，在此不做展开，详情参考<a href="https://oi-wiki.org/math/combinatorics/fibonacci/#%E7%9A%AE%E8%90%A8%E8%AF%BA%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener nofollow">皮萨诺周期</a>。一道<a href="https://www.luogu.com.cn/problem/P4000" target="_blank" rel="noopener nofollow">广为流传的题目</a>可能需要这部分知识。</p>
<h3 id="斐波那契数列相邻两项之比趋于黄金分割比">斐波那契数列相邻两项之比趋于黄金分割比</h3>
<p>黄金分割比指的是</p>
<p></p><div class="math display">\[\phi=\dfrac{\sqrt{5}-1}{2}
\]</div><p></p><p>很显然其是斐波那契数列的一个特征根。本节小标题的意思是：</p>
<p></p><div class="math display">\[\lim_{n\to \infty}\dfrac{f_n}{f_{n+1}}=\phi
\]</div><p></p><p>直接代入通项公式暴力求极限即可：</p>
<p></p><div class="math display">\[\begin{aligned}
\lim_{n\to \infty}\dfrac{f_n}{f_{n+1}}&amp;=\lim_{n\to \infty}
\dfrac{\dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\dfrac{1-\sqrt{5}}{2}\right)^{n}\right]}{\dfrac{1}{\sqrt{5}}\left[\left(\dfrac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\dfrac{1-\sqrt{5}}{2}\right)^{n+1}\right]}\\
&amp;=\lim_{n\to \infty}
\dfrac{\dfrac{\sqrt{5}-1}{2}+(-1)^n\left(\dfrac{1-\sqrt{5}}{2}\right)^{2n+1}}{1+(-1)^n\left(\dfrac{1-\sqrt{5}}{2}\right)^{2n+2}}\\
&amp;=\dfrac{\sqrt{5}-1}{2}=\phi
\end{aligned}
\]</div><p></p><p>对于一部分二阶线性递推，也能得出相似的结论。</p>
<h2 id="结语">结语</h2>
<p>累了，就先写到这里吧……</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08325011761689814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-08 18:23">2025-02-08 18:23</span>&nbsp;
<a href="https://www.cnblogs.com/expector">Expector</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18704958" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18704958);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18704958', targetLink: 'https://www.cnblogs.com/expector/p/18704958/linear_recursion', title: '[OI 向] 深入理解二阶线性递推' })">举报</a>
</div>
        