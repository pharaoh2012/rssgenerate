
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rendezvous/p/18806711" title="发布于 2025-04-02 20:55">
    <span role="heading" aria-level="2">Hyperledger Fabric - 自定义network.sh脚本</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="引言依据hyperledger-fabric提供的测试网络脚本搭建自己的网络环境">引言：依据hyperledger fabric提供的测试网络脚本搭建自己的网络环境</h3>
<p>该系列参考：<a href="https://blog.csdn.net/ling1998?type=blog" target="_blank" rel="noopener nofollow">https://blog.csdn.net/ling1998?type=blog</a></p>
<p>执行./network.sh up 将调用脚本中networkUp()函数，函数解析如下图所示</p>
<p><img src="https://s2.loli.net/2025/04/02/b6dPESUymG4CZBg.png" alt="img" loading="lazy"></p>
<h2 id="创建自己的网络目录">创建自己的网络目录</h2>
<h3 id="进入fabric-samples目录">进入fabric-samples目录</h3>
<pre><code class="language-bash">cd $GOPATH/src/github.com/hyperledger/fabric/scripts/fabric-samples
</code></pre>
<h3 id="创建文件夹test-network-myself">创建文件夹test-network-myself</h3>
<pre><code class="language-bash">mkdir test-network-myself
</code></pre>
<h3 id="进入test-network-myself目录">进入test-network-myself目录</h3>
<pre><code class="language-bash">cd test-network-myself
</code></pre>
<h2 id="创建并编辑crypto-configyaml">创建并编辑crypto-config.yaml</h2>
<p>因hyperledger fabri是许可网络，任何节点的网络参与者都需要有证书才可以访问网络，证书是证明能够访问网络的通行证</p>
<h3 id="创建crypto-configyaml文件">创建crypto-config.yaml文件</h3>
<pre><code class="language-bash">touch crypto-config.yaml
</code></pre>
<h3 id="编辑crypto-configyaml文件">编辑crypto-config.yaml文件</h3>
<pre><code class="language-bash">vim crypto-config.yaml
</code></pre>
<p>文件中创建2个peer节点，一个order排序节点，两个organization组织</p>
<pre><code class="language-yaml">OrdererOrgs: # 排序节点配置
  - Name: Orderer # 组织名称
    Domain: example.com # 组织域名
    EnableNodeOUs: true # 设置为true，将会在msp目录下生成config.yaml文件
    Specs:
      - Hostname: orderer # 主机名称
        SANS:
          - localhost # 除主机名称外的别名
PeerOrgs: # peer节点配置
  - Name: Org1
    Domain: org1.example.com
    EnableNodeOUs: true
    Template: # 使用模板，将自动生成hostname，以peer0到peerN-1的顺序生成
      Count: 1 # peer节点个数
      SANS:
       - localhost
    Users:
      Count: 1 # peer节点中用户数量，除了管理员以外的用户数量
  - Name: Org2
    Domain: org2.example.com
    EnableNodeOUs: true
    Template:
      Count: 1
      SANS:
       - localhost 
    Users:
      Count: 1
</code></pre>
<h3 id="生成组织及证书">生成组织及证书</h3>
<pre><code class="language-bash">cryptogen generate --config=./crypto-config.yaml --output="organizations"
</code></pre>
<p>解释：<br>
cryptogen generate命令中的参数：</p>
<p>--output="organizations"          用来存放构建的输出目录<br>
--config=./crypto-config.yaml   使用的配置文件，即第2步中创建的文件</p>
<h5 id="查看organization目录">查看organization目录</h5>
<pre><code class="language-bash">[root@localhost test-network-myself]# tree organizations
organizations
├── ordererOrganizations #排序组织
│   └── example.com #配置文件中的域名作为目录
│       ├── ca      #证书文件目录
│       │   ├── ca.example.com-cert.pem  #公钥
│       │   └── priv_sk                  #私钥 
│       ├── msp    #存放签名用的证书文件和加密用的私钥文件
│       │   ├── admincerts  #超级管理员，管理排序节点
│       │   ├── cacerts     #根CA证书，可颁发其它证书
│       │   │   └── ca.example.com-cert.pem  #加密证书
│       │   ├── config.yaml
│       │   └── tlscacerts  #TLS根CA证书，网络安全协议
│       │       └── tlsca.example.com-cert.pem  #加密证书
│       ├── orderers #配置文件中的排序节点名称作为目录,
│       │   └── orderer.example.com  #配置文件中的排序节点名称.域名作为目录
│       │       ├── msp
│       │       │   ├── admincerts
│       │       │   ├── cacerts
│       │       │   │   └── ca.example.com-cert.pem
│       │       │   ├── config.yaml
│       │       │   ├── keystore
│       │       │   │   └── priv_sk
│       │       │   ├── signcerts
│       │       │   │   └── orderer.example.com-cert.pem
│       │       │   └── tlscacerts
│       │       │       └── tlsca.example.com-cert.pem
│       │       └── tls
│       │           ├── ca.crt
│       │           ├── server.crt
│       │           └── server.key
│       ├── tlsca
│       │   ├── priv_sk
│       │   └── tlsca.example.com-cert.pem
│       └── users    #组织成员目录
│           └── Admin@example.com #至少有一个管理员
│               ├── msp
│               │   ├── admincerts
│               │   ├── cacerts
│               │   │   └── ca.example.com-cert.pem
│               │   ├── config.yaml
│               │   ├── keystore  #账号的私钥
│               │   │   └── priv_sk 
│               │   ├── signcerts #符合X.509的节点或者账户证书文件
│               │   │   └── Admin@example.com-cert.pem   
│               │   └── tlscacerts
│               │       └── tlsca.example.com-cert.pem
│               └── tls
│                   ├── ca.crt
│                   ├── client.crt
│                   └── client.key
└── peerOrganizations #peer组织
    ├── org1.example.com #配置文件中的域名作为目录
    │   ├── ca
    │   │   ├── ca.org1.example.com-cert.pem
    │   │   └── priv_sk
    │   ├── msp
    │   │   ├── admincerts
    │   │   ├── cacerts
    │   │   │   └── ca.org1.example.com-cert.pem
    │   │   ├── config.yaml
    │   │   └── tlscacerts
    │   │       └── tlsca.org1.example.com-cert.pem
    │   ├── peers
    │   │   └── peer0.org1.example.com
    │   │       ├── msp
    │   │       │   ├── admincerts
    │   │       │   ├── cacerts
    │   │       │   │   └── ca.org1.example.com-cert.pem
    │   │       │   ├── config.yaml
    │   │       │   ├── keystore
    │   │       │   │   └── priv_sk
    │   │       │   ├── signcerts
    │   │       │   │   └── peer0.org1.example.com-cert.pem
    │   │       │   └── tlscacerts
    │   │       │       └── tlsca.org1.example.com-cert.pem
    │   │       └── tls
    │   │           ├── ca.crt
    │   │           ├── server.crt
    │   │           └── server.key
    │   ├── tlsca
    │   │   ├── priv_sk
    │   │   └── tlsca.org1.example.com-cert.pem
    │   └── users
    │       ├── Admin@org1.example.com
    │       │   ├── msp
    │       │   │   ├── admincerts
    │       │   │   ├── cacerts
    │       │   │   │   └── ca.org1.example.com-cert.pem
    │       │   │   ├── config.yaml
    │       │   │   ├── keystore
    │       │   │   │   └── priv_sk
    │       │   │   ├── signcerts
    │       │   │   │   └── Admin@org1.example.com-cert.pem
    │       │   │   └── tlscacerts
    │       │   │       └── tlsca.org1.example.com-cert.pem
    │       │   └── tls
    │       │       ├── ca.crt
    │       │       ├── client.crt
    │       │       └── client.key
    │       └── User1@org1.example.com
    │           ├── msp
    │           │   ├── admincerts
    │           │   ├── cacerts
    │           │   │   └── ca.org1.example.com-cert.pem
    │           │   ├── config.yaml
    │           │   ├── keystore
    │           │   │   └── priv_sk
    │           │   ├── signcerts
    │           │   │   └── User1@org1.example.com-cert.pem
    │           │   └── tlscacerts
    │           │       └── tlsca.org1.example.com-cert.pem
    │           └── tls
    │               ├── ca.crt
    │               ├── client.crt
    │               └── client.key
    └── org2.example.com
        ├── ca
        │   ├── ca.org2.example.com-cert.pem
        │   └── priv_sk
        ├── msp
        │   ├── admincerts
        │   ├── cacerts
        │   │   └── ca.org2.example.com-cert.pem
        │   ├── config.yaml
        │   └── tlscacerts
        │       └── tlsca.org2.example.com-cert.pem
        ├── peers
        │   └── peer0.org2.example.com
        │       ├── msp
        │       │   ├── admincerts
        │       │   ├── cacerts
        │       │   │   └── ca.org2.example.com-cert.pem
        │       │   ├── config.yaml
        │       │   ├── keystore
        │       │   │   └── priv_sk
        │       │   ├── signcerts
        │       │   │   └── peer0.org2.example.com-cert.pem
        │       │   └── tlscacerts
        │       │       └── tlsca.org2.example.com-cert.pem
        │       └── tls
        │           ├── ca.crt
        │           ├── server.crt
        │           └── server.key
        ├── tlsca
        │   ├── priv_sk
        │   └── tlsca.org2.example.com-cert.pem
        └── users
            ├── Admin@org2.example.com
            │   ├── msp
            │   │   ├── admincerts
            │   │   ├── cacerts
            │   │   │   └── ca.org2.example.com-cert.pem
            │   │   ├── config.yaml
            │   │   ├── keystore
            │   │   │   └── priv_sk
            │   │   ├── signcerts
            │   │   │   └── Admin@org2.example.com-cert.pem
            │   │   └── tlscacerts
            │   │       └── tlsca.org2.example.com-cert.pem
            │   └── tls
            │       ├── ca.crt
            │       ├── client.crt
            │       └── client.key
            └── User1@org2.example.com
                ├── msp
                │   ├── admincerts
                │   ├── cacerts
                │   │   └── ca.org2.example.com-cert.pem
                │   ├── config.yaml
                │   ├── keystore
                │   │   └── priv_sk
                │   ├── signcerts
                │   │   └── User1@org2.example.com-cert.pem
                │   └── tlscacerts
                │       └── tlsca.org2.example.com-cert.pem
                └── tls
                    ├── ca.crt
                    ├── client.crt
                    └── client.key
 
93 directories, 85 files
</code></pre>
<h3 id="生成通用连接配置文件json与yaml文件格式">生成通用连接配置文件（json与yaml文件格式）</h3>
<h4 id="拷贝测试网络中的ccp-generatesh脚本文件及ccp模板文件">拷贝测试网络中的ccp-generate.sh脚本文件及ccp模板文件</h4>
<p>因ccp-generate.sh脚本使用了ccp-template.yaml文件与ccp-template.json文件，因此一起拷贝</p>
<pre><code class="language-bash">cp ../test-network/organizations/ccp-* ./organizations/
</code></pre>
<p>ccp-generate.sh  ccp-template.json  ccp-template.yaml  ordererOrganizations  peerOrganizations</p>
<h4 id="执行ccp-generatesh脚本">执行ccp-generate.sh脚本</h4>
<pre><code class="language-bash">./organizations/ccp-generate.sh 
</code></pre>
<p>这会 在peer节点目录中生成json与yaml文件</p>
<h2 id="启动网络">启动网络</h2>
<h3 id="拷贝测试网络中的docker-compose-netyaml文件">拷贝测试网络中的docker-compose-net.yaml文件</h3>
<pre><code class="language-bash">mkdir docker
cp ../test-network/docker/docker-compose-test-net.yaml docker/  #拷贝文件
[root@localhost test-network-myself]# ls docker  #查看拷贝的文件
docker-compose-test-net.yaml
</code></pre>
<h3 id="设置环境变量docker_sock">设置环境变量DOCKER_SOCK</h3>
<pre><code class="language-bash">export DOCKER_SOCK=/var/run/docker.sock #设置环境变量
</code></pre>
<h3 id="使用docker-compose启动网络">使用docker-compose启动网络</h3>
<pre><code class="language-bash">docker-compose -f docker/docker-compose-test-net.yaml up -d
</code></pre>
<h3 id="使用docker-ps命令查看生成的容器">使用docker ps命令查看生成的容器</h3>
<pre><code class="language-bash">docker ps -a
</code></pre>
<h2 id="关闭自己搭建的网络">关闭自己搭建的网络</h2>
<h3 id="停止并删除容器网络卷镜像">停止并删除容器、网络、卷、镜像</h3>
<pre><code class="language-bash">docker-compose -f docker/docker-compose-test-net.yaml down --volumes --remove-orphans
</code></pre>
<h3 id="删除节点目录">删除节点目录</h3>
<pre><code class="language-bash">rm -rf ./organizations/*Organizations
</code></pre>
<h2 id="生成执行启动关闭网络脚本">生成执行启动/关闭网络脚本</h2>
<h3 id="提前条件">提前条件：</h3>
<p>执行完上面步骤将保留配置文件（5个），下面的脚本将基于这5个配置文件运行：</p>
<pre><code class="language-bash">[root@localhost test-network-myself]# tree 
.
├── crypto-config.yaml                #生成组织节点加密配置文件
├── docker
│   └── docker-compose-test-net.yaml  #启动网络配置文件
├── organizations                     
│   ├── ccp-generate.sh               #生成通用连接配置文件脚本
│   ├── ccp-template.json             #生成通用连接配置文件json格式模板
│   └── ccp-template.yaml             #生成通用连接配置文件yaml格式模板
├── scripts
└── system-genesis-block
    └── genesis.block
</code></pre>
<h3 id="创建脚本文件network-myselfsh">创建脚本文件network-myself.sh</h3>
<pre><code class="language-bash">touch network-myself.sh 
</code></pre>
<h3 id="授权network-myselfsh为可执行文件">授权network-myself.sh为可执行文件</h3>
<pre><code class="language-bash">chmod +x network-myself.sh 
</code></pre>
<h3 id="编写启动关闭网络脚本">编写启动/关闭网络脚本</h3>
<pre><code class="language-bash">vi network-myself.sh 
</code></pre>
<p>回车，按键盘上的 i 键或 Insert 功能键，进入编辑状态，脚本内容如下：</p>
<pre><code class="language-bash">#!/bin/bash
 
 
#开启自己的测试网络
function networkUpMyself() {
    # 关闭自己的测试网络
	networkDownMyself
 
	set -x
	# 生成组织及证书
	cryptogen generate --config=./crypto-config.yaml --output="organizations"
 
	# 执行ccp-generate.sh脚本，生成通用连通配置文件
	./organizations/ccp-generate.sh 
 
	# 启动网络
	export DOCKER_SOCK=/var/run/docker.sock
	docker-compose -f $COMPOSE_FILE_BASE up -d
 
	set +x
}
 
#关闭自己的测试网络
function networkDownMyself() {
    
	set -x
	
	#停止和删除容器、网络、卷、镜像
	export DOCKER_SOCK=/var/run/docker.sock
	docker-compose -f $COMPOSE_FILE_BASE down --volumes --remove-orphans
 
	#删除节点目录
	rm -rf ./organizations/*Organizations
 
	set +x
}
 
# docker-compose yaml文件地址
COMPOSE_FILE_BASE=docker/docker-compose-test-net.yaml
 
#参数命令
MODE=$1
 
 
if [ "${MODE}" == "up" ]; then
	echo "开启自己的测试网络"
	networkUpMyself
elif [ "${MODE}" == "down" ]; then
	echo "关闭自己的测试网络"
	networkDownMyself
else
	echo "up 开启自己的测试网络"
	echo "down 关闭自己的测试网络"
	exit 1
fi
</code></pre>
<h3 id="测试开启网络network-myselfsh-up">测试开启网络network-myself.sh up</h3>
<pre><code class="language-bash">./network-myself.sh up
</code></pre>
<h3 id="测试关闭网络network-myselfsh-down">测试关闭网络network-myself.sh down</h3>
<pre><code class="language-bash">./network-myself.sh down
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.10498438405439815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-02 21:49">2025-04-02 20:55</span>&nbsp;
<a href="https://www.cnblogs.com/rendezvous">终须有</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18806711" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18806711);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18806711', targetLink: 'https://www.cnblogs.com/rendezvous/p/18806711', title: 'Hyperledger Fabric - 自定义network.sh脚本' })">举报</a>
</div>
        