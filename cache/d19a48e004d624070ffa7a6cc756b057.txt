<!----> <meta itemprop="headline" content="2025前端面试题-Vue3进阶篇"> <meta itemprop="keywords" content="前端,面试"> <meta itemprop="datePublished" content="2025-06-04T01:53:15.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EB_Coder"> <meta itemprop="url" content="https://juejin.cn/user/3228641967213214"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025前端面试题-Vue3进阶篇
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3228641967213214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EB_Coder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-06-04T01:53:15.000Z" title="Wed Jun 04 2025 01:53:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-06-04
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    15,060
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><blockquote>
<p>以下为Vue3面试进阶篇考察点总结，具体知识点不会太详细，主要梳理面试核心考察点，为面试做准备。</p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/7503111373468893193" target="_blank" title="https://juejin.cn/post/7503111373468893193">2025前端面试题-Vue3基础篇</a></li>
<li><a href="https://juejin.cn/post/7503811658198286388" target="_blank" title="https://juejin.cn/post/7503811658198286388">2025前端面试题-React基础篇</a></li>
<li><a href="https://juejin.cn/post/7504545616841965583" target="_blank" title="https://juejin.cn/post/7504545616841965583">2025前端面试题-React进阶篇</a></li>
<li><a href="https://juejin.cn/post/7504926961627054099" target="_blank" title="https://juejin.cn/post/7504926961627054099">2025前端面试题-React高阶篇</a></li>
</ul>
<h2 data-id="heading-0">Vue进阶</h2>
<h3 data-id="heading-1">一、keep-alive</h3>
<h4 data-id="heading-2">1.核心作用和使用场景</h4>
<h5 data-id="heading-3">1.作用</h5>
<ul>
<li><strong>缓存组件实例</strong>：避免重复销毁和创建，保留组件状态（如<code>DOM结构、响应式数据、事件监听</code>）</li>
<li><strong>提升性能</strong>：适用于需要频繁切换但状态需保留的组件（如<code>Tab页、表单填写页</code>）</li>
</ul>
<h5 data-id="heading-4">2.使用方式</h5>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"['ComponentA', 'ComponentB']"</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">"5"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-5">2.生命周期钩子变化</h4>
<ul>
<li>新增钩子（仅在被缓存的组件中触发）
<ul>
<li><strong>onActivated</strong>：组件被激活（插入DOM）时触发。</li>
<li><strong>onDeactivated</strong>：组件被停用（移除DOM）时触发</li>
</ul>
</li>
<li>执行顺序:
<ul>
<li><strong>首次加载</strong>：<code>onCreate-&gt;onMounted-&gt;onActivated</code></li>
<li><strong>切换离开</strong>：<code>onDeactivated</code></li>
<li><strong>再次进入</strong>：<code>onActivated</code></li>
<li><strong>彻底销毁</strong>：<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h4 data-id="heading-6">3.关键配置属性</h4>
<h5 data-id="heading-7">1.include</h5>
<ul>
<li>匹配<strong>组件名称</strong>（name选项），仅缓存匹配的组件</li>
<li>支持字符串、正则、数组</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;!-- 缓存以 <span class="hljs-string">"Test"</span> 开头的组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"/^Test/"</span>&gt;</span>  
</span></code></pre>
<h5 data-id="heading-8">2.exclude</h5>
<ul>
<li>排除指定组件，优先级高于include</li>
</ul>
<h5 data-id="heading-9">3.max</h5>
<ul>
<li>最大缓存实例数，超出时按LRU（最近最少使用）策略淘汰旧实例</li>
<li>LUR原理：有限淘汰最久未访问的实例</li>
</ul>
<h4 data-id="heading-10">4.高频面试题</h4>
<h5 data-id="heading-11">1.keep-alive实现原理</h5>
<ul>
<li><strong>缓存机制</strong>：通过Map或Object缓存组件vnode实例，渲染时直接从缓存中取</li>
<li><strong>DOM处理</strong>：
<ol>
<li><strong>该组件实例对应的整个 DOM 树会被从真实的文档流 (DOM tree) 中完全移除 (<code>detached</code>)</strong> 。这就是为什么在页面检查器里看不到它的 DOM 了。</li>
<li>当这个组件再次被激活时，<code>keep-alive</code>&nbsp;会从缓存中找到这个实例，<strong>直接复用这个组件实例</strong>（保留所有状态），并<strong>将它对应的 DOM 树重新插入 (<code>attached</code>) 到文档流中</strong>。</li>
</ol>
</li>
</ul>
<h5 data-id="heading-12">2.如何动态控制组件缓存</h5>
<ul>
<li><strong>方案1</strong>：绑定动态include/exclude（响应式变量）</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;keep-alive :include=<span class="hljs-string">"cachedComponents"</span>&gt;
</code></pre>
<ul>
<li><strong>方案2</strong>：通过key强制重新渲染（改变key会销毁旧实例）</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;component :is=<span class="hljs-string">"currentComponent"</span> :key=<span class="hljs-string">"componentKey"</span>&gt;
</code></pre>
<h5 data-id="heading-13">3.keep-alive如何结合路由使用</h5>
<ul>
<li><strong>搭配router-view</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;router-view v-slot=<span class="hljs-string">"{ Component }"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"Component"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"$route.meta.keepAlive"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"Component"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!$route.meta.keepAlive"</span> /&gt;</span></span>
&lt;/router-view&gt;
</code></pre>
<ul>
<li><strong>路由配置</strong>：通过meta字段标记需缓存的页面</li>
</ul>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>, <span class="hljs-attr">meta</span>: { <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> } }
</code></pre>
<h5 data-id="heading-14">4.缓存组件如何更新数据</h5>
<ul>
<li><strong>onActivated中刷新数据</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">onActivated</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 重新请求数据</span>
});
</code></pre>
<h5 data-id="heading-15">5.max属性的作用及淘汰策略</h5>
<ul>
<li><strong>作用</strong>：避免内存无限增长，限制最大缓存实例</li>
<li><strong>淘汰策略</strong>：LRU（最近最少使用），优先移除最久未被访问的实例</li>
</ul>
<h4 data-id="heading-16">5.注意事项</h4>
<ol>
<li><strong>组件必须设置name选项</strong>：否则include/exclude无法匹配</li>
<li><strong>避免内存泄漏</strong>：及时清理不需要缓存的组件（如通过max或动态include）</li>
<li><strong>SSR不兼容</strong>：keep-alive仅在客户端渲染中生效</li>
<li><strong>缓存组件的状态保留</strong>：表单内容等会被保留，需手动重置或通过key强制更新</li>
</ol>
<h4 data-id="heading-17">6.实战实例</h4>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggleComponent"</span>&gt;</span>切换组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"cachedComponents"</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">"3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentComponent"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"currentComponent"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA.vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentB.vue'</span>;

<span class="hljs-keyword">const</span> currentComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'ComponentA'</span>);
<span class="hljs-keyword">const</span> cachedComponents = <span class="hljs-title function_">ref</span>([<span class="hljs-string">'ComponentA'</span>, <span class="hljs-string">'ComponentB'</span>]);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleComponent</span> = (<span class="hljs-params"></span>) =&gt; {
  currentComponent.<span class="hljs-property">value</span> = currentComponent.<span class="hljs-property">value</span> === <span class="hljs-string">'ComponentA'</span> ? <span class="hljs-string">'ComponentB'</span> : <span class="hljs-string">'ComponentA'</span>;
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-18">二、异步组件</h3>
<h4 data-id="heading-19">1.核心概念与使用方式</h4>
<h5 data-id="heading-20">1.定义异步组件</h5>
<ul>
<li><code>defineAsyncComponent</code>函数（Vue3推荐方式）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncCom</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./MyComponent.vue'</span>));
</code></pre>
<ul>
<li>动态<code>import()</code>语法（结合构建工具如Webpack/Vite实现代码分割）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./MyComponent.vue'</span>),
    <span class="hljs-attr">loadingComponent</span>: loadingSpinner,  <span class="hljs-comment">// 加载中组件</span>
    <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorDisplay</span>,      <span class="hljs-comment">// 错误组件</span>
    <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span>,                       <span class="hljs-comment">// 延迟显示loading（防闪烁）</span>
    timeout,                           <span class="hljs-comment">// 超时时间        </span>
})
</code></pre>
<h5 data-id="heading-21">2.Suspense组件</h5>
<ul>
<li>统一管理异步组件（如异步组件或异步setup函数）：</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComp</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-22">2.高频面试题</h4>
<h5 data-id="heading-23">1.异步组件的核心作用</h5>
<ul>
<li><strong>按需加载</strong>：减少初始包体积，提升首屏加载速度</li>
<li><strong>性能优化</strong>：结合代码分割（<code>Code Spliting</code>）动态加载非关键组件</li>
</ul>
<h5 data-id="heading-24">2.如何配置异步组件的加载状态和错误处理？</h5>
<ul>
<li><code>loadingComponent</code>：显示加载中的UI（如loading动画）</li>
<li><code>errorComponent</code>：加载失败时显示错误提示</li>
<li><code>delay</code>：延迟显示loading组件，避免快速加载时闪烁</li>
<li><code>timeout</code>：超时后触发错误组件</li>
</ul>
<h5 data-id="heading-25">3.Suspense和异步组件的关系</h5>
<ul>
<li><strong>Suspense</strong>：内置组件，用于统一管理异步组件的加载状态（如多个异步组件并行加载）</li>
<li><strong>异步组件</strong>：通过<code>defineAsyncComponent</code>定义，由<code>Suspense</code>控制占位内容</li>
</ul>
<h5 data-id="heading-26">4.如何实现组件加载失败后的重试逻辑</h5>
<ul>
<li><strong>工厂函数返回Promise</strong>：在loader中捕获错误并重试</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Async</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./MyComponent.vue'</span>)
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// 重试逻辑</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">retryImport</span>();
        })
})
</code></pre>
<h5 data-id="heading-27">5.异步组件在路由懒加载中的应用</h5>
<ul>
<li><strong>Vue Router配置</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
    <span class="hljs-attr">route</span>: [{
        <span class="hljs-attr">path</span>: <span class="hljs-string">'/profile'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Profile.vue'</span>); <span class="hljs-comment">// 直接动态导入</span>
        <span class="hljs-comment">// 或使用defineAsyncComponent</span>
        <span class="hljs-attr">component</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Profile.vue'</span>)) 
    }]
})
</code></pre>
<h5 data-id="heading-28">6.Vue3异步组件与Vue2的差异</h5>
<ul>
<li><strong>语法差异</strong>：Vue3废弃<code>Vue.component('async-comp',() =&gt; import(...))</code>，改用<code>defineAsyncComponent</code></li>
<li><strong>功能增强</strong>：Vue3支持更细颗粒度的加载状态管理和<code>Suspense</code>集成</li>
</ul>
<h4 data-id="heading-29">3.底层原理优化</h4>
<h5 data-id="heading-30">1.代码分割原理</h5>
<ul>
<li><strong>构建工具</strong>（如webpack）将动态<code>import()</code>的模块拆分为独立<code>chunk</code>，运行时<strong>按需加载</strong></li>
</ul>
<h5 data-id="heading-31">2.异步组件生命周期</h5>
<ul>
<li><strong>加载阶段</strong>：触发loader -&gt; 下载loader -&gt; 初始化组件</li>
<li><strong>缓存机制</strong>：已加载的组件实例会被缓存，避免重复加载</li>
</ul>
<h5 data-id="heading-32">3.性能优化策略</h5>
<ul>
<li><strong>预加载（prefetch）</strong>：通过Webpack魔法注释标记非关键资源</li>
</ul>
<pre><code class="hljs language-js" lang="js">() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">'./MyComponent.vue'</span>)
</code></pre>
<ul>
<li><strong>懒加载阈值</strong>：结合路由或用户行为预测延迟加载组件</li>
</ul>
<h4 data-id="heading-33">4.注意事项</h4>
<ol>
<li><strong>组件命名</strong>：异步组件需显式申明<code>name</code>选项，以便调试和k<code>eep-alive</code>匹配</li>
<li><strong>SSR限制</strong>：异步组件在服务端渲染中需特殊处理（如占位内容）</li>
<li><strong>错误边界</strong>：结合<code>onErrorCaptured</code>全局捕获异步组件错误</li>
<li><strong>过度分割</strong>：避免过多小模块导致HTML请求激增</li>
</ol>
<h4 data-id="heading-34">5.实战代码实例</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 异步组件定义</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncModal</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
    <span class="hljs-attr">lodaer</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Modal.vue'</span>).<span class="hljs-title function_">catch</span>((err) ==&gt; {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'加载失败，3s后重试...'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">import</span>(<span class="hljs-string">'./Modal.vue'</span>)), <span class="hljs-number">3000</span>);
        })
    }),
    <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingSpainner</span>,
    <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>
});
<span class="hljs-comment">// 在组合式API中使用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> showModal = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> { showModal, <span class="hljs-title class_">AsyncModal</span> };
    }
}
</code></pre>
<h4 data-id="heading-35">6.应用场景</h4>
<ol>
<li><strong>大型应用模块懒加载</strong>：如管理后台的复杂表单/图表组件</li>
<li><strong>条件渲染组件</strong>：用户交互后才加载的非必要组件（如弹窗）</li>
<li><strong>路由级懒加载</strong>：结合Vue Router提升首屏性能</li>
</ol>
<h3 data-id="heading-36">三、Vue-Router</h3>
<h4 data-id="heading-37">1.Vue-Router 4.X核心变化</h4>
<h5 data-id="heading-38">1.创建路由实例</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),  <span class="hljs-comment">// 或 createWebHashHistory</span>
    <span class="hljs-attr">routes</span>: [...]
});
</code></pre>
<h5 data-id="heading-39">2.组合式API支持</h5>
<ul>
<li><strong>useRouter()</strong>：获取路由实例（替代<code>this.$router</code>）</li>
<li><strong>useRoute()</strong>：获取当前路由对象（替代<code>this.$route</code>）</li>
</ul>
<h4 data-id="heading-40">2.路由配置与核心概念</h4>
<h5 data-id="heading-41">1.动态路由</h5>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> };
<span class="hljs-comment">// 获取参数：route.params.id</span>
</code></pre>
<h5 data-id="heading-42">2.嵌套路由</h5>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/parent'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Parent</span>,
    <span class="hljs-attr">children</span>: [
        { <span class="hljs-attr">path</span>: <span class="hljs-string">'child'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Child</span> }
    ]
}
</code></pre>
<h5 data-id="heading-43">3.命名路由与编程式导航</h5>
<pre><code class="hljs language-js" lang="js">router.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">params</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } });
</code></pre>
<h5 data-id="heading-44">4.路由模式</h5>
<ul>
<li><code>createWebHistory()</code>：History模式（需服务器支持）</li>
<li><code>createWebHashHistory()</code>：Hash模式</li>
<li><code>createMemoryHistory()</code>：SSR或测试环境</li>
</ul>
<h5 data-id="heading-45">5.重定向与别名</h5>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/'</span> }
{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">alias</span>: <span class="hljs-string">'home'</span> }
</code></pre>
<h4 data-id="heading-46">3.导航守卫</h4>
<h5 data-id="heading-47">1.全局守卫</h5>
<ul>
<li><code>router.beforeEach((to, from, next) =&gt; { ... })</code></li>
<li><code>router.afterEach((to, from) =&gt; { ... })</code></li>
<li><code>router.beforeResolve()</code></li>
</ul>
<h5 data-id="heading-48">2.路由独享守卫</h5>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Admin</span>,
    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> { ... }
}
</code></pre>
<h5 data-id="heading-49">3.组件内守卫</h5>
<ul>
<li><code>onBeforeRouteUpdate</code>：路由参数变化</li>
<li><code>onBeforeRouteLeave</code>：离开组件前</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { onBeforeRouteLeave } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">onBeforeRouteLeave</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
            <span class="hljs-comment">// 清理逻辑</span>
            <span class="hljs-title function_">next</span>();
        });
    }
};
</code></pre>
<h4 data-id="heading-50">4.高级特性与最佳实践</h4>
<h5 data-id="heading-51">1.路由懒加载</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">User</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./User.vue'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./User.vue'</span>));
</code></pre>
<h5 data-id="heading-52">2.路由元信息（meta）</h5>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/profile'</span>, <span class="hljs-attr">meta</span>: { <span class="hljs-attr">requireAuth</span>: <span class="hljs-literal">true</span> } }
<span class="hljs-comment">// 在导航守卫中访问：to.meta.requiresAuth</span>
</code></pre>
<h5 data-id="heading-53">3.动态路由</h5>
<ul>
<li><strong>添加路由</strong>：<code>router.addRoute({ path: '/new', component: New })</code></li>
<li><strong>删除路由</strong>：<code>router.removeRoute('route-name')</code></li>
</ul>
<h5 data-id="heading-54">4.路由组件传参</h5>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> }
<span class="hljs-comment">// 组件通过props：['id'] 接收</span>
</code></pre>
<h5 data-id="heading-55">5.滚动行为控制</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
    <span class="hljs-title function_">scrollBehavior</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, savedPosition</span>) {
        <span class="hljs-keyword">return</span> savedBehavior || { <span class="hljs-attr">top</span>: <span class="hljs-number">0</span> };
    }
});
</code></pre>
<h4 data-id="heading-56">5.高频面试题</h4>
<h5 data-id="heading-57">1.Vue-Router 4.X 与 3.X 的主要区别</h5>
<ul>
<li>API命名调整（如<code>new VueRouter() -&gt; createRouter()</code>）</li>
<li>组合式API支持（<code>useRouter/useRoute</code>）</li>
<li>动态路由API优化（<code>addRoute/removeRoute</code>）</li>
</ul>
<h5 data-id="heading-58">2.如何实现路由权限控制</h5>
<ul>
<li><strong>全局守卫 + 元信息</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">requireAuth</span> &amp;&amp; !isAuthenticated) <span class="hljs-title function_">next</span>(<span class="hljs-string">'/login'</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-title function_">next</span>();
});
</code></pre>
<h5 data-id="heading-59">3.如何处理动态路由加载顺序问题</h5>
<ul>
<li><code>router.isReady()</code>：确保初始路由解析完成再挂载应用</li>
</ul>
<pre><code class="hljs language-js" lang="js">router.<span class="hljs-title function_">isReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>));
</code></pre>
<h5 data-id="heading-60">4.如何捕获导航错误</h5>
<pre><code class="hljs language-js" lang="js">router.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'导航错误'</span>, error);
});
</code></pre>
<h5 data-id="heading-61">5.路由组件如何复用并响应参数变化</h5>
<ul>
<li><code>onBeforeRouteUpdate</code>：监听路由参数变化</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">onBeforeRouteUpdate</span>(<span class="hljs-function">(<span class="hljs-params">to, form, next</span>) =&gt;</span> {
    <span class="hljs-title function_">fetchData</span>(to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);
    <span class="hljs-title function_">next</span>();
})
</code></pre>
<h4 data-id="heading-62">6.实战场景示例</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 动态添加路由（权限控制）</span>
<span class="hljs-keyword">const</span> dynamicRoutes = [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Admin</span>, <span class="hljs-attr">meta</span>: { <span class="hljs-attr">role</span>: <span class="hljs-string">'admin'</span> } }
];
<span class="hljs-keyword">if</span> (user.<span class="hljs-property">role</span> === <span class="hljs-string">'admin'</span>) {
    dynamicRoutes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> router.<span class="hljs-title function_">addRoute</span>(route));
}
<span class="hljs-comment">// 路由懒加载与预加载（webpack魔法注释）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">'./Home.vue'</span> );
</code></pre>
<h4 data-id="heading-63">7.注意事项</h4>
<ol>
<li><strong>this.$router的兼容性</strong>：选项式API中仍可用，组合式API推荐useRouter</li>
<li><strong>SSR适配</strong>：需使用createMemoryHistory并处理客户端激活</li>
<li><strong>路由命名冲突</strong>：动态路由添加时注意避免重复路径或名称</li>
<li><strong>导航守卫异步处理</strong>：确保调用next()或返回Promise</li>
</ol>
<h3 data-id="heading-64">四、状态管理</h3>
<h4 data-id="heading-65">1、Vuex</h4>
<h5 data-id="heading-66">1.Vuex核心概念与工作流程</h5>
<p><strong>1.核心角色</strong></p>
<ul>
<li><code>State</code>：单一状态树，存储全局数据（响应式）</li>
<li><code>Getter</code>：基于State派生的计算属性（类似组件的computed）</li>
<li><code>Mutation</code>：同步修改State的唯一途径（通过commit触发）</li>
<li><code>Action</code>：处理异步操作，提交Mutations（通过dispatch触发）</li>
<li><code>Modules</code>：模块化拆分复杂Store
<strong>2.工作流程</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js">组件 -&gt; <span class="hljs-title function_">dispatch</span>(<span class="hljs-title class_">Action</span>) -&gt; <span class="hljs-title class_">Action</span> -&gt; <span class="hljs-title function_">commit</span>(<span class="hljs-title class_">Mutation</span>) -&gt; <span class="hljs-title class_">Mutation</span> -&gt; 修改<span class="hljs-title class_">State</span> -&gt; 更新视图
</code></pre>
<p><strong>3.Vue4.x对Vue3的支持</strong></p>
<ul>
<li>兼容Vue3的<code>Composition API</code>，但核心API与Vuex 3.x一致</li>
<li>通过<code>useStore</code>替代<code>this.$store</code>（组合式API中）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();
        <span class="hljs-keyword">return</span> { store };
    }
};
</code></pre>
<h5 data-id="heading-67">2.核心API与使用</h5>
<p><strong>1.定义Store</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({
    <span class="hljs-attr">state</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },
    <span class="hljs-attr">mutation</span>: {
        <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) { state.<span class="hljs-property">count</span>++; }
    },
    <span class="hljs-attr">actions</span>: {
        <span class="hljs-title function_">asyncIncrement</span>(<span class="hljs-params">{ commit }</span>) {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">commit</span>(<span class="hljs-string">'increment'</span>), <span class="hljs-number">1000</span>);
        }
    },
    <span class="hljs-attr">getters</span>: {
        <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>
    }
});
</code></pre>
<p><strong>2.组件中访问Store</strong></p>
<ul>
<li><strong>选项式API</strong>：<code>this.$store.state.count</code>或<code>mapState/mapGetters</code>辅助函数</li>
<li><strong>组合式API</strong>：<code>const store = useStore(); store.state.count;</code></li>
</ul>
<p><strong>3.辅助函数</strong></p>
<ul>
<li><code>mapState / mapGetters</code>：映射到计算属性</li>
<li>mapMutation / MapActions：映射到方法</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { mapState, mapGetters, mapMutations, mapActions } <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">computed</span>: {
        ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">'count'</span>]),
        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">'doubleCount'</span>])
    },
    <span class="hljs-attr">methods</span>: {
        ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">'increment'</span>]),
        ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">'asyncIncrement'</span>])
    }
};
</code></pre>
<h5 data-id="heading-68">3.模块化与命名空间</h5>
<p><strong>1.模块定义</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> moduleA = {
    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用命名空间</span>
    <span class="hljs-attr">state</span>: { ... },
    <span class="hljs-attr">mutation</span>: { ... },
    <span class="hljs-attr">action</span>: { ... }
};
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({
    <span class="hljs-attr">modules</span>: { <span class="hljs-attr">a</span>: moduleA }
});
</code></pre>
<p><strong>2.命名空间访问</strong></p>
<ul>
<li><strong>直接访问</strong>：<code>store.state.a.moduleData</code></li>
<li><strong>辅助函数</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js">...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">'a'</span>,[<span class="hljs-string">'moduleAction'</span>]),
<span class="hljs-comment">// 或通过createNamespacedHelpers</span>
<span class="hljs-keyword">const</span> { mapActions } = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">'a'</span>);
</code></pre>
<p><strong>3.模块的局部上下文</strong></p>
<ul>
<li><strong>Root State</strong>：在模块的Action中通过rootState访问全局状态</li>
<li><strong>Root Commit</strong>：在模块Actions中通过<code>{ root: true }</code>提交全局Mutation</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">actions</span>: {
    <span class="hljs-title function_">localAction</span>(<span class="hljs-params">{ commit, dispatch, rootState }</span>) {
        <span class="hljs-title function_">commit</span>(<span class="hljs-string">'localMutation'</span>);
        <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">'gloabalAction'</span>, <span class="hljs-literal">null</span>, { <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> });
    }
}
</code></pre>
<h5 data-id="heading-69">4.高级特性与最佳实践</h5>
<p><strong>1.严格模式</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({ <span class="hljs-attr">strict</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// 直接修改state会抛出错误（仅限开发环境）</span>
</code></pre>
<p><strong>2.插件开发</strong></p>
<ul>
<li><strong>订阅Mutations</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js">store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Mutation:'</span>, mutation.<span class="hljs-property">type</span>);
});
</code></pre>
<ul>
<li><strong>持久化插件</strong>（如结合localStorage）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">persistPlugin</span> = (<span class="hljs-params">store</span>) =&gt; {
    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'vuex-state'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state));
    });
};
</code></pre>
<p><strong>3.动态注册模块</strong></p>
<pre><code class="hljs language-js" lang="js">store.<span class="hljs-title function_">registerModule</span>(<span class="hljs-string">'dynamicModule'</span>, { ... });
store.<span class="hljs-title function_">unregisterModule</span>(<span class="hljs-string">'dynamicModule'</span>, { ... });
</code></pre>
<h5 data-id="heading-70">5.高频面试题</h5>
<p><strong>1. Vuex与pinia的区别</strong></p>
<ul>
<li>Pinia是Vue官方推荐的新状态管理库，支持Composition API和TypeScript</li>
<li><strong>核心差异</strong>：
<ul>
<li>Pinia无mutations，直接通过actions修改状态（同步/异步均可）</li>
<li>Pinia基于模块化设计（每个Store独立），无需嵌套模块</li>
<li>更简洁的API和TypeScript支持</li>
</ul>
</li>
</ul>
<p><strong>2. 为什么需要Mutations处理同步，Actions处理异步？</strong></p>
<ul>
<li><strong>调试工具追踪</strong>：确保状态变化的同步记录可追踪</li>
<li><strong>数据可预测性</strong>：避免异步操作导致状态变更顺序混乱</li>
</ul>
<p><strong>3. Vuex如何实现响应式？</strong></p>
<ul>
<li>底层通过Vue的响应式系统（reactive）实现state的依赖收集和更新触发</li>
</ul>
<p><strong>4. 如何避免模块命名冲突</strong></p>
<ul>
<li>使用namespaced: true隔离模块，通过命名空间访问状态和方法</li>
</ul>
<p><strong>5. 大型项目如何优化Vuex使用？</strong></p>
<ul>
<li>按功能拆分为模块，结合动态加载（<code>registerModule</code>）</li>
<li>使用<code>Getter</code>封装复杂状态逻辑</li>
</ul>
<h5 data-id="heading-71">6.实战使用场景</h5>
<p><strong>1.模块化与命名空间</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// user模块</span>
<span class="hljs-keyword">const</span> userModel = {
    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">state</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> },
    <span class="hljs-attr">mutations</span>:{
        <span class="hljs-title function_">setName</span>(<span class="hljs-params">state, name</span>) {
            state.<span class="hljs-property">name</span> = name;
        }
    }
};
<span class="hljs-comment">// 组件中调用</span>
methods：{
    ...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">'user'</span>, [<span class="hljs-string">'setName'</span>]);
}
</code></pre>
<p><strong>2.状态持久化插件</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> persistedState = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'vuex-state'</span>);
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({
    <span class="hljs-attr">state</span>: persistedState ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(persistedState) : {}m
    <span class="hljs-attr">plugins</span>: [persistPlugin],
});
</code></pre>
<h5 data-id="heading-72">7.注意事项</h5>
<ol>
<li><strong>避免直接修改State</strong>：必须通过<code>commit</code>或<code>dispatch</code>触发变更。</li>
<li><strong>模块复用</strong>：动态注册模块时需要注意生命周期管理（如路由切换时卸载）</li>
<li><strong>性能优化</strong>：避免在<code>Getters</code>中执行高开销计算，使用缓存或拆分逻辑</li>
<li><strong>TypeScript支持</strong>：Vuex4对TS支持较弱，推荐使用<code>pinia</code>替代</li>
</ol>
<h4 data-id="heading-73">2、Pinia</h4>
<h5 data-id="heading-74">1.Pinia核心概念与优势</h5>
<p><strong>1. Pinia是什么？</strong></p>
<ul>
<li>Vue官方推荐的新一代<strong>状态管理库</strong>，替代Vuex，专为Vue3设计，全面支持<code>Composition API</code>和<code>TypeScript</code></li>
<li>核心特点：简洁API、去除了<code>Mutations</code>、模块化天然支持、极致<code>TypeScript</code>友好</li>
</ul>
<p><strong>2. 核心优势（对比Vuex）</strong></p>
<ul>
<li><strong>无Mutations</strong>：直接通过<code>Actions</code>处理同步/异步逻辑</li>
<li><strong>扁平化结构</strong>：多个<code>Store</code>代替嵌套模块，更易维护</li>
<li><strong>TypeScript支持</strong>：自动推导类型，无需额外配置</li>
<li><strong>Devtools集成</strong>：支持时间旅行调试和状态快照</li>
<li><strong>轻量高效</strong>：体积更小，API更简洁</li>
</ul>
<h5 data-id="heading-75">2.核心API与基本使用</h5>
<p><strong>1. 定义Store</strong></p>
<ul>
<li>Options Store（类似Vue选项式API）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// stores/counters.ts</span>
<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'counter'</span>, {
    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }),
    <span class="hljs-attr">getters</span>: {
        <span class="hljs-attr">doubleCount</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>,
    },
    <span class="hljs-attr">actions</span>: {
        <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 直接修改状态</span>
        },
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncIncrement</span>(<span class="hljs-params"></span>) {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">increment</span>(), <span class="hljs-number">1000</span>);
        },
    },
});
</code></pre>
<ul>
<li>Setup Store（类似Composition API）:</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Alice'</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setName</span> = (<span class="hljs-params">newName: string</span>) =&gt; { name.<span class="hljs-property">value</span> = newName; };
    <span class="hljs-keyword">return</span> { name, setName };
})
</code></pre>
<p><strong>2. 在组件中使用Store</strong></p>
<pre><code class="hljs language-js" lang="js">&lt;script&gt;
<span class="hljs-keyword">import</span> { useCounterStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/counter'</span>;
<span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>();
&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ counterStore.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"counterStore.increment()"</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h5 data-id="heading-76">3.核心特性</h5>
<p><strong>1. State</strong></p>
<ul>
<li><strong>响应式状态</strong>：通过<code>ref或reactive</code>实现，直接修改自动触发更新</li>
<li><strong>重置状态</strong>：<code>counterStore.$reset()</code></li>
<li><strong>批量更新</strong>：<code>counterStore.$patch({ count: 10 })</code></li>
</ul>
<p><strong>2. Getters</strong></p>
<ul>
<li>类似Vue的computed，<strong>自动缓存结果</strong></li>
<li>支持<strong>访问其他Store</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">getters</span>: {
    <span class="hljs-title function_">combinedInfo</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${userStore.name}</span>: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.doubleCount}</span>`</span>;
    }
}
</code></pre>
<p><strong>3. Actions</strong></p>
<ul>
<li><strong>同步/异步均可</strong>：无需区分Mutation和Action</li>
<li><strong>支持相互调用</strong>：通过this访问其他Actions</li>
<li><strong>订阅Actions</strong>:</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> unsubscribe = counterStore.$onAction({ name, after, args }) =&gt; {
    <span class="hljs-title function_">after</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${name}</span> 执行完成，参数：<span class="hljs-subst">${args}</span>`</span>));
}
</code></pre>
<h5 data-id="heading-77">4.模块化组合</h5>
<p><strong>1. 模块化设计</strong></p>
<ul>
<li>通过<strong>多个Store文件</strong>天然实现模块化，无需嵌套结构</li>
<li>跨Store调用：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// store/user.ts</span>
<span class="hljs-keyword">import</span> { useCounterStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'./counter'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, {
    <span class="hljs-attr">actions</span>: {
        <span class="hljs-title function_">asyncWithCounter</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>();
            counterStore.<span class="hljs-title function_">increment</span>();
        },
    },
});
</code></pre>
<p><strong>2. 动态添加Store</strong></p>
<ul>
<li>无需显示注册，按需引入即可（天然支持代码分割）</li>
</ul>
<h5 data-id="heading-78">5.插件与高级用法</h5>
<p><strong>1. 插件机制</strong></p>
<ul>
<li><strong>自定义插件</strong>（如持久化存储）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">persistPlugin</span> = (<span class="hljs-params">{ store }</span>) =&gt; {
    <span class="hljs-keyword">const</span> savedState = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(store.<span class="hljs-property">$id</span>);
    <span class="hljs-keyword">if</span>(savedState){
        store.$patch(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(savedState));
    }
    store.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(store.<span class="hljs-property">$id</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state));
    });
};
</code></pre>
<ul>
<li><strong>注册插件</strong>：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createPinia } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>;
<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">createPinia</span>().<span class="hljs-title function_">use</span>(persistPlugin);
</code></pre>
<p><strong>2. Devtools支持</strong></p>
<ul>
<li>默认集成Vue DevTools，可追踪状态变化和Actions调用</li>
</ul>
<h5 data-id="heading-79">6.高频面试题</h5>
<p><strong>1. 为什么选择Pinia而不是Vuex？</strong></p>
<ul>
<li><strong>API简洁</strong>：去除了Mutation，减少心智负担</li>
<li><strong>TypeScript友好</strong>：自动类型推导，无需复杂配置</li>
<li><strong>模块化更自然</strong>：多个Store代替嵌套模块，结构清晰</li>
</ul>
<p><strong>2. Pinia如何处理异步操作？</strong></p>
<ul>
<li>直接在<code>Actions</code>中写异步逻辑（如<code>async/await</code>），无需额外步骤</li>
</ul>
<p><strong>3. Pinia如何实现响应式？</strong></p>
<ul>
<li>底层基于Vue3的<code>reactive和ref</code>，保证状态变更自动触发更新</li>
</ul>
<p><strong>4. 如何实现状态持久化？</strong></p>
<ul>
<li>通过插件拦截<code>$subscribe</code>或<code>$onAction</code>，结合<code>localStorage</code></li>
</ul>
<p><strong>5. Pinia如何支持TypeScript？</strong></p>
<ul>
<li>Store定义自动推导类型，组件中通过<code>store.xxx</code>直接获得类型提示</li>
</ul>
<h5 data-id="heading-80">7.实战场景示例</h5>
<p><strong>1. 用户认证状态管理</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// store/auth.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useAuthStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'auth'</span>, {
    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">token</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span> }),
    <span class="hljs-attr">actions</span>: {
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: string, password: string</span>) {
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">login</span>(usename,password);
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = res.<span class="hljs-property">token</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = res.<span class="hljs-property">user</span>;
        },
        <span class="hljs-title function_">logout</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">this</span>.$reset();
        },
    },
});
</code></pre>
<p><strong>2. 跨Store组合逻辑</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// store/cart.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCartStore</span>(<span class="hljs-string">'cart'</span>, {
    <span class="hljs-attr">actions</span>: {
        <span class="hljs-title function_">checkout</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">const</span> authStore = <span class="hljs-title function_">useAuthStore</span>();
            <span class="hljs-keyword">if</span>(authStore.<span class="hljs-property">user</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请先登录'</span>);
            <span class="hljs-comment">// 调用订单接口...</span>
        },
    },
});
</code></pre>
<h5 data-id="heading-81">8.注意事项</h5>
<ol>
<li><strong>避免直接修改Store实例</strong>：使用Actions或$patch确保状态变更</li>
<li><strong>性能优化</strong>：拆分高频变更状态到独立Store，减少渲染影响</li>
<li><strong>合理设计Store</strong>：按业务功能划分Store，避免单一Store过于臃肿</li>
<li><strong>TypeScript最佳实践</strong>：明确标注类型（如<code>state：() =&gt; ({ count: 0 as number })</code>）</li>
</ol>
<h3 data-id="heading-82">五、性能优化</h3>
<h4 data-id="heading-83">1.Vue3核心优化机制</h4>
<h5 data-id="heading-84">1.响应式系统升级</h5>
<ul>
<li>基于<code>Proxy</code>替代Vue2的<code>Object.defineProperty</code>,支持动态属性添加和数组索引修改的监听</li>
<li><strong>惰性依赖追踪</strong>：仅对实际用到的属性触发更新，减少不必要的渲染</li>
</ul>
<h5 data-id="heading-85">2.编译优化</h5>
<ul>
<li><strong>静态提升</strong>：将静态节点（无动态绑定的元素）提升到渲染函数外，避免重复创建</li>
<li><strong>补丁标志</strong>：在虚拟DOM中标记动态绑定的类型（如<code>class、style、props</code>），减少Diff对比范围</li>
<li><strong>Block Tree优化</strong>：将模版划分为动态和静态区块，仅追踪动态区块的变化</li>
<li><strong>缓存事件处理程序</strong>：如<code>@click</code>的时间处理函数会被缓存，避免重复生成</li>
</ul>
<h4 data-id="heading-86">2.组件级优化策略</h4>
<h5 data-id="heading-87">1.渲染控制</h5>
<ul>
<li><code>v-once</code>：静态内容只渲染一次</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;div v-once&gt;永不更新的内容&lt;/div&gt;
</code></pre>
<p>-<code> v-memo</code>（Vue3.2+）：依赖不变时跳过更新</p>
<pre><code class="hljs language-js" lang="js">&lt;div v-memo=<span class="hljs-string">"[value]"</span>&gt;{{ value }}&lt;/div&gt;  &lt;!-- 仅当value变化时更新 --&gt;
</code></pre>
<ul>
<li><code>v-show</code>：高频切换（CSS显示隐藏）</li>
<li><code>v-if</code>：低频切换（销毁/重建组件）</li>
</ul>
<h5 data-id="heading-88">2.组件设计优化</h5>
<ul>
<li>细粒度拆分：隔离高频更新组件</li>
<li>异步组件：延迟加载非关键组件</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Modal</span> = <span class="hljs-title function_">defineAsyncComponet</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Modal.vue'</span>));
</code></pre>
<h5 data-id="heading-89">3.状态管理优化</h5>
<ul>
<li><code>shallowRef/shalloReactive</code>：非深度响应式数据</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> largeObj = <span class="hljs-title function_">shallowRef</span>({ ... }) <span class="hljs-comment">// 仅.value变化触发更新</span>
</code></pre>
<ul>
<li>避免大型响应式对象：解构为独立ref</li>
<li>使用markRaw跳过响应式转换</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> staticData = <span class="hljs-title function_">markRaw</span>({ ... }) <span class="hljs-comment">// 不转换为响应式</span>
</code></pre>
<h4 data-id="heading-90">3.资源与加载优化</h4>
<h5 data-id="heading-91">1.代码分割</h5>
<ul>
<li>路由级懒加载（<code>Vue Router</code>）</li>
</ul>
<pre><code class="hljs language-js" lang="js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/dashboard'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Dashboard.vue'</span>) }
</code></pre>
<ul>
<li>组件级懒加载（<code>defineAsyncComponent</code>）</li>
<li>第三方库按需加载：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>; <span class="hljs-comment">// 只引入所需函数</span>
</code></pre>
<h5 data-id="heading-92">2.Tree Shaking支持</h5>
<ul>
<li>使用ES模块语法（ESM）</li>
<li>避免副作用代码：</li>
</ul>
<pre><code class="hljs language-js" lang="js">pakage.<span class="hljs-property">json</span> 中标记 <span class="hljs-string">"sideEffects"</span>: <span class="hljs-literal">false</span>
</code></pre>
<h5 data-id="heading-93">3.预加载关键资源</h5>
<pre><code class="hljs language-js" lang="js">&lt;!-- 预加载首屏关键组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"script"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/src/components/Critical.vue"</span>&gt;</span>
</span></code></pre>
<h4 data-id="heading-94">4.运行时性能优化</h4>
<h5 data-id="heading-95">1.列表渲染优化</h5>
<ul>
<li>必须提供key：</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"item in items"</span> :key=<span class="hljs-string">"item.id"</span>&gt;{{ item.<span class="hljs-property">text</span> }}&lt;/li&gt;
</code></pre>
<ul>
<li>虚拟滚动（vue-virtual-scroller）</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">RecycleScroller</span> :items=<span class="hljs-string">"largeList"</span> item-size=<span class="hljs-string">"50"</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">"{ item }"</span>&gt;</span>{{ item.text }}<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">RecycleScroller</span>&gt;
</code></pre>
<ul>
<li>避免v-for与v-if共用（优先用computed过滤数据）</li>
</ul>
<h5 data-id="heading-96">2.计算与侦听优化</h5>
<ul>
<li>computed缓存：替代模板内复杂表达式</li>
<li>避免深度监听大型对象：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">watch</span>(data, callback, { <span class="hljs-attr">deep</span>: <span class="hljs-literal">false</span> }) <span class="hljs-comment">// 默认浅层监听</span>
</code></pre>
<ul>
<li>watchEffect自动依赖追踪：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)) <span class="hljs-comment">// 自动收集依赖</span>
</code></pre>
<h5 data-id="heading-97">3.事件处理优化</h5>
<ul>
<li>高频事件使用防抖/节流</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;
<span class="hljs-attr">methods</span>: { <span class="hljs-attr">search</span>: <span class="hljs-title function_">debounce</span>(fn, <span class="hljs-number">300</span>) }
</code></pre>
<h4 data-id="heading-98">5.架构级优化</h4>
<h5 data-id="heading-99">1.服务端渲染（SSR）</h5>
<ul>
<li>使用Nuxt.js实现</li>
</ul>
<pre><code class="hljs language-js" lang="js">npx nuxi init my-ssr-app
</code></pre>
<ul>
<li>优势：提升首屏加载速度 &amp; SEO</li>
</ul>
<h5 data-id="heading-100">2.静态站点生成（SSG）</h5>
<ul>
<li>使用VitePress/VuePress:</li>
</ul>
<pre><code class="hljs language-js" lang="js">npm init vitepress
</code></pre>
<ul>
<li>预生成静态页面，适合内容型网站</li>
</ul>
<h5 data-id="heading-101">3.CDN与缓存策略</h5>
<ul>
<li>静态资源添加Content Hash：</li>
</ul>
<pre><code class="hljs language-js" lang="js">app.3a88b9e2.<span class="hljs-property">js</span> # 文件名包含hash
</code></pre>
<ul>
<li>设置长期缓存：</li>
</ul>
<pre><code class="hljs language-js" lang="js">location /assets {
    expires 1y;
    add_header <span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span> <span class="hljs-string">"public"</span>;
}
</code></pre>
<h4 data-id="heading-102">6.工具链优化</h4>
<h5 data-id="heading-103">1.现代构建工具</h5>
<ul>
<li>Vite：基于ESM的极速开发体验</li>
</ul>
<pre><code class="hljs language-js" lang="js">npm create vite@lastest
</code></pre>
<ul>
<li>生产构建优化：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">build</span>: {
        <span class="hljs-attr">minify</span>: <span class="hljs-string">'terser'</span>, <span class="hljs-comment">// 代码压缩</span>
        <span class="hljs-attr">brtliSize</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 压缩分析</span>
        <span class="hljs-attr">chunkSizeWarningLimit</span>: <span class="hljs-number">1000</span> <span class="hljs-comment">// 调整块大小警告</span>
    }
}
</code></pre>
<h5 data-id="heading-104">2.性能分析工具</h5>
<ul>
<li><code>Chorme DevTools Performance</code> 面板</li>
<li><code>Vue DevTools</code> 性能追踪</li>
<li><code>Lighthouse</code> 性能评分</li>
</ul>
<pre><code class="hljs language-js" lang="js">lighthouse <span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:5173 --view</span>
</code></pre>
<h4 data-id="heading-105">7.高频面试题</h4>
<h5 data-id="heading-106">1.Vue3比Vue2快在哪里？</h5>
<ul>
<li><strong>响应式</strong>：Proxy替代defineProperty</li>
<li><strong>编译</strong>：Patch Flag/Block Tree减少Diff范围</li>
<li><strong>体积</strong>：Tree Shaking支持更佳</li>
</ul>
<h5 data-id="heading-107">2.如何优化长列表性能？</h5>
<ul>
<li>虚拟滚动 + 唯一key + 避免响应式嵌套</li>
</ul>
<h5 data-id="heading-108">3.v-memo的使用场景</h5>
<ul>
<li>表格行渲染</li>
<li>大型表单字段</li>
<li>重复渲染的子组件</li>
</ul>
<h5 data-id="heading-109">4.什么时候用shallowRef？</h5>
<ul>
<li>大型对象/数组（如1000+条目的列表数据）</li>
</ul>
<h5 data-id="heading-110">5.SSR解决了什么问题？</h5>
<ul>
<li>首屏加载白屏问题</li>
<li>SEO不友好问题</li>
</ul>
<h4 data-id="heading-111">8.实战优化示例</h4>
<h5 data-id="heading-112">1.虚拟滚动实现</h5>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">VirtualList</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">"items"</span> <span class="hljs-attr">:item-size</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"300px"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">"{ item }"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">"item"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">VirtualList</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<h5 data-id="heading-113">2.状态更新批处理</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { nextTick } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchUpdate</span>(<span class="hljs-params"></span>) {
    state.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;
    state.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>() <span class="hljs-comment">// 等待一次更新</span>
    <span class="hljs-comment">// DOM已更新</span>
}
</code></pre>
<h5 data-id="heading-114">3.Web Worker处理CPU密集型任务</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> woker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'./worker.js'</span>);
worker.<span class="hljs-title function_">postMessage</span>(data);
worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> { state.<span class="hljs-property">result</span> = e.<span class="hljs-property">data</span> }
</code></pre>
<h4 data-id="heading-115">9.优化原则总结</h4>
<ol>
<li><strong>量度优先</strong>：用<code>Lighthouse/Vue Devtools</code>定位瓶颈</li>
<li><strong>渐进优化</strong>：优先解决最大性能瓶颈（如长列表/包体积）</li>
<li><strong>平衡之道</strong>：避免过度优化牺牲可维护性</li>
<li><strong>更新策略</strong>：</li>
</ol>

























<table><thead><tr><th>方法</th><th>使用场景</th></tr></thead><tbody><tr><td><code>v-memo</code></td><td>精确控制子组件更新条件</td></tr><tr><td><code>shallowRef</code></td><td>大型非深度响应数据</td></tr><tr><td><code>markRaw</code></td><td>永远不需要响应式的数据</td></tr><tr><td><code>defineAsyncComponent</code></td><td>延迟加载非首屏组件</td></tr></tbody></table>
<h3 data-id="heading-116">六、Vue2和Vue3的区别</h3>
<h4 data-id="heading-117">1.架构设计区别</h4>



































<table><thead><tr><th><strong>特性</strong>​</th><th>​<strong>Vue2</strong>​</th><th>​<strong>Vue3</strong>​</th><th>​<strong>优势</strong>​</th></tr></thead><tbody><tr><td>​<strong>响应式系统</strong>​</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td><td>支持动态属性/数组索引监听，性能更优</td></tr><tr><td>​<strong>代码组织</strong>​</td><td>Options API</td><td>Composition API</td><td>逻辑复用更灵活，类型推导更友好</td></tr><tr><td>​<strong>源码组织</strong>​</td><td>Flow 类型系统</td><td>TypeScript 重写</td><td>更好的类型支持和源码可维护性</td></tr><tr><td>​<strong>包体积</strong>​</td><td>全量引入（22.5kb）</td><td>按需引入（&lt;10kb）</td><td>Tree Shaking 减少 41% 体积</td></tr></tbody></table>
<h4 data-id="heading-118">2.响应式系统升级</h4>
<h5 data-id="heading-119">1.Vue的局限性</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 无法检测动态添加的属性</span>
<span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">'newProp'</span>, value);
<span class="hljs-comment">// 无法监听数组索引发生变化</span>
<span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>, index, value);
</code></pre>
<h5 data-id="heading-120">2.Vue3的Proxy实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, {
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) { <span class="hljs-comment">/* 依赖收集 */</span> }，
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) { <span class="hljs-comment">/* 触发更新 */</span> }
})
</code></pre>
<ul>
<li><strong>优势</strong>
<ul>
<li>支持动态属性增删/数组索引修改</li>
<li>无需初始化深度遍历（惰性依赖追踪）</li>
<li>内存占用减少50%（基于基准测试）</li>
</ul>
</li>
</ul>
<h4 data-id="heading-121">3.Composition API vs Options API</h4>
<h5 data-id="heading-122">1.Options API 痛点</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
        }
    },
    <span class="hljs-attr">methods</span>: { <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {...} },
    <span class="hljs-attr">computed</span>: { <span class="hljs-title function_">double</span>(<span class="hljs-params"></span>) {...} }
}
</code></pre>
<h5 data-id="heading-123">2.Composition API 解决方案</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> double = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>);
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) { count.<span class="hljs-property">value</span>++ }
    <span class="hljs-keyword">return</span> { count, double, increment }; <span class="hljs-comment">// 逻辑聚合</span>
}
</code></pre>
<ul>
<li><strong>核心优势</strong>：
<ul>
<li>逻辑复用（自定义Hook）</li>
<li>更好的TypeScript支持</li>
<li>代码组织更灵活（按功能而非选项）</li>
</ul>
</li>
</ul>
<h4 data-id="heading-124">4.性能优化对比</h4>






























<table><thead><tr><th>​<strong>优化方向</strong>​</th><th>​<strong>Vue2</strong>​</th><th>​<strong>Vue3</strong>​</th></tr></thead><tbody><tr><td>​<strong>编译优化</strong>​</td><td>全量 Diff</td><td>Patch Flags 标记动态节点</td></tr><tr><td>​<strong>静态提升</strong>​</td><td>无</td><td>静态节点提升到渲染函数外部</td></tr><tr><td>​<strong>Tree Shaking</strong>​</td><td>有限支持</td><td>核心 API 可摇树优化</td></tr><tr><td>​<strong>内存占用</strong>​</td><td>较高</td><td>减少 50%（Proxy 惰性依赖）</td></tr></tbody></table>
<p><strong>编译优化示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// Vue3 编译后的Patch Flags (二进制标记)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
        <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">"span"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"静态内容"</span>), <span class="hljs-comment">// 静态节点</span>
        <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">"span"</span>, { <span class="hljs-attr">class</span>: _ctx,dynamicClass }, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* CLASS */</span>)
    ]))
}
</code></pre>
<h4 data-id="heading-125">5.生命周期变化</h4>























































<table><thead><tr><th>​<strong>Vue2</strong>​</th><th>​<strong>Vue3</strong>​ (Composition API)</th><th>​<strong>变化说明</strong>​</th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td><code>setup()</code></td><td>被&nbsp;<code>setup</code>&nbsp;替代</td></tr><tr><td><code>created</code></td><td><code>setup()</code></td><td>被&nbsp;<code>setup</code>&nbsp;替代</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td><td>改名</td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td><td>改名</td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td><td>改名</td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td><td>改名</td></tr><tr><td><code>beforeDestroy</code></td><td><strong><code>onBeforeUnmount</code></strong></td><td>改名（语义更准确）</td></tr><tr><td><code>destroyed</code></td><td><strong><code>onUnmounted</code></strong></td><td>改名（语义更准确）</td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td><td>改名</td></tr></tbody></table>
<p><strong>使用示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { onMounted, onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件挂载'</span>))
    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件卸载'</span>))
  }
}
</code></pre>
<h4 data-id="heading-126">6.新特性与API</h4>
<h5 data-id="heading-127">1.Fragment（碎片）</h5>
<pre><code class="hljs language-js" lang="js">&lt;!-- <span class="hljs-title class_">Vue3</span> 支持多根节点 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h5 data-id="heading-128">2.Teleport（传送门）</h5>
<pre><code class="hljs language-js" lang="js">&lt;teleport to=<span class="hljs-string">"#modal-container"</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal"</span>&gt;</span>模态框内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/teleport&gt;
</code></pre>
<h5 data-id="heading-129">3.Suspense（异步组件）</h5>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">Suspense</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">Suspense</span>&gt;
</code></pre>
<h5 data-id="heading-130">4.自定义渲染器API</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">const</span> { render } = <span class="hljs-title function_">createRenderer</span>({ <span class="hljs-comment">/* 自定义节点操作 */</span> })
</code></pre>
<h4 data-id="heading-131">7.生态与工具链</h4>



































<table><thead><tr><th>​<strong>领域</strong>​</th><th>​<strong>Vue2</strong>​</th><th>​<strong>Vue3</strong>​</th><th>​<strong>说明</strong>​</th></tr></thead><tbody><tr><td>​<strong>官方路由</strong>​</td><td>vue-router 3.x</td><td>vue-router 4.x</td><td>适配 Composition API</td></tr><tr><td>​<strong>状态管理</strong>​</td><td>Vuex 3.x</td><td>Vuex 4.x / ​<strong>Pinia</strong>​</td><td>Pinia 为官方推荐新方案</td></tr><tr><td>​<strong>构建工具</strong>​</td><td>Vue CLI</td><td>​<strong>Vite</strong>​</td><td>Vite 开发速度提升 10 倍+</td></tr><tr><td>​<strong>SSR 框架</strong>​</td><td>Nuxt 2</td><td>Nuxt 3</td><td>全面支持 Vue3 生态</td></tr></tbody></table>
<h4 data-id="heading-132">8.迁移升级攻略</h4>
<h5 data-id="heading-133">1.兼容方案</h5>
<ul>
<li>@vue/compat库提供兼容模式（Vue2行为 + Vue3特性）</li>
<li>逐步替换废弃的API（eventBus -&gt; mitt，Vue.extend -&gt; defineComponent）</li>
</ul>
<h5 data-id="heading-134">2.自动迁移工具</h5>
<pre><code class="hljs language-js" lang="js">npm install -g @vue/compat
vue-cli-service upgrade  # 自动检测并修复部分 <span class="hljs-variable constant_">API</span>
</code></pre>
<h5 data-id="heading-135">3.分步骤迁移</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dde30b3d60184d37b615af359b319469~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRUJfQ29kZXI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755725698&amp;x-signature=PxfmvMVrAsEM6YK8QosCifhTiyU%3D" alt="image.png" loading="lazy"></p>
<h4 data-id="heading-136">9.高频面试题</h4>
<h5 data-id="heading-137">1.为什么Vue3用Proxy替代defineProperty？</h5>
<ul>
<li>解决动态属性/数组监听问题</li>
<li>初始化性能提升（无需递归遍历）</li>
<li>内存占用更低</li>
</ul>
<h5 data-id="heading-138">2.Composition API 解决了什么问题？</h5>
<ul>
<li>逻辑复用困难（Mixins的命名冲突/来源不清）</li>
<li>Options API的逻辑碎片化</li>
<li>TypeScript类型推导支持弱</li>
</ul>
<h5 data-id="heading-139">3.Vue3的模版编译优化有哪些？</h5>
<ul>
<li><code>Patch Flags</code>（动态节点标记）</li>
<li>静态节点提升（减少重复创建）</li>
<li><code>Block Tree</code>（跳过静态子树对比）</li>
</ul>
<h5 data-id="heading-140">4.Vue3对TypeScript的支持改进</h5>
<ul>
<li>源码使用TS重写</li>
<li><code>Composition API</code> 完美支持类型推导</li>
<li><code>defineComponent</code>提供组件类型申明</li>
</ul>
<h5 data-id="heading-141">5.Vue2项目如何升级Vue3？</h5>
<ul>
<li>使用<code>@/vue/compat</code>过渡</li>
<li>逐步替换废弃API（<code>$children,filters</code>等）</li>
<li>优先迁移新组件，逐步重构旧组件</li>
</ul>
<h3 data-id="heading-142">七、SPA</h3>
<h4 data-id="heading-143">1.核心概念</h4>
<h5 data-id="heading-144">1.定义与特点</h5>
<ul>
<li><strong>单页面应用</strong>：整个应用只有一个<code>HTML</code>文件，通过动态替换<code>DOM</code>内容实现"页面"切换</li>
<li><strong>核心优势</strong>：
<ul>
<li>无刷新跳转（流畅用户体验）</li>
<li>前后端分离开发</li>
<li>减轻服务器渲染压力</li>
</ul>
</li>
<li><strong>主要挑战</strong>：
<ul>
<li>首屏加载性能</li>
<li>SEO优化难度</li>
<li>路由管理复杂度</li>
</ul>
</li>
</ul>
<h5 data-id="heading-145">2.SPA与MPA对比</h5>



































<table><thead><tr><th>​<strong>特性</strong>​</th><th>​<strong>SPA</strong>​</th><th>​<strong>MPA (多页面应用)​</strong>​</th></tr></thead><tbody><tr><td>​<strong>页面数量</strong>​</td><td>1 个 HTML</td><td>多个 HTML</td></tr><tr><td>​<strong>页面跳转</strong>​</td><td>前端路由控制，无刷新</td><td>整页刷新</td></tr><tr><td>​<strong>数据请求</strong>​</td><td>Ajax/Fetch 局部获取数据</td><td>每次跳转加载完整页面</td></tr><tr><td>​<strong>开发复杂度</strong>​</td><td>高（需前端路由、状态管理等）</td><td>低</td></tr><tr><td>​<strong>SEO 支持</strong>​</td><td>差（需额外优化）</td><td>优</td></tr></tbody></table>
<h4 data-id="heading-146">2.高频面试题</h4>
<h5 data-id="heading-147">1.SPA首屏加载优化有哪些方案？</h5>
<ul>
<li>路由懒加载 + 组件懒加载</li>
<li>资源预加载/预取</li>
<li>CDN加速静态资源</li>
<li>开启Gzip/Brotli压缩</li>
<li>服务端渲染（SSR）</li>
</ul>
<h5 data-id="heading-148">2.如何解决SPA的SEO问题？</h5>
<ul>
<li>预渲染（Prerender）</li>
<li>服务端渲染（Nustjs）</li>
<li>动态渲染（针对爬虫单独处理）</li>
<li>静态站点生成（SSG）</li>
</ul>
<h5 data-id="heading-149">3.Vue Router的导航守卫执行顺序</h5>
<pre><code class="hljs language-md" lang="md">全局 beforeEach -&gt; 路由 beforeEnter -&gt; 组件 beforeRouteEnter -&gt; 全局 beforeResolve -&gt; 全局 afterEach -&gt; 组件 beforeRouteUpdate
</code></pre>
<h5 data-id="heading-150">4.如何处理权限路由？</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 动态添加路由</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to) =&gt; {
    <span class="hljs-keyword">if</span> (!hasAuthInfo) <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserPermissions</span>();
    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAdmin</span> &amp;&amp; !isAdmin) <span class="hljs-keyword">return</span> <span class="hljs-string">'/no-permission'</span>;
})
</code></pre>
<h5 data-id="heading-151">5.SPA如何保持登录状态？</h5>
<ul>
<li>JWT存储于localStorage + 刷新Token机制</li>
<li>结合HttpOnly Cookie增强安全性</li>
<li>Token过期自动跳转登录页</li>
</ul>
<h3 data-id="heading-152">八、SSR</h3>
<h4 data-id="heading-153">1.SSR核心概念与原理</h4>
<h5 data-id="heading-154">1.服务端渲染 vs 客户端渲染</h5>



































<table><thead><tr><th>​<strong>对比维度</strong>​</th><th>​<strong>SSR</strong>​</th><th>​<strong>CSR (SPA)​</strong>​</th></tr></thead><tbody><tr><td>​<strong>渲染位置</strong>​</td><td>服务端生成完整 HTML</td><td>客户端 JS 动态生成 DOM</td></tr><tr><td>​<strong>首屏时间</strong>​</td><td>快（直接输出 HTML）</td><td>慢（需加载 JS 并执行）</td></tr><tr><td>​<strong>SEO 支持</strong>​</td><td>优（爬虫直接抓取 HTML）</td><td>差（需额外处理）</td></tr><tr><td>​<strong>服务器压力</strong>​</td><td>高（每次请求需渲染）</td><td>低（仅提供静态资源）</td></tr><tr><td>​<strong>开发复杂度</strong>​</td><td>高（需处理同构、服务器环境等）</td><td>低（纯前端开发）</td></tr></tbody></table>
<h5 data-id="heading-155">2.Vue SSR 工作原理</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
浏览器-&gt;&gt;服务器:发送页面请求
服务器-&gt;&gt;Vue 应用: 执行 createSSRApp()
Vue 应用-&gt;&gt;服务器: 渲染组件树生成 HTML
服务器-&gt;&gt;浏览器: 返回包含数据的 HTML
浏览器-&gt;&gt;Vue 应用: 激活(Hydration) 交互
Vue 应用-&gt;&gt;浏览器: 变为可交互 SPA
</code></pre>
<h5 data-id="heading-156">3.关键流程说明</h5>
<ul>
<li><strong>服务端渲染</strong>：<code>renderToString()</code>生成静态HTML</li>
<li><strong>客户端激活</strong>：<code>createSSRApp().mount()</code>接管DOM添加事件</li>
<li><strong>数据预取</strong>：在渲染前获取页面所需数据（避免客户端二次请求）</li>
</ul>
<h4 data-id="heading-157">2.Nuxt.js 3 核心使用</h4>
<h5 data-id="heading-158">1.项目结构与约定</h5>
<pre><code class="hljs language-js" lang="js">├─ .<span class="hljs-property">nuxt</span>/         # 构建生成
├─ components/    # 公共组件
├─ composables/   # 复用逻辑
├─ layouts/       # 布局组件
├─ middleware/    # 路由中间件
├─ pages/         # 自动路由（支持动态路由）
├─ plugins/       # 插件注册
├─ public/        # 静态资源
├─ server/        # <span class="hljs-variable constant_">API</span> 路由
└─ nuxt.<span class="hljs-property">config</span>.<span class="hljs-property">ts</span> # 配置文件
</code></pre>
<h5 data-id="heading-159">2.服务端生命周期</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 服务端异步数据获取</span>
<span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'key'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> $fetch(<span class="hljs-string">'/api/data'</span>)
    <span class="hljs-keyword">return</span> data;
})
<span class="hljs-comment">// 只在服务端执行</span>
<span class="hljs-title function_">onServerPrefetch</span>(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// 预取数据到Store</span>
})
</code></pre>
<h5 data-id="heading-160">3.渲染模式配置</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNustConfig</span>({
    <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启SST（默认）</span>
    <span class="hljs-comment">// 或使用混合模式</span>
    <span class="hljs-attr">routeRules</span>: {
        <span class="hljs-string">'/static'</span>: { <span class="hljs-attr">prerender</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-string">'/spa/**'</span>: { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> }
    }
});
</code></pre>
<h4 data-id="heading-161">3.数据获取与状态管理</h4>
<h5 data-id="heading-162">1.数据预取策略</h5>






























<table><thead><tr><th><strong>方法</strong>​</th><th>​<strong>执行位置</strong>​</th><th>​<strong>特点</strong>​</th></tr></thead><tbody><tr><td><code>useAsyncData</code></td><td>服务端/客户端</td><td>自动防止重复获取，key 唯一化</td></tr><tr><td><code>useFetch</code></td><td>服务端/客户端</td><td>封装了&nbsp;<code>useAsyncData</code>&nbsp;+&nbsp;<code>$fetch</code></td></tr><tr><td><code>onServerPrefetch</code></td><td>​<strong>仅服务端</strong>​</td><td>组合式 API 专用，类似 vue2 的 serverPrefetch</td></tr><tr><td><code>nuxtServerInit</code></td><td>​<strong>仅服务端</strong>​</td><td>（Pinia）初始化 store 全局数据</td></tr></tbody></table>
<h5 data-id="heading-163">2.Pinia状态同步</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// store/user.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, {
    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">token</span>: <span class="hljs-literal">null</span> }),
    <span class="hljs-attr">actions</span>: {
       <span class="hljs-comment">// Nuxt 特有钩子</span>
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">nustServerInit</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTokenFormCookie</span>();
        }
    }
});
<span class="hljs-comment">// 客户端自动激活状态</span>
</code></pre>
<h4 data-id="heading-164">4.性能优化策略</h4>
<h5 data-id="heading-165">1.渲染层优化</h5>
<ul>
<li><strong>组件缓存</strong>：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">render</span>: {
        <span class="hljs-attr">componentCache</span>: {
            <span class="hljs-attr">max</span>: <span class="hljs-number">1000</span>,
            <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">15</span> <span class="hljs-comment">// 缓存15分钟</span>
        }
    }
}
</code></pre>
<ul>
<li><strong>页面级缓存</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 使用 nitro 缓存</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNitroConfig</span>({
    <span class="hljs-attr">storage</span>: {
        <span class="hljs-attr">redis</span>: { <span class="hljs-attr">driver</span>: <span class="hljs-string">'redis'</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">'redis://localhost:6379'</span>}
    },
    <span class="hljs-attr">routeRules</span>: {
        <span class="hljs-string">'/'</span>: { <span class="hljs-attr">cache</span>: { <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> } } <span class="hljs-comment">// 缓存首页60秒</span>
    }
})
</code></pre>
<h5 data-id="heading-166">2.资源加载优化</h5>
<ul>
<li><strong>预加载关键资源</strong></li>
</ul>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/main.css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"modulepreload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vendor.js"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
</code></pre>
<ul>
<li><strong>HTTP/2 服务端推送</strong></li>
</ul>
<pre><code class="hljs language-http" lang="http">Link &lt;/app.css&gt;; rel=preload; as=style
</code></pre>
<h5 data-id="heading-167">2.流式渲染</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 替代 renderToString</span>
<span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToNodeStream</span>(app);
stram.<span class="hljs-title function_">pipe</span>(res, { <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> });
</code></pre>
<h4 data-id="heading-168">5.错误处理与调试</h4>
<h5 data-id="heading-169">1.全局错误捕获</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 客户端错误</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNustPlugin</span>(<span class="hljs-function"><span class="hljs-params">nustApp</span> =&gt;</span> {
    nustApp.<span class="hljs-property">vueApp</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'客户端错误：'</span>, err);
    }
})
<span class="hljs-comment">// 服务端错误（Nitro）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNitroPluign</span>(<span class="hljs-function">(<span class="hljs-params">nitroApp</span>) =&gt;</span> {
    nitroApp.<span class="hljs-property">hooks</span>.<span class="hljs-title function_">hook</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-title function_">logErrorToService</span>(err);
    })
})
</code></pre>
<h5 data-id="heading-170">2.Sentry集成</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// nust.config.ts</span>
<span class="hljs-attr">modules</span>: [<span class="hljs-string">'@nustjs/sentry'</span>],
<span class="hljs-attr">sentry</span>: {
    <span class="hljs-attr">dsn</span>: <span class="hljs-string">'YOUR_DSN'</span>,
    <span class="hljs-attr">tracing</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 性能监控</span>
}
</code></pre>
<h4 data-id="heading-171">6.安全最佳实践</h4>
<h5 data-id="heading-172">1.XSS防护</h5>
<ul>
<li>避免在服务端渲染中使用v-html</li>
<li>使用vue-basic-sanitize过滤用户内容</li>
</ul>
<h5 data-id="heading-173">2.CSRF防护</h5>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 使用 nitro server API</span>
<span class="hljs-function">export <span class="hljs-literal">default</span> <span class="hljs-title">defineEventHandler</span>(<span class="hljs-params"><span class="hljs-keyword">event</span> =&gt; {
  <span class="hljs-keyword">if</span> (!isValidCSRF(<span class="hljs-keyword">event</span></span>))</span> {
    <span class="hljs-keyword">throw</span> createError({ status: <span class="hljs-number">403</span>, message: <span class="hljs-string">'Forbidden'</span> })
  }
  <span class="hljs-keyword">return</span> { data: <span class="hljs-string">'安全数据'</span> }
})
</code></pre>
<h5 data-id="heading-174">3.CORS配置</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">nitro</span>: {
        <span class="hljs-attr">middleware</span>: [
            <span class="hljs-title function_">corsHander</span>({
                <span class="hljs-attr">origin</span>: [<span class="hljs-string">'http://yourdomain.com'</span>],
                <span class="hljs-attr">methods</span>: [<span class="hljs-string">'GET'</span>, <span class="hljs-string">'POST'</span>]
            })
        ]
    }
}
</code></pre>
<h4 data-id="heading-175">7.高阶应用场景</h4>
<h5 data-id="heading-176">1.混合渲染（Hydrid Rendering）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">routeRules</span>: {
        <span class="hljs-comment">// 静态生成</span>
        <span class="hljs-string">'privacy'</span>: { <span class="hljs-attr">prerender</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-comment">// 客户端渲染</span>
        <span class="hljs-string">'/dashboard/**'</span>: { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> },
        <span class="hljs-comment">// 增量静态生成</span>
        <span class="hljs-string">'/products'</span>: { <span class="hljs-attr">swr</span>: <span class="hljs-number">3600</span> }
    }
}
</code></pre>
<h5 data-id="heading-177">2.边缘渲染（Edge-Side Renddering）</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 部署到边缘计算平台</span>
npx nuxi build --preset=vercel-edge
</code></pre>
<h5 data-id="heading-178">3.微前端集成</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 在 Nuxt 中嵌入子应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>({
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> microApp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadMicroApp</span>(<span class="hljs-string">'react-subapp'</span>, <span class="hljs-string">'#container'</span>);
    }
})
</code></pre>
<h4 data-id="heading-179">8.高频面试题</h4>
<h5 data-id="heading-180">1.SSR的核心优势</h5>
<ul>
<li>提升首屏速度</li>
<li>更好的SEO</li>
<li>更稳定的用户体验</li>
</ul>
<h5 data-id="heading-181">2.hydration过程可能出现的问题</h5>
<ul>
<li>客户端和服务端渲染的DOM结构不一致导致hydration失败</li>
<li>解决方案：
<ul>
<li>避免在<code>&lt;template&gt;</code>中使用随机数</li>
<li>确保服务端/客户端初始状态一致</li>
<li>用v-if替代v-show处理不可见元素</li>
</ul>
</li>
</ul>
<h5 data-id="heading-182">3.如何处理异步数据的服务端渲染？</h5>
<ul>
<li>使用<code>useAsyncData</code>或<code>onServerPrefetch</code>在渲染前获取数据</li>
<li>通过<code>__NUXT__.state</code>注入到<code>HTML</code>供客户端激活</li>
</ul>
<h5 data-id="heading-183">4.如何优化高并发下的SSR性能？</h5>
<ul>
<li>组件级缓存+页面级缓存</li>
<li>流式渲染减少TTFB（首字节时间）</li>
<li>负载均衡+水平扩展服务器</li>
</ul>
<h5 data-id="heading-184">5.Nuxt3相比Nuxt2的重大改进</h5>
<ul>
<li>基于Vite的极速HMR</li>
<li>支持混合渲染和增量静态生成</li>
<li>Nitro引擎提供Serverless/Edge</li>
<li>更好的TypeScript集成</li>
</ul>
<h4 data-id="heading-185">9.实战注意事项</h4>
<h5 data-id="heading-186">1.避免全局副作用</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 错误示例：在服务端共享全局变量</span>
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCounter</span> = (<span class="hljs-params"></span>) =&gt; ({ <span class="hljs-attr">count</span>: ++count })
<span class="hljs-comment">// 正确：每个请求独立上下文</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCounter</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> { count };
}
</code></pre>
<h5 data-id="heading-187">2.环境区分处理</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> runtimeConfig = <span class="hljs-title function_">useRuntimeConfig</span>();
<span class="hljs-keyword">const</span> apiBase = process.<span class="hljs-property">server</span> ? runtimeConfig.<span class="hljs-property">apiSecret</span> : runtimeConfig.<span class="hljs-property">public</span>.<span class="hljs-property">apiBase</span>;
</code></pre>
<h5 data-id="heading-188">3.性能监控指标</h5>






























<table><thead><tr><th>​<strong>指标</strong>​</th><th>​<strong>工具</strong>​</th><th>​<strong>目标值</strong>​</th></tr></thead><tbody><tr><td>TTFB (首字节时间)</td><td>Chrome DevTools</td><td>&lt;200ms</td></tr><tr><td>FCP (首次内容渲染)</td><td>Lighthouse</td><td>&lt;1s</td></tr><tr><td>TTI (可交互时间)</td><td>WebPageTest</td><td>&lt;3s</td></tr><tr><td>Hydration 时间</td><td>Vue Devtools</td><td>&lt;500ms</td></tr></tbody></table>
<ul>
<li><a href="https://juejin.cn/post/7503111373468893193" target="_blank" title="https://juejin.cn/post/7503111373468893193">2025前端面试题-Vue3基础篇</a></li>
<li><a href="https://juejin.cn/post/7503811658198286388" target="_blank" title="https://juejin.cn/post/7503811658198286388">2025前端面试题-React基础篇</a></li>
<li><a href="https://juejin.cn/post/7504545616841965583" target="_blank" title="https://juejin.cn/post/7504545616841965583">2025前端面试题-React进阶篇</a></li>
<li><a href="https://juejin.cn/post/7504926961627054099" target="_blank" title="https://juejin.cn/post/7504926961627054099">2025前端面试题-React高阶篇</a></li>
</ul>
<blockquote>
<p>以上是Vue3面试题的进阶篇内容，如有错误欢迎评论区指正，后续还会更新Vue3原理篇。</p>
</blockquote></div></div>