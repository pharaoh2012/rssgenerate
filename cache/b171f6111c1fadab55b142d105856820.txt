
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18943121" title="发布于 2025-06-22 19:32">
    <span role="heading" aria-level="2">Java源码分析系列笔记-3.volatile</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-什么情况-volatile-比-synchronized-更合适" rel="noopener nofollow">2. 什么情况 volatile 比 synchronized 更合适</a><ul><li><a href="#21-例子" rel="noopener nofollow">2.1. 例子</a></li><li><a href="#22-无法停止的原因分析" rel="noopener nofollow">2.2. 无法停止的原因分析</a></li><li><a href="#23-解决方法" rel="noopener nofollow">2.3. 解决方法</a></li><li><a href="#24-volatile-vs-synchronized" rel="noopener nofollow">2.4. volatile vs synchronized</a></li></ul></li><li><a href="#3-汇编源码实验" rel="noopener nofollow">3. 汇编源码实验</a><ul><li><a href="#31-下载编译-hsdis-amd64dll" rel="noopener nofollow">3.1. 下载编译 hsdis-amd64.dll</a></li><li><a href="#32-放入-jre-bin-目录下" rel="noopener nofollow">3.2. 放入 JRE bin 目录下</a></li><li><a href="#33-对比实验" rel="noopener nofollow">3.3. 对比实验</a></li><li><a href="#34-加上-jvm-参数运行" rel="noopener nofollow">3.4. 加上 jvm 参数运行</a></li><li><a href="#35-输出结果对比" rel="noopener nofollow">3.5. 输出结果对比</a></li></ul></li><li><a href="#4-根据实验结果分析原理" rel="noopener nofollow">4. 根据实验结果分析原理</a><ul><li><a href="#41-可见性" rel="noopener nofollow">4.1. 可见性</a></li><li><a href="#42-有序性" rel="noopener nofollow">4.2. 有序性</a></li></ul></li><li><a href="#5-参考" rel="noopener nofollow">5. 参考</a></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<p>Java 的轻量级锁，主要保证了有序性、可见性和一定的原子性</p>
<ul>
<li>轻量级<br>
相比于 synchronized，volatile 不会引起上下文切换（不会造成线程阻塞）</li>
<li>原子性<br>
对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++这种复合操作不具有原子性</li>
<li>可见性<br>
volatile 写会把数据同时写入主内存，并让其他线程对这个数据的工作内存失效，这样其他线程读的时候就需要去主内存中读取</li>
<li>有序性<br>
对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
</ul>
<h2 id="2-什么情况-volatile-比-synchronized-更合适">2. 什么情况 volatile 比 synchronized 更合适</h2>
<h3 id="21-例子">2.1. 例子</h3>
<p>如下程序。thread1 并不会停止</p>
<pre><code class="language-java">public class VolatileTest
{
    private static boolean isRunning = true;

    public static void main(String[] args) throws InterruptedException
    {
        Thread thread1 = new Thread(()-&gt;{
            System.out.println("thread1 is running");
            while (isRunning)
            {

            }
            System.out.println("thread1 will be stopped");
        });
        thread1.start();

        Thread.sleep(1000);

        Thread thread2 = new Thread(()-&gt;{
            System.out.println("thread2 is running");

            isRunning = false;

            System.out.println("thread2 change isRunning flag");
        });
        thread2.start();

        thread1.join();
        thread2.join();
    }
}
</code></pre>
<h3 id="22-无法停止的原因分析">2.2. 无法停止的原因分析</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200118142603.png" class="lazyload"></p>
<ol>
<li>Thread1 从主内存把 isRunning 这个变量加载到工作内存中，值为 true 所以一直运行</li>
<li>Thread2 从主内存把 isRunning 这个变量加载到工作内存中，值为 true 改为 false，写回工作内存，再写回主内存</li>
<li>Thread1 一直从工作内存中读取这个变量，一直为 true，所以还是无法停止运行</li>
</ol>
<h3 id="23-解决方法">2.3. 解决方法</h3>
<p>将 isRunning 使用 volatile 修饰</p>
<pre><code class="language-java">public class VolatileTest
{
    private static volatile boolean isRunning = true;

    public static void main(String[] args) throws InterruptedException
    {
        Thread thread1 = new Thread(()-&gt;{
            System.out.println("thread1 is running");
            while (isRunning)
            {

            }
            System.out.println("thread1 will be stopped");
        });
        thread1.start();

        Thread.sleep(1000);

        Thread thread2 = new Thread(()-&gt;{
            System.out.println("thread2 is running");

            isRunning = false;

            System.out.println("thread2 change isRunning flag");
        });
        thread2.start();

        thread1.join();
        thread2.join();
    }
}
</code></pre>
<h3 id="24-volatile-vs-synchronized">2.4. volatile vs synchronized</h3>
<table>
<thead>
<tr>
<th></th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存模型三性</td>
<td>可见性、有序性</td>
<td>可见性、有序性、原子性</td>
</tr>
<tr>
<td>是否造成线程阻塞【重量级别】</td>
<td>不会</td>
<td>会</td>
</tr>
<tr>
<td>应用范围</td>
<td>变量级别</td>
<td>变量、方法、类级别</td>
</tr>
</tbody>
</table>
<h2 id="3-汇编源码实验">3. 汇编源码实验</h2>
<h3 id="31-下载编译-hsdis-amd64dll">3.1. 下载编译 hsdis-amd64.dll</h3>
<p>参考<a href="https://dropzone.nfshost.com/hsdis/" target="_blank" rel="noopener nofollow">How to build hsdis-amd64.dll and hsdis-i386.dll on Windows</a>或者<a href="../2.Synchronized/attachments/20200123134005963_25574/hsdis-amd64.7z" target="_blank" rel="noopener nofollow">hsdis-amd64.7z</a></p>
<h3 id="32-放入-jre-bin-目录下">3.2. 放入 JRE bin 目录下</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200114134345.png" class="lazyload"></p>
<h3 id="33-对比实验">3.3. 对比实验</h3>
<ul>
<li>有 volatile</li>
</ul>
<pre><code class="language-java">public class TestVolatile
{
    private static volatile int i = 0;
    public static void main(String[] args)
    {
        test();
    }

    private static void test()
    {
        i++;
    }
}
</code></pre>
<ul>
<li>没有 volatile</li>
</ul>
<pre><code class="language-java">public class TestVolatile
{
    private static int i = 0;
    public static void main(String[] args)
    {
        test();
    }

    private static void test()
    {
        i++;
    }
}
</code></pre>
<h3 id="34-加上-jvm-参数运行">3.4. 加上 jvm 参数运行</h3>
<pre><code class="language-jvm">-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:-Inline -XX:CompileCommand=print,*TestVolatile.test
</code></pre>
<p>使用 IDEA 的话如下图：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200113173853.png" class="lazyload"></p>
<h3 id="35-输出结果对比">3.5. 输出结果对比</h3>
<p>结果如附件：</p>
<ul>
<li><a href="attachments/20200113174306533_24106/volatile.txt" target="_blank" rel="noopener nofollow">volatile.txt</a></li>
<li><a href="attachments/20200113174306533_24106/%E6%99%AE%E9%80%9A.txt" target="_blank" rel="noopener nofollow">普通.txt</a><br>
使用 BeyondCompare 对比图如下：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200113174211.png" class="lazyload"></li>
</ul>
<h2 id="4-根据实验结果分析原理">4. 根据实验结果分析原理</h2>
<p>从汇编语言层面看，有 volatile 的结果比没有 volatile 的多了一个指令：<code>lock addl $0x0,(%rsp) </code>，这条指令起到内存屏障的作用</p>
<ol>
<li>
<p>禁止屏障两边的指令重排序</p>
</li>
<li>
<p>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</p>
</li>
</ol>
<h3 id="41-可见性">4.1. 可见性</h3>
<p>根据内存屏障的作用 2 可以实现可见性，表现如下</p>
<ul>
<li>volatile 写会把数据同时写入主内存，并让其他线程对这个数据的工作内存失效</li>
<li>其他线程 volatile 读的时候就需要去主内存中读取</li>
</ul>
<h3 id="42-有序性">4.2. 有序性</h3>
<p>根据内存屏障的作用 1 可以实现有序性，表现如下<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200114113318.png" class="lazyload"></p>
<p>在 volatile 写之前插入<strong>释放屏障</strong>【LoadStore+StoreStore】使得该屏障之前的任何读写操作都先于这个 volatile 写被提交；<br>
在 volatile 读之后插入<strong>获取屏障</strong>【LoadLoad+LoadStore】使得这个 volatile 读操作先于该屏障之后的任何读写操作被提交。</p>
<h2 id="5-参考">5. 参考</h2>
<ul>
<li><a href="https://www.infoq.cn/article/java-memory-model-4/" target="_blank" rel="noopener nofollow">深入理解 Java 内存模型（四）——volatile-InfoQ</a></li>
<li><a href="https://www.hollischuang.com/archives/2673" target="_blank" rel="noopener nofollow">再有人问你 volatile 是什么，把这篇文章也发给他。-HollisChuang's Blog</a></li>
<li><a href="https://crowhawk.github.io/2018/02/10/volatile/" target="_blank" rel="noopener nofollow">Java volatile 关键字底层实现原理解析 - 王泽远的博客 | Crow's Blog</a></li>
<li><a href="https://my.oschina.net/tantexian/blog/808032" target="_blank" rel="noopener nofollow">精确解释 java 的 volatile 之可见性、原子性、有序性（通过汇编语言） - tantexian 的博客空间 - OSCHINA</a></li>
<li><a href="https://juejin.im/post/5ae134e76fb9a07acb3c8ea7" target="_blank" rel="noopener nofollow">volatile 与 synchronized 的区别 - 掘金</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-22 19:33">2025-06-22 19:32</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18943121);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18943121', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18943121', title: 'Java源码分析系列笔记-3.volatile' })">举报</a>
</div>
        