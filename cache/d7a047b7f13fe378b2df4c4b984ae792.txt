<!----> <meta itemprop="headline" content="async/await 必须使用 try/catch 吗？"> <meta itemprop="keywords" content="前端,Promise,监控"> <meta itemprop="datePublished" content="2025-03-17T00:20:26.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨夜寻晴天"> <meta itemprop="url" content="https://juejin.cn/user/1943592288391496"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7fb3e115="">
            async/await 必须使用 try/catch 吗？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7fb3e115=""><div class="author-info-box" data-v-7fb3e115=""><div class="author-name" data-v-7fb3e115=""><a href="/user/1943592288391496/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-7fb3e115=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨夜寻晴天
  </span> <!----> <!----> <div class="vip-level" data-v-cd7d0a50="" data-v-292f6e48=""><span class="tooltip" data-v-cd7d0a50=""><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        VIP.5 如鱼得水
      </div><span class="byte-tooltip__wrapper"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="VIP.5 如鱼得水" title="VIP.5 如鱼得水" class="lazy" style="aspect-ratio:NaN;" data-v-5244ef91="" data-v-cd7d0a50=""></span></span></div> </a></div> <div class="meta-box" data-v-7fb3e115=""><time datetime="2025-03-17T00:20:26.000Z" title="Mon Mar 17 2025 00:20:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7fb3e115="">
                    2025-03-17
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7fb3e115=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7fb3e115=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7fb3e115=""></circle></svg> <span class="views-count" data-v-7fb3e115="">
                    18,666
                  </span> <span class="read-time" data-v-7fb3e115=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7fb3e115=""><rect width="16" height="16" fill="none" data-v-7fb3e115=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7fb3e115=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7fb3e115=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7fb3e115=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7fb3e115=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">前言</h2>
<p>在 JavaScript 开发者的日常中，这样的对话时常发生：</p>
<ul>
<li>👨💻 新人："为什么页面突然白屏了？"</li>
<li>👨🔧 老人："异步请求没做错误处理吧？"</li>
</ul>
<p><strong>async/await 看似优雅的语法糖背后，隐藏着一个关键问题：错误处理策略的抉择</strong>。</p>
<p>在 JavaScript 中使用&nbsp;<code>async/await</code>&nbsp;时，很多人会问：<strong>“必须使用 try/catch 吗？”</strong></p>
<p>其实答案并非绝对，而是取决于你如何设计错误处理策略和代码风格。</p>
<p>接下来，我们将探讨 async/await 的错误处理机制、使用 try/catch 的优势，以及其他可选的错误处理方法。</p>
<h2 data-id="heading-1">async/await 的基本原理</h2>
<h3 data-id="heading-2">异步代码的进化史</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 回调地狱时代</span>
<span class="hljs-title function_">fetchData</span>(url1, <span class="hljs-function">(<span class="hljs-params">data1</span>) =&gt;</span> {
  <span class="hljs-title function_">process</span>(data1, <span class="hljs-function">(<span class="hljs-params">result1</span>) =&gt;</span> {
    <span class="hljs-title function_">fetchData</span>(url2, <span class="hljs-function">(<span class="hljs-params">data2</span>) =&gt;</span> {
      <span class="hljs-comment">// 更多嵌套...</span>
    })
  })
})

<span class="hljs-comment">// Promise 时代</span>
<span class="hljs-title function_">fetchData</span>(url1)
  .<span class="hljs-title function_">then</span>(process)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetchData</span>(url2))
  .<span class="hljs-title function_">catch</span>(handleError)

<span class="hljs-comment">// async/await 时代</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">workflow</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(url1)
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">process</span>(data1)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(url2)
}
</code></pre>
<p>async/await 是基于 <strong>Promise 的语法糖</strong>，它使异步代码看起来<strong>更像同步代码</strong>，从而更易读、易写。一个 async 函数总是返回一个 Promise，你可以在该函数内部使用 await 来等待异步操作完成。</p>
<p>如果在异步操作中<strong>出现错误</strong>（例如网络请求失败），该错误会使 Promise <strong>进入 rejected 状态</strong>。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.example.com/data"</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-keyword">return</span> data;
}
</code></pre>
<h2 data-id="heading-3">使用 try/catch 捕获错误</h2>
<p>打个比喻，就好比<strong>铁路信号系统</strong></p>
<p>想象 async 函数是一列高速行驶的列车：</p>
<ul>
<li><strong>await 是轨道切换器</strong>：控制代码执行流向</li>
<li><strong>未捕获的错误如同脱轨事故</strong>：会沿着铁路网（调用栈）逆向传播</li>
<li><strong>try/catch 是智能防护系统</strong>：
<ul>
<li>自动触发紧急制动（错误捕获）</li>
<li>启动备用轨道（错误恢复逻辑）</li>
<li>向调度中心发送警报（错误日志）</li>
</ul>
</li>
</ul>
<p>为了优雅地捕获 async/await 中出现的错误，通常我们会使用 try/catch 语句。这种方式<strong>可以在同一个代码块中捕获抛出的错误</strong>，使得错误处理逻辑更集中、直观。</p>
<ul>
<li>代码逻辑集中，错误处理与业务逻辑紧密结合。</li>
<li>可以捕获多个 await 操作中抛出的错误。</li>
<li>适合需要在出错时进行统一处理或恢复操作的场景。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.example.com/data"</span>);
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    <span class="hljs-keyword">return</span> data;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error fetching data:"</span>, error);
    <span class="hljs-comment">// 根据需要，可以在此处处理错误，或者重新抛出以便上层捕获</span>
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<h2 data-id="heading-4">不使用 try/catch 的替代方案</h2>
<p>虽然 try/catch 是最直观的错误处理方式，但你也可以不在 async 函数内部使用它，而是<strong>在调用该 async 函数时捕获错误</strong>。</p>
<h3 data-id="heading-5"><strong>在 Promise 链末尾添加&nbsp;<code>.catch()</code></strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.example.com/data"</span>);
  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
  }
  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
}

<span class="hljs-comment">// 调用处使用 Promise.catch 捕获错误</span>
<span class="hljs-title function_">fetchData</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Data:"</span>, data);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error fetching data:"</span>, error);
  });
</code></pre>
<p>这种方式将错误处理逻辑移至函数调用方，适用于以下场景：</p>
<ul>
<li>当多个调用者希望以不同方式处理错误时。</li>
<li>希望让 async 函数保持简洁，将错误处理交给全局统一的错误处理器（例如在 React 应用中可以使用 Error Boundary）。</li>
</ul>
<h3 data-id="heading-6"><strong>将&nbsp;<code>await</code>&nbsp;与&nbsp;<code>catch</code>&nbsp;结合</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Request failed:'</span>, error);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 返回兜底值</span>
  });
  <span class="hljs-keyword">if</span> (!response) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 继续处理 response...</span>
}
</code></pre>
<h3 data-id="heading-7"><strong>全局错误监听（慎用，适合兜底）</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 浏览器端全局监听</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  event.<span class="hljs-title function_">preventDefault</span>();
  <span class="hljs-title function_">sendErrorLog</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'UNHANDLED_REJECTION'</span>,
    <span class="hljs-attr">error</span>: event.<span class="hljs-property">reason</span>,
    <span class="hljs-attr">stack</span>: event.<span class="hljs-property">reason</span>.<span class="hljs-property">stack</span>
  });
  <span class="hljs-title function_">showErrorToast</span>(<span class="hljs-string">'系统异常，请联系管理员'</span>);
});

<span class="hljs-comment">// Node.js 进程管理</span>
process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'unhandledRejection'</span>, <span class="hljs-function">(<span class="hljs-params">reason, promise</span>) =&gt;</span> {
  logger.<span class="hljs-title function_">fatal</span>(<span class="hljs-string">'未处理的 Promise 拒绝:'</span>, reason);
  process.<span class="hljs-property">exitCode</span> = <span class="hljs-number">1</span>;
});
</code></pre>
<h2 data-id="heading-8">错误处理策略矩阵</h2>
<h3 data-id="heading-9">决策树分析</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
  A[需要立即处理错误?] --&gt;|是| B[使用 try/catch]
  A --&gt;|否| C{错误类型}
  C --&gt;|可恢复错误| D[Promise.catch]
  C --&gt;|致命错误| E[全局监听]
  C --&gt;|批量操作| F[Promise.allSettled]
</code></pre>
<h3 data-id="heading-10">错误处理体系</h3>
<ol>
<li><strong>基础层</strong>：80% 的异步操作使用 try/catch + 类型检查</li>
<li><strong>中间层</strong>：15% 的通用错误使用全局拦截 + 日志上报</li>
<li><strong>战略层</strong>：5% 的关键操作实现自动恢复机制</li>
</ol>
<h2 data-id="heading-11">小结</h2>
<p>我的观点是：<strong>不强制要求，但强烈推荐</strong></p>
<ul>
<li><strong>不强制</strong>：如果不需要处理错误，可以不使用&nbsp;<code>try/catch</code>，但未捕获的 Promise 拒绝（unhandled rejection）会导致程序崩溃（在 Node.js 或现代浏览器中）。</li>
<li><strong>推荐</strong>：90% 的场景下需要捕获错误，因此&nbsp;<code>try/catch</code>&nbsp;是最直接的错误处理方式。</li>
</ul>
<p>所有我个人观点：<strong>使用 async/await 尽量使用 try/catch</strong>。<strong>好的错误处理不是消灭错误，而是让系统具备优雅降级的能力</strong>。</p>
<p>你的代码应该像优秀的飞行员——在遇到气流时，仍能保持平稳飞行。大家如有不同意见，还请评论区讨论，说出自己的见解。</p></div></div>