
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/netcore5/p/18635522" title="发布于 2024-12-27 13:38">
    <span role="heading" aria-level="2">ASP.NET Core 中的速率限制中间件的使用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="简介">简介</h2>
<p>在ASP.NET Core中，速率限制中间件是用来控制客户端对Web API或MVC应用程序发出请求的速率，以防止服务器过载和提高安全性。</p>
<p>下面是 <code>AddRateLimiter</code> 的一些基本用法：</p>
<h3 id="1-注册服务">1. 注册服务</h3>
<p>在 <code>Startup.cs</code> 或 <code>Program.cs</code> 中，需要注册 <code>AddRateLimiter</code> 服务。这可以通过以下代码完成：</p>
<pre><code class="language-csharp">builder.Services.AddRateLimiter(options =&gt;
{
    // 配置速率限制选项
});
</code></pre>
<h3 id="2-添加速率限制策略">2. 添加速率限制策略</h3>
<p>可以添加不同类型的速率限制策略， 包括固定窗口、滑动窗口、令牌桶和并发限制。</p>
<h4 id="固定窗口限制器fixed-window-limiter">固定窗口限制器（Fixed Window Limiter）</h4>
<p>固定窗口限制器使用固定的时间窗口来限制请求。当时间窗口到期后，会开始一个新的时间窗口，并重置请求限制。例如，可以设置一个策略，允许每个12秒的时间窗口内最多4个请求。</p>
<pre><code class="language-csharp">builder.Services.AddRateLimiter(options =&gt;
{
    options.AddFixedWindowLimiter("fixed", opt =&gt;
    {
        opt.Window = TimeSpan.FromMinutes(1); // 时间窗口
        opt.PermitLimit = 3; // 在时间窗口内允许的最大请求数
        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst; // 请求处理顺序
        opt.QueueLimit = 2; // 队列中允许的最大请求数
    });
});
app.UseRateLimiter();
</code></pre>
<p>即固定时间请求的次数，超过次数就会限流，下一个窗口时间将次数重置</p>
<p>经过测试，多余的请求还是会等待</p>
<blockquote>
<p><a href="https://www.cnblogs.com/guoxiaotian/p/17834892.html" target="_blank">https://www.cnblogs.com/guoxiaotian/p/17834892.html</a></p>
</blockquote>
<h4 id="滑动窗口限制器sliding-window-limiter">滑动窗口限制器（Sliding Window Limiter）</h4>
<p>滑动窗口算法：</p>
<ul>
<li>与固定窗口限制器类似，但为每个窗口添加了段。 窗口在每个段间隔滑动一段。 段间隔的计算方式是：(窗口时间)/(每个窗口的段数)。</li>
<li>将窗口的请求数限制为 permitLimit 个请求。</li>
<li>每个时间窗口划分为一个窗口 n 个段。</li>
<li>从倒退一个窗口的过期时间段（当前段之前的 n 个段）获取的请求会添加到当前的段。 我们将倒退一个窗口最近过期时间段称为“过期的段”。</li>
</ul>
<p>请考虑下表，其中显示了一个滑动窗口限制器，该限制器的窗口为 30 秒、每个窗口有三个段，且请求数限制为 100 个：</p>
<ul>
<li>第一行和第一列显示时间段。</li>
<li>第二行显示剩余的可用请求数。 其余请求数的计算方式为可用请求数减去处理的请求数和回收的请求数。</li>
<li>每次的请求数沿着蓝色对角线移动。</li>
<li>从时间 30 开始，从过期时间段获得的请求会再次添加到请求数限制中，如红色线条所示。<br>
<img src="https://i-blog.csdnimg.cn/img_convert/0be59048ade0beba218832688219659b.png" alt="" loading="lazy"></li>
</ul>
<p>下表换了一种格式来显示上图中的数据。 “可用”列显示上一个段中可用的请求数（来自上一个行中的“结转”）。 第一行显示有 100 个可用请求，因为没有上一个段。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>可用</th>
<th>获取的请求数</th>
<th>从过期段回收的请求数</th>
<th>结存请求数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>100</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td>10</td>
<td>80</td>
<td>30</td>
<td>0</td>
<td>50</td>
</tr>
<tr>
<td>20</td>
<td>50</td>
<td>40</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>30</td>
<td>10</td>
<td>30</td>
<td>20</td>
<td>0</td>
</tr>
<tr>
<td>40</td>
<td>0</td>
<td>10</td>
<td>30</td>
<td>20</td>
</tr>
<tr>
<td>50</td>
<td>20</td>
<td>10</td>
<td>40</td>
<td>50</td>
</tr>
<tr>
<td>60</td>
<td>50</td>
<td>35</td>
<td>30</td>
<td>45</td>
</tr>
</tbody>
</table>
<pre><code> services.AddRateLimiter(options =&gt;
    {
        options.AddSlidingWindowLimiter("sliding", opt =&gt;
        {
            opt.Window = TimeSpan.FromMinutes(1); // 总窗口时间为1分钟
            opt.SegmentsPerWindow = 6; // 将1分钟的窗口分为6个段，即每10秒一个段
            opt.PermitLimit = 10; // 整个窗口时间内允许的最大请求数
        });
    });
</code></pre>
<h4 id="令牌桶限制器token-bucket-limiter">令牌桶限制器（Token Bucket Limiter）</h4>
<p>令牌桶限制器维护一个滚动累积的使用预算，作为一个令牌的余额。它以一定的速率添加令牌，当服务请求发生时，服务尝试提取一个令牌（减少令牌计数）来满足请求。如果没有令牌，服务就达到了限制，响应被阻塞。</p>
<pre><code class="language-csharp">    services.AddRateLimiter(configureOptions =&gt;
    {
        configureOptions.AddTokenBucketLimiter("token-bucket", options =&gt;
        {
            options.TokenLimit = 100; // 桶的容量
            options.ReplenishmentPeriod = TimeSpan.FromSeconds(10); // 补充周期，即每10秒补充一次令牌
            options.TokensPerPeriod = 10; // 每个周期补充的令牌数
            options.AutoReplenishment = true; // 是否自动补充令牌
            options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst; // 队列处理顺序
            options.QueueLimit = 10; // 请求队列长度限制
        });
    });

</code></pre>
<h4 id="并发限制器concurrency-limiter">并发限制器（Concurrency Limiter）</h4>
<p>并发限制器是最简单的速率限制形式。它不关注时间，只关注并发请求的数量。</p>
<pre><code class="language-csharp">    services.AddRateLimiter(options =&gt;
    {
        options.AddConcurrencyLimiter("concurrency", options =&gt;
        {
            options.PermitLimit = 1; // 最大并发请求数
            options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst; // 队列处理顺序
            options.QueueLimit = 10; // 请求队列长度限制
        });
    });
</code></pre>
<h3 id="3-使用中间件">3. 使用中间件</h3>
<p>在 <code>Configure</code> 方法或 <code>Program.cs</code> 中，需要使用 <code>UseRateLimiter</code> 中间件：</p>
<pre><code class="language-csharp">app.UseRateLimiter();
</code></pre>
<h3 id="4-应用速率限制策略">4. 应用速率限制策略</h3>
<p>可以全局应用速率限制策略，或者将其应用于特定的控制器或动作：</p>
<h4 id="全局配置">全局配置</h4>
<pre><code class="language-csharp">app.MapControllers().RequireRateLimiting("fixed");
</code></pre>
<h4 id="应用于特定的控制器">应用于特定的控制器</h4>
<pre><code class="language-csharp">[EnableRateLimiting("fixed")]
public class RateLimitTestController : ControllerBase
{
    // 控制器动作
}
</code></pre>
<h4 id="应用于特定的动作">应用于特定的动作</h4>
<pre><code class="language-csharp">[EnableRateLimiting("fixed")]
public async Task&lt;IActionResult&gt; Get()
{
    // 动作逻辑
}
</code></pre>
<h3 id="5-禁用速率限制">5. 禁用速率限制</h3>
<p>也可以选择禁用速率限制，无论是在控制器级别还是特定动作级别：</p>
<h4 id="禁用控制器级别的速率限制">禁用控制器级别的速率限制</h4>
<pre><code class="language-csharp">[DisableRateLimiting]
public class RateLimitTestController : ControllerBase
{
    // 控制器动作
}
</code></pre>
<h4 id="禁用特定动作的速率限制">禁用特定动作的速率限制</h4>
<pre><code class="language-csharp">[DisableRateLimiting]
public async Task&lt;IActionResult&gt; Get()
{
    // 动作逻辑
}
</code></pre>
<h3 id="自定义响应">自定义响应</h3>
<p>当客户端超出速率限制时，可以自定义响应。例如，可以设置<code>OnRejected</code>回调来自定义响应：</p>
<pre><code class="language-csharp">options.OnRejected = (context, token) =&gt;
{
    context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
    context.HttpContext.Response.Headers["Retry-After"] = "60"; // 建议60秒后重试
     context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
 context.HttpContext.Response.WriteAsync("Too many requests. Please try again later.", cancellationToken: token);
                   
    return Task.CompletedTask;
};
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/direct/a01bf00182ef40e0b09b859a4eec9b52.png" alt="" loading="lazy"></p>
<h2 id="总结">总结</h2>
<p>在ASP.NET Core应用程序中实现有效的速率限制策略，以保护的API免受滥用和过载。欢迎关注我的公众号：Net分享</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5342591471655093" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 13:38">2024-12-27 13:38</span>&nbsp;
<a href="https://www.cnblogs.com/netcore5">今晚打老虎！</a>&nbsp;
阅读(<span id="post_view_count">234</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18635522" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18635522);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18635522', targetLink: 'https://www.cnblogs.com/netcore5/p/18635522', title: 'ASP.NET Core 中的速率限制中间件的使用' })">举报</a>
</div>
        