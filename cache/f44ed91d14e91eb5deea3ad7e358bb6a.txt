
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/18975266" title="发布于 2025-07-09 17:06">
    <span role="heading" aria-level="2">Django+DRF 实战：序列化器 ValidationError 触发机制完整指南</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250709170559274-985484821.png" alt="Django+DRF 实战：序列化器 ValidationError 触发机制完整指南" class="desc_img">
        本文详解了 DRF 中 ValidationError 的验证流程与优先级，涵盖字段内置验证、自定义验证方法、对象级验证及数据库约束，并通过实战演示如何自定义异常提示信息。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一validationerror-异常优先级">一、ValidationError 异常优先级</h2>
<h3 id="序列化器验证顺序">序列化器验证顺序</h3>
<p>第一级：字段内置验证</p>
<ul>
<li>序列化器先进行字段内置验证，像 <code>min_length</code>、<code>required</code>这类。一旦验证不通过，就会立即抛出 <code>ValidationError</code>，并且后续的验证步骤不会再执行。</li>
</ul>
<pre><code class="language-python">    username = serializers.CharField(
        min_length=settings.USERNAME_MIN_LENGTH,
        max_length=settings.USERNAME_MAX_LENGTH,
        error_messages={
            "required": "登录账号不能为空",
            "min_length": f"账号长度至少为{settings.USERNAME_MIN_LENGTH}位",
            "max_length": f"账号长度不能超过{settings.USERNAME_MAX_LENGTH}位",
        },
    )
</code></pre>
<p>第二级：自定义字段验证方法</p>
<ul>
<li>若定义了类似 <code>validate_&lt;field_name&gt;</code> 这样的自定义验证方法，它会在字段内置验证之后执行。要是验证失败，同样会抛出 <code>ValidationError</code>。</li>
</ul>
<pre><code class="language-python">    def validate_username(self, value):
        if not re.match(r"^[A-Za-z0-9]+$", value):
            raise serializers.ValidationError("账号格式为数字以及字母")
        return value
</code></pre>
<p>第三级：对象级验证</p>
<ul>
<li><code>validate()</code> 方法会在所有字段验证都通过之后执行，用于对多个字段进行联合验证。</li>
</ul>
<pre><code class="language-python">    def validate(self, data):
        if data["password"] != data["confirm_password"]:
            raise serializers.ValidationError(
                {"confirm_password": "两次输入的密码不一致"}
            )
        return data
</code></pre>
<p>第四级：数据库验证</p>
<p>进行反序列化操作时，序列化器验证通过后，会写入数据库。如果写入失败，会抛出异常。例如：</p>
<ul>
<li>唯一性约束冲突：当模型字段被设置为 <code>unique=True</code> 时，如果插入重复数据，就会触发该异常。</li>
<li>外键约束失败：关联一个不存在的外键对象时，会引发此异常。</li>
<li>NOT NULL 约束失败：当模型中设置为 null=False 的字段没有值时，会出现该异常。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://www.django-rest-framework.org/api-guide/exceptions/" target="_blank" rel="noopener nofollow">DRF 异常</a></li>
<li><a href="https://www.django-rest-framework.org/api-guide/exceptions/#validationerror" target="_blank" rel="noopener nofollow">DRF ValidationError</a></li>
</ul>
<h3 id="自动生成验证器">自动生成验证器</h3>
<p>自动生成验证器示例</p>
<ul>
<li>模型字段定义中，指定了<code>unique=True</code>参数</li>
</ul>
<pre><code class="language-python">username = models.CharField(
        max_length=30, unique=True, db_comment="用户账号", help_text="用户账号"
)
</code></pre>
<p><img alt="image-20250707180350738" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250709170419589-889919764.png" class="lazyload"></p>
<ul>
<li>定义序列化器，继承了<code>ModelSerializer</code>。</li>
</ul>
<pre><code class="language-python"># 在下面序列化器，只定义了unique 错误信息，并没有显式声明 unique=True
class UserImportSerializer(serializers.ModelSerializer):
    class Meta:
        model = SystemUsers
        fields = [
            "username",
        ]
        extra_kwargs = {
            "username": {
                "min_length": settings.USERNAME_MIN_LENGTH,
                "max_length": settings.USERNAME_MAX_LENGTH,
                "error_messages": {
                    "min_length": "用户账号长度不能少于4个字符",
                    "max_length": "用户账号长度不能超过30个字符",
                    "unique": "用户账号已经存在",
                },
            },
        }
</code></pre>
<ul>
<li>进入django shell，查看最终生成的序列化器。可以看到自动添加了<code>UniqueValidator</code>验证器</li>
</ul>
<pre><code class="language-python"># 进入 django shell
python manage.py shell

# 查看最终生成的序列化器
&gt;&gt;&gt; from myapp_system.user.serializers import UserImportSerializer
&gt;&gt;&gt; ser=UserImportSerializer()
&gt;&gt;&gt; print(ser)

### 输出结果
username = CharField(error_messages={'min_length': '用户账号长度不能少于4个字符', 'max_length': '用户账号长度不能超过30个字符', 'unique': '用户账号已经存在'}, help_text='用户账号', max_length=30, min_length=4, validators=[&lt;UniqueValidator(queryset=SystemUsers.objects.all())&gt;]) 
</code></pre>
<p>注意：</p>
<ul>
<li>此时的<code>'unique': '用户账号已经存在'</code>错误提示，并不会生效，因为被内置验证器覆盖了。</li>
<li>内置验证器默认返回的错误信息提示是：<code>具有 username 的 system users 已存在。</code></li>
</ul>
<h2 id="二实战">二、实战</h2>
<h3 id="实战场景">实战场景</h3>
<p>取消自动生成验证器，实现自定义异常信息提示。</p>
<h3 id="实战原理">实战原理</h3>
<p><code>ValidationError</code>异常信息提示，与下面因素相关</p>
<ul>
<li>序列化器验证顺序：在哪个阶段抛出<code>ValidationError</code>异常，则返回相应阶段的异常信息提示</li>
<li>序列化器的定义：如果序列化器继承了<code>ModelSerializer</code>，默认会为字段自动生成验证器</li>
</ul>
<h3 id="实战步骤">实战步骤</h3>
<p>在定义序列化器时，设置：</p>
<ul>
<li>取消字段自动生成的验证器。</li>
<li>添加字段自定义验证方法。例如示例代码中的<code>validate_username()</code></li>
</ul>
<p><img alt="image-20250709085519192" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250709170444005-542669822.png" class="lazyload"></p>
<h3 id="实战效果">实战效果</h3>
<p>此时的异常提示信息为：<code>用户账号 x 已经存在</code></p>
<p><img alt="image-20250709085810282" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250709170448888-1757607794.png" class="lazyload"></p>
<p><a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/myapp_system/user/serializers.py" target="_blank" rel="noopener nofollow">点击查看完成代码</a></p>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-09 17:06">2025-07-09 17:06</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18975266);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18975266', targetLink: 'https://www.cnblogs.com/xwz1024/p/18975266', title: 'Django+DRF 实战：序列化器 ValidationError 触发机制完整指南' })">举报</a>
</div>
	