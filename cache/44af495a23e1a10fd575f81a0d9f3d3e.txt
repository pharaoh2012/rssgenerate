
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/linjinkun/p/18856114" title="发布于 2025-05-01 09:44">
    <span role="heading" aria-level="2">同余最短路&amp;转圈背包算法学习笔记（超详细）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="一问题引入">一、问题引入</h3>
<p>当你想要解决一个完全背包计数问题，但是 <span class="math inline">\(M\)</span> 的范围太大，那么你就可以使用同余最短路。</p>
<h3 id="二算法推导过程">二、算法推导过程</h3>
<p>首先对于一个完全背包计数问题，我们要知道如果 <span class="math inline">\(x\)</span> 这个数能凑出来，那么 <span class="math inline">\(x+a_i,x+2a_i,x+3a_i,\dots\)</span> 一定都能凑出来，所以说，我们随便找一个 <span class="math inline">\(a_i\)</span>，找到对于 <span class="math inline">\([0,a_i-1]\)</span> 中的每个数 <span class="math inline">\(k\)</span> 的最小的能凑出来的数并且这个数模 <span class="math inline">\(a_i\)</span> 等于 <span class="math inline">\(k\)</span>，这个时候从最小的可以想到最短路，于是我们就有了一个大胆的想法，首先为了节省时间复杂度，把模数设定成最小的 <span class="math inline">\(a_i\)</span>，然后进行最短路，最短路的过程就是不断尝试增加其它的 <span class="math inline">\(a_i\)</span>，然后再取模，你会发现，这是对的！哦对，刚刚只是找到了对于 <span class="math inline">\([0,a_i-1]\)</span> 中的每个数 <span class="math inline">\(k\)</span> 的最小的能凑出来的数并且这个数模 <span class="math inline">\(a_i\)</span> 等于 <span class="math inline">\(k\)</span>，统计的话还要统计能加多少次 <span class="math inline">\(a_i\)</span>。<br>
时间复杂度：<span class="math inline">\(O(E \log V) = O(a_i(n-1) \log a_i)\)</span>。</p>
<h3 id="三同余最短路模板">三、同余最短路模板</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = ;//数据范围
int a[N];
int f[N];
int vis[N];
struct node
{
    int x;
    int w;
    bool operator&lt;(const node&amp;a)const
    {
        return w&gt;a.w;
    }
};
signed main()
{
    int n;
    long long m;
    scanf("%d %lld",&amp;n,&amp;m);
    for(int i = 1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a[i]);
    }
    sort(a+1,a+n+1);
    memset(f,0x3f,sizeof(f));
    f[0] = 0;
    priority_queue&lt;node&gt;q;
    q.push({0,0});
    while(q.size())
    {
        node x = q.top();
        q.pop();
        if(vis[x.x])
        {
            continue;
        }
        vis[x.x] = 1;
        for(int i = 2;i&lt;=n;i++)
        {
            int v = (x.x+a[i])%a[1];
            if(f[v]&gt;f[x.x]+a[i])
            {
                f[v] = f[x.x]+a[i];
                q.push({v,f[v]});
            }
        }
    }
    long long ans = 0;
    for(int i = 0;i&lt;a[1];i++)
    {
        if(f[i]&lt;=m)
        {
            ans+=(m-f[i])/a[1]+1;
        }
    }
    printf("%lld",ans-1);
    return 0;
}
</code></pre>
<p><strong>注意：这只是一个板子，应用时请随机应变。</strong></p>
<h3 id="四同余最短路例题">四、同余最短路例题</h3>
<h4 id="u553673-硬币问题"><a href="https://www.luogu.com.cn/problem/U553673" target="_blank" rel="noopener nofollow">U553673 硬币问题</a></h4>
<p>同余最短路模板题，代码放上供参考：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e6+5;
int a[N];
long long f[N];
int vis[N];
struct node
{
    int x;
    int w;
    bool operator&lt;(const node&amp;a)const
    {
        return w&gt;a.w;
    }
};
signed main()
{
    int n;
    long long m;
    scanf("%d %lld",&amp;n,&amp;m);
    for(int i = 1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a[i]);
    }
    sort(a+1,a+n+1);
    memset(f,0x3f,sizeof(f));
    f[0] = 0;
    priority_queue&lt;node&gt;q;
    q.push({0,0});
    while(q.size())
    {
        node x = q.top();
        q.pop();
        if(vis[x.x])
        {
            continue;
        }
        vis[x.x] = 1;
        for(int i = 2;i&lt;=n;i++)
        {
            int v = (x.x+a[i])%a[1];
            if(f[v]&gt;f[x.x]+a[i])
            {
                f[v] = f[x.x]+a[i];
                q.push({v,f[v]});
            }
        }
    }
    long long ans = 0;
    for(int i = 0;i&lt;a[1];i++)
    {
        if(f[i]&lt;=m)
        {
            ans+=(m-f[i])/a[1]+1;
        }
    }
    printf("%lld",ans-1);
    return 0;
}
</code></pre>
<p><s><a href="https://www.luogu.com.cn/record/list?pid=U553673&amp;orderBy=1&amp;status=&amp;page=1" target="_blank" rel="noopener nofollow">结果稀里糊涂地拿到了最优解（不要看最快的提交，因为数据很水然后我没开 long long 结果过了，所以看第二快的提交）……</a></s></p>
<h4 id="p3403-跳楼机"><a href="https://www.luogu.com.cn/problem/P3403" target="_blank" rel="noopener nofollow">P3403 跳楼机</a></h4>
<p>只需要把 <span class="math inline">\(m\)</span> 减一（因为题目是从第 <span class="math inline">\(1\)</span> 层开始，然而我们的代码是从第 <span class="math inline">\(0\)</span> 层），然后正常套模板就行了。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5+5;
int a[N];
long long f[N];
int vis[N];
struct node
{
    int x;
    long long w;
    bool operator&lt;(const node&amp;a)const
    {
        return w&gt;a.w;
    }
};
signed main()
{
    int n = 3;
    long long m;
    scanf("%lld",&amp;m);
    m--;
    for(int i = 1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a[i]);
    }
    sort(a+1,a+n+1);
    memset(f,0x3f,sizeof(f));
    f[0] = 0;
    priority_queue&lt;node&gt;q;
    q.push({0,0});
    while(q.size())
    {
        node x = q.top();
        q.pop();
        if(vis[x.x])
        {
            continue;
        }
        vis[x.x] = 1;
        for(int i = 2;i&lt;=n;i++)
        {
            int v = (x.x+a[i])%a[1];
            if(f[v]&gt;f[x.x]+a[i])
            {
                f[v] = f[x.x]+a[i];
                q.push({v,f[v]});
            }
        }
    }
    long long ans = 0;
    for(int i = 0;i&lt;a[1];i++)
    {
        if(f[i]&lt;=m)
        {
            ans+=(m-f[i])/a[1]+1;
        }
    }
    printf("%lld",ans);
    return 0;
}
</code></pre>
<p>由于作者水平不行，所以只能做这些题，后面还会有更多例题，敬请期待！<br>
转圈背包由于<s>太难</s>，作者理解之后再更新！<br>
<s>但是似乎我发现转圈背包虽然理论上比同余最短路快，但是实际上效率远不如同余最短路，特别是在大数据，这是因为迪杰斯特拉在不被卡的情况下时间复杂度比 <span class="math inline">\(O(E \log V)\)</span> 快得多。</s></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0265968755625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-01 10:37">2025-05-01 09:44</span>&nbsp;
<a href="https://www.cnblogs.com/linjinkun">林晋堃</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18856114);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18856114', targetLink: 'https://www.cnblogs.com/linjinkun/p/18856114', title: '同余最短路&amp;amp;转圈背包算法学习笔记（超详细）' })">举报</a>
</div>
        