
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pikacq/p/18974346" title="发布于 2025-07-09 10:22">
    <span role="heading" aria-level="2">关于STM32 定时器预加载机制的个人实验总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="问题来源">问题来源：</h1>
<p>最近使用BLDC硬件COM时间做硬件换向，手册中提到“预加载”机制，然后网上了解一下 ，然后发现一文章，观点总结如下：<br>
<img alt="图片1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709093701734-94616852.png" class="lazyload"><br>
本身我是接受这个观点的，但是我点开了评论区，就疑惑了<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709093808594-338550846.png" class="lazyload"><br>
然后我决定试试：在实验之前，先搞清楚几个概念：定时器周期ARR值，<strong>更新事件发生时间点、修改周期值的时间点（这俩货很重要）</strong>、先产生更新事件，后进入更新中断。</p>
<hr>
<hr>
<h1 id="实验前准备">实验前准备：</h1>
<ul>
<li>芯片STM32G431C8T6，使用TIM1，通道1。定时器主频170MHz，初始化预分频值设置为17000，周期值设置为50000，通道1比较值设置为10000，配置为PWM1模式。修改arr值统一修改为20000。</li>
<li>解释：定时器周期初始化为5s，修改时修改为2s。用PWM来观察定时器周期变化，便于用示波器测量周期和观察结果。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709094214209-884414719.png" class="lazyload"></li>
</ul>
<h1 id="实验过程1">实验过程——1</h1>
<p>板子上电，TIM1初始化，开启定时器。更新中断里修改AAR值为20000，观察示波器上PWM波的情况并测量周期值。</p>
<h3 id="1-不使能预加载结果如下">1. 不使能预加载，结果如下：</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709094527214-1248990769.png" class="lazyload"><br>
结果显示更新中断回调里设置ARR = 20000之后，中断回调程序结束，TIM1周期变为2s，也就是开头贴的博主所说的这一句：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709094743752-121452180.png" class="lazyload"></p>
<h3 id="2-使能预加载结果如下">2. 使能预加载，结果如下：</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709094953367-555955857.png" class="lazyload"><br>
结果显示，在更新中断回调里更改ARR=20000，中断回调结束后依然是跑一个5s的周期之后，再变成2s，这里的结果也就对应这一句话：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709095031822-342412412.png" class="lazyload"></p>
<h3 id="总结">总结：</h3>
<p>为了防止语言歧义，我定义中断回调程序结束后的TIM跑的周期称为下一个周期。目前来看，原博主的总结是对的。<br>
但是但是！！！！！！！！其实问题的关键根本不是在不在更新中断里修改ARR值**</p>
<blockquote>
<ul>
<li>1.对于重装载寄存器的预加载来说，关键在于改变ARR的时间点和当前定时器的时间点（定时器的计数值）</li>
<li>2.对于比较寄存器的预加载来说，关键在于改变比较值的时间点和当前定时器的时间点（定时器的计数值）</li>
</ul>
</blockquote>
<hr>
<h1 id="实验过程2">实验过程——2</h1>
<p>接着验证，现在我把修改ARR的地方由更新中断里变成主循环之前，定时器初始化条件不变。</p>
<h3 id="1预加载使能同时修改值--定时器当前计数值">1.预加载使能，同时修改值 &gt; 定时器当前计数值</h3>
<blockquote>
<p>使能预加载的情况下，开启通道后紧接着修改ARR值为20000，这时TIM1的计数值还没有跑到20000（定时器计数很慢）<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100209036-1360318301.png" class="lazyload"><br>
结果为：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100237374-769724102.png" class="lazyload"><br>
<strong>结果显示，开启预加载情况下，修改ARR的值，跑完初始化设定的5s，在下一个周期变为2s。</strong></p>
</blockquote>
<h3 id="2预加载使能同时修改值--定时器当前计数值">2.预加载使能，同时修改值 &lt; 定时器当前计数值</h3>
<blockquote>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100509864-362478315.png" class="lazyload"><br>
在保证定时器计数已经超过25000的情况下，紧接着设置周期值为20000（程序我验证过，不存在已经跑过一个tim周期的情况存在），结果如下：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100715930-1820338138.png" class="lazyload"><br>
<strong>结果依然是在当前周期不生效，在下一个周期生效。所以在使能了预加载的情况在，生效时间永远是在发生更新事件后的下一个周期（手册也描述了，更新事件后才载入工作寄存器），而不论你更改ARR的时间点在哪里。</strong></p>
</blockquote>
<h3 id="3预加载失能同时修改值--定时器当前计数值">3.预加载失能，同时修改值 &gt; 定时器当前计数值</h3>
<blockquote>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100918595-938674202.png" class="lazyload"><br>
结果如下：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709100950527-1176998075.png" class="lazyload"><br>
<strong>结果显示，修改值立刻生效，这里先不下结论，先看最后一个实验</strong></p>
</blockquote>
<h3 id="4-预加载失能同时修改值--定时器当前计数值">4. 预加载失能，同时修改值 &lt; 定时器当前计数值</h3>
<blockquote>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709101112813-382484276.png" class="lazyload"><br>
结果如下：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709101138816-232170751.png" class="lazyload"><br>
<strong>结果显示，第一个周期跑到了TIM1计数器的最大值（65535，示波器没那么精确），既不是50000，也不是20000。</strong></p>
</blockquote>
<hr>
<hr>
<h1 id="终极结论">终极结论：</h1>
<h6 id="1-首先不要纠结于下个周期生效还是下下个周期生效这种模糊的说法直接忘掉ok">1. 首先不要纠结于下个周期生效还是下下个周期生效这种模糊的说法，直接忘掉OK？</h6>
<h6 id="2-使能重装载寄存器预加载的情况下不论修改arr值的时间点在哪结果都是在修改之后更新事件发生后的下一周期生效">2. 使能重装载寄存器预加载的情况下，不论修改ARR值的时间点在哪，结果都是在修改之后，更新事件发生后的下一周期生效。</h6>
<h6 id="3-在不使能预加载的情况下其实生效机制就是立刻生效但是要注意">3. 在不使能预加载的情况下，其实生效机制就是立刻生效，但是要注意：</h6>
<pre><code>1)修改值小于当前定时器的计数值（就是定时器已经跑过了这个修改点），修改后，本次周期会跑到该定时器的最大周期值(16位就是0xFFFF，32位就是0xFFFFFFFF)
2)修改值大于当前定时器的计数值（就是定时器还未跑过修改点），修改后，立刻生效，本次定时器周期就会变成修改值。
</code></pre>
<h6 id="4由于我比较关注的是比较通道的预加载所以同样也做了实验这里就不贴出来了结果是一样的依然是这个逻辑">4.由于我比较关注的是比较通道的预加载，所以同样也做了实验，这里就不贴出来了，结果是一样的，依然是这个逻辑。</h6>
<hr>
<hr>
<h5 id="最后再叨叨两句">最后再叨叨两句:</h5>
<p>回头看博主的话:<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2577861/202507/2577861-20250709101804612-185093885.png" class="lazyload"><br>
虽然我理解他的意思但是这种表述真的是很模糊的，在定时器更新中断回调里修改ARR，和在其他地方修改ARR两种情况所说的下一个定时器周期是一个概念吗？什么是下一个？什么是下下个？所以希望大家避免这种表述方式；</p>
<h1 id="把握住核心逻辑">把握住核心逻辑：</h1>
<h4 id="1-使能预加载修改arr更新事件发生新arr值生效">1. 使能预加载，修改ARR，更新事件发生，新ARR值生效</h4>
<h4 id="2-不使能预加载修改arr值立刻生效">2. 不使能预加载，修改ARR值，立刻生效</h4>
<h4 id="3-特殊情况记心里不使能预加载时有个特殊情况你懂的">3. 特殊情况记心里（不使能预加载时，有个特殊情况你懂的）</h4>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-07-09 10:23">2025-07-09 10:22</span>&nbsp;
<a href="https://www.cnblogs.com/pikacq">皮卡成球</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18974346);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18974346', targetLink: 'https://www.cnblogs.com/pikacq/p/18974346', title: '关于STM32 定时器预加载机制的个人实验总结' })">举报</a>
</div>
        