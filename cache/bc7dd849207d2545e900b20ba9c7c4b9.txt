
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/icutey/p/18889195" title="发布于 2025-05-21 15:55">
    <span role="heading" aria-level="2">多线程与并发-理论基础</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="lake-content">
<h1 id="PUjNc"><span class="ne-text">1 基础概念</span></h1>
<h2 id="idSGZ"><span class="ne-text">1.1 进程和线程</span></h2>
<h3 id="HmkoZ"><span class="ne-text">1.1.1 进程</span><span class="ne-text">（Process）</span></h3>
<p id="u1b717f90" class="ne-p"><strong><span class="ne-text">进程</span></strong><span class="ne-text">指的是程序在操作系统里的一次执行过程，它是系统进行资源分配和调度的基本单位。进程具备自己独立的内存空间、系统资源以及执行上下文。下面是进程的一些主要特点：</span></p>
<ol class="ne-ol">
<li id="udeef31e8" data-lake-index-type="0"><strong><span class="ne-text">独立性</span></strong><span class="ne-text">：不同的进程之间相互隔离，一个进程无法直接访问另一个进程的内存和资源。</span></li>
<li id="ud893d6c1" data-lake-index-type="0"><strong><span class="ne-text">资源分配</span></strong><span class="ne-text">：操作系统会给每个进程分配独立的内存区域、文件描述符等资源。</span></li>
<li id="uce9f286b" data-lake-index-type="0"><strong><span class="ne-text">重量级</span></strong><span class="ne-text">：进程的创建和销毁开销相对较大，因为需要进行内存分配和上下文切换。</span></li>
<li id="u98749402" data-lake-index-type="0"><strong><span class="ne-text">通信方式</span></strong><span class="ne-text">：进程间通信（IPC）要借助管道、消息队列、共享内存等机制来实现。</span></li>
</ol>
<p id="ua1a6023e" class="ne-p"><span class="ne-text">在 Java 中，可以通过</span><code class="ne-code"><span class="ne-text">ProcessBuilder</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">Runtime.getRuntime().exec()</span></code><span class="ne-text">方法来创建和控制外部进程。以下是一个简单的示例：</span></p>
<pre id="OG0MR" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProcessExample {
    public static void main(String[] args) {
        try {
            // 创建一个进程来执行系统命令（以Windows的ipconfig为例）
            Process process = Runtime.getRuntime().exec("ipconfig");
            
            // 获取进程的输出流并读取
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            
            // 等待进程执行完毕并获取返回值
            int exitCode = process.waitFor();
            System.out.println("进程退出码: " + exitCode);
            
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<h3 id="6a38f5a1"><span class="ne-text">1.1.2 线程（Thread）</span></h3>
<p id="uc8fe4373" class="ne-p"><span class="ne-text">线程是进程中的一个执行单元，也被称作轻量级进程。一个进程可以包含多个线程，这些线程共享进程的内存空间和系统资源，但各自拥有独立的程序计数器、栈空间和局部变量。线程的主要特点如下：</span></p>
<ol class="ne-ol">
<li id="ua7ec7a0b" data-lake-index-type="0"><strong><span class="ne-text">共享资源</span></strong><span class="ne-text">：同一进程内的线程可以共享堆内存、静态变量等资源。</span></li>
<li id="uaa918d6b" data-lake-index-type="0"><strong><span class="ne-text">轻量级</span></strong><span class="ne-text">：线程的创建和切换开销较小，因为不需要重新分配内存和系统资源。</span></li>
<li id="ucdbadb1f" data-lake-index-type="0"><strong><span class="ne-text">并发执行</span></strong><span class="ne-text">：在多核 CPU 环境下，多个线程能够实现真正的并行执行。</span></li>
<li id="u2f97c0aa" data-lake-index-type="0"><strong><span class="ne-text">同步问题</span></strong><span class="ne-text">：由于线程共享资源，所以需要通过同步机制（如</span><code class="ne-code"><span class="ne-text">synchronized</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">Lock</span></code><span class="ne-text">）来避免数据竞争和不一致的问题。</span></li>
</ol>
<p id="ub5244da8" class="ne-p"><span class="ne-text">在 Java 中，创建线程主要有两种方式：</span></p>
<ol class="ne-ol">
<li id="ucf390f8c" data-lake-index-type="0"><strong><span class="ne-text">继承 Thread 类</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="LxMg1" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("线程执行中: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程
        System.out.println("主线程执行中: " + Thread.currentThread().getName());
    }
}</code></pre>
<ol class="ne-ol" start="2">
<li id="u30f0b735" data-lake-index-type="0"><strong><span class="ne-text">实现 Runnable 接口</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="UBq7h" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行中: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // 启动线程
        System.out.println("主线程执行中: " + Thread.currentThread().getName());
    }
}</code></pre>
<h3 id="2e1246d3"><span class="ne-text">1.1.3 进程与线程的区别</span></h3>
<table id="gg7Tu" class="ne-table">
<tbody>
<tr>
<td width="154">
<p id="u2da82841" class="ne-p"><strong><span class="ne-text">比较维度</span></strong></p>
</td>
<td width="328">
<p id="uaee2a053" class="ne-p"><strong><span class="ne-text">进程</span></strong></p>
</td>
<td width="338">
<p id="uf5deda0e" class="ne-p"><strong><span class="ne-text">线程</span></strong></p>
</td>
</tr>
<tr>
<td width="154">
<p id="u3cf5057a" class="ne-p"><span class="ne-text">资源占用</span></p>
</td>
<td width="328">
<p id="u009fbe15" class="ne-p"><span class="ne-text">拥有独立的内存和系统资源</span></p>
</td>
<td width="338">
<p id="u7ffc1721" class="ne-p"><span class="ne-text">共享进程资源，仅拥有自己的栈和程序计数器</span></p>
</td>
</tr>
<tr>
<td width="154">
<p id="u6e317695" class="ne-p"><span class="ne-text">调度</span></p>
</td>
<td width="328">
<p id="ud53b2b56" class="ne-p"><span class="ne-text">进程是操作系统进行资源分配和调度的基本单位</span></p>
</td>
<td width="338">
<p id="u04af1312" class="ne-p"><span class="ne-text">线程是 CPU 调度和分派的基本单位</span></p>
</td>
</tr>
<tr>
<td width="154">
<p id="u1b1b286d" class="ne-p"><span class="ne-text">并发性</span></p>
</td>
<td width="328">
<p id="ue0cd41e8" class="ne-p"><span class="ne-text">不同进程之间可以并发执行</span></p>
</td>
<td width="338">
<p id="ua77078ab" class="ne-p"><span class="ne-text">同一进程内的多个线程可以并发执行</span></p>
</td>
</tr>
<tr>
<td width="154">
<p id="uc3fbd9de" class="ne-p"><span class="ne-text">通信方式</span></p>
</td>
<td width="328">
<p id="u47027d38" class="ne-p"><span class="ne-text">进程间通信（IPC），如管道、消息队列等</span></p>
</td>
<td width="338">
<p id="u907d35dd" class="ne-p"><span class="ne-text">直接共享内存，通过同步机制通信</span></p>
</td>
</tr>
<tr>
<td width="154">
<p id="uc0d9f034" class="ne-p"><span class="ne-text">上下文切换开销</span></p>
</td>
<td width="328">
<p id="u6f8a81f9" class="ne-p"><span class="ne-text">开销大</span></p>
</td>
<td width="338">
<p id="uc57c9144" class="ne-p"><span class="ne-text">开销小</span></p>
</td>
</tr>
<tr>
<td width="154">
<p id="ue0c1abdd" class="ne-p"><span class="ne-text">创建和销毁开销</span></p>
</td>
<td width="328">
<p id="ud5eab88c" class="ne-p"><span class="ne-text">开销大</span></p>
</td>
<td width="338">
<p id="ue604e59a" class="ne-p"><span class="ne-text">开销小</span></p>
</td>
</tr>
</tbody>
</table>
<h3 id="ESRML"><span class="ne-text">1.1.4 线程的生命周期</span></h3>
<p id="u8f603907" class="ne-p"><span class="ne-text">Java 线程的生命周期包含以下几种状态：</span></p>
<ol class="ne-ol">
<li id="u8fbaf77e" data-lake-index-type="0"><strong><span class="ne-text">新建（New）</span></strong><span class="ne-text">：线程对象被创建，但还没有调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法。</span></li>
<li id="ucd2b6242" data-lake-index-type="0"><strong><span class="ne-text">就绪（Runnable）</span></strong><span class="ne-text">：线程已经启动，正在等待 CPU 时间片。</span></li>
<li id="uc1257ad3" data-lake-index-type="0"><strong><span class="ne-text">运行（Running）</span></strong><span class="ne-text">：线程获得 CPU 执行权，正在执行</span><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法中的代码。</span></li>
<li id="ub71461a9" data-lake-index-type="0"><strong><span class="ne-text">阻塞（Blocked）</span></strong><span class="ne-text">：线程因为等待锁、IO 操作等原因暂时停止执行。</span></li>
<li id="u3dd45d4d" data-lake-index-type="0"><strong><span class="ne-text">等待（Waiting）</span></strong><span class="ne-text">：线程调用了</span><code class="ne-code"><span class="ne-text">wait()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">join()</span></code><span class="ne-text">等方法，进入无限期等待状态。</span></li>
<li id="ue14b8d70" data-lake-index-type="0"><strong><span class="ne-text">超时等待（Timed Waiting）</span></strong><span class="ne-text">：线程调用了</span><code class="ne-code"><span class="ne-text">wait(long)</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">sleep(long)</span></code><span class="ne-text">等方法，在指定时间后会自动恢复。</span></li>
<li id="u1383d4d1" data-lake-index-type="0"><strong><span class="ne-text">终止（Terminated）</span></strong><span class="ne-text">：线程的</span><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法执行完毕或者因为异常退出。</span></li>
</ol>
<h2 id="yqKdZ"><span class="ne-text">1.2 并发和并行</span></h2>
<h3 id="aUCjk"><span class="ne-text">1.2.1 并发（Concurrency）</span></h3>
<p id="u76abca58" class="ne-p"><span class="ne-text">并发是指在</span><strong><span class="ne-text">同一时间段内</span></strong><span class="ne-text">，系统能够处理多个任务的能力。这些任务在宏观上看似是同时执行的，但在微观层面，它们可能是交替执行的。并发的核心在于</span><strong><span class="ne-text">任务的切换和调度</span></strong><span class="ne-text">，通过快速切换执行上下文，让用户感觉多个任务在同时进行。</span></p>
<p id="ua271e792" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u4c512e66" data-lake-index-type="0"><span class="ne-text">多个任务在逻辑上同时执行，但物理上可能是串行的。</span></li>
<li id="u02610359" data-lake-index-type="0"><span class="ne-text">适用于 I/O 密集型场景（如网络请求、文件读写），因为任务在等待 I/O 时可以让出 CPU 资源。</span></li>
<li id="u93d88d76" data-lake-index-type="0"><span class="ne-text">通过线程、协程等轻量级执行单元实现。</span></li>
</ul>
<p id="u456d4516" class="ne-p"><strong><span class="ne-text">示例场景</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u7ac6e5dd" data-lake-index-type="0"><span class="ne-text">浏览器同时处理多个标签页的加载。</span></li>
<li id="u1dfc0ac4" data-lake-index-type="0"><span class="ne-text">服务器同时响应多个客户端请求。</span></li>
</ul>
<p id="uf1eb14b0" class="ne-p"><strong><span class="ne-text">Java 实现</span></strong><span class="ne-text">：</span></p>
<pre id="aKOe4" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrencyExample {
    public static void main(String[] args) {
        // 创建一个固定大小的线程池
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // 提交两个任务
        executor.submit(() -&gt; {
            for (int i = 0; i &lt; 3; i++) {
                System.out.println("任务1: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) {}
            }
        });
        
        executor.submit(() -&gt; {
            for (int i = 0; i &lt; 3; i++) {
                System.out.println("任务2: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) {}
            }
        });
        
        executor.shutdown();
    }
}</code></pre>
<p id="u161fbf23" class="ne-p"><span class="ne-text">输出可能是任务 1 和任务 2 交替执行，体现了并发的特性。</span></p>
<h3 id="oOcX9"><span class="ne-text">1.2.2 并行（Parallelism）</span></h3>
<p id="u4d4369ee" class="ne-p"><span class="ne-text">并行是指在</span><strong><span class="ne-text">同一时刻</span></strong><span class="ne-text">，系统能够真正同时执行多个任务的能力。并行需要依赖多核 CPU 等硬件资源，每个任务分配到独立的 CPU 核心上执行，不存在上下文切换的开销。</span></p>
<p id="uf4210f74" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u94b88cce" data-lake-index-type="0"><span class="ne-text">多个任务在物理上同时执行，需要多核 CPU 支持。</span></li>
<li id="u7f4f106f" data-lake-index-type="0"><span class="ne-text">适用于 CPU 密集型场景（如科学计算、图像处理），可以充分利用多核资源加速计算。</span></li>
<li id="u12da6157" data-lake-index-type="0"><span class="ne-text">通过多进程、多线程或 GPU 等方式实现。</span></li>
</ul>
<p id="u3e9cc454" class="ne-p"><strong><span class="ne-text">示例场景</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="ua2265c76" data-lake-index-type="0"><span class="ne-text">视频渲染时多个线程同时处理不同帧。</span></li>
<li id="u986ca73c" data-lake-index-type="0"><span class="ne-text">数据库并行查询多个分片数据。</span></li>
</ul>
<p id="ud10bd9df" class="ne-p"><strong><span class="ne-text">Java 实现</span></strong><span class="ne-text">：</span></p>
<pre id="fX3Pm" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

// 计算斐波那契数列的并行实现
class Fibonacci extends RecursiveTask&lt;Integer&gt; {
    final int n;
    Fibonacci(int n) { this.n = n; }

    @Override
    protected Integer compute() {
        if (n &lt;= 1)
            return n;
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();
        Fibonacci f2 = new Fibonacci(n - 2);
        return f2.compute() + f1.join();
    }
}

public class ParallelismExample {
    public static void main(String[] args) {
        ForkJoinPool pool = ForkJoinPool.commonPool();
        int result = pool.invoke(new Fibonacci(10));
        System.out.println("斐波那契数列第10项: " + result);
    }
}</code></pre>
<p id="ue15ed888" class="ne-p"><span class="ne-text">通过 Fork/Join 框架将任务分解为多个子任务并行执行。</span></p>
<h3 id="SgujE"><span class="ne-text">1.2.3 并发与并行的区别</span></h3>
<table id="jml0I" class="ne-table">
<tbody>
<tr>
<td width="169">
<p id="u6a088165" class="ne-p"><strong><span class="ne-text">比较维度</span></strong></p>
</td>
<td width="257">
<p id="u34c32190" class="ne-p"><strong><span class="ne-text">并发（Concurrency）</span></strong></p>
</td>
<td width="287">
<p id="ude590c14" class="ne-p"><strong><span class="ne-text">并行（Parallelism）</span></strong></p>
</td>
</tr>
<tr>
<td width="169">
<p id="u5f201c94" class="ne-p"><strong><span class="ne-text">核心思想</span></strong></p>
</td>
<td width="257">
<p id="u7e23bd77" class="ne-p"><span class="ne-text">处理多个任务的能力（任务切换）</span></p>
</td>
<td width="287">
<p id="ub9d213d0" class="ne-p"><span class="ne-text">同时执行多个任务的能力（物理并行）</span></p>
</td>
</tr>
<tr>
<td width="169">
<p id="u64133e90" class="ne-p"><strong><span class="ne-text">时间维度</span></strong></p>
</td>
<td width="257">
<p id="ua44ddd2b" class="ne-p"><span class="ne-text">宏观同时，微观交替</span></p>
</td>
<td width="287">
<p id="ue5c78826" class="ne-p"><span class="ne-text">真正的同时执行</span></p>
</td>
</tr>
<tr>
<td width="169">
<p id="u6a74a38f" class="ne-p"><strong><span class="ne-text">硬件依赖</span></strong></p>
</td>
<td width="257">
<p id="u1ab8ffaf" class="ne-p"><span class="ne-text">单核或多核 CPU 均可</span></p>
</td>
<td width="287">
<p id="uca643f2f" class="ne-p"><span class="ne-text">必须依赖多核 CPU</span></p>
</td>
</tr>
<tr>
<td width="169">
<p id="u967cb078" class="ne-p"><strong><span class="ne-text">应用场景</span></strong></p>
</td>
<td width="257">
<p id="u3d2df7ef" class="ne-p"><span class="ne-text">I/O 密集型任务（如 Web 服务器）</span></p>
</td>
<td width="287">
<p id="uf1049f96" class="ne-p"><span class="ne-text">CPU 密集型任务（如科学计算）</span></p>
</td>
</tr>
<tr>
<td width="169">
<p id="ufe64d959" class="ne-p"><strong><span class="ne-text">实现方式</span></strong></p>
</td>
<td width="257">
<p id="u87bfbb28" class="ne-p"><span class="ne-text">线程、协程、事件循环</span></p>
</td>
<td width="287">
<p id="u3b2065b5" class="ne-p"><span class="ne-text">多进程、多线程、GPU 计算</span></p>
</td>
</tr>
<tr>
<td width="169">
<p id="ua9e4d295" class="ne-p"><strong><span class="ne-text">目的</span></strong></p>
</td>
<td width="257">
<p id="u9ca38933" class="ne-p"><span class="ne-text">提高资源利用率，增强系统响应性</span></p>
</td>
<td width="287">
<p id="uc989ea42" class="ne-p"><span class="ne-text">加速计算，提升吞吐量</span></p>
</td>
</tr>
</tbody>
</table>
<h3 id="14a37233"><span class="ne-text">1.2.4 Java 中的并发与并行工具</span></h3>
<ol class="ne-ol">
<li id="ucd90c3ca" data-lake-index-type="0"><strong><span class="ne-text">线程池（ThreadPool）</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="jgpao" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>ExecutorService executor = Executors.newFixedThreadPool(10);</code></pre>
<ol class="ne-ol" start="2">
<li id="u5df4e597" data-lake-index-type="0"><strong><span class="ne-text">并行流（Parallel Stream）</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="e8upk" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.parallelStream()
                .mapToInt(Integer::intValue)
                .sum();</code></pre>
<ol class="ne-ol" start="3">
<li id="u6d0ca0d9" data-lake-index-type="0"><strong><span class="ne-text">CompletableFuture</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="tqZTs" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; "结果1");
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; "结果2");

CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(future1, future2);
allFutures.thenRun(() -&gt; {
    System.out.println(future1.join() + " " + future2.join());
});</code></pre>
<ol class="ne-ol" start="4">
<li id="ucc935af5" data-lake-index-type="0"><strong><span class="ne-text">Fork/Join 框架</span></strong><span class="ne-text">：</span></li>
</ol>
<pre id="sdqbD" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>ForkJoinPool pool = new ForkJoinPool();
RecursiveTask&lt;Integer&gt; task = new MyRecursiveTask(0, 1000);
int result = pool.invoke(task);</code></pre>
<h3 id="f872ff4a"><span class="ne-text">1.2.5 总结</span></h3>
<ul class="ne-ul">
<li id="u460bb838" data-lake-index-type="0"><strong><span class="ne-text">并发</span></strong><span class="ne-text">是一种编程模型，通过任务切换提高资源利用率，适合处理多任务的场景。</span></li>
<li id="u0018e135" data-lake-index-type="0"><strong><span class="ne-text">并行</span></strong><span class="ne-text">是一种物理实现，依赖多核硬件同时执行多个任务，适合加速计算。</span></li>
<li id="ucc6d1147" data-lake-index-type="0"><span class="ne-text">现代系统通常同时使用并发和并行：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u4d5c1e82" data-lake-index-type="0"><span class="ne-text">服务器通过并发处理大量客户端请求（如 Web 服务器）。</span></li>
<li id="uf4f631b0" data-lake-index-type="0"><span class="ne-text">计算密集型任务通过并行加速（如图像处理、机器学习）。</span></li>
</ul>
</ul>
<p id="udf05212d" class="ne-p"><span class="ne-text"><br><br></span></p>
<h2 id="Q5yqW"><span class="ne-text">1.3 同步和异步</span></h2>
<h3 id="07a3b877"><span class="ne-text">1.3.1 同步（Synchronous）</span></h3>
<p id="u632fa7d1" class="ne-p"><span class="ne-text">同步是指代码按照</span><strong><span class="ne-text">顺序依次执行</span></strong><span class="ne-text">的模式，每个操作必须等待前一个操作完成后才能开始。在同步编程中，调用者会</span><strong><span class="ne-text">阻塞</span></strong><span class="ne-text">直到被调用的操作执行完毕并返回结果。</span></p>
<p id="u94e034b4" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u4c332176" data-lake-index-type="0"><span class="ne-text">代码执行顺序明确，易于理解和调试。</span></li>
<li id="u084b7096" data-lake-index-type="0"><span class="ne-text">存在阻塞现象，可能导致程序在等待 I/O 时浪费 CPU 资源。</span></li>
<li id="u009265f6" data-lake-index-type="0"><span class="ne-text">适用于逻辑简单、依赖强的场景。</span></li>
</ul>
<p id="u89f425ce" class="ne-p"><strong><span class="ne-text">示例场景</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="uc553ac5e" data-lake-index-type="0"><span class="ne-text">读取文件后立即处理内容。</span></li>
<li id="u54aff252" data-lake-index-type="0"><span class="ne-text">发送 HTTP 请求后等待响应再继续执行。</span></li>
</ul>
<p id="uc16bb4dc" class="ne-p"><strong><span class="ne-text">Java 同步代码示例</span></strong><span class="ne-text">：</span></p>
<pre id="Ifd9q" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class SynchronousExample {
    public static void main(String[] args) {
        try {
            // 同步发送HTTP请求
            URL url = new URL("https://example.com");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            
            // 阻塞直到响应返回
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                }
            }
            
            // 响应处理完成后继续执行
            System.out.println("请求处理完毕，继续执行后续代码");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p id="u2ccd55e8" class="ne-p"><span class="ne-text">代码会阻塞在</span><code class="ne-code"><span class="ne-text">getInputStream()</span></code><span class="ne-text">直到服务器返回响应。</span></p>
<h3 id="9b254b11"><span class="ne-text">1.3.2 异步（Asynchronous）</span></h3>
<p id="uc920cd82" class="ne-p"><span class="ne-text">异步是指代码执行时不需要等待当前操作完成，而是可以</span><strong><span class="ne-text">继续执行后续代码</span></strong><span class="ne-text">，被调用的操作会在后台完成后通过回调、事件或 Future 等方式通知调用者。</span></p>
<p id="u5d6b4adf" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="ua06754de" data-lake-index-type="0"><span class="ne-text">非阻塞执行，提高程序的并发能力和响应速度。</span></li>
<li id="u702f5401" data-lake-index-type="0"><span class="ne-text">代码逻辑分散，可能增加理解和调试难度。</span></li>
<li id="u101124a7" data-lake-index-type="0"><span class="ne-text">适用于 I/O 密集型、耗时操作的场景。</span></li>
</ul>
<p id="ua2d3e251" class="ne-p"><strong><span class="ne-text">示例场景</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u09bec449" data-lake-index-type="0"><span class="ne-text">浏览器异步加载图片，同时不影响页面渲染。</span></li>
<li id="u5412ee5f" data-lake-index-type="0"><span class="ne-text">服务器异步处理请求，提高吞吐量。</span></li>
</ul>
<p id="ue3303fc5" class="ne-p"><strong><span class="ne-text">Java 异步代码示例（使用 CompletableFuture）</span></strong><span class="ne-text">：</span></p>
<pre id="qTic0" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class AsynchronousExample {
    public static void main(String[] args) {
        // 异步执行任务
        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
            try {
                // 模拟耗时操作
                Thread.sleep(2000);
                return "异步操作结果";
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        
        // 主线程继续执行
        System.out.println("主线程继续执行其他任务");
        
        // 注册回调函数
        future.thenAccept(result -&gt; {
            System.out.println("异步操作完成，结果: " + result);
        });
        
        // 可选：阻塞等待结果（如果需要）
        try {
            String result = future.get();
            System.out.println("获取到结果: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p id="u3b7734f5" class="ne-p"><span class="ne-text">主线程不会阻塞，可以继续执行其他任务，异步操作完成后通过</span><code class="ne-code"><span class="ne-text">thenAccept</span></code><span class="ne-text">回调通知。</span></p>
<h3 id="65706857"><span class="ne-text">1.3.3 同步与异步的区别</span></h3>
<table id="IwUeG" class="ne-table">
<tbody>
<tr>
<td width="115">
<p id="u37dbaafd" class="ne-p"><strong><span class="ne-text">比较维度</span></strong></p>
</td>
<td width="349">
<p id="uf6665940" class="ne-p"><strong><span class="ne-text">同步（Synchronous）</span></strong></p>
</td>
<td width="335">
<p id="u1e316aa9" class="ne-p"><strong><span class="ne-text">异步（Asynchronous）</span></strong></p>
</td>
</tr>
<tr>
<td width="115">
<p id="uce4d101c" class="ne-p"><strong><span class="ne-text">执行模式</span></strong></p>
</td>
<td width="349">
<p id="u02a65649" class="ne-p"><span class="ne-text">按顺序依次执行，前一个操作完成后才开始下一个</span></p>
</td>
<td width="335">
<p id="u7ceb6a90" class="ne-p"><span class="ne-text">不等待当前操作完成，继续执行后续代码</span></p>
</td>
</tr>
<tr>
<td width="115">
<p id="uff38632e" class="ne-p"><strong><span class="ne-text">阻塞特性</span></strong></p>
</td>
<td width="349">
<p id="ua2528d29" class="ne-p"><span class="ne-text">调用者会被阻塞直到操作完成</span></p>
</td>
<td width="335">
<p id="ua509677b" class="ne-p"><span class="ne-text">调用者不会被阻塞</span></p>
</td>
</tr>
<tr>
<td width="115">
<p id="u0dec4d1f" class="ne-p"><strong><span class="ne-text">响应性</span></strong></p>
</td>
<td width="349">
<p id="u4f7f0988" class="ne-p"><span class="ne-text">可能因等待耗时操作而降低整体响应性</span></p>
</td>
<td width="335">
<p id="u900c8f97" class="ne-p"><span class="ne-text">提高系统并发能力和响应速度</span></p>
</td>
</tr>
<tr>
<td width="115">
<p id="u63362af4" class="ne-p"><strong><span class="ne-text">代码复杂度</span></strong></p>
</td>
<td width="349">
<p id="u5014711e" class="ne-p"><span class="ne-text">逻辑简单，易于理解和调试</span></p>
</td>
<td width="335">
<p id="u6b5d212f" class="ne-p"><span class="ne-text">逻辑分散（回调、Future 等），调试难度较高</span></p>
</td>
</tr>
<tr>
<td width="115">
<p id="uaecbdd1c" class="ne-p"><strong><span class="ne-text">适用场景</span></strong></p>
</td>
<td width="349">
<p id="ucec64392" class="ne-p"><span class="ne-text">逻辑简单、依赖强的操作</span></p>
</td>
<td width="335">
<p id="u70e09f2f" class="ne-p"><span class="ne-text">I/O 密集型、耗时操作的场景</span></p>
</td>
</tr>
<tr>
<td width="115">
<p id="ud6eed68a" class="ne-p"><strong><span class="ne-text">资源利用</span></strong></p>
</td>
<td width="349">
<p id="ud6acdbc3" class="ne-p"><span class="ne-text">等待期间 CPU 资源浪费（尤其 I/O 操作）</span></p>
</td>
<td width="335">
<p id="u3e4aacee" class="ne-p"><span class="ne-text">等待期间 CPU 可处理其他任务</span></p>
</td>
</tr>
</tbody>
</table>
<h3 id="HGNPu"><span class="ne-text">1.3.4 异步编程模式</span></h3>
<p id="u50a354c9" class="ne-p"><span class="ne-text">常见的异步编程模式包括：</span></p>
<ol class="ne-ol">
<li id="u657f4cad" data-lake-index-type="0"><strong><span class="ne-text">回调函数（Callback）</span></strong><span class="ne-text">：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uf28a7a29" data-lake-index-type="0"><span class="ne-text">优点：简单直接。</span></li>
<li id="ubfb918fd" data-lake-index-type="0"><span class="ne-text">缺点：嵌套过深会导致 "回调地狱"（Callback Hell）。</span></li>
</ul>
</ul>
<pre id="afJwT" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>asyncOperation(param, (result, error) -&gt; {
    if (error != null) {
        // 处理错误
    } else {
        // 处理结果
    }
});</code></pre>
<ol class="ne-ol" start="2">
<li id="uafd4668e" data-lake-index-type="0"><strong><span class="ne-text">Future/Promise</span></strong><span class="ne-text">：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ue12f3617" data-lake-index-type="0"><span class="ne-text">优点：避免回调地狱，提供更优雅的结果获取方式。</span></li>
<li id="u8b531099" data-lake-index-type="0"><span class="ne-text">缺点：仍需显式处理阻塞（如调用</span><code class="ne-code"><span class="ne-text">get()</span></code><span class="ne-text">）。</span></li>
</ul>
</ul>
<pre id="VmJaS" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Future&lt;String&gt; future = executor.submit(() -&gt; {
    // 执行异步操作
    return "结果";
});

// 稍后获取结果（可能阻塞）
String result = future.get();</code></pre>
<ol class="ne-ol" start="3">
<li id="u77d62e2b" data-lake-index-type="0"><strong><span class="ne-text">CompletableFuture</span></strong><span class="ne-text">（Java 8+）：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ue29c4303" data-lake-index-type="0"><span class="ne-text">优点：支持链式调用、组合多个 Future、异常处理。</span></li>
<li id="ub49e7d09" data-lake-index-type="0"><span class="ne-text">示例见前文。</span></li>
</ul>
</ul>
<ol class="ne-ol" start="4">
<li id="ud9b836a0" data-lake-index-type="0"><strong><span class="ne-text">协程（Coroutine）</span></strong><span class="ne-text">：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u31bd1f73" data-lake-index-type="0"><span class="ne-text">优点：轻量级，避免线程切换开销，代码结构接近同步。</span></li>
<li id="u2c3f1363" data-lake-index-type="0"><span class="ne-text">示例（Java 19 + 虚拟线程）：</span></li>
</ul>
</ul>
<pre id="WFrSX" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread.startVirtualThread(() -&gt; {
    // 异步执行代码
    String result = performIO();
    System.out.println("结果: " + result);
});</code></pre>
<h3 id="dfc8d05b"><span class="ne-text">1.3.5 同步与异步的应用场景</span></h3>
<ol class="ne-ol">
<li id="u0a745aa4" data-lake-index-type="0"><strong><span class="ne-text">同步适用场景</span></strong><span class="ne-text">：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uc5f93c64" data-lake-index-type="0"><span class="ne-text">操作之间存在强依赖关系（如数据库事务）。</span></li>
<li id="u53b97666" data-lake-index-type="0"><span class="ne-text">资源竞争严重，需要严格顺序执行。</span></li>
<li id="uc4ac83b1" data-lake-index-type="0"><span class="ne-text">简单业务逻辑，无需高并发。</span></li>
</ul>
</ul>
<ol class="ne-ol" start="2">
<li id="uacde00ed" data-lake-index-type="0"><strong><span class="ne-text">异步适用场景</span></strong><span class="ne-text">：</span></li>
</ol>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ua397b5fd" data-lake-index-type="0"><span class="ne-text">I/O 密集型操作（如网络请求、文件读写）。</span></li>
<li id="u96cf6774" data-lake-index-type="0"><span class="ne-text">耗时计算（如大数据处理、AI 推理）。</span></li>
<li id="u17f0824d" data-lake-index-type="0"><span class="ne-text">需要高吞吐量的场景（如 Web 服务器、消息队列）。</span></li>
<li id="ub22b54a6" data-lake-index-type="0"><span class="ne-text">用户界面响应性要求高的场景（如前端交互、移动应用）。</span></li>
</ul>
</ul>
<h3 id="e5dfad28"><span class="ne-text">1.3.4 总结</span></h3>
<ul class="ne-ul">
<li id="u9240aa93" data-lake-index-type="0"><strong><span class="ne-text">同步</span></strong><span class="ne-text">是代码按顺序执行的模式，简单直观但可能导致阻塞。</span></li>
<li id="u571708bc" data-lake-index-type="0"><strong><span class="ne-text">异步</span></strong><span class="ne-text">是非阻塞执行模式，通过回调、Future 等机制提高并发和响应性。</span></li>
<li id="ubcca5ff1" data-lake-index-type="0"><span class="ne-text">现代应用通常结合使用同步和异步：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u0150b6b2" data-lake-index-type="0"><span class="ne-text">核心业务逻辑使用同步保证正确性和可维护性。</span></li>
<li id="u1c1aa4e8" data-lake-index-type="0"><span class="ne-text">I/O 密集型操作使用异步提高性能。</span></li>
</ul>
</ul>
<h1 id="eUy0q"><span class="ne-text">2 线程创建方式</span></h1>
<h2 id="Fftwy"><span class="ne-text">2.1 继承 Thread 类</span></h2>
<p id="ub059e367" class="ne-p"><strong><span class="ne-text">实现步骤</span></strong><span class="ne-text">：</span></p>
<ol class="ne-ol">
<li id="uf66e38f6" data-lake-index-type="0"><span class="ne-text">创建一个类，继承自</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">类。</span></li>
<li id="uc4f07095" data-lake-index-type="0"><span class="ne-text">重写</span><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法，在这个方法里定义线程要执行的任务。</span></li>
<li id="ucdca9f32" data-lake-index-type="0"><span class="ne-text">创建该类的实例，然后调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法启动线程。</span></li>
</ol>
<p id="uae9e7e4e" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="YMuzb" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(Thread.currentThread().getName() + " 执行: " + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        
        thread1.start();
        thread2.start();
    }
}</code></pre>
<p id="u2fe5d359" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u5a2de1c5" data-lake-index-type="0"><span class="ne-text">编码较为简单，直接继承</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">类就行。</span></li>
<li id="u881e377f" data-lake-index-type="0"><span class="ne-text">由于 Java 是单继承，继承了</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">类后就不能再继承其他类，这会限制代码的扩展性。</span></li>
<li id="u7b6f0e59" data-lake-index-type="0"><span class="ne-text">线程和任务是耦合在一起的，线程的逻辑被封装在</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">子类中。</span></li>
</ul>
<h2 id="rKh41"><span class="ne-text">2.2 实现 Runnable 接口</span></h2>
<p id="u15eefa22" class="ne-p"><strong><span class="ne-text">实现步骤</span></strong><span class="ne-text">：</span></p>
<ol class="ne-ol">
<li id="uccdc9ff5" data-lake-index-type="0"><span class="ne-text">创建一个类，实现</span><code class="ne-code"><span class="ne-text">Runnable</span></code><span class="ne-text">接口。</span></li>
<li id="u18cd0d5c" data-lake-index-type="0"><span class="ne-text">实现</span><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法，在其中定义任务逻辑。</span></li>
<li id="u0ef49740" data-lake-index-type="0"><span class="ne-text">创建</span><code class="ne-code"><span class="ne-text">Runnable</span></code><span class="ne-text">实现类的实例，将其作为参数传递给</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">类的构造函数。</span></li>
<li id="u1e2a4eda" data-lake-index-type="0"><span class="ne-text">调用</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">实例的</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法启动线程。</span></li>
</ol>
<p id="u77b7adfc" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="Hpucb" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(Thread.currentThread().getName() + " 执行: " + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        MyRunnable task = new MyRunnable();
        Thread thread1 = new Thread(task, "线程1");
        Thread thread2 = new Thread(task, "线程2");
        
        thread1.start();
        thread2.start();
    }
}</code></pre>
<p id="u0e90afc1" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u9233d450" data-lake-index-type="0"><span class="ne-text">避免了单继承的限制，实现类还能继承其他类并实现多个接口。</span></li>
<li id="uebd72016" data-lake-index-type="0"><span class="ne-text">任务和线程是分离的，符合面向对象的设计原则，提高了代码的可复用性。</span></li>
<li id="u9dbde64f" data-lake-index-type="0"><span class="ne-text">推荐使用这种方式，因为它更灵活，能更好地体现 "数据与逻辑分离" 的思想。</span></li>
</ul>
<h2 id="oB8CU"><span class="ne-text">2.3 实现 Callable 接口</span></h2>
<p id="u4c11023c" class="ne-p"><strong><span class="ne-text">实现步骤</span></strong><span class="ne-text">：</span></p>
<ol class="ne-ol">
<li id="u435c3311" data-lake-index-type="0"><span class="ne-text">创建一个类，实现</span><code class="ne-code"><span class="ne-text">Callable&lt;V&gt;</span></code><span class="ne-text">接口，这里的</span><code class="ne-code"><span class="ne-text">V</span></code><span class="ne-text">是返回值的类型。</span></li>
<li id="u78f85d5c" data-lake-index-type="0"><span class="ne-text">实现</span><code class="ne-code"><span class="ne-text">call()</span></code><span class="ne-text">方法，该方法可以有返回值，并且能够抛出异常。</span></li>
<li id="uf13098c9" data-lake-index-type="0"><span class="ne-text">创建</span><code class="ne-code"><span class="ne-text">Callable</span></code><span class="ne-text">实现类的实例，把它包装到</span><code class="ne-code"><span class="ne-text">FutureTask</span></code><span class="ne-text">中。</span></li>
<li id="u64ca4f1c" data-lake-index-type="0"><span class="ne-text">将</span><code class="ne-code"><span class="ne-text">FutureTask</span></code><span class="ne-text">实例作为参数传递给</span><code class="ne-code"><span class="ne-text">Thread</span></code><span class="ne-text">类的构造函数。</span></li>
<li id="ue69bc3a8" data-lake-index-type="0"><span class="ne-text">调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法启动线程，通过</span><code class="ne-code"><span class="ne-text">FutureTask</span></code><span class="ne-text">的</span><code class="ne-code"><span class="ne-text">get()</span></code><span class="ne-text">方法获取返回值。</span></li>
</ol>
<p id="u095b0711" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="DaDi3" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.*;

public class MyCallable implements Callable&lt;Integer&gt; {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i &lt;= 100; i++) {
            sum += i;
        }
        return sum;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable task = new MyCallable();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);
        Thread thread = new Thread(futureTask);
        
        thread.start();
        
        // 获取任务的返回值（会阻塞，直到任务完成）
        Integer result = futureTask.get();
        System.out.println("计算结果: " + result);
    }
}</code></pre>
<p id="u50e28828" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u9cd6ef25" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">call()</span></code><span class="ne-text">方法支持返回值，还能抛出受检查异常。</span></li>
<li id="u9505626d" data-lake-index-type="0"><span class="ne-text">通过</span><code class="ne-code"><span class="ne-text">FutureTask</span></code><span class="ne-text">可以获取异步计算的结果，在需要处理返回值的场景中很有用。</span></li>
<li id="u78a2664a" data-lake-index-type="0"><span class="ne-text">适用于需要返回执行结果的异步任务。</span></li>
</ul>
<h2 id="mdfU2"><span class="ne-text">2.4 使用 CompletableFuture（Java 8+）</span></h2>
<p id="ua8af2881" class="ne-p"><strong><span class="ne-text">实现步骤</span></strong><span class="ne-text">：</span></p>
<ol class="ne-ol">
<li id="u99ae7cf8" data-lake-index-type="0"><span class="ne-text">通过</span><code class="ne-code"><span class="ne-text">CompletableFuture</span></code><span class="ne-text">的静态方法创建异步任务。</span></li>
<li id="uc19731df" data-lake-index-type="0"><span class="ne-text">可以使用</span><code class="ne-code"><span class="ne-text">thenApply()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">thenAccept()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">thenCompose()</span></code><span class="ne-text">等方法进行链式操作。</span></li>
<li id="ucf8fb59f" data-lake-index-type="0"><span class="ne-text">可以使用</span><code class="ne-code"><span class="ne-text">join()</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">get()</span></code><span class="ne-text">方法获取结果。</span></li>
</ol>
<p id="u7efbb406" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="BkmU8" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class CompletableFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建异步任务
        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "异步操作结果";
        });
        
        // 链式操作：转换结果
        CompletableFuture&lt;String&gt; processedFuture = future.thenApply(result -&gt; {
            return result.toUpperCase();
        });
        
        // 异步回调：结果处理完成后执行
        processedFuture.thenAccept(finalResult -&gt; {
            System.out.println("最终结果: " + finalResult);
        });
        
        // 阻塞获取结果（如果需要）
        System.out.println("等待结果...");
        System.out.println(processedFuture.get());
    }
}</code></pre>
<p id="u863f6305" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="ueffd494b" data-lake-index-type="0"><span class="ne-text">提供了函数式编程风格，支持链式调用，代码更加简洁。</span></li>
<li id="u12f3f507" data-lake-index-type="0"><span class="ne-text">内置了线程池管理，默认使用</span><code class="ne-code"><span class="ne-text">ForkJoinPool.commonPool()</span></code><span class="ne-text">。</span></li>
<li id="u6ab37261" data-lake-index-type="0"><span class="ne-text">支持组合多个异步任务，如</span><code class="ne-code"><span class="ne-text">allOf()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">anyOf()</span></code><span class="ne-text">等。</span></li>
<li id="ua1f1b1d6" data-lake-index-type="0"><span class="ne-text">适合复杂的异步流程编排，如并行执行多个任务然后合并结果。</span></li>
</ul>
<h2 id="niceR"><span class="ne-text">2.5 使用虚拟线程（Virtual Threads，Java 19 +）</span></h2>
<p id="u0070a02d" class="ne-p"><strong><span class="ne-text">实现步骤</span></strong><span class="ne-text">：</span></p>
<ol class="ne-ol">
<li id="u67d2c2a7" data-lake-index-type="0"><span class="ne-text">创建</span><code class="ne-code"><span class="ne-text">Runnable</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">Callable</span></code><span class="ne-text">任务。</span></li>
<li id="u08210413" data-lake-index-type="0"><span class="ne-text">通过</span><code class="ne-code"><span class="ne-text">Thread.startVirtualThread()</span></code><span class="ne-text">方法启动虚拟线程。</span></li>
<li id="u744f3f19" data-lake-index-type="0"><span class="ne-text">虚拟线程会在平台线程上运行，由 JVM 自动管理。</span></li>
</ol>
<p id="ud2f8a7df" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="kXYzL" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class VirtualThreadExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建大量虚拟线程
        for (int i = 0; i &lt; 1000; i++) {
            final int taskId = i;
            Thread.startVirtualThread(() -&gt; {
                System.out.println("虚拟线程 " + taskId + " 开始执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("虚拟线程 " + taskId + " 执行完毕");
            });
        }
        
        // 主线程等待所有虚拟线程完成
        Thread.sleep(5000);
    }
}</code></pre>
<p id="u5c24924b" class="ne-p"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></p>
<ul class="ne-ul">
<li id="u910ca90e" data-lake-index-type="0"><span class="ne-text">虚拟线程是轻量级的线程，由 JVM 管理，创建和销毁的成本极低。</span></li>
<li id="ub1a53b86" data-lake-index-type="0"><span class="ne-text">非常适合高并发、I/O 密集型的场景，能显著提高系统吞吐量。</span></li>
<li id="u32ef010c" data-lake-index-type="0"><span class="ne-text">与传统线程 API 兼容，使用方式和普通线程类似。</span></li>
<li id="u22d395de" data-lake-index-type="0"><span class="ne-text">需要 Java 19 及以上版本，并且启用</span><code class="ne-code"><span class="ne-text">--enable-preview</span></code><span class="ne-text">选项。</span></li>
</ul>
<h2 id="EXCTa"><span class="ne-text">七、各种线程创建方式的对比</span></h2>
<table id="WfuQv" class="ne-table">
<tbody>
<tr>
<td width="125">
<p id="uf9ef06f3" class="ne-p"><strong><span class="ne-text">创建方式</span></strong></p>
</td>
<td width="125">
<p id="u4dfc5c38" class="ne-p"><strong><span class="ne-text">是否有返回值</span></strong></p>
</td>
<td width="125">
<p id="u1049fd99" class="ne-p"><strong><span class="ne-text">是否支持异常抛出</span></strong></p>
</td>
<td width="125">
<p id="u6151ef0a" class="ne-p"><strong><span class="ne-text">是否支持多继承</span></strong></p>
</td>
<td width="125">
<p id="uc13d0d29" class="ne-p"><strong><span class="ne-text">线程管理难度</span></strong></p>
</td>
<td width="125">
<p id="ufe4122ef" class="ne-p"><strong><span class="ne-text">适用场景</span></strong></p>
</td>
</tr>
<tr>
<td width="125">
<p id="u64c3d4a4" class="ne-p"><span class="ne-text">继承 Thread 类</span></p>
</td>
<td width="125">
<p id="u69c5410d" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="125">
<p id="u75cd22e1" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="125">
<p id="u062d8daf" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="125">
<p id="uc827e974" class="ne-p"><span class="ne-text">简单</span></p>
</td>
<td width="125">
<p id="u158c8eb2" class="ne-p"><span class="ne-text">简单任务，不考虑扩展性</span></p>
</td>
</tr>
<tr>
<td width="125">
<p id="ud9719c00" class="ne-p"><span class="ne-text">实现 Runnable 接口</span></p>
</td>
<td width="125">
<p id="ud2f43254" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="125">
<p id="u49c92fd6" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="125">
<p id="u297a367a" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u1e3e8ab9" class="ne-p"><span class="ne-text">简单</span></p>
</td>
<td width="125">
<p id="u74305416" class="ne-p"><span class="ne-text">任务与线程分离的场景</span></p>
</td>
</tr>
<tr>
<td width="125">
<p id="u1d7e8dde" class="ne-p"><span class="ne-text">实现 Callable 接口</span></p>
</td>
<td width="125">
<p id="u71d156e0" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u4b28af8f" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u63d8c686" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u4761ed6a" class="ne-p"><span class="ne-text">中等</span></p>
</td>
<td width="125">
<p id="u0ec9d4dc" class="ne-p"><span class="ne-text">需要返回值的异步任务</span></p>
</td>
</tr>
<tr>
<td width="125">
<p id="ubc228593" class="ne-p"><span class="ne-text">CompletableFuture</span></p>
</td>
<td width="125">
<p id="u2ec218a4" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u9654a917" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="ubcdf28be" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u68182b11" class="ne-p"><span class="ne-text">中等</span></p>
</td>
<td width="125">
<p id="u4b7dafd4" class="ne-p"><span class="ne-text">复杂异步流程编排</span></p>
</td>
</tr>
<tr>
<td width="125">
<p id="ub5408c57" class="ne-p"><span class="ne-text">虚拟线程（Java 19+）</span></p>
</td>
<td width="125">
<p id="u088b94ca" class="ne-p"><span class="ne-text">支持（通过 Future）</span></p>
</td>
<td width="125">
<p id="u0cab06b9" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="u481536dc" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="125">
<p id="uc98777a6" class="ne-p"><span class="ne-text">简单</span></p>
</td>
<td width="125">
<p id="ucbbdaed0" class="ne-p"><span class="ne-text">高并发、I/O 密集型场景</span></p>
</td>
</tr>
</tbody>
</table>
<h1 id="JRXcp"><span class="ne-text">3 线程常用方法</span></h1>
<h2 id="S9XVF"><span class="ne-text">3.1 总览</span></h2>
<table id="CaNA4" class="ne-table">
<tbody>
<tr>
<td width="330">
<p id="uefc54ae0" class="ne-p"><span class="ne-text">方法</span></p>
</td>
<td width="737">
<p id="ub8501c2e" class="ne-p"><span class="ne-text">说明</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u4f9b9794" class="ne-p"><span class="ne-text">public void </span><strong><span class="ne-text">start</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u1a689d26" class="ne-p"><span class="ne-text">启动一个新线程，Java虚拟机调用此线程的 run 方法</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u576b5b35" class="ne-p"><span class="ne-text">public void </span><strong><span class="ne-text">run</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="ufcdfe7ed" class="ne-p"><span class="ne-text">线程启动后调用该方法</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u1858a794" class="ne-p"><span class="ne-text">public void </span><strong><span class="ne-text">setName</span></strong><span class="ne-text">(String name)</span></p>
</td>
<td width="737">
<p id="u579cb6f8" class="ne-p"><span class="ne-text">给当前线程取名字</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="uc7dd2cd3" class="ne-p"><span class="ne-text">public void </span><strong><span class="ne-text">getName</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u3e0f649b" class="ne-p"><span class="ne-text">获取当前线程的名字<br></span><span class="ne-text">线程存在默认名称：子线程是 Thread-索引，主线程是 main</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u2cde63f0" class="ne-p"><span class="ne-text">public static Thread </span><strong><span class="ne-text">currentThread</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u31f811a8" class="ne-p"><span class="ne-text">获取当前线程对象，代码在哪个线程中执行</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u69043e06" class="ne-p"><span class="ne-text">public static void </span><strong><span class="ne-text">sleep</span></strong><span class="ne-text">(long time)</span></p>
</td>
<td width="737">
<p id="u73e98864" class="ne-p"><span class="ne-text">让当前线程休眠多少毫秒再继续执行<br></span><strong><span class="ne-text">Thread.sleep(0)</span></strong> <span class="ne-text">: 让操作系统立刻重新进行一次 CPU 竞争</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="ubbf64b8a" class="ne-p"><span class="ne-text">public static native void </span><strong><span class="ne-text">yield</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u6d39cdb4" class="ne-p"><span class="ne-text">提示线程调度器让出当前线程对 CPU 的使用</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u2f4a5339" class="ne-p"><span class="ne-text">public final int </span><strong><span class="ne-text">getPriority</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u69bcca79" class="ne-p"><span class="ne-text">返回此线程的优先级</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u0142b5ae" class="ne-p"><span class="ne-text">public final void </span><strong><span class="ne-text">setPriority</span></strong><span class="ne-text">(int priority)</span></p>
</td>
<td width="737">
<p id="uaf7e0ae8" class="ne-p"><span class="ne-text">更改此线程的优先级，常用 1 5 10</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u81804ee9" class="ne-p"><span class="ne-text">public void </span><strong><span class="ne-text">interrupt</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u2c2c9bb5" class="ne-p"><span class="ne-text">中断这个线程，异常处理机制</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="ucf139268" class="ne-p"><span class="ne-text">public static boolean </span><strong><span class="ne-text">interrupted</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="ufb74753f" class="ne-p"><span class="ne-text">判断当前线程是否被打断，清除打断标记</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u176dddcf" class="ne-p"><span class="ne-text">public boolean </span><strong><span class="ne-text">isInterrupted</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u5074f029" class="ne-p"><span class="ne-text">判断当前线程是否被打断，不清除打断标记</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u2873c7ad" class="ne-p"><span class="ne-text">public final void </span><strong><span class="ne-text">join</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u2aa42004" class="ne-p"><span class="ne-text">等待这个线程结束</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="uf205fbe7" class="ne-p"><span class="ne-text">public final void </span><strong><span class="ne-text">join</span></strong><span class="ne-text">(long millis)</span></p>
</td>
<td width="737">
<p id="uf424a4c3" class="ne-p"><span class="ne-text">等待这个线程死亡 millis 毫秒，0 意味着永远等待</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u9f62eb9f" class="ne-p"><span class="ne-text">public final native boolean </span><strong><span class="ne-text">isAlive</span></strong><span class="ne-text">()</span></p>
</td>
<td width="737">
<p id="u2bbe8a9d" class="ne-p"><span class="ne-text">线程是否存活（还没有运行完毕）</span></p>
</td>
</tr>
<tr>
<td width="330">
<p id="u003c4ab1" class="ne-p"><span class="ne-text">public final void </span><strong><span class="ne-text">setDaemon</span></strong><span class="ne-text">(boolean on)</span></p>
</td>
<td width="737">
<p id="u03103d91" class="ne-p"><span class="ne-text">将此线程标记为守护线程或用户线程</span></p>
</td>
</tr>
</tbody>
</table>
<p id="ua678ac8e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2025/png/34109461/1747538121414-6641e992-d97f-46ab-92de-fc83970b5316.png" class="ne-image" width="893"></p>
<h2 id="efMDT"><span class="ne-text">3.2 线程创建与启动</span></h2>
<h4 id="1."><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public void start()</span></code></h4>
<ul class="ne-ul">
<li id="uc5fdce23" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：启动线程，使线程进入就绪状态（等待 CPU 调度），并自动调用</span><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法。</span></li>
<li id="ubd25e94c" data-lake-index-type="0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u0f42c7aa" data-lake-index-type="0"><span class="ne-text">每个线程只能调用一次</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">，重复调用会抛出</span><code class="ne-code"><span class="ne-text">IllegalThreadStateException</span></code><span class="ne-text">。</span></li>
<li id="u53a793df" data-lake-index-type="0"><strong><span class="ne-text">不要直接调用</span></strong><code class="ne-code"><strong><span class="ne-text">run()</span></strong></code><strong><span class="ne-text">方法</span></strong><span class="ne-text">，否则只是普通的方法调用，不会创建新线程。</span></li>
</ul>
</ul>
<p id="uc43c9956" class="ne-p"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></p>
<pre id="r7c5A" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread(() -&gt; System.out.println("线程执行"));
t.start(); // 正确：启动新线程
// t.start(); // 错误：重复调用</code></pre>
<h2 id="EN1To"><span class="ne-text">3.3 线程状态控制</span></h2>
<h4 id="1.--1"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public static void sleep(long millis)</span></code></h4>
<ul class="ne-ul">
<li id="u3acfed01" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：让当前线程暂停执行指定时间（毫秒），进入</span><strong><span class="ne-text">TIMED_WAITING</span></strong><span class="ne-text">状态。</span></li>
<li id="u10ca9cbb" data-lake-index-type="0"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ue7fe260b" data-lake-index-type="0"><span class="ne-text">不释放锁（若持有锁）。</span></li>
<li id="u4929fc14" data-lake-index-type="0"><span class="ne-text">可被中断（</span><code class="ne-code"><span class="ne-text">interrupt()</span></code><span class="ne-text">），抛出</span><code class="ne-code"><span class="ne-text">InterruptedException</span></code><span class="ne-text">。</span></li>
</ul>
</ul>
<p id="u048ae481" class="ne-p"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></p>
<pre id="R7mip" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>try {
    Thread.sleep(1000); // 暂停1秒
} catch (InterruptedException e) {
    e.printStackTrace();
}</code></pre>
<h4 id="2."><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">public static void yield()</span></code></h4>
<ul class="ne-ul">
<li id="u06a4089b" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：当前线程让出 CPU 时间片，进入</span><strong><span class="ne-text">RUNNABLE</span></strong><span class="ne-text">状态，允许其他线程执行。</span></li>
<li id="u66b8b832" data-lake-index-type="0"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ud9bdcafe" data-lake-index-type="0"><span class="ne-text">仅为建议，操作系统可能忽略。</span></li>
<li id="u22e7f1b6" data-lake-index-type="0"><span class="ne-text">不释放锁。</span></li>
<li id="u2747dda2" data-lake-index-type="0"><span class="ne-text">与</span><code class="ne-code"><span class="ne-text">sleep(0)</span></code><span class="ne-text">类似，但语义更明确。</span></li>
</ul>
</ul>
<h4 id="faf9db79"><span class="ne-text">3.</span> <code class="ne-code"><span class="ne-text">public final void join()</span></code> <span class="ne-text">/</span> <code class="ne-code"><span class="ne-text">join(long millis)</span></code></h4>
<ul class="ne-ul">
<li id="u8d0149c7" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：等待当前线程终止（或指定时间）。常用于主线程等待子线程完成。</span></li>
<li id="u3d121ee7" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="vGjtD" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread(() -&gt; {
    // 子线程任务
});
t.start();
t.join(); // 主线程阻塞，直到t执行完毕</code></pre>
<h2 id="h2NM7"><span class="ne-text">3.4 线程中断</span></h2>
<h4 id="1.--2"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public void interrupt()</span></code></h4>
<ul class="ne-ul">
<li id="u8dc647a4" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：中断线程（设置中断标志位）。</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ua105f939" data-lake-index-type="0"><span class="ne-text">若线程处于</span><code class="ne-code"><span class="ne-text">sleep()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">wait()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">join()</span></code><span class="ne-text">等阻塞状态，会抛出</span><code class="ne-code"><span class="ne-text">InterruptedException</span></code><span class="ne-text">并清除标志位。</span></li>
<li id="u01212a64" data-lake-index-type="0"><span class="ne-text">若线程正常运行，仅设置标志位，需通过</span><code class="ne-code"><span class="ne-text">isInterrupted()</span></code><span class="ne-text">检测。</span></li>
</ul>
</ul>
<h4 id="2.--1"><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">public boolean isInterrupted()</span></code></h4>
<ul class="ne-ul">
<li id="u9e830865" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：检测线程是否被中断（不清除标志位）。</span></li>
</ul>
<h4 id="3."><span class="ne-text">3.</span> <code class="ne-code"><span class="ne-text">public static boolean interrupted()</span></code></h4>
<ul class="ne-ul">
<li id="ud4921185" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：检测当前线程是否被中断，并</span><strong><span class="ne-text">清除中断标志位</span></strong><span class="ne-text">。</span></li>
</ul>
<p id="udce82eda" class="ne-p"><strong><span class="ne-text">正确处理中断的示例</span></strong><span class="ne-text">：</span></p>
<pre id="QcqA3" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread(() -&gt; {
    while (!Thread.currentThread().isInterrupted()) {
        try {
            // 执行任务
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // 重置中断标志位，以便退出循环
            Thread.currentThread().interrupt();
            break;
        }
    }
});
t.start();
t.interrupt(); // 中断线程</code></pre>
<h2 id="EGJ3f"><span class="ne-text">3.5 线程优先级</span></h2>
<h4 id="1.--3"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public final void setPriority(int newPriority)</span></code></h4>
<ul class="ne-ul">
<li id="uebb79884" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：设置线程优先级（1-10），默认 5。</span></li>
<li id="udaf66558" data-lake-index-type="0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ub2ccd7d5" data-lake-index-type="0"><span class="ne-text">优先级高的线程理论上更可能被 CPU 调度，但依赖操作系统实现（如 Windows 和 Linux 对优先级的处理不同）。</span></li>
<li id="u04811ae4" data-lake-index-type="0"><span class="ne-text">不建议过度依赖优先级控制线程执行顺序。</span></li>
</ul>
</ul>
<p id="uc25eebbb" class="ne-p"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></p>
<pre id="LBm4A" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread();
t.setPriority(Thread.MAX_PRIORITY); // 10
t.setPriority(Thread.MIN_PRIORITY); // 1
t.setPriority(Thread.NORM_PRIORITY); // 5（默认）</code></pre>
<h2 id="UINce"><span class="ne-text">3.6 线程状态查询</span></h2>
<h4 id="1.--4"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public Thread.State getState()</span></code></h4>
<ul class="ne-ul">
<li id="u832556dc" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：获取线程的当前状态（枚举类型</span><code class="ne-code"><span class="ne-text">Thread.State</span></code><span class="ne-text">），包括：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uc9916b25" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">NEW</span></strong></code><span class="ne-text">：新建（未调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">）。</span></li>
<li id="uc5cb61c4" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">RUNNABLE</span></strong></code><span class="ne-text">：就绪或运行中。</span></li>
<li id="udb0a15d9" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">BLOCKED</span></strong></code><span class="ne-text">：等待锁。</span></li>
<li id="u4b0b7e5d" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">WAITING</span></strong></code><span class="ne-text">：无限期等待（如</span><code class="ne-code"><span class="ne-text">wait()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">join()</span></code><span class="ne-text">）。</span></li>
<li id="u7a747c60" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">TIMED_WAITING</span></strong></code><span class="ne-text">：限时等待（如</span><code class="ne-code"><span class="ne-text">sleep(1000)</span></code><span class="ne-text">）。</span></li>
<li id="u8651c634" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">TERMINATED</span></strong></code><span class="ne-text">：已终止。</span></li>
</ul>
</ul>
<p id="uf98e012e" class="ne-p"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></p>
<pre id="ipdpx" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread();
System.out.println(t.getState()); // NEW

t.start();
System.out.println(t.getState()); // RUNNABLE 或 TIMED_WAITING</code></pre>
<h2 id="nNP2b"><span class="ne-text">3.7 线程同步与通信</span></h2>
<h4 id="2f17586e"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public final void wait()</span></code> <span class="ne-text">/</span> <code class="ne-code"><span class="ne-text">wait(long timeout)</span></code></h4>
<ul class="ne-ul">
<li id="ud5bdf5ce" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：当前线程释放对象锁，进入</span><strong><span class="ne-text">WAITING</span></strong><span class="ne-text">或</span><strong><span class="ne-text">TIMED_WAITING</span></strong><span class="ne-text">状态，直到其他线程调用该对象的</span><code class="ne-code"><span class="ne-text">notify()</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">notifyAll()</span></code><span class="ne-text">。</span></li>
<li id="u8450caaa" data-lake-index-type="0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：必须在</span><code class="ne-code"><span class="ne-text">synchronized</span></code><span class="ne-text">块中调用，否则抛出</span><code class="ne-code"><span class="ne-text">IllegalMonitorStateException</span></code><span class="ne-text">。</span></li>
</ul>
<h4 id="14380e1e"><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">public final void notify()</span></code> <span class="ne-text">/</span> <code class="ne-code"><span class="ne-text">notifyAll()</span></code></h4>
<ul class="ne-ul">
<li id="u3d5debae" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：唤醒在该对象上等待的线程（</span><code class="ne-code"><span class="ne-text">notify()</span></code><span class="ne-text">随机唤醒一个，</span><code class="ne-code"><span class="ne-text">notifyAll()</span></code><span class="ne-text">唤醒所有）。</span></li>
<li id="u889d84e1" data-lake-index-type="0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：必须在</span><code class="ne-code"><span class="ne-text">synchronized</span></code><span class="ne-text">块中调用。</span></li>
</ul>
<p id="u69d4fd75" class="ne-p"><strong><span class="ne-text">生产者 - 消费者示例</span></strong><span class="ne-text">：</span></p>
<pre id="Vfut9" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>class SharedResource {
    private int data;
    private boolean available = false;

    public synchronized void produce(int value) {
        while (available) {
            try {
                wait(); // 等待消费者取走数据
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        data = value;
        available = true;
        notifyAll(); // 通知消费者数据已就绪
    }

    public synchronized int consume() {
        while (!available) {
            try {
                wait(); // 等待生产者生产数据
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        available = false;
        notifyAll(); // 通知生产者数据已取走
        return data;
    }
}</code></pre>
<h2 id="nTDYV"><span class="ne-text">3.8 守护线程</span></h2>
<h4 id="1.--5"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public final void setDaemon(boolean on)</span></code></h4>
<ul class="ne-ul">
<li id="ue40de689" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：设置线程为守护线程（</span><code class="ne-code"><span class="ne-text">true</span></code><span class="ne-text">）或用户线程（</span><code class="ne-code"><span class="ne-text">false</span></code><span class="ne-text">）。</span></li>
<li id="u42a66098" data-lake-index-type="0"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u9c43b0e3" data-lake-index-type="0"><span class="ne-text">守护线程在所有用户线程结束后自动终止（如垃圾回收线程）。</span></li>
<li id="u3fcc61f1" data-lake-index-type="0"><span class="ne-text">必须在</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">前调用，否则抛出</span><code class="ne-code"><span class="ne-text">IllegalThreadStateException</span></code><span class="ne-text">。</span></li>
</ul>
</ul>
<p id="ue0f8eb65" class="ne-p"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></p>
<pre id="aiGzT" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread daemonThread = new Thread(() -&gt; {
    while (true) {
        System.out.println("守护线程运行中...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
daemonThread.setDaemon(true);
daemonThread.start();

// 主线程结束后，守护线程自动终止</code></pre>
<h2 id="Gy7NC"><span class="ne-text">3.9 其他常用方法</span></h2>
<h4 id="2f17586e-1"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public final String getName()</span></code> <span class="ne-text">/</span> <code class="ne-code"><span class="ne-text">setName(String name)</span></code></h4>
<ul class="ne-ul">
<li id="u6bb6a059" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：获取 / 设置线程名称，用于调试和日志记录。</span></li>
</ul>
<h4 id="2.--2"><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">public final boolean isAlive()</span></code></h4>
<ul class="ne-ul">
<li id="u33777c72" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：判断线程是否处于活动状态（已启动且未终止）。</span></li>
</ul>
<h4 id="3.--1"><span class="ne-text">3.</span> <code class="ne-code"><span class="ne-text">public static Thread currentThread()</span></code></h4>
<ul class="ne-ul">
<li id="ud00ac8ca" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：获取当前执行的线程实例。</span></li>
</ul>
<h2 id="OP3tj"><span class="ne-text">3.10 方法对比与注意事项</span></h2>
<table id="XozUI" class="ne-table">
<tbody>
<tr>
<td width="142">
<p id="u6e09b87d" class="ne-p"><strong><span class="ne-text">方法</span></strong></p>
</td>
<td width="110">
<p id="u321a781b" class="ne-p"><strong><span class="ne-text">是否静态</span></strong></p>
</td>
<td width="109">
<p id="u0e92f802" class="ne-p"><strong><span class="ne-text">释放锁</span></strong></p>
</td>
<td width="119">
<p id="u8613def6" class="ne-p"><strong><span class="ne-text">中断响应</span></strong></p>
</td>
<td width="150">
<p id="u5e3248b6" class="ne-p"><strong><span class="ne-text">用途场景</span></strong></p>
</td>
</tr>
<tr>
<td width="142">
<p id="u570492dd" class="ne-p"><code class="ne-code"><span class="ne-text">sleep()</span></code></p>
</td>
<td width="110">
<p id="u08b20041" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="109">
<p id="u141810bb" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="119">
<p id="ube84de83" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="150">
<p id="u090870e0" class="ne-p"><span class="ne-text">暂停执行</span></p>
</td>
</tr>
<tr>
<td width="142">
<p id="u55f2a196" class="ne-p"><code class="ne-code"><span class="ne-text">yield()</span></code></p>
</td>
<td width="110">
<p id="uc6848360" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="109">
<p id="u815f1177" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="119">
<p id="u7f9b8fe8" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="150">
<p id="uf632c967" class="ne-p"><span class="ne-text">让出 CPU 时间片</span></p>
</td>
</tr>
<tr>
<td width="142">
<p id="u6f76db25" class="ne-p"><code class="ne-code"><span class="ne-text">join()</span></code></p>
</td>
<td width="110">
<p id="ua318f171" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="109">
<p id="u29248dee" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="119">
<p id="u67b3ab7b" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="150">
<p id="u64dfba40" class="ne-p"><span class="ne-text">等待其他线程结束</span></p>
</td>
</tr>
<tr>
<td width="142">
<p id="udb065a6e" class="ne-p"><code class="ne-code"><span class="ne-text">wait()</span></code></p>
</td>
<td width="110">
<p id="uf13b694f" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="109">
<p id="ua90a66fb" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="119">
<p id="u8c47f41f" class="ne-p"><span class="ne-text">是</span></p>
</td>
<td width="150">
<p id="ud8b712ba" class="ne-p"><span class="ne-text">线程间通信</span></p>
</td>
</tr>
<tr>
<td width="142">
<p id="ue20df14f" class="ne-p"><code class="ne-code"><span class="ne-text">notify()</span></code></p>
</td>
<td width="110">
<p id="u95f42aac" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="109">
<p id="u8775ab86" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="119">
<p id="ufb2ec7d5" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="150">
<p id="u8872d500" class="ne-p"><span class="ne-text">唤醒等待线程</span></p>
</td>
</tr>
<tr>
<td width="142">
<p id="u49125f35" class="ne-p"><code class="ne-code"><span class="ne-text">interrupt()</span></code></p>
</td>
<td width="110">
<p id="u5f632d08" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="109">
<p id="u7abe5031" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="119">
<p id="uf19bd267" class="ne-p"><span class="ne-text">否</span></p>
</td>
<td width="150">
<p id="u7dd2cd6f" class="ne-p"><span class="ne-text">中断线程</span></p>
</td>
</tr>
</tbody>
</table>
<h1 id="z0GJu"><span class="ne-text">4 线程关闭方式</span></h1>
<h2 id="rIux7"><span class="ne-text">4.1 线程关闭的错误方式</span></h2>
<h4 id="a21ff3d8"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">public final void stop()</span></code><span class="ne-text">（已弃用）</span></h4>
<ul class="ne-ul">
<li id="ua55665f9" data-lake-index-type="0"><strong><span class="ne-text">问题</span></strong><span class="ne-text">：强制终止线程，立即释放所有锁，可能导致数据不一致（如对象处于半初始化状态）。</span></li>
<li id="ued21f963" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span><strong><span class="ne-text">java</span></strong></li>
</ul>
<pre id="nTnV7" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread(() -&gt; {
    synchronized (lock) {
        // 修改共享资源
        // stop()可能在此处被调用，导致锁释放，资源未完全修改
    }
});
t.start();
t.stop(); // 危险！</code></pre>
<h4 id="Obu94"><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">System.exit(int status)</span></code></h4>
<ul class="ne-ul">
<li id="ua3dfd9ca" data-lake-index-type="0"><strong><span class="ne-text">问题</span></strong><span class="ne-text">：终止整个 JVM，所有线程（包括守护线程）都会被强制终止，未释放的资源（如文件句柄）无法清理。</span></li>
</ul>
<h2 id="lgBtf"><span class="ne-text">4.2 线程优雅关闭的正确方式</span></h2>
<h3 id="omLCb"><span class="ne-text">4.2.1 通过标志位控制（推荐）</span></h3>
<ul class="ne-ul">
<li id="uf859e801" data-lake-index-type="0"><strong><span class="ne-text">原理</span></strong><span class="ne-text">：在线程内部设置一个</span><strong><span class="ne-text">volatile 标志位</span></strong><span class="ne-text">，外部线程通过修改标志位通知目标线程停止。</span></li>
<li id="u09e1cb7d" data-lake-index-type="0"><strong><span class="ne-text">优点</span></strong><span class="ne-text">：安全可控，适合长时间运行的任务。</span></li>
</ul>
<p id="u3c684025" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="KmIIQ" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class FlagControlledThread extends Thread {
    private volatile boolean running = true; // 必须为volatile，保证可见性

    @Override
    public void run() {
        while (running) {
            try {
                // 执行任务
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // 恢复中断状态
                break;
            }
        }
        // 清理资源（如关闭文件、释放连接等）
        System.out.println("线程正常退出");
    }

    public void shutdown() {
        running = false; // 设置标志位，通知线程停止
    }
}

// 使用示例
public static void main(String[] args) throws InterruptedException {
    FlagControlledThread thread = new FlagControlledThread();
    thread.start();
    
    // 主线程休眠一段时间后请求线程关闭
    Thread.sleep(2000);
    thread.shutdown(); // 优雅关闭
    thread.join();     // 等待线程终止
}</code></pre>
<h4 id="735e9499"><span class="ne-text">2.</span> <strong><span class="ne-text">使用中断机制（推荐）</span></strong></h4>
<ul class="ne-ul">
<li id="u2a5b9617" data-lake-index-type="0"><strong><span class="ne-text">原理</span></strong><span class="ne-text">：通过</span><code class="ne-code"><span class="ne-text">interrupt()</span></code><span class="ne-text">设置中断标志，线程在合适的时机检查标志并退出。</span></li>
<li id="uc9e86400" data-lake-index-type="0"><strong><span class="ne-text">适用场景</span></strong><span class="ne-text">：线程处于阻塞状态（如</span><code class="ne-code"><span class="ne-text">sleep()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">wait()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">join()</span></code><span class="ne-text">）时也能及时响应。</span></li>
</ul>
<p id="ued2a3c9f" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="Bd1Sa" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class InterruptibleThread extends Thread {
    @Override
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // 执行任务
                Thread.sleep(100); // 可能被中断，抛出InterruptedException
            } catch (InterruptedException e) {
                // 1. 恢复中断状态
                Thread.currentThread().interrupt();
                // 2. 退出循环
                break;
            }
        }
        // 清理资源
        System.out.println("线程被中断，正常退出");
    }
}

// 使用示例
public static void main(String[] args) throws InterruptedException {
    InterruptibleThread thread = new InterruptibleThread();
    thread.start();
    
    // 主线程休眠后请求中断
    Thread.sleep(2000);
    thread.interrupt(); // 发送中断信号
    thread.join();      // 等待线程终止
}</code></pre>
<h4 id="52127bbc"><span class="ne-text">3.</span> <strong><span class="ne-text">结合标志位和中断（最佳实践）</span></strong></h4>
<ul class="ne-ul">
<li id="uf1370385" data-lake-index-type="0"><strong><span class="ne-text">原理</span></strong><span class="ne-text">：同时使用标志位和中断机制，兼顾灵活性和健壮性。</span></li>
</ul>
<p id="u709f1d82" class="ne-p"><strong><span class="ne-text">示例代码</span></strong><span class="ne-text">：</span></p>
<pre id="KdC3Q" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class HybridShutdownThread extends Thread {
    private volatile boolean running = true;

    @Override
    public void run() {
        while (running &amp;&amp; !Thread.currentThread().isInterrupted()) {
            try {
                // 执行任务
                Thread.sleep(100);
            } catch (InterruptedException e) {
                running = false; // 中断后设置标志位
                Thread.currentThread().interrupt(); // 恢复中断状态
            }
        }
        // 清理资源
        System.out.println("线程优雅关闭");
    }

    public void shutdown() {
        running = false;       // 设置标志位
        interrupt();           // 中断可能的阻塞操作
    }
}</code></pre>
<h3 id="e5191396"><span class="ne-text">4.2.2 线程池的优雅关闭</span></h3>
<h4 id="dI3JI"><span class="ne-text">1.</span> <code class="ne-code"><span class="ne-text">ExecutorService.shutdown()</span></code></h4>
<ul class="ne-ul">
<li id="ue13c6c05" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：平缓关闭线程池，不再接受新任务，已提交的任务会继续执行。</span></li>
</ul>
<h4 id="BCbJw"><span class="ne-text">2.</span> <code class="ne-code"><span class="ne-text">ExecutorService.shutdownNow()</span></code></h4>
<ul class="ne-ul">
<li id="u9f0c9a87" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：强制关闭线程池，尝试中断正在执行的任务，并返回未执行的任务列表。</span></li>
<li id="u2b330fa4" data-lake-index-type="0"><strong><span class="ne-text">原理</span></strong><span class="ne-text">：</span></li>
</ul>
<ol class="ne-list-wrap">
<ol class="ne-ol">
<li id="ud6df882d" data-lake-index-type="0"><strong><span class="ne-text">标记线程池为停止状态</span></strong><span class="ne-text">：拒绝新任务的提交。</span></li>
<li id="ub56430d6" data-lake-index-type="0"><strong><span class="ne-text">中断所有活跃线程</span></strong><span class="ne-text">：遍历线程池中的工作线程，调用</span><code class="ne-code"><span class="ne-text">Thread.interrupt()</span></code><span class="ne-text">。</span></li>
<li id="u5199547b" data-lake-index-type="0"><strong><span class="ne-text">清空任务队列</span></strong><span class="ne-text">：将等待队列中的任务转移到列表中返回。</span></li>
<li id="u55b7a1e3" data-lake-index-type="0"><strong><span class="ne-text">返回未执行的任务</span></strong><span class="ne-text">：返回步骤 3 中转移的任务列表。</span></li>
</ol>
</ol>
<h4 id="10134cd6"><span class="ne-text">3. 最佳实践代码</span></h4>
<pre id="a3FQo" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ThreadPoolShutdownExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        
        // 提交任务
        for (int i = 0; i &lt; 10; i++) {
            final int taskId = i;
            executor.submit(() -&gt; {
                try {
                    System.out.println("执行任务: " + taskId);
                    Thread.sleep(1000);
                    System.out.println("任务 " + taskId + " 完成");
                } catch (InterruptedException e) {
                    System.out.println("任务 " + taskId + " 被中断");
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // 优雅关闭线程池
        executor.shutdown(); // 停止接受新任务
        
        try {
            // 等待已提交的任务执行完毕（最多等待30秒）
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                // 超时未完成，强制关闭
                executor.shutdownNow();
                
                // 再次等待剩余任务中断（最多等待10秒）
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    System.err.println("线程池关闭失败");
                }
            }
        } catch (InterruptedException e) {
            // 主线程被中断，强制关闭
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        System.out.println("线程池已关闭");
    }
}</code></pre>
<h2 id="vciMm"><span class="ne-text">4.3 资源清理的最佳实践</span></h2>
<p id="u98899583" class="ne-p"><span class="ne-text">在线程关闭时，需确保释放所有持有的资源（如文件、网络连接、数据库连接等），推荐使用：</span></p>
<ol class="ne-ol">
<li id="u716dda44" data-lake-index-type="0"><strong><span class="ne-text">try-with-resources</span></strong><span class="ne-text">：自动关闭实现了</span><code class="ne-code"><span class="ne-text">AutoCloseable</span></code><span class="ne-text">接口的资源。</span></li>
</ol>
<pre id="pIhoJ" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>@Override
public void run() {
    try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
        // 使用资源
    } catch (IOException e) {
        e.printStackTrace();
    }
    // 资源自动关闭
}</code></pre>
<ol class="ne-ol" start="2">
<li id="u1bffc671" data-lake-index-type="0"><strong><span class="ne-text">finally 块</span></strong><span class="ne-text">：确保无论是否发生异常，资源都能被关闭。</span></li>
</ol>
<pre id="YyfaR" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>@Override
public void run() {
    Connection conn = null;
    try {
        conn = getDatabaseConnection();
        // 使用连接执行操作
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        if (conn != null) {
            try {
                conn.close(); // 手动关闭资源
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<h2 id="cOdBN"><span class="ne-text">4.4 总结</span></h2>
<p id="u54a24b21" class="ne-p"><span class="ne-text">线程的优雅关闭需遵循以下原则：</span></p>
<ol class="ne-ol">
<li id="u06c2315c" data-lake-index-type="0"><strong><span class="ne-text">避免强制终止</span></strong><span class="ne-text">：不使用</span><code class="ne-code"><span class="ne-text">stop()</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">destroy()</span></code><span class="ne-text">等方法。</span></li>
<li id="ufc238909" data-lake-index-type="0"><strong><span class="ne-text">协作式关闭</span></strong><span class="ne-text">：通过标志位或中断机制通知线程自行终止。</span></li>
<li id="ude0750d8" data-lake-index-type="0"><strong><span class="ne-text">资源清理</span></strong><span class="ne-text">：使用</span><code class="ne-code"><span class="ne-text">try-with-resources</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">finally</span></code><span class="ne-text">确保资源释放。</span></li>
<li id="u28735aea" data-lake-index-type="0"><strong><span class="ne-text">线程池关闭</span></strong><span class="ne-text">：按顺序调用</span><code class="ne-code"><span class="ne-text">shutdown()</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">awaitTermination()</span></code><span class="ne-text">。</span></li>
</ol>
<p id="uee4b2686" class="ne-p"><span class="ne-text">通过以上方法，可以确保线程安全退出，避免数据不一致和资源泄漏，提高系统的稳定性和可靠性。</span></p>
<h1 id="h29ik"><span class="ne-text">5 线程的状态</span></h1>
<h2 id="LZB15"><span class="ne-text">5.1 六种状态</span><span class="ne-text">（Thread.State 枚举）</span></h2>
<p id="ueaf860e6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2025/png/34109461/1747545515205-814bc69a-fe13-4c12-b63f-93f25dc587dc.png" class="ne-image" width="893"></p>
<h3 id="hH1pq"><span class="ne-text">5.1.1 NEW（新建）</span></h3>
<ul class="ne-ul">
<li id="u7bf26f20" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程已被创建（通过</span><code class="ne-code"><span class="ne-text">new Thread()</span></code><span class="ne-text">），但尚未调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法。</span></li>
<li id="u99acc531" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="JDrO9" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>Thread t = new Thread(() -&gt; System.out.println("线程执行"));
// 此时t处于NEW状态</code></pre>
<ul class="ne-ul">
<li id="u69688403" data-lake-index-type="0"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u03615166" data-lake-index-type="0"><span class="ne-text">线程对象已创建，但尚未分配系统资源（如操作系统线程）。</span></li>
<li id="u73a54339" data-lake-index-type="0"><span class="ne-text">只能调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">方法，其他操作（如</span><code class="ne-code"><span class="ne-text">interrupt()</span></code><span class="ne-text">）会抛出异常。</span></li>
</ul>
</ul>
<h3 id="yINAb"><span class="ne-text">5.1.2 RUNNABLE（可运行）</span></h3>
<ul class="ne-ul">
<li id="ub151721e" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程已启动（调用</span><code class="ne-code"><span class="ne-text">start()</span></code><span class="ne-text">），正在 JVM 中运行或等待 CPU 时间片。</span></li>
<li id="u64754bca" data-lake-index-type="0"><strong><span class="ne-text">细分状态</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u26ae2273" data-lake-index-type="0"><strong><span class="ne-text">Running</span></strong><span class="ne-text">：线程正在 CPU 上执行。</span></li>
<li id="u8298c080" data-lake-index-type="0"><strong><span class="ne-text">Ready</span></strong><span class="ne-text">：线程处于就绪队列，等待操作系统调度。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u859269cf" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="bVcKE" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>t.start(); // 调用start()后，t进入RUNNABLE状态</code></pre>
<ul class="ne-ul">
<li id="u370a2473" data-lake-index-type="0"><strong><span class="ne-text">特点</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u1f0279f4" data-lake-index-type="0"><span class="ne-text">线程可能正在执行，也可能在等待 CPU 资源。</span></li>
<li id="u00585269" data-lake-index-type="0"><span class="ne-text">Java 将操作系统层面的</span><code class="ne-code"><span class="ne-text">Running</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">Ready</span></code><span class="ne-text">状态统一抽象为</span><code class="ne-code"><span class="ne-text">RUNNABLE</span></code><span class="ne-text">。</span></li>
</ul>
</ul>
<h3 id="vi2s6"><span class="ne-text">5.1.3 BLOCKED（阻塞）</span></h3>
<ul class="ne-ul">
<li id="ua547daa9" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程正在等待获取锁（如</span><code class="ne-code"><span class="ne-text">synchronized</span></code><span class="ne-text">块或方法）。</span></li>
<li id="ub3de7b9a" data-lake-index-type="0"><strong><span class="ne-text">触发场景</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ue9afd229" data-lake-index-type="0"><span class="ne-text">线程尝试进入</span><code class="ne-code"><span class="ne-text">synchronized</span></code><span class="ne-text">代码块，但锁已被其他线程持有。</span></li>
<li id="u3f19d265" data-lake-index-type="0"><span class="ne-text">锁被释放后，线程从</span><code class="ne-code"><span class="ne-text">BLOCKED</span></code><span class="ne-text">变为</span><code class="ne-code"><span class="ne-text">RUNNABLE</span></code><span class="ne-text">，重新竞争锁。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u74d072a3" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="vSXps" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class BlockedExample {
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -&gt; {
            synchronized (LOCK) {
                // 持有锁，长时间运行
                try { Thread.sleep(1000); } catch (InterruptedException e) {}
            }
        });

        Thread t2 = new Thread(() -&gt; {
            synchronized (LOCK) { // t2在此处阻塞，进入BLOCKED状态
                System.out.println("t2获取到锁");
            }
        });

        t1.start();
        t2.start();
    }
}</code></pre>
<h3 id="cR3uj"><span class="ne-text">5.1.4 WAITING（无限期等待）</span></h3>
<ul class="ne-ul">
<li id="u5ed1c0a0" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程等待另一个线程执行特定操作，需通过其他线程显式唤醒。</span></li>
<li id="uad5bf0f7" data-lake-index-type="0"><strong><span class="ne-text">触发方法</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u0526da85" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Object.wait()</span></code><span class="ne-text">：释放对象锁，进入等待状态，直到其他线程调用</span><code class="ne-code"><span class="ne-text">notify()</span></code><span class="ne-text">/</span><code class="ne-code"><span class="ne-text">notifyAll()</span></code><span class="ne-text">。</span></li>
<li id="u373092e0" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Thread.join()</span></code><span class="ne-text">：等待目标线程终止。</span></li>
<li id="ubea42110" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">LockSupport.park()</span></code><span class="ne-text">：等待许可（permit）。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="uf2c5dc65" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="nw4UL" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class WaitingExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            synchronized (this) {
                try {
                    wait(); // 线程t进入WAITING状态
                } catch (InterruptedException e) {}
            }
        });

        t.start();
        Thread.sleep(100);
        System.out.println(t.getState()); // 输出WAITING

        synchronized (this) {
            notify(); // 唤醒线程t
        }
    }
}</code></pre>
<h3 id="f6XJ9"><span class="ne-text">5.1.5 TIMED_WAITING（限时等待）</span></h3>
<ul class="ne-ul">
<li id="u2fe54cb5" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程在指定时间内等待，超时后自动恢复。</span></li>
<li id="ud4235c5a" data-lake-index-type="0"><strong><span class="ne-text">触发方法</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u70f7d23f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Thread.sleep(long millis)</span></code><span class="ne-text">：线程暂停执行指定时间。</span></li>
<li id="u886b3de8" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Object.wait(long timeout)</span></code><span class="ne-text">：释放锁，等待指定时间或被唤醒。</span></li>
<li id="u8b12dbb4" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Thread.join(long millis)</span></code><span class="ne-text">：等待目标线程终止，最多等待指定时间。</span></li>
<li id="u4f7e76db" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">LockSupport.parkNanos(long nanos)</span></code><span class="ne-text">/</span><code class="ne-code"><span class="ne-text">parkUntil(long deadline)</span></code><span class="ne-text">：限时等待许可。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u8064e5a1" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="VtRuz" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class TimedWaitingExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            try {
                Thread.sleep(2000); // 线程t进入TIMED_WAITING状态
            } catch (InterruptedException e) {}
        });

        t.start();
        Thread.sleep(100);
        System.out.println(t.getState()); // 输出TIMED_WAITING
    }
}</code></pre>
<h3 id="ve85b"><span class="ne-text">5.1.6 TERMINATED（终止）</span></h3>
<ul class="ne-ul">
<li id="u2e231bd5" data-lake-index-type="0"><strong><span class="ne-text">含义</span></strong><span class="ne-text">：线程执行完毕或因异常终止，生命周期结束。</span></li>
<li id="ub2716624" data-lake-index-type="0"><strong><span class="ne-text">触发条件</span></strong><span class="ne-text">：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uf9518bad" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法正常返回。</span></li>
<li id="ue971c169" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">run()</span></code><span class="ne-text">方法抛出未捕获的异常。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u8cb64851" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">：</span></li>
</ul>
<pre id="ZSu0t" class="ne-codeblock language-java highlighter-hljs" data-language="java"><code>public class TerminatedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            System.out.println("线程执行");
        });

        t.start();
        Thread.sleep(100); // 等待线程t执行完毕
        System.out.println(t.getState()); // 输出TERMINATED
    }
}</code></pre>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.018182518194444445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-21 15:55">2025-05-21 15:55</span>&nbsp;
<a href="https://www.cnblogs.com/icutey">褐瞳cutey</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18889195);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18889195', targetLink: 'https://www.cnblogs.com/icutey/p/18889195', title: '多线程与并发-理论基础' })">举报</a>
</div>
        