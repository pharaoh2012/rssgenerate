<!----> <meta itemprop="headline" content="想成为中高级前端，必须理解这10种javascript设计模式"> <meta itemprop="keywords" content="前端,JavaScript,面试"> <meta itemprop="datePublished" content="2024-11-04T07:47:03.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天天鸭"> <meta itemprop="url" content="https://juejin.cn/user/3963059533776605"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            想成为中高级前端，必须理解这10种javascript设计模式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/3963059533776605/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    天天鸭
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-11-04T07:47:03.000Z" title="Mon Nov 04 2024 07:47:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-11-04
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    13,780
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p>通过最近的面试我发现，很多同行小伙伴做了几年的开发竟然连基本的设计模式都不知道，甚至可能连什么是设计模式都说的有点模棱两可。</p>
<p>如果作为几年经验的中高级前端这其实是不应该的，因此才想写一篇文章说明什么是设计模式？？设计模式有哪些分类？？然后举例？？</p>
<p>好了废话不多说，下面让我们直入主题。</p>
<h2 data-id="heading-1">什么是前端设计模式</h2>
<p>用大白话说前端的设计模式，其实就是一种可以在多处地方重复使用的代码设计方案，
只是不同的设计模式所能应用的场景有所不同。</p>
<p>通过这种设计模式可以帮助我们提高代码的可读性、可维护性与可扩展性。</p>
<p>而且前端的设计模式又分为三个大类型，分别是<code>创建型、结构型和行为型</code>，针对这三个大类型，又会有很多种不同的设计模式。</p>
<h2 data-id="heading-2">前端设计模式分类</h2>
<p>如果要说设计模式的话有高达二十多种，但本文章主要针对<code>javascript</code>相关的设计模式，因此我整理出来<code>10种</code>设计模式，并且进行分类总结。</p>
<p><code>javascript</code>的设计模式分为三大类型，即<code>创建型、结构型和行为型</code>。</p>
<p>整理后具体分类如下所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/304ebc54034343869d0176df2b4f1ad4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp6bit:q75.awebp?rk3s=f64ab15b&amp;x-expires=1738707996&amp;x-signature=LinyW1rJm13UL%2FmNsGqEKrhZfVA%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-3">前端设计模式详解</h2>
<h3 data-id="heading-4">创建型</h3>
<blockquote>
<p><strong>创建型</strong>：顾名思义作用就是用于创建过程。通过确定规则对代码进行封装，减少创建过程中的重复代码，并且对创建制定规则提高规范和灵活性。</p>
</blockquote>
<h4 data-id="heading-5">1、单例模式</h4>
<p><strong>主要思想：</strong>  确保一个类只有一个实例，并且提供一个访问它的全局访问点。</p>
<p><strong>优势：</strong> 由于只有一个实例，所以全局唯一性，并且更好地控制共享资源优化性能。</p>
<p><strong>示例：</strong> 下面看一个最经典常用的案例：使用<code>ES6</code>模块。</p>
<pre><code class="hljs language-test.js" lang="test.js">const test = {
  name: 'testName',
  age: '18',
};

export default test;
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">'./test'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">name</span>，test.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 打印：testName，18</span>
</code></pre>
<p>上述例子定义<code>test</code>并且<code>export defaul</code>暴露唯一的实例<code>test</code>，符合确保一个类只有一个实例，并且提供一个访问它的全局访问点原则。</p>
<p>其实单例模式有很多种实现方式，并且不同的实现方式有不同的适用场景，这种只是为了通过例子去理解这种设计模式的思想。</p>
<h4 data-id="heading-6">2、工厂模式</h4>
<p><strong>主要思想：</strong> 对代码逻辑进行封装，只暴露出通用接口直接调用。</p>
<p><strong>优势：</strong> 对逻辑进行高度封装，降低耦合度，易于维护代码和提高后续扩展性。</p>
<p><strong>示例：</strong> 定义一个通用的产品类为示例。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ------ 定义一个产品类 ------ </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">testProduct</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">productName</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">productName</span> = productName;
  }

  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`产品名称: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.productName}</span>`</span>);
  }
}

<span class="hljs-comment">// ----- 定义一个工厂函数 -------</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createProduct</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">testProduct</span>(name);
}

<span class="hljs-comment">// 使用工厂函数创建对象</span>
<span class="hljs-keyword">const</span> test1 = <span class="hljs-title function_">createProduct</span>(<span class="hljs-string">'产品1'</span>);
<span class="hljs-keyword">const</span> test2 = <span class="hljs-title function_">createProduct</span>(<span class="hljs-string">'产品2'</span>);

<span class="hljs-comment">// 使用对象</span>
test1.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 打印： 产品名称: 产品1</span>
test2.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 打印： 产品名称: 产品2</span>
</code></pre>
<p>上述例子定义一个工厂函数，逻辑代码是封装在<code>testProduct</code>类中，暴露出<code>createProduct</code>方法，调用时传入不同的参数返回不同的内容。</p>
<h4 data-id="heading-7">3、构造器模式</h4>
<p><strong>主要思想：</strong>  定义一个通用的构造函数，然后方便多次传递参数调用。</p>
<p><strong>优势：</strong>  减少重复代码、提高可维护性和扩展性。</p>
<p><strong>示例：</strong> 创建用户对象，定义一个构造函数并且使用。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">testPerson</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age,</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }

  <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`姓名: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, 年龄: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>`</span>);
  }
}


<span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">testPerson</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">30</span>);
test1.<span class="hljs-title function_">introduce</span>(); <span class="hljs-comment">//  姓名: 张三, 年龄: 30</span>

<span class="hljs-keyword">const</span> test2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">testPerson</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">25</span>);
test2.<span class="hljs-title function_">introduce</span>(); <span class="hljs-comment">// 输出: 姓名: 李四, 年龄: 25</span>
</code></pre>
<p>定义一个<code>testPerson</code>类，每次传入不同参数即可创建不同的用户对象，后续如果需要修改用户属性只需要调整<code>testPerson</code>类。</p>
<h3 data-id="heading-8">结构型</h3>
<blockquote>
<p><strong>结构型：</strong> 主要是针对对象之间的组合。大概意思就是通过增加代码复杂度，从而提高扩展性和适配性。例如使代码兼容性更好、使某个方法功能更加强大。</p>
</blockquote>
<h4 data-id="heading-9">1、适配器模式</h4>
<p><strong>主要思想：</strong>  顾名思义就是使某个类的接口有更强的适配性，例如本来仅支持<code>mp3</code>，适配成能支持<code>mp4</code>。</p>
<p><strong>优势：</strong> 适配扩展后提高了复用性、降低耦合度并且增强了灵活性。</p>
<p><strong>示例：</strong> 把一个只能接收<code>110V</code>电压的插口，适配成能够接收<code>220V</code>的插口。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ------ 本来存在需要被适配的110V接口 ------</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Receptacle</span> {
  <span class="hljs-title function_">plugIn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"110V 插座"</span>);
  }
}


<span class="hljs-comment">//  ------ 适配者类 ------ </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ForeignReceptacle</span> {
  <span class="hljs-title function_">plugIn220V</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"220V 插座"</span>);
  }
}


<span class="hljs-comment">// ------ 用于适配的方法 ------</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">foreignReceptacle</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreignReceptacle</span> = foreignReceptacle;
  }
  <span class="hljs-title function_">plugIn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreignReceptacle</span>.<span class="hljs-title function_">plugIn220V</span>();
  }
}
</code></pre>
<p><strong>使用适配器代码</strong>：正常使用<code>Receptacle</code>类时输出效果是<code>110V</code>，但我们需要配<code>220V</code>，那么使用定义的<code>VoltageAdapter</code>适配器把<code>220V</code>的<code>ForeignReceptacle</code>类适配到<code>110V</code>的<code>Receptacle</code>类上。</p>
<p>通过这个方式即扩展了<code>Receptacle</code>类的功能，又不需要修改<code>Receptacle</code>类。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 创建110V设备</span>
const receptacle = new <span class="hljs-built_in">Receptacle</span>();
receptacle<span class="hljs-selector-class">.plugIn</span>(); <span class="hljs-comment">// 打印输出: 110V 插座</span>

<span class="hljs-comment">// 创建220V设备</span>
const foreignReceptacle = new <span class="hljs-built_in">ForeignReceptacle</span>();

<span class="hljs-comment">// 使用适配器将 220V 设备适配到 110V 插座</span>
const adapter = new <span class="hljs-built_in">VoltageAdapter</span>(foreignReceptacle);
adapter<span class="hljs-selector-class">.plugIn</span>(); <span class="hljs-comment">// 打印输出: 220V 插座</span>
</code></pre>
<h4 data-id="heading-10">2、装饰器模式</h4>
<p><strong>主要思想：</strong>  创建一个对象去包裹原始对象，在不修改原始对象本身的情况下，动态给指定原始对象添加新的功能。</p>
<p><strong>优势：</strong>  不改动原函数的情况下方便动态扩展功能，可以复用现有函数增强灵活性。</p>
<p><strong>示例：</strong> 通过对一个只能输出<code>你好啊，**</code>的方法添加装饰器，使其能额外输出前缀。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 基础函数</span>
function <span class="hljs-built_in">getGreet</span>(name) {
  console<span class="hljs-selector-class">.log</span>(`你好啊，${name}!`);
}

<span class="hljs-comment">// 装饰器函数</span>
function <span class="hljs-built_in">welcomePrefix</span>(greetFunction) {
  return <span class="hljs-built_in">function</span>(name) {
    console<span class="hljs-selector-class">.log</span>("欢迎啊");
    <span class="hljs-built_in">greetFunction</span>(name);
  };
}

<span class="hljs-comment">// 基础函数</span>
<span class="hljs-built_in">getGreet</span>("天天鸭"); <span class="hljs-comment">// 打印: 你好啊，天天鸭!</span>
<span class="hljs-comment">// 添加 欢迎啊 前缀</span>
const setWelcome = <span class="hljs-built_in">welcomePrefix</span>(getGreet);
<span class="hljs-built_in">setWelcome</span>("天天"); <span class="hljs-comment">// 打印: 欢迎啊     </span>
                    <span class="hljs-comment">// 打印: 你好，天天!</span>
</code></pre>
<p>如上代码所示，<code>getGreet</code>只能输出<code>你好啊，**</code>，但使用装饰器函数<code>welcomePrefix</code>装饰后，可以在前面添加"欢迎啊"前缀，通过这个实现思路方式不需要修改基础函数就能添加功能。</p>
<h4 data-id="heading-11">3、代理模式</h4>
<p><strong>主要思想：</strong>   给某个对象加一个代理对象，代理对象起到中介作用，中介对象在不改变原对象情况下添加功能。</p>
<p><strong>优势：</strong> 代理对象可以很方便实现拦截控制访问，并且不修改原对象提高代码复用率。</p>
<p><strong>示例：</strong> 通过代理函数去控制计数器函数的操作</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 基础函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counterEvent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">setCount</span>: <span class="hljs-function">() =&gt;</span> {
      count++;
    },
    <span class="hljs-attr">getCount</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> count;
    }
  };
}

<span class="hljs-comment">// 代理函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">countProxy</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> newCounter = <span class="hljs-title function_">counterEvent</span>();
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">setCount</span>: <span class="hljs-function">() =&gt;</span> {
      newCounter.<span class="hljs-title function_">setCount</span>();
    },
    <span class="hljs-attr">getCount</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> newCounter.<span class="hljs-title function_">getCount</span>();
    }
  };
}

<span class="hljs-comment">// 创建一个代理对象</span>
<span class="hljs-keyword">const</span> myCounter = <span class="hljs-title function_">countProxy</span>();
<span class="hljs-comment">// 触发增加</span>
myCounter.<span class="hljs-title function_">setCount</span>();
myCounter.<span class="hljs-title function_">setCount</span>();
myCounter.<span class="hljs-title function_">setCount</span>();
<span class="hljs-comment">// 获取当前数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 打印: 3</span>
</code></pre>
<p>不让用户直接操作<code>counterEvent</code>函数，而是通过<code>countProxy</code>代理函数去操作<code>counterEvent</code>函数
。</p>
<p>这里只是举例这种代理模式的设计思想，如果在真实业务中间代理层其实可以很多逻辑操作。</p>
<h3 data-id="heading-12">行为型</h3>
<blockquote>
<p><strong>行为型：</strong> 主要是针对对象之间的交互。针对特定的应用场景，通过封装制定对象之间的交互方式规则，使对象之间协作更加灵活高效健壮。</p>
</blockquote>
<h4 data-id="heading-13">1、观察者模式</h4>
<p><strong>主要思想：</strong>  顾名思义就是观察某个对象是否发生变化，如果发生变化就会通知所有订阅者，并做出相应操作，是<code>一对一或一对多</code>关系。。</p>
<p><strong>优势：</strong> 有很强动态灵活性，可以轻松地添加或者移除观察者; 把观察者和被观察者解耦进行逻辑分离易于维护。</p>
<p><strong>示例：</strong> 实现基本增加、移除和通知。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 观察者</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];
  }

  <span class="hljs-title function_">add</span>(<span class="hljs-params">observer</span>) { <span class="hljs-comment">// 添加观察者到列表中</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);
  }

  <span class="hljs-title function_">unadd</span>(<span class="hljs-params">observer</span>) {  <span class="hljs-comment">// 从列表中移除观察者</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">obs</span> =&gt;</span> obs !== observer);
  }

  <span class="hljs-title function_">notify</span>(<span class="hljs-params">msg</span>) {  <span class="hljs-comment">// 通知所有观察者</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> <span class="hljs-title function_">observer</span>(msg));
  }
}

<span class="hljs-comment">// 用于创建观察者</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">createObs</span> = (<span class="hljs-params">name</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${name}</span> 收到: <span class="hljs-subst">${msg}</span>`</span>);
  };
};
</code></pre>
<p><strong>使用观察者模式代码：</strong>  被观察者<code>Sub</code>里面有<code>add</code>（添加）、<code>unadd</code>（移除）、<code>notify</code>（通知）观察者的方法，观察者<code>createObs</code>里面有接收通知的方法。</p>
<p>当我们用<code>sub.add</code>添加观察者之后，使用<code>sub.notify</code>发布消息所有的观察者都会收到通知。</p>
<p><code>sub.unadd</code>移除一个观察者1后也同理，会不再收到通知。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 创建一个被观察者</span>
const sub = new <span class="hljs-built_in">Sub</span>();

<span class="hljs-comment">// 创建观察者</span>
const obs1 = <span class="hljs-built_in">createObs</span>("观察者<span class="hljs-number">1</span>");
const obs2 = <span class="hljs-built_in">createObs</span>("观察者<span class="hljs-number">2</span>");

<span class="hljs-comment">// 订阅被观察者</span>
sub<span class="hljs-selector-class">.add</span>(obs1);
sub<span class="hljs-selector-class">.add</span>(obs2);

<span class="hljs-comment">// 发布消息</span>
sub<span class="hljs-selector-class">.notify</span>("你好鸭!"); <span class="hljs-comment">// 观察者1和观察者2都收到: 你好鸭！</span>
                              
<span class="hljs-comment">// 移除观察者1</span>
sub<span class="hljs-selector-class">.unadd</span>(obs1);

<span class="hljs-comment">// 再次发布</span>
sub<span class="hljs-selector-class">.notify</span>("你好鸭！"); <span class="hljs-comment">// 只有观察者2收到: 你好鸭！</span>
</code></pre>
<h4 data-id="heading-14">2、发布者订阅者模式</h4>
<p><strong>主要思想：</strong>  这模式有点与观察者模式类似，但观察者模式是<code>一对一或者一对多</code>关系，而发布订阅模式是<code>多对多</code>关系，因此应用场景会有所不同。</p>
<p><strong>优势：</strong> 多对多关系有很强动态灵活性，可以多个订阅者，一个订阅者可以订阅多个事件; 把发布者和订阅者完全解耦提高灵活性和扩展性。</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 发布者</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pub</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span> = {};
  }

  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) {  <span class="hljs-comment">// 订阅事件</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event] = [];
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event].<span class="hljs-title function_">push</span>(callback);
  }

  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) {  <span class="hljs-comment">// 移除订阅事件</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);
    }
  }

  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) { <span class="hljs-comment">// 发布事件</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subobj</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));
    }
  }
}


<span class="hljs-comment">// 创建一个发布者实例</span>
<span class="hljs-keyword">const</span> pub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pub</span>();

<span class="hljs-comment">// 订阅者回调函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">subevent1</span> = (<span class="hljs-params">msg</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`订阅者1 收到: <span class="hljs-subst">${msg}</span>`</span>);
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">subevent2</span> = (<span class="hljs-params">msg</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`订阅者2 收到: <span class="hljs-subst">${msg}</span>`</span>);
};

<span class="hljs-comment">// 订阅事件</span>
pub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">"greet"</span>, subevent1);
pub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">"greet"</span>, subevent2);

<span class="hljs-comment">// 发布消息</span>
pub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">"greet"</span>, <span class="hljs-string">"你好鸭!"</span>); <span class="hljs-comment">// 订阅者1和订阅者2 收到: 你好鸭!</span>

<span class="hljs-comment">// 移除一个订阅者</span>
pub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-string">"greet"</span>, subevent1);

<span class="hljs-comment">// 再次发布消息</span>
pub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">"greet"</span>, <span class="hljs-string">"你好鸭!"</span>); <span class="hljs-comment">//  只有订阅者2 收到: 你好鸭!</span>
</code></pre>
<p>大概思路是定义一个<code>Pub</code>类，里面有<code>subscribe</code>（添加订阅事件）、<code>unsubscribe</code>（移除订阅事件）、
<code>publish</code>（通知发布事件）。<code>new Publisher()</code>创建发布者实例后可以添加、移除和发布事件。</p>
<p>对比上面很相似的观察者模式可以留意到，最主要区别在<code>Pub</code>类里面的<code>constructor()</code> 中，
这里使用的是<code>this.subobj={}</code>存放事件映射，而不是使用数组。<code>{}</code>里面每个事件都存放一个订阅者数组从而实现多对多效果。</p>
<h4 data-id="heading-15">3、命令模式</h4>
<p><strong>主要思想：</strong>  把请求封装在对象里面整个传递给调用对象，使里面参数更加灵活方便扩展。</p>
<p><strong>优势：</strong> 使发送和接收者完全解耦独立易于数据维护、逻辑独立方便灵活处理、队列请求可以撤销操作。</p>
<p><strong>示例：</strong> 以一个开关灯按钮为示例。</p>
<p>接收者<code>testLight</code>主要负责执行业务逻辑命令，即决定是否关灯;</p>
<p><code>LightOnComm</code>和<code>LightOffComm</code>继承基类<code>Comm</code>，实现<code>execute()</code>方法，
在<code>xecute()</code>方法中调用接收者的方法，然后分别调用<code>on</code>和<code>off</code>方法;</p>
<p><code>RemoteControl</code> 类负责调用者的方法，即去调用<code>execute()</code>方法。</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// 接收者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testLight</span> </span>{
  on() {
    console.log(<span class="hljs-string">"打开灯了"</span>);
  }
  off() {
    console.log(<span class="hljs-string">"关闭灯了"</span>);
  }
}

<span class="hljs-comment">// 命令基类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comm</span> </span>{
  constructor(receiver) {
    <span class="hljs-keyword">this</span>.receiver = receiver;
  }
}

<span class="hljs-comment">// 具体命令</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOnComm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comm</span> </span>{
  execute() {
    <span class="hljs-keyword">this</span>.receiver.on();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOffComm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comm</span> </span>{
  execute() {
    <span class="hljs-keyword">this</span>.receiver.off();
  }
}

<span class="hljs-comment">// 调用者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoteControl</span> </span>{
  onButton(comm) {
    comm.execute();
  }
}

</code></pre>
<p><strong>使用示例与解释：</strong></p>
<p>创建一个<code>testlight</code>实例后，将其传递给<code>LightOnComm</code>和<code>LightOffComm</code>的构造函数，
然后普创建了<code>LightOnComm</code>和<code>LightOffComm</code>的实例。并将它们传递给<code>RemoteControl</code>的<code>onButton</code>方法。</p>
<p>最后调用<code>onButton</code>方法时，就会调用相应命令的<code>execute</code>方法，从而执行相应的操作。</p>
<pre><code class="hljs language-ini" lang="ini">// 使用
const <span class="hljs-attr">testlight</span> = new testLight()<span class="hljs-comment">;</span>
const <span class="hljs-attr">lightOnComm</span> = new LightOnComm(testlight)<span class="hljs-comment">;</span>
const <span class="hljs-attr">lightOffComm</span> = new Light<span class="hljs-literal">Off</span>Comm(testlight)<span class="hljs-comment">;</span>
const <span class="hljs-attr">remoteControl</span> = new RemoteControl()<span class="hljs-comment">;</span>

remoteControl.onButton(lightOnComm)<span class="hljs-comment">; // 输出: 打开灯了</span>
remoteControl.onButton(lightOffComm)<span class="hljs-comment">; // 输出: 关闭灯了</span>
</code></pre>
<h4 data-id="heading-16">4、模版模式</h4>
<p><strong>主要思想：</strong>  定义好整个操作过程的框架，框架中把每个步骤的逻辑独立处理。</p>
<p><strong>优势：</strong> 步骤独立分开管理，易于扩展功能维护代码。</p>
<p><strong>示例：</strong> 游戏从初始化到结束</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">obj</span>) {
     
  }
  <span class="hljs-title function_">initGame</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'初始化'</span>);
  }
  <span class="hljs-title function_">startGame</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'游戏开始'</span>);
  }
  <span class="hljs-title function_">onGame</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'游戏中'</span>);
  }
  <span class="hljs-title function_">endGame</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'游戏结束'</span>);
  }
  <span class="hljs-title function_">personEntry</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initGame</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startGame</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onGame</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">endGame</span>()
  }
}
</code></pre>
<p>这个<code>Game</code>类中把每个步骤的逻辑都放在对应步骤的方法中，独立管理互不影响。
添加或者减少步骤，只需要修改对应的方法即可。</p>
<h2 data-id="heading-17">小结</h2>
<p>只要把这些模式都学习理解后会发现，这些设计模式真的是太精妙了！文章的示例主要学习的是设计模式的思想，
这些思想真的能适用于真实业务的方方面面，特别是对去阅读别人开源的源码时很有帮助。</p>
<p>终于肝完了，如果有那里写的不对或者有更好建议的话，欢迎提出来互相学习！</p></div></div>