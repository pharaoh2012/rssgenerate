
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rainybunny/p/18662683" title="发布于 2025-01-09 19:25">
    <span role="heading" aria-level="2">Report -「概率数据结构」随机化骗分？我们是专业的！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文试简要介绍 Bloom Filter, Four-colored Filter 和 Fermat Sketch 三种概率数据结构, 最后略作思考补充.
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="math display">\[\mathscr{Lorain~y~w~la~Lora~blea.}

\newcommand{\DS}[0]{\displaystyle}

% operators alias
\newcommand{\opn}[1]{\operatorname{#1}}
\newcommand{\card}[0]{\opn{card}}
\newcommand{\lcm}[0]{\opn{lcm}}
\newcommand{\char}[0]{\opn{char}}
\newcommand{\Char}[0]{\opn{Char}}
\newcommand{\Min}[0]{\opn{Min}}
\newcommand{\rank}[0]{\opn{rank}}
\newcommand{\Hom}[0]{\opn{Hom}}
\newcommand{\End}[0]{\opn{End}}
\newcommand{\im}[0]{\opn{im}}
\newcommand{\tr}[0]{\opn{tr}}
\newcommand{\diag}[0]{\opn{diag}}
\newcommand{\coker}[0]{\opn{coker}}
\newcommand{\id}[0]{\opn{id}}
\newcommand{\sgn}[0]{\opn{sgn}}
\newcommand{\cent}[0]{\u{\degree C}}

% symbols alias
\newcommand{\E}[0]{\exist}
\newcommand{\A}[0]{\forall}
\newcommand{\l}[0]{\left}
\newcommand{\r}[0]{\right}
\newcommand{\eps}[0]{\varepsilon}
\newcommand{\Ra}[0]{\Rightarrow}
\newcommand{\Eq}[0]{\Leftrightarrow}
\newcommand{\d}[0]{\mathrm{d}}
\newcommand{\oo}[0]{\infty}
\newcommand{\mmap}[0]{\hookrightarrow}
\newcommand{\emap}[0]{\twoheadrightarrow}
\newcommand{\lin}[0]{\lim_{n\to\oo}}
\newcommand{\linf}[0]{\liminf_{n\to\oo}}
\newcommand{\lsup}[0]{\limsup_{n\to\oo}}
\newcommand{\F}[0]{\mathbb F}
\newcommand{\x}[0]{\times}
\newcommand{\M}[0]{\mathbf{M}}
\newcommand{\T}[0]{\intercal}

% symbols with parameters
\newcommand{\der}[1]{\frac{\d}{\d #1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\br}[1]{\l(#1\r)}
\newcommand{\abs}[1]{\l|#1\r|}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\env}[2]{\begin{#1}#2\end{#1}} % why not?
\newcommand{\pmat}[1]{\env{pmatrix}{#1}}
\newcommand{\dary}[2]{\l|\begin{array}{#1}#2\end{array}\r|}
\newcommand{\pary}[2]{\l(\begin{array}{#1}#2\end{array}\r)}
\newcommand{\pblk}[4]{\l(\begin{array}{c|c}{#1}&amp;{#2}\\\hline{#3}&amp;{#4}\end{array}\r)}
\newcommand{\u}[1]{\mathrm{#1}}
\newcommand{\lix}[1]{\lim_{x\to #1}}
\newcommand{\ops}[1]{#1\cdots #1}
\newcommand{\seq}[3]{{#1}_{#2}\ops,{#1}_{#3}}
\newcommand{\dedu}[2]{\u{(#1)}\Ra\u{(#2)}}
\]</div><p></p><p>  <em>本文其实还是信概 report, 所以写得比较严肃 qwq.</em></p>
<p>  概率数据结构 (Probabilistic Data Structure, PDS) 是一种依赖随机性质来获取相较确定性数据结构更优秀的时空效率的数据结构. 其核心要义是通过允许对询问的回答以一定的概率错误, 来极大地简化存储或计算成本. 当对答案的精确性要求不高, 或者精确答案的求解开销过大时, PDS 是一种适合的解决手段. 其在大数据和大模型等领域有较多的应用.</p>
<p>  本文试介绍 Bloom Filter, Four-colored Filter 和 Fermat Sketch, 前者是经典的 PDS, 后两者或许相对少见; 最后略作思考补充. 由于相关资料 (或者笔者的论文检索能力) 有限, 对 Four-colored Filter 和 Fermat Sketch 的介绍只基于信概课程的粗略笔记, 再由笔者重新推导成形, 可能有偏颇错漏, 还望批评指正.</p>
<h2 id="-bloom-filter"><span class="math inline">\(1\)</span> Bloom Filter</h2>
<p>  Bloom Filter 是一种经典的 PDS, 它可以用于处理以下问题:</p>
<blockquote>
<p><strong>问题 1.1</strong></p>
<p>  给定集合 <span class="math inline">\(S\)</span>, 回答若干次询问, 每次询问给出元素 <span class="math inline">\(x\)</span>, 回答是否有 <span class="math inline">\(x\in S\)</span>.</p>
</blockquote>
<p>  传统做法无非是使用 hash table 或者平衡树. 在数据量极大时, 它们都有较大的开销.</p>
<blockquote>
<p><strong>算法 1.2 (Bloom Filter)</strong><br>
  对 <u>问题 1.1</u>, 选定 hash 函数值域 <span class="math inline">\([0:m-1]\)</span> 和 <span class="math inline">\(k\)</span> 个不同且相互独立的 hash 函数 <span class="math inline">\(\{h_k\}\)</span> 来维护一个长为 <span class="math inline">\(m\)</span>, 初始全 <span class="math inline">\(0\)</span> 的 bit array, 以支持对 <span class="math inline">\(S\)</span> 的元素插入和在线查询.</p>
<ul>
<li>插入元素 <span class="math inline">\(x\)</span> 时: 将 bit array 中 <span class="math inline">\(h_1(x),\cdots,h_k(x)\)</span> 位置对应的 bit 全部置为 <span class="math inline">\(1\)</span>.</li>
<li>查询元素 <span class="math inline">\(y\)</span> 时: 检查 bit array 中 <span class="math inline">\(h_1(y),\cdots,h_k(y)\)</span> 位置对应的 bit 是否全部为 <span class="math inline">\(1\)</span>. 若全为 <span class="math inline">\(1\)</span>, 回答 "<span class="math inline">\(y\overset{?}\in S\)</span>", 否则回答 "<span class="math inline">\(y\notin S\)</span>".</li>
</ul>
</blockquote>
<p>  容易看出, Bloom Filter 只可能给出假阳性结果. 即, 若 Bloom Filter 认为 <span class="math inline">\(y\notin S\)</span>, 则 <span class="math inline">\(y\notin S\)</span> 事实上一定成立; 若 Bloom Filter 认为 <span class="math inline">\(y\overset{?}\in S\)</span>, 事实上不一定有 <span class="math inline">\(y\in S\)</span>, 因为 <span class="math inline">\(h_1(y),\cdots,h_k(y)\)</span> 这些 bit 可能被其他元素的 hash 值命中, 而产生错误.</p>
<p>  为了平衡效率和正确率, 我们需要对 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(k\)</span> 进行适当调节. 作为例子, 这里仅考察 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(|S|=n\)</span> 固定时对 <span class="math inline">\(k\)</span> 的选取, 同时假设 hash 函数的取值皆均匀随机. 在 <span class="math inline">\(n\)</span> 个元素插入完成后, 单个 bit 处于 <span class="math inline">\(0\)</span> 的概率为 <span class="math inline">\(p_0=\br{1-\frac{1}{m}}^{kn}\)</span>. 在 <span class="math inline">\(m\)</span> 充分大时, 根据</p>
<p></p><div class="math display">\[\lim_{m\to\oo}\br{1-\frac{1}{m}}^m=\frac{1}{e},
\]</div><p></p><p>可化简得</p>
<p></p><div class="math display">\[p_0\approx e^{-kn/m}.
\]</div><p></p><p>则 Bloom Filter 的假阳性概率可以估计为</p>
<p></p><div class="math display">\[\eps\approx(1-p_0)^k\approx\br{1-e^{-kn/m}}^k.
\]</div><p></p><p>令 <span class="math inline">\(q=n/m\)</span>, 那么</p>
<p></p><div class="math display">\[\ln\eps=k\ln\br{1-e^{-kq}}\\
\Ra \frac{\d \ln\eps}{\d k}=\ln\br{1-e^{-kq}}+\frac{kqe^{-kq}}{1-e^{-kq}}.
\]</div><p></p><p>令 <span class="math inline">\(t=e^{-kq}\)</span>, 则 <span class="math inline">\(kq=-\ln t\)</span>; 令导数取 <span class="math inline">\(0\)</span>, 则在极值点处有</p>
<p></p><div class="math display">\[\ln(1-t)-\frac{t\ln t}{1-t}=0\Eq (1-t)\ln(1-t)=t\ln t.
\]</div><p></p><p>其中 <span class="math inline">\(t\in(0,1)\)</span>, 由单调性不难看出当且仅当 <span class="math inline">\(t=\frac{1}{2}\)</span> 时取等. 这时</p>
<p></p><div class="math display">\[e^{-kn/m}=\frac{1}{2}\Ra k=\frac{m}{n}\ln2 .
\]</div><p></p><p>  此外, 在给定期待的误差率 <span class="math inline">\(\eps\)</span> 时, 也能给出相应的 <span class="math inline">\(m\)</span> 选取, 相关计算这里略去. 经此例可以看出, 诸如 Bloom Filter 这样的 PDS 内部具有较大的自由度, 因此有必要针对参数优化问题 (甚至结合硬件效率, 成本等因素) 进行充分的数学处理.</p>
<h2 id="-four-colored-filter"><span class="math inline">\(2\)</span> Four-colored Filter</h2>
<p>  在某种意义上, Four-colored Filter 是在一个限制更强的集合判属问题上对 Bloom Filter 的扩展.</p>
<blockquote>
<p><strong>问题 2.1</strong></p>
<p>  给定 <span class="math inline">\(n\)</span> 个无交集 <span class="math inline">\(\seq S1n\)</span>, 设 <span class="math inline">\(S=\bigsqcup_{i=1}^n S_i\)</span>. 回答若干次询问, 每次询问给定元素 <span class="math inline">\(x\in S\)</span>, 回答包含该元素的集合标号 <span class="math inline">\(k\)</span> (即存在且唯一的一个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(S_k\ni x\)</span>).</p>
</blockquote>
<p>  暂不谈实现时的内存效率, 我们可以通过二分或者二进制分组将 <u>问题 2.1</u> 转化为一个更简单的问题:</p>
<blockquote>
<p><strong>问题 2.2</strong></p>
<p>  给定 <span class="math inline">\(n=2\)</span> 个无交集 <span class="math inline">\(S^+,S^-\)</span>, 设 <span class="math inline">\(S=S^+\sqcup S^-\)</span>. 回答若干次询问, 每次询问给定元素 <span class="math inline">\(x\in S\)</span>, 判断是否 <span class="math inline">\(x\in S^+\)</span>.</p>
</blockquote>
<p>  <u>问题 2.2</u> 明显不强于 <u>问题 1.1</u>, 因此可以使用 Bloom Filter 解决: 对 <span class="math inline">\(S^+\)</span> (或 <span class="math inline">\(S^-\)</span>) 建立 Bloom Filter, 查询是否有 <span class="math inline">\(x\in S^+\)</span> (或 <span class="math inline">\(x\in S^-\)</span>) 即可得到 <u>问题 2.2</u> 解决方法. 然而, Bloom Filter 无法利用 <span class="math inline">\(x\in S=S^+\sqcup S^-\)</span> 这一信息, 而 Four-colored Filter 则是充分利用这一点来对算法进行了改进.</p>
<blockquote>
<p><strong>算法 2.3 (Four-colored Filter)</strong></p>
<p>  对 <u>问题 2.2</u>,&nbsp;取定 hash 值域 <span class="math inline">\(n\)</span> 和 hash 函数 <span class="math inline">\(h:S\to[1:n]^2\)</span>, 以此生成无向图 <span class="math inline">\(G=(V,E)\)</span>, 其中 <span class="math inline">\(V:=[1:n]\)</span>,</p>
<p></p><div class="math display">\[E^+:=\{(u,v,+):(u,v)\in h(S^+)\},\quad E^-:=\{(s,t,-):(s,t)\in h(S^-)\};\\
E:=E^+\sqcup E^-.
\]</div><p></p><p>称 <span class="math inline">\(E^+\)</span> 的元素为实边, <span class="math inline">\(E^-\)</span> 的元素为虚边. 不妨 <span class="math inline">\(|S^+|\ge|S^-|\)</span>, 反复尝试构造四染色 <span class="math inline">\(c:V\to\{0,1,2,3\}\)</span>, 满足</p>
<ul>
<li>实边异色: <span class="math inline">\(\A(u,v,+)\in E^+,~c(u)\neq c(v)\)</span>;</li>
<li>虚边同色: <span class="math inline">\(\A(s,t,-)\in E^-,~c(u)=c(v)\)</span>.</li>
</ul>
<p>若成功得到 <span class="math inline">\(c\)</span>, 则 Four-colored Filter 建立完成. 此后</p>
<ul>
<li>查询元素 <span class="math inline">\(y\)</span> 时: 计算 <span class="math inline">\(h(y)=(a,b)\)</span>, 若 <span class="math inline">\(c(a)=c(b)\)</span>, 则 <span class="math inline">\(y\in S^-\)</span>, 否则 <span class="math inline">\(y\in S^+\)</span>.</li>
<li>(若要求 Four-colored Filter 在线) 插入元素 <span class="math inline">\(x\)</span> 时: 在原图基础上加入 <span class="math inline">\(x\)</span> 对应的实边或虚边, 并从其两端出发搜索调整染色方案直到 <span class="math inline">\(c\)</span> 再次合法.</li>
</ul>
</blockquote>
<p>  相比于&nbsp;Bloom Filter, 一旦 Four-colored Filter 成功建立, 它的回答都一定是快速且完全正确的, 它适合用于应对对固定数据的大规模查询. 不过, 由于 4-coloring 问题是 NPC 的, 对 <span class="math inline">\(c\)</span> 的寻找必然依赖于随机性算法. 此外, <span class="math inline">\(h\)</span> 给出的 <span class="math inline">\(G\)</span> 本身可能带有明显的矛盾: 若虚边连通块中出现了实边, 则 <span class="math inline">\(c\)</span> 不可能存在, 这要求我们对 <span class="math inline">\(h\)</span> 的随机选取或调整. 事实上, 制定染色策略时认定 <span class="math inline">\(|S^+|\ge|S^-|\)</span> 也正是因此: 大量的同色连边倾向于在 <span class="math inline">\(G\)</span> 中形成一个巨大的连通块, 且此连通块在缩点后的度数较大, 二者分别容易导致块内和块外的染色不存在; 将较小的 <span class="math inline">\(E^-\)</span> 作为同色边则倾向于让 <span class="math inline">\(G\)</span> 的连通块和缩点后度数更加均匀, 更容易成功染色.</p>
<p>  笔者认为值得探索的地方:</p>
<ol>
<li><span class="math inline">\(n\)</span> 的选取. 从信息熵粗略估计, 当 <span class="math inline">\(n=\sqrt{|S|/2}\)</span> 时就已经能够无损地存放 <span class="math inline">\(S^+\)</span> 和 <span class="math inline">\(S^-\)</span> 的信息. 一般实现的时候取的是 <span class="math inline">\(n=|S|\)</span> (此处存疑), 这是否有必要?</li>
<li>染色数 <span class="math inline">\(k\)</span> 的选取. 我们直接承认了 <span class="math inline">\(k=4\)</span>, 这是因为 <span class="math inline">\(k\)</span> 更小时染色难以完成, <span class="math inline">\(k\)</span> 更大时会带来更大空间开销. 如何更细致地描述并推导 <span class="math inline">\(k\)</span> 的选取?</li>
</ol>
<h2 id="-fermat-sketch"><span class="math inline">\(3\)</span> Fermat Sketch</h2>
<p>  所谓 "sketch", 即 "草图", 指的是对数据的一种压缩存储方式. Fermat Sketch 试图解决以下问题:</p>
<blockquote>
<p><strong>问题 3.1</strong></p>
<p>  假设云端向本地用户传输了若干份数据包, 每个数据包有相应的 ID 和包数. 传输完成后, 要求云端向本地附带一则 sketch 信息, 帮助用户检查传输完整性 (是否丢包, 有哪几份数据包发生丢包).</p>
</blockquote>
<p>  我们可以将 (ID, 包数) 集合视为一个关于 ID 的可重集, 目标便是对两个可重集进行快速比较, 尽可能地描述出它们的差异.</p>
<blockquote>
<p><strong>算法 3.2 (Fermat Sketch)</strong></p>
<p>  对 <u>问题 3.1</u>, 设 ID 的值域 <span class="math inline">\(I=[1:m]\)</span>, 总包数 <span class="math inline">\(q\)</span>.&nbsp;选定 hash 范围 <span class="math inline">\(n\)</span>, 两个 hash 函数 <span class="math inline">\(f,g:I\to[1:n]\)</span> 和素数 <span class="math inline">\(p&gt;\max\{m,q\}\)</span>. 定义一个 Abel 群 <span class="math inline">\(G=(\F_p\x\Z,+)\)</span>, 其中</p>
<p></p><div class="math display">\[+:(u,a)\mapsto (v,b)\mapsto (u+_{\F_p}v,a+_\N b).
\]</div><p></p><p>  本地和云端分别维护两份 sketch <span class="math inline">\(\{s_i\}_{i=1}^n,\{t_i\}_{i=1}^n\)</span>, 其中 <span class="math inline">\(s_i,t_i\in G\)</span>. 当接收到 ID 为 <span class="math inline">\(i\)</span> 的包时, 令</p>
<p></p><div class="math display">\[s_{f(i)}\gets s_{f(i)}+(i,1),\quad t_{g(i)}\gets t_{g(i)}+(i,1).
\]</div><p></p><p>传输完成后, 云端将自己的两份 sketch 提供给本地. 不妨设此时云端 sketch 为 <span class="math inline">\(\{s_i\},\{t_i\}\)</span>, 本地 sketch 为 <span class="math inline">\(\{s_i'\},\{t_i'\}\)</span>. 接下来, 不断寻找下标 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(s_i\neq s_i'\)</span> 或者 <span class="math inline">\(t_i\neq t_i'\)</span>, 不妨设找到某个 <span class="math inline">\(s_i\neq s_i'\)</span>, 计算</p>
<p></p><div class="math display">\[(w,c):=s_i-s_i',\quad i_?:=w\x c^{-1}\in\F_p.
\]</div><p></p><p>检查是否有 <span class="math inline">\(f(i_?)=i\)</span> (rehash verification), 讨论:</p>
<ul>
<li>
<p>若是, 相信 <span class="math inline">\((w,c)\)</span> 恰好描述了 ID 为 <span class="math inline">\(i_?\)</span> 的包的本地-云端差异. 此时 <span class="math inline">\(c\)</span> 就是差异数量. 此后在本地 sketch 中消除此差异, 令</p>
<p></p><div class="math display">\[s_i'\gets s_i,\quad t_{g(i_?)}'\gets t_{g(i_?)}'+(i,c).
\]</div><p></p></li>
<li>
<p>否则, 忽略这个 <span class="math inline">\(i\)</span>, 寻找其他的 <span class="math inline">\(i\)</span>.</p>
</li>
</ul>
<p>  如果一切 <span class="math inline">\(s_i=s_i'\)</span> 且 <span class="math inline">\(t_i=t_i'\)</span>, Fermat Sketch 便认为成功找出了所有差异; 否则若找不到任何一个合适的 <span class="math inline">\(i\)</span>, 则认为 Fermat Sketch 的搜索失败.</p>
</blockquote>
<p>  可以感知到, 用两个 hash 维护两份 sketch 的目的是让 "消除差异" 变得可能: 例如某处 <span class="math inline">\(s_i\)</span> 的 hash 冲突导致无法通过 <span class="math inline">\(s_i\)</span> 还原差异, 我们还有 <span class="math inline">\(t_i\)</span> 能提供线索; 如果某处 <span class="math inline">\(s_i\)</span> 可以用作还原差异, 它也能为对应的 <span class="math inline">\(t_{g(i_?)}\)</span> 提供修正, 如此迭代便提高了顺利找出所有差异的概率.</p>
<p>  如果希望提高 rehash verification 的置信度, 只需要对每个 ID 附带上随机指纹 <span class="math inline">\(\textit{fp}\in\F_p\)</span>, 参与与 ID 相同的运算, rehash 时顺便比较随机指纹即可.</p>
<h2 id="-补充与思考"><span class="math inline">\(4\)</span> 补充与思考</h2>
<p>  本文尚有大量未提及的经典 PDS, 例如 Count-min Sketch, Universal Sketch 等. PDS 在诸多计算机领域有所应用, 如垂直领域大模型的检索增强生成, 缓存替换策略等, 不一而足.</p>
<p>  笔者认为, PDS 有很大的研究价值. 理论上, 一切问题都可以通过附带一个 "错误接受程度" 来引入 PDS; 工业上, 大多数问题都并不要求精确求解, 因此 PDS 具有很强的普适性和实用性. 受 Four-colored Filter 的启发, 笔者猜测一种可能的研究方向是将某些问题先映射到一个 NPC 但足以提供良好性质的问题上, 进而借助已有的对 NPC 问题的丰富研究来设计更多 PDS.</p>
<hr>
<p><strong>References</strong></p>
<ol>
<li>《信息科学技术概论》2024/09/13 课程内容 (by 杨仝老师).</li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener nofollow">https://en.wikipedia.org/wiki/Bloom_filter</a></li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.20356643256944446" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-09 19:25">2025-01-09 19:25</span>&nbsp;
<a href="https://www.cnblogs.com/rainybunny">Rainybunny</a>&nbsp;
阅读(<span id="post_view_count">61</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18662683" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18662683);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18662683', targetLink: 'https://www.cnblogs.com/rainybunny/p/18662683', title: 'Report -「概率数据结构」随机化骗分？我们是专业的！' })">举报</a>
</div>
        