
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhiyin123/p/18694566" title="发布于 2025-01-29 13:15">
    <span role="heading" aria-level="2">欧几里得相关算法【含万能欧几里得】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>本文将介绍几个和<em>欧几里得</em>算法算法相关的算法，它们都使用了<strong>辗转相除</strong>的计算策略，获得类似于 <span class="math inline">\(O(\log V)\)</span>（<span class="math inline">\(V\)</span> 为值域）的优秀复杂度。</p>
<p>本文将提供清晰的（数学公式用 <span class="math inline">\(\LaTeX\)</span> 呈现的）<em><strong>伪代码</strong></em>。</p>
<h1 id="约定">约定</h1>
<ul>
<li>对于整数 <span class="math inline">\(x,y\)</span>，定义 <span class="math inline">\(z=x\bmod y\)</span>，当且仅当 <span class="math inline">\(z\)</span> 是最小的<strong>非负整数</strong>，满足 <span class="math inline">\(y\mid (x-z)\)</span>。中间一竖是<em>整除</em>符号。</li>
</ul>
<h1 id="求最大公约数">求最大公约数</h1>
<p><strong>问题</strong>：给定正整数 <span class="math inline">\(x,y\leq V\)</span>，求 <span class="math inline">\(\gcd(x,y)\)</span>。（<span class="math inline">\(\gcd(x,y)\)</span> 表示 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的最大公约数）</p>
<hr>
<p><strong>解说</strong>：若 <span class="math inline">\(x=y\)</span>，则平凡地，<span class="math inline">\(\gcd(x,y)=x\)</span>。不妨设 <span class="math inline">\(x&lt;y\)</span>，则显然有 <span class="math inline">\(\gcd(x,y)=\gcd(y-x,x)\)</span>，根据取模的定义，可得 <span class="math inline">\(\gcd(x,y)=\gcd(y\bmod x,x)\)</span>，于是就有做法了。</p>
<hr>
<p><strong>伪代码</strong>：（函数的返回值即为答案）</p>
<ul>
<li>function <span class="math inline">\(\text{solve}(x,y)\)</span>
<ul>
<li>if <span class="math inline">\(x=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(y\)</span></li>
</ul>
</li>
<li><strong>return</strong> <span class="math inline">\(\text{solve}(y\bmod x,x)\)</span></li>
</ul>
</li>
</ul>
<hr>
<p><strong>复杂度分析</strong>：设时间复杂度为 <span class="math inline">\(\mathcal{T}(x,y)\)</span>，现在我们证明如下命题：</p>
<ul>
<li><span class="math inline">\(\displaystyle\exists x',y'\in \mathbb N^+,x'\leq \frac{x}{2},y'\leq y\)</span>，满足 <span class="math inline">\(\mathcal{T}(x,y)\leq \mathcal{T}(x',y')+O(1)\)</span>。</li>
</ul>
<p>如果该命题成立，就容易推出 <span class="math inline">\(\mathcal{T}(x,y)=O(\log V)\)</span> 了。</p>
<p>不妨设 <span class="math inline">\(r=y\bmod x\)</span>，则分两种情况讨论。</p>
<ol>
<li>若 <span class="math inline">\(\displaystyle r\leq\frac{x}{2}\)</span>，根据算法过程，<span class="math inline">\(\mathcal{T}(x,y)=\mathcal{T}(x,r)+O(1)=\mathcal{T}(r,x)+O(1)\)</span>，命题成立。</li>
<li>若 <span class="math inline">\(\displaystyle r&gt;\frac{x}{2}\)</span>，则有 <span class="math inline">\(\mathcal{T}(x,y)=\mathcal{T}(r,x)+O(1)=\mathcal{T}(x\bmod r,x)+O(1)\)</span>，此时 <span class="math inline">\(\displaystyle x\bmod r=x-r\leq\frac{x}{2}\)</span>，故命题成立。</li>
</ol>
<p>于是，该算法的复杂度为</p>
<p></p><div class="math display">\[\boxed{O(\log V)}
\]</div><p></p><p>之后算法的复杂度都与它类似，将不再证明。</p>
<h1 id="扩展欧几里得">扩展欧几里得</h1>
<p><strong>问题</strong>：给定正整数 <span class="math inline">\(a,b\leq V\)</span>，请求出关于 <span class="math inline">\((x,y)\)</span> 的方程</p>
<p></p><div class="math display">\[ax+by=1
\]</div><p></p><p>的任意整数解（即满足 <span class="math inline">\(x,y\in\mathbb{Z}\)</span>），保证有整数解。</p>
<hr>
<p><strong>解说</strong>：当 <span class="math inline">\(a=b\)</span> 是，方程无整数解，所以不妨设 <span class="math inline">\(a&lt;b\)</span>。直接将 <span class="math inline">\(b\)</span> 写成<em><strong>带余除法</strong></em>形式</p>
<p></p><div class="math display">\[\begin{gathered}
k=\lfloor\frac{b}{a}\rfloor\\
r=(b\bmod a)\\
b=ka+r
\end{gathered}
\]</div><p></p><p>将 <span class="math inline">\(b=ka+r\)</span> 代入方程，整理得</p>
<p></p><div class="math display">\[ry+a(x+ky)=1
\]</div><p></p><p>可以将其看做关于 <span class="math inline">\((y,x+ky)\)</span> 的方程，这样，原本的系数为 <span class="math inline">\(\displaystyle\left[\begin{matrix}a\\ b\end{matrix}\right]\)</span> 的问题就能转化为系数为 <span class="math inline">\(\displaystyle\left[\begin{matrix}r\\ a\end{matrix}\right]\)</span> 的问题。这样，算法就呼之欲出了。</p>
<hr>
<p><strong>伪代码</strong>：</p>
<ul>
<li>function <span class="math inline">\(\text{solve}(a,b)\)</span>
<ul>
<li>if <span class="math inline">\(a=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\((0,1)\)</span></li>
</ul>
</li>
<li>let <span class="math inline">\((x',y')= \text{solve}(b\bmod a,a)\)</span></li>
<li><strong>return</strong> <span class="math inline">\(\displaystyle (y'-\lfloor\frac{b}{a}\rfloor\times x',x')\)</span></li>
</ul>
</li>
</ul>
<hr>
<p><strong>复杂度分析</strong>：与欧几里得算法一样，<span class="math inline">\(O(\log V)\)</span>。</p>
<hr>
<p><strong>生长</strong>：如果想要更详细的了解该算法，参见<a href="https://oi-wiki.org/math/number-theory/bezouts/" target="_blank" rel="noopener nofollow">裴蜀定理 - OI Wiki</a>。</p>
<h1 id="线性同余不等式约束下的最小值">线性同余不等式约束下的最小值</h1>
<p><strong>问题</strong>：给定正整数 <span class="math inline">\(a,m\)</span>（<span class="math inline">\(a&lt;m\)</span>）和非负整数 <span class="math inline">\(L\leq R&lt;m\)</span>，请求出<strong>最小的非负整数</strong> <span class="math inline">\(x\)</span> 使得</p>
<p></p><div class="math display">\[L\leq ax\bmod m\leq R
\]</div><p></p><p>若不存在这样的 <span class="math inline">\(x\)</span>，需要报告无解。</p>
<hr>
<p><strong>解说</strong>：如果 <span class="math inline">\([L,R]\)</span> 中有 <span class="math inline">\(a\)</span> 的倍数，即满足 <span class="math inline">\(\displaystyle a\times\lceil\frac{L}{a}\rceil\leq R\)</span> 时，<span class="math inline">\(x\)</span> 显然为 <span class="math inline">\(\displaystyle\lceil\frac{L}{a}\rceil\)</span>。</p>
<p>在其他情况下，不妨将问题转化，再添加一个变量 <span class="math inline">\(k\)</span>，问题变为：找到<strong>最小的非负整数</strong> <span class="math inline">\(k\)</span>，使得<strong>存在非负整数</strong> <span class="math inline">\(x\)</span>，满足</p>
<p></p><div class="math display">\[L\leq ax-km\leq R
\]</div><p></p><p>因为这里的 <span class="math inline">\(k\)</span> 相当于 <span class="math inline">\(\displaystyle\lfloor\frac{ax}{m}\rfloor\)</span>，所以当 <span class="math inline">\(k\)</span> 最小时，<span class="math inline">\(x\)</span> 可以取到最小的 <span class="math inline">\(\displaystyle \lceil\frac{L+km}{a}\rceil\)</span>。</p>
<p>变形可得，<strong>存在</strong> <span class="math inline">\(x\)</span> 满足上述不等式，当且仅当</p>
<p></p><div class="math display">\[(-R)\bmod a\leq mk\bmod a\leq (-L)\bmod a
\]</div><p></p><p>其中 <span class="math inline">\(mk\bmod a=(m\bmod a)k\bmod a\)</span>。</p>
<p>所以算法就呼之欲出了。</p>
<hr>
<p><strong>伪代码</strong>：</p>
<ul>
<li>function <span class="math inline">\(\text{solve}(a,m,L,R)\)</span>
<ul>
<li>if <span class="math inline">\(L=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(0\)</span></li>
</ul>
</li>
<li>if <span class="math inline">\(a=0\)</span> <strong>or</strong> <span class="math inline">\(R&lt;L\)</span> then
<ul>
<li><strong>return</strong> 无解</li>
</ul>
</li>
<li>if <span class="math inline">\(\displaystyle a\times\lceil\frac{L}{a}\rceil\leq R\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(\displaystyle\lceil\frac{L}{a}\rceil\)</span></li>
</ul>
</li>
<li>let <span class="math inline">\(k=\text{solve}(m\bmod a,a,(-R)\bmod a,(-L)\bmod a)\)</span></li>
<li>if <span class="math inline">\(k=\)</span> 无解 then
<ul>
<li><strong>return</strong> 无解</li>
</ul>
</li>
<li><strong>return</strong> <span class="math inline">\(\displaystyle\lceil\frac{L+km}{a}\rceil\)</span></li>
</ul>
</li>
</ul>
<hr>
<p><strong>时间复杂度</strong>：同样是 <span class="math inline">\(O(\log V)\)</span>。</p>
<hr>
<p><strong>帮助</strong>：你可能需要这个式子 <span class="math inline">\(\displaystyle\lceil\frac{x}{y}\rceil=\lfloor\frac{x+y-1}{y}\rfloor\)</span>（当 <span class="math inline">\(x,y\in \mathbb{Z},y&gt;0\)</span> 时成立）。</p>
<h1 id="类欧几里得">类欧几里得</h1>
<p><strong>问题</strong>：给定非负整数 <span class="math inline">\(n,a,b,c\leq V\)</span>，满足 <span class="math inline">\(c\neq 0\)</span>，求</p>
<p></p><div class="math display">\[\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor
\]</div><p></p><hr>
<p><strong>解决</strong>：不妨设答案为 <span class="math inline">\(f(a,n,b,c)\)</span>，则当 <span class="math inline">\(a=0\)</span> 时，有</p>
<p></p><div class="math display">\[f(a,n,b,c)=\lfloor\frac{b}{c}\rfloor\cdot (n+1)
\]</div><p></p><p>当 <span class="math inline">\(a\geq c\)</span> 或 <span class="math inline">\(b\geq c\)</span> 时，有</p>
<p></p><div class="math display">\[\begin{gathered}
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\\
=\sum_{i=0}^n\left\lfloor\frac{(a\bmod c)i+(b\bmod c)}{c}\right\rfloor+\lfloor\frac{a}{c}\rfloor \cdot\frac{n(n+1)}{2}+\lfloor\frac{b}{c}\rfloor\cdot (n+1)\\
=f(a\bmod c,b\bmod c,c,n)+\lfloor\frac{a}{c}\rfloor \cdot \frac{n(n+1)}{2}+\lfloor\frac{b}{c}\rfloor\cdot (n+1)
\end{gathered}
\]</div><p></p><p>当 <span class="math inline">\(a&lt;c\)</span> 且 <span class="math inline">\(b&lt;c\)</span> 时，有（不妨设 <span class="math inline">\(\displaystyle m=\left\lfloor\frac{an+b}{c}\right\rfloor\)</span>）</p>
<p></p><div class="math display">\[\begin{gathered}
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\\
=\sum_{i=0}^n\sum_{j=0}^{m-1} [c(j+1)\leq ai+b]\\
=\sum_{j=0}^{m-1}\sum_{i=0}^n [ai&gt; cj+c-b-1]\\
=\sum_{j=0}^{m-1}\left(n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)\\
=mn-\sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\\
=mn-f(c,c-b-1,a,m-1)
\end{gathered}
\]</div><p></p><p>然后就有做法了。</p>
<hr>
<p><strong>伪代码</strong>：</p>
<ul>
<li>function <span class="math inline">\(\text{solve}(a,b,c,n)\)</span>
<ul>
<li>if <span class="math inline">\(n=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(\displaystyle \lfloor\frac{b}{c}\rfloor\)</span></li>
</ul>
</li>
<li>if <span class="math inline">\(a\geq c\)</span> <strong>or</strong> <span class="math inline">\(b\geq c\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(\displaystyle \text{solve}(a\bmod c,b\bmod c,c,n)+\lfloor\frac{a}{c}\rfloor \cdot \frac{n(n+1)}{2}+\lfloor\frac{b}{c}\rfloor\cdot (n+1)\)</span></li>
</ul>
</li>
<li>let <span class="math inline">\(\displaystyle m=\left\lfloor\frac{an+b}{c}\right\rfloor\)</span></li>
<li>if <span class="math inline">\(m=0\)</span> then <sup class="footnote-ref"><a href="#fn1" id="fnref1" rel="noopener nofollow">[1]</a></sup>
<ul>
<li><strong>return</strong> <span class="math inline">\(0\)</span></li>
</ul>
</li>
<li><strong>return</strong> <span class="math inline">\(mn-\text{solve}(c,c-b-1,a,m-1)\)</span></li>
</ul>
</li>
</ul>
<hr>
<p><strong>复杂度分析</strong>：为 <span class="math inline">\(O(\log V)\)</span>。</p>
<h1 id="万能欧几里得">万能欧几里得</h1>
<p><strong>约定</strong>：在本节中，部分运算将在<em><strong>群</strong></em> <span class="math inline">\(G\)</span> 下进行，所有的<strong>乘法运算</strong>都可能被看做 <span class="math inline">\(G\)</span> 的群乘法。</p>
<hr>
<p><strong>问题</strong>：给定<em><strong>群元</strong></em> <span class="math inline">\(e,r,s\in G\)</span>，其中 <span class="math inline">\(e\)</span> 为<em><strong>单位元</strong></em>，给定函数（其中 <span class="math inline">\(a,b,c\in\mathbb{N},c\neq 0\)</span>）</p>
<p></p><div class="math display">\[\xi(x)=\frac{ax+b}{c}
\]</div><p></p><p>函数 <span class="math inline">\(f: \mathbb{N}\to G\)</span> 的定义见下方伪代码。给定非负整数 <span class="math inline">\(n\leq V\)</span>，请求出 <span class="math inline">\(f(n)\)</span> 的值。</p>
<p>下方伪代码中，<span class="math inline">\(\epsilon\)</span> 为<strong>无穷小的正数</strong>。</p>
<ul>
<li>function <span class="math inline">\(f(n)\)</span>
<ul>
<li>let <span class="math inline">\(x=\epsilon\)</span>, <span class="math inline">\(\text{ans}=e\)</span></li>
<li>while <span class="math inline">\(x\leq n\)</span> do
<ul>
<li>if <span class="math inline">\(\xi(x)\in\mathbb Z\)</span> then
<ul>
<li><span class="math inline">\(\text{ans}\gets \text{ans}\times r\)</span></li>
</ul>
</li>
<li>if <span class="math inline">\(x\in\mathbb Z\)</span> then
<ul>
<li><span class="math inline">\(\text{ans}\gets \text{ans}\times s\)</span></li>
</ul>
</li>
<li><span class="math inline">\(x\gets x+\epsilon\)</span></li>
</ul>
</li>
<li><strong>return</strong> <span class="math inline">\(\text{ans}\)</span></li>
</ul>
</li>
</ul>
<p>假设群 <span class="math inline">\(G\)</span> 的乘法能做到单次 <span class="math inline">\(O(T)\)</span> 的复杂度。</p>
<hr>
<p><strong>解说</strong>：当 <span class="math inline">\(n=0\)</span> 时，平凡的，<span class="math inline">\(f(0)=e\)</span>。</p>
<p>不妨设答案为 <span class="math inline">\(g(a,b,c,n,r,s)\)</span>。</p>
<p>容易发现，把 <span class="math inline">\(\xi\)</span> 所代表的的直线向下平移是没有影响的，即</p>
<p></p><div class="math display">\[g(a,b,c,n,r,s)=g(a,b\bmod c,c,n,r,s)
\]</div><p></p><p>这里不妨设 <span class="math inline">\(b&lt;c\)</span>。</p>
<p>当 <span class="math inline">\(a\geq c\)</span> 时，<strong>尝试让一方模另一方</strong>。根据 <span class="math inline">\(f\)</span> <strong>差分的周期性</strong>，有：</p>
<p></p><div class="math display">\[g(a,b,c,n,r,s)=g(a\bmod c,b,c,n,r,r^{\lfloor\frac{a}{c}\rfloor}
\times s)
\]</div><p></p><p>可以使用 <span class="math inline">\(f\)</span> 的<strong>几何意义</strong>直观理解该式。可以把 <span class="math inline">\(f\)</span> 看成一条欧氏平面中的直线，是否乘 <span class="math inline">\(r\)</span> 或 <span class="math inline">\(s\)</span> 取决于直线上某点的纵坐标或横坐标是否是整数。发现每次给 <span class="math inline">\(\text{ans}\)</span> 乘上 <span class="math inline">\(s\)</span> 前先至少要乘 <span class="math inline">\(\displaystyle \lfloor\frac{a}{c}\rfloor\)</span> 个 <span class="math inline">\(r\)</span>。</p>
<p>当 <span class="math inline">\(a&lt;c\)</span> 时，<strong>尝试交换它们</strong>。</p>
<p>考虑直接将 <span class="math inline">\(\text{ans}\)</span> 写成<em>求积</em>形式，有</p>
<p></p><div class="math display">\[\text{ans}=\prod_{i=1}^n r^{\lfloor\xi(i)\rfloor-\lfloor\xi(i-1)\rfloor}\times s
\]</div><p></p><p>为了方便研究，用<strong><em>字符串</em>表示群元</strong>，群乘法表示为<em><strong>字符串的拼接</strong></em>，设 <span class="math inline">\(e\)</span> 为<strong>空字符串</strong>，<span class="math inline">\(r=\texttt{r}\)</span>，<span class="math inline">\(s=\texttt{s}\)</span>，则 <span class="math inline">\(\text{ans}\)</span> 为一个由 <span class="math inline">\(\texttt{r}\)</span> 和 <span class="math inline">\(\texttt{s}\)</span> 构成的字符串。</p>
<p>比较显然的是，<span class="math inline">\(\text{ans}\)</span> 中，第 <span class="math inline">\(i\)</span> 个 <span class="math inline">\(\texttt{s}\)</span> 前有 <span class="math inline">\(\lfloor\xi(i)\rfloor\)</span> 个 <span class="math inline">\(\texttt{r}\)</span>。为了达到交换效果，我们不妨计算 <span class="math inline">\(\text{ans}\)</span> 中，第 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(\texttt{r}\)</span> 前面有几个 <span class="math inline">\(\texttt{s}\)</span>。容易列出式子，答案为下方不等式中，整数 <span class="math inline">\(t\)</span> 的最大值。</p>
<p></p><div class="math display">\[\left\lfloor\frac{at+b}{c}\right\rfloor&lt;j
\]</div><p></p><p>它是</p>
<p></p><div class="math display">\[\frac{at+b}{c}&lt;j
\]</div><p></p><p>解不等式得 <span class="math inline">\(t\)</span> 的<strong>最大值</strong>为</p>
<p></p><div class="math display">\[\left\lfloor\frac{c(j-1)+c-b-1}{a}\right\rfloor
\]</div><p></p><p>不妨设函数 <span class="math inline">\(\displaystyle \xi'(x)=\frac{cx+c-b-1}{a}\)</span>。</p>
<p>于是 <span class="math inline">\(\text{ans}\)</span> 可以被表示为（不妨设 <span class="math inline">\(m=\lfloor\xi(n)\rfloor\)</span>）</p>
<p></p><div class="math display">\[\begin{gathered}
\text{ans}=s^{\lfloor\xi'(1-1)\rfloor}\times r\times\left(\prod_{j=2}^{m} s^{\lfloor\xi'(j-1)\rfloor-\lfloor\xi'((j-1)-1)\rfloor} \times r\right) \times s^{n-\lfloor\xi'(m-1)\rfloor}\\
=s^{\lfloor\xi'(0)\rfloor}\times r\times \left(\prod_{j=1}^{m-1}s^{\lfloor\xi'(j)\rfloor-\lfloor\xi'(j-1)\rfloor} \times r\right)\times s^{n-\lfloor\xi'(m-1)\rfloor}\\
=s^{\left\lfloor\frac{c-b-1}{a}\right\rfloor}\times r\times g(c,c-b-1,a,m-1,s,r)\times s^{n-\lfloor\xi'(m-1)\rfloor}\\
=s^{\left\lfloor\frac{c-b-1}{a}\right\rfloor}\times r\times g(c,(c-b-1)\bmod a,a,m-1,s,r)\times s^{n-\left\lfloor\frac{cm-b-1}{a}\right\rfloor}\\
\end{gathered}
\]</div><p></p><p>然后就有做法了。</p>
<hr>
<p><strong>伪代码</strong>：</p>
<ul>
<li>function <span class="math inline">\(\text{solve}(a,b,c,n,r,s)\)</span>
<ul>
<li>if <span class="math inline">\(n=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(e\)</span></li>
</ul>
</li>
<li>if <span class="math inline">\(a\geq c\)</span> <strong>or</strong> <span class="math inline">\(b\geq c\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(\text{solve}(a\bmod c,b\bmod c,c,n,r,r^{\lfloor\frac{a}{c}\rfloor}\times s)\)</span></li>
</ul>
</li>
<li>let <span class="math inline">\(\displaystyle m=\left\lfloor\frac{an+b}{c}\right\rfloor\)</span></li>
<li>if <span class="math inline">\(m=0\)</span> then
<ul>
<li><strong>return</strong> <span class="math inline">\(s^n\)</span></li>
</ul>
</li>
<li><strong>return</strong> <span class="math inline">\(s^{\left\lfloor\frac{c-b-1}{a}\right\rfloor}\times r\times g(c,(c-b-1)\bmod a,a,m-1,s,r)\times s^{n-\left\lfloor\frac{cm-b-1}{a}\right\rfloor}\)</span></li>
</ul>
</li>
</ul>
<hr>
<p><strong>复杂度分析</strong>：如果群元的次幂可以 <span class="math inline">\(O(T)\)</span> 计算，那么时间复杂度就是 <span class="math inline">\(O(T\log V)\)</span> 的。如果不可以，那么可以使用<a href="https://oi-wiki.org/math/binary-exponentiation/" target="_blank" rel="noopener nofollow">快速幂 - OI Wiki</a>算法做到单次 <span class="math inline">\(O(T\log V)\)</span>，那么时间复杂度有上界 <span class="math inline">\(O(T\log^2 V)\)</span>。</p>
<p>实际上，有更紧的上界，设时间复杂度为 <span class="math inline">\(\mathcal{T}(a,c)\)</span>，则有</p>
<p></p><div class="math display">\[\mathcal{T}(a,c)=O(T\log \frac{a}{c})+\mathcal{T}(c\bmod a,a)
\]</div><p></p><p>考虑到 <span class="math inline">\(\displaystyle O(T\log \frac{a}{c})=O(T\log a)-O(T\log c)\)</span>，所以，将 <span class="math inline">\(\mathcal{T}(a,c)\)</span> 直接展开后，含有 <span class="math inline">\(\log\)</span> 的项会消得只剩 <span class="math inline">\(O(1)\)</span> 个，于是复杂度就是</p>
<p></p><div class="math display">\[\boxed{O(T\log V)}
\]</div><p></p><hr>
<p>完结撒花。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>实际上，这个条件判断可以去掉，因为 <span class="math inline">\(n&lt;0\)</span> 时不会让该算法错误。 <a href="#fnref1" class="footnote-backref" rel="noopener nofollow">↩︎</a></p>
</li>
</ol>
</section>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.3742067833287037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-29 13:15">2025-01-29 13:15</span>&nbsp;
<a href="https://www.cnblogs.com/zhiyin123">zhiyin123123</a>&nbsp;
阅读(<span id="post_view_count">83</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18694566" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18694566);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18694566', targetLink: 'https://www.cnblogs.com/zhiyin123/p/18694566', title: '欧几里得相关算法【含万能欧几里得】' })">举报</a>
</div>
        