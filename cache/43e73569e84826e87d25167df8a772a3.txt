
        <div class="postTitle">
            <h1><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenyishi/p/18706989" title="发布于 2025-02-10 09:26">
    <span role="heading" aria-level="2">.NET最佳实践：避免同步读取HttpRequest</span>
    

</a>
</h1>
        </div>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h4>为什么要避免同步读取</h4>
<p>ASP.NET Core 中的所有 I/O 操作都是异步的。服务器实现了 <code>Stream</code> 接口，该接口同时具备同步和异步的方法。</p>
<p>在进行 I/O 操作时，应优先使用异步方法，以避免阻塞线程池的线程。</p>
<p>如果阻塞了线程池线程，可能会导致服务器无法处理更多请求，造成急剧性<strong>性能下降</strong>。</p>
<p>尤其是<strong>当客户端上传速度缓慢时</strong>，同步读取将<strong>阻塞</strong>线程直到整个请求体被全部读取完成。</p>
<h4>如何避免同步读取</h4>
<p><strong>错误的做法</strong></p>
<p>以下代码示例使用了同步方法 <code>ReadToEnd</code>，导致线程被阻塞：</p>
<pre><code class="language-csharp">public class BadStreamReaderController : Controller
{
    [HttpGet("/contoso")]
    public ActionResult&lt;ContosoData&gt; Get()
    {
        var json = new StreamReader(Request.Body).ReadToEnd();

        return JsonSerializer.Deserialize&lt;ContosoData&gt;(json);
    }
}
</code></pre>
<p>在这段代码中，<code>Get</code>方法将整个 HTTP 请求体同步读入内存。如果客户端上传速度缓慢，应用程序将<strong>阻塞</strong>在这个读取操作上，导致效率下降。</p>
<p><strong>正确的做法</strong></p>
<p>使用异步方法 <code>ReadToEndAsync</code>，可以避免阻塞线程：</p>
<pre><code class="language-csharp">public class GoodStreamReaderController : Controller
{
    [HttpGet("/contoso")]
    public async Task&lt;ActionResult&lt;ContosoData&gt;&gt; Get()
    {
        var json = await new StreamReader(Request.Body).ReadToEndAsync();

        return JsonSerializer.Deserialize&lt;ContosoData&gt;(json);
    }
}
</code></pre>
<p>这段代码使用异步读取方法，在读取过程中不会阻塞线程，可以<strong>提升性能</strong>和响应速度。</p>
<h4>读取表单数据时的注意事项</h4>
<p><strong>错误的做法</strong></p>
<p>使用 <code>HttpContext.Request.Form</code>，会在内部执行同步读取，导致线程被阻塞：</p>
<pre><code class="language-csharp">public class BadReadController : Controller
{
    [HttpPost("/form-body")]
    public IActionResult Post()
    {
        var form = HttpContext.Request.Form;

        Process(form["id"], form["name"]);

        return Accepted();
    }
}
</code></pre>
<p><strong>正确的做法</strong></p>
<p>使用 <code>ReadFormAsync</code>，进行异步读取：</p>
<pre><code class="language-csharp">public class GoodReadController : Controller
{
    [HttpPost("/form-body")]
    public async Task&lt;IActionResult&gt; Post()
    {
        var form = await HttpContext.Request.ReadFormAsync();

        Process(form["id"], form["name"]);

        return Accepted();
    }
}
</code></pre>
<p>这种做法使用异步方式读取表单数据，能有效避免阻塞线程池资源。</p>
<h4><strong>结论</strong></h4>
<p>在 ASP.NET Core 开发中，应符合框架的异步操作模式，避免使用同步方法读取 HTTP 请求文本。</p>
<p>这样可以有效地提升应用程序的性能和响应速度，避免因阻塞导致的急剧性性能下降。</p>
</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="9.619446016418982" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 09:27">2025-02-10 09:26</span>&nbsp;
<a href="https://www.cnblogs.com/chenyishi">chester·chen</a>&nbsp;
阅读(<span id="post_view_count">769</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18706989" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18706989);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18706989', targetLink: 'https://www.cnblogs.com/chenyishi/p/18706989', title: '.NET最佳实践：避免同步读取HttpRequest' })">举报</a>
</div>
    