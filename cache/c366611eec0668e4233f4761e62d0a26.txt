
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cwkiller/p/19025951" title="发布于 2025-08-06 22:03">
    <span role="heading" aria-level="2">heapdump深度利用之信息泄露篇</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        前言 在Java里有一些渗透场景可以获得堆内存也即是heapdump比如有的应用存在某个功能可以获取
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>在<code>Java</code>里有一些渗透场景可以获得堆内存也即是<code>heapdump</code>比如有的应用存在某个功能可以获取<code>heapdump</code>、<code>springboot</code>的<code>/actuator/heapdump</code>也可以获取。但是网上比较多的分析文章讲的都比较浅导致挺多人不知道<code>heapdump</code>里到底有什么东西，这篇文章讲一讲对<code>heapdump</code>进行深入分析获取某些特定信息。</p>
<h1 id="常规信息获取">常规信息获取</h1>
<p>先讲一下大多数人的分析方式。最早的时候大家都是使用<code>MAT</code>、<code>jhat</code>、<code>jvisualvm</code>然后使用<code>oql</code>语句去查询字符串里的敏感信息。我当时刚接触的时候对这个的分析文章比较少我记得最早讲的比较清楚的文章是下面这篇<br>
<em><a href="https://zen-sec.github.io/fr/java-heapdump-extraction/" target="_blank" rel="noopener nofollow">https://zen-sec.github.io/fr/java-heapdump-extraction/</a></em><br>
这个时期的<code>oql</code>语句主要集中在查询配置信息，以及内存中可能存在的<code>user|pass|email|oss|aksk|jwt|shiro-key</code>等信息后来有人写了自动化的分析工具主要是下面两款<br>
<em><a href="https://github.com/wyzxxz/heapdump_tool" target="_blank" rel="noopener nofollow">https://github.com/wyzxxz/heapdump_tool</a></em><br>
<em><a href="https://github.com/whwlsfb/JDumpSpider" target="_blank" rel="noopener nofollow">https://github.com/whwlsfb/JDumpSpider</a></em><br>
距离工具发布到现在已经有好几年的时间了，然后我发现很多朋友好像已经不会使用<code>oql</code>语句自定义查询信息了，都是使用这两款工具执行一下就结束然后这两款工具有的时候输出没什么敏感的东西就直接结束了不再进行深度利用，我将在下面写一下这两款工具没有覆盖的一些信息获取方式。</p>
<h1 id="深度信息获取">深度信息获取</h1>
<p>假设我们利用上述两款工具没有获取到什么有用信息还可以使用下面的方式进行利用，这里仅列举出一些案例有其他感兴趣的东西可以自己构造语句查询。使用<code>MAT</code>打开<code>heapdump</code>，主要现在<code>MAT</code>的主要版本需要使用<code>jdk17+</code>才能使用，我jdk环境默认1.8可以使用命令行vm参数指定一个jdk17路径打开<br>
<code>MemoryAnalyzer.exe -vm "C:\Users\admin\.jdks\jbr-17.0.12\bin\javaw.exe"</code><br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220251320-660829414.png" alt="" loading="lazy"><br>
从这里打开你下载的<code>heapdump</code>然后点击下面图标进行<code>oql</code>查询<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220251814-2081393273.png" alt="" loading="lazy"></p>
<h2 id="查询依赖版本">查询依赖版本</h2>
<p>我们首先可以查看这个应用有什么依赖以及他们具体是什么版本,直接从字符串中搜索<code>DISTINCT</code>用于去重(也可通过类加载器查询)。</p>
<pre><code>SELECT DISTINCT toString(s) FROM java.lang.String s WHERE (toString(s) LIKE "file.*\.jar!/")
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220252505-1388482242.png" alt="" loading="lazy"><br>
比如这里发现<code>fastjson</code>依赖在漏洞范围内即可尝试<code>fastjson</code>漏洞。</p>
<h2 id="查询session">查询session</h2>
<p>这里以<code>springboot</code>默认容器为例<code>tomcat</code>默认的<code>session</code>储存在<code>org.apache.catalina.session.StandardSession</code>中所以可以写出如下oql语句</p>
<pre><code>SELECT * FROM org.apache.catalina.session.StandardSession
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220253259-1135253900.png" alt="" loading="lazy"><br>
我这里因为这个网站好像是被很多人扫描了导致尝试了大量无效<code>session</code>总计有1w+，所以需要想办法排除掉一些无效<code>session</code>这种无效<code>session</code>的尝试大多数是扫描器直接访问一个路由然后返回包就会返回一个<code>session</code>这种的话比较好筛选。我们可以注意点每个<code>session</code>实例里都储存了以下信息<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220253944-1366714632.png" alt="" loading="lazy"><br>
根据上面的分析我们可以加一个判断<code>(s.lastAccessedTime - s.creationTime) &gt; 6000</code>也就是最后访问时间需要大于创建时间6秒钟我们即认为是有效<code>session</code>。但是这还不足以判断<code>session</code>是否被设置了访问权限。一般登陆成功后都会使用<code>setAttribute</code>往<code>session</code>里设置属性加上一些其他判断我们可以写出如下<code>oql</code>语句直接获取有效的<code>sessionid</code></p>
<pre><code>SELECT s.id.toString() FROM org.apache.catalina.session.StandardSession s WHERE ((s.isValid = true) and (s.attributes != null) and ((s.lastAccessedTime - s.creationTime) &gt; 6000))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220254539-525769582.png" alt="" loading="lazy"><br>
有的<code>session</code>属性里甚至会直接存放账号密码<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220255229-33109441.png" alt="" loading="lazy"></p>
<h2 id="查询http数据包">查询http数据包</h2>
<p>上面我们查询到了<code>session</code>但是有很多时候并不是使用默认的<code>session</code>鉴权，所有可以获取http数据作为补充。我们知道<code>springboot</code>默认使用<code>tomcat</code>作为容器，经过代码分析已经查阅资料可知可以通过<code>org.apache.coyote.http11.Http11InputBuffer</code>和<code>org.apache.tomcat.util.net.SocketBufferHandler</code>分别获取我们<code>heapdump</code>期间或之前尚未处理完的<code>http</code>数据包。<br>
获取请求包</p>
<pre><code>SELECT h.byteBuffer.hb.toString() FROM org.apache.coyote.http11.Http11InputBuffer h 
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220255820-2052180807.png" alt="" loading="lazy"><br>
先全选然后右键<code>COPY-&gt;Selection</code>即可复制所有数据<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220256352-1017618331.png" alt="" loading="lazy"><br>
获取响应包，最开始以为会记录在<code>Http11OutputBuffer</code>里面经过分析发现<code>Http11OutputBuffer</code>里只记录返回包<code>header</code>数据，完整数据记录需要使用下面的语句查询</p>
<pre><code>SELECT rp.writeBuffer.hb.toString() FROM org.apache.tomcat.util.net.SocketBufferHandler rp
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220257124-1461728964.png" alt="" loading="lazy"><br>
获取某些<code>http</code>缓存数据段</p>
<pre><code>SELECT DISTINCT bc.buff.toString() FROM org.apache.tomcat.util.buf.ByteChunk bc WHERE (bc.buff != null)
</code></pre>
<p>注意这里的数据不和请求包完全重叠，有可能记录一些更早的请求数据.比如这里直接获取了登陆的<code>user、pass</code>从请求包那里查询是没获取到的<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220257806-1186144528.png" alt="" loading="lazy"></p>
<h2 id="查询springboot路由信息">查询springboot路由信息</h2>
<p>根据之前分析<code>springboot</code>的经验可知路由信息储存在<code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#mappingRegistry</code>中我们使用<code>oql</code>语句查询它的实例</p>
<pre><code>SELECT * FROM org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry
</code></pre>
<p>成功找到路由信息<br>
<img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220258512-1056014708.png" alt="" loading="lazy"><br>
注意到他最后都储存在<code>java.util.LinkedHashMap$Entry</code>所以我们可以直接使用下面语句获取所有路由</p>
<pre><code>SELECT key.toString() FROM java.util.LinkedHashMap$Entry entry WHERE (key.toString() LIKE "/.*")
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220259230-2013629033.png" alt="" loading="lazy"><br>
也可通过<code>MappingRegistration</code>获取路由对应的方法</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220300081-1981895917.png" alt="" loading="lazy"><br>
可以注意到这里已经获取路由对应的方法了且包含参数个数以及参数类型，还差获取参数名研究了一下发现有的情况是可以获取到参数名的。需要之前触发过这个路由，且缓存信息没被删除。</p>
<pre><code>select * from org.springframework.web.method.support.HandlerMethodArgumentResolverComposite
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250806220300835-1625920945.png" alt="" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p>本文介绍了<code>Java heapdump</code>的深度分析方法。除了使用常规的自动化工具获取基础敏感信息外，还可以通过自定义<code>OQL</code>语句进行更深入的信息挖掘。这些方法能够在常规工具无法发现敏感信息时，提供更深层次的数据挖掘能力，帮助渗透测试人员获取更多有价值的信息，如登录凭据、API接口、会话数据等。掌握这些技巧可以大大提升<code>heapdump</code>文件的利用价值。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-06 22:03">2025-08-06 22:03</span>&nbsp;
<a href="https://www.cnblogs.com/cwkiller">cwkiller</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19025951);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19025951', targetLink: 'https://www.cnblogs.com/cwkiller/p/19025951', title: 'heapdump深度利用之信息泄露篇' })">举报</a>
</div>
        