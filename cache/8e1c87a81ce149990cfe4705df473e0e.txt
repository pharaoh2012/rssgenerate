
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhennann/p/18958238" title="发布于 2025-06-30 17:53">
    <span role="heading" aria-level="2">使用这个model操作数据库，一爽到底</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1462384/202506/1462384-20250630175236689-1839984410.png" alt="使用这个model操作数据库，一爽到底" class="desc_img">
        我们再来看看Vonajs提供的Model能力，可以让我们用简洁、优雅的代码全方位操作数据库，比如，动态分表、软删除、多租户、动态数据源、二级缓存，等等
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在<a href="https://juejin.cn/post/7509709812857110582" target="_blank" rel="noopener nofollow">前一篇</a>文章中，我们简要介绍了Vonajs的核心功能。在这里，我们再来看看Vonajs提供的<code>Model</code>能力，可以让我们用简洁、优雅的代码全方位操作数据库，比如，动态分表、软删除、多租户、动态数据源、二级缓存，等等</p>
<h2 id="创建model">创建Model</h2>
<p>比如，我们在模块 demo-student 中创建一个 Model: <code>student</code></p>
<h3 id="1-cli命令">1. Cli命令</h3>
<pre><code class="language-bash">$ vona :create:bean model student --module=demo-student
</code></pre>
<h3 id="2-菜单命令">2. 菜单命令</h3>
<p>使用<code>菜单命令</code>可以显著提升开发体验，减少心智负担</p>
<pre><code class="language-bash">右键菜单 - [模块路径]: `Vona Create/Model`
</code></pre>
<p><img alt="1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202506/1462384-20250630175142577-579745834.png" class="lazyload"></p>
<h2 id="model定义">Model定义</h2>
<pre><code class="language-typescript">import { BeanModelBase, Model } from 'vona-module-a-database';
import { EntityStudent } from '../entity/student.ts';

@Model({ entity: EntityStudent })
export class ModelStudent extends BeanModelBase&lt;EntityStudent&gt; {}
</code></pre>
<ul>
<li>继承自 BeanModelBase 基类</li>
<li>使用 Model 装饰器</li>
<li>设置对应的 entity</li>
</ul>
<h2 id="使用model">使用Model</h2>
<p>在 Vona 中使用 Model，支持<code>依赖注入</code>和<code>依赖查找</code>。推荐使用依赖查找，因为依赖查找可以让代码更加简洁、直观</p>
<h3 id="1-本模块查找">1. 本模块查找</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.scope.model.student.select();
  }
}
</code></pre>
<ul>
<li><code>this.scope</code>：当前模块的scope对象</li>
<li><code>this.scope.model.student</code>：从scope中直接获取student model实例</li>
</ul>
<h3 id="2-跨模块查找">2. 跨模块查找</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.$scope.demoStudent.model.student.select();
  }
}
</code></pre>
<ul>
<li><code>this.$scope.demoStudent</code>：获取指定模块的scope对象</li>
<li><code>this.$scope.demoStudent.model.student</code>：从scope中直接获取student model实例</li>
</ul>
<h2 id="crud">CRUD</h2>
<p>在这里，我们仅介绍基本的 CRUD 操作</p>
<h3 id="1-create">1. Create</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async create(student: DtoStudentCreate): Promise&lt;EntityStudent&gt; {
    return await this.scope.model.student.insert(student);
  }
}
</code></pre>
<h3 id="2-read">2. Read</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.scope.model.student.select();
  }
  
  async findOne(id: TableIdentity): Promise&lt;EntityStudent | undefined&gt; {
    return await this.scope.model.student.get({ id });
  }
}
</code></pre>
<ul>
<li>id: 类型为<code>TableIdentity</code>，支持<code>number</code>和<code>bignumber</code>两种字段类型</li>
</ul>
<h3 id="3-update">3. Update</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async update(id: TableIdentity, student: DtoStudentUpdate) {
    return await this.scope.model.student.update({
      ...student,
      id,
    });
  }
}
</code></pre>
<h3 id="4-delete">4. Delete</h3>
<pre><code class="language-typescript">class ServiceStudent {
  async remove(id: TableIdentity) {
    return await this.scope.model.student.delete({ id });
  }
}
</code></pre>
<h2 id="knex-query-builder">Knex Query Builder</h2>
<p>Vona Model 底层使用的是<a href="https://knexjs.org/" target="_blank" rel="noopener nofollow">knex</a>。因此，也支持 knex 提供的<a href="https://knexjs.org/guide/query-builder.html" target="_blank" rel="noopener nofollow">Query Builder</a></p>
<h3 id="1-builder">1. builder</h3>
<p>调用 model 的 builder 方法获取 knex query builder 的实例</p>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.scope.model.student.builder().where('name', 'tom').orderBy('name');
  }
}
</code></pre>
<h3 id="2-builderselect">2. builderSelect</h3>
<p>builderSelect 方法也是获取 knex query builder 的实例，与 builder 不同的是，builderSelect 支持<code>软删除</code>和<code>多实例/多租户</code></p>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.scope.model.student.builderSelect().where('name', 'tom').orderBy('name');
  }
}
</code></pre>
<h2 id="model-options">Model Options</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>entity</td>
<td>model对应的entity</td>
</tr>
<tr>
<td>table</td>
<td>model对应的表名</td>
</tr>
<tr>
<td>disableDeleted</td>
<td>是否禁用软删除，默认为false</td>
</tr>
<tr>
<td>disableInstance</td>
<td>是否禁用多实例/多租户，默认为false</td>
</tr>
<tr>
<td>clientName</td>
<td>指定数据源名称</td>
</tr>
<tr>
<td>cacheOptions</td>
<td>配置缓存参数，默认启用基于redis的缓存</td>
</tr>
</tbody>
</table>
<ul>
<li><code>table</code>:
<ul>
<li>如果为空，则从 entity 获取表名</li>
<li>可以指定函数，实现动态分表的能力</li>
</ul>
</li>
</ul>
<h2 id="app-config配置">App config配置</h2>
<p>如果通过<code>@Model</code>装饰器设置的Model options不符合业务需要，我们还可以在 App config 中修改 Model options的配置。比如，设置缓存参数</p>
<p><code>src/backend/config/config/config.dev.ts</code></p>
<pre><code class="language-typescript">// onions
config.onions = {
  model: {
    'demo-student:student': {
      disableDeleted: true,   // 禁用软删除
      disableInstance: true,  // 禁用多实例/多租户
      cacheOptions: false,    // 禁用缓存
      clientName: 'mysql',    // 使用数据源：mysql
    },
  },
};
</code></pre>
<ul>
<li><code>demo-student:student</code>：模块名称+model名称</li>
</ul>
<h2 id="动态分表">动态分表</h2>
<p>Model 支持<code>动态分表</code>的能力。比如，我们对 Order 进行分表处理，将每天的订单存入<code>order_YYYYMMDD</code>格式的数据表中</p>
<pre><code class="language-typescript">@Model({ table: (ctx: VonaContext, defaultTable: keyof ITableRecord) =&gt; {
  return `${defaultTable}_${moment().format('YYYYMMDD')}`;
} })
class ModelOrder {}
</code></pre>
<ul>
<li><code>ctx</code>: 可以基于当前请求的上下文来动态生成表名</li>
<li><code>defaultTable</code>: 默认的表名，从entity中获取</li>
</ul>
<h2 id="软删除-多实例多租户">软删除, 多实例/多租户</h2>
<p>Model 默认自动启用软删除，当删除一条数据时，并不进行物理删除，而是设置字段 deleted 的值为 true</p>
<p>Model 默认支持<code>多实例/多租户</code>。对数据进行 CRUD 操作时，自动从 Request 上下文获取<code>实例Id</code>，并传入 sql 语句中</p>
<p>比如，执行<code>model.student.select()</code>，那么生成的 sql 如下：</p>
<pre><code class="language-bash">select "demoStudent"."id" from "demoStudent" 
  where "demoStudent"."iid" = 1 and "demoStudent"."deleted" = false
</code></pre>
<ul>
<li><code>iid</code>：实例 Id</li>
<li><code>deleted</code>：软删除</li>
</ul>
<h3 id="临时禁用软删除">临时禁用软删除</h3>
<p>我们也可以在执行 model 方法时临时指定<code>软删除</code>参数</p>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    return await this.scope.model.student.select({}, { disableDeleted: true });
  }
}
</code></pre>
<h2 id="数据源">数据源</h2>
<p>Vona 支持<code>多数据库</code>、<code>多数据源</code>。可以针对任何一个数据源调用 Model 的方法</p>
<h3 id="1-默认数据源">1. 默认数据源</h3>
<p>在默认情况下，Model 使用的是系统设置的缺省数据源</p>
<p><code>env/.env</code></p>
<pre><code class="language-bash">DATABASE_DEFAULT_CLIENT = 'pg' # pg/mysql
</code></pre>
<ul>
<li>系统当前默认使用的是<code>pg</code>数据源</li>
</ul>
<h3 id="2-静态数据源">2. 静态数据源</h3>
<ul>
<li>在 Model options 中指定数据源</li>
</ul>
<pre><code class="language-typescript">@Model({ clientName: 'mysql' })
class ModelBook {}
</code></pre>
<ul>
<li>
<p><code>clientName</code>：需要指定的数据源名称</p>
</li>
<li>
<p>在 App config 中指定数据源</p>
</li>
</ul>
<p><code>src/backend/config/config/config.dev.ts</code></p>
<pre><code class="language-typescript">// onions
config.onions = {
  model: {
    'demo-student:student': {
      clientName: 'mysql',    // 使用数据源：mysql
    },
  },
};
</code></pre>
<h3 id="3-动态数据源">3. 动态数据源</h3>
<p>我们还可以在代码中动态指定数据源</p>
<pre><code class="language-typescript">class ServiceStudent {
  async findAll(): Promise&lt;EntityStudent[]&gt; {
    const modelMysql = this.scope.model.student.newInstance('mysql');
    return await modelMysql.select();
  }
}
</code></pre>
<ul>
<li><code>newInstance</code>: 传入数据源名称，既可创建新的model实例</li>
</ul>
<h2 id="缓存">缓存</h2>
<p>Vona Model 默认启用了缓存，从而使系统在默认情况下就具备非常高的性能</p>
<p>Model 支持<code>二级缓存</code>/<code>mem缓存</code>/<code>redis缓存</code>。默认使用的是<code>redis缓存</code>。因为<code>redis缓存</code>可以在分布式场景下保持数据的一致性，而<code>mem缓存</code>在分布式场景下同步数据有延时。如果业务数据变更不频繁，可以使用<code>mem缓存</code>或者<code>二级缓存</code>，从而获得更高性能</p>
<p>如何设置缓存配置：</p>
<h3 id="1-禁用缓存">1. 禁用缓存</h3>
<pre><code class="language-typescript">@Model({ cacheOptions: false })
class ModelStudent {}
</code></pre>
<h3 id="2-在-model-options-中配置缓存">2. 在 Model options 中配置缓存</h3>
<pre><code class="language-typescript">@Model({ cacheOptions: {
  mode: 'all', // all/mem/redis
  mem: {
    max: 500,
    ttl: 5 * 1000, // 5s
  },
  redis: {
    ttl: 5 * 1000, // 5s
  },
} })
class ModelStudent {}
</code></pre>
<ul>
<li>mode：缓存模式：支持<code>二级缓存</code>/<code>mem缓存</code>/<code>redis缓存</code></li>
<li>mem：<code>mem缓存</code>配置</li>
<li>redis：<code>redis缓存</code>配置</li>
</ul>
<h3 id="3-在-app-config-中配置缓存">3. 在 App config 中配置缓存</h3>
<p>我们也可以在App config中根据业务需要修改Model的缓存配置</p>
<p><code>src/backend/config/config/config.dev.ts</code></p>
<pre><code class="language-typescript">// onions
config.onions = {
  model: {
    'demo-student:student': {
      cacheOptions: {
        mode: 'all', // all/mem/redis
        mem: {
          max: 500,
          ttl: 5 * 1000, // 5s
        },
        redis: {
          ttl: 5 * 1000, // 5s
        },
      }
    },
  },
};
</code></pre>
<h2 id="结语">结语</h2>
<p>Vonajs已开源：<a href="https://github.com/vonajs/vona" target="_blank" rel="noopener nofollow">https://github.com/vonajs/vona</a></p>
<p>Vonajs作者正在B站直播撰写技术文档，工作日每晚8:30，欢迎围观：<a href="https://space.bilibili.com/454737998" target="_blank" rel="noopener nofollow">濮水代码</a></p>
<p>开发一个功能完备的Nodejs框架固然费时费力，但是撰写技术文档更加费尽心思。写文档的过程同时也是再次梳理思路的过程，即便是围观，也有利于加深对框架设计的理解，探索不一样的架构设计路径。目前已完成<a href="https://vona.js.org" target="_blank" rel="noopener nofollow">部分文档</a>，更多精彩正在逐步展开，欢迎参与</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-30 17:54">2025-06-30 17:53</span>&nbsp;
<a href="https://www.cnblogs.com/zhennann">濮水大叔</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18958238);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18958238', targetLink: 'https://www.cnblogs.com/zhennann/p/18958238', title: '使用这个model操作数据库，一爽到底' })">举报</a>
</div>
        