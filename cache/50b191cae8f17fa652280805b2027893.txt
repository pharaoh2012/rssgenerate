
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Fzeng/p/18735256" title="发布于 2025-02-25 00:44">
    <span role="heading" aria-level="2">SpringBoot 2.x 接入非标准SSE格式大模型流式响应实践 🚀</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>近期DeepSeek等国产大模型热度持续攀升，其关注度甚至超过了OpenAI（被戏称为CloseAI）。在<code>SpringBoot3.x</code>环境中，可以使用官方的Spring AI轻松接入，但对于仍在使用<strong>JDK8</strong>和<strong>SpringBoot2.7.3</strong>的企业级应用来说，往往需要自定义实现。特别是当大模型团队返回的数据格式不符合标准SSE规范时，更需要灵活处理。本文将分享我们的实战解决方案。</p>
<hr>
<h2 id="-引入gradle依赖">📦 引入Gradle依赖</h2>
<p>核心依赖说明：</p>
<ul>
<li><code>spring-boot-starter-web</code>：基础Web支持</li>
<li><code>spring-boot-starter-webflux</code>：响应式编程支持（WebClient所在模块）</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.boot:spring-boot-starter-webflux'
</code></pre>
<hr>
<h2 id="-webclient配置要点">🌐 WebClient配置要点</h2>
<p>初始化时特别注意Header配置：</p>
<pre><code class="language-java">@Bean
public WebClient init() {
    return WebClient.builder()
            .baseUrl(baseUrl)
            .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + openAi)
            // ⚠️ 必须设置为JSON格式
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
}
</code></pre>
<blockquote>
<p>🚨 关键踩坑点：初始设置<code>MediaType.TEXT_EVENT_STREAM_VALUE</code>会导致请求失败，必须使用<code>APPLICATION_JSON_VALUE</code></p>
</blockquote>
<hr>
<h2 id="-核心处理逻辑">🧠 核心处理逻辑</h2>
<h3 id="流式请求入口">流式请求入口</h3>
<pre><code class="language-java">@GetMapping(value = "/stream/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;String&gt; streamChatEnhanced(@RequestParam("prompt") String prompt) {
    // 请求体构建
    String requestBody = String.format("""
        {
            "model": "%s",
            "messages": [{"role": "user", "content": "%s"}],
            "stream": true
        }
        """, model, prompt);
                                       
    return webClient.post()
            // 请求配置
            .uri("/v1/chat/completions")
            .bodyValue(requestBody)
            .accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(DataBuffer.class)  // 🔑 关键配置点
            .transform(this::processStream)
            // 重试和超时配置
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
            .timeout(Duration.ofSeconds(180));
            // 错误处理
            .doOnError(e -&gt; log.error("Stream error", e))
            .doFinally(signal -&gt; log.info("Stream completed: {}", signal));
}
</code></pre>
<h3 id="技术原理说明">技术原理说明</h3>
<p>当使用<code>bodyToFlux(DataBuffer.class)</code>时：</p>
<ul>
<li>✅ 获得原始字节流控制权</li>
<li>❌ 避免自动SSE格式解析（适用于非标准响应）</li>
<li>📡 动态数据流处理：类似Java Stream，但数据持续追加</li>
</ul>
<hr>
<h2 id="-非标准sse数据处理">🔧 非标准SSE数据处理</h2>
<h3 id="核心处理流程">核心处理流程</h3>
<pre><code class="language-java">private Flux&lt;String&gt; processStream(Flux&lt;DataBuffer&gt; dataBufferFlux) {
    return dataBufferFlux
            .transform(DataBufferUtils::join)          // 字节流合并
            .map(buffer -&gt; {                          // 字节转字符串
                String content = buffer.toString(StandardCharsets.UTF_8);
                DataBufferUtils.release(buffer);
                return content;
            })
            .flatMap(content -&gt;                       // 处理粘包问题
                Flux.fromArray(content.split("\\r?\\n\\r?\\n")))
            .filter(event -&gt; !event.trim().isEmpty()) // 过滤空事件
            .map(event -&gt; {                           // 格式标准化处理
                String trimmed = event.trim();
                if (trimmed.startsWith("data:")) {
                    String substring = trimmed.substring(5);
                    return substring.startsWith(" ") ? substring.substring(1) : substring;
                }
                return trimmed;
            })
            .filter(event -&gt; !event.startsWith("data:")); // 二次过滤
}
</code></pre>
<h3 id="三大关键技术点">三大关键技术点</h3>
<ol>
<li>
<p><strong>粘包处理</strong><br>
通过<code>split("\\r?\\n\\r?\\n")</code>解决网络传输中的消息边界问题，示例原始数据：</p>
<pre><code class="language-markdown">data:{response1}\n\ndata:{response2}\n\n
</code></pre>
</li>
<li>
<p><strong>格式兼容处理</strong><br>
自动去除服务端可能返回的<code>data:</code>前缀，同时保留Spring自动添加SSE前缀的能力</p>
</li>
<li>
<p><strong>双重过滤机制</strong><br>
确保最终输出不包含任何残留的SSE格式标识</p>
</li>
</ol>
<hr>
<h2 id="️-特别注意">⚠️ 特别注意</h2>
<p>当接口设置<code>produces = MediaType.TEXT_EVENT_STREAM_VALUE</code>时：</p>
<ul>
<li>
<p>Spring WebFlux会自动添加<code>data: </code>前缀</p>
</li>
<li>
<p>前端收到的格式示例：</p>
<pre><code class="language-markdown">data: {实际内容}
</code></pre>
</li>
<li>
<p>若手动添加</p>
<pre><code>data: 
</code></pre>
<p>前缀会导致重复：</p>
<pre><code class="language-markdown">data: data: {错误内容}  // ❌ 错误格式
</code></pre>
</li>
</ul>
<hr>
<h2 id="️-完整实现代码">🛠️ 完整实现代码</h2>
<pre><code class="language-java">// 包声明和导入...

@Service
@Slf4j
public class OpenAiService {
    // 配置项和初始化
    private String openAiApiKey = "sk-xxxxxx";
    
    private String baseUrl = "https://openai.com/xxxx";

    private String model = "gpt-4o";

    private WebClient webClient;

    @PostConstruct
    public void init() {
        webClient = WebClient.builder()
                .baseUrl(baseUrl)
                .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + openAiApiKey)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @GetMapping(value = "/stream/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; streamChatEnhanced(@RequestParam("prompt") String prompt) {
        // 构建请求体
        String requestBody = String.format("""
                {
                    "model": "gpt-4o-mini",
                    "messages": [{"role": "user", "content": "%s"}],
                    "stream": true
                }
                """, prompt);
                                           
        // 发送流式请求
        return webClient.post()
            .uri("/v1/chat/completions")
            .bodyValue(requestBody)
            .retrieve()
            .onStatus(HttpStatusCode::isError, response -&gt;
                    response.bodyToMono(String.class)
                            .flatMap(error -&gt; Mono.error(new RuntimeException("API Error: " + error)))
            )
            .bodyToFlux(DataBuffer.class)
            .transform(this::processStream)
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
            .timeout(Duration.ofSeconds(180))
            .doOnError(e -&gt; log.error("Stream error", e))
            .doFinally(signal -&gt; log.info("Stream completed: {}", signal));
    }

    private Flux&lt;String&gt; processStream(Flux&lt;DataBuffer&gt; dataBufferFlux) {
        return dataBufferFlux
                // 使用字节流处理
                .transform(DataBufferUtils::join)
                .map(buffer -&gt; {
                    String content = buffer.toString(StandardCharsets.UTF_8);
                    DataBufferUtils.release(buffer);
                    return content;
                })
                // 按 SSE 事件边界，防止粘包的问题
                .flatMap(content -&gt; Flux.fromArray(content.split("\\r?\\n\\r?\\n")))
                // 过滤空事件
                .filter(event -&gt; !event.trim().isEmpty())
                // 规范 SSE 事件格式
                .map(event -&gt; {
                    String trimmed = event.trim();

                    // 由于webflux设置了"produces = MediaType.TEXT_EVENT_STREAM_VALUE",
                    // 所以在返回数据时会自动添加“data:”，因此如果返回的格式带了“data:”需要手动去除
                    if (trimmed.startsWith("data:")) {
                        trimmed = trimmed.replaceFirst("data:","").trim();
                    }
                    return trimmed;
                })
                .filter(event -&gt; !event.startsWith("data:"));
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5677859528032407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-25 00:44">2025-02-25 00:44</span>&nbsp;
<a href="https://www.cnblogs.com/Fzeng">fengzeng</a>&nbsp;
阅读(<span id="post_view_count">84</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18735256" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18735256);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18735256', targetLink: 'https://www.cnblogs.com/Fzeng/p/18735256', title: 'SpringBoot 2.x 接入非标准SSE格式大模型流式响应实践 &amp;#128640;' })">举报</a>
</div>
        