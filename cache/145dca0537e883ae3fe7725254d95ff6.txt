
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ydswin/p/18818027" title="发布于 2025-04-10 10:52">
    <span role="heading" aria-level="2">运维必备：基于 Harbor 的 Helm Charts 批量拉取，从配置到自动化脚本</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言"><strong>引言</strong></h2>
<p>在企业级 Kubernetes 环境中，Harbor 作为主流的镜像与 Helm Chart 管理工具，常被用于存储 Helm Charts。但在迁移、备份或离线部署场景中，批量拉取 Harbor 中的 Charts 可能面临效率低下或权限问题。本文将通过 <strong>Helm CLI + Shell 脚本</strong>的组合方案，实现一键化批量导出操作。</p>
<hr>
<h2 id="一环境准备与-helm-仓库配置"><strong>一、环境准备与 Helm 仓库配置</strong></h2>
<h3 id="11-添加-harbor-仓库">1.1 添加 Harbor 仓库</h3>
<p>通过 Helm 命令行工具关联 Harbor 仓库，需指定项目路径和认证信息：</p>
<pre><code class="language-bash"># 配置变量（按实际环境修改）
HARBOR_URL="https://harbor.example.com"
PROJECT_NAME="your-project"
USERNAME="admin"
PASSWORD="your-password"

# 添加 Helm 仓库
helm repo add harbor-repo ${HARBOR_URL}/chartrepo/${PROJECT_NAME} \
  --username=${USERNAME} \
  --password=${PASSWORD}

# 强制更新仓库索引（避免缓存导致列表不全）
helm repo update --force-update harbor-repo
</code></pre>
<blockquote>
<p><strong>注意</strong>：若 Harbor 版本 ≥2.6.0，需确保已弃用 ChartMuseum 并启用 OCI 兼容模式。</p>
</blockquote>
<h3 id="12-验证仓库可见性">1.2 验证仓库可见性</h3>
<pre><code class="language-bash">helm search repo harbor-repo  # 应显示 Charts 列表
</code></pre>
<p>若列表为空，检查 Harbor 控制台 → 目标项目 → <strong>Helm Charts</strong> 是否已上传 Charts。</p>
<hr>
<h2 id="二自动化批量拉取脚本"><strong>二、自动化批量拉取脚本</strong></h2>
<h3 id="21-脚本核心逻辑">2.1 脚本核心逻辑</h3>
<p>创建 <code>pull-all-charts.sh</code>，实现以下功能：<br>
• <strong>动态获取 Charts 列表</strong><br>
• <strong>按 Chart 名称创建目录</strong><br>
• <strong>下载所有历史版本</strong></p>
<pre><code class="language-bash">#!/bin/bash

# 定义变量
REPO_NAME="harbor"    # Helm 仓库名称
OUTPUT_DIR="./harbor-charts"
mkdir -p "${OUTPUT_DIR}"

# 获取所有 Charts 列表（格式：仓库名/Chart名）
CHARTS=$(helm search repo ${REPO_NAME} -l | awk 'NR&gt;1 {print $1}')

# 遍历每个 Chart
for CHART in ${CHARTS}; do
  # 提取 Chart 名称（去掉仓库名前缀）
  SHORT_NAME=$(echo "${CHART}" | sed "s|${REPO_NAME}/||")
  
  # 获取该 Chart 的所有版本
  VERSIONS=$(helm search repo "${CHART}" --versions -o json | jq -r '.[].version')
  
  # 下载每个版本
  for VERSION in ${VERSIONS}; do
    echo "正在拉取: ${SHORT_NAME} (版本 ${VERSION})"
    helm pull "${CHART}" --version "${VERSION}" --destination "${OUTPUT_DIR}"
  done
done

echo "所有 Charts 已下载到: ${OUTPUT_DIR}"
</code></pre>
<h3 id="22-运行脚本">2.2 运行脚本</h3>
<pre><code class="language-bash">chmod +x pull-all-charts.sh &amp;&amp; ./pull-all-charts.sh
</code></pre>
<p>输出目录结构示例：</p>
<pre><code>harbor-charts/
├── nginx/
│   ├── nginx-1.2.3.tgz
│   └── nginx-4.5.6.tgz
└── redis/
    ├── redis-7.0.0.tgz
    └── redis-8.1.0.tgz
</code></pre>
<hr>
<h2 id="三常见问题与解决方案"><strong>三、常见问题与解决方案</strong></h2>
<h3 id="31-权限错误403-forbidden">3.1 权限错误（403 Forbidden）</h3>
<p>• <strong>原因</strong>：用户权限不足或认证信息过期<br>
• <strong>修复</strong>：</p>
<pre><code class="language-bash"># 重新配置仓库凭据
helm repo update harbor-repo --username=${USERNAME} --password=${PASSWORD}
</code></pre>
<p>需确保 Harbor 用户至少具备 <strong>Guest</strong> 角色。</p>
<h3 id="32-charts-列表不全">3.2 Charts 列表不全</h3>
<p>• <strong>原因</strong>：Helm 缓存或分页限制<br>
• <strong>方案</strong>：改用 Harbor API 直接获取（示例片段）：</p>
<pre><code class="language-bash"># 分页查询仓库列表
PAGE=1
while true; do
  REPO_PAGE=$(curl -s -k -u "${USERNAME}:${PASSWORD}" \
    "${HARBOR_URL}/api/v2.0/projects/${PROJECT_ID}/repositories?page=${PAGE}&amp;page_size=50")
  # 解析并追加到列表...
done
</code></pre>
<p>完整脚本可参考网页3的 API 调用逻辑。</p>
<h3 id="33-下载中断或超时">3.3 下载中断或超时</h3>
<p>• <strong>优化</strong>：增加重试机制</p>
<pre><code class="language-bash">for VERSION in ${VERSIONS}; do
  until helm pull "${CHART}" --version ${VERSION}; do
    echo "Retrying ${VERSION}..."
    sleep 10
  done
done
</code></pre>
<hr>
<h2 id="四扩展应用场景"><strong>四、扩展应用场景</strong></h2>
<h3 id="41-仅拉取最新版本">4.1 仅拉取最新版本</h3>
<p>修改版本获取逻辑：</p>
<pre><code class="language-bash">VERSIONS=$(helm search repo "${CHART}" --versions -o json | jq -r '.[0].version')
</code></pre>
<h3 id="42-与-cicd-流水线集成">4.2 与 CI/CD 流水线集成</h3>
<p>在 GitLab CI 中配置阶段任务：</p>
<pre><code class="language-yaml">pull-charts:
  stage: deploy
  script:
    - apk add helm jq
    - ./pull-all-charts.sh
  artifacts:
    paths:
      - harbor-charts/
</code></pre>
<h3 id="43-离线环境分发">4.3 离线环境分发</h3>
<p>打包成压缩文件后传输：</p>
<pre><code class="language-bash">tar czvf harbor-charts-$(date +%Y%m%d).tgz harbor-charts/
</code></pre>
<hr>
<h2 id="五总结"><strong>五、总结</strong></h2>
<p>通过本文方案，您可以：</p>
<ol>
<li><strong>快速备份</strong>：全量保存 Harbor 中的 Helm Charts</li>
<li><strong>简化迁移</strong>：跨集群或跨 Harbor 实例同步 Charts</li>
<li><strong>支持离线部署</strong>：与 Air-Gapped 环境无缝衔接</li>
</ol>
<p>建议将脚本与定时任务结合（如 CronJob），实现定期自动化备份。对于大规模环境，可参考网页7的 API 分页方案优化性能。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/ydswin/" target="_blank">dashery</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/ydswin/p/18818027" target="_blank">https://www.cnblogs.com/ydswin/p/18818027</a></p>
</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.1387366597662037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-10 14:58">2025-04-10 10:52</span>&nbsp;
<a href="https://www.cnblogs.com/ydswin">dashery</a>&nbsp;
阅读(<span id="post_view_count">68</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18818027" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18818027);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18818027', targetLink: 'https://www.cnblogs.com/ydswin/p/18818027', title: '运维必备：基于 Harbor 的 Helm Charts 批量拉取，从配置到自动化脚本' })">举报</a>

		</p>
	