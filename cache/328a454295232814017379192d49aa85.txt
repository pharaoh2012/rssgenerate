
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hk416hasu/p/18689248" title="发布于 2025-01-24 10:59">
    <span role="heading" aria-level="2">为什么UNIX使用init进程启动其他进程？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在UNIX系统中，当系统启动时，内核完成初始化后会启动第一个用户空间进程，通常是`init`进程。`init`进程负责启动和管理其他用户空间进程，而内核本身并不直接处理这些任务。为什么UNIX采用这样的设计，而不是让内核直接负责启动所有进程？本文将从多个角度分析这种设计的背后逻辑与优点。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="为什么unix使用init进程启动其他进程">为什么UNIX使用init进程启动其他进程？</h1>
<p>在UNIX系统中，当系统启动时，内核完成初始化后会启动第一个用户空间进程，通常是<code>init</code>进程。<code>init</code>进程负责启动和管理其他用户空间进程，而内核本身并不直接处理这些任务。为什么UNIX采用这样的设计，而不是让内核直接负责启动所有进程？本文将从多个角度分析这种设计的背后逻辑与优点。</p>
<hr>
<h3 id="0-unix是否真的使用init进程">0. UNIX是否真的使用init进程？</h3>
<p>RTFS，通过观察Linux内核源代码（<a href="https://elixir.bootlin.com/linux/v6.12.6/source/init/main.c#L1525" target="_blank" rel="noopener nofollow">这里</a>），可以发现这段代码：</p>
<pre><code class="language-c">if (!try_to_run_init_process("/sbin/init") ||
    !try_to_run_init_process("/etc/init") ||
    !try_to_run_init_process("/bin/init") ||
    !try_to_run_init_process("/bin/sh"))
        return 0;

panic("No working init found.  Try passing init= option to kernel. "
      "See Linux Documentation/admin-guide/init.rst for guidance.");
</code></pre>
<p>这说明Linux真的会尝试启动一个init进程，甚至如果启动失败就“罢工”了。</p>
<p>同时观察<code>pstree</code>的输出：</p>
<pre><code class="language-bash">VM: ~ &gt; pstree
systemd─┬─ModemManager───2*[{ModemManager}]
        ├─acpid
        ├─2*[agetty]
        ├─dbus-daemon
        ├─mysqld───48*[{mysqld}]
        ├─nginx───2*[nginx]
        ├─sshd───sshd───sshd───bash───pstree
        ├─systemd-journal
        ├─systemd-logind
        ...
</code></pre>
<p>的确可以发现所有的进程都是由systemd“生长分化”（fork）出来的。</p>
<hr>
<h3 id="1-为什么内核不直接启动所有进程">1. 为什么内核不直接启动所有进程？</h3>
<p>尽管内核拥有启动进程的能力，但让内核直接启动所有进程并不符合UNIX的设计哲学。</p>
<ol>
<li>
<p>职责分离<br>
进程的生命周期管理（如创建、调度）由<strong>内核</strong>负责，而决定哪些进程需要启动及其配置由用户空间的<strong>init进程</strong>管理。这样可以让内核保持简洁，减少复杂性。</p>
</li>
<li>
<p>灵活性<br>
通过<code>init</code>或其他替代方案，用户可以动态调整系统初始化逻辑，例如定义不同运行级别或自定义服务启动顺序（<code>systemctl</code>）。而将这些逻辑交给内核则会限制这种灵活性。</p>
</li>
<li>
<p>避免内核代码膨胀<br>
如果内核直接负责启动所有用户进程，它将不得不处理大量复杂的逻辑，例如服务依赖、配置文件解析等。这会导致内核代码变得庞大且难以维护。</p>
</li>
</ol>
<hr>
<h3 id="2-职责分离与模块化设计">2. 职责分离与模块化设计</h3>
<p>UNIX操作系统遵循职责分离的设计哲学，将不同的功能模块化处理：</p>
<ul>
<li><strong><code>init</code>负责：</strong> 高层逻辑，比如系统初始化和服务管理, 决定哪些服务或进程需要启动以及启动的顺序。</li>
<li><strong>内核负责：</strong> 提供底层机制（如<code>fork</code>、<code>exec</code>）来实现进程创建和调度。</li>
</ul>
<p>通过将进程管理的高层逻辑交由用户空间中的<code>init</code>进程负责，内核可以保持专注于底层资源管理，简化了自身的设计和实现。</p>
<hr>
<h3 id="3-灵活性和可配置性">3. 灵活性和可配置性</h3>
<p><code>init</code>进程是用户空间的程序，可以被系统管理员配置或替换为其他初始化系统（如<code>systemd</code>或<code>upstart</code>）。这种灵活性使得不同的UNIX系统可以根据需求自定义其初始化逻辑，而无需更改内核。</p>
<pre><code class="language-bash">&gt; ls /sbin/init -l
lrwxrwxrwx 1 root root 20 Dec 17 04:23 /sbin/init -&gt; /lib/systemd/systemd
</code></pre>
<ul>
<li><strong>内核的任务：</strong> 启动第一个用户空间进程（PID为1的<code>init</code>）。</li>
<li><strong><code>init</code>的任务：</strong> 配置系统、启动服务、管理运行级别。</li>
</ul>
<p>这种设计避免了将系统初始化的逻辑写入内核，使得系统更易于维护和扩展。</p>
<hr>
<h3 id="4-总结">4. 总结</h3>
<p>UNIX选择通过<code>init</code>进程启动和管理其他进程，而不是由内核直接完成，这是为了实现职责分离、增强灵活性、简化内核设计并提高系统的可维护性。</p>
<p>这种设计不仅遵循了UNIX的模块化哲学，还为系统的扩展性和灵活性提供了基础，体现了UNIX设计的简洁与优雅。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.0514754839386575" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 11:03">2025-01-24 10:59</span>&nbsp;
<a href="https://www.cnblogs.com/hk416hasu">hk416hasu</a>&nbsp;
阅读(<span id="post_view_count">284</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18689248" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18689248);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18689248', targetLink: 'https://www.cnblogs.com/hk416hasu/p/18689248', title: '为什么UNIX使用init进程启动其他进程？' })">举报</a>
</div>
        