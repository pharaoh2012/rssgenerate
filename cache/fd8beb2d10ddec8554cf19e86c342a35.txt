
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jiejielin-blogs/p/19002064" title="发布于 2025-07-24 09:15">
    <span role="heading" aria-level="2">ARM-M与RISC-V(32bit)的区别--基于CM4与Nuclei_N300</span>
    

</a>

        </h2>
        <div class="postbody">
            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-systick与core-timer">1 systick与core timer</h1>
<p>ARM Cortex-M内核包含了一个SysTick定时器，SysTick 是一个24 位的倒计数定时器，当计到0 时，将从RELOAD 寄存器中自动重装载定时初值。</p>
<p>而RISC-V内核中自带一个core timer, core timer是一个64位的定时器, 可以用于产生定时器中断或软件中断</p>
<p>SysTick或core timer等内核定时器, 常用于作为RTOS的心跳时钟</p>
<hr>
<h1 id="2-中断与异常">2 中断与异常</h1>
<p>在ARMv7中中断是异常的一种特例</p>
<p>而在RISC-V内核中, 中断与异常是严格区分的, 异常与中断均属于Trap(陷阱), 其中中断是异步的,可以被屏蔽 , 异常是同步的, 不可被屏蔽, 并且异常处理时, 硬件会自动关闭全局中断</p>
<hr>
<h1 id="3-nvic与eclic">3 NVIC与ECLIC</h1>
<p>NVIC与ELCIC均是ARM-M与RISC-V内核实现的中断控制器, 但是在以下方面有不同之处</p>
<h2 id="31-向量中断与非向量中断">3.1 向量中断与非向量中断</h2>
<p>NVIC中, 所有的中断都是向量中断, ISR地址由中断向量表保存</p>
<p>ECLIC中, 中断分为向量中断和非向量中断, 两者在下方的中断优化策略的支持中有所不同, 同时ECLIC也有一张中断向量表, 非向量中断共用一个ISR, 再从ISR中判断中断源</p>
<h2 id="32-中断优化">3.2 中断优化</h2>
<h3 id="321-中断硬件保护现场">3.2.1 中断硬件保护现场</h3>
<p>ARM-M中, 中断触发后, 硬件会自动将寄存器信息保存到栈中</p>
<p>而在RISC-V中, 中断触发后, 硬件不会自动保存, 需要软件编写中断上下文的保存与恢复</p>
<h3 id="322-中断咬尾">3.2.2 中断咬尾</h3>
<p>ARM-M中, 中断咬尾是一个重要的中断优化</p>
<p>RISC-V中, 非向量中断是支持中断咬尾的, 而向量中断不支持中断咬尾</p>
<h3 id="323-中断晚到">3.2.3 中断晚到</h3>
<p>ARM-M中支持中断晚到优化</p>
<p>RISC-V中不支持中断晚到优化</p>
<h3 id="334-中断嵌套">3.3.4 中断嵌套</h3>
<p>ARM-M中支持中断嵌套</p>
<p>RISC-V中非向量中断支持中断嵌套, 向量中断需要软件实现中断上下文的保存与恢复, 并且处理器内核在响应中断后，mstatus寄存器中的MIE域将会被硬件自动更新成为0（意味着中断被全局关闭，从而无法响应新的中断）。因此向量处理模式默认是不支持中断嵌套的，为了达到向量处理模式且又能够中断嵌套的效果, 需要软件实现一些特殊的入栈操作: 0</p>
<ul>
<li>
<p>首先保存CSR寄存器mepc、mcause、msubm入堆栈。保存这几个CSR寄存器是为了保证后续的中断嵌套能够功能正确，因为新的中断响应会重新覆盖mepc、mcause、msubm的值，因此需要将它们先保存入堆栈。</p>
</li>
<li>
<p>重新打开中断的全局使能，即，设置mstatus寄存器的MIE域为1。打开中断全局使能后，新的中断便可以被响应，从而达到中断嵌套的效果。</p>
</li>
<li>
<p>在中断服务程序的结尾处同样需要添加对应的恢复上下文出栈操作。并且在CSR寄存器mepc、mcause、msubm出堆栈之前，需要将中断全局使能再次关闭，以保证mepc、mcause、msubm恢复操作的原子性（不被新的中断所打断）。</p>
</li>
</ul>
<h3 id="335-中断仲裁">3.3.5 中断仲裁</h3>
<p>NVIC中, 中断仲裁机制由中断优先级号来划分, 中断优先级数字越小, 优先级越高, 同时可以进行优先级分组</p>
<p>ECLIC中, 中断仲裁机制是由四个因素决定：中断level、中断priority、中断 ID号、中断阈值，这四个因素的判定顺序是中断level&gt;中断priority&gt;中断ID号&gt; 中断阈值，其中前三个因素都是数字越大表明仲裁优先级高，最后一个因素只有当 中断level的数值大于中断阈值时，中断才会生效。</p>
<hr>
<h1 id="4-pendsv异常与软件中断">4 PendSV异常与软件中断</h1>
<p>ARM-M中, 支持PendSV异常挂起, PendSV是一个最低优先级的异常(中断), 优点是可以在保证高优先级的中断优先执行, 在无中断时及时响应, 常常被RTOS用来实现上下文的保存与切换</p>
<p>RISC-V中, 没有PendSV异常, 但是core timer支持软件中断, 可以将该中断设置为最低优先级, 来实现中断挂起的功能, 来实现与PendSV相同的功能</p>
<hr>
<h1 id="5-特权模式">5 特权模式</h1>
<p>ARM-M中, 特权模式分为用户模式与特权模式</p>
<p>RISC-V中, 特权模式划分如下</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3610910/202507/3610910-20250724091423481-364595552.png" class="lazyload"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>特权级</td>
<td>名称</td>
<td>访问权限</td>
<td>典型应用</td>
</tr>
<tr>
<td>M-mode</td>
<td>机器模式</td>
<td>访问所有CSR、物理内存、中断控制器</td>
<td>Bootloader/安全监控</td>
</tr>
<tr>
<td>S-mode</td>
<td>监管模式</td>
<td>受限CSR、虚拟内存管理（通过satp）</td>
<td>操作系统内核</td>
</tr>
<tr>
<td>U-mode</td>
<td>用户模式</td>
<td>最小权限，受限内存访问</td>
<td>应用程序</td>
</tr>
</tbody>
</table>
<p>Nuclei_N系列仅支持两种特权模式: 机器模式和用户模式 其中机器模式又分出有4个子模式</p>

</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.001388888888888889" data-date-updated="2025-07-24 09:17">2025-07-24 09:15</span>&nbsp;
<a href="https://www.cnblogs.com/jiejielin-blogs">林接接</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19002064);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19002064', targetLink: 'https://www.cnblogs.com/jiejielin-blogs/p/19002064', title: 'ARM-M与RISC-V(32bit)的区别--基于CM4与Nuclei_N300' })">举报</a>

        </p>
    