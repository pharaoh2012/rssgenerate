
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18990993" title="发布于 2025-07-20 18:51">
    <span role="heading" aria-level="2">MySQL 18 为什么这些SQL语句逻辑相同，性能却差异巨大？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在MySQL中，有很多看上去逻辑相同，但性能差异巨大的SQL语句。对这些语句使用不当的话，就会不经意导致整个数据库压力变大。本文选择了三个这样的案例。</p>
<h3 id="案例一条件字段函数操作">案例一：条件字段函数操作</h3>
<p>假设现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。建表语句如下：</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE `tradelog` (
  `id` int(11) NOT NULL,
  `tradeid` varchar(32) DEFAULT NULL,
  `operator` int(11) DEFAULT NULL,
  `t_modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `tradeid` (`tradeid`),
  KEY `t_modified` (`t_modified`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
</code></pre>
<p>目前的需求是，统计发生在所有年份中7月份的交易记录总数。可能会这样写SQL语句：</p>
<pre><code class="language-sql">select count(*) from tradelog where month(t_modified)=7;
</code></pre>
<p>但这可能需要执行很久，因为如果对字段做了函数计算，就用不上索引了。为什么呢？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100200405-2138020560.png" width="40%"></div>
<p>上面是t_modified索引示意图。如果SQL语句的条件是<code>where t_modified='2018-7-1'</code>，引擎会按照绿色箭头的路线快速定位到结果。但如果要计算month()函数，传入7这个数字，并不知道如何在树中查找。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p>
<p>但优化器并不是要放弃使用这个索引。在该案例中，优化器可以选择遍历主键索引，也可以选择遍历t_modified索引，对比索引大小后会选择遍历t_modified索引。</p>
<p>用explain命令查看执行结果：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100230059-688802373.png" width="90%"></div>
<ul>
<li>
<p><code>key=t_modified</code>，表示用上了索引；</p>
</li>
<li>
<p><code>rows=100335</code>，已知测试数据共10万行，表示这条语句扫描了整个索引的所有值。</p>
</li>
</ul>
<p>为了让优化器能按照预期用上t_modified索引的快速定位能力，需要把SQL语句改为基于字段本身的范围查询：</p>
<pre><code class="language-sql">mysql&gt; select count(*) from tradelog where
    -&gt; (t_modified &gt;= '2016-7-1' and t_modified&lt;'2016-8-1') or
    -&gt; (t_modified &gt;= '2017-7-1' and t_modified&lt;'2017-8-1') or 
    -&gt; (t_modified &gt;= '2018-7-1' and t_modified&lt;'2018-8-1');
</code></pre>
<p>还有其他的情况，索引可能也会失效，比如：</p>
<ul>
<li>
<p><code>select * from tradelog where id+1=10000</code>，失效；</p>
</li>
<li>
<p><code>select * from tradelog where id=10000-1</code>，可以。</p>
</li>
</ul>
<h3 id="案例二隐式类型转换">案例二：隐式类型转换</h3>
<p>有一条SQL语句：</p>
<pre><code class="language-sql">select * from tradelog where tradeid=110717;
</code></pre>
<p>explain结果显示这条语句需要走全表扫描，这是因为tradeid字段类型是varchar(32)，而输入的参数是整型，所以需要做类型转换。</p>
<p>那么，数据类型转换规则是什么？为什么有数据类型转换，就需要走全索引扫描？</p>
<p>来看一个简单的比较<code>select "10"&gt;9</code>：</p>
<ul>
<li>
<p>如果规则是将字符串转成数字，那么结果应该是1；</p>
</li>
<li>
<p>如果规则是将数字转成字符串，那么结果应该是0。</p>
</li>
</ul>
<p>验证结果：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100313289-556874183.png" width="30%"></div>
<p>所以在MySQL中，字符串和数字做比较的话，规则是将字符串转成数字。</p>
<p>这时再看案例给出的语句，能发现对于优化器来说，语句等同于：</p>
<pre><code class="language-sql">select * from tradelog where CAST(tradid AS signed int) = 110717;
</code></pre>
<p>而根据案例一，这条语句会索引失效。</p>
<h3 id="案例三隐式字符编码转换">案例三：隐式字符编码转换</h3>
<p>假设系统里还有另外一个表trade_detail用于记录交易的操作细节。为了便于分析，在表中插入一些数据：</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE `trade_detail` (
  `id` int(11) NOT NULL,
  `tradeid` varchar(32) DEFAULT NULL,
  `trade_step` int(11) DEFAULT NULL, /*操作步骤*/
  `step_info` varchar(32) DEFAULT NULL, /*步骤信息*/
  PRIMARY KEY (`id`),
  KEY `tradeid` (`tradeid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into tradelog values(1, 'aaaaaaaa', 1000, now());
insert into tradelog values(2, 'aaaaaaab', 1000, now());
insert into tradelog values(3, 'aaaaaaac', 1000, now());

insert into trade_detail values(1, 'aaaaaaaa', 1, 'add');
insert into trade_detail values(2, 'aaaaaaaa', 2, 'update');
insert into trade_detail values(3, 'aaaaaaaa', 3, 'commit');
insert into trade_detail values(4, 'aaaaaaab', 1, 'add');
insert into trade_detail values(5, 'aaaaaaab', 2, 'update');
insert into trade_detail values(6, 'aaaaaaab', 3, 'update again');
insert into trade_detail values(7, 'aaaaaaab', 4, 'commit');
insert into trade_detail values(8, 'aaaaaaac', 1, 'add');
insert into trade_detail values(9, 'aaaaaaac', 2, 'update');
insert into trade_detail values(10, 'aaaaaaac', 3, 'update again');
insert into trade_detail values(11, 'aaaaaaac', 4, 'commit');
</code></pre>
<p>这时，有一条SQL语句：</p>
<pre><code class="language-sql">select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; 
</code></pre>
<p>其explain结果：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100354093-87620615.png" width="90%"></div>
<p>第一行说明优化器会在tradelog找到<code>id=2</code>的行，这个步骤用上了主键索引；第二行<code>key=null</code>，说明没有用上tradeid索引，进行了全表扫描。</p>
<p>在该执行计划中，是从tradelog表取tradeid字段，再去trade_detail表里查询匹配字段，因此把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。</p>
<p>该语句的执行流程：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100416838-1976047191.png" width="40%"></div>
<ul>
<li>
<p>首先根据id在tradelog表找到L2这一行；</p>
</li>
<li>
<p>从L2取出tradeid字段的值；</p>
</li>
<li>
<p>根据tradeid到trade_detail表查找条件匹配的行，这个过程是通过遍历主键索引的方式。</p>
</li>
</ul>
<p>我们本来是希望在trade_detail表里用索引，但最终并没有。</p>
<p>究其原因，通常是因为两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询时用不上关联字段的索引。那么为什么字符集不同就用不上索引呢？</p>
<p>如果把流程的最后一步单独改成SQL语句，那就是：</p>
<pre><code class="language-sql">select * from trade_detail where tradeid=$L2.tradeid.value;
</code></pre>
<p>其中，$L2.tradeid.value的字符集是utf8mb4。由于utf8mb4是utf8的超集，因此这两个类型的字符串作比较时，MySQL内部会先把utf8字符串转换成utf8mb4，再做比较，等同于：</p>
<pre><code class="language-sql">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; 
</code></pre>
<p>CONVERT在这里表示字符集转换。而这条语句就相当于案例一的堆索引字段做函数操作，优化器会放弃走树搜索。</p>
<p>此时可以看出，字符集不同只是条件，<strong>连接过程要求在被驱动表的索引字段上加函数操作</strong>，是直接导致对被驱动表做全表扫描的原因。</p>
<br>
<p>作为对比验证，换一下驱动表和被驱动表：</p>
<pre><code class="language-sql">select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;
</code></pre>
<p>其explain结果：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250718100455095-289043476.png" width="90%"></div>
<p>从结果可以看出，当trade_detail变成驱动表，此时用上了被驱动表tradelog里的索引。</p>
<p>假设驱动表trade_detail里<code>id=4</code>的行记为R4，如果我们类似分析该语句的最后一步，其类似：</p>
<pre><code class="language-sql">select operator from tradelog  where traideid =$R4.tradeid.value; 
</code></pre>
<p>又由于有字符串转换，进一步的，该语句可以写为：</p>
<pre><code class="language-sql">select operator from tradelog  where traideid =CONVERT($R4.tradeid.value USING utf8mb4); 
</code></pre>
<p>此时可以发现，函数是加在输入参数上的，这样是可以用上被驱动表的tradeid索引的。</p>
<br>
<p>理解了原理，如果想要优化语句：</p>
<pre><code class="language-sql">select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;
</code></pre>
<p>有两种做法：</p>
<ul>
<li>
<p>把trade_detail表上的tradeid字段的字符集也改成utf8mb4；</p>
</li>
<li>
<p>如果不支持修改字符集，可以修改SQL语句为</p>
<pre><code class="language-sql">select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; 
</code></pre>
</li>
</ul>
<p>最后总结：三个案例其实都想说明同一件事，就是对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器会放弃走树搜索。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-20 18:52">2025-07-20 18:51</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18990993);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18990993', targetLink: 'https://www.cnblogs.com/san-mu/p/18990993', title: 'MySQL 18 为什么这些SQL语句逻辑相同，性能却差异巨大？' })">举报</a>
</div>
        