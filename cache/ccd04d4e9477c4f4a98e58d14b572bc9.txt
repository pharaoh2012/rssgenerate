
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuhuacong/p/18766333" title="发布于 2025-03-11 22:22">
    <span role="heading" aria-level="2">使用PySide6/PyQt6实现Python跨平台表格数据分页打印预览处理</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        我曾经在前面使用WxPython开发跨平台应用程序的时候，写了一篇《WxPython跨平台开发框架之列表数据的通用打印处理》，介绍在WxPython下实现表格数据分页打印处理的过程，在Windows下和MacOS测试效果表现一致。然后在WxPython跨平台的基础上，我利用类似WxPhon的程序框架，使用PySide6/PyQt6实现了另一套跨平台的程序开发，功能上更是比WxPython的实现更加细致和完善了，本篇随笔介绍使用PySide6/PyQt6实现Python跨平台表格数据分页打印预览处理。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>我曾经在前面使用WxPython开发跨平台应用程序的时候，写了一篇《<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2024-12-28 16:50" href="https://www.cnblogs.com/wuhuacong/p/18637653">WxPython跨平台开发框架之列表数据的通用打印处理</a>》，介绍在WxPython下实现表格数据分页打印处理的过程，在Windows下和MacOS测试效果表现一致。然后在WxPython跨平台的基础上，我利用类似WxPhon的程序框架，使用PySide6/PyQt6实现了另一套跨平台的程序开发，功能上更是比WxPython的实现更加细致和完善了，本篇随笔介绍使用PySide6/PyQt6实现Python跨平台表格数据分页打印预览处理。<em id="__mceDel"><br></em></p>
<h3>1、回顾WxPython的列表数据的通用打印处理</h3>
<p>WxPython实现数据的表格预览和打印处理，主要是利用<code>wx.PrintPreview</code>、<code>wx.Printer</code>&nbsp;和&nbsp;<code>wx.Printout</code>&nbsp;等 wxPython 提供的用于打印功能的核心类来处理。</p>
<p>一般列表界面，如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241228154910626-1764508971.png" alt="" class="medium-zoom-image"></p>
<p>我们打印模块的处理，需要把这些列表的记录显示在打印预览界面上，并决定是否继续打印即可。</p>
<p>打印预览入口，在列表界面上右键，弹出打印菜单，如下界面所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241228155336036-1365203876.png" alt="" class="medium-zoom-image"></p>
<p>打印预览界面如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241228155712289-2015393758.png" alt="" class="medium-zoom-image"></p>
<div>&nbsp;其打印的逻辑，主要就是调用MyPrintOut的自定义对象，然后调用PrintPreview进行打印预览窗体的显示即可。具体的逻辑还是在自定义的&nbsp;MyPrintout 类里面。</div>
<div>&nbsp;</div>
<h3>2、使用PySide6/PyQt6实现Python跨平台表格数据分页打印处理</h3>
<p>而使用PySide6/PyQt6实现Python跨平台表格数据分页打印预览处理，逻辑上有所不同，这里没有PrintOut对象来处理了。需要根据表格的TableModel对象来进行数据的分页打印。</p>
<p>在开始介绍实现逻辑前，我们先来看看PySide6/PyQt6实现打印预览的效果。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250311214216681-1480493684.png" alt=""></p>
<p>同样我们是在表格展示上给出通用的打印菜单入口，如上图所示，作为答应预览的统一入口。</p>
<p>而由于数据打印的时候，表格列字段可能有些多有些少，因此最好能够根据表格列选择那些可以打印，那些忽略。而选择后，可以进一步选择横向或者竖向等信息，因此在弹出打印预览前，我们让用户确认一下答应的信息，我订做了一个打印预览前的设置对话框，如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250311214659967-894406843.png" alt=""></p>
<p>这样我们可以定制打印的相关信息，也方便我们对打印的格式精细化控制。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250311215018333-336437110.png" alt=""></p>
<p>对于模型数据很多，这需要考虑到分页的处理，我们需要再实现打印预览的时候，实现分页显示的逻辑，分页打印预览的界面如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250311215304510-73601152.png" alt=""></p>
<p>了解了PySide/PyQt的打印预览界面后，我们来分析下实现打印的逻辑处理。</p>
<p>打印预览和打印的时候，我们需要考虑显示器和实际打印设备之间的显示尺寸是不同的，有时候显示器设置显示为200%或其他偏大的数据，如果不注意尺寸的调整，很可能打印预览得到的是一个很小区域的显示内容。</p>
<p>在 PySide6 /PyQt6 中，如果你想实现 <code data-start="19" data-end="31">QTableView</code> 打印功能并确保兼容不同操作系统（如 macOS 和 Windows）的尺寸变化，你可以使用 <code data-start="78" data-end="88">QPrinter</code> 和 <code data-start="91" data-end="105">QPrintDialog</code> 来处理打印。要确保尺寸适应变化，你可以根据打印内容自动调整页面布局。</p>
<p>我编写了一个函数，用于计算缩放比例，如下函数所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> calculateScale(self, printer: QPrinter, painter: QPainter) -&gt;<span style="color: rgba(0, 0, 0, 1)"> float:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">计算每毫米的逻辑单位</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取打印机的 DPI</span>
        ppiPrinterX =<span style="color: rgba(0, 0, 0, 1)"> printer.resolution()
        ppiPrinterY </span>= ppiPrinterX  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 假设 X 和 Y 方向的 DPI 相同</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取屏幕的 DPI</span>
        screen =<span style="color: rgba(0, 0, 0, 1)"> QApplication.primaryScreen()
        ppiScreenX </span>=<span style="color: rgba(0, 0, 0, 1)"> screen.logicalDotsPerInchX()
        ppiScreenY </span>=<span style="color: rgba(0, 0, 0, 1)"> screen.logicalDotsPerInchY()

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 计算缩放比例，</span>
        self.logScale = logScale = float(ppiPrinterX) /<span style="color: rgba(0, 0, 0, 1)"> float(ppiScreenX)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 可根据 DPI 比例调整字体大小</span>
        <span style="color: rgba(0, 0, 255, 1)">print</span>(f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">缩放比例: {logScale}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取页面大小和绘制区域大小</span>
        pageRect = printer.pageRect(QPrinter.Unit.DevicePixel)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 页面大小（像素）</span>
        paintRect = painter.viewport()  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 绘制区域大小（像素）</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 计算缩放比例</span>
        scale = logScale * float(paintRect.width()) /<span style="color: rgba(0, 0, 0, 1)"> float(pageRect.width())

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 设置 QPainter 的缩放比例</span>
<span style="color: rgba(0, 0, 0, 1)">        painter.scale(scale, scale)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 计算每毫米的逻辑单位</span>
        logUnitsMM = float(ppiPrinterX) / (logScale * 25.4<span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">每毫米的逻辑单位: {logUnitsMM}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> logUnitsMM</pre>
</div>
<p>打印预览的处理，主要就是根据设置对话框，获得横向还是纵向，以及页面大小、标题等信息，然后实现QPreviewDialog里面的paintRequest事件即可，如下预览逻辑处理代码。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> print_preview(self, setting: PrintSetting) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">打印预览</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> print(setting.__dict__)</span>
        printer = QPrinter()  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> QPrinter.PrinterMode.HighResolution</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 打印的处理</span>
<span style="color: rgba(0, 0, 0, 1)">        printer.setPageSize(setting.page_size)
        printer.setPageOrientation(setting.page_orientation)
        self.print_cols </span>= setting.print_cols  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 打印指定列的索引列表</span>
        self.print_title = setting.print_title  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 打印标题</span>
        self.settings = setting  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存打印设置</span>
<span style="color: rgba(0, 0, 0, 1)">
        preview_dialog </span>=<span style="color: rgba(0, 0, 0, 1)"> QPrintPreviewDialog(printer)
        <span style="color: rgba(255, 0, 0, 1)"><strong>preview_dialog.paintRequested.connect(self.print_preview_paint)</strong></span>
        preview_dialog.</span><span style="color: rgba(0, 0, 255, 1)">exec</span>()</pre>
</div>
<p>打印预览的处理逻辑，主要就是需要根据缩放的尺寸获得对应的打印区域大小，并根据页面的大小和实现打印的内容显示，计算好尺寸，也就是一般按每页放置多少行，或者每行的高度来计算，如果需要分页，则标识一下即可。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> print_preview_paint(self, printer: QPrinter) -&gt;<span style="color: rgba(0, 0, 0, 1)"> None:
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">打印预览绘制</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        self.painter </span>= painter =<span style="color: rgba(0, 0, 0, 1)"> QPainter(printer)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 计算每毫米的逻辑单位</span>
        self.logUnitsMM =<span style="color: rgba(0, 0, 0, 1)"> self.calculateScale(printer, painter)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取页面大小</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> unit 参数的可选值有：</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> QPrinter.Unit.Point：点（1 点 = 1/72 英寸）</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> QPrinter.Unit.Millimeter：毫米（常用）</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> QPrinter.Unit.Inch：英寸</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> QPrinter.Unit.Pixel：像素</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取页面的可打印区域</span>
        page_rect =<span style="color: rgba(0, 0, 0, 1)"> printer.pageRect(QPrinter.Unit.Millimeter)
        self.page_height </span>= page_height = page_rect.height() *<span style="color: rgba(0, 0, 0, 1)"> self.logUnitsMM
        self.page_width </span>= page_width = page_rect.width() * self.logUnitsMM</pre>
</div>
<p>如果内容需要分页才能展示完，那么你要使用printer.newPage()来告诉打印机进行分页。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 分页打印</span>
        <span style="color: rgba(0, 0, 255, 1)">print</span>(f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">总行数: {total_rows}, 总页数: {total_pages}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> page <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(total_pages):
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> page &gt; 0:  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 非第一页，需要换页</span>
<span style="color: rgba(0, 0, 0, 1)">                printer.newPage()
            self.print_page(page, rows_per_page, self.print_cols)

        self.painter.end()</span></pre>
</div>
<p>打印的时候，我们打印列头和每列内容，都是根据实际的列宽进行一定比例的处理，让它能够兼容打印最佳效果。</p>
<p>打印表头的时候，如下代码。</p>
<div class="cnblogs_code">
<pre>        index = 0  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 用来计算递增的列数</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> col <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(self.columnCount()):
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> print_cols <span style="color: rgba(0, 0, 255, 1)">and</span> col <span style="color: rgba(0, 0, 255, 1)">not</span> <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> print_cols:
                </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">
            header_text </span>=<span style="color: rgba(0, 0, 0, 1)"> self.GetColLabelValue(col)
            self.painter.drawText(</span>
                int(x_offset + sum(col_widths[:index])),  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 累计不同的列宽</span>
<span style="color: rgba(0, 0, 0, 1)">                y_offset,
                header_text,
            )
            index </span>+= 1</pre>
</div>
<p>打印表格每列的内容，处理规则也是类似，如下代码所示</p>
<div class="cnblogs_code">
<pre>       <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 绘制表格内容</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> row <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(
            page </span>* rows_per_page, min((page + 1) *<span style="color: rgba(0, 0, 0, 1)"> rows_per_page, self.total_rows)
        ):
            y_offset </span>+=<span style="color: rgba(0, 0, 0, 1)"> self.row_height
            index </span>= 0  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 用来计算递增的列数</span>
            <span style="color: rgba(0, 0, 255, 1)">for</span> col <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(self.columnCount()):
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> print_cols <span style="color: rgba(0, 0, 255, 1)">and</span> col <span style="color: rgba(0, 0, 255, 1)">not</span> <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> print_cols:
                    </span><span style="color: rgba(0, 0, 255, 1)">continue</span>
                <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取单元格数据</span>
                text =<span style="color: rgba(0, 0, 0, 1)"> self.GetValue(row, col)
                </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 绘制单元格内容</span>
<span style="color: rgba(0, 0, 0, 1)">                self.painter.drawText(</span>
                    int(x_offset + sum(col_widths[:index])),  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 累计不同的列宽</span>
<span style="color: rgba(0, 0, 0, 1)">                    y_offset,
                    text,
                )
                index </span>+= 1</pre>
</div>
<p>其他如标题，横线、页码等信息，根据显示规则绘制即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202503/8867-20250311215018333-336437110.png" alt=""></p>
</div>
<div id="MySignature" role="contentinfo">
    <div style="border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;">
    <img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" align="top" alt="">
    <span style="color: #000000"><span class="Apple-tab-span" style="white-space: pre"></span>
     专注于代码生成工具、.Net/.NetCore 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架等框架产品。
     <br>&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href="http://www.iqidi.com/" target="_blank">http://www.iqidi.com</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.6655129998703704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-11 22:23">2025-03-11 22:22</span>&nbsp;
<a href="https://www.cnblogs.com/wuhuacong">伍华聪</a>&nbsp;
阅读(<span id="post_view_count">107</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18766333" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18766333);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18766333', targetLink: 'https://www.cnblogs.com/wuhuacong/p/18766333', title: '使用PySide6/PyQt6实现Python跨平台表格数据分页打印预览处理' })">举报</a>

        </p>
    