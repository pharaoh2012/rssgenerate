
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/qwqwQAQ/p/18867762" title="发布于 2025-05-09 10:36">
    <span role="heading" aria-level="2">c#开发完整的Socks5代理客户端与服务端——客户端（已完结）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文我们介绍下如何在Windows系统上开发一个代理本机流量的客户端，并且对接我们之前开发的Socks5服务端，实现整个代理的一条龙。对于Socks5代理的服务端的开发可以详见之前的文章。</p>
</blockquote>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#本机流量劫持" rel="noopener nofollow">本机流量劫持</a><ul><li><a href="#通过系统开启手动代理" rel="noopener nofollow">通过系统开启手动代理</a></li><li><a href="#客户端开启对应tcp服务" rel="noopener nofollow">客户端开启对应TCP服务</a></li><li><a href="#解析系统的http请求" rel="noopener nofollow">解析系统的Http请求</a></li><li><a href="#远程socks5服务端握手" rel="noopener nofollow">远程Socks5服务端握手</a></li><li><a href="#交换流量" rel="noopener nofollow">交换流量</a></li><li><a href="#代理流量显示" rel="noopener nofollow">代理流量显示</a></li></ul></li><li><a href="#验证" rel="noopener nofollow">验证</a><ul><li><a href="#远端开启服务端" rel="noopener nofollow">远端开启服务端</a></li><li><a href="#开启客户端" rel="noopener nofollow">开启客户端</a></li></ul></li><li><a href="#结尾" rel="noopener nofollow">结尾</a></li><li><a href="#源码地址" rel="noopener nofollow">源码地址</a></li></ul></div><p></p>
<h4 id="本机流量劫持">本机流量劫持</h4>
<h5 id="通过系统开启手动代理">通过系统开启手动代理</h5>
<p>通过c#程序打开Windows的手动代理， 并且设置端口号和IP地址，这样只要客户端监听该端口就可以获取到本机的Http的流量数据。</p>
<blockquote>
<p>通过对注册表的修改，来开启本机的手动代理，并且设置端口，Ip设置为本机，因为客户端是本机启动的，端口设置不冲突的即可。</p>
</blockquote>
<blockquote>
<p>黑名单则是设置哪些域名或者IP段不走代理，我们这里先把局域网的排除掉。</p>
</blockquote>
<pre><code>// 引入Windows API
[DllImport("wininet.dll")]
public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);

public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;
public const int INTERNET_OPTION_REFRESH = 37;

// 设置系统代理
public static void SetProxy(string proxyServer, bool enable)
{
    const string userRoot = "HKEY_CURRENT_USER";
    const string subkey = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
    const string keyName = userRoot + "\\" + subkey;

    // 设置代理服务器地址和端口
    Microsoft.Win32.Registry.SetValue(keyName, "ProxyServer", proxyServer);

    // 启用或禁用代理
    Microsoft.Win32.Registry.SetValue(keyName, "ProxyEnable", enable ? 1 : 0);

    // 通知系统设置已更改
    InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);
    InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);
}

/// &lt;summary&gt;
/// 黑名单
/// &lt;/summary&gt;
/// &lt;param name="exceptions"&gt;&lt;/param&gt;
public static void SetProxyExceptions(string exceptions)
{
    const string userRoot = "HKEY_CURRENT_USER";
    const string subkey = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
    const string keyName = userRoot + "\\" + subkey;

    Microsoft.Win32.Registry.SetValue(keyName, "ProxyOverride", exceptions);
}
</code></pre>
<pre><code> SystemProxy.SetProxy($"127.0.0.1:{App.SettingsModel.LocalPort}", true);
 SystemProxy.SetProxyExceptions("localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;192.168.*;&lt;local&gt;");
</code></pre>
<h5 id="客户端开启对应tcp服务">客户端开启对应TCP服务</h5>
<pre><code> _tcpListener = new TcpListener(IPAddress.Any, _httpProxyPort);
 _tcpListener.Start();
</code></pre>
<p>主要就是开启一个监听服务，让操作系统将对应的流量转发到我们的Socks5客户端。</p>
<blockquote>
<p>将http报文进行解析，获取到请求的targetHost和Port,<strong>这样才能后面在和Socks5服务端握手的时候才能告知对方需要代理的远端信息</strong>。</p>
</blockquote>
<h5 id="解析系统的http请求">解析系统的Http请求</h5>
<pre><code>    
    /// &lt;summary&gt;
    /// 解析http请求报文，提取关键信息
    /// &lt;/summary&gt;
    /// &lt;param name="request"&gt;http请求&lt;/param&gt;
    /// &lt;param name="host"&gt;请求主机&lt;/param&gt;
    /// &lt;param name="port"&gt;请求主机端口号&lt;/param&gt;
    /// &lt;returns&gt;是否解析成功&lt;/returns&gt;
    private bool TryParseHttpRequest(string request, out string host, out int port)
    {
        host = null;
        port = 0;

        // 解析 CONNECT 请求（如 CONNECT example.com:443 HTTP/1.1）
        if (request.StartsWith("CONNECT"))
        {
            var parts = request.Split(' ')[1].Split(':');
            host = parts[0];
            port = int.Parse(parts[1]);
            return true;
        }

        // 2. 处理 GET/POST 请求（HTTP）
        using (var reader = new StringReader(request))
        {
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                // 从 Host 头提取目标
                if (line.StartsWith("Host:", StringComparison.OrdinalIgnoreCase))
                {
                    var hostParts = line.Substring(5).Trim().Split(':');
                    host = hostParts[0];
                    if (hostParts.Length &gt; 1)
                        port = int.Parse(hostParts[1]);
                    return true;
                }

                // 空行表示头结束
                if (string.IsNullOrWhiteSpace(line))
                    break;
            }
        }

        // 3. 旧式HTTP/1.0请求可能没有Host头，从URL解析
        if (request.StartsWith("GET ") || request.StartsWith("POST "))
        {
            var url = request.Split(' ')[1];
            if (Uri.TryCreate(url, UriKind.Absolute, out var uri))
            {
                host = uri.Host;
                port = uri.Port;
                return true;
            }
        }

        return false;
    }
</code></pre>
<h5 id="远程socks5服务端握手">远程Socks5服务端握手</h5>
<blockquote>
<p>这里我们采用的是带有认证的握手，需要服务端也开启认证配置，<strong>这里对于握手协议和认证还不清楚的可以看我集合的上面一篇文章</strong></p>
</blockquote>
<blockquote>
<p>将http的远程信息作为握手信息与服务端建立连接，让服务端建立与目标的连接代理。</p>
</blockquote>
<pre><code>    /// &lt;summary&gt;
    /// 带有身份验证的登录
    /// &lt;/summary&gt;
    /// &lt;param name="socks5Stream"&gt;&lt;/param&gt;
    /// &lt;param name="targetHost"&gt;&lt;/param&gt;
    /// &lt;param name="targetPort"&gt;&lt;/param&gt;
    /// &lt;param name="username"&gt;&lt;/param&gt;
    /// &lt;param name="password"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    private async Task PerformSocks5Handshake(NetworkStream socks5Stream,
                                              string targetHost,
                                              int targetPort,
                                              string username,
                                              string password)
    {
        // === 1. 协商认证方法 ===
        // 发送支持的认证方法：无认证(0x00) 和 用户名/密码(0x02)
        var authMethods = new byte[] { 0x05, 0x02, 0x00, 0x02 };
        await socks5Stream.WriteAsync(authMethods, 0, authMethods.Length);

        // 读取服务器选择的认证方法
        var authResponse = new byte[2];
        await socks5Stream.ReadAsync(authResponse, 0, 2);

        if (authResponse[1] == 0xFF)
            throw new Exception("SOCKS5服务器不支持任何提供的认证方法");

        // === 2. 用户名/密码认证 ===
        if (authResponse[1] == 0x02)
        {
            // 构建认证请求包
            var authRequest = new byte[3 + username.Length + password.Length];
            authRequest[0] = 0x01; // 认证子协商版本
            authRequest[1] = (byte)username.Length;
            Encoding.ASCII.GetBytes(username).CopyTo(authRequest, 2);
            authRequest[2 + username.Length] = (byte)password.Length;
            Encoding.ASCII.GetBytes(password).CopyTo(authRequest, 3 + username.Length);

            await socks5Stream.WriteAsync(authRequest, 0, authRequest.Length);

            // 读取认证响应
            var authResult = new byte[2];
            await socks5Stream.ReadAsync(authResult, 0, 2);
            if (authResult[1] != 0x00)
                throw new Exception("SOCKS5用户名/密码认证失败");
        }

        // === 3. 发送连接请求 ===
        var request = new byte[7 + targetHost.Length];
        request[0] = 0x05; // VER
        request[1] = 0x01; // CMD=CONNECT
        request[2] = 0x00; // RSV
        request[3] = 0x03; // ATYP=域名
        request[4] = (byte)targetHost.Length;
        Encoding.ASCII.GetBytes(targetHost).CopyTo(request, 5);
        BitConverter.GetBytes(IPAddress.HostToNetworkOrder((short)targetPort)).CopyTo(request, 5 + targetHost.Length);

        await socks5Stream.WriteAsync(request, 0, request.Length);

        // === 4. 读取连接响应 ===
        var response = new byte[10];
        await socks5Stream.ReadAsync(response, 0, 10);
        if (response[1] != 0x00)
            throw new Exception($"SOCKS5连接失败 (状态码: {response[1]})");
    }
</code></pre>
<h5 id="交换流量">交换流量</h5>
<blockquote>
<p>所谓的交换流量就是把远程代理的流量和本机的请求流量通过客户端作为中间人来转发</p>
</blockquote>
<pre><code>    private async Task ForwardDataAsync(NetworkStream src, NetworkStream dest)
    {
        var buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = await src.ReadAsync(buffer, 0, buffer.Length)) &gt; 0)
        {
            await dest.WriteAsync(buffer, 0, bytesRead);
        }
    }
</code></pre>
<pre><code>await Task.WhenAny(ForwardDataAsync(httpStream, socks5Stream),ForwardDataAsync(socks5Stream, httpStream)
</code></pre>
<h5 id="代理流量显示">代理流量显示</h5>
<blockquote>
<p>客户端也需要显示上传和下载流量的一些显示，我们这里简单点，因为我们之前开发的服务端是有基于用户的流量统计的，所以只需要把数据获取到就行，一般情况下为了性能，也可以做双端统计减少压力。</p>
</blockquote>
<p>我们这里通过SSE将用户的流量信息基于用户名推送到客户端。</p>
<pre><code>public async Task ConnectAsync(string remoteAddress, string userName)
{
    _httpClient = new HttpClient(new HttpClientHandler
    {
        Proxy = new WebProxy($"http://{remoteAddress}:5000"), // 明确指定代理
    });
    _cts = new CancellationTokenSource();

    try
    {
        using var response = await _httpClient
            .GetAsync($"http://{remoteAddress}:5000/account/flow/{userName}", HttpCompletionOption.ResponseHeadersRead,_cts.Token);
        if (response.IsSuccessStatusCode)
        {
            using var stream = await response.Content.ReadAsStreamAsync();
            using var reader = new StreamReader(stream);
            while (!_cts.Token.IsCancellationRequested)
            {
                var line = await reader.ReadLineAsync();
                if (!string.IsNullOrEmpty(line))
                {
                    MessageReceived?.Invoke(line);
                }
            }
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"SSE连接错误: {ex.Message}");
    }
}
</code></pre>
<h4 id="验证">验证</h4>
<h5 id="远端开启服务端">远端开启服务端</h5>
<p><img src="https://img2024.cnblogs.com/blog/1306612/202505/1306612-20250509102744249-972019505.png" alt="image" loading="lazy"></p>
<h5 id="开启客户端">开启客户端</h5>
<p>添加一些配置<br>
包括：服务端IP,服务端Port,本地代理Port,用户名密码<br>
<img src="https://img2024.cnblogs.com/blog/1306612/202505/1306612-20250509102925688-1796562828.png" alt="image" loading="lazy"><br>
开启客户端<br>
<img src="https://img2024.cnblogs.com/blog/1306612/202505/1306612-20250509103022064-1140012666.png" alt="image" loading="lazy"><br>
可以看到代理成功，走的是本机的代理和服务端的代理请求<br>
<img src="https://img2024.cnblogs.com/blog/1306612/202505/1306612-20250509103158093-1239036030.png" alt="image" loading="lazy"></p>
<h4 id="结尾">结尾</h4>
<p>因为本身代理采用的修改系统代理设置是一种基础设置，所谓可能存在下面影响：<br>
<strong>仅影响支持系统代理的应用（部分UWP应用、游戏等会绕过</strong><br>
<strong>无法代理非HTTP/HTTPS流量（如DNS、UDP</strong></p>
<h4 id="源码地址">源码地址</h4>
<p><a href="https://github.com/BruceQiu1996/Socks5Server" target="_blank" rel="noopener nofollow">https://github.com/BruceQiu1996/Socks5Server</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.15458876415625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-09 10:41">2025-05-09 10:36</span>&nbsp;
<a href="https://www.cnblogs.com/qwqwQAQ">BruceNeter</a>&nbsp;
阅读(<span id="post_view_count">158</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18867762);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18867762', targetLink: 'https://www.cnblogs.com/qwqwQAQ/p/18867762', title: 'c#开发完整的Socks5代理客户端与服务端——客户端（已完结）' })">举报</a>
</div>
        