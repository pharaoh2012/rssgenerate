
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wxhnlex/p/19048001" title="发布于 2025-08-20 10:04">
    <span role="heading" aria-level="2">浅谈图论算法——图的连通性</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="浅谈图论算法图的连通性">浅谈图论算法——图的连通性</h2>
<h3 id="一-图的连通性topsort">一, 图的连通性(Topsort)</h3>
<blockquote>
<h4 id="topsort是针对dag有向无环图检查其连通性的图论算法">Topsort是针对DAG(有向无环图)，检查其连通性的图论算法。</h4>
</blockquote>
<p><strong>算法过程</strong>：统计所有节点的入度，如果当前节点的入度为0，则将当前节点入队，对于每个节点枚举他的所有出边，出点入度减减，重复此过程。</p>
<h4 id="板子题topsort模板">板子题：<a href="https://www.luogu.com.cn/problem/B3644" target="_blank" rel="noopener nofollow">Topsort(模板)</a></h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1010;
int e[N], ne[N], h[N], idx = 0;
int n, din[N];
inline void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}
inline void Topsort() {
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i ++) {
        if (!din[i]) {
            cout &lt;&lt; i &lt;&lt; " ";
            q.push(i);
        }
    }
    while (q.size()) {
        int t = q.front(); q.pop();
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            din[j] --;
            if (!din[j]) {
                cout &lt;&lt; j &lt;&lt; " ";
                q.push(j);
            }
        }
    }
}
int main() {
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= n; i ++) {
        int x;
        while (cin &gt;&gt; x &amp;&amp; x) {
            add (i, x); din[x] ++;
        }
    }
    Topsort();
}
</code></pre>
<h4 id="练习题摄像头">练习题：<a href="https://www.luogu.com.cn/problem/P2712" target="_blank" rel="noopener nofollow">摄像头</a></h4>
<p>提示：注意摄像头的位置并非全为n</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 10010;
int e[N], ne[N], h[N], idx = 0;
int n, din[N], ans = 0, x[N];
bool st[N];
inline void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}
inline void Topsort() {
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i ++) {
        if (!din[x[i]]) q.push(i);
    }
    while (q.size()) {
        int t = q.front(); q.pop(); ans ++;
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i]; din[j] --;
            if (!din[j] &amp;&amp; st[j]) {
                q.push(j);
            }
        }
    }
}
int main() {
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= n; i ++) {
        int m; cin &gt;&gt; x[i] &gt;&gt; m; st[x[i]] = 1;
        for (int j = 1; j &lt;= m; j ++) {
            int y; cin &gt;&gt; y;
            add (x[i], y); din[y] ++;
        }
    }
    Topsort();
    if (ans == n) puts("YES");
    else cout &lt;&lt; n - ans &lt;&lt; endl;
}
</code></pre>
<h4 id="练习题游览">练习题：<a href="https://www.luogu.com.cn/problem/P1685" target="_blank" rel="noopener nofollow">游览</a></h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
const int Mod = 1e4;
int n, m, s, t, t0;
int e[N], ne[N], w[N], h[N], idx = 0;
int cnt[N], dist[N], din[N];
inline void add (int a, int b, int c) {
    e[idx] = b;
    ne[idx] = h[a];
    w[idx] = c;
    h[a] = idx ++;
}
inline void Topsort() {
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i ++) {
        if (!din[i]) q.push(i);
    }
    while (q.size()) {
        int t = q.front(); q.pop();
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i]; din[j] --;
            cnt[j] = (cnt[j] + cnt[t]) % Mod;
            dist[j] = ((dist[j] + dist[t]) % Mod + w[i] * cnt[t] % Mod) % Mod;
            if (!din[j]) q.push(j);
        }
    }
}
int main() {
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t &gt;&gt; t0;
    for (int i = 1; i &lt;= m; i ++) {
        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add (a, b, c); din[b] ++;
    }
    cnt[s] = 1;
    Topsort();
    cout &lt;&lt; (dist[t] + t0 * (cnt[t] - 1) % Mod) % Mod &lt;&lt; endl;
}
</code></pre>
<h3 id="二图的连通性tarjan">二，图的连通性(Tarjan)</h3>
<blockquote>
<h4 id="强连通分量即对于图中的某一部分节点-u-和-v-可以相互到达则称它们同属于一个连通分量">强连通分量：即对于图中的某一部分节点 $u$ 和 $v$ 可以相互到达则称它们同属于一个连通分量</h4>
</blockquote>
<p>引入一些Tarjan算法会用到的定义</p>
<blockquote>
<h4 id="dfn-时间戳表示当前节点在dfs搜索树上的位置">dfn[] 时间戳：表示当前节点在dfs搜索树上的位置</h4>
</blockquote>
<blockquote>
<h4 id="low当前节点最小子树的根节点初始值为当前节点的dfn">low[]：当前节点最小子树的根节点，初始值为当前节点的dfn</h4>
</blockquote>
<h4 id="1-tarjan求强连通分量">(1) Tarjan求强连通分量</h4>
<h4 id="板子题求强连通分量模板">板子题：<a href="https://www.luogu.com.cn/problem/B3609" target="_blank" rel="noopener nofollow">求强连通分量(模板)</a></h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
const int M = 2 * N;
int n, m, dfn[M], low[M];
int e[M], ne[M], h[M], idx = 0;
int mark = 0, col[M], sum = 0;
bool vis[M];
stack&lt;int&gt; st;
vector&lt;int&gt; vec[N];
inline void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}
inline void Tarjan(int u) {
    dfn[u] = low[u] = ++ mark;
    vis[u] = 1, st.push(u);
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min (low[u], low[v]);
        } else {
            if (vis[v]) {
                low[u] = min (low[u], low[v]);
            }
        }
    }
    if (dfn[u] == low[u]) {
        col[u] = ++ sum;
        vis[u] = 0;
        while (st.top() != u) {
            col[st.top()] = sum;
            vis[st.top()] = 0;
            st.pop();
        }
        st.pop();
    }
}
int main() {
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= m; i ++) {
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        add (a, b);
    }
    for (int i = 1; i &lt;= n; i ++) {
        if (!dfn[i]) Tarjan(i);
    }
    for (int i = 1; i &lt;= n; i ++) {
        vec[col[i]].push_back(i);
    }
    memset(vis, 0, sizeof vis);
    cout &lt;&lt; sum &lt;&lt; endl;
    for (int i = 1; i &lt;= n; i ++) {
        int color = col[i];
        if (!vis[color]) {
            vis[color] = 1;
            sort (vec[color].begin(), vec[color].end());
            for (int j = 0; j &lt; vec[color].size(); j ++) cout &lt;&lt; vec[color][j] &lt;&lt; " ";
            cout &lt;&lt; endl;
        }
    }
}
</code></pre>
<h4 id="缩点">缩点</h4>
<p>由Tarjan求强连通分量我们可以进一步思考这个问题，我们把每个强连通分量看作一个点，这个点的权值记录为在强连通分量中每一个点的权值之和。</p>
<h4 id="板子题缩点模板">板子题：<a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener nofollow">缩点(模板)</a></h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
const int M = 2 * N;
int e[M], ne[M], h[M], idx = 0, idxx = 0;
int ee[M], nee[M], hh[M], a[N], dist[M];
int n, m, dfn[M], low[M], val[M];
int col[M], mark = 0, cnt = 0, din[M];
bool vis[M];
stack&lt;int&gt; st;
inline void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}
inline void add_S(int a, int b) {
    ee[idxx] = b;
    nee[idxx] = hh[a];
    hh[a] = idxx ++;
}
inline void Tarjan(int u) {
    dfn[u] = low[u] = ++ mark;
    vis[u] = 1, st.push(u);
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min (low[u], low[v]);
        } else if (vis[v]) low[u] = min (low[u], low[v]); // 这里用low[v]更新和用dfn[v]更新都是可以的
    }
    if (dfn[u] == low[u]) {
        col[u] = ++ cnt;
        vis[u] = 0; val[cnt] = a[u]; // 如果这里不用do…while的话记得要在初始时更新val[cnt]
        while (st.top() != u) {
            col[st.top()] = cnt;
            vis[st.top()] = 0;
            val[cnt] += a[st.top()];
            st.pop();
        }
        st.pop();
    }
}
inline int Topsort() { // 在进行Topsort的时候记得要用新建的图，也就是缩点后的图
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= cnt; i ++) {
        dist[i] = val[i];
        if (!din[i]) q.push(i);
    }
    while (q.size()) {
        int t = q.front(); q.pop();
        for (int i = hh[t]; ~i; i = nee[i]) {
            int v = ee[i]; din[v] --;
            if (dist[v] &lt; dist[t] + val[v]) {
                dist[v] = dist[t] + val[v];
            }
            if (!din[v]) q.push(v);
        }
    }
    int ans = 0;
    for (int i = 1; i &lt;= cnt; i ++) ans = max (ans, dist[i]);
    return ans;
}
int main() {
    memset(h, -1, sizeof h);
    memset(hh, -1, sizeof hh);
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= m; i ++) {
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        add (a, b);
    }
    for (int i = 1; i &lt;= n; i ++) {
        if (!dfn[i]) Tarjan(i);
    }
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = h[i]; ~j; j = ne[j]) {
            int v = e[j];
            if (col[i] != col[v]) {
                add_S (col[i], col[v]); // 注意建边要建col[u]与col[v]
                din[col[v]] ++;
            }
        }
    }
    cout &lt;&lt; Topsort() &lt;&lt; endl;
}
</code></pre>
<h4 id="例题搭配购买">例题：<a href="https://www.luogu.com.cn/problem/P1455" target="_blank" rel="noopener nofollow">搭配购买</a></h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e4 + 10;
const int M = 2 * N;
int n, m, k, v[M], w[M];
int e[M], ne[M], h[M], idx = 0;
int dfn[M], low[M], mark = 0, dp[M];
int siz[M], val[M], cnt = 0, col[M];
bool vis[M];
stack&lt;int&gt; st;
inline void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}
inline void Tarjan(int u) {
    dfn[u] = low[u] = ++ mark;
    st.push(u); vis[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int p = e[i];
        if (!dfn[p]) {
            Tarjan(p);
            low[u] = min (low[u], low[p]);
        } else if (vis[p]) {
            low[u] = min (low[u], low[p]);
        }
    }
    if (dfn[u] == low[u]) {
        col[u] = ++ cnt;
        siz[cnt] += v[u];
        val[cnt] += w[u];
        vis[u] = 0;
        while (st.top() != u) {
            vis[st.top()] = 0;
            col[st.top()] = cnt;
            siz[cnt] += v[st.top()];
            val[cnt] += w[st.top()];
            st.pop();
        }
        st.pop();
     }
}
int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];
    memset(h, -1,  sizeof h);
    for (int i = 1; i &lt;= m; i ++) {
        int a, b; cin &gt;&gt; a &gt;&gt; b;
        add (a, b); add (b, a);
    }
    for (int i = 1; i &lt;= n; i ++) {
        if (!dfn[i]) Tarjan(i); 
    }
    memset(dp, -0x3f, sizeof dp);
    dp[0] = 0;
    for (int i = 1; i &lt;= cnt; i ++) {
        for (int j = k; j &gt;= siz[i]; j --) {
            dp[j] = max (dp[j], dp[j - siz[i]] + val[i]);
        }
    }
    int ans = 0;
    for (int i = 1; i &lt;= k; i ++) ans = max (ans, dp[i]);
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
<h3 id="关于tarjan的一些不太重要的知识点">关于Tarjan的一些不太重要的知识点</h3>
<blockquote>
<h4 id="割点-在无向图中如果将一点及其连边删去使得原图不连通则称这个点为割点">割点: 在无向图中如果将一点及其连边删去使得原图不连通则称这个点为割点</h4>
</blockquote>
<blockquote>
<h4 id="桥类似于割点的定义若在无向图中将一边删去原图不连通则将该边成为桥">桥：类似于割点的定义，若在无向图中将一边删去原图不连通则将该边成为桥</h4>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-20 10:05">2025-08-20 10:04</span>&nbsp;
<a href="https://www.cnblogs.com/wxhnlex">wxhnlex</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19048001);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19048001', targetLink: 'https://www.cnblogs.com/wxhnlex/p/19048001', title: '浅谈图论算法——图的连通性' })">举报</a>
</div>
        