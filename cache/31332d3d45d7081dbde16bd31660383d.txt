
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18969209" title="发布于 2025-07-06 19:13">
    <span role="heading" aria-level="2">分布式事务-2PC</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-2pc是什么" rel="noopener nofollow">1. 2PC是什么</a></li><li><a href="#2-2pc流程" rel="noopener nofollow">2. 2PC流程</a></li><li><a href="#3-2pc的使用场景" rel="noopener nofollow">3. 2PC的使用场景</a></li><li><a href="#4-2pc的问题" rel="noopener nofollow">4. 2PC的问题</a></li><li><a href="#5-2pc的实现" rel="noopener nofollow">5. 2PC的实现</a><ul><li><a href="#51-xa" rel="noopener nofollow">5.1. XA</a></li><li><a href="#52-seata的xa模式" rel="noopener nofollow">5.2. Seata的XA模式</a></li></ul></li><li><a href="#6-参考" rel="noopener nofollow">6. 参考</a></li></ul></div><p></p>
<h2 id="1-2pc是什么">1. 2PC是什么</h2>
<p>保证强一致性的一种分布式事务方案</p>
<h2 id="2-2pc流程">2. 2PC流程</h2>
<ul>
<li>把事务分成两个阶段
<ul>
<li>第一阶段：由事务管理器向所有database发送prepare请求</li>
<li>第二阶段根据第一阶段的结果决定。
<ul>
<li>如果第一阶段全部响应ok那么执行第二阶段的commit；</li>
<li>如果第一阶段有一个database响应fail或者事务管理器等待超时那么执行第二阶段的rollback</li>
</ul>
</li>
</ul>
</li>
<li><img alt="2PC" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/1622646866_20210602231422247_15205.png" class="lazyload"></li>
</ul>
<h2 id="3-2pc的使用场景">3. 2PC的使用场景</h2>
<ul>
<li>适用于强一致性、时间敏感度高、分布式事务可以回滚的业务的处理结果，比如金融转账场景</li>
<li>单个服务多个数据源且数据源都是DB，即传统单体</li>
</ul>
<h2 id="4-2pc的问题">4. 2PC的问题</h2>
<ul>
<li>性能问题：在阶段1，各个database开始锁定资源，直到第二阶段才释放锁资源。这段期间一直处于同步阻塞状态，性能很差</li>
<li>单点问题：阶段1完成之后，在阶段2如果事务管理器挂了，那么所有database无法收到下一步指令，事务无法继续执行</li>
<li>一致性问题：阶段1完成之后，在阶段2如果任一database挂了没有返回ACK，那么其他database是提交还是回滚无法确定</li>
</ul>
<h2 id="5-2pc的实现">5. 2PC的实现</h2>
<ul>
<li>每个参与者需要实现3个接口
<ul>
<li>Prepare</li>
<li>Commit</li>
<li>Rollback</li>
</ul>
</li>
</ul>
<h3 id="51-xa">5.1. XA</h3>
<ul>
<li>数据库基于2PC实现的分布式事务，有一个统一标准叫做DTP</li>
<li>DTP模型定义了几个角色：
<ul>
<li>AP：我们的微服务</li>
<li>TM：全局事务管理者</li>
<li>RM：数据库</li>
<li>CRM：TM和RM的通信中间件</li>
</ul>
</li>
<li>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</li>
<li>为了让不同的数据库之间可以通讯，必须有一个标准，因此有了XA。XA就是TM和RM通讯的接口规范</li>
</ul>
<h3 id="52-seata的xa模式">5.2. Seata的XA模式</h3>
<ul>
<li>支持XA事务的数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库。</li>
</ul>
<h2 id="6-参考">6. 参考</h2>
<ul>
<li><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b#heading-15" target="_blank" rel="noopener nofollow">再有人问你分布式事务，把这篇扔给他 - 掘金</a></li>
<li><a href="https://segmentfault.com/q/1010000015277647" target="_blank" rel="noopener nofollow">事务 - 请问TCC和2PC的区别在哪里 - SegmentFault 思否</a></li>
<li><a href="https://www.zhihu.com/question/280888550" target="_blank" rel="noopener nofollow">请问TCC和2PC的区别在哪里？ - 知乎</a></li>
<li><a href="http://seata.io/zh-cn/docs/dev/mode/xa-mode.html" target="_blank" rel="noopener nofollow">Seata XA 模式</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-06 19:14">2025-07-06 19:13</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18969209);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18969209', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18969209', title: '分布式事务-2PC' })">举报</a>
</div>
        