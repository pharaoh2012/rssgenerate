
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18786049" title="发布于 2025-03-21 23:08">
    <span role="heading" aria-level="2">Netty源码—3.Reactor线程模型二</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="3" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="4"><strong>5.NioEventLoop的执行总体框架</strong></p>
<p data-track="5"><strong>6.Reactor线程执行一次事件轮询</strong></p>
<p data-track="6"><strong>7.Reactor线程处理产生IO事件的Channel</strong></p>
<p data-track="7"><strong>8.Reactor线程处理任务队列之添加任务</strong></p>
<p data-track="8"><strong>9.Reactor线程处理任务队列之执行任务</strong></p>
<p data-track="9"><strong>10.NioEventLoop总结</strong></p>
<p data-track="10">&nbsp;</p>
<p data-track="11"><strong>5.NioEventLoop的执行总体框架</strong></p>
<p data-track="12"><strong>(1)Reactor线程所做的三件事情</strong></p>
<p data-track="13"><strong>(2)处理多久IO事件就执行多久任务</strong></p>
<p data-track="14"><strong>(3)NioEventLoop.run()方法的执行流程</strong></p>
<p data-track="15">&nbsp;</p>
<p data-track="16"><strong>(1)Reactor线程所做的三件事情</strong></p>
<p data-track="17">NioEventLoop的run()方法里有个无限for循环，for循环里便是Reactor线程所要做的3件事情。</p>
<p data-track="18">&nbsp;</p>
<p data-track="19">一.首先是调用select()方法进行一次事件轮询</p>
<p data-track="20">由于一个NioEventLoop对应一个Selector，所以该select()方法便是轮询注册到这个Reactor线程对应的Selector上的所有Channel的IO事件。注意，select()方法里也有一个无限for循环，但是这个无限for循环可能会被某些条件中断。</p>
<p data-track="21">&nbsp;</p>
<p data-track="22">二.然后调用processSelectedKeys()方法处理轮询出来的IO事件</p>
<p data-track="23">&nbsp;</p>
<p data-track="24">三.最后调用runAllTasks()方法来处理外部线程放入TaskQueue的任务</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    private volatile int ioRatio = 50;
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
            //2.处理产生IO事件的Channel
            processSelectedKeys();
            ...
            //3.执行外部线程放入TaskQueue的任务
            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
        }
    }

    private void select(boolean oldWakenUp) throws IOException {
        for(;;) {
            //1.定时任务截止时间快到了，中断本次轮询
            //2.轮询过程中发现有任务加入，中断本次轮询
            //3.阻塞式select操作: selector.select(timeoutMills)
            //4.避免JDK空轮询Bug
        }
    }
    ...
}</code></pre>
<p data-track="26"><strong>(2)处理多久IO事件就执行多久任务</strong></p>
<p data-track="27">在NioEventLoop的run()方法中，有个ioRatio默认是50，代表处理IO事件的时间和执行任务的时间是1:1。也就是执行了多久的processSelectedKeys()方法后，紧接着就执行多久的runAllTasks()方法。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    private volatile int ioRatio = 50;
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
            final int ioRatio = this.ioRatio;
            if (ioRatio == 100) {
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    runAllTasks();
                }
            } else {
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    final long ioTime = System.nanoTime() - ioStartTime;
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            }
            ...
        }
    }
    ...
}</code></pre>
<p data-track="29"><strong>(3)NioEventLoop.run()方法的执行流程</strong></p>
<pre class="highlighter-hljs"><code>NioEventLoop.run() -&gt; for(;;)
  select() //执行一次事件轮询检查是否有IO事件
  processSelectedKeys() //处理产生IO事件的Channel
  runAllTasks() //处理异步任务队列
//这3步放在一个线程处理应该是为了节约线程，因为不是总会有IO事件和异步任务的</code></pre>
<p data-track="31">&nbsp;</p>
<p data-track="32"><strong>6.Reactor线程执行一次事件轮询</strong></p>
<p data-track="33"><strong>(1)执行select操作前设置wakeUp变量</strong></p>
<p data-track="34"><strong>(2)定时任务快开始了则中断本次轮询</strong></p>
<p data-track="35"><strong>(3)轮询中发现有任务加入则中断本次轮询</strong></p>
<p data-track="36"><strong>(4)执行阻塞式select操作</strong></p>
<p data-track="37"><strong>(5)避免JDK的空轮询Bug</strong></p>
<p data-track="38"><strong>(6)执行一次事件轮询的总结</strong></p>
<p data-track="39">&nbsp;</p>
<p data-track="40"><strong>(1)执行select操作前设置wakeUp变量</strong></p>
<p data-track="41">NioEventLoop有个wakenUp成员变量表示是否应该唤醒正在阻塞的select操作。NioEventLoop的run()方法准备执行select()方法进行一次新的循环逻辑之前，都会将wakenUp设置成false，标志新一轮循环的开始。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    //Boolean that controls determines if a blocked Selector.select should break out of its selection process. 
    //In our case we use a timeout for the select method and the select method will block for that time unless waken up.
    private final AtomicBoolean wakenUp = new AtomicBoolean();
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
        }
    }
    ...
}</code></pre>
<p data-track="43">如下是NioEventLoop的select()方法的执行逻辑，也就是Netty关于事件循环的4段逻辑。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        for(;;) {
            //1.定时任务截止时间快到了，中断本次轮询
            //2.轮询过程中发现有任务加入，中断本次轮询
            //3.阻塞式select操作: selector.select(timeoutMills)
            //4.避免JDK空轮询Bug
        }
    }
    ...
}</code></pre>
<p data-track="45"><strong>(2)定时任务快开始了则中断本次轮询</strong></p>
<p data-track="46">NioEventLoop中的Reactor线程的select操作也是一个for循环。</p>
<p data-track="47">&nbsp;</p>
<p data-track="48">在for循环第一步，如果发现当前定时任务队列中某个任务的开始时间快到了(小于0.5ms)，那么就跳出循环。在跳出循环之前，如果发现目前为止还没有进行过select操作，就调用一次selectNow()方法执行非阻塞式select操作。</p>
<p data-track="49">&nbsp;</p>
<p data-track="50">Netty里的定时任务队列是按照延迟时间从小到大进行排序的，所以delayNanos()方法返回的第一个定时任务的延迟时间便是最早截止的时间。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        int selectCnt = 0;
        long currentTimeNanos = System.nanoTime();//当前时间
        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);//当前时间 + 定时任务的最早截止时间
        for(;;) {
            //1.定时任务截止时间快到了，中断本次轮询
            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;
            if (timeoutMillis &lt;= 0) {
                if (selectCnt == 0) {
                    selector.selectNow();//非阻塞执行select操作
                    selectCnt = 1;
                }
                break;
            }
            ...
        }
    }
    ...
}

//Abstract base class for OrderedEventExecutor's that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    ...
    protected long delayNanos(long currentTimeNanos) {
        ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();
        if (scheduledTask == null) {
            return SCHEDULE_PURGE_INTERVAL;
        }
        return scheduledTask.delayNanos(currentTimeNanos);
    }
    ...
}

//Abstract base class for EventExecutors that want to support scheduling.
public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;//定时任务队列
    ...
    final ScheduledFutureTask&lt;?&gt; peekScheduledTask() {
        Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = this.scheduledTaskQueue;
        if (scheduledTaskQueue == null) {
            return null;
        }
        return scheduledTaskQueue.peek();
    }
    ...
}

final class ScheduledFutureTask&lt;V&gt; extends PromiseTask&lt;V&gt; implements ScheduledFuture&lt;V&gt; {
    ...
    public long delayNanos(long currentTimeNanos) {
        return Math.max(0, deadlineNanos() - (currentTimeNanos - START_TIME));
    }
    public long deadlineNanos() {
        return deadlineNanos;
    }
    ...
}</code></pre>
<p data-track="52"><strong>(3)轮询中发现有任务加入则中断本次轮询</strong></p>
<p data-track="53">注意：Netty的任务队列包括普通任务和定时任务。定时任务快开始时需要中断本次轮询，普通任务队列非空时也需要中断本次轮询。</p>
<p data-track="54">&nbsp;</p>
<p data-track="55">Netty为了保证普通任务队列里的普通任务能够及时执行，在调用selector.select()方法进行阻塞式select操作前会判断普通任务队列是否为空。如果不为空，那么就调用selector.selectNow()方法执行一次非阻塞select操作，然后跳出循环。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        int selectCnt = 0;
        ...
        for(;;) {
            ...
            //2.轮询过程中发现有任务加入，中断本次轮询
            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) {
                selector.selectNow();//非阻塞式执行select操作
                selectCnt = 1;
                break;
            }
            ...
        }
    }
    ...
}

//Abstract base class for EventLoops that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
    private final Queue&lt;Runnable&gt; tailTasks;
    ...
    @Override
    protected boolean hasTasks() {
        return super.hasTasks() || !tailTasks.isEmpty();
    }
    ...
}

//Abstract base class for OrderedEventExecutor's that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    private final Queue&lt;Runnable&gt; taskQueue;//普通任务队列
    ...
    protected boolean hasTasks() {
        assert inEventLoop();
        return !taskQueue.isEmpty();
    }
    ...
}</code></pre>
<p data-track="57"><strong>(4)执行阻塞式select操作</strong></p>
<p data-track="58"><strong>一.最多阻塞到第一个定时任务的开始时间</strong></p>
<p data-track="59"><strong>二.外部线程提交任务会唤醒Reactor线程</strong></p>
<p data-track="60"><strong>三.是否中断本次轮询的判断条件</strong></p>
<p data-track="61">&nbsp;</p>
<p data-track="62"><strong>一.最多阻塞到第一个定时任务的开始时间</strong></p>
<p data-track="63">执行到这一步，说明Netty的普通任务队列里的队列为空，并且所有定时任务的开始时间还未到(大于0.5ms)。于是便进行一次阻塞式select操作，一直阻塞到第一个定时任务的开始时间，也就是把timeoutMills作为参数传入select()方法中。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        ...
        for(;;) {
            ...
            //3.阻塞式select操作: selector.select(timeoutMills)，最多阻塞timeoutMills时间
            int selectedKeys = selector.select(timeoutMillis);
            selectCnt ++;
            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
                // - Selected something,
                // - waken up by user, or
                // - the task queue has a pending task.
                // - a scheduled task is ready for processing
                break;
            }
            ...
        }
    }
    ...
}</code></pre>
<p data-track="65"><strong>二.外部线程提交任务会唤醒Reactor线程</strong></p>
<p data-track="66">如果第一个定时任务的延迟时间非常长，比如一小时，那么有可能线程会一直阻塞在select操作(select完还是会返回的)。但只要这段时间内有新任务加入，该阻塞就会被释放。</p>
<p data-track="67">&nbsp;</p>
<p data-track="68">比如当有外部线程执行NioEventLoop的execute()方法添加任务时，就会调用NioEventLoop的wakeUp()方法来通过selector.wakeup()方法，去唤醒正在执行selector.select(timeoutMills)而被阻塞的线程。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    //Boolean that controls determines if a blocked Selector.select should break out of its selection process. 
    //In our case we use a timeout for the select method and the select method will block for that time unless waken up.
    private final AtomicBoolean wakenUp = new AtomicBoolean();
    Selector selector;
    ...
    @Override
    protected void wakeup(boolean inEventLoop) {
        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) {
            selector.wakeup();
        }
    }
}

//Abstract base class for EventLoops that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
    ...
}

//Abstract base class for OrderedEventExecutor's that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    ...
    @Override
    public void execute(Runnable task) {
        if (task == null) {
            throw new NullPointerException("task");
        }

        boolean inEventLoop = inEventLoop();
        if (inEventLoop) {
            addTask(task);
        } else {
            startThread();
            addTask(task);
            if (isShutdown() &amp;&amp; removeTask(task)) {
                reject();
            }
        }

        if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) {
            //调用NioEventLoop.wakeup()方法唤醒正在执行selector.select(timeoutMills)而被阻塞的线程
            wakeup(inEventLoop);
        }
    }
    ...
}</code></pre>
<p data-track="70"><strong>三.是否中断本次轮询的判断条件</strong></p>
<p data-track="71">阻塞式select操作结束后，Netty又会做一系列状态判断来决定是否中断本次轮询，如果满足如下条件就中断本次轮询：</p>
<p data-track="72">条件一：检测到IO事件</p>
<p data-track="73">条件二：被用户主动唤醒</p>
<p data-track="74">条件三：普通任务队列里有任务需要执行</p>
<p data-track="75">条件四：第一个定时任务即将要被执行</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        ...
        for(;;) {
            ...
            //3.阻塞式select操作: selector.select(timeoutMills)，最多阻塞timeoutMills时间
            int selectedKeys = selector.select(timeoutMillis);
            selectCnt ++;
            //阻塞式select操作结束后，Netty又会做一系列状态判断来决定是否中断本次轮询
            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
                // - Selected something, 检测到IO事件
                // - waken up by user, 被用户主动唤醒
                // - the task queue has a pending task. 普通任务队列里有任务需要执行
                // - a scheduled task is ready for processing 第一个定时任务即将要被执行
                break;
            }
            ...
        }
    }
    ...
}</code></pre>
<p data-track="77"><strong>(5)避免JDK的空轮询Bug</strong></p>
<p data-track="78">JDK空轮询Bug会导致selector一直空轮询，最终导致CPU的利用率100%。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80"><strong>一.Netty避免JDK空轮询的方法</strong></p>
<p data-track="81">首先每次执行selector.select(timeoutMillis)之前都会记录开始时间，在阻塞式select操作后记录结束时间。</p>
<p data-track="82">&nbsp;</p>
<p data-track="83">然后判断阻塞式select操作是否持续了至少timeoutMillis时间。如果阻塞式select操作持续的时间大于等于timeoutMillis，说明这是一次有效的轮询，于是重置selectCnt为1。如果阻塞式select操作持续的时间小于timeoutMillis，则说明可能触发了JDK的空轮询Bug，于是自增selectCnt。当持续时间很短的select操作的次数selectCnt超过了512次，那么就重建Selector。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    private static final int SELECTOR_AUTO_REBUILD_THRESHOLD = 512;
    ...
    private void select(boolean oldWakenUp) throws IOException {
        Selector selector = this.selector;
        intselectCnt = 0;
        long currentTimeNanos = System.nanoTime();//记录开始时间
        ...
        for(;;) {
            ...
            int selectedKeys = selector.select(timeoutMillis);//进行阻塞式select操作
            selectCnt++;//select操作持续时间很短，可能出现空轮询，selectCnt需要自增
            long time = System.nanoTime();//记录结束时间
            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) {
                //如果select操作持续的时间大于timeoutMillis，说明这是一次有效的轮询，重置selectCnt为1
                selectCnt = 1;
            } else if (selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {
                //如果持续时间很短的select操作的次数超过了512次，就重建selector
                rebuildSelector();//重建Selector
                selector = this.selector;
                selector.selectNow();
                selectCnt = 1;
                break;
            }
            currentTimeNanos = time;
            ...
        }
    }
    ...
}</code></pre>
<p data-track="85"><strong>二.重建Selector的逻辑</strong></p>
<p data-track="86">重建Selector的逻辑就是通过openSelector()方法创建一个新的Selector，然后执行一个无限的for循环，只要执行过程中出现一次并发修改SelectionKeys异常，那么就重新开始转移，直到转移完成。</p>
<p data-track="87">&nbsp;</p>
<p data-track="88">具体的转移步骤为：首先拿到有效的key，然后取消该key在旧Selector上的事件注册。接着将该key对应的Channel注册到新的Selector上，最后重新绑定Channel和新的key。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    ...
    //Replaces the current Selector of this event loop with newly created Selectors to work around the infamous epoll 100% CPU bug.
    public void rebuildSelector() {
        final Selector oldSelector = selector;
        final Selector newSelector = openSelector();
        int nChannels = 0;
        for (;;) {
            try {
                for (SelectionKey key: oldSelector.keys()) {
                    Object a = key.attachment();
                    //1.拿到有效的key
                    if (!key.isValid() || key.channel().keyFor(newSelector) != null) {
                        continue;
                    }
        
                    int interestOps = key.interestOps();
                    //2.取消该key在旧Selector上的事件注册
                    key.cancel();
                    //3.将该key对应的Channel注册到新的Selector上
                    SelectionKey newKey = key.channel().register(newSelector, interestOps, a);
                    if (a instanceof AbstractNioChannel) {
                        //4.重新绑定Channel和新的key
                        ((AbstractNioChannel) a).selectionKey = newKey;
                    }
                    nChannels++;
                }
                break;
            } catch(ConcurrentModificationException e) {
                continue;
            }
        }
        selector = newSelector;
        oldSelector.close();
    }
    ...
}</code></pre>
<p data-track="90"><strong>(6)执行一次事件轮询的总结</strong></p>
<p data-track="91">关于Reactor线程的select操作所做的事情：</p>
<p data-track="92">&nbsp;</p>
<p data-track="93">简单来说就是：</p>
<p data-track="94">不断轮询是否有IO事件发生，并且在轮询过程中不断检查是否有任务需要执行，从而保证Netty任务队列中的任务都能够及时执行，以及在轮询过程中会巧妙地使用一个计数器来避开JDK的空轮询Bug。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96">详细来说就是：</p>
<p data-track="97">NioEventLoop的select()方法首先会判断有没有定时任务快到要开始的时间了、普通任务队列taskQueue里是否存在任务。如果有就调用selector.selectNow()进行非阻塞式的select操作，如果都没有就调用selector.select(timeoutMillis)进行阻塞式select操作。在阻塞式select操作结束后，会判断这次select操作是否阻塞了timeoutMillis这么长时间。如果没有阻塞那么长时间就表明可能触发了JDK的空轮询Bug，接下来就会继续判断可能触发空轮询Bug的次数是否达到了512次，如果达到了就通过替换原来Selector的方式去避开空轮询Bug。</p>
<p data-track="98">&nbsp;</p>
<p data-track="99"><strong>7.Reactor线程处理产生IO事件的Channel</strong></p>
<p data-track="100"><strong>(1)处理IO事件的关键逻辑</strong></p>
<p data-track="101"><strong>(2)Netty对selectedKeys的优化</strong></p>
<p data-track="102"><strong>(3)处理IO事件的过程说明</strong></p>
<p data-track="103"><strong>(4)处理IO事件的总结</strong></p>
<p data-track="104">&nbsp;</p>
<p data-track="105"><strong>(1)处理IO事件的关键逻辑</strong></p>
<p data-track="106">Reactor线程执行的第一步是轮询出注册在Selector上的IO事件，第二步便是处理这些IO事件了。</p>
<p data-track="107">&nbsp;</p>
<p data-track="108">processSelectedKeys()的关键逻辑包含两部分：</p>
<p data-track="109">一.针对selectedKeys的优化</p>
<p data-track="110">二.processSelectedKeysOptimized()方法真正处理IO事件</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    private SelectedSelectionKeySet selectedKeys;
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
            //2.处理产生IO事件的Channel
            processSelectedKeys();
            ...
            //3.执行外部线程放入TaskQueue的任务
            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
        }
    }

    private void processSelectedKeys() {
        if (selectedKeys != null) {
            //selectedKeys.flip()会返回一个数组
            processSelectedKeysOptimized(selectedKeys.flip());
        } else {
            processSelectedKeysPlain(selector.selectedKeys());
        }
    }
    ...
}</code></pre>
<p data-track="112"><strong>(2)Netty对selectedKeys的优化</strong></p>
<p data-track="113">Netty对selectedKeys的所有优化都是在NioEventLoop的openSelector()方法中体现的。</p>
<p data-track="114">&nbsp;</p>
<p data-track="115">这个优化指的是：</p>
<p data-track="116">Selector.select()操作每次都会把就绪状态的IO事件添加到Selector底层的两个HashSet成员变量中，而Netty会通过反射的方式将Selector中用于存放SelectionKey的HashSet替换成数组，使得添加SelectionKey的时间复杂度由HashSet的O(n)降为数组的O(1)。</p>
<p data-track="117">&nbsp;</p>
<p data-track="118">具体来说就是：</p>
<p data-track="119">NioEventLoop的成员变量selectedKeys是一个SelectedSelectionKeySet对象，会在NioEventLoop的openSelector()方法中创建。之后openSelector()方法会通过反射将selectedKeys与Selector的两个成员变量绑定。SelectedSelectionKeySet继承了AbstractSet，但底层是使用数组来存放SelectionKey的。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    private SelectedSelectionKeySet selectedKeys;
    ...
    private Selector openSelector() {
        final Selector selector = provider.openSelector();
        final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();
        ...
        //下面的selectorImplClass对应于sun.nio.ch.SelectorImpl
        Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");
        Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");
        selectedKeysField.setAccessible(true);
        publicSelectedKeysField.setAccessible(true);
        //这两个set才是优化中的精华，一句话总结就是：
        //用数组来替换Selector中用于存放SelectionKey的HashSet的实现，做到add()方法的时间复杂度为O(1)
        selectedKeysField.set(selector, selectedKeySet);
        publicSelectedKeysField.set(selector, selectedKeySet);
        ...
        selectedKeys = selectedKeySet;
        ...
    }
    ...
}

//SelectedSelectionKeySet继承了AbstractSet，说明该类可以当作一个Set来用，但是底层使用两个数组来交替使用
//在add()方法中，首先判断当前应该使用哪个数组，然后找到对应的数组执行如下3个步骤：
//步骤一：将SelectionKey放入数组的尾部
//步骤二：更新该数组的逻辑长度+1
//步骤三：如果该数组的逻辑长度等于该数组的物理长度，就将该数组扩容

//待程序运行一段时间后，等数组的长度足够长，每次轮询到NIO事件的时候，
//调用这里的add()方法只需要O(1)的时间复杂度就能将SelectionKey放入到Set中，
//而JDK底层使用的HashSet的put()方法的时间复杂度最小是O(1)、最大是O(n)，
//使用数组替换HashSet还有一个好处就是遍历的时候非常高效
final class SelectedSelectionKeySet extends AbstractSet&lt;SelectionKey&gt; {
    private SelectionKey[] keysA;
    private int keysASize;
    private SelectionKey[] keysB;
    private int keysBSize;
    private boolean isA = true;

    SelectedSelectionKeySet() {
        keysA = new SelectionKey[1024];
        keysB = keysA.clone();
    }

    @Override
    public boolean add(SelectionKey o) {
        if (o == null) {
            return false;
        }
        if (isA) {
            int size = keysASize;
            keysA[size ++] = o;
            keysASize = size;
            if (size == keysA.length) {
                doubleCapacityA();
            }
        } else {
            int size = keysBSize;
            keysB[size ++] = o;
            keysBSize = size;
            if (size == keysB.length) {
                doubleCapacityB();
            }
        }
        return true;
    }
    
    //返回一个数组
    SelectionKey[] flip() {
        if (isA) {
            isA = false;
            keysA[keysASize] = null;
            keysBSize = 0;
            return keysA;
        } else {
            isA = true;
            keysB[keysBSize] = null;
            keysASize = 0;
            return keysB;
        }
    }
    ...
}

//可以看到，SelectorImpl的两个成员变量selectedKeys和keys都是HashSet
public abstract class SelectorImpl extends AbstractSelector {
    protected Set&lt;SelectionKey&gt; selectedKeys = new HashSet();
    protected HashSet&lt;SelectionKey&gt; keys = new HashSet();
    private Set&lt;SelectionKey&gt; publicKeys;
    private Set&lt;SelectionKey&gt; publicSelectedKeys;

    protected SelectorImpl(SelectorProvider var1) {
        super(var1);
        if (Util.atBugLevel("1.4")) {
            this.publicKeys = this.keys;
            this.publicSelectedKeys = this.selectedKeys;
        } else {
            this.publicKeys = Collections.unmodifiableSet(this.keys);
            this.publicSelectedKeys = Util.ungrowableSet(this.selectedKeys);
        }
    }
    ...
}</code></pre>
<p data-track="121"><strong>(3)处理IO事件的过程说明</strong></p>
<p data-track="122"><strong>说明一：</strong></p>
<p data-track="123">首先取出IO事件。IO事件是以数组的形式从selectedKeys中取的，其对应的Channel则由SelectionKey的attachment()方法返回。</p>
<p data-track="124">&nbsp;</p>
<p data-track="125">此时可以体会到优化过的selectedKeys的好处。因为遍历时遍历的是数组，相对JDK原生的HashSet，效率有所提高。</p>
<p data-track="126">&nbsp;</p>
<p data-track="127">拿到当前的SelectionKey之后，便将selectedKeys[i]设置为null，这样做是为了方便GC。因为假设一个NioEventLoop平均每次轮询出N个IO事件，高峰期轮询出3N个事件，那么selectedKeys的物理长度要大于等于3N。如果每次处理这些key时不设置selectedKeys[i]为null，那么高峰期一过，这些保存在数组尾部的selectedKeys[i]对应的SelectionKey将一直无法被回收，虽然SelectionKey对应的对象可能不大，但其关联的attachment则可能很大。这些对象如果一直存活无法回收，就可能发生内存泄露。</p>
<p data-track="128">&nbsp;</p>
<p data-track="129"><strong>说明二：</strong></p>
<p data-track="130">然后获取当前SelectionKey对应的attachment。这个attachement就是取出的IO事件对应的Channel了，于是接下来就可以处理该Channel了。</p>
<p data-track="131">&nbsp;</p>
<p data-track="132">由于Netty在注册服务端Channel时，会将AbstractNioChannel内部的SelectableChannel对象注册到Selector对象上，并且将AbstractNioChannel作为SelectableChannel对象的一个attachment附属。所以当JDK轮询出某个SelectableChannel有IO事件时，就可以通过attachment()方法直接取出AbstractNioChannel进行操作了。</p>
<p data-track="133">&nbsp;</p>
<p data-track="134"><strong>说明三：</strong></p>
<p data-track="135">接着便会调用processSelectedKey()方法对SelectionKey和AbstractNioChannel进行处理。Netty有两大类Channel：一个是NioServerSocketChannel，由bossGroup处理。另一个是NioSocketChannel，由workerGroup处理。对于boss的NioEventLoop来说，轮询到的是连接事件。对于worker的NioEventLoop来说，轮询到的是读写事件。</p>
<p data-track="136">&nbsp;</p>
<p data-track="137"><strong>说明四：</strong></p>
<p data-track="138">最后会判断是否再进行一次轮询。NioEventLoop的run()方法每次在轮询到IO事件后，都会将needsToSelectAgain设置为false。只有当Channel从Selector上移除时，也就是调用NioEventLoop的cancel()方法时，发现被取消的key已经达到256次了，才会将needsToSelectAgain设置为true。当needsToSelectAgain为true，就会调用selectAgain()方法再进行一次轮询。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    private SelectedSelectionKeySet selectedKeys;
    private boolean needsToSelectAgain;
    private int cancelledKeys;
    private static final int CLEANUP_INTERVAL = 256;
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
            //2.处理产生IO事件的Channel
            needsToSelectAgain = false;
            processSelectedKeys();
            ...
            //3.执行外部线程放入TaskQueue的任务
            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
        }
    }

    private void processSelectedKeys() {
        if (selectedKeys != null) {
            //selectedKeys.flip()会返回一个数组
            processSelectedKeysOptimized(selectedKeys.flip());
        } else {
            processSelectedKeysPlain(selector.selectedKeys());
        }
    }

    private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
        for (int i = 0;; i ++) {
            //1.首先取出IO事件
            final SelectionKey k = selectedKeys[i];
            if (k == null) {
                break;
            }
            selectedKeys[i] = null;//Help GC
            //2.然后获取对应的Channel和处理该Channel
            //默认情况下，这个a就是NioChannel，也就是服务端启动时经过Netty封装的Channel
            final Object a = k.attachment();
            if (a instanceof AbstractNioChannel) {
                //网络事件的处理
                processSelectedKey(k, (AbstractNioChannel) a);
            } else {
                //NioTask主要用于当一个SelectableChannel注册到Selector时，执行的一些任务
                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
                processSelectedKey(k, task);
            }
            //3.最后判断是否应该再进行一次轮询
            if (needsToSelectAgain) {
                for (;;) {
                    i++;
                    if (selectedKeys[i] == null) {
                        break;
                    }
                    selectedKeys[i] = null;
                }
                selectAgain();
                //selectedKeys.flip()会返回一个数组
                selectedKeys = this.selectedKeys.flip();
                i = -1;
            }
        }
    }

    private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        if (!k.isValid()) {
            final EventLoop eventLoop;
            try {
                eventLoop = ch.eventLoop();
            } catch (Throwable ignored) {
                //If the channel implementation throws an exception because there is no event loop, 
                //we ignore this because we are only trying to determine if ch is registered to this event loop and thus has authority to close ch.
                return;
            }
            //Only close ch if ch is still registerd to this EventLoop. 
            //ch could have deregistered from the event loop and thus the SelectionKey could be cancelled as part of the deregistration process, 
            //but the channel is still healthy and should not be closed.
            if (eventLoop != this || eventLoop == null) {
                return;
            }
            //close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
            return;
        }

        try {
            int readyOps = k.readyOps();
            //We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
            //the NIO JDK channel implementation may throw a NotYetConnectedException.
            if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) {
                //remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
                int ops = k.interestOps();
                ops &amp;= ~SelectionKey.OP_CONNECT;
                k.interestOps(ops);
                unsafe.finishConnect();
            }

            //Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
            if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) {
                //Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
                ch.unsafe().forceFlush();
            }

            //Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead to a spin loop
            if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                unsafe.read();
                if (!ch.isOpen()) {
                    //Connection already closed - no need to handle write.
                    return;
                }
            }
        } catch (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }

    void cancel(SelectionKey key) {
        key.cancel();
        cancelledKeys ++;
        if (cancelledKeys &gt;= CLEANUP_INTERVAL) {
            cancelledKeys = 0;
            needsToSelectAgain = true;
        }
    }
    ...
}</code></pre>
<p data-track="140"><strong>(4)处理IO事件的总结</strong></p>
<p data-track="141">Netty默认情况下会通过反射，将Selector底层用于存放SelectionKey的两个HashSet，转化成一个数组来提升处理IO事件的效率。</p>
<p data-track="142">&nbsp;</p>
<p data-track="143">在处理每一个SelectionKey时都会拿到对应的一个attachment，而这个attachment就是在服务端Channel注册Selector时所绑定的一个AbstractNioChannel。所以在处理每一个SelectionKey时，都可以找到对应的AbstractNioChannel，然后通过Pipeline将处理串行到ChannelHandler，回调到用户的方法。</p>
<p data-track="144">&nbsp;</p>
<p data-track="145"><strong>8.Reactor线程处理任务队列之添加任务</strong></p>
<p data-track="146"><strong>(1)Reactor线程执行一次事件轮询的过程</strong></p>
<p data-track="147"><strong>(2)任务的分类和添加说明</strong></p>
<p data-track="148"><strong>(3)普通任务的添加</strong></p>
<p data-track="149"><strong>(4)定时任务的添加</strong></p>
<p data-track="150"><strong>(5)Netty的定时任务机制补充</strong></p>
<p data-track="151">&nbsp;</p>
<p data-track="152"><strong>(1)Reactor线程执行一次事件轮询的过程</strong></p>
<p data-track="153">Reactor线程通过NioEventLoop的run()方法每进行一次事件轮询，首先会调用select()方法尝试检测出IO事件，然后会调用processSelectedKeys()方法处理检测出的IO事件。其中IO事件主要包括新连接接入事件和连接的数据读写事件，最后会调用runAllTasks()方法处理任务队列中的异步任务。</p>
<p data-track="154">&nbsp;</p>
<p data-track="155"><strong>(2)任务的分类和添加说明</strong></p>
<p data-track="156">runAllTasks()方法中的Task包括普通任务和定时任务，分别存放于NioEventLoop不同的队列里。一个是普通的任务队列MpscQueue，另一个是定时的任务队列PriorityQueue。</p>
<p data-track="157">&nbsp;</p>
<p data-track="158">普通的任务队列MpscQueue在创建NioEventLoop时创建的，然后在外部线程调用NioEventLoop的execute()方法时，会调用addTask()方法将Task保存到普通的任务队列里。</p>
<p data-track="159">&nbsp;</p>
<p data-track="160">定时的任务队列PriorityQueue则是在添加定时任务时创建的，然后在外部线程调用NioEventLoop的schedule()方法时，会调用scheduleTaskQueue().add()方法将Task保存到定时的任务队列里。</p>
<p data-track="161">&nbsp;</p>
<p data-track="162"><strong>(3)普通任务的添加</strong></p>
<p data-track="163"><strong>场景一：用户自定义普通任务</strong></p>
<p data-track="164"><strong>场景二：外部线程调用Channel的方法</strong></p>
<p data-track="165">&nbsp;</p>
<p data-track="166">当通过ctx.channel().eventLoop().execute(...)自定义普通任务，或者通过非Reactor线程(外部线程)调用Channel的各类方法时，最后都会执行到SingleThreadEventExecutor的execute()方法。</p>
<p data-track="167">&nbsp;</p>
<p data-track="168"><strong>场景一：用户自定义普通任务</strong></p>
<p data-track="169">不管是外部线程还是Reactor线程执行NioEventLoop的execute()方法，都会调用NioEventLoop的addTask()方法，然后调用offerTask()方法。而offerTask()方法会使用一个taskQueue将Task保存起来。这个taskQueue其实就是一个MPSC队列，每一个NioEventLoop都会有一个MPSC队列。</p>
<p data-track="170">&nbsp;</p>
<p data-track="171">Netty使用MPSC队列可以方便地将外部线程的异步任务进行聚集，然后在Reactor线程内部用单线程来批量执行以提升性能。可以借鉴Netty的这种任务执行模式来处理类似多线程数据聚合，定时上报应用。</p>
<pre class="highlighter-hljs"><code>//场景一：用户自定义普通任务
ctx.channel().eventLoop().execute(new Runnable() {
    @Override
    public void run() {
        ...    
    }
});

public final class NioEventLoop extends SingleThreadEventLoop {
    ...
}

public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
    ...
}

public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    //每一个NioEventLoop会有一个MPSC队列
    private final Queue&lt;Runnable&gt; taskQueue;
    protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,
          boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) {
        super(parent);
        this.addTaskWakesUp = addTaskWakesUp;
        this.maxPendingTasks = Math.max(16, maxPendingTasks);
        this.executor = ObjectUtil.checkNotNull(executor, "executor");
        //创建普通的任务队列MpscQueue
        taskQueue = newTaskQueue(this.maxPendingTasks);
        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
    }
    ...
    
    @Override
    public void execute(Runnable task) {
        if (task == null) throw new NullPointerException("task");
        boolean inEventLoop = inEventLoop();
        //不管是外部线程还是Reactor线程执行NioEventLoop的execute()方法，都会调用NioEventLoop的addTask()方法
        if (inEventLoop) {
            addTask(task);
        } else {
            startThread();
            addTask(task);
            if (isShutdown() &amp;&amp; removeTask(task)) {
                reject();
            }
        }
        if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) wakeup(inEventLoop);
    }
    
    //Add a task to the task queue, or throws a RejectedExecutionException if this instance was shutdown before.
    protected void addTask(Runnable task) {
        if (task == null) throw new NullPointerException("task");
        if (!offerTask(task)) reject(task);
    }

    final boolean offerTask(Runnable task) {
        if (isShutdown()) reject();
        return taskQueue.offer(task);
    }
    ...
}</code></pre>
<p data-track="173"><strong>场景二：外部线程调用Channel的方法</strong></p>
<p data-track="174">这个场景是在业务线程里，根据用户标识找到对应的Channel，然后调用Channel的write()方法向该用户推送消息。</p>
<p data-track="175">&nbsp;</p>
<p data-track="176">外部线程在调用Channel的write()方法时，executor.inEventLoop()会返回false。于是会将write操作封装成一个WriteTask，然后调用safeExecute()方法来执行。默认情况下会获取Channel对应的NIO线程，然后作为参数传入safeExecute()方法中进行执行，从而确保任务会由Channel对应的NIO线程执行，通过单线程执行来实现线程安全。</p>
<pre class="highlighter-hljs"><code>//场景二：当前线程为业务线程
channel.write(...)

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    final EventExecutor executor;//一般初始化时默认为null
    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, Class&lt;? extends ChannelHandler&gt; handlerClass) {
        this.pipeline = pipeline;
        this.executor = executor;
        ...
    }
        
    ...
    private void write(Object msg, boolean flush, ChannelPromise promise) {
        AbstractChannelHandlerContext next = findContextOutbound();
        final Object m = pipeline.touch(msg, next);
        EventExecutor executor = next.executor();
        //外部线程在调用Channel的write()方法时，executor.inEventLoop()会返回false
        if (executor.inEventLoop()) {
            if (flush) {
                next.invokeWriteAndFlush(m, promise);
            } else {
                next.invokeWrite(m, promise);
            }
        } else {
            //将write操作封装成一个WriteTask
            AbstractWriteTask task;
            if (flush) {
                task = WriteAndFlushTask.newInstance(next, m, promise);
            }  else {
                task = WriteTask.newInstance(next, m, promise);
            }
            //调用safeExecute()来执行
            safeExecute(executor, task, promise, m);
        }
    }
    
    @Override
    public EventExecutor executor() {
        if (executor == null) {
            return channel().eventLoop();
        } else {
            return executor;
        }
    }
    
    private AbstractChannelHandlerContext findContextOutbound(int mask) {
        AbstractChannelHandlerContext ctx = this;
        EventExecutor currentExecutor = executor();
        do {
            ctx = ctx.prev;
        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));
        return ctx;
    }
    
    private static void safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {
        try {
            //调用SingleThreadEventExecutor.execute()方法
            executor.execute(runnable);
        } catch (Throwable cause) {
            try {
                promise.setFailure(cause);
            } finally {
                if (msg != null) {
                    ReferenceCountUtil.release(msg);
                }
            }
        }
    }
    ...
}

public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            //传入的executor为null
            super(pipeline, null, HEAD_NAME, HeadContext.class);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
    }
    
    final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
        TailContext(DefaultChannelPipeline pipeline) {
            //传入的executor为null
            super(pipeline, null, TAIL_NAME, TailContext.class);
            setAddComplete();
        }
        ...
    }
    ...
}

public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    //每一个NioEventLoop会有一个MPSC队列
    private final Queue&lt;Runnable&gt; taskQueue;
    protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,
          boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) {
        super(parent);
        this.addTaskWakesUp = addTaskWakesUp;
        this.maxPendingTasks = Math.max(16, maxPendingTasks);
        this.executor = ObjectUtil.checkNotNull(executor, "executor");
        //创建普通的任务队列MpscQueue
        taskQueue = newTaskQueue(this.maxPendingTasks);
        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
    }
  
    ...
    @Override
    public void execute(Runnable task) {
        if (task == null) throw new NullPointerException("task");
        boolean inEventLoop = inEventLoop();
        //不管是外部线程还是Reactor线程执行NioEventLoop的execute()方法，都会调用NioEventLoop的addTask()方法
        if (inEventLoop) {
            addTask(task);
        } else {
            startThread();
            addTask(task);
            if (isShutdown() &amp;&amp; removeTask(task)) {
                reject();
            }
        }
        if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) wakeup(inEventLoop);
    }
    
    //Add a task to the task queue, or throws a RejectedExecutionException if this instance was shutdown before.
    protected void addTask(Runnable task) {
        if (task == null) throw new NullPointerException("task");
        if (!offerTask(task)) reject(task);
    }

    final boolean offerTask(Runnable task) {
        if (isShutdown()) reject();
        return taskQueue.offer(task);
    }
    ...
}</code></pre>
<p data-track="178"><strong>(4)定时任务的添加</strong></p>
<p data-track="179">通常使用ctx.channel().eventLoop().schedule(..)自定义定时任务，其中schedule()方法会通过scheduledTaskQueue().add(task)来添加定时任务。首先scheduledTaskQueue()方法会返回一个优先级队列，然后通过该优先级队列的add()方法将定时任务对象加入到队列中。</p>
<p data-track="180">&nbsp;</p>
<p data-track="181">注意，这里可以直接使用优先级队列而不用考虑多线程并发问题的原因如下。如果是外部线程调用schedule()方法添加定时任务，那么Netty会将添加定时任务这个逻辑封装成一个普通的Task。这个Task的任务是一个"添加某定时任务"的任务，而不是添加某定时任务。这样，对优先级队列的访问就变成单线程了，也就是只有Reactor线程会访问，从而不存在多线程并发问题。</p>
<pre class="highlighter-hljs"><code>//场景三：用户自定义定时任务，这也是用得最多的方法
ctx.channel().eventLoop().schedule(new Runnable() {
    @Override
    public void run() {
        ...    
    }
}, 60, TimeUnit.SECONDS);

//Abstract base class for EventExecutors that want to support scheduling.
public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;
    ...
    //添加定时任务
    &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(final ScheduledFutureTask&lt;V&gt; task) {
        if (inEventLoop()) {
            //如果当前线程是Reactor线程，则直接往PriorityQueue中添加任务
            scheduledTaskQueue().add(task);
        } else {
            //如果是外部线程，则调用SingleThreadEventExecutor.execute()方法
            //将添加定时任务这一动作也封装成一个普通任务
            execute(new Runnable() {
                @Override
                public void run() {
                    scheduledTaskQueue().add(task);
                }
            });
        }
        return task;
    }
    
    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() {
        if (scheduledTaskQueue == null) {
            //创建定时的任务队列PriorityQueue
            scheduledTaskQueue = new PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;();
        }
        return scheduledTaskQueue;
    }
    ...
}</code></pre>
<p data-track="183"><strong>(5)Netty的定时任务机制补充</strong></p>
<p data-track="184"><strong>一.如何保证截止时间最近的任务优先执行</strong></p>
<p data-track="185">为什么定时任务要保存在优先级队列中？优先级队列的特性是会按照一定的顺序来排列内部元素，内部元素是可以比较的。由于优先级队列中的每个元素都是定时任务，所以定时任务也是可以比较的。比较的逻辑就是：先比较定时任务的截止时间，在截止时间相同的情况下再比较定时任务的添加顺序也就是ID。</p>
<p data-track="186">&nbsp;</p>
<p data-track="187"><strong>二.Netty的定时任务有三种执行方式</strong></p>
<p data-track="188">方式一：定时任务不会被重复执行</p>
<p data-track="189">ctx.channel().eventLoop().schedule()，传递的periodNanos为0。</p>
<p data-track="190">方式二：每隔一段时间执行一次</p>
<p data-track="191">ctx.channel().eventLoop().scheduleAtFixedRate()，传递的periodNanos为正数。</p>
<p data-track="192">方式三：隔相同时间再执行一次</p>
<p data-track="193">ctx.channel().eventLoop().scheduleWithFixedDelay()，传递的periodNanos为负数。</p>
<p data-track="194">&nbsp;</p>
<p data-track="195">Netty的3种定时任务的执行逻辑是通过调整下一次任务的截止时间来运行的。首先修改完下一次执行的截止时间，然后把当前任务再次加入队列，这样就能确保任务在适当的时候执行。</p>
<pre class="highlighter-hljs"><code>final class ScheduledFutureTask&lt;V&gt; extends PromiseTask&lt;V&gt; implements ScheduledFuture&lt;V&gt; {
    //每个定时任务都有一个唯一的ID
    private static final AtomicLong nextTaskId = new AtomicLong();
    private final long id = nextTaskId.getAndIncrement();
    private long deadlineNanos;
    //标识一个任务是否重复执行，以及以何种方式执行
    private final long periodNanos;
    ...
    
    @Override
    public int compareTo(Delayed o) {
        if (this == o) {
            return 0;
        }

        ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;
        long d = deadlineNanos() - that.deadlineNanos();
        if (d &lt; 0) {
            return -1;
        } else if (d &gt; 0) {
            return 1;
        } else if (id &lt; that.id) {
            return -1;
        } else if (id == that.id) {
            throw new Error();
        } else {
            return 1;
        }
    }

    public long deadlineNanos() {
        return deadlineNanos;
    }
    
    @Override
    public void run() {
        ...
        if (periodNanos == 0) {
            //1.对应schedule()方法，表示一次性任务
            V result = task.call();
            setSuccessInternal(result);
        } else {
            task.call();
            long p = periodNanos;
            if (p &gt; 0) {
                //2.对应scheduleAtFixedRate()方法，表示以固定速率执行任务
                deadlineNanos += p;
            } else {
                //3.对应scheduleWithFixedDelay()方法，表示以固定的延时执行任务
                deadlineNanos = nanoTime() - p;
            }
            scheduledTaskQueue.add(this);
        }
        ...
    }
    ...
}</code></pre>
<p data-track="197">&nbsp;</p>
<p data-track="198"><strong>9.Reactor线程处理任务队列之执行任务</strong></p>
<p data-track="199"><strong>(1)runAllTasks()方法需要传入超时时间</strong></p>
<p data-track="200"><strong>(2)Reactor线程执行任务的步骤</strong></p>
<p data-track="201"><strong>(3)Netty性能优化之批量策略</strong></p>
<p data-track="202"><strong>(4)NioEventLoop.run()方法执行任务总结</strong></p>
<p data-track="203">&nbsp;</p>
<p data-track="204"><strong>(1)runAllTasks()方法需要传入超时时间</strong></p>
<p data-track="205">SingleThreadEventExecutor的runAllTasks()方法需要传入参数timeoutNanos，表示尽量在timeoutNanos时间内将所有的任务都取出来执行一遍。因为如果Reactor线程在执行任务时停留的时间过长，那么将会累积许多IO事件无法及时处理，从而导致大量客户端请求阻塞。因此Netty会精细控制内部任务队列的执行时间。</p>
<p data-track="206">&nbsp;</p>
<p data-track="207"><strong>(2)Reactor线程执行任务的步骤</strong></p>
<p data-track="208"><strong>一.任务聚合</strong></p>
<p data-track="209">转移定时任务到MPSC队列，这里只是将快到期的定时任务转移到MPSC队列里。</p>
<p data-track="210">&nbsp;</p>
<p data-track="211"><strong>二.时间计算</strong></p>
<p data-track="212">计算本轮任务执行的截止时间，此时所有截止时间已到达的定时任务均被填充到普通的任务队列(MPSC队列)里了。</p>
<p data-track="213">&nbsp;</p>
<p data-track="214"><strong>三.任务执行</strong></p>
<p data-track="215">首先不抛异常地同步执行任务，然后累加当前已执行的任务数，接着每隔64次计算一下当前时间是否已超截止时间，最后判断本轮任务是否已经执行完毕。</p>
<pre class="highlighter-hljs"><code>//Abstract base class for OrderedEventExecutor's that execute all its submitted tasks in a single thread.
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    //每一个NioEventLoop会有一个MPSC队列
    private final Queue&lt;Runnable&gt; taskQueue;
    ...
    
    //Poll all tasks from the task queue and run them via Runnable#run() method.
    //This method stops running the tasks in the task queue and returns if it ran longer than timeoutNanos.
    protected boolean runAllTasks(long timeoutNanos) {
        //1.转移定时任务到MPSC队列，也就是任务聚合
        fetchFromScheduledTaskQueue();
        //从普通的任务队列(MPSC队列)里获取任务
        Runnable task = pollTask();
        if (task == null) {
            afterRunningAllTasks();
            return false;
        }
        //2.计算本轮任务执行的截止时间
        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;
        long runTasks = 0;
        long lastExecutionTime;
        //3.执行任务，通过for循环逐个执行pollTask()取出的任务
        for (;;) {
            //3.1 不抛异常地执行任务(同步阻塞)，确保任务可以安全执行
            safeExecute(task);
            //3.2 累加当前已执行的任务数
            runTasks ++;
            //3.3 每隔64次计算一下当前时间是否已经超过截止时间，因为ScheduledFutureTask.nanoTime()也挺耗时的
            if ((runTasks &amp; 0x3F) == 0) {
                lastExecutionTime = ScheduledFutureTask.nanoTime();
                if (lastExecutionTime &gt;= deadline) {
                    break;
                }
            }
            //3.4 判断本轮任务是否已经执行完毕
            task = pollTask();
            if (task == null) {
                lastExecutionTime = ScheduledFutureTask.nanoTime();
                break;
            }
        }
        afterRunningAllTasks();
        this.lastExecutionTime = lastExecutionTime;
        return true;
    }
    
    private boolean fetchFromScheduledTaskQueue() {
        long nanoTime = AbstractScheduledEventExecutor.nanoTime();
        Runnable scheduledTask  = pollScheduledTask(nanoTime);
        while (scheduledTask != null) {
            if (!taskQueue.offer(scheduledTask)) {
                scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);
                return false;
            }
            scheduledTask  = pollScheduledTask(nanoTime);
        }
        return true;
    }
    
    protected Runnable pollTask() {
        assert inEventLoop();
        return pollTaskFrom(taskQueue);
    }

    protected final Runnable pollTaskFrom(Queue&lt;Runnable&gt; taskQueue) {
        for (;;) {
            Runnable task = taskQueue.poll();
            if (task == WAKEUP_TASK) {
                continue;
            }
            return task;
        }
    }
    ...
}

//Abstract base class for EventExecutors that want to support scheduling.
public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;
    ...
    //Return the Runnable which is ready to be executed with the given nanoTime.
    //You should use #nanoTime() to retrieve the the correct nanoTime.
    protected final Runnable pollScheduledTask(long nanoTime) {
        assert inEventLoop();
        Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = this.scheduledTaskQueue;
        ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();
        if (scheduledTask == null) {
            return null;
        }
        if (scheduledTask.deadlineNanos() &lt;= nanoTime) {
            scheduledTaskQueue.remove();
            return scheduledTask;
        }
        return null;
    }
    ...
}

//Abstract base class for EventExecutor implementations.
public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor {
    ...
    //Try to execute the given Runnable and just log if it throws a Throwable.
    protected static void safeExecute(Runnable task) {
        try {
            task.run();//同步执行任务
        } catch (Throwable t) {
            logger.warn("A task raised an exception. Task: {}", task, t);
        }
    }
    ...
}</code></pre>
<p data-track="217"><strong>(3)Netty性能优化之间隔策略</strong></p>
<p data-track="218">假设任务队列里有海量的小任务，如果每次执行完任务都需要判断是否到截止时间，那么效率是比较低的。所以Netty选择通过每隔64个任务才判断一下是否到截止时间，那么效率就会高很多。</p>
<p data-track="219">&nbsp;</p>
<p data-track="220"><strong>(4)NioEventLoop.run()方法执行任务总结</strong></p>
<p data-track="221">Netty里的任务分两种：一种是普通的任务，另一种是定时的任务。Netty在执行这些任务时首先会把定时任务聚合到普通任务队列里，然后再从普通任务队列里获取任务逐个执行，并且是每执行64个任务之后才判断一下当前时间是否超过最大允许执行时间。如果超过就直接中断，中断之后就会进行下一次NioEventLoop.run()方法的for循环。</p>
<p data-track="222">&nbsp;</p>
<p data-track="223"><strong>10.NioEventLoop总结</strong></p>
<p data-track="224"><strong>(1)NioEventLoop的执行流程总结</strong></p>
<p data-track="225"><strong>(2)Reactor线程模型总结</strong></p>
<p data-track="226"><strong>(3)NioEventLoop创建启动执行的总结</strong></p>
<p data-track="227">&nbsp;</p>
<p data-track="228"><strong>(1)NioEventLoop的执行流程总结</strong></p>
<p data-track="229">一.NioEventLoop在执行过程中首先会不断检测是否有IO事件发生，然后如果检测出有IO事件就处理IO事件，接着处理完IO事件之后再处理外部线程提交过来的异步任务。</p>
<p data-track="230">&nbsp;</p>
<p data-track="231">二.在检测是否有IO事件发生时，为了保证异步任务的及时处理，只要有任务要处理，那么就立即停止检测去处理任务。</p>
<p data-track="232">&nbsp;</p>
<p data-track="233">三.外部线程异步执行的任务分为两种：普通任务和定时任务。这两种任务分别保存到MPSC队列和优先级队列，而优先级队列中的任务最终都会转移到MPSC队列里进行处理。</p>
<p data-track="234">&nbsp;</p>
<p data-track="235">四.Netty每处理完64个任务才会检查一次是否超时而退出执行任务的循环。</p>
<p data-track="236">&nbsp;</p>
<p data-track="237"><strong>(2)Reactor线程模型总结</strong></p>
<p data-track="238">一.NioEventLoopGroup在用户代码中被创建，默认情况下会创建两倍CPU核数个NioEventLoop。</p>
<p data-track="239">&nbsp;</p>
<p data-track="240">二.NioEventLoop是懒启动的，bossNioEventLoop在服务端启动时启动，workerNioEventLoop在新连接接入时启动。</p>
<p data-track="241">&nbsp;</p>
<p data-track="242">三.当CPU核数为2的幂时，为每一个新连接绑定NioEventLoop之后，都会做一个取模运算转位与运算的优化。</p>
<p data-track="243">&nbsp;</p>
<p data-track="244">四.每个连接都对应一个Channel，每个Channel都绑定唯一一个NioEventLoop，一个NioEventLoop可能会被绑定多个Channel，每个NioEventLoop都对应一个FastThreadLocalThread线程实体和一个Selector。因此单个连接的所有操作都是在一个线程上执行的，所以是线程安全的。</p>
<p data-track="245">&nbsp;</p>
<p data-track="246">五.每个NioEventLoop都对应一个Selector，这个Selector可以批量处理注册到它上面的Channel。</p>
<p data-track="247">&nbsp;</p>
<p data-track="248">六.每个NioEventLoop的执行过程都包括事件检测、事件处理以及异步任务的执行。</p>
<p data-track="249">&nbsp;</p>
<p data-track="250">七.用户线程池在对Channel进行一些操作时均为线程安全的。这是因为Netty会把外部线程的操作都封装成一个Task放入这个Channel绑定的NioEventLoop中的MPSC队列，然后在该NioEventLoop的执行过程(事件循环)的第三个过程中进行串行执行。</p>
<p data-track="251">&nbsp;</p>
<p data-track="252">八.所以NioEventLoop的职责不仅仅是处理网络IO事件，用户自定义的普通任务和定时任务也会统一由NioEventLoop处理，从而实现线程模型的统一。</p>
<p data-track="253">&nbsp;</p>
<p data-track="254">九.从调度层看，也不存在从NioEventLoop线程中再启动其他类型的线程用于异步执行另外的任务，从而避免了多线程并发操作和锁竞争，提升了IO线程的处理性能和调度性能。</p>
<p data-track="255">&nbsp;</p>
<p data-track="256"><strong>(3)NioEventLoop创建启动执行的总结</strong></p>
<p data-track="257">一.用户在创建bossGroup和workerGroup时，NioEventLoopGroup被创建，默认不传参时会创建两倍CPU核数个NioEventLoop。</p>
<p data-track="258">&nbsp;</p>
<p data-track="259">二.每个NioEventLoopGroup都有一个线程执行器executor和一个线程选择器chooser。线程选择器chooser用于进行线程分配，它会针对NioEventLoop的个数进行优化。</p>
<p data-track="260">&nbsp;</p>
<p data-track="261">三.NioEventLoop在创建时会创建一个Selector和一个MPSC任务队列，创建Selector时Netty会通过反射的方式用数组去替换Selector里的两个HashSet数据结构。</p>
<p data-track="262">&nbsp;</p>
<p data-track="263">四.Netty的NioEventLoop在首次调用execute()方法时会启动线程，这个线程是一个FastThreadLocalThread对象。启动线程后，Netty会将创建完成的线程保存到成员变量，以便能判断执行NioEventLoop里的逻辑的线程是否是这个创建好的线程。</p>
<p data-track="264">&nbsp;</p>
<p data-track="265">五.NioEventLoop的执行逻辑在run()方法里，主要包括3部分：第一是检测IO事件，第二是处理IO事件，第三是执行异步任务。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8862951800844907" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 23:09">2025-03-21 23:08</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18786049" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18786049);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18786049', targetLink: 'https://www.cnblogs.com/mjunz/p/18786049', title: 'Netty源码—3.Reactor线程模型二' })">举报</a>
</div>
        