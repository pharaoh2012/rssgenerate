
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/haicheng92/p/18720428" title="发布于 2025-02-17 17:34">
    <span role="heading" aria-level="2">Spring单元测试（一）入门与实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>问题：如何快速测试，而不是每次测试都要重启应用？<br>
目标：<strong>尽量只测试局部代码</strong></p>
<h2 id="不同的测试">不同的测试</h2>
<p>软件工程中分为：单元测试、集成测试、功能测试、系统测试。其中功能测试和系统测试一般是测试人员的责任，但单元测试和集成测试则必须由开发人员保证。</p>
<ul>
<li>功能测试：检查是否满足需求说明书中确定的各项需求。</li>
<li>系统测试：与系统其他功能组合在一起进行测试</li>
<li>单元测试：检查开发者编写的一小段代码，以确认改动是否正确。<br>
一个功能往往会调用多个接口方法实现，在单元测试时，需要屏蔽掉这些外在接口方法的依赖，将测试焦点集中到目标功能代码上。比如改动了底层工具类 DateUtils 的公共方法。</li>
</ul>
<p>这时模拟就是最有力的工具，模拟的是功能的使用过程，假定外在接口方法正常返回的情况下验证目标代码的正确性。常见的模拟工具有 EasyMock、JMock、Mockito。</p>
<p><strong>单元测试最重要的是可重复性，不可重复性的单元测试是没有价值的。</strong></p>
<p>单元测试和开发工作是同时进行的，有时候甚至是在开发工作之前。</p>
<ul>
<li>集成测试则是在功能开发代码开发完成之后，验证功能模块之间是否能工正常调用。</li>
</ul>
<p>比如，当对 UserService 这个业务层类进行单元测试时，可以通过创建 UserDao 模拟对象，假设 DAO 层接口方法正常工作的情况下对 UserService 进行局部单元测试。</p>
<p>而对 UserService 进行集成测试时，则应该注入真实的 UserDao 对象进行。<br>
所以一般来讲，集成测试面向的层面更高一些，一般对业务层和 Web 层进行集成测试；单元测试则面向一些功能单一的类，比如字符串格式化工具类、数据计算类等。</p>
<h2 id="测试框架">测试框架</h2>
<p>Spring-Test 是 springframework 中的一个模块，是 Spring 提供的单元测试套件，可以方便的测试基于 Spring 框架的代码。</p>
<p>Spring-Test 是 Spring 框架的扩展，它专门用于帮助测试 Spring 应用，构建在 Junit 基础上，提供 Spring 容器相关的功能，比如测试 Spring Bean 的生命周期、Spring 配置加载等。</p>
<h2 id="代码实践">代码实践</h2>
<h3 id="1引入依赖">1、引入依赖</h3>
<pre><code class="language-xml">&lt;!-- 单元测试 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-test&lt;/artifactId&gt;
	&lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.mockito&lt;/groupId&gt;
	&lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
	&lt;version&gt;3.11.2&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.mockito&lt;/groupId&gt;
	&lt;artifactId&gt;mockito-inline&lt;/artifactId&gt;
	&lt;version&gt;3.11.2&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;junit&lt;/groupId&gt;
	&lt;artifactId&gt;junit&lt;/artifactId&gt;
	&lt;version&gt;4.13.2&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2接口测试">2、接口测试</h3>
<pre><code class="language-java">/**
 * Favor接口单元测试
 */
@RunWith(MockitoJUnitRunner.class)
public class FavorControllerTest {
    private MockMvc mockMvc;
    @Mock
    private FavorService favorService;
    @Mock
    private PersonService personService;
    @InjectMocks
    private FavorController favorController;

    @Before
    public void setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(favorController).build();
        // 模拟登录用户
        MockedStatic&lt;SessionUtils&gt; sessionUtils = mockStatic(SessionUtils.class);
        User mockUser = new User();
        mockUser.setId(1L);
        mockUser.setUserName("testUser");
        sessionUtils.when(SessionUtils::currentUser).thenReturn(mockUser);
    }

    /**
     * 测试请求报文是否合法
     *
     * @throws Exception
     */
    @Test
    public void listPage_ValidQuery_ShouldReturnFavorList() throws Exception {
        // 模拟查询结果
        List&lt;Favor&gt; favorList = new ArrayList&lt;&gt;();
        Favor favor = new Favor();
        favor.setId(1L);
        favor.setHoldPersonId(1L);
        favorList.add(favor);
        // 模拟业务层分页查询
        when(favorService.findPage(any(PageQuery.class))).thenReturn(favorList);
        // 模拟查询人员
        Person mockPerson = new Person();
        mockPerson.setId(1L);
        when(personService.findById(1L)).thenReturn(mockPerson);
        // 模拟Http请求
        String requestBody = "{\"terms\":{\"title\":\"someValue\"},\"page\":{\"pageNo\":1,\"pageSize\":10}}";
        mockMvc.perform(post("/favor/listPage")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
                .andExpect(status().isOk());
    }
}
</code></pre>
<blockquote>
<p>为了行文简洁，忽略的 FavorController、FavorService 等部分代码的实现，不影响说明</p>
</blockquote>
<p><strong>注意：此代码是为了测试请求报文的合法性，即请求的响应码是否是 200，前提是接口在验证请求报文不合法时，会返回 200 以外的响应码。</strong></p>
<p>不同的测试目标，代码也会不同。</p>
<h3 id="3dao-层测试">3、DAO 层测试</h3>
<pre><code class="language-java">/**
 * DAO层测试
 */
@Slf4j
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:applicationContext.xml"})
@Transactional
public class FavorItemDaoTest {

    @Autowired
    private FavorItemDao favorItemDao;

    @Before
    public void setUp() {
        // 如果需要，可以在这里进行任何通用设置
    }

    /**
     * 测试查询条件
     */
    @Test
    public void findByCondition_related() {
        Map&lt;String, Object&gt; map = ImmutableMap.of("receiveGiveRelated", true,
                "receivePersonIdList", Arrays.asList(1L, 2L, 3L, 4L),
                "givePersonIdList", Arrays.asList(11L, 12L));
        List&lt;FavorItem&gt; byCondition = favorItemDao.findByCondition(map);
        assertNotEquals(0, byCondition.size());
    }

}
</code></pre>
<p>这里的 Spring 配置文件建议尽量简洁，以加快测试方法执行。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.029537194105324075" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-17 17:35">2025-02-17 17:34</span>&nbsp;
<a href="https://www.cnblogs.com/haicheng92">刘一二</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18720428" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18720428);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18720428', targetLink: 'https://www.cnblogs.com/haicheng92/p/18720428', title: 'Spring单元测试（一）入门与实践' })">举报</a>
</div>
        