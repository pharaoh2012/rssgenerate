
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/gupingan/p/18628539" title="发布于 2024-12-24 19:11">
    <span role="heading" aria-level="2">Promise/A+ 规范 - 中文版本</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="promisesa">Promises/A+</h1>
<blockquote>
<p><strong>这是一个开放标准，旨在让不同开发者实现的 JavaScript Promise 能够无缝衔接并应用——由前辈们制定，为其他后来者提供参考</strong></p>
</blockquote>
<p>一个 <em>promise</em> 所表示的是异步操作的结果。与 <em>promise</em> 交互的主要方式是通过它的 <code>then</code> 方法，该方法会注册所传入的回调函数，回调函数将接收 <em>promise</em> 的最终值或者 <em>promise</em> 无法被满足时的原因。</p>
<p>本规范详细说明了 <code>then</code> 方法的行为，为所有符合 Promises/A+ 标准的 <em>promise</em> 实现提供可靠的基础。因此本规范的更新或修订应被视为非常稳定。虽然 Promises/A+ 组织可能会偶尔对本规范进行向后兼容的小幅度修订，以解决新发现的边缘情况，但我们依然会在经过认真仔细的考虑、讨论和测试后，才会去整合重大或者不向后兼容的变更。</p>
<p>在过去，Promises/A+ 不仅明确早期 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener nofollow">Promise/A</a> 提案中的涉及的行为条款，而且还扩展了一些涵盖实际行为的内容，并且省略了那些不清不楚或存在问题的部分。</p>
<p>最后要说的是，Promises/A+ 规范的核心并不涉及如何创建、满足或拒绝 <em>promise</em>，而是选择专注于提供一个强大的 <code>then</code> 方法以确保不同实现之间的兼容性。大概未来的相关规范才可能会涉及如何创建、满足和拒绝 <em>promise</em> 这些主题吧。</p>
<h2 id="1-专业术语">1 专业术语</h2>
<ol>
<li><code>thenable</code>： 一个具有 <code>then</code> 方法的对象或函数。</li>
<li><code>promise</code>：一个具有 <code>then</code> 方法的对象或函数，<code>then</code> 方法的行为符合本规范。</li>
<li><code>value</code>：是一个合法的 JS 值，含 <code>undefined</code>、<code>null</code>、<code>thenable</code> 或 <code>promise</code> 等。</li>
<li><code>exception</code>：通过 <code>throw</code> 语句抛出的值。</li>
<li><code>reason</code>：通常用于表示 <code>promise</code> 被拒绝/无法实现的原因，也是个值。</li>
</ol>
<h2 id="2-详细规范">2 详细规范</h2>
<h3 id="21-promise-状态">2.1 Promise 状态</h3>
<p>一个 promise 必须处于以下三种状态之一：</p>
<p><code>待定中（pending）</code>、<code>已实现（fulfilled）</code>、<code>已拒绝（rejected）</code></p>
<p>关于这些状态的描述如下：</p>
<ol>
<li>待定中 —— pending:
<ol>
<li>可以转变为其它两种状态，也就是已实现（fulfilled）或已拒绝（rejected）</li>
</ol>
</li>
<li>已实现 —— fulfilled:
<ol>
<li>禁止从该状态转变为其它状态，状态不可改变</li>
<li>必须有一个不可改变的值（value —— 完成后的成果！！）</li>
</ol>
</li>
<li>已拒绝 —— rejected:
<ol>
<li>禁止从该状态转变为其它状态，状态不可改变</li>
<li>必须有一个不可改变的原因（reason —— 为什么拒绝！？）</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意：<code>不可改变</code>并不意味着深层次的不可变（比如属性描述符中 <code>writeable: false</code>），你可以通过对当前状态进行全等判断（<code>===</code>），从而更改相应的值/原因和状态后，那么<code>不可改变</code>自然而然的就会成立了。</p>
</blockquote>
<h3 id="22-then-方法">2.2 <code>then</code> 方法</h3>
<p>一个 <em>promise</em> 必须提供一个 <code>then</code> 方法，它可以访问当前或最终的值或者原因。</p>
<p><em>promise</em> 的 <code>then</code> 方法接受两个参数：</p>
<pre><code class="language-js">promise.then(onFulfilled, onRejected)
</code></pre>
<ol>
<li>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 均是可选参数：</p>
<ol>
<li>如果 <code>onFulfilled</code> 不是一个函数，则必须被忽略。</li>
<li>如果 <code>onRejected</code> 不是一个函数，则必须被忽略。</li>
</ol>
<blockquote>
<p><code>被忽略</code>是指我们不对它做任何的处理，不会抛出任何的错误</p>
</blockquote>
</li>
<li>
<p>如果 <code>onFulfilled</code> 是一个函数：</p>
<ol>
<li>必须在 <code>promise</code> 被实现后调用，且以 <code>promise</code> 的值（value）作为第一个参数。</li>
<li>在 <code>promise</code> 被实现之前不可调用。</li>
<li>不允许被多次调用。</li>
</ol>
</li>
<li>
<p>如果 <code>onRejected</code> 是一个函数：</p>
<ol>
<li>必须在 <code>promise</code> 被拒绝后调用，且以 <code>promise</code> 的原因（reason）作为第一个参数。</li>
<li>在 <code>promise</code> 被拒绝之前不可调用。</li>
<li>不允许被多次调用。</li>
</ol>
</li>
<li>
<p><code>onFulfilled</code> 或 <code>onRejected</code> 必须在执行上下文栈仅包含平台代码时才被调用。[<a href="#3-引注" target="_self" rel="noopener nofollow">3.1</a>]</p>
</li>
<li>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 必须作为函数调用（没有 <code>this</code> 值）。[<a href="#3-引注" target="_self" rel="noopener nofollow">3.2</a>]</p>
</li>
<li>
<p><code>then</code> 可以在同一个 promise 上被多次调用。</p>
<ol>
<li>当 <code>promise</code> 被实现时，所有相应的 <code>onFulfilled</code> 回调必须按它们调用 <code>then</code> 的顺序执行。</li>
<li>当 <code>promise</code> 被拒绝时，所有相应的 <code>onRejected</code> 回调必须按它们调用 <code>then</code> 的顺序执行。</li>
</ol>
</li>
<li>
<p><code>then</code> 必须返回一个 promise [<a href="#3-引注" target="_self" rel="noopener nofollow">3.3</a>]。</p>
<pre><code class="language-js">promise2 = promise1.then(onFulfilled, onRejected);
</code></pre>
<ol>
<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值 <code>x</code>，则运行 Promise 解决过程 <code>[[Resolve]](promise2, x)</code>[<a href="#23-promise-解决过程" target="_self" rel="noopener nofollow">2.3</a>]。</li>
<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 抛出异常 <code>e</code>，则 <code>promise2</code> 必须以 <code>e</code> 作为原因被拒绝。</li>
<li>如果 <code>promise1</code> 被实现且 <code>onFulfilled</code> 不是一个函数，那么 <code>promise2</code> 必须以与 <code>promise1</code> 相同的值（value）被实现。</li>
<li>如果 <code>promise1</code> 被拒绝且 <code>onRejected</code> 不是一个函数，那么 <code>promise2</code> 必须以与 <code>promise1</code> 相同的原因（reason）被拒绝。</li>
</ol>
</li>
</ol>
<h3 id="23-promise-解决过程">2.3 Promise 解决过程</h3>
<p><strong>Promise 解决过程</strong> 是一种抽象操作，它接受一个 <em>promise</em> 和一个值作为输入，表示为 <code>[[Resolve]](promise, x)</code>。如果 <code>x</code> 是一个 <em>thenable</em>，则会尝试使 <code>promise</code> 采用 <code>x</code> 的状态，前提是 <code>x</code> 至少在某种程度上表现得像一个 <em>promise</em>。否则，它将用值 <code>x</code> 来实现 <code>promise</code>。</p>
<p>对 <em>thenable</em> 的这种处理方式使得不同的 <em>promise</em> 实现能够有效兼容，只要它们提供符合 Promises/A+ 标准的 <code>then</code> 方法。但是也允许 Promises/A+ 实现能够“接纳”那些具有合理 <code>then</code> 方法的非标准实现。</p>
<p>要实现 <code>[[Resolve]](promise, x)</code>，请按照以下步骤操作：</p>
<ol>
<li>如果 <code>promise</code> 和 <code>x</code> 指向同一个对象，则以 <code>TypeError</code> 拒绝 <code>promise</code> 作为原因。</li>
<li>如果 <code>x</code> 是一个 <em>promise</em>，则采用其状态 [<a href="#3-引注" target="_self" rel="noopener nofollow">3.4</a>]：
<ol>
<li>如果 <code>x</code> 是待定状态，<code>promise</code> 必须保持待定，直到 <code>x</code> 被实现或拒绝。</li>
<li>如果 <code>x</code> 被实现，使用相同的值实现 <code>promise</code>。</li>
<li>如果 <code>x</code> 被拒绝，使用相同的原因拒绝 <code>promise</code>。</li>
</ol>
</li>
<li>否则，如果 <code>x</code> 是一个对象或函数：
<ol>
<li>将 <code>then</code> 设置为 <code>x.then</code>。[<a href="#3-引注" target="_self" rel="noopener nofollow">3.5</a>]</li>
<li>如果检索属性 <code>x.then</code> 时抛出异常 <code>e</code>，则以 <code>e</code> 作为原因拒绝 <code>promise</code>。</li>
<li>如果 <code>then</code> 是一个函数，则以 <code>x</code> 作为 <code>this</code> 调用它，第一个参数为 <code>resolvePromise</code>，第二个参数为 <code>rejectPromise</code>，其中：
<ol>
<li>如果 <code>resolvePromise</code> 被调用并传入值 <code>y</code>，则运行 <code>[[Resolve]](promise, y)</code>。</li>
<li>如果 <code>rejectPromise</code> 被调用并传入原因 <code>r</code>，则以 <code>r</code> 拒绝 <code>promise</code>。</li>
<li>如果同时调用了 <code>resolvePromise</code> 和 <code>rejectPromise</code>，或对同一参数进行了多次调用，第一次调用优先，后续调用将被忽略。</li>
<li>如果调用 <code>then</code> 时抛出异常 <code>e</code>，
<ol>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已被调用，则忽略该异常。</li>
<li>否则，以 <code>e</code> 作为原因拒绝 <code>promise</code>。</li>
</ol>
</li>
</ol>
</li>
<li>如果 <code>then</code> 不是一个函数，则用 <code>x</code> 来实现 <code>promise</code>。</li>
</ol>
</li>
<li>如果 <code>x</code> 既不是对象也不是函数，则用 <code>x</code> 来实现 <code>promise</code>。</li>
</ol>
<p>如果一个 <em>promise</em> 被一个循环的 <em>thenable</em> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质使得它被再次调用，按照上述算法将会导致无限递归。虽然算法并不强制要求检测这种递归，但我们鼓励实现者可以这样做。如果检测到存在循环，则应以一个语义清晰的 <code>TypeError</code> 拒绝 <code>promise</code>。[<a href="#3-引注" target="_self" rel="noopener nofollow">3.6</a>]</p>
<h2 id="3-引注">3 引注</h2>
<ol>
<li>
<p>这里的“平台代码”指的是引擎、环境和 promise 的实现代码。实际上，这一要求确保 <code>onFulfilled</code> 和 <code>onRejected</code> 在调用 <code>then</code> 的事件循环转之后异步执行，并且在一个新的调用栈中。这可以通过“宏任务”机制（如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener nofollow"><code>setTimeout</code></a> 或 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="noopener nofollow"><code>setImmediate</code></a>）或“微任务”机制（如 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="noopener nofollow"><code>MutationObserver</code></a> 或 <a href="http://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener nofollow"><code>process.nextTick</code></a>）来实现。由于 promise 实现被视为平台代码，它本身可能包含一个任务调度队列或“跳板”，用于调用处理程序。</p>
</li>
<li>
<p>也就是说，在严格模式下，<code>this</code> 的值将是 <code>undefined</code>；在非严格模式下，<code>this</code> 将指向全局对象。</p>
</li>
<li>
<p>实现可以允许 <code>promise2 === promise1</code>，前提是该实现满足所有要求。每个实现应记录是否可以产生 <code>promise2 === promise1</code> 以及在什么条件下可以实现。</p>
</li>
<li>
<p>通常，只有当 <code>x</code> 来自当前实现时，才能确定 <code>x</code> 是一个真正的 promise。这一条款允许使用特定于实现的方法来采用已知符合标准的 promises 的状态。</p>
</li>
<li>
<p>这个过程首先存储对 <code>x.then</code> 的引用，然后测试该引用，最后调用该引用，避免了对 <code>x.then</code> 属性的多次访问。这种预防措施对于确保在访问器属性的情况下保持一致性非常重要，因为该属性的值可能在多次检索之间发生变化。</p>
</li>
<li>
<p>实现不应对 thenable 链的深度设置任意限制，并假设超出该限制的递归将是无限的。只有真正的循环才应导致 <code>TypeError</code>；如果遇到无限的不同 thenable 链，则无限递归是正确的行为。</p>
</li>
</ol>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/gupingan/" target="_blank">顾平安</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/gupingan/p/18628539" target="_blank">https://www.cnblogs.com/gupingan/p/18628539</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.8702441100578704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 19:26">2024-12-24 19:11</span>&nbsp;
<a href="https://www.cnblogs.com/gupingan">顾平安</a>&nbsp;
阅读(<span id="post_view_count">127</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628539" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628539);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628539', targetLink: 'https://www.cnblogs.com/gupingan/p/18628539', title: 'Promise/A+ 规范 - 中文版本' })">举报</a>
</div>
        