
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/naturl/p/18709164" title="发布于 2025-02-11 10:02">
    <span role="heading" aria-level="2">鸿蒙开发 - 支持导出，跨文件使用的自定义样式 AttributeModifier</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我们在自定义组件的时候，无论是用 <code>@Styles</code> 还是 <code>@Extend</code>，都很难真正做到独立的封装样式，因为这两者都不支持导出，不可以跨文件调用</p>
<p>这篇文章主要介绍一个接口 <code>AttributeModifier</code>，它很好的解决了这些弊端，可以实现样式的集中管理和复用，支持<strong>跨文件</strong>调用封装好的样式类</p>
<h2 id="attributemodifier">AttributeModifier</h2>
<h4 id="使用介绍">使用介绍</h4>
<p><code>AttributeModifier</code> 是一个接口，我们需要实现其中的一个方法 <code>apply&lt;状态名称&gt;Attribute</code>，来实现不同的场景</p>
<p>状态名称分为：默认态（Normal）、按压态（Pressed）、焦点态（Focused）、禁用态（Disabled）、选择态（Selected）</p>
<p>如果想设置元素的默认样式，就是 <code>applyNormalAttribute</code>，如果想设置元素的按压场景下的样式，就是 <code>applyPressedAttribute</code></p>
<pre><code class="language-typescript">declare interface AttributeModifier&lt;T&gt; {

  applyNormalAttribute?(instance: T): void;
  
  applyPressedAttribute?(instance: T): void;
  
  applyFocusedAttribute?(instance: T): void;
  
  applyDisabledAttribute?(instance: T): void;
  
  applySelectedAttribute?(instance: T): void;

}
</code></pre>
<h4 id="举例">举例</h4>
<p>文字描述比较抽象，下面举例代码来讲解：</p>
<ul>
<li>我们可以新建个目录<code>modifier</code>，新建个文件<code>index.ets</code>，封装一个作用于 <code>Button</code> 组件的样式类，给它添加一些样式，如下：</li>
</ul>
<pre><code class="language-typescript">export class ButtonModifier implements AttributeModifier&lt;ButtonAttribute&gt; {
  applyNormalAttribute(instance: ButtonAttribute): void {
    instance
      .width(150)
      .height(50)
      .fontSize(20)
      .backgroundColor(Color.Orange)
  }
}
</code></pre>
<ol>
<li>第一步：用 <code>AttributeModifier</code> 接口定义了一个 <code>ButtonModifier</code> 样式类</li>
<li>第二步：再实现 <code>applyNormalAttribute</code> 设置默认态样式：包括宽度、高度、字体等</li>
</ol>
<ul>
<li>在组件文件中使用</li>
</ul>
<pre><code class="language-typescript">import { ButtonModifier } from './modifier/index'

@Entry
@Component
struct Index {
  @State buttonModifier: ButtonModifier = new ButtonModifier()

  build() {
    Column() {
      Button('按钮')
        .attributeModifier(this.buttonModifier)
    }
    .width('100%')
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202502/1289125-20250211095656261-864360551.png" alt="img.png" loading="lazy"></p>
<p>这样我们就实现了一个对 <code>Button</code> 组件的样式封装，并且支持导出，跨文件使用</p>
<h4 id="支持同时设置多个场景的样式">支持同时设置多个场景的样式</h4>
<p>上面给 <code>Button</code> 组件增加了“默认态”的样式，可以在这基础上继续增加“按压态”的样式，就是按钮按下时的样式，如下：</p>
<ul>
<li>按钮按下的时候：增加边框，边框颜色等</li>
</ul>
<pre><code class="language-typescript">export class ButtonModifier2 implements AttributeModifier&lt;ButtonAttribute&gt; {
  applyNormalAttribute(instance: ButtonAttribute): void {
    instance
      .width(150)
      .height(80)
      .fontSize(20)
      .backgroundColor(Color.Orange)
  }

  applyPressedAttribute(instance: ButtonAttribute): void {
    instance
      .borderWidth(5)
      .borderColor(Color.Blue)
      .borderStyle(BorderStyle.Solid)
      .backgroundColor('#17A98D')
  }
}
</code></pre>
<ul>
<li>在组件中引用</li>
</ul>
<pre><code class="language-typescript">import { ButtonModifier2 } from './modifier/index'

@Entry
@Component
struct Index {
  @State buttonModifier: ButtonModifier2 = new ButtonModifier2()

  build() {
    Column() {
      Button('按钮')
        .attributeModifier(this.buttonModifier)
    }
    .width('100%')
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202502/1289125-20250211095656919-1273185632.gif" alt="" loading="lazy"></p>
<h4 id="接口中支持传参和业务逻辑">接口中支持传参和业务逻辑</h4>
<p>在 <code>ButtonModifier3</code> 样式类中，定义一个 <code>isClick</code> 变量，来区分按钮是否点击过，然后分别对点击和没有点击的情况下增加样式，如下：</p>
<pre><code class="language-typescript">export class ButtonModifier3 implements AttributeModifier&lt;ButtonAttribute&gt; {
  isClick: boolean = false

  constructor(flag?: boolean) {
    this.isClick = !!flag
  }

  applyNormalAttribute(instance: ButtonAttribute): void {
    if (this.isClick) {
      instance.backgroundColor('#707070')
    } else {
      instance
        .borderColor('#707070')
        .borderWidth(2)
        .backgroundColor('#17A98D')
    }
  }
}
</code></pre>
<ul>
<li>在组件中调用</li>
</ul>
<pre><code class="language-typescript">import { ButtonModifier3 } from './modifier/index'

@Entry
@Component
struct Index {
  @State buttonModifier: ButtonModifier3 = new ButtonModifier3()
  // @State buttonModifier: ButtonModifier3 = new ButtonModifier3(true)
  
  build() {
    Column() {
      Button('按钮')
        .attributeModifier(this.buttonModifier)
        .onClick(() =&gt; {
          this.buttonModifier.isClick = !this.buttonModifier.isClick
        })
    }
    .width('100%')
  }
} 
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202502/1289125-20250211095657437-49913284.gif" alt="" loading="lazy"></p>
<h4 id="总结">总结</h4>
<ul>
<li>注意事项</li>
</ul>
<p>我们在实现 <code>AttributeModifier&lt;T&gt;</code> 接口的实例，T 必须指定为组件对应的 Attribute类型，或者是CommonAttribute，如下：</p>
<pre><code class="language-typescript">// 作用于 Button 组件，就要传入 ButtonAttribute
export class Modifier1 implements AttributeModifier&lt;ButtonAttribute&gt; {
 applyNormalAttribute?(instance: ButtonAttribute): void;
}

// 作用于 TextInput 组件，就要传入 TextInputAttribute
export class Modifier2 implements AttributeModifier&lt;TextInputAttribute&gt; {
 applyNormalAttribute?(instance: ButtonAttribute): void;
}
</code></pre>
<ul>
<li>@Style 和 @Extend 和 AttributeModifier 三者对比</li>
</ul>
<table>
<thead>
<tr>
<th>能力</th>
<th>@Styles</th>
<th>@Extend</th>
<th>AttributeModifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>跨文件导出</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>通用属性设置</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>通用事件设置</td>
<td>支持</td>
<td>支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>组件特有属性设置</td>
<td>不支持</td>
<td>支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>组件特有事件设置</td>
<td>不支持</td>
<td>支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>参数传递</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>多态样式</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>业务逻辑</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h4 id="最后">最后</h4>
<p>如果大家有不理解的地方可以留言，或自行阅读文档 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-user-defined-extension-attributemodifier-V5" target="_blank" rel="noopener nofollow">文档地址</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/naturl/" target="_blank">时光凉忆</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/naturl/p/18709164" target="_blank">https://www.cnblogs.com/naturl/p/18709164</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.10631432056134259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 15:43">2025-02-11 10:02</span>&nbsp;
<a href="https://www.cnblogs.com/naturl">时光凉忆</a>&nbsp;
阅读(<span id="post_view_count">86</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18709164" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18709164);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18709164', targetLink: 'https://www.cnblogs.com/naturl/p/18709164', title: '鸿蒙开发 - 支持导出，跨文件使用的自定义样式 AttributeModifier' })">举报</a>
</div>
	