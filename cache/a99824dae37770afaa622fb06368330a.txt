<!----> <meta itemprop="headline" content="前端部署后自动提醒用户更新"> <meta itemprop="keywords" content="JavaScript,前端框架,Webpack"> <meta itemprop="datePublished" content="2024-10-23T03:23:52.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Kier"> <meta itemprop="url" content="https://juejin.cn/user/3060648982086663"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            前端部署后自动提醒用户更新
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/3060648982086663/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Kier
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-23T03:23:52.000Z" title="Wed Oct 23 2024 03:23:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-23
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    7,967
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p>前端项目经常碰到更新部署了，但是更新过的功能并没有及时的展示，还需要刷新一下页面，才能看到最新的内容。如果是远程给客户进行的部署，还要口头告知客户需要刷新，体验不友好。</p>
<h2 data-id="heading-1">技术涉及</h2>
<p>vue、webpack、js等。</p>
<h2 data-id="heading-2">问题思考</h2>
<p>想要解决整个问题的关键点在于，检测部署文件的变化。部署文件的变化，前后端都可以做，或者配合一起来完成。纯前端实现的话，就是需要前端自己打包文件的变更进行一个变动检测，如果当前文件与上次部署文件发生变化，那么就得提醒需要刷新，或者自动刷新。前端文件变化，主要在打包后的js、css、以及html的文件变化。而后端的话，主要是记录更新日志记录，检测到版本更新日志变化，那么就得告知前端个进行更新，这里主要通过接口的形式告知版本信息，前端根据接口信息进行更新。</p>
<h2 data-id="heading-3">实现方案</h2>
<h3 data-id="heading-4">方案一：生成git提交的hash信息json文件，请求本地json文件获取更新信息</h3>
<p>在项目中一直使用插件<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fgit-revision-webpack-plugin" target="_blank" title="https://www.npmjs.com/package/git-revision-webpack-plugin" ref="nofollow noopener noreferrer">git-revision-webpack-plugin</a>，记录前端项目的git提交信息，以便于运维人员进行版本比对和维护。</p>
<p><strong>安装依赖</strong></p>
<pre><code class="hljs language-js" lang="js">npm install git-revision-webpack-plugin --save-dev
</code></pre>
<p><strong>webpack主要打包配置中引入git-revision-webpack-plugin插件</strong></p>
<pre><code class="hljs language-js" lang="js">引入<span class="hljs-title class_">GitRevisionPlugin</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">GitRevisionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'git-revision-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> gitRevisionPlugin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GitRevisionPlugin</span>()
</code></pre>
<p><strong>webpack插件配置plugins以及生成version.json</strong></p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-attr">plugins</span>: [
 <span class="hljs-comment">//配插件</span>
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">GitRevisionPlugin</span>(),
  
 <span class="hljs-comment">//在dist或者自定义的打包输出目录下生成包含hash的json</span>
     {
      <span class="hljs-attr">apply</span>: <span class="hljs-function">(<span class="hljs-params">compiler</span>) =&gt;</span> {
        compiler.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">'emit'</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {
          <span class="hljs-comment">// 获取 Git 版本和哈希</span>
          <span class="hljs-keyword">const</span> version = gitRevisionPlugin.<span class="hljs-title function_">version</span>();
          <span class="hljs-keyword">const</span> hashCommit = gitRevisionPlugin.<span class="hljs-title function_">commithash</span>();

          <span class="hljs-keyword">const</span> versionInfo = {
            version,
            hashcommit,
          };
          <span class="hljs-comment">// 将 version.json 文件添加到 compilation.assets 中</span>
          compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">'version.json'</span>] = {
            <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(versionInfo, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>), <span class="hljs-comment">// 文件内容</span>
            <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(versionInfo).<span class="hljs-property">length</span>,      <span class="hljs-comment">// 文件大小</span>
          };
          <span class="hljs-comment">// 确保回调函数被调用，通知 Webpack 继续处理</span>
          <span class="hljs-title function_">callback</span>();
        });
      },
    },
 ]
</code></pre>
<p>在这里要注意两点：一是apply中compiler的写法，比如在高版本中使用<code>compiler.hooks.emit</code>。emit参数的意思是生成打包文件时，当然还有其他一些周期性参数，可以查看webpack官方文档。二是js将对象versionInfo转成json文件。</p>
<p><strong>version.json文件内容</strong></p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-string">"version"</span>: <span class="hljs-string">"Afmos3.00.1-alpha-176-ge10504cc"</span>,
  <span class="hljs-string">"hashcommit"</span>: <span class="hljs-string">"e10504cc8e9dd629685713f1d2a57322ab5b48c5"</span>
}
</code></pre>
<p><strong>打包成功后截图示例</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c05f3c52f13049fa87b4e2f418741b81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgS2llcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736894499&amp;x-signature=nW0usL0R5ZnqfmcpkxNlqKVxVkY%3D" alt="1.png" loading="lazy"></p>
<p><strong>写一个mixins来监听版本文件变化</strong></p>
<p>利用vue的mixins混淆功能，创建一个自定义的<code>hashVersion.js</code></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hashVersionMixins = {
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">current_hash</span>: <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'location_hash'</span>) || <span class="hljs-string">''</span>,
      <span class="hljs-attr">new_hash</span>: <span class="hljs-string">''</span>
    }
  },
  created () {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">checkVersion</span>()
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-keyword">async</span> checkVersion () {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/version.json?date='</span> + <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_hash</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">hashcommit</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">new_hash</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">current_hash</span>) {
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'location_hash'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_hash</span>)
          <span class="hljs-variable language_">this</span>.$notify({
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Afmos系统提醒'</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">'有新版本更新啦~请刷新页面查看最新内容'</span>,
            <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>
          })
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取版本信息失败:'</span>, error)
      }
    }
  }
}

</code></pre>
<p>在这里只做了一个弹框信息提醒，当然也可以根据实际需求进行直接刷新或者定时器之后再刷新。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> { 
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>(); 
}, <span class="hljs-number">5000</span>); <span class="hljs-comment">// 5秒后自动刷新页面</span>
</code></pre>
<p><strong>在App组件中使用</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { hashVersionMixins } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/mixins/hashVersion'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
 <span class="hljs-attr">mixins</span>:[hashVersionMixins],
}
</code></pre>
<p><strong>方案一更新提醒截图</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d34a2e6176844dbacdb7a6decb0e63f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgS2llcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736894499&amp;x-signature=fBAHKCCFiOo6UUlbdK%2FNB7ujOe0%3D" alt="2.png" loading="lazy"></p>
<p><strong>优缺点：</strong></p>
<ol>
<li>全部在前端做工作量多了一些，但是对自己也是一种学习和进步。</li>
<li>后端可能需要配置静态文件指定路径，比如在python环境中指定了静态文件static,此时前端的version.json与index同级，会拿不到文件，要再次将文件移到前端的static下。或者在webpack打包配置中，直接写入到static中。</li>
<li>只更新了后端部分，前端文件不更新的话，hash值也没有改变。</li>
</ol>
<h3 data-id="heading-5">方案二：记录更新日志，通过接口返回更新版本号</h3>
<p>每个项目进行更新，都会有更新记录，比如每次更新，会把本次更新的内容记录到readme中，方便其他人员查看。在发布部署时也需要记录当前更新的内容。在这就可以做一个版本号管理和更新记录。再暴露出一个方法，进行查询记录。</p>
<p><strong>前端通过接口获取版本号</strong></p>
<pre><code class="hljs language-js" lang="js">&lt;script&gt;
<span class="hljs-keyword">import</span> { softVersion } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/request/api/information'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  data () {
      <span class="hljs-attr">version_num</span>:<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'version_num'</span>) || <span class="hljs-string">''</span>
  }
}
<span class="hljs-attr">methods</span>:{
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getVersion</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">softVersion</span>({})
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">result</span>) {
        <span class="hljs-keyword">const</span> new_version = res.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>].<span class="hljs-property">version_num</span>
        <span class="hljs-keyword">if</span> (new_version !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">version_num</span>) {
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'version_num'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_version</span>)
          <span class="hljs-variable language_">this</span>.$notify({
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Afmos系统提醒'</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">'有新版本更新啦~请刷新页面查看最新内容'</span>,
            <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>
          })
        }
        
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">msg</span>);
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>优缺点：</strong></p>
<ol>
<li>无论前后端更新都能及时的获取到更新的版本和信息</li>
<li>工作量问题，以及方案的实施需要多方人员配合。毕竟有的人呀，只要是没有领导说明和写在需求里面的，那就是不知道，不清楚，我不做，压根不会去给自己增加额外的工作量。</li>
</ol>
<h3 data-id="heading-6">方案三：比对前端打包后的index.html中js中文件名hash值</h3>
<p><strong>Webpack 配置确保生成带 hash 的文件</strong></p>
<p>确保 Webpack 配置中开启了带有内容hash值的文件名输出,这样在每次打包时，如果文件内容发生变化，生成的js文件名会带上新的hash值。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash].js'</span>, <span class="hljs-comment">// 确保文件名带有 hash</span>
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
  },
  <span class="hljs-comment">// 其他配置...</span>
};

</code></pre>
<p><strong>构建前端 hash 值提取功能</strong></p>
<p>首先，需要在打包后提取出 <code>index.html</code> 中的 JS 文件 hash 值。通常，Vue 项目通过 Webpack 打包时，生成的 JS 文件名会带有 hash 值（例如：<code>app.123abc456.js</code>）。我们可以通过正则表达式从 <code>index.html</code> 中提取这些 hash 值。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 假设是通过 AJAX 请求或 fetch 方式来获取 index.html</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">extractHashFromHtml</span>(<span class="hljs-params">htmlContent</span>) {
  <span class="hljs-keyword">const</span> scriptRegex = <span class="hljs-regexp">/&lt;script\s+[^&gt;]*src="([^"]+\.js)"/g</span>;
  <span class="hljs-keyword">const</span> hashes = [];
  <span class="hljs-keyword">let</span> match;
  <span class="hljs-keyword">while</span> ((match = scriptRegex.<span class="hljs-title function_">exec</span>(htmlContent)) !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> scriptSrc = match[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> hashMatch = scriptSrc.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(\w+)\.js$/</span>);
    <span class="hljs-keyword">if</span> (hashMatch) {
      hashes.<span class="hljs-title function_">push</span>(hashMatch[<span class="hljs-number">1</span>]);
    }
  }
  <span class="hljs-keyword">return</span> hashes;
}

</code></pre>
<p><strong>保存和比较 hash 值</strong></p>
<p>每次加载应用时，将当前页面的 hash 值与之前保存的 hash 值进行比对。如果 hash 值发生变化，则表明前端文件已更新，可以提示用户刷新页面。你可以将 hash 值存储在 <code>localStorage</code> 中。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForUpdates</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/index.html'</span>, { <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-store'</span> }) <span class="hljs-comment">// 确保获取的是最新的 index.html</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">text</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">htmlContent</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> newHashes = <span class="hljs-title function_">extractHashFromHtml</span>(htmlContent);
      <span class="hljs-keyword">const</span> oldHashes = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'appHashes'</span>)) || [];

      <span class="hljs-comment">// 比较 hash 值</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newHashes) !== <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(oldHashes)) {
        <span class="hljs-comment">// 如果有变化，提示用户</span>
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">'新版本已经发布，请刷新页面以获取最新内容！'</span>);
        <span class="hljs-comment">// 更新存储的 hash 值</span>
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'appHashes'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newHashes));
      }
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error fetching index.html:'</span>, error));
}

<span class="hljs-comment">// 页面加载时检查更新</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, checkForUpdates);

</code></pre>
<h2 data-id="heading-7">总结</h2>
<p>这里涉及到了webpack的配置和node的一些内容。webpack依赖node的环境，所以在webpcak的配置中就能使用node中自带的fs以及path，在指定的地方输出或者生成我们需要的内容信息。</p></div></div>