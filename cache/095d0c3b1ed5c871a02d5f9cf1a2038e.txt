
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18658141" title="发布于 2025-01-17 11:18">
    <span role="heading" aria-level="2">C#中如何使用异步编程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 C# 中，异步编程主要通过 <code>async</code> 和 <code>await</code> 关键字来实现。异步编程的目的是让程序在执行耗时操作（如 I/O 操作、网络请求等）时不会阻塞主线程，从而提高程序的性能。</p>
<h3 id="1-异步编程的核心概念">1. 异步编程的核心概念</h3>
<h4 id="async-关键字"><code>async</code> 关键字</h4>
<ul>
<li>用于标记一个方法为异步方法。</li>
<li>异步方法的返回类型通常是 <code>Task</code>、<code>Task&lt;T&gt;</code> 或 <code>ValueTask</code>。<br>
<code>Task</code>：表示一个没有返回值的异步操作。<br>
<code>Task&lt;T&gt;</code>：表示一个返回类型为 <code>T</code> 的异步操作。<br>
<code>ValueTask</code>：轻量版的 <code>Task</code>，适用于高性能场景。</li>
</ul>
<h4 id="await-关键字"><code>await</code> 关键字</h4>
<ul>
<li>用于暂停异步方法的执行，直到等待的任务完成。</li>
<li><code>await</code> 只能用于 <code>async</code> 方法中。</li>
<li>它不会阻塞线程，而是将控制权交回给调用方，直到任务完成后再恢复执行。</li>
</ul>
<h3 id="2-异步编程的基本语法">2. 异步编程的基本语法</h3>
<h4 id="定义异步方法">定义异步方法</h4>
<pre><code>public&nbsp;async&nbsp;Task&nbsp;GetDataAsync()
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;异步操作
&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(1000);&nbsp;//&nbsp;模拟耗时操作
}
</code></pre>
<h4 id="调用异步方法">调用异步方法</h4>
<pre><code>public&nbsp;async&nbsp;Task&nbsp;CallAsyncMethod()
{
&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;GetDataAsync();&nbsp;//&nbsp;等待异步方法完成
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("异步方法已调用.");
}
</code></pre>
<h3 id="3-异步编程的使用场景">3. 异步编程的使用场景</h3>
<h4 id="io-密集型操作">I/O 密集型操作</h4>
<ul>
<li>文件读写、数据库查询、网络请求等操作通常需要较长时间，使用异步编程可以避免阻塞主线程。</li>
</ul>
<h4 id="ui-应用程序">UI 应用程序</h4>
<ul>
<li>在桌面或移动应用程序中，保持 UI 线程的响应性极为重要。异步操作可以防止 UI 卡顿，提升用户体验。</li>
</ul>
<h4 id="web-应用程序">Web 应用程序</h4>
<ul>
<li>在 ASP.NET 等 Web 应用程序中，异步操作可以提高服务器的吞吐量，处理更多的并发请求。</li>
</ul>
<h4 id="并行任务">并行任务</h4>
<ul>
<li>当需要同时执行多个独立的任务时，可以使用异步编程来提高效率。</li>
</ul>
<h3 id="4-异步编程的示例">4. 异步编程的示例</h3>
<h4 id="1简单的异步方法">1：简单的异步方法</h4>
<pre><code>using&nbsp;System;
using&nbsp;System.Threading.Tasks;

class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;Main(string[]&nbsp;args)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("开始异步操作...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;DoSomethingAsync();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("异步操作已完成.");
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;DoSomethingAsync()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(2000);&nbsp;//&nbsp;模拟耗时操作（2秒）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("DoSomethingAsync方法异步任务已完成.");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>输出：</p>
<pre><code>开始异步操作...
DoSomethingAsync方法异步任务已完成.
异步操作已完成.
</code></pre>
<h4 id="2异步文件读写">2：异步文件读写</h4>
<pre><code>using&nbsp;System;
using&nbsp;System.IO;
using&nbsp;System.Threading.Tasks;

class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;Main(string[]&nbsp;args)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;filePath&nbsp;=&nbsp;"task-test.txt";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;content&nbsp;=&nbsp;"hello&nbsp;async";

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;异步写入文件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;WriteFileAsync(filePath,&nbsp;content);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("文件已写入");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;异步读取文件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;readContent&nbsp;=&nbsp;await&nbsp;ReadFileAsync(filePath);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("文件内容:&nbsp;"&nbsp;+&nbsp;readContent);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;WriteFileAsync(string&nbsp;filePath,&nbsp;string&nbsp;content)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;File.WriteAllTextAsync(filePath,&nbsp;content);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;ReadFileAsync(string&nbsp;filePath)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;await&nbsp;File.ReadAllTextAsync(filePath);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>输出：</p>
<pre><code>文件已写入
文件内容:&nbsp;hello&nbsp;async
</code></pre>
<h4 id="3异步网络请求">3：异步网络请求</h4>
<pre><code>using&nbsp;System;
using&nbsp;System.Net.Http;
using&nbsp;System.Threading.Tasks;

class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;Main(string[]&nbsp;args)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;url&nbsp;=&nbsp;"https://xxxxx.com";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;content&nbsp;=&nbsp;await&nbsp;DownloadContentAsync(url);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Content:&nbsp;"&nbsp;+&nbsp;content);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;DownloadContentAsync(string&nbsp;url)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;(HttpClient&nbsp;client&nbsp;=&nbsp;new&nbsp;HttpClient())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;await&nbsp;client.GetStringAsync(url);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h4 id="4并行异步任务">4：并行异步任务</h4>
<pre><code>using&nbsp;System;
using&nbsp;System.Net.Http;
using&nbsp;System.Threading.Tasks;

class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&nbsp;Main(string[]&nbsp;args)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;string&gt;&nbsp;task1&nbsp;=&nbsp;DownloadContentAsync("https://xxx.com");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;string&gt;&nbsp;task2&nbsp;=&nbsp;DownloadContentAsync("https://xxx2.com");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string[]&nbsp;results&nbsp;=&nbsp;await&nbsp;Task.WhenAll(task1,&nbsp;task2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Task&nbsp;1&nbsp;result:&nbsp;"&nbsp;+&nbsp;results[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Task&nbsp;2&nbsp;result:&nbsp;"&nbsp;+&nbsp;results[1]);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;DownloadContentAsync(string&nbsp;url)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;(HttpClient&nbsp;client&nbsp;=&nbsp;new&nbsp;HttpClient())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;await&nbsp;client.GetStringAsync(url);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3 id="5-异步编程的注意事项">5. 异步编程的注意事项</h3>
<ol>
<li>避免 <code>async void</code>：<br>
• 除了事件处理程序外，尽量避免使用 <code>async void</code> 方法，因为它无法被等待，且异常无法被捕获。</li>
<li>正确处理异常：<br>
• 使用 <code>try-catch</code> 块来捕获异步方法中的异常。</li>
</ol>

<pre><code>try
{
&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;GetDataAsync();
}
catch&nbsp;(Exception&nbsp;ex)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Error:&nbsp;"&nbsp;+&nbsp;ex.Message);
}
</code></pre>
<ol start="3">
<li>避免阻塞异步代码：<br>
• 不要使用 <code>.Result</code> 或 <code>.Wait()</code> 来阻塞异步任务，这可能导致死锁。<br>
• 始终使用 <code>await</code> 来等待异步任务。</li>
<li>性能优化：<br>
*   • 对于高性能场景，可以使用 <code>ValueTask</code> 代替 <code>Task</code>。</li>
</ol>
<h3 id="6-异步编程的好处">6. 异步编程的好处</h3>
<ol>
<li>. 提高响应性：
<ul>
<li>• 异步操作不会阻塞主线程，使得应用程序在等待耗时操作时保持响应。</li>
</ul>
</li>
<li>. 提高资源利用率：
<ul>
<li>• 异步操作可以更高效地利用系统资源，特别是在 I/O 密集型操作中。</li>
</ul>
</li>
<li>. 简化代码：
<ul>
<li>• 使用 <code>async</code> 和 <code>await</code> 可以使异步代码的结构更加清晰，易于理解和维护。</li>
</ul>
</li>
</ol>
<h3 id="总结">总结</h3>
<p>C# 中的异步编程通过 <code>async</code> 和 <code>await</code> 关键字实现，能够显著提高程序的响应性和性能。它特别适用于 I/O 密集型操作、UI 应用程序和 Web 应用程序等场景。通过合理使用异步编程，可以编写出高效、简洁且易于维护的代码。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250107184344767-318666610.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.9759504789351854" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-17 11:18">2025-01-17 11:18</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">584</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18658141" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18658141);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18658141', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18658141', title: 'C#中如何使用异步编程' })">举报</a>
</div>
        