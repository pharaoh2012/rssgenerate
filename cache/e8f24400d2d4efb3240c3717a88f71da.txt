
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yunshengbuzhichu/p/18950205" title="发布于 2025-06-26 15:36">
    <span role="heading" aria-level="2">《代码随想录》回溯问题学习总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="how-to-work-out-the-problem-of-backtracing">How to work out the problem of backtracing?</h1>
<h2 id="1-组合问题">1. 组合问题</h2>
<blockquote>
<p>回溯的本质仍然是递归<br>
考虑递归三部曲:</p>
</blockquote>
<ol>
<li>递归传递参数和返回值 backtracing() -&gt; None:</li>
<li>递归的结束条件</li>
<li>在每次递归中需要执行的逻辑</li>
</ol>
<hr>
<h3 id="11-分析回溯问题">1.1 分析回溯问题</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2630790/202506/2630790-20250626153414269-932576091.png" class="lazyload"><br>
以最简单的组合问题为例，在<strong>抽象树</strong>的每一层中是遍历每种可能取值，而在树枝（深度）中遍历则是寻找每种组合的子组合</p>
<h3 id="12-回溯问题的模版代码">1.2 回溯问题的模版代码</h3>
<p>仍然组合问题为例</p>
<pre><code class="language-python"># 组合问题
def combine(self, n: int, k: int) -&gt; list[list[int]]:
    result = []
    self.backtracing(n, k, 1, [], result)
    return result

# paragram
def backtracing(self, n, k, startindex, path: list, result: list):
    # stop condition
    if len(path) == k:
        result.append(path[:])
        return
    
    for i in range(startindex, n - (k - len(path)) + 2): # 剪枝
        path.append(i)
        self.backtracing(n, k, i+1, path, result)
        path.pop()
</code></pre>
<h3 id="13-什么时候需要startindex">1.3 什么时候需要startindex</h3>
<p>每次在集合中选取元素，可选择的范围随着选取的进行而收缩（可选取元素减少），调整可选取的范围，就是要靠<code>startindex</code></p>
<h3 id="14-在for---层遍历过程中添加额外判断逻辑">1.4 在for - 层遍历过程中添加额外判断逻辑</h3>
<p>以<code>Leetcode</code>第40题组合总和为例，需要对元素进行去重</p>
<pre><code class="language-python">    # LC.40.组合总和2
def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:
    candidates = sorted(candidates)
    temp, res = [], []

    def backtracing(startindex: int, used: list) -&gt; None:
        
        if target == sum(temp):
            res.append(temp.copy())
            return
        
        elif target &lt; sum(temp):
            return
            

        for i in range(startindex, len(candidates)):
            if i &gt; 0 and candidates[i-1] == candidates[i] and used[i-1] == False:
                continue

            temp.append(candidates[i])
            used[i] = True
            backtracing(i+1, used)
            used[i] = False
            temp.pop()
    
    backtracing(0, [False for i in range(len(candidates))])
</code></pre>
<p>在本题中，同一个解可以出现同一元素（按树枝搜索），但在解集合中不能出现相同元素，如<code>[[1,1,2],[1,2,1]]</code>是不合法的，使用<code>candidates[]</code>与<code>used[]</code>数组来控制按层搜索和按树枝搜索时出现重复元素是否可以被添加到解集合中，体现在代码中：</p>
<pre><code class="language-python">for i in range(startindex, len(candidates)):
        if i &gt; 0 and candidates[i-1] == candidates[i] and used[i-1] == False:
            continue
</code></pre>
<h2 id="2-子集问题">2. 子集问题</h2>
<h3 id="21-子集问题概述">2.1 子集问题概述</h3>
<p>子集问题和排列问题的不同之处是需要收集抽象树上的每一个节点，而非叶子节点。即每次回溯都需要判断当前节点是否是解，而非在每次回溯判断是否到达叶子节点。</p>
<h3 id="22-子集问题模版">2.2 子集问题模版</h3>
<p>以力扣第70题为例，在每次调用<code>backtracing()</code>函数后都需要收集当前节点</p>
<pre><code class="language-python">def subsets(self, nums: list[int]) -&gt; list[list[int]]:
    res, path = [], []

    # 回溯
    def backtracing(startindex: int) -&gt; None:
        # 每次调用backtracing都是在遍历该树的一个节点
        res.append(path.copy())

        if startindex == len(nums):
            return
        
        for i in range(startindex, len(nums)):
            path.append(nums[i])
            backtracing(i+1)
            path.pop()
    
    backtracing(0)
    return res
</code></pre>
<h3 id="23-子集问题去重">2.3 子集问题去重</h3>
<p>子集问题的去重同组合问题相同，但需要对集合进行排序，考虑在抽象树的每一数层上不可以使用相同元素，以力扣第90题为例，分别使用<code>used</code>标志数组和<code>set()</code>集合去重</p>
<h4 id="231-used标志数组去重">2.3.1 <code>used</code>标志数组去重</h4>
<pre><code class="language-python"># 去重问题，同一树层不能重复（不同的解集合），但在同一树枝可以重复（寻找唯一子集的过程，树的遍历深度加深）
def subsetsWithDup(self, nums: list[int]) -&gt; list[list[int]]:
    nums.sort()
    res, path = [], []


    # 回溯
    def backtracing(startindex: int, used: list[bool]) -&gt; None:
        # 每次调用backtracing都是在遍历该树的一个节点
        res.append(path.copy())

        if startindex == len(nums):
            return
        
        for i in range(startindex, len(nums)):
            # 去重
            if i &gt; 0 and nums[i-1] == nums[i] and used[i-1] is False:
                continue

            path.append(nums[i])
            used[i] = True
            backtracing(i+1, used)
            # 回溯
            used[i] = False
            path.pop()
    
    backtracing(0, [False for i in range(len(nums))])
    return res
</code></pre>
<h4 id="232-set集合去重">2.3.2 <code>set()</code>集合去重</h4>
<pre><code class="language-python">def subsetsWithDup(self, nums):
    nums.sort()  # 去重需要排序
    result = []
    self.backtracking(nums, 0, [], result)
    return result

def backtracking(self, nums, startIndex, path, result):
    result.append(path[:])
    used = set()
    for i in range(startIndex, len(nums)):
        if nums[i] in used:
            continue
        used.add(nums[i])
        path.append(nums[i])
        self.backtracking(nums, i + 1, path, result)
        path.pop()
</code></pre>
<h2 id="3-排列问题">3. 排列问题</h2>
<h3 id="31-概述">3.1 概述</h3>
<p>排列问题与组合问题的区别在于每次<code>for</code>循环遍历时不使用<code>startindex</code>来寻找下一个遍历起始位置，而是从0开始</p>
<h3 id="32-模版">3.2 模版</h3>
<pre><code class="language-python">def permute(self, nums: list[int]) -&gt; list[list[int]]:
    res, path = [], []

    def backtracing() -&gt; None:
        if len(path) is len(nums):
            res.append(path.copy())
            return
        
        for i in range(len(nums)):
            # 数字不重复
            if nums[i] in path:
                continue

            path.append(nums[i])
            backtracing()
            path.pop()

    backtracing()
    return res
</code></pre>
<h3 id="33-去重">3.3 去重</h3>
<p>去重逻辑和之前相同，但需要注意的是，在同一树枝上进行遍历时也需要去重，即使用<code>if used[i] == Fasle</code>来避免在同一树枝进行遍历时使用到相同元素如<code>nums=[1,1,2]</code>中，选取顺序：<code>nums[0], nums[1], nums[2]</code>与<code>nums[1], nums[0], nums[2]</code>会导致排列集重复</p>
<pre><code class="language-python">def permuteUnique(self, nums: list[int]) -&gt; list[list[int]]:
    nums.sort()
    res, path = [], []

    def backtracing(used: list) -&gt; None:
        if len(path) is len(nums):
            res.append(path.copy())
            return
        for i in range(len(nums)):
            if (i &gt; 0 and nums[i-1] == nums[i] and not used[i-1]):
                continue

            if used[i] == False: # 同一树枝i没使用过
                used[i] = True
                path.append(nums[i])
                backtracing(used)
                path.pop()
                used[i] = False

    backtracing([False for i in range(len(nums))])
    return res
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-26 15:36">2025-06-26 15:36</span>&nbsp;
<a href="https://www.cnblogs.com/yunshengbuzhichu">yunshenbuzhichu</a>&nbsp;
阅读(<span id="post_view_count">97</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18950205);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18950205', targetLink: 'https://www.cnblogs.com/yunshengbuzhichu/p/18950205', title: '《代码随想录》回溯问题学习总结' })">举报</a>
</div>
        