
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wephiles/p/18744989" title="发布于 2025-03-01 16:54">
    <span role="heading" aria-level="2">力扣题库第一题：两数之和</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="两数之和">两数之和</h1>
<h2 id="题目描述">题目描述</h2>
<pre><code class="language-text">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

提示：

2 &lt;= nums.length &lt;= 104
-109 &lt;= nums[i] &lt;= 109
-109 &lt;= target &lt;= 109
只会存在一个有效答案

进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？
</code></pre>
<h2 id="解题方法">解题方法</h2>
<h3 id="暴力方法---循环遍历---时间复杂度on2">暴力方法 - 循环遍历 - 时间复杂度O(n<sup>2</sup>)</h3>
<ol>
<li>
<p>思路<br>
这种方法比较简单，就是通过两层循环进行解题，在外层循环中，我们首先用target的值减去当前的元素，再在里层循环中找出和这个差值相等的元素，得到两个偏移即可。注意在循环的过程中(<code>Python</code>语言)要使用偏移，而不是直接循环元素值。</p>
</li>
<li>
<p>代码</p>
</li>
</ol>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        for i in range(len(nums)):
            minus = target - nums[i]
            for j in range(i+1, len(nums)):
                if nums[j] == minus:
                    return [i, j]
</code></pre>
<h3 id="使用哈希表---时间复杂度on">使用哈希表 - 时间复杂度O(n)</h3>
<ol>
<li>
<p>思路<br>
我们将key的值存储为nums数组中的每一个元素，将key对应的value存储为元素对应的索引，这样在便利整个nums数组的时候，如果target - 当前的元素<strong>在哈希表中</strong>，那么说明已经找到了符合题意的两个数，将偏移返回即可，如果target - 当前的元素<strong>不在哈希表中</strong>，则说明还没有找到符合题意的两个数，这时候将值和索引存入哈希表。即{值: 偏移}，这样我们既可以快速地找到满足题意的数，还能方便地找到数对应的偏移，一举两得。</p>
</li>
<li>
<p>代码</p>
</li>
</ol>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        map = {}
        for offset, num in enumerate(nums):
            if target - num in map:
                return [offset, map[target - num]]
            else:
                map[num] = offset
</code></pre>
<h2 id="总结">总结</h2>
<p>当我们做题的时候，可以先考虑使用最简单的暴力解法进行解题，然后可以思考使用高时间效率的方法，如果实在没有思路可以查看大佬的解法，这样有利于提高自己的编程能力。拜拜~</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5546887504340278" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-01 16:54">2025-03-01 16:54</span>&nbsp;
<a href="https://www.cnblogs.com/wephiles">想你时风起</a>&nbsp;
阅读(<span id="post_view_count">51</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18744989" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18744989);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18744989', targetLink: 'https://www.cnblogs.com/wephiles/p/18744989', title: '力扣题库第一题：两数之和' })">举报</a>
</div>
        