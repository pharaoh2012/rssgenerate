
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/naturl/p/18668909" title="发布于 2025-01-14 11:06">
    <span role="heading" aria-level="2">鸿蒙开发 - 自定义组件 和 组件通信的方法 （15:02 刚刚更新了动图，嘿嘿）</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="自定义组件的基本结构">自定义组件的基本结构</h2>
<pre><code class="language-typescript">@Entry
@Component
struct MyComponent {
  build(){
     // ...
  }
}
</code></pre>
<ul>
<li><strong>build()函数</strong></li>
</ul>
<p><code>build()</code>函数用于描述组件的UI界面，自定义组件必须定义build()函数</p>
<pre><code class="language-typescript">build() {
  Column() {
    Text('测试')
    Button('点击')
  }
}
</code></pre>
<ul>
<li><strong>struct 关键字</strong></li>
</ul>
<p><code>strcut</code> 用来声明数据结构 <code>struct + 自定组件名 + { ... }</code></p>
<p>当 <code>struct</code> 被 <code>@Component</code> 装饰后，必须要要有 <code>build()</code> 函数</p>
<pre><code class="language-typescript">struct MyComponent {
}
</code></pre>
<ul>
<li><strong>@Component 装饰器</strong></li>
</ul>
<p><code>@Component</code> 用来声明一个组件</p>
<ol>
<li><code>@Component</code> 和 <code>struct</code> 两者配对使用</li>
<li><code>@Component</code>只能装饰 <code>struct</code> 关键字声明的数据结构</li>
</ol>
<pre><code class="language-typescript">@Component 
struct MyComponent {
  build() {
  }
}
</code></pre>
<ul>
<li><strong>@Entry 装饰器</strong></li>
</ul>
<p>使用 <code>@Entry</code> 用于标记一个页面的入口点。当用户打开应用或导航路由的时候，展示的就是这个组件</p>
<pre><code class="language-typescript">@Entry
@Component
struct MyComponent {
  build() {
  }
}
</code></pre>
<h2 id="组件通信">组件通信</h2>
<h4 id="父子间单向传递-prop">父子间单向传递 @Prop</h4>
<p><code>@Prop</code> 单向传递数据：父组件数据变化，会通知子组件，但子组件数据变化，<strong>不会</strong>通知父组件</p>
<ol>
<li>子组件深拷贝父组件传过来的数据，父组件发生数据变更，子组件会跟着变化</li>
<li>子组件也可以自己更新数据，但不会同步父组件数据</li>
</ol>
<br>
<p>举例：父组件向子组件传递一个数据 <code>text</code>，默认值是 <code>123</code>，当点击按钮的时候，更新 <code>text</code> 的值为 <code>456</code></p>
<ul>
<li><strong>父组件</strong></li>
</ul>
<pre><code class="language-typescript">import Child from './Child'

@Entry
@Component
struct Parent {
  @State text: string = '123'

  build() {
    Column() {
      Text(`我是父组件，文本内容：${this.text}`)
      Button(`更新按钮`)
        .onClick(() =&gt; {
          this.text = '456'
        })

      Child({ text: this.text })
        .margin({top: 50})
    }
    .width('100%')
  }
}
</code></pre>
<ul>
<li><strong>子组件</strong></li>
</ul>
<p>子组件使用 <code>@Prop</code> 装饰器进行修饰变量</p>
<pre><code class="language-typescript">@Component
export default struct Child {
  @Prop text: string = ''

  build() {
    Row() {
      Text(`我是子组件，父组件传过来的内容：${this.text}`)
    }
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202501/1289125-20250114150124830-731850950.gif" alt="" loading="lazy"></p>
<p><strong style="color: rgba(255, 0, 0, 1)">需要注意的是：</strong> 当父组件发生数据变更，子组件如果想跟着改变，就需要使用 <code>@Prop</code> 声明变量 <code>@Prop text:string = ''</code>。当然如果不需要跟着改变，也可以直接这么写 <code>text:string = ''</code>，相当于将<code>text</code>的初始值传过去了，后续不会跟着变化</p>
<h4 id="父子间双向传递-link">父子间双向传递 @Link</h4>
<p><code>@Link</code> 双向传递数据：父组件发生数据变化，会通知子组件，同时子组件数据变化，也<strong>会</strong>通知父组件</p>
<br>
<p>使用 <code>@Link</code>，替换掉 <code>@Prop</code>，即 <code>@Link text:string</code></p>
<p><strong style="color: rgba(255, 0, 0, 1)">需要注意的是：</strong> 使用 <code>@Link</code> 修饰的变量，<strong>不需要进行初始化</strong>，也就是不需要附一个初始值</p>
<pre><code class="language-typescript">// 子组件

@Component
export default struct Child {
  @Link text: string

  build() {
    Column() {
      Text(`我是子组件，父组件传过来的内容：${this.text}`)

      Button('更改父组件传过来的数据')
        .onClick(() =&gt; {
          this.text = '789'
        })
    }
  }
}
</code></pre>
<p>当子组件点了更改数据的按钮，父组件也跟着发生了变化，效果如下，</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202501/1289125-20250114150125366-2110885759.gif" alt="" loading="lazy"></p>
<h4 id="子组件调用父组件的方法">子组件调用父组件的方法</h4>
<p>和传数据类似，只不过现在传递一个函数方法</p>
<ul>
<li><strong>父组件</strong></li>
</ul>
<p>父组件定义一个方法 <code>click</code>, 传给子组件</p>
<pre><code class="language-typescript">import Child from './Child'

@Entry
@Component
struct Parent {
  @State count: number = 0
  click: () =&gt; void = () =&gt; {
    this.count++
  }

  build() {
    Column() {
      Text(`我是父组件，记录点击次数：${this.count}`)

      Child({ parentClick: this.click })
    }
  }
}
</code></pre>
<ul>
<li><strong>子组件</strong></li>
</ul>
<p>子组件声明父组件传过来的 <code>parentClick</code> 函数，调用即可</p>
<pre><code class="language-typescript">@Component
export default struct Child {
  parentClick?: () =&gt; void

  build() {
    Column() {
      Button('我是子组件，点击')
        .onClick(() =&gt; {
          if (this.parentClick) {
            this.parentClick()
          }
        })
    }
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202501/1289125-20250114150126027-163506877.gif" alt="" loading="lazy"></p>
<h4 id="跨组件双向通信provide-和-consume">跨组件双向通信（@Provide 和 @Consume）</h4>
<p>使用<code>@Provide</code> 和 <code>@Consume</code> 实现跨组件通信，这种方式是双向的，不管祖先组件还是后代组件发生数据变更，另外一方都会实时变化</p>
<p>祖先组件使用 <code>@Provide</code> 注入数据</p>
<pre><code class="language-typescript">@Provide text: string = '123'
</code></pre>
<p>后代组件使用 <code>@Consume</code> 接收</p>
<pre><code class="language-typescript">@Consume text: string
</code></pre>
<p><strong style="color: rgba(255, 0, 0, 1)">注意：</strong> <code>@Consume</code> 同样不需要初始化</p>
<h4 id="eventhub-事件总线">eventHub 事件总线</h4>
<p><code>eventHub</code> 提供了事件中心，提供了监听事件和触发事件的能力，从而实现跨组件通信。（很接近vue的eventBus）</p>
<ul>
<li><strong>祖先组件</strong></li>
</ul>
<pre><code class="language-typescript">@Entry
@Component
struct Parent{
  build() {
    Column() {
      Button('发送')
        .onClick(() =&gt; {
          getContext(this).eventHub.emit('init', 2222)
        })
    }
  }
}
</code></pre>
<ul>
<li><strong>后代组件</strong></li>
</ul>
<p>后代组件中，先建立起监听事件，</p>
<pre><code class="language-typescript">@Component
export default struct Grandchild {
  @State value: number = 1

  aboutToAppear(): void {
    getContext(this).eventHub.on('init', (data: number) =&gt; {
      this.handleMessage(data)
    })
  }

  handleMessage(value: number) {
    this.value = value
  }

  build() {
    Text(`我是后代组件，接收到祖先组件发送的数据：${this.value}`)
  }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/1289125/202501/1289125-20250114150126411-358983791.gif" alt="" loading="lazy"></p>
<h5 id="方法">方法</h5>
<ul>
<li><code>on(event: string, callback: Function)</code> 监听事件</li>
<li><code>emit(event: string, ...args: Object[])</code> 触发事件</li>
<li><code>off(event: string, callback?: Function)</code> 取消订阅的指定事件
<ul>
<li>传入 callback：取消指定的 callback 对指定事件的订阅，当该事件触发后，将不会再回调该callback。</li>
<li>不传 callback：取消所有 callback 对指定事件的订阅。</li>
</ul>
</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/naturl/" target="_blank">时光凉忆</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/naturl/p/18668909" target="_blank">https://www.cnblogs.com/naturl/p/18668909</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.38539739836921294" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 15:03">2025-01-14 11:06</span>&nbsp;
<a href="https://www.cnblogs.com/naturl">时光凉忆</a>&nbsp;
阅读(<span id="post_view_count">136</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18668909" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18668909);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18668909', targetLink: 'https://www.cnblogs.com/naturl/p/18668909', title: '鸿蒙开发 - 自定义组件 和 组件通信的方法 （15:02 刚刚更新了动图，嘿嘿）' })">举报</a>
</div>
	