
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hnzhengfy/p/18984477/JMZDS_Bcrypt" title="发布于 2025-07-31 20:11">
    <span role="heading" aria-level="2">Bcrypt 简介与加密和验证示例【加密知多少系列_8】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        简单介绍下 Bcrypt 是什么，以及优势和特点，最后通过示例来演示了其简便的用法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>〇、简介</h2>
<p>Bcrypt 是一种基于 Blowfish 加密算法的单向哈希函数，<strong>专为密码存储设计</strong>。它通过<strong>随机盐值（salt）和可调节的工作因子（cost factor）</strong>实现高安全性，是目前主流的密码哈希算法之一。</p>
<p><strong>核心原理：</strong></p>
<ul>
<li><strong>随机盐值（Salt）</strong>：每次加密时生成一个<strong>随机盐值（16 字节），与密码混合后生成哈希值</strong>。确保相同密码生成不同哈希值，<strong>防止彩虹表攻击（Rainbow Table Attack）</strong>。</li>
<li><strong>可调节的工作因子（Cost Factor）</strong>：通过调整工作因子（log2：迭代次数），控制哈希计算的复杂度。<strong>范围通常为 4~31（默认 10），值越大，计算时间越长</strong>，安全性越高。计算公式：迭代次数 = 2^cost（例如 cost=12 表示 4096 次迭代）。<strong>增加了暴力破解的时间成本，适应硬件性能提升。</strong></li>
<li>基于 Blowfish 的密钥扩展：大概流程，首先将密码和盐值组合，生成 EksBlowfish 密钥（Expensive Key Schedule）。对固定字符串 "OrpheanBeholderScryDoubt" 进行多次 Blowfish 加密（根据工作因子决定迭代次数）。最终生成哈希值（60 字符的固定格式字符串）。</li>
</ul>
<p>工作因子配置和计算耗时的大概规律：<span style="font-size: 12px"><em>（注：基于博主当前机器的性能，仅供参考！）</em></span></p>
<table style="border-collapse: collapse; width: 32.5494%" border="1">
<tbody>
<tr>
<td style="width: 57.8767%; text-align: center"><strong>workFactor</strong></td>
<td style="width: 42.1258%; text-align: center"><strong>计算用时</strong></td>
</tr>
<tr>
<td style="width: 57.8767%">8</td>
<td style="width: 42.1258%">16ms</td>
</tr>
<tr>
<td style="width: 57.8767%">10（默认值，推荐）</td>
<td style="width: 42.1258%">55ms</td>
</tr>
<tr>
<td style="width: 57.8767%">12</td>
<td style="width: 42.1258%">210ms</td>
</tr>
<tr>
<td style="width: 57.8767%">14</td>
<td style="width: 42.1258%">840ms</td>
</tr>
<tr>
<td style="width: 57.8767%">16</td>
<td style="width: 42.1258%">3000ms+</td>
</tr>
</tbody>
</table>
<pre class="language-javascript highlighter-hljs"><code>// 密文的格式：
$2b$&lt;cost&gt;$&lt;salt&gt;&lt;hash&gt;
// 示例：
$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
// 各个部分的含义：
// $2b$：版本标识（2b 表示当前标准版本）。
// 10：工作因子（2^10 = 1024 次迭代）。
// N9qo8uLOickgx2ZMRZoMye：盐值（22 字符，Base64 编码）。
// IjZAgcfl7p92ldGxad68LJZdL17lhWy：哈希结果（31 字符）。</code></pre>
<p><strong>安全性：</strong></p>
<p><strong>抗彩虹表攻击。</strong>每次加密使用随机盐值，相同密码生成不同哈希值。彩虹表（预计算的哈希值表）无法直接匹配，需逐个尝试破解。<br><strong>抗暴力破解。</strong>工作因子控制计算时间（默认约 0.3 秒/次）。即使使用 GPU 并行计算，暴力破解成本极高（例如：cost=12 时，破解百万级密码需数年）。<br><strong>自适应性。</strong>随着硬件性能提升，可动态增加工作因子（如从 10 调整为 12），保持安全性。</p>
<p>与传统哈希算法的对比：</p>
<table>
<thead>
<tr>
<th data-spm-anchor-id="5176.28103460.0.i21.2f2e1db8Cka5Ja"><strong>特性</strong></th>
<th><strong>Bcrypt</strong></th>
<th><strong>MD5/SHA 系列</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>抗彩虹表攻击</strong></td>
<td>强（通过盐值和多次迭代）</td>
<td>弱（容易受彩虹表攻击）</td>
</tr>
<tr>
<td><strong>计算速度</strong></td>
<td>慢（故意设计为“慢哈希”）</td>
<td>快（适合文件校验，但不适合密码）</td>
</tr>
<tr>
<td><strong>工作因子</strong></td>
<td>支持（可调）</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>不可逆性</strong></td>
<td>是（单向哈希）</td>
<td>是（单向哈希）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>密码存储</td>
<td>文件校验、数字签名（不推荐密码）</td>
</tr>
</tbody>
</table>
<p><strong>主要应用场景：</strong></p>
<ul style="list-style-type: square">
<li><strong>用户密码存储：</strong>注册和登录时加密密码，防止数据库泄露后密码被窃取。</li>
<li><strong>企业级安全框架：</strong>Spring Security 推荐使用 BCryptPasswordEncoder，默认支持 Bcrypt。</li>
<li><strong>数据保护：</strong>对敏感信息（如 API 密钥）进行哈希处理，确保即使数据泄露也无法直接获取明文。</li>
</ul>
<h2>一、C# 语言实现</h2>
<p>先安装依赖：<code>Install-Package BCrypt.Net-Next</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202507/1868241-20250731191319074-1936154540.png" alt="image"></p>
<pre class="language-csharp highlighter-hljs"><code>using BCrypt.Net;
try
{
    string password = "MySecurePassword123";
    int workFactor = 16; // 默认值 10，取值范围 4~31
    // 加密
    string hashedPassword = BCrypt.Net.BCrypt.EnhancedHashPassword(password, workFactor);
    Console.WriteLine("Hashed Password：" + hashedPassword);
    // $2a$10$n3WUdgGrTSVEZ1L3pTxkweeHXqUaWEXwvBI.gOnkTO17eL/ZqhBaG

    // 验证
    bool isMatch = BCrypt.Net.BCrypt.EnhancedVerify(password, hashedPassword);
    Console.WriteLine("Password Match：" + (isMatch ? "匹配" : "不匹配"));
}
catch (Exception ex)
{
    Console.WriteLine("验证失败: " + ex.Message);
}
//Hashed Password：$2a$12$h8EnoQF6QYZDtbrCSGuDxeKjMt.Y0dcnWjFrz4sgEyhXlt.5VQs7G
//Password Match：匹配</code></pre>
<h2>二、js 语言实现</h2>
<p>引用第三方库 bcryptjs 实现加密和验证。安装命令：</p>
<pre class="language-csharp highlighter-hljs"><code>npm install bcryptjs</code></pre>
<p>加密和验证的简单示例代码：</p>
<pre class="language-csharp highlighter-hljs"><code>const bcrypt = require('bcryptjs');
try {
	// 要加密的密码
	const password = 'MySecurePassword123';
	// 工作因子（cost factor）：控制哈希复杂度，推荐值 10
	const saltRounds = 10;
	// 【加密】生成盐并哈希密码（异步）
	const hashedPassword = await bcrypt.hash(password, saltRounds)
	console.log('Hashed Password:', hashedPassword);

	// 【解密】
	const bcrypt = require('bcryptjs');
	// 用户输入的密码
	const inputPassword = 'MySecurePassword123';
	// 数据库中存储的哈希值
	const storedHashedPassword = '$2a$12$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy';
	// 验证密码是否匹配
	const isMatch = await bcrypt.compare(inputPassword, storedHashedPassword);
}
catch (error) {
	console.error('Error:', error);
}</code></pre>
<h2>三、go 语言实现</h2>
<p>在 Go 语言中使用 <strong>Bcrypt</strong> 进行密码哈希和验证，通常依赖官方推荐的第三方库 <code>golang.org/x/crypto/bcrypt</code>。该库提供了安全、高效的 Bcrypt 实现，适合用于密码存储和验证场景。</p>
<pre class="language-go highlighter-hljs"><code>// 安装
go get golang.org/x/crypto/bcrypt</code></pre>
<p>加密和验证简单示例：</p>
<pre class="language-csharp highlighter-hljs"><code>package main

import (
    "fmt"
    "golang.org/x/crypto/bcrypt"
)

func main() {
    // 明文密码
    password := "MySecurePassword123"
    // 【生成】哈希密码（使用默认工作因子）
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	// hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 12) // 自定义工作因子
    if err != nil {
        panic("生成哈希失败: " + err.Error())
    }
    fmt.Println("Hashed Password:", string(hashedPassword))

    // 【验证】密码是否匹配
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    if err != nil {
        fmt.Println("密码不匹配:", err)
    } else {
        fmt.Println("密码匹配")
    }
}</code></pre>
</div>
<div id="MySignature" role="contentinfo">
    <img src="https://images.cnblogs.com/cnblogs_com/blogs/683398/galleries/2417207/o_221441c4.png">
<p>本文来自博客园，作者：<a href="https://www.cnblogs.com/hnzhengfy/" target="_blank">橙子家</a>，欢迎微信扫码关注博主【橙子家czzj】，有任何疑问欢迎沟通，共同成长！</p>
<div><p style="float: left;">转载本文请注明原文链接：<a href="https://www.cnblogs.com/hnzhengfy/p/18984477/JMZDS_Bcrypt" target="_blank">https://www.cnblogs.com/hnzhengfy/p/18984477/JMZDS_Bcrypt</a></p></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-31 20:11">2025-07-31 20:11</span>&nbsp;
<a href="https://www.cnblogs.com/hnzhengfy">橙子家</a>&nbsp;
阅读(<span id="post_view_count">173</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18984477);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18984477', targetLink: 'https://www.cnblogs.com/hnzhengfy/p/18984477/JMZDS_Bcrypt', title: 'Bcrypt 简介与加密和验证示例【加密知多少系列_8】' })">举报</a>
</div>
        