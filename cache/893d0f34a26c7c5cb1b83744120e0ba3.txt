
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/blogs-for-Ruan-ji/p/18811886" title="发布于 2025-04-06 23:24">
    <span role="heading" aria-level="2">洛谷P4198 楼房重建 题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="part1自己一开始是怎么想的">Part1.自己一开始是怎么想的</h2>
<p>我一开始的想法是先考虑什么情况下是看不见的。<br>
如果是 <span class="math inline">\(i &lt; j\)</span> 的话可以直接看 <span class="math inline">\(j\)</span> 的斜率和 <span class="math inline">\(i\)</span> 的斜率就是比较 <span class="math inline">\(\frac{h_i}{i}\)</span> 的大小关系来判断。所以说我们是要单点修改一个点的斜率。我们要统计的东西很复杂，并没有想明白，然后不知道用什么来维护。</p>
<h2 id="part2正解是怎样的">Part2.正解是怎样的</h2>
<p>阅读题解可以得知一种线段树的写法。我们定义 <span class="math inline">\(len\)</span> 表示一段区间内的可见建筑的个数。</p>
<p>抽象了一下问题：整个 <span class="math inline">\(1-n\)</span> 的区间内，每一个大于上一个选了的必须选，小于等于上一个选了的必须不选，求最终的序列长度。<br>
经过观察发现区间是固定的，大区间的答案是可合并的，修改是简单的，考虑线段树维护。</p>
<p>线段树中有两个值。一个存储区间最大<span class="math inline">\(len\)</span>，一个存储的是区间内的斜率最大值<span class="math inline">\(maxx\)</span>。<br>
考虑如何修改？直接修改，<span class="math inline">\(O(logn)\)</span>。重点在于如何合并区间（pushup）。</p>
<p>现在考虑两个小区间，这两个小区间的<span class="math inline">\(len\)</span> 和 <span class="math inline">\(maxx\)</span> 是我们可以直接用的。可以发现，左区间的答案是可以直接继承的。现在我们只需要考虑右区间的答案。</p>
<p>我们是这么更新的 <code>tree[u].len=tree[ls].len+pushup2(tree[ls].maxx,rs,mid+1,rt)</code>，我们发现，确实是直接继承的左儿子的答案。右儿子的答案就是递归算的。为什么要递归算呢？因为左边的数值实际上是会对右边的答案造成影响的，所以不能直接继承答案，要一点一点算出来左边的影响。传一个数值 <span class="math inline">\(lx\)</span> 代表需要满足大于 <span class="math inline">\(lx\)</span> 才能被看见。这个时候我们看 pushup 的核心分类讨论：</p>
<ol>
<li><code>maxx&lt;=lx</code> ，结束</li>
<li><code>a[l]&gt;lx</code>，这时候可以剪枝，直接返 <span class="math inline">\(len_x\)</span></li>
<li><code>l==r</code>，<code>return a[l]&gt;lx</code></li>
<li>定义 <span class="math inline">\(s_1\)</span> 为左区间，<span class="math inline">\(s_2\)</span> 为右区间。</li>
</ol>
<ul>
<li>若 <code>s1.maxx &lt;= lx</code> , <code>return pushup(lx,s2,mid+1,r)</code></li>
<li>若 <code>s1.maxx &gt; lx</code> ,  <code>return tree[u].len-tree[ls].len+pushup(lx,s1,l,mid)</code></li>
</ul>
<p>要讲一下为什么是 <code>tree[u].len-tree[ls].len</code> 而不是 <code>tree[rs].len</code>，因为这里的更新是第一次，但是 <code>tree[u]</code> 已经完成了更新，右区间会受到左区间的影响，我们剪掉这种形式就是对的。</p>
<p>修改就是 <span class="math inline">\(O(logn^2)\)</span>的。</p>
<h2 id="part3差在哪里如何解决">Part3.差在哪里，如何解决？</h2>
<p>没有理清楚自己要干什么。没有想到这种东西是可以合并的，然后就用线段树维护。</p>
<p>解决方法：我积累到了这种思考方式和这种题目的解决办法，感觉就能够解决类似的问题。</p>
<h2 id="part4编码的困难调出来的错误">Part4.编码的困难，调出来的错误</h2>
<ol>
<li>没有</li>
<li>有小的地方打错。</li>
</ol>
<h2 id="part5收获有什么">Part5.收获有什么</h2>
<p>积累了这种类似的问题的解决方案，拿到这种修改查询的东西首先要理清楚自己要干什么，看他的等价问题是什么，然后思考是否可以合并，然后大胆假设，小心分讨！</p>
<h2 id="part6时间主要花在哪里了">Part6.时间主要花在哪里了</h2>
<p>理解正解最后的减去和递归的pushup，这种还是见少了，要见多识广才能缩短时间。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03938661439814815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-06 23:24">2025-04-06 23:24</span>&nbsp;
<a href="https://www.cnblogs.com/blogs-for-Ruan-ji">Ruan_ji</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18811886" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18811886);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18811886', targetLink: 'https://www.cnblogs.com/blogs-for-Ruan-ji/p/18811886', title: '洛谷P4198 楼房重建 题解' })">举报</a>
</div>
        