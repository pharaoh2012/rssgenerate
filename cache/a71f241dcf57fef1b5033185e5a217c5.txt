
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ishoulgodo/p/18709376" title="发布于 2025-02-11 11:04">
    <span role="heading" aria-level="2">java中反射-字节码和类加载器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1972489/202502/1972489-20250211110132478-179165835.jpg" alt="" loading="lazy"></p>
<h4 id="多态的一个表现">多态的一个表现</h4>
<p>子类类型赋值给父类  Father f1 = New Son()<br>
调用子类方法报错。 调用父类方法OK。这个就是多态</p>
<p>一个对象能用什么方法，并不是取决于 它有什么方法。<br>
而是取决于引用变量的类型(也就是取决于它声明的类型,Father类型)<br>
它能够用的方法，一定是Father中的方法。</p>
<p>通过反射来获取整体的对象。这个整体的对象我们称之为：类对象。<br>
怎么获取这个类对象呢？ 通过f1.getClass()来获取类对象</p>
<h4 id="字节码对象">字节码对象</h4>
<pre><code class="language-java">package part;

public class Java01 {
    public static void main(String[] args) {
        User u1 = new User();
        u1.test1();
        // 通过 u1.getClass() 来获取：类对象
        // Class 是java.lang包下的。所以不需要再导入了。
        // 这里的aClass对象就是java中的字节码文件
        // 所谓的字节码文件:就是我们使用javac编译后的那个源码文件
        Class&lt;? extends User&gt; aClass = u1.getClass();
    }
}

class User{
    public void test1(){
        System.out.println("test1");
    }
}

class Child extends User{
    public void test2(){
        System.out.println("test2");
    }
}
</code></pre>
<h4 id="获取类中的属性方法以及其他信息">获取类中的属性，方法以及其他信息</h4>
<pre><code class="language-java">package part;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Java01 {
    public static void main(String[] args) {
        User u1 = new User();
        // 通过 u1.getClass() 来获取：类对象
        // Class 是java.lang包下的。所以不需要再导入了。
        // 这里的aClass对象就是java中的字节码文件
        // 所谓的字节码文件:就是我们使用javac编译后的那个源码文件
        // 类对象
        Class&lt;? extends User&gt; aClass = u1.getClass();
        // 获取类的完整名称,包含包名 输出：part.User
        System.out.println(aClass.getName());
        // 获取类的名称 输出:User
        System.out.println(aClass.getSimpleName());
        // 获取类的包的信息 输出：package part
        System.out.println(aClass.getPackage());
        // 获取类的包名 输出：part
        System.out.println(aClass.getPackage().getName());


        Class&lt;?&gt; superclass = aClass.getSuperclass();
        // 获取类的父类 输出：class java.lang.Object
        System.out.println(superclass);

        // 获取类的接口，可能存在多个，因此是一个数组的哈。
        Class&lt;?&gt;[] interfaces = aClass.getInterfaces();
        // 输出0，因为我们这里没有实现接口的哈
        System.out.println(interfaces.length);

        try {
            //  获取类的属性,只能获取公共(public)的属性
            Field f1 = aClass.getField("xx");
            // 获取类的属性，所有的权限，就是你是私有的，我也可以获取
            Field f2 = aClass.getDeclaredField("aa");
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }

        // 获取类的所有属性，前提是这些属性都是public修饰的，是公共的,返回来的是数组
        Field[] fields = aClass.getFields();
        // 获取类的所有属性,就是你是私有的，我也可以获取，,返回来的是数组
        Field[] declaredFields = aClass.getDeclaredFields();

        try {
            // 获取类中的公共的方法
            Method  method= aClass.getMethod("test");
            // 获取类中的方法，就算是私有的也可以获取
            Method methods = aClass.getDeclaredMethod("test2");
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }

        // 获取类中所有公共的方法,是公共的,返回来的是数组
        Method[] methods = aClass.getMethods();
        // 获取类中的所有方法，方法就算是私有的也可以获取,返回来的是数组
        Method[] allMethods = aClass.getDeclaredMethods();

        try {
            // 构造方法  constructor 就是构造对象
            Constructor&lt;? extends User&gt; constructor = aClass.getConstructor();
            // 返回所有的构造方法
            Constructor&lt;?&gt;[] constructors = aClass.getConstructors();
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }

    }
}

class User{
    public void test1(){
        System.out.println("test1");
    }
}

class Child extends User{
    public void test2(){
        System.out.println("test2");
    }
}
</code></pre>
<h4 id="java中的类主要分为3种">java中的类主要分为3种。</h4>
<p>1.java核心类库中的类:string, Object<br>
2.JVM软件平台厂商<br>
3.我们自己写的类，比如：User,Child这些</p>
<h4 id="类加载器也有3种">类加载器也有3种</h4>
<p>JDK 9+</p>
<ol>
<li>BootClassLoader  启动类加载器，如string, Object</li>
<li>PlatformClassLoader  平台类加载器，如软件平台厂商。<br>
在jdk8及以前的话，这个平台类加载器变成了扩展类加载器Extension ClassLoader</li>
<li>AppClassLoader  应用类加载器,如我们自己写的类<br>
类加载器在加载时也是有顺序的：<br>
java核心类库中的类(string, Object)==&gt; 平台类(软件平台厂商) ==&gt;  应用类加载器(自己写的类)</li>
</ol>
<p>JDK 8 及之前是下面这3种<br>
1.启动类加载器（Bootstrap ClassLoader）<br>
2.扩展类加载器（Extension ClassLoader）,在JDK 9+中,[扩展类加载器]变成了[平台类加载器]<br>
3.应用类加载器（Application ClassLoader，也叫系统类加载器）</p>
<h4 id="得到应用类加载器">得到应用类加载器</h4>
<pre><code class="language-java">package part;

public class Java01 {
    public static void main(String[] args) {
        // 获取类的信息，以前我们是通过new的形式，现在我们取到了Student这个类的信息。
        Class&lt;Student&gt; studentClass = Student.class;
        // 获取Student这个类的加载器
        ClassLoader classLoader = studentClass.getClassLoader();
        // 输出： sun.misc.Launcher$AppClassLoader@14dad5dc
        // 得到的是：应用类加载器。为啥是应用类加载器呢？因为是我们自己写的类。所以是应用类加载器
        System.out.println(classLoader);
    }
}

class Student {

}
</code></pre>
<h4 id="string类的类加载器为啥是null">String类的类加载器为啥是null?</h4>
<pre><code class="language-java">package part;

public class Java01 {
    public static void main(String[] args) {
        Class&lt;String&gt; stringClass = String.class;
        ClassLoader classLoader = stringClass.getClassLoader();
        // 输出null
        System.out.println(classLoader);
    }
}

class Student {

}
</code></pre>
<p>有些小伙伴看到这里会觉得很奇怪,为啥是null?<br>
你不是说：string, Object  这些是启动器类吗？<br>
按理说应该是：BootClassLoader(启动类加载器)才对。<br>
因为：启动类加载器通常表示为null，因为它不是Java实现的。</p>
<h4 id="解释一下启动类">解释一下启动类</h4>
<p>启动类加载器是最顶层的，由原生代码实现，不继承java.lang.ClassLoader。<br>
启动类加载器通常表示为null，因为它不是Java实现的。</p>
<h4 id="得到平台类">得到平台类</h4>
<p>我们可以理解为：平台类是应用类加载器的上一级的加载器。也就是说有有一个上一级的概念。<br>
如果我们想要获取平台类的话。 通过自己写的类可以得到平台类。下面我们来尝试一下</p>
<pre><code class="language-java">package part;

public class Java01 {
    public static void main(String[] args) {
        // 获取类的信息，以前我们是通过new的形式，现在我们取到了Student这个类的信息。
        Class&lt;Student&gt; studentClass = Student.class;
        // 获取Student这个类的加载器
        ClassLoader classLoader = studentClass.getClassLoader();
        // 输出的是：在标准的JDK环境下（如JDK 8），输出会是:sun.misc.Launcher$ExtClassLoader@28d93b30
        // JDK 9+ 由于模块化系统的引入，类加载器名称可能变为 jdk.internal.loader.ClassLoaders$PlatformClassLoader，但逻辑一致。
        System.out.println(classLoader.getParent());
    }
}

class Student {

}
</code></pre>
<h4 id="在啰嗦说一下java的类加载器层次结构">在啰嗦说一下Java的类加载器层次结构</h4>
<p>我们回忆Java的类加载器层次结构。通常，Java的类加载器分为三个层次:<br>
启动类加载器（Bootstrap ClassLoader）、<br>
扩展类加载器（Extension ClassLoader）、(这里根据版本不同，有所变化)<br>
应用类加载器（Application ClassLoader，也叫系统类加载器）。<br>
因此，启动类加载器通常表示为null，因为它不是Java实现的。<br>
扩展类加载器负责加载JRE的扩展目录（如jre/lib/ext）中的类，而应用类加载器负责加载classpath下的类。<br>
特别提醒:应用类加载器的父加载器是扩展类加载器，而扩展类加载器的父加载器是启动类加载器。<br>
其中，启动类加载器是最顶层的，由原生代码实现，不继承java.lang.ClassLoader。</p>
<h4 id="尾声">尾声</h4>
<p>准备开始学习java了。<br>
今天学习的第10天，每天都会发文章，我要卷起来。<br>
请小伙伴们监督我，奥利给</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/ishoulgodo/" target="_blank">流年少年</a> <br>
		        出处：<a href="https://www.cnblogs.com/ishoulgodo/">https://www.cnblogs.com/ishoulgodo/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
		    </div>
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05142970521527778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 11:04">2025-02-11 11:04</span>&nbsp;
<a href="https://www.cnblogs.com/ishoulgodo">何人陪我共长生</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18709376" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18709376);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18709376', targetLink: 'https://www.cnblogs.com/ishoulgodo/p/18709376', title: 'java中反射-字节码和类加载器' })">举报</a>
</div>
        