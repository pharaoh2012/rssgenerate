
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youzhibing/p/18669400" title="发布于 2025-03-07 09:19">
    <span role="heading" aria-level="2">经由同个文件多次压缩的文件MD5都不一样问题排查，感慨AI的强大！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="开心一刻">开心一刻</h2>
<p>今天点了个外卖：牛肉炒饭<br>
外卖到了后，发现并没有牛肉，我找商家理论<br>
我：老板，这个牛肉炒饭的配菜是哪些？<br>
商家：青菜 豆芽 火腿 鸡蛋 葱花<br>
我：没有牛肉？<br>
商家：亲，没有的哦<br>
我：我点的牛肉炒饭没有牛肉，你这不是虚假宣传？<br>
商家：亲，你误会了，牛肉是我们的厨师名字！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921963-675921456.gif" alt="开心一刻"></div>
<h2 id="问题描述">问题描述</h2>
<p>先跟大家统一一个概念：<code>文件的MD5</code>，它是一种用于验证文件完整性的哈希值，<strong>一个文件的MD5值是固定的</strong>。文件的MD5值获取方式有多种，Linux 下可以通过 <code>md5sum</code> 命令获取</p>
<pre><code class="language-shell">[root@k8s-master opt]# md5sum run.sh
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113202209826-1019595320.png" alt="linux_md5"></div>
<p>Win 下则通过 <code>certutil</code> 命令获取</p>
<pre><code class="language-bat">D:\&gt;certutil -hashfile run.sh MD5
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113202210040-543071810.png" alt="win_md5"></div>
<p>各个开发语言也有对应的获取方式，例如 Java</p>
<pre><code class="language-java">/**
 * 通过 JDK 获取文件的MD5
 * @author 青石路
 */
public static String getFileMd5ByJdk(Path path) throws Exception {
    MessageDigest digest = MessageDigest.getInstance("MD5");
    try (InputStream fis = Files.newInputStream(path)) {
        byte[] byteArray = new byte[1024];
        int bytesCount = 0;
        while ((bytesCount = fis.read(byteArray)) != -1) {
            digest.update(byteArray, 0, bytesCount);
        }
    }
    byte[] bytes = digest.digest();
    StringBuilder sb = new StringBuilder();
    for (byte b : bytes) {
        sb.append(String.format("%02x", b));
    }
    return sb.toString();
}
</code></pre>
<p>但是我们通常会用第三方组件或框架来实现，例如</p>
<ol>
<li>
<p>Apache Commons Codec</p>
<pre><code class="language-java">/**
 * 通过 Apache Commons Codec 获取文件的MD5
 * @author 青石路
 */
public static String getFileMd5ByCodec(Path path) throws IOException {
    try(InputStream is = Files.newInputStream(path)) {
        return DigestUtils.md5Hex(is);
    }
}
</code></pre>
</li>
<li>
<p>Guava</p>
<pre><code class="language-java">/**
 * 通过 Guava 获取文件的MD5
 * @author 青石路
 */
public static String getFileMd5ByGuava(Path path) throws IOException {
    return com.google.common.io.Files.hash(path.toFile(), Hashing.md5()).toString();
}
</code></pre>
</li>
<li>
<p>Hutool</p>
<pre><code class="language-java">/**
 * 通过 Spring 获取文件的MD5
 * @author 青石路
 */
public static String getFileMd5BySpring(Path path) throws IOException {
    try(InputStream is = Files.newInputStream(path)) {
        return org.springframework.util.DigestUtils.md5DigestAsHex(is);
    }
}
</code></pre>
</li>
<li>
<p>Spring</p>
<pre><code class="language-java">/**
 * 通过 Hutool 获取文件的MD5
 * @author 青石路
 */
public static String getFileMd5ByHutool(Path path) throws IOException {
    try(InputStream is = Files.newInputStream(path)) {
        return DigestUtil.md5Hex(is);
    }
}
</code></pre>
</li>
</ol>
<p>这些方式获取的 MD5 值都是一致的，都是 <code>cf51e1e40cd1964827bf02916231be85</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921893-323158737.png" alt="获取MD5的方式"></div>
<p>至此，相信你们对 <code>文件的MD5</code> 都理解了；接下来回到正题，我先复现下问题，既然是压缩，那就把压缩代码整起来，基于 <code>zip4j</code> 实现 zip 压缩</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;
    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;
    &lt;version&gt;2.11.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>实现 zip 压缩</p>
<pre><code class="language-java">/**
 * zip 压缩
 * @author 青石路
 * @param destFilePath 压缩文件路径
 * @param sources 源文件列表
 * @throws IOException 压缩异常
 */
public static void compressZip(String destFilePath, List&lt;File&gt; sources) throws IOException {
    try(ZipFile zipFile = new ZipFile(destFilePath)) {
        for (File sourceFile : sources) {
            ZipParameters param = new ZipParameters();
            param.setCompressionMethod(CompressionMethod.DEFLATE);
            param.setCompressionLevel(CompressionLevel.NORMAL);
            param.setFileNameInZip(sourceFile.getName());
            try (FileInputStream is = new FileInputStream(sourceFile)) {
                zipFile.addStream(is, param);
            }
        }
    }
}
</code></pre>
</li>
</ol>
<p>代码很简单，相信你们都能看懂；照理来说，只要源文件列表（<code>sources</code>）的顺序是固定的，那么压缩之后得到的zip包文件的MD5就应该是一致的，对不对？我们来看一个案例</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    List&lt;File&gt; sources = new ArrayList&lt;&gt;();
    sources.add(new File("D:\\run.sh"));
    sources.add(new File("D:\\hello.txt"));
    String zip1 = "D:\\qsl1.zip";
    String zip2 = "D:\\qsl2.zip";
    compressZip(zip1, sources);
    TimeUnit.SECONDS.sleep(1);
    compressZip(zip2, sources);
    System.out.println("zip1 MD5:" + getFileMd5ByCodec(Paths.get(zip1)));
    System.out.println("zip2 MD5:" + getFileMd5ByCodec(Paths.get(zip2)));
}    
</code></pre>
<p>这个代码你们肯定都能看懂，但我还是要强调一下</p>
<blockquote>
<p>两次压缩间隔了 1 秒，是模拟实际项目中的两次压缩的时间间隔<br>实际项目中间隔肯定不止 1 秒，设置成 1 秒是为了达到同样效果的同时快速出结果</p>
</blockquote>
<p>执行如上代码，结果如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921832-1458453226.png" alt="压缩包MD5不一致"></div>
<p>两个压缩包的 MD5 不一致</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921823-2083644680.jpg" alt="震惊" width="200px"></div>
<p>这是为什么？</p>
<h2 id="问题排查">问题排查</h2>
<p>源文件列表 <code>sources</code> 是同一个（文件一致、顺序也一致），打包方法也是同一个（<code>compressZip</code>），为什么得到的压缩包的MD5会不一致？会不会是 <code>Codec</code> 组件（因为用的 <code>getFileMd5ByCodec</code> 方法获取的压缩包的MD5）的问题，后面切成 <code>getFileMd5ByJdk</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922236-2058104143.png" alt="JDK获取压缩包MD5不一致"></div>
<p>结果与 <code>getFileMd5ByCodec</code>  一致，这说明获取文件的MD5是没问题的；莫非是压缩包名的问题？这个我们可以反向验证下，同个文件复制一份，验证下复制文件的MD5与源文件的MD5是不是一致</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921862-2122663436.png" alt="复制MD5一致"></div>
<p>可以看到，复制文件的MD5与源文件的MD5一致，所以问题应该出在 <code>compressZip</code> 上，具体出在哪，我也没有可排查的方向了；此时，换做是你们，你们会怎么排查？现在 <code>AI</code> 这么火热，不得问问它？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922256-1005626733.png" alt="讯飞星火给出排查方向"></div>
<p><code>讯飞星火</code> 给出了 4 个方向，我们逐一分析下</p>
<ol>
<li>
<p>时间戳</p>
<p>是指 ZIP 包的创建时间和修改时间</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203845326-762431573.png" alt="压缩包时间不一致"></div>
<p>还是指 ZIP 包中文件的创建时间和修改时间</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922070-1646611597.png" alt="压缩包中文件时间不一致"></div>
<p>有待进一步分析</p>
</li>
<li>
<p>压缩算法版本</p>
<p>这个可以排除，因为用的是同个压缩打包方法：<code>compressZip</code>，并且从上图可以看出，压缩算法都是：<code>Deflate</code>，版本都是 <code>20</code></p>
</li>
<li>
<p>文件系统差异</p>
<p>这个也可以排除，都是基于 Win10 的 <code>FAT</code> 文件系统</p>
</li>
<li>
<p>随机数或唯一标识符</p>
<p>这个也可以排除，没有随机数和唯一标识</p>
</li>
</ol>
<p>所以我们需要重点分析下时间戳，时间戳又分两个方向</p>
<ol>
<li>
<p>压缩包的时间戳</p>
<p>还记得前面压缩包名的验证吗，复制文件和源文件的MD5一致，也变相验证了文件MD5不受压缩包的 <code>创建时间</code> 的影响</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922018-533425406.png" alt="压缩包创建时间不一样"></div>
<blockquote>
<p>源文件和复制文件的 <code>创建时间</code> 与 <code>访问时间</code> 不一致，但文件MD5一致，说明文件MD5与 <code>创建时间</code>、<code>访问时间</code> 无关</p>
</blockquote>
<p>所以我们只需要验证下文件MD5是不是与压缩包的 <code>修改时间</code> 有关即可；很好验证，只需要修改复制文件的修改时间，然后再比较两个文件的MD5，实例代码如下</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    /*List&lt;File&gt; sources = new ArrayList&lt;&gt;();
    sources.add(new File("D:\\run.sh"));
    sources.add(new File("D:\\hello.txt"));*/
    String zip1 = "D:\\qsl1.zip";
    String zip2 = "D:\\qsl1 - 副本.zip";
    /*compressZip(zip1, sources);
    TimeUnit.SECONDS.sleep(1);
    compressZip(zip2, sources);*/
    System.out.println("zip1 MD5:" + getFileMd5ByJdk(Paths.get(zip1)));
    File file2 = new File(zip2);
    Path path2 = file2.toPath();
    // 将副本文件的修改时间增加1分钟
    Files.setLastModifiedTime(path2, FileTime.fromMillis(file2.lastModified() + (60 * 1000)));
    System.out.println("zip2 MD5:" + getFileMd5ByJdk(path2));
}
</code></pre>
<p>执行结果如下</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922102-427006187.png" alt="压缩包修改时间不一致_MD5一致"></div>
<p>所以我们可以得出结论</p>
<blockquote>
<p>压缩文件的MD5与压缩包的 <code>修改时间</code> 无关</p>
</blockquote>
<p>那么再结合前面的 <code>创建时间</code>、<code>访问时间</code>，说明<strong>压缩包的MD5与压缩包的时间戳无关！</strong></p>
<blockquote>
<p>引申一个问题：非压缩文件MD5是否与其时间戳有关？</p>
</blockquote>
</li>
<li>
<p>压缩包中文件的时间戳</p>
<p>这个很好验证，源文件打包进压缩包的时候，保留其修改时间即可，代码如下</p>
<pre><code class="language-java">/**
 * zip 压缩
 * @author 青石路
 * @param destFilePath 压缩文件路径
 * @param sources 源文件列表
 * @throws IOException 压缩异常
 */
public static void compressZip(String destFilePath, List&lt;File&gt; sources) throws IOException {
    try(ZipFile zipFile = new ZipFile(destFilePath)) {
        for (File sourceFile : sources) {
            ZipParameters param = new ZipParameters();
            param.setCompressionMethod(CompressionMethod.DEFLATE);
            param.setCompressionLevel(CompressionLevel.NORMAL);
            param.setFileNameInZip(sourceFile.getName());
            // 保留源文件的修改时间
            param.setLastModifiedFileTime(sourceFile.lastModified());
            try (FileInputStream is = new FileInputStream(sourceFile)) {
                zipFile.addStream(is, param);
            }
        }
    }
}
</code></pre>
<p>删除旧压缩包后重新进行打包测试</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    List&lt;File&gt; sources = new ArrayList&lt;&gt;();
    sources.add(new File("D:\\run.sh"));
    sources.add(new File("D:\\hello.txt"));
    String zip1 = "D:\\qsl1.zip";
    String zip2 = "D:\\qsl2.zip";
    compressZip(zip1, sources);
    // 压缩间隔1分钟
    TimeUnit.MINUTES.sleep(1);
    compressZip(zip2, sources);
    System.out.println("zip1 MD5:" + getFileMd5ByJdk(Paths.get(zip1)));
    File file2 = new File(zip2);
    Path path2 = file2.toPath();
    System.out.println("zip2 MD5:" + getFileMd5ByJdk(path2));
}
</code></pre>
<p>执行结果如下</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921830-894458497.png" alt="两次压缩MD5一致"></div>
<p>所以我们可以得出结论</p>
<blockquote>
<p>压缩包的MD5与压缩包中文件的 <code>修改时间</code> 有关</p>
</blockquote>
<p>压缩包的MD5否与压缩包中文件的 <code>创建时间</code>、<code>访问时间</code> 有关，这个交由你们去验证了！</p>
</li>
</ol>
<h2 id="问题修复">问题修复</h2>
<p>如何修复，前面已经讲过了，就是增加一个压缩参数</p>
<blockquote>
<p>param.setLastModifiedFileTime(sourceFile.lastModified());</p>
</blockquote>
<p>保留源文件的 <code>修改时间</code> 即可；既然前面已经讲过了，为什么还要单独拿个章节来讲？仅仅只是强调下，你们要是不服，来打我呀！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922047-2098472069.gif" alt="来打我呀"></div>
<h2 id="小插曲">小插曲</h2>
<p>Win10 文件夹和文件的 <code>修改日期</code> 只显示到分钟，不显示秒</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113202210893-1971623839.png" alt="win10修改日期只显示到分钟"></div>
<p>这也导致解压工具打开压缩包的界面也只显示到分钟</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921822-360578319.png" alt="解压工具界面也只显示到分钟" width="900px"></div>
<p>这很容易让我们产生错觉</p>
<blockquote>
<p>两次压缩的修改时间（压缩包以及压缩包中的文件）为什么是一样的？<br>修改时间一致，怎么压缩包的MD5还不一致？</p>
</blockquote>
<p>然后就开始自我质疑了，到底哪个环节出了问题？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922004-1068027342.gif" alt="哪个环节出了问题"></div>
<p>如果你们看的比较细致的话，会发现我将压缩间隔时间从之前的 1 秒调整成了 1 分钟，因为我就产生了错觉，不怕你们笑话，我在这个错觉上还折腾了挺长时间！！！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922683-1872414481.gif" alt="黄渤_斗牛_害羞"></div>
<p>另外，7z工具可以查看压缩包中文件的修改时间到秒级别</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203921833-1772492368.png" alt="7z工具显示秒"></div>
<p>至于Win10，我始终没有折腾出文件夹和文件的 <code>修改日期</code> 显示到秒</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202501/747662-20250113203922172-1363899207.gif" alt="累了" width="200px"></div>
<h2 id="总结">总结</h2>
<ol>
<li>非压缩文件的MD5与文件的时间戳无关</li>
<li>压缩文件的MD5与压缩文件的时间戳无关，但与压缩包中文件的 <code>修改时间</code> 有关</li>
<li>Win10 文件夹和文件的 <code>修改日期</code> 只显示到分钟，不显示秒，不显示秒，不显示秒！！！</li>
<li>AI 的愈发成熟，带来了便利的同时也带来了挑战，工作经验的优势会越来越弱，<code>35</code> 这个坎会持续提前！！！</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2098300455763889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-07 09:20">2025-03-07 09:19</span>&nbsp;
<a href="https://www.cnblogs.com/youzhibing">青石路</a>&nbsp;
阅读(<span id="post_view_count">158</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18669400" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18669400);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18669400', targetLink: 'https://www.cnblogs.com/youzhibing/p/18669400', title: '经由同个文件多次压缩的文件MD5都不一样问题排查，感慨AI的强大！' })">举报</a>
</div>
        