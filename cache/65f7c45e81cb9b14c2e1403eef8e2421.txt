<!----> <meta itemprop="headline" content="前端哪有什么设计模式"> <meta itemprop="keywords" content="前端,设计模式,面试"> <meta itemprop="datePublished" content="2024-12-04T02:51:21.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Dignity_呱"> <meta itemprop="url" content="https://juejin.cn/user/3368559359295966"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            前端哪有什么设计模式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/3368559359295966/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Dignity_呱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-12-04T02:51:21.000Z" title="Wed Dec 04 2024 02:51:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-12-04
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    8,543
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgit-Dignity%2FvueAndTsAndKoa2" target="_blank" title="https://github.com/git-Dignity/vueAndTsAndKoa2" ref="nofollow noopener noreferrer">常网IT源码</a>上线啦！</li>
<li>本篇录入<a href="https://juejin.cn/column/7163273718213378055" target="_blank" title="https://juejin.cn/column/7163273718213378055">吊打面试官</a>专栏，希望能祝君拿下Offer一臂之力，各位看官感兴趣可移步🚶。</li>
<li>有人说面试造火箭，进去拧螺丝；其实个人觉得问的问题是项目中涉及的点 || 热门的技术栈都是很好的面试体验，不要是旁门左道冷门的知识，实际上并不会用到的。</li>
<li>接下来想分享一些自己在项目中遇到的技术选型以及问题场景。</li>
</ul>
<hr>
<blockquote>
<p>你生命的前半辈子或许属于别人，活在别人的认为里。那把后半辈子还给你自己，去追随你内在的声音。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b980a807851846b08200449c70743621~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGlnbml0eV_lkbE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1740514410&amp;x-signature=TS5RrOhMBHAMcZUpbMldkTwe3eo%3D" alt="1.jpg" loading="lazy"></p>
<h2 data-id="heading-1">一、前言</h2>
<p>之前在讨论设计模式、算法的时候，一个后端组长冷嘲热讽的说：前端哪有什么设计模式、算法，就好像只有后端语言有一样，至今还记得那不屑的眼神。</p>
<p>今天想起来，就随便列几个，给这位眼里前端无设计模式的人，睁眼看世界。</p>
<h2 data-id="heading-2">二、观察者模式 (Observer Pattern)</h2>
<p>观察者模式的核心是当数据发生变化时，自动通知并更新相关的视图。在 Vue 中，这通过其响应式系统实现。</p>
<h4 data-id="heading-3">Vue 2.x：<code>Object.defineProperty</code></h4>
<p>在 Vue 2.x 中，响应式系统是通过 <code>Object.defineProperty</code> 实现的。每当访问某个对象的属性时，<code>getter</code> 会被触发；当设置属性时，<code>setter</code> 会触发，从而实现数据更新时视图的重新渲染。</p>
<p>源码（简化版）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) {
  <span class="hljs-comment">// 创建一个 dep 实例，用于收集依赖</span>
  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();

  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">// 当访问属性时，触发 getter，并把当前 watcher 依赖收集到 dep 中</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) {
        dep.<span class="hljs-title function_">addDep</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);
      }
      <span class="hljs-keyword">return</span> val;
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-keyword">if</span> (newVal !== val) {
        val = newVal;
        dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 数据更新时，通知所有依赖重新渲染</span>
      }
    }
  });
}
</code></pre>
<ul>
<li><code>Dep</code> <strong>类</strong>：它管理依赖，<code>addDep</code> 用于添加依赖，<code>notify</code> 用于通知所有依赖更新。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = [];
  }

  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);
  }

  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> dep.<span class="hljs-title function_">update</span>());
  }
}
</code></pre>
<ul>
<li><strong>依赖收集</strong>：当 Vue 组件渲染时，会创建一个 <code>watcher</code> 对象，表示一个视图的更新需求。当视图渲染过程中访问数据时，<code>getter</code> 会触发，并将 <code>watcher</code> 添加到 <code>dep</code> 的依赖列表中。</li>
</ul>
<h4 data-id="heading-4">Vue 3.x：<code>Proxy</code></h4>
<p>Vue 3.x 使用了 <code>Proxy</code> 来替代 <code>Object.defineProperty</code>，从而实现了更高效的响应式机制，支持深度代理。</p>
<p>源码（简化版）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">const</span> handler = {
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-comment">// 依赖收集：当访问某个属性时，触发 getter，收集依赖</span>
      <span class="hljs-title function_">track</span>(target, key);
      <span class="hljs-keyword">return</span> target[key];
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {
      <span class="hljs-comment">// 数据更新时，通知相关的视图更新</span>
      target[key] = value;
      <span class="hljs-title function_">trigger</span>(target, key);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  };

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
}

</code></pre>
<ul>
<li><code>track</code>：收集依赖，确保只有相关组件更新。</li>
<li><code>trigger</code>：当数据发生变化时，通知所有依赖重新渲染。</li>
</ul>
<h2 data-id="heading-5">三、发布/订阅模式 (Publish/Subscribe Pattern)</h2>
<p>发布/订阅模式通过中央事件总线（Event Bus）实现不同组件间的解耦，Vue 2.x 中，组件间的通信就是基于这种模式实现的。</p>
<h4 data-id="heading-6">Vue 2.x：事件总线（Event Bus）</h4>
<p>事件总线就是一个中央的事件处理器，Vue 实例可以充当事件总线，用来处理不同组件之间的消息传递。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个 Vue 实例作为事件总线</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();

<span class="hljs-comment">// 组件 A 发布事件</span>
<span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">'message'</span>, <span class="hljs-string">'Hello from A'</span>);

<span class="hljs-comment">// 组件 B 订阅事件</span>
<span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg); <span class="hljs-comment">// 输出 'Hello from A'</span>
});
</code></pre>
<ul>
<li><code>$emit</code>：用于发布事件。</li>
<li><code>$on</code>：用于订阅事件。</li>
<li><code>$off</code>：用于取消订阅事件。</li>
</ul>
<h2 data-id="heading-7">四、工厂模式 (Factory Pattern)</h2>
<p>工厂模式通过一个函数生成对象或实例，Vue 的组件化机制和动态组件加载就是通过工厂模式来实现的。</p>
<p>Vue 的 <code>render</code> 函数和 <code>functional</code> 组件支持动态生成组件实例。例如，<code>functional</code> 组件本质上是一个工厂函数，通过给定的 <code>props</code> 返回一个 VNode。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'dynamic-component'</span>, {
  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h, context</span>) {
    <span class="hljs-comment">// 工厂模式：根据传入的 props 创建不同的 VNode</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(context.<span class="hljs-property">props</span>.<span class="hljs-property">type</span>);
  }
});
</code></pre>
<ul>
<li><code>functional</code> 组件：它没有实例，所有的逻辑都是在 <code>render</code> 函数中处理，返回的 VNode 就是组件的“产物”。</li>
</ul>
<h2 data-id="heading-8">五、单例模式 (Singleton Pattern)</h2>
<p>单例模式确保某个类只有一个实例，Vue 实例就是全局唯一的。</p>
<p>在 Vue 中，全局的 <code>Vue</code> 构造函数本身就是一个单例对象，通常只会创建一个 Vue 实例，用于管理应用的生命周期和全局配置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello, Vue!'</span>
  }
});
</code></pre>
<ul>
<li><strong>单例保证</strong>：整个应用只有一个 Vue 实例，所有全局的配置（如 <code>Vue.config</code>）都是共享的。</li>
</ul>
<h2 data-id="heading-9">六、模板方法模式 (Template Method Pattern)</h2>
<p>模板方法模式定义了一个操作中的算法框架，而将一些步骤延迟到子类中。Vue 的生命周期钩子就是一个模板方法模式的实现。</p>
<p>Vue 定义了一系列生命周期钩子（如 <code>created</code>、<code>mounted</code>、<code>updated</code> 等），它们实现了组件从创建到销毁的完整过程。开发者可以在这些钩子中插入自定义逻辑。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component'</span>, {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello, 泽!'</span>
    };
  },
  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Component created'</span>);
  },
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Component mounted'</span>);
  },
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{ message }}&lt;/div&gt;'</span>
});
</code></pre>
<p>Vue 组件的生命周期钩子实现了模板方法模式的核心思想，开发者可以根据需要重写生命周期钩子，而 Vue 保证生命周期的流程和框架。</p>
<h2 data-id="heading-10">七、策略模式 (Strategy Pattern)</h2>
<p>策略模式通过定义一系列算法，将它们封装起来，使它们可以相互替换。Vue 的 <strong>计算属性（computed）</strong> 和 <strong>方法（methods）</strong> 可以看作是策略模式的应用。</p>
<p>计算属性允许我们定义动态的属性，其值是基于其他属性的计算结果。Vue 会根据依赖关系缓存计算结果，只有在依赖的属性发生变化时，计算属性才会重新计算。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">num1</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">num2</span>: <span class="hljs-number">20</span>
    };
  },
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">num1</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">num2</span>;
    }
  }
});
</code></pre>
<h2 data-id="heading-11">八、装饰器模式 (Decorator Pattern)</h2>
<p>装饰器模式允许动态地给对象添加功能，而无需改变其结构。在 Vue 中，指令就是一种装饰器模式的应用，它通过指令来动态地改变元素的行为。</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;div v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">"className"</span>&gt;&lt;/div&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"isVisible"</span>&gt;</span>谁的疯太谍<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>
<p>这些指令动态地修改 DOM 元素的行为，类似于装饰器在不修改对象结构的情况下，动态地增强其功能。</p>
<h2 data-id="heading-12">九、代理模式 (Proxy Pattern)</h2>
<p>代理模式通过创建一个代理对象来控制对目标对象的访问。在 Vue 3.x 中，响应式系统就是通过 <code>Proxy</code> 来代理对象的访问。</p>
<p>vue3</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
});

state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 会触发依赖更新</span>
</code></pre>
<p>reactive：使用 Proxy 对对象进行代理，当对象的属性被访问或修改时，都会触发代理器的 get 和 set 操作。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">const</span> handler = {
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-comment">// 依赖收集：当访问某个属性时，触发 getter，收集依赖</span>
      <span class="hljs-title function_">track</span>(target, key);
      <span class="hljs-keyword">return</span> target[key];
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {
      <span class="hljs-comment">// 数据更新时，触发依赖更新</span>
      target[key] = value;
      <span class="hljs-title function_">trigger</span>(target, key);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  };

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
}
</code></pre>
<ul>
<li><code>track</code>：当读取目标对象的属性时，收集依赖，这通常涉及到将当前的 <code>watcher</code> 加入到依赖列表中。</li>
<li><code>trigger</code>：当对象的属性发生改变时，通知所有相关的依赖（如组件）更新。</li>
</ul>
<p>这个 <code>Proxy</code> 机制使得 Vue 可以动态地观察和更新对象的变化，比 <code>Object.defineProperty</code> 更具灵活性。</p>
<h2 data-id="heading-13">十、适配器模式 (Adapter Pattern)</h2>
<p>适配器模式用于将一个类的接口转换成客户端期望的另一个接口，使得原本不兼容的接口可以一起工作。Vue 的插槽（Slots）和组件的跨平台支持某种程度上借用了适配器模式的思想。</p>
<h4 data-id="heading-14">Vue 插槽机制</h4>
<p>Vue 的插槽机制是通过提供一个适配层，将父组件传入的内容插入到子组件的指定位置。开发者可以使用具名插槽、作用域插槽等方式，实现灵活的插槽传递。</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-component</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is the header<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is the default content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<p>父组件通过 <code>#header</code> 插槽插入了一个标题内容，而 <code>child-component</code> 会将其插入到适当的位置。这里，插槽充当了一个适配器，允许父组件插入的内容与子组件的内容结构灵活匹配。</p>
<p>十全十美</p>
<p>至此撒花~</p>
<h2 data-id="heading-15">后记</h2>
<p>我相信技术不分界，不深入了解，就不要轻易断言。</p>
<p>一个圆，有了一个缺口，不知道的东西就更多了。</p>
<p>但是没有缺口，不知道的东西就少了。</p>
<p>这也就是为什么，知道得越多，不知道的就越多。</p>
<p>谢谢！</p>
<p>最后，祝君能拿下满意的offer。</p>
<p>我是<a href="https://juejin.cn/user/3368559359295966/posts" target="_blank" title="https://juejin.cn/user/3368559359295966/posts">Dignity_呱</a>，来交个朋友呀，有朋自远方来，不亦乐乎呀！<a href="https://juejin.cn/pin/7168024168540143623" target="_blank" title="https://juejin.cn/pin/7168024168540143623">深夜末班车</a></p>
<blockquote>
<p>👍 如果对您有帮助，您的点赞是我前进的润滑剂。</p>
</blockquote>
<h2 data-id="heading-16">以往推荐</h2>
<p><a href="https://juejin.cn/post/7339814359886348328" target="_blank" title="https://juejin.cn/post/7339814359886348328">小小导出，我大前端足矣！</a></p>
<p><a href="https://juejin.cn/post/7165675789885636616" target="_blank" title="https://juejin.cn/post/7165675789885636616">靓仔，说一下keep-alive缓存组件后怎么更新及原理？</a></p>
<p><a href="https://juejin.cn/post/7163447762053251109" target="_blank" title="https://juejin.cn/post/7163447762053251109">面试官问我watch和computed的区别以及选择？</a></p>
<p><a href="https://juejin.cn/post/7164563220714225695" target="_blank" title="https://juejin.cn/post/7164563220714225695">面试官问我new Vue阶段做了什么？</a></p>
<p><a href="https://juejin.cn/post/7022812216848023560" target="_blank" title="https://juejin.cn/post/7022812216848023560">前端仔，快把dist部署到Nginx上</a></p>
<p><a href="https://juejin.cn/post/7010942653915201543" target="_blank" title="https://juejin.cn/post/7010942653915201543">多图详解，一次性啃懂原型链（上万字）</a></p>
<p><a href="https://juejin.cn/post/6890116253449453575" target="_blank" title="https://juejin.cn/post/6890116253449453575">Vue-Cli3搭建组件库</a></p>
<p><a href="https://juejin.cn/post/6872344841293037582" target="_blank" title="https://juejin.cn/post/6872344841293037582">Vue实现动态路由（和面试官吹项目亮点）</a></p>
<p><a href="https://juejin.cn/post/6863745313711226887" target="_blank" title="https://juejin.cn/post/6863745313711226887">项目中你不知道的Axios骚操作（手写核心原理、兼容性）</a></p>
<p><a href="https://juejin.cn/post/6854573219773415437" target="_blank" title="https://juejin.cn/post/6854573219773415437">VuePress搭建项目组件文档</a></p>
<h2 data-id="heading-17">原文链接</h2>
<p><a href="https://juejin.cn/post/7444215159289102347" target="_blank" title="https://juejin.cn/post/7444215159289102347">juejin.cn/post/744421…</a></p></div></div>