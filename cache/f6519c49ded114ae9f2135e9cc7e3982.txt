
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18722459" title="发布于 2025-02-18 17:09">
    <span role="heading" aria-level="2">多租户的 4 种常用方案！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>某中型电商平台的报表系统曾在深夜突然崩溃，起因竟是运营误删了共享表中的某租户数据列。</p>
<p>运维团队排查发现，因为缺乏有效租户隔离，一条误操作的<code>ALTER TABLE</code>语句导致全平台数据混乱。</p>
<p>这让我们警惕：<strong>选择多租户方案的每一步，都是安全与成本的权衡</strong>。</p>
<p>今天这篇文章就跟大家一起聊聊，多租户的4种常用方案，希望对你会有所帮助。</p>
<h2 id="一字段隔离方案">一、字段隔离方案</h2>
<h3 id="低成本背后的高风险">低成本背后的高风险</h3>
<p>字段隔离方案，是通过<strong>统一数据表+租户ID过滤</strong>实现逻辑隔离。</p>
<p>如下图所示：<br>
<img src="https://files.mdnice.com/user/5303/17b74e65-b1a8-4498-94d1-cc83ee9509af.png" alt="" loading="lazy"></p>
<p>初期开发成本极低，但将数据安全的压力完全转移到了代码质量控制上。</p>
<p><strong>致命缺陷检查清单</strong>：</p>
<ul>
<li>任意一次DAO层查询漏加<code>tenant_id</code>条件 → 数据跨租户泄露</li>
<li>索引必须将<code>tenant_id</code>作为最左前缀 → 性能瓶颈风险</li>
<li>全表扫描类查询（如报表统计）无法避免跨租户干扰</li>
</ul>
<h3 id="代码防御示范">代码防御示范</h3>
<p><strong>（1）MyBatis拦截器自动注入租户ID</strong></p>
<pre><code class="language-java">@Intercepts({@Signature(type = Executor.class, method = "update")})  
public class TenantInterceptor implements Interceptor {  
    public Object intercept(Invocation iv) throws SQLException {  
        MappedStatement ms = (MappedStatement) iv.getArgs()[0];  
        Object param = iv.getArgs()[1];  
        
        // 实体类自动填充tenant_id  
        if (param instanceof BaseTenantEntity) {  
            Field tenantIdField = param.getClass().getDeclaredField("tenantId");  
            tenantIdField.setAccessible(true);  
            if (tenantIdField.get(param) == null) {  
                tenantIdField.set(param, TenantContext.get());  
            }  
        }  
        return iv.proceed();  
    }  
}
</code></pre>
<p><strong>（2）SQL防火墙：强制全表扫描必须声明租户范围</strong></p>
<pre><code class="language-sql">/* 危险操作（可能扫全表） */  
SELECT * FROM orders WHERE status = 'PAID';  


/* 安全写法（强制tenant_id过滤） */  
SELECT * FROM orders   
WHERE tenant_id = 'tenant_01'  
  AND status = 'PAID'  
  /* 必须添加LIMIT防止全量拉取 */  
  LIMIT 1000;
</code></pre>
<p><strong>适用场景建议</strong></p>
<ul>
<li>初期快速验证的MVP产品，用户量比较少的业务系统。</li>
<li>对数据隔离要求较低的内部管理系统。</li>
</ul>
<p>我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，里面的技术亮点挺多的，欢迎访问和star。[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
<h2 id="二schema隔离">二、Schema隔离</h2>
<h3 id="数据库层的单元房">数据库层的单元房</h3>
<p>在同一个数据库实例中为每个租户独立Schema，实现<strong>库级别隔离</strong>。</p>
<p>如下图所示：<br>
<img src="https://files.mdnice.com/user/5303/eb2d4e27-64e2-43ac-8504-90105c80e9d3.png" alt="" loading="lazy"><br>
各租户表结构相同但数据独立，像小区里的不同住户单元。</p>
<p><strong>运维警告清单</strong>：</p>
<ul>
<li>百级Schema数量级后，备份与迁移成本陡增</li>
<li>跨Schema关联查询必须引入中间聚合层</li>
<li>数据库连接池需按最大租户数配置 → 连接风暴风险</li>
</ul>
<h3 id="动态路由代码实现">动态路由代码实现</h3>
<p><strong>（1）Spring动态数据源配置</strong></p>
<pre><code class="language-java">spring:  
  datasource:  
    dynamic:  
      primary: master  
      strict: true  
      datasource:  
        master:  
          url: jdbc:mysql://主库地址  
        tenant_001:  
          url: jdbc:mysql://从库地址?currentSchema=tenant_001  
        tenant_002:  
          url: jdbc:mysql://从库地址?currentSchema=tenant_002
</code></pre>
<p><strong>（2）AOP切面动态切换Schema</strong></p>
<pre><code class="language-java">@Aspect  
@Component  
public class SchemaAspect {  


    @Before("@annotation(requireTenant)")  
    public void switchSchema(JoinPoint joinPoint) {  
        HttpServletRequest request = getCurrentRequest();  
        String tenantId = request.getHeader("X-Tenant-ID");  
        
        // 验证租户合法性  
        if (!tenantService.isValid(tenantId)) {  
            throw new IllegalTenantException("租户身份异常！");  
        }  
        
        // 动态切换数据源  
        DynamicDataSourceContextHolder.push(tenantId);  
    }  


    @After("@annotation(requireTenant)")  
    public void clearSchema() {  
        DynamicDataSourceContextHolder.clear();  
    }  
}
</code></pre>
<p><strong>适用场景建议</strong></p>
<ul>
<li>需要中等安全级别的行业（教育、零售）。</li>
<li>租户数&lt;50且数据规模可控的系统。</li>
</ul>
<h2 id="三独立数据库">三、独立数据库</h2>
<h3 id="数据隔离的终极形态">数据隔离的终极形态</h3>
<p>每个租户享有<strong>独立数据库实例</strong>。</p>
<p>如下图所示：<br>
<img src="https://files.mdnice.com/user/5303/80b069ef-adb4-49cc-9953-8eecd330de85.png" alt="" loading="lazy"></p>
<p>从存储到底层连接完全隔离。</p>
<p>安全性最高但成本呈线性增长。</p>
<p><strong>财务预警清单</strong>：</p>
<ul>
<li>每个实例约增加￥3000/月（云RDS基础配置）</li>
<li>跨租户数据聚合需额外ETL系统支持</li>
<li>DBA运维成本随租户数量直线上升</li>
</ul>
<h3 id="数据源动态路由核心代码">数据源动态路由核心代码</h3>
<p><strong>（1）抽象路由控制器</strong></p>
<pre><code class="language-java">public class TenantDataSourceRouter extends AbstractRoutingDataSource {  


    @Override  
    protected Object determineCurrentLookupKey() {  
        return TenantContextHolder.get();  
    }  


    @Override  
    protected DataSource determineTargetDataSource() {  
        String tenantId = (String) determineCurrentLookupKey();  
        DataSource ds = dataSourceMap.get(tenantId);  
        if (ds == null) {  
            ds = createNewDataSource(tenantId);  // 动态创建新租户数据源  
            dataSourceMap.put(tenantId, ds);  
        }  
        return ds;  
    }  
}
</code></pre>
<p><strong>（2）多租户事务同步器（关键！）</strong></p>
<pre><code class="language-java">@Bean  
public PlatformTransactionManager transactionManager() {  
    return new DataSourceTransactionManager() {  
        @Override  
        protected void doBegin(Object transaction, TransactionDefinition definition) {  
            TenantDataSourceRouter router = (TenantDataSourceRouter) getDataSource();  
            router.initTenantDataSource(TenantContextHolder.get());  // 确保事务绑定正确数据源  
            super.doBegin(transaction, definition);  
        }  
    };  
}
</code></pre>
<p><strong>适用场景建议</strong></p>
<ul>
<li>金融、医疗等强合规行业</li>
<li>付费能力强且需要独立资源池的KA客户</li>
</ul>
<h2 id="四混合架构">四、混合架构</h2>
<h3 id="没有银弹的平衡术">没有银弹的平衡术</h3>
<p><strong>核心原则</strong>：按租户等级提供不同隔离方案</p>
<p>在系统中创建租户时，根据租户的实际情况，给它分配一个等级。</p>
<p>不同的等级，使用不同的隔离方案。</p>
<p>如下图所示：</p>
<table>
<thead>
<tr>
<th>租户等级</th>
<th>隔离方案</th>
<th>资源配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>S级</td>
<td>独立数据库</td>
<td>独占RDS实例+只读副本</td>
</tr>
<tr>
<td>A级</td>
<td>Schema隔离</td>
<td>共享实例独立Schema</td>
</tr>
<tr>
<td>B级</td>
<td>字段过滤</td>
<td>共享表</td>
</tr>
</tbody>
</table>
<h3 id="动态策略选择器">动态策略选择器</h3>
<p>针对不同的租户，我们可以使用策略模式，根据不同的等级，选择不同的数据库访问方式。</p>
<p>代码如下：</p>
<pre><code class="language-java">public class IsolationStrategyFactory {  


    public IsolationStrategy getStrategy(String tenantId) {  
        TenantConfig config = configService.getConfig(tenantId);  
        switch(config.getLevel()) {  
            case VIP:  
                return new IndependentDBStrategy();  
            case STANDARD:  
                return new SchemaStrategy();  
            case BASIC:  
            default:  
                return new SharedTableStrategy();  
        }  
    }  


    // 示例策略接口  
    public interface IsolationStrategy {  
        DataSource getDataSource();  
        void executeQuery(String sql);  
    }  
}
</code></pre>
<p><strong>运维避坑必读</strong></p>
<ol>
<li><strong>元数据管理</strong>：建立租户-资源映射表，避免配置漂移</li>
<li><strong>迁移工具链</strong>：开发自动化升降级工具（如VIP客户从共享表迁移到独立库）</li>
<li><strong>监控分层</strong>：不同方案的性能指标需独立采集分析</li>
</ol>
<h2 id="总结">总结</h2>
<p>这篇文章列举了多租户的4种常用方案。</p>
<p>没有最完美的，只有最合适的。</p>
<p><strong>多租户设计的本质是资源、安全、成本的黄金三角博弈</strong>。</p>
<p>与其追求理论完美，不如根据业务阶段选择最适方案。</p>
<p>毕竟能用可控成本解决问题的，才是真正的架构智慧。</p>
<p>如果看了文章有些收获，记得给我点赞喔，谢谢你的支持和鼓励。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04581881134490741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-18 17:10">2025-02-18 17:09</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18722459" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18722459);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18722459', targetLink: 'https://www.cnblogs.com/12lisu/p/18722459', title: '多租户的 4 种常用方案！' })">举报</a>
</div>
        