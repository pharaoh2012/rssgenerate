
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/graphics/p/18967447" title="发布于 2025-07-05 16:48">
    <span role="heading" aria-level="2">TypeScript结构化类型初探</span>
    

</a>

        </h2>
        <div class="postbody">
            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="啥是鸭子类型">啥是鸭子类型？</h2>
<p>作为一个前端程序员，想必大家都知道javascript是一个弱类型语言，如果需要类型的支持，那就需要借助typescript来实现，但是大家可曾听过这样一个说法？</p>
<blockquote>
<p>javascript属于鸭子类型</p>
</blockquote>
<p>当我第一次看到这个说法时，我不禁哈哈大笑，鸭子类型是啥？其实这不过是一个比喻而已，鸭子类型的意思是：</p>
<blockquote>
<p>如果一个动物看起来像鸭子，游起泳来像鸭子，叫起来也像鸭子，那么它大概率就是鸭子。</p>
</blockquote>
<h2 id="结构化类型">结构化类型</h2>
<p>TypeScript使用<code>结构化类型（Structural Typing）</code>来实现javascript中的鸭子类型，结构化类型描述的是两个类型之间的兼容性，我们看一个具体的例子，再下结论。</p>
<p>假设你正在开发一个3D图形应用程序，这个程序最基本的功能就是绘制图形，而绘制图形最基本的数据结构就是点，我们先定义一个2D点。</p>
<pre><code class="language-typescript">interface Point2D {
  x: number;
  y: number;
}
</code></pre>
<p>当然，要绘制3D图形，我们还需要一个3D点。</p>
<pre><code class="language-typescript">interface Point3D {
  x: number;
  y: number;
  z: number;
}
</code></pre>
<p>现在我们可以下结论了，<code>Point3D</code>与<code>Point2D</code>是兼容的，因为<code>Point3D</code>包含了所有<code>Point2D</code>的属性。</p>
<p>所以结构化类型的定义如下：</p>
<blockquote>
<p>如果一个类型B包含了另一个类型A的所有属性，那么这两个类型是兼容的，我们可以将类型B赋值给类型A。</p>
</blockquote>
<p>需要注意的是，这种兼容性是单向的，<code>Point3D</code>可以赋值给<code>Point2D</code>，但反之不行，因为<code>Point2D</code>缺少了<code>z</code>属性。</p>
<p>其实这不难理解，假设我们要绘制一条2D线段，需要两个点来表示这条线段的起点和终点。</p>
<pre><code class="language-typescript">function drawLine(start: Point2D, end: Point2D) {
  // 绘制线段的逻辑
}
</code></pre>
<p>那么如果我们传入的是<code>Point3D</code>类型的点，程序依然可以正常工作，因为<code>Point3D</code>包含了<code>Point2D</code>的所有属性。多出来的<code>z</code>属性直接忽略，并不影响结果。</p>
<pre><code class="language-typescript">const start: Point3D = { x: 0, y: 0, z: 0 };
const end: Point3D = { x: 1, y: 1, z: 1 };
drawLine(start, end); // 依然可以正常绘制线段
</code></pre>
<p>我们甚至不需要传递一个<code>Point3D</code>类型的点，任意一个包含<code>x</code>和<code>y</code>属性的对象都可以作为参数传递给<code>drawLine</code>函数。</p>
<pre><code class="language-typescript">const start = { x: 0, y: 0 };
const end = { x: 1, y: 1 };
drawLine(start, end); // 依然可以正常绘制线段
</code></pre>
<p>这就是结构化类型的威力，也是JavaScript的灵活性所在。</p>
<h2 id="名义类型">名义类型</h2>
<p>与结构化类型对应的是<code>名义类型（Nominal Typing）</code>，比如<code>Java</code>和<code>C#</code>这种强类型语言，使用的都是名义类型，名义类型要求类型的名称必须匹配才能兼容。也就是说，只有当两个类型的名称完全相同或者存在继承关系时，它们才被认为是兼容的。</p>
<p>对于<code>Java</code>或者<code>C#</code>这样的强类型语言来说，上面<code>drawLine</code>的例子就不成立了，因为<code>Point2D</code>和<code>Point3D</code>是两个不同的类型，即使它们有相同的属性，也不能互相替换。</p>
<pre><code class="language-java">class Point2D {
    int x;
    int y;
}

class Point3D {
    int x;
    int y;
    int z;
}

void drawLine(Point2D start, Point2D end) {
    // 绘制线段的逻辑
}

Point3D start = new Point3D(); // 定义起点
Point3D end = new Point3D(); // 定义终点
drawLine(start, end); // 编译错误，Point3D不是Point2D类型
</code></pre>
<p>基于这个原因，在强类型语言中如果要实现类型兼容性的话，只能通过继承来实现。</p>
<pre><code class="language-java">class Point2D {
    int x;
    int y;
}

class Point3D extends Point2D {
    int z;
}

void drawLine(Point2D start, Point2D end) {
    // 绘制线段的逻辑
}

Point3D start = new Point3D(); // 定义起点
Point3D end = new Point3D(); // 定义终点
drawLine(start, end); // 现在可以正常工作
</code></pre>
<p>上面的例子中，<code>Point3D</code>继承自<code>Point2D</code>，这就意味着<code>Point3D</code>是一个<code>Point2D</code>类型的对象，可以在需要<code>Point2D</code>的地方使用。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="ZddSignature">
<div>作者：<a href="http://www.cnblogs.com/graphics/" target="_blank">zdd</a></div>
<div>出处：<a href="http://www.cnblogs.com/graphics/" target="_blank">http://www.cnblogs.com/graphics/</a>
<div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-05 16:49">2025-07-05 16:48</span>&nbsp;
<a href="https://www.cnblogs.com/graphics">前端风云志</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18967447);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18967447', targetLink: 'https://www.cnblogs.com/graphics/p/18967447', title: 'TypeScript结构化类型初探' })">举报</a>

        </p>
    