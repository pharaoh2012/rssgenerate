
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18656218" title="发布于 2025-01-06 20:25">
    <span role="heading" aria-level="2">掌握设计模式--抽象工厂模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="抽象工厂模式abstract-factory-pattern">抽象工厂模式（Abstract Factory Pattern）</h2>
<p><strong>抽象工厂模式</strong>是一种创建型设计模式，它提供了一个接口，用于创建<code>一组</code>相关或依赖的对象，而无需指定具体类。它涉及到多个工厂，每个工厂负责<code>创建一类</code>相关产品的对象，确保客户端在不需要了解具体类的情况下，能够通过抽象工厂来获得所需的一系列产品。</p>
<p><strong>组成结构</strong></p>
<ul>
<li><strong>工厂</strong>：提供创建产品的接口。</li>
<li><strong>产品族</strong>：一组相关或依赖的产品。</li>
<li><strong>抽象工厂</strong>：定义创建产品的接口。</li>
<li><strong>具体工厂</strong>：实现抽象工厂接口，具体地创建产品。</li>
<li><strong>抽象产品</strong>：定义一类产品的接口。</li>
<li><strong>具体产品</strong>：实现抽象产品接口的具体类。</li>
</ul>
<p><strong>意图</strong>：用于创建一系列相关或依赖的对象家族，而无需指定具体的类。</p>
<p><strong>抽象工厂模式和工厂方法模式的区别</strong></p>
<ul>
<li><strong>工厂方法模式</strong>是抽象工厂模式的一部分，更加专注于单一产品的创建，且每个具体工厂只负责创建一个产品。</li>
<li><strong>抽象工厂模式</strong>则在工厂方法模式的基础上，扩展了创建多个相关产品的功能，并确保这些产品在同一产品族内的一致性和兼容性。</li>
</ul>
<h2 id="简单案例">简单案例</h2>
<p>假设我们需要支持两种家具风格：</p>
<ul>
<li><strong>现代风格</strong>（Modern）</li>
<li><strong>经典风格</strong>（Classic）</li>
</ul>
<p>每种风格下有不同的产品（椅子和沙发）。抽象工厂模式允许我们通过工厂方法来创建这些产品，但具体的产品实现由不同的工厂来处理。</p>
<h3 id="类图">类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106202429606-1515488250.png" alt="image" loading="lazy"></p>
<h3 id="1-定义抽象产品接口">1. 定义抽象产品接口</h3>
<p>首先，我们定义家具产品的抽象接口，如<strong>椅子</strong>和<strong>沙发</strong>。</p>
<pre><code class="language-java">// 抽象椅子
public interface Chair {
    void sitOn();
}

// 抽象沙发
public interface Sofa {
    void lieOn();
}
</code></pre>
<h3 id="2-定义具体产品">2. 定义具体产品</h3>
<p>然后我们创建具体产品，它们实现了上述接口，代表不同风格的椅子和沙发。</p>
<pre><code class="language-java">// 经典风格的椅子
public class ClassicChair implements Chair {
    @Override
    public void sitOn() {
        System.out.println("经典风格的椅子");
    }
}
// 经典风格的沙发
public class ClassicSofa implements Sofa {
    @Override
    public void lieOn() {
        System.out.println("经典风格的沙发");
    }
}

// 现代风格的椅子
public class ModernChair implements Chair {
    @Override
    public void sitOn() {
        System.out.println("现代风格的椅子");
    }
}
// 现代风格的沙发
public class ModernSofa implements Sofa {
    @Override
    public void lieOn() {
        System.out.println("现代风格的沙发");
    }
}
</code></pre>
<h3 id="3-定义抽象工厂">3. 定义抽象工厂</h3>
<p>定义一个抽象工厂，提供创建产品的方法，这些方法分别返回椅子和沙发的实例。</p>
<pre><code class="language-java">// 抽象家具工厂
public interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
}
</code></pre>
<h3 id="4-定义具体工厂">4. 定义具体工厂</h3>
<p>定义具体工厂，分别实现现代风格工厂和经典风格工厂，它们负责创建对应风格的椅子和沙发。</p>
<pre><code class="language-java">// 现代风格家具工厂
public class ModernFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ModernChair();
    }

    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
}

// 经典风格家具工厂
public class ClassicFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ClassicChair();
    }

    @Override
    public Sofa createSofa() {
        return new ClassicSofa();
    }
}
</code></pre>
<h3 id="5工厂生成器">5.工厂生成器</h3>
<p>为了更好管理系列产品和简化使用而进行的进一步封装</p>
<pre><code class="language-java">// 工厂生成器
public class FactoryGenerator {
    private Chair chair;
    private Sofa sofa;

    /**
     * 通过工厂创建家具
     * @param factory 指定生成哪一系列的家具
     */
    public FactoryGenerator(FurnitureFactory factory) {
        chair = factory.createChair();
        sofa = factory.createSofa();
    }

    public void sitOnChair() {
        chair.sitOn();
    }

    public void lieOnSofa() {
        sofa.lieOn();
    }
}
</code></pre>
<h3 id="6-测试代码">6. 测试代码</h3>
<p>客户端代码无需关心具体的家具实现，它只依赖于抽象工厂接口，通过不同的工厂来创建所需风格的家具。</p>
<pre><code class="language-java">// 测试类
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        // 创建现代风格的系列家具
        FurnitureFactory modernFactory = new ModernFurnitureFactory();
        FactoryGenerator generator = new FactoryGenerator(modernFactory);
        System.out.println("现代风格家具:");
        generator.sitOnChair();
        generator.lieOnSofa();
        System.out.println("--------------------------------------------");
        // 创建经典风格的系列家具
        FurnitureFactory classicFactory = new ClassicFurnitureFactory();
        generator = new FactoryGenerator(classicFactory);
        System.out.println("经典风格家具:");
        generator.sitOnChair();
        generator.lieOnSofa();
    }

}
</code></pre>
<p>输出结果</p>
<blockquote>
<p>现代风格家具:</p>
<p>现代风格的椅子</p>
<p>现代风格的沙发</p>
<hr>
<p>经典风格家具:</p>
<p>经典风格的椅子</p>
<p>经典风格的沙发</p>
</blockquote>
<p>客户端只需要依赖于抽象工厂接口，通过调用不同的工厂来创建所需风格的家具。无论是现代风格还是经典风格，客户端的代码都不需要知道家具的具体实现，只需要通过工厂方法来获得所需的家具产品。这种方式保证了系统的灵活性和可扩展性，你可以很容易地增加新的产品类型或新的产品风格，而不需要修改现有代码。</p>
<h2 id="抽象工厂的优缺点">抽象工厂的优缺点</h2>
<h3 id="优点">优点</h3>
<ul>
<li><strong>产品族的统一管理</strong>：可以在不修改客户端代码的情况下，轻松切换不同的产品族，例如两种产品的切换只需要更改创建时的类型即可，后面的代码无需变动。</li>
<li><strong>隔离具体类</strong>：客户端与具体类解耦，客户端只依赖抽象工厂和抽象产品接口，面向抽象编程所带来的优势。</li>
<li><strong>扩展性强</strong>：如果需要增加新的产品类型，只需要增加新的具体工厂和具体产品，而不需要修改客户端代码。</li>
<li><strong>保证产品一致性</strong>：抽象工厂确保每个产品族中的产品都兼容，避免了不兼容的产品组合。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li><strong>增加类的数量</strong>：对于每一类产品族，都需要创建一个具体工厂和多个具体产品类，这可能会导致类的数量增加。</li>
<li><strong>难以实现灵活的产品组合</strong>：如果产品之间的组合关系比较复杂，抽象工厂模式可能会显得不够灵活。</li>
</ul>
<h2 id="何时使用抽象工厂模式">何时使用抽象工厂模式</h2>
<ul>
<li>需要创建一系列相关的产品，且这些产品根据需要而有不同的实现时。</li>
<li>系统有多种不同风格的产品，但这些产品需要遵循某些共同的接口或父类。</li>
<li>需要确保产品族中的对象之间的兼容性，避免不一致的产品组合。</li>
</ul>
<h2 id="总结">总结</h2>
<p>该设计模式的特点为<strong>创建一类“产品”和切换不同的产品系列时不影响</strong>使用。</p>
<p>关于对象的具体创建逻辑可以使用<code>反射</code>、<code>动态代理</code>或者<code>结合其他创建型设计模式</code>来完成对象的实例化。引入了“中间者”和面向抽象编程使用了多态的特性，起到了解耦的作用。</p>
<p>抽象工厂模式符合以下设计原则：</p>
<ul>
<li><strong>开闭原则</strong>：通过增加新的产品族来扩展，而不修改现有代码。</li>
<li><strong>单一职责原则</strong>：每个工厂和产品只负责创建特定产品族的对象。</li>
<li><strong>依赖倒置原则</strong>：客户端依赖于抽象工厂和抽象产品接口，而不是具体实现。</li>
<li><strong>里氏替换原则</strong>：可以替换不同的具体工厂，而不影响客户端。</li>
<li><strong>接口隔离原则</strong>：每个工厂只提供它所负责的产品接口，避免客户端依赖不需要的接口。</li>
</ul>
<p>设计模式是面向对象程序设计的一种便于升级和维护的<code>软件设计思想</code>，是通过抽象和概念来描述<code>通用的解决方案</code>。</p>
<p>使用设计模式为得也是写出好的代码，<strong>好的代码我觉得是这样的</strong>：面向抽象编程可以降低对象之间的耦合度（耦合度），多态带来的灵活切换具体实现（灵活性），在新增功能时不需要修改原有代码（扩展性），每个对象只负责单一工作（高内聚、可重用）等等，这些特性使得的代码易于阅读、维护起来也会很轻松，系统在一次次的变更中依旧保持稳定。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106202453040-980309081.gif" alt="image" loading="lazy"></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485977&amp;idx=1&amp;sn=1fcbbbe778bc863c176ba1ed3088f43f&amp;chksm=ec62ca84db154392e0f7ea45ce4f332653578bb3b59dcff9bbc35a5cfba07fbbc009be57651d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow"> 什么是设计模式？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486033&amp;idx=1&amp;sn=9c2d6e06e9146e19fa6c8f2d20aaf40a&amp;chksm=ec62caccdb1543da80271cd2e558127d9880d1f5b8d5ba9d8af29c67f42e8fa9d11524212b2e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">单例模式及其思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486104&amp;idx=1&amp;sn=9bc3a4f1046186e36fd8c9cdfae41e1e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式--原型模式及其编程思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486123&amp;idx=1&amp;sn=c67702624f1a2c981cee5982de78fbf9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之生成器模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486132&amp;idx=1&amp;sn=4dde3fe1150bb631ef4f192aef92c8e1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之简单工厂模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486141&amp;idx=1&amp;sn=2b7b397561dcdd10e10bee654ce893a3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之工厂方法模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486156&amp;idx=1&amp;sn=55c63308fcb556cab798bee956d34798&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式--装饰模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/RjrGK1ipkk9KE2eoHzyThQ" target="_blank" rel="noopener nofollow">掌握设计模式--组合模式</a></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7468520237997686" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 20:26">2025-01-06 20:25</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">59</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656218" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656218);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656218', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18656218', title: '掌握设计模式--抽象工厂模式' })">举报</a>
</div>
        