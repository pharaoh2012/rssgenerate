<!----> <meta itemprop="headline" content="现在公司的AI部门的前端面试这么离谱吗？"> <meta itemprop="keywords" content="前端,人工智能,GitHub"> <meta itemprop="datePublished" content="2025-05-10T03:48:07.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="草东没有派对吗"> <meta itemprop="url" content="https://juejin.cn/user/2335804829209150"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            现在公司的AI部门的前端面试这么离谱吗？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2335804829209150/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    草东没有派对吗
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-05-10T03:48:07.000Z" title="Sat May 10 2025 03:48:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-05-10
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    30,118
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p><strong>笔者刷某平台看到一个前端面经</strong>，发现大厂 Ai部门的前端面试有点离谱的存在了，从前端追问到transform...</p>
<p><strong>具体面经图片</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/298e07d89a2b46d883ced0f002e31591~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5Lic5rKh5pyJ5rS-5a-55ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1751234297&amp;x-signature=%2Baw6TgCGiLiUnr9vZLs1TXEfVAM%3D" alt="image.png" loading="lazy"></p>
<p>transform在本文就不讨论了，这个<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Ftardis%2Fzm%2Fart%2F600773858" target="_blank" title="https://www.zhihu.com/tardis/zm/art/600773858" ref="nofollow noopener noreferrer">图解</a>非常生动形象。<strong>笔者因为是在公司做LLM前端应用的，本文先围绕 SSE落地的方案做解答，后续还会更新。</strong></p>
<hr>
<p>后续已更新面经解析2： <a href="https://juejin.cn/post/7504714890361421833" target="_blank" title="https://juejin.cn/post/7504714890361421833">fetch的类库源码解析</a></p>
<h2 data-id="heading-1">LLM前端应用技术选型</h2>
<ol>
<li>
<p><strong>工程开发</strong>：</p>
<ul>
<li><strong>服务端</strong>：主要负责持续接收相关内容，并将其发送至前端。</li>
<li><strong>前端</strong>：则持续接收来自服务端的内容，并进行渲染展示。</li>
</ul>
</li>
<li>
<p><strong>持续性接收的实现方案</strong>：</p>
<p>内容呈现为一段一段地输出文本，在 HTTP 范式下，存在两种常见方案，即 Server - Sent Events（服务器发送事件 ）和 Websocket。</p>
</li>
</ol>
<h2 data-id="heading-2">SSE接入的具体落地有几种方案</h2>
<h3 data-id="heading-3">1. EventSource 实现接入</h3>
<p>EventSource 是一个 <code>Web API</code>，<strong>是浏览器提供的原生对象，专门用于处理 SSE</strong>。使用简单，对 SSE 协议有良好的支持，自动处理连接的保持、重连等机制。</p>
<p>EventSource 基于 HTTP 协议实现，通过与服务器建立一个持续连接，实现了服务器向客户端推送事件数据的功能。</p>
<p>在客户端，EventSource 对象通过一个 URL 发起与服务器的连接。连接成功后，服务器可以向客户端发送事件数据。在客户端，通过 EventSource 对象注册事件处理函数，以接收来自服务器的事件数据。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">'http://localhost:3000'</span>);

eventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到消息:'</span>, event.<span class="hljs-property">data</span>);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'messages'</span>).<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">${event.data}</span>&lt;/p&gt;`</span>;
});

eventSource.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'连接已打开'</span>);
eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'连接中断，将自动重连'</span>);
};
</code></pre>
<p>EventSource API 是用于服务器发送事件（SSE）的客户端接口。<strong>它不支持发起</strong> <code>POST</code> <strong>请求</strong>。如果需要发送数据到服务器以便它能够推送事件给客户端，应该使用标准的 AJAX 请求（例如使用 Fetch API、XMLHttpRequest API）或者WebSocket。</p>
<h3 data-id="heading-4">2. XMLHttpRequest 实现接入</h3>
<p>虽然 XMLHttpRequest 对象通常用于发送 HTTP 请求并接收响应，但它并<strong>不是专门设计</strong>用来处理 Server-Sent Events (SSE) 的。SSE 是一种基于 HTTP 的实时推送技术，可以使用 XMLHttpRequest 来模拟 SSE 的行为。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startSSE</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 创建 XMLHttpRequest 对象</span>
  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();

  <span class="hljs-comment">// 配置请求</span>
  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:3000/sse'</span>, <span class="hljs-literal">true</span>);
  xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);

  <span class="hljs-comment">// 发送请求数据（可以发送一些初始数据）</span>
  <span class="hljs-keyword">const</span> requestData = { <span class="hljs-attr">clientId</span>: <span class="hljs-string">'12345'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello, server!'</span> };
  xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData));

  <span class="hljs-comment">// 监听服务器推送的数据</span>
  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property">LOADING</span>) {
      <span class="hljs-comment">// 处理流式数据</span>
      <span class="hljs-keyword">const</span> responseText = xhr.<span class="hljs-property">responseText</span>;
      <span class="hljs-keyword">const</span> messages = responseText.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n\n'</span>); <span class="hljs-comment">// SSE 数据以两个换行符分隔</span>
      messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (message.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'data:'</span>)) {
          <span class="hljs-keyword">const</span> data = message.<span class="hljs-title function_">slice</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">trim</span>(); <span class="hljs-comment">// 去掉 "data:" 前缀</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received:'</span>, data);
        }
      });
    }
  };

  <span class="hljs-comment">// 监听错误</span>
  xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error occurred during SSE connection'</span>);
  };

  <span class="hljs-comment">// 监听连接关闭</span>
  xhr.<span class="hljs-property">onloadend</span> = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'SSE connection closed'</span>);
  };
}

<span class="hljs-comment">// 启动 SSE</span>
<span class="hljs-title function_">startSSE</span>();
</code></pre>
<h3 data-id="heading-5">3. Fetch 实现接入</h3>
<p><code>Fetch</code>与<code>XMLHttpRequest</code>实现同理，来模拟 SSE 的行为。</p>
<p>下面是简单的demo：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">downloadFile</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://example.com/large-file'</span>);
        <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
        <span class="hljs-keyword">let</span> receivedLength = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> totalLength = response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'content - length'</span>);

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
            <span class="hljs-keyword">if</span> (done) {
                <span class="hljs-keyword">break</span>;
            }
            receivedLength += value.<span class="hljs-property">length</span>;
            <span class="hljs-keyword">const</span> progress = (receivedLength / totalLength * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Download progress: <span class="hljs-subst">${progress}</span>%`</span>);
        }
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error);
    }
}
</code></pre>
<h3 data-id="heading-6">最终方案</h3>
<p>由于需要进行post请求，而没有基于XMLHttpRequest封装的类库，于是使用基于fetch封装的类库，微软开源的 <strong>@microsoft/fetch-event-source</strong>请求库，该库基于<code>fetch</code>进行了封装。在此基础上，我对其进行了二次封装，主要目的是增强请求的可控性，并提升错误处理的健壮性。具体封装功能如下：</p>
<ol>
<li>
<p><strong>请求取消机制</strong>：实现了对请求的主动取消功能，确保在需要时能够及时中断请求，避免不必要的资源消耗。</p>
</li>
<li>
<p><strong>错误捕获与处理</strong>：对各类错误进行了统一的捕获与处理，涵盖以下场景：</p>
<ul>
<li><strong>网络错误</strong>：当网络连接异常或请求无法发送时，捕获并处理相关错误。</li>
<li><strong>服务器错误</strong>：针对服务器返回的5xx或4xx状态码进行错误处理。</li>
<li><strong>网络连接错误</strong>：在网络连接中断或请求超时时，进行相应的错误捕获。</li>
<li><strong>流式接口超时错误</strong>：在请求流式数据的过程中，若出现超时情况，能够及时捕获并处理。</li>
<li><strong>JSON解析错误</strong>：对返回的数据进行JSON解析时，若解析失败，能够捕获并处理异常。</li>
</ul>
</li>
</ol>
<p>通过上述封装，显著提升了请求的可靠性与稳定性，确保在各种异常情况下能够进行有效的错误处理与恢复。</p>
<p>安装：</p>
<pre><code class="hljs language-cmd" lang="cmd">npm i --save @lesliechueng/stream-fetch-manage
</code></pre>
<p>使用示例：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StreamFetchClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@lesliechueng/stream-fetch-manage'</span>

<span class="hljs-keyword">const</span> streamFetchApp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamFetchClient</span>(
  {
    <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
    },
    <span class="hljs-attr">overErrorTimer</span>: <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 流式中间超时时间，单位为毫秒</span>
  },
  {
    <span class="hljs-attr">onMessage</span>: <span class="hljs-function">(<span class="hljs-params">_data</span>) =&gt;</span> {
      <span class="hljs-comment">// 处理流式消息</span>
    },
    <span class="hljs-attr">onClose</span>: <span class="hljs-function">(<span class="hljs-params">_lastData: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 处理关闭时的回调</span>
    },
    <span class="hljs-attr">onServerError</span>: <span class="hljs-function">(<span class="hljs-params">_lastData: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 处理服务器错误时的回调</span>
    },
    <span class="hljs-attr">onStreamConnectionError</span>: <span class="hljs-function">(<span class="hljs-params">_lastData: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 处理流式中间超时错误时的回调</span>
    },
    <span class="hljs-attr">onConnectionError</span>: <span class="hljs-function">(<span class="hljs-params">_lastData: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 处理连接错误时的回调</span>
    },
    <span class="hljs-attr">onParseError</span>: <span class="hljs-function">(<span class="hljs-params">_lastData: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 处理 JSON解析错误时的回调</span>
    },
  }
);
<span class="hljs-comment">// 开始发起请求，下面是具体的参数</span>
streamFetchApp.<span class="hljs-title function_">sendStreamRequest</span>({
  <span class="hljs-comment">// 流式中间请求参数</span>
});

<span class="hljs-comment">// 暂停请求</span>
<span class="hljs-comment">// streamFetchApp.disconnect();</span>
</code></pre>
<ul>
<li>解决网络抖动问题：通过在请求中设置缓存时间和 data个数。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StreamFetchClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@lesliechueng/stream-fetch-manage'</span>

<span class="hljs-keyword">const</span> streamFetchApp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamFetchClient</span>(
  {
    <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
    },
    <span class="hljs-attr">overErrorTimer</span>: <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 流式中间超时时间，单位为毫秒</span>
  },
  {
    <span class="hljs-attr">onMessage</span>: <span class="hljs-function">(<span class="hljs-params">_data</span>) =&gt;</span> {
      <span class="hljs-comment">// 调用消息处理器处理消息</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_data);
    },
    <span class="hljs-attr">onClose</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 处理关闭时的回调</span>
    },
    <span class="hljs-attr">onServerError</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 处理服务器错误时的回调</span>
    },
    <span class="hljs-attr">onStreamConnectionError</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 处理流式中间超时错误时的回调</span>
    },
    <span class="hljs-attr">onConnectionError</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 处理连接错误时的回调</span>
    },
    <span class="hljs-attr">onParseError</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 处理 JSON解析错误时的回调</span>
    },
  },
  {
    <span class="hljs-attr">maxCacheSize</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 最大缓存大小，单位为条</span>
    <span class="hljs-attr">cacheTimeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 缓存超时时间，单位为毫秒</span>
    <span class="hljs-attr">expectedSeq</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 期望的消息索引值</span>
    <span class="hljs-attr">handleValidateMessageFormat</span>: <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 校验消息格式的回调</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data.<span class="hljs-property">seq</span> !== <span class="hljs-string">"number"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Message must have a numeric seq field"</span>);
      }
    },
    <span class="hljs-attr">getIndexValue</span>: <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> data.<span class="hljs-property">seq</span>, <span class="hljs-comment">// 使得消息处理器获取消息索引值</span>
  }
);

<span class="hljs-comment">// 开始发起请求，下面是具体的参数</span>
streamFetchApp1.<span class="hljs-title function_">sendStreamRequest</span>({
  <span class="hljs-comment">// 流式中间请求参数</span>
});
</code></pre>
<p>源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FleslieCHUENGT%2FstreamFetchManage" target="_blank" title="https://github.com/leslieCHUENGT/streamFetchManage" ref="nofollow noopener noreferrer">github.com/leslieCHUEN…</a></p></div></div>