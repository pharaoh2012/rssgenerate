
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18806970" title="发布于 2025-04-07 08:17">
    <span role="heading" aria-level="2">学了设计模式，却不知道怎么选择？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本人主要讲述设计模式怎么去选择，这仅仅是不知从何下手提供一个抓手的东西，并不是银弹。常想、多用，积累经验后，方可灵活运用，做到无模式胜有模式，才可能会在复杂场景中，设计出高质量的系统。</p>
<p>设计模式的选择是一个从<strong>问题</strong>到解决方案的递进过程。通过明确问题类型、分析目标特性、遵循设计原则以及结合场景需求，可以高效地筛选出最佳设计模式，从而达到优化系统设计，提升代码质量和可维护性。设计模式不仅是一种工具，更是一种面向对象程序设计的思维方式，能帮助开发者构建更加稳定和易于维护的软件系统。</p>
<p>这篇文章花了挺多时间去整理的，还请耐心看完。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250402232857518-123633937.jpg" alt="image" loading="lazy"></p>
<p>先说整体上，怎么考虑，怎么选择。</p>
<h2 id="1设计模式选择的综合指南">1.设计模式选择的综合指南</h2>
<h3 id="11-核心决策框架">1.1. 核心决策框架</h3>
<ol>
<li><strong>问题驱动分类法</strong></li>
</ol>
<p>将系统问题归类为三大场景，形成决策起点：</p>
<ul>
<li><strong>创建型问题</strong>：对象如何诞生？（如电商购物车实例的全局唯一性 → <strong>单例模式</strong>）</li>
<li><strong>结构型问题</strong>：对象如何组织？（如动态扩展订单附加服务 → <strong>装饰者模式</strong>）</li>
<li><strong>行为型问题</strong>：对象如何协作？（如用户操作触发多模块联动 → <strong>观察者模式</strong>）</li>
</ul>
<ol start="2">
<li><strong>原则约束检查表</strong><br>
选择模式时需通过设计原则验证：</li>
</ol>
<ul>
<li><strong>单一职责</strong>：该模式是否让每个类/模块更专注？（如状态模式分离状态逻辑与主业务）</li>
<li><strong>开闭原则</strong>：新增功能是否无需修改既有代码？（如装饰者模式叠加功能不破坏原有结构）</li>
<li><strong>依赖倒置</strong>：是否通过接口而非具体实现交互？（如抽象工厂模式隔离具体产品类）</li>
<li><strong>里氏替换原则</strong>：具体实现类的切换是否影响程序正常使用？（如策略模式支持动态切换具体实现类）</li>
</ul>
<h3 id="12-模式选择进阶策略">1.2. 模式选择进阶策略</h3>
<ol>
<li><strong>模式组合技</strong></li>
</ol>
<ul>
<li><strong>动态创建+行为扩展</strong>：工厂方法+策略模式<br>
（示例：支付系统中，工厂创建支付处理器，策略模式切换算法）</li>
<li><strong>状态管理+消息通知</strong>：状态模式+观察者模式<br>
（示例：订单状态变更时，自动触发库存更新和用户通知）</li>
</ul>
<ol start="2">
<li><strong>反模式预警</strong></li>
</ol>
<p>强调设计模式中设计思想的运用</p>
<table>
<thead>
<tr>
<th><strong>陷阱</strong></th>
<th><strong>后果</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>单例滥用</td>
<td>测试困难、隐藏依赖</td>
<td>依赖注入+工厂模式（如Spring框架）</td>
</tr>
<tr>
<td>过度装饰者嵌套</td>
<td>调试链路复杂</td>
<td>合理控制层级，结合组合模式</td>
</tr>
<tr>
<td>观察者内存泄漏</td>
<td>未及时取消订阅</td>
<td>弱引用+生命周期管理</td>
</tr>
</tbody>
</table>
<ol start="3">
<li><strong>性能权衡指南</strong></li>
</ol>
<ul>
<li><strong>空间换时间</strong>：享元模式共享对象减少内存重复--如游戏中的树木渲染共享纹理</li>
<li><strong>时间换灵活</strong>：代理模式增加间接层带来性能损耗--需评估延迟是否在可接受范围</li>
<li><strong>模式轻量化</strong>：函数式替代方案--如Lambda替代策略模式接口</li>
</ul>
<h2 id="2-设计模式决策树23种">2. 设计模式决策树（23种）</h2>
<p>细致到每个设计模式的特点，通过问题类型和场景特征，逐步定位适合的设计模式：</p>
<h3 id="21-第一步确定核心问题类型">2.1. 第一步：确定核心问题类型</h3>
<p>这个前面也已经提到过的了。</p>
<ol>
<li>是否需要创建/管理对象？→ 创建型模式（6种）</li>
<li>是否需要组织对象结构？ → 结构型模式（7种）</li>
<li>是否需要定义对象间协作？→ 行为型模式（11种）</li>
</ol>
<h3 id="22-第二步细化选择路径">2.2. 第二步：细化选择路径</h3>
<h4 id="1-创建型模式5种">1. 创建型模式（5种）</h4>
<p><strong>问题：如何高效、灵活地创建对象？</strong></p>
<pre><code class="language-plaintext">是否需要控制对象实例数量和提供全局访问点？
├─ 是 → 单例模式（Singleton）
└─ 否 → 
   是否需要分步构造复杂对象？
   ├─ 是 → 建造者模式（Builder）
   └─ 否 → 
      是否通过克隆快速创建对象（避免高成本构造）？
      ├─ 是 → 原型模式（Prototype）
      └─ 否 → 
         是否需要在不暴露具体类的前提下，动态选择实例化的类？
         ├─ 是 → 工厂方法模式（Factory Method）
         └─ 否 →
            是否需要创建一组相关对象，并确保它们协同工作？
            ├─ 是 → 抽象工厂模式（Abstract Factory）
            └─ 否 → 简单工厂 或 直接创建
</code></pre>
<h4 id="2-结构型模式7种">2. 结构型模式（7种）</h4>
<p><strong>问题：如何优化对象之间的组合与关系？</strong></p>
<pre><code class="language-plaintext">是否需要扩展对象功能且不影响现有代码？
├─ 是 → 
   │ 是否需动态叠加功能？
   │ ├─ 是 → 装饰者模式（Decorator）
   │ └─ 否 → 适配器模式（Adapter）
└─ 否 → 
   是否需要简化复杂子系统？
   ├─ 是 → 外观模式（Facade）
   └─ 否 → 
      是否需要解耦抽象与实现，以支持独立变化？
      ├─ 是 → 桥接模式（Bridge）
      └─ 否 → 
         是否需要共享大量对象以减少内存资源？
         ├─ 是 → 享元模式（Flyweight）
         └─ 否 → 
            是否需要组合对象为树形结构（“部分-整体”的层次关系）？
            ├─ 是 → 组合模式（Composite）
            └─ 否 → 
               是否需要代理控制访问或优化性能？
               ├─ 是 → 代理模式（Proxy）
               └─ 否 → 
</code></pre>
<h4 id="3-行为型模式11种">3. 行为型模式（11种）</h4>
<p><strong>问题：如何管理对象间的协作与责任分配？</strong></p>
<pre><code class="language-plaintext">是否需要动态切换一组算法？
├─ 是 → 策略模式（Strategy）
└─ 否 → 
   是否通过状态驱动行为？
   ├─ 是 → 状态模式（State）
   └─ 否 → 
      是否需要集中管理对象间复杂交互？
      ├─ 是 → 中介者模式（Mediator）
      └─ 否 → 
         是否需要支持请求的撤销/重做？
         ├─ 是 → 备忘录模式（Memento）
         └─ 否 → 
            是否需要将请求封装为对象（支持参数化、队列化）？
            ├─ 是 → 命令模式（Command）
            └─ 否 → 
               是否需要被观察的对象变化后，会自动通知多个订阅者？
               ├─ 是 → 观察者模式（Observer）
               └─ 否 → 
                  是否需要由多个对象依次处理请求？
                  ├─ 是 → 责任链模式（Chain of Responsibility）
                  └─ 否 → 
                     是否需要定义操作步骤/算法骨架，并允许子类重写具体细节？
                     ├─ 是 → 模板方法模式（Template Method）
                     └─ 否 → 
                        是否需要遍历集合对象？
                        ├─ 是 → 迭代器模式（Iterator）
                        └─ 否 → 
                           是否需要分离数据结构和操作行为？
                           ├─ 是 → 访问者模式（Visitor）
                           └─ 否 → 
                              是否需要解释和处理某种语言或表达式的语法规则？
                              ├─ 是 → 解释器模式（Interpreter）
                              └─ 否 → 
</code></pre>
<p>注：行为型模式的选择并无严谨的先后顺序。</p>
<h3 id="23-决策树使用建议">2.3. 决策树使用建议</h3>
<p>设计模式决策树的核心逻辑是：</p>
<p><strong>问题分类</strong> → <strong>目标匹配</strong> → <strong>原则验证</strong>。<br>
在实际开发中需结合具体场景灵活调整，最终目标是写出<strong>高内聚、低耦合、可重用、易扩展</strong>、<strong>易维护</strong>和<strong>高性能</strong>的代码。&nbsp;通过刻意练习（如重构既有代码、阅读框架源码），可逐步培养模式选择的直觉。</p>
<p><strong>避免教条主义</strong>：模式是工具而非规则，例如简单场景无需强制使用设计模式，而复杂场景需要多种模式相互配合和模式创新。</p>
<h2 id="3-总结">3. 总结</h2>
<p>设计模式的选择如同烹饪调味——需要根据<strong>食材特性</strong>（系统需求）、<strong>食客口味</strong>（团队能力）、<strong>厨房条件</strong>（技术栈）综合决策。关键在于：</p>
<ol>
<li><strong>保持问题敏感度</strong>：从代码异味（如巨型类、扩散式修改）中发现模式应用契机</li>
<li><strong>掌握模式本质</strong>：理解模式背后的抽象原则而非具体实现</li>
<li><strong>培养架构直觉</strong>：通过阅读优秀源码（如Spring、Netty）积累模式使用经验</li>
</ol>
<p>最终目标不是成为模式的奴隶，而是让模式成为手中游刃有余的<strong>设计语言</strong>，构建出兼具<strong>弹性</strong>与<strong>简洁性</strong>的软件系统。</p>
<p>通过项目开发，积累经验后，你会逐渐能根据项目的具体需求，灵活运用合适的设计模式。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250402232847875-1703745322.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。<br>
<strong>后续会分享</strong>：</p>
<p>秘籍1&gt;&gt;掌握设计模式：23种经典模式实践、选择、价值与思想.pdf</p>
<p>秘籍2&gt;&gt;设计模式实战项目：markdown文本编辑器软件开发（<strong>开放所有源代码</strong>）</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.10048160226157407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-07 09:59">2025-04-07 08:17</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">240</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18806970" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18806970);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18806970', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18806970', title: '学了设计模式，却不知道怎么选择？' })">举报</a>
</div>
        