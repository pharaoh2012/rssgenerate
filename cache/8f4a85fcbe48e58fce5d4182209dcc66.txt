
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18733537" title="发布于 2025-02-24 10:45">
    <span role="heading" aria-level="2">『Python底层原理』--Python整数为什么可以无限大</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>整数类型</strong>是编程中最常见的数据类型之一，但它的实现细节却鲜为人知。</p>
<p>与其他语言不同，<code>Python</code> 的整数是任意精度的，这意味着它们可以无限大，仅受限于内存。</p>
<p>这种特性使得 <code>Python</code> 在处理大整数时非常强大，但也增加了实现的复杂性。</p>
<p>今天，我们将探讨 <code>Python</code> 整数的内部实现，揭示其背后的奥秘。</p>
<h1 id="1-整数的内部表示">1. 整数的内部表示</h1>
<p>在大多数编程语言中，整数通常是固定精度的，例如 <strong>32 位</strong>或 <strong>64 位</strong>。</p>
<p>然而，<code>Python</code> 的整数是任意精度的，这意味着它们可以无限大，而不会出现溢出问题。</p>
<p>这种特性使得 <code>Python</code>在密码学、计算机代数等领域中非常实用。</p>
<pre><code class="language-python"># Python 中的整数可以非常大，而不会溢出
big_number = 1234567890123456789012345678901234567890
print(big_number * big_number)  # 输出一个更大的整数
</code></pre>
<p>这种任意精度的特性是如何实现的呢？</p>
<p>答案在于 <code>Python</code> 的整数实现方式。</p>
<p><code>Python</code> 的整数是通过 <code>CPython</code> 的   <code>PyLongObject</code>   结构体实现的，</p>
<p>这个结构体定义了整数的存储方式，包括符号和数字。</p>
<p><code>PyLongObject</code>的定义参考：<code>Include/cpython/longintrepr.h</code> 文件。</p>
<pre><code class="language-c">typedef struct _PyLongValue {
    uintptr_t lv_tag; /* Number of digits, sign and flags */
    digit ob_digit[1];
} _PyLongValue;

struct _longobject {
    PyObject_HEAD
    _PyLongValue long_value;
};
</code></pre>
<p>这里的<code>_longobject</code>就是<code>PyLongObject</code>，<code>_PyLongValue</code>中存储了数字的符号和个数。</p>
<p><code>Python</code> 使用一种<strong>“大基数”</strong>表示法，而不是常见的十进制表示，</p>
<p>在 <strong>64 位</strong>平台上，基数为<span class="math inline">\(2^{30}\)</span> ，而在 <strong>32 位</strong>平台上，基数为<span class="math inline">\(2^{15}\)</span> 。</p>
<p>以<strong>64位平台</strong>（基数为$ 2^{30} $）为例，一个大数据<code>1234567890123456789</code>存储为<code>[1038713109, 76039121, 1]</code>。</p>
<pre><code class="language-python">def to_digits(n, base=2**30):
    digits = [n % base]

    n = n // base
    while n != 0:
        digits.append(n % base)
        n = n // base

    return digits

x = 1234567890123456789
print(f"整数 {x} 的底层数字表示: {to_digits(x)}")
# 整数 1234567890123456789 的底层数字表示: [1038713109, 76039121, 1]
</code></pre>
<p>如果要计算在<strong>32位</strong>平台上的表示，只要将传入<code>to_digits</code>的<code>base</code>参数改为<code>2**15</code>即可。</p>
<p>所以，任意大的整数，在<code>Python</code>内部都用用一个列表来存放，列表中的每个数值都小于$ 2^{30} $ 或者$ 2^{15} $ 。</p>
<h1 id="2-整数的内存优化">2. 整数的内存优化</h1>
<p><code>Python</code> 整数占用较多内存，即使是小整数也需要 28 字节（在 64 位平台上）。</p>
<p>为了优化内存使用，<code>CPython</code> 采取了一些巧妙的策略，尤其是在处理小整数时。</p>
<p>我本机上的Python3.12.4版本中，小于等于$ 2^{64} $的整数都是缓存的。</p>
<pre><code class="language-python">i = 2**64
j = 2**64
print(f"addr i: {id(i)}, addr j: {id(j)}")
print(f"i 和 j 是否相同: {i is j}")
# addr i: 2595289736288, addr j: 2595289736288
# i 和 j 是否相同: True

i = 2**65
j = 2**65
print(f"addr i: {id(i)}, addr j: {id(j)}")
print(f"i 和 j 是否相同: {i is j}")
# addr i: 2595289736432, addr j: 2595289736480
# i 和 j 是否相同: False
</code></pre>
<p>从上面的示例可以看出，当整数$ \le 2^{64} $时，<code>i</code>和<code>j</code>的内存地址是一样的；反之则不一样。</p>
<p>不过，虽然<code>CPython</code>对整数的实现已经很高效了，但是但在处理大量整数时，内存占用仍然是一个需要考虑的问题。</p>
<p>以下是一些优化建议：</p>
<ol>
<li>使用<code>array</code>模块或<code>numpy</code>：如果你需要存储大量同类型的整数，使用<code>array</code>模块或<code>numpy</code>会以更紧凑的方式存储数据。</li>
<li>避免不必要的整数创建：尽量复用已有的整数对象，尤其是在循环中。</li>
<li>使用生成器：如果只需要逐个处理整数，可以使用生成器而不是创建整个列表。</li>
</ol>
<h1 id="3-整数的性能优化">3. 整数的性能优化</h1>
<p><code>CPython</code>的整数实现不仅考虑了内存使用，还通过多种优化手段提高了运算性能。</p>
<ol>
<li><strong>位操作优化</strong>：对于大整数，<code>CPython</code>使用多精度算术，多精度整数在内存中以数组形式存储，每个元素代表一定位数的数值。</li>
</ol>
<p>关联的源码可参考：<code>Include/cpython/longintrepr.h</code> 和 <code>Objects/longobject.c</code></p>
<ol start="2">
<li><strong>缓存机制优化</strong>：对于一些频繁出现的运算或者中间结果，会将其缓存起来。当再次需要这些结果时，直接从缓存中获取，而不是重新计算。</li>
</ol>
<p>关联的源码可参考：<code>Objects/longobject.c</code> 和 <code>Objects/object.c</code></p>
<ol start="3">
<li><strong>并行计算支持</strong>：对于大整数加法，会将计算任务分解成多个子任务，并行地在多个核心上执行。</li>
</ol>
<p>关联的源码可参考：<code>Python/thread_pthread.h</code>、<code>Python/thread_pthread.c</code> 和 <code>Objects/longobject.c</code></p>
<ol start="4">
<li><strong>代码生成优化</strong>：在将整数加法的 <code>Python</code> 代码转换为机器码时，生成更高效的指令序列。</li>
</ol>
<p>关联的源码可参考：<code>Python/compile.c</code>和<code>Python/ceval.c</code></p>
<h1 id="4-总结">4. 总结</h1>
<p><code>Python</code> 的整数实现是一个高效且灵活的任意精度整数系统。</p>
<p>通过<code>CPython</code>的源码，我们可以看到<code>Python</code>如何在内部处理大整数，以及如何通过优化策略提高性能和节省内存。</p>
<p>不过，虽然<code>Python</code>的整数实现已经非常强大，但在处理大量数据时，我们仍然可以通过一些技巧进一步优化内存使用和性能。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.47970453138078706" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-24 10:46">2025-02-24 10:45</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">290</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18733537" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18733537);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18733537', targetLink: 'https://www.cnblogs.com/wang_yb/p/18733537', title: '『Python底层原理』--Python整数为什么可以无限大' })">举报</a>
</div>
        