
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/iRuriCatt/p/18631580" title="发布于 2024-12-25 22:36">
    <span role="heading" aria-level="2">Nodejs（含js模块化+npm+express）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<h3 id="11-运行环境">1.1 运行环境</h3>
<ul>
<li>
<p><strong>浏览器</strong>是 js 的<strong>前端</strong>运行环境</p>
</li>
<li>
<p><strong>Node.js</strong> 是 js 的<strong>后端</strong>运行环境</p>
</li>
<li>
<p>Node.js 中<strong>无法调用</strong> DOM 和 BOM 等浏览器内置 API</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214344041-1484227353.png" style="zoom: 67%">
<h3 id="12-nodejs-可以做什么">1.2 Node.js 可以做什么</h3>
<ul>
<li>
<p>基于 Express 框架可以快速构建 Web 应用</p>
</li>
<li>
<p>基于 Electron 框架可以快速构建跨平台的桌面应用</p>
</li>
<li>
<p>基于 restify 框架可以快速构建 API 接口项目</p>
</li>
<li>
<p>读取和操作数据库，创建实用的命令行工具辅助前端开发</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h3 id="13-安装与运行">1.3 安装与运行</h3>
<ul>
<li>
<p>下载稳定版<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener nofollow">node.js</a></p>
</li>
<li>
<p>安装完查看 node.js 的版本</p>
</li>
</ul>
<pre><code class="language-bash">node -v
</code></pre>
<ul>
<li>创建测试文件，通过命令行运行（需要切换到文件所在目录）</li>
</ul>
<pre><code class="language-bash">node test.js
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214430182-1105624978.png" alt="" loading="lazy"></p>
<h2 id="2-fs-文件系统模块">2. fs 文件系统模块</h2>
<blockquote>
<p>fs 模块是 Node.js 官方提供的用来<strong>操作文件</strong>的模块，提供了一系列的方法和属性，用来满足用户对文件的操作需求</p>
</blockquote>
<ul>
<li>如果要在 js 代码中使用 fs 模块来操作文件，则需要先导入</li>
</ul>
<pre><code class="language-js">const fs = require("fs");
</code></pre>
<h3 id="21-读取指定文件中的内容">2.1 读取指定文件中的内容</h3>
<ul>
<li>使用<code>fs.readFile()</code>读取指定文件中的内容</li>
</ul>
<pre><code class="language-js">fs.readFile(path[, options), callback)
</code></pre>
<ul>
<li>
<p>参数解读</p>
<ul>
<li>
<p><code>path</code>：必选，读取的文件路径（字符串）</p>
</li>
<li>
<p><code>options</code>：可选，以什么编码格式来读取文件，默认指定<code>utf8</code></p>
</li>
<li>
<p><code>callback</code>：必选，文件读取完成后，通过回调函数拿到读取的失败和成功的结果，err 和 dataObj</p>
</li>
</ul>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-js">const fs = require("fs");

fs.readFile("./files/1.txt", "utf-8", function (err, dataObj) {
	// 读取成功，err为null，否则为错误对象。因此能以此进行判断
	if (err) {
		return console.log("文件读取失败！" + err.message);
	}
	// 读取成功的结果，失败则为undefined
	console.log("文件读取成功，内容是：" + dataObj);
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214502057-2061970049.png" alt="" loading="lazy"></p>
<h3 id="22-向指定文件中写入内容">2.2 向指定文件中写入内容</h3>
<ul>
<li>使用<code>fs.writeFile()</code>向指定文件写入内容</li>
</ul>
<pre><code class="language-js">fs.writeFile(file, data[, options], callback)
</code></pre>
<ul>
<li>
<p>参数解读</p>
<ul>
<li>
<p><code>file</code>：必选，文件存放的路径（字符串）</p>
</li>
<li>
<p><code>data</code>：必选，要写入的内容</p>
</li>
<li>
<p><code>options</code>：可选，以什么格式写入文件内容，默认<code>utf8</code></p>
</li>
<li>
<p><code>callback</code>：必选，文件写入完成后的回调函数</p>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const fs = require("fs");

fs.writeFile("F:/files/2.txt", "hello world", function (err) {
	// 写入成功，err为null，否则为错误对象
	if (err) {
		return console.log("写入文件失败！" + err.message);
	}
	console.log("文件写入成功！");
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214520949-1736128910.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214551204-371766901.png" alt="" loading="lazy"></p>
<h3 id="23-小练习">2.3 小练习</h3>
<ul>
<li>
<p>需求：整理<code>成绩.txt</code>中的数据，并写入<code>成绩-ok.txt</code></p>
</li>
<li>
<p>源数据与期望格式数据如下：</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214616517-633691575.png" style="zoom: 80%">
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-js">const fs = require("fs");

fs.readFile("./files/成绩.txt", function (err, dataObj) {
	if (err) {
		return console.log("文件读取失败！" + err.message);
	}
	let dataStr = dataObj.toString();
	dataStr = dataStr.replaceAll("=", "：");
	dataStr = dataStr.replaceAll(" ", "\n");
	fs.writeFile("./files/成绩-ok.txt", dataStr, function (err) {
		if (err) {
			return console.log("文件写入失败！" + err.message);
		}
	});
});
</code></pre>
<h3 id="24-路径动态拼接的问题">2.4 路径动态拼接的问题</h3>
<ul>
<li>
<p>在使用 fs 模块操作文件时，如果使用<strong>相对路径</strong>，很容易出现动态路径拼接错误的问题</p>
</li>
<li>
<p>原因：代码在运行时，会以执行 node 命令所处的目录，动态拼接出被操作文件的完整路径</p>
</li>
<li>
<p>解决</p>
<ul>
<li>
<p>提供完整路径：移植性差，不利于维护</p>
</li>
<li>
<p>使用<code>__dirname_ + '/files/data.txt'</code>：<code>__dirname</code>表示当前文件所在的目录</p>
</li>
</ul>
</li>
<li>
<p>使用相对路径，并在文件所在目录上一级执行命令</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214649103-298443321.png" style="zoom: 80%">
<ul>
<li>优化后的代码</li>
</ul>
<pre><code class="language-js">const fs = require("fs");

fs.readFile(__dirname + "/files/data.txt", function (err, dataObj) {
	if (err) {
		return console.log("文件读取失败！" + err.message);
	}
	console.log(dataObj.toString());
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214713366-776848659.png" alt="" loading="lazy"></p>
<h2 id="3-path-路径模块">3. Path 路径模块</h2>
<blockquote>
<p>path 模块是 Node.js 官方提供的用来<strong>处理路径</strong>的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求</p>
</blockquote>
<ul>
<li>如果要在 js 代码中使用 path 模块来处理路径，则需要先导入</li>
</ul>
<pre><code class="language-js">const path = require("path");
</code></pre>
<h3 id="31-路径拼接">3.1 路径拼接</h3>
<ul>
<li>使用<code>path.join()</code>把多个路径片段拼接为完整的路径字符串</li>
</ul>
<pre><code class="language-js">path.join([...paths]);
</code></pre>
<ul>
<li>
<p>参数解读</p>
<ul>
<li>
<p><code>...paths&lt;string&gt;</code>：路径片段的序列</p>
</li>
<li>
<p>返回值：<code>&lt;string&gt;</code></p>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const fs = require("fs");
const path = require("path");

// ../ 会抵消一级路径
const pathStr = path.join("/a", "/b/c", "../", "./d", "e");
console.log(pathStr);

fs.readFile(path.join(__dirname, "/files/data.txt"), function (err, dataObj) {
	if (err) {
		return console.log("文件读取失败！" + err.message);
	}
	console.log(dataObj.toString());
});
</code></pre>
<ul>
<li>注：以后涉及路径拼接的操作，都要用<code>path.join()</code>进行处理，如果直接使用<code>+</code>进行拼接，可能会有问题，如下图所示</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225214735338-1279849389.png" style="zoom: 75%">
<h3 id="32-获取路径中的文件名">3.2 获取路径中的文件名</h3>
<ul>
<li>使用<code>path.basename()</code>方法获取路径中的最后一部分，经常用它获取路径中的文件名</li>
</ul>
<pre><code class="language-js">path.basename(path[, ext])
</code></pre>
<ul>
<li>
<p>参数解读</p>
<ul>
<li>
<p><code>path</code>：必选，表示一个路径的字符串</p>
</li>
<li>
<p><code>ext</code>：可选，表示文件扩展名</p>
</li>
<li>
<p>返回值：表示路径中的最后一部分</p>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const path = require("path");

// 不加第二个参数，会连扩展名一起输出
const fileName = path.basename("/a/b/c/index.html", ".html");
console.log(fileName);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215209459-759665040.png" alt="" loading="lazy"></p>
<h3 id="33-获取路径中的文件扩展名">3.3 获取路径中的文件扩展名</h3>
<ul>
<li>使用<code>path.extname()</code>获取路径中的扩展名</li>
</ul>
<pre><code class="language-js">const path = require("path");

const extName = path.extname("/a/b/c/index.html");
console.log(extName);
</code></pre>
<ul>
<li>
<p>参数解读</p>
<ul>
<li>
<p><code>path</code>：必选，表示路径字符串</p>
</li>
<li>
<p>返回值：扩展名字符串</p>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const path = require("path");

const extName = path.extname("/a/b/c/index.html");
console.log(extName);
</code></pre>
<h3 id="34-小练习">3.4 小练习</h3>
<ul>
<li>
<p>需求：将<code>Clock.html</code>拆分为三个文件，<code>clock/index.html</code>、<code>clock/index.js</code>、<code>clock/index.css</code>，并引入 css、js 文件（找一个含 html、css、js 的文件进行练习即可）</p>
</li>
<li>
<p>思路</p>
<ul>
<li>
<p>设置正则表达式匹配<code>&lt;style&gt;&lt;/style&gt;</code>和<code>&lt;script&gt;&lt;/script&gt;</code>中的内容</p>
</li>
<li>
<p>使用 fs 模块读取<code>Clock.html</code>文件</p>
</li>
<li>
<p>编写三个方法处理 css、js、html 内容写入文件中</p>
</li>
</ul>
</li>
<li>
<p>目录结构</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215234259-1901626314.png" alt="" loading="lazy"></p>
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-js">const fs = require("fs");
const path = require("path");

// 先设置正则表达式，提取&lt;style&gt;&lt;/style&gt;和&lt;script&gt;&lt;/script&gt;的内容
const regStyle = /&lt;style&gt;[\s\S]*&lt;\/style&gt;/;
const regScript = /&lt;script&gt;[\s\S]*&lt;\/script&gt;/;

// 读取html文件
fs.readFile(path.join(__dirname, "../clockHtml/Clock.html"), function (err, dataObj) {
	if (err) return console.log("文件读取失败！" + err.message);
	// 读取文件成功，调用三个方法将内容拆分成三个文件
	resolveCss(dataObj.toString());
	resolveJs(dataObj.toString());
	resolveHtml(dataObj.toString());
});

// 处理css
function resolveCss(htmlStr) {
	const cssStr = regStyle.exec(htmlStr);
	cssStr[0] = cssStr[0].replace("&lt;style&gt;", "").replace("&lt;/style&gt;", "");
	fs.writeFile(path.join(__dirname, "./clock/index.css"), cssStr[0], function (err) {
		if (err) return console.log("文件写入失败！" + cssStr);
	});
	console.log("css文件写入成功！");
}

// 处理js
function resolveJs(htmlStr) {
	const jsStr = regScript.exec(htmlStr);
	jsStr[0] = jsStr[0].replace("&lt;script&gt;", "").replace("&lt;/script&gt;", "");
	fs.writeFile(path.join(__dirname, "./clock/index.js"), jsStr[0], function (err) {
		if (err) return console.log("文件写入失败！" + jsStr);
	});
	console.log("js文件写入成功！");
}

// 处理html
function resolveHtml(htmlStr) {
	const newStr = htmlStr
		.replace(regStyle, '&lt;link rel="stylesheet" href="index.css"&gt;')
		.replace(regScript, '&lt;script src="index.js"&gt;&lt;/script&gt;');
	fs.writeFile(path.join(__dirname, "./clock/index.html"), newStr, function (err) {
		if (err) console.log("文件写入失败！" + err.message);
		console.log("html文件写入成功！");
	});
}
</code></pre>
<ul>
<li>
<p>两个注意点</p>
<ul>
<li>
<p><code>fs.writeFile()</code>只能用来创建文件，不能用来创建路径</p>
</li>
<li>
<p>重复调用<code>fs.writeFile()</code>写入同一个文件，新写入的内容会覆盖之前的内容</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-http-模块">4. http 模块</h2>
<h3 id="41-简介">4.1 简介</h3>
<blockquote>
<p>http 模块是 Node.js 官方提供的用来创建 web 服务器的模块</p>
</blockquote>
<ul>
<li>
<p>客户端：在网络节点中，负责消费资源的电脑</p>
</li>
<li>
<p>服务器：负责对外提供网络资源的电脑</p>
</li>
<li>
<p>服务器和普通电脑的区别在于：服务器上安装了 web 服务器软件，如 IIS、Apache 等，通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器</p>
</li>
<li>
<p>在 Node.js 中不需要使用 IIS、Apache 等第三方 web 服务器软件，可以基于 Node.js 提供的 http 模块轻松手写一个服务器软件</p>
</li>
</ul>
<h3 id="42-创建最基本的-web-服务器">4.2 创建最基本的 web 服务器</h3>
<ol>
<li>导入</li>
</ol>
<pre><code class="language-js">const http = require("http");
</code></pre>
<ol start="2">
<li>调用<code>http.createServer()</code>创建 web 服务器实例</li>
</ol>
<pre><code class="language-js">const server = http.createServer();
</code></pre>
<ol start="3">
<li>为服务器实例绑定<code>request</code>事件，监听客户端的请求</li>
</ol>
<pre><code class="language-js">server.on("request", (req, res) =&gt; {
	// 只要有客户端来请求服务器，就会触发request事件，从而调用这个事件处理函数
	console.log("Someone visit our web server.");
});
</code></pre>
<ol start="4">
<li>调用<code>listen()</code>启动当前 web 服务器实例</li>
</ol>
<pre><code class="language-js">server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<ul>
<li>运行之后用浏览器访问该地址</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215253260-1927208865.png" alt="" loading="lazy"></p>
<h3 id="43-req-请求对象">4.3 req 请求对象</h3>
<ul>
<li>
<p>只要服务器收到了客户端的请求，就会调用通过<code>server.on()</code>为服务器绑定的<code>request</code>事件处理函数</p>
</li>
<li>
<p><code>req</code>是请求对象，包含了与客户端相关的数据和属性</p>
<ul>
<li>
<p><code>req.url</code>：客户端请求的 url 地址</p>
</li>
<li>
<p><code>req.method</code>：客户端的 method 请求类型</p>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const http = require("http");
const server = http.createServer();
server.on("request", (req, res) =&gt; {
	console.log(`Your request url is ${req.url}, and request method is ${req.method}`);
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<h3 id="44-res-响应对象">4.4 res 响应对象</h3>
<ul>
<li>
<p><code>res</code>是响应对象，包含与服务器相关的数据和属性</p>
<ul>
<li><code>res.end()</code>：向客户端发送指定的内容，并结束本次请求的处理过程</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">const http = require("http");
const server = http.createServer();
server.on("request", (req, res) =&gt; {
	const str = `Your request url is ${req.url}, and request method is ${req.method}`;
	res.end(str);
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215314054-1765708603.png" alt="" loading="lazy"></p>
<ul>
<li>通过一些接口测试软件测试一下其他请求方式，此处使用<code>Apifox</code></li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215331213-1435491677.png" style="zoom: 80%">
<h3 id="45-解决中文乱码问题">4.5 解决中文乱码问题</h3>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215400150-889788824.png" alt="" loading="lazy"></p>
<ul>
<li>当调用<code>res.end()</code>向客户端发送中文内容时，会出现乱码，此时需要手动设置内容的编码格式</li>
</ul>
<pre><code class="language-js">res.setHeader("Content-Type", "text-html; charset=utf-8");
</code></pre>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-js">const http = require("http");
const server = http.createServer();
server.on("request", (req, res) =&gt; {
	const str = `您的请求地址是：${req.url}，请求方式是：${req.method}`;
	res.setHeader("Content-Type", "text/html; charset=utf-8");
	res.end(str);
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215420736-1002545135.png" alt="" loading="lazy"></p>
<h3 id="46-小练习">4.6 小练习</h3>
<h4 id="461-根据不同的-url-响应不同的-html-内容">4.6.1 根据不同的 url 响应不同的 html 内容</h4>
<ul>
<li>
<p>实现步骤</p>
<ul>
<li>
<p>获取请求的 url</p>
</li>
<li>
<p>路径为<code>/</code>或<code>/index.html</code>，访问的是首页</p>
</li>
<li>
<p>路径为<code>/about.html</code>，访问的是关于页面</p>
</li>
<li>
<p>其他则显示<code>404 Not Found</code></p>
</li>
<li>
<p>设置<code>Content-Type</code>响应头，防止中文乱码</p>
</li>
<li>
<p>使用<code>res.end()</code>响应给客户端</p>
</li>
</ul>
</li>
<li>
<p>代码实现</p>
</li>
</ul>
<pre><code class="language-js">const http = require("http");
const server = http.createServer();
server.on("request", (req, res) =&gt; {
	let content = "&lt;h1&gt;404 Not Found&lt;/h1&gt;";
	console.log(req.url);
	if (req.url === "/" || req.url === "/index.html") {
		content = "&lt;h1&gt;首页&lt;/h1&gt;";
	} else if (req.url === "/about.html") {
		content = "&lt;h1&gt;关于&lt;/h1&gt;";
	}
	res.setHeader("Content-Type", "text/html; charset=utf-8");
	res.end(content);
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<h4 id="462-实现时钟的-web-服务器">4.6.2 实现时钟的 web 服务器</h4>
<ul>
<li>思路：把文件的实际存放路径，作为每个资源的请求 url 地址</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215443008-223686545.png" alt="" loading="lazy"></p>
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-js">const http = require("http");
const fs = require("fs");
const path = require("path");

const server = http.createServer();
server.on("request", (req, res) =&gt; {
	if (req.url !== "/favicon.ico") {
		fs.readFile(path.join(__dirname, req.url), function (err, dataObj) {
			if (err) {
				return res.end(`&lt;h1&gt;404 Not Found&lt;/h1&gt;`);
			}
			res.end(dataObj.toString());
		});
	}
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<ul>
<li>
<p>优化资源请求路径</p>
<ul>
<li>
<p>访问<code>/</code>时默认也访问<code>/clock/index.html</code></p>
</li>
<li>
<p>简化路径输入<code>/clock/index.html</code> --&gt; <code>/index.html</code></p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const http = require("http");
const fs = require("fs");
const path = require("path");

const server = http.createServer();
server.on("request", (req, res) =&gt; {
	// 优化资源请求路径
	let fpath = "";
	if (req.url === "/") {
		fpath = path.join(__dirname, "./clock/index.html");
	} else {
		fpath = path.join(__dirname, "/clock", req.url);
	}
	if (req.url !== "/favicon.ico") {
		fs.readFile(fpath, function (err, dataObj) {
			if (err) {
				return res.end(`&lt;h1&gt;404 Not Found&lt;/h1&gt;`);
			}
			res.end(dataObj.toString());
		});
	}
});
server.listen("8080", () =&gt; {
	console.log("http server running at http://127.0.0.1:8080");
});
</code></pre>
<h2 id="5-js-模块化规范">5. js 模块化规范</h2>
<h3 id="51-模块化概述">5.1 模块化概述</h3>
<h4 id="511-什么是模块化">5.1.1 什么是模块化</h4>
<ul>
<li>
<p>将程序⽂件依据⼀定规则拆分成多个⽂件，这种编码⽅式就是模块化的编码方式</p>
</li>
<li>
<p>拆分出来每个⽂件就是⼀个模块，模块中的数据都是私有的，模块之间互相隔离</p>
</li>
<li>
<p>同时也能通过一些手段，可以把模块内的指定数据“交出去”，供其他模块使用</p>
</li>
</ul>
<h4 id="512-为什么需要模块化">5.1.2 为什么需要模块化</h4>
<ul>
<li>
<p>随着应用的复杂度越来越高，其代码量和文件数量都会急剧增加，会逐渐引发以下问题：</p>
<ul>
<li>
<p>全局污染问题</p>
</li>
<li>
<p>依赖混乱问题</p>
</li>
<li>
<p>数据安全问题</p>
</li>
</ul>
</li>
<li>
<p>好处</p>
<ul>
<li>
<p>复用性</p>
</li>
<li>
<p>可维护性</p>
</li>
<li>
<p>可实现按需加载</p>
</li>
</ul>
</li>
</ul>
<h3 id="52-有哪些模块化规范">5.2 有哪些模块化规范</h3>
<ul>
<li>
<p><strong>CommonJS</strong>——服务端应用广泛</p>
</li>
<li>
<p>AMD（了解）</p>
</li>
<li>
<p>CMD（了解）</p>
</li>
<li>
<p><strong>ES6 模块化</strong>——浏览器端应用广泛</p>
</li>
</ul>
<h3 id="53-导入和导出的概念">5.3 导入和导出的概念</h3>
<blockquote>
<p>模块化的核心思想就是：模块之间是隔离的，通过导入和导出进行数据和功能的共享</p>
</blockquote>
<ul>
<li>
<p>导出（暴露）：模块公开其内部的⼀部分（如变量、函数等），使这些内容可以被其他模块使用</p>
</li>
<li>
<p>导入（引入）：模块引入和使用其他模块导出的内容，以重用代码和功能</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215753552-1871235477.png" alt="" loading="lazy"></p>
<h3 id="54-nodejs-中的模块化">5.4 Node.js 中的模块化</h3>
<h4 id="541-分类">5.4.1 分类</h4>
<ul>
<li>
<p>根据来源的不同，分为三大类</p>
<ul>
<li>
<p><strong>内置模块</strong>：如 fs、path、http 等</p>
</li>
<li>
<p><strong>自定义模块</strong>：用户创建的每个<code>.js</code>文件都是自定义模块</p>
</li>
<li>
<p><strong>第三方模块</strong>：由第三方开发出来的模块，使用前需要提前下载</p>
</li>
</ul>
</li>
</ul>
<h4 id="542-加载模块">5.4.2 加载模块</h4>
<pre><code class="language-js">// 1、加载内置的fs模块
const fs = require("fs");
// 2、加载自定义模块，.js后缀可省略
const custom = require("./custom.js");
// 3、加载第三方模块
const moment = require("moment");
</code></pre>
<h4 id="543-模块作用域与-module-对象">5.4.3 模块作用域与 module 对象</h4>
<ul>
<li>
<p>模块作用域：只能在当前模块内被访问</p>
</li>
<li>
<p>好处：防止全局变量污染问题</p>
</li>
<li>
<p>module 对象：每个<code>.js</code>自定义模块中都有一个<code>module</code>对象，里面存储了和当前模块有关的信息</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225215835200-348619441.png" style="zoom: 80%">
<h3 id="55-commonjs-规范">5.5 CommonJS 规范</h3>
<blockquote>
<p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖</p>
</blockquote>
<ul>
<li>
<p>CommonJS 规定</p>
<ul>
<li>
<p>每个模块内部，module 变量代表当前模块</p>
</li>
<li>
<p>module 变量是一个对象，其<code>exports</code>属性（即<code>module.exports</code>）是对外的接口</p>
</li>
<li>
<p>加载某个模块，其实就是加载该模块的<code>module.exports</code>属性，<code>require()</code>方法用于加载模块</p>
</li>
</ul>
</li>
</ul>
<h4 id="551-初步体验">5.5.1 初步体验</h4>
<ul>
<li>school.js</li>
</ul>
<pre><code class="language-js">const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}

// 通过给exports对象添加属性的方式，来导出数据
// 此处不导出getCities
exports.name = name;
exports.slogan = slogan;
exports.getTel = getTel;
</code></pre>
<ul>
<li>student.js</li>
</ul>
<pre><code class="language-js">const name = "张三";
const motto = "相信明天会更好！";

function getTel() {
	return "13877889900";
}

function getHobby() {
	return ["抽烟", "喝酒", "烫头"];
}

// 通过给exports对象添加属性的方式，来导出数据
// 此处不导出getHobby
exports.name = name;
exports.motto = motto;
exports.getTel = getTel;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">// 引入school模块暴露的所有内容
const school = require("./school.js");
// 引入student模块暴露的所有内容
const student = require("./student.js");

console.log(school);
console.log(student);
</code></pre>
<h4 id="552-导出数据">5.5.2 导出数据</h4>
<ul>
<li>
<p>在<code>CommonJS</code>标准中，导出数据有两种方式：</p>
<ul>
<li>
<p>第一种方式：<code>module.exports = value</code></p>
</li>
<li>
<p>第二种方式：<code>exports.name = value</code></p>
</li>
</ul>
</li>
<li>
<p>注：</p>
<ul>
<li>每个模块内部的：<code>this</code>、<code>exports</code>、<code>modules.exports</code>在初始时，都指向同一个空对象，该空对象就是当前模块导出的数据，如下图：</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220059963-491917366.png" style="zoom: 67%">
<ul>
<li>
<p>无论如何修改导出对象，最终导出的都是<code>module.exports</code>的值</p>
</li>
<li>
<p><code>exports</code>是对<code>module.exports</code>的初始引用，仅为了方便给导出添加属性，所以不能用<code>exports={}</code>的形式导出数据，但是可以用<code>module.exports={}</code>导出数据</p>
</li>
<li>
<p>注：为了防止混乱，建议不要在同一模块中同时使用<code>exports</code>和<code>module.exports</code></p>
</li>
</ul>
</li>
<li>
<p>school.js</p>
</li>
</ul>
<pre><code class="language-js">const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}

module.exports = { name, slogan, getTel };

// this.c =789
// exports = {a:1}
// exports.b = 2
// module.exports.c = 3
// module.exports = {d:4}	// 最终导出成功的是这个

// console.log(this)
// console.log(exports)
// console.log(module.exports)
// console.log(this === exports &amp;&amp; exports === module.exports)

exports.name = name;
exports.slogan = slogan;
exports.getTel = getTel;
</code></pre>
<ul>
<li>
<p>解释</p>
<ul>
<li>
<p>一开始<code>module.exports</code>和<code>exports</code>指向同一个空对象</p>
</li>
<li>
<p><code>exports = {a:1}</code>：<code>exports</code>就指向了<code>{a:1}</code>这个新对象，<code>module.exports</code>仍指向空对象</p>
</li>
<li>
<p><code>exports.b = 2</code>：向<code>exports</code>指向的对象添加属性<code>b</code></p>
</li>
<li>
<p><code>module.exports.c = 3</code>：向<code>module.exports</code>指向的对象添加属性<code>c</code></p>
</li>
<li>
<p><code>module.exports = {d:4}</code>：<code>module.exports</code>指向了新对象<code>{d:4}</code></p>
</li>
<li>
<p>无论如何修改导出对象，最终导出的都是<code>module.exports</code>的值</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220159767-114846662.png" alt="" loading="lazy"></p>
<h4 id="553-导入数据">5.5.3 导入数据</h4>
<blockquote>
<p>在 CJS 模块化标准中，使用内置的 require 函数进行导入数据</p>
</blockquote>
<pre><code class="language-js">//直接引入模块
const school = require("./school.js");
//引入同时解构出要用的数据
const { name, slogan, getTel } = require("./school.js");
//引入同时解构+重命名
const { name: stuName, motto, getTel: stuTel } = require("./student.js");
</code></pre>
<h4 id="554-扩展理解">5.5.4 扩展理解</h4>
<ul>
<li>一个 JS 模块在执行时，是被包裹在一个内置函数中执行的，所以每个模块都有自己的作用域，可以通过如下方式验证这一说法：</li>
</ul>
<pre><code class="language-js">console.log(arguments);
console.log(arguments.callee.toString());
</code></pre>
<ul>
<li>内置函数的大致形式如下：</li>
</ul>
<pre><code class="language-js">function (exports, require, module, __filename, __dirname){
	/**************************/
}
</code></pre>
<h4 id="555-浏览器端运行">5.5.5 浏览器端运行</h4>
<ul>
<li>
<p>Node.js 默认是支持 CommonJS 规范的，但浏览器端不支持，所以需要经过编译，步骤如下：</p>
<ul>
<li>第一步：全局安装 browserify</li>
</ul>
<pre><code class="language-bash">npm i browserify -g
</code></pre>
<ul>
<li>第二步：编译</li>
</ul>
<pre><code class="language-bash">browserify index.js -o build.js
</code></pre>
<ul>
<li>
<p>注：index.js 是源文件，build.js 是输出的目标文件</p>
</li>
<li>
<p>第三步：页面中引入使用</p>
</li>
</ul>
<pre><code class="language-html">&lt;script type="text/javascript" src="./build.js"&gt;&lt;/script&gt;
</code></pre>
</li>
</ul>
<h3 id="56-es6-模块化规范">5.6 ES6 模块化规范</h3>
<blockquote>
<p>ES6 模块化规范是一个官方标准的规范，它是在语言标准的层面上实现了模块化功能，是目前最流行的模块化规范，且浏览器与服务端均支持该规范</p>
</blockquote>
<h4 id="561-初步体验">5.6.1 初步体验</h4>
<ul>
<li>school.js</li>
</ul>
<pre><code class="language-js">// 导出name
export const name = "尚硅谷";
// 导出slogan
export const slogan = "让天下没有难学的技术！";
// 导出getTel
export function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}
</code></pre>
<ul>
<li>student.js</li>
</ul>
<pre><code class="language-js">export const name = "张三";
export const motto = "相信明天会更好！";
export function getTel() {
	return "13877889900";
}

function getHobby() {
	return ["抽烟", "喝酒", "烫头"];
}
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">// 引入school模块暴露的所有内容
import * as school from "./school.js";
// 引入student模块暴露的所有内容
import * as student from "./student.js";
</code></pre>
<ul>
<li>页面中引入 index.js</li>
</ul>
<pre><code class="language-html">&lt;script type="module" src="./index.js"&gt;&lt;/script&gt;
</code></pre>
<h4 id="562-node-中运行-es6-模块">5.6.2 Node 中运行 ES6 模块</h4>
<ul>
<li>
<p>Node.js 中运行 ES6 模块代码有两种方式：</p>
<ul>
<li>
<p>方式一：将 JavaScript 文件后缀从<code>.js</code>改为<code>.mjs</code>，Node 则会自动识别 ES6 模块</p>
</li>
<li>
<p>方式二：在<code>package.json</code>中设置<code>type</code>属性值为<code>module</code></p>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220226592-2027654039.png" style="zoom: 80%">
<h4 id="563-导出数据">5.6.3 导出数据</h4>
<blockquote>
<p>ES6 模块化提供 3 种导出方式：① 分别导出、② 统一导出、③ 默认导出</p>
</blockquote>
<ul>
<li>分别导出</li>
</ul>
<pre><code class="language-js">// 导出name
export const name = "尚硅谷";
// 导出slogan
export const slogan = "让天下没有难学的技术！";
// 导出getTel
export function getTel() {
	return "010-56253825";
}
</code></pre>
<ul>
<li>统一导出</li>
</ul>
<pre><code class="language-js">const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}

// 统一导出了：name、slogan、getTel
export { name, slogan, getTel };
</code></pre>
<ul>
<li>默认导出</li>
</ul>
<pre><code class="language-js">const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}

//默认导出了：name、slogan、getTel
export default { name, slogan, getTel };
</code></pre>
<ul>
<li>注：上述多种导出方式，可以同时使用</li>
</ul>
<pre><code class="language-js">// 导出name —— 分别导出
export const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}
// 导出slogan —— 统一导出
export { slogan };
// 导出getTel —— 默认导出
export default getTel;
</code></pre>
<h4 id="564-导入数据">5.6.4 导入数据</h4>
<blockquote>
<p>对于 ES6 模块化来说，使用何种导入方式，要根据导出方式决定</p>
</blockquote>
<h5 id="️-导入全部通用">🛠️ 导入全部（通用）</h5>
<ul>
<li>可以将模块中的所有导出内容整合到一个对象中</li>
</ul>
<pre><code class="language-js">import * as school from "./school.js";
</code></pre>
<h5 id="️-命名导入对应到处方式分别导出统一导出">🛠️ 命名导入（对应到处方式：分别导出、统一导出）</h5>
<ul>
<li>导出数据的模块</li>
</ul>
<pre><code class="language-js">// 分别导出
export const name = "尚硅谷";
// 分别导出
export const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}
// 统一导出
export { getTel };
</code></pre>
<ul>
<li>命名导入</li>
</ul>
<pre><code class="language-js">import { name, slogan, getTel } from "./school.js";
</code></pre>
<ul>
<li>通过<code>as</code>重命名</li>
</ul>
<pre><code class="language-js">import { name as myName, slogan, getTel } from "./school.js";
</code></pre>
<h5 id="️-默认导出对应导出方式默认导出">🛠️ 默认导出（对应导出方式：默认导出）</h5>
<ul>
<li>导出数据的模块</li>
</ul>
<pre><code class="language-js">const name = "尚硅谷";
const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}

// 默认导出了：name、slogan、getTel
export default { name, slogan, getTel };
</code></pre>
<ul>
<li>默认导入</li>
</ul>
<pre><code class="language-js">import school from "./school.js"; // 默认导出的名字可以修改，不是必须为school
</code></pre>
<h5 id="️-命名导入与默认导入可以混合使用">🛠️ 命名导入与默认导入可以混合使用</h5>
<ul>
<li>导出数据的模块</li>
</ul>
<pre><code class="language-js">// 分别导出
export const name = "尚硅谷";
// 分别导出
export const slogan = "让天下没有难学的技术！";

function getTel() {
	return "010-56253825";
}

function getCities() {
	return ["北京", "上海", "深圳", "成都", "武汉", "西安"];
}
// 默认导出
export default getTel;
</code></pre>
<ul>
<li>命名导入与默认导入混合使用，且默认导入的内容必须放在前方</li>
</ul>
<pre><code class="language-js">import getTel, { name, slogan } from "./school.js";
</code></pre>
<h5 id="️-动态导入通用">🛠️ 动态导入（通用）</h5>
<ul>
<li>允许在运行时按需加载模块，返回值是一个 Promise</li>
</ul>
<pre><code class="language-js">const school = await import("./school.js");
console.log(school);
</code></pre>
<h5 id="️import-可以不接收任何数据">🛠️import 可以不接收任何数据</h5>
<ul>
<li>例如只是让 mock.js 参与运行</li>
</ul>
<pre><code class="language-js">import "./mock.js";
</code></pre>
<h4 id="565-数据引用问题">5.6.5 数据引用问题</h4>
<ul>
<li><strong>思考1：</strong>如下代码的输出结果是什么？</li>
</ul>
<pre><code class="language-js">function count() {
	let sum = 1;
	function increment() {
		sum += 1;
	}
	return { sum, increment };
}

const { sum, increment } = count();

console.log(sum); // 1
increment();
increment();
console.log(sum); // 1
</code></pre>
<ul>
<li>
<p><strong>思考2：</strong>使用 CommnJS 规范，编写如下代码，输出结果是什么？</p>
</li>
<li>
<p>count.js</p>
</li>
</ul>
<pre><code class="language-js">let sum = 1;
function increment() {
	sum += 1;
}

module.exports = { sum, increment };
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">const { sum, increment } = require("./count.js");
console.log(sum); // 1
increment();
increment();
console.log(sum); // 1
</code></pre>
<ul>
<li>
<p>说明：cjs 导入的变量是复制品，无论调用的函数怎么修改，改的还是模块内部的变量</p>
</li>
<li>
<p><strong>思考3：</strong>使用 ES6 模块化规范，编写如下代码，输出结果是什么？</p>
</li>
<li>
<p>count.js</p>
</li>
</ul>
<pre><code class="language-js">let sum = 1;
function increment() {
	sum += 1;
}

export { sum, increment };
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import { sum, increment } from "./count.js";
console.log(sum); // 1
increment();
increment();
console.log(sum); // 3
</code></pre>
<ul>
<li>
<p>说明：es6 导入的变量和模块中的变量公用同一块内存，因此会修改变量的值</p>
</li>
<li>
<p>使用原则：导出的常量，务必使用<code>const</code>定义</p>
</li>
</ul>
<h2 id="6-包与-npm">6. 包与 npm</h2>
<h3 id="61-简介">6.1 简介</h3>
<ul>
<li>
<p>包：Node.js 中的第三方模块</p>
</li>
<li>
<p>包的来源：由第三方个人或团队开发出来的，免费供所有人使用（免费开源）</p>
</li>
<li>
<p>为什么需要包</p>
<ul>
<li>
<p>Node.js 的内置模块仅提供一些底层的 API，在基于内置模块进行项目开发时效率较低</p>
</li>
<li>
<p>包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大提高了开发效率</p>
</li>
</ul>
</li>
<li>
<p>从哪下载包</p>
<ul>
<li>
<p>搜索需要的包：<a href="https://www.npmjs.com/" target="_blank" rel="noopener nofollow">npmjs</a></p>
</li>
<li>
<p>从https://registry.npmjs.org/服务器上下载自己需要的包</p>
</li>
</ul>
</li>
<li>
<p>如何下载</p>
<ul>
<li>包管理工具 npm：Node Package Manager</li>
</ul>
</li>
</ul>
<h3 id="62-安装包">6.2 安装包</h3>
<pre><code class="language-bash"># 完整写法，默认下载最新版的包
npm install 包名
# 简写
npm i 包名
# 安装指定版本的包
npm i 包名@2.22.2
</code></pre>
<ul>
<li>
<p>安装完后，查看文档学习该模块的使用方法</p>
</li>
<li>
<p>示例：安装<code>moment</code>对时间进行格式化</p>
</li>
</ul>
<pre><code class="language-js">const moment = require("moment");
const datetime = moment().format("YYYY-MM-DD HH:MM:SS");
console.log(datetime);
</code></pre>
<ul>
<li>
<p>初次装包完成后，项目文件夹下多了<code>node_modules</code>文件夹和<code>package-lock.json</code>的配置文件</p>
</li>
<li>
<p>其中</p>
<ul>
<li>
<p><code>node_modules</code>文件夹用来存放所有已安装到项目中的包，<code>require()</code>就是从这个目录中查找并加载包</p>
</li>
<li>
<p><code>package-lock.json</code>配置文件用来记录<code>node_modules</code>目录下的每一个包的下载信息，如包名、版本号、下载地址等</p>
</li>
</ul>
</li>
<li>
<p>注：不要手动修改<code>node_modules</code>或<code>package-lock.js</code>文件中的任何代码，npm 包管理工具会自动维护它们</p>
</li>
</ul>
<h3 id="63-包的语义化版本规范">6.3 包的语义化版本规范</h3>
<ul>
<li>
<p>包的版本号是以“点分十进制”形式进行定义的，总共三位数字，例如：2.24.0</p>
</li>
<li>
<p>其中每一位数字所代表的含义如下：</p>
<ul>
<li>
<p>第 1 位数字：大版本，当发生了底层重构时，大版本+1</p>
</li>
<li>
<p>第 2 位数字：功能版本，当新增了一些功能时，功能版本+1</p>
</li>
<li>
<p>第 3 位数字：Bug 修复版本，对 bug 进行修复后，bug 修复版本+1</p>
</li>
</ul>
</li>
<li>
<p>版本号提升规则：只要前面的版本号增长了，则后面的版本号<strong>归零</strong></p>
</li>
</ul>
<h3 id="64-包管理配置文件">6.4 包管理配置文件</h3>
<blockquote>
<p>npm 规定，在项目根目录中，必须提供名为<code>package.json</code>的包管理配置文件，用来记录与项目有关的一些配置信息，如：</p>
<ul>
<li>
<p>项目名称、版本号、描述等</p>
</li>
<li>
<p>项目中都用到了哪些包</p>
</li>
<li>
<p>哪些包只在开发期间会用到</p>
</li>
<li>
<p>哪些包在开发和部署时都需要用到</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>多人协作的问题</p>
<ul>
<li>
<p>整个项目的体积是 30.4M，第三方包的体积是 28.8M，项目源代码的体积 1.6M</p>
</li>
<li>
<p>问题：第三方包体积过大，不方便团队成员之间共享项目源代码</p>
</li>
<li>
<p>解决：共享时剔除<code>node_modules</code></p>
</li>
</ul>
</li>
<li>
<p>如何记录项目中安装了哪些包</p>
<ul>
<li>
<p>在项目根目录中，创建<code>package.json</code>配置文件，即可用来记录项目中安装了哪些包，从而方便剔除<code>node_modules</code>目录后，在团队成员之间共享项目的源代码</p>
<ul>
<li>注：在项目开发中，一定要把<code>node_modules</code>文件夹添加到<code>.gitignore</code>忽略文件中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>快速创建<code>package.json</code></p>
</li>
</ul>
<pre><code class="language-bash">npm init -y
</code></pre>
<ul>
<li>
<p>说明</p>
<ul>
<li>
<p>在执行命令所处的目录中，快速新建<code>package.json</code>文件</p>
</li>
<li>
<p>还未写任何代码前先创建该文件</p>
</li>
<li>
<p>该命令只能在<strong>英文</strong>的目录下成功运行，不能含中文、空格</p>
</li>
<li>
<p>运行<code>npm install 包名</code>时，npm 包管理工具会自动把包的名称和版本号记录到<code>package.json</code>中</p>
</li>
</ul>
</li>
</ul>
<h4 id="641-dependencies-节点">6.4.1 dependencies 节点</h4>
<ul>
<li>
<p><code>package.json</code>文件中有一个<code>dependencies</code>节点，专门用来记录用<code>npm install</code>安装了哪些包</p>
</li>
<li>
<p>一次性安装所有包</p>
<ul>
<li>
<p>当拿到一个剔除了<code>node_modules</code>的项目后，需要先把所有的包下载到项目中，项目才能运行起来</p>
</li>
<li>
<p>执行<code>npm install</code>命令时，npm 包管理工具会先读取<code>package.json</code>中的<code>dependencies</code>节点</p>
</li>
<li>
<p>读取到记录的所有依赖包名称和版本号后，npm 包管理工具会把这些包一次性下载到项目中</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">npm install
npm i
</code></pre>
<h4 id="642-devdependencies-节点">6.4.2 devDependencies 节点</h4>
<ul>
<li>
<p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到<code>devDependencies</code>节点中</p>
</li>
<li>
<p>如果在开发和项目上线之后都需要用到，则建议把这些包记录到<code>dependencies</code>节点中</p>
</li>
<li>
<p>使用如下命令安装指定包，并记录到<code>devDependencies</code>节点中</p>
</li>
</ul>
<pre><code class="language-bash"># 简写
npm i 包名 -D
# 完整写法
npm install 包名 --save-dev
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220300606-1821931643.png" style="zoom: 67%">
<h3 id="65-卸载包">6.5 卸载包</h3>
<pre><code class="language-bash">npm uninstall 包名
</code></pre>
<ul>
<li>注：<code>npm uninstall</code>执行成功后，会把卸载的包自动从<code>package.json</code>的<code>dependencies</code>中移除</li>
</ul>
<h3 id="66-解决下包速度慢的问题">6.6 解决下包速度慢的问题</h3>
<ul>
<li>
<p>为什么下载速度慢</p>
<ul>
<li>在使用 npm 下包时，默认从国外的服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢</li>
</ul>
</li>
<li>
<p>npm 镜像服务器</p>
<ul>
<li>
<p>淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，并在国内提供下包的服务，从而提高了下包的速度</p>
</li>
<li>
<p>扩展：镜像是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像</p>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220337547-1668679078.png" style="zoom: 67%">
<ul>
<li>切换 npm 的下包镜像源</li>
</ul>
<pre><code class="language-bash"># 查看当前的下包镜像源
npm config get registry
# 切换镜像源，选择一个即可
npm config set registry https://registry.npmmirror.com	# 淘宝
npm config set registry https://npm.aliyun.com	# 阿里云
npm config set registry http://mirrors.cloud.tencent.com/npm/	# 腾讯云
npm config set registry https://mirrors.huaweicloud.com/repository/npm/	# 华为云
# 检查镜像源是否切换成功
npm config get registry
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220658781-2020090058.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>nrm</code></p>
<ul>
<li>为了更方便的切换下包的镜像源，可以安装<code>nrm</code>工具，利用其提供的终端命令，可以快速查看和切换下包的镜像源</li>
</ul>
</li>
</ul>
<pre><code class="language-bash"># 将nrm安装为全局可用的工具
npm i nrm -g
# 查看所有可用的镜像源
nrm ls
# 将下包的镜像源切换为淘宝镜像
nrm use taobao
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220811493-1947741927.png" style="zoom: 80%">
<h3 id="67-包的分类">6.7 包的分类</h3>
<ul>
<li>
<p>分为两大类</p>
<ul>
<li>
<p>项目包</p>
<ul>
<li>
<p>开发依赖包：被记录到<code>devDependencies</code>节点中的包，只在开发期间会用到</p>
</li>
<li>
<p>核心依赖包：被记录到<code>dependencies</code>节点中的包，在开发期间和项目上线之后都会用到</p>
</li>
</ul>
</li>
<li>
<p>全局包</p>
<ul>
<li>
<p>执行<code>npm install</code>使用了<code>-g</code>参数</p>
</li>
<li>
<p>全局包会被安装到<code>C:\User\用户目录\AppData\Roaming\npm\node_modules</code>目录下</p>
</li>
</ul>
<pre><code class="language-bash">npm i 包名 -g			# 全局安装指定的包
npm uninstall 包名 -g	# 卸载全局安装的包
</code></pre>
</li>
<li>
<p>注：</p>
<ul>
<li>
<p>只有<strong>工具性质的包</strong>才有全局安装的必要性，因为它们提供了好用的终端命令</p>
</li>
<li>
<p>判断某个包是否需要全局安装才能使用，可以参考官方提供的使用说明</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>以<code>i5ting_toc</code>工具进行示例，它是一个可以把<code>md</code>文档转为<code>html</code>页面的小工具</p>
</li>
</ul>
<pre><code class="language-bash"># 将i5ting_toc安装为全局包
npm install -g i5ting_toc
# 调用i5ting_toc，轻松实现md转html的功能
# -o是转换成功后以默认浏览器打开
i5ting_toc -f 要转换的md文件路径 -o
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220844567-1353615383.png" alt="" loading="lazy"></p>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220924289-947290213.png" style="zoom: 80%">
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225220943281-2146617492.png" alt="" loading="lazy"></p>
<h3 id="68-规范的包结构">6.8 规范的包结构</h3>
<ul>
<li>
<p>一个规范的包，其组成结构必须符合以下3点要求</p>
<ul>
<li>
<p>包必须以单独的目录存在</p>
</li>
<li>
<p>包的顶级目录下必须包含<code>package.json</code>这个包管理配置文件</p>
</li>
<li>
<p><code>package.json</code>中必须包含<code>name</code>，<code>version</code>，<code>main</code>这三个属性，分别代表包的名字、版本号、包的入口</p>
</li>
</ul>
</li>
<li>
<p>注：以上3点要求是一个规范的包结构必须遵守的格式，关于更多约束可以参考https://classic.yarnpkg.com/en/docs/package-json</p>
</li>
</ul>
<h3 id="69-开发属于自己的包">6.9 开发属于自己的包</h3>
<ul>
<li>
<p>需求：</p>
<ul>
<li>
<p>格式化日期</p>
</li>
<li>
<p>转义 HTML 中的特殊字符</p>
</li>
<li>
<p>还原 HTML 中的特殊字符</p>
</li>
</ul>
</li>
<li>
<p>初始化包的基本结构</p>
<ul>
<li>
<p>新建<code>my-tools</code>文件夹，作为包的根目录</p>
</li>
<li>
<p>在<code>my-tools</code>文件夹中，新建如下三个文件</p>
<ul>
<li>
<p><code>package.json</code>：包管理配置文件</p>
</li>
<li>
<p><code>index.js</code>：包的入口文件</p>
</li>
<li>
<p><code>README.md</code>：包的说明文档</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初始化<code>package.json</code></p>
</li>
</ul>
<pre><code class="language-json">{
	"name": "my-tools",
	"version": "1.0.0",
	"main": "index.js",
	"description": "提供了格式化时间，HTMLEscape的功能",
	"keywords": ["dateFormat", "escape"],
	"license": "ISC"
}
</code></pre>
<ul>
<li>
<p>关于更多<code>license</code>许可协议相关的内容，可参考https://www.jianshu.com/p/86251523e898</p>
</li>
<li>
<p>在<code>index.js</code>中定义格式化时间的方法</p>
</li>
</ul>
<pre><code class="language-js">// 包的入口文件
function dateFormat(datetime) {
	const date = new Date(datetime);
	const y = date.getFullYear();
	const m = addZero(date.getMonth() + 1);
	const d = addZero(date.getDate());
	const hh = addZero(date.getHours());
	const mm = addZero(date.getMinutes());
	const ss = addZero(date.getSeconds());

	return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
}

function addZero(n) {
	return n &gt; 9 ? n : "0" + n;
}

module.exports = { dateFormat };
</code></pre>
<ul>
<li><code>test.js</code>测试一下模块是否可以使用</li>
</ul>
<pre><code class="language-js">const myTools = require("./my-tools");

const datetime = myTools.dateFormat(new Date());
console.log(datetime);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221038588-910579950.png" alt="" loading="lazy"></p>
<ul>
<li>在<code>index.js</code>中定义转义 HTML 的方法</li>
</ul>
<pre><code class="language-js">function HTMLEscape(htmlStr) {
	return htmlStr.replace(/&lt;|&gt;|"|&amp;/g, match =&gt; {
		switch (match) {
			case "&lt;":
				return "&amp;lt;";
			case "&gt;":
				return "&amp;gt;";
			case '"':
				return "&amp;quot;";
			case "&amp;":
				return "&amp;amp;";
		}
	});
}
</code></pre>
<ul>
<li>在<code>index.js</code>中定义还原 HTML 的方法</li>
</ul>
<pre><code class="language-js">function htmlUnEscape(htmlStr) {
	return htmlStr.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, match =&gt; {
		switch (match) {
			case "&amp;lt;":
				return "&lt;";
			case "&amp;gt;":
				return "&gt;";
			case "&amp;quot;":
				return '"';
			case "&amp;amp;":
				return "&amp;";
		}
	});
}
</code></pre>
<ul>
<li>
<p>将不同的功能进行模块化拆分</p>
<ul>
<li>
<p>将格式化时间的功能拆分到<code>src/dateFormat.js</code>中</p>
</li>
<li>
<p>将处理 HTML 字符串的功能，拆分到<code>src/htmlEscape.js</code></p>
</li>
<li>
<p>在<code>index.js</code>中，导入两个模块，得到需要向外共享的方法</p>
</li>
<li>
<p>在<code>index.js</code>中，使用<code>module.exports</code>把对应的方法共享出去（解构）</p>
</li>
</ul>
</li>
<li>
<p>index.js</p>
</li>
</ul>
<pre><code class="language-js">// 包的入口文件
const date = require("./src/dateFormat");
const htmlEscape = require("./src/htmlEscape");

module.exports = {
	...date,
	...htmlEscape,
};
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-js">const myTools = require("./my-tools");

const datetime = myTools.dateFormat(new Date());
console.log(datetime);

const htmlStr = "&lt;h1 ttile='abc'&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt;";
const str = myTools.HTMLEscape(htmlStr);
const newStr = myTools.htmlUnEscape(str);
console.log(newStr);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221058010-698095219.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>编写包的说明文档</p>
<ul>
<li>
<p>能清晰地将包的作用、用法、注意事项等描述清楚即可</p>
</li>
<li>
<p>以下<code>README.md</code>包含以下内容</p>
<ul>
<li>安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-markdown"># 安装

npm i my-tools

# 导入

const myTools = require('./my-tools')

# 格式化时间

```
// 格式：YYYY-MM-DD hh:mm:ss
const datetime = myTools.dateFormat(new Date())
console.log(datetime)
```

# 转义 HTML 中的特殊字符

```
const htmlStr = "&lt;h1 ttile='abc'&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt;"
// 结果：&amp;lt;h1 ttile='abc'&amp;gt;这是h1标签&amp;lt;span&amp;gt;123&amp;amp;nbsp;&amp;lt;/span&amp;gt;&amp;lt;/h1&amp;gt;
const str = myTools.HTMLEscape(htmlStr)
```

# 还原 HTML 中的特殊字符

```
const htmlStr = "&lt;h1 ttile='abc'&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt;"
const str = myTools.HTMLEscape(htmlStr)
const newStr = myTools.htmlUnEscape(str)
console.log(newStr)
```

# 开源协议

ISC
</code></pre>
<h3 id="610-发布包">6.10 发布包</h3>
<ul>
<li>
<p>注册 npm 账号</p>
</li>
<li>
<p>登录 npm 账号</p>
<ul>
<li>
<p>在终端执行<code>npm login</code>命令</p>
</li>
<li>
<p>注意，不是在官网登录，而是在命令行</p>
</li>
<li>
<p>在运行<code>npm login</code>之前，必须先把下包的服务器地址切换为 npm 官方服务器，否则会导致发布包失败</p>
</li>
</ul>
</li>
<li>
<p>切换到包的根目录，运行<code>npm publish</code>，即可将包发布到 npm 上（注：包名不能雷同）</p>
</li>
<li>
<p>删除已发布的包</p>
<ul>
<li>
<p><code>npm unpublish 包名 --force</code></p>
</li>
<li>
<p>注：</p>
<ul>
<li>
<p>只能删除 72h 以内发布的包</p>
</li>
<li>
<p>删除后 24h 内不允许重复发布</p>
</li>
<li>
<p>发布包时要谨慎，尽量不要往 npm 上发布没有意义的包！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221118057-1007176228.png" style="zoom: 80%">
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221135572-936043123.png" style="zoom: 80%">
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221149546-108879138.png" style="zoom: 65%">
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221206028-1430092000.png" alt="" loading="lazy"></p>
<h3 id="611-模块的加载机制">6.11 模块的加载机制</h3>
<h4 id="6111-优先从缓存中加载">6.11.1 优先从缓存中加载</h4>
<ul>
<li>
<p>模块在第一次加载后会被缓存，即多次调用<code>require()</code>不会导致模块的代码被执行多次</p>
</li>
<li>
<p>注：不论是内置模块、用户自定义模块还是第三方模块，都会优先从缓存中加载，从而提高模块的加载效率</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221224889-78866787.png" style="zoom: 80%">
<h4 id="6112-内置模块的加载机制">6.11.2 内置模块的加载机制</h4>
<ul>
<li>
<p>内置模块的加载优先级最高</p>
</li>
<li>
<p>如：<code>require('fs')</code>始终返回内置的 fs 模块，即使<code>node_modules</code>目录下有同名包 fs</p>
</li>
</ul>
<h4 id="6113-自定义模块的加载机制">6.11.3 自定义模块的加载机制</h4>
<ul>
<li>
<p>使用<code>require()</code>加载自定义模块时，必须指定以<code>./</code>或<code>../</code>开头的路径标识符，在加载自定义模块时，如果没有指定<code>./</code>或<code>../</code>这样的路径标识符，node 会把它当作内置模块或第三方模块进行加载</p>
</li>
<li>
<p>在使用<code>require()</code>导入自定义模块时，若省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下文件</p>
<ul>
<li>
<p>按照确切的文件名进行加载</p>
</li>
<li>
<p>补全<code>.js</code>扩展名进行加载</p>
</li>
<li>
<p>补全<code>.json</code>扩展名进行加载</p>
</li>
<li>
<p>补全<code>.node</code>扩展名进行加载</p>
</li>
<li>
<p>加载失败，终端报错</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221243141-896755268.png" alt="" loading="lazy"></p>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221257774-2096715061.png" style="zoom: 80%">
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221318104-2072693243.png" style="zoom: 80%">
<h4 id="6114-第三方模块的加载机制">6.11.4 第三方模块的加载机制</h4>
<ul>
<li>
<p>如果传递给<code>require()</code>的模块标识符不是一个内置模块，也没有<code>./</code>或<code>../</code>开头，则 Node.js 会从当前模块的父目录开始，尝试从<code>/node_modules</code>文件夹中加载第三方模块</p>
</li>
<li>
<p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</p>
</li>
<li>
<p>例如，假设在<code>C:\Users\itheima\project\foo.js</code>文件里调用了<code>require('tools')</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>
<p><code>C:\Users\itheima\project\node_modules\tools</code></p>
</li>
<li>
<p><code>C:\Users\itheima\node_modules\tools</code></p>
</li>
<li>
<p><code>C:\Users\node_modules\tools</code></p>
</li>
<li>
<p><code>C:\node_modules\tools</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="6115-目录作为模块">6.11.5 目录作为模块</h4>
<ul>
<li>
<p>当把目录作为模块标识符传递给<code>require()</code>进行加载时，有三种加载方式</p>
<ul>
<li>
<p>在被加载的目录下查找一个叫<code>package.json</code>的文件，并寻找<code>main</code>属性，作为<code>require()</code>加载的入口</p>
</li>
<li>
<p>如果目录里没有<code>package.json</code>文件，或者<code>main</code>入口不存在或无法解析，则 Node.js 会试图加载目录下的<code>index.js</code>文件</p>
</li>
<li>
<p>若以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：<code>Error:Cannot find module 'xxx'</code></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221349651-1017397807.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221405499-1925012704.png" alt="" loading="lazy"></p>
<h2 id="7-express">7. express</h2>
<h3 id="71-简介">7.1 简介</h3>
<h4 id="711-是什么">7.1.1 是什么</h4>
<ul>
<li>
<p><a href="https://expressjs.com/zh-cn/" target="_blank" rel="noopener nofollow">Express</a>是基于 Node.js 平台，快速、开放、极简的 Web 开发框架</p>
</li>
<li>
<p>简单理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的</p>
</li>
<li>
<p>Express 的本质：npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法</p>
</li>
</ul>
<h4 id="712-进一步理解">7.1.2 进一步理解</h4>
<ul>
<li>
<p>不使用 Express 能否创建 Web 服务器</p>
<ul>
<li>能，使用原生的 http 模块</li>
</ul>
</li>
<li>
<p>有了 http 内置模块，为什么还要用 Express</p>
<ul>
<li>http 模块使用较复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够提高开发效率</li>
</ul>
</li>
</ul>
<h4 id="713-express-能够做什么">7.1.3 Express 能够做什么</h4>
<ul>
<li>
<p>对于前端程序员来说，最常见的两种服务器，分别是</p>
<ul>
<li>
<p>Web 网站服务器：专门对外提供 Web 网页资源的服务器</p>
</li>
<li>
<p>API 接口服务器：专门对对外提供 API 接口的服务器</p>
</li>
</ul>
</li>
<li>
<p>使用 Express，可以方便、快速的创建 Web 网站服务器或 API 接口服务器</p>
</li>
</ul>
<h3 id="72-基本使用">7.2 基本使用</h3>
<h4 id="721-安装">7.2.1 安装</h4>
<ul>
<li>在项目所处的目录中安装 express</li>
</ul>
<pre><code class="language-bash">npm i express
</code></pre>
<h4 id="722-创建基本的-web-服务器">7.2.2 创建基本的 Web 服务器</h4>
<pre><code class="language-js">// 导入
const express = require("express");
// 创建web服务器
const app = express();
// 调用app.listen(端口号, callback)，启动服务器
app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<h4 id="723-监听-get-请求">7.2.3 监听 GET 请求</h4>
<ul>
<li>通过<code>app.get()</code>可以监听客户端的<code>GET</code>请求</li>
</ul>
<pre><code class="language-js">app.get("请求url", function (req, res) {
	/* 处理函数 */
});
</code></pre>
<ul>
<li>
<p><code>req</code>：请求对象，包含了与请求相关的属性和方法</p>
</li>
<li>
<p><code>res</code>：响应对象，包含了与响应相关的属性和方法</p>
</li>
</ul>
<h4 id="724-监听-post-请求">7.2.4 监听 POST 请求</h4>
<ul>
<li>通过<code>app.post()</code>可以监听客户端的<code>POST</code>请求</li>
</ul>
<pre><code class="language-js">app.post("请求url", function (req, res) {
	/* 处理函数 */
});
</code></pre>
<h4 id="725-把内容响应给客户端">7.2.5 把内容响应给客户端</h4>
<ul>
<li>通过<code>res.send()</code>方法，可以把处理好的内容发送给客户端</li>
</ul>
<pre><code class="language-js">app.get("/user", function (req, res) {
	// 向客户端发送JSON对象
	res.send({ name: "zs", age: 18, gender: "男" });
});

app.post("/user", function (req, res) {
	// 向客户端发送文本内容
	res.send("请求成功！");
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221445218-1088965100.png" style="zoom: 80%">
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221459747-95049634.png" style="zoom: 80%">
<h4 id="726-获取-url-中携带的查询参数">7.2.6 获取 url 中携带的查询参数</h4>
<ul>
<li>
<p><code>req.query</code>默认是一个空对象</p>
</li>
<li>
<p>客户端使用<code>?name=zs&amp;age=18</code>这种查询字符串形式发送到服务器，可以通过<code>req.query</code>对象访问到，如：<code>req.query.name</code>和<code>req.query.age</code></p>
</li>
</ul>
<pre><code class="language-js">app.get("/", function (req, res) {
	console.log(req.query);
	res.send(req.query);
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221515688-1656542239.png" style="zoom: 80%">
<h4 id="727-获取-url-中的动态参数">7.2.7 获取 url 中的动态参数</h4>
<ul>
<li>
<p>通过<code>req.params</code>对象，可以访问到 url 中通过<code>:</code>匹配到的动态参数</p>
</li>
<li>
<p><code>req.params</code>默认是一个空对象</p>
</li>
<li>
<p>动态参数可以有多个，如：<code>/user/:id/:name</code></p>
</li>
</ul>
<pre><code class="language-js">// 此处:id是一个动态参数
app.get("/user/:id", function (req, res) {
	console.log(req.params);
	res.send(req.params);
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221528372-70179854.png" style="zoom: 80%">
<h3 id="73-托管静态资源">7.3 托管静态资源</h3>
<h4 id="731-expressstatic">7.3.1 express.static()</h4>
<ul>
<li>
<p>通过<code>express.static()</code>可以非常方便地创建一个静态资源服务器</p>
</li>
<li>
<p>示例：将 clock 目录下的文件对外开放访问</p>
</li>
</ul>
<pre><code class="language-js">app.use(express.static("./clock"));
</code></pre>
<ul>
<li>
<p>此时，可以访问<code>clock</code>目录下的所有文件了</p>
<ul>
<li><code>http://127.0.0.1/index.html</code></li>
</ul>
</li>
<li>
<p>注：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 url 中</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221545033-1553842112.png" alt="" loading="lazy"></p>
<ul>
<li>如果要托管多个静态资源目录，需要多次调用<code>express.static()</code></li>
</ul>
<pre><code class="language-js">app.use(express.static("./clock"));
app.use(express.static("./files"));
</code></pre>
<ul>
<li>
<p>注：访问静态资源文件时，<code>express.static()</code>会根据目录的添加顺序查找所需的文件，即如果两个文件夹中存在同名文件，以前面的为主</p>
</li>
<li>
<p>把<code>./files</code>放前面，访问到的就是<code>files</code>中的<code>index.html文件</code></p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221612949-1963808621.png" style="zoom: 80%">
<h4 id="732-挂载路径前缀">7.3.2 挂载路径前缀</h4>
<ul>
<li>如果希望在托管的静态资源访问路径之前挂载路径前缀，可使用如下方式</li>
</ul>
<pre><code class="language-js">app.use("/clock", express.static("./clock"));
</code></pre>
<ul>
<li>注：此后访问资源时都必须加上前缀</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221630631-2039797455.png" style="zoom: 80%">
<h3 id="74-nodemon">7.4 nodemon</h3>
<ul>
<li>
<p>在编写调试 Node.js 项目时，如果修改了项目的代码，需要频繁手动关闭再重启，比较繁琐</p>
</li>
<li>
<p>此时，可以使用<code>nodemon</code>工具，它可以监听项目文件的变动，当代码被修改时，<code>nodemon</code>会自动重启项目，方便开发和调试</p>
</li>
<li>
<p>安装</p>
</li>
</ul>
<pre><code class="language-bash">npm i -g nodemon
</code></pre>
<ul>
<li>用<code>nodemon app.js</code>代替传统的<code>node app.js</code>启动项目</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221647284-1563743216.png" style="zoom: 80%">
<h3 id="75-路由">7.5 路由</h3>
<h4 id="751-概念">7.5.1 概念</h4>
<ul>
<li>
<p>在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p>
</li>
<li>
<p>Express 中的路由分为 3 部分组成，分别是请求的类型、请求的 url 地址、处理函数</p>
</li>
</ul>
<pre><code class="language-js">app.method(path, handler);
</code></pre>
<ul>
<li>前面使用过的<code>app.get()</code>、<code>app.post()</code>便是路由</li>
</ul>
<h4 id="752-路由的匹配过程">7.5.2 路由的匹配过程</h4>
<ul>
<li>
<p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后才会调用对应的处理函数</p>
</li>
<li>
<p>匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 url 同时匹配成功，则 Express 会将这次请求转交给对应的 function 函数进行处理</p>
</li>
<li>
<p>路由匹配注意点</p>
<ul>
<li>
<p>按照定义的先后顺序进行匹配</p>
</li>
<li>
<p>请求类型和请求的 url 同时匹配成功，才会调用对应的处理函数</p>
</li>
</ul>
</li>
</ul>
<h4 id="753-使用">7.5.3 使用</h4>
<ul>
<li>
<p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块</p>
</li>
<li>
<p>步骤</p>
<ul>
<li>
<p>创建路由模块对应的<code>.js</code>文件</p>
</li>
<li>
<p>调用<code>express.Router()</code>函数创建路由对象</p>
</li>
<li>
<p>向路由对象上挂载具体的路由</p>
</li>
<li>
<p>使用<code>module.exports</code>向外共享路由对象</p>
</li>
<li>
<p>使用<code>app.use()</code>注册路由模块</p>
</li>
</ul>
</li>
<li>
<p><code>router.js</code></p>
</li>
</ul>
<pre><code class="language-js">// 导入express，创建路由对象
const express = require("express");
const router = express.Router();

// 挂载获取用户列表的路由
router.get("/user/list", function (req, res) {
	res.send("Get user list.");
});

// 挂载添加用户的路由
router.post("/user/add", function (req, res) {
	res.send("Add new user.");
});

// 向外导出路由对象
module.exports = router;
</code></pre>
<ul>
<li><code>test.js</code></li>
</ul>
<pre><code class="language-js">const express = require("express");
const router = require("./router");
const app = express();

app.use(router);

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221701101-1067077235.png" style="zoom: 80%">
<ul>
<li>注：<code>app.use()</code>的作用就是用来注册全局中间件</li>
</ul>
<h4 id="754-为路由模块添加前缀">7.5.4 为路由模块添加前缀</h4>
<pre><code class="language-js">// 导入路由模块
const userRouter = require("./router/user.js");
// 使用app.use()注册路由模块，并添加统一的访问前缀api
app.use("/api", userRouter);
</code></pre>
<h3 id="76-中间件">7.6 中间件</h3>
<h4 id="761-概念">7.6.1 概念</h4>
<ul>
<li>
<p>中间件：特指业务流程的中间处理环节</p>
</li>
<li>
<p>生活中的例子</p>
<ul>
<li>
<p>在处理污水时，一般要经过三个处理环节，从而保证处理过后的废水达到排放标准</p>
</li>
<li>
<p>处理污水的这三个中间处理环节，可以叫做中间件</p>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221721318-1555137655.png" style="zoom: 80%">
<ul>
<li>当一个请求到达 Express 的服务器后，可以连续调用多个中间件，从而对这次请求进行预处理</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221752525-1508364465.png" style="zoom: 67%">
<h4 id="762-格式">7.6.2 格式</h4>
<ul>
<li>Express 的中间件，本质上是一个 function 处理函数，格式如下：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221825946-1818575585.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>注：中间件函数的形参列表中必须包含<code>next</code>参数，而路由处理函数中只包含<code>req</code>和<code>res</code></p>
</li>
<li>
<p><code>next()</code>是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由</p>
</li>
</ul>
<h4 id="763-定义中间件">7.6.3 定义中间件</h4>
<pre><code class="language-js">const mw = function (req, res, next) {
	console.log("这是一个最简单的中间件函数");
	// 在当前中间件的业务处理完毕后，必须调用next()
	// 表示把流转关系转交给下一给中间件或路由
	next();
};
</code></pre>
<h4 id="764-全局生效的中间件">7.6.4 全局生效的中间件</h4>
<ul>
<li>
<p>客户端发起的任何请求到达服务器后，都会触发的中间件，叫做全局生效的中间件</p>
</li>
<li>
<p>通过调用<code>app.use(中间件函数)</code>，即可定义一个全局生效的中间件</p>
</li>
</ul>
<pre><code class="language-js">const mw = function (req, res, next) {
	console.log("这是一个最简单的中间件函数");
	next();
};

// 全局生效的中间件
app.use(mw);

// 简写
app.use(function (req, res, next) {
	console.log("这是一个最简单的中间件函数");
	next();
});
</code></pre>
<ul>
<li>
<p>多个中间件之间共享一份<code>req</code>和<code>res</code></p>
</li>
<li>
<p>基于这样的特性，可以在上游的中间件中，统一为<code>req</code>和<code>res</code>对象添加自定义的属性或方法，供下游的中间件或路由使用</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221848086-794941073.png" style="zoom: 67%">
<pre><code class="language-js">const express = require("express");
const app = express();

app.use(function (req, res, next) {
	req.name = "张三";
	next();
});

app.use(function (req, res, next) {
	res.age = 18;
	next();
});

app.get("/", (req, res) =&gt; {
	console.log(req.name, res.age);
	res.send("Home page.");
});
app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<h4 id="765-定义多个全局中间件">7.6.5 定义多个全局中间件</h4>
<ul>
<li>可以使用<code>app.use()</code>连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的顺序依次进行调用</li>
</ul>
<pre><code class="language-js">app.use(function (req, res, next) {
	console.log("调用了第1个全局中间件");
	next();
});

app.use(function (req, res, next) {
	console.log("调用了第2个全局中间件");
	next();
});

app.get("/", (req, res) =&gt; {
	res.send("Home page.");
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221911108-651116176.png" alt="" loading="lazy"></p>
<h4 id="766-局部生效的中间件">7.6.6 局部生效的中间件</h4>
<ul>
<li>不使用<code>app.use()</code>定义的中间件，即局部生效的中间件</li>
</ul>
<pre><code class="language-js">const mw = function (req, res, next) {
	console.log("这是中间件函数");
	next();
};

app.get("/", mw, function (req, res) {
	res.send("Home page.");
});

// mw这个中间件不会影响下面这个路由
app.get("/user", function (req, res) {
	res.send("User page.");
});
</code></pre>
<h4 id="767-定义多个局部中间件">7.6.7 定义多个局部中间件</h4>
<ul>
<li>以下两种方式都可以定义多个局部中间件</li>
</ul>
<pre><code class="language-js">app.get("/user", mw1, mw2, (req, res) =&gt; {
	res.send("User page.");
});
app.get("/user", [mw1, mw2], (req, res) =&gt; {
	res.send("User page.");
});
</code></pre>
<h4 id="768-注意事项">7.6.8 注意事项</h4>
<ul>
<li>
<p>一定要在路由之前注册中间件</p>
</li>
<li>
<p>客户端发送过来的请求，可以连续调用多个中间件进行处理</p>
</li>
<li>
<p>执行完中间件的业务代码后，要调用<code>next()</code></p>
</li>
<li>
<p>为防止代码逻辑混乱，调用<code>next()</code>后不要再写额外代码</p>
</li>
<li>
<p>连续调用多个中间件时，多个中间件之间共享<code>req</code>和<code>res</code>对象</p>
</li>
</ul>
<h4 id="769-分类">7.6.9 分类</h4>
<ul>
<li>
<p>Express 官方把常见的中间件用法分成了 5 大类</p>
<ul>
<li>
<p>应用级别的中间件</p>
</li>
<li>
<p>路由级别的中间件</p>
</li>
<li>
<p>错误级别的中间件</p>
</li>
<li>
<p>Express 内置的中间件</p>
</li>
<li>
<p>第三方的中间件</p>
</li>
</ul>
</li>
<li>
<p>应用级别的中间件</p>
<ul>
<li>通过<code>app.use()</code>、<code>app.get()</code>等绑定到 app 实例上的全局/局部中间件</li>
</ul>
</li>
<li>
<p>路由级别的中间件</p>
<ul>
<li>绑定到<code>express.Router()</code>实例上的中间件，其用法与应用级别的中间件没有区别</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const app = express();
const router = express.Router();

// 路由级别的中间件
router.use((req, res, next) =&gt; {
	console.log("Time：", Date.now());
	next();
});

app.use("/", router);
</code></pre>
<ul>
<li>
<p>错误级别的中间件</p>
<ul>
<li>
<p>专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</p>
</li>
<li>
<p>格式：错误级别中间件的处理函数中含四个参数<code>function(err, req, res, next)</code></p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();

app.get("/", (req, res) =&gt; {
	throw new Error("出错了！");
	res.send("Home page.");
});

app.use((err, req, res, next) =&gt; {
	res.send(err.message);
});

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<ul>
<li>
<p>注：错误级别的中间件必须注册在所有路由之<strong>后</strong>，否则不生效！</p>
</li>
<li>
<p>Express 内置的中间件（常用的 3 个）</p>
<ul>
<li>
<p><code>express.static()</code>：快速托管静态资源（无兼容性问题）</p>
</li>
<li>
<p><code>express.json</code>：解析 JSON 格式的请求体数据（4.16.0+ 可用）</p>
</li>
<li>
<p><code>express.urlencoded</code>：解析 URL-encoded 格式的请求体数据（4.16.0+ 可用）</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 配置解析application/json格式数据的内置中间件
app.use(express.json());
// 配置解析application/x-www-urlencoded格式数据的内置中间件
app.use(express.urlencoded({ extended: false }));
</code></pre>
<ul>
<li>示例1：</li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();

app.use(express.json());

app.get("/user", (req, res) =&gt; {
	// 没配置express.json()中间件时，默认是undefined
	// 配置之后：{ name: 'zhangsan', age: 18 }
	console.log(req.body);
	res.send("ok");
});

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225221938340-1636319468.png" style="zoom: 80%">
<ul>
<li>示例 2：</li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();

// 解析表单中的url-encoded格式的数据
app.use(express.urlencoded({ extended: false }));

app.post("/book", (req, res) =&gt; {
	// 在服务器中可以使用req.body来接收客户端发送过来的请求体数据
	// 结果：[Object: null prototype] { bookname: '西游记', count: '10' }
	console.log(req.body);
	res.send("ok");
});

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222031548-118648286.png" style="zoom: 80%">
<ul>
<li>
<p>第三方的中间件</p>
<ul>
<li>
<p>由第三方开发出来的中间件。在项目中可以按需下载并配置第三方中间件，从而提高开发效率</p>
</li>
<li>
<p>此处以<code>body-parser</code>为例，该中间件用来解析请求体数据</p>
<ul>
<li>
<p>安装：<code>npm i body-parser</code></p>
</li>
<li>
<p>导入：<code>require('body-parser')</code></p>
</li>
<li>
<p>注册使用：<code>app.use()</code></p>
</li>
</ul>
</li>
<li>
<p>Express 内置的<code>express.urlencoded</code>中间件就是基于<code>body-parser</code>进一步封装出来的</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();
const parser = require("body-parser");

// 解析表单中的url-encoded格式的数据
app.use(parser({ extended: false }));

app.post("/book", (req, res) =&gt; {
	// 在服务器中可以使用req.body来接收客户端发送过来的请求体数据
	console.log(req.body);
	res.send("ok");
});

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<h4 id="7610-自定义中间件">7.6.10 自定义中间件</h4>
<ul>
<li>
<p>需求：模拟一个类似于<code>express.urlencoded</code>的中间件来解析 post 提交到服务器的表单数据</p>
</li>
<li>
<p>实现步骤</p>
<ul>
<li>
<p>定义中间件</p>
</li>
<li>
<p>监听<code>req</code>的<code>data</code>事件和<code>end</code>事件</p>
</li>
<li>
<p>使用<code>querystring</code>模块解析请求体数据</p>
</li>
<li>
<p>将解析出来的数据对象挂载为<code>req.body</code></p>
</li>
<li>
<p>将自定义中间件封装为模块</p>
</li>
</ul>
</li>
<li>
<p>说明：</p>
<ul>
<li>
<p>在中间件中，需要监听<code>req</code>对象的<code>data</code>事件来获取客户端发送到服务器的数据</p>
</li>
<li>
<p>如果数据量较大，无法一次性发送完毕，则客户端会把数据切割后分批发送到服务器，所以<code>data</code>事件可能会触发多次，每次触发<code>data</code>事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接</p>
</li>
<li>
<p>当请求体数据接收完毕后，会自动触发<code>req</code>的<code>end</code>事件</p>
</li>
<li>
<p>因此，可以在<code>req</code>的<code>end</code>事件中拿到并处理完整的请求体数据</p>
</li>
<li>
<p>Node.js 内置了<code>querystring</code>模块，专门用来处理查询字符串，通过该模块的<code>parse()</code>可以将查询字符串解析成对象的格式</p>
</li>
<li>
<p>将解析出来的数据挂载为<code>req</code>的自定义属性，命名为<code>req.body</code>，供下游使用</p>
</li>
<li>
<p>最后将自定义的中间件封装为独立的模块</p>
</li>
</ul>
</li>
<li>
<p><code>custom-body-parser/index.js</code></p>
</li>
</ul>
<pre><code class="language-js">// 导入querystring模块解析请求体数据
const qs = require("querystring");

const parser = (req, res, next) =&gt; {
	// 存储客户端发送过来的请求体数据
	let str = "";
	req.on("data", chunk =&gt; {
		// 拼接请求体数据
		str += chunk;
	});
	req.on("end", () =&gt; {
		// 打印完整的请求体数据
		console.log(str);
		// 调用qs.parse()把查询字符串解析为对象，并挂载为req.body
		req.body = qs.parse(str);
		next();
	});
};

module.exports = parser;
</code></pre>
<ul>
<li><code>test.js</code></li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();
const parser = require("./custom-body-parser");

app.use(parser);

app.post("/book", (req, res) =&gt; {
	// 在服务器中可以使用req.body来接收客户端发送过来的请求体数据
	console.log(req.body);
	res.send("ok");
});

app.listen(80, () =&gt; {
	console.log("express server running at http://127.0.0.1");
});
</code></pre>
<h3 id="77-使用-express-写接口">7.7 使用 Express 写接口</h3>
<h4 id="771-创建基本的服务器创建-api-路由模块">7.7.1 创建基本的服务器&amp;创建 API 路由模块</h4>
<ul>
<li><code>test.js</code></li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();
const apiRouter = require("./apiRouter");

app.use("/api", apiRouter);

app.listen(80, () =&gt; {
	console.log("express running at http://127.0.0.1");
});
</code></pre>
<ul>
<li><code>apiRouter.js</code></li>
</ul>
<pre><code class="language-js">const express = require("express");
const router = express.Router();

module.exports = router;
</code></pre>
<h4 id="772-编写-get-接口">7.7.2 编写 GET 接口</h4>
<pre><code class="language-js">router.get("/get", (req, res) =&gt; {
	// 获取客户端通过查询字符串发送到服务器的数据
	const query = req.query;
	// 调用res.send()把数据响应给客户端
	res.send({
		status: 0, // 状态：0表示成功，1表示失败
		msg: "GET请求成功！", // 状态描述
		data: query, // 需要响应给客户端的具体数据
	});
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222046916-712183824.png" style="zoom: 70%">
<h4 id="773-编写-post-接口">7.7.3 编写 POST 接口</h4>
<pre><code class="language-js">router.post("/post", (req, res) =&gt; {
	// 获取客户端通过请求体发送到服务器的URL-encoded数据
	const body = req.body;
	// 调用res.send()方法把数据响应给客户端
	res.send({
		status: 0, // 状态：0表示成功，1表示失败
		msg: "POST请求成功！", // 状态描述消息
		data: body, // 需要响应给客户端的具体数据
	});
});
</code></pre>
<ul>
<li>
<p>注：如果要获取<code>URL-encoded</code>格式的请求体数据，必须配置中间件<code>app.use(express.urlencoded({extended: false}))</code></p>
</li>
<li>
<p><code>test.js</code></p>
</li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();
const apiRouter = require("./apiRouter");

app.use(express.urlencoded({ extended: false }));
app.use("/api", apiRouter);

app.listen(80, () =&gt; {
	console.log("express running at http://127.0.0.1");
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222103973-543367483.png" style="zoom: 80%">
<h4 id="774-跨域问题">7.7.4 跨域问题</h4>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222123644-2095469673.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>前面写的 GET 和 POST 接口不支持跨域请求</p>
</li>
<li>
<p>当一个请求 url 的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面 url 不同即为跨域</p>
</li>
<li>
<p>解决接口跨域问题的方案主要有两种</p>
<ul>
<li>
<p>CORS：主流的解决方法，推荐使用</p>
</li>
<li>
<p>JSONP：有缺陷，只支持 GET 请求</p>
</li>
</ul>
</li>
</ul>
<h4 id="775-使用-cors-中间件解决跨域问题">7.7.5 使用 cors 中间件解决跨域问题</h4>
<ul>
<li>
<p>cors 是 Express 的第三方中间件，通过安装和配置 cors 中间件，可以很方便地解决跨域问题</p>
</li>
<li>
<p>使用步骤</p>
<ul>
<li>
<p>安装：<code>npm install cors</code></p>
</li>
<li>
<p>导入：<code>const cors = require('cors')</code></p>
</li>
<li>
<p>在路由之前调用<code>app.use(cors())</code>配置中间件</p>
</li>
</ul>
</li>
<li>
<p>编写简单的 html 文件测试</p>
</li>
</ul>
<pre><code class="language-html">&lt;body&gt;
	&lt;button id="get"&gt;get&lt;/button&gt;
	&lt;button id="post"&gt;post&lt;/button&gt;
&lt;/body&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
	const getBtn = document.querySelector("#get");
	const postBtn = document.querySelector("#post");
	getBtn.addEventListener("click", () =&gt; {
		axios({
			url: "/api/get",
			method: "get",
			query: {
				name: "张三",
				age: 18,
			},
		});
	});
	postBtn.addEventListener("click", () =&gt; {
		axios({
			url: "/api/post",
			method: "get",
			params: {
				name: "李四",
				age: 18,
			},
		});
	});
&lt;/script&gt;
</code></pre>
<ul>
<li><code>test.js</code></li>
</ul>
<pre><code class="language-js">const express = require("express");
const app = express();
const apiRouter = require("./apiRouter");
const cors = require("cors");

app.use(cors());
app.use(express.urlencoded({ extended: false }));
app.use("/api", apiRouter);

app.listen(80, () =&gt; {
	console.log("express running at http://127.0.0.1");
});
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222139316-388576432.png" alt="" loading="lazy"></p>
<h4 id="776-cors">7.7.6 CORS</h4>
<ul>
<li>
<p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 js 代码跨域获取资源</p>
</li>
<li>
<p>浏览器的同源安全策略默认会阻止网页“跨域”获取资源，但如果接口服务器配置了 cors 相关的 http 响应头，就可以解除浏览器端的跨域访问限制</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222154554-297206358.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>注意：</p>
<ul>
<li>
<p>CORS 主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启了 CORS 的接口</p>
</li>
<li>
<p>CORS 在浏览器中有兼容性，只支持<code>XMLHttpRequest Level2</code>的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE 10+、Chrome4+、FireFox3.5+）</p>
</li>
</ul>
</li>
</ul>
<h4 id="777-cors-响应头部">7.7.7 CORS 响应头部</h4>
<h5 id="️-access-control-allow-origin">🛠️ Access-Control-Allow-Origin</h5>
<ul>
<li>响应头部中可以携带<code>Access-Control-Allow-Origin</code>字段，格式如下</li>
</ul>
<pre><code class="language-js">Access-Control-Allow-Origin: &lt;origin&gt; | *
</code></pre>
<ul>
<li>
<p>其中，origin 参数的值指定了允许访问该资源的外域 url</p>
</li>
<li>
<p>例如，下面的字段值只允许来自<code>http://itcast.cn</code>的请求</p>
</li>
</ul>
<pre><code class="language-js">res.setHeader("Access-Control-Allow-Origin", "http://itcast.cn");
</code></pre>
<ul>
<li>以下代码表示允许来自任何域的请求</li>
</ul>
<pre><code class="language-js">res.setHeader("Access-Control-Allow-Origin", "*");
</code></pre>
<h5 id="️-access-control-allow-headers">🛠️ Access-Control-Allow-Headers</h5>
<ul>
<li>
<p>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头</p>
<ul>
<li><code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code>、<code>Content-Type</code>（值仅限于<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>三者之一）</li>
</ul>
</li>
<li>
<p>如果客户端向服务器发送了额外的请求体信息，则需要在服务器端通过<code>Access-Control-Allow-Headers</code>对额外的请求头进行声明，否则这次请求会失败！</p>
</li>
</ul>
<pre><code class="language-js">// 运行客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头
// 注：多个请求头之间用英文逗号隔开
res.setHeader("Access-Control-Allow-Headers", "Content-Type, X-Custom-Header");
</code></pre>
<h5 id="️-access-control-allow-methods">🛠️ Access-Control-Allow-Methods</h5>
<ul>
<li>
<p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求</p>
</li>
<li>
<p>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过<code>Access-Control-Allow-Methods</code>来指明实际请求所允许使用的 HTTP 方法</p>
</li>
</ul>
<pre><code class="language-js">// 只允许 POST、GET、DELETE、HEAD 请求方法
res.setHeader("Access-Control-Allow-Methods", "POST, GET, DELETE, HEAD");
// 允许所有的HTTP请求方法
res.setHeader("Access-Control-Allow-Methods", "*");
</code></pre>
<h4 id="778-cors-请求的分类">7.7.8 CORS 请求的分类</h4>
<ul>
<li>
<p>客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类</p>
<ul>
<li>
<p>简单请求</p>
</li>
<li>
<p>预检请求</p>
</li>
</ul>
</li>
<li>
<p>同时满足以下两大条件的请求，就属于简单请求</p>
<ul>
<li>
<p>请求方式：GET、POST、HEAD 三者之一</p>
</li>
<li>
<p>HTTP 头部信息不超过以下几种字段：<strong>无自定义头部字段</strong>、<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code>、<code>Content-Type</code>（值仅限于<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>三者之一）</p>
</li>
</ul>
</li>
<li>
<p>符合以下任何一个条件的请求，都需要进行预检请求</p>
<ul>
<li>
<p>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p>
</li>
<li>
<p>请求头中包含自定义头部字段</p>
</li>
<li>
<p>向服务器发送了<code>application/json</code>格式的数据</p>
</li>
</ul>
</li>
<li>
<p>在浏览器与服务器正式通信之前，浏览器会先发送<code>OPTION</code>请求进行预检，以获知服务器是否允许该实际请求，所以这一次的<code>OPTION</code>请求成为预检请求</p>
</li>
<li>
<p>服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p>
</li>
<li>
<p>简单请求和预检请求的区别</p>
<ul>
<li>
<p>简单请求：客户端与服务器之间只发生一次请求</p>
</li>
<li>
<p>预检请求：客户端与服务器之间发送两次请求，OPTION 预检请求成功后，才会发起真正的请求</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222216430-1561111292.png" alt="" loading="lazy"></p>
<h4 id="779-jsonp-接口">7.7.9 JSONP 接口</h4>
<ul>
<li>
<p>概念：浏览器端通过<code>&lt;script&gt;</code>标签的<code>src</code>属性请求服务器上的数据，同时服务器返回一个函数的调用。这种请求数据的方式叫做<code>JSONP</code></p>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p><code>JSONP</code>不属于真正的<code>Ajax</code>请求，因为它没有使用<code>XMLHttpRequest</code>这个对象</p>
</li>
<li>
<p><code>JSONP</code>仅支持<code>GET</code>请求，不支持<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等请求</p>
</li>
</ul>
</li>
<li>
<p>创建<code>JSONP</code>接口</p>
<ul>
<li>如果项目中已经配置了<code>CORS</code>跨域资源共享，为了防止冲突，必须在配置<code>CORS</code>中间件之前声明<code>JSONP</code>的接口，否则<code>JSONP</code>接口会被处理成开启了<code>CORS</code>的接口</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 优先创建JSONP接口【这个接口不会被处理成CORS接口】
app.get("/api/jsonp", (req, res) =&gt; {});
// 再配置CORS中间件【后续的所有接口都会被处理为CORS接口】
app.use(cors());
// 这是一个开启了CORS的接口
app.get("/api/get", (req, res) =&gt; {});
</code></pre>
<ul>
<li>
<p>实现 JSONP 接口的步骤</p>
<ul>
<li>
<p>获取客户端发送过来的回调函数的名字</p>
</li>
<li>
<p>得到要通过 JSONP 形式发送给客户端的数据</p>
</li>
<li>
<p>根据前两步得到的数据，拼接出一个函数调用的字符串</p>
</li>
<li>
<p>把上一步拼接得到的字符串响应给客户端的<code>&lt;script&gt;</code>标签进行解析执行</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">app.get("/api/jsonp", (req, res) =&gt; {
	// 获取客户端发送过来的回调函数的名字
	const funcName = req.query.callback;
	// 得到要通过 JSONP 形式发送给客户端的数据
	const data = { name: "张三", age: 18 };
	// 根据前两步得到的数据，拼接出一个函数调用的字符串
	const str = `${funcName}(${JSON.stringify(data)})`;
	// 把上一步拼接得到的字符串响应给客户端的`&lt;script&gt;`标签进行解析执行
	res.send(str);
});
</code></pre>
<ul>
<li>由于 axios 没有内置 jsonp，此处使用 jquery 发送 ajax 请求</li>
</ul>
<pre><code class="language-js">$("#jsonp").on("click", () =&gt; {
	$.ajax({
		method: "GET",
		url: "http://127.0.0.1/api/jsonp",
		dataType: "jsonp",
		success: res =&gt; {
			console.log(res);
		},
	});
});
</code></pre>
<h3 id="78-在项目中操作数据库">7.8 在项目中操作数据库</h3>
<h4 id="781-安装并连接数据库">7.8.1 安装并连接数据库</h4>
<ul>
<li>
<p>安装第三方模块：<code>npm i mysql</code></p>
</li>
<li>
<p>配置 mysql 模块，连接到 MySQL 数据库</p>
</li>
</ul>
<pre><code class="language-js">// 导入
const mysql = require("mysql");
// 建立与MySQL数据库的连接
const db = mysql.createPool({
	host: "127.0.0.1", // 数据库的ip地址
	user: "root", // 登录数据库的账号
	password: "root", // 登录数据库的密码
	database: "test", // 指定要操作哪个数据库
});
</code></pre>
<ul>
<li>执行 SQL 语句，测试 mysql 模块是否正常工作</li>
</ul>
<pre><code class="language-js">db.query("SELECT 1", (err, results) =&gt; {
	if (err) return console.log(err.message);
	// 只要能打印出[ RowDataPacket { '1': 1 } ]，就证明数据库连接正常
	console.log(results);
});
</code></pre>
<h4 id="782-查询数据">7.8.2 查询数据</h4>
<ul>
<li>如果执行的是<code>select</code>查询语句，则执行的结果是数组</li>
</ul>
<pre><code class="language-js">// 查询users表中的所有用户数据
db.query("SELECT * FROM users", (err, results) =&gt; {
	// 查询失败
	if (err) return console.log(err.message);
	// 查询成功
	console.log(results);
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222236466-1132712250.png" style="zoom: 67%">
<h4 id="783-插入数据">7.8.3 插入数据</h4>
<ul>
<li>
<p>如果执行的是<code>insert into</code>插入语句，则<code>results</code>是一个对象</p>
</li>
<li>
<p>可以通过<code>affectedRows</code>属性来判断是否插入数据成功</p>
</li>
</ul>
<pre><code class="language-js">// 要插入的数据
const user = { username: "zhangsan", password: "123456" };
// 待执行的sql语句，其中?表示占位符
const sqlStr = "INSERT INTO users (username, password) VALUES (?, ?)";
// 使用数组形式，依次为?占位符指定具体的值
db.query(sqlStr, [user.username, user.password], (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("插入数据成功");
	}
});
</code></pre>
<ul>
<li>向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过以下方式快速插入数据</li>
</ul>
<pre><code class="language-js">// 要插入的数据
const user = { username: "Tom", password: "123456" };
// 待执行的sql语句，其中?表示占位符
const sqlStr = "INSERT INTO users SET ?";
// 直接将数据对象当作占位符的值
db.query(sqlStr, user, (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("插入数据成功");
	}
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222306860-689877435.png" style="zoom: 80%">
<h4 id="784-更新数据">7.8.4 更新数据</h4>
<ul>
<li>执行<code>update</code>语句后，执行结果也是一个对象，可以通过<code>affectedRows</code>判断是否更新成功</li>
</ul>
<pre><code class="language-js">// 要更新的数据
const user = { id: 2, username: "lisi", password: "654321" };
// 待执行的sql语句
const sqlStr = "UPDATE users SET username=?, password=? WHERE id=?";
// 使用数组依次为占位符指定具体的值
db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("更新数据成功");
	}
});
</code></pre>
<ul>
<li>更新表数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过以下方式快速更新数据</li>
</ul>
<pre><code class="language-js">// 要更新的数据
const user = { id: 2, username: "lisi", password: "654321" };
// 待执行的sql语句
const sqlStr = "UPDATE users SET ? WHERE id=?";
// 使用数组依次为占位符指定具体的值
db.query(sqlStr, [user, user.id], (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("更新数据成功");
	}
});
</code></pre>
<h4 id="785-删除数据">7.8.5 删除数据</h4>
<ul>
<li>
<p>在删除数据时，推荐根据<code>id</code>这样的唯一标识来删除对应的数据</p>
</li>
<li>
<p>执行<code>delete</code>语句之后，结果也是一个对象，也有<code>affectedRows</code>属性</p>
</li>
</ul>
<pre><code class="language-js">// 要执行的sql语句
const sqlStr = "DELETE FROM users WHERE id=?";
// 注：如果sql语句中有多个占位符，则必须使用数组为每个占位符指定具体的值
// 如果只有一个占位符，则可以省略数组
db.query(sqlStr, 7, (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("删除数据成功");
	}
});
</code></pre>
<ul>
<li>
<p>标记删除</p>
<ul>
<li>
<p>使用<code>delete</code>语句会真正的把数据从表中删除，为了防止误删，推荐使用<strong>标记删除</strong>的形式来模拟删除的动作</p>
</li>
<li>
<p>所谓标记删除，就是在表中设置类似于<code>status</code>这样的状态字段，来标记当前这条数据是否被删除</p>
</li>
<li>
<p>当用户执行了删除的动作时，不是执行<code>delete</code>，而是<code>update</code>，将这条数据对应的<code>status</code>字段标记为删除即可</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">db.query("UPDATE users SET status=1 WHERE id=?", 6, (err, results) =&gt; {
	if (err) return console.log(err.message);
	if (results.affectedRows === 1) {
		console.log("删除数据成功");
	}
});
</code></pre>
<h2 id="8-前后端的身份认证">8. 前后端的身份认证</h2>
<h3 id="81-web-开发模式">8.1 Web 开发模式</h3>
<ul>
<li>
<p>目前主流的 Web 开发模式有两种</p>
<ul>
<li>
<p>基于<strong>服务器渲染</strong>的传统 Web 开发模式</p>
</li>
<li>
<p>基于<strong>前后端分离</strong>的新型 Web 开发模式</p>
</li>
</ul>
</li>
</ul>
<h4 id="811-服务端渲染">8.1.1 服务端渲染</h4>
<ul>
<li>服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的，因此，客户端不需要使用 Ajax 额外请求页面的数据</li>
</ul>
<pre><code class="language-js">app.get("/index.html", (req, res) =&gt; {
	// 要渲染的数据
	const user = { name: "zs", age: 20 };
	// 服务器通过字符串的拼接，动态生成HTML内容
	const html = `&lt;h1&gt;姓名：${user.name}，年龄：${user.age}&lt;/h1&gt;`;
	// 把生成好的页面内容响应给客户端，因此，客户端拿到的是带有真实数据的HTML页面
	res.send(html);
});
</code></pre>
<ul>
<li>
<p>优点</p>
<ul>
<li>
<p>前端耗时少：因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电</p>
</li>
<li>
<p>有利于 SEO：因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO</p>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>
<p>占用服务器端资源：即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力</p>
</li>
<li>
<p>不利于前后端分离，开发效率低：使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发</p>
</li>
</ul>
</li>
</ul>
<h4 id="812-前后端分离">8.1.2 前后端分离</h4>
<ul>
<li>
<p>后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式</p>
</li>
<li>
<p>优点</p>
<ul>
<li>
<p>开发体验好：前端专注于 UI 页面的开发，后端专注于 api 的开发，且前端有更多的选择性</p>
</li>
<li>
<p>用户体验好：Ajax 技术的广泛应用，极大提高了用户的体验，可以轻松实现页面的局部刷新</p>
</li>
<li>
<p>减轻了服务器端的渲染压力：因为页面最终是在每个用户的浏览器中生成的</p>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>
<p>不利于 SEO：因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息</p>
</li>
<li>
<p>解决：利用 Vue、React 等前端框架的 SSR（server side render）技术</p>
</li>
</ul>
</li>
<li>
<p>SEO</p>
<ul>
<li>Search Engine Optimizatio（搜索引擎优化），简单来说，就是透过一系列的技术和策略，让你的网站更容易被搜寻引擎（如 Google、Bing）收录，并且在搜寻结果中排名靠前。</li>
</ul>
</li>
</ul>
<h4 id="813-如何选择">8.1.3 如何选择？</h4>
<ul>
<li>
<p>不谈业务场景而盲目选择使用何种开发模式都是耍流氓</p>
</li>
<li>
<p>比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，此时使用<strong>服务器端渲染</strong></p>
</li>
<li>
<p>类似后台管理项目，交互性比较强，不需要考虑 SEO，则可以使用<strong>前后端分离</strong>的开发模式</p>
</li>
<li>
<p>具体使用何种开发模式并不是绝对的，为了同时兼顾首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式</p>
</li>
</ul>
<h3 id="82-身份认证">8.2 身份认证</h3>
<h4 id="821-简介">8.2.1 简介</h4>
<ul>
<li>
<p>身份认证：又称“身份验证”、“鉴权”，是通过一定的手段完成对用户身份的确认</p>
</li>
<li>
<p>日常生活中的身份认证随处可见，如：高铁的验票乘车、手机的密码或指纹解锁等</p>
</li>
<li>
<p>在 Web 开发中，也涉及到用户身份的认证，如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等</p>
</li>
<li>
<p>不同开发模式下的身份认证</p>
<ul>
<li>
<p>服务端渲染推荐使用<strong>Session 认证机制</strong></p>
</li>
<li>
<p>前后端分离推荐使用<strong>JWT 认证机制</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="822-session-认证机制">8.2.2 Session 认证机制</h4>
<ul>
<li>
<p>http 协议的无状态性</p>
<ul>
<li>客户端的每次 http 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 http 请求的状态</li>
</ul>
</li>
<li>
<p>如何突破 http 无状态的限制</p>
<ul>
<li>
<p>对于超市来说，为了方便收银员在结算时给 VIP 用户打折，超市可以为每个 VIP 用户发放会员卡</p>
</li>
<li>
<p>现实生活中的会员卡身份认证方式，在 Web 开发中的专业术语叫做<code>Cookie</code></p>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222335292-636174502.png" style="zoom: 50%">
<ul>
<li>
<p><code>Cookie</code>是存储在用户浏览器中的一段不超过 4kb 的字符串，它由一个名称（Name）、一个值（Value）和其它几个用于控制<code>Cookie</code>有效期、安全性、使用范围的可选属性组成</p>
</li>
<li>
<p>不同域名下的<code>Cookie</code>各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的<code>Cookie</code>一同发送到服务器</p>
</li>
<li>
<p><code>Cookie</code>的极大特性</p>
<ul>
<li>
<p>自动发送</p>
</li>
<li>
<p>域名独立</p>
</li>
<li>
<p>过期时限</p>
</li>
<li>
<p>4kb 限制</p>
</li>
</ul>
</li>
<li>
<p>客户端第一次请求服务器时，服务器通过<strong>响应头</strong>的形式向客户端发送一个身份认证的<code>Cookie</code>，客户端会自动将<code>Cookie</code>保存在浏览器中</p>
</li>
<li>
<p>随后，当客户端浏览器每次请求服务器时，浏览器会自动将身份认证相关的<code>Cookie</code>通过<strong>请求头</strong>的形式发送给服务器，服务器即可验明客户端的身份</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222402466-1902743070.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>由于<code>Cookie</code> 是存储在浏览器中的，而且浏览器也提供了读写<code>Cookie</code>的 API，因此<code>Cookie</code>很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据通过<code>Cookie</code>的形式发送给浏览器</p>
</li>
<li>
<p>注：千万不要使用<code>Cookie</code>存储重要且隐私的数据，比如用户的身份信息、密码等</p>
</li>
<li>
<p>为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡后，可以在收银机上进行刷卡认证，只有收银机确认存在的会员卡才能被正常使用</p>
</li>
<li>
<p>这种“会员卡 + 刷卡认证”的设计理念，就是<code>Session</code>认证机制的精髓</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222421241-819514984.png" style="zoom: 80%">
<h4 id="823-session-的工作原理">8.2.3 Session 的工作原理</h4>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222437551-714287007.png" style="zoom: 80%">
<h4 id="824-在-express-中使用-session-认证">8.2.4 在 Express 中使用 Session 认证</h4>
<ul>
<li>安装<code>express-session</code>中间件</li>
</ul>
<pre><code class="language-bash">npm i express-session
</code></pre>
<ul>
<li>注册 session 中间件</li>
</ul>
<pre><code class="language-js">// 导入
const session = require("express-session");
// 配置session中间件
app.use(
	session({
		secret: "keyboard cat", // secret属性的值可以为任意字符串
		resave: false, // 固定写法
		saveUninitialized: true, // 固定写法
	})
);
</code></pre>
<ul>
<li>
<p>向 session 中存数据</p>
<ul>
<li>当<code>express-session</code>中间件配置成功后，即可通过<code>req.session</code>来访问和使用<code>session</code>对象，从而存储用户的关键信息</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 登录的接口
app.post("/api/login", (req, res) =&gt; {
	// 判断用户提交的登录信息是否正确
	if (req.body.username !== "admin" || req.body.password !== "000000") {
		return res.send({ status: 1, msg: "登录失败！" });
	}
	req.session.user = req.body; // 将用户的信息存储到Session中
	req.session.isLogin = true; // 将用户的登录状态存储到session中

	res.send({ status: 0, msg: "登录成功！" });
});
</code></pre>
<ul>
<li>
<p>从 session 中取数据</p>
<ul>
<li>直接从<code>req.session</code>对象上获取之前存储的数据</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 获取用户名的接口
app.get("/api/username", (req, res) =&gt; {
	// 判断用户是否登录
	if (!req.session.user.isLogin) {
		return res.send({ status: 1, msg: "fail" });
	}
	res.send({ status: 0, msg: "success", username: req.session.user.username });
});
</code></pre>
<ul>
<li>
<p>清空 session</p>
<ul>
<li>调用<code>req.session.destory()</code>即可清空服务器保存的<code>session</code>信息</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 退出登录的接口
app.post("/api/logout", (req, res) =&gt; {
	// 清空当前客户端对应的session信息
	req.session.destory();
	res.send({
		status: 0,
		msg: "退出登录成功",
	});
});
</code></pre>
<h4 id="825-jwt">8.2.5 jwt</h4>
<ul>
<li>
<p>Session 认证机制需要配合 Cookie 才能实现，由于 Cookie 默认不支持跨域访问，所以当涉及到前端跨域请求后端接口时，需要做很多额外的配置，才能实现跨域 Session 认证</p>
</li>
<li>
<p>注：</p>
<ul>
<li>
<p>当前端请求后端接口不存在跨域问题时，推荐使用 Session 身份认证机制</p>
</li>
<li>
<p>当前端需要跨域请求后端接口时，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</p>
</li>
</ul>
</li>
<li>
<p>JWT（JSON Web Token）是目前最流行的跨域认证解决方案</p>
</li>
</ul>
<h4 id="826-jwt-工作原理">8.2.6 jwt 工作原理</h4>
<ul>
<li>用户的信息通过 Token 字符串的形式保存在客户端浏览器中，服务器通过还原 Token 字符串的形式来认证用户的身份</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222450692-701742465.png" style="zoom: 80%">
<h4 id="827-jwt-的组成部分">8.2.7 jwt 的组成部分</h4>
<ul>
<li>
<p>jwt 通常由三部分组成，分别是：Header（头部）、Playload（有效荷载）、Signature（签名）</p>
</li>
<li>
<p>三者之间使用<code>.</code>分隔</p>
</li>
</ul>
<pre><code>Header.Playload.Signature
</code></pre>
<ul>
<li>示例</li>
</ul>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></pre>
<ul>
<li>
<p>其中</p>
<ul>
<li>
<p><code>Playload</code>部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串</p>
</li>
<li>
<p><code>Header</code>和<code>Signature</code>是安全性相关的部分，只是为了保证<code>Token</code>的安全性</p>
</li>
</ul>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222511812-88318320.png" style="zoom: 67%">
<ul>
<li>
<p>使用方式</p>
<ul>
<li>
<p>客户端收到服务器返回的 jwt 之后，通常会将它存储在<code>localStorage</code>或<code>sessionStorage</code>中</p>
</li>
<li>
<p>此后，客户端每次与服务器通信，都要带上这个 jwt 字符串，从而进行身份认证</p>
</li>
<li>
<p>推荐的做法是把 jwt 放在 http 请求头的<code>Authorization</code>字段中</p>
</li>
</ul>
<pre><code>Authorization: Bearer &lt;token&gt;
</code></pre>
</li>
</ul>
<h4 id="828-在-express-中使用-jwt">8.2.8 在 Express 中使用 jwt</h4>
<ul>
<li>安装</li>
</ul>
<pre><code class="language-bash">npm i jsonwebtoken express-jwt
</code></pre>
<ul>
<li>
<p>其中</p>
<ul>
<li>
<p><code>jsonwebtoken</code>用于生成 jwt 字符串</p>
</li>
<li>
<p><code>express-jwt</code>用来将 jwt 字符串解析还原成 JSON 对象</p>
</li>
</ul>
</li>
<li>
<p>导入</p>
</li>
</ul>
<pre><code class="language-js">const jwt require('jsonwebtoken')
const { expressjwt } = require('express-jwt')
</code></pre>
<ul>
<li>
<p>定义<code>secret</code>密钥</p>
<ul>
<li>
<p>为了保证 jwt 字符串的安全性，防止 jwt 字符串在网络传输过程中被别人破解，需要定义一个用于加密和解密的 secret 密钥</p>
</li>
<li>
<p>当生成 jwt 字符串时，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 jwt 字符串</p>
</li>
<li>
<p>当把 jwt 字符串解析还原成 JSON 对象时，需要使用 secret 密钥进行解密</p>
</li>
</ul>
<pre><code class="language-js">// secret密钥的本质是一个字符串，任意，越复杂越好
const secretKey = "hello world";
</code></pre>
</li>
<li>
<p>在登录成功后生成 jwt 字符串</p>
<ul>
<li>调用<code>jsonwebtoken</code>提供的<code>sign()</code>，将用户信息加密成 jwt 字符串响应给客户端</li>
</ul>
</li>
</ul>
<pre><code class="language-js">app.post("/api/login", (req, res) =&gt; {
	if (req.body.username !== "admin" || req.body.password !== "000000") {
		return res.send({ status: 1, msg: "登录失败！" });
	}
	// 用户登录成功之后生成jwt字符串，通过token属性响应给客户端
	res.send({
		status: 200,
		message: "登录成功！",
		// 调用jwt.sign()生成jwt字符串
		// 三个参数分别是：用户信息、加密密钥、配置对象，可以配置当前token的有效期
		token: jwt.sign({ username: req.body.username }, secretKey, { expiresIn: "30s" }),
	});
});
</code></pre>
<ul>
<li>
<p>将 jwt 字符串还原为 JSON 对象</p>
<ul>
<li>
<p>客户端每次在访问那些有权限接口时，都需要主动通过请求头中的<code>Authorization</code>字段，将<code>Token</code>字符串发送到服务器进行身份认证</p>
</li>
<li>
<p>此时服务器可以通过<code>express-jwt</code>这个中间件，自动将客户端发送过来的<code>Token</code>解析还原成 JSON 对象</p>
</li>
<li>
<p>注：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息挂载到<code>req.auth</code>属性上</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// expressJWT({secret: secretKey})用来解析Token
// .unless({path: [/^\/api\//]})用来指定哪些接口不需要访问权限
app.use(expressjwt({ secret: secretKey, algorithms: ["HS256"] }).unless({ path: [/^\/api\//] }));
</code></pre>
<ul>
<li>
<p>使用<code>req.auth</code>获取用户信息</p>
<ul>
<li>当<code>express-jwt</code>这个中间件配置成功后，即可在那些有权限的接口中使用<code>req.auth</code>对象，来访问从 jwt 字符串中解出来的用户信息了</li>
</ul>
</li>
</ul>
<pre><code class="language-js">app.get("/admin/getinfo", (req, res) =&gt; {
	console.log(req.auth);
	res.send({
		status: 200,
		message: "获取用户信息成功！",
		data: req.auth,
	});
});
</code></pre>
<ul>
<li>
<p>捕获解析 jwt 失败后产生的错误</p>
<ul>
<li>
<p>当使用<code>express-jwt</code>解析<code>Token</code>时，如果客户端发送过来的<code>Token</code>过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</p>
</li>
<li>
<p>可以通过 Express 的错误中间件捕获这个错误并进行相关的处理</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">app.use((err, req, res, next) =&gt; {
	// token解析失败导致的错误
	if (err.name === "UnauthorizedError") {
		return res.send({
			status: 401,
			message: "无效的token",
		});
	}
	// 其他原因导致的错误
	res.send({ status: 500, message: "未知错误" });
});
</code></pre>
<img src="https://img2024.cnblogs.com/blog/3096011/202412/3096011-20241225222536358-1119133668.png" style="zoom: 65%">

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="16.709965703375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 23:15">2024-12-25 22:36</span>&nbsp;
<a href="https://www.cnblogs.com/iRuriCatt">iRuriCatt</a>&nbsp;
阅读(<span id="post_view_count">73</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18631580" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18631580);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18631580', targetLink: 'https://www.cnblogs.com/iRuriCatt/p/18631580', title: 'Nodejs（含js模块化+npm+express）' })">举报</a>
</div>
        