
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aisong/p/18922518" title="发布于 2025-06-10 17:26">
    <span role="heading" aria-level="2">按下 F12 打开开发者工具，它凭什么能监控所有网络请求？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3583746/202506/3583746-20250610172653583-1245113405.png" alt="按下 F12 打开开发者工具，它凭什么能监控所有网络请求？" class="desc_img">
        开发者工具（DevTools）明明只是浏览器的一个“面板”，它凭什么能像开了上帝视角一样，拦截和监控浏览器内核发出的所有网络请求？它和浏览器内核之间，到底藏着什么秘密通道？
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>兄弟们，咱们天天跟浏览器打交道，F12 可能比键盘上其他任何一个功能键按得都多。我们习惯了在 Network 面板里看着请求瀑布流，调试 API，分析性能。</p>
<p>但你有没有停下来，哪怕一次，问过自己一个问题：<strong>这玩意儿到底是怎么做到的？</strong></p>
<p>开发者工具（DevTools）明明只是浏览器的一个“面板”，它凭什么能像开了上帝视角一样，拦截和监控浏览器内核发出的所有网络请求？它和浏览器内核之间，到底藏着什么秘密通道？</p>
<p>今天，松哥就带你把这个最熟悉又最陌生的功能给彻底扒个底朝天。搞懂了它，你不仅能理解 DevTools，更能瞬间想通 Playwright、Puppeteer 这类自动化工具的核心原理。</p>
<h2 id="揭秘幕后大佬cdp">揭秘幕后大佬——CDP</h2>
<p>答案其实很简单，秘密通道的名字叫做 <strong>Chrome DevTools Protocol (CDP)</strong>。</p>
<p>你可以把 CDP 想象成一套浏览器内核（比如 Chromium）暴露出来的、功能极其强大的“调试 API”。而我们按 F12 打开的开发者工具，<strong>本质上就是 CDP 的第一个，也是最官方的一个客户端应用</strong>。</p>
<p>它俩的关系，就像是：</p>
<ul>
<li><strong>浏览器内核</strong>：一个强大的“服务器”，默默地处理着渲染页面、执行JS、发送请求等所有脏活累活。</li>
<li><strong>开发者工具</strong>：一个“客户端”，它通过 CDP 这条标准化的线路，向内核“服务器”发送指令（比如“给我所有网络请求的详细信息”）并接收内核推送的事件（比如“嘿，一个新的请求刚发生了！”）。</li>
</ul>
<p>所以，你在 Network 面板看到的一切，都不是什么魔法，而是 DevTools 这个客户端通过 CDP 协议，从浏览器内核那里“实时查询”和“订阅”来的数据。</p>
<h2 id="从-devtools-到-playwright-的权力交接">从 DevTools 到 Playwright 的“权力交接”</h2>
<p>好了，最关键的问题来了。既然 DevTools 可以通过 CDP 控制浏览器，那是不是意味着，<strong>任何程序只要学会了 CDP 这套“语言”，都能成为浏览器的“提线木偶师”？</strong></p>
<p>Bingo！你答对了！</p>
<p>这正是 Playwright、Puppeteer、go-rod 等所有现代自动化工具的核心工作模式。它们本质上，就是更强大的、为自动化而生的“第三方 CDP 客户端”。</p>
<p>现在，让我们回到那个熟悉又强大的 API：<code>Playwright.context.route()</code>。</p>
<p>当你写下这行代码，试图拦截某个请求时，Playwright 所做的事情，和 DevTools 在幕后的行为如出一辙，甚至更为深入。它利用了 CDP 中一个专门为此设计的“域”（Domain）—— <strong><code>Fetch</code> 域</strong>。</p>
<p>整个拦截流程，就像一场精心策划的“中间人干预”：</p>
<ol>
<li>
<p><strong>Playwright 下达“戒严令” (<code>Fetch.enable</code>)</strong><br>
当你调用 <code>context.route('**/*', ...)</code>，Playwright 会通过 CDP 连接向浏览器发送一个指令：<code>Fetch.enable</code>。这等于告诉浏览器：“喂，老兄，从现在起，所有网络请求你都别急着发，先暂停，等我通知。”</p>
</li>
<li>
<p><strong>浏览器“暂停”并“上报” (<code>Fetch.requestPaused</code>)</strong><br>
当页面即将发出一个请求，浏览器会检查并发现它处在“戒严”状态。于是，浏览器会立即“冻结”这个请求，然后通过 CDP 发送一个 <code>Fetch.requestPaused</code> 事件给 Playwright，并附上请求的所有细节（URL, Headers, Body...）。</p>
</li>
<li>
<p><strong>你（通过 Playwright）做出“裁决”</strong><br>
Playwright 收到这个事件后，将其封装成我们熟悉的 <code>route</code> 对象，然后调用你写的处理函数。此刻，你就是法官，可以决定这个请求的生死：</p>
<ul>
<li><strong><code>route.continue()</code> (放行)</strong>: Playwright 发送 <code>Fetch.continueRequest</code> 指令，浏览器接收后，将请求照常发出。</li>
<li><strong><code>route.fulfill()</code> (伪造)</strong>: Playwright 发送 <code>Fetch.fulfillRequest</code> 指令，并把你提供的假数据一起给浏览器。浏览器根本不会发出真实请求，而是直接用你的数据“假装”收到了一个响应。这对于 Mock 测试来说，简直是神技！</li>
<li><strong><code>route.abort()</code> (掐死)</strong>: Playwright 发送 <code>Fetch.failRequest</code> 指令，浏览器直接将这个请求作废。</li>
</ul>
</li>
</ol>
<p>看明白了吗？从 DevTools 的监控，到 Playwright 的拦截，它们共享着同一个技术基石——CDP。Playwright 的高明之处，在于把这些繁琐的 CDP 指令交互和事件监听，抽象成了一个极其干净、直观的 API。</p>
<p>我第一次想明白这个关联时，有种豁然开朗的感觉。这正是优秀框架的价值所在：<strong>把复杂的协议细节留给自己，把简单的编程体验交给用户。</strong></p>
<h2 id="cdp-就是终点吗不大戏还在后头">CDP 就是终点吗？不，大戏还在后头</h2>
<p>聊到这里，你可能会觉得 CDP 就是自动化领域的终极武器了。但从工程角度看，CDP 有一个致命的“原罪”：<strong>它是 Chrome 的“方言”，不是 W3C 的“普通话”</strong>。</p>
<p>这意味着，依赖 CDP 的脚本在跨浏览器（尤其是 Firefox, Safari）测试时，总会遇到各种兼容性问题。</p>
<p>因此，一个更宏大的叙事正在发生—— <strong>WebDriver BiDi (WebDriver Bidirectional)</strong> 的崛起。这是 W3C 联合所有浏览器厂商共同推出的下一代自动化标准，旨在结合传统 WebDriver 的跨浏览器优势和 CDP 的强大双向通信能力，成为真正的“世界语”。Playwright 和 Selenium 都在积极拥抱这个新标准。</p>
<h2 id="总结">总结</h2>
<p>今天，我们从一个简单的 F12 按键出发，揭开了它背后的秘密通道 CDP，然后发现这条通道不仅支撑着我们日常的调试工作，更是整个现代浏览器自动化生态系统的基石。</p>
<p>核心洞见是什么？</p>
<ol>
<li><strong>万变不离其宗</strong>：无论上层 API 设计得多么优雅（如 <code>context.route</code>），其底层能力都源于一个强大的协议（CDP）。理解这个协议，能让你在面对各种工具时，瞬间看透本质。</li>
<li><strong>抽象的价值</strong>：我们应该感谢像 Playwright 这样的框架。它让我们不必去手动处理复杂的 CDP 事件和指令，而是聚焦于业务逻辑本身。这是软件工程中“关注点分离”的完美体现。</li>
<li><strong>保持前瞻</strong>：技术永在演进。今天我们依赖 CDP，但明天 WebDriver BiDi 可能会成为新的主流。理解技术演进的“为什么”，比单纯记住一个 API 更重要。</li>
</ol>
<p>所以，下次当你再次按下 F12，看着网络请求列表时，希望你能想起它背后的 CDP。而当你写下 <code>await route.fulfill()</code> 时，更能会心一笑，因为你清楚地知道，在这行代码背后，一场浏览器、CDP 和 Playwright 之间的精彩对话正在上演。</p>
<hr>
<p>关注 <strong>【松哥AI自动化】</strong> 公众号，每周获取深度技术解析，从源码角度彻底理解各种工具的实现原理。更重要的是，遇到技术难题时，直接联系我！我会根据你的具体情况，提供最适合的解决方案和技术指导。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-10 17:27">2025-06-10 17:26</span>&nbsp;
<a href="https://www.cnblogs.com/aisong">松哥_ai_自动化</a>&nbsp;
阅读(<span id="post_view_count">50</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18922518);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18922518', targetLink: 'https://www.cnblogs.com/aisong/p/18922518', title: '按下 F12 打开开发者工具，它凭什么能监控所有网络请求？' })">举报</a>
</div>
        