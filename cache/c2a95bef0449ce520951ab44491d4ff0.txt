
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Colin-Cai/p/18791060" title="发布于 2025-06-12 12:13">
    <span role="heading" aria-level="2">有限Abel群的结构(2)</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        本节在上一节的基础上，解释循环群，Abel群，群同构，直积等概念，最终推导出给定阶数的所有Abel群结构，融合Python对其建模。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="cnblogs_Highlighter">
<pre class="brush:sql;gutter:true;">　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　 https://www.cnblogs.com/Colin-Cai/p/18791060.html

　　作者：窗户

　　QQ/微信：6679072

　　E-mail：6679072@qq.com</pre>
</div>
<p>本节在上一节的基础上，解释循环群，Abel群，群同构，直积等概念，最终推导出给定阶数的所有Abel群结构。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>循环群</strong></span></p>
<p>循环群是最简单的群，$n$阶循环群为$\{0,1,2...n-1\}$，符号记作$Z_n$，在此基础上定义乘法：</p>
<p>$a \cdot b = (a+b) \mod n$</p>
<p>这个是不是看上去很像加法？嗯，叫加法还是叫乘法还是叫其他什么都不重要，性质才重要。</p>
<p>此处的这个运算是可以交换的，也就是</p>
<p>$a \cdot b = b&nbsp;\cdot a$</p>
<p>在不引起误解的情况下，我们习惯上把这个称之为加法。</p>
<p>符号上，既然叫了加法，我们用$\oplus$来代替$\cdot$。</p>
<p>循环群就是$1$生成的群，</p>
<p>$1 \oplus 1 = 2$</p>
<p>$2 \oplus 1 = 3$</p>
<p>$...$</p>
<p>$(n-1) \oplus 1 = 0$</p>
<p>在符号不会发生混乱的情况下，我们就用$a+b$来表示加法。</p>
<p>加了一圈，得到了循环群里所有的元素，总共$n$个$1$相加得到$0$，显然$0$是幺元。</p>
<p>对于一个群里的元素$a$，如果$n$个$a$相乘(或相加)得到幺元，且$n$是满足这一点的最小正整数，则称$n$是$a$的<strong><span style="color: rgba(255, 0, 0, 1)">周期</span></strong>。</p>
<p>注意，周期这个术语是对于所有的群，并非只对于循环群。</p>
<p>此处，$n$是$1$的周期。</p>
<p>其实，循环群的定义就是可以由一个元(也就是$1$)生成的群。</p>
<p>对于有限循环群，那么就是存在某个元的周期等于阶数的群。</p>
<p>无限循环群则不是，$Z$覆盖了所有整数，其群加法就是整数加法，幺元为$0$，生成元为$1$。</p>
<p>对于这个生成元，或许有人会有疑问，无论多少个$1$加在一起也不会是负数啊，怎么可能所有的整数都由$1$生成呢。</p>
<p>在此，我要声明一下，逆元可以直接生成，所以$-1$可以由$1$生成，从而所有整数也都能生成了，此规则记住即可。</p>
<p>容易证明，对于$Z_n$，任何小于$n$的正整数$m$，在该循环群里的周期为$[m,n]/m$，此处$[m,n]$为最小公倍数。</p>
<p>所以，所有与n互质且小于n的正整数都可以是$Z_n$的生成元。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>Abel群</strong></span></p>
<p>Abel群即交换群，也就是满足乘法交换律的群。</p>
<p>也就是$&lt;G,\cdot&gt;$是Abel群是指</p>
<p>$\forall a,b \in G, a \cdot b = b \cdot a$</p>
<p>前面提到的循环群就是一种Abel群，那么，有不是循环群的Abel群吗？</p>
<p>我们来看2阶循环群$Z_2$</p>
<p>然后建立一个有4个元素的群</p>
<p>$\{(0,0),(0,1),(1,0),(1,1)\}$</p>
<p>其中乘法如下定义</p>
<p>$(a,b) \cdot (c,d) = (a \cdot c, b \cdot d)$</p>
<p>可以得知，$(0,0)$是该群的幺元，</p>
<p>$(a,b) \cdot (0,0) = (a \cdot 0, b \cdot 0) = (a,b) = (0 \cdot a, 0 \cdot b) = (0,0) \cdot (a, b)$</p>
<p>每个元的逆元是自身(源于$Z_2$的每个元逆元为自身)，实际上</p>
<p>$(a,b) \cdot (a,b) = (a \cdot a, b \cdot b) = (0,0)$</p>
<p>很显然也满足乘法交换律</p>
<p>$(a,b) \cdot (c,d) = (a \cdot c, b \cdot d) = (c \cdot a, d \cdot b) =&nbsp;(c,d) \cdot (a,b)$</p>
<p>所以这是一个Abel群。</p>
<p>然而，4阶循环群$Z_4$里的$1$的周期为4，而这个群里除幺元外所有的元素周期都为2，显然不是循环群。</p>
<p>那么，有非交换群吗？</p>
<p>有的，我们给出以下6元群。</p>
<p>$\{e,y,y^2,x,xy,xy^2\}$</p>
<p>其中，</p>
<p>$x^2=y^3=e$</p>
<p>$yx=xy^2$</p>
<p>生成乘法表如下</p>
<p>\begin{matrix}<br>\cdot&amp; e &amp; y &amp; y^2 &amp; x &amp; xy &amp; xy^2 \\<br>e    &amp; e &amp; y &amp; y^2 &amp; x &amp; xy &amp; xy^2 \\<br>y    &amp; y &amp; y^2 &amp; e &amp; xy^2 &amp; x &amp; xy\\<br>y^2  &amp; y^2 &amp; e &amp; y &amp; xy &amp; xy^2 &amp; x\\<br>x    &amp; x &amp; xy &amp; xy^2 &amp; e &amp; y &amp; y^2\\<br>xy   &amp; xy &amp; xy^2 &amp; x &amp; y^2  &amp; e &amp; y\\<br>xy^2 &amp; xy^2 &amp; x &amp; xy &amp; y &amp; y^2 &amp; e\\<br>\end{matrix}</p>
<p>可以验证，上面是一个群,</p>
<p>另外，这个乘法表的方阵并不是对称方阵，也就是，它并不是Abel群。</p>
<p>其实，这个群是阶数最小的非交换群，它是一个<strong><span style="color: rgba(255, 0, 0, 1)">二面体群</span></strong>，记作$D_3$，所谓$D_n$，是正$n$边形的所有<strong><span style="color: rgba(255, 0, 0, 1)">对称映射</span></strong><span style="color: rgba(0, 0, 0, 1)">构成的群</span>,$D_3$就是正三角形的对称映射群。</p>
<p>对称映射群，这个名字一下子不好理解，那就换个名字，就叫<strong><span style="color: rgba(255, 0, 0, 1)">全等群</span></strong>。</p>
<p>正n边形和自身有多少种不同的全等？</p>
<p>顺时针方向：</p>
<p>$S_{A_1,A_2,...A_n} \cong&nbsp;S_{A_1,A_2,...A_n}$</p>
<p>$S_{A_1,A_2,...A_n} \cong S_{A_2,A_3,...A_n,A_1}$</p>
<p>$...$</p>
<p>$S_{A_1,A_2,...A_n} \cong&nbsp;S_{A_n,A_1,...A_{n-1}}$</p>
<p>逆时针方向：</p>
<p>$S_{A_1,A_2,...A_n} \cong&nbsp;S_{A_1,A_n,...A_2}$</p>
<p>$S_{A_1,A_2,...A_n} \cong&nbsp;S_{A_2,A_1,A_n...A_3}$</p>
<p>$...$</p>
<p>$S_{A_1,A_2,...A_n} \cong&nbsp;S_{A_n,A_{n-1},...A_1}$</p>
<p>总共$2n$个全等。</p>
<p>另外，</p>
<p>$D_3 \cong S_3$</p>
<p>$S_3$是3阶对称群，也就是3个元素所有的置换组成的群。</p>
<p>&nbsp;</p>
<p><strong style="font-size: 18pt">群同构</strong></p>
<p>一般群论教材里会先讲群同态，再把群同构当成群同态的一种，其中可以引入同态定理，但那是一本正经的讲法。</p>
<p>我这里只是讲个大致，所以同态我直接滤过了。</p>
<p>其实同构才是拍下脑袋就能明白的东西，因为它实在太自然了。</p>
<p>同构同构，顾名思义，就是同样的结构。研究一个群，代表所有与之同构的群的性质。</p>
<p>先看看数学符号，群$a$和群$b$同构记作$a \cong b$</p>
<p>即便没学过高等数学的中学生，也会知道这个符号在平面几何、立体几何里指图形的全等，也就是性质完全一模一样。</p>
<p>我们以数学的直觉，来想想什么样的两个群称为同构呢。</p>
<p>群有两个东西，一个是里面的元素集合，一个是构建在元素集合上的二元运算。</p>
<p>我们甚至可以超越群的限制，想象一下什么叫$&lt;G_1,f_1&gt; \cong &lt;G_2,f_2&gt;$，</p>
<p>其中，$f_1$是集合$G_1$上的二元运算，$f_2$是集合$G_2$上的二元运算，</p>
<p>不一定需要构成群。</p>
<p>那么，应该是在一一对应下两者的所有表现一模一样。那么应该是：</p>
<p>对于一一对应$f:G_1\rightarrow G_2$</p>
<p>$\forall a, b \in G_1:f(a\cdot _{1}b)=f(a)\cdot _{2} f(b)$</p>
<p>上一章里，求出的群有很多同构，那么我们如何让同构的群只出一个即可呢？</p>
<p>最简单的方法，就是构造一个过滤条件，每当新出一个群，就看看是否和之前出过的群同构，</p>
<p>还是用方阵(array下用一维来模拟二维)来代表二元运算，以下函数用来判断同构，op1/op2则是代表二元运算的方阵。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> array
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> itertools as it

</span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> is_isomp(s, op1, op2):
    n </span>=<span style="color: rgba(0, 0, 0, 1)"> len(s)
    make_mul </span>= <span style="color: rgba(0, 0, 255, 1)">lambda</span> op : <span style="color: rgba(0, 0, 255, 1)">lambda</span> a, b : op[a * n +<span style="color: rgba(0, 0, 0, 1)"> b]
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">将矩阵op1和op2转化成真正的函数</span>
    mul_op1 =<span style="color: rgba(0, 0, 0, 1)"> make_mul(op1)
    mul_op2 </span>=<span style="color: rgba(0, 0, 0, 1)"> make_mul(op2)
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">将排列转换成一一对应</span>
    f = <span style="color: rgba(0, 0, 255, 1)">lambda</span><span style="color: rgba(0, 0, 0, 1)"> n : s[n]
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">遍历所有的乘法</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> a, b <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> it.product(range(n), range(n)):
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">如果发现不满足,当然不是同构</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> f(mul_op1(a, b)) !=<span style="color: rgba(0, 0, 0, 1)"> mul_op2(f(a), f(b)):
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> False
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">如果发现当前一一对应满足同构,那么就返回构成同构</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> True

</span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> isomp(n, op1, op2):
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">遍历所有的一一对应,所有的一一对应其实和所有的n全排序一一对应</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> s <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> it.permutations(range(n)):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> is_isomp(s, op1, op2):
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> True
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> False</pre>
</div>
<p>我们看看之前$D_3$在上一节里表示乘法的array该是什么</p>
<p>首先，我们让$e,y,y^2,x,xy,xy^2$分别对应$0,1,2,3,4,5$，那么乘法表矩阵应该是</p>
<p>\begin{matrix}<br>0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\<br>1 &amp; 2 &amp; 0 &amp; 5 &amp; 3 &amp; 4\\<br>2 &amp; 0 &amp; 1 &amp; 4 &amp; 5 &amp; 3\\<br>3 &amp; 4 &amp; 5 &amp; 0 &amp; 1 &amp; 2\\<br>4 &amp; 5 &amp; 3 &amp; 2 &amp; 0 &amp; 1\\<br>5 &amp; 3 &amp; 4 &amp; 1 &amp; 2 &amp; 0\\<br>\end{matrix}</p>
<p>显然任何一个群，在恒等映射下一定是同构的，这种同构是平凡的，也就是没啥大的意义。</p>
<p>我们用程序搜一下:</p>
<div class="cnblogs_code">
<pre>op = array.array(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">i</span><span style="color: rgba(128, 0, 0, 1)">'</span>, [0, 1, 2, 3, 4, 5<span style="color: rgba(0, 0, 0, 1)">,
                       </span>1, 2, 0, 5, 3, 4<span style="color: rgba(0, 0, 0, 1)">,
                       </span>2, 0, 1, 4, 5, 3<span style="color: rgba(0, 0, 0, 1)">,
                       </span>3, 4, 5, 0, 1, 2<span style="color: rgba(0, 0, 0, 1)">,
                       </span>4, 5, 3, 2, 0, 1<span style="color: rgba(0, 0, 0, 1)">,
                       </span>5, 3, 4, 1, 2<span style="color: rgba(0, 0, 0, 1)">, 0])
</span><span style="color: rgba(0, 0, 255, 1)">for</span> s <span style="color: rgba(0, 0, 255, 1)">in</span> it.permutations(range(6<span style="color: rgba(0, 0, 0, 1)">)):
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> is_isomp(s, op, op):
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(s)</pre>
</div>
<p>得到所有构成同构的一一对应：</p>
<p>(0, 1, 2, 3, 4, 5)<br>(0, 1, 2, 4, 5, 3)<br>(0, 1, 2, 5, 3, 4)<br>(0, 2, 1, 3, 5, 4)<br>(0, 2, 1, 4, 3, 5)<br>(0, 2, 1, 5, 4, 3)</p>
<p>这种同构是一个群自己到自己的映射，称为自同构。</p>
<p>一个群所有的自同构其实也构成一个群，称为自同构群。</p>
<p>$D_3$和$D_3$的自同构群(可记作$Aut(D_3)$)恰好同构：</p>
<div class="cnblogs_code">
<pre>op = array.array(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">i</span><span style="color: rgba(128, 0, 0, 1)">'</span>, [0, 1, 2, 3, 4, 5<span style="color: rgba(0, 0, 0, 1)">,
                       </span>1, 2, 0, 5, 3, 4<span style="color: rgba(0, 0, 0, 1)">,
                       </span>2, 0, 1, 4, 5, 3<span style="color: rgba(0, 0, 0, 1)">,
                       </span>3, 4, 5, 0, 1, 2<span style="color: rgba(0, 0, 0, 1)">,
                       </span>4, 5, 3, 2, 0, 1<span style="color: rgba(0, 0, 0, 1)">,
                       </span>5, 3, 4, 1, 2<span style="color: rgba(0, 0, 0, 1)">, 0])
</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">ss装下所有的D3上的自同构置换</span>
ss =<span style="color: rgba(0, 0, 0, 1)"> []
</span><span style="color: rgba(0, 0, 255, 1)">for</span> s <span style="color: rgba(0, 0, 255, 1)">in</span> it.permutations(range(6<span style="color: rgba(0, 0, 0, 1)">)):
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> is_isomp(s, op, op):
        ss.append(list(s))

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">两个置换的乘积</span>
<span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> mul(a, b):
    r </span>= [0] *<span style="color: rgba(0, 0, 0, 1)"> len(a)
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(len(b)):
        r[i] </span>=<span style="color: rgba(0, 0, 0, 1)"> a[b[i]]
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> r

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">op_aut是D3自同构群的乘法表</span>
op_aut = array.array(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">i</span><span style="color: rgba(128, 0, 0, 1)">'</span>, [0] * 36<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">for</span> i, a <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> enumerate(ss):
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> j, b <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> enumerate(ss):
        c </span>=<span style="color: rgba(0, 0, 0, 1)"> mul(a, b)
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> k, s <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> enumerate(ss):
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> c ==<span style="color: rgba(0, 0, 0, 1)"> s:
                op_aut[i </span>* 6 + j] =<span style="color: rgba(0, 0, 0, 1)"> k
                </span><span style="color: rgba(0, 0, 255, 1)">break</span>
<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">以下判断D3和D3自同构群两者同构与否</span>
<span style="color: rgba(0, 0, 255, 1)">print</span>(isomp(6, op, op_aut))</pre>
</div>
<p>不过关于自同构群属于题外话，不深入讲了。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>子群</strong></span></p>
<p>如果一个群内部的一部分元素在该群的乘法下也构成一个群，那么这个群则叫<strong><span style="color: rgba(255, 0, 0, 1)">子群</span></strong>(subgroup)。</p>
<p>很明显，子群中必然包含原群的幺元作为幺元。</p>
<p>比如之前的二面体群$D_3$中，</p>
<p>$\{e,x\}$</p>
<p>$\{e,y,y^2\}$</p>
<p>$\{e,xy\}$</p>
<p>$\{e,xy^2\}$</p>
<p>在原乘法下，都是$D_3$的子群，注意，这些群都是循环群。</p>
<p>另外，$\{e\}$和$\{e,y,y^2,x,xy,xy^2\}$也是$D_3$的子群，只是这是每个群都有的，也就是平凡的，没什么特殊意义。</p>
<p>对于$n$阶循环群，如果$m$是$n$的正约数，则该循环群有$m$阶子群，</p>
<p>实际上，$n/m$生成的群，就是$n$阶循环群的$m$阶子群，当然子群也是循环群。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>直积</strong></span></p>
<p>这是一种用群构建群的方式。</p>
<p>如果$&lt;G_1,\cdot_1&gt;$和$&lt;G_2,\cdot_2&gt;$都是群，</p>
<p>那么集合$G=\{(a,b)|a \in G_1,b \in G_2\}$</p>
<p>配合以下乘法</p>
<p>$(a_1,b_1) \cdot (a_2,b_2)=(a_{1}\cdot_{1} a_2,b_{1}\cdot_{2}b_2)$</p>
<p>我们来看一下它为什么是一个群。</p>
<p>首先，对于任意$G$下$(a,b),(c,d),(e,f)$，</p>
<p>$(a,b)\cdot(c,d) \cdot (e,f)$</p>
<p>$=(a\cdot_{1}c,b\cdot_{2}d)\cdot(e,f)$</p>
<p>$=(a\cdot_{1}c\cdot_{1}e,b\cdot_{2}d\cdot_{2}f)$</p>
<p>$=(a\cdot_{1}(c\cdot_{1}e),b\cdot_{2}(d\cdot_{2}f))$</p>
<p>$=(a,b)\cdot(c\cdot_{1}e,d\cdot_{2}f)$</p>
<p>$=(a,b)\cdot((c,d)\cdot(e,f))$</p>
<p>满足结合律，</p>
<p>对于任意$G$下$(a,b)$，</p>
<p>假设$e_1$和$e_2$是原群的幺元,</p>
<p>$(a,b)\cdot (e_1,e_2) = (a,b) = (e_1,e_2)\cdot (a,b)$</p>
<p>所以$(e_1,e_2)$是幺元,</p>
<p>$(a,b)\cdot (a^{-1},b^{-1}) = (e_1,e_2) =&nbsp;(a^{-1},b^{-1}) \cdot (a,b)$</p>
<p>所以$(a^{-1},b^{-1})$是逆元，</p>
<p>根据群的定义，这个新的代数结构的确是群，称为两个群的<strong><span style="color: rgba(255, 0, 0, 1)">外直积</span></strong><span style="color: rgba(0, 0, 0, 1)">。<strong><br></strong></span></p>
<p>为了研究群的内部结构，我们引入<span style="color: rgba(255, 0, 0, 1)"><strong>内直积</strong></span>，这样直积前的两个群都是最终得到的群的子集。</p>
<p>如果$&lt;G_1,\cdot_1&gt;$和$&lt;G_2,\cdot_2&gt;$都是群，</p>
<div>且$G_1 \cap G_2 = \{e\}$</div>
<p>那么，集合$G=\{a\cdot b|a \in G_1,b\in G_2\}$满足</p>
<p>$a_{1},a_{2} \in G_{1} \land b_{1},b_{2} \in G_{2} \land a_{1} \cdot b_{1} = a_{2} \cdot b_{2} \Rightarrow a_{1} = a_{2} \land b_{1} = b_{2}$</p>
<p>再加上相应的乘法就是内直积得到的群，</p>
<p>对于乘法，原$G_1$里的元和原$G_2$里的元两者乘法可交换，</p>
<p>那么，对于$a,c \in G_1, b,d \in G_2$，</p>
<p>$(a\cdot b) \cdot (c\cdot d)$</p>
<p>$=a\cdot b \cdot c \cdot d$</p>
<p>$=a\cdot (b \cdot c) \cdot d$</p>
<p>$=a\cdot (c \cdot b) \cdot d$</p>
<p>$=a\cdot c \cdot b \cdot d$</p>
<p>$=(a\cdot c) \cdot (b \cdot d)$</p>
<p>外直积和内直积得到的结果实际上是<strong><span style="color: rgba(255, 0, 0, 1)">同构</span></strong>的，所以从研究的角度来说，是可以替代的。</p>
<p>我们再回头看看$D_3$，它也有$\{e,x\}$和$\{e,y,y^2\}$两个子群，</p>
<p>但它并不是这两个子群的直积，因为第一个群的$x$和第二个群的$y$乘法不可交换。</p>
<p>另外，两个Abel群的直积依然是Abel群，这个很容易证明，这一条与本系列所要讨论的Abel群的结构有直接关系。</p>
<p>还是给直积一个符号以便后面叙述吧，记群$G_1$和群$G_2$的直积为$G_1\otimes G_2$</p>
<p>&nbsp;</p>
<div><strong><span style="font-size: 18pt">循环群内直积的条件</span></strong></div>
<p>我们现在考虑有限Abel群的<span style="color: rgba(255, 0, 0, 1)"><strong>生成元</strong></span>。</p>
<p>如果从群$G$中取$n$个元可以生成$G$，</p>
<p>暂时记作$G=&lt;a_1,a_2,...a_n&gt;$</p>
<p>因为Abel群满足乘法交换律，那么$G$中任意的元$g$都可以写成以下的形式:</p>
<p>$g = k_1*a_1+k_2*a_2+...k_n*a_n$</p>
<p>其中，$k*a$中$k$是小于$a$周期的自然数，</p>
<p>意思为$k$个$a$相乘(加)的结果。再重申一次，对于Abel群(也就是可交换群)，我们可以把里面的乘法叫加法，所以这里使用加号。</p>
<p>其中，如果存在一组$k_1,k_2...k_n$</p>
<p>使得$k_1*a_1+k_2*a_2+...k_n*a_n = 0$</p>
<p> 那么$k_1*a_1,k_2*a_2,...kn*an$必然全为$0$</p>
<p>在这种情况下，对于任意$k_1*a_1+k_2*a2+...k_n*a_n$和$j_1*a_1+j_2*a2+...j_n*a_n$</p>
<p>两者相减为$(k_1 - j_1)*a_1+(k_2-j_2)*a_2+...(k_n-j_n)*a_n$</p>
<p>相减为$0$则意味着$(k_1 - j_1)*a_1=0\land (k_2 - j_2)*a_2=0 \land&nbsp;(k_n - j_n)*a_n=0$</p>
<p>根据上面条件，我们发现两者相等只有在各项相等的情况下。</p>
<p>并且本身就是Abel群，两者当然也是乘法可交换的。</p>
<p>从而，$G$是$&lt;a_1&gt;,&lt;a_2&gt;,...&lt;a_n&gt;$这些循环群的<span style="color: rgba(255, 0, 0, 1)"><strong>内直积</strong></span></p>
<p>也就是$G=&lt;a_1&gt;\otimes&lt;a_2&gt;\otimes ...&lt;a_n&gt;$</p>
<p>&nbsp;</p>
<p>另外，对于Abel群$G=&lt;a_1,a_2,...a_n&gt;$</p>
<p>如果存在$k_1*a_1,k_2*a_2,...k_n*a_n$不全为$0$使得$k_1*a_1+k_2*a_2+...k_n*a_n = 0$</p>
<p>那么$a_1,a_2,...a_n$中必然存在一个元可以被其他元<span style="color: rgba(255, 0, 0, 1)"><strong>线性表出</strong></span>，这其实是线性代数的基本功，回忆一下无关线性向量组相关的知识，再加上联系到此处各个元的周期有限，应该不难证明，此处省略证明留给读者。</p>
<p>于是可以找到少一个元生成整个群。</p>
<p>如此不断剔除多余的生成元下去，最终总可以找到满足开始的条件，也就是无论如何，有限Abel群都可以表示为循环群直积的形式。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>循环群直积的标准化</strong></span></p>
<p>现在我们再来考虑一个例子，</p>
<p>假如一个6元的Abel群我们发现同构于$Z_2 \otimes Z_3$</p>
<p>我们用外直积可能更容易理解，</p>
<p>它的六个元分别是</p>
<p>$(e,e),(e,b),(e,b^2),(a,e),(a,b),(a,b^2)$</p>
<p>其中$a$周期为$2$，$b$周期为$3$</p>
<p>结果发现里面有一个周期为6的元素$(a,b)$，结果其实它同构于$Z_6$</p>
<p>我们当然更喜欢直接到位用$Z_6$就能很清楚的明白它的结构了。</p>
<p>这就意味着我们虽然可以有办法把Abel群表示为循环群的直积，但仍需要进一步化简。</p>
<p>&nbsp;</p>
<p>我们考虑$Z_m \otimes Z_n$</p>
<p>为了明白起见，我们还是用外直积来理解。</p>
<p>考虑它有两个生成元$(a,e)$和$(e,b)$</p>
<p>其中$a$周期为$m$，$b$周期为$n$</p>
<p>显然，$(a,b)$的周期是$m$和$n$最小公倍数，记作$lcm(m,n)$。</p>
<p>另，$m$和$n$最大公约数，记作$gcd(m,n)$。</p>
<p>我们有</p>
<p>$lcm(m*n) = m/gcd(m,n)*n = n/gcd(m,n)*m$</p>
<p>其中，$m/gcd(m,n)$和$n/gcd(m,n)$都是正整数，</p>
<p>又显然，对于其他任何元$(k_1*a,k_2*b)$</p>
<p>$lcm(m*n)*(k_1*a,k_2*b)$</p>
<p>$=((lcm(m*n)*k_1)*a,(lcm(m*n)*k_2)*b)$</p>
<p>$=((n/gcd(m,n)*m*k_1)*a,(m/gcd(m,n)*n*k_2)*b)$</p>
<p>$=(n/gcd(m,n)*k_1*(m*a),m/gcd(m,n)*k_2*(n*b))$</p>
<p>$=(e,e)$</p>
<p>&nbsp;这意味着$(a,b)$有着整个群里最大的周期。</p>
<p>不难得出，</p>
<p>$(m/gcd(m,n)*a,n/gcd(m,n)*b)$和$(a,b)$可以作为整个群的生成元</p>
<p>具体证明读者自行去证，提示一下，需要用到以下命题：</p>
<p>对于任意正整数$m$，$n$，存在整数$p$和$q$，使得</p>
<p>$mp+nq=gcd(m,n)$</p>
<p>&nbsp;</p>
<p>$(a,b)$周期为$lcm(m,n)$，</p>
<p>$(m/gcd(m,n)*a,n/gcd(m,n)*b)$周期为$gcd(m,n)$</p>
<p>所以$Z_m \otimes Z_n \cong Z_{gcd(m,n)} \otimes Z_{lcm(m,n)}$</p>
<p>注意，$lcm(m,n)$是整个群最大的周期，并且$gcd(m,n)$是$lcm(m,n)$的约数。</p>
<p>另外，对于平凡的直积</p>
<p>$Z_1 \otimes Z_n \cong Z_n$</p>
<p>可以去掉$Z_1$项</p>
<p>又因为直积满足交换之后依然同构，</p>
<p>于是对于$Z_{k_1} \otimes Z_{k_2} \otimes ... Z_{k_n}$的化简，可以如下这样两层循环进行，可以使得最终为一组循环群的直积，满足左边循环群的阶数是右边循环群阶数的约数。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">最大公约数</span>
<span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> gcd(m, n):
    </span><span style="color: rgba(0, 0, 255, 1)">while</span><span style="color: rgba(0, 0, 0, 1)"> True:
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> n ==<span style="color: rgba(0, 0, 0, 1)"> 0:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> m
        m </span>%=<span style="color: rgba(0, 0, 0, 1)"> n
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> m ==<span style="color: rgba(0, 0, 0, 1)"> 0:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> n
        n </span>%=<span style="color: rgba(0, 0, 0, 1)"> m

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">最小公倍数</span>
<span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> lcm(m, n):
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> m * n //<span style="color: rgba(0, 0, 0, 1)"> gcd(m, n)

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">标准化</span>
<span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> trans(k):
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">复制k数组</span>
    a = [n <span style="color: rgba(0, 0, 255, 1)">for</span> n <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> k]
    length </span>=<span style="color: rgba(0, 0, 0, 1)"> len(a) 
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">两轮循环化简</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> n <span style="color: rgba(0, 0, 255, 1)">in</span> range(length - 1<span style="color: rgba(0, 0, 0, 1)">):
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> m <span style="color: rgba(0, 0, 255, 1)">in</span> range(n + 1<span style="color: rgba(0, 0, 0, 1)">, length):
            a[n], a[m] </span>=<span style="color: rgba(0, 0, 0, 1)"> gcd(a[n], a[m]), lcm(a[n], a[m])
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">剔除掉1</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(length):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> a[i] != 1<span style="color: rgba(0, 0, 0, 1)">:
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> a[i:]
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> a</pre>
</div>
<p>比如我们想要标准化$Z_{6} \otimes Z_{10} \otimes Z_{15} \otimes Z_{20}$</p>
<p>simplify([6,10,15, 20]) =&gt; [10, 30, 60]</p>
<p>也就是$Z_{10} \otimes Z_{30} \otimes Z_{60}$</p>
<p>以上的结果可以看出，运算到最后，前面的数字是后面数字的约数，并且不存在1，这个表示对于这个群是唯一的。</p>
<p>于是我们就根据此得到给定阶数的Abel群所有的同构。</p>
<p>以72阶Abel群为例，我们分解72为大于1的整数乘积，满足左边是右边的约数，可以穷举出72阶Abel群所有的同构如下：</p>
<p>$Z_{72}$</p>
<p>$Z_2 \otimes Z_{36}$</p>
<p>$Z_3 \otimes Z_{24}$</p>
<p>$Z_6 \otimes Z_{12}$</p>
<p>$Z_2 \otimes Z_2 \otimes Z_{18}$</p>
<p>$Z_2 \otimes Z_6&nbsp;\otimes Z_6$</p>
<p>&nbsp;</p>
<p>下一节我们设计程序来穷举给定阶数Abel群的所有同构。</p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.03194444444444444" data-date-updated="2025-06-12 12:59">2025-06-12 12:13</span>&nbsp;
<a href="https://www.cnblogs.com/Colin-Cai">窗户</a>&nbsp;
阅读(<span id="post_view_count">113</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18791060);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18791060', targetLink: 'https://www.cnblogs.com/Colin-Cai/p/18791060', title: '有限Abel群的结构(2)' })">举报</a>
</div>
