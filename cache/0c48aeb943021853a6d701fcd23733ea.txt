
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/keysky/p/18688268" title="发布于 2025-01-23 17:38">
    <span role="heading" aria-level="2">「SPOJ2666」QTREE4 - Query on a tree IV</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="题目概述">题目概述</h2>
<p>对一棵树维护两种操作：翻转某个点的颜色，求 <span class="math inline">\(max\{ dist_{u, v} \}\)</span> 且满足 <span class="math inline">\(u\)</span> 的颜色和 <span class="math inline">\(v\)</span> 的颜色都是白色（ <span class="math inline">\(u,v\)</span> 可以相同）。</p>
<h2 id="思路">思路</h2>
<p>首先考虑若没有修改，给定带颜色的 <span class="math inline">\(N\)</span> 个点怎么查询。<br>
经典办法是树形 <span class="math inline">\(\text{dp}\)</span> ，定义<span class="math inline">\(mx_u\)</span> 表示在 <span class="math inline">\(u\)</span> 的子树中从 <span class="math inline">\(u\)</span> 出发距离最远的白点的距离，<span class="math inline">\(se_u\)</span> 表示在 <span class="math inline">\(u\)</span> 的子树中从 <span class="math inline">\(u\)</span> 出发且不进入 <span class="math inline">\(mx_u\)</span> 表示白点的子树距离最远的白点的距离，最后答案就是</p>
<p></p><div class="math display">\[\max_{ u \in [1, n] }\{ mx_u + se_u \}
\]</div><p></p><p>现在考虑动态维护这一个 <span class="math inline">\(\text{dp}\)</span> ，由于修改结点 <span class="math inline">\(u\)</span> 的颜色后更新 <span class="math inline">\(dp\)</span> 状态是在从 <span class="math inline">\(u\)</span> 到根结点的链上更新 <span class="math inline">\(\text{dp}\)</span> 值，同时 <span class="math inline">\(\text{dp}\)</span> 的更新可以写作线段树的合并区间类型，所以可以考虑使用树链剖分，这样对于从 <span class="math inline">\(u\)</span> 更新到根结点最多只会经过 <span class="math inline">\(\log N\)</span> 条重链，同时线段树上的单点修改，区间合并花费 <span class="math inline">\(O(\log N)\)</span> ，可以在 <span class="math inline">\(O(N log^2 N)\)</span> 的时间内完成此题。</p>
<h2 id="做法">做法</h2>
<p>对于结点 <span class="math inline">\(u\)</span> 记录 <span class="math inline">\(mx(u)\)</span> 表示在 <span class="math inline">\(u\)</span> 的子树中从 <span class="math inline">\(u\)</span> 出发且不走中重子结点距离最远的白点的距离，<span class="math inline">\(se(u)\)</span> 表示在 <span class="math inline">\(u\)</span> 的子树中从 <span class="math inline">\(u\)</span> 出发且不进入 <span class="math inline">\(mx(u)\)</span> 表示白点的子树和 <span class="math inline">\(u\)</span> 的重子结点距离最远的白点的距离，如果不存在，都记为 <span class="math inline">\(- \infty\)</span> 。</p>
<h3 id="概述">概述</h3>
<p>首先对树进行轻重链剖分。</p>
<p>因为每一条重链在 <span class="math inline">\(\text{dfs}\)</span> 序上都是一段连续的区间，所以对于每一条重链开一棵线段树维护 <span class="math inline">\(\text{dfs}\)</span> 序上的区间信息。</p>
<p>对于线段树上某一点维护区间 <span class="math inline">\([l, r]\)</span> 定义</p>
<ul>
<li><span class="math inline">\(topdis\)</span> :从 <span class="math inline">\(dfs\)</span> 序为 <span class="math inline">\(l\)</span> 的点，即当前区间所表示的链的顶端向其子树出发，不进入 <span class="math inline">\(dfs\)</span> 序为 <span class="math inline">\(r\)</span> 的重子结点的子树所能到达的最远的白点的距离</li>
<li><span class="math inline">\(bottomdis\)</span> :从 <span class="math inline">\(dfs\)</span> 序为 <span class="math inline">\(r\)</span> 的点，即当前区间所表示的链的底端出发，只在 <span class="math inline">\(dfs\)</span> 序为 <span class="math inline">\(l\)</span> 的子树中前进所能到达的最远的白点的距离</li>
<li><span class="math inline">\(val\)</span> :记 <span class="math inline">\(dis(u, v)\)</span> 表示 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的距离，原树中所有满足 <span class="math inline">\(dfn_{\text{LCA}(u, v)} \in [l, r]\)</span> 的点对 <span class="math inline">\((u, v)\)</span> 中最大的 <span class="math inline">\(dis(u, v)\)</span></li>
</ul>
<p>因为要开多棵线段树，所以要动态开点，同时记录 <span class="math inline">\(rt_u\)</span> 表示以 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(top\)</span> 的重链的线段树的根结点编号。</p>
<p>现在假设我们已经维护好所有线段树（画大饼，展望未来），设 <span class="math inline">\(val_i\)</span> 表示重链 <span class="math inline">\(i\)</span> 的线段树的根结点的 <span class="math inline">\(val\)</span>（<span class="math inline">\(i\)</span> 为该重链的 <span class="math inline">\(top\)</span>），那么答案就是 <span class="math inline">\(\max_{ i \in \{ u | \exists v, top_v = u \}} \{ val_i \}\)</span> 。</p>
<h3 id="树链剖分">树链剖分</h3>
<h4 id="维护">维护</h4>
<p>先来聊聊线段树中的区间合并，设当前区间为 <span class="math inline">\([l, r]\)</span> ，结点为 <span class="math inline">\(id\)</span>，定义 <span class="math inline">\(dis(u, v)\)</span> 表示 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的距离，左儿子为 <span class="math inline">\(ls\)</span> ，右儿子为 <span class="math inline">\(rs\)</span>，<span class="math inline">\(rnk_i\)</span> 表示 <span class="math inline">\(dfs\)</span> 序为 <span class="math inline">\(i\)</span> 的结点编号，对于 <span class="math inline">\(topdis\)</span> ，我们可以直接继承左儿子的 <span class="math inline">\(topdis\)</span> ,也可以走过整段左儿子表示的链进入右儿子，并走右儿子的 <span class="math inline">\(topdis\)</span> 。即</p>
<p></p><div class="math display">\[topdis_{id} \leftarrow max( topdis_{ls} , dis(rnk_l, rnk_{mid + 1}) + topdis_{rs})
\]</div><p></p><p>像这样<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/2qzrdx67.png" alt="合并topdis" loading="lazy"><br>
可走路径即图中的红色路径或粉色路径+绿色路径+蓝色路径，对应合并时取 <span class="math inline">\(max\)</span> 的两个数。</p>
<p><span class="math inline">\(bottomdis\)</span>同理，即</p>
<p></p><div class="math display">\[bottomdis_{id} \leftarrow max( bottomdis_{rs} , dis(rnk_{mid}, rnk_r) + bottomdis_{ls})
\]</div><p></p><p>对于 <span class="math inline">\(val\)</span> ，我们可以继承左右儿子的 <span class="math inline">\(val\)</span> ，也可以从左儿子中的点走到右儿子中，即走左儿子的 <span class="math inline">\(bottomdis\)</span> ，过 <span class="math inline">\((mid, mid + 1)\)</span> ，走右儿子的 <span class="math inline">\(topdis\)</span> ，转移即</p>
<p></p><div class="math display">\[val_{id} \leftarrow \max \{ val_{ls}, val_{rs}, bottomdis_{ls} + dis(rnk_{mid}, rnk_{mid + 1}) + topdis_{rs} \}
\]</div><p></p><p>对于线段树中的叶子结点 <span class="math inline">\(u\)</span>，可以利用 <span class="math inline">\(mx(u)\)</span> 和 <span class="math inline">\(se(u)\)</span> 更新。</p>
<p>因为 <span class="math inline">\(mx(u)\)</span> 和 <span class="math inline">\(se(u)\)</span> 的定义都不局限于当前重链，所以在更新当前重链前要把挂在该重链上的所有重链更新完，这一点乍一想很恶心，其实只需要对于 <span class="math inline">\(dfs\)</span> 序反过来遍历并依次建树，因为对于挂在某条重链上的所有重链一定是在该重链遍历完再进行遍历（至少我的写法是这样）。</p>
<p>假设知道了 <span class="math inline">\(mx(u)\)</span> 和 &amp;se(u)&amp; ，我们怎么更新 <span class="math inline">\(u\)</span> 呢？我们分两种情况讨论：</p>
<ul>
<li>结点 <span class="math inline">\(rnk_u\)</span> 为白色，<span class="math inline">\(topdis_u, bottomdis_u \leftarrow max(mx(rnk_u), 0)\)</span> ，因为可以以 <span class="math inline">\(rnk_u\)</span> 为起点和终点，所以与 <span class="math inline">\(0\)</span> 取 <span class="math inline">\(max\)</span>（后面就不解释了），<span class="math inline">\(val_u \leftarrow \max \{ mx(rnk_u), mx(rnk_u) + se(rnk_u), 0 \}\)</span></li>
<li>结点 <span class="math inline">\(rnk_u\)</span> 为黑色，<span class="math inline">\(topdis_u, bottomdis_u \leftarrow mx(rnk_u), val_u \leftarrow mx(rnk_u), mx(rnk_u) + se(rnk_u)\)</span></li>
</ul>
<p><span class="math inline">\(mx(rnk_u)\)</span> 表示以 <span class="math inline">\(rnk_u\)</span> 作为路径结尾的答案，<span class="math inline">\(mx(rnk_u) + se(rnk_u)\)</span> 表示将以 <span class="math inline">\(rnk_u\)</span> 为路径结尾的两条路径拼起来的答案。</p>
<p>现在考虑维护 <span class="math inline">\(mx(u)\)</span> 和 <span class="math inline">\(se(u)\)</span> ，由于我们会删除或加入白色点，所以用一个支持随机删除的堆来维护，这里我们可以偷懒使用<span class="math inline">\(\text{STL}\)</span> 中的<code>multiset</code>，对每一个结点开一个堆，初始化时遍历 <span class="math inline">\(u\)</span> 的轻儿子，用已更新好的重链来更新 <span class="math inline">\(u\)</span> ，设 <span class="math inline">\(v\)</span> 为 <span class="math inline">\(u\)</span> 的轻儿子， <span class="math inline">\(id\)</span> 为 <span class="math inline">\(v\)</span> 所在重链的线段树的根结点，即插入 <span class="math inline">\(topdis_{id} + dis(u, v)\)</span> 到 <span class="math inline">\(u\)</span> 的堆中。</p>
<h4 id="查询">查询</h4>
<p>对于每一条重链都会诞生一个答案，同时会实时修改，因为我们已经维护了一个支持随机删除和插入的堆，所以可以直接定义一个堆 <span class="math inline">\(ans\)</span> 表示所有重链的答案的集合，查询时直接取出 <span class="math inline">\(ans\)</span> 的堆顶元素即可。</p>
<h4 id="修改">修改</h4>
<p>与树链剖分的板子相同，不过只有一个点 <span class="math inline">\(u\)</span> ，所以单说跳的部分更简洁，但对于修改其实更加复杂。</p>
<p>首先，对于当前点 <span class="math inline">\(u\)</span> ，它会影响到 <span class="math inline">\(fa_{top_u}\)</span> 的 <span class="math inline">\(mx\)</span> 和 <span class="math inline">\(se\)</span> ，所以要在修改 <span class="math inline">\(u\)</span> 前要消除对 <span class="math inline">\(fa_{top_u}\)</span> 的影响，然后又要在修改后更新对于被撤销影响的位置的 <span class="math inline">\(mx\)</span> 和 <span class="math inline">\(se\)</span> ，即在 <span class="math inline">\(u\)</span> 时删除 <span class="math inline">\(fa_{top_u}\)</span> 的堆中的 <span class="math inline">\(topdis_{rt_{top_u}} + dis_{top_{u}} - dis_{fa_{top_{u}}}\)</span> ，在 <span class="math inline">\(u\)</span> 跳到 <span class="math inline">\(fa_{top_u}\)</span> 后插入 <span class="math inline">\(topdis_{rt_{top_u}} + dis_{top_{u}} - dis_{fa_{top_{u}}}\)</span> 。</p>
<p>然后，要修改 <span class="math inline">\(ans\)</span> 这个堆，删除原本答案 <span class="math inline">\(val_{rt_{top_u}}\)</span> ，修改后再插入新答案 <span class="math inline">\(val_{rt_{top_u}}\)</span> 。</p>
<hr>
<p>现在所有做法和细节就基本上讲完，最后还是要落到代码实现上，虽然说不算最长的那一类，但实现细节很多，建议理清思路后再打，不然盲目抄题解收获不大。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">/*
address:https://vjudge.net/problem/SPOJ-QTREE4
AC 2025/1/23 14:54
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 5;
const int INF = 0x3f3f3f3f;
int n, q;
struct edge {
    int to, w;
};
vector&lt;edge&gt;G[N];
bool col[N];
struct Heap { // 支持随机删除堆
    multiset&lt;int, greater&lt;int&gt;&gt;s;
    inline void insert(int x) { s.insert(x); }
    inline void erase(int x) {
        auto it = s.lower_bound(x);
        if (it != s.end()) s.erase(it);
    }
    inline int mx() { return s.empty() ? -INF : *s.begin(); }
    inline int se() {
        if (s.size() &lt;= 1) return -INF;
        auto it = s.begin();
        it++;
        return *it;
    }
}a[N], ans;
/*
a[i].mx：在i的子树中离i最远的白点的距离
a[i].se：在i的子树中离i次远且与mx只在i相交的白点的距离
ans：每条重链的答案集合
*/
int siz[N], dis[N], dfn[N], rnk[N], top[N], fa[N], son[N], len[N]; // len[i]：重链i的长度
int rt[N], L[N], R[N]; // 每个重链的线段树的根节点和管辖区间
inline void dfs1(int u) {
    siz[u] = 1;son[u] = 0;
    for (auto e : G[u])
        if (e.to != fa[u]) {
            fa[e.to] = u;
            dis[e.to] = dis[u] + e.w;
            dfs1(e.to);
            siz[u] += siz[e.to];
            if (siz[son[u]] &lt; siz[e.to]) son[u] = e.to;
        }
}
int cntn;
inline void dfs2(int u) {
    dfn[u] = ++cntn;
    rnk[cntn] = u;
    len[top[u]]++;
    if (!son[u]) return;
    top[son[u]] = top[u];
    dfs2(son[u]);
    for (auto e : G[u])
        if (e.to != son[u] &amp;&amp; e.to != fa[u]) {
            top[e.to] = e.to;
            dfs2(e.to);
        }
}
int nodecnt;
#define ls (seg[id].lc)
#define rs (seg[id].rc)
#define mid (l + r &gt;&gt; 1)
struct Segment {
    int lc, rc;
    int topdis, bottomdis, val;
    /*
    topdis:离该重链顶部最远的白点的距离
    bottomdis:离该重链底部最远的白点的距离
    val:该重链的答案
    */
}seg[N &lt;&lt; 2]; // 动态开点，对每条重链开一颗线段树
inline void merge(int id, int l, int r) {
    seg[id].topdis = max(seg[ls].topdis, dis[rnk[mid + 1]] - dis[rnk[l]] + seg[rs].topdis);
    // 左儿子的顶端，整段左儿子+右儿子顶端
    seg[id].bottomdis = max(seg[rs].bottomdis, dis[rnk[r]] - dis[rnk[mid]] + seg[ls].bottomdis);
    //同理
    seg[id].val = max({ seg[ls].val, seg[rs].val, seg[ls].bottomdis + dis[rnk[mid + 1]] - dis[rnk[mid]] + seg[rs].topdis });
    // 左儿子答案，右儿子答案，左儿子底端+中间的边+右儿子底端
}
inline void build(int id, int l, int r) {
    if (l == r) {
        int u = rnk[r];
        for (auto e : G[u])
            if (e.to != fa[u] &amp;&amp; e.to != son[u]) a[u].insert(seg[rt[top[e.to]]].topdis + e.w); //从已更新完的重链转移，且两个区间不能相交，否则转移失效
        int mx = a[u].mx(), se = a[u].se();
        seg[id].topdis = seg[id].bottomdis = max(mx, 0); //初始所有点都是白点
        seg[id].val = max({ mx, mx + se, 0 });
        return;
    }
    ls = ++nodecnt;rs = ++nodecnt;
    build(ls, l, mid);build(rs, mid + 1, r);
    merge(id, l, r);
}
inline void change(int id, int l, int r, int x, int sontop) {
    if (l == r) {
        if (x != sontop) a[x].insert(seg[rt[sontop]].topdis + dis[sontop] - dis[x]); //更新被撤销的距离影响
        int mx = a[x].mx(), se = a[x].se();
        if (col[x]) { // 白点可以以自己为起点，与0取max
            seg[id].topdis = seg[id].bottomdis = max(mx, 0);
            seg[id].val = max({ 0, mx, mx + se });
        }
        else {
            seg[id].topdis = seg[id].bottomdis = mx;
            seg[id].val = mx + se;
        }
        return;
    }
    if (dfn[x] &lt;= mid) change(ls, l, mid, x, sontop);
    else change(rs, mid + 1, r, x, sontop);
    merge(id, l, r);
}
inline void modify(int u) {
    int sontop = u; // sontop：记录撤销对当前重链贡献的那条贡献
    while (u != 0) {
        ans.erase(seg[rt[top[u]]].val);
        if (fa[top[u]]) a[fa[top[u]]].erase(seg[rt[top[u]]].topdis + dis[top[u]] - dis[fa[top[u]]]); //撤销对父亲重链距离的影响
        change(rt[top[u]], L[top[u]], R[top[u]], u, sontop);
        ans.insert(seg[rt[top[u]]].val);
        sontop = top[u];
        u = fa[top[u]];
    }
}
inline void init() {
    dfs1(1);
    top[1] = 1;
    dfs2(1);
    for (int i = n;i &gt;= 1;i--)
        if (rnk[i] == top[rnk[i]]) {
            rt[rnk[i]] = ++nodecnt;
            L[rnk[i]] = i, R[rnk[i]] = i + len[rnk[i]] - 1;
            build(rt[rnk[i]], i, i + len[rnk[i]] - 1);
            ans.insert(seg[rt[rnk[i]]].val);
        }
}
int main() {
    scanf("%d", &amp;n);
    for (int i = 1;i &lt; n;i++) {
        int u, v, w;scanf("%d%d%d", &amp;u, &amp;v, &amp;w);
        G[u].push_back({ v, w });
        G[v].push_back({ u, w });
    }
    init();
    for (int i = 1;i &lt;= n;i++) col[i] = true;
    scanf("%d", &amp;q);
    int white = n;
    while (q--) {
        char op[2];scanf("%s", op);
        if (op[0] == 'C') {
            int u;scanf("%d", &amp;u);
            col[u] ^= 1;
            white += col[u] ? 1 : -1;
            modify(u);
        }
        else
            if (white == 0) puts("They have disappeared.");
            else printf("%d\n", ans.mx());
    }
    return 0;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>其实这道题用其他方法会更简单，比如动态分治一类，但这是我们训练树链剖分时做的题，所以就会有这样一个奇怪做法，但对思维和码力练习挺大的，好题++。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02608498196875" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 17:39">2025-01-23 17:38</span>&nbsp;
<a href="https://www.cnblogs.com/keysky">keysky</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688268" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688268);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688268', targetLink: 'https://www.cnblogs.com/keysky/p/18688268', title: '「SPOJ2666」QTREE4 - Query on a tree IV' })">举报</a>
</div>
        