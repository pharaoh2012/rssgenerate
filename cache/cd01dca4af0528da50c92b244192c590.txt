
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/BluePointLilac/p/18908951" title="发布于 2025-06-04 17:34">
    <span role="heading" aria-level="2">C# Task 取消执行的简单封装</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        C# 封装一个简单的 Task 继承类，方便编写可取消的任务
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我让DeepSeek帮我写了一段使用 CancellationTokenSource 取消任务的简单示例如下：</p>
<details open="">
<summary>取消任务的简单示例</summary>
<pre><code class="language-csharp">using System.Threading.Tasks;
using System.Threading;

public async Task Test()
{
    var cts = new CancellationTokenSource();
    var task = Task.Run(() =&gt;
    {
        while (true)
        {
            cts.Token.ThrowIfCancellationRequested();
            Thread.Sleep(200);
        }
    });
    await Task.Delay(1000);
    cts.Cancel();
    try
    {
        await task;
    }
    catch (OperationCanceledException)
    {
        // task is cancelled
    }
    finally
    {
        cts.Dispose();
    }
}
</code></pre>
</details>
<p>相对于不可取消的普通任务多了很多代码，并且终止任务的方式 <code>ThrowIfCancellationRequested</code> 内部是通过抛出异常实现的</p>
<details open="">
<summary>ThrowIfCancellationRequested 内部代码</summary>
<pre><code class="language-csharp">public void ThrowIfCancellationRequested()
{
    if (IsCancellationRequested)
    {
        throw new OperationCanceledExceptionEx(this);
    }
}
</code></pre>
</details>
<p>于是我就想自己封装一个简单的包装类，代码如下：</p>
<details open="">
<summary>CancelableTask</summary>
<pre><code class="language-csharp">namespace System.Threading.Tasks
{
    public sealed class CancelableTask : Task
    {
        readonly object cancelLock = new object();
        CancellationTokenSource cts;

        public bool IsCancellationRequested =&gt; cts != null &amp;&amp; cts.IsCancellationRequested;

        private CancelableTask(Action action, CancellationToken token) : base(action, token) { }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                cts?.Dispose();
            }
            base.Dispose(disposing);
        }

        public void Cancel()
        {
            lock (cancelLock)
            {
                if (!IsCompleted &amp;&amp; !IsCancellationRequested)
                {
                    cts.Cancel();
                }
            }
        }

        public static CancelableTask StartNew(Action action)
        {
            var cts = new CancellationTokenSource();
            var task = new CancelableTask(action, cts.Token);
            task.cts = cts;
            task.Start();
            return task;
        }

        public static void Restart(ref CancelableTask task, Action action)
        {
            var oldTask = Interlocked.Exchange(ref task, null);
            oldTask?.Cancel();
            var newTask = StartNew(action);
            Interlocked.Exchange(ref task, newTask);
        }
    }
}
</code></pre>
</details>
<p>此类公开了 <code>Cancel</code> 用来取消任务，静态的 <code>StartNew</code> 用来创建新实例，以及静态的 <code>Restart</code> 用来取消上个任务并重启任务，<br>
还公开了一个 <code>IsCancellationRequested</code> 属性用来获取是否请求过取消任务，相对于调用 <code>ThrowIfCancellationRequested</code> 抛出异常来终止任务的方式性能更好也更加友好<br>
使用此类重新编写上面的示例就简单很多了</p>
<details open="">
<summary>CancelableTask 使用示例</summary>
<pre><code class="language-csharp">using System.Threading.Tasks;

CancelableTask task;

public async Task Test()
{
    task = CancelableTask.StartNew(() =&gt;
    {
        while (!task.IsCancellationRequested)
        {
            Thread.Sleep(200);
        }
    });
    await Task.Delay(1000);
    task.Cancel();
    await task;
}
</code></pre>
</details>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.7626381228819445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-04 18:09">2025-06-04 17:34</span>&nbsp;
<a href="https://www.cnblogs.com/BluePointLilac">蓝点lilac</a>&nbsp;
阅读(<span id="post_view_count">176</span>)&nbsp;
评论(<span id="post_comment_count">5</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18908951);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18908951', targetLink: 'https://www.cnblogs.com/BluePointLilac/p/18908951', title: 'C# Task 取消执行的简单封装' })">举报</a>
</div>
        