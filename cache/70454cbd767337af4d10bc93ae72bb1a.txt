
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cyfj/p/18689044" title="发布于 2025-01-24 09:30">
    <span role="heading" aria-level="2">封装 BackgroundService</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>基类 我在ExecuteAsync中写的是while 也可以增加定时器 看自己需求，while的好处就是在上一次Work没有执行时下一次Work不会执行，定时器的话就是相反不管上一次Work有没有执行完，到下一次执行时间后，都会执行</p>
<pre><code>public abstract class BaseJob : BackgroundService
{
    private readonly ILogger&lt;BaseJob&gt; logger = ServiceLocator.GetService&lt;ILogger&lt;BaseJob&gt;&gt;();
    public BaseJob()
    {
        Key = GetType().Name;
    }
    /// &lt;summary&gt;
    /// Key
    /// &lt;/summary&gt;
    public string Key { get; private set; }
    /// &lt;summary&gt;
    /// true为启动 false为停止
    /// &lt;/summary&gt;
    private volatile bool _isRunning;
    public bool IsRunning
    {
        get =&gt; _isRunning;
        set =&gt; _isRunning = value;
    }

    /// &lt;summary&gt;
    /// 信息
    /// &lt;/summary&gt;
    public string? JobMsg { get; set; }

    /// &lt;summary&gt;
    /// 停止原因
    /// &lt;/summary&gt;
    public string? StopMsg { get; set; }

    /// &lt;summary&gt;
    /// 启动时间
    /// &lt;/summary&gt;
    public DateTime? StartTime { get; set; }
    /// &lt;summary&gt;
    /// 停止时间
    /// &lt;/summary&gt;
    public DateTime? StopTime { get; set; }
    /// &lt;summary&gt;
    /// 备注
    /// &lt;/summary&gt;
    public string? Remark { get; set; }
    /// &lt;summary&gt;
    /// 排序号
    /// &lt;/summary&gt;
    public short OrderId { get; set; } = 1;
    /// &lt;summary&gt;
    /// WorkContent
    /// &lt;/summary&gt;
    public Func&lt;Task&gt; WorkContent { get; set; }

    /// &lt;summary&gt;
    /// 是否需要轮询 默认需要
    /// &lt;/summary&gt;
    public bool IsPoll { get; set; } = true;

    /// &lt;summary&gt;
    /// 轮询间隔时间 默认两秒
    /// &lt;/summary&gt;
    public TimeSpan Delay
    {
        get =&gt; _delay;
        set
        {
            if (value &lt; TimeSpan.Zero)
                throw new ArgumentException("延迟时间不能为负数");
            _delay = value;
        }
    }
    private TimeSpan _delay = TimeSpan.FromSeconds(2);



    public override async Task StartAsync(CancellationToken cancellationToken)
    {
        StartTime = DateTime.Now;
        if (IsRunning == false)
        {
            StopMsg = string.Empty;
            JobMsg = string.Empty;
            await base.StartAsync(cancellationToken);
        }
    }
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (WorkContent == null) throw new ArgumentNullException(nameof(WorkContent), $"key:{Key}的Work为空");
        try
        {
            IsRunning = true;
            logger.LogInformation($"Job {Key} 开始执行");
            
            if (IsPoll)
            {
                while (!stoppingToken.IsCancellationRequested)
                {
                    try 
                    {
                        await WorkContent.Invoke().ConfigureAwait(false);
                        await Task.Delay(Delay, stoppingToken).ConfigureAwait(false);
                        stoppingToken.ThrowIfCancellationRequested();
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, $"Job {Key} 执行出错: {ex.Message}");
                        JobMsg = $"执行出错: {ex.Message}";
                    }
                }
            }
            else
            {
                await WorkContent.Invoke();
                logger.LogInformation($"Job {Key} 单次执行完成");
                JobMsg = "单次Work已结束";
            }
        }
        catch (Exception ex)
        {
            JobMsg = "异常:" + ex.Message;
            await StopAsync(stoppingToken, $"BaseJob捕获到异常已停止:{ex.Message}");
        }
        finally
        {
            IsRunning = false;// 确保 IsRunning 在方法退出时设置为 false
        }
    }

    public virtual async Task StopAsync(CancellationToken cancellationToken, string stopMsg)
    {
        logger.LogError($"Job {Key} 退出");
        StopMsg = stopMsg;
        StopTime = DateTime.Now;
        IsRunning = false;
        await base.StopAsync(cancellationToken);
    }
}
</code></pre>
<p>最基本的使用案例 会在控制台两秒输出一次</p>
<pre><code>public class TestJob : BaseJob
{
    public TestJob()
    {
        base.Remark = "测试Job";
        base.WorkContent = () =&gt;
        {
            Console.WriteLine("Test");
            return Task.CompletedTask;
        };
    }
}
</code></pre>
<p>另外是对Job的管理查询，启动和停止</p>
<pre><code>public class JobManager
{
    private readonly IServiceProvider _serviceProvider;
    private readonly List&lt;JobInfo&gt; _jobs = new();

    public JobManager(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public void AddJob&lt;T&gt;() where T : BaseJob
    {
        //ActivatorUtilities.CreateInstance 方法接受以一个参数：
        //_serviceProvider：这是 IServiceProvider 对象，它提供了创建服务实例的能力。
        //因为已经给T了 所以不需要第二个参数了 而且类也是无参的构造函数
        var job = ActivatorUtilities.CreateInstance&lt;T&gt;(_serviceProvider);
        _jobs.Add(new JobInfo(job));
    }

    public void AddJob(Type jobType)
    {
        //ActivatorUtilities.CreateInstance 方法接受三个参数：
        //_serviceProvider：这是 IServiceProvider 对象，它提供了创建服务实例的能力。
        //第二个参数：这是 Type 对象，表示您想要创建的类的类型。
        //第三个参数：这个参数在创建实例时被传递给构造函数。
        var job = (BaseJob)ActivatorUtilities.CreateInstance(_serviceProvider, jobType);
        _jobs.Add(new JobInfo(job));
    }

    public async Task StartJobAsync(string key, CancellationToken cancellationToken)
    {
        var job = GetJobInfo(key);
        if (job != null) await job.Service.StartAsync(cancellationToken);
    }

    public async Task StartJobAllAsync(CancellationToken cancellationToken)
    {
        foreach (var job in _jobs)
        {
            if (job.IsRunning) continue;
            try
            {
                await job.Service.StartAsync(cancellationToken);
            }
            catch (Exception ex)
            {
                LogHelp.LogError($"{job.Key}启动异常{ex.Message}");
            }
        }
    }

    public async Task StopJobAsync(string key, CancellationToken cancellationToken)
    {
        var job = GetJobInfo(key);
        if (job != null) await job.Service.StopAsync(cancellationToken, "手动停止");
    }

    public async Task StopJobAllAsync(CancellationToken cancellationToken)
    {
        foreach (var job in _jobs) await job.Service.StopAsync(cancellationToken, "手动停止");
    }

    public IEnumerable&lt;JobInfo&gt; GetJobInfos()
    {
        return _jobs.OrderBy(s=&gt;s.Service.OrderId);
    }

    public JobInfo GetJobInfo(string key)
    {
        return _jobs.FirstOrDefault(j =&gt; j.Key == key);
    }
}
</code></pre>
<pre><code>public static class JobExtension
{
    /// &lt;summary&gt;
    /// 注入JobManager
    /// &lt;/summary&gt;
    /// &lt;param name="services"&gt;&lt;/param&gt;
    public static void AddJobManager(this IServiceCollection services)
    {
        services.AddSingleton&lt;JobManager&gt;();
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        var jobTypes = assemblies.SelectMany(a =&gt; a.GetTypes())
            .Where(t =&gt; typeof(BaseJob).IsAssignableFrom(t) &amp;&amp; !t.IsAbstract);

        foreach (var jobType in jobTypes)
        {
            services.AddSingleton(jobType);
        }
    }

    /// &lt;summary&gt;
    /// 添加所有Job 默认启动
    /// &lt;/summary&gt;
    /// &lt;param name="app"&gt;&lt;/param&gt;
    /// &lt;param name="noStartJob"&gt;不启动哪些Job&lt;/param&gt;
    /// &lt;param name="IsStart"&gt;是否启动 默认为true&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static void UseAddJobAll(this IApplicationBuilder app, bool isStart = true, params string[] noStartJob)
    {
        // 获取所有继承自 BaseJob 的子类类型
        var jobTypes = AppDomain.CurrentDomain.GetDerivedTypes&lt;BaseJob&gt;();
        // 获取 JobManager 实例
        var jobManager = app.ApplicationServices.GetRequiredService&lt;JobManager&gt;();

        foreach (var jobType in jobTypes)
        {
            if (noStartJob.Contains(jobType.Name)) continue;
            jobManager.AddJob(jobType);
        }

        if (isStart) jobManager.StartJobAllAsync(CancellationToken.None).GetAwaiter();
    }

    /// &lt;summary&gt;
    /// 添加所有Job 默认启动
    /// &lt;/summary&gt;
    /// &lt;param name="app"&gt;&lt;/param&gt;
    /// &lt;param name="IsStart"&gt;是否启动 默认为true&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static void UseAddJobAll(this IApplicationBuilder app, bool isStart = true)
    {
        // 获取所有继承自 BaseJob 的子类类型
        var jobTypes = AppDomain.CurrentDomain.GetDerivedTypes&lt;BaseJob&gt;();
        // 获取 JobManager 实例
        var jobManager = app.ApplicationServices.GetRequiredService&lt;JobManager&gt;();

        foreach (var jobType in jobTypes) jobManager.AddJob(jobType);
        if (isStart) jobManager.StartJobAllAsync(CancellationToken.None).GetAwaiter();
    }

    private static IEnumerable&lt;Type&gt; GetDerivedTypes&lt;T&gt;(this AppDomain appDomain)
    {
        return appDomain.GetAssemblies()
            .SelectMany(assembly =&gt; assembly.GetTypes())
            .Where(type =&gt; typeof(T).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract &amp;&amp; type != typeof(T));
    }
}
</code></pre>
<p>在WebApi项目Program类中来调用方法</p>
<pre><code>builder.Services.AddJobManager();
app.UseAddJobAll(false,nameof(S1StackerErrorJob), nameof(S2StackerErrorJob));
</code></pre>
<p>另外如果有有使用 Masuit.Tools(码数吐司库) 类库的兄弟，请不要使用他的 “ASP.NET Core自动扫描注册服务” 功能,这会导致你继承BackgroundService的类莫名其妙自己启动，有Bug<br>
<img src="https://img2024.cnblogs.com/blog/2917458/202501/2917458-20250124093423579-1994159255.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.112937056488426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 09:35">2025-01-24 09:30</span>&nbsp;
<a href="https://www.cnblogs.com/cyfj">柴油飞机</a>&nbsp;
阅读(<span id="post_view_count">60</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18689044" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18689044);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18689044', targetLink: 'https://www.cnblogs.com/cyfj/p/18689044', title: '封装 BackgroundService' })">举报</a>
</div>
        