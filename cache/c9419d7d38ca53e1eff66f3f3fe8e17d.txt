
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18628001" title="发布于 2025-01-11 15:36">
    <span role="heading" aria-level="2">了解 ASP.NET Core 中的中间件</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 .NET Core 中，<strong>中间件（Middleware）</strong> 是处理 HTTP 请求和响应的核心组件。它们被组织成一个<strong>请求处理管道</strong>，每个中间件都可以在请求到达最终处理程序之前或之后执行操作。中间件可以用于实现各种功能，如身份验证、路由、日志记录、异常处理、静态文件服务等。</p>
<hr>
<h3 id="什么是中间件">什么是中间件？</h3>
<p>中间件是 <strong>HTTP 请求管道中的一个处理单元</strong>，负责处理传入的 HTTP 请求和返回的 HTTP 响应。每个中间件都有以下职责：</p>
<ol>
<li><strong>处理请求</strong>：可以对请求进行预处理（如修改请求内容、验证身份等）。</li>
<li><strong>决定是否继续传递请求</strong>：可以选择将请求传递给下一个中间件，或者直接返回响应（短路请求管道）。</li>
<li><strong>处理响应</strong>：可以在响应返回给客户端之前进行后处理（如添加响应头、记录日志等）。</li>
</ol>
<hr>
<h3 id="中间件的工作原理">中间件的工作原理</h3>
<p>中间件的工作原理可以概括为以下几个步骤：</p>
<ol>
<li><strong>请求进入管道</strong>：
<ul>
<li>当一个 HTTP 请求进入应用程序时，它首先通过一系列的中间件组件。</li>
<li>每个中间件都有机会处理请求，并决定是否将请求传递给下一个中间件。</li>
</ul>
</li>
<li><strong>中间件的执行顺序</strong>：
<ul>
<li>中间件是按照添加的顺序依次执行的。</li>
<li>例如，身份验证中间件通常应该在路由中间件之前执行，以确保在路由处理请求之前已经进行了身份验证。</li>
</ul>
</li>
<li><strong>中间件的组成</strong>：
<ul>
<li>每个中间件通常是一个 <code>Func&lt;RequestDelegate, RequestDelegate&gt;</code> 委托，或者是一个实现了 <code>IMiddleware</code> 接口的类。</li>
<li><code>RequestDelegate</code> 是一个表示处理 HTTP 请求的委托，它接收一个 <code>HttpContext</code> 对象并返回一个 <code>Task</code>。</li>
</ul>
</li>
<li><strong>中间件的执行流程</strong>：
<ul>
<li>当请求进入中间件时，中间件可以选择：
<ul>
<li>处理请求并直接返回响应（短路请求管道）。</li>
<li>将请求传递给下一个中间件（调用 <code>next(context)</code>）。</li>
</ul>
</li>
<li>如果中间件调用了 <code>next(context)</code>，那么请求将继续传递到下一个中间件。</li>
<li>当请求通过所有中间件后，最终的处理程序（如控制器）将处理请求并生成响应。</li>
<li>响应会按照相反的顺序通过中间件管道返回给客户端。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="常见的中间件及其工作原理">常见的中间件及其工作原理</h3>
<p>以下是一些常见的中间件及其工作原理：</p>
<h4 id="1-身份验证中间件authentication-middleware">1. <strong>身份验证中间件（Authentication Middleware）</strong></h4>
<ul>
<li><strong>作用</strong>：用于处理用户身份验证。</li>
<li><strong>工作原理</strong>：
<ul>
<li>在请求到达控制器之前，身份验证中间件会检查请求中是否包含有效的身份验证信息（如 JWT 令牌、Cookie 等）。</li>
<li>如果身份验证成功，中间件会将用户信息存储在 <code>HttpContext.User</code> 中。</li>
<li>如果身份验证失败，中间件可以重定向到登录页面或返回 401 未授权响应。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseAuthentication(); // 启用身份验证
    app.UseAuthorization();  // 启用授权
}
</code></pre>
<h4 id="2-路由中间件routing-middleware">2. <strong>路由中间件（Routing Middleware）</strong></h4>
<ul>
<li><strong>作用</strong>：用于将请求路由到相应的处理程序（如控制器）。</li>
<li><strong>工作原理</strong>：
<ul>
<li>路由中间件会解析请求的 URL 和 HTTP 方法，并根据配置的路由规则将请求映射到相应的处理程序。</li>
<li>路由规则可以通过 <code>UseRouting</code> 和 <code>UseEndpoints</code> 配置。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseRouting(); // 启用路由解析
    app.UseEndpoints(endpoints =&gt;
                     {
                         endpoints.MapControllerRoute(
                             name: "default",
                             pattern: "{controller=Home}/{action=Index}/{id?}");
                     });
}
</code></pre>
<h4 id="3-静态文件中间件static-files-middleware">3. <strong>静态文件中间件（Static Files Middleware）</strong></h4>
<ul>
<li><strong>作用</strong>：用于提供静态文件（如 HTML、CSS、JavaScript 文件）。</li>
<li><strong>工作原理</strong>：
<ul>
<li>静态文件中间件会检查请求的 URL，如果请求的是静态文件（如 <code>wwwroot</code> 目录下的文件），则直接返回文件内容。</li>
<li>如果请求的不是静态文件，则将请求传递给下一个中间件。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles(); // 启用静态文件服务
}
</code></pre>
<h4 id="4-异常处理中间件exception-handling-middleware">4. <strong>异常处理中间件（Exception Handling Middleware）</strong></h4>
<ul>
<li><strong>作用</strong>：用于捕获和处理应用程序中的异常。</li>
<li><strong>工作原理</strong>：
<ul>
<li>异常处理中间件会捕获管道中抛出的异常，并根据配置返回友好的错误页面或 JSON 响应。</li>
<li>通常用于开发环境和生产环境。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage(); // 开发环境：显示详细错误页面
    }
    else
    {
        app.UseExceptionHandler("/Home/Error"); // 生产环境：重定向到错误页面
    }
}
</code></pre>
<h4 id="5-日志记录中间件logging-middleware">5. <strong>日志记录中间件（Logging Middleware）</strong></h4>
<ul>
<li><strong>作用</strong>：用于记录请求和响应的日志信息。</li>
<li><strong>工作原理</strong>：
<ul>
<li>日志记录中间件可以在请求进入和离开管道时记录日志。</li>
<li>通常通过第三方库（如 Serilog）或内置的日志记录系统实现。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-csharp">public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;LoggingMiddleware&gt; _logger;

    public LoggingMiddleware(RequestDelegate next, ILogger&lt;LoggingMiddleware&gt; logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation($"Request: {context.Request.Method} {context.Request.Path}");
        await _next(context);
        _logger.LogInformation($"Response: {context.Response.StatusCode}");
    }
}
</code></pre>
<hr>
<h3 id="自定义中间件">自定义中间件</h3>
<p>你可以创建自定义中间件来处理特定的需求。自定义中间件通常是一个类，它包含一个 <code>Invoke</code> 或 <code>InvokeAsync</code> 方法，该方法接收 <code>HttpContext</code> 和一个 <code>RequestDelegate</code> 参数。</p>
<h4 id="示例">示例：</h4>
<pre><code class="language-csharp">public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // 在调用下一个中间件之前执行的操作
        await context.Response.WriteAsync("Custom Middleware: Before\n");

        // 调用下一个中间件
        await _next(context);

        // 在调用下一个中间件之后执行的操作
        await context.Response.WriteAsync("Custom Middleware: After\n");
    }
}
</code></pre>
<p>然后在 <code>Startup.cs</code> 中使用这个中间件：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware&lt;CustomMiddleware&gt;();

    // 其他中间件
    app.UseRouting();
    app.UseEndpoints(endpoints =&gt;
                     {
                         endpoints.MapGet("/", async context =&gt;
                         {
                             await context.Response.WriteAsync("Hello World!");
                         });
                     });
}
</code></pre>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li><strong>中间件</strong> 是 .NET Core 中处理 HTTP 请求和响应的核心组件，它们被组织成一个管道。</li>
<li>中间件的工作原理是：请求依次通过每个中间件，每个中间件可以选择处理请求、传递请求或短路请求管道。</li>
<li>常见的中间件包括身份验证、路由、静态文件服务、异常处理和日志记录。</li>
<li>你可以通过自定义中间件来实现特定的功能。</li>
</ul>
<p>通过理解中间件的工作原理和常见应用场景，你可以更好地设计和优化 .NET Core 应用程序的请求处理流程。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250110182617174-893410886.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.4466461436319444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-11 15:37">2025-01-11 15:36</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">339</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628001" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628001);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628001', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18628001', title: '了解 ASP.NET Core 中的中间件' })">举报</a>
</div>
        