
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ryuasuka/p/18993689" title="发布于 2025-07-20 09:55">
    <span role="heading" aria-level="2">SpringBoot集成测试笔记：缩小测试范围、提高测试效率</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        如果需要指定需要测试的 Bean 及其依赖，而不是加载完整的上下文环境，可以在 `@SpringBootTest` 注解的 `classes` 参数中配置需要测试及依赖的类或对象。如果遇到不是项目中自己写的或者可以自动生成的实现类，可以通过配置 `@TestConfiguration` 的方式，在测试配置中注册相关的 Bean。最终做到缩小测试范围，提高测试运行效率。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>在 SpringBoot 中，除了基于 Mock 的单元测试，往往还需要执行几个模块组合的集成测试。一种简单的方法就是在测试类上加入 <code>@SpringBootTest</code> 注解，但是，如果不对该注解做一些配置，默认情况下该测试类会加载完整的 SpringBoot 环境，包括该程序中所有的 Bean。如果要初始化的 Bean 非常多，启动集成测试的时间就会很长，因此我们需要对 <code>@SpringBootTest</code> 注解进行一些配置，以减少环境加载的数量，提高程序运行效率。</p>
<h2 id="项目架构">项目架构</h2>
<p>下面是一个简单的 SpringBoot 项目，类图如下：</p>
<p><img alt="类图" loading="lazy" data-src="https://img2024.cnblogs.com/blog/400008/202507/400008-20250720095339190-656512025.png" class="lazyload"></p>
<ul>
<li><code>ProjectController</code> 依赖接口 <code>ProjectListService</code> 和 <code>ProjectOperateService</code>；</li>
<li><code>ProjectListService</code> 的实现类依赖接口 <code>ProjectConverter</code> 和 <code>ProjectMapper</code>；</li>
<li><code>ProjectOperateService</code> 的实现类依赖接口 <code>ProjectBizCheckService</code>、<code>TechCheckService</code>、<code>ProjectConverver</code> 和 <code>ProjectMapper</code>;</li>
<li>接口 <code>ProjectConverter</code> 为 <code>MapStruct</code>映射接口；</li>
<li>接口 <code>ProjectMapper</code> 为 <code>Mybatis</code> 数据访问接口（DAO）。</li>
</ul>
<h2 id="不带参数的-springboottest-测试类">不带参数的 <code>@SpringBootTest</code> 测试类</h2>
<p>从类图中可以看到，<code>ProjectListService</code> 的实现类依赖两个接口，分别是用于对象转换的 <code>ProjectConverter</code> 和数据访问接口 <code>ProjectMapper</code>。我们首先使用默认的配置，即不带参数的 <code>@SpringBootTest</code> 注解进行测试。测试类代码如下：</p>
<pre><code class="language-java">/**
 * 直接采用 {@link SpringBootTest} 注解的集成测试，
 * 不带任何参数或配置
 *
 */
@SpringBootTest
@DisplayName("集成测试：不带任何参数或配置")
class ProjectListServiceWithoutConfigsTest {
    private final ApplicationContext applicationContext;

    @Autowired
    private ProjectListService projectListService;

    public ProjectListServiceWithoutConfigsTest(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    @Test
    @DisplayName("获取所有Bean名称和数量")
    public void printAllBean() {
        // 获取所有Bean名称
        String[] beanNames = applicationContext.getBeanDefinitionNames();
        Arrays.sort(beanNames);
        System.out.println("========== Spring Beans Total (" + beanNames.length + ") =========");
        for (String beanName : beanNames) {
            System.out.println("name=" + beanName + ", class=" + applicationContext.getBean(beanName).getClass());
        }
    }

    @Test
    @DisplayName("测试查询全部项目列表-应包含2个项目，且和数据库一致")
    void testListAllProjects() {
        List&lt;ProjectListResponse&gt; projectListResponses = projectListService.listProjects();

        assertThat(projectListResponses).hasSize(2);
        assertThat(projectListResponses.getFirst().getProjectId()).isEqualTo(1);
        assertThat(projectListResponses.getFirst().getProjectName()).isEqualTo("测试项目1");
        assertThat(projectListResponses.getFirst().getProjectStatus()).isEqualTo(ProjectStatus.READY.getDesc());

        assertThat(projectListResponses.get(1).getProjectId()).isEqualTo(2);
        assertThat(projectListResponses.get(1).getProjectName()).isEqualTo("测试项目2");
        assertThat(projectListResponses.get(1).getProjectStatus()).isEqualTo(ProjectStatus.RUNNING.getDesc());
    }
}
</code></pre>
<p>这里我们实现了一个方法 <code>printAllBean()</code>，通过获取应用上下文 <code>ApplicationContext</code> 对象中的所有被 Spring 加载的 Bean，检查本次测试加载的 Bean 数量。</p>
<p>运行测试，<code>printAllBean()</code> 方法的输出如下：</p>
<pre><code class="language-java">========== Spring Beans Total (289) =========
name=/project, class=class cn.asuka.itd.project.controller.ProjectController
name=accessorsProvider, class=class springfox.documentation.schema.property.bean.AccessorsProvider
name=apiDescriptionLookup, class=class springfox.documentation.spring.web.scanners.ApiDescriptionLookup
name=apiDescriptionReader, class=class springfox.documentation.spring.web.scanners.ApiDescriptionReader
name=apiDocumentationScanner, class=class springfox.documentation.spring.web.scanners.ApiDocumentationScanner
......
name=welcomePageNotAcceptableHandlerMapping, class=class org.springframework.boot.autoconfigure.web.servlet.WelcomePageNotAcceptableHandlerMapping
name=xmlModelPlugin, class=class springfox.documentation.schema.plugins.XmlModelPlugin
name=xmlPropertyPlugin, class=class springfox.documentation.schema.property.XmlPropertyPlugin
</code></pre>
<p>可以看到总共加载了 289 个 Bean，数量很多，但大多数是我们在测试中不直接依赖的。</p>
<p>那么，我们应该如何让该测试只依赖我们需要的 Bean，或者尽可能减少依赖的 Bean 数量呢？</p>
<h2 id="带参数的-springboottest-测试">带参数的 <code>@SpringBootTest</code> 测试</h2>
<p>首先，我们要知道的是基于 <code>MapStruct</code> 的 <code>ProjectConverter</code> 接口，在编译期会生成对应的实现类 <code>ProjectConverterImpl</code>，和 <code>ProjectConverter</code> 在同一个包下，因此我们实际上可以直接把该实现类加载进 Spring 上下文中。</p>
<p>但是，基于 <code>Mybatis</code> 的 <code>ProjectMapper</code> 并不会直接生成实现类，而是在运行期通过 <code>MapperProxy</code> 代理类去执行。此外我们使用的数据库连接池是 <code>Druid</code>，因此 <code>ProjectMapper</code> 也隐含了对 <code>Druid</code> 连接池的依赖。</p>
<p>因此，我们通过设置 <code>@SpringBootTest</code> 注解的 <code>classes</code> 参数，来指定本次测试中 Spring 上下文需要加载的类。</p>
<p>为了让测试代码能够调用 <code>Druid</code> 连接池，还需要建立一个 <code>MybatisTestConfig</code> 的配置类，人为地设置一个在测试环境下的 <code>DataSource</code> 对象，让我们的测试类依赖该数据源，而不是生产代码中的数据源。</p>
<p><code>MybatisTestConfig</code> 配置类定义如下：</p>
<pre><code class="language-java">/**
 * @author jwmao
 */
@TestConfiguration
@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class})
@MapperScan(basePackages = {"cn.asuka.itd.project.dao"})
public class MybatisTestConfig {
    @Value("${spring.datasource.druid.url}")
    private String url;

    @Value("${spring.datasource.druid.username}")
    private String username;

    @Value("${spring.datasource.druid.password}")
    private String password;

    @Value("${spring.datasource.druid.driver-class-name}")
    private String driverClassName;

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driverClassName);
        return dataSource;
    }

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/*.xml"));
        return sessionFactory.getObject();
    }
}
</code></pre>
<p>除了指定数据源 <code>DataSource</code> 对象，还需要指定 <code>SqlSessionFactory</code> 对象，因为 <code>MapperProxy</code> 类依赖它，如果不指定的话它不会自动注入。</p>
<p>下面来看一下 <code>ProjectListServiceWithConfigsTest</code> 的实现：</p>
<pre><code class="language-java">/**
 * 指定测试依赖Bean的测试类
 */
@SpringBootTest(classes = {
        ProjectListServiceImpl.class,
        MybatisTestConfig.class,
        ProjectConverterImpl.class
})
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@PropertySource("classpath:application.properties")
@DisplayName("集成测试：指定测试依赖Bean")
class ProjectListServiceWithConfigsTest {
    private final ApplicationContext applicationContext;

    @Autowired
    private ProjectListServiceImpl projectListServiceUnderTest;

    public ProjectListServiceWithConfigsTest(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    @Test
    @DisplayName("获取所有Bean名称和数量")
    public void printAllBean() {
        // 获取所有Bean名称
        String[] beanNames = applicationContext.getBeanDefinitionNames();
        Arrays.sort(beanNames);
        System.out.println("========== Spring Beans Total (" + beanNames.length + ") =========");
        for (String beanName : beanNames) {
            System.out.println("name=" + beanName + ", class=" + applicationContext.getBean(beanName).getClass());
        }
    }

    @Test
    @DisplayName("测试查询全部项目列表-应包含2个项目，且和数据库一致")
    void testListAllProjects() {
        List&lt;ProjectListResponse&gt; projectListResponses = projectListServiceUnderTest.listProjects();

        assertThat(projectListResponses).hasSize(2);
        assertThat(projectListResponses.getFirst().getProjectId()).isEqualTo(1);
        assertThat(projectListResponses.getFirst().getProjectName()).isEqualTo("测试项目1");
        assertThat(projectListResponses.getFirst().getProjectStatus()).isEqualTo(ProjectStatus.READY.getDesc());

        assertThat(projectListResponses.get(1).getProjectId()).isEqualTo(2);
        assertThat(projectListResponses.get(1).getProjectName()).isEqualTo("测试项目2");
        assertThat(projectListResponses.get(1).getProjectStatus()).isEqualTo(ProjectStatus.RUNNING.getDesc());
    }
}
</code></pre>
<p>在上述测试类中，两个测试方法 <code>printAllBean()</code> 和 <code>testListAllProjects()</code> 实现完全一致。在类上方的注解中，我们首先通过</p>
<pre><code class="language-java">@SpringBootTest(classes = {
        ProjectListServiceImpl.class,
        MybatisTestConfig.class,
        ProjectConverterImpl.class
})
</code></pre>
<p>分别指定我们需要测试的类 <code>ProjectListServiceImpl</code>、<code>ProjectConverter</code> 接口的实现类 <code>ProjectConverterImpl</code> 以及 Mybatis 配置类 <code>MybatisTestConfig</code>。然后通过 <code>@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)</code> 让测试类不加载默认的数据源，而是加载我们在 <code>MybatisTestConfig</code> 中配置的数据源；并通过 <code>@PropertySource("classpath:application.properties")</code> 来指定我们使用的测试配置文件。</p>
<p>运行测试类，可以看到 <code>testListAllProjects()</code> 同样可以测试通过，且 <code>printAllBean()</code> 的结果如下：</p>
<pre><code>========== Spring Beans Total (27) =========
name=cn.asuka.itd.testconfig.MybatisConfig#MapperScannerRegistrar#0, class=class org.mybatis.spring.mapper.MapperScannerConfigurer
name=dataSource, class=class com.alibaba.druid.pool.DruidDataSource
name=hikariPoolDataSourceMetadataProvider, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration$$Lambda/0x00000205685d79a0
name=mybatisConfig, class=class cn.asuka.itd.testconfig.MybatisConfig$$EnhancerBySpringCGLIB$$7108b66c
name=org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory, class=class org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory
name=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
name=org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration
name=org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration
name=org.springframework.boot.context.internalConfigurationPropertiesBinder, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBinder
name=org.springframework.boot.context.internalConfigurationPropertiesBinderFactory, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBinder$Factory
name=org.springframework.boot.context.properties.BoundConfigurationProperties, class=class org.springframework.boot.context.properties.BoundConfigurationProperties
name=org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor
name=org.springframework.boot.context.properties.EnableConfigurationPropertiesRegistrar.methodValidationExcludeFilter, class=class org.springframework.boot.validation.beanvalidation.MethodValidationExcludeFilter$$Lambda/0x00000205685d7bb8
name=org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, class=class org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration
name=org.springframework.boot.test.context.ImportsContextCustomizer$ImportsCleanupPostProcessor, class=class org.springframework.boot.test.context.ImportsContextCustomizer$ImportsCleanupPostProcessor
name=org.springframework.boot.test.mock.mockito.MockitoPostProcessor, class=class org.springframework.boot.test.mock.mockito.MockitoPostProcessor
name=org.springframework.boot.test.mock.mockito.MockitoPostProcessor$SpyPostProcessor, class=class org.springframework.boot.test.mock.mockito.MockitoPostProcessor$SpyPostProcessor
name=org.springframework.context.annotation.internalAutowiredAnnotationProcessor, class=class org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
name=org.springframework.context.annotation.internalCommonAnnotationProcessor, class=class org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
name=org.springframework.context.annotation.internalConfigurationAnnotationProcessor, class=class org.springframework.context.annotation.ConfigurationClassPostProcessor
name=org.springframework.context.event.internalEventListenerFactory, class=class org.springframework.context.event.DefaultEventListenerFactory
name=org.springframework.context.event.internalEventListenerProcessor, class=class org.springframework.context.event.EventListenerMethodProcessor
name=projectConverterImpl, class=class cn.asuka.itd.converter.ProjectConverterImpl
name=projectListServiceImpl, class=class cn.asuka.itd.project.service.impl.ProjectListServiceImpl
name=projectMapper, class=class jdk.proxy2.$Proxy84
name=spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties, class=class org.springframework.boot.autoconfigure.jdbc.DataSourceProperties
name=sqlSessionFactory, class=class org.apache.ibatis.session.defaults.DefaultSqlSessionFactory
</code></pre>
<p>可以看到只加载了 27 个 Bean，大大减少了 Bean 的加载数量，对测试运行速度提升也有帮助。</p>
<h2 id="总结">总结</h2>
<p>如果需要指定需要测试的 Bean 及其依赖，而不是加载完整的上下文环境，可以在 <code>@SpringBootTest</code> 注解的 <code>classes</code> 参数中配置需要测试及依赖的类或对象。如果遇到不是项目中自己写的或者可以自动生成的实现类，可以通过配置 <code>@TestConfiguration</code> 的方式，在测试配置中注册相关的 Bean。最终做到缩小测试范围，提高测试运行效率。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-20 09:55">2025-07-20 09:55</span>&nbsp;
<a href="https://www.cnblogs.com/ryuasuka">飞鸟_Asuka</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18993689);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18993689', targetLink: 'https://www.cnblogs.com/ryuasuka/p/18993689', title: 'SpringBoot集成测试笔记：缩小测试范围、提高测试效率' })">举报</a>
</div>
        