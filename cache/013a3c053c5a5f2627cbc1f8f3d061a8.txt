
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/my314/p/18874878" title="发布于 2025-05-17 19:12">
    <span role="heading" aria-level="2">2、手写智能指针</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<div style="text-align: justify">
<p><strong>要求：</strong>实现一个c++11中shared_ptr的类<br>
在手写一个比较完整的类之前，有一些前置知识需要了解，创建一个空类的时候，编译器会自动生成哪些函数了？<br>
1、默认构造函数；<br>
2、默认拷贝构造函数；<br>
3、默认移动构造函数；<br>
4、默认析构函数；<br>
5、默认赋值运算符函数；<br>
6、默认的移动赋值运算符函数；<br>
我们在编写shared_ptr的时候，<strong>关注这6个函数外加上一个有参构造即可</strong>。</p>
<p>共享指针的由两个指针成员组成，一个是<strong>指向对象数据的指针</strong>，另一个是<strong>指向控制卡的指针</strong>。其中控制块中包含引用计数，weak_ptr计数等，这里第一版只考虑引用计数，也就是说我们类的私有成员应该含有<code>T* _ptr</code>，<code>size_t* _count</code>，但这样还不够，<strong>当多个线程同时访问同一个线程计数的时候，可能会出现线程安全问题</strong>，我们可以将引用计数设计成原子变量，即<code>atomic&lt;size_t&gt;* _count</code>。</p>
<p><strong>这里有个问题，为什么引用计数要使用指针的形式了？</strong><br>
这里我们的指针是指向引用计数的内存，如果直接定义<code>T _count</code>，那么多个shared_ptr对象共享的不是同一个引用计数变量。</p>
<p>原shared_ptr结构可见下图：<br>
<img src="https://img2024.cnblogs.com/blog/3320640/202505/3320640-20250513210756320-1066038840.jpg" alt="" loading="lazy"></p>
<p>接下来是我们共享指针应该提供几种常见方法，<code>get()</code>（返回裸指针），<code>use_count</code>(返回引用计数)。<br>
这两个函数的逻辑很简单：</p>
<pre><code>T* get() {
  return _ptr;
}

size_t use_count() const {// 注意这里是常量成员函数
  return *_count // 访问指针_count指向的引用计数
}
</code></pre>
<p>接下来，就是我们文章开头所说的，构建一个空类所涉及到的自动创建的成员函数了<br>
<strong>1、默认无参构造函数</strong></p>
<pre><code>SharedPtr () : _count(new size_t(1)), _ptr(nullptr) {}
</code></pre>
<p><strong>2、有参构造函数</strong></p>
<pre><code>SharedPtr (T* ptr) : _count(new size_t(1)), _ptr(ptr) {}
</code></pre>
<p><strong>3、拷贝构造函数</strong></p>
<pre><code>SharedPtr(const SharedPtr&amp; ptr) 
  : _count(ptr._count), _ptr(Ptr._ptr) {
  ++(*_count); // 自加与自减都前置
}
</code></pre>
<p><strong>4、移动构造函数</strong><br>
这里要注意的是，与move语义区分，move语义的本质是<strong>将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬移或者拷贝</strong>。这里的移动构造函数思路是，拷贝一份，然后将原对象清除。</p>
<pre><code>// 移动构造不需要增加引用计数
SharedPtr(const SharedPtr&amp;&amp; ptr) 
  : _count(ptr._count), _ptr(ptr._ptr) {
  ptr._count = nullptr;
  ptr._ptr = nullptr;
}
</code></pre>
<p><strong>5、拷贝赋值函数</strong><br>
比较难写的就是拷贝赋值函数与移动赋值函数了，这里有一个经典问题：<br>
<strong>当有两个shared_ptr指针为p1与p2，分别指向两块不同的内存，令p1=p2，问p1与p2的引用计数分别是多少？赋值的过程中发生了什么？</strong><br>
答：p1与p2的引用计数都为2，p1所指向的内存被释放。<br>
赋值的过程中发生了什么了？<br>
1）p1的引用计数减1；<br>
2）判定该指向内存的引用计数是否为0，为0则释放内存，置空指针(可不必置空，后续会为其赋值)；<br>
3）将p2的值赋值给p1；<br>
4）这时p1与p2将指向同一块内存，引用计数自增1；<br>
当然我们这里应该还要考虑两点：<br>
1）为提高效率，避免过多的副本产生，尤其子啊链式赋值的情况下，这里返回值应该为<code>SharedPtr&amp;</code>；<br>
2）防止自赋值，应做<code>this == &amp;ptr</code>的判断，若为自赋值，则返回<code>*this</code>；</p>
<pre><code>SharedPtr&amp; operator=(const SharedPtr&amp; ptr) {
  if (this == &amp;ptr)
    return *this;
  if (_ptr &amp;&amp; _count) {// 如果指针与引用计数指针不为空
    if (--(*count) == 0) {
      delete _count;
      delete _ptr;
    }
  }
  // 开始做赋值操作
  _count = ptr._count;
  _ptr = ptr._ptr;
  ++(*_count);
  return *this;
}
</code></pre>
<p><strong>6、移动赋值函数</strong><br>
思路与拷贝赋值函数一致。</p>
<pre><code>SharedPtr&amp;&amp; operator=(const SharedPtr&amp; ptr) {
  if (this == &amp;ptr)
    return *this;
  if (_ptr &amp;&amp; _count) {
    if (--(*_count) == 0) {
      delete _count;
      delete _ptr;
    }
  }
  _ptr = ptr._ptr;
  _count = ptr._count;
  ptr._ptr = nullptr;
  ptr._count = nullptr;
  return *this;
} 
</code></pre>
<p><strong>7、析构函数</strong></p>
<pre><code>~SharedPtr() {
  if (_count &amp;&amp; --(*_count) == 0) {
    delete _count;
    delete _ptr;
  }
}
</code></pre>
<p><strong>下面是完整的类</strong></p>
<details>
<summary>点击查看代码</summary>
<pre><code>template&lt;class T&gt;
class SharedPtr {
public:
  T* get() {
    return _ptr;
  }

  size_t use_count() const {// 注意这里是常量成员函数
    return *_count // 访问指针_count指向的引用计数
  }

  SharedPtr () : _count(new size_t(1)), _ptr(nullptr) {}

  SharedPtr (T* ptr) : _count(new size_t(1)), _ptr(ptr) {}

  SharedPtr(const SharedPtr&amp; ptr) 
    : _count(ptr._count), _ptr(Ptr._ptr) {
    ++(*_count); // 自加与自减都前置
  }

  // 移动构造不需要增加引用计数
  SharedPtr(const SharedPtr&amp;&amp; ptr) 
    : _count(ptr._count), _ptr(ptr._ptr) {
    ptr._count = nullptr;
    ptr._ptr = nullptr;
  }

  SharedPtr&amp; operator=(const SharedPtr&amp; ptr) {
    if (this == &amp;ptr)
      return *this;
    if (_ptr &amp;&amp; _count) {// 如果指针与引用计数指针不为空
      if (--(*count) == 0) {
        delete _count;
        delete _ptr;
      }
    }
    // 开始做赋值操作
    _count = ptr._count;
    _ptr = ptr._ptr;
    ++(*_count);
    return *this;
  }

  SharedPtr&amp;&amp; operator=(const SharedPtr&amp; ptr) {
    if (this == &amp;ptr)
      return *this;
    if (_ptr &amp;&amp; _count) {
      if (--(*_count) == 0) {
        delete _count;
        delete _ptr;
      }
    }
    _ptr = ptr._ptr;
    _count = ptr._count;
    ptr._ptr = nullptr;
    ptr._count = nullptr;
    return *this;
  }
  
  ~SharedPtr() {
    if (_count &amp;&amp; --(*_count) == 0) {
      delete _count;
      delete _ptr;
    }
  }  
  
private:
  T* _ptr;
  atomic&lt;size_t*&gt; _count;  
};
</code></pre>
</details></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.20765251164236112" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-17 19:19">2025-05-17 19:12</span>&nbsp;
<a href="https://www.cnblogs.com/my314">myblog314</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18874878);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18874878', targetLink: 'https://www.cnblogs.com/my314/p/18874878', title: '2、手写智能指针' })">举报</a>
</div>
        