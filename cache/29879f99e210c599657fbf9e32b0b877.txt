
        <div class="postTitle">
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhang-3/p/18755814" title="发布于 2025-03-06 16:44">
    <span role="heading" aria-level="2">VEC系列-RabbitMQ 入门笔记</span>
    

</a>

        </div>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="Editable-unstyled" data-block="true" data-editor="cm257" data-offset-key="3r5m9-0-0">
<blockquote>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3r5m9-0-0"><span data-offset-key="3r5m9-0-0">消息队列（MQ）对于开发者来说是一个经常听到的词汇，但在实际开发中，大多数人并不会真正用到它。网上已经有很多关于 MQ 概述和原理的详细讲解，官网文档和技术博客也都介绍得很深入，因此，我在这里就不再赘述。</span></div>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3r5m9-0-0">我一直认为，学习一项技术不仅要知道<span data-offset-key="edu8q-0-1">它是什么<span data-offset-key="edu8q-0-2">，更重要的是<strong>知道</strong><span data-offset-key="edu8q-0-3"><strong>怎么用</strong><span data-offset-key="edu8q-0-4">，以及<span data-offset-key="edu8q-0-5">在哪些场景下应该用<span data-offset-key="edu8q-0-6">。所以这篇文章主要就是站在一个新手的角度进行描述以及实现MQ的实际运用。</span></span></span></span></span></span></div>
</blockquote>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3r5m9-0-0"><hr>
<h1 class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="14tdv-0-0"><span data-offset-key="14tdv-0-0">使用MQ的常见情景</span></h1>
<ol class="public-DraftStyleDefault-ol" data-offset-key="duabn-0-0">
<li class="Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="duabn-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="duabn-0-0"><span data-offset-key="duabn-0-0">系统解耦：<span data-offset-key="duabn-0-1">比如电商系统，<span data-offset-key="duabn-0-2">订单系统 → 库存系统 → 物流系统 <span data-offset-key="duabn-0-3">订单系统发送“新订单”消息到 MQ，库存系统和物流系统各自订阅处理。即使库存系统或物流系统短暂不可用，消息仍然可以暂存，系统整体不会受影响。这一方面说实话不是架构师也没必要太过关注，毕竟系统的底层普通开发也没这个资格去搭建。只是用于了解，不要因为这段话阻拦学习的脚步。</span></span></span></span></div>
</li>
<li class="Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="1thns-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="1thns-0-0"><span data-offset-key="1thns-0-0">流量削峰，降低并发<span data-offset-key="1thns-0-1">：这个比较好理解，也是最能遇到的情况。用户请求先进入 MQ 队列，由后台的消费端按照数据库的最大承载能力逐步处理请求。确保数据库不会被瞬间压垮，提高系统稳定性。还是电商系统常用些。</span></span></div>
</li>
<li class="Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="p0nl-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="p0nl-0-0"><span data-offset-key="p0nl-0-0">异步任务处理<span data-offset-key="p0nl-0-1">：邮件、短信、推送通知，日志处理等。</span></span></div>
</li>
</ol>
<div class="Editable-unstyled" data-block="true" data-editor="cm257" data-offset-key="28u5-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="28u5-0-0"><span data-offset-key="28u5-0-0">理论上MQ能做的不止这些，抛砖引玉，一起深入学习吧。</span></div>
</div>
</div>
<h1 class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3r5m9-0-0"><span data-offset-key="edu8q-0-1"><span data-offset-key="edu8q-0-2"><span data-offset-key="edu8q-0-3"><span data-offset-key="edu8q-0-4"><span data-offset-key="edu8q-0-5"><span data-offset-key="edu8q-0-6">对MQ进行拆分理解</span></span></span></span></span></span></h1>
<p><span data-offset-key="edu8q-0-1"><span data-offset-key="edu8q-0-2"><span data-offset-key="edu8q-0-3"><span data-offset-key="edu8q-0-4"><span data-offset-key="edu8q-0-5"><span data-offset-key="edu8q-0-6">我认为与其去讲原理，画流程图，说些高端的词汇，倒不如说些土话，文章只能抛砖引玉，入门了，能跑起来了，那慢慢的就了解了。这里我只是用我自己理解来描述，文风粗鄙，大佬莫怪。</span></span></span></span></span></span></p>
<p><span data-offset-key="7ati6-0-0">MQ里常说生产者，消费者等。我会通过简单的例子来描述：</span></p>
<ul class="public-DraftStyleDefault-ul" data-offset-key="daofb-0-0">
<li class="Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="daofb-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="daofb-0-0"><span data-offset-key="daofb-0-0"><strong>生产者</strong><span data-offset-key="daofb-0-1">：一个游戏，我是GM，我要发送公告，玩家分为普通玩家和VIP玩家等。在这里，发<span data-offset-key="daofb-0-2">布公告的人就是消息的生产者<span data-offset-key="daofb-0-3">。应该很好理解嗷？</span></span></span></span></div>
</li>
<li class="Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="6cno9-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="6cno9-0-0"><span data-offset-key="6cno9-0-0"><strong>交换器</strong><span data-offset-key="6cno9-0-1">：如上述，有普通玩家和VIP玩家等，我的公告在普通玩家面前必然是拽的很啊，但是VIP玩家面前还是要舔下的……那么我会发布一条给普通玩家的消息，和一条给VIP玩家的消息。<span data-offset-key="6cno9-0-2">交换器的作用在我看来就是消息的承载体，类似一条运输船，负责把消息运输给玩家们<span data-offset-key="6cno9-0-3">。产生消息的地方很多，但是交换器不用关心是谁发布了消息，他只承载你的消息。</span></span></span></span></div>
</li>
<li class="Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="3vgbq-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3vgbq-0-0"><span data-offset-key="3vgbq-0-0"><strong>队列</strong><span data-offset-key="3vgbq-0-1">：如上述，有了运输船。<span data-offset-key="3vgbq-0-2">那么队列有点像是码头<span data-offset-key="3vgbq-0-3">了。普通玩家进普通码头，VIP玩家进黄金码头。各自码头停泊各自的船。总不会在普通码头取出黄金码头的货哦？</span></span></span></span></div>
</li>
</ul>
<blockquote class="Editable-styled" data-block="true" data-editor="cm257" data-offset-key="f6rnn-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="f6rnn-0-0"><span data-offset-key="f6rnn-0-0"><strong>补充</strong><span data-offset-key="f6rnn-0-1">：交换器是有类型的：<span data-offset-key="f6rnn-0-2">Direct<span data-offset-key="f6rnn-0-3">（直连交换器）<span data-offset-key="f6rnn-0-4">Fanout<span data-offset-key="f6rnn-0-5">（扇形交换器）<span data-offset-key="f6rnn-0-6">Topic<span data-offset-key="f6rnn-0-7">（主题交换器）<span data-offset-key="f6rnn-0-8">Headers<span data-offset-key="f6rnn-0-9">（头交换器）</span></span></span></span></span></span></span></span></span></span></div>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="f6rnn-0-0"><span data-offset-key="fclbn-0-0">概念不多说了。比较常用的是Direct，Fanout</span></div>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="f6rnn-0-0"><span data-offset-key="avq3s-0-0"><strong>Direct</strong>：通过路由键进行匹配，运输船是一艘，但是分为普通区和VIP区，玩家凭借船票（路由键）进行取货（取消息）</span></div>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="f6rnn-0-0"><span data-offset-key="7hvo7-0-0"><strong>Fanout</strong>：只要是是绑定了某个交换器的队列都能进行取货。玩家进普通码头就拿普通货，进黄金码头拿黄金货。当然这是举例子，玩家的队列还是要看你如何分配的。</span></div>
</blockquote>
<ul class="public-DraftStyleDefault-ul" data-offset-key="v3vh-0-0">
<li class="Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR" data-block="true" data-editor="cm257" data-offset-key="v3vh-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="v3vh-0-0"><span data-offset-key="v3vh-0-0"><strong>消费者</strong><span data-offset-key="v3vh-0-1">：说了这么多，玩家就是消费者嗷。</span></span></div>
</li>
</ul>
<h1>MQ代码演示&nbsp;</h1>
<blockquote class="Editable-styled" data-block="true" data-editor="cm257" data-offset-key="1mfbe-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="1mfbe-0-0"><span data-offset-key="1mfbe-0-0"><span style="color: rgba(255, 0, 0, 1)"><strong>最新代码是通过 事件总线</strong></span> <span data-offset-key="1mfbe-0-1">来跨方法传递信息和触发动作。通过发布和订阅事件，模块之间能够解耦通信，使得事件的发布和处理不再依赖于直接调用方法的方式，而是通过事件总线进行跨模块、跨方法的异步传递。这种方式提高了系统的灵活性和扩展性，同时保持了模块之间的松耦合。</span></span></div>
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="1mfbe-0-0"><span data-offset-key="fa8aa-0-0"><strong><span style="color: rgba(255, 0, 0, 1)">长代码警告</span></strong>，有兴趣可以fork仓库进行实际操练 <span style="color: rgba(255, 0, 0, 1)"><strong><a class="Link ztext-link" href="https://gitee.com/zh1446802857/vecore" target="_blank" data-offset-key="fa8aa-1-0" data-editable="true" rel="noopener nofollow"><span style="color: rgba(255, 0, 0, 1)" data-offset-key="fa8aa-1-0">VerEasy.Core</span></a><span data-offset-key="fa8aa-2-0">。</span></strong></span></span></div>
</blockquote>
<p>必要的知识点大致如此，通过代码+注释的形式来演示更好理解。</p>
<p>我这里是NETCore项目，所以还是接口的形式方便依赖注入。</p>
<h2>接口部分代码</h2>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">interface</span><span style="color: rgba(0, 0, 0, 1)"> IRabbitMQPersistentConnection
    {
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 是否已经连接：判断MQ是否是连接状态
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">bool</span> IsConnected { <span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">; }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 尝试连接：断连重连方法
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
        Task&lt;<span style="color: rgba(0, 0, 255, 1)">bool</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 唯一通道：发布通道可以随时关闭，消费通道需要保持打开状态，否则无法进行消费。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        IChannel Channel { <span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">; }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 唯一连接：同理，一个连接可以有N个通道，无需建立过多连接。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        IConnection Connection { <span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">; }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 释放
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
<span style="color: rgba(0, 0, 0, 1)">        Task DisposeAsync();

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 发布：发布消息
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="msg"&gt;&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="exChangeName"&gt;&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="routeKey"&gt;&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="type"&gt;&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
        Task PublishAsync(<span style="color: rgba(0, 0, 255, 1)">string</span> msg, <span style="color: rgba(0, 0, 255, 1)">string</span> exChangeName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VECLOG</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> routeKey = <span style="color: rgba(128, 0, 0, 1)">""</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> type =<span style="color: rgba(0, 0, 0, 1)"> ExchangeType.Fanout);

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 订阅：订阅队列。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
        Task SubscribeAsync(<span style="color: rgba(0, 0, 255, 1)">string</span> exChangeName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VECLOG</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> routeKey = <span style="color: rgba(128, 0, 0, 1)">""</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> type =<span style="color: rgba(0, 0, 0, 1)"> ExchangeType.Fanout);
    }</span></pre>
</div>
<h2>接口实现部分代码</h2>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RabbitMQPersistentConnection : IRabbitMQPersistentConnection
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">构造函数注入,获取MQ的地址账号密码端口,如果不传就用我默认配置的。</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> RabbitMQPersistentConnection(IConnectionFactory? connectionFactory = <span style="color: rgba(0, 0, 255, 1)">null</span>, <span style="color: rgba(0, 0, 255, 1)">int</span> retryCount = <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            _connectionFactory </span>= connectionFactory ?? <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ConnectionFactory
            {
                HostName </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:HostName</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                UserName </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:UserName</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                Password </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:PassWord</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                Port </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:Port</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).ObjToInt()
            };
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">使用Policy进行重连，这个是重连次数=5</span>
            _retryCount =<span style="color: rgba(0, 0, 0, 1)"> retryCount;
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">私有变量，获取连接成功时创建的Mq通道。</span>
        <span style="color: rgba(0, 0, 255, 1)">private</span> IChannel _channel = <span style="color: rgba(0, 0, 255, 1)">default</span>!<span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> IChannel Channel
        {
            </span><span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _channel;
            }
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> RabbitMQ 连接工厂
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IConnectionFactory _connectionFactory;

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 私有变量 RabbitMQ 连接上下文
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">private</span> IConnection _connection = <span style="color: rgba(0, 0, 255, 1)">default</span>!<span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 重连次数
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> _retryCount;

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 标志是否已释放
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> _disposed;

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 是否有效连接
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> IsConnected
        {
            </span><span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> _connection != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; _connection.IsOpen &amp;&amp; !<span style="color: rgba(0, 0, 0, 1)">_disposed;
            }
        }

        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> IConnection Connection
        {
            </span><span style="color: rgba(0, 0, 255, 1)">get</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _connection;
            }
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 手动释放
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task DisposeAsync()
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_disposed) <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;

            _disposed </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;

            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _connection.DisposeAsync();
            }
            </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (IOException ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 重连机制
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task&lt;<span style="color: rgba(0, 0, 255, 1)">bool</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync()
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> policy = Policy.Handle&lt;SocketException&gt;()<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">捕获连接异常</span>
                .Or&lt;BrokerUnreachableException&gt;()<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">无法连接异常</span>
                .WaitAndRetryAsync(_retryCount, x =&gt;<span style="color: rgba(0, 0, 0, 1)">
                TimeSpan.FromSeconds(Math.Pow(</span><span style="color: rgba(128, 0, 128, 1)">2</span>, x)), (ex, time) =&gt;<span style="color: rgba(0, 0, 0, 1)">
                {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">日志</span>
<span style="color: rgba(0, 0, 0, 1)">                });

            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">await</span> policy.ExecuteAsync(<span style="color: rgba(0, 0, 255, 1)">async</span> () =&gt;<span style="color: rgba(0, 0, 0, 1)">
                {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">重建连接【赋值给私有化变量,通过get同步给接口里的Connection和Channel】</span>
                    _connection = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _connectionFactory.CreateConnectionAsync();
                    _channel </span>= <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _connection.CreateChannelAsync();
                });

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果连接成功</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (IsConnected)
                {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 连接成功后，注册连接关闭、异常、阻塞的事件处理程序</span>
                    _connection.ConnectionShutdownAsync +=<span style="color: rgba(0, 0, 0, 1)"> OnConnectionShutdownAsync;
                    _connection.CallbackExceptionAsync </span>+=<span style="color: rgba(0, 0, 0, 1)"> OnCallbackExceptionAsync;
                    _connection.ConnectionBlockedAsync </span>+=<span style="color: rgba(0, 0, 0, 1)"> OnConnectionBlockedAsync;
                    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
                {
                    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
                }
            }
            </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception ex)
            {
                Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">重连失败，最终抛出异常: {ex.Message}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
            }
        }

        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task OnConnectionShutdownAsync(<span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> sender, ShutdownEventArgs e)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_disposed) <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ连接关闭，正在尝试重连...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();
        }

        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task OnCallbackExceptionAsync(<span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> sender, CallbackExceptionEventArgs e)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_disposed) <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ连接出现异常，正在尝试重连... 异常信息: {e.Exception.Message}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();
        }

        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task OnConnectionBlockedAsync(<span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> sender, ConnectionBlockedEventArgs e)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_disposed) <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ连接被阻塞，正在尝试重连...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发布消息</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task PublishAsync(<span style="color: rgba(0, 0, 255, 1)">string</span> msg, <span style="color: rgba(0, 0, 255, 1)">string</span> exChangeName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VECLOG</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> routeKey = <span style="color: rgba(128, 0, 0, 1)">""</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> type =<span style="color: rgba(0, 0, 0, 1)"> ExchangeType.Fanout)
        {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">判断是否连接状态，没有连接就重连</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">IsConnected)
            {
                </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();
            }

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建通道，因为是发布消息，通道不用常打开，所以使用了USING</span>
            <span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> channel = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _connection.CreateChannelAsync();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">【ExchangeDeclareAsync】声明交换机，exchange：交换机名称，type：交换机类型</span>
            <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> channel.ExchangeDeclareAsync(exchange: exChangeName, type: type);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">msg就是消息,需要传递Byte[]</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> body =<span style="color: rgba(0, 0, 0, 1)"> Encoding.UTF8.GetBytes(msg);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">启动消息持久化,我的项目里使用MQ来进行公告的推送,使用的Fanout类型交换机，故此消息保持持久化。</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> properties = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BasicProperties()
            {
                Persistent </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">,
            };

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发布消息</span>
            <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> channel.BasicPublishAsync(
                exchange: exChangeName,
                routingKey: routeKey,
                mandatory: </span><span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">,
                basicProperties: properties,
                body: body);
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">订阅消息</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task SubscribeAsync(<span style="color: rgba(0, 0, 255, 1)">string</span> exChangeName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VECLOG</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> routeKey = <span style="color: rgba(128, 0, 0, 1)">""</span>, <span style="color: rgba(0, 0, 255, 1)">string</span> type =<span style="color: rgba(0, 0, 0, 1)"> ExchangeType.Fanout)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">IsConnected)
            {
                </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> TryConnectAsync();
            }
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">【queue】队列</span>
            <span style="color: rgba(0, 0, 255, 1)">string</span> queueName = <span style="color: rgba(0, 0, 255, 1)">string</span>.IsNullOrWhiteSpace(routeKey) ?<span style="color: rgba(0, 0, 0, 1)"> exChangeName : routeKey;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">【durable】持久化队列,MQ服务器不会删除它。</span>
            QueueDeclareOk queueDeclareResult = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> Channel.QueueDeclareAsync(
                 queue: queueName,
                  durable: </span><span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">,
                  exclusive: </span><span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">,
                  autoDelete: </span><span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">根据queue,exchange,routingKey 对 交换机和队列进行绑定，如果是Fanout类型不需要routeKey。</span>
            <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> Channel.QueueBindAsync(queue: queueName, exchange: exChangeName, routingKey: routeKey);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建消费者</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> consumer = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> AsyncEventingBasicConsumer(Channel);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消费者消费后执行方法</span>
            consumer.ReceivedAsync += <span style="color: rgba(0, 0, 255, 1)">async</span> (model, ea) =&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] body =<span style="color: rgba(0, 0, 0, 1)"> ea.Body.ToArray();
                </span><span style="color: rgba(0, 0, 255, 1)">var</span> message =<span style="color: rgba(0, 0, 0, 1)"> Encoding.UTF8.GetString(body);
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">确认消息已被消费,这样后续该消息就不会被该队列继续消费到了。</span>
                <span style="color: rgba(0, 0, 255, 1)">await</span> Channel.BasicAckAsync(ea.DeliveryTag, multiple: <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">);
            };
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">启动消费者队列，将消费者和队列绑定</span>
            <span style="color: rgba(0, 0, 255, 1)">await</span> Channel.BasicConsumeAsync(queueName, autoAck: <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">, consumer: consumer);
        }
    }</span></pre>
</div>
<h2>MQ服务注入</h2>
<div class="cnblogs_code">
<pre>            <span style="color: rgba(0, 0, 255, 1)">if</span> (Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Enable</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).ObjToBool())
            {
                services.AddSingleton</span>&lt;IRabbitMQPersistentConnection&gt;(x =&gt;<span style="color: rgba(0, 0, 0, 1)">
                {
                    </span><span style="color: rgba(0, 0, 255, 1)">var</span> connectionFactory = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ConnectionFactory()
                    {
                        HostName </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:HostName</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                        UserName </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:UserName</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                        Password </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:PassWord</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                        Port </span>= Appsettings.AppStr(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RabbitMQ:Connection:Port</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).ObjToInt()
                    };
                    </span><span style="color: rgba(0, 0, 255, 1)">var</span> mq = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> RabbitMQPersistentConnection(connectionFactory);

                    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> mq;
                });
            }</span></pre>
</div>
<hr>
<h2>我在注入各种服务时，添加了一些日志进行输出，效果如下：</h2>
<p><img src="https://img2024.cnblogs.com/blog/2125261/202503/2125261-20250306164016055-1782178780.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
</div>
</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="4.561964343305555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-06 16:45">2025-03-06 16:44</span>&nbsp;
<a href="https://www.cnblogs.com/zhang-3">尝尝手指</a>&nbsp;
阅读(<span id="post_view_count">42</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18755814" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18755814);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18755814', targetLink: 'https://www.cnblogs.com/zhang-3/p/18755814', title: 'VEC系列-RabbitMQ 入门笔记' })">举报</a>
</div>
    