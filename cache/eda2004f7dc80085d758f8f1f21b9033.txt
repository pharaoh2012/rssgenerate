
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sdcb/p/18996305/mcp-impl" title="发布于 2025-07-23 08:45">
    <span role="heading" aria-level="2">抛开官方库，手撸一个轻量级 MCP 服务端</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好！在昨天的文章 <strong>《<a href="https://www.cnblogs.com/sdcb/p/18995424/mcp-http-insights" target="_blank">官方文档没告诉你的：通过抓包，深入揭秘MCP协议底层通信</a>》</strong> 中，我们通过Fiddler工具，像侦探一样，一步步揭开了MCP（Model Context Protocol）在无状态HTTP模式下的神秘面纱。我们搞清楚了它的两步握手、SSE（Server-Sent Events）响应机制以及精巧的两种错误处理方式。</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202507/233608-20250721180142485-1405261865.png" alt="image" loading="lazy"></p>
<p>然而，仅仅停留在理论分析层面总感觉意犹未尽。更重要的是，当我们审视官方提供的 <code>ModelContextProtocol.AspNetCore</code> 这个NuGet包时（当前版本0.3.0-preview.3），会发现它目前引入了相当多的依赖项：</p>
<ul>
<li><code>Microsoft.Bcl.Memory (&gt;= 9.0.5)</code></li>
<li><code>Microsoft.Extensions.AI.Abstractions (&gt;= 9.7.1)</code></li>
<li><code>Microsoft.Extensions.Logging.Abstractions (&gt;= 8.0.3)</code></li>
<li><code>System.Diagnostics.DiagnosticSource (&gt;= 8.0.1)</code></li>
<li><code>System.IO.Pipelines (&gt;= 8.0.0)</code></li>
<li><code>System.Net.ServerSentEvents (&gt;= 10.0.0-preview.4.25258.110)</code></li>
<li><code>System.Text.Json (&gt;= 8.0.6)</code></li>
<li><code>System.Threading.Channels (&gt;= 8.0.0)</code></li>
<li><code>Microsoft.Extensions.Hosting.Abstractions (&gt;= 8.0.1)</code></li>
<li><code>ModelContextProtocol.Core (&gt;= 0.3.0-preview.3)</code></li>
</ul>
<p>其中，最令人不安的莫过于 <code>System.Net.ServerSentEvents</code>，它竟然是一个 <strong>.NET 10 的预览版</strong>包！在生产环境中使用预览版包，通常是大忌。</p>
<p>既然我们已经通过抓包掌握了协议的全部细节，那么，何不自己动手，实现一个轻量级、零预览版依赖的MCP服务端呢？这不仅是一次绝佳的学习实践，也能让我们对协议的理解更上一层楼。</p>
<p>今天，我们就来完成这个挑战：不依赖官方服务端库，直接用纯粹的ASP.NET Core代码，实现一个功能完备的MCP服务端。</p>
<h3 id="我们的目标保持工具定义的简洁性">我们的目标：保持工具定义的简洁性</h3>
<p>在动手之前，我们先定一个目标。我们希望定义工具（Tools）的方式能够尽可能地简洁和直观，几乎和昨天的代码保持一致：</p>
<pre><code class="language-csharp">using System.ComponentModel;

public class Tools(IHttpContextAccessor http)
{
    [Description("Echoes the message back to the client.")]
    public string Echo(string message) =&gt; $"hello {message}";

    [Description("Returns the IP address of the client.")]
    public string EchoIP() =&gt; http.HttpContext?.Connection.RemoteIpAddress?.ToString() ?? "Unknown";

    [Description("Counts from 0 to n, reporting progress at each step.")]
    public async Task&lt;int&gt; Count(int n, IProgress&lt;ProgressNotificationValue&gt; progress)
    {
        for (int i = 0; i &lt; n; ++i)
        {
            progress.Report(new ProgressNotificationValue()
            {
                Progress = i,
                Total = n,
                Message = $"Step {i} of {n}",
            });
            await Task.Delay(100);
        }
        return n;
    }

    [Description("Throws an exception for testing purposes.")]
    public string TestThrow()
    {
        throw new Exception("This is a test exception");
    }
}
</code></pre>
<p>注意到变化了吗？我们去掉了官方库定义的 <code>[McpServerToolType]</code> 和 <code>[McpServerTool]</code> 特性。取而代之的是一种更符合ASP.NET Core直觉的方式：<strong>任何 <code>public</code> 方法都自动成为一个工具</strong>，并使用标准的 <code>System.ComponentModel.DescriptionAttribute</code> 来提供工具描述。</p>
<h3 id="理想中的使用方式">理想中的使用方式</h3>
<p>我们期望最终的使用方式能像下面这样优雅：</p>
<pre><code class="language-csharp">WebApplicationBuilder builder = WebApplication.CreateBuilder();

// 1. 注册原生服务和我们的工具类
builder.Services.AddHttpContextAccessor();
builder.Services.AddTransient&lt;Tools&gt;();

WebApplication app = builder.Build();

// 2. 映射 MCP 端点，自动发现并使用 Tools 类
app.MapMcpEndpoint&lt;Tools&gt;("/");

// 3. 启动应用
app.Run();
</code></pre>
<p>是的，你没看错。核心就在于 <code>builder.Services.AddTransient&lt;Tools&gt;();</code> 和 <code>app.MapMcpEndpoint&lt;Tools&gt;("/");</code> 这两行。前者负责将我们的工具类注册到依赖注入容器，后者则是我们即将创建的魔法扩展方法，它会自动处理所有MCP协议的细节。</p>
<h3 id="第一步定义协议的语言---dtos">第一步：定义协议的“语言” - DTOs</h3>
<p>要实现协议，首先要定义好通信双方所使用的“语言”，也就是数据传输对象（DTOs）。根据昨天的抓包分析，我们用C#的 <code>record</code> 类型来精确描述这些JSON结构。</p>
<pre><code class="language-csharp">using System.Text.Json.Serialization;

// --- JSON-RPC Base Structures ---
public record JsonRpcRequest(
    [property: JsonPropertyName("jsonrpc")] string JsonRpc,
    [property: JsonPropertyName("method")] string Method,
    [property: JsonPropertyName("params")] object? Params,
    [property: JsonPropertyName("id")] int? Id
);

public record JsonRpcResponse(
    [property: JsonPropertyName("jsonrpc")] string JsonRpc,
    [property: JsonPropertyName("result")] object? Result,
    [property: JsonPropertyName("error")] object? Error,
    [property: JsonPropertyName("id")] int? Id
);

public record JsonRpcError(
    [property: JsonPropertyName("code")] int Code,
    [property: JsonPropertyName("message")] string Message
);

// --- MCP Specific Payloads ---

// For initialize method
public record InitializeParams(
    [property: JsonPropertyName("protocolVersion")] string ProtocolVersion,
    [property: JsonPropertyName("clientInfo")] ClientInfo ClientInfo
);
public record ClientInfo([property: JsonPropertyName("name")] string Name, [property: JsonPropertyName("version")] string Version);

public record InitializeResult(
    [property: JsonPropertyName("protocolVersion")] string ProtocolVersion,
    [property: JsonPropertyName("capabilities")] ServerCapabilities Capabilities,
    [property: JsonPropertyName("serverInfo")] ClientInfo ServerInfo
);
public record ServerCapabilities([property: JsonPropertyName("tools")] object Tools);


// For tools/call method
public record ToolCallParams(
    [property: JsonPropertyName("name")] string Name,
    [property: JsonPropertyName("arguments")] Dictionary&lt;string, object?&gt; Arguments,
    [property: JsonPropertyName("_meta")] ToolCallMeta? Meta
);
public record ToolCallMeta([property: JsonPropertyName("progressToken")] string ProgressToken);

// For tool call results
public record ToolCallResult(
    [property: JsonPropertyName("content")] List&lt;ContentItem&gt; Content,
    [property: JsonPropertyName("isError")] bool IsError = false
);
public record ContentItem([property: JsonPropertyName("type")] string Type, [property: JsonPropertyName("text")] string Text);

// For tools/list results
public record ToolListResult(
    [property: JsonPropertyName("tools")] List&lt;ToolDefinition&gt; Tools
);

public record ToolDefinition(
    [property: JsonPropertyName("name")] string Name,
    [property: JsonPropertyName("description")] string Description,
    [property: JsonPropertyName("inputSchema")] object InputSchema
);

// For progress notifications
public record ProgressNotification(
    [property: JsonPropertyName("jsonrpc")] string JsonRpc,
    [property: JsonPropertyName("method")] string Method,
    [property: JsonPropertyName("params")] ProgressParams Params
);
public record ProgressParams(
    [property: JsonPropertyName("progressToken")] string ProgressToken,
    [property: JsonPropertyName("progress")] int Progress,
    [property: JsonPropertyName("total")] int Total,
    [property: JsonPropertyName("message")] string Message
);

// This class is for the IProgress&lt;T&gt; interface in our Tools methods
public class ProgressNotificationValue
{
    public int Progress { get; set; }
    public int Total { get; set; }
    public string Message { get; set; } = string.Empty;
}
</code></pre>
<h3 id="第二步打造核心引擎---mcpendpointextensions">第二步：打造核心引擎 - <code>McpEndpointExtensions</code></h3>
<p>接下来，就是实现我们魔法的源泉：一个<code>IEndpointRouteBuilder</code>的扩展方法。我们将所有逻辑都封装在一个静态类 <code>McpEndpointExtensions</code> 中。</p>
<p>这个类将负责：</p>
<ol>
<li><strong>路由映射</strong>：监听指定路径的 <code>POST</code> 和 <code>GET</code> 请求。</li>
<li><strong>请求分发</strong>：根据JSON-RPC请求中的<code>method</code>字段，调用不同的处理函数。</li>
<li><strong>工具发现与调用</strong>：使用反射来查找和执行<code>TTools</code>类中的工具方法。</li>
<li><strong>响应构建</strong>：手动构建符合SSE规范的响应流。</li>
<li><strong>错误处理</strong>：精确复现抓包分析中发现的两种错误模型。</li>
</ol>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Primitives;
using System.ComponentModel;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

public static class McpEndpointExtensions
{
    // JSON-RPC Error Codes from your article's findings
    private const int InvalidParamsErrorCode = -32602; // Invalid params
    private const int MethodNotFoundErrorCode = -32601; // Method not found

    private static readonly JsonSerializerOptions s_jsonOptions = new()
    {
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    };

    /// &lt;summary&gt;
    /// Maps an endpoint that speaks the Model Context Protocol.
    /// &lt;/summary&gt;
    public static IEndpointRouteBuilder MapMcpEndpoint&lt;TTools&gt;(this IEndpointRouteBuilder app, string pattern) where TTools : class
    {
        // 预先通过反射发现所有工具方法，并转换为snake_case以匹配MCP命名习惯
        Dictionary&lt;string, MethodInfo&gt; methods = typeof(TTools).GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .ToDictionary(k =&gt; ToSnakeCase(k.Name), v =&gt; v);

        app.MapPost(pattern, async (HttpContext context, [FromServices] IServiceProvider sp) =&gt;
        {
            JsonRpcRequest? request = await JsonSerializer.DeserializeAsync&lt;JsonRpcRequest&gt;(context.Request.Body, s_jsonOptions);
            if (request == null)
            {
                context.Response.StatusCode = 400; // Bad Request
                return;
            }

            // 核心：处理不同的MCP方法
            switch (request.Method)
            {
                case "initialize":
                    await HandleInitialize(context, request);
                    break;
                case "notifications/initialized":
                    // 在无状态模式下，这个请求只是一个确认，我们返回与initialize类似的信息
                    await HandleInitialize(context, request);
                    break;
                case "tools/list":
                    await HandleToolList&lt;TTools&gt;(context, request);
                    break;
                case "tools/call":
                    await HandleToolCall&lt;TTools&gt;(context, request, sp, methods);
                    break;
                default:
                    JsonRpcResponse errorResponse = new("2.0", null, new JsonRpcError(MethodNotFoundErrorCode, "Method not found"), request.Id);
                    await WriteSseMessageAsync(context.Response, errorResponse);
                    break;
            }
        });

        // 旧版SDK会发送GET请求，我们明确返回405
        app.MapGet(pattern, context =&gt;
        {
            context.Response.StatusCode = StatusCodes.Status405MethodNotAllowed;
            context.Response.Headers.Allow = "POST";
            return Task.CompletedTask;
        });

        return app;
    }

    private static string ToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        var sb = new StringBuilder(name.Length);
        for (int i = 0; i &lt; name.Length; i++)
        {
            char c = name[i];
            if (char.IsUpper(c))
            {
                if (sb.Length &gt; 0 &amp;&amp; i &gt; 0 &amp;&amp; !char.IsUpper(name[i-1])) sb.Append('_');
                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }

    private static async Task HandleInitialize(HttpContext context, JsonRpcRequest request)
    {
        // 复用或创建 Session ID
        string sessionId = context.Request.Headers.TryGetValue("Mcp-Session-Id", out StringValues existingSessionId)
            ? existingSessionId.ToString()
            : WebEncoders.Base64UrlEncode(Guid.NewGuid().ToByteArray());

        context.Response.Headers["Mcp-Session-Id"] = sessionId;

        // 构建与抓包一致的响应
        InitializeResult result = new(
            "2025-06-18", // Echo the protocol version
            new ServerCapabilities(new { listChanged = true }), // Mimic the capabilities
            new ClientInfo("PureAspNetCoreMcpServer", "1.0.0")
        );
        JsonRpcResponse response = new("2.0", result, null, request.Id);
        await WriteSseMessageAsync(context.Response, response);
    }

    private static async Task HandleToolList&lt;TTools&gt;(HttpContext context, JsonRpcRequest request) where TTools : class
    {
        EchoSessionId(context);

        List&lt;ToolDefinition&gt; toolDefs = [];
        MethodInfo[] toolMethods = typeof(TTools).GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        foreach (MethodInfo method in toolMethods)
        {
            string description = method.GetCustomAttribute&lt;DescriptionAttribute&gt;()?.Description ?? "No description.";

            // 简化的动态Schema生成
            Dictionary&lt;string, object&gt; properties = [];
            List&lt;string&gt; required = [];
            foreach (ParameterInfo param in method.GetParameters())
            {
                if (param.ParameterType == typeof(IProgress&lt;ProgressNotificationValue&gt;)) continue; // 忽略进度报告参数
                properties[param.Name!] = new { type = GetJsonType(param.ParameterType) };
                if (!param.IsOptional)
                {
                    required.Add(param.Name!);
                }
            }
            var schema = new { type = "object", properties, required };
            toolDefs.Add(new ToolDefinition(ToSnakeCase(method.Name), description, schema));
        }

        ToolListResult result = new(toolDefs);
        JsonRpcResponse response = new("2.0", result, null, request.Id);
        await WriteSseMessageAsync(context.Response, response);
    }

    private static async Task HandleToolCall&lt;TTools&gt;(HttpContext context, JsonRpcRequest request, IServiceProvider sp, Dictionary&lt;string, MethodInfo&gt; methods) where TTools : class
    {
        EchoSessionId(context);

        ToolCallParams? toolCallParams = JsonSerializer.Deserialize&lt;ToolCallParams&gt;(JsonSerializer.Serialize(request.Params, s_jsonOptions), s_jsonOptions);
        if (toolCallParams == null) return;

        string toolName = toolCallParams.Name;
        methods.TryGetValue(toolName, out MethodInfo? method);

        // 场景1: 调用不存在的工具 -&gt; 返回标准JSON-RPC错误
        if (method == null)
        {
            JsonRpcError error = new(InvalidParamsErrorCode, $"Unknown tool: '{toolName}'");
            JsonRpcResponse response = new("2.0", null, error, request.Id);
            await WriteSseMessageAsync(context.Response, response);
            return;
        }

        // 使用DI容器创建工具类的实例
        using IServiceScope scope = sp.CreateScope();
        TTools toolInstance = scope.ServiceProvider.GetRequiredService&lt;TTools&gt;();

        object? resultValue;
        bool isError = false;

        try
        {
            // 通过反射准备方法参数
            ParameterInfo[] methodParams = method.GetParameters();
            object?[] args = new object?[methodParams.Length];
            for (int i = 0; i &lt; methodParams.Length; i++)
            {
                ParameterInfo p = methodParams[i];
                if (p.ParameterType == typeof(IProgress&lt;ProgressNotificationValue&gt;))
                {
                    // 创建一个IProgress&lt;T&gt;的实现，它会将进度作为SSE消息发回客户端
                    args[i] = new ProgressReporter(context.Response, toolCallParams.Meta!.ProgressToken);
                }
                else if (toolCallParams.Arguments.TryGetValue(p.Name!, out object? argValue) &amp;&amp; argValue is JsonElement element)
                {
                    args[i] = element.Deserialize(p.ParameterType, s_jsonOptions);
                }
                else if (p.IsOptional)
                {
                    args[i] = p.DefaultValue;
                }
                else
                {
                     // 场景2a: 缺少必要参数 -&gt; 抛出异常，进入catch块
                    throw new TargetParameterCountException($"Tool '{toolName}' requires parameter '{p.Name}' but it was not provided.");
                }
            }

            object? invokeResult = method.Invoke(toolInstance, args);

            // 处理异步方法
            if (invokeResult is Task task)
            {
                await task;
                resultValue = task.GetType().IsGenericType ? task.GetType().GetProperty("Result")?.GetValue(task) : null;
            }
            else
            {
                resultValue = invokeResult;
            }
        }
        // 场景2b: 工具执行时内部抛出异常 -&gt; isError: true
        catch (Exception ex)
        {
            isError = true;
            // 将异常信息包装在result中，而不是顶层error
            resultValue = $"An error occurred invoking '{toolName}'. Details: {ex.InnerException?.Message ?? ex.Message}";
        }

        List&lt;ContentItem&gt; content = [new("text", resultValue?.ToString() ?? string.Empty)];
        ToolCallResult result = new(content, isError);
        JsonRpcResponse finalResponse = new("2.0", result, null, request.Id);
        await WriteSseMessageAsync(context.Response, finalResponse);
    }

    // 手动实现SSE消息写入，告别预览版包
    private static async Task WriteSseMessageAsync(HttpResponse response, object data)
    {
        if (!response.Headers.ContainsKey("Content-Type"))
        {
            response.ContentType = "text/event-stream";
            response.Headers.CacheControl = "no-cache,no-store";
            response.Headers.ContentEncoding = "identity";
            response.Headers.KeepAlive = "true";
        }

        string json = JsonSerializer.Serialize(data, s_jsonOptions);
        string message = $"event: message\ndata: {json}\n\n";
        await response.WriteAsync(message);
        await response.Body.FlushAsync();
    }

    private static void EchoSessionId(HttpContext context)
    {
        if (context.Request.Headers.TryGetValue("Mcp-Session-Id", out StringValues sessionId))
        {
            context.Response.Headers["Mcp-Session-Id"] = sessionId;
        }
    }

    private static string GetJsonType(Type type) =&gt; Type.GetTypeCode(type) switch
    {
        TypeCode.String =&gt; "string",
        TypeCode.Int32 or TypeCode.Int64 or TypeCode.Int16 or TypeCode.UInt32 =&gt; "integer",
        TypeCode.Double or TypeCode.Single or TypeCode.Decimal =&gt; "number",
        TypeCode.Boolean =&gt; "boolean",
        _ =&gt; "object"
    };

    // 专门用于处理进度报告的辅助类
    private class ProgressReporter(HttpResponse response, string token) : IProgress&lt;ProgressNotificationValue&gt;
    {
        public void Report(ProgressNotificationValue value)
        {
            ProgressParams progressParams = new(token, value.Progress, value.Total, value.Message);
            ProgressNotification notification = new("2.0", "notifications/progress", progressParams);
            // 警告: 在同步方法中调用异步代码，在真实生产环境中需要更优雅的处理
            WriteSseMessageAsync(response, notification).GetAwaiter().GetResult();
        }
    }
}
</code></pre>
<h3 id="完整代码已备好">完整代码已备好！</h3>
<p>为了方便大家动手实践，我已经将上述所有可直接运行的示例代码上传到了 GitHub Gist。您可以通过以下链接访问：</p>
<ul>
<li><strong><a href="https://gist.github.com/sdcb/80353c3273cd1a89b839c6d40fb1adbc" target="_blank" rel="noopener nofollow">https://gist.github.com/sdcb/80353c3273cd1a89b839c6d40fb1adbc</a></strong></li>
</ul>
<p>该Gist中包含了两个文件：</p>
<ul>
<li><code>mcp-server-raw.linq</code>: 我们刚刚从零开始构建的轻量级MCP服务端。</li>
<li><code>mcp-client.linq</code>: 用于测试的客户端。</li>
</ul>
<p>这两个文件都可以直接在最新版的 <strong>LINQPad</strong> 中打开并运行，让您能够立即体验和调试，如果您访问 Github Gist 有困难，则可以访问这个备用地址：<strong><a href="https://github.com/sdcb/blog-data/tree/master/2025" target="_blank" rel="noopener nofollow">https://github.com/sdcb/blog-data/tree/master/2025</a></strong></p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202507/233608-20250721180211556-760850950.png" alt="bg" loading="lazy"></p>
<h3 id="第三步见证奇迹的时刻">第三步：见证奇迹的时刻</h3>
<p>现在，我们所有的准备工作都已就绪。我们可以用和昨天一模一样的客户端代码来测试我们的新服务端了：</p>
<pre><code class="language-csharp">// 客户端代码完全不变！
var clientTransport = new SseClientTransport(new SseClientTransportOptions()
{
    Name = "MyServer",
    Endpoint = new Uri("http://localhost:5000"), // 注意端口可能不同
});

var client = await McpClientFactory.CreateAsync(clientTransport);

// 1. 列出工具
(await client.ListToolsAsync()).Select(x =&gt; new { x.Name, Desc = JsonObject.Parse(x.JsonSchema.ToString()) }).Dump();

// 2. 调用简单工具
(await client.CallToolAsync(
    "echo",
    new Dictionary&lt;string, object?&gt;() { ["message"] = ".NET is awesome!" },
    cancellationToken: CancellationToken.None)).Dump();

// 3. 调用带进度的工具
(await client.CallToolAsync(
    "count",
    new Dictionary&lt;string, object?&gt;() { ["n"] = 5 },
    new Reporter(),
    cancellationToken: CancellationToken.None)).Dump();
    
// 4. 调用会抛出异常的工具
(await client.CallToolAsync("test_throw", cancellationToken: CancellationToken.None)).Dump();

// 5. 调用不存在的工具
(await client.CallToolAsync("not-existing-tool", cancellationToken: CancellationToken.None)).Dump();

// ... Reporter class as before ...
</code></pre>
<p>启动我们的新服务端，再运行客户端代码。打开抓包工具，你会发现，所有HTTP请求和SSE响应的格式、内容和行为，都与昨天分析的官方库实现<strong>完全一致</strong>！我们成功了！</p>
<h3 id="对错误处理的进一步思考">对错误处理的进一步思考</h3>
<p>值得一提的是，昨天的文章没有深入探讨参数错误的情况。比如 <code>count</code> 工具需要一个名为 <code>n</code> 的 <code>int</code> 类型参数，如果客户端错误地传递了一个 <code>n2</code> 参数，会发生什么？</p>
<p>在我今天实现的 <code>HandleToolCall</code> 方法中，参数匹配逻辑会因为找不到名为 <code>n</code> 的键而抛出 <code>TargetParameterCountException</code>。这个异常会被 <code>try-catch</code> 块捕获，然后和 <code>test_throw</code> 的情况一样，返回一个调用“成功”（HTTP 200）、但在 <code>result</code> 载荷中包含 <code>"isError": true</code> 和详细错误信息的响应。这恰好证明了MCP这种错误处理设计的健壮性：它能统一处理业务逻辑层面（工具内部异常）和参数绑定层面（调用约定不匹配）的多种失败情况。</p>
<h3 id="总结">总结</h3>
<p>通过本次实践，我们不仅重温了MCP协议的通信原理，更重要的是，我们亲手实现了一个轻量级、无预览版依赖的MCP服务端。这次旅程的核心收获是：</p>
<ol>
<li><strong>协议是根基</strong>：一旦深刻理解了协议本身，即使没有官方SDK，我们也能在任何支持HTTP的环境中实现它。</li>
<li><strong>化繁为简</strong>：我们用一个扩展方法和一些辅助类，就替代了官方库及其繁杂的依赖，代码清晰且易于掌控。</li>
<li><strong>反射与元编程的威力</strong>：通过巧妙运用反射，我们实现了工具的自动发现和动态调用，大大提高了代码的灵活性和可扩展性。</li>
<li><strong>知其然，知其所以然</strong>：现在，我们不仅知道MCP如何工作，更通过自己动手理解了它为何如此设计，比如两步握手、SSE流式响应以及分层的错误处理机制。</li>
</ol>
<p>希望本文能帮助你彻底搞懂并掌握MCP协议的实现细节。现在，你拥有了完全控制MCP通信的能力，无论是进行二次开发、跨语言实现，还是仅仅为了满足那份技术探索的好奇心。</p>
<hr>
<p>感谢您的阅读，如果您有任何问题或想法，欢迎在评论区留言讨论。</p>
<p>也欢迎加入我们的 <strong>.NET骚操作</strong> QQ群一起探讨：<strong>495782587</strong></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-23 08:45">2025-07-23 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/sdcb">.NET骚操作</a>&nbsp;
阅读(<span id="post_view_count">92</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18996305);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18996305', targetLink: 'https://www.cnblogs.com/sdcb/p/18996305/mcp-impl', title: '抛开官方库，手撸一个轻量级 MCP 服务端' })">举报</a>
</div>
        