
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/songweipeng/p/18820536" title="发布于 2025-04-11 14:22">
    <span role="heading" aria-level="2">flowable任务监听器和java-service依赖注入问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>前言</h2>
<p class="ba94db8a"><strong>1. Flowable中Java服务任务的依赖注入方法，比如使用Spring的@Autowired或构造函数注入，并确保服务任务类由Spring管理。</strong></p>
<p class="ba94db8a"><strong>2. 流程引擎配置中启用依赖注入和表达式解析的相关设置。</strong></p>
<p class="ba94db8a"><strong>3. 异步任务执行器的配置，确保其与Spring上下文集成，处理依赖注入的Bean。</strong></p>
<p class="ba94db8a"><strong>4. 常见问题排查，如检查Bean的作用域、是否正确使用delegateExpression等。</strong></p>
<p class="ba94db8a"><strong>5. 可能的示例代码或配置片段，帮助用户理解如何正确配置。</strong></p>
<p class="ba94db8a"><strong>另外，可能需要提醒用户注意流程定义文件中的服务任务配置是否正确，比如是否使用了expression或delegateExpression来引用Spring Bean，或者是否直接指定了Java类导致Spring的依赖注入不生效。</strong></p>
<p class="ba94db8a"><strong>最后，如果有必要，可以比较一下在非Spring环境下如何手动处理依赖注入，但大部分情况下用户可能在使用Spring，所以重点放在Spring集成方面。</strong></p>
<h3 class="ba94db8a"><strong>一、Java服务任务依赖注入</strong></h3>
<p><strong>场景</strong>：在实现<code>JavaDelegate</code>的类中注入Spring管理的Bean（如Service、Repository）。</p>
<h4><strong>正确配置方法：</strong></h4>
<ul>
<li>
<p><strong>步骤1：将服务类注册为Spring Bean</strong></p>
</li>
</ul>
<div class="cnblogs_code">
<pre>@Component("myServiceTask") <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用名称便于流程中引用</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> MyServiceTask <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> JavaDelegate {
    
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> MyService myService;

    @Autowired </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 构造器注入推荐</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> MyServiceTask(MyService myService) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.myService =<span style="color: rgba(0, 0, 0, 1)"> myService;
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> execute(DelegateExecution execution) {
        myService.businessMethod();
    }
}</span></pre>
</div>
<ul>
<li>
<p><strong>步骤2：在流程定义中引用Bean</strong><br>使用<code>delegateExpression</code>指向Spring Bean的名称：</p>


</li>


</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">serviceTask </span><span style="color: rgba(255, 0, 0, 1)">id</span><span style="color: rgba(0, 0, 255, 1)">="serviceTask1"</span><span style="color: rgba(255, 0, 0, 1)"> name</span><span style="color: rgba(0, 0, 255, 1)">="My Task"</span><span style="color: rgba(255, 0, 0, 1)"> flowable:delegateExpression</span><span style="color: rgba(0, 0, 255, 1)">="${myServiceTask}"</span> <span style="color: rgba(0, 0, 255, 1)">/&gt;</span></pre>
</div>
<h4><strong>常见问题解决：</strong></h4>
<ul>
<li>
<p><strong>Bean注入为null</strong>：</p>
<ul>
<li>
<p>确保类被Spring扫描（位于@ComponentScan路径下）。</p>
</li>
<li>
<p>检查流程定义中是否错误使用<code>class</code>属性而非<code>delegateExpression</code>。</p>
</li>
<li>
<p>确认流程引擎配置启用了Spring集成。</p>
</li>
</ul>
</li>
<li>
<p><strong>表达式解析失败</strong>：<br>在<code>FlowableConfig</code>中启用表达式解析和Spring注入：</p>


</li>


</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Bean
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> SpringProcessEngineConfiguration processEngineConfiguration(DataSource dataSource, PlatformTransactionManager transactionManager) {
    SpringProcessEngineConfiguration config </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> SpringProcessEngineConfiguration();
    config.setDataSource(dataSource);
    config.setTransactionManager(transactionManager);
    config.setDatabaseSchemaUpdate(Flowable.DB_SCHEMA_UPDATE_TRUE);
    config.setAsyncExecutorEnabled(</span><span style="color: rgba(0, 0, 255, 1)">true</span>); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 启用异步执行器</span>
    config.setExpressionManager(<span style="color: rgba(0, 0, 255, 1)">new</span> SpringExpressionManager(applicationContext, <span style="color: rgba(0, 0, 255, 1)">null</span>)); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 启用Spring表达式</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> config;
}</span></pre>
</div>
<h3><strong>二. 异步任务执行器配置</strong></h3>
<p>当服务任务标记为异步（<code>flowable:async="true"</code>）时，任务由异步执行器处理。</p>
<h4><strong>配置异步执行器：</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Bean
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> AsyncExecutor asyncExecutor(DataSource dataSource) {
    DefaultAsyncExecutor asyncExecutor </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DefaultAsyncExecutor();
    asyncExecutor.setDataSource(dataSource);
    asyncExecutor.setCorePoolSize(</span>5); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 核心线程数</span>
    asyncExecutor.setMaxPoolSize(10); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最大线程数</span>
    asyncExecutor.setQueueSize(100); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 任务队列大小</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> asyncExecutor;
}</span></pre>
</div>
<p>在<code>processEngineConfiguration</code>中启用：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">config.setAsyncExecutor(asyncExecutor);
config.setAsyncExecutorEnabled(</span><span style="color: rgba(0, 0, 255, 1)">true</span>);</pre>
</div>
<h4><strong>异步任务依赖注入要点：</strong></h4>
<ul>
<li>
<p><strong>Bean作用域</strong>：异步任务可能在新线程中运行，确保注入的Bean是线程安全的或使用<code>@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</code>。</p>
</li>
<li>
<p><strong>事务管理</strong>：若异步任务涉及数据库操作，需配置<code>@Transactional</code>并确保事务传播正确。</p>
</li>
</ul>
<h3>三、通过ApplicationContextAware接口的方式获取ApplicationContext对象实例</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">可能的错误情况包括：没有在流程引擎配置中设置asyncExecutorEnabled为true，或者在服务任务中没有正确使用表达式导致注入失败。另外，Bean的作用域问题也可能导致依赖注入失败，

例如，如果Bean的作用域是原型（prototype），但在注入时可能需要不同的处理方式。以下是我通过ApplicationContextAware接口的方式获取ApplicationContext对象实例，再通过applicationContext.getBean(</span>"myService"<span style="color: rgba(0, 0, 0, 1)">)

方法获取对应的bean</span></pre>
</div>
<p><strong>代码示例：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Component
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> MyListener <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> TaskListener, ApplicationContextAware {

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)">  ApplicationContext applicationContext;

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> setApplicationContext(ApplicationContext arg0) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> BeansException {
        applicationContext </span>=<span style="color: rgba(0, 0, 0, 1)"> arg0;
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> notify(DelegateTask delegateTask) {

        String processInsId </span>=<span style="color: rgba(0, 0, 0, 1)"> delegateTask.getProcessInstanceId();
        MyService myService </span>= (MyService) applicationContext.getBean("myService"<span style="color: rgba(0, 0, 0, 1)">);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> TODO 执行service方法</span>
<span style="color: rgba(0, 0, 0, 1)">        
        System.out.println(</span>"==========执行监听器======"<span style="color: rgba(0, 0, 0, 1)">);
    }

}</span></pre>
</div>
<h3><strong>四. 常见问题排查</strong></h3>
<ul>
<li>
<p><strong>错误：无法解析表达式<code>${myServiceTask}</code></strong></p>
<ul>
<li>
<p>检查Bean名称是否匹配。</p>
</li>
<li>
<p>确认流程引擎配置中设置了<code>SpringExpressionManager</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>异步任务不执行</strong></p>
<ul>
<li>
<p>检查<code>asyncExecutor</code>是否启动：调用<code>asyncExecutor.start()</code>。</p>
</li>
<li>
<p>查看日志中是否有任务提交异常。</p>
</li>
</ul>
</li>
<li>
<p><strong>事务不生效</strong></p>
</li>
<ul>
<li>
<p>确保异步执行器配置了事务管理器：asyncExecutor<span class="token punctuation">.<span class="token function">setTransactionManager<span class="token punctuation">(transactionManager<span class="token punctuation">)<span class="token punctuation">;</span></span></span></span></span></p>
</li>
</ul>
</ul>
<h3><strong>五. Spring Boot集成</strong></h3>
<p>若使用<code>flowable-spring-boot-starter</code>，简化配置如下：</p>
<p><strong>(1) application.yml</strong>：</p>
<div class="md-code-block md-code-block-dark">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">flowable:
  async-executor-enabled: true
  database-schema-update: true
  async-executor:
    core-pool-size: 5
    max-pool-size: 10
    queue-size: 100</span></pre>
</div>
</div>
</div>
</div>
</div>
<p><strong>(2) 服务任务类</strong>：</p>
<div class="md-code-block md-code-block-dark">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Component
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> EmailServiceTask <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> JavaDelegate {

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> EmailService emailService;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> EmailServiceTask(EmailService emailService) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.emailService =<span style="color: rgba(0, 0, 0, 1)"> emailService;
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> execute(DelegateExecution execution) {
        String recipient </span>= (String) execution.getVariable("email"<span style="color: rgba(0, 0, 0, 1)">);
        emailService.send(recipient, </span>"流程通知", "您的任务已处理完成。"<span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
</div>
</div>
</div>
</div>
<p><strong>(3) 流程定义XML</strong>：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">serviceTask </span><span style="color: rgba(255, 0, 0, 1)">id</span><span style="color: rgba(0, 0, 255, 1)">="sendEmail"</span><span style="color: rgba(255, 0, 0, 1)"> flowable:delegateExpression</span><span style="color: rgba(0, 0, 255, 1)">="${emailServiceTask}"</span> <span style="color: rgba(0, 0, 255, 1)">/&gt;</span></pre>
</div>
<h3><strong>六.总结</strong></h3>
<ul>
<li>
<p><strong>依赖注入</strong>：确保服务任务类为Spring Bean，流程中使用<code>delegateExpression</code>引用。</p>
</li>
<li>
<p><strong>异步执行</strong>：配置<code>AsyncExecutor</code>并启用，注意线程安全和事务。</p>
</li>
<li>
<p>ApplicationContextAware接口的方式获取ApplicationContext对象实例</p>
</li>
<li>
<p><strong>Spring集成</strong>：正确配置<code>SpringProcessEngineConfiguration</code>以支持表达式和Bean解析。</p>
</li>
</ul>
</div>
<div id="MySignature" role="contentinfo">
    古今成大事者，不唯有超世之才，必有坚韧不拔之志！
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2563378736296296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-11 14:24">2025-04-11 14:22</span>&nbsp;
<a href="https://www.cnblogs.com/songweipeng">[奋斗]</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18820536" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18820536);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18820536', targetLink: 'https://www.cnblogs.com/songweipeng/p/18820536', title: 'flowable任务监听器和java-service依赖注入问题' })">举报</a>
</div>
        