
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18657017" title="发布于 2025-01-07 10:13">
    <span role="heading" aria-level="2">分库分表带来的这7大问题，一定要小心！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>分库分表是解决单库单表性能瓶颈的有效手段，但也会引入新的复杂性和技术挑战。</p>
<p>这篇文章跟大家一起聊聊，分库分表后带来的7个问题，以及相关的解决方案，希望对你会有所帮助。</p>
<p>(我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，欢迎访问和star。)[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
<h2 id="1-全局唯一-id-问题">1. 全局唯一 ID 问题</h2>
<h3 id="问题描述">问题描述</h3>
<p>在分库分表后，每张表的自增 ID 只在本表范围内唯一，但无法保证全局唯一。</p>
<p>例如：</p>
<ul>
<li><code>订单表_1</code> 的主键从 1 开始，<code>订单表_2</code> 的主键也从 1 开始。</li>
<li>在需要全局唯一 ID 的场景（如订单号、用户 ID）中会发生冲突。</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<h4 id="11-使用分布式-id-生成器">1.1 使用分布式 ID 生成器</h4>
<h5 id="推荐工具"><strong>推荐工具：</strong></h5>
<ul>
<li><strong>Snowflake</strong>：Twitter 开源的分布式 ID 算法。</li>
<li><strong>百度 UidGenerator</strong>：基于 Snowflake 的改进版。</li>
<li><strong>Leaf</strong>：美团开源，号段模式和 Snowflake 双支持。</li>
</ul>
<h5 id="代码示例snowflake-算法"><strong>代码示例：Snowflake 算法</strong></h5>
<pre><code class="language-java">public class SnowflakeIdGenerator {
    private final long epoch = 1622476800000L; // 自定义时间戳
    private final long workerIdBits = 5L; // 机器ID
    private final long datacenterIdBits = 5L; // 数据中心ID
    private final long sequenceBits = 12L; // 序列号

    private final long maxWorkerId = ~(-1L &lt;&lt; workerIdBits);
    private final long maxDatacenterId = ~(-1L &lt;&lt; datacenterIdBits);
    private final long sequenceMask = ~(-1L &lt;&lt; sequenceBits);

    private long workerId;
    private long datacenterId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;

    public SnowflakeIdGenerator(long workerId, long datacenterId) {
        if (workerId &gt; maxWorkerId || workerId &lt; 0) throw new IllegalArgumentException("Worker ID out of range");
        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) throw new IllegalArgumentException("Datacenter ID out of range");
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }

    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        if (timestamp &lt; lastTimestamp) throw new RuntimeException("Clock moved backwards");

        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) &amp; sequenceMask;
            if (sequence == 0) timestamp = waitNextMillis(lastTimestamp);
        } else sequence = 0L;

        lastTimestamp = timestamp;
        return ((timestamp - epoch) &lt;&lt; (workerIdBits + datacenterIdBits + sequenceBits))
                | (datacenterId &lt;&lt; (workerIdBits + sequenceBits))
                | (workerId &lt;&lt; sequenceBits)
                | sequence;
    }

    private long waitNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp &lt;= lastTimestamp) timestamp = System.currentTimeMillis();
        return timestamp;
    }
}
</code></pre>
<h4 id="12-数据库号段分配">1.2 数据库号段分配</h4>
<ul>
<li><strong>原理</strong>：维护一个独立的 <code>global_id</code> 表，分库按步长分配 ID：
<ul>
<li>库 1：ID 步长为 2，从 1 开始（1, 3, 5...）。</li>
<li>库 2：ID 步长为 2，从 2 开始（2, 4, 6...）。</li>
</ul>
</li>
</ul>
<h5 id="示例"><strong>示例</strong></h5>
<pre><code class="language-sql">CREATE TABLE global_id (
    id INT PRIMARY KEY AUTO_INCREMENT,
    stub CHAR(1) NOT NULL UNIQUE
);
-- 步长设置：
SET @@auto_increment_increment = 2;
SET @@auto_increment_offset = 1;
</code></pre>
<h2 id="2-跨库跨表查询复杂性">2. 跨库跨表查询复杂性</h2>
<h3 id="问题描述-1">问题描述</h3>
<p>分库分表后，聚合查询（如总数统计、分页查询）需要跨多个分片表执行，增加了查询复杂度。</p>
<p>例如：</p>
<ul>
<li>查询所有订单总数，需要跨 10 个订单表聚合。</li>
<li>按创建时间分页查询所有订单。</li>
</ul>
<h3 id="解决方案-1">解决方案</h3>
<h4 id="21-使用中间件推荐">2.1 使用中间件（推荐）</h4>
<ul>
<li><strong>ShardingSphere</strong> 或 <strong>MyCAT</strong>：支持 SQL 分片执行和结果合并。</li>
<li>优点：业务代码无需修改，中间件完成分库分表逻辑。</li>
</ul>
<h4 id="22-手动分片查询">2.2 手动分片查询</h4>
<ul>
<li>按分片逐一查询数据，在业务层合并结果。</li>
</ul>
<h5 id="示例代码聚合查询"><strong>示例代码：聚合查询</strong></h5>
<pre><code class="language-java">public int countAllOrders() {
    int total = 0;
    for (String db : List.of("db1", "db2", "db3")) {
        String sql = "SELECT COUNT(*) FROM " + db + ".orders";
        total += jdbcTemplate.queryForObject(sql, Integer.class);
    }
    return total;
}
</code></pre>
<h5 id="示例代码跨分片分页查询"><strong>示例代码：跨分片分页查询</strong></h5>
<pre><code class="language-java">public List&lt;Order&gt; paginateOrders(int page, int size) {
    List&lt;Order&gt; allOrders = new ArrayList&lt;&gt;();
    for (String table : List.of("orders_1", "orders_2")) {
        String sql = "SELECT * FROM " + table + " LIMIT 100";
        allOrders.addAll(jdbcTemplate.query(sql, new OrderRowMapper()));
    }
    allOrders.sort(Comparator.comparing(Order::getCreatedAt));
    return allOrders.stream()
            .skip((page - 1) * size)
            .limit(size)
            .collect(Collectors.toList());
}
</code></pre>
<p>手动分片查询的方案，如果数据比较多，性能会比较差。</p>
<h2 id="3-分布式事务问题">3. 分布式事务问题</h2>
<h3 id="问题描述-2">问题描述</h3>
<p>分布式事务（如订单表在库 A，库存表在库 B）无法使用单库事务，导致可能会出现数据的一致性问题。</p>
<h3 id="解决方案-2">解决方案</h3>
<h4 id="31-分布式事务框架">3.1 分布式事务框架</h4>
<ul>
<li><strong>Seata</strong>：支持跨库的分布式事务。</li>
<li><strong>示例代码</strong>：</li>
</ul>
<pre><code class="language-java">@GlobalTransactional
public void createOrder(Order order) {
    orderService.saveOrder(order); // 写入库A
    stockService.reduceStock(order.getProductId()); // 更新库B
}
</code></pre>
<h4 id="32-柔性事务">3.2 柔性事务</h4>
<ul>
<li>使用消息中间件实现最终一致性。</li>
<li>典型实现：<strong>RocketMQ 消息事务</strong>。</li>
</ul>
<h2 id="4-分片键设计问题">4. 分片键设计问题</h2>
<h3 id="问题描述-3">问题描述</h3>
<p>分片键选择不当可能导致数据倾斜（热点问题）或查询路由效率低。</p>
<h3 id="解决方案-3">解决方案</h3>
<h4 id="41-分片键设计原则">4.1 分片键设计原则</h4>
<ol>
<li><strong>数据分布均匀</strong>：避免热点问题。</li>
<li><strong>常用查询字段</strong>：尽量选高频查询字段。</li>
</ol>
<h4 id="42-路由表">4.2 路由表</h4>
<ul>
<li>维护全局路由表，映射分片键到分表。</li>
</ul>
<h5 id="示例代码路由表查询"><strong>示例代码：路由表查询</strong></h5>
<pre><code class="language-java">public String getTargetTable(int userId) {
    String sql = "SELECT table_name FROM routing_table WHERE user_id = ?";
    return jdbcTemplate.queryForObject(sql, new Object[]{userId}, String.class);
}
</code></pre>
<h2 id="5-数据迁移问题">5. 数据迁移问题</h2>
<h3 id="问题描述-4">问题描述</h3>
<p>扩容（如从 4 个分片扩展到 8 个分片）时，旧数据需要迁移到新分片，迁移复杂且可能影响线上服务。</p>
<h3 id="解决方案-4">解决方案</h3>
<h4 id="51-双写策略">5.1 双写策略</h4>
<ul>
<li>数据迁移期间，旧表和新表同时写入。</li>
<li>待迁移完成后，切换到新表。</li>
</ul>
<h4 id="52-增量同步">5.2 增量同步</h4>
<ul>
<li>使用 <strong>Canal</strong> 监听 MySQL Binlog，将数据迁移到新分片。</li>
</ul>
<h5 id="示例canal-配置"><strong>示例：Canal 配置</strong></h5>
<pre><code class="language-yaml">canal.destinations:
  example:
    mysql:
      hostname: localhost
      port: 3306
      username: root
      password: password
    kafka:
      servers: localhost:9092
      topic: example_topic
</code></pre>
<h2 id="6-分页查询问题">6. 分页查询问题</h2>
<h3 id="问题描述-5">问题描述</h3>
<p>分页查询需要从多个分片表合并数据，再统一分页，逻辑复杂度增加。</p>
<h3 id="解决方案-5">解决方案</h3>
<ol>
<li><strong>各分片分页后合并</strong>：先按分片分页查询，业务层合并排序后分页。</li>
<li><strong>中间件支持分页</strong>：如 ShardingSphere。</li>
</ol>
<h5 id="示例代码跨分片分页"><strong>示例代码：跨分片分页</strong></h5>
<pre><code class="language-java">public List&lt;Order&gt; queryPagedOrders(int page, int size) {
    List&lt;Order&gt; results = new ArrayList&lt;&gt;();
    for (String table : List.of("orders_1", "orders_2")) {
        results.addAll(jdbcTemplate.query("SELECT * FROM " + table + " LIMIT 100", new OrderRowMapper()));
    }
    results.sort(Comparator.comparing(Order::getCreatedAt));
    return results.stream().skip((page - 1) * size).limit(size).collect(Collectors.toList());
}
</code></pre>
<p>但如果分的表太多，可能会有内存占用过多的问题，需要做好控制。</p>
<h2 id="7-运维复杂性">7. 运维复杂性</h2>
<h3 id="问题描述-6">问题描述</h3>
<p>分库分表后，运维难度增加：</p>
<ul>
<li>数据库实例多，监控和备份复杂。</li>
<li>故障排查需要跨多个库。</li>
</ul>
<h3 id="解决方案-6">解决方案</h3>
<ol>
<li><strong>自动化运维平台</strong>：如阿里云 DMS。</li>
<li><strong>监控工具</strong>：使用 Prometheus + Grafana 实现分片监控。</li>
</ol>
<h2 id="总结">总结</h2>
<p>分库分表本质上是“性能换复杂度”，它虽然能有效提升系统的性能和扩展性，但问题也随之而来。</p>
<p>分库分表后带来的问题总结如下：</p>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>全局唯一 ID</td>
<td>雪花算法、号段分配、Leaf</td>
</tr>
<tr>
<td>跨库跨表查询</td>
<td>中间件支持（如 ShardingSphere）或手动合并</td>
</tr>
<tr>
<td>分布式事务</td>
<td>分布式事务框架（Seata）、消息最终一致性</td>
</tr>
<tr>
<td>分片键设计问题</td>
<td>路由表或高效分片键</td>
</tr>
<tr>
<td>数据迁移问题</td>
<td>双写策略或增量同步（如 Canal）</td>
</tr>
<tr>
<td>分页查询问题</td>
<td>分片查询后合并排序</td>
</tr>
<tr>
<td>运维复杂性</td>
<td>自动化工具（DMS）、监控工具（Prometheus + Grafana）</td>
</tr>
</tbody>
</table>
<p>应根据业务场景选择适合的分库分表策略，并通过工具和技术方案，解决由此带来的一些问题，最终实现系统的高性能与高可靠性。</p>
<p>最后说一句(求关注，别白嫖我)<br>
如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202501/2238006-20250107101324302-1718690422.jpg" alt="" loading="lazy"></p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.17173289389814814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-07 10:14">2025-01-07 10:13</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18657017" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18657017);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18657017', targetLink: 'https://www.cnblogs.com/12lisu/p/18657017', title: '分库分表带来的这7大问题，一定要小心！' })">举报</a>
</div>
        