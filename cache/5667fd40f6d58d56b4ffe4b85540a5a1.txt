
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18823157" title="发布于 2025-04-13 13:32">
    <span role="heading" aria-level="2">使用RabbitMQ实现消息队列---C#为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="标题">标题</h1>
<h2 id="1消息队列介绍">1.消息队列介绍</h2>
<p>其实消息队列没有那么神秘，我们这样想一下，用户访问网站，最终是要将数据以HTTP的协议的方式，通过网络传输到主机的某个端口上的。</p>
<p>那么，接收数据的方式是什么呢？自然是端口监听啦。</p>
<p>那消息队列是什么就很好解释了？</p>
<p>它就是端口监听，接到数据后，将数据排列起来。</p>
<p>那这件事，我们不用中间件能做吗？</p>
<p>当然能做啦，写个TCP/UDP/Socket的软件就可以做啦。</p>
<p>举个简单的例子，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131152284-1890529325.png" alt="image" loading="lazy"></p>
<h2 id="2rabbitmq安装">2.RabbitMQ安装</h2>
<p>首先，我们访问官网【<a href="https://www.rabbitmq.com/%E3%80%91%EF%BC%8C%E7%82%B9%E5%87%BBGet" target="_blank" rel="noopener nofollow">https://www.rabbitmq.com/】，点击Get</a> Started。</p>
<p>然后，网站会自动跳转到当前首页Get Started的锚点位置，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131309717-911055772.png" alt="image" loading="lazy"></p>
<p>然后我们点击DownLoad+Installation，进入到下载界面。</p>
<p>在下载页面中，我们找到安装指南，然后在点击官网推荐的Windows系统的安装包，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131357535-2109713011.png" alt="image" loading="lazy"></p>
<p>现在，我们进入了Windows安装指南界面了。</p>
<p>首先，我们看一下预览信息，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131420469-1707244172.png" alt="image" loading="lazy"></p>
<p>在预览里，我们得知，安装RabbitMQ有两种方法，一种是使用Chocolatey安装，一种是使用官方安装包安装。</p>
<p>Chocolatey是什么呢?随手百度一下，原来他是一个软件包管理工具，也就是说，Chocolatey是类似于Nuget的一种工具。</p>
<p>由于Chocolatey的使用，我不是很熟悉，所以，这里选择使用官方安装包安装。</p>
<p>点击【Using the official installer】，我们进入了【Using the official installer】对应的锚点，如下图。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131501214-2044078315.png" alt="image" loading="lazy"></p>
<p>在【Using the official installer】段落里找到有推荐标志的安装包，然后下载。</p>
<p>下载完成后，我们可以得到这样一个安装包，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131523724-115959702.png" alt="image" loading="lazy"></p>
<p>除了下载安装包，我们还会发现，在【Using the official installer】段落里，有提醒我们，RabbitMQ是有依赖的，依赖一个Erlang语言的框架（类似于C#语言的NetFramework）。</p>
<p>我们可以发现，在依赖的段落里，官网非常坑的给出了三个链接网址，如下：</p>
<p>supported version of Erlang：<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener nofollow">https://www.rabbitmq.com/which-erlang.html</a></p>
<p>Windows installer：<a href="https://www.erlang.org/downloads" target="_blank" rel="noopener nofollow">https://www.erlang.org/downloads</a></p>
<p>Erlang Solutions：<a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener nofollow">https://www.erlang-solutions.com/resources/download.html</a></p>
<p>因为，我们是无法通过文字描述来判断，哪一个是真的依赖框架的下载地址，所以只好每个都点击进去看看。。。</p>
<p>打开网址后发现，在后两个网址中都可以找到框架下载地址，但第二个地址明显更友好一点，所以我们在第二个网址内下载Erlang的框架。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131608309-940111928.png" alt="image" loading="lazy"></p>
<p>下载完成得到如下图文件：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131633669-927145775.png" alt="image" loading="lazy"></p>
<p>PS：这里下载的是OTP的22.1的版本，我的理解是Erlang等于C#语言，而OTP等于NetFramework。</p>
<h3 id="21-安装erlangotp">2.1 安装Erlang\OTP</h3>
<p>首先，我们运行otp_win64_22.1.exe，安装依赖框架Erlang\OTP。</p>
<p>安装完成后，设置环境变量如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131727371-433358337.png" alt="image" loading="lazy"></p>
<p>然后运行CMD，输入erl，测试安装是否成功，如下图：<br>
<img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413131803908-2084917107.png" alt="image" loading="lazy"></p>
<p>安装成功。</p>
<h3 id="22-安装rabbitmq-server">2.2 安装rabbitmq-server</h3>
<p>安装完依赖后，我们接着安装rabbitmq-server-3.8.0.exe。</p>
<p>安装完RabbitMQ服务端后，我们还是启动CMD，用命令行来查看下安装状态。</p>
<p>首先输入下面的命令，将路径定位到RabbitMQ的路径下：</p>
<p>【CD /D C:\Program Files\RabbitMQ Server\rabbitmq_server-3.8.0\sbin】</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132010568-209687879.png" alt="image" loading="lazy"></p>
<p>然后输入rabbitmqctl status查看状态。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132030504-1645549982.png" alt="image" loading="lazy"></p>
<p>启动管理工具的命令行：rabbitmq-plugins enable rabbitmq_management。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132055844-924885530.png" alt="image" loading="lazy"></p>
<p>启动成功后，在浏览器输入地址http://127.0.0.1:15672/，进入管理页面，账户密码都是guest。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132125660-1092362519.png" alt="image" loading="lazy"></p>
<p>到此，RabbitMQ服务端的环境配置好了，正常情况，这些配置应该在服务器进行，但我为了测试方便，就把服务端也安装在本机了，因此我下面调用RabbitMQ时，连接的主机IP都是localhost。</p>
<h2 id="3rabbitmq应用">3.RabbitMQ应用</h2>
<p>首先创建两个控制台应用程序，KibaRabbitMQSend和KibaRabbitMQReceived。</p>
<p>然后引入RabbitMQ的开源类库。</p>
<p>在C#里使用RabbitMQ开源类库非常简单，可以去官网下载一个.NET版本的RabbitMQ客户端类库，也可以直接在Nuget上搜索RabbitMQ，然后安装，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132249346-1043777805.png" alt="image" loading="lazy"></p>
<h3 id="31-客户端kibarabbitmqsend">3.1 客户端KibaRabbitMQSend</h3>
<p>安装完RabbitMQ开源类库后，我们编写代码，实现向RabbitMQ服务器发送消息，代码如下：</p>
<pre><code>static void Main(string[] args)
{
	var factory = new ConnectionFactory();
	factory.HostName = "localhost";//主机名，Rabbit会拿这个IP生成一个endpoint，这个很熟悉吧，就是socket绑定的那个终结点。
	factory.UserName = "guest";//默认用户名,用户可以在服务端自定义创建，有相关命令行
	factory.Password = "guest";//默认密码

	using (var connection = factory.CreateConnection())//连接服务器，即正在创建终结点。
	{
		//创建一个通道，这个就是Rabbit自己定义的规则了，如果自己写消息队列，这个就可以开脑洞设计了
		//这里Rabbit的玩法就是一个通道channel下包含多个队列Queue
		using (var channel = connection.CreateModel())
		{
			 channel.QueueDeclare("kibaQueue", false, false, false, null);//创建一个名称为kibaqueue的消息队列
			 var properties = channel.CreateBasicProperties();
			 properties.DeliveryMode = 1;
			 string message = "I am Kiba518"; //传递的消息内容
			 channel.BasicPublish("", "kibaQueue", properties, Encoding.UTF8.GetBytes(message)); //生产消息
			 Console.WriteLine($"Send:{message}");
		}
	}
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132338674-1144685878.png" alt="image" loading="lazy"></p>
<h3 id="32-kibarabbitmqreceived">3.2 KibaRabbitMQReceived</h3>
<p>现在我们编写接收消息代码，如下：</p>
<pre><code>static void Main(string[] args)
{
	var factory = new ConnectionFactory();
	factory.HostName = "localhost";
	factory.UserName = "guest";
	factory.Password = "guest";

	using (var connection = factory.CreateConnection())
	{
		using (var channel = connection.CreateModel())
		{
			channel.QueueDeclare("kibaQueue", false, false, false, null);

			/* 这里定义了一个消费者，用于消费服务器接受的消息
			 * C#开发需要注意下这里，在一些非面向对象和面向对象比较差的语言中，是非常重视这种设计模式的。
			 * 比如RabbitMQ使用了生产者与消费者模式，然后很多相关的使用文章都在拿这个生产者和消费者来表述。
			 * 但是，在C#里，生产者与消费者对我们而言，根本算不上一种设计模式，他就是一种最基础的代码编写规则。
			 * 所以，大家不要复杂的名词吓到，其实，并没那么复杂。
			 * 这里，其实就是定义一个EventingBasicConsumer类型的对象，然后该对象有个Received事件，
			 * 该事件会在服务接收到数据时触发。
			 */
			var consumer = new EventingBasicConsumer(channel);//消费者
			channel.BasicConsume("kibaQueue", true, consumer);//消费消息
			consumer.Received += (model, ea) =&gt;
			{
				var body = ea.Body;
				var message = Encoding.UTF8.GetString(body);
			};
		}
	}
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132525285-1442024619.png" alt="image" loading="lazy"></p>
<p>现在我们在发送代码出做一个for循环，看看消息接收速度是什么样的，代码如下，for循环了100次，每次间隔3秒。</p>
<pre><code>for (int i = 0; i &lt; 100; i++)
{
	channel.QueueDeclare("kibaQueue", false, false, false, null);//创建一个名称为kibaQueue的消息队列
	var properties = channel.CreateBasicProperties();
	properties.DeliveryMode = 1;
	string message = "I am Kiba518"; //传递的消息内容
	channel.BasicPublish("", "kibaQueue", properties, Encoding.UTF8.GetBytes(message)); //生产消息
	Console.WriteLine($"Send:{message}");
	Thread.Sleep(3000);
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132610175-1290277545.png" alt="image" loading="lazy"></p>
<h2 id="4服务器端应用">4.服务器端应用</h2>
<p>在上文，我们的RabbitMQ服务是安装在我的本机上的；现在我们把服务移植到服务器上，然后再来测试一下。</p>
<p>在服务器端安装RabbitMQ和在本机安装的步骤是一样的，但是安装完成后，我们需要设置下防火墙的入站规则和出站规则，将5672的UDP端口开放一下。</p>
<p>为什么要开放端口是5672？因为RabbitMQ的默认的消息接收和发送端口就是5672，我们可以使用断点查看一下。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132735632-262278495.png" alt="image" loading="lazy"></p>
<p>如上图，可以看到，在我们没有设置端口的时候，Endpoint的端口的默认值是5672。</p>
<p>配置完端口后，我们修改代码中的HostName为我们的服务器地址，如下。</p>
<pre><code>factory.HostName = "127.0.0.1";
</code></pre>
<p>重新运行代码，会发现在运行到factory.CreateConnection()的时候，系统提示一个异常【RabbitMQ.Client.Exceptions.BrokerUnreachableException:“None of the specified endpoints were reachable”】，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132808730-1022890937.png" alt="image" loading="lazy"></p>
<p>这是因为我们使用的账号是guest，guest账号默认是不支持远程连接的。</p>
<p>解决办法很简单，新建一个账户即可。</p>
<p><strong>创建用户</strong></p>
<p>在服务器端打开浏览器，输入http://127.0.0.1:15672/，进入管理页面。</p>
<p>点击菜单栏的Admin选项，进入用户管理界面创建用户kiba，密码123456，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132914709-637794592.png" alt="image" loading="lazy"></p>
<p>如上图所示，刚刚创建的用户还没有任何访问权限。</p>
<p>现在我们点击用户名，进入权限管理页面设置权限。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132936141-983840368.png" alt="image" loading="lazy"></p>
<p>如上图所示，页面默认为我们设置了一个可读，可写，可管理配置的权限；所以，我们只要点击Set premission就可以了。</p>
<p>设置完权限，我们回到用户管理页面。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413132957740-1121045337.png" alt="image" loading="lazy"></p>
<p>如上图所示，权限设置成功。</p>
<p>现在我们回到代码，修改用户名密码如下。</p>
<pre><code>factory.HostName = "127.0.0.1";
factory.UserName = "kiba";
factory.Password = "123456";
</code></pre>
<p>运行代码，不再抛异常，接受发送消息正常。</p>
<hr>
<p>设置用户权限也可以通过命令的方式设置，如下：</p>
<p>rabbitmqctl set_permissions -p "/" kiba "." "." ".*"<br>
<img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250413133100568-2104828220.png" alt="image" loading="lazy"></p>
<p>源码地址：<a href="https://gitee.com/chenshibao/csb-rabbit-mqapp" target="_blank" rel="noopener nofollow">https://gitee.com/chenshibao/csb-rabbit-mqapp</a></p>
<p>参考文档出自：<a href="https://www.cnblogs.com/kiba/p/11703073.html" target="_blank">https://www.cnblogs.com/kiba/p/11703073.html</a><br>
<a href="https://www.cnblogs.com/kiba/p/13728088.html" target="_blank">https://www.cnblogs.com/kiba/p/13728088.html</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0426870348009258" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-15 17:18">2025-04-13 13:32</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">60</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18823157);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18823157', targetLink: 'https://www.cnblogs.com/chenshibao/p/18823157', title: '使用RabbitMQ实现消息队列---C#为例' })">举报</a>
</div>
        