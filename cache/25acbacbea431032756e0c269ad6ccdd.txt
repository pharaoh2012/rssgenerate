
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18758770" title="发布于 2025-03-10 10:18">
    <span role="heading" aria-level="2">层峦叠嶂：跳表如何维护有序世界</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="链表的觉醒当线性结构长出翅膀">链表的觉醒：当线性结构长出翅膀</h2>
<p>想象一串珍珠项链——每个节点优雅地牵着下一个节点的手。这种单向的、线性的、链表最本真的特性：插入与删除的瞬时性 <span class="math inline">\(O(1)\)</span>。但当需要寻找特定节点时，我们不得不 <span class="math inline">\(O(n)\)</span>遍历。</p>
<p>为链表赋予有序性，我们就可以维护一个有序的结合。使用有序数组维护有序集合，插入删除将移动大量元素；使用链表可快速插入删除，但当我们试图用二分查找加速时，却发现致命缺陷：数组可以通过下标瞬间跃迁，而链表只能沿着指针蹒跚爬行。</p>
<p>如果让链表突破二维平面呢？其实基础深厚的你很容易想到，我们可以再建造一层间隔更大的列表，首先从大间隔的副本里加速跳跃，就可以缩短遍历时间。</p>
<p>想象一座立体城市：地面是原始链表，空中架设多层高架桥。高层道路跨度更大，连接远方地标；底层道路细密交织，保留完整细节。这种<strong>空间折叠</strong>的直觉，正是跳表的核心隐喻。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250309224101486-1183910500.png" alt="image" loading="lazy"></p>
<p>当然，由于链表可以再中间随时插入删除，我们不可能提前规定好每层链表副本的间隔数。跳表的神性在于：它不强制维持完美平衡，而是让每个节点以概率为尺，以一定概率在上一层中出现。</p>
<p>通过<strong>概率性生长</strong>的层级结构，跳表在保持链表动态优势的同时，创造出类似二分查找的快速通道。每一层都是下层链表的"快照缩影"，高层指针如同穿越时空的虫洞，让查询操作实现对数级<span class="math inline">\(O(\log n)\)</span> 的跳跃式演进。</p>
<h2 id="跳表结构">跳表结构</h2>
<p>传统链表节点只携带单一下程地址：</p>
<pre><code class="language-cpp">struct Node {  
    int value;  
    Node* next;  
};  
</code></pre>
<p>而跳表节点则化身<strong>多维存在</strong>，每个节点代表本节点的所有层，同时携带一组指针，代表本节点在每一层指向谁：</p>
<pre><code class="language-cpp">struct Node {  
    int value;  
    vector&lt;Node*&gt; next;
};  
</code></pre>
<p>每个节点的<code>next</code>数组长度即其<strong>高度</strong>，动态分配。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250309231924346-642392468.png" alt="image" loading="lazy"></p>
<p>层数的生成从底层（层0）开始抛掷一枚概率硬币，连续成功则向上跃升。设跳表的参数概率为 <span class="math inline">\(p\)</span>，则节点达到第 <span class="math inline">\(k\)</span> 层的概率为：</p>
<p></p><div class="math display">\[P(k) = p^{k} \cdot (1-p)
\]</div><p></p><p>这形成<strong>几何分布</strong>，其数学期望为：</p>
<p></p><div class="math display">\[E(\text{层数}) = \frac{1}{1-p} - 1
\]</div><p></p><p>当 <span class="math inline">\(p=0.5\)</span> 时，约50%节点有第1层，25%有第2层……如同金字塔，高层节点愈发稀少却战略地位显著。</p>
<p><strong>参数设计</strong></p>
<ul>
<li><strong>概率 <span class="math inline">\(p\)</span></strong>：通常取 0.25~0.5。<span class="math inline">\(p\)</span> 值越小，高层节点越稀疏，查询时跳跃幅度更大，但需要更多层数补偿</li>
<li><strong>最大层数 <span class="math inline">\(L_{max}\)</span></strong>：防御极端情况，常取<span class="math inline">\(L_{max} = \log_{1/p}n + 1\)</span>。例如 <span class="math inline">\(n=10^6\)</span> 时，<span class="math inline">\(p=0.5\)</span> 则 <span class="math inline">\(L_{max} \approx 20\)</span></li>
</ul>
<p><strong>空间折叠的具象化</strong><br>
想象一个含值[1,3,5,7,9]的跳表（ <span class="math inline">\(p=0.5\)</span> ），其结构可能呈现：</p>
<pre><code>层3：1 ----------------------------&gt; 9  
层2：1 --------5 --------&gt; 7 -----&gt; 9  
层1：1 -&gt; 3 -&gt; 5 -&gt; 7 ---&gt; 9  
层0：1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9  
</code></pre>
<p>高层指针如同跃迁引擎，使查询7时路径为：层3跳1→9（超界）→降层→层2跳1→5→7，仅需3步而非底层5步。</p>
<ul>
<li><strong>时间复杂度</strong>：每层遍历节点数期望为 <span class="math inline">\(\frac{1}{p}\)</span>，总层数约 <span class="math inline">\(\log_{1/p}n\)</span>，单次查询的整体时间复杂度 <span class="math inline">\(O(\log n)\)</span></li>
<li><strong>空间复杂度</strong>：节点平均层数<span class="math inline">\(\frac{1}{1-p}\)</span>，平均总空间消耗 <span class="math inline">\(O(n)\)</span>。当 <span class="math inline">\(p=0.5\)</span> 时，空间开销仅为原链表的 2 倍</li>
</ul>
<h2 id="核心操作">核心操作</h2>
<p><strong>1. 查找</strong></p>
<ul>
<li><strong>高空俯冲策略</strong>：从最高层指针出发（如 16 层）</li>
<li><strong>层间跃迁法则</strong>：<p></p><div class="math display">\[\text{while } (当前节点.next[层] \neq null) \land (当前节点.next[层].val &lt; target)  
\]</div><p></p></li>
<li><strong>精准着陆</strong>：当无法继续向右（右侧更大或来到链表尾）时，向下穿越维度（层数减1）</li>
</ul>
<p><strong>2. 插入</strong></p>
<ul>
<li><strong>定位</strong>：和查找一样从上往下定位。不过，由于是单链表，从高层向底层逐层记录走过的最后一个点。</li>
<li><strong>随机生长</strong>：要插入的节点依概率得到自己的层数。</li>
<li><strong>缝合</strong>：在每一层进行和通常链表一样的插入，将新节点的各层指针与<code>update</code>数组节点链式缝合。</li>
</ul>
<p><strong>3. 删除</strong></p>
<ul>
<li><strong>定位</strong>：和查找一样从上往下定位。也需要从高层向底层逐层记录走过的最后一个点。</li>
<li><strong>缝合</strong>：在每一层和通常链表一样逐层解除链接，释放内存</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202503/1545207-20250309232716448-300004145.png" alt="image" loading="lazy"></p>
<pre><code class="language-cpp">// 参考题目：https://leetcode.cn/problems/design-skiplist/description/

class Skiplist {
    int maxLevel;
    double p;

    struct Node {
        int val;
        vector&lt;Node*&gt; next;
        Node(int val, int level) : val(val), next(level+1, nullptr) {}
    };

    Node* head;
    int randomLevel() {
        int level = 0;
        while (rand() &lt; p * RAND_MAX &amp;&amp; level &lt; maxLevel) {
            level++;
        }
        return level;
    }
public:
    Skiplist(): p(0.4), maxLevel(16), head(new Node(-1, maxLevel)) {
        srand(time(0));
    }
    
    bool search(int target) {
        auto p = head;
        for (int level = maxLevel - 1; level &gt;= 0; level--) {
            while (p-&gt;next[level] &amp;&amp; p-&gt;next[level]-&gt;val &lt; target) {
                p = p-&gt;next[level];
            }
        } return p-&gt;next[0] &amp;&amp; p-&gt;next[0]-&gt;val == target;
    }
    
    void add(int num) {
        auto p = head;
        vector&lt;Node*&gt; update(maxLevel, nullptr);
        for (int level = maxLevel - 1; level &gt;= 0; level--) {
            while (p-&gt;next[level] &amp;&amp; p-&gt;next[level]-&gt;val &lt; num) {
                p = p-&gt;next[level];
            }update[level] = p;
        } 

        Node* newNode = new Node(num, randomLevel());
        for (int i = 0; i &lt; newNode-&gt;next.size(); i++) {
            newNode-&gt;next[i] = update[i]-&gt;next[i];
            update[i]-&gt;next[i] = newNode;
        }
    }
    
     bool erase(int num) {
         auto p = head;
         vector&lt;Node*&gt; update(maxLevel, nullptr);
         for (int level = maxLevel - 1; level &gt;= 0; level--) {
             while (p-&gt;next[level] &amp;&amp; p-&gt;next[level]-&gt;val &lt; num) {
                 p = p-&gt;next[level];
             }
             update[level] = p;
         } 

         Node* target = p-&gt;next[0];
         if (!target || target-&gt;val != num) return false;
         for (int i = 0; i &lt; target-&gt;next.size(); i++) {
             update[i]-&gt;next[i] = target-&gt;next[i];
         }
         delete target;
         return true;
     }
};
</code></pre>
<h2 id="复杂度">复杂度</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>平均情况</th>
<th>最坏情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找 / 插入 / 删除</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>虽然理论最坏情况（所有链表都没有被提升或都被顶到最高）与链表相同，但实际工程中通过：</p>
<ul>
<li>合理设置 <span class="math inline">\(p=0.4\)</span></li>
<li>限制 <span class="math inline">\(L_{max}=16\)</span><br>
使得极端情况概率低于<span class="math inline">\(10^{-9}\)</span>，<strong>实践复杂度等效 <span class="math inline">\(O(\log n)\)</span></strong></li>
</ul>
<p>假定 <span class="math inline">\(p=0.4\)</span>，节点平均层数：</p>
<p></p><div class="math display">\[E(L) = \frac{1}{1-p} = \frac{1}{1-0.4} \approx 1.67  
\]</div><p></p><p>总空间消耗：</p>
<p></p><div class="math display">\[O(n \cdot E(L)) = O(1.67n) = O(n)  
\]</div><p></p><p>即增加这么多层后，平均仍是 <span class="math inline">\(O(n)\)</span>，假设最大高度设置为 <span class="math inline">\(\log n\)</span>，那么理论最坏空间是每层都顶到最高，即<span class="math inline">\(O(n\log n)\)</span>，实际上不可能发生。</p>
<p>相比红黑树每个节点存储颜色标记和左右子树指针，跳表通过<strong>空间换时间</strong>获得更简洁的实现</p>
<h2 id="跳表与平衡树">跳表与平衡树</h2>
<p>平衡树和跳表解决了同一个问题（维护有序集合），各有优缺点。</p>
<p><strong>1. 跳表的锋芒</strong></p>
<ul>
<li><strong>实现简单性</strong>：200 行代码 vs 红黑树500+行</li>
<li><strong>无锁并发优势</strong>：LevelDB MemTable 利用跳表的局部性实现高效写入</li>
<li><strong>范围查询优化</strong>：<code>SELECT * WHERE key BETWEEN a AND b</code>可沿底层链表快速遍历</li>
</ul>
<p><strong>2. 平衡树的坚守</strong></p>
<ul>
<li><strong>严格时间复杂度</strong>：红黑树保证最坏情况</li>
<li><strong>内存紧凑性</strong>：B+树节点存储更多子节点，适合磁盘页存储</li>
<li><strong>持久化优势</strong>：AVL树旋转不改变原有路径，利于实现事务回滚</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表 (Skip List)</th>
<th>平衡树 (Balanced Tree)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>查找、插入、删除：平均 O(log N)，最坏 O(N)</td>
<td>查找、插入、删除：O(log N)</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(N)，其中 N 是元素个数</td>
<td>O(N)</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>相对简单，容易实现</td>
<td>较复杂，涉及树的旋转操作</td>
</tr>
<tr>
<td><strong>平衡性</strong></td>
<td>不需要复杂的平衡操作，随机化的跳跃机制实现平衡</td>
<td>通过旋转操作确保平衡</td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>平均 O(log N)，最坏 O(N)</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>插入/删除效率</strong></td>
<td>平均 O(log N)，最坏 O(N)</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>内存消耗</strong></td>
<td>由于多层链表，内存消耗较高</td>
<td>由于节点存储平衡因子（或颜色），内存消耗略高</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>可以适应动态扩展，但随着规模增大，跳表可能退化为链表</td>
<td>在动态环境中（如频繁插入删除）效率保持较高</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>高度并发的场景，尤其是在网络协议、分布式系统中</td>
<td>数据库、文件系统、图形学中的空间分配等</td>
</tr>
</tbody>
</table>
<p><strong>3. 战场启示录</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>胜出者</th>
<th>决胜因素</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存数据库索引</td>
<td>跳表</td>
<td>实现简单，写入速度快</td>
</tr>
<tr>
<td>磁盘数据库索引</td>
<td>B+树</td>
<td>页对齐优化</td>
</tr>
<tr>
<td>实时游戏排行榜</td>
<td>跳表</td>
<td>范围查询高效</td>
</tr>
<tr>
<td>金融交易系统</td>
<td>红黑树</td>
<td>稳定延迟保证</td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.33127776741782405" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 10:19">2025-03-10 10:18</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">82</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18758770" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18758770);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18758770', targetLink: 'https://www.cnblogs.com/ofnoname/p/18758770', title: '层峦叠嶂：跳表如何维护有序世界' })">举报</a>
</div>
        