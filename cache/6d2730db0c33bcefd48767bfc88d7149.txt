
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kklldog/p/19022317" title="发布于 2025-08-04 22:05">
    <span role="heading" aria-level="2">LongRunningTask-正确用法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在上一篇文章《如何正确实现一个 BackgroundService》中有提到 <code>LongRunning</code> 来优化后台任务始终保持在同一个线程上。</p>
<pre><code class="language-csharp">        protected override Task ExecuteAsync(CancellationToken stoppingToken)
        {
            return Task.Factory.StartNew(async () =&gt;
            {
                while (!stoppingToken.IsCancellationRequested)
                {
                    // Simulate some work
                    Console.WriteLine("HostServiceTest_A is doing work.");

                    LongTermTask();

                    await Task.Delay(1000, stoppingToken); // Delay for 1 second
                }

                Console.WriteLine("HostServiceTest_A task done.");

            }, TaskCreationOptions.LongRunning);
        }

        private void LongTermTask()
        {
            // Simulate some work
            Console.WriteLine("LongTermTaskA is doing work.");
            Thread.Sleep(30000);
        }
</code></pre>
<p>但是被<code>黑洞视界</code> 大佬指出这个用法是错误的：以上用法并不能保证任务始终在同一个 <code>Task</code>(线程) 上执行。原因是当碰到第一个 <code>await</code> 之后运行时会从 <code>ThreadPool</code> 中调度一个新的线程来执行后面的代码，而当前线程被释放。这个时候就不符合我们使用 <code>LongRunning</code> 的期望了。</p>
<p>在 .NET 中，<code>Task.Factory.StartNew</code> 提供了 <code>TaskCreationOptions.LongRunning</code> 选项，很多开发者会用它来启动长时间运行的任务，并且想当然的认为它会永远执行在同一个线程上。但是事实上当遇到 <code>async</code> <code>await</code> 的时候并想象的那么简单。</p>
<p>下面我们还是通过一个错误的示例开始讲解如何正确的使用它。</p>
<h2 id="错误用法">错误用法</h2>
<p>很多人会直接在 <code>Task.Factory.StartNew</code> 里传入一个 <code>async</code> 方法：</p>
<pre><code class="language-csharp">// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

var task = Task.Factory.StartNew(async () =&gt;
{
    Console.WriteLine($"long running task starting. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    var loopCount = 1;
    while (true)
    {
        Console.WriteLine($"\r\nStart: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId}");
        await LongRunningJob();
        Console.WriteLine($"End: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId} \r\n ");
        loopCount++;
    }

}, TaskCreationOptions.LongRunning);


static async Task LongRunningJob()
{
    Console.WriteLine($"task doing. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    await Task.Delay(1000);
}

Console.ReadLine();
</code></pre>
<p>输出：</p>
<pre><code>Hello, World!
long running task starting. Thread id: 12

Start: loop count: 1, Thread id: 12
task doing. Thread id: 12
End: loop count: 1, Thread id: 11


Start: loop count: 2, Thread id: 11
task doing. Thread id: 11
End: loop count: 2, Thread id: 11
</code></pre>
<p>可以看到，第一次循环后，线程 id 发生了变化。很明显 <code>LongRunning</code> 失效了。原因开篇已经讲了，不在赘述。</p>
<h2 id="正确用法-1同步方法">正确用法 1：同步方法</h2>
<p>将 <code>LongRunningJob</code> 改为同步方法，避免异步切换线程：</p>
<pre><code class="language-csharp">var task = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine($"long running task starting. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    var loopCount = 1;
    while (true)
    {
        Console.WriteLine($"\r\nStart: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId}");
        LongRunningJob();
        Console.WriteLine($"End: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId} \r\n ");
        loopCount++;
    }

}, TaskCreationOptions.LongRunning);


static void LongRunningJob()
{
    Console.WriteLine($"task doing. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(1000);
}
</code></pre>
<p>输出：</p>
<pre><code>Hello, World!
long running task starting. Thread id: 12

Start: loop count: 1, Thread id: 12
task doing. Thread id: 12
End: loop count: 1, Thread id: 12
</code></pre>
<p>线程 id 始终不变，说明始终运行在专用线程上。</p>
<h2 id="正确用法-2异步方法同步等待">正确用法 2：异步方法同步等待</h2>
<p>如果必须用异步方法，可以用 <code>.Wait()</code> 让调用变为同步：</p>
<pre><code class="language-csharp">var task = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine($"long running task starting. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    var loopCount = 1;
    while (true)
    {
        Console.WriteLine($"\r\nStart: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId}");
        LongRunningJob().Wait();
        Console.WriteLine($"End: loop count: {loopCount}, Thread id: {Thread.CurrentThread.ManagedThreadId} \r\n ");
        loopCount++;
    }

}, TaskCreationOptions.LongRunning);


static async Task LongRunningJob()
{
    Console.WriteLine($"task doing. Thread id: {Thread.CurrentThread.ManagedThreadId}");
    await Task.Delay(1000);
}
</code></pre>
<p>输出：</p>
<pre><code>Hello, World!
long running task starting. Thread id: 12

Start: loop count: 1, Thread id: 12
task doing. Thread id: 12
End: loop count: 1, Thread id: 12
</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><code>TaskCreationOptions.LongRunning</code> 适用于同步、阻塞型任务。</li>
<li>不要在 <code>StartNew</code> 里直接用 <code>async</code> 方法。</li>
<li>如果必须用异步方法，需同步等待（如 <code>.Wait()</code>）。</li>
</ul>
<p>希望本文能帮你正确理解和使用 <code>LongRunning</code> 任务！</p>
<p>最后，再次感谢<code>黑洞视界</code>指出问题。如果对于这个问题大家希望了解更多，可以拜读大佬的这篇文章：<br>
<a href="https://www.cnblogs.com/eventhorizon/p/17497359.html" target="_blank">https://www.cnblogs.com/eventhorizon/p/17497359.html</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">        
<p id="PSignature" style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 10px; font-family: 微软雅黑; font-size: 11px">       
QQ群：1022985150 VX：kklldog 一起探讨学习.NET技术
<br>
作者：<a href="http://www.cnblogs.com/kklldog" target="_blank">Agile.Zhou(kklldog)</a>            
<br> 
出处：<a href="http://www.cnblogs.com/kklldog/" target="_blank">http://www.cnblogs.com/kklldog/</a>
<br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
 </p>  
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-04 22:05">2025-08-04 22:05</span>&nbsp;
<a href="https://www.cnblogs.com/kklldog">Agile.Zhou</a>&nbsp;
阅读(<span id="post_view_count">165</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19022317);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19022317', targetLink: 'https://www.cnblogs.com/kklldog/p/19022317', title: 'LongRunningTask-正确用法' })">举报</a>
</div>
        