
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ygluu/p/19055375" title="发布于 2025-08-24 12:32">
    <span role="heading" aria-level="2">自动化 Lua ⟷ C API功能模块（ygluu）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h6 id="关键词cc模板template反射luaapi绑定自动化开发效率成本">关键词：C/C++、模板、template、反射、Lua、API、绑定、自动化、开发、效率、成本</h6>
<h2 id="痛点"><strong>痛点：</strong></h2>
<p>C/C++没有完美的反射功能(如golang/delphi)，对开发 Lua ⟷ C API 来说是比较繁琐和耗工时的，并且人工编码的出错率也非常高。</p>
<h2 id="方案"><strong>方案</strong></h2>
<p>C++模板编译期自动化推导。</p>
<h2 id="优点"><strong>优点</strong></h2>
<p>•性能高（相比于反射）<br>
•提高开发效率（相比与人工）<br>
•出错率极低（相比与人工）</p>
<h2 id="示例"><strong>示例</strong></h2>
<h3 id="示例1注册-c-函数到-lua">示例1：注册 C++ 函数到 Lua</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3509144/202508/3509144-20250824122520741-2118306985.png" class="lazyload"></p>
<h3 id="示例2从-c-调用-lua-函数无函数指针方式">示例2：从 C++ 调用 Lua 函数（无函数指针方式）</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3509144/202508/3509144-20250824122416369-196398402.png" class="lazyload"></p>
<h3 id="示例3从-c-调用-lua-函数函数指针方式">示例3：从 C++ 调用 Lua 函数（函数指针方式）</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3509144/202508/3509144-20250824122445996-811986651.png" class="lazyload"></p>
<h2 id="代码"><strong>代码</strong></h2>
<pre><code>/**********************************************************************************
 * 
 *  自动化 Lua ⟷ C API功能模块
 * 
 *  author: ygluu
 * 
 *  1、Lua-&gt;C: 自动推导和注册C-Func参数和返回值给Lua调用
 *      函数 alua::reg_lua&lt;c-func&gt;(L, mod_name, func_name)
 * 
 *  2、C-&gt;Lua: 自动推导C-Call语句的参数和返回值并调用Lua函数
 *
 *      无返回值调用（常用）
 *          alua::call_lua(L, mod_name, func_name, lua-args...);
 * 
 *      显式返回类型调用（常用）
 * 
 *          int ret = alua::call_lua(L, mod_name, func_name, lua-args...);
 * 
 *          std::tuple&lt;int, bool, string&gt; ret = alua::call_lua(L, mod_name, func_name, lua-args...);
 * 
 *          std::map&lt;string, int&gt; ret = alua::call_lua(L, mod_name, func_name, lua-args...);
 * 
 *      隐式返回类型调用（需声明与LUA函数一致的c-func声明）
 *          auto ret = alua::call_lua&lt;c-func&gt;(...);
 * 
 * 参数和返回值类型支持：
 *      1、基础类型：int/uint32/int64/uint64/string(const char*)/bool
 *      2、数组：std::vector&lt;基础类型&gt;
 *      3、元组：std::tuple&lt;基础类型，基础类型，...&gt;
 *      4、字典：std::map/std::unordered_map&lt;基础类型, 基础类型&gt;
 * 
 * 
**********************************************************************************/

#pragma once

#include "lua.hpp"

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;source_location&gt;

namespace alua
{
    // 工具：把 __PRETTY_FUNCTION__ 里的裸函数名取出来
    namespace
    {
        // 判断是否是 tuple
        template&lt;typename T&gt; inline constexpr bool is_tuple_v = false;
        template&lt;typename... Ts&gt; inline constexpr bool is_tuple_v&lt;std::tuple&lt;Ts...&gt;&gt; = true;

        // 计算期望返回数量
        template&lt;typename R&gt;
        constexpr int expected_returns() noexcept
        {
            if constexpr (std::is_same_v&lt;R, void&gt;) return 0;
            else if constexpr (is_tuple_v&lt;R&gt;) return std::tuple_size_v&lt;R&gt;;
            else return 1;
        }

        constexpr std::string_view raw_name(std::string_view pretty) noexcept
        {
            std::size_t tail = pretty.rfind('(');
            if (tail == std::string_view::npos) { return pretty; }
            std::size_t head = pretty.rfind(' ', tail);
            return (head == std::string_view::npos)
                   ? pretty.substr(0, tail)
                   : pretty.substr(head + 1, tail - head - 1);
        }

        // 单值读取 / 压栈
        template&lt;typename T&gt; struct popper;
        template&lt;typename T&gt; struct pusher;

        // 数值
        template&lt;&gt; struct popper&lt;int&gt;           { static int           get(lua_State* l,int i){return static_cast&lt;int&gt;(luaL_checkinteger(l,i));}};
        template&lt;&gt; struct popper&lt;float&gt;         { static float         get(lua_State* l,int i){return static_cast&lt;float&gt;(luaL_checknumber(l,i));}};
        template&lt;&gt; struct popper&lt;double&gt;        { static double        get(lua_State* l,int i){return luaL_checknumber(l,i);}};
        template&lt;&gt; struct popper&lt;bool&gt;          { static bool          get(lua_State* l,int i){return lua_toboolean(l,i)!=0;}};
        template&lt;&gt; struct popper&lt;std::uint32_t&gt; { static std::uint32_t get(lua_State* l,int i){return static_cast&lt;std::uint32_t&gt;(luaL_checkinteger(l,i));}};
        template&lt;&gt; struct popper&lt;std::uint64_t&gt; { static std::uint64_t get(lua_State* l,int i){return static_cast&lt;std::uint64_t&gt;(luaL_checkinteger(l,i));}};
        template&lt;&gt; struct popper&lt;std::int64_t&gt;  { static std::int64_t  get(lua_State* l,int i){return static_cast&lt;std::int64_t&gt;(luaL_checkinteger(l,i));}};

        // 字符串
        template&lt;&gt; struct popper&lt;std::string&gt;
        {
            static std::string get(lua_State* l,int i)
            {
                std::size_t len = 0;
                const char* s = luaL_checklstring(l,i,&amp;len);
                return std::string{s,len};
            }
        };
        template&lt;&gt; struct popper&lt;const char*&gt; { static const char* get(lua_State* l,int i){return luaL_checkstring(l,i);}};

        // 轻量 userdata
        template&lt;&gt; struct popper&lt;void*&gt; { static void* get(lua_State* l,int i){return lua_touserdata(l,i);}};

        // 压栈
        template&lt;&gt; struct pusher&lt;int&gt;           { static void put(lua_State* l,int v){lua_pushinteger(l,v);}};
        template&lt;&gt; struct pusher&lt;float&gt;         { static void put(lua_State* l,float v){lua_pushnumber(l,v);}};
        template&lt;&gt; struct pusher&lt;double&gt;        { static void put(lua_State* l,double v){lua_pushnumber(l,v);}};
        template&lt;&gt; struct pusher&lt;bool&gt;          { static void put(lua_State* l,bool v){lua_pushboolean(l,v);}};
        template&lt;&gt; struct pusher&lt;std::uint32_t&gt; { static void put(lua_State* l,std::uint32_t v){lua_pushnumber(l,v);}};
        template&lt;&gt; struct pusher&lt;std::uint64_t&gt; { static void put(lua_State* l,std::uint64_t v){lua_pushnumber(l,v);}};
        template&lt;&gt; struct pusher&lt;std::int64_t&gt;  { static void put(lua_State* l,std::int64_t v){lua_pushnumber(l,v);}};
        template&lt;&gt; struct pusher&lt;std::string&gt;   { static void put(lua_State* l,const std::string&amp; v){lua_pushlstring(l,v.data(),v.size());}};
        template&lt;&gt; struct pusher&lt;const char*&gt;   { static void put(lua_State* l,const char* v){lua_pushstring(l,v);}};
        template&lt;&gt; struct pusher&lt;void*&gt;         { static void put(lua_State* l,void* v){lua_pushlightuserdata(l,v);}};

        // vector
        template&lt;typename T&gt; struct popper&lt;std::vector&lt;T&gt;&gt;
        {
            static std::vector&lt;T&gt; get(lua_State* l,int idx)
            {
                luaL_checktype(l,idx,LUA_TTABLE);
                std::vector&lt;T&gt; v;
                lua_pushnil(l);
                while(lua_next(l,idx)!=0)
                {
                    v.emplace_back(popper&lt;T&gt;::get(l,-1));
                    lua_pop(l,1);
                }
                return v;
            }
        };
        template&lt;typename T&gt; struct pusher&lt;std::vector&lt;T&gt;&gt;
        {
            static void put(lua_State* l,const std::vector&lt;T&gt;&amp; v)
            {
                lua_createtable(l,static_cast&lt;int&gt;(v.size()),0);
                for(std::size_t i=0;i&lt;v.size();++i)
                {
                    pusher&lt;T&gt;::put(l,v[i]);
                    lua_rawseti(l,-2,static_cast&lt;int&gt;(i+1));
                }
            }
        };

        // unordered_map
        template&lt;typename K,typename V&gt; struct popper&lt;std::unordered_map&lt;K,V&gt;&gt;
        {
            static std::unordered_map&lt;K,V&gt; get(lua_State* l,int idx)
            {
                luaL_checktype(l,idx,LUA_TTABLE);
                std::unordered_map&lt;K,V&gt; m;
                lua_pushnil(l);
                while(lua_next(l,idx)!=0)
                {
                    K k=popper&lt;K&gt;::get(l,-2);
                    V v=popper&lt;V&gt;::get(l,-1);
                    m.emplace(std::move(k),std::move(v));
                    lua_pop(l,1);
                }
                return m;
            }
        };
        template&lt;typename K,typename V&gt; struct pusher&lt;std::unordered_map&lt;K,V&gt;&gt;
        {
            static void put(lua_State* l,const std::unordered_map&lt;K,V&gt;&amp; m)
            {
                lua_createtable(l,0,static_cast&lt;int&gt;(m.size()));
                for(const auto&amp; [k,v]:m)
                {
                    pusher&lt;K&gt;::put(l,k);
                    pusher&lt;V&gt;::put(l,v);
                    lua_settable(l,-3);
                }
            }
        };

        // tuple
        template&lt;typename...&gt; struct tuple_popper;
        template&lt;&gt; struct tuple_popper&lt;&gt; { static std::tuple&lt;&gt; get(lua_State*,int){return {};}; };
        template&lt;typename H,typename... T&gt; struct tuple_popper&lt;H,T...&gt;
        {
            static auto get(lua_State* l,int idx)
            {
                return std::tuple_cat(std::make_tuple(popper&lt;H&gt;::get(l,idx)),
                                      tuple_popper&lt;T...&gt;::get(l,idx+1));
            }
        };

        // 返回值包装
        template&lt;typename R&gt; struct ret_helper
        {
            static int push(lua_State* l,const R&amp; v){pusher&lt;R&gt;::put(l,v);return 1;}
        };
        template&lt;&gt; struct ret_helper&lt;void&gt;{ static int push(lua_State*,...){return 0;} };
        template&lt;typename... Ts&gt; struct ret_helper&lt;std::tuple&lt;Ts...&gt;&gt;
        {
            static int push(lua_State* l,const std::tuple&lt;Ts...&gt;&amp; tup)
            {
                std::apply([&amp;l](const Ts&amp;... vs){(pusher&lt;Ts&gt;::put(l,vs),...);},tup);
                return static_cast&lt;int&gt;(sizeof...(Ts));
            }
        };

        // C 函数 → Lua 包装
        template&lt;auto f&gt; struct lua_to_c_wrapper;
        template&lt;typename R,typename... A,R(*f)(A...)&gt; struct lua_to_c_wrapper&lt;f&gt;
        {
            static int call(lua_State* l)
            {
                constexpr int k_expect=sizeof...(A);
                const int argc=lua_gettop(l);
                if(argc!=static_cast&lt;int&gt;(k_expect))
                {
                    luaL_error(l,"expect %d args, got %d",k_expect,argc);
                }
                try
                {
                    auto args=tuple_popper&lt;A...&gt;::get(l,1);
                    if constexpr(std::is_same_v&lt;R,void&gt;)
                    {
                        std::apply(f,args);
                        return 0;
                    }
                    else
                    {
                        R ret=std::apply(f,args);
                        return ret_helper&lt;R&gt;::push(l,ret);
                    }
                }
                catch(const std::exception&amp; e)
                {
                    luaL_where(l,1);
                    lua_pushfstring(l,"C++ exception: %s",e.what());
                    lua_concat(l,2);
                    lua_error(l);
                }
                catch(...)
                {
                    luaL_where(l,1);
                    lua_pushstring(l,"unknown C++ exception");
                    lua_concat(l,2);
                    lua_error(l);
                }
                return 0;
            }
        };

        // 已知函数指针的调用实现
        template&lt;auto f&gt; struct lua_caller;
        template&lt;typename R,typename... A,R(*f)(A...)&gt; struct lua_caller&lt;f&gt;
        {
            static R call(lua_State* L,const char* mod,const char* fn,const A&amp;... args)
            {
                constexpr int k_argc=sizeof...(A);
                constexpr int k_ret = expected_returns&lt;R&gt;();
                constexpr bool k_void=std::is_same_v&lt;R,void&gt;;
                const int base=lua_gettop(L);

                lua_getglobal(L,"debug");
                lua_getfield(L,-1,"traceback");

                // 找函数
                if(mod &amp;&amp; *mod)
                {
                    lua_getglobal(L,mod);
                    if(!lua_istable(L,-1)) luaL_error(L,"module '%s' not found",mod);
                    lua_getfield(L,-1,fn);
                    lua_remove(L,-2);
                }
                else
                {
                    lua_getglobal(L,fn);
                }
                if(!lua_isfunction(L,-1))
                {
                    auto full=mod?(std::string(mod)+'.'+fn):std::string(fn);
                    alog_print(get_log_file(),LogLevel::LEVEL_ERROR,full.c_str(),full.size());
                }

                (pusher&lt;std::decay_t&lt;A&gt;&gt;::put(L,args),...);

                lua_inc_call_count();
                if(lua_pcall(L,k_argc,k_ret,base+2)!=LUA_OK)
                {
                    size_t sz; auto str=lua_tolstring(L,-1,&amp;sz);
                    alog_print(get_log_file(),LogLevel::LEVEL_ERROR,str,sz);
                }

                if constexpr(std::is_same_v&lt;R,void&gt;)
                {
                    lua_settop(L,base);
                    return;
                }
                else if constexpr(is_tuple_v&lt;R&gt;)
                {
                    // 读取 tuple 返回值
                    R ret = [&amp;L,k_ret] {
                        return popper&lt;R&gt;::get(L,-k_ret);
                    }();
                    lua_settop(L,base);
                    return ret;
                }
                else
                {
                    R ret=popper&lt;R&gt;::get(L,-1);
                    lua_settop(L,base);
                    return ret;
                }
            }
        };

        // 无需函数指针的调用实现
        template&lt;typename R&gt;
        struct free_caller
        {
            template&lt;typename... Args&gt;
            static R call(lua_State* L,const char* mod,const char* fn,Args&amp;&amp;... args)
            {
                constexpr int k_ret = expected_returns&lt;R&gt;();
                constexpr bool k_void=std::is_same_v&lt;R,void&gt;;
                const int base=lua_gettop(L);

                lua_getglobal(L,"debug");
                lua_getfield(L,-1,"traceback");

                // 找函数
                if(mod &amp;&amp; *mod)
                {
                    lua_getglobal(L,mod);
                    if(!lua_istable(L,-1)) luaL_error(L,"module '%s' not found",mod);
                    lua_getfield(L,-1,fn);
                    lua_remove(L,-2);
                }
                else
                {
                    lua_getglobal(L,fn);
                }
                if(!lua_isfunction(L,-1))
                {
                    auto full=mod?(std::string(mod)+'.'+fn):std::string(fn);
                    alog_print(get_log_file(),LogLevel::LEVEL_ERROR,full.c_str(),full.size());
                }

                (pusher&lt;std::decay_t&lt;Args&gt;&gt;::put(L,std::forward&lt;Args&gt;(args)),...);

                lua_inc_call_count();
                if(lua_pcall(L,sizeof...(Args),k_ret,base+2)!=LUA_OK)
                {
                    size_t sz; auto str=lua_tolstring(L,-1,&amp;sz);
                    alog_print(get_log_file(),LogLevel::LEVEL_ERROR,str,sz);
                }

                if constexpr(std::is_same_v&lt;R,void&gt;)
                {
                    lua_settop(L,base);
                    return;
                }
                else if constexpr(is_tuple_v&lt;R&gt;)
                {
                    R ret = popper&lt;R&gt;::get(L,-k_ret);
                    lua_settop(L,base);
                    return ret;
                }
                else
                {
                    R ret=popper&lt;R&gt;::get(L,-1);
                    lua_settop(L,base);
                    return ret;
                }
            }
        };

        // tuple 读取器
        template&lt;typename... Ts&gt;
        struct popper&lt;std::tuple&lt;Ts...&gt;&gt;
        {
            static std::tuple&lt;Ts...&gt; get(lua_State* l,int idx)
            {
                constexpr std::size_t N=sizeof...(Ts);
                if(lua_gettop(l)-idx+1&lt;static_cast&lt;int&gt;(N))
                    luaL_error(l,"not enough return values for tuple");

                return [&amp;l,idx]&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;)
                {
                    return std::make_tuple(popper&lt;Ts&gt;::get(l,idx+I)...);
                }(std::make_index_sequence&lt;N&gt;{});
            }
        };
    } // namespace

    // 已知函数原型，两参
    template&lt;auto f,typename... Args&gt;
    auto call_lua(lua_State* L,const char* fn,Args&amp;&amp;... args)
    {
        return lua_caller&lt;f&gt;::call(L,nullptr,fn,std::forward&lt;Args&gt;(args)...);
    }
    // 已知函数原型，三参
    template&lt;auto f,typename... Args&gt;
    auto call_lua(lua_State* L,const char* mod,const char* fn,Args&amp;&amp;... args)
    {
        return lua_caller&lt;f&gt;::call(L,mod,fn,std::forward&lt;Args&gt;(args)...);
    }
    // 仅指定返回值，两参（默认 void）
    template&lt;typename R=void,typename... Args&gt;
    auto call_lua(lua_State* L,const char* fn,Args&amp;&amp;... args)
    {
        return free_caller&lt;R&gt;::call(L,nullptr,fn,std::forward&lt;Args&gt;(args)...);
    }
    // 仅指定返回值，三参
    template&lt;typename R,typename... Args&gt;
    auto call_lua(lua_State* L,const char* mod,const char* fn,Args&amp;&amp;... args)
    {
        return free_caller&lt;R&gt;::call(L,mod,fn,std::forward&lt;Args&gt;(args)...);
    }

    // 注册函数
    template&lt;auto f&gt;
    inline void reg_lua(lua_State* L,const char* module_name,const char* lua_name=nullptr)
    {
        lua_getglobal(L,module_name);
        if(!lua_istable(L,-1))
        {
            lua_pop(L,1);
            luaL_error(L,"module '%s' not found",module_name);
            return;
        }
        const char* real_name=lua_name?lua_name:raw_name(std::source_location::current().function_name()).data();
        lua_pushcfunction(L,lua_to_c_wrapper&lt;f&gt;::call);
        lua_setfield(L,-2,real_name);
        lua_pop(L,1);
    }
} // namespace alua
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-24 12:32">2025-08-24 12:32</span>&nbsp;
<a href="https://www.cnblogs.com/ygluu">码客-ygluu</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19055375);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19055375', targetLink: 'https://www.cnblogs.com/ygluu/p/19055375', title: '自动化 Lua ⟷ C API功能模块（ygluu）' })">举报</a>
</div>
        