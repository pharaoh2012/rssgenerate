
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dalgleish/p/18938264" title="发布于 2025-06-20 14:10">
    <span role="heading" aria-level="2">03 - LayoutPanels例子 - SimpleInkCanvas</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>C# maui暂时没有官方支持InkCanvas，但是不影响，自己实现一个就行了。目前支持画图，选择，移动和删除。同时支持自定义橡皮擦形状，也支持绑定自定义的形状列表。</p>
<p><strong>实现一个Converter类，以后所有的绑定类型转换都在这个类中实现。</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Shares.Utility
{
    public class Converter : IValueConverter
    {
        public object? Convert(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
        {
            // Implement conversion logic here
            if (value is List&lt;string&gt; list)
            {
                return string.Join(", ", list); // 自定义分隔符
            }
            else if (value is int intValue &amp;&amp; targetType.IsEnum)
            {
                return Enum.ToObject(targetType, intValue); // 将整数转换为枚举类型
            }
            return value;
        }
        public object? ConvertBack(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
        {
            // Implement conversion back logic here
            return value;
        }
    }
}
</pre>
</div>
<p><strong>然后在MyStyles.xaml中添加Converter类的引用，这样以后所有项目都可以使用了，local是</strong></p>
<p>xmlns:local="clr-namespace:Shares.Utility;assembly=Shares"</p>
<div class="cnblogs_code">
<pre>    &lt;!--converter定义--&gt;
    &lt;local:Converter x:Key=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Converter</span><span style="color: rgba(128, 0, 0, 1)">"</span>/&gt;</pre>
</div>
<p><strong>InkCanvas重写GraphicsView</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">    public class InkCanvas : GraphicsView, IDrawable
    {
        public class DrawingPath
        {
            private RectF? cachedBounds;
            private bool isDirty = true;

            public Guid Id { get; } = Guid.NewGuid();
            public PathF Path { get; set; } = new PathF();
            public Color? StrokeColor { get; set; }
            public float StrokeThickness { get; set; }
            public bool IsSelected { get; set; }
            public PointF Pos { get; set; }

            public RectF Bounds
            {
                get
                {
                    if (!isDirty &amp;&amp; cachedBounds.HasValue)
                        return cachedBounds.Value;

                    if (Path.Count == 0)
                    {
                        cachedBounds = RectF.Zero;
                        return RectF.Zero;
                    }

                    var points = Path.Points;
                    float minX = float.MaxValue, minY = float.MaxValue;
                    float maxX = float.MinValue, maxY = float.MinValue;

                    foreach (var point in points)
                    {
                        float x = point.X + Pos.X;
                        float y = point.Y + Pos.Y;
                        minX = Math.Min(minX, x);
                        minY = Math.Min(minY, y);
                        maxX = Math.Max(maxX, x);
                        maxY = Math.Max(maxY, y);
                    }

                    cachedBounds = new RectF(minX, minY, maxX - minX, maxY - minY);
                    isDirty = false;
                    return cachedBounds.Value;
                }
            }

            public void InvalidateBounds() =&gt; isDirty = true;

            public void LineTo(float x, float y)
            {
                Path.LineTo(x, y);
                InvalidateBounds();
            }

            public bool IntersectAt(PointF eraserPos, float eraserRadius)
            {
                if (Path.Count == 0)
                    return false;

                // 优化点接触检查
                foreach (var point in Path.Points)
                {
                    float dx = point.X + Pos.X - eraserPos.X;
                    float dy = point.Y + Pos.Y - eraserPos.Y;
                    if (dx * dx + dy * dy &lt;= eraserRadius * eraserRadius)
                    {
                        return true;
                    }
                }

                // 优化线段接触检查
                if (Path.Count &gt;= 2)
                {
                    var points = Path.Points;
                    for (int i = 1; i &lt; points.Count(); i++)
                    {
                        var start = new PointF(points.ElementAt(i - 1).X + Pos.X, points.ElementAt(i - 1).Y + Pos.Y);
                        var end = new PointF(points.ElementAt(i).X + Pos.X, points.ElementAt(i).Y + Pos.Y);

                        if (PointToLineDistance(start, end, eraserPos) &lt;= eraserRadius)
                        {
                            return true;
                        }
                    }
                }

                return false;
            }

            public List&lt;DrawingPath&gt; SplitAt(PointF eraserPos, float eraserRadius)
            {
                var newPaths = new List&lt;DrawingPath&gt;();
                if (Path.Count &lt; 2) return newPaths;

                var points = Path.Points;
                int bestIndex = -1;
                float minDistance = float.MaxValue;

                // 1. 检查点接触
                for (int i = 0; i &lt; points.Count(); i++)
                {
                    float dx = points.ElementAt(i).X + Pos.X - eraserPos.X;
                    float dy = points.ElementAt(i).Y + Pos.Y - eraserPos.Y;
                    float distance = dx * dx + dy * dy;

                    if (distance &lt; minDistance)
                    {
                        minDistance = distance;
                        bestIndex = i;
                    }
                }

                // 点接触处理
                if (bestIndex &gt;= 0 &amp;&amp; minDistance &lt;= eraserRadius * eraserRadius)
                {
                    // 起点处理
                    if (bestIndex == 0)
                    {
                        if (points.Count() &gt; 1)
                        {
                            var newPath = new DrawingPath
                            {
                                StrokeColor = StrokeColor,
                                StrokeThickness = StrokeThickness,
                                Pos = Pos
                            };
                            newPath.Path.MoveTo(points.ElementAt(1));
                            for (int i = 2; i &lt; points.Count(); i++)
                            {
                                newPath.Path.LineTo(points.ElementAt(i));
                            }
                            newPaths.Add(newPath);
                        }
                        return newPaths;
                    }

                    // 终点处理
                    if (bestIndex == points.Count() - 1)
                    {
                        if (points.Count() &gt; 1)
                        {
                            var newPath = new DrawingPath
                            {
                                StrokeColor = StrokeColor,
                                StrokeThickness = StrokeThickness,
                                Pos = Pos
                            };
                            newPath.Path.MoveTo(points.ElementAt(0));
                            for (int i = 1; i &lt; points.Count() - 1; i++)
                            {
                                newPath.Path.LineTo(points.ElementAt(i));
                            }
                            newPaths.Add(newPath);
                        }
                        return newPaths;
                    }

                    // 中间点处理
                    if (bestIndex &gt; 0 &amp;&amp; bestIndex &lt; points.Count() - 1)
                    {
                        // 第一段路径
                        var path1 = new DrawingPath
                        {
                            StrokeColor = StrokeColor,
                            StrokeThickness = StrokeThickness,
                            Pos = Pos
                        };
                        path1.Path.MoveTo(points.ElementAt(0));
                        for (int i = 1; i &lt;= bestIndex; i++)
                        {
                            path1.Path.LineTo(points.ElementAt(i));
                        }
                        newPaths.Add(path1);

                        // 第二段路径
                        var path2 = new DrawingPath
                        {
                            StrokeColor = StrokeColor,
                            StrokeThickness = StrokeThickness,
                            Pos = Pos
                        };
                        path2.Path.MoveTo(points.ElementAt(bestIndex));
                        for (int i = bestIndex + 1; i &lt; points.Count(); i++)
                        {
                            path2.Path.LineTo(points.ElementAt(i));
                        }
                        newPaths.Add(path2);

                        return newPaths;
                    }
                }

                // 2. 线段接触处理
                bestIndex = -1;
                minDistance = float.MaxValue;

                for (int i = 1; i &lt; points.Count(); i++)
                {
                    var start = new PointF(points.ElementAt(i - 1).X + Pos.X, points.ElementAt(i - 1).Y + Pos.Y);
                    var end = new PointF(points.ElementAt(i).X + Pos.X, points.ElementAt(i).Y + Pos.Y);

                    float distance = PointToLineDistance(start, end, eraserPos);
                    if (distance &lt; minDistance)
                    {
                        minDistance = distance;
                        bestIndex = i;
                    }
                }

                if (bestIndex &gt; 0 &amp;&amp; minDistance &lt;= eraserRadius)
                {
                    // 第一段路径
                    if (bestIndex &gt; 1)
                    {
                        var path1 = new DrawingPath
                        {
                            StrokeColor = StrokeColor,
                            StrokeThickness = StrokeThickness,
                            Pos = Pos
                        };
                        path1.Path.MoveTo(points.ElementAt(0));
                        for (int i = 1; i &lt; bestIndex; i++)
                        {
                            path1.Path.LineTo(points.ElementAt(i));
                        }
                        newPaths.Add(path1);
                    }

                    // 第二段路径
                    if (bestIndex &lt; points.Count() - 1)
                    {
                        var path2 = new DrawingPath
                        {
                            StrokeColor = StrokeColor,
                            StrokeThickness = StrokeThickness,
                            Pos = Pos
                        };
                        path2.Path.MoveTo(points.ElementAt(bestIndex));
                        for (int i = bestIndex + 1; i &lt; points.Count(); i++)
                        {
                            path2.Path.LineTo(points.ElementAt(i));
                        }
                        newPaths.Add(path2);
                    }
                }

                return newPaths;
            }
        }

        public enum InkCanvasEditingMode { Ink, Select, Erase }

        public static readonly BindableProperty EditingModeProperty =
            BindableProperty.Create(nameof(EditingMode), typeof(InkCanvasEditingMode), typeof(InkCanvas),
                InkCanvasEditingMode.Ink, BindingMode.TwoWay, propertyChanged: OnEditingModeChanged);

        private static void OnEditingModeChanged(BindableObject bindable, object oldValue, object newValue)
        {
            if (bindable is InkCanvas canvas)
            {
                canvas.ClearSelection();
                canvas.Invalidate();
            }
        }

        public InkCanvasEditingMode EditingMode
        {
            get =&gt; (InkCanvasEditingMode)GetValue(EditingModeProperty);
            set =&gt; SetValue(EditingModeProperty, value);
        }

        public ObservableCollection&lt;DrawingPath&gt; Paths { get; set; } = new ObservableCollection&lt;DrawingPath&gt;();
        public DrawingPath Eraser { get; set;}
        public float EraserRadius { get; set; } = 15f; // 增大橡皮擦半径
        private DrawingPath? currentPath;
        private RectF? selectionRect;
        private PointF lastTouchPoint;
        private bool isMovingSelection;

        // 橡皮擦轨迹跟踪
        private readonly List&lt;PointF&gt; eraserTrail = new List&lt;PointF&gt;();
        private const int MaxEraserTrailPoints = 5;

        public Color StrokeColor { get; set; } = Colors.Black;
        public Color SelectionColor { get; set; } = Colors.Red;
        public float SelectionStrokeThickness { get; set; } = 1f;
        public float StrokeThickness { get; set; } = 1f;

        public InkCanvas()
        {
            Drawable = this;
            BackgroundColor = Colors.Transparent;
            Eraser = CreateEraserPath();

            StartInteraction += OnTouchStarted;
            DragInteraction += OnTouchMoved;
            EndInteraction += OnTouchEnded;
        }

        private DrawingPath CreateEraserPath()
        {
            var path = new PathF();
            var points = new[]
            {
            new PointF(107.4f, 13), new PointF(113.7f, 28.8f),
            new PointF(127.9f, 31.3f), new PointF(117.6f, 43.5f),
            new PointF(120.1f, 60.8f), new PointF(107.4f, 52.6f),
            new PointF(94.6f, 60.8f), new PointF(97.1f, 43.5f),
            new PointF(86.8f, 31.3f), new PointF(101f, 28.8f)
        };

            path.MoveTo(points[0]);
            for (int i = 1; i &lt; points.Length; i++)
            {
                path.LineTo(points[i]);
            }
            path.Close();

            return new DrawingPath { Path = path, StrokeColor = Colors.Black, StrokeThickness = 1f };
        }

        private void OnTouchStarted(object? sender, TouchEventArgs e)
        {
            if (e.Touches.Length == 0) return;

            var point = e.Touches[0];
            lastTouchPoint = new PointF(point.X, point.Y);
            eraserTrail.Clear(); // 清除历史轨迹

            switch (EditingMode)
            {
                case InkCanvasEditingMode.Ink:
                    StartInking(lastTouchPoint);
                    break;

                case InkCanvasEditingMode.Select:
                    StartSelection(lastTouchPoint);
                    break;

                case InkCanvasEditingMode.Erase:
                    StartErase(lastTouchPoint);
                    eraserTrail.Add(lastTouchPoint); // 添加起始点
                    break;
            }
            Invalidate();
        }

        private void StartInking(PointF startPoint)
        {
            currentPath = new DrawingPath
            {
                StrokeColor = StrokeColor,
                StrokeThickness = StrokeThickness,
                Pos = PointF.Zero
            };
            currentPath.Path.MoveTo(startPoint.X, startPoint.Y);
            Paths.Add(currentPath);
        }

        private void StartSelection(PointF startPoint)
        {
            isMovingSelection = Paths.Any(p =&gt; p.IsSelected &amp;&amp; p.Bounds.Contains(startPoint));

            if (!isMovingSelection)
            {
                ClearSelection();
                var clickedPath = Paths.LastOrDefault(p =&gt; p.Bounds.Contains(startPoint));

                if (clickedPath != null)
                {
                    clickedPath.IsSelected = true;
                    isMovingSelection = true;
                }
                else
                {
                    selectionRect = new RectF(startPoint, SizeF.Zero);
                }
            }
        }

        private void StartErase(PointF startPoint)
        {
            Eraser.Pos = new PointF(startPoint.X - Eraser.Path.Bounds.Width / 2,
                                    startPoint.Y - Eraser.Path.Bounds.Height / 4);
            Eraser.IsSelected = true;
        }

        private void OnTouchMoved(object? sender, TouchEventArgs e)
        {
            if (e.Touches.Length == 0) return;

            var currentPoint = new PointF(e.Touches[0].X, e.Touches[0].Y);

            switch (EditingMode)
            {
                case InkCanvasEditingMode.Ink:
                    ContinueInking(currentPoint);
                    break;

                case InkCanvasEditingMode.Select:
                    UpdateSelection(currentPoint);
                    break;

                case InkCanvasEditingMode.Erase:
                    UpdateEraser(currentPoint);
                    ErasePaths();
                    break;
            }
            Invalidate();
        }

        private void ContinueInking(PointF currentPoint)
        {
            if (currentPath == null) return;

            const float minDistance = 1.0f;
            float dx = currentPoint.X - lastTouchPoint.X;
            float dy = currentPoint.Y - lastTouchPoint.Y;

            if (dx * dx + dy * dy &gt; minDistance * minDistance)
            {
                currentPath.LineTo(currentPoint.X, currentPoint.Y);
                lastTouchPoint = currentPoint;
            }
        }

        private void UpdateSelection(PointF currentPoint)
        {
            if (isMovingSelection)
            {
                MoveSelectedPaths(currentPoint);
            }
            else if (selectionRect.HasValue)
            {
                UpdateSelectionRect(currentPoint);
            }
        }

        private void UpdateEraser(PointF currentPoint)
        {
            Eraser.Pos = new PointF(currentPoint.X - Eraser.Path.Bounds.Width / 2,
                                    currentPoint.Y - Eraser.Path.Bounds.Height / 4);

            // 添加到橡皮擦轨迹
            eraserTrail.Add(Eraser.Pos);
            if (eraserTrail.Count &gt; MaxEraserTrailPoints)
            {
                eraserTrail.RemoveAt(0);
            }

            lastTouchPoint = currentPoint;
        }

        // 优化擦除逻辑
        private void ErasePaths()
        {
            // 倒序遍历所有路径
            for (int i = Paths.Count - 1; i &gt;= 0; i--)
            {
                var path = Paths[i];

                // 检查橡皮擦轨迹上的所有点
                foreach (var trailPoint in eraserTrail)
                {
                    if (path.IntersectAt(trailPoint, EraserRadius))
                    {
                        var newPaths = path.SplitAt(trailPoint, EraserRadius);

                        if (newPaths.Count &gt; 0)
                        {
                            Paths.RemoveAt(i);
                            foreach (var newPath in newPaths)
                            {
                                if (newPath.Path.Count &gt;= 2) // 只添加有效路径
                                {
                                    Paths.Add(newPath);
                                }
                            }
                            break; // 路径已被处理，跳出循环
                        }
                        else
                        {
                            // 没有新路径表示整个路径应被删除
                            Paths.RemoveAt(i);
                            break;
                        }
                    }
                }
            }
        }

        private void MoveSelectedPaths(PointF currentPoint)
        {
            float deltaX = currentPoint.X - lastTouchPoint.X;
            float deltaY = currentPoint.Y - lastTouchPoint.Y;

            foreach (var path in Paths)
            {
                if (path.IsSelected)
                {
                    path.Pos = new PointF(path.Pos.X + deltaX, path.Pos.Y + deltaY);
                    path.InvalidateBounds();
                }
            }
            lastTouchPoint = currentPoint;
        }

        private void UpdateSelectionRect(PointF currentPoint)
        {
            float x = Math.Min(lastTouchPoint.X, currentPoint.X);
            float y = Math.Min(lastTouchPoint.Y, currentPoint.Y);
            float width = Math.Abs(currentPoint.X - lastTouchPoint.X);
            float height = Math.Abs(currentPoint.Y - lastTouchPoint.Y);

            selectionRect = new RectF(x, y, width, height);
        }

        private void OnTouchEnded(object? sender, TouchEventArgs e)
        {
            switch (EditingMode)
            {
                case InkCanvasEditingMode.Select when selectionRect.HasValue:
                    FinalizeSelection();
                    break;
            }

            currentPath = null;
            selectionRect = null;
            isMovingSelection = false;
            Eraser.IsSelected = false;
            eraserTrail.Clear(); // 清除橡皮擦轨迹
            Invalidate();
        }

        private void FinalizeSelection()
        {
            var selection = selectionRect!.Value;

            foreach (var path in Paths)
            {
                if (!selection.IntersectsWith(path.Bounds)) continue;

                if (selection.Contains(path.Bounds))
                {
                    path.IsSelected = true;
                    continue;
                }

                foreach (var point in path.Path.Points)
                {
                    var absolutePoint = new PointF(point.X + path.Pos.X, point.Y + path.Pos.Y);
                    if (selection.Contains(absolutePoint))
                    {
                        path.IsSelected = true;
                        break;
                    }
                }
            }
        }

        public void ClearSelection()
        {
            foreach (var path in Paths)
            {
                path.IsSelected = false;
            }
        }

        public void Draw(ICanvas canvas, RectF dirtyRect)
        {
            canvas.FillColor = BackgroundColor;
            canvas.FillRectangle(dirtyRect);

            canvas.StrokeLineCap = LineCap.Round;
            canvas.StrokeLineJoin = LineJoin.Round;

            // 绘制所有路径
            foreach (var path in Paths)
            {
                DrawPath(canvas, path);
            }

            // 绘制橡皮擦（如果被选中）
            if (Eraser.IsSelected)
            {
                DrawEraser(canvas);
            }

            // 绘制选择框
            if (selectionRect.HasValue)
            {
                DrawSelectionRect(canvas, selectionRect.Value);
            }
        }

        private void DrawPath(ICanvas canvas, DrawingPath path)
        {
            var strokeColor = path.StrokeColor ?? Colors.Black;
            float strokeSize = path.IsSelected ? path.StrokeThickness * 1.5f : path.StrokeThickness;

            if (!path.IsSelected)
            {
                strokeColor = strokeColor.WithAlpha(0.5f);
            }

            canvas.StrokeColor = strokeColor;
            canvas.StrokeSize = strokeSize;

            canvas.SaveState();
            canvas.Translate(path.Pos.X, path.Pos.Y);
            canvas.DrawPath(path.Path);
            canvas.RestoreState();
        }

        private void DrawEraser(ICanvas canvas)
        {
            canvas.SaveState();
            canvas.Translate(Eraser.Pos.X, Eraser.Pos.Y);
            canvas.Scale(0.2f, 0.2f);
            canvas.StrokeColor = Eraser.StrokeColor ?? Colors.Black;
            canvas.StrokeSize = Eraser.StrokeThickness;
            canvas.FillColor = Color.FromArgb("#FFD700");
            canvas.FillPath(Eraser.Path);
            canvas.DrawPath(Eraser.Path);
            canvas.RestoreState();
        }

        private void DrawSelectionRect(ICanvas canvas, RectF rect)
        {
            canvas.SaveState();
            canvas.StrokeColor = SelectionColor;
            canvas.StrokeSize = SelectionStrokeThickness;
            canvas.StrokeDashPattern = new float[] { 5, 3 };
            canvas.DrawRectangle(rect);
            canvas.RestoreState();
        }

        // 静态工具方法
        public static float Distance(PointF a, PointF b)
            =&gt; (float)Math.Sqrt(Math.Pow(a.X - b.X, 2) + Math.Pow(a.Y - b.Y, 2));

        public static float DistanceSquared(PointF a, PointF b)
            =&gt; (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);

        public static float PointToLineDistance(PointF lineStart, PointF lineEnd, PointF point)
        {
            float l2 = DistanceSquared(lineStart, lineEnd);
            if (l2 == 0) return Distance(point, lineStart);

            float t = Math.Max(0, Math.Min(1, Vector2.Dot(
                new Vector2(point.X - lineStart.X, point.Y - lineStart.Y),
                new Vector2(lineEnd.X - lineStart.X, lineEnd.Y - lineStart.Y)) / l2));

            PointF projection = new PointF(
                lineStart.X + t * (lineEnd.X - lineStart.X),
                lineStart.Y + t * (lineEnd.Y - lineStart.Y)
            );

            return Distance(point, projection);
        }
    }
</pre>
</div>
<p><strong>SimpleInkCanvas.xaml</strong></p>
<div class="cnblogs_code">
<pre>&lt;?xml version=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">1.0</span><span style="color: rgba(128, 0, 0, 1)">"</span> encoding=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">utf-8</span><span style="color: rgba(128, 0, 0, 1)">"</span> ?&gt;
&lt;ContentPage xmlns=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://schemas.microsoft.com/dotnet/2021/maui</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
             xmlns:x</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://schemas.microsoft.com/winfx/2009/xaml</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
             xmlns:local</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">clr-namespace:Shares.Utility;assembly=Shares</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
             x:Class</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">MauiViews.MauiDemos.Book._03.SimpleInkCanvas</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
             Title</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">SimpleInkCanvas</span><span style="color: rgba(128, 0, 0, 1)">"</span> HeightRequest=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">300</span><span style="color: rgba(128, 0, 0, 1)">"</span> WidthRequest=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">300</span><span style="color: rgba(128, 0, 0, 1)">"</span>&gt;
    &lt;Grid RowDefinitions=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">auto,*</span><span style="color: rgba(128, 0, 0, 1)">"</span>&gt;
        &lt;StackLayout Margin=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">5</span><span style="color: rgba(128, 0, 0, 1)">"</span> Orientation=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Horizontal</span><span style="color: rgba(128, 0, 0, 1)">"</span>&gt;
            &lt;Label Text=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">EditingMode:</span><span style="color: rgba(128, 0, 0, 1)">"</span> Margin=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">5</span><span style="color: rgba(128, 0, 0, 1)">"</span> VerticalOptions=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Center</span><span style="color: rgba(128, 0, 0, 1)">"</span> FontSize=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">16</span><span style="color: rgba(128, 0, 0, 1)">"</span>/&gt;
            &lt;Picker x:Name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">lstEditingMode</span><span style="color: rgba(128, 0, 0, 1)">"</span> VerticalOptions=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Center</span><span style="color: rgba(128, 0, 0, 1)">"</span>/&gt;
        &lt;/StackLayout&gt;
        &lt;local:InkCanvas Grid.Row=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">1</span><span style="color: rgba(128, 0, 0, 1)">"</span> BackgroundColor=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LightYellow</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> 
                         EditingMode</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{Binding Path=SelectedIndex, </span>
                         Source={x:Reference lstEditingMode}, Converter={StaticResource Converter}}<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/&gt;</span>
        &lt;Button Text=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Hello</span><span style="color: rgba(128, 0, 0, 1)">"</span> Grid.Row=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">1</span><span style="color: rgba(128, 0, 0, 1)">"</span> WidthRequest=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">78</span><span style="color: rgba(128, 0, 0, 1)">"</span> HeightRequest=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">16</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> 
                HorizontalOptions</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Start</span><span style="color: rgba(128, 0, 0, 1)">"</span> VerticalOptions=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Start</span><span style="color: rgba(128, 0, 0, 1)">"</span>/&gt;
    &lt;/Grid&gt;
&lt;/ContentPage&gt;</pre>
</div>
<p><strong>对应的cs代码</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using static Shares.Utility.InkCanvas;

namespace MauiViews.MauiDemos.Book._03;

public partial class SimpleInkCanvas : ContentPage
{
	public SimpleInkCanvas()
	{
		InitializeComponent();
		foreach (InkCanvasEditingMode mode in Enum.GetValues(typeof(InkCanvasEditingMode)))
		{
            lstEditingMode.Items.Add(mode.ToString());
			lstEditingMode.SelectedIndex = 0;
        }
    }
}
</pre>
</div>
<p>运行效果</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/702851/202506/702851-20250620140858952-802407398.png" class="lazyload"></p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.021527777777777778" data-date-updated="2025-06-20 14:41">2025-06-20 14:10</span>&nbsp;
<a href="https://www.cnblogs.com/dalgleish">dalgleish</a>&nbsp;
阅读(<span id="post_view_count">19</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18938264);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18938264', targetLink: 'https://www.cnblogs.com/dalgleish/p/18938264', title: '03 - LayoutPanels例子 - SimpleInkCanvas' })">举报</a>
</div>
