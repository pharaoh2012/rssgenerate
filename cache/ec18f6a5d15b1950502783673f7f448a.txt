<!----> <meta itemprop="headline" content="【精华】为什么class在前端开发中不常用？"> <meta itemprop="keywords" content="JavaScript"> <meta itemprop="datePublished" content="2025-02-28T13:30:41.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="DRYWIND"> <meta itemprop="url" content="https://juejin.cn/user/2999942860514759"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-799d3073="">
            【精华】为什么class在前端开发中不常用？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-799d3073=""><div class="author-info-box" data-v-799d3073=""><div class="author-name" data-v-799d3073=""><a href="/user/2999942860514759/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-6a576a98="" data-v-799d3073=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-6a576a98="">
    DRYWIND
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-799d3073=""><time datetime="2025-02-28T13:30:41.000Z" title="Fri Feb 28 2025 13:30:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-799d3073="">
                    2025-02-28
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-799d3073=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-799d3073=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-799d3073=""></circle></svg> <span class="views-count" data-v-799d3073="">
                    13,247
                  </span> <span class="read-time" data-v-799d3073=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-799d3073=""><rect width="16" height="16" fill="none" data-v-799d3073=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-799d3073=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-799d3073=""></path></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-799d3073=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-799d3073=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">为什么class在前端开发中不常用？</h2>
<ul>
<li>js是一种基于原型的语言。</li>
<li>它的对象继承是通过 原型链（prototype chain）实现的，每个对象都有一个 <strong>proto</strong> 属性指向它的原型。（大多数传统面向对象语言（如 Java、C++、Python、Ruby）是基于类的。在这些语言中，对象是通过类（class）定义的模板实例化出来的，继承是通过类之间的关系实现的。)</li>
<li>ES6 的 class 只是语法糖，底层还是基于原型。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, grade</span>) {
    <span class="hljs-variable language_">super</span>(name, age);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;
  }
  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is studying`</span>;
  }
}

<span class="hljs-comment">//实际上等价于：</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
};

</code></pre>
<h2 data-id="heading-1">为什么不像其他语言基于类？</h2>
<p>这是一个非常有趣的问题！JavaScript 为什么选择基于原型而不是基于类，背后有历史、技术和设计哲学的原因。让我们一步步拆解。</p>
<hr>
<h4 data-id="heading-2">1. JavaScript 的诞生背景</h4>
<p>JavaScript 是由 Brendan Eich 在 1995 年为网景公司（Netscape）开发的，最初的目标是为网页添加简单的动态功能。当时的时间非常紧迫（据说只有 10 天设计和实现），因此语言设计上需要快速成型，同时保持简单和灵活。</p>
<p>在那个年代，面向对象编程（OOP）已经很流行，尤其是基于类的语言（如 C++ 和 Java）。网景公司的高层希望 JavaScript 能吸引 Java 开发者，所以表面上要求它“看起来像 Java”。但 Brendan Eich 本人更喜欢一种更动态、简洁的语言——他受到 <strong>Self</strong> 语言（一种基于原型的语言）的启发，最终选择了原型机制。</p>
<hr>
<h4 data-id="heading-3">2. 为什么选择原型而不是类？</h4>
<h5 data-id="heading-4">(1) 简单性和灵活性</h5>
<ul>
<li>
<p><strong>原型更简单</strong><br>
基于类的语言需要定义类的蓝图（模板），然后通过实例化生成对象。这种机制在复杂系统中很强大，但在简单的脚本语言中显得繁琐。原型机制直接让对象可以“复制”或“继承”另一个对象的行为，不需要额外的类定义。例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};
<span class="hljs-keyword">const</span> alice = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);
alice.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello"</span>
</code></pre>
<p>这比定义一个类、再实例化要直截了当。</p>
</li>
<li>
<p><strong>动态性</strong><br>
原型允许运行时修改对象的结构。你可以随时给原型添加方法，所有基于这个原型的对象都会自动获得新行为：</p>
<pre><code class="hljs language-javascript" lang="javascript">person.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hi there"</span>);
};
alice.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// "Hi there"</span>
</code></pre>
<p>而基于类的语言通常是静态的，类定义一旦确定就很难改动。</p>
</li>
</ul>
<h5 data-id="heading-5">(2) 适合脚本语言的轻量需求</h5>
<p>JavaScript 最初是为网页设计的，主要用来操作 DOM、处理事件等简单任务。基于类的系统更适合大型、结构化的软件（如操作系统或企业级应用），但对于一个嵌入浏览器的小型脚本语言来说，原型机制更轻量、更灵活，不需要复杂的编译步骤。</p>
<h5 data-id="heading-6">(3) Self 语言的影响</h5>
<p>Brendan Eich 深受 Self 语言启发。Self 是一种基于原型的语言，核心理念是“一切皆对象”，没有类的概念。对象直接通过克隆和修改原型来创建新对象。这种设计避免了类的抽象层，让语言更简洁。JavaScript 借鉴了这种思想，虽然加上了构造函数（<code>function</code>）来模拟类的实例化，但底层依然是原型。</p>
<hr>
<h4 data-id="heading-7">3. 为什么不像其他语言基于类？</h4>
<h5 data-id="heading-8">(1) 历史包袱和竞争压力</h5>
<ul>
<li>在 1995 年，网景和微软（IE 的 JScript）在浏览器大战中竞争激烈。JavaScript 需要快速推出并赢得开发者支持。如果完全照搬 Java 的基于类设计，会增加语言的复杂度和实现成本，可能拖慢开发进度。</li>
<li>同时，JavaScript 要吸引的不只是 Java 程序员，还有写脚本的非专业开发者（比如网页设计师）。原型机制加上动态特性，让它更容易上手。</li>
</ul>
<h5 data-id="heading-9">(2) 与其他语言的目标不同</h5>
<ul>
<li><strong>Java、C++</strong> 等语言是为构建大型、静态类型系统设计的，基于类的机制适合严格的类型检查和复杂的继承体系。</li>
<li>JavaScript 的目标是动态性和交互性，运行在浏览器中，面对的是不可预测的网页环境。原型机制让它能快速适应变化，比如动态添加方法或属性。</li>
</ul>
<h5 data-id="heading-10">(3) 哲学差异</h5>
<p>基于类的语言（尤其是强类型语言）强调“提前规划”和“结构化”，而 JavaScript 的原型机制更倾向于“边做边改”和“自由度”。这反映了 Brendan Eich 想创造一种更自由、实验性语言的初衷。</p>
<hr>
<h4 data-id="heading-11">4. 原型带来的独特优势</h4>
<ul>
<li>
<p><strong>灵活继承</strong><br>
你可以直接操作原型链，实现多样的继承方式，而不像基于类的语言受限于单一继承（Single Inheritance）或复杂的多重继承。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj1);
obj2.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">a</span>); <span class="hljs-comment">// 1 (从原型继承)</span>
</code></pre>
</li>
<li>
<p><strong>运行时扩展</strong><br>
原型允许你在运行时动态修改对象的行为，这在浏览器环境中非常有用，比如 polyfill（填补浏览器功能的缺失）。</p>
</li>
<li>
<p><strong>简洁的实现</strong><br>
原型的实现比类更轻量，占用内存更少，适合早期的资源有限的浏览器环境。</p>
</li>
</ul>
<hr>
<h4 data-id="heading-12">5. 为什么后来加了 <code>class</code>？</h4>
<p>尽管原型很强大，但开发者（尤其是来自 Java、C++ 背景的人）觉得它难以理解，而且代码组织不够直观。到了 ES6（2015 年），JavaScript 引入了 <code>class</code> 语法，主要是为了：</p>
<ul>
<li>迎合主流开发者的习惯。</li>
<li>提供更清晰的面向对象编程方式。</li>
</ul>
<p>但要注意，<code>class</code> 只是语法糖，底层仍然是原型机制。例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
}
</code></pre>
<p>实际上等价于：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
</code></pre>
<hr>
<h4 data-id="heading-13">总结：为什么 JS 基于原型？</h4>
<ul>
<li><strong>历史原因</strong>：快速开发、受到 Self 语言启发、迎合 Java 外观但保持简单。</li>
<li><strong>技术原因</strong>：原型更轻量、灵活，适合动态脚本语言的需求。</li>
<li><strong>哲学原因</strong>：强调自由度和运行时可变性，而不是静态结构。</li>
</ul>
<p>如果 JavaScript 当初选择基于类，可能更像 Java，失去今天的灵活性和独特性，但也可能让初学者更难接受它的动态特性。原型机制是 JavaScript 的“灵魂”，也是它能适应从简单脚本到现代复杂应用的关键。</p>
<h2 data-id="heading-14">原型机制的弱点（如灵活性带来的不可预测性）被怎么解决了？</h2>
<ul>
<li>渲染引擎的优化</li>
<li>TS</li>
<li>ES6 提供了class</li>
</ul>
<h2 data-id="heading-15"></h2>
<p>在 TypeScript 中，<strong>直接修改原型（比如 <code>xxx.prototype.somefunc = newFunc</code>）并没有被完全禁止</strong>，但它的行为和可行性受到了一些限制和约束。这主要取决于上下文、类型检查的严格程度以及代码的组织方式。让我详细解释一下。</p>
<hr>
<h2 data-id="heading-16">TypeScript已经不允许直接这样修改原型了吗？</h2>
<h4 data-id="heading-17">TypeScript 对原型修改的态度</h4>
<p>TypeScript 的核心目标是增强 JavaScript 的类型安全性和可维护性。它通过静态类型检查来减少运行时错误，但它仍然是 JavaScript 的超集，底层运行时行为没有改变。因此，TypeScript 允许你修改原型，但会通过类型系统和配置项对你施加一些限制。</p>
<h5 data-id="heading-18">1. 默认情况下是允许的，但类型不安全</h5>
<p>你仍然可以在 TypeScript 中直接修改原型，比如：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
p.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 "Hello, Alice"</span>
</code></pre>
<p>这段代码在 TypeScript 中是合法的，也能正常运行。因为 TypeScript 不会阻止你操作 <code>prototype</code>，它只是试图为这种操作提供类型支持。</p>
<p>但是，TypeScript 的类型系统可能无法自动推断出你添加的 <code>sayHello</code> 方法，除非你显式声明它的类型。这会导致类型检查时的警告或错误。</p>
<h5 data-id="heading-19">2. 类型声明缺失的问题</h5>
<p>如果你不告诉 TypeScript 你修改了原型，它会认为 <code>sayHello</code> 不存在：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
p.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// TS 错误: Property 'sayHello' does not exist on type 'Person'</span>
</code></pre>
<p>要解决这个问题，你需要在 <code>Person</code> 的类型定义中显式声明这个方法，比如通过接口或类型扩展：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Person, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
p.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 正常运行，且类型安全</span>
</code></pre>
<h5 data-id="heading-20">3. 使用 <code>class</code> 时更严格</h5>
<p>如果你使用 TypeScript 的 <code>class</code> 语法（推荐的方式），直接修改原型会受到更多限制。因为 <code>class</code> 的方法和属性是静态定义的，TypeScript 会假设类的结构是固定的：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
}; <span class="hljs-comment">// 可以运行，但不推荐</span>

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
p.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// TS 错误: Property 'sayHello' does not exist on type 'Person'</span>
</code></pre>
<p>在这种情况下，TypeScript 不会自动识别 <code>sayHello</code>，因为它不在类的定义中。你需要通过接口扩展来声明：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-title function_">sayHello</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
p.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 现在类型安全</span>
</code></pre>
<h5 data-id="heading-21">4. 严格模式下的限制</h5>
<p>如果你在 <code>tsconfig.json</code> 中启用了严格模式（<code>strict: true</code>），尤其是 <code>noImplicitAny</code> 和 <code>strictPropertyInitialization</code>，TypeScript 会更严格地检查类型。直接修改原型而不声明类型会更容易触发错误，迫使你显式定义接口或类型。</p>
<h5 data-id="heading-22">5. 对内置对象原型的修改</h5>
<p>如果你尝试修改内置对象的原型（如 <code>Object.prototype</code> 或 <code>Array.prototype</code>），TypeScript 不会阻止运行时行为，但会要求你通过声明合并（Declaration Merging）来扩展类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Array</span>&lt;T&gt; {
    <span class="hljs-title function_">myCustomMethod</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCustomMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Custom method on array"</span>);
};

<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
arr.<span class="hljs-title function_">myCustomMethod</span>(); <span class="hljs-comment">// 正常运行，且类型安全</span>
</code></pre>
<p>不这样做的话，TypeScript 会报错，因为它不知道 <code>myCustomMethod</code>。</p>
<hr>
<h4 data-id="heading-23">TypeScript 为什么不完全禁止？</h4>
<ol>
<li>
<p><strong>兼容 JavaScript</strong><br>
TypeScript 是 JavaScript 的超集，必须兼容 JS 的所有特性，包括原型机制。如果直接禁止修改原型，会破坏与现有 JS 代码的兼容性。</p>
</li>
<li>
<p><strong>动态性保留</strong><br>
JavaScript 的动态特性（如运行时修改原型）是其核心优势之一，TypeScript 不想完全剥夺这种灵活性，而是通过类型系统引导开发者更安全地使用。</p>
</li>
<li>
<p><strong>实际用例</strong><br>
在一些场景中（比如 polyfill 或库开发），修改原型仍然是合法且必要的。TypeScript 允许这种操作，但要求你显式声明类型。</p>
</li>
</ol>
<hr>
<h4 data-id="heading-24">现代 TypeScript 的推荐实践</h4>
<p>尽管你可以修改原型，TypeScript 更鼓励使用 <code>class</code> 或模块化的方式来组织代码，而不是直接操作 <code>prototype</code>：</p>
<ul>
<li><strong>用 <code>class</code> 替代</strong>：
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {}
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
    }
}
</code></pre>
</li>
<li><strong>用模块和函数替代</strong>：
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createPerson</span> = (<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt; ({
    name,
    <span class="hljs-attr">sayHello</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>`</span>)
});
</code></pre>
</li>
</ul>
<p>直接修改原型被视为“老派”或“不安全”的做法，尤其在大型项目中，可能导致：</p>
<ul>
<li>类型不一致。</li>
<li>维护困难（团队成员难以追踪原型修改）。</li>
<li>与静态类型系统的理念冲突。</li>
</ul>
<hr>
<h4 data-id="heading-25">结论</h4>
<ul>
<li><strong>TypeScript 没有禁止修改原型</strong>，但通过类型系统和严格检查，间接限制了这种行为。如果你想这样做，需要显式声明类型，否则会报错。</li>
<li><strong>在现代开发中不推荐</strong>，因为 <code>class</code> 和函数式编程提供了更清晰、更安全的替代方案。</li>
<li>如果你坚持用 <code>xxx.prototype.somefunc = newFunc</code>，是可以的，但要配合接口或类型声明，确保类型安全。</li>
</ul>
<hr>
<h2 data-id="heading-26">js中“复制”或“继承”的方法有哪些？</h2>
<p>在 JavaScript 中，基于原型的“复制”或“继承”机制是其核心特性之一。由于 JavaScript 是基于原型的语言，它没有传统基于类语言中的“类继承”，而是通过原型链实现类似继承的功能。以下是 JavaScript 中实现“复制”或“继承”的常用方法，涵盖了从低级操作到高级语法的各种方式：</p>
<hr>
<h4 data-id="heading-27">1. 通过 <code>Object.create()</code></h4>
<ul>
<li><strong>作用</strong>：创建一个新对象，并将其原型设置为指定对象，实现继承。</li>
<li><strong>特点</strong>：直接操作原型链，简单且灵活。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> parent = {
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello from parent"</span>);
    }
};

<span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello from parent"</span>
</code></pre>
</li>
<li><strong>注意</strong>：<code>child</code> 继承了 <code>parent</code> 的属性和方法，但自身是空的，可以添加新属性。</li>
</ul>
<hr>
<h4 data-id="heading-28">2. 通过构造函数和 <code>prototype</code></h4>
<ul>
<li><strong>作用</strong>：利用构造函数和原型链实现继承，模拟类的行为。</li>
<li><strong>特点</strong>：传统方式，广泛用于 ES5 及之前。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 复制 Parent 的实例属性</span>
}
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 继承原型方法</span>
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 修正 constructor</span>

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">"Alice"</span>);
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Alice"</span>
</code></pre>
</li>
<li><strong>步骤</strong>：
<ol>
<li>用 <code>call</code> 或 <code>apply</code> 复制父构造函数的属性。</li>
<li>用 <code>Object.create</code> 设置原型链。</li>
<li>修正 <code>constructor</code> 属性（可选）。</li>
</ol>
</li>
</ul>
<hr>
<h4 data-id="heading-29">3. 通过 ES6 的 <code>class</code> 和 <code>extends</code></h4>
<ul>
<li><strong>作用</strong>：使用 ES6 的类语法实现继承（底层仍是原型）。</li>
<li><strong>特点</strong>：语法糖，更直观，适合现代开发。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类的构造函数</span>
    }
}

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">"Alice"</span>);
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Alice"</span>
</code></pre>
</li>
<li><strong>注意</strong>：<code>extends</code> 底层是通过原型链实现的，等价于构造函数方式。</li>
</ul>
<hr>
<h4 data-id="heading-30">4. 通过对象字面量和扩展运算符（浅复制）</h4>
<ul>
<li><strong>作用</strong>：复制对象的属性（不涉及原型链），实现简单的“复制”。</li>
<li><strong>特点</strong>：不完全是继承，更像是属性拷贝，适用于简单场景。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> parent = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span>,
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};

<span class="hljs-keyword">const</span> child = { ...parent };
child.<span class="hljs-property">name</span> = <span class="hljs-string">"Bob"</span>;
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parent.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Alice"（互不影响）</span>
</code></pre>
</li>
<li><strong>限制</strong>：只复制自身属性，不复制原型上的方法，且是浅复制。</li>
</ul>
<hr>
<h4 data-id="heading-31">5. 通过 <code>Object.assign()</code></h4>
<ul>
<li><strong>作用</strong>：将一个或多个源对象的可枚举属性复制到目标对象。</li>
<li><strong>特点</strong>：浅复制，常用于合并对象。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> parent = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span>,
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};

<span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, parent);
child.<span class="hljs-property">name</span> = <span class="hljs-string">"Bob"</span>;
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello"</span>
</code></pre>
</li>
<li><strong>限制</strong>：和扩展运算符类似，不复制原型链。</li>
</ul>
<hr>
<h4 data-id="heading-32">6. 通过 <code>__proto__</code>（不推荐）</h4>
<ul>
<li><strong>作用</strong>：直接设置对象的 <code>__proto__</code> 属性，指定原型。</li>
<li><strong>特点</strong>：低级操作，灵活但不推荐（性能差且已被废弃）。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> parent = {
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};

<span class="hljs-keyword">const</span> child = { <span class="hljs-attr">__proto__</span>: parent };
child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello"</span>
</code></pre>
</li>
<li><strong>警告</strong>：<code>__proto__</code> 是非标准特性，可能不支持，且不建议在生产代码中使用。</li>
</ul>
<hr>
<h4 data-id="heading-33">7. 通过混入（Mixin）</h4>
<ul>
<li><strong>作用</strong>：将多个对象的功能“混合”到一个对象中。</li>
<li><strong>特点</strong>：不依赖原型链，灵活实现多继承。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> canSpeak = {
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};
<span class="hljs-keyword">const</span> canWalk = {
    <span class="hljs-title function_">walk</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Walking"</span>);
    }
};

<span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, canSpeak, canWalk);
person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello"</span>
person.<span class="hljs-title function_">walk</span>(); <span class="hljs-comment">// "Walking"</span>
</code></pre>
</li>
<li><strong>注意</strong>：属性冲突时，后者覆盖前者。</li>
</ul>
<hr>
<h4 data-id="heading-34">8. 深复制（特殊情况）</h4>
<ul>
<li><strong>作用</strong>：完全复制对象，包括嵌套属性，不涉及原型继承。</li>
<li><strong>特点</strong>：用于独立复制整个对象。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> parent = {
    <span class="hljs-attr">info</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },
    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
};

<span class="hljs-keyword">const</span> child = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(parent));
child.<span class="hljs-property">info</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"Bob"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parent.<span class="hljs-property">info</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Alice"（互不影响）</span>
</code></pre>
</li>
<li><strong>限制</strong>：<code>JSON</code> 方法不支持函数和原型，且只适用于可序列化的数据。也可以用库（如 Lodash 的 <code>_.cloneDeep</code>）。</li>
</ul>
<hr>
<h4 data-id="heading-35">方法对比</h4>




































































<table><thead><tr><th>方法</th><th>类型</th><th>是否涉及原型</th><th>复制深度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>Object.create</code></td><td>继承</td><td>是</td><td>-</td><td>原型链继承</td></tr><tr><td>构造函数+原型</td><td>继承</td><td>是</td><td>-</td><td>模拟类继承（ES5）</td></tr><tr><td><code>class extends</code></td><td>继承</td><td>是</td><td>-</td><td>现代类继承（ES6+）</td></tr><tr><td>扩展运算符</td><td>复制</td><td>否</td><td>浅复制</td><td>简单对象复制</td></tr><tr><td><code>Object.assign</code></td><td>复制</td><td>否</td><td>浅复制</td><td>属性合并</td></tr><tr><td><code>__proto__</code></td><td>继承</td><td>是</td><td>-</td><td>低级原型操作（不推荐）</td></tr><tr><td>Mixin</td><td>复制/混合</td><td>否</td><td>浅复制</td><td>多功能组合</td></tr><tr><td>深复制（JSON）</td><td>复制</td><td>否</td><td>深复制</td><td>完全独立对象</td></tr></tbody></table>
<hr>
<h4 data-id="heading-36">总结</h4>
<ul>
<li><strong>继承（基于原型）</strong>：<code>Object.create</code>、<code>class extends</code>、构造函数+原型是主要方式，适合需要原型链的场景。</li>
<li><strong>复制（不基于原型）</strong>：扩展运算符、<code>Object.assign</code>、深复制适用于属性拷贝，不涉及继承。</li>
<li><strong>混合方式</strong>：Mixin 用于组合多个对象的功能。</li>
</ul>
<p>在现代 JavaScript 中，推荐使用 <code>class extends</code>（清晰且符合 OOP 习惯）或函数式方法（简单场景），避免直接操作低级原型（如 <code>__proto__</code>）。你有具体的需求吗？我可以帮你选个最适合的方法实现！</p>
<h2 data-id="heading-37">.__proto__和.prototype有什么区别？我已经完全混乱了，我也不太理解构造函数</h2>
<p>别担心！我完全理解这些概念一开始可能会让人头脑一片迷雾，尤其是 <code>__proto__</code> 和 <code>prototype</code>，还有构造函数的运作方式。我会用最简单的方式一步步解释，尽量让你理清思路。如果有任何地方还是不明白，可以随时打断我！</p>
<hr>
<h4 data-id="heading-38">先从基础开始：什么是构造函数？</h4>
<p>咱们先把构造函数弄清楚，因为它是 <code>__proto__</code> 和 <code>prototype</code> 的基础。</p>
<h5 data-id="heading-39">构造函数的简单理解</h5>
<p>构造函数就是一个普通的函数，但它的目的是通过 <code>new</code> 关键字来创建对象。它像一个“模板”，告诉你怎么造出一个新对象。</p>
<ul>
<li><strong>例子</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 设置新对象的属性</span>
}

<span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
<span class="hljs-comment">// 相当于：</span>
  <span class="hljs-comment">/*
  1. const alice = {};
  2. alice.__proto__ = Person.prototype;
  3. Person.call(alice, "Alice");
  4. 返回 alice
  */</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Alice"</span>
</code></pre>
</li>
<li><strong>发生了什么</strong>：
<ol>
<li><code>new Person("Alice")</code> 创建了一个空对象 <code>{}</code>。</li>
<li>把这个空对象的“内部指针”指向 <code>Person.prototype</code>（这就是 <code>__proto__</code> 的作用，后面讲）。</li>
<li>把 <code>this</code> 绑定到这个新对象上，执行函数体（给对象加了 <code>name</code> 属性）。</li>
<li>返回这个新对象，赋值给 <code>alice</code>。</li>
</ol>
</li>
</ul>
<h5 data-id="heading-40">关键点</h5>
<ul>
<li>构造函数本身只是个函数，<code>new</code> 让它变成“造对象”的工具。</li>
<li>它会自动返回一个新对象（除非你手动返回其他东西）。</li>
</ul>
<hr>
<h4 data-id="heading-41"><code>__proto__</code> 和 <code>prototype</code> 的区别</h4>
<p>现在我们进入正题！这两个东西名字很像，但作用完全不同。</p>
<h5 data-id="heading-42">1. <code>prototype</code>（构造函数的属性）</h5>
<ul>
<li>
<p><strong>是什么</strong>：<code>prototype</code> 是构造函数的一个属性（一个对象），它定义了所有通过这个构造函数创建的实例可以共享的属性和方法。</p>
</li>
<li>
<p><strong>谁有它</strong>：只有函数（尤其是打算用作构造函数的函数）有 <code>prototype</code> 属性。</p>
</li>
<li>
<p><strong>作用</strong>：当你用 <code>new</code> 创建对象时，新对象的“原型”会指向这个 <code>prototype</code>。</p>
</li>
<li>
<p><strong>例子</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
alice.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Alice"</span>
</code></pre>
<ul>
<li>这里 <code>Person.prototype</code> 是一个对象，里面放了 <code>sayHello</code> 方法。</li>
<li><code>alice</code> 能调用 <code>sayHello</code>，因为它的“原型”指向了 <code>Person.prototype</code>。</li>
</ul>
</li>
<li>
<p><strong>小结</strong>：<code>prototype</code> 是构造函数的“蓝图”，决定了实例能继承什么。</p>
</li>
</ul>
<h5 data-id="heading-43">2. <code>__proto__</code>（对象的内部属性）</h5>
<ul>
<li>
<p><strong>是什么</strong>：<code>__proto__</code> 是每个对象都有的一个隐藏属性（内部指针），它指向这个对象的原型（也就是它继承的那个对象）。</p>
</li>
<li>
<p><strong>谁有它</strong>：所有对象（包括普通对象、数组、函数等）都有 <code>__proto__</code>。</p>
</li>
<li>
<p><strong>作用</strong>：当你访问一个对象的属性或方法时，如果对象本身没有，JS 会通过 <code>__proto__</code> 去原型上找。</p>
</li>
<li>
<p><strong>例子</strong>（接上面的代码）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
</code></pre>
<ul>
<li><code>alice.__proto__</code> 指向 <code>Person.prototype</code>，所以 <code>alice</code> 能用 <code>sayHello</code>。</li>
<li>如果你在 <code>alice</code> 上找不到某个属性，JS 会顺着 <code>__proto__</code> 去 <code>Person.prototype</code> 找。</li>
</ul>
</li>
<li>
<p><strong>小结</strong>：<code>__proto__</code> 是对象和它的原型之间的“连接线”。</p>
</li>
</ul>
<hr>
<h4 data-id="heading-44">用图来理清关系</h4>
<p>假设有以下代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};
<span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
</code></pre>
<ul>
<li><strong>关系图</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Person</span> (函数)
   |
   | .<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> (对象)
   |    ├── <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>
   |    └── <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>
   |
alice (对象)
   |
   | .<span class="hljs-property">__proto__</span> 指向 <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
   |
   └── <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span>
</code></pre>
</li>
<li><strong><code>Person.prototype</code></strong> 是 <code>Person</code> 的属性，定义了共享的方法。</li>
<li><strong><code>alice.__proto__</code></strong> 是 <code>alice</code> 的内部指针，指向 <code>Person.prototype</code>。</li>
</ul>
<hr>
<h4 data-id="heading-45">再加点例子巩固</h4>
<h5 data-id="heading-46">示例 1：访问属性</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Woof!"</span>);
};

<span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"Buddy"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-property">name</span>);    <span class="hljs-comment">// "Buddy"（直接在 myDog 上）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());  <span class="hljs-comment">// "Woof!"（从 myDog.__proto__ 找到）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
</code></pre>
<h5 data-id="heading-47">示例 2：原型链</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> animal = {
    <span class="hljs-attr">eat</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Eating..."</span>);
    }
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal; <span class="hljs-comment">// 设置原型（继承 animal）</span>

<span class="hljs-keyword">const</span> myCat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">"Whiskers"</span>);
myCat.<span class="hljs-title function_">eat</span>(); <span class="hljs-comment">// "Eating..."（从 myCat.__proto__ 找到）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCat.<span class="hljs-property">__proto__</span> === animal); <span class="hljs-comment">// true</span>
</code></pre>
<hr>
<h4 data-id="heading-48">常见困惑解答</h4>
<ol>
<li>
<p><strong>为什么我看不到 <code>__proto__</code>？</strong></p>
<ul>
<li>它是内部属性，不是直接定义的。你可以用 <code>Object.getPrototypeOf(obj)</code> 替代 <code>__proto__</code>，更标准：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(alice) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><code>__proto__</code> 是历史遗留写法，不推荐直接用。</li>
</ul>
</li>
<li>
<p><strong>普通函数有 <code>prototype</code> 吗？</strong></p>
<ul>
<li>是的，所有函数都有 <code>prototype</code>，但只有用作构造函数时才有用：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">justFunction</span>(<span class="hljs-params"></span>) {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(justFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 存在，是个对象</span>
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>对象有 <code>prototype</code> 吗？</strong></p>
<ul>
<li>没有！普通对象只有 <code>__proto__</code>，没有 <code>prototype</code>。只有函数才有 <code>prototype</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 data-id="heading-49">总结：<strong>proto</strong> vs prototype</h4>























<table><thead><tr><th>属性</th><th>谁拥有它</th><th>作用</th><th>示例值</th></tr></thead><tbody><tr><td><code>prototype</code></td><td>函数（构造函数）</td><td>定义实例可以继承的属性和方法</td><td><code>Person.prototype</code></td></tr><tr><td><code>__proto__</code></td><td>所有对象</td><td>指向对象的原型（连接原型链）</td><td><code>alice.__proto__</code></td></tr></tbody></table>
<ul>
<li><strong><code>prototype</code></strong>：是构造函数的“工具箱”，给所有实例共享用。</li>
<li><strong><code>__proto__</code></strong>：是实例的“导航箭头”，指着它的原型。</li>
</ul>
<hr>
<h4 data-id="heading-50">再回到构造函数</h4>
<p>构造函数的核心就是通过 <code>new</code>：</p>
<ul>
<li>创建一个新对象。</li>
<li>把新对象的 <code>__proto__</code> 设为构造函数的 <code>prototype</code>。</li>
<li>初始化对象（用 <code>this</code>）。</li>
<li>返回对象。</li>
</ul>
<p>如果你还是觉得晕，我可以用更生活化的比喻（比如工厂和工人）再讲一遍，或者你告诉我具体哪里卡住了，我针对性解释！怎么样？有没有稍微清晰一点了？呜呜不要紧，我们慢慢来！</p>
<h2 data-id="heading-51">形象生动讲解</h2>
<p>好的！这次我用一个更生活化、更形象的比喻来讲解 <code>__proto__</code> 和 <code>prototype</code>，还有构造函数的运作方式。想象我们在一个“魔法玩具工厂”里，目标是制造会说话的小机器人玩具。让我们一步步走进这个场景，把这些概念变得生动起来！</p>
<hr>
<h4 data-id="heading-52">场景设定：魔法玩具工厂</h4>
<ul>
<li>你是工厂的老板，想批量生产会说话的小机器人。</li>
<li>每个机器人都有自己的名字（个性化属性），还能说“Hello”（共享技能）。</li>
<li>工厂里有一些工具和角色，我们用它们来解释构造函数、<code>prototype</code> 和 <code>__proto__</code>。</li>
</ul>
<hr>
<h4 data-id="heading-53">1. 构造函数：工厂的“机器人制造机”</h4>
<ul>
<li>
<p><strong>比喻</strong>：构造函数是一个“机器人制造机”。你把原材料（比如名字）放进去，按下“启动”（<code>new</code>），它就吐出一个新的机器人。</p>
</li>
<li>
<p><strong>形象化</strong>：</p>
<ul>
<li>机器的名字叫 <code>Person</code>。</li>
<li>你输入“Alice”作为原料，按下“启动”，机器就造出一个名叫 Alice 的机器人。</li>
</ul>
</li>
<li>
<p><strong>代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 给新机器人贴上名字标签</span>
}

<span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>); <span class="hljs-comment">// 按下“启动”按钮</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Alice"</span>
</code></pre>
</li>
<li>
<p><strong>发生了什么</strong>：</p>
<ol>
<li>工厂启动，制造机创建一个空壳机器人（<code>{}</code>）。</li>
<li>机器给这个空壳贴上“Alice”的名字标签（<code>this.name = name</code>）。</li>
<li>最后把成品机器人交给你（返回对象）。</li>
</ol>
</li>
<li>
<p><strong>关键点</strong>：这个“制造机”（<code>Person</code>）本身不会说话，但它知道怎么给机器人装上零件。它还有个秘密武器——“技能蓝图”（这就是 <code>prototype</code>）。</p>
</li>
</ul>
<hr>
<h4 data-id="heading-54">2. <code>prototype</code>：技能蓝图</h4>
<ul>
<li>
<p><strong>比喻</strong>：<code>prototype</code> 是工厂里的“技能蓝图”，一张写着“所有机器人都会的技能”的图纸。制造机（<code>Person</code>）会把这张图纸交给每一个新机器人，让它们学会蓝图上的技能。</p>
</li>
<li>
<p><strong>形象化</strong>：</p>
<ul>
<li>你在蓝图上写下：“所有机器人都会说 Hello”。</li>
<li>每个机器人出厂时，都会带上这张蓝图的“使用权”。</li>
</ul>
</li>
<li>
<p><strong>代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>);
alice.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Alice"</span>
</code></pre>
</li>
<li>
<p><strong>发生了什么</strong>：</p>
<ul>
<li><code>Person.prototype</code> 是制造机的一个特殊抽屉，里面放着蓝图。</li>
<li>蓝图上写着 <code>sayHello</code> 的技能（一个函数）。</li>
<li>每个机器人（比如 <code>alice</code>）出厂时，制造机会偷偷告诉它：“如果你需要技能，去我的蓝图上看。”</li>
</ul>
</li>
<li>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>prototype</code> 是制造机（构造函数）的财产，不是机器人自己的东西。</li>
<li>所有用 <code>Person</code> 造出来的机器人都共享同一张蓝图，节省工厂资源。</li>
</ul>
</li>
</ul>
<hr>
<h4 data-id="heading-55">3. <code>__proto__</code>：机器人的“技能导航仪”</h4>
<ul>
<li>
<p><strong>比喻</strong>：<code>__proto__</code> 是每个机器人身上装的一个小导航仪，告诉它：“如果你自己不会什么技能，就去蓝图（<code>prototype</code>）那儿找。”</p>
</li>
<li>
<p><strong>形象化</strong>：</p>
<ul>
<li>小机器人 Alice 想要说“Hello”，但它自己没装这个技能。</li>
<li>它打开导航仪（<code>__proto__</code>），导航仪指向工厂的蓝图（<code>Person.prototype</code>）。</li>
<li>在蓝图上找到 <code>sayHello</code>，然后用自己的名字喊出来。</li>
</ul>
</li>
<li>
<p><strong>代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
alice.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Alice"</span>
</code></pre>
</li>
<li>
<p><strong>发生了什么</strong>：</p>
<ul>
<li><code>alice</code> 是工厂造出来的机器人，它的 <code>__proto__</code> 导航仪指向 <code>Person.prototype</code>。</li>
<li>当你叫 <code>alice.sayHello()</code> 时：
<ol>
<li>Alice 发现自己没这个技能。</li>
<li>它用导航仪查到蓝图（<code>Person.prototype</code>）。</li>
<li>在蓝图上找到 <code>sayHello</code>，然后用自己的名字（<code>this.name</code>）执行。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>__proto__</code> 是机器人（对象）自己的东西，指向它的“出身蓝图”。</li>
<li>它像一根绳子，把机器人和工厂的蓝图连起来。</li>
</ul>
</li>
</ul>
<hr>
<h4 data-id="heading-56">工厂的完整运作流程</h4>
<ol>
<li><strong>老板下单</strong>：<code>const alice = new Person("Alice")</code>。
<ul>
<li>工厂启动制造机（<code>Person</code>），输入原料“Alice”。</li>
</ul>
</li>
<li><strong>制造机器人</strong>：
<ul>
<li>制造机造一个空壳（<code>{}</code>）。</li>
<li>给空壳装上名字“Alice”（<code>this.name = name</code>）。</li>
<li>把导航仪（<code>__proto__</code>）调到指向蓝图（<code>Person.prototype</code>）。</li>
</ul>
</li>
<li><strong>交付</strong>：成品机器人 <code>alice</code> 出厂，能用蓝图上的技能（<code>sayHello</code>）。</li>
</ol>
<ul>
<li><strong>结果</strong>：
<ul>
<li><code>alice.name</code> 是它自己的零件（"Alice"）。</li>
<li><code>alice.sayHello</code> 是通过导航仪从蓝图借来的技能。</li>
</ul>
</li>
</ul>
<hr>
<h4 data-id="heading-57">再加个场景：继承</h4>
<ul>
<li>
<p><strong>比喻</strong>：工厂升级了，想造一种会跑的机器人（<code>Runner</code>），它继承了普通机器人的技能。</p>
</li>
<li>
<p><strong>代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Runner</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用 Person 的零件</span>
}
<span class="hljs-title class_">Runner</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 复制蓝图</span>
<span class="hljs-title class_">Runner</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">" is running"</span>);
};

<span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(<span class="hljs-string">"Bob"</span>);
bob.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "Hello, Bob"（从 Person 的蓝图）</span>
bob.<span class="hljs-title function_">run</span>();      <span class="hljs-comment">// "Bob is running"（自己的蓝图）</span>
</code></pre>
</li>
<li>
<p><strong>形象化</strong>：</p>
<ul>
<li><code>Runner</code> 是新款制造机，它先借用 <code>Person</code> 的零件（名字）。</li>
<li>它复制了 <code>Person</code> 的蓝图（<code>Object.create</code>），然后加了自己的技能“跑步”。</li>
<li><code>bob</code> 的导航仪（<code>__proto__</code>）指向 <code>Runner.prototype</code>，而 <code>Runner.prototype</code> 的导航仪又指向 <code>Person.prototype</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 data-id="heading-58">总结：角色分工</h4>
<ul>
<li><strong>构造函数（<code>Person</code>）</strong>：工厂的制造机，负责造机器人。</li>
<li><strong><code>prototype</code></strong>：制造机的技能蓝图，写着共享技能（<code>sayHello</code>）。</li>
<li><strong><code>__proto__</code></strong>：每个机器人的导航仪，指向它的蓝图。</li>
</ul>
<h5 data-id="heading-59">生活化对比</h5>

























<table><thead><tr><th>概念</th><th>工厂比喻</th><th>作用</th></tr></thead><tbody><tr><td>构造函数</td><td>制造机</td><td>造出新机器人，装上零件</td></tr><tr><td><code>prototype</code></td><td>技能蓝图</td><td>定义所有机器人能共享的技能</td></tr><tr><td><code>__proto__</code></td><td>导航仪</td><td>告诉机器人去哪找技能</td></tr></tbody></table>
<hr>
<h4 data-id="heading-60">检查一下清楚了吗？</h4>
<ul>
<li>想象 <code>alice</code> 是一个小机器人，它的名字是“Alice”，它不会说话，但能通过导航仪（<code>__proto__</code>）找到工厂蓝图（<code>Person.prototype</code>）上的 <code>sayHello</code>。</li>
<li>如果你问 <code>alice</code>：“你是谁造的？”它会说：“<code>Person</code> 制造机造的，我的技能蓝图在它那儿！”</li>
</ul>
<p>还有哪里觉得模糊吗？或者想让我再举个例子（比如造个会跳舞的机器人）？这次有没有更形象一点呀？</p>
<h2 data-id="heading-61">Person.call(this, name) 什么意思？</h2>
<blockquote>
<ul>
<li>Person.call(this, name);其实就是运行这个Person机器，但是用我给你的“this”来生产对吧。</li>
<li>对！完全正确！</li>
</ul>
</blockquote>
<p>Person.call(this, name) 的作用</p>
<ul>
<li>比喻：Person.call(this, name) 就像你拿起电话，打给“Person 制造机”，说：“嘿，我这儿有个空壳机器人（this），你帮我给它装上名字零件（name），但别按你的完整流程走，我只借你装零件的步骤！”</li>
<li>形象化：
“Runner 制造机”启动，造出一个空壳机器人（比如 bob）。
它把这个空壳（this）交给“Person 制造机”，说：“给它装上名字‘Bob’。”
“Person 制造机”执行它的逻辑（this.name = name），把名字装到空壳上，然后完事。</li>
</ul>
<h2 data-id="heading-62">call 、bind、apply</h2>
<p>好的！让我来详细介绍一下 <code>call</code> 方法，顺便带上你提到的 <code>bind</code> 方法，以及它们跟 <code>apply</code> 的关系（因为这三兄弟经常一起出现）。我会尽量用生动的方式解释，结合我们之前的“魔法玩具工厂”比喻，让你轻松理解它们的用途和区别！</p>
<hr>
<h4 data-id="heading-63">背景：函数的“魔法按钮”</h4>
<p>在 JavaScript 中，函数不仅仅是代码块，它们还有一些魔法按钮（方法），可以改变函数的执行方式。这些方法绑定在所有函数上，来自 <code>Function.prototype</code>，包括 <code>call</code>、<code>apply</code> 和 <code>bind</code>。它们的核心作用是<strong>控制函数中的 <code>this</code> 和参数</strong>。</p>
<hr>
<h4 data-id="heading-64">1. <code>call</code> 方法</h4>
<h5 data-id="heading-65">是什么？</h5>
<ul>
<li><strong><code>call</code> 是一个函数方法</strong>，可以让你手动指定函数中的 <code>this</code> 指向，并且立即执行这个函数。</li>
<li><strong>语法</strong>：<code>function.call(thisArg, arg1, arg2, ...)</code>
<ul>
<li><code>thisArg</code>：你想让 <code>this</code> 指向的对象。</li>
<li><code>arg1, arg2, ...</code>：传递给函数的参数（逐个列出）。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-66">比喻：工厂的“电话借用服务”</h5>
<ul>
<li>想象你在“Runner 制造机”旁边，有个电话。你拨通“Person 制造机”（<code>Person</code> 函数）的号码，说：“我这儿有个空壳机器人（<code>this</code>），你帮我执行你的逻辑，把名字装上吧！”</li>
<li>“Person 制造机”接到电话，用你的空壳（指定的 <code>this</code>）执行它的代码。</li>
</ul>
<h5 data-id="heading-67">示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Person says: My name is "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Runner</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用 Person 的逻辑</span>
}

<span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(<span class="hljs-string">"Bob"</span>); <span class="hljs-comment">// "Person says: My name is Bob"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bob.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Bob"</span>
</code></pre>
<ul>
<li><strong>发生了什么</strong>：
<ul>
<li><code>Runner</code> 造了个空壳（<code>this</code> 是 <code>{}</code>）。</li>
<li>用 <code>call</code> 打电话给 <code>Person</code>，说：“用我的空壳，装上名字‘Bob’。”</li>
<li><code>Person</code> 执行，把 <code>this.name = "Bob"</code> 装到 <code>bob</code> 上。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-68">用处</h5>
<ul>
<li><strong>借用功能</strong>：像上面这样，复用其他函数的逻辑。</li>
<li><strong>控制 <code>this</code></strong>：在普通调用中，<code>this</code> 可能指向 <code>window</code> 或 <code>undefined</code>（严格模式），<code>call</code> 让你指定它。</li>
</ul>
<hr>
<h4 data-id="heading-69">2. <code>bind</code> 方法</h4>
<h5 data-id="heading-70">是什么？</h5>
<ul>
<li><strong><code>bind</code> 也是函数方法</strong>，<strong>但它不会立即执行函数，而是返回一个新函数，这个新函数的 <code>this</code> 被永久绑定到你指定的对象。</strong></li>
<li><strong>语法</strong>：<code>function.bind(thisArg, arg1, arg2, ...)</code>
<ul>
<li>返回一个新函数，<code>this</code> 固定为 <code>thisArg</code>。</li>
<li>可以预先绑定部分参数（柯里化）。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-71">比喻：工厂的“遥控器定制”</h5>
<ul>
<li>想象你不想每次都打电话给“Person 制造机”，而是定制一个遥控器（新函数）。这个遥控器已经设定好：无论在哪按下按钮，<code>this</code> 永远指向你指定的机器人。</li>
<li>你拿着遥控器，按下按钮时才会执行。</li>
</ul>
<h5 data-id="heading-72">示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}

<span class="hljs-keyword">const</span> robot = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Robo"</span> };
<span class="hljs-keyword">const</span> boundPerson = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">bind</span>(robot); <span class="hljs-comment">// 返回新函数，this 绑定到 robot</span>
<span class="hljs-title function_">boundPerson</span>(<span class="hljs-string">"Alice"</span>); <span class="hljs-comment">// "Hello, Robo"（name 参数被忽略，因为 this 已绑定）</span>
</code></pre>
<ul>
<li><strong>发生了什么</strong>：
<ul>
<li><code>bind</code> 创建了一个新函数 <code>boundPerson</code>，它的 <code>this</code> 永久指向 <code>robot</code>。</li>
<li>调用时，<code>this.name</code> 用的是 <code>robot.name</code>，传入的 "Alice" 没起作用（除非函数逻辑用参数）。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-73">用处</h5>
<ul>
<li><strong>固定 <code>this</code></strong>：比如事件监听器中，防止 <code>this</code> 乱跑：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Obj"</span>,
    <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    }
};
<span class="hljs-keyword">const</span> boundSay = obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">bind</span>(obj);
<span class="hljs-built_in">setTimeout</span>(boundSay, <span class="hljs-number">1000</span>); <span class="hljs-comment">// "Obj"（不绑定的话，this 可能是 window）</span>
</code></pre>
</li>
<li><strong>预设参数</strong>：提前锁定部分参数：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-keyword">const</span> add5 = add.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// this 无关，绑定 a=5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 8</span>
</code></pre>
</li>
</ul>
<hr>
<h4 data-id="heading-74">3. <code>apply</code> 方法（顺便介绍）</h4>
<h5 data-id="heading-75">是什么？</h5>
<ul>
<li><strong><code>apply</code> 和 <code>call</code> 很像</strong>，也是立即执行函数并指定 <code>this</code>，但参数以数组形式传递。</li>
<li><strong>语法</strong>：<code>function.apply(thisArg, [args])</code>
<ul>
<li><code>thisArg</code>：指定的 <code>this</code>。</li>
<li><code>[args]</code>：参数数组。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-76">比喻：工厂的“批量订单”</h5>
<ul>
<li>你还是打电话给“Person 制造机”，但这次不是一个个零件报过去，而是递过去一张清单（数组），说：“按这个清单装零件！”</li>
</ul>
<h5 data-id="heading-77">示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Runner</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [name, age]); <span class="hljs-comment">// 用数组传递参数</span>
}

<span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bob.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Bob"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bob.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 25</span>
</code></pre>
<ul>
<li><strong>发生了什么</strong>：
<ul>
<li><code>apply</code> 把 <code>[name, age]</code> 展开，像 <code>this.name = name; this.age = age</code> 一样执行。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-78">用处</h5>
<ul>
<li><strong>处理数组参数</strong>：比如找最大值：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, numbers)); <span class="hljs-comment">// 8</span>
</code></pre>
</li>
</ul>
<hr>
<h4 data-id="heading-79">三兄弟对比</h4>

































<table><thead><tr><th>方法</th><th>执行时机</th><th>参数形式</th><th>返回值</th><th>比喻</th></tr></thead><tbody><tr><td><code>call</code></td><td>立即执行</td><td>逐个参数</td><td>函数执行结果</td><td>电话借用服务</td></tr><tr><td><code>apply</code></td><td>立即执行</td><td>参数数组</td><td>函数执行结果</td><td>批量订单清单</td></tr><tr><td><code>bind</code></td><td>不执行，返回新函数</td><td>逐个参数（可预设）</td><td>新函数</td><td>定制遥控器</td></tr></tbody></table>
<h5 data-id="heading-80">图解工厂场景</h5>
<ul>
<li><strong><code>call</code></strong>：你喊：“Person，帮我装名字‘Bob’，现在就干！”（马上装好）</li>
<li><strong><code>apply</code></strong>：你递清单：“Person，按 [‘Bob’, 25] 装零件，现在开工！”（马上装好）</li>
<li><strong><code>bind</code></strong>：你定制遥控器：“Person，锁定这个机器人，以后我按按钮你就装名字。”（等你按）</li>
</ul>
<hr>
<h4 data-id="heading-81">回到你的问题</h4>
<ul>
<li><strong><code>Person.call</code></strong>：我们之前用它让“Runner 制造机”借用“Person”的装名字功能，直接把名字装到 <code>bob</code> 上。</li>
<li><strong><code>bind</code></strong>：如果你用 <code>Person.bind(this)(name)</code>，会返回一个绑定了 <code>this</code> 的新函数，但不会立即执行，得再调用一次。</li>
</ul>
<h5 data-id="heading-82">对比代码</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Runner</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 立即装名字</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">RunnerBind</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">const</span> bound = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 只定制，不执行</span>
    <span class="hljs-title function_">bound</span>(name); <span class="hljs-comment">// 手动再按一下按钮</span>
}

<span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(<span class="hljs-string">"Bob"</span>);      <span class="hljs-comment">// "Bob"（call 直接生效）</span>
<span class="hljs-keyword">const</span> bob2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnerBind</span>(<span class="hljs-string">"Bob"</span>); <span class="hljs-comment">// "Bob"（bind 需两步）</span>
</code></pre>
<hr>
<h4 data-id="heading-83">总结</h4>
<ul>
<li><strong><code>call</code></strong>：借用功能，马上干活，适合继承零件（像 <code>Runner</code> 借 <code>Person</code>）。</li>
<li><strong><code>bind</code></strong>：定制一个新函数，随时用，常用于固定 <code>this</code> 或预设参数。</li>
<li><strong>额外福利 <code>apply</code></strong>：和 <code>call</code> 类似，但爱用数组传参。</li>
</ul></div></div>