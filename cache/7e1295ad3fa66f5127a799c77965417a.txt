
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/D1TA/p/18904007" title="发布于 2025-05-30 11:39">
    <span role="heading" aria-level="2">缓冲区溢出全解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2839487/202505/2839487-20250530113912291-475489185.png" alt="缓冲区溢出全解" class="desc_img">
        自此，缓冲区溢出再也不是看不懂的领域！
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="缓冲区溢出概述">缓冲区溢出概述</h2>
<p>缓冲区溢出（Buffer Overflow）是一种经典的安全漏洞，当程序未对输入长度进行检查时，多余的数据会覆盖相邻内存区域，进而篡改程序控制流，达到执行任意代码的目的。</p>
<hr>
<h2 id="1-栈stack与堆heap">1. 栈（Stack）与堆（Heap）</h2>
<ul>
<li><strong>栈 (Stack)</strong>：后进先出（LIFO）结构，用于管理函数调用。每次调用都会创建独立栈帧，包含函数参数、返回地址、保存的寄存器（如 EBP）和局部变量。</li>
<li><strong>堆 (Heap)</strong>：用于动态分配内存，地址从低向高增长，需手动分配和释放。堆与栈分区相互独立。</li>
</ul>
<hr>
<h2 id="2-字节序endianness">2. 字节序（Endianness）</h2>
<p>在多字节系统中：</p>
<ul>
<li><strong>大端序 (Big-Endian)</strong>：高位字节存储在低地址，常见于网络协议（如 IP 头）。</li>
<li><strong>小端序 (Little-Endian)</strong>：低位字节存储在低地址，x86、ARM 默认采用此模式。</li>
</ul>
<p><strong>示例</strong>：32 位地址 <code>0xbffffb80</code> 在小端系统中的存储顺序：</p>
<pre><code>内存地址增长 → 低地址： 0x80 0xfb 0xff 0xbf
</code></pre>
<p>在利用漏洞时，必须将地址按小端序写入载荷（如 <code>\x80\xfb\xff\xbf</code>），否则会跳转到错误地址。</p>
<hr>
<h2 id="3-x86-栈帧布局与函数调用">3. x86 栈帧布局与函数调用</h2>
<pre><code class="language-asm">高地址
+------------------+
| 参数 n           | ← 调用者按右→左顺序压栈
| ...              |
+------------------+
| 返回地址 (EIP)   | ← `call` 指令自动压栈
+------------------+
| 旧 EBP           | ← `push ebp`
+------------------+ ← 新 EBP 指向此处
| 局部变量         | ← `sub esp, N`
| ...              |
低地址
</code></pre>
<p><strong>调用流程</strong>：</p>
<ol>
<li>调用者按反序压入参数。</li>
<li><code>call</code> 将返回地址压栈，并跳转到函数入口。</li>
<li><code>push ebp; mov ebp, esp; sub esp, N</code> 设置新栈帧。</li>
<li><code>leave; ret</code> 恢复 EBP 并将返回地址弹栈到 EIP。</li>
</ol>
<hr>
<h2 id="4-缓冲区溢出攻击流程">4. 缓冲区溢出攻击流程</h2>
<p>以以下易受攻击函数为例：</p>
<pre><code class="language-c">void vulnerable(char *input) {
    char buffer[256];
    strcpy(buffer, input); // 未检查边界
}
</code></pre>
<ol>
<li>当 <code>input</code> 超过 256 字节，多余数据向高地址写入，依次覆盖：旧 EBP → 返回地址 → 参数区。</li>
<li>覆盖返回地址后，执行 <code>ret</code> 时，EIP 跳转到攻击者指定地址。</li>
<li>若该地址指向包含 shellcode 的输入区，即可实现任意代码执行。</li>
</ol>
<hr>
<h2 id="5-构造利用载荷">5. 构造利用载荷</h2>
<pre><code class="language-bash">./vuln $(python -c 'print "A"*268 + "\x80\xfb\xff\xbf" + "\x90"*20 + SHELLCODE')
</code></pre>
<ul>
<li><strong>偏移量</strong>：通过 GDB 找到 EIP 覆盖点，此处为 268。</li>
<li><strong>小端地址</strong>：<code>\x80\xfb\xff\xbf</code> 对应内存地址 <code>0xbffffb80</code>。</li>
<li><strong>NOP 雪橇</strong>：<code>\x90</code> 填充，覆盖返回地址与 shellcode 之间的区域，扩大跳板范围。</li>
</ul>
<hr>
<h2 id="6-获取-esp-地址的方法">6. 获取 ESP 地址的方法</h2>
<h3 id="方法一eip-覆盖测试">方法一：EIP 覆盖测试</h3>
<ol>
<li><code>$(python -c 'print "A"*268 + "BBBB"')</code>，观察 GDB 崩溃时：返回地址是否被 <code>0x42424242</code>（<code>BBBB</code>）替换。</li>
<li>若匹配，说明偏移 268 后正好覆盖返回地址。</li>
</ol>
<h3 id="方法二esp-跳板测试">方法二：ESP 跳板测试</h3>
<ol>
<li>
<p>在偏移基础上继续追加 NOP 和标记：</p>
<pre><code class="language-bash">$(python -c 'print "A"*268 + "BBBB" + "C"*20')
</code></pre>
</li>
<li>
<p>当 EIP 被 <code>BBBB</code> 覆盖后，程序崩溃时返回地址已弹栈，GDB 显示 ESP 指向 <code>CCCC...</code> 区域，即 shellcode 起始处。</p>
</li>
<li>
<p>该地址即为跳转目标，可按小端序写入返回地址。</p>
</li>
</ol>
<p><strong>注意</strong>：多次测试时，若输入长度变化（如从 272 → 292 字节），操作系统会为对齐在更低地址分配新的栈空间，导致 ESP 地址出现偏移差异。</p>
<hr>
<h2 id="7-nop-雪橇与其作用范围">7. NOP 雪橇与其作用范围</h2>
<ul>
<li><strong>目的</strong>：在返回地址到 shellcode 区间填充 <code>\x90</code>，形成 <code>NOP</code> 滑板，确保 EIP 落点可滑入真实 shellcode。</li>
<li><strong>长度</strong>：通常几十到数百字节，根据偏移范围动态调整。</li>
</ul>
<hr>
<h2 id="8-坏字符测试bad-character-testing">8. 坏字符测试（Bad Character Testing）</h2>
<ol>
<li>
<p>使用脚本生成连续字节串：</p>
<pre><code class="language-bash">python -c 'print "".join([chr(i) for i in range(1,256)])'
</code></pre>
</li>
<li>
<p>将该字符串传入程序，在 GDB 中查看内存（<code>x/256x $esp</code> 或 <code>x/256b $esp</code>）。</p>
</li>
<li>
<p>若发现某字节丢失或被解释异常，则需将其从 payload 中排除，直到所有字节都能正确通过。</p>
</li>
</ol>
<hr>
<h2 id="9-常见调用约定对比">9. 常见调用约定对比</h2>
<table>
<thead>
<tr>
<th>约定</th>
<th>参数顺序</th>
<th>清理者</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdecl</td>
<td>右→左</td>
<td>调用者</td>
<td>C 默认</td>
</tr>
<tr>
<td>stdcall</td>
<td>右→左</td>
<td>被调用者</td>
<td>Windows API</td>
</tr>
<tr>
<td>fastcall</td>
<td>前几个通过寄存器</td>
<td>被调用者</td>
<td>性能优化</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="10-x86-与-x64-区别">10. x86 与 x64 区别</h2>
<ul>
<li><strong>寄存器宽度</strong>：x86 为 32 位，x64 为 64 位。</li>
<li><strong>新增寄存器</strong>：x64 增加 R8–R15。</li>
<li><strong>参数传递</strong>：x64 多数通过寄存器，栈负载减少。</li>
</ul>
<hr>
<p><em>以上内容整合了栈与堆、字节序、栈帧结构、利用流程、偏移与跳板测试、NOP 雪橇、坏字符测试及调用约定差异，建议结合 GDB 工具逐步验证。</em></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.028454096769676" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-30 11:39">2025-05-30 11:39</span>&nbsp;
<a href="https://www.cnblogs.com/D1TA">D1TAsec</a>&nbsp;
阅读(<span id="post_view_count">208</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18904007);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18904007', targetLink: 'https://www.cnblogs.com/D1TA/p/18904007', title: '缓冲区溢出全解' })">举报</a>
</div>
        