
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19055246" title="发布于 2025-08-24 11:15">
    <span role="heading" aria-level="2">Token续期的5种方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>今天我们来聊聊一个看似简单却让无数开发者栽跟头的问题——<strong>Token续期</strong>。</p>
<p>你以为Token续期只是重置时间？90%的系统安全漏洞由此而生！</p>
<p>当用户正在提交重要表单时突然跳转到登录页面，或者系统在高峰期因Token并发刷新而崩溃，这些问题的根源往往在于<strong>Token续期策略设计不当</strong>。</p>
<h2 id="一token续期的本质">一、Token续期的本质</h2>
<p>Token续期不是简单的时间重置，而是<strong>安全、用户体验和系统性能的三方博弈</strong>。</p>
<p>我们先看一个典型事故：</p>
<pre><code class="language-java">// 错误案例：简单过期的Token检查
public boolean validateToken(String token) {
    return JwtUtil.getExpiration(token).after(new Date());
}
</code></pre>
<p>这种实现会导致：</p>
<ol>
<li>用户操作中断（Token突然过期）</li>
<li>安全风险（旧Token继续有效）</li>
<li>并发问题（多个请求同时触发刷新）</li>
</ol>
<h3 id="token续期的三大核心问题">Token续期的三大核心问题</h3>
<ol>
<li><strong>何时续期</strong>：提前多久刷新最合理？</li>
<li><strong>如何续期</strong>：单Token还是双Token？有状态还是无状态？</li>
<li><strong>安全防控</strong>：如何防止令牌劫持和并发风暴？</li>
</ol>
<p>下面我跟大家一起聊聊工作中最常用的5种主流方案，希望对你会有所帮助。</p>
<h2 id="二单token方案">二、单Token方案</h2>
<h3 id="21-基础实现与致命缺陷">2.1 基础实现与致命缺陷</h3>
<pre><code class="language-java">public String refreshToken(String oldToken) {
    String username = JwtUtil.parseUsername(oldToken);
    return JwtUtil.generateToken(username, 30 * 60); // 直接生成新Token
}
</code></pre>
<p><strong>三大致命缺陷</strong>：</p>
<ol>
<li>旧Token在有效期内依然可用（安全黑洞）</li>
<li>多个请求同时触发刷新会导致多个有效Token并存（并发灾难）</li>
<li>无法强制下线用户（状态失控）</li>
</ol>
<h3 id="22-黑名单优化方案">2.2 黑名单优化方案</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/e805e653-be78-48a4-85fb-09c843ecf45d.png" class="lazyload"></p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-java">public String safeRefresh(String oldToken) {
    // 旧Token加入黑名单（有效期比Token长5分钟）
    redis.setex("blacklist:"+oldToken, "1", 35 * 60); 
    
    String username = JwtUtil.parseUsername(oldToken);
    String newToken = JwtUtil.generateToken(username, 30 * 60);
    return newToken;
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>内部低安全系统</li>
<li>短期活动页面</li>
<li>快速原型开发</li>
</ul>
<h2 id="三双token方案">三、双Token方案</h2>
<h3 id="31-核心架构设计">3.1 核心架构设计</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/72377f7e-82b6-404b-a52d-bb5757b9d726.png" class="lazyload"></p>
<h3 id="32-安全增强三验证机制">3.2 安全增强：三验证机制</h3>
<pre><code class="language-java">public TokenPair refreshTokens(String refreshToken) {
    // 1. JWT签名验证
    if (!JwtUtil.verifySignature(refreshToken)) {
        throw new SecurityException("非法令牌");
    }
    
    // 2. 状态令牌验证
    String stateToken = extractStateToken(refreshToken);
    if (!redis.exists("state_token:" + stateToken)) {
        throw new SecurityException("令牌已失效");
    }
    
    // 3. 设备绑定验证
    String deviceId = getDeviceIdFromRequest();
    if (!deviceId.equals(redis.get("bind_device:" + stateToken))) {
        throw new SecurityException("设备变更需重新登录");
    }
    
    return generateNewTokenPair(refreshToken);
}
</code></pre>
<h3 id="33-并发控制分布式锁方案">3.3 并发控制：分布式锁方案</h3>
<pre><code class="language-java">public TokenPair safeRefresh(String refreshToken) {
    String lockKey = "refresh_lock:" + refreshToken;
    RLock lock = redissonClient.getLock(lockKey);
    
    try {
        if (lock.tryLock(2, 5, TimeUnit.SECONDS)) {
            return doRefresh(refreshToken);
        }
        throw new BusyException("系统繁忙，请重试");
    } finally {
        lock.unlock();
    }
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>金融系统</li>
<li>电商平台</li>
<li>企业级应用</li>
</ul>
<h2 id="四自动续期方案">四、自动续期方案</h2>
<h3 id="41-拦截器滑动窗口">4.1 拦截器+滑动窗口</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/2f3b8086-3e58-49f3-aba4-98350ee9e1c7.png" class="lazyload"></p>
<p><strong>智能阈值计算</strong>：</p>
<pre><code class="language-java">public boolean shouldRenew(Token token) {
    long remainTime = token.getExpireTime() - System.currentTimeMillis();
    long totalTime = token.getTotalValidTime();
    
    // 双阈值策略：绝对时间（5分钟）和相对时间（30%有效期）
    return remainTime &lt;= Math.min(5 * 60 * 1000, 0.3 * totalTime);
}
</code></pre>
<h3 id="42-redis缓存续期方案">4.2 Redis缓存续期方案</h3>
<pre><code class="language-java">public void autoRenewToken(String headerToken) {
    String cacheKey = "token_cache:" + headerToken;
    String cacheToken = redis.get(cacheKey);
    
    if (cacheToken == null) throw new TokenExpiredException("令牌已完全过期");
    
    if (JwtUtil.isAboutToExpire(cacheToken)) { 
        String newToken = generateNewToken();
        // 关键：Token更新但缓存Key不变
        redis.setex(cacheKey, newToken, 2 * 60 * 60);
        response.setHeader("X-New-Token", newToken);
    }
}
</code></pre>
<h3 id="43-gateway全局过滤器方案">4.3 Gateway全局过滤器方案</h3>
<pre><code class="language-java">@Component
@Order(-100)
public class TokenRenewFilter implements GlobalFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, Chain chain) {
        String token = extractToken(exchange.getRequest());
        
        if (renewService.isRenewRequired(token)) {
            String newToken = renewService.renewToken(token);
            exchange.getResponse().getHeaders().set("X-New-Token", newToken);
        }
        
        return chain.filter(exchange);
    }
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>微服务架构</li>
<li>前后端分离应用</li>
<li>高并发用户系统</li>
</ul>
<h2 id="五分布式环境特殊挑战">五、分布式环境特殊挑战</h2>
<h3 id="51-多设备会话管理">5.1 多设备会话管理</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/03d74d33-9304-4e5a-b512-9bb39ad1a196.png" class="lazyload"></p>
<p><strong>设备冲突解决方案</strong>：</p>
<pre><code class="language-java">public void handleLogin(User user, String deviceType) {
    String oldSessionKey = "user_devices:" + user.getId() + ":" + deviceType;
    String oldToken = redis.get(oldSessionKey);
    
    if (oldToken != null) {
        redis.del("token_cache:" + oldToken); // 使旧Token失效
    }
    
    String newToken = generateToken();
    redis.set(oldSessionKey, newToken);
}
</code></pre>
<h3 id="52-跨服务令牌验证">5.2 跨服务令牌验证</h3>
<pre><code class="language-java">public boolean validateTokenAcrossServices(String token) {
    // 1. 本地快速验证
    if (JwtUtil.verifyWithLocalKey(token)) return true;
    
    // 2. 查询认证中心
    return authCenterClient.validateToken(token);
}
</code></pre>
<h2 id="六五大方案对比">六、五大方案对比</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>安全性</th>
<th>用户体验</th>
<th>实现复杂度</th>
<th>适用场景</th>
<th>性能影响</th>
<th>典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单Token基础版</strong></td>
<td>★☆☆☆☆</td>
<td>★★☆☆☆</td>
<td>★☆☆☆☆</td>
<td>内部测试系统</td>
<td>低</td>
<td>原型开发</td>
</tr>
<tr>
<td><strong>单Token+黑名单</strong></td>
<td>★★☆☆☆</td>
<td>★★★☆☆</td>
<td>★★☆☆☆</td>
<td>低风险Web应用</td>
<td>中</td>
<td>企业内网</td>
</tr>
<tr>
<td><strong>双Token基础版</strong></td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
<td>常规Web/APP</td>
<td>中</td>
<td>电商平台</td>
</tr>
<tr>
<td><strong>双Token+三验证</strong></td>
<td>★★★★★</td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
<td>金融/支付系统</td>
<td>高</td>
<td>银行APP</td>
</tr>
<tr>
<td><strong>自动续期方案</strong></td>
<td>★★★★☆</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>高用户体验要求系统</td>
<td>中高</td>
<td>SAAS应用</td>
</tr>
</tbody>
</table>
<h2 id="七方案如何选型">七、方案如何选型？</h2>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/f4f0e923-85ca-436c-9745-248c50ecf4c9.png" class="lazyload"></p>
<h2 id="八最佳实践与避坑指南">八、最佳实践与避坑指南</h2>
<h3 id="81-安全黄金法则">8.1 安全黄金法则</h3>
<ol>
<li>
<p><strong>令牌时效控制</strong>：</p>
<ul>
<li>Access Token ≤ 30分钟</li>
<li>Refresh Token ≤ 7天（需配合刷新次数限制）</li>
</ul>
</li>
<li>
<p><strong>敏感操作二次认证</strong>：</p>
</li>
</ol>
<pre><code class="language-java">public void processSensitiveOperation(String token) {
   if (isSensitiveOperation()) {
       if (!smsVerifyService.verify(getCurrentUser())) {
           throw new SecurityException("需要短信验证");
       }
   }
   // 执行操作
}
</code></pre>
<h3 id="82-性能优化关键">8.2 性能优化关键</h3>
<ol>
<li><strong>异步刷新队列</strong>：</li>
</ol>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/20130cd2-b34c-4330-8ac4-75ebee28f96c.png" class="lazyload"></p>
<ol start="2">
<li><strong>本地缓存验证</strong>：</li>
</ol>
<pre><code class="language-java">// 使用Caffeine实现本地缓存
LoadingCache&lt;String, Boolean&gt; tokenCache = Caffeine.newBuilder()
   .maximumSize(10_000)
   .expireAfterWrite(5, TimeUnit.MINUTES)
   .build(key -&gt; redis.exists("valid_token:" + key));
</code></pre>
<h3 id="83-十大避坑指南">8.3 十大避坑指南</h3>
<ol>
<li>永远不要用长有效期的Access Token</li>
<li>Refresh Token必须是一次性使用的</li>
<li>客户端必须实现<strong>静默更新</strong>机制</li>
<li>分布式环境下必须用<strong>RedLock</strong>处理并发刷新</li>
<li>敏感操作必须二次认证</li>
<li>黑名单有效期需长于Token有效期</li>
<li>设备变更必须重新认证</li>
<li>监控Refresh Token的使用频率</li>
<li>定期轮换签名密钥</li>
<li>实现令牌撤销接口</li>
</ol>
<blockquote>
<p>好的Token管理系统应该像人体的自主神经系统——平时感受不到它的存在，但在需要时总能及时响应。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-24 11:16">2025-08-24 11:15</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19055246);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19055246', targetLink: 'https://www.cnblogs.com/12lisu/p/19055246', title: 'Token续期的5种方案' })">举报</a>
</div>
        