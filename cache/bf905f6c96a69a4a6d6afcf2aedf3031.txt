
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zxlh1529/p/18823158" title="发布于 2025-04-13 13:56">
    <span role="heading" aria-level="2">vue2&amp;vue3&amp;小程序简介</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="vue2vue3小程序页面生命周期详解">Vue2、Vue3、小程序页面生命周期详解</h1>
<p>本篇将对比 Vue2、Vue3 以及小程序页面/组件的生命周期，简单梳理各自特点、差异、新增优化点。</p>
<hr>
<h2 id="-vue2-生命周期">📦 Vue2 生命周期</h2>
<pre><code class="language-txt">beforeCreate → created → beforeMount → mounted → beforeUpdate → updated → beforeDestroy → destroyed
</code></pre>
<h3 id="说明">说明：</h3>
<table>
<thead>
<tr>
<th>生命周期钩子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforeCreate</td>
<td>实例初始化之前，数据未挂载</td>
</tr>
<tr>
<td>created</td>
<td>实例创建完成，data 可访问</td>
</tr>
<tr>
<td>beforeMount</td>
<td>挂载前，$el 和模板已生成但未插入 DOM</td>
</tr>
<tr>
<td>mounted</td>
<td>挂载完成，DOM 可访问</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>数据更新前触发</td>
</tr>
<tr>
<td>updated</td>
<td>数据更新后触发（更新 DOM 后）</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>实例销毁前，可做清理工作</td>
</tr>
<tr>
<td>destroyed</td>
<td>实例销毁后</td>
</tr>
</tbody>
</table>
<h3 id="示例">示例：</h3>
<pre><code class="language-js">export default {
  data() {
    return { count: 0 }
  },
  created() {
    console.log('组件创建完成')
  },
  mounted() {
    console.log('DOM已挂载')
  }
}
</code></pre>
<hr>
<h2 id="-vue3-生命周期">🚀 Vue3 生命周期</h2>
<p>Vue3 提供了与 Vue2 一致的生命周期概念，并新增组合式 API 的方式定义。</p>
<h3 id="组合式-api-写法">组合式 API 写法</h3>
<pre><code class="language-ts">import { onMounted, onUpdated, onUnmounted } from 'vue';

export default {
  setup() {
    onMounted(() =&gt; {
      console.log('Vue3 组件挂载')
    });
  }
}
</code></pre>
<h3 id="vue3-生命周期钩子对比">Vue3 生命周期钩子对比：</h3>
<table>
<thead>
<tr>
<th>Vue2</th>
<th>Vue3 Options API</th>
<th>Vue3 Composition API</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforeCreate</td>
<td>beforeCreate</td>
<td>setup() 中逻辑</td>
</tr>
<tr>
<td>created</td>
<td>created</td>
<td>setup() 中逻辑</td>
</tr>
<tr>
<td>beforeMount</td>
<td>beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>mounted</td>
<td>mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td>updated</td>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td>destroyed</td>
<td>unmounted</td>
<td>onUnmounted</td>
</tr>
</tbody>
</table>
<h3 id="vue-3-新特性与优势">Vue 3 新特性与优势</h3>
<ol>
<li>
<p><strong>Composition API（组合式API）</strong></p>
<ul>
<li>
<p>把零散的代码逻辑按功能打包成「积木块」，想用哪块插哪块，告别满屏乱跳的 <code>data</code> 和 <code>methods</code>。</p>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
// 以前：data、methods、computed 散落各处
// 现在：按功能聚合
import { ref, computed } from 'vue'

// 计数器逻辑打包成一个「积木块」
function useCounter() {
  const count = ref(0)
  const double = computed(() =&gt; count.value * 2)
  const increment = () =&gt; count.value++
  return { count, double, increment }
}

// 直接插到组件里用
const { count, double, increment } = useCounter()
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>性能暴击（Proxy 取代 defineProperty）</strong></p>
<ul>
<li>
<p>Vue2 用「贴纸条」（<code>Object.defineProperty</code>）监听数据，Vue3 改用「监控摄像头」（<code>Proxy</code>），数组修改、对象新增属性再也不用手动 <code>$set</code>。</p>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-javascript">// Vue2：数组 push 需要特殊处理
this.$set(this.list, index, newValue)

// Vue3：直接莽，全自动监听
const list = reactive([1, 2, 3])
list.push(4) // 触发响应式更新
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>按需编译 + Tree Shaking</strong></p>
<ul>
<li>打包时只带走真正用到的代码，比如不用 <code>v-model</code> 就不打包相关逻辑，项目体积瘦身 30%+。</li>
</ul>
</li>
<li>
<p><strong>碎片化组件（Fragment + Teleport）</strong></p>
<ul>
<li>
<p>组件终于能像普通 HTML 一样写多个根标签（不用强行套 <code>div</code>），还能用 <code>&lt;Teleport&gt;</code> 把模态框「传送」到 <code>body</code> 根部，避免 CSS 层级问题。</p>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 合法！多个根元素 --&gt;
  &lt;header&gt;标题&lt;/header&gt;
  &lt;main&gt;内容&lt;/main&gt;

  &lt;!-- 把弹窗传送到 body 末尾 --&gt;
  &lt;Teleport to="body"&gt;
    &lt;div class="modal"&gt;我是全局弹窗&lt;/div&gt;
  &lt;/Teleport&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>TypeScript 原生支持</strong></p>
<ul>
<li>
<p>代码提示精准到毛孔，类型检查直接内置，再也不用和 <code>Vue.extend</code> 斗智斗勇。</p>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-typescript">interface User {
  id: number
  name: string
}

const user = ref&lt;User&gt;({ id: 1, name: '张三' }) // 类型安全！
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>其他实用武器库</strong></p>
<ul>
<li><strong>Suspense</strong>：异步组件加载时显示 loading 状态（类似 React）。</li>
<li><strong>自定义渲染器</strong>：用 Vue 语法开发小程序/Canvas 应用。</li>
<li><strong>Vite 加持</strong>：秒级热更新，告别 webpack 漫长等待。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="-vue-组件相关生命周期">🧩 Vue 组件相关生命周期</h2>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>props 更新</td>
<td>Vue2 和 Vue3 均可监听 props 变化（通过 watch）</td>
</tr>
<tr>
<td>slot 渲染</td>
<td>在 mounted 后插槽内容可以访问</td>
</tr>
<tr>
<td>异步组件</td>
<td>Vue3 支持 defineAsyncComponent 封装异步组件</td>
</tr>
</tbody>
</table>
<h3 id="示例异步组件">示例：异步组件</h3>
<pre><code class="language-ts">import { defineAsyncComponent } from 'vue';

const MyAsync = defineAsyncComponent(() =&gt; import('./MyComponent.vue'));
</code></pre>
<hr>
<h2 id="-小程序生命周期">💡 小程序生命周期</h2>
<h3 id="页面生命周期">页面生命周期</h3>
<pre><code class="language-txt">onLoad → onShow → onReady → onHide → onUnload
</code></pre>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>onLoad</td>
<td>页面加载，接受参数</td>
</tr>
<tr>
<td>onShow</td>
<td>页面显示，类似 activated</td>
</tr>
<tr>
<td>onReady</td>
<td>页面初次渲染完成</td>
</tr>
<tr>
<td>onHide</td>
<td>页面隐藏</td>
</tr>
<tr>
<td>onUnload</td>
<td>页面卸载</td>
</tr>
</tbody>
</table>
<h3 id="组件生命周期">组件生命周期</h3>
<pre><code class="language-txt">created → attached → ready → detached
</code></pre>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>组件实例刚创建</td>
</tr>
<tr>
<td>attached</td>
<td>节点插入页面 DOM</td>
</tr>
<tr>
<td>ready</td>
<td>组件布局完成</td>
</tr>
<tr>
<td>detached</td>
<td>节点从页面移除</td>
</tr>
</tbody>
</table>
<h3 id="示例页面">示例：页面</h3>
<pre><code class="language-js">Page({
  onLoad(query) {
    console.log('页面加载', query);
  },
  onReady() {
    console.log('页面初次渲染完成');
  }
})
</code></pre>
<h3 id="示例组件">示例：组件</h3>
<pre><code class="language-js">Component({
  lifetimes: {
    created() {
      console.log('组件创建');
    },
    ready() {
      console.log('组件渲染完成');
    }
  }
})
</code></pre>
<hr>
<h2 id="-总结对比">✅ 总结对比</h2>
<table>
<thead>
<tr>
<th>平台</th>
<th>生命周期粒度</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue2</td>
<td>清晰但耦合</td>
<td>生命周期集中在 Options 中</td>
</tr>
<tr>
<td>Vue3</td>
<td>更灵活</td>
<td>Composition API 更利于逻辑复用、类型支持更好</td>
</tr>
<tr>
<td>小程序</td>
<td>分页面/组件</td>
<td>生命周期更贴近原生环境，适合事件驱动模型</td>
</tr>
</tbody>
</table>
<p>适配建议：</p>
<ul>
<li>如果要构建大规模应用，Vue3 推荐使用组合式 API 搭配 TypeScript；</li>
<li>小程序推荐封装一层统一生命周期处理，方便复用；</li>
<li>Vue2 项目可以渐进迁移 Vue3，重构时可引入 Composition API。</li>
</ul>
<hr>
<blockquote>
<p>📘 推荐工具：</p>
<ul>
<li>Vue3 Composition API 官方指南</li>
<li>小程序开发者工具调试生命周期</li>
<li>Vueuse 处理常见生命周期逻辑</li>
</ul>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.016867708711805554" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-13 13:56">2025-04-13 13:56</span>&nbsp;
<a href="https://www.cnblogs.com/zxlh1529">幼儿园技术家</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18823158);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18823158', targetLink: 'https://www.cnblogs.com/zxlh1529/p/18823158', title: 'vue2&amp;amp;vue3&amp;amp;小程序简介' })">举报</a>
</div>
        