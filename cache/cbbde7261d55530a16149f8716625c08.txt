
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Fzeng/p/18978087" title="发布于 2025-07-11 01:15">
    <span role="heading" aria-level="2">SpringBoot3 + LangChain4j + Redis 实现大模型多轮对话及工具调用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>在人工智能快速发展的当下，大语言模型（LLM）已成为构建智能应用的核心技术之一。LangChain4j 作为 Java 生态中领先的 LLM 应用开发框架，为开发者提供了强大的工具，助力构建基于大语言模型的各类应用。在 Java 领域，目前整合大语言模型的主流工具主要有 Spring AI 和 LangChain4j。许多 Java 开发者可能对 Spring AI 更为熟悉，但 LangChain4j 延续了 LangChain 框架的诸多优点，在 Java 中同样易于使用。<br>
不过，当前网络上关于 LangChain4j 的整合教程较少，官方文档的粒度也不够细致，导致将其集成到现有项目中并非易事。为此，我计划编写一个系列教程，帮助大家快速地将大语言模型集成到自己的项目中。目前已实现了多轮对话和工具调用功能，接下来的短期目标是支持多模态能力和知识库系统。</p>
<h2 id="项目概述">项目概述</h2>
<p>本项目实现了一个基于SpringBoot3的智能对话系统，具有以下核心特性：</p>
<ul>
<li><strong>流式响应</strong>：支持实时流式输出，提供更好的用户体验</li>
<li><strong>多轮对话</strong>：基于Redis实现对话历史持久化</li>
<li><strong>工具集成</strong>：支持自定义工具函数扩展AI能力</li>
<li><strong>内存管理</strong>：智能的对话历史管理，避免上下文过长</li>
</ul>
<h2 id="技术栈">技术栈</h2>
<ul>
<li><strong>SpringBoot 3.5.3</strong>：现代化的Java Web框架</li>
<li><strong>Java 21</strong>：使用最新的LTS版本</li>
<li><strong>LangChain4j 1.1.0-beta7</strong>：Java版LangChain框架</li>
<li><strong>Redis</strong>：用于对话历史持久化存储</li>
<li><strong>Lombok</strong>：简化Java代码编写</li>
</ul>
<h2 id="项目结构">项目结构</h2>
<pre><code>src/main/java/com/fengzeng/langchain4j/
├── chat/
│   └── ChatController.java          # 聊天控制器
├── config/
│   ├── AssistantConfiguration.java  # AI助手配置
│   ├── PersistentChatMemoryStore.java # Redis持久化存储
│   └── RedisTemplateConfig.java    # Redis配置
├── service/
│   ├── Assistant.java              # 普通助手接口
│   └── StreamingAssistant.java     # 流式助手接口
├── tool/
│   └── AssistantTools.java         # 自定义工具
└── listener/
    └── MyChatModelListener.java    # 聊天模型监听器
</code></pre>
<h2 id="核心实现">核心实现</h2>
<h3 id="1-依赖配置">1. 依赖配置</h3>
<p>首先在<code>pom.xml</code>中添加必要的依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- SpringBoot Web --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;!-- Redis支持 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;!-- LangChain4j核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;
        &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.1.0-beta7&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- OpenAI集成 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;
        &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.1.0-beta7&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- 响应式支持 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;
        &lt;artifactId&gt;langchain4j-reactor&lt;/artifactId&gt;
        &lt;version&gt;1.1.0-beta7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="2-应用配置">2. 应用配置</h3>
<p>在<code>application.yaml</code>中配置OpenAI和Redis：</p>
<pre><code class="language-yaml">langchain4j:
  open-ai:
    streaming-chat-model:
      base-url: https://yunwu.ai/v1
      api-key: your-api-key
      model-name: gpt-4o-mini
      log-requests: true
      log-responses: true

spring:
  data:
    redis:
      host: 10.0.5.55
      port: 6379
      database: 1
      password: your-password

server:
  port: 8000
</code></pre>
<h3 id="3-redis配置">3. Redis配置</h3>
<p>创建Redis模板配置类：</p>
<pre><code class="language-java">@Configuration
public class RedisTemplateConfig {
    
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
</code></pre>
<h3 id="4-持久化聊天存储">4. 持久化聊天存储</h3>
<p>实现基于Redis的聊天历史持久化：</p>
<pre><code class="language-java">@Component
@Slf4j
public class PersistentChatMemoryStore implements ChatMemoryStore {
    
    @Resource
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    @Override
    public List&lt;ChatMessage&gt; getMessages(Object memoryId) {
        Object raw = redisTemplate.opsForValue().get(String.valueOf(memoryId));
        if (raw == null) {
            // todo 从数据库中查询最近的历史消息记录
            return List.of(); // 返回空历史，表示是第一次对话
        }
        return messagesFromJson(raw.toString());
    }
    
    @Override
    public void updateMessages(Object memoryId, List&lt;ChatMessage&gt; messages) {
        String json = messagesToJson(messages);
        redisTemplate.opsForValue().set(String.valueOf(memoryId), json);
    }
    
    @Override
    public void deleteMessages(Object memoryId) {
        redisTemplate.delete(String.valueOf(memoryId));
    }
}
</code></pre>
<h3 id="5-流式助手接口">5. 流式助手接口</h3>
<p>定义支持流式响应的AI助手：</p>
<pre><code class="language-java">@AiService
public interface StreamingAssistant {
    
    @SystemMessage("You are a helpful assistant")
    Flux&lt;String&gt; chat(@UserMessage String userMessage, @MemoryId int memoryId);
}
</code></pre>
<h3 id="6-自定义工具">6. 自定义工具</h3>
<p>扩展AI助手的能力：</p>
<pre><code class="language-java">@Component
public class AssistantTools {
    
    @Tool
    @Observed
    public String currentTime() {
        return LocalDateTime.now().toString();
    }
}
</code></pre>
<h3 id="7-聊天控制器">7. 聊天控制器</h3>
<p>其实，核心步骤就在这里。由于引入了 langchain4j-starter 后，框架会根据配置文件中定义的 xxx-chat-model，自动为你注入对应的实例。因此，关键就在于如何正确获取 Assistant。官方文档给出的示例是直接通过注解注入 Assistant，但这种方式无法注入自定义的 memory（记忆）和 tools（工具），限制了更复杂场景的使用。</p>
<p>下面是一个通过显式方式构建 Assistant 的示例，并提供了一个简单的 REST API 接口：</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/v1/chat")
public class ChatController {
    
    @Resource
    private OpenAiStreamingChatModel openAiChatModel;
    
    @Resource
    PersistentChatMemoryStore chatMemoryStore;
    
    @Resource
    AssistantTools assistantTools;
    
    @GetMapping(value = "/chat", produces = TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; model(@RequestParam(value = "message", defaultValue = "Hello") String message,
                              @RequestParam(value = "memoryId") int memoryId) {
        
        StreamingAssistant assistant = getAssistant(memoryId);
        return assistant.chat(message, memoryId);
    }
    
    private StreamingAssistant getAssistant(int memoryId) {
        ChatMemoryProvider chatMemoryProvider = o -&gt; MessageWindowChatMemory.builder()
                .id(memoryId)
                .maxMessages(10)
                .chatMemoryStore(chatMemoryStore)
                .build();
        
        return AiServices.builder(StreamingAssistant.class)
                .streamingChatModel(openAiChatModel)
                .chatMemoryProvider(chatMemoryProvider)
                .tools(assistantTools)
                .build();
    }
}
</code></pre>
<h2 id="核心特性解析">核心特性解析</h2>
<h3 id="1-多轮对话支持">1. 多轮对话支持</h3>
<p>通过<code>@MemoryId</code>注解和Redis持久化存储，系统能够：</p>
<ul>
<li>为每个用户会话分配唯一的memoryId</li>
<li>自动保存和恢复对话历史</li>
<li>支持最多10轮对话的上下文窗口</li>
</ul>
<h3 id="2-流式响应">2. 流式响应</h3>
<p>使用<code>Flux&lt;String&gt;</code>和<code>TEXT_EVENT_STREAM_VALUE</code>实现：</p>
<ul>
<li>实时流式输出，提升用户体验</li>
<li>减少等待时间，提供即时反馈</li>
<li>支持长文本的渐进式显示</li>
</ul>
<h3 id="3-工具集成">3. 工具集成</h3>
<p>通过<code>@Tool</code>注解可以轻松扩展AI能力：</p>
<ul>
<li>自定义工具函数</li>
<li>自动注入到AI助手中</li>
<li>支持复杂的业务逻辑</li>
</ul>
<h3 id="4-内存管理">4. 内存管理</h3>
<p>智能的对话历史管理：</p>
<ul>
<li>自动限制上下文长度</li>
<li>防止token超限</li>
<li>保持对话的连贯性</li>
</ul>
<h2 id="使用示例">使用示例</h2>
<h3 id="启动应用">启动应用</h3>
<pre><code class="language-bash">mvn spring-boot:run
</code></pre>
<h3 id="api调用">API调用</h3>
<pre><code class="language-bash">curl -N "http://localhost:8000/api/v1/chat/chat?message=你好&amp;memoryId=123"
</code></pre>
<h3 id="前端集成">前端集成</h3>
<pre><code class="language-javascript">const eventSource = new EventSource('/api/v1/chat/chat?message=你好&amp;memoryId=123');
eventSource.onmessage = function(event) {
    console.log('收到流式响应:', event.data);
};
</code></pre>
<h2 id="总结">总结</h2>
<p>本项目展示了如何使用SpringBoot3和LangChain4j构建现代化的AI对话系统。通过Redis实现持久化存储，结合流式响应和工具集成，为开发者提供了一个完整的解决方案。</p>
<p>项目特点：</p>
<ul>
<li><strong>简单易用</strong>：基于SpringBoot的熟悉开发模式</li>
<li><strong>功能完整</strong>：支持多轮对话、流式响应、工具集成</li>
<li><strong>可扩展性强</strong>：模块化设计，易于扩展新功能</li>
<li><strong>生产就绪</strong>：包含完整的配置和部署方案</li>
</ul>
<h2 id="相关资源">相关资源</h2>
<ul>
<li><a href="https://github.com/fengzengfly/easy_langchain4sb" target="_blank" rel="noopener nofollow">项目地址(github)</a></li>
<li><a href="https://docs.langchain4j.dev/" target="_blank" rel="noopener nofollow">LangChain4j官方文档</a></li>
<li><a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener nofollow">SpringBoot官方文档</a></li>
<li><a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener nofollow">Redis命令手册</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-07-11 01:18">2025-07-11 01:15</span>&nbsp;
<a href="https://www.cnblogs.com/Fzeng">fengzeng</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18978087);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18978087', targetLink: 'https://www.cnblogs.com/Fzeng/p/18978087', title: 'SpringBoot3 + LangChain4j + Redis 实现大模型多轮对话及工具调用' })">举报</a>
</div>
        