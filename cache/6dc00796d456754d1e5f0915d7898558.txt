
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyzhangdd/p/18354302" title="发布于 2025-01-15 10:44">
    <span role="heading" aria-level="2">一文搞懂国际化（二）架构设计</span>
    

</a>

			</h2>
 			Posted on 
<span id="post-date" data-last-update-days="0.2264139264247685" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-15 10:53">2025-01-15 10:44</span>&nbsp;
<a href="https://www.cnblogs.com/dennyzhangdd">只会一点java</a>&nbsp;
阅读(<span id="post_view_count">73</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18354302" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18354302);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18354302', targetLink: 'https://www.cnblogs.com/dennyzhangdd/p/18354302', title: '一文搞懂国际化（二）架构设计' })">举报</a>
			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><strong>专题目录</strong></p>
<p><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyzhangdd/p/18019586">一文搞懂国际化（一）背景概览 </a></p>
<p><a href="https://www.cnblogs.com/dennyzhangdd/p/18354302">一文搞懂国际化（二）架构设计</a></p>
<p>一文搞懂国际化（三）落地实践</p>
<p>一文搞懂国际化（四）总结提升</p>
<h1>引子</h1>
<p>第一章，我们分析了国际化项目的背景和基础知识，本章我们来分析一下要实现国际化的功能，有哪些设计点。本章只讲设计，不讲落地实践（见第三章）。</p>
<h1>一、需求分析</h1>
<p>回顾笔者主导的这一年的国际化改造项目过程，可归纳出三大块设计难点：</p>
<ul>
<li>1）<strong>多语言改造</strong>：系统支持用户设置自己的语言，支持语言切换，即【<span style="color: rgba(255, 0, 0, 1)"><strong>语言切换</strong></span>】功能。</li>
<li>2）多<strong>时区改造</strong>：系统支持多时区客户端时间。客户看到的是自己本地时区时间，但后端服务、数据库一般只部署在一套环境中。如何设计解决【<span style="color: rgba(255, 0, 0, 1)"><strong>前端多时区，后端统一时区</strong></span>】的业务场景。</li>
<li>3）<strong>翻译运营</strong><strong>工具</strong>：上线生产后，为了快速实现，持续可拓展的新增语言功能，急需一个翻译运营工具，即如何设计实现一个新增/维护语言的【<strong><span style="color: rgba(255, 0, 0, 1)">翻译运营工具</span></strong>】。</li>
</ul>
<p>相信大部分做国际化改造的项目都会遇到上面所说的设计场景，下面我们针对这三大块进行初步分析。</p>
<h1>二、多语言设计</h1>
<p>&nbsp;要实现用户多语言切换，可拆解成2部分：</p>
<ul>
<li>第一步，设置用户想要的语言：具体在APP上还是WEB端上搞个入口支持设置用户的语言即可。</li>
<li>第二步，使用设置的语言，加载对应的语言翻译资源了。这里分两大块，<span style="color: rgba(255, 0, 0, 1)"><strong>前端的工程内的静态资源包、后端的接口动态翻译</strong></span>。</li>
</ul>
<p>不管是前端静态资源包还是后端的动态翻译，都有3种实现逻辑，即<span style="color: rgba(255, 0, 0, 1)"><strong>设备跟随、账号跟随、系统跟随</strong></span>。</p>
<ol>
<li><span style="color: rgba(255, 0, 0, 1)"><span style="color: rgba(0, 0, 0, 1)"><strong><span style="color: rgba(255, 0, 0, 1)">系统跟随</span></strong>：未设置语言，直接跟随系统<span style="color: rgba(255, 0, 0, 1)"><span style="color: rgba(0, 0, 0, 1)">（比如APP端就是手机android/ios系统语言，WEB端就是客户浏览器运营设备的系统语言）</span></span>。</span></span></li>
<li><span style="color: rgba(255, 0, 0, 1)"><strong>设备跟随</strong>：<span style="color: rgba(0, 0, 0, 1)">即<span style="color: rgba(255, 0, 0, 1)"><strong>语言跟随客户端设备</strong></span>走，换设备后得重新设置语言，否则默认系统跟随。</span></span></li>
<li><span style="color: rgba(255, 0, 0, 1)"><strong>账号跟随</strong>：<span style="color: rgba(0, 0, 0, 1)">即<span style="color: rgba(255, 0, 0, 1)"><strong>语言跟随账号</strong></span>走，不管换了什么客户端设备都是账号设置的语言，否则默认系统跟随。</span></span></li>
</ol>
<p>纯系统跟随策略的产品很少（不够灵活），使用另外两种策略的产品市面上很多，看哪种适合你。（一般来说，<span><span style="background-color: rgba(255, 153, 0, 1)">账号跟随适合强B端的重企业偏向的产品，设备跟随适合强C端的重个人体验的产品</span>。）</span></p>
<h2>2.1 前端静态翻译</h2>
<p>前端逻辑很简单：就是根据当前语言，获取静态资源包中的翻译。</p>
<h3><strong>1.语言包</strong></h3>
<p>现代前端工程框架&nbsp; react、vaue等都是有自己支持一套国际化方案的，在前端工程中的保存有i18n翻译资源包（例如VUE的i18n框架），随着项目打包发布。例如zh_CN.json 这样的json格式。</p>
<h3>2.登录态持有语言</h3>
<p>前端的语言，<span style="color: rgba(255, 0, 0, 1)"><strong>生命周期应该是登录态持有的</strong></span>（不管用的是设备跟随还是账号跟随策略）。即如果语言被改了，不会立即生效，登出后再登入，刷新登录态，此时获取到最新语言，才会生效。</p>
<h2>2.2 后端动态翻译</h2>
<p>后端的翻译跟前端最大的不同是复用。比如某个微服务中的一个字典翻译，可能会被上层多个不同业务层服务接口用到。如何设计一个可复用，高性能，易维护的后端翻译架构，还是有点难度的。下买呢我们从业务模型、具体设计两个步骤来进行设计拆解。</p>
<h3><span style="color: rgba(0, 0, 0, 1)"><strong>2.2.1 </strong></span><span style="color: rgba(255, 0, 0, 1)"><span style="color: rgba(255, 0, 0, 1)"><span style="color: rgba(0, 0, 0, 1)"><strong>翻译依赖梳理</strong></span></span></span></h3>
<p>思考到大部分翻译是通过接口定义的返回字段上做的翻译，比如某个resultDTO。这个DTO（或者是其中某些字段）又会被多个上层应用引用。当某个底层服务的接口resultDTO中的翻译字段更新时，上层引用的缓存需要同步更新。这种缓存依赖关系，需要配置在各自的apollo中。这样当依赖的缓存更新时，上层引用方也会刷新缓存。</p>
<p><img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241024163702491-943513971.jpg" alt=""></p>
<h3><strong>2.2.2 流程设计</strong></h3>
<p><strong><img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241024174921470-2105746642.jpg" alt=""></strong></p>
<p><strong>1.前置操作</strong></p>
<p><strong>1）设置好用户的语言：</strong>不管是客户端跟随，还是账户跟随。</p>
<p><strong>2）后端服务：</strong>用到翻译的后端服务启动时，根据配置的服务依赖关系，读取翻译库，生成内存缓存。</p>
<p><strong>2.请求流程</strong></p>
<p><strong>1）前端请求：前端请求头header传过来。前端登录态持有语言的生命周期（不管语言策略是客户端跟随还是账户跟随）。</strong></p>
<p><strong>2）后端框架：读取请求头中的语言+服务名+翻译key,从缓存中获取翻译值。</strong></p>
<h3><strong>2.2.3 重点设计</strong></h3>
<p><strong>1）能力封装</strong></p>
<p>　　后端翻译，统一存储在配置中心（微服务）的翻译表中。配置中心对外提供翻译的增删改查接口，作为一种<span style="color: rgba(255, 0, 0, 1)"><strong>翻译能力</strong></span>提供。根据第一节业务分析得知，翻译拆解为<strong><span style="color: rgba(255, 0, 0, 1)">服务级维护</span></strong>，翻译表设计核心业务模型：<span style="color: rgba(255, 0, 0, 1)"><strong>服务名-翻译key-语言类型-翻译值value.</strong></span></p>
2）<span style="color: rgba(0, 0, 0, 1)"><strong>翻译性能</strong></span>
<ul>
<li>增加缓存：由于翻译是<span style="color: rgba(255, 0, 0, 1)">高频请求且不会经常变动</span>，我们设计在业务服务中增加<span style="color: rgba(255, 0, 0, 1)">内存缓存</span>。可极大提高接口查询翻译的性能。</li>
<li>热刷新：同时，当翻译资源有新增/更新时，需要支持热刷新。避免重启生产服务带来的风险。翻译资源增加版本号概念，版本变化，监听缓存自动刷新。</li>
</ul>
<p><strong>&nbsp;3）框架升级</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后端的底层框架包（一般叫base/core包）升级：要能够解析请求头中的语言+接口返回序列化时增强做翻译。接口返回DTO上加注解，注解分两类：整个类上，字段上。字段上的注解需要填写key。框架层在返回DTO序列化时，读取翻译注解：根据key+语言从缓存中读取对应的翻译值，塞入序列化返回值。</p>
<p>&nbsp;</p>
<h1>三、多时区设计</h1>
<p>多时区改造是国际化改造中的重头戏，如非必须改造，不建议轻易动。特别是业务链路长、微服务特别多、软硬件一体化的系统。笔者项目设计了2个月，改造花了3个月最后才上线。</p>
<p>&nbsp; <img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241017170128624-605012028.jpg" alt=""></p>
<p>我们以最简单的前后端接口通信为例，讲解多时区的问题以及改造方案。</p>
<p>一般我们未支持过国际化的系统特性：</p>
<ul>
<li>1.<span style="color: rgba(255, 0, 0, 1)"><strong>前后端通信丢失时区</strong></span>：前后端数据通信，接口只会传一个时间字符串 “yyyy-mm-dd&nbsp; HH:mm:ss”。此时并不知道这个时间，对应的时区是什么，也就没法精确定位到一个时间点。</li>
<li>2.<span style="color: rgba(255, 0, 0, 1)"><strong>数据存储丢失时区</strong></span>：数据库的时间字段是不带时区的timeStamp类型。光看数据库这个字段数据，也没法精确定位到一个时间点。</li>
</ul>
<p>一开始业务在国内跑，一般系统的运行环境都是<span style="color: rgba(255, 0, 0, 1)"><strong>UTC8时区</strong></span>的，所以不会出现上述的2点时区偏移问题。但在国际化多时区场景下，同一个时间字符串 “yyyy-mm-dd&nbsp; HH:mm:ss”，在美国和在韩国，代表的肯定不是一个时间点。第二点，当一般业务量不是特别巨大时，业务发展初期，也不会根据地域时区去拆库。所以数据库一般就一个时区，即国内的UTC8。有点设计经验的小伙肯定想到了，时区转换的方案：即前端数据到后端后开始，统一使用一种时区，包括存储。最后接口返回给前端时，再转换前端不同的时区时间即可。问题来了，我们是继续使用UTC8做后端底座，还是全部改造成UTC0呢？两种方案的对比如下：</p>
<h2>3.1 时区改造方案</h2>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241018154439344-1499161861.jpg" alt=""></p>
<p>方案一：<span style="color: rgba(255, 0, 0, 1)"><strong>使用UTC8环境（后端服务、组件、数据库）</strong><span style="color: rgba(0, 0, 0, 1)">不变</span><span style="color: rgba(0, 0, 0, 1)">。步骤如下：</span></span></p>
<ol>
<li>前端：请求在header中传本地时区timezone.</li>
<li>后端：请求到后端时，在入参解析时，框架根据<span style="color: rgba(255, 0, 0, 1)"><strong>header中的timezone（缓存本地），转换成UTC8时区时间</strong>。<span style="color: rgba(0, 0, 0, 1)">（图中UTC9→UTC8）</span></span></li>
<li>后端：执行业务逻辑，数据落库（UTC8）。</li>
<li>后端：请求返回JSON格式数据时，框架统一<span style="color: rgba(255, 0, 0, 1)"><strong>在序列化时根据缓存中的timezone转换为客户端本地时区时间</strong><span style="color: rgba(0, 0, 0, 1)">（图中UTC9）。</span></span></li>
<li>前端：拿到后端返回的数据，时间格式化展示。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/584866/202410/584866-20241018154620112-1689119964.jpg" alt=""></p>
<p>方案二：重新部署一套UTC0环境（<span style="color: rgba(255, 0, 0, 1)"><strong>后端服务、组件、</strong><strong>数据库</strong><strong>、洗数据</strong>）。</span></p>
<ol>
<li>前端：发起请求，传值<span style="color: rgba(255, 0, 0, 1)"><strong>ISO格式</strong>时间，<span style="color: rgba(0, 0, 0, 1)">例如：韩国东九区时间“2024-01-12T09:00:00+09:00”。ISO8601格式的时间（上跳第一章第三节），是为了有更好的可读性，且能表示唯一时间。</span></span></li>
<li>后端：请求到后端时，在入参接收时，框架把<span style="color: rgba(255, 0, 0, 1)"><strong>本地时区时间转换为系统默认时区（UTC0）的时间</strong>。<span style="color: rgba(0, 0, 0, 1)">（图中UTC9→UTC0）</span></span></li>
<li>后端：执行业务逻辑，数据落库（UTC0）。</li>
<li>后端：请求返回在序列化时，框架统一<span style="color: rgba(255, 0, 0, 1)"><strong>在序列化时返回</strong><span style="color: rgba(0, 0, 0, 1)">ISO零时区时间。</span></span></li>
<li>前端：拿到后端返回的数据，接收ISO时间<span style="color: rgba(255, 0, 0, 1)"><strong>自动转成客户端本地时区时间</strong><span style="color: rgba(0, 0, 0, 1)">，格式化后展示。</span></span></li>
</ol>
<p>&nbsp;建议：</p>
<p>笔者的团队在纠结了多轮博弈后，最终还是选择了UTC0时区，一步到位，耗时三个月呕心沥血才改造完毕。<span style="color: rgba(255, 0, 0, 1)"><strong>这两种方案都可行。看哪种适合你的团队即可！！！。如果系统链路长，涉及各种云、边、端服务，保守起见可以使用UTC8方案一。</strong></span></p>
<h1>四、翻译运营工具设计</h1>
<h2>4.1 翻译工具设计</h2>
<p>分析了国际化翻译业务场景中，在运营平台中新增多语言管理菜单，进行可视化运维。可拆分为3步骤：</p>
<ul>
<li>1.<strong>字典库维护</strong>：导出翻译表，人工识别专业词汇，线下翻译后导入字典库，可视化维护。</li>
<li>2.<strong>智能翻译</strong>：拆解出一个步骤，专门用来做翻译。调用Dify的大模型翻译API即可，这是一个批量离线翻译的过程。</li>
<li>3.<strong>翻译管理</strong>：把智能翻译的结果下载，完事人工检查一下本次翻译的变化列，校验无误后导入翻译管理，即可被业务使用，支持可视化维护。流程如下图：</li>
</ul>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/584866/202501/584866-20250115095740808-1200220309.png" alt=""></p>
<h2>4.2 开放问题</h2>
<p>关于如何提高翻译精准度问题，这里提供一些思路，大家可选择适合自己项目的：</p>
<p><strong>1.人工校对</strong></p>
<p>由于翻译场景不同，翻译值可能变化较大，如需要极度精准翻译，一定是找专业翻译人员，一个一个页面去校对。</p>
<p><strong>2.AI翻译</strong></p>
<p>1）由于中文的复杂度可能导致翻译的不精准。可以先中文-&gt;英文，再用英文做key，调用AI去翻译 韩语、俄语等外语。精准度会有较大提升。</p>
<p>2）如有<strong>专业领域的大模型</strong>直接选择更佳。</p>
<p><strong>3.打标收敛</strong></p>
<p>打标已矫正过的翻译，逐步收敛不精准翻译。</p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    ------------------个人能力有限，大家多交流，一起壮哉我大JAVA！------------------
<p>如果你觉得本文对你有点帮助的话，记得在右下角点个<span>“推荐”</span>哦，博主在此感谢！</p>
</div>
<div class="clear"></div>
</div>
	