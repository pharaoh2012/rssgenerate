
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hk416hasu/p/18691722" title="发布于 2025-01-26 13:36">
    <span role="heading" aria-level="2">stdio.h的缓冲机制解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在C语言中，由于stdio.h中的缓冲机制，printf的输出常令人感到迷惑。本文将介绍其缓冲机制的具体细节
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-令人迷惑的printf">1. 令人迷惑的printf()</h2>
<p>在C语言中，由于<code>stdio.h</code>中的缓冲机制，<code>printf</code>的输出通常会受到缓冲区的影响。<br>
这种影响可能非常微妙，并常常令人疑惑，比如我们来看下面这段代码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(void) {
  printf("Hello World");
  while(1);
}
</code></pre>
<p>在命令行中编译运行，发现他只是一味循环，输出不见了？！！<br>
但是如果我们修改一下代码，添加一个换行符：</p>
<pre><code class="language-c">printf("Hello World\n");
</code></pre>
<p>就可以看到Hello World被输出了？！<br>
<img src="https://img2024.cnblogs.com/blog/3320890/202501/3320890-20250126115208800-1523328242.jpg" alt="image" loading="lazy"></p>
<h2 id="2-stdio的缓冲机制解析">2. stdio的缓冲机制解析</h2>
<p>根据标准I/O的缓冲方式，<code>printf</code>的输出主要有以下几种情况：</p>
<h3 id="21-行缓冲line-buffering">2.1. <strong>行缓冲（Line Buffering）</strong></h3>
<ul>
<li>默认情况下，<strong>面向终端（标准输出/<code>stdout</code>是终端）的文件流</strong>使用<strong>行缓冲</strong>。</li>
<li>缓冲区在<strong>以下情况下刷新</strong>：
<ol>
<li>输出了一个<strong>换行符 <code>\n</code></strong>。</li>
<li>缓冲区被<strong>填满</strong>。</li>
<li>主动调用刷新函数（如 <code>fflush(stdout)</code>）。</li>
<li>程序正常结束，流被关闭（如 <code>exit()</code> 或 <code>return</code> 导致流关闭）。</li>
</ol>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-c">printf("Hello, ");    // 不会立即输出，因为没有换行
printf("World\n");    // 输出 "Hello, World"，因为遇到换行符
</code></pre>
<hr>
<h3 id="22-全缓冲full-buffering">2.2. <strong>全缓冲（Full Buffering）</strong></h3>
<ul>
<li>默认情况下，<strong>面向文件的文件流（如写入文件的<code>FILE*</code>）</strong>使用<strong>全缓冲</strong>。</li>
<li>缓冲区在<strong>以下情况下刷新</strong>：
<ol>
<li>缓冲区被<strong>填满</strong>。</li>
<li>主动调用刷新函数（如 <code>fflush(file_stream)</code>）。</li>
<li>程序正常结束，流被关闭（如 <code>fclose()</code> 或 <code>exit()</code>）。</li>
</ol>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-c">FILE *fp = fopen("output.txt", "w");
fprintf(fp, "Buffered output");  // 不会立即写入文件
fflush(fp);                      // 主动刷新缓冲区，写入文件
fclose(fp);                      // 关闭文件时自动刷新缓冲区
</code></pre>
<hr>
<h3 id="23-无缓冲unbuffered">2.3. <strong>无缓冲（Unbuffered）</strong></h3>
<ul>
<li>默认情况下，<strong>标准错误流<code>stderr</code></strong>是<strong>无缓冲</strong>的（因为需要及时显示错误信息）。</li>
<li>缓冲区在<strong>每次调用I/O操作时</strong>都会刷新，数据直接输出到目标设备。</li>
<li>如果通过 <code>setvbuf</code> 或 <code>setbuf</code> 将流设置为无缓冲，则每次调用<code>printf</code>都会立即输出。</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-c">fprintf(stderr, "This is an error message\n"); // 立即输出，不受缓冲机制影响
</code></pre>
<p><strong>设置无缓冲流</strong>：</p>
<pre><code class="language-c">setvbuf(stdout, NULL, _IONBF, 0); // 将 stdout 设置为无缓冲
printf("Immediate output");      // 每次调用都会直接输出
</code></pre>
<hr>
<h3 id="24-缓冲区溢出或关闭时刷新">2.4. <strong>缓冲区溢出或关闭时刷新</strong></h3>
<ul>
<li>如果缓冲区被填满，<code>stdio</code>会自动刷新。</li>
<li>当程序结束或流关闭时（如 <code>fclose()</code>），缓冲区中的内容会被自动刷新。</li>
</ul>
<hr>
<h3 id="stdio缓冲机制总结">stdio缓冲机制总结</h3>
<table>
<thead>
<tr>
<th>缓冲模式</th>
<th>使用场景</th>
<th>刷新条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>行缓冲</strong></td>
<td><code>stdout</code>面向终端</td>
<td>换行符、缓冲区满、调用<code>fflush</code>、流关闭或程序退出</td>
</tr>
<tr>
<td><strong>全缓冲</strong></td>
<td><code>stdout</code>面向文件或其他设备</td>
<td>缓冲区满、调用<code>fflush</code>、流关闭或程序退出</td>
</tr>
<tr>
<td><strong>无缓冲</strong></td>
<td><code>stderr</code>或主动设置无缓冲流</td>
<td>每次调用<code>printf</code>或<code>fprintf</code>直接输出</td>
</tr>
</tbody>
</table>
<p>缓冲模式可以通过 <code>setvbuf</code> 或 <code>setbuf</code> 自定义，这在调试或控制输出行为时非常有用。</p>
<h2 id="3-并发场景下的stdio缓冲">3. 并发场景下的stdio缓冲</h2>
<p>在并发场景下，stdio的缓冲机制可能会更令人迷惑一点，不过机制是相通的。</p>
<pre><code class="language-bash">$ cat fork_printf.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(void) {
  for (int i = 0; i &lt; 2; i++) {
    fork();
    printf("Hello\n");
  }
  return 0;
}
$ gcc fork_printf.c
$ ./a.out
Hello
Hello
Hello
Hello
Hello
Hello
$ ./a.out | cat
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
$ # ??? 为什么两次输出内容不一样？是魔法么？？！
</code></pre>
<p>这就是因为./a.out面向的输出的使用的缓冲方式不同：</p>
<ul>
<li>面向标准输出stdout时，使用行缓冲机制，Hello\n不存放在stdio的缓冲区（内存中），而是直接输出了</li>
<li>面向管道输出时， 则使用全缓冲机制，因此第一个Hello\n会存放在缓冲区中，并随着fork一并复制，并再最后程序退出时输出。</li>
</ul>
<p>也许你觉得我在胡说八道，但是根据<code>计算机中没有魔法</code>的观点，我们一定是有办法验证我们的猜想的。<br>
没错，我们可以使用strace来看到程序的write系统调用，从而验证上述观点。<br>
下一篇将以此为例介绍linux神器之<code>strace</code>的应用场景与使用方式。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.35828765869097223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 13:36">2025-01-26 13:36</span>&nbsp;
<a href="https://www.cnblogs.com/hk416hasu">hk416hasu</a>&nbsp;
阅读(<span id="post_view_count">23</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18691722" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18691722);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18691722', targetLink: 'https://www.cnblogs.com/hk416hasu/p/18691722', title: 'stdio.h的缓冲机制解析' })">举报</a>
</div>
        