
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/HuaTalkHub/p/18695088" title="发布于 2025-01-30 10:49">
    <span role="heading" aria-level="2">如何安全发布 CompletableFuture ？Java9新增方法分析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="如何安全发布-completablefuture-java9新增方法分析">如何安全发布 CompletableFuture ？Java9新增方法分析</h1>
<p>本文未经允许禁止转载。</p>
<p>JDK9 中对于CompletableFuture做了新的增强，除了<a href="https://juejin.cn/post/7411345808527147062" target="_blank" rel="noopener nofollow">超时功能</a>（orTimeout），还有面向继承、安全发布等相关方法。本文中，我们将详细分析各个新增方法，同时说明其安全发布的重要性，最后提出相关的实践原则。</p>
<h2 id="1-newincompletefuture">1. newIncompleteFuture</h2>
<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
    return new CompletableFuture&lt;U&gt;();
}
</code></pre>
<p>这是一个面向继承的方法，Java支持方法返回值协变，子类可以返回自己的实现。如果你不需要继承 CompletableFuture，对于使用来说，这个方法没有新增新的功能。</p>
<h2 id="2-默认执行器">2. 默认执行器</h2>
<pre><code class="language-java">public Executor defaultExecutor() {
    return ASYNC_POOL;
}
</code></pre>
<p>子类可以指定默认执行器，不过需要注意调用不显式指定执行器的async相关方法时，其执行回调所在的线程有两种可能：当前调用线程或者子类指定的执行器线程。如果使用 CompletableFuture，推荐显式指定执行器；如果使用 CFFU，无需每次都显式指定执行器。</p>
<h2 id="3-复制方法">3. 复制方法</h2>
<pre><code class="language-java">public CompletableFuture&lt;T&gt; copy() {
    return uniCopyStage(this);
}
</code></pre>
<p>此方法等同于调用 <code>cf.thenApply(x -&gt; x)</code>, 目的是实现保护性复制，避免后续操作对于原实例的修改。</p>
<h2 id="4-只读形式与安全发布">4. 只读形式与安全发布</h2>
<pre><code class="language-java">// 返回结果仅支持 CompletionStage 操作
public CompletionStage&lt;T&gt; minimalCompletionStage() {
    return uniAsMinimalStage();
}

private MinimalStage&lt;T&gt; uniAsMinimalStage() {
    Object r;
  	// 性能优化1：若已有结果，当前线程下直接返回stage
    if ((r = result) != null)
        return new MinimalStage&lt;T&gt;(encodeRelay(r));
  	// 性能优化2：若还未有结果，注册回调
    MinimalStage&lt;T&gt; d = new MinimalStage&lt;T&gt;();
    unipush(new UniRelay&lt;T,T&gt;(d, this));
    return d;
}

// 实际实现，CompletableFuture 独有方法均不支持
static final class MinimalStage&lt;T&gt; extends CompletableFuture&lt;T&gt; {
        MinimalStage() { }
        MinimalStage(Object r) { super(r); }
        @Override public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
            return new MinimalStage&lt;U&gt;(); }
        @Override public T get() {
            throw new UnsupportedOperationException(); }
        @Override public T get(long timeout, TimeUnit unit) {
            throw new UnsupportedOperationException(); }
        @Override public T getNow(T valueIfAbsent) {
            throw new UnsupportedOperationException(); }
        @Override public T join() {
            throw new UnsupportedOperationException(); }
        @Override public T resultNow() {
            throw new UnsupportedOperationException(); }
        @Override public Throwable exceptionNow() {
            throw new UnsupportedOperationException(); }
        @Override public boolean complete(T value) {
            throw new UnsupportedOperationException(); }
        @Override public boolean completeExceptionally(Throwable ex) {
            throw new UnsupportedOperationException(); }
        @Override public boolean cancel(boolean mayInterruptIfRunning) {
            throw new UnsupportedOperationException(); }
        @Override public void obtrudeValue(T value) {
            throw new UnsupportedOperationException(); }
        @Override public void obtrudeException(Throwable ex) {
            throw new UnsupportedOperationException(); }
        @Override public boolean isDone() {
            throw new UnsupportedOperationException(); }
        @Override public boolean isCancelled() {
            throw new UnsupportedOperationException(); }
        @Override public boolean isCompletedExceptionally() {
            throw new UnsupportedOperationException(); }
        @Override public State state() {
            throw new UnsupportedOperationException(); }
        @Override public int getNumberOfDependents() {
            throw new UnsupportedOperationException(); }
        @Override public CompletableFuture&lt;T&gt; completeAsync
            (Supplier&lt;? extends T&gt; supplier, Executor executor) {
            throw new UnsupportedOperationException(); }
        @Override public CompletableFuture&lt;T&gt; completeAsync
            (Supplier&lt;? extends T&gt; supplier) {
            throw new UnsupportedOperationException(); }
        @Override public CompletableFuture&lt;T&gt; orTimeout
            (long timeout, TimeUnit unit) {
            throw new UnsupportedOperationException(); }
        @Override public CompletableFuture&lt;T&gt; completeOnTimeout
            (T value, long timeout, TimeUnit unit) {
            throw new UnsupportedOperationException(); }
  			// 返回新的CompletableFuture, 等效于thenApply(x -&gt; x)
        @Override public CompletableFuture&lt;T&gt; toCompletableFuture() {
            Object r;
            if ((r = result) != null)
                return new CompletableFuture&lt;T&gt;(encodeRelay(r));
            else {
                CompletableFuture&lt;T&gt; d = new CompletableFuture&lt;&gt;();
                unipush(new UniRelay&lt;T,T&gt;(d, this));
                return d;
            }
        }
    }
</code></pre>
<p>此方法返回只读的 CompletionStage，可以实现安全发布。可以类比于一个方法返回了ImmutableList，优点是可以防止后续的错误操作，比如其他线程强制写结果（类比List#add）。</p>
<p>有这样一个安全发布的保证至关重要，特别是面临复杂场景时，可以减轻编程负担，放心地使用 CompletableFuture 返回的结果。</p>
<p>我们知道CompletionStage接口定义了链式异步回调相关方法， CompletableFuture 相关读写操作（join, complete,  obtrudeValue 等），不在CompletionStage的定义下，可以通过方法toCompletableFuture进行中转。</p>
<pre><code class="language-java">class InventoryServiceDemo {
    final Executor executor = Executors.newCachedThreadPool();

    // 获取库存信息
  	// 方法可以返回 CompletionStage，相比于CompletableFuture更安全
    CompletionStage&lt;Integer&gt; getInventoryAsync(String productId) {
        return CompletableFuture.supplyAsync(() -&gt; {
                    try {
                        Thread.sleep(Duration.ofSeconds(2));
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return 42;
                }, executor)
                .minimalCompletionStage();
    }
}
</code></pre>
<blockquote>
<p>笔者曾在<a href="https://juejin.cn/post/7388332481739882547" target="_blank" rel="noopener nofollow">《深入理解 Future, CompletableFuture, ListenableFuture，回调机制》</a>一文中质疑 CompletionStage#toCompletableFuture 方法破坏了接口设计的相关原则，CompletableFuture#minimalCompletionStage 不如直接使用接口。</p>
<ol>
<li>CompletionStage#toCompletableFuture 表明 CompletableFuture 可以作为 CompletionStage 的默认实现，实现两者类型的快速转换。很多情况下，两者的区别不大。</li>
<li>CompletableFuture#minimalCompletionStage 底层思想是提供只读功能。</li>
<li>这里的实现有点取巧，minimalStage虽然继承自CompleatableFuture，而实际上只是实现了CompletionStage 接口方法。minimalStage 不应该是 CompletableFuture的示例，更好的实现方式是使用委托方式（组合）。</li>
<li>如果子类进行类型检查，使用 instanceOf 或者新版JDK支持的模式匹配，minimalStage 需要进行额外的处理。</li>
<li>CFFU 的实现对于minimalStage做了兼容处理，你可以放心使用。</li>
</ol>
</blockquote>
<h2 id="5-异步写操作">5. 异步写操作</h2>
<pre><code class="language-java">public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier) {
    return completeAsync(supplier, defaultExecutor());
}

public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier,
                                          Executor executor) {
    if (supplier == null || executor == null)
        throw new NullPointerException();
    executor.execute(new AsyncSupply&lt;T&gt;(this, supplier));
    return this;
}
</code></pre>
<p>这两个方法很容易理解，适用于子类返回自己的实现。CompletableFuture#supplyAsync 工厂方法返回的实例是 ComplteableFuture 无法更改。子类可以自己定义自己的工厂方法；用户也可以使用这里的异步写方法。</p>
<h2 id="6-cffu的优化拓展">6. CFFU的优化拓展</h2>
<p>开源项目CFFU（功夫未来）对于CompletableFuture 进行了拓展，以下仅列举和Java9新增功能相关的拓展点：</p>
<ol>
<li>可以在对象创建时指定执行器，后续操作无需重复指定</li>
<li>Java8 版本下可以使用后续版本的功能</li>
<li>提供了相关安全发布功能，比如<a href="https://juejin.cn/post/7411686792342274089" target="_blank" rel="noopener nofollow">安全的超时功能</a></li>
<li>内部的很多便利方法应用了保护性复制方法</li>
<li>CffuFactoryBuilder 支持以参数形式配置是否允许强制重写结果</li>
</ol>
<h2 id="7-实践原则">7. 实践原则</h2>
<ol>
<li>异步方法可以返回 CompletionStage，其相比于CompletableFuture更为安全，同时可以提示用户不要使用阻塞相关方法</li>
<li>就像推荐使用不可变对象一样，推荐默认使用 CompletableFuture#minimalCompletionStage 方法</li>
<li>无论是对于方法入参还是返回结果，使用接口一般都优于实体类</li>
<li>理想的 Future 设计应该是读写分离的，不可变的。虽然 CompletableFuture 并没有完全遵循以上原则，但是我们在使用时应当注意遵循。</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23180723123842592" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-30 10:49">2025-01-30 10:49</span>&nbsp;
<a href="https://www.cnblogs.com/HuaTalkHub">桦说编程</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18695088" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18695088);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18695088', targetLink: 'https://www.cnblogs.com/HuaTalkHub/p/18695088', title: '如何安全发布 CompletableFuture ？Java9新增方法分析' })">举报</a>
</div>
        