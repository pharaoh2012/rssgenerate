
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/AnimeBucket/p/18762631" title="发布于 2025-03-10 14:31">
    <span role="heading" aria-level="2">C语言标准库中的缓冲机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 class="md-meta-block md-end-block"><span class="md-plain">什么是缓冲区</span></h1>
<p class="md-end-block md-p"><span class="md-plain">缓存区是内存空间的一部分，再内存中，内存空间会预留一定的存储空间，这些存储空间是用来缓冲输入和输出的数据，预留的这部分空间就叫做<span class="md-pair-s "><strong><span class="md-plain">缓冲区</span></strong><span class="md-plain">。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">其中缓冲区还会根据对应的是输入设备还是输出设备分为<span class="md-pair-s "><strong><span class="md-plain">输入缓冲区</span></strong><span class="md-plain">和<span class="md-pair-s "><strong><span class="md-plain">输出缓冲区</span></strong><span class="md-plain">。</span></span></span></span></span></p>
<h1 class="md-end-block md-heading md-focus"><span class="md-plain">为什么需要缓冲？</span></h1>
<p class="md-end-block md-p"><span class="md-plain">直接操作硬件（如屏幕、磁盘）的I/O操作非常耗时。就好比如，你每次调用 <span class="md-pair-s"><code>printf</code><span class="md-plain"> 都直接向屏幕写入一个字符，会导致频繁的系统调用，极大降低程序效率。<span class="md-softbreak"> <span class="md-plain">缓冲机制通过将数据暂存在内存中的一块区域（<span class="md-pair-s "><strong><span class="md-plain">缓冲区</span></strong><span class="md-plain">），等待满足特定条件时一次性写入目标设备，从而减少系统调用次数。</span></span></span></span></span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">缓冲的三种模式：</span></h1>
<h2 class="md-end-block md-heading"><span class="md-plain">全缓冲(Fully Buffered)</span></h2>
<p class="md-end-block md-p"><span class="md-plain">数据会陷入导内存的缓冲区里面，知道缓冲区满了或者我们去手动去刷新我们的缓存区，才会一次性将我们缓存区的内容写入到目标设备。</span></p>
<p class="md-end-block md-p"><span class="md-plain">一般来说，全缓冲一般运用在文件操作的一些场景中，就好比如说我们写入文件的是时候，会使用全缓冲。还有就是重定向输出导文件的时候，stdout会从默认的行缓冲切换为全缓冲给。</span></p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span><span class="cm-meta">#include &lt;stdio.h&gt;<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">FILE <span class="cm-operator">*<span class="cm-variable">fp <span class="cm-operator">= <span class="cm-variable">fopen(<span class="cm-string">"output.txt", <span class="cm-string">"w");<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fprintf(<span class="cm-variable">fp, <span class="cm-string">"Hello, World!"); &nbsp;<span class="cm-comment">// 写入缓冲区，但不会立即写入文件<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-comment">// 此时文件内容为空<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fflush(<span class="cm-variable">fp); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 手动刷新缓冲区，内容写入文件<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fclose(<span class="cm-variable">fp); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 关闭文件时也会自动刷新<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-number">0;<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">注意我们代码中的这两个函数，<span class="md-pair-s"><code>fflush()</code><span class="md-plain">和<span class="md-pair-s"><code>fclose()</code><span class="md-plain">如果没有这两个函数的话，我们写入的内容可能会丢失。</span></span></span></span></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">行缓冲(Line Buffered)</span></h2>
<p class="md-end-block md-p"><span class="md-plain">在这种情况下，当在输入和输出中<span class="md-pair-s "><strong><span class="md-plain">遇到换行符或者缓冲区满的时候，执行真正的I/O操作</span></strong><span class="md-plain">。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">这种缓冲模式一般运用再终端输出和交互式程序中，就好比如需要及时的显示提示信息的场景(就好像自动贩卖机提示你printf(“please input your money:”))。</span></p>
<p class="md-end-block md-p"><span class="md-plain">行缓冲一般再遇到<span class="md-pair-s"><code>换行符\n</code><span class="md-plain">，缓冲区满的时候，<span class="md-pair-s"><code>程序正常退出</code><span class="md-plain">的时候还有<span class="md-pair-s"><code>手动刷新时</code><span class="md-plain">后触发。</span></span></span></span></span></span></span></p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span><span class="cm-meta">#include &lt;stdio.h&gt;<br>&nbsp;<span><span class="cm-meta">#include &lt;unistd.h&gt; &nbsp;<span class="cm-comment">// 用于 sleep 函数<br>&nbsp;<span><span>​<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"Start..."); &nbsp; <span class="cm-comment">// 无换行符，不刷新<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">sleep(<span class="cm-number">2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// 等待2秒<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"End\n"); &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 遇到换行符，立即刷新，输出 "Start...End"<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-number">0;<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">结果</span></strong><span class="md-plain">：程序会等待2秒后一次性输出 <span class="md-pair-s"><code>Start...End</code></span></span></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">无缓冲(Unbuffered)</span></h2>
<p class="md-end-block md-p"><span class="md-plain">数据<span class="md-pair-s "><strong><span class="md-plain">直接写入目标设备</span></strong><span class="md-plain">，不经过缓冲区。每次 I/O 操作都会立即生效。其实我们看名字应该就能想到时没有缓冲，那就是说，没有任何触发条件，写入操作集合生效。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">一般用在标准错误流stderr和需要实时反馈的场景，好比如调试信息，关键日志。</span></p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-meta">#include &lt;stdio.h&gt;<br>&nbsp;<span><span>​<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fprintf(<span class="cm-variable">stderr, <span class="cm-string">"Error: File not found!\n"); &nbsp;<span class="cm-comment">// 立即输出<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"This is stdout message."); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 可能延迟输出（行缓冲）<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-number">0;<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">结果</span></strong><span class="md-plain">：<span class="md-pair-s"><code>stderr</code><span class="md-plain"> 的输出会立即显示，而 <span class="md-pair-s"><code>stdout</code><span class="md-plain"> 的输出可能延迟。</span></span></span></span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">如何控制缓冲模式？</span></h1>
<p class="md-end-block md-p"><span class="md-plain">我们知道了有那些缓冲模式之后，我们是不是可以去想想有哪些控制缓冲模式的方法。</span></p>
<p class="md-end-block md-p"><span class="md-plain">我们可以使用<span class="md-pair-s"><code>setvbuf</code><span class="md-plain">函数来自定义缓冲行为。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">有这几个参数：</span></p>
<ol class="ol-list" start="">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><code>_IOFBF</code><span class="md-plain">：全缓冲</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><code>_IOLBF</code><span class="md-plain">：行缓冲</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><code>_IONBF</code><span class="md-plain">：无缓冲</span></span></p>
</li>
</ol>
<h1 class="md-end-block md-heading"><span class="md-plain">常见的问题与解决方案：</span></h1>
<h2 class="md-end-block md-heading"><span class="md-plain">问题一：输出顺序不符合预期</span></h2>
<p class="md-end-block md-p"><span class="md-plain">就好比如这个代码：</span></p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span><span class="cm-meta">#include "stdio.h"<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"A");<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fprintf(<span class="cm-variable">stderr, <span class="cm-string">"B"); &nbsp;<span class="cm-comment">// stderr无缓冲<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"C");<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">我们可以看到他的输出结果是这样的：</span></p>
<blockquote>
<p class="md-end-block md-p"><span class="md-plain">BAC</span></p>
</blockquote>
<p class="md-end-block md-p"><span class="md-plain">这种情况就是输出顺序不符合我们的预期，我们可以使用fflush来去刷新我们的缓存区。</span></p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span><span class="cm-meta">#include "stdio.h"<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"A");<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fflush(<span class="cm-variable">stdout);<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">fprintf(<span class="cm-variable">stderr, <span class="cm-string">"B"); &nbsp;<span class="cm-comment">// stderr无缓冲<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"C");<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<blockquote>
<p class="md-end-block md-p"><span class="md-plain">这样写就可以解决这个问题了。</span></p>
</blockquote>
<h2 class="md-end-block md-heading"><span class="md-plain">问题二：调试信息丢失</span></h2>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded">&nbsp;<span><span class="cm-meta">#include "stdio.h"<br>&nbsp;<span><span class="cm-variable-3">int <span class="cm-def">main() {<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable">printf(<span class="cm-string">"Debug info"); <span class="cm-comment">// 无换行符<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-variable-3">int <span class="cm-variable-3">*<span class="cm-variable">p <span class="cm-operator">= <span class="cm-variable">NULL;<br>&nbsp;<span> &nbsp; &nbsp;<span class="cm-operator">*<span class="cm-variable">p <span class="cm-operator">= <span class="cm-number">42; <span class="cm-comment">// 段错误，程序崩溃<br>&nbsp;<span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">首先我们来分析一下这个代码，我们的<span class="md-pair-s"><code>printf</code><span class="md-plain">中没有<span class="md-pair-s"><code>\n</code><span class="md-plain">所以会造成<span class="md-pair-s"><code>Debug info</code><span class="md-plain">可能不会立即显示在控制台上，所以我们首先是得去使用<span class="md-pair-s"><code>fflush</code><span class="md-plain">来刷新缓冲区。</span></span></span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">然后我们定义了一个空指针，然后我们又尝试尝试通过 <span class="md-pair-s"><code>p</code><span class="md-plain"> 访问内存并给它赋值，但是这样肯定是有问题的，由于 <span class="md-pair-s"><code>p</code><span class="md-plain"> 是 <span class="md-pair-s"><code>NULL</code><span class="md-plain">，这将导致段错误（Segmentation Fault），程序会崩溃。</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">这种情况我们也是可以使用<span class="md-pair-s"><code>fflush</code><span class="md-plain">来进行刷新缓冲区的。</span></span></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">问题三：输入输出混合时的提示延迟</span></h2>
<p class="md-end-block md-p"><span class="md-plain">这个是这样的：</span></p>
<p class="md-end-block md-p"><span class="md-image md-img-loaded" data-src="https://animebucket-1313463726.cos.ap-guangzhou.myqcloud.com/imgs/202503101418865.png"><img src="https://animebucket-1313463726.cos.ap-guangzhou.myqcloud.com/imgs/202503101418865.png" alt="image-20250310141818702"></span></p>
<p class="md-end-block md-p"><span class="md-plain">这里的我们只能先输入，然后才会提示我们的输出。</span></p>
<p class="md-end-block md-p"><span class="md-plain">我们还是直接使用<span class="md-pair-s"><code>fflush</code><span class="md-plain">去刷新缓冲区就可以了。</span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">总结</span></h1>
<p class="md-end-block md-p"><span class="md-plain">C语言的缓冲机制是I/O高效性的核心设计，但需要开发者深刻理解其行为。</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓冲模式决定刷新时机</span></strong><span class="md-plain">：全缓冲看容量，行缓冲看换行，无缓冲即写即走。</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">手动控制是王道</span></strong><span class="md-plain">：在需要实时性的地方，用<span class="md-pair-s"><code>fflush</code><span class="md-plain">或<span class="md-pair-s"><code>stderr</code><span class="md-plain">。</span></span></span></span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">跨平台注意细节</span></strong><span class="md-plain">：不同系统对行缓冲的实现可能有差异。</span></span></p>
</li>
<li class="md-list-item">
<div><span class="md-plain">&nbsp;</span></div>
</li>
</ul>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.022105524673611113" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 15:47">2025-03-10 14:31</span>&nbsp;
<a href="https://www.cnblogs.com/AnimeBucket">Anime_Bucket</a>&nbsp;
阅读(<span id="post_view_count">38</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18762631" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18762631);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18762631', targetLink: 'https://www.cnblogs.com/AnimeBucket/p/18762631', title: 'C语言标准库中的缓冲机制' })">举报</a>
</div>
        