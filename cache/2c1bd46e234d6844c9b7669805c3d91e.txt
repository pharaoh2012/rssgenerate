
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18651547" title="发布于 2025-01-04 10:37">
    <span role="heading" aria-level="2">list和字典哪个性能高？for循环下哪个性能高？为啥？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在选择数据结构时，性能取决于具体的操作和使用场景。列表（List） 和 字典（Dictionary） 是两种常见的数据结构，它们有不同的性能特性。以下是对这两种数据结构在不同操作下的性能比较，特别是针对 for 循环下的性能表现。</p>
<h2 id="列表list">列表（List）</h2>
<p>列表 是一种有序的集合，通常用于存储一组元素，并按顺序访问这些元素。</p>
<h3 id="主要特点">主要特点</h3>
<ol>
<li>
<p>有序性：</p>
<ul>
<li>列表中的元素按顺序存储。</li>
<li>可以通过索引快速访问特定位置的元素。</li>
</ul>
</li>
<li>
<p>动态大小：</p>
<ul>
<li>列表的大小可以动态变化。</li>
<li>支持添加、删除和修改元素。</li>
</ul>
</li>
<li>
<p>内存分配</p>
<ul>
<li>内部使用数组来存储元素。</li>
<li>在需要时会动态调整数组大小，可能会涉及内存复制操作。</li>
</ul>
</li>
</ol>
<h3 id="常见操作及其性能">常见操作及其性能</h3>
<ol>
<li>
<p>按索引访问元素：</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>非常快，因为列表通过索引直接访问元素。</li>
</ul>
</li>
<li>
<p>添加元素：</p>
<ul>
<li>时间复杂度：平均 O(1)，最坏情况下 O(n)（当需要调整数组大小时）</li>
<li>通常很快，但在某些情况下可能需要额外的内存复制操作</li>
</ul>
</li>
<li>
<p>删除元素：</p>
<ul>
<li>时间复杂度：O(n)（需要移动后续元素）</li>
<li>较慢，因为删除元素后需要移动后续元素以保持顺序。</li>
</ul>
</li>
<li>
<p>遍历元素：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>遍历操作的时间与列表的大小成线性关系。</li>
</ul>
</li>
</ol>
<h2 id="字典dictionary">字典（Dictionary）</h2>
<p>字典 是一种键值对（Key-Value Pair）的集合，通常用于快速查找、插入和删除元素。</p>
<h3 id="主要特点-1">主要特点</h3>
<ol>
<li>无序性：
<ul>
<li>字典中的元素按键的哈希值存储，不保证顺序。</li>
<li>可以通过键快速访问对应的值。</li>
</ul>
</li>
<li>动态大小：
<ul>
<li>字典的大小可以动态变化。</li>
<li>支持添加、删除和修改键值对。</li>
</ul>
</li>
<li>哈希表实现：
<ul>
<li>内部使用哈希表来存储键值对。</li>
<li>通过键的哈希值进行快速定位。</li>
</ul>
</li>
</ol>
<h3 id="常见操作及其性能-1">常见操作及其性能</h3>
<ol>
<li>按键访问元素：
<ul>
<li>时间复杂度：平均 O(1)，最坏情况下 O(n)（哈希冲突时）</li>
<li>非常快，因为字典通过键的哈希值直接访问元素。</li>
</ul>
</li>
<li>添加键值对：
<ul>
<li>时间复杂度：平均 O(1)，最坏情况下 O(n)（当需要调整哈希表大小时）</li>
<li>通常很快，但在某些情况下可能需要额外的内存复制操作。</li>
</ul>
</li>
<li>删除键值对：
<ul>
<li>时间复杂度：平均 O(1)，最坏情况下 O(n)（哈希冲突时）</li>
<li>较快，因为删除操作不需要移动其他元素。</li>
</ul>
</li>
<li>遍历键值对：
<ul>
<li>时间复杂度：O(n)</li>
<li>遍历操作的时间与字典的大小成线性关系。</li>
</ul>
</li>
</ol>
<h3 id="在for循环下的性能比较">在for循环下的性能比较</h3>
<ol>
<li>
<p>遍历列表（List）</p>
<pre><code> using System;
 using System.Collections.Generic;

 public class ListExample
 {
 	public static void Main()
 	{
 		List&lt;int&gt; list = new List&lt;int&gt;();
 		for (int i = 0; i &lt; 1000000; i++)
 		{
 			list.Add(i);
 		}

 		// 遍历列表
 		for (int i = 0; i &lt; list.Count; i++)
 		{
 			int value = list[i];
 			// 处理 value
 		}
 	}
 }
</code></pre>
</li>
</ol>
<h4 id="性能">性能：</h4>
<ul>
<li>按索引访问元素的时间复杂度为 O(1)。</li>
<li>遍历整个列表的时间复杂度为 O(n)。</li>
<li>列表的遍历通常非常高效，因为它是顺序访问，CPU 缓存友好。</li>
</ul>
<ol start="2">
<li>
<p>遍历字典（Dictionary）</p>
<pre><code> 	using System;
 	using System.Collections.Generic;

 	public class DictionaryExample
 	{
 		public static void Main()
 		{
 			Dictionary&lt;int, int&gt; dict = new Dictionary&lt;int, int&gt;();
 			for (int i = 0; i &lt; 1000000; i++)
 			{
 				dict[i] = i;
 			}

 			// 遍历字典
 			foreach (var kvp in dict)
 			{
 				int key = kvp.Key;
 				int value = kvp.Value;
 				// 处理 key 和 value
 			}
 		}
 	}
</code></pre>
</li>
</ol>
<h4 id="性能-1">性能：</h4>
<ul>
<li>遍历字典的时间复杂度为 O(n)。</li>
<li>字典的遍历涉及哈希表的迭代，虽然也是线性时间复杂度，但由于哈希表的非顺序性，可能会比列表的遍历稍微慢一些。</li>
<li>CPU 缓存的利用效率可能相对较低，因为字典的内部结构是基于哈希表，而不是简单的数组。</li>
</ul>
<h3 id="具体性能差异">具体性能差异</h3>
<ol>
<li>按索引访问元素：
<ul>
<li>列表（List）：按索引访问元素的时间复杂度为 O(1)，非常高效。</li>
<li>字典（Dictionary）：按键访问元素的时间复杂度为平均 O(1)，但在哈希冲突时会稍微慢一些。</li>
</ul>
</li>
<li>遍历元素：
<ul>
<li>列表（List）：顺序遍历列表，CPU 缓存友好，通常较快。</li>
<li>字典（Dictionary）：遍历哈希表，非顺序访问，CPU 缓存利用率较低，可能较慢。</li>
</ul>
</li>
<li>使用场景</li>
</ol>
<ul>
<li>
<p>列表（List）：</p>
<ul>
<li>适用于需要按顺序访问元素的场景。</li>
<li>适用于需要频繁遍历元素的场景。</li>
</ul>
</li>
<li>
<p>字典（Dictionary）：</p>
<ul>
<li>
<p>适用于需要快速查找、插入和删除键值对的场景。</p>
</li>
<li>
<p>适用于需要通过键快速访问值的场景。<br>
示例：遍历列表和字典的性能比较<br>
以下是一个简单的示例，比较遍历列表和字典的性能。</p>
<pre><code>  using System;
  using System.Collections.Generic;
  using System.Diagnostics;
  using System.Linq;

  public class PerformanceComparison
  {
  	public static void Main()
  	{
  		int size = 1000000;

  		// 创建列表
  		List&lt;int&gt; list = new List&lt;int&gt;();
  		for (int i = 0; i &lt; size; i++)
  		{
  			list.Add(i);
  		}

  		// 创建字典
  		Dictionary&lt;int, int&gt; dict = new Dictionary&lt;int, int&gt;();
  		for (int i = 0; i &lt; size; i++)
  		{
  			dict[i] = i;
  		}

  		// 遍历列表的性能测试
  		Stopwatch listStopwatch = new Stopwatch();
  		listStopwatch.Start();
  		for (int i = 0; i &lt; list.Count; i++)
  		{
  			int value = list[i];
  			// 处理 value
  		}
  		listStopwatch.Stop();
  		Console.WriteLine($"List traversal time: {listStopwatch.ElapsedMilliseconds} ms");

  		// 遍历字典的性能测试
  		Stopwatch dictStopwatch = new Stopwatch();
  		dictStopwatch.Start();
  		foreach (var kvp in dict)
  		{
  			int key = kvp.Key;
  			int value = kvp.Value;
  			// 处理 key 和 value
  		}
  		dictStopwatch.Stop();
  		Console.WriteLine($"Dictionary traversal time: {dictStopwatch.ElapsedMilliseconds} ms");
  	}
  }
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="运行结果示例">运行结果示例</h4>
<pre><code>List traversal time: 15 ms
Dictionary traversal time: 25 ms
</code></pre>
<h4 id="解释">解释</h4>
<ol>
<li>列表（List）：
<ul>
<li>列表的遍历时间通常较短，因为它是顺序访问，CPU 缓存友好。</li>
<li>每次访问都是按顺序读取内存中的数据，减少了缓存未命中的情况。</li>
</ul>
</li>
<li>字典（Dictionary）：
<ul>
<li>字典的遍历时间稍长，因为它是迭代哈希表。</li>
<li>哈希表的内部结构不保证顺序，可能需要更多的内存访问和缓存未命中的情况。</li>
</ul>
</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<ol>
<li>选择合适的数据结构：
<ul>
<li>如果你需要按顺序访问元素或频繁遍历元素，列表（List）通常是更好的选择。</li>
<li>如果你需要快速查找、插入和删除键值对，字典（Dictionary）通常是更好的选择。</li>
</ul>
</li>
<li>避免在生产环境中禁用保护模式：
<ul>
<li>如果你在生产环境中遇到 Redis 保护模式的问题，建议设置密码或配置其他安全措施，而不是禁用保护模式。<br>
通过理解列表和字典的性能特性及其使用场景，可以更好地选择合适的数据结构，从而提高应用程序的性能和可靠性。</li>
</ul>
</li>
</ol>
<h3 id="总结">总结</h3>
<ol>
<li>列表（List）：
<ul>
<li>有序集合，按索引访问元素的时间复杂度为 O(1)。</li>
<li>遍历列表的时间复杂度为 O(n)，顺序访问，CPU 缓存友好。</li>
</ul>
</li>
<li>字典（Dictionary）：
<ul>
<li>键值对集合，按键访问元素的时间复杂度为平均 O(1)。</li>
<li>遍历字典的时间复杂度为 O(n)，迭代哈希表，CPU 缓存利用率较低。</li>
</ul>
</li>
<li>遍历性能：
<ul>
<li>在 for 循环下，遍历列表通常比遍历字典更快，因为列表是顺序访问，而字典是迭代哈希表。</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>列表：适用于按顺序访问元素或频繁遍历元素的场景。</li>
<li>字典：适用于快速查找、插入和删除键值对的场景。<br>
通过选择合适的数据结构和理解其性能特性，可以有效提高应用程序的性能和效率。</li>
</ul>
</li>
</ol>
<p>参考资源</p>
<ul>
<li>
<p>Microsoft Docs - List<t>：<br>
<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=net-9.0" title="List<T> 文档" target="_blank" rel="noopener nofollow">List<t> 文档</t></a></t></p>
</li>
<li>
<p>Microsoft Docs - Dictionary&lt;TKey, TValue&gt;：<br>
<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2?view=net-9.0" title="Dictionary<TKey, TValue> 文档" target="_blank" rel="noopener nofollow">Dictionary&lt;TKey, TValue&gt; 文档</a></p>
</li>
<li>
<p>Redis 官方文档：<br>
<a href="https://redis.io/docs/latest/" title="Redis 官方文档" target="_blank" rel="noopener nofollow">Redis 官方文档</a></p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7333607137534722" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-04 10:38">2025-01-04 10:37</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18651547" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18651547);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18651547', targetLink: 'https://www.cnblogs.com/chenshibao/p/18651547', title: 'list和字典哪个性能高？for循环下哪个性能高？为啥？' })">举报</a>
</div>
        