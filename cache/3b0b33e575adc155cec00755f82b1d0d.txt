
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MelonTe/p/18737143" title="发布于 2025-02-25 20:03">
    <span role="heading" aria-level="2">Go实现动态开点线段树</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1线段树介绍">1、线段树介绍</h1>
<p>线段树是一种用于高效处理区间查询和区间更新的数据结构，当我们需要解决一个频繁更新区间值的问题的时候，就可以采用线段树的结构进行解决。线段树的核心思想是将区间分为多个子区间进行管理，越往下区间范围越小，根节点表示整个线段树能表示的区间。</p>
<p>本文记录使用Go实现动态开点线段树的方式，该模板的线段树用于解决区间求和问题，还有求解区间最小值、最大值的线段树可以进行微调修改即可。</p>
<p>区间查询、区间更新的时间复杂度均为<code>O(logN)</code>。</p>
<h1 id="2动态开点线段树实现">2、动态开点线段树实现</h1>
<p>动态开点的核心在于，需要缩小范围，即进入子节点的时候再进行创建，相对于使用数组来实现线段树，可以更大的减小空间开销。</p>
<h2 id="1线段树节点">1、线段树节点</h2>
<p>一个节点需要记录它的左子节点、右子节点、当前节点表示的区间的和<code>val</code>，以及暂未下推给子节点的懒惰值<code>lazy</code>。</p>
<pre><code class="language-go">type SegTreeNode struct {
	lazy  int
	val   int
	left  *SegTreeNode
	right *SegTreeNode
}
</code></pre>
<h2 id="2线段树的创建">2、线段树的创建</h2>
<p>整个线段树只需要记录一个根节点以及该线段树表示的区间上届。</p>
<pre><code class="language-go">type SegTree struct {
	//线段树的范围，0~N
	N    int
	root *SegTreeNode
}

// 创建线段树
func CreateSegTree(n int) *SegTree {
	return &amp;SegTree{
		N: n,
		root: &amp;SegTreeNode{
			lazy:  0,
			val:   0,
			left:  nil,
			right: nil,
		},
	}
}
</code></pre>
<h2 id="3递归上推">3、递归上推</h2>
<p>当更新完了子节点后，回到当前节点的时候，需要更新当前节点的值，表示从树的底部上推值。</p>
<pre><code class="language-go">// 递归上推
func (ST *SegTree) Pushup(node *SegTreeNode) {
	node.val = node.left.val + node.right.val
}
</code></pre>
<h2 id="4懒惰下推">4、懒惰下推</h2>
<p>当需要缩小查找区间的时候，需要向下查找，这时候要先把懒惰值下推，防止查找出错误的结果，也防止子节点还未创建。</p>
<pre><code class="language-go">// 同步下推
func (ST *SegTree) Pushdown(node *SegTreeNode, leftnum, rightnum int) {
	//创建左右节点
	if node.left == nil {
		node.left = new(SegTreeNode)
	}
	if node.right == nil {
		node.right = new(SegTreeNode)
	}
	//下推节点懒惰标记
	if node.lazy == 0 {
		return
	}
	node.left.val += leftnum * node.lazy
	node.right.val += rightnum * node.lazy
	//下推
	node.left.lazy += node.lazy
	node.right.lazy += node.lazy
	//置零
	node.lazy = 0
}
</code></pre>
<p>首先先创建左右节点，如果没有需要下推的懒惰标记则直接返回。否则就更新左右节点的<code>val</code>和<code>lazy</code>。</p>
<h2 id="5更新操作">5、更新操作</h2>
<pre><code class="language-go">// 更新操作，更新[left,right]区间的值，start和end是当前处在区间
func (ST *SegTree) Update(node *SegTreeNode, start, end, left, right, val int) {
	if left &lt;= start &amp;&amp; end &lt;= right {
		//锁定区间，进行更新
		node.val += (end - start + 1) * val
		node.lazy += val
		return
	}
	//缩小区间
	mid := (start + end) / 2
	//需要找到子节点，先下推懒惰标记
	ST.Pushdown(node, mid-start+1, end-mid)
	if mid &gt;= left {
		ST.Update(node.left, start, mid, left, right, val)
	}
	if mid+1 &lt;= right {
		ST.Update(node.right, mid+1, end, left, right, val)
	}
	//递归
	ST.Pushup(node)
}
</code></pre>
<p><code>left</code>和<code>right</code>表示要更新的区间，而<code>start</code>和<code>end</code>表示当前区间。如果当前区间处在需要更新的区间内，则直接更新区间值以及懒惰值，然后直接返回即可，此时不需要继续更新下面节点的值，这是动态开点的关键所在。</p>
<p>若当前区间并未完全处在需要更新的区间内，则二分该区间，缩小范围进行更新。</p>
<p>例如在一次操作需要更新的是<code>[30,40]</code>范围的值，而当前区间处在<code>[25,50]</code>中，当前区间并未完全处在更新区间，则二分为<code>[25,37]</code>和<code>[38,50]</code>，左区间和右区间均和需要更新的区间存在<strong>交集</strong>，那么就往下更新，直到更新区间<strong>包含</strong>当前区间。</p>
<p>在更新完后，进行一次上推。</p>
<h2 id="6查询操作">6、查询操作</h2>
<p>与更新操作类似，只需要一个<code>ans</code>来记录答案并且返回。</p>
<pre><code class="language-go">// 查询操作，返回区间的值
func (ST *SegTree) Query(node *SegTreeNode, start, end, left, right int) int {
	if left &lt;= start &amp;&amp; end &lt;= right {
		return node.val
	}
	mid := (start + end) / 2
	ST.Pushdown(node, mid-start+1, end-mid)
	ans := 0
	if left &lt;= mid {
		ans += ST.Query(node.left, start, mid, left, right)
	}
	if mid+1 &lt;= right {
		ans += ST.Query(node.right, mid+1, end, left, right)
	}
	return ans
}
</code></pre>
<h1 id="3尝试题目">3、尝试题目</h1>
<p><a href="https://leetcode.cn/problems/my-calendar-i/" target="_blank" rel="noopener nofollow">LeetCode我的日程表安排I</a></p>
<p>[LeetCode我的日程表安排III](<a href="https://leetcode.cn/problems/my-calendar-iii/" target="_blank" rel="noopener nofollow">732. 我的日程安排表 III - 力扣（LeetCode）</a>)</p>
<p><a href="https://leetcode.cn/problems/design-memory-allocator/?envType=daily-question&amp;envId=2025-02-25" target="_blank" rel="noopener nofollow">2502. 设计内存分配器 - 力扣（LeetCode）</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.017111567" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-25 20:04">2025-02-25 20:03</span>&nbsp;
<a href="https://www.cnblogs.com/MelonTe">MelonTe</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737143" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737143);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737143', targetLink: 'https://www.cnblogs.com/MelonTe/p/18737143', title: 'Go实现动态开点线段树' })">举报</a>
</div>
        