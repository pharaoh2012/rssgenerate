
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dayue-bc/p/18992299" title="发布于 2025-07-18 23:16">
    <span role="heading" aria-level="2">创建型模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1873246/202507/1873246-20250718231602386-921620623.png" alt="创建型模式" class="desc_img">
        创建型模式是设计模式的核心分支，专注于对象创建机制的优化，通过封装对象实例化过程，提升系统的灵活性与可扩展性。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>创建型模式是设计模式的核心分支，专注于对象创建机制的优化，通过封装对象实例化过程，提升系统的灵活性与可扩展性。在分布式系统中，由于多节点协作、网络通信延迟、状态一致性等特性，传统单体环境下的创建型模式需进行适应性演化。本文从分布式场景出发，系统解析单例、工厂方法、抽象工厂、建造者、原型五大创建型模式的核心原理、分布式变种及实战应用。</p>
</blockquote>
<h2 id="一单例模式分布式环境下的唯一性保障">一、单例模式：分布式环境下的唯一性保障</h2>
<h3 id="11-单体与分布式单例的本质区别">1.1 单体与分布式单例的本质区别</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>单体环境单例</th>
<th>分布式环境单例</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用域</td>
<td>进程内唯一</td>
<td>集群内唯一（跨 JVM 进程）</td>
</tr>
<tr>
<td>实现基础</td>
<td>类加载机制（饿汉 / 懒汉）</td>
<td>分布式协调服务（ZooKeeper/Redis）</td>
</tr>
<tr>
<td>核心挑战</td>
<td>线程安全</td>
<td>节点一致性、网络分区、故障恢复</td>
</tr>
</tbody>
</table>
<h3 id="12-分布式单例的实现方案">1.2 分布式单例的实现方案</h3>
<h4 id="1-基于-zookeeper-的分布式单例">1. 基于 ZooKeeper 的分布式单例</h4>
<pre><code>public class DistributedSingleton { 

   private static final String LOCK_PATH = "/distributed/singleton"; 

   private static DistributedSingleton instance; 

   private static CuratorFramework zkClient; 

   private DistributedSingleton() {} 

   public static DistributedSingleton getInstance() throws Exception { 

       if (instance == null) { 

           // 1. 创建ZooKeeper分布式锁 
           InterProcessMutex lock = new InterProcessMutex(zkClient, LOCK_PATH); 

           try { 

               // 2. 尝试获取锁（超时时间10秒） 
               if (lock.acquire(10, TimeUnit.SECONDS)) { 
                   // 3. 双重检查（防止并发创建） 
                   if (instance == null) { 
                       instance = new DistributedSingleton(); 
                       // 4. 在ZK创建临时节点，节点存在表示单例已初始化 
                       zkClient.createEphemeral(LOCK_PATH); 
                   } 
               } 
           } finally { 
               // 5. 释放锁 
               if (lock.isAcquiredInThisProcess()) { 
                   lock.release(); 
               } 
           } 
       } 
       return instance; 
   } 
} 
</code></pre>
<h4 id="2-方案对比与适用场景">2. 方案对比与适用场景</h4>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>优势</th>
<th>缺陷</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ZooKeeper</strong></td>
<td>强一致性，自动故障转移</td>
<td>依赖 ZK 集群，性能开销较高</td>
<td>核心服务（如分布式任务调度器）</td>
</tr>
<tr>
<td><strong>Redis 锁</strong></td>
<td>性能优异，部署简单</td>
<td>需处理锁超时与续租问题</td>
<td>高并发场景（如分布式计数器）</td>
</tr>
<tr>
<td><strong>数据库锁</strong></td>
<td>无需额外组件</td>
<td>性能差，易成为瓶颈</td>
<td>低频率创建场景（如配置中心初始化）</td>
</tr>
</tbody>
</table>
<h2 id="二工厂方法模式分布式服务的动态实例化">二、工厂方法模式：分布式服务的动态实例化</h2>
<h3 id="21-模式核心与分布式适配">2.1 模式核心与分布式适配</h3>
<h4 id="1-基础结构">1. 基础结构</h4>
<p>工厂方法模式通过定义抽象工厂接口，由子类决定具体产品的创建逻辑。在分布式系统中，该模式常用于服务实例的动态创建，适配不同环境（如生产 / 测试）或不同实现（如 MySQL/PostgreSQL 数据源）。</p>
<h4 id="2-分布式服务发现中的工厂方法">2. 分布式服务发现中的工厂方法</h4>
<pre><code>// 抽象工厂：服务客户端工厂 
public interface ServiceClientFactory { 
   ServiceClient createClient(String serviceName); 
} 

// 具体工厂：REST API客户端工厂 
public class RestClientFactory implements ServiceClientFactory { 

   @Override 
   public ServiceClient createClient(String serviceName) { 

       // 从服务注册中心获取服务地址 
       String serviceUrl = serviceDiscovery.getServiceUrl(serviceName); 
       return new RestClient(serviceUrl); 
   } 
} 

// 具体工厂：RPC客户端工厂 
public class RpcClientFactory implements ServiceClientFactory { 

   @Override 
   public ServiceClient createClient(String serviceName) { 
       // 基于Dubbo创建RPC客户端 
       return new DubboClient(serviceName); 
   } 
} 

// 客户端使用 
public class ServiceConsumer { 
   private ServiceClientFactory factory; 
   public void invokeService(String serviceName) { 
       // 根据配置动态选择工厂（如配置文件指定"rpc"或"rest"） 
       ServiceClient client = factory.createClient(serviceName); 
       client.invoke(); 
   } 
} 
</code></pre>
<h3 id="22-关键优势与扩展">2.2 关键优势与扩展</h3>
<ul>
<li><strong>动态适配</strong>：通过工厂方法透明切换服务实现（如从 MySQL 切换到 TiDB，无需修改业务代码）。</li>
<li><strong>服务治理集成</strong>：工厂内部可集成负载均衡（如从 Nacos 获取服务列表后按权重选择实例）。</li>
<li><strong>容错扩展</strong>：在工厂中实现客户端熔断降级（如创建<code>ResilientClient</code>包装原始客户端）。</li>
</ul>
<h2 id="三抽象工厂模式跨组件的一致性创建">三、抽象工厂模式：跨组件的一致性创建</h2>
<h3 id="31-模式架构与分布式应用">3.1 模式架构与分布式应用</h3>
<p>抽象工厂模式通过定义一系列相关或相互依赖的对象的创建接口，确保组件间的兼容性。在分布式系统中，该模式常用于多组件协同创建（如数据库 + 缓存 + 消息队列的组合配置）。</p>
<h4 id="实战案例多环境存储组件工厂">实战案例：多环境存储组件工厂</h4>
<pre><code>// 抽象产品：缓存组件 
public interface Cache { 
   void set(String key, String value); 
   String get(String key); 
} 

// 抽象产品：数据库组件 
public interface Database { 

   void execute(String sql); 
} 

// 抽象工厂：存储组件工厂 
public interface StorageFactory { 
   Cache createCache(); 
   Database createDatabase(); 
} 

// 具体工厂：生产环境（Redis + MySQL） 
public class ProductionStorageFactory implements StorageFactory { 

   @Override 
   public Cache createCache() { 
       return new RedisCache("prod-redis:6379"); 
   } 
   
   @Override 
   public Database createDatabase() { 
       return new MySQLDatabase("prod-mysql:3306"); 
   } 
} 

// 具体工厂：测试环境（本地缓存 + H2） 
public class TestStorageFactory implements StorageFactory { 

   @Override 
   public Cache createCache() { 
       return new LocalCache(); 
   } 

   @Override 
   public Database createDatabase() { 
       return new H2Database("test-h2:mem"); 
   } 
} 
</code></pre>
<h3 id="32-分布式场景价值">3.2 分布式场景价值</h3>
<ul>
<li><strong>环境一致性</strong>：确保同一环境下的组件版本兼容（如生产环境的 Redis 与 MySQL 版本匹配）。</li>
<li><strong>部署灵活性</strong>：通过切换工厂实现一键部署到不同环境（无需修改组件初始化逻辑）。</li>
</ul>
<h2 id="四建造者模式复杂分布式对象的构建">四、建造者模式：复杂分布式对象的构建</h2>
<h3 id="41-模式核心与分布式适配">4.1 模式核心与分布式适配</h3>
<p>建造者模式将复杂对象的构建与表示分离，通过分步构建与导演类协调，生成不同配置的对象。在分布式系统中，该模式常用于构建复杂配置对象（如分布式任务、集群节点配置）。</p>
<h4 id="实战案例分布式任务构建器">实战案例：分布式任务构建器</h4>
<pre><code>// 复杂对象：分布式任务 
public class DistributedTask { 

   private String taskId; 

   private List&lt;String&gt; targetNodes; // 目标节点列表 

   private int retryCount; // 重试次数 

   private boolean isParallel; // 是否并行执行 

   private Map&lt;String, String&gt; params; // 任务参数 

   // 私有构造器，仅允许建造者创建 
   private DistributedTask(Builder builder) { 
       this.taskId = builder.taskId; 
       this.targetNodes = builder.targetNodes; 
       this.retryCount = builder.retryCount; 
       this.isParallel = builder.isParallel; 
       this.params = builder.params; 
   } 

   // 建造者 
   public static class Builder { 
       private String taskId; 
       private List&lt;String&gt; targetNodes = new ArrayList&lt;&gt;(); 
       private int retryCount = 3; // 默认重试3次 
       private boolean isParallel = false; 
       private Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); 
       public Builder taskId(String taskId) { 
           this.taskId = taskId; 
           return this; 
       } 

       public Builder addTargetNode(String node) { 
           this.targetNodes.add(node); 
           return this; 
       } 

       public Builder retryCount(int retryCount) { 
           this.retryCount = retryCount; 
           return this; 
       } 

       public Builder parallel(boolean isParallel) { 
           this.isParallel = isParallel; 
           return this; 
       } 

       public Builder param(String key, String value) { 
           this.params.put(key, value); 
           return this; 
       } 

       // 构建方法：校验参数并生成任务对象 
       public DistributedTask build() { 
           if (taskId == null || targetNodes.isEmpty()) { 
               throw new IllegalArgumentException("任务ID和目标节点不能为空"); 
           } 
           return new DistributedTask(this); 
       } 
   } 
} 

// 使用示例 
public class TaskScheduler { 
   public void submitTask() { 
       // 构建分布式任务：ID为"backup-1"，在node1/node2并行执行，重试5次 
       DistributedTask task = new DistributedTask.Builder() 
           .taskId("backup-1") 
           .addTargetNode("node1") 
           .addTargetNode("node2") 
           .parallel(true) 
           .retryCount(5) 
           .param("path", "/data/backup") 
           .build(); 
       taskExecutor.execute(task); 
   } 
} 
</code></pre>
<h3 id="42-分布式场景优势">4.2 分布式场景优势</h3>
<ul>
<li><strong>参数校验</strong>：在<code>build()</code>方法中集中校验分布式对象的合法性（如目标节点是否在集群中存在）。</li>
<li><strong>配置可读性</strong>：链式调用清晰表达对象的构建逻辑（如<code>parallel(true)</code>明确表示并行执行）。</li>
<li><strong>版本兼容</strong>：新增参数时只需扩展建造者方法，不影响旧版本代码（如添加<code>timeout(int)</code>方法）。</li>
</ul>
<h2 id="五原型模式分布式系统中的对象复制">五、原型模式：分布式系统中的对象复制</h2>
<h3 id="51-模式核心与分布式挑战">5.1 模式核心与分布式挑战</h3>
<p>原型模式通过复制现有对象生成新实例，避免重复初始化开销。在分布式系统中，该模式常用于对象的跨节点复制（如缓存同步、会话复制），但需解决序列化、深拷贝及一致性问题。</p>
<h4 id="1-分布式原型的实现基于序列化">1. 分布式原型的实现（基于序列化）</h4>
<pre><code>// 可复制对象：用户会话 
public class UserSession implements Cloneable, Serializable { 
   private String sessionId; 
   private String userId; 
   private Map&lt;String, Object&gt; attributes; // 会话属性 

   // 深拷贝实现（支持跨节点传输） 
   @Override 
   public UserSession clone() { 

       try { 
           // 序列化实现深拷贝（适用于跨JVM复制） 
           ByteArrayOutputStream bos = new ByteArrayOutputStream(); 
           ObjectOutputStream oos = new ObjectOutputStream(bos); 
           oos.writeObject(this); 
           ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); 
           ObjectInputStream ois = new ObjectInputStream(bis); 
           return (UserSession) ois.readObject(); 
       } catch (Exception e) { 
           throw new RuntimeException("Session复制失败", e); 
       } 
   } 

   // 集群复制方法：将会话复制到其他节点 
   public void replicateTo(List&lt;String&gt; targetNodes) { 

       for (String node : targetNodes) { 
           UserSession copy = this.clone(); 
           // 通过RPC将复制对象发送到目标节点 
           clusterClient.send(node, "session/replicate", copy); 
       } 
   } 
} 
</code></pre>
<h4 id="2-分布式场景的优化策略">2. 分布式场景的优化策略</h4>
<ul>
<li><strong>增量复制</strong>：仅复制修改的属性（如通过<code>dirty</code>标记），减少网络传输量。</li>
<li><strong>版本控制</strong>：为复制对象添加版本号，避免旧版本覆盖新版本（如<code>version=3</code>的对象无法覆盖<code>version=5</code>的对象）。</li>
</ul>
<h2 id="六面试高频问题深度解析">六、面试高频问题深度解析</h2>
<h3 id="61-基础概念类问题">6.1 基础概念类问题</h3>
<p><strong>Q：分布式环境下的单例模式与单体环境有何不同？如何实现分布式单例？</strong></p>
<p>A：</p>
<ul>
<li>
<p><strong>核心差异</strong>：单体单例仅需保证进程内唯一（依赖类加载机制），分布式单例需保证集群内唯一（跨 JVM 进程），需解决节点一致性与网络分区问题。</p>
</li>
<li>
<p><strong>实现方案</strong>：</p>
</li>
</ul>
<ol>
<li><strong>ZooKeeper 临时节点</strong>：通过抢占 ZK 临时节点保证唯一实例，节点失效时自动释放（适合强一致性场景）。</li>
<li><strong>Redis 分布式锁</strong>：利用<code>SET NX</code>命令实现锁机制，配合过期时间避免死锁（适合高并发场景）。</li>
</ol>
<p><strong>Q：建造者模式与工厂模式的核心区别？在分布式配置构建中如何选择？</strong></p>
<p>A：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>建造者模式</th>
<th>工厂模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心目标</td>
<td>复杂对象的分步构建与定制化</td>
<td>产品族的批量创建</td>
</tr>
<tr>
<td>灵活性</td>
<td>高（支持细粒度参数配置）</td>
<td>中（固定流程，参数可选范围有限）</td>
</tr>
<tr>
<td>适用场景</td>
<td>多参数、多配置组合的对象</td>
<td>标准化产品的创建</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>分布式配置选择</strong>：优先使用建造者模式，因其支持细粒度配置（如分布式任务的节点列表、重试次数、并行策略等多维度参数），且构建过程清晰可追溯。</li>
</ul>
<h3 id="62-实战设计类问题">6.2 实战设计类问题</h3>
<p><strong>Q：如何用工厂模式设计一个支持多注册中心（Nacos/Eureka/Consul）的服务发现组件？</strong></p>
<p>A：</p>
<ol>
<li>
<p><strong>抽象工厂接口</strong>：定义<code>RegistryFactory</code>，包含<code>createServiceDiscovery()</code>和<code>createServiceRegistry()</code>方法。</p>
</li>
<li>
<p><strong>具体工厂</strong>：</p>
</li>
</ol>
<ul>
<li><code>NacosRegistryFactory</code>：创建 Nacos 的服务发现与注册实例。</li>
<li><code>EurekaRegistryFactory</code>：创建 Eureka 的对应实例。</li>
</ul>
<ol>
<li><strong>客户端适配</strong>：通过配置文件（如<code>registry.type=nacos</code>）动态选择工厂，业务代码无需感知具体实现。</li>
</ol>
<pre><code>// 抽象工厂 

public interface RegistryFactory { 

   ServiceDiscovery createDiscovery(); 
   ServiceRegistry createRegistry(); 

} 

// 客户端使用 
public class ServiceClient { 
   private ServiceDiscovery discovery; 
   public ServiceClient() { 

       // 从配置获取注册中心类型 
       String type = Config.get("registry.type"); 
       RegistryFactory factory = RegistryFactoryLoader.load(type); 
       this.discovery = factory.createDiscovery(); 
   } 
} 
</code></pre>
<p><strong>Q：在分布式缓存同步中，原型模式如何保证缓存对象的一致性？</strong></p>
<p>A：</p>
<ol>
<li>
<p><strong>版本控制</strong>：缓存对象添加<code>version</code>字段，复制时携带版本信息，避免旧版本覆盖新版本。</p>
</li>
<li>
<p><strong>增量复制</strong>：仅复制修改的字段（如通过<code>diff</code>算法计算差异），减少网络传输。</p>
</li>
<li>
<p><strong>同步机制</strong>：采用 “修改者推送” 模式，对象修改后主动复制到其他节点，而非被动拉取，降低一致性延迟。</p>
</li>
</ol>
<h2 id="总结创建型模式在分布式系统中的选型策略">总结：创建型模式在分布式系统中的选型策略</h2>
<h3 id="模式选型决策框架">模式选型决策框架</h3>
<table>
<thead>
<tr>
<th>场景需求</th>
<th>推荐模式</th>
<th>核心考量</th>
</tr>
</thead>
<tbody>
<tr>
<td>集群内唯一实例</td>
<td>分布式单例（ZooKeeper/Redis）</td>
<td>一致性优先，容忍一定性能开销</td>
</tr>
<tr>
<td>服务实例的动态创建</td>
<td>工厂方法模式</td>
<td>适配多实现、多环境，降低服务耦合</td>
</tr>
<tr>
<td>复杂配置对象的构建</td>
<td>建造者模式</td>
<td>多参数组合，构建过程透明可校验</td>
</tr>
<tr>
<td>跨节点对象复制（如缓存同步）</td>
<td>原型模式（基于序列化）</td>
<td>深拷贝可靠性，版本控制与增量复制</td>
</tr>
<tr>
<td>多组件协同创建（如存储层）</td>
<td>抽象工厂模式</td>
<td>组件兼容性，环境一致性</td>
</tr>
</tbody>
</table>
<h3 id="分布式环境下的设计原则">分布式环境下的设计原则</h3>
<ol>
<li>
<p><strong>一致性优先</strong>：创建型模式需优先保证分布式场景下的实例一致性（如单例的集群唯一性、原型复制的版本一致性）。</p>
</li>
<li>
<p><strong>容错性设计</strong>：工厂方法需支持服务实例的故障转移（如创建服务客户端时自动重试），建造者需校验分布式参数合法性（如目标节点是否在线）。</p>
</li>
<li>
<p><strong>性能平衡</strong>：避免过度设计导致性能损耗（如分布式单例的锁竞争需控制粒度，原型复制优先增量同步）。</p>
</li>
</ol>
<p>通过掌握创建型模式在分布式环境下的演化与实践，不仅能应对面试中的设计类问题，更能在实际架构中优化对象创建逻辑，提升系统的灵活性与可靠性 —— 这正是高级程序员与普通开发者在设计思维上的核心差异。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-18 23:16">2025-07-18 23:16</span>&nbsp;
<a href="https://www.cnblogs.com/dayue-bc">晴空月明</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18992299);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18992299', targetLink: 'https://www.cnblogs.com/dayue-bc/p/18992299', title: '创建型模式' })">举报</a>
</div>
        