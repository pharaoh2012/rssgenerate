
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youzhibing/p/18958862" title="发布于 2025-07-01 09:14">
    <span role="heading" aria-level="2">都说了布尔类型的变量不要加 is 前缀，非要加，这不是坑我了嘛</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="开心一刻">开心一刻</h2>
<p>今天心情不好，给哥们发语音<br>
我：哥们，晚上出来喝酒聊天吧<br>
哥们：咋啦，心情不好？<br>
我：嗯，刚刚在公交车上看见前女友了<br>
哥们：然后呢？<br>
我：给她让座时，发现她怀孕了...<br>
哥们：所以难受了？<br>
我：不是她怀孕让我难受，是她怀孕还坐公交车让我难受<br>
哥们：不是，她跟着你就不用坐公交车了？不还是也要坐，有区别吗？<br>
我默默的挂断了语音，心情更难受了</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002618295-1516291850.gif" alt="痛苦面具" width="200px"></div>
<h2 id="java开发手册">Java开发手册</h2>
<p>作为一个 <code>javaer</code>，我们肯定看过 <code>Alibaba</code> 的 <a href="https://developer.aliyun.com/topic/java20" target="_blank" rel="noopener nofollow">Java开发手册</a>，作为国内Java开发领域的标杆性编码规范，我们或多或少借鉴了其中的一些规范，其中有一点</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615715-226395131.png" alt="布尔值变量命名规约"></div>
<p>我印象特别深，也一直在奉行，自己还从未试过用 <code>is</code> 作为布尔类型变量的前缀，不知道会有什么坑；正好前段时间同事这么用了，很不幸，他挖坑，我踩坑，阿西吧！</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615935-1001599942.png" alt="坑爹了" width="200px"></div>
<h2 id="is前缀的布尔变量有坑">is前缀的布尔变量有坑</h2>
<p>为了复现问题，我先简单搞个 <code>demo</code>；调用很简单，服务 <code>workflow</code> 通过 <code>openfeign</code> 调用 <code>offline-sync</code>，代码结构如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615765-326598351.png" alt="项目模块结构"></div>
<blockquote>
<p>qsl-data-govern-common：整个项目的公共模块</p>
<p>qsl-offline-sync：离线同步</p>
<ul>
<li>qsl-offline-sync-api：向外提供 <code>openfeign</code> 接口</li>
<li>qsl-offline-sync-common：离线同步公共模块</li>
<li>qsl-offline-sync-server：离线同步服务</li>
</ul>
<p>qsl-workflow：工作流</p>
<ul>
<li>qsl-workflow-api：向外提供 <code>openfeign</code> 接口，暂时空实现</li>
<li>qsl-workflow-common：工作流公共模块</li>
<li>qsl-workflow-server：工作流服务</li>
</ul>
<p>完整代码：<a href="https://gitee.com/youzhibing/qsl-project/tree/master/qsl-data-govern" target="_blank" rel="noopener nofollow">qsl-data-govern</a></p>
</blockquote>
<p><code>qsl-offline-sync-server</code> 提供删除接口</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@RestController
@RequestMapping("/task")
public class SyncTaskController {

    private static final Logger LOG = LoggerFactory.getLogger(SyncTaskController.class);

    @PostMapping("/delete")
    public ResultEntity&lt;String&gt; delete(@RequestBody SyncTaskDTO syncTask) {
        // TODO 删除处理
        LOG.info("删除任务[taskId={}]", syncTask.getTaskId());
        return ResultEntity.success("删除成功");
    }
}
</code></pre>
<p><code>qsl-offline-sync-api</code> 对外提供 <code>openfeign</code> 接口</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@FeignClient(name = "data-govern-offline-sync", contextId = "dataGovernOfflineSync", url = "${offline.sync.server.url}")
public interface OfflineSyncApi {

    @PostMapping(value = "/task/delete")
    ResultEntity&lt;String&gt; deleteTask(@RequestBody SyncTaskDTO syncTaskDTO);
}
</code></pre>
<p><code>qsl-workflow-server</code> 调用 <code>openfeign</code> 接口</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@RestController
@RequestMapping("/definition")
public class WorkflowController {

    private static final Logger LOG = LoggerFactory.getLogger(WorkflowController.class);

    @Resource
    private OfflineSyncApi offlineSyncApi;

    @PostMapping("/delete")
    public ResultEntity&lt;String&gt; delete(@RequestBody WorkflowDTO workflow) {
        LOG.info("删除工作流[workflowId={}]", workflow.getWorkflowId());
        // 1.查询工作流节点，查到离线同步节点（taskId = 1）
        // 2.删除工作流节点，删除离线同步节点
        ResultEntity&lt;String&gt; syncDeleteResult = offlineSyncApi.deleteTask(new SyncTaskDTO(1L));
        if (syncDeleteResult.getCode() != 200) {
            LOG.error("删除离线同步任务[taskId={}]失败：{}", 1, syncDeleteResult.getMessage());
            ResultEntity.fail(syncDeleteResult.getMessage());
        }
        return ResultEntity.success("删除成功");
    }
}
</code></pre>
<p>逻辑是不是很简单？我们启动两个服务，然后发起 <code>http</code> 请求</p>
<blockquote>
<p>POST <a href="http://localhost:8081/data-govern/workflow/definition/delete" target="_blank" rel="noopener nofollow">http://localhost:8081/data-govern/workflow/definition/delete</a><br>
Content-Type: application/json</p>
<p>{<br>
"workflowId": 99<br>
}</p>
</blockquote>
<p>此时 <code>qsl-offline-sync-server</code> 日志输出如下</p>
<blockquote>
<p>2025-06-30 14:53:06.165|INFO|http-nio-8080-exec-4|25|c.q.s.s.controller.SyncTaskController   :删除任务[taskId=1]</p>
</blockquote>
<p>至此，一切都很正常，第一版也是这么对接的；后面 <code>offline-sync</code> 进行调整，删除接口增加了一个参数：<code>isClearData</code></p>
<pre><code class="language-java">public class SyncTaskDTO {

    public SyncTaskDTO(){}

    public SyncTaskDTO(Long taskId, Boolean isClearData) {
        this.taskId = taskId;
        this.isClearData = isClearData;
    }

    private Long taskId;
    private Boolean isClearData = false;

    public Long getTaskId() {
        return taskId;
    }

    public void setTaskId(Long taskId) {
        this.taskId = taskId;
    }

    public Boolean getClearData() {
        return isClearData;
    }

    public void setClearData(Boolean clearData) {
        isClearData = clearData;
    }
}
</code></pre>
<p>然后实现对应的逻辑</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@RestController
@RequestMapping("/task")
public class SyncTaskController {

    private static final Logger LOG = LoggerFactory.getLogger(SyncTaskController.class);

    @PostMapping("/delete")
    public ResultEntity&lt;String&gt; delete(@RequestBody SyncTaskDTO syncTask) {
        // TODO 删除处理
        LOG.info("删除任务[taskId={}]", syncTask.getTaskId());
        if (syncTask.getClearData()) {
            LOG.info("清空任务[taskId={}]历史数据", syncTask.getTaskId());
            // TODO 清空历史数据
        }
        return ResultEntity.success("删除成功");
    }
}
</code></pre>
<p>调整完之后，同事通知我，让我做对 <code>qsl-workflow</code> 做对应的调整。调整很简单，<code>qsl-workflow</code> 删除时直接传 <code>true</code> 即可</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@RestController
@RequestMapping("/definition")
public class WorkflowController {

    private static final Logger LOG = LoggerFactory.getLogger(WorkflowController.class);

    @Resource
    private OfflineSyncApi offlineSyncApi;

    @PostMapping("/delete")
    public ResultEntity&lt;String&gt; delete(@RequestBody WorkflowDTO workflow) {
        LOG.info("删除工作流[workflowId={}]", workflow.getWorkflowId());
        // 1.查询工作流节点，查到离线同步节点（taskId = 1）
        // 2.删除工作流节点，删除离线同步节点
        // 删除离线同步任务，isClearData直接传true
        ResultEntity&lt;String&gt; syncDeleteResult = offlineSyncApi.deleteTask(new SyncTaskDTO(1L, true));
        if (syncDeleteResult.getCode() != 200) {
            LOG.error("删除离线同步任务[taskId={}]失败：{}", 1, syncDeleteResult.getMessage());
            ResultEntity.fail(syncDeleteResult.getMessage());
        }
        return ResultEntity.success("删除成功");
    }
}
</code></pre>
<p>调整完成之后，发起 <code>http</code> 请求，发现历史数据没有被清除，看日志发现</p>
<blockquote>
<p>LOG.info("清空任务[taskId={}]历史数据", syncTask.getTaskId());</p>
</blockquote>
<p>没有打印，参数明明传的是 <code>true</code> 吖！！！</p>
<blockquote>
<p>offlineSyncApi.deleteTask(new SyncTaskDTO(1L, true));</p>
</blockquote>
<p>这是哪里出了问题？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615493-1035093032.png" alt="20240115000802"></div>
<h2 id="问题排查">问题排查</h2>
<p>因为 <code>qsl-offline-sync-api</code> 是直接引入的，并非我实现的，所以我第一时间找到了其实现者，反馈了问题后让其自测下；一开始他还很自信，说这么简单怎么会有问题</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615704-101518234.jpg" alt="640 (15)"></div>
<p>当他启动 <code>qsl-offline-sync-server</code> 后，发起 <code>http</code> 请求</p>
<blockquote>
<p>POST <a href="http://localhost:8080/data-govern/sync/task/delete" target="_blank" rel="noopener nofollow">http://localhost:8080/data-govern/sync/task/delete</a><br>
Content-Type: application/json</p>
<p>{<br>
"taskId": 123,<br>
"isClearData": true<br>
}</p>
</blockquote>
<p>发现 <code>isClearData</code> 的值是 <code>false</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615705-715626053.png" alt="isClearData是false" width="900px"></div>
<p>此刻，疑问从我的额头转移到了他的额头上，他懵逼了，我轻松了。为了功能能够正常交付，我还是决定看下这个问题，没有了心理压力，也许更容易发现问题所在。第一眼看到 <code>isClearData</code>，我就隐约觉得有问题，所以我决定仔细看下 <code>SyncTaskDTO</code> 这个类，发现 <code>isClearData</code> 的 <code>setter</code> 和 <code>getter</code> 方法有点不一样</p>
<pre><code class="language-java">private Boolean isClearData = false;

public Boolean getClearData() {
    return isClearData;
}

public void setClearData(Boolean clearData) {
    isClearData = clearData;
}
</code></pre>
<p>方法名是不是少了 <code>Is</code>？带着这个疑问我找到了同事，问他 <code>setter</code> 、<code>getter</code> 为什么要这么<strong>命名</strong>？他说是 <code>idea</code> 工具自动生成的（也就是我们平时用到的idea自动生成setter、getter方法的功能）</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615531-474378759.png" alt="idea_setter-getter"></div>
<p>我让他把 <code>Is</code> 补上试试</p>
<pre><code class="language-java">private Boolean isClearData = false;

public Boolean getIsClearData() {
    return isClearData;
}

public void setIsClearData(Boolean isClearData) {
    this.isClearData = isClearData;
}
</code></pre>
<p>发现传值正常了，他回过头看着我，我看着他，两人同时提问</p>
<blockquote>
<p>他：为什么加了 <code>Is</code> 就可以了？</p>
<p>我：布尔类型的变量，你为什么要加 <code>is</code> 前缀？</p>
</blockquote>
<h2 id="问题延申">问题延申</h2>
<p>作为一个严谨的开发，不只是要知其然，更要知其所以然；关于</p>
<blockquote>
<p>为什么加了 <code>Is</code> 就可以了</p>
</blockquote>
<p>这个问题，我们肯定是要会上一会的；会这个问题之前，我们先来捋一下参数的流转，因为是基于 <code>Spring MVC</code> 实现的 Web 应用，所以我们可以这么问 <code>deepseek</code></p>
<blockquote>
<p>Spring MVC 是如何将前端参数转换成POJO的</p>
</blockquote>
<p>能够查到如下重点信息</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615676-480369717.png" alt="springmvc参数转换"></div>
<p><code>RequestResponseBodyMethodProcessor</code> 的 <code>resolveArgument</code></p>
<pre><code class="language-java">/**
 * Throws MethodArgumentNotValidException if validation fails.
 * @throws HttpMessageNotReadableException if {@link RequestBody#required()}
 * is {@code true} and there is no body content or if there is no suitable
 * converter to read the content with.
 */
@Override
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

    parameter = parameter.nestedIfOptional();
    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());
    String name = Conventions.getVariableNameForParameter(parameter);

    if (binderFactory != null) {
        WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
        if (arg != null) {
            validateIfApplicable(binder, parameter);
            if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
                throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
            }
        }
        if (mavContainer != null) {
            mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());
        }
    }

    return adaptArgumentIfNecessary(arg, parameter);
}
</code></pre>
<p>正是解析参数的地方，我们打个断点，再发起一次 <code>http</code> 请求</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002616016-89662583.png" alt="断点调试" width="900px"></div>
<p>很明显，<code>readWithMessageConverters</code> 是处理并转换参数的地方，继续跟进去会来到 <code>MappingJackson2HttpMessageConverter</code> 的 <code>readJavaType</code> 方法</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615999-998548396.png" alt="jackson绑定参数" width="900px"></div>
<p>此刻我们可以得到，是通过 <code>jackson</code> 完成数据绑定与数据转换的。继续跟进，会看到 <code>isClearData</code> 的赋值过程</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202507/747662-20250701002615996-1273776375.png" alt="set反射设值" width="900px"></div>
<p>通过前端传过来的参数 <code>isClearData</code> 找对应的 <code>setter</code>方法是 <strong>setIsClearData</strong>，而非 <code>setClearData</code>，所以问题</p>
<blockquote>
<p>为什么加了 <code>Is</code> 就可以了</p>
</blockquote>
<p>是不是就清楚了？</p>
<h2 id="问题解决">问题解决</h2>
<ol>
<li>
<p>按上述方式调整 <code>isClearData</code> 的 <code>setter</code>、<code>getter</code> 方法</p>
<p>带上 <code>is</code></p>
<pre><code class="language-java">public Boolean getIsClearData() {
    return isClearData;
}

public void setIsClearData(Boolean isClearData) {
    this.isClearData = isClearData;
}
</code></pre>
</li>
<li>
<p>布尔类型的变量，不用 <code>is</code> 前缀</p>
<p>可以用 <code>if</code> 前缀</p>
<pre><code>private Boolean ifClearData = false;

public Boolean getIfClearData() {
    return ifClearData;
}

public void setIfClearData(Boolean ifClearData) {
    this.ifClearData = ifClearData;
}
</code></pre>
</li>
<li>
<p>可以结合 <code>@JsonProperty</code> 来处理</p>
<pre><code class="language-java">@JsonProperty("isClearData")
private Boolean isClearData = false;
</code></pre>
</li>
</ol>
<h2 id="总结">总结</h2>
<ol>
<li>
<p><code>Spring MVC</code> 对参数的绑定与转换，内容不同，采用的处理器也不同</p>
<ol>
<li>
<p>form表单数据(application/x-www-form-urlencoded)</p>
<p>处理器：<code>ServletModelAttributeMethodProcessor</code></p>
</li>
<li>
<p>JSON 数据 (application/json)</p>
<p>处理器：<code>RequestResponseBodyMethodProcessor</code><br>
转换器：<code>MappingJackson2HttpMessageConverter</code></p>
</li>
<li>
<p>多部分文件 (multipart/form-data)</p>
<p>处理器：<code>MultipartResolver</code></p>
</li>
</ol>
</li>
<li>
<p><code>POJO</code> 的布尔类型变量，不要加 <code>is</code> 前缀</p>
<p>命名不符合规范，集成第三方框架的时候就很容易出不好排查的问题</p>
<blockquote>
<p>成不了规范的制定者，那就老老实实遵循规范！</p>
</blockquote>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07569444444444444" data-date-updated="2025-07-01 11:03">2025-07-01 09:14</span>&nbsp;
<a href="https://www.cnblogs.com/youzhibing">青石路</a>&nbsp;
阅读(<span id="post_view_count">453</span>)&nbsp;
评论(<span id="post_comment_count">13</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18958862);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18958862', targetLink: 'https://www.cnblogs.com/youzhibing/p/18958862', title: '都说了布尔类型的变量不要加 is 前缀，非要加，这不是坑我了嘛' })">举报</a>
</div>
        