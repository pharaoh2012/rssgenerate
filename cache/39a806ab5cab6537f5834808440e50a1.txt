
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hez2010/p/18718386/csharp-interpolated-string-sscanf" title="发布于 2025-02-16 17:06">
    <span role="heading" aria-level="2">用 C# 插值字符串处理器写一个 sscanf</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>什么？用 C# 插值字符串处理器写一个输入用的 <code>sscanf</code>？你确定不是输出用的 <code>sprintf</code>？</p>
<p>我猜不少读者看到标题后大概会有上述的想法。然而我们这里还真就是实现 <code>sscanf</code>，而不是 <code>sprintf</code>。</p>
<h2 id="插值字符串处理器">插值字符串处理器</h2>
<p>C# 有一个特性叫做插值字符串，使用插值字符串，你可以自然地往字符串里面插入变量的值，比如：<code>$"abc{x}def"</code>，这一改以往通过 <code>string.Format</code> 来格式化字符串的方式，使得不再需要先传递一个字符串模板再挨个传递参数，非常方便。</p>
<p>在插值字符串的基础上更进一步，C# 支持插值字符串处理器，意味着你可以自定义字符串的插值行为。比如一个简单的例子：</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
struct Handler(int literalLength, int formattedCount)
{
    public void AppendLiteral(string s)
    {
        Console.WriteLine($"Literal: '{s}'");
    }

    public void AppendFormatted&lt;T&gt;(T v)
    {
        Console.WriteLine($"Value: '{v}'");
    }
}
</code></pre>
<p>在使用的时候，只需要把传递 <code>string</code> 参数的地方都换成这个 <code>Handler</code> 类型，就能做到按照你自定义的方式来处理插值字符串，我们的插值字符串会被 C# 编译器自动变换成 <code>Handler</code> 的构造和调用然后被传入：</p>
<pre><code class="language-cs">void Foo(Handler handler) { }
var x = 42;
Foo($"abc{x}def");
</code></pre>
<p>比如上面这个例子，你会得到输出：</p>
<pre><code class="language-text">Literal: 'abc'
Value: '42'
Literal: 'def'
</code></pre>
<p>这大大方便了各种结构化日志框架的处理，你只需要简单的把插值字符串传递进去，日志框架就能根据你插值的方式来做到结构化解析，从而完全避免了手动去格式化字符串。</p>
<h2 id="带参数的插值字符串处理器">带参数的插值字符串处理器</h2>
<p>其实 C# 的插值字符串处理器还支持带额外的参数：</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
struct Handler(int literalLength, int formattedCount, int value)
{
    public void AppendLiteral(string s)
    {
        Console.WriteLine($"Literal: '{s}'");
    }

    public void AppendFormatted&lt;T&gt;(T v)
    {
        Console.WriteLine($"Value: '{v}'");
    }
}

void Foo(int value, [InterpolatedStringHandlerArgument("value")] Handler handler) { }
Foo(42, $"abc{x}def");
</code></pre>
<p>这么一来，<code>42</code> 就会被传入 <code>handler</code> 的 <code>value</code> 参数当中，这允许我们捕获来自调用方的上下文，毕竟在日志场景中，根据不同参数来决定不同的格式很常见。</p>
<h2 id="sscanf">sscanf？</h2>
<p>众所周知 C/C++ 里面有一个很常用的函数 <code>sscanf</code>，它接受一个文本输入和一个格式化模板，然后再传递对格式化部分的变量的引用，就能把变量的值解析出来：</p>
<pre><code class="language-cpp">const char* input = "test 123 test";
const char* template = "test %d test";
int v = 0;
sscanf(input, template, &amp;v);
printf("%d\n", v); // 123
</code></pre>
<p>那我们能不能在 C# 里复刻一个呢？当然可以！只不过需要一点点黑魔法。</p>
<h2 id="用-c-实现-sscanf">用 C# 实现 sscanf</h2>
<p>首先我们做一个带参数的插值字符串处理器：</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
ref struct TemplatedStringHandler(int literalLength, int formattedCount, ReadOnlySpan&lt;char&gt; input)
{
    private ReadOnlySpan&lt;char&gt; _input = input;

    public void AppendLiteral(ReadOnlySpan&lt;char&gt; s)
    {
    }

    public void AppendFormatted&lt;T&gt;(T v) where T : ISpanParsable&lt;T&gt;
    {
    }
}
</code></pre>
<p>这里我们把所有的 <code>string</code> 都换成 <code>ReadOnlySpan&lt;char&gt;</code> 减少分配。</p>
<p>按照 <code>sscanf</code> 的使用方法，我们按理来说应该做成类似这样的东西：</p>
<pre><code class="language-cs">void sscanf(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; template, params object[] args);
</code></pre>
<p>但是很显然，这里我们需要的是 <code>(ref object)[]</code>，因为我们需要传递引用进去才能做到对外部变量的更新，而不是直接把变量的值当作 <code>object</code> 传进去。那怎么办呢？</p>
<p>你会发现，C# 的插值字符串处理器里已经包含了各变量的值，因此我们完全不需要像 C/C++ 那样通过类似 <code>%d</code> 之类的占位符来插入变量！相对于 <code>"test %d test"</code> 我们可以直接写 <code>$"test {v} test"</code>，然后通过引用传递这个 <code>v</code>。</p>
<p>一个很自然的想法是，我们把只需要把 <code>AppendFormatted&lt;T&gt;(T v)</code> 改成 <code>AppendFormatted&lt;T&gt;(ref T v)</code> 不就行了。</p>
<p>然而实际这么操作之后你会发现这么做是行不通的：</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
ref struct TemplatedStringHandler(int literalLength, int formattedCount, ReadOnlySpan&lt;char&gt; input)
{
    private ReadOnlySpan&lt;char&gt; _input = input;

    public void AppendLiteral(ReadOnlySpan&lt;char&gt; s)
    {
    }

    public void AppendFormatted&lt;T&gt;(ref T v) where T : ISpanParsable&lt;T&gt;
    {
    }
}

void sscanf(ReadOnlySpan&lt;char&gt; input, [InterpolatedStringHandlerArgument("input")] TemplatedStringHandler template);
</code></pre>
<p>当我们试图调用 <code>sscanf</code> 的时候：</p>
<pre><code class="language-cs">int v = 0;
sscanf("test 123 test", $"test {ref v} test"); // error CS1525: Invalid expression term 'ref'
</code></pre>
<p>报错了！插值字符串的值部分里写 <code>ref</code> 关键字是无效的！</p>
<p>注意到这个错误是来自 C# 编译器的 parser，也就是说只要我们从语法上把这个 <code>ref</code> 干掉，那就能通过编译了。</p>
<p>此时我们灵机一动，我们 C# 不是有 <code>in</code> 来传递只读引用吗？C# 对于 <code>in</code> 传递只读引用会自动帮我们创建引用并传递进去，无需在语法上显式指定 <code>ref</code>，于是我们稍微利用一下这个特性改造一番：</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
ref struct TemplatedStringHandler(int literalLength, int formattedCount, ReadOnlySpan&lt;char&gt; input)
{
    private ReadOnlySpan&lt;char&gt; _input = input;

    public void AppendLiteral(ReadOnlySpan&lt;char&gt; s)
    {
    }

    public void AppendFormatted&lt;T&gt;(in T v) where T : ISpanParsable&lt;T&gt;
    {
    }
}
</code></pre>
<p>然后就会发现，下面这个代码可以成功编译了：</p>
<pre><code class="language-cs">int v = 0;
sscanf("test 123 test", $"test {v} test");
</code></pre>
<p>此时我们离成功只剩下最后一步：传递进来的是只读引用，可是为了提取出变量我们需要更新引用的值，怎么办呢？</p>
<p>好在我们有 <code>Unsafe.AsRef</code> 把只读引用转换成可变引用，那最后一个问题解决了，我们就可以开始我们的实现了。</p>
<pre><code class="language-cs">[InterpolatedStringHandler]
ref struct TemplatedStringHandler(int literalLength, int formattedCount, ReadOnlySpan&lt;char&gt; input)
{
    private int _index = 0;
    private ReadOnlySpan&lt;char&gt; _input = input;

    public void AppendLiteral(ReadOnlySpan&lt;char&gt; s)
    {
        var offset = Advance(0); // 先跳过连续空白字符
        _input = _input[offset..];
        _index += offset;
  
        if (_input.StartsWith(s)) // 从输入字符串中去掉模板字符串的非变量部分
        {
            _input = _input[s.Length..];
        }
        else throw new FormatException($"Cannot find '{s}' in the input string (at index: {_index}).");

        _index += s.Length;
        literalLength -= s.Length;
    }

    public void AppendFormatted&lt;T&gt;(in T v) where T : ISpanParsable&lt;T&gt;
    {
        var offset = Advance(0); // 先跳过连续空白字符
        _input = _input[offset..];
        _index += offset;

        var length = Scan(); // 计算到下一个空白字符为止的长度
        if (T.TryParse(_input[..length], null, out var result)) // 解析！
        {
            Unsafe.AsRef(in v) = result; // 把只读引用换成可变引用后更新引用值
            _input = _input[length..];
            _index += length;
            formattedCount--;
        }
        else
        {
            throw new FormatException($"Cannot parse '{_input[..length]}' to '{typeof(T)}' (at index: {_index}).");
        }
    }

    // 向后扫描，直到遇到空白字符停止
    private int Scan()
    {
        var length = 0;
        for (var i = 0; i &lt; _input.Length; i++)
        {
            if (_input[i] is ' ' or '\t' or '\r' or '\n') break;
            length++;
        }
        return length;
    }

    // 跳过所有的空白字符
    private int Advance(int start)
    {
        var length = start;
        while (length &lt; _input.Length &amp;&amp; _input[length] is ' ' or '\t' or '\r' or '\n')
        {
            length++;
        }
        return length;
    }
}
</code></pre>
<p>然后我们提供一个 <code>sscanf</code> 暴露我们的插值字符串处理器即可：</p>
<pre><code class="language-cs">static void sscanf(ReadOnlySpan&lt;char&gt; input, [InterpolatedStringHandlerArgument("input")] TemplatedStringHandler template) { }
</code></pre>
<h2 id="使用">使用</h2>
<pre><code class="language-cs">int x = 0;
string y = "";
bool z = false;
DateTime d = default;
sscanf("test 123 hello false 2025/01/01T00:00:00 end", $"test{x}{y}{z}{d}end");
Console.WriteLine(x);
Console.WriteLine(y);
Console.WriteLine(z);
Console.WriteLine(d);
</code></pre>
<p>得到输出：</p>
<pre><code class="language-text">123
hello
False
2025年1月1日 0:00:00
</code></pre>
<p>而 <code>scanf</code> 只不过是 <code>sscanf(Console.ReadLine(), template)</code> 的简写罢了，所以这里我们有 <code>sscanf</code> 就完全足够了。</p>
<h2 id="结论">结论</h2>
<p>C# 的插值字符串处理器非常强大，利用这个特性，我们成功实现了比 C/C++ 中 <code>sscanf</code> 还要更好用的多的字符串解析函数，不仅不需要格式化字符串占位，还能自动推导类型，甚至连在后面的参数里逐个传递变量引用的需要都直接省掉了，在此基础上我们还做到了零分配。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.376265504763889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-16 17:18">2025-02-16 17:06</span>&nbsp;
<a href="https://www.cnblogs.com/hez2010">hez2010</a>&nbsp;
阅读(<span id="post_view_count">1029</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18718386" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18718386);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18718386', targetLink: 'https://www.cnblogs.com/hez2010/p/18718386/csharp-interpolated-string-sscanf', title: '用 C# 插值字符串处理器写一个 sscanf' })">举报</a>
</div>
        