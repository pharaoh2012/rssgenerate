
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18625369" title="发布于 2024-12-24 23:06">
    <span role="heading" aria-level="2">经典区间线段树详解：从原理到实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>线段树（Segment Tree）是一种非常高效的树形数据结构，用于解决区间查询和修改问题。本文将通过分步骤讲解，带领读者熟练掌握线段树的原理与实现，并探索其应用场景。</p>
<h2 id="引言数组区间修改问题">引言：数组区间修改问题</h2>
<p>线段树要解决这样一个经典问题：比如给定一个数组，频繁地需要进行以下操作：</p>
<ol>
<li><strong>区间查询</strong>：查询数组某一子区间内的<strong>最大值、最小值、总和</strong>等。假定我们总要反复求某个区间内的元素和。</li>
<li><strong>区间修改</strong>：将某个子区间的所有值都进行一次操作，假定我们总要将区间内所有数增加一个固定数值。</li>
</ol>
<p>暴力来说，我们直接在原数组上求和和修改即可。对于区间查询，我们可以每次直接遍历子区间计算结果；对于区间修改，可以遍历整个子区间进行更新。然而，区间长度最长可以是几乎整个数组长度，这种方法的时间复杂度为 <span class="math inline">\(O(n)\)</span>，如果操作频繁且数组较大，效率会变得不可接受。</p>
<p>我们需要一种数据结构能够在单次 <span class="math inline">\(O(\log n)\)</span> 的时间内完成上述操作。线段树应运而生。</p>
<hr>
<h2 id="线段树的结构与实现">线段树的结构与实现</h2>
<p>线段树是一种二叉树，用于高效地存储和操作区间信息。</p>
<h3 id="1-从区间到二叉树">1. 从区间到二叉树</h3>
<p>线段树将数组下标空间反复二分划分为多个区间，并使用二叉树存储这些区间的信息：</p>
<ul>
<li><strong>叶节点</strong>：表示数组的单个元素。</li>
<li><strong>内部节点</strong>：表示某一子区间的汇总信息（如区间和、最大值等）。</li>
</ul>
<p>例如，给定数组 <code>[1, 3, 5, 7, 9, 11]</code>，其线段树如下：</p>
<pre><code>              [0, 5]
             /       \
        [0, 2]       [3, 5]
       /     \       /     \
   [0, 1]  (2, 2) [3, 4]  (5, 5)
  /    \          /    \
(0, 0)(1, 1)  (3, 3)(4, 4)
</code></pre>
<p>小括号为叶节点，即本元素值；中括号即储存区间信息的额外节点，在本题里，他储存区间的总和，这个值由左右儿子计算得出。</p>
<h3 id="2-空间复杂度与-4-倍数组">2. 空间复杂度与 4 倍数组</h3>
<p>普通数组只占用 1 倍空间，不需要多余数据，而线段树的二叉树通常用数组表示。对于大小为 <span class="math inline">\(n\)</span> 的数组，线段树数组的大小通常是 <span class="math inline">\(4n\)</span>，这是因为：</p>
<ol>
<li>线段树是一棵完全二叉树，其节点数不超过 <span class="math inline">\(2n - 1\)</span>。</li>
<li>但预分配时考虑到最坏情况（非 2 的幂次）会增加存储需求，为了叶节点的左右空节点也仍无需特殊处理，为了简化代码实现，我们直接分配数组大小为 <span class="math inline">\(4n\)</span>，确保不会越界，形成了惯例。</li>
</ol>
<p>当然空间复杂度是 <span class="math inline">\(O(n)\)</span> 的，变化的仅系数。你可以对比上例的数组理解。</p>
<h3 id="3-线段树的构建">3. 线段树的构建</h3>
<p>以下是构建线段树的代码示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; tree; // 数组保存二叉树
vector&lt;int&gt; lazy; // 二叉树每个节点对应的懒标记，稍后使用
vector&lt;int&gt; arr; // 建树使用的原数据

void build(int node, int start, int end) {
    if (start == end) {
        // 叶节点
        tree[node] = arr[start];
    } else {
        // 非叶节点都被继续二分
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;

        build(left_child, start, mid);
        build(right_child, mid + 1, end);

        tree[node] = tree[left_child] + tree[right_child]; // 区间和为左右之和
    }
}
</code></pre>
<h2 id="区间查询与修改">区间查询与修改</h2>
<h3 id="1-区间查询">1. 区间查询</h3>
<p>线段树支持高效的区间查询，通过分治法将问题划分为子区间处理。要求某个区间内所有数的和，只需要将在线段树里不断拆分区间。以下是实现代码：</p>
<pre><code class="language-cpp">int query(int node, int start, int end, int l, int r) {
    if (r &lt; start || l &gt; end) {
        return 0; // 完全不相交
    }
    if (l &lt;= start &amp;&amp; end &lt;= r) {
        return tree[node]; // 完全包含
    }

    // 部分包含，则交给左右子树处理
    int mid = (start + end) / 2;
    int left_child = 2 * node + 1;
    int right_child = 2 * node + 2;

    int left_sum = query(left_child, start, mid, l, r);
    int right_sum = query(right_child, mid + 1, end, l, r);

    return left_sum + right_sum;
}
</code></pre>
<p>假如我们要修改区间 <span class="math inline">\([1,4]\)</span>，可以发现区间最终被拆分到几个子区间，而不一定总是走到最底部，大大提高了效率。</p>
<pre><code>                     [0, 5][36]×
                     /           \
            [0, 2][9]×             [3, 5][27]×
           /           \              /     \
    [0, 1][4]×  (2, 2)[5]√   [3, 4][16]√  (5, 5)[11]
   /       \                 /        \
(0, 0)[1] (1, 1)[3]√      (3, 3)[7] (4, 4)[9]
</code></pre>
<hr>
<h3 id="2-单点修改">2. 单点修改</h3>
<p>假如要修改数组中的一个元素，那么只要从上往下一路查找到底即可，而底节点改变影响父节点的值，递归结束后重新计算和即可。我们需要更新线段树：</p>
<pre><code class="language-cpp">void update(int node, int start, int end, int idx, int val) {
    if (start == end) {
        tree[node] = val;
    } else {
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;

        if (idx &lt;= mid) {
            update(left_child, start, mid, idx, val);
        } else {
            update(right_child, mid + 1, end, idx, val);
        }

        tree[node] = tree[left_child] + tree[right_child];
    }
}
</code></pre>
<p>仍使用刚才的例子，假定修改下标 1 的值：</p>
<pre><code>                     [0, 5][37]×
                     /           \
            [0, 2][10]×             [3, 5][27]
           /           \              /     \
    [0, 1][5]×  (2, 2)[5]   [3, 4][16]   (5, 5)[11]
   /       \                 /        \
(0, 0)[1] (1, 1)[4]√      (3, 3)[7] (4, 4)[9]
</code></pre>
<h3 id="3-区间修改懒标记">3. 区间修改：懒标记</h3>
<p>这是线段树最难的一部分。线段树通过<strong>懒标记（Lazy Propagation）</strong>来优化区间修改。<strong>核心思想</strong>：延迟更新，将修改操作记录在标记数组中，仅在必要时更新。</p>
<p>具体来说，假如我们要修改某个区间的值（比如都增加 <span class="math inline">\(a\)</span>），我们仍将其分割到几个子区间，若某区间被完全包含，那么我们就不再向下递归，而是仅对该节点修改，并在该节点处的懒标记设为 <span class="math inline">\(a\)</span>，表明我的所有子节点都应该加上 <span class="math inline">\(a\)</span>，但是尚未实际操作。直到后续某次查询来到这里时，我们才将懒标记清空，并将其向下推一层。</p>
<pre><code class="language-cpp">

void updateRange(int node, int start, int end, int l, int r, int val) {
    if (lazy[node] != 0) { // 来到一个节点，首先检查标记，若存在则下推一层
        tree[node] += (end - start + 1) * lazy[node];
        if (start != end) {
            lazy[2 * node + 1] += lazy[node];
            lazy[2 * node + 2] += lazy[node];
        }
        lazy[node] = 0;
    }

    if (r &lt; start || l &gt; end) { // 完全不相交
        return;
    }

    if (l &lt;= start &amp;&amp; end &lt;= r) { // 完全包含，那么在这里停止，并使用懒标记
        tree[node] += (end - start + 1) * val;
        if (start != end) {
            lazy[2 * node + 1] += val;
            lazy[2 * node + 2] += val;
        }
        return;
    }

    // 部分包含，则交给左右子树处理
    int mid = (start + end) / 2;
    updateRange(2 * node + 1, start, mid, l, r, val);
    updateRange(2 * node + 2, mid + 1, end, l, r, val);

    tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
}
</code></pre>
<p>仍循上例，将<span class="math inline">\([1,4]\)</span>都增加 1，我们发现在<span class="math inline">\([3,4]\)</span>处就进行标记，并不再向下传播。由此，区间修改的操作量和区间查询是一致的。若没有懒标记，则每次修改都会推到最底部，这比暴力还劣。所以懒标记是线段树的必须项，而非锦上添花。</p>
<p>虽然其子树的值暂不正确，但是访问子树一定会经过懒标记，当以后任何情况下再次来到这里，都一定会经过懒标记并将其下推，保证了只要你访问了子树。结果总是正确。由此，区间查询和单点修改函数也需要添加下推标记段（即<code>if (lazy[node] != 0)</code> 部分）。</p>
<p>懒标记就像一个勤快又善于偷懒的管理员，负责照看一片大田地。每当需要给某些田地施肥时，如果整片田地都需要相同的肥料，他会在大门口挂一个牌子，写上“这片田地需要施肥”，但暂时不实际行动。这意味着，他不用一块一块地跑下去忙碌，但是等到有人真正走进田地时，他就会立刻施肥，并顺手把任务分配给更小的田地。这样既节省了时间，又确保了田地里的作物都能及时得到照顾，每个走进田地的人都看到的是已施肥后的土地。懒标记的“懒”，只是暂缓处理；而他的“勤”，则体现在始终精准地完成所有任务！</p>
<pre><code>                     [0, 5][40]×
                     /           \
            [0, 2][11]×             [3, 5][29]×
           /           \              /     \
    [0, 1][5]×  (2, 2)[6]√   [3, 4][18|+1]√  (5, 5)[11]
   /       \                 /        \
(0, 0)[1] (1, 1)[4]√      (3, 3)[7] (4, 4)[9]
</code></pre>
<hr>
<hr>
<h2 id="为什么线段树分解为--段">为什么线段树分解为 <span class="math inline">\(O(\log n)\)</span> 段？</h2>
<p>我们发现，每次查询或修改时，线段树通过二分方式分解目标区间为几个大段，长块的修改总不会被推到底，大大提升了效率。线段树的单次操作之所以总是 $ O(\log n) $，是因为它通过二分递归的方式，将问题规模快速减小。每次查询或修改时，线段树会根据区间的位置判断是完全包含、完全不相交，还是部分重叠：</p>
<ol>
<li>若区间的左端点和本节点的左端点对齐，右端点没有越过中点，则直接进入左子树，将问题规模缩小一半。反过来同理。</li>
<li>若区间的左端点和本节点的左端点对齐，右端点越过中点，则将左子树整块查询或懒标记修改，然后进入右子树，将问题规模缩小一半。反过来同理。</li>
</ol>
<p>以上两种情况下，进入子树后区间一端仍然对齐，新情况总还是 1 和 2 的一种。</p>
<ol start="3">
<li>
<p>若区间端点不存在对齐，但全部在左右区间中的一侧中，则直接进入，问题规模仍被缩小一半。进入子树后可能是情况 3 或 4.</p>
</li>
<li>
<p>若区间端点不存在对齐，且跨过本区间中点，只有在这种情况下，才会同时进入左右子树，且左右子树总是情况 1 和 2，所以这样的情况最多发生一次。</p>
</li>
</ol>
<p>在这样的分治过程中，只有一次会同时进入左右子树，而递归的深度与线段树的高度相同，而线段树的高度是 $ \log n $，因此每次操作的复杂度是 $ O(\log n) $，访问的节点数最坏是 $ 2\log n $ 左右。这种分治机制有效避免了遍历整个数组的低效操作，是线段树高效的核心原因。你可以自己绘制一个较长的线段树，帮助理解。</p>
<hr>
<h2 id="拓展知识">拓展知识</h2>
<h3 id="指针版线段树">指针版线段树</h3>
<p>在算法思想完全一样的情况下，二叉树也可以使用指针和动态申请空间来实现，指针版线段树动态分配节点内存，适用于稀疏数组。其可以在更新赋值时再创建节点，内存使用效率高，且不需要 4 倍空间，也叫动态开点线段树。适用于大范围稀疏数据。缺点是编程复杂度较高且常数项性能较低。这种方式本文就不展示了。</p>
<p>在本文章的场景下（维护数组），静态数组版本效率高，更为常用。若要维护巨大但稀疏的值域，则指针版本可节省大量空间。</p>
<hr>
<h3 id="线段树的其他应用">线段树的其他应用</h3>
<p>除了区间查询和修改，线段树还能解决以下问题：</p>
<ol>
<li><strong>区间最值</strong>：除了区间和，在线段树节点存储区间最小值或最大值。他们的思想几乎一致，仅需要在分支节点中更新和查询时把区间相加改为区间最值即可。</li>
<li><strong>第 k 小值查询</strong>：结合其他算法，可以实现排序和统计信息。</li>
<li><strong>二维线段树</strong>：拓展到二维情况。用于处理平面上的区间问题。</li>
</ol>
<p>线段树擅长处理可分解的区间性质（如求和、最大值、最小值、乘积等），但对于某些非线性性质，它难以处理或效率低下。某些区间问题则不能使用线段树，典型的例子是<strong>区间众数（Mode）和区间中位数（Median）</strong>：众数无法通过简单的组合两个子区间的结果来得到，因为它需要全局信息，即子区间的众数不能简单合并为整体区间的众数。中位数也类似，它需要区间内的全局排序信息，不能通过线段树的分治思想直接解决。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2439772859861111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 12:24">2024-12-24 23:06</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">102</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18625369" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18625369);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18625369', targetLink: 'https://www.cnblogs.com/ofnoname/p/18625369', title: '经典区间线段树详解：从原理到实践' })">举报</a>
</div>
        