
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/feffery/p/18965946" title="发布于 2025-07-04 16:53">
    <span role="heading" aria-level="2">Python全栈应用开发利器Dash 3.x新版本介绍（2）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<center style="font-size: 18px; font-weight: bold; padding-top: 40px">更多Dash应用开发干货知识、案例，欢迎关注“玩转Dash”微信公众号👇</center>
<p><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250703190053776-1837084116.png" alt="image" loading="lazy"></p>
<p>大家好我是费老师，在<a href="https://www.cnblogs.com/feffery/p/18964220" target="_blank">上一期文章</a>中，我们针对<code>Python</code>生态中<u>强大</u>且<u>灵活</u>的<em>全栈应用开发</em>框架<code>Dash</code>，介绍了其<code>3.x</code>新版本中的<em>部分</em>更新内容🧐。</p>
<p>今天的文章中，我们继续介绍<code>3.x</code>新版本<code>Dash</code>中的<em>更多更新内容</em>，进一步提升使用<code>Python</code>+<code>Dash</code>进行全栈应用开发的效率~</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164933879-1595975957.png" width="50%"></center>
<h2 id="1-inputstate回调角色编排新增allow_optional参数">1 Input、State回调角色编排新增allow_optional参数</h2>
<p>我们都知道，在<code>Dash</code>中，<em>回调函数</em>是关联不同组件，实现各种灵活<em>交互功能</em>的关键。</p>
<p>但在编写一些<em>较复杂</em>回调函数逻辑时，部分同学对参与回调函数的<em>部分组件渲染顺序</em>控制不当，导致回调函数触发时，部分<code>Input</code>或<code>State</code>角色<em>尚未渲染在页面中</em>，这在<code>debug</code>模式下会在前端弹出以<code>A nonexistent object was used in</code>开头的错误提示。</p>
<p>譬如下面的例子，<em>输入框2</em>需要点击按钮后才会渲染在页面中，因此对应<code>show_inputs()</code>回调函数提前触发时，作为<code>Input</code>角色之一的<em>输入框2</em>并不存在，就会导致相关错误出现：</p>
<pre><code class="language-python">import dash
from dash import html
import feffery_antd_components as fac
from dash.dependencies import Input, Output
from feffery_dash_utils.style_utils import style

app = dash.Dash(__name__, suppress_callback_exceptions=True)

app.layout = html.Div(
    [
        fac.AntdSpace(
            [
                fac.AntdButton("渲染输入框2", id="render-input", type="primary"),
                fac.AntdInput(id="input1", placeholder="输入框1"),
                fac.Fragment(id="input2-container"),
                fac.AntdText(id="inputs-content"),
            ]
        )
    ],
    style=style(padding=50),
)


@app.callback(
    Output("input2-container", "children"),
    Input("render-input", "nClicks"),
    prevent_initial_call=True,
)
def render_input2(nClicks):
    return fac.AntdInput(id="input2", placeholder="输入框2")


@app.callback(
    Output("inputs-content", "children"),
    Input("input1", "value"),
    Input("input2", "value"),
)
def show_inputs(input1, input2):
    return f"输入框1: {input1}, 输入框2: {input2}"


if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164935874-1201093876.png"></center>
<p>针对这个场景，<code>3.x</code>版本中为<code>Input()</code>和<code>State()</code>角色编排添加了<code>allow_optional</code>参数，当设置<code>allow_optional=True</code>时，对应的<code>Input</code>或<code>State</code>角色即使当前不存在，也不会报错终止回调逻辑，而是<em>以空值作为缺省值</em>：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164937914-842183746.png"></center>
<p>作用效果如下：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164940090-1703281741.gif"></center>
<p>妥善利用此项新特性，我们就可以更轻松地处理相关场景啦~</p>
<h2 id="2-dashdash新增assets_path_ignore参数">2 dash.Dash()新增assets_path_ignore参数</h2>
<p>熟悉<code>Dash</code>应用开发的朋友应该知晓，对于应用项目默认的静态资源目录<code>assets</code>，其内部的所有<code>.css</code>、<code>.js</code>文件，都会在用户访问应用时<em>全部自动加载并生效</em>，譬如下面的简单例子，<code>assets</code>目录下<code>demo_folder</code>中额外定义的<code>demo.js</code>和<code>demo.css</code>均在应用中自动生效：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164941887-62173268.png"></center>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164943750-1196262156.png"></center>
<p>当我们既希望可以直接通过<code>assets/</code>开头的<code>URL</code>访问对应文件资源（譬如<code>assets/demo_folder/demo.css</code>），又不希望应用访问时部分静态资源自动被加载生效时，就可以使用到新版本中为<code>dash.Dash()</code>新增的参数<code>assets_path_ignore</code>，接受列表型输入，用于指定<code>assets</code>下<em>哪些路径</em>需要在自动加载机制中被忽略，譬如：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164945604-2086061424.png"></center>
<p>这样设置之后，对应目录下的相关静态资源就不会自动生效啦：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164947628-2037144027.png"></center>
<p>这一点在很多场景下非常实用，譬如离线形式部署<code>Dash</code>+<code>three.js</code>等，有相关<code>Dash</code>应用高级功能开发需求的朋友值得注意。</p>
<h2 id="3-antdconfigprovider性能大幅优化">3 AntdConfigProvider性能大幅优化</h2>
<p>熟悉<code>fac</code>组件库的朋友，可能对其中的<em>参数配置</em>组件<code>AntdConfigProvider</code>有所了解：</p>
<ul>
<li>文档地址：<a href="https://fac.feffery.tech/AntdConfigProvider" target="_blank" rel="noopener nofollow">https://fac.feffery.tech/AntdConfigProvider</a></li>
</ul>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164949745-93804825.png"></center>
<p>在<code>3.0</code>版本之前，由于<code>Dash</code>底层渲染机制的原因，导致被<code>AntdConfigProvider</code>组件所包裹的其他组件，在被交互时会<em>额外产生</em>大量多余的<em>重绘渲染</em>，当<code>AntdConfigProvider</code>内部组件众多，譬如直接将整个页面嵌套在<code>AntdConfigProvider</code>中实现主题切换、国际化切换等功能时，会感受到<em>明显的操作卡顿</em>，譬如下面的例子（对应<code>Dash</code>版本为<code>2.18.2</code>）：</p>
<pre><code class="language-python">import dash
from dash import html
import feffery_antd_components as fac
from feffery_dash_utils.style_utils import style

app = dash.Dash(__name__)

app.layout = html.Div(
    [
        fac.AntdConfigProvider(
            fac.AntdSpace(
                [fac.AntdSwitch(checkedChildren="打开", unCheckedChildren="关闭")]
                * 2000,
                wrap=True,
            )
        )
    ],
    style=style(padding=50),
)

if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164952124-542768487.gif"></center>
<p>同样的应用在<code>3.x</code>版本中，操作就变得非常丝滑~</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250704164954548-1377611880.gif"></center>
<p>基于这项<em>性能</em>上的<em>重大提升</em>，我们就可以在应用中更稳定地实现<em>主题切换</em>、<em>国际化切换</em>、<em>批量禁用控制</em>等功能~</p>
<p>篇幅有限，更多新版本<code>Dash</code>更新相关内容，接下来的数篇文章我们继续为大家盘点，敬请期待~</p>
<hr>
<p>以上就是本文的全部内容，对<code>Dash</code>应用开发感兴趣的朋友，欢迎添加微信号<code>CNFeffery</code>，备注“dash学习”加入我们的技术交流群，一起成长一起进步。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.029166666666666667" data-date-updated="2025-07-04 17:35">2025-07-04 16:53</span>&nbsp;
<a href="https://www.cnblogs.com/feffery">费弗里</a>&nbsp;
阅读(<span id="post_view_count">111</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18965946);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18965946', targetLink: 'https://www.cnblogs.com/feffery/p/18965946', title: 'Python全栈应用开发利器Dash 3.x新版本介绍（2）' })">举报</a>
</div>
        