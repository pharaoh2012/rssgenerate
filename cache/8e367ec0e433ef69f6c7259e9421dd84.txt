
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jzzg/p/18654172" title="发布于 2025-01-06 00:07">
    <span role="heading" aria-level="2">Python学习（六）——配套《PyTorch深度学习实战》</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-numpy介绍">1. NumPy介绍</h2>
<p><img src="https://img2024.cnblogs.com/blog/2760960/202501/2760960-20250105213323339-534650490.png" alt="gg" loading="lazy"><br>
这张图片介绍了Python中两个非常重要的科学计算库：NumPy和SciPy，以及它们的核心功能和特性。</p>
<h3 id="numpy">NumPy</h3>
<p>NumPy（Numerical Python）是一个开源的Python科学计算库，用于进行大规模数值和矩阵运算。以下是图片中提到的NumPy的关键特性：</p>
<ul>
<li><strong>NumPy数组</strong>：类似于Matlab中的矩阵，NumPy数组是NumPy的核心数据结构，用于存储同类型数据的集合。</li>
<li><strong>数据分析的核心基础库</strong>：NumPy提供了大量的数学函数来操作数组，使其成为数据分析和科学计算的基础。</li>
<li><strong>数组的生成和方法</strong>：NumPy提供了多种方法来生成数组，并提供了丰富的方法来操作这些数组。</li>
<li><strong>数组广播</strong>：NumPy支持数组广播，这是一种强大的机制，允许NumPy用不同大小的数组进行算术运算。广播规则允许较小的数组“扩展”以匹配较大数组的形状，只要它们在相应的维度上兼容。例如，一个形状为<code>2x3x1</code>的数组可以与一个形状为<code>5x1x3x4</code>的数组进行运算，因为其中一个维度为1，可以广播以匹配另一个数组的相应维度。</li>
<li><strong>高维数组的索引（花式索引）</strong>：NumPy允许使用复杂的索引技术，如花式索引，来选择数组的子集。</li>
<li><strong>随机数组的生成</strong>：NumPy提供了生成随机数数组的功能，这对于模拟和统计分析非常有用。</li>
</ul>
<h3 id="scipy">SciPy</h3>
<p>SciPy（Scientific Python）是一个开源的Python算法库和数学工具包，用于科学和工程计算。它建立在NumPy之上，提供了更多的功能。以下是图片中提到的SciPy的关键模块：</p>
<ul>
<li><strong>插值</strong>：<code>scipy.interpolate</code>模块提供了各种插值方法，用于估计数据点之间的值。</li>
<li><strong>统计</strong>：<code>scipy.stats</code>模块提供了统计分布、统计测试和统计数据的统计描述。</li>
<li><strong>优化</strong>：<code>scipy.optimize</code>模块提供了多种优化算法，用于找到函数的最小值或最大值。</li>
<li><strong>积分</strong>：<code>scipy.integrate</code>模块提供了数值积分的方法，用于计算定积分或不定积分。</li>
<li><strong>线代</strong>：<code>scipy.linalg</code>模块提供了线性代数的基本操作，包括矩阵分解、特征值问题等。</li>
</ul>
<p>这两个库是Python科学计算生态系统的基石，广泛应用于数据科学、机器学习、工程和科学领域。</p>
<hr>
<h2 id="2-列表和数组的区别">2. 列表和数组的区别</h2>
<p>数组（Arrays）和列表（Lists）是编程中用于存储多个值的两种不同的数据结构，它们在不同编程语言中有着不同的实现和特性。在Python中，列表是一种内置的数据结构，而数组则通常通过第三方库（如NumPy）实现。以下是数组和列表在Python中的主要区别：</p>
<h3 id="1-元素类型">1. 元素类型</h3>
<ul>
<li><strong>列表</strong>：可以包含不同类型的元素，例如整数、字符串、浮点数、甚至是其他列表或对象。列表是异构的。</li>
<li><strong>NumPy数组</strong>：通常要求所有元素都是相同的数据类型，这使得数组在处理数值计算时更加高效。数组是同构的。</li>
</ul>
<h3 id="2-性能">2. 性能</h3>
<ul>
<li><strong>列表</strong>：由于其灵活性，列表在执行数值计算时可能不如数组高效，尤其是在处理大量数据时。</li>
<li><strong>NumPy数组</strong>：为了提高性能，NumPy数组在内存中是连续存储的，这使得它们在进行向量化操作时非常快速。</li>
</ul>
<h3 id="3-内存使用">3. 内存使用</h3>
<ul>
<li><strong>列表</strong>：由于存储了元素的类型信息，列表可能使用更多的内存。</li>
<li><strong>NumPy数组</strong>：因为所有元素类型相同，数组可以更紧凑地存储数据，通常使用更少的内存。</li>
</ul>
<h3 id="4-功能和方法">4. 功能和方法</h3>
<ul>
<li><strong>列表</strong>：Python的列表提供了丰富的方法，如<code>append()</code>, <code>extend()</code>, <code>insert()</code>, <code>remove()</code>, <code>pop()</code>等，用于添加、删除和修改元素。</li>
<li><strong>NumPy数组</strong>：NumPy数组提供了大量的数学和统计方法，这些方法在列表中不可用，如<code>mean()</code>, <code>std()</code>, <code>sum()</code>, <code>cumprod()</code>等。</li>
</ul>
<h3 id="5-索引和切片">5. 索引和切片</h3>
<ul>
<li><strong>列表</strong>：支持基于0的索引和负索引，以及切片操作。</li>
<li><strong>NumPy数组</strong>：同样支持基于0的索引、负索引和切片，但还支持更高级的索引技术，如花式索引和布尔索引。</li>
</ul>
<h3 id="6-广播">6. 广播</h3>
<ul>
<li><strong>列表</strong>：不支持广播机制。</li>
<li><strong>NumPy数组</strong>：支持广播，这是一种强大的机制，允许NumPy用不同大小的数组进行算术运算。</li>
</ul>
<h3 id="7-可变性">7. 可变性</h3>
<ul>
<li><strong>列表</strong>：是可变的，意味着你可以在不改变列表身份的情况下更改其内容。</li>
<li><strong>NumPy数组</strong>：也是可变的，但对数组的某些操作（如改变形状或大小）会创建一个新的数组。</li>
</ul>
<h3 id="8-使用场景">8. 使用场景</h3>
<ul>
<li><strong>列表</strong>：适用于存储不同类型的数据，或者当你需要存储的数据结构不规则时。</li>
<li><strong>NumPy数组</strong>：适用于数值计算，特别是当你需要处理大量数值数据并进行向量化操作时。</li>
</ul>
<p>在Python中，如果你需要进行高效的数值计算，使用NumPy数组通常是更好的选择。如果你需要一个灵活的数据结构来存储不同类型的数据，那么列表可能更合适。</p>
<blockquote>
<p>对两者进行形象化的解释</p>
</blockquote>
<p>让我们通过一些比喻来形象化地解释Python中数组和列表的区别：</p>
<h3 id="列表lists购物清单">列表（Lists）：购物清单</h3>
<p>想象一下，你有一个购物清单，上面可以写任何你想要的东西，无论是苹果、牛奶还是洗洁精。你可以在清单上添加新项目，划掉已经购买的物品，或者在任何位置插入新项目。这个清单没有严格的规则，你可以随意修改它。</p>
<ul>
<li><strong>灵活性</strong>：就像购物清单可以包含任何商品，Python列表可以包含任何类型的元素。</li>
<li><strong>修改</strong>：你可以在购物清单上自由添加或删除项目，同样，Python列表也允许你添加、删除或修改元素。</li>
</ul>
<h3 id="数组arrays图书馆的书架">数组（Arrays）：图书馆的书架</h3>
<p>现在，想象一下图书馆里的书架。每个书架（数组）都是为特定类型的书设计的，比如小说、科学或历史。你不能在小说书架上放一本科学书。书架上的书籍按照一定的顺序排列，你可以通过编号快速找到它们。</p>
<ul>
<li><strong>统一性</strong>：图书馆的每个书架都只存放一种类型的书，同样，NumPy数组中的所有元素必须是相同的数据类型。</li>
<li><strong>效率</strong>：图书馆的书籍按照编号排列，使得查找变得非常快速。NumPy数组在内存中连续存储，这使得它们在进行数值计算时非常高效。</li>
</ul>
<h3 id="性能赛车与普通汽车">性能：赛车与普通汽车</h3>
<ul>
<li><strong>列表</strong>：就像一辆普通汽车，它可以在各种道路上行驶，但可能不是最快的。在处理大量数据或需要高性能计算时，列表可能不是最高效的选择。</li>
<li><strong>NumPy数组</strong>：就像一辆赛车，它在直道上（数值计算）可以跑得非常快，但在曲折的山路上（复杂的数据结构）可能不太灵活。</li>
</ul>
<h3 id="内存使用小房子与大房子">内存使用：小房子与大房子</h3>
<ul>
<li><strong>列表</strong>：就像一个小房子，每个房间（元素）都可以存放不同的东西，但可能需要更多的空间来存放各种物品。</li>
<li><strong>NumPy数组</strong>：就像一个大房子，所有房间（元素）都是相同的，这使得空间利用更加高效，但可能不允许存放不同类型的物品。</li>
</ul>
<p>通过这些比喻，我们可以更直观地理解Python中列表和数组的区别，以及它们在不同场景下的适用性。列表提供了灵活性和多样性，而数组提供了效率和统一性。</p>
<hr>
<h2 id="3-python中的数据类型">3. Python中的数据类型</h2>
<p>在Python中，数组通常是指NumPy库中的数组，它们支持多种数据类型。NumPy数组的数据类型（dtype）决定了数组中每个元素的存储方式和所占空间。以下是一些常见的NumPy数据类型：</p>
<ol>
<li>
<p><strong>整数类型</strong>：</p>
<ul>
<li><code>int8</code>：8位有符号整数</li>
<li><code>int16</code>：16位有符号整数</li>
<li><code>int32</code>：32位有符号整数</li>
<li><code>int64</code>：64位有符号整数</li>
<li><code>uint8</code>：8位无符号整数</li>
<li><code>uint16</code>：16位无符号整数</li>
<li><code>uint32</code>：32位无符号整数</li>
<li><code>uint64</code>：64位无符号整数</li>
</ul>
</li>
<li>
<p><strong>浮点类型</strong>：</p>
<ul>
<li><code>float16</code>：16位半精度浮点数</li>
<li><code>float32</code>：32位单精度浮点数</li>
<li><code>float64</code>：64位双精度浮点数</li>
<li><code>float128</code>：128位扩展精度浮点数（在某些平台上可用）</li>
</ul>
</li>
<li>
<p><strong>复数类型</strong>：</p>
<ul>
<li><code>complex64</code>：64位复数（32位实部和32位虚部）</li>
<li><code>complex128</code>：128位复数（64位实部和64位虚部）</li>
<li><code>complex256</code>：256位复数（在某些平台上可用）</li>
</ul>
</li>
<li>
<p><strong>布尔类型</strong>：</p>
<ul>
<li><code>bool_</code>：布尔类型，用于存储True或False值</li>
</ul>
</li>
<li>
<p><strong>对象类型</strong>：</p>
<ul>
<li><code>object_</code>：可以存储Python对象的数组</li>
</ul>
</li>
<li>
<p><strong>字符串类型</strong>：</p>
<ul>
<li><code>str_</code>：字符串类型，用于存储文本数据</li>
<li><code>bytes_</code>：字节类型，用于存储原始字节数据</li>
<li><code>unicode_</code>：Unicode字符串类型，用于存储Unicode文本数据</li>
</ul>
</li>
<li>
<p><strong>日期和时间类型</strong>：</p>
<ul>
<li><code>datetime64</code>：日期和时间类型，可以指定不同的时间分辨率，如<code>datetime64[s]</code>表示秒级分辨率</li>
</ul>
</li>
<li>
<p><strong>时间差类型</strong>：</p>
<ul>
<li><code>timedelta64</code>：时间差类型，用于表示两个日期或时间之间的差异</li>
</ul>
</li>
<li>
<p><strong>自定义类型</strong>：</p>
<ul>
<li>用户可以定义自己的数据类型，通过组合现有的数据类型来创建结构化数组。</li>
</ul>
</li>
</ol>
<p>NumPy数组的dtype是固定的，这意味着一旦数组被创建，其dtype就不能改变。如果你需要改变数组的数据类型，你必须创建一个新的数组。例如：</p>
<pre><code class="language-python">import numpy as np

# 创建一个整数数组
int_array = np.array([1, 2, 3], dtype=np.int32)

# 创建一个浮点数数组
float_array = np.array([1.0, 2.0, 3.0], dtype=np.float64)

# 创建一个布尔数组
bool_array = np.array([True, False, True], dtype=np.bool_)

# 创建一个字符串数组
str_array = np.array(['hello', 'world'], dtype=np.str_)
</code></pre>
<p>在创建数组时，你可以指定dtype参数来定义数组的数据类型。如果不指定，NumPy会根据提供的元素自动推断dtype。</p>
<hr>
<h2 id="4-数组中axis是什么">4. 数组中axis是什么</h2>
<p>在NumPy和类似库中，<code>axis</code>是一个非常重要的概念，它用于指定在多维数组（如矩阵）上进行操作的维度。<code>axis</code>参数在许多NumPy函数中都有出现，比如<code>mean()</code>, <code>std()</code>, <code>sum()</code>, <code>argmax()</code>等，它允许你指定沿着哪个轴进行计算。</p>
<h3 id="理解axis">理解<code>axis</code></h3>
<p>在二维数组（矩阵）中，<code>axis</code>可以取以下几个值：</p>
<ul>
<li><code>axis=0</code>：沿着列操作，<strong>即对每一列的元素进行操作</strong>。这通常意味着函数将应用于数组的每一行。</li>
<li><code>axis=1</code>：沿着行操作，<strong>即对每一行的元素进行操作</strong>。这通常意味着函数将应用于数组的每一列。</li>
</ul>
<p>在更高维度的数组中，<code>axis</code>可以是任何从0到<code>n-1</code>的整数（其中<code>n</code>是数组的维度数），表示沿着第<code>axis</code>个维度进行操作。</p>
<h3 id="示例">示例</h3>
<p>假设你有一个二维数组，表示为一个矩阵：</p>
<pre><code class="language-python">import numpy as np

# 创建一个3x3的数组
array_2d = np.array([[1, 2, 3],
                     [4, 5, 6],
                     [7, 8, 9]])
</code></pre>
<p>如果你想计算每一列的平均值，你可以这样做：</p>
<pre><code class="language-python">mean_by_column = np.mean(array_2d, axis=0)
</code></pre>
<p>这将返回一个包含每列平均值的一维数组：<code>[4., 5., 6.]</code>。</p>
<p>相反，如果你想计算每一行的平均值，你可以这样做：</p>
<pre><code class="language-python">mean_by_row = np.mean(array_2d, axis=1)
</code></pre>
<p>这将返回一个包含每行平均值的一维数组：<code>[2., 5., 8.]</code>。</p>
<h3 id="多维数组">多维数组</h3>
<p>对于多维数组，<code>axis</code>的概念扩展到更多的维度。例如，一个三维数组可以看作是一个“堆叠”的矩阵，你可以沿着第一个维度（<code>axis=0</code>）、第二个维度（<code>axis=1</code>）或第三个维度（<code>axis=2</code>）进行操作。</p>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>如果不指定<code>axis</code>，某些函数可能会返回一个降维的结果，或者在所有元素上进行操作。</li>
<li>在使用<code>axis</code>时，确保它不超过数组的维度数减一（例如，对于三维数组，<code>axis</code>的有效值是0、1或2）。</li>
</ul>
<p>通过理解<code>axis</code>，你可以更精确地控制NumPy函数在多维数组上的操作维度，这对于数据分析和科学计算至关重要。</p>
<hr>
<h2 id="5-如何用numpy实现矩阵">5. 如何用numpy实现矩阵</h2>
<blockquote>
<p>直接写就可以</p>
</blockquote>
<p>在Python中，使用NumPy库可以方便地实现矩阵的各种操作。以下是一些基本的步骤和示例，展示如何使用NumPy来创建和操作矩阵：</p>
<h3 id="1-安装numpy">1. 安装NumPy</h3>
<p>如果你还没有安装NumPy，可以通过pip安装：</p>
<pre><code class="language-bash">pip install numpy
</code></pre>
<h3 id="2-导入numpy">2. 导入NumPy</h3>
<p>在Python脚本或交互式环境中导入NumPy：</p>
<pre><code class="language-python">import numpy as np
</code></pre>
<h3 id="3-创建矩阵">3. 创建矩阵</h3>
<p>有多种方式可以创建NumPy矩阵：</p>
<h4 id="从列表创建矩阵">从列表创建矩阵</h4>
<pre><code class="language-python"># 使用嵌套列表创建矩阵
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])
print(matrix)
</code></pre>
<h4 id="使用npzeros创建零矩阵">使用<code>np.zeros</code>创建零矩阵</h4>
<pre><code class="language-python"># 创建一个3x3的零矩阵
zero_matrix = np.zeros((3, 3))
print(zero_matrix)
</code></pre>
<h4 id="使用npones创建单位矩阵">使用<code>np.ones</code>创建单位矩阵</h4>
<pre><code class="language-python"># 创建一个3x3的单位矩阵
ones_matrix = np.ones((3, 3))
print(ones_matrix)
</code></pre>
<h4 id="使用npeye创建对角矩阵">使用<code>np.eye</code>创建对角矩阵</h4>
<pre><code class="language-python"># 创建一个3x3的对角矩阵
identity_matrix = np.eye(3)
print(identity_matrix)
</code></pre>
<h4 id="使用nprandom创建随机矩阵">使用<code>np.random</code>创建随机矩阵</h4>
<pre><code class="language-python"># 创建一个3x3的随机矩阵
random_matrix = np.random.rand(3, 3)
print(random_matrix)
</code></pre>
<h3 id="4-矩阵的基本操作">4. 矩阵的基本操作</h3>
<h4 id="矩阵加法">矩阵加法</h4>
<pre><code class="language-python"># 矩阵加法
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
sum_matrix = matrix1 + matrix2
print(sum_matrix)
</code></pre>
<h4 id="矩阵乘法">矩阵乘法</h4>
<pre><code class="language-python"># 矩阵乘法
product_matrix = np.dot(matrix1, matrix2)
print(product_matrix)
</code></pre>
<h4 id="矩阵转置">矩阵转置</h4>
<pre><code class="language-python"># 矩阵转置
transpose_matrix = matrix1.T
print(transpose_matrix)
</code></pre>
<h4 id="矩阵的逆">矩阵的逆</h4>
<pre><code class="language-python"># 矩阵的逆（需要是方阵）
if matrix1.shape[0] == matrix1.shape[1]:
    inverse_matrix = np.linalg.inv(matrix1)
    print(inverse_matrix)
</code></pre>
<h4 id="矩阵的行列式">矩阵的行列式</h4>
<pre><code class="language-python"># 矩阵的行列式（需要是方阵）
if matrix1.shape[0] == matrix1.shape[1]:
    det = np.linalg.det(matrix1)
    print(det)
</code></pre>
<h3 id="5-高级操作">5. 高级操作</h3>
<p>NumPy提供了许多用于矩阵运算的高级函数，如特征值、奇异值分解等，这些都可以在<code>numpy.linalg</code>模块中找到。</p>
<p>通过这些基本步骤，你可以开始使用NumPy进行矩阵运算和更复杂的数值计算。NumPy的文档提供了更详细的信息和高级功能。</p>
<blockquote>
<p>矩阵乘法的实现</p>
</blockquote>
<p>执行矩阵乘法<br>
在NumPy中，可以使用dot()函数或者@运算符来执行矩阵乘法：</p>
<p>使用dot()函数</p>
<h3 id="使用dot函数进行矩阵乘法">使用dot函数进行矩阵乘法</h3>
<p>product = np.dot(matrix_a, matrix_b)<br>
print("Matrix product using dot():\n", product)<br>
使用@运算符</p>
<h3 id="使用运算符进行矩阵乘法">使用@运算符进行矩阵乘法</h3>
<p>product = matrix_a @ matrix_b<br>
print("Matrix product using @ operator:\n", product)</p>
<hr>
<h2 id="6-广播机制">6. 广播机制</h2>
<p>NumPy数组的广播（Broadcasting）机制是一种强大的特性，它允许NumPy在执行数组运算时，自动扩展较小的数组以匹配较大数组的形状。这种机制在不实际复制数据的情况下，提供了一种便捷的方式来执行数组间的算术运算。广播机制遵循以下规则：</p>
<ol>
<li>
<p><strong>维度匹配</strong>：从两个数组的尾部（最右边）开始比较维度，如果两个数组在某个维度上的长度相同，或者其中一个数组在该维度上的长度为1，则认为这两个维度是兼容的。</p>
</li>
<li>
<p><strong>广播扩展</strong>：如果一个数组在某个维度上的长度为1，NumPy会将其沿着该维度扩展以匹配另一个数组的形状。这意味着长度为1的维度可以被视为任何长度。</p>
</li>
<li>
<p><strong>逐元素运算</strong>：一旦两个数组的形状兼容，NumPy就会逐元素地执行运算。在扩展后的数组中，每个元素都会与另一个数组中相应位置的元素进行运算。</p>
</li>
</ol>
<h3 id="广播示例">广播示例</h3>
<p>假设有两个数组 <code>a</code> 和 <code>b</code>：</p>
<pre><code class="language-python">import numpy as np

a = np.array([1, 2, 3])  # 形状为 (3,)
b = np.array([[1], [2], [3]])  # 形状为 (3, 1)
</code></pre>
<p>尽管 <code>a</code> 和 <code>b</code> 的形状不同，但它们在进行逐元素加法时可以广播：</p>
<pre><code class="language-python">c = a + b  # 结果的形状为 (3, 3)
</code></pre>
<p>在执行加法时，<code>a</code> 会在列方向上广播，<code>b</code> 会在行方向上广播，以匹配对方的形状。结果是：</p>
<pre><code>[[2 2 3]
 [3 4 5]
 [4 5 6]]
</code></pre>
<h3 id="广播的维度规则">广播的维度规则</h3>
<ul>
<li>如果两个数组的维度不同，那么较小维度的数组会在前面补1，直到两个数组的维度相同。</li>
<li>如果两个数组在某个维度上的长度相同，或者其中一个数组在该维度上的长度为1，那么这两个数组在该维度上是兼容的。</li>
<li>如果两个数组在某个维度上的长度都不为1，且不相等，那么它们在该维度上不兼容，不能进行广播。</li>
</ul>
<h3 id="广播的用途">广播的用途</h3>
<p>广播机制在NumPy中非常有用，因为它允许你：</p>
<ul>
<li>进行不同大小数组间的运算，而不需要显式地重塑数组。</li>
<li>简化代码，减少内存使用，因为不需要复制数据来扩展数组。</li>
<li>轻松实现向量化操作，如将一个值加到数组的每个元素上，或者比较数组与标量的每个元素。</li>
</ul>
<p>广播是NumPy中实现高效数值计算的关键特性之一。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.44855905621527775" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 00:07">2025-01-06 00:07</span>&nbsp;
<a href="https://www.cnblogs.com/jzzg">江左子固</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18654172" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18654172);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18654172', targetLink: 'https://www.cnblogs.com/jzzg/p/18654172', title: 'Python学习（六）——配套《PyTorch深度学习实战》' })">举报</a>
</div>
        