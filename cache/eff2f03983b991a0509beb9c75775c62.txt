
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18951795" title="发布于 2025-06-27 10:53">
    <span role="heading" aria-level="2">Java源码分析系列笔记-15.CompletableFuture</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-future-vs-completablefutre" rel="noopener nofollow">2. Future VS CompletableFutre</a></li><li><a href="#3-使用" rel="noopener nofollow">3. 使用</a><ul><li><a href="#31-运行一个不返回结果的任务" rel="noopener nofollow">3.1. 运行一个不返回结果的任务</a></li><li><a href="#32-运行一个返回结果的任务" rel="noopener nofollow">3.2. 运行一个返回结果的任务</a></li><li><a href="#33-线程池" rel="noopener nofollow">3.3. 线程池</a></li><li><a href="#34-手动完成任务" rel="noopener nofollow">3.4. 手动完成任务</a></li><li><a href="#35-回调" rel="noopener nofollow">3.5. 回调</a></li><li><a href="#36-链式调用" rel="noopener nofollow">3.6. 链式调用</a></li><li><a href="#37-组合多个completablefuture" rel="noopener nofollow">3.7. 组合多个CompletableFuture</a></li><li><a href="#38-异常处理" rel="noopener nofollow">3.8. 异常处理</a></li></ul></li><li><a href="#4-源码分析" rel="noopener nofollow">4. 源码分析</a><ul><li><a href="#41-类图" rel="noopener nofollow">4.1. 类图</a></li><li><a href="#42-属性" rel="noopener nofollow">4.2. 属性</a><ul><li><a href="#421-altresult" rel="noopener nofollow">4.2.1. AltResult</a></li></ul></li><li><a href="#43-runasync" rel="noopener nofollow">4.3. runAsync</a><ul><li><a href="#431-初始化默认的线程池" rel="noopener nofollow">4.3.1. 初始化默认的线程池</a></li><li><a href="#432-把执行的任务runnable和接收结果completablefuture封装到asyncrun" rel="noopener nofollow">4.3.2. 把执行的任务【Runnable】和接收结果【CompletableFuture】封装到AsyncRun</a></li><li><a href="#433-调用线程池的execute方法执行上面的asyncrun" rel="noopener nofollow">4.3.3. 调用线程池的execute方法执行上面的AsyncRun</a></li></ul></li><li><a href="#44-supplyasync" rel="noopener nofollow">4.4. supplyAsync</a><ul><li><a href="#441-初始化默认的线程池" rel="noopener nofollow">4.4.1. 初始化默认的线程池</a></li><li><a href="#442-把执行的任务supplier和接收结果completablefuture封装到asyncsupply" rel="noopener nofollow">4.4.2. 把执行的任务【Supplier】和接收结果【CompletableFuture】封装到AsyncSupply</a></li><li><a href="#443-调用线程池的execute方法执行上面的asyncrun" rel="noopener nofollow">4.4.3. 调用线程池的execute方法执行上面的AsyncRun</a></li></ul></li><li><a href="#45-complete" rel="noopener nofollow">4.5. complete</a><ul><li><a href="#451-手动设置结果" rel="noopener nofollow">4.5.1. 手动设置结果</a></li><li><a href="#452-执行钩子方法" rel="noopener nofollow">4.5.2. 执行钩子方法</a></li></ul></li></ul></li><li><a href="#5-参考" rel="noopener nofollow">5. 参考</a></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<p>用于异步编程。（准备说是非阻塞）<br>
Java中所谓的异步编程其实就是把阻塞的代码放在一个单独的线程中执行，并且有结果时会通知主线程</p>
<h2 id="2-future-vs-completablefutre">2. Future VS CompletableFutre</h2>
<table>
<thead>
<tr>
<th></th>
<th>Future</th>
<th>CompletableFutre</th>
</tr>
</thead>
<tbody>
<tr>
<td>结果获取方式</td>
<td>主动轮询。使用isDone来检查调用是否完成，get用来获取执行的结果</td>
<td>异步回调。使用回调函数</td>
</tr>
<tr>
<td>异常处理</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>链式调用</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>可以手动完成一个任务</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h2 id="3-使用">3. 使用</h2>
<h3 id="31-运行一个不返回结果的任务">3.1. 运行一个不返回结果的任务</h3>
<pre><code class="language-java">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {
        try
        {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e)
        {
            throw new IllegalStateException(e);
        }
        System.out.println("后台任务完成");
    });

    future.get();
</code></pre>
<h3 id="32-运行一个返回结果的任务">3.2. 运行一个返回结果的任务</h3>
<pre><code class="language-java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        try
        {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e)
        {
            throw new IllegalStateException(e);
        }
       return "后台任务完成";
    });

    String s = future.get();
    System.out.println(s);
</code></pre>
<h3 id="33-线程池">3.3. 线程池</h3>
<p>默认使用ForkJoin的commonpool里的线程池执行任务，但是也可以使用Executor作为第二个参数指定运行的线程池</p>
<pre><code class="language-java">Executor executor = Executors.newFixedThreadPool(10);
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
try {
    TimeUnit.SECONDS.sleep(1);
} catch (InterruptedException e) {
    throw new IllegalStateException(e);
}
return "Result of the asynchronous computation";
}, executor);

</code></pre>
<h3 id="34-手动完成任务">3.4. 手动完成任务</h3>
<pre><code class="language-java">CompletableFuture&lt;String&gt; stringCompletableFuture = new CompletableFuture&lt;&gt;();

    new Thread(()-&gt;{
        try
        {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }

       stringCompletableFuture.complete("手动完成任务");
    }).run();

    String s = stringCompletableFuture.get();
    System.out.println(s);
</code></pre>
<h3 id="35-回调">3.5. 回调</h3>
<ul>
<li>thenApply() 接受结果作为参数，有返回</li>
<li>thenAccept() 接受结果作为参数，无返回</li>
<li>thenRun() 无参数，无返回</li>
</ul>
<pre><code class="language-java">System.out.println("start");
    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        try
        {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e)
        {
            throw new IllegalStateException(e);
        }
        return "后台任务完成";
    });

    future.thenAccept(System.out::println);

    System.out.println("主线程继续执行并且休眠10s");

    TimeUnit.SECONDS.sleep(10);
</code></pre>
<h3 id="36-链式调用">3.6. 链式调用</h3>
<pre><code class="language-java">System.out.println("start");
    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        try
        {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e)
        {
            throw new IllegalStateException(e);
        }
        return "后台任务完成";
    });

    future.thenApply(s-&gt;{
        System.out.println(Thread.currentThread().getName() + "s");
        return s;
    }).thenApply(s-&gt;{
        System.out.println(Thread.currentThread().getName() + "s");
        return s;
    });

    System.out.println("主线程继续执行并且休眠10s");

    TimeUnit.SECONDS.sleep(10);
</code></pre>
<h3 id="37-组合多个completablefuture">3.7. 组合多个CompletableFuture</h3>
<ul>
<li>thenCompose() 有依赖的两个Future</li>
<li>thenCombine() 没有依赖的两个Future</li>
<li>CompletableFuture.allOf 所有Future完成</li>
<li>CompletableFuture.anyOf 任意一个Future完成</li>
</ul>
<pre><code class="language-java">System.out.println("start runnning............");
    long start = System.currentTimeMillis();
    CompletableFuture&lt;String&gt; future1
            = CompletableFuture.supplyAsync(() -&gt;
            {
                try
                {
                    TimeUnit.SECONDS.sleep(5);
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
                System.out.println("Hello" + Thread.currentThread().getName());
                return "Hello";
            }
    );
    CompletableFuture&lt;String&gt; future2
            = CompletableFuture.supplyAsync(() -&gt;
            {
                try
                {
                    TimeUnit.SECONDS.sleep(8);
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
                System.out.println("Beautiful" + Thread.currentThread().getName());

                return "Beautiful";
            }
    );
    CompletableFuture&lt;String&gt; future3
            = CompletableFuture.supplyAsync(() -&gt;
            {
                try
                {
                    TimeUnit.SECONDS.sleep(10);
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
                System.out.println("World" + Thread.currentThread().getName());

                return "World";
            }
    );

    CompletableFuture&lt;Void&gt; combinedFuture
            = CompletableFuture.allOf(future1, future2, future3);


    combinedFuture.get();

    long end = System.currentTimeMillis();

    System.out.println("finish run...time is " + (end-start));

    assertTrue(future1.isDone());
    assertTrue(future2.isDone());
    assertTrue(future3.isDone());

    System.out.println(future1.get());
    System.out.println(future2.get());
    System.out.println(future3.get());

</code></pre>
<h3 id="38-异常处理">3.8. 异常处理</h3>
<ul>
<li>exceptionally发生异常的时候调用</li>
<li>handle无论发生异常与否都调用</li>
</ul>
<pre><code class="language-java">CompletableFuture&lt;Object&gt; future = CompletableFuture.supplyAsync(() -&gt; {
            throw new IllegalArgumentException("Age can not be negative");
    }).exceptionally(ex -&gt; {
        System.out.println("Oops! We have an exception - " + ex.getMessage());
        return "Unknown!";
    });

System.out.println(future.get());

</code></pre>
<h2 id="4-源码分析">4. 源码分析</h2>
<h3 id="41-类图">4.1. 类图</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200117153056.png" class="lazyload"></p>
<p>可以看出CompletableFuture实现了Future接口，因此这玩意也是一个可以获取异步执行结果的接口</p>
<h3 id="42-属性">4.2. 属性</h3>
<pre><code class="language-java">volatile Object result;       // Either the result or boxed AltResult
volatile Completion stack;    // Top of Treiber stack of dependent actions
</code></pre>
<p>运行的结果存在<code>Object result</code>，如果发生了异常那么封装在AltResult</p>
<h4 id="421-altresult">4.2.1. AltResult</h4>
<pre><code class="language-java">static final class AltResult { // See above
    final Throwable ex;        // null only for NIL
    AltResult(Throwable x) { this.ex = x; }
}

/** The encoding of the null value. */
static final AltResult NIL = new AltResult(null);
</code></pre>
<h3 id="43-runasync">4.3. runAsync</h3>
<pre><code class="language-java">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {
    return asyncRunStage(asyncPool, runnable);
}
</code></pre>
<p>传入asyncPool和runnable任务调用asyncRunStage方法</p>
<p>我们先看看asyncPool是怎么初始化的</p>
<h4 id="431-初始化默认的线程池">4.3.1. 初始化默认的线程池</h4>
<pre><code class="language-java">//返回true
private static final boolean useCommonPool =
    (ForkJoinPool.getCommonPoolParallelism() &gt; 1);
//这里使用的是ForkJoinPool.commonPool()
private static final Executor asyncPool = useCommonPool ?
    ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();
</code></pre>
<p>所以默认使用的是<code>ForkJoinPool.commonPool()</code></p>
<p>有了默认的线程池，接下来调用的asyncRunStage方法</p>
<ul>
<li>asyncRunStage</li>
</ul>
<pre><code class="language-java">static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) {
    if (f == null) throw new NullPointerException();
    CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();
    e.execute(new AsyncRun(d, f));
    return d;
}
</code></pre>
<ul>
<li>2行：任务为空那么抛出异常</li>
<li>3行：构造CompletableFuture，用于接收结果</li>
<li>4行：先用CompletableFuture和Runnable构造AsyncRun，接口调用线程池Executor的execute方法执行这个AsyncRun</li>
<li>5行：返回CompletableFuture</li>
</ul>
<h4 id="432-把执行的任务runnable和接收结果completablefuture封装到asyncrun">4.3.2. 把执行的任务【Runnable】和接收结果【CompletableFuture】封装到AsyncRun</h4>
<p>先看看AsyncRun类</p>
<ul>
<li>AsyncRun</li>
</ul>
<pre><code class="language-java">static final class AsyncRun extends ForkJoinTask&lt;Void&gt;
        implements Runnable, AsynchronousCompletionTask {
    CompletableFuture&lt;Void&gt; dep; Runnable fn;
    AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) {
        this.dep = dep; this.fn = fn;
    }

    public final Void getRawResult() { return null; }
    public final void setRawResult(Void v) {}
    public final boolean exec() { run(); return true; }

    public void run() {
        CompletableFuture&lt;Void&gt; d; Runnable f;
        if ((d = dep) != null &amp;&amp; (f = fn) != null) {
            //清空CompletableFuture和Runnable
            dep = null; fn = null;
            //如果CompletableFuture的结果为空
            if (d.result == null) {
                try {
                    //那么执行Runnable方法
                    f.run();
                    //CAS设置CompletableFuture的结果为AltResult NIL--详见上面的AltResult
                    d.completeNull();
                } catch (Throwable ex) {
                    //抛出了异常则CAS设置CompletableFuture的结果为AltResult(异常)--详见上面的AltResult
                    d.completeThrowable(ex);
                }
            }
            d.postComplete();
        }
    }
}
</code></pre>
<ul>
<li>2行：实现了Runnable接口</li>
<li>4-6行：构造方法只是保存了传进来的Runnable和CompletableFuture</li>
<li>12-26行：线程池的execute方法最终会调用这个run方法。详细说明见注释。</li>
</ul>
<p>我们可以看看设置null结果和异常结果的方法</p>
<ul>
<li>completeNull【null】</li>
</ul>
<pre><code class="language-java">final boolean completeNull() {
    //CAS设置RESULT为NIL
    return UNSAFE.compareAndSwapObject(this, RESULT, null,
                                       NIL);
}
</code></pre>
<ul>
<li>completeThrowable【异常】</li>
</ul>
<pre><code class="language-java">static AltResult encodeThrowable(Throwable x) {
    return new AltResult((x instanceof CompletionException) ? x :
                         new CompletionException(x));
}

/** Completes with an exceptional result, unless already completed. */
final boolean completeThrowable(Throwable x) {
    //CAS设置RESULT为AltResult（异常）
    return UNSAFE.compareAndSwapObject(this, RESULT, null,
                                       encodeThrowable(x));
}
</code></pre>
<h4 id="433-调用线程池的execute方法执行上面的asyncrun">4.3.3. 调用线程池的execute方法执行上面的AsyncRun</h4>
<p>执行AsyncRun的时候最终会调用AsyncRun的run方法，分析如上面的<a href="#%E6%8A%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%90Runnable%E3%80%91%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BB%93%E6%9E%9C%E3%80%90CompletableFuture%E3%80%91%E5%B0%81%E8%A3%85%E5%88%B0AsyncRun" rel="noopener nofollow">把执行的任务【Runnable】和接收结果【CompletableFuture】封装到AsyncRun</a></p>
<h3 id="44-supplyasync">4.4. supplyAsync</h3>
<pre><code class="language-java">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
    return asyncSupplyStage(asyncPool, supplier);
}
</code></pre>
<p>传入默认的线程池asyncPool和任务supplier，这个supplier是Supplier【函数式接口】，如下图：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200117163021.png" class="lazyload"></p>
<h4 id="441-初始化默认的线程池">4.4.1. 初始化默认的线程池</h4>
<p>初始化默认的线程池跟上面的runAsync一样</p>
<p>我们接着跟踪asyncSupplyStage方法</p>
<ul>
<li>asyncSupplyStage</li>
</ul>
<pre><code class="language-java">static &lt;U&gt; CompletableFuture&lt;U&gt; asyncSupplyStage(Executor e,
                                                 Supplier&lt;U&gt; f) {
    if (f == null) throw new NullPointerException();
    CompletableFuture&lt;U&gt; d = new CompletableFuture&lt;U&gt;();
    e.execute(new AsyncSupply&lt;U&gt;(d, f));
    return d;
}
</code></pre>
<ul>
<li>2行：任务为空那么抛出异常</li>
<li>3行：构造CompletableFuture，用于接收结果</li>
<li>4行：先用CompletableFuture和Supplier构造AsyncSupply，接口调用线程池Executor的execute方法执行这个AsyncSupply</li>
<li>5行：返回CompletableFuture</li>
</ul>
<h4 id="442-把执行的任务supplier和接收结果completablefuture封装到asyncsupply">4.4.2. 把执行的任务【Supplier】和接收结果【CompletableFuture】封装到AsyncSupply</h4>
<ul>
<li>AsyncSupply</li>
</ul>
<pre><code class="language-java">static final class AsyncSupply&lt;T&gt; extends ForkJoinTask&lt;Void&gt;
        implements Runnable, AsynchronousCompletionTask {
    CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;
    AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) {
        this.dep = dep; this.fn = fn;
    }

    public final Void getRawResult() { return null; }
    public final void setRawResult(Void v) {}
    public final boolean exec() { run(); return true; }

    public void run() {
        CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;
        if ((d = dep) != null &amp;&amp; (f = fn) != null) {
            //清空CompletableFuture和Runnable
            dep = null; fn = null;
            //如果CompletableFuture的结果为空
            if (d.result == null) {
                try {
                    //调用Supplier.get获取结果
                    //然后调用CompletableFuture.completeValue把结果设置进
                    d.completeValue(f.get());
                } catch (Throwable ex) {
                    //抛出了异常则CAS设置CompletableFuture的结果为AltResult(异常)--详见上面的AltResult
                    d.completeThrowable(ex);
                }
            }
            d.postComplete();
        }
    }
}
</code></pre>
<ul>
<li>2行：实现了Runnable接口</li>
<li>4-6行：构造方法只是保存了传进来的Runnable和CompletableFuture</li>
<li>12-26行：线程池的execute方法最终会调用这个run方法。详细说明见注释。</li>
</ul>
<p>我们可以看看设置结果的completeValue方法</p>
<ul>
<li>completeValue</li>
</ul>
<pre><code class="language-java">final boolean completeValue(T t) {
    return UNSAFE.compareAndSwapObject(this, RESULT, null,
                                       (t == null) ? NIL : t);
}
</code></pre>
<h4 id="443-调用线程池的execute方法执行上面的asyncrun">4.4.3. 调用线程池的execute方法执行上面的AsyncRun</h4>
<p>执行AsyncRun的时候最终会调用AsyncRun的run方法，分析如上面的把执行的任务【Supplier】和接收结果【CompletableFuture】封装到AsyncSupply</p>
<h3 id="45-complete">4.5. complete</h3>
<pre><code class="language-java">public boolean complete(T value) {
    boolean triggered = completeValue(value);
    postComplete();
    return triggered;
}
</code></pre>
<ul>
<li>2行：手动设置结果</li>
<li>3行：执行钩子方法</li>
</ul>
<h4 id="451-手动设置结果">4.5.1. 手动设置结果</h4>
<pre><code class="language-java">final boolean completeValue(T t) {
    return UNSAFE.compareAndSwapObject(this, RESULT, null,
                                       (t == null) ? NIL : t);
}
</code></pre>
<h4 id="452-执行钩子方法">4.5.2. 执行钩子方法</h4>
<p>这段代码确定没看懂要干啥</p>
<pre><code class="language-java">final void postComplete() {
    /*
     * On each step, variable f holds current dependents to pop
     * and run.  It is extended along only one path at a time,
     * pushing others to avoid unbounded recursion.
     */
    CompletableFuture&lt;?&gt; f = this; Completion h;
    while ((h = f.stack) != null ||
           (f != this &amp;&amp; (h = (f = this).stack) != null)) {
        CompletableFuture&lt;?&gt; d; Completion t;
        if (f.casStack(h, t = h.next)) {
            if (t != null) {
                if (f != this) {
                    pushStack(h);
                    continue;
                }
                h.next = null;    // detach
            }
            f = (d = h.tryFire(NESTED)) == null ? this : d;
        }
    }
}
</code></pre>
<h2 id="5-参考">5. 参考</h2>
<ul>
<li><a href="https://juejin.im/post/5adbf8226fb9a07aac240a67" target="_blank" rel="noopener nofollow">Java 8 CompletableFuture 教程 - 掘金</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-27 10:53">2025-06-27 10:53</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18951795);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18951795', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18951795', title: 'Java源码分析系列笔记-15.CompletableFuture' })">举报</a>
</div>
        