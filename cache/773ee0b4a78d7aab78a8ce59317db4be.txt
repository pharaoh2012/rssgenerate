
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/morec/p/18921958" title="发布于 2025-06-10 12:14">
    <span role="heading" aria-level="2">理解堆排序的本质：建堆 + 交换 + 装箱+重复</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2 data-start="211" data-end="235">&nbsp;什么是堆排序（Heap Sort）？</h2>
<p data-start="237" data-end="308">堆排序是一种<strong data-start="243" data-end="261">基于堆这种特殊结构的选择排序</strong>。常见于不允许使用额外空间（in-place）的场景，且性能稳定为 <code data-start="295" data-end="307">O(n log n)</code>。</p>
<p data-start="310" data-end="327">它的过程可以非常简单地概括为四步：</p>
<h2 data-start="334" data-end="352">我的理解（堆排序核心步骤）</h2>
<ol data-start="354" data-end="548">
<li data-start="354" data-end="399">
<p data-start="357" data-end="371"><strong data-start="357" data-end="371">建最大堆（或最小堆）</strong></p>
<ul data-start="375" data-end="399">
<li data-start="375" data-end="399">
<p data-start="377" data-end="399">所有数据先变成一个“堆”（最大堆适用于升序）</p>
</li>
</ul>
</li>
<li data-start="401" data-end="447">
<p data-start="404" data-end="414"><strong data-start="404" data-end="414">交换顶底元素</strong></p>
<ul data-start="418" data-end="447">
<li data-start="418" data-end="447">
<p data-start="420" data-end="447">堆顶是最大元素，把它跟堆尾交换，最大元素被“摘出来了”</p>
</li>
</ul>
</li>
<li data-start="449" data-end="501">
<p data-start="452" data-end="462"><strong data-start="452" data-end="462">干掉底部元素</strong></p>
<ul data-start="466" data-end="501">
<li data-start="466" data-end="501">
<p data-start="468" data-end="501">把末尾元素从“堆”里踢出去，相当于缩小堆的尺寸，代表它已经排序完了</p>
</li>
</ul>
</li>
<li data-start="503" data-end="548">
<p data-start="506" data-end="516"><strong data-start="506" data-end="516">重复前面步骤</strong></p>
<ul data-start="520" data-end="548">
<li data-start="520" data-end="548">
<p data-start="522" data-end="548">对剩下的堆重新调整（堆化），最大值又回到堆顶，继续摘</p>
</li>
</ul>
</li>
</ol>
<p data-start="550" data-end="572">一直重复，直到堆中只剩一个元素——排序完成！</p>
<h2 data-start="579" data-end="599">图示演示（以最大堆升序为例）</h2>
<p data-start="601" data-end="632">初始数组：<code data-start="606" data-end="624">[4, 10, 3, 5, 1]</code><br data-start="624" data-end="627">
步骤如下：</p>
<div class="cnblogs_code">
<pre>Step <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">: 构建最大堆
        [</span><span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]

Step </span><span style="color: rgba(128, 0, 128, 1)">2</span>: 交换堆顶与堆尾 → [<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">]
        剔除堆尾（</span><span style="color: rgba(128, 0, 128, 1)">10</span>） → 只对前 <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)"> 个元素堆化

Step </span><span style="color: rgba(128, 0, 128, 1)">3</span>: 堆化 → [<span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">]

Step </span><span style="color: rgba(128, 0, 128, 1)">4</span>: 交换堆顶与堆尾 → [<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">]
        剔除 </span><span style="color: rgba(128, 0, 128, 1)">5</span> → 堆化前 <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)"> 个

...

最终结果：`[</span><span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>]`</pre>
</div>
<p>C# 实现（按步骤清晰注释）</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> HeapSorter
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> HeapSort(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">[] arr)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> n =<span style="color: rgba(0, 0, 0, 1)"> arr.Length;

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 1. 建最大堆</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = n / <span style="color: rgba(128, 0, 128, 1)">2</span> - <span style="color: rgba(128, 0, 128, 1)">1</span>; i &gt;= <span style="color: rgba(128, 0, 128, 1)">0</span>; i--<span style="color: rgba(0, 0, 0, 1)">)
            Heapify(arr, n, i);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 2. 顶底交换 + 3. 干掉底部元素 + 4. 重复</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = n - <span style="color: rgba(128, 0, 128, 1)">1</span>; i &gt; <span style="color: rgba(128, 0, 128, 1)">0</span>; i--<span style="color: rgba(0, 0, 0, 1)">)
        {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 交换堆顶和堆尾</span>
            (arr[<span style="color: rgba(128, 0, 128, 1)">0</span>], arr[i]) = (arr[i], arr[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">]);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 调整剩余部分为最大堆（i 是新堆的大小）</span>
            Heapify(arr, i, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 调整以 root 为根的子树，使其成为最大堆</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Heapify(<span style="color: rgba(0, 0, 255, 1)">int</span>[] arr, <span style="color: rgba(0, 0, 255, 1)">int</span> heapSize, <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> root)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> largest =<span style="color: rgba(0, 0, 0, 1)"> root;
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> left = <span style="color: rgba(128, 0, 128, 1)">2</span> * root + <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> right = <span style="color: rgba(128, 0, 128, 1)">2</span> * root + <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt;<span style="color: rgba(0, 0, 0, 1)"> arr[largest])
            largest </span>=<span style="color: rgba(0, 0, 0, 1)"> left;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt;<span style="color: rgba(0, 0, 0, 1)"> arr[largest])
            largest </span>=<span style="color: rgba(0, 0, 0, 1)"> right;

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (largest !=<span style="color: rgba(0, 0, 0, 1)"> root)
        {
            (arr[root], arr[largest]) </span>=<span style="color: rgba(0, 0, 0, 1)"> (arr[largest], arr[root]);
            Heapify(arr, heapSize, largest);
        }
    }
}</span></pre>
</div>
<p>Go 实现（同样思路）</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">package main

import (
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">fmt</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
)

func heapSort(arr []</span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">) {
    n :</span>=<span style="color: rgba(0, 0, 0, 1)"> len(arr)

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 1. 建最大堆</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> i := n/<span style="color: rgba(128, 0, 128, 1)">2</span> - <span style="color: rgba(128, 0, 128, 1)">1</span>; i &gt;= <span style="color: rgba(128, 0, 128, 1)">0</span>; i--<span style="color: rgba(0, 0, 0, 1)"> {
        heapify(arr, n, i)
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 2. 顶底交换 + 3. 干掉底部 + 4. 重复</span>
    <span style="color: rgba(0, 0, 255, 1)">for</span> i := n - <span style="color: rgba(128, 0, 128, 1)">1</span>; i &gt; <span style="color: rgba(128, 0, 128, 1)">0</span>; i--<span style="color: rgba(0, 0, 0, 1)"> {
        arr[</span><span style="color: rgba(128, 0, 128, 1)">0</span>], arr[i] = arr[i], arr[<span style="color: rgba(128, 0, 128, 1)">0</span>] <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 交换堆顶和堆尾</span>
        heapify(arr, i, <span style="color: rgba(128, 0, 128, 1)">0</span>)              <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 堆化剩下的部分</span>
<span style="color: rgba(0, 0, 0, 1)">    }
}

func heapify(arr []</span><span style="color: rgba(0, 0, 255, 1)">int</span>, heapSize <span style="color: rgba(0, 0, 255, 1)">int</span>, root <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">) {
    largest :</span>=<span style="color: rgba(0, 0, 0, 1)"> root
    left :</span>= <span style="color: rgba(128, 0, 128, 1)">2</span>*root + <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">
    right :</span>= <span style="color: rgba(128, 0, 128, 1)">2</span>*root + <span style="color: rgba(128, 0, 128, 1)">2</span>

    <span style="color: rgba(0, 0, 255, 1)">if</span> left &lt; heapSize &amp;&amp; arr[left] &gt;<span style="color: rgba(0, 0, 0, 1)"> arr[largest] {
        largest </span>=<span style="color: rgba(0, 0, 0, 1)"> left
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> right &lt; heapSize &amp;&amp; arr[right] &gt;<span style="color: rgba(0, 0, 0, 1)"> arr[largest] {
        largest </span>=<span style="color: rgba(0, 0, 0, 1)"> right
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> largest !=<span style="color: rgba(0, 0, 0, 1)"> root {
        arr[root], arr[largest] </span>=<span style="color: rgba(0, 0, 0, 1)"> arr[largest], arr[root]
        heapify(arr, heapSize, largest)
    }
}

func main() {
    arr :</span>= []<span style="color: rgba(0, 0, 255, 1)">int</span>{<span style="color: rgba(128, 0, 128, 1)">4</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">}
    fmt.Println(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">原始数组:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, arr)
    heapSort(arr)
    fmt.Println(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">排序后:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, arr)
}</span></pre>
</div>
<h2 data-start="2833" data-end="2845">总结一句话：</h2>
<blockquote data-start="2847" data-end="2900">
<p data-start="2849" data-end="2900">堆排序本质上是一个“摘最大值放到底部 + 重建最大堆”的过程，构造最大堆就是在为这个摘果子流程做准备。</p>
<p data-start="2849" data-end="2900">&nbsp;</p>
<h2 data-start="2907" data-end="2917">延伸阅读</h2>
<ul data-start="2919" data-end="3008">
<li data-start="2919" data-end="2944">
<p data-start="2921" data-end="2944">如果你用的是最小堆，也可以实现<strong data-start="2936" data-end="2944">降序排序</strong></p>
</li>
<li data-start="2945" data-end="2975">
<p data-start="2947" data-end="2975"><code data-start="2947" data-end="2965">PriorityQueue&lt;T&gt;</code> 是堆结构的实际应用</p>
</li>
<li data-start="2976" data-end="3008">
<p data-start="2978" data-end="3008">实时 TopK、图论中的 Dijkstra、调度算法都基于堆</p>
</li>
</ul>
</blockquote>
</div>
<div id="MySignature" role="contentinfo">
    <a href="https://github.com/liuzhixin405"><img loading="lazy" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-10 12:14">2025-06-10 12:14</span>&nbsp;
<a href="https://www.cnblogs.com/morec">星仔007</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18921958);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18921958', targetLink: 'https://www.cnblogs.com/morec/p/18921958', title: '理解堆排序的本质：建堆 + 交换 + 装箱+重复' })">举报</a>
</div>
        