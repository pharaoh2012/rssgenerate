
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/18747299" title="发布于 2025-03-03 09:17">
    <span role="heading" aria-level="2">Echarts与Vue3中获取DOM节点可能出现的异常错误</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="usetemplateref-的简单介绍">useTemplateRef 的简单介绍</h4>
<p>官方:返回一个浅层 ref，其值将与模板中的具有匹配 ref attribute 的元素或组件同步。<br>
参数匹配机制‌：useTemplateRe的参数需与模板中 ref 属性值必须完全一致<br>
‌响应式变量类型明确‌：返回值是一个 浅层 ref对象，其 .value 直接指向绑定的 DOM 元素或组件实例。</p>
<h4 id="usetemplateref源码浅析">useTemplateRef源码浅析</h4>
<p>packages/runtime-core/src/helpers/useTemplateRef.ts 文件中</p>
<pre><code>import { type ShallowRef, readonly, shallowRef } from '@vue/reactivity'
import { getCurrentInstance } from '../component'
import { warn } from '../warning'
import { EMPTY_OBJ } from '@vue/shared'
export function useTemplateRef(key) {
  // 获取当前 Vue 实例对象。
  const i = getCurrentInstance()
  // 创建一个浅层的ref对象r，初始值为null。 
  const r = shallowRef(null)
  //如果存在 Vue 实例
  if (i) {
    // i.refs 默认初始化为 EMPTY_OBJ（空对象）首次使用时动态创建新对象‌
    const refs = i.refs === EMPTY_OBJ ? (i.refs = {}) : i.refs
    Object.defineProperty(refs, key, {
        enumerable: true,
        get: () =&gt; r.value,
        set: val =&gt; (r.value = val),
      })
  }
  return r
}
</code></pre>
<p>1.获取当前 Vue 实例对象。<br>
2.创建一个浅层的ref对象r，初始值为null。<br>
3.如果存在 Vue 实例，则获取实例上的refs属性（用于存储模板引用）。<br>
4.使用Object.defineProperty对refs对象的key属性进行拦截：<br>
get拦截：返回r.value，即useTemplateRef返回的ref变量的值。<br>
set拦截：将val赋值给r.value，从而将 DOM 元素或组件实例绑定到ref变量上。<br>
5.返回ref对象r。</p>
<h4 id="下面这段代码看看有啥问题">下面这段代码看看有啥问题</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import * as echarts from 'echarts'
import { onMounted, useTemplateRef } from 'vue'
// useTemplateRef接受的是一个字符串，表示你要获取哪一个节点
const divNode = useTemplateRef("chartNode");
console.log(1111, divNode)
// 初始化图表
let chartDom = echarts.init(divNode);
onMounted(() =&gt; {
  drawCharts()
})
const drawCharts=()=&gt;{
  // 指定图表的配置项和数据
  let option = {
    xAxis: {
      type: 'category',
      data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月']
    },
    yAxis: {
      type: 'value'
    },
    tooltip: {
      trigger:'axis',
    },
    series:[
      {
        data: [1150, 200, 300, 356, 105, 200, 345],
        type: 'line'
      }
    ]
  };
  // 使用刚指定的配置项和数据显示图表。
  chartDom.setOption(option);
}
&lt;/script&gt;
&lt;style scoped&gt;
.pic{
  width: 600px;
  height: 380px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202503/1425695-20250303091511106-1317487382.jpg" alt="" loading="lazy"></p>
<h4 id="实际情况thisdomgetcontext-is-not-a-function">实际情况:this.dom.getContext is not a function</h4>
<p>报错信息: Uncaught (in promise) TypeError: this.dom.getContext is not a function<br>
01-echarts引入报错.jpg<br>
为啥会报这个错误呢?<br>
原因:因为在初始化echarts的时候，echarts规定只能传入实际的DOM元素。<br>
此时我们传递的是Ref对象,而不是实际的DOM元素<br>
需要传递 divNode.value。</p>
<h4 id="传递一个实际的dom元素divnodevalue">传递一个实际的DOM元素(divNode.value)</h4>
<pre><code>const divNode = useTemplateRef("chartNode");
console.log(1111, divNode)
// 初始化图表，传递实际DOM
let chartDom = echarts.init(divNode.value);
onMounted(() =&gt; {
  drawCharts()
})
const drawCharts=()=&gt;{
  ...代码爆出不变
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202503/1425695-20250303091522065-1341766319.jpg" alt="" loading="lazy"></p>
<h4 id="为啥还会报错error-initialize-failed-invalid-dom">为啥还会报错:Error: Initialize failed: invalid dom.</h4>
<p>原因在于：let chartDom = echarts.init(divNode.value);这一行代码。<br>
此时divNode.value为null。<br>
为啥是null呢？<br>
这个跟获取时机有关:此时还没有完成绑定哈，所以得到的是null。<br>
什么时候可以正常绑定呢？<br>
第1种：在onMounted中肯定是绑定了，此时divNode.value是一个实际的DOM元素了。<br>
第2种：与它同一级的DOM元素已经渲染完成(其实也是在onMounted)</p>
<h4 id="使用usetemplateref正常渲染图表">使用useTemplateRef正常渲染图表</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import * as echarts from 'echarts'
import { onMounted, useTemplateRef } from 'vue'
let chartDom = null //存储的是 ECharts 实例
// useTemplateRef接受的是一个字符串，表示你要获取哪一个节点
const divNode = useTemplateRef("chartNode");
console.log(222, divNode)
onMounted(() =&gt; {
  // 在onMounted中初始化图表，可以得到原生的DOM节点
  chartDom = echarts.init(divNode.value);
  // 调用图表
  drawCharts()
})
const drawCharts=()=&gt;{
  // 指定图表的配置项和数据
  let option = {
    xAxis: {
      type: 'category',
      data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月']
    },
    yAxis: {
      type: 'value'
    },
    tooltip: {
      trigger:'axis',
    },
    series:[
      {
        data: [1150, 200, 300, 356, 105, 200, 345],
        type: 'line'
      }
    ]
  };
  // 使用刚指定的配置项和数据显示图表。
  chartDom.setOption(option);
}
&lt;/script&gt;
&lt;style scoped&gt;
.pic{
  width: 600px;
  height: 380px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202503/1425695-20250303091529272-1886996341.jpg" alt="" loading="lazy"></p>
<h4 id="dom元素已经渲染完成usetemplateref拿到dom元素">DOM元素已经渲染完成,useTemplateRef拿到DOM元素</h4>
<pre><code>&lt;template&gt;
  &lt;div class="art-page"&gt;
    &lt;div ref="divNode"&gt;我是div元素&lt;/div&gt;
    &lt;button @click="getNodeHandler"&gt;我是按钮，获取div节点&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { useTemplateRef } from 'vue'
const divNode = useTemplateRef("divNode");
const getNodeHandler= () =&gt;{
  /**
   * 为啥这里的 divNode.value不是null
   * 因为：与它同一级的DOM元素已经渲染完成。
   * 也就是说:点击的时候已经渲染完成了。也就完成了DOM的绑定，因此可以拿到DOM元素
  */
  if(divNode.value){
    divNode.value.innerText = '通过dom来赋值';
  }
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202503/1425695-20250303091537654-1725939369.png" alt="" loading="lazy"></p>
<p>当然我们除了使用 useTemplateRef 来获取DOM元素<br>
还可以使用 ref 来获取DOM元素</p>
<h4 id="使用-ref-来获取dom元素">使用 ref 来获取DOM元素</h4>
<p>使用ref 来获取DOM元素需要注意的点。<br>
通过ref函数创建，并赋值给与模板中同名的变量。</p>
<pre><code class="language-html">&lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt; 
&lt;script setup&gt;
// 通过ref函数创建，并赋值给与模板中同名的变量。
const chartNode = ref(null)
&lt;/script&gt;
</code></pre>
<h4 id="错误的获取dom节点的方式">错误的获取DOM节点的方式</h4>
<pre><code class="language-html">&lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt; 
&lt;script setup&gt;
// 这一种是创建了一个响应式的对象。并不是获取DOM节点。
const node = ref('chartNode')
&lt;/script&gt;
</code></pre>
<h4 id="使用-ref-来获取dom元素并渲染echarts">使用 ref 来获取DOM元素，并渲染echarts</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import * as echarts from 'echarts'
import { onMounted,ref } from 'vue'
let chartDom = null //存储的是 ECharts 实例
let chartNode  = ref() // 通过ref函数创建，并赋值给与模板中同名的变量。
onMounted(() =&gt; {
  // 在onMounted中初始化图表，可以得到原生的DOM节点
  chartDom = echarts.init(chartNode.value);
  // 调用图表
  drawCharts()
})
const drawCharts=()=&gt;{
  // 指定图表的配置项和数据
  let option = {
    xAxis: {
      type: 'category',
      data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月']
    },
    yAxis: {
      type: 'value'
    },
    tooltip: {
      trigger:'axis',
    },
    series:[
      {
        data: [1150, 200, 300, 356, 105, 200, 345],
        type: 'line'
      }
    ]
  };
  // 使用刚指定的配置项和数据显示图表。
  chartDom.setOption(option);
}
&lt;/script&gt;
&lt;style scoped&gt;
.pic{
  width: 600px;
  height: 380px;
}
&lt;/style&gt;
</code></pre>
<h4 id="存储的是echarts实例变成响应式数据出现的问题">存储的是ECharts实例变成响应式数据出现的问题</h4>
<pre><code>&lt;template&gt;
  &lt;div class="chart-page"&gt;
    &lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import * as echarts from 'echarts'
import { onMounted,ref, onBeforeUnmount  } from 'vue'
// 存储 echarts 实例的变量
et chartDom = ref(null)
let chartNode  = ref()
onMounted(() =&gt; {
  // 存储的是 ECharts 实例此时是一个响应式的
  chartDom.value = echarts.init(chartNode.value);
  // 调用图表
  drawCharts()
  // 监听窗口大小变化，重绘图表
  window.addEventListener('resize', chartRedraw)
})
onBeforeUnmount(()=&gt;{
  window.removeEventListener('resize', chartRedraw)
})
const drawCharts = () =&gt; {
  let option = {
    ...配置不变
  }
  chartDom.value.setOption(option);
}
const chartRedraw = ()=&gt; {
  chartDom.value &amp;&amp; chartDom.value.resize()
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202503/1425695-20250303091549070-541678117.jpg" alt="" loading="lazy"></p>
<h4 id="缩放echarts出现cannot-read-properties-of-undefined-reading-type">缩放echarts出现:Cannot read properties of undefined (reading 'type')</h4>
<p>缩放窗口大小，echarts图表出现报错信息如下：<br>
Cannot read properties of undefined (reading 'type')<br>
原因是：存储的是 ECharts 实例变成了响应式,从而在resize 的时候获取不到。<br>
其实存储 ECharts 实例不应该是一个响应式的数据。<br>
就是一个普通类型的数据就行</p>
<h4 id="解决办法">解决办法</h4>
<p>现在我们知道出现问题的原因。<br>
解决办法就是不让它变成响应式的数据就行。<br>
1:存储的是 ECharts实例不要变成响应式,让其成为普通对象。<br>
2.使用markRaw将它标记为一个对象,使其不会被转换为响应式对象<br>
第1种我们已经使用过了，下面我们演示第2种</p>
<h4 id="vue3中的markraw">Vue3中的markRaw</h4>
<p>我的理解是:  ****<br>
用于‌标记一个对象，使其永远不会被转换为响应式对象‌。返回该对象本身。<br>
该对象即使被包裹在 reactive()、ref()、shallowReactive() 等响应式 API 中<br>
也会保持原始状态，不会触发依赖追踪和视图更新‌。<br>
官网的解释是：<br>
将一个对象标记为不可以被转化为代理对象。返回该对象本身。</p>
<h4 id="使用markraw来解决">使用markRaw来解决</h4>
<pre><code>&lt;script setup&gt;
import { onMounted,ref, onBeforeUnmount, markRaw } from 'vue'
// ...省略其他代码,其他代码不变，使用markRaw包裹
chartDom.value = markRaw(echarts.init(chartNode.value));
// ...省略其他代码,其他代码不变
&lt;/script&gt;
</code></pre>
<h4 id="切换页面的时候echarts实例会自动销毁嘛">切换页面的时候echarts实例会自动销毁嘛？</h4>
<p>不会的。需要手动销毁。<br>
‌在 Vue 中切换路由(页面)时或刷新页面时，ECharts 实例不会自动销毁。<br>
需手动调用 dispose() 方法销毁实例‌,否则会导致内存泄漏或二次渲染异常‌。</p>
<h4 id="销毁echarts实例">销毁ECharts实例</h4>
<pre><code>let chartDom = echarts.init('echarts容器');
// 销毁实例，避免内存泄漏
onBeforeUnmount(()=&gt;{
  chartDom &amp;&amp; chartDom.dispose()
})
&lt;script&gt;
</code></pre>
<h4 id="解决echarts第二次无法渲染的问题">解决echarts第二次无法渲染的问题</h4>
<pre><code>// 获取存储echarts容器的节点
let chartNode = document.getElementById('chart')
//移除容器上的 _echarts_instance_ 属性
chartNode.removeAttribute('_echarts_instance_')
</code></pre>
<h4 id="避免多次重复初始-echarts">避免多次重复初始 echarts</h4>
<p>通过 echarts.getInstanceByDom() 检查是否已存在实例，避免重复初始化‌</p>
<pre><code>&lt;template&gt;
  &lt;div class="chart-page"&gt;
    &lt;div class="pic" ref="chartNode"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref } from 'vue'
let chartNode  = ref()
// echarts.getInstanceByDom的参数是页面中渲染echarts的DOM节点
chartInstance = echarts.getInstanceByDom(chartNode.value);
// 检查是否已存在实例
if (!chartInstance) {
  console.log('实例不存在')
}else{
  console.log('实例已存在')
}
&lt;script&gt;
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06695071465625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-03 09:18">2025-03-03 09:17</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18747299" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18747299);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18747299', targetLink: 'https://www.cnblogs.com/IwishIcould/p/18747299', title: 'Echarts与Vue3中获取DOM节点可能出现的异常错误' })">举报</a>
</div>
        