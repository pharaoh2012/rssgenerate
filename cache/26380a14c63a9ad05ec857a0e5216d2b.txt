
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ishoulgodo/p/18695297" title="发布于 2025-01-30 19:35">
    <span role="heading" aria-level="2">java中的HashSet与 == 和 equals的区别</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="什么是hashset">什么是HashSet</h4>
<p>在 Java 中，HashSet 是一个基于哈希表实现的集合类，它实现了 Set 接口<br>
HashSet 的主要特点是:1,2</p>
<h4 id="hashset-的主要特点是">HashSet 的主要特点是</h4>
<p>1,集合中的数据不能够重复<br>
2,存储的数据是无序的(元素的存储顺序与插入顺序无关)<br>
3,允许 null 值: 可以存储一个 null 元素(感觉这个不算)</p>
<h4 id="hashset-的常用方法">HashSet 的常用方法</h4>
<p>boolean add(e)向集合中添加元素。如果元素已存在，则返回 false。<br>
boolean remove(Object o)从集合中移除指定元素。如果元素存在并成功移除，则返回 true。<br>
boolean contains(Object o)检查集合中是否包含指定元素。如果存在，则返回 true。<br>
int size()	返回集合中元素的数量。<br>
boolean isEmpty()检查集合是否为空。如果为空，则返回 true。<br>
void clear()清空集合中的所有元素。<br>
Iterator<e> iterator()	返回一个迭代器，用于遍历集合中的元素。<br>
Object[] toArray()	将集合转换为数组。</e></p>
<h4 id="hasset存储为啥是无序的">hasSet存储为啥是无序的</h4>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202501/1972489-20250130193328933-790540840.png" alt="" loading="lazy"></p>
<h4 id="hasset-存储为啥数据不能够重复">hasSet 存储为啥数据不能够重复</h4>
<p>hash存储是幂等性算法<br>
也就是说:你给我一个A，计算出来的是2。<br>
下次你再给一个A，计算出来的仍然是2。<br>
这样的话，就会造成一个问题。<br>
这个2要不要存储呢？<br>
hasSet会丢弃第2个相同的值，因此存储的数据是不能够重复的。</p>
<h4 id="存储数据是无序的">存储数据是无序的</h4>
<pre><code>package part;
// HashSet在util这个包中，需要我们引入
import java.util.HashSet;
public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("赵6");
        // 输出的来是： [赵6, 李四, 张三] 说明存储数据是无序的
        System.out.println(setObject);
    }
}
</code></pre>
<h4 id="存储的数据是不会重复的">存储的数据是不会重复的</h4>
<pre><code>public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("张三");
        // 输出的来是：
        System.out.println(setObject);
    }
}
</code></pre>
<h4 id="hashset如何修改数据">HashSet如何修改数据</h4>
<p>HashSet无法直接修改数据。<br>
我们需要先把某一条要修改的数据删除掉。在新增我们想要的数据</p>
<pre><code>package part;
// HashSet在util这个包中，需要我们引入
import java.util.HashSet;

public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        // 把张三更改为张3,我们先删除然后再新增
        setObject.remove("张三");
        setObject.add("张3");
        // 输出： [李四, 张3]
        System.out.println(setObject);
    }
}
</code></pre>
<h4 id="增强-for循环也称为-for-each-循环-来遍历数据">增强 for循环(也称为 for-each 循环) 来遍历数据</h4>
<pre><code class="language-java">package part;
// HashSet在util这个包中，需要我们引入
import java.util.HashSet;
public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 我们通过特殊for循环来遍历数据
        for (Object o : setObject) {
            System.out.println(o);
        }
    }
}
</code></pre>
<h4 id="增强-for循环的语法">增强 for循环的语法</h4>
<pre><code>for (元素类型 变量名 : 数组或集合) {
    // 循环体 
    // ps: 变量名是循环中的每一项
}
</code></pre>
<h4 id="hashsetadd新增元素如果元素已存在则返回-false">HashSet.add新增元素(如果元素已存在，则返回 false)</h4>
<pre><code>package part;
// HashSet在util这个包中，需要我们引入
import java.util.HashSet;
public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 输出的是 [李四, 张三, 王五]
        System.out.println(setObject);
    }
}
</code></pre>
<h4 id="hashsetaddall-将一个集合中的所有元素添加到另一个集合中">HashSet.addAll 将一个集合中的所有元素添加到另一个集合中</h4>
<pre><code>package part;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        ArrayList&lt;Integer&gt; listObject = new ArrayList();
        listObject.add(1);
        listObject.add(2);
        LinkedList linkedListObject = new LinkedList();
        linkedListObject.add("张三");
        // 添加一个ArrayList集合对象
        setObject.addAll(listObject);
        // 添加一个LinkedList集合对象
        setObject.addAll(linkedListObject);
        // 输出的是: [1, 2, 张三]
        System.out.println("setObject:" + setObject);
    }
}
</code></pre>
<h4 id="hashsettoarray-将hashset转化为数组">HashSet.toArray 将HashSet转化为数组</h4>
<pre><code class="language-java">public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 将 HashSet 转换为数组
        Object obj = setObject.toArray();
        System.out.println(obj);
    }
}
</code></pre>
<h4 id="hashsetsize-获取hashset-的长度">HashSet.size() 获取HashSet 的长度</h4>
<pre><code class="language-java">public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 获取HashSet 的长度
        int len = setObject.size();
        System.out.println(len);
    }
}
</code></pre>
<h4 id="hashsetclone-克隆">HashSet.clone 克隆</h4>
<pre><code class="language-java">package part;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 克隆HashSet，相当于复制了一份。但是我们需要使用Object来声明
        Object newSet = setObject.clone();
    }
}
</code></pre>
<h4 id="克隆-hashset-可以不用object来声明吗">克隆 HashSet 可以不用Object来声明吗?</h4>
<p>克隆 HashSet 可以不用 Object 来声明吗? 可以的。<br>
那为啥克隆需要使用 Object来声明呢？<br>
因为：clone() 方法的返回类型是 Object。所以我们需要使用Object来声明。<br>
我们可以使用强制转化来处理就行</p>
<pre><code class="language-java">public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 克隆HashSet，相当于复制了一份。我们可以使用强制转化来解决这个问题的
        HashSet newSet =(HashSet) setObject.clone();
    }
}
</code></pre>
<h4 id="hashsetremove被移除的对象">HashSet.remove(被移除的对象)</h4>
<p>要从 HashSet 中移除的对象。如果 HashSet 包含该对象，则会被移除。<br>
返回值是一个布尔值<br>
如果 HashSet 中包含指定的对象并且成功移除，则返回 true。<br>
如果 HashSet 中不包含该对象，则返回 false。</p>
<pre><code>public class Java01 {
    public static void main(String[] args) {
        HashSet setObject = new HashSet();
        setObject.add("张三");
        setObject.add("李四");
        setObject.add("王五");
        // 移除李四
        Boolean delStatus = setObject.remove("李四");
        // 输出的是true
        System.out.println(delStatus);
    }
}
</code></pre>
<h4 id="arraylistremove根据传参不同返回的类型不同">ArrayList.remove根据传参不同，返回的类型不同</h4>
<pre><code>ArrayList arrList = new ArrayList();
arrList.add("嘿嘿01");
// 传参的是数字，返回的是被删除的数据
Object oldValue = arrList.remove(0);
</code></pre>
<pre><code>public class Java01 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("A");
        // 传参字符串，返回来的是布尔
        Boolean flag = list.remove("A");
        System.out.println(flag);
    }
}

</code></pre>
<h4 id="hashset存储了相同的数据">HashSet存储了相同的数据</h4>
<pre><code>package part;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
       HashSet setList = new HashSet();
       User u1 = new User();
       User u2 = new User();
        u1.id = "2025_01_30";
        u1.name = "张三";
        u2.id = "2025_01_30";
        u2.name = "张三";
        setList.add(u1);
        setList.add(u2);
        // 大家认为会输出什么呢？
        // 输出的 [User [id=2025_01_30, name=张三], User [id=2025_01_30, name=张三]]
        System.out.println(setList);
    }
}

class User{
    String id;
    String name;
    // ctrl + o 就可以啦 现在我重写了 toString
    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + "]";
    }
}
</code></pre>
<p>不是说：HashSet中的数据不能重复吗？<br>
为啥会重复呢？<br>
因为:这2个对象在内存中是不同的地址哈~。<br>
所以HashSet会认为是不同的值。<br>
内存中是不同的地址我们一般认为是 hashCode不同(这种说法不准确,但是方便我们理解)<br>
ps: hashCode类似与内存中的地址</p>
<h4 id="解释为啥存储了相同的数据">解释为啥存储了相同的数据</h4>
<pre><code class="language-java">
package part;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
       HashSet setList = new HashSet();
       User u1 = new User();
       User u2 = new User();
        u1.id = "2025_01_30";
        u1.name = "张三";
        u2.id = "2025_01_30";
        u2.name = "张三";
        setList.add(u1);
        setList.add(u2);
        // hashCode 我们可以理解为内存中的地址(这种说法不准确,但是方便我们理解)
        System.out.println(u1.hashCode()); // 685325104
        System.out.println(u2.hashCode()); // 460141958
        // 我们发现这2个地址不同，就会认为是2个不同的对象，就会出现相同的数据
    }
}

class User{
    String id;
    String name;
    // ctrl + o 就可以啦
    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + "]";
    }
}
</code></pre>
<h4 id="如何如果让一个对象的id和name相同就让它识别为是同一个数据">如何如果让一个对象的id和name相同，就让它识别为是同一个数据</h4>
<p>如果让一个对象的id和name相同，就让它识别为是同一个数据呢？<br>
是可以的。我们需要重写2个方法；hashCode 和 equals<br>
因为: HashSet是在存储数据的时候,就是通过hashCode来操作的。<br>
我们给定一个值(字符串), 通过操作得到存储到哪一个位置。<br>
当然不同的值可能得到的存储位置是一样的。<br>
如果出现这样的情况，他会去比较他们的equals。<br>
如果相等，会把这个数据(后面这个新增的数据)丢弃，什么都不做。<br>
如果不相等，这个时候他会使用链表它装在一起哈。<br>
我们也可以从这里得出结论：HashSet的底层是:数组+链表的结构来进行存储数据的</p>
<h4 id="重写hashcode-和-equals">重写hashCode 和 equals</h4>
<pre><code class="language-java">
package part;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
       HashSet setList = new HashSet();
       User u1 = new User();
       User u2 = new User();
        u1.id = 2025;
        u1.name = "张三";
        u2.id = 2025;
        u2.name = "张三";
        setList.add(u1);
        setList.add(u2);
        // [User [id=2025, name=张三]] 现在数据就不会重复了
        System.out.println(setList);
    }
}

class User{
    int id;
    String name;
    //    重写方法的快捷键 ctrl+o
    @Override
    //  类似与我们的内存地址，我们使用id来判断
    public int hashCode() {
        return id;
    }

    @Override
    // 判断2个对象的属性是否完全相同
    public boolean equals(Object obj) {
        if(obj instanceof User) {
            //因为这个对象是User类型的，我们可以使用强制转换
            User u = (User)obj;
            //判断对象的属性是否相同,这里为啥使用equals，等会回说一下
            if(u.id==this.id &amp;&amp; u.name.equals(this.name)) {
                return true;
            }else{
                return false;
            }
        }else{
            // 如果不是，直接返回false
            return false;
        }
    }
    @Override
    public String toString() {
         return "User [id=" + id + ", name=" + name + "]";
    }
}
</code></pre>
<h4 id="hashset的底层是数组链表的结构来进行存储数据的">HashSet的底层是:数组+链表的结构来进行存储数据的</h4>
<h4 id="-和-equals的区别">== 和 equals的区别</h4>
<p>1,当使用 == 比较基本数据类型，它比较的是两个变量的值是否相等。<br>
2,当使用 == 比较引用数据类型(如对象)时,它比较的是对象的内存地址是否相等，即它们是否引用同一内存地址。<br>
3,equals是Object类中的一个方法，用于比较同一类的两个对象的内容是否相等。</p>
<h4 id="equals的比较逻辑">equals的比较逻辑</h4>
<p>equals方法首先检查两个对象是否为同一类的实例(即类是否相等)。<br>
如果不属于同一类，则对象肯定不相等。<br>
如果类相等，equals方法将逐一比较两个对象的字段或属性，以确定它们是否相等。</p>
<h4 id="适用场景">适用场景：</h4>
<p>对于基本数据类型，== 用于比较值是否相<br>
对于引用数据类型：如对象，通常使用 equals 方法进行内容比较。</p>
<h4 id="方法重写">方法重写：</h4>
<p>== 的行为固定，不可更改。<br>
equals 方法可以在自定义类中重写，以实现特定的比较逻辑。</p>
<h4 id="尾声">尾声</h4>
<p>准备开始学习java了。<br>
今天学习的第三天，每天都会发文章，我要卷起来。<br>
请小伙伴们监督我，奥利给</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/ishoulgodo/" target="_blank">流年少年</a> <br>
		        出处：<a href="https://www.cnblogs.com/ishoulgodo/">https://www.cnblogs.com/ishoulgodo/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
		    </div>
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19815084512731482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-30 19:45">2025-01-30 19:35</span>&nbsp;
<a href="https://www.cnblogs.com/ishoulgodo">何人陪我共长生</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18695297" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18695297);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18695297', targetLink: 'https://www.cnblogs.com/ishoulgodo/p/18695297', title: 'java中的HashSet与 == 和 equals的区别' })">举报</a>
</div>
        