
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/javadaydayup/p/18894332" title="发布于 2025-05-24 14:32">
    <span role="heading" aria-level="2">一个 Bean 就这样走完了它的一生之 Bean 的出生</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1878162/202505/1878162-20250524143226575-1495418308.png" alt="一个 Bean 就这样走完了它的一生之 Bean 的出生" class="desc_img">
        想了解 Spring 中 Bean 的创建流程么？本文将从 Spring 源码的角度带你一步一步查看 Spring 中的 Bean 创建时候生命周期的每个方法是如何被调用的。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="生命周期流程">生命周期流程</h2>
<p>Spring 中的一个 Bean 从被创建到被销毁，需要经历很多个阶段的生命周期，下图是一个 Bean 从创建到销毁的生命周期流程：<br>
<img src="https://img2024.cnblogs.com/blog/1878162/202505/1878162-20250524143115072-1228542287.png" alt="" loading="lazy"></p>
<p>在 Bean 的各个生命周期流程点，Spring 都提供了对应的接口或者注解，以便开发者在各个生命周期的流程点能够做一些自己的操作。</p>
<h2 id="案例解析">案例解析</h2>
<h3 id="定义-spring-上下文工具类">定义 Spring 上下文工具类</h3>
<p>Spring 中生命周期最常见的应用可能是定义一个 Spring 上下文的工具类。这个工具类也使用 <code>@Component</code> 注解修饰，表明<strong>它也是一个 Bean</strong> ，其次它实现了 <code>ApplicationContextAware</code> 接口，则说明它作为一个 Bean 被创建以及初始化的过程中需要调用 <code>setApplicationContext()</code> 方法，设置它所在的 Spring 上下文。代码如下：</p>
<pre><code class="language-java">@Component 
public class SpringContextUtils implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    /**
     * Spring会自动调用这个方法，注入ApplicationContext
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringContextUtils.applicationContext = applicationContext;
    }

    /**
     * 获取ApplicationContext
     * @return ApplicationContext
     */
    public static ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            throw new IllegalStateException("ApplicationContext is not set. Make sure SpringContextUtils is properly initialized.");
        }
        return applicationContext;
    }

    /**
     * 通过名称获取Bean
     * @param name Bean的名称
     * @return Bean实例
     */
    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    /**
     * 通过名称和类型获取Bean
     * @param name Bean的名称
     * @param requiredType Bean的类型
     * @param &lt;T&gt; Bean的类型
     * @return Bean实例
     */
    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) {
        return getApplicationContext().getBean(name, requiredType);
    }

    /**
     * 通过类型获取Bean
     * @param requiredType Bean的类型
     * @param &lt;T&gt; Bean的类型
     * @return Bean实例
     */
    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) {
        return getApplicationContext().getBean(requiredType);
    }
}
</code></pre>
<h3 id="在-bean-的依赖注入之后执行初始化操作">在 Bean 的依赖注入之后执行初始化操作</h3>
<p>比如下面的案例中，<code>MyService</code> 这个 Bean 需要在它的依赖 <code>MyRepository</code> 这个 Bean 注入完成之后，调用依赖的 <code>loadInitialData()</code> 方法加载初始数据。代码如下：</p>
<pre><code class="language-java">@Service
public class MyService {

    private MyRepository myRepository;
    
    private List&lt;String&gt; initialData;

    @Autowired
    public void setMyRepository(MyRepository myRepository) {
        this.myRepository = myRepository;
    }

    // 依赖注入完成后执行的初始化方法
    @PostConstruct
    public void init() {
        this.initialData = myRepository.loadInitialData();
    }

    public void doBusinessLogic() {
    }
}

@Service
class MyRepository {
    public List&lt;String&gt; loadInitialData() {
    }
}
</code></pre>
<p><code>@PostConstruct</code> 注解是 JSR-250 标准定义的注解，它与 Spring 框架的耦合度比较低。除此之外还可以实现 <code>InitializingBean</code> 接口，在它的 <code>afterPropertiesSet()</code> 方法中来完成初始化；通过 XML 配置 <code>init-method</code> 或者 <code>@Bean</code> 注解的 <code>initMethod</code> 属性来指定任意的方法作为初始化方法来完成初始化。</p>
<h2 id="bean-创建源码解析">Bean 创建源码解析</h2>
<p>在 Spring 源码实现中实际上分为了三个大的步骤：<strong>实例化 -&gt; 填充属性 -&gt; 初始化</strong>。填充属性可以看前面的文章<a href="https://mp.weixin.qq.com/s/WVpWDU2JXFbpl-hgsywUXQ" target="_blank" rel="noopener nofollow">Spring 中@Autowired，@Resource，@Inject 注解实现原理</a>。在上面生命周期图片中的从 <code>XXXAware</code> 的 <code>setXXXAware()</code> 方法到 <code>postProcessAfterInitialization()</code> 都属于初始化的这个步骤中。</p>
<p>在 <code>AbstractAutowireCapableBeanFactory</code> 中提供的 <code>doCreateBean()</code> 方法中提现了这三个大的步骤，其中的 <code>createBeanInstance()</code> 方法完成 Bean 的实例化；<code>populateBean()</code> 方法完成 Bean的属性填充；<code>initializeBean()</code> 方法完成 Bean 的初始化。代码如下：</p>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, 
	@Nullable Object[] args) throws BeanCreationException {
    // Instantiate the bean.  
    BeanWrapper instanceWrapper = null;  
    
    if (instanceWrapper == null) {  
       //实例化Bean
       instanceWrapper = createBeanInstance(beanName, mbd, args);  
    }  
    Object bean = instanceWrapper.getWrappedInstance();  
  
    // Eagerly cache singletons to be able to resolve circular references  
    // even when triggered by lifecycle interfaces like BeanFactoryAware.    
    boolean earlySingletonExposure = (mbd.isSingleton() 
	    &amp;&amp; this.allowCircularReferences 
	    &amp;&amp; isSingletonCurrentlyInCreation(beanName));  
    if (earlySingletonExposure) {  
       addSingletonFactory(beanName, 
	       () -&gt; getEarlyBeanReference(beanName, mbd, bean));  
    }  
  
    // Initialize the bean instance.  
    Object exposedObject = bean;  
    try {  
       //填充Bean的属性，比如处理@Autowired，@Resource，@Inject注解
       populateBean(beanName, mbd, instanceWrapper);  
       
       //初始化Bean
       exposedObject = initializeBean(beanName, exposedObject, mbd);  
    } catch {
    }
}
</code></pre>
<h3 id="initializebean方法流程">initializeBean()方法流程</h3>
<p>在 <code>initializeBean()</code> 方法中又分为：<strong>调用 invokeAwareMethods() 方法 -&gt; 调用 applyBeanPostProcessorsBeforeInitialization() 方法 -&gt; 调用 invokeInitMethods() 方法 -&gt; 调用 applyBeanPostProcessorsAfterInitialization() 方法</strong>，代码如下：</p>
<pre><code class="language-java">protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
      //调用Aware()方法
      invokeAwareMethods(beanName, bean);

      Object wrappedBean = bean;
      if (mbd == null || !mbd.isSynthetic()) {
          //调用BeanPostProcessor的postProcessBeforeInitialization()方法
          wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
      }

      try {
          //调用初始化方法
          invokeInitMethods(beanName, wrappedBean, mbd);
      }
      catch (Throwable ex) {
          throw new BeanCreationException(
                  (mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);
      }
      if (mbd == null || !mbd.isSynthetic()) {
          //调用BeanPostProcessor的postProcessAfterInitialization()方法
          wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
      }

      return wrappedBean;
}
</code></pre>
<h3 id="invokeawaremethods方法流程">invokeAwareMethods()方法流程</h3>
<p>需要注意的是 <code>invokeAwareMethods()</code> 方法中仅仅只调用实现了 <code>BeanNameAware</code>，<code>BeanClassLoaderAware</code>，<code>BeanFactoryAware</code> 接口的方法。而常见的 <code>ApplicationContextAware</code> 接口的 <code>setApplicationContext()</code> 方法则是在 <code>ApplicationContextAwareProcessor</code> 的 <code>postProcessBeforeInitialization()</code> 方法中调用的。代码如下：</p>
<pre><code class="language-java">public abstract class AbstractAutowireCapableBeanFactory {
    private void invokeAwareMethods(String beanName, Object bean) {
        if (bean instanceof Aware) {
            if (bean instanceof BeanNameAware beanNameAware) {
                //调用setBeanName()方法
                beanNameAware.setBeanName(beanName);
            }
            if (bean instanceof BeanClassLoaderAware beanClassLoaderAware) {
                ClassLoader bcl = getBeanClassLoader();
                if (bcl != null) {
                    //调用setBeanClassLoader()方法
                    beanClassLoaderAware.setBeanClassLoader(bcl);
                }
            }
            if (bean instanceof BeanFactoryAware beanFactoryAware) {
                //调用setBeanFactory()方法
                beanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.this);
            }
        }
    }
}

class ApplicationContextAwareProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof Aware) {
            this.invokeAwareInterfaces(bean);
        }

        return bean;
    }

    private void invokeAwareInterfaces(Object bean) {
        if (bean instanceof EnvironmentAware environmentAware) {
            environmentAware.setEnvironment(this.applicationContext.getEnvironment());
        }

        if (bean instanceof EmbeddedValueResolverAware embeddedValueResolverAware) {
            embeddedValueResolverAware.setEmbeddedValueResolver(this.embeddedValueResolver);
        }

        if (bean instanceof ResourceLoaderAware resourceLoaderAware) {
            resourceLoaderAware.setResourceLoader(this.applicationContext);
        }

        if (bean instanceof ApplicationEventPublisherAware applicationEventPublisherAware) {
            applicationEventPublisherAware.setApplicationEventPublisher(this.applicationContext);
        }

        if (bean instanceof MessageSourceAware messageSourceAware) {
            messageSourceAware.setMessageSource(this.applicationContext);
        }

        if (bean instanceof ApplicationStartupAware applicationStartupAware) {
            applicationStartupAware.setApplicationStartup(this.applicationContext.getApplicationStartup());
        }
        
        if (bean instanceof ApplicationContextAware applicationContextAware) {
            //这里调用的setApplicationContext()方法
            applicationContextAware.setApplicationContext(this.applicationContext);
        }

    }
}
</code></pre>
<h3 id="applybeanpostprocessorsbeforeinitialization-方法流程">applyBeanPostProcessorsBeforeInitialization() 方法流程</h3>
<p>在该方法中主要就是查找所有实现了 <code>BeanPostProcessor</code> 接口的对象，然后循环调用其 <code>postProcessBeforeInitialization()</code> 方法。代码如下：</p>
<pre><code class="language-java">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
    throws BeansException {
    Object result = existingBean;
    for (BeanPostProcessor processor : getBeanPostProcessors()) {
        Object current = processor.postProcessBeforeInitialization(result, beanName);
        if (current == null) {
            return result;
        }
        result = current;
    }
    return result;
}
</code></pre>
<p>在 Spring 中提供了 <code>CommonAnnotationBeanPostProcessor</code>（<code>@Resource</code> 注解也是它处理的） 实现了 <code>BeanPostProcessor</code> 接口，在它的构造函数里面初始化了要处理 <code>@PostConstruct</code> 注解。代码如下：</p>
<pre><code class="language-java">public CommonAnnotationBeanPostProcessor() {
		setOrder(Ordered.LOWEST_PRECEDENCE - 3);

		// Jakarta EE 9 set of annotations in jakarta.annotation package
		addInitAnnotationType(loadAnnotationType("jakarta.annotation.PostConstruct"));
		addDestroyAnnotationType(loadAnnotationType("jakarta.annotation.PreDestroy"));

		// Tolerate legacy JSR-250 annotations in javax.annotation package
		addInitAnnotationType(loadAnnotationType("javax.annotation.PostConstruct"));
		addDestroyAnnotationType(loadAnnotationType("javax.annotation.PreDestroy"));
	}
</code></pre>
<p>然后在它的子类 <code>InitDestroyAnnotationBeanPostProcessor</code> 的 <code>postProcessBeforeInitialization()</code> 实现了查找 <code>@PostConstruct</code> 注解修饰的方法，然后调用的逻辑。代码如下：</p>
<pre><code class="language-java">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
    try {
        metadata.invokeInitMethods(bean, beanName);
    }
    catch (InvocationTargetException ex) {
        throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException());
    }
    catch (Throwable ex) {
        throw new BeanCreationException(beanName, "Failed to invoke init method", ex);
    }
    return bean;
}
</code></pre>
<h3 id="invokeinitmethods-方法流程">invokeInitMethods() 方法流程</h3>
<p>在该方法中会先判断 Bean 是否实现了 <code>InitializingBean</code> 接口，如果实现了则调用其 <code>afterPropertiesSet()</code> 方法，然后查看 Bean 定义中是否有自定义的初始化方法，如果有的话，则调用自定义的初始化方法。代码如下：</p>
<pre><code class="language-java">protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)
    throws Throwable {
    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean &amp;&amp; (mbd == null || !mbd.hasAnyExternallyManagedInitMethod("afterPropertiesSet"))) {
        if (logger.isTraceEnabled()) {
            logger.trace("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
        }
        //调用afterPropertiesSet()方法
        ((InitializingBean) bean).afterPropertiesSet();
    }

    if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {
        String[] initMethodNames = mbd.getInitMethodNames();
        if (initMethodNames != null) {
            for (String initMethodName : initMethodNames) {
                if (StringUtils.hasLength(initMethodName) &amp;&amp;
                        !(isInitializingBean &amp;&amp; "afterPropertiesSet".equals(initMethodName)) &amp;&amp;
                        !mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {
                    //调用自定义初始化方法
                    invokeCustomInitMethod(beanName, bean, mbd, initMethodName);
                }
            }
        }
    }
}


protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)
    throws Throwable {
    Class&lt;?&gt; beanClass = bean.getClass();
    MethodDescriptor descriptor = MethodDescriptor.create(beanName, beanClass, initMethodName);
    String methodName = descriptor.methodName();

    Method initMethod = (mbd.isNonPublicAccessAllowed() ?
            BeanUtils.findMethod(descriptor.declaringClass(), methodName) :
            ClassUtils.getMethodIfAvailable(beanClass, methodName));
    //省略代码
    
    Method methodToInvoke = ClassUtils.getPubliclyAccessibleMethodIfPossible(initMethod, beanClass);

    try {
        ReflectionUtils.makeAccessible(methodToInvoke);
        //这里通过反射的方式调用初始化方法
        methodToInvoke.invoke(bean);
    }
    catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    }
}
</code></pre>
<h3 id="applybeanpostprocessorsbeforeinitialization-方法流程-1">applyBeanPostProcessorsBeforeInitialization() 方法流程</h3>
<p>在该方法中主要就是查找所有实现了 <code>BeanPostProcessor</code> 接口的对象，然后循环调用其 <code>postProcessAfterInitialization()</code> 方法。代码如下：</p>
<pre><code class="language-java">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
    try {
        metadata.invokeInitMethods(bean, beanName);
    }
    catch (InvocationTargetException ex) {
        throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException());
    }
    catch (Throwable ex) {
        throw new BeanCreationException(beanName, "Failed to invoke init method", ex);
    }
    return bean;
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    欢迎大家关注我的公众号【javadaydayup】
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5712985156215278" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-24 14:33">2025-05-24 14:32</span>&nbsp;
<a href="https://www.cnblogs.com/javadaydayup">javadaydayup</a>&nbsp;
阅读(<span id="post_view_count">61</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18894332);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18894332', targetLink: 'https://www.cnblogs.com/javadaydayup/p/18894332', title: '一个 Bean 就这样走完了它的一生之 Bean 的出生' })">举报</a>
</div>
        