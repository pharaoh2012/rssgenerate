
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18674207" title="发布于 2025-01-16 10:32">
    <span role="heading" aria-level="2">[车联网/以太网] SOME/IP 协议</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概述-someip-协议">概述: SOME/IP 协议</h1>
<ul>
<li><strong>车载以太网协议栈</strong>总共可划分为5层:</li>
</ul>
<blockquote>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>其中本文所要描述的<code>SOME/IP</code>就是一种<strong>应用层协议</strong>。</p>
</blockquote>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102241466-2003995365.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102258711-554283738.png" alt="" loading="lazy"></p>
<ul>
<li><code>SOME/IP</code>协议内容按照<code>AUTOSAR</code>中的描述，我们可以更进一步的拆分为3类<strong>子协议</strong>：</li>
</ul>
<blockquote>
<ul>
<li>应用层的<code>SOME/IP</code><strong>标准协议</strong></li>
<li><code>SOME/IP-SD</code>协议</li>
<li>TP层的<code>SOME/IP-TP</code>协议</li>
</ul>
</blockquote>
<h2 id="产生背景与动机">产生背景与动机</h2>
<ul>
<li>2011年<strong>宝马</strong>公司开发设计了一套<strong>中间件</strong>，该中间件能够实现<strong>以服务为导向的通信方式</strong></li>
</ul>
<blockquote>
<p>该中间件区别于传统以<strong>信号</strong>为导向的通信方式，不仅能够大大减少<strong>网络负载</strong>以提高<strong>通信双方的效率</strong><br>
同时，引入<strong>以太网通信</strong>也能够大大满足未来车辆不断增长的通信需求。</p>
</blockquote>
<ul>
<li>
<p><strong>面向信号的数据传输模式</strong>不管网络需不需要始终会不断循环发送，而<strong>面向服务的通信方式</strong>则不同，只有当网络中至少存在一个接收方需要这些数据时，发送方才会发送数据，这是一种面向服务通信方式的显著优点。</p>
</li>
<li>
<p><strong>宝马</strong>将该<strong>面向服务的通信方式</strong>叫做<code>SOME/IP</code>(全称为：<code>Scalable service-Oriented MiddlewarE over IP</code>， 基于IP协议的可扩展的、面向服务的中间件)。</p>
</li>
</ul>
<blockquote>
<p>正如其名，可见该协议跟以太网密切相关。<br>
没错！<code>SOME/IP</code>就是运行在<strong>车载以太网协议栈</strong>基础之上的<strong>中间件</strong>，或者也可以称为<strong>应用层软件</strong>。</p>
</blockquote>
<ul>
<li><code>SOME/IP</code>正由于其知名度逐渐被<code>AUTOSAR</code>接纳并计划纳入其正式标准，并且在2014年集成进<code>AUTOSAR 4.X</code>中。其几个关键发展节点如下：</li>
</ul>
<blockquote>
<ul>
<li>AUTOSAR 4.0 - 完成宝马SOME/IP消息的初步集成；</li>
<li>AUTOSAR 4.1 - 支持SOME/IP-SD及其发布/订阅功能；</li>
<li>AUTOSAR 4.2 - 添加transformer用于序列化以及其他相关优化；</li>
<li>AUTOSAR 4.3 - 修复一些transformer bug同时添加针对大量UDP数据包的SOME/IP-TP协议以及其他SOME/IP-SD的优化工作；</li>
</ul>
</blockquote>
<h2 id="someip-协议的特点协议的定位">SOME/IP 协议的特点、协议的定位</h2>
<table>
<thead>
<tr>
<th>特点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scalable(可扩展)</td>
<td>该协议设计的初衷之一就是为了实现不同硬件平台、不同操作系统或嵌入式固件以及不同应用软件的异构设备之间的可扩展性和互操作性。</td>
</tr>
<tr>
<td>service-Oriented(面向服务)</td>
<td>表明它是一种面向服务的基本协议。因此仅当客户端请求或服务器通知特定订阅者时，才在客户端-服务器配置中交换数据 ，这就确保了永远不会浪费带宽，并且仅在需要的时间和地点进行数据通信/交换。</td>
</tr>
<tr>
<td>MiddlewarE</td>
<td>它也是一种中间件。即其位于应用层，有自己的通用协议层来处理更具体的操作及应用；</td>
</tr>
<tr>
<td>Serialization(序列化)</td>
<td>在ECU内部进行序列化及反序列化以实现信息的高效传输</td>
</tr>
<tr>
<td>Remote Procedure Calls(远程调用)</td>
<td>该协议可以传递消息(作为字段发送)以及方法的远程调用(实现过程/函数调用)</td>
</tr>
<tr>
<td>Service Discovery(服务发现)</td>
<td>SOME/IP协议的数据通信发生在客户端-服务器模型中,同时服务器提供客户端可以订阅的许多不同服务。该协议允许客户端动态查找服务、订阅服务并配置对服务的访问。</td>
</tr>
<tr>
<td>Publish/Subscribe(发布与订阅)</td>
<td>SOME/IP中的数据通信通过发布/订阅进行。客户端可以订阅服务器提供的服务,服务器可以向活跃的订阅者发布通知。</td>
</tr>
<tr>
<td>Segementation of UDP message</td>
<td>每当服务器必须向活动订阅者发送通知时，他们是通过UDP协议发送的。SOME/IP能够在不需要任何分段的情况下传送大型UDP消息。</td>
</tr>
<tr>
<td>over IP(基于以太网)</td>
<td>它也是一个<strong>基于以太网的协议</strong>。<br>它使用类似的硬件接口，确保高达 <code>100Mbps</code> 的带宽。<br>同时数据通过中间件（即应用层）通过网络电缆使用 <code>TCP/IP</code> 或 <code>UDP</code> 协议进行通信。<br>当客户端需要来自服务器的数据时，它可由客户端使用 TCP 协议进行请求。<br>如果服务器必须将数据传送给所有活动的订阅者，则可通过 UDP 协议传输。<br>UDP 协议上的数据通信可以是单播、多播或广播。 <br>如下图所示，就十分清晰地展示了SOME/IP在车载以太网协议栈中的位置以及与其他模块的关系</td>
</tr>
</tbody>
</table>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116100837923-15339887.png" alt="" loading="lazy"></p>
<blockquote>
<p>图: SOME/IP 与车载以太网协议栈关系</p>
</blockquote>
<ul>
<li>那么在AUTOSAR协议栈中，SOME/IP协议又处于一个什么样的位置呢？</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116100953698-136966052.png" alt="" loading="lazy"></p>
<blockquote>
<p>如上图可知，<strong>SOME/IP协议涉及到与RTE，COM，PDUR以及SOAd这些AUTOSAR标准模块的交互，而用于服务发现的SOME/IP-SD则涉及到BswM，SD以及SoAd模块的交互。</strong><br>
SOME/IP协议与各个模块的交互关系会在后续文章讲到，提及于此让大家对SOME/IP协议与AUTOSAR协议栈的关联有个整体概念，此文中不做过多展开。<br>
SOME/IP 最初是作为另一种 RPC 机制开发的，以确保与 AUTOSAR 设备的兼容性并提供汽车用例所需的最大功能，同时它也是专为ECU间客户端-服务器序列化而设计的网络层协议。<br>
目前，该协议可以在多种不同的操作系统上实现，包括 AUTOSAR、OSEK 和 GENIVI。它也可以在不运行操作系统的嵌入式固件上实现。<br>
摄像头、主机、远程信息处理设备、AUTOSAR 设备，甚至信息娱乐系统等大型设备，都可以使用 SOME/IP 协议有效地交换 ECU 间消息。<br>
自 <code>Wireshark 3.2 SOME/IP</code> 发布以来，<code>SOME/IP</code> 支持就已公开，可以在 <code>Wireshark</code> 上解析SOME/IP数据。</p>
</blockquote>
<h2 id="someip与soa架构的关系">SOME/IP与SOA架构的关系</h2>
<h3 id="soa">SOA</h3>
<ul>
<li>
<p><code>SOA</code>，简而言之就是一种<strong>面向服务的架构</strong>(<code>Service-Oriented Architecture</code>), 当然也是一种软件设计的重要方式，IT研究与顾问咨询公司 <code>Gartner</code> 在 <code>1996</code> 年提出的，其本身并不是新鲜概念，而且已经在IT互联网领域风靡了20余年。</p>
</li>
<li>
<p>按照<code>W3C</code>对它的定义 : “SOA是一种应用程序架构，在这种架构中，所有功能都定义为独立的服务，这些服务带有定义明确的可调用接口，能够以定义好的顺序调用这些服务来形成业务流程。</p>
</li>
<li>
<p><strong>服务</strong>： 服务是一种比构件粒度更大的信息集合，实际是包含实现了多个关联业务需求的逻辑组合，并且允许每个服务使用特定的平台，架构或技术方案；</p>
</li>
<li>
<p><strong>可调用接口</strong>： 面向服务的接口不同于构件的接口，他的实现与特定语言无关，与特定的平台也无关，可十分方便的实现不同异构平台的交互；</p>
</li>
<li>
<p>联系与区别：</p>
</li>
</ul>
<blockquote>
<p>首先，需要明确的是<code>SOME/IP</code>不是SOA，<code>SOA</code>也不是SOME/IP；<br>
由于SOME/IP本身也是一种<strong>面向服务的协议</strong>，所以一般认为<code>SOME/IP</code>只不过是一种<strong>实现SOA可行的协议选择</strong>；<br>
一般而言，基于消息的通信与RPC(Remote Procedure Call 远程过程调用)通信都可以实现SOA，而SOME/IP就是一种基于RPC框架的协议；<br>
可以通过SOME/IP用来实现SOA，但SOA的实现却不一定非得用SOME/IP;</p>
</blockquote>
<h2 id="someip-通信机制">SOME/IP 通信机制</h2>
<h3 id="服务发现service-discovery">服务发现(Service Discovery)</h3>
<ul>
<li>SOME/IP SD 用于提供服务、发现服务、订阅事件组。</li>
<li>SOME/IP SD 只用 UDP 协议的 30490 端口通信。</li>
<li>SOME/IP SD 提供了两种动态发现服务的机制。</li>
</ul>
<blockquote>
<ul>
<li>一种是 Offer Service（Type = 0x01），由服务端广播其提供的服务；</li>
<li>一种是 Find Service（Type = 0x00），由客户端请求可用的服务。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>服务发现的通信机制</strong>是通过<code>SOME/IP-SD</code>协议实现的，主要是为了实现在<strong>车载以太网</strong>中<strong>告知客户端</strong>当前服务实例的可用性及访问方式，可通过<code>Find Service</code> 和<code>Offer Service</code>来实现。</p>
</li>
<li>
<p>SOME/IP 服务发现流程，可以分为3大基本步骤：</p>
</li>
</ul>
<blockquote>
<ul>
<li>Client 通过发送Find Service的报文去寻找车载网络中可用的服务实例；</li>
<li>Server 接收到Client的Find Server后通过UDP发送Offer Service响应；</li>
<li>Client 通过发送Subcribe Event Group去订阅相关Event；</li>
<li>Server 检查是否满足Client是否满足订阅条件，如果满足回复ACK，如果不满足，则回复NACK；</li>
<li>Client 成功订阅相关事件后，Server会按照事件本身属性来实现对已订阅该事件的Client的发布；</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095349070-1382464213.png" alt="" loading="lazy"></p>
<h3 id="远程进程调用rpc">远程进程调用(RPC)</h3>
<ul>
<li>远程进程调用主要可分为四种通信模式：</li>
</ul>
<h4 id="requestresponse通信模式">Request/Response通信模式</h4>
<p>可归纳为·Method·中的一种；其基本通信模型如下图所示：</p>
<ul>
<li>Request-Response模型作为一种最为常见的通信方式，其主要任务就是客户端发送请求信息，服务端接收到请求，进行相关处理之后进行相应的响应。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095459764-749116790.png" alt="" loading="lazy"></p>
<h4 id="fireforget通信模式">Fire&amp;Forget通信模式</h4>
<p>可归纳为Method中的一种；</p>
<p>该通信模型的主要任务就是客户端向服务端发送请求，服务端无需进行任何响应，有点类似诊断服务中的抑制正响应。</p>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095531078-1695501686.png" alt="" loading="lazy"></p>
<h4 id="notification-event通信模式">Notification Event通信模式</h4>
<ul>
<li>该通信模式主要描述了发布 /订阅消息内容，主要任务就是为了实现客户端向服务端订阅相关的事件组，当服务端的事件组发生或者值发生变化时，就需要向已订阅该事件组的客户端发布更新的内容。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095551791-1744185053.png" alt="" loading="lazy"></p>
<h4 id="远程进程控制field">远程进程控制(Field)</h4>
<ul>
<li>访问进程通信机制主要是为了实现针对对应用程序的数据获取与更改，主要任务就是实现客户端通过Getter获取Server的值，通过Setter设置Server的值。</li>
</ul>
<p>Field就可理解为一个Service的基本属性，可包含Getter，Setter，Notifier三种方式。其中Getter就是读取Field中某个值的方法，Setter就是一种改变Field值的方法，而Notifier则是一种当Field中的值发生变化的触发事件，发生变化时就通知Client。</p>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095654333-1935982490.png" alt="" loading="lazy"></p>
<h2 id="someip-错误处理机制">SOME/IP 错误处理机制</h2>
<ul>
<li><code>AUTOSAR</code>为了更为高效的定位到通讯过程中的问题所在，制定了一套检查<code>SOME/IP</code>协议格式内容的错误处理机制。比如版本信息检查，服务ID等，其他故障信息可以在Payload中进行详细定义。目前SOME/IP支持以下两种错误处理机制，这两种uowu处理机制可以根据配置进行选择。</li>
</ul>
<blockquote>
<ul>
<li>消息类型0x80，Response信息，即可以通过Response Message中的Return Code来定位到问题所在；</li>
<li>消息类型0x81，显式的错误信息；</li>
</ul>
</blockquote>
<ul>
<li>主要是校验协议首部结构，对<code>Message Type</code>和<code>Return code</code>进行赋值，通知对端。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116095823238-1423085733.png" alt="" loading="lazy"></p>
<h2 id="核心概念">核心概念</h2>
<h3 id="服务-service">服务 Service</h3>
<ul>
<li>服务是 SOME/IP 的核心，服务端提供服务，客户端使用服务。服务由零个或多个方法、事件以及字段组成。</li>
</ul>
<h3 id="方法-method">方法 Method</h3>
<ul>
<li>客户端调用服务端的函数/程序/服务/方法。方法有两种形式：</li>
</ul>
<blockquote>
<ul>
<li>Request &amp; Response：常规的客户端请求，服务端响应</li>
<li>Fire &amp; Forget（Request_NoReturn）：单向客服端请求，服务端不响应</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102446974-1871902396.png" alt="" loading="lazy"></p>
<h3 id="事件-event">事件 Event</h3>
<ul>
<li>客户端向服务端订阅事件组 EventGroup，当事件组有更新时，服务端发布消息，通知所有订阅的客户端</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102549381-1315042658.png" alt="" loading="lazy"></p>
<h3 id="字段-field">字段 Field</h3>
<ul>
<li>方法和事件的组合，提供 Getter/Setter 两个方法用于获取/设置字段值，以及一个 Notification 事件，当字段值变化时，服务端发布消息，通知订阅的客户端</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102605549-334711495.png" alt="" loading="lazy"></p>
<h3 id="entry">Entry</h3>
<ul>
<li>
<p>用于提供服务、发现服务、订阅事件组。</p>
</li>
<li>
<p><code>Entry</code> 有 Service Entry 和 EventGroup Entry 两种：</p>
</li>
<li>
<p>Service Entry</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102727227-710147228.png" alt="" loading="lazy"></p>
<ul>
<li>EventGroup Entry</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102737934-1634018220.png" alt="" loading="lazy"></p>
<blockquote>
<p>SOME/IP SD 提供了两种动态发现服务的机制。一种是 Offer Service（Type = 0x01），由服务端广播其提供的服务；另一种是 Find Service（Type = 0x00），由客户端请求可用的服务</p>
</blockquote>
<h3 id="option">Option</h3>
<ul>
<li>Option 字段用来传输 Entry 的附加信息，包括对于服务实例的 IP 地址、传输协议、端口号等信息。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102821237-281417478.png" alt="" loading="lazy"></p>
<blockquote>
<p>例如 Type = 0x04 时</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116102838025-925623790.png" alt="" loading="lazy"></p>
<h1 id="someip-标准协议">SOME/IP 标准协议</h1>
<h2 id="someip-协议格式">SOME/IP 协议格式</h2>
<pre><code class="language-c">// SomeIP 协议格式
SomeIP {
    ushort svcID; //Service ID; 标识出一个服务
    ushort mthdID;//Method ID; 标识出一个方法
    uint   length;//Length (此字节之后的长度)
    ushort cliID; //Client ID; 客户端ID,区分不同客户端
    ushort ssID;  //Session ID; 区分统一客户端的多次调用
    uchar  ver{0x01}; //SOME/IP Version; 协议版本号;固定为0x01
    uchar ifcVer; //interfaceVer; 服务接口版本
    uchar  type;  // | Message Type [.... xxxx]  报文类型,目前共5种
    bool   isAck; // | Message Type [.x.. ....]  Message Type Ack Flag
    bool   isTP;  // | Message Type [..x. ....]  Message Type TP Flag
    uchar  retCode;//返回码Return Code (0x00 Ok) ;
    char[] payload;//数据段
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116091124453-936576733.png" alt="" loading="lazy"></p>
<ul>
<li>如果应用了 <code>E2E</code> 通信保护，则 <code>E2E</code> 报头将放置在 <code>Return Code</code> 之后，具体取决于为 E2E 报头选择的偏移值。</li>
</ul>
<blockquote>
<p>默认偏移值为 64 位，这将 E2E 报头恰好放置在 Return Code 和 Payload 之间。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116093417705-1091687771.png" alt="" loading="lazy"></p>
<h2 id="someip-message-header">SOME/IP Message Header</h2>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Message ID</td>
<td>前2个字节为Service ID，后2个字节为Method ID（每个服务仅定义一个唯一的Service ID，Method ID的最高位为0即为方法（包括Method Filed.Getter及Filed.Setter），最高位为1就为事件（包括Event和Filed.Notify））</td>
</tr>
<tr>
<td>Length</td>
<td>标识从Request ID开始至SOME/IP报文结束的长度</td>
</tr>
<tr>
<td>Request ID</td>
<td>前2个字节为Client ID，用来识别一个客户端；后2个字节为Session ID，用来识别同一个客户端的多次请求。（其中Client ID可通过配置前缀或者固定值来实现唯一性，可不进行Session处理，如果需要，则Session ID需根据各自的用例从0x0001递增）</td>
</tr>
<tr>
<td>Protocol Version</td>
<td>协议版本号，目前固定为1</td>
</tr>
<tr>
<td>Interface Version</td>
<td>用来识别服务接口的主版本号，由用户定义</td>
</tr>
<tr>
<td>Message Type</td>
<td>用来识别不同的消息类型，Message Type（8Bits）的Bit5标识TP-Flag，当TP-Flag=1时，标识一个TP类型的Message Type (当SOME/IP下层通信协议为UDP，且SOME/IP传输大数据（&gt;1452Bytes）时，将使用SomeIpTp进行分段）</td>
</tr>
<tr>
<td>Return Code</td>
<td>用来指示Message是否被成功处理了，或针对请求中的错误内容进行反馈</td>
</tr>
<tr>
<td>E2E Header</td>
<td>可选，是否使能，并且可变长度（默认长度是8Bytes），可选使用一种E2E profile（常用E2E Profile4）</td>
</tr>
<tr>
<td>Payload</td>
<td>有效载荷，序列化和反序列化定义了 PDU 中所有数据结构的确切位置，并且考虑了内存对齐</td>
</tr>
</tbody>
</table>
<h2 id="message-type">Message Type</h2>
<ul>
<li>用来识别不同的消息类型，目前存在的类型如下所示，其中<code>TP</code>表示<strong>分包的报文</strong>,按照<code>AUTOSAR</code>标准(<code>R21-11</code>)定义如下：</li>
</ul>
<blockquote>
<p>其中 <code>Message Type</code> 取值及含义如下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Message Type</th>
<th>报文类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>REQUEST</td>
<td>请求并期待响应(A request expecting a response)。请求，需要回复</td>
</tr>
<tr>
<td>0x01</td>
<td>REQUEST_NO_RETURN</td>
<td>请求但不期待响应(A fire&amp;forget request)。请求，不需要回复</td>
</tr>
<tr>
<td>0x02</td>
<td>NOTIFICATION</td>
<td>通知/事件回调的请求，不期待有响应(A request for a notification expecting no response)。Notifier/Event，不需要回复</td>
</tr>
<tr>
<td>0x40</td>
<td>REQUEST_ACK</td>
<td>Acknowledgment for REQUEST (optional)<br>REQUEST的ACK确认</td>
</tr>
<tr>
<td>0x41</td>
<td>REQUEST_NO_RETURN_ACK</td>
<td>Acknowledgment for REQUEST_NO_RETURN (informational)<br>REQUEST_NO_RETURN的ACK确认</td>
</tr>
<tr>
<td>0x42</td>
<td>NOTIFICATION_ACK</td>
<td>Acknowledgment for NOTIFICATION (informational)<br>NOTIFICATION的ACK确认</td>
</tr>
<tr>
<td>0x80</td>
<td>RESPONSE</td>
<td>The response message<br>响应</td>
</tr>
<tr>
<td>0x81</td>
<td>ERROR</td>
<td>The response containing an error<br>响应中包含的错误</td>
</tr>
<tr>
<td>0x20</td>
<td>TP_REQUEST</td>
<td>TP segment of a Request Message for methods<br>TP请求并期待响应</td>
</tr>
<tr>
<td>0x21</td>
<td>TP_REQUEST_NO_RETURN</td>
<td>TP segment of a Request Message for Fire &amp; Forget methods<br>TP请求但不期待响应</td>
</tr>
<tr>
<td>0x22</td>
<td>TP_NOTIFICATION</td>
<td>TP segment of an Event (Notification) Message<br>TP通知/事件回调的请求，不期待有响应</td>
</tr>
<tr>
<td>0xA0</td>
<td>TP_RESPONSE</td>
<td>TP segment of a Response Message for methods<br>TP响应</td>
</tr>
<tr>
<td>0xA1</td>
<td>TP_ERROR</td>
<td>TP segment of an Error Message for methods<br>TP响应中包含的错误</td>
</tr>
</tbody>
</table>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116091327264-1956219049.png" alt="" loading="lazy"></p>
<h2 id="return-code">Return Code</h2>
<ul>
<li>用来指示Message是否被成功处理了，或针对请求中的错误内容进行反馈，如下为<code>AUTOSAR</code>(R21-11)中定义的<code>Return Code</code>类型：</li>
</ul>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>E_OK</td>
<td>没有错误发生</td>
</tr>
<tr>
<td>0x01</td>
<td>E_NOT_OK</td>
<td>发生了未定义的错误</td>
</tr>
<tr>
<td>0x02</td>
<td>SOMEIPXF_E_UNKNOWN_SERVICE</td>
<td>未知的服务ID</td>
</tr>
<tr>
<td>0x03</td>
<td>SOMEIPXF_E_UNKNOWN_METHOD</td>
<td>未知的Method ID</td>
</tr>
<tr>
<td>0x04</td>
<td>SOMEIPXF_E_NOT_READY</td>
<td>应用程序未就绪</td>
</tr>
<tr>
<td>0x05</td>
<td>SOMEIPXF_E_NOT_REACHABLE</td>
<td>运行该服务的系统不可用</td>
</tr>
<tr>
<td>0x06</td>
<td>SOMEIPXF_E_TIMEOUT</td>
<td>发生超时</td>
</tr>
<tr>
<td>0x07</td>
<td>SOMEIPXF_E_WRONG_PROTOCOL_VERSION</td>
<td>SOME/IP协议版本不支持</td>
</tr>
<tr>
<td>0x08</td>
<td>SOMEIPXF_E_WRONG_INTERFACE_VERSION</td>
<td>接口版本不匹配</td>
</tr>
<tr>
<td>0x09</td>
<td>SOMEIPXF_E_MALFORMED_MESSAGE</td>
<td>反序列化错误</td>
</tr>
<tr>
<td>0x0A</td>
<td>SOMEIPXF_E_WRONG_MESSAGE_TYPE</td>
<td>接收到不符合预期的消息类型</td>
</tr>
<tr>
<td>0x0B</td>
<td>E_E2E_REPEATED</td>
<td>E2E重复错误</td>
</tr>
<tr>
<td>0x0C</td>
<td>E_E2E_WRONG_SEQUENCE</td>
<td>E2E错误的时序</td>
</tr>
<tr>
<td>0x0D</td>
<td>E_E2E</td>
<td>没有进一步的E2E错误</td>
</tr>
<tr>
<td>0x0E</td>
<td>E_E2E_NOT_AVAILABLE</td>
<td>E2E不可用</td>
</tr>
<tr>
<td>0x0F</td>
<td>E_E2E_NO_NEW_DATA</td>
<td>没有E2E计算的新数据</td>
</tr>
<tr>
<td>0x10-0x1F</td>
<td>RESERVED</td>
<td>预留给到SOME/IP一般性错误</td>
</tr>
<tr>
<td>0x20-0x5E</td>
<td>RESERVED</td>
<td>预留给到服务及方法的特定错误</td>
</tr>
</tbody>
</table>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116091337973-374571663.png" alt="" loading="lazy"></p>
<h2 id="payload的序列化与反序列化">Payload的序列化与反序列化</h2>
<ul>
<li><code>SOME/IP</code>报文收发的过程中，上层应用所定义的<code>Method</code>、<code>Event</code>、<code>Field</code>参数都是面向用户的<code>struct</code>，<code>string</code>等，<strong>序列化</strong>就是将这些输出参数转换为<strong>字节流</strong>的过程；而<strong>反序列化</strong>的过程正好相反，就是将<strong>字节流</strong>反向解析成<code>struct</code>、<code>string</code>等具体的参数。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116094842671-2138549507.png" alt="" loading="lazy"></p>
<ul>
<li>大小端：</li>
</ul>
<blockquote>
<p>SOME/IP报文的payload(负载)大小端(字节序)指的是数据在内存中的存储和传输顺序。在计算机系统中,数据的存储和传输顺序主要有两种标准: <strong>大端字节序</strong>(Big-Endian)和<strong>小端字节序</strong>(Little-Endian)。</p>
</blockquote>
<ul>
<li>
<p>大端字节序(Big-Endian):是指数据的高位字节存放在低地址处,而低位字节存放在高地址处。也就是说,从内存的起始位置开始,第一个字节是最高位字节。</p>
</li>
<li>
<p>小端字节序(Little-Endian):是指数据的低位字节存放在低地址处,而高位字节存放在高地址处。在这个模式下,内存起始位置存放的是最低位字节。</p>
</li>
</ul>
<blockquote>
<p>SOME/IP报文的payload部分可以采用上述两种字节序中的任何一种,这取决于数据交换双方的协议约定或者通信端点的实现。在网格协议中,端字节序通常由协议规范明确指出。开发者在处理SOME/IPP报文时,必须确保发送方和接收方在端字节序上保持一致,以避免数据解析错误。</p>
</blockquote>
<h1 id="someip-sd-协议--服务发现">SOME/IP-SD 协议 : 服务发现</h1>
<h2 id="someip-sd-协议格式">SOME/IP-SD 协议格式</h2>
<pre><code class="language-c">SomeIPSD {
    ushort svcID{0xFFFF}; //Service ID; 固定值 0xFFFF
    ushort mthdID{0x8100};//Method ID;  固定值 0x8100
    uint   length;//Length (此字节之后的长度)
    ushort cliID; //Client ID; 客户端ID,区分不同客户端
    ushort ssID;  //Session ID; 区分统一客户端的多次调用
    uchar  ver{0x01}; //SOME/IP Version; 协议版本号;固定为0x01
    uchar  ifcVer{0x01}; //interfaceVer; 服务接口版本;固定为0x01
    uchar  type{0x02}; // | Message Type [.... xxxx]  报文类型;固定为0x02
    bool   isAck;      // | Message Type [.x.. ....]  Message Type Ack Flag
    bool   isTP;       // | Message Type [..x. ....]  Message Type TP Flag
    uchar  retCode{0x00};//返回码Return Code;固定为0x00
    //uchar  flags; //重新启动标志+单播标志+显示初始数据控制标志
    bool   flagReboot;  // | [x... ....] Reboot Flag ; 服务重新启动后，所有消息的Reboot Flag须置为1，直到Session ID重新从1开始计数，之后的Reboot Flag须置为0。
    bool   flagUnicat;  // | [.x.. ....] Unicast Flag
    bool   flagExplicit;// | [..x. ....] Explicit Inital Data Requested Flag
    uchar  reserved[3]{0x00};//保留
    uint   entrySize;//Length of Entries Array
    Entry[entrySize]  entris;// entrySize 个 Entry
    uint   optionSize;//Length of Options Array
    Option[optionSize] options;// optionSize 个 Option
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250116091816888-223405607.png" alt="" loading="lazy"></p>
<h2 id="entrytype">EntryType</h2>
<pre><code class="language-c">// Entry 有服务和 EventGroup 两种：
// 有的类型具有相同的值，这时需要通过 Entry 中的 TTL 字段来区分到底是 Start 还是 Stop，是ACK 还是 NACK。
enum EntryType : uchar {
    FindService = 0x00,
    OfferService = 0x01,
    StopOfferService = 0x01,
    SubscribeEventgroup = 0x06,
    StopSubscribeEventgroup = 0x06,
    SubscribeEventgroupAck = 0x07,
    SubscribeEventgroupNAck = 0x07
}
</code></pre>
<h2 id="entry-1">Entry</h2>
<pre><code class="language-c">Entry {
    EntryType type; // enum EntryType
    uchar     opt1stInd; //Option1排在Array里第几个
    uchar     opt2stInd; //Option2排在Array里第几个
    uchar     opt1st; //Option1的数目
    uchar     opt2st; //Option2的数目
    ushort    svcID;  // service ID
    ushort    instID; // instance ID ; 0xFFFF表示全部实例
    uchar     majorVer;
    uchar[3]  ttl; // time to live; “Entry”的生命周期，单位为秒
    union {
      uint    minorVer;
      struct  group{
        uchar reserved{0x00};
        bool  idrf;      // | [x... ....] Inital Data Requested Flag; 如初始值由服务发送，须置为1
        uchar reserved_; // | [.xxx ....]
        uchar counter;   // | [.... xxxx] 区分相同订阅者的订阅请求
        ushort groupID;  //Event Group ID; 事件组ID，也就是说SOME/IP事件订阅和取消订阅的颗粒度到一个事件组，而不是一个事件
      };
    };
}
</code></pre>
<h2 id="optiontype">OptionType</h2>
<pre><code class="language-c">//Option 字段用来传输 Entry 的附加信息，包括对于服务实例的 IP 地址、传输协议、端口号等信息。
enum OptionType :uchar {
    Configuration = 0x01, //用于传输Entry的附加信息，比如服务名等等
    IPv4_Endpoint = 0x04, //用于传输IPv4相关的参数，比如服务的IP地址、TCP还是UDP、端口号
    IPv6_Endpoint = 0x06,
    IPv4_Multcast = 0x14,
    IPv6_Multcast = 0x16
}
</code></pre>
<h2 id="option-1">Option</h2>
<pre><code class="language-c">Option {
    ushort   length; //
    OptionType  type; // enum OptionType
    uchar    reserved;
    uchar[]  data; //包括服务实例的 IP 地址、传输协议、端口号等信息。
}
// SomeIPSD 协议格式
</code></pre>
<h1 id="y-推荐资源">Y 推荐资源</h1>
<ul>
<li>AUTOSAR</li>
</ul>
<blockquote>
<ul>
<li><a href="https://www.autosar.org/fileadmin/standards/R19-11/FO/AUTOSAR_PRS_SOMEIPProtocol.pdf" target="_blank" rel="noopener nofollow">https://www.autosar.org/fileadmin/standards/R19-11/FO/AUTOSAR_PRS_SOMEIPProtocol.pdf</a></li>
</ul>
</blockquote>
<ul>
<li>Github SOME/IP 协议的项目</li>
</ul>
<blockquote>
<ul>
<li><a href="https://github.com/COVESA/vsomeip" target="_blank" rel="noopener nofollow">https://github.com/COVESA/vsomeip</a></li>
<li><a href="https://github.com/lixiaolia/ndk-someiplib" target="_blank" rel="noopener nofollow">https://github.com/lixiaolia/ndk-someiplib</a></li>
</ul>
</blockquote>
<ul>
<li><a href="https://course.zhidx.com/download/detail/YWM2YTcxMDQwYWY5ZGJjMGJhOTM=" target="_blank" rel="noopener nofollow">一网打尽车载以太网之SOME/IP(上) - 智星星</a> 【推荐】</li>
</ul>
<blockquote>
<p>GitHub上的开源代码，在GitHub中搜索"vsomeip"关键字便可找到对应的开源代码学习。值得注意的是vsomeip是一种基于Linux平台采用C++语言进行开发的SOME/IP协议</p>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/tengzijian/p/15360205.html" target="_blank">SOME/IP 学习笔记 - 博客园</a></li>
<li><a href="https://blog.csdn.net/xllhd100s/article/details/112309194" target="_blank" rel="noopener nofollow">SOME/IP-SD 深入浅出 - CSDN</a></li>
<li><a href="https://www.cnblogs.com/lzpong/p/18186396" target="_blank">SomeIP 协议格式解析 - 博客园</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.006641143206018519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 10:32">2025-01-16 10:32</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18674207" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18674207);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18674207', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18674207', title: '[车联网/以太网] SOME/IP 协议' })">举报</a>
</div>
        