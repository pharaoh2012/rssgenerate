
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cear/p/19024158" title="发布于 2025-08-05 21:58">
    <span role="heading" aria-level="2">ARM 通用中断控制器GIC（Generic Interrupt Controller）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        ARM 通用中断控制器GIC（Generic Interrupt Controller）
Zynq7000系列学习笔记
本文介绍分发器（Distributor）和CPU接口 （CPU Interface）的功能与协作，并提供C语言案例辅助理解。
分发器设置中断使能和中断优先级，并将该中断信号发送给CPU，CPU设置可接受的最低优先级，进行中断处理和完成中断通知。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="lake-content">
<p id="u3fb70ada" class="ne-p"><span class="ne-text">Zynq7000系列学习笔记</span></p>
<p class="ne-p"><span class="ne-text">本文介绍</span><strong><span class="ne-text">分发器（Distributor）</span></strong><span class="ne-text">和</span><strong><span class="ne-text">CPU接口 （CPU Interface）</span></strong><span class="ne-text">的功能与协作，并提供C语言案例辅助理解。</span></p>
<p id="u9e74ce6c" class="ne-p"><span class="ne-text">总结来说，分发器设置中断使能和中断优先级，并将该中断信号发送给CPU，CPU设置可接受的最低优先级，进行中断处理和完成中断通知。</span></p>
<h1 id="GXiz9"><span class="ne-text">一、分发器和CPU接口的功能</span></h1>
<table id="hy6Ky" class="ne-table">
<tbody>
<tr>
<td width="177">&nbsp;</td>
<td width="309">
<p id="ucf8a487a" class="ne-p"><span class="ne-text">分发器Distributor</span></p>
</td>
<td width="320">
<p id="u3414eb83" class="ne-p"><span class="ne-text">CPU 接口 (CPU Interface)</span></p>
</td>
</tr>
<tr>
<td width="177">
<p id="u4db76c03" class="ne-p"><span class="ne-text">基地址</span></p>
</td>
<td width="309">
<p id="u13883ec0" class="ne-p"><code class="ne-code"><span class="ne-text">0xF8F01000</span></code></p>
</td>
<td width="320">
<p id="u6f824195" class="ne-p"><code class="ne-code"><span class="ne-text">0xF8F00100</span></code></p>
</td>
</tr>
<tr>
<td width="177">
<p id="uca8dc105" class="ne-p"><span class="ne-text">功能</span></p>
</td>
<td width="309">
<p id="u38f78279" class="ne-p"><span class="ne-text">全局中断管理</span></p>
</td>
<td width="320">
<p id="u209b10f3" class="ne-p"><span class="ne-text">CPU 核心的中断交互</span></p>
</td>
</tr>
<tr>
<td width="177">
<p id="u8c934fb9" class="ne-p"><span class="ne-text">管理对象</span></p>
</td>
<td width="309">
<p id="uab4ececf" class="ne-p"><span class="ne-text">所有中断源 (SPI, PPI, SGI)</span></p>
</td>
<td width="320">
<p id="ufcadb8c5" class="ne-p"><span class="ne-text">连接到单个 CPU 核心的中断</span></p>
</td>
</tr>
<tr>
<td width="177">
<p id="u82bf8e2a" class="ne-p"><span class="ne-text">具体使用</span></p>
</td>
<td width="309">
<p id="u73909006" class="ne-p"><span class="ne-text">中断使能/禁用、优先级配置、路由到 CPU</span></p>
</td>
<td width="320">
<p id="u7a3e6633" class="ne-p"><span class="ne-text">中断确认、优先级屏蔽、中断完成通知</span></p>
</td>
</tr>
<tr>
<td width="177">
<p id="u187dbd7b" class="ne-p"><span class="ne-text">可见性</span></p>
</td>
<td width="309">
<p id="ua122f849" class="ne-p"><span class="ne-text">全局唯一（CPU共享）</span></p>
</td>
<td width="320">
<p id="u1a244c27" class="ne-p"><span class="ne-text">每个CPU私有</span></p>
</td>
</tr>
</tbody>
</table>
<h1 id="Owg8A"><span class="ne-text">二、工作原理与交互流程 (中断生命周期)</span></h1>
<ol class="ne-ol" data-index-type="2">
<li id="ueab4ce31" data-lake-index-type="2"><strong><span class="ne-text">中断触发（外设 → 分发器）</span></strong></li>
</ol>
<ul class="ne-ul" data-index-type="2">
<li id="u2983b494" data-lake-index-type="2"><strong><span class="ne-text">外设中断源</span></strong><span class="ne-text">（如 GPIO / UART / Timer）触发中断信号。</span></li>
<li id="ufdaabf25" data-lake-index-type="2"><strong><span class="ne-text">分发器接收：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul" data-index-type="2">
<li id="u4d85c3b2" data-lake-index-type="2"><span class="ne-text">中断信号到达分发器（</span><code class="ne-code"><span class="ne-text">0xF8F01000</span></code><span class="ne-text">）</span></li>
<li id="ued451f0c" data-lake-index-type="2"><span class="ne-text">分发器检查该中断是否 已使能（</span><code class="ne-code"><span class="ne-text">GICD_ISENABLERn</span></code><span class="ne-text">）</span></li>
<li id="u43853e12" data-lake-index-type="2"><span class="ne-text">分发器读取该中断的 优先级（</span><code class="ne-code"><span class="ne-text">GICD_IPRIORITYRn</span></code><span class="ne-text">）</span></li>
<li id="u134dfb23" data-lake-index-type="2"><span class="ne-text">分发器根据配置决定是否 转发 给目标 CPU</span></li>
</ul>
</ul>
<ol class="ne-ol" start="2">
<li id="u5e175675" data-lake-index-type="0"><strong><span class="ne-text">中断分发（分发器 → CPU 接口）</span></strong></li>
</ol>
<ul class="ne-ul">
<li id="u8922989a" data-lake-index-type="0"><strong><span class="ne-text">路由决策：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u180e0fdd" data-lake-index-type="0"><span class="ne-text">分发器检查目标 CPU 接口的状态（是否使能接收中断）</span></li>
<li id="ud4a180d8" data-lake-index-type="0"><span class="ne-text">比较 中断优先级 与目标 CPU 当前的 运行优先级（通过 CPU 接口的 GICC_PMR 获取）</span></li>
<li id="u8c8cc6ba" data-lake-index-type="0"><span class="ne-text">若中断优先级 &gt; CPU 当前优先级，分发器将其挂起到目标 CPU 的待处理队列。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="ucab856f2" data-lake-index-type="0"><strong><span class="ne-text">信号通知：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u8ded8a35" data-lake-index-type="0"><span class="ne-text">分发器通过硬件信号线通知目标 CPU 的 CPU 接口：有高优先级中断等待处理。</span></li>
</ul>
</ul>
<ol class="ne-ol" start="3">
<li id="u15b6e13b" data-lake-index-type="0"><strong><span class="ne-text">CPU 响应 (CPU 接口 → CPU 核心)</span></strong></li>
</ol>
<ul class="ne-ul">
<li id="ue1681ee6" data-lake-index-type="0"><strong><span class="ne-text">中断通知：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u897950f2" data-lake-index-type="0"><span class="ne-text">CPU 接口 （</span><code class="ne-code"><span class="ne-text">0xF8F00100</span></code><span class="ne-text">）收到分发器通知。</span></li>
<li id="ua800146e" data-lake-index-type="0"><span class="ne-text">CPU 接口向 CPU 核心 发送 IRQ/FIQ 中断请求。</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u744e480e" data-lake-index-type="0"><strong><span class="ne-text">CPU 核心响应：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u5d6bf3a3" data-lake-index-type="0"><span class="ne-text">CPU 核心暂停当前程序，跳转到 中断向量表 入口。</span></li>
<li id="uacb4de36" data-lake-index-type="0"><span class="ne-text">执行中断服务程序 (ISR) 的 入口代码。</span></li>
</ul>
</ul>
<ol class="ne-ol" start="4">
<li id="u444469a6" data-lake-index-type="0"><strong><span class="ne-text">中断处理 (ISR 与 CPU 接口交互)</span></strong></li>
</ol>
<ul class="ne-ul">
<li id="u671055a7" data-lake-index-type="0"><strong><span class="ne-text">中断确认：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ue36f2342" data-lake-index-type="0"><span class="ne-text">ISR 通过 CPU 接口的 Interrupt Acknowledge Register（GICC_IAR）读取 中断号（INTID）</span></li>
<li id="u2fbc3377" data-lake-index-type="0"><span class="ne-text">读取 GICC_IAR 的行为告知 GIC：“CPU 已开始处理此中断”</span></li>
<li id="udae619e5" data-lake-index-type="0"><span class="ne-text">GIC 自动将该中断状态从 Pending 改为 Active</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u3b641c21" data-lake-index-type="0"><strong><span class="ne-text">服务中断：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uaf0f3589" data-lake-index-type="0"><span class="ne-text">ISR 根据 INTID 执行具体的中断服务逻辑（如读取 UART 数据）</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u2dda9d59" data-lake-index-type="0"><strong><span class="ne-text">中断完成：</span></strong></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="uc5e36b6b" data-lake-index-type="0"><span class="ne-text">ISR 结束时，向 CPU 接口的 End of Interrupt Register（GICC_EOIR）写入之前读到的 INTID。</span></li>
<li id="u97a0f769" data-lake-index-type="0"><span class="ne-text">写入 GICC_EOIR 告知 GIC：“此中断处理已完成”</span></li>
<li id="udccc55a5" data-lake-index-type="0"><span class="ne-text">GIC 将该中断状态从 Active 改为 Inactive，并允许分发器再次发送此中断（若再次触发）</span></li>
</ul>
</ul>
<ol class="ne-ol" start="5">
<li id="ub36c7d6f" data-lake-index-type="0"><strong><span class="ne-text">中断优先级与抢占</span></strong></li>
</ol>
<ul class="ne-ul">
<li id="u4693e583" data-lake-index-type="0"><span class="ne-text">分发器 根据全局中断优先级决定哪些中断可发送给 CPU。</span></li>
<li id="ub4084bbf" data-lake-index-type="0"><span class="ne-text">CPU 接口 的 GICC_PMR 设置 CPU 可接受的最低优先级（低于此值的中断被屏蔽）</span></li>
<li id="u4f4b1aa1" data-lake-index-type="0"><span class="ne-text">若高优先级中断到达，且当前中断优先级较低，CPU 接口可触发 中断抢占（暂停当前 ISR，转去处理更高优先级中断）。</span></li>
</ul>
<h1 id="OnPmx"><span class="ne-text">三、软件编程详细案例</span></h1>
<ol class="ne-ol" data-index-type="2">
<li id="u58e0002b" data-lake-index-type="2"><strong><span class="ne-text">分发器初始化代码详解</span></strong></li>
</ol><ol class="ne-list-wrap"><ol class="ne-ol" data-index-type="2">
<li id="ub7313982" data-lake-index-type="2"><strong><span class="ne-text"> 全局使能分发器</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_DIST_BASE + 0x000) = 0x1; // GICD_CTLR</code></pre>
<ul class="ne-ul">
<li id="u3220d149" data-lake-index-type="0"><span class="ne-text">作用：启用整个中断分发系统，是整个 GIC 系统的总开关</span></li>
<li id="u8b6aedf7" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICD_CTLR</span></code><span class="ne-text">（Distributor Control Register）</span></li>
<li id="u5d431d0a" data-lake-index-type="0"><span class="ne-text">地址计算：基地址</span><code class="ne-code"><span class="ne-text">0xF8F01000</span></code><span class="ne-text">+偏移量</span><code class="ne-code"><span class="ne-text">0x000</span></code></li>
<li id="uba7f0151" data-lake-index-type="0"><span class="ne-text">位设置：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u09e7d636" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 0 = 1</span></code><span class="ne-text">：使能中断转发到 CPU 接口</span></li>
<li id="u8c851b84" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 1 = 0</span></code><span class="ne-text">：禁用安全扩展</span></li>
</ul>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="2" data-index-type="2">
<li id="u8cab8a68" data-lake-index-type="2"><strong><span class="ne-text">配置中断优先级</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_DIST_BASE + 0x400 + (84 * 4/4)) = 0xA0; 
// GICD_IPRIORITYR[21]</code></pre>
<ul class="ne-ul">
<li id="u29bdbe1c" data-lake-index-type="0"><span class="ne-text">作用：设置中断号84的优先级（优先级范围0~255，0最高）</span></li>
<li id="ua6ea9c7a" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICD_IPRIORITYRn</span></code><span class="ne-text">（Interrupt Priority Registers）</span></li>
<li id="u807514ac" data-lake-index-type="0"><span class="ne-text">地址计算：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u49373995" data-lake-index-type="0"><span class="ne-text">优先级寄存器组基偏移：0x400</span></li>
<li id="u4b2d0a87" data-lake-index-type="0"><span class="ne-text">中断号 84 的偏移：84 * 1（因为每个中断占 1 字节）</span></li>
<li id="u7f918c53" data-lake-index-type="0"><span class="ne-text">实际地址：</span><code class="ne-code"><span class="ne-text">0xF8F01000 + 0x400 + 84 = 0xF8F01454</span></code></li>
<li id="uf6f25901" data-lake-index-type="0"><span class="ne-text">Zynq-7000 中：0-31是私有中断（PPI）和软件中断（SGI）；32-95是共享外设中断（SPI）</span></li>
</ul>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="3" data-index-type="2">
<li id="u3f705665" data-lake-index-type="2"><strong><span class="ne-text">路由到 CPU0</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_DIST_BASE + 0x800 + (84 * 4/4)) = 0x01; 
// GICD_ITARGETSR[21]</code></pre>
<ul class="ne-ul">
<li id="ubd4cbb63" data-lake-index-type="0"><span class="ne-text">作用：指定中断84发送到 CPU0</span></li>
<li id="u25c52fb2" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICD_ITARGETSRn</span></code><span class="ne-text">（Interrupt Processor Targets Registers）</span></li>
<li id="u9dd8718c" data-lake-index-type="0"><span class="ne-text">地址计算：</span><code class="ne-code"><span class="ne-text">0xF8F01000 + 0x800 + 84 = 0xF8F01854</span></code></li>
<li id="u83505638" data-lake-index-type="0"><span class="ne-text">位掩码：</span><code class="ne-code"><span class="ne-text">0x01</span></code><span class="ne-text">表示 CPU0</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u51181b60" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 0 = 1</span></code><span class="ne-text">：路由到 CPU0</span></li>
<li id="u15b22f57" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 1 = 0</span></code><span class="ne-text">：不路由到 CPU1</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u49e49201" data-lake-index-type="0"><span class="ne-text">注：在双核系统中，必须明确指定中断发送到哪个核心。</span></li>
<li id="uc7824d66" data-lake-index-type="0"><span class="ne-text">注：PPI/SGI 不能配置路由，只有 SPI（32+）可配置</span></li>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="4" data-index-type="2">
<li id="ub4f09cdd" data-lake-index-type="2"><strong><span class="ne-text">使能中断号 84</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_DIST_BASE + 0x100 + (84 / 32)*4) |= (1 &lt;&lt; (84 % 32)); 
// GICD_ISENABLER</code></pre>
<ul class="ne-ul">
<li id="u0da520c8" data-lake-index-type="0"><span class="ne-text">作用：启用特定中断源</span></li>
<li id="u0cb0257d" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICD_ISENABLERn</span></code><span class="ne-text">（Interrupt Set-Enable Registers）</span></li>
<li id="ud2ad95db" data-lake-index-type="0"><span class="ne-text">地址计算：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u43a27b11" data-lake-index-type="0"><span class="ne-text">使能寄存器组基偏移：</span><code class="ne-code"><span class="ne-text">0x100</span></code></li>
<li id="u9d6023a6" data-lake-index-type="0"><span class="ne-text">寄存器索引：</span><code class="ne-code"><span class="ne-text">84 / 32 = 2</span></code><span class="ne-text">（第3个寄存器，管理中断64-95）</span></li>
<li id="ua3296ae4" data-lake-index-type="0"><span class="ne-text">位位置：</span><code class="ne-code"><span class="ne-text">84 % 32 = 20</span></code></li>
<li id="u52436129" data-lake-index-type="0"><span class="ne-text">实际地址：</span><code class="ne-code"><span class="ne-text">0xF8F01000 + 0x100 + 2*4 = 0xF8F01008</span></code></li>
</ul>
</ul>
<ol class="ne-ol" start="2" data-index-type="2">
<li id="u08a8f80d" data-lake-index-type="2"><strong><span class="ne-text">CPU 接口初始化代码详解</span></strong></li>
</ol><ol class="ne-list-wrap"><ol class="ne-ol" data-index-type="2">
<li id="u4fbfbf9a" data-lake-index-type="2"><strong><span class="ne-text">设置优先级屏蔽阈值</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_CPU_BASE + 0x0004) = 0xA0; // GICC_PMR</code></pre>
<ul class="ne-ul">
<li id="u39e4dd45" data-lake-index-type="0"><span class="ne-text">作用：定义 CPU 处理中断的最低优先级</span></li>
<li id="ubb0c92fd" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICC_PMR</span></code><span class="ne-text">（Priority Mask Register）</span></li>
<li id="u31e41c77" data-lake-index-type="0"><span class="ne-text">地址：</span><code class="ne-code"><span class="ne-text">0xF8F00100 + 0x0004 = 0xF8F00104</span></code></li>
<li id="u8bbe891f" data-lake-index-type="0"><span class="ne-text">值说明：0xA0（160）表示：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u25207104" data-lake-index-type="0"><span class="ne-text">优先级高于 160 的中断被屏蔽</span></li>
<li id="u0051e7bc" data-lake-index-type="0"><span class="ne-text">优先级低于 160 的中断可被处理</span></li>
<li id="ud289fea4" data-lake-index-type="0"><span class="ne-text">防止低优先级中断打断高优先级任务</span></li>
</ul>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="2" data-index-type="2">
<li id="u1dba7241" data-lake-index-type="2"><span class="ne-text">使能 CPU 接口</span></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_CPU_BASE + 0x0000) = 0x1; // GICC_CTLR</code></pre>
<ul class="ne-ul">
<li id="u26568b01" data-lake-index-type="0"><span class="ne-text">作用：启用 CPU 与 GIC 的交互通道</span></li>
<li id="uaaabce43" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICC_CTLR</span></code><span class="ne-text">（CPU Interface Control Register）</span></li>
<li id="udb152c5a" data-lake-index-type="0"><span class="ne-text">地址：</span><code class="ne-code"><span class="ne-text">0xF8F00100 + 0x0000 = 0xF8F00100</span></code></li>
<li id="u11e0238d" data-lake-index-type="0"><span class="ne-text">位设置：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="u0f1dc469" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 0 = 1</span></code><span class="ne-text">：使能中断信号到 CPU</span></li>
<li id="u95805ba3" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 1 = 0</span></code><span class="ne-text">：禁用 FIQ（通常用 IRQ）</span></li>
<li id="u43f3c116" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Bit 2 = 0</span></code><span class="ne-text">：禁用 ACK 特殊处理</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="u453581ed" data-lake-index-type="0"><span class="ne-text">注：不使能CPU接口，即使分发器发送中断，CPU 也不会响应</span></li>
</ul>
<ol class="ne-ol" start="3" data-index-type="2">
<li id="u5c65cd86" data-lake-index-type="2"><strong><span class="ne-text">中断服务程序 (ISR) </span></strong></li>
</ol><ol class="ne-list-wrap"><ol class="ne-ol" data-index-type="2">
<li id="ue479f93f" data-lake-index-type="2"><strong><span class="ne-text">读取中断号</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>uint32_t intid = *(volatile uint32_t *)(GIC_CPU_BASE + 0x000C); // GICC_IAR</code></pre>
<ul class="ne-ul">
<li id="u5706556b" data-lake-index-type="0"><span class="ne-text">作用：获取当前中断 ID 并确认接收</span></li>
<li id="uc8738da1" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICC_IAR</span></code><span class="ne-text">（Interrupt Acknowledge Register）</span></li>
<li id="u11ea5bfc" data-lake-index-type="0"><span class="ne-text">地址：</span><code class="ne-code"><span class="ne-text">0xF8F00100 + 0x000C = 0xF8F0010C</span></code></li>
<li id="u25a5fe49" data-lake-index-type="0"><span class="ne-text">读取操作的意义：</span></li>
</ul>
<ul class="ne-list-wrap">
<ul class="ne-ul">
<li id="ud7812f48" data-lake-index-type="0"><span class="ne-text">获取中断号（低 10 位）</span></li>
<li id="u2450ef9f" data-lake-index-type="0"><span class="ne-text">通知 GIC "CPU 已开始处理此中断"</span></li>
</ul>
</ul>
<ul class="ne-ul">
<li id="uff101f21" data-lake-index-type="0"><span class="ne-text">状态转换：GIC 将中断状态从 Pending 改为 Active</span></li>
<li id="uafeed794" data-lake-index-type="0"><span class="ne-text">注：必须读取此寄存器后才能安全处理中断</span></li>
<li id="u817f8346" data-lake-index-type="0"><span class="ne-text">注：返回值可能包含其他信息（如 CPU 号），通常 </span><code class="ne-code"><span class="ne-text">intid &amp; 0x3FF</span></code><span class="ne-text">提取 ID</span></li>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="2" data-index-type="2">
<li id="u014a10bb" data-lake-index-type="2"><strong><span class="ne-text">执行中断处理</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>handle_irq(intid);  // 用户定义的中断处理函数</code></pre>
<ul class="ne-ul">
<li id="u70fb0313" data-lake-index-type="0"><span class="ne-text">应避免阻塞其他中断</span></li>
<li id="u54c427df" data-lake-index-type="0"><span class="ne-text">不能调用可能阻塞的函数</span></li>
<li id="ueeb6ca74" data-lake-index-type="0"><span class="ne-text">清除外设中断标志</span></li>
</ul>
<ol class="ne-list-wrap"><ol class="ne-ol" start="3" data-index-type="2">
<li id="u2c465c6f" data-lake-index-type="2"><strong><span class="ne-text">通知中断处理完成</span></strong></li>
</ol></ol>
<pre class="ne-codeblock language-c highlighter-hljs" data-language="c"><code>*(volatile uint32_t *)(GIC_CPU_BASE + 0x0010) = intid; // GICC_EOIR</code></pre>
<ul class="ne-ul">
<li id="u8ab53d09" data-lake-index-type="0"><span class="ne-text">作用：告知 GIC 中断处理已完成</span></li>
<li id="u7cfdb5e2" data-lake-index-type="0"><span class="ne-text">寄存器：</span><code class="ne-code"><span class="ne-text">GICC_EOIR</span></code><span class="ne-text">（End of Interrupt Register）</span></li>
<li id="u6bbb811e" data-lake-index-type="0"><span class="ne-text">地址：</span><code class="ne-code"><span class="ne-text">0xF8F00100 + 0x0010 = 0xF8F00110</span></code></li>
<li id="u73f9f1c0" data-lake-index-type="0"><span class="ne-text">注：必须写入从</span><code class="ne-code"><span class="ne-text">GICC_IAR</span></code><span class="ne-text">读取的原始值</span></li>
<li id="u50a97388" data-lake-index-type="0"><span class="ne-text">必须在中断处理完成后立即执行</span></li>
<li id="u2426b3af" data-lake-index-type="0"><span class="ne-text">此时中断状态从Active转换为Inactive，才能允许相同的中断再次触发</span></li>
</ul>
<p id="u942f0f4e" class="ne-p">&nbsp;</p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-05 21:58">2025-08-05 21:58</span>&nbsp;
<a href="https://www.cnblogs.com/cear">cear</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19024158);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19024158', targetLink: 'https://www.cnblogs.com/cear/p/19024158', title: 'ARM 通用中断控制器GIC（Generic Interrupt Controller）' })">举报</a>
</div>
        