
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/March7thDev/p/18678862" title="发布于 2025-01-18 20:57">
    <span role="heading" aria-level="2">树（基础）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="树">树</h1>
<h2 id="1--定义">1  定义</h2>
<h3 id="11--树是什么">1.1  树是什么</h3>
<p>树是一种数据结构，因为形似倒着的树而得名.</p>
<h3 id="12--树的定义">1.2  树的定义</h3>
<p>递归定义</p>
<h4 id="121--有根树的定义">1.2.1  有根树的定义</h4>
<p>形象化的，如图1，有根树存在根节点这一定义，从根节点可以分出任意个分支，这任意个分支又可以继续细分，分出的节点称为“子节点”。<br>
<br><br>
抽象化的，树也是<span class="math inline">\(N\)</span>个节点和<span class="math inline">\(N-1\)</span>条边的集合。<br>
<br><br>
每条边都将某个节点连接至他的父亲,而除去根节点外的每个节点都有父亲，每个结点之间互不相交。</p>
<h4 id="122--无根树的定义">1.2.2  无根树的定义</h4>
<p>形象化的，无根树就是有根树删去根节点后得到的东西<br>
<br><br>
抽象化的，无根树也是树是<span class="math inline">\(N\)</span>个节点和<span class="math inline">\(N-1\)</span>条边的集合。<br>
<br><br>
每条边都将某个节点连接至他的父亲,每个节点互不相交</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/kw5zai7k.png" alt="图1 有根树" loading="lazy"></p>
<h3 id="13--有关树的一些常用术语">1.3  有关树的一些常用术语</h3>
<p><strong>森林</strong>:每个连通块都是树的图。按照定义，<strong>一棵树也是森林</strong><br>
<br><br>
<strong>叶节点</strong>：没有子节点的节点<br>
<br><br>
<strong>父亲</strong>：一个节点上一层的点<br>
<br><br>
<strong>祖先</strong>：一个点上层的每一个点<br>
<br><br>
<strong>子节点</strong>：一个节点延伸出的下一个节点<br>
<br><br>
<strong>深度</strong>:一个点到根节点的层数（边数）<br>
<br><br>
<strong>高度</strong>：从叶节点到根节点的层数。<br>
<br><br>
<strong>兄弟</strong>：同一个父节点的子节点互为兄弟<br>
<br><br>
<strong>后代</strong>:一个点下层的每一个点是当前点的后代。<br>
<br><br>
<strong>度</strong>:一个节点的子树个数（其实这个概念应该放在前面，大家可以试着使用度来概括一些前期概念）<br>
<br><br>
<strong>内部节点</strong>：根以外的分支节点<br>
<br><br>
<strong>树的度</strong>：这棵树各节点中度的最大值<br>
<br><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/lwifzoj6.png" alt="图2 数的术语" loading="lazy"></p>
<h3 id="14-特殊树">1.4 特殊树</h3>
<p><strong>链</strong>：满足与任意节点相连的边不超过2条的树<br>
<br><br>
<strong>二叉树</strong>:每个节点<strong>最多</strong>只有两个子节点的树。<br>
<br><br>
<strong>完整二叉树</strong>:每个节点的子节点数量都为<strong>2</strong>或<strong>没有</strong><br>
<br><br>
<strong>完全二叉树</strong>：只有最下面<strong>两层</strong>节点度数可以<span class="math inline">\(&lt;2\)</span>,且最下面一层节点都位于该层最左边的位置上。<br>
<br><br>
<strong>完美二叉树</strong>:所有叶节点深度相同，且所有节点都只有两个子节点！<br>
<br><br>
<font color="red">注意！完美二叉树一定也是完全二叉树和完满二叉树，但完满二叉树不一定是完全二叉树和完美二叉树。</font><br>
<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rfldemjf.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oykolj88.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/el9qekkx.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/uhqdtezy.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/89c32so0.png" alt="" loading="lazy"></p>
<h3 id="15--二叉树的一些性质">1.5  二叉树的一些性质</h3>
<p>性质部分:<br><br>
1.在二叉树的第<span class="math inline">\(i\)</span>层上最多有<span class="math inline">\(2^{i-1}\)</span>个节点<br><br>
2.深度为<span class="math inline">\(k\)</span>的二叉树最多有<span class="math inline">\(2^k-1\)</span>个节点<br><br>
3.对任意一棵二叉树，如果其叶节点数为<span class="math inline">\(n_0\)</span>,度为<span class="math inline">\(2\)</span>的节点数为<span class="math inline">\(n_2\)</span>,则一定满足<span class="math inline">\(n_0=n_2+1\)</span><br><br>
4.具有<span class="math inline">\(n\)</span>个基点的完全二叉树的深度为<span class="math inline">\(floor(log_2n)+1\)</span><br><br>
5.对于一棵<span class="math inline">\(n\)</span>个节点的完全二叉树，对任意一个节点<span class="math inline">\(i\)</span>,有：<br>
<br><br>
5.1 如果<span class="math inline">\(i=1\)</span>，则节点<span class="math inline">\(i\)</span>为根，无父节点；<br><br>
5.2 如果<span class="math inline">\(i&gt;1\)</span>,则其父节点编号为<span class="math inline">\(i/2\)</span><br><br>
5.3 如果<span class="math inline">\(2*i&gt;n\)</span>，则节点<span class="math inline">\(i\)</span>是叶节点，否则左孩子编号为<span class="math inline">\(2*i\)</span><br><br>
5.4 如果<span class="math inline">\(2*i+1&gt;n\)</span>,则节点<span class="math inline">\(i\)</span>无右孩子，否则右孩子编号为<span class="math inline">\(2*1+1\)</span><br><br>
<br><br>
证明部分：<br><br>
用归纳法证明性质1.<br><br>
当<span class="math inline">\(i=1\)</span>时，</p>
<h2 id="2--树的储存">2  树的储存</h2>
<h3 id="21--普通树的储存">2.1  普通树的储存</h3>
<h4 id="211--顺序存储">2.1.1  顺序存储</h4>
<p>1.<strong>父亲表示法</strong>（数组记录孩子的父亲为父亲）<br>
<br></p>
<pre><code class="language-cpp">int data[N];//存数据的
int father[N];//father[i]=j 表示i的父亲为j
</code></pre>
<p>2.<strong>孩子表示法</strong>（数组记录父亲的第任意个孩子为孩子）<br>
<br></p>
<pre><code class="language-cpp">int data[N];//不做过多解释
int son[N][M];//son[i][j]=k表示父亲i的第j个孩子为k
</code></pre>
<p>3.<strong>父亲孩子表示法</strong>(双向奔赴的爱)<br>
<br></p>
<pre><code class="language-cpp">int data[N];//不做过多解释
int father[N];//father[i]=j 表示i的父亲为j
int son[N][M];//son[i][j]=k表示父亲i的第j个孩子为k
</code></pre>
<p>4.<strong>孩子兄弟表示法</strong>（见故事）<br>
<br></p>
<pre><code class="language-cpp">int data[N];//不做过多解释
int firstson[N];//表示父亲的第一个孩子
int nxt[N];//nxt[i]=j表示i的下一个兄弟为j
</code></pre>
<p>这里我们老师给我们讲了个故事，说乾隆生了100多个孩子，这时候怎么记是不是自己孩子呢？就让哥哥记住自己弟弟，弟弟在记住自己弟弟，这就是孩子兄弟表示法。<br>
<br></p>
<h4 id="212--链式存储">2.1.2  链式存储</h4>
<p>1.<strong>父亲表示法</strong><br>
<br></p>
<pre><code class="language-cpp">struct node
{
    int data;// 节点存储的数据
    node *father// 指向父节点的指针
}tree[N];//树
</code></pre>
<p>2.<strong>孩子表示法</strong><br>
<br></p>
<pre><code class="language-cpp">struct node
{
    int data;// 节点存储的数据
    node *son[M];//指向子节点的指针
}tree[N];
</code></pre>
<p>3.<strong>父亲孩子表示法</strong><br>
<br></p>
<pre><code class="language-cpp">struct node
{
    int data;//数据
    node *father;//指向父亲
    node *son[M];//指向孩子
}tree[N];
</code></pre>
<p>4.<strong>孩子兄弟表示法</strong><br>
<br></p>
<pre><code class="language-cpp">struct node
{
    int data;//数据
    node *firstson;//第一个儿子
    node *bro;//下一个兄弟
}tree[N];
</code></pre>
<h3 id="22-二叉树的存储">2.2 二叉树的存储</h3>
<p>1.<strong>顺序存储</strong><br>
<br></p>
<pre><code class="language-cpp">int data[N];//数据域
</code></pre>
<p>2.<strong>链式存储</strong></p>
<pre><code class="language-cpp">struct node
{
    int data;
    node *lc;//左孩子
    node *rc;//右孩子
    node(int d)//构造函数
    {
        data=d;// 初始化节点数据为传入的参数d
        lc=NULL;// 初始化左子节点指针为NULL
        rc=NULL;// 初始化右子节点指针为NULL
    }
    //另一种写法
    /*
      node(int d) : data(d), lc(NULL), rc(NULL)
    {

    }
    */
};
node *bt;//根节点指针
</code></pre>
<h2 id="3树的遍历">3.树的遍历</h2>
<p>先序遍历，中序遍历，后序遍历</p>
<h3 id="31--先序遍历">3.1  先序遍历</h3>
<p>如图8，先序遍历类似<span class="math inline">\(DFS\)</span>,从根开始，然后是左子树，递归到最深层后返回，然后遍历右子树，最后回到根<br>
<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/w17gkcby.png" alt="" loading="lazy"><br>
<br></p>
<pre><code class="language-cpp">void preoder(int f)
{
    cout&lt;&lt;data[f]&lt;&lt;" ";//首先在函数运行前输出是为了先从根节点开始
    if(lc[2*f]&gt;0)//左子树
        preoder(2*f);
    if(rc[2*f+1]&gt;0)//右子树
        preoder(2*f+1);
}
</code></pre>
<h3 id="32--中序遍历">3.2  中序遍历</h3>
<p>如图9，中序遍历在遍历完左子树后直接跳向根节点后遍历右子树<br><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/x4kkvjcv.png" alt="" loading="lazy"><br>
<br></p>
<pre><code class="language-cpp">void inoder(int f)
{
    if(lc[f]&gt;0)
        inoder(lc[f]);
    cout&lt;&lt;data[f]&lt;&lt;endl;//在遍历左子树时输出是为了先从左子树开始
    if(rc[f]&gt;0)
        inoder(rc[f]);
}
</code></pre>
<h3 id="33--后序遍历">3.3  后序遍历</h3>
<p>如图10，后序遍历在遍历完左子树后直接跳向右子树叶子节点后向上遍历至根节点<br><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oe363ck8.png" alt="" loading="lazy"><br>
<br></p>
<pre><code class="language-cpp">void postoder(int f)
{
    if(lc[f]&gt;0)
        postoder(lc[f])
    if(rc[f]&gt;0)
        postoder(rc[f]);
    cout&lt;&lt;data[f]&lt;&lt;endl;//在遍历右子树时输出是为了从右子树开始
}
</code></pre>
<h3 id="34--faq">3.4  FAQ</h3>
<p>肯定会有彭于晏有疑问，为什么他们的输出位置不同，决定了他们的遍历次数不同？<br><br>
1.先序遍历 首先在函数运行前输出是为了先从根节点开始<br><br>
2.中序遍历 在遍历左子树时输出是为了先从左子树开始<br><br>
3.后序遍历 在遍历右子树时输出是为了从右子树开始<br><br>
神不神奇？<s>反正我觉得挺神奇</s><br></p>
<p>接下来需要完善的：<br><br>
2.二叉树性质 证明<br><br>
4.反推<br><br>
5.BFS<br><br>
6.Morris<br></p>
<p>呼~~ 用时7个多小时终于写完了！希望能帮到你喵~~</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.059631485336805554" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 20:57">2025-01-18 20:57</span>&nbsp;
<a href="https://www.cnblogs.com/March7thDev">March7thDev</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678862" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678862);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678862', targetLink: 'https://www.cnblogs.com/March7thDev/p/18678862', title: '树（基础）' })">举报</a>
</div>
        