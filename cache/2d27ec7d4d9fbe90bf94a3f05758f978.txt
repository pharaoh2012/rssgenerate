
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18656383" title="发布于 2025-01-10 09:38">
    <span role="heading" aria-level="2">掌握设计模式--享元模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="享元模式flyweight-pattern">享元模式（Flyweight Pattern）</h2>
<p>享元模式是一种结构型设计模式，它通过共享相同的对象来减少内存使用，从而提升性能。它适用于有大量相似对象的场景，通过共享相同的对象来避免创建大量重复对象。强调的是共享对象，不共享对象的行为。</p>
<h3 id="核心思想">核心思想</h3>
<p>将对象分为 <strong>内部状态（Intrinsic State）</strong> 和 <strong>外部状态（Extrinsic State）</strong>：</p>
<ul>
<li><strong>内部状态</strong>：可以被共享，不会随环境变化而改变。</li>
<li><strong>外部状态</strong>：依赖于具体的场景，不可共享，需要通过客户端传递给享元对象。</li>
</ul>
<p>这样说可能太抽象了，看文中的代码示例具体的感受下。</p>
<h3 id="组成部分">组成部分</h3>
<ol>
<li>
<p><strong>Flyweight（享元接口）</strong><br>
定义共享对象的接口，描述公共行为。</p>
</li>
<li>
<p><strong>ConcreteFlyweight（具体享元类）</strong><br>
实现共享对象的具体行为，保存内部状态。</p>
</li>
<li>
<p><strong>UnsharedConcreteFlyweight（非共享享元类）</strong><br>
不需要共享的对象，通常包含具体的子节点组合。</p>
</li>
<li>
<p><strong>FlyweightFactory（享元工厂）</strong><br>
管理享元对象的创建和共享，确保合理地创建和复用对象。</p>
</li>
<li>
<p><strong>Client（客户端）</strong><br>
负责传递外部状态给享元对象。</p>
</li>
</ol>
<h2 id="案例实现">案例实现</h2>
<p>围棋示例，<code>棋子</code>为<code>共享对象</code>，<code>下棋的位置</code>为<code>非共享对象</code>，通过<code>享元工厂</code>控制棋子的创建，整个棋盘中<code>只有黑白两种棋子</code>，一共只会创建两个对象，变化的只是下棋的位置，而<code>下棋的位置由客户端决定</code>。</p>
<h3 id="案例类图">案例类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106215710695-964031852.png" alt="image" loading="lazy"></p>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

// 享元接口：棋子
interface Flyweight {
    void display(String position); // 外部状态：棋子的位置
}

// 具体享元类：棋子的颜色可以共享
class GoPieceFlyweight implements Flyweight {
    private final String color; // 棋子的颜色（黑或白）

    public GoPieceFlyweight(String color) {
        this.color = color;
    }

    @Override
    public void display(String position) {
        System.out.println("Go Piece: Color = " + color + ", Position = " + position);
    }
}

// 享元工厂：负责管理享元对象的创建和共享
class GoPieceFactory {
    private static final Map&lt;String, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    // 同一种颜色的棋子只会创建一次
    public static Flyweight getFlyweight(String color) {
        // 如果已有该颜色的棋子，直接返回；否则创建新的棋子
        if (!flyweightMap.containsKey(color)) {
            flyweightMap.put(color, new GoPieceFlyweight(color));
            System.out.println("创建新围棋棋子，颜色为: " + color);
        }
        return flyweightMap.get(color);
    }
}

// 下棋操作
class PlayChess{

    public void play(String color, String position){
        // 享元工厂创建享元对象：共享棋子颜色（黑或白）
        Flyweight piece = GoPieceFactory.getFlyweight(color);
        // 外部状态：棋子的位置
        piece.display(position);
    }
}

// 客户端代码：围棋棋盘
public class GoGame {
    public static void main(String[] args) {
        // 围棋开局
        PlayChess playChess = new PlayChess();
        // 白棋先手
        playChess.play("White","D4");
        playChess.play("Black","D5");
        playChess.play("White","C6");
        playChess.play("Black","D9");
        System.out.println("--------------------------------------");
        // 围棋开局：其它用户也开局
        PlayChess playChess2 = new PlayChess();
        // 黑棋先手
        playChess2.play("Black","D7");
        playChess2.play("White","E8");
        playChess2.play("Black","D9");
        playChess2.play("White","D5");

    }
}
</code></pre>
<h3 id="测试结果简析">测试结果简析</h3>
<p><strong>测试输出结果</strong></p>
<blockquote>
<p>创建新围棋棋子，颜色为: White</p>
<p>Go Piece: Color = White, Position = D4</p>
<p>创建新围棋棋子，颜色为: Black</p>
<p>Go Piece: Color = Black, Position = D5</p>
<p>Go Piece: Color = White, Position = C6</p>
<p>Go Piece: Color = Black, Position = D9</p>
<hr>
<p>Go Piece: Color = Black, Position = D7</p>
<p>Go Piece: Color = White, Position = E8</p>
<p>Go Piece: Color = Black, Position = D9</p>
<p>Go Piece: Color = White, Position = D5</p>
</blockquote>
<p><strong>结果简析</strong></p>
<p>整个代码执行过程只创建两个棋子对象，变化的只有位置信息。逐一分析如下</p>
<ol>
<li><strong>共享的内部状态</strong>：</li>
</ol>
<p>棋子的 <strong>颜色</strong>（黑色或白色）是共享的，棋盘上的每个棋子不需要重新创建相同颜色的棋子实例。工厂方法 <code>getFlyweight()</code> 保证对于相同颜色的棋子，始终使用相同的对象。</p>
<p>例如，无论在棋盘的任何位置放置黑棋，都会复用相同的黑色棋子实例。</p>
<ol start="2">
<li><strong>独立的外部状态</strong>：</li>
</ol>
<p>每个棋子的 <strong>位置</strong>（如 D4、C6 等）是外部状态，它随棋局变化而变化，因此不共享，客户端在调用 <code>display()</code> 方法时传递具体位置。</p>
<ol start="3">
<li><strong>享元工厂</strong>：</li>
</ol>
<p>享元工厂 <code>GoPieceFactory</code> 负责管理不同颜色棋子的创建和共享。当请求相同颜色的棋子时，工厂返回已存在的实例；否则创建一个新的实例。</p>
<ol start="4">
<li><strong>复用共享对象</strong>：</li>
</ol>
<p>在后续的棋步中，如果再次放置黑色棋子，<code>GoPieceFactory</code> 会复用之前创建的黑色棋子对象，而不需要重新创建。</p>
<h2 id="优缺点和适用场景">优缺点和适用场景</h2>
<p><strong>优点</strong>：</p>
<ol>
<li>节省内存：通过共享对象，避免了大量重复对象的内存占用。</li>
<li>性能优化：减少了对象创建的开销。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>引入了复杂性：需要分离内部和外部状态，并通过工厂管理对象的共享。</li>
<li>不适用于外部状态过于复杂的场景。</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ol>
<li>各种游戏场景、图形绘制等；</li>
<li>系统中存在大量相似对象，造成内存使用量过高；</li>
<li>对象的内部状态相对稳定，可以共享。</li>
</ol>
<p>例如：</p>
<ul>
<li>文本编辑器中的字符共享；</li>
<li>图形绘制中的共享对象（如游戏中的子弹对象）；</li>
<li>数据库连接池。</li>
</ul>
<h2 id="单例模式与享元模式对比">单例模式与享元模式对比</h2>
<p><strong>单例模式</strong>：</p>
<p>单例模式确保全局只有一个对象实例，它仅需一次内存分配。</p>
<p><strong>享元模式</strong>：</p>
<p>享元模式通过复用大量相似对象的内部状态，减少内存消耗。在享元模式中，尽管有多个享元对象，但共享的部分（内部状态）是复用的，外部状态通常由客户端提供，从而减少内存占用。</p>
<h2 id="总结">总结</h2>
<p>享元模式强调的是共享对象，不共享对象的行为。通过共享对象来优化内存使用，尤其适用于有大量相似对象的场景。它通过分离对象的内部状态和外部状态，实现了内部状态的内存复用，减少了对象创建的开销。在需要管理大量细粒度对象的应用中，享元模式是一个非常有效的解决方案。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106215753692-1351787312.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4506123519363426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 09:38">2025-01-10 09:38</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">155</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656383" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656383);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656383', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18656383', title: '掌握设计模式--享元模式' })">举报</a>
</div>
        