
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18898303" title="发布于 2025-05-27 11:38">
    <span role="heading" aria-level="2">聊一聊 .NET Dump 中的 Linux信号机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>当 <code>.NET程序</code> 在Linux上崩溃时，我们可以配置一些参考拿到对应程序的core文件，拿到core文件后用windbg打开，往往会看到这样的一句信息 <code>Signal SIGABRT code SI_USER (Sent by kill, sigsend, raise)</code>，参考如下：</p>
<pre><code class="language-C#">
(1.1d): Signal SIGABRT code SI_USER (Sent by kill, sigsend, raise)
libc_so!wait4+0x57:
00007fbd`09313c17 483d00f0ffff    cmp     rax,0FFFFFFFFFFFFF000h
0:023&gt; ? 1d
Evaluate expression: 29 = 00000000`0000001d
0:023&gt; ~29s
*** WARNING: Unable to verify timestamp for libSystem.Native.so
libc_so!read+0x4c:
00007fbd`0933829c 483d00f0ffff    cmp     rax,0FFFFFFFFFFFFF000h

</code></pre>
<p>从字面上看是 <code>kill,sigsend,raise</code> 发出了携带 SI_USER 代码的 SIGABRT 信号，看起来和Linux信号机制有关，那具体是什么意思呢？这就是本篇和大家详聊的。</p>
<h2 id="二linux-信号机制">二：Linux 信号机制</h2>
<h3 id="1-信号机制简介">1. 信号机制简介</h3>
<p>简单的说<code>Linux信号</code>是一种进程间通信机制，大概可以做三件事情。</p>
<ul>
<li>通知进程发生了某种事件，比如：段错误。</li>
<li>允许进程间发送简单的消息。</li>
<li>控制进程行为，比如：终止、暂停、继续等。</li>
</ul>
<p>在 linux 上有60多个信号，默认能产生core文件的有11个，这也是我们最关心的，整理成表格如下：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>信号编号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>通常由 Ctrl+\ 触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>由 abort() 函数产生</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>浮点异常</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>段错误（非法内存访问）</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>7</td>
<td>总线错误（内存访问对齐问题等）</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>31</td>
<td>错误的系统调用</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>5</td>
<td>跟踪/断点陷阱</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24</td>
<td>超出 CPU 时间限制</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>25</td>
<td>超出文件大小限制</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>7</td>
<td>EMT 指令（某些架构）</td>
</tr>
</tbody>
</table>
<p>有了这些基础之后就可以解读 <code>Signal SIGABRT code SI_USER (Sent by kill, sigsend, raise)</code> 这句话了。</p>
<h4 id="1-sigabrt">1) SIGABRT</h4>
<p>全称 signal abort ，是一种能产生 core 的信号。</p>
<h4 id="2-si_user">2) SI_USER</h4>
<p>在 linux 源码中有这样一句代码<code>(type == PIDTYPE_PID) ? SI_TKILL : SI_USER</code>，参考如下：</p>
<pre><code class="language-C">
static void prepare_kill_siginfo(int sig, struct kernel_siginfo *info,enum pid_type type)
{
	clear_siginfo(info);
	info-&gt;si_signo = sig;
	info-&gt;si_errno = 0;
	info-&gt;si_code = (type == PIDTYPE_PID) ? SI_TKILL : SI_USER;
	info-&gt;si_pid = task_tgid_vnr(current);
	info-&gt;si_uid = from_kuid_munged(current_user_ns(), current_uid());
}

</code></pre>
<p>代码中的 <code>kernel_siginfo.si_code</code> 字段用来表示信号的来源，比如说 <code>SI_USER</code> 表示信号来源于用户进程，而后者的 <code>SI_TKILL</code> 表示信号来源于 <code>tgkill,tkill</code> 系统调用。</p>
<h4 id="3-killsigsendraise">3) kill,sigsend,raise</h4>
<p>熟悉 linux 的朋友应该对 <code>kill</code> 和 <code>raise</code> 方法非常熟悉，毕竟他们遵守 <code>POSIX</code> 标准，至于他们有什么区别，看签名就知道了。。。</p>
<pre><code class="language-C#">
/* Raise signal SIG, i.e., send SIG to yourself.  */
extern int raise (int __sig) __THROW;

/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is &lt; -1, send SIG to all processes in process group - PID.  */
#ifdef __USE_POSIX
extern int kill (__pid_t __pid, int __sig) __THROW;
#endif /* Use POSIX.  */

</code></pre>
<p>相比前面的函数，这个 <code>sigsend</code> 就不是 <code>POSIX</code> 标准了，只在部分Unix上可用，比如 Solaris，SunOS，不过功能还是很强大的，不仅可以指定 pid，还可以指定 pidgroup 以及 user 来批量的 kill 进程，这里做个了解即可，签名如下：</p>
<pre><code class="language-C#">
int sigsend(idtype_t idtype, id_t id, int sig);

</code></pre>
<p>这些信息汇总之后更准确的意思就是：<code>你的程序可能调用了 kill(SIGABRT) ,raise(SIGABRT)，abort 引发的程序崩溃</code>，那是不是这样的呢？可以用 windbg 的 <code>~* k</code> 观察每个线程的调用栈，最终还真给找到了。</p>
<pre><code class="language-C#">
0:023&gt; k
 # Child-SP          RetAddr               Call Site
00 00007fbd`03c62a70 00007fbd`090bf635     libc_so!wait4+0x57
01 00007fbd`03c62aa0 00007fbd`090c0580     libcoreclr!PROCCreateCrashDump+0x275 [/__w/1/s/src/coreclr/pal/src/thread/process.cpp @ 2307] 
02 00007fbd`03c62b00 00007fbd`090be22f     libcoreclr!PROCCreateCrashDumpIfEnabled+0x770 [/__w/1/s/src/coreclr/pal/src/thread/process.cpp @ 2524] 
03 00007fbd`03c62b90 00007fbd`090be159 (T) libcoreclr!PROCAbort+0x2f [/__w/1/s/src/coreclr/pal/src/thread/process.cpp @ 2555] 
04 (Inline Function) --------`-------- (T) libcoreclr!PROCEndProcess+0x7c [/__w/1/s/src/coreclr/pal/src/thread/process.cpp @ 1352] 
05 00007fbd`03c62bb0 00007fbd`08db667f (T) libcoreclr!TerminateProcess+0x84 [/__w/1/s/src/coreclr/pal/inc/pal_mstypes.h @ 1249] 
...
09 00007fbd`03c63950 00007fbd`08d4524e     libcoreclr!UMEntryThunk::Terminate+0x38 [/__w/1/s/src/coreclr/inc/clrtypes.h @ 260] 
0a (Inline Function) --------`--------     libcoreclr!InteropSyncBlockInfo::FreeUMEntryThunk+0x24 [/__w/1/s/src/coreclr/vm/syncblk.cpp @ 119] 
19 00007fbd`03c63e30 00007fbd`092c91f5     libcoreclr!CorUnix::CPalThread::ThreadEntry+0x1fe [/__w/1/s/src/coreclr/pal/inc/pal.h @ 1763] 
1a 00007fbd`03c63ee0 00007fbd`09348b00     libc_so!pthread_condattr_setpshared+0x515
1b 00007fbd`03c63f80 ffffffff`ffffffff     libc_so!_clone+0x40
1c 00007fbd`03c63f88 00000000`00000000     0xffffffff`ffffffff

</code></pre>
<p>在上面的代码中我们看到了 <code>libcoreclr!PROCAbort</code> 函数，在 coreclr 中方法定义如下：</p>
<pre><code class="language-C#">
/*++
Function:
  PROCAbort()

  Aborts the process after calling the shutdown cleanup handler. This function
  should be called instead of calling abort() directly.

Parameters:
  signal - POSIX signal number

  Does not return
--*/
PAL_NORETURN
VOID
PROCAbort(int signal)
{
    // Do any shutdown cleanup before aborting or creating a core dump
    PROCNotifyProcessShutdown();

    PROCCreateCrashDumpIfEnabled(signal);

    // Restore the SIGABORT handler to prevent recursion
    SEHCleanupAbort();

    // Abort the process after waiting for the core dump to complete
    abort();
}

VOID PROCCreateCrashDumpIfEnabled(int signal, siginfo_t* siginfo, bool serialize)
{
	// If enabled, launch the create minidump utility and wait until it completes
	if (!g_argvCreateDump.empty())
	{
		std::vector&lt;const char*&gt; argv(g_argvCreateDump);
    ...
	}
}

</code></pre>
<p>卦中的代码逻辑非常清楚，在 abort 退出之前，先通过 <code>PROCCreateCrashDumpIfEnabled(signal)</code> 方法踩了一个dump，也就是说 dump 中看到的信息就是用他来填充的，可以观察 <code>libcoreclr!g_argvCreateDump</code> 全局变量，参考如下：</p>
<pre><code class="language-C#">
0:023&gt; x libcoreclr!*g_argvCreateDump*
00007fbd`09192360 libcoreclr!g_argvCreateDump = {size=8}
0:023&gt; dx -r1 (*((libcoreclr!std::vector&lt;const char *, std::allocator&lt;const char *&gt; &gt; *)0x7fbd09192360))
(*((libcoreclr!std::vector&lt;const char *, std::allocator&lt;const char *&gt; &gt; *)0x7fbd09192360))                 : {size=8} [Type: std::vector&lt;const char *, std::allocator&lt;const char *&gt; &gt;]
    [&lt;Raw View&gt;]     [Type: std::vector&lt;const char *, std::allocator&lt;const char *&gt; &gt;]
    [size]           : 8
    [capacity]       : 8
    [0]              : 0x5555b5d71140 : "/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.15/createdump" [Type: char *]
    [1]              : 0x7fbd08b61d8f : "--name" [Type: char *]
    [2]              : 0x7ffd1b7e1cec : "/db/xxxx/crash.dmp" [Type: char *]
    [3]              : 0x7fbd08b6ce5f : "--full" [Type: char *]
    [4]              : 0x7fbd08b4c7ee : "--diag" [Type: char *]
    [5]              : 0x7fbd08b58630 : "--crashreport" [Type: char *]
    [6]              : 0x5555b5dd7230 : "1" [Type: char *]
    [7]              : 0x0 [Type: char *]

</code></pre>
<h3 id="2-c代码眼见为实">2. C代码眼见为实</h3>
<p>为了能够让大家有一个更加贴切的眼见为实，我们用 C 代码亲自演示一下，为产生 core 文件，配置如下：</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2# ulimit -c unlimited 
root@ubuntu2404:/data2# echo /data2/core-%e-%p-%t  | sudo tee /proc/sys/kernel/core_pattern
/data2/core-%e-%p-%t

</code></pre>
<p>配置好之后，大家可以使用 <code>abort,kill,raise</code> 这三个方法的任何一个，这里我就用 <code>kill</code> 来演示吧。</p>
<pre><code class="language-C#">
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

void sig_handler(int signo, siginfo_t *info, void *context)
{
    fprintf(stderr, "Received signal: %d (sent by PID: %d, UID: %d)\n",
            signo, info-&gt;si_pid, info-&gt;si_uid);
}

int main()
{
    struct sigaction sa;

    sa.sa_sigaction = sig_handler;
    sa.sa_flags = SIGABRT;
    sigemptyset(&amp;sa.sa_mask);

    if (sigaction(SIGSEGV, &amp;sa, NULL) == -1)
    {
        perror("sigaction");
        return 1;
    }

    printf("My PID: %d\n", getpid());
    printf("Press Enter to send SIGABRT to myself...\n");
    getchar();

    kill(getpid(), SIGABRT);  // 第一种方式
    // raise(SIGABRT);        // 第二种方式
    //  abort();              //第三方方式

    printf("This line may not be reached.\n");
    return 0;
}

</code></pre>
<p>ternimal 如下：</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2# ./app
My PID: 7403
Press Enter to send SIGABRT to myself...

Aborted (core dumped)
root@ubuntu2404:/data2# 
root@ubuntu2404:/data2# ls -lh
total 160K
-rwxr-xr-x 1 root root  21K May 27 10:25 app
-rw-r--r-- 1 root root  813 May 27 10:25 app.c
-rw------- 1 root root 432K May 27 10:25 core-app-7403-1748312729

</code></pre>
<p>用 windbg 打开 core-app-7403-1748312729 文件，熟悉的画面又回来了，哈哈。截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250527113750804-1127404487.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>要分析linux 上的.NET程序崩溃，理解<code>Linux信号机制</code>是一个必须要过的基础，调试之路艰难哈。。。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.031166631858796" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 11:38">2025-05-27 11:38</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">260</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18898303);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18898303', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18898303', title: '聊一聊 .NET Dump 中的 Linux信号机制' })">举报</a>
</div>
        