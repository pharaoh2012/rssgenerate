
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/makemylife/p/18843555" title="发布于 2025-04-23 21:52">
    <span role="heading" aria-level="2">聊聊四种实时通信技术：长轮询、短轮询、WebSocket 和 SSE</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这篇文章，我们聊聊 四种实时通信技术：短轮询、长轮询、WebSocket 和 SSE 。</p>
<h1 id="1-短轮询">1 短轮询</h1>
<p>浏览器 <strong>定时</strong>（如每秒）向服务器发送 HTTP 请求，服务器立即返回当前数据（无论是否有更新）。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154356-1068261093.png" alt="" loading="lazy"></p>
<ul>
<li><strong>优点</strong>：实现简单，兼容性极佳</li>
<li><strong>缺点</strong>：高频请求浪费资源，实时性差（依赖轮询间隔）</li>
<li><strong>延迟</strong>：高（取决于轮询频率）</li>
<li><strong>适用场景</strong>：兼容性要求高，延迟不敏感的简单场景。</li>
</ul>
<p>笔者职业生涯印象最深刻的短轮询应用场景是<strong>比分直播</strong>：</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154239-376754289.png" alt="" loading="lazy"></p>
<p>如图所示，用户进入比分直播界面，浏览器定时查询赛事信息（比分变动、黄红牌等），假如数据有变化，则重新渲染页面。</p>
<p>这种方式实现起来非常简单可靠，但是频繁的调用后端接口，会对后端性能会有影响（主要是 CPU）。同时，因为依赖轮询间隔，页面数据变化有延迟，用户体验并不算太好。</p>
<h1 id="2-长轮询">2 长轮询</h1>
<p>浏览器发送 HTTP 请求后，服务器&nbsp;<strong>挂起连接</strong>&nbsp;直到数据更新或超时，返回响应后浏览器立即发起新请求。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154239-114279491.png" alt="" loading="lazy"></p>
<ul>
<li><strong>优点</strong>：减少无效请求，比短轮询实时性更好</li>
<li><strong>缺点</strong>：服务器需维护挂起连接，高并发时资源消耗大</li>
<li><strong>延迟</strong>：中（取决于数据更新频率）</li>
<li><strong>适用场景</strong>：需要较好实时性且无法用 WebSocket/SSE 的场景（如消息通知）</li>
</ul>
<p>长轮询最常见的应用场景是：配置中心，我们耳熟能详的注册中心 Nacos 、阿波罗都是依赖长轮询机制。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154238-1313327716.webp" alt="nacos长轮询" loading="lazy"></p>
<blockquote>
<p>客户端发起请求后，Nacos 服务端不会立即返回请求结果，而是将请求挂起等待一段时间，如果此段时间内服务端数据变更，立即响应客户端请求，若是一直无变化则等到指定的超时时间后响应请求，客户端重新发起长链接。</p>
</blockquote>
<h1 id="3-websocket">3 WebSocket</h1>
<p>基于 TCP 的全双工协议，通过 HTTP 升级握手（<strong><code>Upgrade: websocket</code></strong>）建立持久连接，<strong>双向实时通信。</strong><br>
<img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154381-1256522159.png" alt="image.png" loading="lazy"></p>
<ul>
<li><strong>优点</strong>：最低延迟，支持双向交互，节省带宽</li>
<li><strong>缺点</strong>：实现复杂，需单独处理连接状态</li>
<li><strong>延迟</strong>：极低</li>
<li><strong>适用场景</strong>：聊天室、在线游戏、协同编辑等&nbsp;<strong>高实时双向交互</strong>&nbsp;需求</li>
</ul>
<p>笔者曾经服务于北京一家电商公司，参与直播答题功能的研发。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215157970-1447287687.png" alt="" loading="lazy"></p>
<p>直播答题整体架构见下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215156686-144032620.png" alt="" loading="lazy"></p>
<p>Netty TCP 网关的技术选型是：Netty、ProtoBuf、WebSocket ，选择 WebSocket 是因为它支持双向实时通信，同时 Netty 内置了 WebSocket 实现类，工程实现起来相对简单。</p>
<h1 id="4-server-send-eventsse">4 Server Send Event(SSE)</h1>
<p>基于 HTTP 协议，服务器可&nbsp;<strong>主动推送</strong>&nbsp;数据流（如<code>Content-Type: text/event-stream</code>），浏览器通过<code>EventSource</code> API 监听。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154496-404092698.png" alt="" loading="lazy"></p>
<ul>
<li><strong>优点</strong>：原生支持断线重连，轻量级（HTTP协议）</li>
<li><strong>缺点</strong>：不支持浏览器向服务器发送数据</li>
<li><strong>延迟</strong>：低（服务器可即时推送）</li>
<li><strong>适用场景</strong>：股票行情、实时日志等&nbsp;<strong>服务器单向推送</strong>&nbsp;需求。</li>
</ul>
<p>SSE 最经典的应用场景是 ： DeepSeek web 聊天界面  ，如图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154497-426594169.png" alt="" loading="lazy"></p>
<p>当在 DeepSeek 对话框发送消息后，浏览器会发送一个 HTTP 请求 ，服务端会通过 SSE 方式将数据返回到浏览器。</p>
<p><img src="https://img2024.cnblogs.com/blog/2487169/202504/2487169-20250423215154478-1103720259.png" alt="" loading="lazy"></p>
<h1 id="5-总结">5 总结</h1>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>短轮询</strong></th>
<th><strong>长轮询</strong></th>
<th><strong>SSE</strong></th>
<th><strong>WebSocket</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通信方向</strong></td>
<td>浏览器→服务器</td>
<td>浏览器→服务器</td>
<td>服务器→浏览器</td>
<td>双向通信</td>
</tr>
<tr>
<td><strong>协议</strong></td>
<td>HTTP</td>
<td>HTTP</td>
<td>HTTP</td>
<td>WebSocket（基于TCP）</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>极高</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>高（频繁请求）</td>
<td>中（挂起连接）</td>
<td>低</td>
<td>低（长连接）</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>：</p>
<ul>
<li>需要&nbsp;<strong>简单兼容性</strong>&nbsp;→ 短轮询</li>
<li>需要&nbsp;<strong>中等实时性</strong>&nbsp;→ 长轮询</li>
<li>只需&nbsp;<strong>服务器推送</strong>&nbsp;→ SSE</li>
<li>需要&nbsp;<strong>全双工实时交互</strong>&nbsp;→ WebSocket</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5508092856273148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-23 21:52">2025-04-23 21:52</span>&nbsp;
<a href="https://www.cnblogs.com/makemylife">勇哥编程游记</a>&nbsp;
阅读(<span id="post_view_count">174</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18843555);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18843555', targetLink: 'https://www.cnblogs.com/makemylife/p/18843555', title: '聊聊四种实时通信技术：长轮询、短轮询、WebSocket 和 SSE' })">举报</a>
</div>
        