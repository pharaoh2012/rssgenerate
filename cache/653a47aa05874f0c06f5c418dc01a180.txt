
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18889814" title="发布于 2025-05-21 22:19">
    <span role="heading" aria-level="2">.NET外挂系列：5. harmony 中补丁参数的有趣玩法（下）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>开局一张表，故事全靠编，为了能够承上启下，先把参数列表放出来。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__instance</code></td>
<td>访问非静态方法的实例（类似 <code>this</code>）。</td>
</tr>
<tr>
<td><code>__result</code></td>
<td>获取/修改返回值，要想修改用 <code>ref</code>。</td>
</tr>
<tr>
<td><code>__resultRef</code></td>
<td>修改返回引用（方法返回是 ref 返回 ）。</td>
</tr>
<tr>
<td><code>__state</code></td>
<td>在前缀和后缀间传递自定义数据 。</td>
</tr>
<tr>
<td><code>___fields</code></td>
<td>读写私有字段（三下划线开头，修改需加 <code>ref</code>）。</td>
</tr>
<tr>
<td><code>__args</code></td>
<td>以 <code>object[]</code> 形式访问所有参数（修改数组即修改参数）。</td>
</tr>
<tr>
<td><code>方法参数同名</code></td>
<td>直接映射原参数。</td>
</tr>
<tr>
<td><code>__n</code></td>
<td><code>__n</code> 表示直接访问第 <code>n</code> 个参数，从 0 开始）。</td>
</tr>
<tr>
<td><code>__originalMethod</code></td>
<td>获取原方法的 <code>MethodBase</code>。</td>
</tr>
<tr>
<td><code>__runOriginal</code></td>
<td>判断原方法是否被执行。</td>
</tr>
</tbody>
</table>
<p>如果说上一篇聊到的参数是无害的，那这篇所聊到的参数就具有破坏性了，会让一些底层方法产生匪夷所思的输出结果。</p>
<h2 id="二补丁参数解读">二：补丁参数解读</h2>
<h3 id="1-__result">1. __result</h3>
<p>这个参数可以获取被注入方法的返回值，你可以对他进行查看和修改，为了让例子更有趣一点，我们对 <code>DateTime.Now</code> 进行注入，让它永远的丢失<code>时分秒</code>，是不是有点像黑客？ 哈哈，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            var harmony = new Harmony("com.example.patch");
            harmony.PatchAll();

            var time = DateTime.Now;

            Console.WriteLine($"当前时间：{time}");

            Console.ReadLine();
        }
    }

    [HarmonyPatch(typeof(DateTime), "Now", MethodType.Getter)]
    public class DateTimeHook
    {
        public static void Postfix(ref DateTime __result)
        {
            __result = __result.Date;
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521221902900-1852983072.png" alt="" loading="lazy"></p>
<p>是不是让人很恼火，明明调的是 <code>DateTime.Now</code> ，怎么时分秒不见了。。。</p>
<h3 id="2-__args">2. __args</h3>
<p>在 harmony 中有三种方式可以获取原方法的参数，分别为：</p>
<ul>
<li>object[] __args 获取，支持读写。</li>
<li>__n  下标获取，支持读写。</li>
<li>parameter 同名法，默认只读，写的话要加 ref。</li>
</ul>
<p>为了让例子更加有趣和黑客，我们对 HttpClient 的底层方法 SendAsync 进行拦截，然后纂改url，指向一个来历不明的网址，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static async Task Main(string[] args)
        {
            // 应用Harmony补丁
            var harmony = new Harmony("com.example.httpclient");
            harmony.PatchAll();

            var url = "https://www.cnblogs.com";

            var httpClient = new HttpClient();
            
            Console.WriteLine($"1.request：{url}");
            var response = await httpClient.GetAsync(url);
            var content = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"2.response:\n{content.Substring(0, 500)}");

            Console.ReadKey();
        }
    }

    [HarmonyPatch(typeof(HttpClient), "SendAsync", new Type[] { typeof(HttpRequestMessage), typeof(HttpCompletionOption), typeof(CancellationToken) })]
    class HttpClientPatch
    {
        static void Prefix(object[] __args)
        {
            HttpRequestMessage request = (HttpRequestMessage)__args[0];

            request.RequestUri = new Uri("http://www.baidu.com");
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521221902906-946063916.png" alt="" loading="lazy"></p>
<p>从卦中看，我明明请求的是 <code>博客园</code>，怎么给我返回 <code>百度</code> 的内容，是不是非常诡异。。。</p>
<p>可能有朋友看到了，这里有一个 <code>(HttpRequestMessage)__args[0];</code> 强转的逻辑，能不能在 <code>Prefix(object[] __args)</code> 中直接接收 HttpRequestMessage 参数呢？可以的，这这就 harmony 的另外一种<code>同名参数法</code>，也就是参数名一定要和底层的 <code>SendAsync</code> 方法签名保持一致，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521221902908-1301683384.png" alt="" loading="lazy"></p>
<p>修改后的代码如下，是不是非常的清爽。</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(HttpClient), "SendAsync", new Type[] { typeof(HttpRequestMessage), typeof(HttpCompletionOption), typeof(CancellationToken) })]
    class HttpClientPatch
    {
        static void Prefix(HttpRequestMessage request)
        {
            request.RequestUri = new Uri("http://www.baidu.com");
        }
    }

</code></pre>
<p>可能有些人会遇到这样的情况，比如 <code>SendAsync</code> 方法的第一个参数是 internel 类型，由于是程序集可访问，所以你无法在另一个程序集的 Prefix 中声明此类型，这时候怎么办呢？可以借助 harmony 提供的 <code>__n</code> 索引法，下标是从0开始的。修改代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(HttpClient), "SendAsync", new Type[] { typeof(HttpRequestMessage), typeof(HttpCompletionOption), typeof(CancellationToken) })]
    class HttpClientPatch
    {
        static void Prefix(object __0)
        {
            Type requestType = __0.GetType();
            PropertyInfo requestUriProperty = requestType.GetProperty("RequestUri");
            Uri newUri = new Uri("http://www.baidu.com");
            requestUriProperty.SetValue(__0, newUri);
        }
    }

</code></pre>
<h3 id="3-___fields">3. ___fields</h3>
<p>这个参数也是一个非常简单粗暴的特性，它可以用三下划线<code>___</code>引出当前 this 实例上的私有字段，使用场景可以是这样的，我们知道 <code>new Thread</code> 默认是没有 <code>ThreadName</code> 的，这在高级调试中往往有所不便，所以可加这样的一段逻辑：一旦发现无名的 <code>ThreadName</code> 就给它赋一个默认的名字，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            var harmony = new Harmony("com.example.patch");
            harmony.PatchAll();

            var thread = new Thread(() =&gt; { });

            thread.Start();

            Console.WriteLine($"1.查看线程名：{thread.Name?.ToString()}");

            Console.ReadLine();
        }
    }

    [HarmonyPatch(typeof(Thread), "Name", MethodType.Getter)]
    public class ThreadStartHook
    {
        public static void Prefix(Thread __instance, ref string ____name)
        {
            if (string.IsNullOrEmpty(____name))
            {
                ____name = $"Default Threadid:{__instance.ManagedThreadId}";
            }
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521221902894-1030390354.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>这篇文章我们聊到的一些参数多多少少都带点黑客性质，建议大家不要乱用，这里声明一下，我所说的一切都是为<code>.NET高级调试训练营</code>服务的，也是给学员们提供的拓展资料。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="13.996370696143519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-21 22:19">2025-05-21 22:19</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">312</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18889814);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18889814', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18889814', title: '.NET外挂系列：5. harmony 中补丁参数的有趣玩法（下）' })">举报</a>
</div>
        