
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18668721" title="发布于 2025-01-16 15:15">
    <span role="heading" aria-level="2">.NET Core GC计划阶段(plan_phase)底层原理浅谈</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>在mark_phase阶段之后，所有对象都被标记为<code>有用/垃圾</code>对象。此时，垃圾回收器已经拥有启动垃圾回收的所有前置准备工作。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250114135548148-699741587.png" alt="image" loading="lazy"></p>
<p>这个时候，垃圾回收期应该执行<span style="color: rgba(255, 0, 0, 1)">"清除回收"</span>还是<span style="color: rgba(255, 0, 0, 1)">"压缩回收"</span>呢？只有做一下试验才能得出理论支撑。</p>
<h1 id="模拟压缩">模拟压缩</h1>
<p>这里会有一个悖论，如果你要知道压缩是否划得来，那你就得先压缩后查看其结果，才知道压缩的成本。<br>
CLR团队如何解决这个问题呢？plan_phase阶段会计算与压缩过程相关的所有信息，而这些信息是以<code>旁敲侧击</code>的方式计算，并没有实际移动对象。这样我们就能从侧面知道压缩的结果</p>
<h2 id="插头plug间隙gap">插头(plug)/间隙(gap)</h2>
<p>模拟压缩阶段，CLR会将托管堆上的对象分为有空(plug)和没用(gap)两块，也就是所谓的插头和间隙.<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250114141646560-791352266.png" alt="image" loading="lazy"></p>
<p>通过将托管堆拆分成plug与gap，我们可以轻松计算出其重要信息</p>
<ol>
<li>每个gap的大小和位置都会被记住,如果最终是清除回收，那么大多数gap都将成为Free的可用空间。</li>
<li>每个plug的位置与偏移量都会被记住，如果最终选择了压缩回收，则会使用重定位偏移量来移动plug</li>
</ol>
<h2 id="重排plug">重排plug</h2>
<p>计划阶段在重排 Plug 区块时，内部使用了一个单独分配器，所以此时plug是并没有被移动的.分配器仅将对象指针进行操作，进行模拟。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116103923380-114433671.png" alt="image" loading="lazy"></p>
<ol>
<li>当遇到第一个plug时，分配器会找到根据对象自身的alloc_ptr指针，移动分配器的指针，并记录两个指针之间的偏移量，记为重定位偏移量</li>
<li>遇到下一个plug时，分配器会在上一个分配的基础上，继续分配。直到遇到最后一个plug。</li>
</ol>
<p>这样，所有的重定位偏移量都被计算出来，因此GC可以准确的知道以下信息</p>
<ol>
<li>压缩效率是多少？</li>
<li>如果是清除压缩，在哪里创建Free列表？</li>
<li>如果是压缩回收，plug如何移动？</li>
</ol>
<h2 id="plug数据结构">plug数据结构</h2>
<p>既然要模拟压缩，那么就意味着有数据结构来承载额外的信息。在 coreclr 源码中有一个叫 gap_reloc_pair 结构体记录Plug的信息。</p>
<blockquote>
<p>gap没有专用的数据结构来存，大家可以思考一下。为什么？</p>
</blockquote>
<ol>
<li>gap<br>
记录着plug前面gap大小</li>
<li>reloc<br>
plug 新地址的相对旧地址的偏移量</li>
<li>m_pair<br>
记录plug左右plug的位置(二叉排序树)</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250114142525382-1184593413.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250114142538775-1817138400.png" alt="image" loading="lazy"></p>
<h2 id="gap_reloc_pair的存储">gap_reloc_pair的存储</h2>
<p>按照常规方案，gap_reloc_pair的存储会在托管堆上单独开辟一段内存区间来存放，但是CLR团队非常巧妙的把gap_reloc_pair放在gap块中，因为gap不再使用，覆盖它是安全的，非常巧妙的设计！</p>
<p>将plug的信息存储在plug之前，这就是为什么<code>即使是一个空对象也必须是24字节的原因</code></p>
<blockquote>
<p>有人可能会问了，内存段的段首，第一个plug前面没有gap怎么办？<br>
实际上，每一代的对象，都是从一个空对象开始的，因此即使是第一个插头，它也是有gap的。</p>
</blockquote>
<h3 id="眼见为实plug前面的gap中存放着gap_reloc_pair">眼见为实：plug前面的gap中存放着gap_reloc_pair</h3>
<p>在bp coreclr!WKS::gc_heap::decide_on_compacting 下断点。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116134222071-179312233.png" alt="image" loading="lazy"></p>
<h3 id="眼见为实第一个plug有一个天然的gap">眼见为实：第一个plug，有一个天然的gap</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116134938671-1099025609.png" alt="image" loading="lazy"></p>
<h1 id="代降级">代降级</h1>
<p>因为pinned对象的存在，导致对象代的提升不是100%的，有可能会不升反降。在执行压缩的场景下，如果pinned对象出现在了一些特别尴尬的位置，GC会考虑给某些pinned对象降代或者不升代</p>
<p>举个例子，如果不存在降代现在，GC堆会发生什么情况<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116142844735-607442785.png" alt="image" loading="lazy"></p>
<p>可以看到，0代段被压缩到很小，导致没分配几次内存又要GC，又会导致STW非常频繁，从而使得程序卡顿，CPU增高，吞吐量降低等现象</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116143123319-2052311842.png" alt="image" loading="lazy"></p>
<p>这个时候，只有选择不升代，或者降代，才能维持好GC代之间的平衡。</p>
<blockquote>
<p>降级是一种优化，确保更多的内存碎片被重用。</p>
</blockquote>
<h2 id="眼见为实">眼见为实</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116144829085-371552715.png" alt="image" loading="lazy"></p>
<p>未GC前，pinned为0代，正常情况下，它会升为1代。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116144843662-415422370.png" alt="image" loading="lazy"></p>
<p>因为该pinned对象非常尴尬的出现在了一大批gap对象之后，如果升代，会导致前面这一片gap对象空间同样被纳入1代的代边界范围，这极大的缩小了0代的代边界。<br>
因此，ClR选择将Pinned对象不升代</p>
<h1 id="番外篇无效结构的内存转储">番外篇：无效结构的内存转储</h1>
<p>有时候，我们在plan_phase阶段，通过!dumpheap 指令查看托管堆的时候，会发现托管堆看不了。提示如下信息<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116145810012-1440633961.png" alt="image" loading="lazy"></p>
<p>还记得之前说过的gap_reloc_pair数据结构吗？它被CLR团队非常巧妙的放在了gap中。<br>
问题就在于此，如果你的dump正好在plan_phase执行过程中，因为gap上的原始内容被gap_reloc_pair覆盖，所以此时的托管堆相当于是<code>被破坏状态</code>。因此CLR为了防止你被脏数据误解，直接不让你观察。</p>
<h1 id="决定压缩的诱因">决定压缩的诱因</h1>
<p>在模拟压缩阶段，GC根据会计算出压碎率，碎片大小的，并辅助其它条件。来决定是否执行压缩回收。</p>
<p>其它条件可能是，主动触发，也可能是OOM之前的最后一次Full GC ,或者是临时段空间不足</p>
<p>其核心方法为</p>
<pre><code>BOOL gc_heap::decide_on_compacting (int condemned_gen_number,
                                    size_t fragmentation,
                                    BOOL&amp; should_expand)
</code></pre>
<p>通过返回Bool，来告诉下一阶段应该执行清除回收还是压缩回收</p>
<h2 id="眼见为实-1">眼见为实</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250116151150309-1273770563.png" alt="image" loading="lazy"></p>
<blockquote>
<p><a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/gc/gc.cpp" target="_blank" rel="noopener nofollow">https://github.com/dotnet/runtime/blob/main/src/coreclr/gc/gc.cpp</a></p>
</blockquote>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.3188446560115741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 16:42">2025-01-16 15:15</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">76</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18668721" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18668721);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18668721', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18668721', title: '.NET Core GC计划阶段(plan_phase)底层原理浅谈' })">举报</a>

		</p>
	