
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tongh/p/18815732" title="发布于 2025-04-09 00:09">
    <span role="heading" aria-level="2">KGDB调试Linux内核与模块</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>内核 5.10 版本</p>
<ol>
<li>openEuler 使用 yum install 下载了源码，并且通过两个 VMware 虚拟机进行调试</li>
<li>ubuntu 直接使用 git 拉取了<a href="https://kernel.org/" target="_blank" rel="noopener nofollow">https://kernel.org/</a>下 5.10.235 分支的代码，物理主机作为开发机，通过 virtualbox 建立虚拟机作为调试机</li>
</ol>
<h1 id="openeuler2204-sp4">openEuler2204-SP4</h1>
<p>使用两台虚拟机：</p>
<ol>
<li>开发机：使用 gdb 连接调试机进行调试</li>
<li>调试机：编译内核，开启 KGDB ，被调试的机器</li>
</ol>
<h2 id="配置虚拟机">配置虚拟机</h2>
<h2 id="开发机">开发机</h2>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000220493-2106621481.png" alt="" loading="lazy"></p>
<h2 id="调试机">调试机</h2>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000235771-1658403674.png" alt="" loading="lazy"></p>
<p><strong>测试：</strong>在调试机执行 <code>cat /dev/ttyS0</code>阻塞，在开发机执行 <code>echo "hello" &gt; /dev/ttyS0</code>，可以看到调试机测输出 <code>hello</code>，表示串口连通。</p>
<h2 id="调试机配置">调试机配置</h2>
<h3 id="编译内核">编译内核</h3>
<p>在调试机侧下载内核源码：<code>yum install kernel-source.x86_64</code>，在目录 <code>/usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64</code>下：</p>
<pre><code class="language-bash">#安装yum install
pkg-config
ncurses-devel
openssl-libs
elfutils-libelf-devel
dwarves
openssl-libs
</code></pre>
<pre><code class="language-bash">cd /usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64
make menuconfig
</code></pre>
<p>按照以下截图配置内核：</p>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000303966-1397077475.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000310959-677575180.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000321307-1455553084.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000327994-1524019348.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000334930-2094430922.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000340284-879981572.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000345335-442039143.png" alt="" loading="lazy"></p>
<h3 id="问题">问题</h3>
<ol>
<li>openeuler 安装时会出现:dracut-install: Failed to find module 'virtio_gpu' dracut: FAILED: /usr/lib/dracut/dracut-install -D /var/tmp/dracut.MlDs2I/initramfs --kerneldir /lib/modules/5.10.235-yielde-v1-+/ -m virtio_gpu，需要打开 Virtio GPU driver 支持，如下：<br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000409738-640266493.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000415719-335932454.png" alt="" loading="lazy"></li>
</ol>
<p>配置完成并保存后开始编译内核：</p>
<pre><code class="language-bash">make -j8
</code></pre>
<ul>
<li>-j8：表示使用 8 个 cpu 核共同编译</li>
</ul>
<p>编译完成后检查 vmlinux 是否包含 debug 信息：</p>
<pre><code class="language-bash">[root@yielde-debugging linux-5.10.0-257.0.0.160.oe2203sp4.x86_64]# readelf -e vmlinux|grep debug
  [36] .debug_aranges    PROGBITS         0000000000000000  02e00000
  [37] .debug_info       PROGBITS         0000000000000000  02e2c310
  [38] .debug_abbrev     PROGBITS         0000000000000000  0d7f2b9b
  [39] .debug_line       PROGBITS         0000000000000000  0dcc7ee8
  [40] .debug_frame      PROGBITS         0000000000000000  0f37bcf8
  [41] .debug_str        PROGBITS         0000000000000000  0f64cf48
  [42] .debug_loc        PROGBITS         0000000000000000  0f9adda9
  [43] .debug_ranges     PROGBITS         0000000000000000  12c16be0
</code></pre>
<p>调试机安装内核模块和系统：</p>
<pre><code class="language-bash">make modules_install
make install
</code></pre>
<h3 id="配置-grub">配置 grub</h3>
<p>设置 grub 打开 kgdb，<code>vim /etc/default/grub</code> 在 <code>GRUB_CMDLINE_LINUX</code>的末尾加入 <code>kgdboc=ttyS0,115200 nokaslr</code></p>
<pre><code class="language-bash">GRUB_CMDLINE_LINUX="rhgb quiet crashkernel=auto rd.lvm.lv=VolGroup/lv_root cgroup_disable=files apparmor=0 crashkernel=512M selinux=0 kgdboc=ttyS0,115200 nokaslr"
</code></pre>
<p>更新 grub</p>
<pre><code class="language-bash">grub2-mkconfig -o /boot/grub2/grub.cfg
</code></pre>
<p>复制代码到 开发机</p>
<pre><code class="language-bash">rsync -avh /usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64 root@10.20.41.140:/usr/src
</code></pre>
<p>调试机 reboot，选择我们编译好的内核启动</p>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000429974-1392484859.png" alt="" loading="lazy"></p>
<h3 id="kgdb-debugger">kgdb Debugger</h3>
<p>发起 kgdb 中断，调试机的屏幕卡住，后面通过开发机的 gdb 通过串口连接后接管：</p>
<pre><code class="language-bash">echo g &gt; /proc/sysrq-trigger
</code></pre>
<h2 id="调试">调试</h2>
<h3 id="内核">内核</h3>
<p>在开发机侧：</p>
<pre><code class="language-bash">cd /usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64
</code></pre>
<p>连接调试机，给 vfs_write 函数打断点并执行</p>
<pre><code class="language-bash">gdb vmlinux
(gdb) target remote /dev/ttyS0
(gdb) bt
#0  kgdb_breakpoint () at kernel/debug/debug_core.c:1268
#1  0xffffffff811f5c2e in sysrq_handle_dbg (key=&lt;optimized out&gt;) at kernel/debug/debug_core.c:1008
#2  0xffffffff81b31761 in __handle_sysrq (key=key@entry=103, check_mask=check_mask@entry=false) at drivers/tty/sysrq.c:604
#3  0xffffffff8174776a in write_sysrq_trigger (file=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, count=2, ppos=&lt;optimized out&gt;) at drivers/tty/sysrq.c:1168
#4  0xffffffff81455ce3 in pde_write (ppos=&lt;optimized out&gt;, count=0, buf=&lt;optimized out&gt;, file=0x67, pde=0xffff888448b14540) at fs/proc/inode.c:345
#5  proc_reg_write (file=0x67, buf=0xffff88882fba0710 "", count=0, ppos=0x0 &lt;fixed_percpu_data&gt;) at fs/proc/inode.c:357
#6  0xffffffff813bd5df in vfs_write (file=file@entry=0xffff88844b4b3540, buf=buf@entry=0x564f86210f00 &lt;error: Cannot access memory at address 0x564f86210f00&gt;, count=count@entry=2, pos=pos@entry=0xffffc900039fbef0) at fs/read_write.c:600
#7  0xffffffff813bda67 in ksys_write (fd=&lt;optimized out&gt;, buf=0x564f86210f00 &lt;error: Cannot access memory at address 0x564f86210f00&gt;, count=2) at fs/read_write.c:655
#8  0xffffffff813bdb0a in __do_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/read_write.c:667
#9  __se_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/read_write.c:664
#10 __x64_sys_write (regs=&lt;optimized out&gt;) at fs/read_write.c:664
#11 0xffffffff81b510bd in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc900039fbf58) at arch/x86/entry/common.c:47
#12 0xffffffff81c000df in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:125
#13 0x00007fa5a8d777a0 in ?? ()
#14 0x0000000000000002 in fixed_percpu_data ()
#15 0x00007fa5a8d775a0 in ?? ()
(gdb) b vfs_write
Breakpoint 1 at 0xffffffff813bd500: file fs/read_write.c, line 583.
(gdb) c
Continuing.
[Switching to Thread 7142]

Thread 409 hit Breakpoint 1, vfs_write (file=file@entry=0xffff888449e45680, buf=buf@entry=0xc0002f7a93 &lt;error: Cannot access memory at address 0xc0002f7a93&gt;, count=count@entry=1, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:583
583     {
(gdb) l
578             return ret;
579     }
580     EXPORT_SYMBOL(kernel_write);
581
582     ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
583     {
584             ssize_t ret;
585
586             if (!(file-&gt;f_mode &amp; FMODE_WRITE))
587                     return -EBADF;
</code></pre>
<h3 id="内核模块">内核模块</h3>
<p>以 bcache 举例，想要调试 bcache 需要将 bcache.ko 导入进来，否则无法获取符号表：</p>
<ol>
<li>在调试机侧</li>
</ol>
<pre><code class="language-bash">modprobe bcache
</code></pre>
<p>获取内存布局：</p>
<pre><code class="language-bash">
[root@yielde-debugging ~]# cat /sys/module/bcache/sections/.text
0xffffffffa0672000
[root@yielde-debugging ~]# cat /sys/module/bcache/sections/.bss
0xffffffffa06a6140
[root@yielde-debugging ~]# cat /sys/module/bcache/sections/.data
0xffffffffa06a05a0
</code></pre>
<p>执行 <code>echo g &gt; /proc/sysrq-trigger</code>再将控制权交给开发机的 gdb</p>
<ol start="2">
<li>在开发机侧加载 bcache 的符号表</li>
</ol>
<pre><code class="language-bash">(gdb) add-symbol-file /usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64/drivers/md/bcache/bcache.ko -s .text 0xffffffffa0672000 -s .bss 0xffffffffa06a6140 -s .data 0xffffffffa06a05a0
add symbol table from file "/usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64/drivers/md/bcache/bcache.ko" at
        .text_addr = 0xffffffffa0672000
        .bss_addr = 0xffffffffa06a6140
        .data_addr = 0xffffffffa06a05a0
(y or n) y
Reading symbols from /usr/src/linux-5.10.0-257.0.0.160.oe2203sp4.x86_64/drivers/md/bcache/bcache.ko...
</code></pre>
<p>给 bcache 的函数打断点，之后继续运行</p>
<pre><code class="language-bash">(gdb) b bcache_write_super
Breakpoint 2 at 0xffffffffa0689390: file drivers/md/bcache/super.c, line 375.
(gdb) c
Continuing.
</code></pre>
<p>在调试机创建 bcache，执行</p>
<pre><code class="language-bash">make-bcache -B /dev/sdc -C /dev/sdb --writeback
</code></pre>
<p>触发我们的断点如下：</p>
<pre><code class="language-bash">[New Thread 10207]
[New Thread 10198]
[New Thread 10201]
[New Thread 10204]
[New Thread 10208]
[New Thread 10209]
[New Thread 10210]
[New Thread 10211]
[New Thread 10212]
[Switching to Thread 10207]

Thread 444 hit Breakpoint 2, bcache_write_super (c=c@entry=0xffff888442d40000) at drivers/md/bcache/super.c:375
375     {
</code></pre>
<p>查看创建 bcache 的调用栈：</p>
<pre><code class="language-bash">(gdb) bt
#0  bcache_write_super (c=c@entry=0xffff888442d40000) at drivers/md/bcache/super.c:375
#1  0xffffffffa068af4a in run_cache_set (c=0xffff888442d40000) at drivers/md/bcache/super.c:2137
#2  0xffffffffa068b927 in register_cache_set (ca=ca@entry=0xffff888105552000) at drivers/md/bcache/super.c:2204
#3  0xffffffffa068ba47 in register_cache (sb=&lt;optimized out&gt;, sb_disk=&lt;optimized out&gt;, bdev=0xffff888441756c80, ca=0xffff888105552000) at drivers/md/bcache/super.c:2401
#4  0xffffffffa068bc72 in register_bcache (k=&lt;optimized out&gt;, attr=0xffffffffa06a07a0 &lt;ksysfs_register&gt;, buffer=&lt;optimized out&gt;, size=9) at drivers/md/bcache/super.c:2656
#5  0xffffffff81609d4f in kobj_attr_store (kobj=0xffff888442d40000, attr=0xffff88844566a080, buf=0xffff888105552000 "", count=0) at lib/kobject.c:864
#6  0xffffffff8146ec3b in sysfs_kf_write (of=&lt;optimized out&gt;, buf=0xffff888105552000 "", count=0, pos=&lt;optimized out&gt;) at fs/sysfs/file.c:139
#7  0xffffffff8146e27c in kernfs_fop_write_iter (iocb=0xffffc900060f7e60, iter=&lt;optimized out&gt;) at fs/kernfs/file.c:296
#8  0xffffffff813baa99 in call_write_iter (iter=0xffff88844566a080, kio=0xffff888442d40000, file=0xffff888440f672c0) at ./include/linux/fs.h:2064
#9  new_sync_write (filp=filp@entry=0xffff888440f672c0, buf=buf@entry=0x5627601532a0 &lt;error: Cannot access memory at address 0x5627601532a0&gt;, len=len@entry=9, ppos=ppos@entry=0xffffc900060f7ef0) at fs/read_write.c:515
#10 0xffffffff813bd6c0 in vfs_write (file=file@entry=0xffff888440f672c0, buf=buf@entry=0x5627601532a0 &lt;error: Cannot access memory at address 0x5627601532a0&gt;, count=count@entry=9, pos=pos@entry=0xffffc900060f7ef0) at fs/read_write.c:602
#11 0xffffffff813bda67 in ksys_write (fd=&lt;optimized out&gt;, buf=0x5627601532a0 &lt;error: Cannot access memory at address 0x5627601532a0&gt;, count=9) at fs/read_write.c:655
#12 0xffffffff813bdb0a in __do_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/read_write.c:667
#13 __se_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at fs/read_write.c:664
#14 __x64_sys_write (regs=&lt;optimized out&gt;) at fs/read_write.c:664
#15 0xffffffff81b510bd in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc900060f7f58) at arch/x86/entry/common.c:47
#16 0xffffffff81c000df in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:125
#17 0x00007f1ea5a5a7a0 in ?? ()
#18 0x0000000000000009 in fixed_percpu_data ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
</code></pre>
<p>单步执行如下：<br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000521770-1554726618.png" alt="" loading="lazy"></p>
<h1 id="ubuntu-22045--lts">Ubuntu 22.04.5  LTS</h1>
<ol>
<li>开发机：使用 gdb 连接调试机进行调试，安装 ubuntu 系统的物理机</li>
<li>调试机：编译内核，开启 KGDB ，被调试的机器，在此物理机上通过 virtualbox 安装的虚拟机</li>
</ol>
<h2 id="配置虚拟机-1">配置虚拟机</h2>
<p>配置串口并设置主机 pip 通信路径为 <code>/tmp/debuglinux</code><br>
<img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000538419-838043042.png" alt="" loading="lazy"></p>
<h2 id="物理机编译内核">物理机编译内核</h2>
<blockquote>
<p>这次通过开发机来编译内核拷贝到调试机上面去</p>
</blockquote>
<p>内核源码地址在 <code>/root/workspace/linux-learn</code>，安装 deb 包如下：</p>
<pre><code class="language-bash"># apt install
gcc
make
perl
flex
bison
pkg-config
libncurses-dev
libelf-devel
build-essential
</code></pre>
<p>开始编译</p>
<pre><code class="language-bash">cd /root/workspace/linux-learn
mkdir build
make mrproper
make O=build defconfig
make O=build menuconfig
</code></pre>
<ul>
<li>配置项与 openEuler 相似，主要是开启 KGDB，关闭内核的的随机地址空间布局(KASLR)，开启 debuginfo</li>
</ul>
<pre><code class="language-bash">make O=build -j8
</code></pre>
<p>将整个内核目录复制到 virtulbox 调试机的相同目录下：</p>
<pre><code class="language-bash">cd /root/workspace
rsync -avzW linux-learn root@192.168.5.20:/root/workspace
</code></pre>
<h2 id="配置调试机">配置调试机</h2>
<h3 id="安装内核">安装内核</h3>
<pre><code class="language-bash">cd /root/workspace/linux-learn
make O=build modules_install
make O=build install
</code></pre>
<h3 id="更新-grub">更新 grub</h3>
<p>当前版本的 ubuntu 使用的 grub，上面的 openEuler 使用的 grub2</p>
<pre><code class="language-bash"># 添加
vim /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="kgdboc=ttyS0,115200 nokaslr"

grub-update
</code></pre>
<p>重启虚拟机，进入编译好的系统如下图</p>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000553191-941572246.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1480358/202504/1480358-20250409000559077-1655162994.png" alt="" loading="lazy"></p>
<h3 id="kgdb-debugger-1">kgdb Debugger</h3>
<ol>
<li>调试机执行<code>echo g &gt; /proc/sysrq-trigger</code>将控制交给 gdb</li>
<li>开发机即主机执行:</li>
</ol>
<pre><code class="language-bash">cd /root/workspace/linux-learn/build
target remote /tmp/debuglinux
</code></pre>
<p>尝试断点：</p>
<pre><code class="language-bash">(gdb) b vfs_write
Breakpoint 1 at 0xffffffff811c34cf: file ../fs/read_write.c, line 586.
(gdb) c
Continuing.
[Switching to Thread 377]

Thread 78 hit Breakpoint 1, vfs_write (file=file@entry=0xffff888101ddf800, buf=0x7ffe9e60766f &lt;error: Cannot access memory at address 0x7ffe9e60766f&gt;, count=count@entry=1, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at ../fs/read_write.c:586
586	{

(gdb) bt
#0  vfs_write (file=file@entry=0xffff888101ddf800, buf=0x7ffe9e60766f &lt;error: Cannot access memory at address 0x7ffe9e60766f&gt;, 
    count=count@entry=1, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at ../fs/read_write.c:586
#1  0xffffffff811c3786 in ksys_write (fd=&lt;optimized out&gt;, buf=0x7ffe9e60766f &lt;error: Cannot access memory at address 0x7ffe9e60766f&gt;, 
    count=1) at ../fs/read_write.c:658
#2  0xffffffff811c37eb in __do_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at ../fs/read_write.c:670
#3  __se_sys_write (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, fd=&lt;optimized out&gt;) at ../fs/read_write.c:667
#4  __x64_sys_write (regs=&lt;optimized out&gt;) at ../fs/read_write.c:667
#5  0xffffffff81a1a921 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc90000407f58) at ../arch/x86/entry/common.c:46
#6  0xffffffff81c0011f in entry_SYSCALL_64 () at ../arch/x86/entry/entry_64.S:117
#7  0x00005610590964e5 in ?? ()
#8  0x0000561091a5ac50 in ?? ()
#9  0x00007f6214955a60 in ?? ()

</code></pre>
<h1 id="总结">总结</h1>
<p>本文主要汇总了下近期调试内核与内核模块的配置方式。</p>
<ol>
<li>使用两台虚拟机通信，一台启动 gdb，另一台启动 kgdb</li>
<li>物理机本身为 linux 系统启动 gdb，使用虚拟机启动 kgdb</li>
<li>建议每次修改代码重新编译内核后同步到两个系统的相同的目录下，可以省去很多麻烦</li>
</ol>

</div>
<div id="MySignature" role="contentinfo">
    <h3>望各位大佬指出错误！</h3>
<h3><a href="https://www.cnblogs.com/tongh/">不断学习更新，转载请注明出处</a></h3>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0068651942141203705" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-09 00:10">2025-04-09 00:09</span>&nbsp;
<a href="https://www.cnblogs.com/tongh">yielde</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18815732" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18815732);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18815732', targetLink: 'https://www.cnblogs.com/tongh/p/18815732', title: 'KGDB调试Linux内核与模块' })">举报</a>
</div>
        