
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/abinzhao/p/18910353" title="发布于 2025-06-04 15:40">
    <span role="heading" aria-level="2">HarmonyOS 实战：给笔记应用加防截图水印</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>最近在做笔记类应用时，遇到一个头疼的需求：防止用户内容被非法截图传播。思来想去，加水印是个直接有效的方案。研究了 HarmonyOS 的开发文档后，发现用 Canvas 配合布局组件能轻松实现动态水印效果。今天就来聊聊如何给笔记页面加上「会呼吸」的用户专属水印，顺便分享几个开发时踩过的坑。</p>
<h2 id="一需求拆解什么样的水印防截图最有效">一、需求拆解：什么样的水印防截图最有效？</h2>
<p>我们的目标很明确：在笔记浏览页面覆盖一层半透明水印，内容包含<strong>用户 ID+实时时间戳</strong>，且满足以下条件：</p>
<ul>
<li><strong>斜向排列</strong>：防止截图后通过简单裁剪去除</li>
<li><strong>动态更新</strong>：每分钟刷新时间戳，增加追踪难度</li>
<li><strong>性能无感</strong>：不影响页面滑动和交互</li>
<li><strong>全局覆盖</strong>：适配不同屏幕尺寸和旋转方向</li>
</ul>
<h2 id="二核心实现用canvas实现动态水印">二、核心实现：用canvas实现动态水印</h2>
<h3 id="1-搭建水印组件骨架">1. 搭建水印组件骨架</h3>
<p>首先封装一个 <code>UserWatermark</code> 组件，基于 HarmonyOS 的 Canvas 实现自绘。这里有个关键细节：通过 <code>hitTestBehavior</code> 设置水印层透明，避免阻挡用户点击笔记内容。</p>
<pre><code class="language-typescript">// components/Watermark.ets
@Component
export struct UserWatermark {
  @State userId = 'user001' // 从账号服务获取的动态用户ID
  private context = new CanvasRenderingContext2D(new RenderingContextSettings(true))
  private timestamp = new Date().toLocaleString() // 实时时间戳

  build() {
    Canvas(this.context)
      .width('100%')
      .height('100%')
      .hitTestBehavior(HitTestMode.Transparent) // 重点！不影响触摸事件
      .onReady(() =&gt; this.drawWatermark())
  }

  // 初始化绘制
  private drawWatermark() {
    this.updateTimestamp() // 先更新时间
    this.context.clearRect(0, 0, this.context.width, this.context.height)
    this.setWatermarkStyle()
    this.drawWatermarkGrid()
  }
}
</code></pre>
<h3 id="2-动态时间戳实现每分钟刷新一次">2. 动态时间戳实现：每分钟刷新一次</h3>
<p>为了避免高频重绘影响性能，选择每分钟更新一次时间戳。这里用 <code>setInterval</code> 配合状态变量触发重绘：</p>
<pre><code class="language-typescript">// 组件生命周期钩子
aboutToAppear() {
  this.updateTimestamp() // 初始化时间
  setInterval(() =&gt; {
    this.timestamp = new Date().toLocaleString() // 更新时间
    this.drawWatermark() // 触发画布重绘
  }, 60 * 1000) // 每分钟执行一次
}

// 时间格式化方法（可根据需求调整）
private updateTimestamp() {
  const now = new Date()
  this.timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`
}
</code></pre>
<h3 id="3-斜向水印的坐标计算玄学">3. 斜向水印的坐标计算「玄学」</h3>
<p>实现斜向排列的关键是<strong>坐标系旋转和平移</strong>。这里踩过最大的坑是旋转后原点位置的变化，调试了半小时才发现需要将原点移到左下角：</p>
<pre><code class="language-typescript">private drawWatermarkGrid() {
  const text = `用户ID:${this.userId} ${this.timestamp}`
  const font = '14vp sans-serif'
  const angle = -25 * Math.PI / 180 // 倾斜25度

  // 计算文本尺寸
  this.context.font = font
  const { width: textWidth, height: textHeight } = this.context.measureText(text)

  // 坐标系变换：先平移到左下角，再旋转
  this.context.save()
  this.context.translate(0, this.context.height) // 原点移至左下角
  this.context.rotate(angle) // 逆时针旋转25度

  // 计算行列间隔（1.5倍文本尺寸避免重叠）
  const colGap = textWidth * 1.5
  const rowGap = textHeight * 1.5
  const cols = Math.ceil(this.context.width / colGap)
  const rows = Math.ceil(this.context.height / rowGap)

  // 绘制网格
  for (let i = 0; i &lt; cols; i++) {
    for (let j = 0; j &lt; rows; j++) {
      const x = i * colGap
      const y = j * rowGap
      this.context.fillText(text, x, -y) // y轴反转（因为原点在左下角）
    }
  }

  this.context.restore() // 恢复原始坐标系
}
</code></pre>
<h3 id="4-页面集成用-stack-实现水印层覆盖">4. 页面集成：用 Stack 实现水印层覆盖</h3>
<p>将水印组件与笔记内容层叠加，推荐使用 <code>Stack</code> 布局，清晰且性能稳定：</p>
<pre><code class="language-typescript">// pages/NoteDetail.ets
@Entry
@Component
struct NoteDetail {
  private noteContent = '这里是用户的笔记正文...'

  build() {
    Stack() {
      // 笔记内容层
      Column()
        .padding(24)
        .spacing(16)
        .text(this.noteContent)
        .fontSize(16)
        .lineHeight(24)

      // 水印层（覆盖在内容上方）
      UserWatermark()
    }
    .backgroundColor(Color.White)
    .width('100%')
    .height('100%')
  }
}
</code></pre>
<h2 id="三性能优化">三、性能优化</h2>
<ol>
<li>
<p><strong>离屏渲染优化</strong><br>
如果遇到页面卡顿，可以尝试将 <code>Canvas</code> 替换为 <code>OffscreenCanvas</code> 进行离屏绘制，减少主线程压力：</p>
<pre><code class="language-typescript">// 离屏画布版本（适用于复杂场景）
private offscreenCanvas = new OffscreenCanvas()
private offscreenContext = this.offscreenCanvas.getContext('2d')!

// 在draw方法中使用offscreenContext绘制，最后同步到主画布
this.context.drawImage(this.offscreenCanvas, 0, 0)
</code></pre>
</li>
<li>
<p><strong>文本测量缓存</strong><br>
重复计算文本宽度会影响性能，因此将 <code>measureText</code> 的结果缓存：</p>
<pre><code class="language-typescript">private textMetrics: TextMetrics | null = null

private getTextSize(text: string) {
  if (!this.textMetrics || this.textMetrics.text !== text) {
    this.textMetrics = this.context.measureText(text)
  }
  return this.textMetrics
}
</code></pre>
</li>
<li>
<p><strong>触摸事件优化</strong><br>
通过 <code>hitTestBehavior: HitTestMode.Transparent</code> 让水印层完全透明，触摸事件直接穿透到下层内容，不影响用户操作。</p>
</li>
</ol>
<h2 id="四从页面到全场景的水印方案">四、从页面到全场景的水印方案</h2>
<p>如果你的应用需要支持更多场景，还可以参考官方文档中的其他能力：</p>
<ul>
<li><strong>图片水印</strong>：用 <code>OffscreenCanvas</code> 实现本地图片加水印（适合用户保存笔记截图时自动加水印）</li>
<li><strong>PDF 水印</strong>：通过 <code>pdfService</code> 模块给导出的 PDF 文档添加水印（企业需求必备）</li>
<li><strong>动态变色</strong>：根据页面主题切换水印颜色（浅色/深色模式适配）</li>
</ul>
<h2 id="五那些让我半夜睡不着的细节">五、那些让我半夜睡不着的细节</h2>
<ol>
<li>
<p><strong>旋转方向的坑</strong><br>
坐标系默认顺时针旋转，想实现「向左倾斜」需要用负数角度（如 <code>-25度</code>），刚开始用正数导致水印方向搞反。</p>
</li>
<li>
<p><strong>设备适配问题</strong><br>
不同设备的 <code>vp</code> 单位换算有差异，建议统一处理尺寸问题。</p>
</li>
<li>
<p><strong>性能监控</strong><br>
用 DevEco Studio 的「性能调优」工具监控 <code>onReady</code> 和 <code>draw</code> 方法的执行时间，确保单次绘制不超过 16ms（60fps标准）。</p>
</li>
</ol>
<h2 id="六总结水印背后的安全哲学">六、总结：水印背后的安全哲学</h2>
<p>加水印本质是一种「威慑性防护」，它不能完全阻止截图，但能大大增加内容泄露后的追溯成本。在实际开发中，建议结合以下策略：</p>
<ul>
<li><strong>前端水印</strong>：防止非授权截图传播</li>
<li><strong>后端日志</strong>：记录用户操作时间线</li>
<li><strong>数据加密</strong>：敏感内容本地加密存储</li>
</ul>
<p>技术之外，更重要的是平衡用户体验与安全需求——毕竟，没有人喜欢被密密麻麻的水印「包围」。通过透明度调整（建议 <code>opacity: 0.15-0.2</code>）和合理的排列间隔，完全可以做到「水印可见但不干扰阅读」。</p>
<p>如果你在开发中遇到其他有趣的场景，欢迎在评论区交流～ 一起用技术让内容安全更优雅一点～ 💻✨</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/abinzhao/" target="_blank">纯爱掌门人</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/abinzhao/p/18910353" target="_blank">https://www.cnblogs.com/abinzhao/p/18910353</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5242397295150463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-04 15:40">2025-06-04 15:40</span>&nbsp;
<a href="https://www.cnblogs.com/abinzhao">纯爱掌门人</a>&nbsp;
阅读(<span id="post_view_count">104</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18910353);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18910353', targetLink: 'https://www.cnblogs.com/abinzhao/p/18910353', title: 'HarmonyOS 实战：给笔记应用加防截图水印' })">举报</a>
</div>
	