
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19052133" title="发布于 2025-08-22 10:01">
    <span role="heading" aria-level="2">【渲染流水线】[逐片元阶段]-[模版测试]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250822100603425-59860274.png" alt="【渲染流水线】[逐片元阶段]-[模版测试]以UnityURP为例" class="desc_img">
        本文介绍了Unity URP中模板缓冲区的使用，通过8位整数/像素实现精确像素控制。详细解析了模板测试流程：包括缓冲区初始化、测试阶段比较函数（如Always、Equal等）和缓冲操作（如Replace、Incr等）。提供了两个实用案例：1）使用模板缓冲区实现区域遮罩效果；2）实现角色外轮廓描边效果，其中第二个案例展示了如何通过双Pass（角色渲染+轮廓扩展）配合模板测试实现专业级描边效果。文章采用Shader代码和注释结合的方式，清晰呈现了URP管线中模板缓冲的技术实现细节。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>用于精确控制像素丢弃的逐片元操作，通过模板缓冲区（8位整数/像素）实现复杂遮罩效果。</li>
<li>支持8种比较函数和6种缓冲操作‌</li>
<li>当前模版操作，只能在Shader文件中书写操作，ShaderGraph中无法直接使用模版指令。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="核心配置预览">核心配置预览</h1>
<ul>
<li>核心配置所有配置列出（非全必要）：</li>
</ul>
<pre><code class="language-c">Stencil {
    Ref 2 // 必要模版数值
    ReadMask 255
    WriteMask 255
    Comp Greater // 必要比较操作符
    Pass Replace // 必要通过后的操作
    Fail Keep
    ZFail DecrSat
}
</code></pre>
<h2 id="1-核心配置命令">‌<strong>1. 核心配置命令</strong>‌</h2>
<ul>
<li><code>Ref</code>：设置参考值(0-255整数)，用于与模板缓冲区比较</li>
<li><code>ReadMask</code>：读取掩码(0-255)，按位与操作后比较（默认255）</li>
<li><code>WriteMask</code>：写入掩码(0-255)，控制可修改的缓冲区位（默认255）</li>
</ul>
<h2 id="2-比较函数命令">‌<strong>2. 比较函数命令</strong>‌</h2>
<p><code>Comp</code>支持以下枚举值：</p>
<ul>
<li><code>Always</code>/<code>Never</code>：始终通过/拒绝</li>
<li><code>Less</code>/<code>Greater</code>：小于/大于时通过</li>
<li><code>Equal</code>/<code>NotEqual</code>：等于/不等于时通过</li>
<li><code>LessEqual</code>/<code>GreaterEqual</code>：小于等于/大于等于时通过</li>
</ul>
<h2 id="3-操作命令">‌<strong>3. 操作命令</strong>‌</h2>
<p><code>Pass</code>/<code>Fail</code>/<code>ZFail</code>支持的操作：</p>
<ul>
<li><code>Keep</code>：保持原值</li>
<li><code>Zero</code>：置零</li>
<li><code>Replace</code>：用Ref值替换</li>
<li><code>IncrSat</code>/<code>DecrSat</code>：饱和增减（0/255边界）</li>
<li><code>IncrWrap</code>/<code>DecrWrap</code>：循环增减</li>
<li><code>Invert</code>：按位取反</li>
</ul>
<h1 id="模板测试具体过程"><strong>模板测试具体过程‌</strong></h1>
<ol>
<li>
<p>‌<strong>缓冲区初始化</strong>‌</p>
<ul>
<li>清除模板缓冲：<code>GL.Clear(ClearBufferMask.StencilBufferBit)</code></li>
<li>设置初始值：<code>GL.StencilMask(0xFF)</code>（默认全255）</li>
</ul>
</li>
<li>
<p>‌<strong>测试阶段-逐片元</strong>‌</p>
<pre><code class="language-c">plaintext
if (片元模板值 [比较函数] 参考值) {
    执行通过操作（如保留像素）
} else {
    执行失败操作（如丢弃像素）
}
</code></pre>
</li>
<li>
<p>‌<strong>缓冲更新</strong>‌</p>
<ul>
<li>根据测试结果修改模板缓冲值（可选）</li>
</ul>
</li>
</ol>
<h1 id="比较函数stencilfunc"><strong>‌比较函数（StencilFunc）‌</strong></h1>
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
<th>OpenGL常量</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Never</code></td>
<td>永远不通过</td>
<td><code>GL_NEVER</code></td>
</tr>
<tr>
<td><code>Always</code></td>
<td>永远通过</td>
<td><code>GL_ALWAYS</code></td>
</tr>
<tr>
<td><code>Less</code></td>
<td>模板值 &lt; 参考值</td>
<td><code>GL_LESS</code></td>
</tr>
<tr>
<td><code>LEqual</code></td>
<td>模板值 ≤ 参考值</td>
<td><code>GL_LEQUAL</code></td>
</tr>
<tr>
<td><code>Greater</code></td>
<td>模板值 &gt; 参考值</td>
<td><code>GL_GREATER</code></td>
</tr>
<tr>
<td><code>GEqual</code></td>
<td>模板值 ≥ 参考值</td>
<td><code>GL_GEQUAL</code></td>
</tr>
<tr>
<td><code>Equal</code></td>
<td>模板值 == 参考值</td>
<td><code>GL_EQUAL</code></td>
</tr>
<tr>
<td><code>NotEqual</code></td>
<td>模板值 != 参考值</td>
<td><code>GL_NOTEQUAL</code></td>
</tr>
</tbody>
</table>
<h1 id="缓冲操作stencilop"><strong>‌缓冲操作（StencilOp）‌</strong></h1>
<table>
<thead>
<tr>
<th>操作组合</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Keep</code></td>
<td>保持当前模板值不变（默认）</td>
</tr>
<tr>
<td><code>Zero</code></td>
<td>将模板值设为0</td>
</tr>
<tr>
<td><code>Replace</code></td>
<td>用参考值替换模板值</td>
</tr>
<tr>
<td><code>Incr</code>/<code>IncrWrap</code></td>
<td>模板值+1（超过255时，前者截断后者循环）</td>
</tr>
<tr>
<td><code>Decr</code>/<code>DecrWrap</code></td>
<td>模板值-1（低于0时，前者截断后者循环）</td>
</tr>
<tr>
<td><code>Invert</code></td>
<td>按位取反（~操作）</td>
</tr>
</tbody>
</table>
<h1 id="示例1">示例1</h1>
<ul>
<li>遮罩区域shader</li>
</ul>
<pre><code class="language-c">Shader "Custom/StencilMask" {
    SubShader {
        Tags { "Queue"="Geometry-1" } // 优先渲染
        ColorMask 0 // 不写入颜色
        ZWrite Off

        Stencil {
            Ref 1
            Comp Always
            Pass Replace // 将模板值设为1
        }
        Pass {} // 空Pass仅用于写入模板
    }
}
</code></pre>
<ul>
<li>物体模版测试shader，该Shader仅在模板值为1的区域内渲染物体。</li>
</ul>
<pre><code class="language-c">Shader "Custom/StencilObject" {
    SubShader {
        Stencil {
            Ref 1
            Comp Equal // 仅渲染模板值=1的区域
            Pass Keep
        }
        Pass {
            // 正常着色代码...
        }
    }
}
</code></pre>
<h1 id="示例2-外轮廓描边">示例2 外轮廓描边</h1>
<pre><code class="language-c">Shader "Custom/StencilOutline" {
    Properties {
        _MainTex ("Base Texture", 2D) = "white" {}
        _OutlineColor ("Outline Color", Color) = (1,0,0,1)
        _OutlineWidth ("Outline Width", Range(0, 0.1)) = 0.05
    }

    SubShader {
        Tags { 
            "RenderPipeline"="UniversalRenderPipeline"
            "RenderType"="Opaque"
        }

        // Pass 1: 正常渲染角色并写入模板
        Pass {
            Name "Character"
            Tags
            {
                "LightMode" = "UniversalForward"
            } 
            Stencil {
                Ref 1
                Comp Always
                Pass Replace
                ZFail Keep
            }

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct Varyings {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);

            Varyings vert(Attributes IN) {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = IN.uv;
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
            }
            ENDHLSL
        }

        // Pass 2: 渲染轮廓
        Pass {
            Name "Outline"
            Cull Front
            Stencil {
                Ref 1
                Comp NotEqual
                Pass Keep
            }

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
            };

            struct Varyings {
                float4 positionCS : SV_POSITION;
            };

            CBUFFER_START(UnityPerMaterial)
                float4 _OutlineColor;
                float _OutlineWidth;
            CBUFFER_END

            Varyings vert(Attributes IN) {
                Varyings OUT;
                float3 posWS = TransformObjectToWorld(IN.positionOS.xyz * (1 + _OutlineWidth));
                float3 normalWS = TransformObjectToWorldNormal(IN.normalOS);
                // posWS += normalWS * _OutlineWidth; // 沿法线方向扩展
                OUT.positionCS = TransformWorldToHClip(posWS);
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                return _OutlineColor;
            }
            ENDHLSL
        }
    }
}
</code></pre>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.003472222222222222" data-date-updated="2025-08-22 10:06">2025-08-22 10:01</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">23</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19052133);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19052133', targetLink: 'https://www.cnblogs.com/SmalBox/p/19052133', title: '【渲染流水线】[逐片元阶段]-[模版测试]以UnityURP为例' })">举报</a>
</div>
        