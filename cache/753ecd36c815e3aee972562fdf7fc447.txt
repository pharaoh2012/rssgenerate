
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ludangxin/p/18655751" title="发布于 2025-01-06 20:29">
    <span role="heading" aria-level="2">Map中经常被忽略但又非常好用的方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<p>map是我们日常开发中常会的集合类之一, 但是我们除了常用的<code>get</code>和<code>put</code>之外,其他的方法好像很少会用到,接下来我们就介绍一下几个经常被忽略但又很好用的方法.</p>
<h2 id="2-quick-start">2. Quick Start</h2>
<h3 id="21-数据准备">2.1 数据准备</h3>
<p>创建一个map对象, 并声明几个用于测试的user对象</p>
<pre><code class="language-java">Map&lt;Integer, User&gt; hashMap = Maps.newHashMap();
User zhangsan = new User(1, "张三");
User lisi = new User(2, "李四");
User zhangtieniu = new User(3, "张铁牛");
</code></pre>
<h3 id="22-重温put">2.2 重温put</h3>
<pre><code class="language-java">// hashmap put (添加/更新元素)
@Test
public void put() {
    User test = hashMap.put(null, null);
    User user = hashMap.put(1, null);
    User user1 = hashMap.put(1, zhangsan);
    User user2 = hashMap.put(1, lisi);
    User user3 = hashMap.put(null, zhangsan);
    User user4 = hashMap.put(null, lisi);
    User user5 = hashMap.get(null);
    log.info("map: {}", hashMap);
    log.info("user: {}, user1: {}, user2: {}, user3: {}, user4: {}, user5: {}", user, user1, user2, user3, user4, user5);
    //map: {null=User(id=2, name=李四), 1=User(id=2, name=李四)}
    //user: null, user1: null, user2: User(id=1, name=张三), user3: null, user4: User(id=1, name=张三), user5: User(id=2, name=李四)
}
</code></pre>
<ol>
<li>key和value可以为null <mark>(hashmap 和 linkedhashmap)</mark></li>
<li>使用null可以正常的覆盖和获取元素</li>
<li>put可以直接新增or覆盖已有的元素</li>
<li>put方法返回对应key的oldValue，如果没有oldValue则返回null</li>
</ol>
<h3 id="23-getordefault">2.3 getOrDefault</h3>
<pre><code class="language-java">// getOrDefault(Object key, V defaultValue) (获取/返回默认值)
@Test
public void getOrDefault() {
    hashMap.put(1, zhangsan);
    hashMap.put(2, null);
    final User user1 = hashMap.get(1);
    final User user2 = hashMap.getOrDefault(2, lisi);
    final User user3 = hashMap.getOrDefault(3, zhangtieniu);
    log.info("map: {}", hashMap);
    //map: {1=User(id=1, name=张三), 2=null}
    log.info("user1: {}, user2: {}, user3: {}", user1, user2, user3);
    //user1: User(id=1, name=张三), user2: null, user3: User(id=3, name=张铁牛)
}
</code></pre>
<ol>
<li>
<p>当map中没有对应的key时, 返回对应的defaultValue</p>
<p><mark>注意: 如果map中存在对应的key, 但是对应的<code>value == null</code>时, 返回的是null, 而不是defaultValue</mark></p>
</li>
</ol>
<p>源码如下:</p>
<pre><code class="language-java">default V getOrDefault(Object key, V defaultValue) {
    V v;
    return (((v = get(key)) != null) || containsKey(key))
        ? v
        : defaultValue;
}
</code></pre>
<h3 id="24-putifabsent">2.4 putIfAbsent</h3>
<pre><code class="language-java">// putIfAbsent(K key, V value) (如果不存在则添加)
@Test
public void putIfAbsent() {
    hashMap.put(1, null);
    User user1 = hashMap.putIfAbsent(1, zhangsan);
    User user2 = hashMap.putIfAbsent(2, lisi);
    User user3 = hashMap.putIfAbsent(2, zhangtieniu);
    log.info("map: {}", hashMap);
    log.info("user1: {}, user2: {}, user3: {}", user1, user2, user3);
    //map: {1=User(id=1, name=张三), 2=User(id=2, name=李四)}
    //user1: null, user2: null, user3: User(id=2, name=李四)
}
</code></pre>
<ol>
<li>如果指定的key对应的value不为null时(<code>oldValue != null</code>) : 不覆盖 &amp; 返回oldValue</li>
<li>当指定key的value不存在时(<code>oldValue == null</code>) : 添加元素 &amp; 返回oldValue</li>
</ol>
<blockquote>
<p>可以理解为 当指定key的value不存在时, 才去put, 否则不添加</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">default V putIfAbsent(K key, V value) {
    V v = get(key);
    if (v == null) {
        v = put(key, value);
    }

    return v;
}
</code></pre>
<h3 id="25-compute">2.5 compute</h3>
<pre><code class="language-java">// compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) (计算)
@Test
public void compute() {
    hashMap.put(1, zhangsan);
    User user1 = hashMap.compute(1, (k, oldValue) -&gt; lisi);
    log.info("map: {}, user1: {}", hashMap, user1);
    //map: {1=User(id=2, name=李四)}, user1: User(id=2, name=李四)
    User user2 = hashMap.compute(1, (k, oldValue) -&gt; null);
    log.info("map: {}, user2: {}", hashMap, user2);
    //map: {}, user2: null
}
</code></pre>
<ol>
<li><code>remappingFunction返回值 != null</code> : 覆盖oldValue &amp; 返回newValue</li>
<li><code>remappingFunction返回值 == null</code> : 删除对应元素 &amp; 返回null</li>
</ol>
<blockquote>
<p>可以理解为 使用remappingFunction的返回值覆盖对应key的旧值, 当remappingFunction返回值为null时, 会直接将当前元素移除掉</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">default V compute(K key,
        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    V oldValue = get(key);

    V newValue = remappingFunction.apply(key, oldValue);
    if (newValue == null) {
        // delete mapping
        if (oldValue != null || containsKey(key)) {
            // something to remove
            remove(key);
            return null;
        } else {
            // nothing to do. Leave things as they were.
            return null;
        }
    } else {
        // add or replace old mapping
        put(key, newValue);
        return newValue;
    }
}
</code></pre>
<h3 id="26-computeifabsent">2.6 computeIfAbsent</h3>
<pre><code class="language-java">// computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) (不存在则计算)
@Test
public void computeIfAbsent() {
    User user = hashMap.computeIfAbsent(1, k -&gt; zhangsan);
    User user1 = hashMap.computeIfAbsent(1, k -&gt; lisi);
    User user2 = hashMap.computeIfAbsent(2, k -&gt; null);
    log.info("map: {}, user：{}, user1: {}, user2:{}", hashMap, user, user1, user2);
    //map: {1=User(id=1, name=张三)}, user：User(id=1, name=张三), user1: User(id=1, name=张三), user2:null
}
</code></pre>
<ol>
<li><code>oldValue != null</code> : 不覆盖 &amp; 返回oldValue</li>
<li><code>oldValue == null &amp;&amp; mappingFunction返回值 != null</code>: 添加元素 &amp; 返回newValue</li>
<li><code>oldValue == null &amp;&amp; mappingFunction返回值 == null</code>: 不覆盖 &amp; 返回null</li>
</ol>
<blockquote>
<p>可以理解为 当指定key的value不存在时, 才使用mappingFunction的返回值覆盖对应key的旧值, 如果key对应value存在或者mappingFunction的返回值为null时, 则不覆盖</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">default V computeIfAbsent(K key,
        Function&lt;? super K, ? extends V&gt; mappingFunction) {
    Objects.requireNonNull(mappingFunction);
    V v;
    if ((v = get(key)) == null) {
        V newValue;
        if ((newValue = mappingFunction.apply(key)) != null) {
            put(key, newValue);
            return newValue;
        }
    }

    return v;
}
</code></pre>
<h3 id="27-computeifpresent">2.7 computeIfPresent</h3>
<pre><code class="language-java">// computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) (存在则计算)
@Test
public void computeIfPresent() {
    hashMap.put(1, zhangsan);
    User user1 = hashMap.computeIfPresent(1, (k,oldValue) -&gt; lisi);
    User user2 = hashMap.computeIfPresent(3, (k,oldValue) -&gt; zhangtieniu);
    log.info("map: {}, user1: {}， user2: {}", hashMap, user1, user2);
    //map: {1=User(id=2, name=李四)}, user1: User(id=2, name=李四)， user2: null
    User user3 = hashMap.computeIfPresent(1, (k,oldValue) -&gt; null);
    log.info("map: {}, user3:{}", hashMap, user3);
    //map: {}, user3:null
}
</code></pre>
<ol>
<li><code>oldValue == null</code> : 不覆盖&amp;返回null</li>
<li><code>oldValue != null &amp;&amp; remappingFunction返回值 == null</code> : 移除元素&amp;返回null</li>
<li><code>oldValue != null &amp;&amp; remappingFunction返回值 != null</code> : 覆盖元素&amp;返回newValue</li>
</ol>
<blockquote>
<p>可以理解为 当key对应的value存在时, 才使用remappingFunction的返回值覆盖对应key的旧值, 如果key对应的value不存在或者remappingFunction的返回值为null时, 则不覆盖</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">default V computeIfPresent(K key,
        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    V oldValue;
    if ((oldValue = get(key)) != null) {
        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue != null) {
            put(key, newValue);
            return newValue;
        } else {
            remove(key);
            return null;
        }
    } else {
        return null;
    }
}
</code></pre>
<h3 id="28-replace">2.8 replace</h3>
<pre><code class="language-java">// replace(K key, V value)
// replace(K key, V oldValue, V newValue) (替换)
@Test
public void replace() {
    hashMap.put(1, zhangsan);
    hashMap.put(2, lisi);
    hashMap.replace(1, zhangtieniu);
    hashMap.replace(2, null);
    hashMap.replace(3, zhangtieniu);
    hashMap.replace(2, null, zhangtieniu);
    log.info("map: {}", hashMap);
    //map: {1=User(id=3, name=张铁牛), 2=User(id=3, name=张铁牛)}
}
</code></pre>
<ol>
<li>替换指定key的value值</li>
<li>可以将对应的value设置为null</li>
<li>对应的key不存在时不会添加新元素</li>
<li><code>replace(K key, V oldValue, V newValue)</code>方法多了一层判断, 当key对应的value与oldValue相等时, 才会替换newValue</li>
</ol>
<blockquote>
<p>可以理解为 替换指定key的value值</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">default V replace(K key, V value) {
    V curValue;
    if (((curValue = get(key)) != null) || containsKey(key)) {
        curValue = put(key, value);
    }
    return curValue;
}

default boolean replace(K key, V oldValue, V newValue) {
    Object curValue = get(key);
    if (!Objects.equals(curValue, oldValue) ||
        (curValue == null &amp;&amp; !containsKey(key))) {
        return false;
    }
    put(key, newValue);
    return true;
}
</code></pre>
<h3 id="29-merge">2.9 merge</h3>
<pre><code class="language-java">// merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) (融合)
@Test
public void merge() {
    hashMap.put(1, zhangsan);
    User user1 = hashMap.merge(1, lisi, (oldValue, defaultValue) -&gt; zhangtieniu);
    User user2 = hashMap.merge(2, lisi, (oldValue, defaultValue) -&gt; zhangtieniu);
    log.info("map: {}, user1: {}， user2: {}", hashMap, user1, user2);
    //map: {1=User(id=3, name=张铁牛), 2=User(id=2, name=李四)}, user1: User(id=3, name=张铁牛)， user2: User(id=2, name=李四)
}
</code></pre>
<ol>
<li>
<p><code>oldValue == null</code> : 使用传进来的 value 作为newValue, <code>oldValue != null</code>  : 使用remappingFunction的返回值作为newValue</p>
<ul>
<li>
<p><code>newValue == null</code> : 移除元素 &amp; 返回newValue</p>
</li>
<li>
<p><code>newValue != null</code> : 覆盖元素 &amp; 返回newValue</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>可以理解为 融合三个值 分别为:</p>
<ol>
<li>key对应的value(oldValue)</li>
<li>merge方法的第二个参数value (可以理解为oldValue的defaultValue)</li>
<li>merge方法的第三个参数remappingFunction方法的返回值</li>
</ol>
<p>融合逻辑为:  如果key对应的value不存在时, 使用merge方法的第二个参数value作为newValue, 如果key对应的value存在时,使用remappingFunction的返回值作为newValue, 如果newValue不为null则覆盖元素, 为null则移除元素</p>
</blockquote>
<p>源码如下:</p>
<pre><code class="language-java">    default V merge(K key, V value,
            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                   remappingFunction.apply(oldValue, value);
        if(newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
}
</code></pre>
<h3 id="210-foreach">2.10 foreach</h3>
<pre><code class="language-java">// foreach java8 新增
@Test
public void foreach() {
    hashMap.put(1, zhangsan);
    hashMap.put(2, lisi);
    hashMap.forEach((key, value) -&gt; log.info("key: {}, value: {}", key, value));
    //key: 1, value: User(id=1, name=张三)
    //key: 2, value: User(id=2, name=李四)
}
</code></pre>
<h2 id="3-总结">3. 总结</h2>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法参数</th>
<th>方法描述</th>
<th>方法特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>put</td>
<td>key, value</td>
<td>添加元素</td>
<td>hashmap/linkedhashmap: key, value 都可以为null</td>
</tr>
<tr>
<td>getOrDefault</td>
<td>key, defaultValue</td>
<td>获取元素</td>
<td>当map中没有对应的key时, 返回defaultValue</td>
</tr>
<tr>
<td>putIfAbsent</td>
<td>key, value</td>
<td>当不存在时添加元素</td>
<td>这里不存在指的是: key对应的旧值为null</td>
</tr>
<tr>
<td>compute</td>
<td>key, BiFunction&lt;key, oldValue, newValue&gt; remappingFunction</td>
<td>重新计算key对应的value</td>
<td>使用remappingFunction的返回值替换key的旧值</td>
</tr>
<tr>
<td>computeIfAbsent</td>
<td>key, Function&lt;key, value&gt; mappingFunction</td>
<td>当不存在时计算</td>
<td>这里不存在指的是:  key对应的旧值为null, 与putIfAbsent方法逻辑类似</td>
</tr>
<tr>
<td>computeIfPresent</td>
<td>key, BiFunction&lt;key, oldValue, newValue&gt; remappingFunction</td>
<td>当存在时计算</td>
<td>这里存在指的是: key对应的旧值!=null</td>
</tr>
<tr>
<td>replace</td>
<td>key, value</td>
<td>替换元素</td>
<td>替换指定key的value, 不会添加元素</td>
</tr>
<tr>
<td>merge</td>
<td>key, value, BiFunction&lt;oldValue, value, newValue&gt; remappingFunction</td>
<td>融合</td>
<td>融合key的旧值, 默认值, remappingFunction的返回值作为新值</td>
</tr>
<tr>
<td>foreach</td>
<td>BiConsumer&lt;key, value&gt;</td>
<td>遍历</td>
<td>java8新加的遍历方式</td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.719749429744213" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 21:05">2025-01-06 20:29</span>&nbsp;
<a href="https://www.cnblogs.com/ludangxin">张铁牛</a>&nbsp;
阅读(<span id="post_view_count">67</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18655751" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18655751);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18655751', targetLink: 'https://www.cnblogs.com/ludangxin/p/18655751', title: 'Map中经常被忽略但又非常好用的方法' })">举报</a>
</div>
        