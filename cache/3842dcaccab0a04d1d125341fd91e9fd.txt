
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dongxb/p/18906169" title="发布于 2025-06-01 15:27">
    <span role="heading" aria-level="2">X-MACRO使用技巧</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>　</p>
<p>最近遇到一个问题，需要将分区表硬编码在代码，第一反应可能是定义个数组，数组内容包括分区名称和分区大小。</p>
<p>类似于这种：</p>
<pre><code class="language-C">struct Partition {
    const char *name;
    int max_size;
};
static const struct Partition partitions[] = {
    {"partition_a", 0x12345},
    {"partition_b", 0x12345},
    // ...
};
</code></pre>
<p>但在设备启动时，每加载一个分区时都要获取分区大小。如果有16个分区就需要遍历该数组16 * 16 = 256次。会浪费不少时间在这上面。 　　因此，考虑到对设备启动时间的影响，需要找一种其他办法来解决这个问题。</p>
<h2 id="什么是xmacro">什么是xmacro</h2>
<p>　　<strong>X-MACRO</strong>是一种可靠维护代码或数据的并行列表的技术，其相应项必须以相同的顺序出现。它们在至少某些列表无法通过索引组成的地方（例如编译时）最有用。此类列表的示例尤其包括数组的初始化，枚举常量和函数原型的声明，语句序列的生成等。<strong>X-MACRO</strong>的使用可以追溯到1960年代。它在现代C和C ++编程语言中仍然有用。</p>
<p>　　<strong>X-MACRO</strong>应用程序包括两部分：</p>
<ol>
<li>列表元素的定义。</li>
<li>扩展列表以生成声明或语句的片段。</li>
</ol>
<p>　　该列表由一个宏或头文件（名为LIST）定义，该文件本身不生成任何代码，而仅由一系列调用宏（通常称为“ X”）与元素的数据组成。LIST的每个扩展都在X定义之前加上一个list元素的语法。LIST的调用会为列表中的每个元素扩展X。</p>
<p>　　X-MACRO核心思想有两点：</p>
<ol>
<li><strong>数据与代码分离</strong>：将数据定义（如字段、枚举值等）集中在一个地方。</li>
<li><strong>多次展开</strong>：通过宏的不同定义，将同一份数据生成不同的代码（如枚举、字符串数组、序列化代码等）。</li>
</ol>
<h2 id="用法介绍">用法介绍</h2>
<p>　　首先我们介绍一下<code>#define</code>与<code>#undef</code>的用法:</p>
<pre><code class="language-c">#define X_MACRO(a, b)   a
#undef X_MACRO
#define X_MACRO(a, b)   b
#undef X_MACRO
</code></pre>
<p>　　<strong>示例：</strong></p>
<pre><code class="language-c">#define X_MACRO(a, b)   a
int x = X_MACRO(10, 100)
#undef X_MACRO

#define X_MACRO(a, b)   b
int y = X_MACRO(10, 100)
#undef X_MACRO
</code></pre>
<p>　　<code>#undef</code>可以取消定义宏，然后再通过<code>#define</code>重新定义宏，此时得到的<code>x</code>，<code>y</code>的值分别是<code>10</code>和<code>100</code></p>
<hr>
<p>　　<code>X-Macro</code>其实就是通过<code>#define</code>与<code>#undef</code>实现的一种宏定义的技巧；</p>
<p>　　首先我们可以定义出这样的宏列表：</p>
<pre><code class="language-c">#define MACROS_TABLE                    \
    X_MACROS(CMD_LED_ON,  led_on)       \
    X_MACROS(CMD_LED_OFF, led_off)      \
</code></pre>
<p>　　当我们需要一个命令列表时可以这样定义：</p>
<pre><code class="language-c">typedef enum
{
    #define X_MACROS(a, b) a,
    MACROS_TABLE
    #undef X_MACROS
    CMD_MAX
}cmd_e;
</code></pre>
<p>　　宏展开后是这样的形式：</p>
<pre><code class="language-C">typedef enum
{
    CMD_LED_ON,
    CMD_LED_OFF,
    CMD_MAX
}cmd_e;
</code></pre>
<hr>
<p>　　如果我们需要一个命令的字符串列表用作log打印时也可以定义这样的列表：</p>
<pre><code class="language-c">const char* cmd_str[] = 
{
    #define X_MACROS(a, b) #a,
    MACROS_TABLE
    #undef X_MACROS
};
</code></pre>
<p>　　宏展开后是这样的形式：</p>
<pre><code class="language-c">const func func_table[] = 
{
    “CMD_LED_ON”，
    “CMD_LED_OFF”，
};
</code></pre>
<hr>
<p>　　当我们需要一个函数列表时可以这样操作：</p>
<pre><code class="language-c">const func func_table[] = 
{
    #define X_MACROS(a, b) b,
    MACROS_TABLE
    #undef X_MACROS
};
</code></pre>
<p>　　宏展开后是这样的形式：</p>
<pre><code class="language-c">const func func_table[] = 
{
    led_on,
    led_off,
};
</code></pre>
<hr>
<p>　　由于函数列表与命令列表都是根据<code>MACROS_TABLE</code>这个宏拓展出来的，是一一对应的，所以我们可以直接使用索引的方式来调用函数：</p>
<pre><code class="language-c">static void cmd_handle(cmd_e cmd)
{
    if(cmd &lt; CMD_MAX)
    {
        func_table[cmd]((void*)cmd_str[cmd]);
    }
}
</code></pre>
<p>　　使用<code>X-MACRO</code>对于此类的命令消息处理十分高效简洁，非常实用，且拓展性非常强。</p>
<h2 id="使用x-macro定义分区大小">使用X-MACRO定义分区大小</h2>
<pre><code class="language-C">/**
* Maximum partition size
*/
#define PARTITION_TABLE      \
    PARTITION_MAX_SIZE(partition_a, 123456)    \
    PARTITION_MAX_SIZE(partition_b, 23456)      \
      ............

#define PARTITION_MAX_SIZE(name, size) \
    static const int PART_##name##_SIZE = size;
    PARTITION_TABLE
#undef PARTITION_MAX_SIZE
</code></pre>
<p>　　然后使用get_partition_max_size函数获取分区的大小。</p>
<pre><code class="language-C">int get_partition_max_size(const char *partition_name)
{
    return 0
    #define PARTITION_MAX_SIZE(name, size) +(strcmp(partition_name, #name) ? 0 : PART_##name##_SIZE)
        PARTITION_TABLE
    #undef PARTITION_MAX_SIZE
    ;
}
</code></pre>
<p>　　下面对这函数做详细介绍。</p>
<p>　　以上代码主要分为两部分。第一次定义<code> PARTITION_MAX_SIZE</code> 生成静态常量。第二次在<code>get_partition_max_size</code>函数内重新定义，生成条件判断表达式。</p>
<h3 id="partition_max_size生成静态常量"><code>PARTITION_MAX_SIZE</code>生成静态常量</h3>
<h4 id="1-定义分区表宏-partition_table">1. <strong>定义分区表宏</strong> <strong><code>PARTITION_TABLE</code></strong></h4>
<pre><code class="language-c">#define PARTITION_TABLE      \
    PARTITION_MAX_SIZE(partition_a, 123456)    \
    PARTITION_MAX_SIZE(partition_b, 23456)      \
    // ... 其他分区定义
</code></pre>
<ul>
<li>
<p><strong>作用</strong>：<br>
通过宏 <code>PARTITION_MAX_SIZE</code> 定义多个分区的名称和大小，形成一张分区表。</p>
</li>
<li>
<p><strong>示例内容</strong>：</p>
<ul>
<li><code>partition_a</code> 的大小为 123456 字节。</li>
<li><code>partition_b</code> 的大小为 23456 字节。</li>
<li><code>...</code> 表示可以继续添加更多分区。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2--定义宏-partition_max_size">2 <strong>. 定义宏</strong> <strong><code>PARTITION_MAX_SIZE</code></strong></h4>
<pre><code class="language-c">#define PARTITION_MAX_SIZE(name, size) \
    static const int PART_##name##_SIZE = size;
</code></pre>
<ul>
<li>
<p><strong>作用</strong>：<br>
将 <code>PARTITION_MAX_SIZE(name, size)</code> 转换为静态常量定义，格式为：<br>
<code>static const int PART_&lt;name&gt;_SIZE = size;</code></p>
</li>
<li>
<p><strong>关键符号</strong>：</p>
<ul>
<li><code>##</code>：宏的拼接运算符，将 <code>name</code> 插入到 <code>PART_</code> 和 <code>_SIZE</code> 之间。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：<br>
<code>PARTITION_MAX_SIZE(partition_a, 123456)</code> 展开后：</p>
<pre><code class="language-c">static const int PART_partition_a_SIZE = 123456;
</code></pre>
</li>
</ul>
<hr>
<h4 id="3--展开-partition_table">3 <strong>. 展开</strong> <strong><code>PARTITION_TABLE</code></strong></h4>
<pre><code class="language-c">PARTITION_TABLE
</code></pre>
<ul>
<li>
<p><strong>作用</strong>：<br>
展开 <code>PARTITION_TABLE</code> 宏，实际调用其中所有 <code>PARTITION_MAX_SIZE</code> 宏。</p>
</li>
<li>
<p><strong>展开过程</strong>：</p>
<ol>
<li>根据 <code>PARTITION_TABLE</code> 的定义，展开为多个 <code>PARTITION_MAX_SIZE</code> 调用：</li>
</ol>
<pre><code class="language-c">PARTITION_MAX_SIZE(partition_a, 123456)
PARTITION_MAX_SIZE(partition_b, 23456)
// ... 其他分区
</code></pre>
<ol start="2">
<li>进一步展开每个 <code>PARTITION_MAX_SIZE</code>：</li>
</ol>
<pre><code class="language-c">static const int PART_partition_a_SIZE = 123456;
static const int PART_partition_b_SIZE = 23456;
// ... 其他分区对应的静态变量
</code></pre>
</li>
</ul>
<hr>
<h4 id="4--取消宏定义">4 <strong>. 取消宏定义</strong></h4>
<pre><code class="language-c">#undef PARTITION_MAX_SIZE
</code></pre>
<ul>
<li><strong>作用</strong>：<br>
取消 <code>PARTITION_MAX_SIZE</code> 的宏定义，防止后续代码中可能出现的宏名冲突。</li>
</ul>
<hr>
<h4 id="5-完整展开示例">5. <strong>完整展开示例</strong></h4>
<p>　　假设 <code>PARTITION_TABLE</code> 定义如下：</p>
<pre><code class="language-c">#define PARTITION_TABLE      \
    PARTITION_MAX_SIZE(partition_a, 123456)    \
    PARTITION_MAX_SIZE(partition_b, 23456)
</code></pre>
<p>　　则代码：</p>
<pre><code class="language-c">#define PARTITION_MAX_SIZE(name, size) \
    static const int PART_##name##_SIZE = size;
PARTITION_TABLE
#undef PARTITION_MAX_SIZE
</code></pre>
<p>　　将展开为：</p>
<pre><code class="language-c">static const int PART_partition_a_SIZE = 123456;
static const int PART_partition_b_SIZE = 23456;
</code></pre>
<h4 id="6-核心目的">6. <strong>核心目的</strong></h4>
<p>　　通过宏技巧 <strong>集中管理分区配置</strong>，避免手工编写重复代码：</p>
<ol>
<li><strong>集中化定义</strong>：所有分区的名称和大小在 <code>PARTITION_TABLE</code> 中统一配置。</li>
<li><strong>自动生成代码</strong>：通过宏批量生成对应的静态常量，简化代码维护。</li>
</ol>
<h3 id="get_partition_max_size-函数逻辑"><code>get_partition_max_size</code> 函数逻辑</h3>
<p>　　在<code>get_partition_max_size </code> 函数内部重新定义了 <code>PARTITION_MAX_SIZE</code>，每个 <code>PARTITION_MAX_SIZE(name, size)</code> 被替换为：</p>
<pre><code class="language-C">+ (strcmp(partition_name, "partition_a") ? 0 : PART_partition_a_SIZE)

+ (strcmp(partition_name, "partition_b") ? 0 : PART_partition_b_SIZE)
</code></pre>
<p>　　最终在<code>get_partition_max_size</code>函数展开为：</p>
<pre><code class="language-C">int get_partition_max_size(const char *partition_name) {
    return 0
        + (strcmp(partition_name, "partition_a") ? 0 : PART_partition_a_SIZE)
        + (strcmp(partition_name, "partition_b") ? 0 : PART_partition_b_SIZE)
}
</code></pre>
<p>　　若 <code>partition_name </code>匹配 <code>"parititon_a"</code>，表达式结果为 <code>PART_partition_a_SIZE</code>（即 123456）。<br>
若不匹配，结果为 0。</p>
<h2 id="总结">总结</h2>
<p>　　相比于使用数组定义分区名称和大小的方式，使用X-MACRO方式大大节省了运行时的开销。所有分区的名称和大小在编译期展开为静态常量，查询时直接访问内存地址，无计算开销。而且静态常量存储在程序的只读数据段（如 <code>.rodata</code>），不占用堆栈内存。</p>
<p>　　当然，缺点也很明显，代码可读性，可调试性会下降。</p>
<p>　　优点缺点总是相对而论的，在某些情况下，缺点也可以变为优点。而且，并不是所有的方案都完美无缺。需求的优先级是最高的，这点毋庸置疑。在考虑性能和可维护性的前提下，使用X-MACRO这种方式，可能是最好的解决办法。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0380129038043981" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-01 15:28">2025-06-01 15:27</span>&nbsp;
<a href="https://www.cnblogs.com/dongxb">学习，积累，成长</a>&nbsp;
阅读(<span id="post_view_count">34</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18906169);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18906169', targetLink: 'https://www.cnblogs.com/dongxb/p/18906169', title: 'X-MACRO使用技巧' })">举报</a>
</div>
        