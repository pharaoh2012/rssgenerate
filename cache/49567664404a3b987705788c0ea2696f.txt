<!----> <meta itemprop="headline" content="还在用轮询、websocket查询大屏数据？sse用起来"> <meta itemprop="keywords" content="前端,React.js"> <meta itemprop="datePublished" content="2024-10-14T06:22:03.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Mozambique_Here"> <meta itemprop="url" content="https://juejin.cn/user/81811266615619"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            还在用轮询、websocket查询大屏数据？sse用起来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/81811266615619/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Mozambique_Here
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-14T06:22:03.000Z" title="Mon Oct 14 2024 06:22:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-14
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    13,284
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body cache result"><h3 data-id="heading-0">常见的大屏数据请求方式</h3>
<h5 data-id="heading-1">1、http请求轮询：使用定时器每隔多少时间去请求一次数据。优点：简单，传参方便。缺点：数据更新不实时，浪费服务器资源（一直请求，但是数据并不更新）</h5>
<h5 data-id="heading-2">2、websocket：使用websocket实现和服务器长连接，服务器向客户端推送大屏数据。优点：长连接，客户端不用主动去请求数据，节约服务器资源（不会一直去请求数据，也不会一直去查数据库），数据更新及时，浏览器兼容较好（web、h5、小程序一般都支持）。缺点：有点大材小用，一般大屏数据只需要查询数据不需要向服务端发送消息，还要处理心跳、重连等问题。</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90851b2eee9d4b44994870b3bdad737a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW96YW1iaXF1ZV9IZXJl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735538337&amp;x-signature=tNz3iznZnD%2BQTcKIyKSgLoHpTl4%3D" alt="image.png" loading="lazy"></p>
<h5 data-id="heading-3">3、sse：基于http协议，将一次性返回数据包改为流式返回数据。优点：sse使用http协议，兼容较好、sse轻量，使用简单、sse默认支持断线重连、支持自定义响应事件。缺点：浏览器原生的EventSource不支持设置请求头，需要使用第三方包去实现（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYaffle%2FEventSource" target="_blank" title="https://github.com/Yaffle/EventSource" ref="nofollow noopener noreferrer">event-source-polyfill</a>）、需要后端设置接口的响应头Content-Type: text/event-stream</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a6f14d5d796435cb6fbb4fb6abeba87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW96YW1iaXF1ZV9IZXJl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735538337&amp;x-signature=O0yCh8r1oUG7rahZ8Dtj6qa8zss%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-4">sse和websocket的区别</h3>
<ol>
<li>websocket支持双向通信，服务端和客户端可以相互通信。sse只支持服务端向客户端发送数据。</li>
<li>websocket是一种新的协议。sse则是基于http协议的。</li>
<li>sse默认支持断线重连机制。websocket需要自己实现断线重连。</li>
<li>websocket整体较重，较为复杂。sse较轻，简单易用。</li>
</ol>
<h4 data-id="heading-5">Websocket和SSE分别适用于什么业务场景？</h4>
<p>根据sse的特点（<strong>轻量、简单、单向通信</strong>）更适用于<strong>大屏</strong>的数据查询，业务应用上查询全局的一些数据，比如<strong>消息通知</strong>、<strong>未读消息</strong>等。</p>
<p>根据websocket的特点（<strong>双向通信</strong>）更适用于<strong>聊天功能</strong>的开发</p>
<h3 data-id="heading-6">前端代码实现</h3>
<p>sse的前端的代码非常简单</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initSse</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">`/api/wisdom/terminal/stats/change/notify/test`</span>);

        <span class="hljs-comment">// 这里的stats_change要和后端返回的数据结构里的event要一致</span>
        source.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'stats_change'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event: any</span>) {
            <span class="hljs-keyword">const</span> types = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>).<span class="hljs-property">types</span>;
        });
        <span class="hljs-comment">// 如果event返回的是message 数据监听也可以这样监听</span>
        <span class="hljs-comment">// source.onmessage =function (event) {</span>
        <span class="hljs-comment">//  var data = event.data;</span>
        <span class="hljs-comment">// };</span>

        <span class="hljs-comment">// 下面这两个监听也可以写成addEventListener的形式</span>
        source.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'SSE 连接已打开'</span>);
        };

        <span class="hljs-comment">// 处理连接错误</span>
        source.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error: any</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'SSE 连接错误:'</span>, error);
        };
        <span class="hljs-title function_">setSseSource</span>(source);
    };
    
<span class="hljs-comment">// 关闭连接</span>
sseSource.<span class="hljs-title function_">close</span>();
</code></pre>
<p>这种原生的sse连接是不能设置请求头的，但是在业务上接口肯定是要鉴权需要传递token的，那么怎么办呢？ 我们可以使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYaffle%2FEventSource" target="_blank" title="https://github.com/Yaffle/EventSource" ref="nofollow noopener noreferrer">event-source-polyfill</a>这个库</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSourcePolyfill</span>(<span class="hljs-string">`/api/wisdom/terminal/stats/change/notify/<span class="hljs-subst">${companyId}</span>`</span>, {
            <span class="hljs-attr">headers</span>: {
                <span class="hljs-title class_">Authorization</span>: sessionStorage.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">StorageKey</span>.<span class="hljs-property">TOKEN</span>) || storage.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">StorageKey</span>.<span class="hljs-property">TOKEN</span>),
                <span class="hljs-attr">COMPANYID</span>: storage.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">StorageKey</span>.<span class="hljs-property">COMPANYID</span>),
                <span class="hljs-attr">COMPANYTYPE</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">CT</span>: <span class="hljs-number">13</span>
            }
        });
        
        <span class="hljs-comment">//其它的事件监听和原生的是一样</span>
</code></pre>
<h3 data-id="heading-7">后端代码实现</h3>
<p>后端最关键的是设置将响应头的<strong>Content-Type</strong>设置为<strong>text/event-stream</strong>、<strong>Cache-Control</strong>设置为<strong>no-cache</strong>、<strong>Connection</strong>设置为<strong>keep-alive</strong>。每次发消息需要在消息体结尾用"/n/n"进行分割，一个消息体有多个字段每个字段的结尾用"/n"分割。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);

http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">var</span> fileName = <span class="hljs-string">"."</span> + req.<span class="hljs-property">url</span>;

  <span class="hljs-keyword">if</span> (fileName === <span class="hljs-string">"./stream"</span>) {
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, {
      <span class="hljs-string">"Content-Type"</span>:<span class="hljs-string">"text/event-stream"</span>,
      <span class="hljs-string">"Cache-Control"</span>:<span class="hljs-string">"no-cache"</span>,
      <span class="hljs-string">"Connection"</span>:<span class="hljs-string">"keep-alive"</span>,
      <span class="hljs-string">"Access-Control-Allow-Origin"</span>: <span class="hljs-string">'*'</span>,
    });
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">"retry: 10000\n"</span>);
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">"event: connecttime\n"</span>);
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">"data: "</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) + <span class="hljs-string">"\n\n"</span>);
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">"data: "</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) + <span class="hljs-string">"\n\n"</span>);

    interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">"data: "</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) + <span class="hljs-string">"\n\n"</span>);
    }, <span class="hljs-number">1000</span>);

    req.<span class="hljs-property">connection</span>.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">"close"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-built_in">clearInterval</span>(interval);
    }, <span class="hljs-literal">false</span>);
  }
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8844</span>, <span class="hljs-string">"127.0.0.1"</span>);
</code></pre>
<h3 data-id="heading-8">其它开发中遇到的问题</h3>
<p>我在开发调试中用的是umi，期间遇到个问题就是sse连接上了但是在控制台一直没有返回消息，后端那边又是正常发出了的，灵异的是在后端把服务干掉的一瞬间可以看到控制台一下接到好多消息。我便怀疑是umi的代理有问题，然后我就去翻umi的文档，看到了下面的东西：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e5d5d1448284f08b5c3ac0ba111a97a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW96YW1iaXF1ZV9IZXJl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735538337&amp;x-signature=6KiOVscZTW6SPeTGCNJmSesTSMo%3D" alt="image.png" loading="lazy"></p>
<p>一顿操作之后正常</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/71305f2b5d794e28890dc6780fafcd1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW96YW1iaXF1ZV9IZXJl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735538337&amp;x-signature=LVUNTFx%2BP5deYuKT%2FYFetO%2BgC8I%3D" alt="image.png" loading="lazy"></p></div></div>