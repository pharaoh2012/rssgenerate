
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhally/p/18922066" title="发布于 2025-06-10 14:12">
    <span role="heading" aria-level="2">Maui 实践：为控件动态扩展 DragDrop 能力</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>作者：夏群林 原创 2025.6.9</p>
<p>拖放的实现，和其他的 GestureRecognizer 不同，需要 DragGestureRecognizer 与 DropGestureRecognizer 相互配合，Drag / Drop 又是在不同的控件上附加的，数据传输和配置相对复杂，不太好理解。需要彻底阅读源代码，才能真的把握。我做了一个扩展方法，把复杂的配置包裹起来，在代码层面与要附加拖放功能的控件分离，用户只需关注拖放动作所支持的业务功能即可。</p>
<p>直接上代码。</p>
<h2 id="一核心架构与关键组件">一、核心架构与关键组件</h2>
<h3 id="1-数据载体dragdroppayloadtview">1. 数据载体：<code>DragDropPayload&lt;TView&gt;</code></h3>
<p>解耦控件与业务逻辑，封装拖放所需的视图引用、附加数据和回调逻辑。</p>
<pre><code class="language-csharp">public interface IDragDropPayload
{
    public View View { get; }                   // 拖放源/目标控件
    public object? Affix { get; }               // 任意附加数据（如文本、对象）
    public Action? Callback { get; }            // 拖放完成后的回调
}
public class DragDropPayload&lt;TView&gt; : IDragDropPayload where TView : View
{
    public required TView View { get; init; }
    public object? Affix { get; init; }
    public Action? Callback { get; init; }
    View IDragDropPayload.View =&gt; View;
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>View</code>：强类型视图引用，确保拖放操作与具体控件绑定。</li>
<li><code>Affix</code>：支持传递复杂数据，用于拖和放时，对源控件和目标控件进行处理所需附加的数据。 默认为 null。</li>
<li><code>Callback</code>：用于执行拖放后的轻量化操作（如日志记录、UI 微更新），对源控件和目标控件分别处理。可得到 Affix 数据支持。默认为 null。即不处理。</li>
<li>设计 IDragDropPayload 公共接口，配置协变，是本扩展方法保持精干而又多面的关键。</li>
</ul>
<h3 id="2-消息传递dragdropmessagetsource-ttarget">2. 消息传递：<code>DragDropMessage&lt;TSource, TTarget&gt;</code></h3>
<p>通过泛型消息明确拖放类型，实现跨层业务逻辑解耦。 这里也配置了协变，便于 WeakReferenceMessenger 引用。使用反射权衡后的妥协。</p>
<pre><code class="language-csharp">public interface IDragDropMessage
{
    public IDragDropPayload SourcePayload { get; }
    public IDragDropPayload TargetPayload { get; }
}

public sealed class DragDropMessage&lt;TSource, TTarget&gt; : IDragDropMessage
    where TSource : View
    where TTarget : View
{
    public required DragDropPayload&lt;TSource&gt; SourcePayload { get; init; }
    public required DragDropPayload&lt;TTarget&gt; TargetPayload { get; init; }

    IDragDropPayload IDragDropMessage.SourcePayload =&gt; SourcePayload;
    IDragDropPayload IDragDropMessage.TargetPayload =&gt; TargetPayload;
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>类型安全</strong>：通过 <code>TSource</code> 和 <code>TTarget</code> 约束拖放的源/目标类型（如 <code>Label</code>→<code>Border</code>）。</li>
<li><strong>数据透传</strong>：通过 <code>DataPackagePropertySet</code> 传递扩展属性，避免消息类字段膨胀。</li>
<li><strong>解耦业务</strong>：消息仅负责数据传递，具体逻辑由订阅者（如 <code>MainPage</code>）处理。</li>
</ul>
<h3 id="3-asdraggabletsource-扩展方法">3. <code>AsDraggable&lt;TSource&gt;</code> 扩展方法</h3>
<p>通过扩展方法为任意控件注入拖放能力，屏蔽手势识别细节。</p>
<pre><code class="language-csharp">    public static void AsDraggable&lt;TSource&gt;(this TSource source, object? sourceAffix = null, Action? sourceCallback = null)
        where TSource : View
    {
        // 创建并存储 payload
        var payload = new DragDropPayload&lt;TSource&gt;
        {
            View = source,
            Affix = sourceAffix,
            Callback = sourceCallback
        };

        // 覆盖现有 payload（如果存在）
        dragPayloads.AddOrUpdate(source, payload);

        // 查找或创建 DragGestureRecognizer
        var dragGesture = source.GestureRecognizers.OfType&lt;DragGestureRecognizer&gt;().FirstOrDefault();
        if (dragGesture == null)
        {
            dragGesture = new DragGestureRecognizer { CanDrag = true };
            source.GestureRecognizers.Add(dragGesture);

            // 只在首次添加手势时注册事件
            dragGesture.DragStarting += (sender, args) =&gt;
            {
                // 通过 dragPayloads 提取最新的 payload
                if (dragPayloads.TryGetValue(source, out var dragPayload) &amp;&amp; dragPayload is DragDropPayload&lt;TSource&gt; payload)
                {
                    args.Data.Properties.Add("SourcePayload", payload);
                    source.Opacity = 0.5;
                }
            };
        }
    }
</code></pre>
<h2 id="4-asdroppabletsource-ttarget-扩展方法">4. <code>AsDroppable&lt;TSource, TTarget&gt;</code> 扩展方法</h2>
<pre><code class="language-c#">public static void AsDroppable&lt;TTarget&gt;(this TTarget target, object? targetAffix = null, Action? targetCallback = null)
    where TTarget : View
{
    AsDroppable&lt;View, TTarget&gt;(target, targetAffix, targetCallback);
}

public static void AsDroppable&lt;TSource, TTarget&gt;(this TTarget target, object? targetAffix = null, Action? targetCallback = null)
    where TSource : View
    where TTarget : View
{
    var dropGesture = target.GestureRecognizers.OfType&lt;DropGestureRecognizer&gt;().FirstOrDefault();
    if (dropGesture is null)
    {
        dropGesture = new DropGestureRecognizer() { AllowDrop = true };
        target.GestureRecognizers.Add(dropGesture);

        DragDropPayload&lt;TTarget&gt; defaultPayload = new()
        {
            View = target,
            Affix = null,
            Callback = null
        };

        _ = dropPayloads
            .GetOrCreateValue(dropGesture)
            .GetOrAdd(typeof(View).Name, _ =&gt; defaultPayload);

        dropGesture.DragOver += (sender, args) =&gt;
        {
            bool isSupported = args.Data.Properties.TryGetValue("SourcePayload", out _);
            target.BackgroundColor = isSupported ? Colors.LightGreen : Colors.Transparent;
        };

        dropGesture.DragLeave += (sender, args) =&gt;
        {
            target.BackgroundColor = Colors.Transparent;
        };

        dropGesture.Drop += (s, e) =&gt; OnDroppablesMessage&lt;TTarget&gt;(target, dropGesture, e);
    }

    DragDropPayload&lt;TTarget&gt; sourceSpecificDropPayload = new()
    {
        View = target,
        Affix = targetAffix,
        Callback = targetCallback
    };

    var payloadDict = dropPayloads.GetOrCreateValue(dropGesture);
    _ = payloadDict.AddOrUpdate(typeof(TSource).Name, (s) =&gt; sourceSpecificDropPayload, (s, old) =&gt; sourceSpecificDropPayload);
}
</code></pre>
<p><strong>核心机制</strong>：</p>
<ul>
<li><strong>手势识别器</strong>：使用 <code>DragGestureRecognizer</code> 和 <code>DropGestureRecognizer</code> 捕获拖放事件。  保持实例唯一。</li>
<li><strong>类型映射表</strong>：静态存储器 dragPayloads / dropPayloads 存储可支持的拖、放对象及其附加的数据，保持最新。</li>
<li><strong>消息注册</strong>：为每种类型组合注册唯一的消息处理函数，确保消息精准投递。</li>
<li><strong>方法重载</strong>：AsDroppable<ttarget> ，无特殊数据和动作附加的，可简化处理，毋须逐一注册类型配对。</ttarget></li>
</ul>
<h2 id="二关键实现细节">二、关键实现细节</h2>
<h3 id="1--conditionalweaktable">1.  ConditionalWeakTable</h3>
<p>在 <code>DragDropExtensions</code> 中，我们使用两个 <code>ConditionalWeakTable</code> 实现状态管理，保证拖放事件发生时传递最新约定的数据。</p>
<p>ConditionalWeakTable 最大的好处是避免内存泄漏。用 View 或 GestureRecognizer 实例作为键，当该实例不再被别处引用时，内存回收机制会自动清除对应的键值对，无需用户专门释放内存。</p>
<pre><code class="language-csharp">private static readonly ConditionalWeakTable&lt;View, IDragDropPayload&gt; dragPayloads = [];
private static readonly ConditionalWeakTable&lt;GestureRecognizer, ConcurrentDictionary&lt;string, IDragDropPayload&gt;&gt; dropPayloads = [];
</code></pre>
<h3 id="2-droppayloads">2. dropPayloads</h3>
<p>为每个 <code>DropGestureRecognizer</code> 关联源类型映射和对应该源类型所预先配置目标类型 TargetPayload。</p>
<pre><code class="language-csharp">DragDropPayload&lt;TTarget&gt; sourceSpecificDropPayload = new()
{
    View = target,
    Affix = targetAffix,
    Callback = targetCallback
};

var payloadDict = dropPayloads.GetOrCreateValue(dropGesture);
_ = payloadDict.AddOrUpdate(typeof(TSource).Name, (s) =&gt; sourceSpecificDropPayload, (s, old) =&gt; sourceSpecificDropPayload);
</code></pre>
<p>还贴心地预备好默认配置：</p>
<pre><code class="language-c#">DragDropPayload&lt;TTarget&gt; defaultPayload = new()
{
    View = target,
    Affix = null,
    Callback = null
};

_ = dropPayloads
    .GetOrCreateValue(dropGesture)
    .GetOrAdd(typeof(View).Name, _ =&gt; defaultPayload);
</code></pre>
<h3 id="3--dragpayloads">3 . dragPayloads</h3>
<p>源类型 SourcePayload 配置表，在 DragGestureRecognizer 首次配置时注册，重复 AsDraggable 方法时更新。</p>
<pre><code class="language-csharp">// 创建并存储 payload
var payload = new DragDropPayload&lt;TSource&gt;
{
    View = source,
    Affix = sourceAffix,
    Callback = sourceCallback
};

// 覆盖现有 payload（如果存在）
dragPayloads.AddOrUpdate(source, payload);
</code></pre>
<h3 id="4---idragdropmessage--weakreferencemessenger">4 .  IDragDropMessage / WeakReferenceMessenger</h3>
<p>反射获取分类拖放消息，但需要统一发送：</p>
<pre><code class="language-csharp">// 构建泛型类型
Type genericMessageType = typeof(DragDropMessage&lt;,&gt;);
Type constructedMessageType = genericMessageType.MakeGenericType(sourceType, typeof(TTarget));

// 创建实例
object? message = Activator.CreateInstance(constructedMessageType);
if (message is null)
{
    return;
}

// 设置属性
PropertyInfo sourceProp = constructedMessageType.GetProperty("SourcePayload")!;
PropertyInfo targetProp = constructedMessageType.GetProperty("TargetPayload")!;
sourceProp.SetValue(message, sourcePayload);
targetProp.SetValue(message, targetPayload);

// 核心动作
_ = WeakReferenceMessenger.Default.Send&lt;IDragDropMessage&gt;((IDragDropMessage)message);
</code></pre>
<h2 id="三-反射的优化">三、 反射的优化</h2>
<p>尝试了很多办法，还是采用反射技术，最为直接。</p>
<p>我并不喜欢使用反射。消耗大不说，现在 Microsoft 大力推进 Native AOT（ Ahead Of Time）编译，将.NET 代码提前编译为本机代码，对反射的使用有约束，如果代码中反射模式导致 AOT 编译器无法静态分析，就会产生裁剪警告，甚至可能导致编译失败或运行时异常。</p>
<p>因此，在 .NET MAUI 的 AOT 编译环境下，对反射泛型类型的创建需要特殊处理。这里通过 <strong>预编译委托缓存 + 静态类型注册</strong> 的组合方案，实现了AOT 的泛型消息工厂。高效是肯定的，目前看来，是兼容的。</p>
<p>使用 <code>ConcurrentDictionary&lt;string, HashSet&lt;Type&gt;&gt;</code> 存储注册的源类型和目标类型，通过 <code>"Source"</code> 和 <code>"Target"</code> 两个键区分不同角色的类型集合， <code>HashSet&lt;Type&gt;</code> 确保类型唯一性，避免重复注册。</p>
<pre><code class="language-c#">private static readonly ConcurrentDictionary&lt;string, HashSet&lt;Type&gt;&gt; registeredTypes = new();
</code></pre>
<p><strong>自动配对机制</strong>：当新类型注册时，自动与已注册的对立类型（源→目标，目标→源）创建所有可能的配对组合（静态），确保 AOT 环境下反射可用。</p>
<pre><code class="language-c#">private static void RegisterType(string role, Type type)
{
  // 获取或创建对应角色的类型集合
  var types = registeredTypes.GetOrAdd(role, _ =&gt; []);

  // 添加类型并判断是否为新增（返回true表示新增）
  if (types.Add(type))
  {
      // 新注册的类型，补全所有可能的配对组合
      if (role == "Source")
      {
          // 源类型：与所有已注册的目标类型配对
          if (registeredTypes.TryGetValue("Target", out var targetTypes))
          {
              foreach (var targetType in targetTypes)
              {
                  RegisterMessageFactory(type, targetType);
              }
          }
      }
      else if (role == "Target")
      {
          // 目标类型：与所有已注册的源类型配对
          if (registeredTypes.TryGetValue("Source", out var sourceTypes))
          {
              foreach (var sourceType in sourceTypes)
              {
                  RegisterMessageFactory(sourceType, type);
              }
          }
      }
  }
}
</code></pre>
<p><strong>反射泛型工厂</strong>：每个类型组合仅反射一次，生成的委托被缓存</p>
<pre><code class="language-csharp">private static readonly ConcurrentDictionary&lt;(Type source, Type target), Func&lt;IDragDropPayload, IDragDropPayload, IDragDropMessage&gt;&gt; messageFactories = new();

private static void RegisterMessageFactory(Type sourceType, Type targetType)
{
    var key = (sourceType, targetType);
    messageFactories.GetOrAdd(key, _ =&gt; {
        // 仅首次执行反射
        var messageType = typeof(DragDropMessage&lt;,&gt;).MakeGenericType(sourceType, targetType);
        return (sourcePayload, targetPayload) =&gt; {
            var message = Activator.CreateInstance(messageType)!;
            // 设置属性...
            return (IDragDropMessage)message;
        };
    });
}
</code></pre>
<p><strong>反射优化策略</strong>：后续调用直接执行委托，避免重复反射</p>
<pre><code class="language-csharp">// 通过预注册的工厂创建消息实例
var key = (sourceType, typeof(TTarget));
if (messageFactories.TryGetValue(key, out var factory))
{
    var message = factory(sourcePayload, targetPayload);

    // 核心动作
    _ = WeakReferenceMessenger.Default.Send&lt;IDragDropMessage&gt;(message);
}
</code></pre>
<p><strong>AOT 兼容性保障</strong></p>
<p>预编译委托缓存方案，支持任意类型组合，仅首次注册时有反射开销，平衡灵活性和性能，但需要在编译前静态注册所有可能的类型组合，避免运行时动态生成未知类型组合。</p>
<p>必要的话，可使用 <code>[assembly: Preserve]</code> 属性保留泛型类型及其成员。暂时没采用这种方法，寄希望于 Microsoft 自行保证兼容性。</p>
<h2 id="四使用示例">四、使用示例</h2>
<h3 id="mainpagexaml"><code>MainPage.xaml</code></h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Zhally.DragDrop.MainPage"
             Title="拖放示例"&gt;

    &lt;StackLayout Spacing="20" Padding="30"&gt;
        &lt;Label Text="高级拖放示例"
               FontSize="22"
               FontAttributes="Bold"
               HorizontalOptions="Center" /&gt;

        &lt;HorizontalStackLayout 
                HorizontalOptions="Center"&gt;
            &lt;Label x:Name="DragLabel"
                Text="拖放示例文本"
                BackgroundColor="LightBlue"
                Padding="12"
                HorizontalOptions="Center"
                FontSize="16" /&gt;

            &lt;BoxView x:Name="DragBoxView"
                HeightRequest="60"
                WidthRequest="120"
                BackgroundColor="LightPink"
                HorizontalOptions="Center" /&gt;

            &lt;ContentView x:Name="DragContentView"
                HeightRequest="60"
                WidthRequest="120"
                BackgroundColor="LightCyan"
                HorizontalOptions="Center" /&gt;
        &lt;/HorizontalStackLayout&gt;

        &lt;Border x:Name="DropBorder"
               BackgroundColor="LightGreen"
               Padding="20"
               Margin="10"
               HorizontalOptions="Center"
               WidthRequest="200"
               HeightRequest="100"&gt;
            &lt;Label Text="放置目标区域" HorizontalOptions="Center" /&gt;
        &lt;/Border&gt;

        &lt;Label x:Name="ResultLabel"
               Text="等待拖放操作..."
               HorizontalOptions="Center"
               FontAttributes="Italic"
               TextColor="Gray" /&gt;
    &lt;/StackLayout&gt;
&lt;/ContentPage&gt;    
</code></pre>
<h3 id="mainpagexamlcs"><code>MainPage.xaml.cs</code></h3>
<pre><code class="language-csharp">using CommunityToolkit.Mvvm.Messaging;
using System.Diagnostics;
using Zhally.DragDrop.Controls;

namespace Zhally.DragDrop;

public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
        SetupDragDrop();
    }

    private void SetupDragDrop()
    {
        // 设置可拖动元素（携带 Payload 数据）
        DragLabel.AsDraggable&lt;Label&gt;(
            sourceAffix: new { Type = "文本数据", Value = "Hello World" },
            sourceCallback: () =&gt; Debug.WriteLine("拖动源回调")
        );
        DragLabel.AsDraggable&lt;Label&gt;(
            sourceAffix: new { Type = "文本数据", Value = "Hello World agian" },
            sourceCallback: () =&gt; Debug.WriteLine("拖动源回调 again")
        );
        DragBoxView.AsDraggable&lt;BoxView&gt;(
            sourceAffix: new { Type = "BoxView数据", Value = "BoxView" },
            sourceCallback: () =&gt; Debug.WriteLine("按钮拖动回调")
        );
        DragContentView.AsDraggable&lt;ContentView&gt;(
            sourceAffix: new { Type = "ContentView数据", Value = "ContentView" },
            sourceCallback: () =&gt; Debug.WriteLine("按钮拖动回调")
        );

        // 设置可放置元素（携带目标数据）
        DropBorder.AsDroppable&lt;Label, Border&gt;(
          targetAffix: new { Type = "目标数据", Value = "Label Drop Zone" },
          targetCallback: () =&gt; Debug.WriteLine("放置目标回调")
        );

        DropBorder.AsDroppable&lt;BoxView, Border&gt;(
          targetAffix: new { Type = "目标数据", Value = "BoxView Drop Zone" },
          targetCallback: () =&gt; Debug.WriteLine("放置目标回调")
        );

        // 设置可放置元素（通用，非必须，在携带目标数据时有用）
        DropBorder.AsDroppable&lt;Border&gt;(
          targetAffix: new { Type = "目标数据", Value = "Generic Drop Zone" },
          targetCallback: () =&gt; Debug.WriteLine("放置目标回调")
        );
    }

    protected override void OnAppearing()
    {
        base.OnAppearing();

        WeakReferenceMessenger.Default.Register&lt;IDragDropMessage&gt;(this, HandleBorderDragDropMessage);
    }

    protected override void OnDisappearing()
    {
        base.OnDisappearing();
        WeakReferenceMessenger.Default.UnregisterAll(this);
    }

    private void HandleBorderDragDropMessage(object recipient, IDragDropMessage message)
    {
        if (message.SourcePayload.View == null || message.TargetPayload.View == null)
        {
            return;
        }

        switch (message.SourcePayload.View)
        {
            case Label label:
                HandleLabelDrop(label, message);
                break;

            case BoxView boxView:
                HandleBoxViewDrop(boxView, message);
                break;

            case ContentView contentView:
                HandleContentViewDrop(contentView, message);
                break;

            default:
                HandleDefaultDrop(message);
                break;
        }
    }

    private void HandleDefaultDrop(IDragDropMessage message) =&gt; HandleBorderMessage(message);
    private void HandleLabelDrop(Label label, IDragDropMessage message) =&gt; HandleBorderMessage(message);
    private void HandleBoxViewDrop(BoxView boxView, IDragDropMessage message) =&gt; HandleBorderMessage(message);
    private void HandleContentViewDrop(ContentView contentView, IDragDropMessage message) =&gt; HandleBorderMessage(message);
    private void HandleBorderMessage(IDragDropMessage message)
    {

        MainThread.BeginInvokeOnMainThread(() =&gt;
        {
            ResultLabel.Text = $"拖放成功!\n" +
                              $"源类型: {message.SourcePayload.View.GetType()}\n" +
                              $"源数据: {message.SourcePayload.Affix}\n" +
                              $"目标数据: {message.TargetPayload.Affix}";
        });

        // 执行回调
        MainThread.BeginInvokeOnMainThread(() =&gt;
        {
            message.SourcePayload.Callback?.Invoke();  // 执行源回调
        });

        // 执行回调
        MainThread.BeginInvokeOnMainThread(() =&gt;
        {
            message.TargetPayload.Callback?.Invoke();   // 执行目标回调
        });
    }

}
</code></pre>
<h2 id="五总结">五、总结</h2>
<p>本方案实现了 MAUI 控件拖放能力的动态扩展。核心设计遵循以下原则：</p>
<ol>
<li><strong>解耦</strong>：拖放逻辑与控件分离，通过消息系统连接业务层。</li>
<li><strong>类型安全</strong>：泛型约束确保拖放类型匹配，编译期暴露潜在问题。</li>
<li><strong>可扩展</strong>：通过字典映射和消息订阅，轻松支持新的拖放类型组合。</li>
</ol>
<p>此方案已在实际项目中验证，适用于文件管理、列表排序、数据可视化等场景，为 MAUI 应用提供了灵活高效的拖放解决方案。</p>
<p>本方案源代码开源，按照 MIT 协议许可。地址：<a href="https://github.com/xiaql/Zhally.Toolkit" target="_blank" rel="noopener nofollow">xiaql/Zhally.Toolkit: Dynamically attach draggable and droppable capability to controls of View in MAUI</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-10 14:12">2025-06-10 14:12</span>&nbsp;
<a href="https://www.cnblogs.com/zhally">zhally</a>&nbsp;
阅读(<span id="post_view_count">91</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18922066);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18922066', targetLink: 'https://www.cnblogs.com/zhally/p/18922066', title: 'Maui 实践：为控件动态扩展 DragDrop 能力' })">举报</a>
</div>
        