
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/io-T-T/p/18865002" title="发布于 2025-05-07 20:10">
    <span role="heading" aria-level="2">(NLP)关键词提取之——TF-IDF解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        (NLP)关键词提取之——TF-IDF解析
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="关键词提取tf-idf">关键词提取——TF-IDF</h2>
<h2 id="1-tf-idf定义">1 TF-IDF定义</h2>
<ol>
<li>
<p>概要</p>
<p><strong>tf-idf</strong>（英语：<strong>t</strong>erm <strong>f</strong>requency–<strong>i</strong>nverse <strong>d</strong>ocument <strong>f</strong>requency）是一种用于<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E8%A8%8A%E6%AA%A2%E7%B4%A2" target="_blank" rel="noopener nofollow">信息检索</a>与<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98" target="_blank" rel="noopener nofollow">文本挖掘</a>的常用加权技术。tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个<a href="https://zh.wikipedia.org/wiki/%E8%AA%9E%E6%96%99%E5%BA%AB" target="_blank" rel="noopener nofollow">语料库</a>中的其中一份<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener nofollow">文件</a>的重要程度。字词的重要性随着它在文件中出现的次数成<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%AF%94" target="_blank" rel="noopener nofollow">正比</a>增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" target="_blank" rel="noopener nofollow">搜索引擎</a>应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。</p>
</li>
<li>
<p>什么是TF：</p>
<p><strong>TF意为Term Frequency</strong> ，即为<strong>词频</strong>，用于衡量一个词在一篇文档中出现的频率。</p>
</li>
<li>
<p>什么是IDF</p>
<blockquote>
<p><strong>IDF意为Inverse Document Frequency</strong>，为<strong>逆文档频率</strong>，衡量一个词在整个语料库中的稀有程度。</p>
</blockquote>
</li>
<li>
<p>什么是TF-IDF</p>
<blockquote>
<p>TF-IDF为TF与IDF的乘积</p>
</blockquote>
</li>
</ol>
<h2 id="2-tf-idf公式">2 TF-IDF公式</h2>
<h3 id="2-1-tf公式">2-1 TF公式：</h3>
<blockquote>
<p>公式：TF(t,d)= \frac {f_{t,d}} {\sum_{k} f_{k,d}}</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507200621344-1365687183.svg" alt="mylatex20250502_205144" loading="lazy"></p>
<ul>
<li>
<p>公式解释：</p>
<p>分子：<code>F t,d</code>表示词 t 在文档 d 中出现的次数</p>
<p>分母：文档 d 中所有词的总数</p>
</li>
<li>
<p>PS：其实就是词频，这个词在当前文档d出现次数 / 文档d中词数数量</p>
</li>
</ul>
<h3 id="2-2-idf公式">2-2 IDF公式</h3>
<p><strong>注意，此IDF公式经过平滑，在分母加了1，原版IDF公式分母只有nt</strong></p>
<blockquote>
<p>公式：IDF(t)=log(\frac{N}{1+n_t})</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507200622195-271438080.svg" alt="tf_idf (2)" loading="lazy"></p>
<ul>
<li>
<p>公式解释：</p>
<p>N：总文档数。</p>
<p>1+nt：包含词 t 的文档数（注意 +1 防止除以 0）。</p>
</li>
</ul>
<h3 id="2-3-tf-idf公式">2-3 TF-IDF公式</h3>
<blockquote>
<p>公式：TF-IDF(t,d)=TF(t,d)*IDF(t)</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507200621514-202701152.svg" alt="TF-IDF" loading="lazy"></p>
<ul>
<li>
<p>公式解释：</p>
<p>本质上就是TF与IDF相乘</p>
</li>
</ul>
<h2 id="3-tf-idf编码实现">3 TF-IDF编码实现</h2>
<h3 id="3-0-简要步骤">3-0 简要步骤：</h3>
<p>主要分为以下几个步骤：</p>
<ol>
<li>批量文档分词并保存</li>
<li>读取分词结果，计算TF值以及IDF值</li>
<li>获取关键词</li>
</ol>
<h3 id="3-1批量文档分词并保存">3-1批量文档分词并保存：</h3>
<p>目前中文分词常用的有：</p>
<ul>
<li>jieba【结巴分词】</li>
<li>pkuseg【一个多领域中文分词工具包】</li>
<li>thulac【THULAC（THU Lexical Analyzer for Chinese）由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包】</li>
</ul>
<p>这里以<code>pku</code>和<code>jieba</code>，给一个框架作为参考，具体还需要补全：</p>
<pre><code class="language-python">import jieba, pkuseg,thulac


def tokenize_pku(text:str):
    """
    使用pku分词
    :param text: 输入的文本
    :return: 分词后的 token 列表
    """
    seg = pkuseg.pkuseg()
    tokens = seg.cut(text)                    #分词
    #你对于分词做处理，保存
    print(tokens)
    return tokens


def tokenize_by_jieba(sentence: str):
    """
    使用 jieba 对中文句子进行分词
    :param sentence: 待分词的中文句子
    :return: 分词后的 token 列表
    """
    tokens = list(jieba.cut(sentence, cut_all=False))  # 精确模式
    print(tokens)
    return tokens

if __name__ == '__main__':
    tokenize_pku("这里以`pku`和`jieba`，给一个框架作为参考，具体还需要补全")
    tokenize_by_jieba("这里以`pku`和`jieba`，给一个框架作为参考，具体还需要补全")
</code></pre>
<p>保存我这里就不写了，我当时使用的数据库保存，对于没有学过数据库的用户可能不友好，而且数据库配置各不相同，后续只需要用你会用的保存方式保存即可，思路一致就好。</p>
<h3 id="3-2-计算tf-idf">3-2 计算TF-IDF</h3>
<h4 id="3-2-1-计算tf">3-2-1 计算TF</h4>
<p>其实只需要两个参数，一个是<strong>关键词</strong>，一个是<strong>本书总词数</strong>，即所计算的关键词所在的书中一共有多数词数。只要理解什么是<strong>关键词</strong>和本书的<strong>总词数</strong>就好编码了。我们来举个例子。</p>
<ul>
<li>
<p>举个栗子：</p>
<ul>
<li>
<p>假设我们以法律来分词，法律有刑法、宪法、民法。</p>
</li>
<li>
<p>我们以刑法举例来计算刑法里面的关键字，假设为“缓刑”，这个关键词的词频TF。</p>
</li>
<li>
<p>假设刑法里面只有如下的文本{缓刑、拘役、管制、缓刑}，那TF所指的总词数就是4，不受其他法律文书的影响，因为词频只针对当前文档</p>
</li>
</ul>
</li>
<li>
<p>编码：</p>
<pre><code class="language-python">def TF_calculate(keyword_count, book_all_word_count:int):
    """
    计算词频
    :param keyword_count: 关键字出现词数
    :param book_all_word_count: 单本法律文书的词汇总数
    :return: 计算后的TF
    """
    return float(keyword_count) / float(book_all_word_count)
</code></pre>
<p>至于如何提取关键词词数、文书中包含多少词，这个因人而异，了解了核心比较关键，细枝末节我相信读者是可以实现的。</p>
</li>
</ul>
<h4 id="3-2-2-计算idf">3-2-2 计算IDF</h4>
<ul>
<li>
<p>举个栗子：</p>
<p>计算IDF相比计算TF会相对难一点，但其实也没那么难，主要需求两个变量：</p>
<ul>
<li>文档总数量N：按照上面那个例子，这里的N应该是3，总有3本书</li>
<li>出现次数<code>nt</code> ：假设只有刑法出现过了关键词【缓刑】，那这里的<code>nt</code>为1</li>
</ul>
</li>
<li>
<p>注意事项：</p>
<ol>
<li>
<p>IDF的计算公式我建议使用平滑的，因为如果不加1，假设关键词在所有书中全部出现了，那 <code>N/nt =1</code>  再经过log就变成0了</p>
</li>
<li>
<p>这里你可以根据需求使用不同的log底数，我这里使用的是自然对数</p>
</li>
<li>
<p>如果文本量不大的话不用担心精度丢失，以我自己进行处理的文本为例，单书2w多词进行TF-IDF效果还是比较可以的，计算的精度也没有丢失。如果实在有需要可以观察一下并进行处理【一般用户应该用不上】</p>
</li>
</ol>
</li>
<li>
<p>编码：</p>
<ol>
<li>这个是我叫ai帮我写的，大致的计算就是这样子，你们可以参考一下：</li>
</ol>
<pre><code class="language-python">def IDF_calculate(N: int, nt: int) -&gt; float:
    """
    计算 IDF（逆文档频率），使用平滑公式：IDF(t) = log(N / (1 + nt))
    :param N: 文档总数
    :param nt: 包含词 t 的文档数量
    :return: 平滑后的 IDF 值
    """
    if N &lt;= 0:
        raise ValueError("文档总数 N 必须大于 0")
    return math.log(N / (1 + nt))
</code></pre>
<ol start="2">
<li>
<p>我自己在实际运用的情况：</p>
<p>主要还是怎么找到出现次数nt就好了，因为要跨文书，所以是有一点难点</p>
<pre><code class="language-python">def IDF_calculate(key_word:db.Key_word):
    """
    计算IDF 逆文档频率
    :param key_word:关键字表类
    :return: 返回计算好的IDF
    """
    word = key_word.word
    idf_session = db.Session()
    N_data = db.get_info(db.Key_word, "law_name")#获取文档总数
    N = float(len(N_data))
    nt_all_doc = idf_session.query(db.Key_word).filter(db.Key_word.word==word).all()#获取包含这个关键字的文档数量【没有针对不同分词方式去重】
    nt_count = float(len(nt_all_doc))
    IDF = math.log( N/ nt_count+1)
    idf_session.close()
    return IDF
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="3-2-3-tf-idf">3-2-3 TF-IDF</h4>
<p>​	两个函数的结果相乘就好。</p>
<h3 id="3-3-后续">3-3 后续</h3>
<p>后续可以根据你自己需要进行关键字提取的测试，以我实现的效果举例：</p>
<p><img src="https://raw.githubusercontent.com/idk0v0/pic25/main/image-20250503212211106.png" alt="image-20250503212211106" loading="lazy"></p>
<p>希望能够帮助你了解<code>TF-IDF</code>，网上的说明不是特别清楚，因此发此篇博客，也不能说有多专业，仅为个人的理解。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.015187945237268519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-07 20:10">2025-05-07 20:10</span>&nbsp;
<a href="https://www.cnblogs.com/io-T-T">io_T_T</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18865002);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18865002', targetLink: 'https://www.cnblogs.com/io-T-T/p/18865002', title: '(NLP)关键词提取之——TF-IDF解析' })">举报</a>
</div>
        