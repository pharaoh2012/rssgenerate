
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/18988610" title="发布于 2025-07-16 23:38">
    <span role="heading" aria-level="2">Golang基础笔记十二之defer、panic、error</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/U2GSh83iB9YV9cXZFZjjdA" target="_blank" rel="noopener nofollow">Golang基础笔记十二之defer、panic、error</a></p>
</blockquote>
<p>本篇笔记介绍一下 Golang 里 defer、panic 和 error 的相关概念和操作，以下是本篇笔记目录：</p>
<ol>
<li>defer</li>
<li>panic</li>
<li>error</li>
</ol>
<h3 id="1defer">1、defer</h3>
<p><code>defer</code> 语句用于延迟执行一个函数，这个函数会在函数返回前执行，无论是正常返回还是触发 panic 之后。</p>
<p>它常用于确保一些文件、链接等资源无论是正常还是异常的情况下被释放。</p>
<p>如果有多个 deder 会按照后进先出的顺序来执行。</p>
<h4 id="1-后进先出">1. 后进先出</h4>
<p>我们可以先看一个示例：</p>
<pre><code class="language-go">func main() {
    defer fmt.Println("最后输出")
    defer fmt.Println("倒数第二个输出")

    defer fmt.Println("第二个输出")
    defer fmt.Println("第一个输出")
}
</code></pre>
<p>这个函数执行后，输出的结果如下：</p>
<pre><code class="language-go">第一个输出
第二个输出
倒数第二个输出
最后输出
</code></pre>
<p>从这个操作可以看到，它是满足后进先出的顺序的。</p>
<h4 id="2-函数返回前执行">2. 函数返回前执行</h4>
<p>接下来我们验证一下它会在函数返回前执行：</p>
<pre><code class="language-go">func main() {
    defer fmt.Println("defer 输出")

    fmt.Println("正常输出")
    fmt.Println("函数的末尾输出")
}
</code></pre>
<p>其输出内容如下：</p>
<pre><code class="language-go">正常输出
函数的末尾输出
defer 输出
</code></pre>
<p>可以看到，defer 执行的功能会在函数末尾的操作之后。</p>
<h4 id="3-异常操作的-defer">3. 异常操作的 defer</h4>
<p>接下来我们模拟一下函数中执行异常的情况：</p>
<pre><code class="language-go">func main() {
    defer fmt.Println("defer 输出")
    a := 1
    b := 0
    fmt.Println(a / b)
}
</code></pre>
<p>其输出结果如下：</p>
<pre><code class="language-go">defer 输出
panic: runtime error: integer divide by zero
</code></pre>
<p>可以看到，虽然在函数中间执行报错了，但是 defer 后的内容仍然被执行了。</p>
<p>因此，defer 操作可以保证一些资源的释放，即便函数在运行中报错。</p>
<h4 id="4-defer-注意事项">4. defer 注意事项</h4>
<h5 id="1-defer-函数的参数传递">1) defer 函数的参数传递</h5>
<p>如果 defer 的函数的使用了参数，那么这个参数在当时就被固定了，即便是后面对其进行了修改，也不会改变，比如下面的例子：</p>
<pre><code class="language-go">func main() {
    i := 1
    defer fmt.Println("defer i: ", i)

    i += 1
    fmt.Println("final i: ", i)
}
</code></pre>
<p>其输出内容如下：</p>
<pre><code class="language-go">final i:  2
defer i:  1
</code></pre>
<p>可以看到，即便 i 的值被修改，因为 defer 先被执行，所以 i 的值已经被复制，后面对 i 进行修改后，也不会对 defer 操作的内容有所修改。</p>
<p>而如果变量是引用类型，在操作上是一样的，传递的都是变量的副本，但是因为引用类型传递的是引用的副本，而其共享底层数据是一样的，所以修改后会反映到结果上，其示例如下：</p>
<pre><code class="language-go">func main() {
    s := []int{1, 2, 3}
    defer fmt.Println("defer s: ", s)

    s[1] = 100
    fmt.Println("final s: ", s)
}
</code></pre>
<p>其输出结果为：</p>
<pre><code class="language-go">final s:  [1 100 3]
defer s:  [1 100 3]
</code></pre>
<h5 id="2-defer-获取变量最新值">2) defer 获取变量最新值</h5>
<p>如果我们想要在 defer 逻辑中获取到变量的最新值，我们可以将参数封装到匿名函数内部，延迟到实际执行的时候再求值：</p>
<pre><code class="language-go">func main() {
    i := 1
    defer func() { fmt.Println("defer i: ", i) }()

    i += 1
    fmt.Println("final i: ", i)
}
</code></pre>
<p>其输出的内容为：</p>
<pre><code class="language-go">final i:  2
defer i:  2
</code></pre>
<h3 id="2panic">2、panic</h3>
<p>panic 是 Golang 里的一种异常机制，用于处理不可恢复的错误，比如数组越界，空指针引用等。</p>
<p>当发生 panic 时，程序会立即停止当前函数的执行，逐层向上执行 defer 并输出错误信息，下面是一个示例：</p>
<pre><code class="language-go">func main() {
    defer fmt.Println("defer content")

    fmt.Println("first message")

    var a []int
    fmt.Println(a[0])

    fmt.Println("wont show")
}
</code></pre>
<p>输出内容如下：</p>
<pre><code class="language-go">first message
defer content
panic: runtime error: index out of range [0] with length 0

goroutine 1 [running]:
main.main()
        /../main.go:32 +0x8f
exit status 2
</code></pre>
<h4 id="1-主动触发和运行时触发">1. 主动触发和运行时触发</h4>
<p>在程序运行过程中，如果发生了我们没有预料到的错误，就会触发 panic，或者当我们在处理中无法继续处理下去，我们也可以选择主动触发 panic。</p>
<p>运行时触发 panic 就比如上面我们介绍的例子，下面介绍一个主动触发 panic 的示例：</p>
<pre><code class="language-go">func GetRandomState() bool {
    num := rand.Intn(5)
    if num &lt; 3 {
        return true
    } else {
        return false
    }
}

func main() {
    if GetRandomState() {
        panic("random state error")
    }
}
</code></pre>
<p>这个函数多执行几次，当返回值为 true 时，就会主动触发 panic，并中断程序：</p>
<pre><code class="language-go">panic: random state error

goroutine 1 [running]:
main.main()
        /../main.go:33 +0x38
exit status 2
</code></pre>
<h4 id="2-recover-捕获-panic">2. recover 捕获 panic</h4>
<p>我们可以使用 recover 用于在 defer 中捕获 panic，使程序恢复正常执行。</p>
<p>注意，这里的恢复正常执行，并不是跳过发生报错的地方接着执行，而是指在调用这个函数之外的地方接着往后执行，从而使整个 Golang 程序不会崩溃。</p>
<p>下面是一个示例：</p>
<pre><code class="language-go">func Test() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recovered err info: ", r)
        }
    }()

    if GetRandomState() {
        panic("random state error")
    }
}

func main() {
    Test()
    fmt.Println("after Test")
}
</code></pre>
<p>当程序报错后，recover 可以捕获到 panic 信息，在这里我们将其打印了出来，并且可以看到，调用 <code>Test()</code> 之后的 <code>fmt.Println()</code> 信息被正常打印出来。</p>
<p>如果是在生产环境，我们可以将其写入日志，或者发送邮件等方式通知到对应的负责人，下面是将错误信息打印出来的结果：</p>
<pre><code class="language-go">recovered err info:  random state error
</code></pre>
<p>根据这个信息，只有简单一个 panic 输出的信息，如果我们想获取更详细的信息，比如，在哪个函数的多少行出了什么报错，我们可以使用下面的操作：</p>
<pre><code class="language-go">func main() {

    defer func() {
        if r := recover(); r != nil {
            stackBuffer := make([]byte, 1024)
            stackSize := runtime.Stack(stackBuffer, false)

            fmt.Printf("recovered err info: %s \n", stackBuffer[:stackSize])
        }
    }()

    if GetRandomState() {
        panic("random state error")
    }
}
</code></pre>
<p>其中输出的具体的报错信息如下：</p>
<pre><code class="language-go">recovered err info: goroutine 1 [running]:
main.main.func1()
        /../main.go:36 +0x51
panic({0x5a6cf20?, 0x5a855f8?})
        /usr/local/go/src/runtime/panic.go:791 +0x132
main.main()
        /../main.go:43 +0x5f
</code></pre>
<p>可以看到报错信息可以详细到在 main 函数的第 43 行，根据这个信息我们可以再去溯源错误。</p>
<h3 id="3error">3、error</h3>
<p>error 是 Golang 的标准错误接口，用于表示错误信息：</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<h4 id="1-返回-error-信息">1. 返回 <code>error</code> 信息</h4>
<p>我们一般约定函数返回值的最后一个为 <code>error</code> 类型，我们可以使用 <code>errors.New()</code> 的方式来创建一个 <code>error</code> 数据，下面是一个使用示例：</p>
<pre><code class="language-go">package main

import (
    "errors"
    "fmt"
)

func DivideFunc(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := DivideFunc(10, 0)

    if err != nil {
        fmt.Println("process error:", err)
        return
    }
    fmt.Println("division result: ", result)
}
</code></pre>
<p>在这里，我们获取函数返回值，第一个为结果，第二个为 <code>error</code> 信息，处理 <code>error</code> 信息的时候，判断 <code>err</code> 是否为 <code>nil</code>，不为 <code>nil</code> 则说明函数在运行中发生了报错，需要处理。</p>
<p>除了 <code>errors.New()</code> 这种形式，我们也可以使用 <code>fmt.Errorf("division by zero")</code> 的方式返回一个 <code>error</code> 数据：</p>
<pre><code class="language-go">func DivideFunc(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}
</code></pre>
<h4 id="2-自定义-error">2. 自定义 error</h4>
<p>我们可以自定一个 error 信息，用于输出我们自己想要输出的信息，比如我们定义一个 <code>error</code> 信息如下：</p>
<pre><code class="language-go">type DivideError struct {
    Code int
    Msg  string
}

func (e *DivideError) Error() string {
    return fmt.Sprintf("error_code:%d, error_msg:%s", e.Code, e.Msg)
}
</code></pre>
<p>在这里，我们使用定义的 <code>DivideError</code> 实现了 <code>error</code> 接口的 <code>Error()</code> 方法，所以可以直接作为 <code>error</code> 类型返回，下面是使用的示例：</p>
<pre><code class="language-go">func DivideFunc(a, b int) (int, error) {
    if b == 0 {
        err := &amp;DivideError{Code: -1, Msg: "division by zero"}
        return 0, err
    }
    return a / b, nil
}
</code></pre>
<h4 id="3-检查特定-error-类型">3. 检查特定 error 类型</h4>
<p>用于判断和检查特定的 error 类型的函数有两个，一个是 <code>errors.Is()</code>，一个是 <code>errors.As()</code>。</p>
<p><code>errors.Is()</code> 用于判断返回的错误信息是否是某个特定错误实例，而 <code>errors.As()</code> 用于判断错误信息是否是某个特定类型，即进行类型断言。</p>
<p>以下是两个函数的使用示例：</p>
<h5 id="1-errorsis">1) errors.Is()</h5>
<pre><code class="language-go">type DivideError struct {
	Code int
	Msg  string
}

func (e *DivideError) Error() string {
    return fmt.Sprintf("error_code:%d, error_msg:%s", e.Code, e.Msg)
}

var divideError = &amp;DivideError{Code: -1, Msg: "division by zero"}

func DivideFunc(a, b int) (int, error) {
    if b == 0 {
        return 0, divideError
    }
    return a / b, nil
}

func main() {
    result, err := DivideFunc(10, 0)

    if err != nil {
        if errors.Is(err, divideError) {
            fmt.Println("divideError: ", err)
        } else {
            fmt.Println("other error info: ", err)
        }
    }
    fmt.Println("division result: ", result)
}

</code></pre>
<p>在这里，先对 <code>DivideError</code> 进行了一个实例化 <code>divideError</code>，在返回错误信息后，使用 <code>errors.Is()</code> 判断是否是该错误。</p>
<h5 id="2-errorsas">2) errors.As()</h5>
<p>errors.As() 操作如下：</p>
<pre><code class="language-go">type DivideError struct {
	Code int
	Msg  string
}

func (e *DivideError) Error() string {
    return fmt.Sprintf("error_code:%d, error_msg:%s", e.Code, e.Msg)
}

var divideError = &amp;DivideError{Code: -1, Msg: "division by zero"}

func DivideFunc(a, b int) (int, error) {
    if b == 0 {
        return 0, divideError
    }
    return a / b, nil
}

func main() {
    result, err := DivideFunc(10, 0)

    if err != nil {
        var divErr *DivideError
        if errors.As(err, &amp;divErr) {
            fmt.Println("divideError: ", err, divErr.Code, divErr.Msg)
        } else {
            fmt.Println("other error info: ", err)
        }
    }
    fmt.Println("division result: ", result)
}
</code></pre>
<p>在这里，我们定义了一个 <code>divErr</code> 变量，并使用 <code>errors.As()</code> 函数对其进行类型断言，因此，在后面我们我们可以直接通过 <code>divErr</code> 获取到对应的 <code>Code</code> 和 <code>Msg</code> 信息。</p>
<p>以上就是本篇笔记关于 <code>defer</code>、<code>panic</code> 和 <code>error</code> 的相关内容介绍，在实际程序中，我们一般使用 <code>error</code> 来返回一些可预料，可恢复的错误，并在函数调用结束之后捕获到该错误，并决定接下来的程序应该如何操作。</p>
<p>而 <code>panic</code> 则包括主动触发和运行时的被动触发，主动触发为当我们程序运行中遇上一些可能无法继续运行的错误，我们可以选择 <code>panic</code> 并结束程序运行，而运行时的被动触发则是我们无法预料到的一些错误，从而被动中止程序运行。</p>
<p>在触发 <code>panic</code> 后，程序会中止运行，如果我们有一些需要关闭资源的操作，我们可以在开启资源调用的时候就使用 <code>defer</code> 操作来预防程序中止后无法关闭资源的问题，同时我们可以在 <code>defer</code> 中使用 <code>recover</code> 操作来捕获到 <code>panic</code> 信息并输出到日志或采用其他能通知到程序运行者的方式。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 23:39">2025-07-16 23:38</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">91</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18988610);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18988610', targetLink: 'https://www.cnblogs.com/hunterxiong/p/18988610', title: 'Golang基础笔记十二之defer、panic、error' })">举报</a>
</div>
        