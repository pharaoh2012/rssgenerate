
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18823241" title="发布于 2025-04-21 08:15">
    <span role="heading" aria-level="2">面试官：SpringBoot 工程启动以后，希望将数据库中已有的固定内容提前加载到 Redis 缓存中，应该如何处理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这个问题说白了就是希望通过预加载数据，达到提升系统性能和响应速度的效果。像目前在很多场景中都有使用：</p>
<ul>
<li>电商平台的商品分类信息、用户基础资料：避免高并发时数据库被重复查询，降低响应延迟。</li>
<li>系统参数配置（如地区编码、权限规则）、国际化资源：减少对配置中心或数据库的依赖，提升配置读取速度。</li>
<li>促销活动的商品库存信息、新闻头条内容：通过预加载防止缓存击穿，应对突发流量。</li>
</ul>
<p>题目说的是提前加载的redis缓存中，像配置类信息等这种变更频率低、实时性要求低的数据，还会加载到本地缓存中（如<a href="https://www.seven97.top/tool-library/guava/guava-cache.html" target="_blank" rel="noopener nofollow">GuavaCache</a>，<a href="https://www.seven97.top/system-design/cache-column/caffeine.html" target="_blank" rel="noopener nofollow">Caffeine</a>等），进一步减轻redis的压力，提升访问速度</p>
<h2 id="重点">重点</h2>
<p>重点其实就是利用<a href="https://www.seven97.top/framework/spring/extentions-use.html" target="_blank" rel="noopener nofollow">Spring 或 SpringBoot的扩展点</a>来完成这部分功能</p>
<h3 id="初始化数据加载触发机制">初始化数据加载触发机制</h3>
<ol>
<li>使用 CommandLineRunner或ApplicationRunner 在应用启动时自动执行数据加载逻辑。这是最常见的实现方式。</li>
</ol>
<pre><code class="language-java">@Component
public class CacheWarmupRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        // 分页加载数据到缓存
        PageHelper.startPage(1, 1000);
        List&lt;Product&gt; products = productMapper.selectAll();
        products.forEach(p -&gt; redisTemplate.opsForHash().put("products", p.getId(), p));
    }
}
</code></pre>
<ol start="2">
<li>使用 @PostConstruct 注解<br>
在服务类中通过 @Postconstruct 注解标记等初始化方法，在 Bean 创建后立即执行数据加载</li>
</ol>
<pre><code class="language-java">@Service
public class CachePreloader {
    @Autowired
    private UserService userService;
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @PostConstruct
    public void init() {
        List&lt;User&gt; users = userService.getAllFixedData(); // 从数据库获取数据
        users.forEach(user -&gt; 
            redisTemplate.opsForValue().set("user:" + user.getId(), user)
        );
    }
}
</code></pre>
<h3 id="结合缓存注解主动触发">结合缓存注解主动触发</h3>
<p>使用 @Cacheable 注解：在首次调用方法时触发缓存写入，强制触发缓存写入。但需手动触发首次调用才能完成预加载</p>
<pre><code class="language-java">@Service
public class UserService {
    @Cacheable(value = "users", key = "#root.methodName")
    public List&lt;User&gt; getAllFixedData() {
        return userRepository.findAll(); // 首次调用会写入缓存
    }
}
</code></pre>
<h2 id="注意">注意</h2>
<ul>
<li>推荐方案：使用 CommandlineRunner 或 @PostConstruct 在启动时主动加载数据到Redis，确保缓存立即可用。</li>
<li>注解补充：@Cacheable 适用于懒加载场景，但需结合首次调用触发。</li>
<li>注意事项：确保实体类实现 Serializable 接口，并正确配置 RedisTemplate 的序列化方式.</li>
</ul>
<h2 id="扩展知识">扩展知识</h2>
<p>关于<a href="https://mp.weixin.qq.com/s/O0W6vCuqQfeAH0UB7elpeA" target="_blank" rel="noopener nofollow">Spring 和 SpringBoot的扩展点</a>我已经写过一篇文章详细介绍，可以点击查看了解</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202409081448393.jpg" alt="spring扩展点执行顺序" loading="lazy"></p>
<h3 id="commandlinerunner和applicationrunner">CommandLineRunner和ApplicationRunner</h3>
<blockquote>
<p>org.springframework.boot.CommandLineRunner</p>
</blockquote>
<h4 id="介绍">介绍</h4>
<p>这两个是Springboot中新增的扩展点，之所以将这两个扩展点放在一起，是因为它两个功能特性高度相似，不同的只是名字、扩展方法形参数类型、执行先后的一些小的不同。</p>
<p>这两个接口触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p>
<p>注意：</p>
<ul>
<li>CommandLineRunner和ApplicationRunner都有一个扩展方法run()，但是run()形参数类型不同；</li>
<li>CommandLineRunner.run()方法的形参数类型是String... args，ApplicationRunner.run()的形参数类型是ApplicationArguments args；</li>
<li>CommandLineRunner.run()的执行时机要晚于ApplicationRunner.run()一点；</li>
<li>CommandLineRunner和ApplicationRunner触发执行时机是在Spring容器、Tomcat容器正式启动完成后，可以正式处理业务请求前，即项目启动的最后一步；</li>
<li>CommandLineRunner和ApplicationRunner可以应用的场景：项目启动前，热点数据的预加载、清除临时文件、读取自定义配置信息等；</li>
</ul>
<h4 id="使用场景">使用场景</h4>
<ol>
<li>初始化数据：使用 <code>CommandLineRunner</code> 可以在应用启动后初始化一些必要的数据，例如从数据库加载某些配置或插入初始数据。</li>
</ol>
<pre><code class="language-java">@Component
public class DataInitializer implements CommandLineRunner {

    @Override
    public void run(String... args) {
        System.out.println("初始化数据：插入初始数据");
        // 模拟插入初始数据
        insertInitialData();
    }

    private void insertInitialData() {
        System.out.println("插入数据：用户表初始数据");
    }
}
</code></pre>
<ol start="2">
<li>启动后执行任务：使用 <code>CommandLineRunner</code> 可以在应用启动后执行一些特定的任务，比如发送一个通知或启动一些背景任务。</li>
</ol>
<pre><code class="language-java">@Component
public class TaskExecutor implements CommandLineRunner {

    @Override
    public void run(String... args) {
        System.out.println("启动后执行任务：发送启动通知");
        // 模拟发送启动通知
        sendStartupNotification();
    }

    private void sendStartupNotification() {
        System.out.println("通知：应用已启动");
    }
}
</code></pre>
<ol start="3">
<li>读取命令行参数：使用 <code>CommandLineRunner</code> 可以获取并处理命令行参数，这对于需要根据启动参数动态配置应用的场景非常有用。</li>
</ol>
<pre><code class="language-java">@Component
public class CommandLineArgsProcessor implements CommandLineRunner {

    @Override
    public void run(String... args) {
        System.out.println("处理命令行参数：");
        for (String arg : args) {
            System.out.println("参数：" + arg);
        }
    }
}

@SpringBootApplication
public class AppConfig {
    public static void main(String[] args) {
        SpringApplication.run(AppConfig.class, new String[]{"参数1", "参数2", "参数3"});
    }
}
</code></pre>
<h3 id="postconstruct">@PostConstruct</h3>
<blockquote>
<p>javax.annotation.PostConstruct</p>
</blockquote>
<h4 id="介绍-1">介绍</h4>
<p>可以看出来其本身不是Spring定义的注解，但是Spring提供了具体的实现。这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了<code>@PostConstruct</code>，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p>
<p>注意：</p>
<ul>
<li>使用@PostConstruct注解标记的方法不能有参数，除非是拦截器，可以采用拦截器规范定义的InvocationContext对象。</li>
<li>使用@PostConstruct注解标记的方法不能有返回值，实际上如果有返回值，也不会报错，但是会忽略掉；</li>
<li>使用@PostConstruct注解标记的方法不能被static修饰，但是final是可以的；</li>
</ul>
<h4 id="使用场景-1">使用场景</h4>
<p>使用场景与 InitializingBean 类似，具体看下文</p>
<h3 id="initializingbean">InitializingBean</h3>
<blockquote>
<p>org.springframework.beans.factory.InitializingBean</p>
</blockquote>
<h4 id="介绍-2">介绍</h4>
<p>这个类，顾名思义，也是用来初始化bean的。<code>InitializingBean</code>接口为bean提供了初始化方法的方式，它只在bean实例化、属性注入后的提供了一个扩展点<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始前、属性赋值后，都会执行该方法。这个<strong>扩展点的触发时机</strong>在<code>postProcessAfterInitialization</code>之前。</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202409031058389.png" alt="" loading="lazy"></p>
<p>注意：</p>
<ul>
<li>与InitializingBean#afterPropertiesSet()类似效果的是<code>init-method</code>，但是需要注意的是InitializingBean#afterPropertiesSet()执行时机要略早于init-method；</li>
<li>InitializingBean#afterPropertiesSet()的调用方式是在bean初始化过程中真接调用bean的afterPropertiesSet()；</li>
<li>bean自定义属性init-method是通过java反射的方式进行调用 ；</li>
</ul>
<h4 id="使用场景-2">使用场景</h4>
<ol>
<li>初始化资源：可以在 Bean 初始化后自动启动一些资源，如数据库连接、文件读取等。</li>
</ol>
<pre><code class="language-java">import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

@Component
public class ResourceInitializer implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // 模拟资源初始化
        System.out.println("资源初始化：建立数据库连接");
    }

    public void performAction() {
        System.out.println("资源使用：执行数据库操作");
    }
}
    
@Configuration
@ComponentScan(basePackages = "com.seven")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        ResourceInitializer initializer = context.getBean(ResourceInitializer.class);
        initializer.performAction();
    }
}
</code></pre>
<ol start="2">
<li>设置初始值</li>
</ol>
<pre><code class="language-java">@Component
public class InitialValueSetter implements InitializingBean {

    private String initialValue;

    @Override
    public void afterPropertiesSet() {
        initialValue = "默认值";
        System.out.println("设置初始值：" + initialValue);
    }

    public void printValue() {
        System.out.println("当前值：" + initialValue);
    }
}

@Configuration
@ComponentScan(basePackages = "com.seven")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        InitialValueSetter valueSetter = context.getBean(InitialValueSetter.class);
        valueSetter.printValue();
    }
}
</code></pre>
<ol start="3">
<li>加载配置：可以在 Bean 初始化后加载必要的配置，如从文件或数据库中读取配置。</li>
</ol>
<pre><code class="language-java">@Component
public class ConfigLoader implements InitializingBean {

    private String configValue;

    @Override
    public void afterPropertiesSet() {
        // 模拟配置加载
        configValue = "配置值";
        System.out.println("加载配置：" + configValue);
    }

    public void printConfig() {
        System.out.println("当前配置：" + configValue);
    }
}

@Configuration
@ComponentScan(basePackages = "com.seven")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        ConfigLoader configLoader = context.getBean(ConfigLoader.class);
        configLoader.printConfig();
    }
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03920769182523148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-21 08:15">2025-04-21 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18823241);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18823241', targetLink: 'https://www.cnblogs.com/seven97-top/p/18823241', title: '面试官：SpringBoot 工程启动以后，希望将数据库中已有的固定内容提前加载到 Redis 缓存中，应该如何处理' })">举报</a>
</div>
        