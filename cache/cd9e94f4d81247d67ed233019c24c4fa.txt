
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/densen2014/p/18897768" title="发布于 2025-05-27 01:05">
    <span role="heading" aria-level="2">Github Copilot 实战: 从零开始用AI写一个OCR工具 (1)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>最近AI很火,咱也尝试一下由浅入深探索一下 Github Copilot 的能力和底限.<br>
使用的环境是 Windows11 + Microsoft Visual Studio Enterprise 2022 (64 位) - Current 版本 17.13.7 + VS内置的 Github Copilot Pro</p>
<h3 id="首先创建wpf工程">首先创建wpf工程</h3>
<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net9.0-windows&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
  &lt;/PropertyGroup&gt;
    &lt;ItemGroup&gt; 
        &lt;PackageReference Include="OpenCvSharp4.runtime.win" Version="4.11.0.20250507" /&gt;
        &lt;PackageReference Include="Sdcb.OpenVINO.PaddleOCR" Version="0.6.8" /&gt;
        &lt;PackageReference Include="Sdcb.OpenVINO.PaddleOCR.Models.Online" Version="0.6.2" /&gt;
        &lt;PackageReference Include="Sdcb.OpenVINO.runtime.win-x64" Version="2025.0.0" /&gt;
    &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>简单放置一个本地ocr服务</p>
<pre><code>using OpenCvSharp;
using Sdcb.OpenVINO.PaddleOCR;
using Sdcb.OpenVINO.PaddleOCR.Models;
using Sdcb.OpenVINO.PaddleOCR.Models.Online;
using System.Diagnostics;
using System.Net.Http;

namespace JovenApi;

public class PaddleOCRService
{

    public static bool IsUrl(string filename)
    {
        return Uri.TryCreate(filename, UriKind.Absolute, out var uriResult)
               &amp;&amp; (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);
    }

    public async Task&lt;(List&lt;string&gt; strings, PaddleOcrResult result)&gt; StartOCR(string filename)
    {
        Mat src;

        if (string.IsNullOrEmpty(filename))
        {
            throw new ArgumentNullException(nameof(filename));
        }

        if (IsUrl(filename))
        {
            src = Cv2.ImDecode(await new HttpClient().GetByteArrayAsync(filename), ImreadModes.Color);
        }
        else
        {
            src = Cv2.ImRead(filename);
        }

        return await StartOCR(src);
    }

    public async Task&lt;(List&lt;string&gt; strings, PaddleOcrResult result)&gt; StartOCR(byte[] imageData)
    {
        Mat src;

        ArgumentNullException.ThrowIfNull(imageData);

        src = Cv2.ImDecode(imageData, ImreadModes.Color);
        return await StartOCR(src);
    }

    public async Task&lt;(List&lt;string&gt; strings, PaddleOcrResult result)&gt; StartOCR(Mat src)
    {
        PaddleOcrResult result;
        var resultText = new List&lt;string&gt;();
        FullOcrModel model = await OnlineFullModels.ChineseV3.DownloadAsync();

        using (PaddleOcrAll all = new(model)
        {
            AllowRotateDetection = true,
            Enable180Classification = true,
        })
        {
            Stopwatch sw = Stopwatch.StartNew();
            result = all.Run(src);
            Console.WriteLine($"elapsed={sw.ElapsedMilliseconds} ms");
            Console.WriteLine("Detected all texts: \n" + result.Text);
            foreach (PaddleOcrResultRegion region in result.Regions)
            {
                Console.WriteLine($"Text: {region.Text}, Score: {region.Score}, RectCenter: {region.Rect.Center}, RectSize:    {region.Rect.Size}, Angle: {region.Rect.Angle}");
                resultText.Add(region.Text);
            }
        }
        src.Dispose();
        return (resultText, result);
    }
}
</code></pre>
<h3 id="a-提示词-实现拖放粘贴图片或者点击打开选择文件获取一张图片-并且调用ocr服务将结果绘图到原图上-右边显示相应的文本">A. 提示词 "实现拖放,粘贴图片或者点击打开选择文件获取一张图片, 并且调用ocr服务,将结果绘图到原图上, 右边显示相应的文本"</h3>
<p>下面是一个完整的 WPF 方案，支持拖放图片、粘贴图片、点击选择图片，并调用 OCR 服务，将识别结果绘制到原图上，右侧显示文本。代码已适配你的 PaddleOCRService，并假设其 StartOCR(byte[] image) 返回识别结果（如文本框列表）。</p>
<ol>
<li>MainWindow.xaml（UI布局）</li>
</ol>
<pre><code>&lt;Window x:Class="MiOcr.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MiOcr" Height="600" Width="900"
        AllowDrop="True"
        KeyDown="Window_KeyDown"
        Drop="Window_Drop"
        &gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="2*"/&gt;
            &lt;ColumnDefinition Width="*"/&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Border Grid.Column="0" Margin="10" BorderBrush="Gray" BorderThickness="1" Background="#FFF"
                MouseLeftButtonUp="ImageBorder_MouseLeftButtonUp"
                AllowDrop="True"
                Drop="ImageBorder_Drop"
                &gt;
            &lt;Image x:Name="MainImage" Stretch="Uniform" /&gt;
        &lt;/Border&gt;
        &lt;ScrollViewer Grid.Column="1" Margin="10"&gt;
            &lt;TextBox x:Name="OcrTextBox" AcceptsReturn="True" VerticalScrollBarVisibility="Auto" TextWrapping="Wrap" FontSize="16"/&gt;
        &lt;/ScrollViewer&gt;
        &lt;Button Content="选择图片" Width="100" Height="30" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="20"
                Click="SelectImageButton_Click"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>
<ol start="2">
<li>MainWindow.xaml.cs（核心逻辑）</li>
</ol>
<pre><code>using JovenApi;
using Microsoft.Win32;
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media.Imaging;
using System.Windows.Media;
using System.Windows.Controls;
using System.Collections.Generic;

namespace MiOcr;
public partial class MainWindow : Window
{
    private BitmapImage? _currentImage;
    private byte[]? _currentImageBytes;

    public MainWindow()
    {
        InitializeComponent();
        this.PreviewDragOver += (s, e) =&gt; e.Handled = true; // 允许拖放
        this.PreviewKeyDown += Window_KeyDown;
    }

    // 拖放图片
    private async void Window_Drop(object sender, DragEventArgs e)
    {
        if (e.Data.GetDataPresent(DataFormats.FileDrop))
        {
            var files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (files.Length &gt; 0 &amp;&amp; IsImageFile(files[0]))
            {
                await LoadAndOcrImage(files[0]);
            }
        }
    }

    // Border区域拖放
    private async void ImageBorder_Drop(object sender, DragEventArgs e)
    {
        await Window_Drop(sender, e);
    }

    // 粘贴图片
    private async void Window_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Key == Key.V &amp;&amp; (Keyboard.Modifiers &amp; ModifierKeys.Control) == ModifierKeys.Control)
        {
            if (Clipboard.ContainsImage())
            {
                var img = Clipboard.GetImage();
                if (img != null)
                {
                    var bmp = BitmapFromClipboard(img);
                    using var ms = new MemoryStream();
                    var encoder = new PngBitmapEncoder();
                    encoder.Frames.Add(BitmapFrame.Create(bmp));
                    encoder.Save(ms);
                    await LoadAndOcrImage(ms.ToArray());
                }
            }
        }
    }

    // 点击选择图片
    private async void SelectImageButton_Click(object sender, RoutedEventArgs e)
    {
        var dlg = new OpenFileDialog
        {
            Filter = "图片文件|*.jpg;*.jpeg;*.png;*.bmp;*.gif"
        };
        if (dlg.ShowDialog() == true)
        {
            await LoadAndOcrImage(dlg.FileName);
        }
    }

    // 点击图片区域也可选择图片
    private async void ImageBorder_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        await SelectImageButton_Click(sender, e);
    }

    // 加载图片并调用OCR
    private async Task LoadAndOcrImage(string filePath)
    {
        _currentImageBytes = await File.ReadAllBytesAsync(filePath);
        _currentImage = new BitmapImage(new Uri(filePath));
        MainImage.Source = _currentImage;
        await RunOcrAndDraw(_currentImageBytes);
    }

    // 加载图片并调用OCR（字节流）
    private async Task LoadAndOcrImage(byte[] imageBytes)
    {
        _currentImageBytes = imageBytes;
        using var ms = new MemoryStream(imageBytes);
        var bmp = new BitmapImage();
        bmp.BeginInit();
        bmp.CacheOption = BitmapCacheOption.OnLoad;
        bmp.StreamSource = ms;
        bmp.EndInit();
        bmp.Freeze();
        _currentImage = bmp;
        MainImage.Source = _currentImage;
        await RunOcrAndDraw(imageBytes);
    }

    // OCR并绘制
    private async Task RunOcrAndDraw(byte[] imageBytes)
    {
        OcrTextBox.Text = "识别中...";
        var ocr = new PaddleOCRService();
        var results = await ocr.StartOCR(imageBytes);
        if (results == null || results.Count == 0)
        {
            OcrTextBox.Text = "未识别到文本";
            return;
        }
        // 假设results为List&lt;OcrResult&gt;，每个OcrResult有Text和Box（左上、右下坐标）
        // 你需要根据PaddleOCRService的返回类型适配
        OcrTextBox.Text = string.Join(Environment.NewLine, results.Select(r =&gt; r.Text));

        // 绘制识别框和文字
        var drawed = DrawOcrResultsOnImage(_currentImage, results);
        MainImage.Source = drawed;
    }

    // 判断文件是否为图片
    private bool IsImageFile(string file)
    {
        var ext = System.IO.Path.GetExtension(file).ToLower();
        return ext == ".jpg" || ext == ".jpeg" || ext == ".png" || ext == ".bmp" || ext == ".gif";
    }

    // 从ClipboardBitmapSource转BitmapSource
    private BitmapSource BitmapFromClipboard(BitmapSource src)
    {
        var encoder = new PngBitmapEncoder();
        encoder.Frames.Add(BitmapFrame.Create(src));
        using var ms = new MemoryStream();
        encoder.Save(ms);
        ms.Position = 0;
        var bmp = new BitmapImage();
        bmp.BeginInit();
        bmp.CacheOption = BitmapCacheOption.OnLoad;
        bmp.StreamSource = ms;
        bmp.EndInit();
        bmp.Freeze();
        return bmp;
    }

    // 绘制OCR结果到图片
    private BitmapSource DrawOcrResultsOnImage(BitmapImage? image, List&lt;OcrResult&gt; results)
    {
        if (image == null) return null!;
        int width = image.PixelWidth;
        int height = image.PixelHeight;

        var visual = new DrawingVisual();
        using (var dc = visual.RenderOpen())
        {
            dc.DrawImage(image, new Rect(0, 0, width, height));
            var pen = new Pen(Brushes.Red, 2);
            var typeface = new Typeface("Arial");
            foreach (var r in results)
            {
                // 假设 r.Box 是 int[4] 或 Point[]，请根据实际类型适配
                var box = r.Box; // 例如: [x1, y1, x2, y2]
                dc.DrawRectangle(null, pen, new Rect(box[0], box[1], box[2] - box[0], box[3] - box[1]));
                var formattedText = new FormattedText(
                    r.Text,
                    System.Globalization.CultureInfo.CurrentCulture,
                    FlowDirection.LeftToRight,
                    typeface,
                    20,
                    Brushes.Yellow,
                    1.25);
                dc.DrawText(formattedText, new Point(box[0], box[1] - 24));
            }
        }
        var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
        bmp.Render(visual);
        bmp.Freeze();
        return bmp;
    }
}

// 假设OCR结果类型如下，实际请根据PaddleOCRService返回类型调整
public class OcrResult
{
    public string Text { get; set; }
    public int[] Box { get; set; } // [x1, y1, x2, y2]
}

</code></pre>
<p>说明<br>
•	拖放：支持将图片文件拖到窗口或图片区域。<br>
•	粘贴：Ctrl+V 粘贴剪贴板图片。<br>
•	点击选择：点击图片区域或按钮弹出文件选择对话框。<br>
•	OCR调用：调用 PaddleOCRService.StartOCR(byte[])，并假设返回 List<ocrresult>，每个包含 Text 和 Box。<br>
•	绘图：在图片上绘制识别框和文字，右侧显示所有识别文本。<br>
•	UI：左侧图片，右侧文本，顶部有“选择图片”按钮。<br>
如 PaddleOCRService 返回类型不同，请补充其定义，我可帮你适配。<br>
如需支持多种图片格式或更复杂的坐标，请补充说明。</ocrresult></p>
<p>到这里,一个基本框架居然就完成了. 运行起来也差不多达到预期. 真是惊为天人.</p>
<h3 id="修正一下提示词-返回的-resultsresult-类型为-paddleocrresult">修正一下,提示词 "返回的 results.result 类型为 PaddleOcrResult"</h3>
<p>非常好，PaddleOCRService.StartOCR 返回的 results.result 类型为 PaddleOcrResult。<br>
PaddleOcrResult 结构如下（基于 Sdcb.OpenVINO.PaddleOCR 官方文档和源码）：</p>
<pre><code>public class PaddleOcrResult
{
    public List&lt;PaddleOcrResultRegion&gt; Regions { get; set; }
}

public class PaddleOcrResultRegion
{
    public string Text { get; set; }
    public float Score { get; set; }
    public RotatedRect Rect { get; set; }
    // 还有 PolyPoints、Label 等属性
}
</code></pre>
<p>•	Rect 是 RotatedRect，包含中心点、尺寸、角度。<br>
•	PolyPoints 是多边形点（通常为4个点，顺时针/逆时针），可用于绘制识别框。</p>
<p>你的代码应这样处理：</p>
<ol>
<li>
<p>显示文本<br>
OcrTextBox.Text = string.Join(Environment.NewLine, results.result.Regions.Select(r =&gt; r.Text));</p>
</li>
<li>
<p>绘制识别框和文字<br>
建议用 PolyPoints 绘制多边形框，Rect.Center 作为文字起点。</p>
</li>
</ol>
<pre><code>private BitmapSource DrawOcrResultsOnImage(BitmapImage? image, PaddleOcrResult result)
{
    if (image == null) return null!;
    int width = image.PixelWidth;
    int height = image.PixelHeight;

    var visual = new DrawingVisual();
    using (var dc = visual.RenderOpen())
    {
        dc.DrawImage(image, new Rect(0, 0, width, height));
        var pen = new Pen(Brushes.Red, 2);
        var typeface = new Typeface("Arial");
        foreach (var region in result.Regions)
        {
            // 绘制多边形框
            if (region.PolyPoints != null &amp;&amp; region.PolyPoints.Length &gt;= 4)
            {
                var points = region.PolyPoints.Select(p =&gt; new System.Windows.Point(p.X, p.Y)).ToArray();
                var polygon = new System.Windows.Media.PolyLineSegment(points, true);
                var figure = new PathFigure(points[0], new[] { polygon }, true);
                var geometry = new PathGeometry(new[] { figure });
                dc.DrawGeometry(null, pen, geometry);
            }
            // 绘制文字
            var formattedText = new FormattedText(
                region.Text,
                System.Globalization.CultureInfo.CurrentCulture,
                FlowDirection.LeftToRight,
                typeface,
                20,
                Brushes.Yellow,
                1.25);
            dc.DrawText(formattedText, new System.Windows.Point(region.Rect.Center.X, region.Rect.Center.Y));
        }
    }
    var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
    bmp.Render(visual);
    bmp.Freeze();
    return bmp;
}

</code></pre>
<ol start="3">
<li>调用方式</li>
</ol>
<pre><code>var drawed = DrawOcrResultsOnImage(_currentImage, results.result);
MainImage.Source = drawed;
</code></pre>
<p>总结<br>
•	results.result 是 PaddleOcrResult，其 Regions 为每个识别区域。<br>
•	推荐用 PolyPoints 绘制多边形框，region.Text 作为识别文本。<br>
•	右侧文本框用 string.Join(Environment.NewLine, results.result.Regions.Select(r =&gt; r.Text))。</p>
<h3 id="继续修正提示词-绘制多边形框方法有点错误-根据-consolewritelinetext-regiontext-score-regionscore-rectcenter-regionrectcenter-rectsize----regionrectsize-angle-regionrectangle-修正一下">继续修正,提示词 "绘制多边形框方法有点错误, 根据 Console.WriteLine($"Text: {region.Text}, Score: {region.Score}, RectCenter: {region.Rect.Center}, RectSize:    {region.Rect.Size}, Angle: {region.Rect.Angle}"); 修正一下"</h3>
<p>你当前的绘制方法有误，因为 region.Rect 是 RotatedRect，它不是点集合，而是一个带有中心点、尺寸和角度的旋转矩形。<br>
正确做法是：使用 region.Rect.GetVertices() 获取多边形的四个顶点，然后用这些点绘制多边形框。<br>
请将 DrawOcrResultsOnImage 方法中的多边形绘制部分修正如下：</p>
<pre><code>private BitmapSource DrawOcrResultsOnImage(BitmapImage? image, PaddleOcrResult result)
{
    if (image == null) return null!;
    int width = image.PixelWidth;
    int height = image.PixelHeight;

    var visual = new DrawingVisual();
    using (var dc = visual.RenderOpen())
    {
        dc.DrawImage(image, new Rect(0, 0, width, height));
        var pen = new Pen(Brushes.Red, 2);
        var typeface = new Typeface("Arial");
        foreach (var region in result.Regions)
        {
            // 正确获取四个顶点
            var vertices = region.Rect.GetVertices(); // 返回 PointF[]，长度为4
            var points = vertices.Select(p =&gt; new System.Windows.Point(p.X, p.Y)).ToArray();

            // 绘制多边形
            var figure = new PathFigure(points[0], new[] { new PolyLineSegment(points.Skip(1), true) }, true);
            var geometry = new PathGeometry(new[] { figure });
            dc.DrawGeometry(null, pen, geometry);

            // 绘制文字（以中心点为准）
            var formattedText = new FormattedText(
                region.Text,
                System.Globalization.CultureInfo.CurrentCulture,
                FlowDirection.LeftToRight,
                typeface,
                20,
                Brushes.Yellow,
                1.25);
            dc.DrawText(formattedText, new System.Windows.Point(region.Rect.Center.X, region.Rect.Center.Y));
        }
    }
    var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
    bmp.Render(visual);
    bmp.Freeze();
    return bmp;
}
</code></pre>
<p>关键修正说明：<br>
•	用 region.Rect.GetVertices() 获取四个顶点，而不是直接遍历 Rect。<br>
•	用 PolyLineSegment 和 PathFigure 绘制闭合多边形。<br>
•	文字仍然以 region.Rect.Center 为基准绘制。</p>
<h3 id="这个时候还是有错误-ai需要继续引导一下--提示词-regionrect-的定义是-point2f-center-size2f-size-float-angle">这个时候还是有错误, AI需要继续引导一下 , 提示词 "region.Rect 的定义是 Point2f center, Size2f size, float angle"</h3>
<p>感谢补充，region.Rect 是 RotatedRect，其定义为：</p>
<pre><code>public struct RotatedRect
{
    public Point2f Center; // 中心点
    public Size2f Size;    // 宽高
    public float Angle;    // 旋转角度（度）
}
</code></pre>
<p>正确绘制多边形框的方法是：<br>
•	使用 region.Rect.GetVertices() 获取四个顶点（Point2f[]，顺序为左上、右上、右下、左下）。<br>
•	用这些点绘制闭合多边形。<br>
你的代码如下即可：</p>
<pre><code>private BitmapSource DrawOcrResultsOnImage(BitmapImage? image, PaddleOcrResult result)
{
    if (image == null) return null!;
    int width = image.PixelWidth;
    int height = image.PixelHeight;

    var visual = new DrawingVisual();
    using (var dc = visual.RenderOpen())
    {
        dc.DrawImage(image, new Rect(0, 0, width, height));
        var pen = new Pen(Brushes.Red, 2);
        var typeface = new Typeface("Arial");
        foreach (var region in result.Regions)
        {
            // 获取四个顶点
            var vertices = region.Rect.GetVertices(); // Point2f[]，长度4
            var points = vertices.Select(p =&gt; new System.Windows.Point(p.X, p.Y)).ToArray();

            // 绘制多边形
            var figure = new PathFigure(points[0], new[] { new PolyLineSegment(points.Skip(1), true) }, true);
            var geometry = new PathGeometry(new[] { figure });
            dc.DrawGeometry(null, pen, geometry);

            // 绘制文字（以中心点为准）
            var formattedText = new FormattedText(
                region.Text,
                System.Globalization.CultureInfo.CurrentCulture,
                FlowDirection.LeftToRight,
                typeface,
                20,
                Brushes.Yellow,
                1.25);
            dc.DrawText(formattedText, new System.Windows.Point(region.Rect.Center.X, region.Rect.Center.Y));
        }
    }
    var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
    bmp.Render(visual);
    bmp.Freeze();
    return bmp;
}

</code></pre>
<p>要点说明：<br>
•	region.Rect.GetVertices() 是最安全、最准确的方式获取旋转矩形的四个顶点。<br>
•	直接用 Center、Size、Angle 计算顶点较为繁琐，库已封装好。<br>
•	文字建议以 region.Rect.Center 为锚点绘制。<br>
这样即可正确绘制 PaddleOCR 识别区域的旋转矩形框和文本。</p>
<h3 id="本节成果">本节成果</h3>
<p><img src="https://img2024.cnblogs.com/blog/1980213/202505/1980213-20250527010431978-205633292.png" alt="" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    <h4 id="关联项目">关联项目</h4>
<p><font color="blue">FreeSql QQ群：4336577</font></p>
<p><font color="blue">BA &amp; Blazor QQ群：795206915</font></p>
<p><font color="blue">Maui Blazor 中文社区 QQ群：645660665</font></p>
<h4 id="知识共享许可协议">知识共享许可协议</h4>
<p>本作品采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但务必保留文章署名AlexChow（包含链接： <a href="https://github.com/densen2014" target="_blank" rel="noopener">https://github.com/densen2014</a> ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请<a href="zhouchuanglin@gmail.com" target="_blank" rel="noopener">与我联系</a> 。</p>
<h4 id="转载声明">转载声明</h4>
<p>本文来自博客园，作者：周创琳 <a href="https://www.cnblogs.com/densen2014/" target="_blank">AlexChow</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/densen2014/p/18897768" target="_blank">https://www.cnblogs.com/densen2014/p/18897768</a></p>
<h4 id="alexchow">AlexChow</h4>
<p><a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAGMBzlmgJx0rytwH08AEEY8F0wIVXB2soJXXdUP3ohAE/?" target="_blank" rel="noopener">今日头条</a> | <a href="https://www.cnblogs.com/densen2014" target="_blank" rel="noopener">博客园</a> | <a href="https://www.zhihu.com/people/alex-chow-54" target="_blank" rel="noopener">知乎</a> | <a href="https://gitee.com/densen2014" target="_blank" rel="noopener">Gitee</a> | <a href="https://github.com/densen2014?WT.mc_id=DT-MVP-5005078" target="_blank" rel="noopener">GitHub</a></p>

<p><img src="https://img2023.cnblogs.com/blog/1980213/202302/1980213-20230201233143321-1727894703.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.043705305623842595" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 01:17">2025-05-27 01:05</span>&nbsp;
<a href="https://www.cnblogs.com/densen2014">AlexChow</a>&nbsp;
阅读(<span id="post_view_count">1</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18897768);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18897768', targetLink: 'https://www.cnblogs.com/densen2014/p/18897768', title: 'Github Copilot 实战: 从零开始用AI写一个OCR工具 (1)' })">举报</a>
</div>
        