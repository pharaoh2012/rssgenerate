
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/weizwz/p/18689185" title="发布于 2025-01-24 10:30">
    <span role="heading" aria-level="2"># Vue3.5常用特性整理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Vue3.5 发布已近半年，抽空整理下常用的新增/改动特性</p>
<h2 id="响应式-props-解构">响应式 Props 解构</h2>
<p>Vue3.5 中 Props 正式支持解构了，并添加了响应式跟踪</p>
<h3 id="设置默认值">设置默认值</h3>
<p>使用 JavaScript 原生的默认值语法声明 props 默认值</p>
<p>以前</p>
<pre><code class="language-vue">const props = withDefaults(
  defineProps&lt;{
    count?: number
    msg?: string
  }&gt;(),
  {
    count: 0,
    msg: 'hello'
  }
)
</code></pre>
<p>现在</p>
<pre><code class="language-vue">const { count = 0, msg = 'hello' } = defineProps&lt;{
  count?: number
  message?: string
}&gt;()
</code></pre>
<h3 id="响应式解构">响应式解构</h3>
<p>当在同一个 <code>&lt;script setup&gt;</code> 代码块中访问由 <code>defineProps</code> 解构的变量时，Vue 编译器会自动在前面添加 <code>props</code></p>
<p>以前</p>
<pre><code class="language-ts">const { foo } = defineProps(['foo'])

watchEffect(() =&gt; {
  // 在 3.5 之前只运行一次
  console.log(foo)
})
</code></pre>
<p>现在</p>
<pre><code class="language-ts">const { foo } = defineProps(['foo'])

watchEffect(() =&gt; {
  // 在 3.5 中在 "foo" prop 变化时重新执行
  console.log(foo)
  // `foo` 由编译器转换为 `props.foo`，以上等同于 `console.log(props.foo)`
})
</code></pre>
<p>与之类似，监听解构的 prop 变量 或 将其传递到可组合项中同时保留响应性 时需要将其包装在 getter 中</p>
<p>以前</p>
<pre><code class="language-ts">const { foo } = defineProps(['foo'])

watch(foo, /* ... */)
</code></pre>
<p>现在：</p>
<pre><code class="language-ts">// watch(foo, /* ... */) 等价于 watch(props.foo, ...)，我们给 watch 传递的是一个值而不是响应式数据源
watch(() =&gt; foo, /* ... */)

// 传递解构的 prop 到外部函数中并保持响应性
useComposable(() =&gt; foo)
</code></pre>
<h2 id="监听watch--watcheffect-相关">监听(<code>watch</code> / <code>watcheffect</code>) 相关</h2>
<h3 id="watch-支持指定深度-deep-number">watch 支持指定深度 deep: number</h3>
<p>watch 的 <code>deep</code> 选项现在支持传入数字，来指定监听的深度</p>
<pre><code class="language-ts">const state = ref({
  a: {
    b: {
      c: 1
    }
  }
})

watch(state, (newValue) =&gt; {
    console.log(`state: ${newValue}`)
  },
  { deep: 2 }
)

state.a.b = { c: 2 } // 更改了第二层的属性，触发监听
state.a.b.c = 2 // 更改了第三层的属性，不触发监听
</code></pre>
<h3 id="清理函数-onwatchercleanup--oneffectcleanup">清理函数 onWatcherCleanup / onEffectCleanup</h3>
<p>以前我们在监听函数中要发送异步请求时，很可能发生请求参数发生变化的情况，这时我们需要设置全局变量存储 <code>AbortController</code>，并在组件卸载之前清理它</p>
<pre><code class="language-ts">import { watch, onBeforeUnmount } from "vue"

let controller = new AbortController()

watch(state, (newValue) =&gt; {
	controller.abort() // 取消上一次的请求
	controller = new AbortController()

	fetch(`/api/${newValue}`, { signal: controller.signal }).then(() =&gt; {
    // 回调逻辑
  })
});

// 组件卸载前也要清理
onBeforeUnmount(() =&gt; controller.abort())
</code></pre>
<p>现在有了清理函数 <code>onWatcherCleanup</code> / <code>onEffectCleanup</code> 后，我们可以直接调用它来清理之前的 调用(异步)函数/请求</p>
<pre><code class="language-ts">import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) =&gt; {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() =&gt; {
    // 回调逻辑
  })

  onWatcherCleanup(() =&gt; {
    // 终止过期请求
    controller.abort()
  })
})
</code></pre>
<p><code>onEffectCleanup</code> 函数写法类似以上，不同的是导入来源</p>
<pre><code class="language-ts">import { onEffectCleanup } from "@vue/reactivity";
</code></pre>
<blockquote>
<p>[!WARNING]<br>
<code>onWatcherCleanup</code> 仅在 Vue 3.5+ 中支持，并且必须在 <code>watchEffect</code> 效果函数或 <code>watch</code> 回调函数的同步执行期间调用：你不能在异步函数的 <code>await</code> 语句之后调用它。</p>
</blockquote>
<h3 id="watch-返回值增强">watch 返回值增强</h3>
<p>watch 返回值中新增 暂停/恢复侦听器，可以更细致的控制监听作用范围</p>
<pre><code class="language-ts">const { stop, pause, resume } = watch(() =&gt; {})

// 暂停侦听器
pause()

// 稍后恢复
resume()
</code></pre>
<h2 id="ssr-改进">SSR 改进</h2>
<h3 id="惰性激活-lazy-hydration">惰性激活 Lazy Hydration</h3>
<p>异步组件可以通过 <code>defineAsyncComponent() API</code> 中的 <code>hydrate</code> 选项来控制何时进行激活</p>
<h4 id="在空闲时进行激活">在空闲时进行激活</h4>
<pre><code class="language-ts">import { defineAsyncComponent, hydrateOnIdle } from 'vue'

const AsyncComp = defineAsyncComponent({
  loader: () =&gt; import('./Comp.vue'),
  hydrate: hydrateOnIdle(/* 传递可选的最大超时 */)
})
</code></pre>
<h4 id="在元素变为可见时激活">在元素变为可见时激活</h4>
<pre><code class="language-ts">import { defineAsyncComponent, hydrateOnVisible } from 'vue'

const AsyncComp = defineAsyncComponent({
  loader: () =&gt; import('./Comp.vue'),
  hydrate: hydrateOnVisible()
})
</code></pre>
<h4 id="自定义策略">自定义策略</h4>
<pre><code class="language-ts">import { defineAsyncComponent, type HydrationStrategy } from 'vue'

const myStrategy: HydrationStrategy = (hydrate, forEachElement) =&gt; {
  // forEachElement 是一个遍历组件未激活的 DOM 中所有根元素的辅助函数，
  // 因为根元素可能是一个片段而非单个元素
  forEachElement(el =&gt; {
    // ...
  })
  // 准备好时调用 `hydrate`
  hydrate()
  return () =&gt; {
    // 如必要，返回一个销毁函数
  }
}

const AsyncComp = defineAsyncComponent({
  loader: () =&gt; import('./Comp.vue'),
  hydrate: myStrategy
})
</code></pre>
<h4 id="其他">其他</h4>
<p>请查看 <a href="https://cn.vuejs.org/guide/components/async.html#lazy-hydration" target="_blank" rel="noopener nofollow">Vue3官方文档 - 惰性激活</a>，这里不再赘述</p>
<h3 id="useid-生成唯一应用id"><code>useId()</code> 生成唯一应用ID</h3>
<p>用于为无障碍属性或表单元素生成每个应用内唯一的 ID。在我们日常应用中，主要可以解决服务端和客户端生成的<code>id</code>不一样导致渲染报错的问题</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useId } from 'vue'

const id = useId()
&lt;/script&gt;

&lt;template&gt;
  &lt;form&gt;
    &lt;label :for="id"&gt;Name:&lt;/label&gt;
    &lt;input :id="id" type="text" /&gt;
  &lt;/form&gt;
&lt;/template&gt;
</code></pre>
<h3 id="data-allow-mismatch"><code>data-allow-mismatch</code></h3>
<p>如果客户端值不可避免地与其服务端对应值（例如日期）不同，我们可以使用属性 <code>data-allow-mismatch</code> 来避免由此产生的激活不匹配警告</p>
<pre><code class="language-vue">&lt;span data-allow-mismatch&gt;{{ data.toLocaleString() }}&lt;/span&gt;
</code></pre>
<p>还可以指定特定类型。允许的值有：<code>text</code>，<code>children</code> (仅允许直接子组件不匹配)，<code>class</code>，<code>style</code>，<code>attribute</code></p>
<h2 id="其他-1">其他</h2>
<h3 id="usetemplateref"><code>useTemplateRef()</code></h3>
<p>返回一个浅层 ref，可以更直观的绑定元素，同时也支持动态绑定</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, useTemplateRef, onMounted } from 'vue'

const targetRef = ref('input1')
const inputRef = useTemplateRef&lt;HTMLInputElement&gt;(targetRef.value)

onMounted(() =&gt; {
  inputRef.value.focus()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref="input1" /&gt;
	&lt;input ref="input2" /&gt;
&lt;/template&gt;
</code></pre>
<p><strong>其他不常用的就不在说明了</strong></p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="copyrightWeizwz">
    <p><span class="post-copyright-meta">文章作者：</span><span class="post-copyright-info"><a href="https://www.cnblogs.com/weizwz/" target="_blank">唯之为之</a></span></p>
    <p><span class="post-copyright-meta">文章出处：</span><span class="post-copyright-info"><a href="https://www.cnblogs.com/weizwz/p/18689185" target="_blank">https://www.cnblogs.com/weizwz/p/18689185</a></span></p>
    <p><span class="post-copyright-meta">版权声明：</span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">「CC BY-NC-SA 4.0 DEED」</a> 国际许可协议，转载请注明出处！</span></p>
    <p>内容粗浅，如有错误，欢迎大佬批评指正</p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.009643192885416667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 10:30">2025-01-24 10:30</span>&nbsp;
<a href="https://www.cnblogs.com/weizwz">唯之为之</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18689185" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18689185);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18689185', targetLink: 'https://www.cnblogs.com/weizwz/p/18689185', title: '# Vue3.5常用特性整理' })">举报</a>
</div>
        