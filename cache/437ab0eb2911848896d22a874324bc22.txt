
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hsiang/p/18710783" title="发布于 2025-02-20 00:41">
    <span role="heading" aria-level="2">Avalonia系列文章之样式与主题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        随着社会的发展，大家对软件的要求，从最初的命令行输入输出，到可视化输入输出，如报表，图表等；从最初的可用性，稳定性为主，到现代软件理念中的便捷易用性转变，在保证稳定可用外，对软件的交互易用要求越来越高，而这些则离不开UI设计以及样式的应用。今天以一些简单的小例子，简述Avalonia UI中样式与主题的应用，仅供学习分享使用，如有不足之处，还请指正。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>随着社会的发展，大家对软件的要求，从最初的命令行输入输出，到可视化输入输出，如报表，图表等；从最初的可用性，稳定性为主，到现代软件理念中的便捷易用性转变，在保证稳定可用外，对软件的交互易用要求越来越高，而这些则离不开UI设计以及样式的应用。今天以一些简单的小例子，简述Avalonia UI中样式与主题的应用，仅供学习分享使用，如有不足之处，还请指正。</p>
<p>&nbsp;</p>
<h1>样式概述</h1>
<p>&nbsp;</p>
<p>Avalonia UI中的样式是一种可以在控件之间共享属性设置的机制。与WPF中的样式不同，Avalonia UI中的样式设置借鉴了B/S开发中的CSS样式理念；不过Avalonia UI引入了主题（ControlTheme）和WPF中的样式相对应。当给UI控件设置样式时，样式系统从控件开始沿着逻辑树向上搜索，直到应用程序的最高级别(App.axaml)。如果样式系统匹配到控件设置的样式时，则根据样式中的设置器互进行更改。样式系统沿着逻辑树向上搜索，采用就近原则，所以如果有多个匹配项，则离控件更近的地方定义的样式可以覆盖离控件较远的地方定义的样式。</p>
<p>&nbsp;</p>
<h1>样式定义</h1>
<p>&nbsp;</p>
<p>样式的定义包含两部分：选择器属性（Selector）和一个或多个设置器元素（Setter）。选择器的值包含使用Avalonia UI“样式选择器语法”的字符串。每个设置器元素通过名称标识将被更改的属性和将被替换的新值。语法如下：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;Style Selector="selector syntax"&gt;
     &lt;Setter Property="property name" Value="new value"/&gt;
     ...
&lt;/Style&gt;</code></pre>
<p>说明：Avalonia UI&nbsp;样式选择器语法&nbsp;类似于 CSS（层叠样式表）中使用的语法。</p>
<p>样式放置在UserControl或Window或者Application上的Styles集合中，如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;UserControl.Styles&gt;
    &lt;Style Selector="Button"&gt;
        &lt;Setter Property="Background" Value="Red"&gt;&lt;/Setter&gt;
        &lt;Setter Property="Margin" Value="10"&gt;&lt;/Setter&gt;
    &lt;/Style&gt; 
&lt;/UserControl.Styles&gt;
&lt;StackPanel&gt;
    &lt;Button Width="100" Height="100" Content="按钮"&gt;&lt;/Button&gt;
    &lt;Button Width="100" Height="100" Content="按钮"&gt;&lt;/Button&gt;
&lt;/StackPanel&gt;</code></pre>
<p>上述样式示例，定义了一个Button按钮的样式（背景色为红色，边距为10px），选择器属性为Button，表示在UserControl范围内的Button都会应用此样式，如StackPanel中的Button，示例效果如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202502/1068941-20250213005516928-24217336.png"></p>
<p>选择器定义样式将作用于哪些控件，定义选择器的格式有很多种，类型选择器是比较常用的一种方式。设置器描述了当选择器与控件匹配时会发生什么，设置器主要设置控件的属性Property和值Value。当样式与控件匹配时，样式中所有的设置器都将应用于控件。</p>
<p>&nbsp;</p>
<h1>嵌套样式</h1>
<p>&nbsp;</p>
<p>在实际应用用，除了可以定义单独的样式，还可以定义嵌套样式，而嵌套样式只需要将子样式作为Style元素的子元素包含，并在子选择器的开头加上“嵌套选择器标识符^”。如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="clr-namespace:FirstAvalonia.ViewModels"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="FirstAvalonia.Views.MainView"&gt;
	&lt;UserControl.Styles&gt;
		&lt;Style Selector="TextBlock.h1"&gt;
			&lt;Setter Property="FontSize" Value="24"/&gt;
			&lt;Setter Property="FontWeight" Value="Bold"/&gt;

			&lt;Style Selector="^:pointerover"&gt;
				&lt;Setter Property="Foreground" Value="Red"/&gt;
			&lt;/Style&gt;
		&lt;/Style&gt;
	&lt;/UserControl.Styles&gt;
	&lt;StackPanel&gt;
		&lt;TextBlock Classes="h1" Text="字号24,加粗，鼠标放上变红色"&gt;&lt;/TextBlock&gt;
	&lt;/StackPanel&gt;
&lt;/UserControl&gt;</code></pre>
<p>在上述示例中，子样式继承了父样式的属性设置，当鼠标悬停在TextBlock.h1设置的样式时，子样式才会生效。如下：</p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/1068941/202502/1068941-20250216224016278-418851054.gif" alt="" height="173" width="500"></p>
<p>注意，"嵌套选择器标识符^"必须存在，并且必须出现在子选择器的开头</p>
<p>&nbsp;</p>
<h1 id="1739716818048">样式键</h1>
<p>&nbsp;</p>
<p>样式选择器匹配的对象的类型并不是由控件的具体类型决定的，而是通过检查器StyleKey属性来确定。默认情况下，StyleKey属性返回当前实例的类型。示例：当你自定义一个控件，且它继承自Button，如果你希望它被样式化一个按钮，可以重写StyleKeyOverride属性，并让它返回typeof(Button)。如下所示：</p>
<pre class="language-csharp highlighter-hljs"><code>public class MyButton : Button
{
    // MyButton 将会被作为标准的 Button 控件样式化。
    protected override Type StyleKeyOverride =&gt; typeof(Button);
}</code></pre>
<p>在WPF/UWP中，当你派生一个新的控件时，它将被样式化为其基础控件，除非你覆盖了DefaultStyleKey属性。在Avalonia UI中，控件将使用其具体类型进行样式化，除非提供了相同的样式键。</p>
<p>&nbsp;</p>
<h1>样式类</h1>
<p>&nbsp;</p>
<p>在Avalonia UI中，可以为控件分配一个或多个样式类，并使用它们来指导样式选择。样式类通过在控件元素中使用Classes属性进行分配。多个样式类之间用空格进行分隔。示例如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="clr-namespace:FirstAvalonia.ViewModels"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="FirstAvalonia.Views.MainView"&gt;
	&lt;UserControl.Styles&gt;
		&lt;Style Selector="Button.h1"&gt;
			&lt;Setter Property="FontSize" Value="24"&gt;&lt;/Setter&gt;
		&lt;/Style&gt;
		&lt;Style Selector="Button.blue"&gt;
			&lt;Setter Property="Background" Value="Blue"&gt;&lt;/Setter&gt;
		&lt;/Style&gt;
	&lt;/UserControl.Styles&gt;
	&lt;StackPanel&gt;
		&lt;Button Classes="h1 blue" Width="100" Height="100" Content="按钮"&gt;&lt;/Button&gt;
		&lt;Button Width="100" Height="100" Content="按钮"&gt;&lt;/Button&gt;
	&lt;/StackPanel&gt;
&lt;/UserControl&gt;</code></pre>
<p>在上述示例中，第一个Button应用了h1，blue两个样式，第二个按钮没有应用样式，差别如下：<br><img src="https://img2024.cnblogs.com/blog/1068941/202502/1068941-20250216230809258-1621181045.png"></p>
<p>&nbsp;注意，选择器中样式类的定义必须以“控件类型.样式类名称”的格式进行定义。多个样式类定义必须用点号分隔，如“Button.larger.blue”等。如果选择器指定了多个类，则控件必须同时拥有所有请求的类定义才能匹配。</p>
<p>&nbsp;</p>
<h1>伪类（Pseudo Classes）</h1>
<p>&nbsp;</p>
<p>伪类（Pseudo Classes）与CSS类似，控件可以拥有伪类，这些类是控件本身而不是用户定义的。伪类在选择器中的名称，始终以“冒号”开头。如：pointerover伪类表示鼠标悬停在控件上，pressed伪类表示鼠标在按钮上按下，checked表示复选框选中时。示例如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;StackPanel&gt;
  &lt;StackPanel.Styles&gt;
    &lt;Style Selector="Border:pointerover"&gt;
      &lt;Setter Property="Background" Value="Red"/&gt;
    &lt;/Style&gt;
  &lt;/StackPanel.Styles&gt;
  &lt;Border&gt;
    &lt;TextBlock&gt;I will have red background when hovered.&lt;/TextBlock&gt;
  &lt;/Border&gt;
&lt;/StackPanel&gt;</code></pre>
<p>&nbsp;</p>
<h1>控件主题</h1>
<p>&nbsp;</p>
<p>控件主题是在样式的基础上构建的，用于为控件创建可切换的主题。控件主题本质是样式，但和样式有一些区别：</p>
<ul>
<li>控件主题没有选择器，它们有一个TargetType属性，用于描述它们要针对的控件。</li>
<li>控件主题存储在ResourceDictionary中，而不是Styles集合中。</li>
<li>控件主题通过设置Theme属性来分配给控件，通常使用StaticResource标记扩展。</li>
</ul>
<p>控件主题通常用于模板化控件，对于非模板化的控件，通常使用标准样式更方便。</p>
<p>定义主题，控件主题作为资源的形式出现，一般可以在窗口（Window），用户控件（UserControl），应用程序（Application）的Resources中进行定义，如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="FirstAvalonia.App"
             RequestedThemeVariant="Default"&gt;
    &lt;Application.Styles&gt;
        &lt;FluentTheme /&gt;
    &lt;/Application.Styles&gt;
	&lt;Application.Resources&gt;
		&lt;ControlTheme x:Key="EllipseButton" TargetType="Button"&gt;
			&lt;Setter Property="Background" Value="Blue"/&gt;
			&lt;Setter Property="Foreground" Value="Yellow"/&gt;
			&lt;Setter Property="Padding" Value="8"/&gt;
			&lt;Setter Property="Template"&gt;
				&lt;ControlTemplate&gt;
					&lt;Panel&gt;
						&lt;Ellipse Fill="{TemplateBinding Background}"
								 HorizontalAlignment="Stretch"
								 VerticalAlignment="Stretch"/&gt;
						&lt;ContentPresenter x:Name="PART_ContentPresenter"
										  Content="{TemplateBinding Content}"
										  Margin="{TemplateBinding Padding}"
										   VerticalAlignment="Center" HorizontalAlignment="Center" /&gt;
					&lt;/Panel&gt;
				&lt;/ControlTemplate&gt;
			&lt;/Setter&gt;
		&lt;/ControlTheme&gt;
	&lt;/Application.Resources&gt;
&lt;/Application&gt;</code></pre>
<p>在上述示例中，ControlTheme作为Resources的子元素，x:Key表示资源的唯一标识，TargetType表示主题要应用的控件类型。</p>
<p>应用主题，主题定义完成后，可以在控件上通过Theme="{StaticResource ResourceKey}"的形式进行引用，如下所示：</p>
<pre class="language-xml highlighter-hljs"><code>&lt;StackPanel Orientation="Horizontal"&gt;
    &lt;Button Classes="h1 blue" Width="100" Height="100" Content="按钮" Theme="{StaticResource EllipseButton}"&gt;&lt;/Button&gt;
    &lt;Button Width="100" Height="100" Content="按钮" &gt;&lt;/Button&gt;
&lt;/StackPanel&gt;</code></pre>
<p>应用主题后的效果如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202502/1068941-20250218001838560-1295201992.png"></p>
<p>&nbsp;</p>
<h1>控件主题查找</h1>
<p>&nbsp;</p>
<p>控件主题有两种查找方式：</p>
<p>如果控件的Theme属性被设置，则应用该控件主题；如果没有指定控件的Theme属性，Avalonia UI会从逻辑树向上搜索控件，查找一个x:Key与控件的样式键匹配的ControlTheme资源。所以就有两种方式来定义控件主题：</p>
<ol>
<li>如果希望控件主题应用于控件的所有实例，则将主题资源的x:Key属性设置为{x:Type}作为资源的标识，如：&lt;ControlTheme x:Key="{x:Type Button}" TargetType="Button"&gt;。</li>
<li>如果希望控件主题应用于选定的控件实例，则需要使用普通文本内容作为资源键，并使用StaticResource查找资源。</li>
</ol>
<p>ControlTheme中的TargetType属性指定适用于Setter属性的类型。如果没有指定TargetType，则必须使用类名限定Setter对象中的属性，使用<code>Property="ClassName.Property"</code>&nbsp;的语法。</p>
<p>以上就是《Avalonia系列文章之样式与主题》的全部内容，旨在抛砖引玉，一起学习，共同进步。</p>
</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">
 
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 30px; font-family: 微软雅黑; font-size: 12px" id="PSignature">
<br>
  <a style="float: left; display: block; padding-right: 10px" target="_blank" href="https://images.cnblogs.com/cnblogs_com/hsiang/1154298/o_115f1cd8.jpg">
   <img alt="" src="https://images.cnblogs.com/cnblogs_com/hsiang/1154298/o_115f1cd8.jpg" width="80px" height="80px">
   </a>
    作者：<a href="http://www.cnblogs.com/hsiang/" target="_blank">老码识途</a>
    <br>
    出处：<a href="http://www.cnblogs.com/hsiang/" target="_blank">http://www.cnblogs.com/hsiang/</a>
    <br>
    本文版权归作者和博客园共有，写文不易，支持原创，欢迎转载【点赞】，转载请保留此段声明，且在文章页面明显位置给出原文连接，谢谢。
    <br>关注个人公众号，定时同步更新技术及职场文章
<br><br>
   </p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.148569700346065" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-20 00:41">2025-02-20 00:41</span>&nbsp;
<a href="https://www.cnblogs.com/hsiang">老码识途呀</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710783" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710783);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710783', targetLink: 'https://www.cnblogs.com/hsiang/p/18710783', title: 'Avalonia系列文章之样式与主题' })">举报</a>
</div>
        