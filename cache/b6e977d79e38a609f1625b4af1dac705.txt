
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18737892" title="发布于 2025-02-26 10:19">
    <span role="heading" aria-level="2">『玩转Streamlit』--缓存机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><code>Streamlit</code> 应用在运行时，每次用户交互都会触发整个脚本的重新执行。</p>
<p>这意味着一些耗时操作，如数据加载、复杂计算和模型训练等，可能会被重复执行，严重影响应用响应速度。</p>
<p>本文介绍的<strong>缓存机制</strong>能够帮助我们解决这些问题，提高<code>Streamlit</code> 应用的性能。</p>
<p>而<code>Streamlit</code>的<strong>缓存机制</strong>就像是给应用配备了一个<strong>“记忆助手”</strong>，它允许开发者将特定函数的计算结果保存下来，当下次相同输入再次调用该函数时，无需重新执行函数，直接返回缓存结果，极大地提高了应用运行效率，减少等待时间。</p>
<h1 id="1-为什么需要缓存">1. 为什么需要缓存</h1>
<p><code>Streamlit</code>的机制是每次用户交互或代码更改时都会重新运行脚本，这样就导致了：</p>
<ol>
<li><strong>重复计算</strong>：长时间运行的函数可能会被多次调用，导致应用响应变慢</li>
<li><strong>资源浪费</strong>：频繁加载和处理大量数据会消耗大量内存和计算资源</li>
<li><strong>用户体验差</strong>：应用加载时间过长，影响用户交互体验</li>
</ol>
<p>为了解决这些问题，<code>Streamlit</code>提供了缓存机制。</p>
<p><strong>缓存机制</strong>就像是给应用配备了一个<strong>“记忆助手”</strong>，它允许开发者将特定函数的计算结果保存下来，当下次相同输入再次调用该函数时，无需重新执行函数，直接返回缓存结果。</p>
<p>通过缓存函数的输出结果，避免重复计算，能够显著提高应用的性能和响应速度。</p>
<h1 id="2-两种缓存装饰器">2. 两种缓存装饰器</h1>
<p><code>Streamlit</code>提供了两种缓存装饰器：<code>st.cache_data</code>和<code>st.cache_resource</code>，它们的主要区别在于缓存的对象类型和使用场景。</p>
<h2 id="21-stcache_data">2.1. st.cache_data</h2>
<p><code>st.cache_data</code>是用于<strong>缓存数据</strong>的装饰器。</p>
<p>适用于缓存函数的输出结果，特别是那些返回可序列化数据对象的函数（如 <code>Pandas DataFrame</code>、<code>NumPy</code> 数组、字符串、整数等）。</p>
<p>它的主要参数有：</p>
<ul>
<li><code>ttl</code>：缓存的生存时间（以秒为单位）。超过该时间后，缓存将失效并重新计算。</li>
<li><code>max_entries</code>：缓存中允许的最大条目数。超出该数量时，最旧的缓存条目将被删除。</li>
<li><code>persist</code>：是否将缓存持久化到磁盘上。默认为<code>False</code>。</li>
<li><code>show_spinner</code>：是否显示加载动画。默认为<code>True</code>。</li>
<li><code>allow_output_mutation</code>：是否允许返回值被修改。默认为<code>False</code>，建议谨慎使用。</li>
</ul>
<h2 id="22-stcache_resource">2.2. st.cache_resource</h2>
<p><code>st.cache_resource</code>是用于<strong>缓存资源</strong>的装饰器。</p>
<p>适用于缓存那些需要初始化但不需要频繁重新计算的对象，如数据库连接、模型加载等。</p>
<p>它的主要参数有：</p>
<ul>
<li><code>ttl</code>和<code>max_entries</code>：与<code>st.cache_data</code>相同。</li>
<li><code>show_spinner</code>：是否显示加载动画。默认为<code>True</code>。</li>
<li><code>allow_output_mutation</code>：是否允许返回值被修改。默认为<code>False</code>。</li>
</ul>
<h2 id="23-两者区别总结">2.3. 两者区别总结</h2>
<table>
<thead>
<tr>
<th></th>
<th><strong>st.cache_data</strong></th>
<th><strong>st.cache_resource</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>使用场景</td>
<td>适用于缓存函数的输出结果，特别是那些返回可序列化数据对象的函数</td>
<td>适用于缓存那些需要初始化但不需要频繁重新计算的对象，如数据库连接、模型加载等</td>
</tr>
<tr>
<td>特点</td>
<td>缓存的是函数的输出结果，适合频繁调用且输出结果可能变化的场景</td>
<td>缓存的是资源对象本身，适合初始化耗时但不需要频繁更新的场景</td>
</tr>
<tr>
<td>缓存内容示例</td>
<td>从 API 获取数据、加载 CSV 文件、数据处理等</td>
<td>加载预训练模型、建立数据库连接等</td>
</tr>
</tbody>
</table>
<h1 id="3-缓存使用示例">3. 缓存使用示例</h1>
<p>下面通过示例来演示这两种缓存装饰器的使用。</p>
<h2 id="31-stcache_data示例">3.1. st.cache_data示例</h2>
<p>假设我们有一个应用，需要从<code>API</code>获取数据并展示给用户。</p>
<p>由于数据加载可能需要较长时间，我们可以使用<code>st.cache_data</code>来缓存结果。</p>
<pre><code class="language-python">import streamlit as st
import requests
import pandas as pd

# 使用 st.cache_data 缓存数据加载
@st.cache_data(ttl=3600)  # 缓存 1 小时
def fetch_data(api_url):
    response = requests.get(api_url)
    data = response.json()
    df = pd.DataFrame(data)
    return df

# 用户界面部分
st.title("使用 st.cache_data 缓存数据加载")
api_url = "https://jsonplaceholder.typicode.com/posts"
df = fetch_data(api_url)
st.write(df)
</code></pre>
<p>在这个例子中，<code>fetch_data</code>函数被<code>@st.cache_data</code>装饰器修饰。</p>
<p>第一次调用时，数据会被加载并缓存，后续调用时直接从缓存中读取，避免重复请求 <code>API</code>，</p>
<p>直至<strong>1小时</strong>后，缓存失效之后才能重新请求。</p>
<h2 id="32-stcache_resource示例">3.2. st.cache_resource示例</h2>
<p>假设我们有一个机器学习应用，需要加载一个预训练的模型。</p>
<p>由于模型加载可能需要较长时间，我们可以使用<code>st.cache_resource</code>来缓存模型对象。</p>
<pre><code class="language-python">import streamlit as st
import joblib

# 使用 st.cache_resource 缓存模型加载
@st.cache_resource
def load_model(model_path):
    model = joblib.load(model_path)
    return model

# 用户界面部分
st.title("使用 st.cache_resource 缓存模型加载")
model_path = "path/to/your/model.pkl"
model = load_model(model_path)
st.write("模型已加载，可以进行预测！")
</code></pre>
<p>在这个例子中，<code>load_model</code>函数被<code>@st.cache_resource</code>装饰器修饰。</p>
<p>模型加载后会被缓存，后续调用时直接从缓存中读取，避免重复加载。</p>
<h1 id="4-总结">4. 总结</h1>
<p><code>Streamlit</code>的缓存机制通过<code>st.cache_data</code>和<code>st.cache_resource</code>提供了强大的性能优化功能。</p>
<p>它们可以帮助开发者减少重复计算、节省资源，并显著提高应用的响应速度。</p>
<p>在实际开发中，开发者可以根据需求选择合适的缓存装饰器：</p>
<ul>
<li>如果需要缓存函数的输出结果，使用<code>st.cache_data</code></li>
<li>如果需要缓存初始化的资源对象，使用<code>st.cache_resource</code></li>
</ul>
<p>合理使用缓存机制，可以让 <code>Streamlit</code> 应用更加高效和流畅，提升用户体验。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5063970038402777" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 10:20">2025-02-26 10:19</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">80</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737892" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737892);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737892', targetLink: 'https://www.cnblogs.com/wang_yb/p/18737892', title: '『玩转Streamlit』--缓存机制' })">举报</a>
</div>
        