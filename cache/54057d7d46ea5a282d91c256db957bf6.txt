
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/L178/p/18977971/JavaScript" title="发布于 2025-07-10 23:53">
    <span role="heading" aria-level="2">JavaScript</span>
    

</a>

			</h2>
 			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="事件循环机制">事件循环机制</h1>
<p><a href="https://www.jsv9000.app/" title="事件循环练习" target="_blank" rel="noopener nofollow">事件循环练习</a></p>
<p>由于js是单线程，为防止代码阻塞，将代码分为同步和异步，同步代码会直接放入执行栈中执行，异步代码（如setTimeout）放入宿主环境（浏览器，Node）中，时机到了（点击事件即点击后，setTimeout即时间结束后）以后将回调函数放入任务队列中，执行栈中的代码执行完后就会去任务队列中查看有无异步代码要执行。反复循环查看执行，这个过程就是事件循环。<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250710231513760-232140412.png" alt="image" loading="lazy"></p>
<p>js又把异步任务分为宏任务（由宿主环境发起，如script，事件，网络请求Ajax/Fetch，setTimeout()/setInterval()）和微任务（由JS引擎发起，如Promise，Promise本身同步，then/catch回调函数异步）</p>
<p><img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250710231543392-596173098.png" alt="image" loading="lazy"></p>
<h2 id="注意️">注意⚠️</h2>
<ul>
<li>排前面的 script 先执行，执行其内部的【同】，再执行其【微】，接着就轮到下一个大的宏，也就是执行下一个 script，【同】、【微】......顺序执行完后，再从头开始，看第一个 script 是否有需要执行的【宏】，再去下一个 script 中找 【宏】，等大家宏结束后，进入下一轮循环。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250710231820269-408097562.png" alt="image" loading="lazy"></p>
<ul>
<li>async函数里面的属于同步代码，await后的代码属于异步微任务</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250710231842588-1856885379.png" alt="image" loading="lazy"></p>
<h2 id="practice">Practice</h2>
<h3 id="1️⃣">1️⃣</h3>
<pre><code>console.log('A');·
setTimeout(() =&gt; console.log('B'), 0);
Promise.resolve().then(() =&gt; console.log('C'));
Promise.resolve().then(() =&gt; setTimeout(() =&gt; console.log('D'), 0));
console.log('E');
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code>A → E → C → B → D
</code></pre>
</details>
<h3 id="2️⃣">2️⃣</h3>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
console.log(1);
console.log(2);
});
promise.then(() =&gt; {
console.log(3);
});
console.log(4);
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code> 1 → 2 → 4
</code></pre>
</details>
<h3 id="3️⃣">3️⃣</h3>
<pre><code>async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}
async function async2() { console.log('3'); }
setTimeout(() =&gt; console.log('4'), 0);
async1();
new Promise(resolve =&gt; {
  console.log('5');
  resolve();
}).then(() =&gt; console.log('6'));
console.log('7');
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code> 1 → 3 → 5 → 7 → 2 → 6 → 4
</code></pre>
</details>
<h3 id="4️⃣">4️⃣</h3>
<pre><code>new Promise((resolve) =&gt; {
  console.log(1);
  resolve(3);
  Promise.resolve().then(() =&gt; {
    console.log(4);
  });
}).then((num) =&gt; {
  console.log(num);
});

setTimeout(() =&gt; {
  console.log(6);
});

Promise.resolve().then(() =&gt; {
  console.log(5);
});
console.log(2);
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code> 1 → 2 → 4 → 3 → 5 → 6
</code></pre>
</details>
<h3 id="5️⃣">5️⃣</h3>
<pre><code>console.log('start');
setTimeout(() =&gt; {
  console.log('Timeout1');
}, 1000);

Promise.resolve().then(() =&gt; {
  console.log('Promise1');
});

Promise.resolve().then(() =&gt; {
  console.log('Promise2');
  setTimeout(() =&gt; {
    Promise.resolve().then(() =&gt; {
      console.log('Promise3');
    })
    console.log('Timeout2');
  }, 0);
});
console.log('end');
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code> start → end → Promise1 → Promise2 → Timeout2 → Promise3 → Timeout1
</code></pre>
</details>
<pre><code>function app() {
  setTimeout(() =&gt; {
    console.log("1-1");3
    Promise.resolve().then(() =&gt; {
      console.log("2-1");5
    });
  });
  console.log("1-2"); 1
  Promise.resolve().then(() =&gt; {
    console.log("1-3"); 2
    setTimeout(() =&gt; {
      console.log("3-1"); 4
    });
  });
}
</code></pre>
<details>
<summary>点击查看答案</summary>
<pre><code> 1-2 → 1-3 → 1-1 → 3-1 → 2-1
</code></pre>
</details>
<h1 id="内存管理">内存管理</h1>
<p>JS有如下数据类型：<br>
<strong>原始数据类型</strong>：String, Number, Boolean, Null, Undefined, Symbol<br>
<strong>引用数据类型</strong>：Object<br>
而存放这些数据的内存又可以分为两部分：栈内存（Stack）和堆内存（Heap）。原始数据类型存在栈中，引用类型存在堆中。</p>
<h2 id="栈内存">栈内存</h2>
<p>栈是一种只能一端进出的数据结构，先进后出，后进先出。<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713215310983-1673529642.png" alt="image" loading="lazy"></p>
<h2 id="堆内存">堆内存</h2>
<p>JS中原始数据类型的内存大小是固定的，由系统自动分配内存。但是引用数据类型，比如Object, Array，他们的大小不是固定的，所以是存在堆内存的。JS不允许直接操作堆内存，我们在操作对象时，操作的实际是对象的引用，而不是实际的对象。可以理解为对象在栈里面存了一个内存地址，这个地址指向了堆里面实际的对象。所以引用类型的值是一个指向堆内存的引用地址。<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713215355803-1044334403.png" alt="image" loading="lazy"><br>
函数也是引用类型，当我们定义一个函数时，会在堆内存中开辟一块内存空间，将函数体代码以字符串的形式存进去。然后将这块内存的地址赋值给函数名，函数名和引用地址会存在栈上。<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713215418278-2065198501.png" alt="image" loading="lazy"></p>
<h2 id="垃圾回收">垃圾回收</h2>
<p>垃圾回收就是找出那些不再继续使用的变量，然后释放其占用的内存，垃圾回收器会按照固定的时间间隔周期性执行这一操作。JS使用垃圾回收机制来自动管理内存，但是他是一把双刃剑：</p>
<p><strong>优势</strong>： 可以大幅简化程序的内存管理代码，降低程序员负担，减少因为长时间运行而带来的内存泄漏问题。<br>
<strong>劣势</strong>：程序员无法掌控内存，JS没有暴露任何关于内存的API，我们无法进行强制垃圾回收，更无法干预内存管理。</p>
<h3 id="引用计数">引用计数</h3>
<p>引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。<br>
使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</p>
<pre><code>function problem(){ 
    var objectA = {};
    var objectB = {}; 
    objectA.a = objectB;
    objectB.b = objectA; 
}
</code></pre>
<p>在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。</p>
<h3 id="标记清除算法">标记—清除算法</h3>
<p>算法分为 <strong>“标记”和“清除”</strong> 两个阶段，最终目的是识别并释放 “不再需要” 的内存。</p>
<ol>
<li>标记阶段：区分 “有用” 和 “无用” 的变量<br>
标记规则：<br>
垃圾回收器会从根对象（Roots） 开始遍历所有变量（根对象通常是全局对象，如浏览器中的window、Node.js 中的global）。</li>
</ol>
<ul>
<li>所有能被根对象直接或间接访问到的变量，标记为 <strong>“有用”</strong>（处于 “进入环境” 状态，即仍在执行环境中被使用）。</li>
<li>无法被根对象访问到的变量，标记为 <strong>“无用”</strong>（处于 “离开环境” 状态，即已脱离执行环境，不再被使用）。</li>
</ul>
<ol start="2">
<li>清除逻辑：<br>
垃圾回收器会遍历内存中所有变量，将标记为 “无用” 的变量占用的内存释放，并将这些内存空间归还给操作系统，供后续使用。</li>
</ol>
<h2 id="闭包">闭包</h2>
<p>当一个内部函数引用了外部函数的变量时，就形成了闭包。</p>
<h3 id="闭包的优点特点">闭包的优点/特点</h3>
<ul>
<li>通过闭包可以让外部环境访问到函数内部的局部变量</li>
<li>通过闭包可以让全局变量持续保存下来，不随着它的上下文一起销毁</li>
</ul>
<hr>
<p>通过此特性，我们可以解决一个全局变量污染的问题， 早期在 JavaScript 还无法进行模块化的时候，在多人协作时，如果定义过多的全局变量有可能造成全局变量命名冲突，使用闭包来解决功能对变量的调用将变量写到一个独立的空间里面，从而能够一定程度上解决全局变量污染的问题。</p>
<h3 id="闭包经典面试题一">闭包经典面试题一</h3>
<pre><code>for (var i = 1; i &lt;= 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 1000);
}
</code></pre>
<h4 id="var-的作用域特性">var 的作用域特性：</h4>
<p>var 声明的变量没有块级作用域（仅函数作用域或全局作用域），因此整个循环共享同一个 i 变量。</p>
<ul>
<li>循环执行时：<br>
三次迭代都会将 setTimeout 放入任务队列，延迟 1 秒执行。<br>
但每次迭代的回调函数引用的是同一个 i 变量。</li>
<li>定时器触发时：<br>
由于循环执行速度极快，1 秒后所有定时器触发时，循环早已结束，此时 i 的值已经变为 4（循环终止条件是 i &gt; 3）。<br>
因此所有回调函数打印的都是 4。</li>
</ul>
<h4 id="解决方法">解决方法</h4>
<pre><code>for (var i = 1; i &lt;= 3; i++) {
    (function (index) {
        setTimeout(function () {
            console.log(index);
        }, 1000);
    })(i)
}
</code></pre>
<h4 id="let-的作用域特性">let 的作用域特性：</h4>
<p>let 声明的变量具有块级作用域（每个循环迭代都会创建独立的变量副本）。</p>
<ul>
<li>循环执行时：<br>
每次迭代都会创建一个新的 i 变量，并将其值（1、2、3）绑定到对应的定时器回调函数中。<br>
每个回调函数形成的闭包捕获的是当前迭代的 i 值。</li>
<li>定时器触发时：<br>
每个回调函数访问的是自己闭包中的 i 副本（分别为 1、2、3），因此依次打印：1 2 3<br>
<a href="https://blog.csdn.net/m0_67180694/article/details/127396304" title="闭包面试题" target="_blank" rel="noopener nofollow">闭包面试题</a></li>
</ul>
<h2 id="this指向">this指向</h2>
<p>函数中的this指向取决于函数如何调用，它指向当前函数的运行环境</p>
<p>判断this的唯一依据就是此刻函数的执行由哪个对象调用</p>
<ul>
<li>如果函数以参数形式传递，则this会指向windows，函数是一个局部变量，找不到他的调用者</li>
</ul>
<h2 id="原型链">原型链</h2>
<h3 id="1原型">1.原型</h3>
<p>在js中，每一个对象（函数也是对象）都有一个特殊的属性叫做原型（prototype），它指向另一个对象，这个对象（Test.prototype）被称为原型对象， 原型对象是用来共享属性和方法的</p>
<h3 id="2原型对象">2.原型对象：</h3>
<p>(1)原型对象有一个constructor属性指向构造函数本身(Test)。<br>
(2)原型对象是一个普通的对象，它包含属性和方法。<br>
(3)原型对象的属性和方法会被继承到所有通过原型链与它相连的对象。</p>
<pre><code>function Test(name, age){
    this.name = name
    this.age = age
}
 
Test.prototype.say = function(){
    console.log('我能说话')
}
var obj3 = new Test('Jack', 26)
var obj4 = new Test('Rose', 25)
 
obj3.say()    // 我能说话
obj4.say()    // 我能说话
console.log(obj3.say === obj4.say)    // true
 
</code></pre>
<p>构造函数和实例之间就初步构成了这样一个关系，如图：<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713234503812-732457334.png" alt="image" loading="lazy"></p>
<h3 id="3隐式原型__proto__">3.隐式原型__proto__</h3>
<p>在js中，每个对象都有一个__proto__ 属性(左右两边两个短下划线)，这个__proto__就被称为隐式原型。</p>
<pre><code>console.log(obj3.__proto__ === Test.prototype)
// true
</code></pre>
<p>(1)每个js对象都有一个隐藏的原型对象属性__proto__，它指向创建它的构造函数的原型对象（Test.prototype）<br>
(2)<strong>proto__存在的意义在于为原型链查找提供方向，原型链查找靠的是__proto</strong>，而不是prototype</p>
<pre><code>function Test(name, age){
    this.name = name
    this.age = age
}
 
Test.prototype.say = function(){
    console.log('我能说话')
}
var obj3 = new Test('Jack', 26)
 
 
1, 构造函数是? 实例是?
2, obj3.constructor === Test   true or false?
3, obj3.__proto__ === Test ?
4, Test.prototype === obj3.__proto__ ?
5, obj3.__proto__.constructor === Test ?
 
// 1, Test  obj3  2,true  3,false  4,true  5,true
</code></pre>
<h3 id="4原型链">4.原型链</h3>
<p>Test的原型对象Test.prototype会不会也有一个隐式原型__proto__</p>
<pre><code>Test.prototype.__proto__ === Object.prototype
// true
</code></pre>
<p>(1) Test.prototype的隐式原型(<strong>proto</strong>)就是Object.prototype<br>
(2) 所有的对象，包括构造函数的原型对象，最终都继承自 Object.prototype，这是js原型链的顶点<br>
此时的关系图：<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713235231095-1409817950.png" alt="image" loading="lazy"></p>
<h4 id="链">链</h4>
<p>Object.prototype作为原型链的顶端，位于原型链的最末端。因此，它不再有自己的原型，所以Object.prototype.<strong>proto</strong> 指向null，表示原型链的终点</p>
<ul>
<li>原型链的终点是null</li>
<li>Object.prototype.<strong>proto</strong> === null<br>
<img src="https://img2024.cnblogs.com/blog/3390382/202507/3390382-20250713235410669-713860297.png" alt="image" loading="lazy"><br>
每个对象都有一个原型(prototype),它指向另外一个对象，而指向的对象又存在属性(<em>proto</em>)指向另外一个对象。当我们访问对象(obj3)的属性时，会先在对象定义的属性中进行查找，没找到就会沿着__proto__一路向上查找，最终形成一个链式结构，这整个链式结构就叫做<strong>原型链</strong><br>
如果在原型链中找到了这个属性，就返回找到的属性值；如果整个原型链都没找到这个属性值，则返回 undefined，没找到方法直接报错</li>
</ul>
<pre><code>function Test(name, age){
    this.name = name
    this.age = age
}
Test.prototype.say = function(){
    console.log('我能说话')
}
var obj3 = new Test('Jack', 26)
var obj4 = new Test('Rose', 24)
 
1, Test.prototype === ( ) ?
2, obj3.__proto__.__proto__ === ( ) ?
3, obj3.__proto__ === obj4.__proto__ ?
4, Test.prototype.__proto__ === ( ) ?
5, obj4.__proto__.constructor === ( ) ?
6, Object.prototype.__proto__ === ( ) ?
7, obj3.say === obj4.say ?
 
 
// 1, obj3.__proto__ 或 obj4.__proto    2,Object.prototype    3, true (二者都由Test new出来，在原型链上都指向 Test.prototype)
// 4， Object.prototype    5, Test    6, null (终点)    7,true （同问题3）
</code></pre>
<p><a href="https://blog.csdn.net/Yi_qian1000/article/details/135264247" title="原型链面试题" target="_blank" rel="noopener nofollow">原型链面试题</a></p>
<h2 id="promise">Promise</h2>
<h3 id="1-promise是什么">1. Promise是什么？</h3>
<blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数,  更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象 。</p>
</blockquote>
<ul>
<li>指定回调函数方式更灵活易懂。</li>
<li>解决异步 <strong>回调地狱</strong> 的问题。</li>
</ul>
<h4 id="1-回调地狱">(1). 回调地狱</h4>
<ul>
<li>当一个回调函数嵌套一个回调函数的时候</li>
<li>就会出现一个嵌套结构</li>
<li>当嵌套的多了就会出现回调地狱的情况</li>
<li>比如我们发送三个 ajax 请求
<ul>
<li>第一个正常发送</li>
<li>第二个请求需要第一个请求的结果中的某一个值作为参数</li>
<li>第三个请求需要第二个请求的结果中的某一个值作为参数</li>
</ul>
<pre><code class="language-javascript">ajax({
  url: '我是第一个请求',
  success (res) {
    // 现在发送第二个请求
    ajax({
      url: '我是第二个请求'，
      data: { a: res.a, b: res.b },
      success (res2) {
        // 进行第三个请求
        ajax({
          url: '我是第三个请求',
          data: { a: res2.a, b: res2.b },
  				success (res3) { 
            console.log(res3) 
          }
        })
      }
    })
  }
})
</code></pre>
</li>
<li><strong>回调地狱，其实就是回调函数嵌套过多导致的</strong></li>
<li>当代码成为这个结构以后，已经没有维护的可能了</li>
</ul>
<h3 id="2-promise使用">2. Promise使用</h3>
<ul>
<li>语法：<pre><code class="language-javascript">new Promise(function (resolve, reject) {
  // resolve 表示成功的回调
  // reject 表示失败的回调
}).then(function (res) {
  // 成功的函数
}).catch(function (err) {
  // 失败的函数
})
</code></pre>
</li>
</ul>
<h3 id="3-promise-对象的状态">3. Promise 对象的状态</h3>
<p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<pre><code>异步操作未完成（pending）
异步操作成功（fulfilled）
异步操作失败（rejected）
</code></pre>
<p>这三种的状态的变化途径只有两种。</p>
<pre><code>从“未完成”到“成功”
从“未完成”到“失败”
</code></pre>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。<br>
因此，Promise 的最终结果只有两种。</p>
<pre><code>异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。
异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。
</code></pre>
<h3 id="4promise对象方法">4.Promise对象方法</h3>
<blockquote>
<p>Promise 是一个对象，也是一个构造函数。</p>
</blockquote>
<h4 id="1promiseresolve">(1).Promise.resolve</h4>
<p>将现有对象转为 Promise 对象</p>
<pre><code class="language-javascript">Promise.resolve('kerwin')
// 等价于
new Promise(resolve =&gt; resolve('kerwin'))
</code></pre>
<h4 id="2promisereject">(2).Promise.reject</h4>
<p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<pre><code class="language-javascript">const p = Promise.reject('error');
// 等同于
const p = new Promise((resolve, reject) =&gt; reject('error'))
</code></pre>
<h4 id="3promiseall">(3).Promise.all</h4>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="language-javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>p的状态由p1,p2,p3 决定，分成两种情况。<br>
1️⃣只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。<br>
2️⃣只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<h4 id="4promiserace">（4）.Promise.race</h4>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="language-javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<h4 id="5promiseallsettled">（5）.Promise.allSettled</h4>
<p><code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>
<pre><code class="language-js">const promises = [ ajax('/200接口'), ajax('/401接口') ];
Promise.allSettled(promises).then(results=&gt;{
    // 过滤出成功的请求
    results.filter(item =&gt;item.status === 'fulfilled');
    过滤出失败的请求
    results.filter(item=&gt; item.status === 'rejected');
})
</code></pre>
<h4 id="6promiseany">（6）.Promise.any</h4>
<p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<blockquote>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
</blockquote>
<h3 id="5手写promise">5.手写Promise</h3>
<pre><code class="language-js">function KerwinPromise(executor) {
    this.status = "pending";
    this.result = undefined;
    this.cb = []
    var _this = this;

    function resolve(res) {
        if (_this.status !== "pending") return;
        // console.log(_this)
        _this.status = "fulfilled"
        _this.result = res;

        _this.cb.forEach(item =&gt; {
            item.successCB &amp;&amp; item.successCB(_this.result)
        });
    }

    function reject(res) {
        if (_this.status !== "pending") return;
        // console.log("reject")
        _this.status = "rejected"
        _this.result = res;
        _this.cb.forEach(item =&gt; {
            item.failCB &amp;&amp; item.failCB(_this.result)
        });
    }
    executor(resolve, reject)
}

KerwinPromise.prototype.then = function (successCB, failCB) {

    if(!successCB){
        successCB = value=&gt;value
    }
    if(!failCB){
        failCB = error=&gt;error
    }

    // successCB()
    return new KerwinPromise((resolve, reject) =&gt; {
        if (this.status === "fulfilled") {
            var result = successCB &amp;&amp; successCB(this.result)
            // console.log(result);

            if (result instanceof KerwinPromise) {
                result.then(res =&gt; {
                    // console.log(res)
                    resolve(res);
                }, err =&gt; {
                    // console.log(err)
                    reject(err)
                })
            } else {
                resolve(result);
            }
        }
        if (this.status === "rejected") {
            var result = failCB &amp;&amp; failCB(this.result)

            if (result instanceof KerwinPromise) {
                result.then(res =&gt; {
                    // console.log(res)
                    resolve(res);
                }, err =&gt; {
                    // console.log(err)
                    reject(err)
                })
            } else {
                reject(result);
            }
        }

        if (this.status === "pending") {
            //收集回调
            this.cb.push({
                successCB: () =&gt; {
                    var result = successCB &amp;&amp; successCB(this.result)

                    if (result instanceof KerwinPromise) {
                        result.then(res =&gt; {
                            // console.log(res)
                            resolve(res);
                        }, err =&gt; {
                            // console.log(err)
                            reject(err)
                        })
                    } else {
                        resolve(result);
                    }
                },
                failCB: () =&gt; {
                    var result = failCB &amp;&amp; failCB(this.result)
                    if (result instanceof KerwinPromise) {
                        result.then(res =&gt; {
                            // console.log(res)
                            resolve(res);
                        }, err =&gt; {
                            // console.log(err)
                            reject(err)
                        })
                    } else {
                        reject(result);
                    }
                }
            })
        }
    })
}

KerwinPromise.prototype.catch= function(failCB){
    this.then(undefined,failCB)
}
</code></pre>
<h3 id="6async与await">6.Async与Await</h3>
<h4 id="1async">（1）.Async</h4>
<p>async 函数，使得异步操作变得更加方便。</p>
<ul>
<li>更好的语义。</li>
<li>返回值是 Promise。</li>
</ul>
<pre><code class="language-js">async function test(){
	
}
test()
</code></pre>
<h4 id="2await">（2）.Await</h4>
<p><code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<pre><code>async function test(){
    var res1 =  await ajax("http://localhost:3000/news1")
    var res2 =  await ajax("http://localhost:3000/news2")
    return res2
}

test().then(res=&gt;{
	console.log("返回结果",res)
}).catch(err=&gt;{
	console.log("err",err)
})
</code></pre>
<h4 id="3错误处理">（3）错误处理</h4>
<pre><code class="language-js">try{
    var res1 =  await ajax("http://localhost:3000/news1")
    var res2 =  await ajax("http://localhost:3000/news2")
}catch(err){
	console.log("err",err)
}
</code></pre>

</div>
<div class="clear"></div>
</div>
		<div class="postfoot">
		Posted on 
<span id="post-date" data-last-update-days="3.928472222222222" data-date-updated="2025-07-14 22:10">2025-07-10 23:53</span>&nbsp;
<a href="https://www.cnblogs.com/L178">Minutiae</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18977971);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18977971', targetLink: 'https://www.cnblogs.com/L178/p/18977971/JavaScript', title: 'JavaScript' })">举报</a>

			
			
		</div>
	