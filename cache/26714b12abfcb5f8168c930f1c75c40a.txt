
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/19054722" title="发布于 2025-08-25 09:00">
    <span role="heading" aria-level="2">Redis支持事务吗？了解Redis的持久化机制吗？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="redis-支持事务吗与关系型数据库事务的区别">Redis 支持事务吗？与关系型数据库事务的区别？</h2>
<p>Redis 支持事务，但它的事务与 MSQL中的事务有所不同，MSOL中的事务主要支持 ACID 的特性，而 Redis中的事务主要保证的是多个命令执行的原子性，即所有的命令在一个原子操作中执行，不会被打断。还有一个很重要的点，就是 MySQL 中的事务是支持回滚的，而 Redis 中的事务是不支持回滚的。</p>
<p>Redis事务是指将多条命令加入队列，一次批量执行多条命令，每条命令会按顺序执行，事务执行过程中不会被其他客户端发来的命令所打断。也就是说，Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>Redis事务和关系型数据库的事务不太一样，它<strong>不保证原子性，也没有隔离级别</strong>的概念。</p>
<blockquote>
<p>事务不保证原子性，但是Redis命令本身是原子性的</p>
</blockquote>
<ol>
<li><strong>Redis事务没有隔离级别的概念</strong>：批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务里的查询要看到本事务的更新或其它事务的修改更新操作的问题。（Mysql里的事务的语句不是放入队列，而是直接执行）</li>
<li><strong>Redis不保证原子性</strong>：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</li>
</ol>
<p><strong>WATCH命令</strong></p>
<p><code>WATCH</code>命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行<code>EXEC</code>命令之后，就会自动取消监控。</p>
<pre><code class="language-java">127.0.0.1:6379&gt; watch name
OK
127.0.0.1:6379&gt; set name 1
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set name 2
QUEUED
127.0.0.1:6379&gt; set gender 1
QUEUED
127.0.0.1:6379&gt; exec
(nil)
127.0.0.1:6379&gt; get gender
(nil)
</code></pre>
<p>比如上面的代码中：</p>
<ol>
<li><code>watch name</code>开启了对<code>name</code>这个<code>key</code>的监控</li>
<li>修改<code>name</code>的值</li>
<li>开启事务a</li>
<li>在事务a中设置了<code>name</code>和<code>gender</code>的值</li>
<li>使用<code>EXEC</code>命令进提交事务</li>
<li>使用命令<code>get gender</code>发现不存在，即事务a没有执行</li>
</ol>
<p>使用<code>UNWATCH</code>可以取消<code>WATCH</code>命令对<code>key</code>的监控，所有监控锁将会被取消。</p>
<h2 id="redis事务支持隔离性吗">Redis事务支持隔离性吗？</h2>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h2 id="redis事务保证原子性吗支持回滚吗">Redis事务保证原子性吗，支持回滚吗？</h2>
<p>Redis单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="redis-的-lua-脚本功能是什么如何使用">Redis 的 Lua 脚本功能是什么?如何使用?</h2>
<p>Redis 的 Lua 脚本功能允许用户在 Redis 服务器端执行自定义的 Lua 脚本，以实现原子操作和复杂逻辑。其核心点包括：</p>
<ul>
<li>原子性:Lua 脚本的所有命令在执行过程中是原子的，避免了并发修改带来的问题。</li>
<li>减少网络往返次数：通过在服务器端执行脚本，减少了客户端和服务器之间的网络往返次数，提高了性能。</li>
<li>复杂操作：可以在 Lua 脚本中执行复杂的逻辑，比如批量更新、条件更新等，超过了单个 Redis 命令的能力。</li>
</ul>
<p>例如常见基于 Redis 实现分布式锁就需要结合 lua 脚本来实现。</p>
<p>lua 本身是不具备原子性的，但由于 Redis的命令是单线程执行的，它会把整个|ua 脚本作为一个命令执行，会阻塞其间接受到的其他命令，这就保证了 lua 脚本的原子性。</p>
<h2 id="redis的持久化了解吗">Redis的持久化了解吗？</h2>
<p>详细可以查看：<a href="https://www.seven97.top/database/redis/03-strategy1-persistence.html" target="_blank" rel="noopener nofollow">https://www.seven97.top/database/redis/03-strategy1-persistence.html</a></p>
<p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止服务宕机导致内存数据丢失。</p>
<p>Redis支持两种方式的持久化，一种是<code>RDB</code>的方式，一种是<code>AOF</code>的方式。<strong>前者会根据指定的规则定时将内存中的数据存储在硬盘上</strong>，而<strong>后者在每次执行完命令后将命令记录下来</strong>。Redis 4.0 新增了 RDB 和 AOF 的混合持久化机制，一般将两者结合使用。</p>
<h2 id="rdb方式">RDB方式</h2>
<p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p>
<p><code>bgsave</code>是主流的触发 RDB 持久化的方式，执行过程如下：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202409281053898.png" alt="" loading="lazy"></p>
<ul>
<li>执行<code>BGSAVE</code>命令</li>
<li>Redis 父进程判断当前<strong>是否存在正在执行的子进程</strong>，如果存在，<code>BGSAVE</code>命令直接返回。</li>
<li>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。</li>
<li>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>；</li>
<li>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</li>
</ul>
<p>Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。</p>
<p>触发 RDB 持久化的方式：</p>
<ol>
<li>
<p><strong>手动触发</strong>：用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。<code>SAVE</code>命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。<code>BGSAVE</code>命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用<code>BGSAVE</code>命令。</p>
</li>
<li>
<p><strong>被动触发</strong>：</p>
<ul>
<li>根据配置规则进行自动快照，如<code>SAVE 100 10</code>，100秒内至少有10个键被修改则进行快照。</li>
<li>如果从节点执行全量复制操作，主节点会自动执行<code>BGSAVE</code>生成 RDB 文件并发送给从节点。</li>
<li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</strong>。</li>
<li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>RDB方式数据无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</li>
<li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li>
</ol>
<h2 id="redis-在生成-rdb-文件时如何处理请求">Redis 在生成 RDB 文件时如何处理请求?</h2>
<p>在 Redis 生成 RDB文件时是异步的(使用 bgsave 命令)，采用了fork子进程的方式来进行快照操作，生成 RD8文件的过程由子进程执行，主进程维续处理客户端清求，所以可以保证 Redis在生成快照的过程中依然对外提供服务，不会影响正常请求。</p>
<h2 id="生成-rdb-文件的时候数据可以修改吗">生成 RDB 文件的时候，数据可以修改吗?</h2>
<p>当然可以。主进程会正常处理客户端的请求，进行数据的修改，但数据被修改还叫快照吗?</p>
<p>此时就运用了写时复制的技术。当主进程 fork 出一个子进程后，并不会把主进程的所有内存数据重新复制一份给子进程，而是让主进程和子进程共享相同的内存页面。</p>
<p>底层的实现仅仅复制了页表，但映射的物理内存还是同一个。这样做可以加快 fork 的速度，减少性能损耗(fork会阻塞主进程)。</p>
<h2 id="aof方式">AOF方式</h2>
<p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p>
<p>默认情况下Redis没有开启AOF方式的持久化，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code>。开启AOF方式持久化后每执行一条写命令，Redis就会将该命令写进<code>aof_buf</code>缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>默认情况下系统<strong>每30秒</strong>会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过<code>appendfsync</code>参数设置同步的时机。</p>
<pre><code>appendfsync always //每次写入aof文件都会执行同步，最安全最慢，不建议配置
appendfsync everysec  //既保证性能也保证安全，建议配置
appendfsync no //由操作系统决定何时进行同步操作
</code></pre>
<p>接下来看一下 AOF 持久化执行流程：</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202409281054721.png" alt="" loading="lazy"></p>
<ol>
<li>所有的写入命令会追加到 AOP 缓冲区中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘同步。</li>
<li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li>
<li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li>
<li>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>对于同一份文件AOF文件比RDB数据快照要大。</li>
<li>数据恢复比较慢。</li>
</ol>
<h2 id="rdf和aof的区别">RDF和AOF的区别？</h2>
<ol>
<li>记录的数据不一样：
<ul>
<li>RDB 快照就是记录某一个瞬间的内存数据，<strong>记录的是实际数据</strong>，而 AOF 文件<strong>记录的是命令操作的日志</strong></li>
<li>AOF 文件的内容是<strong>操作命令</strong>；RDB 文件的内容是<strong>二进制数据</strong>。</li>
</ul>
</li>
<li>恢复数据和执行频率：
<ul>
<li>RDB是全量快照，<strong>恢复数据更快</strong>，AOF则需要额外执行操作命令，相对更慢。</li>
<li>RDB是全量快照，<strong>不宜频繁执行</strong>，而AOF数据文件更新比较及时，比RDB保存更完整的数据，这样在数据恢复时能够恢复尽量完整的数据，降低丢失数据的风险。因此发生故障时，RDB丢失的数据会比 AOF 持久化的方式更多</li>
</ul>
</li>
<li>是否影响主进程
<ul>
<li>AOF的Always写回策略是<code>主进程</code>执行的，总是调用fsync函数；Everysec异步执行，不影响主线程；No则redis不控制写回，最终交给操作系统决定何时写回；不影响主线程。</li>
<li>RDB可以将工作交给<code>子进程</code>来做，此时Redis主线程还可以继续处理操作命令。</li>
</ul>
</li>
</ol>
<p>如果同时存在RDB文件和AOF文件，Redis会<strong>优先使用AOF</strong>文件进行数据恢复。</p>
<h2 id="rdb和aof如何选择">RDB和AOF如何选择？</h2>
<p>RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p>
<ul>
<li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li>
<li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li>
</ul>
<p>因此可以使用混合持久化，混合持久化就是混合使用 AOF 日志和RDB</p>
<p>混合持久化工作在 <strong>AOF日志重写</strong>过程中：<br>
会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后写时复制时修改数据再以 AOF 的格式化追加的文件的末尾，写入完成后再新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p>
<p>优点：</p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的恢复数据，同时结合 AOF 的优点，减低了大量数据丢失的风险。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-25 09:00">2025-08-25 09:00</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">程序员Seven</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19054722);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19054722', targetLink: 'https://www.cnblogs.com/seven97-top/p/19054722', title: 'Redis支持事务吗？了解Redis的持久化机制吗？' })">举报</a>
</div>
        