
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18945891/secp256k1_2" title="发布于 2025-06-30 17:52">
    <span role="heading" aria-level="2">secp256k1算法详解二（关键理论及源码分析）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文首先给出secp256k1库中关键数据结构的定义，并介绍了其含义，之后介绍了两个该库函数实现中用的理论基础，最后对库中关键的核心函数进行了源码分析！
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1 关键结构体</h1>
<h2>1.1&nbsp;secp256k1_fe</h2>
<p>secp256k1库域元素field element，其具体定义如下</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* This field implementation represents the value as 10 uint32_t limbs in base
 *  2^26. </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
typedef </span><span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> {
   </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> A field element f represents the sum(i=0..9, f.n[i] &lt;&lt; (i*26)) mod p,
    * where p is the field modulus, 2^256 - 2^32 - 977.
    *
    * The individual limbs f.n[i] can exceed 2^26; the field's magnitude roughly
    * corresponds to how much excess is allowed. The value
    * sum(i=0..9, f.n[i] &lt;&lt; (i*26)) may exceed p, unless the field element is
    * normalized. </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    uint32_t n[</span><span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">];
    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">
     * Magnitude m requires:
     *     n[i] &lt;= 2 * m * (2^26 - 1) for i=0..8
     *     n[9] &lt;= 2 * m * (2^22 - 1)
     *
     * Normalized requires:
     *     n[i] &lt;= (2^26 - 1) for i=0..8
     *     sum(i=0..9, n[i] &lt;&lt; (i*26)) &lt; p
     *     (together these imply n[9] &lt;= 2^22 - 1)
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    SECP256K1_FE_VERIFY_FIELDS
} secp256k1_fe;</span></pre>
</div>
<p>由定义可知，secp256k1_fe由10个uint32_t变量进行数据存储，9 个 26 位字（n[0]到n[8]）和1 个 22 位字（n[9]），总位数为：9*26+22=256位，每个字大小为：n[i] ≤ 2^26 - 1（i=0..8），n[9] ≤ 2^22 - 1。在定义VERIFY时，m（magnitude）是一个缩放因子（scaling factor），用于控制每个字的最大允许值。具体来说：</p>
<p>对于前 9 个字（i=0..8）：<br>n[i] ≤ 2 × m × (2^26 - 1)<br>这意味着每个字的最大值被放大了 2m 倍。<br>对于最后一个字（i=9）：<br>n[9] ≤ 2 × m × (2^22 - 1)<br>同样被放大了 2m 倍。</p>
<p>在椭圆曲线运算（如模乘、点加）中，中间结果可能会超出单个字的范围。通过允许每个字暂时存储更大的值（通过m缩放），可以避免频繁的归一化（normalization）操作，从而提高效率。这里的归一化，是将每个字的值压缩到标准范围（如 n[i] ≤ 2^26 - 1）的过程。当m=1时：</p>
<p>前9个字的最大值为2 × (2^26 - 1) = 134,217,726（二进制下 27 位）。<br>最后一个字的最大值为2 × (2^22 - 1) = 8,388,606（二进制下 24 位）。</p>
<p>此外根据椭圆曲线方程，x坐标三次方运算可能导致中间结果快速增长，需要更大的临时存储空间，所以x能需要更大缩放希数，如下定义</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* Maximum allowed magnitudes for group element coordinates
 *  in affine (x, y) and jacobian (x, y, z) representation. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 0, 255, 1)">#define</span> SECP256K1_GE_X_MAGNITUDE_MAX  4
<span style="color: rgba(0, 0, 255, 1)">#define</span> SECP256K1_GE_Y_MAGNITUDE_MAX  3
<span style="color: rgba(0, 0, 255, 1)">#define</span> SECP256K1_GEJ_X_MAGNITUDE_MAX 4
<span style="color: rgba(0, 0, 255, 1)">#define</span> SECP256K1_GEJ_Y_MAGNITUDE_MAX 4
<span style="color: rgba(0, 0, 255, 1)">#define</span> SECP256K1_GEJ_Z_MAGNITUDE_MAX 1</pre>
</div>
<h2>1.2 secp256k1_fe_storage</h2>
<p>typedef struct {<br>&nbsp; &nbsp; uint32_t n[8];<br>} secp256k1_fe_storage;</p>
<p>正如其名称显示，该数据结构用8个uint32_t表示大数，最大支持256位大数。</p>
<h2>1.3&nbsp;secp256k1_ge &amp; secp256k1_gej</h2>
<p>群元素group element，椭圆曲线上点的仿射坐标（affine coordinates），x和y坐标都是secp256k1_fe类型大数，infinity变量指明点是否为无穷远点。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* A group element in affine coordinates on the secp256k1 curve,
 *  or occasionally on an isomorphic curve of the form y^2 = x^3 + 7*t^6.
 *  Note: For exhaustive test mode, secp256k1 is replaced by a small subgroup of a different curve.
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
typedef </span><span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> {
    secp256k1_fe x;
    secp256k1_fe y;
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> infinity; <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> whether this represents the point at infinity </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
} secp256k1_ge;</span></pre>
</div>
<p>椭圆曲线上点的Jacobian射影坐标，射影坐标(x, y, z)对应的仿射坐标为(x/z^2, y/z^3)，同样infinity变量指明点是否为无穷远点。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* A group element of the secp256k1 curve, in jacobian coordinates.
 *  Note: For exhastive test mode, secp256k1 is replaced by a small subgroup of a different curve.
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
typedef </span><span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> {
    secp256k1_fe x; </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> actual X: x/z^2 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    secp256k1_fe y; </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> actual Y: y/z^3 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    secp256k1_fe z;
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> infinity; <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> whether this represents the point at infinity </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
} secp256k1_gej;</span></pre>
</div>
<h2>1.4 secp256k1_ge_storage</h2>
<p>以存储形式表示的group element，该形式坐标无法表示无穷远点。</p>
<div class="cnblogs_code">
<pre>typedef <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> {
    secp256k1_fe_storage x;
    secp256k1_fe_storage y;
} secp256k1_ge_storage;</span></pre>
</div>
<h1>2 关键理论</h1>
<h2>2.1&nbsp;Schoolbook 算法</h2>
<p>Schoolbook 算法（竖式乘法算法）是最基础的多精度整数乘法方法，直接模拟人类手算乘法的过程。它易于理解和实现，适用于中小规模的数值计算。</p>
<h3>一 核心原理</h3>
<p>Schoolbook算法的核心思想是将多位数乘法拆解为多个单字乘法和累加操作，类似于小学竖式计算：<br><strong>逐位相乘</strong>：用乘数的每一位分别去乘被乘数的每一位，得到部分积。<br><strong>错位累加</strong>：将每个部分积按位对齐后累加，得到最终结果。</p>
<h3>二 算法步骤（以十进制为例）</h3>
<p>假设计算两个多位数A*B，其中：</p>
<p>A = a<sub>n-1</sub>a<sub>n-2</sub>...a<sub>1</sub>a<sub>0</sub>（共n位）</p>
<p>B = b<sub>m-1</sub>b<sub>m-2</sub>...b<sub>1</sub>b<sub>0</sub>（共m位）</p>
<p><strong>具体步骤：</strong></p>
<p>1 <strong>初始化结果数组</strong>：创建一个长度为n+m的数组C，用于存储中间结果和最终乘积。<br>2 <strong>逐位相乘并累加</strong>：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span> range(m):  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 遍历乘数的每一位</span>
<span style="color: rgba(0, 128, 128, 1)">2</span>     carry =<span style="color: rgba(0, 0, 0, 1)"> 0
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> j <span style="color: rgba(0, 0, 255, 1)">in</span> range(n):  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 遍历被乘数的每一位</span>
<span style="color: rgba(0, 128, 128, 1)">4</span>         <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 计算当前位的乘积和进位</span>
<span style="color: rgba(0, 128, 128, 1)">5</span>         product = a[j] × b[i] + C[i+j] +<span style="color: rgba(0, 0, 0, 1)"> carry
</span><span style="color: rgba(0, 128, 128, 1)">6</span>         C[i+j] = product % 10  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 当前位的结果</span>
<span style="color: rgba(0, 128, 128, 1)">7</span>         carry = product // 10  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 进位</span>
<span style="color: rgba(0, 128, 128, 1)">8</span>     C[i+n] = carry  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 处理最高位的进位</span></pre>
</div>
<p>3 <strong>结果处理</strong>：</p>
<p>数组C即为最终乘积，可能包含前导零，需按需处理。</p>
<h3>三 计算机实现细节（多字乘法）</h3>
<p>在计算机中，多精度整数通常以<strong>字数组</strong>（Word Array）形式存储，每个字（Word）是一个固定位数的整数（如 32 位或 64 位）。此时 Schoolbook 算法的实现需注意：</p>
<p>1 <strong>单字乘法的处理</strong>：</p>
<p>两个w位的字相乘可能产生2w位的结果，需用两个字表示。例如，32位 × 32位 → 64位结果，需拆分为高位和低位两部分。</p>
<p>2 <strong>进位管理</strong>：</p>
<p>每次乘法产生的进位需传递到高位，累加中间结果时需处理多字进位。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> A = [0xFF, 0xFF<span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> B = [0xFF, 0xFF, 0xFF<span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> C = [0, 0, 0, 0, 0]  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 结果数组</span>
<span style="color: rgba(0, 128, 128, 1)"> 4</span> w = 8
<span style="color: rgba(0, 128, 128, 1)"> 5</span> m = 3
<span style="color: rgba(0, 128, 128, 1)"> 6</span> n = 2
<span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(m):
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     carry =<span style="color: rgba(0, 0, 0, 1)"> 0
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     
<span style="color: rgba(0, 128, 128, 1)">10</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> j <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(n):
</span><span style="color: rgba(0, 128, 128, 1)">11</span>         product = A[j] *<span style="color: rgba(0, 0, 0, 1)"> B[i]
</span><span style="color: rgba(0, 128, 128, 1)">12</span>         product_high = product &gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> w
</span><span style="color: rgba(0, 128, 128, 1)">13</span>         product_low = product &amp; ((1 &lt;&lt; w) - 1<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">14</span>         
<span style="color: rgba(0, 128, 128, 1)">15</span>         <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 累加低位部分到当前位置</span>
<span style="color: rgba(0, 128, 128, 1)">16</span>         sum_low = product_low + C[i+<span style="color: rgba(0, 0, 0, 1)">j]
</span><span style="color: rgba(0, 128, 128, 1)">17</span>         carry = sum_low &gt;&gt; w  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 进位传递到下一位</span>
<span style="color: rgba(0, 128, 128, 1)">18</span>         C[i+j] = sum_low &amp; ((1 &lt;&lt; w) - 1<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">19</span>         
<span style="color: rgba(0, 128, 128, 1)">20</span>         <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 累加高位部分及进位到下一个位置</span>
<span style="color: rgba(0, 128, 128, 1)">21</span>         C[i+j+1] += product_high+<span style="color: rgba(0, 0, 0, 1)">carry
</span><span style="color: rgba(0, 128, 128, 1)">22</span> 
<span style="color: rgba(0, 128, 128, 1)">23</span> <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">result\n0x</span><span style="color: rgba(128, 0, 0, 1)">"</span>, end=<span style="color: rgba(128, 0, 0, 1)">""</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">24</span> <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span> range(m+<span style="color: rgba(0, 0, 0, 1)">n):
</span><span style="color: rgba(0, 128, 128, 1)">25</span>     <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span>%C[m+n-1-i], end=<span style="color: rgba(128, 0, 0, 1)">""</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">26</span> <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">""</span>)</pre>
</div>
<p>程序中第11~13行将乘积分成高低字节两部分，第16行将低字节部分和当前位置现有值相加，17行获取相加结果的进位，18行将相加结果的低字节部分保留在当前位置，21行将之前乘积的高字节部分和产生的进位一起累加到下一个位置，最后输出最终结果。</p>
<h2>2.2 二次剩余及相关理论</h2>
<h3>一 欧拉函数</h3>
<p>对于正整数n，欧拉函数φ(n)表示小于n且与n互质的数的个数。如果n是质数，则φ(n)=n-1。如果n可以分解成两个互质的整数之积，则其欧拉函数等于其互质因子欧拉函数之积，即φ(n)=φ(p<sub>1</sub>p<sub>2</sub>)=φ(p<sub>1</sub>)φ(p<sub>2</sub>)。</p>
<h3>二 欧拉定理</h3>
<p>费马小定理：若p是质数，且整数a满足gcd(a, p) = 1，则a<sup>p-1</sup>&nbsp;≡ 1 mod p。其经典证明如下：</p>
<p>1 构造互质的剩余希</p>
<p>考虑小于p的正整数集合S = { 1, 2, 3, ..., p-1 }，由于p是质数，且gcd(a, p) = 1，则集合S中每个元素与p互质，且a与p也互质。</p>
<p>构造新集合T = { a*1 mod p, a*2 mod p, a*(p-1) mod p}，即对S中每个元素乘以a后取模p。</p>
<p>2 证明T是S的一个排列</p>
<p>需证明T中的元素与S中的元素完全相同（仅顺序可能不同）：</p>
<p><strong>互质性</strong>：由于gcd(a, p) = 1且gcd(k, p) = 1（k&nbsp;<span class="base"><span class="mrel">∈&nbsp;<span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">S），根据互质性质，gcd(a*k, p) = 1，因此a*k mod p仍属于S（即T ⊆ S）。</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal"><strong>唯一性</strong>：若a*k<sub>1</sub>&nbsp;≡ a*k<sub>2</sub> mod p，则a*(k<sub>1</sub> - k<sub>2</sub>)&nbsp;≡ 0 mod p，由于gcd(a, p) = 1，可推出k<sub>1</sub>&nbsp;≡ k<sub>2</sub> mod p，又因为k<sub>1</sub>，k<sub>2</sub> &lt; p，故k<sub>1</sub> = k<sub>2</sub>，即T中元素互不相同。</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">因此，T是S的一个排列（元素完全一致，顺序不同）。</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">3 两边乘积的同余关系</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">由于T是S的排列，两集合中的所有元素的乘积模p相等：</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">(a*1)*(a*2)*...*(a*(p-1))&nbsp;≡ 1*2*...*(p-1) mod p<br></span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">左边可化简为：</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">a<sup>p-1</sup>*(1*2*...*(p-1)&nbsp;≡ (1*2*...*(p-1) mod p，令W = 1*2*...*(p-1)，则上式变为：</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">a<sup>p-1</sup>*W&nbsp;≡ W mod p</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">4 消去W得到结论</span></span></span></span></span></span></p>
<p><span class="base"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">由于p是质数，W = (p-1)!与p互质，因此可以同余式两边同时除于W（或乘以W的逆元），即得a<sup>p-1</sup>&nbsp;≡ W mod p。</span></span></span></span></span></span></p>
<p>欧拉定理是费马小定理的推广，使用于更一般的情形。其定义：若两个正整数a和n互质（即gcd(a, n) = 1），则a<sup>φ(n)</sup>&nbsp;≡ 1 mod n，φ(n)是欧拉函数。其证明过程类似。</p>
<h3><strong>三 二次剩余</strong></h3>
<p>设p是一个正整数（通常为质数），且<strong>整数a与p互质</strong>（即gcd(a, p) = 1），如果存在整数x使得：x<sup>2</sup>&nbsp;≡ a mod p，则称a是模p的二次剩余；否则，称a是模p的二次非剩余。简单来说，二次剩余是“模意义下能开平方的数”。例如：</p>
<p>模7时，1<sup>2</sup> ≡ 1，2<sup>2</sup>&nbsp;≡ 4，3<sup>2</sup>&nbsp;≡ 2，4<sup>2</sup>&nbsp;≡ 2，5<sup>2</sup>&nbsp;≡ 4，6<sup>2</sup>&nbsp;≡ 1，因此1、2、4是模7的二次剩余，3、5、6是模7的二次非剩余。</p>
<p>二次剩余有如下关键性质</p>
<p>1 数量对称性</p>
<p>若p是奇质数，则模p的二次剩余和二次非剩余各有(p-1)/2个。</p>
<p>2 欧拉判别法</p>
<p>对于奇质数p和与p互质的整数a，a是模p的二次剩余的充要条件是：a<sup>(p-1)/2</sup>&nbsp;≡ 1 mod p，若a是二次非剩余，则：a<sup>(p-1)/2</sup>&nbsp;≡ -1 mod p。</p>
<p>3 勒让德符号</p>
<p>为简化二次剩余的表示，定义勒让德符号</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250630152040645-693217982.png" alt="" width="291" height="74" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>其核心性质是：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250630152243581-365795426.png" alt="" width="410" height="37" loading="lazy"></p>
<p>后续的secp256k1_fe_sqrt函数实现用到了这里的二次剩余理论，在这里先提前说一下，因为a是模p的二次剩余的充要条件是a<sup>(p-1)/2</sup>&nbsp;≡ 1 mod p，则有a*a<sup>(p-1)/2</sup>&nbsp;≡ a mod p，即a<sup>(p+1)/2</sup>&nbsp;≡ a mod p，如果存在k使得p=4*k+3，那么(p+1)/4正好是整数，这时有(a<sup>(p+1)/4</sup>)<sup>2</sup> ≡ a mod p，也就是说如果a是模p的二次剩余，则a<sup>(p+1)/4</sup>必是a的开方之一（模p操作下），这正是secp256k1_fe_sqrt函数的理论基础。</p>
<h1>3 关键函数解析</h1>
<h2>3.1&nbsp;secp256k1_fe_normalize</h2>
<p>该函数实现大数的归一化操作，其实现如下</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> secp256k1_fe_normalize(secp256k1_fe *<span style="color: rgba(0, 0, 0, 1)">r) {
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span>     uint32_t t0 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">0</span>], t1 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">1</span>], t2 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">2</span>], t3 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">3</span>], t4 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">],
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>              t5 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">5</span>], t6 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">6</span>], t7 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">7</span>], t8 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">8</span>], t9 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> 
<span style="color: rgba(0, 128, 128, 1)"> 5</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Reduce t9 at the start so there will be at most a single carry from the first pass </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 0, 0, 1)">    uint32_t m;
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>     uint32_t x = t9 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">22</span>; t9 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x03FFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> 
<span style="color: rgba(0, 128, 128, 1)"> 9</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> The first pass ensures the magnitude is 1, ... </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">10</span>     t0 += x * <span style="color: rgba(128, 0, 128, 1)">0x3D1UL</span>; t1 += (x &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">11</span>     t1 += (t0 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t0 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">12</span>     t2 += (t1 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t1 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">13</span>     t3 += (t2 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t2 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m =<span style="color: rgba(0, 0, 0, 1)"> t2;
</span><span style="color: rgba(0, 128, 128, 1)">14</span>     t4 += (t3 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t3 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t3;
</span><span style="color: rgba(0, 128, 128, 1)">15</span>     t5 += (t4 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t4 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t4;
</span><span style="color: rgba(0, 128, 128, 1)">16</span>     t6 += (t5 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t5 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t5;
</span><span style="color: rgba(0, 128, 128, 1)">17</span>     t7 += (t6 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t6 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t6;
</span><span style="color: rgba(0, 128, 128, 1)">18</span>     t8 += (t7 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t7 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t7;
</span><span style="color: rgba(0, 128, 128, 1)">19</span>     t9 += (t8 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t8 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; m &amp;=<span style="color: rgba(0, 0, 0, 1)"> t8;
</span><span style="color: rgba(0, 128, 128, 1)">20</span> 
<span style="color: rgba(0, 128, 128, 1)">21</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">22</span> 
<span style="color: rgba(0, 128, 128, 1)">23</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> At most a single final reduction is needed; check if the value is &gt;= the field characteristic </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">24</span>     x = (t9 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">22</span>) | ((t9 == <span style="color: rgba(128, 0, 128, 1)">0x03FFFFFUL</span>) &amp; (m == <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">25</span>         &amp; ((t1 + <span style="color: rgba(128, 0, 128, 1)">0x40UL</span> + ((t0 + <span style="color: rgba(128, 0, 128, 1)">0x3D1UL</span>) &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>)) &gt; <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">));
</span><span style="color: rgba(0, 128, 128, 1)">26</span> 
<span style="color: rgba(0, 128, 128, 1)">27</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Apply the final reduction (for constant-time behaviour, we do it always) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">28</span>     t0 += x * <span style="color: rgba(128, 0, 128, 1)">0x3D1UL</span>; t1 += (x &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">29</span>     t1 += (t0 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t0 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">30</span>     t2 += (t1 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t1 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">31</span>     t3 += (t2 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t2 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">32</span>     t4 += (t3 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t3 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">33</span>     t5 += (t4 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t4 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">34</span>     t6 += (t5 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t5 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">35</span>     t7 += (t6 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t6 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">36</span>     t8 += (t7 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t7 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">37</span>     t9 += (t8 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t8 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">38</span> 
<span style="color: rgba(0, 128, 128, 1)">39</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> If t9 didn't carry to bit 22 already, then it should have after any final reduction </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">40</span> 
<span style="color: rgba(0, 128, 128, 1)">41</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Mask off the possible multiple of 2^256 from the final reduction </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">42</span>     t9 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x03FFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">43</span> 
<span style="color: rgba(0, 128, 128, 1)">44</span>     r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">0</span>] = t0; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">1</span>] = t1; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">2</span>] = t2; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">3</span>] = t3; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">4</span>] =<span style="color: rgba(0, 0, 0, 1)"> t4;
</span><span style="color: rgba(0, 128, 128, 1)">45</span>     r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">5</span>] = t5; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">6</span>] = t6; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">7</span>] = t7; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">8</span>] = t8; r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">9</span>] =<span style="color: rgba(0, 0, 0, 1)"> t9;
</span><span style="color: rgba(0, 128, 128, 1)">46</span> }</pre>
</div>
<p>域的模数p = 2<sup>256</sup> - 2<sup>32</sup> - 977，域中大数r被分为10个limbs，其标准表示为每个limb是26-bit数（除了最后一个是22-bit数），即：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250625151039594-1242997972.png" alt="" width="274" height="63" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>如之前所描述，由于magnitude的存在，在运算过程中，会使某些limbs超过26-bit，导致进位错误。归一化目标：1 确保最终值 &lt; p; 2 所有limbs小于2<sup>26</sup>（除了t9，小于2<sup>22</sup>）。</p>
<p>在函数中共进行了两次模约减操作，首轮模约减主要目的是去除高位t9的22-bit之后多余部分：</p>
<div class="cnblogs_code">
<pre>uint32_t x = t9 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">22</span>;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 取出超过 256 位的部分</span>
t9 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x03FFFFFUL</span>;      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 保留低 22 位</span></pre>
</div>
<p>这里的x值为r/2<sup>256</sup>向下取整，由SECP256K1_GE_X_MAGNITUDE_MAX等宏定义可知x最大为4-bit数，因为2<sup>256</sup>&nbsp;≡ 2<sup>32</sup> + 977 mod p，所以超出2<sup>256</sup>部分即为 x*2<sup>256</sup>&nbsp;≡ x*(2<sup>32</sup>&nbsp;+ 977) mod p&nbsp;≡ x*(1 &lt;&lt; 32) + x*977 mod p&nbsp;≡ x*(1 &lt;&lt; 6)*2<sup>26</sup> + x*977 mod p，由以上推理可知，x*2<sup>256</sup>在模p操作下，可分解为两部分，其中x*977（即x*0x3D1）可加到t0部分，而x*2<sup>32</sup>可以将乘积的高于26-bit部分x&lt;&lt;6加到t1，由于x最大为4-bit数，所以x&lt;&lt;6最大为10-bit数，也就是x*2<sup>256</sup>高位在模p意义下，只能循环传导到t0和t1，对应代码第10行。之后11~19行，依次按标准模式计算t0~t8，本级保留低26-bits，进位加到下一级，最终所有进位传导到t9。运行进行到这里会有两种情况：1, t9 &gt;&gt; 22为1，即&nbsp;t9有进位，说明大数归一化值还大于<span class="katex"><span class="katex-mathml">2<sup>256</sup><span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord"><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">，需要进一步归约；2, t9 == 2<sup>22</sup> - 1（即最大值），t2~t8也都为</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>0x3FFFFFF<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord"><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">最大值，因为2<sup>256</sup> - p = 0x1000003d1 = 0x40*2<sup>26</sup> + 0x3d1，所以如果</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>t1 + 0x40 + ((t0 + 0x3D1UL) &gt;&gt; 26大于0x3FFFFFF，则必然产生向t2的进位，从而直接导致最终t9超过最大值，也即和超过2<sup>256</sup>，假设大数归一化值是A，可用不等式A+(2<sup>256</sup>&nbsp;- p)&nbsp;≥ 2<sup>256</sup>，即A&nbsp;≥ p，当A等于p时，其加法可以通过下图清楚的看到各进位情况。简单的说就是这两种情况就是第一次归一化后的值大于2<sup>256</sup>或者大于或等于p，对应代码24~25行，这两种情况下就仍需进一步归一化操作（可以进一步验证在magnitude不大于4的情况下，第一次归一化操作后进位x最大为1）。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250626115038607-1251532956.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>类似于第一次归一化，代码28~37行，将可能为1的进位x依次传导到t0~t9中，然后第42行将已经“补偿”到低位的最高位用且操作消除掉，最后44~45将结果赋值给远大数变量。了解了该函数的原理，函数secp256k1_fe_normalize_weak就更好理解了，它只是进行了一次归一化操作，也就是说最终结果t9可能还在23bit处包含1个最高进位。</p>
<h2>3.2&nbsp;secp256k1_fe_normalizes_to_zero</h2>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_42c569b1-7ea7-449a-a03f-ea3273e0eb28" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_42c569b1-7ea7-449a-a03f-ea3273e0eb28" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_42c569b1-7ea7-449a-a03f-ea3273e0eb28" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">int</span> secp256k1_fe_normalizes_to_zero(secp256k1_fe *<span style="color: rgba(0, 0, 0, 1)">r) {
    uint32_t t0 </span>= r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">0</span>], t1 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">1</span>], t2 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">2</span>], t3 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">3</span>], t4 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">],
             t5 </span>= r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">5</span>], t6 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">6</span>], t7 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">7</span>], t8 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">8</span>], t9 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">];

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    uint32_t z0, z1;

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> Reduce t9 at the start so there will be at most a single carry from the first pass </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    uint32_t x </span>= t9 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">22</span>; t9 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x03FFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> The first pass ensures the magnitude is 1, ... </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    t0 </span>+= x * <span style="color: rgba(128, 0, 128, 1)">0x3D1UL</span>; t1 += (x &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">);
    t1 </span>+= (t0 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t0 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0  = t0; z1  = t0 ^ <span style="color: rgba(128, 0, 128, 1)">0x3D0UL</span><span style="color: rgba(0, 0, 0, 1)">;
    t2 </span>+= (t1 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t1 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t1; z1 &amp;= t1 ^ <span style="color: rgba(128, 0, 128, 1)">0x40UL</span><span style="color: rgba(0, 0, 0, 1)">;
    t3 </span>+= (t2 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t2 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t2; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t2;
    t4 </span>+= (t3 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t3 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t3; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t3;
    t5 </span>+= (t4 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t4 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t4; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t4;
    t6 </span>+= (t5 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t5 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t5; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t5;
    t7 </span>+= (t6 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t6 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t6; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t6;
    t8 </span>+= (t7 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t7 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t7; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t7;
    t9 </span>+= (t8 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">26</span>); t8 &amp;= <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>; z0 |= t8; z1 &amp;=<span style="color: rgba(0, 0, 0, 1)"> t8;
                                         z0 </span>|= t9; z1 &amp;= t9 ^ <span style="color: rgba(128, 0, 128, 1)">0x3C00000UL</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) </span><span style="color: rgba(0, 128, 0, 1)">*/</span>

    <span style="color: rgba(0, 0, 255, 1)">return</span> (z0 == <span style="color: rgba(128, 0, 128, 1)">0</span>) | (z1 == <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">);
}</span></pre>
</div>
<span class="cnblogs_code_collapse">secp256k1_fe_normalize_to_zero</span></div>
<p>该函数在不完全归一化（normalize）整个字段元素的情况下，判断其值是否为零或等于模数，代码中z0用于检测是否所有位都为 0，z1用于检测是否所有位构成了模数p。类似secp256k1_fe_normalizes_to_zero_var函数是secp256k1_fe_normalizes_to_zero的变体（var）版，其功能与前者一致：判断一个字段元素是否为0或模数p（即归一化后是否为 0），但使用了更快路径和懒惰归一化以提高性能，该函数的关键代码如下：</p>
<div class="cnblogs_code">
<pre>t0 = r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
t9 </span>= r-&gt;n[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">];
x </span>= t9 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">22</span><span style="color: rgba(0, 0, 0, 1)">;
t0 </span>+= x * <span style="color: rgba(128, 0, 128, 1)">0x3D1UL</span><span style="color: rgba(0, 0, 0, 1)">;
z0 </span>= t0 &amp; <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">;
z1 </span>= z0 ^ <span style="color: rgba(128, 0, 128, 1)">0x3D0UL</span><span style="color: rgba(0, 0, 0, 1)">;

</span><span style="color: rgba(0, 0, 255, 1)">if</span> ((z0 != <span style="color: rgba(128, 0, 128, 1)">0UL</span>) &amp; (z1 != <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span><span style="color: rgba(0, 0, 0, 1)">)) {
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>若t9有进位（超过 22 位），说明有“≥2<sup>256</sup>”成分，我们提取出这部分（乘以 0x3D1 并加回 t0），这是归一化关键。然后立即对 t0 做一次判断：z0 == 0 表示可能是 0，z1 == 0x3FFFFFFUL 表示可能是 P（因为 t0 应该是 0x3D0），如果两个都不满足，直接返回 0，这是个非常快的判断分支。其他部分代码就和secp256k1_fe_normalizes_to_zero一致了。</p>
<h2>3.3 secp256k1_fe_mul_inner</h2>
<p>该函数是大数乘法的内部实现，libsecp256k1的作者Pieter Wuille的设计理念可以总结为："所有公共API都要求输入是完全归一化的，但内部函数可以处理非归一化形式。中间值的大小必须受控，但可以比26位大（比如在该函数内部被限制在30bit），为的是避免频繁的carry"。以下是完整函数</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_c3345043-0732-470f-93df-511110a9cb6a" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_c3345043-0732-470f-93df-511110a9cb6a" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_c3345043-0732-470f-93df-511110a9cb6a" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> SECP256K1_INLINE <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> secp256k1_fe_mul_inner(uint32_t *r, <span style="color: rgba(0, 0, 255, 1)">const</span> uint32_t *a, <span style="color: rgba(0, 0, 255, 1)">const</span> uint32_t *<span style="color: rgba(0, 0, 0, 1)"> SECP256K1_RESTRICT b) {
</span><span style="color: rgba(0, 128, 128, 1)">  2</span> <span style="color: rgba(0, 0, 0, 1)">    uint64_t c, d;
</span><span style="color: rgba(0, 128, 128, 1)">  3</span> <span style="color: rgba(0, 0, 0, 1)">    uint64_t u0, u1, u2, u3, u4, u5, u6, u7, u8;
</span><span style="color: rgba(0, 128, 128, 1)">  4</span> <span style="color: rgba(0, 0, 0, 1)">    uint32_t t9, t1, t0, t2, t3, t4, t5, t6, t7;
</span><span style="color: rgba(0, 128, 128, 1)">  5</span>     <span style="color: rgba(0, 0, 255, 1)">const</span> uint32_t M = <span style="color: rgba(128, 0, 128, 1)">0x3FFFFFFUL</span>, R0 = <span style="color: rgba(128, 0, 128, 1)">0x3D10UL</span>, R1 = <span style="color: rgba(128, 0, 128, 1)">0x400UL</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">  6</span> 
<span style="color: rgba(0, 128, 128, 1)">  7</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">0</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">  8</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">1</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">  9</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">2</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 10</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">3</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 11</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">4</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 12</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">5</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 13</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">6</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 14</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">7</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 15</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">8</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 16</span>     VERIFY_BITS(a[<span style="color: rgba(128, 0, 128, 1)">9</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 17</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">0</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 18</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">1</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 19</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">2</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 20</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">3</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 21</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">4</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 22</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">5</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 23</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">6</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 24</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">7</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 25</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">8</span>], <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 26</span>     VERIFY_BITS(b[<span style="color: rgba(128, 0, 128, 1)">9</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 27</span> 
<span style="color: rgba(0, 128, 128, 1)"> 28</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">* [... a b c] is a shorthand for ... + a&lt;&lt;52 + b&lt;&lt;26 + c&lt;&lt;0 mod n.
</span><span style="color: rgba(0, 128, 128, 1)"> 29</span> <span style="color: rgba(0, 128, 0, 1)">     *  for 0 &lt;= x &lt;= 9, px is a shorthand for sum(a[i]*b[x-i], i=0..x).
</span><span style="color: rgba(0, 128, 128, 1)"> 30</span> <span style="color: rgba(0, 128, 0, 1)">     *  for 9 &lt;= x &lt;= 18, px is a shorthand for sum(a[i]*b[x-i], i=(x-9)..9)
</span><span style="color: rgba(0, 128, 128, 1)"> 31</span> <span style="color: rgba(0, 128, 0, 1)">     *  Note that [x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0].
</span><span style="color: rgba(0, 128, 128, 1)"> 32</span>      <span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 33</span> 
<span style="color: rgba(0, 128, 128, 1)"> 34</span>     d  = (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 35</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 37</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 38</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 41</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 42</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 43</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(d, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 45</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 46</span>     t9 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 47</span>     VERIFY_BITS(t9, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 48</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">38</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 49</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d t9 0 0 0 0 0 0 0 0 0] = [p9 0 0 0 0 0 0 0 0 0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 50</span> 
<span style="color: rgba(0, 128, 128, 1)"> 51</span>     c  = (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">60</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d t9 0 0 0 0 0 0 0 0 c] = [p9 0 0 0 0 0 0 0 0 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 54</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 55</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 56</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 58</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 59</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 60</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 61</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 62</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 63</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 64</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d t9 0 0 0 0 0 0 0 0 c] = [p10 p9 0 0 0 0 0 0 0 0 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 65</span>     u0 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u0 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)"> 66</span>     VERIFY_BITS(u0, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 67</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 68</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">61</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 69</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u0 t9 0 0 0 0 0 0 0 0 c-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 70</span>     t0 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u0 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)"> 71</span>     VERIFY_BITS(t0, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 72</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 73</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u0 t9 0 0 0 0 0 0 0 c-u0*R1 t0-u0*R0] = [p10 p9 0 0 0 0 0 0 0 0 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 74</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 0 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 75</span> 
<span style="color: rgba(0, 128, 128, 1)"> 76</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 77</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 78</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">62</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 79</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 t9 0 0 0 0 0 0 0 c t0] = [p10 p9 0 0 0 0 0 0 0 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 80</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 83</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 84</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 85</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 86</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 87</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)"> 88</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 89</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 t9 0 0 0 0 0 0 0 c t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 90</span>     u1 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u1 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span>     VERIFY_BITS(u1, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 92</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 93</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 94</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u1 0 t9 0 0 0 0 0 0 0 c-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 95</span>     t1 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u1 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span>     VERIFY_BITS(t1, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">38</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 98</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u1 0 t9 0 0 0 0 0 0 c-u1*R1 t1-u1*R0 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)"> 99</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 0 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">100</span> 
<span style="color: rgba(0, 128, 128, 1)">101</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">102</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">103</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">104</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">62</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">105</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">106</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">107</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">108</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">109</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">110</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">111</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">112</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">113</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">114</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 t9 0 0 0 0 0 0 c t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">115</span>     u2 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u2 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">116</span>     VERIFY_BITS(u2, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">117</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">118</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">119</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u2 0 0 t9 0 0 0 0 0 0 c-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">120</span>     t2 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u2 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">121</span>     VERIFY_BITS(t2, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">122</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">38</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">123</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u2 0 0 t9 0 0 0 0 0 c-u2*R1 t2-u2*R0 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">124</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 0 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">125</span> 
<span style="color: rgba(0, 128, 128, 1)">126</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">127</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">128</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">129</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">130</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">131</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">132</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">133</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">134</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">135</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">136</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">137</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">138</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">139</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 t9 0 0 0 0 0 c t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">140</span>     u3 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u3 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">141</span>     VERIFY_BITS(u3, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">142</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">143</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">144</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u3 0 0 0 t9 0 0 0 0 0 c-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">145</span>     t3 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u3 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">146</span>     VERIFY_BITS(t3, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">147</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">39</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">148</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u3 0 0 0 t9 0 0 0 0 c-u3*R1 t3-u3*R0 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">149</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 0 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">150</span> 
<span style="color: rgba(0, 128, 128, 1)">151</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">152</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">153</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">154</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">155</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">156</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">157</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">158</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">159</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">160</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">161</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">162</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">163</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">62</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">164</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 t9 0 0 0 0 c t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">165</span>     u4 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u4 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">166</span>     VERIFY_BITS(u4, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">167</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">36</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">168</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">169</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u4 0 0 0 0 t9 0 0 0 0 c-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">170</span>     t4 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u4 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">171</span>     VERIFY_BITS(t4, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">172</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">39</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">173</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u4 0 0 0 0 t9 0 0 0 c-u4*R1 t4-u4*R0 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">174</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 0 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">175</span> 
<span style="color: rgba(0, 128, 128, 1)">176</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">177</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">178</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">179</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">180</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">181</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">182</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">183</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">184</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">185</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">186</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">187</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">188</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">62</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">189</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 t9 0 0 0 c t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">190</span>     u5 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u5 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">191</span>     VERIFY_BITS(u5, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">192</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">36</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">193</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">194</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u5 0 0 0 0 0 t9 0 0 0 c-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">195</span>     t5 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u5 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">196</span>     VERIFY_BITS(t5, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">197</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">39</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">198</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u5 0 0 0 0 0 t9 0 0 c-u5*R1 t5-u5*R0 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">199</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 0 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">200</span> 
<span style="color: rgba(0, 128, 128, 1)">201</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">202</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">203</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">204</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">205</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">206</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">207</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">208</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">63</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">209</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">210</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">211</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">212</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">213</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">61</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">214</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 t9 0 0 c t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">215</span>     u6 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u6 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">216</span>     VERIFY_BITS(u6, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">217</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">35</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">218</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">219</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u6 0 0 0 0 0 0 t9 0 0 c-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">220</span>     t6 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u6 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">221</span>     VERIFY_BITS(t6, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">222</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">39</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">223</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u6 0 0 0 0 0 0 t9 0 c-u6*R1 t6-u6*R0 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">224</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 0 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">225</span> 
<span style="color: rgba(0, 128, 128, 1)">226</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">227</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">228</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">229</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">230</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">231</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">232</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">233</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">234</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">235</span>     VERIFY_CHECK(c &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x8000007C00000007ULL);
</span><span style="color: rgba(0, 128, 128, 1)">236</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">237</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">238</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">239</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">58</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">240</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 t9 0 c t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">241</span>     u7 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u7 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">242</span>     VERIFY_BITS(u7, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">243</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">32</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">244</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">245</span>     VERIFY_CHECK(c &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x800001703FFFC2F7ULL);
</span><span style="color: rgba(0, 128, 128, 1)">246</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u7 0 0 0 0 0 0 0 t9 0 c-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">247</span>     t7 = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u7 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">248</span>     VERIFY_BITS(t7, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">249</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">38</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">250</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u7 0 0 0 0 0 0 0 t9 c-u7*R1 t7-u7*R0 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">251</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 0 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">252</span> 
<span style="color: rgba(0, 128, 128, 1)">253</span>     c += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">0</span>] * b[<span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">254</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">1</span>] * b[<span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">255</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">2</span>] * b[<span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">256</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">3</span>] * b[<span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">257</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">4</span>] * b[<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">258</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">5</span>] * b[<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">259</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">6</span>] * b[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">260</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">7</span>] * b[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">261</span>        + (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">8</span>] * b[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">262</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">263</span>     VERIFY_CHECK(c &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x9000007B80000008ULL);
</span><span style="color: rgba(0, 128, 128, 1)">264</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">265</span>     d += (uint64_t)a[<span style="color: rgba(128, 0, 128, 1)">9</span>] * b[<span style="color: rgba(128, 0, 128, 1)">9</span><span style="color: rgba(0, 0, 0, 1)">];
</span><span style="color: rgba(0, 128, 128, 1)">266</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">57</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">267</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 t9 c t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">268</span>     u8 = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u8 *<span style="color: rgba(0, 0, 0, 1)"> R0;
</span><span style="color: rgba(0, 128, 128, 1)">269</span>     VERIFY_BITS(u8, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">270</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">31</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">271</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> VERIFY_BITS(c, 64); </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">272</span>     VERIFY_CHECK(c &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x9000016FBFFFC2F8ULL);
</span><span style="color: rgba(0, 128, 128, 1)">273</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 t3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">274</span> 
<span style="color: rgba(0, 128, 128, 1)">275</span>     r[<span style="color: rgba(128, 0, 128, 1)">3</span>] =<span style="color: rgba(0, 0, 0, 1)"> t3;
</span><span style="color: rgba(0, 128, 128, 1)">276</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">3</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">277</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 t4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">278</span>     r[<span style="color: rgba(128, 0, 128, 1)">4</span>] =<span style="color: rgba(0, 0, 0, 1)"> t4;
</span><span style="color: rgba(0, 128, 128, 1)">279</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">4</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">280</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 t5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">281</span>     r[<span style="color: rgba(128, 0, 128, 1)">5</span>] =<span style="color: rgba(0, 0, 0, 1)"> t5;
</span><span style="color: rgba(0, 128, 128, 1)">282</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">5</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">283</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 t6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">284</span>     r[<span style="color: rgba(128, 0, 128, 1)">6</span>] =<span style="color: rgba(0, 0, 0, 1)"> t6;
</span><span style="color: rgba(0, 128, 128, 1)">285</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">6</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">286</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 t7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">287</span>     r[<span style="color: rgba(128, 0, 128, 1)">7</span>] =<span style="color: rgba(0, 0, 0, 1)"> t7;
</span><span style="color: rgba(0, 128, 128, 1)">288</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">7</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">289</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9 c-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">290</span> 
<span style="color: rgba(0, 128, 128, 1)">291</span>     r[<span style="color: rgba(128, 0, 128, 1)">8</span>] = c &amp; M; c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span>; c += u8 *<span style="color: rgba(0, 0, 0, 1)"> R1;
</span><span style="color: rgba(0, 128, 128, 1)">292</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">8</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">293</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">39</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">294</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d u8 0 0 0 0 0 0 0 0 t9+c-u8*R1 r8-u8*R0 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">295</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 0 t9+c r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">296</span>     c   += d * R0 +<span style="color: rgba(0, 0, 0, 1)"> t9;
</span><span style="color: rgba(0, 128, 128, 1)">297</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">45</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">298</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 0 c-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">299</span>     r[<span style="color: rgba(128, 0, 128, 1)">9</span>] = c &amp; (M &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">4</span>); c &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">22</span>; c += d * (R1 &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">300</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">9</span>], <span style="color: rgba(128, 0, 128, 1)">22</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">301</span>     VERIFY_BITS(c, <span style="color: rgba(128, 0, 128, 1)">46</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">302</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 0 r9+((c-d*R1&lt;&lt;4)&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">303</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [d 0 0 0 0 0 0 0 -d*R1 r9+(c&lt;&lt;22)-d*R0 r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">304</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 t0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">305</span> 
<span style="color: rgba(0, 128, 128, 1)">306</span>     d    = c * (R0 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">4</span>) +<span style="color: rgba(0, 0, 0, 1)"> t0;
</span><span style="color: rgba(0, 128, 128, 1)">307</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">56</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">308</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1 d-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">309</span>     r[<span style="color: rgba(128, 0, 128, 1)">0</span>] = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">310</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">0</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">311</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">312</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 t1+d r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">313</span>     d   += c * (R1 &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">4</span>) +<span style="color: rgba(0, 0, 0, 1)"> t1;
</span><span style="color: rgba(0, 128, 128, 1)">314</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">53</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">315</span>     VERIFY_CHECK(d &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x10000003FFFFBFULL);
</span><span style="color: rgba(0, 128, 128, 1)">316</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9+(c&lt;&lt;22) r8 r7 r6 r5 r4 r3 t2 d-c*R1&gt;&gt;4 r0-c*R0&gt;&gt;4] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">317</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9 r8 r7 r6 r5 r4 r3 t2 d r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">318</span>     r[<span style="color: rgba(128, 0, 128, 1)">1</span>] = d &amp; M; d &gt;&gt;= <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">319</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">1</span>], <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">320</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">27</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">321</span>     VERIFY_CHECK(d &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0x4000000ULL);
</span><span style="color: rgba(0, 128, 128, 1)">322</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9 r8 r7 r6 r5 r4 r3 t2+d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">323</span>     d   +=<span style="color: rgba(0, 0, 0, 1)"> t2;
</span><span style="color: rgba(0, 128, 128, 1)">324</span>     VERIFY_BITS(d, <span style="color: rgba(128, 0, 128, 1)">27</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">325</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9 r8 r7 r6 r5 r4 r3 d r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">326</span>     r[<span style="color: rgba(128, 0, 128, 1)">2</span>] =<span style="color: rgba(0, 0, 0, 1)"> d;
</span><span style="color: rgba(0, 128, 128, 1)">327</span>     VERIFY_BITS(r[<span style="color: rgba(128, 0, 128, 1)">2</span>], <span style="color: rgba(128, 0, 128, 1)">27</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">328</span>     <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 128, 128, 1)">329</span> }</pre>
</div>
<span class="cnblogs_code_collapse">secp256k1_fe_mul_inner</span></div>
<p>函数中第5行对M，R0，R1变量进行了初始化，M取值为了进行异或操作，使得每个limb保留26bit，R0和R1取值和secp256k1_fe_normalize中分析类似，只不过是将大数超过2<sup>260</sup>部分归一化到低位limb，即 2<sup>260</sup>&nbsp;≡ 0x1000003d10&nbsp;mod p&nbsp;≡ (1 &lt;&lt; 36) + 0x3d10 mod p&nbsp;≡ 0x400*2<sup>26</sup>&nbsp;+ 0x3d10 mod p，归一化最低limb部分对应参数R0=0x3d10，次低limb部分对应参数R1=0x400。接下来7~26行是对输入参数的合法性检查，本节开头已经对此做出说明。之后第28~31行的注释说明了数组形式大数的具体含义，以及代码注释中px的含义，此外[x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0]，等式表示大数中超过2<sup>260</sup>部分x，可以通过之前提到的归一化操作，借助R0和R1归一化到最低两个位置，即x*2<sup>260</sup>&nbsp;≡ x*0x400*2<sup>26</sup>&nbsp;+ x*0x3d10 mod p ≡ x*R1 + x*R0 mod p。之后34~43行先求了p9位置的累加和d，46行将累加和d的低26bit值t9留在了p9位置，而后对累加和进行右移位操作，保留高位作为进位放在了p10位置。51行求得了p0位置的值，第54~62行求p10位置累加和，并将该累加和加到了之前的进位d上，第65行，u0是累加和的低26bit值对应位置是p10，继续进行右移位操作保留高位值d（对应位置p11），该行最后一条语句提前为u0向低位归一化做准备（69行注释说明了大数乘积当前各位置对应的实际取值，因为u0还没有完成归一化，所以最低p0位置应为新t加上u0*R0之前的值），70行完成了高位u0向最低两位的归一化操作，此时c为向p1位置的进位，t0为p0位置的值（注释73是归一化之前的对应值，74行是u0完成归一化后各位置对应值，此时已经消去u0）。</p>
<p>接下来，76~77行继续求p1位置对应的大数乘法累加和，并将其加到之前的进位t上，80~87求p11位置对应的大数乘法累加和，并将其加到上一次的进位值d上，第90行保留d低26bit作为p11位置上实际值，并右移保留高位作为向p12位置的进位，同样改行最后一条语句为位置p11向次低位p1做归一化做准备，95行完成归一化操作并移除u1，并获取p1位置值t1。再之后，第101~124行获取p2位置值t2，第126~149行获取p3位置值t3，第151~174行获取p4位置值t4，第176~199行获取p5位置值t5，第201~224行获取p6位置值t6，第226~251行获取p7位置值t7，第253~295行获取p8位置t8，在此期间又将t3~t7存储到了最终结果r[3]~r[7]中（应该是程序做过极限测试，后续的归一化操作已经不会影响到该部分最终的取值）。</p>
<p>第296行将来自p8位置的进位和p18位置d对应归一化低位值以及最一开始获得的t9进行相加获取p9位置的值c，之后，第299行只保留低22bit值赋值给r[9]（最终归一化结果最高位置只保留22bit）,右移22bit保留高位c，最后将p18位置d对应归一化高位值和c进行相加（在此之前都是按照260位大数进行归一化操作，而进行到这一步，c已经相当于超出大数256位之后对应的值），接下来，将按照256位大数进行归一化操作，第306行首先c到最低位部分归一化操作，将对应值和t0相加，第309行将和d低26bit保存到r[0]，右移保留高位d，第313行将对应次低位部分归一化值和t1以及上一步的d进行累加，并更新为d，第318~326行按相同方式依次更新t[1]和t[2]，进行到这里所有归一化进位已经处理完毕算法结束。而大数平方函数secp256k1_fe_sqr_inner的处理过程和该函数基本一致，不再进行详细分析。</p>
<h2>3.4&nbsp;secp256k1_fe_sqrt</h2>
<p>之前的二次剩余理论部分已经得出a如果是模p的二次剩余，则a<sup>(p+1)/4</sup>必是a的开平方，先直接给出函数实现</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_caa67717-be2d-4152-8817-ada5e0979e97" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_caa67717-be2d-4152-8817-ada5e0979e97" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_caa67717-be2d-4152-8817-ada5e0979e97" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> /*
<span style="color: rgba(0, 128, 128, 1)">  2</span> * (p+1)/4 = 
<span style="color: rgba(0, 128, 128, 1)">  3</span> * 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
<span style="color: rgba(0, 128, 128, 1)">  4</span> * 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
<span style="color: rgba(0, 128, 128, 1)">  5</span> * 111111111111110111111111111111111111100001100
<span style="color: rgba(0, 128, 128, 1)">  6</span> * 可以将该二进制按连续1进行分块，分三块，连续1的个数分别是2，22，223
<span style="color: rgba(0, 128, 128, 1)">  7</span> */
<span style="color: rgba(0, 128, 128, 1)">  8</span> static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *<span style="color: rgba(0, 0, 0, 1)">a) {
</span><span style="color: rgba(0, 128, 128, 1)">  9</span>     /** Given that p <span style="color: rgba(0, 0, 255, 1)">is</span> congruent to 3 mod 4<span style="color: rgba(0, 0, 0, 1)">, we can compute the square root of
</span><span style="color: rgba(0, 128, 128, 1)"> 10</span>      *  a mod p as the (p+1)/4<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">th power of a.</span>
<span style="color: rgba(0, 128, 128, 1)"> 11</span>      *
<span style="color: rgba(0, 128, 128, 1)"> 12</span>      *  As (p+1)/4 <span style="color: rgba(0, 0, 255, 1)">is</span> an even number, it will have the same result <span style="color: rgba(0, 0, 255, 1)">for</span> a <span style="color: rgba(0, 0, 255, 1)">and</span> <span style="color: rgba(0, 0, 255, 1)">for</span>
<span style="color: rgba(0, 128, 128, 1)"> 13</span>      *  (-<span style="color: rgba(0, 0, 0, 1)">a). Only one of these two numbers actually has a square root however,
</span><span style="color: rgba(0, 128, 128, 1)"> 14</span>      *  so we test at the end by squaring <span style="color: rgba(0, 0, 255, 1)">and</span><span style="color: rgba(0, 0, 0, 1)"> comparing to the input.
</span><span style="color: rgba(0, 128, 128, 1)"> 15</span>      *  Also because (p+1)/4 <span style="color: rgba(0, 0, 255, 1)">is</span> an even number, the computed square root <span style="color: rgba(0, 0, 255, 1)">is</span>
<span style="color: rgba(0, 128, 128, 1)"> 16</span>      *  itself always a square (a ** ((p+1)/4) <span style="color: rgba(0, 0, 255, 1)">is</span> the square of a ** ((p+1)/8<span style="color: rgba(0, 0, 0, 1)">)).
</span><span style="color: rgba(0, 128, 128, 1)"> 17</span>      */
<span style="color: rgba(0, 128, 128, 1)"> 18</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;
</span><span style="color: rgba(0, 128, 128, 1)"> 19</span> <span style="color: rgba(0, 0, 0, 1)">    int j;
</span><span style="color: rgba(0, 128, 128, 1)"> 20</span> 
<span style="color: rgba(0, 128, 128, 1)"> 21</span>     /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths <span style="color: rgba(0, 0, 255, 1)">in</span>
<span style="color: rgba(0, 128, 128, 1)"> 22</span>      *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> each block:
</span><span style="color: rgba(0, 128, 128, 1)"> 23</span>      *  1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223<span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)"> 24</span>      */
<span style="color: rgba(0, 128, 128, 1)"> 25</span>     secp256k1_fe_sqr(&amp;<span style="color: rgba(0, 0, 0, 1)">x2, a);
</span><span style="color: rgba(0, 128, 128, 1)"> 26</span>     secp256k1_fe_mul(&amp;x2, &amp;x2, a);        // a^3<span style="color: rgba(0, 0, 0, 1)"> 0b11
</span><span style="color: rgba(0, 128, 128, 1)"> 27</span> 
<span style="color: rgba(0, 128, 128, 1)"> 28</span>     secp256k1_fe_sqr(&amp;x3, &amp;x2);            // a^6<span style="color: rgba(0, 0, 0, 1)"> 0b110
</span><span style="color: rgba(0, 128, 128, 1)"> 29</span>     secp256k1_fe_mul(&amp;x3, &amp;x3, a);        // x3 a^7<span style="color: rgba(0, 0, 0, 1)"> 0b111
</span><span style="color: rgba(0, 128, 128, 1)"> 30</span> 
<span style="color: rgba(0, 128, 128, 1)"> 31</span>     x6 =<span style="color: rgba(0, 0, 0, 1)"> x3;
</span><span style="color: rgba(0, 128, 128, 1)"> 32</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++) {               //<span style="color: rgba(0, 0, 0, 1)"> 0b111000
</span><span style="color: rgba(0, 128, 128, 1)"> 33</span>         secp256k1_fe_sqr(&amp;x6, &amp;<span style="color: rgba(0, 0, 0, 1)">x6);
</span><span style="color: rgba(0, 128, 128, 1)"> 34</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 35</span>     secp256k1_fe_mul(&amp;x6, &amp;x6, &amp;x3);    // x6 a^63<span style="color: rgba(0, 0, 0, 1)"> 0b111111
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span> 
<span style="color: rgba(0, 128, 128, 1)"> 37</span>     x9 =<span style="color: rgba(0, 0, 0, 1)"> x6;
</span><span style="color: rgba(0, 128, 128, 1)"> 38</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++) {               //<span style="color: rgba(0, 0, 0, 1)"> 0b111111000
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span>         secp256k1_fe_sqr(&amp;x9, &amp;<span style="color: rgba(0, 0, 0, 1)">x9);
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 41</span>     secp256k1_fe_mul(&amp;x9, &amp;x9, &amp;x3);    // x9 a^511<span style="color: rgba(0, 0, 0, 1)"> 0b111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 42</span> 
<span style="color: rgba(0, 128, 128, 1)"> 43</span>     x11 =<span style="color: rgba(0, 0, 0, 1)"> x9;
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;2; j++) {               //<span style="color: rgba(0, 0, 0, 1)"> 0b11111111100
</span><span style="color: rgba(0, 128, 128, 1)"> 45</span>         secp256k1_fe_sqr(&amp;x11, &amp;<span style="color: rgba(0, 0, 0, 1)">x11);
</span><span style="color: rgba(0, 128, 128, 1)"> 46</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 47</span>     secp256k1_fe_mul(&amp;x11, &amp;x11, &amp;x2);    // x11 a^2047<span style="color: rgba(0, 0, 0, 1)"> 0b11111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 48</span> 
<span style="color: rgba(0, 128, 128, 1)"> 49</span>     x22 =<span style="color: rgba(0, 0, 0, 1)"> x11;
</span><span style="color: rgba(0, 128, 128, 1)"> 50</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;11; j++) {              //<span style="color: rgba(0, 0, 0, 1)"> 0b1111111111100000000000
</span><span style="color: rgba(0, 128, 128, 1)"> 51</span>         secp256k1_fe_sqr(&amp;x22, &amp;<span style="color: rgba(0, 0, 0, 1)">x22);
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span>     secp256k1_fe_mul(&amp;x22, &amp;x22, &amp;x11); //<span style="color: rgba(0, 0, 0, 1)"> x22 0b1111111111111111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 54</span> 
<span style="color: rgba(0, 128, 128, 1)"> 55</span>     x44 =<span style="color: rgba(0, 0, 0, 1)"> x22;
</span><span style="color: rgba(0, 128, 128, 1)"> 56</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;22; j++) {              //<span style="color: rgba(0, 0, 0, 1)"> 0b11111111111111111111110000000000000000000000
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span>         secp256k1_fe_sqr(&amp;x44, &amp;<span style="color: rgba(0, 0, 0, 1)">x44);
</span><span style="color: rgba(0, 128, 128, 1)"> 58</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 59</span>     secp256k1_fe_mul(&amp;x44, &amp;x44, &amp;x22); //<span style="color: rgba(0, 0, 0, 1)"> 0b11111111111111111111111111111111111111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 60</span> 
<span style="color: rgba(0, 128, 128, 1)"> 61</span>     x88 =<span style="color: rgba(0, 0, 0, 1)"> x44;
</span><span style="color: rgba(0, 128, 128, 1)"> 62</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;44; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 63</span>         secp256k1_fe_sqr(&amp;x88, &amp;<span style="color: rgba(0, 0, 0, 1)">x88);
</span><span style="color: rgba(0, 128, 128, 1)"> 64</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 65</span>     secp256k1_fe_mul(&amp;x88, &amp;x88, &amp;x44); //<span style="color: rgba(0, 0, 0, 1)"> 0b1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 66</span> 
<span style="color: rgba(0, 128, 128, 1)"> 67</span>     x176 =<span style="color: rgba(0, 0, 0, 1)"> x88;
</span><span style="color: rgba(0, 128, 128, 1)"> 68</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;88; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 69</span>         secp256k1_fe_sqr(&amp;x176, &amp;<span style="color: rgba(0, 0, 0, 1)">x176);
</span><span style="color: rgba(0, 128, 128, 1)"> 70</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 71</span>     secp256k1_fe_mul(&amp;x176, &amp;x176, &amp;<span style="color: rgba(0, 0, 0, 1)">x88);
</span><span style="color: rgba(0, 128, 128, 1)"> 72</span> 
<span style="color: rgba(0, 128, 128, 1)"> 73</span>     x220 =<span style="color: rgba(0, 0, 0, 1)"> x176;
</span><span style="color: rgba(0, 128, 128, 1)"> 74</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;44; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 75</span>         secp256k1_fe_sqr(&amp;x220, &amp;<span style="color: rgba(0, 0, 0, 1)">x220);
</span><span style="color: rgba(0, 128, 128, 1)"> 76</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 77</span>     secp256k1_fe_mul(&amp;x220, &amp;x220, &amp;<span style="color: rgba(0, 0, 0, 1)">x44);
</span><span style="color: rgba(0, 128, 128, 1)"> 78</span> 
<span style="color: rgba(0, 128, 128, 1)"> 79</span>     x223 =<span style="color: rgba(0, 0, 0, 1)"> x220;
</span><span style="color: rgba(0, 128, 128, 1)"> 80</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span>         secp256k1_fe_sqr(&amp;x223, &amp;<span style="color: rgba(0, 0, 0, 1)">x223);
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 83</span>     secp256k1_fe_mul(&amp;x223, &amp;x223, &amp;<span style="color: rgba(0, 0, 0, 1)">x3);
</span><span style="color: rgba(0, 128, 128, 1)"> 84</span> 
<span style="color: rgba(0, 128, 128, 1)"> 85</span>     /* The final result <span style="color: rgba(0, 0, 255, 1)">is</span> then assembled using a sliding window over the blocks. */
<span style="color: rgba(0, 128, 128, 1)"> 86</span>     t1 =<span style="color: rgba(0, 0, 0, 1)"> x223;
</span><span style="color: rgba(0, 128, 128, 1)"> 87</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;23; j++) {                    //<span style="color: rgba(0, 0, 0, 1)"> 左移23bit，给01111111111111111111111留出位置
</span><span style="color: rgba(0, 128, 128, 1)"> 88</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)"> 89</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 90</span>     secp256k1_fe_mul(&amp;t1, &amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">x22);
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;6; j++) {                    // 000011 length <span style="color: rgba(0, 0, 255, 1)">is</span> 6
<span style="color: rgba(0, 128, 128, 1)"> 92</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)"> 93</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 94</span>     secp256k1_fe_mul(&amp;t1, &amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">x2);
</span><span style="color: rgba(0, 128, 128, 1)"> 95</span>     secp256k1_fe_sqr(&amp;t1, &amp;t1);                // <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> the last two 0
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span>     secp256k1_fe_sqr(r, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span> 
<span style="color: rgba(0, 128, 128, 1)"> 98</span>     /* Check that a square root was actually calculated */
<span style="color: rgba(0, 128, 128, 1)"> 99</span>     secp256k1_fe_sqr(&amp;<span style="color: rgba(0, 0, 0, 1)">t1, r);
</span><span style="color: rgba(0, 128, 128, 1)">100</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> secp256k1_fe_equal(&amp;<span style="color: rgba(0, 0, 0, 1)">t1, a);
</span><span style="color: rgba(0, 128, 128, 1)">101</span> }</pre>
</div>
<span class="cnblogs_code_collapse">secp256k1_fe_sqrt</span></div>
<p>如2~6行注释中做出的解释，(p+1)/4二进制共有3段连续的二进制1，算法正是围绕着该特点进行实现的。</p>
<p>第25行求x2=a<sup>2</sup>，26行求得x2=a<sup>3</sup>=a<sup>0b11</sup>，第28~29行求得x3=a<sup>7</sup>=a<sup>0b111</sup>，第31~35行求得x6=a<sup>63</sup>=a<sup>0b111111</sup>，之后类似，直到第83行求得x223=a<sup>0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff</sup>，至此(p+1)/4最高位部分连续223个二级制1部分的平方已经计算完毕，之后第86行~90行，首先通过平方操作实现“左移23位操作”，将接下来的22个连续二级制1部分内容乘到结果中（这里面包含一个0位）。然后第91行~94行，将最后2个连续1乘到结果内，之后95~96行实现最后“左移2位操作”。最后99~100行结合二次剩余理论，通过开方的平方是否和原a相等，判断a是否真的“可开方“。</p>
<h2>3.5&nbsp;secp256k1_fe_inv</h2>
<p>&nbsp;该函数的实现和secp256k1_fe_sqrt类似，不再进行详细分析，只给出完整的函数实现。</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_2923017a-c50e-4eb7-8753-bda76f99151c" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_2923017a-c50e-4eb7-8753-bda76f99151c" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_2923017a-c50e-4eb7-8753-bda76f99151c" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> /*
<span style="color: rgba(0, 128, 128, 1)"> 2</span> * 在有限域中求数a的模逆，由欧拉公式可知a^fai(p) = 1 mod p，即a^(p-1) = 1<span style="color: rgba(0, 0, 0, 1)"> mod p
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> * 所以a^(p-2<span style="color: rgba(0, 0, 0, 1)">)即为a的逆元,0b11111111111111111111111111111111111111111111111111111111111111111
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
<span style="color: rgba(0, 128, 128, 1)"> 5</span> 1111111111111111111111111111111111111111111111111111111111011111111111111111111110000101101
<span style="color: rgba(0, 128, 128, 1)"> 6</span> */
<span style="color: rgba(0, 128, 128, 1)"> 7</span> static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *<span style="color: rgba(0, 0, 0, 1)">a) {
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> <span style="color: rgba(0, 0, 0, 1)">    int j;
</span><span style="color: rgba(0, 128, 128, 1)">10</span> 
<span style="color: rgba(0, 128, 128, 1)">11</span>     /** The binary representation of (p - 2) has 5 blocks of 1s, with lengths <span style="color: rgba(0, 0, 255, 1)">in</span>
<span style="color: rgba(0, 128, 128, 1)">12</span>      *  { 1, 2, 1, 22, 223 }. Use an addition chain to calculate 2^n - 1 <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> each block:
</span><span style="color: rgba(0, 128, 128, 1)">13</span>      *  [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223<span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 128, 1)">14</span>      */
<span style="color: rgba(0, 128, 128, 1)">15</span>     secp256k1_fe_sqr(&amp;<span style="color: rgba(0, 0, 0, 1)">x2, a);
</span><span style="color: rgba(0, 128, 128, 1)">16</span>     secp256k1_fe_mul(&amp;x2, &amp;<span style="color: rgba(0, 0, 0, 1)">x2, a);
</span><span style="color: rgba(0, 128, 128, 1)">17</span> 
<span style="color: rgba(0, 128, 128, 1)">18</span>     secp256k1_fe_sqr(&amp;x3, &amp;<span style="color: rgba(0, 0, 0, 1)">x2);
</span><span style="color: rgba(0, 128, 128, 1)">19</span>     secp256k1_fe_mul(&amp;x3, &amp;<span style="color: rgba(0, 0, 0, 1)">x3, a);
</span><span style="color: rgba(0, 128, 128, 1)">20</span> 
<span style="color: rgba(0, 128, 128, 1)">21</span>     x6 =<span style="color: rgba(0, 0, 0, 1)"> x3;
</span><span style="color: rgba(0, 128, 128, 1)">22</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">23</span>         secp256k1_fe_sqr(&amp;x6, &amp;<span style="color: rgba(0, 0, 0, 1)">x6);
</span><span style="color: rgba(0, 128, 128, 1)">24</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">25</span>     secp256k1_fe_mul(&amp;x6, &amp;x6, &amp;<span style="color: rgba(0, 0, 0, 1)">x3);
</span><span style="color: rgba(0, 128, 128, 1)">26</span> 
<span style="color: rgba(0, 128, 128, 1)">27</span>     x9 =<span style="color: rgba(0, 0, 0, 1)"> x6;
</span><span style="color: rgba(0, 128, 128, 1)">28</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">29</span>         secp256k1_fe_sqr(&amp;x9, &amp;<span style="color: rgba(0, 0, 0, 1)">x9);
</span><span style="color: rgba(0, 128, 128, 1)">30</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">31</span>     secp256k1_fe_mul(&amp;x9, &amp;x9, &amp;<span style="color: rgba(0, 0, 0, 1)">x3);
</span><span style="color: rgba(0, 128, 128, 1)">32</span> 
<span style="color: rgba(0, 128, 128, 1)">33</span>     x11 =<span style="color: rgba(0, 0, 0, 1)"> x9;
</span><span style="color: rgba(0, 128, 128, 1)">34</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;2; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">35</span>         secp256k1_fe_sqr(&amp;x11, &amp;<span style="color: rgba(0, 0, 0, 1)">x11);
</span><span style="color: rgba(0, 128, 128, 1)">36</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">37</span>     secp256k1_fe_mul(&amp;x11, &amp;x11, &amp;<span style="color: rgba(0, 0, 0, 1)">x2);
</span><span style="color: rgba(0, 128, 128, 1)">38</span> 
<span style="color: rgba(0, 128, 128, 1)">39</span>     x22 =<span style="color: rgba(0, 0, 0, 1)"> x11;
</span><span style="color: rgba(0, 128, 128, 1)">40</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;11; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">41</span>         secp256k1_fe_sqr(&amp;x22, &amp;<span style="color: rgba(0, 0, 0, 1)">x22);
</span><span style="color: rgba(0, 128, 128, 1)">42</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">43</span>     secp256k1_fe_mul(&amp;x22, &amp;x22, &amp;<span style="color: rgba(0, 0, 0, 1)">x11);
</span><span style="color: rgba(0, 128, 128, 1)">44</span> 
<span style="color: rgba(0, 128, 128, 1)">45</span>     x44 =<span style="color: rgba(0, 0, 0, 1)"> x22;
</span><span style="color: rgba(0, 128, 128, 1)">46</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;22; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">47</span>         secp256k1_fe_sqr(&amp;x44, &amp;<span style="color: rgba(0, 0, 0, 1)">x44);
</span><span style="color: rgba(0, 128, 128, 1)">48</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">49</span>     secp256k1_fe_mul(&amp;x44, &amp;x44, &amp;<span style="color: rgba(0, 0, 0, 1)">x22);
</span><span style="color: rgba(0, 128, 128, 1)">50</span> 
<span style="color: rgba(0, 128, 128, 1)">51</span>     x88 =<span style="color: rgba(0, 0, 0, 1)"> x44;
</span><span style="color: rgba(0, 128, 128, 1)">52</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;44; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">53</span>         secp256k1_fe_sqr(&amp;x88, &amp;<span style="color: rgba(0, 0, 0, 1)">x88);
</span><span style="color: rgba(0, 128, 128, 1)">54</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">55</span>     secp256k1_fe_mul(&amp;x88, &amp;x88, &amp;<span style="color: rgba(0, 0, 0, 1)">x44);
</span><span style="color: rgba(0, 128, 128, 1)">56</span> 
<span style="color: rgba(0, 128, 128, 1)">57</span>     x176 =<span style="color: rgba(0, 0, 0, 1)"> x88;
</span><span style="color: rgba(0, 128, 128, 1)">58</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;88; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">59</span>         secp256k1_fe_sqr(&amp;x176, &amp;<span style="color: rgba(0, 0, 0, 1)">x176);
</span><span style="color: rgba(0, 128, 128, 1)">60</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">61</span>     secp256k1_fe_mul(&amp;x176, &amp;x176, &amp;<span style="color: rgba(0, 0, 0, 1)">x88);
</span><span style="color: rgba(0, 128, 128, 1)">62</span> 
<span style="color: rgba(0, 128, 128, 1)">63</span>     x220 =<span style="color: rgba(0, 0, 0, 1)"> x176;
</span><span style="color: rgba(0, 128, 128, 1)">64</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;44; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">65</span>         secp256k1_fe_sqr(&amp;x220, &amp;<span style="color: rgba(0, 0, 0, 1)">x220);
</span><span style="color: rgba(0, 128, 128, 1)">66</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">67</span>     secp256k1_fe_mul(&amp;x220, &amp;x220, &amp;<span style="color: rgba(0, 0, 0, 1)">x44);
</span><span style="color: rgba(0, 128, 128, 1)">68</span> 
<span style="color: rgba(0, 128, 128, 1)">69</span>     x223 =<span style="color: rgba(0, 0, 0, 1)"> x220;
</span><span style="color: rgba(0, 128, 128, 1)">70</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">71</span>         secp256k1_fe_sqr(&amp;x223, &amp;<span style="color: rgba(0, 0, 0, 1)">x223);
</span><span style="color: rgba(0, 128, 128, 1)">72</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">73</span>     secp256k1_fe_mul(&amp;x223, &amp;x223, &amp;<span style="color: rgba(0, 0, 0, 1)">x3);
</span><span style="color: rgba(0, 128, 128, 1)">74</span> 
<span style="color: rgba(0, 128, 128, 1)">75</span>     /* The final result <span style="color: rgba(0, 0, 255, 1)">is</span> then assembled using a sliding window over the blocks. */
<span style="color: rgba(0, 128, 128, 1)">76</span>     t1 =<span style="color: rgba(0, 0, 0, 1)"> x223;
</span><span style="color: rgba(0, 128, 128, 1)">77</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;23; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">78</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)">79</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">80</span>     secp256k1_fe_mul(&amp;t1, &amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">x22);
</span><span style="color: rgba(0, 128, 128, 1)">81</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;5; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">82</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)">83</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">84</span>     secp256k1_fe_mul(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1, a);
</span><span style="color: rgba(0, 128, 128, 1)">85</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;3; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">86</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)">87</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">88</span>     secp256k1_fe_mul(&amp;t1, &amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">x2);
</span><span style="color: rgba(0, 128, 128, 1)">89</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (j=0; j&lt;2; j++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">90</span>         secp256k1_fe_sqr(&amp;t1, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)">91</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">92</span>     secp256k1_fe_mul(r, a, &amp;<span style="color: rgba(0, 0, 0, 1)">t1);
</span><span style="color: rgba(0, 128, 128, 1)">93</span> }</pre>
</div>
<span class="cnblogs_code_collapse">secp256k1_fe_inv</span></div>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-30 17:53">2025-06-30 17:52</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18945891);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18945891', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18945891/secp256k1_2', title: 'secp256k1算法详解二（关键理论及源码分析）' })">举报</a>
</div>
        