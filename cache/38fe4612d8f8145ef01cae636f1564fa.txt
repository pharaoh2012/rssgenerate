
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Colin-Cai/p/10629908.html" title="发布于 2025-01-14 12:44">
    <span role="heading" aria-level="2">排列和组合的实现</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        每当学一门计算机语言，质数表、汉诺塔可以作为早期测试的话题之一。随着深入，都很想快速提高一下对这个语言的把握。这个时候，我觉得排列、组合是合适的。不仅排列、组合的程序相对复杂一些，而且在很多问题的解决上，排列、组合往往是解决中的一部分。以下我们的讨论都是针对有限集。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="cnblogs_Highlighter">
<pre class="brush:sql;gutter:true;">　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　 http://www.cnblogs.com/Colin-Cai/p/10629908.html

　　作者：窗户

　　QQ/微信：6679072

　　E-mail：6679072@qq.com</pre>
</div>
<p>　　每当学一门计算机语言，质数表、汉诺塔可以作为早期测试的话题之一。随着深入，都很想快速提高一下对这个语言的把握。这个时候，我觉得排列、组合是合适的。不仅排列、组合的程序相对复杂一些，而且在很多问题的解决上，排列、组合往往是解决中的一部分。以下我们的讨论都是针对有限集。</p>
<p>&nbsp;</p>
<p>　　<strong><span style="color: rgba(136, 136, 136, 1); font-size: 18pt">排列</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;排列，我们这里可以记为$p(s, n)$，代表从一个有限集$s$中选择$n$个元素组成的序列，所有的这样的序列组成的集合。注意，序列在于其有序性，$[1,2,3]$和$[1,3,2]$就是不同的序列。例如，$p({1,2,3}, 2)$所代表的集合是${[1,2], [2,1], [1,3], [3,1], [2,3],[3,2]}$。</p>
<p>&nbsp;</p>
<p>　　<strong><span style="color: rgba(136, 136, 136, 1); font-size: 18pt">组合</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;组合，我们这里可以记为$c(s, n)$，代表从一个有限集$s$中选择$n$个元素组成的集合，所有的这样的集合组成的集合。例如，$c({1,2,3}, 2)$所代表的集合是${{1,2},&nbsp;{1, 3}, {2,3}}$。</p>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18pt"><strong><span style="color: rgba(136, 136, 136, 1)">递归完成排列</span></strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;排列的递归完成理论上可以有无限多种递归方式。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;比如我们可以考虑这样的方式来递归：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当$n = 0$时，$p(s,n) = \{\emptyset\}$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当$n \ne 0$时，$p(s,n) = \bigcup_{x\in s}{\{&lt;x,y&gt;|y\in p(s-{x},n-1)\}}&nbsp;$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;也就是，当$n \ne 0$时$p(s,n)$分为以$s$各个元素为首元素的序列集合的并集，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;于是用Haskell直接可以如下写</p>
<div class="cnblogs_code">
<pre>perm::[a] -&gt; Int -&gt;<span style="color: rgba(0, 0, 0, 1)"> [[a]]<br>--表示并集
bigcup </span>= foldl (++<span style="color: rgba(0, 0, 0, 1)">) []
perm _ </span>0 =<span style="color: rgba(0, 0, 0, 1)"> [[]]
perm s n </span>= bigcup [[(s!!index:e)|e&lt;-perm [s!!k|k&lt;-[0..length s - 1], k/=index] (n - 1)] | index&lt;-[0..length s - 1]]</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;用Scheme描述可以如下</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">(define (perm s n)
  (define (put</span>-each-to-<span style="color: rgba(0, 0, 0, 1)">head s)
    (let it ((left s)
             (right </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">())</span>
             (r <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">()))</span>
      (<span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (null? left)
          r
          (it
            (cdr left)
            (cons (car left) right)
            (cons (append left right) r)))))
  (</span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (zero? n)
      </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">(())</span>
<span style="color: rgba(0, 0, 0, 1)">      (apply append
             (map
               (</span><span style="color: rgba(0, 0, 255, 1)">lambda</span><span style="color: rgba(0, 0, 0, 1)"> (s2)
                 (map
                   (</span><span style="color: rgba(0, 0, 255, 1)">lambda</span><span style="color: rgba(0, 0, 0, 1)"> (n) (cons (car s2) n))
                   (perm (cdr s2) (</span>- n 1<span style="color: rgba(0, 0, 0, 1)">))))
               (put</span>-each-to-head s)))))</pre>
</div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18pt"><strong><span style="color: rgba(136, 136, 136, 1)">组合的递归</span></strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;组合的递归完成理论上也一样可以有无限多种递归方式。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;假如我们考虑以下的递归方式:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当$n = 0$时，$c(s,n)=\{\emptyset\}$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当$n \ne 0&nbsp;\land s = \emptyset$时，$c(s,n)=\emptyset$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其他时候，任意取一个$a\in s$，有$c(s,n)=c(s-\{a\},n)\cup \{x\cup\{a\}|x\in c(s-\{a\},n-1)\}$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;用Haskell写作</p>
<div class="cnblogs_code">
<pre>comb::[a] -&gt; Int -&gt;<span style="color: rgba(0, 0, 0, 1)"> [[a]]
comb _ </span>0 =<span style="color: rgba(0, 0, 0, 1)"> [[]]
comb [] _ </span>=<span style="color: rgba(0, 0, 0, 1)"> []
comb s n </span>= comb (tail s) n ++ [(head s:x)|x&lt;-comb (tail s) (n - 1)]</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;用Scheme可以写作</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">(define (comb s n)
  (cond
    ((zero? n)
      </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">(()))</span>
<span style="color: rgba(0, 0, 0, 1)">    ((null? s)
     </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">())</span>
    (<span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
      (append
        (map (</span><span style="color: rgba(0, 0, 255, 1)">lambda</span> (x) (cons (car s) x)) (comb (cdr s) (- n 1<span style="color: rgba(0, 0, 0, 1)">)))
        (comb (cdr s) n)))))</span></pre>
</div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18pt"><strong><span style="color: rgba(136, 136, 136, 1)">排列的字典顺序</span></strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;字典顺序输出，依次输出的各序列，其每个元素在原来集合(我们用list表示)中的位置(list中的序号)所构成的序列满足字典顺序。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;比如$[1,2,3,4]$,取2个元素构成的排序按字典顺序为$[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$c(s,n)$第一个序列肯定是序号序列$[0,1...n]$依次所对应的元素组成的序列，问题的关键就在于如何根据当前序列找到下一个序列。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;其实只需要按照从右向左，一个接一个找有没有可以升高的可能，只要有可能，就找到了下一个序列。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;比如我们要从$[a,b,c,d]$中找3个元素的排列：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;最开始，序号序列是$[0,1,2]$，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;要找下一个序号序列时，我们从右往左找，发现最后一个2改成3就可以实现最小的字典顺序跨越，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;所以接下来的序号序列是$[0,1,3]$，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;再从右往左找时,我们发现3时找不到更大的替代了，于是轮到$[0,1]$找，1可以替代为2，得到$[0,2]$，然后最靠前的补全3个的序列，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;得到接下来的序号序列是$[0,2,1]$，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;......</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;字典输出，Scheme可以引入lambda进行惰性计算，R5RS中有delay和force，当然它们可以都是利用lambda进行惰性计算的宏，这样的好处还是不需要生成。而Haskell自身就是惰性的，以下为Haskell的实现，因为计算next用反序比较方便，所以其中next'是反序的，最后生成真实排列的序列才把序列反过来。</p>
<div class="cnblogs_code">
<pre>perm::[a] -&gt; Int -&gt;<span style="color: rgba(0, 0, 0, 1)"> [[a]]
perm _ 0 </span>=<span style="color: rgba(0, 0, 0, 1)"> [[]]
perm s n </span>= map (\x -&gt; map (s!!) (reverse x)) (dict_seq_rev (length s - 1<span style="color: rgba(0, 0, 0, 1)">) n)
  where
   dict_seq_rev max_index n </span>=<span style="color: rgba(0, 0, 0, 1)">
     s : remains s
       where
         s </span>= reverse [0..n-1<span style="color: rgba(0, 0, 0, 1)">]
         next</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> s = if null s</span>
<span style="color: rgba(0, 0, 0, 1)">                   then []
                   </span><span style="color: rgba(0, 0, 255, 1)">else</span>
                     <span style="color: rgba(0, 0, 255, 1)">if</span> null s<span style="color: rgba(128, 0, 0, 1)">'
</span><span style="color: rgba(0, 0, 0, 1)">                     then
                       let s</span><span style="color: rgba(128, 0, 0, 1)">''</span> = next<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> (tail s) in</span>
                        <span style="color: rgba(0, 0, 255, 1)">if</span> null s<span style="color: rgba(128, 0, 0, 1)">''</span><span style="color: rgba(0, 0, 0, 1)">
                        then []
                        </span><span style="color: rgba(0, 0, 255, 1)">else</span> head [x|x&lt;-[0..max_index], <span style="color: rgba(0, 0, 255, 1)">not</span> (elem x s<span style="color: rgba(128, 0, 0, 1)">''</span>)] : s<span style="color: rgba(128, 0, 0, 1)">''</span>
                     <span style="color: rgba(0, 0, 255, 1)">else</span> head s<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> : tail s</span>
                        where s<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> = [x|x&lt;-[0..max_index],x&gt;head s,not (elem x s)]</span>
         remains s = (\x -&gt; <span style="color: rgba(0, 0, 255, 1)">if</span> null x then [] <span style="color: rgba(0, 0, 255, 1)">else</span> x : remains x) (next<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> s)</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 最终用小写字母的全排列来演示一下</p>
<div class="cnblogs_code">
<pre>main = <span style="color: rgba(0, 0, 255, 1)">print</span> $perm [<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">a</span><span style="color: rgba(128, 0, 0, 1)">'</span>..<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">z</span><span style="color: rgba(128, 0, 0, 1)">'</span>] 26</pre>
</div>
<p>　　 编译之后可运行，说明了Haskell的惰性计算，否则26个元素的全排列是不可能装的下去，更不可能瞬间计算出来。</p>
<p>&nbsp;　　Scheme或者其他语言的字典顺序排列可以读者自己实现。</p>
<p>&nbsp;</p>
<p>　　<span style="color: rgba(136, 136, 136, 1)"><strong><span style="font-size: 18pt">组合的字典顺序</span></strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;组合的字典顺序依旧问题在如何设计这个next函数。每个下标集合按升序的序列来表示。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;那么也是从右往左来找下一个元素，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;比如$[0..8]$选择4个来组合</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;最开始，序号序列是$[0,1,2,3]$，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; ....(过程中省略)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;再来找$[2,4,7,8]$的下一个</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;最右边的8无法找到下一个，倒数第二个的7也无法找到下一个，倒数第三个的4找到下一个为5，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;最后两个再依次加1补全，得到结果为$[2,5,6,7]$。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;还是用Haskell来表示，其他地方都可一致，唯独next'的实现有一点区别：</p>
<div class="cnblogs_code">
<pre>comb::[a] -&gt; Int -&gt;<span style="color: rgba(0, 0, 0, 1)"> [[a]]
comb _ 0 </span>=<span style="color: rgba(0, 0, 0, 1)"> [[]]
comb [] _ </span>=<span style="color: rgba(0, 0, 0, 1)"> []
comb s n </span>= map (\x -&gt; map (s!!) (reverse x)) (dict_seq_rev (length s - 1<span style="color: rgba(0, 0, 0, 1)">) n)
  where
   dict_seq_rev max_index n </span>=<span style="color: rgba(0, 0, 0, 1)">
     s : remains s
       where
         s </span>= reverse [0..n-1<span style="color: rgba(0, 0, 0, 1)">]
         next</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> s = if null s</span>
<span style="color: rgba(0, 0, 0, 1)">                   then []
                   </span><span style="color: rgba(0, 0, 255, 1)">else</span>
                     <span style="color: rgba(0, 0, 255, 1)">if</span> head s &lt; max_index - n +<span style="color: rgba(0, 0, 0, 1)"> length s
                     then head s </span>+ 1<span style="color: rgba(0, 0, 0, 1)"> : tail s
                     </span><span style="color: rgba(0, 0, 255, 1)">else</span> let s<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> = next</span><span style="color: rgba(128, 0, 0, 1)">'</span> (tail s) <span style="color: rgba(0, 0, 255, 1)">in</span>
                            <span style="color: rgba(0, 0, 255, 1)">if</span> null s<span style="color: rgba(128, 0, 0, 1)">'
</span><span style="color: rgba(0, 0, 0, 1)">                            then []
                            </span><span style="color: rgba(0, 0, 255, 1)">else</span> head s<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> + 1 : s</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">
         remains s </span>= (\x -&gt; <span style="color: rgba(0, 0, 255, 1)">if</span> null x then [] <span style="color: rgba(0, 0, 255, 1)">else</span> x : remains x) (next<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)"> s)</span></pre>
</div>
<p>　　Scheme或者其他语言的字典顺序排列可以读者自己实现。</p>
<p>&nbsp;</p>
<p>　　<span style="color: rgba(136, 136, 136, 1); font-size: 18pt"><strong>排列组合的应用</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Python属于很常用的语言，用来做胶水再好不过，从而发展很迅猛，现在被当作是一种很“通俗”的编程语言。我时常会使用里面自带的itertools库。当然，其他语言也可以找到该有的库，没有的话也可以自己来造，以上递归的方式并非唯一，发挥想象可以继续挖掘，但要注意，先生成排列组合的整体再处理很多时候并不现实，因为需要大量的内存，而最终等价于遍历排列组合的每一个结果依次处理价值要大得多。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;有了排列组合，某些题目可以暴力完成。比如这样一个题目，给出平面上一堆点，找出距离最近的2个点。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;一个很自然的想法就是遍历所有的2点组合，然后找出距离最小的情况，Python代码如下:</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> itertools as it
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> math

</span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> find_shortest_distance(points):
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> distance(p1, p2):
        s </span>= (p2[0] - p1[0], p2[1] - p1[1<span style="color: rgba(0, 0, 0, 1)">])
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> math.sqrt(s[0] ** 2 + s[1] ** 2<span style="color: rgba(0, 0, 0, 1)">)
    min_distance </span>=<span style="color: rgba(0, 0, 0, 1)"> None
    min_distance_two_points </span>=<span style="color: rgba(0, 0, 0, 1)"> None
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> two_points <span style="color: rgba(0, 0, 255, 1)">in</span> it.combinations(points, 2<span style="color: rgba(0, 0, 0, 1)">):
        d </span>= distance(*<span style="color: rgba(0, 0, 0, 1)">two_points)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> min_distance <span style="color: rgba(0, 0, 255, 1)">is</span> None <span style="color: rgba(0, 0, 255, 1)">or</span> min_distance &gt;<span style="color: rgba(0, 0, 0, 1)"> d:
            min_distance </span>=<span style="color: rgba(0, 0, 0, 1)"> d
            min_distance_two_points </span>=<span style="color: rgba(0, 0, 0, 1)"> two_points
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> (min_distance_two_points, min_distance)</pre>
</div>
<p>　　以上就是利用排列、组合做的暴力算法，很多时候这样的暴力算法都是一个选择，它意味着遍历所有可能，往往复杂度较大，所以根据数据规模量力而行。另外，以上寻找最短距离的一对点存在$O(n\log (n))$时间的算法，不过不在本篇讨论范围之内。</p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.19941577868287036" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 21:32">2025-01-14 12:44</span>&nbsp;
<a href="https://www.cnblogs.com/Colin-Cai">窗户</a>&nbsp;
阅读(<span id="post_view_count">251</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=10629908" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(10629908);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '10629908', targetLink: 'https://www.cnblogs.com/Colin-Cai/p/10629908.html', title: '排列和组合的实现' })">举报</a>
</div>
