
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18772784" title="发布于 2025-03-14 20:33">
    <span role="heading" aria-level="2">【杂谈】分布式事务——高大上的无用知识？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div>
<h3>如何保证多个数据库操作的原子性？</h3>
</div>
<div>很简单，用事务。具体到代码，在方法上加一个@Transactional，这样方法内部的entity操作都能在一个数据事务内。</div>
<div>abc三个entity，要么全部修改，要么一个不改。</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Transactional
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> someOperation() {
        aRepo.save(a);
        bRepo.save(b);
        cRepo.save(c);
}</span></pre>
</div>
<h3><strong>那如果有个entity的修改是在另外一个服务上呢？</strong></h3>
<p>假设 <code data-start="494" data-end="497">b</code> 这个数据属于另一个微服务，我们通过 <strong data-start="516" data-end="531">FeignClient</strong> 远程调用它：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Transactional
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> someOperation() {
        aRepo.save(a);
        bFeignClient.save(b);
        cRepo.save(c);
}</span></pre>
</div>
<p>那么@Transactional就只能保证a，c两个修改的原子性，b的修改不受控制。</p>
<h3>分布式事务的解决方案</h3>
<p>分布式事务通常使用两阶段提交（2PC, Two-Pahse Commit）进行处理。</p>
</div>
<div>1.第一阶段（Prepare，准备阶段）</div>
<ul>
<li>
<div>事务协调器（TC，Transaction Coordinator）通知所有参与者（分支事务）执行事务操作，但不提交</div>
</li>
<li>
<div>每个参与者执行本地事务并记录undo log（或锁定资源），然后向TC报告准备成功或失败</div>
<ul>
<li>使用行级锁（SELECT ... FOR UPDATE）锁定一行数据，无法被其他线程修改。</li>
</ul>
</li>
</ul>
<div>2.第二阶段（Commit/Rollback，提交或回滚阶段）</div>
<ul>
<li>
<div>如果所有参与者都准备成功，TC通知所有分支事务提交</div>
</li>
<li>
<div>如果有任何一个失败，TC通知所有分支事务回滚。</div>
</li>
</ul>
<p>就代码来讲，假设不使用XA命令。<br>一个分支事务会依次执行这5句SQL，一般执行完④成功后，就停住了，不再发新SQL给数据库。<br>分支事务会等待协调器TC的命令，如果可以执行，就继续执行COMMIT，否则就执行ROLLBACK。</p>
<div class="cnblogs_code">
<p>-- 1. 开启事务<br>START TRANSACTION;</p>
<p>-- 2. 先锁定目标数据，确保后续不会有其他事务并发修改<br>SELECT * FROM table_b WHERE id = '12345' FOR UPDATE;</p>
<p>-- 3. 记录旧数据到 `undo_log`<br>INSERT INTO undo_log (table_name, record_id, old_value)<br>SELECT 'table_b', id, name FROM table_b WHERE id = '12345';</p>
<p>-- 4. 执行更新操作<br>UPDATE table_b SET name='www' WHERE id= '12345';</p>
<p>-- 5. 等待 TC 指令：<br>-- ✅ 如果 TC 说“可以提交”，则执行：<br>COMMIT;</p>
<p>-- ❌ 如果 TC 说“回滚”，则执行：<br>ROLLBACK;</p>

</div>
<p>如果分支事务COMMIT后，其他分支事务失败，则可以通过undo_log表来回滚数据。</p>
<h3><strong>分布式事务框架——Seata</strong></h3>
<div>高性能的AT模式</div>
<div>
<ul>
<li>在第一阶段，Seata直接修改数据库（和2PC不同，它不会锁定资源）
<ul>
<li>Seata会拦截SQL并记录undo log（修改前的数据），用于回滚</li>

</ul>

</li>
<li>在第二阶段：
<ul>
<li>提交时：直接提交，无额外操作</li>
<li>回滚时：用undo log恢复数据</li>

</ul>

</li>

</ul>

</div>
<div>相比于传统的2PC，它避免了长时间锁定资源，提高了性能。</div>
<div>案例代码：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@GlobalTransactional
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> someOperation() {
        aRepo.save(a);
        bFeignClient.save(b);
        cRepo.save(c);
}</span></pre>
</div>
</div>
<h3>有了Seata这种高性能框架，分布式事务为何还是不常见？</h3>
<div>
<p data-start="70" data-end="102"><strong>1. 业务通常不需要强一致性，仅需最终一致性</strong></p>
<p data-start="103" data-end="157">大多数业务场景对数据的一致性要求没有那么严格，<strong data-start="126" data-end="146">只要能在一段时间内完成最终一致性</strong>，就足够了。</p>
<p data-start="122" data-end="148">案例：用户余额充值与优惠券发放</p>
<p data-start="149" data-end="206">假设你在一个电商平台充值 100 元，并且平台规定：<strong data-start="175" data-end="203">首次充值 100 元以上，会赠送 10 元优惠券</strong>。</p>
<p data-start="149" data-end="206">假设充值和优惠卷发放是在两个独立的服务上，完全可以在充值完成后，写入MQ，然后优惠卷服务再处理消息。</p>
<p data-start="149" data-end="206">只要最终结果一致就行。</p>
<p data-start="103" data-end="157"><strong>2. 事务本地化</strong></p>
<p data-start="103" data-end="157">拆分微服务时，事务操作通常划归到一个服务内，不会跨服务。</p>
<p data-start="103" data-end="157">比如一个系统，它的支付相关的操作，都在一个支付服务内。</p>
<p data-start="129" data-end="152"><strong data-start="129" data-end="150">3.Seata 仍然存在额外开销</strong></p>
<p data-start="154" data-end="203">比如额外的SQL解析；undo log表的维护，额外的数据库写入；额外的网络通信。</p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2414902019201389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-14 20:33">2025-03-14 20:33</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18772784" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18772784);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18772784', targetLink: 'https://www.cnblogs.com/longfurcat/p/18772784', title: '【杂谈】分布式事务——高大上的无用知识？' })">举报</a>
</div>
        