
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kewei/p/18630545" title="发布于 2024-12-25 15:30">
    <span role="heading" aria-level="2">在Asp.netCore中使用Attribute来描述限流</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="前言">前言</h3>
<p>同事问我Asp.netCore的RateLimiting是怎么使用的，我回答说很简单的，你只要按照如下步骤来：</p>
<ol>
<li>在RateLimiterOptions上注册policy，记住policy对应的policyName</li>
<li>在Web应用添加UseRateLimiter()中间件</li>
<li>在api对应的Action上标注[EnableRateLimiting(policyName)]</li>
</ol>
<p>半小时后，同事说要对我告知他的RateLimiter功能差评，因为他得写几十种policy工作量很大，就连policyName的取名都让他头大。</p>
<h3 id="让ratelimiting更简单">让RateLimiting更简单</h3>
<p>我在基于Yarp的网关上做过RateLimiting，将每个服务的所有Endpoint描述导出放到网关做网关的子级路由，然后基于Endpoint做可配置化的限流，代码实现上很复杂但使用灵活度非常可观。<br>
但今天我们的问题范围是在单体WebApplication中，如何减少我同事的限流工作量。</p>
<h4 id="限流器attribute化">限流器Attribute化</h4>
<p>假如我们造了如下的Attribute：</p>
<ul>
<li>[RateLimiter.Concurrency(permitLimit: 10)]</li>
<li>[RateLimiter.FixedWindow(permitLimit: 10, windowSeconds: 60)]</li>
<li>[RateLimiter.SlidingWindow(permitLimit: 10, windowSeconds: 60, segmentsPerWindow: 5)]</li>
</ul>
<p>让我的同事在Action上标记其中一个Attribute，他的开发时间短、代码可读性高，免去了他手写policy实现的巨量代码。</p>
<h4 id="限流单元来源attribute化">限流单元来源Attribute化</h4>
<p>同事说他的众多接口中，需要整体限流的很少，几乎都是需要颗粒度更细的限流：</p>
<ol>
<li>登录接口，需要对请求体的json对象的userName值做限流单元</li>
<li>找回密码接口，需要对请求路由里的userName值做限流单元</li>
<li>其它已经做了用户身份认证的接口，需要用userId值做限流单元</li>
<li>xx特殊接口，需要用请求者IP值做限流单元</li>
<li>yy接口需要从Form中取出yy值做限流单元</li>
<li>zz接口需要从Header中取出zz值做限流单元</li>
<li>想自定义从HttpContext里获取限流单元</li>
</ol>
<p>于是我们又造了一些Attribute，来处理上面的需求</p>
<ol>
<li>[RateLimiterUnit.FromBody(unitName: "$.userName")]</li>
<li>[RateLimiterUnit.FromRoute(unitName: "userName")]</li>
<li>[RateLimiterUnit.FromUser(unitName: ClaimTypes.NameIdentifier)]</li>
<li>[RateLimiterUnit.FromRemoteIPAddress]</li>
<li>[RateLimiterUnit.FromForm(unitName: "yy")]</li>
<li>[RateLimiterUnit.FromHeader(unitName: "zz")]</li>
</ol>
<p>再提供一个IRateLimiterUnitMetadata接口，让他实现自定义逻辑</p>
<pre><code class="language-c#">public class YourRateLimiterUnitAttribute : Attribute, IRateLimiterUnitMetadata
{
    public ValueTask&lt;string?&gt; GetUnitAsync(HttpContext context)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<h3 id="让ratelimiting能运行">让RateLimiting能运行</h3>
<p>上面提到的那些Attribute，目前只存在于我们理想中，我们需要把它变成实际。</p>
<p>我们需要实现实现一个policy，在policy里获取当前请求的Endpoint，从Endpoint的metadata里提取出我们上面定义的Attribute，根据Attribute的描述生成RateLimitPartition。</p>
<p>把这个唯一的policy注册到RatelimiterOptions中，再把它的policyName使用EnableRateLimitingAttribute添加到Endpoint的metadata中。</p>
<p>最后，使用标准的Asp.netCore的UseRateLimiter()中间件，就能把我们的限流器运行起来了。</p>
<h3 id="最后">最后</h3>
<p><a href="https://github.com/xljiulang/RateLimiting.DataAnnotations" target="_blank" rel="noopener nofollow">此项目是开源</a>的，不管你在工作中有没有用到，但里面有意思的想法你可以来一起品。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.033093994787037034" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 15:31">2024-12-25 15:30</span>&nbsp;
<a href="https://www.cnblogs.com/kewei">jiulang</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18630545" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18630545);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18630545', targetLink: 'https://www.cnblogs.com/kewei/p/18630545', title: '在Asp.netCore中使用Attribute来描述限流' })">举报</a>
</div>
        