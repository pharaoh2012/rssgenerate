
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18691766" title="发布于 2025-01-26 14:22">
    <span role="heading" aria-level="2">Rust多线程中安全的使用变量</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在Rust语言中，一个既引人入胜又可能带来挑战的特性是<strong>闭包</strong>如何从其所在环境中捕获变量，尤其是在涉及<strong>多线程</strong>编程的情境下。</p>
<p>如果尝试在不使用<code>move</code>关键字的情况下创建新线程并传递数据至闭包内，编译器将很可能返回一系列与<strong>生命周期</strong>、<strong>借用规则</strong>及<strong>所有权</strong>相关的复杂错误信息。</p>
<p>不过，这种机制虽然增加了学习曲线，但也确保了内存安全与并发执行中的数据一致性。</p>
<p>本文我们将探讨如何在线程的闭包中安全的使用变量，包括共享变量和修改变量。</p>
<h1 id="1-向线程传递变量">1. 向线程传递变量</h1>
<p>首先，我们构造一个简单的示例，在线程中正常使用一个外部的变量，看看Rust中能否正常编译运行。</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let msg = String::from("Hello World!");

    let handle = thread::spawn(|| {
        // msg 是主线中定义的变量
        println!("{}", msg);
    });

    handle.join().unwrap();
}
</code></pre>
<p>例子非常简单，看着写法也没什么问题，在其他编程语言中类似的写法是没有问题的。</p>
<p>但是，使用<code>cargo run</code>运行时，却有如下的错误：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136743-57104095.png" alt="" loading="lazy"></p>
<p>为什么会有这样的错误？这就是<code>Rust</code>在内存方面更加严谨的原因。</p>
<p>上面<code>Rust</code>的错误信息中也给出了原因，总结起来主要有两点：</p>
<ol>
<li><strong>线程的生命周期</strong>：新创建的线程的生命周期有可能超出主函数 <code>main</code> 的执行范围。当 <code>main</code> 函数终止时，与之相关的局部变量（也就是<code>msg</code>）将超出作用域。</li>
<li><strong>不符合借用规则</strong>：在 <code>Rust</code> 中，引用的生命周期不会超过其所指向数据的生命周期，以避免出现<strong>悬空引用</strong>。如果main提前结束，那么线程中的msg将成为<strong>悬空引用</strong>。</li>
</ol>
<p>修复的方法很简单，使用<code>move</code>关键字，将变量的所有权转移到线程中就可以了。</p>
<pre><code class="language-rust">    let handle = thread::spawn(move || {
        // msg 是主线中定义的变量
        println!("{}", msg);
    });
</code></pre>
<p>这样就可以正常运行了。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136710-1468240084.png" alt="" loading="lazy"></p>
<p>不过，这样，主线程中就无法使用变量<code>msg</code>了，比如在<code>main</code>函数的最后打印<code>msg</code>，会报错，因为它的所有权已经转移到线程中了。</p>
<h1 id="2-多线程共享变量引用">2. 多线程共享变量引用</h1>
<p>如果我们只把<strong>变量的引用</strong>转移给线程，是不是可以在主线程<code>main</code>中继续使用变量<code>msg</code>呢？</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let msg = String::from("Hello World!");
    let msg_ref = &amp;msg;

    let handle = {

        thread::spawn(move || {
            // msg 是主线中定义的变量
            println!("{}", msg_ref);
        })
    };

    handle.join().unwrap();

    println!("msg in main : {}", msg_ref);
}
</code></pre>
<p>很遗憾，依然有错误：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136742-65722617.png" alt="" loading="lazy"></p>
<p>错误的原因仍然是传入线程中的变量引用<code>msg_ref</code>生命周期的不够长。</p>
<p>虽然我们使用了<code>move</code>，将<code>msg_ref</code>转移到线程中，但<code>main</code>中仍然拥有底层的数据<code>msg</code>，</p>
<p>一旦<code>main</code>函数结束（或者数据在线程完成之前超出范围），该引用（msg_ref）指向数据将失去有效的内存，成为<strong>悬空引用</strong>。</p>
<p>总的来说就是：</p>
<ol>
<li><strong>移动引用</strong>并不移动原始数据-只转移引用本身的所有权</li>
<li>实际数据（<code>msg</code>）仍然由原始范围拥有，并具有自己的生命周期约束</li>
</ol>
<p>为了修复这个错误，就要用到<code>Rust</code>中提供的并发原语<code>Arc</code>（一种自动引用计数的智能指针）。</p>
<p>先看看使用<code>Arc</code>修改后的例子。</p>
<pre><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    let msg = String::from("Hello World!");
    // 通过Arc来创建变量的引用
    let msg_ref = Arc::new(msg);

    // 线程1
    let handle_1 = {
        // move 之前，先使用Arc clone 变量
        let msg_thread = Arc::clone(&amp;msg_ref);

        thread::spawn(move || {
            println!("Thread 1: {}", msg_thread);
        })
    };

    // 线程2
    let handle_2 = {
        let msg_thread = Arc::clone(&amp;msg_ref);

        thread::spawn(move || {
            println!("Thread 2: {}", msg_thread);
        }) 
    };

    handle_1.join().unwrap();
    handle_2.join().unwrap();

    // 主线程中依然可以使用变量
    println!("msg in main : {}", msg_ref);
}
</code></pre>
<p>使用<code>Arc</code>修改之后，变量不仅可以在多个线程中共享，主线程中也可以使用。</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136712-1387787481.png" alt="" loading="lazy"></p>
<h1 id="3-多线程中修改变量">3. 多线程中修改变量</h1>
<p>上面的示例是在多个线程中共享变量，如果想要修改变量的话，那么就会出现数据竞争的情况。</p>
<p>这时，就要用到<code>Rust</code>的另一个并发原语<code>Mutex</code>。</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // 创建一个被Mutex保护的共享数据，这里是一个i32类型的数字
    let shared_number = Arc::new(Mutex::new(0));

    // 定义一个线程向量，用于存储创建的线程
    let mut threads = Vec::new();

    // 创建10个线程，每个线程对共享数据进行1000次递增操作
    for _ in 0..10 {
        // 克隆Arc，使得每个线程都拥有一个指向共享数据的引用
        let num_clone = Arc::clone(&amp;shared_number);
        let handle = thread::spawn(move || {
            // 尝试获取Mutex的锁，这是一个阻塞操作，如果锁不可用，线程会等待
            let mut num = num_clone.lock().unwrap();
            for _ in 0..1000 {
                *num += 1;
            }
        });
        threads.push(handle);
    }

    // 等待所有线程完成操作
    for handle in threads {
        handle.join().unwrap();
    }

    // 获取最终的共享数据值并打印
    let final_num = shared_number.lock().unwrap();
    println!("最终10个线程的累加结果: {}", final_num);
}
</code></pre>
<p>在这个示例中：</p>
<ol>
<li>首先创建了一个<code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>类型的共享数据，<code>Arc</code>用于在多个线程间共享<code>Mutex</code>，<code>Mutex</code>用于保护内部的<code>i32</code>数据。</li>
<li>循环创建<code>10</code>个线程，每个线程都克隆了<code>Arc</code>并尝试获取<code>Mutex</code>的锁。一旦获取到锁，线程就可以安全地对共享数据进行递增操作。</li>
<li>主线程使用<code>join</code>方法等待所有子线程完成操作。</li>
<li>最后，主线程获取并打印共享数据的最终值。由于Mutex的保护，多个线程对共享数据的操作不会产生数据竞争，保证了数据的一致性。</li>
</ol>
<p>运行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136726-338449892.png" alt="" loading="lazy"></p>
<p><code>10</code>个线程，每个累加<code>1000</code>，所以最后结果是<code>1000*10=10000</code>。</p>
<h1 id="4-总结">4. 总结</h1>
<p>从上面的例子可以看出，<code>Rust</code>的闭包捕获规则最初可能感觉很严格，但它们在确保<strong>内存安全</strong>和<strong>数据竞争自由</strong>方面至关重要。</p>
<p>总之，</p>
<p>如果需要在另一个线程中拥有数据，考虑使用<code>move</code>；</p>
<p>如果需要跨线程共享数据，考虑使用<code>Arc</code>；</p>
<p>如果需要跨线程共享和修改数据，考虑使用<code>Arc+Mutex</code>；</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.250840900818287" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 14:22">2025-01-26 14:22</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18691766" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18691766);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18691766', targetLink: 'https://www.cnblogs.com/wang_yb/p/18691766', title: 'Rust多线程中安全的使用变量' })">举报</a>
</div>
        