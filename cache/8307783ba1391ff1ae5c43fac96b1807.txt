
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/danzongd/p/19032497" title="发布于 2025-08-11 18:24">
    <span role="heading" aria-level="2">浅谈C++ const</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引入">引入</h2>
<p>分别考虑以下代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    const int a = 1;
    const_cast&lt;int &amp;&gt;(a) = 42;
    std::printf("%d\n", a);
}
</code></pre>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    const int a = std::rand();
    const_cast&lt;int &amp;&gt;(a) = 42;
    std::printf("%d\n", a);
}
</code></pre>
<p>请问两次代码分别会输出什么？</p>
<p>运行后不难发现，前者会输出42，后者则输出1。事实上，两者逻辑几乎一致：</p>
<ol>
<li>定义一个常量a并初始化</li>
<li>强制修改a的值</li>
<li>输出a</li>
</ol>
<p>那为什么行为上存在差异呢？</p>
<h2 id="汇编分析">汇编分析</h2>
<p>我们通过Compiler Explorer查看二者的汇编代码（省略部分代码），如下：</p>
<pre><code class="language-plain">main:
        ; ...
        lea     rdi, [rip + .L.str] ; 传递printf第一个参数
        mov     esi, 1 ; 传递printf的第二个参数
        xor     eax, eax  ; 将eax寄存器清零，便于printf调用
        call    printf ; 调用printf
        ; 以上代码相当于printf("%d\n", 1);
        ; ...

.L.str:
        .asciz  "%d\n"
</code></pre>
<pre><code class="language-plain">main:
        ; ...
        call    rand ; 调用rand函数
        lea     rdi, [rip + .L.str] ; 传递printf第一个参数
        mov     esi, 42 ; 传递printf的第二个参数
        xor     eax, eax ; 将eax寄存器清零，便于printf调用
        call    printf ; 调用printf
        ; 以上代码相当于printf("%d\n, 42);
        ; ...

.L.str:
        .asciz  "%d\n" ; 定义格式化字符串
</code></pre>
<p>观察到，编译器忽略了a的内存分配，并直接使用Magic Number作为A的值。</p>
<h2 id="符号表替换">符号表替换</h2>
<p>我们先分析代码A。通过查阅资料可知，编译器会进行<strong>符号表替换</strong>优化，具体来说，会将所有<strong>编译期常量</strong>替换为Magic Number，如以下代码：</p>
<pre><code class="language-cpp">const int a = 114514;
int b[a];
</code></pre>
<p>会被优化为</p>
<pre><code class="language-cpp">int b[114514];
</code></pre>
<p>这一优化发生在AST阶段，位于预处理之后，汇编之前。那么回到刚才的代码，</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    const int a = 1;
    const_cast&lt;int &amp;&gt;(a) = 42;
    std::printf("%d\n", a);
}
</code></pre>
<p>显然，按照刚才的逻辑，程序会被优化成这样：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    const int a = 1;
    const_cast&lt;int &amp;&gt;(a) = 42;
    std::printf("%d\n", 1);
}
</code></pre>
<p>那么，此时显然</p>
<pre><code class="language-cpp">const int a = 1;
const_cast&lt;int &amp;&gt;(a) = 42;
</code></pre>
<p>已经没有任何意义，那么编译器会根据<strong>as-if原则（<strong><strong>编译器可以自由地改变程序，只要可观察行为与原始程序一致。</strong></strong>）</strong>，这段代码就会被优化。</p>
<p>最终被优化为：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    std::printf("%d\n", 1);
}
</code></pre>
<h2 id="代码b分析">代码B分析</h2>
<p>接下来考虑代码B。我们知道，符号表替换适用于编译期常量，显然对于代码B不适用。接下来，编译器会考虑将变量a分配至<strong>.rodata段（只读数据段）</strong>。然而很不幸，上述方法不适用于局部变量。因此，编译器只能像普通变量一样处理a，只不过在编译器进行检查。</p>
<p>但是，const_cast会拒绝编译器检查，相当于告诉编译器“我保证这段代码是安全的”。于是，编译器检查通过后，源代码</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    const int a = std::rand();
    const_cast&lt;int &amp;&gt;(a) = 42;
    std::printf("%d\n", a);
}
</code></pre>
<p>会被处理为像这样：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    int a = std::rand();
    a = 42;
    std::printf("%d\n", a);
}
</code></pre>
<p>此时，编译器会进行<strong>数据流分析</strong>最后发现：<br>
唯一一次获取a的值，即printf时，a的值是确定的，为42。因此，编译器会认为a是没有意义的，优化成这样：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    std::rand();
    std::printf("%d\n", 42);
}
</code></pre>
<p>请注意，此处的std::rand是<strong>有副作用的</strong>，也就是说，执行std::rand会改变程序状态。因此，编译器不会删除std::rand的调用，但是会忽略其返回值。</p>
<h2 id="写在最后">写在最后</h2>
<p>永远不要尝试修改一个常量！这在C++中是<strong>未定义行为</strong>，也就是说，这种操作的结果是不确定的，编译器可以对未定义行为进行任何处理。上述分析只是当前主流编译器的普遍优化方法。</p>
<h2 id="参考">参考</h2>
<ol>
<li>ISO/IEC 14882:2024</li>
<li><a href="https://godbolt.org/" target="_blank" rel="noopener nofollow">https://godbolt.org/</a></li>
<li><a href="https://chat.deepseek.com/" target="_blank" rel="noopener nofollow">https://chat.deepseek.com/</a></li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-11 18:24">2025-08-11 18:24</span>&nbsp;
<a href="https://www.cnblogs.com/danzongd">danzongd</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19032497);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19032497', targetLink: 'https://www.cnblogs.com/danzongd/p/19032497', title: '浅谈C++ const' })">举报</a>
</div>
        