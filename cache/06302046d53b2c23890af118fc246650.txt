
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hnzhengfy/p/18711915/Nginx_Practical3" title="发布于 2025-02-13 17:33">
    <span role="heading" aria-level="2">nginx 简单实践：Web 缓存【nginx 实践系列之三】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文为 nginx 简单实践系列文章之一，主要简单实践了两个内容：Web 缓存的简单实现，仅供参考。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>〇、前言</h2>
<p>本文为 nginx 简单实践系列文章之二，主要简单实践了两个内容：正向代理、反向代理，仅供参考。</p>
<p>关于 Nginx 基础，以及安装和配置详解，可以参考博主过往文章：</p>
<p><em><a title="https://www.cnblogs.com/hnzhengfy/p/Nginx.html" href="https://www.cnblogs.com/hnzhengfy/p/Nginx.html" target="_blank" rel="noopener">https://www.cnblogs.com/hnzhengfy/p/Nginx.html</a>&nbsp;</em></p>
<h2>一、强制缓存、协商缓存</h2>
<h3>1.1 强制缓存（强缓存）</h3>
<p><strong>强制缓存指的是当用户请求一个资源时，浏览器直接从本地缓存中读取数据而不向服务器发送任何请求。</strong></p>
<p>这种缓存机制主要依赖于 HTTP 响应头中的 Cache-Control 和 Expires 字段。</p>
<p><strong>Expires：</strong>这是 HTTP/1.0 引入的一个头部字段，它指定了资源在该时间之前被认为是有效的。例如，Expires: Wed, 21 Oct 2025 07:28:00 GMT。但是，<strong>由于 Expires 依赖于客户端的时间设置，可能出现非预期的状况</strong>。</p>
<p><strong>Cache-Control：</strong>HTTP/1.1 引入了更为强大的 Cache-Control 头部，提供了更多控制缓存行为的指令，如下表：</p>
<table style="border-collapse: collapse; width: 73.0091%; height: 168px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 22.4176%; text-align: center; height: 21px"><strong>值</strong></td>
<td style="width: 77.5824%; text-align: center; height: 21px"><strong>含义</strong></td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px"><strong>no-store</strong></td>
<td style="width: 77.5824%; height: 21px"><strong>禁止缓存（强缓存和协商缓存），客户端不存储任何值</strong></td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px"><strong>no-cache</strong></td>
<td style="width: 77.5824%; height: 21px"><strong>禁止强缓存，需要重写验证（可以理解为禁止强缓存，启用协商缓存）</strong></td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px">private</td>
<td style="width: 77.5824%; height: 21px">私有缓存，禁止中间人（比如 CDN 等代理缓存）</td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px">public</td>
<td style="width: 77.5824%; height: 21px">共享缓存，允许中间人缓存</td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px"><strong>max-age</strong></td>
<td style="width: 77.5824%; height: 21px"><strong>资源可以被缓存的最大时间，单位：秒，是一个相对时间，优先级高于 Expires，示例（缓存两分钟）：max-age=120</strong></td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px">s-maxage</td>
<td style="width: 77.5824%; height: 21px">用于共享缓存，单位：秒，如果在其有效期内，不去访问 CDN 等。s-maxage 会覆盖 max-age 和 Expires</td>
</tr>
<tr style="height: 21px">
<td style="width: 22.4176%; height: 21px">must-revalidate</td>
<td style="width: 77.5824%; height: 21px">缓存使用陈旧资源时，必需先验证状态</td>
</tr>
</tbody>
</table>
<p>强缓存的优势：</p>
<ul>
<li><strong>减少网络请求：</strong>浏览器可以直接使用本地缓存中的资源，无需再次向服务器发起请求，从而减少了网络往返次数，提升了页面加载速度。</li>
<li><strong>降低服务器负载：</strong>由于减少了对服务器的请求，服务器的压力也随之减小，有助于提高服务器的整体性能和稳定性。</li>
<li><strong>节省带宽：</strong>避免了重复下载相同的数据，节省了用户的网络带宽，尤其对于移动设备或在带宽有限的情况下尤为重要。</li>
<li><strong>提升用户体验：</strong>加速页面加载时间，尤其是对于静态资源如图片、CSS 和 JavaScript 文件等，能够显著改善用户体验。</li>
</ul>
<p>强缓存的劣势：</p>
<ul>
<li>可能展示过期内容：如果缓存策略设置不当，可能会导致用户看到过期的内容。例如，如果资源更新了但缓存尚未过期，用户将继续看到旧版本的资源，直到缓存失效。</li>
<li>缺乏灵活性：强制缓存的时间是预先设定好的，无法根据实际情况动态调整。这意味着即使服务器上的资源已经更新，只要客户端缓存未过期，用户就看不到最新的内容。</li>
<li>需要精确配置：正确配置缓存策略需要一定的专业知识，尤其是在处理不同类型的资源时（如静态资源与动态生成的内容），错误的配置可能导致缓存命中率低或频繁的缓存失效问题。</li>
<li>难以应对紧急更新：在某些情况下，比如发现安全漏洞或需要立即推送的重要更新，强制缓存可能会成为障碍，因为用户可能长时间看不到最新的修复或更新。</li>
</ul>
<p>在实际应用中，通常会结合使用强制缓存和协商缓存，以达到既快速又可靠的缓存效果。例如，对于不经常变化的静态资源可以使用较长的缓存时间，而对于可能频繁更新的内容则采用较短的缓存时间或者使用协商缓存机制。</p>
<p>&nbsp;</p>
<h3>1.2 协商缓存</h3>
<p>协商缓存（也称为验证缓存）是一种 HTTP 缓存机制，它在强制缓存失效后使用。</p>
<p>在这种情况下，浏览器会携带特定的缓存标识（如 ETag 或 Last-Modified）向服务器发送请求，询问资源是否有更新。如果资源没有变化，服务器将返回一个 304 Not Modified 状态码，指示客户端可以继续使用本地缓存；如果资源有变化，则服务器返回新的资源。</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213172135603-2023334868.png" height="370" width="634"></p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213172155138-2139816938.png" height="370" width="631"></p>
<p>协商缓存主要依赖于 <strong>值标记法（ETag、If-None-Match）</strong>和<strong>比较最后修改时间法（Last-Modified、If-Modified-Since）</strong>两种头部字段来实现。</p>
<p><strong>值标记法（ETag、If-None-Match）：</strong></p>
<ul>
<li>ETag：由服务器生成并返回给客户端的一个唯一标识符，通常基于文件内容的哈希值。每当资源发生变化时，ETag 也会随之改变。</li>
<li>If-None-Match：当客户端再次请求资源时，会在请求头中带上之前获取的 ETag 值。服务器收到请求后，会比较当前资源的 ETag 与请求中的 If-None-Match 值。如果两者相同，说明资源未变，服务器返回 304 Not Modified（未更改，缓存可用）；否则，服务器返回新的资源及其新的 ETag。</li>
</ul>
<p><strong>比较最后修改时间法（Last-Modified、If-Modified-Since）：</strong></p>
<ul style="list-style-type: circle">
<li>Last-Modified：服务器告诉客户端<span style="background-color: rgba(251, 238, 184, 1)"><strong>资源</strong><strong>最后修改的时间</strong></span>。例如，Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT。</li>
<li>If-Modified-Since：客户端在后续请求中会带上这个时间戳。服务器接收到请求后，检查<span style="background-color: rgba(251, 238, 184, 1)"><strong>资源的最后修改时间 Last-Modified </strong></span>是否晚于 If-Modified-Since 指定的时间。如果是，服务器返回新资源；如果不是，服务器返回 304 Not Modified（未更改，缓存可用）。</li>
</ul>
<p>协商缓存的优势：</p>
<ul>
<li><strong>确保数据新鲜度：</strong>通过与服务器进行验证，确保用户始终能够获取到最新的资源，避免了因缓存过期而看不到最新内容的问题。</li>
<li><strong>节省带宽：</strong>如果资源没有变化，服务器只需返回一个小的 304 Not Modified 响应，而不需要重新传输整个资源，从而节省了带宽。</li>
<li><strong>灵活性：</strong>相比强制缓存，协商缓存提供了更高的灵活性，允许根据实际资源的变化情况动态调整缓存策略。</li>
</ul>
<p>协商缓存的劣势：</p>
<ul>
<li><strong>增加网络开销：</strong>即使资源没有变化，每次请求都需要与服务器进行一次验证，这增加了少量的网络开销。</li>
<li><strong>复杂性较高：</strong>需要正确设置和管理 ETag、Last-Modified 等头部字段，增加了配置和维护的复杂性。</li>
<li><strong>性能略逊于强缓存：</strong>虽然节省了带宽，但相比直接从缓存中读取资源，协商缓存仍需要一次网络往返，因此性能稍逊一筹。</li>
</ul>
<p>通过合理地结合使用强制缓存和协商缓存，可以根据不同的需求优化网站的性能和用户体验。</p>
<p><strong>对于不常变化的静态资源，可以优先考虑使用强制缓存；而对于那些需要保持最新状态的资源，则应采用协商缓存。</strong></p>
<h2>二、通过 nginx 配置实现 Web 缓存</h2>
<h3>2.1 强缓存的实现：Cache-Control</h3>
<p><strong>Expires 可能造成误差，因此不再进行示例测试。</strong>由于 Expires 配置是后端返回给客户端的一个时间戳，取自服务器时间，当客户端发送请求时，采用客户端的当前时间进行比较，如果两边时间有误差就会造成数据不一致的异常情况。</p>
<p>Cache-Control 的优先级高于 Expires，Expires 是 http1.0 的产物，而 Cache-Control 是 http1.1 的产物，两者同时存在的时候 Expire 会被 Cache-Control 的 max-age 覆盖，在不支持 http1.1 的情况下可能就需要 Expires 来保持兼容。</p>
<p>nginx 配置示例：</p>
<pre class="language-nginx highlighter-hljs"><code>server {
    listen 8888;
    server_name www.testczzj.com;

    #charset utf-8;
    #charset koi8-r;

    access_log  /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

    location / {
            add_header Cache-Control max-age=500; # 缓存有效期配置为 500 秒
            proxy_pass http://www.testczzj.com:5000;
    }
}</code></pre>
<p>如下图请求结果：（响应头中包含了强缓存配置项 Cache-Control）</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213165222983-750311343.png"></p>
<p>如下图针对文件 bootstrap.min.css 的二次请求详情：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213165332031-1540924460.png"></p>
<p>&nbsp;</p>
<h3>2.2 协商缓存实现：Cache-Control：no-cache</h3>
<p><strong>客户端每次请求都会向服务端发起，若没更新则返回 304，若有更新就正常返回 200。</strong></p>
<p>nginx 配置，其实就是修改了 Cache-Control 这个配置项：</p>
<pre class="language-nginx highlighter-hljs"><code>server {
    listen 8888;
    server_name www.testczzj.com;

    #charset utf-8;
    #charset koi8-r;

    access_log  /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

    location / {
            add_header Cache-Control no-cache; # 配置为协商缓存
            proxy_pass http://www.testczzj.com:5000;
    }
}</code></pre>
<p>如下图，首次加载是从服务器拉取全部数据，待第二次刷新时，在服务端数据未发生变更的情况下，返回 304，效率大大提高：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213155346598-627739553.png"></p>
<p>如下图针对文件 bootstrap.min.css 的二次请求详情：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213151758390-189366140.png"></p>
<p>&nbsp;</p>
<h3>2.3 无缓存：Cache-Control：no-store</h3>
<p>nginx 配置如下：</p>
<pre class="language-nginx highlighter-hljs"><code>server {
    listen 8888;
    server_name www.testczzj.com;

    #charset utf-8;
    #charset koi8-r;

    access_log  /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

    location / {
            add_header Cache-Control no-store; # 配置无缓存
            proxy_pass http://www.testczzj.com:5000;
    }
}</code></pre>
<p>每次请求都是从服务端取数据，如下图：&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202502/1868241-20250213171636005-2076309267.png"></p>
<p><span style="font-size: 12px"><em>参考：<a title="https://blog.csdn.net/JarryNeverGiveup/article/details/131060939" href="https://blog.csdn.net/JarryNeverGiveup/article/details/131060939" target="_blank" rel="noopener nofollow">https://blog.csdn.net/JarryNeverGiveup/article/details/131060939</a></em></span></p>
<p><span style="font-size: 12px"><em><a title="https://segmentfault.com/a/1190000040748678" href="https://segmentfault.com/a/1190000040748678" target="_blank" rel="noopener nofollow">https://segmentfault.com/a/1190000040748678</a></em></span></p>
</div>
<div id="MySignature" role="contentinfo">
    <img src="https://images.cnblogs.com/cnblogs_com/blogs/683398/galleries/2417207/o_221441c4.png">
<p>本文来自博客园，作者：<a href="https://www.cnblogs.com/hnzhengfy/" target="_blank">橙子家</a>，欢迎微信扫码关注博主【橙子家czzj】，有任何疑问欢迎沟通，共同成长！</p>
<div><p style="float: left;">转载本文请注明原文链接：<a href="https://www.cnblogs.com/hnzhengfy/p/18711915/Nginx_Practical3" target="_blank">https://www.cnblogs.com/hnzhengfy/p/18711915/Nginx_Practical3</a></p></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4457721787303241" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 17:33">2025-02-13 17:33</span>&nbsp;
<a href="https://www.cnblogs.com/hnzhengfy">橙子家</a>&nbsp;
阅读(<span id="post_view_count">73</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18711915" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18711915);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18711915', targetLink: 'https://www.cnblogs.com/hnzhengfy/p/18711915/Nginx_Practical3', title: 'nginx 简单实践：Web 缓存【nginx 实践系列之三】' })">举报</a>
</div>
        