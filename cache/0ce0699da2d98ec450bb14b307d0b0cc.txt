
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18955021" title="发布于 2025-06-28 19:52">
    <span role="heading" aria-level="2">3.Java SDK源码分析系列笔记-LinkedList</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-如何使用" rel="noopener nofollow">2. 如何使用</a></li><li><a href="#3-原理分析" rel="noopener nofollow">3. 原理分析</a><ul><li><a href="#31-uml" rel="noopener nofollow">3.1. uml</a></li><li><a href="#32-构造方法" rel="noopener nofollow">3.2. 构造方法</a><ul><li><a href="#321-队列的节点node" rel="noopener nofollow">3.2.1. 队列的节点Node</a></li></ul></li><li><a href="#33-add方法" rel="noopener nofollow">3.3. add方法</a><ul><li><a href="#331-插入到链表尾部" rel="noopener nofollow">3.3.1. 插入到链表尾部</a></li><li><a href="#332-构造新节点prev指向尾节点next为null" rel="noopener nofollow">3.3.2. 构造新节点【prev指向尾节点，next为null】</a></li><li><a href="#333-更新尾节点" rel="noopener nofollow">3.3.3. 更新尾节点</a></li><li><a href="#334-更新size" rel="noopener nofollow">3.3.4. 更新size</a></li></ul></li><li><a href="#34-addlast方法" rel="noopener nofollow">3.4. addLast方法</a></li><li><a href="#35-addfirst方法" rel="noopener nofollow">3.5. addFirst方法</a><ul><li><a href="#351-头部插入节点" rel="noopener nofollow">3.5.1. 头部插入节点</a></li><li><a href="#352-构造新节点prev指向nullnext指向头节点" rel="noopener nofollow">3.5.2. 构造新节点【prev指向null，next指向头节点】</a></li><li><a href="#353-更新头节点" rel="noopener nofollow">3.5.3. 更新头节点</a></li><li><a href="#354-更新size" rel="noopener nofollow">3.5.4. 更新size</a></li></ul></li><li><a href="#36-remove方法根据下标删除" rel="noopener nofollow">3.6. remove方法【根据下标删除】</a><ul><li><a href="#361-遍历找到这个位置的元素" rel="noopener nofollow">3.6.1. 遍历找到这个位置的元素</a></li><li><a href="#362-更新该节点前后节点的指针" rel="noopener nofollow">3.6.2. 更新该节点前后节点的指针</a></li></ul></li><li><a href="#37-remove方法按照元素删除" rel="noopener nofollow">3.7. remove方法【按照元素删除】</a><ul><li><a href="#371-遍历找到这个元素" rel="noopener nofollow">3.7.1. 遍历找到这个元素</a></li><li><a href="#372-更新该节点前后节点的指针" rel="noopener nofollow">3.7.2. 更新该节点前后节点的指针</a></li></ul></li><li><a href="#38-remove方法无参" rel="noopener nofollow">3.8. remove方法【无参】</a><ul><li><a href="#381-删除头部节点" rel="noopener nofollow">3.8.1. 删除头部节点</a></li><li><a href="#382-把原来头节点的next节点更新为头节点" rel="noopener nofollow">3.8.2. 把原来头节点的next节点更新为头节点</a></li></ul></li><li><a href="#39-removelast方法" rel="noopener nofollow">3.9. removeLast方法</a><ul><li><a href="#391-把原来尾节点的prev节点更新为尾节点" rel="noopener nofollow">3.9.1. 把原来尾节点的prev节点更新为尾节点</a></li></ul></li></ul></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<p>底层由双向链表实现的顺序表<br>
有序、可以重复</p>
<h2 id="2-如何使用">2. 如何使用</h2>
<pre><code class="language-java">public class LinkedListTest
{
    public static void main(String[] args)
    {
        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
        list.add("1");
        list.add("2");
        list.addFirst("3");
        list.addLast("4");
        System.out.println(list);
        list.remove(0);
        list.remove("2");
        list.remove();
        list.removeFirst();
        list.removeLast();


    }
}

</code></pre>
<h2 id="3-原理分析">3. 原理分析</h2>
<h3 id="31-uml">3.1. uml</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200122170621.png" class="lazyload"><br>
可以看出LinkedList是个List、双端队列、可序列化、可克隆</p>
<h3 id="32-构造方法">3.2. 构造方法</h3>
<p>由头节点、尾节点、长度构成</p>
<pre><code class="language-java">public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;//提供了List的骨架实现
    implements List&lt;E&gt;/*List接口*/, Deque&lt;E&gt;/*双端队列*/, Cloneable, java.io.Serializable
{

    //属性
    transient int size = 0;//长度
    transient Node&lt;E&gt; first;//头节点
    transient Node&lt;E&gt; last;//尾节点

    //构造方法
    public LinkedList() {
    }
}
</code></pre>
<h4 id="321-队列的节点node">3.2.1. 队列的节点Node</h4>
<pre><code class="language-java"> private static class Node&lt;E&gt; {
    E item;//数据
    Node&lt;E&gt; next;//后指针
    Node&lt;E&gt; prev;//前指针

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre>
<p>结构如下图：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200217101829.png" class="lazyload"></p>
<h3 id="33-add方法">3.3. add方法</h3>
<ul>
<li>O（1）</li>
</ul>
<pre><code class="language-java">public boolean add(E e) {
    //调用linkLast方法
    linkLast(e);
    return true;
}

</code></pre>
<h4 id="331-插入到链表尾部">3.3.1. 插入到链表尾部</h4>
<ul>
<li>linkLast</li>
</ul>
<pre><code class="language-java">void linkLast(E e) {
	//保存尾节点
    final Node&lt;E&gt; l = last;
    //构造新的节点，prev指向last节点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    //把尾节点更新为新的节点
    last = newNode;
    //如果原来的尾节点为空，那么是第一个节点。此时更新first为新节点
    if (l == null)
        first = newNode;
    else
	//否则更新尾节点的next为新的节点
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<h4 id="332-构造新节点prev指向尾节点next为null">3.3.2. 构造新节点【prev指向尾节点，next为null】</h4>
<pre><code class="language-java">//保存尾节点
final Node&lt;E&gt; l = last;
//构造新的节点，prev指向last节点
final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
</code></pre>
<h4 id="333-更新尾节点">3.3.3. 更新尾节点</h4>
<pre><code class="language-java">//如果原来的尾节点为空，那么是第一个节点。此时更新first为新节点
if (l == null)
    first = newNode;
else
//否则更新尾节点的next为新的节点
    l.next = newNode;
</code></pre>
<h4 id="334-更新size">3.3.4. 更新size</h4>
<pre><code class="language-java">size++;
</code></pre>
<h3 id="34-addlast方法">3.4. addLast方法</h3>
<ul>
<li>O（1）</li>
</ul>
<pre><code class="language-java">public void addLast(E e) {
	//调用linkLast
    linkLast(e);
}
</code></pre>
<ul>
<li>linkLast<br>
参考add方法</li>
</ul>
<h3 id="35-addfirst方法">3.5. addFirst方法</h3>
<ul>
<li>O（1）</li>
</ul>
<pre><code class="language-java">public void addFirst(E e) {
	//简单的调用linkFirst
    linkFirst(e);
}
</code></pre>
<h4 id="351-头部插入节点">3.5.1. 头部插入节点</h4>
<ul>
<li>linkFirst</li>
</ul>
<pre><code class="language-java">
private void linkFirst(E e) {
	//先保存原头节点
    final Node&lt;E&gt; f = first;
    //新建节点，next指向原头节点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
    //更新头节点为新的节点
    first = newNode;
    //如果原头节点为空，那么是第一个元素，更新last节点为新的节点
    if (f == null)
        last = newNode;
    else
    //否则更新原头节点的prev为新的节点
        f.prev = newNode;
        
    size++;
    modCount++;
}
</code></pre>
<h4 id="352-构造新节点prev指向nullnext指向头节点">3.5.2. 构造新节点【prev指向null，next指向头节点】</h4>
<pre><code class="language-java">//先保存原头节点
final Node&lt;E&gt; f = first;
//新建节点，next指向原头节点
final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
</code></pre>
<h4 id="353-更新头节点">3.5.3. 更新头节点</h4>
<pre><code class="language-java">//如果原头节点为空，那么是第一个元素，更新last节点为新的节点
if (f == null)
    last = newNode;
else
//否则更新原头节点的prev为新的节点
    f.prev = newNode;
</code></pre>
<h4 id="354-更新size">3.5.4. 更新size</h4>
<pre><code class="language-java">size++;
</code></pre>
<h3 id="36-remove方法根据下标删除">3.6. remove方法【根据下标删除】</h3>
<ul>
<li>
<p>O（N）</p>
</li>
<li>
<p>修改这个元素的前后元素的next和prev指针</p>
</li>
</ul>
<pre><code class="language-java">public E remove(int index) {
		//检查是否越界
        checkElementIndex(index);
    	//根据下标找到相应的节点，并把这个节点删除
        return unlink(node(index));
    }
    
</code></pre>
<h4 id="361-遍历找到这个位置的元素">3.6.1. 遍历找到这个位置的元素</h4>
<ul>
<li>node</li>
</ul>
<pre><code class="language-java">
Node&lt;E&gt; node(int index) {
    // assert isElementIndex(index);

	//索引在链表左半部分
    if (index &lt; (size &gt;&gt; 1)) {
    	//从头节点往右找
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    //索引在链表右半部分
    } else {
    	//从尾节点往左找
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}


</code></pre>
<h4 id="362-更新该节点前后节点的指针">3.6.2. 更新该节点前后节点的指针</h4>
<pre><code class="language-java">E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    //首先保存当前节点的prev，next，和item值
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;

	//更新prev
    if (prev == null) {
    	//前一个节点为空（说明当前节点是头节点），那么把first指向当前节点的下一个节点即可
        first = next;
    } else {
    	//前一个节点的next指向当前节点的下一个节点
        prev.next = next;
        //help gc
        x.prev = null;
    }

	//更新next
    if (next == null) {
    	//后一个节点为空（说明当前节点是尾节点），那么把last指向当前节点的上一个节点即可
        last = prev;
    } else {
    	//后一个节点的prev指向当前节点的上一个节点
        next.prev = prev;
        //help gc
        x.next = null;
    }

	//help gc
    x.item = null;
    size--;//更新size
    modCount++;
    return element;
}

</code></pre>
<h3 id="37-remove方法按照元素删除">3.7. remove方法【按照元素删除】</h3>
<ul>
<li>O（N）</li>
</ul>
<pre><code class="language-java">public boolean remove(Object o) {
	//==null
    if (o == null) {
    	//遍历找到node
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    //equals
    } else {
    	//遍历找到node
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
</code></pre>
<h4 id="371-遍历找到这个元素">3.7.1. 遍历找到这个元素</h4>
<pre><code class="language-java">for (Node&lt;E&gt; x = first; x != null; x = x.next)
{
    //...
}
</code></pre>
<h4 id="372-更新该节点前后节点的指针">3.7.2. 更新该节点前后节点的指针</h4>
<h3 id="38-remove方法无参">3.8. remove方法【无参】</h3>
<ul>
<li>O（1）</li>
</ul>
<pre><code class="language-java">public E remove() {
	//简单调用removeFirst
    return removeFirst();
}
</code></pre>
<h4 id="381-删除头部节点">3.8.1. 删除头部节点</h4>
<ul>
<li>removeFirst</li>
</ul>
<pre><code class="language-java">
public E removeFirst() {
	//头节点
    final Node&lt;E&gt; f = first;
    if (f == null)
    	//为null直接抛出异常
        throw new NoSuchElementException();
    //调用unlinkFirst从链表删除头节点
    return unlinkFirst(f);
}


</code></pre>
<h4 id="382-把原来头节点的next节点更新为头节点">3.8.2. 把原来头节点的next节点更新为头节点</h4>
<ul>
<li>unlinkFirst</li>
</ul>
<pre><code class="language-java">
 private E unlinkFirst(Node&lt;E&gt; f) {
    // assert f == first &amp;&amp; f != null;
    //保存item，next
    final E element = f.item;
    final Node&lt;E&gt; next = f.next;
	
	// help GC    
    f.item = null;
    f.next = null; 
    
    //first直接指向头节点的next
    first = next;
    //如果头节点的next为空，说明链表中只有一个节点
    if (next == null)
    	//更新last指向null
        last = null;
    else
    	//否则更新头节点的next节点的prev指针
        next.prev = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<h3 id="39-removelast方法">3.9. removeLast方法</h3>
<ul>
<li>O（1）</li>
</ul>
<pre><code class="language-java">public E removeLast() {
        final Node&lt;E&gt; l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }
</code></pre>
<h4 id="391-把原来尾节点的prev节点更新为尾节点">3.9.1. 把原来尾节点的prev节点更新为尾节点</h4>
<ul>
<li>unlinkLast</li>
</ul>
<pre><code class="language-java">private E unlinkLast(Node&lt;E&gt; l) {
    // assert l == last &amp;&amp; l != null;
    //保存尾节点的item值和prev
    final E element = l.item;
    final Node&lt;E&gt; prev = l.prev;
    // help GC
    l.item = null;
    l.prev = null;
    //更新last为原尾节点的prev
    last = prev;
    //只有一个元素
    if (prev == null)
        first = null;
    else
        prev.next = null;
    size--;
    modCount++;
    return element;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-28 19:52">2025-06-28 19:52</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">23</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18955021);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18955021', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18955021', title: '3.Java SDK源码分析系列笔记-LinkedList' })">举报</a>
</div>
        