
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18990474" title="发布于 2025-07-18 08:57">
    <span role="heading" aria-level="2">论文阅读-Cerebro: A Platform for Multi-Party Cryptographic Collaborative Learning</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本文构建了一个端到端的协同学习平台Cerebro，能使多方安全地开展机器学习计算协作。</p>
<h3 id="1-介绍">1 介绍</h3>
<p>鉴于读者可能没有了解过密码学，这里也给出安全多方计算的介绍：安全多方计算（MPC）是一种加密技术，它允许<span class="math inline">\(P\)</span>个参与方针对其私有输入<span class="math inline">\(x_1,x_2,\cdots,x_p\)</span>计算函数<span class="math inline">\(f\)</span>，且参与方只能获知<span class="math inline">\(f(x_1,x_2,\cdots,x_p)\)</span>，而无法得知彼此输入的任何其他信息。</p>
<p>之前的工作没有端到端的用于协同学习的安全多方计算。这里的“端到端”指的是，之前的研究会将整个流程拆分成多个独立的子步骤，比如单独设计加密方案、分别优化、最终聚合等，而端到端则是从数据输入到最后得到结果，整个流程为一个整体。</p>
<p>对于端到端的方法，其主要想解决两个问题：</p>
<ul>
<li>
<p>第一是通用性与性能之间的权衡问题。许多关于用于协同学习的MPC的论文聚焦为特定学习任务手动调整MPC，虽然性能高但不具有可推广性；也存在能执行任意程序的通用MPC协议，但这些协议数量很多，用户往往不知道如何选择和优化。</p>
</li>
<li>
<p>第二是隐私与透明度之间的权衡问题。该平台需要确保能满足各组织参与协同学习过程的动机和约束。</p>
</li>
</ul>
<p>Cerebro的目标就是解决上述两个问题，其做法是：</p>
<ul>
<li>
<p>对于第一个问题，Cerebro开发了一个编译器，可以将类Python领域特定语言（DSL）编写的任何程序自动编译为优化的MPC协议。该编译器会提供机器学习相关的API，同时采用新颖的物理规划方法，结合部署环境因素为执行机器学习工作负载选择最优的MPC算法。不过，Cerebro不追求替代手工优化的协议，即性能方面不一定能够超越。</p>
</li>
<li>
<p>对于第二个问题，Cerebro引入一套机制。第一种机制是计算策略，允许各方提供代码，以控制学习任务结果的发布时间和方式；第二种是密码学审计，允许各方回溯并审计隐私计算过程中使用的输入，从而让所有参与方对其行为负责。</p>
</li>
</ul>
<h3 id="2-cerebro概述">2 Cerebro概述</h3>
<h4 id="21-威胁模型">2.1 威胁模型</h4>
<p>考虑有<span class="math inline">\(P\)</span>个参与方，首先假设参与方会在协议阶段达成共识，确定要运行的学习任务、希望彼此揭露的最终结果（比如是一个模型或是一个预测值），以及想要实施的策略。这个假设需要通过外部机制强制执行，例如通过法律协议。</p>
<p>Cerebro允许参与方通过支持半诚实和恶意两种场景来选择适用于其用例的威胁模型：</p>
<ul>
<li>
<p>半诚实场景，敌手最多攻陷<span class="math inline">\(P-1\)</span>个参与方，并分析这些参与方在计算中接收的数据，希望能获取到除了最终结果外的诚实方数据信息；</p>
</li>
<li>
<p>恶意场景，敌手可以让被攻陷的参与方偏离协议，比如篡改计算、使用不一样的输入。</p>
</li>
</ul>
<p>Cerebro通过使用不同的通用密码学后端来支持这两种场景。</p>
<p>而针对机器学习的其他攻击，比如数据投毒、推理攻击、参数窃取攻击等，MPC从定义上就无法防范，Cerebro使用密码学审计策略来进行防御。</p>
<h4 id="22-系统工作流程">2.2 系统工作流程</h4>
<p>其工作流程如图所示：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250717215412178-434693121.png" width="70%"></div>
<ul>
<li>
<p>协议阶段：在运行Cerebro前执行。参与方汇聚并同意参与计算，就学习任务目标达成一致，并就使用的威胁模型达成共识。各参与方还需要建立公钥基础设施（PKI），用来识别参与方。</p>
</li>
<li>
<p>编程模型：用户使用类Python领域特定语言DSL编写程序。通过DSL和Cerebro提供的API，用户能自定义学习任务和策略。用户也能指定配置参数，比如参与方数量以及各方应贡献的数据量。</p>
</li>
<li>
<p>计算策略：用户可以通过DSL自定义计算策略。计算策略表示关于结果获取方式的通用逻辑，或者一些特殊的结果发布策略，比如准确性大于多少的模型才能发布。</p>
</li>
<li>
<p>密码学编译器：Cerebro的编译器首先对使用DSL编写的程序应用逻辑优化，然后将优化后的程序输入到物理规划阶段，以生成高效的物理执行计划。</p>
</li>
<li>
<p>安全计算：Cerebro依据物理执行计划执行安全计算，完成后参与方共同发布结果。</p>
</li>
<li>
<p>密码学审计：各参与方在后期处理阶段与第三方审计者共同审计彼此的输入数据。</p>
</li>
</ul>
<h3 id="3-编程模型和编译器">3 编程模型和编译器</h3>
<p>这一块的过程是：用户使用DSL指定程序，该程序会作为编译器的输入。编译器进行两次逻辑优化过程，在保留安全保证的同时减少了MPC中的计算量。最后，物理规划器接收编译器生成的逻辑计划，并利用物理部署信息实例化和执行计划。</p>
<h4 id="31-dsl">3.1 DSL</h4>
<p>DSL支持机器学习、数据分析和通用函数中常用的各种数值数据类型。</p>
<p>数据类型：Cerebro程序中的每个变量会自动标记类型和安全级别，其中安全级别决定哪些参与方可访问变量的原始值，支持的级别有三种：</p>
<ul>
<li>
<p>public：所有参与方可见；</p>
</li>
<li>
<p>private：仅单一参与方可见，<code>private(i)</code>表示仅参与方i可见；</p>
</li>
<li>
<p>secret：所有参与方均不可见，需通过安全计算协议处理。</p>
</li>
</ul>
<p>变量的安全级别会根据类型推导规则自动升级。程序可以通过一个reveal方法显式降低安全级别。</p>
<p>函数：DSL提供了一组数学和逻辑运算符，每个运算符可接受任意安全标记的输入，其输出标记由一组类型推导规则确定。</p>
<p>Cerebro提供了多种针对数据类型的基本运算符，包括算术运算和比较运算，用户可以组合这些运算符来实现算法；也提供了高级数学运算符比如线代相关的、Sigmoid函数等、一组用于高效索引数组或矩阵的函数、一组分支运算符，以及一组更复杂的融合运算符。</p>
<h4 id="32-逻辑优化">3.2 逻辑优化</h4>
<p>Cerebro包含两种对机器学习任务有用的新优化：</p>
<ul>
<li>
<p>程序拆分。将程序Q拆分为两部分Q1和Q2，Q1可以在明文环境执行，而Q2使用安全计算执行；</p>
</li>
<li>
<p>运算符融合，编译器尝试检测Q2中预定义的复合代码模式，将其转换为更高效的融合操作。</p>
</li>
</ul>
<p>（1）程序拆分</p>
<p>将部分安全计算任务放在本地以明文形式执行。比如一个排序任务，可以安排各参与度预先对各自数据进行本地排序，在安全环境中对排完序的子序列做最后的排序。</p>
<p>在半诚实场景中，Cerebro可以自动识别代码中适合本地计算的部分。首先，根据输入的安全类型，Cerebro使用一组规则来推断输出和函数的安全级别：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250717215505972-906941519.png" width="30%"></div>
<p>如上，如果输入都是public的，其输出也是public，且这类计算可由任意一方以明文形式在本地执行。而如果函数输入包含来自不同参与方的private数据或secret数据，那么该函数就需要使用MPC执行。</p>
<p>而在恶意场景中，由于参与方可能被攻陷，不能假设参与方能在本地正确计算数值。为了兼容本地计算，需要增加额外的步骤。比如排序任务，首先依然是让参与方执行本地明文排序，然后，由于恶意参与方仍然可能向安全计算中输入未排序的数据，全局排序函数会先检查各方输入是否已排序。</p>
<p>这一优化使 Cerebro 能够自动生成高效的安全多方计算（MPC）协议。</p>
<p>（2）融合操作</p>
<p>在MPC中，识别复合代码模式至关重要，因为许多在明文环境中成本较低的复合操作在安全执行时会导致显著的性能损失。比如数组索引，明文下是<span class="math inline">\(O(1)\)</span>，而密文环境下是<span class="math inline">\(O(n)\)</span>。</p>
<p>在Cerebro中，与常见做法一致，会通过线性扫描整个数组来数组索引。考虑在决策树预测等程序中出现的复合代码模式，比如对同一数组多次秘密访问的if/else。在基于电路的MPC中，所有分支都要执行一遍，因此需要对同一数组进行多次扫描。</p>
<p>而Cerebro会将这些运算符组合成一个单一的融合操作<code>secret_index_if</code>，在一次扫描中进行所有可能的判断。</p>
<h4 id="33-物理规划">3.3 物理规划</h4>
<p>物理规划是指，生成逻辑计划后，Cerebro会确定计算的高效物理实例化，然后可以使用Cerebro的某个MPC后端执行。</p>
<p>在将逻辑计划转换为物理实现时，Cerebro必须决定是使用现有布尔和算术MPC协议提供的操作，还是使用特殊向量化原语。为了在这些选项之间进行选择，Cerebro使用一组成本模型来预测不同实现选择的性能，并从中选择最佳方案。最后，一旦选完物理实现，Cerebro就会决定在可用节点之间放置计算的位置。</p>
<p>接下来说明一些记号：</p>
<p>P是参与方的数量，<span class="math inline">\(P_i\)</span>表示第i个参与方。N表示电路中门的总数量，<span class="math inline">\(N_m\)</span>表示算术电路中的乘法门数量，<span class="math inline">\(N_a\)</span>表示布尔电路中的与门数量。<span class="math inline">\(B(\cdot)\)</span>表示网络带宽参数，<span class="math inline">\(l(\cdot)\)</span>表示延迟参数。对于给定的加密算法<span class="math inline">\(C(\cdot)\)</span>，使用<span class="math inline">\(|C(\cdot)|\)</span>表示单个密文的字节数。<span class="math inline">\(c\)</span>表示成本模型中任何常数成本，如初始化成本，其余成本分为计算成本（用<span class="math inline">\(f_i\)</span>函数表示）和网络成本（用<span class="math inline">\(g_i\)</span>函数表示）。</p>
<p>（1）向量化</p>
<p>Cerebro支持编译到两种主要的MPC后端：算术型和布尔型。这两种后端均包含两个阶段：预处理阶段和在线阶段。在预处理阶段，系统会计算随机元素，这些元素可以在后续的在线阶段使用。</p>
<p>在算术MPC的乘法预处理中，参与方需要计算乘法三元组，用于加速在线阶段的乘法操作。对于矩阵乘法，由于乘法运算数量多，需要生成很多三元组，这个代价比较昂贵。本文对此进行了优化，允许向量化生成乘法三元组，这一思想在半诚实两方场景下已经实现，本文将其推广至n方半诚实。</p>
<p>两方向量化协议发生在预处理阶段，计算随机矩阵乘法三元组。比如每个参与方<span class="math inline">\(P_i\)</span>持有<span class="math inline">\(A_j^{(i)},B_j^{(i)},C_j^{(i)}\)</span>，其中<span class="math inline">\(\sum_i(A_j^{(i)}\cdot B_j^{(i)})=\sum_i C_j^{(i)}\)</span>。为了便于分析，假设<span class="math inline">\(B_j\)</span>是一个向量<span class="math inline">\(b\)</span>，那么关系就变为了<span class="math inline">\(c=Ab\)</span>。为了将该设定拓展为多方，以两两应用两方协议的方式生成三元组。要计算该三元组，每个参与方只需首先采样随机<span class="math inline">\(A^{(i)}\)</span>和<span class="math inline">\(b^{(i)}\)</span>，然后使用两方协议计算两两乘积<span class="math inline">\(A^{(i)}\cdot b^{(j)}\)</span>。</p>
<p>（2）成本模型</p>
<p>文章提供了Cerebro中不同成本模型的两个示例。</p>
<p>预处理规划。半诚实算术MPC有两种不同的预处理协议：线性预处理和二次预处理，这两种方法在不同的设置下可能表现迥异。将<span class="math inline">\(C_l\)</span>定义为线性预处理中使用的加密算法，<span class="math inline">\(C_q\)</span>定义为二次预处理中使用的加密算法。</p>
<p>线性预处理的每方成本模型为：</p>
<p></p><div class="math display">\[c+N_m(f_1(|C_l|))+\frac{1}{P}[f_2(|C_l|)(P-1)+f_3(|C_l|)+g(B,|C_l|)(P-1)]
\]</div><p></p><p>二次预处理的每方成本模型为：</p>
<p></p><div class="math display">\[c+N_m(P-1)(f(|C_q|)+g(B,|C_q|))
\]</div><p></p><p>在参与方数量的扩展性方面，线性预处理远优于二次预处理。然而，由于<span class="math inline">\(|C_q|&lt;|C_l|\)</span>，二次预处理加密的计算量和带宽消耗更低。</p>
<p>向量化成本：预处理<span class="math inline">\((m,n)\times (n,1)\)</span>的矩阵，向量乘法的成本模型为：</p>
<p></p><div class="math display">\[c+f_1(|C_q|)(n+m(P-1))+f_2(|C_q|)m(P-1)+g(B,|C_q|)(m+n)(P-1)
\]</div><p></p><p>与二次预处理（将<span class="math inline">\(N_m\)</span>替换为<span class="math inline">\(mn\)</span>）相比，负载从<span class="math inline">\(mn\)</span>减少到<span class="math inline">\(m\)</span>或<span class="math inline">\(m+n\)</span>。注意到，向量化不仅加快了三元组生成速度，而且如果程序中混合了矩阵乘法和常规乘法，还会带来另一个规划机会。</p>
<p>（3）布局优化</p>
<p>在广域网环境中，不同物理布局会显著影响协议性能。Cerebro为跨越多个区域的各方规划了一个可改变的通信模式。</p>
<p>在半诚实模型中，线性预处理需要一组协调器来聚合所有参与方的数据，理论上可以通过均匀分配工作负载，但这种方式仅在两两通信成本相近时有效。</p>
<p>本文引入双层分层布局，其中协调工作同时在区域内和区域间两个级别进行。每个三元组被分配给一个全局协调器，此外还分配一个区域协调器，负责部分聚合单个区域中每个参与方的数据，并将结果发送给全局协调器。</p>
<p>这里假设区域由网络带宽定义。可以手动确定，也能对带宽进行聚类算法划分。</p>
<p>给定<span class="math inline">\(k\)</span>个区域，令<span class="math inline">\(B_{ij}\)</span>表示区域<span class="math inline">\(i,j\)</span>之间的带宽，<span class="math inline">\(B_i\)</span>表示区域<span class="math inline">\(i\)</span>内的带宽。设<span class="math inline">\(n_i\)</span>为分配给区域<span class="math inline">\(i\)</span>中每个参与方的三元组数量，<span class="math inline">\(P_i\)</span>为区域<span class="math inline">\(i\)</span>中的参与方数量。其中，<span class="math inline">\(\sum_{i=1}^k n_i\cdot P_i=N_m\)</span>。此时，成本函数表示为<span class="math inline">\(C=L_1^{'}+L_2^{'}+L_3^{'}\)</span>，其中：</p>
<p></p><div class="math display">\[L_1^{'}=\max (\sum_{j\neq i}(\frac{n_j\cdot P_j(P_i-1)}{P_iB_i}))
\]</div><p></p><p></p><div class="math display">\[L_2^{'}=\max(\frac{n_i\cdot (P_i-1)}{B_i})
\]</div><p></p><p></p><div class="math display">\[L_3^{'}=\max (\sum_{j\neq i}(\frac{n_j\cdot P_j}{B_{ij}})
\]</div><p></p><p>该优化可以转为线性规划来解决。</p>
<h3 id="4-策略与审计">4 策略与审计</h3>
<p>在协作学习场景中，端到端平台需要考虑参与者的激励机制和约束条件。例如，参与者可能会关注训练期间彼此的行为，以及向其他方发布最终模型的成本和收益。某一方可能希望确保其竞争对手获得的经济利益不会大幅超过自身利益。因此，协作学习平台需要允许参与者指定其激励和约束条件，并确保两者都得到满足。</p>
<p>Cerebro 通过引入用户定义的计算策略概念和支持密码学审计的框架来解决这个问题。计算策略作为安全计算的一部分执行，有助于在结果发布前集成额外的预计算和后计算检查。审计则在结果发布后一段时间执行，可让参与方对其在原始安全计算中的输入负责。</p>
<h4 id="41-计算策略">4.1 计算策略</h4>
<p>Cerebro的发布策略由函数<code>if_release</code>控制，结果为true时返回真实值，否则返回0值，从而不发布最终结果。</p>
<p>假设策略函数公开，且所有参与者在协议阶段就这些函数达成一致。而这些策略要使用到的常量或输入（比如训练准确率阈值）可以使用MPC保持私密。</p>
<p>重点关注两类主要策略：</p>
<p>（1）基于验证的策略</p>
<p>在Cerebro中构建基于验证的策略时，除了训练数据集外，每一方还需提供一个测试数据集和一个预测函数。</p>
<ul>
<li>
<p>基于阈值的验证：参与方希望确保协助训练的准确率高于其本地模型；</p>
</li>
<li>
<p>准确率比较：参与方是否发布结果取决于其竞争对手的测试准确率提升幅度；</p>
</li>
<li>
<p>交叉验证：若某一方对训练的贡献不足，其也无法获得最终模型。</p>
</li>
</ul>
<p>（2）隐私策略</p>
<p>由于模型基于各方的私有输入训练，会嵌入关于这些私有输入的信息，因此参与方可能希望引入隐私检查，确保最终模型不会嵌入过多训练数据集的信息，方法主要有：</p>
<ul>
<li>
<p>差分隐私：可以在发布模型前对其添加噪声；</p>
</li>
<li>
<p>模型记忆化：将随机性测量函数编程为发布策略，通过模型输出与原始随机扰动的关联性判断记忆化程度，评估记忆化风险。</p>
</li>
</ul>
<h4 id="42-加密审计">4.2 加密审计</h4>
<p>在恶意模型中，Cerebro可以采用恶意安全的MPC协议抵御计算阶段的违规行为，但是无法防范恶意参与方注入恶意输入的攻击，在发布的模型中嵌入后门。</p>
<p>现有计算策略不足以检测此类攻击，因为策略编写者要么需要预先知道所选后门（不现实），要么需要穷举检查输入域（不可行）。Cerebro提出的一种审计框架，旨在即使在结果发布后，仍能让各方对其原始输入负责。</p>
<p>在审计阶段，所有参与方必须首先就公开审计函数达成一致，然后对其输入训练数据进行审计。如果审计函数构建正确，审计阶段应能识别出输入恶意训练样本的参与方。</p>
<p>（1）审计框架设计</p>
<p>进行审计时，需要确保审计程序能访问与原始计算中使用的相同输入，否则就有可能让恶意参与者在审计期间提供经过净化的输入，从而避免被检测到。Cerebro使用密码学承诺来强制审计阶段也使用计算阶段的相同输入，这是一种密码学工具，可将用户与其输入值绑定，而不泄露实际输入。</p>
<p>参与者通过生成具有两个属性的随机值来对其输入数据进行承诺：绑定性和隐藏性。通俗地说，绑定性意味着从其恶意数据集生成承诺的一方，以后将无法生成另一个经过净化的版本，并声称该承诺与这个新数据集匹配。同时，隐藏性确保承诺不会泄露有关输入的信息。</p>
<p>（2）承诺计划</p>
<p>Cerebro设计的审计计划足够通用，可以用任何承诺和MPC设计来实现。在实践中，有一些方法可以构建有效的承诺，方便与MPC协议进行集成，比如基于SIS的承诺、彼得森承诺。</p>
<p>基于SIS的承诺和彼得森承诺各有优劣，Cerebro会考虑各种情况，并权衡出最佳计划。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-18 08:58">2025-07-18 08:57</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18990474);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18990474', targetLink: 'https://www.cnblogs.com/san-mu/p/18990474', title: '论文阅读-Cerebro: A Platform for Multi-Party Cryptographic Collaborative Learning' })">举报</a>
</div>
        