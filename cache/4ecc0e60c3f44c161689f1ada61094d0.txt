
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19032112" title="发布于 2025-08-11 15:43">
    <span role="heading" aria-level="2">糟糕，生产环境频繁Full GC，怎么办？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>我们在面试时，经常会被面试官问到：线上服务频繁Full GC该如何优化？</p>
<p>今天这篇文章跟大家一起聊聊这个话题，希望对你会有所帮助。</p>
<h2 id="1-什么是full-gc">1. 什么是Full GC？</h2>
<p>当老年代空间不足时，JVM会触发<code>Stop-The-World</code>的全局回收（Full GC），暂停所有应用线程。</p>
<p><strong>致命危害</strong>（生产环境实测）：</p>
<table>
<thead>
<tr>
<th>暂停时间</th>
<th>业务影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>1秒</td>
<td>支付超时率上升5%</td>
</tr>
<tr>
<td>3秒</td>
<td>数据库连接池耗尽</td>
</tr>
<tr>
<td>10秒</td>
<td>服务被注册中心摘除</td>
</tr>
</tbody>
</table>
<p><strong>对象的晋升之路流程图：</strong></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250811154224732-1990297264.png" class="lazyload"></p>
<p><strong>关键代码：年龄计数器</strong></p>
<pre><code class="language-java">// HotSpot虚拟机源码片段（objectMonitor.cpp）
void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock) {
  if (obj-&gt;age() &gt;= MaxTenuringThreshold) { // 年龄阈值检查
    promote_to_old_gen(obj); // 晋升老年代
  }
}
</code></pre>
<h2 id="2如何排查定位问题">2.如何排查定位问题？</h2>
<h3 id="21-实时监控gc健康度速诊">2.1 实时监控：GC健康度速诊</h3>
<pre><code class="language-bash">jstat -gcutil &lt;pid&gt; 1000  # 每秒输出GC数据
</code></pre>
<p><strong>关键指标解读</strong>：</p>
<ul>
<li><strong>OU</strong>：老年代使用率 &gt; 90% = 危险区</li>
<li><strong>FGCT</strong>：Full GC总耗时 &gt; 应用运行时间10% = 严重问题</li>
</ul>
<h3 id="22-堆内存转储揪出内存黑洞">2.2. 堆内存转储：揪出内存黑洞</h3>
<pre><code class="language-bash">jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;  # 生产环境慎用live
</code></pre>
<h3 id="23-mat深度分析解剖内存泄漏">2.3 MAT深度分析：解剖内存泄漏</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250811154235846-409480766.png" class="lazyload"></p>
<h2 id="3优化方案">3.优化方案</h2>
<h3 id="方案1对象池化大对象的救赎">方案1：对象池化——大对象的救赎</h3>
<p><strong>场景</strong>：高频创建10MB的文件缓存</p>
<pre><code class="language-java">// 反例：每次请求创建新对象
public void processRequest(Request req) {
    byte[] buffer = new byte[10 * 1024 * 1024]; // 10MB
    // ...处理逻辑
}

// 优化：对象池复用
private static final ObjectPool&lt;byte[]&gt; pool = new GenericObjectPool&lt;&gt;(
    new BasePooledObjectFactory&lt;byte[]&gt;() {
        @Override
        public byte[] create() {
            return new byte[10 * 1024 * 1024]; 
        }
    }
);

public void processRequest(Request req) throws Exception {
    byte[] buffer = pool.borrowObject();
    try {
        // ...处理逻辑
    } finally {
        pool.returnObject(buffer);
    }
}
</code></pre>
<p><strong>效果</strong>：老年代分配速率下降85%</p>
<h3 id="方案2手动控制晋升">方案2：手动控制晋升</h3>
<p><strong>问题</strong>：Survivor区过小导致对象提前晋升<br>
<strong>优化参数</strong>：</p>
<pre><code class="language-bash">-XX:TargetSurvivorRatio=60  # Survivor区使用阈值
-XX:MaxTenuringThreshold=15 # 最大晋升年龄
-XX:+NeverTenure            # 若Survivor足够，永不晋升（慎用！）
</code></pre>
<p><strong>晋升原理</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250811154253662-1135163360.png" class="lazyload"></p>
<h3 id="方案3合理分配堆空间">方案3：合理分配堆空间</h3>
<p><strong>经典误区</strong>：</p>
<pre><code class="language-bash">-Xmx4g -Xms4g  # 错误！未配置新生代
</code></pre>
<p><strong>优化公式</strong>：</p>
<pre><code>新生代大小 = 总堆 * 3/8  
Eden:Survivor = 8:1:1  
</code></pre>
<p><strong>正确配置</strong>：</p>
<pre><code class="language-bash">-Xmx8g -Xms8g 
-Xmn3g  # 新生代3G (8*3/8≈3)
-XX:SurvivorRatio=8  # Eden:Survivor=8:1:1
</code></pre>
<h3 id="方案4卸载无用类">方案4：卸载无用类</h3>
<p><strong>场景</strong>：热部署频繁的应用（如JRebel）<br>
<strong>诊断命令</strong>：</p>
<pre><code class="language-bash">jcmd &lt;pid&gt; VM.class_stats  # JDK8+
jcmd &lt;pid&gt; GC.class_stats  # JDK11+
</code></pre>
<p><strong>根治代码</strong>：</p>
<pre><code class="language-java">// 自定义类加载器必须实现close()
public class HotSwapClassLoader extends URLClassLoader {
    @Override
    public void close() throws IOException {
        // 1. 停止新请求
        // 2. 卸载所有类
        // 3. 关闭资源
    }
}
</code></pre>
<h3 id="方案5颠覆传统的zgc">方案5：颠覆传统的ZGC</h3>
<p><strong>传统GC痛点</strong>：</p>
<ul>
<li>CMS：内存碎片问题</li>
<li>G1：Mixed GC不可控</li>
</ul>
<p><strong>ZGC迁移步骤</strong>：</p>
<ol>
<li>升级JDK至17+</li>
<li>添加参数：</li>
</ol>
<pre><code class="language-bash">-XX:+UseZGC 
-XX:ZAllocationSpikeTolerance=5.0  # 容忍内存分配速率波动
-Xmx16g -Xlog:gc*:file=gc.log
</code></pre>
<p><strong>效果对比</strong>：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>CMS</th>
<th>ZGC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full GC次数</td>
<td>15次/天</td>
<td>0次/天</td>
</tr>
<tr>
<td>最大暂停</td>
<td>2.8秒</td>
<td>1.2毫秒</td>
</tr>
</tbody>
</table>
<h3 id="方案6堆外内存治理">方案6：堆外内存治理</h3>
<p><strong>现象</strong>：堆内存正常，但Full GC频繁<br>
<strong>根源</strong>：DirectByteBuffer的清理依赖Full GC<br>
<strong>防御方案</strong>：</p>
<pre><code class="language-java">// 方案1：限制堆外内存
-XX:MaxDirectMemorySize=512m

// 方案2：主动调用Cleaner
ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
Cleaner cleaner = ((DirectBuffer) buffer).cleaner();
if (cleaner != null) cleaner.clean();

// 方案3：Netty的内存管理
PooledByteBufAllocator allocator = new PooledByteBufAllocator(true);
ByteBuf buffer = allocator.directBuffer(1024);
// ...使用后必须release!
buffer.release(); 
</code></pre>
<h2 id="4实战案例">4.实战案例</h2>
<p><strong>背景</strong>：某支付系统日均交易10亿<br>
<strong>症状</strong>：</p>
<ul>
<li>每分钟5次Full GC，暂停4.2秒</li>
<li>99线响应时间从50ms飙升至3秒</li>
</ul>
<p><strong>排查过程</strong>：</p>
<ol>
<li><code>jstat</code>显示老年代10秒内从60%→99%</li>
<li>MAT分析发现<code>ConcurrentHashMap$Node[]</code>占78%内存</li>
<li>溯源代码找到缓存黑洞：</li>
</ol>
<pre><code class="language-java">// 问题代码：永不失效的缓存
Map&lt;String, Transaction&gt; cache = new ConcurrentHashMap&lt;&gt;();
public void cacheTransaction(Transaction tx) {
    cache.put(tx.getId(), tx); // Key冲突时旧对象未移除！
}
</code></pre>
<p><strong>解决方案</strong>：</p>
<ol>
<li>改用Caffeine缓存：</li>
</ol>
<pre><code class="language-java">Cache&lt;String, Transaction&gt; cache = Caffeine.newBuilder()
    .maximumSize(10_000)
    .expireAfterWrite(5, TimeUnit.MINUTES)
    .build();
</code></pre>
<ol start="2">
<li>添加ZGC参数</li>
<li>重写线程池任务队列：</li>
</ol>
<pre><code class="language-java">// 用有界队列替代LinkedBlockingQueue
new ThreadPoolExecutor(..., new ArrayBlockingQueue&lt;&gt;(1000));
</code></pre>
<p><strong>效果</strong>：</p>
<ul>
<li>Full GC降为0</li>
<li>99线回落至68ms</li>
</ul>
<h2 id="总结">总结</h2>
<ol>
<li><strong>监控三件套</strong>：</li>
</ol>
<pre><code class="language-bash">jstat -gcutil &lt;pid&gt; 1000  # 实时监控
-Xlog:gc*:file=gc.log     # GC日志
Prometheus + Grafana      # 可视化大盘
</code></pre>
<ol start="2">
<li><strong>参数黄金法则</strong>：</li>
</ol>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250811154310434-2109791564.png" class="lazyload"></p>
<ol start="3">
<li><strong>代码军规</strong>：
<ul>
<li>大对象必须池化</li>
<li>缓存必须设置上限</li>
<li>线程池必须用有界队列</li>
</ul>
</li>
<li><strong>GC算法选择</strong>：
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆&lt;8G</td>
<td>Parallel</td>
</tr>
<tr>
<td>8G~32G</td>
<td>G1</td>
</tr>
<tr>
<td>关键业务系统</td>
<td>ZGC</td>
</tr>
</tbody>
</table>
</li>
</ol>
<blockquote>
<p>Full GC不是优化出来的，是设计出来的！</p>
</blockquote>
<p><strong>永远在架构设计阶段预留30%内存缓冲空间</strong>，比任何调参技巧都重要。</p>
<p><strong>附录：急救工具箱</strong></p>
<table>
<thead>
<tr>
<th>工具</th>
<th>命令</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>jcmd</td>
<td><code>jcmd &lt;pid&gt; GC.run</code></td>
<td>主动触发Full GC</td>
</tr>
<tr>
<td>Arthas</td>
<td><code>vmtool --action getHeap</code></td>
<td>内存快照</td>
</tr>
<tr>
<td>btrace</td>
<td>监控DirectByteBuffer分配</td>
<td>堆外内存泄漏</td>
</tr>
<tr>
<td>PerfMa</td>
<td>在线分析GC日志</td>
<td>自动化诊断</td>
</tr>
</tbody>
</table>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-11 15:44">2025-08-11 15:43</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">177</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19032112);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19032112', targetLink: 'https://www.cnblogs.com/12lisu/p/19032112', title: '糟糕，生产环境频繁Full GC，怎么办？' })">举报</a>
</div>
        