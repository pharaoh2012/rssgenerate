<!----> <meta itemprop="headline" content="🔥 最牛Vue3的无限循环滚动 NPM 包开源了！"> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"> <meta itemprop="datePublished" content="2025-03-28T06:49:50.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员大卫"> <meta itemprop="url" content="https://juejin.cn/user/1961184474695213"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🔥 最牛Vue3的无限循环滚动 NPM 包开源了！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1961184474695213/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员大卫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-03-28T06:49:50.000Z" title="Fri Mar 28 2025 06:49:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-03-28
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    4,342
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>大家好，我是 <strong>前端架构师 - 大卫</strong>。</p>
<p>更多优质内容请关注微信公众号 @<strong>程序员大卫</strong>。</p>
<blockquote>
<p><strong>初心为助前端人🚀，进阶路上共星辰✨，</strong></p>
<p><strong>您的点赞👍与关注❤️，是我笔耕不辍的灯💡。</strong></p>
</blockquote>
<h2 data-id="heading-0">功能介绍</h2>
<h3 data-id="heading-1">1. 向上滚动</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bd0dca420e748b9906d8c5f82788e7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=%2Fr%2F0SDeuCLTgnOsqQO%2BL0Q9T8IM%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-2">2. 向下滚动</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bdc86ddbe6d441e9811d67463f6accf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=c9ejZuhwcLocO%2BECe3yk%2FctIvXQ%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-3">3. 向左滚动</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c6cf6e84024401abb691b75088a5e71~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=Mt0v4EY43cBDtuB3TF3hM%2F3g3zw%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-4">4. 向右滚动</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c042e03d3cf04f1ba2fec54773f8a1c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=2EvQwpF5LXNKnk09cDISfTW4RdY%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-5">5. 滚动暂停</h3>
<p><strong>单步滚动暂停</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9ef31e7aaf7467d8efd1c08cbcfdba5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=o1DW%2BsjXpmocTP0qIY1wCr%2BvUvU%3D" alt="" loading="lazy"></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8dbcbec590aa40eda51f449b8d4c40b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=crg9HfKdpAOfSUgh6YAeLgx7SuU%3D" alt="" loading="lazy"></p>
<p><strong>翻页滚动暂停</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e870bc93d8254f8186d00f093e6c1380~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=f6Up%2FCJ%2BbfYC1zABP%2FqPBMb6flQ%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-6">6. 自适应视口大小和动态数据更新</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/923fbf3dcc674974806811fea6105b3d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=eP7l9YbqoNJiFejYV3dVBhmFCpo%3D" alt="" loading="lazy"></p>
<h2 data-id="heading-7">前言</h2>
<p>先介绍下这个 NPM 包 <code>vue-loop-scroll</code> 的功能：</p>
<ul>
<li>🔥 超大数据流畅滚动
<ul>
<li>即使 10 万条数据，也能丝滑滚动不卡顿！仅渲染<strong>可视区域的 2 倍数据</strong>，大幅减少 DOM 负担，让滚动更流畅。</li>
</ul>
</li>
<li>🌟 适应变化，始终顺滑
<ul>
<li>支持<strong>容器大小动态调整</strong>，即使数据实时更新，依然能保持平滑滚动，提供最佳用户体验。</li>
</ul>
</li>
<li>🔧 灵活滚动控制
<ul>
<li>支持<strong>四向滚动</strong>、<strong>单步停顿</strong>、<strong>滚动速度调节</strong>、<strong>鼠标悬停控制</strong>等多种配置，让滚动更符合需求。</li>
</ul>
</li>
</ul>
<blockquote>
<p>GitHub 地址：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FjoydayX%2Fvue-loop-scroll" target="_blank" title="https://github.com/joydayX/vue-loop-scroll" ref="nofollow noopener noreferrer">github.com/joydayX/vue…</a></p>
<p>官网地址:</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fjoydayx.github.io%2Fwebsite-vue-loop-scroll%2F" target="_blank" title="https://joydayx.github.io/website-vue-loop-scroll/" ref="nofollow noopener noreferrer">joydayx.github.io/website-vue…</a></p>
<p>NPM 包:</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40joyday%2Fvue-loop-scroll" target="_blank" title="https://www.npmjs.com/package/@joyday/vue-loop-scroll" ref="nofollow noopener noreferrer">www.npmjs.com/package/@jo…</a></p>
</blockquote>
<p>如果这个项目对您有帮助，<strong>欢迎留下宝贵的 ⭐Star⭐</strong>！</p>
<p>您的支持不仅是我们优化升级的动力，更是对开源精神的最大认可。</p>
<h2 data-id="heading-8">背景</h2>
<p><strong>循环滚动</strong>是一个很常见的需求，在前端开发过程中几乎不可避免。通常，我们会轮询服务端接口来更新滚动数据，而我开发这个 <code>NPM</code> 包的初衷是什么呢？</p>
<p>在介绍方案之前，我们先弄清楚两个概念：</p>
<ul>
<li><strong>可视区域</strong>：用户能看到的部分。</li>
<li><strong>滚动区域</strong>：整个可滚动内容的范围。</li>
</ul>
<p>只有当滚动区域大于可视区域时，才可以滚动。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2b76be15b3a427ab2fb6efc8223075a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=7r%2FjdnyQFAm9g2rsaHa6u9z2J2o%3D" alt="" loading="lazy"></p>
<h2 data-id="heading-9">传统循环滚动的弊端</h2>
<p>在传统的循环滚动实现中，我们通常会遇到以下几个问题：</p>
<p><strong>1.大数据渲染，如何优化性能？</strong></p>
<ul>
<li>直接渲染所有数据，DOM 负担过大，影响滚动流畅度。</li>
</ul>
<p><strong>2.数据实时更新，如何保证滚动平滑？</strong></p>
<ul>
<li>轮询服务端获取新数据时，如何避免数据更新导致的滚动卡顿或跳跃？</li>
</ul>
<p><strong>3.响应式页面适配，如何让滚动更顺畅？</strong></p>
<ul>
<li>在可视化大屏等自适应页面中，窗口大小变化会影响滚动区域尺寸大小，如何保证滚动不突兀？</li>
</ul>
<h2 data-id="heading-10">旧的解决方案</h2>
<h3 data-id="heading-11">1. 大数据渲染的处理</h3>
<ul>
<li>传统方案通常<strong>不做优化</strong>，直接渲染所有数据。</li>
<li>但如果数据量较大（如上千条），会导致<strong>DOM 负载过高，滚动卡顿</strong>。</li>
</ul>
<h3 data-id="heading-12">2. 处理数据更新时的滚动平滑</h3>
<p><strong>方案 ①：根据滚动区域高度判断是否重置滚动</strong></p>
<p>如果新数据在容器中所占的总高度小于当前滚动区域的最大滚动高度，则继续执行滚动；
否则，重置滚动状态，从顶部重新开始滚动。</p>
<p>缺点:</p>
<ul>
<li>需要<strong>完整渲染所有新数据</strong>后，才能获取总高度；</li>
<li>当数据量较大时，渲染过程可能造成卡顿，影响性能与用户体验。</li>
</ul>
<p><strong>方案 ②：强制重置组件</strong></p>
<p>通过对比新旧数据，如果不一致，则修改组件 key，强制重渲染。</p>
<p>缺点：</p>
<ul>
<li>数据量大时，对比成本高，影响性能。</li>
<li>强制重置组件会导致滚动中断，影响用户体验。</li>
</ul>
<h3 data-id="heading-13">3. 监听可视区域变化</h3>
<p>计算当前滚动高度占滚动区域的百分比，然后用新数据在容器中所占的总高度乘以该百分比，得出新的滚动高度。</p>
<p>缺点：</p>
<ul>
<li>需要<strong>完整渲染所有新数据</strong>来计算总高度，开销较大，影响性能。</li>
</ul>
<h2 data-id="heading-14">本组件库的解决方案</h2>
<h3 data-id="heading-15">1. 优化大数据渲染</h3>
<p><strong>初始化</strong>时，只渲染<strong>可视区域高度的两倍</strong>数据，避免一次性渲染过多内容。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b333503a659d4689b8edc20e8279c097~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=RUxKH8qdYOOcKyam461TXM0UFCE%3D" alt="" loading="lazy"></p>
<p>当<strong>滚动超过可视区域</strong>时，删除已经滚动出视野的数据，<strong>动态加载新的数据</strong>，保持 DOM 轻量化。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b50b618143941d6977b2fe9832b3a37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=3%2BQ0SfvFu3yRRaOQTF26qfaWA%2BA%3D" alt="" loading="lazy"></p>
<p><strong>如何判断加载的滚动项高度？</strong></p>
<p>我们可以使用 <code>nextTick</code>，通过递归不断检查加载的高度是否满足需求。</p>
<p>以下是主要逻辑，<code>loadDataBatch</code> 函数的参数包括<strong>起始索引</strong>和<strong>需要加载的高度</strong>。</p>
<blockquote>
<p><strong>loadDataBatch</strong> 是关键函数，后续还会多次使用。组件参数 <strong>loadCount</strong> 控制每次批量加载的数据量，默认值为 1。</p>
</blockquote>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loadDataBatch</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">startIndex, requiredSize</span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadUntilFilled</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> loadedItems = [];
    <span class="hljs-keyword">let</span> loadCount = props.<span class="hljs-property">loadCount</span>;
    <span class="hljs-keyword">while</span> (loadCount-- &gt; <span class="hljs-number">0</span>) {
      startIndex++;
      loadedItems.<span class="hljs-title function_">push</span>(props.<span class="hljs-property">dataSource</span>[startIndex]);
    }
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();
    <span class="hljs-comment">// 计算已经加载的数据项的高度</span>
    <span class="hljs-keyword">const</span> actualLoadedSize = <span class="hljs-title function_">calculateItemsTotalSize</span>(loadedItems);
    <span class="hljs-keyword">if</span> (requiredSize &gt; actualLoadedSize) {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadUntilFilled</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 已经满足加载尺寸需求</span>
    }
  };
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadUntilFilled</span>();
};
</code></pre>
<p>所以开始滚动前，我们只需要加载<strong>可视区域高度的 2 倍数据</strong>，代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">loadDataBatch</span>(<span class="hljs-number">0</span>, viewportSize * <span class="hljs-number">2</span>);
</code></pre>
<h3 data-id="heading-16">2. 处理数据更新时的滚动平滑</h3>
<p>这是本组件中<strong>最具挑战性</strong>、同时也是最具<strong>技巧与创意</strong>的部分。</p>
<p>假设当前正在滚动的项是：</p>
<p><code>[item-4, item-5, item-6, item-7, item-8, item-9]</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/308b831c9f3248018a27b2791d481158~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=uekPmQUDneQGfP3UDbE7cTFtZ34%3D" alt="" loading="lazy"></p>
<p>此时，服务端返回的新数据是：</p>
<p><code>[item-xxx, item-5, item-xxx, item-xxx, item-xxx, item-xxx]</code></p>
<p>我们可以遍历当前正在滚动的旧数据，在新数据中查找与之匹配的项 <code>item-5</code>，它在新数据中的索引是 <code>1</code>，接着计算该项相对于可视区域<strong>上边界</strong>与<strong>下边界</strong>的距离。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9237ad902334ec582aaa14ffa68a5a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749778164&amp;x-signature=%2BAiO501Fo7DrzNFdGWO9S0J605Y%3D" alt="" loading="lazy"></p>
<p><strong>匹配规则</strong>：</p>
<p>根据组件参数 <code>itemKey</code> 提供的唯一标识字段进行匹配。若未传入 <code>itemKey</code>，则默认使用 <code>JSON.stringify(item)</code> 作为唯一标识。</p>
<p><code>itemKey</code> 用法如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> dataSource = [{<span class="hljs-attr">id</span>: <span class="hljs-string">"123"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"Hello"</span>}, {<span class="hljs-attr">id</span>: <span class="hljs-string">"456"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"World"</span>} ]

&lt;<span class="hljs-title class_">LoopScroll</span> :dataSource itemKey=<span class="hljs-string">"id"</span>&gt;&lt;/<span class="hljs-title class_">LoopScroll</span>&gt;
</code></pre>
<p>然后，我们调用之前提到的 <code>loadDataBatch</code> 函数两次：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 第一次调用</span>
<span class="hljs-title function_">loadDataBatch</span>(<span class="hljs-number">1</span>, item-<span class="hljs-number">5</span> 距离可视区域上边框的高度)

<span class="hljs-comment">// 第2次调用</span>
<span class="hljs-title function_">loadDataBatch</span>(<span class="hljs-number">1</span>, item-<span class="hljs-number">5</span> 距离可视区域下边框的高度 + 可视区域的高度)
</code></pre>
<p>为什么第二次调用函数 <code>loadDataBatch</code> 需要额外加上可视区域的高度？</p>
<p>因为在“第一点：优化大数据渲染”中，我们约定<strong>滚动区域高度必须至少是可视区域的 2 倍</strong>，否则会导致滚动出现断层。</p>
<p><strong>特殊情况：</strong></p>
<p>当新数据与当前滚动数据<strong>完全没有匹配项</strong>时，意味着无法还原之前的滚动位置。</p>
<p>从业务角度来说，用户通常也不希望继续看到旧数据，这种情况下应当重置滚动状态，从头开始滚动，以避免误导或错乱的展示。</p>
<h3 data-id="heading-17">3. 监听可视区域变化</h3>
<p>在解决了<strong>第二点</strong>的核心问题之后，<strong>第三点</strong>就简单多了。</p>
<p>当容器尺寸或列表项的高度发生变化时，我们可以假设<strong>服务端返回的是同一批数据</strong>，这意味着我们无需关心数据内容的变更，仅需重新执行<strong>第二点中的定位逻辑</strong>即可。</p>
<p>为了实现这一逻辑，我们可以引入一个<strong>自增的刷新 ID</strong>。每当监听到尺寸变化时，递增这个 ID，作为触发重新计算的信号。代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> updateCounter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">triggerUpdate</span> = (<span class="hljs-params"></span>) =&gt; {
  updateCounter.<span class="hljs-property">value</span>++;
};

<span class="hljs-comment">/** 监听"数据源变化"和“自增id”变化 */</span>
<span class="hljs-title function_">watch</span>(
  <span class="hljs-function">() =&gt;</span> [props.<span class="hljs-property">dataSource</span>, updateCounter.<span class="hljs-property">value</span>],
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 重新渲染页面数据展示</span>
  },
);

<span class="hljs-comment">/** 监听 "可视区域内容" 尺寸变化 */</span>
<span class="hljs-title function_">useResizeObserver</span>(scrollViewportRef, <span class="hljs-function">()=&gt;</span>{
    <span class="hljs-title function_">triggerUpdate</span>();
});

<span class="hljs-comment">/** 监听 "滚动内容区域" 尺寸变化 */</span>
<span class="hljs-title function_">useResizeObserver</span>(scrollTrackRef, <span class="hljs-function">()=&gt;</span>{
    <span class="hljs-title function_">triggerUpdate</span>();
});
</code></pre>
<h2 data-id="heading-18">关键技术分析</h2>
<h3 data-id="heading-19">1. 为什么不使用 clientHeight 来获取高度？</h3>
<p>我们选择使用 <code>getBoundingClientRect()</code>，主要原因：</p>
<ul>
<li>监听容器尺寸变化用的 API 是<code>ResizeObserver</code>，它监听到的尺寸值是<strong>带小数点的浮点数</strong>，而<code>clientHeight</code>仅返回整数，会导致监听误差。</li>
<li>使用 <code>getBoundingClientRect</code> 返回的尺寸精度更高，能够与<code>ResizeObserver</code>保持一致性。</li>
</ul>
<h3 data-id="heading-20">2. 新数据到来时如何实现平滑过渡？</h3>
<ul>
<li><strong>缓存旧数据</strong>，在新数据加载过程中，先缓存旧数据，按批次逐步加载新数据。每次加载后使用 <code>nextTick</code> 判断当前内容总高度是否超过可视区域，用以判断是否具备滚动条件。</li>
<li><strong>如果可以滚动</strong>，恢复旧数据，并根据之前 "2.处理数据更新时的滚动平滑" 的逻辑，继续执行滚动。</li>
<li><strong>如果不可以滚动</strong>，则停止滚动并重置所有状态。</li>
</ul>
<h3 data-id="heading-21">3. 滚动暂停的处理</h3>
<p>假设场景如下：</p>
<ul>
<li>每帧滚动步长为 <code>3px</code></li>
<li>每个列表项高度为 <code>10px</code></li>
</ul>
<p>在第 4 帧时，总共滚动了 <code>3 × 4 = 12px</code>，超过了 <code>10</code>，会导致不对齐。</p>
<p><strong>解决方案：</strong></p>
<p>当滚动到第 <code>4</code> 帧时，将滚动步长调整为 <code>1px</code>，使得累计滚动距离为 <code>3 × 3 + 1 = 10px</code>，这样就能对齐列表项的边界了。</p>
<h3 data-id="heading-22">4. 如何优雅地实现逆向滚动(向下和向右滚动)</h3>
<p>假设正向滚动(向上和向左)时，我们存储的<strong>数据项信息</strong>如下：</p>
<pre><code class="hljs language-js" lang="js">[itemInfo-<span class="hljs-number">1</span>, itemInfo-<span class="hljs-number">2</span>, itemInfo-<span class="hljs-number">3</span>]
</code></pre>
<p>其中 <code>itemInfo</code>  主要包含 <code>height</code>、<code>top</code>、<code>bottom</code> 等信息，用于计算滚动位置。</p>
<p><strong>逆向滚动的关键点</strong>：</p>
<ul>
<li>存储数据项的顺序保持不变，还是<code>[itemInfo-1, itemInfo-2, itemInfo-3]</code>。</li>
<li>而渲染数据时倒序排列，确保滚动逻辑清晰，避免混乱。</li>
</ul>
<h3 data-id="heading-23">5. CSS 的特殊设置</h3>
<p><strong>1. CSS 设置 <code>content: ""</code></strong></p>
<ul>
<li>当向左滚动时，在内容前插入 content: ""；</li>
<li>当向右滚动时，在内容后插入 content: ""。</li>
</ul>
<p>这样处理是为了解决使用 <code>flex</code> 布局中的 <code>gap</code> 属性可能引发的抖动问题。由于 <code>gap</code> 仅作用于相邻项之间，当滚动时第 2 项变为第 1 项，前方缺少相邻元素，导致布局位置略有偏移，从而出现抖动现象。</p>
<p><strong>2. CSS 设置 <code>display: flow-root</code></strong></p>
<p><code>滚动区域</code> 设置 <code>display: flow-root;</code> 主要是为了创建一个 BFC（块格式化上下文），从而解决浮动塌陷和 <code>margin</code> 合并问题。</p>
<p>例如：每个子项使用 <code>margin: 10px 0</code> 作为垂直间距时，滚动区域的总高度会出现误差，因为第一项的上边距和最后一项的下边距不会被包含在父元素（滚动区域）的高度计算中。而设置 <code>display: flow-root</code> 可以创建一个 BFC，从而避免这种 <code>margin</code> 折叠问题，确保高度计算准确。</p>
<p>如果浏览器不支持 <code>display: flow-root;</code>，可以使用以下替代方案:</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.scroll-loop-track</span>{
    <span class="hljs-comment">/* display: flow-root; */</span>
    &amp;<span class="hljs-selector-pseudo">::before</span>,
    &amp;<span class="hljs-selector-pseudo">::after</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
        <span class="hljs-attribute">display</span>: table;
    }
}
</code></pre>
<p><strong>3. CSS 设置 <code>width: max-content</code></strong></p>
<p>在横向（向左或向右）滚动时，将<code>滚动区域</code>设置为 <code>width: max-content</code>，可以让其宽度根据内容的最大固有宽度自动扩展，避免内容换行。</p>
<h2 data-id="heading-24">注意事项</h2>
<p>在实际项目中使用时，请合理设置 <strong>itemKey</strong> 和 <strong>loadCount</strong>，以获得最佳性能和正确的数据更新。</p>
<ul>
<li>
<p><strong>itemKey</strong> 是列表数据项的唯一标识字段名。在数据更新时，组件会通过 <code>itemKey</code> 找到对应的项并更新其内容，以确保正确的数据匹配和渲染。</p>
</li>
<li>
<p><strong>loadCount</strong> 控制每次批量加载的数据量，默认值为 <code>1</code>。建议设置为<strong>当前可视区域最多能展示的项数</strong>，这样可以减少不必要的渲染计算，提升滚动性能，而不是每次仅加载 <code>1</code> 项后再判断是否填满可视区域。</p>
</li>
</ul>
<h2 data-id="heading-25">总结</h2>
<p>本组件专为大数据滚动场景设计，<strong>滚动超顺滑</strong>，只渲染可见内容，性能杠杠的。</p>
<p>还能<strong>自动适应尺寸和数据变化，支持四向滚动、速度调节</strong>等各种控制，灵活又好用。</p>
<h2 data-id="heading-26">最后</h2>
<p>如果觉得本文对你有帮助，欢迎点赞👍、关注➕、收藏❤️，也欢迎在评论区交流你的看法！</p></div></div>