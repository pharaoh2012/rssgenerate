
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hanyaxxx/p/18742536" title="发布于 2025-02-28 08:57">
    <span role="heading" aria-level="2">Chrome 133 里程碑式更新 - moveBefore, 或开启前端框架未来新纪元?</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="相关背景">相关背景:</h1>
<p>Chrome 133 版本（将于 2 月 4 日发布稳定版）引入了一个新的 DOM 操作方法：<code>Node.prototype.moveBefore</code>。这一方法虽然看似简单，但其意义重大，因为它能够在移动 DOM 元素时保留元素的状态。传统的 DOM 移动操作通常需要先移除元素再重新插入，这会导致元素的状态重置，而 <code>moveBefore</code> 则避免了这一问题。</p>
<h1 id="特性">特性:</h1>
<h2 id="1保留元素状态">1、保留元素状态</h2>
<p><code>moveBefore</code> 方法能够在移动 DOM 元素时保留其状态，这意味着：内嵌框架 (iframe) 会保持加载状态，活动元素会保持焦点，弹出窗口、全屏模式、模态对话框会保持打开状态，CSS 过渡和动画会继续执行。</p>
<p>moveBefore 可以用于各种需要移动 DOM 元素并保留其状态的场景，例如：</p>
<ul>
<li>拖放操作</li>
<li>动态排序列表</li>
<li>创建动画效果</li>
<li>.....</li>
</ul>
<h2 id="2语法简洁">2、语法简洁</h2>
<p><code>moveBefore</code> 的语法与 <code>insertBefore</code> 类似，开发者可以轻松替换现有的代码。例子：</p>
<p>传统上，开发者使用 <code>Node.prototype.insertBefore</code> 方法来替换 DOM 元素。然而，使用 insertBefore 方法会导致被替换的节点重新加载状态。</p>
<pre><code class="language-js"> document.querySelector('#classic').addEventListener('click', () =&gt; {
   const $newSibling = getRandomElementInBody();
   const $iframe = document.querySelector('iframe');
   // document.body.insertBefore($iframe, $newSibling); //无状态替换,需要重新注册
   document.body.moveBefore($iframe, $newSibling); //状态可保留
 });
</code></pre>
<p>以下这个演示为我们展示了 moveBefore 的强大魔力:<br>
<a href="https://state-preserving-atomic-move.glitch.me/?scenario=selection" target="_blank" rel="noopener nofollow">state-preserving-atomic-move.glitch.me/?scenario=selection</a></p>
<h1 id="意义解读">意义解读:</h1>
<ol>
<li>
<p>性能更优,避免了传统无状态DOM操作中产生的重排消耗</p>
</li>
<li>
<p>从无状态的DOM操作提供了一个过渡到有状态的DOM操作的方法</p>
</li>
<li>
<p>为前端MVVM机制提供了更优的性能保障</p>
</li>
</ol>
<h1 id="未来展望">未来展望:</h1>
<ol>
<li>
<p>diff 将或与成为历史, 随着更多现代浏览器和更多先进的 DOM-API 加入后, 以react,vue为代表的现代前端框架设计理念或许将会被修正; 包括数据流,vdom的概念</p>
</li>
<li>
<p>以 <code>moveBefore</code> 为里程碑或许未来将会加入更多的带状态操作的 DOM API.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里就不得不提到 <strong>C39 Signal 提案</strong> , 如果对前端前沿技术比较关注的同学,对状态管理的Signal解决方案想必是已经熟悉了,<code>useSignal</code> 的核心概念基于 TC39 的信号提案，这是一个旨在标准化 JavaScript 中响应式状态管理的提案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于 <code>useSignal</code> 的概念早在十年前就已经出现，例如在 Knockout 框架中就已经使用了类似的信号机制。然而，由于当时的编译技术和开发体验的限制，这种机制并未广泛流行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该提案的目标是通过信号（<code>Signal</code>）机制，提供一种细粒度的响应式状态管理方式，允许开发者更高效地管理状态变化。如果这一标准能够无缝集成到浏览器中或许复杂的前端"框架"也将成为历史,一切回归到本真,从简出发</p>
</li>
<li>
<p>驱动开源社区提供更优质的MVVM架构设计, 简化现代MVVM架构中冗余和糟粕的部分,让开发学习成本更低,也让机器学习的成本更低,为未来的自动化应用的落地成为更现实的可能.</p>
</li>
</ol>
<p>当然最终结果还是取决于开源社区和开发者是否积极向上的去拥抱新特性,就让历史见证一切</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011185088226851853" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 08:58">2025-02-28 08:57</span>&nbsp;
<a href="https://www.cnblogs.com/hanyaxxx">hanyaxxxx</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18742536" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18742536);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18742536', targetLink: 'https://www.cnblogs.com/hanyaxxx/p/18742536', title: 'Chrome 133 里程碑式更新 - moveBefore, 或开启前端框架未来新纪元?' })">举报</a>
</div>
        