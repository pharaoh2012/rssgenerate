
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/crossoverJie/p/18961353" title="发布于 2025-07-02 13:40">
    <span role="heading" aria-level="2">StarRocks 物化视图创建与刷新全流程解析</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>最近在为 StarRocks 的物化视图增加<a href="https://github.com/StarRocks/starrocks/pull/60035" target="_blank" rel="noopener nofollow">多表达式支持</a>的能力，于是便把物化视图（MV）的创建刷新流程完成的捋了一遍。</p>
<p>之前也写过一篇：<a href="https://crossoverjie.top/2024/11/18/ob/StarRocks-MV-refresh-Principle/" target="_blank" rel="noopener nofollow">StarRocks 物化视图刷新流程和原理</a>，主要分析了刷新的流程，以及刷新的条件。</p>
<p>这次从头开始，从 MV 的创建开始来看看 StarRocks 是如何管理物化视图的。</p>
<h1 id="创建物化视图">创建物化视图</h1>
<pre><code class="language-sql">CREATE
MATERIALIZED VIEW mv_test99
REFRESH ASYNC EVERY(INTERVAL 60 MINUTE)
PARTITION BY p_time
PROPERTIES (
"partition_refresh_number" = "1"
)
AS
select date_trunc("day", a.datekey) as p_time, sum(a.v1) as value
from par_tbl1 a
group by p_time, a.item_id
</code></pre>

<p>创建物化视图的时候首先会进入这个函数：<code>com.starrocks.sql.analyzer.MaterializedViewAnalyzer.MaterializedViewAnalyzerVisitor#visitCreateMaterializedViewStatement</code></p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130212223-871759227.png" class="lazyload"></p>
<blockquote>
<p>其实就是将我们的创建语句结构化为一个 <code>CreateMaterializedViewStatement</code> 对象，这个过程是使用 ANTLR 实现的。</p>
</blockquote>
<p>这个函数负责对创建物化视图的 SQL 语句进行语义分析、和基本的校验。</p>
<p>比如：</p>
<ul>
<li>分区表达式是否正确</li>
<li>基表、数据库这些的格是否正确</li>
</ul>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130212351-622031094.png" class="lazyload"></p>
<blockquote>
<p>校验分区分区表达式的各种信息。</p>
</blockquote>
<p>然后会进入函数：<code>com.starrocks.server.LocalMetastore#createMaterializedView()</code></p>
<p>这个函数的主要作用如下：</p>
<ol>
<li>
<p><strong>检查数据库和物化视图是否存在</strong>。</p>
</li>
<li>
<p><strong>初始化物化视图的基本信息</strong>：</p>
<ul>
<li>获取物化视图的列定义（schema）</li>
<li>验证列定义的合法性</li>
<li>初始化物化视图的属性（如分区信息）。</li>
</ul>
</li>
<li>
<p><strong>处理刷新策略</strong>：</p>
<ul>
<li>根据刷新类型（如 <code>ASYNC</code>、<code>SYNC</code>、<code>MANUAL</code> 或 <code>INCREMENTAL</code>）设置刷新方案。</li>
<li>对于异步刷新，设置刷新间隔、开始时间等，并进行参数校验。</li>
</ul>
</li>
<li>
<p><strong>创建物化视图对象</strong>：</p>
<ul>
<li>根据运行模式（存算分离和存算一体）创建不同类型的物化视图对象</li>
<li>设置物化视图的索引、排序键、注释、基础表信息等。</li>
</ul>
</li>
<li>
<p><strong>处理分区逻辑</strong>：</p>
<ul>
<li>如果物化视图是非分区的，创建单一分区并设置相关属性。</li>
<li>如果是分区的，解析分区表达式并生成分区映射关系</li>
</ul>
</li>
<li>
<p><strong>绑定存储卷</strong>：</p>
<ul>
<li>如果物化视图是云原生类型，绑定存储卷。<br>
<img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211915-198668491.png" class="lazyload"></li>
</ul>
</li>
</ol>
<h2 id="序列化关键数据">序列化关键数据</h2>
<p>对于一些核心数据，比如分区表达式、原始的创建 SQL 等，需要再重启的时候可以再次加载到内存里供后续使用时；</p>
<p>就需要将这些数据序列化到元数据里。</p>
<p>这些数据定期保存在 <code>fe/meta</code> 目录中。<br>
<img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211614-1123361743.png" class="lazyload"></p>
<p>我们需要序列化的字段需要使用 <code>@SerializedName</code>注解。</p>
<pre><code class="language-java">@SerializedName(value = "partitionExprMaps")  
private Map&lt;ExpressionSerializedObject, ExpressionSerializedObject&gt; serializedPartitionExprMaps;
</code></pre>
<p>同时在 <code>com.starrocks.catalog.MaterializedView#gsonPreProcess/gsonPostProcess</code> 这两个函数中将数据序列化和反序列化。</p>
<h3 id="元数据的同步与加载">元数据的同步与加载</h3>
<p>当 StarRocks 的 FE 集群部署时，会由 leader 的 FE 启动一个 checkpoint 线程，定时扫描当前的元数据是否需要生成一个 <code>image.${JournalId}</code> 的文件。</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211130-2096087992.png" class="lazyload"></p>
<blockquote>
<p>其实就是判断当前日志数量是否达到上限（默认是 5w）生成一次。</p>
</blockquote>
<p>具体的流程如下：<br>
<img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211328-974500045.png" class="lazyload"><br>
<img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211477-89604922.png" class="lazyload"></p>
<p><img alt="" loading="lazy" data-src="https://i.imgur.com/txqTt0U.png" class="lazyload"></p>
<p>更多元数据同步和加载流程可以查看我之前的文章：<a href="https://crossoverjie.top/2024/11/11/ob/StarRocks-meta/" target="_blank" rel="noopener nofollow">深入理解 StarRocks 的元数据管理</a></p>
<h1 id="刷新物化视图">刷新物化视图</h1>
<p>创建完成后会立即触发一次 MV 的刷新逻辑。</p>
<h2 id="同步分区">同步分区</h2>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211704-286938190.png" class="lazyload"><br>
刷新 MV 的时候有一个很重要的步骤：<strong>同步 MV 和基表的分区</strong>。</p>
<blockquote>
<p>这个步骤在每次刷新的时候都会做，只是如果基表分区和 MV 相比没有变化的话就会跳过。</p>
</blockquote>
<p>这里我们以常用的 <code>Range</code> 分区为例，核心的函数为：<code>com.starrocks.scheduler.mv.MVPCTRefreshRangePartitioner#syncAddOrDropPartitions</code></p>
<p>它的主要作用是同步物化视图的分区，添加、删除分区来保持 MV 的分区与基础表的分区一致；核心流程：</p>
<ol>
<li><strong>计算分区差异</strong>：根据指定的分区范围，计算物化视图与基础表之间的分区差异。</li>
<li>同步分区：
<ol>
<li><strong>删除旧分区</strong>：删除物化视图中与基础表不再匹配的分区。</li>
<li><strong>添加新分区</strong>：根据计算出的差异，添加新的分区到物化视图。</li>
</ol>
</li>
</ol>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211832-548802183.png" class="lazyload"></p>
<p>分区同步完成之后就可以计算需要刷新的分区了：<br>
<img alt="image.png" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1431471/202507/1431471-20250702130211697-478819252.png" class="lazyload"></p>
<p>以上内容再结合之前的两篇文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2024/11/18/ob/StarRocks-MV-refresh-Principle/" target="_blank" rel="noopener nofollow">StarRocks 物化视图刷新流程和原理</a></li>
<li><a href="https://crossoverjie.top/2024/11/11/ob/StarRocks-meta/" target="_blank" rel="noopener nofollow">深入理解 StarRocks 的元数据管理</a></li>
</ul>
<p>就可以将整个物化视图的创建与刷新的核心流程掌握了。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="font-size: small">

<p>
        作者： 
        <a href="https://crossoverjie.top/about/">crossoverJie</a>
</p>
<p>
        出处：
        <a href="https://crossoverjie.top/">https://crossoverjie.top</a>
</p>
<img src="https://i.loli.net/2019/05/19/5ce16dbc99cfa13989.jpg">
<p>
欢迎关注博主公众号与我交流。
</p>
<p>
         本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出,
            如有问题， 可邮件（crossoverJie#gmail.com）咨询。
</p>
</div>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-02 13:41">2025-07-02 13:40</span>&nbsp;
<a href="https://www.cnblogs.com/crossoverJie">crossoverJie</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18961353);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18961353', targetLink: 'https://www.cnblogs.com/crossoverJie/p/18961353', title: 'StarRocks 物化视图创建与刷新全流程解析' })">举报</a>
</div>
	