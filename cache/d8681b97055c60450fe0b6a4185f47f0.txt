
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18728843/svelte-stores" title="发布于 2025-02-21 10:53">
    <span role="heading" aria-level="2">Svelte 最新中文文档教程（15）—— Stores</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>Svelte，一个语法简洁、入门容易，面向未来的前端框架。从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://yayujs-blog.oss-cn-beijing.aliyuncs.com/405488775-48df16b1-939c-489b-8d52-6071869893f0.png" alt="image.png" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目，也是我做个人项目的首选技术栈。</strong></p>
<p>目前 Svelte 基于 Svelte 5 发布了最新的官方文档，但却缺少对应的中文文档。为了帮助大家学习 Svelte，为爱发电翻译了官方文档。</p>
<p>我同时搭建了 Svelte 最新的中文文档站点：<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">https://svelte.yayujs.com</a> ，如果需要辅助学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>虽说是翻译，但个人并不喜欢严格遵守原文，为了保证中文阅读流畅，会删减部分语句，对难懂的部分也会另做补充解释，希望能给大家带来一个好的中文学习体验。</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上前端大佬成长之路。</p>
<h2 id="stores">Stores</h2>

<p><em>store</em> 是一个对象，允许通过简单的 <em>store 合约（store contract）</em> 对值进行响应式访问。 <a href="https://svelte.yayujs.com/docs/svelte-store" target="_blank" rel="noopener nofollow"><code>svelte/store</code> 模块</a> 包含满足此合约的最小 store 实现。</p>
<p>每当您引用 store 时，您都可以在组件内通过添加 <code>$</code> 前缀访问它的值。这会导致 Svelte 声明带前缀的变量，在组件初始化时订阅 store，并在适当的时候取消订阅。</p>
<p>对 <code>$</code> 前缀变量进行赋值要求该变量是一个可写的 store ，并将导致对 store 的 <code>.set</code> 方法的调用。</p>
<p>请注意，store 必须在组件的顶层声明 —— 例如，不能在 <code>if</code> 块或函数内部声明。</p>
<p>局部变量（不是 store 的值）<strong>不能</strong>有 <code>$</code> 前缀。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { writable } from 'svelte/store';

  const count = writable(0);
  console.log($count); // 输出 0

  count.set(1);
  console.log($count); // 输出 1

  $count = 2;
  console.log($count); // 输出 2
&lt;/script&gt;
</code></pre>
<h2 id="何时使用-store">何时使用 store</h2>
<p>在 Svelte 5 之前， store 是创建跨组件响应式状态或提取逻辑的首选解决方案。随着符文的出现，这些用例已大大减少。</p>
<ul>
<li>在提取逻辑时，最好利用符文的通用响应性：你可以在组件顶层之外使用符文，甚至可以将它们放入 JavaScript 或 TypeScript 文件（使用 <code>.svelte.js</code> 或 <code>.svelte.ts</code> 文件后缀）。</li>
<li>在创建共享状态时，你可以创建一个包含所需值的 <code>$state</code> 对象，然后操作该状态。</li>
</ul>
<pre><code class="language-ts">/// file: state.svelte.js
export const userState = $state({
  name: 'name'
  /* ... */
});
</code></pre>
<pre><code class="language-svelte">&lt;!--- file: App.svelte ---&gt;
&lt;script&gt;
  import { userState } from './state.svelte.js';
&lt;/script&gt;

&lt;p&gt;用户名: {userState.name}&lt;/p&gt;
&lt;button onclick={() =&gt; {
  userState.name = '新名字';
}}&gt;
  修改名字
&lt;/button&gt;
</code></pre>
<p>当你有复杂的异步数据流，或需要手动控制更新值或监听变化时， store 仍然是一个不错的解决方案。如果你熟悉 RxJs 并希望复用这些知识，<code>$</code> 也会对你很有帮助。</p>
<h2 id="sveltestore">svelte/store</h2>
<p><code>svelte/store</code> 模块包含满足 store 合约的最小 store 实现。它提供了创建可以从外部更新的 store 、只能从内部更新的 store 以及组合和派生 store 的方法。</p>
<h3 id="writable"><code>writable</code></h3>
<p>一个函数，可以创建一个从“外部”组件设置值的 store。store 是一个额外带有<br>
<code>set</code> 和 <code>update</code> 方法的对象。</p>
<p><code>set</code> 是一个方法，它接受一个参数，该参数是要设置的值。如果 store 值与参数值不相等，则 store 值将设置为参数值。</p>
<p><code>update</code> 是一个方法，它接受一个参数，该参数是一个回调函数。回调函数以现有的 store 值作为其参数,并返回要设置到 store 中的新值。</p>
<pre><code class="language-js">/// file: store.js
import { writable } from 'svelte/store';

const count = writable(0);

count.subscribe((value) =&gt; {
  console.log(value);
}); // 输出 '0'

count.set(1); // 输出 '1'

count.update((n) =&gt; n + 1); // 输出 '2'
</code></pre>
<p>如果 <code>writeable</code> 的第二个参数传递了一个函数，它将在订阅者数量从 0 到 1 时被调用（而不是从 1 到 2，等等）。</p>
<p>该函数将接收一个 <code>set</code> 函数，用于改变 store 的值，以及一个 <code>update</code> 函数，其工作原理类似于 store 的 <code>update</code> 方法，接受一个回调函数，根据旧值计算 store 的新值。它必须返回一个 <code>stop</code> 函数，当订阅者数量从 1 到 0 时调用该函数。</p>
<pre><code class="language-js">/// file: store.js
import { writable } from 'svelte/store';

const count = writable(0, () =&gt; {
  console.log('得到一个订阅者');
  return () =&gt; console.log('没有更多的订阅者');
});

count.set(1); // 不执行

const unsubscribe = count.subscribe((value) =&gt; {
  console.log(value);
}); // 输出 '得到一个订阅者'，然后输出 '1'

unsubscribe(); // 输出 '没有更多的订阅者'
</code></pre>
<p>注意，当 <code>writable</code> 的值被销毁时，例如当页面刷新时，其值会丢失。但是，你可以编写自己的逻辑，将值同步到比如 <code>localStorage</code> 中。</p>
<h3 id="readable"><code>readable</code></h3>
<p>创建一个不能从“外部”设置值的 store ，第一个参数是 store 的初始值，第二个参数与 <code>writable</code> 的第二个参数相同。</p>
<pre><code class="language-ts">import { readable } from 'svelte/store';

const time = readable(new Date(), (set) =&gt; {
  set(new Date());

  const interval = setInterval(() =&gt; {
    set(new Date());
  }, 1000);

  return () =&gt; clearInterval(interval);
});

const ticktock = readable('tick', (set, update) =&gt; {
  const interval = setInterval(() =&gt; {
    update((sound) =&gt; (sound === 'tick' ? 'tock' : 'tick'));
  }, 1000);

  return () =&gt; clearInterval(interval);
});
</code></pre>
<h3 id="derived"><code>derived</code></h3>
<p>从一个或多个其他 store 派生出一个 store 。回调在第一个订阅者订阅时运行,然后在 store 依赖关系发生变化时运行。</p>
<p>在最简单的版本中，<code>derived</code> 接受一个 store ，回调返回一个派生值。</p>
<pre><code class="language-ts">// @filename: ambient.d.ts
import { type Writable } from 'svelte/store';

declare global {
  const a: Writable&lt;number&gt;;
}

export {};

// @filename: index.ts
// ---cut---
import { derived } from 'svelte/store';

const doubled = derived(a, ($a) =&gt; $a * 2);
</code></pre>
<p>回调可以通过接受第二个参数 <code>set</code> 和一个可选的第三个参数 <code>update</code> 异步设置一个值，并在适当时调用它们中的一个或两个。</p>
<p>在这种情况下，您还可以向 <code>derived</code> 传递第三个参数 —— 派生 store 在第一次调用 <code>set</code> 或 <code>update</code> 之前的初始值。如果未指定初始值，则 store 的初始值为 <code>undefined</code>。</p>
<pre><code class="language-ts">// @filename: ambient.d.ts
import { type Writable } from 'svelte/store';

declare global {
  const a: Writable&lt;number&gt;;
}

export {};

// @filename: index.ts
// @errors: 18046 2769 7006
// ---cut---
import { derived } from 'svelte/store';

const delayed = derived(
  a,
  ($a, set) =&gt; {
    setTimeout(() =&gt; set($a), 1000);
  },
  2000
);

const delayedIncrement = derived(a, ($a, set, update) =&gt; {
  set($a);
  setTimeout(() =&gt; update((x) =&gt; x + 1), 1000);
  // 每次 $a 产生一个值时，这个也会产生两个值
  // $a 立即输出然后 $a + 1 一秒后输出
});
</code></pre>
<p>如果你从回调中返回一个函数，它将在以下情况被调用：</p>
<ol>
<li>回调再次运行的时候</li>
<li>最后一个订阅者取消订阅的时候</li>
</ol>
<pre><code class="language-ts">// @filename: ambient.d.ts
import { type Writable } from 'svelte/store';

declare global {
  const frequency: Writable&lt;number&gt;;
}

export {};

// @filename: index.ts
// ---cut---
import { derived } from 'svelte/store';

const tick = derived(
  frequency,
  ($frequency, set) =&gt; {
    const interval = setInterval(() =&gt; {
      set(Date.now());
    }, 1000 / $frequency);

    return () =&gt; {
      clearInterval(interval);
    };
  },
  2000
);
</code></pre>
<p>在这两种情况下，可以将一个参数数组作为第一个参数传递，而不是单个 store 。</p>
<pre><code class="language-ts">// @filename: ambient.d.ts
import { type Writable } from 'svelte/store';

declare global {
  const a: Writable&lt;number&gt;;
  const b: Writable&lt;number&gt;;
}

export {};

// @filename: index.ts

// ---cut---
import { derived } from 'svelte/store';

const summed = derived([a, b], ([$a, $b]) =&gt; $a + $b);

const delayed = derived([a, b], ([$a, $b], set) =&gt; {
  setTimeout(() =&gt; set($a + $b), 1000);
});
</code></pre>
<h3 id="readonly"><code>readonly</code></h3>
<p>这个简单的辅助函数使得 store 只读。你仍然可以使用这个新的可读 store 订阅原始 store 的变化。</p>
<pre><code class="language-js">import { readonly, writable } from 'svelte/store';

const writableStore = writable(1);
const readableStore = readonly(writableStore);

readableStore.subscribe(console.log);

writableStore.set(2); // console: 2
// @errors: 2339
readableStore.set(2); // ERROR
</code></pre>
<h3 id="get"><code>get</code></h3>
<p>通常，你应该通过订阅 store 并随着时间变化使用其值来读取 store 的值。偶尔，你可能需要检索未订阅的 store 的值。<code>get</code> 允许你这样做。</p>
<blockquote>
<p>[!NOTE] 这样做背后是通过创建一个订阅、读取值、再然后取消订阅来实现的。因此，不建议在频繁使用的代码路径中使用。</p>
</blockquote>
<pre><code class="language-ts">// @filename: ambient.d.ts
import { type Writable } from 'svelte/store';

declare global {
  const store: Writable&lt;string&gt;;
}

export {};

// @filename: index.ts
// ---cut---
import { get } from 'svelte/store';

const value = get(store);
</code></pre>
<h2 id="store-合约">store 合约</h2>
<pre><code class="language-ts">// @noErrors
store = { subscribe: (subscription: (value: any) =&gt; void) =&gt; (() =&gt; void), set?: (value: any) =&gt; void }
</code></pre>
<p>你可以通过实现 <em>store 合约（store contract）</em> 创建自己的 store ，而不依赖于 <a href="https://svelte.yayujs.com/docs/svelte-store" target="_blank" rel="noopener nofollow"><code>svelte/store</code></a>：</p>
<ol>
<li>store 必须包含一个 <code>.subscribe</code> 方法，该方法必须接受一个订阅函数作为参数。此订阅函数必须在调用 <code>.subscribe</code> 时立即和同步地传入 store 的当前值进行调用。无论何时 store 的值发生变化，所有激活的订阅函数都必须被同步调用。</li>
<li><code>.subscribe</code> 方法必须返回一个取消订阅函数。调用取消订阅函数必须停止其订阅，并且 store 不得再次调用其相应的订阅函数。</li>
<li>一个 store 可以 <em>可选的</em> 包含一个 <code>.set</code> 方法，该方法必须接受一个新的 store 值作为参数，并同步调用 store 所有激活的订阅函数。这样的 store 称为 <em>可写的 store（writable store）</em>。</li>
</ol>
<p>为了与 RxJS Observables 互操作性，<code>.subscribe</code> 方法也可以返回一个带有 <code>.unsubscribe</code> 方法的对象，而不是直接返回取消订阅函数。但请注意，除非 <code>.subscribe</code> 同步调用订阅（这是 Observable 规范中并不要求），否则 Svelte 会将 store 的值视为 <code>undefined</code>，直到它这样做。</p>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>本篇已收录在掘金专栏 <a href="https://juejin.cn/column/7459299646696374284" target="_blank" rel="noopener nofollow">《Svelte 中文文档》</a>，该系列预计 40 篇。</p>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上前端大佬成长之路。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="16.057321555480325" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-21 10:54">2025-02-21 10:53</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18728843" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18728843);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18728843', targetLink: 'https://www.cnblogs.com/yayujs/p/18728843/svelte-stores', title: 'Svelte 最新中文文档教程（15）—— Stores' })">举报</a>
</div>
        