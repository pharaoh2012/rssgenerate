
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dtux/p/18691833" title="发布于 2025-01-26 15:11">
    <span role="heading" aria-level="2">React中的数据流管理</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>我们是<a href="http://ued.dtstack.cn/" target="_blank" rel="noopener nofollow">袋鼠云数栈 UED 团队</a>，致力于打造优秀的一站式数据中台产品。我们始终保持工匠精神，探索前端道路，为社区积累并传播经验价值。</p>
</blockquote>
<blockquote>
<p>本文作者：霜序</p>
</blockquote>
<h2 id="前言">前言</h2>
<blockquote>
<p>💡 为什么数据流管理重要？<br>
React 的核心思想为：UI=render(data) ，data 就是所谓的数据，render 是 React 提供的纯函数，所以 UI 展示完全由数据层决定。</p>
</blockquote>
<p>在本文中，会简单介绍 React 中的数据流管理，从自身的 context 到三方库的 redux 的相关概念，以及 redux 附属内容丐版实现。</p>
<p>在正文之前，先简单介绍<strong>数据</strong>和<strong>状态</strong>的概念。React 是利用可复用的组件来构建界面，组件本质上是有限状态机，能够记住当前组件的状态，根据不同的状态变化做出相关的操作。在React中，把这种状态定义为 <code>state</code> 。通过管理状态来实现对组件的管理，当 <code>state</code> 发生改变时，React 会自动去执行相应的操作。</p>
<p>而数据，它不仅指 server 层返回给前端的数据，React 中的状态也是一种数据。当数据改变时，我们需要改变状态去引发界面的变更。</p>
<h2 id="react自身的数据流方案">React自身的数据流方案</h2>
<h3 id="基于props的单向数据流">基于Props的单向数据流</h3>
<p>React 是自上而下的单向数据流，容器组件&amp;展示组件是最常见的 React 组件设计方案。容器组件负责处理复杂的业务逻辑和数据，展示组件负责处理 UI 层。通常我们会把展示组件抽出来复用或者组件库的封装，容器组件自身通过 state 来管理状态，setState 更新状态，从而更新 UI ，通过 props 将自身的 state 传递给展示组件实现通信</p>
<p><img src="https://img2024.cnblogs.com/other/2332333/202501/2332333-20250126151131388-1390973151.png" alt="file" loading="lazy"></p>
<p>对于简单的通信，基于 <code>props</code> 串联父子和兄弟组件是很灵活的。</p>
<p>但对于嵌套深数据流组件，A→B→C→D→E，A 的数据需要传递给 E 使用，那么我们需要在 B/C/D 的 <code>props</code> 都加上该数据，导致最为中间组件的 B/C/D 来说会引入一些不属于自己的属性</p>
<h3 id="使用-context-api-维护全局状态">使用 Context API 维护全局状态</h3>
<p>Context API 是 React 官方提供的一种组件树全局通信方式</p>
<p><code>Context</code> 基于生产者-消费者模式，对应 React 中的三个概念:  <strong>React.createContext</strong> 、 <strong>Provider</strong>、 <strong>Consumer</strong> 。通过调用 <code>createContext</code> 创建出一组 <code>Provider</code> 。<code>Provider</code> 作为数据的提供方，可以将数据下发给自身组件树中的任意层级的 <code>Consumer</code> ，而 <strong>Consumer 不仅能够读取到 Provider 下发的数据还能读取到这些数据后续的更新值</strong></p>
<pre><code class="language-jsx">const defaultValue = {
  count: 0,
  increment: () =&gt; {}
};

const ValueContext = React.createContext(defaultValue);

&lt;ValueContext.Provider value={this.state.contextState}&gt;
  &lt;div className="App"&gt;
    &lt;div&gt;Count: {count}&lt;/div&gt;
    &lt;ButtonContainer /&gt;
    &lt;ValueContainer /&gt;
  &lt;/div&gt;
&lt;/ValueContext.Provider&gt;

&lt;ValueContext.Consumer&gt;
  {({ increment }) =&gt; (
    &lt;button onClick={increment} className="button"&gt;increment&lt;/button&gt;
  )}
&lt;/ValueContext.Consumer&gt;
</code></pre>
<p><a href="https://codesandbox.io/s/context-use-before-16-3-318qr2?file=/src/App.js" target="_blank" rel="noopener nofollow">16.3之前的用法</a>，<a href="https://codesandbox.io/s/context-use-after-16-3-j566ro?file=/src/App.js:581-643" target="_blank" rel="noopener nofollow">16.3之后的createContext用法</a>，<a href="https://codesandbox.io/s/context-use-hooks-2l55gw?file=/src/App.js" target="_blank" rel="noopener nofollow">useContext用法</a></p>
<p>Context工作流的简单图解：</p>
<p><img src="https://img2024.cnblogs.com/other/2332333/202501/2332333-20250126151131776-1484936154.png" alt="file" loading="lazy"></p>
<p>在 v16.3 之前由于各种局限性不被推荐使用</p>
<ul>
<li>代码不够简单优雅：生产者需要定义 <code>childContextTypes</code> 和 <code>getChildContext</code> ，消费者需要定义 <code>ChildTypes</code> 才能够访问 <code>this.context</code> 访问到生产者提供的数据</li>
<li>数据无法及时同步：类组件中可以使用 <code>shouldComponentUpdate</code> 返回 false 或者是 <code>PureComponent</code> ，后代组件都不会被更新，这违背了 Context 模式的设置，导致生产者和消费者之间不能及时同步</li>
</ul>
<p>在 v16.3 之后的版本中做了对应的调整，即使组件的 <code>shouldComponentUpdate</code> 返回 false ，它仍然可以”穿透”组件继续向后代组件进行传播，更改了声明方式变得更加语义化，使得 Context 成为了一种可行的通信方案</p>
<p>但是 Context 的也是通过一个容器组件来管理状态的，但是 <code>Consumer</code> 和 <code>Provider</code> 是一一对应的，在项目复杂度高的时候，可能会出现多个 <code>Provider</code> 和<code>Consumer</code> ，甚至一个 <code>Consumer</code> 需要对应多个 <code>Provider</code> 的情况</p>
<p>当某个组件的业务逻辑变得非常复杂时，代码会越写越多，因为我们只能够在组件内部去控制数据流，这样导致 Model 和 View 都在 View 层，业务逻辑和 UI 实现都在一块，难以维护</p>
<p>所以这个时候需要真正的数据流管理工具，从 UI 层完全抽离出来，只负责管理数据，让 React 只专注于 View 层的绘制</p>
<h2 id="redux">Redux</h2>
<p>Redux 是 <strong>JS应用</strong> 的状态容器，提供可预测的状态管理</p>
<p>Redux 的三大原则</p>
<ul>
<li>单一数据源：整个应用的 state 都存储在一棵树上，并且这棵状态树只存在于唯一的 store 中</li>
<li>state 是只读的：对 state 的修改只有触发 action</li>
<li>用纯函数执行修改：reducer 根据旧状态和传进来的 action 来生成一个新的 state (类似于 reduce 的思想，接受上一个 state 和当前项 action ，计算出来一个新值)</li>
</ul>
<p>Redux工作流</p>
<p><img src="https://img2024.cnblogs.com/other/2332333/202501/2332333-20250126151132643-2029082273.png" alt="file" loading="lazy"></p>
<p><strong>不可变性( Immutability )</strong></p>
<p>mutable 意为可改变的，immutability 意为用不可改变的</p>
<p>在JS的对象( object )和数组( array )默认都是 mutable，创建一个对象/数组都是可以改变内容</p>
<pre><code class="language-javascript">const obj = { name: 'FBB', age: 20 };
obj.name = 'shuangxu';

const arr = [1,2,3];
arr[1] = 6;
arr.push('change');
</code></pre>
<p>改变对象或者数组，内存中的引用地址尚未改变，但是内容已经改变</p>
<p>如果想用不可变的方式来更新，代码必须复制原来的对象/数组，更新它的复制体</p>
<pre><code class="language-javascript">const obj = { info: { name: 'FBB', age: 20 }, phone: '177xxx' }
const cloneObj = { ...obj, info: { name: 'shuangxu' } }

//浅拷贝、深拷贝
</code></pre>
<p><strong>Redux期望所有的状态都采用不可变的方式。</strong></p>
<h3 id="react-redux">react-redux</h3>
<p>react-redux 是 Redux 提供的 react 绑定，辅助在 react 项目中使用 redux</p>
<p>它的 API 简单，包括一个组件 <code>Provider</code> 和一个高阶函数 <code>connect</code></p>
<h4 id="provider">Provider</h4>
<p>❓为什么 <code>Provider</code> 只传递一个 <code>store</code> ，被它包裹的组件都能够访问到 <code>store</code> 的数据呢？</p>
<p>Provider 做了些啥？</p>
<ul>
<li>创建一个 <code>contextValue</code> 包含 <code>redux</code> 传入的 <code>store</code> 和根据 <code>store</code> 创建出的 <code>subscription</code> ，发布订阅均为 <code>subscription</code> 做的</li>
<li>通过 <code>context</code> 上下文把<code>contextValue</code>传递子组件</li>
</ul>
<h4 id="connect">Connect</h4>
<p>❓connect 做了什么事情讷？</p>
<p>使用容器组件通过 <code>context</code> 提供的 <code>store</code> ，并将 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 返回的 <code>state</code> 和 <code>dispatch</code> 传递给 UI 组件</p>
<p>组件依赖 redux 的 <code>state</code> ，映射到容器组件的 <code>props</code> 中，<code>state</code> 改变时触发容器组件的 <code>props</code> 的改变，触发容器组件组件更新视图</p>
<pre><code class="language-javascript">const enhancer = connect(mapStateToProps, mapDispatchToProps)
enhancer(Component)
</code></pre>
<h4 id="react-redux丐版实现">react-redux丐版实现</h4>
<p><strong>Provider</strong></p>
<pre><code class="language-jsx">export const Provider = (props) =&gt; {
  const { store, children, context } = props;
  const contextValue = { store };
  const Context = context || ReactReduxContext;
  return &lt;Context.Provider value={contextValue}&gt;{children}&lt;/Context.Provider&gt;
};
</code></pre>
<p><strong>connect</strong></p>
<pre><code class="language-tsx">import { useContext, useReducer } from "react";
import { ReactReduxContext } from "./ReactReduxContext";

export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (
  WrappedComponent
) =&gt; (props) =&gt; {
  const { ...wrapperProps } = props;
  const context = useContext(ReactReduxContext);
  const { store } = context; // 解构出store
  const state = store.getState(); // 拿到state
  //使用useReducer得到一个强制更新函数
  const [, forceComponentUpdateDispatch] = useReducer((count) =&gt; count + 1, 0);
  // 订阅state的变化，当state变化的时候执行回调
  store.subscribe(() =&gt; {
    forceComponentUpdateDispatch();
  });
  // 执行mapStateToProps和mapDispatchToProps
  const stateProps = mapStateToProps?.(state);
  const dispatchProps = mapDispatchToProps?.(store.dispatch);
  // 组装最终的props
  const actualChildProps = Object.assign(
    {},
    stateProps,
    dispatchProps,
    wrapperProps
  );
  return &lt;WrappedComponent {...actualChildProps} /&gt;;
};
</code></pre>
<h3 id="redux-middleware">redux Middleware</h3>
<blockquote>
<p>“It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.” – Dan Abramov</p>
</blockquote>
<p><code>middleware</code> 提供分类处理 <code>action</code> 的机会，在 <code>middleware</code> 中可以检查每一个 <code>action</code> ，挑选出特定类型的 <code>action</code> 做对应操作</p>
<p><img src="https://img2024.cnblogs.com/other/2332333/202501/2332333-20250126151132975-1304899671.png" alt="file" loading="lazy"></p>
<p><a href="https://codesandbox.io/s/middleware-wn4pn?file=/src/App.js" target="_blank" rel="noopener nofollow">middleware示例</a></p>
<p>打印日志</p>
<pre><code class="language-jsx">store.dispatch = (action) =&gt; {
  console.log("this state", store.getState());
  console.log(action);
  next(action);
  console.log("next state", store.getState());
};
</code></pre>
<p>监控错误</p>
<pre><code class="language-jsx">store.dispatch = (action) =&gt; {
  try {
    next(action);
  } catch (err) {
    console.log("catch---", err);
  }
};
</code></pre>
<p>二者合二为一</p>
<pre><code class="language-jsx">store.dispatch = (action) =&gt; {
  try {
    console.log("this state", store.getState());
    console.log(action);
    next(action);
    console.log("next state", store.getState());
  } catch (err) {
    console.log("catch---", err);
  }
};
</code></pre>
<p>提取 loggerMiddleware/catchMiddleware</p>
<pre><code class="language-jsx">const loggerMiddleware = (action) =&gt; {
  console.log("this state", store.getState());
  console.log("action", action);
  next(action);
  console.log("next state", store.getState());
};
const catchMiddleware = (action) =&gt; {
  try {
    loggerMiddleware(action);
  } catch (err) {
    console.error("错误报告: ", err);
  }
};
store.dispatch = catchMiddleware
</code></pre>
<p>catchMiddleware 中都写死了，调用 loggerMiddleware ，loggerMiddleware 中写死了 next(store.dispatch) ，需要灵活运用，让 middleware 接受 dispatch 参数</p>
<pre><code class="language-jsx">const loggerMiddleware = (next) =&gt; (action) =&gt; {
  console.log("this state", store.getState());
  console.log("action", action);
  next(action);
  console.log("next state", store.getState());
};
const catchMiddleware = (next) =&gt; (action) =&gt; {
  try {
    /*loggerMiddleware(action);*/
    next(action);
  } catch (err) {
    console.error("错误报告: ", err);
  }
};
/*loggerMiddleware 变成参数传进去*/
store.dispatch = catchMiddleware(loggerMiddleware(next));
</code></pre>
<p>middleware中接受一个store，就能够把上面的方法提取到单独的函数文件中</p>
<pre><code class="language-jsx">export const catchMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {
  try {
    next(action);
  } catch (err) {
    console.error("错误报告: ", err);
  }
};

export const loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {
  console.log("this state", store.getState());
  console.log("action", action);
  next(action);
  console.log("next state", store.getState());
};

const logger = loggerMiddleware(store);
const exception = catchMiddleware(store);
store.dispatch = exception(logger(next));
</code></pre>
<p>每个 middleware 都需要接受 store 参数，继续优化这个调用函数</p>
<pre><code class="language-javascript">export const applyMiddleware = (middlewares) =&gt; {
  return (oldCreateStore) =&gt; {
    return (reducer, initState) =&gt; {
      //获得老的store
      const store = oldCreateStore(reducer, initState);
      //[catch, logger]
      const chain = middlewares.map((middleware) =&gt; middleware(store));
      let oldDispatch = store.dispatch;
      chain
        .reverse()
        .forEach((middleware) =&gt; (oldDispatch = middleware(oldDispatch)));
      store.dispatch = oldDispatch;
      return store;
    };
  };
};

const newStore = applyMiddleware([catchMiddleware, loggerMiddleware])(
  createStore
)(rootReducer);
</code></pre>
<p>Redux 提供了 <code>applyMiddleware</code> 来加载 <code>middleware</code> ，<code>applyMiddleware</code> 接受三个参数，<code>middlewares</code> 数组 / <code>redux</code> 的 <code>createStore</code> / <code>reducer</code></p>
<pre><code class="language-jsx">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (reducer, ...args) =&gt; {
    //由createStore和reducer创建store
    const store = createStore(reducer, ...args) 
    let dispatch = store.dispatch
    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) =&gt; dispatch(action, ...args)
    }
    //把getState/dispatch传给middleware，
    //map让每个middleware获得了middlewareAPI参数
    //形成一个chain匿名函数数组[f1,f2,f3...fn]
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    //dispatch=f1(f2(f3(store.dispatch)))，把所有  的middleware串联起来
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>applyMiddleware 符合洋葱模型</p>
<p><img src="https://img2024.cnblogs.com/other/2332333/202501/2332333-20250126151133720-2086869257.png" alt="file" loading="lazy"></p>
<h2 id="总结">总结</h2>
<p>本文意在讲解 react 的数据流管理。从 react 本身的提供的数据流方式出发</p>
<ol>
<li>基于 <code>props</code> 的单向数据流，串联父子和兄弟组件非常灵活，但是对于嵌套过深的组件，会使得中间组件都加上不需要的 <code>props</code> 数据</li>
<li>使用 Context 维护全局状态，介绍了 v16.3 之前、v16.3之后的hooks ，不同版本 <code>context</code> 的使用，以及 v16.3 之前版本的 <code>context</code> 的弊端。</li>
<li>引入 redux ，第三方的状态容器，以及 react-redux API ( Provider/connect )分析与丐版实现，最后介绍了 redux 强大的中间件是如何重写 dispatch 方法</li>
</ol>
<h2 id="参考连接">参考连接</h2>
<ul>
<li><a href="https://github.com/sunyongjian/blog/issues/36" target="_blank" rel="noopener nofollow">对 React 状态管理的理解及方案对比</a></li>
<li><a href="https://juejin.cn/post/6844903566381940744" target="_blank" rel="noopener nofollow">聊一聊我对 React Context 的理解以及应用</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener nofollow">redux middleware 详解</a></li>
<li><a href="http://dennisgo.cn/Articles/React/React-Redux.html" target="_blank" rel="noopener nofollow">手写 react-redux</a></li>
</ul>
<h3 id="最后">最后</h3>
<p>欢迎关注【袋鼠云数栈UED团队】~<br>
袋鼠云数栈 UED 团队持续为广大开发者分享技术成果，相继参与开源了欢迎 star</p>
<ul>
<li><strong><a href="https://dtstack.github.io/Taier/" target="_blank" rel="noopener nofollow">大数据分布式任务调度系统——Taier</a></strong></li>
<li><strong><a href="https://dtstack.github.io/molecule/" target="_blank" rel="noopener nofollow">轻量级的 Web IDE UI 框架——Molecule</a></strong></li>
<li><strong><a href="https://dtstack.github.io/monaco-sql-languages/" target="_blank" rel="noopener nofollow">针对大数据领域的 SQL Parser 项目——dt-sql-parser</a></strong></li>
<li><strong><a href="https://github.com/DTStack/code-review-practices" target="_blank" rel="noopener nofollow">袋鼠云数栈前端团队代码评审工程实践文档——code-review-practices</a></strong></li>
<li><strong><a href="https://github.com/DTStack/ko" target="_blank" rel="noopener nofollow">一个速度更快、配置更灵活、使用更简单的模块打包器——ko</a></strong></li>
<li><strong><a href="https://github.com/DTStack/ant-design-testing" target="_blank" rel="noopener nofollow">一个针对 antd 的组件测试工具库——ant-design-testing</a></strong></li>
</ul>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.2184499141597223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 15:12">2025-01-26 15:11</span>&nbsp;
<a href="https://www.cnblogs.com/dtux">袋鼠云数栈前端</a>&nbsp;
阅读(<span id="post_view_count">59</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18691833" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18691833);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18691833', targetLink: 'https://www.cnblogs.com/dtux/p/18691833', title: 'React中的数据流管理' })">举报</a>
</div>
	