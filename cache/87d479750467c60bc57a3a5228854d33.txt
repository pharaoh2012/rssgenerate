
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Xin-Code9/p/18711095" title="发布于 2025-02-12 11:39">
    <span role="heading" aria-level="2">Linux驱动---/sys接口</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文介绍通过 sysfs 实现 LED 驱动的方法。利用 led_classdev_register 注册 LED 设备，在 /sys/class/leds/ 创建文件，实现用户空间对 LED 的控制
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#一伪文件-sys" rel="noopener nofollow">一、伪文件 sys</a></li><li><a href="#二led_classdev结构体" rel="noopener nofollow">二、led_classdev结构体</a></li><li><a href="#三注册注销led" rel="noopener nofollow">三、注册/注销LED</a><ul><li><a href="#31led_classdev_register-函数" rel="noopener nofollow">3.1、led_classdev_register 函数</a></li><li><a href="#32led_classdev_unregister-函数" rel="noopener nofollow">3.2、led_classdev_unregister 函数</a></li></ul></li><li><a href="#四sys接口实现" rel="noopener nofollow">四、/sys接口实现</a><ul><li><a href="#41编写驱动程序" rel="noopener nofollow">4.1、编写驱动程序</a></li><li><a href="#42驱动安装测试" rel="noopener nofollow">4.2、驱动安装测试</a></li></ul></li></ul></div><p></p>
<h1 id="一伪文件-sys">一、伪文件 sys</h1>
<p>伪文件（Pseudo File） 是 Linux 系统中一种特殊的文件，<strong>它不占用物理存储空间</strong>，而是<strong>由内核或系统动态生成，用于提供某种特定的功能或信息</strong>。我们本篇文章所整理的 /sys 便是伪文件，它提供了内核对象（如设备、驱动、总线）的属性和状态信息。<br>
<br>
在上篇<a href="https://www.cnblogs.com/Xin-Code9/p/18709520" target="_blank">LED驱动</a>文章中，我们通过在 /dev 下创建设备节点，提供了用户空间访问硬件设备的入口。不过这种情况下，用户只能通过open()、read()、write（）等函数编程来操作设备。而 /sys 下的文件是内核为用户空间提供的高级抽象接口，直接读写文件（如cat、echo等）会触发内核中对应的回调函数，完成配置或信息获取。<br>
<br>
这样，当我们回顾以前的知识就会发现，在学习Linux下的GPIO操作时为什么有 libgpiod 和 sysfs 两种操作方式，其实就是一直是通过编程操作 /dev 的设备，另一种是直接通过命令行操作 /sys 的设备。</p>
<h1 id="二led_classdev结构体">二、led_classdev结构体</h1>
<p>每个 LED 设备在内核中通过一个 led_classdev 结构体来表示。这个结构体包含了 LED 设备的各种属性和控制函数，例如亮度设置函数、最大亮度等，定义如下（只整理了常见部分）：</p>
<pre><code>struct led_classdev
{
  	const char		*name;                       // 设备名字
	enum led_brightness	 brightness;             // LED 默认亮度
	enum led_brightness	 max_brightness;         // LED 的最大亮度

    // 用于设置 LED 亮度的函数指针，不可休眠
    void    (*brightness_set)(struct led_classdev *led_cdev, enum led_brightness brightness);

    //用于设置 LED 亮度的函数指针，可以休眠
    int     (*brightness_set_blocking)(struct led_classdev *led_cdev, enum led_brightness brightness);
  
    struct device	    *dev;
    const char		    *default_trigger;
}
</code></pre>
<p><br>
（1）name：表示设备名字；<br>
<br>
（2）brightness和max_brightness：这两个成员都是枚举类型 enum led_brightness 的变量，一个表示 LED 的初始化亮度，一个表示 LED 的最大亮度，这个枚举 类型定义了 LED 的亮度等级，来看看这个枚举类型：</p>
<pre><code>enum led_brightness {
	LED_OFF		= 0,
	LED_ON		= 1,
	LED_HALF	= 127,
	LED_FULL	= 255,
};
</code></pre>
<p><br>
（3）default_trigger：该属性设置LED灯的默认动作，比如：</p>
<pre><code>backlight：LED灯作为背光。

default-on：LED灯打开

heartbeat：LED灯作为心跳指示灯，可以作为系统运行提示灯。

ide-disk：LED灯作为硬盘活动指示灯。

timer：LED灯周期性闪烁，由定时器驱动，闪烁频率可以修改
</code></pre>
<p><br>
（4）brightness_set：绑定 LED 亮度设置函数（不可休眠）；<br>
<br>
（5）brightness_set_blocking：绑定 LED 亮度设置函数（可以休眠）；</p>
<h1 id="三注册注销led">三、注册/注销LED</h1>
<h2 id="31led_classdev_register-函数">3.1、led_classdev_register 函数</h2>
<p>该函数将一个 LED 设备注册到 LED 子系统中，使其可以通过内核提供的统一接口进行操作。为 LED 设备初始化一些默认的属性，如亮度（brightness）、最大亮度（max_brightness）、触发器（trigger）等。同时在 /sys/class/leds/ 目录下为注册的 LED 设备创建一个对应的设备文件，用户可以通过该文件对 LED 进行操作。</p>
<pre><code>int led_classdev_register(struct device *parent, struct led_classdev *led_cdev);
//parent：指向父设备的指针。通常为 NULL，表示该 LED 设备没有父设备。如果提供了父设备，则 LED 设备会与父设备关联。
//led_cdev：指向 led_classdev 结构体的指针，该结构体包含了 LED 设备的相关信息，如名称、亮度设置函数、最大亮度等。
//成功时返回 0。失败时返回负的错误码.
</code></pre>
<h2 id="32led_classdev_unregister-函数">3.2、led_classdev_unregister 函数</h2>
<p>该函数用于从 LED 子系统中注销一个之前注册的 LED 设备。删除 /sys/class/leds/ 目录下对应的设备文件。释放与该 LED 设备相关的内核资源。</p>
<pre><code>void led_classdev_unregister(struct led_classdev *led_cdev);
//led_cdev：指向之前通过 led_classdev_register 注册的 led_classdev 结构体的指针。
功能
</code></pre>
<h1 id="四sys接口实现">四、/sys接口实现</h1>
<h2 id="41编写驱动程序">4.1、编写驱动程序</h2>
<p>在上一篇文章中，我们通过注册字符设备，在<code>/dev</code>下创建设备节点，从而实现了用户空间通过编程对硬件进行操作。接下来在这里将通过<code>/sys</code>接口实现用户通过命令行直接操作硬件设备。代码如下（设备树文件参考上篇文章，这里没有做修改）：</p>
<pre><code>//vim ldv2.c

#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;   
#include &lt;linux/fs.h&gt;       
#include &lt;linux/errno.h&gt;    
#include &lt;linux/types.h&gt;   
#include &lt;linux/cdev.h&gt;   
#include &lt;linux/slab.h&gt;     
#include &lt;linux/version.h&gt;  
#include &lt;linux/uaccess.h&gt;  
#include &lt;linux/device.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/leds.h&gt;

struct leds_desc
{
    struct led_classdev dev;     /* dev for led_classdev_register() */
    struct gpio_desc   *gpio;    /* gpio instance for this led */
    char                name[8]; /* led name in /sys/class/leds */
};

struct led_priv
{
    int                 nleds; /* number of leds */
    struct leds_desc   *leds;  /* leds array */
};

struct led_priv *priv;

static void led_brightness_set(struct led_classdev *dev, enum led_brightness brightness)
{
    struct leds_desc *led = container_of(dev, struct leds_desc, dev);

    gpiod_set_value_cansleep(led-&gt;gpio, brightness?1:0 );
}

static int led_probe(struct platform_device *pdev)
{
    struct device *dev = &amp;pdev-&gt;dev;
    struct leds_desc *led;
    int ret, i;

    /* allocate memory for private data structure */
    priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;

    /* parser the number of LEDs from the device tree */
    priv-&gt;nleds = gpiod_count(dev, NULL);
    if ( priv-&gt;nleds &lt; 1) {
        dev_err(dev, "Failed to read leds gpio from device tree\n");
        return -EINVAL;
    }
    dev_info(dev, "led driver probe for %d leds from device tree\n", priv-&gt;nleds);

    /* allocate memory for all the leds */
    priv-&gt;leds = devm_kzalloc(dev, priv-&gt;nleds*sizeof(*priv-&gt;leds), GFP_KERNEL);
    if( !priv-&gt;leds )
        return -ENOMEM;

    /* parser and request GPIO pins from the device tree */
    for (i = 0; i &lt; priv-&gt;nleds; i++) {
        priv-&gt;leds[i].gpio = devm_gpiod_get_index(dev, NULL, i, GPIOD_ASIS);
        if (IS_ERR(priv-&gt;leds[i].gpio))
            return PTR_ERR(priv-&gt;leds[i].gpio);

        /* set GPIO as output mode and default off */
        gpiod_direction_output(priv-&gt;leds[i].gpio, 0);
    }

    /* create sysfs file for each led */
    for (i = 0; i &lt; priv-&gt;nleds; i++) {
        led = priv-&gt;leds+i;
        snprintf(led-&gt;name, sizeof(led-&gt;name), "led%d", i);

        led-&gt;dev.name = led-&gt;name;
        led-&gt;dev.brightness_set = led_brightness_set;
        ret = led_classdev_register(dev, &amp;led-&gt;dev);
        if (ret) {
            dev_err(dev, "Failed to register LED[%d]\n", i);
            goto failed_destroy;
        }
    }

    platform_set_drvdata(pdev, priv);
    return 0;

failed_destroy:
    for (--i; i &gt;= 0; i--)
        led_classdev_unregister(&amp;priv-&gt;leds[i].dev);

    return ret;
}

static int led_remove(struct platform_device *pdev)
{
    struct led_priv *priv = platform_get_drvdata(pdev);
    int i;

    for (i = 0; i &lt; priv-&gt;nleds; i++) {
        led_classdev_unregister(&amp;priv-&gt;leds[i].dev);
    }

    dev_info(&amp;pdev-&gt;dev, "led driver removed.\n");
    return 0;
}

static const struct of_device_id led_of_match[] = {
    { .compatible = "rgb,leds", },
    { /* sentinel */ },
};
MODULE_DEVICE_TABLE(of, led_of_match);

static struct platform_driver led_driver = {
    .probe = led_probe,
    .remove = led_remove,
    .driver = {
        .name = "leds",
        .of_match_table = led_of_match,
    },
};

module_platform_driver(led_driver);

MODULE_LICENSE("GPL");
</code></pre>
<p><br>
<code>Makefile</code>文件如下：</p>
<pre><code>ARCH ?= arm
CROSS_COMPILE ?= /opt/gcc-aarch32-10.3-2021.07/bin/arm-none-linux-gnueabihf-
KERNAL_DIR ?= ~/igkboard-imx6ull/bsp/kernel/linux-imx/

PWD :=$(shell pwd)

obj-m += ledv2.o

modules:
    $(MAKE) ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C $(KERNAL_DIR) M=$(PWD) modules
    @make clear

clear:
    @rm -f *.o *.cmd *.mod *.mod.c
    @rm -rf *~ core .depend .tmp_versions Module.symvers modules.order -f
    @rm -f .*ko.cmd .*.o.cmd .*.o.d
    @rm -f *.unsigned

clean:
    @rm -f *.ko
</code></pre>
<pre><code>make
</code></pre>
<h2 id="42驱动安装测试">4.2、驱动安装测试</h2>
<p>将编译后的<code>ledv2.ko</code>下载到开发板上，并进行安装：</p>
<pre><code>insmod ledv2.ko
</code></pre>
<p><br>
在新的驱动中，我们并没有注册字符设备，所以 /dev/ 下并不会产生新的设备文件，而在 /sys/class/leds 路径下出现了我们的三个 Led 设备文件。</p>
<pre><code>ls /dev/led*
  ls: cannot access '/dev/led*': No such file or directory

ls /sys/class/leds/
  led0  led1  led2  mmc0::  mmc1::

ls /sys/class/leds/led1/
  brightness  device  max_brightness  power  subsystem  trigger  uevent
</code></pre>
<p><br>
接下来我们使用 echo 命令就可以控制相应 Led 亮灭了。</p>
<pre><code>echo 1 &gt; /sys/class/leds/led1/brightness
//效果：绿灯亮
echo 0 &gt; /sys/class/leds/led1/brightness
//效果：绿灯灭
</code></pre>
<p><br>
从上面 Led 驱动程序编写过程中我们了解到，要实现一个设备的驱动供应用程序空间使用，可以有多种不同的实现方式。如果我们想要容易编程控制，则可以使用常规的字符设备驱动通过调用 ioctl() 系统调用实现；而如果想要在命令行或Shell脚本中直接实现，则我们可以使用 /sys/class 伪文件系统来实现。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.025803226623842594" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 11:40">2025-02-12 11:39</span>&nbsp;
<a href="https://www.cnblogs.com/Xin-Code9">小信嵌梦</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18711095" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18711095);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18711095', targetLink: 'https://www.cnblogs.com/Xin-Code9/p/18711095', title: 'Linux驱动---/sys接口' })">举报</a>
</div>
        