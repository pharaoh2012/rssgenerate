
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18835155" title="发布于 2025-04-19 09:56">
    <span role="heading" aria-level="2">『Plotly实战指南』--布局进阶篇</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在数据可视化领域，<code>Plotly</code>的<strong>子图布局</strong>是打造专业级仪表盘的核心武器。</p>
<p>当面对多维数据集时，合理的子图布局能显著提升多数据关联分析效率，让数据的呈现更加直观和美观。</p>
<p>本文将深入探讨<code>Plotly</code>中子图布局技巧，并结合代码实现与实际场景案例，介绍多子图组织方法的技巧。</p>
<h1 id="多子图布局">多子图布局</h1>
<h2 id="网格布局">网格布局</h2>
<p><strong>网格布局</strong>是<code>Plotly</code>中实现多子图排列的一种常见方式，通过<code>make_subplots</code>函数，我们可以轻松创建行列对齐的子图。</p>
<p>例如，设置<code>rows=2, cols=3</code>，就可以生成一个<strong>2行3列</strong>的子图网格，这种方式的好处是子图的尺寸会自动分配，</p>
<p>而且我们还可以通过<code>horizontal_spacing</code>和<code>vertical_spacing</code>参数来调整子图之间的水平和垂直间距，从而让整个布局更加紧凑和美观。</p>
<pre><code class="language-python">from plotly.subplots import make_subplots
import plotly.graph_objects as go

fig = make_subplots(rows=2, cols=3, horizontal_spacing=0.2, vertical_spacing=0.2)

fig.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 5, 6]), row=1, col=1)
fig.add_trace(go.Scatter(x=[20, 30, 40], y=[50, 60, 70]), row=1, col=2)
fig.add_trace(go.Scatter(x=[300, 400, 500], y=[600, 700, 800]), row=1, col=3)
fig.add_trace(go.Scatter(x=[4000, 5000, 6000], y=[7000, 8000, 9000]), row=2, col=1)
fig.add_trace(
    go.Scatter(x=[50000, 60000, 70000], y=[80000, 90000, 100000]), row=2, col=2
)
fig.add_trace(
    go.Scatter(x=[600000, 700000, 800000], y=[900000, 1000000, 1100000]), row=2, col=3
)

fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202504/83005-20250419095459901-958627606.png" alt="" loading="lazy"></p>
<h2 id="自由布局">自由布局</h2>
<p><strong>自由布局</strong>则给予了我们更大的灵活性，通过<code>domain</code>参数，我们可以手动设置子图的位置，即指定子图在图表中的<code>x</code>和<code>y</code>坐标范围。</p>
<p>这种方式非常适合实现一些非对齐排列的子图布局，比如主图与缩略图的组合。</p>
<p>我们可以将主图放在较大的区域，而将缩略图放在角落，通过这种方式来辅助展示数据的局部细节。</p>
<pre><code class="language-python"># 自由布局

import plotly.graph_objects as go

# 自由布局示例
fig_free = go.Figure()

# 添加第一个子图
fig_free.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 5, 6], name="Trace 1"))

# 添加第二个子图
fig_free.add_trace(go.Scatter(x=[20, 30, 40], y=[50, 60, 70], name="Trace 2"))

# 更新布局，定义每个子图的domain
fig_free.update_layout(
    xaxis=dict(domain=[0, 0.7]),  # 第一个子图占据左侧70%
    yaxis=dict(domain=[0, 1]),    # 第一个子图占据整个高度
    xaxis2=dict(domain=[0.7, 1], anchor="y2"),  # 第二个子图占据右侧30%
    yaxis2=dict(domain=[0.5, 1], anchor="x2")   # 第二个子图在右侧上方
)

# 更新每个trace的坐标轴引用
fig_free.update_traces(xaxis="x1", yaxis="y1", selector={"name": "Trace 1"})
fig_free.update_traces(xaxis="x2", yaxis="y2", selector={"name": "Trace 2"})

fig_free.show()

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202504/83005-20250419095459910-556022195.png" alt="" loading="lazy"></p>
<h2 id="子图共享坐标轴">子图共享坐标轴</h2>
<p>在多子图的情况下，<strong>共享坐标轴</strong>是一个非常实用的功能，通过设置<code>shared_xaxes=True</code>或<code>shared_yaxes=True</code>，可以让多个子图在同一个坐标轴上进行联动。</p>
<p>这样，当我们在一个子图上进行缩放或平移操作时，其他共享相同坐标轴的子图也会同步更新，从而方便我们进行多数据的对比分析。</p>
<p>此外，当遇到不同量纲的数据时，我们还可以通过<code>secondary_y=True</code>来独立控制次坐标轴，避免因量纲冲突而导致图表显示不清晰。</p>
<pre><code class="language-python">fig = make_subplots(
    rows=2,
    cols=1,
    shared_xaxes=True,
    specs=[[{"secondary_y": True}], [{}]],
)

fig.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 5, 6]), row=1, col=1)
fig.add_trace(go.Scatter(x=[1, 2, 3], y=[40, 50, 60]), row=1, col=1, secondary_y=True)
fig.add_trace(go.Scatter(x=[1, 2, 3], y=[7, 8, 9]), row=2, col=1)

fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202504/83005-20250419095459912-1884070786.gif" alt="" loading="lazy"></p>
<h1 id="实战案例">实战案例</h1>
<p>下面两个案例根据实际情况简化而来，主要演示布局如何在实际项目中使用。</p>
<h2 id="股票多指标分析仪表盘">股票多指标分析仪表盘</h2>
<p>示例中先构造一些模拟数据，然后采用3行1列的布局模式来显示不同的股票信息。</p>
<pre><code class="language-python">import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd

# 模拟股票数据
df = pd.DataFrame(
    {
        "date": pd.date_range(start="2023-01-01", periods=100),
        "price": [100 + i * 0.5 + (i % 10) * 2 for i in range(100)],
        "volume": [5000 + i * 10 + abs(i % 20 - 10) * 100 for i in range(100)],
        "rsi": [50 + i % 15 - 7.5 for i in range(100)],
    }
)

# 1. 创建3行1列的子图布局
fig = make_subplots(
    rows=3,
    cols=1,
    shared_xaxes=True,  # 共享x轴
    vertical_spacing=0.05,  # 子图间距
    subplot_titles=("价格趋势", "成交量", "RSI 指标"),
)

# 2. 添加价格走势图
fig.add_trace(
    go.Candlestick(
        x=df["date"],
        open=df["price"] * 0.99,
        high=df["price"] * 1.02,
        low=df["price"] * 0.98,
        close=df["price"],
        name="股票价格",
    ),
    row=1,
    col=1,
)

# 3. 添加成交量柱状图
fig.add_trace(
    go.Bar(x=df["date"], y=df["volume"], name="成交量", marker_color="lightgray"),
    row=2,
    col=1,
)

# 4. 添加RSI指标图
fig.add_trace(
    go.Scatter(x=df["date"], y=df["rsi"], name="RSI", line=dict(color="blue")),
    row=3,
    col=1,
)

# 5. 更新布局设置
fig.update_layout(
    title_text="多指标仪表盘",
    height=800,
    margin=dict(l=20, r=20, t=80, b=20),
    # 主图坐标轴配置
    xaxis=dict(domain=[0, 1], rangeslider_visible=False),
    # 成交量图坐标轴
    xaxis2=dict(domain=[0, 1], matches="x"),
    # RSI图坐标轴
    xaxis3=dict(domain=[0, 1], matches="x"),
    # 公共y轴配置
    yaxis=dict(domain=[0.7, 1], showticklabels=False),
    yaxis2=dict(domain=[0.35, 0.65], showticklabels=False),
    yaxis3=dict(domain=[0, 0.3], tickformat=".0%"),
)

# 6. 添加形状标注
fig.add_shape(
    type="line",
    x0="2023-01-01",
    y0=30,
    x1="2023-04-10",
    y1=70,
    line=dict(color="red", width=2, dash="dash"),
)

fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202504/83005-20250419095459906-1474237657.png" alt="" loading="lazy"></p>
<p>这是单列的布局，如果指标多的话，可以用多列的<strong>网格布局</strong>方式来布局。</p>
<h2 id="物联网设备状态监控">物联网设备状态监控</h2>
<p>这个示例采用<strong>自由布局</strong>实现主监控图+4个状态指标环绕。</p>
<pre><code class="language-python">import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np

# 模拟设备数据
np.random.seed(42)
device_data = {
    "timestamp": np.arange(100),
    "temp": 25 + np.random.normal(0, 2, 100),
    "pressure": 100 + np.random.normal(0, 5, 100),
    "vibration": np.random.exponential(0.5, 100),
}

# 1. 创建2行2列的子图布局
fig = make_subplots(
    rows=2,
    cols=2,
    subplot_titles=("温度", "压力", "振动", "状态"),
    specs=[
        [{"type": "scatter"}, {"type": "scatter"}],
        [{"type": "scatter"}, {"type": "indicator"}],
    ],
)

# 2. 添加温度折线图
fig.add_trace(
    go.Scatter(
        x=device_data["timestamp"],
        y=device_data["temp"],
        mode="lines+markers",
        name="温度 (°C)",
        line=dict(color="firebrick"),
    ),
    row=1,
    col=1,
)

# 3. 添加压力散点图
fig.add_trace(
    go.Scatter(
        x=device_data["timestamp"],
        y=device_data["pressure"],
        mode="markers",
        name="压力 (kPa)",
        marker=dict(size=8, color="royalblue", opacity=0.7),
    ),
    row=1,
    col=2,
)

# 4. 添加振动频谱图
fig.add_trace(
    go.Scatter(
        x=device_data["timestamp"],
        y=device_data["vibration"],
        mode="lines",
        name="振动 (g)",
        line=dict(color="forestgreen"),
    ),
    row=2,
    col=1,
)

# 5. 添加状态指示器
fig.add_trace(
    go.Indicator(
        mode="gauge+number",
        value=85,
        domain={"x": [0, 1], "y": [0, 1]},
        title="系统健康 (%)",
        gauge={
            "axis": {"range": [0, 100]},
            "bar": {"color": "gold"},
            "steps": [
                {"range": [0, 70], "color": "red"},
                {"range": [70, 90], "color": "orange"},
                {"range": [90, 100], "color": "green"},
            ],
        },
    ),
    row=2,
    col=2,
)

# 6. 更新布局设置
fig.update_layout(
    title_text="IoT 设备监控仪表盘",
    height=600,
    margin=dict(l=20, r=20, t=80, b=20),
    showlegend=False,
    # 温度图坐标轴
    xaxis=dict(domain=[0, 0.45], showgrid=False),
    yaxis=dict(domain=[0.55, 1], showgrid=False),
    # 压力图坐标轴
    xaxis2=dict(domain=[0.55, 1], showgrid=False),
    yaxis2=dict(domain=[0.55, 1], showgrid=False),
    # 振动图坐标轴
    xaxis3=dict(domain=[0, 0.45], showgrid=False),
    yaxis3=dict(domain=[0, 0.45], showgrid=False),
)

fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202504/83005-20250419095459865-1979399201.png" alt="" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p>在<code>Plotly</code>中，<strong>子图布局</strong>对于创建高质量的数据可视化作品至关重要。</p>
<p>在实际应用中，对于复杂的仪表盘项目，优先采用<strong>网格布局</strong>可以保证子图之间的对齐和一致性；而对于一些创意性的场景，<strong>自由布局</strong>则能够更好地发挥我们的想象力。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.18674599911458334" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-19 09:56">2025-04-19 09:56</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18835155);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18835155', targetLink: 'https://www.cnblogs.com/wang_yb/p/18835155', title: '『Plotly实战指南』--布局进阶篇' })">举报</a>
</div>
        