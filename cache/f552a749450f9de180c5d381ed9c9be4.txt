
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18712528" title="发布于 2025-02-13 09:55">
    <span role="heading" aria-level="2">Log4j2 Garbage-free 无垃圾回收模式实践与总结</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.03313560433564815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 09:58">2025-02-13 09:55</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712528" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712528);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712528', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18712528', title: 'Log4j2 Garbage-free 无垃圾回收模式实践与总结' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Log4j2 内置 Garbage-free（无垃圾）模式，可重用对象和缓冲区，减少日志记录时产生的垃圾对象，避免 JVM 进行 GC 回收，进而提升应用程序的性能与响应速度。以下以 Log4j2 的 2.24.3 版本为基础，客观、真实、全面地介绍 Garbage-free 无垃圾回收模式，并总结其特性和应用场景。</p>
<p><strong>先说结论：</strong> Log4j2 的 Garbage-free 无垃圾回收模式在实际使用中支持和适用场景极为有限，意义不大，不建议开启。</p>
<h2 id="一如何启用">一、如何启用</h2>
<p>默认情况下，Log4j2 根据应用是否为 Web 类型（通过判断 classpath 中是否包含 Servlet 类）来决定是否启用 Garbage-free 运行模式。若是 Web 应用，不开启，此时 log4j2.isWebapp 和 log4j2.enableThreadlocals 属性值分别为 true 和 false；反之，可将两属性值设置为 false 和 true，则强制开启 Garbage-free 模式。</p>
<p>在 Web 应用中，若 ThreadLocal 变量持有非 JDK 类，且 Web 应用程序卸载后，应用服务器的线程池仍继续引用这些变量，可能导致应用内存泄漏。因此，为避免内存泄漏，Web 应用默认不开启 Garbage-free 模式。Web 应用可通过强制指定 log4j2.enableThreadlocals=true 来开启该模式。此外，若使用线程上下文字段（如 MDC），还需将 log4j2.garbagefreeThreadContextMap 属性设为 true。</p>
<p>建议将上述配置属性统一放在类路径（通常是 src/main/resources/）下的 log4j2.component.properties 文件中。这种配置方式可被 JVM 变量、系统环境变量和编码覆盖。</p>
<h2 id="二配套要求">二、配套要求</h2>
<p>启用 Garbage-free 模式（log4j2.enableThreadlocals 属性值设置为 true）后，需配套使用支持 Garbage-free 的 Layouts、Appenders 和 Filters，并合理使用 API，才能确保该模式真正生效。</p>
<h3 id="1-支持的-layout">1. 支持的 Layout</h3>
<p>（1）有条件支持 GelfLayout、JsonTemplateLayout 和 PatternLayout 这三种 Layout，不支持常用的 CsvLayout。</p>
<p>（2）上述三种 Layout 并非完全支持。如果其中使用了不支持 Garbage-free 的参数、配置或方法，会导致该 Layout 不支持 Garbage-free。例如，在 PatternLayout 中输出 Exception、Method、Line、Location、Class、File 等字段，就会使得该 Layout 不支持 Garbage-free。</p>
<h3 id="2-支持的-appender">2. 支持的 Appender</h3>
<p>（1）ConsoleAppender 及文件类 Appender，如 FileAppender、MemoryMappedFileAppender、RandomAccessFileAppender、RollingFileAppender（非轮转期间）、RollingRandomAccessFileAppender（非轮转期间）均支持。</p>
<p>（2）大部分涉及外部 IO（网络、数据库和消息队列等）的 Appender 均不支持，例如 JDBCAppender、KafkaAppender 等。</p>
<p>（3）上述结论仅源于官方文档，未经详细测试。总结 Layout 使用经验，建议仔细参考各 Appender 文档，判断是否存在具体限制。</p>
<h3 id="3-支持的-filter">3. 支持的 Filter</h3>
<p>（1）CompositeFilter、DynamicThresholdFilter、LevelRangeFilter、MapFilter、MarkerFilter、StructuredDataFilter、ThreadContextMapFilter、ThresholdFilter 和 TimeFilter 均支持。</p>
<p>（2）上述结论仅源于官方文档，未经详细测试。总结 Layout 使用经验，建议仔细参考各 Appender 文档，判断是否存在具体限制。</p>
<h3 id="4-其他情况">4. 其他情况</h3>
<p>（1）如果使用了 NDC（Nested Diagnostic Context），则无法支持 Garbage 模式。</p>
<p>（2）异步日志（AsyncLogger）如果使用默认的 timeout 等待策略，则支持 Garbage 模式。</p>
<p>（3）从测试情况来看，即便使用的 Layout、Appender 和 Filter 都支持 Garbage 模式，但如果 logger 输出内容包不支持 Garbage 模式的字段，最终也无法使用 Garbage 模式。</p>
<h2 id="三强烈建议">三、强烈建议</h2>
<p>在实际项目中，即便应用启用 Garbage 模式，受各种使用限制和配置要求影响，实际也未必真正启用。强烈建议使用 JMH 对相应的日志配置进行压测，并添加“prof gc”参数，以验证 GC 的回收情况，从而判断该日志配置是否真正支持 Garbage 模式。</p>
<h2 id="四性能对比">四、性能对比</h2>
<p>以下我们将使用相同的性能测试基准，通过配置参数强制开启或关闭 Garbage 模式，以此判断该模式对性能的帮助。</p>
<h3 id="1-测试基准">1. 测试基准</h3>
<p>（1）硬件：Windows 笔记本，配置为 I5-1350P CPU、32G DDR5 5200 内存以及三星 MZVL4512HBLU-00BLL 512G SSD（顺序写入速度为 2430MB/s）。</p>
<p>（2）软件：基于 JDK 1.8.171，使用 1.37 版 JMH 和 2.24.3 版 Log4j2。</p>
<p>（3）配置：采用 FileAppender 及其默认配置（append 和 immediateFlush 均为 true），使用同步 Logger 进行压测。</p>
<p>（4）参考日常使用情况，输出长度为 100 个的固定字符串，日志 PatternLayout 布局为：“% d {yyyy-MM-dd HH:mm:ss.SSS} %-5level % pid % t - % msg % n”。</p>
<p>（5）在 classpath 下添加 log4j2.component.properties 配置文件，通过 log4j2.enableThreadlocals 配置项来开启或关闭 Garbage-free 模式。</p>
<h3 id="2-log4j2-配置文件">2. Log4j2 配置文件</h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration name="log4j2AppenderTest" status="error"&gt;
	&lt;Properties&gt;
		&lt;Property name="log.pattern"&gt;
			%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %pid %t - %msg %n
		&lt;/Property&gt;
	&lt;/Properties&gt;

	&lt;Appenders&gt;
		&lt;Console name="Console"&gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/Console&gt;
		&lt;File name="File"
			fileName="log/log4j2-file.log"&gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/File&gt;
	&lt;/Appenders&gt;

	&lt;Loggers&gt;
		&lt;Root level="debug"&gt;
			&lt;AppenderRef ref="Console" /&gt;
		&lt;/Root&gt;
		&lt;Logger name="FileLogger" level="debug" additivity="false"&gt;
			&lt;AppenderRef ref="File" /&gt;
		&lt;/Logger&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="3-jmh-压测代码">3. JMH 压测代码</h3>
<pre><code class="language-java">@State(Scope.Benchmark)
public class Log4J2FileAppenderBenchmark {

    static Logger fileLogger;

    int delFilesCount = 0;

    @Setup(Level.Trial)
    public void setUp() throws Exception {
        System.setProperty("log4j.configurationFile", "log4j2.xml");
        fileLogger = LogManager.getLogger("FileLogger");
    }

    @TearDown
    public void tearDown() {
        System.clearProperty("log4j.configurationFile");
    }

    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    @Benchmark
    public void fileLogger() {
        fileLogger.debug(Const.MSG_HAVE_100_CHARS);
    }
}
</code></pre>
<h3 id="4-jmh-参数">4. JMH 参数</h3>
<p>JMH 执行的参数为：<code>-jvmArgs "-Xmx512m -Xms512m" -f 2 -t 4 -w 10 -wi 2 -r 30 -i 2 -to 300 -prof gc</code>，即设置 JVM 参数为 -Xmx512m -Xms512m（堆内存最大和最小均为 512MB），使用 2 个 fork（-f 2），每个 fork 使用 4 个线程（-t 4），预热阶段每次运行 10 秒（-w 10），预热迭代 2 次（-wi 2），正式测试每次运行 30 秒（-r 30），正式测试迭代 2 次（-i 2），超时时间为 300 秒（-to 300），并启用 GC 性能分析（-prof gc）。</p>
<h3 id="5-测试结果">5. 测试结果</h3>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>平均吞吐量</strong></th>
<th><strong>内存分配速率（MB/sec）</strong></th>
<th><strong>垃圾回收次数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Garbage-free 模式</td>
<td>137.1 ops/ms</td>
<td>10 MB/sec</td>
<td>0</td>
</tr>
<tr>
<td>非 Garbage-free 模式</td>
<td>135.5 ops/ms</td>
<td>18.8 MB/sec</td>
<td>18</td>
</tr>
</tbody>
</table>
<h3 id="6-测试总结">6. 测试总结</h3>
<p>（1）由于不少 PatternLayout 参数不支持无垃圾回收模式，因此上述 PatternLayout 配置参数略微简单，在相同配置下，启用 Garbage-free 模式后，内存分配量明显下降，且无 GC 回收及耗时，但吞吐量并无明显提高。</p>
<p>（2）此外，经其他测试发现，越不支持无垃圾回收模式的参数，越占内存，如输出日志所在的类、方法、行数及完整异常堆栈信息等。</p>
<h2 id="五总结">五、总结</h2>
<p>在日常研发中，我们主要将 Log4j2 用于 Web 开发，默认不开启 Garbage-free 模式。若强制启用，一旦使用不当，可能导致内存泄露。即便强制启用，实际使用时，各类日志输出字段需包含产生日志的类、方法、行数及完整异常堆栈等基本字段，而这些字段又不支持 Garbage-free 模式，仍会产生垃圾回收，最终真正启用该模式。所以我认为，<strong>Log4j2 的 Garbage-free 无垃圾回收模式在实际使用中支持和适用场景极为有限，意义不大，不建议开启。</strong></p>
<h2 id="六参考文档">六、参考文档</h2>
<p>（1）<a href="https://logging.apache.org/log4j/2.x/manual/garbagefree.html" target="_blank" rel="noopener nofollow">log4j2.x garbagefree</a></p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18712528"></vc:categories-tags>
    </ul>
