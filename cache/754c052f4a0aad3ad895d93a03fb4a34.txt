
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18965307" title="发布于 2025-07-04 11:24">
    <span role="heading" aria-level="2">6.Java Spring框架源码分析-AOP-Spring_AOP源码分析总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#源码分析" rel="noopener nofollow">源码分析</a><ul><li><a href="#1-enableaspectjautoproxy" rel="noopener nofollow">1. @EnableAspectJAutoProxy</a></li><li><a href="#2-aspectjautoproxyregistrar" rel="noopener nofollow">2. AspectJAutoProxyRegistrar</a></li><li><a href="#3-aopconfigutils" rel="noopener nofollow">3. AopConfigUtils</a><ul><li><a href="#31-registeraspectjannotationautoproxycreatorifnecessary" rel="noopener nofollow">3.1. registerAspectJAnnotationAutoProxyCreatorIfNecessary</a></li><li><a href="#32-registerorescalateapcasrequired" rel="noopener nofollow">3.2. registerOrEscalateApcAsRequired</a></li></ul></li><li><a href="#4-annotationawareaspectjautoproxycreator" rel="noopener nofollow">4. AnnotationAwareAspectJAutoProxyCreator</a><ul><li><a href="#41-类体系" rel="noopener nofollow">4.1. 类体系</a></li></ul></li><li><a href="#5-流程分析" rel="noopener nofollow">5. 流程分析</a><ul><li><a href="#51-调试" rel="noopener nofollow">5.1. 调试</a></li><li><a href="#52-abstractautoproxycreator" rel="noopener nofollow">5.2. AbstractAutoProxyCreator</a><ul><li><a href="#521-postprocessbeforeinstantiation" rel="noopener nofollow">5.2.1. postProcessBeforeInstantiation</a></li><li><a href="#522-isinfrastructureclass" rel="noopener nofollow">5.2.2. isInfrastructureClass</a></li><li><a href="#523-postprocessafterinitialization" rel="noopener nofollow">5.2.3. postProcessAfterInitialization</a></li><li><a href="#524-wrapifnecessary" rel="noopener nofollow">5.2.4. wrapIfNecessary</a></li><li><a href="#525-createproxy" rel="noopener nofollow">5.2.5. createProxy</a></li></ul></li><li><a href="#53-annotationawareaspectjautoproxycreator" rel="noopener nofollow">5.3. AnnotationAwareAspectJAutoProxyCreator</a><ul><li><a href="#531-isinfrastructureclass" rel="noopener nofollow">5.3.1. isInfrastructureClass</a></li><li><a href="#532-isaspect" rel="noopener nofollow">5.3.2. isAspect</a></li></ul></li><li><a href="#54-aspectjawareadvisorautoproxycreator" rel="noopener nofollow">5.4. AspectJAwareAdvisorAutoProxyCreator</a><ul><li><a href="#541-shouldskip" rel="noopener nofollow">5.4.1. shouldSkip</a></li></ul></li><li><a href="#55-abstractadvisorautoproxycreator" rel="noopener nofollow">5.5. AbstractAdvisorAutoProxyCreator</a><ul><li><a href="#551-getadvicesandadvisorsforbean" rel="noopener nofollow">5.5.1. getAdvicesAndAdvisorsForBean</a></li><li><a href="#552-findeligibleadvisors" rel="noopener nofollow">5.5.2. findEligibleAdvisors</a></li><li><a href="#553-findadvisorsthatcanapply" rel="noopener nofollow">5.5.3. findAdvisorsThatCanApply</a></li></ul></li><li><a href="#56-aoputils" rel="noopener nofollow">5.6. AopUtils</a><ul><li><a href="#561-findadvisorsthatcanapply" rel="noopener nofollow">5.6.1. findAdvisorsThatCanApply</a></li></ul></li><li><a href="#57-proxyfactory" rel="noopener nofollow">5.7. ProxyFactory</a><ul><li><a href="#571-getproxy" rel="noopener nofollow">5.7.1. getProxy</a></li></ul></li><li><a href="#58-proxycreatorsupport" rel="noopener nofollow">5.8. ProxyCreatorSupport</a><ul><li><a href="#581-createaopproxy" rel="noopener nofollow">5.8.1. createAopProxy</a></li></ul></li><li><a href="#59-defaultaopproxyfactory" rel="noopener nofollow">5.9. DefaultAopProxyFactory</a><ul><li><a href="#591-createaopproxy" rel="noopener nofollow">5.9.1. createAopProxy</a></li></ul></li></ul></li><li><a href="#6-目标方法执行" rel="noopener nofollow">6. 目标方法执行</a><ul><li><a href="#61-cglibaopproxy" rel="noopener nofollow">6.1. CglibAopProxy</a><ul><li><a href="#611-intercept" rel="noopener nofollow">6.1.1. intercept</a></li></ul></li><li><a href="#62-advisedsupportadvisedsupport" rel="noopener nofollow">6.2. AdvisedSupportAdvisedSupport</a><ul><li><a href="#621-getinterceptorsanddynamicinterceptionadvice" rel="noopener nofollow">6.2.1. getInterceptorsAndDynamicInterceptionAdvice</a></li></ul></li><li><a href="#63-defaultadvisorchainfactory" rel="noopener nofollow">6.3. DefaultAdvisorChainFactory</a><ul><li><a href="#631-getinterceptorsanddynamicinterceptionadvice" rel="noopener nofollow">6.3.1. getInterceptorsAndDynamicInterceptionAdvice</a></li></ul></li><li><a href="#64-defaultadvisoradapterregistry" rel="noopener nofollow">6.4. DefaultAdvisorAdapterRegistry</a><ul><li><a href="#641-getinterceptors" rel="noopener nofollow">6.4.1. getInterceptors</a></li></ul></li><li><a href="#65-reflectivemethodinvocation" rel="noopener nofollow">6.5. ReflectiveMethodInvocation</a><ul><li><a href="#651-proceed" rel="noopener nofollow">6.5.1. proceed</a></li></ul></li><li><a href="#66-exposeinvocationinterceptor" rel="noopener nofollow">6.6. ExposeInvocationInterceptor</a><ul><li><a href="#661-invoke" rel="noopener nofollow">6.6.1. invoke</a></li></ul></li><li><a href="#67-methodbeforeadviceinterceptor" rel="noopener nofollow">6.7. MethodBeforeAdviceInterceptor</a><ul><li><a href="#671-invoke" rel="noopener nofollow">6.7.1. invoke</a></li></ul></li><li><a href="#68-aspectjafteradvice" rel="noopener nofollow">6.8. AspectJAfterAdvice</a><ul><li><a href="#681-invoke" rel="noopener nofollow">6.8.1. invoke</a></li></ul></li><li><a href="#69-afterreturningadviceinterceptor" rel="noopener nofollow">6.9. AfterReturningAdviceInterceptor</a><ul><li><a href="#691-invoke" rel="noopener nofollow">6.9.1. invoke</a></li></ul></li><li><a href="#610-throwsadviceinterceptor" rel="noopener nofollow">6.10. ThrowsAdviceInterceptor</a><ul><li><a href="#6101-invoke" rel="noopener nofollow">6.10.1. invoke</a></li></ul></li></ul></li></ul></li></ul></div><p></p>
<h2 id="源码分析">源码分析</h2>
<h3 id="1-enableaspectjautoproxy">1. @EnableAspectJAutoProxy</h3>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)//导入了AspectJAutoProxyRegistrar组件
public @interface EnableAspectJAutoProxy {

	boolean proxyTargetClass() default false;
	boolean exposeProxy() default false;

}
</code></pre>
<h3 id="2-aspectjautoproxyregistrar">2. AspectJAutoProxyRegistrar</h3>
<pre><code>//实现了ImportBeanDefinitionRegistrar接口，可以向ioc容器导入bean
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

	@Override
	public void registerBeanDefinitions(
			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

		//向容器中注册AnnotationAwareAspectJAutoProxyCreator bean
		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

		AnnotationAttributes enableAspectJAutoProxy =
				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
		if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
		}
		if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
		}
	}

}
</code></pre>
<h3 id="3-aopconfigutils">3. AopConfigUtils</h3>
<h4 id="31-registeraspectjannotationautoproxycreatorifnecessary">3.1. registerAspectJAnnotationAutoProxyCreatorIfNecessary</h4>
<pre><code>public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
		//导入AnnotationAwareAspectJAutoProxyCreator
		return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
	}
</code></pre>
<h4 id="32-registerorescalateapcasrequired">3.2. registerOrEscalateApcAsRequired</h4>
<pre><code>private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {
		Assert.notNull(registry, "BeanDefinitionRegistry must not be null");

		//已经存在org.springframework.aop.config.internalAutoProxyCreator的bean
		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
			if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
				int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
				int requiredPriority = findPriorityForClass(cls);
				if (currentPriority &lt; requiredPriority) {
					apcDefinition.setBeanClassName(cls.getName());
				}
			}
			return null;
		}

		//不存在则创建该AnnotationAwareAspectJAutoProxyCreator bean，放入ioc容器
		RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
		beanDefinition.setSource(source);
		beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE);
		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
		return beanDefinition;
	}
</code></pre>
<h3 id="4-annotationawareaspectjautoproxycreator">4. AnnotationAwareAspectJAutoProxyCreator</h3>
<h4 id="41-类体系">4.1. 类体系</h4>
<p>由下图可看出AnnotationAwareAspectJAutoProxyCreator主要实现了<br>
BeanFactoryAware接口。setBeanFactory方法（为bean注入BeanFactory）<br>
以及BeanPostProcessor接口。postProcessBeforeInitialization方法（bean初始化之前做一些事情）和postProcessAfterInitialization方法（bean初始化之后做一些事情））<br>
<img alt="" loading="lazy" data-src="./Spring%E6%B3%A8%E8%A7%A3/pasted_image003.png" class="lazyload"></p>
<h3 id="5-流程分析">5. 流程分析</h3>
<h4 id="51-调试">5.1. 调试</h4>
<p>为AnnotationAwareAspectJAutoProxyCreator类体系的关键方法加上断点，运行。<br>
1）、传入配置类，创建ioc容器<br>
2）、注册配置类，调用refresh()刷新容器<br>
3）、registerBeanPostProcessors(beanFactory)；注册bean的后置处理器拦截bean的创建<br>
1）、先获取ioc容器中的所有BeanPostProcessor<br>
2）、给容器中加入别的BeanPostProcessor<br>
3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor<br>
4）、然后注册实现了Ordered接口的BeanPostProcessor<br>
5）、接着注册没实现接口的BeanPostProcessor<br>
6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor保存在容器中<br>
创建internalAutoProxyCreator的BeanPostProcessor[]<br>
1）、创建Bean的实例<br>
2）、populateBean，给bean的各种属性赋值<br>
3）、initializeBean，初始化bean<br>
1）、invokeAwareMethods()，处理Aware接口的方法回调<br>
2）、applyBeanPostProcessorsBeforeInitialization()<br>
3）、invokeInitMethods()，执行自定义的初始化方法<br>
4）、applyBeanPostProcessorsAfterInitialization()<br>
4）、BeanPostProcessor（AnnotationAwareAspecJAutoProxyCreater）<br>
7）、把BeanPostProcessor注册到BeanFactory中<br>
beanFactory.addBeanPostProcessor(processor)<br>
<mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark>通过以上过程就把AnnotationAwareAspecJAutoProxyCreater注册进容器中</mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark>=================</p>
<h4 id="52-abstractautoproxycreator">5.2. AbstractAutoProxyCreator</h4>
<h5 id="521-postprocessbeforeinstantiation">5.2.1. postProcessBeforeInstantiation</h5>
<pre><code>public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
		//获取缓存key
		Object cacheKey = getCacheKey(beanClass, beanName);

		
		if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {
			//判断是否在已经增强的bean里
			if (this.advisedBeans.containsKey(cacheKey)) {
				//是的话说明已经增强过，直接返回
				return null;
			}
			//调用AnnotationAwareAspectJAutoProxyCreator的isInfrastructureClass方法以及shouldSkip方法
			if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
				this.advisedBeans.put(cacheKey, Boolean.FALSE);
				return null;
			}
		}

		// Create proxy here if we have a custom TargetSource.
		// Suppresses unnecessary default instantiation of the target bean:
		// The TargetSource will handle target instances in a custom fashion.
		if (beanName != null) {
			TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
			if (targetSource != null) {
				this.targetSourcedBeans.add(beanName);
				Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
				Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
				this.proxyTypes.put(cacheKey, proxy.getClass());
				return proxy;
			}
		}

		return null;
	}
</code></pre>
<h5 id="522-isinfrastructureclass">5.2.2. isInfrastructureClass</h5>
<pre><code>protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {
		//判断是否是Advice、Pointcut、Advisor、AopInfrastructureBean类
		boolean retVal = Advice.class.isAAopInfrastructureBeanssignableFrom(beanClass) ||
				Pointcut.class.isAssignableFrom(beanClass) ||
				Advisor.class.isAssignableFrom(beanClass) ||
				AopInfrastructureBean.class.isAssignableFrom(beanClass);
		if (retVal &amp;&amp; logger.isTraceEnabled()) {
			logger.trace("Did not attempt to auto-proxy infrastructure class [" + beanClass.getName() + "]");
		}
		return retVal;
	}
</code></pre>
<h5 id="523-postprocessafterinitialization">5.2.3. postProcessAfterInitialization</h5>
<pre><code>//创建完Calc对象后会调用这个方法
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (bean != null) {
			Object cacheKey = getCacheKey(bean.getClass(), beanName);
			if (this.earlyProxyReferences.remove(cacheKey) != bean) {
				//必要时包装Calc
				return wrapIfNecessary(bean, beanName, cacheKey);
			}
		}
		return bean;
	}
</code></pre>
<h5 id="524-wrapifnecessary">5.2.4. wrapIfNecessary</h5>
<pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
		if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) {
			return bean;
		}
		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
			return bean;
		}
		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
			this.advisedBeans.put(cacheKey, Boolean.FALSE);
			return bean;
		}

		// Create proxy if we have advice.
		//获取Calc所有的增强器
		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
			this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建代理类增强当前bean
			Object proxy = createProxy(
					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}

		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}
</code></pre>
<h5 id="525-createproxy">5.2.5. createProxy</h5>
<pre><code>protected Object createProxy(
			Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

		if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
		}

		ProxyFactory proxyFactory = new ProxyFactory();
		proxyFactory.copyFrom(this);

		if (!proxyFactory.isProxyTargetClass()) {
			if (shouldProxyTargetClass(beanClass, beanName)) {
				proxyFactory.setProxyTargetClass(true);
			}
			else {
				evaluateProxyInterfaces(beanClass, proxyFactory);
			}
		}

		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
		proxyFactory.addAdvisors(advisors);
		proxyFactory.setTargetSource(targetSource);
		customizeProxyFactory(proxyFactory);

		proxyFactory.setFrozen(this.freezeProxy);
		if (advisorsPreFiltered()) {
			proxyFactory.setPreFiltered(true);
		}

		//用ProxyFactory代理工厂创建对象
		return proxyFactory.getProxy(getProxyClassLoader());
	}
</code></pre>
<h4 id="53-annotationawareaspectjautoproxycreator">5.3. AnnotationAwareAspectJAutoProxyCreator</h4>
<h5 id="531-isinfrastructureclass">5.3.1. isInfrastructureClass</h5>
<pre><code>protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {
		//AbstractAutoProxyCreator.isInfrastructureClass || AbstractAspectJAdvisorFactory.isAspect
		return (super.isInfrastructureClass(beanClass) || this.aspectJAdvisorFactory.isAspect(beanClass));
	}
</code></pre>
<h5 id="532-isaspect">5.3.2. isAspect</h5>
<pre><code>public boolean isAspect(Class&lt;?&gt; clazz) {
		//有@Aspect注解 并且 没有以ajc$开头的属性
		return (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));
	}
</code></pre>
<h4 id="54-aspectjawareadvisorautoproxycreator">5.4. AspectJAwareAdvisorAutoProxyCreator</h4>
<h5 id="541-shouldskip">5.4.1. shouldSkip</h5>
<pre><code>protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {
		// TODO: Consider optimization by caching the list of the aspect names
		//找到所有增强的切面：就是LogAspect中的增强方法
		List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
		for (Advisor advisor : candidateAdvisors) {
			//只要有一个增强器是AspectJPointcutAdvisor类型的并且增强器修饰的bean就是beanName，那么返回true
			if (advisor instanceof AspectJPointcutAdvisor) {
				if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) {
					return true;
				}
			}
		}
		return super.shouldSkip(beanClass, beanName);
	}
</code></pre>
<h4 id="55-abstractadvisorautoproxycreator">5.5. AbstractAdvisorAutoProxyCreator</h4>
<h5 id="551-getadvicesandadvisorsforbean">5.5.1. getAdvicesAndAdvisorsForBean</h5>
<pre><code>protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) {
		List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);
		if (advisors.isEmpty()) {
			return DO_NOT_PROXY;
		}
		return advisors.toArray();
	}
</code></pre>
<h5 id="552-findeligibleadvisors">5.5.2. findEligibleAdvisors</h5>
<pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {
		//获取所有的增强器
		List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
		//筛选出能应用到当前bean上的增强器
		List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
		extendAdvisors(eligibleAdvisors);
		if (!eligibleAdvisors.isEmpty()) {
			eligibleAdvisors = sortAdvisors(eligibleAdvisors);
		}
		return eligibleAdvisors;
	}
</code></pre>
<h5 id="553-findadvisorsthatcanapply">5.5.3. findAdvisorsThatCanApply</h5>
<pre><code>protected List&lt;Advisor&gt; findAdvisorsThatCanApply(
			List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) {

		ProxyCreationContext.setCurrentProxiedBeanName(beanName);
		try {
			//调用AopUtils获取能应用的增强器
			return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
		}
		finally {
			ProxyCreationContext.setCurrentProxiedBeanName(null);
		}
	}
</code></pre>
<h4 id="56-aoputils">5.6. AopUtils</h4>
<h5 id="561-findadvisorsthatcanapply">5.6.1. findAdvisorsThatCanApply</h5>
<pre><code>public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {
		if (candidateAdvisors.isEmpty()) {
			return candidateAdvisors;
		}
		List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();
		//遍历所有增强器，最后调用的都是getClassFilter().matches()方法判断的
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {
				eligibleAdvisors.add(candidate);
			}
		}
		boolean hasIntroductions = !eligibleAdvisors.isEmpty();
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor) {
				// already processed
				continue;
			}
			if (canApply(candidate, clazz, hasIntroductions)) {
				eligibleAdvisors.add(candidate);
			}
		}
		return eligibleAdvisors;
	}
</code></pre>
<h4 id="57-proxyfactory">5.7. ProxyFactory</h4>
<h5 id="571-getproxy">5.7.1. getProxy</h5>
<pre><code>public Object getProxy(ClassLoader classLoader) {
		//ProxyCreatorSupport的createAopProxy
		return createAopProxy().getProxy(classLoader);
	}
</code></pre>
<h4 id="58-proxycreatorsupport">5.8. ProxyCreatorSupport</h4>
<h5 id="581-createaopproxy">5.8.1. createAopProxy</h5>
<pre><code>protected final synchronized AopProxy createAopProxy() {
		if (!this.active) {
			activate();
		}
		//调用DefaultAopProxyFactory的createAopProxy方法	
		return getAopProxyFactory().createAopProxy(this);
	}
</code></pre>
<h4 id="59-defaultaopproxyfactory">5.9. DefaultAopProxyFactory</h4>
<h5 id="591-createaopproxy">5.9.1. createAopProxy</h5>
<pre><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
			Class&lt;?&gt; targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException("TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation.");
			}
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
				return new JdkDynamicAopProxy(config);
			}
			//没有的话使用cglib继承
			return new ObjenesisCglibAopProxy(config);
		}
		else {
			//有接口的话使用jdk代理
			return new JdkDynamicAopProxy(config);
		}
	}
</code></pre>
<h3 id="6-目标方法执行">6. 目标方法执行</h3>
<h4 id="61-cglibaopproxy">6.1. CglibAopProxy</h4>
<h5 id="611-intercept">6.1.1. intercept</h5>
<pre><code>//拦截目标方法的执行
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
		Object oldProxy = null;
		boolean setProxyContext = false;
		Class&lt;?&gt; targetClass = null;
		Object target = null;
		try {
			if (this.advised.exposeProxy) {
				// Make invocation available if necessary.
				oldProxy = AopContext.setCurrentProxy(proxy);
				setProxyContext = true;
			}
			// May be null. Get as late as possible to minimize the time we
			// "own" the target, in case it comes from a pool...
			target = getTarget();
			if (target != null) {
				targetClass = target.getClass();
			}
			//获取目标方法的拦截器链:AdvisedSupportAdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice()
			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
			Object retVal;
			// Check whether we only have one InvokerInterceptor: that is,
			// no real advice, but just reflective invocation of the target.
			//没有拦截器链
			if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
				// We can skip creating a MethodInvocation: just invoke the target directly.
				// Note that the final invoker must be an InvokerInterceptor, so we know
				// it does nothing but a reflective operation on the target, and no hot
				// swapping or fancy proxying.
				//直接执行目标方法
				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
				retVal = methodProxy.invoke(target, argsToUse);
			}
			else {
				// We need to create a method invocation...
				//把需要执行的目标对象，目标方法，拦截器链等信息传入创建CglibMethodInvocation
				//接着执行这个对象的proceed方法
				retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
			}
			retVal = processReturnType(proxy, target, method, retVal);
			return retVal;
		}
		finally {
			if (target != null) {
				releaseTarget(target);
			}
			if (setProxyContext) {
				// Restore old proxy.
				AopContext.setCurrentProxy(oldProxy);
			}
		}
	}
</code></pre>
<h4 id="62-advisedsupportadvisedsupport">6.2. AdvisedSupportAdvisedSupport</h4>
<h5 id="621-getinterceptorsanddynamicinterceptionadvice">6.2.1. getInterceptorsAndDynamicInterceptionAdvice</h5>
<pre><code>public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) {
		MethodCacheKey cacheKey = new MethodCacheKey(method);
		List&lt;Object&gt; cached = this.methodCache.get(cacheKey);
		if (cached == null) {
		//#### DefaultAdvisorChainFactory##### getInterceptorsAndDynamicInterceptionAdvice
			cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
					this, method, targetClass);
			this.methodCache.put(cacheKey, cached);
		}
		return cached;
	}
</code></pre>
<h4 id="63-defaultadvisorchainfactory">6.3. DefaultAdvisorChainFactory</h4>
<h5 id="631-getinterceptorsanddynamicinterceptionadvice">6.3.1. getInterceptorsAndDynamicInterceptionAdvice</h5>
<pre><code>public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(
			Advised config, Method method, Class&lt;?&gt; targetClass) {

		// This is somewhat tricky... We have to process introductions first,
		// but we need to preserve order in the ultimate list.
		List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length);
		Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());
		boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);
		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();

		//获取所有的增强器，封装成Interceptor
		for (Advisor advisor : config.getAdvisors()) {
			if (advisor instanceof PointcutAdvisor) {
				// Add it conditionally.
				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
					if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {
						//调用DefaultAdvisorAdapterRegistry的getInterceptors方法
						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
						if (mm.isRuntime()) {
							// Creating a new object instance in the getInterceptors() method
							// isn't a problem as we normally cache  
							for (MethodInterceptor interceptor : interceptors) {
								interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
							}
						}
						else {
							interceptorList.addAll(Arrays.asList(interceptors));
						}
					}
				}
			}
			else if (advisor instanceof IntroductionAdvisor) {
				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {
					Interceptor[] interceptors = registry.getInterceptors(advisor);
					interceptorList.addAll(Arrays.asList(interceptors));
				}
			}
			else {
				Interceptor[] interceptors = registry.getInterceptors(advisor);
				interceptorList.addAll(Arrays.asList(interceptors));
			}
		}

		return interceptorList;
	}
</code></pre>
<h4 id="64-defaultadvisoradapterregistry">6.4. DefaultAdvisorAdapterRegistry</h4>
<h5 id="641-getinterceptors">6.4.1. getInterceptors</h5>
<pre><code>public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
		List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3);
		Advice advice = advisor.getAdvice();
		//如果是MethodInterceptor，直接加入进去
		if (advice instanceof MethodInterceptor) {
			interceptors.add((MethodInterceptor) advice);
		}
		for (AdvisorAdapter adapter : this.adapters) {
			//使用适配器
			if (adapter.supportsAdvice(advice)) {
				interceptors.add(adapter.getInterceptor(advisor));
			}
		}
		if (interceptors.isEmpty()) {
			throw new UnknownAdviceTypeException(advisor.getAdvice());
		}
		return interceptors.toArray(new MethodInterceptor[interceptors.size()]);
	}
</code></pre>
<h4 id="65-reflectivemethodinvocation">6.5. ReflectiveMethodInvocation</h4>
<h5 id="651-proceed">6.5.1. proceed</h5>
<pre><code>public Object proceed() throws Throwable {
		//	We start with an index of -1 and increment early.
		//如果没有拦截器链或者执行到最后一个拦截器
		if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
			//通过反射执行目标方法method.invoke(target, args);
			return invokeJoinpoint();
		}

		//获取第n个拦截器
		Object interceptorOrInterceptionAdvice =
				this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
		if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
			// Evaluate dynamic method matcher here: static part will already have
			// been evaluated and found to match.
			InterceptorAndDynamicMethodMatcher dm =
					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
			if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
				return dm.interceptor.invoke(this);
			}
			else {
				// Dynamic matching failed.
				// Skip this interceptor and invoke the next in the chain.
				return proceed();
			}
		}
		else {
			// It's an interceptor, so we just invoke it: The pointcut will have
			// been evaluated statically before this object was constructed.
			//调用ExposeInvocationInterceptor的invoke方法
			//最后一次会调用MethodBeforeAdviceInterceptor.invoke方法
			return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
		}
	}
</code></pre>
<h4 id="66-exposeinvocationinterceptor">6.6. ExposeInvocationInterceptor</h4>
<h5 id="661-invoke">6.6.1. invoke</h5>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
		//private static final ThreadLocal&lt;MethodInvocation&gt; invocation = new NamedThreadLocal&lt;MethodInvocation&gt;("Current AOP method invocation");
		MethodInvocation oldInvocation = invocation.get();
		//设置当前ThreadLocal关联的拦截器
		invocation.set(mi);
		try {
			//继续调用ReflectiveMethodInvocation.proceed方法
			return mi.proceed();
		}
		finally {
			invocation.set(oldInvocation);
		}
	}
</code></pre>
<h4 id="67-methodbeforeadviceinterceptor">6.7. MethodBeforeAdviceInterceptor</h4>
<h5 id="671-invoke">6.7.1. invoke</h5>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
		//1.执行前置通知
		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
		//2.继续调用ReflectiveMethodInvocation.proceed方法此时执行的是目标方法
		return mi.proceed();
	}
</code></pre>
<h4 id="68-aspectjafteradvice">6.8. AspectJAfterAdvice</h4>
<h5 id="681-invoke">6.8.1. invoke</h5>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			//4.执行proceed
			return mi.proceed();
		}
		finally {
			//3.执行后置通知
			invokeAdviceMethod(getJoinPointMatch(), null, null);
		}
	}
</code></pre>
<h4 id="69-afterreturningadviceinterceptor">6.9. AfterReturningAdviceInterceptor</h4>
<h5 id="691-invoke">6.9.1. invoke</h5>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
		//先执行方法
		Object retVal = mi.proceed();
		//没有任何问题才执行afterReturning
		this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
		return retVal;
	}
</code></pre>
<h4 id="610-throwsadviceinterceptor">6.10. ThrowsAdviceInterceptor</h4>
<h5 id="6101-invoke">6.10.1. invoke</h5>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		catch (Throwable ex) {
			Method handlerMethod = getExceptionHandler(ex);
			if (handlerMethod != null) {
				//执行异常处理方法
				invokeHandlerMethod(mi, ex, handlerMethod);
			}
			throw ex;
		}
	}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200102214459.png" class="lazyload"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-07-04 11:25">2025-07-04 11:24</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18965307);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18965307', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18965307', title: '6.Java Spring框架源码分析-AOP-Spring_AOP源码分析总结' })">举报</a>
</div>
        