
	<h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/heyonggang/p/19032169" title="发布于 2025-08-11 16:08">
    <span role="heading" aria-level="2">InnoDB为什么不用跳表，Redis为什么不用B+树？</span>
    

</a>
</h1>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>要回答为什么 <strong>InnoDB（MySQL 的存储引擎）</strong> 使用 B+ 树而不是跳表（Skip List），以及为什么 <strong>Redis</strong> 使用跳表而不是 B+ 树，需要分析两者的数据结构特性、使用场景和设计目标。以下是详细的对比和原因分析。</p>
<hr>
<h3 id="1-innodb-为什么使用-b-树而不是跳表"><strong>1. InnoDB 为什么使用 B+ 树而不是跳表？</strong></h3>
<h4 id="b-树的特点"><strong>B+ 树的特点</strong></h4>
<ul>
<li><strong>结构</strong>：B+ 树是一种多路平衡搜索树，非叶子节点存储键值，叶子节点存储完整数据（聚簇索引）或键值+指针（非聚簇索引），叶子节点通过双向链表连接。</li>
<li><strong>优势</strong>：
<ul>
<li><strong>高效范围查询</strong>：叶子节点链表支持快速顺序访问，适合 <code>WHERE id BETWEEN 10 AND 20</code> 等查询。</li>
<li><strong>低树高</strong>：多路分支（每个节点存储多个键）减少树高，降低磁盘 I/O。</li>
<li><strong>磁盘优化</strong>：节点大小与 InnoDB 页面（默认 16KB）对齐，最大化 I/O 效率。</li>
<li><strong>并发支持</strong>：支持细粒度锁（如行锁、间隙锁）和 MVCC（多版本并发控制），适合事务性数据库。</li>
</ul>
</li>
<li><strong>劣势</strong>：
<ul>
<li>键值重复存储，增加空间开销。</li>
<li>插入/更新可能导致页面分裂，维护成本较高。</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>在B+树中，非叶子节点存储键值（索引字段），而叶子节点存储完整的键值和数据（或数据指针）。这意味着<strong>同一个键值可能会在非叶子节点和叶子节点中重复出现</strong>，导致存储空间的冗余</li>
<li>例如，在一个name字段的索引中，name值会在非叶子节点和叶子节点中都存储，增加了存储开销。</li>
</ul>
<h4 id="跳表的特点"><strong>跳表的特点</strong></h4>
<ul>
<li><strong>结构</strong>：跳表是一种基于链表的概率性数据结构，通过多层索引（随机层数）加速查找，类似平衡树的二分搜索。</li>
<li><strong>优势</strong>：
<ul>
<li><strong>简单实现</strong>：相比 B+ 树，跳表实现更简单，代码复杂度低。</li>
<li><strong>动态更新</strong>：插入和删除操作效率较高，平均时间复杂度为 O(log n)，无需复杂平衡操作。</li>
<li><strong>内存友好</strong>：跳表基于指针，适合<strong>内存操作</strong>，空间利用率较高。</li>
</ul>
</li>
<li><strong>劣势</strong>：
<ul>
<li><strong>概率性性能</strong>：跳表的性能依赖随机层分配，最坏情况退化为 O(n)。</li>
<li><strong>范围查询较弱</strong>：虽然支持范围查询，但需要逐节点遍历链表，效率不如 B+ 树的顺序链表。</li>
<li><strong>磁盘 I/O 不友好</strong>：跳表节点大小不固定，难以与磁盘页面对齐，<strong>增加 I/O 开销</strong>。</li>
</ul>
</li>
</ul>
<h4 id="为什么-innodb-选择-b-树"><strong>为什么 InnoDB 选择 B+ 树？</strong></h4>
<ol>
<li>
<p><strong>磁盘 I/O 优化</strong>：</p>
<ul>
<li>InnoDB 是<strong>磁盘数据库</strong>，查询性能受限于磁盘 I/O。B+ 树的节点设计与页面大小对齐（16KB），每次 I/O 可读取多个键值，减少 I/O 次数。</li>
<li>跳表的节点大小不固定，难以优化磁盘 I/O，可能导致更多随机读取，性能下降。</li>
</ul>
</li>
<li>
<p><strong>高效范围查询</strong>：</p>
<ul>
<li>数据库常见操作包括范围查询（如 <code>SELECT * FROM table WHERE id BETWEEN 10 AND 20</code>）。B+ 树的叶子节点通过双向链表连接，支持高效顺序访问。</li>
<li>跳表需要逐节点遍历，范围查询效率较低，尤其在数据量大时。</li>
</ul>
</li>
<li>
<p><strong>并发和事务支持</strong>：</p>
<ul>
<li>InnoDB 支持复杂的事务隔离级别（如可重复读）和 MVCC。B+ 树的结构便于实现行锁、间隙锁和版本控制，减少锁冲突。</li>
<li>跳表的链表结构难以支持细粒度锁，MVCC 实现复杂，可能导致并发性能下降。</li>
</ul>
</li>
<li>
<p><strong>稳定性能</strong>：</p>
<ul>
<li>B+ 树是平衡树，查询时间复杂度稳定为 O(log n)。跳表的性能依赖随机层分配，最坏情况退化为 O(n)，不适合对性能一致性要求高的数据库。</li>
</ul>
</li>
<li>
<p><strong>数据量和持久化</strong>：</p>
<ul>
<li>InnoDB 处理大规模数据（百万到亿级记录），B+ 树的低树高和顺序存储适合磁盘环境。</li>
<li>跳表更适合内存数据库或较小数据集，难以应对大规模磁盘存储。</li>
</ul>
</li>
</ol>
<h4 id="总结"><strong>总结</strong></h4>
<p>InnoDB 选择 B+ 树是因为它在<strong>磁盘 I/O 优化</strong>、<strong>范围查询效率</strong>、<strong>并发支持</strong>和<strong>稳定性能</strong>方面更适合关系型数据库的需求。跳表的概率性性能、较弱的范围查询支持和磁盘不友好特性使其不适合 InnoDB 的场景。</p>
<hr>
<h3 id="2-redis-为什么使用跳表而不是-b-树"><strong>2. Redis 为什么使用跳表而不是 B+ 树？</strong></h3>
<h4 id="redis-的特点"><strong>Redis 的特点</strong></h4>
<ul>
<li>Redis 是一个<strong>内存数据库</strong>，数据存储在内存中，I/O 延迟极低，查询性能主要受 CPU 和内存访问速度限制。</li>
<li>Redis 的有序集合（Sorted Set，ZSET）使用跳表作为主要数据结构，支持快速插入、删除、查找和范围查询。</li>
</ul>
<h4 id="跳表在-redis-中的优势"><strong>跳表在 Redis 中的优势</strong></h4>
<ol>
<li>
<p><strong>内存操作优化</strong>：</p>
<ul>
<li>跳表基于链表和指针，节点大小灵活，适合内存环境。内存访问速度快，跳表无需像 B+ 树那样优化磁盘页面大小。</li>
<li>B+ 树的节点设计（大节点、多键）针对磁盘 I/O，在内存中可能导致空间浪费和复杂维护。</li>
</ul>
</li>
<li>
<p><strong>简单实现</strong>：</p>
<ul>
<li>跳表实现比 B+ 树简单，代码复杂度低，维护成本小。Redis 强调高性能和轻量级，跳表符合这一设计哲学。</li>
<li>B+ 树需要复杂的平衡操作（如节点分裂、合并），增加开发和维护成本。</li>
</ul>
</li>
<li>
<p><strong>动态更新效率</strong>：</p>
<ul>
<li>Redis 的 ZSET 频繁涉及插入和删除操作（如 <code>ZADD</code>、<code>ZREM</code>）。跳表的插入/删除平均时间复杂度为 O(log n)，无需复杂平衡，适合高频更新。</li>
<li>B+ 树的插入/更新可能导致节点分裂或合并，成本较高，尤其在内存中无明显 I/O 优势。</li>
</ul>
</li>
<li>
<p><strong>范围查询支持</strong>：</p>
<ul>
<li>ZSET 常用于范围查询（如 <code>ZRANGEBYSCORE</code>）。跳表通过底层链表支持范围查询，虽然效率不如 B+ 树的双向链表，但在内存中差异较小。</li>
<li>Redis 数据量通常较小（内存限制），跳表足以满足范围查询需求。</li>
</ul>
</li>
<li>
<p><strong>空间效率</strong>：</p>
<ul>
<li>跳表节点只存储必要指针和数据，空间利用率较高。B+ 树的键值重复存储（非叶子节点和叶子节点）在内存中可能浪费空间。</li>
<li>Redis 追求内存高效，跳表更适合。</li>
</ul>
</li>
</ol>
<h4 id="b-树的劣势在-redis-中"><strong>B+ 树的劣势在 Redis 中</strong></h4>
<ol>
<li>
<p><strong>内存不友好</strong>：</p>
<ul>
<li>B+ 树节点设计为大块（如 16KB），在内存中可能导致空间浪费，且节点分裂/合并操作复杂。</li>
<li>跳表的节点小且灵活，内存分配更高效。</li>
</ul>
</li>
<li>
<p><strong>复杂性</strong>：</p>
<ul>
<li>B+ 树需要维护多路平衡，代码复杂，不符合 Redis 轻量级设计。</li>
<li>跳表通过随机层分配实现近似平衡，简单且性能足够。</li>
</ul>
</li>
<li>
<p><strong>无磁盘 I/O 需求</strong>：</p>
<ul>
<li>Redis 是内存数据库，I/O 成本几乎为零，B+ 树的磁盘优化优势（如低树高、页面对齐）无用武之地。</li>
<li>跳表的 O(log n) 查找性能在内存中已足够快。</li>
</ul>
</li>
<li>
<p><strong>并发需求不同</strong>：</p>
<ul>
<li>Redis 是单线程模型，依赖事件驱动处理并发，无需复杂锁机制。跳表的简单结构适合单线程操作。</li>
<li>B+ 树在 InnoDB 中支持复杂的事务和锁机制，但在 Redis 的单线程环境中显得过于复杂。</li>
</ul>
</li>
</ol>
<h4 id="redis-中跳表的使用"><strong>Redis 中跳表的使用</strong></h4>
<ul>
<li>Redis 的 ZSET 使用跳表存储元素及其分数（score），支持快速查找（<code>ZSCORE</code>）、排名（<code>ZRANK</code>）和范围查询（<code>ZRANGEBYSCORE</code>）。</li>
<li>跳表结合哈希表（存储元素到分数的映射）实现 ZSET，提供高效的插入、删除和查询性能。</li>
<li>示例：<pre><code class="language-redis">ZADD myzset 1 "user1" 2 "user2" 3 "user3"
ZRANGEBYSCORE myzset 1 2
</code></pre>
<ul>
<li>跳表快速定位分数范围 [1, 2]，通过链表遍历返回结果。</li>
</ul>
</li>
</ul>
<h4 id="总结-1"><strong>总结</strong></h4>
<p>Redis 选择跳表是因为它在<strong>内存环境</strong>中简单高效，支持动态更新、范围查询和排名操作，符合 Redis 轻量级、高性能的设计目标。B+ 树的磁盘优化和复杂平衡机制在内存数据库中无明显优势，且维护成本高。</p>
<hr>
<h3 id="3-b-树与跳表的对比总结"><strong>3. B+ 树与跳表的对比总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>B+ 树</strong></th>
<th><strong>跳表</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>结构</strong></td>
<td>多路平衡树，叶子节点链表连接</td>
<td>多层链表，概率性平衡</td>
</tr>
<tr>
<td><strong>查询复杂度</strong></td>
<td>O(log n)，稳定</td>
<td>O(log n) 平均，O(n) 最坏</td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td>高效（双向链表）</td>
<td>较慢（逐节点遍历）</td>
</tr>
<tr>
<td><strong>插入/删除</strong></td>
<td>O(log n)，需节点分裂/合并</td>
<td>O(log n)，简单随机层分配</td>
</tr>
<tr>
<td><strong>空间占用</strong></td>
<td>键值重复，占用较多</td>
<td>灵活，空间效率较高</td>
</tr>
<tr>
<td><strong>磁盘优化</strong></td>
<td>节点与页面对齐，I/O 效率高</td>
<td>不适合磁盘，随机访问多</td>
</tr>
<tr>
<td><strong>并发支持</strong></td>
<td>支持细粒度锁、MVCC</td>
<td>简单结构，适合单线程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>磁盘数据库（InnoDB），大规模数据</td>
<td>内存数据库或较小数据集</td>
</tr>
</tbody>
</table>

</div>
<div id="MySignature" role="contentinfo">
    <div style="display: block" id="MySignature">
<p style="border: 2px solid #DEEBF7; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 10px; background: #fff7dc no-repeat 1% 50%; height: 100px; font-family: 微软雅黑; font-size: 12px;" id="PSignature">
<img style="margin-right: 20px; width: 100px; height: 100px; float: left;" src="https://images.cnblogs.com/cnblogs_com/heyonggang/957279/o_qrcode_for_gh_96c5e991bd62_430.jpg">
<br>
微信公众号：
<a target="_blank" href="https://images.cnblogs.com/cnblogs_com/heyonggang/957279/o_qrcode_for_gh_96c5e991bd62_430.jpg">猿人谷 </a>
<br>
如果您认为阅读这篇博客让您有些收获，不妨点击一下右下角的【推荐】
<br>
如果您希望与我交流互动，欢迎关注微信公众号
<br>
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。
</p><p></p>
</div>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-11 16:09">2025-08-11 16:08</span>&nbsp;
<a href="https://www.cnblogs.com/heyonggang">猿人谷</a>&nbsp;
阅读(<span id="post_view_count">294</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19032169);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19032169', targetLink: 'https://www.cnblogs.com/heyonggang/p/19032169', title: 'InnoDB为什么不用跳表，Redis为什么不用B+树？' })">举报</a>
</div>
