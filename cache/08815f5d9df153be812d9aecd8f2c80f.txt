
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18975908" title="发布于 2025-07-09 23:09">
    <span role="heading" aria-level="2">MySQL的三大日志</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>飞机失事靠黑匣子还原真相，MySQL崩溃靠三大日志保障数据安全。</p>
<p>作为一个工作多年的程序员，我见过太多因日志配置不当引发的灾难：数据丢失、主从同步中断、事务回滚失败...</p>
<p>今天，我将用最通俗的方式，带你彻底掌握MySQL三大日志的底层原理，希望对你会有所帮助。</p>
<h2 id="一引子一个数据丢失的教训">一、引子：一个数据丢失的教训</h2>
<p><strong>事故现场</strong>：某电商平台数据库服务器宕机后，发现最近2小时订单数据丢失。</p>
<p><strong>问题根源</strong>：  错误配置导致redo log刷盘失效：</p>
<pre><code class="language-sql">
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_flush_log_at_trx_commit | 0     |  -- 应设为1
+--------------------------------+-------+
</code></pre>
<p><strong>核心结论</strong>：</p>
<ol>
<li>日志系统是MySQL的<strong>安全气囊</strong></li>
<li>不理解日志机制，等于在数据安全上裸奔</li>
</ol>
<h2 id="二redo-log保证持久性的守护神">二、Redo Log：保证持久性的守护神</h2>
<h3 id="21-核心作用崩溃恢复">2.1 核心作用：崩溃恢复</h3>
<p><strong>WAL原则（Write-Ahead Logging）</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250709230842440-44654430.png" class="lazyload"></p>
<h3 id="22-物理结构解析">2.2 物理结构解析</h3>
<p><strong>循环写入机制</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250709230858725-1524930313.png" class="lazyload"></p>
<p><strong>关键参数</strong>：</p>
<pre><code class="language-sql">-- 查看日志配置
SHOW VARIABLES LIKE 'innodb_log%';
+---------------------------+---------+
| Variable_name             | Value   |
+---------------------------+---------+
| innodb_log_file_size      | 50331648| -- 单个日志文件大小
| innodb_log_files_in_group | 2       | -- 日志文件数量
| innodb_log_buffer_size    | 16777216| -- 缓冲区大小
+---------------------------+---------+
</code></pre>
<h4 id="23-刷盘策略实战">2.3 刷盘策略实战</h4>
<pre><code class="language-java">// JDBC事务提交示例
Connection conn = DriverManager.getConnection(url, user, pwd);
try {
    conn.setAutoCommit(false);
    Statement stmt = conn.createStatement();
    stmt.executeUpdate("UPDATE account SET balance=balance-100 WHERE id=1");
    stmt.executeUpdate("UPDATE account SET balance=balance+100 WHERE id=2");
    
    // 核心配置：刷盘策略
    conn.setClientInfo("innodb_flush_log_at_trx_commit", "1");
    conn.commit(); // 触发redo log刷盘
} catch (SQLException e) {
    conn.rollback();
}
</code></pre>
<p><strong>刷盘策略对比</strong>：</p>
<table>
<thead>
<tr>
<th>参数值</th>
<th>安全性</th>
<th>性能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>低（每秒刷）</td>
<td>最高</td>
<td>可丢失数据的缓存</td>
</tr>
<tr>
<td>1</td>
<td>最高（实时）</td>
<td>最低</td>
<td>金融交易系统</td>
</tr>
<tr>
<td>2</td>
<td>中（OS缓存）</td>
<td>较高</td>
<td>常规业务系统</td>
</tr>
</tbody>
</table>
<h3 id="三undo-log事务回滚的时光机">三、Undo Log：事务回滚的时光机</h3>
<h4 id="31-mvcc实现原理">3.1 MVCC实现原理</h4>
<p><strong>多版本控制流程</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250709230918044-1080013820.png" class="lazyload"></p>
<h4 id="32-回滚操作源码级解析">3.2 回滚操作源码级解析</h4>
<pre><code class="language-sql">-- 事务回滚示例
START TRANSACTION;
UPDATE users SET name='张三' WHERE id=1; 
-- 在undo log中记录：
-- | 事务ID | 行ID | 旧值 | 回滚指针 |
-- | 101    | 1    | '李四'| 0x7F8A9B|

ROLLBACK; -- 根据undo log恢复数据
</code></pre>
<h4 id="33-长事务引发的灾难">3.3 长事务引发的灾难</h4>
<p><strong>问题场景</strong>：</p>
<pre><code class="language-sql">-- 查询运行超过60秒的事务
SELECT * FROM information_schema.innodb_trx 
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) &gt; 60;
</code></pre>
<p><strong>严重后果</strong>：</p>
<ol>
<li>Undo Log暴涨占用磁盘空间</li>
<li>历史版本链过长导致查询性能下降</li>
</ol>
<p><strong>解决方案</strong>：</p>
<pre><code class="language-java">@Transactional(timeout = 30) // 单位：秒
public void updateOrder(Order order) {
    // 业务逻辑
}
</code></pre>
<p>Spring Boot项目可以设置事务超时时间。</p>
<h2 id="四binlog主从复制的桥梁">四、Binlog：主从复制的桥梁</h2>
<h3 id="41-三种格式深度对比">4.1 三种格式深度对比</h3>
<table>
<thead>
<tr>
<th>格式</th>
<th>特点</th>
<th>数据安全</th>
<th>复制效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATEMENT</td>
<td>记录SQL语句</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>ROW</td>
<td>记录行变化</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>MIXED</td>
<td>自动切换模式</td>
<td>中</td>
<td>中</td>
</tr>
</tbody>
</table>
<p><strong>ROW格式的优势</strong>：</p>
<pre><code class="language-sql">-- 原始SQL
UPDATE users SET status=1 WHERE age&gt;30;

-- ROW格式binlog实际记录
/* 修改前镜像 */
id:1, status:0, age:35
id:2, status:0, age:40
/* 修改后镜像 */
id:1, status:1, age:35
id:2, status:1, age:40
</code></pre>
<h3 id="42-主从复制全流程剖析">4.2 主从复制全流程剖析</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250709230930737-546847581.png" class="lazyload"></p>
<h3 id="43-数据恢复实战">4.3 数据恢复实战</h3>
<p><strong>场景</strong>：误删全表数据<br>
<strong>恢复步骤</strong>：</p>
<pre><code class="language-bash"># 1. 解析binlog找到删除位置
mysqlbinlog --start-position=763 --stop-position=941 binlog.000001 &gt; recovery.sql

# 2. 提取回滚SQL
grep -i 'DELETE FROM users' recovery.sql

# 3. 生成反向补偿语句
sed 's/DELETE FROM/INSERT INTO/g' recovery.sql &gt; rollback.sql

# 4. 执行恢复
mysql -u root -p &lt; rollback.sql
</code></pre>
<h2 id="五三大日志协同工作图">五、三大日志协同工作图</h2>
<p><strong>更新语句执行流程</strong>：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250709230943725-1415116737.png" class="lazyload"></p>
<p><strong>两阶段提交关键点</strong>：</p>
<ol>
<li>redo log prepare 与 binlog 写入的原子性</li>
<li>崩溃恢复时的决策逻辑：
<ul>
<li>binlog完整：提交事务</li>
<li>binlog不完整：回滚事务</li>
</ul>
</li>
</ol>
<h2 id="六生产环境优化指南">六、生产环境优化指南</h2>
<h3 id="61-参数调优模板">6.1 参数调优模板</h3>
<p>my.cnf 关键配置：</p>
<pre><code class="language-sql">[mysqld]
# Redo Log
innodb_log_file_size = 2G        # 建议4个日志文件
innodb_log_files_in_group = 4
innodb_flush_log_at_trx_commit = 1

# Undo Log
innodb_max_undo_log_size = 1G
innodb_undo_log_truncate = ON
innodb_purge_threads = 4

# Binlog
server_id = 1
log_bin = /data/mysql-bin
binlog_format = ROW
binlog_expire_logs_seconds = 604800 # 保留7天
sync_binlog = 1                   # 每次提交刷盘
</code></pre>
<h3 id="62-监控指标清单">6.2 监控指标清单</h3>
<pre><code class="language-sql">-- 关键监控SQL
SELECT 
  /* Redo Log */
  (SELECT VARIABLE_VALUE 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME='Innodb_os_log_written') AS redo_written,
   
  /* Undo Log */
  (SELECT SUM(DATA_LENGTH) 
   FROM information_schema.TABLES 
   WHERE TABLE_SCHEMA='mysql' 
   AND TABLE_NAME LIKE 'undo%') AS undo_size,
   
  /* Binlog */
  (SELECT VARIABLE_VALUE 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME='Binlog_cache_disk_use') AS binlog_disk_use;
</code></pre>
<h3 id="63-常见问题解决方案">6.3 常见问题解决方案</h3>
<p><strong>问题1</strong>：redo log文件设置过小导致频繁checkpoint。</p>
<p><strong>现象</strong>：</p>
<pre><code class="language-sql">SHOW GLOBAL STATUS LIKE 'Innodb_log_waits';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_log_waits | 542   | -- 值&gt;0表示存在等待
+------------------+-------+
</code></pre>
<p><strong>解决</strong>：</p>
<pre><code class="language-sql"># 动态调整（需重启生效）
SET GLOBAL innodb_log_file_size = 2147483648; 
</code></pre>
<p><strong>问题2</strong>：大事务导致binlog暴涨。</p>
<p><strong>预防方案</strong>：</p>
<pre><code class="language-java">// 事务拆分示例
public void batchProcess(List&lt;Order&gt; orders) {
    int batchSize = 100; // 每100条一个事务
    for (int i=0; i&lt;orders.size(); i+=batchSize) {
        transactionTemplate.execute(status -&gt; {
            List&lt;Order&gt; subList = orders.subList(i, Math.min(i+batchSize, orders.size()));
            processBatch(subList);
            return null;
        });
    }
}
</code></pre>
<h2 id="七总结">七、总结</h2>
<ol>
<li>
<p><strong>Redo Log是生命线</strong>：</p>
<ul>
<li>配置原则：<code>innodb_flush_log_at_trx_commit=1 + 足够大的日志文件</code></li>
<li>监控重点：<code>Innodb_log_waits</code> 应趋近于0</li>
</ul>
</li>
<li>
<p><strong>Undo Log是后悔药</strong>：</p>
<ul>
<li>及时清理：开启 <code>innodb_undo_log_truncate</code></li>
<li>避免长事务：监控 <code>information_schema.innodb_trx</code></li>
</ul>
</li>
<li>
<p><strong>Binlog是复制基石</strong>：</p>
<ul>
<li>格式选择：金融级系统必须用ROW格式</li>
<li>同步策略：主从复制时 <code>sync_binlog=1</code></li>
</ul>
</li>
</ol>
<p>数据库的可靠性不是偶然发生的，而是通过三大日志的精密协作实现的。</p>
<p>当你下次执行<code>COMMIT</code>时，请记住背后有三个强大的守护者在为你工作：</p>
<ol>
<li>Redo Log确保你的数据不会丢失</li>
<li>Undo Log保证你的操作可以撤销</li>
<li>Binlog让数据在集群间流动</li>
</ol>
<blockquote>
<p>敬畏日志，就是敬畏数据安全！</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-09 23:10">2025-07-09 23:09</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">138</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18975908);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18975908', targetLink: 'https://www.cnblogs.com/12lisu/p/18975908', title: 'MySQL的三大日志' })">举报</a>
</div>
        