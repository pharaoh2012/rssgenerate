
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ishoulgodo/p/18696590" title="发布于 2025-02-01 23:24">
    <span role="heading" aria-level="2">java集合中的迭代器Iterator和数组内置方法以及常见的报错</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="删除map的中某一项报错">删除Map的中某一项报错</h4>
<pre><code class="language-java">package part;
import java.util.HashMap;
import java.util.Set;
public class Java01 {
    public static void main(String[] args) {
        // 为啥这里要使用包装类型 Integer， 而不是int
        HashMap&lt;String, Integer&gt; map = new HashMap();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        // 获取所有键名的集合，返回类型是 Set 类型
        Set&lt;String&gt; Keys = map.keySet();
        // 增强型for循环
        for (String keyName : Keys) {
            // 键名相等的话，删除掉, 导致程序报错了呀。 会报错
            if(keyName == "b"){
              //   map.remove(keyName); 删除会报错的
                map.put("n",11); // 新增也是会报错的
                map.put(keyName, 200); // ok的，但是我们最好还是使用迭代器来操作
            }
        }
    }
}

</code></pre>
<h4 id="为啥这里要使用包装类型-integer-而不是int">为啥这里要使用包装类型 Integer, 而不是int</h4>
<p>因为: HashMap的键和值必须是对象类型，不能是基本数据类型。<br>
Java 提供了自动装箱（int 转 Integer）和拆箱（Integer 转 int）的功能<br>
int 类型自动装箱后就是 Integer</p>
<h4 id="为哈会报错呢">为哈会报错呢？</h4>
<p>我们在循环中途的某一项的时候，不光是删除，新增也会报错的<br>
因为:当你使用 for-each 循环遍历 HashMap 的键集合时<br>
for-each 底层是通过 Iterator 实现的<br>
Iterator 会检查集合是否被修改(通过一个 modCount 变量)来判断<br>
如果发现集合被修改(例添加、删除元素)，就会抛出 ConcurrentModificationException</p>
<h4 id="为啥在遍历最后一项的时候删除就不会报错呢">为啥在遍历最后一项的时候删除就不会报错呢</h4>
<pre><code class="language-java">
package part;
import java.util.HashMap;
import java.util.Set;

public class Java01 {
    public static void main(String[] args) {
        //  HashMap的键和值必须是对象类型，不能是基本数据类型。 int 类型自动装箱后就是 Integer  
        HashMap&lt;String, Integer&gt; map = new HashMap();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        // 获取所有键名的集合，返回类型是 Set 类型
        Set&lt;String&gt; Keys = map.keySet();
        // 增强型for循环
        for (String keyName : Keys) {
            // 当遍历最后一项的时候，删除就不会报错
            if(keyName == "c"){
                map.remove(keyName);
            }
        }
    }
}
</code></pre>
<h4 id="解释为什么删除最后一项不会报错">解释:为什么删除最后一项不会报错？</h4>
<p>这个跟(ConcurrentModificationException)触发机制<br>
(ConcurrentModificationException) 是通过 modCount 变量来检测集合是否被修改的。<br>
在遍历集合时，Iterator 会检查 modCount 是否与预期值一致。如果不一致(即集合被修改)，就会抛出异常。<br>
当你删除最后一项时，Iterator 可能已经完成了遍历，因此不会触发 modCount 的检查。<br>
因此也就不会报错哈</p>
<h4 id="修改数据最好使用迭代器来处理">修改数据最好使用迭代器来处理</h4>
<pre><code class="language-java">package part;


import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

public class Java01 {
    public static void main(String[] args) {
        // 为啥这里要使用包装类型 Integer， 而不是int
        HashMap&lt;String, Integer&gt; map = new HashMap();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        Set&lt;String&gt; keys = map.keySet();
        // 迭代器
        Iterator&lt;String&gt; it =keys.iterator();
        // hasNext方法用于办法是否存在下一条数据
        while (it.hasNext()) {
            // 获取下一条数据
            String key = it.next();
            // 删除键名是b这一项
            if("b".equals(key)){
                it.remove();
            }
            // 1 null 3
            System.out.println(map.get(key));
        }
        // {a=1, c=3}
        System.out.println(map);
    }
}
</code></pre>
<h4 id="使用-removeif-方法java-8迭代">使用 removeIf() 方法(Java 8+)迭代</h4>
<pre><code>HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);

Set&lt;String&gt; keys = map.keySet();
keys.removeIf(keyName -&gt; keyName.equals("c")); // 使用 removeIf
System.out.println(map); // 输出: {a=1, b=2}
</code></pre>
<h4 id="使用迭代器能够删除其他项吗">使用迭代器能够删除其他项吗？</h4>
<p>就是说：我们在循环a这一项的时候，可以删除b这一项的数据吗？<br>
不可以的。<br>
因为:只能够删除当前循环的这一项的。再说一次：只能够删除当前循环的这一项的</p>
<h4 id="将数组转化为字符串--arraystostring">将数组转化为字符串  Arrays.toString()</h4>
<pre><code class="language-java">
package part;

import java.util.Arrays;
public class Java01 {
    public static void main(String[] args) {
        // 声明并初始化一个 int 数组
        int[] is= {1, 2, 3, 4, 5};
        // 转化为字符串 [1, 2, 3, 4, 5]
        String str = Arrays.toString(is);
        System.out.println(str);
        // [I@28d93b30 是hashCode的内存地址
        System.out.println(is);
    }
}
</code></pre>
<h4 id="将数组转化为集合以及升序">将数组转化为集合以及升序</h4>
<pre><code class="language-java">package part;

import java.util.Arrays;
import java.util.List;

public class Java01 {
    public static void main(String[] args) {
        // 将数组转化为集合
        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
        int[] arr =  {4,1,-3,10 };
        // Arrays.sort 默认是升序的哈,会影响原始数组的哈，与js不同的
        Arrays.sort(arr);
        // [-3, 1, 4, 10]
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<h4 id="二分查找法查找的是排序后的位置">二分查找法,查找的是排序后的位置</h4>
<pre><code class="language-java">package part;

import java.util.Arrays;
import java.util.List;

public class Java01 {
    public static void main(String[] args) {
        int[] arr =  {4,1,-3,10 };
        Arrays.sort(arr);
        // [-3, 1, 4, 10]
        System.out.println(Arrays.toString(arr));
        // 查询4的位置
        int index = Arrays.binarySearch(arr, 4);
        // 2
        System.out.println(index);
    }
}
</code></pre>
<h4 id="2个数组项比较">2个数组项比较</h4>
<pre><code class="language-java">package part;
import java.util.Arrays;
import java.util.List;

public class Java01 {
    public static void main(String[] args) {
        int[] arr1 =  {4,1,-3,10 };
        int[] arr2 = {4,1,10, -3};
        // 会比较2个数组是否相等，会一对一进行比较。 第2项的-3和第2项的10不相等，返回flase
        System.out.println(Arrays.equals(arr1,arr2)); // false
    }
}
</code></pre>
<pre><code class="language-java">package part;

import java.util.Arrays;
import java.util.List;

public class Java01 {
    public static void main(String[] args) {
        int[] arr1 = {4, 1, -3, 10};
        int[] arr2 = {4, 1, 10, -3};
        //arr1, 0, 2表示从arr1数组中，从0开始取，取前2个。 arr2, 0, 2表示从arr2数组中，从0开始取，取前2个
        // 特别需要注意一点的是： 是在 JDK 9 中引入的。如果你使用的是 JDK 8 或更早版本，这个方法会报错。
        System.out.println(Arrays.equals(arr1, 0, 2, arr2, 0, 2)); // 输出: true
    }
}
</code></pre>
<h4 id="arraylist-集合默认时长度10你设置容器大小必须大于等于0如果是负数会报错">ArrayList 集合默认时长度10,你设置容器大小必须大于等于0。如果是负数会报错</h4>
<pre><code class="language-java">
package part;

import java.util.ArrayList;
public class Java01 {
    public static void main(String[] args) {
        ArrayList&lt;String &gt; list2 = new ArrayList&lt;String&gt;(0);
        System.out.println(list2); // []

       ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(-1);
       System.out.println(list1); //  ava.lang.IllegalArgumentException 非法参数异常
    }
}
</code></pre>
<h4 id="arraylist的访问范围是0长度-1">ArrayList的访问范围是[0,长度-1]</h4>
<pre><code class="language-java">package part;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Java01 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("A");
        list.add("B");
        list.add("C");
        // 访问的范围是[0,长度-1]
        System.out.println(list.get(2));
        // IndexOutOfBoundsException 索引超出异常
        System.out.println(list.get(3));
    }
}
</code></pre>
<h4 id="linkedlist的长度是0使用get0和getfirst访问报错">LinkedList的长度是0,使用get(0)和getFirst访问报错</h4>
<pre><code class="language-java">package part;

import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
       LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
       //报错 IndexOutOfBoundsException
       System.out.println(list.get(0));
       // list的长度是0， 现在你获取第1项，这样的操作跟索引越界相似。同样也是会报错的
        // java.util.NoSuchElementException
       System.out.println(list.getFirst());
    }
}
</code></pre>
<h4 id="hashmap在循环的时候删除新增数据会报错">HashMap在循环的时候删除，新增数据会报错</h4>
<pre><code class="language-java">
package part;
import java.util.HashMap;
import java.util.LinkedList;

public class Java01 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("a",1);
        map.put("b",2);
        map.put("c",3);
        // HashMap一旦开始循环，那么如果删除，新增数据，就会发生错误
        for (Object key : map.keySet()) {
            if(key.equals("b")){
               // map.remove(key); 删除数据报错
               //  map.put("d",4); 新增数据报错
                map.put(key,4); // 修改数据不会报错的哈
            }
        }
        // 我们可以使用迭代器还解决这样的问题哈。
        System.out.println(map);
    }
}
</code></pre>
<h4 id="尾声">尾声</h4>
<p>准备开始学习java了。<br>
今天学习的第五天，每天都会发文章，我要卷起来。<br>
请小伙伴们监督我，奥利给</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/ishoulgodo/" target="_blank">流年少年</a> <br>
		        出处：<a href="https://www.cnblogs.com/ishoulgodo/">https://www.cnblogs.com/ishoulgodo/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
		    </div>
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.9525617095289352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-01 23:24">2025-02-01 23:24</span>&nbsp;
<a href="https://www.cnblogs.com/ishoulgodo">何人陪我共长生</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18696590" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18696590);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18696590', targetLink: 'https://www.cnblogs.com/ishoulgodo/p/18696590', title: 'java集合中的迭代器Iterator和数组内置方法以及常见的报错' })">举报</a>
</div>
        