
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vigourice/p/18622383" title="发布于 2024-12-22 20:23">
    <span role="heading" aria-level="2">构建模块化 CLI：Lerna + Commander 打造灵活的基础脚手架</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在现代软件开发中，创建 <strong>定制化的命令行工具(CLI)</strong> 已成为满足公司业务需求的关键一环。这类工具可以辅助执行诸如代码检查、项目初始化等任务。为了提高开发效率并简化维护过程，我们将功能模块化，并通过多个子包来组织这些功能。本文将介绍如何使用 <code>Lerna</code> 来管理一个多包项目，并基于 <code>Commander</code> 实现一个基础的 <code>CLI</code> 脚手架框架。</p>
<h1 id="初始化创建入口文件">初始化：创建入口文件</h1>
<h2 id="项目结构">项目结构</h2>
<p>我们以 <code>ice-basic-cli</code> 为例，这是一个空的 CLI 项目。首先，通过 <code>lerna init</code> 初始化 Lerna 项目，然后使用 <code>lerna create cli</code> 创建入口子包。这一步将在项目的根目录下生成 <code>packages/cli</code> 文件夹，其内部结构如下：</p>
<pre><code>ice-basic-cli/
├── .git/
├── packages/
│ &nbsp; └── cli/
│ &nbsp; &nbsp; &nbsp; ├── __tests__
│ &nbsp; &nbsp; &nbsp; │ &nbsp; └── cli.test.js
│ &nbsp; &nbsp; &nbsp; ├── lib/
│ &nbsp; &nbsp; &nbsp; │ &nbsp; └── index.js
│ &nbsp; &nbsp; &nbsp; ├── bin/
│ &nbsp; &nbsp; &nbsp; │ &nbsp; └── cli.js
│ &nbsp; &nbsp; &nbsp; ├── package.json
│ &nbsp; &nbsp; &nbsp; └── README.md
├── .gitignore
├── lerna.json
└── package.json
</code></pre>
<h2 id="cli-入口配置">CLI 入口配置</h2>
<p><code>cli/bin/cli.js</code> 是 CLI 的入口文件，它负责接收命令行参数并调用相应的逻辑处理函数。为确保脚本可执行，我们在文件顶部添加了 <code>shebang</code> 行 (#!/usr/bin/env node)，并且导入了 lib/index.js 中定义的入口函数。</p>
<pre><code class="language-javascript">// bin/cli.js
#!/usr/bin/env node
import entry from "../lib/index.js";
entry(process.argv);
</code></pre>
<p>对于不熟悉初始化命令中的 <code>shebang</code> 行（#!/usr/bin/env node）或 <code>bin</code> 入口文件概念的朋友，建议参考 <a href="https://www.cnblogs.com/vigourice/p/18538586" target="_blank">Node.js 构建命令行工具：实现 ls 命令的 -a 和 -l 选项</a> 这篇文章，它提供了详细的解释和示例。</p>
<h2 id="命令行接口实现">命令行接口实现</h2>
<p><code>lib/index.js</code> 提供了 CLI 的核心逻辑，包括对 <code>Commander</code> 的初始化和自定义命令的注册。这里我们定义了一个简单的 init 命令。</p>
<pre><code class="language-javascript">import { program } from 'commander';
import createCli from './createCli.js';
export default function (args) {
&nbsp; &nbsp; const cli = createCli();
&nbsp; &nbsp;
&nbsp; &nbsp; // 定义命令及其行为
&nbsp; &nbsp; cli.command('init [name]')
&nbsp; &nbsp; &nbsp; &nbsp; .description('初始化新项目')
&nbsp; &nbsp; &nbsp; &nbsp; .action((name) =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(`&gt;&gt; Initializing project: ${name}`);
&nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; cli.parse(args);
}
</code></pre>
<p>同时，在 <code>lib/createCli.js</code> 中，我们封装了 <code>Commander</code> 的初始化设置，使得其他部分可以复用此配置。</p>
<pre><code class="language-javascript">import { program } from "commander";
export default function createCli() {
&nbsp; return program
&nbsp; &nbsp; .name("@ice-basic-cli/cli")
&nbsp; &nbsp; .version("0.0.1", "-v, --version", "显示当前版本")
&nbsp; &nbsp; .option("-d, --debug", "开启调试模式", false);
}
</code></pre>
<h2 id="包配置与依赖安装">包配置与依赖安装</h2>
<p>为了使我们的 CLI 可以全局调用，需要正确配置 <code>package.json</code> 中的 <code>bin</code> 字段指向入口文件。此外，我们还指定了 <code>"type": "module"</code> 以启用 <code>ES Module</code> 支持，从而保证与最新的 JavaScript 生态系统的兼容性。</p>
<pre><code class="language-json">{  
&nbsp; "name": "@ice-basic-cli/cli",
&nbsp; "version": "0.0.1",
  "main": "bin/cli.js",
&nbsp;   "bin": {
&nbsp; &nbsp;   "@ice-basic-cli/cli": "./bin/cli.js"
&nbsp; },
 "type": "module",
 ...
}
</code></pre>
<p>接下来，通过 <code>cnpm install commander --save --workspace=packages/cli</code> 安装所需的 Commander 库，并通过 <code>npm link --workspace=packages/cli</code> 创建本地符号链接以便测试。</p>
<h2 id="模块化选择es-modules-vs-commonjs">模块化选择：ES Modules vs CommonJS</h2>
<p>在项目中，我们选择了 <code>ES Modules</code> 作为默认的模块系统，而非传统的 <code>CommonJS</code>。这是因为 <code>ES Modules</code> 更加现代化，提供了更好的互操作性和静态分析支持。更重要的是，随着越来越多的库开始采用 <code>ES Modules</code> 格式，保持一致的模块化标准有助于减少潜在的问题，确保项目的长期可持续性。</p>
<p>完成上述配置后，在 Git Bash 中运行命令 <code>npx @ice-basic-cli/cli</code>  可以看到如下结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202412/1408181-20241222182130308-773375146.png" alt="" loading="lazy"></p>
<h1 id="抽象-command-类构建模块化-cli-命令">抽象 Command 类：构建模块化 CLI 命令</h1>
<p>为了让命令行工具（<code>CLI</code>）中的命令更加实用，并能作为独立的子包使用，我们将命令逻辑抽象为一个通用的 <code>Command</code> 父类。这样不仅提高了代码的可维护性和复用性，也为后续扩展奠定了基础。</p>
<h2 id="定义公共的-command-父类">定义公共的 Command 父类</h2>
<p>首先，我们使用 <code>lerna create command</code> 创建一个新的子包来存放 <code>Command</code> 父类。这将在项目的 <code>packages/</code> 目录下生成一个新的文件夹 <code>command</code>，其中包含所有必要的文件结构。</p>
<p>在 <code>command/lib/command.js</code> 中定义 <code>Command</code> 类，该类封装了创建命令的基本逻辑，同时提供钩子函数以支持命令执行前后的自定义行为。</p>
<pre><code class="language-javascript">class Command {
&nbsp; constructor(instance) {
&nbsp; &nbsp; if (!instance) {
&nbsp; &nbsp; &nbsp; throw new Error("Command instance must not be null");
&nbsp; &nbsp; }
&nbsp; &nbsp; this.program = instance;
&nbsp; &nbsp; const cmd = this.program.command(this.command);
&nbsp; &nbsp; cmd.description(this.description);
&nbsp; &nbsp; cmd.usage(this.usage);
&nbsp; &nbsp; // 添加命令生命周期钩子
&nbsp; &nbsp; cmd.hook('preAction', () =&gt; this.preAction());
&nbsp; &nbsp; cmd.hook('postAction', () =&gt; this.postAction());
&nbsp; &nbsp; // 添加命令选项
&nbsp; &nbsp; if (this.options?.length &gt; 0) {
&nbsp; &nbsp; &nbsp; this.options.forEach(option =&gt; cmd.option(...option));
&nbsp; &nbsp; }
&nbsp; &nbsp; // 设置命令的行为
&nbsp; &nbsp; cmd.action((...params) =&gt; this.action(...params));
&nbsp; }
&nbsp; get command() {
&nbsp; &nbsp; throw new Error("The 'command' getter must be implemented in a subclass.");
&nbsp; }
&nbsp; get description() {
&nbsp; &nbsp; throw new Error("The 'description' getter must be implemented in a subclass.");
&nbsp; }
&nbsp; get options() {
&nbsp; &nbsp; return [];
&nbsp; }
&nbsp; get usage() {
&nbsp; &nbsp; return '[options]';
&nbsp; }
&nbsp; action(...params) {
&nbsp; &nbsp; throw new Error("The 'action' method must be implemented in a subclass.");
&nbsp; }
&nbsp; preAction() {}
&nbsp; postAction() {}
}
export default Command;
</code></pre>
<p>接着，确保 package.json 文件中正确配置了名称和模块类型：</p>
<pre><code class="language-javascript">{    
    "name": "@ice-basic-cli/command",
    "type": "module",
}
</code></pre>
<h2 id="实现具体的子类命令">实现具体的子类命令</h2>
<p>接下来，我们创建一个特定的命令子类 <code>InitCommand</code> 来实现 <code>init</code> 功能。通过 <code>lerna create init</code> 创建新的子包，修改 package.json 中的配置：</p>
<pre><code class="language-javascript">{
    "name": "@ice-basic-cli/init",
    "type": "module",
}
</code></pre>
<p>并安装 <code>@ice-basic-cli/command</code> 作为依赖：</p>
<pre><code class="language-javascript">npm install @ice-basic-cli/command --workspace=packages/cli
</code></pre>
<p>然后，在 <code>init/lib/init.js</code> 中实现继承自 <code>Command</code> 的 <code>InitCommand</code> 类：</p>
<pre><code class="language-javascript">"use strict";
import Command from "@ice-basic-cli/command";
class InitCommand extends Command {
&nbsp; get command() {
&nbsp; &nbsp; return "init [name]";
&nbsp; }
&nbsp; get options() {
&nbsp; &nbsp; return [["-f, --force", "是否强制更新", false]];
&nbsp; }
&nbsp; get description() {
&nbsp; &nbsp; return "初始化项目";
&nbsp; }
&nbsp; action([name], { force }) {
&nbsp; &nbsp; console.log(`Initializing project: ${name}, Force mode: ${force}`);
&nbsp; }
}
function createInitCommand(instance) {
&nbsp; return new InitCommand(instance);
}
export default createInitCommand;
</code></pre>
<p>最后一步是将新创建的 <code>InitCommand</code> 整合进主 CLI 应用。为此，在 cli 子包中添加 <code>@ice-basic-cli/init</code> 依赖：</p>
<pre><code class="language-javascript">npm install @ice-basic-cli/init --workspace=packages/cli
</code></pre>
<p>并修改 cli/lib/index.js 文件，使其引用并注册 InitCommand：</p>
<pre><code class="language-javascript">"use strict";
import createCli from "./createCli.js";
import createInitCommand from "@ice-basic-cli/init";
export default function (args) {
&nbsp; const cli = createCli();
&nbsp; createInitCommand(cli);
&nbsp; cli.parse(args);
}
</code></pre>
<p>此时，运行 <code>npx @ice-basic-cli/cli</code> 时，能够看到与之前一致的结果，但现在的架构更加模块化，便于维护和扩展。</p>
<h1 id="工具函数的封装与集成">工具函数的封装与集成</h1>
<p>在构建复杂CLI工具时，通常会遇到一些通用的功能需求，比如路径判断、日志记录等。为了提高代码复用性和项目的模块化程度，我们将这些功能封装为独立的子包，确保它们可以在项目中的任何地方使用。</p>
<h2 id="创建-utils-子包">创建 utils 子包</h2>
<p>首先，通过 <code>lerna create utils</code> 命令创建一个新的子包来存放工具函数，并修改默认生成的文件结构以适应 <code>ES Modules</code> 标准。具体步骤如下：</p>
<ol>
<li>
<p><strong>重命名并配置入口文件</strong>：将 <code>lib/util.js</code> 重命名为 <code>lib/index.js</code>，并在 <code>package.json</code> 中指定正确的入口点。</p>
<pre><code class="language-javascript">{
    "name": "@ice-basic-cli/utils",
    "main": "lib/index.js",
    "type": "module",
}
</code></pre>
</li>
<li>
<p><strong>实现调试状态检测</strong>：在 <code>lib/isDebug.js</code> 中定义一个简单的函数用于判断是否启用了调试模式。</p>
<pre><code class="language-javascript">function isDebug() {
  return process.argv.includes("--debug") || process.argv.includes("-d");
}
export default isDebug;
</code></pre>
</li>
<li>
<p><strong>统一封装日志输出</strong>：创建 <code>lib/log.js</code> 文件，借助 <code>npmlog</code> 库实现统一的日志格式。首先安装依赖：</p>
<pre><code class="language-javascript">npm install npmlog --save --workspace=packages/utils
</code></pre>
<p>然后编写代码：</p>
<pre><code class="language-javascript">import log from 'npmlog';
import isDebug from './isDebug.js';

if (isDebug()) {
  log.level = "verbose";
} else {
  log.level = "info";
}

log.heading = "ice-basic-cli";
log.addLevel("success", 2000, { fg: "green", bold: true, bg: "red" });
export default log;
</code></pre>
</li>
<li>
<p><strong>处理 ES Module 的路径问题</strong>：由于 ES Modules 不直接支持 <code>__filename</code> 和 <code>__dirname</code>，我们创建 <code>lib/getPath.js</code> 来提供替代方案。</p>
<pre><code class="language-javascript">import { fileURLToPath } from "url";
import { dirname as pathDirname } from "path";
export function dirname(importMeta) {
  const file = filename(importMeta);
  return file !== "" ? pathDirname(file) : "";
}
export function filename(importMeta) {
  return importMeta.url ? fileURLToPath(importMeta.url) : "";
}
</code></pre>
</li>
<li>
<p><strong>导出工具函数</strong>：最后，在 <code>lib/index.js</code> 中导出所有工具函数，以便其他模块可以方便地引用。</p>
<pre><code class="language-javascript">"use strict";
import log from "./log.js";
import isDebug from "./isDebug.js";
import { dirname, filename } from "./getPath.js";
export { log, isDebug, dirname, filename };
</code></pre>
</li>
</ol>
<h2 id="集成工具函数到-cli-子包">集成工具函数到 CLI 子包</h2>
<p>完成 <code>utils</code> 子包后，我们需要将其集成到主 <code>CLI</code> 应用中。这一步骤包括安装依赖以及增强命令行接口的功能。</p>
<h3 id="安装工具函数包">安装工具函数包</h3>
<p>执行以下命令安装 <code>@ice-basic-cli/utils</code> 作为依赖：</p>
<pre><code class="language-javascript">npm install @ice-basic-cli/utils --workspace=packages/cli
</code></pre>
<h3 id="增强命令行接口功能">增强命令行接口功能</h3>
<p>接下来，我们可以进一步完善 <code>cli/lib/createCli.js</code> 文件，添加自动获取 <code>package.json</code> 版本号和名称的能力，加入 <code>NodeJS</code> 版本校验，并监听未知命令。此外，还需要安装几个辅助库：</p>
<pre><code class="language-javascript">npm install semver chalk fs-extra --save --workspace=packages/cli
</code></pre>
<p>下面是更新后的 <code>createCli.js</code> 文件：</p>
<pre><code class="language-javascript">"use strict";
import { program } from "commander";
import semver from "semver";
import { dirname, log } from "@ice-basic-cli/utils";
import { resolve } from "path";
import fse from "fs-extra";
import chalk from "chalk";

const __dirname = dirname(import.meta);
const pkgPath = resolve(__dirname, "../package.json");
const pkg = fse.readJSONSync(pkgPath);

function preAction() {
&nbsp; checkNodeVersion();
}
const LOWEST_NODE_VERSION = "18.0.0";
function checkNodeVersion() {
&nbsp; if (!semver.gte(process.version, LOWEST_NODE_VERSION)) {
&nbsp; &nbsp; const message = `ice-basic-cli 需要安装 ${LOWEST_NODE_VERSION} 或更高版本的 Node.js`;
&nbsp; &nbsp; throw new Error(chalk.red(message));
&nbsp; }
}

export default function createCli() {
&nbsp; program
&nbsp; &nbsp; .name(Object.keys(pkg.bin)[0])
&nbsp; &nbsp; .usage("&lt;command&gt; [options]")
&nbsp; &nbsp; .version(pkg.version)
&nbsp; &nbsp; .option("-d, --debug", "是否开启调试模式", false)
&nbsp; &nbsp; .hook("preAction", preAction)
&nbsp; &nbsp; .on("option:debug", function () {
&nbsp; &nbsp; &nbsp; if (program.opts().debug) {
&nbsp; &nbsp; &nbsp; &nbsp; log.verbose("debug", "launch debug mode");
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; })
&nbsp; &nbsp; .on("command:*", function (obj) {
&nbsp; &nbsp; &nbsp; log.info("未知命令：" + obj[0]);
&nbsp; &nbsp; });
&nbsp; return program;
}
</code></pre>
<h3 id="添加全局错误处理">添加全局错误处理</h3>
<p>为了提升用户体验，我们还在 <code>cli/lib/index.js</code> 中增加了全局错误捕获机制，确保未处理的异常和未捕获的 Promise 拒绝不会导致程序崩溃。</p>
<pre><code class="language-javascript">"use strict";
import createInitCommand from "@ice-basic-cli/init";
import createCli from "./createCli.js";
import { isDebug, log } from "@ice-basic-cli/utils";

export default function (args) {
&nbsp; const program = createCli();
&nbsp; createInitCommand(program);
&nbsp; program.parse(args);
}

process.on("uncaughtException", (e) =&gt; printErrorLog(e, "uncaughtException"));
process.on("unhandleRejection", (e) =&gt; printErrorLog(e, "unhandleRejection"));

function printErrorLog(e) {
&nbsp; if (isDebug()) {
&nbsp; &nbsp; log.info(e);
&nbsp; } else {
&nbsp; &nbsp; log.info(e.message);
&nbsp; }
}
</code></pre>
<h3 id="优先使用本地依赖">优先使用本地依赖</h3>
<p>最后，我们可以通过引入 <code>import-local</code> 来优化 <code>bin/cli.js</code> 文件，使得如果本地项目存在同名命令行工具，则优先使用本地版本。这样做不仅保证了开发环境的一致性，还能加快命令执行速度。</p>
<p>首先安装依赖：</p>
<pre><code class="language-javascript">npm install import-local --save --workspace=packages/cli
</code></pre>
<p>然后修改 <code>bin/cli.js</code> 文件：</p>
<pre><code class="language-javascript">#!/usr/bin/env node
import importLocal from "import-local";
import { log, filename } from "@ice-base-cli/utils";
import entry from "../lib/index.js";
const __filename = filename(import.meta);

if (importLocal(__filename)) {
&nbsp; log.info("cli", "使用本次 cli");
} else {
&nbsp; log.info("远程 cli");
&nbsp; entry(process.argv);
}
</code></pre>
<p>以上便是整个多包框架的构建过程。通过这种方式，我们不仅提高了CLI工具的功能性和灵活性，还增强了其可维护性和扩展性。</p>
<h1 id="发布-npm">发布 npm</h1>
<p>以 @组织名/包名 的格式发布 NPM 包，首先需要在 npmjs.com 上注册一个组织（Organization）。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202412/1408181-20241222182102333-857983253.png" alt="" loading="lazy"></p>
<p>在发布前，建议更新每个子包的版本号。由于我们对整个项目进行了修改，采用一键发布的方式更为方便。只需执行以下命令即可发布所有修改过的子包：</p>
<pre><code class="language-javascript">npm publish --workspaces --access=public
</code></pre>
<p>该命令会遍历所有的工作区，检查是否有新的改动需要发布，并将这些改动以公共访问权限发布到 NPM。</p>
<p>如果你对前端工程化有兴趣，或者想了解更多相关的内容，欢迎查看我的其他文章，这些内容将持续更新，希望能给你带来更多的灵感和技术分享~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.535693189313657" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-05 22:01">2024-12-22 20:23</span>&nbsp;
<a href="https://www.cnblogs.com/vigourice">一颗冰淇淋</a>&nbsp;
阅读(<span id="post_view_count">96</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18622383" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18622383);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18622383', targetLink: 'https://www.cnblogs.com/vigourice/p/18622383', title: '构建模块化 CLI：Lerna + Commander 打造灵活的基础脚手架' })">举报</a>
</div>
	