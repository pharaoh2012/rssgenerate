
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18645358" title="发布于 2025-01-01 10:59">
    <span role="heading" aria-level="2">[Flink] Flink运行过程中Flink作业运行崩溃，且`TaskManager`报:"Association with remote system [akka.tcp://flink@flink-236429.ns-69020:6123] has failed, address is now gated for [50] ms. Reason: [Disassociated]"</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-问题描述">1 问题描述</h1>
<ul>
<li>一个长期正常运行的FlinkSqlCdcJob(<code>Flink 1.12</code> 、 <code>Flink CDC 1.3.0</code>)，运行崩溃，且<code>TaskManager</code>的日志(<code>taskmanager.log</code>)报: akka 异常</li>
</ul>
<blockquote>
<ul>
<li>作业运行崩溃的时间点: <code>2025/01/01 09:24:17</code></li>
</ul>
</blockquote>
<pre><code class="language-log">...
2025-01-01 09:22:14,965 INFO  org.apache.flink.streaming.api.functions.sink.TwoPhaseCommitSinkFunction [] - FlinkKafkaProducer 1/1 - checkpoint 16699 complete, committing transaction TransactionHolder{handle=KafkaTransactionState [transactionalId=null, producerId=-1, epoch=-1], transactionStartTime=1735694353482} from checkpoint 16699
2025-01-01 09:24:06,449 WARN  akka.remote.ReliableDeliverySupervisor                       [] - Association with remote system [akka.tcp://flink-metrics@flink-236429.ns-69020:45033] has failed, address is now gated for [50] ms. Reason: [Disassociated] 
2025-01-01 09:24:06,450 WARN  akka.remote.ReliableDeliverySupervisor                       [] - Association with remote system [akka.tcp://flink@flink-236429.ns-69020:6123] has failed, address is now gated for [50] ms. Reason: [Disassociated] 
&lt;end&gt;
</code></pre>
<ul>
<li>对比<code>JobManager</code>的日志：无任何异常信息</li>
</ul>
<pre><code class="language-log">...
2025-01-01 09:19:14,060 INFO  org.apache.flink.runtime.checkpoint.CheckpointCoordinator    [] - Completed checkpoint 16698 for job 1dd034557a79ca16f8b692f44cbcf5b2 (1578642 bytes in 499 ms).
2025-01-01 09:22:14,232 INFO  org.apache.flink.runtime.checkpoint.CheckpointCoordinator    [] - Triggering checkpoint 16699 (type=CHECKPOINT) @ 1735694534059 for job 1dd034557a79ca16f8b692f44cbcf5b2.
2025-01-01 09:22:14,963 INFO  org.apache.flink.runtime.checkpoint.CheckpointCoordinator    [] - Completed checkpoint 16699 for job 1dd034557a79ca16f8b692f44cbcf5b2 (1578642 bytes in 591 ms).
&lt;end&gt;
</code></pre>
<h1 id="2-问题分析">2 问题分析</h1>
<h2 id="解读错误日志">解读错误日志</h2>
<ul>
<li><code>Association with remote system [akka.tcp://flink-metrics@flink-236429.ns-69020:45033] has failed, address is now gated for [50] ms. Reason: [Disassociated]</code></li>
</ul>
<blockquote>
<p>与远程系统[akka.tcp://flink-metrics@flink-236429.ns-69020:45033]关联失败，地址现在的阈值是[50]ms。原因：[断联/解除关联]</p>
</blockquote>
<ul>
<li>报错信息提示存在与远程系统的关联问题，具体是与名为 <code>flink</code> 的<code>Akka</code>系统在 <code>flink-236429.ns-69020</code> 主机的<code>6123</code>端口上的关联。</li>
</ul>
<blockquote>
<p>这个报错提示说明 <code>Jobmanager</code> 和 <code>TaskManager</code> 中的某个节点<strong>失去了联系</strong>，导致任务无法正常运行。<br>
可能是由于网络中断、节点宕机等原因导致的。<br>
需要检查<strong>集群节点</strong>的状态以及<strong>网络连接</strong>是否正常。</p>
</blockquote>
<h2 id="akka系统">Akka系统</h2>
<h3 id="flink的rpc实现基于scala的网络编程库akka来的">Flink的RPC实现：基于Scala的网络编程库Akka来的</h3>
<h3 id="akka-简介用于构建可伸缩高可用性低延迟的java和scala应用程序的消息传递框架rpc远程调用框架">Akka 简介：用于构建可伸缩、高可用性、低延迟的<code>Java</code>和<code>Scala</code><strong>应用程序</strong>的<strong>消息传递框架/RPC远程调用框架</strong></h3>
<ul>
<li><code>Akka</code>是一个用于构建可伸缩、高可用性、低延迟的<code>Java</code>和<code>Scala</code><strong>应用程序</strong>的<strong>消息传递框架</strong></li>
</ul>
<blockquote>
<p>常用于构建<strong>大数据处理平台</strong><code>Apache Flink</code> / <code>Spark</code> 的<code>actor</code>系统。</p>
</blockquote>
<ul>
<li><code>Akka</code>是一个构建<strong>高度并发</strong>和<strong>分布式应用</strong>的<strong>工具包</strong>和<strong>运行时环境</strong></li>
</ul>
<blockquote>
<p>它基于Scala语言，但也支持Java。</p>
</blockquote>
<ul>
<li>Akka系统的核心作用和特点，包括：</li>
</ul>
<ol start="0">
<li><strong>并发性</strong>：Akka利用Actor模型来实现并发性，Actor是Akka中的基本并发单元。</li>
</ol>
<blockquote>
<p>对并发模型进行了更高的抽象。<br>
每个Actor都是一个并发执行的对象，它们之间通过消息传递来通信，这样可以避免共享状态和锁的使用，从而简化并发编程。</p>
</blockquote>
<ol>
<li>轻量</li>
</ol>
<blockquote>
<p>轻量级事件处理（1GB内存可以以容纳百万级别的Actor）</p>
</blockquote>
<ol start="2">
<li>异步、非阻塞、高性能的<strong>事件驱动编程模型</strong></li>
</ol>
<blockquote>
<p><strong>事件驱动架构</strong>：Akka适合构建事件驱动的架构，因为它可以轻松处理异步事件流，并且可以与各种消息队列和事件源集成。</p>
</blockquote>
<ol start="3">
<li>
<p><strong>分布式系统</strong>：Akka支持构建分布式系统，允许Actor系统跨越多个节点和JVM实例。这意味着你可以在多个服务器上部署你的应用，并且这些服务器上的Actor可以像在同一个JVM中一样相互通信。</p>
</li>
<li>
<p><strong>容错性</strong>：Akka提供了监督和监控机制，允许开发者定义Actor如何响应其他Actor的失败。这使得构建容错系统变得更加容易，因为你可以定义恢复策略，如重启失败的Actor或停止它们。</p>
</li>
<li>
<p><strong>可伸缩性</strong>：由于Akka的Actor模型天然支持并发和分布式，因此可以轻松地通过增加更多的节点来扩展系统，以处理更多的负载。</p>
</li>
<li>
<p><strong>消息驱动</strong>：Akka系统是消息驱动的，Actor通过消息传递来交互，这有助于解耦系统组件，并使得系统更加模块化。</p>
</li>
<li>
<p><strong>持久性和持久状态</strong>：Akka支持持久化Actor状态，这意味着即使Actor重启，它们的状态也可以被恢复，这对于需要持久化状态的系统（如CQRS系统）非常有用。</p>
</li>
<li>
<p><strong>插件和模块化</strong>：Akka提供了丰富的插件生态系统，允许开发者添加额外的功能，如持久化、分布式缓存、监控等。</p>
</li>
<li>
<p><strong>跨语言支持</strong>：虽然Akka最初是为Scala设计的，但它也提供了对Java的支持，使得Java开发者也可以利用Akka构建并发和分布式系统。</p>
</li>
<li>
<p><strong>集成和兼容性</strong>：Akka可以与现有的Java和Scala生态系统无缝集成，包括各种数据库、消息队列和Web框架。</p>
</li>
</ol>
<blockquote>
<p><code>Akka</code>系统的<strong>设计哲学</strong>是“<code>一切皆Actor</code>”，这使得它非常适合构建复杂的并发和分布式系统，同时保持代码的可读性和可维护性。</p>
</blockquote>
<h3 id="akka原理">Akka原理</h3>
<ul>
<li><code>Akka</code>是一个网络编程库</li>
</ul>
<blockquote>
<ul>
<li><code>Akka</code>有2个重要的组成部分：<code>Actor</code>，<code>ActorSystem</code></li>
</ul>
</blockquote>
<pre><code class="language-txt">可简单的理解为ActorSystem是一个小组，其中的Actor是一个组员。
我们开发过程中不可能是组和组之间的交流吧，肯定是【组员】和【组员】之间的交流，也就是【Actor】和【Actor】之间的通信

假如组员之间是【打电话】的话，那么是不是就【阻塞】了，你打电话啥都干不了了。
所以他们之间可以【发短信】，每个人都有手机，他们通过手机交流。
当然手机是有【手机号】的，也就是： akka.tcp://actorsydtem_name:主机:端口/user/actor_name。
当然组员之间想要通信，知道了他的【手机号】还不够，还得有【短信终端】啊，这个也就是 【ActorRef】。

</code></pre>
<ul>
<li><code>ActorSystem</code>是管理<code>Actor</code>生命周期的组件，<code>Actor</code>是负责进行通信的组件</li>
<li>每个<code>Actor</code>都有一个<code>MailBox</code>（在Flink源码中经常可以看到，<code>checkpoint</code>通知就是基于此），别的<code>Actor</code>发送给它的消息都是首先存储在<code>MailBox</code>中，通过这种方式可以实现<strong>异步通信</strong></li>
<li>单个<code>Actor</code>可以改变他自身的状态，可以接收消息，也可以发送消息，还可以生成新的<code>Actor</code></li>
<li>每个<code>Actor</code>是<strong>单线程</strong>的处理，不断从<code>MailBox</code>中拉取消息执行处理</li>
</ul>
<blockquote>
<blockquote>
<p>所以对于<code>Actor</code>的消息处理，<strong>不适合调用阻塞</strong>的处理方式。</p>
</blockquote>
</blockquote>
<ul>
<li>每个<code>ActorSystem</code>和<code>Actor</code>都在启动时候会给一个<code>Name</code></li>
</ul>
<blockquote>
<p>如果要从<code>Actor</code>获取一个<code>Actor</code>，则通过以下方式进行<code>Actor</code>的获取:</p>
<blockquote>
<p><code>akka.tcp://actorsydtem_name:主机:端口/user/actor_name</code> 来进行定位的。<br>
例如: <code>akka.tcp://flink@flink-236429.ns-69020:6123</code></p>
</blockquote>
</blockquote>
<ul>
<li>如果一个<code>Actor</code>要和另外一个<code>Actor</code>进行通信，则必须先获取对象的<code>Actor</code>的<code>ActorRef</code>对象，然后通过该对象<strong>发送消息</strong>即可。</li>
<li>通过<code>tell</code><strong>发送异步消息</strong>，<strong>不接受响应</strong>；通过<code>ask</code>发送异步消息，得到<code>future</code>返回，通过<strong>异步回调</strong>返回处理结果。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250101105002931-52790025.png" alt="" loading="lazy"></p>
<h3 id="使用akka模拟实现flink-standalone集群通信">使用Akka模拟实现Flink Standalone集群通信</h3>
<h4 id="需求">需求</h4>
<ul>
<li>需求：<br>
1、两个进程: JobManager、TaskManager<br>
2、当TaskManager启动的时候，向JobManager发送注册信息，报告本地的内存、CPU<br>
3、当JobManager收到注册消息的时候，返回给TaskManager注册成功的消息<br>
4、TaskManager每间隔三秒向JobManager发送心跳消息<br>
5、JobManager每间隔3秒扫描一下，有哪些TaskManager下线了</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202501/1173617-20250101105649366-1651938983.png" alt="" loading="lazy"></p>
<h4 id="代码实现-taskmanager">代码实现: TaskManager</h4>
<pre><code class="language-java">public class TaskManager extends UntypedActor {
    
    public static Props props() {
        return Props.create(TaskManager.class, () -&gt; new TaskManager());
    }

    private final static ActorSystem TASKMANAGER_SYSTEM;
    private final static ActorRef TASKMANAGER_ACTOR;
    private final static int PORT;
    private final static StandaloneConfig STANDALONE_CONFIG = new StandaloneConfig();

    static {
        PORT = STANDALONE_CONFIG.getTaskManagerPort();
        Map&lt;String, Object&gt; conf = new HashMap&lt;&gt;();
        conf.put("akka.remote.netty.tcp.hostname", STANDALONE_CONFIG.getTaskManagerHost());
        conf.put("akka.remote.netty.tcp.port", PORT);
        conf.put("akka.actor.provider", "akka.remote.RemoteActorRefProvider");
        Config config = ConfigFactory.parseMap(conf);
        TASKMANAGER_SYSTEM = ActorSystem.create(STANDALONE_CONFIG.getTaskManagerSystemName(), config);
        TASKMANAGER_ACTOR = TASKMANAGER_SYSTEM.actorOf(TaskManager.props(), STANDALONE_CONFIG.getJobManagerActorName());
    }

    @Override
    public void onReceive(Object message) throws Throwable {

    }

    @Override
    public void preStart() throws Exception {
        RegistTaskManager registTaskManager = new RegistTaskManager();
        registTaskManager.setCpu(64);
        registTaskManager.setMemory(128);
        registTaskManager.setHostname(STANDALONE_CONFIG.getTaskManagerHost());
        registTaskManager.setPort(PORT);
        String taskMId = (registTaskManager.getHostname() + ":" + PORT).hashCode() + "";
        registTaskManager.setTaskManagerId(taskMId);
        String template = "akka.tcp://%s@%s:%d/user/%s";
        String jobmanagerUrl = String.format(template, STANDALONE_CONFIG.getJobManagerSystemName(),
                STANDALONE_CONFIG.getJobManagerHost(), STANDALONE_CONFIG.getJobManagerPort(), STANDALONE_CONFIG.getJobManagerActorName());
        System.out.println(jobmanagerUrl);
        ActorSelection jobmanagerActor = getContext().actorSelection(jobmanagerUrl);
        Timeout t = new Timeout(Duration.create(10, TimeUnit.SECONDS));
        //注册获取回调，并且绑定发送心跳
        Future&lt;Object&gt; ask = Patterns.ask(jobmanagerActor, registTaskManager, t);
        ask.onSuccess(new OnSuccess&lt;Object&gt;() {
            @Override
            public void onSuccess(Object result) throws Throwable {
                if ("注册成功".equalsIgnoreCase((String)result)) {
                    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
                    service.scheduleWithFixedDelay(new Runnable() {
                        @Override
                        public void run() {
                            Heartbeat heartbeat = new Heartbeat();
                            heartbeat.setTaskId(registTaskManager.getTaskManagerId());
                            jobmanagerActor.tell(heartbeat,getSelf());
                            System.out.println("发送心跳");
                        }
                    }, 0, 3, TimeUnit.SECONDS);
                }
            }
        }, TASKMANAGER_SYSTEM.dispatcher());
    }

    public static void main(String[] args) throws Exception {

    }
</code></pre>
<h4 id="代码实现jobmanager">代码实现：JobManager</h4>
<pre><code class="language-java">public class JobManager extends UntypedActor {
    public static Props props() {
        return Props.create(JobManager.class, () -&gt; new JobManager());
    }

    private final static ActorSystem JOBMANAGER_SYSTEM;
    private final static ActorRef JOBMANAGER_ACTOR;
    private ConcurrentHashMap&lt;String,TaskManagerInfo&gt; taskManagerInfoConcurrentHashMap = new ConcurrentHashMap&lt;&gt;();

    static {
        StandaloneConfig STANDALONE_CONFIG  = new StandaloneConfig();
        Map&lt;String, Object&gt; conf = new HashMap&lt;&gt;();
        conf.put("akka.remote.netty.tcp.hostname", STANDALONE_CONFIG.getJobManagerHost());
        conf.put("akka.remote.netty.tcp.port", STANDALONE_CONFIG.getJobManagerPort());
        conf.put("akka.actor.provider","akka.remote.RemoteActorRefProvider");
        Config config = ConfigFactory.parseMap(conf);
        JOBMANAGER_SYSTEM = ActorSystem.create(STANDALONE_CONFIG.getJobManagerSystemName(), config);
        JOBMANAGER_ACTOR = JOBMANAGER_SYSTEM.actorOf(JobManager.props(), STANDALONE_CONFIG.getJobManagerActorName());
    }

    @Override
    public void onReceive(Object message) throws Throwable {
        if (message instanceof CheckTimeout){
            System.out.println("开始心跳检测");
            System.out.println("要检测的taskmanager数量: "+taskManagerInfoConcurrentHashMap.size());
            Set&lt;Map.Entry&lt;String, TaskManagerInfo&gt;&gt; entries = taskManagerInfoConcurrentHashMap.entrySet();
            Iterator&lt;Map.Entry&lt;String, TaskManagerInfo&gt;&gt; iterator = entries.iterator();
            while (iterator.hasNext()){
                Map.Entry&lt;String, TaskManagerInfo&gt; entry = iterator.next();
                TaskManagerInfo next = entry.getValue();
                long l = System.currentTimeMillis();
                if ((l - next.getLastHeartbeatTime()) &gt; 6000){
                    iterator.remove();
                    taskManagerInfoConcurrentHashMap.remove(next.getTaskManagerId());
                    System.out.println(next.getTaskManagerId() +" 下线了");
                }
            }

        }
        if (message instanceof RegistTaskManager){
            RegistTaskManager registTaskManager = (RegistTaskManager) message;
            TaskManagerInfo taskManagerInfo = new TaskManagerInfo();
            taskManagerInfo.setCpu(registTaskManager.getCpu());
            taskManagerInfo.setHostname(registTaskManager.getHostname());
            taskManagerInfo.setTaskManagerId(registTaskManager.getTaskManagerId());
            taskManagerInfo.setMemory(registTaskManager.getMemory());
            taskManagerInfoConcurrentHashMap.put(registTaskManager.getTaskManagerId(),taskManagerInfo);
            System.out.println(taskManagerInfo.getTaskManagerId() +" 前来注册了");
            getSender().tell("注册成功",getSelf());
        }
        if (message instanceof Heartbeat){
            Heartbeat heartbeat = (Heartbeat) message;
            String taskId = heartbeat.getTaskId();
            TaskManagerInfo taskManagerInfo = taskManagerInfoConcurrentHashMap.get(taskId);
            taskManagerInfo.setLastHeartbeatTime(System.currentTimeMillis());
            System.out.println(taskId +" 前来心跳了");
        }
    }

    @Override
    public void preStart() throws Exception {

        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
        service.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                CheckTimeout checkTimeout = new CheckTimeout();
                getSelf().tell(checkTimeout,getSelf());
            }
        }, 0, 3, TimeUnit.SECONDS);
    }

    public static void main(String[] args) throws Exception {

    }
}
</code></pre>
<h1 id="3-解决方法">3 解决方法</h1>
<ul>
<li>检查网络连接：确保你的机器能够网络连接到 flink-236429.ns-69020 主机的6123端口。</li>
</ul>
<blockquote>
<ul>
<li>延伸：检查所有机器，hosts是否都配置了映射</li>
</ul>
</blockquote>
<ul>
<li>
<p>检查所有机器，时间是否一致</p>
</li>
<li>
<p>检查<code>Akka</code>配置和<code>JobManager</code>配置：确认 akka.tcp 协议、flink 系统名称以及端口号是否正确配置在Flink集群的配置文件中。</p>
</li>
</ul>
<blockquote>
<ul>
<li>Flink应用中，有时候在与远程系统建立连接时会出现问题，其中一种常见的问题是<strong>与远程系统(如：JobManager)的连接失败</strong>。</li>
</ul>
<blockquote>
<p>在 Flink 中，<code>Akka</code> 是用于实现<strong>分布式通信</strong>和<strong>远程调用的框架</strong>。<br>
当 Flink 运行时与远程系统建立连接时，它使用 <code>Akka.Remote</code> 模块来处理通信。<br>
在这个过程中，如果发生了关联失败，通常会出现 “<code>akka.remote.ReliableDeliverySupervisor - Association with remote system has failed</code>” 的错误信息。<br>
解决这个问题的一种方法是重新配置 <code>Flink</code> 和 <code>Akka</code> 的相关参数，以便更好地适应远程系统的环境。</p>
</blockquote>
<ul>
<li>关键配置：<code>AkkaOptions</code> / <code>JobManagerOptions</code></li>
<li><code>AkkaOptions</code></li>
</ul>
<blockquote>
<ul>
<li><code>akka.ask.timeout</code> ：用于异步futures和阻塞调用Akka的超时，如果flink因为超时而失败，则可以尝试增加此值，超时可能是由于机器速度慢或网络拥挤造成的。超时值需要时间单位说明符（ms/s/min/h/d）。源码默认值：10s。所属源码类：AkkaOptions。</li>
<li><code>akka.tcp.timeout</code> ：用于和taskManager之间的通信，如果由于网络速度较慢而在连接TaskManager时遇到问题，则应增加此值。默认值：20s。源码类：AkkaOptions。</li>
<li><code>akka.framesize</code> ：用于JobManager和TaskManager之间发送的最大消息大小，如果Flink失败是因为消息超过此限制，可以增加该值。消息大小需要大小单位说明符。默认值：10485760b(10m)。源码类：同上。</li>
<li><code>akka.lookup.timeout</code>:用于查找JobManager的超时。默认值10s。源码类：同上。</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-java">//demo code
import org.apache.flink.configuration.JobManagerOptions; //导入依赖的package包/类
private static void testFailureBehavior(final InetSocketAddress unreachableEndpoint) throws Exception {

	final Configuration config = new Configuration();
	config.setString(AkkaOptions.ASK_TIMEOUT, ASK_STARTUP_TIMEOUT + " ms");
	config.setString(AkkaOptions.LOOKUP_TIMEOUT, CONNECT_TIMEOUT + " ms");
	config.setString(JobManagerOptions.ADDRESS, unreachableEndpoint.getHostName());
	config.setInteger(JobManagerOptions.PORT, unreachableEndpoint.getPort());

	StandaloneClusterClient client = new StandaloneClusterClient(config);

	try {
		// we have to query the cluster status to start the connection attempts
		client.getClusterStatus();
		fail("This should fail with an exception since the endpoint is unreachable.");
	} catch (Exception e) {
		// check that we have failed with a LeaderRetrievalException which says that we could
		// not connect to the leading JobManager
		assertTrue(CommonTestUtils.containsCause(e, LeaderRetrievalException.class));
	}
}
</code></pre>
<ul>
<li>
<p>检查Flink集群状态：确保Flink集群正在运行，并且所有必要的服务组件都是活跃的。</p>
</li>
<li>
<p>防火墙和安全组设置：确保没有防火墙或安全组规则阻止访问6123端口。</p>
</li>
<li>
<p>日志文件：查看Flink和应用程序的日志文件，以获取更多关于关联失败的详细信息。</p>
</li>
<li>
<p>版本兼容性：确保Flink的版本与尝试连接的版本兼容。</p>
</li>
</ul>
<blockquote>
<ul>
<li>延伸：Scala版本是否和Flink兼容</li>
<li>延伸：客户端和服务器端的Scala版本是否一致</li>
</ul>
</blockquote>
<ul>
<li>
<p>若Flink某个节点长时间FullGC导致akka通信超时，也是一个可能的原因，需针对性排查解决。</p>
</li>
<li>
<p><strong>重启FlinkJob</strong></p>
</li>
</ul>
<blockquote>
<p>如果单纯是偶然的网络波动，且短期内无法解决，则可尝试此法。</p>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://blog.csdn.net/weixin_43704599/article/details/123463653" target="_blank" rel="noopener nofollow">Flink底层实现Akka - CSDN</a> 【参考/推荐】</li>
<li><a href="https://developer.aliyun.com/ask/437466" target="_blank" rel="noopener nofollow">这个意思是 jobmanager 失联了么？ - 阿里云</a> 【推荐】</li>
<li><a href="https://help.sap.com/docs/SAP_COMMERCE/c65fa30c12ec4c2dbe04becf73f0943d/3f1786b90257453984167724f49db73e.html?version=2105" target="_blank" rel="noopener nofollow">Handling Unreachable Nodes - Troubleshooting Cluster Issues - sap.com</a> 【推荐】</li>
</ul>
<blockquote>
<p>问题现象：Data Hub未实现自动关闭功能，无法在发生崩溃时删除无法访问的节点。如果某个节点崩溃或由于网络问题而与集群隔离，则所有剩余节点都会报告丢失。</p>
<blockquote>
<p>其余节点会重复记录这些警告，直到该节点重新上线，但会继续正常接受请求。当离线节点重新上线时，集群会自行修复，无需干预。<br>
关键日志：`2016-11-14 14:52:15,146 [WARN] [a.r.ReliableDeliverySupervisor] Association with remote system [akka.ssl.tcp://DataHubActorSystem@10.0.0.3:2552] has failed, address is now gated for [5000] ms. Reason:[Disassociated]</p>
</blockquote>
</blockquote>
<ul>
<li><a href="https://www.mail-archive.com/user@flink.apache.org/msg46719.html" target="_blank" rel="noopener nofollow">RE: Could not stop job with a savepoint - mail-archive.com</a></li>
</ul>
<blockquote>
<p>关键日志：<code>address is now gated for [50] ms. Reason: [Disassociated]</code></p>
</blockquote>
<ul>
<li><a href="https://www.mail-archive.com/akka-user@googlegroups.com/msg21000.html" target="_blank" rel="noopener nofollow">Re: [akka-user] AKKA nodes gets disconnected without code interaction on virtual machines - mail-archive.com</a></li>
</ul>
<blockquote>
<p>关键日志：<code>Association with remote system [akka.tcp://ClusterSystem@euler:9191] has failed, address is now gated for [5000] ms. Reason: [Disassociated]</code></p>
</blockquote>
<ul>
<li><a href="https://blog.51cto.com/u_15067236/4664367" target="_blank" rel="noopener nofollow">Spark常见问题汇总，spark相关错误和解决方法 - 51CTO</a> 【推荐】</li>
</ul>
<blockquote>
<p>关键日志：<code>WARN ReliableDeliverySupervisor: Association with remote system [akka.tcp://sparkMaster@s1:7077] has failed, address is now gated for [5000] ms. Reason: [Disassociated]</code><br>
问题现象：Spark在发布应用的时候，出现连接不上master问题<br>
解决思路：检查所有机器时间是否一致、hosts是否都配置了映射、客户端和服务器端的Scala版本是否一致、Scala版本是否和Spark兼容</p>
</blockquote>
<ul>
<li><a href="https://developer.aliyun.com/ask/129734" target="_blank" rel="noopener nofollow">Flink jobmanager报错： ERROR akka.remote.Remoting - Association to [akka.tcp://flink@xxxxx:42895] with UID [-205381938] irrecoverably failed. Quarantining address - 阿里云</a></li>
</ul>
<blockquote>
<p><code>2018-11-18 23:24:09,594 ERROR akka.remote.Remoting - Association to [akka.tcp://flink@xxxx:46671] with UID [-435340187] irrecoverably failed. Quarantining address. java.util.concurrent.TimeoutException: Remote system has been silent for too long. (more than 48.0 hours)</code></p>
</blockquote>
<ul>
<li><a href="https://xdcsy.github.io/Text/Section0048.xhtml" target="_blank" rel="noopener nofollow">Flink JobManager 和 TaskManager 地址配置的一些问题 - xdcsy.github.io</a></li>
</ul>
<blockquote>
<p>关键日志：<code>WARN akka.remote.ReliableDeliverySupervisor [] - Association with remote system [akka.tcp://flink@localhost:6123] has failed, address is now gated for [50] ms. Reason: [Association failed with [akka.tcp://flink@localhost:6123]] Caused by: [java.net.ConnectException: Connection refused: taskmanager/xxxx:6123]</code><br>
问题现象：Flink集群能够启动，但是拉起任务时报错。检查Flink控制台页面，发现taskmamager注册的地址为127.0.0.1，而正常情况下，taskmanager应该以实际ip地址注册到jobmanager。<br>
解决办法：在 flink-conf.yaml 这个配置文件的最后加一行 taskmanager.host: xxx.xxx.xxx.xxx，其中指定taskmanager的实际本机ip。</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/109719927" target="_blank" rel="noopener nofollow">Association with remote system [akka.tcp://flink@:42567] has failed,address is now gated for [50] ms - CSDN</a></li>
</ul>
<blockquote>
<p>关键日志：<code>WARN akka.remote.ReliableDeliverySupervisor [] - Association with remote system [akka.tcp://flink@bigdata1:42567] has failed, address is now gated for [50] ms. Reason: [Association failed with [akka.tcp://flink@bigdata1:42567]] Caused by: [java.net.ConnectException: 拒绝连接: bigdata1/192.168.239.131:42567]</code><br>
问题现象：Flink-1.11.2 Standalone HA集群实现JobManager高可用主备切换报错。bigdata1节点、bigdata2节点实现JobManager的高可用主备切换，bigdata1被选为Leader，但bigdata2无法和bigdata1通信，bigdata2无法成为备用JobManager。<br>
问题摘要：在Flink 1.11.2 Standalone HA集群中配置JobManager高可用时遇到问题，bigdata1作为Leader，bigdata2无法与其通信。报错信息涉及Akka远程连接失败，原因是网络连接被拒绝。通过调整<code>flink-conf.yaml</code>中内存参数，重启集群，观察进程和Web UI，确认JobManager主备切换。当kill掉bigdata1的JobManager进程，bigdata2能成功接管，实现主备切换</p>
</blockquote>
<ul>
<li></li>
<li><a href="https://blog.csdn.net/cuichunchi/article/details/121888619" target="_blank" rel="noopener nofollow">Flink 1.13 一些配置参数记录 - CSDN</a></li>
</ul>
<blockquote>
<p><code>AkkaOptions</code> / <code>JobManagerOptions</code></p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05498218418981481" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-01 10:59">2025-01-01 10:59</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18645358" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18645358);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18645358', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18645358', title: '[Flink] Flink运行过程中Flink作业运行崩溃，且`TaskManager`报:&amp;quot;Association with remote system [akka.tcp://flink@flink-236429.ns-69020:6123] has failed, address is now gated for [50] ms. Reason: [Disassociated]&amp;quot;' })">举报</a>
</div>
        