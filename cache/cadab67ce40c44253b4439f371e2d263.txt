
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18748329" title="发布于 2025-03-04 13:15">
    <span role="heading" aria-level="2">重生之数据结构与算法----队列&amp;栈</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>上文说到，数据结构只有两种。其它的数据结构都是它的<code>整花活</code>。</p>
<ol>
<li>
<p>栈<br>
栈只能在表的一端（称为栈顶）进行插入和删除操作，遵循 “后进先出”（Last In First Out，LIFO）的原则。就像生活中的一摞盘子，最后放上去的盘子会最先被拿走</p>
</li>
<li>
<p>队列<br>
它只允许在表的一端进行插入操作（队尾），在另一端进行删除操作（队头），遵循 “先进先出”（First In First Out，FIFO）的原则。类似于生活中排队买票，先排队的人先买到票离开队列。</p>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250303152717980-1372165972.png" alt="image" loading="lazy"></p>
<h1 id="用链表实现stack">用链表实现stack</h1>
<pre><code>    public class MyLinkedStack&lt;T&gt;()
    {
        public static void Run()
        {
            var stack = new MyLinkedStack&lt;string&gt;();

            stack.Push("aaaa");
            stack.Push("bbbb");
            stack.Push("cccc");
            stack.Push("dddd");

            while (stack.Count &gt; 0)
            {
                Console.WriteLine(stack.Pop());
            }
            
        }
        private LinkedList&lt;T&gt; _linked = new LinkedList&lt;T&gt;();

        /// &lt;summary&gt;
        /// 入栈
        /// O(1)
        /// &lt;/summary&gt;
        /// &lt;param name="item"&gt;&lt;/param&gt;
        public void Push(T item)
        {
            _linked.AddFirst(item);
        }

        /// &lt;summary&gt;
        /// 出栈
        /// O(1)
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public T Pop()
        {
            var first = _linked.First;
            _linked.RemoveFirst();
            return first.Value;
        }
        /// &lt;summary&gt;
        /// 查看栈顶
        /// &lt;/summary&gt;
        /// O(1)
        /// &lt;returns&gt;&lt;/returns&gt;
        public T Peek()
        {
            return _linked.First.Value;
        }

        public int Count { get { return _linked.Count; } }
    }
</code></pre>
<h1 id="用链表实现queue">用链表实现queue</h1>
<pre><code>public class MyLinkedQueue&lt;T&gt;
{
    public static void Run()
    {
        var queue = new MyLinkedQueue&lt;string&gt;();


        queue.Enqueue("aaa");
        queue.Enqueue("bbb");
        queue.Enqueue("ccc");
        queue.Enqueue("ddd");

        while (queue.Count &gt; 0)
        {
            Console.WriteLine(queue.Dequeue());
        }
    }

    private LinkedList&lt;T&gt; _linked = new LinkedList&lt;T&gt;();

    /// &lt;summary&gt;
    /// 入列
    /// &lt;/summary&gt;
    /// &lt;param name="item"&gt;&lt;/param&gt;
    public void Enqueue(T item)
    {
        _linked.AddFirst(item);
    }

    /// &lt;summary&gt;
    /// 出列
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Dequeue()
    {
        var last= _linked.Last;
        _linked.RemoveLast();
        return last.Value;
    }

    /// &lt;summary&gt;
    /// 查看队列顶
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Peek()
    {
        return _linked.First.Value;
    }

    public int Count { get { return _linked.Count; } }
}
</code></pre>
<h1 id="用数组实现stack">用数组实现stack</h1>
<pre><code>    public class MyArrayStack&lt;T&gt;()
    {
        public static void Run()
        {
            var stack = new MyLinkedStack&lt;string&gt;();

            stack.Push("aaaa");
            stack.Push("bbbb");
            stack.Push("cccc");
            stack.Push("dddd");

            while (stack.Count &gt; 0)
            {
                Console.WriteLine(stack.Pop());
            }

        }
        private List&lt;T&gt; _list=new List&lt;T&gt;();

        /// &lt;summary&gt;
        /// 入栈
        /// O(1)
        /// &lt;/summary&gt;
        /// &lt;param name="item"&gt;&lt;/param&gt;
        public void Push(T item)
        {
            _list.Add(item);
        }

        /// &lt;summary&gt;
        /// 出栈
        /// O(1)
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public T Pop()
        {
            var v = _list[_list.Count - 1];
            _list.RemoveAt(_list.Count - 1);
            return v;
        }

        /// &lt;summary&gt;
        /// 查看栈顶
        /// &lt;/summary&gt;
        /// O(1)
        /// &lt;returns&gt;&lt;/returns&gt;
        public T Peek()
        {
            return _list[_list.Count - 1];
        }

        public int Count { get { return _list.Count; } }
    }
</code></pre>
<h1 id="用数组实现queue">用数组实现queue</h1>
<p>由于queue先进先出的特性，list头部增删元素的复杂度是O(N),不符合性能要求，我们可以使用前文介绍的<code>环形数组</code>，来实现list头部增删的O(1)</p>
<pre><code>public class MyArrayQueue&lt;T&gt;
{
    public static void Run()
    {
        var queue = new MyArrayQueue&lt;string&gt;();

        queue.Push("aaaa");
        queue.Push("bbbb");
        queue.Push("cccc");
        queue.Push("dddd");

        while (queue.Count &gt; 0)
        {
            Console.WriteLine(queue.Pop());
        }

    }
    private CircularArray&lt;T&gt; _list = new CircularArray&lt;T&gt;();

    /// &lt;summary&gt;
    /// 入栈
    /// O(1)
    /// &lt;/summary&gt;
    /// &lt;param name="item"&gt;&lt;/param&gt;
    public void Push(T item)
    {
        _list.AddFirst(item);
    }

    /// &lt;summary&gt;
    /// 出栈
    /// O(1)
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Pop()
    {
        var v = _list.GetLast();
        _list.RemoveLast();
        return v;
    }

    /// &lt;summary&gt;
    /// 查看栈顶
    /// &lt;/summary&gt;
    /// O(1)
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Peek()
    {
        return _list.GetFirst();
    }

    public int Count { get { return _list.Count; } }
}
</code></pre>
<h1 id="队列的变种双端队列">队列的变种：双端队列</h1>
<p>所谓双端队列，主要是比普通队列，多一个<code>出入口</code>,可以从队列的两头进行插入，删除。但也破坏了<code>先进先出</code>的原则。<br>
日常场景使用不多。只有 Python用得多一些，因为Python标准库没有提供内置的栈和队列，一般会用双端队列来模拟标准队列。</p>
<pre><code>    public interface IMyQueue&lt;T&gt;
    {
        /// &lt;summary&gt;
        /// 从头入列
        /// &lt;/summary&gt;
        /// &lt;param name="item"&gt;&lt;/param&gt;
        void EnqueueFirst(T item);
        /// &lt;summary&gt;
        /// 从头出列
        /// &lt;/summary&gt;
        /// &lt;param name="item"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        T DequeueFirst(T item);
        /// &lt;summary&gt;
        /// 从尾入列
        /// &lt;/summary&gt;
        void EnqueueLast();
        /// &lt;summary&gt;
        /// 从头出列
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        T DequeueLast();

    }
</code></pre>
<blockquote>
<p>实现比较简单，不再重复，参考普通队列思路即可。链表/环形数组均可实现。</p>
</blockquote>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.37575171916666666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-04 13:15">2025-03-04 13:15</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">107</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18748329" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18748329);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18748329', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18748329', title: '重生之数据结构与算法----队列&amp;amp;栈' })">举报</a>

		</p>
	