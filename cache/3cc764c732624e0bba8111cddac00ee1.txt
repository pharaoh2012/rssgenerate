
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tmbcan/p/18686660" title="发布于 2025-01-22 19:33">
    <span role="heading" aria-level="2">zkw 线段树-原理及其扩展</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<blockquote>
<p>许多算法的本质是统计。线段树用于统计，是沟通原数组与前缀和的桥梁。</p>
<p>《统计的力量》清华大学-张昆玮</p>
</blockquote>
<h3 id="关于线段树">关于线段树</h3>
<p>前置知识：<a href="https://oi-wiki.org/ds/seg/" target="_blank" rel="noopener nofollow">线段树 OIWiki</a>。</p>
<p>线段树是一种专门<strong>维护区间问题</strong>的数据结构。<br>
线段树对信息进行<strong>二进制化处理</strong>并在树形结构上维护，以此让处理速度达到 <span class="math inline">\(O(\log{n})\)</span> 级别。</p>
<h3 id="线段树的实现方式">线段树的实现方式</h3>
<p>由于线段树的树形结构特点，每次修改查询可以从根节点向下二分查找需要用到的节点，因此较为普遍且快捷的线段树会使用<strong>递归</strong>实现。</p>
<p>但递归实现的线段树由于每次要从根节点<strong>递归</strong>向下传递子树信息，导致常数较大，容易被卡常，所以出现了<strong>常数更小的递推实现</strong>的线段树（膜拜 zkw 大佬）。</p>
<hr>
<h1 id="zkw-线段树">zkw 线段树</h1>
<p><strong>先来讲一些小原理。</strong></p>
<h2 id="一原理">一、原理</h2>
<p>由于<strong>递归</strong>实现的线段树不是一棵满二叉树，其叶子节点位置不确定，导致每次操作都需要从根节点开始<strong>自上而下递归</strong>依次寻找叶子节点，回溯时进行维护，递归过程常数就比较大了。</p>
<p>所以 zkw 线段树就直接建出一棵<strong>满二叉树</strong>，原序列信息都维护在最底层。<strong>严格规定</strong>父子节点关系，同层节点的子树大小相等。<br>
这样每个叶子节点都可以直接找到并修改，由于二叉树父子节点的<strong>二进制关系</strong>，就可以递推直接找到对应节点的父亲节点<strong>自下而上</strong>地维护节点关系。</p>
<h2 id="二初始化">二、初始化</h2>
<h3 id="1建树">1、建树</h3>
<p>对长度为 <span class="math inline">\(n\)</span> 的序列建一棵 zkw 线段树，其<strong>至少有 <span class="math inline">\(n+2\)</span> 个叶子节点</strong>。其中有 2 个用来帮助维护区间信息的<strong>虚点</strong>，有 <span class="math inline">\(n\)</span> 个用来存原序列信息的节点。<br>
如图（<a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener nofollow">【模板】线段树 1 </a>的样例为例，下同）：</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140634125-188954022.png" alt="" loading="lazy"></p>
<p>建树时先求出虚点 <span class="math inline">\(P\)</span> 位置，然后直接向其他叶子节点读入信息即可:</p>
<pre><code class="language-cpp">//先求虚点 P
  P = 1;
  while(P&lt;=n+1) P&lt;&lt;=1;//节点深度每增加一层，当前层节点数量扩大一倍
  for(int i=1;i&lt;=n;++i) read(tr[P+i]);
</code></pre>
<h3 id="2维护">2、维护</h3>
<p>根据上文所说，由于严格确定了父子关系，所以直接自下而上遍历所有节点维护父子关系做初始化：</p>
<pre><code class="language-cpp">//push_up
  for(int i=P-1;i;--i){//i=(P+n)&gt;&gt;1
  	tr[i] = tr[i&lt;&lt;1|1]+tr[i&lt;&lt;1]; 
  	tr[i] = min(tr[i&lt;&lt;1|1],tr[i&lt;&lt;1]);
  	tr[i] = max(tr[i&lt;&lt;1|1],tr[i&lt;&lt;1]);
  	//...
  }
</code></pre>
<h2 id="三概念介绍">三、概念介绍</h2>
<h3 id="1永久化懒标记">1、永久化懒标记</h3>
<p>与递归线段树的 <span class="math inline">\(lazy\)</span> <span class="math inline">\(tag\)</span> 不同，其每次向下递归时都需要先下放标记并清空以维护信息。</p>
<p>但在维护<strong>存在结合律</strong>的运算时，zkw 线段树的 <span class="math inline">\(lazy\)</span> <span class="math inline">\(tag\)</span> 只会<strong>累加</strong>，而不会在修改和查询前下放清空。</p>
<h3 id="2哨兵节点">2、“哨兵”节点</h3>
<p>在区间操作时，引入两个哨兵节点，分别在区间的左右两侧，<strong>把闭区间变成开区间进行处理</strong>。</p>
<p>两个哨兵节点到根有两条链，与两条链相邻且在中间部分的节点，就是这次操作需要用到其信息的所有节点。</p>
<p>如图（沿用了第一个图，节点中的数的为节点编号）：<br>
例如：<a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener nofollow">【模板】线段树 1 </a>第一个操作 <span class="math inline">\(query(2,4)\)</span>：</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140714479-2142267648.png" alt="" loading="lazy"></p>
<p>同时，这也解释了为什么建树时叶子节点上会有 <span class="math inline">\(2\)</span> 个虚点。</p>
<h4 id="1为什么可以确定需要用到哪些节点">（1）为什么可以确定需要用到哪些节点</h4>
<p>操作时，只需要操作区间中单元素区间的公共祖先即可。<br>
我们选取的两条链，中间部分正好包含了与操作区间有关的所有节点，与两条链相邻的节点显然的所有区间的公共祖先。</p>
<p>操作时只需要操作这些节点上的信息就可以了。</p>
<h4 id="2在递推过程中怎么判断要用到哪些节点">（2）在递推过程中怎么判断要用到哪些节点</h4>
<p>观察我们刚才手推出来的图片，注意到：<br>
对于左哨兵 <span class="math inline">\(S\)</span>，当它是左儿子时，其兄弟节点是需要用到的；<br>
对于右哨兵 <span class="math inline">\(T\)</span>，当它是右儿子时，其兄弟节点是需要用到的。</p>
<p>每次操作完后 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 向上走到自己的父亲节点，然后维护父子关系，再进行新一轮操作。<br>
当 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 互为兄弟节点时（走到了两条链的交点），就停止操作，然后向上维护信息到根节点。</p>
<h2 id="四基于结合律的查询与修改">四、基于结合律的查询与修改</h2>
<h3 id="1区间修改">1、区间修改</h3>
<p><strong>以区间加为例</strong>。<br>
类似递归线段树操作，更新时需要知道当前节点的<strong>子树大小</strong>。<br>
每次更新时，当前节点的值增加的是其标记乘子树大小；其标记的值正常累加即可。<br>
永久化懒标记<strong>减少了标记下放</strong>带来的常数。</p>
<pre><code class="language-cpp">//
  inline void update_add(int l,int r,ll k){
  	l=P+l-1; r=P+r+1;//哨兵位置 
  	int siz = 1;//记录当前子树大小 
  	
  	while(l^1^r){//当l与r互为兄弟时，只有最后一位不同 
  		if(~l&amp;1) tr[l^1]+=siz*k,sum[l^1]+=k;
  		if(r&amp;1) tr[r^1]+=siz*k,sum[r^1]+=k;
  		//类似递归线段树 tr[p] += tag[p]*(r-l+1) 
  		l&gt;&gt;=1; r&gt;&gt;=1; siz&lt;&lt;=1;
  		//每次向上走时子树大小都会增加一倍 
  		tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1]+sum[l]*siz;//维护父子关系 
  		tr[r] = tr[r&lt;&lt;1]+tr[r&lt;&lt;1|1]+sum[r]*siz;
  	}
  	for(l&gt;&gt;=1,siz&lt;&lt;=1;l;l&gt;&gt;=1,siz&lt;&lt;=1) tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1]+sum[l]*siz;//更新上传至根节点
  } 
</code></pre>
<h3 id="2区间查询">2、区间查询</h3>
<p>由于我们需要查询的区间被左右哨兵分为了两个部分，但两部分子树大小不一定相等。<br>
所以要分别维护左右哨兵到达的节点所包含查询区间的子树的大小。</p>
<pre><code class="language-cpp">//
  inline ll query_sum(int l,int r){
  	l=l+P-1; r=r+P+1;
  	ll res = 0;
  	int sizl = 0,sizr = 0,siz = 1;//分别维护左右两侧子树大小

  	while(l^1^r){
  		if(~l&amp;1) res+=tr[l^1],sizl+=siz;//更新答案及子树大小 
  		if(r&amp;1) res+=tr[r^1],sizr+=siz;
  		l&gt;&gt;=1; r&gt;&gt;=1; siz&lt;&lt;=1;
		
  		res += sum[l]*sizl+sum[r]*sizr;
  		//即使当前节点所存的区间和不需要用，但因为其是两个哨兵的父亲节点，且 tag 不会下传，
  		//所以其 tag 会对答案有贡献，所以需要加上 tag 的贡献
  	}
  	for(l&gt;&gt;=1,sizl+=sizr;l;l&gt;&gt;=1) res+=sum[l]*sizl;//累加至根节点 
	return res;
  }
</code></pre>
<p>如果维护<strong>区间最大值</strong>也同理：</p>
<pre><code class="language-cpp">//
  inline void update_add(int l,int r,ll k){
  	l=P+l-1; r=P+r+1;
  	while(l^1^r){
  		if(~l&amp;1) sum[l^1]+=k,maxn[l^1]+=d;
  		if(r&amp;1) sum[r^1]+=k,maxn[r^1]+=d;
  		l&gt;&gt;=1; r&gt;&gt;=1;
        maxn[l] = max(maxn[l&lt;&lt;1],maxn[l&lt;&lt;1|1])+sum[l];
        maxn[r] = max(maxn[r&lt;&lt;1],maxn[r&lt;&lt;1|1])+sum[r];
  	}
  	for(l&gt;&gt;=1;l;l&gt;&gt;=1) maxn[l]=max(maxn[l&lt;&lt;1],maxn[l&lt;&lt;1|1])+sum[l];//更新上传至根节点
  } 
  inline ll query_max(int l,int r){
  	l=l+P-1; r=r+P+1;
  	ll resl = 0,resr = 0;//分别记录左右两侧最大值 
  	while(l^1^r){
  		if(~l&amp;1) resl=max(resl,maxn[l^1]);
  		if(r&amp;1) resr=max(resr,maxn[r^1]);
  		l&gt;&gt;=1; r&gt;&gt;=1;
  		resl += sum[l];//标记永久化，所以要累加标记值
  		resr += sum[r];
  	}
  	for(resl=max(resl,resr),l&gt;&gt;=1;l;l&gt;&gt;=1) res1+=sum[l];//累加至根节点
	return resl;
  }
</code></pre>
<p>某些时候，只会用到单点修改区间查询和区间修改单点查询，此时 zkw 线段树<strong>码量</strong>优势很大。</p>
<h3 id="3单点修改下的区间查询">3、单点修改下的区间查询</h3>
<p>修改：直接改叶子结点的值然后向上维护。<br>
查询：哨兵向上走时直接累加节点值。</p>
<pre><code class="language-cpp">//
  inline update(int x,ll k){
  	x += P; tr[x] = k;
  	for(x&gt;&gt;=1; x ;x&gt;&gt;=1) tr[x] = tr[x&lt;&lt;1]+tr[x&lt;&lt;1|1]; 
  }
  inline ll query(int l,int r){
  	l += P-1; r += P+1;
  	ll res = 0;
  	while(l^1^r){
  		if(~l&amp;1) res+=tr[l^1];
  		if(r&amp;1) res+=tr[r^1];
  		l&gt;&gt;=1; r&gt;&gt;=1;
  	}
  	return res;
  }
</code></pre>
<h3 id="4区间修改下的单点查询">4、区间修改下的单点查询</h3>
<p>将赋初值的过程看作是在叶子节点上打标记，区间修改也是在节点上打标记。<br>
由于 zkw 线段树的标记是永久化的，所以此时将标记的值看作节点的真实值。<br>
但这种做法显然<strong>只对于单点查询</strong>有效，在查询时需要加上节点到根沿途的所有标记。</p>
<pre><code class="language-cpp">//
  inline void update_add(int l,int r,ll k){
  	l += P-1; r += P+1;
  	while(l^1^r){
  		if(~l&amp;1) tr[l^1]+=k;
  		if(r&amp;1) tr[r^1]+=k;
  		l&gt;&gt;=1; r&gt;&gt;=1;
  	}
  }
  inline ll query(int x){
  	ll res = 0;
  	for(x+=P; x ;x&gt;&gt;=1) res+=tr[x];
  	return res;
  }
</code></pre>
<h3 id="5标记永久化的局限性">5、标记永久化的局限性</h3>
<p>以上修改与查询方式，全部基于<strong>运算具有结合律</strong>，所以标记可以永久化，以此减少标记下放增加的常数。</p>
<p>但如果运算<strong>存在优先级</strong>，标记就不能再永久化了。考虑在更新时将先标记下放（类似递归线段树）然后再从叶子节点向上更新。</p>
<p>但是如果像递归线段树一样从根开始逐次寻找子节点下放一遍的话，那优化等于没有。<br>
所以要考虑基于 zkw 线段树的特点进行下放操作，而且要尽可能的简洁方便。</p>
<hr>
<p><strong>So easy，搜一紫衣。</strong></p>
<h2 id="五有运算优先级的修改与查询">五、有运算优先级的修改与查询</h2>
<h3 id="1标记去永久化">1、标记去永久化</h3>
<p>在进行区间修改时，我们会用到的节点只存在于哨兵节点到根的链上。<br>
所以只考虑将这两条链上的节点标记进行下放即可。</p>
<h4 id="1如何得到有哪些需要下放标记的节点">（1）如何得到有哪些需要下放标记的节点</h4>
<p>考虑最暴力的方法：<br>
每次从哨兵节点向上递归直至根节点，回溯时下放标记。<br>
显然这样的方式常数优化约等于零。</p>
<p>考虑优化肯定是基于 zkw 线段树的特点。<br>
还是由于 zkw 线段树是满二叉树结构，所以可以通过节点<strong>编号移位</strong>的方式找到其所有父子节点的编号。<br>
显然哨兵到根节点的链，是哨兵的所有父亲组成的，所以只要让哨兵编号移位就可以了。</p>
<h4 id="2如何自上而下的传递标记">（2）如何自上而下的传递标记</h4>
<p>再记录一下叶子节点的深度。<br>
思考满二叉树的性质：当节点编号右移位节点深度时就指向根节点编号。<br>
所以节点右移的位数，从节点深度依次递减，就可以自上而下得到其所有父亲节点的编号。</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140730123-1560843760.png" alt="" loading="lazy"></p>
<h3 id="2区间修改">2、区间修改</h3>
<p>先下放标记，然后正常做标记更新。<br>
传递标记时可能要考虑子树大小，直接通过深度计算就可以了。<br>
<strong>以区间加及乘为例</strong>：</p>
<pre><code class="language-cpp">//建树时记录叶子节点深度 
  P = 1;DEP = 0;
  while(P&lt;=n+1) P&lt;&lt;=1,++DEP;
  //...
  //...
  //...
  inline void update_add(int l,int r,ll k){
  	l=P+l-1; r=P+r+1;
  	//先下放标记 
  	for(int i=DEP;i;--i) push_down(l&gt;&gt;i,1&lt;&lt;i),push_down(r&gt;&gt;i,1&lt;&lt;i); 
  	//push_dwon( 链上节点 , 当前子树大小 );

  	int siz = 1;
  	while(l^1^r){
  		if(~l&amp;1) tr[l^1]+=siz*k,sum[l^1]+=k;//正常更新
  		if(r&amp;1) tr[r^1]+=siz*k,sum[r^1]+=k;
  		l&gt;&gt;=1; r&gt;&gt;=1; siz&lt;&lt;=1;

  		//维护父子关系 
  		tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];//由于标记已下放，所以维护时不再考虑累加标记 
  		tr[r] = tr[r&lt;&lt;1]+tr[r&lt;&lt;1|1];
  	}
  	for(l&gt;&gt;=1; l ;l&gt;&gt;=1) tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];//上传至根节点 
  }
  //
  inline void update_mul(int l,int r,ll k){
  	l += P-1; r += P+1;
  	for(int i=DEP;i;--i) push_down(l&gt;&gt;i,1&lt;&lt;i),push_down(r&gt;&gt;i,1&lt;&lt;i);
  	while(l^1^r){
  		if(~l&amp;1) tr[l^1]*=k,mul[l^1]*=k,sum[l^1]*=k;//标记覆盖
  		if(r&amp;1) tr[r^1]*=k,mul[r^1]*=k,sum[r^1]*=k;
  		l&gt;&gt;=1; r&gt;&gt;=1;
  		tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];
  		tr[r] = tr[r&lt;&lt;1]+tr[r&lt;&lt;1|1];
  	}
  	for(l&gt;&gt;=1; l ;l&gt;&gt;=1) tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];
  }
</code></pre>
<h3 id="3区间查询">3、区间查询</h3>
<p>先下放标记。<br>
由于标记已经去永久化，所以直接累加节点值即可。</p>
<pre><code class="language-cpp">//
  inline ll query(int l,int r){
  	l = l+P-1;r = r+P+1;
  	//先下放标记 
  	for(int i=DEP;i;--i) push_down(l&gt;&gt;i,1&lt;&lt;i),push_down(r&gt;&gt;i,1&lt;&lt;i); 
  	ll res = 0;
  	while(l^1^r){
  		if(~l&amp;1) res+=tr[l^1]; 
  		if(r&amp;1) res+=tr[r^1]; 
  		//由于标记已下放，所以无需再累加标记的贡献 
  		l&gt;&gt;=1; r&gt;&gt;=1;
  	}
  	return res;
  }
</code></pre>
<h2 id="六优化效果">六、优化效果</h2>
<h3 id="1时间复杂度">1、时间复杂度</h3>
<p>开始的时候也提到了：递归线段树常数大的瓶颈在于其需要对树进行<strong>递归遍历</strong>以找到目标节点，然后回溯进行信息维护。<br>
zkw 线段树<strong>仅仅只是</strong>优化了递归寻找目标节点这样的<strong>遍历过程</strong>的常数。</p>
<p>如果是追求常数或者注重优化遍历，那 zkw 线段树的优化就比较明显了；如果要维护较为复杂的信息，那么显然这点常数并不是很够看，此时就需要在其他地方上做改进了。</p>
<h3 id="2空间复杂度">2、空间复杂度</h3>
<p>zkw 线段树需要开<strong>三倍空间</strong>，普通线段树如果不使用动态开点需要开四倍空间。</p>
<p>相较于普通线段树，zkw 线段树代码好理解也比较简洁，不会出现<strong>忘建树</strong>和<strong>忘终止递归</strong>的问题，而且满二叉树结构的确定性让<strong>手造数据</strong>也比较方便。<br>
对于一些维护信息复杂的题目，zkw 线段树的优势在于手推时思路更加清晰。</p>
<hr>
<p><strong>如果性格比较内向，不敢用递归线段树进行递归维护信息。</strong><br>
<strong>想用 zkw 递推实现更多更强的操作怎么办！</strong></p>
<h1 id="zkw-线段树实现其他线段树结构">zkw 线段树实现其他线段树结构</h1>
<h2 id="一引入">一、引入</h2>
<h3 id="1关于-zkw-线段树">1、关于 zkw 线段树</h3>
<p>本人认为：<strong>狭义</strong>的 zkw 线段树是指建立出满二叉树结构、节点间的父子关系严格规定、一切信息从叶子节点开始向上维护、通过循环递推实现维护过程。<br>
另外：张昆玮大佬的 PPT 中提到，为了减小递归带来的常数，出现了<strong>汇编版的非递归</strong>线段树。<br>
所以本人的理解是：<strong>广义</strong>的 zkw 线段树指通过<strong>循环递推而非递归</strong>实现的线段树。</p>
<h3 id="2关于优化效果">2、关于优化效果</h3>
<p>基于多数线段树结构的特点，导致大部分时候必须上下循环两次维护信息，所以此时 zkw 线段树更多优化的是代码的<strong>简洁程度</strong>和<strong>理解难度</strong>（当然了，对常数也有一些优化）。</p>
<h2 id="二可持久化线段树">二、可持久化线段树</h2>
<h3 id="1介绍">1、介绍</h3>
<p>可持久化线段树与普通线段树的区别在于，其支持修改和访问<strong>任意版本</strong>。<br>
举个例子：给定一个序列 <span class="math inline">\(a_N\)</span>，对它进行一百万次操作，然后突然问你第十次操作后的序列信息。</p>
<p>朴素的想法是对于每次操作都建一棵线段树，空间复杂度是 <span class="math inline">\(O(3mn)\)</span> 的。<br>
可以发现：<br>
修改后，大部分节点并没有受到影响，所以考虑只对受影响的节点新建对应节点。其余没受影响的节点直接<strong>与原树共用节点</strong>，就等同于新建了一棵修改后的线段树。</p>
<h3 id="2单点修改单点查询">2、单点修改单点查询</h3>
<p>每次单点修改后，只有叶子节点到根节点的那一条链上的点会受到影响。<br>
所以我们只需要对受影响的这条链新建一条对应的链，其余没受影响的节点直接和待修改版本共用即可。</p>
<p>对于本次要修改的位置，在以原始序列 <span class="math inline">\(a_N\)</span> 建立的初始线段树中，其对应的叶子节点到根的链上的节点分别为 <span class="math inline">\(tl\)</span>，当前新节点为 <span class="math inline">\(now\)</span>，下一个新节点为 <span class="math inline">\(new\)</span>：<br>
如果 <span class="math inline">\(tl\)</span> 为左儿子，那么 <span class="math inline">\(now\)</span> 的左儿子为 <span class="math inline">\(new\)</span>，右儿子为 <span class="math inline">\(tl\)</span> 对应在待修改树上节点的兄弟节点；<br>
如果 <span class="math inline">\(tl\)</span> 为右儿子，那么 <span class="math inline">\(now\)</span> 的右儿子为 <span class="math inline">\(new\)</span>，左儿子为 <span class="math inline">\(tl\)</span> 对应在待修改树上节点的兄弟节点。</p>
<p>其实就是新建节点的位置与初始树上的节点位置<strong>分别对应</strong>。<br>
看图（节点内数字为节点编号）：在<strong>原序列</strong>上修改一个位置:</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140742789-1551916591.png" alt="" loading="lazy"></p>
<p>在<strong>第一次修改后</strong>的序列上，再修改一次：</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140759321-1169860931.png" alt="" loading="lazy"></p>
<p>继续在<strong>第一次修改后</strong>的序列上做修改：</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202411/3259522-20241113140805363-527785385.png" alt="" loading="lazy"></p>
<p>我们发现新建的链在新树上的位置，与初始树上的链在初始树上的位置，是<strong>相同</strong>的。<br>
所以我们新建节点时，新节点的位置<strong>跟随</strong>对应的初始树上的节点的位置进行<strong>移动</strong>。</p>
<p>由于版本间需要<strong>以根节点做区分</strong>（因为使用叶子节点会非常麻烦），所以<strong>修改和查询</strong>操作只能从根节点开始<strong>自上而下</strong>进行，防止不同版本的存储出现问题。<br>
所以我们需要多一个记录：当前节点的左右儿子。</p>
<p>对于 <span class="math inline">\(tl\)</span> 到根的链如何快速求得，我们前面讲“哨兵”的时候已经讲过实现，接下来就是模拟整个新建节点过程即可。<br>
同时，新建节点的节点编号依次递增，操作后进行<strong>自下而上维护</strong>信息也很方便：</p>
<pre><code class="language-cpp">//建初始线段树
  while(P&lt;=n+1) P&lt;&lt;=1,++DEP; NOW = (1&lt;&lt;(DEP+1))-1;//最后一个节点的编号
  for(int i=1;i&lt;=n;++i) read(tr[P+i]); rt[0] = 1;//初始树根为1
  for(int i=P-1;i;--i) son[i][0]=i&lt;&lt;1,son[i][1]=i&lt;&lt;1|1;//记录子节点 0为左儿子；1为右儿子
//...
//...
  inline void update(int i,int vi,int val,int l){
  	int tl = l+P;//在初始树上对应的叶子节点编号
  	int v = rt[vi];//待修改线段树的根
  	rt[i] = l = ++NOW;//新线段树的根
  	for(int dep=DEP-1; dep&gt;=0 ;--dep,l = NOW){
        //模拟节点更新过程
		if((tl&gt;&gt;dep)&amp;1) son[l][0] = son[v][0],son[l][1] = ++NOW,v = son[v][1];
  		else son[l][0] = ++NOW,son[l][1] = son[v][1],v = son[v][0];
  	}
  	tr[l] = val;//更新最后的叶子节点

    //自下而上维护信息（如果有需要的话）
    //for(int dep=1;dep&lt;=DEP;++dep) tr[l-dep]=tr[son[l-dep][0]]+tr[son[l-dep][1]];
  }
</code></pre>
<p>版本查询与修改相同，从根开始模拟子树选取：</p>
<pre><code class="language-cpp">//
  inline int query(int vi,int l){
  	int tl = l+P;//在初始树上对应的叶子节点编号
  	l = rt[vi];//当前版本的根
  	for(int dep=DEP-1; dep&gt;=0 ;--dep) l=son[l][(tl&gt;&gt;dep)&amp;1];
  	return tr[l];//返回叶子节点值
  }
</code></pre>
<h3 id="3区间修改区间查询">3、区间修改区间查询</h3>
<p>目前我了解到的信息是：<strong>只能做区间加</strong>。<br>
可持久化线段树中有大量的公用节点，所以标记不能下放且修改要能够用永久化标记维护，否则会<strong>对其他版本产生影响</strong>。</p>
<p>那么考虑如何做区间加。</p>
<ol>
<li>标记永久化：省去标记下放以减小常数同时防止对其他版本产生影响；</li>
<li>预处理时记录子树大小，查讯时累加标记值。</li>
</ol>
<p>不同的是：</p>
<ol>
<li>需要对区间新建节点；</li>
<li>修改时对照初始树上节点的轨迹进行移动；</li>
<li>修改需要自上而下进行，然后再自下而上做一遍维护（类似递归回溯）。</li>
</ol>
<h2 id="三权值线段树">三、权值线段树</h2>
<h3 id="1介绍-1">1、介绍</h3>
<p>普通线段树维护的是信息，权值线段树维护的是<strong>信息的个数</strong>。<br>
权值线段树相当于在普通线段树上开了一个<strong>桶</strong>，用于处理信息个数，以<strong>单点修改和区间查询</strong>实现<strong>动态全局第 <span class="math inline">\(k\)</span> 大</strong>。</p>
<h3 id="2查询全局排名">2、查询全局排名</h3>
<p>在权值线段树中，节点存信息出现的次数：</p>
<pre><code class="language-cpp">//
  inline void update(int l,int k){
  	l += P; tr[l] += k;//k为信息出现次数 
  	for(l&gt;&gt;=1; l ;l&gt;&gt;=1) tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];
  }
</code></pre>
<p>当前数字的相对大小位置向前的前缀和，即为当前数字在<strong>全局</strong>中的排名：</p>
<pre><code class="language-cpp">//
  inline int get_rank(int r){//查询第r个数的全局排名 
  	int l = 1+P-1;//做区间[1,r]的前缀和 
  	r += P+1;
  	int res = 0;
  	while(l^1^r){
  		if(~l&amp;1) res+=tr[l^1];
  		if(r&amp;1) res+=tr[r^1];
  		l&gt;&gt;=1; r&gt;&gt;=1; 
  	}
  	return res;
  }
</code></pre>
<h3 id="3动态全局第--大">3、动态全局第 <span class="math inline">\(k\)</span> 大</h3>
<p>基于线段树的结构，第 <span class="math inline">\(k\)</span> 大的<strong>二分</strong>实现其实就在线段树上<strong>查找左右子树</strong>的过程。<br>
查询第 <span class="math inline">\(k\)</span> 大时，借助线段树的结构，以左右子树选取来模拟<strong>二分过程</strong>即可：</p>
<pre><code class="language-cpp">//
  inline int K_th(int k){
  	int l = 1,dep = 0;
  	while(dep&lt;DEP){
  		if(tr[l&lt;&lt;1]&gt;=k) l=l&lt;&lt;1;//模拟二分 
  		else k-=tr[l&lt;&lt;1],l=l&lt;&lt;1|1;
  		++dep;
  	}
  	return l-P;//减去虚点编号，得到原数组中的编号 
  }
</code></pre>
<h3 id="4前驱与后继">4、前驱与后继</h3>
<p>有时还需要查询 <span class="math inline">\(k\)</span> 的前驱和后继。<br>
<span class="math inline">\(k\)</span> 的前驱为：最大的小于 <span class="math inline">\(k\)</span> 的数；<br>
<span class="math inline">\(k\)</span> 的后继为：最小的大于 <span class="math inline">\(k\)</span> 的数。<br>
查 <span class="math inline">\(k\)</span> 的前驱可以看作：查与 <span class="math inline">\(k-1\)</span> 的排名相同数；<br>
查 <span class="math inline">\(k\)</span> 的后继可以看作：查比 <span class="math inline">\(k\)</span> 的排名靠后一位的数。<br>
结合一下 <span class="math inline">\(get\_rank\)</span> 和 <span class="math inline">\(K\_th\)</span> 即可：</p>
<pre><code class="language-cpp">//
  inline int pre(int k){
  	int rk = get_rank(k-1);
  	return K_th(rk);
  } 
  inline int nex(int k){
  	int rk = get_rank(k)+1; 
  	return K-th(rk);
  }
</code></pre>
<h2 id="四可持久化权值线段树主席树">四、可持久化权值线段树（主席树）</h2>
<p><s>有人说 zkw 做不了主席树，我急了。</s></p>
<h3 id="1介绍-2">1、介绍</h3>
<p>顾名思义，就是<strong>可持久化线段树和权值线段树</strong>结合。<br>
大部分情况下只需要支持区间查询，常用于解决<strong>静态区间第 <span class="math inline">\(k\)</span> 大</strong>，因为单独的主席树不太好进行修改操作。<br>
当然，<strong>动态区间第 <span class="math inline">\(k\)</span> 大</strong>的实现——树套树，可以直接跳到<strong>目录五</strong>去看。</p>
<h3 id="2静态区间第--大">2、静态区间第 <span class="math inline">\(k\)</span> 大</h3>
<p>主席树对序列的每个位置都维护一棵线段树，其节点值为对应序列上值的范围。<br>
在第 <span class="math inline">\(m\)</span> 棵线段树上，区间 <span class="math inline">\([L,R]\)</span> 维护的是：序列上 <span class="math inline">\(a_i\sim a_m\)</span> 中，有多少数字在 <span class="math inline">\([L,R]\)</span> 范围内。</p>
<p>我们对序列中<strong>每一个数的权值</strong>都开一棵线段树，一共开 <span class="math inline">\(N\)</span> 棵树，存不下，所以使用可持久化线段树。<br>
由于权值线段树存下了数的权值，每个节点上存的是前缀和，信息具有可加性。所以查 <span class="math inline">\([L,R]\)</span> 等于查 <span class="math inline">\([1,R]-[1,L-1]\)</span>。<br>
可持久化线段树的新建书和权值线段树的查询结合一下就好了：</p>
<pre><code class="language-cpp">//可持久化线段树的建新树
  inline void update(int i,int vi,int l,int k){
  	int tl = l+P;
  	int v = rt[vi];
  	rt[i] = l = ++NOW;
  	for(int dep=DEP-1; dep&gt;=0 ;--dep,l=NOW){
		if((tl&gt;&gt;dep)&amp;1) son[l][0] = son[v][0],son[l][1] = ++NOW,v = son[v][1];
  		else son[l][1] = son[v][1],son[l][0] = ++NOW,v = son[v][0];
  	}
  	tr[l] = tr[v]+k;//需要维护前缀和
    //向上维护信息
  	for(int dep=1;dep&lt;=DEP;++dep) tr[l-dep]=tr[son[l-dep][0]]+tr[son[l-dep][1]];
  }
//权值线段树的查询
  inline int query(int l,int r,int k){
    //查 [l,r] 相当于查 [1,r]-[1,l-1]
  	l = rt[l-1];r = rt[r];
    int tl = 1;//答案
  	for(int dep=0;dep&lt;DEP;++dep){
  		int num = tr[son[r][0]]-tr[son[l][0]];//左子树大小
		if(num&gt;=k){//不比左子树大，说明在左子树中
			l = son[l][0];
			r = son[r][0];
            tl = tl&lt;&lt;1;
		}
		else{//比左子树大，说明在右子树中
			k -= num;
			l = son[l][1];
			r = son[r][1];
            tl = tl&lt;&lt;1|1;
		}
	}
	return tl-P;//当前权值为：对应在初始树上位置减虚点编号
  }
</code></pre>
<h2 id="五树状数组套权值线段树">五、树状数组套权值线段树</h2>
<h3 id="1介绍-3">1、介绍</h3>
<p>上文说，单独的主席树不方便维护<strong>动态区间第 <span class="math inline">\(k\)</span> 大</strong>，主要是因为主席树修改时，对应的其他版本关系被破坏了。<br>
实现动态第 <span class="math inline">\(k\)</span> 大的朴素想法当然还是对序列的每个位置都开一棵权值线段树，那么难点就在于我们到底要对哪些树做修改。</p>
<p>由于<strong>权值线段树具有可加性</strong>的性质，所以我们可以拿一个树状数组维护线段树的前缀和，用于求出要修改哪些树。这个过程我们可以用 <span class="math inline">\(lowbit\)</span> 来实现。</p>
<p>把要修改的树编号存下来，然后做线段树相加的操作，此时操作就从多棵线段树变成了在一棵线段树上操作。</p>
<h3 id="2初始化">2、初始化</h3>
<p>对序列的每个点建一棵 zkw 线段树的话，空间会变成 <span class="math inline">\(Q(3n^2)\)</span> 的，所以我们需要<strong>动态开点</strong>，空间复杂度变成 <span class="math inline">\(O(n\log^2{n})\)</span>。<br>
（存个节点而已，我们 zkw 也要动态开点，父子关系对应初始树就可以了）。</p>
<p>为了保证修改和查询时新树节点与序列的对应关系，以及严格确定的树形结构，所以我们先建一棵初始树（<strong>不用真的建出来，因为我们只会用到编号</strong>），操作时新树上的节点<strong>跟随</strong>对应在初始树上的节点进行移动。</p>
<pre><code class="language-cpp">//
  for(int i=1;i&lt;=n;++i){
  	read(a[i]);
  	b[++idx] = a[i];
  }
  sort(b+1,b+1+idx);
  idx = unique(b+1,b+1+idx)-(b+1);//离散化
  while(P&lt;=idx+1) P&lt;&lt;=1,++DEP;//求初始树上节点编号备用
  for(int i=1;i&lt;=n;++i){
  	a[i] = lower_bound(b+1,b+1+idx,a[i])-b;
  	add(i,1);//对每个位置建线段树
  }
//...
  inline void update(int i,int l,int k){
  	int tl = l+P,stop = 0;
  	rt[i] ? 0 : rt[i]=++NOW;//动态开点
  	l = rt[i]; st[++stop] = l;tr[l] += k;
  	for(int dep=DEP-1;dep&gt;=0;--dep,st[++stop]=l,tr[l]+=k){
  		if((tl&gt;&gt;dep)&amp;1) son[l][1]?0:son[l][1]=++NOW,l=son[l][1];
  		else son[l][0]?0:son[l][0]=++NOW,l=son[l][0];
	}
    //为了方便也可以把链上的节点全存下来再做维护
  	//while(--stop) tr[st[stop]] = tr[son[st[stop]][0]]+tr[son[st[stop]][1]];
  }
  inline void add(int x,int k){//lowbit求需要用到的线段树
  	for(int i=x;i&lt;=n;i+=(i&amp;-i)) update(i,a[x],k);
  }
</code></pre>
<h3 id="3单点修改">3、单点修改</h3>
<p>先把原来数的权值减一，再让新的数权值加一。</p>
<pre><code class="language-cpp">//
  inline void change(int pos,int k){
  	add(pos,-1);
  	a[pos] = k;
  	add(pos,1);
  }
</code></pre>
<h3 id="4查询区间排名">4、查询区间排名</h3>
<p>由于权值线段树维护的是前缀和，所以把区间 <span class="math inline">\([L,R]\)</span> 的查询看作查询 <span class="math inline">\([1,R]-[1,L-1]\)</span>。<br>
先用树状数组求出需要用到的线段树，然后做线段树相加，求前缀和即可。</p>
<pre><code class="language-cpp">//
  inline int query_rank(int l){
  	l += P;
  	int res = 0;
  	for(int dep=DEP-1;dep&gt;=0;--dep){
  		if((l&gt;&gt;dep)&amp;1){//做线段树相加求前缀和
  			for(int i=1;i&lt;=tmp0;++i) res-=tr[son[tmp[i][0]][0]],tmp[i][0]=son[tmp[i][0]][1];
  			for(int i=1;i&lt;=tmp1;++i) res+=tr[son[tmp[i][1]][0]],tmp[i][1]=son[tmp[i][1]][1];
  		}
  		else{
  			for(int i=1;i&lt;=tmp0;++i) tmp[i][0]=son[tmp[i][0]][0];
  			for(int i=1;i&lt;=tmp1;++i) tmp[i][1]=son[tmp[i][1]][0];
  		}
  	}
  	return res;
  }
  inline int get_rank(int l,int r,int k){
  	tmp0 = tmp1 = 0;
  	for(int i=l-1; i ;i-=(i&amp;-i)) tmp[++tmp0][0] = rt[i];
  	for(int i=r; i ;i-=(i&amp;-i)) tmp[++tmp1][1] = rt[i];
  	return query_rank(k)+1;
    //query_rank求的是小于等于k的数的个数，加一就是k的排名
  }
</code></pre>
<h3 id="5动态区间第--大">5、动态区间第 <span class="math inline">\(k\)</span> 大</h3>
<p>和查询排名道理一样：由于权值线段树维护的是前缀和，所以把区间 <span class="math inline">\([L,R]\)</span> 的查询看作查询 <span class="math inline">\([1,R]-[1,L-1]\)</span>。<br>
还是先用树状数组求出需要用到的线段树，查询时做线段树相加。然后模拟线段树上二分就可以了。</p>
<pre><code class="language-cpp">//
  inline int query_num(int k){
  	int l = 1;
  	for(int dep=0,res=0;dep&lt;DEP;++dep,res=0){
  		for(int i=1;i&lt;=tmp0;++i) res-=tr[son[tmp[i][0]][0]];
  		for(int i=1;i&lt;=tmp1;++i) res+=tr[son[tmp[i][1]][0]];//每棵树的节点值都满足可加
  		if(k&gt;res){
  			k -= res;//做树上二分
  			for(int i=1;i&lt;=tmp0;++i) tmp[i][0]=son[tmp[i][0]][1];
  			for(int i=1;i&lt;=tmp1;++i) tmp[i][1]=son[tmp[i][1]][1];
  			l = l&lt;&lt;1|1;
  		} 
  		else{
  			for(int i=1;i&lt;=tmp0;++i) tmp[i][0]=son[tmp[i][0]][0];
  			for(int i=1;i&lt;=tmp1;++i) tmp[i][1]=son[tmp[i][1]][0];
  			l = l&lt;&lt;1;
  		}
  	}
  	return l-P;//叶子节点对应编号
  }
  inline int get_num(int l,int r,int k){
  	tmp0 = tmp1 = 0;//先用lowbit求需要查询的线段树
  	for(int i=l-1; i ;i-=(i&amp;-i)) tmp[++tmp0][0] = rt[i];
  	for(int i=r; i ;i-=(i&amp;-i)) tmp[++tmp1][1] = rt[i];
  	return query_num(k);
  }
</code></pre>
<p><strong>线段树套线段树</strong>与其原理相同。下层线段树维护序列信息，再用一棵上层线段树来维护下层线段树的信息，上层线段树的每一个节点都是一棵线段树。</p>
<p><strong>线段树套平衡树</strong>原理也一样。下层平衡树维护序列信息，再用一棵上层线段树来维护下层平衡树的信息，上层线段树的每一个节点都是一棵平衡树。</p>
<p>具体请看图自行脑补（<s>真的码不动字了啊</s>）：</p>
<p><img src="https://img2024.cnblogs.com/blog/3259522/202501/3259522-20250122202222061-1718319912.png" alt="" loading="lazy"></p>
<h2 id="六兔队线段树">六、兔队线段树</h2>
<p>（本人不是特别了解，所以暂时仅作信息具有<strong>可加减性</strong>的解释）<br>
<s>有人说 zkw 做不了兔队线段树，我急了。</s></p>
<h3 id="1介绍-4">1、介绍</h3>
<p>兔队线段树是指一类：在信息修改<strong>同时</strong>，以 <span class="math inline">\(O(\log{n})\)</span> 复杂度做维护的线段树。支持单点修改区间查询，通常用来维护<strong>前缀最大值</strong>的问题。<br>
（粉兔在<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html" target="_blank">这篇文章</a>中率先对其进行了说明）</p>
<h3 id="2处理与维护">2、处理与维护</h3>
<p>其处理与维护信息的大致方式可以看作：</p>
<ol>
<li>首先修改信息，然后从下到上做维护；</li>
<li>向上维护时每到达一个节点，都再次从下到上维护信息；</li>
<li>第二次从下到上维护时，左子树对答案贡献不变，只考虑右子树对答案的贡献。</li>
</ol>
<p>由于第一次向上维护时，需要从当前节点开始对其所有子树进行第二次维护，所以递归线段树常用的方法是<strong>二次递归</strong>处理右子树信息。</p>
<h3 id="3具体实现">3、具体实现</h3>
<p>考虑如何用 zkw 线段树<strong>递推</strong>处理右子树信息。<br>
首先，对单点进行修改后，<strong>从下到上</strong>进行处理和维护，同时记录节点深度，防止第二次维护时发生越界：</p>
<pre><code class="language-cpp">//单点修改后，每次上传更新到根节点
  inline void update(int l,ll k){
  	l += P;int dep = DEP;
  	mx[l] = k;mn[l] = k;//...
  	for(l&gt;&gt;=1,--dep; l ;l&gt;&gt;=1,--dep) push_up(l,dep);
  }
</code></pre>
<p>然后，再次模拟标记上传过程：</p>
<pre><code class="language-cpp">//
  inline void push_up(int l,int dep){
  	mx[l] = max(mx[l&lt;&lt;1],mx[l&lt;&lt;1|1]);
  	//...
  	ans[l] = ans[l&lt;&lt;1]+calc(l&lt;&lt;1|1,dep+1,mx[l&lt;&lt;1]); 
  }
  inline int calc(int l,int dep,ll mx){
  	int res = 0,tl = l;
  	while(dep&lt;DEP){//模拟左右子树选取过程
		if(mx[l]&lt;=k) break;//剪枝之类的
		if(mx[l&lt;&lt;1]&lt;=k) l = l&lt;&lt;1|1;
		else{
			res += len[l]-len[l&lt;&lt;1];//信息有可减性，考虑左区间的覆盖 
			l &lt;&lt;= 1;
		}
		++dep; 
	}
	if(dep==DEP) res += (mx[l]&gt;k);//叶子节点特判
  }
</code></pre>
<h2 id="七kinetic-tournamen-tree">七、Kinetic Tournamen Tree</h2>
<p>（有读者评论问能不能实现 KTT，我们讨论研究后发现是可以的。）</p>
<h3 id="1介绍-5">1、介绍</h3>
<p>KTT 最初在 <a href="https://rusunoi.github.io/books/National-Team-Thesis/2020.pdf" target="_blank" rel="noopener nofollow">2020 年集训队论文</a>中由 <a href="https://www.luogu.com.cn/user/21423" target="_blank" rel="noopener nofollow">EI </a>队长提出。<br>
KTT 用来维护<strong>动态区间最大值</strong>问题，其基本思想为将需要维护的信息看作<strong>一次函数</strong>，所有修改都基于函数进行。同时设置<strong>阈值</strong>，表示维护的答案取值何时发生变化，当修改或查询的信息达到阈值时，暴力重构子树维护答案。</p>
<p>笔者觉得学习 KTT 最好还是从一些具体问题入手。所以我们下文的内容，<strong>全部围绕</strong>论文中提到的经典问题 <a href="https://www.luogu.com.cn/problem/P5693" target="_blank" rel="noopener nofollow">P5693 EI 的第六分块</a>进行展开。</p>
<h3 id="2信息处理">2、信息处理</h3>
<p>最大子段和要记录四个信息用线段树维护，信息合并时分类讨论：</p>
<ul>
<li><span class="math inline">\(lmax = \max(lmax_{ls},sum_{ls}+lmax_{rs})\)</span>；</li>
<li><span class="math inline">\(rmax = \max(rmax_{rs},sum_{rs}+rmax_{ls})\)</span>；</li>
<li><span class="math inline">\(mx = \max(mx_{ls},mx_{rs},rmax_{ls}+lmax_{rs})\)</span>。</li>
</ul>
<p>进行<strong>动态</strong>维护就要用 KTT 了，这是我们的重点内容。</p>
<p>现在每个信息记录的都不是一个具体值，而是一条<strong>一次函数</strong>：<span class="math inline">\(f(x)=kx+b\)</span>。<br>
其中 <span class="math inline">\(k\)</span> 为最大子段的长度，<span class="math inline">\(x\)</span> 为变化量，<span class="math inline">\(f(0)=b\)</span> 为当前维护的具体值。<br>
同时，对于两条函数，记录一个<strong>阈值 <span class="math inline">\(dx\)</span></strong>，表示当前区间最大值是否在两个函数间进行<strong>交替</strong>。</p>
<h3 id="3关于交替阈值">3、关于交替阈值</h3>
<p><s>前置知识：<a href="http://www.shuxue9.com/pep/cz8x/ebook/103.html" target="_blank" rel="noopener nofollow">人教版八年级下册 19.2.3一次函数与方程、不等式</a></s><br>
在对两条函数进行合并取<strong>最大值</strong>时，需要知道具体应该<strong>何时</strong>选取哪条函数。我们知道应该看函数的交点相对于区间的位置，来对取值情况分类讨论。<br>
交替阈值就干了这样一件事情，维护时记录下何时应该对函数选取进行交替，并只在需要交替时交替，以此优化时间复杂度。</p>
<p>具体地，当<strong>区间加 <span class="math inline">\(q\)</span></strong> 时，函数向上进行了移动，函数的交点相对于区间进行了左右移动。此时我们令<strong>阈值 <span class="math inline">\(dx\)</span> 减小</strong>，当 <span class="math inline">\(dx&lt;0\)</span> 时表示此时选取的函数要进行交替了。<br>
具体减少多少呢，由于函数都满足 <span class="math inline">\(k\ge 1\)</span>，所以至少要令 <span class="math inline">\(dx-=q\)</span>（当然最好是这个数，减多了重构次数就太多了）。<br>
由于同一个区间可能有两个不同的函数进行维护，所以在合并区间时，阈值不仅要对左右区间取最小值，还需要包含当前两条函数的交点。</p>
<h3 id="4区间及函数合并">4、区间及函数合并</h3>
<p>笔者个人建议写成<strong>重载运算符</strong>形式。<br>
针对函数的操作，有求交点、函数合并、函数移动：</p>
<pre><code class="language-cpp">//struct Func
	inline Func operator + (const Func&amp;G) const{//函数合并
		return Func(k+G.k,b+G.b);
	}
	inline ll operator &amp; (const Func&amp;G) const{//求交点
		return (G.b-b)/(k-G.k);
	}
	inline void operator += (const ll&amp;G){//函数向上移动
		b += k*G;
	}
</code></pre>
<p>区间合并时，我们在函数操作的基础上分类讨论即可，注意同时维护阈值信息：</p>
<pre><code class="language-cpp">//struct Tree
	inline bool operator &lt; (const Func&amp;G) const{
        //钦定两条函数的相对位置，方便判断有没有交点
		return k==G.k &amp;&amp; b&lt;G.b || k&lt;G.k;
	}
    inline void Merge_lx(Func x,Func y,Tree &amp;tmp) const{//求lmax
		if(x&lt;y) swap(x,y);
		if(x.b&gt;=y.b) tmp.lx = x;//钦定过了函数位置，此时两条函数没有交点
		else tmp.lx = y,tmp.dx = Min(tmp.dx,x&amp;y);
	}
    //...
	inline Tree operator + (const Tree&amp;G) const{//区间合并
		Tree tmp;tmp.sum = sum+G.sum; tmp.dx = Min(dx,G.dx);//注意维护阈值信息 
		Merge_lx(lx,sum+G.lx,tmp);Merge_rx(G.rx,G.sum+rx,tmp);
		Merge_mx(G.mx,mx,tmp);Merge_mx(tmp.mx,rx+G.lx,tmp);
		return tmp;
	}
</code></pre>
<h3 id="5修改与重构">5、修改与重构</h3>
<p>区间加按照正常的方式来，唯一不同的是在修改后需要对节点子树进行<strong>重构</strong>。<br>
首先第一步肯定是下放标记：</p>
<pre><code class="language-cpp">//struct Tree
  inline void operator += (const ll&amp;G){//区间加
		lx += G; rx += G; mx += G; sum += G; dx -= G;
  }
//
  inline void push_down(int p){//正常push_down
     if(tag[p]){
  		tag[p&lt;&lt;1] += tag[p]; tr[p&lt;&lt;1] += tag[p];
  		tag[p&lt;&lt;1|1] += tag[p]; tr[p&lt;&lt;1|1] += tag[p];
		tag[p] = 0;
     }
  }
</code></pre>
<p>然后再正常做修改：</p>
<pre><code class="language-cpp">//
  inline void update(int l,int r,ll k){
  	l += P-1; r += P+1;//先push_down
  	for(int dep=DEP;dep;--dep) push_down(l&gt;&gt;dep),push_down(r&gt;&gt;dep);
  	while(l^1^r){
  		if(~l&amp;1) tag[l^1]+=k,tr[l^1]+=k,rebuild(l^1);//别忘了重构
  		if(r&amp;1) tag[r^1]+=k,tr[r^1]+=k,rebuild(r^1);
  		l&gt;&gt;=1;r&gt;&gt;=1;
  		tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];
  		tr[r] = tr[r&lt;&lt;1]+tr[r&lt;&lt;1|1];
  	}
  	for(l&gt;&gt;=1; l ;l&gt;&gt;=1) tr[l] = tr[l&lt;&lt;1]+tr[l&lt;&lt;1|1];
  }
</code></pre>
<p>对于重构，从当前子树的根节点开始一层一层向下递推，直到没有节点需要重构为止：</p>
<pre><code class="language-cpp">//
  inline void rebuild(int p){
  	if(tr[p].dx&gt;=0) return ;
  	int head = 1,tail = 0;
  	st[++tail] = p; push_down(p);
  	while(tail&gt;=head){//模拟压栈
		int ttail = tail;
		for(int j=tail,pos;j&gt;=head;--j){
  			pos = st[j]; //看子节点的子树是否需要更新
  			if(tr[pos&lt;&lt;1].dx&lt;0) st[++tail]=pos&lt;&lt;1,push_down(pos&lt;&lt;1);//注意push_down
  			if(tr[pos&lt;&lt;1|1].dx&lt;0) st[++tail]=pos&lt;&lt;1|1,push_down(pos&lt;&lt;1|1);
  		}
  		head = ttail+1;
  	}//重新维护
  	do{ tr[st[tail]]=tr[st[tail]&lt;&lt;1]+tr[st[tail]&lt;&lt;1|1]; } while(--tail); 
  }
</code></pre>
<h3 id="6查询">6、查询</h3>
<p>正常做查询就可以了。<br>
需要注意一点，区间合并时要<strong>按照左右顺序</strong>进行。</p>
<pre><code class="language-cpp">//
  inline ll query(int l,int r){
  	l += P-1; r += P+1;//先push_down
  	for(int dep=DEP;dep;--dep) push_down(l&gt;&gt;dep),push_down(r&gt;&gt;dep);
  	Tree resl,resr;
  	while(l^1^r){
        //注意左右区间的合并顺序
  		if(~l&amp;1) resl = resl+tr[l^1];
  		if(r&amp;1) resr = tr[r^1]+resr;
  		l&gt;&gt;=1;r&gt;&gt;=1;
  	}
  	return (resl+resr).mx.b;
  }
</code></pre>
<p>KTT 的基本思路就是这样，将信息转换为函数进行处理，同时维护阈值进行重构。这使得 KTT 有优于分块的复杂度，但同时也对其使用产生了限制。</p>
<hr>
<h1 id="zkw-实现一些线段树功能">zkw 实现一些线段树功能</h1>
<h2 id="一线段树优化建图">一、线段树优化建图</h2>
<p><strong>递归实现要写一车代码，相比之下 zkw 实现显得极致简洁。</strong></p>
<h3 id="1介绍-6">1、介绍</h3>
<p>当我们需要对一段区间内的点进行连边时，如果对每一点都连一条边，边数是 <span class="math inline">\(O(n^2)\)</span> 的，往往会炸空间。<br>
我们可以基于线段树的思想，将向区间的每一点连边，改为向一些区间连边，将空间优化为 <span class="math inline">\(O(n\log{n})\)</span>。</p>
<h3 id="2入树与出树">2、入树与出树</h3>
<p>构建一棵线段树，每个节点代表一个区间，每个父亲结点向其子节点连一条权值为 <span class="math inline">\(0\)</span> 的有向边。有向边从父节点连向子节点的叫做<strong>出树</strong>。</p>
<p>再构建一棵线段树，与出树一样，每个节点代表一个区间。不同的是，每个子节点向其父亲结点连一条权值为 <span class="math inline">\(0\)</span> 的有向边。有向边从子节点连向父节点的叫做<strong>入树</strong>。</p>
<p>有时我们只用到其中一种，有时需要两者结合。<br>
当入树与出树配合使用时，需要先对<strong>它们对应的叶子节点分别连边</strong>（因为它们表示同一个点）且<strong>权值为 <span class="math inline">\(0\)</span></strong>，然后再分别做更新。</p>
<h3 id="3实现">3、实现</h3>
<p>当出树与入树同时使用时，为了区分，我们令入树或出树的节点编号进行整体偏移即可。</p>
<pre><code class="language-cpp">//
  while(P&lt;=n+1) P&lt;&lt;=1,++DEP;
  NOW = (P&lt;&lt;1)-1;//偏移量
  for(int i=P-1;i;--i){
    add(i,i&lt;&lt;1,0);add(i,i&lt;&lt;1|1,0);//建入树
    add((i&lt;&lt;1|1)+NOW,i+NOW,0);add((i&lt;&lt;1)+NOW,i+NOW,0);//建出树
  }
  //入树与出树的叶子节点连边
  for(int i=1;i&lt;=n;++i) add(i+P,i+P+NOW,0),add(i+P+NOW,i+P,0);
</code></pre>
<ul>
<li>点向区间连边时，从入树的点向出树的区间连边；</li>
<li>区间向点连边时，从入树的区间向出树的点连边。</li>
</ul>
<pre><code class="language-cpp">//点向区间连边
  inline void update_dot_intvl(int v,int l,int r,ll w){
    l += P-1; r += P+1; v += P;//出树上叶子节点编号
	while(l^1^r){
        if(~l&amp;1) add(v+NOW,l^1,w);//入树编号有偏移量
        if(r&amp;1) add(v+NOW,r^1,w);
        l&gt;&gt;=1;r&gt;&gt;=1;
	}
  }
//区间向点连边
  inline void update_intvl_dot(int v,int l,int r,ll w){
	l += P-1; r += P+1; v += P;//出树上叶子节点编号
    while(l^1^r){
        if(~l&amp;1) add((l^1)+NOW,v,w);//入树编号有偏移量
        if(r&amp;1) add((r^1)+NOW,v,w);
        l&gt;&gt;=1;r&gt;&gt;=1;
	}
  }
</code></pre>
<p>（当然了，有主席树、树套树、zkw 当 ST 表使等等等等等优化方式，根据需求进行选择，作者目前先只对线段树优化建图进行介绍。<s>没时间码字啊。</s>）</p>
<h2 id="二扫描线">二、扫描线</h2>
<p><s>（只讲 zkw 的实现了，过几天再码介绍的字。）</s></p>
<h3 id="1介绍-7">1、介绍</h3>
<p>用来求矩形面积并。<br>
将矩形按纵坐标排序，用线段树维护每个位置被图形覆盖的次数以及长度。<br>
向线一样从纵坐标一次自下而上扫一遍。</p>
<h3 id="2实现">2、实现</h3>
<p>主函数内当然还是先存下信息，然后排序、离散化、然后扫描。<br>
我们来看看线段树内有什么不同。</p>
<p>首先是维护过程。不同与递归线段树，我们可以<strong>直接通过节点深度及其编号</strong>求出其所<strong>管辖的区间</strong>。</p>
<pre><code class="language-cpp">//len为维护的覆盖长度
  inline void push_up(int p,int dep){
	if(tr[p].vis){//如果被覆盖了
		int l = p&lt;&lt;dep;//管辖的区间的左端点
		int r = l+(1&lt;&lt;dep)-1;//根据区间长度求右端点
		tr[p].len = b[r-P+1]-b[l-P];
	}
	else{
		if(P&gt;p) tr[p].len = tr[p&lt;&lt;1].len+tr[p&lt;&lt;1|1].len;//非叶子节点
		else tr[p].len = 0;//叶子节点
	}
  }
</code></pre>
<p>所以我们在更新的时候，还需要记录当前叶子节点的深度（从下到上啦）用来求其子树内叶子节点的个数。</p>
<pre><code class="language-cpp">//
  inline void update(int l,int r,int k){
	l += P-1; r += P+1; int dep = 0;//记录当前节点深度
// 	if(l&gt;=r) return ;
	while(l^1^r){
		if(~l&amp;1) tr[l^1].vis+=k,push_up(l^1,dep);
		if(r&amp;1) tr[r^1].vis+=k,push_up(r^1,dep);
		l&gt;&gt;=1;r&gt;&gt;=1;++dep;
		push_up(l,dep);push_up(r,dep);
	}
	for(l&gt;&gt;=1,++dep; l ;l&gt;&gt;=1,++dep) push_up(l,dep);
  }
</code></pre>
<p>于是我们可以省掉记录节点管辖的左右端点的空间。</p>
<hr>
<p><strong>到现在，能肯定 zkw 线段树基本可以实现递归线段树能做的全部操作了。</strong></p>
<h1 id="一些模板题及代码">一些模板题及代码</h1>
<p>放<a href="https://www.luogu.com.cn/paste/yusgq24m" target="_blank" rel="noopener nofollow">云剪贴板</a>了，会跟随文章更新（也可以看<a href="https://www.cnblogs.com/Tmbcan/articles/18631278" target="_blank">博客</a>）。</p>
<h1 id="后记">后记</h1>
<h3 id="更新日志"><a href="https://www.luogu.com.cn/paste/fjxmvbvx" target="_blank" rel="noopener nofollow">更新日志</a></h3>
<p>笔者目前学识过于浅薄，文章大部分内容是笔者自己的理解，可能有地方讲得不是很清楚。等笔者再学会新东西，会先更新在<a href="https://www.luogu.com.cn/article/rp96x8b7" target="_blank" rel="noopener nofollow"><strong>此文章</strong></a>以及<a href="https://www.cnblogs.com/Tmbcan" target="_blank"><strong>我的博客</strong></a>，然后找时间统一更新。</p>
<p>同时，笔者会经常对文章内容细节和代码块进行修改完善，如果您有什么想法可以提出来，我们一起来解决。作者真的真的是活的！！！</p>
<p><strong>期待您提出宝贵的建议。</strong></p>
<h3 id="鸣谢">鸣谢</h3>
<p><a href="https://github.com/hzwer/shareOI/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%8A%9B%E9%87%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A8%E6%8E%A5%E8%A7%A6_%E5%BC%A0%E6%98%86%E7%8E%AE.pptx" target="_blank" rel="noopener nofollow">《统计的力量》清华大学-张昆玮 /hzwer整理</a><br>
<a href="https://oi-wiki.org" target="_blank" rel="noopener nofollow">OIWiki</a><br>
<a href="https://blog.csdn.net/weixin_43960287/article/details/108246164" target="_blank" rel="noopener nofollow">CSDN 偶耶XJX</a><br>
<a href="https://tifa-233.com/archives/zkw-segment-tree/" target="_blank" rel="noopener nofollow">Tifa's Blog【洛谷日报 #35】Tifa</a><br>
<a href="https://www.luogu.com.cn/article/2uwf53xs" target="_blank" rel="noopener nofollow">洛谷日报 #4 皎月半洒花</a><br>
<a href="https://www.luogu.com.cn/user/670826" target="_blank" rel="noopener nofollow">NianFeng</a> // <a href="https://www.luogu.com.cn/user/21423" target="_blank" rel="noopener nofollow">EntropyIncreaser</a> //</p>
<p><strong>如需转载，请注明出处。</strong></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002549195126157407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 20:23">2025-01-22 19:33</span>&nbsp;
<a href="https://www.cnblogs.com/Tmbcan">Tmbcan</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18686660" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18686660);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18686660', targetLink: 'https://www.cnblogs.com/Tmbcan/p/18686660', title: 'zkw 线段树-原理及其扩展' })">举报</a>
</div>
        