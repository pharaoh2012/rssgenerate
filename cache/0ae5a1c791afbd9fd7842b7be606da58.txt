
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18945899" title="发布于 2025-06-24 11:02">
    <span role="heading" aria-level="2">Java源码分析系列笔记-6.ReentrantLock</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a><ul><li><a href="#11-synchronized-vs-reentranlock" rel="noopener nofollow">1.1. synchronized vs ReentranLock</a></li></ul></li><li><a href="#2-实现原理" rel="noopener nofollow">2. 实现原理</a><ul><li><a href="#21-uml图" rel="noopener nofollow">2.1. uml图</a></li></ul></li><li><a href="#3-公平锁" rel="noopener nofollow">3. 公平锁</a><ul><li><a href="#31-如何使用" rel="noopener nofollow">3.1. 如何使用</a></li><li><a href="#32-原理分析" rel="noopener nofollow">3.2. 原理分析</a><ul><li><a href="#321-构造方法" rel="noopener nofollow">3.2.1. 构造方法</a><ul><li><a href="#3211-底层使用aqs实现" rel="noopener nofollow">3.2.1.1. 底层使用AQS实现</a></li></ul></li><li><a href="#322-加锁" rel="noopener nofollow">3.2.2. 加锁</a><ul><li><a href="#3221-调用公平锁的lock方法" rel="noopener nofollow">3.2.2.1. 调用公平锁的lock方法</a></li><li><a href="#3222-调用aqs的acquire方法获取锁" rel="noopener nofollow">3.2.2.2. 调用AQS的acquire方法获取锁</a></li><li><a href="#3223-尝试获取锁只有队头才允许抢占锁--公平锁" rel="noopener nofollow">3.2.2.3. 尝试获取锁【只有队头才允许抢占锁--公平锁】</a></li><li><a href="#3224-尝试获取锁失败加入阻塞队列" rel="noopener nofollow">3.2.2.4. 尝试获取锁失败加入阻塞队列</a><ul><li><a href="#32241-入队的操作" rel="noopener nofollow">3.2.2.4.1. 入队的操作</a></li></ul></li><li><a href="#3225-阻塞等待唤醒继续获取锁" rel="noopener nofollow">3.2.2.5. 阻塞，等待唤醒继续获取锁</a><ul><li><a href="#32251-判断是否需要阻塞" rel="noopener nofollow">3.2.2.5.1. 判断是否需要阻塞</a><ul><li><a href="#322511-阻塞当前线程" rel="noopener nofollow">3.2.2.5.1.1. 阻塞当前线程</a></li></ul></li></ul></li></ul></li><li><a href="#323-解锁" rel="noopener nofollow">3.2.3. 解锁</a><ul><li><a href="#3231-使用aqs释放锁" rel="noopener nofollow">3.2.3.1. 使用AQS释放锁</a></li><li><a href="#3232-尝试释放锁" rel="noopener nofollow">3.2.3.2. 尝试释放锁</a></li><li><a href="#3233-释放锁成功后唤醒阻塞队列中的节点" rel="noopener nofollow">3.2.3.3. 释放锁成功后唤醒阻塞队列中的节点</a></li></ul></li></ul></li></ul></li><li><a href="#4-非公平锁" rel="noopener nofollow">4. 非公平锁</a><ul><li><a href="#41-如何使用" rel="noopener nofollow">4.1. 如何使用</a></li><li><a href="#42-实现原理" rel="noopener nofollow">4.2. 实现原理</a><ul><li><a href="#421-构造方法" rel="noopener nofollow">4.2.1. 构造方法</a></li><li><a href="#422-加锁" rel="noopener nofollow">4.2.2. 加锁</a><ul><li><a href="#4221-使用非公平锁加锁" rel="noopener nofollow">4.2.2.1. 使用非公平锁加锁</a></li><li><a href="#4222-通过aqs加锁" rel="noopener nofollow">4.2.2.2. 通过AQS加锁</a></li><li><a href="#4223-通过非公平锁尝试加锁" rel="noopener nofollow">4.2.2.3. 通过非公平锁尝试加锁</a><ul><li><a href="#42231-非公平锁尝试加锁的操作不管是否队头都可以抢占锁--非公平锁" rel="noopener nofollow">4.2.2.3.1. 非公平锁尝试加锁的操作【不管是否队头都可以抢占锁--非公平锁】</a></li></ul></li><li><a href="#4224-尝试加锁失败加入阻塞队列" rel="noopener nofollow">4.2.2.4. 尝试加锁失败，加入阻塞队列</a><ul><li><a href="#42241-加入队列的操作" rel="noopener nofollow">4.2.2.4.1. 加入队列的操作</a></li></ul></li></ul></li><li><a href="#423-解锁" rel="noopener nofollow">4.2.3. 解锁</a><ul><li><a href="#4231-使用aqs释放锁" rel="noopener nofollow">4.2.3.1. 使用AQS释放锁</a></li><li><a href="#4232-尝试释放锁" rel="noopener nofollow">4.2.3.2. 尝试释放锁</a><ul><li><a href="#42321-释放锁成功后唤醒阻塞队列中的后续节点" rel="noopener nofollow">4.2.3.2.1. 释放锁成功后唤醒阻塞队列中的后续节点</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#5-参考" rel="noopener nofollow">5. 参考</a></li></ul></div><p></p>
<h1 id="1-是什么">1. 是什么</h1>
<p>在jdk5之前，synchronized效率极低，于是写了ReentranLock代替。<br>
后来jdk7优化了synchronized，参考<a href="https://www.cnblogs.com/ThinkerQAQ/p/18945202" target="_blank">Java源码分析系列笔记-2.锁的优化 - ThinkerQAQ - 博客园</a>。两者性能区别不大</p>
<h2 id="11-synchronized-vs-reentranlock">1.1. synchronized vs ReentranLock</h2>
<table>
<thead>
<tr>
<th style="text-align: center">比较</th>
<th style="text-align: center">Synchronized</th>
<th style="text-align: center">ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">等待</td>
<td style="text-align: center">结合object wait/notify</td>
<td style="text-align: center">结合condition await/signal</td>
</tr>
<tr>
<td style="text-align: center">使用难度</td>
<td style="text-align: center">简单。jvm会处理加锁，解锁的过程</td>
<td style="text-align: center">麻烦。需要手动lock、unlock，且unlock得放在finally块中</td>
</tr>
<tr>
<td style="text-align: center">特性</td>
<td style="text-align: center">可重入 不可中断 非公平</td>
<td style="text-align: center">可重入 可中断 可公平</td>
</tr>
<tr>
<td style="text-align: center">实现原理</td>
<td style="text-align: center">monitor</td>
<td style="text-align: center">AQS</td>
</tr>
</tbody>
</table>
<h1 id="2-实现原理">2. 实现原理</h1>
<h2 id="21-uml图">2.1. uml图</h2>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20191230160402.png" class="lazyload"><br>
由uml图可以看出ReentranLock底层是用AQS实现的，有一个Sync属性（继承AQS类），如果是非公平锁则用的NonfairSync实现类，否则用的FairSync类<br>
具体的实现参考</p>
<h1 id="3-公平锁">3. 公平锁</h1>
<p>所谓公平锁，遵循先到先得的原则。<br>
即使锁已经被释放了，后到的也不能去抢占锁，得等到前面没人时才能去获取</p>
<h2 id="31-如何使用">3.1. 如何使用</h2>
<pre><code class="language-java">public class TestReentrantLock
{
    private static int val = 0;
    private final static Lock lock = new ReentrantLock(true);//公平锁

    public static void main(String[] args) throws InterruptedException
    {
        Thread thread1 = new Thread(() -&gt; {

            for (int i = 0; i &lt; 100000; i++)
            {
                try
                {
                    lock.lock();
                    val++;
                }
                finally
                {
                    lock.unlock();
                }

            }
        });

        Thread thread2 = new Thread(() -&gt; {

            for (int i = 0; i &lt; 100000; i++)
            {
                try
                {
                    lock.lock();
                    val--;
                }
                finally
                {
                    lock.unlock();
                }
            }
        });


        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(val);
    }
}
</code></pre>
<h2 id="32-原理分析">3.2. 原理分析</h2>
<h3 id="321-构造方法">3.2.1. 构造方法</h3>
<h4 id="3211-底层使用aqs实现">3.2.1.1. 底层使用AQS实现</h4>
<pre><code class="language-java">public class ReentrantLock implements Lock, java.io.Serializable {

    private final Sync sync;

    //默认非公平锁
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        //true的话，公平锁使用FairSync，否则是NonfairSync
        sync = fair ? new FairSync() : new NonfairSync();
    }

    //Sync是AQS的子类
    abstract static class Sync extends AbstractQueuedSynchronizer {}
    //FairSync是Sync的子类
    static final class FairSync extends Sync {}
}
</code></pre>
<h3 id="322-加锁">3.2.2. 加锁</h3>
<ul>
<li>lock</li>
</ul>
<pre><code class="language-java">public void lock() {
    //调用FairSync的lock
    sync.lock();
}
</code></pre>
<h4 id="3221-调用公平锁的lock方法">3.2.2.1. 调用公平锁的lock方法</h4>
<ul>
<li>FairSync.lock</li>
</ul>
<pre><code class="language-java">final void lock() {
    //调用AQS的acquire
    acquire(1);
}
</code></pre>
<h4 id="3222-调用aqs的acquire方法获取锁">3.2.2.2. 调用AQS的acquire方法获取锁</h4>
<ul>
<li>AQS.acquire</li>
</ul>
<pre><code class="language-java">public final void acquire(int arg) {
    //调用FairSync的tryAcquire获取锁
    if (!tryAcquire(arg) &amp;&amp;
    	//获取锁失败加入AQS队列。并且死循环阻塞当前线程，等待唤醒继续获取锁
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    	//恢复中断标记
        selfInterrupt();
}
</code></pre>
<p>由于FairSync重写了AQS的tryAcquire方法，因此这里会调用FairSync的tryAcquire<br>
其他的逻辑同<a href="../5.AQS/5.AQS.md" target="_blank" rel="noopener nofollow">5.AQS.md</a>，下面只是简要说一下主要逻辑</p>
<h4 id="3223-尝试获取锁只有队头才允许抢占锁--公平锁">3.2.2.3. 尝试获取锁【只有队头才允许抢占锁--公平锁】</h4>
<ul>
<li>FairSync.tryAcquire</li>
</ul>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
final Thread current = Thread.currentThread();
    int c = getState();
    //锁尚未被获取
    if (c == 0) {
    	//【公平锁】：队列中我的前面没人等待锁（队列为空或者我就是队列的队头）
        if (!hasQueuedPredecessors() &amp;&amp;
        	//CAS设置state获取锁成功
            compareAndSetState(0, acquires)) {
            //设置持有锁的线程为当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //锁已经被获取，且是当前线程，那么重入
    else if (current == getExclusiveOwnerThread()) {
    	//增加state量
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    //获取锁失败返回false
    return false;
}
</code></pre>
<h4 id="3224-尝试获取锁失败加入阻塞队列">3.2.2.4. 尝试获取锁失败加入阻塞队列</h4>
<ul>
<li>AQS.addWaiter</li>
</ul>
<pre><code class="language-java">private Node addWaiter(Node mode) {
	//用当前线程、EXCLUSIVE模式构造节点
    Node node = new Node(Thread.currentThread(), mode);
    // 队列不为空
    Node pred = tail;
    if (pred != null) {
    	//插入到队尾
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //队列为空或者插入到队尾失败
    enq(node);
    return node;
}
</code></pre>
<h5 id="32241-入队的操作">3.2.2.4.1. 入队的操作</h5>
<ul>
<li>enq</li>
</ul>
<pre><code class="language-java">private Node enq(final Node node) {
//死循环直到入队成功
for (;;) {
    Node t = tail;
	//队列为空，那么初始化头节点。注意是new Node而不是当前node（即队头是个占位符）
    if (t == null) {
        if (compareAndSetHead(new Node()))
            tail = head;
	//队列不为空，插入到队尾
    } else {
        node.prev = t;
        if (compareAndSetTail(t, node)) {
            t.next = node;
            return t;
        }
    }
}
}
</code></pre>
<h4 id="3225-阻塞等待唤醒继续获取锁">3.2.2.5. 阻塞，等待唤醒继续获取锁</h4>
<ul>
<li>acquireQueued</li>
</ul>
<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
    	//死循环直到获取锁成功
        for (;;) {
        	//逻辑1.
    		//当前节点的前一个节点时头节点的时候（公平锁：即我的前面没有人等待获取锁），尝试获取锁
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
            	//获取锁成功后设置头节点为当前节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
        	//逻辑2.
            //当前节点的前一个节点状态时SIGNAL（承诺唤醒当前节点）的时候，阻塞当前线程。
            //什么时候唤醒？释放锁的时候
            //唤醒之后干什么？继续死循环执行上面的逻辑1
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
    	//何时执行这段逻辑？发生异常导致获取锁失败的时候
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<h5 id="32251-判断是否需要阻塞">3.2.2.5.1. 判断是否需要阻塞</h5>
<ul>
<li>shouldParkAfterFailedAcquire</li>
</ul>
<pre><code class="language-java">//根据（前一个节点，当前节点）-&gt;是否阻塞当前线程
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    //前一个节点的状态时SIGNAL，即释放锁后承诺唤醒当前节点，那么返回true可以阻塞当前线程
    if (ws == Node.SIGNAL)
        return true;
    //前一个节点状态&gt;0，即CANCEL。
    //那么往前遍历找到没有取消的前置节点。同时从链表中移除CANCEL状态的节点
    if (ws &gt; 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    // 前置节点状态&gt;=0，即0或者propagate。
    //这里通过CAS把前置节点状态改成signal成功获取锁，失败的话再阻塞。why？
    } else {
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<h6 id="322511-阻塞当前线程">3.2.2.5.1.1. 阻塞当前线程</h6>
<ul>
<li>parkAndCheckInterrupt</li>
</ul>
<pre><code class="language-java">private final boolean parkAndCheckInterrupt() {
    //使用Unsafe阻塞当前线程，这里会清除线程中断的标记，因此需要返回中断的标记
    LockSupport.park(this);
    return Thread.interrupted();
}
</code></pre>
<h3 id="323-解锁">3.2.3. 解锁</h3>
<pre><code class="language-java">public void unlock() {
    //调用AQS的release方法
    sync.release(1);
}
</code></pre>
<h4 id="3231-使用aqs释放锁">3.2.3.1. 使用AQS释放锁</h4>
<ul>
<li>release</li>
</ul>
<pre><code class="language-java">public final boolean release(int arg) {
    //Sync重写了调用Sync释放锁成功
    if (tryRelease(arg)) {
        Node h = head;
    	//队头不为空且状态正常，那么唤醒头节点
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
<p>Sync重写了tryRelease方法，因此这里调用的是Sync.tryRelease<br>
其他的逻辑同<a href="../5.AQS/5.AQS.md" target="_blank" rel="noopener nofollow">5.AQS.md</a>，下面只是简要说一下主要逻辑</p>
<h4 id="3232-尝试释放锁">3.2.3.2. 尝试释放锁</h4>
<ul>
<li>Sync.tryRelease</li>
</ul>
<pre><code class="language-java">protected final boolean tryRelease(int releases) {
    //解锁
    int c = getState() - releases;
    //加锁解锁必须同一个线程
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        //锁全部释放成功后，置占用锁的线程为空
        free = true;
        setExclusiveOwnerThread(null);
    }
    //CAS设置解锁
    setState(c);
    return free;
}
</code></pre>
<h4 id="3233-释放锁成功后唤醒阻塞队列中的节点">3.2.3.3. 释放锁成功后唤醒阻塞队列中的节点</h4>
<ul>
<li>AQS.unparkSuccessor</li>
</ul>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    //当前节点的状态&lt;0,则把状态改为0
    //0是空的状态，因为node这个节点的线程释放了锁后续不需要做任何
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);


     //当前节点的下一个节点为空或者状态&gt;0（即是取消状态）
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        //那么从队尾开始往前遍历找到离当前节点最近的下一个状态&lt;=0的节点（即非取消状态）
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
	//唤醒下一个节点（公平锁）
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre>
<h1 id="4-非公平锁">4. 非公平锁</h1>
<p>所谓非公平锁，就是只要锁已经被释放了，那么不管是先到的还是后到的，都可以去抢占锁</p>
<h2 id="41-如何使用">4.1. 如何使用</h2>
<pre><code class="language-java">public class TestReentrantLock
{
    private static int val = 0;
    private final static Lock lock = new ReentrantLock();//非公平锁

    public static void main(String[] args) throws InterruptedException
    {
        Thread thread1 = new Thread(() -&gt; {

            for (int i = 0; i &lt; 100000; i++)
            {
                try
                {
                    lock.lock();
                    val++;
                }
                finally
                {
                    lock.unlock();
                }

            }
        });

        Thread thread2 = new Thread(() -&gt; {

            for (int i = 0; i &lt; 100000; i++)
            {
                try
                {
                    lock.lock();
                    val--;
                }
                finally
                {
                    lock.unlock();
                }
            }
        });


        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(val);
    }
}
</code></pre>
<h2 id="42-实现原理">4.2. 实现原理</h2>
<h3 id="421-构造方法">4.2.1. 构造方法</h3>
<pre><code class="language-java">public class ReentrantLock implements Lock, java.io.Serializable {
 
    private final Sync sync;
 
    //默认非公平锁
    public ReentrantLock() {
        sync = new NonfairSync();
    }
 
    public ReentrantLock(boolean fair) {
        //true的话，公平锁使用FairSync，否则是NonfairSync
        sync = fair ? new FairSync() : new NonfairSync();
    }
 
    //Sync是AQS的子类
    abstract static class Sync extends AbstractQueuedSynchronizer {}
    //FairSync是Sync的子类
    static final class FairSync extends Sync {}
}
</code></pre>
<h3 id="422-加锁">4.2.2. 加锁</h3>
<pre><code class="language-java">public void lock() {
	//简单得调用Sync属性的lock方法。即NonfairSync的lock方法
    sync.lock();
}
</code></pre>
<h4 id="4221-使用非公平锁加锁">4.2.2.1. 使用非公平锁加锁</h4>
<ul>
<li>NonfairSync lock方法</li>
</ul>
<pre><code class="language-java">final void lock() {
	//获取锁。使用CAS设置state的值为1,这里state代表互斥量
    if (compareAndSetState(0, 1))
    	//设置当前线程为拥有互斥量的线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
    	//获取失败则调用AQS的acquire方法
        acquire(1);
}
</code></pre>
<h4 id="4222-通过aqs加锁">4.2.2.2. 通过AQS加锁</h4>
<ul>
<li>AQS.acquire方法</li>
</ul>
<pre><code class="language-java">public final void acquire(int arg) {
	//调用NonFairSync的tryAcquire获取锁
    if (!tryAcquire(arg) &amp;&amp;
    	//获取锁失败加入AQS队列。并且死循环阻塞当前线程，等待唤醒继续获取锁
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    	//恢复中断标记
        selfInterrupt();
}
</code></pre>
<p>由于NonfairSync重写了AQS的tryAcquire方法，因此这里会调用NonfairSync的tryAcquire<br>
其他的逻辑同<a href="../5.AQS/5.AQS.md" target="_blank" rel="noopener nofollow">5.AQS.md</a>，下面只是简要说一下主要逻辑</p>
<h4 id="4223-通过非公平锁尝试加锁">4.2.2.3. 通过非公平锁尝试加锁</h4>
<ul>
<li>NonfairSync.tryAcquire</li>
</ul>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
    //调用NonfairSync.nonfairTryAcquire
    return nonfairTryAcquire(acquires);
}
</code></pre>
<h5 id="42231-非公平锁尝试加锁的操作不管是否队头都可以抢占锁--非公平锁">4.2.2.3.1. 非公平锁尝试加锁的操作【不管是否队头都可以抢占锁--非公平锁】</h5>
<ul>
<li>NonfairSync.nonfairTryAcquire</li>
</ul>
<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    //锁尚未被获取
    if (c == 0) {
    	//不管前面是否有人等待，直接尝试获取锁（非公平锁）
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //锁已被获取且时当前线程，重入
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<h4 id="4224-尝试加锁失败加入阻塞队列">4.2.2.4. 尝试加锁失败，加入阻塞队列</h4>
<ul>
<li>AQS.addWaiter</li>
</ul>
<pre><code class="language-java"> private Node addWaiter(Node mode) {
 	//用当前线程、EXCLUSIVE模式构造节点
    Node node = new Node(Thread.currentThread(), mode);
    // 队列不为空
    Node pred = tail;
    if (pred != null) {
    	//插入到队尾
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //队列为空或者插入到队尾失败
    enq(node);
    return node;
}
</code></pre>
<h5 id="42241-加入队列的操作">4.2.2.4.1. 加入队列的操作</h5>
<ul>
<li>AQS.enq</li>
</ul>
<pre><code class="language-java">private Node enq(final Node node) {
	//死循环直到入队成功
    for (;;) {
        Node t = tail;
    	//队列为空，那么初始化头节点。注意是new Node而不是当前node（即队头是个占位符）
        if (t == null) {
            if (compareAndSetHead(new Node()))
                tail = head;
		//队列不为空，插入到队尾
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<ul>
<li>acquireQueued</li>
</ul>
<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
    	//死循环直到获取锁成功
        for (;;) {
        	//逻辑1.
    		//当前节点的前一个节点时头节点的时候（公平锁：即我的前面没有人等待获取锁），尝试获取锁
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
            	//获取锁成功后设置头节点为当前节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
        	//逻辑2.
            //当前节点的前一个节点状态时SIGNAL（承诺唤醒当前节点）的时候，阻塞当前线程。
            //什么时候唤醒？释放锁的时候
            //唤醒之后干什么？继续死循环执行上面的逻辑1
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    //如果发生了异常，那么执行下面的逻辑
    } finally {
    	//除了获取锁成功的情况都会执行cancelAcquire方法
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<ul>
<li>shouldParkAfterFailedAcquire</li>
</ul>
<pre><code class="language-java">//根据（前一个节点，当前节点）-&gt;是否阻塞当前线程
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
	//前一个节点的状态时SIGNAL，即释放锁后承诺唤醒当前节点，那么返回true可以阻塞当前线程
    if (ws == Node.SIGNAL)
        return true;
    //前一个节点状态&gt;0，即CANCEL。
    //那么往前遍历找到没有取消的前置节点。同时从链表中移除CANCEL状态的节点
    if (ws &gt; 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
	// 前置节点状态&gt;=0，即0或者propagate。
	//这里通过CAS把前置节点状态改成signal成功获取锁，失败的话再阻塞。why？
    } else {
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<ul>
<li>parkAndCheckInterrupt</li>
</ul>
<pre><code class="language-java">private final boolean parkAndCheckInterrupt() {
	//使用Unsafe阻塞当前线程，这里会清除线程中断的标记，因此需要返回中断的标记
    LockSupport.park(this);
    return Thread.interrupted();
}
</code></pre>
<h3 id="423-解锁">4.2.3. 解锁</h3>
<pre><code class="language-java">public void unlock() {
		//简单得调用AQS的release方法
        sync.release(1);
    }
</code></pre>
<h4 id="4231-使用aqs释放锁">4.2.3.1. 使用AQS释放锁</h4>
<ul>
<li>release</li>
</ul>
<pre><code class="language-java">public final boolean release(int arg) {
	//调用Sync释放锁成功
    if (tryRelease(arg)) {
        Node h = head;
		//队头不为空且状态正常，那么唤醒头节点
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
<h4 id="4232-尝试释放锁">4.2.3.2. 尝试释放锁</h4>
<ul>
<li>Sync.tryRelease</li>
</ul>
<pre><code class="language-java"> protected final boolean tryRelease(int releases) {
	//解锁
    int c = getState() - releases;
	//加锁解锁必须同一个线程
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    //CAS设置解锁
    setState(c);
    return free;
}
</code></pre>
<h5 id="42321-释放锁成功后唤醒阻塞队列中的后续节点">4.2.3.2.1. 释放锁成功后唤醒阻塞队列中的后续节点</h5>
<ul>
<li>unparkSuccessor</li>
</ul>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        //当前节点的状态&lt;0,则把状态改为0
        //0是空的状态，因为node这个节点的线程释放了锁后续不需要做任何
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

  
         //当前节点的下一个节点为空或者状态&gt;0（即是取消状态）
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            //那么从队尾开始往前遍历找到离当前节点最近的下一个状态&lt;=0的节点（即非取消状态）
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
    	//唤醒下一个节点（非公平锁也这样？）
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>
<h1 id="5-参考">5. 参考</h1>
<ul>
<li><a href="https://blog.csdn.net/weixin_40081388/article/details/89417623" target="_blank" rel="noopener nofollow">结合AQS看锁的获取和释放_weixin_40081388的博客-CSDN博客</a></li>
<li><a href="http://ifeve.com/juc-aqs-reentrantlock/" target="_blank" rel="noopener nofollow">JUC的AQS学习-ReentrantLock源代码分析 | 并发编程网 – ifeve.com</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-24 11:03">2025-06-24 11:02</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">71</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18945899);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18945899', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18945899', title: 'Java源码分析系列笔记-6.ReentrantLock' })">举报</a>
</div>
        