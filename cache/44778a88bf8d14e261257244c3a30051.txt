
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/somefuture/p/18988670" title="发布于 2025-07-17 00:22">
    <span role="heading" aria-level="2">面向 Git 用户的 jujutsu 使用入门</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Jujutsu 是一个与 Git 兼容的分布式版本控制系统，旨在成为更简单、性能更高、更易于使用的 Git 替代品。
删除了暂存区（index），工作树由实际提交直接表示，用户可直接编辑磁盘文件来修改提交，无需暂存或取消暂存操作，也无需 “git add” 或 “git stash” 等命令。
集成了基于 patch 的版本控制系统中的想法，采用冲突树的表述形式处理合并冲突，允许用户提交冲突并在之后解决，确保合并和 rebase 始终 “成功”。
其性能表现出色，完成 rebase 操作的速度比 Git 快得多。部分原因是采用了合理默认值，以及尽可能避免像 “git rebase” 那样遍历 commit graph。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在软件开发领域，版本控制是协作的基石。<br>
Git作为当前主流工具，虽功能强大但设计理念可追溯至2005年，其复杂的命令集和冲突处理机制常令开发者困扰。近年来，新兴工具——比如Jujutsu（jj）和Pijul—— 越来越以其创新设计理念受到关注。</p>
<blockquote>
<p>Jujutsu和Pijul代表了版本控制工具的两个革新方向：前者通过兼容性和简化操作降低使用门槛，后者通过数学化模型解决根本痛点。对于Git资深用户，Jujutsu是“即插即用”的效率工具，而Pijul更适合作为长期技术探索。<br>
两者目前均无法完全替代Git，但在特定场景下已展现出显著优势，值得根据团队需求选择性尝试。</p>
</blockquote>
<p>jj 是2019 年作为个人爱好项目创建，用 Rust 编写，目前由 Google 资助开发，旨在成为更简单、性能更高、更易于使用的 Git 替代品。</p>
<h1 id="核心创新">核心创新</h1>
<h2 id="1-工作副本即提交working-copy-as-a-commit">1. 工作副本即提交（Working-copy-as-a-commit）</h2>
<p>消除Git的暂存区（index）概念，工作目录直接映射为可编辑的提交。修改文件后无需git add，通过jj new即可创建新提交，简化日常操作。</p>
<h2 id="2-自动重基与变更追踪">2. 自动重基与变更追踪</h2>
<p>修改历史提交后，依赖该提交的后续变更会自动 rebase（如jj edit <commit>），避免Git中手动rebase的繁琐。操作日志完整记录所有变更，支持任意步骤回滚（jj undo）。</commit></p>
<h2 id="3-多后端支持">3. 多后端支持</h2>
<p>默认使用Git仓库作为存储后端，<strong>可无缝衔接现有Git项目</strong>；同时支持自研存储引擎，未来计划扩展云存储支持（如Google内部系统）。</p>
<h3 id="局限性">局限性：</h3>
<p>目前还缺乏Git高级特性如子模块、LFS、签名提交和hooks，所以企业级应用存在缺口。</p>
<hr>
<h1 id="从零到生产">从零到生产</h1>
<h2 id="安装与初始化">安装与初始化</h2>
<table>
<thead>
<tr>
<th>Git 概念</th>
<th>jj 对应</th>
<th>命令示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git</code> 软件</td>
<td><code>jj</code>软件</td>
<td>根据 <a href="https://jj-vcs.github.io/jj/latest/install-and-setup/" target="_blank" rel="noopener nofollow">https://jj-vcs.github.io/jj/latest/install-and-setup/</a> 针对不同平台安装</td>
</tr>
<tr>
<td><code>.git/</code>目录</td>
<td><code>.jj/</code>目录</td>
<td><code>jj git init --colocate</code>（与 Git 共用仓库）或 <code>jj init</code>（纯 jj）</td>
</tr>
<tr>
<td><code>git config</code></td>
<td><code>jj config</code></td>
<td><code>jj config set --user user.name "Adam"</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>纯 jj 仓库无法被原生 Git 打开，只有 colocate 模式才能与 Git 混合使用</p>
</blockquote>
<h2 id="基本命令映射表">基本命令映射表</h2>
<table>
<thead>
<tr>
<th>目的</th>
<th>Git</th>
<th>jj（等效或更优）</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看状态</td>
<td><code>git status</code></td>
<td><code>jj st</code>（或 <code>jj status</code>）</td>
</tr>
<tr>
<td>查看日志</td>
<td><code>git log --oneline --graph</code></td>
<td><code>jj log</code>（自动图形化）</td>
</tr>
<tr>
<td>提交</td>
<td><code>git commit -am "msg"</code></td>
<td><code>jj commit -m "msg"</code></td>
</tr>
<tr>
<td>暂存</td>
<td><code>git add -p</code></td>
<td>不需要：<code>jj new</code> 自动把工作区作为「新变更集」</td>
</tr>
<tr>
<td>创建分支</td>
<td><code>git checkout -b feat</code></td>
<td><code>jj new main -m "feat"</code>（产生新的变更集，可理解为「匿名分支」）</td>
</tr>
<tr>
<td>切换</td>
<td><code>git switch feat</code></td>
<td><code>jj edit &lt;id&gt;</code> 或 <code>jj new &lt;id&gt;</code></td>
</tr>
<tr>
<td>拉取</td>
<td><code>git pull --rebase</code></td>
<td><code>jj git fetch &amp;&amp; jj rebase -d 'main@origin'</code></td>
</tr>
<tr>
<td>推送</td>
<td><code>git push origin HEAD</code></td>
<td><code>jj git push -c &lt;id&gt;</code>（第一次）或 <code>jj git push --change &lt;id&gt;</code></td>
</tr>
<tr>
<td>修改最近一次提交</td>
<td><code>git commit --amend</code></td>
<td>直接在工作区继续编辑，然后 <code>jj squash</code></td>
</tr>
<tr>
<td>交互式 rebase</td>
<td><code>git rebase -i</code></td>
<td><code>jj rebase -i</code></td>
</tr>
<tr>
<td>stash</td>
<td><code>git stash</code></td>
<td>不需要：工作区永远干净，所有修改都在「草稿变更集」</td>
</tr>
</tbody>
</table>
<h3 id="核心概念">核心概念</h3>
<ul>
<li>变更集（change）= Git 中的一次 commit，但可随意改写，直到显式 push。</li>
<li>工作区永远 clean；你始终处于某个变更集上。</li>
<li>jj new 创建新的「匿名分支」；jj branch 给变更集贴标签（类似 Git branch）。</li>
<li>所有历史都可重写，且不会丢失旧版本（自动保留不可见的「废弃变更集」）。</li>
<li>远程协作通过 jj git push/fetch，底层仍是 Git 协议。</li>
</ul>
<h2 id="日常最佳实践">日常最佳实践</h2>
<pre><code class="language-bash"># 1. 基于主干创建功能
jj new main -m "wip: add login"
# 2. 开发、迭代
vim foo.rust
jj commit -m "parse jwt"
# 3. 需要改更早的提交？直接 rebase -i
jj rebase -i 'main'
# 4. 整理完，推到远端
jj git push -c @-
</code></pre>
<h3 id="高频技巧">高频技巧</h3>
<ul>
<li>快速拆分大提交：<br>
<code>jj split</code>（交互式选择文件或 hunk 拆成两个变更集）。</li>
<li>快速 squash：<br>
<code>jj squash -r &lt;child&gt; -r &lt;parent&gt;</code> 或 <code>jj squash --into &lt;parent&gt;</code>。</li>
<li>撤销任何操作：<br>
<code>jj op log</code> → 找到误操作的 op → <code>jj op restore &lt;id&gt;</code>（时间机器）。</li>
</ul>
<h2 id="常见坑与排查">常见坑与排查</h2>
<table>
<thead>
<tr>
<th>现象</th>
<th>原因</th>
<th>解决</th>
</tr>
</thead>
<tbody>
<tr>
<td>无法 push</td>
<td>远端有更新</td>
<td><code>jj git fetch &amp;&amp; jj rebase -d 'main@origin'</code></td>
</tr>
<tr>
<td>误删变更集</td>
<td>历史仍在</td>
<td><code>jj log -r 'visible_heads()'</code> 找回，或 <code>jj op restore</code></td>
</tr>
<tr>
<td>Windows 路径过长</td>
<td>jj 内部使用长哈希</td>
<td>设置 <code>core.longpaths=true</code>（Git 配置）</td>
</tr>
<tr>
<td>GUI 工具不支持</td>
<td>只认 <code>.git</code></td>
<td>使用 colocate 模式即可</td>
</tr>
</tbody>
</table>
<h2 id="资料">资料</h2>
<ul>
<li>官方书：<a href="https://github.com/martinvonz/jj/blob/main/docs/tutorial.md" target="_blank" rel="noopener nofollow">https://github.com/martinvonz/jj/blob/main/docs/tutorial.md</a></li>
<li>实时更新教程：<a href="https://steveklabnik.github.io/jujutsu-tutorial/introduction/introduction.html" target="_blank" rel="noopener nofollow">https://steveklabnik.github.io/jujutsu-tutorial/introduction/introduction.html</a></li>
<li>命令补全：在 zsh/bash 里 source &lt;(jj util completion zsh)</li>
</ul>
<h1 id="速查清单贴墙用">速查清单（贴墙用）</h1>
<pre><code class="language-bash"># 新功能
jj new main -m "xxx"
# 迭代
jj commit -m "..."
# 整理
jj rebase -i 'main'
# 推送
jj git push -c @-
# 回滚
jj op restore &lt;prev&gt;
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07222222222222222" data-date-updated="2025-07-17 02:06">2025-07-17 00:22</span>&nbsp;
<a href="https://www.cnblogs.com/somefuture">大卫小东（Sheldon）</a>&nbsp;
阅读(<span id="post_view_count">97</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18988670);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18988670', targetLink: 'https://www.cnblogs.com/somefuture/p/18988670', title: '面向 Git 用户的 jujutsu 使用入门' })">举报</a>
</div>
        