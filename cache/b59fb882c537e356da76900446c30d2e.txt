
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/syzyc/p/18987457" title="发布于 2025-07-16 14:20">
    <span role="heading" aria-level="2">CSP-S 模拟赛 20 题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="t1">T1</h1>
<p><span class="math inline">\(S\)</span>本身就有的我们先剔除,只用考虑<span class="math inline">\(T\)</span>之间左右相邻的和<span class="math inline">\(S,T\)</span>之间上下相邻</p>
<p><span class="math inline">\(O(n^2)\)</span>的暴力<span class="math inline">\(dp\)</span>似乎很显,这里当然也可以<span class="math inline">\(bitset\)</span>优化一下</p>
<p>具体的就是<span class="math inline">\(dp_{i,j,0}\)</span>为第<span class="math inline">\(i\)</span>位填<span class="math inline">\(0\)</span>时有<span class="math inline">\(j\)</span>对不同的是否可行,<span class="math inline">\(dp_{i,j,1}\)</span>同理</p>
<p>我们这里可以考虑探究一下固定<span class="math inline">\(i\)</span>，<span class="math inline">\(j\)</span>之间是否有性质</p>
<p>我们设<span class="math inline">\(dp_{i,0}\)</span>为满足的<span class="math inline">\(j\)</span>构成的集合</p>
<p>结论:<span class="math inline">\(dp_{i,0}\)</span>和<span class="math inline">\(dp_{i,1}\)</span>均是一个区间但有可能中间被挖去一个值<span class="math inline">\(v\)</span></p>
<p>这个可以打表找出来吧。。</p>
<p>注意到<span class="math inline">\(dp_{i,0},dp_{i,1}\)</span>是一直重叠的</p>
<p>考虑归纳证明,边界就不管了,<span class="math inline">\(i=2\)</span>的情况可以下去自己手算一下,<span class="math inline">\(i=1\)</span>的情况可以先不管</p>
<p>对于<span class="math inline">\(i\)</span>，这里我们可以先观察一下转移,可以发现区间取并时只用关注<span class="math inline">\(0/1\)</span>的相对位置,随便一个平移一下就行了,抽象为</p>
<p><span class="math inline">\(dp_{i,0}=dp_{i-1,0}\cup(dp_{i-1,1}+1)\)</span></p>
<p><span class="math inline">\(dp_{i,1}=dp_{i-1,1}\cup(dp_{i-1,0}+1)+(\pm1)\)</span></p>
<p>这里就只先解决这种情况,其他的同理,<span class="math inline">\(0/1\)</span>整体平移一下即可</p>
<p>首先对于<span class="math inline">\(x\in dp_{i-1,0},dp_{i-1,1}\)</span></p>
<p>可以发现<span class="math inline">\(dp_{i,0}\)</span>产生的是<span class="math inline">\(\{x,x+1\}\)</span>,<span class="math inline">\(dp_{i,1}\)</span>产生的是<span class="math inline">\(\{x+1,x+2\}\)</span>或者<span class="math inline">\(\{x,x-1\}\)</span>依旧有重叠部分</p>
<p>所以<span class="math inline">\(0/1\)</span>始终有重叠</p>
<p>那这里缺的位置是只有原有区间来产生,不会因为并产生空</p>
<p>可以假定这里缺的位置不能是端点,因为是端点一定能被填上或者可以忽略</p>
<p>那么对于缺的位置还有一个更强的结论,对于一个<span class="math inline">\(0\)</span>缺的位置<span class="math inline">\(v\)</span>，<span class="math inline">\(v+1\)</span>或<span class="math inline">\(v-1\)</span>一定会出现在<span class="math inline">\(1\)</span>中</p>
<p>当然换一下也是成立的</p>
<p>这里同样归纳证明</p>
<p>如果<span class="math inline">\(v+1\)</span>出现在<span class="math inline">\((i-1,1)\)</span>中,那<span class="math inline">\((0,i)\)</span>就缺<span class="math inline">\(v\)</span>,<span class="math inline">\((1,i)\)</span>什么都不缺</p>
<p>如果<span class="math inline">\(v-1\)</span>出现在<span class="math inline">\((i-1,1)\)</span>中,那<span class="math inline">\((0,i)\)</span>什么都不缺,<span class="math inline">\((1,i)\)</span>缺<span class="math inline">\(v/v+2\)</span>,但<span class="math inline">\(v+2\)</span>还是<span class="math inline">\(v\)</span>在<span class="math inline">\((0,i)\)</span>中都有<span class="math inline">\(v+1\)</span>相邻</p>
<p>由此,如果<span class="math inline">\(i=2\)</span>只有一个缺口,每次操作后最多也只会有一个缺口</p>
<p>最后直接<span class="math inline">\(O(n)\)</span>转移即可</p>
<hr>
<h1 id="t2-nk">T2 nk</h1>
<p><span class="math inline">\(source:\)</span><a href="https://atcoder.jp/contests/arc102/tasks/arc102_d" target="_blank" rel="noopener nofollow">https://atcoder.jp/contests/arc102/tasks/arc102_d</a></p>
<h5 id="_"><span class="math inline">\(subtask1\)</span>：</h5>
<p>也许有人会写搜索?</p>
<p>期望得分:<span class="math inline">\(20 pts\)</span></p>
<h5 id="_-1"><span class="math inline">\(subtask2\)</span>：</h5>
<p>显然结果与每次操作顺序无关</p>
<p>考虑每次暴力遍历整个数组，若当前点可以操作则直接进行，直到序列有序。</p>
<p>序列有序等价于逆序对为<span class="math inline">\(0\)</span>，每次操作从<span class="math inline">\(p_i&gt;p_{i+1}&gt;p_{i+2}\)</span>变为<span class="math inline">\(p_i&lt;p_{i+1}&lt;p_{i+2}\)</span>，逆序对减少了<span class="math inline">\(3\)</span>，而初始逆序对是在<span class="math inline">\(n^2\)</span>级别的，所以总操作次数也在<span class="math inline">\(n^2\)</span>级别，再加上最坏每次寻找操作点遍历整个数组，时间复杂度上界在<span class="math inline">\(O(n^3)\)</span>左右。<s>但我不知道为什么n&lt;2000也能跑得飞快</s></p>
<p>期望得分:<span class="math inline">\(50pts\)</span></p>
<p><span class="math inline">\(subtask3\)</span>:</p>
<p>妙妙结论题。</p>
<p>首先每次操作时每个数所在下标的奇偶性不变，因此初始一个数下标和值奇偶性不同那么一定无解。</p>
<p>再考虑逆序对，首先由<span class="math inline">\(subtask2\)</span>的复杂度分析有初始序列的逆序对数一定是3的倍数才可能有解。</p>
<p>尝试将逆序对的结论进行扩展，可以发现每次操作后下标为奇数或偶数的数构成的序列逆序对数量都减少了1。也就是说，每次整个序列逆序对减少3一定伴随着下标为奇数或偶数之一的数构成的序列逆序对数量减1。</p>
<p>因此我们可以得到有解的一个必要条件：初始下标为奇数和偶数的数分别构成的两个序列的逆序对之和是原序列的<span class="math inline">\(\frac{1}{3}\)</span>。</p>
<p>显然这个条件也是充分的。</p>
<p>直接树状数组/归并排序求逆序对即可，时间复杂度<span class="math inline">\(O(n\log n)\)</span></p>
<p>期望得分:<span class="math inline">\(100pts\)</span></p>
<p><span class="math inline">\(PS\)</span>：本题似乎存在<span class="math inline">\(O(n)\)</span>做法，但是搬题人太蔡了不会。</p>
<hr>
<h1 id="t3-ds">T3 ds</h1>
<p>某两位同学看到过这道题，其中某位同学写了这道题，愿他们都能场切这道题</p>
<p><span class="math inline">\(source\)</span>：</p>
<p><a href="https://www.luogu.com.cn/problem/P3863" target="_blank" rel="noopener nofollow">https://www.luogu.com.cn/problem/P3863</a></p>
<p><a href="https://www.luogu.com.cn/problem/P5356" target="_blank" rel="noopener nofollow">https://www.luogu.com.cn/problem/P5356</a></p>
<p><span class="math inline">\(subtask1\)</span>:</p>
<p>暴力模拟即可，时间复杂度<span class="math inline">\(O(mn\log n)\)</span> 或<span class="math inline">\(O(mn)\)</span>，空间复杂度<span class="math inline">\(O(mn)\)</span></p>
<p>期望得分:<span class="math inline">\(20pts\)</span></p>
<p><span class="math inline">\(subtask2\)</span>:</p>
<p>暴力时间复杂度还是可以通过，但是会被卡空间，考虑优化暴力记录数组的每个历史版本这一过程。</p>
<p>离线可以维护一个位置在<span class="math inline">\([0,m]\)</span>时间内的信息。</p>
<p>具体来说，我们可以将询问和修改离线下来，把修改差分，拆成两个后缀的修改，分别为<span class="math inline">\((l,x,t)\)</span>,<span class="math inline">\((r+1,-x,t)\)</span>,其中<span class="math inline">\((pos,val,tim)\)</span>表示在时间为<span class="math inline">\(t\)</span>时将<span class="math inline">\([pos,n]\)</span>全部加上<span class="math inline">\(val\)</span>。</p>
<p>将询问和修改按照第一维位置升序，第二维时间升序排序。</p>
<p>维护一个修改位置的指针，依次升序扫过每个询问，对于当前指针指向的修改如果位置更靠前，或位置一样但修改时间靠前，则更新修改<span class="math inline">\((t,m)\)</span>这一段并向右挪动指针。然后就可以对当前询问计算答案。</p>
<p>考虑算法正确性，发现因为修改影响的是一段后缀的时间和位置，那么排在这个询问后的修改一定对当前的答案没有影响。本质是扫描线。</p>
<p>说得有点抽象，放核心代码。</p>
<pre><code class="language-c++">void solve(){
    sort(c+1,c+1+ccnt);sort(q+1,q+1+qcnt);
    int now=1;
    for (int i=1;i&lt;=qcnt;i++){
        while(((c[now].pos&lt;q[i].pos)||(c[now].pos==q[i].pos&amp;&amp;c[now].tim&lt;q[i].tim))&amp;&amp;now&lt;=ccnt){
            update(c[now].tim,m,c[now].x);
            ++now;
        }
        ans[q[i].id]=kth(q[i].l,q[i].r,q[i].x);
    }
}
</code></pre>
<p>如果暴力维护区间加，区间第<span class="math inline">\(k\)</span>小，时间复杂度不变，空间复杂度变为<span class="math inline">\(O(n)\)</span></p>
<p>期望得分:<span class="math inline">\(40pts\)</span></p>
<p><span class="math inline">\(subtask3\)</span>:</p>
<p><s>你都会sub2了还不会sub3？</s></p>
<p>教主的魔法都做过吧?</p>
<p>区间加，区间大于等于一个给定数的数的个数</p>
<p>分块维护块内排序后序列，询问时散块暴力，整块二分</p>
<p>那么区间第<span class="math inline">\(k\)</span>小可以由教主的魔法的询问再套上一个二分得到</p>
<p>时间复杂度<span class="math inline">\(O(m\sqrt{m\log m } \log m)\)</span></p>
<p>期望得分:<span class="math inline">\(100pts\)</span></p>
<hr>
<h1 id="t4">T4</h1>
<p>分析一下问题,可以发现瓶颈在于限制牛仔序列</p>
<p>前<span class="math inline">\(20pts\)</span>似乎直接状压+子序列DP即可</p>
<p><span class="math inline">\(sub3\)</span>是个很好的启发,由于<span class="math inline">\(A\)</span>就是牛仔序列,我们只需要统计每个<span class="math inline">\(A\)</span>的贡献</p>
<p>直接枚举<span class="math inline">\(A\)</span>的位置算方案数,答案是<span class="math inline">\((n-m+1)k^{n-m}\)</span></p>
<p><span class="math inline">\(sub4\)</span>我们先剔除<span class="math inline">\(m=n\)</span>的情况</p>
<p>剩下的,考虑容斥,先计算所有<span class="math inline">\(A\)</span>可能的贡献<span class="math inline">\((n-m+1)k^{n-m}\)</span>,最后减去没有牛仔序列的序列中<span class="math inline">\(A\)</span>的贡献</p>
<p>注意到没有牛仔序列等价于不存在连续的长度为<span class="math inline">\(K\)</span>元素不同的段</p>
<p>同样考虑子序列<span class="math inline">\(dp\)</span></p>
<p>设<span class="math inline">\(dp_{i,j}\)</span>表示填前<span class="math inline">\(i\)</span>个数后末尾有长度为<span class="math inline">\(j\)</span>连续的元素不同的段的方案数</p>
<p>转移的话考虑</p>
<p><span class="math inline">\(j\rightarrow j+1\)</span>,即填上前面<span class="math inline">\(j\)</span>个没出现的数,转移系数为<span class="math inline">\(k-j\)</span></p>
<p><span class="math inline">\(j\rightarrow p,(p\le j)\)</span>,即填上前面出现的数,根据与末尾的位置决定<span class="math inline">\(p\)</span></p>
<p>这里直接后缀和优化即可,这里我们只需限制<span class="math inline">\(j&lt;k\)</span>即可保证无牛仔序列</p>
<p>注意这里计算的是牛度，我们可以发现每个元素均是等价的，所以我们可以计算所有长度为<span class="math inline">\(m\)</span>元素不同的段的贡献最后除<span class="math inline">\(\dfrac{fac_k}{fac_{k-m}}\)</span>,对于这个的计算,可以记录一个辅助数组表示牛度,转移是一样的,就是最后<span class="math inline">\(j\ge m\)</span>时要算上自己的贡献</p>
<p>其实这里离正解就不远了,可以发现就只剩一种情况:<span class="math inline">\(A\)</span>中有相同元素</p>
<p>如果<span class="math inline">\(A\)</span>有相同元素,一个合法的牛仔序列一定不会横跨<span class="math inline">\(A\)</span>,因此我们可以考虑直接枚举<span class="math inline">\(A\)</span>的匹配位置算方案数</p>
<p>可以发现这个可以借助上面的<span class="math inline">\(dp\)</span>的定义和转移,唯一的区别在于初值不同</p>
<p>时间复杂度<span class="math inline">\(O(nk)\)</span></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 14:20">2025-07-16 14:20</span>&nbsp;
<a href="https://www.cnblogs.com/syzyc">syzyc</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18987457);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18987457', targetLink: 'https://www.cnblogs.com/syzyc/p/18987457', title: 'CSP-S 模拟赛 20 题解' })">举报</a>
</div>
        