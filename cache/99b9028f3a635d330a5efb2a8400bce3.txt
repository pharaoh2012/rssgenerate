
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18743696" title="发布于 2025-02-28 17:20">
    <span role="heading" aria-level="2">JUC相关知识点总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Java JUC（<code>java.util.concurrent</code>）是Java并发编程的核心工具包，提供了丰富的并发工具类和框架。以下是JUC的主要知识点，按难易程度分类，供你参考：</p>
<hr>
<h3 id="1-基础概念与工具类"><strong>1. 基础概念与工具类</strong></h3>
<h4 id="11-并发与并行易"><strong>1.1 并发与并行（易）</strong></h4>
<ul>
<li><strong>内容</strong>：理解并发（Concurrency）和并行（Parallelism）的区别。</li>
<li><strong>重要性</strong>：基础概念，理解并发编程的前提。</li>
</ul>
<h4 id="12-线程与线程池中"><strong>1.2 线程与线程池（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>线程的创建与启动（<code>Thread</code>、<code>Runnable</code>）。</li>
<li>线程池（<code>ExecutorService</code>、<code>ThreadPoolExecutor</code>）。</li>
<li>线程池参数（核心线程数、最大线程数、队列类型、拒绝策略）。</li>
</ul>
</li>
<li><strong>重要性</strong>：线程池是并发编程的核心工具，必须掌握。</li>
</ul>
<h4 id="13-线程生命周期与状态易"><strong>1.3 线程生命周期与状态（易）</strong></h4>
<ul>
<li><strong>内容</strong>：线程的6种状态（<code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>TERMINATED</code>）。</li>
<li><strong>重要性</strong>：理解线程状态是调试并发问题的基础。</li>
</ul>
<hr>
<h3 id="2-同步与锁"><strong>2. 同步与锁</strong></h3>
<h4 id="21-synchronized关键字易"><strong>2.1 <code>synchronized</code>关键字（易）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>方法同步与代码块同步。</li>
<li>锁的粒度与性能优化。</li>
</ul>
</li>
<li><strong>重要性</strong>：最基础的同步机制。</li>
</ul>
<h4 id="22-reentrantlock中"><strong>2.2 <code>ReentrantLock</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>可重入锁的基本使用。</li>
<li>公平锁与非公平锁。</li>
<li><code>tryLock</code>、<code>lockInterruptibly</code>等高级特性。</li>
</ul>
</li>
<li><strong>重要性</strong>：比<code>synchronized</code>更灵活的锁机制。</li>
</ul>
<h4 id="23-readwritelock中"><strong>2.3 <code>ReadWriteLock</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>读写锁（<code>ReentrantReadWriteLock</code>）。</li>
<li>读锁与写锁的分离。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于读多写少的场景。</li>
</ul>
<h4 id="24-stampedlock难"><strong>2.4 <code>StampedLock</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>乐观读锁与悲观读锁。</li>
<li>锁的升级与降级。</li>
</ul>
</li>
<li><strong>重要性</strong>：高性能锁，适用于特定场景。</li>
</ul>
<hr>
<h3 id="3-原子操作类"><strong>3. 原子操作类</strong></h3>
<h4 id="31-atomicintegeratomiclong等易"><strong>3.1 <code>AtomicInteger</code>、<code>AtomicLong</code>等（易）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>原子操作的基本使用。</li>
<li><code>compareAndSet</code>（CAS）原理。</li>
</ul>
</li>
<li><strong>重要性</strong>：无锁编程的基础。</li>
</ul>
<h4 id="32-atomicreferenceatomicstampedreference中"><strong>3.2 <code>AtomicReference</code>、<code>AtomicStampedReference</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>引用类型的原子操作。</li>
<li>解决ABA问题。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于复杂对象的原子操作。</li>
</ul>
<h4 id="33-longadderdoubleadder中"><strong>3.3 <code>LongAdder</code>、<code>DoubleAdder</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>高并发场景下的累加器。</li>
<li>分段锁机制。</li>
</ul>
</li>
<li><strong>重要性</strong>：比<code>AtomicLong</code>性能更高。</li>
</ul>
<hr>
<h3 id="4-并发集合"><strong>4. 并发集合</strong></h3>
<h4 id="41-concurrenthashmap中"><strong>4.1 <code>ConcurrentHashMap</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>分段锁与CAS机制。</li>
<li>高并发下的性能优化。</li>
</ul>
</li>
<li><strong>重要性</strong>：最常用的并发集合。</li>
</ul>
<h4 id="42-copyonwritearraylistcopyonwritearrayset易"><strong>4.2 <code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>（易）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>写时复制机制。</li>
<li>适用场景与性能特点。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于读多写少的场景。</li>
</ul>
<h4 id="43-blockingqueue及其实现类中"><strong>4.3 <code>BlockingQueue</code>及其实现类（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li><code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>。</li>
<li><code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>。</li>
<li><code>put</code>、<code>take</code>等阻塞操作。</li>
</ul>
</li>
<li><strong>重要性</strong>：生产者-消费者模型的实现基础。</li>
</ul>
<h4 id="44-concurrentlinkedqueueconcurrentskiplistmap难"><strong>4.4 <code>ConcurrentLinkedQueue</code>、<code>ConcurrentSkipListMap</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>无锁队列与跳表。</li>
<li>高并发场景下的性能优势。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于高性能无锁场景。</li>
</ul>
<hr>
<h3 id="5-同步工具类"><strong>5. 同步工具类</strong></h3>
<h4 id="51-countdownlatch易"><strong>5.1 <code>CountDownLatch</code>（易）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>等待多个线程完成任务。</li>
</ul>
</li>
<li><strong>重要性</strong>：多线程协作的基础工具。</li>
</ul>
<h4 id="52-cyclicbarrier中"><strong>5.2 <code>CyclicBarrier</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>多线程到达屏障后继续执行。</li>
<li>与<code>CountDownLatch</code>的区别。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于分阶段任务。</li>
</ul>
<h4 id="53-semaphore中"><strong>5.3 <code>Semaphore</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>控制并发线程数。</li>
<li>信号量的基本使用。</li>
</ul>
</li>
<li><strong>重要性</strong>：资源池管理的核心工具。</li>
</ul>
<h4 id="54-phaser难"><strong>5.4 <code>Phaser</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>多阶段任务同步。</li>
<li>动态调整参与线程数。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于复杂任务调度。</li>
</ul>
<h4 id="55-exchanger难"><strong>5.5 <code>Exchanger</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>线程间数据交换。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于特定场景。</li>
</ul>
<hr>
<h3 id="6-异步编程"><strong>6. 异步编程</strong></h3>
<h4 id="61-future与futuretask中"><strong>6.1 <code>Future</code>与<code>FutureTask</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>异步任务的结果获取。</li>
<li><code>get</code>方法的阻塞特性。</li>
</ul>
</li>
<li><strong>重要性</strong>：异步编程的基础。</li>
</ul>
<h4 id="62-completablefuture难"><strong>6.2 <code>CompletableFuture</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>链式调用与组合操作。</li>
<li><code>thenApply</code>、<code>thenAccept</code>、<code>thenCombine</code>等方法。</li>
</ul>
</li>
<li><strong>重要性</strong>：现代异步编程的核心工具。</li>
</ul>
<hr>
<h3 id="7-线程调度与定时任务"><strong>7. 线程调度与定时任务</strong></h3>
<h4 id="71-scheduledexecutorservice中"><strong>7.1 <code>ScheduledExecutorService</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>定时任务与周期性任务。</li>
</ul>
</li>
<li><strong>重要性</strong>：替代<code>Timer</code>的推荐工具。</li>
</ul>
<h4 id="72-forkjoinpool难"><strong>7.2 <code>ForkJoinPool</code>（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>分治算法与工作窃取。</li>
<li><code>RecursiveTask</code>与<code>RecursiveAction</code>。</li>
</ul>
</li>
<li><strong>重要性</strong>：适用于计算密集型任务。</li>
</ul>
<hr>
<h3 id="8-其他高级特性"><strong>8. 其他高级特性</strong></h3>
<h4 id="81-threadlocal中"><strong>8.1 <code>ThreadLocal</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>线程本地变量。</li>
<li>内存泄漏问题。</li>
</ul>
</li>
<li><strong>重要性</strong>：线程间数据隔离的工具。</li>
</ul>
<h4 id="82-aqsabstractqueuedsynchronizer难"><strong>8.2 <code>AQS</code>（AbstractQueuedSynchronizer）（难）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>同步器的底层实现。</li>
<li>自定义锁与同步工具。</li>
</ul>
</li>
<li><strong>重要性</strong>：理解JUC底层机制的关键。</li>
</ul>
<h4 id="83-内存模型与volatile中"><strong>8.3 内存模型与<code>volatile</code>（中）</strong></h4>
<ul>
<li><strong>内容</strong>：
<ul>
<li>可见性、有序性、原子性。</li>
<li><code>happens-before</code>原则。</li>
</ul>
</li>
<li><strong>重要性</strong>：理解并发编程的基础。</li>
</ul>
<hr>
<h3 id="学习建议"><strong>学习建议</strong></h3>
<ol>
<li><strong>从易到难</strong>：先掌握基础概念和工具类，再深入学习高级特性。</li>
<li><strong>动手实践</strong>：通过编写代码加深理解，尤其是并发集合和同步工具类。</li>
<li><strong>阅读源码</strong>：特别是<code>AQS</code>、<code>ConcurrentHashMap</code>等核心类的源码。</li>
<li><strong>调试与测试</strong>：使用工具（如JConsole、VisualVM）分析并发问题。</li>
</ol>
<hr>
<p>通过系统学习以上知识点，你将全面掌握Java JUC的核心内容，并能够应对实际开发中的并发编程挑战。</p>
<h1 id="详细演示上面功能">详细演示上面功能</h1>
<hr>
<h3 id="java-juc-知识点完整汇总"><strong>Java JUC 知识点完整汇总</strong></h3>
<hr>
<h3 id="1-基础概念与工具类-1"><strong>1. 基础概念与工具类</strong></h3>
<h4 id="11-并发与并行"><strong>1.1 并发与并行</strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>并发</strong>：多个任务交替执行，适用于单核 CPU 或多线程任务。</li>
<li><strong>并行</strong>：多个任务同时执行，需要多核 CPU 支持。</li>
<li><strong>适用范围</strong>：理解并发与并行的区别是并发编程的基础。</li>
<li><strong>注意点</strong>：并行需要硬件支持（多核 CPU）。</li>
<li><strong>实现原理</strong>：并发通过线程切换实现，并行通过多核 CPU 实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">public class ConcurrencyVsParallelism {
    public static void main(String[] args) {
        // 并发：多个任务交替执行
        Runnable task = () -&gt; System.out.println(Thread.currentThread().getName() + " is running");
        new Thread(task).start(); // 启动线程1
        new Thread(task).start(); // 启动线程2

        // 并行：多个任务同时执行（需要多核CPU支持）
        ExecutorService executor = Executors.newFixedThreadPool(2); // 创建固定大小的线程池
        executor.submit(task); // 提交任务1
        executor.submit(task); // 提交任务2
        executor.shutdown(); // 关闭线程池
    }
}
</code></pre>
<hr>
<h4 id="12-线程与线程池"><strong>1.2 线程与线程池</strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>线程</strong>：Java 中最基本的并发单元。</li>
<li><strong>线程池</strong>：管理线程的生命周期，避免频繁创建和销毁线程。</li>
<li><strong>适用范围</strong>：需要频繁创建线程的场景。</li>
<li><strong>注意点</strong>：线程池参数（核心线程数、最大线程数、队列类型、拒绝策略）需要合理配置。</li>
<li><strong>实现原理</strong>：线程池通过任务队列和工作线程实现任务调度。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); // 创建固定大小的线程池
        executor.submit(() -&gt; System.out.println("Task 1")); // 提交任务1
        executor.submit(() -&gt; System.out.println("Task 2")); // 提交任务2
        executor.shutdown(); // 关闭线程池
    }
}
</code></pre>
<hr>
<h4 id="13-线程生命周期与状态"><strong>1.3 线程生命周期与状态</strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>线程状态</strong>：<code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>TERMINATED</code>。</li>
<li><strong>适用范围</strong>：调试和分析线程行为。</li>
<li><strong>注意点</strong>：线程状态是 JVM 管理的，开发者无法直接控制。</li>
<li><strong>实现原理</strong>：JVM 通过内部状态机管理线程状态。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">public class ThreadStateExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&gt; {
            try {
                Thread.sleep(1000); // TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(thread.getState()); // NEW
        thread.start();
        System.out.println(thread.getState()); // RUNNABLE
        thread.join();
        System.out.println(thread.getState()); // TERMINATED
    }
}
</code></pre>
<hr>
<h3 id="2-同步与锁-1"><strong>2. 同步与锁</strong></h3>
<h4 id="21-synchronized"><strong>2.1 <code>synchronized</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：简单的线程同步场景。</li>
<li><strong>注意点</strong>：锁的粒度要尽量小，避免性能问题。</li>
<li><strong>实现原理</strong>：基于 JVM 内置锁机制，通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">public class SynchronizedExample {
    private static class Counter {
        private int count = 0;
        public synchronized void increment() {
            count++; // 临界区操作
        }
        public int getCount() {
            return count;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Runnable task = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                counter.increment(); // 调用同步方法
            }
        };
        Thread thread1 = new Thread(task); // 创建线程1
        Thread thread2 = new Thread(task); // 创建线程2
        thread1.start(); // 启动线程1
        thread2.start(); // 启动线程2
        thread1.join(); // 等待线程1完成
        thread2.join(); // 等待线程2完成
        System.out.println("Final count: " + counter.getCount()); // 输出最终结果
    }
}
</code></pre>
<hr>
<h4 id="22-reentrantlock"><strong>2.2 <code>ReentrantLock</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：需要更灵活的锁控制（如可中断锁、超时锁）。</li>
<li><strong>注意点</strong>：必须手动释放锁，否则会导致死锁。</li>
<li><strong>实现原理</strong>：基于 <code>AQS</code>（AbstractQueuedSynchronizer）实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private static class Counter {
        private int count = 0;
        private final ReentrantLock lock = new ReentrantLock(); // 创建 ReentrantLock
        public void increment() {
            lock.lock(); // 获取锁
            try {
                count++; // 临界区操作
            } finally {
                lock.unlock(); // 释放锁
            }
        }
        public int getCount() {
            return count;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Runnable task = () -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                counter.increment(); // 调用同步方法
            }
        };
        Thread thread1 = new Thread(task); // 创建线程1
        Thread thread2 = new Thread(task); // 创建线程2
        thread1.start(); // 启动线程1
        thread2.start(); // 启动线程2
        thread1.join(); // 等待线程1完成
        thread2.join(); // 等待线程2完成
        System.out.println("Final count: " + counter.getCount()); // 输出最终结果
    }
}
</code></pre>
<hr>
<h3 id="3-原子操作类-1"><strong>3. 原子操作类</strong></h3>
<h4 id="31-atomicinteger"><strong>3.1 <code>AtomicInteger</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：无锁的线程安全计数器。</li>
<li><strong>注意点</strong>：适用于简单的原子操作，复杂场景可能需要锁。</li>
<li><strong>实现原理</strong>：基于 CAS（Compare-And-Swap）实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    public static void main(String[] args) {
        AtomicInteger atomicInt = new AtomicInteger(0); // 初始化值为 0
        atomicInt.incrementAndGet(); // 原子操作：自增并返回新值
        atomicInt.addAndGet(5); // 原子操作：增加指定值并返回新值
        System.out.println("Final value: " + atomicInt.get()); // 输出最终值
    }
}
</code></pre>
<hr>
<h3 id="4-并发集合-1"><strong>4. 并发集合</strong></h3>
<h4 id="41-concurrenthashmap"><strong>4.1 <code>ConcurrentHashMap</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：高并发场景下的键值对存储。</li>
<li><strong>注意点</strong>：不支持 <code>null</code> 键和值。</li>
<li><strong>实现原理</strong>：分段锁 + CAS 机制。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;(); // 创建 ConcurrentHashMap
        map.put("a", 1); // 插入键值对
        map.put("b", 2); // 插入键值对
        System.out.println("Value for key 'a': " + map.get("a")); // 获取值
    }
}
</code></pre>
<hr>
<h3 id="5-同步工具类-1"><strong>5. 同步工具类</strong></h3>
<h4 id="51-countdownlatch"><strong>5.1 <code>CountDownLatch</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：等待多个线程完成任务。</li>
<li><strong>注意点</strong>：计数器不能重置。</li>
<li><strong>实现原理</strong>：基于 AQS 实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(2); // 初始化计数器为 2
        new Thread(() -&gt; {
            System.out.println("Task 1 completed");
            latch.countDown(); // 计数器减 1
        }).start();
        new Thread(() -&gt; {
            System.out.println("Task 2 completed");
            latch.countDown(); // 计数器减 1
        }).start();
        latch.await(); // 阻塞直到计数器为 0
        System.out.println("All tasks completed");
    }
}
</code></pre>
<hr>
<h3 id="6-异步编程-1"><strong>6. 异步编程</strong></h3>
<h4 id="61-future"><strong>6.1 <code>Future</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：异步任务的结果获取。</li>
<li><strong>注意点</strong>：<code>get()</code> 方法会阻塞，直到任务完成。</li>
<li><strong>实现原理</strong>：基于 <code>Runnable</code> 和 <code>Callable</code> 实现。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor(); // 创建单线程线程池
        Future&lt;Integer&gt; future = executor.submit(() -&gt; 1 + 1); // 提交任务
        System.out.println("Task result: " + future.get()); // 获取任务结果
        executor.shutdown(); // 关闭线程池
    }
}
</code></pre>
<hr>
<h3 id="7-线程调度与定时任务-1"><strong>7. 线程调度与定时任务</strong></h3>
<h4 id="71-scheduledexecutorservice"><strong>7.1 <code>ScheduledExecutorService</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：定时任务和周期性任务。</li>
<li><strong>注意点</strong>：任务执行时间过长会影响后续任务。</li>
<li><strong>实现原理</strong>：基于线程池和任务队列。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorServiceExample {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // 创建调度线程池
        scheduler.schedule(() -&gt; System.out.println("Task executed"), 1, TimeUnit.SECONDS); // 延迟执行
        scheduler.shutdown(); // 关闭线程池
    }
}
</code></pre>
<hr>
<h3 id="8-其他高级特性-1"><strong>8. 其他高级特性</strong></h3>
<h4 id="81-threadlocal"><strong>8.1 <code>ThreadLocal</code></strong></h4>
<p><strong>描述</strong>：</p>
<ul>
<li><strong>适用范围</strong>：线程间数据隔离。</li>
<li><strong>注意点</strong>：可能导致内存泄漏，需要及时清理。</li>
<li><strong>实现原理</strong>：每个线程维护一个独立的 <code>ThreadLocalMap</code>。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">public class ThreadLocalExample {
    private static final ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; "Initial Value");

    public static void main(String[] args) {
        new Thread(() -&gt; {
            threadLocal.set("Thread 1 Value"); // 设置线程本地变量
            System.out.println("Thread 1: " + threadLocal.get()); // 获取线程本地变量
        }).start();
        new Thread(() -&gt; {
            threadLocal.set("Thread 2 Value"); // 设置线程本地变量
            System.out.println("Thread 2: " + threadLocal.get()); // 获取线程本地变量
        }).start();
    }
}
</code></pre>
<hr>
<p>以上是 Java JUC 的完整知识点汇总，包含代码示例、实现原理和注意点。如果需要进一步补充或调整，请随时告诉我！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7333250889525463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 17:21">2025-02-28 17:20</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18743696" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18743696);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18743696', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18743696', title: 'JUC相关知识点总结' })">举报</a>
</div>
        