
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/18654297" title="发布于 2025-01-06 08:08">
    <span role="heading" aria-level="2">基于源码分析 SHOW GLOBAL STATUS 的实现原理</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">问题</span></h1>
<p data-tool="mdnice编辑器">在 MySQL 中，查询全局状态变量的方式一般有两种：<code>SHOW GLOBAL STATUS</code>和<code>performance_schema.global_status</code>。</p>
<p data-tool="mdnice编辑器">但不知道大家注意到没有，performance_schema.global_status 返回的状态变量数要远远少于 SHOW GLOBAL STATUS 。</p>
<p data-tool="mdnice编辑器">具体来说，</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>在 MySQL 8.4.2 中，SHOW GLOBAL STATUS 返回了 503 个变量，而 performance_schema.global_status 只返回了 336 个。</p>
</li>
<li>
<p>在 MySQL 5.7.44 中，SHOW GLOBAL STATUS 返回了 354 个变量，而 performance_schema.global_status 只返回了 207 个。</p>
</li>
</ul>
<p data-tool="mdnice编辑器">有的童鞋可能会认为这两者的实现方式不一样，但事实上，从 MySQL 5.7 开始，当执行 SHOW GLOBAL STATUS 时，MySQL 并不是直接从内存中的状态变量获取数据，而是通过查询 performance_schema.global_status 表来间接获取。</p>
<p data-tool="mdnice编辑器">既然两者的实现方式是一样的，为什么返回的变量数会不一样？</p>
<p data-tool="mdnice编辑器">带着这个问题，接下来我们具体分析下 SHOW GLOBAL STATUS 的实现原理。本文主要包括以下几个部分：</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>状态变量是在哪里定义的？</li>
<li>状态变量值的来源。</li>
<li>SHOW GLOBAL STATUS 的实现原理。</li>
<li>performance_schema.global_status 的实现原理。</li>
<li>为什么 performance_schema.global_status 返回的变量数比 SHOW GLOBAL STATUS 少。</li>
</ul>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">状态变量是在哪里定义的？</span></h1>
<p data-tool="mdnice编辑器">状态变量的来源主要有三个：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>Server 层面的状态变量：这些状态变量主要在<code>status_vars</code>（mysqld.cc）中定义。在 MySQL 8.4 中，共有 321 个状态变量。其中包括了 com_status_vars 中定义的 167 个 Com 相关的变量。</li>
<li>插件中的状态变量：</li>
<ul class="list-paddingleft-1">
<li>InnoDB：在<code>innodb_status_variables</code>（ha_innodb.cc）中定义 ，共 76 个。</li>
<li>半同步复制：在<code>semi_sync_master_status_vars</code>（semisync_source_plugin.cc）中定义，共 14 个，从库只有 1 个。</li>
<li>组复制：在<code>group_replication_status_vars</code>（plugin.cc）中定义，共 22 个。</li>
<li>performance_schema：在<code>pfs_status_vars</code>（ha_perfschema.cc）中定义，共 33 个。</li>
<li>mysqlx：在<code>m_plugin_status_variables</code>（status_variables.cc）中定义，共 78 个。</li>
</ul>
<li>Component 中的状态变量：例如，在密码认证插件 validate_password 中定义的状态变量。</li>
</ol>
<p data-tool="mdnice编辑器">这些变量会通过<code>add_status_vars</code>函数添加到一个数组中 all_status_vars。注意这个数组名，后面讲解原理时会用到。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;sql/mysqld.cc<br>int&nbsp;init_common_variables()&nbsp;{<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;if&nbsp;(add_status_vars(status_vars))&nbsp;return&nbsp;1;&nbsp;<br>&nbsp;&nbsp;...<br>}<br><br>//&nbsp;sql/sql_plugin.cc<br>static&nbsp;int&nbsp;plugin_initialize(st_plugin_int&nbsp;*plugin)&nbsp;{<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;if&nbsp;(plugin-&gt;plugin-&gt;status_vars)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(add_status_vars(plugin-&gt;plugin-&gt;status_vars))&nbsp;goto&nbsp;err;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;...<br>}<br><br>//&nbsp;sql/server_component/component_status_var_service.cc<br>DEFINE_BOOL_METHOD(mysql_status_variable_registration_imp::register_variable,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SHOW_VAR&nbsp;*&nbsp;status_var))&nbsp;{<br>&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(add_status_vars(status_var))&nbsp;return&nbsp;true;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;}&nbsp;catch&nbsp;(...)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;mysql_components_handle_std_exception(__func__);<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return&nbsp;true;<br>}<br><br>//&nbsp;sql/sql_show.cc<br>bool&nbsp;add_status_vars(const&nbsp;SHOW_VAR&nbsp;*list)&nbsp;{<br>...<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(list-&gt;name)&nbsp;all_status_vars.push_back(*list++);<br>...<br>}<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">状态变量值的来源</span></h1>
<p data-tool="mdnice编辑器">状态变量的值是在定义时指定的，以 Server 层面的状态变量为例：</p>
<pre data-tool="mdnice编辑器"><code>SHOW_VAR&nbsp;status_vars[]&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;{"Aborted_clients",&nbsp;(char&nbsp;*)&amp;aborted_threads,&nbsp;SHOW_LONG,&nbsp;SHOW_SCOPE_GLOBAL},<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;{"Bytes_received",&nbsp;(char&nbsp;*)offsetof(System_status_var,&nbsp;bytes_received),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHOW_LONGLONG_STATUS,&nbsp;SHOW_SCOPE_ALL},<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;{"Com",&nbsp;(char&nbsp;*)com_status_vars,&nbsp;SHOW_ARRAY,&nbsp;SHOW_SCOPE_ALL},<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;{"Uptime",&nbsp;(char&nbsp;*)&amp;show_starttime,&nbsp;SHOW_FUNC,&nbsp;SHOW_SCOPE_GLOBAL},<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br></code></pre>
<p data-tool="mdnice编辑器">status_vars 是一个数组，其元素类型是<code>SHOW_VAR</code>，每个元素代表一个状态变量。每个元素包含四个字段，依次是：变量名、变量值、变量类型和变量作用范围。所以，通过元素的第二个字段，就可以确定该状态变量值的来源。</p>
<p data-tool="mdnice编辑器">上面列举了四个有代表性的状态变量：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>Aborted_clients：变量值来源于全局变量 aborted_threads（<code>extern ulong aborted_threads</code>）。</p>
</li>
<li>
<p>Bytes_received：变量值来自于 System_status_var 结构体中 bytes_received 字段的内存偏移量（<code>offsetof(System_status_var, bytes_received)</code>）。</p>
<p>System_status_var 常用于以下场景：</p>
</li>
<ul class="list-paddingleft-1">
<li>global_status_var：用于存储全局的状态变量。连接断开后，会通过<code>add_to_status</code>函数将对应线程的状态变量添加到 global_status_var 中。</li>
<li>status_var：用于存储每个线程的状态变量。</li>
<li>query_start_status：保存上一个操作结束时线程的状态变量，只在<code>log_slow_extra</code>&nbsp;为 ON 时使用。</li>
</ul>
<li>
<p>Com：变量值来自于<code>com_status_vars</code>数组（怎么知道它是一个数组呢？实际上看的是第三个字段，SHOW_ARRAY 代表它是一个数组），该数组定义了 Com 相关的状态变量。</p>
</li>
<li>
<p>Uptime：变量值由<code>show_starttime</code>函数（SHOW_FUNC 代表它是一个函数）生成。下面是该函数的具体实现。</p>
</li>
</ol>
<pre data-tool="mdnice编辑器"><code>static&nbsp;int&nbsp;show_starttime(THD&nbsp;*thd,&nbsp;SHOW_VAR&nbsp;*var,&nbsp;char&nbsp;*buff)&nbsp;{<br>&nbsp;&nbsp;var-&gt;type&nbsp;=&nbsp;SHOW_LONGLONG;<br>&nbsp;&nbsp;var-&gt;value&nbsp;=&nbsp;buff;<br>&nbsp;&nbsp;*((longlong&nbsp;*)buff)&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(longlong)(thd-&gt;query_start_in_secs()&nbsp;-&nbsp;server_start_time);<br>&nbsp;&nbsp;return&nbsp;0;<br>}<br></code></pre>
<p data-tool="mdnice编辑器">不难看出，Uptime 实际上是通过查询的开始时间（<code>thd-&gt;set_time()</code>中设置的）减去 MySQL 服务器的启动时间得到的。</p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">SHOW GLOBAL STATUS 的实现原理</span></h1>
<p data-tool="mdnice编辑器">当我们执行 SHOW GLOBAL STATUS 时，实际上查询的是 performance_schema.global_status。</p>
<p data-tool="mdnice编辑器">这一转化操作是在<code>build_show_global_status</code>函数中实现的。该函数会将表名（table_name，即 global_status 表）、LIKE 子句（wild）和 WHERE 子句（where_cond）传递给<code>build_query</code>函数，后者会构造对应的 SQL 查询解析树。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;sql/sql_show_status.cc<br>Query_block&nbsp;*build_show_global_status(const&nbsp;POS&nbsp;&amp;pos,&nbsp;THD&nbsp;*thd,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;String&nbsp;*wild,&nbsp;Item&nbsp;*where_cond)&nbsp;{<br>&nbsp;&nbsp;static&nbsp;const&nbsp;LEX_CSTRING&nbsp;table_name&nbsp;=&nbsp;{STRING_WITH_LEN("global_status")};<br><br>&nbsp;&nbsp;return&nbsp;build_query(pos,&nbsp;thd,&nbsp;SQLCOM_SHOW_STATUS,&nbsp;table_name,&nbsp;wild,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where_cond);<br>}<br></code></pre>
<p data-tool="mdnice编辑器">在不指定任何查询条件的情况下，SHOW GLOBAL STATUS 对应的查询语句如下：</p>
<pre data-tool="mdnice编辑器"><code>SELECT&nbsp;*&nbsp;FROM<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SELECT&nbsp;VARIABLE_NAME&nbsp;as&nbsp;Variable_name,&nbsp;VARIABLE_VALUE&nbsp;as&nbsp;Value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;performance_schema.global_status)&nbsp;global_status<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">performance_schema.global_status 的实现原理</span></h1>
<p data-tool="mdnice编辑器">查询 performance_schema.global_status 时，MySQL 会通过调用<code>MaterializeIterator&lt;Profiler&gt;::MaterializeOperand</code>函数实现数据的物化（即构造查询结果），除此之外，这个函数还会逐行读取数据并将其写入目标表。</p>
<p data-tool="mdnice编辑器">下面是该函数简化后的代码。</p>
<pre data-tool="mdnice编辑器"><code>bool&nbsp;MaterializeIterator&lt;Profiler&gt;::MaterializeOperand(const&nbsp;Operand&nbsp;&amp;operand,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ha_rows&nbsp;*stored_rows)&nbsp;{<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;if&nbsp;(operand.subquery_iterator-&gt;Init())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;PFSBatchMode&nbsp;pfs_batch_mode(operand.subquery_iterator.get());<br><br>&nbsp;&nbsp;while&nbsp;(true)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;error&nbsp;=&nbsp;read_next_row(operand);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;t-&gt;file-&gt;ha_write_row(t-&gt;record[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;return&nbsp;false;<br>}<br></code></pre>
<p data-tool="mdnice编辑器">具体来说，</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li><code>operand.subquery_iterator-&gt;Init()</code>会实现数据的物化（即构造查询结果）。</li>
<li><code>read_next_row(operand)</code>会逐行读取数据，并将数据写到 table-&gt;record[0] 中，table-&gt;record[0] 是当前行的数据缓冲区。</li>
<li><code>t-&gt;file-&gt;ha_write_row(t-&gt;record[0])</code>会将 table-&gt;record[0] 中的数据写到 performance_schema.global_status 中。</li>
</ul>
<p data-tool="mdnice编辑器">接下来，我们具体分析下构造查询结果和数据读取这两个步骤的实现逻辑。</p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">构造查询结果</span></h2>
<p data-tool="mdnice编辑器">下面是<code>operand.subquery_iterator-&gt;Init()</code>调用后的堆栈信息。</p>
<pre data-tool="mdnice编辑器"><code>#0&nbsp;&nbsp;PFS_status_variable_cache::do_materialize_global()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/pfs_variable.cc:1178<br>#1&nbsp;&nbsp;PFS_variable_cache&lt;Status_variable&gt;::materialize_global()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/pfs_variable.h:526<br>#2&nbsp;&nbsp;table_global_status::rnd_init()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/table_global_status.cc:123<br>#3&nbsp;&nbsp;ha_perfschema::rnd_init()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/ha_perfschema.cc:1733<br>#4&nbsp;&nbsp;handler::ha_rnd_init()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/handler.cc:2961<br>#5&nbsp;&nbsp;TableScanIterator::Init()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/iterators/basic_row_iterators.cc:260<br>#6&nbsp;&nbsp;MaterializeIterator::MaterializeOperand()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/iterators/composite_iterators.cc:2759<br></code></pre>
<p data-tool="mdnice编辑器">查询结果的构造主要是在<code>PFS_status_variable_cache::do_materialize_global()</code>函数中实现的。</p>
<p data-tool="mdnice编辑器">下面我们看看这个函数的具体实现细节。</p>
<pre data-tool="mdnice编辑器"><code>int&nbsp;PFS_status_variable_cache::do_materialize_global()&nbsp;{<br>&nbsp;&nbsp;//&nbsp;这个变量用来汇总全局的状态变量（global_status_var）和当前所有线程的状态变量（status_var）<br>&nbsp;&nbsp;System_status_var&nbsp;status_totals;<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;if&nbsp;(!m_external_init)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;基于&nbsp;all_status_vars&nbsp;构建一个满足条件的状态变量数组&nbsp;m_show_var_array<br>&nbsp;&nbsp;&nbsp;&nbsp;init_show_var_array(OPT_GLOBAL,&nbsp;true);<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;//&nbsp;初始化&nbsp;PFS_connection_status_visitor，将&nbsp;status_vars&nbsp;赋值给&nbsp;m_status_vars<br>&nbsp;&nbsp;PFS_connection_status_visitor&nbsp;visitor(&amp;status_totals);<br>&nbsp;&nbsp;//&nbsp;这个函数非常关键，它会将全局的状态变量（global_status_var）和当前所有线程的状态变量（status_var）累加汇总到 m_status_vars 中。<br>&nbsp;&nbsp;PFS_connection_iterator::visit_global(false,&nbsp;/*&nbsp;hosts&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false,&nbsp;/*&nbsp;users&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false,&nbsp;/*&nbsp;accounts&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false,&nbsp;/*&nbsp;threads&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true,&nbsp;&nbsp;/*&nbsp;THDs&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;visitor);<br>&nbsp;&nbsp;//&nbsp;这个函数也非常关键，它会遍历 m_show_var_array 中的状态变量，获取其值并进行格式化处理，最终将处理后的结果缓存到 m_cache 中。<br>&nbsp;&nbsp;manifest(m_current_thd,&nbsp;m_show_var_array.begin(),&nbsp;&amp;status_totals,&nbsp;"",&nbsp;false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true);<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;return&nbsp;0;<br>}<br></code></pre>
<p data-tool="mdnice编辑器">该函数的处理流程如下：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>基于 all_status_vars 构建一个满足条件的状态变量数组 m_show_var_array。至于需要满足什么条件，后面会详细说明。</li>
<li>将全局的状态变量（global_status_var）和当前所有线程的状态变量（status_var）累加汇总到 status_totals 中。</li>
<li>遍历 m_show_var_array 中的状态变量，根据变量的类型（如 SHOW_FUNC、SHOW_ARRAY 等）进行不同的处理，并将处理后的状态变量存储到 m_cache 缓存中。具体处理逻辑如下：</li>
<ul class="list-paddingleft-1">
<li>对于 SHOW_FUNC 类型的变量，<code>manifest</code>会递归执行函数来计算变量的最终值。</li>
<li>对于 SHOW_ARRAY 类型的变量，函数会递归调用&nbsp;<code>manifest</code>，以展开数组中的每一个状态变量。</li>
<li>状态变量添加到 m_cache 之前，会先转换为 Status_variable 类型。</li>
</ul>
</ol>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">读取数据</span></h2>
<p data-tool="mdnice编辑器">下面是<code>read_next_row(operand)</code>调用后的堆栈信息。</p>
<pre data-tool="mdnice编辑器"><code>#0&nbsp;&nbsp;PFS_variable_cache&lt;Status_variable&gt;::get()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/pfs_variable.h:382<br>#1&nbsp;&nbsp;table_global_status::rnd_next()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/table_global_status.cc:131<br>#2&nbsp;&nbsp;ha_perfschema::rnd_next()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/storage/perfschema/ha_perfschema.cc:1757<br>#3&nbsp;&nbsp;handler::ha_rnd_next()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/handler.cc:3006<br>#4&nbsp;&nbsp;TableScanIterator::Read()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/iterators/basic_row_iterators.cc:278<br>#5&nbsp;&nbsp;MaterializeIterator::read_next_row()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/iterators/composite_iterators.cc:2278<br>#6&nbsp;&nbsp;MaterializeIterator::MaterializeOperand()&nbsp;at&nbsp;/usr/src/mysql-8.4.2/sql/iterators/composite_iterators.cc:2771<br></code></pre>
<p data-tool="mdnice编辑器"><code>read_next_row(operand)</code>最后会调用<code>PFS_variable_cache&lt;Status_variable&gt;::get()</code>，而这个函数实际上读取的就是 m_cache 中的元素。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;storage/perfschema/pfs_variable.h:382<br>&nbsp;&nbsp;const&nbsp;Var_type&nbsp;*get(uint&nbsp;index&nbsp;=&nbsp;0)&nbsp;const&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(index&nbsp;&gt;=&nbsp;m_cache.size())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;Var_type&nbsp;*p&nbsp;=&nbsp;&amp;m_cache.at(index);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;p;<br>&nbsp;&nbsp;}<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">为什么 performance_schema.global_status 返回的变量数比 SHOW GLOBAL STATUS 少？</span></h1>
<p data-tool="mdnice编辑器">前面我们提到过，在构造查询结果时，会先基于 all_status_vars 构建一个满足条件的状态变量数组 m_show_var_array。</p>
<p data-tool="mdnice编辑器">具体需要满足什么条件，是在<code>PFS_status_variable_cache::filter_show_var</code>函数中定义的。</p>
<pre data-tool="mdnice编辑器"><code>bool&nbsp;PFS_status_variable_cache::filter_show_var(const&nbsp;SHOW_VAR&nbsp;*show_var,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;strict)&nbsp;{<br>&nbsp;&nbsp;if&nbsp;(!match_scope(show_var-&gt;scope,&nbsp;strict))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;if&nbsp;(filter_by_name(show_var))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;if&nbsp;(m_aggregate&nbsp;&amp;&amp;&nbsp;!can_aggregate(show_var-&gt;type))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;return&nbsp;false;<br>}<br><br>bool&nbsp;PFS_status_variable_cache::filter_by_name(const&nbsp;SHOW_VAR&nbsp;*show_var)&nbsp;{<br>&nbsp;&nbsp;assert(show_var);<br>&nbsp;&nbsp;assert(show_var-&gt;name);<br><br>&nbsp;&nbsp;if&nbsp;(show_var-&gt;type&nbsp;==&nbsp;SHOW_ARRAY)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;SHOW_ARRAY&nbsp;name&nbsp;is&nbsp;the&nbsp;prefix&nbsp;for&nbsp;the&nbsp;variables&nbsp;in&nbsp;the&nbsp;sub&nbsp;array.&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*prefix&nbsp;=&nbsp;show_var-&gt;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Exclude&nbsp;COM&nbsp;counters&nbsp;if&nbsp;not&nbsp;a&nbsp;SHOW&nbsp;STATUS&nbsp;command.&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!my_strcasecmp(system_charset_info,&nbsp;prefix,&nbsp;"Com")&nbsp;&amp;&amp;&nbsp;!m_show_command)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return&nbsp;false;<br>}<br></code></pre>
<p data-tool="mdnice编辑器">从代码中可以看到，需要判断的条件有三个：</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>变量作用范围：因为<code>init_show_var_array(OPT_GLOBAL, true)</code>中指定了 OPT_GLOBAL，所以这里会过滤掉变量作用范围为 SHOW_SCOPE_SESSION 的状态变量。在 Server 层面的状态变量中，这样的变量有 6 个：Compression、Compression_algorithm、Compression_level、Last_query_cost、Last_query_partial_plans、Tls_sni_server_name。</li>
<li>对于非 m_show_command 类的查询（其实就是指的是直接查询 performance_schema.global_status 这种方式），还会剔除&nbsp;<code>com_status_vars</code>数组中 Com 相关的状态变量。这也就是为什么 performance_schema.global_status 返回的变量数比 SHOW GLOBAL STATUS 中少。</li>
<li>查询聚合数据：如果查询的是 status_by_account、status_by_host 或 status_by_user 之类的聚合表，还会剔除无法聚合的状态变量。</li>
</ul>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">总结</span></h1>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>状态变量的来源主要有三个：Server、插件和 Component。</li>
<li>如果想查看某个状态变量值的来源，直接查看定义部分对应元素的第二个字段即可。</li>
<li>当我们执行 SHOW GLOBAL STATUS 时，实际上查询的是 performance_schema.global_status。</li>
<li>performance_schema.global_status 在实现上主要分为两步：1. 构造查询结果，将所有变量的值存储到一个缓存（m_cache）中；2. 数据读取，直接从缓存中读取变量值。</li>
<li>之所以 performance_schema.global_status 返回的变量数比 SHOW GLOBAL STATUS 中少，主要是<code>PFS_status_variable_cache::filter_by_name</code>中的限制。</li>
<li>需要注意的是，如果查询中指定了过滤条件，过滤操作会发生在数据读取阶段，而不是查询结果构造阶段。</li>
</ol>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.17423812148842593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 08:08">2025-01-06 08:08</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18654297" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18654297);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18654297', targetLink: 'https://www.cnblogs.com/ivictor/p/18654297', title: '基于源码分析 SHOW GLOBAL STATUS 的实现原理' })">举报</a>
</div>
	