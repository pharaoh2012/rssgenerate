
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18643761" title="发布于 2024-12-31 13:10">
    <span role="heading" aria-level="2">Python并发总结：多线程、多进程与异步编程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>随着多核的发展，<code>Python</code>中并发编程也变得越来越广泛且发展很快。</p>
<p>一方面，<code>Python</code>提供了多种并发编程工具。</p>
<p>比如，传统的多线程，通过<code>threading</code>模块方便地创建和管理线程，可用于I/O密集型任务；</p>
<p>多进程，利用<code>multiprocessing</code>模块充分利用多核CPU优势，适合CPU密集型任务。</p>
<p>另一方面，随着异步编程的兴起。<code>asyncio</code>库也让开发者能够编写高效的异步代码，提升程序性能，尤其在处理大量并发I/O操作场景表现出色。</p>
<p>不过，<code>Python</code>中全局解释器锁（<code>GIL</code>）为并发编程带来了不小的挑战，目前社区正在积极探索绕过<code>GIL</code>的方法和优化策略，推动<code>Python</code>并发编程持续进步。</p>
<p>本篇打算一一介绍如何<code>Python</code>中使用多线程、多进程或异步的方式来编写程序。</p>
<h1 id="1-多线程">1. 多线程</h1>
<p><code>Python</code>中多线程的模块是<code>threading</code>，早在<code>Python 1.5</code> 版本时就加入到标准库中了。</p>
<p><code>threading</code>一直在发展，特别是进入<code>Python3.x</code>之后，</p>
<p>从<code>Python3.3~Python3.13</code>，几乎每次<code>Python</code>的升级都伴随着<code>threading</code>的变化。</p>
<p>所以，使用时务必根据自己<code>Python</code>版本来正确使用<code>threading</code>的接口。</p>
<h2 id="11-使用场景和局限">1.1. 使用场景和局限</h2>
<p><code>Python</code>的多线程广泛用于 <strong>I/O 密集型</strong>的任务场景中，如网络请求、文件读写等，让程序在等待 <code>I/O</code> 操作时切换执行其他线程，从而提升整体效率。</p>
<p>随着应用场景拓展，多线程局限性也逐渐凸显。</p>
<p>最主要的是<strong>全局解释器锁</strong>（<code>GIL</code>），这是 <code>Python</code> 解释器的一个特性，同一时刻只有一个线程能执行 <code>Python</code> 字节码。</p>
<p>这导致在 <code>CPU</code> 密集型任务中，多线程无法充分利用多核 <code>CPU</code> 优势，性能提升不明显甚至可能降低。</p>
<p>不过，尽管存在局限，多线程在 <code>Python</code> 生态中仍有重要地位。</p>
<p>开发者不断探索优化方法，如使用<code>threading</code>结合<code>multiprocessing</code>等其他并发模块，扬长避短。同时，新的 <code>Python</code> 版本也在尝试改进 <code>GIL</code> 机制，为多线程发展提供更多可能 。</p>
<h2 id="12-使用方式">1.2. 使用方式</h2>
<p>在实际开发中，使用多线程主要有3种方式：</p>
<p>第一种方式是直接使用<code>threading.Thread</code>类创建线程，</p>
<p>这是最基本的方式，直接实例化threading.Thread类并传入目标函数及参数。</p>
<pre><code class="language-python">import threading


def worker():
    print('线程正在执行')


# 创建线程
t = threading.Thread(target=worker)
# 启动线程
t.start()
# 等待线程执行完毕
t.join()
</code></pre>
<p>第二种方式通过继承<code>threading.Thread</code>类创建线程类，并重写<code>run</code>方法来定义线程执行的任务。</p>
<pre><code class="language-python">import threading


class MyThread(threading.Thread):
    def run(self):
        print(f'{self.name} 线程正在执行')


# 创建线程实例
my_thread = MyThread()
# 启动线程
my_thread.start()
# 等待线程执行完毕
my_thread.join()
</code></pre>
<p>最后一种方式是使用<code>threading.ThreadPool</code>实现线程池，在 <code>Python 3</code> 中，建议使用<code>concurrent.futures</code>模块中的<code>ThreadPoolExecutor</code>来实现线程池功能。</p>
<p><code>threading.ThreadPool</code>已经标记过时，不建议在新的项目中再使用。</p>
<p>线程池的好处是可以管理一组线程，重用线程资源，减少线程创建和销毁的开销。</p>
<pre><code class="language-python">import concurrent.futures


def task(num):
    print(f"执行任务 {num}")
    return num * 2


# 创建线程池，最大线程数为3
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # 提交任务
    future_to_num = {executor.submit(task, num): num for num in range(5)}
    for future in concurrent.futures.as_completed(future_to_num):
        num = future_to_num[future]
        try:
            result = future.result()
        except Exception as e:
            print(f"任务 {num} 执行失败: {e}")
        else:
            print(f"任务 {num} 结果: {result}")
</code></pre>
<p>执行结果：</p>
<pre><code class="language-bash">$  python.exe .\thread.py
执行任务 0
执行任务 1
执行任务 2
执行任务 3
任务 1 结果: 2
执行任务 4
任务 2 结果: 4
任务 0 结果: 0
任务 3 结果: 6
任务 4 结果: 8
</code></pre>
<h1 id="2-多进程">2. 多进程</h1>
<p>多线程模块<code>multiprocessing</code>自 <code>Python 2.6</code> 版本引入，随后在 <code>Python 3.x</code> 中持续发展。</p>
<p>在发展过程中，<code>multiprocessing</code>不断完善。它提供了简洁且强大的接口，让开发者能轻松创建和管理多个进程，充分利用多核 <code>CPU </code>的优势，大幅提升 <code>CPU</code> 密集型任务的处理效率。</p>
<p>它支持多种进程间通信方式，如队列、管道等，方便进程间的数据共享与同步。</p>
<h2 id="21-使用场景和局限">2.1. 使用场景和局限</h2>
<p><code>multiprocessing</code>适用于<code>CPU</code> 密集型计算，如科学计算、数据分析、图像处理等需要大量计算资源的任务。</p>
<p>当有多个独立任务需要同时执行时，也可以使用<code>multiprocessing</code>，例如批量文件处理、任务队列处理等。可以为每个任务分配一个进程，提高任务执行效率。</p>
<p>此外，在一些服务器应用中，也可以使用多进程让主进程处理请求的同时，其他进程负责后台任务，如数据缓存更新、日志记录等，从而避免阻塞主线程，提升应用的响应速度 。</p>
<p>不过，<code>multiprocessing</code>也存在一些局限性。</p>
<p>由于每个进程都有独立的内存空间，进程间数据共享和通信相对复杂，需要额外的机制和同步操作，可能带来性能损耗。</p>
<p>并且，创建和销毁进程的开销较大，频繁地创建和销毁进程会影响程序的整体性能。</p>
<p>此外，它的使用场景相对受限，不适用于简单的并发任务，相比多线程，在 I/O 密集型任务中优势不明显，因为多线程在 I/O 等待时能切换执行其他任务，多进程则会耗费更多资源。</p>
<h2 id="22-使用方式">2.2. 使用方式</h2>
<p>这里也介绍使用<code>multiprocessing</code>的3种常用的方式：</p>
<p>第一种是直接使用 <code>Process</code> 类，通过实例化<code>multiprocessing.Process</code>类并传入目标函数及参数来创建进程。</p>
<pre><code class="language-python">import multiprocessing


def worker():
    print('进程正在执行')


if __name__ == '__main__':
    # 创建进程
    p = multiprocessing.Process(target=worker)
    # 启动进程
    p.start()
    # 等待进程执行完毕
    p.join()
</code></pre>
<p>第二种方式是通过继承<code>multiprocessing.Process</code>类，并重写<code>run</code>方法来定义进程执行的任务。</p>
<pre><code class="language-python">import multiprocessing


class MyProcess(multiprocessing.Process):
    def run(self):
        print(f'{self.name} 进程正在执行')


if __name__ == '__main__':
    # 创建进程实例
    my_process = MyProcess()
    # 启动进程
    my_process.start()
    # 等待进程执行完毕
    my_process.join()
</code></pre>
<p>最后一种方式是通过<code>multiprocessing.Pool</code>类创建一个进程池，自动分配任务给进程，提高资源利用率。</p>
<pre><code class="language-python">import multiprocessing


def task(num):
    return num * 2


if __name__ == '__main__':
    # 创建进程池，最大进程数为3
    with multiprocessing.Pool(processes=3) as pool:
        # 使用map方法并行执行任务
        results = pool.map(task, range(5))
        print(results)
</code></pre>
<p>这三种使用方式看起来和上一节中的<code>threading</code>都差不多，不过，它们底层的处理是完全不一样的，</p>
<p><code>multiprocessing</code>会为每个任务单独创建一个进程去执行；而<code>threading</code>中的所有任务都是在同一个进程中执行的。</p>
<h1 id="3-异步">3. 异步</h1>
<p>异步模块<code>asyncio</code>的历史比上面的两个模块要迟很多，它在<code>Python 3.4</code> 版本中被首次引入。</p>
<p>在<code>Python 3.5</code>时， 引入了<code>async</code>和<code>await</code>关键字，让异步代码的编写更加简洁、易读，大大提升了异步编程的体验，推动了asyncio的广泛应用。</p>
<h2 id="31-使用场景和局限">3.1. 使用场景和局限</h2>
<p><code>asyncio</code>适用于下面几种对并发处理要求高的场景：</p>
<ul>
<li>
<p><strong>网络爬虫</strong>：在爬取多个网页时，<code>asyncio</code>能在等待响应的同时，继续发送其他请求，大大提高爬取效率，缩短获取大量数据的时间。</p>
</li>
<li>
<p><strong>网络服务端开发</strong>：处理高并发的客户端连接，如构建聊天服务器、实时数据推送服务等。它能异步处理每个客户端请求，避免阻塞，确保服务器高效运行。</p>
</li>
<li>
<p><strong>I/O密集型任务</strong>：如文件读写、数据库操作等。<code>asyncio</code>可在等待<code>I/O</code>操作完成时执行其他任务，减少整体等待时间，提升程序性能。</p>
</li>
</ul>
<p>当然，<code>asyncio</code>的优势明显，但也存在一些局限性。</p>
<p>一方面，由于它基于单线程，在处理 <code>CPU</code> 密集型任务时性能欠佳，无法充分利用多核 <code>CPU</code> 的优势。</p>
<p>另一方面，异步编程模型相对复杂，代码调试和维护难度较高，需要开发者对异步概念有深入理解，否则容易出现逻辑错误。</p>
<p>此外，<code>asyncio</code>与一些传统的同步库可能存在兼容性问题，在集成现有代码时可能会遇到困难。</p>
<h2 id="32-使用方式">3.2. 使用方式</h2>
<p><code>asyncio</code>是比较新的模块，它的使用方式主要有：</p>
<ol>
<li>定义一个协程函数，使用<code>async def</code>关键字声明，在函数内部使用<code>await</code>关键字暂停协程执行，等待其他异步操作完成。</li>
</ol>
<pre><code class="language-python">import asyncio


async def coroutine():
    print('开始执行协程函数')
    await asyncio.sleep(1)
    print('协程函数执行结束')


if __name__ == '__main__':
    asyncio.run(coroutine())
</code></pre>
<p><code>asyncio.run()</code>用于运行最高层级的协程。</p>
<ol start="2">
<li>使用<code>asyncio.gather()</code>函数可以同时运行多个协程。</li>
</ol>
<pre><code class="language-python">import asyncio


async def coroutine1():
    await asyncio.sleep(1)
    print('协程1执行完毕')


async def coroutine2():
    await asyncio.sleep(2)
    print('协程2执行完毕')


if __name__ == "__main__":
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    try:
        loop.run_until_complete(asyncio.gather(coroutine1(), coroutine2()))
    finally:
        loop.close()
</code></pre>
<ol start="3">
<li>使用<code>async for</code>对异步可迭代对象进行迭代。</li>
</ol>
<pre><code class="language-python">import asyncio


async def async_generator():
    for i in range(3):
        await asyncio.sleep(1)
        yield i


async def main():
    async for num in async_generator():
        print(num)


if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<p>这种方式适用于处理异步产生的数据序列。</p>
<h1 id="4-总结">4. 总结</h1>
<p>总的来看，</p>
<p><strong>多线程</strong>是在一个进程里创建多个线程，共享资源，线程切换开销小，适合 <code>I/O </code>密集型任务，像网络请求、文件读写。</p>
<p>它编程简单，能提高程序响应性，但因全局解释器锁，在 <code>CPU</code> 密集型任务中无法发挥多核优势，还存在线程安全问题。</p>
<p><strong>多进程</strong>中每个进程有独立内存和资源，适合 <code>CPU</code> 密集型任务，能充分利用多核 <code>CPU</code>，稳定性高。</p>
<p>不过，进程创建和销毁开销大，进程间通信和数据共享复杂。</p>
<p><strong>异步编程</strong>基于事件循环和协程，在单线程内实现异步。</p>
<p>它并发性能高，代码简洁，适合大量 I/O 密集型任务。但不适合 CPU 密集型任务，编程模型复杂，调试维护难。</p>
<p>简单来说，在开发时，I/O 密集型任务少用<strong>多线程</strong>，任务多用<strong>异步</strong>；CPU 密集型任务就选<strong>多进程</strong>；混合任务则按需组合。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.38257743734953703" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-31 13:11">2024-12-31 13:10</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18643761" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18643761);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18643761', targetLink: 'https://www.cnblogs.com/wang_yb/p/18643761', title: 'Python并发总结：多线程、多进程与异步编程' })">举报</a>
</div>
        