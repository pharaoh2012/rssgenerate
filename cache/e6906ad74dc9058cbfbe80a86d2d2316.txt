
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ashuaiYiRen/p/18756609" title="发布于 2025-03-06 22:02">
    <span role="heading" aria-level="2">异步编程——CompletableFuture详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="future">Future</h1>
<p>JDK5 新增了Future接口，用于描述一个异步计算的结果。</p>
<p>虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，我们必须使用Future.get()的方式阻塞调用线程，或者使用轮询方式判断 Future.isDone 任务是否结束，再获取结果。</p>
<p>并且，Future 无法解决多个异步任务相互依赖的场景，简单点说就是，主线程需要等待子线程任务执行完毕之后在进行执行，这个时候你可能想到了 「CountDownLatch」，没错确实可以解决，代码如下。</p>
<p>这里定义两个 Future，第一个通过用户 id 获取用户信息，第二个通过商品 id 获取商品信息。</p>
<pre><code class="language-java">public void testCountDownLatch() throws InterruptedException, ExecutionException {
    ExecutorService executorService = Executors.newFixedThreadPool(5);

    CountDownLatch downLatch = new CountDownLatch(2);

    long startTime = System.currentTimeMillis();
    Future&lt;String&gt; userFuture = executorService.submit(() -&gt; {
        //模拟查询商品耗时500毫秒
        Thread.sleep(500);
        downLatch.countDown();
        return "用户A";
    });

    Future&lt;String&gt; goodsFuture = executorService.submit(() -&gt; {
        //模拟查询商品耗时500毫秒
        Thread.sleep(400);
        downLatch.countDown();
        return "商品A";
    });

    downLatch.await();
    //模拟主程序耗时时间
    Thread.sleep(600);
    System.out.println("获取用户信息:" + userFuture.get());
    System.out.println("获取商品信息:" + goodsFuture.get());
    System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");

}
</code></pre>
<p>Java8 以后这不再是一种优雅的解决方式，接下来来了解下 CompletableFuture 的使用。</p>
<h1 id="completablefuture">CompletableFuture</h1>
<pre><code class="language-java">@Test
public void testCompletableInfo() throws InterruptedException, ExecutionException {
    long startTime = System.currentTimeMillis();

    //调用用户服务获取用户基本信息
    CompletableFuture&lt;String&gt; userFuture = CompletableFuture.supplyAsync(() -&gt;
            //模拟查询商品耗时500毫秒
    {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "用户A";
    });

    //调用商品服务获取商品基本信息
    CompletableFuture&lt;String&gt; goodsFuture = CompletableFuture.supplyAsync(() -&gt;
            //模拟查询商品耗时500毫秒
    {
        try {
            Thread.sleep(400);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "商品A";
    });

    System.out.println("获取用户信息:" + userFuture.get());
    System.out.println("获取商品信息:" + goodsFuture.get());

    //模拟主程序耗时时间
    Thread.sleep(600);
    System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");
}
</code></pre>
<h2 id="completablefuture-创建方式">CompletableFuture 创建方式</h2>
<p><strong>「supplyAsync」</strong>执行任务，支持返回值。<br>
<strong>「runAsync」</strong>执行任务，没有返回值。<br>
参数如果传了线程池就使用自定义的线程池，没传则使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务。（注意：<strong>默认内置线程池核心数为机器核心数减一，如果机器核心数比2小时，会创建一个新线程去跑任务，建议在高并发场景使用自定义线程池</strong>）</p>
<pre><code class="language-java">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier){..}
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor){..}
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable){..}
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor){..}
</code></pre>
<h2 id="completablefuture-获取方式">CompletableFuture 获取方式</h2>
<pre><code>//方式一
public T get()

//方式二

public T get(long timeout, TimeUnit unit)

//方式三

public T getNow(T valueIfAbsent)

//方式四

public T join()
</code></pre>
<p>说明：</p>
<p>「get()和 get(long timeout, TimeUnit unit)」 =&gt; 在 Future 中就已经提供了，后者提供超时处理，如果在指定时间内未获取结果将抛出超时异常<br>
「getNow」 =&gt; 立即获取结果不阻塞，结果计算已完成将返回结果或计算过程中的异常，如果未计算完成将返回设定的 valueIfAbsent 值<br>
「join」 =&gt;  方法里有异常不会抛出异常，但会抛出 CompletionException</p>
<h2 id="异步回调方法">异步回调方法</h2>
<p>1、thenRun/thenRunAsync<br>
通俗点讲就是，「做完第一个任务后，再做第二个任务,第二个任务也没有返回值」。</p>
<p>【Async】加了则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 ForkJoin 线程池，没加则第二个线程池也用传入的线程池。</p>
<p>2、thenAccept/thenAcceptAsync</p>
<p>第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是没有返回值的。</p>
<p>3、thenApply/thenApplyAsync</p>
<p>表示第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，并且回调方法是有返回值的。</p>
<h2 id="异常回调">异常回调</h2>
<p>whenComplete + exceptionally 示例</p>
<pre><code>public void testWhenCompleteExceptionally() throws ExecutionException, InterruptedException {
    CompletableFuture&lt;Double&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        if (Math.random() &lt; 0.5) {
            throw new RuntimeException("出错了");
        }
        System.out.println("正常结束");
        return 0.11;

    }).whenComplete((aDouble, throwable) -&gt; {
        if (aDouble == null) {
            System.out.println("whenComplete aDouble is null");
        } else {
            System.out.println("whenComplete aDouble is " + aDouble);
        }
        if (throwable == null) {
            System.out.println("whenComplete throwable is null");
        } else {
            System.out.println("whenComplete throwable is " + throwable.getMessage());
        }
    }).exceptionally((throwable) -&gt; {
        System.out.println("exceptionally中异常：" + throwable.getMessage());
        return 0.0;
    });

    System.out.println("最终返回的结果 = " + future.get());
}
</code></pre>
<p>当出现异常时，exceptionally 中会捕获该异常，给出默认返回值 0.0。</p>
<p>而 「whenComplete」 这个回调函数:</p>
<p>「正常完成」：whenComplete 返回结果和上级任务一致，异常为 null；<br>
「出现异常」：whenComplete 返回结果为 null，异常为上级任务的异常；</p>
<p>结果：</p>
<pre><code>whenComplete aDouble is null
whenComplete throwable is java.lang.RuntimeException: 出错了
exceptionally中异常：java.lang.RuntimeException: 出错了
最终返回的结果 = 0.0
</code></pre>
<h2 id="注意点">注意点</h2>
<h3 id="1future-需要获取返回值才能获取异常信息">1、Future 需要获取返回值，才能获取异常信息</h3>
<p>Future 需要获取返回值，才能获取到异常信息。如果不加 get()/join()方法，看不到异常信息。如果想要获取，考虑是否加 try...catch...或者使用 exceptionally 方法。</p>
<h3 id="2completablefuture-的-get方法是阻塞的">2、CompletableFuture 的 get()方法是阻塞的</h3>
<p>CompletableFuture 的 get()方法是阻塞的，如果使用它来获取异步调用的返回值，需要添加超时时间。</p>
<h3 id="3不建议使用默认线程池">3、不建议使用默认线程池</h3>
<p>CompletableFuture 代码中使用了默认的 「ForkJoin 线程池」， 处理的线程个数是电脑 「CPU 核数-1」 。在大量请求过来的时候，处理逻辑复杂的话，响应会很慢。一般建议使用自定义线程池，优化线程池配置参数。</p>
<h3 id="4自定义线程池时注意拒绝策略">4、自定义线程池时，注意拒绝策略</h3>
<p>如果线程池拒绝策略是 DiscardPolicy（丢弃当前任务） 或者 DiscardOldestPolicy（丢弃最旧的那个任务），当线程池饱和时，会直接丢弃任务，不会抛弃异常。因此建议，CompletableFuture 线程池策略最好使用 AbortPolicy（抛出执行异常）或者CallerRunsPolicy（让主线程执行）。</p>
<h2 id="结合业务代码使用示例">结合业务代码使用示例</h2>
<p>Util工具类</p>
<pre><code>public class CompletableFutureUtil {

    private CompletableFutureUtil(){}

    public static &lt;R&gt; CompletableFuture&lt;R&gt;  executeWithFallbackAndContextPropagation(@Nonnull Supplier&lt;R&gt; normalFunction,
                                                 @Nonnull Supplier&lt;R&gt; exceptionFunction,
                                                 @Nonnull ThreadPoolTaskExecutor taskExecutor,
                                                 @Nonnull String exceptionMsg){
        Thread mainThread = Thread.currentThread();
        return CompletableFuture
                .supplyAsync(normalFunction,taskExecutor)
                .exceptionally(e -&gt; {
                    log.error(exceptionMsg, e);
                    return exceptionFunction.get();
                })
                .whenComplete((data,e)-&gt;{
                    if(!mainThread.equals(Thread.currentThread())){
                        MallContextHolderManager.clearContext();
                    }
                });
    }
    
}
</code></pre>
<p>使用Util创建任务代码</p>
<pre><code class="language-java">    private CompletableFuture&lt;Boolean&gt; asyncQueryCommentPic(ProductDetailInfoNewDto detailInfoDto, ProductInfoQueryDTO productInfoQuery) {
        ThreadPoolTaskExecutor taskExecutor = bizThreadPoolManager.getBizThreadPoolTaskExecutor(BIZ_THREAD_POOL_NAME);
        // 兜底获取不到线程池时降级
        if (taskExecutor == null) {
            detailInfoDto.setShowPrimaryPic(Boolean.FALSE);
            return null;
        }
        return CompletableFutureUtil.executeWithFallbackAndContextPropagation(
                () -&gt; queryShowPrimaryPic(detailInfoDto, productInfoQuery),
                () -&gt; Boolean.FALSE,
                taskExecutor,
                "异步任务执行异常");
    }
</code></pre>
<p>获取任务结果代码</p>
<pre><code class="language-java">    private void handShowPrimaryPic(ProductDetailInfoNewDto detailInfoDto, CompletableFuture&lt;Boolean&gt; commentPicFuture) {
        detailInfoDto.setShowPrimaryPic(Boolean.FALSE);
        if (commentPicFuture != null) {
            try {
                Boolean showPrimaryPic = commentPicFuture.get(asyncGetCommentPrimaryPicTimeout, TimeUnit.MILLISECONDS);
                detailInfoDto.setShowPrimaryPic(showPrimaryPic);
            } catch (Exception e) {
                log.error("任务等待结果异常:future={}", JSON.toJSONString(commentPicFuture), e);
            }
        }
    }
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.09690140407986111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-06 22:03">2025-03-06 22:02</span>&nbsp;
<a href="https://www.cnblogs.com/ashuaiYiRen">异人程序员</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18756609" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18756609);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18756609', targetLink: 'https://www.cnblogs.com/ashuaiYiRen/p/18756609', title: '异步编程——CompletableFuture详解' })">举报</a>
</div>
        