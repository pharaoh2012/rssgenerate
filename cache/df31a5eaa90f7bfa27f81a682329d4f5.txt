
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-orchestration-concurrent" title="发布于 2025-07-14 08:30">
    <span role="heading" aria-level="2">多Agent协作入门：并发编排模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250712110837894-1988327330.png" alt="多Agent协作入门：并发编排模式" class="desc_img">
        传统的单Agent系统在处理复杂多面任务的能力方面受到较多限制，因此我们会有多Agent编排协作完成任务的需求。Semantic Kernel支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。本文介绍了Agent编排的概念以及Semantic Kernel支持的编排模式，最后通过一个案例介绍了如何实现一个并发编排模式，相信通过这个案例你能够有个感性的认识。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>大家好，我是Edison。</p>
<p><a class="normal_text_link" href="https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-orchestration-agentgroupchat" target="_blank" data-itemshowtype="0" data-linktype="2">上一篇</a>我们学习了Semantic Kernel中的AgentGroupChat实现群聊的效果，但其实多Agent协作编排还有一些其他的模式。今天就来和你唠唠其他支持的编排模式，每篇介绍一个，持续更新完。</p>
<h1><strong>SK支持哪些编排模式？</strong></h1>
<p>传统的单Agent系统在处理复杂多面任务的能力方面受到较多限制，因此我们会有多Agent编排协作完成任务的需求。Semantic Kernel支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。这些模式作为框架的一部分提供出来，我们可以自己扩展。</p>
<p>目前，Semantic Kernel支持以下编排模式：</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250712105907399-1999558913.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>上面所有的编排模式都基于统一的构造和接口来实现，它抽象了Agent通信、协调和结果聚合的复杂性，如下代码所示，只需选择不同的编排模式类即可：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 只需修改下面的编排模式类型即可
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> or ConcurrentOrchestration, GroupChatOrchestration, HandoffOrchestration, MagenticOrchestration, ...</span>
SequentialOrchestration orchestration = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">(agentA, agentB)
{
    LoggerFactory </span>= <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.LoggerFactory
};
InProcessRuntime runtime </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">();
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start the runtime</span>
<span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> runtime.StartAsync();
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Invoke the orchestration and get the result</span>
OrchestrationResult&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; result = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> orchestration.InvokeAsync(task, runtime);
</span><span style="color: rgba(0, 0, 255, 1)">string</span> text = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> result.GetValueAsync();
</span><span style="color: rgba(0, 0, 255, 1)">await</span> runtime.RunUntilIdleAsync();</pre>
</div>
<p>因此，我们无需学习新的API或重写Agent逻辑，可以专注于应用程序的编写，真的是很方便！</p>
<p>下面，我们就来看看第一种模式：并发编排。</p>
<h1><strong><span data-pm-slice="0 0 []">并发编排模式简介</span></strong></h1>
<p>并发模式使用多个Agent并行处理同一个任务，每个Agent都可以独立处理输入，并收集并聚合结果。此模式比较适合多种观点或解决方案很有价值的场景，比如集思广益、群体推理以及其他投票系统。</p>
<p>下图展示了多个Agent生成同一问题的不同解决方案，并收集其响应以进一步分析或选择：</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250712110029502-2132702591.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h1>实现并发编排模式</h1>
<p>这里我们来实现一个DEMO，定义两个Agent：Physicst（物理学大佬） 和 Chemist （化学大佬），它们可以对用户提出的同一个问题并行地进行思考并给出自己的解释。</p>
<p><span><span>为了简单地实现这个功能，我们创建一个.NET控制台项目，然后安装以下包：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">Microsoft.SemanticKernel.Agents.Core
Microsoft.SemanticKernel.Agents.OpenAI (Preview版本）
Microsoft.SemanticKernel.Agents.Orchestration (Preview版本）
Microsoft.SemanticKernel.Agents.Runtime.InProcess (Preview版本）</span></pre>
</div>
<p><span><span>需要注意的是，由于Semantic Kernel的较多功能目前还处于实验预览阶段，所以建议在该项目的csproj文件中加入以下配置，统一取消警告：</span></span></p>
<div class="cnblogs_code">
<pre>&lt;PropertyGroup&gt;
  &lt;NoWarn&gt;$(NoWarn);CA2007;IDE1006;SKEXP0001;SKEXP0110;OPENAI001&lt;/NoWarn&gt;
&lt;/PropertyGroup&gt;</pre>
</div>
<p><span><span>创建一个appsettings.json配置文件，填入以下关于LLM API的配置，其中API_KEY请输入你自己的：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">{
  </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: 
  {
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">BASE_URL</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">https://api.siliconflow.cn</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">API_KEY</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">******************************</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">MODEL_ID</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Qwen/Qwen2.5-32B-Instruct</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
  }
}</span></pre>
</div>
<p data-pm-slice="0 0 []"><span><span>这里我们使用SiliconCloud提供<span><span>的<span><span>&nbsp;<span><span class="code-snippet__string">Qwen2.5-32B-Instruct<span><span>&nbsp;<span><span>模型，你<span><span>可以通过这个URL注册账号：<span><span><a href="https://cloud.siliconflow.cn/i/DomqCefW" target="_blank" rel="noopener nofollow">https://cloud.siliconflow.cn/i/DomqCefW</a><span>&nbsp;获取大量免费的Token来进行本次实验。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-pm-slice="0 0 []"><span><span>有了LLM API，我们可以创建一个Kernel供后续使用，这也是老面孔了：</span></span></p>
<div class="cnblogs_code">
<pre>Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the configuration...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> config = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ConfigurationBuilder()
    .AddJsonFile($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">appsettings.json</span><span style="color: rgba(128, 0, 0, 1)">"</span>, optional: <span style="color: rgba(0, 0, 255, 1)">false</span>, reloadOnChange: <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
    .Build();
Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the chat client...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> chattingApiConfiguration = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenAiConfiguration(
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:MODEL_ID</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value,
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:BASE_URL</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value,
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:API_KEY</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> openAiChattingClient = <span style="color: rgba(0, 0, 255, 1)">new</span> HttpClient(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenAiHttpHandler(chattingApiConfiguration.EndPoint));
</span><span style="color: rgba(0, 0, 255, 1)">var</span> kernel =<span style="color: rgba(0, 0, 0, 1)"> Kernel.CreateBuilder()
    .AddOpenAIChatCompletion(chattingApiConfiguration.ModelId, chattingApiConfiguration.ApiKey, httpClient: openAiChattingClient)
    .Build();</span></pre>
</div>
<p><span><span><span><span>接下来，我们就一步一步地来看看核心的代码。</span></span></span></span></p>
<h1><span><span><span>定义两个Agent</span></span></span></h1>
<p><span><span><span><span>这里我们来定义两个Agent：Chemist &amp; Physicst</span></span></span></span></p>
<p><span><span><span><span>（1）<strong>Chemist</strong></span></span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> chemist = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent()
{
    Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">ChemistryExpert</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Instructions </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">You're an expert in chemistry, you can answer questions from a chemistry expert perspective.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Description </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Chemistry expert agent for answering questions in the perspective of a chemist.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Kernel </span>=<span style="color: rgba(0, 0, 0, 1)"> kernel
};</span></pre>
</div>
<p><span><span><span><span>（2）<strong>Physicst</strong></span></span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> physicist = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent()
{
    Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">PhysicsExpert</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Instructions </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">You're an expert in physics, you can answer questions from a physics expert perspective.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Description </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Physics expert agent for answering questions in the perspective of a physicst.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Kernel </span>=<span style="color: rgba(0, 0, 0, 1)"> kernel
};</span></pre>
</div>
<h1><span>选择编排模式</span></h1>
<p><span><span>这里我们选择的是并发编排模式：<span><span>ConcurrentOrchestration，将需要编排的两个Agent作为参数传递给它：</span></span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Set up the Concurrent Orchestration</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> orchestration = <span style="color: rgba(0, 0, 255, 1)">new</span> ConcurrentOrchestration(physicist, chemist);</pre>
</div>
<h1><span data-pm-slice="3 3 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;line-height: 1.75em; margin: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,null,&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]"><span data-pm-slice="1 1 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;margin: 8px;line-height: 1.75em;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;data-pm-slice&quot;:&quot;3 3 [\&quot;para\&quot;,{\&quot;tagName\&quot;:\&quot;section\&quot;,\&quot;attributes\&quot;:{\&quot;style\&quot;:\&quot;letter-spacing: 0.578px;text-align: left;\&quot;},\&quot;namespaceURI\&quot;:\&quot;http://www.w3.org/1999/xhtml\&quot;},\&quot;para\&quot;,{\&quot;tagName\&quot;:\&quot;p\&quot;,\&quot;attributes\&quot;:{\&quot;style\&quot;:\&quot;line-height: 1.75em; margin: 8px;\&quot;},\&quot;namespaceURI\&quot;:\&quot;http://www.w3.org/1999/xhtml\&quot;},\&quot;para\&quot;,null,\&quot;node\&quot;,{\&quot;tagName\&quot;:\&quot;span\&quot;,\&quot;attributes\&quot;:{\&quot;style\&quot;:null},\&quot;namespaceURI\&quot;:\&quot;http://www.w3.org/1999/xhtml\&quot;}]&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;font-style: normal;font-variant-ligatures: normal;font-variant-caps: normal;text-transform: none;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;text-align: left;margin-top: 8px;margin-bottom: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">启动运行时</span></span></h1>
<p><span><span>在Semantic Kernel中，需要运行时（Runtime）才能管理Agent的执行，因此这里我们需要在正式开始前使用InProcessRuntime并启动起来。</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start the Runtime</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> runtime = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> InProcessRuntime();
</span><span style="color: rgba(0, 0, 255, 1)">await</span> runtime.StartAsync();</pre>
</div>
<h1><span>调用编排 并 收集结果</span></h1>
<p><span><span>准备工作差不多了，现在我们可以开始调用编排了。编排任务时它会将任务广播到所有Agent中，并发运行多个Agent进行任务处理，最后收集每个Agent的处理结果。</span></span></p>
<p><span><span>这里的案例就是将用户的问题传给多个Agent并发思考并给出自己的回答。</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start the Chat</span>
Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">----------Agents are Ready. Let's Start Working!----------</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
{
    Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">User&gt; </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> input =<span style="color: rgba(0, 0, 0, 1)"> Console.ReadLine();
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">.IsNullOrWhiteSpace(input))
        </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
    input </span>=<span style="color: rgba(0, 0, 0, 1)"> input.Trim();
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (input.Equals(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">EXIT</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, StringComparison.OrdinalIgnoreCase))
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Stop the Runtime</span>
        <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> runtime.RunUntilIdleAsync();
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Invoke the Orchestration</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> result = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> orchestration.InvokeAsync(input, runtime);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Collect Results from multi Agents</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> output = <span style="color: rgba(0, 0, 255, 1)">await</span> result.GetValueAsync(TimeSpan.FromSeconds(<span style="color: rgba(128, 0, 128, 1)">10</span> * <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">));
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> texts = output.Select(text =&gt; $<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{text}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; texts.Count(); i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)"># RESULT {i+1}:{Environment.NewLine}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{texts.ElementAt(i).Trim()}{Environment.NewLine}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        }
    }
    </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (HttpOperationException ex)
    {
        Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Exception: {ex.Message}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }
    </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)">
    {
        Console.ResetColor();
        Console.WriteLine();
    }
}</span></pre>
</div>
<p>需要注意的是：上面的代码示例中我手动使用了一个for循环将收集到的结果进行显示，期望显示格式为RESULT 1, RESULT 2等。</p>
<h1><strong><span>效果展示</span></strong></h1>
<p>用户输入问题：<strong>What is temperature?</strong></p>
<p>NOTE：temperature中文意思为温度</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250712110455451-1389109340.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span data-pm-slice="3 3 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;line-height: 1.75em; margin: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,null,&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]"><span data-pm-slice="3 3 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;line-height: 1.75em; margin: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,null,&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">可以看到，Chemist 和 Physicst 两个Agent并行思考并给出了从自己的视角出发的对于温度这个概念的解释。</span></span></p>
<p><span data-pm-slice="3 3 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;line-height: 1.75em; margin: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,null,&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]"><span data-pm-slice="3 3 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;letter-spacing: 0.578px;text-align: left;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;line-height: 1.75em; margin: 8px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,null,&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;p&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;span&quot;,&quot;attributes&quot;:{&quot;style&quot;:null},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">因此，可以看出并发编排模式非常适合并行分析、独立子任务并集成决策的任务场景。</span></span></p>
<h1>小结</h1>
<p>本文介绍了Agent编排的概念以及Semantic Kernel支持的编排模式，最后通过一个案例介绍了如何实现一个并发编排模式，相信通过这个案例你能够有个感性的认识。</p>
<p>下一篇，我们将学习顺序编排模式，它按定义的顺序讲一个Agent的处理结果传递给下一个Agent，非常适合于工作流、管道、多阶段处理类任务。</p>
<h1>示例源码</h1>
<p>GitHub:&nbsp;<a href="https://github.com/EdisonTalk/MultiAgentOrchestration" target="_blank" rel="noopener nofollow">https://github.com/EdisonTalk/MultiAgentOrchestration</a></p>
<h1><strong><span data-pm-slice="1 1 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;data-content&quot;:&quot;[{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;dk8c-1652876793035\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;CmYV-1652876793036\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;Apache Kafka是一款\&quot;,\&quot;marks\&quot;:[]},{\&quot;text\&quot;:\&quot;开源的消息引擎系统\&quot;,\&quot;marks\&quot;:[{\&quot;type\&quot;:\&quot;bold\&quot;}]},{\&quot;text\&quot;:\&quot;。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;LkWc-1652879629260\&quot;,\&quot;name\&quot;:\&quot;image\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1,\&quot;url\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;width\&quot;:281,\&quot;height\&quot;:150,\&quot;style\&quot;:{\&quot;textAlign\&quot;:\&quot;center\&quot;}},\&quot;nodes\&quot;:[],\&quot;state\&quot;:{\&quot;renderSource\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;initialSize\&quot;:{\&quot;width\&quot;:281,\&quot;height\&quot;:148},\&quot;loading\&quot;:false}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;xh4n-1652876897909\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;3hx7-1652876897893\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。通俗来讲，就是系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}}]&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-align: left; margin-top: 16px; margin-bottom: 16px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;strong&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;caret-color: var(--weui-BRAND); letter-spacing: 0.034em;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">参考资料</span></strong></h1>
<p><span><span>Microsoft Learn:&nbsp;</span></span><a href="https://learn.microsoft.com/zh-cn/semantic-kernel/frameworks/agent/agent-orchestration?wt.mc_id=MVP_397012" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/semantic-kernel/frameworks/agent/agent-orchestration</a></p>
<h1>推荐学习</h1>
<p><span><span><span><span><span><span><span><span>圣杰：<span>《<a href="https://www.cnblogs.com/sheng-jie/p/18840383" target="_blank">.NET+AI | Semantic Kernel入门到精通</a>》</span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p style="text-align: center"><img src="https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg" alt="" style="width: 65%; border: 1px solid rgba(221, 221, 221, 1); border-radius: 3px; box-shadow: 0 4px 8px rgba(3, 27, 78, 0.12)"></p>
<div id="Copyright">
<p>作者：<span style="text-decoration: underline">爱迪生</span></p>
<p>出处：<a title="from" href="https://edisontalk.cnblogs.com" target="_blank">https://edisontalk.cnblogs.com</a></p>
<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>
</div>
</div>
<div id="MySignature" role="contentinfo">
    <div align="center"><a href="https://weibo.com/u/2068032061?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png"></a></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.01875" data-date-updated="2025-07-14 08:57">2025-07-14 08:30</span>&nbsp;
<a href="https://www.cnblogs.com/edisontalk">EdisonZhou</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18980316);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18980316', targetLink: 'https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-orchestration-concurrent', title: '多Agent协作入门：并发编排模式' })">举报</a>
</div>
        