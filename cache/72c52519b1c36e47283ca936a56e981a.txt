
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18920751" title="发布于 2025-06-09 15:13">
    <span role="heading" aria-level="2">[Java/Python] Java 基于命令行调用 Python</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="需求描述">需求描述</h1>
<ul>
<li>利用 Java 基于命令行调用 Python</li>
</ul>
<h1 id="实现步骤">实现步骤</h1>
<h2 id="安装-python--pip-环境">安装 Python + PIP 环境</h2>
<blockquote>
<p>以基于 Ubuntu 24 的 Docker 环境为例</p>
</blockquote>
<ul>
<li>Dockerfile</li>
</ul>
<pre><code class="language-shell"># OS: Ubuntu 24.04
FROM swr.cn-north-4.myhuaweicloud.com/xxx/eclipse-temurin:17-noble
 
COPY ./target/*.jar /app.jar
COPY ./target/classes/xxx/ /xxx/

# install : python + pip (前置操作: 更新 apt 源)
RUN sed -i 's#http[s]*://[^/]*#http://mirrors.aliyun.com#g' /etc/apt/sources.list \
  &amp;&amp; apt-get update \
  &amp;&amp; apt-get -y install vim \
  &amp;&amp; apt-get -y install --no-install-recommends python3 python3-pip python3-venv \
  &amp;&amp; python3 -m venv $HOME/.venv \
  &amp;&amp; . $HOME/.venv/bin/activate \ # 注：Linux 中 高版本 Python (3.5以上)，必须在虚拟环境下方可正常安装所需依赖包
  &amp;&amp; pip install -i https://mirrors.aliyun.com/pypi/simple/ can cantools
#   &amp;&amp; echo "alias python=python3" &gt;&gt; ~/.bashrc \ # Java程序的子进程调用中试验：未此行命令未生效；但开发者独自登录 docker 容器内，有生效
#   &amp;&amp; echo '. $HOME/.venv/bin/activate' &gt;&gt; ~/.bashrc \ # Java程序的子进程调用中试验：未此行命令未生效；但开发者独自登录 docker 容器内，有生效
#   &amp;&amp; echo 'export PYTHON=$HOME/.venv/bin/python' &gt;&gt; /etc/profile \ # Java程序的子进程调用中试验：未此行命令未生效；但开发者独自登录 docker 容器内，有生效

#  &amp;&amp; echo '. /etc/profile' &gt; $HOME/app.sh \ # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉
#  &amp;&amp; echo 'java ${JAVA_OPTS:-} -jar app.jar &gt; /dev/null 2&gt;&amp;1 &amp;' &gt;&gt; $HOME/app.sh \  # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉
#  &amp;&amp; echo 'java ${JAVA_OPTS:-} -jar app.jar' &gt;&gt; $HOME/app.sh \  # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉
#  &amp;&amp; chmod +x $HOME/app.sh \  # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉
#  &amp;&amp; chown 777 $HOME/app.sh  # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉

EXPOSE 8080

# ENTRYPOINT exec sh $HOME/app.sh # Java程序的子进程调用中试验：未测通，有衍生问题未解决掉
ENTRYPOINT exec java ${JAVA_OPTS:-} -DPYTHON=$HOME/.venv/bin/python -jar app.jar # 通过 Java 获取 JVM 参数（ System.getProperty("PYTHON") ） 方式获取 【 Python 可执行文件的绝对路径】的值
</code></pre>
<h2 id="编写和准备-python-业务脚本">编写和准备 Python 业务脚本</h2>
<ul>
<li>
<p>step1 编写 Python 业务脚本 （略）</p>
</li>
<li>
<p>step2 如果 Python 脚本在 JAVA 工程内部（JAR包内），则需在 执行 Python 脚本前，将其提前拷贝为一份新的脚本文件到指定位置。</p>
</li>
</ul>
<pre><code class="language-shell">public XXX {
    private static String scriptFilePath;
    public static String TMP_DIR = "/tmp/xxx-sdk/";
	
	static {
        prepareHandleScript( TMP_DIR );
	}

    /**
     *  准备脚本文件到目标路径
     * @note 无法直接执行 jar 包内的脚本文件，需要拷贝出来。
     * @param targetScriptDirectory 目标脚本的文件夹路径
     *     而非脚本文件路径 eg: "/tmp/xxx-sdk"
     */
    @SneakyThrows
    public static void prepareHandleScript(String targetScriptDirectory){
        File file = new File(targetScriptDirectory);
        //如果目标目录不存在，则创建该目录
        if (!file.exists() &amp;&amp; !file.isDirectory()) {
            file.mkdirs();
        }
        File targetScriptFile = new File(targetScriptDirectory + "/xxx-converter.py");// targetScriptFile = "\tmp\xxx-sdk\xxx-converter.py"
        scriptFilePath = targetScriptFile.getAbsolutePath(); // scriptFilePath = "D:\tmp\xxx-sdk\xxx-converter.py"

        URL resource = CanAscLogGenerator.class
            .getClassLoader()
            .getResource( "bin/xxx-converter.py");

        InputStream converterPythonScriptInputStream = null;
        try {
            converterPythonScriptInputStream = resource.openStream();
            FileUtils.copyInputStreamToFile( converterPythonScriptInputStream, targetScriptFile );
        } catch (IOException exception){
            log.error("Fail to prepare the script!targetScriptDirectory:{}, exception:", targetScriptDirectory, exception);
            throw new RuntimeException(exception);
        } finally {
            if(converterPythonScriptInputStream != null){
                converterPythonScriptInputStream.close();
            }
        }
    }
}
</code></pre>
<h2 id="java-调用-python-脚本">Java 调用 Python 脚本</h2>
<h3 id="关键点程序阻塞问题">关键点：程序阻塞问题</h3>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250609152339642-1663843969.png" alt="" loading="lazy"></p>
<ul>
<li>推荐文献</li>
</ul>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/fpqi/p/9679039.html" target="_blank">执行Runtime.exec()需要注意的陷阱 - 博客园</a> 【推荐】</li>
</ul>
<blockquote>
<p>程序阻塞问题</p>
</blockquote>
</blockquote>
<ul>
<li>
<p>通过 Process实例.getInputStream() 和 Process实例.getErrorStream() 获取的<strong>输入流</strong>和<strong>错误信息流</strong>是<strong>缓冲池</strong>向当前Java程序提供的，而不是直接获取外部程序的标准输出流和标准错误流。</p>
</li>
<li>
<p>而<strong>缓冲池的容量</strong>是一定的。</p>
</li>
</ul>
<blockquote>
<p>因此，若<strong>外部程序</strong>在运行过程中不断向<strong>缓冲池</strong>输出内容，当<strong>缓冲池</strong>填满，那么： <strong>外部程序</strong>将<strong>暂停运行</strong>直到<strong>缓冲池</strong>有空位可接收外部程序的输出内容为止。（<br>
注：采用xcopy命令复制大量文件时将会出现该问题</p>
</blockquote>
<ul>
<li>解决办法： 当前的Java程序不断读取缓冲池的内容，从而为腾出缓冲池的空间。</li>
</ul>
<pre><code class="language-java">Runtime r = Runtime.getRuntime();
try {
    Process proc = r.exec("cmd /c dir"); // 假设该操作为造成大量内容输出
  	// 采用字符流读取缓冲池内容，腾出空间
  	BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream(), "gbk")));
  	String line = null;
  	while ((line = reader.readLine()) != null){
  	   System.out.println(line);
  	}
 	
  	/* 或采用字节流读取缓冲池内容，腾出空间
  	 ByteArrayOutputStream pool = new ByteArrayOutputStream();
  	 byte[] buffer = new byte[1024];
  	 int count = -1;
  	 while ((count = proc.getInputStream().read(buffer)) != -1){
  	   pool.write(buffer, 0, count);
  	   buffer = new byte[1024];
  	 }
  	 System.out.println(pool.toString("gbk"));
  	 */
 	
  	int exitVal = proc.waitFor();
  	System.out.println(exitVal == 0 ? "成功" : "失败");
} catch(Exception e){
  	e.printStackTrace();
}
</code></pre>
<ul>
<li>注意：外部程序在执行结束后需<strong>自动关闭</strong>；否则，不管是字符流还是字节流均由于既读不到数据，又读不到流结束符，从而出现<strong>阻塞Java进程运行</strong>的情况。</li>
</ul>
<blockquote>
<p><code>cmd</code>的参数 “<code>/c</code>” 表示<strong>当命令执行完成后关闭自身</strong>。</p>
</blockquote>
<h3 id="关键点-java-runtimeexec-方法">关键点： Java <code>Runtime.exec()</code> 方法</h3>
<h4 id="基本方法-runtimeexec">基本方法: <code>Runtime.exec()</code></h4>
<ul>
<li>首先，在Linux系统下，使用Java调用Python脚本，传入参数，需要使用<code>Runtime.exec()</code>方法</li>
</ul>
<blockquote>
<p>即 在<code>java</code>中使用<code>shell</code>命令</p>
</blockquote>
<blockquote>
<p>这个方法有两种使用形式：</p>
<ul>
<li>方式1 <strong>无参数传入</strong> ，直接执行Linux相关命令： <code>Process process = Runtime.getRuntime().exec(String cmd);</code></li>
</ul>
<blockquote>
<p>无参数可以直接传入字符串，如果需要传参数，就要用方式2的字符串数组实现。</p>
</blockquote>
<ul>
<li>方式2 <strong>有参数传入</strong>，并执行Linux命令： <code>Process process = Runtime.getRuntime().exec(String[] cmd);</code></li>
</ul>
</blockquote>
<h4 id="执行结果">执行结果</h4>
<ul>
<li>使用<code>exec</code>方法执行命令，如果需要执行的结果，用如下方式得到：</li>
</ul>
<pre><code class="language-java">	String line;
    while ((line = processInputStream.readLine()) != null) { // InputStream processInputStream = process.getInputStream();
    	System.out.println(line);
         if ("".equals(line)) {
               break;
          }
    }
    System.out.println("line ----&gt; " + line);
</code></pre>
<h4 id="查看错误信息">查看错误信息</h4>
<pre><code class="language-java">	BufferedReader errorResultReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
	String errorLine;
	while ((errorLine = shellErrorResultReader.readLine()) != null) {
    	System.out.println("errorStream:" + errorLine);
    }
    int exitCode = process.waitFor();
    System.out.println("exitCode:" + exitCode);
</code></pre>
<h4 id="简单示例">简单示例</h4>
<pre><code class="language-java">	String result = "";
	String[] cmd = new String [] { "pwd" };
	Process process = Runtime.getRuntime().exec(cmd);
	InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream());
	LineNumberReader input = new LineNumberReader(inputStreamReader);
	result = input.readLine();
	System.out.println("result:" + result);
</code></pre>
<h3 id="关键点-python-绝对路径">关键点： python 绝对路径</h3>
<ul>
<li>查看python使用的路径，然后在Java调用的时候写出绝对路径。</li>
</ul>
<blockquote>
<p>以解决 Linux 环境中的 Python 3.X 的<strong>虚拟环境</strong>异常问题(<code>pip install XXX : error: externally-managed-environment</code>)。<br>
<a href="https://www.cnblogs.com/johnnyzen/p/18920448" target="_blank">Python 虚拟环境管理 - 博客园/千千寰宇</a></p>
</blockquote>
<blockquote>
<p><code>Cannot run program “python“: error=2, No such file or director</code> (因虚拟环境问题，找不到python命令和pip安装的包)</p>
</blockquote>
<h3 id="java-调用-python-的实现-必读">Java 调用 Python 的实现 （必读）</h3>
<pre><code class="language-java">@Slf4j
public class XxxxGenerator implements IGenerator&lt;XxxxSequenceDto&gt; {
    //python jvm 变量 (`-DPYTHON=$HOME/.venv/bin/python`)
    public static String PYTHON_VM_PARAM = "PYTHON";//System.getProperty(PYTHON_VM_PARAM)
    //python 环境变量名称 //eg: "export PYTHON=$HOME/.venv/bin/python" , pythonEnv="$HOME/.venv/bin/python"
    public static String PYTHON_ENV_PARAM = "PYTHON";//;System.getenv(PYTHON_ENV_PARAM);
    private static String PYTHON_COMMAND ;
    //默认的 python 命令
    private static String PYTHON_COMMAND_DEFAULT = "python";
	
	//...
 
    static {
        PYTHON_COMMAND = loadPythonCommand();
        log.info("PYTHON_COMMAND:{}, PYTHON_VM:{}, PYTHON_ENV:{}", PYTHON_COMMAND, System.getProperty(PYTHON_VM_PARAM), System.getenv(PYTHON_ENV_PARAM) );
		
		//...
    }
 
    /**
     * 加载 python 命令的可执行程序的路径
     * @note
     *   Linux 中，尤其是 高版本 Python(3.x) ，为避免 Java 通过 `Runtime.getRuntime().exec(args)` 方式 调用 Python 命令时，报找不到 可执行程序(`Python` 命令)\
     *   ————建议： java 程序中使用的 `python` 命令的可执行程序路径，使用【绝对路径】
     * @return
     */
    private static String loadPythonCommand(){
        String pythonVm = System.getProperty(PYTHON_VM_PARAM);
        String pythonEnv = System.getenv(PYTHON_ENV_PARAM);
        String pythonCommand = pythonVm != null?pythonVm : pythonEnv;
        pythonCommand = pythonCommand != null?pythonCommand : PYTHON_COMMAND_DEFAULT;
        return pythonCommand;
    }
 
 
    /**
     * 业务方法： CAN ASC LOG 转 BLF
     * @param ascLogFilePath
     * @param blfFilePath
     */
    protected void convertToBlf(File ascLogFilePath, File blfFilePath){
        //CanAsclogBlfConverterScriptPath = "/D:/Workspace/CodeRepositories/xxx-platform/xxx-sdk/xxx-sdk-java/target/classes/bin/can-asclog-blf-converter.py"
        //String CanAsclogBlfConverterScriptPath = CanAscLogGenerator.class.getClassLoader().getResource("bin/can-asclog-blf-converter.py").getPath();
 
        String canAscLogBlfConverterScriptPath = XxxxGenerator.scriptFilePath;//python 业务脚本的文件路径， eg: "D:\tmp\xxx-sdk\can-asclog-blf-converter.py"
 
        //String [] args = new String [] {"python", "..\\bin\\can-asclog-blf-converter.py", "-i", ascLogFilePath, "-o", blfFilePath};// ascLogFilePath="/tmp/xxx-sdk/can-1.asc" , blfFilePath="/tmp/xxx-sdk/can-1.blf"
        String [] args = new String [] { PYTHON_COMMAND, canAscLogBlfConverterScriptPath, "-i", ascLogFilePath.getPath(), "-o", blfFilePath.getPath()};
        log.info("args: {} {} {} {} {} {}", args);
        Process process = null;
        Long startTime = System.currentTimeMillis();
        try {
            process = Runtime.getRuntime().exec(args);
            Long endTime = System.currentTimeMillis();
            log.info("Success to convert can asc log file to blf file!ascLogFile:{}, blfFile:{}, timeConsuming:{}ms, pid:{}", ascLogFilePath, blfFilePath, endTime - startTime, process.pid());
        } catch (IOException exception) {
            log.error("Fail to convert can asc log file to blf file!ascLogFile:{}, blfFile:{}, exception:", ascLogFilePath, blfFilePath,  exception);
            throw new RuntimeException(exception);
        }
 
        //读取 python 脚本的标准输出
        // ---- input stream ----
        List&lt;String&gt; processOutputs = new ArrayList&lt;&gt;();
        try(
            InputStream processInputStream = process.getInputStream();
            BufferedReader processReader = new BufferedReader( new InputStreamReader( processInputStream ));
        ) {
            Long readProcessStartTime = System.currentTimeMillis();
            String processLine = null;
            while( (processLine = processReader.readLine()) != null ) {
                processOutputs.add( processLine );
            }
            process.waitFor();
            Long readProcessEndTime = System.currentTimeMillis();
            log.info("Success to read the can asc log to blf file's process standard output!timeConsuming:{}ms", readProcessEndTime - readProcessStartTime );
            log.info("processOutputs(System.out):{}", JSON.toJSONString( processOutputs ));
        } catch (IOException exception) {
            log.error("Fail to get input stream!IOException:", exception);
            throw new RuntimeException(exception);
        } catch (InterruptedException exception) {
            log.error("Fail to wait for the process!InterruptedException:{}", exception);
            throw new RuntimeException(exception);
        }
 
        // ---- error stream ----
        List&lt;String&gt; processErrors = new ArrayList&lt;&gt;();
        try(
            InputStream processInputStream = process.getErrorStream();
            BufferedReader processReader = new BufferedReader( new InputStreamReader( processInputStream ));
        ) {
            Long readProcessStartTime = System.currentTimeMillis();
            String processLine = null;
            while( (processLine = processReader.readLine()) != null ) {
                processErrors.add( processLine );
            }
            process.waitFor();
            Long readProcessEndTime = System.currentTimeMillis();
            log.error("Success to read the can asc log to blf file's process standard output!timeConsuming:{}ms", readProcessEndTime - readProcessStartTime );
            log.error("processOutputs(System.err):{}", JSON.toJSONString( processOutputs ));
        } catch (IOException exception) {
            log.error("Fail to get input stream!IOException:", exception);
            throw new RuntimeException(exception);
        } catch (InterruptedException exception) {
            log.error("Fail to wait for the process!InterruptedException:{}", exception);
            throw new RuntimeException(exception);
        }
        if( processErrors.size() &gt; 0 ) {
            throw new RuntimeException( "convert to blf failed!\nerrors:" + JSON.toJSONString(processErrors) );
        }
    }
}
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li>
<p><a href="https://www.cnblogs.com/johnnyzen/p/18649006" target="_blank">[Python] 包管理器Pip - 博客园/千千寰宇</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/johnnyzen/p/18383840" target="_blank">[Python] Python 基础教程 - 博客园/千千寰宇</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/johnnyzen/p/18920448" target="_blank">Python 虚拟环境管理 - 博客园/千千寰宇</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/fpqi/p/9679039.html" target="_blank">执行Runtime.exec()需要注意的陷阱 - 博客园</a> 【推荐】</p>
</li>
</ul>
<blockquote>
<p>程序阻塞问题</p>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://blog.csdn.net/nhx900317/article/details/118017622" target="_blank" rel="noopener nofollow">解决Linux环境使用Java调用Python脚本的问题 - CSDN</a> 【推荐】</li>
</ul>
<blockquote>
<p>在Java调用的时候写出绝对路径: <code>String[] cmd = {"/root/miniconda3/bin/python", "/home/test.py"};</code></p>
</blockquote>
<ul>
<li>
<p><a href="https://blog.csdn.net/footless_bird/article/details/116274515" target="_blank" rel="noopener nofollow">java调用外部程序（Runtime.getRuntime().exec）详解 - CSDN</a> 【推荐】</p>
</li>
<li>
<p><a href="https://blog.csdn.net/u011250186/article/details/112253086" target="_blank" rel="noopener nofollow">yarn上报错Cannot run program “python“: error=2, No such file or directory</a></p>
</li>
</ul>
<blockquote>
<p><code>Cannot run program “python“: error=2, No such file or director</code>  (因虚拟环境问题，找不到python命令和pip安装的包)</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02277721910763889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-09 15:50">2025-06-09 15:13</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18920751);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18920751', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18920751', title: '[Java/Python] Java 基于命令行调用 Python' })">举报</a>
</div>
        