
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18626670" title="发布于 2024-12-24 09:50">
    <span role="heading" aria-level="2">『玩转Streamlit』--集成Plotly</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>之前介绍了如何在<code>Streamlit App</code>中使用<code>Matplotlib</code>库来绘图。</p>
<p>本篇介绍 <code>Steamlit</code>结合<code>Poltly</code>的方法，相比于<code>Matplotlib</code>，<code>Poltly</code>的交互性更强，</p>
<p>更适合在<code>Web</code>应用中做为可视化的工具。</p>
<h1 id="1-stplotly_chart函数">1. st.plotly_chart函数</h1>
<p><code>st.plotly_chart</code>函数专门用于在<code>Steamlit</code>应用中显示 <code>Plotly</code> 绘制的图形。</p>
<p>这个函数能够直接将<strong>Plotly Figure对象</strong>或者<strong>Poltly支持的数据对象</strong>直接渲染到页面的指定位置上。</p>
<p><code>st.plotly_chart</code>的参数不多，与<code>st.pyplot</code>比，多了一些交互用的参数：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>figure_or_data</td>
<td>Figure或Data对象</td>
<td></td>
</tr>
<tr>
<td>theme</td>
<td>str</td>
<td>指定图表的主题</td>
</tr>
<tr>
<td>use_container_width</td>
<td>bool</td>
<td>决定是否使用父容器的宽度覆盖图形的原始宽度</td>
</tr>
<tr>
<td>key</td>
<td>str</td>
<td>为元素提供标识</td>
</tr>
<tr>
<td>on_select</td>
<td>str</td>
<td>控制图表如何响应用户选择事件</td>
</tr>
<tr>
<td>selection_mode</td>
<td>str</td>
<td>图表的选择模式</td>
</tr>
</tbody>
</table>
<p>因为<code>Plotly</code>绘制的图形可交互，通过<code>key</code>参数，在交互的过程中，我们可以精确地定位到交互的图表。</p>
<p><code>on_select</code>参数有以下几种取值：</p>
<ol>
<li><code>ignore</code>：不对图表中的任何选择事件做出反应</li>
<li><code>rerun</code>：在图表中选择数据时，会重新运行应用程序</li>
<li><code>可调用对象****</code>：会重新运行应用程序，并在应用程序的其余部分之前执行该可调用对象作为回调函数</li>
</ol>
<p><code>selection_mode</code>参数定义图表的选择模式，包括：</p>
<ol>
<li><code>points</code>：允许基于单个数据点进行选择</li>
<li><code>box</code>：允许基于矩形区域进行选择</li>
<li><code>lasso</code>：允许基于自由绘制区域进行选择</li>
</ol>
<p><code>on_select</code>不同时，页面的效果如下：</p>
<h2 id="11-on_selectignore">1.1. on_select=ignore</h2>
<p><code>ignore</code>是<code>on_select</code>的默认值，此时<code>Plotly</code>图形上无法选择对象。</p>
<pre><code class="language-python">import streamlit as st
import plotly.express as px

df = px.data.iris()
fig = px.scatter(df, x="sepal_width", y="sepal_length")


st.plotly_chart(fig, key="iris")
# 或者
# st.plotly_chart(fig, key="iris", on_select="ignore")
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202412/83005-20241224094257606-1732212876.png" alt="" loading="lazy"></p>
<p>此时，工具栏上没有选择数据的小工具。</p>
<h2 id="12-on_selectrerun">1.2. on_select=rerun</h2>
<p>此时，<code>st.plotly_chart</code>会将选择的数据点返回。</p>
<p>选择数据点时，可以切换成<strong>矩形选择</strong>和<strong>自由区域</strong>选择。</p>
<pre><code class="language-python">event = st.plotly_chart(fig, key="iris", on_select="rerun")
event
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202412/83005-20241224094257671-870221187.gif" alt="" loading="lazy"></p>
<h2 id="13-on_selectcallable">1.3. on_select=callable</h2>
<p><code>on_select=callable</code>的效果<code>on_select=rerun</code>差不多，也能对数据点选择并得到选择的数据点。</p>
<p>不同之处在于，可以在选择数据点之后，调用<code>callable</code>函数进行额外的处理。</p>
<pre><code class="language-python">def handle_selection():
    from datetime import datetime

    st.write(f"Selected data at {datetime.now()}")


event = st.plotly_chart(fig, key="iris", on_select=handle_selection)
event
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202412/83005-20241224094257640-1551295950.gif" alt="" loading="lazy"></p>
<p>每次选择数据之后，上面的时间都会变化，说明<code>handle_selection</code>函数在每次选择数据之后都被回调。</p>
<h1 id="2-使用示例">2. 使用示例</h1>
<p>下面通过示例演示实际场景中如何使用<code>streamlit</code>和<code>Poltly</code>图表。</p>
<h2 id="21-销售数据时间序列分析">2.1. 销售数据时间序列分析</h2>
<p>在这个示例中，首先创建了一个模拟的销售数据时间序列，然后通过st.plotly_chart展示图表，并设置<code>on_select</code>回调函数来处理用户在图表上的选择操作。</p>
<p>当用户选择图上的点时，会在 <code>Streamlit</code> 应用中显示所选数据点对应的日期和销售额信息。</p>
<pre><code class="language-python">import streamlit as st
import plotly.express as px
import pandas as pd

# 模拟销售数据
data = {
    "Date": pd.date_range(start="2024-01-01", periods=100),
    "Sales": [i**2 + 50 + 10 * (i % 10) for i in range(100)],
}
df = pd.DataFrame(data)

# 创建时间序列折线图
fig = px.scatter(df, x="Date", y="Sales")


# 显示图表并处理选择事件
def handle_selection():
    selected_points = st.session_state["sales_chart"].selection.points
    st.write("已选择的数据点:")
    df = pd.DataFrame(columns=["日期", "销售额"])

    for idx, p in enumerate(selected_points):
        df.loc[idx, "日期"] = p["x"]
        df.loc[idx, "销售额"] = p["y"]

    st.dataframe(df)


st.plotly_chart(fig, key="sales_chart", on_select=handle_selection)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202412/83005-20241224094257660-1429341930.gif" alt="" loading="lazy"></p>
<h2 id="22-模拟股票分析">2.2. 模拟股票分析</h2>
<p>使用<code>generate_stock_data</code>函数生成模拟的股票数据，再使用<code>plotly.graph_objects</code>创建一个烛台图，将模拟数据绘制到图表中。</p>
<p>编写一个回调函数，当用户在图表上选择某个点时，它会获取所选点的详细信息并在 <code>Streamlit</code> 应用中展示出来。</p>
<pre><code class="language-python">import streamlit as st
import plotly.graph_objects as go
import pandas as pd
import numpy as np


# 生成随机模拟的股票数据
def generate_stock_data(days=300):
    dates = pd.date_range(start="2024-01-01", periods=days)
    open_prices = np.random.rand(days) * 100 + 50
    high_prices = open_prices + np.random.rand(days) * 10
    low_prices = open_prices - np.random.rand(days) * 10
    close_prices = open_prices + np.random.randn(days) * 5

    data = {
        "Date": dates,
        "Open": open_prices,
        "High": high_prices,
        "Low": low_prices,
        "Close": close_prices,
    }
    return pd.DataFrame(data)


# 生成模拟股票数据
df = generate_stock_data()

# 创建交互式图表
fig = go.Figure(
    data=[
        go.Candlestick(
            x=df["Date"],
            open=df["Open"],
            high=df["High"],
            low=df["Low"],
            close=df["Close"],
        )
    ]
)

fig.update_layout(title="模拟股票价格", xaxis_title="Date", yaxis_title="Price")


# onselect 回调函数
def handle_selection():
    selected_points = st.session_state.stock_chart.selection.points
    st.write("Selected Stock Data Points:")

    df = pd.DataFrame(columns=["日期", "开盘价", "收盘价", "最高价", "最低价"])

    for idx, p in enumerate(selected_points):
        print(idx, p)
        df.loc[idx, "日期"] = p["x"]
        df.loc[idx, "开盘价"] = p["open"]
        df.loc[idx, "收盘价"] = p["close"]
        df.loc[idx, "最高价"] = p["high"]
        df.loc[idx, "最低价"] = p["low"]

    st.dataframe(df)


# 显示图表
st.plotly_chart(fig, key="stock_chart", on_select=handle_selection)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202412/83005-20241224094257635-501595836.gif" alt="" loading="lazy"></p>
<h1 id="3-总结">3. 总结</h1>
<p><code>Streamlit</code> 可以简化 <code>Web</code> 应用构建流程，<code>Plotly</code> 提供丰富图表类型，二者结合能快速将数据转化为交互式可视化应用，节省开发时间。</p>
<p>此外，<code>Plotly</code> 图表交互性高，在 <code>Streamlit</code> 应用中可实现数据探索、筛选等操作，增强用户体验。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03891709156712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-24 09:50">2024-12-24 09:50</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18626670" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18626670);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18626670', targetLink: 'https://www.cnblogs.com/wang_yb/p/18626670', title: '『玩转Streamlit』--集成Plotly' })">举报</a>
</div>
        