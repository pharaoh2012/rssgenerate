
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wanglli/p/18778857" title="发布于 2025-03-18 14:18">
    <span role="heading" aria-level="2">DCL（Double-checked Locking双重校验锁）实现单例模式的原理、问题与解决方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<span data-cke-copybin-start="1"><span data-cke-copybin-start="1"><span data-cke-copybin-start="1">​</span></span></span>
<div class="cnblogs_code">
<pre>好的，要深入理解DCL（Double-<span style="color: rgba(0, 0, 0, 1)">Checked Locking）双重校验锁的原理、问题以及解决方法。
首先，我需要回忆一下单例模式的基本概念，因为DCL通常用于实现单例模式。
单例模式确保一个类只有一个实例，并提供一个全局访问点。

接下来，DCL的目的是为了减少同步的开销。通常，如果直接在getInstance方法上加synchronized关键字，
虽然能保证线程安全，但每次获取实例时都需要同步，这在多线程环境下可能会影响性能。
而DCL通过两次检查实例是否已经创建，来避免每次调用都进行同步，只在第一次创建实例的时候同步。

现在，我需要想一下DCL的标准写法。大概是这样的：

</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Singleton {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> Singleton instance; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 必须使用 volatile</span>
    
    <span style="color: rgba(0, 0, 255, 1)">private</span> Singleton() {} <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 私有构造函数</span>
    
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> Singleton getInstance() {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (instance == <span style="color: rgba(0, 0, 255, 1)">null</span>) {                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第一次检查（避免不必要的同步）</span>
            <span style="color: rgba(0, 0, 255, 1)">synchronized</span> (Singleton.<span style="color: rgba(0, 0, 255, 1)">class</span>) {    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 同步块</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (instance == <span style="color: rgba(0, 0, 255, 1)">null</span>) {         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第二次检查（确保唯一实例）</span>
                    instance = <span style="color: rgba(0, 0, 255, 1)">new</span> Singleton(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 实例化</span>
<span style="color: rgba(0, 0, 0, 1)">                }
            }
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> instance;
    }
}


不过，这种写法在早期的Java中存在问题，主要涉及到指令重排序的问题。
因为instance </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Singleton(); 这个操作并不是原子性的，它分为三个步骤：

</span>1<span style="color: rgba(0, 0, 0, 1)">. 分配内存空间
</span>2<span style="color: rgba(0, 0, 0, 1)">. 初始化对象
</span>3<span style="color: rgba(0, 0, 0, 1)">. 将instance指向分配的内存地址

但由于指令重排序的可能，步骤2和步骤3可能会被颠倒，导致其他线程在第一次检查时看到instance不为null，但实际上对象还没有初始化完成，从而访问到一个不完整的对象。

为了解决这个问题，Java 5之后引入了volatile关键字，可以禁止指令重排序，
确保写操作之前的操作不会被重排序到写操作之后。因此，正确的DCL实现需要将instance声明为volatile：

</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">volatile</span><span style="color: rgba(0, 0, 0, 1)"> Singleton instance;

这样，使用volatile修饰instance变量，就能保证在instance被初始化完成之后，
其他线程才能看到它的值，从而避免了指令重排序带来的问题。
不过，需要确认一下volatile在Java内存模型中的具体作用。volatile关键字主要有两个作用：

</span>1<span style="color: rgba(0, 0, 0, 1)">. 可见性：保证变量的修改对所有线程立即可见。
</span>2<span style="color: rgba(0, 0, 0, 1)">. 禁止指令重排序：通过插入内存屏障，确保编译器和处理器不会对指令进行重排序。

在DCL中，主要是利用了volatile的第二个特性，即禁止指令重排序，确保对象的初始化在赋值操作之后完成。
另外，我还需要思考其他实现单例模式的方式，
比如静态内部类的方式，或者枚举方式，这些方式是否更简单且线程安全。

静态内部类的实现方式：
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Singleton {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> Singleton() {}

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Holder {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Singleton INSTANCE = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Singleton();
    }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> Singleton getInstance() {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> Holder.INSTANCE; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 类加载时初始化，由 JVM 保证线程安全</span>
<span style="color: rgba(0, 0, 0, 1)">    }
}

这种方式利用了类加载机制，保证在首次访问Holder.INSTANCE时才会加载Holder类，
从而初始化Singleton实例，由JVM保证线程安全。
这种方法不需要显式的同步，且实现简单，但可能无法应对反射攻击或者序列化的问题。

枚举方式：
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">enum</span><span style="color: rgba(0, 0, 0, 1)"> Singleton {
    INSTANCE;
}

这种方式由JVM保证实例的唯一性和线程安全，且能防止反射和序列化破坏单例，是最推荐的方式，
但可能不够灵活，比如无法继承其他类。

回到DCL，虽然它在某些情况下仍然有用，但需要正确使用volatile关键字。
还需要验证一下如果不使用volatile是否一定会出现问题，以及这种问题发生的条件。

比如，在Java 5之前，DCL确实是不安全的，因为volatile关键字的语义不够严格，
无法完全禁止指令重排序。而在Java 5之后，JSR</span>-<span style="color: rgba(0, 0, 0, 1)">133增强了volatile的内存语义，确保了DCL的正确性。

另外，我还需要了解内存屏障的概念，以及volatile如何通过内存屏障来禁止重排序。
比如，在写操作之后插入StoreStore屏障，防止写操作之前的指令被重排序到写操作之后；
在读操作之前插入LoadLoad屏障，防止读操作之后的指令被重排序到读操作之前。

总结一下，DCL的正确实现需要注意以下几点：

</span>1<span style="color: rgba(0, 0, 0, 1)">. 使用双重检查来减少同步的开销。
</span>2<span style="color: rgba(0, 0, 0, 1)">. 使用volatile关键字来禁止指令重排序，保证实例的可见性和初始化顺序。
</span>3<span style="color: rgba(0, 0, 0, 1)">. 确保构造函数是私有的，防止外部实例化。

可能的误区是认为只要两次检查就能保证线程安全，而忽略了指令重排序的问题。
因此，volatile的使用是必不可少的。

最后，我需要思考在实际开发中，是否应该优先选择其他单例实现方式，
如枚举或静态内部类，而不是DCL，以避免潜在的复杂性和错误。
但在某些需要延迟初始化且对性能有较高要求的场景下，DCL仍然是一个合理的选择，只要正确实现。</span></pre>
</div>
<p>&nbsp;</p>
<p><span id="cke_bm_1252S">&nbsp;</span></p>
<h3>前言：什么是单例模式</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例即单实例，只实例出来一个对象。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般在创建一些<strong>管理器类</strong>、<strong>工具类</strong>的时候，需要用到单例模式，比如<strong>JDBCUtil </strong>类，我们只需要一个实例即可（多个实例也可以实现功能，但是增加了代码量且降低了性能）。</p>
<h4>如何实现单例：</h4>
<ul>
<li>将<strong>构造方法私有化</strong></li>
<li>提供一个<strong>全局唯一获取该类实例</strong>的方法帮助用户获取类的实例</li>
</ul>
<h4>应用场景：</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要被用于一个<strong>全局类的对象</strong><strong>在多个地方被使用</strong>并且对象的状态是全局变化的场景下。</p>
<h4>单例模式的优点：</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式为系统资源的优化提供了很好的思路，频繁创建和销毁对象都会增加系统的资源消耗，而单例模式保障了整个系统只有一个对象能被使用，很好地节约了资源。</p>
<h4><br>
单例模式的四类写法：</h4>
<ul>
<li><strong>饿汉模式</strong></li>
<li><strong>懒汉模式</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>双重校验锁</strong></li>


</ul>
<blockquote>
<p>在讲双重校验锁之前先来看一下其他模式</p>


</blockquote>
<h4>饿汉模式<br>
顾名思义，饿汉模式就是加载类的时候直接new一个对象，后面直接用即可。</h4>
<p>饿汉模式指在<strong>类中</strong>直接定义全局的静态对象的<strong>实例</strong>并<strong>初始化</strong>，然后提供一个方法获取该实例对象。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="14" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%C2%A0%20%C2%A0%20%2F%2F%20%E4%BD%BF%E7%94%A8static%E4%BF%AE%E9%A5%B0%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E5%80%99new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20static%20Singleton%20INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0%2F%2F%20%E6%9E%84%E9%80%A0%E5%99%A8%E7%A7%81%E6%9C%89%E5%8C%96%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20Singleton()%20%7B%7D%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0public%20static%20Singleton%20getInstance()%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0return%20INSTANCE%3B%5Cn%C2%A0%20%C2%A0%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Singleton {
&nbsp; &nbsp; <span class="hljs-comment">// 使用static修饰，类加载的时候new一个对象
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-type">Singleton <span class="hljs-variable">INSTANCE <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-comment">// 构造器私有化
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-title function_">Singleton<span class="hljs-params">() {}
&nbsp; &nbsp;&nbsp; &nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">public <span class="hljs-keyword">static Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">return INSTANCE;
&nbsp; &nbsp; }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<h4><br>
懒汉模式<br>
顾名思义，懒汉模式就是加载类的时候只声明变量，不new对象，后面用到的时候再new对象，然后把对象赋给该变量。</h4>
<p>定义一个私有的<strong>静态对象</strong>INSTANCE，之所以定义INSTANCE为静态，是因为<strong>静态属性或方法是属于类的</strong>，能够很好地保障单例对象的唯一性；</p>
<p>然后定义一个静态<strong>方法</strong>获取该对象，如果对象为null，则 new 一个对象并将其赋值给INSTANCE。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="13" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%C2%A0%20%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20static%20Singleton%20INSTANCE%3B%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0%2F%2F%20%E6%9E%84%E9%80%A0%E5%99%A8%E7%A7%81%E6%9C%89%E5%8C%96%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20Singleton()%20%7B%7D%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0public%20static%20Singleton%20getInstance()%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0if%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%7D%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0return%20INSTANCE%3B%5Cn%C2%A0%20%C2%A0%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Singleton {
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-keyword">static Singleton INSTANCE;
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-comment">// 构造器私有化
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-title function_">Singleton<span class="hljs-params">() {}
&nbsp; &nbsp;&nbsp; &nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">public <span class="hljs-keyword">static Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">return INSTANCE;
&nbsp; &nbsp; }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<blockquote>
<p><br>
饿汉模式和懒汉模式的<strong>区别</strong>在于：</p>
<p><strong>饿</strong>汉模式是在类加载时将其实例化的，在饿汉模式下，在Class Loader完成后该类的实例便已经存在于JVM中了，即，在getInstance方法第一次被调用前该实例已经存在了，new对象的操作不在getInstance方法内。<br>
而<strong>懒</strong>汉模式在<strong>类中只是定义了变量但是并未实例化</strong>，实例化的过程是在获取单例对象的方法中实现的，即，在<strong>getInstance方法第一次被调用后该实例才会被创建</strong>，new对象的操作在getInstance方法内。<br>
此外注意：</p>
<p><strong>饿汉</strong>模式的实例在类加载的时候已经存在于JVM中了，因此是<strong>线程安全的</strong>；</p>
<p><strong>懒汉</strong>模式通过第一次调用getInstance才实例化，该方法<strong>不是线程安全的</strong>（后面讲怎么优化）</p>


</blockquote>
<h4>静态内部类<br>
静态内部类通过在类中定义一个静态内部类，将对象实例的定义和初始化放在内部类中完成，我们在获取对象时要通过静态内部类调用其单例对象。</h4>
<p>之所以这样设计，是因为类的静态内部类在JVM中是唯一的，这就很好地保障了单例对象的唯一性。<br>
静态内部类的单例实现方式同样是<strong>线程安全</strong>的。</p>
<p>代码如下：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="12" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20static%20class%20SingletonHolder%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20static%20final%20Singleton%20INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%C2%A0%20%C2%A0%20%7D%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20Singleton()%7B%7D%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0public%20static%20final%20Singleton%20getInstance()%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0return%20SingletonHolder.INSTANCE%3B%5Cn%C2%A0%20%C2%A0%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Singleton {
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-keyword">class <span class="hljs-title class_">SingletonHolder {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-keyword">final <span class="hljs-type">Singleton <span class="hljs-variable">INSTANCE <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
&nbsp; &nbsp; }
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-title function_">Singleton<span class="hljs-params">(){}
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">public <span class="hljs-keyword">static <span class="hljs-keyword">final Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">(){
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">return SingletonHolder.INSTANCE;
&nbsp; &nbsp; }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<blockquote>
<p><br>
<strong>饿汉模式和静态</strong>内部类实现单例模式的优点是<strong>写法简单</strong>，缺点是<strong>不适合复杂对象的创建</strong>。</p>
<p>对于涉及复杂对象创建的单例模式，比较优雅的实现方式是懒汉模式，</p>
<p>但是懒汉模式是非线程安全的，</p>
<p>下面就讲一下<strong>懒汉模式的升级版</strong>——<strong>DCL</strong>双重构校验锁模式（<strong>双重构校验锁是线程安全的</strong>）。</p>


</blockquote>
<h4>双重校验锁<br>
饿汉模式是不需要加锁来保证单例的，而懒汉模式虽然节省了内存，但是却需要使用锁来保证单例，因此，双重校验锁就是懒汉模式的升级版本。</h4>
<p>单线程懒汉模式实现<br>
普通的懒汉模式在单线程场景下是线程安全的，但在多线程场景下是非线程安全的。</p>
<p>先来看看普通的懒汉模式实现：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="11" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%C2%A0%20%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20static%20Singleton%20INSTANCE%3B%5Cn%C2%A0%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0private%20Singleton()%20%7B%7D%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0%5Cn%C2%A0%20%C2%A0%C2%A0%20%C2%A0public%20static%20Singleton%20getInstance()%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0if%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%7D%5Cn%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0return%20INSTANCE%3B%5Cn%C2%A0%20%C2%A0%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Singleton {
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-keyword">static Singleton INSTANCE;
&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">private <span class="hljs-title function_">Singleton<span class="hljs-params">() {}
&nbsp; &nbsp;&nbsp; &nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">public <span class="hljs-keyword">static Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">return INSTANCE;
&nbsp; &nbsp; }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<h4><br>
单线程懒汉模式的问题<br>
上面这段代码在单线程环境下没有问题，但是在多线程的情况下会产生线程安全问题。</h4>
<p>在多个线程同时调用getInstance方法时，由于方法没有加锁，可能会出现以下情况</p>
<ul>
<li>① 这些<strong>线程</strong>可能会<strong>创建多个对象</strong></li>
<li>② 某个线程可能会得到一个<strong>未完全初始化的对</strong>象</li>


</ul>
<p>为什么会出现以上问题？对于 ① 的情况解释如下：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="10" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20static%20Singleton%20getInstance()%20%7B%5Cn%20%20%20%20if%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F**%5Cn%20%20%20%20%20%20%20%20%20*%20%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89%E5%8A%A0%E9%94%81%EF%BC%8C%E5%BD%93%E7%BA%BF%E7%A8%8BA%E5%88%9A%E6%89%A7%E8%A1%8C%E5%AE%8Cif%E5%88%A4%E6%96%ADINSTANCE%E4%B8%BAnull%E5%90%8E%E8%BF%98%E6%B2%A1%E6%9D%A5%E5%BE%97%E5%8F%8A%E6%89%A7%E8%A1%8CINSTANCE%20%3D%20new%20Singleton()%5Cn%20%20%20%20%20%20%20%20%20*%20%E6%AD%A4%E6%97%B6%E7%BA%BF%E7%A8%8BB%E8%BF%9B%E6%9D%A5%EF%BC%8Cif%E5%88%A4%E6%96%AD%E5%90%8EINSTANCE%E4%B8%BAnull%EF%BC%8C%E4%B8%94%E6%89%A7%E8%A1%8C%E5%AE%8CINSTANCE%20%3D%20new%20Singleton()%5Cn%20%20%20%20%20%20%20%20%20*%20%E7%84%B6%E5%90%8E%EF%BC%8C%E7%BA%BF%E7%A8%8BA%E6%8E%A5%E7%9D%80%E6%89%A7%E8%A1%8C%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%B9%8B%E5%89%8Dif%E5%88%A4%E6%96%ADINSTANCE%E4%B8%BAnull%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%89%A7%E8%A1%8CINSTANCE%20%3D%20new%20Singleton()%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E8%B1%A1%5Cn%20%20%20%20%20%20%20%20%20*%2F%5Cn%20%20%20%20%20%20%20%20INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20INSTANCE%3B%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">static Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {
    <span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
        <span class="hljs-comment">/**
         * 由于没有加锁，当线程A刚执行完if判断INSTANCE为null后还没来得及执行INSTANCE = new Singleton()
         * 此时线程B进来，if判断后INSTANCE为null，且执行完INSTANCE = new Singleton()
         * 然后，线程A接着执行，由于之前if判断INSTANCE为null，于是执行INSTANCE = new Singleton()重复创建了对象
         */
        INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
    }
    <span class="hljs-keyword">return INSTANCE;
}
</span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>对于 ② 的情况解释如下：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="9" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20static%20Singleton%20getInstance()%20%7B%5Cn%20%20%20%20if%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F**%5Cn%20%20%20%20%20%20%20%20%20*%20%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89%E5%8A%A0%E9%94%81%EF%BC%8C%E5%BD%93%E7%BA%BF%E7%A8%8BA%E5%88%9A%E6%89%A7%E8%A1%8C%E5%AE%8Cif%E5%88%A4%E6%96%ADINSTANCE%E4%B8%BAnull%E5%90%8E%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%20INSTANCE%20%3D%20new%20Singleton()%5Cn%20%20%20%20%20%20%20%20%20*%20%E4%BD%86%E6%98%AF%E6%B3%A8%E6%84%8F%EF%BC%8Cnew%20Singleton()%E8%BF%99%E4%B8%AA%E6%93%8D%E4%BD%9C%E5%9C%A8JVM%E5%B1%82%E9%9D%A2%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%5Cn%20%20%20%20%20%20%20%20%20*%5Cn%20%20%20%20%20%20%20%20%20*%EF%BC%88%E5%85%B7%E4%BD%93%E7%94%B1%E4%B8%89%E6%AD%A5%E7%BB%84%E6%88%90%EF%BC%9A1.%E4%B8%BAINSTANCE%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%9B2.%E5%88%9D%E5%A7%8B%E5%8C%96INSTANCE%EF%BC%9B3.%E5%B0%86INSTANCE%E6%8C%87%E5%90%91%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%20*%20%E4%B8%94%E8%BF%99%E4%B8%89%E6%AD%A5%E5%9C%A8JVM%E5%B1%82%E9%9D%A2%E6%9C%89%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%AF%E8%83%BD%E4%B8%BA1-3-2%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%20*%5Cn%20%20%20%20%20%20%20%20%20*%20%E5%9B%A0%E4%B8%BAnew%E6%93%8D%E4%BD%9C%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8BA%E6%89%A7%E8%A1%8Cnew%20Singleton()%E6%97%B6%E5%8F%91%E7%94%9F%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%20*%20%E5%AF%BC%E8%87%B4%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%98%E4%B8%BA1-3-2%EF%BC%8C%E5%BD%93%E6%89%A7%E8%A1%8C%E5%AE%8C1-3%E8%BF%98%E6%B2%A1%E6%9D%A5%E5%8F%8A%E6%89%A7%E8%A1%8C2%E6%97%B6%EF%BC%88%E8%99%BD%E7%84%B6%E8%BF%98%E6%B2%A1%E6%89%A7%E8%A1%8C2%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%20*%20%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%98%E6%B2%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%89%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%BA%BF%E7%A8%8BB%E8%BF%9B%E6%9D%A5%E8%BF%9B%E8%A1%8Cif%E5%88%A4%E6%96%AD%E5%90%8EINSTANCE%E4%B8%8D%E4%B8%BAnull%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20%20*%20%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E6%8A%8A%E7%BA%BF%E7%A8%8BA%20new%E5%88%B0%E4%B8%80%E5%8D%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E%E4%BA%86%5Cn%20%20%20%20%20%20%20%20%20*%2F%5Cn%20%20%20%20%20%20%20%20INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20INSTANCE%3B%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">static Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {
    <span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
        <span class="hljs-comment">/**
         * 由于没有加锁，当线程A刚执行完if判断INSTANCE为null后开始执行 INSTANCE = new Singleton()
         * 但是注意，new Singleton()这个操作在JVM层面不是一个原子操作
         *
         *（具体由三步组成：1.为INSTANCE分配内存空间；2.初始化INSTANCE；3.将INSTANCE指向分配的内存空间，
         * 且这三步在JVM层面有可能发生指令重排，导致实际执行顺序可能为1-3-2）
         *
         * 因为new操作不是原子化操作，因此，可能会出现线程A执行new Singleton()时发生指令重排的情况，
         * 导致实际执行顺序变为1-3-2，当执行完1-3还没来及执行2时（虽然还没执行2，但是对象的引用已经有了，
         * 只不过引用的是一个还没初始化的对象），此时线程B进来进行if判断后INSTANCE不为null，
         * 然后直接把线程A new到一半的对象返回了
         */
        INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
    }
    <span class="hljs-keyword">return INSTANCE;
}
</span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<h4>解决问题：加锁</h4>
<p>为了解决问题 ①，我们可以对 getInstance() 这个方法加锁。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="8" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%20%20%5Ctprivate%20static%20Singleton%20INSTANCE%3B%5Cn%20%20%5Cn%20%20%5Ctprivate%20Singleton()%20%7B%7D%5Cn%20%20%5Ct%5Cn%20%20%5Ctpublic%20static%20synchronized%20Singleton%20getInstance()%20%7B%20%20%2F%2F%20%E5%8A%A0%E9%94%81%5Cn%20%20%20%20%20%20%5Ctif%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%5CtINSTANCE%20%3D%20new%20Singleton()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%5Ctreturn%20INSTANCE%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Singleton {
  	<span class="hljs-keyword">private <span class="hljs-keyword">static Singleton INSTANCE;
  
  	<span class="hljs-keyword">private <span class="hljs-title function_">Singleton<span class="hljs-params">() {}
  	
  	<span class="hljs-keyword">public <span class="hljs-keyword">static <span class="hljs-keyword">synchronized Singleton <span class="hljs-title function_">getInstance<span class="hljs-params">() {  <span class="hljs-comment">// 加锁
      	<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
          	INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Singleton();
        }
      	<span class="hljs-keyword">return INSTANCE;
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<blockquote>
<p>仔细看，这里是粗暴地对<strong>整个 getInstance() 方法加锁</strong>，这样做代价很大，因为，只有当第一次调用 getInstance() 时才需要同步创建对象，创建之后再次调用 getInstance() 时就只是简单的返回成员变量，而这里是无需同步的，所以没必要对整个方法加锁。</p>
<p>由于同步一个方法会降低上百倍甚至更高的性能， 每次调用获取和释放锁的开销似乎是可以避免的：一旦初始化完成，获取和释放锁就显得很不必要。所以可以<strong>只对方法的部分代码加锁</strong>！！</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="7" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Lock2Singleton%20%7B%5Cn%20%20%5Ctprivate%20static%20Lock2Singleton%20INSTANCE%3B%5Cn%20%20%5Cn%20%20%5Ctprivate%20Lock2Singleton()%20%7B%7D%5Cn%20%20%5Cn%20%20%5Ctpublic%20static%20Lock2Singleton%20getSingleton()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%9B%A0%E4%B8%BAINSTANCE%E6%98%AF%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8C%E6%89%80%E4%BB%A5%E7%BB%99Lock2Singleton%E7%9A%84Claa%E5%AF%B9%E8%B1%A1%E4%B8%8A%E9%94%81%5Cn%20%20%20%20%20%20%20%20synchronized(Lock2Singleton.class)%20%7B%20%20%20%20%20%20%20%20%2F%2F%20%E5%8A%A0%20synchronized%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(INSTANCE%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20INSTANCE%20%3D%20new%20Lock2Singleton()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%5Ctreturn%20INSTANCE%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Lock2Singleton {
  	<span class="hljs-keyword">private <span class="hljs-keyword">static Lock2Singleton INSTANCE;
  
  	<span class="hljs-keyword">private <span class="hljs-title function_">Lock2Singleton<span class="hljs-params">() {}
  
  	<span class="hljs-keyword">public <span class="hljs-keyword">static Lock2Singleton <span class="hljs-title function_">getSingleton<span class="hljs-params">() {
        <span class="hljs-comment">// 因为INSTANCE是静态变量，所以给Lock2Singleton的Claa对象上锁
        <span class="hljs-keyword">synchronized(Lock2Singleton.class) {        <span class="hljs-comment">// 加 synchronized
            <span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {
                INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Lock2Singleton();
            }
        }
      	<span class="hljs-keyword">return INSTANCE;
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>优化后的代码选择了对 if (INSTANCE == null) 和 INSTANCE = new Lock2Singleton()加锁</p>
<p>这样，每<strong>个线程进到这个方法中之后先加锁</strong>，这样就保证了 if (INSTANCE == null) 和 INSTANCE = new Lock2Singleton() 这两行代码被同一个线程执行时不会有另外一个线程进来，由此保证了创建的对<strong>象是唯一的</strong>。</p>
<p>&nbsp;</p>
<p>对象的唯一性保证了，也就是解决了问题①，同时也解决了问题②。<br>
为什么说也解决了问题②呢？synchronized不是不能禁止指令重排序吗？<br>
其实当我们对INSTANCE == null和INSTANCE = new Lock2Singleton();加锁时，也就表示只有一个线程能进来，尽管发生了指令重排序，也只是在持有锁的期间发生了指令重排序，当该线程创建完对象释放锁时，new出来的已经是一个完整的对象。</p>
<p>&nbsp;</p>
<p>如此，我们仿佛完美地解决了问题 ① 和 ② ，然而你以为这就结束了吗？NO！这段代码从功能层面来讲确实是已经结束了，但是<strong>性能</strong>方面呢？是不是还有可以优化的地方？</p>
<p>&nbsp;</p>
<p>答案是：有！！</p>
<p>&nbsp;</p>
<p>值得优化的地方就在于 <strong>synchronized </strong>代码块这里。每个线程进来，不管三七二十一，都要先进入同步代码块再说，如果说现在 INSTANCE 已经不为null了，那么，此时当一个线程进来，先获得锁，然后才会执行 if 判断。我们知道加锁是非常影响效率的，所以，如果 INSTANCE 已经不为null，是不是就可以先判断，再进入 synchronized 代码块。如下</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="6" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Lock2Singleton%20%7B%5Cn%5Cn%20%20%5Ctprivate%20static%20Lock2Singleton%20INSTANCE%3B%5Cn%20%20%5Cn%20%20%5Ctprivate%20Lock2Singleton()%20%7B%7D%5Cn%20%20%5Cn%20%20%5Ctpublic%20static%20Lock2Singleton%20getSingleton()%20%7B%5Cn%20%20%20%20%20%20%5Ctif%20(INSTANCE%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A0%A1%E9%AA%8C%5Cn%20%20%20%20%20%20%20%20%20%20%5Ctsynchronized(Lock2Singleton.class)%20%7B%20%20%20%20%20%20%20%20%2F%2F%20%E5%8A%A0%20synchronized%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctif%20(INSTANCE%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%EF%BC%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%A0%A1%E9%AA%8C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CtINSTANCE%20%3D%20new%20Lock2Singleton()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%5Ctreturn%20INSTANCE%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Lock2Singleton {

  	<span class="hljs-keyword">private <span class="hljs-keyword">static Lock2Singleton INSTANCE;
  
  	<span class="hljs-keyword">private <span class="hljs-title function_">Lock2Singleton<span class="hljs-params">() {}
  
  	<span class="hljs-keyword">public <span class="hljs-keyword">static Lock2Singleton <span class="hljs-title function_">getSingleton<span class="hljs-params">() {
      	<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {                         <span class="hljs-comment">// 双重校验：第一次校验
          	<span class="hljs-keyword">synchronized(Lock2Singleton.class) {        <span class="hljs-comment">// 加 synchronized
              	<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {                 <span class="hljs-comment">// 双重校验：第二次校验
                  	INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Lock2Singleton();
                }
            }
        }
      	<span class="hljs-keyword">return INSTANCE;
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p><strong>在 synchronized 代码块之外再加一个 if 判断，这样，当 INSTANCE 已经存在时，线程先判断不为null，然后直接返回，避免了进入 synchronized 同步代码块</strong>。</p>
<p>&nbsp;</p>
<p>那么可能又有人问，好了，我明白了在<strong> synchronized 代码块外加一个 if 判断</strong>，是不是就意味着里面的那个 if 判断可以去掉？</p>
<p>&nbsp;</p>
<p>当然不可以！！</p>
<p>&nbsp;</p>
<p>如果把里面的 if 判断去掉，就相当于只对 INSTANCE = new Lock2Singleton() 这一行代码加了个锁，只对一行代码加锁，那你岂不是加了个寂寞（<strong>加锁的目的</strong>就是防止在<strong>第二个if判断和new操作之间有别的线程进来</strong>！！），结果还是会引起问题①。</p>
<p>&nbsp;</p>
<p>所以，两次校验，一次都不能少！！</p>
<p>&nbsp;</p>
<p>但是，问题又来了，由于我们在外层又加了一层if (INSTANCE == null)的判断，导致原本被我们解决的问题② （即<strong>指令重排序问题</strong>）又出现了！</p>
<p>&nbsp;</p>
<p>比如：线程A拿到锁后刚走到INSTANCE = new Lock2Singleton()，但是还没执行完，因为new Lock2Singleton()不是原子操作，且发生了指令重排序，那么此时INSTANCE就是一个不完整的对象，恰巧此时，线程B来到第一个if (INSTANCE == null)判断，由于INSTANCE不为null，结果获取到一个不完整的对象。</p>
<p>&nbsp;</p>
<p>那么怎么解决呢？</p>
<p>&nbsp;</p>
<p>答案是加 <strong>volatile</strong> 关键字，volatile可以禁止指令重排序</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="5" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20Lock2Singleton%20%7B%5Cn%20%20%5Ctprivate%20volatile%20static%20Lock2Singleton%20INSTANCE%3B%20%20%20%20%2F%2F%20%E5%8A%A0%20volatile%5Cn%20%20%5Cn%20%20%5Ctprivate%20Lock2Singleton()%20%7B%7D%5Cn%20%20%5Cn%20%20%5Ctpublic%20static%20Lock2Singleton%20getSingleton()%20%7B%5Cn%20%20%20%20%20%20%5Ctif%20(INSTANCE%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A0%A1%E9%AA%8C%5Cn%20%20%20%20%20%20%20%20%20%20%5Ctsynchronized(Lock2Singleton.class)%20%7B%20%20%20%20%20%20%20%20%2F%2F%20%E5%8A%A0%20synchronized%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctif%20(INSTANCE%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%EF%BC%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%A0%A1%E9%AA%8C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CtINSTANCE%20%3D%20new%20Lock2Singleton()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%5Ctreturn%20INSTANCE%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">Lock2Singleton {
  	<span class="hljs-keyword">private <span class="hljs-keyword">volatile <span class="hljs-keyword">static Lock2Singleton INSTANCE;    <span class="hljs-comment">// 加 volatile
  
  	<span class="hljs-keyword">private <span class="hljs-title function_">Lock2Singleton<span class="hljs-params">() {}
  
  	<span class="hljs-keyword">public <span class="hljs-keyword">static Lock2Singleton <span class="hljs-title function_">getSingleton<span class="hljs-params">() {
      	<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {                         <span class="hljs-comment">// 双重校验：第一次校验
          	<span class="hljs-keyword">synchronized(Lock2Singleton.class) {        <span class="hljs-comment">// 加 synchronized
              	<span class="hljs-keyword">if (INSTANCE == <span class="hljs-literal">null) {                 <span class="hljs-comment">// 双重校验：第二次校验
                  	INSTANCE = <span class="hljs-keyword">new <span class="hljs-title class_">Lock2Singleton();
                }
            }
        }
      	<span class="hljs-keyword">return INSTANCE;
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
</blockquote>
<h3>&nbsp;</h3>
<h3><strong>一、DCL 的基本实现</strong></h3>
<p>DCL（Double-Checked Locking）旨在减少同步开销，仅在首次创建实例时使用同步，同时保证线程安全。</p>
<h4><strong>标准代码模板</strong></h4>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="4" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%20%20%20%20private%20static%20volatile%20Singleton%20instance%3B%20%2F%2F%20%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%20volatile%5Cn%20%20%20%20%5Cn%20%20%20%20private%20Singleton()%20%7B%7D%20%2F%2F%20%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%5Cn%20%20%20%20%5Cn%20%20%20%20public%20static%20Singleton%20getInstance()%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(instance%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A3%80%E6%9F%A5%EF%BC%88%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%20%20%20%20synchronized%20(Singleton.class)%20%7B%20%20%20%20%2F%2F%20%E5%90%8C%E6%AD%A5%E5%9D%97%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(instance%20%3D%3D%20null)%20%7B%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%A3%80%E6%9F%A5%EF%BC%88%E7%A1%AE%E4%BF%9D%E5%94%AF%E4%B8%80%E5%AE%9E%E4%BE%8B%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20instance%20%3D%20new%20Singleton()%3B%20%2F%2F%20%E5%AE%9E%E4%BE%8B%E5%8C%96%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20instance%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">public class Singleton {
    private static volatile Singleton instance; // 必须使用 volatile
    
    private Singleton() {} // 私有构造函数
    
    public static Singleton getInstance() {
        if (instance == null) {                 // 第一次检查（避免不必要的同步）
            synchronized (Singleton.class) {    // 同步块
                if (instance == null) {         // 第二次检查（确保唯一实例）
                    instance = new Singleton(); // 实例化
                }
            }
        }
        return instance;
    }
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<hr>
<h3><strong>二、DCL 的核心问题</strong></h3>
<h4><strong>1. 指令重排序问题</strong></h4>
<ul>
<li>
<p><strong>实例化操作的非原子性</strong>：<br>
	<code>instance = new Singleton()</code>&nbsp;分解为三步：</p>
<ol>
<li>
<p>分配内存空间</p>


		</li>
<li>
<p>初始化对象</p>


		</li>
<li>
<p>将引用指向内存地址</p>


		</li>


	</ol>
	</li>
<li>
<p><strong>可能的指令重排序</strong>：<br>
	若步骤2和3被重排序，其他线程可能访问到未初始化的对象（导致空指针异常）。</p>


	</li>


</ul>
<h4><strong>2. 可见性问题</strong></h4>
<p>未使用&nbsp;<code>volatile</code>&nbsp;时，一个线程的写操作可能对其他线程不可见。</p>
<hr>
<h3><strong>三、解决方案：<code>volatile</code>&nbsp;关键字</strong></h3>
<h4><strong><code>volatile</code>&nbsp;的作用</strong></h4>
<ol>
<li>
<p><strong>禁止指令重排序</strong></p>
<ul>
<li>
<p>通过内存屏障（Memory Barrier）确保：</p>
<ul>
<li>
<p><strong>写</strong>操作前的指令不会被重排序到<strong>写</strong>操作之后。</p>


			</li>
<li>
<p><strong>读</strong>操作后的指令不会被重排序到<strong>读</strong>操作之前。</p>


			</li>


		</ul>


		</li>


	</ul>


	</li>
<li>
<p><strong>保证可见性</strong></p>
<ul>
<li>
<p><strong>修改&nbsp;<code>volatile</code>&nbsp;变量后，强制刷新到主内存</strong>。</p>


		</li>
<li>
<p>其他线程读取时直接从<strong>主内存</strong>加载。</p>


		</li>


	</ul>


	</li>


</ol><hr>
<h3><strong>四、DCL 的演进与 JVM 版本兼容性</strong></h3>
<table>
<thead>
<tr><th><strong>Java 版本</strong></th><th><strong>DCL 安全性</strong></th><th><strong>原因</strong></th>
		</tr>


	</thead>
<tbody>
<tr>
<td>Java 1.4 及之前</td>
<td>不安全</td>
<td><code>volatile</code>&nbsp;语义不完整</td>


		</tr>
<tr>
<td>Java <strong>5</strong>（JSR-133）及之后</td>
<td>安全</td>
<td><strong><code>volatile</code>&nbsp;增强内存屏障语义</strong></td>


		</tr>


	</tbody>


</table>
<hr>
<h3><strong>五、替代单例实现方案</strong></h3>
<h4><strong>1. 静态内部类（Holder 模式）</strong></h4>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="3" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22public%20class%20Singleton%20%7B%5Cn%20%20%20%20private%20Singleton()%20%7B%7D%5Cn%20%20%20%20%5Cn%20%20%20%20private%20static%20class%20Holder%20%7B%5Cn%20%20%20%20%20%20%20%20private%20static%20final%20Singleton%20INSTANCE%20%3D%20new%20Singleton()%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Cn%20%20%20%20public%20static%20Singleton%20getInstance()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20Holder.INSTANCE%3B%20%2F%2F%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%94%B1%20JVM%20%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">public class Singleton {
    private Singleton() {}
    
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE; // 类加载时初始化，由 JVM 保证线程安全
    }
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<ul>
<li>
<p><strong>优点</strong>：无锁、线程安全、延迟加载。</p>
</li>
<li>
<p><strong>缺点</strong>：无法防止反射或反序列化破坏单例。</p>
</li>
</ul>
<h4><strong>2. 枚举单例（推荐）</strong></h4>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="2" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22public%20enum%20Singleton%20%7B%5Cn%20%20%20%20INSTANCE%3B%20%2F%2F%20%E7%94%B1%20JVM%20%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%5Cn%20%20%20%20%5Cn%20%20%20%20public%20void%20doSomething()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">public enum Singleton {
    INSTANCE; // 由 JVM 保证唯一性
    
    public void doSomething() {
        // 方法实现
    }
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<ul>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p>线程安全。</p>
</li>
<li>
<p>天然防反射和反序列化破坏。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：无法继承其他类。</p>
</li>
</ul>
<hr>
<h3><strong>六、DCL 的正确使用场景</strong></h3>
<ul>
<li>
<p><strong>延迟初始化</strong>：仅在需要时创建实例。</p>
</li>
<li>
<p><strong>性能敏感</strong>：避免每次调用同步的开销。</p>
</li>
<li>
<p><strong>兼容性要求</strong>：需支持 Java 5 及以上版本。</p>
</li>
</ul>
<hr>
<h3><strong>七、常见误区与验证</strong></h3>
<h4><strong>1. 错误：省略&nbsp;<code>volatile</code></strong></h4>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="1" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22private%20static%20Singleton%20instance%3B%20%2F%2F%20%E7%BC%BA%E5%B0%91%20volatile%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">private static Singleton instance; // 缺少 volatile</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<ul>
<li>
<p><strong>后果</strong>：可能返回未完全初始化的对象（指令重排序导致）。</p>
</li>
</ul>
<h4><strong>2. 错误：单次检查</strong></h4>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="0" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22public%20static%20Singleton%20getInstance()%20%7B%5Cn%20%20%20%20if%20(instance%20%3D%3D%20null)%20%7B%20%2F%2F%20%E5%8D%95%E6%AC%A1%E6%A3%80%E6%9F%A5%5Cn%20%20%20%20%20%20%20%20synchronized%20(Singleton.class)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20instance%20%3D%20new%20Singleton()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20instance%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">public static Singleton getInstance() {
    if (instance == null) { // 单次检查
        synchronized (Singleton.class) {
            instance = new Singleton();
        }
    }
    return instance;
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1858210/202503/1858210-20250318141825966-1870380107.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<ul>
<li>
<p><strong>后果</strong>：多线程环境下可能创建多个实例。</p>
</li>
</ul>
<hr>
<h3><strong>八、内存屏障与 JVM 实现细节</strong></h3>
<ul>
<li>
<p><strong>写操作屏障：</strong></p>
<ul>
<li>
<p><strong><code>StoreStore</code>&nbsp;屏障：禁止普通写与&nbsp;<code>volatile</code>&nbsp;写重排序。</strong></p>
</li>
<li>
<p><strong><code>StoreLoad</code>&nbsp;屏障：强制刷新写缓存到主内存。</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>读操作屏障：</strong></p>
<ul>
<li>
<p><strong><code>LoadLoad</code>&nbsp;屏障：禁止&nbsp;<code>volatile</code>&nbsp;读与后续普通读重排序。</strong></p>
</li>
<li>
<p><strong><code>LoadStore</code>&nbsp;屏障：禁止&nbsp;<code>volatile</code>&nbsp;读与后续普通写重排序。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3><strong>九、总结</strong></h3>
<ul>
<li>
<p><strong>DCL 要点</strong>：</p>
<ul>
<li>
<p><strong>双重检查减少同步开销。</strong></p>
</li>
<li>
<p><strong><code>volatile</code>&nbsp;禁止指令重排序，保证可见性。</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：需要延迟初始化且对性能有要求的单例实现。</p>
</li>
<li>
<p><strong>替代方案</strong>：优先考虑枚举或静态内部类实现单例。</p>
</li>
</ul>
<p>正确实现 DCL 需严格遵循代码模板，避免遗漏&nbsp;<code>volatile</code>&nbsp;关键字，以确保线程安全和对象初始化的正确性。</p>
<span data-cke-copybin-start="1"><span data-cke-copybin-end="1">​</span></span>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005647888597222222" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-18 14:18">2025-03-18 14:18</span>&nbsp;
<a href="https://www.cnblogs.com/wanglli">我是王哈哈w</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18778857" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18778857);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18778857', targetLink: 'https://www.cnblogs.com/wanglli/p/18778857', title: 'DCL（Double-checked Locking双重校验锁）实现单例模式的原理、问题与解决方案' })">举报</a>
</div>
        