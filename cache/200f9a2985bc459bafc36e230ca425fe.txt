
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yongshao/p/18731475" title="发布于 2025-03-01 22:08">
    <span role="heading" aria-level="2">2025/2/22课堂记录</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        dp，树上依赖背包，树上dp，多叉树转二叉树，愚蠢的矿工，宝藏，状压，猛兽军团，国王
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>目录</h2>
<ol>
<li>愚蠢的矿工</li>
<li>国王（猛兽军团）</li>
</ol>
<hr>
<ul>
<li>
<h3><a href="https://www.rqnoj.cn/problem/30" target="_blank" rel="noopener nofollow">愚蠢的矿工</a></h3>
</li>
</ul>
<p>这网页稍微有点乱，不过凑合凑合还能看，就是没法提交了而已</p>
<p>首先看到的第一眼，感觉是树上依赖背包</p>
<p>毕竟要挖到某一个节点的宝藏要之前知道根节点所有节点都要有狗狗停留</p>
<p>但是呢……</p>
<p>没错，他就是树上依赖背包<span style="text-decoration: line-through">（别打我）</span></p>
<p>但是呢，这道题还有第二种写法，就是多叉树转二叉树</p>
<p>没错，左牵儿子，右擎兄弟的孩子兄弟表示法</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202502/3564565-20250222201658904-1785710070.png" alt="" height="198" width="406"></p>
<p id="1740226620002">记住一个口诀：之前你的儿子现在是我的兄弟，现在你的儿子是我&nbsp;</p>
<p>然后就可以根据普通的树形dp来做啦</p>
<details>
<summary>这是代码</summary>
<pre class="language-cpp highlighter-hljs"><code>
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int a[1010],leftt[1010],rightt[1010],vis[1010][110];
int dp(int x,int m)//dp(a,b):求以a为根节点的子树，给b位矿工，求最大值，也就是vis[a][b] 
{
	if(m==0)return 0;//不给人没法干活
	if(vis[x][m]!=-1)return vis[x][m];//之前算过这个，剪枝
	if(x==-1)return 0;//访问的节点不存在，sorry，the number you…
	int ans=0;//终于剪完枝了 
	ans=dp(rightt[x],m);//自己没留人，孩子不能走。把所有人手都给自己的兄弟
	for(int i=0;i&lt;=m-1;i++)//至少给自己留一人，然后就可以走孩子了，孩子兄弟分家产
		ans=max(ans,dp(leftt[x],i)+a[x]+dp(rightt[x],m-i-1));//别忘了数你自己！ 
	vis[x][m]=ans;
	return ans; 
}
int main()
{
	memset(vis,-1,sizeof(vis));
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;//宝藏个数；旷工人数
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;=n;i++)leftt[i]=rightt[i]=-1;
	for(int i=1;i&lt;=n;i++)
	{
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		rightt[y]=leftt[x];//之前你的儿子现在是我的兄弟
		leftt[x]=y;//现在你的儿子是我 
	}
	cout&lt;&lt;dp(leftt[0],m); //0的孩子就是树根 
	cout&lt;&lt;"\n";
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=m;j++)
			cout&lt;&lt;vis[i][j]&lt;&lt;" ";
		cout&lt;&lt;"\n";
	}
	return 0;
}</code></pre>
</details><hr>
<ul>
<li>
<h3>国王（猛兽军团）</h3>
</li>
</ul>
<p>这是一个全新的dp种类，名叫“状压”</p>
<p>状压就是列数比较少的，行数不限的dp，每行可以用二进制等进行描述</p>
<p>前面预处理部分是筛选出所有合法状态，然后把二进制压缩（所以行数必须要少，不然数据的大小是呈指数型增长的！！）</p>
<p>比如10110这个</p>
<p style="padding-left: 40px">010110</p>
<p>&amp;&nbsp; &nbsp; &nbsp; &nbsp;101100</p>
<p>——————</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 000100</p>
<p>所以就有重叠</p>
<p>后来通过4for：枚举行，个数，方案，前一行方案来进行dp</p>
<h3>&nbsp;</h3>
<pre class="language-cpp highlighter-hljs"><code>// 猛兽军团1； 互不侵犯
// &lt;&lt;算法竞赛宝典-第二部&gt;&gt;
// N*N  放m个猛兽  上下左右，四条对角线； 共8个方向冲突;
#include&lt;iostream&gt;
using namespace std;
int n,m,ans; 
int s[1050] ;//保存一行之内不冲突的可行状态
int state;   //统计行内可行状态的个数
int num[1050];//对应可行状态的猛兽个数；
int f[11][105][1050];// f[i][j][s]: 前i行放j个猛兽，并且第i行放置第s个可行状态; 
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	//预处理部分 ： 找出行内不冲突的可行状态; 
	for(int i=0;i&lt;(1&lt;&lt;n);i++)
	{
		if(i&amp;i&lt;&lt;1)    // 状态s里面有相邻的1 ，冲突 
		    continue;
		state++;   
		s[state]=i;
		int t=i;
		while(t)
		{
			num[state]+=t&amp;1;
			t=t&gt;&gt;1;   // t=t/2;
		}
	}
	
	//dp部分；
	//第一行 
	for(int i=1;i&lt;=state;i++)
	{
		int j=num[i];
		if(j&gt;m)
		    continue;
		f[1][j][i]=1;  //前1行放置j个猛兽，并且第1行放第i个合法状态的  方案数 
	}
	
	//2-n行  4for： 
	for(int i=2;i&lt;=n;i++)  // 枚举到第i行 
	{
	    for(int j=0;j&lt;=m;j++) // 1~i行放置j个猛兽 
		{
			for(int a=1;a&lt;=state;a++)   // 当前行可行状态
			{
				int x=num[a];//第1行放置的猛兽个数 
				if(x&gt;j)
				    continue;
				int xx=j-x;               //1~i-1行剩余可用的猛兽数 
				for(int b=1;b&lt;=state;b++) //第i-1行可行状态
				{
					int y=num[b];
					if(y&gt;xx)
				        continue;
				        
				    if(s[a]&amp;s[b])     //同列 
				        continue;
				    if(s[a]&lt;&lt;1&amp;s[b])  //左上角 
				        continue;
				    if(s[a]&amp;s[b]&lt;&lt;1)  //右上角 
				        continue;
				        
				    f[i][j][a]+=f[i-1][j-num[a]][b];
				} 
				if(i==n&amp;&amp;j==m)
				    ans+=f[n][m][a]; 
			}
		}	
	} 
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} </code></pre>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/yongshao/" target="_blank">永韶</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/yongshao/p/18731475" target="_blank">https://www.cnblogs.com/yongshao/p/18731475</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0070102073564814816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-01 22:09">2025-03-01 22:08</span>&nbsp;
<a href="https://www.cnblogs.com/yongshao">永韶</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18731475" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18731475);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18731475', targetLink: 'https://www.cnblogs.com/yongshao/p/18731475', title: '2025/2/22课堂记录' })">举报</a>
</div>
        