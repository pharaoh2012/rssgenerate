
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ZhangDT/p/18794901" title="发布于 2025-03-26 22:05">
    <span role="heading" aria-level="2">UNIQUE VISION Programming Contest 2025 Spring (AtCoder Beginner Contest 398) (A~F) 补题+题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="a---doors-in-the-center"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_a" title="A - Doors in the Center" target="_blank" rel="noopener nofollow">A - Doors in the Center</a></h1>
<p>签到题，直接构造即可。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e6 + 10;

signed main() {
	int n;
	cin &gt;&gt; n;
	if (n % 2 == 1) {
		for (int i = 1; i &lt;= n / 2; i++) {
			cout &lt;&lt; '-';
		}
		cout &lt;&lt; "=";
		for (int i = 1; i &lt;= n / 2; i++) {
			cout &lt;&lt; '-';
		}
	} else {
		for (int i = 1; i &lt;= n / 2 - 1; i++) {
			cout &lt;&lt; '-';
		}
		cout &lt;&lt; "==";
		for (int i = 1; i &lt;= n / 2 - 1; i++) {
			cout &lt;&lt; '-';
		}
	}
}
/*
*/
</code></pre>
</details>
<h1 id="b---full-house-3"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_b" title="B - Full House 3" target="_blank" rel="noopener nofollow">B - Full House 3</a></h1>
<p>有两种三个以上的相同的或者一种三个以上相同一种两个以上相同便可以满足葫芦的条件。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e6 + 10;

signed main() {
	int n = 7;
	map&lt;int, int&gt; mp;
	set&lt;int&gt; se;
	for (int i = 1; i &lt;= n; i++) {
		int x;
		cin &gt;&gt; x;
		mp[x]++;
		se.insert(x);
	}
	int f = 0, ff = 0;
	for (auto t : se) {
		if (mp[t] &gt;= 3) f++;
		else if (mp[t] &gt;= 2) ff++;
	}
	if (f &gt;= 2 || (f == 1 &amp;&amp; ff &gt;= 1)) {
		cout &lt;&lt; "Yes\n";
	} else {
		cout &lt;&lt; "No\n";
	}
}
/*
*/
</code></pre>
</details>
<h1 id="c---uniqueness"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_c" title="C - Uniqueness" target="_blank" rel="noopener nofollow">C - Uniqueness</a></h1>
<p>暴力枚举。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e6 + 10;

signed main() {
	int n;
	cin &gt;&gt; n;
	map&lt;int, int&gt; mp;
	vector&lt;int&gt; a(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; a[i];
		mp[a[i]]++;
	}
	int ans = -1, id = -1;
	for (int i = 1; i &lt;= n; i++) {
		if (mp[a[i]] == 1) {
			if (a[i] &gt; ans) {
				ans = a[i];
				id = i;
			}
		}
	}
	cout &lt;&lt; id &lt;&lt; '\n';
}
/*
*/
</code></pre>
</details>
<h1 id="d---bonfire"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_d" title="D - Bonfire" target="_blank" rel="noopener nofollow">D - Bonfire</a></h1>
<p><span class="math inline">\((0,0)\)</span>点每次都会刷新新的烟雾，对于每次移动是否可以覆盖高桥只需要看前面哪个刷新的烟雾可以到达高桥，如果有则是1，没有则是0。</p>
<p>实现上可以用两个<span class="math inline">\(sum\)</span>数组记录东西和南北的移动量，二分去查找。</p>
<p>当然其实也有实现更简便的方法。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e6 + 10;
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n, r, c;
	cin &gt;&gt; n &gt;&gt; r &gt;&gt; c;
	string s;
	cin &gt;&gt; s;
	//n r-1
	//w c-1
	//s r+1
	//e c+1
	s = ' ' + s;
	vector&lt;int&gt; sum1(n + 1), sum2(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		sum1[i] = sum1[i - 1], sum2[i] = sum2[i - 1];
		if (s[i] == 'N') sum1[i] -= 1;
		if (s[i] == 'S') sum1[i] += 1;
		if (s[i] == 'W') sum2[i] -= 1;
		if (s[i] == 'E') sum2[i] += 1;
	}
//	for (int i = 1; i &lt;= n; i++) {
//		cout &lt;&lt; sum1[i] &lt;&lt; " \n"[i == n];
//	}
//	for (int i = 1; i &lt;= n; i++) {
//		cout &lt;&lt; sum2[i] &lt;&lt; " \n"[i == n];
//	}
	map&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt; mp;
	mp[ {0, 0}].push_back(1);
	for (int i = 1; i &lt;= n; i++) {
		mp[ {sum1[i], sum2[i]}].push_back(i + 1);
	}
	string ans;
	for (int i = 1; i &lt;= n; i++) {
		int x = sum1[i], y = sum2[i];
		int nex = x - r, ney = y - c;
		if (mp[ {nex, ney}].size() == 0 ) {
			ans += "0";
			continue;
		}
		if (mp[ {nex, ney}].back() &lt;= i) {
			ans += "1";
			continue;
		}
		int l = upper_bound(mp[ {nex, ney}].begin(), mp[ {nex, ney}].end(), i) - mp[ {nex, ney}].begin();
		if (mp[ {nex, ney}][l] &lt;= i) ans += "1";
		else {
			if (l != 0) l--;
			else {
				ans += "0";
				continue;
			}
			if (mp[ {nex, ney}][l] &lt;= i) ans += "1";
		}
	}
	cout &lt;&lt; ans &lt;&lt; '\n';
}
/*
10 1 2
NEESESWEES
2 2
2 1
2 0

6 -2 1
NNEEWS

*/
</code></pre>
</details>
<h1 id="e---tree-game-"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_e" title="E - Tree Game " target="_blank" rel="noopener nofollow">E - Tree Game </a></h1>
<p>交互题，通过对每个点<span class="math inline">\(bfs\)</span>可以将所有 $u -&gt;v $ 经过点集为偶数的组合记录下来，如果组合的数量是奇数那么是<span class="math inline">\(first\)</span>，否则是<span class="math inline">\(second\)</span>。然后根据对手操作输出合适的<span class="math inline">\((u,v)\)</span>。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e6 + 10;
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;int&gt;&gt; g(n + 10);
	vector&lt;int&gt; d(n + 10), e(n + 10);
	for (int i = 1; i &lt; n; i++) {
		int u, v;
		cin &gt;&gt; u &gt;&gt; v;
		d[u]++;
		e[v]++;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	queue&lt;pair&lt;int, int&gt;&gt; qq;
	map&lt;pair&lt;int, int&gt;, int&gt; mp;
	for (int i = 1; i &lt;= n; i++) {
		vector&lt;int&gt; st(n + 1), dis(n + 1, 0);
		queue&lt;int&gt; q;
		q.push(i);
		st[i] = 1;
		while (q.size()) {
			int u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (st[v] == 0) {
					q.push(v);
					st[v] = 1;
					dis[v] = dis[u] + 1;
				}
			}
		}
		for (int j = 1; j &lt;= n; j++) {
//			cout &lt;&lt; dis[j] &lt;&lt; " \n"[j == n];
			if (j != i) {
				if ((dis[j] + 1) % 2 == 0 &amp;&amp; dis[j] + 1 != 2) {
					if (mp[ {i, j}] == 0) {
						qq.push({i, j});
						mp[ {i, j}] = 1;
						mp[ {j, i}] = 1;
					}
				}
			}
		}
	}
	map&lt;pair&lt;int, int&gt;, int&gt; st;
//	cout &lt;&lt; qq.size() &lt;&lt; '\n';
	if (qq.size() % 2 == 1) {
		cout &lt;&lt; "First" &lt;&lt; endl;
		while (qq.size()) {
			while (qq.size() &amp;&amp; st[qq.front()] == 1) qq.pop();
			pair&lt;int, int&gt; t = qq.front();
			qq.pop();
			cout &lt;&lt; t.first &lt;&lt; ' ' &lt;&lt; t.second &lt;&lt; endl;
			int u, v;
			cin &gt;&gt; u &gt;&gt; v;
			st[ {u, v}] = 1;
			st[ {v, u}] = 1;
			if (u == -1 &amp;&amp; v == -1) return 0;
		}
	} else {
		cout &lt;&lt; "Second" &lt;&lt; endl;
		while (qq.size()) {
			int u, v;
			cin &gt;&gt; u &gt;&gt; v;
			st[ {u, v}] = 1;
			st[ {v, u}] = 1;
			if (u == -1 || v == -1) return 0;
			while (qq.size() &amp;&amp; st[qq.front()] == 1) qq.pop();
			if (qq.size() == 0)return 0;
			pair&lt;int, int&gt; t = qq.front();
			qq.pop();
			cout &lt;&lt; t.first &lt;&lt; ' ' &lt;&lt; t.second &lt;&lt; endl;
		}
		int u, v;
		cin &gt;&gt; u &gt;&gt; v;
		if (u == -1 &amp;&amp; v == -1) return 0;
	}
	return 0;
}
/*
6
1 2
2 3
3 4
4 5
5 6

5
1 2
1 3
2 4
2 5
*/
</code></pre>
</details>
<h1 id="f---abcba"><a href="https://atcoder.jp/contests/abc398/tasks/abc398_f" title="F - ABCBA" target="_blank" rel="noopener nofollow">F - ABCBA</a></h1>
<p>这个题就是比较简单，很容易想到找最长的 <span class="math inline">\([l,n]\)</span> 回文串，代码实现使用的哈希。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define ull unsigned long long
const int N = 1e6 + 10, base = 13331;
ull hs[N], pa[N], fhs[N], fpa[N];
ull get(int l, int r) {
	return hs[r] - hs[l - 1] * pa[r - l + 1];
}
ull getf(int l, int r) {
	return fhs[r] - fhs[l - 1] * fpa[r - l + 1];
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	string s;
	cin &gt;&gt; s;
	string yu = s;
	int n = s.size();
	s = ' ' + s;
	pa[0] = 1, fpa[0] = 1;
	for (int i = 1; i &lt;= n; i++) {
		pa[i] = pa[i - 1] * base;
		hs[i] = hs[i - 1] * base + s[i];
	}
	reverse(yu.begin(), yu.end());
	string fs = yu;
	reverse(yu.begin(), yu.end());
	fs = ' ' + fs;
	for (int i = 1; i &lt;= n; i++) {
		fpa[i] = fpa[i - 1] * base;
		fhs[i] = fhs[i - 1] * base + fs[i];
	}
	int k = n;
	for (int i = 1; i &lt;= n; i++) {
		ull a = get(i, n);
		ull b = getf(1, n - i + 1);
		if (a == b) {
			k = i - 1;
			break;
		}
	}
	string ans = yu;
	for (int i = k; i &gt;= 1; i--) {
		ans += s[i];
	}
	cout &lt;&lt; ans &lt;&lt; '\n';
}
/*
*/
</code></pre>
</details>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.006954726229166667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-26 22:06">2025-03-26 22:05</span>&nbsp;
<a href="https://www.cnblogs.com/ZhangDT">ZhangDT</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18794901" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18794901);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18794901', targetLink: 'https://www.cnblogs.com/ZhangDT/p/18794901', title: 'UNIQUE VISION Programming Contest 2025 Spring (AtCoder Beginner Contest 398) (A~F) 补题+题解' })">举报</a>
</div>
        