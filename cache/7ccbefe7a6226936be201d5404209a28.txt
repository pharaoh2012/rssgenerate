
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MrHanBlog/p/18706316" title="发布于 2025-02-09 17:18">
    <span role="heading" aria-level="2">网站集成微信公众号（订阅号）登录</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>前一阵子，想着给<a href="https://www.xiandanplay.com/" target="_blank" rel="noopener nofollow">我的站点</a>集成一个微信登录，因为我之前从未有过微信相关的开发，所以我自己跟着网上的资料，一步一步的慢慢的摸索，过程不免的遇到了许多坑，才把我的网站微信登录集成完成，所以这里分享一下我的摸索的过程。<strong>因为我的是订阅号，所以一下的内容均针对订阅号而言的</strong>。</p>
<h2 id="一了解微信的交互流程">一、了解微信的交互流程</h2>
<p>这里假设我们都已经申请号了微信开发的相关信息，那么我们就要配置微信认证服务器地址（api地址），这一步是必须的，微信与我们交互都是都是通过这一个地址，开始我一直不知道，我以为自己要对每一个功能都要写一个api，其实不需要的。我们只需要完成我们的微信认证服务器地址，然后里面处理我们相关的业务逻辑。<br>
<img src="https://img2024.cnblogs.com/blog/994611/202502/994611-20250209171426798-1744355540.png" alt="" loading="lazy"></p>
<div class="mermaid">sequenceDiagram
  用户-&gt;&gt;微信: 发送消息“hello!”
  微信-&gt;&gt;我的网站: 认证服务api校验
  我的网站-)微信: 校验成功
  微信-&gt;&gt;我的网站: 发送“hello!”到认证服务api
  我的网站-)业务逻辑: 认证服务api接收“hello!”并且处理业务逻辑
 我的网站--&gt;&gt; 用户: 也可返回给用户相关信息
</div><p>用我的话就是<br>
假设我的认证api是：/api/check<br>
1.用户发送消息”你好“到微信公众号<br>
2.微信公众号发起Get请求调用 /api/check 进行认证<br>
3.认证成功时微信公众号再次Post请求调用/api/check，并且携带”你好“信息<br>
4./api/check接口里面处理相关业务逻辑，或者返回特定信息给用户</p>
<h2 id="二集成相关sdk">二、集成相关sdk</h2>
<p>对于微信的消息处理，其实有点复杂，这里我网上搜了一下，大部分推荐的是<a href="https://sdk.weixin.senparc.com/Docs/Work/" target="_blank" rel="noopener nofollow">盛派微信sdk</a>,博客园也有相关的教程<a href="https://www.cnblogs.com/szw/archive/2013/05/20/3089479.html" target="_blank">https://www.cnblogs.com/szw/archive/2013/05/20/3089479.html</a>，个人用起来我觉得还是可以的，可以省去我们大部分工作，专注处理业务逻辑。</p>
<h3 id="封装custommessagehandler">封装CustomMessageHandler</h3>
<p>首先我是要对盛派微信sdk的封装，所以我新建了一个CustomMessageHandler，然后继承自MessageHandler<defaultmpmessagecontext>，然后重新DefaultResponseMessage方法，这里比较简单，直接</defaultmpmessagecontext></p>
<p>public override IResponseMessageBase DefaultResponseMessage(IRequestMessageBase requestMessage)<br>
{<br>
var responseMessage = base.CreateResponseMessage<responsemessagetext>();<br>
return responseMessage;<br>
}</responsemessagetext></p>
<h3 id="处理用户关注事件">处理用户关注事件</h3>
<p>当微信用户关注公众号时我需要发送问候语给用户，那么这里就需要重写OnEvent_SubscribeRequestAsync<br>
public override Task<iresponsemessagebase> OnEvent_SubscribeRequestAsync(RequestMessageEvent_Subscribe requestMessage)<br>
{<br>
var responseMessage = base.CreateResponseMessage<responsemessagetext>();<br>
responseMessage.Content = “欢迎关注”;<br>
return Task.FromResult(responseMessage as IResponseMessageBase);<br>
}</responsemessagetext></iresponsemessagebase></p>
<h3 id="处理用户关键字">处理用户关键字</h3>
<p>当微信用户给公众号发送特点消息（关键字）时，我需要回复用户，那么就重写OnTextRequestAsync<br>
public override Task<iresponsemessagebase> OnTextRequestAsync(RequestMessageText requestMessage)<br>
{<br>
var responseMessage = base.CreateResponseMessage<responsemessagetext>();<br>
return Task.FromResult(responseMessage as IResponseMessageBase);<br>
}</responsemessagetext></iresponsemessagebase></p>
<h3 id="抽离业务逻辑方法">抽离业务逻辑方法</h3>
<p>在开发中，我们往往希望封装一个功能时，不需要牵扯太多业务逻辑，就例如不想在CustomMessageHandler里去写业务逻辑，那么我这里采用的委托的形式，新建一个CustomParam，然后里面定义一个两个委托</p>
<pre><code class="language-C#"> public class CustomParam
    {
        /// &lt;summary&gt;
        /// 普通文本事件处理
        /// &lt;/summary&gt;
        public Func&lt;RequestMessageText, ResponseMessageText, string, ResponseMessageText&gt; OnTextFunc;
        /// &lt;summary&gt;
        /// 订阅事件处理
        /// &lt;/summary&gt;
        public Func&lt;string&gt; OnSubscribeFunc;
    }
</code></pre>
<p>然后通过CustomMessageHandler的构造函数传入</p>
<pre><code class="language-C#">        private CustomParam customParam;
        public CustomMessageHandler(CustomParam customParam)
        {
            this.customParam = customParam;
        }
</code></pre>
<p>然后在具体的处理事件里面调用这个委托<br>
<img src="https://www.xiandanplay.com/qniu/2025/2/9/0b8b7abd9d3e419ba8ca747ef817fa70.png" alt="" loading="lazy"></p>
<h3 id="通过接口调用微信custommessagehandler的方法">通过接口调用微信CustomMessageHandler的方法</h3>
<p>我接着在建一个接口，里面包含了认证，消息处理，创建CustomMessageHandler的方法，来给业务调用</p>
<pre><code class="language-C#">using Core.WeXin.WxOfficial;
using Senparc.Weixin.AspNet.MvcExtension;
using Senparc.Weixin.MP.Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Core.WeXin
{
    public interface IWxCommonHandler
    {
        /// &lt;summary&gt;
        /// 校验服务
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        bool CheckSign(string signature, string timestamp, string nonce, string echostr);
        /// &lt;summary&gt;
        /// 创建消息处理器
        /// &lt;/summary&gt;
        /// &lt;param name="inputStream"&gt;&lt;/param&gt;
        /// &lt;param name="messageAbsService"&gt;&lt;/param&gt;
        void CreateMessageHandler(Stream inputStream, CustomParam param);
        /// &lt;summary&gt;
        /// 公众号消息处理
        /// &lt;/summary&gt;
        /// &lt;param name="inputStream"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task&lt;WeixinResult&gt; ExecuteMessageHandler();
        /// &lt;summary&gt;
        /// 获取当前opentid
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        string GetOpenId();
        /// &lt;summary&gt;
        /// 获取微信消息
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        string GetMessgeText();
    }
}

</code></pre>
<pre><code class="language-C#">using Core.Log;
using Core.WeXin.WxOfficial;
using Microsoft.Extensions.Configuration;
using Senparc.NeuChar;
using Senparc.NeuChar.Entities;
using Senparc.Weixin.AspNet.MvcExtension;
using Senparc.Weixin.MP;
using Senparc.Weixin.MP.Entities;
using System;

namespace Core.WeXin
{
    internal class WxCommonHandler:IWxCommonHandler
    {
        private CustomMessageHandler customMessageHandler = null;
        private IConfiguration configuration; 
        public WxCommonHandler(IConfiguration configuration)
        {
          this.configuration = configuration;
        }
        public bool CheckSign(string signature, string timestamp, string nonce, string echostr)
        {
            string token = configuration.GetSection("SenparcWeixinSetting:Token").Value;
            return CheckSignature.Check(signature, timestamp, nonce, token);
        }
        public void CreateMessageHandler(Stream inputStream,CustomParam customParam)
        {
            customMessageHandler = new CustomMessageHandler(inputStream, null, customParam);
            customMessageHandler.OmitRepeatedMessage = true;
        }
        public async Task&lt;WeixinResult&gt; ExecuteMessageHandler()
        {
            await customMessageHandler.ExecuteAsync(new CancellationToken());
            string result = "";
            if (customMessageHandler.ResponseDocument != null)
            {
                 result = customMessageHandler.ResponseDocument.ToString();
            }
            return new WeixinResult(result);
        }

        public string GetOpenId()
        {
            return customMessageHandler.OpenId;
        }
        public string GetMessgeText()
        {
            var requestMsg= customMessageHandler.RequestMessage;
            if (requestMsg.MsgType == RequestMsgType.Text)
            {
                RequestMessageText requestText = requestMsg as RequestMessageText;
                return requestText.Content;
            }
            return string.Empty;
        }
    }
}

</code></pre>
<h3 id="注册微信sdk相关内容">注册微信sdk相关内容</h3>
<pre><code class="language-C#">using Core.Log;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Senparc.CO2NET;
using Senparc.CO2NET.AspNet;
using Senparc.Weixin.AspNet;
using Senparc.Weixin.Entities;
using Senparc.Weixin.MP;
using Senparc.Weixin.RegisterServices;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Core.WeXin
{
    public static class ConfigureWxService
    {
        public static IServiceCollection AddWxOfficialServices(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddScoped&lt;IWxCommonHandler, WxCommonHandler&gt;();
            services.AddSenparcWeixinServices(configuration);
            return services;
        }
        public static void UseWxOfficial(this WebApplication app, ConfigurationManager configuration)
        {
            var registerService = app.UseSenparcWeixin(app.Environment, null, null, register =&gt; { },
                (register, weixinSetting) =&gt;
                {
                    register.RegisterMpAccount(weixinSetting, configuration.GetSection("WxOfficialName").Value);
                });
        }
    }
}

</code></pre>
<h2 id="二新建认证apiget请求">二、新建认证api(Get请求)</h2>
<p>前面说到，我们和微信打交道始终是这一个微信，所以我们需要用一个api既能接收认证又能接收消息，所以我先建一个Get请求的方法</p>
<pre><code class="language-C#">  [HttpGet("handler")]
   public ContentResult Handler()
        {
            string signature = Request.Query["signature"];
            string timestamp = Request.Query["timestamp"];
            string nonce = Request.Query["nonce"];
            string echostr = Request.Query["echostr"];
            if (wxCommonHandler.CheckSign(signature, timestamp, nonce, echostr))
            {
                return new ContentResult()
                {
                    Content = echostr
                };
            }
            else
            {
                return new ContentResult()
                {
                    Content = "false"
                };
            }
        }

</code></pre>
<h2 id="三新建微信处理的service">三、新建微信处理的Service</h2>
<h3 id="关注事件业务">关注事件业务</h3>
<p>我想在用户关注时发送对应的问候语，则我直接新建一个方法OnSubscribeEvent</p>
<pre><code class="language-C#">     public string OnSubscribeEvent()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("您好！欢迎关注【闲蛋】💖\r\n");
            sb.Append("回复[登录]即可获取验证码登录网页&lt;a href=\"https://www.xiandanplay.com\"&gt;闲蛋&lt;/a&gt;🌟\r\n");
            sb.Append("更好的网站体验请用电脑登录😂😂\r\n");
            sb.Append("关于闲蛋，点这里👉：&lt;a href=\"https://mp.weixin.qq.com/s/TNBr9XiLbPJU3ZFRT3cCbg\"&gt;关于闲蛋&lt;/a&gt;\r\n");
            sb.Append("关于站长，点这里👉：&lt;a href=\"https://mp.weixin.qq.com/s/4KvydAbogv2KZGBfNmRveA\"&gt;关于站长&lt;/a&gt;\r\n");
            sb.Append("祝大家生活平平安安，不求多财但求无疾😜😜");
            return sb.ToString();
        }
</code></pre>
<h3 id="关键字登录">关键字登录</h3>
<p>因为我的是订阅号，无法获取实现微信登录，于是我只好通过回复关键字的形式，获取登录验证码，然后获取到openid来注册用户，所以我的处理步骤如下：<br>
1.匹配到关键字“登录”<br>
2.根据当前的当前的openid判断redis的Set是否已有对应的验证吗，如果已存在直接返回“请勿重复获取验证码”<br>
3.为了防止生成重复的有效的验证码，所以我新建一个Key，值为loginCode的Set类型的缓存，当生成的验证码可以从redis取到，则从新生成。（目前木有想到更好的办法，请赐教...）<br>
4.将Set的Key、 验证码loginCode，放入redis，存为Set类型，过期时间为1分钟，此处是为了步骤3的校验<br>
5.再新建一个Set的Key、 openid，放入redis，过期时间为1分钟，此处是为了步骤2的校验，<br>
6.再新建一个HashSet的Key、loginCode、 openid，放入redis，过期时间为1分钟,然后输入验证码登录的时候直接根据这个缓存来</p>
<pre><code class="language-C#"> public ResponseMessageText OnTextEvent(RequestMessageText requestMessageText,ResponseMessageText responseMessageText,string openId)
        {
            try
            {
                requestMessageText.StartHandler().Keyword("登录", () =&gt;
                {
                    if (cacheClient.ExistsSet(CheckRepeatGetLoginCodeKey, openId))
                        responseMessageText.Content = $"您好：请勿重复获取验证码";
                    else
                    {
                        string verCode = OnLoginVerCode(openId);
                        responseMessageText.Content = $"您好：您的网站登录验证码是 {verCode} 有效期60秒";
                    }
                    return responseMessageText;
                });
                return responseMessageText;
            }
            catch (Exception ex)
            {
                LogUtils.LogError(ex);
                throw;
            }

        }
 private string OnLoginVerCode(string openId)
        {
            string loginCode = StringUtil.RandomNumber(4);
            string cacheKey = "login_wx_code";
            bool existCode = false;
            do
            {
                existCode = cacheClient.ExistsSet(cacheKey, loginCode);
                if (!existCode)
                {
                    TimeSpan expire = TimeSpan.FromMinutes(1);
                    cacheClient.AddSet(cacheKey, loginCode, expire);
                    cacheClient.AddSet(CheckRepeatGetLoginCodeKey, openId, expire);
                    cacheClient.AddHash(CacheKey.WxLoginCodeKey, loginCode, openId, expire);
                }

            }
            while (existCode);
            return loginCode;
        }
</code></pre>
<h2 id="四新建认证apipost请求">四、新建认证api(Post请求)</h2>
<pre><code class="language-C#">        [HttpPost("handler")]
        public async Task&lt;ContentResult&gt; Handler(string signature, string timestamp, string nonce, string echostr)
        {
            if (!wxCommonHandler.CheckSign(signature, timestamp, nonce,echostr))
            {
                return new ContentResult()
                {
                    Content = "参数错误"
                };
            }
            CustomParam customParam = new CustomParam()
            {
                OnSubscribeFunc = wxService.OnSubscribeEvent,
                OnTextFunc = wxService.OnTextEvent
            };
            wxCommonHandler.CreateMessageHandler(Request.Body, customParam);
            return  await wxCommonHandler.ExecuteMessageHandler();
        }
</code></pre>
<p>wxService就是前面的封装的方法</p>
<h2 id="五登录验证">五、登录验证</h2>
<p>比较简单，就是根据验证码，能否从缓存取到对应的信息</p>
<pre><code class="language-C#">           Regex regex = new Regex(RegexPattern.IsNumberPattern);
            if (!regex.IsMatch(code.Trim()) || code.Length != 4)
                throw new ValidationException("code 无效");
            CacheClient cacheClient = CacheClient.CreateClient();
            string openId= cacheClient.GetHashValue("Wx_Login_Hash_Key", code);
            if (string.IsNullOrEmpty(openId))
                throw new AuthException("验证码无效");
            WeXinUserInfo weXinUserInfo = new WeXinUserInfo();
            weXinUserInfo.OpenAuthEnum = OpenAuthEnum.Wexin;
            weXinUserInfo.Nickname = "wx_" + StringUtil.RandomNumber(10);
            weXinUserInfo.OpenID = openId;
            weXinUserInfo.Sex = "男";
            cacheClient.DeleteHashField("Wx_Login_Hash_Key", code);
            return await Task.FromResult(weXinUserInfo);
</code></pre>
<h2 id="六成果展示">六、成果展示</h2>
<p><img src="https://img2024.cnblogs.com/blog/994611/202502/994611-20250209175731517-1995981136.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/994611/202502/994611-20250209175743527-1549148385.png" alt="" loading="lazy"></p>
<p>目前为止，微信公众号已经开发完成，因为我没有过相关开发的经验，所以如果有不合适的地方，大家可以指出来。</p>
<p><strong>同时我有个疑问请教一下大家，就是发布到服务器上后我用明文模式可以正常处理微信消息，但是安全模式却不行了，也正确的配置了相关的EncodingAESKey</strong></p>
<blockquote>
<p>作者：程序员奶牛 <br><br>
个人开源网站<a href="https://www.xiandanplay.com" target="_blank" rel="noopener nofollow">：https://www.xiandanplay.com</a><br>
源码地址<a href="https://gitee.com/MrHanchichi/xian-dan" target="_blank" rel="noopener nofollow">：https://gitee.com/MrHanchichi/xian-dan</a></p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.492122774430555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 14:29">2025-02-09 17:18</span>&nbsp;
<a href="https://www.cnblogs.com/MrHanBlog">灬丶</a>&nbsp;
阅读(<span id="post_view_count">49</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18706316" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18706316);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18706316', targetLink: 'https://www.cnblogs.com/MrHanBlog/p/18706316', title: '网站集成微信公众号（订阅号）登录' })">举报</a>
</div>
        