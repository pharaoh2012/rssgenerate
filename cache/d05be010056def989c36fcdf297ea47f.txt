
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/podongfeng/p/18801765" title="发布于 2025-03-31 11:00">
    <span role="heading" aria-level="2">leetcode每日一题：数组美丽值求和</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/890809/202503/890809-20250331105937910-1731170099.jpg" alt="image" loading="lazy"></p>
<h2 id="引言">引言</h2>
<p>​		今天的每日一题原题是<a href="https://leetcode.cn/problems/percentage-of-letter-in-string/" target="_blank" rel="noopener nofollow">2278. 字母在字符串中的百分比</a>，直接模拟，逐个匹配，统计<code>letter</code>在原始字符串<code>s</code>中出现的次数，然后再计算所占百分比即可。更换成前几天遇到的更有意思的一题来写这个每日一题。</p>
<h2 id="题目">题目</h2>
<p><a href="https://leetcode.cn/problems/sum-of-beauty-in-the-array/" target="_blank" rel="noopener nofollow">2012. 数组美丽值求和</a></p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>
<ul>
<li><code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>
<li><code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>
<li><code>0</code>，如果上述条件全部不满足</li>
</ul>
<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 <strong>美丽值的总和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,3]
输出：2
解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :
- nums[1] 的美丽值等于 2
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [2,4,6,4]
输出：1
解释：对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :
- nums[1] 的美丽值等于 1
- nums[2] 的美丽值等于 0
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [3,2,1]
输出：0
解释：对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :
- nums[1] 的美丽值等于 0
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="思路">思路</h2>
<p>​		首先还是读懂题目，对于符合<code>1 &lt;= i &lt;= nums.length - 2</code>的下标i，美丽值可能有3种情况：</p>
<ul>
<li>美丽值 = 2，对于在i位置前面的数，都严格小于<code>nums[i]</code>；且在i位置后面的数，都严格大于<code>nums[i]</code></li>
<li>美丽值 = 1，无法满足第1种情况下，且可以满足<code>nums[i]</code>前面的1个数严格小于它，后面的1个数严格大于它</li>
<li>美丽值 = 0，排除上述2种情况的其他情况</li>
</ul>
<p>​		那么对于每个在范围内的<code>i</code>，我们要逐个判断美丽值：对于情况1，如果每个都去比较，判断单个i需要的时间复杂度是<code>O(n)</code>，整体的时间复杂度就是<code>O(n^2)</code>；对于情况2，只要判断前后，判断单个i的时间复杂度是<code>O(1)</code>；对于情况3，在上述2种情况都判断后，不再需要单独判断。</p>
<p>​		由此可见，我们主要优化点在于如何快速判断情况1。构造2个辅助数组，<code>prefixMax[]</code>和<code>suffixMin[]</code>，<code>prefixMax[i]</code>表示下标<code>[0, i]</code>范围内的最大值，<code>suffixMin[i]</code>表示下标<code>[i, n-1]</code>范围内的最小值。有了这2个辅助数组后，对于位置i我们在判断是否满足情况1的时间，只要判断条件 <code>prefixMax[i-1] &lt; nums[i] &amp;&amp; nums[i] &lt; suffixMin[i+1]</code> 即可，这样每次判断的时间复杂度会缩减到<code>O(1)</code>，判断范围内的i的时间复杂度是<code>O(n)</code>。而构建这2个辅助数组，需要分别从前往后和从后往前遍历原始数组，时间复杂度也是<code>O(n)</code>。这样，我们就避免了<code>O(n^2)</code>的时间复杂度。</p>
<p>​		进一步来看，如果我们从前往后处理<code>i</code>的话，<code>prefixMax[]</code>数组不需要被创建，只要滚动维护一个<code>prefixMax</code>的变量，表示<code>[0, i]</code>范围内的最大值即可，这样，可以省下一个大小为n的数组的空间开销。同理，如果从后往前处理<code>i</code>的话，可以省下<code>suffixMin[]</code>的空间。不过，这2者不可兼得。</p>
<h4 id="图解">图解</h4>
<p><img src="https://img2024.cnblogs.com/blog/890809/202503/890809-20250331105946610-303752929.png" alt="image" loading="lazy"></p>
<h4 id="代码">代码</h4>
<p><img src="https://img2024.cnblogs.com/blog/890809/202503/890809-20250331105953026-853759747.png" alt="image" loading="lazy"></p>
<pre><code class="language-java">class Solution {
    public int sumOfBeauties(int[] nums) {
        int[] min = getMin(nums);
        int sum = 0;
        int max = nums[0];
        for (int i = 1; i &lt; nums.length - 1; i++) {
            if (nums[i] &gt; max &amp;&amp; nums[i] &lt; min[i + 1]) {
                sum += 2;
            } else if (nums[i] &gt; nums[i - 1] &amp;&amp; nums[i] &lt; nums[i + 1]) {
                sum += 1;
            }
            // 求出遍历到下一个i时，nums[0,i-1]的最大值
            max = Integer.max(max, nums[i]);
        }
        return sum;
    }

    /**
     * 从后往前，求出当前下标到数组结尾的最小值
     */
    private int[] getMin(int[] nums) {
        int n = nums.length;
        int[] min = new int[n];
        min[n - 1] = nums[n - 1];
        for (int i = n - 2; i &gt;= 0; i-- ) {
            min[i] = Integer.min(min[i+1], nums[i]);
        }
        return min;
    }
}
</code></pre>
<h4 id="耗时">耗时</h4>
<p><img src="https://img2024.cnblogs.com/blog/890809/202503/890809-20250331110001968-1867638571.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0025835385925925924" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 11:01">2025-03-31 11:00</span>&nbsp;
<a href="https://www.cnblogs.com/podongfeng">podongfeng</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18801765" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18801765);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18801765', targetLink: 'https://www.cnblogs.com/podongfeng/p/18801765', title: 'leetcode每日一题：数组美丽值求和' })">举报</a>
</div>
        