
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Garfield-cat/p/18803269" title="发布于 2025-03-31 23:18">
    <span role="heading" aria-level="2">harmonyOS基础- 快速弄懂HarmonyOS ArkTs基础组件、布局容器（前端视角篇）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>大家好！我是黑臂麒麟，一位6年的前端；</p>
</blockquote>
<blockquote>
<p>if you're change the world, you're workingon important things.  you're excited to get up in the norning.</p>
</blockquote>
<h1 id="一常用基础组件">一、常用基础组件</h1>
<h2 id="1基础组件">1.基础组件</h2>
<p>简单列举常用的及含义，掌握了以下按钮可以解决日常简单场景需求。其他在使用时查询<code>ArkTS</code>的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/reference-document-outline-0000001115016824" target="_blank" rel="noopener nofollow">API文档</a>即可。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Text()</td>
<td>显示一段文本的组件。</td>
</tr>
<tr>
<td>Image()</td>
<td>图片组件，支持本地图片和网络图片的渲染展示</td>
</tr>
<tr>
<td>TextInput()</td>
<td>单行文本输入框组件。</td>
</tr>
<tr>
<td>Button()</td>
<td>按钮</td>
</tr>
<tr>
<td>Blank</td>
<td>空白填充组件，在容器主轴方向上，空白填充组件具有自动填充容器空余部分的能力。仅当父组件为Row/Column时生效。</td>
</tr>
<tr>
<td>LoadingProgress</td>
<td>显示加载进展</td>
</tr>
<tr>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="2文本样式">2.文本样式</h2>
<p><code>ArkTS</code>的样式以驼峰命名方式，这里以<code>Text</code>组件为例：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>参数类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fontColor</td>
<td>ResourceColor</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>fontSize</td>
<td>Length or Resource</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>fontStyle</td>
<td>FontStyle</td>
<td>设置文本的字体样式。默认值：FontStyle.Normal。</td>
</tr>
<tr>
<td>fontWeight</td>
<td>numbe or FontWeight or string</td>
<td>设置文本的字体粗细，number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如“400”，以及“bold”、“bolder”、“lighter”、“regular”、“medium”，分别对应FontWeight中相应的枚举值。默认值：FontWeight.Normal。</td>
</tr>
</tbody>
</table>
<p>下面代码是两个Text组件，分别是默认样式和设置了文本样式的对比。</p>
<pre><code class="language-typescript">@Entry
@Component
struct Index {
  @State message: string = 'Hello World';
  @State myText: string = 'World';

  build() {
    Row() {
      Column(){
        Text('ArkTs')
        Text('ArkTs')
          .fontColor(Color.Blue)
          .fontSize(40)
          .fontWeight(FontWeight.Bold)
          .fontFamily('Arial')
      }
    }
    .justifyContent(FlexAlign.Center)
    .backgroundColor(0xF1F3F5)
    .width('100%')
    .height('100%')
  }
}
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7f030a8be87a26a66c61770431ec260c.png" alt="在这里插入图片描述" loading="lazy"><br>
以上ArkTs代码的样式使用<code>驼峰格式</code>；其他组件的样式也是一样。使用时查阅具体用法。</p>
<h2 id="3image">3.Image</h2>
<p>这里着重说一下Image的图片地址的<code>引入方式</code>，方式如下：<br>
<code>Image(src: string|PixelMap|Resource)</code><br>
(1).使用string数据加载网络图片</p>
<pre><code class="language-typescript">Image(‘https://www.example.com/xxx.png’)
</code></pre>
<p>这里要注意<code>Image</code>在使用网络图片的时候，需要要在<code>module.json5</code>文件中声明网络访问权限</p>
<pre><code class="language-typescript">// module.json5
{
  "module": {
   	"requestPermissions": [
  		"name": "ohos.permisssion.INTERNET"	
  	]
  }
}
</code></pre>
<p>(2).使用<code>PixelMap</code>数据加载图片</p>
<pre><code class="language-Typescript">Image(pixelMapObject)
</code></pre>
<p>(3)使用Resource数据加载图片</p>
<pre><code class="language-typescript">Image($r('app.media.logo'))
</code></pre>
<p>上面的Resource是一种资源引入类型。会在下面详细描述。</p>
<h2 id="4使用资源引用类型">4.使用资源引用类型</h2>
<p><code>Resource</code>是资源引用类型，用于设置组件属性的值。<code>ArkTs文档推荐优先使用Resource类型</code>，将资源文件（字符串、图片、音频等）统一存放于<code>resources</code>目录下，便于开发者统一维护。同事系统可以根据当前配置加载合适资源，例如，开发者根据屏幕尺寸呈现不同的布局效果，或根据语言提供不同的字符串。<br>
已上面Text组件代码为例：</p>
<pre><code class="language-typescript">Text('ArkTs')
  .fontColor(Color.Blue)
  .fontSize(40)
  .fontWeight(FontWeight.Bold)
  .fontFamily('Arial')
</code></pre>
<h3 id="1对元素内文本字符串的管理">(1).对元素内文本字符串的管理；</h3>
<p>可以将这些编码写到entry/src/main/resources下的资源文件中。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/5c45ffa1408c7d63d076f66f676407cd.png" alt="在这里插入图片描述" loading="lazy"><br>
在string.json中定义Button显示的文本<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/cc00c9d331bbfb284000c2aa94d2c08b.png" alt="在这里插入图片描述" loading="lazy"><br>
就个人而言，不太喜欢这种方式相对于前端喜欢而言。<br>
在<code>float.json</code>中定义<code>Text</code>的字体样式。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/500718965e58532e7e1215659dc14be1.png" alt="在这里插入图片描述" loading="lazy"><br>
在color.json中定义Text的字体颜色。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/d2fde25009b70d7c1777e8ddd2c3ceb4.png" alt="在这里插入图片描述" loading="lazy"><br>
然后再Text组件通过<code>$r('app.type.name)</code>的形式引用应用资源。app带表应用内resources目录中定义的资源；<code>type</code>代表资源类型（或资源的存放位置），可以取“color”，“float”、“string”、“plural”、“media”; 以上几种是固定的，不支持自定义命名文件引用。name代表资源命名，由开发者定义资源时确定的。</p>
<pre><code class="language-typescript">Text($r('app.string.Index_Text'))
  .fontColor($r('app.color.Text_color'))
  .fontSize($r('app.float.Text_fontSize'))
  .fontWeight(FontWeight.Bold)
  .fontFamily($r('app.float.Text_fontFamily'))
</code></pre>
<p>以上是简单的描述<code>Resource</code>引用方式，后面回单独出一期深入研究的<code>Resource</code>引入文章。</p>
<h1 id="二布局组件">二、布局组件</h1>
<p>前端常用布局方式<code>header、side、main、footer</code>等标签，还有布局样式<code>flex</code>、<code>grid</code>等，在<code>ArkTs</code>常用布局组件有一下几种：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Column</td>
<td>垂直方向布局的容器</td>
</tr>
<tr>
<td>Row</td>
<td>水平方向布局的容器</td>
</tr>
<tr>
<td>List</td>
<td>列表容器</td>
</tr>
<tr>
<td>Grid</td>
<td>网格容器</td>
</tr>
<tr>
<td>Tabs</td>
<td>页签容器</td>
</tr>
<tr>
<td>Swiper</td>
<td>滑块视图容器</td>
</tr>
<tr>
<td>Scroll</td>
<td>可滑动的容器</td>
</tr>
</tbody>
</table>
<p>这里说一下<code>List</code>，<code>Grid</code>，<code>Tabs</code>，<code>Column</code>、<code>Row</code>使用方法，Swiper、Scroll布局组件相对简单详见Api文档。有点类似小程序的类似组件。</p>
<h2 id="1-columnrow">1. Column&amp;Row</h2>
<h3 id="布局容器概念">布局容器概念</h3>
<p>线性布局容器表示垂直方向或者水平方向排列子组件的容器，<code>ArkTs</code>提供了<code>Column</code>和<code>Row</code>容器来实现线性布局。</p>
<h3 id="主轴和交叉轴概念">主轴和交叉轴概念</h3>
<p>在布局容器中，默认存在两根轴，分别是主轴和交叉轴，这两个轴始终是相互垂直的。不同的容器中主轴的方向不一样的。</p>
<ul>
<li><strong>主轴</strong>：在Column容器中的子组件是按照<code>从上到下</code>的垂直方向布局，其主轴的方向是垂直方向；在Row容器中的组件时按照<code>从左到右</code>的水平方向布局的，其主轴的方向时水平方向。<br>
下图时Column&amp;Row容器交叉轴<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/ea783904e9aac81e76a465dcf620f836.png#pic_center" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<h3 id="属性">属性</h3>
<p>Column&amp;Row容器的两个属性justifyContent和alignItems，类似CSS的flex或Grid的justify-content和align-item。这样容易让我们前端快速理解。<br>
这里注意一下它们的属性值都要<code>首字母大写</code>。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>justifyContent</td>
<td>设置子组件在主轴方向上的对齐格式</td>
</tr>
<tr>
<td>alignItems</td>
<td>设置子组件在交叉轴方向上的对齐格式</td>
</tr>
</tbody>
</table>
<h4 id="主轴方向的对其justifycontent">主轴方向的对其（justifyContent）</h4>
<p>子组件在主轴方向上的使用<code>jusifyContent</code>属性来设置，其参数类型时<code>FlexAlign</code>。它有一下几种类型：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start</td>
<td>主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐</td>
</tr>
<tr>
<td>Center</td>
<td>主轴方向中心对齐，第一个元素与行首的距离以及最后一个元素与行尾距离相同</td>
</tr>
<tr>
<td>End</td>
<td>主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐</td>
</tr>
<tr>
<td>SpaceBetween</td>
<td>主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素与行首对齐，最后一个元素与行尾对齐</td>
</tr>
<tr>
<td>SpaceAround</td>
<td>轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半</td>
</tr>
<tr>
<td>SpaceEvenly</td>
<td>主轴方向等间距布局，无论是相邻元素还是边界元素到容器的间距都一样</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Start<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/7c5e306b51b8dcd14a62fa9d235b8801.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>Center<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/aef897a62715b322cad304a81d46bd37.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>End<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/48beb6b1bc2e78a7e98aa823e18a4b93.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>SpaceBetween<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/727d357d17700ac49f9d508651e46363.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>SpaceAround<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/d2a2c54fd99a5c9957d138667235c3dd.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>SpaceEvenly<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8901ec128c9e8ed6c9503463dee13af9.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
</ul>
<h4 id="交叉中方向对齐alignitems">交叉中方向对齐（alignItems）</h4>
<p>Column容器的主轴时垂直方向，交叉轴是水平方向，其参数类型为<code>HorizontalAlign</code>（水平对齐），<code>HorizontalAlign</code>定义了一下几个类型；</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start</td>
<td>水平方向上按照起始端对齐</td>
</tr>
<tr>
<td>Center</td>
<td>水平方向上居中对齐</td>
</tr>
<tr>
<td>End</td>
<td>水平方向上按照末端对齐</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>start<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/05d71d58fbe2ea44da22e37ed67ca2d6.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>Centent<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/ecdf6dca204e07f738d03750057b81de.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>End<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/e9b5db68edf1bdd73ad0b4a3976cdc85.png#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
Row容器的主轴是水平方向，交叉轴是垂直方向，其参数类型为VerticalAlign（垂直对其），VerticalAlign定义了一下几种类型：<br>
|属性值|描述|<br>
|--|--|<br>
|Top|垂直方向上居顶部对齐|<br>
|Center|竖直方向上居中对齐|<br>
|Bottom|竖直方向上居底部对齐|</p>
</li>
<li>
<p>Top<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/eadfd7c94c8f8cb6579c2ba58f19a124.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>Center<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/0bd171ee3cb30fc7bb732dcd5e00c3fa.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>Bottom<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/3409184260d23b8a9b18d167c4a4b9c3.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
</ul>
<h3 id="接口介绍">接口介绍</h3>
<p>Column&amp;Row都课接收一个参数<code>space</code>，表示子组件在主轴上的间距；</p>
<pre><code class="language-typescript">@Entry
@Component
struct Index {
  @State TextArr: Array&lt;string&gt; = ["Image", "Text", "TextInput", "Button"]

  build() {
    Column({space: 30}) { // 这里设置子元素主轴上的间距
      ForEach(this.TextArr, (item: string)=&gt; { // 利用ForEach渲染我们的字符串数组
        Row(){
          Text(item)
        }
        .width('80%')
        .height('100vp')
        .backgroundColor('#99b2df')
        .border({
          width: 5,
          color: '#8aa7da',
          style: BorderStyle.Solid
        })
        .justifyContent(FlexAlign.Center)
      })
    }
    .justifyContent(FlexAlign.Start)
    .backgroundColor('#bdd7ee')
    .width('100%')
    .height('100%')
  }
}
</code></pre>
<p>渲染出来的效果：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/2a678d01c194b782dc3c89137ef4b634.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="3-list使用">3. List使用</h2>
<h3 id="简介">简介</h3>
<p>使用频率很高的组件，需要配合<code>ListItem</code>子组件一起使用，列表每项对应一个<code>ListItem</code>组件<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/f5fadce9d1b79ac8acf14867691b08c6.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="使用foreach渲染">使用ForEach渲染</h3>
<p>渲染多时，可以使用ForEach来循环渲染我们的列表项；</p>
<pre><code class="language-typescript">@Entry
@Component
struct Index {
  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  build() {
    Column({space: 30}) {
      List({space: 10}) {
        ForEach(this.arr, (item: number)=&gt; {
          ListItem(){
            Text(`${item}`)
              .width('100%')
              .height(100)
              .fontSize(20)
              .fontColor(Color.White)
              .textAlign(TextAlign.Center)
              .backgroundColor(0x007DFF)
          }
        }, item =&gt; item)
      }
    }
    .padding(12)
    .height('100%')
    .backgroundColor(0xF1F3F5)
  }
}
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2e76ed6ac24f1bde5ed72a35e536fc8e.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="设置分割线">设置分割线</h3>
<p>这里如有需求可以给list组件可以使用<code>divider</code>属性给<code>ListItem</code>设置分割线。有四个参数：</p>
<ul>
<li>strokeWidth: 分割线宽度</li>
<li>color: 分割线颜色</li>
<li>startMargin: 分割线距离列表起始端的距离</li>
<li>endMargin: 分割线距离列表结束端的距离</li>
</ul>
<pre><code class="language-typescript">List({space: 50}) {
  ForEach(this.arr, (item: number)=&gt; {
    ListItem(){
      Text(`${item}`)
    }
  }, item =&gt; item)
}
.divider({
  strokeWidth: 5,
  color: '#d8d8d8',
  startMargin: 20,
  endMargin: 20,
 })
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/43a52bb27376b68324148c5aae6a3567.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="列表滚动事件监听">列表滚动事件监听</h3>
<p>List滚动监听事件和前端监听Scroll监听时间方法很像：</p>
<ul>
<li><code>onScroll</code>: 滑动触发，返回<code>scrollOffset</code>为滑动偏移量，<code>scrollState</code>为当前滑动状态。</li>
<li><code>onScrollIndex</code>: 滑动时触发，分别返回滑动起始索引值与滑动结束索引值。</li>
<li><code>onReachStart</code>: 列表到达起始位置时触发。</li>
<li><code>onReachEnd:</code> 列表到底末尾位置触发。</li>
<li><code>onScrollStrop</code>: 列表滑动结束时触发。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/46e8914ebfbdf6a3302878d5754a54f3.png" alt="在这里插入图片描述" loading="lazy"><br>
利用这些时间监听，并可以在<code>log</code>面板中打印出我们想要的滑动数据；</li>
</ul>
<h3 id="设置list排列方向">设置List排列方向</h3>
<p><code>List</code>组件排列可以垂直方向和水平方向排列，默认是垂直方向排列。如果想设置<code>List</code>为水平方向，可以使用<code>listDiretion</code>属性为Axis.Horizontal即可。</p>
<h2 id="4-grid">4. Grid</h2>
<h3 id="简介-1">简介</h3>
<p>如果前端学过css的grid布局模式，那大家一定不会对<code>Grid</code>组件布局陌生，接下来学习如何使用<code>Grid</code>网格布局组件。</p>
<h3 id="使用">使用</h3>
<p><code>Grid</code>组件是由“行”和“列”分割的单元格组成。<code>Grid</code>一般和<code>GridItem</code>一起使用。</p>
<pre><code class="language-typescript">@Entry
@Component
struct GridPage {
  private arr: string[] = new Array(9).fill('').map((_, index) =&gt; `item ${index + 1}`)

  build() {
    Column() {
      Grid() {
        ForEach(this.arr, (item: string) =&gt; {
          GridItem(){
            Text(item)
              .fontSize(16)
              .fontColor(Color.White)
              .backgroundColor(0x007DFF)
              .width('100%')
              .height('100%')
              .textAlign(TextAlign.Center)
          }
        }, (item: string) =&gt; item)
      }
      .columnsTemplate('1fr 1fr 1fr')
      .rowsTemplate('1fr 1fr 1fr')
      .columnsGap(10)
      .rowsGap(10)
      .height(300)
    }
    .width('100%')
    .padding(12)
    .backgroundColor(0xF1F3F5)
  }
}
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d3a32db33e60ed409860dff17f5b90e.png" alt="在这里插入图片描述" loading="lazy"><br>
这里我们同样跟List一样使用<code>ForEach</code>遍历出的数组，可以看到我们设置<code>columnsTemplate</code>属性垂直方向配置3等分个<code>1fr</code>，同样纵向<code>rowsTemplate</code>也是3等分的<code>1fr</code>，<code>1fr</code>代表所占Grid等分个数。<code>columnGap</code>和<code>rowGap</code>分别设置垂直和纵向元素之间的间距。这里分别设置了 <code>10vp</code>。</p>
<h2 id="5-tabs">5. Tabs</h2>
<h3 id="概述">概述</h3>
<p><code>Tabs</code>是我们常用的做视图切换的常用布局组件。如“底部页签”，“顶部标签”，平板的“侧边页签”等。</p>
<h3 id="使用-1">使用</h3>
<p><code>Tabs</code>组件仅含子组件TabContent，每一个页签对应内容视图即TabContent组件。<br>
结合之前我们写的<code>List</code>和<code>Grid</code>的组件，我们编写一个简单的<code>Tabs</code>布局</p>
<pre><code class="language-typescript">import Home from '../view/Home';
import GridPage from '../view/GridPage'
@Entry
@Component
struct Index {
  private controller: TabsController = new TabsController();

  build() {
    Column() {
      Tabs() {
        TabContent() {
          Home()
        }
        .tabBar('List')

        TabContent() {
          GridPage()
        }
        .tabBar('Grid')
      }
      .barWidth('100%') // 设置TabBar宽度
      .barHeight('60') // 设置TabBar高度
      .width('100%') 
      .height('100%')
      .backgroundColor(0xF5F5F5)
    }
    .width('100%')
    .height('100%')
  }
}
</code></pre>
<p>展示后的效果<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/f0f3ba94a924e89ed2394e4c8417c441.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/824549227ed63f0a5d0a6a2c70cbf9d7.png" alt="在这里插入图片描述" loading="lazy"><br>
上面代码，通过属性<code>width</code>和<code>height</code>设置了<code>Tabs</code>组件的宽高，使用<code>TabWidth</code>和<code>BarHeight</code>设置了<code>TabBar</code>的宽度和高度。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/3bf29e68d4478302d759084677ce7117.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="设置tabbar布局属性">设置TabBar布局属性</h3>
<p><code>Tabs</code>布局模式默认Fixed的，不支持滑动。如果页签过多会可能导致显示不全，讲布局模式设置为Scrollable的话，可以实现页签的滚动。</p>
<table>
<thead>
<tr>
<th>布局属性</th>
<th>描述</th>
<th>属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td>barMode</td>
<td>Tabs的布局模式</td>
<td>BarMode.Fixed （默认）:所有TabBar平均分配barWidth宽度。 <br>BarMode.Scrollable: 每个TabBar使用实际宽度，超过总长度后可滑动。</td>
</tr>
<tr>
<td>barPosition</td>
<td>设置TabBar位置和排列方向</td>
<td>BarPosition.Start，vertical属性为false（默认值）时，页签在顶部.vertical属性为true时，位于容器左侧。<br>BarPosition.End， vertical属性为false时，位于容器底部。vertical属性为true时，位于容器右侧。</td>
</tr>
</tbody>
</table>
<h3 id="自定义tabbar样式">自定义TabBar样式</h3>
<p>如果需要自定义<code>TabBar</code>， 需要通过@Builder装饰器的函数。构造一个生成自定义TabBar样式的函数，我们来实现上面底部页签效果：</p>
<pre><code class="language-typescript">import Home from '../view/Home';
import GridPage from '../view/GridPage'
@Entry
@Component
struct Index {
  private tabsController: TabsController = new TabsController();
  @State currentIndex: number = 0;


  @Builder TabBuilder(title: string, targetIndex: number, selectedImg: Resource, normalImg: Resource) {
    Column() {
      Image(this.currentIndex === targetIndex ? selectedImg : normalImg)
        .size({width: 25, height: 25})
      Text(title)
        .fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')
    }
    .width('100%')
    .height(50)
    .justifyContent(FlexAlign.Center)
    .onClick(() =&gt; {
      this.currentIndex = targetIndex;
      this.tabsController.changeIndex(this.currentIndex);
    })
  }
  build() {
    Column() {
      Tabs({barPosition: BarPosition.End, controller: this.tabsController}) {
        TabContent() {
          Home()
        }
        .tabBar(this.TabBuilder('List', 0, $r('app.media.home_selected'), $r('app.media.home_normal')))

        TabContent() {
          GridPage()
        }
        .tabBar(this.TabBuilder('List', 1, $r('app.media.mine_selected'), $r('app.media.mine_normal')))
      }
      .vertical(false)
      .barWidth("100%") // 设置TabBar宽度
      .barHeight(60) // 设置TabBar高度
      .width('100%')
      .height('100%')
      .backgroundColor(0xF5F5F5)
      .onChange((index: number) =&gt; {
        this.currentIndex = index;
      })
    }
    .width('100%')
    .height('100%')
  }
}
</code></pre>
<p>渲染后效果：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/eb7d3efab2ea7598ccb207baeb48ce77.png" alt="在这里插入图片描述" loading="lazy"><br>
将<code>barPosition</code>的值设置为<code>BarPosition.End</code>，使页签显示在底部。使用@Builder自定义TabBuilder函数，生成由Image和Text组成的页签。同时也给<code>Tabs</code>组件设置了<code>TabsController</code>控制器，当点击某个页签时，调用<code>changeIndex</code>方法进行页签内容切换。<br>
最后在Tabs添加onChange事件。切换时，把当前最近<code>Index</code>赋给currentIndex保存起来。</p>
<h1 id="参考">参考</h1>
<p>华为开发者联盟官网开发者<a href="https://developer.huawei.com/consumer/cn/training/" target="_blank" rel="noopener nofollow">基础课程</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04308994928356481" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 23:18">2025-03-31 23:18</span>&nbsp;
<a href="https://www.cnblogs.com/Garfield-cat">黑臂麒麟</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18803269" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18803269);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18803269', targetLink: 'https://www.cnblogs.com/Garfield-cat/p/18803269', title: 'harmonyOS基础- 快速弄懂HarmonyOS ArkTs基础组件、布局容器（前端视角篇）' })">举报</a>
</div>
        