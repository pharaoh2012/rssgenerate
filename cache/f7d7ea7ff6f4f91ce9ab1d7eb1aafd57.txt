
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SilverGo/p/19019364" title="发布于 2025-08-02 21:48">
    <span role="heading" aria-level="2">Ctorch开发日志——矩阵乘法优化及数学原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="随着项目的推进本作者遇到了目前最棘手的问题即矩阵乘法的优化">随着项目的推进，本作者遇到了目前最棘手的问题，即矩阵乘法的优化</h4>
<h4 id="但是有句话说得好">但是有句话说得好</h4>
<blockquote>
<p>“你越棘手，我越兴奋”</p>
</blockquote>
<h4 id="那么如下是本作者如何把的朴素矩阵乘法一步一步优化到-的全过程">那么，如下是本作者如何把<span class="math inline">\(O(MNK)\)</span>（<span class="math inline">\(O(n^3)\)</span>）的朴素矩阵乘法一步一步优化到<span class="math inline">\(O(n^{2.81})\)</span> 的全过程</h4>
<h2 id="测试环境">测试环境</h2>
<p><strong>macOS Tahoe 26 Beta 2</strong><br>
<strong>M3 Pro 11核</strong><br>
<strong>18GB</strong><br>
<strong>CLion &amp; Cmake</strong><br>
<strong>计时器：ctime</strong><br>
<strong>矩阵：1024 * 1024 @ 1024 * 1024</strong><br>
<strong>为保证准确，时间均为5次测量取平均值</strong></p>
<h2 id="朴素算法实现--测速">朴素算法实现 &amp; 测速</h2>
<h3 id="朴素实现的数学原理">朴素实现的数学原理</h3>
<p>其实就是把矩阵乘的数学公式重写一遍：</p>
<p></p><div class="math display">\[A={\left[ a_{ij}\right]_{m \times n}} 
\]</div><p></p><p></p><div class="math display">\[B={\left[ b_{ij}\right]_{n \times s}} 
\]</div><p></p><p></p><div class="math display">\[C= {A \times  B}=\left[ c_{ij}\right]_{m \times s} 
\]</div><p></p><p></p><div class="math display">\[= \left[ \sum \limits_{k=1}^{n}a_{ik}b_{kj}\right]_{m \times s}  
\]</div><p></p><p>注意：矩阵乘法不满足交换律<br>
只有左矩阵的列数与右矩阵的行数相同的两个矩阵才能相乘<br>
乘积矩阵的行数等于左矩阵的行数，列数等于右矩阵的列数</p>
<h5 id="概括一下就是">概括一下就是</h5>
<blockquote>
<p>乘积矩阵第i行第j列处的元素等于左矩阵的第i行与右矩阵的第j列对应元素乘积之和</p>
</blockquote>
<p>那么，这个很简单，上代码吧<br>
为了测试，所有的矩阵保证满足乘法条件且为2维</p>
<p><strong>时间复杂度 <span class="math inline">\(O(n^3)\)</span></strong></p>
<pre><code>// 原始版本（未优化）
void matrix_mult(float* A, float* B, float* C, int N) {
    for (int i = 0; i &lt; N; i++)
        for (int j = 0; j &lt; N; j++)
            for (int k = 0; k &lt; N; k++)
                C[i*N + j] += A[i*N + k] * B[k*N + j];
}
</code></pre>
<p>在实际测试中，此算法跑出了<strong>1898.46ms</strong>的<s>优秀</s>成绩</p>
<h2 id="优化一循环优化">优化一：循环优化</h2>
<p>你可能会疑惑，循环优化是什么<br>
故名思义，就是对原有的ijk的循环重新更换顺序为ikj</p>
<h5 id="一个更大的问题来了凭什么仅仅改变顺序就快了许多">一个更大的问题来了，凭什么仅仅改变顺序就快了许多</h5>
<p>那么不妨看看访问顺序</p>
<h6 id="算法1朴素实现">算法1（朴素实现）：</h6>
<blockquote>
<p>在这个顺序中，最内层循环是k，它遍历A的一行和B的一列。<br>
对于A的访问是连续的（因为A[i][k]在内存中是按行存储的，所以k增加时是连续访问），<br>
但是B的访问是不连续的（因为B[k][j]在内存中是按行存储，k增加时访问的是不同行的同一列，所以是跳跃访问）。这样对B的访问会导致缓存失效。</p>
</blockquote>
<p>so，真正影响到速度的，就是缓存，在顺序读取中，缓存可以加载一整行，不必跳跃元素访问</p>
<p><strong>那么，有没有一种循环顺序，使得对三个数组均为顺序访问呢</strong><br>
<strong>有的兄弟，有的，让我们欢迎仍为<span class="math inline">\(O(n^{3})\)</span>的优化算法出场</strong><br>
<strong>——“ikj”循环优化</strong></p>
<blockquote>
<p>在这个顺序中，最内层循环是j。对于A的访问，固定i和k，所以每次内层循环A[i][k]是常数。对于B的访问，是B[k][j]，由于j是连续的，所以B的访问是连续的（因为同一行连续列）。同时，C的访问也是连续的（C[i][j]）。这样，所有的内存访问都是连续的，因此性能更好。</p>
</blockquote>
<p>可以自行验证，对于三个数组，均为顺序访问<br>
给出如下代码：<br>
<strong>时间复杂度 <span class="math inline">\(O(n^3)\)</span></strong></p>
<pre><code>// 优化后（行优先访问）
void matrix_mult_opt1(float* A, float* B, float* C, int N) {
    for (int i = 0; i &lt; N; i++)
        for (int k = 0; k &lt; N; k++)  // k循环提到中间
            for (int j = 0; j &lt; N; j++)
                C[i*N + j] += A[i*N + k] * B[k*N + j];
}
</code></pre>
<p>在实际测试中，此算法跑出了<strong>1462.89ms</strong>的优秀成绩<br>
提升：1898.46ms-1462.89ms = 435.57ms <strong>提高22.9%</strong></p>
<h2 id="进阶提升-优化二矩阵分块算法">进阶提升 优化二：矩阵分块算法</h2>
<blockquote>
<p>顾名思义，分块算法即是把矩阵分为多个小矩阵，对每个矩阵操作后再组合出结果，类似分块算法</p>
</blockquote>
<h4 id="那么它为什么快呢">那么，它为什么快呢</h4>
<p>在计算机中，共有三种CPU缓存以及普通内存，即<strong>L1、L2、L3 Cache和内存</strong><br>
前三种的速度要比内存快很多很多，大概只有一个CPU周期的延迟，而普通内存可以达到上百周期延迟<br>
<strong>而比他们更快的就是寄存器，直接接触CPU，0延迟</strong><br>
唯一的问题是，寄存器的大小只够存储单个值</p>
<h4 id="新的问题来了怎样把一个巨大的矩阵放到只有128k-1m的l1缓存中呢">新的问题来了，怎样把一个巨大的矩阵放到只有128k-1m的L1缓存中呢</h4>
<p>聪明的你一定想到了把原矩阵划分为多个小矩阵，每一个都能放到L1内进行运算<br>
那么恭喜你，你已经知道了<strong>矩阵分块算法</strong>的原理</p>
<p>更确切的说，先定义一个常数 <span class="math inline">\(blocks \in N^{+}\)</span> 作为划分的单位矩阵的行列，<br>
对于原矩阵A，我们把其中的 <span class="math inline">\({blocks \times blocks}\)</span> 个元素划分为一个新矩阵，记为<span class="math inline">\(a^{'}_{\cdots}\)</span>,我们定义:</p>
<p></p><div class="math display">\[ a^{'}_{11} = \begin{pmatrix}
a_{11} &amp; \cdots &amp; a_{1blocks} \\
\vdots &amp; \ddots &amp;\vdots \\
a_{blocks1} &amp; \cdots &amp; a_{blocks_{ }blocks}
\end{pmatrix}
\]</div><p></p><p>其余以此类推，新矩阵<span class="math inline">\(A^{'}\)</span>即变为</p>
<p></p><div class="math display">\[A^{'}=\begin{pmatrix}  
  a^{'}_{11} &amp; \cdots &amp; a^{'}_{1n} \\  
  \vdots &amp; \ddots &amp; \vdots \\  
  a^{'}_{m1} &amp; \cdots &amp; a^{'}_{mn}  
\end{pmatrix} \]</div><p></p><p><strong>正如同我们可以把 <span class="math inline">\(f(x)\)</span> 中的 <span class="math inline">\(x\)</span> 替换为任意多项式（函数），我们同样也可以把矩阵中的每个元素换为一个矩阵，其运算规则仍然成立</strong></p>
<hr>
<h5 id="so显而易见的分块矩阵算法有如下公式">so，显而易见的，分块矩阵算法有如下公式：</h5>
<p>对于整体而言，</p>
<p></p><div class="math display">\[\begin{array}{c} 
  C={A^{'}\times B^{'}}=\left[ c_{ij}\right]_{m \times s}  
  = \left[ \sum \limits_{k=1}^{n}a^{'}_{ik}b^{'}_{kj}\right]_{m \times s} 
\end{array}\]</div><p></p><p>其中：</p>
<p></p><div class="math display">\[ a^{'}_{ij} = \begin{pmatrix}
a_{[(i-1) \times blocks]{[(j-1)\times blocks]}} &amp; \cdots &amp; a_{[(i-1) \times blocks]{[j\times blocks]}} \\
\vdots &amp; \ddots &amp;\vdots \\
a_{[i\times blocks]{[(j-1)\times blocks]}} &amp; \cdots &amp; a_{[i\times blocks]{[j\times blocks]}}
\end{pmatrix}
\]</div><p></p><p>其中的每个乘法 <span class="math inline">\(a'{ik} \times b'{kj}\)</span> 是子矩阵乘法<br>
这里为了方便看，默认原矩阵的行列均为 blocks 的倍数<br>
<strong>那么下一个很自然的问题就是</strong></p>
<blockquote>
<p>若行列不为blocks的倍数，怎么办</p>
</blockquote>
<p>分两种情况：</p>
<ol>
<li>$ min(m,n) &lt; blocks $</li>
<li>$ \exists m,n \nmid blocks $</li>
</ol>
<p>对于1，直接执行普通矩阵乘法即可，因为整个矩阵均可放于L1、L2 Cache中<br>
对于2，我们定义分块矩阵的大小为$ p,q $</p>
<p></p><div class="math display">\[p = min(blocks,M- i \times blocks)
\]</div><p></p><p></p><div class="math display">\[q = min(blocks,N - j \times blocks)
\]</div><p></p><p>其中，</p>
<p></p><div class="math display">\[M，N为被分块矩阵的行列
\]</div><p></p><p></p><div class="math display">\[i,j为分块矩阵a^{'}_{ij}的下标
\]</div><p></p><p>至此，分块矩阵的全部问题已经解决</p>
<p>给出如下代码：<br>
<strong>时间复杂度<span class="math inline">\(O(n^3)\)</span></strong></p>
<pre><code>void block_mult(float* A, float* B, float* C, int N, int BLOCK) {
    // 清除结果矩阵
    memset(C, 0, N*N*sizeof(float));
    // 三层分块循环
    for (int i0 = 0; i0 &lt; N; i0 += BLOCK) {
        int i_end = min(i0 + BLOCK, N);  // 计算行边界
        for (int k0 = 0; k0 &lt; N; k0 += BLOCK) {
            int k_end = min(k0 + BLOCK, N);  // 计算中间维度边界
            for (int j0 = 0; j0 &lt; N; j0 += BLOCK) {
                int j_end = min(j0 + BLOCK, N);  // 计算列边界
                // 核心计算：只处理完整块内的元素
                for (int i = i0; i &lt; i_end; i++) {
                    for (int k = k0; k &lt; k_end; k++) {
                        float a_val = A[i*N + k];  // 一次加载A元素
                        // 内层循环：连续访问B和C
                        for (int j = j0; j &lt; j_end; j++) {
                            C[i*N + j] += a_val * B[k*N + j];
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<p>由于矩阵过小时，分块算法优势不大，且会增加调用开销，因此，这里的测试，<span class="math inline">\(m,n\)</span>为2048</p>
<h5 id="实测结果-时用时-115152ms">实测结果：<span class="math inline">\(blocks = 512\)</span> 时，用时 <strong>11515.2ms</strong></h5>
<p>而不使用分块仅循环优化的算法 用时 <strong>16028.9ms</strong><br>
朴素实现 用时 <strong>18053.45ms</strong><br>
提升：16028.9ms-11515.2ms = <span class="math inline">\(4513.2ms\)</span> <strong>提高：<span class="math inline">\(28.1\%\)</span></strong></p>
<h2 id="高手过招-优化三-并行与simd">高手过招 优化三 ：并行与SIMD</h2>
<p>何为<strong>并行与SIMD</strong>？<br>
并行：<strong>多线程同时处理多个分块</strong><br>
SIMD：<strong>乘加一体</strong>，即一条CPU指令同时处理乘与加<br>
我们这里使用Apple的<strong>AMX(Apple Matrix协处理器)</strong>（也属于CPU的一部分，并非GPU优化）<br>
对于x86架构和其余ARM架构的处理器，可以使用AVX、AVX_512、SSE等SIMP指令集</p>
<h4 id="它的特性有">它的特性有：</h4>
<ul>
<li>Apple Silicon芯片(M1/M2/M3等)内置的专用矩阵运算单元</li>
<li>可并行处理大量16位浮点(FP16)或整数(INT8)运算</li>
</ul>
<p>每个AMX单元包含：</p>
<ul>
<li>8个32KB的寄存器文件</li>
<li>可同时执行2048次乘加运算(16x16x8矩阵)</li>
<li>专用数据通路减少内存访问延迟</li>
</ul>
<p>以及<strong>自动分块</strong><br>
如下是使用AMX的SIMP的代码：<br>
<strong>时间复杂度：<span class="math inline">\(O(n^3)\)</span></strong></p>
<pre><code>// 使用Apple的AMX加速BLAS库
            cblas_sgemm(CblasRowMajor,   // 行主序存储
                        CblasNoTrans,   // 不转置A
                        CblasNoTrans,   // 不转置B
                        M,              // A的行数
                        N,              // B的列数
                        K,              // 公共维度
                        1.0f,           // alpha系数
                        a_data,         // A数据指针
                        K,              // A的列步幅（lda）
                        b_data,         // B数据指针
                        N,              // B的列步幅（ldb）
                        0.0f,           // beta系数
                        r_data,         // 结果数据指针
                        N);             // 结果的列步幅（ldc）
</code></pre>
<p><strong>那么，本次优化最吓人、最恐怖的一次数据来了：</strong><br>
<strong>实测数据：202.831ms（4096*4096）</strong><br>
<strong>而标准分块+循环优化算法，在2048*2048时，就已经11515.2ms</strong><br>
提升：11312.37 ms <strong>提高：98.2%</strong></p>
<h2 id="数学手段-优化4strassen算法--变种">数学手段 优化4:Strassen算法 &amp; 变种</h2>
<p><strong>温馨提示：到这里已经是高等数学内容了（实不相瞒，前面其实也是），有点小烧脑，不过欢迎各位继续跟作者一起尝试，本作者大约花了3小时搞完这一部分的证明</strong></p>
<h4 id="介绍">介绍：</h4>
<p>Strassen算法是一种通过数学变换减少乘法次数的高效矩阵乘/卷积算法</p>
<h4 id="简要推导">简要推导：</h4>
<p>我们设有如下两个矩阵相乘：</p>
<p></p><div class="math display">\[\begin{pmatrix}  
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22}
\end{pmatrix} \times 
\begin{pmatrix}
b_{11} &amp; b_{12} \\
b_{21} &amp; b_{22}
\end{pmatrix} = 
\begin{pmatrix}
c_{11} &amp; c_{12} \\
c_{21} &amp;c_{22}
\end{pmatrix}
\]</div><p></p><p>传统计算需要8次乘法：</p>
<p></p><div class="math display">\[c_{11} = a_{11}\times b_{11} + a_{12}\times b_{21} \\
\]</div><p></p><p></p><div class="math display">\[c_{12} = a_{11}\times b_{12} + a_{12}\times b_{22} \\
\]</div><p></p><p></p><div class="math display">\[c_{21} = a_{21}\times b_{11} + a_{22}\times b_{21} \\
\]</div><p></p><p></p><div class="math display">\[c_{22} = a_{21}\times b_{12} + a_{22}\times b_{22} \\
\]</div><p></p><p>而Strassen算法只需7次乘<br>
<strong>接下来，是Strassen算法最精妙绝伦的一步：</strong><br>
作者定义了7个矩阵：</p>
<p></p><div class="math display">\[\begin{align*}
M_1 &amp;= (a_{11} + a_{22})(b_{11} + b_{22}) \\
M_2 &amp;= (a_{21} + a_{22})b_{11} \\
M_3 &amp;= a_{11}(b_{12} - b_{22}) \\
M_4 &amp;= a_{22}(b_{21} - b_{11}) \\
M_5 &amp;= (a_{11} + a_{12})b_{22} \\
M_6 &amp;= (a_{21} - a_{11})(b_{11} + b_{12}) \\
M_7 &amp;= (a_{12} - a_{22})(b_{21} + b_{22})
\end{align*}
\]</div><p></p><p>真正让人惊讶的是下一步：<br>
作者构建的7个矩阵，可以通过有限次的组合成为结果矩阵的一个元素<br>
什么意思呢，让我们尝试展开其中一项：</p>
<p></p><div class="math display">\[c_{11} = M_1 + M_4 - M_5 + M_7 \\
\]</div><p></p><p></p><div class="math display">\[\begin{align*}
&amp;=(a_{11} + a_{22})(b_{11} + b_{22}) + a_{22}(b_{21} - b_{11}) - (a_{11} + a_{12})b_{22} + (a_{12} - a_{22})(b_{21} + b_{22}) \\ \end{align*}\]</div><p></p><p></p><div class="math display">\[\begin{align*}
= &amp; \ \ a_{11}b_{11} + \cancel{a_{11}b_{22}} + \cancel{a_{22}b_{11}} + \cancel{a_{22}b_{22}} \\
&amp;+ \ \cancel{a_{22}b_{21}} - \cancel{a_{22}b_{11}} \\
&amp;- \ \cancel{a_{11}b_{22}} - a_{12}b_{22} \\
&amp;+ \ a_{12}b_{21} + \cancel{a_{12}b_{22}} - \cancel{a_{22}b_{21}} - \cancel{a_{22}b_{22}} \\
= &amp; \ \ a_{11}b_{11} + a_{12}b_{21}
\end{align*}\]</div><p></p><p><strong>由此，可以类似的推出<span class="math inline">\(c_{12}、c_{21}、c_{22}\)</span>均与正常计算一致</strong><br>
最后的结果矩阵为</p>
<p></p><div class="math display">\[C=
\begin{pmatrix}
M_{1}+M_{4}-M_{5}+M_{7} &amp; M_{3}+M_{5} \\
M_{2}+M_{4} &amp; M_{1}-M_{2}+M_{3}+M_{6}
\end{pmatrix}
\]</div><p></p><p>接下来，我们证明其对于n&gt;2时仍然成立：<br>
由于( n=2 )时，我们已经证明其正确<br>
所以，在n&gt;2时，我们采取分块<br>
将原矩阵分为4块，此时我们将其中的子矩阵看为一个元素<br>
那么此时又回归到了标准的2x2的Strassen算法<br>
由此在$n,m \mid 2 $时Strassen算法正确<br>
那么，下一个很自然的问题就是</p>
<blockquote>
<p>若<span class="math inline">\(n,m \nmid {2} ,结论是否成立\)</span></p>
</blockquote>
<p>我们的做法是，将矩阵分块，分为几个<span class="math inline">\(2^k \times 2^k\)</span>的子矩阵以及几个符合矩阵乘规则的小矩阵<br>
显然由于前文的分块算法的正确性，此时的分块仍然正确，对于几个<span class="math inline">\(2^k \times 2^k\)</span>的矩阵，我们使用Strassen算法进行计算<br>
<strong>现在来计算一下Strassen算法的时间复杂度：</strong><br>
设$ T(n) $ 为计算 $ n \times n $ 矩阵乘法的时间：<br>
<span class="math inline">\(T(n) = 7T\left(\frac{n}{2}\right) + O(n^2)\)</span></p>
<ul>
<li>$ 7T(n/2) $：7 个子问题递归计算</li>
<li>$O(n^2) $：矩阵加减法开销（共 18 次加减法）</li>
</ul>
<p>根据主定理1，<br>
$ a = 7,b = 2,f(n)=\Theta(n^2) $<br>
<span class="math inline">\(log _b a = log_27 \approx 2.807\)</span><br>
由于<span class="math inline">\(log _b a &gt; 2\)</span>,所以<span class="math inline">\(f(n) = O({n^{log_b a-\epsilon})} = O(n^{log_27}) \approx O(n^{2.807})\)</span><br>
更精确的，复杂度为<span class="math inline">\(\Theta(n^{2.807})\)</span></p>
<p>具体的算法为：<br>
1.先将矩阵AB分块，分成大小为 <span class="math inline">\({blocks \times blocks}\)</span> 的若干块以及几个任意大小的子块<br>
2.对于 <span class="math inline">\({blocks \times blocks}\)</span> 的子块，我们使用Strassen算法计算<br>
3.在递归过程中，若方阵大小（因为Strassen算法开始时为方阵）n = 128，则使用循环优化的矩阵乘法<br>
4.否则，继续按照Strassen算法递归计算直至n = 128<br>
5.对于不是 <span class="math inline">\({blocks \times blocks}\)</span> 的子块，使用循环优化的矩阵乘法计算<br>
<strong>给出如下代码：</strong><br>
近似时间复杂度<span class="math inline">\(O(n^{2.81})\)</span></p>
<pre><code>const int BLOCK_SIZE = 2048;
const int STRASSEN_THRESHOLD = 128;

// 标准矩阵乘法 (用于小矩阵和边界处理)
void standard_matmul(const float* A, const float* B, float* C, int n, int m, int p, int lda, int ldb, int ldc) {
    for (int i = 0; i &lt; n; ++i) {
        for (int k = 0; k &lt; m; ++k) {
            float a = A[i * lda + k];
            for (int j = 0; j &lt; p; ++j) {
                C[i * ldc + j] += a * B[k * ldb + j];
            }
        }
    }
}

// 循环优化矩阵乘法 (n=128时使用)
void optimized_matmul(const float* A, const float* B, float* C, int n, int lda, int ldb, int ldc) {
    for (int i = 0; i &lt; n; ++i) {
        for (int k = 0; k &lt; n; ++k) {
            float a = A[i * lda + k];
            for (int j = 0; j &lt; n; ++j) {
                C[i * ldc + j] += a * B[k * ldb + j];
            }
        }
    }
}

// 矩阵加法
void matrix_add(const float* A, const float* B, float* C, int n, int lda, int ldb, int ldc) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            C[i * ldc + j] = A[i * lda + j] + B[i * ldb + j];
        }
    }
}

// 矩阵减法
void matrix_subtract(const float* A, const float* B, float* C, int n, int lda, int ldb, int ldc) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            C[i * ldc + j] = A[i * lda + j] - B[i * ldb + j];
        }
    }
}

// 结果累加到目标矩阵
void matrix_add_to_target(float* T, const float* S, int n, int ldt, int lds) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            T[i * ldt + j] += S[i * lds + j];
        }
    }
}

// Strassen 矩阵乘法 (递归实现)
void strassen_matmul(const float* A, const float* B, float* C, int n, int lda, int ldb, int ldc) {
    // 递归基: n &lt;= 128 使用优化乘法
    if (n &lt;= STRASSEN_THRESHOLD) {
        optimized_matmul(A, B, C, n, lda, ldb, ldc);
        return;
    }

    int half = n / 2;
    // 定义子矩阵指针
    const float* A11 = A;
    const float* A12 = A + half;
    const float* A21 = A + half * lda;
    const float* A22 = A + half * lda + half;
    
    const float* B11 = B;
    const float* B12 = B + half;
    const float* B21 = B + half * ldb;
    const float* B22 = B + half * ldb + half;
    
    float* C11 = C;
    float* C12 = C + half;
    float* C21 = C + half * ldc;
    float* C22 = C + half * ldc + half;

    // 分配临时矩阵
    std::vector&lt;float&gt; S1(half * half);
    std::vector&lt;float&gt; S2(half * half);
    std::vector&lt;float&gt; S3(half * half);
    std::vector&lt;float&gt; S4(half * half);
    std::vector&lt;float&gt; S5(half * half);
    std::vector&lt;float&gt; S6(half * half);
    std::vector&lt;float&gt; S7(half * half);
    std::vector&lt;float&gt; S8(half * half);
    std::vector&lt;float&gt; S9(half * half);
    std::vector&lt;float&gt; S10(half * half);
    
    std::vector&lt;float&gt; P1(half * half);
    std::vector&lt;float&gt; P2(half * half);
    std::vector&lt;float&gt; P3(half * half);
    std::vector&lt;float&gt; P4(half * half);
    std::vector&lt;float&gt; P5(half * half);
    std::vector&lt;float&gt; P6(half * half);
    std::vector&lt;float&gt; P7(half * half);

    // 计算S矩阵
    matrix_subtract(B12, B22, S1.data(), half, ldb, ldb, half);    // S1 = B12 - B22
    matrix_add(A11, A12, S2.data(), half, lda, lda, half);         // S2 = A11 + A12
    matrix_add(A21, A22, S3.data(), half, lda, lda, half);         // S3 = A21 + A22
    matrix_subtract(B21, B11, S4.data(), half, ldb, ldb, half);    // S4 = B21 - B11
    matrix_add(A11, A22, S5.data(), half, lda, lda, half);         // S5 = A11 + A22
    matrix_add(B11, B22, S6.data(), half, ldb, ldb, half);         // S6 = B11 + B22
    matrix_subtract(A12, A22, S7.data(), half, lda, lda, half);    // S7 = A12 - A22
    matrix_add(B21, B22, S8.data(), half, ldb, ldb, half);         // S8 = B21 + B22
    matrix_subtract(A11, A21, S9.data(), half, lda, lda, half);    // S9 = A11 - A21
    matrix_add(B11, B12, S10.data(), half, ldb, ldb, half);        // S10 = B11 + B12

    // 递归计算P矩阵
    strassen_matmul(A11, S1.data(), P1.data(), half, lda, half, half);      // P1 = A11 * S1
    strassen_matmul(S2.data(), B22, P2.data(), half, half, ldb, half);      // P2 = S2 * B22
    strassen_matmul(S3.data(), B11, P3.data(), half, half, ldb, half);      // P3 = S3 * B11
    strassen_matmul(A22, S4.data(), P4.data(), half, lda, half, half);      // P4 = A22 * S4
    strassen_matmul(S5.data(), S6.data(), P5.data(), half, half, half, half); // P5 = S5 * S6
    strassen_matmul(S7.data(), S8.data(), P6.data(), half, half, half, half); // P6 = S7 * S8
    strassen_matmul(S9.data(), S10.data(), P7.data(), half, half, half, half);// P7 = S9 * S10

    // 组合结果矩阵 (累加到C)
    // C11 = P5 + P4 - P2 + P6
    matrix_add_to_target(C11, P5.data(), half, ldc, half);
    matrix_add_to_target(C11, P4.data(), half, ldc, half);
    matrix_add_to_target(C11, P6.data(), half, ldc, half);
    for (int i = 0; i &lt; half; ++i) {
        for (int j = 0; j &lt; half; ++j) {
            C11[i * ldc + j] -= P2[i * half + j];
        }
    }
    
    // C12 = P1 + P2
    matrix_add_to_target(C12, P1.data(), half, ldc, half);
    matrix_add_to_target(C12, P2.data(), half, ldc, half);
    
    // C21 = P3 + P4
    matrix_add_to_target(C21, P3.data(), half, ldc, half);
    matrix_add_to_target(C21, P4.data(), half, ldc, half);
    
    // C22 = P5 + P1 - P3 - P7
    matrix_add_to_target(C22, P5.data(), half, ldc, half);
    matrix_add_to_target(C22, P1.data(), half, ldc, half);
    for (int i = 0; i &lt; half; ++i) {
        for (int j = 0; j &lt; half; ++j) {
            C22[i * ldc + j] -= (P3[i * half + j] + P7[i * half + j]);
        }
    }
}

// 分块矩阵乘法
void matrix_multiply(const float* A, const float* B, float* C, int n, int m, int p, int lda, int ldb, int ldc) {
    // 初始化输出矩阵为0
    std::memset(C, 0, n * ldc * sizeof(float));
    
    // 分块处理
    for (int i = 0; i &lt; n; i += BLOCK_SIZE) {
        int i_end = std::min(i + BLOCK_SIZE, n);
        int i_size = i_end - i;
        
        for (int k = 0; k &lt; m; k += BLOCK_SIZE) {
            int k_end = std::min(k + BLOCK_SIZE, m);
            int k_size = k_end - k;
            
            for (int j = 0; j &lt; p; j += BLOCK_SIZE) {
                int j_end = std::min(j + BLOCK_SIZE, p);
                int j_size = j_end - j;
                
                // 当前块指针
                const float* A_block = A + i * lda + k;
                const float* B_block = B + k * ldb + j;
                float* C_block = C + i * ldc + j;
                
                // 完整块使用Strassen算法
                if (i_size == BLOCK_SIZE &amp;&amp; k_size == BLOCK_SIZE &amp;&amp; j_size == BLOCK_SIZE) {
                    strassen_matmul(A_block, B_block, C_block, BLOCK_SIZE, lda, ldb, ldc);
                } 
                // 非完整块使用标准乘法
                else {
                    standard_matmul(A_block, B_block, C_block, i_size, k_size, j_size, lda, ldb, ldc);
                }
            }
        }
    }
}
}
</code></pre>
<p>当然，实际测试中，我们使用Ctorch框架的Tensor类Op::Add，与此代码会略有差异<br>
<strong>最终测试结果：1005.65ms</strong><br>
P.S.<strong>提升不明显的原因是矩阵过小，如果使用Tranformer架构的巨型矩阵测试，<span class="math inline">\(O(n^{2.81})\)</span>的优势会非常明显</strong></p>
<h2 id="最终的方案">最终的方案：</h2>
<p>我们使用多函数策略：<br>
1.若dim&lt;128 此时的拷贝开销已经大于AMX的优化，因此使用循环优化<br>
2.128&lt;dim&lt;4096 AMX的最优区间，使用纯AMX<br>
3.dim&gt;4096 分块，对于能够分为<span class="math inline">\(2^k\)</span>的块，使用Strassen算法，递归到2048使用AMX<br>
对于不是<span class="math inline">\(2^k\)</span>的块，直接使用AMX计算，同时，每个分块使用单一线程</p>
<h3 id="最后的结果">最后的结果：</h3>
<p>测试矩阵：16384<em>16384</em>2（<span class="math inline">\(2^{14}\)</span>）<br>
标准：30251ms<br>
循环优化：24580ms<br>
分块：20498ms<br>
<strong>最终方案（SIMP+多线程+分块+Strassen）：8267.97ms</strong></p>
<h3 id="最后">最后</h3>
<p>如果你希望既追求高性能又追求简洁的框架，那么Ctorch将是你的最优选择<br>
尽管这个项目还在开发中，但是可以先小小的期待一下<br>
欢迎贡献，如有错误，请各位不吝赐教，谢谢<br>
2025.8.2</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-02 21:48">2025-08-02 21:48</span>&nbsp;
<a href="https://www.cnblogs.com/SilverGo">Ghost-Face</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19019364);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19019364', targetLink: 'https://www.cnblogs.com/SilverGo/p/19019364', title: 'Ctorch开发日志——矩阵乘法优化及数学原理' })">举报</a>
</div>
        