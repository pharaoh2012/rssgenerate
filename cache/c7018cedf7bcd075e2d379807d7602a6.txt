
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/HuaTalkHub/p/18692193" title="发布于 2025-01-26 22:18">
    <span role="heading" aria-level="2">【异步编程实战】如何实现超时功能（以CompletableFuture为例）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="异步编程实战如何实现超时功能以completablefuture为例">【异步编程实战】如何实现超时功能（以CompletableFuture为例）</h1>
<p>由于网络波动或者连接节点下线等种种问题，对于大多数网络异步任务的执行通常会进行超时限制，在异步编程中是一个常见的问题。本文主要讨论实现超时功能的基本思路以及CompletableFuture（之后简称CF）是如何通过代码实现超时功能的。</p>
<h2 id="基本思路">基本思路</h2>
<ol>
<li>两个任务，两个线程：原有任务，超时任务</li>
<li>原有的任务正常执行，写入正常结果，原有任务执行成功取消超时任务</li>
<li>超时时取消原有任务，写入结果为超时异常或者默认值</li>
<li>竞态条件下保证结果写入的原子性和只写一次</li>
</ol>
<h2 id="completablefuture-的实现">CompletableFuture 的实现</h2>
<h3 id="1-基本实现流程">1. 基本实现流程</h3>
<pre><code class="language-java">// JDK9新增的超时方法
public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    if (result == null)
        whenComplete(new Canceller(Delayer.delay(new Timeout(this),
                                                 timeout, unit)));
    return this;
}

// CF的内部类
    static final class Timeout implements Runnable {
        final CompletableFuture&lt;?&gt; f;
        Timeout(CompletableFuture&lt;?&gt; f) { this.f = f; }
        public void run() {
            if (f != null &amp;&amp; !f.isDone())
                f.completeExceptionally(new TimeoutException());
        }
    }
</code></pre>
<p>分析代码得知，whenComplete方法添加了正常结束的回调，取消超时任务。</p>
<p>超时任务通过Delayer.delay创建，超时时执行Timeout::run方法，即写入结果为TimeoutException。</p>
<p>下面来看下Dalayer的具体实现：</p>
<pre><code class="language-java">/**
 * Singleton delay scheduler, used only for starting and
 * cancelling tasks.
 */
static final class Delayer {
    static ScheduledFuture&lt;?&gt; delay(Runnable command, long delay,
                                    TimeUnit unit) {
        return delayer.schedule(command, delay, unit);
    }

    static final class DaemonThreadFactory implements ThreadFactory {
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            // 守护线程，当主线程关闭时，自身也关闭
            t.setDaemon(true);
            t.setName("CompletableFutureDelayScheduler");
            return t;
        }
    }

    static final ScheduledThreadPoolExecutor delayer;
    static {
        (delayer = new ScheduledThreadPoolExecutor(
            1, new DaemonThreadFactory())).
            setRemoveOnCancelPolicy(true);
    }
}
</code></pre>
<p>Delayer是一个单例对象，专门用于执行延迟任务，减少了内存占用。ScheduledThreadPoolExecutor 的配置为单线程，设置了<code>removeOnCancelPolicy</code>，表示取消延迟任务时，任务从延迟队列删除。这里的延迟队列为默认的执行器实现：</p>
<pre><code class="language-java">public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue(), threadFactory);
}
</code></pre>
<p>ScheduledThreadPoolExecutor 底层使用延迟队列<code>DelayedWorkQueue</code>，延迟队列底层依赖于索引优先队列，删除操作的时间复杂度为o(logn)。</p>
<p>下面来看下Canceller的具体实现：</p>
<pre><code class="language-java">static final class Canceller implements BiConsumer&lt;Object, Throwable&gt; {
    final Future&lt;?&gt; f;
    Canceller(Future&lt;?&gt; f) { this.f = f; }
    public void accept(Object ignore, Throwable ex) {
        if (f != null &amp;&amp; !f.isDone())
            f.cancel(false);
    }
}
</code></pre>
<p>canceller实际上是一个回调函数，原有任务完成后触发，会取消相关超时任务。</p>
<h3 id="2-静态条件分析">2. 静态条件分析</h3>
<p>下面是写入CF的实现代码片段：</p>
<pre><code class="language-java">				// 超时结束        
        if (f != null &amp;&amp; !f.isDone())
            f.completeExceptionally(new TimeoutException());
        // 取消任务
        if (f != null &amp;&amp; !f.isDone())
            f.cancel(false);
				// CF 原有任务的写入不由orTimeout方法控制，以下为一个示例
						Thread.sleep(1000);
						f.complete(u);
</code></pre>
<p>对于CF的检查实际上不能保证原子性，因为这种检查-再计算的模式需要同步块的保护，而CF底层并没有这种实现。所以，if语句检查任务未完成，之后执行代码时，任务可能已经完成了。不过这种检查也有一定的好处，因为CF保证了结果写入后，isDone方法必然为true，从而避免执行不必要的代码。</p>
<p><code>completeExceptionally</code> 方法和 <code>complete</code> 方法可能同时执行，CF 通过CAS操作保证了结果写入的原子性。</p>
<pre><code class="language-java">// 异常结果实现
final boolean internalComplete(Object r) { // CAS from null to r
    return RESULT.compareAndSet(this, null, r);
}
// 正常结果实现
final boolean completeValue(T t) {
    return RESULT.compareAndSet(this, null, (t == null) ? NIL : t);
}

public boolean isDone() {
    return result != null;
}
</code></pre>
<h3 id="3-内存泄露bug">3. 内存泄露bug</h3>
<p>在 JDK21之前的CF实现中，存在内存泄露的bug，具体描述详见 <a href="https://bugs.openjdk.org/browse/JDK-8303742%EF%BC%8C%E7%9B%AE%E5%89%8D%E7%AC%94%E8%80%85%E4%BB%85%E5%9C%A8" target="_blank" rel="noopener nofollow">https://bugs.openjdk.org/browse/JDK-8303742，目前笔者仅在</a> JDK21 中发现代码已修复（不考虑非LTS版本）。作为bug，后续发布的 JDK 子版本可能会修复这个问题。</p>
<p>这个bug在如下代码中：</p>
<pre><code class="language-java">// 取消任务，JDK21之前的实现会检查异常结果
if (ex == null &amp;&amp; f != null &amp;&amp; !f.isDone())
    f.cancel(false);
</code></pre>
<p>当正常任务异常结束时，不会取消延迟队列中的任务，最终会导致内存泄露。若项目中存在多个长时间超时CF任务，内存泄露的情况会更明显。</p>
<pre><code class="language-java">public class LeakDemo {
    public static void main(String[] args) {
        while (true) {
            new CompletableFuture&lt;&gt;().orTimeout(1, TimeUnit.HOURS).completeExceptionally(new Exception());
        }
    }
}
</code></pre>
<p>执行以上代码会报OOM错误，你可以在自己的编程环境中进行测试。</p>
<h3 id="4-jdk8如何实现超时任务">4. JDK8如何实现超时任务</h3>
<p>JDK8中CompletableFuture并不支持超时任务，笔者推荐使用<a href="https://github.com/foldright/cffu" target="_blank" rel="noopener nofollow">CFFU类库</a>，其是CF的增强类库，支持在JDK8环境中使用高版本的功能。另一种方案使用 Guava 提供的 ListenableFuture。当然你也可以参照JDK21中的代码自己实现。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08175785443287037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 22:18">2025-01-26 22:18</span>&nbsp;
<a href="https://www.cnblogs.com/HuaTalkHub">桦说编程</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18692193" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18692193);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18692193', targetLink: 'https://www.cnblogs.com/HuaTalkHub/p/18692193', title: '【异步编程实战】如何实现超时功能（以CompletableFuture为例）' })">举报</a>
</div>
        