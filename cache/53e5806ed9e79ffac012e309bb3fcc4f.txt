
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SilverGo/p/19054462" title="发布于 2025-08-23 15:10">
    <span role="heading" aria-level="2">关于模运算</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>写这篇文章的时候，本蒟蒻正在挑战3个月达省一；<br>
之前一直对模运算<s>耿耿于怀</s>十分好奇，遂决定，今天拿下；<br>
最后在正文开始之前放一个搞笑的东西：<br>
<img src="https://img2024.cnblogs.com/blog/3357339/202508/3357339-20250823123239145-1309505766.avif" alt="" loading="lazy"></p>
<h1 id="关于模运算的定义">关于模运算的定义</h1>
<p>我们先定义<strong>带余除法</strong>（<s>其实就是除法</s>）：<br>
<span class="math inline">\(设两个数 a,m \in \symbb{Z}, m \not= 0,则a、m的带余除法定义为：\)</span><br>
存在唯一的整数q、r（r必须大于等于0），使得</p>
<p></p><div class="math display">\[a = qm+r 
\]</div><p></p><p>我们记a模m为： <span class="math inline">\(a \bmod m\)</span><br>
我们把 <span class="math inline">\(q\)</span> 称做商，<span class="math inline">\(r\)</span> 称做余数（也称a模m的结果），记作：</p>
<p></p><div class="math display">\[r = a \bmod m
\]</div><p></p><h1 id="关于114514--998244353">关于114514 &amp; 998244353</h1>
<p>在 <strong>OI</strong> 中，模运算最直接的用处就是解决一些需要处理带模运算的题目；<br>
而 <span class="math inline">\(114514\)</span> 和 <span class="math inline">\(998244353\)</span> 这两个神奇的模数就不得不提一下了：</p>
<p><span class="math inline">\(114514\)</span> 请自行百度（主要是我也没查出来什么）， <span class="math inline">\(998244353\)</span> 有如下的几个特点：<br>
1.它的二进制表达是：111011100000000000000000000001<br>
2.它是一个质数。<br>
3.它是一个奇数。<br>
4.它可以表达为两个数的平方和：<span class="math inline">\(998244353 = 3943^2 + 31348^2\)</span><br>
5.它是勾股数之一：<span class="math inline">\(998244353^2 = 247210328^2 + 967149855^2\)</span><br>
6.它可以被表达为：<span class="math inline">\(998244353 = 7 \times 17 \times 2^{23} + 1\)</span><br>
7.998244353最优美的性质莫过于它是个完美恶臭数：</p>
<p></p><div class="math display">\[998244353=( 114514 * ( 54-1+114 * (1+14*5+1+4) ) ) + ( 4+11451 * (4-1-15+14) ) + ( 11+41*54 + (141+541) )  + (4-1-15+14)
\]</div><p></p><p>之所以称为完美，因为每一个括号里114514都出现了正整数次；</p>
<p><strong>Tips ：<span class="math inline">\(998244353\)</span> 最大的一个特点是：出题人 <span class="math inline">\(99\%\)</span> 的情况下是不会使用这个数的，取而代之的是 <span class="math inline">\(998234353\)</span> 、<span class="math inline">\(998244553\)</span> ，不过应该没人会栽在上面</strong></p>
<h1 id="模运算的两个等式">模运算的两个等式</h1>
<p></p><div class="math display">\[\S 1. (a+b) \bmod m = ((a \bmod m)+(b \bmod m)) \bmod m 
\]</div><p></p><p></p><div class="math display">\[\S 2. (a \times b) \bmod m = ((a \bmod m) \times (b \bmod m)) \bmod m
\]</div><p></p><p>这两个是经常会用到的等式，大部分的OI题目都要求取模<br>
但是通常情况下，这时的结果都远远超出了int型的范围，我们需要在运算过程中就直接取模，而这步的正确性就是依赖于上面的两个等式</p>
<p><strong>下面我们来证明一下：</strong></p>
<p>证明1:<br>
依据带余除法，我们设 <span class="math inline">\(a = q_1m + r_1,\)</span>   <span class="math inline">\(b = q_2m + r_2\)</span>，那么带入等式左边，我们有：</p>
<p></p><div class="math display">\[(a+b)\bmod m = (q_1m+r_1+q_2m+r_2) \bmod m
\]</div><p></p><p>更进一步，合并同类项：</p>
<p></p><div class="math display">\[原式 = ((q_1+q_2)m+r_1+r_2) \bmod m
\]</div><p></p><p>引入一个定理：</p>
<blockquote>
<p><span class="math inline">\(a \bmod m\)</span> 的结果与 <span class="math inline">\((a+k \times m) \bmod m\)</span> 是一样的，通俗来说，就是一个数除以另一个数的余数，与这个数加上任意倍的除数之后除以除数的余数是一样的</p>
</blockquote>
<p>显然，这里相当于有一个<strong>商为 <span class="math inline">\((q_1+q_2)\)</span> ,余数为 <span class="math inline">\(r_1+r_2\)</span> 的数模 <span class="math inline">\(m\)</span></strong>,当然就等于直接对 <span class="math inline">\(r_1+r_2\)</span> 模 <span class="math inline">\(m\)</span> （不妨自己试一下，<span class="math inline">\(9 \bmod 2\)</span> 和 <span class="math inline">\(1 \bmod 2\)</span>一不一样）<br>
所以我们有：</p>
<p></p><div class="math display">\[((q_1+q_2)m+r_1+r_2) \bmod m = (r_1+r_2) \bmod m
\]</div><p></p><p>而 <span class="math inline">\(r_1,r_2\)</span> 就是 <span class="math inline">\(a \bmod m\)</span> ,<span class="math inline">\(b \bmod m\)</span> ,带入得：</p>
<p></p><div class="math display">\[(r_1+r_2) \bmod m = ((a \bmod m)+(b \bmod m)) \bmod m
\]</div><p></p><p><strong>证毕</strong></p>
<p>证明2:<br>
仍然依据带余除法，我们设 <span class="math inline">\(a = q_1m + r_1,\)</span>   <span class="math inline">\(b = q_2m + r_2\)</span>，那么带入等式左边，我们有：</p>
<p></p><div class="math display">\[(a \times b)\bmod m = ((q_1m+r1) \times (q_2m + r_2)) \bmod m
\]</div><p></p><p>展开：</p>
<p></p><div class="math display">\[= (q_1q_2m^2+(q_1r_2+q_2r_1)m+r_1r_2) \bmod m
\]</div><p></p><p>这里括号内的前两项仍然是 <span class="math inline">\(m\)</span> 的倍数，所以可以和1一样进行替换</p>
<p></p><div class="math display">\[= (r_1r_2) \bmod m
\]</div><p></p><p>而 <span class="math inline">\(r_1\)</span> 、<span class="math inline">\(r_2\)</span> 分别是 <span class="math inline">\(a \bmod m\)</span> ,<span class="math inline">\(b \bmod m\)</span> ,带入得：</p>
<p></p><div class="math display">\[= ((a \bmod m) \times (b \bmod m)) \bmod m
\]</div><p></p><p><strong>证毕</strong></p>
<h1 id="同余">同余</h1>
<p>如果在计算过程中出现了负数，应该如何处理呢(也就是对负数取模，这里不能直接取，这样是负的)？<br>
我们回归问题的本质：求出这个负数除以m的余数</p>
<p>也就是说，我们只要找到一个和这个负数除以m的余数一样的正数，就可以找到这个负数除以m的余数，而所谓的“和这个负数除以m的余数一样的正数”，简称和这个负数同余（具有同样的余数）</p>
<p>当然，仅说同余是没有意义的，我们需要指定模数（除数），才是有意义的；</p>
<blockquote>
<p>具体而言：假如有两个整数 <span class="math inline">\(x,y\)</span> ，若 <span class="math inline">\((x-y) \bmod m = 0\)</span> ,则称 <span class="math inline">\(x,y\)</span> 在模 <span class="math inline">\(m\)</span> 意义下同余（具有同样的余数）</p>
</blockquote>
<p>为什么<strong>差是倍数就同余呢</strong>，仍然依据带余除法，我们设 <span class="math inline">\(x = q_1m + r_1,\)</span>   <span class="math inline">\(y = q_2m + r_2\)</span>，那么带入等式左边，我们有：</p>
<p></p><div class="math display">\[原式 = ((q_1-q_2)m+(r_1-r_2)) \bmod m
\]</div><p></p><p>而因为这玩意为0，所以 <span class="math inline">\((q_1-q_2)m+(r_1-r_2)\)</span> 必然是 <span class="math inline">\(m\)</span> 的倍数，也就是能写成 <span class="math inline">\(n \times m\)</span>的形式（ <span class="math inline">\(n\)</span> 是一个整数），显然，<span class="math inline">\(n = q_1-q_2\)</span> ,所以 <span class="math inline">\(r_1 - r_2 = 0\)</span>，也就是说，<span class="math inline">\(r_1 = r_2\)</span> ，即 <span class="math inline">\(x,y\)</span> 同余;</p>
<p>现在给出定义：对于任意的两个数 <span class="math inline">\(x,y\)</span> ，若有 <span class="math inline">\((x-y) \bmod m = 0\)</span> ,那么我们称 <span class="math inline">\(x,y\)</span> 在模 <span class="math inline">\(m\)</span> 意义下同余，记为：</p>
<p></p><div class="math display">\[x \equiv y\pmod m
\]</div><p></p><p>那么回到最初的问题：如何找到和这个负数同余的正数；<br>
我们假设这个数是 <span class="math inline">\(-15\)</span>，根据同余的定义，我们有：<span class="math inline">\(-15 \equiv 5 \pmod{10}\)</span> (<span class="math inline">\(-15-5 = -20 \bmod 10 = 0\)</span> ，显然-20是10的-2倍)</p>
<p>那么怎样从 <span class="math inline">\(-15\)</span> 推出 <span class="math inline">\(5\)</span> 来呢？<br>
我们使用 <strong>「模m加m」</strong> 的方法，即先模m得到一个负数，随后加上m，就得到了和m同余的正数：<br>
<span class="math inline">\(-15 \bmod 10 = -5\)</span>，<span class="math inline">\(-5+10 = 5\)</span>,这样就得到了5，随后再对5模10即可（这里的负余数-5是大部分的编程语言的默认做法，但是不符合数学定义）；</p>
<p>对于对一个不知正负的数字 <span class="math inline">\(x\)</span> 取模，我们进行如下计算：<br>
<span class="math inline">\(x \bmod m = (x \bmod m + m) \bmod m\)</span></p>
<h3 id="最后">最后</h3>
<p>到这里这篇介绍模运算的文章就结束了（当然不包含对除法的取模，这个比较复杂，需要适当了解群论和乘法逆元），可能会有笔误，欢迎各位指正</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-23 15:10">2025-08-23 15:10</span>&nbsp;
<a href="https://www.cnblogs.com/SilverGo">Ghost-Face</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19054462);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19054462', targetLink: 'https://www.cnblogs.com/SilverGo/p/19054462', title: '关于模运算' })">举报</a>
</div>
        