
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tylerw/p/18866414" title="发布于 2025-05-09 15:37">
    <span role="heading" aria-level="2">【UEFI】PEI阶段从概念到代码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="总述">总述</h1>
<p>UEFI开发过程中，BIOS工程师主要关注点和工作都在于PEI和DXE阶段。</p>
<p>DXE阶段是我们的主战场，可以进行丰富且大量的功能驱动开发。</p>
<p>实际上，在UEFI Spec中，就指出<br>
<a href="https://uefi.org/specs/PI/1.8/V1_Overview.html#:~:text=The%20design%20for%20the%20Pre%2DEFI%20Initialization%20(PEI)%20phase%20of%20a%20PI%20Architecture%2Dcompliant%20boot%20is%20as%20an%20essentially%20miniature%20version%20of%20the%20DXE%20phase%20of%20the%20PI%20Architecture%20and%20addresses%20many%20of%20the%20same%20issues." target="_blank" rel="noopener nofollow">---- The design for the Pre-EFI Initialization (PEI) phase of a PI Architecture-compliant boot is as an essentially miniature version of the DXE phase of the PI Architecture and addresses many of the same issues.<br>
---- PEI 本质上是 PI 架构的 DXE 阶段的微型版本，并解决了许多相同的问题。</a></p>
<p><strong>一阵见血。</strong></p>
<p>我们换句话说，PEI阶段是进入DXE阶段前的一个不得已而为之的妥协，或是一个过渡的阶段，我们的目标是进入DXE阶段，能够放开拳脚。</p>
<p>下面介绍一下PEI（Pre-EFI Initialization，EFI前初始化），本人初学者，一家之言，如有错误请留言指正。</p>
<h1 id="为什么有pei阶段">为什么有PEI阶段</h1>
<p>在PEI阶段在SEC阶段之后，尽管进行了SEC的相关工作，但仍然相对初始。</p>
<p>尤其是内存仍然尚未初始化，而想要利用C语言来做一些丰富的功能开发，尽快进入DXE阶段，最关键的是能够大量地使用“<code>栈</code>”。</p>
<p>因此在这个阶段，我们希望可以尽快能够初始化<code>Memory</code>，在一些资料中也被称为<code>“永久内存Permanent Memory”</code>。</p>
<p>此处的永久内存仍然是指<code>Ram</code>，即<code>断电易失的存储器</code>，永久是相对于SEC阶段中的<code>Cache As Ram (CAR)</code>来说的。</p>
<p>在这个阶段仅利用 CPU 上的资源，如将 CPU 的缓存 <code>Cache</code> 作为栈，来调度<code>PEIM（PEI Module）</code>，目的是最快进入DXE阶段。这些 <code>PEIM</code> 负责以下工作：</p>
<blockquote>
<p><a href="https://uefi.org/specs/PI/1.8/V1_Overview.html#:~:text=These%20PEIMs%20are%20responsible%20for%20the%20following" target="_blank" rel="noopener nofollow">UEFI PI Spec 1.8中这样描述的：</a><br>
Initializing some permanent memory complement<br>
初始化一些 永久性内存 作为补充</p>
</blockquote>
<blockquote>
<p>Describing the memory in Hand-Off Blocks (HOBs)<br>
描述 传递块（HOBs）中的内存</p>
</blockquote>
<blockquote>
<p>Describing the firmware volume locations in HOBs<br>
描述 HOBs 中的固件卷位置</p>
</blockquote>
<blockquote>
<p>Passing control into the Driver Execution Environment (DXE) phase<br>
将控制权传递到 驱动执行环境（DXE）阶段</p>
</blockquote>
<blockquote>
<p>Philosophically, the PEI phase is intended to be the thinnest amount of code to achieve the ends listed above. As such, any more sophisticated algorithms or processing should be deferred to the DXE phase of execution.<br>
从哲学上讲，PEI 阶段应该以最少的代码量实现上述目标。因此，任何更复杂的算法或处理都应该推迟到执行 DXE 阶段。<br>
...............</p>
</blockquote>
<p>名词很多，而且<strong>真的很抽象</strong>。</p>
<p>那首先，<code>PEIM</code>是什么？</p>
<h2 id="peim">PEIM</h2>
<p><code>PEIM</code>，PEI阶段对系统的初始化主要由PEIM完成。</p>
<p>在具体地认知上，可以认为是一个个的 <code>*.efi </code> 二进制文件。</p>
<p>可以认为，这些个<code>efi</code>文件就是在UEFI下的可执行文件，类似于我们在单片机中烧写的二进制<code>.bin</code>文件。</p>
<ul>
<li>资料中说，<code>.efi</code>文件格式是基于<code>PE32+</code>的文件格式而来，具体这个<code>PE32+</code>格式是个啥，我们先不细究，<s>反正也细究不明白</s>。</li>
</ul>
<p>更具象地，在编译后的<code>Build</code>文件夹中，例如在 <code>\edk2\Build\OvmfX64\DEBUG_VS2019\X64\</code>这个文件夹下，可以找到大量的 <code>.efi</code> 文件，其中有一部分形如 <code>XxxxxxPei.efi</code> 的文件，例如 <code>S3Resume2Pei.efi</code>文件，使用WinHex等软件可以打开，查看其格式。</p>
<p>流程是：<code>.inf 文件 + .c 文件 + .h 文件 -&gt; build -&gt; .efi</code></p>
<p>知道了什么是PEIM了，那PEIM这些功能模块是怎么怎么在代码中跑起来的呢？下面我们来看下。</p>
<h2 id="一些概念">一些概念</h2>
<ul>
<li>
<p>PEI 内核（在UEFI Spec中叫 <code>PEI Foundation</code>，在EDK2代码中其实就是 <code>PeiCore</code>）：负责PEI阶段的基础服务和流程，可以认为是PEI阶段的内核，在EDK2代码中，具体可以找到<code>MdeModulePkg\Core\Pei\PeiMain\PeiMain.c</code>中的函数<code>PeiCore</code><br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250508162431040-346795268.png" alt="image" loading="lazy"></p>
</li>
<li>
<p>PEIM Dispatcher（调度器）：具体地是在PeiCore中PeiDispatcher函数，Dispatcher会找出系统中的所有PEIM，并根据PEIM之间的依赖关系，按顺序执行PEIM。<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250508165054511-1024012746.png" alt="image" loading="lazy"></p>
</li>
<li>
<p>PEI Foundation，即PeiCore，会建立一个 UEFI规范里叫 PEI Services Table 的变量，实际在代码里如下图中的gPs，该表对所有系统中的 PEIM 可见。通过PEI Services，PEIM 可以调用 PEI 阶段提供的一些系统功能，例如<code>Install PPI、Locate PPI</code> 以及 <code>Notify PPI</code>等。<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250508165430149-50680246.png" alt="image" loading="lazy"><br>
（另外说一嘴，在EDK2中，如果是全局变量就用gVariable的小驼峰形式来标注，如果是仅仅在Module中使用的变量，则mVariable来命名）</p>
</li>
<li>
<p>通过调用这些服务，PEIM可以访问PEI内核。PEIM之间的的通信通过PPI（PEIM-to-PEIM Interfaces）完成。</p>
</li>
</ul>
<p><strong>啥又是Interface？</strong></p>
<h2 id="ppipeim-to-peim-interfaces">PPI（PEIM-to-PEIM Interfaces）</h2>
<p>在EDK2中，Interface接口的概念使用非常多，然而这里的接口并不是类似于Java或者Web的前后端通信的接口。具体在代码的表现上，其实就是一个结构体，这个结构体描述了某一个函数功能的信息，相当于把一个功能函数封装起来。</p>
<p>在<code>MdePkg\Include\Pi\PiPeiCis.h</code>中可以看到<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250508170841503-1256738281.png" alt="image" loading="lazy"></p>
<p><code>PPI</code> 是用 <code>EFI_PEI_PPI_DESCRIPTOR</code> 来封装描述的，里面有个成员是 <code>VOID *Ppi</code>。</p>
<p>这个成员是个指针，一旦初始化这个描述符，也就是说我们绑定了 某个 Guid 和 某个 Ppi 上，并且通过Flags来指定这个Ppi的一些属性。不要忘了，PPI本质上是希望给其他PEIM调用的功能，所以具体的功能函数就应该存放在这个<code>VOID *Ppi</code>里。</p>
<p>前面我们也说了，接口本身是一个结构体，这个<code>VOID *Ppi</code>所以也应该是一个结构体。不信？我们看EDK2中的代码，看看大佬的写法：<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250508172315343-1691691208.png" alt="image" loading="lazy"></p>
<p>可以从上图中看到，首先定义了一个<code>Const EFI_XXX_XXX_PPI类型</code>的 <code>mXxxxPpi</code>，因此，可以说，PPI是一个结构体。这个例子中，结构体中只有一个成员WaitForNotify，这个成员是一个函数。</p>
<p>在实际开发中，<strong><code>Const EFI_XXX_XXX_PPI类型</code>应当是由我们自己定义的，</strong> 为啥呢？</p>
<p>想想开发PEIM的流程，我们应当预先写好相关的函数功能，例如Func1、Func2、Func3，再将这些Func1、Func2、Func3统统包含到一个结构体里，那如何把函数包含到结构体里？当然是自己定义结构体原型了。例如：</p>
<pre><code>// 函数原型，注意这里的函数是没有函数体的
typedef
EFI_STATUS
(EFIAPI *EFI_PEI_FUNC_1)();

typedef
EFI_STATUS
(EFIAPI *EFI_PEI_FUNC_2)();

typedef
EFI_STATUS
(EFIAPI *EFI_PEI_FUNC_3)();

// PPI结构体原型定义
typedef struct _EFI_PEI_FUNC1_FUNC2_FUNC3_PPI
{
  EFI_PEI_FUNC_1 func1;
  EFI_PEI_FUNC_2 func2;
  EFI_PEI_FUNC_3 func3;
} EFI_PEI_FUNC1_FUNC2_FUNC3_PPI;

// 函数功能实现
EFI_STATUS
EFIAPI
Func1(){
  .......
  return EFI_SUCCESS;
}

EFI_STATUS
EFIAPI
Func2(){
  .......
  return EFI_SUCCESS;
}

EFI_STATUS
EFIAPI
Func3(){
  .......
  return EFI_SUCCESS;
}

// 重点来了，实例化Ppi结构体
EFI_PEI_FUNC1_FUNC2_FUNC3_PPI mFunc1Func2Func3Ppi = {
  Func1,
  Func2,
  Func3
};

</code></pre>
<p>紧接着，又利用 <code>EFI_PEI_PPI_DESCRIPTOR</code> 这个描述符封装这个结构体，并指定其Flags属性和绑定<code>Guid</code>，这样以后我们就可以通过Guid来找到这个PPI，从而调用到PPI里的功能了，是不是很<s>麻烦</s>聪明？</p>
<pre><code>EFI_PEI_PPI_DESCRIPTOR mFunc1Func2Func3PpiList = {
  (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
  &amp;gEfiFunc1Func2Func3PpiGuid, // 这个GUID在开头自己定义好，或者使用一些UEFI中的，可以实现一些功能
  &amp;mFunc1Func2Func3Ppi
};

</code></pre>
<p><strong>现在我们知道了怎么定义一个PPI，那该如何完整的开发一个PPI或使用一个PPI呢？</strong></p>
<h1 id="install-一个自己的-ppi">Install 一个自己的 PPI</h1>
<p>这里就涉及到了如何编写一个PEIM模块了，实际上上面的定义一个PPI内容都是某一个xxxPEIM.c的内容。</p>
<p>新建一个文件夹（就是PEIM），路径为<code>edk2\OvmfPkg\MyHelloWorldInstallPpi\</code>，创建两个文件，分别叫做<code>MyHelloWorldInstallPpi.c</code> 、 <code>MyHelloWorldInstallPpi.inf</code><br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509092458424-1894401167.png" alt="image" loading="lazy"></p>
<pre><code>MyHelloWorldInstallPpi.inf
[Defines]
  INF_VERSION                 = 0x00010005
  VERSION_STRING              = 1.0
  BASE_NAME                   = MyHelloWorldInstallPpi
  MODULE_TYPE                 = PEIM # 这里必须得是PEIM，表明我们要创建的是一个PEI Module
  FILE_GUID                   = c4f822d4-02e0-4ebf-854d-390dc8ca6166
  ENTRY_POINT                 = MyInstallPpiEntryPoint # 入口函数可以自己随便起名字，只要和.c文件中的一致即可


[Sources]
  MyHelloWorldInstallPpi.c 
  # 我们这一次实验只有这一个.c函数，我们创建自己的PPI，
  # 功能是输出HelloWorld的debug信息，并且将其Install到PPI Database中，
  # 方便后续我们自己调用

[LibraryClasses]
  BaseLib
  PeimEntryPoint
  BaseMemoryLib
  DebugLib
  PeiServicesLib
  PrintLib

[Packages]
  MdePkg/MdePkg.dec
  ShellPkg/ShellPkg.dec
  MdeModulePkg/MdeModulePkg.dec

[Pcd]

[Ppis]

[Depex]
  TRUE

</code></pre>
<pre><code>MyHelloWorldInstallPpi.c
#include &lt;Uefi.h&gt;
#include &lt;Library/UefiLib.h&gt;
#include &lt;Library/BaseLib.h&gt;
#include &lt;Library/IoLib.h&gt;
#include &lt;Library/DebugLib.h&gt;
#include &lt;Library/BaseMemoryLib.h&gt;
#include &lt;Library/UefiDriverEntryPoint.h&gt;
#include &lt;Library/PeimEntryPoint.h&gt;
#include &lt;Library/PeiServicesLib.h&gt;
#include &lt;Library/PeiServicesTablePointerLib.h&gt;
#include &lt;Pi/PiHob.h&gt;
#include &lt;Pi/PiPeiCis.h&gt;


EFI_GUID gEfiHelloWorldPpiInstallGuid = {0xf0915e25, 0xe749, 0x4a7a, {0x9f, 0x31, 0xbd, 0xb5, 0x4c, 0x05, 0x22, 0xc4}};


/********************************************************************************
 * 当需要将一个PEIM的代码共享给其它PEIM调用的时候，就可以把它安装在PPI的数据库 PPI Database中。
 *
 * 步骤：
 * 1、定义PPI结构体并实例化，结构体里面是具体的功能函数（函数指针）实现
 *
 * 2、将PPI结构体添加到EFI_PEI_PPI_DESCRIPTOR PPI_List[]，这个数组里都是PPI函数指针的struct
 *
 * 3、在入口函数中Install PPI_List[]，将这一套PPI注册在Database中。
 *
********************************************************************************/

// 定义PPI功能函数接口原型和结构体
typedef
EFI_STATUS
(EFIAPI *EFI_PRINT_HELLO_WORLD_MSG)(
  IN  CHAR16        *Msg
);


 typedef struct _EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI
{
  EFI_PRINT_HELLO_WORLD_MSG peiPrintHelloWorldMsg;
} EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI;

// 实现PPI函数功能，并紧接着实例化结构体
// 功能：打印任意字符串Msg
EFI_STATUS
EFIAPI
PrintHelloMsg (
  IN  CHAR16        *Msg
)
{
  DEBUG ((EFI_D_ERROR, "[MyHelloWorldInstallPpi] PRINT_HELLO_WORLD_MSG is called \r\n"));
  DEBUG ((EFI_D_ERROR, "[MyHelloWorldInstallPpi] PrintHelloMsg : %s \r\n", Msg));
  return EFI_SUCCESS;
}

// 实例化PPI结构体
EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI mPeiHelloPpi = {
  PrintHelloMsg
};

// 添加进PPI_LIST[]，并且将PPI和相关的guid绑定
EFI_PEI_PPI_DESCRIPTOR mPeiHelloPpiList[] = {
  {
    (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
    &amp;gEfiHelloWorldPpiInstallGuid,
    &amp;mPeiHelloPpi
  }
};

/*
 * @brief PEIM 的入口函数，PEIM的main函数
 *
 * @return 状态码
 */

EFI_STATUS
EFIAPI
MyInstallPpiEntryPoint(
  IN EFI_PEI_FILE_HANDLE         FileHandle,
  IN CONST EFI_PEI_SERVICES   ** PeiServices
)
{
  EFI_STATUS status;
  DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] MyInstallPpiEntryPoint Start..\r\n"));

  // Install PPI
  status = (*PeiServices) -&gt;InstallPpi (PeiServices, &amp;mPeiHelloPpiList[0]);

  // Install 失败的处理
  if (EFI_ERROR(status))
  {
    DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] Install PPI failed.. \r\n"));
    DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] EFI return value is %d \r\n", status));
    return status;
  }

  // Install 成功，打印通知
  DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] Install PPI success! \r\n"));
  DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] MyHelloWorldInstallPPIEntry End.. \r\n"));

  return EFI_SUCCESS;
}
</code></pre>
<p>这样，就成功的开发了一个PPI。</p>
<p>这个PPI会在PeiCore中受到PeiDispatchor调度，自动运行。</p>
<p>但是我们还不能直接用这个PPI。</p>
<p>上面说过，PPI是PEIM之间的通信方式。</p>
<p>也就是说，PPI是PEIM的对外暴露给其他PEIM的功能接口，因此，我们Install好了PPI还需要再写一个PEIM，来使用我们现在写好的这个PPI。</p>
<h2 id="locate-一个自己的-ppi">Locate 一个自己的 PPI</h2>
<p>Locate PPI，如同Install PPI，也就是PEI Services里，gPs里，EDK2已经给我们写好的一个API.</p>
<p>新建一个文件夹（就是PEIM），路径为<code>edk2\OvmfPkg\MyHelloWorldLocatePpi\</code>，创建两个文件，分别叫做<code>MyHelloWorldLocatePpi.c</code> 、 <code>MyHelloWorldLocatePpi.inf</code><br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509104607788-1931875271.png" alt="image" loading="lazy"></p>
<pre><code>MyHelloWorldLocatePpi.inf
[Defines]
  INF_VERSION                 = 0x00010005
  VERSION_STRING              = 1.0
  BASE_NAME                   = MyHelloWorldLocatePpi
  MODULE_TYPE                 = PEIM
  FILE_GUID                   = af521e0f-4aef-498a-8f19-b1de83a77c70
  ENTRY_POINT                 = MyLocatePpiEntryPoint

[Sources]
  MyHelloWorldLocatePpi.c

[LibraryClasses]
  BaseLib
  PeimEntryPoint
  BaseMemoryLib
  DebugLib
  PeiServicesLib
  PrintLib

[Packages]
  MdePkg/MdePkg.dec
  ShellPkg/ShellPkg.dec
  MdeModulePkg/MdeModulePkg.dec
  OvmfPkg/OvmfPkg.dec # 多一个我们写PPI的那个Pkg

[Pcd]

[Ppis]
  gEfiHelloWorldPpiInstallGuid 
  # 用到了Install这个PEM的PPI，所以要告诉本模块，
  # 该PPI的guid，用于查找；
  # 另外，也可以在C文件中直接调用，更方便

[Depex]
  gEfiHelloWorldPpiInstallGuid 
  # 这边是使用我们自己创建的PpiGuid的，
  # 这样可以确保我们的调用Ppi的函数时，
  # 该Ppi已经被Install了。


</code></pre>
<pre><code>#include &lt;Uefi.h&gt;
#include &lt;Library/UefiLib.h&gt;
#include &lt;Library/BaseLib.h&gt;
#include &lt;Library/IoLib.h&gt;
#include &lt;Library/DebugLib.h&gt;
#include &lt;Library/BaseMemoryLib.h&gt;
#include &lt;Library/UefiDriverEntryPoint.h&gt;
#include &lt;Library/PeimEntryPoint.h&gt;
#include &lt;Library/PeiServicesLib.h&gt;
#include &lt;Library/PeiServicesTablePointerLib.h&gt;
#include &lt;Pi/PiHob.h&gt;
#include &lt;Pi/PiPeiCis.h&gt;

// EFI_GUID gEfiHelloWorldPpiInstallGuid = {0xf0915e25, 0xe749, 0x4a7a, {0x9f, 0x31, 0xbd, 0xb5, 0x4c, 0x05, 0x22, 0xc4}};

// 定义PPI功能函数接口原型和结构体
typedef
EFI_STATUS
(EFIAPI *EFI_PRINT_HELLO_WORLD_MSG)(
  IN  CHAR16        *Msg
);

 typedef struct _EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI
{
  EFI_PRINT_HELLO_WORLD_MSG peiPrintHelloWorldMsg;
} EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI;


EFI_STATUS
EFIAPI
MyLocatePpiEntryPoint(
  IN EFI_PEI_FILE_HANDLE         FileHandle,
  IN CONST EFI_PEI_SERVICES   ** PeiServices
)
{
  EFI_STATUS  Status;
  // 定义一个变量，用于接收解析到的PPI，相当于接受实例
  EFI_PEI_PRINT_HELLO_WORLD_MSG_PPI *mHelloWorldPpi = NULL;

  DEBUG ((EFI_D_ERROR, "[MyLocatePpiEntryPoint] MyLocatePpiEntryPoint Locate PPI Start..\n"));

  // Locate PPI
  Status = PeiServicesLocatePpi (
           &amp;gEfiHelloWorldPpiInstallGuid,// 这里的GUID虽然没有定义也没有extern，但是因为我们在inf里写了，所以可以直接用
           0,
           NULL,
           (VOID **)&amp;mHelloWorldPpi
           );

  if (EFI_ERROR(Status))
  {
    DEBUG ((EFI_D_ERROR, "[MyLocatePpiEntryPoint] Locate PPI failed..\r\n"));
    DEBUG ((EFI_D_ERROR, "[MyInstallPpiEntryPoint] EFI return value is %d \r\n", Status));

    return Status;
  }

  // Locate 成功，打印通知
  DEBUG ((EFI_D_ERROR, "[MyLocatePpiEntryPoint] Locate PPI success! \r\n"));

  // 调用PPI内的功能
  mHelloWorldPpi-&gt; peiPrintHelloWorldMsg(L"2025 Tyler Wang Locate PPI Hello World ...\n");


  DEBUG ((EFI_D_ERROR, "[MyLocatePpiEntryPoint] MyLocatePpiEntryPoint Locate PPI End..\n"));

  return EFI_SUCCESS;
}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509104417921-1131746417.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509104459012-1123352792.png" alt="image" loading="lazy"></p>
<h2 id="编译">编译</h2>
<p>进入<code>edk2</code>目录，在<code>edksetup.bat</code>最后一行添加</p>
<p><code>build -a X64 -p OvmfPkg\OvmfPkgX64.dsc -D DEBUG_ON_SERIAL_PORT</code></p>
<p>这样以后打开cmd之后，只需要运行<code>edksetup.bat</code>即可自动编译出.fd文件。</p>
<p>编译通过之后，使用qemu模拟器。<br>
在qemu模拟器的路径下，例如我是<code>D:\Program Files\qemu</code>，创建<code>setup-qemu-x64.bat</code>文件。</p>
<p>里面内容是：</p>
<pre><code>"D:\Program Files\qemu\qemu-system-x86_64.exe" -bios "D:\edk2\edk2\Build\OvmfX64\DEBUG_VS2019\FV\OVMF.fd" -M "pc" -m 256 -cpu "qemu64" -boot order=dc -serial stdio
</code></pre>
<p>这里面的路径请根据自己打情况自行修改。</p>
<p>在qemu模拟器的路径下，cmd运行<code>setup-qemu-x64.bat | findstr "Hello World"</code>，如下图<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509153227949-1875578095.png" alt="image" loading="lazy"></p>
<p>可以观察到Hello World现象了。</p>
<h1 id="后记">后记</h1>
<p>InstallPpi.c文件写好了之后，我中间编译了好几次，一直显示fail，如下图：<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509143200332-759150752.png" alt="image" loading="lazy"></p>
<pre><code>一直以为是我的cl.exe环境配置有问题
NMAKE : fatal error U1077: D:\Develop\Microsoft\VisualStudio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx86\x64\cl.exe: ش롰0x2
Stop.
</code></pre>
<p>然而，在我删去自己的PEIM重新编译OvmfPkg这个dsc之后，却可以编译通过。</p>
<p>百思不得其解。</p>
<p>接下来的编译失败的信息也少得可怜，也仅仅是告知我是我的PEIM模块出了问题。。。。</p>
<pre><code>build.py...
 : error 7000: Failed to execute command
        D:\Develop\Microsoft\VisualStudio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx86\x86\nmake.exe /nologo tbuild [D:\edk2\edk2\Build\OvmfX64\DEBUG_VS2019\X64\OvmfPkg\MyHelloWorldInstallPpi\MyHelloWorldInstallPpi]


build.py...
 : error F002: Failed to build module
        D:\edk2\edk2\OvmfPkg\MyHelloWorldInstallPpi\MyHelloWorldInstallPpi.inf [X64, VS2019, DEBUG]
</code></pre>
<p>虽然始终找不到问题在哪里，但是可以确定是自己的问题，接下来就是开始漫长的排查。</p>
<p>下面介绍一下我的做法，供给后来的和我一样的小白们参考/(ㄒoㄒ)/~~</p>
<p>Step 1、将.c文件中所有东西都注释掉，仅仅保留 入口函数和return EFI_SUCCESS；语句</p>
<p><img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509144411070-1806236718.png" alt="image" loading="lazy"></p>
<p><strong>build一下，发现可以通过。</strong></p>
<p>Step 2、将入口函数中的语句一行一行取消注释。。。。。到了哪一句无法编译通过，就是谁的问题。</p>
<p>后来<strong>终于定位到了，</strong>原来是这里DEBUG，不小心少复制了一个D<br>
<img src="https://img2024.cnblogs.com/blog/3273121/202505/3273121-20250509143414977-1189721599.png" alt="image" loading="lazy"></p>
<p>不得不吐槽，vscode 配合 EDK2原生的这个编译器，真是个灾难，编译不通过什么提示都没有。。。。定位这么小的错误需要半天!!!!!!!</p>
<p>vscode更是个大烂货，这么明显的错误都没有提示~~~~</p>
<p>这个一句句的排查也只能够是这种实验的小模块，如果是大工程，那就很耗费精力了。。。。（<s>也许可以2分法排查？</s>）</p>
<p>看来，写一点编译一点，这是一个好习惯。</p>
<p><strong>少写多编，少些多提交，始终是个习惯啊</strong></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7291172043553241" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-09 15:38">2025-05-09 15:37</span>&nbsp;
<a href="https://www.cnblogs.com/tylerw">Tyler77</a>&nbsp;
阅读(<span id="post_view_count">71</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18866414);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18866414', targetLink: 'https://www.cnblogs.com/tylerw/p/18866414', title: '【UEFI】PEI阶段从概念到代码' })">举报</a>
</div>
        