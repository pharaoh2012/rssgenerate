
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mghio/p/18809618" title="发布于 2025-04-04 23:36">
    <span role="heading" aria-level="2">Dubbo 中的集群容错</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1924094/202504/1924094-20250404233536171-1796969975.png" alt="Dubbo 中的集群容错" class="desc_img">
        在微服务架构中，服务间的依赖关系复杂且动态，任何一个服务的故障都可能引发连锁反应，导致系统雪崩，一个好的容错设计至关重要。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1924094/202504/1924094-20250404233506027-48030849.jpg" alt="" loading="lazy"></p>
<h3 id="前言">前言</h3>
<p>在微服务架构中，服务间的依赖关系复杂且动态，任何一个服务的故障都可能引发连锁反应，导致系统雪崩。一个好的容错设计可以避免这些问题发生：</p>
<ul>
<li>
<p><strong>服务雪崩效应</strong>：单个服务崩溃或响应延迟可能导致调用链上的所有服务被阻塞，最终拖垮整个系统。例如，若服务 A 依赖服务 B，而服务 B 因高负载无法响应，A 的线程池可能被占满，进而影响其他依赖A的服务；</p>
</li>
<li>
<p><strong>分布式系统的脆弱性</strong>：网络抖动、节点宕机、资源耗尽等问题在分布式环境中不可避免。容错机制通过冗余和快速失败策略，确保部分故障不会扩散到整个系统；</p>
</li>
<li>
<p><strong>服务的可用性低</strong>：微服务的目标是提升系统可用性，而容错设计（如故障转移、熔断）是保障服务持续可用的核心手段。例如，通过自动切换健康节点，避免单点故障。</p>
</li>
</ul>

<h3 id="dubbo-的集群容错机制">Dubbo 的集群容错机制</h3>
<p>在 Dubbo 中，多个 Provider 实例构成一个「集群」。消费者调用时，Dubbo 通过 Cluster 模块实现容错策略的封装和路由，Cluster 模块会根据配置（如 cluster=failover）装配不同的容错策略实现类，对 Directory 中的多个 Invoker 进行处理，返回一个可执行的 Invoker。Dubbo 当前已支持以下 6 种容错策略（在 <code>org.apache.dubbo.rpc.cluster.support</code> 包下）：</p>
<table>
<thead>
<tr>
<th style="text-align: center">策略简称</th>
<th style="text-align: center">实现类名</th>
<th style="text-align: center">特性</th>
<th style="text-align: center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Failover</td>
<td style="text-align: center">FailoverClusterInvoker</td>
<td style="text-align: center">失败自动重试，默认实现</td>
<td style="text-align: center">网络不稳定，民登操作</td>
</tr>
<tr>
<td style="text-align: center">Failfast</td>
<td style="text-align: center">FailfastClusterInvoker</td>
<td style="text-align: center">快速失败，不重试</td>
<td style="text-align: center">响应时间敏感，非幂等</td>
</tr>
<tr>
<td style="text-align: center">Failsafe</td>
<td style="text-align: center">FailsafeClusterInvoker</td>
<td style="text-align: center">失败忽略异常</td>
<td style="text-align: center">日志记录、监控等非主要场景</td>
</tr>
<tr>
<td style="text-align: center">Failback</td>
<td style="text-align: center">FailbackClusterInvoker</td>
<td style="text-align: center">失败后后台重试</td>
<td style="text-align: center">可容忍失败，后续补偿重试</td>
</tr>
<tr>
<td style="text-align: center">Forking</td>
<td style="text-align: center">ForkingClusterInvoker</td>
<td style="text-align: center">并行调用多个节点，最快成功返回</td>
<td style="text-align: center">实时性要求高，资源充足</td>
</tr>
<tr>
<td style="text-align: center">Broadcast</td>
<td style="text-align: center">BroadcastClusterInvoker</td>
<td style="text-align: center">广播方式调用所有服务提供着</td>
<td style="text-align: center">配置更新、通知类等操作</td>
</tr>
</tbody>
</table>
<h4 id="failover-cluster失败自动切换默认策略">Failover Cluster（失败自动切换，默认策略）</h4>
<p><strong>实现原理</strong>：通过循环重试实现容错。<br>
实现源码关键点：</p>
<ol>
<li>FailoverClusterInvoker 的 doInvoke 方法中，通过 for 循环控制重试次数（默认重试 2 次，共调用 3 次）;</li>
<li>每次重试前调用 list(invocation) 重新获取最新的 Invoker 列表，确保动态感知节点变化。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker#doInvoke
for (int i = 0; i &lt; len; i++) {
    if (i &gt; 0) {
        copyInvokers = list(invocation); // 动态刷新 Invoker 列表
    }
    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);
    // 调用并处理异常...
}
</code></pre>
<h4 id="failfast-cluster快速失败">Failfast Cluster（快速失败）</h4>
<p><strong>实现原理</strong>：仅发起一次调用，异常直接抛出。<br>
实现源码关键点：</p>
<ol>
<li>FailfastClusterInvoker 直接调用目标 Invoker，不进行重试。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailfastClusterInvoker#doInvoke
fpublic Result doInvoke(...) throws RpcException {
    checkInvokers(invokers, invocation);
    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, null);
    return invoker.invoke(invocation); // 仅一次调用
}
</code></pre>
<h4 id="failsafe-cluster失败安全">Failsafe Cluster（失败安全）</h4>
<p><strong>实现原理</strong>：异常被捕获后返回空结果，不中断流程。<br>
实现源码关键点：</p>
<ol>
<li>ailsafeClusterInvoker通过try-catch捕获异常并记录日志。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailsafeClusterInvoker
try {
    // 调用逻辑...
} catch (Throwable e) {
    logger.error("Failsafe ignore exception", e);
    return new RpcResult(); // 返回空结果
}
</code></pre>
<h4 id="failback-cluster失败自动恢复">Failback Cluster（失败自动恢复）</h4>
<p><strong>实现原理</strong>：失败请求存入队列，定时重试。<br>
实现源码关键点：</p>
<ol>
<li>捕获失败异常，使用 RetryTimerTask 存储失败请求，定时触发重试。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailbackClusterInvoker#doInvoke
private void addFailed(
        LoadBalance loadbalance,
        Invocation invocation,
        List&lt;Invoker&lt;T&gt;&gt; invokers,
        Invoker&lt;T&gt; lastInvoker,
        URL consumerUrl) {
    if (failTimer == null) {
        synchronized (this) {
            if (failTimer == null) {
                failTimer = new HashedWheelTimer(
                        new NamedThreadFactory("failback-cluster-timer", true),
                        1,
                        TimeUnit.SECONDS,
                        32,
                        failbackTasks);
            }
        }
    }
    RetryTimerTask retryTimerTask = new RetryTimerTask(
            loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD, consumerUrl);
    try {
        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);
    } catch (Throwable e) {
        logger.error(
                CLUSTER_TIMER_RETRY_FAILED,
                "add newTimeout exception",
                "",
                "Failback background works error, invocation-&gt;" + invocation + ", exception: " + e.getMessage(),
                e);
    }
}
</code></pre>
<h4 id="forking-cluster并行调用">Forking Cluster（并行调用）</h4>
<p><strong>实现原理</strong>：并发调用多个节点，首个成功结果即返回。<br>
实现源码关键点：</p>
<ol>
<li>使用线程池并发调用，结果通过 BlockingQueue 异步接收。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.ForkingClusterInvoker#doInvoke
for (Invoker&lt;T&gt; invoker : selected) {
    executor.execute(() -&gt; {
        Result result = invoker.invoke(invocation);
        ref.offer(result); // 结果存入队列
    });
}
</code></pre>
<h4 id="broadcast-cluster广播调用">Broadcast Cluster（广播调用）</h4>
<p><strong>实现原理</strong>：逐个调用所有节点，任一失败则整体失败。<br>
实现源码关键点：</p>
<ol>
<li>遍历所有 Invoker 调用，异常累积后抛出。</li>
</ol>
<pre><code class="language-Java">// 代码片段：org.apache.dubbo.rpc.cluster.support.BroadcastClusterInvoker#doInvoke
for (Invoker&lt;T&gt; invoker : invokers) {
    try {
        invoker.invoke(invocation);
    } catch (RpcException e) {
        exception = e;
    }
}
if (exception != null) throw exception;
</code></pre>
<h3 id="如何自定义集群容错策略">如何自定义集群容错策略</h3>
<p>如果以上提供的容错策略不满足需求，Dubbo 支持通过 SPI 自定义 Cluster 实现，步骤如下：</p>
<h5 id="第一步实现-cluster-和-abstractclusterinvoker">第一步：实现 Cluster 和 AbstractClusterInvoker</h5>
<pre><code class="language-Java">@SPI("custom")
public class MyCluster implements Cluster {

    @Override
    public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) {
        return new MyClusterInvoker&lt;&gt;(directory);
    }

}
</code></pre>
<pre><code class="language-Java">public class MyClusterInvoker&lt;T&gt; extends AbstractClusterInvoker&lt;T&gt; {

    @Override
    protected Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) {
        // 自定义逻辑，例如条件重试、动态路由等
    }

}
</code></pre>
<h5 id="第二步添加-spi-配置">第二步：添加 SPI 配置</h5>
<p>在 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.Cluster</code> 中添加配置：</p>
<pre><code class="language-xml">mycluster=com.example.MyCluster
</code></pre>
<h5 id="第三步配置使用自定义容错策略">第三步：配置使用自定义容错策略</h5>
<pre><code class="language-xml">&lt;dubbo:reference cluster="mycluster" /&gt;
</code></pre>
<h3 id="总结">总结</h3>
<p>建议核心服务优先使用 <code>Failover（失败自动切换）</code> 策略保障可用性，非核心服务可降级为 <code>Failsafe（失败安全）</code>。同时结合 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener nofollow">Hystrix(已停止更新)</a> 或 <a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener nofollow">Sentinel</a> 实现熔断与限流，增强容错能力。</p>
<p>通过灵活组合 Dubbo 的容错策略，可显著提升分布式系统的鲁棒性。实际应用配置时需要根据业务特性权衡延迟、资源开销与一致性要求，一切皆是 trade off ～</p>
<p><strong>P.S.</strong> 不妨再深入思考一下：Dubbo 的集群容错实现中有哪些优秀设计值得我们学习？</p>

</div>
<div id="MySignature" role="contentinfo">
    Java 搬运工 &amp; 终身学习者 @ 微信公众号「mghio」
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0289402484375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-04 23:37">2025-04-04 23:36</span>&nbsp;
<a href="https://www.cnblogs.com/mghio">mghio</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18809618" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18809618);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18809618', targetLink: 'https://www.cnblogs.com/mghio/p/18809618', title: 'Dubbo 中的集群容错' })">举报</a>
</div>
        