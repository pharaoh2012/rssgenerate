
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/-Acheron-/p/18700032" title="发布于 2025-02-05 19:32">
    <span role="heading" aria-level="2">后缀自动机 (SAM)学习笔记</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="1-前言">1. 前言</h4>
<p>后缀自动机是一种高效的有穷状态机，用于表示一个字符串的所有可能的后缀子串。与传统的后缀树相比，后缀自动机具有较小的空间复杂度和较快的构建速度。</p>
<p>它就是一个要实现能存下一个串中所有子串的算法，按一般来说应当有个状态，而 SAM 却可以用 O(N) 个状态来表示所有子串，因为它把很多个本质相似的子串映射到了同一个状态上。</p>
<hr>
<h4 id="2-基础概念">2. 基础概念</h4>
<h5 id="a-状态">a. 状态</h5>
<ul>
<li><strong>定义</strong>：状态表示了所有具有相同最长公共前缀的子串。</li>
<li><strong>属性</strong>：
<ul>
<li><code>len</code>：该状态所代表的子串的最大长度。</li>
<li><code>link</code>：指向另一个状态的指针，用于表示当前状态与前一状态的关系。</li>
</ul>
</li>
</ul>
<h5 id="b-转移边">b. 转移边</h5>
<ul>
<li><strong>定义</strong>：转移边表示从一个状态到另一个状态的路径，通常由字符触发。</li>
<li><strong>结构</strong>：每个状态可以有多个转移边，通过这些边可以到达其他状态。</li>
</ul>
<h5 id="c-后缀链">c. 后缀链</h5>
<ul>
<li><strong>定义</strong>：后缀链是一系列状态的连接，用于表示字符串中不同长度的后缀子串之间的关系。</li>
<li><strong>作用</strong>：在构建自动机时，后缀链帮助维护最长公共前缀的信息。</li>
</ul>
<hr>
<h4 id="3-构建后缀自动机">3. 构建后缀自动机</h4>
<h5 id="a-初始化">a. 初始化</h5>
<ol>
<li>创建初始状态（<code>init</code>），其 <code>len</code> 为 -1，<code>link</code> 指针指向自身。</li>
<li>当前最后插入的字符所对应的节点为 <code>last</code>。</li>
</ol>
<h5 id="b-扩展节点">b. 扩展节点</h5>
<ul>
<li><strong>步骤</strong>：
<ol>
<li><strong>创建新节点</strong>：当处理一个新的字符时，首先创建一个新的状态，并将其 <code>len</code> 设置为当前 <code>last</code> 的 <code>len</code> + 1。</li>
<li><strong>回溯检查</strong>：从当前 <code>last</code> 开始回溯，沿着转移边和后缀链寻找可以添加新转移边的状态。如果某个状态的子节点已经存<br>
在，则更新 <code>link</code> 指针。</li>
<li><strong>维护最后公共状态</strong>：在回溯过程中，确保所有相关状态的后缀链正确。</li>
</ol>
</li>
</ul>
<h5 id="c-实现细节">c. 实现细节</h5>
<ul>
<li>使用C++中的类或结构体来表示状态和转移边：</li>
</ul>
<pre><code class="language-cpp">struct state {
    int len;
    int link;
    unordered_map&lt;char, int&gt; next;  // 转移边：字符到状态的映射
};
</code></pre>
<hr>
<h4 id="4-核心算法">4. 核心算法</h4>
<h5 id="a-延伸节点">a. 延伸节点</h5>
<ul>
<li><strong>函数描述</strong>：
<ul>
<li>给定当前 <code>last</code> 状态和一个新字符 <code>c</code>，创建并返回新的状态。</li>
</ul>
</li>
<li><strong>实现步骤</strong>：
<ol>
<li>初始化新的状态 <code>p</code>，并将 <code>p.len = last-&gt;len + 1</code>。</li>
<li>遍历从 <code>last</code> 开始的后缀链，寻找可以添加转移边的状态 <code>q</code>。</li>
<li>更新 <code>q</code> 的子节点，确保不存在冲突。</li>
<li>返回新状态 <code>p</code> 并更新 <code>last</code>。</li>
</ol>
</li>
</ul>
<h5 id="b-计算出现次数">b. 计算出现次数</h5>
<ul>
<li><strong>方法</strong>：
<ul>
<li>利用后缀自动机的性质，通过遍历所有状态并统计其 <code>len</code> 属性来计算不同子串的出现次数。</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<pre><code class="language-cpp">int countOccurrences() {
    int res = 0;
    for (const auto&amp; state : states) {
        if (state.len != -1) {
            res += state.len - state.link;
        }
    }
    return res;
}
</code></pre>
<h5 id="c-最长公共前缀">c. 最长公共前缀</h5>
<ul>
<li><strong>方法</strong>：
<ul>
<li>在两个字符串中找到最长的共同前缀。</li>
</ul>
</li>
<li><strong>实现步骤</strong>：
<ol>
<li>将问题转换为在后缀自动机中查找对应的路径。</li>
<li>使用回溯算法从根节点开始，沿着转移边寻找最长公共前缀。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="5-高级应用">5. 高级应用</h4>
<h5 id="a-最长回文子串">a. 最长回文子串</h5>
<ul>
<li><strong>思路</strong>：
<ul>
<li>利用后缀自动机和一些辅助数据结构（如哈希表和manacher）来记录每个位置的对称信息。</li>
<li>遍历所有可能的中心点，寻找最长的回文。</li>
</ul>
</li>
</ul>
<h5 id="b-多模式匹配">b. 多模式匹配</h5>
<ul>
<li><strong>方法</strong>：
<ul>
<li>将多个模式字符串合并到同一个后缀自动机中。</li>
<li>使用自动机进行高效的多模式匹配。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-常见问题与调试技巧">6. 常见问题与调试技巧</h4>
<h5 id="a-内存泄漏">a. 内存泄漏</h5>
<ul>
<li>确保每个新创建的状态都被正确释放。</li>
</ul>
<h5 id="b-指针错误">b. 指针错误</h5>
<ul>
<li>仔细检查所有状态的 <code>link</code> 和 <code>next</code> 属性是否初始化正确。</li>
</ul>
<h5 id="c-性能优化">c. 性能优化</h5>
<ul>
<li>使用更高效的数据结构（如跳表或平衡二叉树）替代默认的哈希表。</li>
<li>并行化某些不依赖顺序的计算步骤。</li>
</ul>
<h4 id="7更多模型扩展">7.更多模型扩展</h4>
<h5 id="1检查字符串是否出现">1.检查字符串是否出现</h5>
<ul>
<li>题面
<ul>
<li>给一个文本串 s 和多个模式串 t，我们要检查字符串 t 是否作为 s 的一个子串出现。</li>
</ul>
</li>
<li>思路
<ul>
<li>我们先对 s 构建自动机。为了检查模式串 t 是否在 s 中出现，我们沿转移边从起点开始根据 t 的字符进行转移。如果在某个点无法转移下去，则模式串 t 不是 s 的一个子串。如果我们能够这样处理完整个字符串 t，那么模式串在 s 中出现过。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2计算给定的字符串中有多少个不同的子串">2.计算给定的字符串中有多少个不同的子串。</h5>
<ul>
<li>题面
<ul>
<li>给一个字符串 s，计算不同子串的个数。</li>
</ul>
</li>
<li>思路
<ul>
<li>对字符串 s 构造后缀自动机。每个 s 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 t_0 为起点的不同路径的条数。令 <span class="math inline">\(d_{v}\)</span> 为从状态 v 开始的路径数量（包括长度为零的路径）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3所有不同子串的总长度">3.所有不同子串的总长度</h5>
<ul>
<li>题面
<ul>
<li>给定一个字符串 s，计算所有不同子串的总长度。</li>
</ul>
</li>
<li>思路
<ul>
<li>本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 <span class="math inline">\(d_{v}\)</span> 和它们的总长度 <span class="math inline">\(ret_{v}\)</span>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4字典序第-k-大子串">4.字典序第 k 大子串</h5>
<ul>
<li>题面
<ul>
<li>给定一个字符串 s。多组询问，每组询问给定一个数 k，查询 S 的所有子串中字典序第 k 大的子串。</li>
</ul>
</li>
<li>思路
<ul>
<li>字典序第 k 大的子串对应于 SAM 中字典序第 k 大的路径，因此在计算每个状态的路径数后，我们可以很容易地从 SAM 的根开始找到第 k 大的路径。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5最小循环移位">5.最小循环移位</h5>
<ul>
<li>题面
<ul>
<li>给定一个字符串 s。找出字典序最小的循环移位。</li>
</ul>
</li>
<li>思路
<ul>
<li>字符串 S+S 包含字符串 S 的所有循环移位作为子串。所以问题简化为在 S+S 对应的后缀自动机上寻找最小的长度为 <span class="math inline">\(\left|S\right|\)</span> 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6第一次出现的位置">6.第一次出现的位置</h5>
<ul>
<li>题面
<ul>
<li>给定一个文本串 t，多组查询。每次查询字符串 s 在字符串 t 中第一次出现的位置（s 的开头位置）。</li>
</ul>
</li>
<li>思路
<ul>
<li>
<p>这种题又朴素的 O(T|t|) 的做法，但是显然过不了。考虑优化：<br>
我们构造一个后缀自动机。我们对 SAM 中的所有状态预处理位置 <span class="math inline">\(\operatorname{firstpos}\)</span>。即，对每个状态 v 我们想要找到第一次出现这个状态的末端的位置 <span class="math inline">\(\operatorname{firstpos}[v]\)</span>。换句话说，我们希望先找到每个集合 <span class="math inline">\(\operatorname{endpos}\)</span> 中的最小的元素（显然我们不能显式地维护所有 <span class="math inline">\(\operatorname{endpos}\)</span> 集合）。</p>
<p>为了维护 <span class="math inline">\(\operatorname{firstpos}\)</span> 这些位置，我们将原函数扩展为 sam_extend()。当我们创建新状态 <span class="math inline">\(\textit{cur}\)</span> 时，我们令：</p>
<p></p><div class="math display">\[\operatorname{firstpos}(\textit{cur})=\operatorname{len}(\textit{cur})-1
\]</div><p></p><p>当我们将结点 q 复制到 <span class="math inline">\(\textit{clone}\)</span> 时，我们令：</p>
<p></p><div class="math display">\[\operatorname{firstpos}(\textit{clone})=\operatorname{firstpos}(q)
\]</div><p></p><p>（因为值的唯一的其它选项 <span class="math inline">\(\operatorname{firstpos}(\textit{cur})\)</span> 显然太大了）。</p>
<p>那么查询的答案就是 <span class="math inline">\(\operatorname{firstpos}(t)-\left|s\right|+1\)</span>，其中 t 为对应字符串 s 的状态。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7所有出现的位置">7.所有出现的位置</h5>
<ul>
<li>题面
<ul>
<li>问题同上，这一次需要查询文本串 t 中模式串出现的所有位置。</li>
</ul>
</li>
<li>思路
<ul>
<li>利用后缀自动机的树形结构，遍历子树，一旦发现终点节点就输出。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8最短的没有出现的字符串">8.最短的没有出现的字符串</h5>
<ul>
<li>题面
<ul>
<li>给定一个字符串 s 和一个特定的字符集，我们要找一个长度最短的没有在 s 中出现过的字符串。</li>
</ul>
</li>
<li>思路
<ul>
<li>令 <span class="math inline">\(d_{v}\)</span> 为节点 v 的答案，即，我们已经处理完了子串的一部分，当前在状态 v，想找到不连续的转移需要添加的最小字符数量。计算 <span class="math inline">\(d_{v}\)</span> 非常简单。如果不存在使用字符集中至少一个字符的转移，则 <span class="math inline">\(d_{v}=1\)</span>。否则添加一个字符是不够的，我们需要求出所有转移中的最小值</li>
</ul>
</li>
</ul>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.36367005667361113" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-05 19:32">2025-02-05 19:32</span>&nbsp;
<a href="https://www.cnblogs.com/-Acheron-">_Acheron</a>&nbsp;
阅读(<span id="post_view_count">35</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18700032" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18700032);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18700032', targetLink: 'https://www.cnblogs.com/-Acheron-/p/18700032', title: '后缀自动机 (SAM)学习笔记' })">举报</a>
</div>
        