
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18701895" title="发布于 2025-02-06 23:37">
    <span role="heading" aria-level="2">【忍者算法】从图书馆编目到数组搜索：探索缺失的第一个正整数｜LeetCode 41 缺失的第一个正整数</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从图书馆编目到数组搜索探索缺失的第一个正整数">从图书馆编目到数组搜索：探索缺失的第一个正整数</h1>
<h2 id="生活中的算法">生活中的算法</h2>
<p>想象你是一位图书馆管理员，正在整理一排连续编号的图书。这些书应该从1号开始按顺序排列，但是有些编号的书不见了。你的任务是找出第一个缺失的编号。这就像是在做点名，发现第一个没来上课的同学。</p>
<p>这个场景在生活中很常见。比如：</p>
<ul>
<li>餐厅服务员查看哪个桌号是第一个空位</li>
<li>停车场管理员寻找第一个空闲的车位号</li>
<li>学校给新生分配第一个未使用的学号</li>
<li>医院为病人安排第一个可用的就诊序号</li>
</ul>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第41题"缺失的第一个正整数"是这样描述的：给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<p>例如：</p>
<pre><code>输入：nums = [3,4,-1,1]
输出：2
解释：数组中有1，3，4，所以第一个缺失的正整数是2。

输入：nums = [7,8,9,11,12]
输出：1
解释：数组中没有1，所以缺失的第一个正整数是1。
</code></pre>
<h2 id="最直观的解法排序后遍历">最直观的解法：排序后遍历</h2>
<p>就像整理图书时，先把所有的书按编号排好序，然后从1开始检查，看哪个编号最先空缺。</p>
<p>让我们用一个简单的例子来理解：</p>
<pre><code>原数组：[3,1,4,-1]
1. 先排序（只考虑正数）：[1,3,4]
2. 从1开始检查：
   - 1存在
   - 2不存在，找到答案！
</code></pre>
<h2 id="优化解法原地标记">优化解法：原地标记</h2>
<p>仔细思考会发现一个关键点：如果数组长度为n，那么答案一定在[1, n+1]范围内。就像有10个学生的班级，第一个缺席的学号最大不会超过11。</p>
<p>我们可以把数组本身作为标记板，把每个数放到它应该在的位置上（就像把每本书放到对应的编号位置）。</p>
<h3 id="原地标记的原理">原地标记的原理</h3>
<ol>
<li>把每个在[1,n]范围内的数x放到索引x-1的位置</li>
<li>再次遍历，第一个不在对应位置的数就指示了缺失的最小正整数<br>
这就像是：</li>
</ol>
<ul>
<li>先把每本书放到它编号对应的书架位置</li>
<li>然后从1号位置开始检查，找到第一个空位置</li>
</ul>
<h3 id="示例演示">示例演示</h3>
<p>用nums = [3,4,-1,1]来说明：</p>
<pre><code>1. 开始移动元素：
   [3,4,-1,1] 把3放到索引2
   [3,4,3,1] 把4放到索引3
   [3,1,3,4] 把1放到索引0
   [1,3,3,4]

2. 再次遍历，检查每个位置：
   位置0：期望1，实际1，正确
   位置1：期望2，实际3，找到答案2！
</code></pre>
<h3 id="java代码实现">Java代码实现</h3>
<pre><code class="language-java">public int firstMissingPositive(int[] nums) {
    int n = nums.length;
    
    // 第一遍遍历：把每个数放到它应该在的位置
    for (int i = 0; i &lt; n; i++) {
        // 当前数在有效范围内，且不在正确位置上
        while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - 1]) {
            // 交换到正确位置
            int temp = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = temp;
        }
    }
    
    // 第二遍遍历：找出第一个不在正确位置上的数
    for (int i = 0; i &lt; n; i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }
    
    // 如果都正确，返回n+1
    return n + 1;
}
</code></pre>
<h2 id="解法比较">解法比较</h2>
<p>让我们比较这两种方法：</p>
<p>排序后遍历：</p>
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
<li>优点：思路直观，易于理解</li>
<li>缺点：不满足时间复杂度要求</li>
</ul>
<p>原地标记：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
<li>优点：满足所有要求，不需要额外空间</li>
<li>缺点：实现略微复杂，需要仔细处理边界情况</li>
</ul>
<h2 id="解题技巧总结">解题技巧总结</h2>
<p>这道题给我们的启示：</p>
<ol>
<li>思考数据的取值范围很重要</li>
<li>有时候可以把数组本身当作标记数组使用</li>
<li>位置和值的对应关系常常能带来灵感</li>
<li>不要害怕修改原数组，有时这是提高效率的关键</li>
</ol>
<p>类似的问题还有：</p>
<ul>
<li>数组中重复的数字</li>
<li>找到所有数组中消失的数字</li>
<li>寻找重复数</li>
</ul>
<h2 id="小结">小结</h2>
<p>通过缺失的第一个正整数这道题，我们学会了一个重要的思维方式：有时候看似需要额外空间的问题，可以通过巧妙利用输入数组本身来解决。这种思维不仅在这道题中有用，在处理其他需要标记或计数的问题时也很有启发。记住，当遇到需要找寻特定范围内缺失数字的问题时，考虑能否利用数组本身来存储信息！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>完整题解项目 ：<a href="https://github.com/ninjaAlgorithm/LeetCode-Solutions-Hot-100" target="_blank" rel="noopener nofollow">https://github.com/ninjaAlgorithm/LeetCode-Solutions-Hot-100</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.026102671752314816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-06 23:38">2025-02-06 23:37</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18701895" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18701895);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18701895', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18701895', title: '【忍者算法】从图书馆编目到数组搜索：探索缺失的第一个正整数｜LeetCode 41 缺失的第一个正整数' })">举报</a>
</div>
        