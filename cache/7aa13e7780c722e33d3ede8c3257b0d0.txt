
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/linjinkun/p/18815550" title="发布于 2025-05-05 20:16">
    <span role="heading" aria-level="2">反悔贪心&amp;局部调整法学习笔记</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="一什么是反悔贪心">一、什么是反悔贪心</h3>
<p>反悔贪心就是在普通贪心的过程中“反悔”，从而使得一些看似不太好贪心的题变成贪心可做题。</p>
<h3 id="二反悔贪心普遍流程">二、反悔贪心普遍流程</h3>
<p>就是先使用一个好想的贪心策略，使用优先队列进行维护，然后如果在贪心时发现一个东西不能选，那你要考虑之前选的东西里面是否有比这个东西相对意义更差的东西，如果有就丢掉之前选的那个比较差的东西，把这个比较好的东西塞进优先队列里，这就是“反悔”。</p>
<h3 id="三反悔贪心框架">三、反悔贪心框架</h3>
<pre><code class="language-cpp">priority_queue&lt;int&gt;q;//这里默认大根堆，但有时候需要小根堆
开始贪心
{
	if(这个东西可以选)
	{
		q.push(这个东西);
		//增加计数，有些题目可能还需要增加其它东西
	}
	else if(q.size()&amp;&amp;队列里最不好的东西比这个东西差)
	{
		//增加计数，有些题目可能还需要增加其它东西
		q.pop();//扔掉差的
		q.push(这个东西);//扔进好的
	}
}
</code></pre>
<p><strong>注意：这只是板子，应用时请随机应变。</strong></p>
<h3 id="四反悔贪心例题讲解">四、反悔贪心例题讲解</h3>
<h4 id="cf1974g-money-buys-less-happiness-now"><a href="https://www.luogu.com.cn/problem/CF1974G" target="_blank" rel="noopener nofollow">CF1974G Money Buys Less Happiness Now</a></h4>
<p>反悔贪心模板题，首先如果你能增加幸福值就增加幸福值，如果你不能增加（没钱了）那就看看之前是在哪些月份获取了幸福值，找到价格最贵的那一个月，如果那一个月的价格比这个月的价格高，扔掉那一个月，加入这个月（因为这样会让钱变得更多，而且不会影响幸福值）。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
signed main()
{
    int _;
    scanf("%d",&amp;_);
    while(_--)
    {
        priority_queue&lt;int&gt;q;
        int n,m,sum = 0,num = 0;
        scanf("%d %d",&amp;n,&amp;m);
        for(int i = 1;i&lt;=n;i++,sum+=m)
        {
            int x;
            scanf("%d",&amp;x);
            if(x&lt;=sum)
            {
                sum-=x;
                num++;
                q.push(x);
            }
            else if(q.size()&amp;&amp;q.top()&gt;x)
            {
                sum+=q.top()-x;
                q.pop();
                q.push(x);
            }
        }
        printf("%d\n",num);
    }
    return 0;
}
</code></pre>
<h4 id="cf1526c2-potions-hard-version"><a href="https://www.luogu.com.cn/problem/CF1526C2" target="_blank" rel="noopener nofollow">CF1526C2 Potions (Hard Version)</a></h4>
<p>首先如果读入的 <span class="math inline">\(x \ge 0\)</span>，那肯定是选的，因为不会对答案造成任何负面影响，然后如果 <span class="math inline">\(sum+x \ge 0\)</span>，虽然会让 <span class="math inline">\(sum\)</span>（目前前缀和）变得更小，但是依旧不影响，所以也是可以直接选的，只不过这里得加入优先队列（因为前面大于等于 <span class="math inline">\(0\)</span> 的数，对后面无法选择不会造成影响，没必要加入优先队列，因为后面如果无法选择那肯定是负数，负数不可能大于大于等于 <span class="math inline">\(0\)</span> 的数），然后如果 <span class="math inline">\(sum+x&lt;0\)</span>，就是无法选择，那么就看一下前面选的最差的负数有没有比这个差，如果比这个差就“反悔”。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

signed main()
{
    int n;
    long long sum = 0;
    int num = 0;
    scanf("%d",&amp;n);
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
    for(int i = 1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        if(x&gt;=0)
        {
            sum+=x;
            num++;
        }
        else if(sum+x&gt;=0)
        {
            sum+=x;
            num++;
            q.push(x);
        }
        else
        {
            if(q.size()&amp;&amp;q.top()&lt;x)
            {
                sum+=x-q.top();
                q.pop();
                q.push(x);
            }
        }
    }
    printf("%d",num);
    return 0;
}
</code></pre>
<h4 id="cf1185c2-exam-in-bersu-hard-version"><a href="https://www.luogu.com.cn/problem/CF1185C2" target="_blank" rel="noopener nofollow">CF1185C2 Exam in BerSU (hard version)</a></h4>
<p>还是同样的套路，如果能选就选，不能选的话我们就反悔。<br>
本题的输出在不能选的情况下得再准备一个优先队列，因为如果不能选的话，我们每次肯定得从优先队列里面取出最大的（最拖后腿的），放到这个临时的优先队列里，然后输出完后再放回去，然后在不能选的情况下输出的时候还要减 <span class="math inline">\(1\)</span>，因为你那个时候还没有将这个东西放入优先队列（你也可以先放，这样就不用减 <span class="math inline">\(1\)</span> 了）。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
signed main()
{
    priority_queue&lt;int&gt;q,tmp;
    int n,m,sum = 0;
    scanf("%d %d",&amp;n,&amp;m);
    for(int i = 1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        if(sum+x&lt;=m)
        {
            sum+=x;
            q.push(x);
            printf("%d ",i-q.size());
        }
        else
        {
            while(sum+x&gt;m)
            {
                sum-=q.top();
                tmp.push(q.top());
                q.pop();
            }
            printf("%d ",i-q.size()-1);
            while(tmp.size())
            {
                sum+=tmp.top();
                q.push(tmp.top());
                tmp.pop();
            }
            if(q.top()&gt;x)
            {
                sum-=q.top()-x;
                q.pop();
                q.push(x);
            }
        }
    }
    return 0;
}
</code></pre>
<h4 id="p2949-usaco09open-work-scheduling-g"><a href="https://www.luogu.com.cn/problem/P2949" target="_blank" rel="noopener nofollow">P2949 [USACO09OPEN] Work Scheduling G</a></h4>
<p>同样的套路。首先得给这些任务按照时间顺序排序，然后开始贪心，依旧是能选的就选，不能选的就从优先队列里找到最差的看下有没有比当前的差，如果有就放入。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 1e5+5;
struct node
{
    int d;
    int p;
}a[N];
int cmp(node x,node y)
{
    return x.d&lt;y.d;
}
signed main()
{
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
    int num = 0,sum = 0;
    int n;
    scanf("%lld",&amp;n);
    for(int i = 1;i&lt;=n;i++)
    {
        scanf("%lld %lld",&amp;a[i].d,&amp;a[i].p);
    }
    sort(a+1,a+n+1,cmp);
    for(int i = 1;i&lt;=n;i++)
    {
        if(num&lt;a[i].d)
        {
            num++;
            q.push(a[i].p);
            sum+=a[i].p;
        }
        else if(q.top()&lt;a[i].p)
        {
            sum+=a[i].p-q.top();
            q.pop();
            q.push(a[i].p);
        }
    }
    printf("%lld",sum);
    return 0;
}
</code></pre>
<h4 id="cf865d-buy-low-sell-high"><a href="https://www.luogu.com.cn/problem/CF865D" target="_blank" rel="noopener nofollow">CF865D Buy Low Sell High</a></h4>
<p>由于只有一个股票，我们不确定一个股票如果买了要到什么时候买最好，我们可以贪心地选择，如果当前的优先队列里最便宜的股票价钱比当前这个股票价钱便宜，那么就“卖掉”这个股票（这样一定是对的，因为就算到后面再卖了赚的差价更高，我们之前卖出的价钱也会放到优先队列里，我们理论上是卖了那个股票，但是其实不仅能当最终结果，也可以当中继器，所以还可以和后面的股票进行交易，答案就不会出现问题），然后不管怎样，都得往优先队列里面放当前这个股票，因为它还有机会当中继器。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main()
{
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
    int n,sum = 0;
    scanf("%lld",&amp;n);
    for(int i = 1;i&lt;=n;i++)
    {
        int x;
        scanf("%lld",&amp;x);
        if(q.size()&amp;&amp;q.top()&lt;x)
        {
            sum+=x-q.top();
            q.pop();
            q.push(x);
        }
        q.push(x);
    }
    printf("%lld",sum);
    return 0;
}
</code></pre>
<p>后面还会更新更多例题，敬请期待！！</p>
<h3 id="五什么是局部调整法">五、什么是局部调整法</h3>
<p>局部调整法就是在做选择性贪心时挑两个相邻的位置进行数学中的不等式分析，从而得出排序法则，同时，它还有一个重要的用处——判断选择性题目是否可以贪心。</p>
<h3 id="六局部调整法普遍推导过程">六、局部调整法普遍推导过程</h3>
<p>就是先定义两个相邻数 <span class="math inline">\(x,y\)</span>，然后假设其它位置的数固定，而 <span class="math inline">\(x,y\)</span> 可以互换，那么我们分别写出 <span class="math inline">\(1,2,\dots,x,y,\dots,n-1,n\)</span> 的贡献和 <span class="math inline">\(1,2,\dots,y,x,\dots,n-1,n\)</span> 的贡献，然后假设 <span class="math inline">\(1,2,\dots,x,y,\dots,n-1,n\)</span> 的贡献比 <span class="math inline">\(1,2,\dots,y,x,\dots,n-1,n\)</span> 的贡献更优，然后这就是排序法则，当然，有时候这个排序法则比较麻烦，你可以对它进行化简。那局部调整法如何用来快速判断选择性题目是否可以贪心呢？很简单，只需要判断我们化简后的不等式是否满足偏序关系，偏序关系就是你用小的连大的不会成环，<a href="https://baike.baidu.com/item/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/943166" target="_blank" rel="noopener nofollow">当然偏序关系还有纯数学的定义</a>。</p>
<h3 id="七如何快速判断一个不太好判断的不等式是否满足偏序关系">七、如何快速判断一个不太好判断的不等式是否满足偏序关系</h3>
<ul>
<li>手动造数据，然后根据这个不等式写排序方式，如果能排出来就满足偏序关系，拍不出来就说明不满足偏序关系（<s>注意，此方法较唐</s>）。</li>
<li>直接用偏序关系的三个性质验证，如果都满足就没啥问题了，如果不满足就有问题（<s>注意：此方法也比较唐</s>）。</li>
</ul>
<p>两种方法虽然都不一定保证一定正确，但是合在一起正确率肯定高于百分之九十九，而且这也是算法竞赛中很好用的方法，当然，你应用时完全不需要合在一起，随便用一种方法就行了。</p>
<h3 id="七局部调整法例题讲解">七、局部调整法例题讲解</h3>
<h4 id="p1012-noip-1998-提高组-拼数"><a href="https://www.luogu.com.cn/problem/P1012" target="_blank" rel="noopener nofollow">P1012 [NOIP 1998 提高组] 拼数</a></h4>
<p>首先先把两者的贡献写下来，组成不等式（这里 <span class="math inline">\(A\)</span> 表示 <span class="math inline">\(x\)</span> 以前的数拼在一起的结果，<span class="math inline">\(B\)</span> 表示 <span class="math inline">\(x,y\)</span> 后面的数拼在一起的结果）：</p>
<p></p><div class="math display">\[A \times 10^{|B|+|a_x|+|a_y|}+a_x \times 10^{|B|+|a_y|}+a_y \times 10^{|B|}+B&gt;A \times 10^{|B|+|a_x|+|a_y|}+a_y \times 10^{|B|+|a_x|}+a_x \times 10^{|B|}+B
\]</div><p></p><p></p><div class="math display">\[a_x \times 10^{|B|+|a_y|}+a_y \times 10^{|B|}&gt;a_y \times 10^{|B|+|a_x|}+a_x \times 10^{|B|}
\]</div><p></p><p></p><div class="math display">\[a_x \times 10^{|a_y|}+a_y&gt;a_y \times 10^{|a_x|}+a_x
\]</div><p></p><p>然后令 <span class="math inline">\(|DFG|\)</span> 表示 <span class="math inline">\(D\)</span> 和 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(G\)</span> 拼起来的结果，那么：</p>
<p></p><div class="math display">\[|a_xa_y|&gt;|a_ya_x|
\]</div><p></p><p>然后这个个排序规则排序就好了。<br>
至于 <span class="math inline">\(a_x \times 10^{|a_y|}+a_y&gt;a_y \times 10^{|a_x|}+a_x\)</span> 为啥是偏序是因为：</p>
<p></p><div class="math display">\[a_x \times 10^{|a_y|}+a_y&gt;a_y \times 10^{|a_x|}+a_x
\]</div><p></p><p></p><div class="math display">\[a_x \times 10^{|a_y|}-a_x&gt;a_y \times 10^{|a_x|}-a_y
\]</div><p></p><p></p><div class="math display">\[a_x \times (10^{|a_y|}-1)&gt;a_y \times (10^{|a_x|}-1)
\]</div><p></p><p></p><div class="math display">\[\frac{a_x}{10^{|a_x|}-1}&gt;\frac{a_y}{10^{|a_y|}-1}
\]</div><p></p><p>发现一边全是 <span class="math inline">\(x\)</span>，另一边全是 <span class="math inline">\(y\)</span>，所以一定是偏序。<br>
代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
string a[25];
string ans;
bool cmp(string a,string b)
{
	string c = a+b,d = b+a;
	return c&gt;d;
}
int main()
{
	int n;
	cin &gt;&gt; n;
	for(int i = 1;i&lt;=n;i++)
	{
		cin &gt;&gt; a[i];
	}
	sort(a+1,a+n+1,cmp);
	for(int i = 1;i&lt;=n;i++)
	{
		ans+=a[i];
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h4 id="p5963-balticoi--card-卡牌游戏来源请求"><a href="https://www.luogu.com.cn/problem/P5963" target="_blank" rel="noopener nofollow">P5963 [BalticOI ?] Card 卡牌游戏【来源请求】</a></h4>
<p>首先把两者的贡献写下来，组成不等式（假设有两组卡片 <span class="math inline">\((x_i,y_i),(x_j,y_j)\)</span>）：</p>
<p></p><div class="math display">\[-x_i+y_j&lt;-x_j+y_i
\]</div><p></p><p></p><div class="math display">\[y_j-x_i&lt;y_i-x_j
\]</div><p></p><p></p><div class="math display">\[y_j+x_j&lt;y_i+x_i
\]</div><p></p><p>这不直接就搞定了吗，而且还是一边全是 <span class="math inline">\(j\)</span>，一边全是 <span class="math inline">\(i\)</span> 的情况，所以一定是偏序。<br>
<strong>注意：十年 OI 一场空，不开 long long 见祖宗。</strong><br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 
const int N = 6e5+5;
struct node
{
    int x;
    int y;
    int sum;
}a[N];
int cmp(node x,node y)
{
    return x.sum&lt;y.sum;
}
signed main()
{
    int n;
    scanf("%lld",&amp;n);
    for(int i = 1;i&lt;=n;i++)
    {
        scanf("%lld %lld",&amp;a[i].x,&amp;a[i].y);
        a[i].sum = a[i].x+a[i].y;
    }
    sort(a+1,a+n+1,cmp);
    int ans = 0;
    for(int i = 1;i&lt;=n/2;i++)
    {
        ans+=min(a[i].x,a[i].y);
    }
    for(int i = n/2+1;i&lt;=n;i++)
    {
        ans-=max(a[i].x,a[i].y);
    }
    printf("%lld",ans);
    return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010057389112268519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-05 20:16">2025-05-05 20:16</span>&nbsp;
<a href="https://www.cnblogs.com/linjinkun">林晋堃</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18815550);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18815550', targetLink: 'https://www.cnblogs.com/linjinkun/p/18815550', title: '反悔贪心&amp;amp;局部调整法学习笔记' })">举报</a>
</div>
        