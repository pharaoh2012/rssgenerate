
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18658876" title="发布于 2025-01-13 09:11">
    <span role="heading" aria-level="2">掌握设计模式--代理模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="代理模式proxy-pattern">代理模式（Proxy Pattern）</h2>
<p>代理模式（Proxy Pattern）是一种结构型设计模式，允许你通过代理对象来控制对其他对象的访问。代理模式的主要目的是通过代理对象来控制原对象的访问、延迟加载、权限控制等。</p>
<h3 id="组成结构">组成结构</h3>
<ul>
<li><strong>Subject（主题接口）</strong>：定义了真实对象和代理对象的共同接口。</li>
<li><strong>RealSubject（真实主题类）</strong>：定义了代理类所代表的真实对象，通常实现了Subject接口。</li>
<li><strong>Proxy（代理类）</strong>：持有RealSubject的引用，并在请求传递给RealSubject之前或之后进行一些操作。</li>
</ul>
<h2 id="代理模式的分类">代理模式的分类</h2>
<ol>
<li>
<p><strong>静态代理</strong>：代理类在编译时就已经确定。代理类和被代理类通常是手动创建的，代码需要在编译时就确定好。</p>
</li>
<li>
<p><strong>动态代理</strong>：代理类在运行时动态生成，通常借助反射机制来生成代理对象。这种方式更灵活，可以通过代理类来代理多个不同的接口或类。</p>
</li>
<li>
<p><strong>虚拟代理</strong>：通过代理类控制对某个对象的访问，常用于懒加载，只有在实际需要时才初始化对象，减少资源消耗。</p>
</li>
<li>
<p><strong>保护代理</strong>：控制对对象的访问权限，通常用于权限控制等。</p>
</li>
<li>
<p><strong>远程代理</strong>：用于对象在不同地址空间的访问，例如，分布式系统中，客户端通过代理访问远程对象。</p>
</li>
</ol>
<p>由于篇幅原因，远程代理会放在另一篇文章单独举例。</p>
<p>根据代理模式的分类，以下是各类型代理的具体案例和应用：</p>
<h2 id="1-静态代理static-proxy">1. 静态代理（Static Proxy）</h2>
<p>静态代理是在<code>编译时</code>确定的，代理类和真实类都需要在编写时定义。代理类通常会实现与真实类相同的接口，并在代理类中调用真实类的方法。一个具体类对应一个代理类，通过代理类来操作具体类。</p>
<h3 id="案例静态代理的日志记录">案例：静态代理的日志记录</h3>
<p>假设我们有一个计算服务，通过代理类来记录方法执行的日志。</p>
<pre><code class="language-java">// Subject接口
public interface CalculationService {
    int add(int a, int b);
    int subtract(int a, int b);
}

// 真实类
public class CalculationServiceImpl implements CalculationService {
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
}

// 代理类
public class CalculationServiceProxy implements CalculationService {
    private CalculationServiceImpl realService;

    public CalculationServiceProxy() {
        realService = new CalculationServiceImpl();
    }

    @Override
    public int add(int a, int b) {
        System.out.println("日志: add ...");
        return realService.add(a, b);
    }

    @Override
    public int subtract(int a, int b) {
        System.out.println("日志: subtract ...");
        return realService.subtract(a, b);
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        CalculationService service = new CalculationServiceProxy();
        System.out.println("执行结果: " + service.add(10, 5));
        System.out.println("执行结果: " + service.subtract(10, 5));
    }
}
</code></pre>
<p><strong>执行结果</strong>：</p>
<blockquote>
<p>日志: add ...</p>
<p>执行结果: 15</p>
<p>日志: subtract ...</p>
<p>执行结果: 5</p>
</blockquote>
<h2 id="2-动态代理dynamic-proxy">2. 动态代理（Dynamic Proxy）</h2>
<p>动态代理是在运行时动态生成的，可以使用 JDK 动态代理（<code>Proxy.newProxyInstance()</code>）或CGLib动态代理创建一个代理对象，并在其中增强目标对象的功能。多个具体类使用一个代理类来创建代理对象。</p>
<h3 id="案例动态代理的日志记录">案例：动态代理的日志记录</h3>
<p>通过<code>java.lang.reflect.Proxy</code>和<code>InvocationHandler</code>来动态创建代理类，实现类似静态代理的功能。动态代理不需要像静态代理那样在每个业务代码方法都加入日志代码，而是统一的日志记录，并且与业务代码解耦，起到<strong>低耦合</strong>的作用，日志代码（代理类）的调整不会影响到业务代码。</p>
<h4 id="案例类图">案例类图</h4>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250108081423494-1197832239.png" alt="image" loading="lazy"></p>
<h4 id="使用jdk动态代理实现">使用JDK动态代理实现</h4>
<pre><code class="language-java">import java.lang.reflect.*;

public interface CalculationService {
    int add(int a, int b);
    int subtract(int a, int b);
}

public class CalculationServiceImpl implements CalculationService {
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
}

public class LoggingInvocationHandler implements InvocationHandler {
    private Class&lt;?&gt; targetClass;  // 目标类的 Class 对象

    public LoggingInvocationHandler(Class&lt;?&gt; targetClass) {
        this.targetClass = targetClass;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在方法调用前打印日志
        System.out.println("日志: 执行方法 " + method.getName() + " 参数为 " + args[0] + " 和 " + args[1]);

        // 使用反射创建目标对象实例
        Object target = targetClass.getDeclaredConstructor().newInstance();

        // 使用反射调用目标对象的方法
        return method.invoke(target, args);  // 调用目标类的方法并传递参数
    }
}

public class Client {
    public static void main(String[] args) {
        try {
            // 使用反射创建代理对象
            Class&lt;?&gt; targetClass = CalculationServiceImpl.class;  // 获取目标类的 Class 对象

            // 创建动态代理
            CalculationService proxy = (CalculationService) Proxy.newProxyInstance(
                    targetClass.getClassLoader(),  // 类加载器
                    targetClass.getInterfaces(),  // 接口列表
                    new LoggingInvocationHandler(targetClass)  // 传入目标类的 Class 对象
            );

            // 通过代理对象调用方法
            System.out.println("执行结果: " + proxy.add(10, 5));
            System.out.println("执行结果: " + proxy.subtract(10, 5));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>执行结果</strong></p>
<blockquote>
<p>日志: 执行方法 add 参数为 10 和 5</p>
<p>执行结果: 15</p>
<p>日志: 执行方法 subtract 参数为 10 和 5</p>
<p>执行结果: 5</p>
</blockquote>
<h3 id="使用cglib动态代理实现">使用CGLib动态代理实现</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="创建-cglib-代理类">创建 CGLIB 代理类</h3>
<pre><code class="language-java">public class CGLibProxyExample {

    // 使用 CGLIB 动态代理
    public static void main(String[] args) {
        // 创建目标对象
        CalculationServiceImpl realService = new CalculationServiceImpl();

        // 创建 CGLIB 代理对象
        CalculationServiceImpl proxyService = (CalculationServiceImpl) Enhancer.create(
                CalculationServiceImpl.class,  // 目标类
                new MethodInterceptor() {      // 方法拦截器
                    @Override
                    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                        // 方法调用前打印日志
                        System.out.println("日志: 执行方法 " + method.getName() + " 参数为 " + args[0] + " 和 " + args[1]);
                        // 调用目标方法
                        return proxy.invokeSuper(obj, args);  // 调用父类（目标类）的方法
                    }
                }
        );

        // 通过代理对象调用方法
        System.out.println("执行结果: " + proxyService.add(10, 5));
        System.out.println("执行结果: " + proxyService.subtract(10, 5));
    }
}
</code></pre>
<h2 id="3-虚拟代理virtual-proxy">3. 虚拟代理（Virtual Proxy）</h2>
<p>虚拟代理通常用于<code>对象的懒加载</code>（Lazy Initialization）。当某个对象的创建非常昂贵（如需要加载大量数据或资源），而并非每次都需要使用时，虚拟代理可以推迟对象的创建，直到<code>需要时才创建</code>。</p>
<h3 id="案例虚拟代理的懒加载">案例：虚拟代理的懒加载</h3>
<p>模拟一个大型图片的加载，只有在需要显示图片时，才加载图片数据。</p>
<pre><code class="language-java">// Subject接口
public interface Image {
    void display();
}

// 真实对象
public class RealImage implements Image {
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading image: " + fileName);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + fileName);
    }
}

// 代理类
public class ProxyImage implements Image {
    private RealImage realImage;
    private String fileName;

    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg");
        image.display();  // 第一次调用时加载图片
        image.display();  // 第二次调用时直接显示
    }
}
</code></pre>
<p><strong>执行结果</strong>：</p>
<blockquote>
<p>Loading image: test.jpg</p>
<p>Displaying image: test.jpg</p>
<p>Displaying image: test.jpg</p>
</blockquote>
<h2 id="4-保护代理protective-proxy">4. 保护代理（Protective Proxy）</h2>
<p>保护代理控制访问权限，通常用于安全控制。例如，代理对象可以检查用户权限，只有在满足条件时才允许访问真实对象。</p>
<h3 id="案例保护代理">案例：保护代理</h3>
<p>假设我们有一个银行账户服务，保护代理会在执行操作之前验证用户是否有足够的权限。</p>
<pre><code class="language-java">// 账户服务接口
public interface BankAccountService {
    void withdraw(int amount);
    void deposit(int amount);
}

// 真实对象
public class BankAccountServiceImpl implements BankAccountService {
    private int balance = 1000;

    @Override
    public void withdraw(int amount) {
        if (balance &gt;= amount) {
            balance -= amount;
            System.out.println("转出: " + amount + ", 剩余余额: " + balance);
        } else {
            System.out.println("资金不足!");
        }
    }

    @Override
    public void deposit(int amount) {
        balance += amount;
        System.out.println("转入: " + amount + ", 剩余余额: " + balance);
    }
}

// 保护代理
public class BankAccountServiceProxy implements BankAccountService {
    private BankAccountServiceImpl realService;
    private String userRole;

    public BankAccountServiceProxy(String userRole) {
        realService = new BankAccountServiceImpl();
        this.userRole = userRole;
    }

    @Override
    public void withdraw(int amount) {
        if ("admin".equals(userRole)) {
            realService.withdraw(amount);
        } else {
            System.out.println("访问被拒绝：权限不足!");
        }
    }

    @Override
    public void deposit(int amount) {
        realService.deposit(amount);
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        BankAccountService userService = new BankAccountServiceProxy("user");
        userService.withdraw(200);  // Should be denied

        BankAccountService adminService = new BankAccountServiceProxy("admin");
        adminService.withdraw(200);  // Should be allowed
    }
}
</code></pre>
<p><strong>执行结果</strong></p>
<blockquote>
<p>访问被拒绝：权限不足!</p>
<p>转出: 200, 剩余余额: 800</p>
</blockquote>
<h2 id="优缺点和应用场景">优缺点和应用场景</h2>
<p><strong>优点</strong>：</p>
<ul>
<li>提供了对真实对象的控制，可以增加额外的功能，比如访问控制、缓存、延迟加载、日志记录等等。</li>
<li>通过动态代理可以减少代码冗余，提高代码的灵活性和可扩展性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>增加了系统的复杂度，因为每个真实对象都需要有一个代理类来配合工作。</li>
<li>如果代理层次过多，可能会影响性能，尤其是动态代理在性能上会有一定的损耗。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ol>
<li>
<p><strong>延迟加载</strong>：当一个对象的创建成本非常高，且不一定每次都需要使用该对象时，可以通过代理来控制对象的创建时机，避免不必要的资源浪费。</p>
</li>
<li>
<p><strong>访问控制</strong>：通过代理类可以控制对原对象的访问权限，只有在满足特定条件下才允许访问。</p>
</li>
<li>
<p><strong>远程代理</strong>：当对象在远程服务器上时，可以通过代理类来模拟远程对象的行为。</p>
</li>
<li>
<p><strong>日志记录和性能监控</strong>：在代理类中可以加入日志记录、性能监控等功能，不需要修改真实对象的代码。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>这些不同类型的代理模式根据应用场景和需求各自发挥作用，以上只是常见的几种情况。</p>
<p>比如：Spring AOP使用了动态代理模式+自定义注解实现的切面编程；JavaRMI Java平台之间的远程方法调用 ；RPC框架实现跨平台的远程过程调用。</p>
<p>代理模式的思想不仅仅是代码的编写，比如服务器的正向代理和反向代理。代理对象同样可以起到服务访问<code>日志记录（审计）</code>；请求服务器只知道代理服务器的IP，对于目标服务器起到<code>安全保护</code>，同时可以设置IP的<code>黑白名单</code>和<code>限流</code>等；服务器网络之间的<code>解耦</code>，比如目标服务器IP地址发生变化时只需要调整代理服务器的配置即可，而无需调整客户端请求的目标地址。</p>
<p>掌握设计模式及其编程思想才能做到以不变应万变，真正做到学以致用，举一反三的效果。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250108081405529-421223450.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.21524843243518518" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 09:12">2025-01-13 09:11</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18658876" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18658876);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18658876', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18658876', title: '掌握设计模式--代理模式' })">举报</a>
</div>
        