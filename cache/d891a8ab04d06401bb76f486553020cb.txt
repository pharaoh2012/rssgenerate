
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18683913" title="发布于 2025-01-21 17:51">
    <span role="heading" aria-level="2">.NET Core 中如何构建一个弹性的 HTTP 请求机制？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="1-理解弹性-http-请求机制">1. 理解弹性 HTTP 请求机制</h3>
<h4 id="什么是弹性">什么是弹性？</h4>
<p>弹性是指系统在面对故障或异常情况时，能够保持或快速恢复到正常状态的能力。在 HTTP 请求的上下文中，弹性意味着当请求失败时，系统能够自动采取一系列措施（如重试、降级、断路等）来确保请求最终成功或优雅地处理失败。</p>
<h4 id="为什么需要弹性-http-请求机制">为什么需要弹性 HTTP 请求机制？</h4>
<p>在分布式系统中，服务间的依赖关系复杂，任何一个服务的故障都可能导致整个系统的不可用。弹性 HTTP 请求机制可以帮助我们：</p>
<ul>
<li><strong>提高系统的可用性</strong>：通过重试、断路等策略，减少因瞬态故障导致的系统不可用。</li>
<li><strong>增强用户体验</strong>：通过快速恢复和优雅降级，减少用户感知到的故障时间。</li>
<li><strong>降低运维成本</strong>：通过自动化处理故障，减少人工干预的需求。</li>
</ul>
<h4 id="弹性机制的核心原则">弹性机制的核心原则</h4>
<ul>
<li><strong>重试（Retry）</strong>：在请求失败时，自动重试一定次数。</li>
<li><strong>断路器（Circuit Breaker）</strong>：当失败率达到一定阈值时，暂时停止请求，避免雪崩效应。</li>
<li><strong>超时（Timeout）</strong>：设置请求的超时时间，避免长时间等待。</li>
<li><strong>降级（Fallback）</strong>：当请求失败时，提供备用的响应或行为。</li>
<li><strong>负载均衡（Load Balancing）</strong>：将请求分散到多个服务实例，避免单点故障。</li>
</ul>
<h3 id="2-net-core-中的-http-请求基础">2. .NET Core 中的 HTTP 请求基础</h3>
<h4 id="httpclient-的使用">HttpClient 的使用</h4>
<p>在 .NET Core 中，<code>HttpClient</code> 是用于发送 HTTP 请求和接收 HTTP 响应的主要类。以下是一个简单的 <code>HttpClient</code> 使用示例：</p>
<pre><code class="language-csharp">using System;
using System.Net.Http;
using System.Threading.Tasks;

public class HttpClientApplication
{
    public static async Task Main(string[] args)
    {
        using (HttpClient client = new HttpClient())
        {
            // 发送 GET 请求
            HttpResponseMessage response = await client.GetAsync("https://******");
            if (response.IsSuccessStatusCode)
            {
                // 读取响应内容
                string content = await response.Content.ReadAsStringAsync();
                Console.WriteLine(content);
            }
            else
            {
                // 输出错误状态码
                Console.WriteLine($"Error: {response.StatusCode}");
            }
        }
    }
}
</code></pre>
<h4 id="httpclientfactory-的引入">HttpClientFactory 的引入</h4>
<p><code>HttpClient</code> 的直接使用存在一些问题，如 DNS 更新问题和套接字耗尽问题。为了解决这些问题，.NET Core 引入了 <code>HttpClientFactory</code>，它提供了更好的 <code>HttpClient</code> 生命周期管理和配置选项。</p>
<p>在 <code>Startup.cs</code> 中配置 <code>HttpClientFactory</code>：</p>
<pre><code class="language-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // 注册 HttpClientFactory 并添加一个命名的 HttpClient
        services.AddHttpClient("ResilientClient", client =&gt;
        {
            client.BaseAddress = new Uri("https://******"); // 设置基础地址
            client.DefaultRequestHeaders.Add("Accept", "application/json"); // 设置默认请求头
        });
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // 其他中间件配置
    }
}
</code></pre>
<p>在控制器或服务中使用 <code>HttpClientFactory</code>：</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
using System.Net.Http;
using System.Threading.Tasks;

[ApiController]
[Route("[controller]")]
public class ResilientController : ControllerBase
{
    private readonly IHttpClientFactory _httpClientFactory;

    public ResilientController(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    [HttpGet]
    public async Task&lt;IActionResult&gt; Get()
    {
        // 通过名称获取 HttpClient 实例
        var client = _httpClientFactory.CreateClient("ResilientClient");

        // 发送 GET 请求
        var response = await client.GetAsync("posts/list");
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync();
            return Ok(content); // 返回成功响应
        }

        return StatusCode((int)response.StatusCode); // 返回错误状态码
    }
}
</code></pre>
<h4 id="优点">优点：</h4>
<ul>
<li><strong>生命周期管理</strong>：<code>HttpClientFactory</code> 自动管理 <code>HttpClient</code> 的生命周期，避免套接字耗尽问题。</li>
<li><strong>配置灵活</strong>：可以为不同的 API 配置不同的 <code>HttpClient</code> 实例。</li>
<li><strong>DNS 更新支持</strong>：<code>HttpClientFactory</code> 会定期刷新 DNS 缓存。</li>
</ul>
<h3 id="3-实现基本的重试机制">3. 实现基本的重试机制</h3>
<h4 id="简单的重试逻辑">简单的重试逻辑</h4>
<p>在没有使用任何库的情况下，我们可以通过简单的循环来实现重试逻辑：</p>
<pre><code class="language-csharp">public async Task&lt;string&gt; GetDataWithRetryAsync(int maxRetries = 3)
{
    int retryCount = 0;
    while (true)
    {
        try
        {
            // 发送 GET 请求
            HttpResponseMessage response = await _httpClient.GetAsync("data");
            response.EnsureSuccessStatusCode(); // 确保请求成功
            return await response.Content.ReadAsStringAsync(); // 返回响应内容
        }
        catch (HttpRequestException)
        {
            retryCount++;
            if (retryCount &gt;= maxRetries)
            {
                throw; // 超过重试次数后抛出异常
            }
        }
    }
}
</code></pre>
<h4 id="使用-polly-实现重试策略">使用 Polly 实现重试策略</h4>
<p>Polly 是一个流行的 .NET 弹性库，提供了丰富的策略来实现重试、断路、超时等功能。以下是一个使用 Polly 实现重试策略的示例：</p>
<pre><code class="language-csharp">using Polly;
using Polly.Retry;

public class RetryService
{
    private readonly HttpClient _httpClient;
    private readonly AsyncRetryPolicy&lt;HttpResponseMessage&gt; _retryPolicy;

    public RetryService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        // 配置重试策略：最多重试 3 次，每次等待 2 秒
        _retryPolicy = Policy
            .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode) // 处理失败响应
            .Or&lt;HttpRequestException&gt;() // 处理请求异常
            .WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); // 指数退避
    }

    public async Task&lt;string&gt; GetDataWithRetryAsync()
    {
        // 执行重试策略
        HttpResponseMessage response = await _retryPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync("data"));
        response.EnsureSuccessStatusCode(); // 确保请求成功
        return await response.Content.ReadAsStringAsync(); // 返回响应内容
    }
}
</code></pre>
<h4 id="重试策略的配置">重试策略的配置</h4>
<p>Polly 允许我们灵活地配置重试策略，包括重试次数、重试间隔等。以下是一个配置指数退避重试策略的示例：</p>
<pre><code class="language-csharp">_retryPolicy = Policy
    .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .Or&lt;HttpRequestException&gt;()
    .WaitAndRetryAsync(5, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
</code></pre>
<h3 id="4-处理瞬态故障">4. 处理瞬态故障</h3>
<h4 id="什么是瞬态故障">什么是瞬态故障？</h4>
<p>瞬态故障是指那些暂时性的、通常会自动恢复的故障。例如，网络抖动、服务暂时不可用等。瞬态故障的特点是它们通常是短暂的，重试后可能会成功。</p>
<h4 id="常见的瞬态故障类型">常见的瞬态故障类型</h4>
<ul>
<li><strong>网络抖动</strong>：网络连接不稳定导致的请求失败。</li>
<li><strong>服务暂时不可用</strong>：目标服务因负载过高或维护而暂时不可用。</li>
<li><strong>资源限制</strong>：目标服务因资源限制（如 CPU、内存）而暂时无法处理请求。</li>
</ul>
<h4 id="使用-polly-处理瞬态故障">使用 Polly 处理瞬态故障</h4>
<p>Polly 提供了多种策略来处理瞬态故障，包括重试、断路、超时等。以下是一个结合重试和断路策略的示例：</p>
<pre><code class="language-csharp">  // 定义重试策略，当HTTP请求失败时进行重试
  var retryPolicy = Policy
      .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
      .Or&lt;HttpRequestException&gt;()
      // 设置重试次数为3次，每次重试的间隔时间按指数递增（2^retryAttempt秒）
      .WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));

  // 定义熔断策略，当连续失败次数达到阈值时，熔断一段时间
  var circuitBreakerPolicy = Policy
      .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
      .Or&lt;HttpRequestException&gt;()
      .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)); // 设置熔断条件：连续失败5次后，熔断30秒

  // 将重试策略和熔断策略组合成一个综合策略
  var combinedPolicy = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);

  HttpResponseMessage response = await combinedPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync("data"));

</code></pre>
<h3 id="5-实现断路器模式">5. 实现断路器模式</h3>
<h4 id="断路器模式的概念">断路器模式的概念</h4>
<p>断路器模式是一种用于防止系统因依赖服务故障而崩溃的设计模式。当依赖服务的失败率达到一定阈值时，断路器会打开，停止所有请求，直到依赖服务恢复。</p>
<h4 id="使用-polly-实现熔断策略">使用 Polly 实现熔断策略</h4>
<p>Polly 提供了 <code>CircuitBreaker</code> 策略来实现熔断策略。以下是一个使用 Polly 实现熔断策略的示例：</p>
<pre><code class="language-csharp">var circuitBreakerPolicy = Policy
    .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .Or&lt;HttpRequestException&gt;()
    .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)); // 连续失败 5 次后，断路器打开 30 秒

HttpResponseMessage response = await circuitBreakerPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync("data"));
</code></pre>
<h4 id="配置熔断策略参数">配置熔断策略参数</h4>
<p>Polly 允许我们配置熔断策略的参数，包括失败次数阈值、断路时间等。以下是一个配置断路器的示例：</p>
<pre><code class="language-csharp">var circuitBreakerPolicy = Policy
    .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .Or&lt;HttpRequestException&gt;()
    .CircuitBreakerAsync(
        exceptionsAllowedBeforeBreaking: 5, // 允许的失败次数
        durationOfBreak: TimeSpan.FromSeconds(30) // 断路时间
    );
</code></pre>
<h3 id="6-超时和超时策略">6. 超时和超时策略</h3>
<h4 id="设置请求超时">设置请求超时</h4>
<p>在 <code>HttpClient</code> 中，我们可以通过 <code>Timeout</code> 属性设置请求的超时时间：</p>
<pre><code class="language-csharp">_httpClient.Timeout = TimeSpan.FromSeconds(10); // 设置超时时间为 10 秒
</code></pre>
<h4 id="使用-polly-实现超时策略">使用 Polly 实现超时策略</h4>
<p>Polly 提供了 <code>Timeout</code> 策略来实现超时控制。以下是一个使用 Polly 实现超时策略的示例：</p>
<pre><code class="language-csharp">var timeoutPolicy = Policy.TimeoutAsync&lt;HttpResponseMessage&gt;(TimeSpan.FromSeconds(10)); // 设置超时时间为 10 秒

HttpResponseMessage response = await timeoutPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync("data"));
</code></pre>
<h4 id="超时与重试的结合">超时与重试的结合</h4>
<p>我们可以将超时策略与重试策略结合使用，以应对因超时导致的请求失败：</p>
<pre><code class="language-csharp">var retryPolicy = Policy
    .HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .Or&lt;HttpRequestException&gt;()
    .WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); // 重试策略

var timeoutPolicy = Policy.TimeoutAsync&lt;HttpResponseMessage&gt;(TimeSpan.FromSeconds(10)); // 超时策略

var combinedPolicy = Policy.WrapAsync(retryPolicy, timeoutPolicy); // 组合策略

HttpResponseMessage response = await combinedPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync("data"));
</code></pre>
<h3 id="7-负载均衡与请求分流">7. 负载均衡与请求分流</h3>
<h4 id="负载均衡的基本概念">负载均衡的基本概念</h4>
<p>负载均衡是指将请求分散到多个服务实例，以避免单点故障和提高系统的可扩展性。常见的负载均衡策略包括轮询、随机、加权轮询等。</p>
<h4 id="在-net-core-中实现负载均衡">在 .NET Core 中实现负载均衡</h4>
<p>在 .NET Core 中，我们可以通过配置多个 <code>HttpClient</code> 实例来实现负载均衡。以下是一个简单的负载均衡示例：</p>
<pre><code class="language-csharp">public class LoadBalancer
{
    private readonly List&lt;HttpClient&gt; _httpClients;
    private readonly Random _random = new Random();

    public LoadBalancer(IHttpClientFactory httpClientFactory)
    {
        _httpClients = new List&lt;HttpClient&gt;
        {
            httpClientFactory.CreateClient("ServiceInstance1"), // 实例 1
            httpClientFactory.CreateClient("ServiceInstance2"), // 实例 2
            httpClientFactory.CreateClient("ServiceInstance3")  // 实例 3
        };
    }

    public async Task&lt;string&gt; GetDataAsync()
    {
        // 随机选择一个 HttpClient 实例
        HttpClient client = _httpClients[_random.Next(_httpClients.Count)];
        HttpResponseMessage response = await client.GetAsync("data");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }
}
</code></pre>
<h4 id="请求分流的策略">请求分流的策略</h4>
<p>请求分流是指根据某些条件（如请求内容、用户身份等）将请求分发到不同的服务实例。以下是一个简单的请求分流示例：</p>
<pre><code class="language-csharp">public async Task&lt;string&gt; GetDataAsync(string userId)
{
    // 根据用户 ID 选择不同的 HttpClient 实例
    HttpClient client = userId.StartsWith("A") ? _httpClients[0] : _httpClients[1];
    HttpResponseMessage response = await client.GetAsync("data");
    response.EnsureSuccessStatusCode();
    return await response.Content.ReadAsStringAsync();
}
</code></pre>
<h3 id="8-监控与日志记录">8. 监控与日志记录</h3>
<h4 id="监控-http-请求的重要性">监控 HTTP 请求的重要性</h4>
<p>监控 HTTP 请求可以帮助我们及时发现和解决问题，确保系统的稳定性和可靠性。常见的监控指标包括请求成功率、响应时间、错误率等。</p>
<h4 id="使用-application-insights-进行监控">使用 Application Insights 进行监控</h4>
<p>Application Insights 是 Azure 提供的一个应用性能管理服务，可以帮助我们监控和分析 HTTP 请求。以下是一个使用 Application Insights 监控 HTTP 请求的示例：</p>
<pre><code class="language-csharp">public class HttpRemoteService
{
    private readonly HttpClient _httpClient;
    private readonly TelemetryClient _telemetryClient;

    public HttpRemoteService(HttpClient httpClient, TelemetryClient telemetryClient)
    {
        _httpClient = httpClient;
        _telemetryClient = telemetryClient;
    }

    public async Task&lt;string&gt; GetDataAsync()
    {
        var startTime = DateTime.UtcNow;
        var timer = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync("data");
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadAsStringAsync();
        }
        catch (Exception ex)
        {
            _telemetryClient.TrackException(ex); // 记录异常
            throw;
        }
        finally
        {
            timer.Stop();
            _telemetryClient.TrackDependency("HTTP", "GET", "data", startTime, timer.Elapsed, true); // 记录依赖调用
        }
    }
}
</code></pre>
<h4 id="日志记录的最佳实践">日志记录的最佳实践</h4>
<p>日志记录是监控和调试的重要工具。以下是一些日志记录的最佳实践：</p>
<ul>
<li><strong>记录关键信息</strong>：如请求 URL、响应状态码、响应时间等。</li>
<li><strong>使用结构化日志</strong>：便于日志的查询和分析。</li>
<li><strong>避免记录敏感信息</strong>：如密码、令牌等。</li>
</ul>
<pre><code class="language-csharp">public async Task&lt;string&gt; GetDataAsync()
{
    _logger.LogInformation("正在发送 HTTP GET 请求到 {Url}", "https://api.*****.com/data");

    try
    {
        HttpResponseMessage response = await _httpClient.GetAsync("data");
        response.EnsureSuccessStatusCode();
        string content = await response.Content.ReadAsStringAsync();
        _logger.LogInformation("请求成功，响应状态码: {StatusCode}", response.StatusCode);
        return content;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "请求失败: {Message}", ex.Message);
        throw;
    }
}
</code></pre>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener nofollow"><strong>Polly 官方文档</strong></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/core/" target="_blank" rel="noopener nofollow"><strong>.NET Core 官方文档</strong></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/azure/azure-monitor/app/app-insights-overview" target="_blank" rel="noopener nofollow"><strong>Application Insights 官方文档</strong></a></li>
</ul>
<h3 id="结语">结语</h3>
<p>在 .NET Core 中构建一个弹性的 HTTP 请求机制是一个复杂但值得的任务。希望本文能够帮助你在 .NET Core 中构建一个健壮的 HTTP 请求机制。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250121173244361-1429266657.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="12.936331774237269" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-21 17:51">2025-01-21 17:51</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">614</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18683913" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18683913);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18683913', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18683913', title: '.NET Core 中如何构建一个弹性的 HTTP 请求机制？' })">举报</a>
</div>
        