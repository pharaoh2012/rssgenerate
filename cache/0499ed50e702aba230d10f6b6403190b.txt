
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CUC-MenG/p/19052820" title="发布于 2025-08-22 15:05">
    <span role="heading" aria-level="2">2025杭电多校第十场 Cut Check Bit、Multiple and Factor 个人题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="multiple-and-factor"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1181&amp;pid=1002" target="_blank" rel="noopener nofollow">Multiple and Factor</a></h1>
<h1 id="根号分治-数学">根号分治 #数学</h1>
<h2 id="题目">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250822150315358-95853377.png" alt="image" loading="lazy"></p>
<h2 id="思路">思路</h2>
<p>本题采用<strong>根号分治</strong>的思想，令<span class="math inline">\(B=\sqrt{ n }\)</span>，将下标分为<span class="math inline">\(1\leq i\leq B\)</span>与<span class="math inline">\(B&lt;i\leq n\)</span>两类数进行维护</p>
<p>数组<span class="math inline">\(a[N]\)</span>用于储存初始权值</p>
<p>操作一：令<span class="math inline">\(x\)</span>的所有倍数位置<span class="math inline">\(+k\)</span></p>
<ul>
<li>若<span class="math inline">\(x\leq B\)</span>：
<ul>
<li>创建数组<span class="math inline">\(add[B]\)</span>，作为小数倍数和的加法懒标记</li>
<li>直接 <span class="math inline">\(add[x]+=k\)</span>即可</li>
<li>时间复杂度<span class="math inline">\(o(1)\)</span></li>
</ul>
</li>
<li>若<span class="math inline">\(x&gt;B\)</span>：
<ul>
<li>可知此时的<span class="math inline">\(x\)</span>的倍数个数不会超过<span class="math inline">\(B\)</span>个，因此可以暴力解决</li>
<li>枚举<span class="math inline">\(x\)</span>的所有倍数<span class="math inline">\(tx\)</span>，<span class="math inline">\(a[tx]+=k\)</span></li>
<li>时间复杂度<span class="math inline">\(o(B)\)</span></li>
</ul>
</li>
</ul>
<p>操作二：令<span class="math inline">\(x\)</span>的所有因数位置<span class="math inline">\(+k\)</span></p>
<ul>
<li>直接枚举<span class="math inline">\(x\)</span>的所有因数<span class="math inline">\(d\)</span></li>
<li><span class="math inline">\(a[d]+=k\ [\ d\ |\ x\ ]\)</span></li>
<li>时间复杂度<span class="math inline">\(o(\sqrt{ n })\)</span></li>
</ul>
<p>操作三：查询<span class="math inline">\(x\)</span>的所有倍数位置的权值和</p>
<ul>
<li>若<span class="math inline">\(x&gt;B\)</span>：
<ul>
<li>先暴力枚举<span class="math inline">\(x\)</span>的所有倍数<span class="math inline">\(tx\)</span>，<span class="math inline">\(ans+=a[tx]\)</span></li>
<li>接下来需要处理<span class="math inline">\(1\leq i\leq B\)</span>部分的加法懒标记：
<ul>
<li>设集合<span class="math inline">\(S_{i}=\{ j\ |\ j=t\times i\ ,\ j\leq n\ ,\ t\geq 1 \}\)</span>，表示所有小于<span class="math inline">\(n\)</span>的<span class="math inline">\(i\)</span>的倍数集合</li>
<li>可知<span class="math inline">\(S_{i}\cap S_{x}=S_{lcm(x,i)}\)</span></li>
<li><span class="math inline">\(add[i]\)</span>对答案的贡献即<span class="math inline">\(add[i]\times S_{lcm(x,i)}.size\)</span></li>
<li>而<span class="math inline">\(S_{j}.size=\left\lfloor  \frac{n}{j}  \right\rfloor\)</span></li>
<li>因此<span class="math inline">\(ans+=add[i]\times \left\lfloor  \frac{n}{lcm(x,i)}  \right\rfloor\)</span></li>
</ul>
</li>
<li>时间复杂度<span class="math inline">\(o(B+B\log n)\)</span>，<span class="math inline">\(\log n\)</span>来自<span class="math inline">\(lcm(x,i)\)</span></li>
</ul>
</li>
<li>若<span class="math inline">\(x\leq B\)</span>：
<ul>
<li>这些数不好用懒标记维护，所以直接每次修改都暴力维护</li>
<li>创建数组<span class="math inline">\(addmul[B]\)</span>，用于直接储存操作三小数询问的答案</li>
<li>进行操作一时：(令<span class="math inline">\(x\)</span>的所有倍数位置<span class="math inline">\(+k\)</span>)
<ul>
<li>考虑直接更新<span class="math inline">\(1\leq i\leq B\)</span>的<span class="math inline">\(addmul[i]\)</span></li>
<li>同样考虑<span class="math inline">\(S_{i}\)</span>与<span class="math inline">\(S_{x}\)</span>两个集合，可得<span class="math inline">\(addmul[i]+=k\times\left\lfloor  \frac{n}{lcm(x,i)}  \right\rfloor\)</span></li>
<li>时间复杂度<span class="math inline">\(o(B\log n)\)</span></li>
</ul>
</li>
<li>进行操作二时：(令<span class="math inline">\(x\)</span>的所有因数位置<span class="math inline">\(+k\)</span>)
<ul>
<li>考虑直接更新<span class="math inline">\(1\leq i\leq B\)</span>的<span class="math inline">\(addmul[i]\)</span></li>
<li>首先<span class="math inline">\(i\)</span>必须是<span class="math inline">\(x\)</span>的因数才会被更新到，即<span class="math inline">\(i\ |\ x\)</span></li>
<li>设<span class="math inline">\(t\times i=x\)</span>，若<span class="math inline">\(d\ |\ t\)</span>，则<span class="math inline">\((d\times i)\ |\ x\)</span>，因此<span class="math inline">\(d\)</span>的数量即为又是<span class="math inline">\(i\)</span>的倍数又是<span class="math inline">\(x\)</span>的因数的个数</li>
<li>创建数组<span class="math inline">\(d[B]\)</span>，<span class="math inline">\(d[i]\)</span>表示数字<span class="math inline">\(i\)</span>的因数个数，求<span class="math inline">\(d\ |\ t\)</span>的个数即<span class="math inline">\(d[t]=d\left[ \frac{x}{i} \right]\)</span></li>
<li>因此<span class="math inline">\(addmul[i]+=k\times d\left[ \frac{x}{i} \right]\)</span></li>
<li>时间复杂度<span class="math inline">\(o(B)\)</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作四：查询<span class="math inline">\(x\)</span>的所有因数位置的权值和</p>
<ul>
<li>先暴力枚举<span class="math inline">\(x\)</span>的所有因数<span class="math inline">\(d\)</span>，<span class="math inline">\(ans+=a[d]\)</span></li>
<li>接下来处理小数部分的加法懒标记：
<ul>
<li>对于<span class="math inline">\(1\leq i\leq B\)</span>且<span class="math inline">\(i\ |\ x\)</span>，同样也是考虑“又是<span class="math inline">\(i\)</span>的倍数又是<span class="math inline">\(x\)</span>的因数的个数”</li>
<li>因此<span class="math inline">\(ans+=d\left[ \frac{x}{i} \right]\times add[i]\)</span></li>
</ul>
</li>
<li>时间复杂度<span class="math inline">\(o(\sqrt{ n }+B)\)</span></li>
</ul>
<p>对于数组<span class="math inline">\(d[B]\)</span>，可以通过类似欧拉筛的方法预处理：</p>
<ul>
<li>枚举<span class="math inline">\(1\leq i\leq n\)</span>，对于每个<span class="math inline">\(i\)</span>再枚举<span class="math inline">\(k\times i\leq n\)</span>，<span class="math inline">\(d[k\times i]++\)</span></li>
<li>对于每个确定的<span class="math inline">\(i\)</span>，将会枚举<span class="math inline">\(\left\lfloor  \frac{n}{i}  \right\rfloor\)</span>个<span class="math inline">\(k\)</span>，因此总枚举次数为<span class="math inline">\(\sum_{i=1}^n\left\lfloor  \frac{n}{i}  \right\rfloor\)</span></li>
<li>复杂度为<span class="math inline">\(o\left( \sum_{i=1}^n\left\lfloor  \frac{n}{i}  \right\rfloor \right)=o\left( \sum_{i=1}^n \frac{n}{i} \right)=o\left( n·\sum_{i=1}^n \frac{1}{i} \right)\)</span>，由<span class="math inline">\(\sum_{n=1}^x \frac{1}{n}\leq 1+\ln x\)</span>可知，复杂度为<span class="math inline">\(o(n\log n)\)</span>（文末证明）</li>
</ul>
<p>至此，由于<span class="math inline">\(B=\sqrt{ n }\)</span>，总复杂度来到<span class="math inline">\(o(n\log n+m·\sqrt{ n }·\log n)\)</span>，但由于<span class="math inline">\(\sqrt{ n }·\log n\)</span>的原因，会<span class="math inline">\(TLE\)</span></p>
<p>因此考虑预处理<span class="math inline">\(gcd(a,b)\)</span>从而将<span class="math inline">\(\log n\)</span>消去：</p>
<ul>
<li>因为调用时<span class="math inline">\(lcm(x,i)\)</span>中<span class="math inline">\(1\leq i\leq B\)</span>，而对于<span class="math inline">\(x&gt;B\)</span>，辗转相除一次之后也将变为<span class="math inline">\(x\leq B\)</span> ，因此仅预处理所有<span class="math inline">\(1\leq a,b\leq B\)</span>的<span class="math inline">\(gcd(a,b)\)</span></li>
<li>枚举所有<span class="math inline">\(1\leq i&lt;j\leq B\)</span>，复杂度为<span class="math inline">\(o(B^2)=o(n)\)</span></li>
</ul>
<p>预处理后复杂度为<span class="math inline">\(n\log n+m·\sqrt{ n }\)</span> 可以通过！</p>
<h2 id="代码实现">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
#define int ll
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';

const int N = 5e5 + 5, M = 710;
int n, m, a[N], gcd[M][M], B, add[M], d[N], ansmul[M];

constexpr void init() {
    rep(i, 1, B) {
        rep(j, i + 1, B) {
            gcd[i][j] = __gcd(i, j);
        }
    }
    rep(i, 1, n) {
        for (int j = i;j &lt;= n;j += i)d[j]++;
    }
}

constexpr int g(int x, int y) {
    if (x == y)return x;
    if (x &gt; y)swap(x, y);
    if (x &lt;= M - 1 &amp;&amp; y &lt;= M - 1 &amp;&amp; gcd[x][y])return gcd[x][y];
    return __gcd(x, y);
}

constexpr int lcm(int x, int y) {
    return x * y / g(x, y);
}

void eachT() {
    cin &gt;&gt; n &gt;&gt; m;
    B = sqrt(n);
    init();
    rep(i, 1, n) cin &gt;&gt; a[i];
    rep(i, 1, B) {
        for (int j = i;j &lt;= n;j += i)ansmul[i] += a[j];
    }
    while (m--) {
        int op;cin &gt;&gt; op;
        if (op == 1) {
            int x, k;cin &gt;&gt; x &gt;&gt; k;
            if (x &lt;= B)add[x] += k;
            else {
                for (int i = x;i &lt;= n;i += x) a[i] += k;
            }
            rep(i, 1, B)ansmul[i] += n / lcm(x, i) * k;
        } else if (op == 2) {
            int x, k;cin &gt;&gt; x &gt;&gt; k;
            for (int i = 1;i * i &lt;= x;i++) {
                if (x % i != 0)continue;
                a[i] += k;
                if (i * i != x)a[x / i] += k;
            }
            rep(i, 1, B)if (x % i == 0)ansmul[i] += d[x / i] * k;
        } else if (op == 3) {
            int x;cin &gt;&gt; x;
            int ans = 0;
            if (x &lt;= B) {
                ans = ansmul[x];
            } else {
                for (int i = 1;i * x &lt;= n;i++)ans += a[i * x];
                rep(i, 1, B)ans += n / lcm(x, i) * add[i];
            }
            cout &lt;&lt; ans &lt;&lt; '\n';
        } else {
            int x;cin &gt;&gt; x;
            int ans = 0;
            for (int i = 1;i * i &lt;= x;i++) {
                if (x % i != 0)continue;
                ans += a[i];
                if (i * i != x)ans += a[x / i];
            }
            rep(i, 1, B) {
                if (x % i != 0)continue;
                ans += add[i] * d[x / i];
            }
            cout &lt;&lt; ans &lt;&lt; '\n';
        }
    }
}

signed main() {
    // cout &lt;&lt; sqrt(5e5) &lt;&lt; '\n';
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    //cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}
</code></pre>
<h2 id="关于调和级数复杂度的证明">关于调和级数复杂度的证明</h2>
<p></p><div class="math display">\[\sum_{n=1}^x \frac{1}{n}\leq 1+\ln x
\]</div><p></p><p>对于这个级数，我们可以通过<strong>拉格朗日中值定理</strong>来证明其上界为<span class="math inline">\(o(\log x)\)</span>级别：</p>
<p></p><div class="math display">\[\begin{align}
&amp;设b&lt;a,由拉格朗日中值定理:\\ \\
&amp;\exists \ \delta\in[b,a]\ 使得 \frac{f(a)-f(b)}{a-b}=f'(\delta)\\ \\
&amp;令 f(x)=\ln x,则f'(x)=\frac{1}{x}\\ \\
&amp;b\leq \delta\leq a,则 \frac{1}{\delta} \geq \frac{1}{a}\\ \\
&amp;令a=n,b=n-1,则: \\ \\
&amp;\ln \frac{n}{n-1}= \frac{\ln n-\ln (n-1)}{n-(n-1)}=\frac{1}{\delta}\geq \frac{1}{n}\\ \\
&amp;\sum_{n=2}^x\ln \frac{n}{n-1}\geq \sum_{n=2}^x \frac{1}{n}\\ \\
&amp;而\sum_{n=2}^ x \ln \frac{n}{n-1}=\ln \left( \prod_{n=2}^x \frac{n}{n-1} \right)=\ln x\\ \\
&amp;\therefore \sum_{n=1}^x \frac{1}{n} =1+\sum_{n=2}^x \frac{1}{n}\leq 1+\ln x
\end{align}
\]</div><p></p><hr>
<h1 id="cut-check-bit"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1181&amp;pid=1010" target="_blank" rel="noopener nofollow">Cut Check Bit</a></h1>
<h1 id="位运算-数学-dp-数位dp">位运算 #数学 #dp #数位dp</h1>
<h2 id="题目-1">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250822150334636-1368102124.png" alt="image" loading="lazy"></p>
<h2 id="思路-1">思路</h2>
<p><s>不是很懂为什么官方题解这么简短，莫非出题人是CCB领域大神？！</s></p>
<p>关于<span class="math inline">\(2^k\)</span>进制数的特点：</p>
<p>这样的进制数实际上都可以在化为二进制后直接拼接在一起！<br>
比如<span class="math inline">\(32=2^{5}\)</span>进制的数<span class="math inline">\(x_{3}x_{2}x_{1}x_{0}(32)=x_{3}\times 32^{3}+x_{2}\times 32^{2}+x_{1}\times 32+x_{0}(10)\)</span><br>
而一个数乘以<span class="math inline">\(2^{k}\)</span>就相当于其二进制表示左移<span class="math inline">\(k\)</span>位，因此直接将<span class="math inline">\(x_{3}x_{2}x_{1}x_{0}\)</span>所对应的二进制数由高位到低位直接拼接起来即可得到其二进制表示！</p>
<p>题干需要将各个段中的数字相与后再相或，并且还需要小于<span class="math inline">\(x\)</span>，那么相或后的结果<span class="math inline">\(t\)</span>就需要满足<span class="math inline">\(t\ |\ x=x\)</span>，即<span class="math inline">\(x\)</span>为0的位置上<span class="math inline">\(t\)</span>必须为0，<span class="math inline">\(x\)</span>为1的位置上<span class="math inline">\(t\)</span>没有限制</p>
<p>由于相与的性质，对于一个确定的分段，只要有一个数字在<span class="math inline">\(pos\)</span>位上是0，那么相与出来的数在<span class="math inline">\(pos\)</span>位上必然也是0，这就可以作为我们调控<span class="math inline">\(t\leq x\)</span>的限制<br>
若<span class="math inline">\(t\leq x\)</span>，则在<span class="math inline">\(x\)</span>为0的位置上，<span class="math inline">\(t\)</span>必须也为0；在<span class="math inline">\(x\)</span>为1的位置上，<span class="math inline">\(t\)</span>可以为0也可以为1</p>
<p>一个数位dp的技巧：<br>
<span class="math inline">\(t\leq x\)</span>等价于<span class="math inline">\(t&lt;x+1\)</span></p>
<p>为什么要这样做？</p>
<ul>
<li>在<span class="math inline">\(t\leq x\)</span>的限制下，除了<span class="math inline">\(t&lt;x\)</span>时可以自由选择，需要额外考虑<span class="math inline">\(t=x\)</span>时的“紧贴上界”情况</li>
<li>而在<span class="math inline">\(t&lt;x+1\)</span>的限制下，仅需要保证<span class="math inline">\(t\)</span>严格小于<span class="math inline">\(x+1\)</span>的情况，不存在“紧贴上界”一说</li>
<li>在<span class="math inline">\(t&lt;x+1\)</span>的限制下，更新时可以一直限制<span class="math inline">\(t\)</span>当前位为0（后文解释）</li>
</ul>
<p>创建四个数组用于<strong>数位dp</strong>：</p>
<ul>
<li><span class="math inline">\(1\leq i\leq n\)</span></li>
<li><span class="math inline">\(pre[i]\)</span>表示在处理第<span class="math inline">\(pos\)</span>位时，<span class="math inline">\(1\sim i-1\)</span>中距离<span class="math inline">\(i\)</span>最近的<span class="math inline">\(0\)</span>的位置，即<span class="math inline">\((a[\ pre[i]\ ]\gg pos)\&amp;1=0\)</span>；换一种说法，<span class="math inline">\(pre[i]\)</span>表示仅考虑第<span class="math inline">\(pos\)</span>位的情况下，以<span class="math inline">\(i\)</span>位置作为一个段的结尾，这个段的最优左端点在<span class="math inline">\(pre[i]\)</span>处</li>
<li><span class="math inline">\(l[i]\)</span>表示考虑<span class="math inline">\(1\sim pos\)</span>位上的限制，处理第<span class="math inline">\(pos\)</span>位时，以<span class="math inline">\(i\)</span>位置作为一个段的结尾，这个段的最优左端点在<span class="math inline">\(r[i]\)</span>处</li>
<li><span class="math inline">\(dp[i]\)</span>表示考虑<span class="math inline">\(1\sim pos\)</span>位上的限制，处理第位时，<span class="math inline">\(1\sim i\)</span>的最大分段数</li>
<li><span class="math inline">\(max[i]\)</span>表示在处理第<span class="math inline">\(pos\)</span>位时，<span class="math inline">\(1\sim i\)</span>中的最大<span class="math inline">\(dp\)</span>值</li>
</ul>
<p>接下来需要理解一些<strong>过程</strong>：</p>
<ul>
<li>设<span class="math inline">\(xbit\)</span>为<span class="math inline">\(x+1\)</span>在第<span class="math inline">\(pos\)</span>位上的数字，<span class="math inline">\(tbit\)</span>为段与段的<span class="math inline">\(OR\)</span>和：<span class="math inline">\(t\)</span>  在第<span class="math inline">\(pos\)</span>位上的数字</li>
<li>不管<span class="math inline">\(xbit\)</span>是什么，都先更新<span class="math inline">\(pre\)</span>数组</li>
<li>若<span class="math inline">\(xbit=0\)</span>，则必须有<span class="math inline">\(tbit=0\)</span>，此时用<span class="math inline">\(pre\)</span>数组更新<span class="math inline">\(l\)</span>数组的限制，但不更新<span class="math inline">\(dp\)</span>数组</li>
<li>若<span class="math inline">\(xbit=1\)</span>，则必须有<span class="math inline">\(tbit=0\)</span>（看似与<span class="math inline">\(t=0 /1\)</span>矛盾），此时<span class="math inline">\(dp\)</span>数组由<span class="math inline">\(pre,l\)</span>两个数组共同限制来更新，同时更新全局答案<span class="math inline">\(ans\)</span>，但<span class="math inline">\(l\)</span>数组不更新</li>
</ul>
<p>举一个<strong>例子</strong>来辅助理解：<br>
<em>以下数字均采用二进制，左端为高位右端为低位</em></p>
<ul>
<li>设<span class="math inline">\(x+1=10010\)</span></li>
<li>由于高位对数字大小的影响更大，所以从高位向低位遍历</li>
<li><span class="math inline">\(pos=5\)</span>时，<span class="math inline">\(xbit=1\)</span>：
<ul>
<li>理论上<span class="math inline">\(tbit=0 /1\)</span>，但是由于比较的是<span class="math inline">\(x+1\)</span>，<span class="math inline">\(t\)</span>需要严格小于<span class="math inline">\(x+1\)</span>，所以<span class="math inline">\(t=0\)</span>，否则<span class="math inline">\(t=x=1\)</span>相等了</li>
<li>通过限制<span class="math inline">\(tbit=0\)</span>，可以更新<span class="math inline">\(dp\)</span>数组得到一次答案</li>
</ul>
</li>
<li><span class="math inline">\(pos=4、3\)</span>时，<span class="math inline">\(xbit=0\)</span>：
<ul>
<li>必须有<span class="math inline">\(tbit=0\)</span></li>
<li>通过<span class="math inline">\(pre\)</span>来更新<span class="math inline">\(l\)</span>数组的限制</li>
<li>此时不能更新<span class="math inline">\(dp\)</span>，因为<span class="math inline">\(x\)</span>与<span class="math inline">\(t\)</span>在这一位的值都是0，那么便有相等的风险！以<span class="math inline">\(pos=3\)</span>为例，<span class="math inline">\(x:100\ ,\ t_{1}:100\ ,t_{2}:000\)</span>，此时更新<span class="math inline">\(dp\)</span>将把<span class="math inline">\(t_{1}\)</span>的答案算进去，因此错误</li>
</ul>
</li>
<li><span class="math inline">\(pos=2\)</span>时，<span class="math inline">\(xbit=1\)</span>：
<ul>
<li>若<span class="math inline">\(tbit=1\)</span>，则会出现<span class="math inline">\(x:1001\ ,\ t_{1}:1000,t_{2}:1001,t_{3}:0001,t_{4}:0000\)</span>四种情况，其中<span class="math inline">\(t_{2}=x\)</span>非法，再一次验证<span class="math inline">\(tbit=0\)</span>的正确性</li>
<li>但若限制了<span class="math inline">\(tbit=0\)</span>，<span class="math inline">\(t_{3}:0001\)</span>的情况不会漏掉吗？这也是合法的情况呀？</li>
<li>不会漏掉，因为本次不更新<span class="math inline">\(l\)</span>数组，<span class="math inline">\(tbit=0\)</span>的限制不会影响到后续的<span class="math inline">\(pos\)</span></li>
<li>正如<span class="math inline">\(pos=5\)</span>时限制了<span class="math inline">\(tbit=0\)</span>，但是没有更新进<span class="math inline">\(l\)</span>数组里，所以现在<span class="math inline">\(pos=2\)</span>时，<span class="math inline">\(t\)</span>中<span class="math inline">\(pos=5\)</span>的位置就是<span class="math inline">\(0 /1\)</span></li>
</ul>
</li>
</ul>
<p><strong>伪代码：</strong></p>
<p>从高位向低位遍历<span class="math inline">\(pos\)</span>：<br>
<em>为了方便，将<span class="math inline">\(a_{i}\)</span>在<span class="math inline">\(pos\)</span>位上的值统称为<span class="math inline">\(i\)</span>的值</em></p>
<ul>
<li>预处理<span class="math inline">\(pre[i]\)</span>：
<ul>
<li>遍历<span class="math inline">\(1\leq i\leq n\)</span></li>
<li>若<span class="math inline">\(i\)</span>的值为0，那么为了使得分段数尽可能多，则段长要尽可能小，因此最优左端点要尽可能靠近右端点，等于右端点是最优的，<span class="math inline">\(pre[i]=i\)</span></li>
<li>若<span class="math inline">\(i\)</span>的值为1，那么只能从<span class="math inline">\(pre[i-1]\)</span>转移过来，<span class="math inline">\(pre[i]=pre[i-1]\)</span></li>
</ul>
</li>
<li>若<span class="math inline">\(xbit=0\)</span>：
<ul>
<li>遍历<span class="math inline">\(1\leq i\leq n\)</span></li>
<li>用<span class="math inline">\(l\)</span>数组加入<span class="math inline">\(pre\)</span>的限制：<span class="math inline">\(l[i]=min\{ l[i],pre[i] \}\)</span></li>
</ul>
</li>
<li>若<span class="math inline">\(xbit=1\)</span>：
<ul>
<li>遍历<span class="math inline">\(1\leq i\leq n\)</span></li>
<li><span class="math inline">\(cur=min\{ l[i],pre[i] \}\)</span>，代表最优左端点位置</li>
<li>若<span class="math inline">\(cur=0\)</span>，说明在当前限制条件下无法分段，<span class="math inline">\(dp[i]=-1\)</span></li>
<li>否则<span class="math inline">\(dp\)</span>由<span class="math inline">\(cur-1\)</span>的状态转移而来：<span class="math inline">\(dp[i]=dp[\ max[cur-1]\ ]+1\)</span></li>
<li><span class="math inline">\(max[i]=max\{ max[i-1],dp[i] \}\)</span></li>
<li><span class="math inline">\(ans=max\{ ans,dp[n] \}\)</span></li>
</ul>
</li>
</ul>
<p>最后还需要特判<span class="math inline">\(x\)</span>二进制为全1的情况，因为此时<span class="math inline">\(x+1\)</span>只有最高位为1，其他都为0，而这个最高位有可能超出<span class="math inline">\(m\)</span>的限制导致<span class="math inline">\(dp\)</span>过程认为<span class="math inline">\(x+1=00\dots0 0\)</span>出错<br>
因此在<span class="math inline">\(x\)</span>为全1的时候直接输出<span class="math inline">\(n\)</span>即可~</p>
<h2 id="代码实现-1">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
// #define int ll
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';


int n, m;
const int inf = 2e14;
bool readx(vector&lt;int&gt;&amp; x) {
    string s;cin &gt;&gt; s;
    int cnt = 0;
    rep(j, 1, m) {
        char c = s[m - j];
        if (c &gt;= 'a')x[j] = c - 'a' + 10;
        else x[j] = c - '0';
        cnt += __builtin_popcount(x[j]);
    }
    if (cnt == 5 * m)return 1;
    int add = 1;
    rep(i, 1, m) {
        x[i] += add;
        add = x[i] / 32;
        x[i] %= 32;
    }
    return 0;
}

void read(vector&lt;vector&lt;int&gt;&gt;&amp; a, int i) {
    string s;cin &gt;&gt; s;
    rep(j, 1, m) {
        char c = s[m - j];
        if (c &gt;= 'a')a[i][j] = c - 'a' + 10;
        else a[i][j] = c - '0';
    }
}

void chmax(int&amp; x, int y) {
    x = max(x, y);
}
void chmin(int&amp; x, int y) {
    x = min(x, y);
}

void see2(int x) {
    vector&lt;int&gt;res(5,0);
    int pos = 0;
    while (x) {
        res[pos++] = (x &amp; 1);
        x &gt;&gt;= 1;
    }
    per(i, 5 - 1, 0)cout &lt;&lt; res[i];
}

void eachT() {
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt;a(n + 1, vector&lt;int&gt;(m + 1, 0));
    vector&lt;int&gt;x(m + 1);
    bool flag=readx(x);
    rep(i, 1, n)read(a, i);
    if (flag) { cout &lt;&lt; n &lt;&lt; '\n'; return; }
    vector&lt;int&gt;l(n + 1), pre(n + 1, 0), dp(n + 1, 0), ma(n + 1, 0);
    rep(i, 1, n)l[i] = i;
    int ans = -1;
    per(p, m, 1) {
        per(pos, 4, 0) {
            rep(j, 1, n) {
                bool bit = (a[j][p] &gt;&gt; pos) &amp; 1;
                pre[j] = bit ? pre[j-1] : j;
            }
            bool xbit = (x[p] &gt;&gt; pos) &amp; 1;
            if (xbit) {
                rep(j, 1, n) {
                    int cur = min(l[j], pre[j]);
                    dp[j] = cur ? ma[cur - 1] + 1 : -1;
                    ma[j] = max(ma[j - 1], dp[j]);
                }
                chmax(ans, dp[n]);
            } else {
                rep(j, 1, n)chmin(l[j], pre[j]);
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-22 15:06">2025-08-22 15:05</span>&nbsp;
<a href="https://www.cnblogs.com/CUC-MenG">CUC-MenG</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19052820);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19052820', targetLink: 'https://www.cnblogs.com/CUC-MenG/p/19052820', title: '2025杭电多校第十场 Cut Check Bit、Multiple and Factor 个人题解' })">举报</a>
</div>
        