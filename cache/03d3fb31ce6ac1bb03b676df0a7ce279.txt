
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lintianchen/p/18679648" title="发布于 2025-01-19 16:07">
    <span role="heading" aria-level="2">AGC018</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="agc018">AGC018</h1>
<h2 id="b">B</h2>
<h3 id="题目大意">题目大意</h3>
<p>举办一场运动会，有 <span class="math inline">\(N\)</span> 人，<span class="math inline">\(M\)</span> 个项目，每个人所有项目都有一个排名，会选择参加排名最高且开设的项目，现在要开设若干项目使得人数最多的项目人数尽可能小，求这个最小值。</p>
<h3 id="解题思路">解题思路</h3>
<p>考虑<strong>贪心</strong>。</p>
<p>一开始，我们不妨开设所有项目，设人数最多的项目为 <span class="math inline">\(x\)</span>。</p>
<p>如果我们不关闭项目 <span class="math inline">\(x\)</span>，最大值就不会变，因此我们考虑关闭项目 <span class="math inline">\(x\)</span>，将原来参加 <span class="math inline">\(x\)</span> 的人分配到他们排名次高的项目（可以用 <code>vector</code> 存储参加这个项目的人）。</p>
<p>于是，又会有新的人数最多的项目，我们重复这个过程，直到只剩下一个项目，期间最大值的最小值即为答案。</p>
<p>注意：在重新分配项目时，不仅要根据次高排名，还要判断这个项目现在是否开设，不开设还要再往后。</p>
<p>时间复杂度：<span class="math inline">\(O(nm)\)</span></p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define endl "\n"
using namespace std;

const int N = 310;

int n, m, ans;
int a[N][N], b[N][N], sz[N];
vector&lt;int&gt; e[N];
bool vis[N];

inline void add(int u, int v)
{
	e[u].push_back(v);
	sz[u]++;
}

int main()
{
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; i++)
	{
		for (int j = 1; j &lt;= m; j++)
		{
			cin &gt;&gt; a[i][j];
			b[i][a[i][j]] = j;
			if (j == 1)
			{
				add(a[i][j], i);
			}
		}
	}
	for (int i = 1; i &lt;= m; i++)
	{
		if (!vis[i])
		{
			ans = max(sz[i], ans);
		}
	}
	for (int i = 1; i &lt; m; i++)
	{
		int x = 0, mx = 0;
		for (int i = 1; i &lt;= m; i++)
		{
			if (!vis[i])
			{
				if (sz[i] &gt; mx)
				{
					mx = sz[i];
					x = i;
				}
			}
		}
		ans = min(mx, ans);
		for (auto it : e[x])
		{
			int v = b[it][x] + 1;
			while (vis[a[it][v]])
			{
				v++;
			}
			add(a[it][v], it);
		}
		vis[x] = 1;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<h2 id="c">C</h2>
<h3 id="题目大意-1">题目大意</h3>
<p>有 <span class="math inline">\(x+y+z\)</span> 个人，第 <span class="math inline">\(i\)</span> 个人有 <span class="math inline">\(A_i\)</span> 个金币，<span class="math inline">\(B_i\)</span> 个银币，<span class="math inline">\(C_i\)</span> 个铜币。</p>
<p>要选出 <span class="math inline">\(x\)</span> 个人获得其金币，选出 <span class="math inline">\(y\)</span> 个人获得其银币，选出 <span class="math inline">\(z\)</span> 个人获得其铜币。在不重复选某个人的情况下，求最大的获得的币的总数。</p>
<h3 id="解题思路-1">解题思路</h3>
<p>考虑<strong>反悔贪心</strong>。</p>
<p>一开始有三个元素：金币、银币、铜币，较难处理。</p>
<p>考虑反悔机制，直接默认所有人都拿金币，之后把 <span class="math inline">\(y\)</span> 人改成银币，选出 <span class="math inline">\(z\)</span> 个改成铜币即可。</p>
<p>具体地，把金币个数加到答案里，再把每个人的信息改成二元组 <span class="math inline">\((B_i-A_i,C_i-A_i)\)</span>，使得在选金币后再选这两个元素之一和选银币或铜币等价。</p>
<p>记 <span class="math inline">\(D_i=B_i-A_i\)</span>，<span class="math inline">\(E_i=C_i-A_i\)</span>，问题转化为在 <span class="math inline">\(N\)</span> 个二元组中选 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(D_i\)</span> 收益，选 <span class="math inline">\(z\)</span> 个 <span class="math inline">\(E_i\)</span> 收益，求最大的总收益。</p>
<p>考虑何时 <span class="math inline">\((D_i,E_i)\)</span> 选 <span class="math inline">\(D_i\)</span>、<span class="math inline">\((D_j,E_j)\)</span> 选 <span class="math inline">\(E_j\)</span> 不比 <span class="math inline">\((D_i,E_i)\)</span> 选 <span class="math inline">\(E_i\)</span>、<span class="math inline">\((D_j,E_j)\)</span> 选 <span class="math inline">\(D_j\)</span> 劣。</p>
<p>即 <span class="math inline">\(D_i+E_j\ge D_j+E_i\)</span>，移项得：<span class="math inline">\(D_i-E_i\ge D_j-E_j\)</span>。</p>
<p>于是我们可以按 <span class="math inline">\((D_i,E_i)\)</span> 从大到小排序，此时前面一段统一选 <span class="math inline">\(D_i\)</span>，后面一段统一选 <span class="math inline">\(E_i\)</span> 一定不劣。</p>
<p>然后可以用优先队列维护前缀最大的 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(D_i\)</span> 的和 <span class="math inline">\(s[i]\)</span>，后最大的 <span class="math inline">\(y\)</span> 个 <span class="math inline">\(D_i\)</span> 的和 <span class="math inline">\(t[i]\)</span>。</p>
<p>答案即为：</p>
<p></p><div class="math display">\[\sum A+\max_{i=y}^{n-z}(s[i]+t[i+1])
\]</div><p></p><p>时间复杂度 <span class="math inline">\(O(\log n)\)</span></p>
<h3 id="代码-1">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define endl "\n"
#define ll long long
using namespace std;

const int N = 1e5 + 10;

struct node
{
	int a, b;
} p[N];

int n, x, y, z;
ll ans, s[N], t[N];
priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q;

bool cmp(node x, node y)
{
	return x.a - x.b &gt; y.a - y.b;
}

int main()
{
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
	n = x + y + z;
	for (int i = 1; i &lt;= n; i++)
	{
		int a, b, c;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		ans += a;
		p[i].a = b - a, p[i].b = c - a;
	}
	sort(p + 1, p + n + 1, cmp);
	for (int i = 1; i &lt;= n; i++)
	{
		s[i] = s[i - 1] + p[i].a;
		q.push(p[i].a);
		if ((int)q.size() &gt; y)
		{
			s[i] -= q.top();
			q.pop();
		}
	}
	while (!q.empty())
	{
		q.pop();
	}
	for (int i = n; i &gt;= 1; i--)
	{
		t[i] = t[i + 1] + p[i].b;
		q.push(p[i].b);
		if ((int)q.size() &gt; z)
		{
			t[i] -= q.top();
			q.pop();
		}
	}
	ll mx = LONG_LONG_MIN;
	for (int i = y; i &lt;= n - z; i++)
	{
		mx = max(mx, s[i] + t[i + 1]);
	}
	cout &lt;&lt; ans + mx &lt;&lt; endl;
	return 0;
}
</code></pre>
<h2 id="d">D</h2>
<h3 id="题目大意-2">题目大意</h3>
<p>给出一棵有 <span class="math inline">\(N\)</span> 个点有边权的无根树，现有一个有 <span class="math inline">\(N\)</span> 个点的完全图，两点间边权即为他们在树上的简单路径长度，求这个图最长的哈密顿路径的长度。</p>
<h3 id="解题思路-2">解题思路</h3>
<p>先考虑最长哈密顿回路长度。</p>
<p>要使其最长，就需要尽可能多地经过每一条边，考虑树上一条边能做出的最大贡献。</p>
<p>设这条边为 <span class="math inline">\((u,fa)\)</span>，由于是哈密顿回路，有出有进且不能重复访问点，可以得到访问次数上界为 <span class="math inline">\(2\min(size_u,n-size_u)\)</span>。</p>
<p>考虑能否让每条边取到这个上界，假设子树的点数小于子树外点数，可以发现取到上界时<strong>不能有路径在子树内部</strong>，因为子树点数本来就少，又被自己匹配掉一些，就会使经过这条边的最大次数减少，如果大于同理，也不能有路径完全在子树外。</p>
<p>为了方便讨论，我们不妨<strong>钦定重心为树根</strong>（如果重心有两个就可以缩点成一个），根据重心的性质，不会有子树点数大于子树外点数的情况，就避免了考虑另一种情况。</p>
<p>于是可以得到：<strong>不能有路径在一个子树内部，即每条路径都要经过重心，就可以取到最值</strong>（补充：一个重心可以就只在达重心上，两个重心必须经过连接两个重心的边），我们只需将答案加上最值即可。</p>
<p>现在我们考虑哈密顿路径，就是在回路的基础上减去一条最短的路径。</p>
<ul>
<li>一个重心：此时最小值一定是在终点在重心上，那么就可以钦定连接重心的最小边为最后一条边，删去它损失必定最小</li>
<li>两个重心：由于两个重心必须经过连接两个重心的边，那么最短的路径即恰好为连接两个重心的边。</li>
</ul>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<p>关于讨论区问题的补充：</p>
<p>证明最大哈密顿回路去掉最小边一定是最大哈密顿路径。</p>
<p>如果它不是最大哈密顿回路，即存在在同一棵子树的路径，由于一条路径会匹配掉两个点，那么就会使得经过的连接重心的边的访问次数减 <span class="math inline">\(2\)</span>。</p>
<p>如图，中间的边少访问了两次：（非原创，侵删）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dvfbruqa.png" alt="" loading="lazy"></p>
<p>因为少了两次，而我们的哈密顿路径选取了最小的边，只少一次，因此它的哈密顿回路已经小于最大的哈密顿路径，所以哈密顿路径更小于最大的哈密顿路径。</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define endl "\n"
#define ll long long
using namespace std;

const int N = 1e5 + 10;

struct edge
{
	int to, w, next;
} e[N &lt;&lt; 1];

ll n, tot, ans, p1, p2;
ll h[N], sz[N], mx[N];

void add(int u, int v, int w)
{
	tot++;
	e[tot].to = v;
	e[tot].w = w;
	e[tot].next = h[u];
	h[u] = tot;
}

void dfs(int u, int fa)
{
	sz[u] = 1;
	for (int i = h[u]; i; i = e[i].next)
	{
		int v = e[i].to;
		if (v == fa)
		{
			continue;
		}
		dfs(v, u);
		sz[u] += sz[v];
		mx[u] = max(mx[u], sz[v]);
		ans += 2 * min(sz[v], n - sz[v]) * e[i].w;
	}
	mx[u] = max(mx[u], n - sz[u]);
}

int main()
{
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin &gt;&gt; n;
	for (int i = 1; i &lt; n; i++)
	{
		int u, v, w;
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u, v, w), add(v, u, w);
	}
	dfs(1, 0);
	ll mn = LONG_LONG_MAX;
	for (int i = 1; i &lt;= n; i++)
	{
		mn = min(mn, mx[i]);
	}
	for (int i = 1; i &lt;= n; i++)
	{
		if (mx[i] == mn)
		{
			if (!p1)
			{
				p1 = i;
			}
			else
			{
				p2 = i;
			}
		}
	}
	mn = LONG_LONG_MAX;
	for (int i = h[p1]; i; i = e[i].next)
	{
		int v = e[i].to;
		if (p2 &amp;&amp; v != p2)
		{
			continue;
		}
		mn = min(mn, (ll)e[i].w);
	}
	cout &lt;&lt; ans - mn &lt;&lt; endl;
	return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06467113602314815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-19 16:41">2025-01-19 16:07</span>&nbsp;
<a href="https://www.cnblogs.com/lintianchen">I_LOVE_MATH</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18679648" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18679648);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18679648', targetLink: 'https://www.cnblogs.com/lintianchen/p/18679648', title: 'AGC018' })">举报</a>
</div>
        