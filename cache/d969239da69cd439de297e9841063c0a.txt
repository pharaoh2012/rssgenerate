
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18790452" title="发布于 2025-03-24 23:46">
    <span role="heading" aria-level="2">Netty源码—5.Pipeline和Handler</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="3" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="4"><strong>1.Pipeline和Handler的作用和构成</strong></p>
<p data-track="5"><strong>2.ChannelHandler的分类</strong></p>
<p data-track="6"><strong>3.几个特殊的ChannelHandler</strong></p>
<p data-track="7"><strong>4.ChannelHandler的生命周期</strong></p>
<p data-track="8"><strong>5.ChannelPipeline的事件处理</strong></p>
<p data-track="9"><strong>6.关于ChannelPipeline的问题整理</strong></p>
<p data-track="10"><strong>7.ChannelPipeline主要包括三部分内容</strong></p>
<p data-track="11"><strong>8.ChannelPipeline的初始化</strong></p>
<p data-track="12"><strong>9.ChannelPipeline添加ChannelHandler</strong></p>
<p data-track="13"><strong>10.ChannelPipeline删除ChannelHandler</strong></p>
<p data-track="14"><strong>11.Inbound事件的传播</strong></p>
<p data-track="15"><strong>12.Outbound事件的传播</strong></p>
<p data-track="16"><strong>13.ChannelPipeline中异常的传播</strong></p>
<p data-track="17"><strong>14.ChannelPipeline总结</strong></p>
<p data-track="18">&nbsp;</p>
<p data-track="19"><strong>1.Pipeline和Handler的作用和构成</strong></p>
<p data-track="20"><strong>(1)Pipeline和Handler的作用</strong></p>
<p data-track="21"><strong>(2)Pipeline和Handler的构成</strong></p>
<p data-track="22">&nbsp;</p>
<p data-track="23"><strong>(1)Pipeline和Handler的作用</strong></p>
<p data-track="24">可以在处理复杂的业务逻辑时避免if else的泛滥，可以实现对业务逻辑的模块化处理，不同的逻辑放置到单独的类中进行处理。最后将这些逻辑串联起来，形成一个完整的逻辑处理链。</p>
<p data-track="25">&nbsp;</p>
<p data-track="26">Netty通过责任链模式来组织代码逻辑，能够支持逻辑的动态添加和删除，能够支持各类协议的扩展。</p>
<p data-track="27">&nbsp;</p>
<p data-track="28"><strong>(2)Pipeline和Handler的构成</strong></p>
<p data-track="29">在Netty里，一个连接对应着一个Channel。这个Channel的所有处理逻辑都在一个叫ChannelPipeline的对象里，ChannelPipeline是双向链表结构，它和Channel之间是一对一的关系。</p>
<p data-track="30">&nbsp;</p>
<p data-track="31">ChannelPipeline里的每个结点都是一个ChannelHandlerContext对象，这个ChannelHandlerContext对象能够获得和Channel相关的所有上下文信息。每个ChannelHandlerContext对象都包含一个逻辑处理器ChannelHandler，每个逻辑处理器ChannelHandler都处理一块独立的逻辑。</p>
<p data-track="32">&nbsp;</p>
<p data-track="33"><strong>2.ChannelHandler的分类</strong></p>
<p data-track="34">ChannelHandler有两大子接口，分别为Inbound和Outbound类型：第一个子接口是ChannelInboundHandler，用于处理读数据逻辑，最重要的方法是channelRead()。第二个子接口是ChannelOutboundHandler，用于处理写数据逻辑，最重要的方法是write()。</p>
<p data-track="35">&nbsp;</p>
<p data-track="36">这两个子接口默认的实现分别是：ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter。它们分别实现了两个子接口的所有功能，在默认情况下会把读写事件传播到下一个Handler。</p>
<p data-track="37">&nbsp;</p>
<p data-track="38">InboundHandler的事件通常只会传播到下一个InboundHandler，OutboundHandler的事件通常只会传播到下一个OuboundHandler，InboundHandler的执行顺序与实际addLast的添加顺序相同，OutboundHandler的执行顺序与实际addLast的添加顺序相反。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">Inbound事件通常由IO线程触发，如TCP链路的建立事件、关闭事件、读事件、异常通知事件等。其触发方法一般带有fire字眼，如下所示：</p>
<p data-track="41">ctx.fireChannelRegister()、</p>
<p data-track="42">ctx.fireChannelActive()、</p>
<p data-track="43">ctx.fireChannelRead()、</p>
<p data-track="44">ctx.fireChannelReadComplete()、</p>
<p data-track="45">ctx.fireChannelInactive()。</p>
<p data-track="46">&nbsp;</p>
<p data-track="47">Outbound事件通常由用户主动发起的网络IO操作触发，如用户发起的连接操作、绑定操作、消息发送等操作。其触发方法一般如：ctx.bind()、ctx.connect()、ctx.write()、ctx.flush()、ctx.read()、ctx.disconnect()、ctx.close()。</p>
<p data-track="48">&nbsp;</p>
<p data-track="49"><strong>3.几个特殊的ChannelHandler</strong></p>
<p data-track="50"><strong>(1)ChannelInboundHandlerAdapter</strong></p>
<p data-track="51"><strong>(2)ChannelOutboundHandlerAdapter</strong></p>
<p data-track="52"><strong>(3)ByteToMessageDecoder</strong></p>
<p data-track="53"><strong>(4)SimpleChannelInboundHandler</strong></p>
<p data-track="54"><strong>(5)MessageToByteEncoder</strong></p>
<p data-track="55">&nbsp;</p>
<p data-track="56"><strong>(1)ChannelInboundHandlerAdapter</strong></p>
<p data-track="57">ChannelInboundHandlerAdapter主要用于实现ChannelInboundHandler接口的所有方法，这样我们在继承它编写自己的ChannelHandler时就不需要实现ChannelHandler里的每种方法了，从而避免了直接实现ChannelHandler时需要实现其所有方法而导致代码显得冗余和臃肿。</p>
<pre class="highlighter-hljs"><code>//Handles an I/O event or intercepts an I/O operation, and forwards it to its next handler in its ChannelPipeline.
public interface ChannelHandler {
    //Gets called after the ChannelHandler was added to the actual context and it's ready to handle events.
    void handlerAdded(ChannelHandlerContext ctx) throws Exception;

    //Gets called after the ChannelHandler was removed from the actual context and it doesn't handle events anymore.
    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;

    //Gets called if a Throwable was thrown.
    @Deprecated
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;

    //Indicates that the same instance of the annotated ChannelHandler can be added to one or more ChannelPipelines multiple times without a race condition.
    @Inherited
    @Documented
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Sharable {
        // no value
    }
}

//Skeleton implementation of a ChannelHandler.
public abstract class ChannelHandlerAdapter implements ChannelHandler {
    // Not using volatile because it's used only for a sanity check.
    boolean added;

    //Return true if the implementation is Sharable and so can be added to different ChannelPipelines.
    public boolean isSharable() {
        Class&lt;?&gt; clazz = getClass();
        Map&lt;Class&lt;?&gt;, Boolean&gt; cache = InternalThreadLocalMap.get().handlerSharableCache();
        Boolean sharable = cache.get(clazz);
        if (sharable == null) {
            sharable = clazz.isAnnotationPresent(Sharable.class);
            cache.put(clazz, sharable);
        }
        return sharable;
    }

    //Do nothing by default, sub-classes may override this method.
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }

    //Do nothing by default, sub-classes may override this method.
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }

    //Calls ChannelHandlerContext#fireExceptionCaught(Throwable) to forward to the next ChannelHandler in the ChannelPipeline.
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.fireExceptionCaught(cause);
    }
}

//ChannelHandler which adds callbacks for state changes. 
//This allows the user to hook in to state changes easily.
public interface ChannelInboundHandler extends ChannelHandler {
    //The Channel of the ChannelHandlerContext was registered with its EventLoop
    void channelRegistered(ChannelHandlerContext ctx) throws Exception;

    //The Channel of the ChannelHandlerContext was unregistered from its EventLoop
    void channelUnregistered(ChannelHandlerContext ctx) throws Exception;

    //The Channel of the ChannelHandlerContext is now active
    void channelActive(ChannelHandlerContext ctx) throws Exception;

    //The Channel of the ChannelHandlerContext was registered is now inactive and reached its end of lifetime.
    void channelInactive(ChannelHandlerContext ctx) throws Exception;

    //Invoked when the current Channel has read a message from the peer.
    void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;

    //Invoked when the last message read by the current read operation has been consumed by #channelRead(ChannelHandlerContext, Object).
    //If ChannelOption#AUTO_READ is off, no further attempt to read an inbound data from the current Channel will be made until ChannelHandlerContext#read() is called.
    void channelReadComplete(ChannelHandlerContext ctx) throws Exception;

    //Gets called if an user event was triggered.
    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;

    //Gets called once the writable state of a Channel changed. 
    //You can check the state with Channel#isWritable().
    void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;

    //Gets called if a Throwable was thrown.
    @Override
    @SuppressWarnings("deprecation")
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
}

//Abstract base class for ChannelInboundHandler implementations which provide implementations of all of their methods.
public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {
    //Calls ChannelHandlerContext#fireChannelRegistered() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelRegistered();
    }

    //Calls ChannelHandlerContext#fireChannelUnregistered() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelUnregistered();
    }

    //Calls ChannelHandlerContext#fireChannelActive() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelActive();
    }

    //Calls ChannelHandlerContext#fireChannelInactive() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelInactive();
    }

    //Calls ChannelHandlerContext#fireChannelRead(Object) to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ctx.fireChannelRead(msg);
    }

    //Calls ChannelHandlerContext#fireChannelReadComplete() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelReadComplete();
    }

    //Calls ChannelHandlerContext#fireUserEventTriggered(Object) to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        ctx.fireUserEventTriggered(evt);
    }

    //Calls ChannelHandlerContext#fireChannelWritabilityChanged() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelWritabilityChanged();
    }

    //Calls ChannelHandlerContext#fireExceptionCaught(Throwable) to forward to the next ChannelHandler in the ChannelPipeline.
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.fireExceptionCaught(cause);
    }
}</code></pre>
<p data-track="59"><strong>(2)ChannelOutboundHandlerAdapter</strong></p>
<p data-track="60">ChannelOutboundHandlerAdapter主要用于实现ChannelOutboundHandler接口的所有方法，这样我们在继承它编写自己的ChannelHandler时就不需要实现ChannelHandler里的每种方法了，从而避免了直接实现ChannelHandler时需要实现其所有方法而导致代码显得冗余和臃肿。</p>
<pre class="highlighter-hljs"><code>//ChannelHandler which will get notified for IO-outbound-operations.
public interface ChannelOutboundHandler extends ChannelHandler {
    //Called once a bind operation is made.
    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;

    //Called once a connect operation is made.
    void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception;

    //Called once a disconnect operation is made.
    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //Called once a close operation is made.
    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //Called once a deregister operation is made from the current registered EventLoop.
    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //Intercepts ChannelHandlerContext#read().
    void read(ChannelHandlerContext ctx) throws Exception;

    //Called once a write operation is made. The write operation will write the messages through the ChannelPipeline.
    //Those are then ready to be flushed to the actual Channel once Channel#flush() is called.
    void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;

    //Called once a flush operation is made. The flush operation will try to flush out all previous written messages that are pending.
    void flush(ChannelHandlerContext ctx) throws Exception;
}

//Skeleton implementation of a ChannelOutboundHandler. This implementation just forwards each method call via the ChannelHandlerContext.
public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
    //Calls ChannelHandlerContext#bind(SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.bind(localAddress, promise);
    }

    //Calls ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline. 
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.connect(remoteAddress, localAddress, promise);
    }

    //Calls ChannelHandlerContext#disconnect(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.disconnect(promise);
    }

    //Calls ChannelHandlerContext#close(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.close(promise);
    }

    //Calls ChannelHandlerContext#deregister(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.deregister(promise);
    }

    //Calls ChannelHandlerContext#read() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void read(ChannelHandlerContext ctx) throws Exception {
        ctx.read();
    }

    //Calls ChannelHandlerContext#write(Object, ChannelPromise)} to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ctx.write(msg, promise);
    }

    //Calls ChannelHandlerContext#flush() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void flush(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}</code></pre>
<p data-track="62"><strong>(3)ByteToMessageDecoder</strong></p>
<p data-track="63">基于这个ChannelHandler可以实现自定义解码，而不用关心ByteBuf的强转和解码结果的传递。Netty里的ByteBuf默认下使用的是堆外内存，ByteToMessageDecoder会自动进行内存的释放，不用操心内存管理。我们自定义的ChannelHandler继承了ByteToMessageDecoder后，需要实现decode()方法。</p>
<p data-track="64">&nbsp;</p>
<p data-track="65"><strong>(4)SimpleChannelInboundHandler</strong></p>
<p data-track="66">基于这个ChannelHandler可以实现每一种指令的处理，不再需要强转、不再有冗长的if else逻辑、不再需要手动传递对象。</p>
<p data-track="67">&nbsp;</p>
<p data-track="68">同时还可以自动释放没有往下传播的ByteBuf，因为我们编写指令处理ChannelHandler时，可能会编写不用关心的if else判断，然后手动传递无法处理的对象至下一个指令处理器。</p>
<pre class="highlighter-hljs"><code>//xxxHandler.java
if (packet instanceof xxxPacket) {
    //进行处理
} else {
    ctx.fireChannelRead(packet);
}</code></pre>
<p data-track="70"><strong>(5)MessageToByteEncoder</strong></p>
<p data-track="71">基于这个ChannelHandler可以实现自定义编码，而不用关心ByteBuf的创建，不用把创建完的ByteBuf进行返回。</p>
<p data-track="72">&nbsp;</p>
<p data-track="73"><strong>4.ChannelHandler的生命周期</strong></p>
<p data-track="74"><strong>(1)ChannelHandler回调方法的执行顺序</strong></p>
<p data-track="75">ChannelHandler回调方法的执行顺序可以称为ChannelHandler的生命周期。</p>
<p data-track="76">&nbsp;</p>
<p data-track="77">新建连接时ChannelHandler回调方法的执行顺序是：handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete()。</p>
<p data-track="78">&nbsp;</p>
<p data-track="79">关闭连接时ChannelHandler回调方法的执行顺序是：channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()。</p>
<p data-track="80">&nbsp;</p>
<p data-track="81">接下来是ChannelHandler具体的回调方法说明，其中一二三的顺序可以参考AbstractChannel的内部类AbstractUnsafe的register0()方法。</p>
<p data-track="82">&nbsp;</p>
<p data-track="83"><strong>一.handlerAdded()</strong></p>
<p data-track="84">检测到新连接后调用"ch.pipeline().addLast(...)"之后的回调，表示当前Channel已成功添加一个ChannelHandler。</p>
<p data-track="85">&nbsp;</p>
<p data-track="86"><strong>二.channelRegistered()</strong></p>
<p data-track="87">表示当前Channel已和某个NioEventLoop线程建立了绑定关系，已经创建了一个Reactor线程来处理当前这个Channel的读写。</p>
<p data-track="88">&nbsp;</p>
<p data-track="89"><strong>三.channelActive()</strong></p>
<p data-track="90">当Channel的Pipeline已经添加完所有的ChannelHandler以及绑定好一个NioEventLoop线程，这个Channel对应的连接才算真正被激活，接下来就会回调该方法。</p>
<p data-track="91">&nbsp;</p>
<p data-track="92"><strong>四.channelRead()</strong></p>
<p data-track="93">服务端每次收到客户端发送的数据时都会回调该方法，表示有数据可读。</p>
<p data-track="94">&nbsp;</p>
<p data-track="95"><strong>五.channelReadComplete()</strong></p>
<p data-track="96">服务端每次读完一条完整的数据都会回调该方法，表示数据读取完毕。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>六.channelInactive()</strong></p>
<p data-track="99">表示这个连接已经被关闭，该连接在TCP层已经不再是ESTABLISH状态。</p>
<p data-track="100">&nbsp;</p>
<p data-track="101"><strong>七.channelUnregister()</strong></p>
<p data-track="102">表示与这个连接对应的NioEventLoop线程移除了对这个连接的处理。</p>
<p data-track="103">&nbsp;</p>
<p data-track="104"><strong>八.handlerRemoved()</strong></p>
<p data-track="105">表示给这个连接添加的所有的ChannelHandler都被移除了。</p>
<p data-track="106">&nbsp;</p>
<p data-track="107"><strong>(2)ChannelHandler回调方法的应用场景</strong></p>
<p data-track="108">一.handlerAdded()方法与handlerRemoved()方法通常可用于一些资源的申请和释放。</p>
<p data-track="109">&nbsp;</p>
<p data-track="110">二.channelActive()方法与channelInactive()方法表示的是TCP连接的建立与释放，可用于统计单机连接数或IP过滤。</p>
<p data-track="111">&nbsp;</p>
<p data-track="112">三.channelRead()方法可用于根据自定义协议进行拆包。每次读到一定数据就累加到一个容器里，然后看看能否拆出完整的包。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114">四.channelReadComplete()方法可用于实现批量刷新。如果每次向客户端写数据都通过writeAndFlush()方法写数据并刷新到底层，其实并不高效。所以可以把调用writeAndFlush()方法的地方换成调用write()方法，然后再在channelReadComplete()方法里调用ctx.channel().flush()。</p>
<p data-track="115">&nbsp;</p>
<p data-track="116"><strong>5.ChannelPipeline的事件处理</strong></p>
<p data-track="117"><strong>(1)消息读取和发送被Pipeline处理的过程</strong></p>
<p data-track="118"><strong>(2)ChannelPipeline的主要特征</strong></p>
<p data-track="119">&nbsp;</p>
<p data-track="120"><strong>(1)消息读取和发送被Pipeline处理的过程</strong></p>
<p data-track="121">消息的读取和发送被ChannelPipeline的ChannelHandler链拦截和处理的全过程：</p>
<p data-track="122">一.首先AbstractNioChannel内部类NioUnsafe的read()方法读取ByteBuf时会触发ChannelRead事件，也就是由NioEventLoop线程调用ChannelPipeline的fireChannelRead()方法将ByteBuf消息传输到ChannelPipeline中。</p>
<p data-track="123">二.然后ByteBuf消息会依次被HeadContext、xxxChannelHandler、...、TailContext拦截处理。在这个过程中，任何ChannelHandler都可以中断当前的流程，结束消息的传递。</p>
<p data-track="124">三.接着用户可能会调用ChannelHandlerContext的write()方法发送ByteBuf消息。此时ByteBuf消息会从TailContext开始，途径xxxChannelHandler、...、HeadContext，最终被添加到消息发送缓冲区中等待刷新和发送。在这个过程中，任何ChannelHandler都可以中断当前的流程，中断消息的传递。</p>
<p data-track="125">&nbsp;</p>
<p data-track="126"><strong>(2)ChannelPipeline的主要特征</strong></p>
<p data-track="127">一.ChannelPipeline支持运行时动态地添加或者删除ChannelHandler</p>
<p data-track="128">例如业务高峰时对系统做拥塞保护。处于业务高峰期时，则动态地向当前的ChannelPipeline添加ChannelHandler。高峰期过后，再移除ChannelHandler。</p>
<p data-track="129">&nbsp;</p>
<p data-track="130">二.ChannelPipeline是线程安全的</p>
<p data-track="131">多个业务线程可以并发操作ChannelPipeline，因为使用了synchronized关键字。但ChannelHandler却不一定是线程安全的，这由用户保证。</p>
<p data-track="132">&nbsp;</p>
<p data-track="133"><strong>6.关于ChannelPipeline的问题整理</strong></p>
<p data-track="134"><strong>一.Netty是如何判断ChannelHandler类型的？</strong></p>
<p data-track="135">即如何判断一个ChannelHandler是Inbound类型还是Outbound类型？</p>
<p data-track="136">&nbsp;</p>
<p data-track="137">答：当调用Pipeline去添加一个ChannelHandler结点时，旧版Netty会使用instanceof关键字来判断该结点是Inbound类型还是Outbound类型，并分别用一个布尔类型的变量来进行标识。新版Netty则使用一个整形的executionMask来具体区分详细的Inbound事件和Outbound事件。这个executionMask对应一个16位的二进制数，是哪一种事件就对应哪一个Mask。</p>
<pre class="highlighter-hljs"><code>//Inbound事件的Mask
MASK_EXEPTION_CAUGHT = 1;
MASK_CHANNEL_REGISTER = 1 &lt;&lt; 1;
MASK_CHANNEL_UNREGISTER = 1 &lt;&lt; 2;
MASK_CHANNEL_ACTIVE = 1 &lt;&lt; 3;
MASK_CHANNEL_INACTIVE = 1 &lt;&lt; 4;
MASK_CHANNEL_READ = 1 &lt;&lt; 5;
MASK_CHANNEL_READ_COMPLETE = 1 &lt;&lt; 6;
MASK_CHANNEL_USER_EVENT_TRIGGERED = 1 &lt;&lt; 7;
MASK_CHANNEL_WRITABLITY_CHANGED = 1 &lt;&lt; 8;

//Outbound事件的Mask
MASK_BIND = 1 &lt;&lt; 9;
MASK_CONNECT = 1 &lt;&lt; 10;
MASK_DISCONNECT = 1 &lt;&lt; 11;
MASK_CLOSE = 1 &lt;&lt; 12;
MASK_DEREGISTER = 1 &lt;&lt; 13;
MASK_READ = 1 &lt;&lt; 14;
MASK_WRITE = 1 &lt;&lt; 15;
MASK_FLUSH = 1 &lt;&lt; 16;</code></pre>
<p data-track="139"><strong>二.添加ChannelHandler时应遵循什么样的顺序？</strong></p>
<p data-track="140">答：Inbound类型的事件传播跟添加ChannelHandler的顺序一样，Outbound类型的事件传播跟添加ChannelHandler的顺序相反。</p>
<p data-track="141">&nbsp;</p>
<p data-track="142"><strong>三.用户手动触发事件传播的两种方式有什么区别？</strong></p>
<p data-track="143">这两种方式是分别是：ctx.writeAndFlush()和ctx.channel().writeAndFlush()。</p>
<p data-track="144">&nbsp;</p>
<p data-track="145">答：当通过Channel去触发一个事件时，那么该事件会沿整个ChannelPipeline传播。如果是Inbound类型事件，则从HeadContext结点开始向后传播到最后一个Inbound类型的结点。如果是Outbound类型事件，则从TailContext结点开始向前传播到第一个Outbound类型的结点。当通过当前结点去触发一个事件时，那么该事件只会从当前结点开始传播。如果是Inbound类型事件，则从当前结点开始一直向后传播到最后一个Inbound类型的结点。如果是Outbound类型事件，则从当前结点开始一直向前传播到第一个Outbound类型的结点。</p>
<p data-track="146">&nbsp;</p>
<p data-track="147"><strong>7.ChannelPipeline主要包括三部分内容</strong></p>
<p data-track="148"><strong>一.ChannelPipeline的初始化</strong></p>
<p data-track="149">服务端Channel和客户端Channel在何时初始化ChannelPipeline？在初始化时又做了什么事情？</p>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>二.添加和删除ChannelHandler</strong></p>
<p data-track="152">Netty是如何实现业务逻辑处理器动态编织的？</p>
<p data-track="153">&nbsp;</p>
<p data-track="154"><strong>三.事件和异常的传播</strong></p>
<p data-track="155">读写事件和异常在ChannelPipeline中的传播。</p>
<p data-track="156">&nbsp;</p>
<p data-track="157"><strong>8.ChannelPipeline的初始化</strong></p>
<p data-track="158"><strong>(1)ChannelPipeline的初始化时机</strong></p>
<p data-track="159"><strong>(2)ChannelPipeline的初始化内容</strong></p>
<p data-track="160"><strong>(3)ChannelPipeline的说明</strong></p>
<p data-track="161">&nbsp;</p>
<p data-track="162"><strong>(1)ChannelPipeline的初始化时机</strong></p>
<p data-track="163">在服务端启动和客户端连接接入的过程中，在创建NioServerSocketChannel和NioSocketChannel时，会逐层执行父类的构造方法，最后执行到AbstractChannel的构造方法。AbstractChannel的构造方法会将Netty的核心组件创建出来。而核心组件中就包含了DefaultChannelPipeline类型的ChannelPipeline组件。</p>
<pre class="highlighter-hljs"><code>//A skeletal Channel implementation.
public abstract class AbstractChannel extends DefaultAttributeMap implements Channel { 
    private final Channel parent;
    private final ChannelId id;
    private final Unsafe unsafe;
    private final DefaultChannelPipeline pipeline;
    ...
    //Creates a new instance.
    protected AbstractChannel(Channel parent) {
        this.parent = parent;
        id = newId();
        unsafe = newUnsafe();
        pipeline = newChannelPipeline();
    }
    
    //Returns a new DefaultChannelPipeline instance.
    protected DefaultChannelPipeline newChannelPipeline() {
        //创建ChannelPipeline组件
        return new DefaultChannelPipeline(this);
    }
    ...
}

//The default ChannelPipeline implementation.  
//It is usually created by a Channel implementation when the Channel is created.
public class DefaultChannelPipeline implements ChannelPipeline {
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    private final Channel channel;//保存了Channel的引用
    ...
    protected DefaultChannelPipeline(Channel channel) {
        //保存Channel的引用到Pipeline组件的成员变量
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        ...
        tail = new TailContext(this);
        head = new HeadContext(this);
        head.next = tail;
        tail.prev = head;
    }
    ...
}</code></pre>
<p data-track="165"><strong>(2)ChannelPipeline的初始化内容</strong></p>
<p data-track="166">ChannelPipeline的初始化主要涉及三部分内容：</p>
<p data-track="167">一.Pipeline在创建Channel时被创建</p>
<p data-track="168">二.Pipeline的结点是ChannelHandlerContext</p>
<p data-track="169">三.Pipeline两大哨兵HeadContext和TailContext</p>
<p data-track="170">&nbsp;</p>
<p data-track="171"><strong>(3)ChannelPipeline的说明</strong></p>
<p data-track="172">ChannelPipeline中保存了Channel的引用，ChannelPipeline中每个结点都是一个ChannelHandlerContext对象，每个ChannelHandlerContext结点都包裹着一个ChannelHandler执行器，每个ChannelHandlerContext结点都保存了它包裹的执行器ChannelHandler执行操作时所需要的上下文ChannelPipeline。由于ChannelPipeline又保存了Channel的引用，所以每个ChannelHandlerContext结点都可以拿到所有的上下文信息。</p>
<p data-track="173">&nbsp;</p>
<p data-track="174">ChannelHandlerContext接口多继承自AttributeMap、ChannelInboundInvoker、ChannelOutboundInvoker。</p>
<p data-track="175">&nbsp;</p>
<p data-track="176">ChannelHandlerContext的关键方法有：channel()、executor()、handler()、pipeline()、alloc()。ChannelHandlerContext默认是由AbstractChannelHandlerContext去实现的，它实现了大部分功能。</p>
<p data-track="177">&nbsp;</p>
<p data-track="178">ChannelPipeline初始化时会初始化两个结点：HeadContext和TailContext，并构成双向链表。HeadContext结点会比TailContext结点多一个unsafe成员变量。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    //ChannelPipeline中每个结点都是一个ChannelHandlerContext对象
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    private final Channel channel;//ChannelPipeline中保存了Channel的引用
    ...
    protected DefaultChannelPipeline(Channel channel) {
        //保存Channel的引用到Pipeline组件的成员变量
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        ...
        //ChannelPipeline初始化时会初始化两个结点：HeadContext和TailContext，并构成双向链表
        tail = new TailContext(this);
        head = new HeadContext(this);
        head.next = tail;
        tail.prev = head;
    }
    
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        //HeadContext结点会比TailContext结点多一个unsafe成员变量
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
    }
    
    final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
        TailContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, TAIL_NAME, true, false);
            setAddComplete();
        }
        ...
    }
    ...
}

//ChannelHandlerContext默认是由AbstractChannelHandlerContext去实现的，它实现了大部分功能
abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint { 
    //每个ChannelHandlerContext结点都保存了它包裹的执行器ChannelHandler执行操作时所需要的上下文ChannelPipeline
    private final DefaultChannelPipeline pipeline;
    ...
    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, boolean inbound, boolean outbound) {
        this.name = ObjectUtil.checkNotNull(name, "name");
        this.pipeline = pipeline;
        this.executor = executor;
        this.inbound = inbound;
        this.outbound = outbound;
        ordered = executor == null || executor instanceof OrderedEventExecutor;
    }
}

public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {
    //Return the Channel which is bound to the ChannelHandlerContext.
    Channel channel();
    
    //Returns the EventExecutor which is used to execute an arbitrary task.
    EventExecutor executor();

    //The unique name of the ChannelHandlerContext.
    //The name was used when then ChannelHandler was added to the ChannelPipeline. 
    //This name can also be used to access the registered ChannelHandler from the ChannelPipeline.
    String name();

    //The ChannelHandler that is bound this ChannelHandlerContext.
    ChannelHandler handler();

    //Return true if the ChannelHandler which belongs to this context was removed from the ChannelPipeline. 
    //Note that this method is only meant to be called from with in the EventLoop.
    boolean isRemoved();

    ChannelHandlerContext fireChannelRegistered();
    ChannelHandlerContext fireChannelUnregistered();
    ChannelHandlerContext fireChannelActive();
    ChannelHandlerContext fireChannelInactive();
    ChannelHandlerContext fireExceptionCaught(Throwable cause);
    ChannelHandlerContext fireUserEventTriggered(Object evt);
    ChannelHandlerContext fireChannelRead(Object msg);
    ChannelHandlerContext fireChannelReadComplete();
    ChannelHandlerContext fireChannelWritabilityChanged();
    ChannelHandlerContext read();
    ChannelHandlerContext flush();
    //Return the assigned ChannelPipeline
    ChannelPipeline pipeline();
    //Return the assigned ByteBufAllocator which will be used to allocate ByteBufs.
    ByteBufAllocator alloc();
    ...
}</code></pre>
<p data-track="180">&nbsp;</p>
<p data-track="181"><strong>9.ChannelPipeline添加ChannelHandler</strong></p>
<p data-track="182"><strong>(1)常见的客户端代码</strong></p>
<p data-track="183"><strong>(2)ChannelPipeline添加ChannelHandler入口</strong></p>
<p data-track="184"><strong>(3)DefaultChannelPipeline的addLast()方法</strong></p>
<p data-track="185"><strong>(4)检查是否重复添加ChannelHandler结点</strong></p>
<p data-track="186"><strong>(5)创建ChannelHandlerContext结点</strong></p>
<p data-track="187"><strong>(6)添加ChannelHandlerContext结点</strong></p>
<p data-track="188"><strong>(7)回调handerAdded()方法</strong></p>
<p data-track="189"><strong>(8)ChannelPipeline添加ChannelHandler总结</strong></p>
<p data-track="190">&nbsp;</p>
<p data-track="191"><strong>(1)常见的客户端代码</strong></p>
<p data-track="192">首先用一个拆包器Spliter对二进制数据流进行拆包，然后解码器Decoder会将拆出来的包进行解码，接着业务处理器BusinessHandler会处理解码出来的Java对象，最后编码器Encoder会将业务处理完的结果编码成二进制数据进行输出。</p>
<pre class="highlighter-hljs"><code>bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline p = ch.pipeline();   
        p.addLast(newSpliter());
        p.addLast(new Decoder());
        p.addLast(new BusinessHandler());
        p.addLast(new Encoder());          
    }
});</code></pre>
<p data-track="194">整个ChannelPipeline的结构如下所示：</p>
<div class="pgc-img"><img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=OWNjZDFjMjI2ODRiYjRiYTJlNDUxNmQyYzA0YzBiZTcsMTc0MjgzMTA2Mjg1OA==" data-ic="false" data-width="1080" data-height="179" data-ic-uri=""></div>
<p data-track="195">这里共有两种不同类型的结点，结点之间通过双向链表连接。一种是ChannelInboundHandler，用来处理Inbound事件，比如读取数据流进行加工处理。一种是ChannelOutboundHandler，用来处理Outbound事件，比如当调用writeAndFlush()方法时就会经过这种类型的Handler。</p>
<p data-track="196">&nbsp;</p>
<p data-track="197"><strong>(2)ChannelPipeline添加ChannelHandler入口</strong></p>
<p data-track="198">当服务端Channel的Reactor线程轮询到新连接接入的事件时，就会调用AbstractNioChannel的内部类NioUnsafe的read()方法，也就是调用AbstractNioMessageChannel的内部类NioMessageUnsafe的read()方法。</p>
<p data-track="199">&nbsp;</p>
<p data-track="200">然后会触发执行代码pipeline.fireChannelRead()传播ChannelRead事件，从而最终触发调用ServerBootstrapAcceptor接入器的channelRead()方法。</p>
<p data-track="201">&nbsp;</p>
<p data-track="202">在ServerBootstrapAcceptor的channelRead()方法中，便会通过执行代码channel.pipeline().addLast()添加ChannelHandler，也就是通过调用DefaultChannelPipeline的addLast()方法添加ChannelHandler。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public final class NioEventLoop extends SingleThreadEventLoop {
    Selector selector;
    private SelectedSelectionKeySet selectedKeys;
    private boolean needsToSelectAgain;
    private int cancelledKeys;
    ...
    @Override
    protected void run() {
        for (;;) {
            ...
            //1.调用select()方法执行一次事件轮询
            select(wakenUp.getAndSet(false));
            if (wakenUp.get()) {
                selector.wakeup();
            }
            ...
            //2.处理产生IO事件的Channel
            needsToSelectAgain = false;
            processSelectedKeys();
            ...
            //3.执行外部线程放入TaskQueue的任务
            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
        }
    }
    
    private void processSelectedKeys() {
        if (selectedKeys != null) {
            //selectedKeys.flip()会返回一个数组
            processSelectedKeysOptimized(selectedKeys.flip());
        } else {
            processSelectedKeysPlain(selector.selectedKeys());
        }
    }
    
    private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
        for (int i = 0;; i ++) {
            //1.首先取出IO事件
            final SelectionKey k = selectedKeys[i];
            if (k == null) {
                break;
            }
            selectedKeys[i] = null;//Help GC
            //2.然后获取对应的Channel和处理该Channel
            //默认情况下，这个a就是NioChannel，也就是服务端启动时经过Netty封装的Channel
            final Object a = k.attachment();
            if (a instanceof AbstractNioChannel) {
                //网络事件的处理
                processSelectedKey(k, (AbstractNioChannel) a);
            } else {
                //NioTask主要用于当一个SelectableChannel注册到Selector时，执行的一些任务
                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
                processSelectedKey(k, task);
            }
            //3.最后判断是否应该再进行一次轮询
            if (needsToSelectAgain) {
                for (;;) {
                    i++;
                    if (selectedKeys[i] == null) {
                        break;
                    }
                    selectedKeys[i] = null;
                }
                selectAgain();
                //selectedKeys.flip()会返回一个数组
                selectedKeys = this.selectedKeys.flip();
                i = -1;
            }
        }
    }
    
    private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        ...
        try {
            int readyOps = k.readyOps();
            ...
            //boss的Reactor线程已经轮询到有ACCEPT事件，即表明有新连接接入
            //此时将调用Channel的unsafe变量来进行实际操作
            if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                //调用AbstractNioMessageChannel的NioMessageUnsafe.read()方法
                //进行新连接接入处理
                unsafe.read();
                if (!ch.isOpen()) {
                    return;
                }
            }
        } catch (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }
    ...
}

//AbstractNioChannel base class for Channels that operate on messages.
public abstract class AbstractNioMessageChannel extends AbstractNioChannel {
    ...
    private final class NioMessageUnsafe extends AbstractNioUnsafe {
        //临时存放读到的连接NioSocketChannel
        private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();
        @Override
        public void read() {
            //断言确保该read()方法必须来自Reactor线程调用
            assert eventLoop().inEventLoop();
            //获得Channel对应的Pipeline
            final ChannelPipeline pipeline = pipeline();
            //获得Channel对应的RecvByteBufAllocator.Handle
            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
            do {
                //1.调用NioServerSocketChannel的doReadMessages()方法创建NioSocketChannel
                //通过JDK的accept()方法去创建JDK Channel，然后把它包装成Netty自定义的Channel
                int localRead = doReadMessages(readBuf);
                if (localRead == 0) {
                    break;
                }
            } while (allocHandle.continueReading());//控制连接的接入速率，默认一次性读取16个连接
          
            //2.设置并绑定NioSocketChannel
            int size = readBuf.size();
            for (int i = 0; i &lt; size; i ++) {
                //调用DefaultChannelPipeline的fireChannelRead()方法
                pipeline.fireChannelRead(readBuf.get(i));
            }
            //3.清理容器并触发DefaultChannelPipeline的fireChannelReadComplete()方法
            readBuf.clear();
            pipeline.fireChannelReadComplete();
        }
    }
    ...
}

//The default ChannelPipeline implementation.  
//It is usually created by a Channel implementation when the Channel is created.
public class DefaultChannelPipeline implements ChannelPipeline {
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    ...
    protected DefaultChannelPipeline(Channel channel) {
        ...
        tail = new TailContext(this);
        head = new HeadContext(this);
        head.next = tail;
        tail.prev = head;
    }
    
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        //从Pipeline的第一个HeadContext处理器开始调用
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        return this;
    }
    
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        ...
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            //调用AbstractChannelHandlerContext的fireChannelRead()方法
            ctx.fireChannelRead(msg);
        }
     
        @Override
        public ChannelHandler handler() {
            return this;
        }
        ...
    }
    ...
}

public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; {
    ...
    //初始化服务端Channel时，会向其Pipeline添加ServerBootstrapAcceptor处理器
    @Override
    void init(Channel channel) throws Exception {
        //1.设置服务端Channel的Option与Attr
        final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();
        synchronized (options) {
            channel.config().setOptions(options);
        }
        final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();
        synchronized (attrs) {
            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {
                @SuppressWarnings("unchecked")
                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();
                channel.attr(key).set(e.getValue());
            }
        }
       
        //2.设置客户端Channel的Option与Attr
        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;
        synchronized (childOptions) {
            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));
        }
        synchronized (childAttrs) {
            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));
        }
       
        //3.配置服务端启动逻辑
        ChannelPipeline p = channel.pipeline();
        //p.addLast()用于定义服务端启动过程中需要执行哪些逻辑
        p.addLast(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            public void initChannel(Channel ch) throws Exception {
                //一.添加用户自定义的Handler，注意这是handler，而不是childHandler
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) pipeline.addLast(handler);
                //二.添加一个特殊的Handler用于接收新连接
                //自定义的childHandler会作为参数传入连接器ServerBootstrapAcceptor
                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        //调用DefaultChannelPipeline的addLast()方法
                        pipeline.addLast(new ServerBootstrapAcceptor(
                            currentChildGroup, 
                            currentChildHandler, 
                            currentChildOptions, 
                            currentChildAttrs)
                        );
                    }
                });
            }
        });
    }

    private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter {
        private final EventLoopGroup childGroup;
        private final ChannelHandler childHandler;
        private final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;
        private final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;
        ...
        //channelRead()方法在新连接接入时被调用
        @Override
        @SuppressWarnings("unchecked")
        public void channelRead(ChannelHandlerContext ctx, Object msg) {
            final Channel child = (Channel) msg;
            //1.给新连接的Channel添加用户自定义的Handler处理器
            //这里的childHandler其实是一个特殊的Handler: ChannelInitializer
            child.pipeline().addLast(childHandler);
            //2.设置ChannelOption，主要和TCP连接一些底层参数及Netty自身对一个连接的参数有关
            for (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) {
                if (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) {
                    logger.warn("Unknown channel option: " + e);
                }
            }
            //3.设置新连接Channel的属性
            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) {
                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());
            }
            //4.绑定Reactor线程
            //childGroup是一个NioEventLoopGroup，所以下面会调用其父类的register()方法
            childGroup.register(child);
        }
        ...
    }
    ...
}</code></pre>
<p data-track="204"><strong>(3)DefaultChannelPipeline的addLast()方法</strong></p>
<p data-track="205">使用synchronized关键字是为了防止多线程并发操作ChannelPipeline底层的双向链表，添加ChannelHandler结点的过程主要分为4个步骤：</p>
<p data-track="206">步骤一：判断ChannelHandler是否重复添加</p>
<p data-track="207">步骤二：创建结点</p>
<p data-track="208">步骤三：添加结点到链表</p>
<p data-track="209">步骤四：回调添加完成事件</p>
<p data-track="210">&nbsp;</p>
<p data-track="211">这个结点便是ChannelHandlerContext，Pipeline里每个结点都是一个ChannelHandlerContext。addLast()方法便是把ChannelHandler包装成一个ChannelHandlerContext，然后添加到链表。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    @Override
    public final ChannelPipeline addLast(ChannelHandler... handlers) {
        return addLast(null, handlers);
    }
    
    @Override
    public final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) {
        if (handlers == null) throw new NullPointerException("handlers");
        for (ChannelHandler h: handlers) {
            if (h == null) break;
            addLast(executor, null, h);
        }
        return this;
    }
    
    @Override
    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
        final AbstractChannelHandlerContext newCtx;
        synchronized (this) {
            //1.检查是否有重复的ChannelHandler结点
            checkMultiplicity(handler);
            //2.创建ChannelHandlerContext结点
            newCtx = newContext(group, filterName(name, handler), handler);
            //3.添加ChannelHandlerContext结点
            addLast0(newCtx);
            ...
        }
        //4.回调用户方法
        //通过这个方法告诉用户这个ChannelHandler已添加完成，用户在回调方法里可以处理事情了
        callHandlerAdded0(newCtx);
        return this;
    }
    ...
}</code></pre>
<p data-track="213"><strong>(4)检查是否重复添加ChannelHandler结点</strong></p>
<p data-track="214">Netty使用了一个成员变量added来表示一个ChannelHandler是否已经添加。如果当前要添加的ChannelHandler是非共享的并且已经添加过，那么抛出异常，否则标识该ChannelHandler已添加。</p>
<p data-track="215">&nbsp;</p>
<p data-track="216">如果一个ChannelHandler支持共享，那么它就可以无限次被添加到ChannelPipeline中。如果要让一个ChannelHandler支持共享，只需要加一个@Sharable注解即可。而ChannelHandlerAdapter的isSharable()方法正是通过判断该ChannelHandler对应的类是否标有@Sharable注解来实现的。</p>
<p data-track="217">&nbsp;</p>
<p data-track="218">Netty为了性能优化，还使用了ThreadLocal来缓存ChannelHandler是否共享的情况。在高并发海量连接下，每次有新连接添加ChannelHandler都会调用isSharable()方法，从而优化性能。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    private static void checkMultiplicity(ChannelHandler handler) {
        if (handler instanceof ChannelHandlerAdapter) {
            ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;
            if (!h.isSharable() &amp;&amp; h.added) {
                throw new ChannelPipelineException(h.getClass().getName() +
                    " is not a @Sharable handler, so can't be added or removed multiple times.");
            }
            h.added = true;
        }
    }
    ...
}

//Skeleton implementation of a ChannelHandler.
public abstract class ChannelHandlerAdapter implements ChannelHandler {
    //Not using volatile because it's used only for a sanity check.
    boolean added;

    //Return true if the implementation is Sharable and so can be added to different ChannelPipelines.
    public boolean isSharable() {
        //Cache the result of Sharable annotation detection to workaround a condition. 
        //We use a ThreadLocal and WeakHashMap to eliminate the volatile write/reads. 
        //Using different WeakHashMap instances per Thread is good enough for us and the number of Threads are quite limited anyway.
        Class&lt;?&gt; clazz = getClass();
        Map&lt;Class&lt;?&gt;, Boolean&gt; cache = InternalThreadLocalMap.get().handlerSharableCache();
        Boolean sharable = cache.get(clazz);
        if (sharable == null) {
            sharable = clazz.isAnnotationPresent(Sharable.class);
            cache.put(clazz, sharable);
        }
        return sharable;
    }
    ...
}</code></pre>
<p data-track="220"><strong>(5)创建ChannelHandlerContext结点</strong></p>
<p data-track="221">根据ChannelHandler创建ChannelHandlerContext类型的结点时，会将该ChannelHandler的引用保存到结点的成员变量中。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...    
    @Override
    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
        final AbstractChannelHandlerContext newCtx;
        synchronized (this) {
            //1.检查是否有重复的ChannelHandler结点
            checkMultiplicity(handler);
            //2.创建ChannelHandlerContext结点
            newCtx = newContext(group, filterName(name, handler), handler);
            //3.添加ChannelHandlerContext结点
            addLast0(newCtx);
            ...
        }
        //4.回调用户方法
        //通过这个方法告诉用户这个ChannelHandler已添加完成，用户在回调方法里可以处理事情了
        callHandlerAdded0(newCtx);
        return this;
    }
    
    //给ChannelHandler创建一个唯一性的名字
    private String filterName(String name, ChannelHandler handler) {
        if (name == null) {
            return generateName(handler);
        }
        checkDuplicateName(name);
        return name;
    }
    
    //根据ChannelHandler创建一个ChannelHandlerContext结点
    private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) {
        return new DefaultChannelHandlerContext(this, childExecutor(group), name, handler);
    }
    ...
}

final class DefaultChannelHandlerContext extends AbstractChannelHandlerContext {
    private final ChannelHandler handler;
    DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) {
        super(pipeline, executor, name, isInbound(handler), isOutbound(handler));
        if (handler == null) {
            throw new NullPointerException("handler");
        }
        this.handler = handler;
    }
    ...
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    ...
    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, boolean inbound, boolean outbound) {
        this.name = ObjectUtil.checkNotNull(name, "name");
        this.pipeline = pipeline;
        this.executor = executor;
        this.inbound = inbound;
        this.outbound = outbound;
        ordered = executor == null || executor instanceof OrderedEventExecutor;
    }
    ...
}</code></pre>
<p data-track="223"><strong>(6)添加ChannelHandlerContext结点</strong></p>
<p data-track="224">使用尾插法向双向链表添加结点。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    private void addLast0(AbstractChannelHandlerContext newCtx) {
        AbstractChannelHandlerContext prev = tail.prev;
        newCtx.prev = prev;
        newCtx.next = tail;
        prev.next = newCtx;
        tail.prev = newCtx;
    }
    ...
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    volatile AbstractChannelHandlerContext next;
    volatile AbstractChannelHandlerContext prev;
    ...
}</code></pre>
<p data-track="226"><strong>(7)回调handerAdded()方法</strong></p>
<p data-track="227">向ChannelPipeline添加完新结点后，会使用CAS修改结点的状态为ADD_COMPLETE表示结点添加完成，然后执行ctx.handler().handlerAdded(ctx)，回调用户在这个要添加的ChannelHandler中实现的handerAdded()方法。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
        //使用CAS修改结点的状态为ADD_COMPLETE表示结点添加完成
        ctx.setAddComplete();
        //回调用户在这个要添加的ChannelHandler中实现的handerAdded()方法
        ctx.handler().handlerAdded(ctx);
    }
    ...
}

//DemoHandler是用户定义的ChannelHandler
public class DemoHandler extends SimpleChannelInboundHandler&lt;...&gt; {
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        //这个DemoHandler结点被添加到ChannelPipeline之后，就会回调这里的方法
    }
    ...
}</code></pre>
<p data-track="229">最典型的一个回调就是用户代码的ChannelInitializer被添加完成后，会先调用其initChannel()方法将用户自定义的ChannelHandler添加到ChannelPipeline，然后再调用pipeline.remove()方法将自身结点进行删除。</p>
<pre class="highlighter-hljs"><code>public class NettyServer {
    private int port;
    public NettyServer(int port) {
        this.port = port;
    }
  
    public void start() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap
            .group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)//监听端口的ServerSocketChannel
            .option(ChannelOption.SO_BACKLOG, 128)
            .childOption(ChannelOption.SO_KEEPALIVE, true)
            //设置一个ChannelInitializer类型的childHandler
            //新连接接入时，会执行ServerBootstrapAcceptor.channelRead()中的代码"child.pipeline().addLast(childHandler)"
            //也就是会把这个ChannelInitializer类型的结点会被添加到新连接Channel的Pipeline中
            //添加完这个结点后会回调ChannelInitializer的handlerAdded()方法
            //其中会调用ChannelInitializer的initChannel()方法给Pipeline添加真正的结点
            //执行完initChannel()方法后，就会移除ChannelInitializer这个结点
            .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {//处理每个客户端连接的SocketChannel
                @Override
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    socketChannel.pipeline()
                    .addLast(new StringDecoder())
                    .addLast(new StringEncoder())
                    .addLast(new NettyServerHandler());//针对网络请求的处理逻辑
                }
            });
            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();//同步等待启动服务器监控端口
            channelFuture.channel().closeFuture().sync();//同步等待关闭启动服务器的结果
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws Exception{
        System.out.println("Starting Netty Server...");
        int port = 8998;
        if (args.length &gt; 0) {
            port = Integer.parseInt(args[0]);
        }
        new NettyServer(port).start();
    }
}

@Sharable
public abstract class ChannelInitializer&lt;C extends Channel&gt; extends ChannelInboundHandlerAdapter {
    ...
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        if (ctx.channel().isRegistered()) {
            initChannel(ctx);
        }
    }

    @SuppressWarnings("unchecked")
    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {
        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.
            try {
                initChannel((C) ctx.channel());
            } catch (Throwable cause) {
                exceptionCaught(ctx, cause);
            } finally {
                remove(ctx);
            }
            return true;
        }
        return false;
    }

    private void remove(ChannelHandlerContext ctx) {
        try {
            ChannelPipeline pipeline = ctx.pipeline();
            if (pipeline.context(this) != null) {
                //ChannelPipeline删除ChannelHandler结点(ChannelInitializer)
                pipeline.remove(this);
            }
        } finally {
            initMap.remove(ctx);
        }
    }
    ...
}</code></pre>
<p data-track="231"><strong>(8)ChannelPipeline添加ChannelHandler总结</strong></p>
<p data-track="232">一.判断ChannelHandler是否重复添加的依据是：如果该ChannelHandler不是共享的且已被添加过，则拒绝添加。</p>
<p data-track="233">二.否则就创建一个ChannelHandlerContext结点(ctx)，并把这个ChannelHandler包装进去，也就是保存ChannelHandler的引用到ChannelHandlerContext的成员变量中。由于创建ctx时保存了ChannelHandler的引用、ChannelPipeline的引用到成员变量，ChannelPipeline又保存了Channel的引用，所以每个ctx都拥有一个Channel的所有信息。</p>
<p data-track="234">三.接着通过双向链表的尾插法，将这个ChannelHandlerContext结点添加到ChannelPipeline中。</p>
<p data-track="235">四.最后回调用户在这个要添加的ChannelHandler中实现的handerAdded()方法。</p>
<p data-track="236">&nbsp;</p>
<p data-track="237"><strong>10.ChannelPipeline删除ChannelHandler</strong></p>
<p data-track="238">Netty最大的特征之一就是ChannelHandler是可插拔的，可以动态编织ChannelPipeline。比如在客户端首次连接服务端时，需要进行权限认证，认证通过后就可以不用再认证了。下面的AuthHandler便实现了只对第一个传来的数据包进行认证校验。如果通过验证则删除此AuthHandler，这样后续传来的数据包便不会再校验了。</p>
<pre class="highlighter-hljs"><code>public class AuthHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
    ...
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf data) throw Exception {
        if (verify(data)) {
            ctx.pipeline().remove(this);     
        } else {
            ctx.close();
        }
    }
}</code></pre>
<p data-track="240">DefaultChannelPipeline的remove()方法如下：</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    @Override
    public final ChannelPipeline remove(ChannelHandler handler) {
        remove(getContextOrDie(handler));
        return this;
    }
    
    private AbstractChannelHandlerContext getContextOrDie(ChannelHandler handler) {
        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);
        if (ctx == null) {
            throw new NoSuchElementException(handler.getClass().getName());
        } else {
            return ctx;
        }
    }
    
    @Override
    public final ChannelHandlerContext context(ChannelHandler handler) {
        ...
        AbstractChannelHandlerContext ctx = head.next;
        //遍历双向链表
        for (;;) {
            ...
            if (ctx.handler() == handler) return ctx;
            ctx = ctx.next;
        }
    }
    
    private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) { 
        //Pipeline中的head和tail结点不能被删除
        assert ctx != head &amp;&amp; ctx != tail;
        synchronized (this) {
            //调整链表指针并删除
            remove0(ctx);
            ...
        }
        //回调用户在这个要删除的ChannelHandler实现的handlerRemoved()方法
        callHandlerRemoved0(ctx);
        return ctx;
    }

    private static void remove0(AbstractChannelHandlerContext ctx) {
        AbstractChannelHandlerContext prev = ctx.prev;
        AbstractChannelHandlerContext next = ctx.next;
        prev.next = next;
        next.prev = prev;
    }
    
    private void callHandlerRemoved0(final AbstractChannelHandlerContext ctx) {
        ...
        ctx.handler().handlerRemoved(ctx);
        ...
    }
    ...
}</code></pre>
<p data-track="242">ChannelPipeline删除ChannelHandler的步骤：</p>
<p data-track="243">一.遍历双向链表，根据ChannelHandler找到对应的ChannelHandlerContext结点。</p>
<p data-track="244">二.通过调整ChannelPipeline中双向链表的指针来删除对应的ChannelHandlerContext结点。</p>
<p data-track="245">三.回调用户在这个要删除的ChannelHandler实现的handlerRemoved()方法，比如进行资源清理。</p>
<p data-track="246">&nbsp;</p>
<p data-track="247"><strong>11.Inbound事件的传播</strong></p>
<p data-track="248"><strong>(1)Unsafe的介绍</strong></p>
<p data-track="249"><strong>(2)Unsafe的继承结构</strong></p>
<p data-track="250"><strong>(3)Unsafe的分类</strong></p>
<p data-track="251"><strong>(4)ChannelPipeline中Inbound事件传播</strong></p>
<p data-track="252"><strong>(5)ChannelPipeline中的头结点和尾结点</strong></p>
<p data-track="253"><strong>(6)Inbound事件的传播总结</strong></p>
<p data-track="254">&nbsp;</p>
<p data-track="255"><strong>(1)Unsafe的介绍</strong></p>
<p data-track="256">Unsafe和ChannelPipeline密切相关，ChannelPipeline中有关IO的操作最终都会落地到Unsafe的。Unsafe是不安全的意思，即不要在应用程序里直接使用Unsafe及它的衍生类对象。Unsafe是在Channel中定义的，是属于Channel的内部类。Unsafe中的接口操作都和JDK底层相关，包括：分配内存、Socket四元组信息、注册事件循环、绑定端口、Socket的连接和关闭、Socket的读写。</p>
<pre class="highlighter-hljs"><code>//A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind.
public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable&lt;Channel&gt; {
    //Returns the globally unique identifier of this Channel.
    ChannelId id();
    
    //Return the EventLoop this Channel was registered to.
    EventLoop eventLoop();

    //Returns the parent of this channel.
    Channel parent();

    //Returns the configuration of this channel.
    ChannelConfig config();

    //Returns true if the Channel is open and may get active later
    boolean isOpen();

    //Returns true if the Channel is registered with an EventLoop.
    boolean isRegistered();

    //Return true if the Channel is active and so connected.
    boolean isActive();

    //Return the ChannelMetadata of the Channel which describe the nature of the Channel.
    ChannelMetadata metadata();

    //Returns the local address where this channel is bound to.  
    //The returned SocketAddress is supposed to be down-cast into more concrete type such as InetSocketAddress to retrieve the detailed information. 
    SocketAddress localAddress();

    //Returns the remote address where this channel is connected to.  
    //The returned SocketAddress is supposed to be down-cast into more concrete type such as InetSocketAddress to retrieve the detailed information.
    SocketAddress remoteAddress();

    //Returns the ChannelFuture which will be notified when this channel is closed.  
    //This method always returns the same future instance.
    ChannelFuture closeFuture();

    //Returns true if and only if the I/O thread will perform the requested write operation immediately.  
    //Any write requests made when this method returns false are queued until the I/O thread is ready to process the queued write requests.
    boolean isWritable();

    //Get how many bytes can be written until #isWritable() returns false.
    //This quantity will always be non-negative. If #isWritable() is false then 0.
    long bytesBeforeUnwritable();

    //Get how many bytes must be drained from underlying buffers until #isWritable() returns true.
    //This quantity will always be non-negative. If #isWritable() is true then 0.
    long bytesBeforeWritable();

    //Returns an &lt;em&gt;internal-use-only&lt;/em&gt; object that provides unsafe operations.
    Unsafe unsafe();

    //Return the assigned ChannelPipeline.
    ChannelPipeline pipeline();

    //Return the assigned ByteBufAllocator which will be used to allocate ByteBufs.
    ByteBufAllocator alloc();

    @Override
    Channel read();

    @Override
    Channel flush();

    //Unsafe operations that should never be called from user-code. 
    //These methods are only provided to implement the actual transport, and must be invoked from an I/O thread except for the following methods:
    //#invoker()
    //#localAddress()
    //#remoteAddress()
    //#closeForcibly()
    //#register(EventLoop, ChannelPromise)
    //#deregister(ChannelPromise)
    //#voidPromise()
    interface Unsafe {
        //Return the assigned RecvByteBufAllocator.Handle which will be used to allocate ByteBuf's when receiving data.
        RecvByteBufAllocator.Handle recvBufAllocHandle();

        //Return the SocketAddress to which is bound local or null if none.
        SocketAddress localAddress();

        //Return the SocketAddress to which is bound remote or null if none is bound yet.
        SocketAddress remoteAddress();

        //Register the Channel of the ChannelPromise and notify the ChannelFuture once the registration was complete.
        void register(EventLoop eventLoop, ChannelPromise promise);

        //Bind the SocketAddress to the Channel of the ChannelPromise and notify it once its done.
        void bind(SocketAddress localAddress, ChannelPromise promise);

        //Connect the Channel of the given ChannelFuture with the given remote SocketAddress.
        //If a specific local SocketAddress should be used it need to be given as argument. Otherwise just pass null to it.
        //he ChannelPromise will get notified once the connect operation was complete.
        void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);

        //Disconnect the Channel of the ChannelFuture and notify the ChannelPromise once the operation was complete.
        void disconnect(ChannelPromise promise);

        //Close the Channel of the ChannelPromise and notify the ChannelPromise once the operation was complete.
        void close(ChannelPromise promise);

        //Closes the Channel immediately without firing any events.  Probably only useful when registration attempt failed.
        void closeForcibly();

        //Deregister the Channel of the ChannelPromise from EventLoop and notify the ChannelPromise once the operation was complete.
        void deregister(ChannelPromise promise);

        //Schedules a read operation that fills the inbound buffer of the first ChannelInboundHandler in the ChannelPipeline.
        //If there's already a pending read operation, this method does nothing.
        void beginRead();

        //Schedules a write operation.
        void write(Object msg, ChannelPromise promise);

        //Flush out all write operations scheduled via #write(Object, ChannelPromise).
        void flush();

        //Return a special ChannelPromise which can be reused and passed to the operations in Unsafe.
        //It will never be notified of a success or error and so is only a placeholder for operations
        //that take a ChannelPromise as argument but for which you not want to get notified.
        ChannelPromise voidPromise();

        //Returns the ChannelOutboundBuffer of the Channel where the pending write requests are stored.
        ChannelOutboundBuffer outboundBuffer();
    }
}

public abstract class AbstractNioChannel extends AbstractChannel {
    ...
    public interface NioUnsafe extends Unsafe {
        //Return underlying SelectableChannel
        SelectableChannel ch();

        //Finish connect
        void finishConnect();

        //Read from underlying SelectableChannel
        void read();

        void forceFlush();
    }
    ...
}</code></pre>
<p data-track="258"><strong>(2)Unsafe的继承结构</strong></p>
<div class="pgc-img"><img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=Y2ViMGM1YjAwNjZiMDNlZGQ4ODdhNDU4ODZhZjEyN2YsMTc0MjgzMTA2Mjg1OQ==" data-ic="false" data-width="808" data-height="770" data-ic-uri=""></div>
<p data-track="259">一.NioUnsafe增加了可以访问底层JDK的SelectableChannel的功能，定义了从SelectableChannel读取数据的read()方法。</p>
<p data-track="260">二.AbstractUnsafe实现了大部分Unsafe的功能。</p>
<p data-track="261">三.AbstractNioUnsafe主要是通过代理到其外部类AbstractNioChannel获得与JDK NIO相关的一些信息，比如SelectableChannel、SelectionKey等。</p>
<p data-track="262">四.NioMessageUnsafe和NioByteUnsafe是处在同一层次的抽象，Netty将一个新连接的建立也当作一个IO操作来处理，这里Message的含义可以当作一个SelectableChannel，读的意思就是接收一个SelectableChannel。</p>
<p data-track="263">&nbsp;</p>
<p data-track="264"><strong>(3)Unsafe的分类</strong></p>
<p data-track="265">有两种类型的Unsafe：一种是与连接的字节数据读写相关的NioByteUnsafe，另一种是与新连接建立操作相关的NioMessageUnsafe。</p>
<p data-track="266">&nbsp;</p>
<p data-track="267"><strong>一.NioByteUnsafe的读和写</strong></p>
<p data-track="268">NioByteUnsafe的读会被委托到NioByteChannel的doReadBytes()方法进行读取处理，doReadBytes()方法会将JDK的SelectableChannel的字节数据读取到Netty的ByteBuf中。</p>
<p data-track="269">&nbsp;</p>
<p data-track="270">NioByteUnsafe中的写有两个方法，一个是write()方法，一个是flush()方法。write()方法是将数据添加到Netty的缓冲区，flush()方法是将Netty缓冲区的字节流写到TCP缓冲区，并最终委托到NioSocketChannel的doWrite()方法通过JDK底层Channel的write()方法写数据。</p>
<pre class="highlighter-hljs"><code>//AbstractNioChannel base class for Channels that operate on bytes.
public abstract class AbstractNioByteChannel extends AbstractNioChannel {
    ...
    protected class NioByteUnsafe extends AbstractNioUnsafe {
        ...
        //NioByteUnsafe的读
        @Override
        public final void read() {
            ...
            doReadBytes(byteBuf);
            ...
        }
    }
}

public class NioSocketChannel extends AbstractNioByteChannel implements SocketChannel {
    ...
    @Override
    protected int doReadBytes(ByteBuf byteBuf) throws Exception {
        final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
        allocHandle.attemptedBytesRead(byteBuf.writableBytes());
        return byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());
    }
    
    @Override
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        ...
        ByteBuffer[] nioBuffers = in.nioBuffers();
        SocketChannel ch = javaChannel();
        ...
        ByteBuffer nioBuffer = nioBuffers[0];
        ...
        ch.write(nioBuffer)
        ...
    }
}

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    ...
    protected abstract class AbstractUnsafe implements Unsafe {
        private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);
        ...
        //NioByteUnsafe的写
        @Override
        public final void write(Object msg, ChannelPromise promise) {
            assertEventLoop();
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            ...
            outboundBuffer.addMessage(msg, size, promise);
        }
       
        //NioByteUnsafe的写
        @Override
        public final void flush() {
            assertEventLoop();
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            ...
            outboundBuffer.addFlush();
            flush0();
        }

        @SuppressWarnings("deprecation")
        protected void flush0() {
            ...
            doWrite(outboundBuffer);
            ...
        }
    }
}</code></pre>
<p data-track="272"><strong>二.NioMessageUnsafe的读</strong></p>
<p data-track="273">NioMessageUnsafe的读会委托到NioServerSocketChannel的doReadMessages()方法进行处理。doReadMessages()方法会调用JDK的accept()方法新建立一个连接，并将这个连接放到一个List里以方便后续进行批量处理。</p>
<pre class="highlighter-hljs"><code>public abstract class AbstractNioMessageChannel extends AbstractNioChannel {
    ...
    private final class NioMessageUnsafe extends AbstractNioUnsafe {
        private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();
        //NioMessageUnsafe的读
        @Override
        public void read() {
            ...
            doReadMessages(readBuf)
            ...
        }
    }
}

public class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel {
    ...
    @Override
    protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
        SocketChannel ch = javaChannel().accept();
        if (ch != null) {
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
        return 0;
    }
}</code></pre>
<p data-track="275"><strong>(4)ChannelPipeline中Inbound事件传播</strong></p>
<p data-track="276">当新连接已准备接入或者已经存在的连接有数据可读时，会在NioEventLoop的processSelectedKey()方法中执行unsafe.read()。</p>
<p data-track="277">&nbsp;</p>
<p data-track="278">如果是新连接已准备接入，执行的是NioMessageUnsafe的read()方法。如果是已经存在的连接有数据可读，执行的是NioByteUnsafe的read()方法。</p>
<p data-track="279">&nbsp;</p>
<p data-track="280">最后都会执行pipeline.fireChannelRead()引发ChannelPipeline的读事件传播。首先会从HeadContext结点开始，也就是调用HeadContext的channelRead()方法。然后触发调用AbstractChannelHandlerContext的fireChannelRead()方法，接着通过findContextInbound()方法找到HeadContext的下一个结点，然后通过invokeChannelRead()方法继续调用该结点的channelRead()方法，直到最后一个结点TailContext。</p>
<pre class="highlighter-hljs"><code>public final class NioEventLoop extends SingleThreadEventLoop {
    ...
    private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        ...
        //新连接已准备接入或者已经存在的连接有数据可读
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            //如果是新连接已准备接入，则调用NioMessageUnsafe的read()方法
            //如果是已经存在的连接有数据可读，执行的是NioByteUnsafe的read()方法
            unsafe.read();
            if (!ch.isOpen()) {
                return;
            }
        }
    }
    ...
}

public abstract class AbstractNioMessageChannel extends AbstractNioChannel {
    ...
    private final class NioMessageUnsafe extends AbstractNioUnsafe {
        private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();
        @Override
        public void read() {
            assert eventLoop().inEventLoop();
            final ChannelConfig config = config();
            final ChannelPipeline pipeline = pipeline();
            //创建ByteBuf分配器
            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
            allocHandle.reset(config);
            ...
            do {
                int localRead = doReadMessages(readBuf);
                ...
                allocHandle.incMessagesRead(localRead);
            } while (allocHandle.continueReading());
          
            int size = readBuf.size();
            for (int i = 0; i &lt; size; i ++) {
                readPending = false;
                //调用DefaultChannelPipeline的fireChannelRead()方法从Head结点开始传播事件
                pipeline.fireChannelRead(readBuf.get(i));
            }
            readBuf.clear();
            allocHandle.readComplete();
            //调用DefaultChannelPipeline的fireChannelReadComplete()方法从Head结点开始传播事件
            pipeline.fireChannelReadComplete();
            ...
        }
        ...
    }
}

public abstract class AbstractNioByteChannel extends AbstractNioChannel {
    ...
    protected class NioByteUnsafe extends AbstractNioUnsafe {
        ...
        @Override
        public final void read() {
            final ChannelConfig config = config();
            final ChannelPipeline pipeline = pipeline();
            //创建ByteBuf分配器
            final ByteBufAllocator allocator = config.getAllocator();
            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
            allocHandle.reset(config);

            ByteBuf byteBuf = null;
            do {
                //1.分配一个ByteBuf
                byteBuf = allocHandle.allocate(allocator);
                //2.将数据读取到分配的ByteBuf中
                allocHandle.lastBytesRead(doReadBytes(byteBuf));
                if (allocHandle.lastBytesRead() &lt;= 0) {
                    byteBuf.release();
                    byteBuf = null;
                    close = allocHandle.lastBytesRead() &lt; 0;
                    break;
                }
                ...
                //3.调用DefaultChannelPipeline的fireChannelRead()方法从Head结点开始传播事件
                pipeline.fireChannelRead(byteBuf);
                byteBuf = null;
            } while (allocHandle.continueReading());

            allocHandle.readComplete();
            //4.调用DefaultChannelPipeline的fireChannelReadComplete()方法从Head结点开始传播事件
            pipeline.fireChannelReadComplete();
            ...
        }
    }
}

public class DefaultChannelPipeline implements ChannelPipeline {
    //ChannelPipeline的头结点
    final AbstractChannelHandlerContext head;
    ...
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        return this;
    }
    
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        ...
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            //调用AbstractChannelHandlerContext的fireChannelRead()方法
            ctx.fireChannelRead(msg);
        }
    }
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    volatile AbstractChannelHandlerContext next;
    volatile AbstractChannelHandlerContext prev;
    ...
    static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            //调用AbstractChannelHandlerContext的invokeChannelRead()方法
            next.invokeChannelRead(m);
        } else {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeChannelRead(m);
                }
            });
        }
    }
    
    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                //比如调用HeadContext的channelRead()方法
                ((ChannelInboundHandler) handler()).channelRead(this, msg);
            } catch (Throwable t) {
                notifyHandlerException(t);
            }
        } else {
            fireChannelRead(msg);
        }
    }
    
    @Override
    public ChannelHandlerContext fireChannelRead(final Object msg) {
        invokeChannelRead(findContextInbound(), msg);
        return this;
    }
    
    //寻找下一个结点
    private AbstractChannelHandlerContext findContextInbound() {
        AbstractChannelHandlerContext ctx = this;
        do {
            ctx = ctx.next;
        } while (!ctx.inbound);
        return ctx;
    }
}</code></pre>
<p data-track="282"><strong>(5)ChannelPipeline中的头结点和尾结点</strong></p>
<p data-track="283">HeadContext是一个同时属于Inbound类型和Outbound类型的ChannelHandler，TailContext则只是一个属于Inbound类型的ChannelHandler。</p>
<p data-track="284">&nbsp;</p>
<p data-track="285">HeadContext结点的作用就是作为头结点开始传递读写事件并调用unsafe进行实际的读写操作。比如Channel读完一次数据后，HeadContext的channelReadComplete()方法会被调用。然后继续执行如下的调用流程：readIfAutoRead() -&gt; channel.read() -&gt; pipeline.read() -&gt; HeadContext.read() -&gt; unsafe.beginRead() -&gt; 再次注册读事件。所以Channel读完一次数据后，会继续向Selector注册读事件。这样只要Channel活跃就可以连续不断地读取数据，然后数据又会通过ChannelPipeline传递到HeadContext结点。</p>
<p data-track="286">&nbsp;</p>
<p data-track="287">TailContext结点的作用是通过让方法体为空来终止大部分事件的传播，它的exceptionCaugh()方法和channelRead()方法分别会发出告警日志以及释放到达该结点的对象。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    //ChannelPipeline的头结点
    final AbstractChannelHandlerContext head;
    //ChannelPipeline的尾结点
    final AbstractChannelHandlerContext tail;
    ...
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        return this;
    }
    
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
      
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
       
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            //调用AbstractChannelHandlerContext的fireChannelRead()方法
            ctx.fireChannelRead(msg);
        }
       
        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
            ctx.fireChannelReadComplete();
            readIfIsAutoRead();
        }
       
        private void readIfIsAutoRead() {
            if (channel.config().isAutoRead()) {
                channel.read();
            }
        }
    }
    
    final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
        TailContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, TAIL_NAME, true, false);
            setAddComplete();
        }
            
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            onUnhandledInboundMessage(msg);
        }
        ...
    }
    
    //Called once a message hit the end of the ChannelPipeline without been handled by the user in ChannelInboundHandler#channelRead(ChannelHandlerContext, Object).
    //This method is responsible to call ReferenceCountUtil#release(Object) on the given msg at some point.
    protected void onUnhandledInboundMessage(Object msg) {
        try {
            logger.debug("Discarded inbound message {} that reached at the tail of the pipeline. " + "Please check your pipeline configuration.", msg);
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
}</code></pre>
<p data-track="289"><strong>(6)Inbound事件的传播总结</strong></p>
<p data-track="290">一般用户自定义的ChannelInboundHandler都继承自ChannelInboundHandlerAdapter。如果用户代码没有覆盖ChannelInboundHandlerAdapter的channelXXX()方法，那么Inbound事件会从HeadContext开始遍历ChannelPipeline的双向链表进行传播，并默认情况下传播到TailContext结点。</p>
<p data-track="291">&nbsp;</p>
<p data-track="292">如果用户代码覆盖了ChannelInboundHandlerAdapter的channelXXX()方法，那么事件传播就会在当前结点结束。所以如果此时这个ChannelHandler又忘记了手动释放业务对象ByteBuf，则可能会造成内存泄露，而SimpleChannelInboundHandler则可以帮用户自动释放业务对象。</p>
<p data-track="293">&nbsp;</p>
<p data-track="294">如果用户代码调用了ChannelHandlerContext的fireXXX()方法来传播事件，那么该事件就从当前结点开始往下传播。</p>
<pre class="highlighter-hljs"><code>public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {
    //Calls ChannelHandlerContext#fireChannelRegistered() to forward to the next ChannelInboundHandler in the ChannelPipeline. 
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelRegistered();
    }

    //Calls ChannelHandlerContext#fireChannelUnregistered() to forward to the next ChannelInboundHandler in the ChannelPipeline. 
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelUnregistered();
    }

    //Calls ChannelHandlerContext#fireChannelActive() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelActive();
    }

    //Calls ChannelHandlerContext#fireChannelInactive() to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelInactive();
    }

    //Calls ChannelHandlerContext#fireChannelRead(Object) to forward to the next ChannelInboundHandler in the ChannelPipeline.
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ctx.fireChannelRead(msg);
    }

    //Calls ChannelHandlerContext#fireChannelReadComplete() to forward to the next ChannelInboundHandler in the ChannelPipeline. 
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelReadComplete();
    }

    //Calls ChannelHandlerContext#fireUserEventTriggered(Object) to forward to the next ChannelInboundHandler in the ChannelPipeline. 
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        ctx.fireUserEventTriggered(evt);
    }

    //Calls ChannelHandlerContext#fireChannelWritabilityChanged() to forward to the next ChannelInboundHandler in the ChannelPipeline. 
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelWritabilityChanged();
    }

    //Calls ChannelHandlerContext#fireExceptionCaught(Throwable) to forward to the next ChannelHandler in the ChannelPipeline.
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.fireExceptionCaught(cause);
    }
}</code></pre>
<p data-track="296">&nbsp;</p>
<p data-track="297"><strong>12.Outbound事件的传播</strong></p>
<p data-track="298"><strong>(1)触发Outbound事件传播的入口</strong></p>
<p data-track="299"><strong>(2)Outbound事件传播的源码</strong></p>
<p data-track="300"><strong>(3)总结</strong></p>
<p data-track="301">&nbsp;</p>
<p data-track="302"><strong>(1)触发Outbound事件传播的入口</strong></p>
<p data-track="303">在消息推送系统中，可能会有如下代码，意思是根据用户ID获得对应的Channel，然后向用户推送消息。</p>
<pre class="highlighter-hljs"><code>Channel channel = ChannelManager.getChannel(userId);
channel.writeAndFlush(response);</code></pre>
<p data-track="305"><strong>(2)Outbound事件传播的源码</strong></p>
<p data-track="306">如果通过Channel来传播Outbound事件，则是从TailContext开始传播的。</p>
<p data-track="307">&nbsp;</p>
<p data-track="308">和Inbound事件一样，Netty为了保证程序的高效执行，所有核心操作都要在Reactor线程中处理。如果业务线程调用了Channel的方法，那么Netty会将该操作封装成一个Task任务添加到任务队列中，随后在Reactor线程的事件循环中执行。</p>
<p data-track="309">&nbsp;</p>
<p data-track="310">findContextOutbound()方法找Outbound结点的过程和findContextInbound()方法找Inbound结点类似，需要反向遍历ChannelPipeline中的双向链表，一直遍历到第一个Outbound结点HeadCountext。</p>
<p data-track="311">&nbsp;</p>
<p data-track="312">如果用户的ChannelHandler覆盖了Outbound类型的方法，但没有把事件在方法中继续传播下去，那么会导致该事件的传播中断。</p>
<p data-track="313">&nbsp;</p>
<p data-track="314">最后一个Inbound结点是TailContext，最后一个Outbound结点是HeadContext，而数据最终会落到HeadContext的write()方法上。</p>
<p data-track="315">&nbsp;</p>
<p data-track="316">下面是channel.writeAndFlush()方法的源码：</p>
<pre class="highlighter-hljs"><code>public interface ChannelOutboundInvoker {
    ...
    //Shortcut for call #write(Object) and #flush().
    ChannelFuture writeAndFlush(Object msg);
    ...
}

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    private final Channel parent;
    private final ChannelId id;
    private final Unsafe unsafe;
    private final DefaultChannelPipeline pipeline;
    ...
    protected AbstractChannel(Channel parent) {
        this.parent = parent;
        id = newId();
        unsafe = newUnsafe();
        pipeline = newChannelPipeline();
    }
    
    protected DefaultChannelPipeline newChannelPipeline() {
        return new DefaultChannelPipeline(this);
    }
    
    @Override
    public ChannelFuture writeAndFlush(Object msg) {
        return pipeline.writeAndFlush(msg);
    }
    ...
}

public class DefaultChannelPipeline implements ChannelPipeline {
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    private final Channel channel;
    
    protected DefaultChannelPipeline(Channel channel) {
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        tail = new TailContext(this);
        head = new HeadContext(this);
        head.next = tail;
        tail.prev = head;
    }
    
    @Override
    public final ChannelFuture writeAndFlush(Object msg) {
        //从TailContext开始传播
        //但TailContext没有重写writeAndFlush()方法
        //所以会调用AbstractChannelHandlerContext的writeAndFlush()方法
        return tail.writeAndFlush(msg);
    }
    ...
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    volatile AbstractChannelHandlerContext next;
    volatile AbstractChannelHandlerContext prev;
    ...
    @Override
    public ChannelFuture writeAndFlush(Object msg) {
        return writeAndFlush(msg, newPromise());
    }
    
    @Override
    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
        if (msg == null) throw new NullPointerException("msg");
        if (!validatePromise(promise, true)) {
            ReferenceCountUtil.release(msg);
            return promise;
        }
        write(msg, true, promise);
        return promise;
    }
    
    private void write(Object msg, boolean flush, ChannelPromise promise) {
        //反向遍历链表进行查找
        AbstractChannelHandlerContext next = findContextOutbound();
        final Object m = pipeline.touch(msg, next);
        EventExecutor executor = next.executor();
        //最终都会由Reactor线程处理Channel的数据读写
        if (executor.inEventLoop()) {
            if (flush) {
                //调用结点的invokeWriteAndFlush()方法
                next.invokeWriteAndFlush(m, promise);
            } else {
                next.invokeWrite(m, promise);
            }
        } else {
            AbstractWriteTask task;
            if (flush) {
                task = WriteAndFlushTask.newInstance(next, m, promise);
            }  else {
                task = WriteTask.newInstance(next, m, promise);
            }
            safeExecute(executor, task, promise, m);
        }
    }
    
    private void invokeWriteAndFlush(Object msg, ChannelPromise promise) {
        if (invokeHandler()) {
            //逐个调用ChannelHandler结点的write()方法，但前提是当前ChannelHandler可以往下传
            //即write()方法在最后也像ChannelOutboundHandlerAdapter那样，调用了ctx.write()往下传播
            invokeWrite0(msg, promise);
            //逐个调用ChannelHandler结点的flush()方法，但前提是当前ChannelHandler可以往下传
            //即flush()方法在最后也像ChannelOutboundHandlerAdapter那样，调用了ctx.flush()往下传播
            invokeFlush0();
        } else {
            writeAndFlush(msg, promise);
        }
    }
    
    private void invokeWrite0(Object msg, ChannelPromise promise) {
        try {
            //逐个调用，最终回到HeadContext的write()方法
            ((ChannelOutboundHandler) handler()).write(this, msg, promise);
        } catch (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
    
    private void invokeFlush0() {
        try {
            //逐个调用，最终回到HeadContext的flush()方法
            ((ChannelOutboundHandler) handler()).flush(this);
        } catch (Throwable t) {
            notifyHandlerException(t);
        }
    }
    ...
}

public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }

        @Override
        public void flush(ChannelHandlerContext ctx) throws Exception {
            unsafe.flush();
        }
    }
    ...
}

//Skeleton implementation of a ChannelOutboundHandler. This implementation just forwards each method call via the ChannelHandlerContext.
public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
    //Calls ChannelHandlerContext#bind(SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.bind(localAddress, promise);
    }

    //Calls ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline. 
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.connect(remoteAddress, localAddress, promise);
    }

    //Calls ChannelHandlerContext#disconnect(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.disconnect(promise);
    }

    //Calls ChannelHandlerContext#close(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.close(promise);
    }

    //Calls ChannelHandlerContext#deregister(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.deregister(promise);
    }

    //Calls ChannelHandlerContext#read() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void read(ChannelHandlerContext ctx) throws Exception {
        ctx.read();
    }

    //Calls ChannelHandlerContext#write(Object, ChannelPromise)} to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ctx.write(msg, promise);
    }

    //Calls ChannelHandlerContext#flush() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void flush(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}</code></pre>
<p data-track="318"><strong>(3)总结</strong></p>
<p data-track="319">Outbound事件的传播机制和Inbound事件的传播机制类似。但Outbound事件是从链表尾部开始向前传播，而Inbound事件是从链表头部开始向后传播。Outbound事件传播中的写数据，最终都会落到HeadContext结点中的unsafe进行处理。</p>
<p data-track="320">&nbsp;</p>
<p data-track="321"><strong>13.ChannelPipeline中异常的传播</strong></p>
<p data-track="322">Inbound事件和Outbound事件在传播时发生异常都会调用notifyHandlerExecption()方法，该方法会按Inbound事件的传播顺序找每个结点的异常处理方法exceptionCaught()进行处理。</p>
<p data-track="323">&nbsp;</p>
<p data-track="324">我们通常在自定义的ChannelHandler中实现一个处理异常的方法exceptionCaught()，统一处理ChannelPipeline过程中的所有异常。这个自定义ChannelHandler一般继承自ChannelDuplexHandler，表示该结点既是一个Inbound结点，又是一个Outbound结点。</p>
<p data-track="325">&nbsp;</p>
<p data-track="326">如果我们在自定义的ChannelHandler中没有处理异常，由于ChannelHandler通常都继承了ChannelInboundHandlerAdapter，通过其默认实现的exceptionCaught()方法可知异常会一直往下传递，直到最后一个结点的异常处理方法exceptionCaught()中结束。因此如果异常处理方法exceptionCaught()在ChannelPipeline中间的结点实现，则该结点后面的ChannelHandler抛出的异常就没法处理了。所以一般会在ChannelHandler链表的末尾结点实现处理异常的方法exceptionCaught()。</p>
<p data-track="327">&nbsp;</p>
<p data-track="328">需要注意的是：在任何结点中发生的异常都会向下一个结点进行传递。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        return this;
    }
    ...
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint { 
    ...
    @Override
    public ChannelHandlerContext fireChannelRead(final Object msg) {
        invokeChannelRead(findContextInbound(), msg);
        return this;
    }

    static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeChannelRead(m);
        } else {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeChannelRead(m);
                }
            });
        }
    }

    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                ((ChannelInboundHandler) handler()).channelRead(this, msg);
            } catch (Throwable t) {
                notifyHandlerException(t);
            }
        } else {
            fireChannelRead(msg);
        }
    }
    
    private void notifyHandlerException(Throwable cause) {
        if (inExceptionCaught(cause)) {
            if (logger.isWarnEnabled()) {
                logger.warn("...", cause);
            }
            return;
        }
        invokeExceptionCaught(cause);
    }
    
    private void invokeExceptionCaught(final Throwable cause) {
        if (invokeHandler()) {
            try {
                //调用ChannelHandler的exceptionCaught()
                handler().exceptionCaught(this, cause);
            } catch (Throwable error) {
                if (logger.isDebugEnabled()) {
                    logger.debug("...",
                    ThrowableUtil.stackTraceToString(error), cause);
                } else if (logger.isWarnEnabled()) {
                    logger.warn("...", error, cause);
                }
            }
        } else {
            fireExceptionCaught(cause);
        }
    }
    
    @Override
    public ChannelHandlerContext fireExceptionCaught(final Throwable cause) {
        //调用下一个结点next的exceptionCaught()方法
        invokeExceptionCaught(next, cause);
        return this;
    }

    static void invokeExceptionCaught(final AbstractChannelHandlerContext next, final Throwable cause) {
        ObjectUtil.checkNotNull(cause, "cause");
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeExceptionCaught(cause);
        } else {
            try {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        next.invokeExceptionCaught(cause);
                    }
                });
            } catch (Throwable t) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Failed to submit an exceptionCaught() event.", t);
                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
                }
            }
        }
    }
    ...
}

public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {
    ...
    //Calls ChannelHandlerContext#fireExceptionCaught(Throwable) to forward to the next ChannelHandler in the ChannelPipeline. 
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.fireExceptionCaught(cause);
    }
}</code></pre>
<p data-track="330">&nbsp;</p>
<p data-track="331"><strong>14.ChannelPipeline总结</strong></p>
<p data-track="332"><strong>(1)ChannelPipeline的初始化</strong></p>
<p data-track="333"><strong>(2)ChannelPipeline的数据结构</strong></p>
<p data-track="334"><strong>(3)ChannelHandler类型的判断</strong></p>
<p data-track="335"><strong>(4)ChannelPipeline的头尾结点</strong></p>
<p data-track="336"><strong>(5)Channel与Unsafe</strong></p>
<p data-track="337"><strong>(6)ChannelPipeline的事件传播机制</strong></p>
<p data-track="338">&nbsp;</p>
<p data-track="339"><strong>(1)ChannelPipeline的初始化</strong></p>
<p data-track="340">ChannelPipeline在服务端Channel和客户端Channel被创建时创建，创建ChannelPipeline的类是服务端Channel和客户端Channel的共同父类AbstractChannel。</p>
<p data-track="341">&nbsp;</p>
<p data-track="342"><strong>(2)ChannelPipeline的数据结构</strong></p>
<p data-track="343">ChannelPipeline中的数据结构是双向链表结构，每一个结点都是一个ChannelHandlerContext对象。ChannelHandlerContext里包装了用户自定义的ChannelHandler，即前者会保存后者的引用到其成员变量handler中。ChannelHandlerContext中拥有ChannelPipeline和Channel的所有上下文信息。添加和删除ChannelHandler最终都是在ChannelPipeline的链表结构中添加和删除对应的ChannelHandlerContext结点。</p>
<p data-track="344">&nbsp;</p>
<p data-track="345"><strong>(3)ChannelHandler类型的判断</strong></p>
<p data-track="346">在旧版Netty中，会使用instanceof关键字来判断ChannelHandler的类型，并使用两个成员变量inbound和outbound来标识。在新版Netty中，会使用一个16位的二进制数executionMask来表示ChannelHandler具体实现的事件类型，若实现则给对应的位标1。</p>
<p data-track="347">&nbsp;</p>
<p data-track="348"><strong>(4)ChannelPipeline的头尾结点</strong></p>
<p data-track="349">创建ChannelPipeline时会默认添加两个结点：HeadContext结点和TailContext结点。HeadContext结点的作用是作为头结点，开始传播读写事件，并且通过它的unsafe变量实现具体的读写操作。TailContext结点的作用是起到终止事件传播(方法体为空)以及异常和对象未处理的告警。</p>
<p data-track="350">&nbsp;</p>
<p data-track="351"><strong>(5)Channel与Unsafe</strong></p>
<p data-track="352">一个Channel对应一个Unsafe，Unsafe用于处理底层IO操作。NioServerSocketChannel对应NioMessageUnsafe，NioSocketChannel对应NioByteUnsafe。</p>
<p data-track="353">&nbsp;</p>
<p data-track="354"><strong>(6)ChannelPipeline的事件传播机制</strong></p>
<p data-track="355">ChannelPipeline中的事件传播机制分为3种：Inbound事件的传播、Outbound事件的传播、异常事件的传播。</p>
<p data-track="356">&nbsp;</p>
<p data-track="357"><strong>一.Inbound事件的传播</strong></p>
<p data-track="358">如果通过Channel的Pipeline触发这类事件(默认情况下)，那么触发的规则是从head结点开始不断寻找下一个InboundHandler，最终落到tail结点。如果在当前ChannelHandlerContext上触发这类事件，那么事件只会从当前结点开始向下传播。</p>
<p data-track="359">&nbsp;</p>
<p data-track="360"><strong>二.Outbound事件的传播</strong></p>
<p data-track="361">如果通过Channel的Pipeline触发这类事件(默认情况下)，那么触发的规则是从tail结点开始不断寻找上一个InboundHandler，最终落到head结点。如果在当前ChannelHandlerContext上触发这类事件，那么事件只会从当前结点开始向上传播。</p>
<p data-track="362">&nbsp;</p>
<p data-track="363"><strong>三.异常事件的传播</strong></p>
<p data-track="364">异常在ChannelPipeline中的双向链表传播时，无论Inbound结点还是Outbound结点，都是向下一个结点传播，直到tail结点为止。TailContext结点会打印这些异常信息，最佳实践是在ChannelPipeline的最后实现异常处理方法exceptionCaught()。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.46650292425925927" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-24 23:47">2025-03-24 23:46</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">48</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18790452" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18790452);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18790452', targetLink: 'https://www.cnblogs.com/mjunz/p/18790452', title: 'Netty源码—5.Pipeline和Handler' })">举报</a>
</div>
        