
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MeteorSeed/p/18662695" title="发布于 2025-01-17 09:55">
    <span role="heading" aria-level="2">【译】使用 Visual Studio Profiler 进行基准测试</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在 Visual Studio 17.13 预览版中，我们发布了更新的 BenchmarkDotNet 诊断器，允许您使用性能分析器中的更多工具来分析基准测试。有了这个变化，可以非常快速地挖掘 CPU 使用情况和内存分配，从而使测量/修改/测量周期快速而高效。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span>　　在 Visual Studio 17.13 预览版中，我们发布了更新的 BenchmarkDotNet 诊断器，允许您使用性能分析器中的更多工具来分析基准测试。有了这个变化，可以非常快速地挖掘 CPU 使用情况和内存分配，从而使测量/修改/测量周期快速而高效。</span></p>
<h1><span><span>对实际项目进行基准测试</span></span></h1>
<p><span>　　因此，为了展示我们如何使用这些工具使事情变得更好，让我们来测试一个真实的项目。在撰写本文时，CsvHelper 是 Nuget.org 上排名67的最受欢迎的包，当前版本的下载量超过900万次。如果我们可以对其进行基准测试并使其变得更好，我们就可以帮助许多用户。</span></p>
<p><span>　　您可以在 https://github.com/karpinsn/CsvHelper 上拉取我的分支。值得注意的变化是，我添加了一个新的控制台项目（CsvHelper.Benchmarks），我们可以使用它来存储基准测试，添加了 BenchmarkDotNet 包来执行实际的基准测试运行，以及一个简单的 EnumerateRecords 基准测试，它将 CSV 流解析为记录，如下所示。</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> BenchmarkEnumerateRecords
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">int</span> entryCount = <span style="color: rgba(128, 0, 128, 1)">10000</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> MemoryStream stream = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Simple
    {
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span> Id { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span> Name { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    }
    
    [GlobalSetup]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> GlobalSetup()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> streamWriter = <span style="color: rgba(0, 0, 255, 1)">new</span> StreamWriter(<span style="color: rgba(0, 0, 255, 1)">this</span>.stream, <span style="color: rgba(0, 0, 255, 1)">null</span>, -<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> writer = <span style="color: rgba(0, 0, 255, 1)">new</span> CsvWriter(streamWriter, CultureInfo.InvariantCulture, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> random = <span style="color: rgba(0, 0, 255, 1)">new</span> Random(<span style="color: rgba(128, 0, 128, 1)">42</span>); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Pick a known seed to keep things consistent</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> chars = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">char</span>[<span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">];
        </span><span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> getRandomString()
        {
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">10</span>; ++<span style="color: rgba(0, 0, 0, 1)">i)
                chars[i] </span>= (<span style="color: rgba(0, 0, 255, 1)">char</span>)random.Next(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">a</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">z</span><span style="color: rgba(128, 0, 0, 1)">'</span> + <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">(chars);
        }
        writer.WriteHeader(</span><span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(Simple));
        writer.NextRecord();
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; BenchmarkEnumerateRecords.entryCount; ++<span style="color: rgba(0, 0, 0, 1)">i)
        {
            writer.WriteRecord(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Simple()
            {
                Id </span>=<span style="color: rgba(0, 0, 0, 1)"> random.Next(),
                Name </span>=<span style="color: rgba(0, 0, 0, 1)"> getRandomString()
            });
            writer.NextRecord();
        }
    }
    
    [GlobalCleanup]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> GlobalCleanup()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.stream.Dispose();
    }
    
    [Benchmark]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> EnumerateRecords()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.stream.Position = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> streamReader = <span style="color: rgba(0, 0, 255, 1)">new</span> StreamReader(<span style="color: rgba(0, 0, 255, 1)">this</span>.stream, <span style="color: rgba(0, 0, 255, 1)">null</span>, <span style="color: rgba(0, 0, 255, 1)">true</span>, -<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> csv = <span style="color: rgba(0, 0, 255, 1)">new</span> CsvReader(streamReader, CultureInfo.InvariantCulture, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> record <span style="color: rgba(0, 0, 255, 1)">in</span> csv.GetRecords&lt;Simple&gt;<span style="color: rgba(0, 0, 0, 1)">())
        {
            _ </span>=<span style="color: rgba(0, 0, 0, 1)"> record;
        }
    }
}</span></pre>
</div>
<p><span>　　这里有几点需要注意。我们有一个全局设置函数，它创建一个简单的 CSV 流，并将其保存在内存流中。我们在基准测试运行的[GlobalSetup]中这样做，这样它就不会影响基准测试的结果，我们只想对 CSV 文件的实际解析进行基准测试，而不是创建测试数据。</span></p>
<p><span>　　接下来，我们有一个全局清理函数，它可以正确地释放我们的内存流，在添加更多基准测试的情况下，这是一个很好的实践，这样我们就不会持续泄漏内存。</span></p>
<p><span>　　最后，我们的基准测试只是从流中创建一个 CsvReader，然后从中读取每条记录。这将演习 CsvHelper 的解析功能，而这正是我们将要尝试和优化的。</span></p>
<h1><span><span>深入了解基准</span></span></h1>
<p><span>　　从这里，您可以向基准类添加一个 BenchmarkDotNet（BDN）Diagnoser，以便在运行时捕获有关基准的信息。BenchmarkDotNet 附带了一个[MemoryDiagnosers]，它可以捕获内存分配和总体内存使用信息。如果我们添加这个特性并运行基准测试，您应该得到类似的结果：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182120008-821850542.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　从这里可以看到 BDN 提供的正常平均值、误差和标准偏差，以及我们的诊断程序的输出，其中显示我们在基准测试期间分配了1.69 MB 内存，并将其分解为不同的 GC 堆。如果我们想进一步挖掘，然后我们可以包括来自 Nuget.org 的 &nbsp;Microsoft.VisualStudio.DiagnosticsHub.BenchmarkDotNetDiagnosers 包，它将 BenchmarkDotNet 挂到 VisualStudio Profiler 中，这样我们就可以看到在运行期间发生了什么。在包含这个包并将[DotNetAllocDiagnoser]和[DotNetObjectAllocJobConfiguration]添加到基准测试并重新运行后，我们得到：</p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182144559-1602058947.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　最值得注意的是底部的一行，它显示了收集到的诊断文件的路径，这是 Visual Studio Profiler 文件格式的。随着新的更新，它会自动在 VS 中打开，现在我们有了所有需要挖掘的东西，可能会减少一些内存分配。</p>
<h1><span><span>狩猎内存分配</span></span></h1>
<p><span>　　现在我们有了一个详细描述运行中所有内存分配的诊断，让我们看看是否可以减少我们正在进行的内存分配并减少垃圾收集器的负载。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182207961-1928070410.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span>　　由于我们的基准测试被设计为从内存流中反序列化10,000条记录，因此我们希望查找10,000的倍数，因为这表明它正在为每条记录进行分配。我们立即看到 String, Type[]，int32 和 Simple。String 和 Int32 是我们的 Simple 记录类型上的属性这是合理的分配，Simple 是我们反序列化的记录类型这也是合理的分配。Type[] 有点可疑，进一步挖掘事情只会看起来更糟：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182226328-806264047.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span>　　在这种情况下，看起来我们正在为我们反序列化的每条记录分配一个空的 Type[]，每条记录为24字节，在这个基准测试运行中总共分配了7.6MB。在基准测试中，这些无法保存任何数据的垃圾分陪占总内存分配的14%。这太疯狂了，我们应该能解决好的。双击该类型显示了回溯，这表明它来自某个匿名函数：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182240774-861941716.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span>　　转到源代码（右键单击上下文菜单-&gt;Go to Source File），我们看到以下内容：</span></p>
<p><span><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182332019-417570221.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></span></p>
<p>　　对我来说，这个分配的来源并不明显，所以最简单的方法就是在 CreateInstance 调用中添加一个断点，然后在调试器中查看。现在 BDN 在一个单独的进程中运行我们的基准测试，以更好地控制基准测试，所以要调试，我们只需实例化我们的基准测试并自己调用基准测试方法。我们可以这样更新 main：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task Main(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">[] args)
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">_ = BenchmarkRunner.Run&lt;BenchmarkEnumerateRecords&gt;();</span>

    <span style="color: rgba(0, 0, 255, 1)">var</span> benchmarks = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BenchmarkEnumerateRecords();
    benchmarks.GlobalSetup();
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> benchmarks.EnumerateRecords();
    benchmarks.GlobalCleanup();
}</span></pre>
</div>
<p><span>　　在调试器中运行，我们到达分配发生的地方：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182359339-1322858983.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　再一次，它不是特别明显的显示分配发生在哪里，所以让我们进入调用，以防这是来自内联框架：</p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182412657-1749967767.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　该方法有一个 Type 参数，但没有 Type[]。它是一个相对较短的函数，也许它和它的调用者是内联的，所以让我们再次进入。</p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182426032-1747810820.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　不幸的是，还是没有 Type[]，但是这个方法被标记为 AggressiveInlining，这解释了为什么我们没有在分配堆栈中看到它。最后一步，我们得到了 Type[] 分配！</p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182438903-79196483.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　这就是“啊哈时刻”！我们调用 GetArgTypes，它根据传入的 object[] 返回 Type[]。我们首先分配一个与 object[] 大小相同的数组，但如果 object[] 的长度为0，那么我们分配一个新的长度为0的数组。在这种情况下，我们可以很容易地通过检查参数大小和在没有参数可以从中获取类型的情况下尽早返回来解决这个问题。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">[MethodImpl(MethodImplOptions.AggressiveInlining)]
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> Type[] GetArgTypes(<span style="color: rgba(0, 0, 255, 1)">object</span>?<span style="color: rgba(0, 0, 0, 1)">[] args)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (args.Length == <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> Array.Empty&lt;Type&gt;<span style="color: rgba(0, 0, 0, 1)">();
    }
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> argTypes = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Type[args.Length];
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; args.Length; i++<span style="color: rgba(0, 0, 0, 1)">)
    {
        argTypes[i] </span>= args[i]?.GetType() ?? <span style="color: rgba(0, 0, 255, 1)">typeof</span>(<span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)">);
    }
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> argTypes;
}</span></pre>
</div>
<p><span>　　在做了这个更改之后，我们可以重新运行我们的基准测试，这是一个测量/修改/测量的过程，我们得到以下结果：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182452891-739295224.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>　　我们有效地减少了约14%的分配内存！虽然这看起来不是一个巨大的胜利，但这与记录的数量有关。对于具有大量记录的 CSV 文件来说，这是一个巨大的胜利，特别是在一个已经非常快速和大量优化的库中。</p>
<h1><span><span>让我们知道您的想法</span></span></h1>
<p><span>　　总而言之，我们能够在一篇博客文章中对一个真实的项目，添加一个基准测试，使用 Visual Studio 分析器，并做出有意义的贡献。通过创建基准测试套件，可以很容易地隔离您希望通过测量/修改/测量来改进的特定代码，并查看性能优化的影响。我们很想听听您的想法！</span></p>
<p><span>&nbsp;</span></p>
<p><span>原文连接：https://devblogs.microsoft.com/visualstudio/benchmarking-with-visual-studio-profiler/#benchmarking-a-real-project</span></p>
<p><span><img src="https://img2024.cnblogs.com/blog/270073/202501/270073-20250109182513703-788322262.webp" alt="" style="display: block; margin-left: auto; margin-right: auto"></span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <blockquote>
<p><strong>作者：</strong><a href="http://www.cnblogs.com/MeteorSeed">MeteorSeed</a></p>
<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>
<p><strong>转载请注明出处。</strong></p>
</blockquote>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.18334222862384258" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-17 09:56">2025-01-17 09:55</span>&nbsp;
<a href="https://www.cnblogs.com/MeteorSeed">MeteorSeed</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18662695" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18662695);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18662695', targetLink: 'https://www.cnblogs.com/MeteorSeed/p/18662695', title: '【译】使用 Visual Studio Profiler 进行基准测试' })">举报</a>
</div>
        