
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18757481" title="发布于 2025-03-10 16:29">
    <span role="heading" aria-level="2">重生之数据结构与算法----图论</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>图结构本质上还有<code>多叉树的变种</code>,图结构在逻辑上，由于<code>若干个节点和边</code>组成。但在实际落地中，一般用<code>邻接表，邻接矩阵</code>来存储图</p>
<p>在标准的树结构中，一般都是<code>单链表</code>表示，即只允许父节点指向子节点，两个子节点之间也不允许互相指向。<br>
而图中，则是<code>双链表放飞自我版</code>，既可以父子之间互相指向，又可以子节点互相链接，形成复杂的网络结构。</p>
<h2 id="图的逻辑视图">图的逻辑视图</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307125837466-810819671.png" alt="image" loading="lazy"></p>
<p>可以看到一幅图由<code>节点(Vertex)</code>与<code>边(Edge)</code>组成，那么从直觉出发，我们可以认为它的数据结构应该是这个样子的</p>
<pre><code>    public class Vertex
    {
        public int Value { get; set; }
        Vertex[] Neighbors { get; set; }
    }
</code></pre>
<p>可以看到，与多叉树并无区别，所以图在<code>本质上还是树</code>.因此适用于树的DFS/BFS算法同样适用于图</p>
<h3 id="degree">Degree</h3>
<p>图论中有一个独特的概念，叫<code>度(Degree)</code>.<br>
在没有方向的图中，Degree就是每个节点相连边的条数。在有方向的图中，Degree被细分为indegree和outdegree<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307125837466-810819671.png" alt="image" loading="lazy"></p>
<p>比如在此图中，节点3的indegree为3，outdegree为1。节点4的indegree为3，outdegree为0</p>
<h2 id="图的实际视图">图的实际视图</h2>
<p>与上面代码相反的是，图的实际存储方式如下</p>
<h3 id="邻接表">邻接表</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307142628806-1343497118.png" alt="image" loading="lazy"></p>
<p>0号节点存储着它的indegree，【4，3，1】<br>
2号节点存储着它的indegree，【3，2，4】<br>
......</p>
<p>代码结构如下:</p>
<pre><code>//邻接表
//List存节点，Int[]存储相邻节点
List&lt;int[]&gt; grath = new List&lt;int[]&gt;();
</code></pre>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307142453887-309524662.png" alt="image" loading="lazy"></p>
<p>邻接矩阵则是把所有可能的节点都<code>穷举描绘出来</code>，然后再到上面标点。</p>
<p>代码结构如下：</p>
<pre><code>//邻接矩阵
//二维数组
bool[,] matrix = new bool[5,5];
</code></pre>
<blockquote>
<p>为什么会有两种不同存储方式？<br>
因为任何结构都有两个考虑因素，时间与空间。这是一个万能公式。</p>
<ol>
<li>可以直观的看到，邻接矩阵是空间换时间，通过填充整个矩阵,只需要matrix[i,j]就能以O(1)的复杂度实现查找。</li>
<li>而邻接表则是时间换空间,只存储必要的信息，节省了空间，但查找复杂度退化为O(N)</li>
</ol>
</blockquote>
<h1 id="加权图">加权图</h1>
<p>上面介绍的图最基本的结构，是不是很简单？所有的<code>复杂结构</code>都是在简单上一步一步演化的，图也不例外。</p>
<p>那加权图又如何实现呢？回忆我们的套路.<code>算法共一石,空间换时间独占八斗</code>。</p>
<h2 id="邻接表加权">邻接表加权</h2>
<pre><code>//List&lt;int[]&gt; grath = new List&lt;int[]&gt;();

// 空间换时间，加一个字段存权重不就好了？

List&lt;Edge[]&gt; grath = new List&lt;Edge[]&gt;();
public struct Edge
{
	public int Indegree { get; set; }
	public int Weight { get; set; }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307145443328-1633951591.png" alt="image" loading="lazy"></p>
<h2 id="矩阵表加权">矩阵表加权</h2>
<pre><code>//bool[,] matrix = new bool[5,5];

//由bool二维数组切换成int二维数组
//=0 代表没有边，!=0 代表有边且与权重
int[,] matrix = new int[5,5];
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307145924761-986554513.png" alt="image" loading="lazy"></p>
<h1 id="无向图">无向图</h1>
<p>上面我们介绍的，都是有向无权图与有向加权图。那什么是无向图呢？<br>
很简单，<code>无向图=双向图</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307150433441-120924544.png" alt="image" loading="lazy"></p>
<blockquote>
<p>所以你无脑数，有几条边就有几个节点，不再区分indegree,outdegree</p>
</blockquote>
<h1 id="一个简单的图">一个简单的图</h1>
<pre><code>    public interface IGraphSimple
    {
        /// &lt;summary&gt;
        /// 添加一条边
        /// &lt;/summary&gt;
        /// &lt;param name="from"&gt;&lt;/param&gt;
        /// &lt;param name="to"&gt;&lt;/param&gt;
        /// &lt;param name="weight"&gt;&lt;/param&gt;
        void AddEdge(int from, int to, int weight);
        /// &lt;summary&gt;
        /// 删除一条边
        /// &lt;/summary&gt;
        /// &lt;param name="from"&gt;&lt;/param&gt;
        /// &lt;param name="to"&gt;&lt;/param&gt;
        void RemoveEdge(int from, int to);
        /// &lt;summary&gt;
        /// 判断两个节点是否相等
        /// &lt;/summary&gt;
        /// &lt;param name="from"&gt;&lt;/param&gt;
        /// &lt;param name="to"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        bool IsEdge(int from, int to);
        /// &lt;summary&gt;
        /// 返回一条边的权重
        /// &lt;/summary&gt;
        /// &lt;param name="from"&gt;&lt;/param&gt;
        /// &lt;param name="to"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        int? Weight(int from, int to);
        List&lt;Edge&gt; Neighbors(int v);
    }
    public struct Edge
    {
        /// &lt;summary&gt;
        /// 相邻的节点
        /// &lt;/summary&gt;
        public int Indegree { get; set; }
        /// &lt;summary&gt;
        /// 权重
        /// &lt;/summary&gt;
        public int Weight { get; set; }
    }

    /// &lt;summary&gt;
    /// 邻接表实现图
    /// &lt;/summary&gt;
    public class AdjacencySimple : IGraphSimple
    {
        public static void Run()
        {
            var s = new AdjacencySimple(10);
            s.AddEdge(0, 1, 0);
            s.AddEdge(0, 2, 0);

            s.AddEdge(2, 5, 0);
            s.AddEdge(2, 6, 0);

            s.AddEdge(1, 3, 0);
            s.AddEdge(1, 4, 0);

            s.AddEdge(3, 6, 0);
            s.AddEdge(3, 0, 0);

            s.AddEdge(6, 0, 0);


            s.DFSTraverse(0);
        }
        private List&lt;List&lt;Edge&gt;&gt; _graph;
        private bool[] _visited;
        private LinkedList&lt;int&gt; _path=new LinkedList&lt;int&gt;();
        public AdjacencySimple(int capacity)
        {
            //init
            _graph = new List&lt;List&lt;Edge&gt;&gt;(capacity);
            _visited=new bool[capacity];
            for (int i = 0; i &lt; capacity; i++)
            {
                _graph.Add(new List&lt;Edge&gt;());
            }

        }

        public void Add(int from, int to, int weight)
        {
            //如果是无向加权表，就调用此方法
            AddEdge(from, to, weight);
            //多维护一遍关系
            AddEdge(from,to, weight);
        }
        public void AddEdge(int from, int to, int weight)
        {
            var neighbor = new Edge()
            {
                Indegree = to,
                Weight = weight
            };
            _graph[from].Add(neighbor);


        }

        public bool IsEdge(int from, int to)
        {
            foreach (var edge in _graph[from])
            {
                if (edge.Indegree.Equals(to))
                {
                    return true;
                }
            }
            return false;
        }

        public List&lt;Edge&gt; Neighbors(int from)
        {
            return _graph[from];
        }

        public void Remove(int from, int to)
        {
            //如果是无向加权表，就调用此方法
            RemoveEdge(from, to);
            //多维护一遍关系
            RemoveEdge(to, from);
        }
        public void RemoveEdge(int from, int to)
        {
            var neighbors = _graph[from];
            foreach (var edge in neighbors)
            {
                if (edge.Indegree.Equals(to))
                {
                    neighbors.Remove(edge);
                    break;
                }
            }
        }

        public int? Weight(int from, int to)
        {
            var neighbors = _graph[from];
            foreach (var edge in neighbors)
            {
                if (edge.Indegree.Equals(to))
                {
                    return edge.Weight;
                }
            }
            return null;
        }


        public void DFSTraverse(int startIndex)
        {

            if (startIndex &lt; 0 || startIndex &gt;= _graph.Count)
                return;

            
            if (_visited[startIndex])
                return;


            _visited[startIndex] = true;
            //前序遍历
            Console.WriteLine($"index={startIndex}");

            if (_graph[startIndex]?.Count &gt; 0)
            {
                foreach (var item in _graph[startIndex])
                {
                    DFSTraverse(item.Indegree);
                }
            }

            //后序遍历
            //Console.WriteLine($"index={index}");
        }


    }

    /// &lt;summary&gt;
    /// 邻接矩阵实现图
    /// &lt;/summary&gt;
    public class MatrixSimple : IGraphSimple
    {
        private int[,] _matrix;
        private bool[] _visited;
        public static void Run()
        {
            var s = new MatrixSimple(10);
            s.AddEdge(0, 1, 1);
            s.AddEdge(0, 2, 2);

            s.AddEdge(2, 5, 3);
            s.AddEdge(2, 6, 4);

            s.AddEdge(1, 3, 5);
            s.AddEdge(1, 4, 6);

            s.AddEdge(3, 6, 7);
            s.AddEdge(3, 0, 8);

            s.AddEdge(6, 0, 9);


            s.DFSTraverse(0);
        }
        public MatrixSimple(int capacity)
        {
            _matrix = new int[capacity, capacity];
            _visited = new bool[capacity];
        }

        public void Add(int from, int to, int weight)
        {
            //如果是无向加权表，就调用此方法
            AddEdge(from, to, weight);
            //多维护一遍关系
            AddEdge(to, from, weight);
        }
        public void AddEdge(int from, int to, int weight)
        {
            _matrix[from, to] = weight;
        }

        public bool IsEdge(int from, int to)
        {
            return _matrix[from, to] != 0;
        }

        public List&lt;Edge&gt; Neighbors(int from)
        {
            var result=new List&lt;Edge&gt;();

            var columns = _matrix.GetLength(from);

            for (int i = 0; i &lt; columns; i++)
            {
                if (_matrix[columns, i] &gt; 0)
                {
                    result.Add(new Edge { Indegree = i, Weight = _matrix[columns, i] });
                }
            }

            return result;
        }

        public void Remove(int from, int to)
        {
            //如果是无向加权表，就调用此方法
            RemoveEdge(from, to);
            //多维护一遍关系
            RemoveEdge(to, from);
        }
        public void RemoveEdge(int from, int to)
        {
            //0代表未使用
            _matrix[from, to] = 0;
        }

        public int? Weight(int from, int to)
        {
            return _matrix[from, to];
        }

        public void DFSTraverse(int startIndex)
        {
            if (_visited[startIndex])
                return;

            _visited[startIndex] = true;

            //前序遍历
            Console.WriteLine($"index={startIndex}");

            for (int i = 0; i &lt; _visited.Length; i++)
            {
                //为0代表未使用
                if (_matrix[startIndex, i] == 0)
                    continue;

                DFSTraverse(i);
            }

            //后序遍历
            //Console.WriteLine($"index={index}"); 
        }
    }
</code></pre>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.07422492123842593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 16:29">2025-03-10 16:29</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18757481" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18757481);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18757481', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18757481', title: '重生之数据结构与算法----图论' })">举报</a>

		</p>
	