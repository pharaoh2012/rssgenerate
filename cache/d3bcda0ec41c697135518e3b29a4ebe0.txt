
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/19002364" title="发布于 2025-07-28 09:20">
    <span role="heading" aria-level="2">【Redis分布式锁实现】基于 Redis 单节点保姆级教程（Spring Boot 示例）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>下面我将详细介绍基于 Redis 单节点实现分布式锁的原理，并提供一个完整的 Spring Boot 实现示例。</p>
<h2 id="实现原理">实现原理</h2>
<h3 id="核心机制">核心机制</h3>
<ol>
<li>
<p><strong>原子获取锁</strong>：使用 <code>SET key unique_value NX PX milliseconds</code> 命令</p>
<ul>
<li><code>NX</code>：仅当 key 不存在时设置值</li>
<li><code>PX</code>：设置过期时间（毫秒）</li>
<li><code>unique_value</code>：唯一标识客户端（防止误删其他客户端的锁）</li>
</ul>
</li>
<li>
<p><strong>安全释放锁</strong>：使用 Lua 脚本保证原子性</p>
<pre><code class="language-lua">if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
</code></pre>
</li>
<li>
<p><strong>锁续期机制</strong>：可选的看门狗（Watchdog）机制，定期延长锁的有效期</p>
</li>
</ol>
<h3 id="关键特性">关键特性</h3>
<ul>
<li><strong>互斥性</strong>：同一时刻只有一个客户端能持有锁</li>
<li><strong>防死锁</strong>：自动过期机制确保锁最终释放</li>
<li><strong>容错性</strong>：客户端崩溃后锁会自动释放</li>
<li><strong>安全性</strong>：只有锁的持有者才能释放锁</li>
</ul>
<h2 id="spring-boot-实现示例">Spring Boot 实现示例</h2>
<h3 id="1-添加依赖-pomxml">1. 添加依赖 (<code>pom.xml</code>)</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="2-配置-redis-applicationyml">2. 配置 Redis (<code>application.yml</code>)</h3>
<pre><code class="language-yaml">spring:
  redis:
    host: localhost
    port: 6379
    password: 
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
</code></pre>
<h3 id="3-redis-分布式锁工具类">3. Redis 分布式锁工具类</h3>
<pre><code class="language-java">import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

@Component
public class RedisDistributedLock {

    private final RedisTemplate&lt;String, String&gt; redisTemplate;
    
    // 锁键前缀
    private static final String LOCK_PREFIX = "lock:";
    // 解锁Lua脚本
    private static final String UNLOCK_SCRIPT = 
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "   return redis.call('del', KEYS[1]) " +
        "else " +
        "   return 0 " +
        "end";
    // 续期Lua脚本
    private static final String RENEW_SCRIPT = 
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "   return redis.call('pexpire', KEYS[1], ARGV[2]) " +
        "else " +
        "   return 0 " +
        "end";

    public RedisDistributedLock(RedisTemplate&lt;String, String&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 尝试获取分布式锁
     * 
     * @param lockKey    锁的key
     * @param requestId  请求标识（可使用UUID）
     * @param expireTime 锁的过期时间(毫秒)
     * @param waitTime   等待时间(毫秒)
     * @return 是否获取成功
     */
    public boolean tryLock(String lockKey, String requestId, long expireTime, long waitTime) {
        String fullKey = LOCK_PREFIX + lockKey;
        long end = System.currentTimeMillis() + waitTime;
        
        while (System.currentTimeMillis() &lt; end) {
            // 尝试获取锁
            Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(fullKey, requestId, expireTime, TimeUnit.MILLISECONDS);
            
            if (Boolean.TRUE.equals(success)) {
                return true;
            }
            
            // 等待随机时间后重试，避免活锁
            try {
                Thread.sleep(50 + (long) (Math.random() * 100));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        return false;
    }

    /**
     * 释放分布式锁
     * 
     * @param lockKey   锁的key
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public boolean unlock(String lockKey, String requestId) {
        String fullKey = LOCK_PREFIX + lockKey;
        
        // 使用Lua脚本保证原子性
        RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(UNLOCK_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(fullKey), requestId);
        
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 锁续期（看门狗机制）
     * 
     * @param lockKey    锁的key
     * @param requestId  请求标识
     * @param expireTime 新的过期时间(毫秒)
     * @return 是否续期成功
     */
    public boolean renewLock(String lockKey, String requestId, long expireTime) {
        String fullKey = LOCK_PREFIX + lockKey;
        
        // 使用Lua脚本保证原子性
        RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(RENEW_SCRIPT, Long.class);
        Long result = redisTemplate.execute(script, 
            Collections.singletonList(fullKey), 
            requestId, 
            String.valueOf(expireTime));
        
        return result != null &amp;&amp; result == 1;
    }

    /**
     * 获取锁（简化版，带自动续期）
     * 
     * @param lockKey    锁的key
     * @param expireTime 锁的过期时间(毫秒)
     * @param waitTime   等待时间(毫秒)
     * @param task       需要执行的任务
     * @return 任务执行结果
     */
    public &lt;T&gt; T lockAndExecute(String lockKey, long expireTime, long waitTime, LockTask&lt;T&gt; task) {
        String requestId = UUID.randomUUID().toString();
        boolean locked = false;
        
        try {
            // 尝试获取锁
            locked = tryLock(lockKey, requestId, expireTime, waitTime);
            
            if (!locked) {
                throw new RuntimeException("获取分布式锁失败");
            }
            
            // 启动看门狗线程定期续期
            WatchDog watchDog = new WatchDog(lockKey, requestId, expireTime);
            watchDog.start();
            
            try {
                // 执行业务逻辑
                return task.execute();
            } finally {
                // 停止看门狗
                watchDog.stop();
            }
        } finally {
            // 确保锁被释放
            if (locked) {
                unlock(lockKey, requestId);
            }
        }
    }

    // 看门狗线程实现
    private class WatchDog {
        private final String lockKey;
        private final String requestId;
        private final long expireTime;
        private volatile boolean running = true;
        private Thread thread;

        public WatchDog(String lockKey, String requestId, long expireTime) {
            this.lockKey = lockKey;
            this.requestId = requestId;
            this.expireTime = expireTime;
        }

        public void start() {
            thread = new Thread(() -&gt; {
                // 在过期时间的1/3时进行续期
                long sleepTime = expireTime / 3;
                
                while (running) {
                    try {
                        Thread.sleep(sleepTime);
                        if (!renewLock(lockKey, requestId, expireTime)) {
                            // 续期失败，可能是锁已被释放或过期
                            break;
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }, "RedisLock-WatchDog");
            thread.setDaemon(true);
            thread.start();
        }

        public void stop() {
            running = false;
            if (thread != null) {
                thread.interrupt();
            }
        }
    }

    // 锁任务接口
    @FunctionalInterface
    public interface LockTask&lt;T&gt; {
        T execute();
    }
}
</code></pre>
<h3 id="4-业务服务中使用分布式锁">4. 业务服务中使用分布式锁</h3>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final RedisDistributedLock redisLock;
    
    public OrderService(RedisDistributedLock redisLock) {
        this.redisLock = redisLock;
    }
    
    /**
     * 创建订单（使用分布式锁保护）
     */
    public void createOrder(String orderId) {
        // 使用锁执行关键操作
        redisLock.lockAndExecute("order_create:" + orderId, 30000, 5000, () -&gt; {
            // 在这里执行需要加锁的业务逻辑
            try {
                // 1. 检查订单是否已存在
                if (checkOrderExists(orderId)) {
                    throw new RuntimeException("订单已存在");
                }
                
                // 2. 执行创建订单的核心业务
                processOrderCreation(orderId);
                
                // 3. 记录订单日志
                logOrderCreation(orderId);
                
                return null;
            } catch (Exception e) {
                throw new RuntimeException("订单创建失败", e);
            }
        });
    }
    
    private boolean checkOrderExists(String orderId) {
        // 实际业务逻辑
        return false;
    }
    
    private void processOrderCreation(String orderId) {
        // 实际业务逻辑
        System.out.println("处理订单创建: " + orderId);
        // 模拟耗时操作
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void logOrderCreation(String orderId) {
        // 实际业务逻辑
        System.out.println("记录订单日志: " + orderId);
    }
}
</code></pre>
<h3 id="5-控制器示例">5. 控制器示例</h3>
<pre><code class="language-java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @GetMapping("/order/{orderId}")
    public String createOrder(@PathVariable String orderId) {
        try {
            orderService.createOrder(orderId);
            return "订单创建成功: " + orderId;
        } catch (Exception e) {
            return "订单创建失败: " + e.getMessage();
        }
    }
}
</code></pre>
<h2 id="关键注意事项">关键注意事项</h2>
<ol>
<li>
<p><strong>锁过期时间</strong>：</p>
<ul>
<li>设置合理的时间（略大于业务执行时间）</li>
<li>过短：业务未完成锁已释放 → 数据不一致</li>
<li>过长：客户端崩溃后锁释放延迟 → 系统可用性降低</li>
</ul>
</li>
<li>
<p><strong>唯一标识（requestId）</strong>：</p>
<ul>
<li>必须保证全局唯一（使用UUID）</li>
<li>确保只有锁的持有者才能释放锁</li>
</ul>
</li>
<li>
<p><strong>看门狗机制</strong>：</p>
<ul>
<li>解决业务执行时间超过锁过期时间的问题</li>
<li>定期续期（建议在1/3过期时间时续期）</li>
<li>业务完成后立即停止看门狗</li>
</ul>
</li>
<li>
<p><strong>异常处理</strong>：</p>
<ul>
<li>使用try-finally确保锁最终被释放</li>
<li>避免因异常导致锁无法释放</li>
</ul>
</li>
<li>
<p><strong>重试机制</strong>：</p>
<ul>
<li>设置合理的等待时间和重试策略</li>
<li>使用随机退避避免活锁</li>
</ul>
</li>
</ol>
<h2 id="潜在缺陷及解决方案">潜在缺陷及解决方案</h2>
<table>
<thead>
<tr>
<th>缺陷</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁提前过期</strong></td>
<td>实现看门狗续期机制</td>
</tr>
<tr>
<td><strong>非原子操作风险</strong></td>
<td>使用Lua脚本保证原子性</td>
</tr>
<tr>
<td><strong>单点故障</strong></td>
<td>主从复制（但有数据丢失风险）或改用RedLock</td>
</tr>
<tr>
<td><strong>GC暂停导致锁失效</strong></td>
<td>优化JVM参数，减少GC暂停时间</td>
</tr>
<tr>
<td><strong>时钟漂移问题</strong></td>
<td>使用NTP同步时间，监控时钟差异</td>
</tr>
<tr>
<td><strong>锁被误删</strong></td>
<td>使用唯一标识验证锁持有者</td>
</tr>
</tbody>
</table>
<h2 id="最佳实践建议">最佳实践建议</h2>
<ol>
<li><strong>锁粒度</strong>：尽量使用细粒度锁（如订单ID而非整个系统锁）</li>
<li><strong>超时设置</strong>：根据业务压力动态调整锁超时时间</li>
<li><strong>监控报警</strong>：监控锁等待时间、获取失败率等关键指标</li>
<li><strong>熔断机制</strong>：当Redis不可用时提供降级方案</li>
<li><strong>压力测试</strong>：模拟高并发场景验证锁的正确性</li>
<li><strong>避免长时间持锁</strong>：优化业务逻辑减少锁持有时间</li>
</ol>
<p>这个实现提供了生产环境中使用Redis分布式锁的完整解决方案，包含了基本的锁获取/释放、看门狗续期机制、以及易用的API封装。在实际使用中，可以根据具体业务需求调整参数和实现细节。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008333333333333333" data-date-updated="2025-07-28 09:32">2025-07-28 09:20</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">43</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19002364);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19002364', targetLink: 'https://www.cnblogs.com/sun-10387834/p/19002364', title: '【Redis分布式锁实现】基于 Redis 单节点保姆级教程（Spring Boot 示例）' })">举报</a>
</div>
        