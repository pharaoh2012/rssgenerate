
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18992795" title="发布于 2025-07-19 13:28">
    <span role="heading" aria-level="2">【Spring三级缓存解密】如何优雅解决循环依赖难题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>在Spring框架的日常开发中，循环依赖问题如同一个幽灵，时不时困扰着开发者。当Bean A依赖Bean B，而Bean B又依赖Bean A时，传统的创建流程会陷入死锁。本文将深入剖析Spring如何通过三级缓存机制破解这一难题，揭示其背后的设计智慧。</p>
<h2 id="一循环依赖的本质问题">一、循环依赖的本质问题</h2>
<p>循环依赖的根源在于对象创建的<strong>顺序性矛盾</strong>：</p>
<pre><code class="language-java">@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB; // 需要ServiceB实例
}

@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // 需要ServiceA实例
}
</code></pre>
<p>这种"鸡生蛋还是蛋生鸡"的问题，传统创建流程无法解决。</p>
<h2 id="二三级缓存机制全景解析">二、三级缓存机制全景解析</h2>
<p>Spring通过三级缓存架构破解循环依赖：</p>
<div class="mermaid">classDiagram
    class DefaultSingletonBeanRegistry {
        -singletonObjects: Map~String, Object~       // 一级缓存：成品Bean
        -earlySingletonObjects: Map~String, Object~  // 二级缓存：半成品（早期引用）
        -singletonFactories: Map~String, ObjectFactory~ // 三级缓存：对象工厂
    }
</div><h3 id="各级缓存的核心职责">各级缓存的核心职责</h3>
<table>
<thead>
<tr>
<th>缓存级别</th>
<th>存储内容</th>
<th>生命周期</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>一级缓存</td>
<td>完全初始化的Bean</td>
<td>应用生命周期</td>
<td>提供最终产品</td>
</tr>
<tr>
<td>二级缓存</td>
<td>早期引用（半成品）</td>
<td>被依赖→初始化完成</td>
<td>临时周转</td>
</tr>
<tr>
<td>三级缓存</td>
<td>ObjectFactory对象</td>
<td>实例化→被依赖/初始化完成</td>
<td>延迟生成早期引用</td>
</tr>
</tbody>
</table>
<h2 id="三破解循环依赖的全流程">三、破解循环依赖的全流程</h2>
<p>以经典的A→B→A依赖链为例：</p>
<div class="mermaid">sequenceDiagram
    participant C as 容器
    participant L3 as 三级缓存
    participant L2 as 二级缓存
    participant A as BeanA
    participant B as BeanB
    
    Note over C: 创建BeanA
    C-&gt;&gt;A: 1. 实例化(分配内存)
    C-&gt;&gt;L3: 2. 添加ObjectFactory_A
    C-&gt;&gt;A: 3. 属性注入(发现需要B)
    
    Note over C: 转向创建B
    C-&gt;&gt;B: 4. 实例化
    C-&gt;&gt;L3: 5. 添加ObjectFactory_B
    C-&gt;&gt;B: 6. 属性注入(发现需要A)
    
    B-&gt;&gt;L3: 7. 请求获取A
    L3-&gt;&gt;L3: 8. 调用ObjectFactory_A.getObject()
    L3-&gt;&gt;L3: 9. 执行getEarlyBeanReference()
    alt 需要代理
        L3-&gt;&gt;L3: 10. 创建代理对象Proxy_A
    else 无需代理
        L3-&gt;&gt;L3: 10. 保留原始对象
    end
    L3-&gt;&gt;L2: 11. 存入早期引用
    L3-&gt;&gt;L3: 12. 移除ObjectFactory_A
    L3-&gt;&gt;B: 13. 返回A的早期引用
    
    C-&gt;&gt;B: 14. 完成B的初始化
    C-&gt;&gt;L1: 15. B成品放入一级缓存
    C-&gt;&gt;L3: 16. 移除ObjectFactory_B
    
    C-&gt;&gt;A: 17. 注入B(已就绪)
    C-&gt;&gt;A: 18. 完成A初始化
    C-&gt;&gt;L1: 19. A成品放入一级缓存
    C-&gt;&gt;L2: 20. 移除A的早期引用
</div><h3 id="关键步骤解析">关键步骤解析</h3>
<ol>
<li>
<p><strong>三级缓存注册</strong>（步骤2/5）：</p>
<pre><code class="language-java">// 实例化后立即注册
addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, bean));
</code></pre>
</li>
<li>
<p><strong>早期引用生成</strong>（步骤9-11）：</p>
<pre><code class="language-java">protected Object getEarlyBeanReference(String beanName, Object bean) {
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
            // 动态决策是否创建代理
            bean = ((SmartInstantiationAwareBeanPostProcessor) bp)
                       .getEarlyBeanReference(bean, beanName);
        }
    }
    return bean;
}
</code></pre>
</li>
<li>
<p><strong>缓存状态转移</strong>（步骤12/16/20）：</p>
<ul>
<li>被依赖后从三级缓存删除</li>
<li>初始化完成后从二级缓存删除</li>
<li>最终成品存于一级缓存</li>
</ul>
</li>
</ol>
<h2 id="四三级缓存的设计精妙之处">四、三级缓存的设计精妙之处</h2>
<h3 id="1-双重延迟决策机制">1. 双重延迟决策机制</h3>
<pre><code class="language-java">public Object getEarlyBeanReference() {
    // 延迟点1：只在被依赖时触发
    // 延迟点2：动态决定是否创建代理
    return (needsProxy ? createProxy(bean) : bean); 
}
</code></pre>
<p><strong>优势</strong>：避免为不需要代理或未发生循环依赖的Bean创建额外对象</p>
<h3 id="2-状态完整性保障">2. 状态完整性保障</h3>
<div class="mermaid">graph TD
    A[属性注入完成] --&gt; B[创建早期引用]
    B --&gt; C[代理可安全使用属性值]
</div><p>当创建代理时，Bean已通过<code>populateBean()</code>完成属性注入，避免NPE风险</p>
<h3 id="3-对象版本统一性">3. 对象版本统一性</h3>
<pre><code class="language-java">// 最终代理一致性保证
public void initializeBean() {
    if (earlyProxyReference != null) {
        return earlyProxyReference; // 复用已创建的代理
    }
    return createProxy(bean); // 无循环依赖时创建
}
</code></pre>
<h3 id="4-资源高效利用">4. 资源高效利用</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>传统方案</th>
<th>三级缓存方案</th>
<th>性能提升</th>
</tr>
</thead>
<tbody>
<tr>
<td>无循环依赖</td>
<td>创建所有代理</td>
<td>不创建代理</td>
<td>节省90%内存</td>
</tr>
<tr>
<td>有循环依赖无代理</td>
<td>创建半成品副本</td>
<td>直接使用原始对象</td>
<td>减少对象创建</td>
</tr>
<tr>
<td>有循环依赖需代理</td>
<td>可能创建多个代理</td>
<td>单例代理</td>
<td>避免代理冲突</td>
</tr>
</tbody>
</table>
<h2 id="五疑难场景解决方案">五、疑难场景解决方案</h2>
<h3 id="1-代理对象循环依赖">1. 代理对象循环依赖</h3>
<pre><code class="language-java">@Service
public class UserService {
    @Autowired 
    private OrderService orderService;
    
    @Transactional // 需要代理
    public void createUser() {...}
}
</code></pre>
<p><strong>解决方案</strong>：</p>
<ul>
<li>在<code>getEarlyBeanReference()</code>中创建代理</li>
<li>保证代理对象基于完成属性注入的状态</li>
</ul>
<h3 id="2-多级循环依赖">2. 多级循环依赖</h3>
<p>A→B→C→A依赖链：</p>
<div class="mermaid">graph LR
    A--&gt;B
    B--&gt;C
    C--&gt;A
</div><p><strong>处理流程</strong>：</p>
<ol>
<li>C获取A时触发三级缓存</li>
<li>返回A的早期引用</li>
<li>C完成初始化</li>
<li>B获得C的引用</li>
<li>A最终获得B的引用</li>
</ol>
<h3 id="3-无法解决的场景">3. 无法解决的场景</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造器循环依赖</td>
<td>对象未实例化完成，无法暴露引用</td>
</tr>
<tr>
<td>原型(Prototype)作用域</td>
<td>Spring不缓存原型Bean</td>
</tr>
<tr>
<td>@Async方法</td>
<td>代理生成时机与标准AOP不同</td>
</tr>
</tbody>
</table>
<h2 id="六性能优化建议">六、性能优化建议</h2>
<ol>
<li>
<p><strong>避免循环依赖</strong>：重构设计，引入事件机制</p>
<pre><code class="language-java">// 使用事件解耦
applicationContext.publishEvent(new UserCreatedEvent(user));
</code></pre>
</li>
<li>
<p><strong>懒加载优化</strong>：</p>
<pre><code class="language-java">@Lazy
@Autowired
private HeavyService heavyService; // 延迟初始化
</code></pre>
</li>
<li>
<p><strong>作用域控制</strong>：</p>
<pre><code class="language-java">@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {...}
</code></pre>
</li>
</ol>
<h2 id="结论">结论</h2>
<p>Spring的三级缓存机制通过以下创新设计解决循环依赖：</p>
<ol>
<li><strong>空间换时间</strong>：通过三级缓存状态管理打破创建顺序限制</li>
<li><strong>延迟决策</strong>：在被依赖时才决定是否创建代理</li>
<li><strong>状态保障</strong>：确保代理对象基于完整初始化状态</li>
<li><strong>资源优化</strong>：避免不必要的对象创建</li>
</ol>
<p>理解三级缓存不仅帮助解决循环依赖异常，更是深入掌握Spring框架设计思想的钥匙。正如Spring框架创始人Rod Johnson所说："好的框架设计是在约束与灵活性之间找到完美平衡"，三级缓存正是这种平衡的艺术体现。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-19 13:29">2025-07-19 13:28</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">74</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18992795);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18992795', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18992795', title: '【Spring三级缓存解密】如何优雅解决循环依赖难题' })">举报</a>
</div>
        