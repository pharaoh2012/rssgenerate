
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/damaoa/p/18983540" title="发布于 2025-07-14 10:42">
    <span role="heading" aria-level="2">Java锁这样用，从单机到分布式一步到位</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="java锁这样用从单机到分布式一步到位">Java锁这样用，从单机到分布式一步到位</h1>
<blockquote>
<p>单机锁已经不够用了？分布式系统中如何保证数据安全？今天我们来聊聊从单机锁到分布式锁的完整解决方案，最后用一个注解就能搞定所有锁的问题！</p>
</blockquote>
<h2 id="为什么需要锁">为什么需要锁？</h2>
<p>在多线程或多进程环境中，多个操作同时访问同一资源时可能出现数据不一致的问题。锁就是用来保证同一时间只有一个操作能访问共享资源。</p>
<p><strong>锁的作用：</strong></p>
<ul>
<li>保证数据一致性</li>
<li>防止并发冲突</li>
<li>确保操作的原子性</li>
</ul>
<p><strong>简单理解：</strong> 就像厕所门上的锁，同一时间只能有一个人使用，其他人必须等待。</p>
<h2 id="单机锁的局限性">单机锁的局限性</h2>
<h3 id="synchronized关键字">synchronized关键字</h3>
<p>Java最简单的锁机制。</p>
<pre><code class="language-java">public class CounterService {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}
</code></pre>
<h3 id="reentrantlock可重入锁">ReentrantLock可重入锁</h3>
<p>更灵活的锁机制。</p>
<pre><code class="language-java">public class CounterService {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p><strong>单机锁的问题：</strong></p>
<ul>
<li>只能在单个JVM内生效</li>
<li>多个服务实例之间无法互斥</li>
<li>分布式环境下失效</li>
</ul>
<h2 id="分布式环境的挑战">分布式环境的挑战</h2>
<p>当应用部署在多台服务器上时，单机锁就不够用了。</p>
<p><img src="https://img2024.cnblogs.com/blog/1826646/202507/1826646-20250714104107580-1340198113.png" alt="image" loading="lazy"></p>
<p><strong>分布式环境下的问题：</strong></p>
<ul>
<li>多个服务实例可能同时执行相同操作</li>
<li>库存扣减、订单生成等场景容易出现数据不一致</li>
<li>需要跨JVM的锁机制</li>
</ul>
<h2 id="基于redis的分布式锁">基于Redis的分布式锁</h2>
<h3 id="简单的redis分布式锁">简单的Redis分布式锁</h3>
<p>使用Redis的SET命令实现。</p>
<pre><code class="language-java">@Component
public class SimpleRedisLock {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    public boolean tryLock(String key, String value, long expireTime) {
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(key, value, expireTime, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(result);
    }
    
    public void releaseLock(String key, String value) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) else return 0 end";
        redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Long.class), 
                            Arrays.asList(key), value);
    }
}
</code></pre>
<h3 id="使用示例">使用示例</h3>
<pre><code class="language-java">@Service
public class OrderService {
    
    @Autowired
    private SimpleRedisLock redisLock;
    
    public void createOrder(Long userId) {
        String lockKey = "order:user:" + userId;
        String lockValue = UUID.randomUUID().toString();
        
        if (redisLock.tryLock(lockKey, lockValue, 30)) {
            try {
                // 执行订单创建逻辑
                doCreateOrder(userId);
            } finally {
                redisLock.releaseLock(lockKey, lockValue);
            }
        } else {
            throw new RuntimeException("获取锁失败，请稍后重试");
        }
    }
    
    private void doCreateOrder(Long userId) {
        // 具体的订单创建逻辑
    }
}
</code></pre>
<h2 id="基于redisson的分布式锁">基于Redisson的分布式锁</h2>
<p>Redisson提供了更完善的分布式锁实现。</p>
<h3 id="引入依赖">引入依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.20.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置redisson">配置Redisson</h3>
<pre><code class="language-java">@Configuration
public class RedissonConfig {
    
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://localhost:6379")
              .setDatabase(0);
        return Redisson.create(config);
    }
}
</code></pre>
<h3 id="使用redisson锁">使用Redisson锁</h3>
<pre><code class="language-java">@Service
public class OrderService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    public void createOrder(Long userId) {
        String lockKey = "order:user:" + userId;
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
                // 执行订单创建逻辑
                doCreateOrder(userId);
            } else {
                throw new RuntimeException("获取锁失败，请稍后重试");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("获取锁被中断");
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
</code></pre>
<p><strong>Redisson的优势：</strong></p>
<ul>
<li>自动续期机制</li>
<li>可重入锁支持</li>
<li>公平锁、读写锁等多种锁类型</li>
<li>异常处理更完善</li>
</ul>
<h2 id="注解式分布式锁工具">注解式分布式锁工具</h2>
<p>手动加锁解锁容易出错，我们可以通过注解来简化使用。</p>
<h3 id="自定义锁注解">自定义锁注解</h3>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DistributedLock {
    
    String key() default "";
    
    long waitTime() default 10;
    
    long leaseTime() default 30;
    
    TimeUnit timeUnit() default TimeUnit.SECONDS;
    
    String errorMessage() default "获取锁失败，请稍后重试";
}
</code></pre>
<h3 id="aop切面实现">AOP切面实现</h3>
<pre><code class="language-java">@Aspect
@Component
public class DistributedLockAspect {
    
    @Autowired
    private RedissonClient redissonClient;
    
    @Around("@annotation(distributedLock)")
    public Object around(ProceedingJoinPoint joinPoint, DistributedLock distributedLock) throws Throwable {
        String lockKey = generateLockKey(joinPoint, distributedLock.key());
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            boolean acquired = lock.tryLock(
                distributedLock.waitTime(), 
                distributedLock.leaseTime(), 
                distributedLock.timeUnit()
            );
            
            if (!acquired) {
                throw new RuntimeException(distributedLock.errorMessage());
            }
            
            return joinPoint.proceed();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("获取锁被中断");
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
    
    private String generateLockKey(ProceedingJoinPoint joinPoint, String key) {
        if (StringUtils.hasText(key)) {
            return parseKey(key, joinPoint);
        }
        
        String className = joinPoint.getTarget().getClass().getSimpleName();
        String methodName = joinPoint.getSignature().getName();
        return className + ":" + methodName;
    }
    
    private String parseKey(String key, ProceedingJoinPoint joinPoint) {
        if (key.contains("#")) {
            // 支持SpEL表达式解析参数
            return parseSpEL(key, joinPoint);
        }
        return key;
    }
    
    private String parseSpEL(String key, ProceedingJoinPoint joinPoint) {
        // SpEL表达式解析实现
        // 这里简化处理，实际项目中可以使用Spring的SpEL解析器
        return key.replace("#userId", String.valueOf(joinPoint.getArgs()[0]));
    }
}
</code></pre>
<h3 id="使用注解式分布式锁">使用注解式分布式锁</h3>
<pre><code class="language-java">@Service
public class OrderService {
    
    @DistributedLock(key = "order:user:#userId", waitTime = 5, leaseTime = 30)
    public void createOrder(Long userId) {
        // 方法执行时自动加锁
        doCreateOrder(userId);
        // 方法执行完成后自动释放锁
    }
    
    @DistributedLock(key = "inventory:product:#productId")
    public void decreaseInventory(Long productId, Integer quantity) {
        // 库存扣减逻辑
        doDecreaseInventory(productId, quantity);
    }
    
    private void doCreateOrder(Long userId) {
        // 具体的订单创建逻辑
    }
    
    private void doDecreaseInventory(Long productId, Integer quantity) {
        // 具体的库存扣减逻辑
    }
}
</code></pre>
<h2 id="分布式锁的注意事项">分布式锁的注意事项</h2>
<h3 id="1-锁超时时间设置">1. 锁超时时间设置</h3>
<p>锁的超时时间要根据业务执行时间合理设置。</p>
<pre><code class="language-java">// 根据业务复杂度设置合适的超时时间
@DistributedLock(key = "complex:task:#taskId", leaseTime = 60) // 复杂任务60秒
public void executeComplexTask(String taskId) {
    // 复杂业务逻辑
}

@DistributedLock(key = "simple:task:#taskId", leaseTime = 10) // 简单任务10秒
public void executeSimpleTask(String taskId) {
    // 简单业务逻辑
}
</code></pre>
<h3 id="2-锁的粒度控制">2. 锁的粒度控制</h3>
<p>锁的粒度要合适，既要保证安全性，又要避免性能问题。</p>
<pre><code class="language-java">// 细粒度锁 - 针对具体用户
@DistributedLock(key = "user:operation:#userId")
public void userOperation(Long userId) {
    // 只锁定特定用户的操作
}

// 粗粒度锁 - 全局锁（慎用）
@DistributedLock(key = "global:operation")
public void globalOperation() {
    // 全局操作，会影响所有用户
}
</code></pre>
<h3 id="3-异常处理">3. 异常处理</h3>
<p>确保在异常情况下锁能正确释放。</p>
<pre><code class="language-java">@DistributedLock(key = "order:#orderId", errorMessage = "订单正在处理中，请勿重复操作")
public void processOrder(Long orderId) {
    try {
        // 业务逻辑
        doProcessOrder(orderId);
    } catch (Exception e) {
        // 记录日志
        log.error("订单处理失败: {}", orderId, e);
        throw e; // 重新抛出异常，确保事务回滚
    }
    // 锁会在方法结束时自动释放
}
</code></pre>
<h2 id="性能优化建议">性能优化建议</h2>
<h3 id="1-连接池配置">1. 连接池配置</h3>
<pre><code class="language-java">@Configuration
public class RedissonConfig {
    
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://localhost:6379")
              .setConnectionPoolSize(50)    // 连接池大小
              .setConnectionMinimumIdleSize(10); // 最小空闲连接
        return Redisson.create(config);
    }
}
</code></pre>
<h3 id="2-锁等待策略">2. 锁等待策略</h3>
<pre><code class="language-java">// 快速失败策略
@DistributedLock(key = "quick:#id", waitTime = 0)
public void quickOperation(String id) {
    // 不等待，立即返回
}

// 适度等待策略
@DistributedLock(key = "normal:#id", waitTime = 3)
public void normalOperation(String id) {
    // 等待3秒
}
</code></pre>
<h2 id="总结">总结</h2>
<p>Java锁的演进过程：</p>
<p><strong>单机锁：</strong></p>
<ul>
<li>synchronized、ReentrantLock</li>
<li>只能在单个JVM内使用</li>
</ul>
<p><strong>分布式锁：</strong></p>
<ul>
<li>基于Redis实现</li>
<li>支持跨JVM协调</li>
</ul>
<p><strong>注解式分布式锁：</strong></p>
<ul>
<li>使用简单，一个注解搞定</li>
<li>减少重复代码，降低出错概率</li>
</ul>
<p><strong>选择建议：</strong></p>
<ul>
<li>单机应用：使用synchronized或ReentrantLock</li>
<li>分布式应用：使用Redisson分布式锁</li>
<li>追求简洁：使用注解式分布式锁</li>
</ul>
<p>掌握这套锁的升级方案，让你的应用在任何环境下都能保证数据安全！</p>
<hr>
<p><strong>如果这篇文章对你有帮助，请不要忘记：</strong></p>
<ul>
<li>👍 <strong>点赞</strong>支持一下</li>
<li>🔔 <strong>关注</strong>我，获取更多Java技术干货</li>
<li>⭐ <strong>推荐</strong>给你的朋友同事</li>
</ul>
<blockquote>
<p>关注微信公众号【划水的程序猿】，专注于Java技术分享。让我们一起在技术的海洋中成长！</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1826646/202507/1826646-20250714104228006-2128695892.jpg" alt="qrcode_for_gh_f4013377461f_258" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-14 10:43">2025-07-14 10:42</span>&nbsp;
<a href="https://www.cnblogs.com/damaoa">大毛啊</a>&nbsp;
阅读(<span id="post_view_count">19</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18983540);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18983540', targetLink: 'https://www.cnblogs.com/damaoa/p/18983540', title: 'Java锁这样用，从单机到分布式一步到位' })">举报</a>
</div>
        