
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lindexi/p/18687046" title="发布于 2025-01-23 07:23">
    <span role="heading" aria-level="2">dotnet 使用 ColorCode 做代码着色器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文记录我使用 ColorCode 开源库简单做一个代码着色器
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">



<p>开源库地址： <a href="https://github.com/CommunityToolkit/ColorCode-Universal" target="_blank" rel="noopener nofollow">https://github.com/CommunityToolkit/ColorCode-Universal</a></p>
<p>我用的是 ColorCode.Core 版本，这个版本是无具体 UI 框架依赖的，于是我就在此基础上，同时做了 WPF 和 Avalonia 框架的版本。这两个框架在对 ColorCode 的使用上近乎毫无差别，大家可以在本文末尾找到本文所有代码的下载方法，下载本文的代码了解两个框架的差异</p>
<p>以下为 WPF 版本的效果图</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202501/1080237-20250123072301929-1070726439.png" alt="" loading="lazy"></p>
<p>以下为 Avalonia 版本的效果图</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202501/1080237-20250123072302530-646328918.png" alt="" loading="lazy"></p>
<p>以下是具体的测试逻辑。由于 WPF 和 Avalonia 版本代码几乎没有差别，我这里就使用 WPF 为例子进行演示，完全的代码还请到本文末尾找到下载方法</p>
<p>以下是我编写的一段用来做测试的 C# 测试代码</p>
<pre><code class="language-csharp">        var code = """
                   using System;

                   namespace NemficubehayWaybakiwerwhaw.Desktop;

                   class Program
                   {
                       public static void Main(string[] args)
                       {
                           Console.WriteLine("Hello, World!");
                       }
                   }
                   """;
</code></pre>
<p>咱接下来将对此代码进行着色</p>
<p>编写一个名为 TextEditorCodeColorizer 的类型，让此类型继承 CodeColorizerBase 类型。在此类型里面重写 Write 方法</p>
<pre><code class="language-csharp">class TextEditorCodeColorizer : CodeColorizerBase
{
    protected override void Write(string parsedSourceCode, IList&lt;Scope&gt; scopes)
    {
        ... // 忽略其他代码
    }
</code></pre>
<p>为了能够进行承载着色的代码，我这里使用了之前编写的简单文本库。将其设置进入 TextEditorCodeColorizer 的构造函数，代码如下</p>
<pre><code class="language-csharp">class TextEditorCodeColorizer : CodeColorizerBase
{
    public TextEditorCodeColorizer(TextEditor textEditor, StyleDictionary styles, ILanguageParser languageParser) : base(styles, languageParser)
    {
        _textEditor = textEditor;
    }

    private readonly TextEditor _textEditor;
}
</code></pre>
<p>对于使用方来说，创建 TextEditorCodeColorizer 的代码如下</p>
<pre><code class="language-csharp">        ILanguage language = Languages.CSharp;
        var textEditorCodeColorizer = new TextEditorCodeColorizer(TextEditor, null, null);
</code></pre>
<p>是的，构造函数的 StyleDictionary 和 ILanguageParser 都传空即可，这个库没有很好处理可空问题</p>
<p>再编写 FormatInlines 方法，让此方法作为接收输入方，代码如下</p>
<pre><code class="language-csharp">class TextEditorCodeColorizer : CodeColorizerBase
{
    public void FormatInlines(string sourceCode, ILanguage language)
    {
        _textEditor.TextEditorCore.Remove(_textEditor.TextEditorCore.GetAllDocumentSelection());

        languageParser.Parse(sourceCode, language, (parsedSourceCode, captures) =&gt; Write(parsedSourceCode, captures));
    }
}
</code></pre>
<p>具体的调用方法如下</p>
<pre><code class="language-csharp">        ILanguage language = Languages.CSharp;
        var textEditorCodeColorizer = new TextEditorCodeColorizer(TextEditor, null, null);
        textEditorCodeColorizer.FormatInlines(code, language);
</code></pre>
<p>在 <code>protected override void Write(string parsedSourceCode, IList&lt;Scope&gt; scopes)</code> 方法里面根据 Scope 决定使用什么颜色，代码如下</p>
<pre><code class="language-csharp">    protected override void Write(string parsedSourceCode, IList&lt;Scope&gt; scopes)
    {
        SolidColorBrush colorBrush = Brushes.Black;

        if (scopes.Count &gt; 0)
        {
            var name = scopes[0].Name;
            if (name == "Keyword")
            {
                colorBrush = Brushes.Blue;
            }
            else if (name == "String")
            {
                colorBrush = BrushCreator.CreateFromARGB(0xFFD69D7F);
            }
            else if (name == "Number")
            {
                colorBrush = BrushCreator.CreateFromARGB(0xFFADCDA8);
            }
            else
            {

            }
        }

        var runProperty = ((RunProperty) _textEditor.CurrentCaretRunProperty) with
        {
            Foreground = new ImmutableBrush(colorBrush)
        };
        _textEditor.AppendRun(new TextRun(parsedSourceCode, runProperty));
    }
</code></pre>
<p>以上的 BrushCreator 的实现如下</p>
<pre><code class="language-csharp">public static class BrushCreator
{
    public static SolidColorBrush CreateFromARGB(uint argbHex)
    {
        byte a = (byte) ((argbHex &amp; 0xFF000000) &gt;&gt; 24);
        byte r = (byte) ((argbHex &amp; 0x00FF0000) &gt;&gt; 16);
        byte g = (byte) ((argbHex &amp; 0x0000FF00) &gt;&gt; 8);
        byte b = (byte) (argbHex &amp; 0x000000FF);
        var brush = new SolidColorBrush(Color.FromArgb(a, r, g, b));
        return brush;
    }
}
</code></pre>
<p>在 Avalonia 版本里面，直接使用 Skia 作为绘制底层，使用 SKColor.Parse 进行转换颜色字符串，就不需要和 WPF 一样有额外的 BrushCreator 方法，代码如下</p>
<pre><code class="language-csharp">    protected override void Write(string parsedSourceCode, IList&lt;Scope&gt; scopes)
    {
        SKColor color = SKColors.Black;

        if (scopes.Count &gt; 0)
        {
            var name = scopes[0].Name;
            if (name == "Keyword")
            {
                color = SKColors.Blue;
            }
            else if(name == "String")
            {
                color = SKColor.Parse("D69D7F");
            }
            else if(name == "Number")
            {
                color = SKColor.Parse("ADCDA8");
            }
            else
            {
                
            }
        }

        _textEditor.AppendRun(new SkiaTextRun(parsedSourceCode, _textEditor.CurrentCaretRunProperty with
        {
            Foreground = color
        }));
    }
</code></pre>
<p>本文代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/5ba7a51c4f77e516eca886192fbbea4fe90d4a4f/AvaloniaIDemo/NemficubehayWaybakiwerwhaw" target="_blank" rel="noopener nofollow">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/5ba7a51c4f77e516eca886192fbbea4fe90d4a4f/AvaloniaIDemo/NemficubehayWaybakiwerwhaw" target="_blank" rel="noopener nofollow">gitee</a> 上，可以使用如下命令行拉取代码。我整个代码仓库比较庞大，使用以下命令行可以进行部分拉取，拉取速度比较快</p>
<p>先创建一个空文件夹，接着使用命令行 cd 命令进入此空文件夹，在命令行里面输入以下代码，即可获取到本文的代码</p>
<pre><code>git init
git remote add origin https://gitee.com/lindexi/lindexi_gd.git
git pull origin 5ba7a51c4f77e516eca886192fbbea4fe90d4a4f
</code></pre>
<p>以上使用的是国内的 gitee 的源，如果 gitee 不能访问，请替换为 github 的源。请在命令行继续输入以下代码，将 gitee 源换成 github 源进行拉取代码。如果依然拉取不到代码，可以发邮件向我要代码</p>
<pre><code>git remote remove origin
git remote add origin https://github.com/lindexi/lindexi_gd.git
git pull origin 5ba7a51c4f77e516eca886192fbbea4fe90d4a4f
</code></pre>
<p>获取代码之后，进入 AvaloniaIDemo/NemficubehayWaybakiwerwhaw 文件夹，即可获取到源代码</p>
<p>更多技术博客，请参阅 <a href="https://blog.lindexi.com/post/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA.html" target="_blank" rel="noopener nofollow">博客导航</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>博客园博客只做备份，博客发布就不再更新，如果想看最新博客，请访问 https://blog.lindexi.com/</p>

<p>如图片看不见，请在浏览器开启不安全http内容兼容</p>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width: 0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](https://www.cnblogs.com/lindexi)(包含链接:https://www.cnblogs.com/lindexi )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.614412071721065" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 07:30">2025-01-23 07:23</span>&nbsp;
<a href="https://www.cnblogs.com/lindexi">lindexi</a>&nbsp;
阅读(<span id="post_view_count">155</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18687046" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18687046);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18687046', targetLink: 'https://www.cnblogs.com/lindexi/p/18687046', title: 'dotnet 使用 ColorCode 做代码着色器' })">举报</a>
</div>
        