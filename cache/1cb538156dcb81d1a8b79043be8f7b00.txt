
<table cellspacing="0" cellpadding="0"><tbody><tr><td class="t_f" id="postmessage_52625667">
<i class="pstatus"> 本帖最后由 LightIO 于 2025-3-16 17:33 编辑 </i><br>
<div class="parsedown-markdown"><p><strong>关于Windows和Linux简单批处理文件的分享</strong><br>
目录<br>
一、批处理脚本概念<br>
二、批处理脚本的作用和意义<br>
三、常用批处理脚本分享<br>
3.1 ssh服务的启动和关闭<br>
3.1.1 startssh.sh(Linux)<br>
3.1.2 stopssh.sh(Linux)<br>
3.2 phpstudy的数据库(MySQl)和中间件(Apache)服务的启动和关闭<br>
3.2.1 startphpstudy.bat(Windows)<br>
3.2.2 stophpstudy.bat(Windows)<br>
3.3 虚拟主机KALI的启动和关闭<br>
3.3.1 startkali.bat(Windows)<br>
3.3.2 stopkali.bat(Windows)<br>
3.4 虚拟主机Windows的启动和关闭<br>
3.4.1 startwin10.bat(Windows)<br>
3.4.2 stopwin10.bat(Windows)<br>
3.5 常见服务和端口的启动和关闭<br>
3.5.1 startsmb445.bat(Windows)<br>
3.5.2 stopsmb445.bat(Windows)<br>
3.6 C2脚本启动和关闭<br>
3.6.1 startCS.sh(Linux)<br>
3.6.2 stopCS.sh(Linux)<br>
3.7 写在最后<br>
3.7.1 建议<br>
3.7.2 分享</p>
<p>脚本经过AI生成和优化，自行判断使用</p>
<h2 id="52625667_一、批处理脚本概念">一、批处理脚本概念</h2>
<p>批处理脚本（Batch Script）是由一系列命令组成的文件，通常具有<code>.bat</code> 和<code>.cmd</code>(Windows)以及<code>.sh</code> (Linux)扩展名，并用于在 Windows和Linux 操作系统中自动执行一系列任务。它们是基于命令行的脚本语言，通常用来简化日常操作，自动化系统管理、应用程序配置、任务调度等工作。批处理脚本在系统管理和开发中有着广泛的应用。</p>
<h2 id="52625667_二、批处理脚本的作用和意义">二、批处理脚本的作用和意义</h2>
<blockquote>
<p>批处理脚本的作用和意义</p>
<pre><code>&nbsp; &nbsp; 1. 自动化操作： 批处理脚本可以将多个手动操作或命令打包成一个自动执行的脚本。通过编写批处理脚本，可以自动化许多重复性的任务，例如启动或停止应用程序、备份文件、清理临时文件等。这可以极大地提高效率，减少人为操作错误。</code></pre>
<ol start="2">
<li>
<p>系统管理：对于系统管理员来说，批处理脚本是一个强有力的工具，用于自动化常见的系统管理任务。例如，自动化虚拟机的启动和停止、管理文件备份、日志清理、服务启动与停止等任务。在批处理脚本中，可以集成多个系统命令和工具，使得管理操作更加高效和方便。</p>
</li>
<li>
<p>任务调度：批处理脚本可以与 Windows 的任务计划程序结合使用，按预定时间或条件触发执行。例如，系统可以设定每天定时运行一个批处理脚本来执行数据备份，或者每周自动重启特定的服务。</p>
</li>
<li>
<p>灵活性和可定制性：批处理脚本支持条件判断（如 if 语句）、循环（如 for 语句）等结构，因此可以根据不同的需求进行灵活的自定义。比如可以根据文件的存在与否执行不同的操作，或者根据用户输入动态修改脚本行为。</p>
</li>
<li>
<p>简化任务：对于复杂的操作，批处理脚本能够将多个命令合并为一个文件，只需运行该文件即可完成复杂的操作，无需记住和输入每一个命令。这对于非专业用户也非常友好，使得复杂的操作变得简单和直观。</p>
<pre><code>6. 便于维护和分享：批处理脚本以文本文件的形式存在，可以方便地编辑、复制和分享。通过脚本，多个系统可以执行相同的操作，这对于团队合作、远程管理等场景非常有意义。</code></pre>
</li>
<li>
<p>减少错误：&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;通过自动化执行任务，可以减少人为操作中的错误。例如，虚拟机的启动和停止命令，如果由人手动执行，可能因疏忽或命令拼写错误导致失败；而使用批处理脚本时，执行流程是自动化且一致的，减少了这些风险。</p>
</li>
</ol>
</blockquote>
<h2 id="52625667_三、常用批处理脚本分享">三、常用批处理脚本分享</h2>
<h3 id="52625667_3.1-ssh服务的启动和关闭">3.1 ssh服务的启动和关闭</h3>
<h4 id="52625667_3.1.1-startssh.sh(linux)">3.1.1 startssh.sh(Linux)</h4>
<p>运行方式</p>
<pre><code class="language-rust">./startssh.sh</code></pre>
<p>脚本代码示例1（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">echo "Verifying kernel version..."
KERNEL_VERSION=$(uname -r)
echo "Running kernel version: $KERNEL_VERSION"

echo "Enabling SSH service..."
systemctl enable ssh
systemctl start ssh

echo "Checking SSH service status..."
systemctl status ssh --no-pager

echo "Configuration completed."

# 输出信息，表示正在检查 SSH 服务的状态
echo "Checking SSH service status..."
# 使用 systemctl 查看 SSH 服务的状态，并输出信息
systemctl status ssh --no-pager

# 输出完成信息，表示配置已经完成
echo "Configuration completed."</code></pre>
<h4 id="52625667_3.1.2-stopssh.sh(linux)">3.1.2 stopssh.sh(Linux)</h4>
<p>运行方式</p>
<pre><code class="language-rust">./stopssh.sh</code></pre>
<p>脚本代码示例2（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">#!/bin/bash

echo "Checking if running as root..."
if [ "$(id -u)" -ne 0 ]; then
&nbsp; &nbsp; echo "Please run as root"
&nbsp; &nbsp; exit 1
fi

echo "Stopping SSH service..."
if systemctl stop ssh; then
&nbsp; &nbsp; echo "SSH service stopped successfully."
else
&nbsp; &nbsp; echo "Failed to stop SSH service or service not found."
&nbsp; &nbsp; exit 1
fi

echo "Disabling SSH service..."
if systemctl disable ssh; then
&nbsp; &nbsp; echo "SSH service disabled successfully."
else
&nbsp; &nbsp; echo "Failed to disable SSH service."
&nbsp; &nbsp; exit 1
fi

echo "Checking SSH status..."
systemctl is-active --quiet ssh &amp;&amp; echo "SSH service is still running!" || echo "SSH service is stopped."

echo "Done."</code></pre>
<h3 id="52625667_3.2-phpstudy的数据库(mysql)和中间件(apache)服务的启动和关闭">3.2 phpstudy的数据库(MySQl)和中间件(Apache)服务的启动和关闭</h3>
<h4 id="52625667_3.2.1-startphpstudy.bat(windows)">3.2.1 startphpstudy.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">startphpstudy.bat</code></pre>
<p>脚本代码示例3（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
rem 启动 phpstudy_pro 应用程序
rem 此命令启动 phpstudy_pro 主程序，路径需根据实际安装位置调整
echo Starting phpstudy_pro...
start "" "C:\phpstudy_pro\COM\phpstudy_pro.exe"

rem 启动 Apache2.4.39 服务
rem 使用 start 命令启动 Apache 服务，-k start 参数表示启动 Apache 服务
rem 确保 Apache2.4.39 的安装路径和配置文件路径正确
echo Starting Apache...
start "" "C:\phpstudy_pro\Extensions\Apache2.4.39\bin\httpd.exe" -k start

rem 启动 MySQL 服务
rem 使用 start 命令启动 MySQL 服务，--console 参数表示 MySQL 在控制台模式下运行
rem 确保 MySQL5.7.26 的安装路径和配置文件路径正确
echo Starting MySQL5.7.26...
start "" "C:\phpstudy_pro\Extensions\MySQL5.7.26\bin\mysqld.exe" --console

rem 显示已启动信息
rem 提示用户 phpstudy_pro、Apache2.4.39 和 MySQL5.7.26 已启动
echo phpstudy_pro, Apache2.4.39, and MySQL5.7.26 are now running.

rem 暂停命令行窗口，直到用户按任意键继续
pause</code></pre>
<h4 id="52625667_3.2.2-stophpstudy.bat(windows)">3.2.2 stophpstudy.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">stophpstudy.bat</code></pre>
<p>脚本代码示例4（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
rem 显示正在停止的服务信息
rem 该命令向用户显示正在停止 phpstudy_pro、Apache 和 MySQL 服务
echo Stopping phpstudy_pro, Apache2.4.39, and MySQL5.7.26...

rem 停止 Apache 服务
rem 使用 taskkill 命令强制终止 httpd.exe 进程，即停止 Apache2.4.39 服务
rem /F 参数表示强制结束进程，/IM 参数指定进程的映像名称（即 httpd.exe）
echo Stopping Apache2.4.39...
taskkill /F /IM httpd.exe

rem 停止 MySQL 服务
rem 使用 taskkill 命令强制终止 mysqld.exe 进程，即停止 MySQL5.7.26 服务
rem 同样使用 /F 和 /IM 参数来指定进程并强制结束
echo Stopping MySQL5.7.26...
taskkill /F /IM mysqld.exe

rem 关闭 phpstudy_pro 应用
rem 使用 taskkill 命令强制终止 phpstudy_pro.exe 进程，即关闭 phpstudy_pro 应用程序
echo Stopping PHPStudy Pro...
taskkill /F /IM phpstudy_pro.exe

rem 显示已停止的信息
rem 提示用户 phpstudy_pro、Apache 和 MySQL 服务已经成功停止
echo phpstudy_pro, Apache2.4.39, and MySQL5.7.26 have been stopped.

rem 暂停命令行窗口，直到用户按任意键继续
pause</code></pre>
<h3 id="52625667_3.3-虚拟主机kali的启动和关闭">3.3 虚拟主机KALI的启动和关闭</h3>
<h4 id="52625667_3.3.1-startkali.bat(windows)">3.3.1 startkali.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">startkali.bat</code></pre>
<p>脚本代码示例5（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">#有窗口
@echo off
set VMX_PATH="C:\KALI2025-W02-01\KALI2025-W02-01.vmx"

echo Starting VMware Workstation...
start "" "C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe"

timeout /t 5 /nobreak

echo Starting VMware virtual machine in background...
"C:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe" start "%VMX_PATH%" nogui

exit</code></pre>
<pre><code class="language-rust">有无窗口取决于是使用那个方式运行
有窗口是运行了vmware.exe，如果想无窗口运行
注释掉此命令就行
echo Starting VMware Workstation...
start "" "C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe"

无界面启动（后台运行）
使用vmrun.exe自带工具
nogui 选项表示不显示 VMware 界面，直接运行虚拟机。</code></pre>
<h4 id="52625667_3.3.2-stopkali.bat(windows)">3.3.2 stopkali.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">stopkali.bat</code></pre>
<p>脚本代码示例6（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">#无窗口关闭
@echo off
echo Setting VMX path...
set VMX_PATH="C:\KALI2025-W02-01\KALI2025-W02-01.vmx"

echo Stopping VMware virtual machine...
"C:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe" stop "%VMX_PATH%" hard

echo VMX path cleared.
set VMX_PATH=
exit</code></pre>
<h3 id="52625667_3.4-虚拟主机windows的启动和关闭">3.4 虚拟主机Windows的启动和关闭</h3>
<h4 id="52625667_3.4.1-startwin10.bat(windows)">3.4.1 startwin10.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">startwin10.bat</code></pre>
<p>脚本代码示例7（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
setlocal

rem 设置 VMware 路径
set "VMWARE_PATH=C:\Program Files (x86)\VMware\VMware Workstation"
set "VMX_PATH=D:\VMwareVmdk\Windows10-01\Windows10-01.vmx"

rem 检查 VMware 是否存在
if not exist "%VMWARE_PATH%\vmware.exe" (
&nbsp; &nbsp; echo VMware Workstation not found at "%VMWARE_PATH%". Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 检查虚拟机文件是否存在
if not exist "%VMX_PATH%" (
&nbsp; &nbsp; echo Virtual machine file "%VMX_PATH%" not found. Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 启动 VMware Workstation
echo Starting VMware Workstation...
start "" "%VMWARE_PATH%\vmware.exe"

rem 等待 2 秒
timeout /t 2 /nobreak

rem 检查 vmrun 是否存在
if not exist "%VMWARE_PATH%\vmrun.exe" (
&nbsp; &nbsp; echo vmrun.exe not found at "%VMWARE_PATH%\vmrun.exe". Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 启动虚拟机
echo Starting VMware virtual machine...
"%VMWARE_PATH%\vmrun.exe" start "%VMX_PATH%" nogui
if errorlevel 1 (
&nbsp; &nbsp; echo Failed to start virtual machine. Please check the vmrun logs for more information.
&nbsp; &nbsp; exit /b 1
)

echo Virtual machine started successfully.

endlocal
exit</code></pre>
<h4 id="52625667_3.4.2-stopwin10.bat(windows)">3.4.2 stopwin10.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<pre><code class="language-rust">stopwin10.bat</code></pre>
<p>脚本代码示例8（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
rem 启用局部环境变量，防止环境变量的污染
setlocal

rem 设置 VMware 安装路径，并指定虚拟机文件路径
set "VMWARE_PATH=C:\Program Files (x86)\VMware\VMware Workstation"
set "VMX_PATH=D:\VMwareVmdk\Windows10-01\Windows10-01.vmx"

rem 检查 VMware 是否存在，确认 vmware.exe 文件是否存在
if not exist "%VMWARE_PATH%\vmware.exe" (
&nbsp; &nbsp; rem 如果未找到 VMware 工作站程序，输出错误信息并退出脚本
&nbsp; &nbsp; echo VMware Workstation not found at "%VMWARE_PATH%". Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 检查虚拟机文件是否存在，确保虚拟机配置文件 (.vmx) 存在
if not exist "%VMX_PATH%" (
&nbsp; &nbsp; rem 如果未找到虚拟机文件，输出错误信息并退出脚本
&nbsp; &nbsp; echo Virtual machine file "%VMX_PATH%" not found. Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 等待 2 秒，给系统一些时间以确保路径和文件的检查完成
timeout /t 2 /nobreak

rem 检查 vmrun.exe 是否存在，确保 VMware 的命令行工具 vmrun.exe 可以使用
if not exist "%VMWARE_PATH%\vmrun.exe" (
&nbsp; &nbsp; rem 如果未找到 vmrun.exe，输出错误信息并退出脚本
&nbsp; &nbsp; echo vmrun.exe not found at "%VMWARE_PATH%\vmrun.exe". Exiting...
&nbsp; &nbsp; exit /b 1
)

rem 停止虚拟机，使用 vmrun 工具通过无界面模式 (nogui) 停止虚拟机
echo Stopping VMware virtual machine...
"%VMWARE_PATH%\vmrun.exe" stop "%VMX_PATH%" nogui
rem 检查是否成功执行停止虚拟机的命令，如果失败则输出错误信息并退出
if errorlevel 1 (
&nbsp; &nbsp; echo Failed to stop virtual machine. Please check the vmrun logs for more information.
&nbsp; &nbsp; exit /b 1
)

rem 如果虚拟机成功停止，输出虚拟机已成功停止的信息
echo Virtual machine stopped successfully.

rem 结束局部环境变量作用域，清除设置的环境变量
endlocal

rem 退出脚本
exit</code></pre>
<h3 id="52625667_3.5-常见服务和端口的启动和关闭">3.5 常见服务和端口的启动和关闭</h3>
<h4 id="52625667_3.5.1-startsmb445.bat(windows)">3.5.1 startsmb445.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<p>脚本代码示例9（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
rem Disable command echo for cleaner output

rem Open port 445 in Windows Firewall
rem Adds a firewall rule to allow incoming TCP connections on port 445
netsh advfirewall firewall add rule name="Open 445" protocol=TCP dir=in localport=445 action=allow
echo Port 445 has been opened

rem Configure and start SMB service
rem Set the SMB service (lanmanserver) to start automatically
sc config lanmanserver start= auto
rem Attempt to start the SMB service
sc start lanmanserver
echo SMB service has been started

rem Pause to view output
pause</code></pre>
<h4 id="52625667_3.5.2-stopsmb445.bat(windows)">3.5.2 stopsmb445.bat(Windows)</h4>
<p>运行方式</p>
<p>双击运行，或者命令行启动</p>
<p>脚本代码示例10（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">@echo off
rem Disable command echo for cleaner execution output

rem Remove firewall rule for port 445
rem Deletes the existing TCP inbound rule for SMB port 445
netsh advfirewall firewall delete rule name="Open 445" protocol=TCP dir=in localport=445
echo Port 445 has been closed

rem Stop and disable SMB service
rem First stop the running SMB service
sc stop lanmanserver
rem Permanently disable the service from auto-starting
rem Note: The space after 'start=' is mandatory in sc config syntax
sc config lanmanserver start= disabled
echo SMB service has been stopped and disabled

rem Pause to view completion messages
pause</code></pre>
<h3 id="52625667_3.6-c2脚本启动和关闭">3.6 C2脚本启动和关闭</h3>
<h4 id="52625667_3.6.1-startcs.sh(linux)">3.6.1 startCS.sh(Linux)</h4>
<p>运行方式</p>
<pre><code class="language-rust">./startCS.sh</code></pre>
<p>脚本代码示例11（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">#!/bin/bash

# ---------- 配置区 ----------
WORK_DIR="/home/tools/Cobalt_Strike_4.7" # 必须设置的工作目录
TEAM_SERVER="./teamserver" # 相对工作目录的路径
IP="服务主机IP"
PASSWORD="自定义密码"
# ---------------------------

# 进入工作目录（关键步骤）
if ! cd "$WORK_DIR" 2&gt;/dev/null; then
&nbsp; &nbsp; echo "[错误] 无法进入工作目录：$WORK_DIR"
&nbsp; &nbsp; echo "请检查：1.目录是否存在 2.当前用户是否有访问权限"
&nbsp; &nbsp; exit 1
fi

# 用户确认环节
read -p "是否继续执行脚本？(y/n): " choice
if [[ ! "$choice" =~ ^[yY] ]]; then
&nbsp; &nbsp; echo "操作已取消"
&nbsp; &nbsp; exit 0
fi

# 进程检查（精确匹配命令行）
if pgrep -f "$TEAM_SERVER $IP $PASSWORD" &gt;/dev/null; then
&nbsp; &nbsp; echo "[状态] teamserver 已在运行"
&nbsp; &nbsp; exit 0
fi

# 权限检查（避免使用高权限命令）
if [ ! -x "$TEAM_SERVER" ]; then
&nbsp; &nbsp; echo "[错误] 缺少执行权限：$WORK_DIR/$TEAM_SERVER"
&nbsp; &nbsp; echo "请手动执行以下命令修复："
&nbsp; &nbsp; echo "chmod +x '$WORK_DIR/$TEAM_SERVER'"
&nbsp; &nbsp; exit 1
fi

# 启动服务（使用 nohup 防止退出）
echo "[启动] 正在启动 teamserver..."
#nohup $TEAM_SERVER $IP $PASSWORD &gt;/dev/null 2&gt;&amp;1 &amp;
nohup $TEAM_SERVER $IP $PASSWORD &gt;&gt; server.log 2&gt;&amp;1 &amp;

# 结果验证
sleep 3
if pgrep -f "$TEAM_SERVER $IP $PASSWORD" &gt;/dev/null; then
&nbsp; &nbsp; echo "[成功] 服务已启动"
else
&nbsp; &nbsp; echo "[警告] 进程未检测到，可能启动失败"
&nbsp; &nbsp; echo "请检查：1.端口冲突 2.日志文件输出"
fi</code></pre>
<h4 id="52625667_3.6.2-stopcs.sh(linux)">3.6.2 stopCS.sh(Linux)</h4>
<p>运行方式</p>
<pre><code class="language-rust">./stopCS.sh</code></pre>
<p>脚本代码示例12（可以根据需求自行优化,文件命名可以自定义）</p>
<pre><code class="language-rust">#!/bin/bash

# ---------- 配置区 ----------
WORK_DIR="/home/tools/Cobalt_Strike_4.7" # 必须设置的工作目录
TEAM_SERVER="./teamserver" # 相对工作目录的路径
IP="服务主机IP"
PASSWORD="自定义密码"
# ---------------------------

# 进入工作目录（关键步骤）
if ! cd "$WORK_DIR" 2&gt;/dev/null; then
&nbsp; &nbsp; echo "[错误] 无法进入工作目录：$WORK_DIR"
&nbsp; &nbsp; echo "请检查：1.目录是否存在 2.当前用户是否有访问权限"
&nbsp; &nbsp; exit 1
fi

# 用户确认环节
read -p "是否继续执行脚本？(y/n): " choice
if [[ ! "$choice" =~ ^[yY] ]]; then
&nbsp; &nbsp; echo "操作已取消"
&nbsp; &nbsp; exit 0
fi

# 进程检查（精确匹配命令行）
if pgrep -f "$TEAM_SERVER $IP $PASSWORD" &gt;/dev/null; then
&nbsp; &nbsp; echo "[状态] teamserver 已在运行"
&nbsp; &nbsp; exit 0
fi

# 权限检查（避免使用高权限命令）
if [ ! -x "$TEAM_SERVER" ]; then
&nbsp; &nbsp; echo "[错误] 缺少执行权限：$WORK_DIR/$TEAM_SERVER"
&nbsp; &nbsp; echo "请手动执行以下命令修复："
&nbsp; &nbsp; echo "chmod +x '$WORK_DIR/$TEAM_SERVER'"
&nbsp; &nbsp; exit 1
fi

# 启动服务（使用 nohup 防止退出）
echo "[启动] 正在启动 teamserver..."
#nohup $TEAM_SERVER $IP $PASSWORD &gt;/dev/null 2&gt;&amp;1 &amp;
nohup $TEAM_SERVER $IP $PASSWORD &gt;&gt; server.log 2&gt;&amp;1 &amp;

# 结果验证
sleep 3
if pgrep -f "$TEAM_SERVER $IP $PASSWORD" &gt;/dev/null; then
&nbsp; &nbsp; echo "[成功] 服务已启动"
else
&nbsp; &nbsp; echo "[警告] 进程未检测到，可能启动失败"
&nbsp; &nbsp; echo "请检查：1.端口冲突 2.日志文件输出"
fi</code></pre>
<h2 id="52625667_3.7-写在最后">3.7 写在最后</h2>
<h3 id="52625667_3.7.1-建议">3.7.1 建议</h3>
<p>文件可以直接放入管理员目录下，打开命令行就可以直接运行，但是存在安全风险，个人根据需求取舍，其它更多的用法可以自行探索。</p>
<blockquote>
<p>tips:<br>
1.别忘记给文件赋权<br>
2.关于虚拟主机启动与关闭的问题与你的.vmx文件有关<br>
把加上.vmx绝对路径和.vmx文件的完整路径写全，并且替换掉其中<code>""</code>里面的内容即可成功运行<br>
echo Setting VMX path...<br>
set VMX_PATH="C:\KALI2025-W02-01\KALI2025-W02-01.vmx"<br>
3.VMware如果是默认的安装路径，后面不用改，如果是自定义路径，请替换相应的绝对路径，同2<br>
set "VMWARE_PATH=C:\Program Files (x86)\VMware\VMware Workstation"<br>
4.如何判断虚拟主机成功运行： 当打开VMware看到左侧边栏有向右的绿色三角形符号说明成功启动，没有说明未启动成功或者停止服务成功<br>
5.没有万能的脚本，也没有万能的工具，一切以实际情况为准。</p>
</blockquote>
<h3 id="52625667_3.7.2-分享">3.7.2 分享</h3>
<pre><code class="language-rust">知识并不总是免费，它需要你持久的注意力</code></pre></div>
<div class="parsedown-markdown-end_FLAG_ZXSQ" style="display:none"></div></td></tr></tbody></table>


