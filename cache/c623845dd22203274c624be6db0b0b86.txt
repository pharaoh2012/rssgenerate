
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jimoer/p/18998722" title="发布于 2025-07-22 14:35">
    <span role="heading" aria-level="2">Kafka为什么吞吐量大，速度快？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>根据个人的经历，无论在工作中，还是即将要经历的面试，MQ这部分是肯定要了解的，虽然之前工作中一直使用Kafka但是一些详细的细节知识还是了解的不深，所以这次总结一波。</p>
<h2 id="kafka为什么吞吐量这么大还能这么快高吞吐低延迟">Kafka为什么吞吐量这么大还能这么快（高吞吐&amp;低延迟）？</h2>
<h3 id="顺序写">顺序写</h3>
<p>Kafka是会将消息持久化到本地磁盘的，但是一般我们认为对磁盘的操作性能都不会太高，实际上不管是内存还是磁盘，读写快或慢关键在于寻址的方式，磁盘和内存都有顺序写与随机写，基于磁盘的随机写却是很慢，<strong>但是基于磁盘的顺序写性能是很高的</strong>，一般高于随机写3个数量级，某些情况下磁盘的顺序写性能甚至高于内存的随机写。<br>
顺序写的快的主要原因在于：<strong>减少了磁盘寻道时间</strong>，顺序写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机写。</p>
<h3 id="页缓存page-cache异步刷盘机制">页缓存（page cache）+异步刷盘机制</h3>
<p>即便是顺序写入磁盘，磁盘的访问速度还是不可能跟内存相比的，所以kafka充分利用了现代操作系统分页存储来利用内存提高I/O效率。</p>
<p>**当kafka接收到生产者发送的一条消息时，并不会直接将消息写入到磁盘，而是写入到操作系统的页缓存中，然后通过定时操作，批量将页缓存中的数据刷到磁盘中，当然如果达到页缓存数据量阈值也是会提前触发刷盘操作。<br>
**<br>
<img src="https://i-blog.csdnimg.cn/direct/b382a09da288462ebd192987ccd20930.png" alt="页缓存批量写入" loading="lazy"><br>
页缓存是操作系统预留的一部分内存区域，以固定大小的页为单位（4K或8K）来缓存磁盘数据。</p>
<h3 id="同步副本机制isr">同步副本机制（ISR）</h3>
<p>通过使用页缓存，让kafka的写入操作在明面上都是与内存交互的，速度肯定就很快了，但是因为是先写入到缓存中，然后再刷盘，所以就有可能存在还没来得及从缓存刷到磁盘，服务节点就宕机了，这样消息就丢了。<br>
所以，kafka引入了同步副本节点，<strong>即一个 Kafka 节点可有多个同步副本节点。生产者发送消息后，Kafka 需等同步副本节点也接收到消息，才向生产者返回成功，这样主节点挂掉后，可从同步副本节点重新选举新主节点。</strong><br>
<img src="https://i-blog.csdnimg.cn/direct/edb01599fda94067a62f0509e9fd6aa0.png" alt="同步副本" loading="lazy"></p>
<h3 id="日志分段与索引机制">日志分段与索引机制</h3>
<p>上面都是在说kafka如何提高写的速度了，那么写的再快，读的很慢，kafka还是快不起来，所以为了提升读的速度，kafka将文件按段分成多个小文件，一是为了方便删除老数据，二是可以通过偏移量基于二分法快速定位到具体的小文件。同时加入了索引机制，用小文件粗颗粒度记录偏移量和物理地址的关系，还增加时间索引，支持通过时间戳快速定位消息，以此加快读取速度。<br>
<img src="https://i-blog.csdnimg.cn/direct/bab18b646f1d4dbd94b650ff56950cce.png" alt="分段" loading="lazy"></p>
<h3 id="零拷贝技术">零拷贝技术</h3>
<p>我们知道操作系统分为内核态和用户态，而我们正常情况下想从磁盘中读取一条数据并通过网络发送给消费者，需要先通过 DMA 将数据从磁盘拷贝到内核态的页缓存，然后再通过 CPU 把数据从内核态拷贝到用户态的 kafka，把数据拷贝到内核态的网络缓冲区，最后 DMA 把数据拷贝给网卡。<br>
<img src="https://i-blog.csdnimg.cn/direct/86729c5653814aa78d2e67686f6028ec.png" alt="CPU状态切换" loading="lazy"></p>
<p><strong>这拷贝来拷贝去的 CPU 还需要在内核态和用户态之间来回切换，看着就很麻烦。</strong><br>
<strong>那有没有更好的方法？</strong><br>
<strong>LINUX2.1 便提供了一个 sendfile 的系统函数，它可以直接把数据从页缓存拷贝到网络缓冲区，然后发送给网卡。</strong><br>
<img src="https://i-blog.csdnimg.cn/direct/3218d77422b549d3a7c6725fd97cc4a1.png" alt="仅剩一次CPU拷贝" loading="lazy"></p>
<p><strong>后来到了 LINUX2.4 时代，如果有带收集功能的 DMA 可以更进一步直接将数据从页缓存拷贝到网卡，实现了真正的零拷贝。</strong><br>
<img src="https://i-blog.csdnimg.cn/direct/aebe7276267a4462875889fdbf52eec1.png" alt="零拷贝" loading="lazy"></p>
<h3 id="分区并行">分区并行</h3>
<p>无论 kafka 速度有多快，如果消费者速度跟不上怎么办？</p>
<p>我们知道一个消息队列只能消费者一个一个消费，就算我多加几个消费者也只会增加锁争抢的压力。<br>
所以 kafka 便将消息队列分成多个区，每个区可以有单独的消费者。<br>
<img src="https://i-blog.csdnimg.cn/direct/492598e47a5d448685f933a80d14da0d.png" alt="分区处理" loading="lazy"></p>
<h3 id="批量处理">批量处理</h3>
<p>kafka的一个消费者可一次性从消息队列中获取多个消息进行批量处理，同样生产者也可以批量处理。<br>
生产者发送消息后会先暂存在本地，然后再异步批量向消息队列投递消息。不过这个就不推荐了，容易导致丢消息。<br>
<img src="https://i-blog.csdnimg.cn/direct/39b066191c99434381dfbba6f4987868.png" alt="批量处理" loading="lazy"></p>
<h3 id="reactor-线程模型">reactor 线程模型</h3>
<p>请看IO模型解释：<a href="https://www.cnblogs.com/jimoer/p/11462457.html#autoid-2-4-0" target="_blank">https://www.cnblogs.com/jimoer/p/11462457.html#autoid-2-4-0</a></p>
<h3 id="数据压缩">数据压缩</h3>
<p>卡夫卡会通过压缩算法将消息压缩后进行传输和持久化，这个也能一定程度上提高网络传输和磁盘存储的速度。</p>
<p>Kafka 还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩，压缩的好处就是减少传输的数据量，减轻对网络传输的压力，Producer压缩之后，在Consumer需进行解压，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得。<br>
<img src="https://i-blog.csdnimg.cn/direct/7f632b3dce3145dbacf66e57bf585626.png" alt="数据压缩" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="float:left;letter-spacing: 1px;font-size: 13px;"><p><strong>作者：</strong><a href="http://www.cnblogs.com/jimoer/">纪莫</a>
<br>欢迎任何形式的转载，但请务必注明出处。<br>
限于本人水平，如果文章和代码有表述不当之处，还请不吝赐教。</p>
<!-- 分享图标开始 -->
<p>欢迎扫描二维码关注公众号：<strong>Jimoer</strong></p>
<p>文章会同步到公众号上面，大家一起成长，共同提升技术能力。</p>
<p><strong>声援博主：</strong>如果您觉得文章对您有帮助，可以点击文章右下角【<a onclick="pepleFavourite();" href="javascript:void(0);" style="font-size: 14pt;">推荐</a>】一下。</p>
<p>您的鼓励是博主的最大动力！</p>
</div>
<div style="float:right;">
<img src="https://img2018.cnblogs.com/blog/772743/201909/772743-20190904004009398-659676330.png" alt="微信公众号"></div>
<!-- 分享图标结束 -->
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-22 14:35">2025-07-22 14:35</span>&nbsp;
<a href="https://www.cnblogs.com/jimoer">纪莫</a>&nbsp;
阅读(<span id="post_view_count">240</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18998722);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18998722', targetLink: 'https://www.cnblogs.com/jimoer/p/18998722', title: 'Kafka为什么吞吐量大，速度快？' })">举报</a>
</div>
        