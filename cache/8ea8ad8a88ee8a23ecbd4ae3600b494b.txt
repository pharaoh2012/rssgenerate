
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18662162" title="发布于 2025-01-09 14:55">
    <span role="heading" aria-level="2">聊一聊 C#异步 任务延续的三种底层玩法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>最近聊了不少和异步相关的话题，有点疲倦了，今天再写最后一篇作为近期这类话题的一个封笔吧，下篇继续写我熟悉的 <code>生产故障</code> 系列，突然亲切感油然而生，哈哈，免费给别人看程序故障，是一种积阴德阳善的事情，欲知前世因，今生受者是。欲知来世果，今生做者是。</p>
<p>在任务延续方面，我个人的总结就是三类，分别为：</p>
<ol>
<li>StateMachine</li>
<li>ContinueWith</li>
<li>Awaiter</li>
</ol>
<p>话不多说，我们逐个研究下底层是咋玩的？</p>
<h2 id="二异步任务延续的玩法">二：异步任务延续的玩法</h2>
<h3 id="1-statemachine">1. StateMachine</h3>
<p>说到状态机大家再熟悉不过了，也是 async,await 的底层化身，很多人看到 async await 就想到了IO场景，其实IO场景和状态机是两个独立的东西，状态机是一种设计模式，把这个模式套在IO场景会让代码更加丝滑，仅此而已。为了方便讲述，我们写一个 StateMachine 与 IO场景 无关的一段测试代码。</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            UseAwaitAsync();

            Console.ReadLine();
        }

        static async Task&lt;string&gt; UseAwaitAsync()
        {
            var html = await Task.Run(() =&gt;
            {
                Thread.Sleep(1000);
                var response = "&lt;html&gt;&lt;h1&gt;博客园&lt;/h1&gt;&lt;/html&gt;";
                return response;
            });
            Console.WriteLine($"GetStringAsync 的结果：{html}");
            return html;
        }
    }

</code></pre>
<p>那这段代码在底层是如何运作的呢？刚才也说到了asyncawait只是迷惑你的一种幻象，我们必须手握<code>辟邪宝剑</code>斩开幻象显真身，这里借助 ilspy 截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510738-1424073754.png" alt="" loading="lazy"></p>
<p>从卦中看，本质上就是借助<code>AsyncTaskMethodBuilder&lt;string&gt;</code> 建造者将 awaiter 和 stateMachine 做了一个绑定，感兴趣的朋友可以追一下 AwaitUnsafeOnCompleted() 方法，最后状态机 <code>&lt;UseAwaitAsync&gt;d__1</code> 实例会放入到 <code>Task.Run</code> 的 m_continuationObject 字段。如果有朋友对流程比较蒙的话，我画了一张简图。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510756-448834857.png" alt="" loading="lazy"></p>
<p>图和代码都有了，接下来就是眼见为实。分别在 <code>AddTaskContinuation</code> 和 <code>RunContinuations</code> 方法中做好埋点，前者可以看到 延续任务 是怎么加进去的，后者可以看到 延续任务 是怎么取出来的。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510769-2027042627.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510645-1844504425.png" alt="" loading="lazy"></p>
<p>心细的朋友会发现这卦上有一个很特别的地方，就是 <code>allowInlining=true</code>，也就是回调函数（StateMachine）是在当前线程上一撸到底的。</p>
<p>有些朋友可能要问，能不能让<code>延续任务</code> 跑在单独线程上？ 可以是可以，但你得把 Task.Run 改成 Task.Factory.StartNew ，这样就可以设置TaskCreationOptions参数，参考代码如下：</p>
<pre><code class="language-C#">    var html = await Task.Factory.StartNew(() =&gt;{}, TaskCreationOptions.RunContinuationsAsynchronously);
</code></pre>
<h3 id="2-continuewith">2. ContinueWith</h3>
<p>那些同处于被裁的35岁大龄程序员应该知道Task是 framework 4.0 时代出来的，而async,await是4.5出来的，所以在这个过渡期中有大量的项目会使用ContinueWith 导致回调地狱。。。 这里我们对比一下两者有何不同，先写一段参考代码。</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            UseContinueWith();

            Console.ReadLine();
        }

        static Task&lt;string&gt; UseContinueWith()
        {
            var query = Task.Run(() =&gt;
            {
                Thread.Sleep(1000);
                var response = "&lt;html&gt;&lt;h1&gt;博客园&lt;/h1&gt;&lt;/html&gt;";
                return response;
            }).ContinueWith(t =&gt;
            {
                var html = t.Result;
                Console.WriteLine($"GetStringAsync 的结果：{html}");
                return html;
            });

            return query;
        }
    }

</code></pre>
<p>从卦代码看确实没有asyncawait简洁，那 ContinueWith 内部做了什么呢？感兴趣的朋友可以跟踪一下，本质上和 StateMachine 的玩法是一样的，都是借助 m_continuationObject 来实现延续，画个简图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510719-1105388118.png" alt="" loading="lazy"></p>
<p>代码和模型图都有了，接下来就是用 dnspy 开干了。。。还是在 <code>AddTaskContinuation</code> 和 <code>RunContinuations</code> 上埋伏断点观察。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510740-1105640192.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510753-2132224338.png" alt="" loading="lazy"></p>
<p>从卦中可以看到，延续任务使用新线程来执行的，并没有一撸到底，这明显与 <code>asyncawait</code> 的方式不同，有些朋友可能又要说了，那如何实现和StateMachine一样的呢？这就需要在 ContinueWith 中新增 ExecuteSynchronously 同步参数，参考如下：</p>
<pre><code class="language-C#">    var query = Task.Run(() =&gt; { }).ContinueWith(t =&gt;
    {
    }, TaskContinuationOptions.ExecuteSynchronously);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510726-1223870172.png" alt="" loading="lazy"></p>
<h3 id="3-awaiter">3. Awaiter</h3>
<p>使用Awaiter做任务延续的朋友可能相对少一点，它更多的是和 StateMachine 打配合，当然单独使用也可以，但没有前两者灵活，它更适合那些不带返回值的任务延续,本质上也是借助 <code>m_continuationObject</code> 字段实现的一套底层玩法，话不多说，上一段代码：</p>
<pre><code class="language-C#">
        static Task&lt;string&gt; UseAwaiter()
        {
            var awaiter = Task.Run(() =&gt;
            {
                Thread.Sleep(1000);
                var response = "&lt;html&gt;&lt;h1&gt;博客园&lt;/h1&gt;&lt;/html&gt;";
                return response;
            }).GetAwaiter();

            awaiter.OnCompleted(() =&gt;
            {
                var html = awaiter.GetResult();
                Console.WriteLine($"UseAwaiter 的结果：{html}");
            });

            return Task.FromResult(string.Empty);
        }

</code></pre>
<p>前面两种我配了图，这里没有理由不配了，哈哈，模型图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510758-1495872013.png" alt="" loading="lazy"></p>
<p>接下来把程序运行起来，观察截图：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510647-2048928210.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/214741/202501/214741-20250109145510719-1591257984.png" alt="" loading="lazy"></p>
<p>从卦中观察，它和StateMachine一样，默认都是 一撸到底 的方式。</p>
<h2 id="三runcontinuations-观察">三：RunContinuations 观察</h2>
<p>这一小节我们单独说一下 <code>RunContinuations</code> 方法，因为这里的实现太精妙了，不幸的是Dnspy和ILSpy反编译出来的代码太狗血，原汁原味的简化后代码如下：</p>
<pre><code class="language-C#">    private void RunContinuations(object continuationObject) // separated out of FinishContinuations to enable it to be inlined
    {
        bool canInlineContinuations =
            (m_stateFlags &amp; (int)TaskCreationOptions.RunContinuationsAsynchronously) == 0 &amp;&amp;
            RuntimeHelpers.TryEnsureSufficientExecutionStack();

        switch (continuationObject)
        {
            // Handle the single IAsyncStateMachineBox case.  This could be handled as part of the ITaskCompletionAction
            // but we want to ensure that inlining is properly handled in the face of schedulers, so its behavior
            // needs to be customized ala raw Actions.  This is also the most important case, as it represents the
            // most common form of continuation, so we check it first.
            case IAsyncStateMachineBox stateMachineBox:
                AwaitTaskContinuation.RunOrScheduleAction(stateMachineBox, canInlineContinuations);
                LogFinishCompletionNotification();
                return;

            // Handle the single Action case.
            case Action action:
                AwaitTaskContinuation.RunOrScheduleAction(action, canInlineContinuations);
                LogFinishCompletionNotification();
                return;

            // Handle the single TaskContinuation case.
            case TaskContinuation tc:
                tc.Run(this, canInlineContinuations);
                LogFinishCompletionNotification();
                return;

            // Handle the single ITaskCompletionAction case.
            case ITaskCompletionAction completionAction:
                RunOrQueueCompletionAction(completionAction, canInlineContinuations);
                LogFinishCompletionNotification();
                return;
        }
    }

</code></pre>
<p>卦中的 case 挺有意思的，除了本篇聊过的 TaskContinuation 和 IAsyncStateMachineBox 之外，还有另外两种 continuationObject，这里说一下 ITaskCompletionAction 是怎么回事，其实它是 <code>Task.Result</code> 的底层延续类型，所以大家应该能理解为什么 Task.Result 能唤醒，主要是得益于<code>Task.m_continuationObject =completionAction</code> 所致。</p>
<p>说了这么说，如何眼见为实呢？可以从源码中寻找答案。</p>
<pre><code class="language-C#">
        private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken)
        {
            var mres = new SetOnInvokeMres();

            AddCompletionAction(mres, addBeforeOthers: true);

            var returnValue = mres.Wait(Timeout.Infinite, cancellationToken);
        }

        private sealed class SetOnInvokeMres : ManualResetEventSlim, ITaskCompletionAction
        {
            internal SetOnInvokeMres() : base(false, 0) { }
            public void Invoke(Task completingTask) { Set(); }
            public bool InvokeMayRunArbitraryCode =&gt; false;
        }

</code></pre>
<p>从卦中可以看到，其实就是把 ITaskCompletionAction 接口的实现类 SetOnInvokeMres 塞入了 Task.m_continuationObject 中，一旦Task执行完毕之后就会调用 Invoke() 下的 <code>Set()</code> 来实现事件唤醒。</p>
<h2 id="四总结">四：总结</h2>
<p>虽然<code>异步任务延续</code>有三种实现方法，但底层都是一个套路，即借助 <code>Task.m_continuationObject</code> 字段玩出的各种花样，当然他们也是有一些区别的，即对 <code>m_continuationObject</code> 任务是否用单独的线程调度，产生了不同的意见分歧。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.83046129209375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-09 14:56">2025-01-09 14:55</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">717</span>)&nbsp;
评论(<span id="post_comment_count">5</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18662162" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18662162);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18662162', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18662162', title: '聊一聊 C#异步 任务延续的三种底层玩法' })">举报</a>
</div>
        