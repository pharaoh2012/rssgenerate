
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangSir-devops/p/18903105" title="发布于 2025-05-30 11:28">
    <span role="heading" aria-level="2">Redis持久化机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="概述">概述</h2>
<p>Redis是基于内存的nosql数据库，数据一般是存储于内存中，想让内存数据保存到磁盘中，我们需要利用Redis的持久化机制。</p>
<p>Redis的持久化机制用于将内存中的数据保存到磁盘，以便在重启后恢复数据。<br>
Redis 提供了两种主要的持久化方式：</p>
<ul>
<li>RDB（Redis Database）快照</li>
<li>AOF（Append Only File）日志</li>
</ul>
<p>在Redis4.0版本之后，引入了混合持久化（RDB + AOF）</p>
<h2 id="rdb持久化方式讲解">RDB持久化方式讲解</h2>
<p>RDB 持久化机制以轻量、快速为核心优势，适合对数据实时性要求不高但需要高效恢复的场景。在生产环境中，通常与 AOF 结合使用（混合持久化），以平衡数据安全性和性能。合理配置触发策略、监控文件生成状态，并做好备份管理，是确保 RDB 机制稳定运行的关键。</p>
<p>其使用场景通常为：</p>
<ul>
<li>缓存场景：允许部分数据丢失（如缓存热点数据），优先使用 RDB 提升恢复速度。</li>
<li>定期全量备份：例如每天生成一次 RDB 文件，用于历史数据存档或容灾切换。</li>
<li>主从复制：Redis 主从集群中，主节点通过 RDB 向从节点同步初始数据（增量同步通过 AOF 实现）。</li>
</ul>
<h3 id="rdb实现原理">RDB实现原理</h3>
<p>RDB 是 Redis 在某个时间点将数据写入一个临时文件（快照），持久化结束后，用这个临时文件替换之前的持久化文件，达到数据持久化的目的。</p>
<h3 id="rdb触发持久化方式">RDB触发持久化方式</h3>
<h4 id="手动触发">手动触发</h4>
<p>SAVE 命令：阻塞主线程，直到 RDB 文件生成完毕，期间无法处理客户端请求。<br>
BGSAVE 命令： fork 出一个子进程来生成 RDB 文件，主线程继续处理请求，不阻塞。</p>
<h4 id="自动触发">自动触发</h4>
<p>通过配置文件（redis.conf）中的 save 配置项，满足条件时自动执行 BGSAVE。</p>
<pre><code># 基础配置项
save 900 1        # 900秒内至少有1个键被修改，触发快照
save 300 10       # 300秒内至少有10个键被修改，触发快照
save 60 10000     # 60秒内至少有10000个键被修改，触发快照

# RDB 文件存储路径（建议使用独立磁盘，避免与系统盘混用）
dir /data/redis/rdb
# RDB 文件名（可包含日期戳，便于区分版本）
dbfilename "dump-${DATE}.rdb"  # 需配合脚本动态生成，Redis 不支持变量直接替换
# 压缩配置（生产环境建议保持默认）
rdbcompression yes
# 校验配置（加载时校验 RDB 文件完整性，默认开启）
rdbchecksum yes
</code></pre>
<h3 id="rdb文件管理">RDB文件管理</h3>
<h4 id="文件存储位置与命名">文件存储位置与命名</h4>
<ul>
<li>存储路径：由配置项 dir 决定，默认值为 /var/lib/redis（可通过 config get dir 查看）。</li>
<li>文件名：由配置项 dbfilename 决定，默认值为 dump.rdb（可通过 config get dbfilename 查看）。</li>
</ul>
<h4 id="压缩配置">压缩配置：</h4>
<ul>
<li>RDB 文件默认使用 LZF 算法压缩，可通过配置项 rdbcompression yes|no 开启或关闭（默认 yes）。</li>
<li>关闭压缩可提升生成速度，但会增加文件体积，适用于 CPU 资源紧张的场景。</li>
<li>二进制格式：RDB 文件为二进制格式，不可直接读取，但体积小、恢复速度快。</li>
</ul>
<h3 id="rdb恢复方式及时机">RDB恢复方式及时机</h3>
<ul>
<li>
<p>当Redis宕机重启之后会自动加载rdb文件（如果同时开启了AOF，则优先加载AOF）。</p>
</li>
<li>
<p>如果想强制加载RDB，忽略AOF时，可在配置中设置 appendonly no，或在启动时指定 --loadrdb 参数。</p>
</li>
<li>
<p>手动加载指定加载RDB文件</p>
</li>
</ul>
<pre><code># --dbfilename：指定dump.rdb文件的路径
redis-server  --dbfilename /path/dump.rdb
</code></pre>
<h3 id="rdb实战">RDB实战</h3>
<pre><code># 创建模拟数据
127.0.0.1:6379&gt; set test1 1
OK
127.0.0.1:6379&gt; set test2 2
OK
127.0.0.1:6379&gt; set test3 3
OK
127.0.0.1:6379&gt; keys *
1) "test1"
2) "test2"
3) "test3"

# 执行快照
127.0.0.1:6379&gt; bgsave
Background saving started

[root@master /data00/data/redis]# ll
total 96
-rw-r--r-- 1 root root   125 May 29 19:28 dump.rdb
</code></pre>
<h4 id="模拟一下将dumprdb文件删除重启之后数据还在吗">模拟一下将dump.rdb文件删除，重启之后数据还在吗？</h4>
<pre><code>[root@master /data00/data/redis]# mv dump.rdb ~
# 强制停止redis
[root@master ~]# ps -ef | grep redis
root      908803  635754  0 19:38 pts/0    00:00:00 grep redis
root     1818909       1  0 May20 ?        00:19:44 redis-server 0.0.0.0:6379
[root@master ~]# pkill redis-server
</code></pre>
<p>启动Redis服务</p>
<pre><code>[root@master ~]# redis-server /data00/data/redis/redis.conf
[root@master ~]# ss -lntup | grep 6379
tcp   LISTEN 0      511                           0.0.0.0:6379       0.0.0.0:*    users:(("redis-server",pid=1807376,fd=6)) 
</code></pre>
<p>检查数据是否存在</p>
<pre><code>127.0.0.1:6379&gt; keys *
(empty array)
</code></pre>
<h4 id="模拟恢复dumprdb文件">模拟恢复dump.rdb文件</h4>
<pre><code># 将dump.rdb文件迁移到Redis数据目录下
[root@master /data00/data/redis]# mv ~/dump.rdb /data00/data/redis

# 检查rdb文件是否损坏
[root@master /data00/data/redis]# redis-check-rdb dump.rdb
[offset 0] Checking RDB file dump.rdb
[offset 27] AUX FIELD redis-ver = '6.2.18'
[offset 41] AUX FIELD redis-bits = '64'
[offset 53] AUX FIELD ctime = '1748518107'
[offset 68] AUX FIELD used-mem = '875088'
[offset 84] AUX FIELD aof-preamble = '0'
[offset 86] Selecting DB ID 0
[offset 125] Checksum OK
[offset 125] \o/ RDB looks OK! \o/
[info] 3 keys read
[info] 0 expires
[info] 0 already expired

# 启动Redis并检查数据
[root@master ~]# redis-server /data00/data/redis/redis.conf
[root@master ~]# redis-cli 
127.0.0.1:6379&gt; auth !Xinxin123
OK
127.0.0.1:6379&gt; keys *
1) "test2"
2) "test1"
3) "test3"
</code></pre>
<h2 id="aof持久化方式讲解">AOF持久化方式讲解</h2>
<p>AOF（Append Only File）是 Redis 提供的一种实时性更强的持久化方式，通过记录所有写操作命令（而非数据本身）来保证数据的完整性。</p>
<h3 id="核心原理">核心原理</h3>
<ul>
<li>客户端发送写命令（如 SET key value）。</li>
<li>Redis 执行命令并将结果返回客户端。</li>
<li>将命令写入 AOF 缓冲区（内存）。</li>
<li>根据配置策略将缓冲区内容同步到磁盘。</li>
</ul>
<h4 id="刷盘策略appendfsync">刷盘策略（appendfsync）</h4>
<ul>
<li>always：每个写命令都同步到磁盘，最多会丢失一个命令</li>
<li>everysec：每秒同步一次磁盘（默认配置），最多丢失 1 秒数据</li>
<li>no：由操作系统决定何时刷盘（通常为 30 秒左右，取决于内核调度），可能会丢失大量数据</li>
</ul>
<h3 id="aof相关配置">AOF相关配置</h3>
<pre><code># 启用 AOF（默认关闭）
appendonly yes

# 刷盘策略（推荐 everysec，兼顾安全与性能）
appendfsync everysec

# AOF 文件名（默认 appendonly.aof）
appendfilename "appendonly.aof"

# AOF 文件存储目录（与 RDB 共享，由 dir 参数决定）
dir /var/lib/redis

# 开启混合持久化（Redis 4.0+ 支持）
aof-use-rdb-preamble yes
</code></pre>
<h3 id="aof重写机制">AOF重写机制</h3>
<h4 id="为什么需要重写">为什么需要重写？</h4>
<p>随着写命令不断追加，AOF 文件会越来越大，可能导致：</p>
<ul>
<li>文件体积膨胀：占用大量磁盘空间。</li>
<li>恢复速度变慢：重启时需要重放更多命令。</li>
</ul>
<h4 id="重写原理">重写原理</h4>
<p>通过 <code>BGREWRITEAOF</code> 命令触发，Redis 会：</p>
<ul>
<li>fork 子进程遍历当前内存数据。</li>
<li>生成最简命令集（如合并多个 SET 为一个）。</li>
<li>替换原有 AOF 文件，保证原子性。</li>
</ul>
<h4 id="自动触发重写">自动触发重写</h4>
<p>在 redis.conf 中配置：</p>
<pre><code># 当 AOF 文件比上次重写后增长超过 100% 时触发
auto-aof-rewrite-percentage 100

# AOF 文件至少达到 64MB 才触发重写（避免频繁重写小文件）
auto-aof-rewrite-min-size 64mb
</code></pre>
<h3 id="aof恢复机制">AOF恢复机制</h3>
<h4 id="redis-自动加载-aof-日志">Redis 自动加载 AOF 日志</h4>
<p>Redis 服务器启动时会优先尝试加载 AOF 文件来恢复数据，前提是满足以下条件：</p>
<p>1、配置文件中需启用 AOF 持久化，在 Redis 的配置文件（redis.conf）中，appendonly 参数需设置为 yes：</p>
<pre><code>appendonly yes
</code></pre>
<p>2、存在有效的 AOF 文件，Redis 会检查 appendfilename 参数指定的 AOF 文件名（默认是 appendonly.aof）是否存在，且文件内容未损坏</p>
<h2 id="混合持久化机制讲解">混合持久化机制讲解</h2>
<p>Redis的混合持久化机制（Hybrid Persistence）是Redis4.0版本及以上的新特性，混合持久化机制（Hybrid Persistence）是结合了 AOF（Append Only File）和 RDB（Redis Database）两种持久化方式优点的策略，旨在提供更高效的数据恢复能力和更细粒度的数据安全性。</p>
<h3 id="工作原理">工作原理</h3>
<p>混合持久化机制的核心是：</p>
<p><strong>在执行 AOF 重写（BGREWRITEAOF）时，将当前内存中的数据以 RDB 快照格式写入 AOF 文件，后续的写命令继续以 AOF 格式追加到文件末尾。</strong></p>
<p>具体流程如下：</p>
<ul>
<li>启用混合持久化：在 redis.conf 中配置 aof-use-rdb-preamble yes（默认关闭）。</li>
<li>AOF 重写触发：当 AOF 文件达到一定大小或手动执行 BGREWRITEAOF 时，Redis 会：
<ul>
<li>生成 RDB 快照数据（二进制格式，紧凑高效）。</li>
<li>将 RDB 数据写入新 AOF 文件的开头。</li>
<li>继续将后续的写命令以文本协议格式追加到 AOF 文件末尾。</li>
</ul>
</li>
<li>数据恢复：Redis 启动时，先加载 RDB 部分（快速恢复大部分数据），再执行 AOF 追加部分的命令（恢复最新操作）。</li>
</ul>
<h3 id="混合持久化相关配置">混合持久化相关配置</h3>
<pre><code>appendonly yes                # 启用 AOF 持久化
aof-use-rdb-preamble yes      # 启用混合持久化（Redis 4.0+ 支持）

# 触发AOF重写
auto-aof-rewrite-percentage 100  # AOF 文件大小比上次重写后增长 100% 时触发
auto-aof-rewrite-min-size 64mb   # AOF 文件最小达到 64MB 时触发
</code></pre>
<h3 id="数据恢复流程">数据恢复流程</h3>
<p>当 Redis 服务器重启时，加载混合 AOF 文件的流程：</p>
<ul>
<li>检查文件格式：识别 AOF 文件是否包含 RDB 前缀。</li>
<li>加载 RDB 部分：快速解析二进制 RDB 数据，重建内存状态。</li>
<li>执行 AOF 部分：继续执行 RDB 之后的 AOF 命令，恢复最新操作。</li>
</ul>
<h2 id="混合持久化-vs-纯-aof-vs-纯-rdb区别">混合持久化 vs 纯 AOF vs 纯 RDB区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>混合持久化</th>
<th>纯 AOF</th>
<th>纯 RDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据恢复速度</td>
<td>快（RDB 加载 + 少量 AOF 命令）</td>
<td>较慢（逐行执行命令）</td>
<td>最快（直接加载快照）</td>
</tr>
<tr>
<td>文件体积</td>
<td>小（RDB 二进制 + 增量 AOF）</td>
<td>大（纯文本命令）</td>
<td>中等（二进制快照）</td>
</tr>
<tr>
<td>数据安全性</td>
<td>高（接近 AOF，仅丢失未同步数据）</td>
<td>高（取决于 fsync 策略）</td>
<td>低（可能丢失最后一次快照后的数据）</td>
</tr>
<tr>
<td>写操作开销</td>
<td>中等（重写时生成 RDB）</td>
<td>高（频繁 fsync）</td>
<td>低（定期快照）</td>
</tr>
<tr>
<td>兼容性</td>
<td>Redis 4.0+</td>
<td>全版本支持</td>
<td>全版本支持</td>
</tr>
</tbody>
</table>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/huangSir-devops/" target="_blank">huangSir-devops</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/huangSir-devops/p/18903105" target="_blank">https://www.cnblogs.com/huangSir-devops/p/18903105</a>，微信Vac666666，欢迎交流</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.282836537607639" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-30 11:28">2025-05-30 11:28</span>&nbsp;
<a href="https://www.cnblogs.com/huangSir-devops">huangSir-devops</a>&nbsp;
阅读(<span id="post_view_count">291</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18903105);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18903105', targetLink: 'https://www.cnblogs.com/huangSir-devops/p/18903105', title: 'Redis持久化机制' })">举报</a>
</div>
        