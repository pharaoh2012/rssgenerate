
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/burc/p/18568296" title="发布于 2024-11-26 09:48">
    <span role="heading" aria-level="2">pnpm 是如何颠覆 npm 和 yarn 的？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181522359-1347488251.png" alt="pnpm 是如何颠覆 npm 和 yarn 的？" class="desc_img">
        今天研究了一下 pnpm 的机制，发现它确实很强大，甚至可以说对 yarn 和 npm 形成了降维打击 。我们从包管理工具的发展历史，一起看下到底好在哪里？
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>今天研究了一下 <code>pnpm</code> 的机制，发现它确实很强大，甚至可以说对 <code>yarn</code> 和 <code>npm</code> 形成了降维打击 。</p>
<p>我们从包管理工具的发展历史，一起看下到底好在哪里？</p>
<h1 id="npm2">npm2</h1>
<p>在 npm 3.0 版本之前，项目的 <code>node_modules</code> 会呈现出嵌套结构，也就是说，我安装的依赖、依赖的依赖、依赖的依赖的依赖...，都是递归嵌套的</p>
<pre><code>node_modules
├─ express
│  ├─ index.js
│  ├─ package.json
│  └─ node_modules
│     ├─ accepts
│     │  ├─ index.js
│     │  ├─ package.json
│     │  └─ node_modules
│     │     ├─ mime-types
|     |     |   └─ node_modules
|     |     |      └─ mime-db
|     │     └─ negotiator
│     ├─ array-flatten
│ 		├─ ...
│  		└─ ...
└─ A
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ accepts
         ├─ index.js
         ├─ package.json
         └─ node_modules
            ├─ mime-types
            |   └─ node_modules
            |      └─ mime-db
            └─ negotiator
</code></pre>
<h2 id="设计缺陷">设计缺陷</h2>
<p>这种嵌套依赖树的设计确实存在几个严重的问题</p>
<ol>
<li><strong>路径过长问题：</strong> 由于包的嵌套结构 ， <code>node_modules</code> 的目录结构可能会变得非常深，甚至可能会超出系统路径长度上限 ，毕竟 windows 系统的文件路径默认最多支持 256 个字符</li>
<li><strong>磁盘空间浪费：</strong> 多个包之间难免会有公共的依赖，公共依赖会被多次安装在不同的包目录下，导致磁盘空间被大量浪费 。比如上面 <code>express</code> 和 A 都依赖了 <code>accepts</code>，它就被安装了两次</li>
<li><strong>安装速度慢</strong>：由于依赖包之间的嵌套结构，<code>npm</code> 在安装包时需要多次处理和下载相同的包，导致安装速度变慢，尤其是在依赖关系复杂的项目中</li>
</ol>
<p>当时 npm 还没解决这些问题， 社区便推出了新的解决方案 ，就是 yarn。 它引入了一种新的依赖管理方式——<strong>扁平化依赖。</strong></p>
<p>看到 yarn 的成功，npm 在 3.0 版本中也引入了类似的扁平化依赖结构</p>
<h1 id="yarn">yarn</h1>
<p><strong>yarn 的主要改进之一就是通过扁平化依赖结构来解决嵌套依赖树的问题</strong>，具体来说</p>
<p>铺平，yarn 尽量将所有依赖包安装在项目的顶层 <code>node_modules</code> 目录下，而不是嵌套在各自的 <code>node_modules</code> 目录中。</p>
<p>这样一来，减少了目录的深度，避免了路径过长的问题 ，也尽可能避免了依赖被多次重复安装的问题</p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181005095-1472119216.png" width="400">
<p>我们可以在 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/yarn-example" target="_blank" rel="noopener nofollow">yarn-example</a> 看到整个目录，全部铺平在了顶层 <code>node_modules</code> 目录下，展开下面的包大部分是没有二层 <code>node_modules</code> 的</p>
<p>然而，有些依赖包还是会在自己的目录下有一个 <code>node_modules</code> 文件夹，出现嵌套的情况，例如 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/yarn-example" target="_blank" rel="noopener nofollow">yarn-example</a> 下的<code>http-errors</code> 依赖包就有自己的 <code>node_modules</code>，原因是：</p>
<p>当一个项目的多个依赖包需要同一个库的不同版本时，<strong>yarn 只能将一个版本的库提升到顶层</strong> <strong><code>node_modules</code></strong> <strong>目录中。</strong> 对于需要<strong>这个库其他版本</strong>的依赖，yarn 仍然需要在这些依赖包的目录下创建一个嵌套的 <code>node_modules</code> 来存放不同版本的包</p>
<p>比如，包 A 依赖于 <code>lodash@4.0.0</code>，而包 B 依赖于 <code>lodash@3.0.0</code>。由于这两个版本的 <code>lodash</code> 不能合并，<code>yarn</code> 会将 <code>lodash@4.0.0</code> 提升到顶层 <code>node_modules</code>，而 <code>lodash@3.0.0</code> 则被嵌套在包 B 的 <code>node_modules</code> 目录下。</p>
<h2 id="幽灵依赖">幽灵依赖</h2>
<p><strong>虽然 yarn 和 npm 都采用了扁平化的方案来解决依赖嵌套的问题，但这种方案本身也有一些缺陷，其中幽灵依赖是一个主要问题。</strong></p>
<p>幽灵依赖，也就是你明明没有在 <code>package.json</code> 文件中声明的依赖项，但在项目代码里却可以 <code>require</code> 进来</p>
<p>这个也很容易理解，因为依赖的依赖被扁平化安装在顶层 <code>node_modules</code> 中，所以我们能访问到依赖的依赖</p>
<p>但是这样是有隐患的，因为没有显式依赖，未来某个时候这些包可能会因为某些原因消失（例如新版本库不再引用这个包了，然后我们更新了库），就会引发代码运行错误</p>
<h2 id="浪费磁盘空间">浪费磁盘空间</h2>
<p><strong>而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题</strong></p>
<p>那社区有没有解决这俩问题的思路呢？ pnpm 就是其中最成功的一个</p>
<h1 id="pnpm">pnpm</h1>
<p>pnpm 通过<strong>全局存储和符号链接机制</strong>从根源上解决了依赖重复安装和路径长度问题，同时也避免了扁平化依赖结构带来的幽灵依赖问题</p>
<p>pnpm 的优势概括来说就是“快、准、狠”：</p>
<ul>
<li>快：安装速度快</li>
<li>准：安装过的依赖会准确复用缓存，甚至包版本升级带来的变化都只 diff，绝不浪费一点空间</li>
<li>狠：直接废掉了幽灵依赖</li>
</ul>
<p>执行 <code>npm add express</code>，我们可以在 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules" target="_blank" rel="noopener nofollow">pnpm-example</a> 看到整个目录，由于只安装了 <code>express</code>，那 <code>node_modules</code> 下就只有 <code>express</code></p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181128905-495318130.png" width="400">
<p>那么所有的（次级）依赖去哪了呢？ binggo，在<code>node_modules/.pnpm/</code>目录下，<code>.pnpm/</code> 以平铺的形式储存着所有的包</p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181157446-1399260902.png" width="450">
<h2 id="三层寻址">三层寻址</h2>
<ol>
<li>所有 npm 包都安装在全局目录 <code>~/.pnpm-store/v3/files</code> 下，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容。</li>
<li>顶层 <code>node_modules</code> 下有 <code>.pnpm</code> 目录以打平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。</li>
<li>每个项目 <code>node_modules</code> 下安装的包以软链接方式将内容指向 <code>node_modules/.pnpm</code> 中的包。</li>
</ol>
<p>所以每个包的寻找都要经过三层结构：<code>node_modules/package-a</code> &gt; 软链接 <code>node_modules/.pnpm/package-a@1.0.0/node_modules/package-a</code> &gt; 硬链接 <code>~/.pnpm-store/v3/files/00/xxxxxx</code>。</p>
<p>这就是 pnpm 的实现原理。官方给了一张原理图，可以搭配食用</p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181316814-2012932012.webp" width="800">
<p>前面说过，npm 包都被安装在全局 <code>pnpm store</code> ，默认情况下，会创建多个存储（每个驱动器（盘符）一个），并在项目所在盘符的根目录</p>
<p>所以，同一个盘符下的不同项目，都可以共用同一个全局 <code>pnpm store</code>，绝绝子啊👏，大大节省了磁盘空间，提高了安装速度</p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181246691-1264971730.png" width="500">
<h2 id="软硬链接">软硬链接</h2>
<p>也就是说，所有的依赖都是从全局 store 硬连接到了 <code>node_modules/.pnpm</code> 下，然后之间通过软链接来相互依赖。</p>
<p>那么，这里的软连接、硬链接到底是什么东西？</p>
<p>硬链接是指向磁盘上原始文件所在的同一位置 （直接指向相同的数据块）</p>
<p>软连接可以理解为新建一个文件，它包含一个指向另一个文件或目录的路径 （指向目标路径）</p>
<img src="https://img2024.cnblogs.com/blog/2180164/202411/2180164-20241125181632440-2083330047.png" width="650">
<h2 id="npmrc">.npmrc</h2>
<p><code>shamefully-hoist</code>，默认 false</p>
<ul>
<li>false：<code>node_modules</code>下只能看到直接依赖的套件，次级依赖在<code>node_modules/.pnpm</code> 目录下；无法访问其他子包局部安装的依赖项，例如，vue-dome2 安装的 lodash，vue-dome1 是访问不到的</li>
<li>true：將所有套件都拉升到 <code>node_modules</code> 目錄下，能访问到其他子包局部安装的依赖项，例如，vue-dome2 安装的 lodash，vue-dome1 是能访问到的</li>
</ul>
<pre><code>// .npmrc

# pnpm 配置
shamefully-hoist=false
</code></pre>
<h1 id="总结">总结</h1>
<p><strong>npm2 的嵌套结构</strong>： 每个依赖项都会有自己的 <code>node_modules</code> 目录，导致了依赖被重复安装，严重浪费了磁盘空间💣；在依赖层级比较深的项目中，甚至会超出 windows 系统的文件路径长度💣</p>
<p><strong>npm3+ 和 Yarn 的扁平化策略：</strong> 尽量将所有依赖包安装在项目的顶层 <code>node_modules</code> 目录下，解决了 <code>npm2</code> 嵌套依赖的问题。但是该方案有一个重大缺陷就是“幽灵依赖”💣；而且依赖包有多个版本时，只会提升一个，那其余版本依然会被重复安装，还是有浪费磁盘空间的问题💣</p>
<p><strong>pnpm全局存储和符号链接机制：</strong> 结合软硬链和三层寻址，解决了依赖被重复安装的问题，更加变态的是，同一盘符下的不同项目都可以共用一个全局 <code>pnpm store</code>。节省了磁盘空间，并且根本不存在“幽灵依赖”，安装速度还贼快💪💪💪</p>
<h1 id="参考文档">参考文档</h1>
<p><a href="https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/253.%E7%B2%BE%E8%AF%BB%E3%80%8Apnpm%E3%80%8B.md" target="_blank" rel="noopener nofollow">weekly/前沿技术/253.精读《pnpm》</a><br>
<a href="https://zhuanlan.zhihu.com/p/549189023" target="_blank" rel="noopener nofollow">pnpm 是凭什么对 npm 和 yarn 降维打击的</a>)<br>
<a href="https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noopener nofollow">平铺的结构不是 node_modules 的唯一实现方式 | pnpm中文网</a></p>

</div>
<div id="MySignature" role="contentinfo">
    人间不正经生活手册
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="27.215911107159723" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-11-26 09:49">2024-11-26 09:48</span>&nbsp;
<a href="https://www.cnblogs.com/burc">柏成</a>&nbsp;
阅读(<span id="post_view_count">717</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18568296" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18568296);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18568296', targetLink: 'https://www.cnblogs.com/burc/p/18568296', title: 'pnpm 是如何颠覆 npm 和 yarn 的？' })">举报</a>
</div>
        