
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Rong-/p/18678830" title="发布于 2025-01-18 20:31">
    <span role="heading" aria-level="2">编程练习：编写一个监听者模式类</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        监听者模式（Observer Pattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。这种模式非常适合用于事件驱动的系统，例如 GUI 框架、消息队列等。
在本文中，我们将通过编写一个简单的监听者模式类 Observable，来学习如何实现这一设计模式。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>监听者模式（Observer Pattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。这种模式非常适合用于事件驱动的系统，例如 GUI 框架、消息队列等。</p>
<p>在本文中，我们将通过编写一个简单的监听者模式类&nbsp;<code>Observable</code>，来学习如何实现这一设计模式。</p>
<hr>
<h2>1. 监听者模式的核心概念</h2>
<p>监听者模式通常包含以下两个核心组件：</p>
<ul>
<li>
<p><strong>Subject（主题）</strong>：维护一个观察者列表，并提供注册、注销和通知观察者的接口。</p>
</li>
<li>
<p><strong>Observer（观察者）</strong>：定义一个更新接口，用于接收主题的通知。</p>
</li>
</ul>
<p>在我们的实现中，<code>Observable</code>&nbsp;类充当 Subject 的角色，而观察者是一个&nbsp;<code>std::function&lt;void()&gt;</code>&nbsp;回调函数。</p>
<hr>
<h2>2. 实现&nbsp;<code>Observable</code>&nbsp;类</h2>
<p>以下是&nbsp;<code>Observable</code>&nbsp;类的完整实现：</p>
<div class="md-code-block">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">#ifndef __OBSERVABLE_H___
</span><span style="color: rgba(0, 0, 255, 1)">#define</span> __OBSERVABLE_H___<span style="color: rgba(0, 0, 0, 1)">

#include </span>&lt;functional&gt;<span style="color: rgba(0, 0, 0, 1)">
#include </span>&lt;mutex&gt;<span style="color: rgba(0, 0, 0, 1)">
#include </span>&lt;unordered_map&gt;<span style="color: rgba(0, 0, 0, 1)">
#include </span>&lt;cassert&gt;

<span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> cise {

</span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
 * @class Observable
 * @brief 观察者模式中的可观察对象，允许观察者注册、注销和接收通知。
 * 
 * @tparam Event 观察事件的类型，可以是任意可哈希的类型（如枚举、整数、字符串等）。
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
template</span>&lt;typename Event&gt;
<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Observable final {
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    </span><span style="color: rgba(0, 0, 255, 1)">using</span> Handle = <span style="color: rgba(0, 0, 255, 1)">int</span>;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 观察者句柄类型</span>

<span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    Observable() : nextHandle_(</span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) {}

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
     * @brief 添加观察者。
     * 
     * @param event 观察事件的键值。
     * @param callback 观察者的回调函数。
     * @return 返回观察者的句柄，用于后续注销。
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    Handle addObserver(Event </span><span style="color: rgba(0, 0, 255, 1)">event</span>, std::function&lt;<span style="color: rgba(0, 0, 255, 1)">void</span>()&gt;<span style="color: rgba(0, 0, 0, 1)"> callback) {
        std::lock_guard</span>&lt;std::mutex&gt; <span style="color: rgba(0, 0, 255, 1)">lock</span><span style="color: rgba(0, 0, 0, 1)">(mutex_);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查 Handle 是否溢出</span>
        assert(nextHandle_ &lt; std::numeric_limits&lt;Handle&gt;::max() &amp;&amp; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Handle overflow: maximum number of observers reached.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);

        auto</span>&amp; handlers = observers_[<span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">];
        handlers[nextHandle_] </span>=<span style="color: rgba(0, 0, 0, 1)"> std::move(callback);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> nextHandle_++<span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
     * @brief 移除指定事件和句柄的观察者。
     * 
     * @param event 观察事件的键值。
     * @param handle 观察者的句柄。
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">void</span> removeObserver(Event <span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">, Handle handle) {
        std::lock_guard</span>&lt;std::mutex&gt; <span style="color: rgba(0, 0, 255, 1)">lock</span><span style="color: rgba(0, 0, 0, 1)">(mutex_);
        auto it </span>= observers_.find(<span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (it !=<span style="color: rgba(0, 0, 0, 1)"> observers_.end()) {
            it</span>-&gt;<span style="color: rgba(0, 0, 0, 1)">second.erase(handle);
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
     * @brief 移除所有事件下指定句柄的观察者。
     * 
     * @param handle 观察者的句柄。
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> removeObserver(Handle handle) {
        std::lock_guard</span>&lt;std::mutex&gt; <span style="color: rgba(0, 0, 255, 1)">lock</span><span style="color: rgba(0, 0, 0, 1)">(mutex_);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (auto&amp; [<span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">, handlers] : observers_) {
            handlers.erase(handle);
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
     * @brief 通知所有观察指定事件的观察者。
     * 
     * @param event 观察事件的键值。
     * @note 如果某个观察者的回调函数抛出异常，异常会直接传递给调用者。
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">void</span> notifyObservers(Event <span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">) {
        std::lock_guard</span>&lt;std::mutex&gt; <span style="color: rgba(0, 0, 255, 1)">lock</span><span style="color: rgba(0, 0, 0, 1)">(mutex_);
        auto it </span>= observers_.find(<span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (it !=<span style="color: rgba(0, 0, 0, 1)"> observers_.end()) {
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (auto&amp; [handle, callback] : it-&gt;<span style="color: rgba(0, 0, 0, 1)">second) {
                callback();  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 异常会直接传递给调用者</span>
<span style="color: rgba(0, 0, 0, 1)">            }
        }
    }

</span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:</span><span style="color: rgba(0, 128, 0, 1)"><br></span></pre>
<p>&nbsp; &nbsp; &nbsp;// 假设使用者不需要按事件键值有序遍历观察者，因此选择 std::unordered_map 以提高性能。<br>&nbsp; &nbsp; &nbsp;// 如果使用者需要有序遍历，可以将 std::unordered_map 替换为 std::map。</p>
<pre>    std::unordered_map&lt;Event, std::unordered_map&lt;Handle, std::function&lt;<span style="color: rgba(0, 0, 255, 1)">void</span>()&gt;&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> observers_;
    Handle nextHandle_;</span>
    std::mutex mutex_;
<span style="color: rgba(0, 0, 0, 1)">};

}  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> namespace cise</span>

<span style="color: rgba(0, 0, 255, 1)">#endif</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> __OBSERVABLE_H___</span></pre>
</div>
<p>&nbsp;</p>
</div>
<hr>
<h2>3. 设计亮点</h2>
<h3>3.1 线程安全</h3>
<p>使用&nbsp;<code>std::mutex</code>&nbsp;保护共享资源，确保在多线程环境下安全地添加、移除和通知观察者。</p>
<h3>3.2 高性能</h3>
<p>使用&nbsp;<code>std::unordered_map</code>&nbsp;存储观察者，避免了有序遍历的开销，提高了性能。</p>
<h3>3.3 灵活性</h3>
<p>支持任意可哈希的事件类型（如枚举、整数、字符串等），适用于多种场景。</p>
<h3>3.4 异常处理</h3>
<p>将异常直接传递给调用者，遵循“谁调用，谁处理”的原则。</p>
<hr>
<h2>4. 使用示例</h2>
<p>以下是一个简单的使用示例：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">&nbsp;</div>
</div>
</div>
<div class="cnblogs_code">
<pre>#include &lt;iostream&gt;<span style="color: rgba(0, 0, 0, 1)">
#include </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Observable.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>

<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main() {
    cise::Observable</span>&lt;std::<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> observable;

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 添加观察者</span>
    auto handle1 = observable.addObserver(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, []() {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Observer 1: Event 1 triggered!</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> std::endl;
    });

    auto handle2 </span>= observable.addObserver(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event2</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, []() {
        std::cout </span>&lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Observer 2: Event 2 triggered!</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> std::endl;
    });

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 通知观察者</span>
    observable.notifyObservers(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span>);  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出: Observer 1: Event 1 triggered!</span>
    observable.notifyObservers(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event2</span><span style="color: rgba(128, 0, 0, 1)">"</span>);  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出: Observer 2: Event 2 triggered!

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 移除观察者</span>
    observable.removeObserver(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, handle1);
    observable.notifyObservers(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span>);  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 无输出，观察者已移除</span>

    <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
<hr>
<h2>5. 单元测试</h2>
<p>为了确保&nbsp;<code>Observable</code>&nbsp;类的正确性，我们编写了以下单元测试：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">&nbsp;</div>
</div>
</div>
<div class="cnblogs_code">
<pre>#include &lt;gtest/gtest.h&gt;<span style="color: rgba(0, 0, 0, 1)">
#include </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Observable.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>

<span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> cise;

TEST(ObservableTest, AddAndNotifyObserver) {
    Observable</span>&lt;std::<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> observable;

    </span><span style="color: rgba(0, 0, 255, 1)">bool</span> isCalled = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    auto handle </span>= observable.addObserver(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span>, [&amp;<span style="color: rgba(0, 0, 0, 1)">isCalled]() {
        isCalled </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
    });

    observable.notifyObservers(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    EXPECT_TRUE(isCalled);
}

TEST(ObservableTest, RemoveObserverByEvent) {
    Observable</span>&lt;std::<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> observable;

    </span><span style="color: rgba(0, 0, 255, 1)">bool</span> isCalled = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    auto handle </span>= observable.addObserver(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span>, [&amp;<span style="color: rgba(0, 0, 0, 1)">isCalled]() {
        isCalled </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
    });

    observable.removeObserver(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, handle);
    observable.notifyObservers(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    EXPECT_FALSE(isCalled);
}

TEST(ObservableTest, NotifyWithException) {
    Observable</span>&lt;std::<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> observable;

    observable.addObserver(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, []() {
        </span><span style="color: rgba(0, 0, 255, 1)">throw</span> std::runtime_error(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Callback failed</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    });

    EXPECT_THROW(observable.notifyObservers(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">event1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">), std::runtime_error);
}</span></pre>
</div>
<p>Makefile:</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)"># 编译器
CXX </span>= g++<span style="color: rgba(0, 0, 0, 1)">

# 编译选项</span><span style="color: rgba(0, 0, 0, 1)">
CXXFLAGS </span>= -std=c++<span style="color: rgba(128, 0, 128, 1)">11</span> -Wall -Wextra -g -<span style="color: rgba(0, 0, 0, 1)">pthread

# Google Test 路径（根据你的安装路径修改）
GTEST_DIR </span>= /path/to/<span style="color: rgba(0, 0, 0, 1)">gtest

# 目标文件
TARGET </span>=<span style="color: rgba(0, 0, 0, 1)"> observable_test

# 源文件
SRCS </span>= ObservableTest.<span style="color: rgba(0, 0, 255, 1)">cpp</span><span style="color: rgba(0, 0, 0, 1)"> Observable.h

# 编译规则
$(TARGET): $(SRCS)
    $(CXX) $(CXXFLAGS) </span>-isystem $(GTEST_DIR)/include -<span style="color: rgba(0, 0, 0, 1)">I$(GTEST_DIR) \
    $(GTEST_DIR)</span>/libgtest.a $(GTEST_DIR)/<span style="color: rgba(0, 0, 0, 1)">libgtest_main.a \
    $(SRCS) </span>-<span style="color: rgba(0, 0, 0, 1)">o $(TARGET)

# 运行测试
test: $(TARGET)
    .</span>/<span style="color: rgba(0, 0, 0, 1)">$(TARGET)

# 清理
clean:
    </span><span style="color: rgba(0, 0, 255, 1)">rm</span> -f $(TARGET)</pre>
</div>
<h3>示例目录结构</h3>
<p>假设你的项目目录结构如下：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">&nbsp;</div>
<div class="md-code-block-action">
<div class="ds-markdown-code-copy-button">复制</div>
</div>
</div>
</div>
<pre>/project
    ├── Observable.h
    ├── ObservableTest.cpp
    ├── Makefile
    └── /gtest (Google Test 安装路径)</pre>
</div>
<hr>
<h3>运行示例</h3>
<ol start="1">
<li>
<p><strong>编译</strong>：</p>
<div class="md-code-block">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">make</span></pre>
</div>
</div>
</li>
<li>
<p><strong>运行测试</strong>：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">make</span> test</pre>
</div>
</div>
</div>
</div>
</div>
</li>
<li>
<p><strong>清理</strong>：</p>
<div class="md-code-block">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">make</span> clean</pre>
</div>
<p>&nbsp;</p>
</div>
</li>
</ol></div>
<hr>
<h2>6. 总结</h2>
<p>通过本次编程练习，我们实现了一个简单但功能强大的监听者模式类&nbsp;<code>Observable</code>。它不仅支持多线程环境，还具有高性能和灵活性。希望这篇文章能帮助你更好地理解监听者模式，并在实际项目中应用它。</p>
<p>如果你有任何问题或建议，欢迎在评论区留言！</p>
<hr>
<h3>参考资料</h3>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener nofollow" target="_blank">Observer Pattern - Wikipedia</a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/" rel="noopener nofollow" target="_blank">C++ Standard Library Documentation</a></p>
</li>
</ul>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0582612542025462" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 20:50">2025-01-18 20:31</span>&nbsp;
<a href="https://www.cnblogs.com/Rong-">荣--</a>&nbsp;
阅读(<span id="post_view_count">86</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678830" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678830);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678830', targetLink: 'https://www.cnblogs.com/Rong-/p/18678830', title: '编程练习：编写一个监听者模式类' })">举报</a>
</div>
        