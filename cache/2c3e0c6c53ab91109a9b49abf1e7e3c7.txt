
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/guangzan/p/19024969" title="发布于 2025-08-06 14:03">
    <span role="heading" aria-level="2">在 Zustand 中实现 computed 的方式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>注：本文结合本人真实项目实践经验，经过 AI 润色。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>在状态管理领域，计算属性（computed properties）是一个极其重要的概念。MobX 和 Pinia 等库都内置了计算属性功能，允许开发者声明式地定义派生状态。虽然 Zustand 本身没有直接提供 <code>computed</code> API，但这并不意味着我们无法实现类似的功能。</p>
<p>本文将介绍三种在 Zustand 中实现计算属性的优雅方式，包含官方推荐等方案。</p>
<h2 id="方案一derive-zustand">方案一：derive-zustand</h2>
<p><a href="https://github.com/zustandjs/derive-zustand" target="_blank" rel="noopener nofollow">https://github.com/zustandjs/derive-zustand</a> 是 Zustand 官方维护的派生状态库，它提供了一种响应式的方式来处理计算逻辑。</p>
<h3 id="核心优势">核心优势</h3>
<ul>
<li><strong>响应式更新</strong>：自动追踪依赖，当依赖状态变化时自动更新</li>
<li><strong>类型安全</strong>：完美支持 TypeScript 类型推断</li>
<li><strong>性能优化</strong>：避免不必要的重新计算</li>
</ul>
<h3 id="基本用法">基本用法</h3>
<pre><code class="language-ts">import { create, useStore } from 'zustand';
import { derive } from 'derive-zustand';

// 基础 store
const useCountStore = create&lt;{ count: number; inc: () =&gt; void }&gt;((set) =&gt; ({
  count: 0,
  inc: () =&gt; set((state) =&gt; ({ count: state.count + 1 })),
}));

// 派生 store
const doubleCountStore = derive&lt;number&gt;((get) =&gt; get(useCountStore).count * 2);

// 自定义 hook
const useDoubleCountStore = () =&gt; useStore(doubleCountStore);

// 组件中使用
const Counter = () =&gt; {
  const { count, inc } = useCountStore();
  const doubleCount = useDoubleCountStore();
  return (
    &lt;div&gt;
      &lt;div&gt;count: {count}&lt;/div&gt;
      &lt;div&gt;doubleCount: {doubleCount}&lt;/div&gt;
      &lt;button type="button" onClick={inc}&gt;
        +1
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<h3 id="适用场景">适用场景</h3>
<ul>
<li>需要多个组件共享的派生状态</li>
<li>复杂的计算逻辑需要复用</li>
<li>希望保持响应式更新的特性</li>
</ul>
<h2 id="方案二手动维护计算属性">方案二：手动维护计算属性</h2>
<p>对于简单的计算需求，可以直接在 store 中声明派生状态，并在相关操作后手动更新。</p>
<h3 id="实现模式">实现模式</h3>
<pre><code class="language-ts">import { create } from 'zustand';

type CartItem = { id: string; price: number; quantity: number };

type CartState = {
  items: CartItem[];
  total: number; // ← 计算属性
  addItem: (item: Omit&lt;CartItem, 'id'&gt;) =&gt; void;
  updateTotal: () =&gt; void;
};

const useCartStore = create&lt;CartState&gt;((set, get) =&gt; ({
  items: [],
  total: 0,

  addItem: (item) =&gt; {
    set((state) =&gt; ({
      items: [...state.items, { ...item, id: crypto.randomUUID() }],
    }));
    get().updateTotal(); // 添加商品后更新总价
  },

  updateTotal: () =&gt; {
    const newTotal = get().items.reduce(
      (sum, item) =&gt; sum + item.price * item.quantity,
      0
    );
    set({ total: newTotal });
  },
}));
</code></pre>
<h3 id="优缺点分析">优缺点分析</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>不需要额外依赖</li>
<li>逻辑集中，便于维护</li>
<li>更新时机明确可控</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要手动触发更新</li>
<li>可能遗漏更新点</li>
<li>不适合复杂依赖关系</li>
</ul>
<h3 id="最佳实践">最佳实践</h3>
<ul>
<li>为计算属性添加专门的更新方法</li>
<li>在文档中明确标注哪些操作会影响计算属性</li>
<li>考虑使用 <code>immer</code> 简化不可变更新逻辑</li>
</ul>
<h2 id="方案三在组件内派生状态">方案三：在组件内派生状态</h2>
<p>对于简单的、仅限单个组件使用的派生状态，可以直接在组件内部计算。</p>
<h3 id="实现示例">实现示例</h3>
<pre><code class="language-tsx">const UserProfile = () =&gt; {
  const firstName = useUserStore(（s） =&gt; s.firstName);
  const lastName = useUserStore(（s） =&gt; s.lastName);

  const fullName = `${firstName} ${lastName}`;

  return (
    &lt;div&gt;{fullName}&lt;/div&gt;
  );
};
</code></pre>
<h3 id="适用条件">适用条件</h3>
<ul>
<li>派生状态只在一个组件中使用</li>
<li>计算逻辑非常简单</li>
<li>不需要响应式更新（或可以接受组件重新渲染）</li>
</ul>
<h3 id="性能考虑">性能考虑</h3>
<p>当派生计算较复杂时，可以使用 <code>useMemo</code> 优化：</p>
<pre><code class="language-tsx">const expensiveValue = useMemo(() =&gt; {
  return computeExpensiveValue(a, b);
}, [a, b]);
</code></pre>
<h2 id="方案对比与选择指南">方案对比与选择指南</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>复杂度</th>
<th>性能</th>
<th>维护性</th>
</tr>
</thead>
<tbody>
<tr>
<td>derive-zustand</td>
<td>多组件共享的复杂派生状态</td>
<td>中</td>
<td>优</td>
<td>优</td>
</tr>
<tr>
<td>Store 内维护</td>
<td>简单的全局计算属性</td>
<td>低</td>
<td>良</td>
<td>中</td>
</tr>
<tr>
<td>组件内计算</td>
<td>单一组件使用的简单派生</td>
<td>最低</td>
<td>视情况</td>
<td>视情况</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>：</p>
<ol>
<li>优先考虑 derive-zustand，特别是需要响应式更新时</li>
<li>对于简单场景，Store 内维护更轻量</li>
<li>组件内计算适合临时性、局部性的简单逻辑</li>
</ol>
<h2 id="高级技巧组合使用多种方案">高级技巧：组合使用多种方案</h2>
<p>在实际项目中，你可以灵活组合这些方案。例如：</p>
<pre><code class="language-ts">// 使用 derive-zustand 创建基础派生状态
const filteredTodosStore = derive&lt;Todo[]&gt;(get =&gt; {
  const { todos, filter } = get(useTodoStore);
  return todos.filter(todo =&gt; 
    filter === 'all' || 
    (filter === 'completed' &amp;&amp; todo.completed) ||
    (filter === 'active' &amp;&amp; !todo.completed)
  );
});

// 在组件内进一步派生
const TodoStats = () =&gt; {
  const filteredTodos = useStore(filteredTodosStore);
  
  // 组件特有的派生状态
  const completionPercentage = useMemo(() =&gt; {
    if (filteredTodos.length === 0) return 0;
    const completed = filteredTodos.filter(t =&gt; t.completed).length;
    return Math.round((completed / filteredTodos.length) * 100);
  }, [filteredTodos]);

  return &lt;div&gt;完成度: {completionPercentage}%&lt;/div&gt;;
};
</code></pre>
<h2 id="总结与最佳实践">总结与最佳实践</h2>
<p>在 Zustand 中实现计算属性有多种方式，没有绝对的"最佳"方案，关键是根据具体场景选择最合适的：</p>
<ol>
<li><strong>保持简单</strong>：不要过度设计，简单的组件内计算可能就足够了</li>
<li><strong>关注性能</strong>：对于昂贵的计算，使用 memoization 技术</li>
<li><strong>类型安全</strong>：充分利用 TypeScript 确保类型正确</li>
<li><strong>文档说明</strong>：明确标注哪些是计算属性及其依赖关系</li>
<li><strong>测试覆盖</strong>：为重要的计算逻辑添加单元测试</li>
</ol>
<p>Zustand 的灵活性允许你根据项目需求选择最适合的计算属性实现方式，这种设计哲学正是它受到开发者喜爱的原因之一。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-08-06 14:10">2025-08-06 14:03</span>&nbsp;
<a href="https://www.cnblogs.com/guangzan">guangzan</a>&nbsp;
阅读(<span id="post_view_count">1</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19024969);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19024969', targetLink: 'https://www.cnblogs.com/guangzan/p/19024969', title: '在 Zustand 中实现 computed 的方式' })">举报</a>
</div>
        