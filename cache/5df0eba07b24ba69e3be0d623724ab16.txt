
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/blbl-blog/p/19049029" title="发布于 2025-08-20 16:56">
    <span role="heading" aria-level="2">🌐 从零构建高可用 API 网关：鉴权、路由、性能优化全解析</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="-从零构建高可用-api-网关鉴权路由性能优化全解析">🌐 从零构建高可用 API 网关：鉴权、路由、性能优化全解析</h1>
<blockquote>
<p><strong>作者</strong>：古渡蓝按<br>
<strong>技术栈</strong>：Spring Cloud Gateway + redis + Nacos + 自定义鉴权<br>
<strong>技术栈</strong>：微信公众号（深入浅出谈java）<br>
感觉本篇对你有帮助可以关注一下，会不定期更新知识和面试资料、技巧！！！</p>
</blockquote>
<hr>
<h2 id="一引言为什么我们需要-api-网关">一、引言：为什么我们需要 API 网关？</h2>
<p>在微服务架构中，随着服务数量的增加，直接暴露后端服务给客户端会带来诸多问题：</p>
<ul>
<li>❌ <strong>安全隐患</strong>：每个服务都要重复实现鉴权逻辑</li>
<li>❌ <strong>路径混乱</strong>：客户端需要维护多个服务地址</li>
<li>❌ <strong>重复代码</strong>：日志、监控、限流等横切关注点重复开发</li>
<li>❌ <strong>升级困难</strong>：服务变更对客户端影响大</li>
</ul>
<blockquote>
<p><strong>API 网关（API Gateway）</strong> 应运而生，它作为系统的统一入口，承担了 <strong>路由转发、安全控制、协议转换、流量治理</strong> 等核心职责。</p>
</blockquote>
<p>本文将带你从零开始，搭建一个 <strong>支持动态路由、全局鉴权、路径重写、高并发</strong> 的生产级网关服务，并深入剖析其设计思路、调用链路与性能优化策略。</p>
<hr>
<h2 id="二网关的核心作用与典型场景">二、网关的核心作用与典型场景</h2>
<h3 id="1-网关的五大核心能力">1. 网关的五大核心能力</h3>
<table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 路由转发</td>
<td>将请求按规则转发到对应微服务</td>
</tr>
<tr>
<td>✅ 协议转换</td>
<td>HTTP → gRPC、WebSocket 等</td>
</tr>
<tr>
<td>✅ 安全控制</td>
<td>鉴权、防重放、防篡改</td>
</tr>
<tr>
<td>✅ 流量治理</td>
<td>限流、熔断、降级</td>
</tr>
<tr>
<td>✅ 监控审计</td>
<td>请求日志、调用链追踪、QPS 监控</td>
</tr>
</tbody>
</table>
<h3 id="2-典型应用场景">2. 典型应用场景</h3>
<ul>
<li><strong>统一入口</strong>：所有请求走 <code>/api/**</code> 统一入口</li>
<li><strong>安全加固</strong>：防止未授权访问、签名验证、防刷</li>
<li><strong>灰度发布</strong>：根据 Header 路由到不同版本服务</li>
<li><strong>前后端分离</strong>：解决跨域、路径代理</li>
<li><strong>API 聚合</strong>：合并多个接口返回（BFF 模式）</li>
</ul>
<hr>
<h2 id="三技术选型为什么选择-spring-cloud-gateway">三、技术选型：为什么选择 Spring Cloud Gateway？</h2>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Nginx</th>
<th>Zuul 1.x</th>
<th><strong>Spring Cloud Gateway</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>编程模型</td>
<td>配置化</td>
<td>同步阻塞</td>
<td><strong>异步非阻塞（Netty）</strong></td>
</tr>
<tr>
<td>动态路由</td>
<td>需 reload</td>
<td>支持</td>
<td><strong>支持（可对接 Nacos）</strong></td>
</tr>
<tr>
<td>扩展性</td>
<td>有限</td>
<td>一般</td>
<td><strong>高（Filter 机制）</strong></td>
</tr>
<tr>
<td>开发成本</td>
<td>低</td>
<td>低</td>
<td><strong>中（Java 编写）</strong></td>
</tr>
<tr>
<td>适用场景</td>
<td>静态代理</td>
<td>旧项目</td>
<td><strong>微服务网关首选</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>✅ <strong>结论</strong>：SCG 基于 Reactor 和 Netty，性能高、扩展性强，是微服务网关的理想选择。</p>
</blockquote>
<hr>
<h2 id="四架构设计整体架构与模块划分">四、架构设计：整体架构与模块划分</h2>
<div class="mermaid">graph TD
    A[Client] --&gt; B[API Gateway]
    B --&gt; C[Route: /pass/**]
    B --&gt; D[Route: /auth/**]
    B --&gt; E[Route: /file/**]
    
    C --&gt; F[AuthGlobalFilter]
    F --&gt; G[鉴权逻辑]
    G --&gt; H{鉴权成功?}
    H --&gt;|是| I[StripPrefix → 转发]
    H --&gt;|否| J[返回 401]
    
    I --&gt; K[Service A]
    I --&gt; L[Service B]
</div><h3 id="核心模块">核心模块</h3>
<ol>
<li><strong>动态路由模块</strong>：基于 <code>RouteLocator</code> 实现路径匹配</li>
<li><strong>全局过滤器</strong>：<code>GlobalFilter</code> 实现鉴权、日志等</li>
<li><strong>安全模块</strong>：自定义签名验证（HMAC-SHA256）</li>
<li><strong>性能优化</strong>：GZIP、缓存、JVM 调优</li>
</ol>
<h2 id="五核心实现全局鉴权过滤器深度解析">五、核心实现：全局鉴权过滤器深度解析</h2>
<h3 id="1-需求分析">1. 需求分析</h3>
<ul>
<li>✅ 支持 <code>POST</code> 请求体参与签名</li>
<li>✅ 支持 <code>GET</code> 请求参数透传</li>
<li>✅ 防重放攻击（timestamp + nonce）</li>
<li>✅ 签名验证失败返回 <code>401</code></li>
</ul>
<h3 id="2-关键代码authglobalfilter">2. 关键代码：<code>AuthGlobalFilter</code></h3>
<pre><code class="language-java">@Component
public class AuthGlobalFilter implements GlobalFilter, Ordered {

    private final Map&lt;String, String&gt; appSecrets = Map.of("APP_A_001", "your-secret-key-123");

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();

        // 仅拦截 /pass/** 请求
        if (!path.startsWith("/pass/")) {
            return chain.filter(exchange);
        }

        // 读取并缓存请求体（关键！保证 body 可重复读）
        return DataBufferUtils.join(request.getBody())
                .flatMap(dataBuffer -&gt; {
                    byte[] bodyBytes = new byte[dataBuffer.readableByteCount()];
                    dataBuffer.read(bodyBytes);
                    DataBufferUtils.release(dataBuffer);

                    String body = new String(bodyBytes, StandardCharsets.UTF_8);
                    exchange.getAttributes().put("cachedRequestBody", body);

                    // 重新包装 request，保证 body 能转发到下游
                    Flux&lt;DataBuffer&gt; cachedBodyFlux = Flux.defer(() -&gt; 
                        Mono.just(exchange.getResponse().bufferFactory().wrap(bodyBytes))
                    );

                    ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator(request) {
                        @Override
                        public Flux&lt;DataBuffer&gt; getBody() {
                            return cachedBodyFlux;
                        }
                    };

                    ServerWebExchange newExchange = exchange.mutate().request(mutatedRequest).build();

                    // 执行鉴权
                    return performAuthentication(newExchange, body)
                            .then(Mono.defer(() -&gt; chain.filter(newExchange)))
                            .onErrorResume(ex -&gt; {
                                if (ex instanceof AuthenticationException) {
                                    return onError(exchange.getResponse(), ex.getMessage(), HttpStatus.UNAUTHORIZED);
                                }
                                return onError(exchange.getResponse(), "Internal error", HttpStatus.INTERNAL_SERVER_ERROR);
                            });
                })
                .switchIfEmpty(chain.filter(exchange)); // GET 请求直接放行
    }

    private Mono&lt;Void&gt; performAuthentication(ServerWebExchange exchange, String body) {
        ServerHttpRequest request = exchange.getRequest();

        String appId = request.getHeaders().getFirst("X-Pass-AppId");
        String timestampStr = request.getHeaders().getFirst("X-Pass-Timestamp");
        String nonce = request.getHeaders().getFirst("X-Pass-Nonce");
        String sign = request.getHeaders().getFirst("X-Pass-Sign");

        // 省略参数校验...

        String secret = appSecrets.get(appId);
        if (secret == null) {
            return onError(exchange.getResponse(), "Invalid AppId", HttpStatus.UNAUTHORIZED);
        }

        // 验证时间戳（5分钟内）
        try {
            long timestamp = Long.parseLong(timestampStr);
            long now = Instant.now().getEpochSecond();
            if (Math.abs(now - timestamp) &gt; 300) {
                return onError(exchange.getResponse(), "Timestamp expired", HttpStatus.UNAUTHORIZED);
            }
        } catch (NumberFormatException e) {
            return onError(exchange.getResponse(), "Invalid timestamp", HttpStatus.UNAUTHORIZED);
        }

        // ✅ 使用 path + body + timestamp + nonce 生成签名
        String contentToSign = request.getURI().getPath() + body + timestampStr + nonce;
        String expectedSign = SignUtil.sign(contentToSign, secret);

        if (!expectedSign.equalsIgnoreCase(sign)) {
            return onError(exchange.getResponse(), "Invalid signature", HttpStatus.UNAUTHORIZED);
        }

        return Mono.empty();
    }

    private Mono&lt;Void&gt; onError(ServerHttpResponse response, String msg, HttpStatus status) {
        response.setStatusCode(status);
        response.getHeaders().add("Content-Type", "application/json");
        String body = String.format("{\"code\": %d, \"message\": \"%s\"}", status.value(), msg);
        return response.writeWith(Mono.just(response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8))));
    }

    @Override
    public int getOrder() {
        return -1; // 优先执行
    }
}
</code></pre>
<h3 id="3-关键设计点">3. 关键设计点</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>❓ <code>POST</code> 请求体只能读一次</td>
<td><code>DataBufferUtils.join()</code> 缓存 body</td>
</tr>
<tr>
<td>❓ 缓存后如何转发到下游</td>
<td><code>ServerHttpRequestDecorator</code> 包装 request</td>
</tr>
<tr>
<td>❓ <code>GET</code> 请求如何处理</td>
<td><code>switchIfEmpty(chain.filter(exchange))</code> 直接放行</td>
</tr>
<tr>
<td>❓ 鉴权失败如何中断</td>
<td><code>onErrorResume</code> 返回错误响应</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="六调用链路一次请求的完整旅程">六、调用链路：一次请求的完整旅程</h2>
<p>以 <code>POST /pass/test/create</code> 为例：</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202508/2719585-20250820164745858-1692593289.png" alt="image-20250814154631800" loading="lazy"></p>
<h3 id="详细请求路径分析">详细请求路径分析</h3>
<ol>
<li>请求进入网关<br>
↓</li>
<li>RoutePredicateHandlerMapping：匹配路由<br>
↓</li>
<li>FilteringWebHandler：执行 GlobalFilter 和 GatewayFilter<br>
↓</li>
<li>路由转发到目标地址（如 <a href="http://www.baidu.com/order/16%EF%BC%89" target="_blank" rel="noopener nofollow">http://www.baidu.com/order/16）</a></li>
</ol>
<p>我们一步步来看：</p>
<h3 id="-步骤-1路由匹配route-matching">🔹 步骤 1：路由匹配（Route Matching）</h3>
<ul>
<li>
<p>网关会从所有可用的 <code>RouteDefinition</code> 中查找匹配的路由。</p>
</li>
<li>
<p>你的两个路由源都会被加载：</p>
</li>
<li>
<p>来自 <code>CustomRouteConfig</code>：<code>Path=/pass/order/**</code> → <code>http://www.baidu.com</code></p>
<ul>
<li>来自 <code>application.yml</code>：<code>Path=/pass/**</code> → <code>http://localhost:8080</code></li>
</ul>
</li>
<li>
<p>由于 <code>/pass/order/**</code> 是更具体的路径，它会优先匹配（前提是 <code>order</code> 设置合理）。</p>
</li>
<li>
<p>匹配成功后，生成一个Route对象，包含：</p>
</li>
</ul>
<pre><code>  ID: `order_route`
  URI: `http://www.baidu.com`
  Predicates: `Path=/pass/order/**`
  Filters: （如果有）
</code></pre>
<h3 id="-步骤-2执行-globalfilterauthglobalfilter">🔹 步骤 2：执行 <code>GlobalFilter</code>（AuthGlobalFilter）</h3>
<ul>
<li>
<p>匹配路由后，网关进入过滤器链。</p>
</li>
<li>
<p><code>AuthGlobalFilter</code> 是 <code>GlobalFilter</code>，它的 <code>filter()</code> 方法会被调用</p>
</li>
<li>
<blockquote>
<p>✅ 此时，<strong>请求路径 <code>/pass/order/16</code> 被用于路由匹配</strong>，但 <code>CustomRouteConfig</code> 本身 <strong>不会主动收到这个请求信息</strong>。</p>
</blockquote>
<hr>
</li>
</ul>
<pre><code class="language-java">public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    ServerHttpRequest request = exchange.getRequest();
    String path = request.getURI().getPath(); // → "/pass/order/16"
    ...
}
</code></pre>
<p>✅ 在这里，你可以获取到完整的请求信息，包括：</p>
<ul>
<li>路径：<code>/pass/order/16</code></li>
<li>Header：<code>X-Pass-AppId</code>, <code>X-Pass-Sign</code> 等</li>
<li>方法：GET/POST</li>
<li>查询参数等</li>
</ul>
<p>👉 <strong>这是你做鉴权的正确位置。</strong></p>
<hr>
<h3 id="-步骤-3路由转发">🔹 步骤 3：路由转发</h3>
<ul>
<li>
<p>鉴权通过后，<code>chain.filter(exchange)</code> 继续执行。</p>
</li>
<li>
<p>网关根据 <code>Route</code> 中的 <code>uri</code>（<code>http://www.baidu.com</code>）和 <code>predicates</code> 进行转发。</p>
</li>
<li>
<p>最终请求被转发为：</p>
<pre><code>GET http://www.baidu.com/order/16
</code></pre>
</li>
</ul>
<h2 id="七请求调试">七、请求调试</h2>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202508/2719585-20250820164921932-1609838604.png" alt="image-20250820151406974" loading="lazy"></p>
<p>网关日志打印日志</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202508/2719585-20250820165014232-1502786568.png" alt="image-20250820151040396" loading="lazy"></p>
<p>下游系统</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202508/2719585-20250820165035203-120572745.png" alt="image-20250820151336602" loading="lazy"></p>
<h2 id="八总结">八、总结</h2>
<p>本文从零搭建了一个生产级 API 网关，实现了：</p>
<ul>
<li>✅ 基于路径的动态路由</li>
<li>✅ 支持 Body 参与签名的全局鉴权</li>
<li>✅ GET/POST 请求兼容处理</li>
<li>✅ 高并发性能优化</li>
</ul>
<blockquote>
<p><strong>网关不是简单的“转发器”，而是微服务架构的“安全门”与“流量调度中心”</strong>。</p>
</blockquote>
<p>通过合理设计与优化，即使是 2核4G 的机器，也能扛住上千 QPS，为业务保驾护航。</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-20 16:57">2025-08-20 16:56</span>&nbsp;
<a href="https://www.cnblogs.com/blbl-blog">古渡蓝按</a>&nbsp;
阅读(<span id="post_view_count">179</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19049029);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19049029', targetLink: 'https://www.cnblogs.com/blbl-blog/p/19049029', title: '&amp;#127760; 从零构建高可用 API 网关：鉴权、路由、性能优化全解析' })">举报</a>
</div>
	