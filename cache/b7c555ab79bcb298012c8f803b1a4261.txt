
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18964725" title="发布于 2025-07-20 19:16">
    <span role="heading" aria-level="2">数论计算必吃榜之『模数乘法逆元』</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>有模数的乘法逆元是数论计算中的一个基本概念。在日常生活与科学计算中，我们早已习惯了实数域（<span class="math inline">\(\mathbb{R}\)</span>）里“倒数”这一直观概念：给定一个非零实数 <span class="math inline">\(a\)</span>，总能找到唯一的数 <span class="math inline">\(a^{-1}\)</span>，使得</p>
<p></p><div class="math display">\[a \times a^{-1} = 1.
\]</div><p></p><p>二的乘法逆元是二分之一，九的乘法逆元是九分之一。“对称”的倒数符合我们的直觉。</p>
<p>现在我们将目光转向离散的模数世界——也就是在某个正整数 <span class="math inline">\(m\)</span> 下考察整数的运算时，情况便多了几分趣味与挑战。此时的“模 <span class="math inline">\(m\)</span>”把大大小小的整数都“折叠”进 <span class="math inline">\(\{0,1,\dots,m-1\}\)</span> 之中，相加相乘后再取余，使数尽其用而不溢出。此时：若对某个整数 <span class="math inline">\(a\)</span> 存在 <span class="math inline">\(b\)</span>，使得</p>
<p></p><div class="math display">\[a \times b \equiv 1 \pmod m,
\]</div><p></p><p>那么 <span class="math inline">\(b\)</span> 就是 <span class="math inline">\(a\)</span> 在『模 <span class="math inline">\(m\)</span> 』下的『乘法逆元』（乘法可以交换，当然 <span class="math inline">\(a\)</span> 也是 <span class="math inline">\(b\)</span> 的逆元）。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>元素集合</th>
<th>乘法单位</th>
<th>逆元定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(\mathbb R\)</span></td>
<td>所有实数</td>
<td><span class="math inline">\(1\)</span></td>
<td>对 <span class="math inline">\(a\neq0\)</span>，都存在唯一 <span class="math inline">\(a^{-1}\in\mathbb R\)</span>，使 <span class="math inline">\(a a^{-1}=1\)</span>。</td>
</tr>
<tr>
<td><span class="math inline">\(\mathbb Z\)</span></td>
<td>所有整数</td>
<td><span class="math inline">\(1\)</span></td>
<td>仅 <span class="math inline">\(\pm1\)</span> 有逆元（是自身）。</td>
</tr>
<tr>
<td>整数模环</td>
<td><span class="math inline">\(\{0,\dots,m-1\}\)</span></td>
<td><span class="math inline">\(1\pmod m\)</span></td>
<td>若存在 <span class="math inline">\(b\)</span> 使 <span class="math inline">\(ab\equiv1\pmod m\)</span>，则 <span class="math inline">\(b\)</span> 是 <span class="math inline">\(a\)</span> 的乘法逆元。（本文主题）</td>
</tr>
</tbody>
</table>
<h2 id="乘法逆元的基本知识">乘法逆元的基本知识</h2>
<h3 id="逆元的存在和唯一性">逆元的存在和唯一性</h3>
<p>在有限模数的圆环里，“乘法逆元”是否存在呢？大概是怎么样？</p>
<p><strong>质数模数，人人可逆</strong>。当模数是质数 <span class="math inline">\(p\)</span> 时，<span class="math inline">\(\mathbb Z/p\mathbb Z\)</span> 恰好形成一个有限域。除了 <span class="math inline">\(0\)</span>，每个元素都与 <span class="math inline">\(p\)</span> 互质，此时每一个元素都存在唯一逆元。</p>
<ul>
<li>存在性：有许多证明方式。可通过后文逆元的求解来理解。</li>
<li>唯一性：假设 <span class="math inline">\(ab\equiv ac\equiv1\pmod p\)</span>，则 <span class="math inline">\(p\mid a(b-c)\)</span>。因 <span class="math inline">\(p\nmid a\)</span>，故 <span class="math inline">\(p\mid(b-c)\Rightarrow b\equiv c\)</span>。</li>
</ul>
<p>此时我们发现，除了 <span class="math inline">\(0\)</span> 没有逆元，剩下的所有数都存在逆元，并且要么就是自身( <span class="math inline">\(1\)</span> 和 <span class="math inline">\(p-1\)</span>)，要么两两成对（其他）。</p>
<p></p><div class="math display">\[\begin{array}{c|cccccccccc}
a &amp; 1 &amp; \color{red}{2} &amp; \color{green}{3} &amp; \color{green}{4} &amp; \color{blue}{5} &amp; \color{red}{6} &amp; \color{gold}{7} &amp; \color{gold}{8} &amp; \color{blue}{9} &amp; 10 \\ \hline
a^{-1}\!\bmod 11 &amp; 1 &amp; \color{red}{6} &amp; \color{green}{4} &amp; \color{green}{3} &amp; \color{blue}{9} &amp; \color{red}{2} &amp; \color{gold}{8} &amp; \color{gold}{7} &amp; \color{blue}{5} &amp; 10
\end{array}
\]</div><p></p><p>质数模数带来的普适可逆性，使其成为密码学与竞赛算法的主战场，是我们主要的讨论对象。</p>
<p><strong>合数模数，互质才配拥有“镜像”</strong>。若 <span class="math inline">\(m\)</span> 为合数，“有逆元”不再是天生权利，而是需通过互质性考核：</p>
<p></p><div class="math display">\[\text{存在逆元 }\Leftrightarrow \gcd(a,m)=1.
\]</div><p></p><ul>
<li>必要性：若 <span class="math inline">\(ab\equiv1\pmod m\)</span>，则 <span class="math inline">\(m\mid ab-1\)</span>。若 <span class="math inline">\(d=\gcd(a,m)&gt;1\)</span>，则 <span class="math inline">\(d\mid (ab-1)\)</span> 与 <span class="math inline">\(d\mid ab\)</span>，从而 <span class="math inline">\(d\mid1\)</span>，矛盾。</li>
<li>充分性：互质时，可和质数模数一样求解。如由扩展欧几里得算法。</li>
</ul>
<p></p><div class="math display">\[\begin{array}{c|ccccccccccccc}
a &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 \\ \hline
a^{-1}\!\bmod 14 
&amp; 1 &amp; - &amp; 5 &amp; - &amp; 3 &amp; - &amp; - &amp; - &amp; 5 &amp; - &amp; 11 &amp; - &amp; 13
\end{array}
\]</div><p></p><blockquote>
<p><strong>零元素</strong>永远没有逆元，因为 <span class="math inline">\(0\times b\equiv0\neq1\)</span>。后文就忽略掉它了。</p>
</blockquote>
<h3 id="乘性积性">乘性（积性）</h3>
<p>对任意两数 <span class="math inline">\(a,b\)</span> 与模 <span class="math inline">\(m\)</span>，若均与 <span class="math inline">\(m\)</span> 互质，则</p>
<p></p><div class="math display">\[(ab)^{-1}\equiv a^{-1}\,b^{-1}\pmod m.
\]</div><p></p><p>证明，直接验证：</p>
<p></p><div class="math display">\[(ab)\left(a^{-1}b^{-1}\right)\equiv (aa^{-1})(bb^{-1})\equiv 1\pmod m,
\]</div><p></p><p>且唯一性保证这就是 <span class="math inline">\((ab)^{-1}\)</span>。这就是“乘积的逆元等于逆元的乘积”。</p>
<p><strong>启示</strong></p>
<ul>
<li>批量计算时可将“大块”拆为小块求逆，再相乘。</li>
<li>在算法分析里，可把分数连乘化简为“所有分子相乘 × 所有分母逆元相乘”，大大减轻运算量。</li>
</ul>
<h3 id="其他性质">其他性质</h3>
<p><strong>逆元的逆元（显然）</strong></p>
<p></p><div class="math display">\[\left(a^{-1}\right)^{-1}\equiv a\pmod m.
\]</div><p></p><p><strong>消去律</strong><br>
若 <span class="math inline">\(\gcd(a,m)=1\)</span>，则“乘 <span class="math inline">\(a\)</span>”在模 <span class="math inline">\(m\)</span> 上是一个双射，可自由左右“消去”：</p>
<p></p><div class="math display">\[ab\equiv ac\pmod m\quad\Longrightarrow\quad b\equiv c\pmod m.
\]</div><p></p><p>这使得线性同余方程</p>
<p></p><div class="math display">\[ax\equiv b\pmod m
\]</div><p></p><p>可直接解为</p>
<p></p><div class="math display">\[x \equiv a^{-1} b \pmod m,
\]</div><p></p><p>有了这么多优秀性质，乘法逆元真的就像我们的除法分数一样，在整数域运算，却简洁如在实数域中除以 <span class="math inline">\(a\)</span>。</p>
<h3 id="乘法单位群的群律视角">乘法单位群的群律视角</h3>
<p>记</p>
<p></p><div class="math display">\[U_m=(\mathbb Z/m\mathbb Z)^\times.
\]</div><p></p><p>则 <span class="math inline">\((U_m,\,\times)\)</span> 满足<strong>封闭性、结合律、单位元 1、逆元存在</strong>，构成一个有限群。若 <span class="math inline">\(m\)</span> 为质数，<span class="math inline">\(U_m\)</span> 甚至是循环群。</p>
<h2 id="求解一个数的乘法逆元">求解一个数的乘法逆元</h2>
<p>在实际应用中，求逆元总不可能一个一个枚举，我们需要利用数学性质高效地“开出”逆元。</p>
<h3 id="扩展欧几里得算法extended-euclid">扩展欧几里得算法（Extended Euclid）</h3>
<p>只需 <span class="math inline">\(\gcd(a,m)=1\)</span>（不要求 <span class="math inline">\(m\)</span> 为素数）。</p>
<p>由于满足互质条件，用扩展欧几里得求出整数解 <span class="math inline">\((x,y)\)</span> 使</p>
<p></p><div class="math display">\[   ax + my = 1.
\]</div><p></p><p>我们发现，按照定义来说则 <span class="math inline">\(x\)</span> 就是 <span class="math inline">\(a\)</span> 的一个逆元模 <span class="math inline">\(m\)</span>，取其最小非负剩余：</p>
<p></p><div class="math display">\[   a^{-1} \equiv x \bmod m.
\]</div><p></p><pre><code class="language-text">function ext_gcd(a, b):
    if b == 0: return (1, 0, a)
    (x1, y1, g) = ext_gcd(b, a mod b)
    x = y1
    y = x1 - ⌊a/b⌋ * y1
    return (x, y, g)

// 主流程
(x, y, g) = ext_gcd(a, m)
if g != 1: no inverse
inv = (x mod m + m) mod m // 确保取最小的非负剩余。而非得到负数
</code></pre>
<p>时间复杂度 <span class="math inline">\(O(\log m)\)</span>（欧几里得算法的复杂度），因每次递归将参数规模至少减半。通用、稳定，适合任意大整数与合数模数场景。</p>
<h3 id="费马小定理与欧拉定理乘方法">费马小定理与欧拉定理乘方法</h3>
<p>如果模数是质数 <span class="math inline">\(p\)</span>，那么由<strong>费马小定理</strong> $a^{p-1}\equiv 1\pmod p $ 可以得出：</p>
<p></p><div class="math display">\[  a^{-1}\equiv a^{p-2}\pmod p.
\]</div><p></p><p>我们直接计算这个幂就可以得到答案。</p>
<p>如果模数不保证是质数，更一般的<strong>欧拉定理</strong> $a^{\varphi(m)}\equiv 1\pmod p $ 可以得出：</p>
<p></p><div class="math display">\[    a^{-1}\equiv a^{\varphi(m)-1}\pmod m,
\]</div><p></p><p>其中 <span class="math inline">\(\varphi(m)\)</span> 为欧拉函数。这样仅要求 <span class="math inline">\(\gcd(a,m)=1\)</span>。</p>
<p>使用快速幂求解幂次，复杂度通常为 <span class="math inline">\(O(\log m)\)</span>。若模数是合数，再加上 <span class="math inline">\(O(\sqrt m)\)</span> 的时间求欧拉函数。</p>
<h2 id="求解多个数的乘法逆元">求解多个数的乘法逆元</h2>
<h3 id="质数域下的连续递推法">质数域下的连续递推法</h3>
<p>若模数 <span class="math inline">\(p\)</span> 为素数，而我们需要求出所有从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(p-1\)</span> 的逆元，那么有一个递推公式可以解决此问题，一次遍历搞定——时间复杂度仅为 <span class="math inline">\(O(p)\)</span>。这比 <span class="math inline">\(O(p\log p)\)</span> 一个一个求解的多次快速幂或扩展欧几里得快得多。</p>
<ol>
<li>
<p>初始化，用 <span class="math inline">\(\mathrm{inv}\)</span> 表示一个数的逆元，那么</p>
<p></p><div class="math display">\[  \mathrm{inv}[1] = 1.
\]</div><p></p></li>
<li>
<p>对于每个 <span class="math inline">\(2 \le i \le p-1\)</span>，因为</p>
<p></p><div class="math display">\[p = \bigl\lfloor\tfrac p i\bigr\rfloor\cdot i + (p\bmod i)
\;\Longrightarrow\;
(p\bmod i)\equiv -\bigl\lfloor\tfrac p i\bigr\rfloor\,i\pmod p.
\]</div><p></p><p>左右都乘以 <span class="math inline">\(\mathrm{inv}[p \bmod i]\times\mathrm{inv}[i]\)</span>，得到</p>
<p></p><div class="math display">\[ \mathrm{inv}[i]
 \equiv - \lfloor\tfrac p i\rfloor \times \mathrm{inv}\!\bigl[p \bmod i\bigr]\pmod p.
\]</div><p></p><p>为了保证结果为正，改写为</p>
<p></p><div class="math display">\[  \mathrm{inv}[i]
  = \bigl(p - \lfloor\tfrac p i\rfloor \bigr)\times \mathrm{inv}\!\bigl[p \bmod i\bigr]\;\bmod p.
\]</div><p></p></li>
</ol>
<p>这就意味着，可以总是用已推出的 <span class="math inline">\(\mathrm{inv}[p \bmod i]\)</span> 来计算 <span class="math inline">\(\mathrm{inv}[i]\)</span>。模数是素数保证了每个逆元的存在性（若模数为合数则此方法不可用）。</p>
<pre><code class="language-text">// 仅适用于素数模 p
inv[1] = 1
for i = 2 to p-1:
    inv[i] = (p - (p // i)) * inv[p mod i] mod p
// 结束后 inv[i] 即为 i^{-1} mod p
</code></pre>
<p>显然这样的时间是 <span class="math inline">\(O(p)\)</span>，空间也是 <span class="math inline">\(O(p)\)</span>。此法特别适合当你固定素数模 <span class="math inline">\(p\)</span>，需要预处理所有小于 <span class="math inline">\(p\)</span> 的逆元供后续 <span class="math inline">\(O(1)\)</span> 查表时使用。</p>
<h3 id="离线批量求逆元">离线批量求逆元</h3>
<p>如果要求多个较大且并不连续的逆元，上面的方法就不再可用，但是其实还有办法批量离线处理来加速计算。只需一次求逆和 <span class="math inline">\(O(n)\)</span> 次乘法，就能在 <span class="math inline">\(O(n + \log m)\)</span> 时间内完成所有逆元计算。</p>
<ul>
<li>
<p>令输入序列为 <span class="math inline">\(\{a_1,a_2,\dots,a_n\}\)</span>，我们要求他们每个数的逆元。这个方法需要用到逆元的积性，所以首先构造前缀积数组</p>
<p></p><div class="math display">\[  P_0 = 1,\quad P_i = a_1a_2\cdots a_i \bmod m,\quad i=1\ldots n.
\]</div><p></p></li>
<li>
<p>仅对 <span class="math inline">\(P_n = a_1a_2\cdots a_n\)</span> 调用一次逆元算法，得到</p>
<p></p><div class="math display">\[  R_n = P_n^{-1} \bmod m.
\]</div><p></p></li>
<li>
<p>为了得到所有数的逆元，再倒过来枚举，逆序计算每个 <span class="math inline">\(a_i^{-1}\)</span>：</p>
<p></p><div class="math display">\[  a_i^{-1} \;=\; R_i \, P_{i-1} \bmod m,\quad i=n,n-1,\dots,1.
\]</div><p></p><p>其中 <span class="math inline">\(R_i\)</span> 表示从后缀开始累积的逆元乘积，初始 <span class="math inline">\(R_{n}=P_{n}^{-1}\)</span>，然后也由递推计算</p>
<p></p><div class="math display">\[  R_{i-1} = R_i \times a_i \bmod m,\quad i=n,n-1,\dots,1.
\]</div><p></p></li>
</ul>
<pre><code class="language-text">// 输入: a[1..n], 模数 m，且 ∀i: gcd(a[i], m)=1
P[0] = 1
for i = 1 to n:
    P[i] = P[i-1] * a[i] mod m

// 一次求逆
R = inverse(P[n], m)  // 用扩展欧几里得或快速幂

// 逆序还原
for i = n down to 1:
    inv[i] = R * P[i-1] mod m
    R = R * a[i] mod m

return inv[1..n]
</code></pre>
<p>时间复杂度：构造前缀积和逆序还原显然 <span class="math inline">\(O(n)\)</span>；一次求逆花费<span class="math inline">\(O(\log m)\)</span>；总计 <span class="math inline">\(O(n + \log m)\)</span>。空间复杂度 <span class="math inline">\(O(n)\)</span>。不要求质数模数，但要求逆元必须存在（所有 <span class="math inline">\(a_i\)</span> 必须与 <span class="math inline">\(m\)</span> 互质）。</p>
<p>本方案适合大批量逆元需求。将“逆元”操作的整体成本降至与单次求逆相近。</p>
<h2 id="用逆元进行有理数取模">用逆元进行有理数取模</h2>
<p>借助乘法逆元，我们现在不仅能对整数取模，还能给有理数取模。对于有理数 <span class="math inline">\(\dfrac{a}{b}\)</span>（其中 <span class="math inline">\(a,b\)</span> 可先取 $ \bmod\ m$），若 <span class="math inline">\(\gcd(b,m)=1\)</span> 则有</p>
<p></p><div class="math display">\[\frac{a}{b} \bmod m
\;=\;
a \times b^{-1} \bmod m.
\]</div><p></p><p>这里的 <span class="math inline">\(b^{-1}\)</span> 就是前面各节讨论的“乘法逆元”。</p>
<ul>
<li><strong>分母须可逆</strong>：仅当 <span class="math inline">\(\gcd(b,m)=1\)</span> 时，才存在 <span class="math inline">\(b^{-1}\pmod m\)</span>。</li>
<li><strong>分子可任意</strong>：对 <span class="math inline">\(a\)</span> 先做 <span class="math inline">\(a \bmod m\)</span>，再与 <span class="math inline">\(b^{-1}\)</span> 相乘。</li>
</ul>
<p>如果 <span class="math inline">\(\gcd(b,m)&gt;1\)</span>，则 <span class="math inline">\(\tfrac{a}{b}\bmod m\)</span> 无意义——分母无论如何消不去。</p>
<p>例题：计算 <span class="math inline">\(\frac{3}{4}\bmod7\)</span></p>
<ul>
<li>
<p>先求 <span class="math inline">\(4^{-1}\bmod7\)</span>。因 <span class="math inline">\(4\times2\equiv1\pmod7\)</span>，故 <span class="math inline">\(4^{-1}=2\)</span>。</p>
</li>
<li>
<p>再计算：</p>
<p></p><div class="math display">\[  \frac{3}{4}\bmod7 = 3 \times 2 \bmod7 = 6.
\]</div><p></p></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.015277777777777777" data-date-updated="2025-07-20 19:38">2025-07-20 19:16</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">39</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18964725);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18964725', targetLink: 'https://www.cnblogs.com/ofnoname/p/18964725', title: '数论计算必吃榜之『模数乘法逆元』' })">举报</a>
</div>
        