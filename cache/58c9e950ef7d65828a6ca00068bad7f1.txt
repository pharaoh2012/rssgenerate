
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/comsoi/p/18738485" title="发布于 2025-02-26 15:18">
    <span role="heading" aria-level="2">Linux 环境变量指北</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>&nbsp;</p>
<header id="title-block-header">
<h1 class="title">Linux 环境变量指北</h1>
</header><nav id="TOC" role="doc-toc">
<ul>
<li><a id="toc-一终端login-shell" href="#一终端login-shell" rel="noopener nofollow">一、终端：Login Shell</a></li>
<li><a id="toc-二systemd-的配置方式" href="#二systemd-的配置方式" rel="noopener nofollow">二、Systemd 的配置方式</a></li>
<li><a id="toc-三图形界面" href="#三图形界面" rel="noopener nofollow">三、图形界面</a>
<ul>
<li><a id="toc-dmdisplay-manager-显示管理器" href="#dmdisplay-manager-显示管理器" rel="noopener nofollow">DM(Display Manager) 显示管理器</a></li>
<li><a id="toc-dedesktop-environment-桌面环境" href="#dedesktop-environment-桌面环境" rel="noopener nofollow">DE(Desktop Environment) 桌面环境</a></li>
</ul>
</li>
</ul>
</nav>
<p>作为Linux用户一定遇到过这样的场景：在终端里配置好的环境变量，一打开图形界面就“神秘失踪”；或者在KDE下正常的程序，换到GNOME却死活读不到<code>JAVA_HOME</code>。这背后的原因，往往与环境变量的加载机制在不同场景下的差异有关。</p>

<p>Linux 系统启动流程</p>
<p><img src="https://img2024.cnblogs.com/blog/3093851/202502/3093851-20250226162032929-378281062.svg" alt=""></p>
<h2 id="一终端login-shell">一、终端：Login Shell</h2>
<p>Unix shell 是为 Unix 和类 Unix 系统提供传统用户界面的命令行解释器或 shell，通过执行用户输入的命令文本，或包含命令的文本脚本来指导计算机的运行。</p>
<p>兼容 Bourne Shell 的 Shell 有：Bash、Zsh 等。其他类型的 Shell 有：Fish、PowerShell、nushell 等。</p>
<p>环境变量提供了一种在多个程序和进程间共享配置的简单方式。 在 Windows 中，通过 GUI 的方式设置全局环境变量非常方便。 而在 Linux 中，通过 Login Shell 配置环境变量是一种常见的做法，虽然原始，但是功能更加强大。</p>
<p>在 linux 下，图形界面启动的终端通常是 <strong>Non-Login Shell</strong>（不通过 <code>bash --login</code> 启动），只会读取<code>~/.bashrc</code>（交互式配置），而不会触发对应Login Shell的初始化流程。 因此，了解 Login Shell 对于设置环境变量非常重要。</p>
<p>当你通过SSH登录服务器，或是在物理机上按下<code>Ctrl+Alt+F5</code>进入文本终端时，系统会启动一个 <strong>Login Shell</strong>。</p>
<p>Login Shell 是一种调用模式，在这种模式下，Shell 读取一次性初始化文件。 例如兼容 Bourne Shell 的 Shell 会读取系统范围的 <code>/etc/profile</code>、用户的 <code>~/.profile</code>(sh)/<code>.bash_profile</code>(bash)/<code>.zprofile</code>(zsh) 或其他 dotfiles。 在登录时， <code>/etc/profile</code> 会读取 <code>/etc/profile.d/</code> 中任何可读的 *.sh 文件：这些脚本不需要 shebang，也不需要具有可执行权限。它们用于设置环境并定义特定于应用程序的设置。</p>
<p>这些文件（dotfiles）将会设置初始环境，且会被所有从 Shell 启动的进程继承。 因此，其应当只在会话开始（登陆）时读取一次。 例如，在控制台或通过 SSH 登录、使用 <code>--login</code> 参数通过 sudo 或 su 切换用户、手动调用 Login Shell（例如，通过 <code>bash --login</code>）。</p>
<p>不同的发行版使用的 <code>/bin/sh</code> 可能不同，例如 Debian 系默认使用 <code>dash</code>，而 Arch 系默认使用 <code>bash</code>。 在 <code>~/.bash_profile</code>、<code>~/.zprofile</code> 中引用 <code>~/.profile</code>，并统一在 <code>~/.profile</code> 中设置环境变量，可以保证在不同的情况（greetd、uwsm 只使用 sh）下都能生效。</p>
<p>Zsh 和 Bash 有一定的相似性，主要区别在于 Bash 将 Login shell 的启动文件与交互式（interactive）shell 分开。 正如 <a href="https://wiki.debian.org/DotFiles" rel="noopener nofollow">Debian wiki</a> 页面所解释的那样：</p>
<blockquote>
<p>那么，为什么 .bashrc 是独立于 .bash_profile 的文件呢？ 这样做主要是由于历史原因，当时的机器与今天的工作站相比非常慢。 处理 <code>.profile</code> 或 <code>.bash_profile</code> 中的命令可能需要相当长的时间，尤其是在大量工作必须由外部命令完成的机器上。 因此，困难的初始设置命令（创建可以传递给子进程的环境变量）被置于.bash_profile。 未继承的临时设置和别名被放在 .bashrc 中，以便每个 subshell 都可以重新读取它们。</p>
</blockquote>
<p>虽然说通常情况下<strong><em>交互式的</em></strong>（Interactive） Login Shell（<code>bash -li</code>）不怎么会被用到，但是在一些特殊情况下，比如通过 SSH 登录服务器，或者在 tty 中切换用户，或者是使用 macOS 系统，这种情况下就会用到 Interactive Login Shell。</p>
<p>标准的解决方法是<strong>始终</strong>在 <code>.bash_profile</code> 文件末尾包含类似于以下命令的内容：</p>
<div id="cb1" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code>[[ -f "${HOME}/.profile" ]] &amp;&amp; . "${HOME}/.profile"
[[ -f "${HOME}/.bashrc" ]] &amp;&amp; . "${HOME}/.bashrc"</code></pre>
</div>
<p>zsh 下，无论是否是 Login Shell，都会加载交互式配置（<code>~/.zshrc</code>）。</p>
<p>Zsh 因其强大的功能和友好的交互体验，逐渐成为主流Shell，目前 Apple 将其作为 macOS 的默认Shell。 在 archlinux 中，<code>/etc/zsh/zprofile</code> 包含了 <code>emulate sh -c 'source /etc/profile'</code>，用于设置$PATH及其他环境变量，以及应用程序相关的设置（<code>/etc/profile.d/*.sh</code>）。 因此使用zsh作为Login Shell也会加载<code>/etc/profile</code>。</p>
<p>对于 macOS，约定是将每个新终端作为 Interactive Login Shell 启动。 macOS GUI 在登录时不运行 <code>.profile</code>，这显然是因为它有自己的加载全局设置的方法。 但这意味着 macOS 上的终端模拟器确实需要运行 <code>.profile</code>（通过告诉它启动的 shell 它是一个登录 shell），否则最终会得到一个不能使用的 shell。</p>
<p><strong>不同shell的配置加载顺序（精简）详见<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html" rel="noopener nofollow">1</a> <a href="https://superuser.com/questions/1840395/complete-overview-of-bash-and-zsh-startup-files-sourcing-order" rel="noopener nofollow">2</a>：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3093851/202502/3093851-20250226162032995-1871017527.svg" alt=""></p>
<p><img src="https://img2024.cnblogs.com/blog/3093851/202502/3093851-20250226162033064-940319134.svg" alt=""></p>
<p>通常情况下：</p>
<ul>
<li>终端相关配置（如别名、提示符）放用户配置，如<code>~/.bashrc</code>; <code>.zshrc</code></li>
<li>需要全局生效的变量（如<code>JAVA_HOME</code>）放<code>~/.bash_profile</code>; <code>.zprofile</code> 或者统一放在 <code>~/.profile</code></li>
<li><code>~/.profile</code> 必须与 <code>/bin/sh</code> 兼容，<a href="https://mywiki.wooledge.org/Bashism" rel="noopener nofollow">bashism</a> 语法不支持。</li>
<li>如果在 <code>~/.profile</code> 中设置环境变量，则 <code>~/.bash_profile</code> 只需加载 .profile 和 .bashrc。</li>
<li>只使用 bash 时，同时拥有 <code>~/.profile</code>  和 <code>~/.bash_profile</code>  没有什么意义。 如果缺少后者，bash 将很乐意使用前者，并且任何特定于 bash 的行都可以通过检查 $BASH 或 $BASH_VERSION 来保护。</li>
<li>在图形桌面环境中启动终端，默认是非login终端，它将仅读取用户的非Login启动脚本。</li>
</ul>
<h2 id="二systemd-的配置方式">二、Systemd 的配置方式</h2>
<p>随着 Systemd 的普及，一套新的变量加载机制开始取代之前的机制。 具体来说，Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 Systemd 启动流程抛弃了 shell 脚本，它将系统对象及其依赖项统一为 systemd 单元。 当你登录时，幕后发生了两件关键事情：</p>
<ol type="1">
<li><strong>PAM（认证模块）</strong></li>
</ol>
<p>优先读取<code>/etc/environment</code>和<code>/etc/security/pam_env.conf</code>（<code>~/.pam_environment</code> <a href="https://bugs.archlinux.org/task/68945" rel="noopener nofollow">已被弃用</a>）。</p>
<p><code>/etc/environment</code> 通过定义KEY=VAL配置，适用于所有用户和会话</p>
<div id="cb2" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code># /etc/environment
LANG=en_US.UTF-8
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin"</code></pre>
</div>
<p><code>/etc/security/pam_env.conf</code> 同时也支持 <code>VARIABLE [DEFAULT=value] [OVERRIDE=value]</code> 的写法</p>
<div id="cb3" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code># /etc/security/pam_env.conf

LANG              DEFAULT=en_US.UTF-8
# 特殊变量 @{HOME}, @{SHELL}，默认值为当前用户的家目录和shell
# 和 HOME，SHELL 的值无关，默认情况下不会设置它们。
XDG_CONFIG_HOME   DEFAULT=@{HOME}/.config
# 可以使用 `${VARIABLE}` 在其他变量的值中扩展已定义的变量
_JAVA_OPTIONS     DEFAULT=-Djava.util.prefs.userRoot=${XDG_CONFIG_HOME}/java
# 虽然支持 KEY=VAL 的写法，但这种写法不支持变量扩展
PATH="/home/username/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin" 
# 更推荐
PATH              DEFAULT=@{HOME}/bin:${PATH}</code></pre>
</div>
<ol start="2" type="1">
<li><strong>systemd 环境变量<code>environment.d</code><a href="https://manpages.debian.org/bookworm/systemd/environment.d.5.en.html" rel="noopener nofollow">(5)</a></strong></li>
</ol>
<p>虽然这里的也是通过 KEY=VAL 的形式定义环境变量，但是支持了变量扩展：</p>
<div id="cb4" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code>PATH=/opt/foo/bin${PATH:+:$PATH}
LD_LIBRARY_PATH=/opt/foo/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
XDG_DATA_DIRS=/opt/foo/share:${XDG_DATA_DIRS:-/usr/local/share/:/usr/share/}</code></pre>
</div>
<ul>
<li>~/.config/environment.d/*.conf – 用户级</li>
<li>/etc/environment.d/*.conf</li>
<li>/run/environment.d/*.conf</li>
<li>/usr/lib/environment.d/*.conf</li>
<li>/etc/environment – 向后兼容</li>
</ul>
<p>一些桌面环境通过 SystemD 用户服务启动程序，这代表着需要通过 <code>environment.d</code>，或者其他特定于桌面环境的方式<a href="https://userbase.kde.org/Session_Environment_Variables" rel="noopener nofollow">(KDE)</a><a href="https://gitlab.gnome.org/GNOME/gnome-session/-/blob/main/gnome-session/gnome-session.in" rel="noopener nofollow">(GNOME)</a>设置环境变量。 （注：通常情况下 Display Manager 设置的环境变量会导入 session）</p>
<h2 id="三图形界面">三、图形界面</h2>
<h3 id="dmdisplay-manager-显示管理器">DM(Display Manager) 显示管理器</h3>
<p>显示管理器通常是一个图形用户界面程序，它在系统启动完成后加载，取代了传统的命令行登录方式。</p>
<p>其负责如下功能：</p>
<blockquote>
<p>显示登录窗口（用户名/密码输入界面）<br>选择桌面环境/窗口管理器（会话类型）<br>启动Xorg/Wayland显示服务器</p>
</blockquote>
<p>Shell 的启动文件（<code>/etc/profile</code>等）是否有效取决于DM。 不同 DM 处理 Login Shell 配置的方式有所不同：</p>
<ul>
<li>
<p><strong>SDDM(KDE 默认DM)/LightDM</strong>： 在 Wayland 和 x11 下都会完整执行 Login Shell 流程并继承环境变量，变量设置相对更加灵活。 但是目前不支持 <code>environment.d</code>。</p>
</li>
<li>
<p><strong>GDM（GNOME 默认DM）</strong>： 在 X11 会话中，GDM 使用 Login Shell 加载配置文件，同时运行 /etc/X11/xinit/xinitrc 或类似的初始化脚本。<br>而在 Wayland 会话中，GDM 不使用 Login Shell，环境变量通过 <code>~/.config/environment.d/</code> 或 <code>/usr/share/gdm/env.d/</code> 设置。 <a href="https://wiki.gnome.org/Initiatives/Wayland/SessionStart" rel="noopener nofollow">详见</a></p>
</li>
<li>
<p><strong>greetd</strong>： 默认行为加载 /etc/profile 和 ~/.profile（通过 source_profile 选项控制）。</p>
</li>
</ul>
<h4 id="xorg-session">Xorg Session</h4>
<p>在 Xorg 环境下，可以通过 xprofile 来加载环境变量。 xprofile(<code>~/.xprofile</code> 和 <code>/etc/xprofile</code>) 在 Xorg 会话初始化阶段（窗口管理器启动前）自动执行命令。xprofile 被以下文件加载：</p>
<ul>
<li>GDM - /etc/gdm/Xsession</li>
<li>LightDM - /etc/lightdm/Xsession</li>
<li>LXDM - /etc/lxdm/Xsession</li>
<li>SDDM - /usr/share/sddm/scripts/Xsession</li>
</ul>
<h4 id="wayland-session">Wayland Session</h4>
<p>由于 Wayland 不启动任何 Xorg 相关文件，因此 GDM 和 KDE Plasma<a href="https://invent.kde.org/plasma/plasma-workspace/-/blob/master/startkde/startplasma.cpp#L273" rel="noopener nofollow">*</a> 会导入 systemd 用户环境变量(<code>~/.config/environment.d</code>)。</p>
<p>虽然 SDDM/LightDM 不支持 <code>environment.d</code>，但是可以通过在登陆脚本中导入环境变量实现类似行为：</p>
<div id="cb5" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code># use systemd-environment-d-generator(8) to generate environment, and export those variables
set -o allexport
source &lt;(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)
set +o allexport</code></pre>
</div>
<h3 id="dedesktop-environment-桌面环境">DE(Desktop Environment) 桌面环境</h3>
<h4 id="kde-plasma">KDE Plasma</h4>
<p>KDE Plasma 可以通过 <code>~/.config/plasma-workspace/env/</code> 中的脚本设置环境变量，其通过调用 <code>/bin/sh</code> <a href="https://invent.kde.org/plasma/plasma-workspace/-/blob/master/startkde/startplasma.cpp#L152" rel="noopener nofollow">实现</a>环境变量的导出。 因此， 要确保语法符合 (<code>/bin/sh</code>)，比如 debain 系的 <code>/bin/sh</code> 为 <code>dash</code>，不支持 <code>source</code> 命令。</p>
<p>如果使用的是像 GDM 这种在 Wayland 下不加载 Login Shell 配置的 DM，但是又想在 KDE Plasma 中能够像 SDDM 一样加载环境变量， 可以通过手动加载 <code>profile</code> 文件来实现类似的功能。</p>
<div id="cb6" class="sourceCode">
<pre class="sourceCode bash highlighter-hljs"><code>mkdir -p ~/.config/plasma-workspace/env
touch ~/.config/plasma-workspace/env/profile.sh</code></pre>
</div>
<div id="cb7" class="sourceCode">
<pre class="sourceCode sh highlighter-hljs"><code># profile.sh
DM_PATH=$(grep -oP '(?&lt;=^ExecStart=).*' /etc/systemd/system/display-manager.service 2&gt;/dev/null)

if [ "$DM_PATH" = "/usr/bin/gdm" ]; then
 . "/etc/profile"
 . "$HOME/.profile"
fi</code></pre>
</div>
<h4 id="gnome">GNOME</h4>
<p>在 Wayland 下，由于 GDM 不加载 Login Shell，因此 GNOME 会话有且仅有会在 Wayland 中使用 Login Shell 重新加载环境变量。</p>
<p>具体来讲，GNOME 通过 <code>gnome-session</code> 启动，<code>gnome-session</code> 实际上是一个 shell 脚本，它会在执行 <code>gnome-session-binary</code> 之前检查自己的第一个参数是否是 <code>-l</code>(Login)<a href="https://gitlab.gnome.org/GNOME/gnome-session/-/blob/main/gnome-session/gnome-session.in?ref_type=heads#L10" rel="noopener nofollow">*</a>。如果不是，则重新启动当前 shell 会话为登录 shell。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.15553478850810185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 16:45">2025-02-26 15:18</span>&nbsp;
<a href="https://www.cnblogs.com/comsoi">comsoi</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18738485" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18738485);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18738485', targetLink: 'https://www.cnblogs.com/comsoi/p/18738485', title: 'Linux 环境变量指北' })">举报</a>
</div>
        