
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuyuegb2312/p/18685884" title="发布于 2025-01-26 22:33">
    <span role="heading" aria-level="2">深入理解Mybatis分库分表执行原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        探究分库分表场景下Mybatis是如何将mapper.xml中sql的逻辑表，转换成实际执行时的物理表。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>工作多年，分库分表的场景也见到不少了，但是我仍然对其原理一知半解。趁着放假前时间比较富裕，我想要解答三个问题：</p>
<ol>
<li>
<p>为什么mybatis的mapper.xml文件里的sql不需要拼接表名中的分表？</p>
</li>
<li>
<p>mybatis是如何识别分表位的？</p>
</li>
<li>
<p>最近工作中遇到的问题：为什么我的三表join会报错找不到表？为了不影响项目上线时间，我不得不在mapper.xml中用${}拼接其中的一个逻辑表对应的物理表表名，引入了SQL注入的风险。</p>
</li>
</ol>
<p>带着问题，我花了不少时间深入了读了一下这部分的源码，终于搞清楚了，借本文分享一下。</p>
<p>本文主要环境是mybatis-plus-boot-starter 3.4.3，不过用的基本上仍然是mybatis的特性。</p>
<h1 id="流程图">流程图</h1>
<p>以查询为例，可以先看下流程图，大致了解一下整个过程。</p>
<p><img src="https://img2024.cnblogs.com/blog/228024/202501/228024-20250126221615340-831512405.png" alt="" loading="lazy"></p>
<h1 id="关键的类和对象">关键的类和对象</h1>
<p>在流程图里出现了一些类和其实例化的对象，有必要选其中关键的介绍一下。</p>
<h2 id="mappedstatement">MappedStatement</h2>
<p>类全名org.apache.ibatis.mapping.MappedStatement，是一个final类。<strong>不要被名字误导，它和JDBC API中的java.sql.Statement没有实现关系。</strong>后者用于执行一条静态SQL并返回结果。</p>
<p>MappedStatement用来维护一个mapper中一个方法（对应一个sql）相关的信息，也就是将xml中的sql实例化成一个对象：</p>
<p><img src="https://dcn4mpcv8fl1.feishu.cn/space/api/box/stream/download/asynccode/?code=MjVlNWIxNTk4ZDU1MTc1ZGFkODI0NjkwZDA1YzZhMGFfVkZUdU95WW41bGNXUXFoV0ZUMkFieDJpN242d05pYjRfVG9rZW46Vzh2RGJNTkhab1FGMWZ4WkozR2NyM1Zpbm5nXzE3Mzc5MDA4MTU6MTczNzkwNDQxNV9WNA" alt="" loading="lazy"></p>
<h3 id="生成时机">生成时机</h3>
<p>使用sql的id通过MybatisConfiguration/Configuration获取。后者内部的Map(mappedStatements)会持有所有的mapper中的语句。</p>
<h2 id="boundsql">BoundSql</h2>
<p>类全名：org.apache.ibatis.mapping.BoundSql</p>
<p>主要用于存储 SQL 语句以及该 SQL 语句所需的参数等信息。</p>
<p>如下图中：</p>
<ul>
<li>
<p>sql字段是经过处理的sql</p>
<ul>
<li>
<p>已经将<code>${}</code>直接替换为实际值，这也就会导致注入风险</p>
</li>
<li>
<p><code>#{}</code>则使用<code>?</code>占位</p>
</li>
</ul>
</li>
<li>
<p>parameterMappings记录参数的映射方法</p>
</li>
<li>
<p>parameterObject实际的参数值，对应的是java的mapper接口类里的参数。比如接口是9个参数，这里就是18个，其中paramxx是原参数全部用新key存储但是值没变的。这些参数不一定是sql里的<code>?</code>占位符所用到的，可能会多一些。</p>
</li>
</ul>
<p><img src="https://dcn4mpcv8fl1.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E5ZjcxNWMwNzg0ZGJkODc3MmRmZWNlMjFlNzE0NDdfZnFpNHBnOEpRc2l5ZGJTaWkzNXdQQTlSQW5veFpHcFZfVG9rZW46T2EzdWIxRHEyb280cGt4emFrWmMwU01JbkFnXzE3Mzc5MDA4MTU6MTczNzkwNDQxNV9WNA" alt="" loading="lazy"></p>
<h3 id="生成时机-1">生成时机</h3>
<p>Executor通过MapperStatement生成。</p>
<h2 id="connection">Connection</h2>
<p>全名：java.sql.Connection，是JDBC API的一个核心接口。它的功能是：</p>
<ul>
<li>
<p>建立与数据库的连接</p>
</li>
<li>
<p>创建执行对象，用于执行SQL语句的对象，也就是各种各样的Statement</p>
</li>
<li>
<p>管理事务，包括开启、提交、回滚。本文以查询为例，探讨分表的路由的原理，因此不会对事务相关话题做展开。</p>
</li>
</ul>
<p>应用配置的是分库分表数据源，对应地，实例化的Connection对象是ShardingSphereConnection，如下：</p>
<p><img src="https://dcn4mpcv8fl1.feishu.cn/space/api/box/stream/download/asynccode/?code=YTAzYzUxNjdhZGM3NzVjNWZhYTVmYmIzZDA2MDQ4MTBfVWdRakVlME4yREV2MmFFb2N1N0UwVnlzc0JpcnNrZjdfVG9rZW46SmpORWJQRU5ab1ZTemJ4djd4NmNtTENObkdoXzE3Mzc5MDA4MTU6MTczNzkwNDQxNV9WNA" alt="" loading="lazy"></p>
<p>展开dataSourceMap的value，可以看到更多数据源的配置，包括连接超时时间、jdbcUrl，db的用户名和明文的密码。如果运行容器是Springboot，那么这些配置可以在application.properties里看到。</p>
<h2 id="statementshardingspherepreparedstatement">Statement/ShardingSpherePreparedStatement</h2>
<p>Statement接口在jdbc中的地位也很重要，它用于执行一条静态SQL并返回结果。</p>
<p>在分库分表的场景，它会生成各种中间过程的上下文Context，比如ExecutionContext、TrafficContext、RouteContext等，流程图中的LogicSQL也可以看作是一种上下文。Logic的sqlStatementContext把原始SQL进行了结构化的解析，比如from、where、group by等。在from字段可以进行多级的join嵌套，比如下图join的left是另一个join，right是一个表（逻辑表）：</p>
<p><img src="https://dcn4mpcv8fl1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQ0YTE4ZTU0ZTRlNjgzYWVmZjgxMDkyYjYwYmQ2MWJfYnQxUnJrZDF0TXFHbzZDRVJxUERBYWRsM0VRYXduVktfVG9rZW46U3V0SWJzeFZEb0hRYTl4T3NJb2NBbEJMbjdKXzE3Mzc5MDA4MTU6MTczNzkwNDQxNV9WNA" alt="" loading="lazy"></p>
<p>对于LogicSQL的where属性，其中的参数会用于参与库表的分片计算。</p>
<p>Statement也会借助其他的工具类，如SQLCheckEngine、KernelProcessor做处理，其中最关键的一点是，在KernelProcessor中生成ExecutionContext的方法内，生成RouteContext时获取物理表名：</p>
<pre><code class="language-Java">public ExecutionContext generateExecutionContext(final LogicSQL logicSQL, final ShardingSphereMetaData metaData, final ConfigurationProperties props) {
    RouteContext routeContext = route(logicSQL, metaData, props);
    SQLRewriteResult rewriteResult = rewrite(logicSQL, metaData, props, routeContext);
    ExecutionContext result = createExecutionContext(logicSQL, metaData, routeContext, rewriteResult);
    logSQL(logicSQL, props, result);
    return result;
}
</code></pre>
<p>上面的route()中，也包含了很多步：</p>
<ul>
<li>WhereClauseShardingConditionEngine从Logic SQL的from属性获取分表相关的属性和值的代码如下</li>
</ul>
<pre><code class="language-Java">public List&lt;ShardingCondition&gt; createShardingConditions(final SQLStatementContext&lt;?&gt; sqlStatementContext, final List&lt;Object&gt; parameters) {
    if (!(sqlStatementContext instanceof WhereAvailable)) {
        return Collections.emptyList();
    }
    List&lt;ShardingCondition&gt; result = new ArrayList&lt;&gt;();
    for (WhereSegment each : ((WhereAvailable) sqlStatementContext).getWhereSegments()) {
        result.addAll(createShardingConditions(sqlStatementContext, each.getExpr(), parameters));
    }
    return result;
}
</code></pre>
<ul>
<li>构造condition后，ShardingRouteEngineFactory会把from中和逻辑表名不一致的表剔除掉，这个怎么理解呢？比如SQL里一共涉及3张表table_a、table_b、table_c，其中table_c其中table_c写作<code>table_c_${}</code>，直接通过<code>${}</code>把分表名拼接好了，变成table_c_001。table_c_001这个表名是在分表规则里找不到的，因此也不会应用任何分表规则。</li>
</ul>
<pre><code class="language-Java">private static ShardingRouteEngine getDQLRoutingEngine(final ShardingRule shardingRule, final ShardingSphereSchema schema, final SQLStatementContext&lt;?&gt; sqlStatementContext, 
                                                       final ShardingConditions shardingConditions, final ConfigurationProperties props) {
    Collection&lt;String&gt; tableNames = sqlStatementContext.getTablesContext().getTableNames();
    if (shardingRule.isAllBroadcastTables(tableNames)) {
        return sqlStatementContext.getSqlStatement() instanceof SelectStatement ? new ShardingUnicastRoutingEngine(tableNames) : new ShardingDatabaseBroadcastRoutingEngine();
    }
    if (sqlStatementContext.getSqlStatement() instanceof DMLStatement &amp;&amp; shardingConditions.isAlwaysFalse() || tableNames.isEmpty()) {
        return new ShardingUnicastRoutingEngine(tableNames);
    }
    // from子句里的表名，如果不是逻辑表名，不会按照分表处理
    Collection&lt;String&gt; shardingLogicTableNames = shardingRule.getShardingLogicTableNames(tableNames);
    if (shardingLogicTableNames.isEmpty()) {
        return new ShardingIgnoreRoutingEngine();
    }
    return getDQLRouteEngineForShardingTable(shardingRule, schema, sqlStatementContext, shardingConditions, props, shardingLogicTableNames);
}
</code></pre>
<ul>
<li>
<p>继续看下去，getDQLRouteEngineForShardingTable如果通过bindingTableRule出要处理的表分片规则一致，那就直接返回，不重复处理。</p>
</li>
<li>
<p>RouteSQLRewriteEngine将SQL里的逻辑表改写为物理表，调用栈如下：</p>
</li>
</ul>
<p><img src="https://dcn4mpcv8fl1.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIwN2M2NGNmMzc5YzkyYWRhMmQ5NzkwMGQyYmFhZWZfUHNMMWpIN3BrVnNQaVBJaWRaRlZ6VkNObEZmTGFJZFVfVG9rZW46U0dxNGJPWWlobzd1a3l4SW83ZmNZdk9kblZiXzE3Mzc5MDA4MTU6MTczNzkwNDQxNV9WNA" alt="" loading="lazy"></p>
<p>用于改写的代码：</p>
<pre><code class="language-Java">public final String toSQL() {
    if (context.getSqlTokens().isEmpty()) {
        return context.getSql();
    }
    Collections.sort(context.getSqlTokens());
    StringBuilder result = new StringBuilder();
    result.append(context.getSql(), 0, context.getSqlTokens().get(0).getStartIndex());
    for (SQLToken each : context.getSqlTokens()) {
        result.append(each instanceof ComposableSQLToken ? getComposableSQLTokenText((ComposableSQLToken) each) : getSQLTokenText(each));
        result.append(getConjunctionText(each));
    }
    return result.toString();
}
</code></pre>
<h2 id="shardingrule">ShardingRule</h2>
<p>用于存放分表和单表的规则，被Statement使用。为了便于叙述，举例如下：</p>
<ul>
<li>
<p>一共三个数据源：不分表的ds-master、包括分表的ds0、包括分表的ds1</p>
</li>
<li>
<p>查询的逻辑表名是c_voucher，对应地分表是c_voucher_${companyId}_${subYear}，也就是通过companyId和subYear两个参数确定实际的分表。</p>
</li>
<li>
<p>实际使用时有很多分片规则可以采用，比如按userId第几位路由到第几张表、某个字段取哈希值再取模路由。但是由于目前手上的项目找不到这种例子，不在此处剖析。处理方式是类似的，读者可以自行探索。</p>
</li>
</ul>
<h3 id="与applicationproperties对应关系部分">与application.properties对应关系(部分)</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>ShardingRule中的属性名</td>
<td>application.properties配置</td>
<td>备注</td>
</tr>
<tr>
<td>数据源名称</td>
<td>dataSourceNames</td>
<td>属性前缀的一部分，比如<br><br>["ds-0","ds-1"]对应<br><br>spring.shardingsphere.datasource.ds-0.xxx=yyy<br><br>spring.shardingsphere.datasource.ds-1.xxx=zzz</td>
<td></td>
</tr>
<tr>
<td>分片算法</td>
<td>shardingAlgorithms<br><br>(Map)</td>
<td>既有表的也有库的。<br><br>对于表的：<br><br>spring.shardingsphere.rules.sharding.sharding-algorithms.ts-c-voucher.type=COMPLEX_INLINE<br><br>spring.shardingsphere.rules.sharding.sharding-algorithms.ts-c-voucher.props.algorithm-expression=c_voucher_$-&gt;{companyId}_$-&gt;{subYear}<br><br>  <br><br>对于库的：<br><br>spring.shardingsphere.rules.sharding.sharding-algorithms.t-database-inline.type=INLINE<br><br>spring.shardingsphere.rules.sharding.sharding-algorithms.t-database-inline.props.algorithm-expression=ds-$-&gt;</td>
<td>type定义具体分片算法类型，此处是COMPLEX_INLINE，支持比INLINE更复杂的表达式计算。<br><br>可以看出表和库的属性规则不太一样，表是ts-xx，库是t-xx</td>
</tr>
<tr>
<td>全局唯一键生成算法</td>
<td>keyGenerators<br><br>(本例中为null)</td>
<td>本例不涉及</td>
<td>雪花算法、UUID等</td>
</tr>
<tr>
<td>表规则</td>
<td>tableRules<br><br>(Map)</td>
<td>见下一节</td>
<td></td>
</tr>
<tr>
<td>绑定表规则</td>
<td>bindingTableRules</td>
<td>比如有a~i一共9张表，每3张的分片规则一样<br><br>spring.shardingsphere.rules.sharding.binding-tables[0]=a,b,c<br><br>spring.shardingsphere.rules.sharding.binding-tables[1]=d,e,f<br><br>spring.shardingsphere.rules.sharding.binding-tables[2]=g,h,i</td>
<td>将具有关联关系（会进行join）且按照同样的分片规则的表绑定到同一个表规则中，避免笛卡尔积运算</td>
</tr>
<tr>
<td>其它</td>
<td>本例不涉及，略</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="tablerule和applicationproperties的对应关系">TableRule和application.properties的对应关系</h3>
<p>ShardingRule包含了一个TableRule的map，包含了具体表分片的配置。这里单拎出来分析。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>TableRule的属性名</td>
<td>application.properties配置</td>
<td>备注</td>
</tr>
<tr>
<td>逻辑表名</td>
<td>logicTable</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>实际的数据节点</td>
<td>actualDataNodes</td>
<td 1..2="">spring.shardingsphere.rules.sharding.tables.c_vouching_result.actual-data-nodes=ds-$-&gt;{0..1}.c_voucher_$-&gt;{1..2}_$-&gt;</td>
<td>并不是真实的表名，此处对象中是：<br><br>ds-0.c_voucher_1_1<br><br>ds-0.c_voucher_2_2<br><br>ds-0.c_voucher_2_1<br><br>ds-0.c_voucher_2_2<br><br>ds-1.c_voucher_1_1<br><br>ds-1.c_voucher_2_2<br><br>ds-1.c_voucher_2_1<br><br>ds-1.c_voucher_2_2</td>
</tr>
<tr>
<td>实际的表</td>
<td>actualTables</td>
<td>同上</td>
<td>并不是真实的表名，和actualDataNodes类似</td>
</tr>
<tr>
<td>数据节点的索引map</td>
<td>dataNodeIndexMap</td>
<td>同上</td>
<td>给actualDataNodes按顺序分配一个序号，本例0~7</td>
</tr>
<tr>
<td>表所在库的分片规则</td>
<td>databaseShardingStrategyConfig</td>
<td>spring.shardingsphere.rules.sharding.tables.c_voucher.database-strategy.standard.sharding-column=schemaId<br><br>spring.shardingsphere.rules.sharding.tables.c_voucher.database-strategy.standard.sharding-algorithm-name=t-database-inline</td>
<td></td>
</tr>
<tr>
<td>表的分片规则</td>
<td>tableShardingStrategyConfig</td>
<td>spring.shardingsphere.rules.sharding.tables.c_voucher.table-strategy.complex.sharding-columns=companyId,subYear<br><br>spring.shardingsphere.rules.sharding.tables.c_voucher.table-strategy.complex.sharding-algorithm-name=ts-c-vouching-result</td>
<td>分片的列、分片算法名称，对应的name是shardingAlgorithms中出现过的拼上前缀的表名</td>
</tr>
<tr>
<td>生成主键的列</td>
<td>generateKeyColumn</td>
<td>-</td>
<td>不涉及，略</td>
</tr>
<tr>
<td>主键生成器名称</td>
<td>keyGeneratorName</td>
<td>-</td>
<td>不涉及，略</td>
</tr>
<tr>
<td>实际数据源名称</td>
<td>actualDatasourceNames</td>
<td>-</td>
<td>ds-0，ds-1</td>
</tr>
<tr>
<td>数据源对应的分表</td>
<td>datasourceToTablesMap</td>
<td>-</td>
<td>分表名同actualDataNodes</td>
</tr>
</tbody>
</table>
<h1 id="实现分库分表路由的关键步骤">实现分库分表路由的关键步骤</h1>
<p>根据流程图和上面的类，可以总结如下：</p>
<ol>
<li>
<p>进行数据源的配置，包括库和表的分片规则（算法+来源列），以确保应用启动时组装的Connection包含这些路由信息，从而传递下去。</p>
</li>
<li>
<p>执行SQL时，组装的Statement根据逻辑表名找到对应的库表分片规则，从而推算出实际的表名：</p>
<ol>
<li>
<p>生成LogicSQL，将SQL结构化</p>
</li>
<li>
<p>解析LogicSQL的from子句，获取分表相关的参数，并组装逻辑表到物理表的映射RouteUnit（同一个bindingTableRules的表只组装一个）</p>
</li>
<li>
<p>KernelProcessor将LogicSQL里需要替换的表名按RouteUnit改写成逻辑表名。</p>
</li>
</ol>
</li>
</ol>
<h1 id="问题解答">问题解答</h1>
<h2 id="前言的三个问题">前言的三个问题</h2>
<p>前言中的前两个问题很好解答，通过上面的分析，可以知道原始sql里的逻辑表是怎么转换成物理表的，分片规则是如何和相关的参数共同发挥作用的。</p>
<p>对于第三个问题，我把之前项目中无法找到table_c的第一版三表join查询SQL简化如下：</p>
<pre><code class="language-SQL">SELECT
a.biz_date,
a.type_id,
a.voucher_id,
a.create_time,
a.update_time
FROM
table_a a
INNER JOIN table_c c
ON a.biz_date = c.biz_date
AND a.type_id = c.type_id
AND a.voucher_id = c.voucher_id
LEFT JOIN table_b b
ON a.biz_date = b.biz_date
AND a.type_id = b.type_id
AND a.voucher_id = b.voucher_id
AND a.schema_id = b.schema_id
AND a.sub_year = b.sub_year
AND a.company_id = b.company_id
where a.company_id = #{company_id}
AND a.schema_id = #{schema_id}
AND a.sub_year = #{sub_year}
</code></pre>
<p>其中table_a、table_b的分表位是company_id和sub_year，分片规则完全一样；table_c的是accPackageId，分表规则和前两种不一同。</p>
<p>由于第一版运行时会报错，当时没有时间确定具体原因，为了不影响项目进度，我临时将table_c改写成了table_c_${accPackageId}。它在executor里会替换成对应的物理表名，并且也不会找对应的分表规则。项目上线了，能用但是有注入风险。</p>
<p>经过上面的探讨，初版SQL找不到table_c逻辑表的原因其实很简单了：table_c的分表位没有作为一个参数出现在SQL里（尽管它在mapper.java的方法入参里出现）。那么在这个SQL的where中加一行，并把<code>table_c_${accPackageId}</code>改回<code>table_c</code>，问题解决：</p>
<pre><code class="language-SQL">and c.accPackageId = #{accPackageId}
</code></pre>
<h2 id="引申问题如果分表不在同一个分库">引申问题：如果分表不在同一个分库？</h2>
<p>这种情况通过现有项目对应应用验证有点麻烦：库的分片规则所有分表是一致的，这个字段所有分表的逻辑表都有。如果想改，需要改分片规则。</p>
<p>因此我换了一种方式测试：在Navicat中执行等效语句语句，没有报错，且能查到插入的数据：</p>
<pre><code class="language-SQL">SELECT
        a.biz_date,
        a.type_id,
        a.voucher_id,
        a.update_time 
FROM
        dev_account_0.table_a_1722_2024 a
        INNER JOIN dev_account_1.table_c_757 c ON a.biz_date= c.biz_date
        AND a.type_id= c.type_id
        AND a.voucher_id= c.voucher_id
        LEFT JOIN dev_account_0.table_b_1722_2024 b ON a.biz_date= b.biz_date
        AND a.type_id= b.type_id
        AND a.voucher_id= b.voucher_id
        AND a.schema_id = b.schema_id 
        AND a.sub_year = b.sub_year 
        AND a.company_id = b.company_id 
WHERE
        a.company_id = 1722 
        AND a.schema_id = 0 
        AND a.sub_year= 2024 
        AND c.dev_account_0= 757
</code></pre>
<p>那么，既然Mybatis能提供类似的分库分表映射，理论上也是可以达到同样效果的。</p>
<p><strong>当然，我个人并不推荐这样做，因为这种查询有限制：必须对这些分片都有权限。</strong></p>
<p><strong>并且，我观察到，如果table_c没有符合要求的数据，不在同一个库的查询会比在同一个库要慢的非常多，到了极其夸张的程度——分别是50s和0.2s。</strong></p>
<h1 id="源码阅读感想">源码阅读感想</h1>
<ol>
<li>
<p>阅读源码时，最好一边debug一边整理流程图一边去理解。静态地看源码，理解难度很高，原因是：</p>
<ol>
<li>
<p>使用了大量的反射和代理，debug时很容易陷在其中，读着读着就不知道读到哪里去了。代理类，有一部分是框架中的，也有一部分是日志相关的。</p>
</li>
<li>
<p>很多对象都是实例化的子类，只有在debug时才能看到实际的子类是什么。这些子类的继承实现关系也很复杂。</p>
</li>
<li>
<p>有一些对象，同时持有了中间数据和中间数据和处理过的数据，如果只盯着中间数据，就不知道到底发生了什么。比如executionContext，它所持有的logicSQL里的SQL文本是不会变的，但是经过一系列路由处理和rewrite后逻辑表替换成物理表的会放在executionContext另一个属性的executionUnits里，并用以执行，有点隐蔽。，并用以执行，有点隐蔽。</p>
</li>
</ol>
</li>
<li>
<p>我以前是很反对用lombok的。但是在此之后又过了几年，因为接手老代码的原因工作中不得不用，只能慢慢的接受。这次看到分片算法里有些类也在用（比如org.apache.shardingsphere.sharding.rule.TableRule），不禁哑然失笑。</p>
</li>
</ol>

</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">
        <p id="PSignature" style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed;
            padding-top: 10px;padding-right: 10px;padding-bottom: 10px;padding-left: 60px;
            font-family: 微软雅黑; font-size:11px;">
            <br>
            作者：<a href="http://www.cnblogs.com/wuyuegb2312" target="_blank">五岳</a>
            <br>
            出处：<a href="http://www.cnblogs.com/wuyuegb2312" target="_blank">http://www.cnblogs.com/wuyuegb2312</a>
            <br>
            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
        </p>
    　</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07060473813657407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 22:34">2025-01-26 22:33</span>&nbsp;
<a href="https://www.cnblogs.com/wuyuegb2312">五岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18685884" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18685884);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18685884', targetLink: 'https://www.cnblogs.com/wuyuegb2312/p/18685884', title: '深入理解Mybatis分库分表执行原理' })">举报</a>
</div>
        