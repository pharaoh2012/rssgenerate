
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hadxs/p/18721609" title="发布于 2025-02-18 14:42">
    <span role="heading" aria-level="2">.net 8 web api使用SqlSugar搭建仓储模式+Autofac依赖注入</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>废话少说直接上重点,使用SqlSugar搭建仓储模式,之前自己搭建的一个相对基础同时还算稳定的一个框架；<br>
创建解决方案....创建项目省过...结果如图：</p>
<p><img src="https://img2024.cnblogs.com/blog/3602392/202502/3602392-20250218112237475-1423373112.png" alt="" loading="lazy"></p>
<p>仓储服务和仓储实现，业务服务以及业务实现外加一个webapi;</p>
<p>我们先从<strong>SqlSugarCore</strong>项目开始：</p>
<p>1.添加SqlSugarCore引用</p>
<p><code>dotnet add package SqlSugarCore --version 5.1.4.177</code></p>
<p>这个类库项目用来提供实体依赖【个人拿来存数据库实体用】</p>
<p>接下来上重点了；</p>
<p>搭建仓储与基础服务：</p>
<p>1.在IRepository中添加SqlSugarCore项目引用，再建一个IBaseRepository接口类，代码如下：</p>
<pre><code>using SqlSugar;

namespace LHJ.IRepository;

/// &lt;summary&gt;
/// 基类接口,其他接口继承该接口
/// &lt;/summary&gt;
/// &lt;typeparam name="TEntity"&gt;&lt;/typeparam&gt;
public interface IBaseRepository&lt;TEntity&gt; where TEntity : class
{
    /// &lt;summary&gt;
    /// 根据ID查询
    /// &lt;/summary&gt;
    /// &lt;param name="objId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;TEntity&gt; QueryByID(object objId);

    /// &lt;summary&gt;
    /// 添加
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;bool&gt; Add(TEntity model);

    /// &lt;summary&gt;
    /// 修改
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;bool&gt; Update(TEntity model);

    /// &lt;summary&gt;
    /// 删除
    /// &lt;/summary&gt;
    /// &lt;param name="ids"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;bool&gt; DeleteByIds(object[] ids);

    /// &lt;summary&gt;
    /// 获取db对象
    /// &lt;/summary&gt;
    /// &lt;param name="config"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public SqlSugarClient GetDb(string config = "0");
}
</code></pre>
<p>注意：GetDb方法用来向外提供DbBase,参数自己可以根据后面实例化DbContext时传入对应数据库的configId</p>
<p>服务接口有了，接下来就是具体实现：</p>
<p>在Repository项目中添加SqlSugar的Nuget引用后新建一个DbContext类,代码如下：</p>
<pre><code>using SqlSugar;

namespace LHJ.Repository;

public class DbContext&lt;T&gt; where T : class, new()
{
    public DbContext()
    {
        Db = new SqlSugarClient(new ConnectionConfig()
        {
            ConfigId = "0",
            ConnectionString = BaseDBConfig.ConnectionString,
            DbType = DbType.SqlServer,
            InitKeyType = InitKeyType.Attribute,//从特性读取主键和自增列信息
            IsAutoCloseConnection = true,//开启自动释放模式
        });
        //调式代码 用来打印SQL 
        Db.Aop.OnLogExecuting = (sql, pars) =&gt;
        {
            Console.WriteLine(sql + "\r\n" +
                Db.Utilities.SerializeObject(pars.ToDictionary(it =&gt; it.ParameterName, it =&gt; it.Value)));
            Console.WriteLine();
        };

    }

    public SqlSugarClient Db;//用来处理事务多表查询和复杂的操作
    public SimpleClient&lt;T&gt; CurrentDb { get { return new SimpleClient&lt;T&gt;(Db); } }//用来操作当前表的数据

    //public SimpleClient&lt;Users&gt; UserDb { get { return new SimpleClient&lt;Users&gt;(Db); } }
}
</code></pre>
<p>DbContext用来初始化数据库连接，然后再建一个仓储实现类BaseRepository.cs,代码如下：</p>
<pre><code>
namespace LHJ.Repository;

/// &lt;summary&gt;
/// 基类实现
/// &lt;/summary&gt;
/// &lt;typeparam name="TEntity"&gt;&lt;/typeparam&gt;
public class BaseRepository&lt;TEntity&gt; : DbContext&lt;TEntity&gt;, IBaseRepository&lt;TEntity&gt; where TEntity : class, new()
{
    /// &lt;summary&gt;
    /// 写入实体数据
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;bool&gt; Add(TEntity model)
    {
        //这里需要注意的是，如果使用了Task.Run()就会导致 sql语句日志无法记录改成下面的
        //var i = await Task.Run(() =&gt; Db.Insertable(model).ExecuteCommand());
        var i = await Db.Insertable(model).ExecuteCommandAsync();
        return i &gt; 0;
    }

    /// &lt;summary&gt;
    /// 根据ID删除
    /// &lt;/summary&gt;
    /// &lt;param name="ids"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;bool&gt; DeleteByIds(object[] ids)
    {
        var i = await Db.Deleteable&lt;TEntity&gt;().In(ids).ExecuteCommandAsync();
        return i &gt; 0;
    }

    /// &lt;summary&gt;
    /// 根据ID查询一条数据
    /// &lt;/summary&gt;
    /// &lt;param name="objId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;TEntity&gt; QueryByID(object objId)
    {
        return await Db.Queryable&lt;TEntity&gt;().InSingleAsync(objId);
    }

    /// &lt;summary&gt;
    /// 更新实体数据
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;bool&gt; Update(TEntity model)
    {
        //这种方式会以主键为条件
        var i = await Db.Updateable(model).ExecuteCommandAsync();
        return i &gt; 0;
    }

    public SqlSugarClient GetDb(string configId) =&gt; Db;
}
</code></pre>
<p>这里我们继承了IBaseRepository类，同时也基础了DbContext类，这样我们就能通过DbContext实现对应基础数据交互操作；</p>
<p>同时再建一个配置类BaseDBConfig.cs,代码如下：</p>
<pre><code>namespace LHJ.Repository;

public class BaseDBConfig
{

    /// &lt;summary&gt;
    /// 数据库连接字符串oracle
    /// &lt;/summary&gt;
    public static string? ConnectionString { get; set; }
}
</code></pre>
<p>这里是用来存储数据库字符串,我自己处理单库，如果要多库请使用：</p>
<p><code>public static List&lt;string&gt;?  ConnectionString { get; set; }</code></p>
<p>这里我建议大家可以单据建一个类库用来提供公共配置支持配置信息【个人搭建写完了才发现，就懒得改了】，还有使用静态字段存储链接字符其实是不恰当的，应该在DBContext初始化的时候读一次配置文件，这样发布后更改数据库相对方便；【主要是为了演示如何搭建，就不改了】</p>
<p>仓储有了，我们就可以搭建逻辑业务，在项目IService中新建IBaseService接口类,代码如下：</p>
<pre><code>namespace LHJ.IService;

public interface IBaseService&lt;TEntity&gt; where TEntity : class
{
    /// &lt;summary&gt;
    /// 根据ID列表删除
    /// &lt;/summary&gt;
    /// &lt;param name="ids"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;bool&gt; DeleteByIds(object[] ids);

    /// &lt;summary&gt;
    /// 根据ID查询
    /// &lt;/summary&gt;
    /// &lt;param name="objId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;TEntity&gt; QueryByID(object objId);

    /// &lt;summary&gt;
    /// 添加实体
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;bool&gt; Add(TEntity model);

    /// &lt;summary&gt;
    /// 更新实体
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;

    Task&lt;bool&gt; Update(TEntity model);
}
</code></pre>
<p>在Service项目中新建服务基类Service.cs,代码如下：</p>
<pre><code>/// &lt;summary&gt;
/// 服务基类
/// &lt;/summary&gt;
/// &lt;typeparam name="TEntity"&gt;&lt;/typeparam&gt;
public class BaseService&lt;TEntity&gt; : IBaseService&lt;TEntity&gt; where TEntity : class, new()
{
    private readonly IBaseRepository&lt;TEntity&gt; baseDal;

    //这里使用依赖注入
    public BaseService(IBaseRepository&lt;TEntity&gt; baseRepository)
    {
        baseDal = baseRepository;
    }

    /// &lt;summary&gt;
    /// 写入实体
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;bool&gt; Add(TEntity model)
    {
        return await baseDal.Add(model);
    }

    /// &lt;summary&gt;
    /// 根据ID删除
    /// &lt;/summary&gt;
    /// &lt;param name="ids"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;

    public async Task&lt;bool&gt; DeleteByIds(object[] ids)
    {
        return await baseDal.DeleteByIds(ids);
    }

    /// &lt;summary&gt;
    /// 根据ID查询
    /// &lt;/summary&gt;
    /// &lt;param name="objId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;TEntity&gt; QueryByID(object objId)
    {
        return await baseDal.QueryByID(objId);
    }

    /// &lt;summary&gt;
    /// 更新实体
    /// &lt;/summary&gt;
    /// &lt;param name="model"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;bool&gt; Update(TEntity model)
    {
        return await baseDal.Update(model);
    }
}
</code></pre>
<p>到此后端的架构基本上算是完成了，但是这个时候启动项目是不会实现基础服务,因此我们需要Autofac注入实现我们的服务：</p>
<p>1.添加服务</p>
<p><code>dotnet add package Autofac.Extensions.DependencyInjection --version 10.0.0</code></p>
<p>2.还是添加包引用</p>
<p><code>dotnet add package Autofac.Extras.DynamicProxy --version 7.1.0</code></p>
<p>3.新建AutofacModuleRegister.cs类，用来配置Autofac,代码如下：</p>
<pre><code>using Autofac;
using Autofac.Extras.DynamicProxy;
using System.Reflection;

namespace LHJ.WebHost;

public class AutofacModuleRegister : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        //注册服务
        //builder.RegisterType&lt;TestService&gt;().As&lt;ITestService&gt;();

        //builder.RegisterType&lt;TestRepository&gt;().As&lt;ITestRepository&gt;();

        //注册Service
        var assemblysServices = Assembly.Load("LHJ.Service");
        builder.RegisterAssemblyTypes(assemblysServices)
            .InstancePerDependency()//默认模式，每次调用，都会重新实例化对象；每次请求都创建一个新的对象
           .AsImplementedInterfaces()//是以接口方式进行注入,注入这些类的所有的公共接口作为服务（除了释放资源）
           .EnableInterfaceInterceptors(); //引用Autofac.Extras.DynamicProxy;应用拦截器

        //注册Repository
        var assemblysRepository = Assembly.Load("LHJ.Repository");
        builder.RegisterAssemblyTypes(assemblysRepository)
            .InstancePerDependency()//默认模式，每次调用，都会重新实例化对象；每次请求都创建一个新的对象
           .AsImplementedInterfaces()//是以接口方式进行注入,注入这些类的所有的公共接口作为服务（除了释放资源）
           .EnableInterfaceInterceptors(); //引用Autofac.Extras.DynamicProxy;应用拦截器

    }
}
</code></pre>
<p>根据程序集注册，请求一次实例化注入一次服务，请求结束自动释放继承IDisposable的对象资源；</p>
<p>在appsettings.json中配置你自己的连接字符串：</p>
<pre><code>"AppSetting": {
  "ConnectionStringSqlServer": "Data Source=xxxx;Initial Catalog=your_Db;User Id=sa;Password=xxxx;Encrypt=True;TrustServerCertificate=True;",
  "ConnectionStringOracle": "Server=.;Database=BookStore;Trusted_Connection=True;TrustServerCertificate=True"
}
</code></pre>
<p>而后在Program.cs中启用以上配置,代码如下：</p>
<pre><code>using Autofac;
using Autofac.Extensions.DependencyInjection;
using LHJ.Repository;
using LHJ.WebHost;

var builder = WebApplication.CreateBuilder(args);

// 使用 Autofac 作为服务容器
builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());

// 配置 Autofac 容器
builder.Host.ConfigureContainer&lt;ContainerBuilder&gt;(containerBuilder =&gt;
{
    // 注册服务
    containerBuilder.RegisterModule(new AutofacModuleRegister());
});

// Add services to the container.

builder.Services.AddControllers();

BaseDBConfig.ConnectionString = builder.Configuration.GetSection("AppSetting:ConnectionStringSqlServer").Value;

// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
//if (app.Environment.IsDevelopment())
//{
//    app.UseSwagger();
//    app.UseSwaggerUI();
//}

app.UseSwagger();
app.UseSwaggerUI();

app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<p>如果需要使用多库，则将数据库配置全部读进BaseDBConfig.ConnectionString；</p>
<p>这个时候你的项目【Webhost】应该可以正常启动，我们在SqlSugarCore项目下新建一个实体类Users.cs，代码如下：</p>
<pre><code>using SqlSugar;

namespace LHJ.SqlSugarCore.Entities;

/// &lt;summary&gt;
/// 
///&lt;/summary&gt;
[SugarTable("User")]
public class Users
{
    /// &lt;summary&gt;
    ///  
    ///&lt;/summary&gt;
    [SugarColumn(ColumnName = "Id", IsPrimaryKey = true)]
    public int Id  { get; set; }

    /// &lt;summary&gt;
    ///  
    ///&lt;/summary&gt;
    [SugarColumn(ColumnName = "Name")]
    public string? Name { get; set; }

    /// &lt;summary&gt;
    ///  
    ///&lt;/summary&gt;
    [SugarColumn(ColumnName = "Email")]
    public string? Email { get; set; }
}
</code></pre>
<p>IService项目下新建一个类ITestService，代码如下：</p>
<pre><code>
using LHJ.SqlSugarCore.Entities;


namespace LHJ.IService.IServices;

public interface ITestService:IBaseService&lt;Users&gt;
{
}
</code></pre>
<p>在Service项目中新建TestService类用于实现测试的接口类，代码如下：</p>
<pre><code>using LHJ.IRepository;
using LHJ.IService.IServices;
using LHJ.SqlSugarCore.Entities;

namespace LHJ.Service.Services;

public class TestService : BaseService&lt;Users&gt;, ITestService
{
    IBaseRepository&lt;Users&gt; _baseRepository;
    public TestService(IBaseRepository&lt;Users&gt; baseRepository) : base(baseRepository)
    {
        _baseRepository = baseRepository;
    }


}
</code></pre>
<p>在IRepository项目中新建ITestRepository.cs类,代码如下：</p>
<pre><code>using LHJ.SqlSugarCore.Entities;

namespace LHJ.IRepository.ManagerRepository;

public interface ITestPlanRepository : IBaseRepository&lt;Users&gt;
{

}

</code></pre>
<p>在Repository中新建TestPlanRepository类基础ITestRepository,代码如下：</p>
<pre><code>using LHJ.IRepository.ManagerRepository;
using LHJ.SqlSugarCore.Entities;

namespace LHJ.Repository.SugarRepository;

public class TestRepository : BaseRepository&lt;Users&gt;, ITestPlanRepository
{

}
</code></pre>
<p>最后添加一个控制器TestController.cs，代码如下：</p>
<pre><code>
using LHJ.IService.IServices;
using LHJ.SqlSugarCore.Entities;
using Microsoft.AspNetCore.Mvc;

namespace LHJ.WebHost.Controllers;

[ApiController]
[Route("api/[controller]/[action]")]
public class TestController : ControllerBase
{
    private readonly ITestService testService;

    public TestController(ITestService _testService) { this.testService = _testService; }

    [HttpGet]
    public Task&lt;Users&gt; GetUser(int Id)
    {
        return testService.QueryByID(Id);
    }
}
</code></pre>
<p>然后启动项目【Webhost】确保你使用的数据库与实体类符合，然后查询</p>
<p><img src="https://img2024.cnblogs.com/blog/3602392/202502/3602392-20250218144201693-2055479316.png" alt="" loading="lazy"></p>
<p>完成！！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8998681306932871" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-18 14:43">2025-02-18 14:42</span>&nbsp;
<a href="https://www.cnblogs.com/hadxs">hadxs</a>&nbsp;
阅读(<span id="post_view_count">39</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18721609" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18721609);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18721609', targetLink: 'https://www.cnblogs.com/hadxs/p/18721609', title: '.net 8 web api使用SqlSugar搭建仓储模式+Autofac依赖注入' })">举报</a>
</div>
        