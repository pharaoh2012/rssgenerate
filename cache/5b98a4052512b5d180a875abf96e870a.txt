
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaokang-coding/p/18761205" title="发布于 2025-03-09 19:18">
    <span role="heading" aria-level="2">震惊！C++程序真的从main开始吗？99%的程序员都答错了</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>嘿，朋友们好啊！我是小康。今天咱们来聊一个看似简单，但实际上99%的C++程序员都答错的问题：<strong>C++程序真的是从main函数开始执行的吗？</strong></p>
<p>如果你毫不犹豫地回答"是"，那恭喜你，你和大多数人一样——掉进了C++的第一个陷阱！别担心，等你看完这篇文章，你就能成为那个与众不同的1%了。</p>
<blockquote>
<p><strong>微信搜索 【跟着小康学编程】，关注我，定期分享计算机编程硬核技术文章。</strong></p>
</blockquote>
<h2 id="一揭开c启动的神秘面纱">一、揭开C++启动的神秘面纱</h2>
<p>还记得你写的第一个C++程序吗？可能是这样的：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>老师告诉你："程序从main函数开始执行"。然后你就这么相信了，一路写代码写到现在。但事实真的如此吗？</p>
<p><strong>剧透一下：并不是！</strong></p>
<p>如果你仔细思考，一定会冒出许多疑问：</p>
<ul>
<li>谁负责调用main函数？</li>
<li>在main执行前，系统到底做了什么？</li>
<li>为什么main前面的全局变量已经初始化好了？</li>
<li>main函数返回后又发生了什么？</li>
</ul>
<p>今天，我们就来一起掀开这神秘的黑箱，看看C++程序启动的真相！</p>
<h2 id="二c程序启动的真实过程">二、C++程序启动的真实过程</h2>
<p>想象一下，一个C++程序的生命周期就像一次电影拍摄：</p>
<p>1、<strong>前期准备</strong>：搭建场景，准备道具（操作系统加载程序）</p>
<p>2、<strong>彩排</strong>：演员就位，准备开拍（初始化运行环境）</p>
<p>3、<strong>正式拍摄</strong>：导演喊"Action!"（执行main函数）</p>
<p>4、<strong>收尾工作</strong>：打包器材，清理现场（释放资源，结束程序）</p>
<p>而我们平时只关注"正式拍摄"阶段，却忽略了其他同样重要的环节。</p>
<h3 id="第一幕操作系统的角色">第一幕：操作系统的角色</h3>
<p>当你双击一个.exe文件或者以命令行<code>./program</code> 执行时，发生了什么？</p>
<p>操作系统会首先加载可执行文件到内存，然后做一系列准备工作：</p>
<p>1、创建进程和线程</p>
<p>2、分配栈空间和堆空间</p>
<p>3、加载依赖的动态链接库（DLL或so文件）</p>
<p>4、 设置各种环境变量</p>
<p>这就像电影开拍前，场务人员布置好拍摄场地，准备好所有道具。</p>
<h3 id="第二幕cc运行时的初始化">第二幕：C/C++运行时的初始化</h3>
<p>操作系统准备好后，并不会直接跳到main函数，而是先调用C/C++运行时库的初始化代码。在Windows中，这通常是<code>_start</code>或<code>mainCRTStartup</code>，在Linux中是<code>_start</code>。</p>
<p><strong>这个启动函数负责完成以下工作</strong>：</p>
<p>1、初始化C运行时库</p>
<p>2、设置堆管理器的数据结构</p>
<p>3、初始化I/O子系统</p>
<p>4、处理命令行参数（构建argc和argv）</p>
<p>5、初始化全局变量和静态变量</p>
<p>6、调用全局对象的构造函数</p>
<p>7、最后才调用main函数</p>
<p>看到了吗？main函数实际上是被运行时库调用的！它不是起点，而是运行时库准备好一切后才执行的函数。</p>
<p><strong>我们来看个例子</strong>：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

// 全局变量
int globalVar = 42;

// 全局对象
class GlobalObject {
public:
    GlobalObject() {
        std::cout &lt;&lt; "全局对象构造函数被调用，此时main还没开始执行！" &lt;&lt; std::endl;
    }
    ~GlobalObject() {
        std::cout &lt;&lt; "全局对象析构函数被调用，此时main已经结束了！" &lt;&lt; std::endl;
    }
};

GlobalObject g_obj; // 全局对象实例

int main() {
    std::cout &lt;&lt; "现在才是main函数开始执行..." &lt;&lt; std::endl;
    std::cout &lt;&lt; "全局变量值：" &lt;&lt; globalVar &lt;&lt; std::endl;
    std::cout &lt;&lt; "main函数结束..." &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>运行这段代码，你会惊讶地发现输出是：</p>
<pre><code class="language-bash">全局对象构造函数被调用，此时main还没开始执行！
现在才是main函数开始执行...
全局变量值：42
main函数结束...
全局对象析构函数被调用，此时main已经结束了！
</code></pre>
<p>看到了吗？全局对象的构造函数在main函数之前就执行了！这就是最直接的证据：<strong>程序并非从main开始</strong>。</p>
<h3 id="第三幕main函数---只是主角而非导演">第三幕：main函数 - 只是主角，而非导演</h3>
<p>main函数的确很重要，它是我们编写业务逻辑的地方。但它就像电影中的主角，是整部戏的核心，却不是整个电影制作的起点。</p>
<p><strong>main函数有两种标准形式</strong>：</p>
<pre><code class="language-c++">int main() { /* ... */ }
</code></pre>
<p>或者带命令行参数的版本：</p>
<pre><code class="language-c++">int main(int argc, char* argv[]) { /* ... */ }
</code></pre>
<p>这些参数是谁准备的？没错，是运行时库！它将操作系统传来的命令行参数整理成C++程序易于使用的格式，然后再传给main函数。</p>
<h3 id="第四幕main函数结束后的故事">第四幕：main函数结束后的故事</h3>
<p>很多人以为main函数结束，程序就立刻退出了。但实际上，这只是电影的高潮过去了，还有结尾要拍。</p>
<p><strong>当 main 函数返回后</strong>：</p>
<p>1、运行时库接收到main的返回值</p>
<p>2、调用全局对象的析构函数（按照创建的相反顺序）</p>
<p>3、释放程序资源</p>
<p>4、将main的返回值传递给操作系统</p>
<p>5、最后结束进程</p>
<p>这就解释了为什么全局对象的析构函数在main函数结束后才被调用。</p>
<h2 id="实战例子我们来抓个现行">实战例子：我们来抓个现行！</h2>
<p>光说不练假把式。我们来做个实验，亲眼看看main函数前后都发生了什么。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

// 定义一个计数器
int initCounter = 0;

// 全局变量初始化
int globalA = ++initCounter;  // 应该是1
int globalB = ++initCounter;  // 应该是2

// 使用__attribute__((constructor))在main之前执行函数（GCC编译器特性）
__attribute__((constructor))
void beforeMain() {
    std::cout &lt;&lt; "【main之前】beforeMain函数执行，计数器值：" &lt;&lt; initCounter &lt;&lt; std::endl;
    std::cout &lt;&lt; "【main之前】全局变量globalA = " &lt;&lt; globalA &lt;&lt; ", globalB = " &lt;&lt; globalB &lt;&lt; std::endl;
}

// 使用__attribute__((destructor))在main之后执行函数
__attribute__((destructor))
void afterMain() {
    std::cout &lt;&lt; "【main之后】afterMain函数执行，计数器值：" &lt;&lt; initCounter &lt;&lt; std::endl;
}

// 全局类
class GlobalTracer {
public:
    GlobalTracer(const char* name) : name_(name) {
        std::cout &lt;&lt; "【main之前】全局对象 " &lt;&lt; name_ &lt;&lt; " 构造，计数器值：" &lt;&lt; ++initCounter &lt;&lt; std::endl;
    }
    
    ~GlobalTracer() {
        std::cout &lt;&lt; "【main之后】全局对象 " &lt;&lt; name_ &lt;&lt; " 析构，计数器值：" &lt;&lt; ++initCounter &lt;&lt; std::endl;
    }
private:
    const char* name_;
};

// 创建全局对象
GlobalTracer tracerA("A");  // 计数器应该是3
GlobalTracer tracerB("B");  // 计数器应该是4

// main函数
int main(int argc, char* argv[]) {
    std::cout &lt;&lt; "\n【main开始】main函数开始执行，计数器值：" &lt;&lt; ++initCounter &lt;&lt; std::endl;
    std::cout &lt;&lt; "【main中】命令行参数数量: " &lt;&lt; argc &lt;&lt; std::endl;
    
    // 创建局部对象
    GlobalTracer localObj("Local");  // 计数器应该是6
    
    std::cout &lt;&lt; "【main结束】main函数即将结束，计数器值：" &lt;&lt; ++initCounter &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>在 Linux 下用g++编译运行这段代码，你会得到类似这样的输出：</p>
<pre><code class="language-bash">【main之前】beforeMain函数执行，计数器值：0
【main之前】全局变量globalA = 0, globalB = 0
【main之前】全局对象 A 构造，计数器值：3
【main之前】全局对象 B 构造，计数器值：4

【main开始】main函数开始执行，计数器值：5
【main中】命令行参数数量: 1
【main之前】全局对象 Local 构造，计数器值：6
【main结束】main函数即将结束，计数器值：7
【main之后】全局对象 Local 析构，计数器值：8
【main之后】全局对象 B 析构，计数器值：9
【main之后】全局对象 A 析构，计数器值：10
【main之后】afterMain函数执行，计数器值：10
</code></pre>
<p>从输出中，我们可以清晰地看到整个流程：</p>
<p>1、首先初始化全局变量globalA和globalB</p>
<p>2、然后执行标记为constructor的beforeMain函数</p>
<p>3、接着构造全局对象A和B</p>
<p>4、之后才开始执行main函数</p>
<p>5、main函数返回后，首先析构局部对象Local</p>
<p>6、然后按照与构造相反的顺序析构全局对象B和A</p>
<p>7、最后执行标记为destructor的afterMain函数</p>
<h2 id="三初始化顺序魔鬼藏在细节里">三、初始化顺序：魔鬼藏在细节里</h2>
<p>现在我们知道C++程序不是从main开始的了，接下来要面对的是另一个容易让人头疼的问题：<strong>全局变量和对象的初始化顺序</strong>。这个问题就像是魔鬼一样，藏在细节里，稍不注意就会导致奇怪的bug。</p>
<h3 id="同一个cpp文件中的初始化是有序的">同一个.cpp文件中的初始化是有序的</h3>
<p>好消息是，如果所有全局变量和对象都在同一个.cpp文件中，那么它们的初始化顺序是完全可预测的：</p>
<ul>
<li>全局变量按照你写代码的顺序初始化（从上到下）</li>
<li>全局对象也按照你写代码的顺序构造（从上到下）</li>
</ul>
<p><strong>举个简单的例子</strong>：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int apple = 5;
int banana = apple * 2;  // banana = 10，因为apple已经初始化为5了

class Fruit {
public:
    Fruit(const char* name) {
        std::cout &lt;&lt; name &lt;&lt; "被构造了，此时banana = " &lt;&lt; banana &lt;&lt; std::endl;
    }
};

Fruit orange("橙子");  // 输出"橙子被构造了，此时banana = 10"
Fruit grape("葡萄");   // 输出"葡萄被构造了，此时banana = 10"
</code></pre>
<p>在这个例子中，一切都按照我们的预期进行：apple先初始化，然后banana初始化，接着orange构造，最后grape构造。这很简单，对吧？</p>
<h3 id="但是不同cpp文件中的初始化顺序是个迷">但是...不同.cpp文件中的初始化顺序是个迷</h3>
<p>现在问题来了！当你的程序有多个.cpp文件，每个文件都有自己的全局变量和对象时，它们之间的初始化顺序就变得不确定了。</p>
<p><strong>想象一下这种情况</strong>：</p>
<pre><code class="language-c++">// 文件1：breakfast.cpp
#include &lt;iostream&gt;

// 声明一个在dinner.cpp中定义的变量
extern int dinnerTime;

// 定义早餐时间
int breakfastTime = 7;

// 计算从早餐到晚餐的时间
int hoursBetweenMeals = dinnerTime - breakfastTime;

class Breakfast {
public:
    Breakfast() {
        std::cout &lt;&lt; "早餐准备好了！距离晚餐还有" 
                  &lt;&lt; hoursBetweenMeals &lt;&lt; "小时" &lt;&lt; std::endl;
    }
};

// 创建早餐对象
Breakfast myBreakfast;
</code></pre>
<pre><code class="language-c++">// 文件2：dinner.cpp
#include &lt;iostream&gt;

// 声明一个在breakfast.cpp中定义的变量
extern int breakfastTime;

// 定义晚餐时间
int dinnerTime = 18;

// 计算从早餐到晚餐的时间（和breakfast.cpp中的计算相同）
int mealGap = dinnerTime - breakfastTime;

class Dinner {
public:
    Dinner() {
        std::cout &lt;&lt; "晚餐准备好了！距离早餐已经过了" 
                  &lt;&lt; mealGap &lt;&lt; "小时" &lt;&lt; std::endl;
    }
};

// 创建晚餐对象
Dinner myDinner;
</code></pre>
<p><strong>问题来了</strong>：</p>
<ul>
<li>谁会先被初始化？breakfastTime还是dinnerTime？</li>
<li>hoursBetweenMeals和mealGap的值会是多少？</li>
<li>myBreakfast和myDinner哪个会先构造？</li>
</ul>
<p>答案是：<strong>完全不确定！</strong>这完全取决于编译器和链接器如何组合这些文件，而这些通常不在我们的控制范围内。</p>
<p>这就会导致非常诡异的问题。比如，如果dinner.cpp先初始化：</p>
<ul>
<li>dinnerTime被设为18</li>
<li>但breakfastTime还没初始化，它的值可能是任意垃圾值</li>
<li>mealGap = 18 - 垃圾值，得到一个无意义的结果</li>
<li>myDinner构造时打印这个无意义的值</li>
<li>然后breakfast.cpp才开始初始化...</li>
</ul>
<p>这种情况下，程序不会崩溃，但会输出错误的结果，这种bug特别难找！</p>
<h3 id="拯救方案用函数内的静态变量">拯救方案：用函数内的静态变量</h3>
<p>幸好，C++新标准提供了一个简单而优雅的解决方案，叫做"函数内静态变量"。这种方式有个特点：<strong>它们只在第一次调用该函数时才会被初始化。</strong></p>
<p>我们来看看如何利用这个特性解决问题：</p>
<pre><code class="language-c++">// 使用函数包装我们的全局变量
int&amp; getBreakfastTime() {
    static int breakfastTime = 7;  // 只在第一次调用时初始化
    return breakfastTime;
}

int&amp; getDinnerTime() {
    static int dinnerTime = 18;  // 只在第一次调用时初始化
    return dinnerTime;
}

// 需要用到这些值时，调用函数获取
int getHoursBetweenMeals() {
    return getDinnerTime() - getBreakfastTime();  // 现在顺序没问题了！
}
</code></pre>
<p>这种方式，我们不再依赖全局变量的初始化顺序，而是在需要用到这些值的时候才去获取它们。由于函数内静态变量保证只初始化一次，所以无论你调用多少次，都只会有一份数据。</p>
<p>还可以把这种思路扩展为"单例模式"，用于全局对象：</p>
<pre><code class="language-c++">class Restaurant {
public:
    // 获取唯一的Restaurant实例
    static Restaurant&amp; getInstance() {
        // 这个static对象只在第一次调用时创建
        static Restaurant instance;
        return instance;
    }
    
    void serveBreakfast() {
        std::cout &lt;&lt; "早餐时间到！" &lt;&lt; std::endl;
    }
    
    void serveDinner() {
        std::cout &lt;&lt; "晚餐时间到！" &lt;&lt; std::endl;
    }
    
private:
    // 构造函数设为私有，防止外部创建对象
    Restaurant() {
        std::cout &lt;&lt; "餐厅开业了！" &lt;&lt; std::endl;
    }
};

// 使用方式
void morningRoutine() {
    // 第一次调用会初始化Restaurant
    Restaurant::getInstance().serveBreakfast();
}

void eveningRoutine() {
    // 再次调用会返回同一个Restaurant实例
    Restaurant::getInstance().serveDinner();
}
</code></pre>
<p>这样，无论morningRoutine()和eveningRoutine()哪个先被调用，Restaurant对象都只会在第一次调用时被创建，而且我们可以确保在使用它之前它已经被正确初始化了。</p>
<p>这就是为什么单例模式在C++中如此流行 - 它不仅能保证全局只有一个实例，还能解决初始化顺序的问题！厉害吧？</p>
<blockquote>
<p><strong>微信搜索 【跟着小康学编程】，关注我，定期分享计算机编程硬核技术文章。</strong></p>
</blockquote>
<h2 id="四深入理解一个完整程序的启动过程">四、深入理解：一个完整程序的启动过程</h2>
<p>让我们把整个过程连起来，看看从你双击程序到main函数执行再到程序结束，完整的流程是怎样的：</p>
<p>1、<strong>操作系统加载阶段</strong></p>
<ul>
<li>加载可执行文件到内存</li>
<li>创建进程和线程</li>
<li>分配内存空间（栈、堆等）</li>
<li>加载所需的动态链接库</li>
<li>跳转到程序入口点（通常是_start）</li>
</ul>
<p>2、 <strong>C/C++运行时初始化阶段</strong></p>
<ul>
<li>初始化C运行时库</li>
<li>设置堆管理器的数据结构</li>
<li>初始化I/O子系统</li>
<li>设置环境变量</li>
<li>准备命令行参数（argc, argv）</li>
<li>初始化全局/静态变量和对象</li>
<li>调用constructor属性的函数</li>
</ul>
<p>3、 <strong>main函数执行阶段</strong></p>
<ul>
<li>调用main(argc, argv)</li>
<li>执行用户代码</li>
<li>返回退出码</li>
</ul>
<p>4、 <strong>程序终止阶段</strong></p>
<ul>
<li>接收main函数的返回值</li>
<li>调用全局/静态对象的析构函数</li>
<li>调用destructor属性的函数</li>
<li>释放程序资源</li>
<li>将退出码返回给操作系统</li>
<li>终止进程</li>
</ul>
<h2 id="五实际应用为什么这些知识很重要">五、实际应用：为什么这些知识很重要？</h2>
<p>你可能会想："知道这些有什么用？反正我的代码还是从main开始写起。"</p>
<p>实际上，理解这个过程对解决许多实际问题非常有帮助：</p>
<h3 id="1-全局对象的依赖问题">1. 全局对象的依赖问题</h3>
<p>如果你的程序使用全局对象，并且这些对象之间有依赖关系，那么初始化顺序就至关重要。了解C++的初始化机制可以帮你避免因初始化顺序不确定导致的微妙bug。</p>
<h3 id="2-资源管理">2. 资源管理</h3>
<p>理解main函数返回后的清理过程，有助于你正确管理资源，避免其他资源泄漏问题。</p>
<h3 id="3-构造函数中的陷阱">3. 构造函数中的陷阱</h3>
<p>全局对象的构造函数中不应该依赖其他全局对象（除非你能确保初始化顺序），因为这可能导致"静态初始化顺序问题"。</p>
<h3 id="4-调试复杂问题">4. 调试复杂问题</h3>
<p>当你遇到一些奇怪的问题，比如程序启动崩溃但没有明显错误时，了解启动过程可以帮你定位问题。</p>
<h3 id="5-面试加分项">5. 面试加分项</h3>
<p>这绝对是面试中的一个亮点！当面试官问"C++程序从哪里开始执行"时，如果你能详细解释整个过程，一定会给面试官留下深刻印象。</p>
<h2 id="六高级技巧控制main函数前后的执行">六、高级技巧：控制main函数前后的执行</h2>
<p>了解了C++程序的启动过程，我们还可以利用这些知识来做一些有趣的事情：</p>
<h3 id="1-在main之前执行代码">1. 在main之前执行代码</h3>
<p>除了前面提到的<code>__attribute__((constructor))</code>，还有其他方法可以在main之前执行代码：</p>
<h4 id="全局对象的构造函数">全局对象的构造函数</h4>
<pre><code class="language-c++">class StartupManager {
public:
    StartupManager() {
        // 这里的代码会在main之前执行
        std::cout &lt;&lt; "程序启动中..." &lt;&lt; std::endl;
        // 做一些初始化工作
    }
};

// 创建全局对象
StartupManager g_startupManager;
</code></pre>
<h4 id="编译器特定的扩展">编译器特定的扩展</h4>
<p>在GCC中：</p>
<pre><code class="language-c++">void beforeMain() __attribute__((constructor));
void beforeMain() {
    // 这里的代码会在main之前执行
}
</code></pre>
<h3 id="2-在main之后执行代码">2. 在main之后执行代码</h3>
<h4 id="使用atexit注册清理函数">使用atexit注册清理函数</h4>
<pre><code class="language-c++">#include &lt;cstdlib&gt;

void cleanupFunction() {
    // 这里的代码会在main之后执行
    std::cout &lt;&lt; "程序清理中..." &lt;&lt; std::endl;
}

int main() {
    // 注册清理函数
    atexit(cleanupFunction);
    
    std::cout &lt;&lt; "main已结束..." &lt;&lt; std::endl;
    // 正常的main函数代码
    return 0;
}
</code></pre>
<h4 id="全局对象的析构函数">全局对象的析构函数</h4>
<pre><code class="language-c++">class ShutdownManager {
public:
    ~ShutdownManager() {
        // 这里的代码会在main之后执行
        std::cout &lt;&lt; "程序关闭中..." &lt;&lt; std::endl;
    }
};

// 创建全局对象
ShutdownManager g_shutdownManager;
</code></pre>
<h4 id="编译器特定的扩展-1">编译器特定的扩展</h4>
<p>在GCC中：</p>
<pre><code class="language-c++">void afterMain() __attribute__((destructor));
void afterMain() {
    // 这里的代码会在main之后执行
}
</code></pre>
<h2 id="总结揭开c启动的神秘面纱">总结：揭开C++启动的神秘面纱</h2>
<p>通过这篇文章，我们已经揭开了C++程序启动过程的神秘面纱：</p>
<p>1、<strong>C++程序根本不是从main函数开始的</strong>！在main执行前，系统和运行时库已经偷偷做了大量工作</p>
<p>2、全局变量和对象在main函数执行前就已经初始化完毕，这就是为什么main函数一开始就能使用它们</p>
<p>3、main函数结束不等于程序结束，之后还有全局对象析构、资源释放等一系列"收尾工作"</p>
<p>4、跨文件的全局对象初始化顺序是个"定时炸弹"，搞不好就会引发难以察觉的bug</p>
<p>5、掌握了这些知识，你可以利用constructor/destructor属性、全局对象构造/析构函数、atexit函数等工具在main函数前后插入自己的代码，实现自动初始化和清理功能</p>
<p>下次有人告诉你"C++程序从main开始执行"，你可以自豪地纠正他们了！</p>
<p>是不是觉得C++比想象的要复杂得多？别担心，这正是C++的魅力所在 — 它让你能掌控程序的每一个细节，从出生到死亡的全过程。真正的C++高手，就是了解这些不为人知的秘密！</p>
<p>如果这篇文章让你有所收获，别忘了点赞、收藏、关注，让更多的C++爱好者看到！</p>
<p>有疑问？有经验想分享？欢迎在评论区留言交流~</p>
<p>想持续充电？「<strong>跟着小康学编程</strong>」公众号等你关注，每周定期推送接地气的编程干货，让你的编程水平蹭蹭往上涨！</p>
<h4 id="怎么关注我的公众号">怎么关注我的公众号？</h4>
<p>扫下方公众号二维码即可关注。</p>
<p><img src="https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png" alt="" loading="lazy"></p>
<p>另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！</p>
<p><img src="https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7066268397407407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-09 19:19">2025-03-09 19:18</span>&nbsp;
<a href="https://www.cnblogs.com/xiaokang-coding">江小康</a>&nbsp;
阅读(<span id="post_view_count">279</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18761205" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18761205);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18761205', targetLink: 'https://www.cnblogs.com/xiaokang-coding/p/18761205', title: '震惊！C++程序真的从main开始吗？99%的程序员都答错了' })">举报</a>
</div>
        