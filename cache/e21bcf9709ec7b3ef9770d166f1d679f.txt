
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/doooge/p/18961442" title="发布于 2025-07-02 14:37">
    <span role="heading" aria-level="2">KMP算法详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        KMP详解
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>哈喽大家好，我是 doooge。今天给大家带来的是 KMP 算法的解析。</p>
<p></p><div class="math display">\[\Huge \sf 浅析 KMP 算法
\]</div><p></p><h1 id="1算法简介">1.算法简介</h1>
<p>首先我们要知道 KMP 是干什么的。先引入一个例题：</p>
<blockquote>
<p>给定两个字符串 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，求出 <span class="math inline">\(A\)</span> 有多少个子串和 <span class="math inline">\(B\)</span> 相同，输出它们出现的位置。<span class="math inline">\(|B| \le |A| \le 5 \times 10^3\)</span>。</p>
</blockquote>
<p>这道题看上去很简单，因为 <span class="math inline">\(|A|\)</span> 不超过 <span class="math inline">\(5000\)</span>，那我们就可以用暴力来查找，也就是说枚举 <span class="math inline">\(A\)</span> 中每一个字符作为起点，来判断是否能和 <span class="math inline">\(B\)</span> 匹配，匹配完了后我们就可以移动字符串 <span class="math inline">\(B\)</span> 到下一位，如果可以就输出答案。</p>
<p>例如，有两个字符串分别为 <code>abacab</code> 和 <code>ab</code> 那么匹配的过程就是：</p>
<p><img src="https://s1.imagehub.cc/images/2025/07/02/d34372f645147a889daf18bc248d86f7.gif" alt="寻找过程" loading="lazy"></p>
<p>上代码：</p>
<pre><code class="language-cpp">for(int i=0;i&lt;a.size()-b.size();i++){//防止越界
    bool flag=true;
    for(int j=i;j&lt;i+b.size();j++){
        if(a[i]!=b[j]){
            flag=false;
            break;
        }
    }
    if(flag)cout&lt;&lt;i&lt;&lt;' ';
}
</code></pre>
<p>时间复杂度 <span class="math inline">\(O(|A| \cdot |B|)\)</span>，也就是 <span class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="2正片kmp算法的思想">2.正片：KMP算法的思想</h1>
<p>我们还是给出这道题：</p>
<blockquote>
<p>给定两个字符串 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，求出 <span class="math inline">\(A\)</span> 有多少个子串和 <span class="math inline">\(B\)</span> 相同，输出它们出现的位置。<span class="math inline">\(|B| \le |A| \le 10^6\)</span>。<br>
<s>其实就是为了水字数</s></p>
</blockquote>
<p>此时，<span class="math inline">\(O(n^2)\)</span> 的暴力显然会挂掉<s>除非你是欧皇每次刚开始匹配就结束</s>，那么我们该如何应对这样丧心病狂的题目呢？</p>
<h2 id="21-优化的思路">2.1 优化的思路</h2>
<p>我们可以好好想想是从这个暴力哪里会让时间很长。我们可以逐个优化。我们用字符串 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 分别为 <code>ABABABABC</code> 和 <code>ABABC</code> 这两个字符串来模拟一下，我们需要一个指针 <span class="math inline">\(i\)</span> 来记录比到了什么位置。</p>
<p>首先，我们先枚举从第 <span class="math inline">\(i\)</span> 位开始后面的字符串是否相同，我们的指针 <span class="math inline">\(i\)</span> 会从 <span class="math inline">\(1\)</span> 扫到 <span class="math inline">\(4\)</span>，此时的 <span class="math inline">\(A_i\)</span> 都和 <span class="math inline">\(B_i\)</span> 相同。但是当 <span class="math inline">\(i\)</span> 扫到第 <span class="math inline">\(5\)</span> 位时，由于 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_i\)</span> 并不相同，所以第一次枚举失败。<strong>指针 <span class="math inline">\(i\)</span> 会回到 <span class="math inline">\(2\)</span> 来枚举第 <span class="math inline">\(2\)</span> 位字符是否能成功匹配</strong>，由此循环往复。</p>
<p>我们会发现，正是这个回溯一样的操作才会使时间爆炸。尤其是这个<s>毒瘤</s>***钻的字符串 <span class="math inline">\(A\)</span>，会让 <span class="math inline">\(i\)</span> 指针傻傻的回退很多很多次，这样，我们就可以收获一个大大的 TLE 啦！</p>
<p>这肯定是不可能的。那我们有没有一种可以让指针 <span class="math inline">\(i\)</span> 不往后退的算法呢？</p>
<p>于是，KMP 就这样诞生了！</p>
<h2 id="22-优化后的算法">2.2 优化后的算法</h2>
<p>在暴力算法中，我们的 <span class="math inline">\(i\)</span> 指针一直回退，才导致的超时的。</p>
<p>那么有什么可以让 <span class="math inline">\(i\)</span> 指针不降呢？我们是否能从已经比较过的内容中找到一些线索呢？</p>
<p>比如说，有这么两个字符串 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 分别为 <code>ABABABABC</code> 和 <code>ABABC</code>，在第一次比较 <code>ABABA</code> 和 <code>ABABC</code> 时，我们会发现当指针 <span class="math inline">\(i\)</span> 走到 <span class="math inline">\(5\)</span> 时字符串不匹配，那么我们是否可以将 <span class="math inline">\(B\)</span> 向后移动一定的距离，来达到 <span class="math inline">\(i\)</span> 指针不下降的目的呢？请看下面：</p>
<p><img src="https://s1.imagehub.cc/images/2025/07/02/a367410fdbeb05930b95743445796449.gif" alt="移动过程" loading="lazy"></p>
<p>由于 <span class="math inline">\(B\)</span> 串前面的 <code>AB</code> 和 <span class="math inline">\(A\)</span> 串这里的 <code>AB</code> 是相同的，我们这样移位并没有什么问题。于是，我们就这样跳过了许许多多的比较，节省了非常多的时间。</p>
<p>那么我们怎么才能知道我们要跳过多少字符呢？我们可以用一个 <span class="math inline">\(next\)</span> 数组来记录。我们先不用管 <span class="math inline">\(next\)</span> 是怎么来的，用就完了。比如说上面的 <span class="math inline">\(B\)</span> 串，其中每个下标 <span class="math inline">\(i\)</span> 对应的 <span class="math inline">\(next_i\)</span> 是这样的：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串 <span class="math inline">\(B\)</span> 中表示的值</td>
<td><span class="math inline">\(A\)</span></td>
<td><span class="math inline">\(B\)</span></td>
<td><span class="math inline">\(A\)</span></td>
<td><span class="math inline">\(B\)</span></td>
<td><span class="math inline">\(A\)</span></td>
</tr>
<tr>
<td>对应的 <span class="math inline">\(next_i\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(3\)</span></td>
</tr>
</tbody>
</table>
<p>可以自己去模拟一下。假设 <span class="math inline">\(|A|=n\)</span>，<span class="math inline">\(|B|=m\)</span>。</p>
<p>那么我们的查找的步骤就是：</p>
<ol>
<li>创建两个指针 <span class="math inline">\(i=1\)</span> 和 <span class="math inline">\(j=0\)</span>。</li>
<li>如果 <span class="math inline">\(A_i=B_{j+1}\)</span>，那么就说明可以继续匹配，将 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 分别加 <span class="math inline">\(1\)</span>。</li>
<li>重复执行 <span class="math inline">\(3 \sim 6\)</span> 步直到 <span class="math inline">\(i=n\)</span>。</li>
<li>如果匹配失败，如果 <span class="math inline">\(j&gt;0\)</span>，使 <span class="math inline">\(j=next_{j-1}\)</span>，看是否能够继续匹配，这一步最多执行 <span class="math inline">\(n\)</span> 次。</li>
<li>否则如果 <span class="math inline">\(j=0\)</span>，从一开始就匹配失败了，直接将 <span class="math inline">\(i+1\)</span>。</li>
<li>如果 <span class="math inline">\(j=m\)</span>，表示匹配成功，输出一开始的下标，也就是 <span class="math inline">\(i-j+1\)</span>。</li>
</ol>
<p>上代码（因为 c++ 中的变量名不能用 <span class="math inline">\(next\)</span> <s>我也不知道为啥</s>，于是我用 <span class="math inline">\(nxt\)</span> 代替了一下）：</p>
<pre><code class="language-cpp">j=0;//初始化指针j=0
for(int i=0;i&lt;n;){//指针i从0~n-1 
    if(s[i]==s2[j])i++,j++;//如果匹配成功就继续 
    else if(j&gt;0)j=nxt[j-1];//否则就j=nxt[j-1]看是否能继续匹配 
    else i++;//如果从一开始就匹配不上就让指针i++ 
    if(j==m){//如果匹配成功 
        cout&lt;&lt;i-j+1&lt;&lt;'\n';//输出开始匹配的位置i-j+1 
        j=nxt[j-1];//j=nxt[j-1]一边继续匹配 
    }
}
</code></pre>
<p>那我们应该如何求 <span class="math inline">\(next\)</span> 数组呢？请往下看。</p>
<h2 id="22-公共前缀后缀border">2.2 公共前缀后缀（border）</h2>
<p>首先说明一下，<span class="math inline">\(S_{i \to j}\)</span> 表示 <span class="math inline">\(S\)</span> 中下标为 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 的子串。</p>
<p>正如题目所述，<span class="math inline">\(S\)</span> 的 border 表示 <span class="math inline">\(S\)</span> 的公共的前缀和后缀，<span class="math inline">\(S\)</span> 的最长的 border 表示 <span class="math inline">\(S\)</span> 的最长的公共的前缀和后缀。<span class="math inline">\(S\)</span> 的前缀和后缀相信大家都知道吧，<code>abcab</code> 的前缀有 <code>a</code>，<code>ab</code>，<code>abc</code> 等等，而后缀有 <code>b</code>，<code>ab</code>，<code>cab</code> 等等。</p>
<p>比如说，如果 <span class="math inline">\(S\)</span> 为 <code>abcabc</code>，那么 <span class="math inline">\(S\)</span> 的 border 只有一个，就是 <code>abc</code>，因为 <span class="math inline">\(S\)</span> 的前缀和后缀中分别都有 <code>abc</code> 这个字符串。<strong>特别的，<span class="math inline">\(S\)</span> 本身并不是一个 border</strong>，也就是 <code>aaa</code> 不是 <code>aaa</code> 的 border，只有 <code>a</code> 和 <code>aa</code> 才是。</p>
<p>那么这跟 <span class="math inline">\(next\)</span> 数组有什么关系呢？</p>
<p>我们可以分析一下 <span class="math inline">\(next\)</span>，拿一个例子：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ms0fidyf.png" alt="" loading="lazy"></p>
<p>稍微转变一下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k08ocjhe.png" alt="" loading="lazy"></p>
<p>再把不相关的东西给去掉：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mbz0ylti.png" alt="" loading="lazy"></p>
<p>诶！这个东西好像就是刚刚说的最长的公共前缀后缀吗？</p>
<p>没错，这就是 <span class="math inline">\(next\)</span> 的核心求法，我们在举个例子详细说一说，设上面的字符串为 <span class="math inline">\(A\)</span>，下面的字符串为 <span class="math inline">\(B\)</span>：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m4xelm3r.png" alt="" loading="lazy"></p>
<p>当我们发现匹配不上时，为了找到所有潜在的答案，所以因该找到一个最靠左边且可能可以重新匹配的下标。比如说炸这幅图中最小的下标是 <span class="math inline">\(4\)</span>。而如果从 <span class="math inline">\(4\)</span> 开始匹配，能匹配 <span class="math inline">\(3\)</span> 个字符，也就是 <span class="math inline">\(B_{1 \to 3}\)</span> 这一段子串，进而我们就能得知 <span class="math inline">\(next_7=3\)</span>。</p>
<p>那为什么是 <span class="math inline">\(3\)</span> 呢？我们可以先把刚刚已经匹配的 <span class="math inline">\(A\)</span> 的部分移下来。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/285n7ifl.png" alt="" loading="lazy"></p>
<p>此时我们需要最小可以重新匹配的坐标，也就是 <span class="math inline">\(B\)</span> 字符串右边这一段长度最大，那我们可以推回去。因为 <span class="math inline">\(B\)</span> 字符串右边这一段，也就是 <span class="math inline">\(A\)</span> 字符串右边这一段，又因为我们要找的是重新匹配的位置，所以也就是从 <span class="math inline">\(B\)</span> 的第一项开始匹配，也就是说，我们想要求出最左边可以重新匹配的下标，也就是需要最长的长度 <span class="math inline">\(x\)</span> 使 <span class="math inline">\(B_{1 \to x}=B_{i-x+1 \to i}\)</span>，也就是 <span class="math inline">\(B\)</span> 的最长的公共前缀后缀。</p>
<p>如此，我们就可以用求出 <span class="math inline">\(S_{1 \to i}\)</span> 的最长公共前缀后缀的长度来计算 <span class="math inline">\(next\)</span> 数组了。</p>
<h2 id="23-next数组的求法">2.3 next数组的求法</h2>
<p>如果我们用暴力求解 <span class="math inline">\(next\)</span> 数组，时间复杂度很差，因为我们对于每一个下标 <span class="math inline">\(i\)</span> 都要求一遍 <span class="math inline">\(next_i\)</span>，这需要枚举长度然后再根据长度来判断，时间复杂度 <span class="math inline">\(O(n^3)\)</span>，实在太差，有这时间还不如去打暴力呢。</p>
<p>当然，这个求法有很大的改进空间，我们可以一步一步优化它。</p>
<h2 id="24-next求法优化">2.4 next求法优化</h2>
<p>显然，我们需要优化 <span class="math inline">\(next\)</span> 数组的求法过程。</p>
<p>我们在求解 <span class="math inline">\(next_i\)</span> 时，显然已知 <span class="math inline">\(next_1\)</span> 到 <span class="math inline">\(next_{i-1}\)</span>，我们应该从已经求出 <span class="math inline">\(next\)</span> 数组的值来求出 <span class="math inline">\(next_i\)</span> <s>这是什么废话</s>。</p>
<p>想想，<span class="math inline">\(S_{1 \to i-1}\)</span> 与 <span class="math inline">\(S_{1 \to i}\)</span> 只差了 <span class="math inline">\(S_i\)</span> 这一个字符，然而我们又知道 <span class="math inline">\(S_{i-next_{i-1} \to i-1}=S_{1 \to next_{i-1}}\)</span>，也就是 <span class="math inline">\(S\)</span> 下标 <span class="math inline">\(i-1\)</span> 的最长后缀等于最长前缀，那我们可不可以继承 <span class="math inline">\(next_{i-1}\)</span> 求出 <span class="math inline">\(next_i\)</span> 呢？请看下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/71p4qeji.png" alt="" loading="lazy"></p>
<p>所以，当 <span class="math inline">\(S_i=S_{next_{i-1}+1}\)</span> 时，<span class="math inline">\(next_i\)</span> 就能继承 <span class="math inline">\(next_{i-1}\)</span>。</p>
<p>但是这还不够，如果 <span class="math inline">\(S_i \not = S_{next_{i-1}+1}\)</span> 时，我们应该怎么办呢？不会又要回到之前的暴力求解了吧。</p>
<p>不如我们来看下面的例子：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1qyegiiw.png" alt="" loading="lazy"></p>
<p>我们会发现，虽然匹配不成功，但是 <span class="math inline">\(next_i\)</span> 可以从开头的 <span class="math inline">\(AB\)</span> 转移过来。</p>
<p>那我们应该怎么知道 <span class="math inline">\(next_i\)</span> 是从开头的 <span class="math inline">\(AB\)</span> 转移过来呢？</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/39donadk.png" alt="" loading="lazy"></p>
<p>我们知道，<span class="math inline">\(S_{1 \to i-1}\)</span> 的前缀子串和后缀子串是相等的，那么是不是 <span class="math inline">\(S_{1 \to i-1}\)</span> 的前缀子串的前缀子串和后缀子串的后缀子串是相等的？</p>
<p>这句话虽然有点绕，但是从上面的图片不难看出，<span class="math inline">\(next_i\)</span> 可以从 <span class="math inline">\(next_{next_{i-1}}\)</span> 转移过来，也就是如果 <span class="math inline">\(S_i=S_{next_{next_{i-1}}+1}\)</span> 时，<span class="math inline">\(next_i\)</span> 就能从 <span class="math inline">\(next_{next_{i-1}}\)</span> 转移过来。不难发现，我们可以如此递归（设目前 <span class="math inline">\(next_i\)</span> 的长度为 <span class="math inline">\(len\)</span>）<span class="math inline">\(len=next_{len-1}\)</span>，直到 <span class="math inline">\(S_i=S_len\)</span> 或 <span class="math inline">\(len=0\)</span> 为止。</p>
<p>综上所述，<span class="math inline">\(next_i\)</span> 可以这样转移，我们设目前的下标 <span class="math inline">\(i=1\)</span> 和目前的长度 <span class="math inline">\(len=0\)</span>：</p>
<ul>
<li>如果 <span class="math inline">\(S_i=S_{len}\)</span>，那么 <span class="math inline">\(next_i=len\)</span>，将 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(len\)</span> 增加 <span class="math inline">\(1\)</span>。</li>
<li>否则，如果 <span class="math inline">\(len=0\)</span>，那么 <span class="math inline">\(next_i=len\)</span>，将 <span class="math inline">\(i\)</span> 增加 <span class="math inline">\(1\)</span>。</li>
<li>否则，将 <span class="math inline">\(len\)</span> 变为 <span class="math inline">\(next_{len-1}\)</span>，递归下去。</li>
</ul>
<p>不难发现，递归次数不会大于 <span class="math inline">\(|S|\)</span> 次。于是，我们将求 <span class="math inline">\(next\)</span> 数组的复杂度降为了 <span class="math inline">\(O(n)\)</span>。</p>
<p>所以，写出 KMP 的代码就不难了吧！</p>
<h1 id="3kmp算法的代码">3.KMP算法的代码</h1>
<p><a href="https://www.luogu.com.cn/problem/P3375" target="_blank" rel="noopener nofollow">P3375 【模板】KMP</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int nxt[1000010],n,m,len,j;
string s,s2;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin&gt;&gt;s&gt;&gt;s2;
    n=s.size(),m=s2.size();
    for(int i=1;i&lt;m;){
        if(s2[i]==s2[len]){
            nxt[i]=++len;
            i++;
        }else{
            if(len==0){
                nxt[i]=0;
                i++;
            }else len=nxt[len-1];
        }
    }
    j=0;
    for(int i=0;i&lt;n;){
        if(s[i]==s2[j])i++,j++;
        else if(j&gt;0)j=nxt[j-1];
        else i++;
        if(j==m){
        	cout&lt;&lt;i-j+1&lt;&lt;'\n';
        	j=nxt[j-1];
    	}
    }
	for(int i=0;i&lt;s2.size();i++){
        cout&lt;&lt;nxt[i]&lt;&lt;' ';
    }
	cout&lt;&lt;endl;
	return 0;
}
</code></pre>
<h1 id="4闲话">4.闲话</h1>
<p>蒟蒻不才，膜拜大佬，如果文章有任何的错字等问题，请在评论区 @我。</p>
<p>感谢这个视频教会了我KMP，也推荐大家都去学一学，讲的很详细：<a href="https://www.bilibili.com/video/BV1AY4y157yL/" target="_blank" rel="noopener nofollow">最浅显易懂的 KMP 算法讲解</a>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011805555555555555" data-date-updated="2025-07-02 14:54">2025-07-02 14:37</span>&nbsp;
<a href="https://www.cnblogs.com/doooge">doooge</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18961442);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18961442', targetLink: 'https://www.cnblogs.com/doooge/p/18961442', title: 'KMP算法详解' })">举报</a>
</div>
        