
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SilverGo/p/19023190" title="发布于 2025-08-05 14:20">
    <span role="heading" aria-level="2">《算法导论》笔记——循环不变式及插入排序证明</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>算法导论第二章中提出了一个概念－－<strong>“循环不变式”</strong></p>
<h4 id="那么何为循环不变式">那么，何为循环不变式</h4>
<p>我的理解是：</p>
<blockquote>
<p>“循环不变式是用于证明算法正确性的一种工具”</p>
</blockquote>
<h4 id="它应该怎么用呢">它应该怎么用呢</h4>
<ul>
<li>首先，对于任意的一种算法，我们需要找出其循环不变式</li>
<li>然后，需要证明循环不变式的三条性质</li>
</ul>
<h4 id="对于插入排序算法它的证明是这样的">对于插入排序算法，它的证明是这样的：</h4>
<ul>
<li>设下标j为目前正在排序的数字的索引，开始时j = 1（C++中索引从0开始，我们这里从第二个元素开始排，至于为什么，请往下读）</li>
<li><strong>循环不变式：“for循环每次开始时，A[0…j-1]是有序的”</strong></li>
</ul>
<h4 id="接下来我们证明三条性质">接下来我们证明三条性质：</h4>
<ul>
<li>初始化 ：循环的第⼀次迭代之前，循环不变式为真</li>
<li>保持 ：如果循环的某次迭代之前循环不变式为真，那么下次迭代之前它仍为真</li>
<li>终止 ：终止时不变式要能做到符合结果（比如：完成排序）</li>
</ul>
<h4 id="证明">证明：</h4>
<p>1.初始化：显然，j = 1时，A[0…j-1]就是A[0]，只有一个数字，当然是符合循环不变式的<br><br>
2.保持：若 A[0..j-1] 有序，将 A[j] 插入后，A[0..j] 仍有序<br><br>
3.终止：终止时，当 j = n 时，A[0..n] 整体有序，排序完成<br><br>
因此你可以看到，事实上，循环不变式就是用来规范证明算法正确性的工具</p>
<p><strong>如果你对数学归纳法比较熟的话，很容易发现其实循环不变式就是数学归纳法的一个变种</strong></p>
<h3 id="如何找循环不变式">如何找循环不变式？</h3>
<p>由于算法是一步步执行的，那么如果每一步（包括初试和结束）都满足一个共同的条件，那么这个条件就是要找的循环不变式（loop invariant）</p>
<h3 id="一个例子">一个例子：</h3>
<p>二分查找</p>
<p><strong>不变式：若目标值存在，则必在子数组 A[l..r] 中</strong></p>
<p>证明要点：<br><br>
初始化：l=0, r=n-1，覆盖整个数组 <br><br>
保持：根据中间值比较调整边界，目标值仍在新区间内 <br><br>
终止：l &gt; r 时子数组为空，目标不存在 → 返回 -1 <br><br><br>
我们发现，三条性质都符合我们的要求（初始化和保持满足不变式、终止符合要求的结果），所以算法正确</p>
<blockquote>
<p>循环不变式不只是理论工具——它强迫你在写循环时明确“我试图维护什么”。这种思维习惯能显著减少代码错误。<br><br>
——《算法导论》核心思想</p>
</blockquote>
<h2 id="插入排序">插入排序</h2>
<h3 id="算法原理">算法原理：</h3>
<p>插入排序与我们手动整理一副牌的过程类似（这里我们引用算法导论上的比喻）<br></p>
<p>(注意，目前为了易读，我们讨论升序排序，对于非升序，参考GitHub:<a href="https://github.com/Ghost-Silver/algorithm" target="_blank" rel="noopener nofollow">《算法导论》笔记</a>src/insertion_sort(插入排序).h中的注释</p>
<p>想象一下：你现在右手放着一副乱序的牌，左手开始时什么都没有<br>
我们规定：右手的牌是无序的，左手始终有序<br>
那么，我们现在从右手拿出一张牌，放到左手中<br>
此时，你左手的牌仍然有序，因为此时只有一张牌，符合规定</p>
<p>接着，我们去拿下一张牌，这时有两种情况：<br>
1.当前的牌面&gt;=左手牌面<br>
2.当前的牌面&lt;左手牌面<br>
对于1，我们直接将牌放于左手的顶部即可<br>
对于2，我们需要将牌放于左手第一张的下面</p>
<br>
让我们重复这个过程：<br>
1.取出一张牌，我们记录它的值为key<br>
2.从左手的第一张开始，逐个比较(我们记为A[j])，直到key&lt;=A[j]，执行3；<br>
3.那么此时，A[j+1]就是key这个值在左手上的正确位置，我们令A[j+1]=key，<br>相当于把key插入到对应位置<br>
4.执行1-3，直到整个数列有序
<br>
<p>问题是，在计算机中，我们没办法执行<code>插入</code>这个操作，更具体的说，令A[j+1]=key时，会丢失A[j+1]的值</p>
<p>此时想想排牌时的操作：<strong>当我们找到合适位置时，我们会将它右侧的所有牌右移一点，<code>腾出</code>一个空位来</strong><br></p>
<h4 id="那么在算法中我们应该怎么办呢">那么在算法中，我们应该怎么办呢？<br></h4>
<p>很简单，我们做一点点修改：<br><br>
在上述的过程2中，如果我们发现key&gt;A[j]，我们令A[j+1] = A[j]<br></p>
<p>可以试验一下：<br>
假设左手牌为：2，4<br>
当前的key = 3<br>
当前的j = 1（C++索引从0开始）<br>
执行2:<strong>由于4&gt;key，我们让A[j+1] = A[j]，即A[2] = A[1]</strong><br><br>
那么，此时A[j]已经复制到了A[j+1]，我们无论怎么操作都不会丢失A[j]的数据，相当于腾出来了一个空位<br></p>
<p>继续执行2:  此时的j = 0，A[j] = A[0] = 2&lt;key，执行3<br><br>
执行3:  此时，A[j+1]就是key在左手的正确位置，所以令A[j+1]=key，而此时的A[j+1]就是上一轮的A[j]（因为每次j都会-1）<br><br>
而上一轮的A[j]已复制到上一轮的A[j+1]也就是当前的A[j+2]<br><br>
所以<strong>我们可以直接令A[j+1]=key，不会丢失任何数据</strong></p>
<p><strong>只要我们持续这个操作，右手的所有牌最终都会正确地到达左手的正确位置</strong></p>
<h3 id="如何形式化的验证算法正确性">如何形式化的验证算法正确性：</h3>
<p>算法导论给我们提供了一个方法，类似数学归纳法--<strong>“循环不变式”</strong></p>
<blockquote>
<p>关于循环不变式的详解：参考docs/循环不变式.md</p>
</blockquote>
<p>我们来证明插入排序的循环不变式</p>
<h4 id="如何找循环不变式-1">如何找循环不变式？</h4>
<p>由于算法是一步步执行的，那么如果每一步（包括初始和结束）都满足一个共同的条件，那么这个条件就是要找的循环不变式（loop invariant）</p>
<p>显然的，我们一直在试图维护左手牌堆是有序的这个性质<br>
那么，插入排序的循环不变式就是：循环中，A[0…j-1]是有序的</p>
<p>接下来，我们证明循环不变式的三条性质：<br><br>
1.初始化：显然，j = 1时，A[0…j-1]就是A[0]，只有一个数字（这里我们提前将一张右手牌放入左手，并不影响结果），当然是符合循环不变式的<br>
2.保持：若 A[0..j-1] 有序，将 A[j] 插入后，A[0..j] 仍有序<br>
3.终止：终止时，当 j = n 时，A[0..n] 整体有序，排序完成</p>
<p><strong>因此，插入排序最终被证明为正确的</strong></p>
<blockquote>
<p>关于代码实现，参考GitHub:<a href="https://github.com/Ghost-Silver/algorithm" target="_blank" rel="noopener nofollow">《算法导论》笔记</a>src/insertion_sort(插入排序).h</p>
</blockquote>
<p><strong>P.S.在之后的算法设计文档中，我们都使用循环不变式来设计和证明算法</strong><br>
文章及代码已同步到GitHub：<a href="https://github.com/Ghost-Silver/algorithm" target="_blank" rel="noopener nofollow">《算法导论》笔记</a>，欢迎参考<br>
如有错误，请不吝赐教</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-05 14:20">2025-08-05 14:20</span>&nbsp;
<a href="https://www.cnblogs.com/SilverGo">Ghost-Face</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19023190);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19023190', targetLink: 'https://www.cnblogs.com/SilverGo/p/19023190', title: '《算法导论》笔记——循环不变式及插入排序证明' })">举报</a>
</div>
        