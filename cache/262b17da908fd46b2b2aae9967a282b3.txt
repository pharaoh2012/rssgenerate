
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sdcb/p/19019424/csharp-circular-buffer" title="发布于 2025-08-04 08:45">
    <span role="heading" aria-level="2">一个被BCL遗忘的高性能集合：C# CircularBuffer&lt;T&gt;深度解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，在最近的一个业余项目——<a href="https://github.com/sdcb/n-body" target="_blank" rel="noopener nofollow">天体运行模拟器</a>中，我遇到了一个有趣的需求：我需要记录每个天体最近一段时间的历史位置，从而在屏幕上为它们画出一条长长而漂亮的轨迹线。</p>
<p>你可能会说，用一个 <code>List&lt;T&gt;</code> 不就行了？但问题在于，如果模拟持续运行，这个 <code>List&lt;T&gt;</code> 会无限增长，最终会消耗大量内存，甚至可能导致程序崩溃。我真正需要的是一个“固定大小”的集合，当新数据加进来时，最老的数据能被自动丢弃。这正是“循环缓冲区”（Circular Buffer）大显身手的场景。<code>CircularBuffer&lt;T&gt;</code> 完美地满足了我的需求。</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202508/233608-20250802225908093-901210324.png" alt="image" loading="lazy"></p>
<h2 id="circularbuffert-的实现"><code>CircularBuffer&lt;T&gt;</code> 的实现</h2>
<p>C# 的基础类库（BCL）中并没有内置 <code>CircularBuffer&lt;T&gt;</code> 这个类型，但这完全不妨碍我们自己动手，丰衣足食。下面就是我所使用的 <code>CircularBuffer&lt;T&gt;</code> 的完整实现，它支持泛型，并且实现了 <code>IEnumerable&lt;T&gt;</code> 接口，可以方便地进行遍历。</p>
<pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using System;

namespace Sdcb.NBody.Common;

/// &lt;summary&gt;
/// 表示一个固定容量的循环缓冲区（或环形列表）。
/// 当缓冲区满时，添加新元素会覆盖最早的元素。
/// &lt;/summary&gt;
/// &lt;typeparam name="T"&gt;缓冲区中元素的类型。&lt;/typeparam&gt;
public class CircularBuffer&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private readonly T[] _data;
    private int _end; // 指向下一个要写入元素的位置（尾部）

    /// &lt;summary&gt;
    /// 获取缓冲区中实际存储的元素数量。
    /// &lt;/summary&gt;
    public int Count { get; private set; }

    /// &lt;summary&gt;
    /// 获取缓冲区的总容量。
    /// &lt;/summary&gt;
    public int Capacity =&gt; _data.Length;

    /// &lt;summary&gt;
    /// 获取一个值，该值指示缓冲区是否已满。
    /// &lt;/summary&gt;
    public bool IsFull =&gt; Count == Capacity;

    /// &lt;summary&gt;
    /// 计算并获取第一个元素（头部）在内部数组中的索引。
    /// &lt;/summary&gt;
    private int HeadIndex
    {
        get
        {
            if (Count == 0) return 0;
            // 当 Count &lt; Capacity 时，_end 就是 Count，结果为 0。
            // 当缓冲区满时 (Count == Capacity)，_end 会循环，这个公式能正确计算出头部的索引。
            return (_end - Count + Capacity) % Capacity;
        }
    }

    /// &lt;summary&gt;
    /// 初始化 &lt;see cref="CircularBuffer{T}"/&gt; 类的新实例。
    /// &lt;/summary&gt;
    /// &lt;param name="capacity"&gt;缓冲区的容量。必须为正数。&lt;/param&gt;
    /// &lt;exception cref="ArgumentException"&gt;当容量小于等于 0 时抛出。&lt;/exception&gt;
    public CircularBuffer(int capacity)
    {
        if (capacity &lt;= 0)
        {
            throw new ArgumentException("Capacity must be a positive number.", nameof(capacity));
        }
        _data = new T[capacity];
        _end = 0;
        Count = 0;
    }

    /// &lt;summary&gt;
    /// 将一个新元素添加到缓冲区的尾部。
    /// 如果缓冲区已满，此操作会覆盖最早的元素。
    /// &lt;/summary&gt;
    /// &lt;param name="item"&gt;要添加的元素。&lt;/param&gt;
    public void Add(T item)
    {
        _data[_end] = item;
        _end = (_end + 1) % Capacity;

        if (Count &lt; Capacity)
        {
            Count++;
        }
    }

    /// &lt;summary&gt;
    /// 清空缓冲区中的所有元素。
    /// &lt;/summary&gt;
    public void Clear()
    {
        // 只需重置计数器和指针即可，无需清除数组数据
        Count = 0;
        _end = 0;
    }

    /// &lt;summary&gt;
    /// 获取或设置指定逻辑索引处的元素。
    /// 索引 0 是最早的元素，索引 Count-1 是最新的元素。
    /// &lt;/summary&gt;
    /// &lt;param name="index"&gt;元素的逻辑索引。&lt;/param&gt;
    /// &lt;exception cref="IndexOutOfRangeException"&gt;当索引超出范围时抛出。&lt;/exception&gt;
    public T this[int index]
    {
        get
        {
            if (index &lt; 0 || index &gt;= Count)
            {
                throw new IndexOutOfRangeException("Index is out of the valid range of the buffer.");
            }
            int actualIndex = (HeadIndex + index) % Capacity;
            return _data[actualIndex];
        }
        set
        {
            if (index &lt; 0 || index &gt;= Count)
            {
                throw new IndexOutOfRangeException("Index is out of the valid range of the buffer.");
            }
            int actualIndex = (HeadIndex + index) % Capacity;
            _data[actualIndex] = value;
        }
    }

    /// &lt;summary&gt;
    /// 获取缓冲区中的第一个（最早的）元素。
    /// &lt;/summary&gt;
    /// &lt;exception cref="InvalidOperationException"&gt;当缓冲区为空时抛出。&lt;/exception&gt;
    public T First
    {
        get
        {
            if (Count == 0) throw new InvalidOperationException("Buffer is empty.");
            return _data[HeadIndex];
        }
    }

    /// &lt;summary&gt;
    /// 获取缓冲区中的最后一个（最新的）元素。
    /// &lt;/summary&gt;
    /// &lt;exception cref="InvalidOperationException"&gt;当缓冲区为空时抛出。&lt;/exception&gt;
    public T Last
    {
        get
        {
            if (Count == 0) throw new InvalidOperationException("Buffer is empty.");
            // _end 指向下一个要写入的位置，所以上一个写入的位置是 (_end - 1)
            int lastIndex = (_end - 1 + Capacity) % Capacity;
            return _data[lastIndex];
        }
    }

    /// &lt;summary&gt;
    /// 返回一个循环访问集合的枚举器。
    /// &lt;/summary&gt;
    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        int head = HeadIndex;
        for (int i = 0; i &lt; Count; i++)
        {
            yield return _data[(head + i) % Capacity];
        }
    }

    /// &lt;summary&gt;
    /// 返回一个循环访问集合的枚举器。
    /// &lt;/summary&gt;
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
</code></pre>
<h2 id="原理浅析">原理浅析</h2>
<p>这个类的核心思想非常巧妙：</p>
<ol>
<li><strong>内部存储</strong>：它内部使用一个固定长度的数组 <code>_data</code> 作为元素的物理存储空间。</li>
<li><strong>指针管理</strong>：它使用一个 <code>_end</code> 指针来标记下一个新元素应该插入的位置（尾部），以及一个 <code>Count</code> 属性来记录当前存储的元素数量。</li>
<li><strong>循环的奥秘</strong>：<code>HeadIndex</code> 这个计算属性是关键，它通过 <code>_end</code> 和 <code>Count</code> 的位置动态计算出“逻辑上”第一个元素（头部）在物理数组中的实际索引。取模运算 <code>% Capacity</code> 保证了无论是 <code>_end</code> 指针的移动还是 <code>HeadIndex</code> 的计算，都能在数组的边界内“循环”。</li>
<li><strong>添加与覆盖</strong>：当你调用 <code>Add</code> 方法时，新元素会被放到 <code>_end</code> 指向的位置。如果缓冲区还没满 (<code>Count &lt; Capacity</code>)，<code>Count</code> 会加一。如果已经满了，<code>Count</code> 不再变化，而旧的头部元素就会被自然而然地覆盖掉。整个过程对于调用者来说是无感的。</li>
</ol>
<h2 id="骚操作之在天体模拟中使用">骚操作之：在天体模拟中使用</h2>
<p>得益于 <code>CircularBuffer&lt;T&gt;</code> 的优雅设计，在我的天体模拟器中使用它变得异常简单。我只需要关心一件事：把新的位置点加进去。</p>
<p>这就是它在我的模拟循环中的样子：每当一个天体的位置变化超过了2个像素（为了避免轨迹点过于密集），我就把它新的坐标 <code>Add</code> 到它的轨迹历史记录 <code>TrackingHistory</code> 中。</p>
<pre><code class="language-csharp">// _system.MoveNext();
// _acc += _system.Current.Timestamp - _lastSnapshot.Timestamp;

for (int i = 0; i &lt; _system.Current.Bodies.Length; ++i)
{
    BodySnapshot star = _system.Current.Bodies[i];
    BodyUIProps props = _uiProps[i];

    Vector2 now = new(star.Px, star.Py);
    // 如果历史轨迹中有数据，则判断距离
    if (props.TrackingHistory.Count &gt; 0)
    {
        Vector2 old = props.TrackingHistory.Last;
        float dist = Vector2.Distance(old, now);
        // 只有当移动距离超过阈值时才添加新点
        if (dist &gt; 2 / _scale.Value)
        {
            props.TrackingHistory.Add(now);
        }
    }
    else
    {
        // 如果是第一个点，直接添加
        props.TrackingHistory.Add(now);
    }
}
</code></pre>
<p>我完全不需要写 <code>if (list.Count &gt; MAX_COUNT) { list.RemoveAt(0); }</code> 这样的代码。<code>CircularBuffer&lt;T&gt;</code> 自动为我处理了覆盖最早元素逻辑，代码因此变得更加简洁和高效。</p>
<h2 id="骚操作之遍历与渲染">骚操作之：遍历与渲染</h2>
<p>当需要绘制轨迹线时，由于 <code>CircularBuffer&lt;T&gt;</code> 实现了 <code>IEnumerable&lt;T&gt;</code> 接口，我可以直接使用 <code>foreach</code> 循环来遍历其中的所有点，并将它们连接成线。下面的代码片段使用 <code>Direct2D</code> 来绘制几何路径：</p>
<pre><code class="language-csharp">if (prop.TrackingHistory.Count &lt; 2) continue;

using ID2D1PathGeometry1 path = XResource.Direct2DFactory.CreatePathGeometry();
using ID2D1GeometrySink sink = path.Open();

// 将画笔移动到轨迹的第一个点
sink.BeginFigure(prop.TrackingHistory.First, FigureBegin.Hollow);

// 遍历并连接后续的点
foreach (Vector2 pt in prop.TrackingHistory.Skip(1))
{
    sink.AddLine(pt);
}

sink.EndFigure(FigureEnd.Open);
sink.Close();

// 绘制几何路径
ctx.DrawGeometry(path, XResource.GetColor(prop.Color), 0.02f);
</code></pre>
<p>这里的 <code>foreach</code> 会按照元素添加的先后顺序，从最早的（头部）到最新的（尾部）依次返回，完美符合我绘制轨迹的需求。</p>
<h2 id="性能分析为什么它如此高效">性能分析：为什么它如此高效？</h2>
<p>我们实现的这个 <code>CircularBuffer&lt;T&gt;</code> 不仅用起来方便，其性能也相当出色。让我们来分析一下它主要操作的时间复杂度：</p>
<ul>
<li><strong>插入 (<code>Add</code>)</strong>: <strong>O(1)</strong>。添加一个新元素仅涉及一次数组写入和一次指针（<code>_end</code>）的算术运算，无论缓冲区有多大，耗时都是固定的。</li>
<li><strong>获取元素数量 (<code>Count</code>)</strong>: <strong>O(1)</strong>。这只是返回一个字段的值，是瞬时操作。</li>
<li><strong>索引访问 (<code>this[index]</code>)</strong>: <strong>O(1)</strong>。通过索引获取元素，需要经过 <code>HeadIndex</code> 的 O(1) 计算来定位实际的数组下标，然后进行一次数组访问，总体仍然是 O(1)。</li>
<li><strong>获取头/尾元素 (<code>First</code>/<code>Last</code>)</strong>: <strong>O(1)</strong>。与索引访问类似，都是通过计算直接定位，无需遍历。</li>
<li><strong>查找/遍历 (<code>foreach</code>)</strong>: <strong>O(n)</strong>。和大多数集合一样，如果要查找一个不确定位置的元素或完整遍历，需要访问所有 <code>n</code> 个元素。</li>
</ul>
<p>现在，让我们来对比一下，如果使用 <code>List&lt;T&gt;</code> 并手动在列表满时执行 <code>list.RemoveAt(0)</code> 来模拟这个行为，会发生什么。</p>
<p><code>List&lt;T&gt;.RemoveAt(0)</code> 是一个非常昂贵的操作，其时间复杂度为 <strong>O(n)</strong>。这是因为它需要将索引 <code>0</code> 之后的所有元素在内存中向前移动一位来填补空缺。如果你的缓冲区很大（比如存储几千个历史点），每次添加新元素都可能触发一次大规模的内存复制，这会带来巨大的性能开销。</p>
<p>相比之下，我们的 <code>CircularBuffer&lt;T&gt;</code> 仅仅通过移动一个整数指针就巧妙地“移除”了最旧的元素，整个 <code>Add</code> 操作的复杂度始终是 <strong>O(1)</strong>。在这种需要固定大小并频繁读写的场景下，其效率比 <code>List&lt;T&gt;</code> 的模拟方案好得不知道哪里去了，性能简直是天壤之别。</p>
<h2 id="总结">总结</h2>
<p>虽然 C# 基础类库里没有提供 <code>CircularBuffer&lt;T&gt;</code>，但它无疑是一个非常实用的数据结构。它在需要固定容量、自动淘汰旧数据的场景下表现出色。</p>
<p>除了今天演示的天体运行轨迹记录，它还可以广泛应用于：</p>
<ul>
<li><strong>日志记录</strong>：只保留最近的 N 条日志。</li>
<li><strong>性能监控</strong>：记录最近一段时间的 CPU 或内存使用率。</li>
<li><strong>实时数据流处理</strong>：缓存最新的数据点用于分析。</li>
<li><strong>轮询调度（Round-Robin）</strong>：在多个任务或资源间循环切换。</li>
</ul>
<p>希望这个 <code>CircularBuffer&lt;T&gt;</code> 的实现能对你有所启发。</p>
<p>感谢阅读到这里，如果感觉本文对您有帮助，请不吝<strong>评论</strong>和<strong>点赞</strong>，这也是我持续创作的动力！<br>
也欢迎加入我的 <strong>.NET骚操作 QQ群：495782587</strong>，一起交流.NET 和 AI 的各种有趣玩法！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-04 08:45">2025-08-04 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/sdcb">.NET骚操作</a>&nbsp;
阅读(<span id="post_view_count">592</span>)&nbsp;
评论(<span id="post_comment_count">9</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19019424);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19019424', targetLink: 'https://www.cnblogs.com/sdcb/p/19019424/csharp-circular-buffer', title: '一个被BCL遗忘的高性能集合：C# CircularBuffer&amp;lt;T&amp;gt;深度解析' })">举报</a>
</div>
        