
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/5ran2yl/p/18768324" title="发布于 2025-03-12 19:25">
    <span role="heading" aria-level="2">SpringBoot集成WebServlet出现自定义单servlet请求失败的问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>一.导言</h1>
<p>&nbsp;SpringBoot的真正核心是快速整合以及自动装配，所以在spring家族中springBoot不仅整合了Spring的IOC容器还兼容了WebServlet容器；这使得springBoot项目不仅支持快速开发微服务，同时具备开发MVC模式下的项目。</p>
<p>其中MVC模式的实现者之一就是WebServlet；由于springBoot的整合，在其项目中开发WebServlet也是可行方案之一。但是在使用servlet技术时我们遇到了一个问题：即在SpringBoot中，以Bean的方式注册servlet需要自定义两个及以上的servlet。</p>
<p>这是为什么呢？</p>
<h1>二.测试验证问题</h1>
<h3>&nbsp;首先验证一个servlet的情况</h3>
<p>先配置servlet实现类：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> OneServlet <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> HttpServlet {
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> doGet(HttpServletRequest req, HttpServletResponse resp) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> ServletException, IOException {
        System.out.println(</span>"servlet 1 的实现类"<span style="color: rgba(0, 0, 0, 1)">);
        resp.getWriter().print(</span>"this is servlet 1"<span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>在config配置类中注册这个servletBean：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Configuration
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RegisterBean {
    @Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet createOneServlet(){
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">注册servlet 1</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet();
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>直接启动springBoot启动器查看是否可以完成一次servlet的请求</p>
<p>地址栏输入：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createOneServlet/</span></pre>
</div>
<p>&nbsp;</p>
<p>或者：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/OneServlet/</span></pre>
</div>
<p>&nbsp;</p>
<p>显示都是错误页面：</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312180407644-325088929.png" alt="" width="602" height="152" loading="lazy"></p>
<h3>&nbsp;验证两个servlet的情况</h3>
<p>拓展一个servlet实现类：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> TwoServlet <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> HttpServlet {
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> doGet(HttpServletRequest req, HttpServletResponse resp) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> ServletException, IOException {
        System.out.println(</span>"servlet 2 的实现类"<span style="color: rgba(0, 0, 0, 1)">);
        resp.getWriter().print(</span>"this is servlet 2"<span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>以及使用Bean的方式完成注入：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Configuration
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RegisterBean {
    @Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet createOneServlet(){
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">注册servlet 1</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet();
    }
        @Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> TwoServlet createTwoServlet(){
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">注册servlet 2</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TwoServlet();
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>再次启动springBoot启动器：</p>
<p>运行：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createOneServlet/</span></pre>
</div>
<p>结果可以拿到请求，正常处理</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312180700673-586772247.png" alt="" loading="lazy"></p>
<p>&nbsp;运行：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createTwoServlet/</span></pre>
</div>
<p>结果依旧可以拿到，正常处理请求：</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312180821968-1086709351.png" alt="" loading="lazy"></p>
<p>&nbsp;这就出现了刚开始提到的那个问题：springBoot项目运行时，一个servlet无法进行请求，当有两个时却可以进行请求</p>
<p>&nbsp;解决这问题之前，我们需要一点前言知识，那就是需要先了解SpringMVC中的DispatcherServlet</p>
<h1>三.解决单servlet无法正常请求的问题</h1>
&nbsp;<code>DispatcherServlet</code> 是 Spring MVC 框架的核心组件，它充当前端控制器（Front Controller）的角色，负责接收所有的 HTTP 请求并将其分发到相应的处理器（Handler）。通过这种方式，<code>DispatcherServlet</code> 实现了请求的集中管理和分发。请求分发：接收所有进入的应用程序的HTTP请求，并根据配置将它们分发给合适的处理器（Controller）。
<p>&nbsp;当然DispatcherServlet的功能还有很多，我们只把关系到问题的部分单独拿出来。我们知道SpringMVC在JavaWeb的基础之上，演化了DispatcherServlet，它的本质依旧是一个servlet，在SpringMVC中将其单独拿出来作为前后端连接的大脑，通常它会将前端所有的请求都拦截下来，然后经过一系列验证之后移交给controller处理，处理完成之后又返回给它，返回给视图层。</p>
<p>由于springBoot中整合了SpringMVC，故而DispatcherServlet存在于spring容器中的。</p>
<p>&nbsp;回到刚刚的问题，一个servlet为什么执行不起来，这还得分析我们注入servlet的方式</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Bean
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet createOneServlet(){
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">注册servlet 1</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OneServlet();
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;由于我们注入使用的是最简单的注入方式，并没有配置这个servlet的请求路径；</p>
<p>DeepSeek：如果没有显式配置路径映射，Spring Boot 会尝试为 Servlet 分配默认路径，通常是 Servlet 的名称或类名的小写形式。如果默认路径与其他映射冲突，或 Servlet 未正确注册，可能导致无法访问。</p>
<p>在第一种情况下，springBoot是在尝试进行为servlet命名的，只是为其命名的映射路径刚好和DispatcherServlet的拦截请求冲突了，故而失败了</p>
<p>我们在失败的情况下编写一个controller，看相同的请求是不是交给DispatcherServlet处理了</p>
<p>controller：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@RestController
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ServletTest {
    @GetMapping(</span>"/createOneServlet/"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> String test(){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> "return from Spring MVC"<span style="color: rgba(0, 0, 0, 1)">;
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>和第一次失败测试一样的请求：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createOneServlet/</span></pre>
</div>
<p>结果</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312185321283-476013765.png" alt="" loading="lazy"></p>
<p>&nbsp;可以发现，配置一个controller之后确实请求被DispatcherServlet接管了，故而有springMVC框架进行返回</p>
<p>知道了问题所在就可以进行修改了，推荐两种解决方案</p>
<h3>1.更改DispatcherServlet的默认拦截路径</h3>
<p>在SpringBoot中DispatcherServlet的默认拦截路径是&nbsp; "/*" ;故而将其改到其它位置后，他就不会影响SpringBoot为没有配置映射路径的servlet命名了</p>
<p>更改application.properties文件：</p>
<div class="cnblogs_code">
<pre>spring.mvc.servlet.path= /test/</pre>
</div>
<p>&nbsp;</p>
<p>将DispatcherServlet的默认匹配路径更改到&nbsp; &nbsp;“ /test/* ”&nbsp; 下</p>
<p>注销controller类的实现：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">    @GetMapping("/createOneServlet/")
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">    public String test(){
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">        return "return from Spring MVC";
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">    }</span></pre>
</div>
<p>&nbsp;</p>
<p>再次启动，测试单servlet未配置路径是否有问题：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createOneServlet/</span></pre>
</div>
<p>&nbsp;</p>
<p>结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312190347500-1646380736.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>可以看到，servlet成功将其请求处理了</p>
<h3>2.配置单个servlet的请求路径</h3>
<p>配置servlet实现类使用@WebServlet注解：</p>
<div class="cnblogs_code">
<pre>@WebServlet(urlPatterns = "/createOneServlet"<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> OneServlet <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> HttpServlet {
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> doGet(HttpServletRequest req, HttpServletResponse resp) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> ServletException, IOException {
        System.out.println(</span>"servlet 1 的实现类"<span style="color: rgba(0, 0, 0, 1)">);
        resp.getWriter().print(</span>"this is servlet 1"<span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>在springBoot启动器上配置自动扫描servlet的注解@ServletComponentScan：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@SpringBootApplication
@ServletComponentScan
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ServletTestApplication {

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main(String[] args) {
        SpringApplication.run(ServletTestApplication.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">, args);
    }

}</span></pre>
</div>
<p>&nbsp;</p>
<p>启动测试：</p>
<div class="cnblogs_code">
<pre>http:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">localhost:9000/createOneServlet/</span></pre>
</div>
<p>&nbsp;</p>
<p>结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2846424/202503/2846424-20250312191122630-1651908180.png" alt="" loading="lazy"></p>
<p>&nbsp;可以发现依旧运行出来了结果</p>
<p>如上就是推荐在SpringBoot中注册servlet的两种方式</p>
<h3>为什么两个自定义servlet不写映射却可以呢？</h3>
<p>DeepSeek：两个自定义 Servlet 可以访问的原因</p>
<p>自动注册：当有多个 Servlet 时，Spring Boot 会为每个 Servlet 生成默认路径，通常基于类名或者Bean。<br>路径唯一性：多个 Servlet 的默认路径通常不会冲突，因此可以正常访问。</p>
<p>也就是基于这样的原因，DispatcherServlet没有产生拦截，因为这两个自定义servlet已经在Servlet容器中完成注册，根据Java servlet的匹配规范，即最长匹配原则，/(类名|Bean)的匹配长度比DispatcherServlet /* 精度更高，故而两个servlet的情况下，即使不修改SpringMVC的配置依旧可以正常访问。</p>
<p>&nbsp;</p>
<p>------END------</p>
<p>本文虽经反复斟酌，但仍可能存在疏漏或不当之处，衷心希望得到各位同行的批评指正，以期进一步完善。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.36719089941666666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-12 19:27">2025-03-12 19:25</span>&nbsp;
<a href="https://www.cnblogs.com/5ran2yl">回忆也交给时间</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18768324" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18768324);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18768324', targetLink: 'https://www.cnblogs.com/5ran2yl/p/18768324', title: 'SpringBoot集成WebServlet出现自定义单servlet请求失败的问题' })">举报</a>
</div>
        