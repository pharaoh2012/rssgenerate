
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dingxingxing/p/18827417" title="发布于 2025-04-15 20:12">
    <span role="heading" aria-level="2">函数组件的声明方式及差异+React.memo和userCallback区别</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="1函数组件的声明方式及差异">1、函数组件的声明方式及差异</h3>
<ul>
<li>
<p>普通函数声明</p>
</li>
<li>
<p>箭头函数声明</p>
</li>
<li>
<p>使用React.FC类型（TypeScript专用）</p>
<pre><code class="language-react">interface Props {
  content: string
}

// 写法一
const MyComponent: React.FC&lt;Props&gt; = (props) =&gt; {
  return &lt;div&gt;{props.content}&lt;/div&gt;
}

// 写法二， FC 是 React.FC 的简写别名，二者完全等价。
import { FC } from 'react'
const MyComponent: FC&lt;Props&gt; = (props) =&gt; {
  return &lt;div&gt;{props.content}&lt;/div&gt;
}
</code></pre>
</li>
<li>
<p>使用React.memo优化</p>
<pre><code class="language-react">const MemoizedComponent = React.memo(function MyComponent(props) {
  return &lt;div&gt;{props.content}&lt;/div&gt;;
});
</code></pre>
</li>
</ul>
<h3 id="2reactmemo和usercallback">2、React.memo和userCallback</h3>
<h4 id="reactmemo">React.memo</h4>
<ol>
<li>
<p><strong>介绍及使用时机</strong></p>
<blockquote>
<p><strong><code>React.memo</code> 是什么</strong>：一个用于函数组件的性能优化工具，通过浅比较 props 避免无效渲染。</p>
<p><strong>何时使用</strong>：</p>
<ul>
<li>组件渲染成本高</li>
<li>父组件频繁更新但子组件 props 不变</li>
<li>需要精细化控制渲染逻辑</li>
</ul>
<p><strong>如何正确使用</strong>：</p>
<ul>
<li>对简单 props 使用默认浅比较</li>
<li>对复杂 props 结合 <code>useMemo</code>/<code>useCallback</code></li>
<li>必要时自定义比较函数</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>基本用法</strong></p>
<pre><code class="language-react">import React from 'react';

const MyComponent = (props) =&gt; {
  return &lt;div&gt;{props.content}&lt;/div&gt;;
};

// 用 React.memo 包裹组件
export default React.memo(MyComponent);
</code></pre>
</li>
<li>
<p><strong>自定义比较逻辑（高级用法）</strong></p>
<p>如果默认的浅比较不满足需求，可以手动控制比较逻辑：</p>
<pre><code class="language-react">// 第二个参数是自定义比较函数
export default React.memo(MyComponent, (prevProps, nextProps) =&gt; {
  // 返回 true 表示 props "相同"，阻止渲染
  // 返回 false 表示 props "不同"，允许渲染
  return prevProps.id === nextProps.id;
});
</code></pre>
</li>
<li>
<p><strong>使用场景案例</strong></p>
<pre><code class="language-react">场景 1：父组件频繁更新，但子组件不需要

// 父组件
const Parent = () =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;点击 {count}&lt;/button&gt;
      {/* 即使 count 变化，Child 的 props 未变化 */}
      &lt;Child title="静态内容" /&gt;
    &lt;/div&gt;
  );
};

// 子组件用 React.memo 包裹
const Child = React.memo(({ title }) =&gt; {
  console.log('子组件渲染'); // 只有 title 变化时才会打印
  return &lt;div&gt;{title}&lt;/div&gt;;
});

场景 2：复杂数据渲染
// 大数据表格组件
const DataTable = React.memo(({ data }) =&gt; {
  // 假设 data 有 10,000 行数据
  return (
    &lt;table&gt;
      {data.map(row =&gt; (
        &lt;tr key={row.id}&gt;&lt;td&gt;{row.value}&lt;/td&gt;&lt;/tr&gt;
      ))}
    &lt;/table&gt;
  );
});
</code></pre>
</li>
</ol>
<h4 id="usecallback">useCallback</h4>
<ol>
<li>
<p><strong>核心作用</strong></p>
<blockquote>
<p><code>useCallback</code> 是 React 的一个性能优化 Hook，用于 <strong>缓存函数引用</strong>。<br>
它的核心价值是 <strong>避免父组件重新渲染时，因函数引用变化导致子组件无效渲染</strong>。</p>
</blockquote>
</li>
<li>
<h4 id="解决什么问题"><strong>解决什么问题？</strong></h4>
<ul>
<li><strong>问题场景</strong>：<br>
当父组件传递一个函数给子组件时，若父组件更新，每次会重新创建该函数。即使子组件用 <code>React.memo</code> 包裹，也会因函数引用不同而触发重新渲染。</li>
<li><strong>优化目标</strong>：<br>
保持函数引用不变，除非依赖项变化，从而减少子组件无效渲染。</li>
</ul>
<p>问题场景：</p>
<pre><code class="language-react">// 父组件
const Parent = () =&gt; {
  const [count, setCount] = useState(0);

  // 每次 Parent 渲染都会创建新的 handleClick 函数
  const handleClick = () =&gt; {
    console.log('点击事件');
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;触发渲染（当前：{count}）&lt;/button&gt;
      {/* 即使 Child 用 React.memo 包裹，仍会重新渲染 */}
      &lt;Child onClick={handleClick} /&gt;
    &lt;/div&gt;
  );
};

// 子组件（用 React.memo 优化）
const Child = React.memo(({ onClick }) =&gt; {
  console.log('子组件渲染'); // 父组件每次更新都会触发此日志
  return &lt;button onClick={onClick}&gt;子组件按钮&lt;/button&gt;;
});

// 问题：父组件每次更新（如 count 变化）时，handleClick 会被重新创建，导致传递给子组件的 onClick 引用不同。
// 结果：即使子组件用 React.memo 包裹，也会因 props 中函数的引用变化而重新渲染。
</code></pre>
</li>
<li>
<h4 id="语法与参数"><strong>语法与参数</strong></h4>
<pre><code class="language-react">const memoizedFn = useCallback(
  () =&gt; { /* 函数逻辑 */ }, 
  [dep1, dep2] // 依赖项数组
);
// 参数 1：需要缓存的函数。
// 参数 2：依赖项数组（类似 useEffect 的依赖）。
// 返回值：一个记忆化的函数引用（依赖不变时引用不变）。

// ✅ 正确：依赖项包含 count，避免形成闭包并解决
const handleClick = useCallback(() =&gt; {
  console.log(count);
}, [count]);
</code></pre>
</li>
</ol>
<h4 id="区别">区别</h4>
<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left"><code>useCallback</code></th>
<th style="text-align: left"><code>useMemo</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>缓存目标</strong></td>
<td style="text-align: left">缓存函数本身</td>
<td style="text-align: left">缓存函数的计算结果（值/对象）</td>
</tr>
<tr>
<td style="text-align: left"><strong>返回值</strong></td>
<td style="text-align: left">函数引用</td>
<td style="text-align: left">计算结果</td>
</tr>
<tr>
<td style="text-align: left"><strong>等效写法</strong></td>
<td style="text-align: left"><code>useMemo(() =&gt; fn, deps)</code></td>
<td style="text-align: left"><code>useMemo(() =&gt; value, deps)</code></td>
</tr>
</tbody>
</table>
<p>2025/04/15</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.01203360354513889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-15 20:13">2025-04-15 20:12</span>&nbsp;
<a href="https://www.cnblogs.com/dingxingxing">前端羽哥</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18827417);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18827417', targetLink: 'https://www.cnblogs.com/dingxingxing/p/18827417', title: '函数组件的声明方式及差异+React.memo和userCallback区别' })">举报</a>
</div>
        