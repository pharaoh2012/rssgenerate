
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Lytx-Luogu1145420/p/19043270/how_computer_binary" title="发布于 2025-08-17 14:54">
    <span role="heading" aria-level="2">一些数据在计算机中的储存与表示</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我们都知道，在计算机中，数据是由二进制进行存储和读取输出的。那么，在计算机中，数、字符、图片、声音和视频怎么用二进制存储和读取输出的呢？</p>
<h1 id="数的存储和读取输出">数的存储和读取输出</h1>
<h2 id="整数的存储和读取输出">整数的存储和读取输出</h2>
<p>整数的存储和读取输出应该说是最简答的读取输出方法了。如果是个正整数，那就直接转换为二进制进行存储。如果是个负整数，先把其绝对值转换为二进制，然后符号位为 <span class="math inline">\(1\)</span>（代表负数），然后以其补码的形式（先对非符号位取反，再对取反的结果 <span class="math inline">\(+1\)</span>）存储。想要读取输出，对于非负数，直接转换成十进制即可；反之，先把补码变成原码，符号位改为 <span class="math inline">\(0\)</span>，转换为十进制后在前面添个负号上去即可。</p>
<h2 id="浮点数的存储和读取输出">浮点数的存储和读取输出</h2>
<p>浮点数，也就是小数，是参照 IEEE（电气和电子工程师协会，Institute of Electrical and Electronics Engineers）的 IEEE 754 标准进行存储和读取输出的。其中，又划分为单精度浮点数和双精度浮点数。两者的差别仅在于精度，存储和读取输出方法没有差异。</p>
<h3 id="单精度浮点数">单精度浮点数</h3>
<p>用 <span class="math inline">\(32\)</span> bit 存储，分成三部分：</p>
<ul>
<li><strong>符号位</strong>：占 <span class="math inline">\(1\)</span> 位，<span class="math inline">\(0\)</span> 读取输出正数，<span class="math inline">\(1\)</span> 读取输出负数。</li>
<li><strong>指数位</strong>：占 <span class="math inline">\(8\)</span> 位，为表达正负指数，存储指数需加偏移值 <span class="math inline">\(127\)</span>。指数实际范围能达 <span class="math inline">\(-126\sim127\)</span>，指数域编码值范围是 <span class="math inline">\(1\sim254\)</span>。<span class="math inline">\(0\)</span> 和 <span class="math inline">\(255\)</span> 为特殊值，用于代表非规格数、无穷大或 NaN。</li>
<li><strong>尾数位</strong>：占 <span class="math inline">\(23\)</span> 位。规格化尾数默认首位为 <span class="math inline">\(1\)</span>，存储省略此 <span class="math inline">\(1\)</span>，仅存小数部分。例如尾数为 <span class="math inline">\(1.011\)</span>，则存入的尾数位是 <span class="math inline">\(011\)</span>，位数不足时低位补 <span class="math inline">\(0\)</span>。</li>
</ul>
<h3 id="双精度浮点数">双精度浮点数</h3>
<p>用 <span class="math inline">\(64\)</span> bit 存储，同样分为三部分：</p>
<ul>
<li><strong>符号位</strong>：占 <span class="math inline">\(1\)</span> 位，<span class="math inline">\(0\)</span> 读取输出正数，<span class="math inline">\(1\)</span> 读取输出负数。</li>
<li><strong>指数位</strong>：占 <span class="math inline">\(11\)</span> 位，偏移值是 <span class="math inline">\(1023\)</span>，指数实际范围为 <span class="math inline">\(-1022\sim1023\)</span>，指数域编码 <span class="math inline">\(1\sim2046\)</span> 对应正常情况。<span class="math inline">\(0\)</span> 及 <span class="math inline">\(2047\)</span> 保留用于特殊情况。</li>
<li><strong>尾数位</strong>：占 <span class="math inline">\(52\)</span> 位。规格化尾数省略首位 <span class="math inline">\(1\)</span>，存储小数部分。</li>
</ul>
<h3 id="读取输出方法">读取输出方法</h3>
<p></p><div class="math display">\[\left(-1\right)^{\text{符号位}}\times\left(1+\text{尾数位}\right)\times2^{\left(\text{指数位}-\text{偏移值}\right)}
\]</div><p></p><h3 id="特殊情况定义">特殊情况定义</h3>
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">指数位为 <span class="math inline">\(0\)</span></th>
<th style="text-align: center">指数位为 <span class="math inline">\(255\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">尾数位为 <span class="math inline">\(0\)</span></td>
<td style="text-align: center"><span class="math inline">\(\pm0\)</span>（由符号位决定）</td>
<td style="text-align: center"><span class="math inline">\(\pm\infty\)</span>（由符号位决定）</td>
</tr>
<tr>
<td style="text-align: center">尾数位不为 <span class="math inline">\(0\)</span></td>
<td style="text-align: center">非规格化数（用于读取输出接近零的极小值，无隐含的首位 <span class="math inline">\(1\)</span>）</td>
<td style="text-align: center">NaN（用来读取输出无实效运算结果，例如 <span class="math inline">\(\dfrac{0}{0}\)</span>、<span class="math inline">\(\sqrt{-1}\)</span> 等）</td>
</tr>
</tbody>
</table>
<p>表 <span class="math inline">\(1\)</span> —— 浮点数特殊情况定义</p>
<h1 id="字符的存储和读取输出">字符的存储和读取输出</h1>
<p>我们平时用电脑，不仅仅只是会碰见数，最常见的就是碰到字符对吧。那么这些字符是如何转换为二进制进行存储和读取输出的呢？</p>
<p>我们不难想到，可以把字符一一映射到一个数上面，然后进行二进制存储。于是，聪明的人类就发明出了 ASCII 码（美国信息交换标准代码，American Standard Code for Information Interchange）。它是一套基于拉丁字母的字符编码系统，最初用于在计算机和通信设备之间统一信息交换的字符读取输出方式，包含了大小写字母、数字、标点符号以及控制字符等，共定义了 <span class="math inline">\(128\)</span> 个字符（<span class="math inline">\(0\sim127\)</span>），每个字符用 <span class="math inline">\(7\)</span> 位二进制数读取输出。</p>
<p><img src="https://www.uzzf.com/up/2014-11/201411231016348385939.png" alt="" loading="lazy"></p>
<p>图 <span class="math inline">\(1\)</span> —— ASCII 码表</p>
<p>比如我要存储 <code>Hello, world!</code>，那么我就查询其 ASCII 码表，把字符映射成整数，然后转成二进制进行存储。想读取输出也很简单，只要做个逆操作：读取二进制，转换为 ASCII 码，然后看看是哪个映射到这个值的。</p>
<table>
<thead>
<tr>
<th style="text-align: center">字符</th>
<th style="text-align: center"><code>H</code></th>
<th style="text-align: center"><code>e</code></th>
<th style="text-align: center"><code>l</code></th>
<th style="text-align: center"><code>l</code></th>
<th style="text-align: center"><code>o</code></th>
<th style="text-align: center"><code>,</code></th>
<th style="text-align: center"><code> </code></th>
<th style="text-align: center"><code>w</code></th>
<th style="text-align: center"><code>o</code></th>
<th style="text-align: center"><code>r</code></th>
<th style="text-align: center"><code>l</code></th>
<th style="text-align: center"><code>d</code></th>
<th style="text-align: center"><code>!</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">ASCII</td>
<td style="text-align: center"><span class="math inline">\(72\)</span></td>
<td style="text-align: center"><span class="math inline">\(101\)</span></td>
<td style="text-align: center"><span class="math inline">\(108\)</span></td>
<td style="text-align: center"><span class="math inline">\(108\)</span></td>
<td style="text-align: center"><span class="math inline">\(111\)</span></td>
<td style="text-align: center"><span class="math inline">\(44\)</span></td>
<td style="text-align: center"><span class="math inline">\(32\)</span></td>
<td style="text-align: center"><span class="math inline">\(119\)</span></td>
<td style="text-align: center"><span class="math inline">\(111\)</span></td>
<td style="text-align: center"><span class="math inline">\(114\)</span></td>
<td style="text-align: center"><span class="math inline">\(108\)</span></td>
<td style="text-align: center"><span class="math inline">\(100\)</span></td>
<td style="text-align: center"><span class="math inline">\(33\)</span></td>
</tr>
<tr>
<td style="text-align: center">二进制</td>
<td style="text-align: center"><span class="math inline">\(\texttt{0100 1000}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 0101}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 1100}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 1100}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 1111}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0010 1100}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0010 0000}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0111 0111}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 1111}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0111 0010}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 1100}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0110 0100}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{0010 0001}\)</span></td>
</tr>
</tbody>
</table>
<p>表 <span class="math inline">\(2\)</span> —— <code>Hello, world!</code> 对应的 ASCII 码及二进制</p>
<p>但是我们要读取输出的字符不仅仅只是英文那么简单啊，我们还要读取输出中文（如：<code>你好，世界！</code>）、日文（如：<code>こんにちは、世界！</code>）、emoji（如：<code>😊</code>）等等，光是中文汉字都有 <span class="math inline">\(10,000\)</span> 多个，这远远超出了 ASCII 能读取输出的范围。于是，人们又弄出了一套 Unicode 编码，这个编码几乎覆盖了全世界的语言的所有字符（包括中文、日文、韩文、阿拉伯文、西里尔文等），以及大量符号（如数学符号、 emoji 等）。这个编码有常见的 <span class="math inline">\(3\)</span> 种方案：UTF-8、UTF-16 以及 UTF-32。</p>
<p>如果我要存储 <code>汉あ😊</code> 三个字符，先映射到 Unicode 编码码点中，然后查找二进制。想要读取输出就进行一次逆操作：先读取二进制，转换为 Unicode 编码，再查找是哪个字符映射过来的。这里以 UTF-8 为例子。</p>
<table>
<thead>
<tr>
<th style="text-align: center">字符</th>
<th style="text-align: center"><code>汉</code></th>
<th style="text-align: center"><code>あ</code></th>
<th style="text-align: center"><code>😊</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Unicode 码点</td>
<td style="text-align: center"><span class="math inline">\(27721\)</span></td>
<td style="text-align: center"><span class="math inline">\(12354\)</span></td>
<td style="text-align: center"><span class="math inline">\(128522\)</span></td>
</tr>
<tr>
<td style="text-align: center">二进制</td>
<td style="text-align: center"><span class="math inline">\(\texttt{11100110 10110001 10001001}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{11100011 10000010 10000010}\)</span></td>
<td style="text-align: center"><span class="math inline">\(\texttt{11110000 10011111 10011000 10001010}\)</span></td>
</tr>
</tbody>
</table>
<p>表 <span class="math inline">\(3\)</span> —— <code>汉あ😊</code> 对应的 Unicode 码点及二进制</p>
<h1 id="图片的存储和读取输出">图片的存储和读取输出</h1>
<p>我们使用电脑时碰见图片应该也是常见的（上文的 ASCII 码表就是一张图片）。那么，图片又是如何在计算机中存储和读取输出的呢？</p>
<p>我们都知道，一张图片是由很多很多像素点组成的。每一个像素点都有一个 RGB（红、绿、蓝，Red, Green, Blue）值。我们就拿一个表存下这个图片所有像素点的 R 值、G 值、B 值，再转换为二进制存储。当然，如果这个图片有透明度，根据不同的图片格式，如果这个图片是 PNG 格式，需要增加一个字节来读取输出透明度，<span class="math inline">\(0\)</span> 读取输出全透明，<span class="math inline">\(255\)</span> 读取输出不透明，这个透明度的值越小，越透明，反之亦然；如果这个图片是个 GIF 格式，只需要增加一位，<span class="math inline">\(0\)</span> 读取输出透明，<span class="math inline">\(1\)</span> 读取输出不透明。JPEG 和 BMP 格式的图片无法渲染透明度。读取输出时，根据每一个 RGB 值和透明度值渲染每一个像素，再拼凑出这个图案。</p>
<p>当然，除了静态图，还有动态图。动态图就是记录每一帧的图片数据，然后记录每一帧的时长、整体循环次数，以及记录一些帧间规则。记录的这些东西都是一个一个的数，可以直接转换为二进制存储。读取输出时，通过读取记录的每一个数据，把每一帧于每一帧之间通过帧间时长和一些其他的规则，把动态的画面展示出来。</p>
<h1 id="声音的存储和读取输出">声音的存储和读取输出</h1>
<p>我们听歌的时候就会碰到声音。那么计算机又是怎么存储声音的呢？其实本质就是把模拟声音信号转换为数字信号并以二进制形式存储，核心步骤包括 “模拟信号数字化” 和 “数字数据的编码与存储”。</p>
<h2 id="模拟声音信号的数字化">模拟声音信号的数字化</h2>
<p>自然界的声音（如人声、乐器声）是连续的模拟信号（随时间连续变化的声波），而计算机只能处理离散的数字信号（<span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>），因此需要通过 “模数转换（ADC）” 将模拟声音转为数字形式，包含三个核心步骤：</p>
<ol>
<li><strong>采样</strong>：按固定时间间隔截取模拟声波的瞬时振幅，将连续的声波 “离散化” 为一系列采样点。采样频率（单位：Hz）越高，越接近原始声音细节。</li>
<li><strong>量化</strong>：将每个采样点的振幅（模拟量）转换为有限个离散的数字值（整数），确定每个采样点的 “音量大小”。因离散化导致的原始信号与数字信号的差异，位数越高，误差越小，声音越细腻。</li>
<li><strong>编码</strong>：将量化后的整数转换为二进制数据（<span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>），并添加同步信息、纠错码等，形成可存储的数字音频流。</li>
</ol>
<h2 id="读取输出声音">读取输出声音</h2>
<p>要从二进制转回声音，却不是向字符映射那么简单做个逆运算就行的。首先需要读取存储的数据，明确采样率、量化数以及声道数等方便后续处理。接着，借助数字模拟转换器（DAC）把解码后的 PCM 二进制数据转换为模拟电压或电流信号。DAC 的工作原理是将二进制数字量译码后，把每一位依权值大小转换为对应的模拟量，再汇总这些模拟量得到最终模拟输出信号。例如 R-2R 梯形电阻网络 DAC 可按 <span class="math inline">\(2\)</span> 的幂次方比例将各二进制位转成对应电流，求和后输出匹配的模拟值。经 DAC 转换的模拟信号常带有高频噪声及混叠产物，需利用低通滤波器消除高于音频频段的信号成分。滤波器依据奈奎斯特采样定理设置截止频率，像针对 <span class="math inline">\(44.1\)</span> kHz 采样的音频，滤波器可将 <span class="math inline">\(22.05\)</span> kHz 以上的高频成分滤除，使输出的模拟信号更平滑，接近原始模拟声音信号。滤波后的模拟音频信号通常强度较弱，要通过音频放大器增强其功率，达到能驱动扬声器或耳机等发声设备的水平。最后，扬声器或耳机依据模拟信号的电压或电流变化振动发声，让人们听到对应的声音。</p>
<h1 id="视频的存储和读取输出">视频的存储和读取输出</h1>
<p>视频，其实就是动图和声音的结合体。其主要就是对动图和声音进行一个封装，同步时间戳，然后转换为二进制文件。对于如何存储动图和声音，请见上文。</p>
<p>读取输出视频，首先就是读取二进制并解析封装格式、编码类型、时间戳规则等，然后分离视频流和音频流。接着，对视频流和音频流解码（具体内容请见上文），接着，音画同步输出。</p>
<h1 id="尾声">尾声</h1>
<p>以上就是这篇文章的全部了，感谢各位读者的阅读。由于作者知识有限，有哪些地方写得不好或者有错误的，欢迎大家评论区指出。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/Lytx-Luogu1145420/" target="_blank">longyitongxue</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/Lytx-Luogu1145420/p/19043270/how_computer_binary" target="_blank">https://www.cnblogs.com/Lytx-Luogu1145420/p/19043270/how_computer_binary</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-17 14:54">2025-08-17 14:54</span>&nbsp;
<a href="https://www.cnblogs.com/Lytx-Luogu1145420">longyitongxue</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19043270);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19043270', targetLink: 'https://www.cnblogs.com/Lytx-Luogu1145420/p/19043270/how_computer_binary', title: '一些数据在计算机中的储存与表示' })">举报</a>
</div>
        