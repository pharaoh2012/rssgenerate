
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Big-Yellow/p/18882659" title="发布于 2025-05-18 21:24">
    <span role="heading" aria-level="2">深入浅出了解生成模型-2：VAE模型原理以及代码实战</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>From: <a href="https://www.big-yellow-j.top/posts/2025/05/11/VAE.html" target="_blank" rel="noopener nofollow">https://www.big-yellow-j.top/posts/2025/05/11/VAE.html</a><br>
前文已经介绍了<a href="https://www.big-yellow-j.top/posts/2025/05/08/GAN.html" target="_blank" rel="noopener nofollow">GAN</a>的基本原理以及代码操作，本文主要介绍VAE其基本原理以及代码实战</p>
<h2 id="vae-or-ae">VAE or AE</h2>
<p>介绍VAE之前了解两个概念：AE（AutoEncoder，自编码器）和VAE（Variational Autoencoder，变自编码器）。<strong>AE</strong>：自编码器是一种无监督学习神经网络，旨在通过将输入数据压缩到一个低维表示（编码），然后从该表示重建输入数据（解码），来学习数据的特征表示。<strong>VAE</strong>：变分自编码器是自编码器的扩展，结合了概率模型和深度学习，通过引入变分推理使潜在空间具有概率分布特性，适合生成任务。<br>
<strong>AE</strong>的数学描述对于输入 <span class="math inline">\(x\)</span>通过编码器将输入映射到 <strong>低纬空间</strong> <span class="math inline">\(z=f(x)\)</span>而后通过解码器得到输出：<span class="math inline">\(\hat{x}=g(x)\)</span><br>
<strong>VAE</strong>的数学描述对于输入 <span class="math inline">\(x\)</span>通过编码器将输入映射成 <strong>概率分布</strong> <span class="math inline">\(q(z\vert x)\)</span>，假设为高斯分布，输出 𝜇和 𝜎，从 <span class="math inline">\(q(z\vert x)\)</span>采样 <span class="math inline">\(z\)</span>而后通过 <span class="math inline">\(z=\mu+ \sigma+ \epsilon\)</span> 其中 <span class="math inline">\(\epsilon \in N(0,1)\)</span>，而后通过采样得到的<span class="math inline">\(z\)</span>重新构建输入，生成<span class="math inline">\(p(x\vert z)\)</span><br>
前者不适合对于图片进行生成而后者则是更加适合图像生成，这是因为AE将输入映射到一个低纬空间z这个低纬空间并没有明确的结构，进而就可能不适合去生成新的数据，而VAE之所以可以用于生成新的数据是，比如说对于图像数据（比如说：猫）如果知道其分布特征，就可以直接通过分布特征去构建一个新的图像</p>
<p><img src="https://s2.loli.net/2025/05/13/Ji5sAMmGehLjdf9.png" alt="" loading="lazy"></p>
<h2 id="vaevariational-autoencoder">VAE（Variational Autoencoder）</h2>
<p>上面简单介绍了VAE数学描述这里重新再描述一下其数学描述（涉及到比较多贝叶斯统计相关内容）：</p>
<h3 id="1基本框架">1.基本框架</h3>
<p>VAE 是一种生成模型，<strong>目标是学习数据的概率分布 p(x)，让模型能生成类似真实数据的新样本</strong>，想象我们要制作各种蛋糕（数据 <span class="math inline">\(x\)</span>），但不知道蛋糕的“秘方”（潜在变量 <span class="math inline">\(z\)</span>）。假设所有蛋糕组成数据集 <span class="math inline">\(X = {x_1, \dots, x_n}\)</span>，每种蛋糕（如巧克力蛋糕或水果蛋糕）背后有独特的秘方。VAE 通过学习秘方的分布和生成过程，制造出逼真的蛋糕。<br>
<strong>秘方</strong>：VAE 假设秘方 <span class="math inline">\(z\)</span> 服从标准正态分布，即先验分布 <span class="math inline">\(p(z) = \mathcal{N}(0, I)\)</span>。这意味着大多数秘方是“普通”的，围绕平均值分布。<br>
<strong>生成蛋糕（解码器）</strong>：给定秘方 <span class="math inline">\(z\)</span>，VAE 使用一个“蛋糕机”（解码器，参数 <span class="math inline">\(\theta\)</span>）生成蛋糕 <span class="math inline">\(x\)</span>。解码器建模条件分布 <span class="math inline">\(p_\theta(x\vert z) = \mathcal{N}(x; \mu_\theta(z), \sigma_\theta^2(z))\)</span>，表示从 <span class="math inline">\(z\)</span> 生成 <span class="math inline">\(x\)</span> 的概率。<br>
<strong>猜测秘方（编码器）</strong>：直接从蛋糕 <span class="math inline">\(x\)</span> 反推秘方（后验分布 <span class="math inline">\(p_\theta(z\vert x)=\frac{p_\theta(x,z)}{p_\theta(x)}=\frac{p_\theta(x\vert )p(z)}{p_\theta(x)}\)</span>）很困难（因为我的变量是一个高维的，换句说法就是我的蛋糕他有千奇百怪种组合）。既然如此就只需要将制造蛋糕的组合分解，分解成低维的变量 <span class="math inline">\(z\)</span>（也就是上面提到的 <strong>秘方</strong>）然后我去计算下面一个联合分布（<span class="math inline">\(p(x,z)\)</span>）：</p>
<p></p><div class="math display">\[p_\theta(x) =\int p_\theta(x\vert z)p(z)dz
\]</div><p></p><p>不过就算上面积分会存在困难即使你将蛋糕分解成不同的 <em>潜在变量</em> 但是这些潜在变量种类也是很多的（蛋糕奶油、加不加巧克力等等）那么上面的联合分布就会变成：</p>
<p></p><div class="math display">\[\int p_\theta(x\vert z)p(z)dz = \int_{z_1} ... \int_{z_d}p_\theta(x\vert z)p(z)d_{z_1}...d_{z_d}
\]</div><p></p><p>这种高维积分没有解析解，数值积分计算复杂度随维度指数增长，因此在VAE 引入一个“猜测机”（编码器，也就是一个神经网络，参数 <span class="math inline">\(\varphi\)</span>），用变分分布：</p>
<p></p><div class="math display">\[q_\varphi(z\vert x) = \mathcal{N}(z; \mu_\varphi(x), \text{diag}(\sigma_\varphi^2(x)))
\]</div><p></p><p>近似后验分布，估计可能的秘方也就是去估算我们的：<span class="math inline">\(p_\theta(z\vert x)\)</span></p>
<blockquote>
<p>再去引入新的参数 <span class="math inline">\(\varphi\)</span> 不还是很难计算吗？似乎是这么一回事，但是回顾我们需要解决的问题：<span class="math inline">\(p_\theta(z\vert x)=\frac{p_\theta(x,z)}{p_\theta(x)}=\frac{p_\theta(x\vert z)p(z)}{p_\theta(x)}\)</span> 分子分母三项都是很难计算的那么也就意味着如果要通过 <span class="math inline">\(x\)</span> “推算” <span class="math inline">\(z\)</span> 基本就是很难解决的问题，那么“干脆”不去计算用神经网络进行“模拟”也就是说 <span class="math inline">\(p_\theta(z\vert x) ≈ p_\varphi(z\vert x)\)</span></p>
</blockquote>
<p>大致总结一下就是：VAE的主要的任务就是，最开始的数据集里面，我希望通过对这个数据的潜在分布进行学习，如果我模型学会了各类数据的分布，那么就可以通过这些分布去进一步生成新的数据。</p>
<h3 id="2损失函数构建">2.损失函数构建</h3>
<p>了解模型基本框架之后就需要对整个模型的参数进行求解，正如上面所述对于数据集分布 <span class="math inline">\(p_\theta(x)\)</span> 的计算我们通过构建一个和 <span class="math inline">\(z\)</span>的联合分布，因此整个过程计算如下：</p>
<p></p><div class="math display">\[\begin{align}
\log p_{\theta}(x) &amp;= \log p_{\theta}\left(x\right) \tag{1} \\
&amp;= \log p_{\theta}\left(x\right)\int q_{\varphi}(z\vert x)dz \tag{2} \\
&amp;= \int\log p_{\theta}\left(x\right)q_{\varphi}(z\vert x)dz \tag{3} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{Z}\vert\mathbf{X})}[\log p_{\theta}(\mathbf{x})] \tag{4} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{Z}\vert\mathbf{X})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{p_{\theta}(\mathbf{z}\vert\mathbf{x})}\right] \tag{5} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{Z}\vert\mathbf{X})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})q_{\varphi}(\mathbf{z}\vert\mathbf{x})}{p_{\theta}(\mathbf{z}\vert\mathbf{x})q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\right] \tag{6} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\right] + \mathbb{E}_{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\left[\log\frac{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}{p_{\theta}(\mathbf{z}\vert\mathbf{x})}\right] \tag{7} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\right] + \underbrace{D_{\mathrm{KL}}\left(q_{\varphi}(\mathbf{z}\vert\mathbf{x}) \parallel p_{\theta}(\mathbf{z}\vert\mathbf{x})\right)}_{\geq 0} \tag{8} \\
&amp;\geq \mathbb{E}_{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{q_{\varphi}(\mathbf{z}\vert\mathbf{x})}\right] \quad (\text{ELBO}) \tag{9}
\end{align}
\]</div><p></p><blockquote>
<p>其中 <span class="math inline">\(\text{ELBO}\)</span>也就是所谓的变分下界</p>
</blockquote>
<p>（1-3）上面介绍对于联合分布 <span class="math inline">\(p_\theta(x) =\int p_\theta(x\vert z)p(z)dz\)</span> 计算存在困难，因此替换为 <span class="math inline">\(p_\theta(x) =\int p_\varphi(x\vert z)p(z)dz\)</span>；（4-7）直接就是贝叶斯公式和一些基本变形；（8）最后一项就是 <span class="math inline">\(KL\)</span>散度。最后上面公式就可以写成：</p>
<p></p><div class="math display">\[\begin{aligned}
\log p_{\theta}(x)\geq E_{q_{\varphi}(\mathbf{z}|\mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{q_{\varphi}(\mathbf{z}|\mathbf{x})}\right] &amp; =E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}\left[\log\frac{p_{\theta}(\mathbf{x}|\mathbf{z})p(\mathbf{z})}{q_{\varphi}(\mathbf{z}|\mathbf{x})}\right] \\
 &amp; =E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}[\log p_{\theta}(\mathbf{x}|\mathbf{z})]+E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}\left[\log\frac{p(\mathbf{z})}{q_{\varphi}(\mathbf{z}|\mathbf{x})}\right] \\
 &amp; =E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}[\log p_{\theta}(\mathbf{x}|\mathbf{z})]-D_{KL}\left(q_{\varphi}(\mathbf{z}|\mathbf{x})\|p_{\theta}(\mathbf{z})\right)
\end{aligned}
\]</div><p></p><p>那么我们的损失函数就是（最大化下面计算）：</p>
<p></p><div class="math display">\[L(\theta, \varphi,x)= E_{q_{\varphi}(\mathbf{z}|\mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x},\mathbf{z})}{q_{\varphi}(\mathbf{z}|\mathbf{x})}\right]=E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}[\log p_{\theta}(\mathbf{x}|\mathbf{z})]-D_{KL}(q_{\varphi}(\mathbf{z}|\mathbf{x})\|p_{\theta}(\mathbf{z}))
\]</div><p></p><p>在深度学习中自然就会直接用 <em>梯度下降</em>的方法去优化参数，下面推荐借鉴：<a href="https://arxiv.org/pdf/1906.02691" target="_blank" rel="noopener nofollow">https://arxiv.org/pdf/1906.02691</a> 中的描述</p>
<p><strong>参数求解之前引入最开始定义的几个变量</strong>：</p>
<p></p><div class="math display">\[q_\varphi(z\vert x) = \mathcal{N}(z; \mu_\varphi(x), \text{diag}(\sigma_\varphi^2(x))) \qquad
p_\theta(x\vert z) = \mathcal{N}(x; \mu_\theta(z), \sigma_\theta^2(z))
\]</div><p></p><h4 id="21-参数--计算">2.1 参数 <span class="math inline">\(\theta\)</span> 计算</h4>
<p>对于 <span class="math inline">\(\theta\)</span>参数可以得到：</p>
<p></p><div class="math display">\[\begin{align}
\nabla_{\theta} \mathcal{L}(x,\theta,\varphi) &amp;= \nabla_{\theta} \mathbb{E}_{q_\varphi(z|x)} \left[ \log p_\theta(x,z) - \log q_\varphi(z|x) \right] \\
&amp;= \mathbb{E}_{q_\varphi(z|x)} \left[ \nabla_{\theta} (\log p_\theta(x,z) - \log q_\varphi(z|x)) \right] \\
&amp;\approx \nabla_{\theta} (\log p_\theta(x,z) - \log q_\varphi(z|x)) \\
&amp;= \nabla_{\theta} (\log p_\theta(x,z))
\end{align}
\]</div><p></p><p>（1-2）也需要注意之所以可以将梯度拿到期望里面（直接借鉴 grok里面解释），另外一点在计算梯度时候将 KL散度拿掉这是因为在KL计算中第一部分参数为 <span class="math inline">\(\varphi\)</span>，而第二部分参数 <span class="math inline">\(p_\theta(x)\)</span> 我们实现定义他是一个简单的标准正态分布：<span class="math inline">\(\mathcal{N}(0, I)\)</span></p>
<p><img src="https://s2.loli.net/2025/05/16/DrLX36eKG5whNPk.png" alt="" loading="lazy"></p>
<p>（3）这是因为在后面一项中参数是 <span class="math inline">\(\varphi\)</span> 因此计算梯度直接为0因此就可以拿掉，对于下面公式：</p>
<p></p><div class="math display">\[\mathbb{E}_{q_\varphi(z|x)} [\nabla_{\theta} (\log p_\theta(x,z)] \rightarrow \nabla_{\theta} (\log p_\theta(x,z))
\]</div><p></p><p>一个容易接受的说法：可以直接通过蒙特卡洛方法，通过从分布中抽取少量样本（甚至单样本）来近似期望值。因此对于期望</p>
<p></p><div class="math display">\[\mathbb{E}_{q_\varphi(z\vert x)}[ \nabla_\theta \log p_\theta(x, z)] 
\approx \frac{1}{S} \sum_{s=1}^S \nabla_\theta \log p_\theta(x, z)
\]</div><p></p><p>计算，可以去通过从 <span class="math inline">\(q_\varphi(z\vert x)\)</span> 进行抽样，当 <span class="math inline">\(S=1\)</span> 时候就直接变成单个样本去近似整个期望。（单样本估计的方差可以通过SGD的多次迭代和批量数据的处理来缓解，模型会在优化过程中逐渐收敛到一个较好的解（通常是局部最优或接近全局最优））</p>
<h4 id="22-参数--计算">2.2 参数 <span class="math inline">\(\varphi\)</span> 计算</h4>
<p>对于参数 <span class="math inline">\(\varphi\)</span>不能直接像上面计算一样直接将 <span class="math inline">\(\nabla\)</span> 拿到期望里面（期望和分布都依赖参数 <span class="math inline">\(\varphi\)</span>）也就是 <a href="https://arxiv.org/pdf/1906.02691" target="_blank" rel="noopener nofollow">论文</a> 里面提到的下面公式不成立：</p>
<p></p><div class="math display">\[\begin{equation}
\nabla_{\varphi} \mathcal{L}_{\theta, \varphi}(x) = \nabla_{\varphi} \mathbb{E}_{q_{\varphi}(z|x)} \left[ \log p_{\theta}(x, z) - \log q_{\varphi}(z|x) \right]
\neq \mathbb{E}_{q_{\varphi}(z|x)} \left[ \nabla_{\varphi} \left( \log p_{\theta}(x, z) - \log q_{\varphi}(z|x) \right) \right]
\end{equation}
\]</div><p></p><blockquote>
<p>下面是成立的并且可以直接求导变为0</p>
<p></p><div class="math display">\[\mathbb{E}_{q_\varphi(z\vert x)}[\nabla_\theta \log p_\theta(x, z)]
\]</div><p></p></blockquote>
<p>既然如此那么就直接涌入一个随机变量 <span class="math inline">\(\epsilon\)</span> 将最开始的 <span class="math inline">\(z \in q_{\varphi}(z\vert x)\)</span> 转化为：<span class="math inline">\(z=g(\epsilon,\varphi,x)\)</span>，回顾最开始定义的损失函数：</p>
<p></p><div class="math display">\[L(\theta,\varphi,x) = E_{q_{\varphi}(\mathbf{z}|\mathbf{x})}[\log p_{\theta}(\mathbf{x}|\mathbf{z})]-D_{KL}(q_{\varphi}(\mathbf{z}|\mathbf{x})\|p_{\theta}(\mathbf{z}))
\]</div><p></p><ul>
<li><strong>第一部重构项计算</strong>：<span class="math inline">\(E_{q_{\varphi}(\mathbf{z}\vert \mathbf{x})}[\log p_{\theta}(\mathbf{x}\vert\mathbf{z})]\)</span></li>
</ul>
<p>因为通过引入了随机变量 <span class="math inline">\(\epsilon\)</span>因此上面公式可以变为：<span class="math inline">\(E_\epsilon[\log p_{\theta}(\mathbf{x}\vert\mathbf{z})]\)</span>，那么对于其梯度进行计算得到：</p>
<p></p><div class="math display">\[\nabla_{\varphi} \mathbb{E}_{q_{\varphi}(z\vert x)} \left[ \log p_{\theta}(\mathbf{x}\vert \mathbf{z}) \right]
= \mathbb{E}_{p(\epsilon)} \left[ \nabla_{\varphi} \log p_{\theta}(\mathbf{x}|\mathbf{z}) \right]
= \nabla_{\varphi} \log p_{\theta}(\mathbf{x}|\mathbf{z})
\]</div><p></p><p>是不是可以直接让其变成0？还是不行因为里面变量 <span class="math inline">\(z\)</span>的分布还是依赖我们的变量 <span class="math inline">\(\varphi\)</span>（最开始我们假设了<span class="math inline">\(\mathcal{N}(z; \mu_\varphi(x), \text{diag}(\sigma_\varphi^2(x)))\)</span>）对于最后的结果就和最开始的 <span class="math inline">\(\theta\)</span>求解一样可以直接通过蒙特卡洛模拟来进行计算，也就是：</p>
<p></p><div class="math display">\[\nabla_{\varphi} \mathbb{E}_{q_{\varphi}(z|x)} \left[ \log p_{\theta}(\mathbf{x}|\mathbf{z}) \right]≈\frac{1}{S}\sum_{s=1}^{S}log p_\theta(x\vert z)
\]</div><p></p><ul>
<li><strong>第二部分KL散度计算</strong>：<span class="math inline">\(D_{KL}(q_{\varphi}(\mathbf{z}\vert \mathbf{x})\vert p_{\theta}(\mathbf{z}))\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(D_{KL}\left(q_{\varphi}(\mathbf{z}\vert \mathbf{x})\vert p_{\theta}(\mathbf{z})\right)=E_{q_{\varphi}(\mathbf{Z}\vert \mathbf{X})}\left[\log\frac{q_{\varphi}(\mathbf{z}\vert \mathbf{x})}{p_\theta(\mathbf{z})}\right]\)</span></p>
</blockquote>
<p></p><div class="math display">\[\begin{align}
\nabla_\varphi D_{KL}(q_\varphi(\mathbf{z}|\mathbf{x}) \| p_\theta(\mathbf{z})) 
&amp;= \nabla_\varphi \int q_\varphi(\mathbf{z}|\mathbf{x}) [\log q_\varphi(\mathbf{z}|\mathbf{x}) - \log p_\theta(\mathbf{z})] d\mathbf{z} \\
&amp;= \int \left[ \nabla_\varphi q_\varphi(\mathbf{z}|\mathbf{x}) [\log q_\varphi(\mathbf{z}|\mathbf{x}) - \log p_\theta(\mathbf{z})] + q_\varphi(\mathbf{z}|\mathbf{x}) \cdot \frac{\nabla_\varphi q_\varphi(\mathbf{z}|\mathbf{x})}{q_\varphi(\mathbf{z}|\mathbf{x})} \right] d\mathbf{z} \\
&amp;= \int \nabla_\varphi q_\varphi(\mathbf{z}|\mathbf{x}) \left[ \log q_\varphi(\mathbf{z}|\mathbf{x}) - \log p_\theta(\mathbf{z}) + 1 \right] d\mathbf{z} \\
&amp;= \int q_\varphi(\mathbf{z}|\mathbf{x}) \left[ \nabla_\varphi \log q_\varphi(\mathbf{z}|\mathbf{x}) \right] \left[ \log q_\varphi(\mathbf{z}|\mathbf{x}) - \log p_\theta(\mathbf{z}) + 1 \right] d\mathbf{z} \\
&amp;= \mathbb{E}_{q_{\varphi}(\mathbf{z}|\mathbf{x})} \left[ \left( \log q_\varphi(\mathbf{z}|\mathbf{x}) - \log p_\theta(\mathbf{z}) + 1 \right) \nabla_\varphi \log q_\varphi(\mathbf{z}|\mathbf{x}) \right] \\
&amp;\approx \frac{1}{L} \sum_{l=1}^L \left[ \left( \log q_\varphi(\mathbf{z}^{(l)}|\mathbf{x}) - \log p_\theta(\mathbf{z}^{(l)}) + 1 \right) \nabla_\varphi \log q_\varphi(\mathbf{z}^{(l)}|\mathbf{x}) \right], \quad \mathbf{z}^{(l)} \sim q_\varphi(\mathbf{z}|\mathbf{x})
\end{align}
\]</div><p></p><p>上面公式中第2项：直接通过求导的乘法法则，对于括号里面内容求导过程中:第二项 <span class="math inline">\(logp_\theta(z)\)</span>和 <span class="math inline">\(\varphi\)</span>无关因此直接等于0，第4项：<span class="math inline">\(\nabla_\varphi q_\varphi(z \vert x)=q_\varphi(z\vert x)\nabla_ \varphi logq_\varphi(z\vert x)\)</span>，最后两项就是直接改写为期望然后通过蒙特卡洛计算得到结果。</p>
<h2 id="vq-vae">VQ-VAE</h2>
<blockquote>
<p><a href="https://arxiv.org/pdf/1711.00937" target="_blank" rel="noopener nofollow">https://arxiv.org/pdf/1711.00937</a></p>
</blockquote>
<p>注意主要简单介绍一下其基本原理，VQ-VAE主要是为了解决VAE在生成样本模糊问题，通过向量量化将编码器的输出映射到离散的码本（codebook）中。这种离散化可以更好地捕捉数据的局部结构，生成更清晰的样本，同时避免了传统 VAE 中后验分布和先验分布之间的 KL 散度优化带来的不稳定性。因此和传统的VAE差异在于将 “潜在空间”替换为离散的 <strong>码本（codebook）</strong><br>
<img src="https://s2.loli.net/2025/05/18/MVBqSKXkEist2zn.png" alt="" loading="lazy"></p>
<blockquote>
<p><strong>值得注意的</strong>：VQ-VAE不能直接用于生成新的样本，需要一个额外的先验模型去建模离散的潜在变量</p>
</blockquote>
<p>这里不对数学原理做过多解释，直接解释代码如何操作，唯一的区别就是在于如何去构建 “离散化的码本”，对于输入图像通过编码器处理之后：<br>
<strong>第一步</strong>、生成我们的码本：<span class="math inline">\(C=[e+k]_{k=1}^K\)</span> 代表K个嵌入向量以及每个向量维度为D。可以直接通过：<code>nn.Embedding(num_embeddings, embedding_dim)</code><br>
<strong>第二步</strong>、直接将encoder处理后的内容“拉平”（<span class="math inline">\((B,C,H,W)\rightarrow (N,D)\)</span> 其中 <span class="math inline">\(N=B\times H\times W\)</span>）而后计算拉平后的内容和 码本之间的距离，并且返回距离最小的码本向量（<span class="math inline">\(K,D\)</span>）索引：<span class="math inline">\(k=argmin_j \Vert z_e^i- e_j \Vert _2^2\)</span>，而后将结果丢到one-hot矩阵（<span class="math inline">\((N,K)\)</span>）中指导每个输入向量选择哪些码本向量<br>
<strong>第三步</strong>、将码本权重和one-hot相乘得到量化向量：<span class="math inline">\(z_q\in [N,D]\)</span><br>
<strong>第四步</strong>、计算损失：1、承诺损失（编码器输出和量化输出均方误差）；2、量化损失（量化输出和编码器输出的均方误差）；而后对两部分进行加权<br>
<strong>第五步</strong>、困惑度：监控码本利用率：<span class="math inline">\(exp(-\sum_k p_klogp_k)\)</span></p>
<p>说人话就是：编码后的向量会将这个向量映射到一个“字典”（也就是我们的码本，可以理解为这个<strong>码本存储了我们所有特征</strong>，最开始VAE是用连续分布做的）上，具体映射方法就是计算编码器的连续输出和码本中向量最接近的向量，然后用这个向量替换原始特征，但是这个码本开始是不行的，因此就需要计算损失来更新，因此就直接计算码本和编码器输出损失，于此同时也为了保证编码器输出和码本接近也计算损失，但是量化过程（选最近向量）没法直接算梯度，所以用“直通”方法：前向传播用码本选择的向量反向传播时假装梯度直接传回编码器输出。困惑度检查码本向量使用情况。如果困惑度低，说明有些向量没被用（“死码”），需要优化。</p>
<h2 id="3代码操作">3.代码操作</h2>
<p>说一千到一万不如直接看代码操作！代码上VAE代码比较简单主要是3个模块：1、encoder；2、decoder；3、潜在空间。在encoder/decoder中就都是通过一个神经网络构建而成的，没有太多需要解释的，不过需要注意的是在通过 encoder 直接处理之后，会额外通过神经网络去“拟合”：<span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\sigma\)</span> 去代表潜在空间的分布，除此之外在 潜在空间 处理上还会计算我们引入的随机变量 <span class="math inline">\(\epsilon\)</span>，通过下面图像解释：</p>
<p><img src="https://s2.loli.net/2025/05/18/4bOfcMn83HDjLpK.png" alt="" loading="lazy"></p>
<p>因此代码结构上（以MNIST数据集为例）：</p>
<pre><code class="language-python">class VAE(nn.Module):
    def __init__(self, latent_dim=20, input_dim=784):
        super(VAE, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU()
        )
        self.fc_mu = nn.Linear(128, latent_dim)
        self.fc_var = nn.Linear(128, latent_dim)
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 256),
            nn.ReLU(),
            nn.Linear(256, input_dim),
            nn.Sigmoid()
        )

    def encode(self, x):
        h = self.encoder(x)
        return self.fc_mu(h), self.fc_var(h)

    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5 * logvar)
        eps = torch.randn_like(std)
        return mu + eps * std

    def decode(self, z):
        return self.decoder(z)

    def forward(self, x):
        x = x.view(-1, VAE_CONFIG['image_size'])
        mu, logvar = self.encode(x)
        z = self.reparameterize(mu, logvar)
        recon_x = self.decode(z)
        return recon_x, mu, logvar
</code></pre>
<p>整体的代码结构很简单，在loss计算上，最开始我们的优化是：</p>
<p></p><div class="math display">\[L(\theta, \varphi,x)=E_{q_{\varphi}(\mathbf{Z}|\mathbf{X})}[\log p_{\theta}(\mathbf{x}|\mathbf{z})]-D_{KL}(q_{\varphi}(\mathbf{z}|\mathbf{x})\|p_{\theta}(\mathbf{z}))
\]</div><p></p><p>其中第一项为我们的重建项（可以直接通过BCE loss来计算）、第二项为KL散度（存在解：<span class="math inline">\(D_{KL}=\frac{1}{2}\sum_{j=1}^{d}(\mu_j^2+\sigma_j^2-log\sigma_j^2-1)\)</span>）。</p>
<pre><code class="language-python">def vae_loss(recon_x, x, mu, logvar):
    recon_x = torch.clamp(recon_x, 1e-8, 1-1e-8)
    x = x.view(-1, VAE_CONFIG['image_size'])
    BCE = nn.functional.binary_cross_entropy(recon_x, x, reduction='sum')
    KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
    return (BCE + KLD) / x.size(0)  # 平均损失
</code></pre>
<p>所有的代码：1、<a href="./code/../../code/VAE.py.txt" target="_blank" rel="noopener nofollow">VAE</a>；2、<a href="../code/PixcelCNN.py.txt" target="_blank" rel="noopener nofollow">PixelCNN</a></p>
<h3 id="实际生成效果">实际生成效果</h3>
<blockquote>
<p>VAE测试的主要是生成效果（MNIST数据集），而VA-VAE则是测试重构效果</p>
</blockquote>
<p><strong>VAE</strong>在MNIST数据集上表现</p>
<table>
<thead>
<tr>
<th style="text-align: center">固定输入</th>
<th style="text-align: center">重构图像</th>
<th style="text-align: center">随机生成</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/14/ABJDCTjW46Odx3g.gif" alt="" loading="lazy"></td>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/14/fQmMFOXRNovIubA.gif" alt="" loading="lazy"></td>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/14/28Tln5qcap6HvPf.gif" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>不过值得注意的是 MNIST数据集很简单所以VAE可以很容易就生成需要的图片<br>
<strong>VQ-VAE</strong>在CIFAR10数据集上重构图像的表现（<strong>生成图像只是测试代码运行效果</strong>，CIFAR10数据集自身也比较复杂！，在CIFAR10上都没能生成较好的图片）</p>
<table>
<thead>
<tr>
<th style="text-align: center">重构图像</th>
<th style="text-align: center">PixelCNN生成图像</th>
<th style="text-align: center">PixelCNNPlusPlus 生成图像</th>
<th style="text-align: center">GatedPixelCNN 生成图像</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/14/38zIQHaL9Vukret.gif" alt="" loading="lazy"></td>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/15/DHvAXfZIRimwOen.gif" alt="" loading="lazy"></td>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/15/mQqgLNF83uzoZiJ.gif" alt="" loading="lazy"></td>
<td style="text-align: center"><img src="https://s2.loli.net/2025/05/15/gDcBlhsyS1or8Iu.gif" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>本文主要介绍了VAE的基本原理以及不同参数的求解，除此之外介绍了VQ-VAE的基本原理。两种差异在于：潜在用连续分布替换特征，后者用离散分布替换特征。对于VAE代码在模型上不难只需要在最后生成潜在空间过程中通过神经网络拟合 <span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\sigma\)</span>以及会额外的生成一个随机变量 <span class="math inline">\(\epsilon\)</span>在损失函数计算中也只需要注意 <span class="math inline">\(D_{KL}\)</span>和重建项的计算即可。</p>
<h2 id="参考">参考</h2>
<p>1、<a href="https://github.com/hkproj/vae-from-scratch-notes/blob/main/VAE.pdf" target="_blank" rel="noopener nofollow">https://github.com/hkproj/vae-from-scratch-notes/blob/main/VAE.pdf</a><br>
2、<a href="https://mbernste.github.io/posts/vae/" target="_blank" rel="noopener nofollow">https://mbernste.github.io/posts/vae/</a><br>
3、<a href="https://arxiv.org/pdf/1906.02691" target="_blank" rel="noopener nofollow">https://arxiv.org/pdf/1906.02691</a><br>
4、<a href="https://arxiv.org/pdf/1312.6114" target="_blank" rel="noopener nofollow">https://arxiv.org/pdf/1312.6114</a><br>
5、<a href="https://arxiv.org/pdf/1711.00937" target="_blank" rel="noopener nofollow">https://arxiv.org/pdf/1711.00937</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03340307845138889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-18 21:25">2025-05-18 21:24</span>&nbsp;
<a href="https://www.cnblogs.com/Big-Yellow">Big-Yellow-J</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18882659);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18882659', targetLink: 'https://www.cnblogs.com/Big-Yellow/p/18882659', title: '深入浅出了解生成模型-2：VAE模型原理以及代码实战' })">举报</a>
</div>
        