
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sowler/p/18802875" title="发布于 2025-03-31 20:26">
    <span role="heading" aria-level="2">Kubernetes基础教程-通过部署Nginx快速学习基本使用命令</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1验证节点信息">1、验证节点信息</h1>
<h2 id="11查看控制平面组件的状态">1.1、查看控制平面组件的状态</h2>
<pre><code class="language-sh">[root@linux-servertwo software]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok                  
scheduler            Healthy   ok                  
etcd-0               Healthy   {"health":"true"}  

#controller-manager: 控制器管理器，负责维护集群的状态，例如复制控制器、部署控制器等。
#scheduler: 调度器，负责决定将哪个 Pod 安排到哪个节点。
#etcd-0: 分布式键值存储，用于存储 Kubernetes 集群的所有数据。
</code></pre>
<h2 id="12查看节点信息">1.2、查看节点信息</h2>
<h3 id="121查看节点信息">1.2.1、查看节点信息</h3>
<pre><code class="language-sh">#查看节点信息
[root@linux-servertwo software]# kubectl get nodes
NAME              STATUS   ROLES                  AGE   VERSION
linux-servertwo   Ready    control-plane,master,node   26h   v1.20.9
</code></pre>
<h3 id="122查看更加充分的节点信息">1.2.2、查看更加充分的节点信息</h3>
<pre><code class="language-sh">#查看更加充分的节点信息
[root@linux-servertwo software]# kubectl get nodes -o wide 
NAME              STATUS   ROLES                  AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                 CONTAINER-RUNTIME
linux-servertwo   Ready    control-plane,master,node   27h   v1.20.9   10.0.4.16     &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1160.108.1.el7.x86_64   docker://26.1.3
</code></pre>
<h3 id="123查看节点详情">1.2.3、查看节点详情</h3>
<pre><code class="language-sh">#查看节点详情：
[root@linux-servertwo software]# kubectl describe node linux-servertwo
Name:               linux-servertwo
Roles:              control-plane,master,node
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=linux-servertwo
                    kubernetes.io/os=linux
                    node-role.kubernetes.io/control-plane=
                    node-role.kubernetes.io/master=
                    node-role.kubernetes.io/node=
......
</code></pre>
<h2 id="13查看系统组件">1.3、查看系统组件</h2>
<pre><code class="language-sh"># 集群中的各个组件也都是以Pod方式运行的
[root@linux-servertwo software]# kubectl get pods -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-2k74p                  1/1     Running   0          27h
coredns-7f89b7bc75-6xrvb                  1/1     Running   0          27h
etcd-linux-servertwo                      1/1     Running   0          27h
kube-apiserver-linux-servertwo            1/1     Running   0          27h
kube-controller-manager-linux-servertwo   1/1     Running   0          25h
kube-proxy-bmfzr                          1/1     Running   0          27h
kube-scheduler-linux-servertwo            1/1     Running   0          25h
</code></pre>
<h2 id="14查看所有pod">1.4、查看所有Pod</h2>
<h3 id="141查看所有pod信息">1.4.1、查看所有Pod信息</h3>
<pre><code class="language-sh">[root@linux-servertwo software]# kubectl get pods --all-namespaces
NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE
kube-flannel   kube-flannel-ds-lbmdr                     1/1     Running   0          5d
kube-system    coredns-7f89b7bc75-47d56                  1/1     Running   0          6d4h
kube-system    coredns-7f89b7bc75-h4c9b                  1/1     Running   0          6d4h
kube-system    etcd-linux-servertwo                      1/1     Running   0          6d4h
kube-system    kube-apiserver-linux-servertwo            1/1     Running   0          6d4h
kube-system    kube-controller-manager-linux-servertwo   1/1     Running   0          5d
kube-system    kube-proxy-j7d4v                          1/1     Running   0          6d4h
kube-system    kube-scheduler-linux-servertwo            1/1     Running   0          5d
</code></pre>
<h3 id="142查看更充分的所有pod信息">1.4.2、查看更充分的所有pod信息</h3>
<pre><code class="language-sh"># 查看更充分的所有pod详情信息
[root@linux-servertwo software]# kubectl get pods --all-namespaces -o wide
NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE    IP           NODE              NOMINATED NODE   READINESS GATES
kube-flannel   kube-flannel-ds-lbmdr                     1/1     Running   0          5d     10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    coredns-7f89b7bc75-47d56                  1/1     Running   0          6d4h   172.17.0.3   linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    coredns-7f89b7bc75-h4c9b                  1/1     Running   0          6d4h   172.17.0.2   linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    etcd-linux-servertwo                      1/1     Running   0          6d4h   10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    kube-apiserver-linux-servertwo            1/1     Running   0          6d4h   10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    kube-controller-manager-linux-servertwo   1/1     Running   0          5d     10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    kube-proxy-j7d4v                          1/1     Running   0          6d4h   10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
kube-system    kube-scheduler-linux-servertwo            1/1     Running   0          5d     10.0.4.16    linux-servertwo   &lt;none&gt;           &lt;none&gt;
</code></pre>
<h2 id="15查看节点日志">1.5、查看节点日志</h2>
<pre><code class="language-sh">使用 journalctl -u kubelet 命令查看日志信息

# 动态查看 kubelet 日志的命令
[root@linux-servertwo software]# journalctl -u kubelet -f
Mar 19 15:53:58 linux-servertwo kubelet[25155]: I0319 15:53:58.023328   25155 reconciler.go:224] operationExecutor.VerifyControllerAttachedVolume started for volume "config-volume" (UniqueName: "kubernetes.io/configmap/9d6647d1-caeb-448a-9628-c5ac14821995-config-volume") pod "coredns-7f89b7bc75-47d56" (UID: "9d6647d1-caeb-448a-9628-c5ac14821995")
Mar 19 15:53:58 linux-servertwo kubelet[25155]: map[string]interface {}{"cniVersion":"0.3.1", "hairpinMode":true, "ipMasq":false, "ipam":map[string]interface {}{"ranges":[][]map[string]interface {}{[]map[string]interface {}{map[string]interface {}{"subnet":"172.17.0.0/24"}}}, "routes":[]types.Route{types.Route{Dst:net.IPNet{IP:net.IP{0xac, 0x11, 0x0, 0x0}, Mask:net.IPMask{0xff, 0xff, 0x0, 0x0}}, GW:net.IP(nil)}}, "type":"host-local"}, "isDefaultGateway":true, "isGateway":true, "mtu":(*uint)(0xc00001c928), "name":"cbr0", "type":"bridge"}
Mar 19 15:53:58 linux-servertwo kubelet[25155]: {"cniVersion":"0.3.1","hairpinMode":true,"ipMasq":false,"ipam":{"ranges":[[{"subnet":"172.17.0.0/24"}]],"routes":[{"dst":"172.17.0.0/16"}],"type":"host-local"},"isDefaultGateway":true,"isGateway":true,"mtu":1450,"name":"cbr0","type":"bridge"}
Mar 19 15:53:58 linux-servertwo kubelet[25155]: map[string]interface {}{"cniVersion":"0.3.1", "hairpinMode":true, "ipMasq":false, "ipam":map[string]interface {}{"ranges":[][]map[string]interface {}{[]map[string]interface {}{map[string]interface {}{"subnet":"172.17.0.0/24"}}}, "routes":[]types.Route{types.Route{Dst:net.IPNet{IP:net.IP{0xac, 0x11, 0x0, 0x0}, Mask:net.IPMask{0xff, 0xff, 0x0, 0x0}}, GW:net.IP(nil)}}, "type":"host-local"}, "isDefaultGateway":true, "isGateway":true, "mtu":(*uint)(0xc0000a28e8), "name":"cbr0", "type":"bridge"}
</code></pre>
<h1 id="2namespaces">2、Namespaces</h1>
<h2 id="21介绍">2.1、介绍</h2>
<p>命名空间Namespaces主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。它能够将资源划分为不同的分组，帮助我们在一个集群中划分不同的项目、团队或者环境（如开发、测试和生产环境），从而提高资源的隔离性和管理效率。</p>
<h2 id="22查看创建的命名空间">2.2、查看创建的命名空间</h2>
<pre><code class="language-sh">[root@linux-servertwo software]# kubectl get namespaces
NAME              STATUS   AGE
default           Active   24h
kube-flannel      Active   19h
kube-node-lease   Active   24h
kube-public       Active   24h
kube-system       Active   24h
</code></pre>
<h2 id="23创建命名空间">2.3、创建命名空间</h2>
<pre><code class="language-sh">[root@linux-servertwo software]# kubectl create namespace blog-dev
namespace/blog-dev created

# 再次查看-命名空间 blog-dev 创建成功
[root@linux-servertwo software]# kubectl get namespaces
NAME              STATUS   AGE
blog-dev          Active   17s
default           Active   24h
kube-flannel      Active   19h
kube-node-lease   Active   24h
kube-public       Active   24h
kube-system       Active   24h
</code></pre>
<h2 id="24删除命名空间">2.4、删除命名空间</h2>
<pre><code class="language-sh">#删除
[root@linux-servertwo software]# kubectl delete namespace blog-dev
namespace "blog-dev" deleted

#再次查看-发现已经删除
[root@linux-servertwo software]# kubectl get namespaces
NAME              STATUS   AGE
default           Active   24h
kube-flannel      Active   20h
kube-node-lease   Active   24h
kube-public       Active   24h
kube-system       Active   24h
</code></pre>
<h2 id="25检索指定命名空间">2.5、检索指定命名空间</h2>
<pre><code class="language-sh"># 查看-检索指定命名空间
[root@linux-servertwo software]# kubectl get namespaces blog-dev
NAME       STATUS   AGE
blog-dev   Active   39s

# 查看-指定命名空间详情
[root@linux-servertwo software]# kubectl describe namespace blog-dev
Name:         blog-dev
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Status:       Active

No resource quota.
No LimitRange resource.
</code></pre>
<h2 id="26查看命名空间中的资源">2.6、查看命名空间中的资源</h2>
<pre><code class="language-sh">[root@linux-servertwo software]# kubectl get pods -n blog-dev
No resources found in blog-dev namespace.
[root@linux-servertwo software]# kubectl get pod -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-47d56                  1/1     Running   0          6d4h
coredns-7f89b7bc75-h4c9b                  1/1     Running   0          6d4h
etcd-linux-servertwo                      1/1     Running   0          6d4h
kube-apiserver-linux-servertwo            1/1     Running   0          6d4h
kube-controller-manager-linux-servertwo   1/1     Running   0          5d1h
kube-proxy-j7d4v                          1/1     Running   0          6d4h
kube-scheduler-linux-servertwo            1/1     Running   0          5d1h
</code></pre>
<h2 id="27输出yaml格式">2.7、输出yaml格式</h2>
<pre><code class="language-sh"># 查看-输出yaml格式
[root@linux-servertwo software]# kubectl get namespaces blog-dev -o yaml
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: "2024-12-10T03:58:55Z"
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:status:
        f:phase: {}
    manager: kubectl-create
    operation: Update
    time: "2024-12-10T03:58:55Z"
  name: blog-dev
  resourceVersion: "106051"
  uid: 406d2440-b725-409f-9a01-2bf8c606e5cf
spec:
  finalizers:
  - kubernetes
status:
  phase: Active
  
# 输出一个yaml创建命名空间的格式，但不运行 
[root@linux-servertwo software]# kubectl create namespace blog-dev-1 --dry-run=client -o yaml
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: null
  name: blog-dev-1
spec: {}
status: {}

# 输出一个yaml创建命名空间的格式，但不运行 ，输出到主机blog-dev-1.yaml文件中
[root@linux-servertwo software]# kubectl create namespace blog-dev-1 --dry-run=client -o yaml &gt; blog-dev-1.yaml

#查看输出的文件信息
[root@linux-servertwo software]# ls
blog-dev-1.yaml
[root@linux-servertwo software]# cat blog-dev-1.yaml 
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: null
  name: blog-dev-1
spec: {}
status: {}
</code></pre>
<h2 id="28yaml创建">2.8、YAML创建</h2>
<pre><code class="language-sh"># 声明文件创建
[root@linux-servertwo software]# kubectl apply -f blog-dev-1.yaml 
namespace/blog-dev-1 created
[root@linux-servertwo software]# kubectl get namespaces
NAME              STATUS   AGE
blog-dev          Active   3h11m
blog-dev-1        Active   9s
default           Active   27h
kube-flannel      Active   23h
kube-node-lease   Active   27h
kube-public       Active   27h
kube-system       Active   27h
nginx             Active   37m
</code></pre>
<h2 id="29yaml删除">2.9、YAML删除</h2>
<pre><code class="language-sh"># 删除命名空间-以yml的形式
[root@linux-servertwo software]# kubectl delete -f blog-dev-1.yaml 
namespace "blog-dev-1" deleted
[root@linux-servertwo software]# kubectl get namespaces
NAME              STATUS   AGE
blog-dev          Active   3h13m
default           Active   27h
kube-flannel      Active   23h
kube-node-lease   Active   27h
kube-public       Active   27h
kube-system       Active   27h
nginx             Active   38m
</code></pre>
<h2 id="210切换命名空间">2.10、切换命名空间</h2>
<pre><code class="language-sh"># 通过设置默认命名空间，可以在运行其他命令时避免每次都加上 -n &lt;namespace-name&gt;
[root@linux-servertwo software]# kubectl config set-context --current --namespace=kube-system
Context "kubernetes-admin@kubernetes" modified.

# 查看pod
[root@linux-servertwo software]# kubectl get pods
NAME                                      READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-47d56                  1/1     Running   0          6d4h
coredns-7f89b7bc75-h4c9b                  1/1     Running   0          6d4h
etcd-linux-servertwo                      1/1     Running   0          6d4h
kube-apiserver-linux-servertwo            1/1     Running   0          6d4h
kube-controller-manager-linux-servertwo   1/1     Running   0          5d1h
kube-proxy-j7d4v                          1/1     Running   0          6d4h
kube-scheduler-linux-servertwo            1/1     Running   0          5d1h

# 查看当前使用的命名空间
[root@linux-servertwo software]# kubectl config view --minify | grep namespace:
namespace: kube-system

# 设置为默认
[root@linux-servertwo software]# kubectl config set-context --current --namespace=default
Context "kubernetes-admin@kubernetes" modified.

[root@linux-servertwo software]# kubectl config view --minify | grep namespace:
namespace: default
    
[root@linux-servertwo software]# kubectl get pods
No resources found in default namespace.
</code></pre>
<h1 id="3pod命令使用">3、Pod命令使用</h1>
<h2 id="31介绍">3.1、介绍</h2>
<p><code>Pod</code>是<code>Kubernetes</code>中可以创建和管理的最小部署单元，也是<code>Kubernetes</code>应用的基本运行单位，它封装了一个或多个容器和存储资源。<code>Pod</code>中的所有容器共享相同的网络命名空间、IP 地址、端口空间以及存储卷。通常情况下不直接管理 Pod，而是通过更高层次的抽象（如 Deployment、StatefulSet 等）来管理 Pod 的生命周期。下面就以安装<code>nginx</code>为例，单独介绍一下Pod的相关使用。</p>
<h2 id="32创建命名空间">3.2、创建命名空间</h2>
<p>首先创建好一个<code>nginx</code>的命名空间，做好数据隔离。</p>
<pre><code class="language-sh"># 创建命名空间nginx
[root@linux-servertwo software]#  kubectl create namespace nginx
namespace/nginx created

# 列出所有Pod： kubectl get pods -n &lt;namespace-name&gt;
[root@linux-servertwo software]# kubectl get pods -n nginx
No resources found in nginx namespace.
</code></pre>
<h2 id="33创建pod">3.3、创建Pod</h2>
<pre><code class="language-sh"># 创建Pod 通过Pod控制器创建Pod
# 命令格式： kubectl run (pod控制器名称) [参数] 
# --image  指定Pod的镜像
# --port   指定端口
# --namespace  指定namespace
[root@linux-servertwo nginx]# kubectl run nginx --image nginx:latest --port 80 --namespace nginx
pod/nginx created
</code></pre>
<h2 id="34查看pod信息">3.4、查看Pod信息</h2>
<pre><code class="language-sh"># 查看Pods信息
[root@linux-servertwo nginx]# kubectl get pods -n nginx
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          9m6s

# 更详细得查看pods信息
[root@linux-servertwo nginx]#  kubectl get pods -n nginx -o wide
NAME    READY   STATUS    RESTARTS   AGE   IP            NODE              NOMINATED NODE   READINESS GATES
nginx   1/1     Running   0          15m   172.17.0.68   linux-servertwo   &lt;none&gt;           &lt;none&gt;

# 查看详情Pod信息
[root@linux-servertwo nginx]# kubectl describe pods nginx -n nginx
Name:         nginx
Namespace:    nginx
Priority:     0
Node:         linux-servertwo/10.0.4.16
Start Time:   Wed, 11 Dec 2024 16:16:48 +0800
Labels:       run=nginx
Annotations:  &lt;none&gt;
Status:       Running
IP:           172.17.0.68
IPs:
  IP:  172.17.0.68

......
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  9m29s  default-scheduler  Successfully assigned nginx/nginx to linux-servertwo
  Normal  Pulling    9m28s  kubelet            Pulling image "nginx:latest"
  Normal  Pulled     8m36s  kubelet            Successfully pulled image "nginx:latest" in 52.683702042s
  Normal  Created    8m35s  kubelet            Created container nginx
  Normal  Started    8m35s  kubelet            Started container nginx
</code></pre>
<h2 id="35验证创建成功">3.5、验证创建成功</h2>
<pre><code class="language-sh"># 根据IP访问nginx，发现nginx启动成功
[root@linux-servertwo nginx]# curl 172.17.0.68:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="36删除pod">3.6、删除Pod</h2>
<pre><code class="language-sh"># 删除Pod
[root@linux-servertwo nginx]# kubectl delete pods -n nginx nginx 
pod "nginx" deleted
# 再次查看，发现已经删除
[root@linux-servertwo nginx]# kubectl get pod -n nginx
No resources found in nginx namespace.
# 上面只删除Pod，创建的命名空间还在
[root@linux-servertwo nginx]# kubectl get namespaces
NAME                   STATUS   AGE
blog-dev               Active   28h
default                Active   2d4h
kube-flannel           Active   2d
kube-node-lease        Active   2d4h
kube-public            Active   2d4h
kube-system            Active   2d4h
kubernetes-dashboard   Active   155m
nginx                  Active   26h
</code></pre>
<h2 id="37yaml创建pod">3.7、YAML创建Pod</h2>
<p>接下来使用<code>yaml</code>格式文件创建<code>nginx</code></p>
<pre><code class="language-sh"># 输出一个 nginx 的 yaml 格式 pod 到 nginx-pod.yaml 文件
[root@linux-servertwo nginx]# kubectl run nginx --image nginx:latest --port 80 --namespace nginx --dry-run=client -o yaml &gt; nginx-pod.yaml

# 查看 nginx-pod.yaml 文件
[root@linux-servertwo nginx]# cat nginx-pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
  namespace: nginx
spec:
  containers:
  - image: nginx:latest
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

# pod 声明
[root@linux-servertwo nginx]# kubectl apply -f nginx-pod.yaml 
pod/nginx created

# 查看-发现创建成功
[root@linux-servertwo nginx]# kubectl get pod nginx -n nginx
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          20s

# 查看详情
[root@linux-servertwo nginx]# kubectl describe pod nginx -n nginx
Name:         nginx
Namespace:    nginx
Priority:     0
Node:         linux-servertwo/10.0.4.16
Start Time:   Wed, 11 Dec 2024 16:42:53 +0800
Labels:       run=nginx
Annotations:  &lt;none&gt;
Status:       Running
IP:           172.17.0.69
IPs:
  IP:  172.17.0.69
  ......
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  93s   default-scheduler  Successfully assigned nginx/nginx to linux-servertwo
  Normal  Pulling    93s   kubelet            Pulling image "nginx:latest"
  Normal  Pulled     91s   kubelet            Successfully pulled image "nginx:latest" in 2.213103384s
  Normal  Created    91s   kubelet            Created container nginx
  Normal  Started    91s   kubelet            Started container nginx
</code></pre>
<h2 id="38验证是否成功">3.8、验证是否成功</h2>
<pre><code class="language-sh"># 访问
[root@linux-servertwo nginx]# curl  172.17.0.69:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="39yaml删除pod">3.9、YAML删除Pod</h2>
<pre><code class="language-sh">#删除-通过yaml方式
[root@linux-servertwo nginx]# kubectl delete  -f nginx-pod.yaml 
pod "nginx" deleted

#再次查看，发现和使用命令删除Pod一样，只删除Pod不删除namespaces
[root@linux-servertwo nginx]# kubectl get pod -n nginx
No resources found in nginx namespace.

[root@linux-servertwo nginx]# kubectl get namespaces
NAME                   STATUS   AGE
blog-dev               Active   28h
default                Active   2d5h
kube-flannel           Active   2d
kube-node-lease        Active   2d5h
kube-public            Active   2d5h
kube-system            Active   2d5h
kubernetes-dashboard   Active   168m
nginx                  Active   26h
</code></pre>
<h2 id="310查看pod日志">3.10、查看Pod日志</h2>
<pre><code class="language-sh"># 通过 kubectl logs &lt;pod-name&gt; -n &lt;namespace-name&gt; 进行查看特定命名空间中 Pod 的日志
[root@linux-servertwo software]# kubectl logs nginx -n nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2025/03/24 09:32:43 [notice] 1#1: using the "epoll" event method
2025/03/24 09:32:43 [notice] 1#1: nginx/1.27.4
2025/03/24 09:32:43 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) 
2025/03/24 09:32:43 [notice] 1#1: OS: Linux 3.10.0-1160.108.1.el7.x86_64
2025/03/24 09:32:43 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 65536:65536
2025/03/24 09:32:43 [notice] 1#1: start worker processes
2025/03/24 09:32:43 [notice] 1#1: start worker process 29
2025/03/24 09:32:43 [notice] 1#1: start worker process 30
172.17.0.1 - - [24/Mar/2025:09:33:19 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"
172.17.0.1 - - [24/Mar/2025:09:34:24 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"
172.17.0.1 - - [24/Mar/2025:09:34:26 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"

# 如果 Pod 包含多个容器，可以指定容器名称
# kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;
[root@linux-servertwo software]# kubectl logs nginx -n nginx -c nginx -f
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2025/03/24 13:01:13 [notice] 1#1: using the "epoll" event method
2025/03/24 13:01:13 [notice] 1#1: nginx/1.27.4
2025/03/24 13:01:13 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) 
2025/03/24 13:01:13 [notice] 1#1: OS: Linux 3.10.0-1160.108.1.el7.x86_64
2025/03/24 13:01:13 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 65536:65536
2025/03/24 13:01:13 [notice] 1#1: start worker processes
2025/03/24 13:01:13 [notice] 1#1: start worker process 29
2025/03/24 13:01:13 [notice] 1#1: start worker process 30
172.17.0.1 - - [24/Mar/2025:13:01:40 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"
172.17.0.1 - - [24/Mar/2025:13:03:47 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"
172.17.0.1 - - [25/Mar/2025:02:24:58 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.29.0" "-"

</code></pre>
<h2 id="311进入容器">3.11、进入容器</h2>
<pre><code class="language-sh">#  进入Pod容器：kubectl exec -it &lt;pod-name&gt; -- /bin/bash
[root@linux-servertwo software]# kubectl exec -it nginx -n nginx  -- /bin/bash
root@nginx:/# ls
bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@nginx:/# nginx -V      
nginx version: nginx/1.27.4
built by gcc 12.2.0 (Debian 12.2.0-14) 
built with OpenSSL 3.0.11 19 Sep 2023 (running with OpenSSL 3.0.15 3 Sep 2024)
TLS SNI support enabled
configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_v3_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -ffile-prefix-map=/data/builder/debuild/nginx-1.27.4/debian/debuild-base/nginx-1.27.4=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'
root@nginx:/# 


# 如果 Pod 中有多个容器，可以通过 -c 参数指定容器：kubectl exec -it &lt;pod-name&gt; -c &lt;container-name&gt; -- /bin/bash
[root@linux-servertwo software]# kubectl exec -it nginx -c nginx  -n nginx -- /bin/bash
root@nginx:/# ls
bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@nginx:/# 

</code></pre>
<h2 id="312查看-pod-关联的事件">3.12、查看 Pod 关联的事件</h2>
<pre><code class="language-sh"># 查看与 Pod 相关的事件，了解 Pod 的运行状态以及错误信息：
[root@linux-servertwo software]# kubectl get events --field-selector involvedObject.name=nginx -n nginx
LAST SEEN   TYPE     REASON      OBJECT      MESSAGE
5m42s       Normal   Scheduled   pod/nginx   Successfully assigned nginx/nginx to linux-servertwo
5m42s       Normal   Pulling     pod/nginx   Pulling image "nginx:latest"
5m32s       Normal   Pulled      pod/nginx   Successfully pulled image "nginx:latest" in 9.177513284s
5m32s       Normal   Created     pod/nginx   Created container nginx
5m32s       Normal   Started     pod/nginx   Started container nginx
</code></pre>
<h2 id="313pod-的扩展和缩容">3.13、Pod 的扩展和缩容</h2>
<p>直接修改 Pod 数量需要使用副本集（ReplicaSet）或部署（Deployment）来管理。例如，使用以下命令扩展或缩容 Pod 副本数：</p>
<pre><code class="language-sh"># kubectl scale --replicas=&lt;num&gt; deployment/&lt;deployment-name&gt;
kubectl scale --replicas=3 deployment/my-app-nginx
</code></pre>
<p>在 Kubernetes 中，Pod 的扩展和缩容通常是通过它们的资源来管理的。<code>Deployment</code> 允许定义多个副本（Pod 实例），并可以根据需要进行扩展和缩容。<code>Deployment</code> 会自动管理 Pod 的生命周期和状态，包括在需要时扩展和缩容 Pod 数量。下面就来介绍<code>Deployment</code> 的相关使用命令。</p>
<h1 id="4deployment命令使用">4、Deployment命令使用</h1>
<h2 id="41介绍">4.1、介绍</h2>
<p>在<code> Kubernetes</code>中，<code>Pod</code> 是最小的调度和管理单元，但<code>Kubernetes</code>很少直接操作单个 <code>Pod</code>。通常，<code>Kubernetes</code>是通过 <strong>Pod 控制器</strong> 来间接管理 <code>Pod</code>，实现对 Pod 的控制与维护，确保 <code>Pod</code> 的状态始终符合预期。这些控制器负责自动化创建、调度、更新和扩展 <code>Pod</code>，并确保其高可用性和健康。当 <code>Pod</code> 发生故障或失效时，控制器会自动执行恢复操作，如重启或重新创建 <code>Pod</code>，以确保应用的连续性和稳定性。<code>Kubernetes</code>中常见的 <strong>Pod控制器</strong> 包括 <strong>Deployment</strong>、<strong>ReplicaSet</strong>、<strong>StatefulSet</strong>、<strong>DaemonSet</strong>、<strong>Job</strong> 和 <strong>CronJob</strong>，它们各自负责不同的用例和场景，提供了灵活的管理方式，满足不同的需求场景。通过这些控制器，<code>Kubernetes</code>实现了强大的自愈能力、扩展性和灵活性，使得容器化应用的管理更加高效、可靠。下面介绍其中一个 <strong>Pod控制器</strong> ：<code>Deployment</code></p>
<h2 id="42创建-deployment">4.2、创建 Deployment</h2>
<p>可以通过 <code>kubectl create</code> 或 <code>kubectl apply</code> 命令来创建 Deployment</p>
<pre><code class="language-sh"># 创建deployment控制器
# 命令格式: 
#    kubectl create deployment 名称  [参数] 
# 参数：
#    -n/--namespace  指定创建的所属命名空间
#    --image  指定pod的镜像
#    --port   指定端口
#    --replicas 指定创建pod数量  --replicas=3：指定该 Deployment 创建的 Pod 副本数量为 3，
# 该命令表示 Kubernetes 将确保始终有 3 个运行中的 nginx Pod 实例来提供服务，实现高可用性和负载均衡
[root@linux-servertwo software]# kubectl create deployment nginx -n nginx --image nginx:latest --port 80 --replicas=3
deployment.apps/nginx created

# 查看命名空间下面的Pod
[root@linux-servertwo nginx]# kubectl get pods -n nginx
NAME                    READY   STATUS    RESTARTS   AGE
nginx-585449566-6788b   1/1     Running   0          39s
nginx-585449566-bhbtp   1/1     Running   0          39s
nginx-585449566-gk2kl   1/1     Running   0          39s
</code></pre>
<h2 id="43查看-deployment">4.3、查看 Deployment</h2>
<pre><code class="language-sh"># 查看deployment状态
[root@linux-servertwo nginx]# kubectl get deployment -n nginx
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   3/3     3            3           88s

# 查看某一个 Deployment 信息 kubectl get deployment &lt;deployment-name&gt; &lt;namespaces&gt;
[root@linux-servertwo software]# kubectl get deployment nginx -n nginx
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   3/3     3            3           25m

# 查看 Deployment 的 YAML 配置
[root@linux-servertwo software]# kubectl get deployment nginx -n nginx -o yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "1"
  generation: 1
  labels:
    app: nginx
......
status:
  availableReplicas: 3
  conditions:
  - lastTransitionTime: "2025-03-25T07:38:18Z"
    lastUpdateTime: "2025-03-25T07:38:18Z"
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: "True"
    type: Available
  - lastTransitionTime: "2025-03-25T07:38:14Z"
    lastUpdateTime: "2025-03-25T07:38:18Z"
    message: ReplicaSet "nginx-585449566" has successfully progressed.
    reason: NewReplicaSetAvailable
    status: "True"
    type: Progressing
  observedGeneration: 1
  readyReplicas: 3
  replicas: 3
  updatedReplicas: 3



# 更详细得查看deployment信息 UP-TO-DATE：成功升级的副本数量， AVAILABLE：可用副本的数量
[root@linux-servertwo nginx]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR
nginx   3/3     3            3           4m56s   nginx        nginx:latest   app=nginx

# 查看deployment详情
[root@linux-servertwo nginx]# kubectl describe deployment -n nginx
Name:                   nginx
Namespace:              nginx
CreationTimestamp:      Fri, 13 Dec 2024 10:26:15 +0800
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:latest
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-585449566 (3/3 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  3m9s  deployment-controller  Scaled up replica set nginx-585449566 to 3

</code></pre>
<h2 id="44验证访问">4.4、验证访问</h2>
<pre><code class="language-sh"># 查看每一个nginx启动的容器IP
[root@linux-servertwo nginx]# kubectl get pod -n nginx -o wide
NAME                    READY   STATUS    RESTARTS   AGE     IP            NODE              NOMINATED NODE   READINESS GATES
nginx-585449566-6788b   1/1     Running   0          9m33s   172.17.0.71   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-bhbtp   1/1     Running   0          9m33s   172.17.0.72   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-gk2kl   1/1     Running   0          9m33s   172.17.0.73   linux-servertwo   &lt;none&gt;           &lt;none&gt;

# 通过IP尝试访问 172.17.0.71
[root@linux-servertwo nginx]# curl 172.17.0.71
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
# 通过IP尝试访问 172.17.0.72
[root@linux-servertwo nginx]# curl 172.17.0.72
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

#  通过IP尝试访问 172.17.0.73
[root@linux-servertwo nginx]# curl 172.17.0.73
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="45进入容器">4.5、进入容器</h2>
<pre><code class="language-sh"># 进入其中一个POD的容器内部
[root@linux-servertwo nginx]# kubectl exec -it -n nginx nginx-585449566-6788b /bin/bash
kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.
root@nginx-585449566-6788b:/# 
# 上面命令提示已经准备弃用，使用新命令进入 需要加 --
[root@linux-servertwo nginx]# kubectl exec -it -n nginx nginx-585449566-6788b -- /bin/bash
root@nginx-585449566-6788b:/# nginx -v
nginx version: nginx/1.27.3
</code></pre>
<h2 id="46更新-deployment">4.6、更新 Deployment</h2>
<p>更新 Deployment 可以通过 <code>kubectl set</code> 或 <code>kubectl apply</code> 实现</p>
<pre><code class="language-sh"># 将上面部署的 nginx 的 deployment 的容器镜像更新为 nginx:1.19.0
# kubectl set image deployment/&lt;deployment-name&gt; &lt;container-name&gt;=&lt;new-image&gt;
[root@linux-servertwo software]# kubectl set image deployment/nginx nginx=nginx:1.19 -n nginx
deployment.apps/nginx image updated

# 查看是否更新-查看信息发现更新成功
[root@linux-servertwo software]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES       SELECTOR
nginx   3/3     3            3           40m   nginx        nginx:1.19   app=nginx

# 进入其中一个POD的容器内部 查看nginx版本
[root@linux-servertwo software]# kubectl exec -it -n nginx nginx-5479877cb4-2lpwv  -- /bin/bash
root@nginx-5479877cb4-2lpwv:/# nginx -v
nginx version: nginx/1.19.10
</code></pre>
<h2 id="47查看和管理-deployment-版本">4.7、查看和管理 Deployment 版本</h2>
<pre><code class="language-sh"># 查看 Deployment 的历史版本
[root@linux-servertwo software]# kubectl rollout history deployment/nginx -n nginx
deployment.apps/nginx 
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         &lt;none&gt;
# 变更记录，REVISION 1: 初始部署的版本，REVISION 2: 更新后的版本，CHANGE-CAUSE: 每个修订版本的变更原因或描述。当前两个版本的 CHANGE-CAUSE 都为空。
# 这可以通过在 kubectl set image 命令中添加 --record 参数来实现，每次更新时提供 CHANGE-CAUSE 信息
# --record 参数会将命令记录到 Deployment 的变更历史中，方便后续查看和回滚。
# 如以上更新命令加上参数 kubectl set image deployment/nginx nginx=nginx:1.19 -n nginx --record


# 查看 Deployment 的滚动更新状态
[root@linux-servertwo software]# kubectl rollout status deployment/nginx -n nginx
deployment "nginx" successfully rolled out
# 输出以上信息，表示 nginx Deployment 的滚动更新已经成功完成
</code></pre>
<h2 id="48回滚-deployment-版本">4.8、回滚 Deployment 版本</h2>
<p>如果更新后的应用出现问题，可以通过回滚命令恢复到先前的版本。</p>
<pre><code class="language-sh"># 回滚到上一个版本：kubectl rollout undo deployment/&lt;deployment-name&gt;
[root@linux-servertwo software]# kubectl rollout undo deployment/nginx -n nginx
deployment.apps/nginx rolled back

# 查看是否回滚成功
[root@linux-servertwo software]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
nginx   3/3     3            3           68m   nginx        nginx:latest   app=nginx
# 可以发现nginx版本已经变为部署时候的最新版本。

# 回滚到某个特定版本：kubectl rollout undo deployment/&lt;deployment-name&gt; --to-revision=&lt;revision-number&gt;
[root@linux-servertwo software]# kubectl rollout undo deployment/nginx  -n nginx --to-revision=2
deployment.apps/nginx rolled back

# 查看是否回滚成功
[root@linux-servertwo software]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES       SELECTOR
nginx   3/3     3            3           75m   nginx        nginx:1.19   app=nginx
# 发现又回到了更新之后的版本。
</code></pre>
<h2 id="49暂停和恢复-deployment">4.9、暂停和恢复 Deployment</h2>
<pre><code class="language-sh"># 暂停正在进行的更新操作：kubectl rollout pause deployment/&lt;deployment-name&gt;
[root@linux-servertwo software]# kubectl rollout pause deployment/nginx -n nginx
deployment.apps/nginx paused


# 恢复暂停的更新操作：kubectl rollout resume deployment/&lt;deployment-name&gt;
[root@linux-servertwo software]# kubectl rollout resume deployment/nginx -n nginx
deployment.apps/nginx resumed
</code></pre>
<h2 id="410删除-deployment">4.10、删除 Deployment</h2>
<pre><code class="language-sh"># 删除某个 Deployment：kubectl delete deployment &lt;deployment-name&gt;
[root@linux-servertwo software]# kubectl delete deployment nginx -n nginx
deployment.apps "nginx" deleted
# 再次查看deployment发现已经删除
[root@linux-servertwo software]#  kubectl get deployment -n nginx
No resources found in nginx namespace.
# 删除 deployment后，Pod也自动删除了
[root@linux-servertwo software]# kubectl get pod -n nginx
No resources found in nginx namespace.
</code></pre>
<h2 id="411yaml创建">4.11、YAML创建</h2>
<pre><code class="language-sh"># 输出一个yaml创建nginx的Deployment格式文件，但不运行 ，输出到主机nginx-deployment.yml文件中
[root@linux-servertwo software]# kubectl create deployment nginx -n nginx --image nginx:latest --port 80 --replicas=3 --dry-run=client -o yaml &gt; nginx-deployment.yml

# 输出成功后，查看输出的yml文件
[root@linux-servertwo software]# cat nginx-deployment.yml 
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: nginx
  name: nginx
  namespace: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx
    spec:
      containers:
      - image: nginx:latest
        name: nginx
        ports:
        - containerPort: 80
        resources: {}
status: {}

# 运行nginx的YML文件
[root@linux-servertwo software]# kubectl apply -f nginx-deployment.yml 
deployment.apps/nginx created

# 查看是否创建成功
[root@linux-servertwo software]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR
nginx   3/3     3            3           2m29s   nginx        nginx:latest   app=nginx

# 查看运行的Pod
[root@linux-servertwo software]# kubectl get pod -n nginx -o wide
NAME                    READY   STATUS    RESTARTS   AGE     IP            NODE              NOMINATED NODE   READINESS GATES
nginx-585449566-46b9w   1/1     Running   0          5m31s   172.17.0.21   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-lcmlp   1/1     Running   0          5m31s   172.17.0.22   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-x6rcl   1/1     Running   0          5m31s   172.17.0.20   linux-servertwo   &lt;none&gt;           &lt;none&gt;
</code></pre>
<h2 id="412yaml删除">4.12、YAML删除</h2>
<pre><code class="language-sh"># 通过  kubectl delete 命令进行删除，删除 Deployment 会自动删除与之关联的所有 Pod。
[root@linux-servertwo software]# kubectl delete -f nginx-deployment.yml
deployment.apps "nginx" deleted

# 查看Deployment
[root@linux-servertwo software]#  kubectl get deployment -n nginx
No resources found in nginx namespace.

# 查看Pod
[root@linux-servertwo software]# kubectl get pod -n nginx
No resources found in nginx namespace.
</code></pre>
<h2 id="413删除指定pod">4.13、删除指定Pod</h2>
<pre><code class="language-sh"># 如果只需要删除其中一个Pod，而不删除Deployment，执行删除Pod的命令即可 
[root@linux-servertwo nginx]# kubectl delete pods -n nginx nginx-585449566-lcmlp
pod "nginx-585449566-lcmlp" deleted
# 删除其中一个后，Deployment 会根据其配置，在自动创建一个新的 Pod 来保持所需的副本数量

# 再次查看运行的Pod，发现还是保持3个副本数量，但是Ip地址已经更新了。
[root@linux-servertwo software]# kubectl get pod -n nginx -o wide
NAME                    READY   STATUS    RESTARTS   AGE   IP            NODE              NOMINATED NODE   READINESS GATES
nginx-585449566-46b9w   1/1     Running   0          5m31s 172.17.0.21   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-krqsh   1/1     Running   0          14s   172.17.0.26   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-x6rcl   1/1     Running   0          5m31s 172.17.0.20   linux-servertwo   &lt;none&gt;           &lt;none&gt;
</code></pre>
<h1 id="5service命令使用">5、Service命令使用</h1>
<h2 id="51介绍">5.1、介绍</h2>
<p><code>Service</code> 是 <code>Kubernetes</code>一种资源类型，它主要定义了一组<code>Pod</code>的访问策略，并为这些<code>Pod</code>提供一个稳定的固定网络地址，而无需了解这些<code>Pod</code>的具体 IP 地址。<code>Service</code> 主要用于将一组 Pod 暴露给集群内的其他服务或外部用户，使其可以通过网络与其他应用程序之间提供一个更加可靠和灵活的通信。</p>
<h2 id="52创建-service">5.2、创建 Service</h2>
<p>首先执行<code>nginx-deployment.yml</code> 文件创建一个Deployment的nginx服务，</p>
<pre><code class="language-sh"># 创建 Deployment nginx
[root@linux-servertwo software]# kubectl apply -f nginx-deployment.yml 
deployment.apps/nginx created

# 查看是否启动成功
[root@linux-servertwo software]# kubectl get deployment -n nginx -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
nginx   3/3     3            3           33s   nginx        nginx:latest   app=nginx
[root@linux-servertwo software]# kubectl get pod -n nginx -o wide
NAME                    READY   STATUS    RESTARTS   AGE   IP            NODE              NOMINATED NODE   READINESS GATES
nginx-585449566-5lxwx   1/1     Running   0          40s   172.17.0.29   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-l9wvw   1/1     Running   0          40s   172.17.0.28   linux-servertwo   &lt;none&gt;           &lt;none&gt;
nginx-585449566-lfjgc   1/1     Running   0          40s   172.17.0.27   linux-servertwo   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>然后在进入每一个Pod的Nginx容器内部，配置一下html页面信息，方便后面查看</p>
<pre><code class="language-sh"># 进入 nginx-585449566-5lxwx 容器内部
[root@linux-servertwo nginx]# kubectl exec -it -n nginx nginx-585449566-5lxwx -- bash
root@nginx-585449566-6788b:/# echo this is 172.17.0.29 nginx &gt; /usr/share/nginx/html/index.html 
root@nginx-585449566-6788b:/# cat /usr/share/nginx/html/index.html 
this is 172.17.0.29 nginx
# 进入 nginx-585449566-l9wvw 容器内部
[root@linux-servertwo nginx]# kubectl exec -it -n nginx nginx-585449566-l9wvw -- bash
root@nginx-585449566-bhbtp:/# echo this is 172.17.0.28 nginx &gt; /usr/share/nginx/html/index.html
root@nginx-585449566-bhbtp:/#  cat /usr/share/nginx/html/index.html
this is 172.17.0.28 nginx
# 进入 nginx-585449566-lfjgc 容器内部
[root@linux-servertwo nginx]# kubectl exec -it -n nginx nginx-585449566-lfjgc -- bash
root@nginx-585449566-gk2kl:/# echo this is 172.17.0.27 nginx &gt; /usr/share/nginx/html/index.html
root@nginx-585449566-gk2kl:/# cat /usr/share/nginx/html/index.html 
this is 172.17.0.27 nginx

# 验证访问
[root@linux-servertwo software]# curl 172.17.0.29
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl 172.17.0.28
this is 172.17.0.28 nginx
[root@linux-servertwo software]# curl 172.17.0.27
this is 172.17.0.27 nginx
</code></pre>
<p>接下来就可以创建一个集群内部可访问的<code>Service</code>了</p>
<pre><code class="language-sh"># 通过以下命令创建一个内部的Service服务访问Pods
# kubectl expose pod &lt;pod-name&gt; --name=&lt;service-name&gt; --port=&lt;port&gt; --target-port=&lt;target-port&gt; --type=&lt;service-type&gt;
[root@linux-servertwo nginx]# kubectl expose deployment -n nginx nginx --name=svc-nginx --type=ClusterIP --port=80 --target-port=80
service/svc-nginx exposed

# type 类型：
#  ClusterIP：默认类型，服务只在集群内部可访问。
#  NodePort：在每个 Node 上打开一个端口，并通过该端口暴露服务。
#  LoadBalancer：使用云服务提供商的负载均衡器来暴露服务，通常适用于云环境。
#  ExternalName：通过 DNS 名称将外部服务映射到 Kubernetes 集群中的服务，适用于需要访问集群外部服务的情况。
</code></pre>
<h2 id="53查看-service">5.3、查看 Service</h2>
<pre><code class="language-sh"># 查看创建的Service
[root@linux-servertwo software]# kubectl get service -n nginx
NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
svc-nginx   ClusterIP   172.16.251.156   &lt;none&gt;        80/TCP    19s

# 查看更充分的Service
[root@linux-servertwo software]#  kubectl get service -n nginx -o wide
NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE   SELECTOR
svc-nginx   ClusterIP   172.16.251.156   &lt;none&gt;        80/TCP    56s   app=nginx
# ClusterIP 此类型只允许集群内访问，这里生成了一个CLUSTER-IP的IP，这就是service的IP。在Service的生命周期中，这个地址是不会变动的，可以通过这个IP访问当前service对应的Pod

# 详情查看 kubectl describe service &lt;service-name&gt;
[root@linux-servertwo software]# kubectl describe service svc-nginx -n nginx
Name:              svc-nginx
Namespace:         nginx
Labels:            app=nginx
Annotations:       &lt;none&gt;
Selector:          app=nginx
Type:              ClusterIP
IP Families:       &lt;none&gt;
IP:                172.16.251.156
IPs:               172.16.251.156
Port:              &lt;unset&gt;  80/TCP
TargetPort:        80/TCP
Endpoints:         172.17.0.27:80,172.17.0.28:80,172.17.0.29:80
Session Affinity:  None
Events:            &lt;none&gt;

# 查看 Endpoint 信息-存储了Service对应的Pod的实际IP地址和端口信息
[root@linux-servertwo software]#  kubectl get endpoints -n nginx svc-nginx
NAME        ENDPOINTS                                      AGE
svc-nginx   172.17.0.27:80,172.17.0.28:80,172.17.0.29:80   42m

</code></pre>
<h2 id="54验证访问">5.4、验证访问</h2>
<p>通过访问<code>CLUSTER-IP</code>对应的<code>IP </code>进行测试</p>
<pre><code class="language-sh">[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.28 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.27 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.28 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.27 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.27 nginx
[root@linux-servertwo software]# curl 172.16.251.156
this is 172.17.0.29 nginx
</code></pre>
<p>通过以上的多次访问，可以看到 Service IP 会随机将请求转发到其中一个 Pod 上的 Nginx 中，这表明内部实现了负载均衡。这个负载均衡通过 kube-proxy  在第四层（传输层）完成的，适用于 TCP 和 UDP 流量。无论是 ClusterIP 还是 NodePort 类型的 Service，kube-proxy 都会在集群内部创建路由规则，将请求转发到后端的 Pod。当客户端请求发送到 Service 的 Cluster IP 地址时，kube-proxy 会把请求转发到一个或多个 Pod。由于这种负载均衡是在第四层（传输层）进行的， 因此不需要理解更高层次的应用协议。</p>
<h2 id="55kube-proxy-实现负载均衡介绍">5.5、kube-proxy 实现负载均衡介绍</h2>
<p>在 Kubernetes 中，kube-proxy 使用 iptables 规则来实现 Service 的负载均衡。通过查看 iptables 规则，可以了解访问 Service 的 Cluster IP 地址时的具体链路规则。以下是具体步骤和示例：</p>
<pre><code class="language-sh"># 查看 iptables 规则 
# iptables-save | grep KUBE 或者 iptables -L -t nat | grep KUBE
[root@linux-servertwo software]# iptables -L -t nat | grep KUBE

# 只截取部署nginx的重要部分进行说明
# 通过注释可以查看 /* nginx/svc-nginx */  表明这是与 nginx/svc-nginx 服务相关的流量 
Chain KUBE-SEP-MEC45OHITDUK5UCI (1 references)
KUBE-MARK-MASQ  all  --  172.17.0.27          anywhere             /* nginx/svc-nginx */
Chain KUBE-SEP-OVGUVNLN5SZ5SJPC (1 references)
KUBE-MARK-MASQ  all  --  172.17.0.28          anywhere             /* nginx/svc-nginx */
Chain KUBE-SEP-Q7FC6ND2772R7A3Y (1 references)
KUBE-MARK-MASQ  all  --  172.17.0.29          anywhere             /* nginx/svc-nginx */

# KUBE-SERVICES 链是 Kubernetes 服务暴露的入口。它是 Kubernetes 网络代理（kube-proxy）实现负载均衡的地方，可以看到IP:172.16.251.156 就是创建的nginx service的IP
Chain KUBE-SERVICES (2 references)
KUBE-MARK-MASQ  tcp  -- !linux-servertwo/16   172.16.251.156       /* nginx/svc-nginx cluster IP */ tcp dpt:http
KUBE-SVC-XDC2TBTFGP42ST2T  tcp  --  anywhere             172.16.251.156       /* nginx/svc-nginx cluster IP */ tcp dpt:http

# 通过下面可以看出，使用了 加权随机负载均衡
KUBE-SEP-MEC45OHITDUK5UCI  all  --  anywhere             anywhere             /* nginx/svc-nginx */ statistic mode random probability 0.33333333349
KUBE-SEP-OVGUVNLN5SZ5SJPC  all  --  anywhere             anywhere             /* nginx/svc-nginx */ statistic mode random probability 0.50000000000
KUBE-SEP-Q7FC6ND2772R7A3Y  all  --  anywhere             anywhere             /* nginx/svc-nginx */
# statistic mode random 是一种概率机制，表示 Kubernetes 根据给定的概率将流量随机地发送到指定的 Pod。这里的概率是：
# 33% 的流量会被转发到 MEC45OHITDUK5UCI 这个 Pod。
# 50% 的流量会被转发到 OVGUVNLN5SZ5SJPC 这个 Pod。
#  剩余的流量会被转发到 Q7FC6ND2772R7A3Y 这个 Pod。
#  结合这些规则，Kubernetes 通过随机概率来实现加权负载均衡，确保流量按照一定的比例（33%、50%）分发到不同的后端 Pod。这样的方式可以根据服务负载或者其他策略调整流量分配比例。
</code></pre>
<h2 id="56创建外部可访问的service">5.6、创建外部可访问的Service</h2>
<p>想要创建集群外部也可访问的Service ，只需要在创建 service 指定<code>--type=</code> 的类型为 <strong>NodePord 类型</strong> 即可。</p>
<pre><code class="language-sh"># 查看 Service
[root@linux-servertwo software]# kubectl get service -n nginx -o wide
NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE    SELECTOR
svc-nginx   ClusterIP   172.16.251.156   &lt;none&gt;        80/TCP    169m   app=nginx


# 删除原先的 ClusterIP 类型的服务
[root@linux-servertwo software]# kubectl delete service -n nginx svc-nginx
service "svc-nginx" deleted

# 再次查看，发现已经删除
[root@linux-servertwo software]#  kubectl get service -n nginx
No resources found in nginx namespace.

# 创建NodePord类型的服务
[root@linux-servertwo software]# kubectl expose deployment -n nginx nginx --name=svc-nginx --type=NodePort --port=80 --target-port=80
service/svc-nginx exposed

# 查看是否创建成功
[root@linux-servertwo software]#  kubectl get service -n nginx
NAME        TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
svc-nginx   NodePort   172.16.237.241   &lt;none&gt;        80:31918/TCP   17s
# 通过以上输出可以发现PORT(S) 属性80端口映射到31918端口了， 然后就可以通过访问31918端口在外部访问 nginx 了，访问主机IP+指定端口号31918就可以访问的随机一个 Pod 的 Nginx。使用宿主机访问31918端口：
[root@linux-servertwo software]# curl localhost:31918
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl localhost:31918
this is 172.17.0.28 nginx
[root@linux-servertwo software]# curl localhost:31918
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl localhost:31918
this is 172.17.0.27 nginx
# 所以，如果是集群内部访问，可以通过 172.16.237.241:80 访问 svc-nginx。如果是集群外部访问，使用节点的 IP 地址和端口 31918 访问 svc-nginx
</code></pre>
<h2 id="57删除-service">5.7、删除 Service</h2>
<pre><code class="language-sh"># 通过 kubectl delete service  &lt;service-name&gt; 进行删除
[root@linux-servertwo software]# kubectl delete service -n nginx svc-nginx
service "svc-nginx" deleted

# 再次查看发现已经删除
[root@linux-servertwo software]#  kubectl get service -n nginx
No resources found in nginx namespace.
</code></pre>
<h2 id="58yaml创建">5.8、YAML创建</h2>
<pre><code class="language-sh"># 输出一个 yaml 创建 nginx 的 Service 格式文件但不运行，输出到主机nginx-service.yml文件中
[root@linux-servertwo software]# kubectl expose deployment -n nginx nginx --name=svc-nginx --type=NodePort --port=80 --target-port=80 --dry-run=client -o yaml &gt; nginx-service.yml

# 输出成功后，查看输出的yml文件
[root@linux-servertwo software]# cat nginx-service.yml 
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: nginx
  name: svc-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  type: NodePort
status:
  loadBalancer: {}

# 在使用kubectl expose命令生成Service的YAML文件时，生成的YAML文件默认不会包含命名空间信息，需要手动在生成的YAML文件中添加命名空间。
# 编辑 nginx-service.yml 文件，添加需要创建的命名空间后，再次查看
[root@linux-servertwo software]# cat nginx-service.yml 
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: nginx
  name: svc-nginx
  namespace: nginx  # 添加命名空间信息
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  type: NodePort
status:
  loadBalancer: {}

  
# 运行nginx的YML文件
[root@linux-servertwo software]# kubectl apply -f nginx-service.yml 
service/svc-nginx created


# 查看是否创建成功
[root@linux-servertwo software]# kubectl get service -n nginx
NAME        TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
svc-nginx   NodePort   172.16.87.14   &lt;none&gt;        80:30501/TCP   17s

# 验证访问
# 访问内部IP+端口
[root@linux-servertwo software]# curl 172.16.87.14
this is 172.17.0.28 nginx
[root@linux-servertwo software]# curl 172.16.87.14
this is 172.17.0.29 nginx
[root@linux-servertwo software]# curl 172.16.87.14
this is 172.17.0.28 nginx
# 访问主机节点IP+端口
[root@linux-servertwo software]# curl localhost:30501
this is 172.17.0.27 nginx
[root@linux-servertwo software]# curl localhost:30501
this is 172.17.0.28 nginx
</code></pre>
<h2 id="59yaml删除">5.9、YAML删除</h2>
<pre><code class="language-sh"># 删除
[root@linux-servertwo software]# kubectl delete -f nginx-service.yml 
service "svc-nginx" deleted

# 再次查看
[root@linux-servertwo software]# kubectl get service -n nginx
No resources found in nginx namespace.
</code></pre>
<h1 id="6ipvs配置">6、ipvs配置</h1>
<p><code>kube-proxy </code>支持多种模式来实现这种负载均衡，包括：</p>
<p><strong><code>iptables </code>模式</strong>：这是默认的模式，<code>kube-proxy </code>使用 <code>iptables </code>规则来实现 Service 到 Pod 的负载均衡。<br>
<strong><code>ipvs </code>模式</strong>：从<code>Kubernetes 1.8</code>开始支持，使用<code> IPVS（IP Virtual Server）</code>代替<code>iptables</code>来实现负载均衡，<code>IPVS</code> 通常被认为比<code>iptables</code>更高效，尤其是在高并发场景下。</p>
<pre><code class="language-sh"># 查看所有 iptables规则
iptables -t nat -nL | iptables -L -v -n

# k8s开启ipvs,首先查看，发现没有该命令
[root@linux-servertwo software]# ipvsadm -ln
-bash: ipvsadm: command not found

# 安装 ipvsadm 工具
yum install ipvsadm -y
# 再次执行
[root@linux-servertwo software]#  ipvsadm -ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
  
# 查看加载内核模快是否加载ipvs
[root@linux-servertwo software]# lsmod | grep ip_vs
ip_vs_sh               12688  0 
ip_vs_wrr              12697  0 
ip_vs_rr               12600  0 
ip_vs                 145458  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr
nf_conntrack          143411  7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4
libcrc32c              12644  3 ip_vs,nf_nat,nf_conntrack

# 由于kube-proxy默认是通过iptables来进行转发的，需要将iptables转换为ipvs（提高性能）
[root@linux-servertwo software]# kubectl  edit -n kube-system  configmaps kube-proxy
# 默认为空,加上 ipvs 修改成功后保存
mode: "" -&gt; mode: "ipvs" 

# 查看系统运行的Pod
[root@linux-servertwo software]# kubectl get pod -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-47d56                  1/1     Running   0          8d
coredns-7f89b7bc75-h4c9b                  1/1     Running   0          8d
etcd-linux-servertwo                      1/1     Running   0          8d
kube-apiserver-linux-servertwo            1/1     Running   0          8d
kube-controller-manager-linux-servertwo   1/1     Running   0          7d
kube-proxy-j7d4v                          1/1     Running   0          8d
kube-scheduler-linux-servertwo            1/1     Running   0          7d

# 删除包含 kube-proxy的Pod
[root@linux-servertwo software]#  kubectl delete pod -n kube-system kube-proxy-j7d4v
pod "kube-proxy-j7d4v" deleted


# 删除成功后，再次查看，发现会重新创建一个新的 kube-proxy 的pod
[root@linux-servertwo software]# kubectl get pod -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-47d56                  1/1     Running   0          8d
coredns-7f89b7bc75-h4c9b                  1/1     Running   0          8d
etcd-linux-servertwo                      1/1     Running   0          8d
kube-apiserver-linux-servertwo            1/1     Running   0          8d
kube-controller-manager-linux-servertwo   1/1     Running   0          7d
kube-proxy-wbst6                          1/1     Running   0          16s
kube-scheduler-linux-servertwo            1/1     Running   0          7d


#重新查看-列出所有
[root@linux-servertwo nginx]# ipvsadm -ln
# 条件筛选
[root@linux-servertwo software]# ipvsadm -ln | grep -A 3 "127.0.0.1:30501"
TCP  127.0.0.1:30501 rr
  -&gt; 172.17.0.27:80               Masq    1      0          0         
  -&gt; 172.17.0.28:80               Masq    1      0          0         
  -&gt; 172.17.0.29:80               Masq    1      0          0   
# 输出以上信息，说明使用ipvs负载均衡成功
</code></pre>
<h1 id="7实践-部署nginx">7、实践-部署nginx</h1>
<h2 id="71描述">7.1、描述</h2>
<p>通过以上的命令介绍，已经会使用K8s部署一个简单的应用了，接下来就来通过使用<strong>Deployment+NodePort的模式</strong> 安装部署一个高可用的<code>Nginx服务</code>。</p>
<h2 id="72创建yml">7.2、创建YML</h2>
<p>创建一个 <code>ingress-nginx.yml</code> 文件，配置<code>Nginx</code>的部署信息</p>
<pre><code class="language-sh"># 1、创建 Namespace
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: null
  name: nginx-proxy
spec: {}
status: {}
---
# 2、创建 Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: nginx-proxy
  name: nginx-proxy
  namespace: nginx-proxy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-proxy
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx-proxy
    spec:
      #hostNetwork: true 使用宿主机的网络接口
      nodeSelector:
        beta.kubernetes.io/os: linux
      priorityClassName: system-node-critical
      containers:
      - image: nginx:1.23.1
        name: nginx
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
        resources: 
          limits:
            cpu: 300m
            memory: 512M
          requests:
            cpu: 25m
            memory: 32M
        volumeMounts:
        - name: conf
          mountPath: /etc/nginx/nginx.conf
          readOnly: true     
      volumes:
      - name: conf
        hostPath:
          path: /opt/software/k8s-deployment/nginx/conf/nginx.conf         
status: {}
---
# 3、创建 Service
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: nginx-proxy
  name: svc-nginx
  namespace: nginx-proxy 
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 31001
  selector:
    app: nginx-proxy
  type: NodePort
status:
  loadBalancer: {}
</code></pre>
<p>参数配置说明：</p>
<p><strong>分隔符</strong></p>
<pre><code class="language-sh">--- 分隔符是 Kubernetes YAML 文件中的标准语法，用于区分同一文件中的多个资源定义，使得一个文件可以包含多个资源对象。Deployment、Service 和 Namespace 是三个不同的 Kubernetes 资源定义,因此需要使用 --- 进行分隔。通过将多个资源定义写在一个 YAML 文件中，并用 --- 分隔，kubectl apply 可以一次性创建或更新多个资源，而不需要分别写多个文件或执行多次命令。
</code></pre>
<p><strong>Namespace 配置说明：</strong></p>
<pre><code class="language-yaml"># kind：Namespace 表示yaml文件创建的是命名空间
# metadata 表示命名空间的元信息
# metadata.name 是命名空间的名称 取值nginx
# metadata.labels 是命名空间的标签 name=nginx
</code></pre>
<p><strong>Deployment 配置说明</strong></p>
<pre><code class="language-properties">hostNetwork: true # 使用宿主机的网络接口

priorityClassName: system-node-critical # 用来设置Pod优先级，确保其在集群中具有较高的优先权。
# 关于 priorityClassName 优先级说明
# Kubernetes 默认提供了以下几种优先级类：
#   system-node-critical：关键节点服务，优先级最高。 主要作用：Pod 会在资源紧张时优先保留，不会被驱逐，确保它们在节点上保持运行。
#   system-cluster-critical：集群级别的关键服务，优先级最高。确保关键组件（如控制平面组件）能够在资源不足的情况下继续运行，如 kube-apiserver、             kube-controller-manager、kube-scheduler 等
#   default：普通的默认优先级类。它的优先级低于 system-node-critical 和 system-cluster-critical
#   可以根据需要自定义优先级类。

beta.kubernetes.io/os: linux  # 确保Pod只会在具有该标签的节点上运行，避免调度到不符合条件的节点上
</code></pre>
<p><strong>Service 配置说明</strong></p>
<pre><code class="language-sh"># 创建 NodePort Service 时，可以指定范围为30000-32767的端口
</code></pre>
<h2 id="73启动yml">7.3、启动YML</h2>
<pre><code class="language-sh"># 通过 kubectl apply -f 创建
[root@linux-servertwo nginx]# kubectl apply -f ingress-nginx.yml 
namespace/nginx-proxy created
deployment.apps/nginx-proxy created
service/svc-nginx created
</code></pre>
<h2 id="74查看">7.4、查看</h2>
<pre><code class="language-sh"># 查看命名空间
[root@linux-servertwo nginx]# kubectl get namespace nginx-proxy
NAME          STATUS   AGE
nginx-proxy   Active   4m7s


# 查看资源
[root@linux-servertwo nginx]# kubectl get deploy,svc,pod -n nginx-proxy
NAME                          READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx-proxy   3/3     3            3           4m20s

NAME                TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
service/svc-nginx   NodePort   172.16.44.247   &lt;none&gt;        80:31001/TCP   4m20s

NAME                               READY   STATUS    RESTARTS   AGE
pod/nginx-proxy-6966ffc86c-289vk   1/1     Running   0          4m20s
pod/nginx-proxy-6966ffc86c-f47vl   1/1     Running   0          4m20s
pod/nginx-proxy-6966ffc86c-hqjvp   1/1     Running   0          4m20s
</code></pre>
<h2 id="75验证是否成功">7.5、验证是否成功</h2>
<pre><code class="language-sh"># 查看资源详情显示IP地址
[root@linux-servertwo nginx]# kubectl get deploy,svc,pod -n nginx-proxy -o wide
NAME                          READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR
deployment.apps/nginx-proxy   3/3     3            3           4m39s   nginx        nginx:1.23.1   app=nginx-proxy

NAME                TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE     SELECTOR
service/svc-nginx   NodePort   172.16.44.247   &lt;none&gt;        80:31001/TCP   4m39s   app=nginx-proxy

NAME                               READY   STATUS    RESTARTS   AGE     IP            NODE              NOMINATED NODE   READINESS GATES
pod/nginx-proxy-6966ffc86c-289vk   1/1     Running   0          4m39s   172.17.0.58   linux-servertwo   &lt;none&gt;           &lt;none&gt;
pod/nginx-proxy-6966ffc86c-f47vl   1/1     Running   0          4m39s   172.17.0.59   linux-servertwo   &lt;none&gt;           &lt;none&gt;
pod/nginx-proxy-6966ffc86c-hqjvp   1/1     Running   0          4m39s   172.17.0.57   linux-servertwo   &lt;none&gt;           &lt;none&gt;

# 查看ipvs链路规则
[root@linux-servertwo nginx]# ipvsadm -ln | grep -A 3 "127.0.0.1:31001"
TCP  127.0.0.1:31001 rr
  -&gt; 172.17.0.57:80               Masq    1      0          0         
  -&gt; 172.17.0.58:80               Masq    1      0          0         
  -&gt; 172.17.0.59:80               Masq    1      0          0    
  
# 验证负载均衡-首先进入容器内部配置html页面
[root@linux-servertwo nginx]# kubectl exec -it -n nginx-proxy nginx-proxy-6966ffc86c-289vk -- bash
root@nginx-proxy-6966ffc86c-289vk:/# echo this is 172.17.0.58  nginx &gt; /usr/share/nginx/html/index.html 
root@nginx-proxy-6966ffc86c-289vk:/# cat /usr/share/nginx/html/index.html 
this is 172.17.0.58 nginx

# 进入容器 172.17.0.59
[root@linux-servertwo nginx]# kubectl exec -it -n nginx-proxy nginx-proxy-6966ffc86c-f47vl -- bash
root@nginx-proxy-6966ffc86c-f47vl:/# echo this is 172.17.0.59  nginx &gt; /usr/share/nginx/html/index.html
root@nginx-proxy-6966ffc86c-f47vl:/# cat /usr/share/nginx/html/index.html
this is 172.17.0.59 nginx
# 进入容器 172.17.0.57
[root@linux-servertwo nginx]# kubectl exec -it -n nginx-proxy nginx-proxy-6966ffc86c-hqjvp -- bash
root@nginx-proxy-6966ffc86c-hqjvp:/# echo this is 172.17.0.57  nginx &gt; /usr/share/nginx/html/index.html
root@nginx-proxy-6966ffc86c-hqjvp:/# cat /usr/share/nginx/html/index.html
this is 172.17.0.57 nginx


# 访问服务service
root@nginx-proxy-6966ffc86c-hqjvp:/# curl 172.16.44.247
this is 172.17.0.59 nginx
root@nginx-proxy-6966ffc86c-hqjvp:/# curl 172.16.44.247
this is 172.17.0.58 nginx
root@nginx-proxy-6966ffc86c-hqjvp:/# curl 172.16.44.247
this is 172.17.0.57 nginx
root@nginx-proxy-6966ffc86c-hqjvp:/# curl 172.16.44.247
this is 172.17.0.59 nginx
</code></pre>
<h2 id="76删除yml">7.6、删除YML</h2>
<pre><code class="language-sh"># 删除 ingress-nginx.yml 
[root@linux-servertwo nginx]# kubectl delete -f ingress-nginx.yml 
namespace "nginx-proxy" deleted
deployment.apps "nginx-proxy" deleted
service "svc-nginx" deleted

# 再次查看 namespace
[root@linux-servertwo nginx]# kubectl get namespace nginx-proxy
Error from server (NotFound): namespaces "nginx-proxy" not found

# 查看资源
[root@linux-servertwo nginx]# kubectl get deploy,svc,pod -n nginx-proxy -o wide
No resources found in nginx-proxy namespace.
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0019706016041666666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 20:27">2025-03-31 20:26</span>&nbsp;
<a href="https://www.cnblogs.com/sowler">sowler</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18802875" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18802875);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18802875', targetLink: 'https://www.cnblogs.com/sowler/p/18802875', title: 'Kubernetes基础教程-通过部署Nginx快速学习基本使用命令' })">举报</a>
</div>
        