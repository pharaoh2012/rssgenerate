
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/maomao777/p/18928468" title="发布于 2025-06-14 16:43">
    <span role="heading" aria-level="2">有关Spring事务的传播机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这是一个非常常见的关于 <strong>Spring 事务传播机制</strong> 的问题，核心问题是：</p>
<blockquote>
<p><strong>在同一个类中，方法 A 调用方法 B，而方法 B 上有 <code>@Transactional</code> 注解。当调用方法 A 时，如果发生异常，方法 B 的事务会生效吗？</strong></p>
</blockquote>
<hr>
<h2 id="-简短回答">✅ 简短回答：</h2>
<blockquote>
<p><strong>不会生效！</strong><br>
在 Spring 中，默认使用的是基于 <strong>代理（Proxy）</strong> 的事务管理机制，<strong>只有外部调用带有 <code>@Transactional</code> 注解的方法时才会开启事务。</strong><br>
如果是<strong>同一个类中的方法直接调用</strong>（即内部调用），<strong>Spring 的事务注解将失效</strong>。</p>
</blockquote>
<hr>
<h2 id="-示例代码说明">📌 示例代码说明</h2>
<pre><code class="language-java">@Service
public class MyService {

    public void methodA() {
        // 做一些操作
        methodB();  // 内部调用methodB
    }

    @Transactional
    public void methodB() {
        // 数据库操作
    }
}
</code></pre>
<h3 id="️问题">❗️问题：</h3>
<ul>
<li>你调用 <code>methodA()</code>，它内部调用了 <code>methodB()</code>。</li>
<li>即使 <code>methodB()</code> 上有 <code>@Transactional</code> 注解，<strong>事务也不会生效</strong>！</li>
</ul>
<hr>
<h2 id="-为什么事务不生效">🤔 为什么事务不生效？</h2>
<p>因为 Spring 的事务是通过 <strong>动态代理（JDK Proxy 或 CGLIB）</strong> 实现的：</p>
<ul>
<li>当你从外部调用 <code>methodB()</code>，Spring 会拦截这个调用，并在调用前后开启/提交事务。</li>
<li>但当你在类内部调用 <code>methodB()</code>，这是普通的 Java 方法调用，<strong>绕过了代理对象</strong>，Spring 无法进行事务控制。</li>
</ul>
<hr>
<h2 id="-如何解决这个问题">✅ 如何解决这个问题？</h2>
<h3 id="-方案一将方法拆分到不同的类中">✅ 方案一：将方法拆分到不同的类中</h3>
<p>把 <code>methodB()</code> 放到另一个 Service 类中：</p>
<pre><code class="language-java">@Service
public class MyService {

    @Autowired
    private AnotherService anotherService;

    public void methodA() {
        // 做一些操作
        anotherService.methodB();  // 外部调用
    }
}

@Service
public class AnotherService {

    @Transactional
    public void methodB() {
        // 数据库操作
    }
}
</code></pre>
<p>✅ 这样事务就会生效了。</p>
<hr>
<h3 id="-方案二通过-aopcontextcurrentproxy-获取代理对象慎用">✅ 方案二：通过 <code>AopContext.currentProxy()</code> 获取代理对象（慎用）</h3>
<p>你可以通过以下方式获取当前类的代理对象来调用 <code>methodB()</code>：</p>
<pre><code class="language-java">@Service
public class MyService implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Transactional
    public void methodB() {
        // 数据库操作
    }

    public void methodA() {
        // 获取当前类的代理对象
        MyService proxy = (MyService) AopContext.currentProxy();
        proxy.methodB();  // 使用代理调用
    }

    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        applicationContext = ctx;
    }
}
</code></pre>
<p>⚠️ 注意事项：</p>
<ul>
<li>需要在配置文件中启用暴露代理：<code>&lt;aop:aspectj-autoproxy expose-proxy="true"/&gt;</code></li>
<li>或者使用注解方式：<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></li>
<li>此方式可实现功能，但会让代码耦合 Spring 框架，一般推荐优先使用方案一。</li>
</ul>
<hr>
<h2 id="-补充事务传播行为propagation-behavior">🔁 补充：事务传播行为（Propagation Behavior）</h2>
<p>如果你希望方法B的行为能被方法A控制，可以指定事务传播行为，例如：</p>
<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // 总是开启一个新事务
}
</code></pre>
<p>但这仍然需要保证 <code>methodB()</code> 是通过代理调用的才行。</p>
<hr>
<h2 id="-总结">✅ 总结</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>事务是否生效</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一类内调用带 <code>@Transactional</code> 的方法</td>
<td>❌ 不生效</td>
<td>Spring 无法拦截内部方法调用</td>
</tr>
<tr>
<td>不同类之间调用带 <code>@Transactional</code> 的方法</td>
<td>✅ 生效</td>
<td>通过代理对象调用，事务生效</td>
</tr>
<tr>
<td>使用 <code>AopContext.currentProxy()</code> 调用</td>
<td>✅ 可以生效</td>
<td>需要设置 <code>expose-proxy=true</code></td>
</tr>
</tbody>
</table>
<hr>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/maomao777/" target="_blank">没有烦恼的猫猫</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/maomao777/p/18928468" target="_blank">https://www.cnblogs.com/maomao777/p/18928468</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-14 16:44">2025-06-14 16:43</span>&nbsp;
<a href="https://www.cnblogs.com/maomao777">没有烦恼的猫猫</a>&nbsp;
阅读(<span id="post_view_count">50</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18928468);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18928468', targetLink: 'https://www.cnblogs.com/maomao777/p/18928468', title: '有关Spring事务的传播机制' })">举报</a>
</div>
        