
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huggingface/p/18846801" title="发布于 2025-04-25 15:25">
    <span role="heading" aria-level="2">大模型评估排障指南 | 关于推理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这是 <strong>大模型评估排障指南</strong> 系列文章的第一篇，敬请关注系列文章:</p>
<ul>
<li>关于推理</li>
<li>关于 <span class="math inline">\(\LaTeX\)</span> 公式解析</li>
<li>关于可复现性</li>
</ul>
<h2 id="模型运行非常慢怎么办">模型运行非常慢怎么办？</h2>
<h3 id="调整-batch-size">调整 batch size</h3>
<p>如果你想要评估结果完全可复现 (在特定的输入 prompt 和硬件条件下)，你可以把 batch size 可以设为 1。但如果增大 batch size (硬件条件允许的话) 将会加快推理速度。</p>
<h3 id="数据并行">数据并行</h3>
<p>你可以将模型加载到多个 GPU 上，然后将数据集分为多个子集并分配给每个 GPU，最后汇总全部计算结果。<br>
这意味着每个数据流是被并行同时处理的，从而将总执行时间缩短至 GPU 数分之一。尽量把 GPU 都放在一个节点上来避免跨节点传输瓶颈。</p>
<h3 id="调整代码">调整代码</h3>
<p>不同的推理库由于代码优化的种种差异，推理速度不尽相同。你可能需要做一些对比试验来选出速度最快的库。如果模型层面你使用 pytorch 实现，建议可以参考这份 <a href="https://pytorch.org/serve/performance_checklist.html" target="_blank" rel="noopener nofollow">推理优化清单</a>。</p>
<h3 id="调整精度">调整精度</h3>
<p>你可以通过调整计算精度来减小模型大小，进而加快推理速度。虽然 float32 精度 (每个数字使用 32 位存储) 的模型计算非常精确，但其消耗的内存和计算资源却非常大。降低精度为 <code>blfoat16</code> 或 <code>float16</code> (半精度) 可以加速一倍，而且不会影响计算结果。如果需要更进一步加速，可以尝试量化为更低精度，如 8 比特或 4 比特 (可以使用 <code>gptq</code> 或 <code>bitsandbytes</code> 库完成量化)。低位矩阵计算速度更快 (不过有些量化库反而有些慢，最好在你自己的模型上测试一下)，模型占用内存也更少。</p>
<h2 id="内存占用非常大怎么办">内存占用非常大怎么办？</h2>
<h3 id="估算内存需求">估算内存需求</h3>
<p>你可以用以下 <strong>公式</strong> 估算模型加载 (特定硬件) 所需的最小理论内存：</p>
<p><code>&lt;内存 (GB)&gt; = &lt;参数量 (G)&gt; * &lt;精度因子&gt;</code></p>
<p>模型所需总内存等于总参数量乘以一个参数所需的字节数。其中 1 个字节 (Byte) 是 8 比特 (bit)，精度因子视情况取值 (<code>float32</code> 为 4、<code>float16</code> 或 <code>bfoat16</code> 为 2、<code>8bit</code> 为 1、<code>4bit</code> 为 0.5)。</p>
<p>这就是基本的估算方法。</p>
<p>实际使用时我建议这样计算：<code>&lt;内存 (GB)&gt; = &lt;参数量 (G)&gt; * (&lt;精度因子&gt; * 110%)</code>。因为推理阶段除了加载模型还需要加载数据，总内存需求会更多。</p>
<h3 id="一个-gpu-都装不下怎么办">一个 GPU 都装不下怎么办？</h3>
<h4 id="量化">量化</h4>
<p>第一个明显的方法是降低 <code>&lt;精度因子&gt;</code>：从 float32 降低到 4bit 可以降低 8 倍的内存占用！<br>
不过精度太低也会导致结果变差。对于一些模型 (尤其是中等规模的模型) float16 或 8bit 就足够 (低精度对大型模型的影响较小，可能是因为信息冗余)。</p>
<h4 id="模型并行">模型并行</h4>
<p>模型并行包含一系列技术：拆分大模型为多个小型子模型、分配子模型到不同的 GPU 上运行等。这种方法不会一次性地加载整个模型，因此减少了内存需求，但可能会更慢。</p>
<p>模型并行有两种方法：</p>
<ul>
<li>管线并行。即在 layer 级拆分模型，不同的 layer 被分配到不同的 GPU 上。由于推理时前向过程是线性的，例如 layer 1 的输出是 layer 2 的输入，因此 layer 2 分配的 GPU 需要等待 layer 1 的计算结束才能开始 (也叫 “冒泡 (bubble)”)，同时数据和中间结果也需要 GPU 间传输，这也就导致执行速度较慢。不过可以通过将输入拆分为更小的批次来缓解冒泡，Pytorch 的原生库 <a href="https://github.com/pytorch/PiPPy" target="_blank" rel="noopener nofollow"><code>PiPPy</code></a> 就支持这一功能，也是 <code>accelerate</code> 库后台实现并行的方法。</li>
<li>张量并行。即在矩阵计算级拆分模型，矩阵按行或者列被拆分且分配到不同的 GPU 上计算以及合并结果。如果多个 GPU 在同一个节点上 (避免跨节点传输瓶颈)，这种并行方法会非常高效，但是代码实现有些困难。好在 <code>vllm</code> 库已经实现了，加速效果 <strong>非常明显</strong>。</li>
</ul>
<p>更多并行方法 (包括数据并行等) 可以参考 <a href="https://huggingface.co/docs/transformers/v4.15.0/en/parallelism" target="_blank" rel="noopener nofollow">这篇文档</a>。</p>
<h4 id="用-cpu-减负">用 CPU 减负</h4>
<p>CPU 卸载可以将部分模型和计算从 GPU 转移到 CPU 上，以减少 GPU 内存占用。不过相比于其他方法，CPU 卸载要 <strong>慢得多</strong>，主要原因是需要将数据在设备之间频繁移动。</p>
<p>例如，Deepspeed 的 <a href="https://arxiv.org/abs/2101.06840" target="_blank" rel="noopener nofollow">ZeRO-Offload</a> 可以将参数同时分配到 CPU 和 GPU (在 ZeRO-2 论文中有更详细的优化说明) 上。其中梯度、优化器状态、以及优化过程中的 fp32 模型参数在 CPU 上传递，而前向和反向过程中的 fp16 参数可以在 GPU 上传递，从而利用 CPU 内存优化并优化 GPU 计算，同时减少两者之间的通信。</p>
<h3 id="模型装进-gpu-但还是报-ooms-错误怎么办">模型装进 GPU 但还是报 OOMs 错误怎么办？</h3>
<p>你可能遇到了上下文大小相关的问题。</p>
<p>我们建议：</p>
<ol>
<li>同时加载模型以及 dummy 数据，测试 GPU 是否会内存溢出，注意 dummy 数据的上下文长度应足够大 (能够代表你的任务)。</li>
<li>降低 batch size，或者关闭自动搜索 batch size 功能 (如果启用，有时会导致 OOM 错误)。</li>
<li>更一般地，确保输入模型的样本的上下文大小是按从大到小的顺序，这样如果上下文大小过大，模型就会直接报错，避免了模型一开始正常运行，直到某个时间才出问题。</li>
</ol>
<hr>
<blockquote>
<p>英文原文: <a href="https://raw.githubusercontent.com/huggingface/evaluation-guidebook/refs/heads/main/translations/zh/contents/troubleshooting/troubleshooting-inference.md" target="_blank" rel="noopener nofollow">troubleshooting-inference.md</a></p>
<p>原文作者: clefourrier</p>
<p>译者: SuSung-boy</p>
<p>审校: adeenayakup</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2121184490011574" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 15:25">2025-04-25 15:25</span>&nbsp;
<a href="https://www.cnblogs.com/huggingface">HuggingFace</a>&nbsp;
阅读(<span id="post_view_count">44</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18846801);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18846801', targetLink: 'https://www.cnblogs.com/huggingface/p/18846801', title: '大模型评估排障指南 | 关于推理' })">举报</a>
</div>
        