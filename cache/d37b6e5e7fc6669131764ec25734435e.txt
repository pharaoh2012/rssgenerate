
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/keysky/p/19034742" title="发布于 2025-08-12 22:10">
    <span role="heading" aria-level="2">「HDU 6566」The Hanged Man</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="题目大意">题目大意</h2>
<p>给定一棵 <span class="math inline">\(N\)</span> 个点的无根树，对于所有 <span class="math inline">\(1 \leq k \leq M\)</span> 求出满足以下条件的点集 <span class="math inline">\(S\)</span> 个数。</p>
<ul>
<li><span class="math inline">\(\forall u, v \in S\)</span> ，<span class="math inline">\(u\)</span> , <span class="math inline">\(v\)</span> 在树上不相邻</li>
<li><span class="math inline">\(\sum_{u \in S} a_u = k\)</span></li>
<li><span class="math inline">\(\sum_{u \in S} b_u\)</span> 在满足上述两个条件的情况下最小</li>
</ul>
<p><span class="math inline">\(1 \leq N \leq 50\)</span> ，<span class="math inline">\(1 \leq M \leq 5000\)</span> 。</p>
<h2 id="初步思考">初步思考</h2>
<p>先考虑把暴力打出来，去优化。</p>
<p>对于此题，容易想到树上背包，定义 <span class="math inline">\(dp_{u, v, 0/1}\)</span> 表示处理完了 <span class="math inline">\(u\)</span> 这颗子树，<span class="math inline">\(\sum a_i = v\)</span> ，<span class="math inline">\(u\)</span> 不选/选的最小值&amp;方案数。转移时合并背包，时间复杂度 <span class="math inline">\(O(NM^2)\)</span> ，显然不行。</p>
<p>分析暴力，发现合并背包目前没有更好的方法，那么暴力优化的方向行不通，就要考虑更改状态 or 改变 dp 方法。</p>
<h2 id="进一步探究">进一步探究</h2>
<p>对于此题而言，笔者没想出其他可行的 dp 定义，所以从改变 dp 方法入手。</p>
<p>对于树形 dp ，除了常见的从下至上逐层 dp 外，还有按 dfs 序 dp 的方法，我们从这个角度去探究。</p>
<p>仿照暴力，令 <span class="math inline">\(dp_{u, v, 0/1}\)</span> 表示处理到结点 <span class="math inline">\(u\)</span> ，<span class="math inline">\(\sum a_i = v\)</span> ，<span class="math inline">\(u\)</span> 不选/选的最小值&amp;方案数，发现若我们在从 <span class="math inline">\(i\)</span> 转移到 <span class="math inline">\(i + 1\)</span> 时他们代表的结点“跨”树时（即非祖先关系）我们不知道 <span class="math inline">\(i + 1\)</span> 代表的结点 <span class="math inline">\(v\)</span> 相连的结点的选择情况，所以需要将 <span class="math inline">\(v\)</span> 附近的结点选择情况表示出来。</p>
<p>发现直接状压的话是 <span class="math inline">\(2^N\)</span> 级别的，接受不了，继续挖掘其他性质。手玩发现（真的易证）当 <span class="math inline">\(i\)</span> 代表结点 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(i + 1\)</span> 代表结点 <span class="math inline">\(v\)</span> “跨”树时 <span class="math inline">\(v\)</span> 一定是 <span class="math inline">\(\text{LCA}(u, v)\)</span> 的一个儿子。所以我们状压只需状压从 <span class="math inline">\(u\)</span> 到根节点的选择情况，然后回溯时将子结点的答案回收，加入本结点的 <span class="math inline">\(dp\)</span> 数组即可。</p>
<p>但链仍然可以把这种做法卡成 <span class="math inline">\(O(NM2^N)\)</span> ，所以对于状压仍然要继续优化，由于要状压从 <span class="math inline">\(u\)</span> 到根节点的链，我们可以从寻找优化链查找的数据结构的角度入手，一个是树链剖分，一个是点分治，此题中两者皆可，笔者就介绍下点分治吧。</p>
<h2 id="做法">做法</h2>
<p>首先对于点分治后构成的点分树有一个性质：在原树中相邻的点 <span class="math inline">\(u\)</span> 和点 <span class="math inline">\(v\)</span> 在点分树上一定是祖孙关系。因为当 <span class="math inline">\(u\)</span> - <span class="math inline">\(v\)</span> 这条边拆开时一定是当以 <span class="math inline">\(u\)</span> 或 <span class="math inline">\(v\)</span> 作为其子树根节点，且另一个点非其子树重心时，此时无论另一个点怎么旋，一定在该子树中，也就跟根节点呈祖孙关系。若 <span class="math inline">\(u\)</span> - <span class="math inline">\(v\)</span> 没拆开显然呈祖孙关系（父子被包含于祖孙关系中）。</p>
<p>所以我们可以直接在点分树上进行状压&amp;dp（因为对于第一个条件被转化为某一个祖孙关系，在状压的管辖范畴中），在向下递归时将当前结点加入背包，重点在于如何回溯，由于我们是按 dfs 序 dp ，所以所有已做过背包的点的贡献要保留下来。保留在哪里呢？对于 <span class="math inline">\(dp_{u, v, msk}\)</span> 我们在把 <span class="math inline">\(u\)</span> 回溯掉后发现只有 <span class="math inline">\(msk\)</span> 发生了变化，所以 <span class="math inline">\(dp_{u, v, msk}\)</span> 要加进 <span class="math inline">\(dp_{fa_u, v, msk \oplus (1 &lt;&lt; u)}\)</span> ，然后回到 <span class="math inline">\(fa_u\)</span> 继续 dp 。</p>
<p>因为我们最后做完 dp 后所有点的 dp 值全部传回了根节点，根节点到根节点的选点集合为 <span class="math inline">\(0/1\)</span> ，所以最终答案为 <span class="math inline">\(dp_{1, k, 0} + dp_{1, k, 1}\)</span> (“<span class="math inline">\(+\)</span>” 是重载过的，表示更新) 。</p>
<h2 id="solution">Solution</h2>
<pre><code class="language-cpp">/*
address:https://vjudge.net/problem/HDU-6566
AC 2025/8/12 14:58
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N = 105, V = 5005;
vector&lt;int&gt;G[N], adj[N];
int n, m;
int a[N], b[N];
struct node {
    int v;
    LL c;
    node() { v = c = 0; }
    node(int _v, LL _c) { v = _v, c = _c; }
    node operator += (const node&amp; o) {
        if (v == o.v) return node(v, c += o.c);
        else if (v &lt; o.v) return node(v = o.v, c = o.c);
        else return node(v, c);
    }
    node operator + (const int&amp; b) { return node(v + b, c); }
}dp[N][V];
bool uni[N][N]; //uni[i][j]: u, v 在原树上是否相邻
int siz[N];
inline int getsiz(int u, int fa = 0) {
    int ret = 1;
    for (auto v : G[u])
        if (v != fa) ret += getsiz(v, u);
    return ret;
}
int subn;
inline int find(int u, int fa = 0) {
    siz[u] = 1;
    bool ok = true;
    for (auto v : G[u])
        if (v != fa) {
            int g = find(v, u);
            if (g != -1) return g;
            siz[u] += siz[v];
            ok &amp;= siz[v] &lt;= (subn &gt;&gt; 1);
        }
    if (ok &amp;&amp; subn - siz[u] &lt;= (subn &gt;&gt; 1)) return u;
    return -1;
}//找重心
inline void build(int u, int fa) {
    subn = getsiz(u);
    u = find(u);
    adj[fa].push_back(u);
    for (auto v : G[u]) {
        G[v].erase(lower_bound(G[v].begin(), G[v].end(), u));
        build(v, u);
    }
}//建点分树
int stk[N]; //stk[i]表示从根节点到u的第i个结点的编号
inline void dfs(int u, int dep) {
    if (!dep) {
        dp[0][0] = node(0, 1);
        dp[1][a[u]] = node(b[u], 1); //根节点一定要初始化
    }
    else
        for (int msk = 0;msk &lt; 1 &lt;&lt; dep;++msk) {
            bool ok = true;
            for (int i = 0;i &lt; dep;++i)
                if ((msk &gt;&gt; i &amp; 1) &amp;&amp; uni[stk[i]][u]) {
                    ok = false;
                    break;
                }
            if (!ok) continue; //选了u后不合法就不选
            for (int i = m;i &gt;= a[u];--i)
                if (dp[msk][i - a[u]].c) dp[msk | 1 &lt;&lt; dep][i] += dp[msk][i - a[u]] + b[u];
        }
    stk[dep] = u;
    for (auto v : adj[u]) {
        dfs(v, dep + 1);
        for (int msk = 0;msk &lt; 1 &lt;&lt; dep + 1;++msk) {
            bool ok = true;
            for (int i = 0;i &lt;= dep;++i)
                if ((msk &gt;&gt; i &amp; 1) &amp;&amp; uni[stk[i]][v]) {
                    ok = false;
                    break;
                }
            if (!ok) continue;
            for (int i = 0;i &lt;= m;++i) {
                dp[msk][i] += dp[msk | 1 &lt;&lt; dep + 1][i];
                dp[msk | 1 &lt;&lt; dep + 1][i] = node(0, 0);
            }
        }//回溯
    }
}
int main() {
    int T, Case = 0;scanf("%d", &amp;T);
    while (T--) {
        scanf("%d%d", &amp;n, &amp;m);
        for (int i = 1;i &lt;= n;++i) scanf("%d%d", &amp;a[i], &amp;b[i]);
        for (int i = 1;i &lt; n;++i) {
            int u, v;scanf("%d%d", &amp;u, &amp;v);
            uni[u][v] = uni[v][u] = true;
            G[u].push_back(v);G[v].push_back(u);
        }
        for (int i = 1;i &lt;= n;++i) sort(G[i].begin(), G[i].end()); //笔者点分树写法比较怪，由于要删边，所以需排序，读者有更好的方法自己写即可，别喷
        build(1, 0);
        dfs(adj[0][0], 0);
        printf("Case %d:\n", ++Case);
        for (int i = 1;i &lt;= m;++i) printf("%lld ", (dp[0][i] += dp[1][i]).c);
        puts("");
        for (int i = 0;i &lt;= m;++i) dp[0][i] = dp[1][i] = node(0, 0);
        for (int i = 0;i &lt;= n;++i) {
            G[i].clear();
            adj[i].clear();
            for (int j = 1;j &lt;= n;++j) uni[i][j] = false;
        }//清空挺多的，细心点
    }
    return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-12 22:10">2025-08-12 22:10</span>&nbsp;
<a href="https://www.cnblogs.com/keysky">keysky</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19034742);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19034742', targetLink: 'https://www.cnblogs.com/keysky/p/19034742', title: '「HDU 6566」The Hanged Man' })">举报</a>
</div>
        