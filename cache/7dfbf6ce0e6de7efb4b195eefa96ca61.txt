
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fs7744/p/19035113" title="发布于 2025-08-13 09:36">
    <span role="heading" aria-level="2">VKProxy 集成 OpenTelemetry</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="opentelemetry">OpenTelemetry</h1>
<p>OpenTelemetry 是各类 API、SDK 和工具形成的集合。可用于插桩、生成、采集和导出遥测数据（链路、指标和日志），帮助你分析软件的性能和行为。</p>
<p><img alt="layered-approach" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093339395-713699219.svg" class="lazyload"></p>
<p>VKProxy 已集成OpenTelemetry，所以现在可以非常简单采集和导出遥测数据（链路、指标和日志）。</p>
<h2 id="简单回顾aspnet-core中如何使用">简单回顾asp.net core中如何使用</h2>
<p>遥测数据分为链路、指标和日志 ，dotnet中使用可参考<a href="https://opentelemetry.io/zh/docs/languages/dotnet/getting-started/" target="_blank" rel="noopener nofollow">OpenTelemetry文档</a></p>
<h3 id="简单的示例">简单的示例</h3>
<pre><code class="language-csharp">using Microsoft.Extensions.Options;
using OpenTelemetry;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;


Environment.SetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT", "http://127.0.0.1:4317/"); // 配置OpenTelemetry收集器

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi
builder.Services.AddOpenApi();

builder.Services.AddOpenTelemetry()
                    .ConfigureResource(resource =&gt; resource.AddService("TestApi", "").AddContainerDetector())
                    .WithTracing(tracing =&gt; tracing.AddAspNetCoreInstrumentation())
                    .WithMetrics(builder =&gt;
                    {
                        builder.AddMeter("System.Runtime", "Microsoft.AspNetCore.Server.Kestrel", "Microsoft.AspNetCore.MemoryPool");
                    })
                    .WithLogging()
                    .UseOtlpExporter();  // 示例使用 Otlp协议

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<h3 id="日志">日志</h3>
<p>这个其实没什么特别，由于已经提供非常抽象的 <code>ILogger</code>， 所以只需大家按照自己记录log所需正常使用就好，</p>
<p>log 大家使用非常多，这里就不详细示例了，可参考文档<a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-9.0" target="_blank" rel="noopener nofollow">Logging in .NET and ASP.NET Core</a></p>
<p>而OpenTelemetry 对于log，主要是如何在log 结构化并记录分布式追踪的信息，以方便关联。</p>
<p>OpenTelemetry sdk 已经内置支持，只需配置好 <code>.WithLogging()</code>，对应log和分布式追踪的信息都会写入收集器中。</p>
<h3 id="指标">指标</h3>
<p>dotnet 中已提供统一的抽象 <code>Meter</code>， 大家不必再关注是为 Prometheus 还是其他方案提供对应性能指标方案</p>
<p>详细文档可参考<a href="https://learn.microsoft.com/zh-cn/aspnet/core/log-mon/metrics/metrics?view=aspnetcore-9.0" target="_blank" rel="noopener nofollow">ASP.NET Core 指标</a> 和 <a href="https://learn.microsoft.com/zh-cn/aspnet/core/log-mon/metrics/built-in?view=aspnetcore-9.0" target="_blank" rel="noopener nofollow">ASP.NET 核心内置指标</a></p>
<p>这里举个简单例子说明 如何自定义指标</p>
<pre><code class="language-csharp">public class ProxyMetrics
{
    private readonly Meter? metrics;
    private readonly Counter&lt;long&gt;? requestsCounter;
    private readonly Histogram&lt;double&gt;? requestDuration;

    public ProxyMetrics(IMeterFactory meterFactory)
    {
        var f = serviceProvider.GetService&lt;IMeterFactory&gt;();
        metrics = f == null ? null : f.Create("VKProxy.ReverseProxy");
        if (metrics != null)
        {
            // 计数器
            requestsCounter = metrics.CreateCounter&lt;long&gt;("vkproxy.requests", unit: "{request}",    "Total number of (HTTP/tcp/udp) requests processed by the reverse proxy.");

            // 直方图
            requestDuration = metrics.CreateHistogram(
                "vkproxy.request.duration",
                unit: "s",
                description: "Proxy handle duration of (HTTP/tcp/udp) requests.",
                advice: new InstrumentAdvice&lt;double&gt; { HistogramBucketBoundaries = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 30, 60, 120, 300] });
        }
    }

    public void ProxyBegin(IReverseProxyFeature feature)  // 在请求开始调用
    {
        string routeId = GetRouteId(feature);
        GeneralLog.ProxyBegin(generalLogger, routeId);
        if (requestsCounter != null &amp;&amp; requestsCounter.Enabled)
        {
            var tags = new TagList
            {
                { "route", routeId }  // 设置 指标 tag，让其粒度到 route 级别
            };
            requestsCounter.Add(1, in tags); // +1 记录总共接受了多少个请求
        }
    }

     public void ProxyEnd(IReverseProxyFeature feature) // 在请求结束调用
    {
        string routeId = GetRouteId(feature);
        GeneralLog.ProxyEnd(generalLogger, routeId);
        if (requestDuration != null &amp;&amp; requestDuration.Enabled)
        {
            var endTimestamp = Stopwatch.GetTimestamp();
            var t = Stopwatch.GetElapsedTime(feature.StartTimestamp, endTimestamp);
            var tags = new TagList
                {
                    { "route", routeId }  // 设置 指标 tag，让其粒度到 route 级别
                };
            requestDuration.Record(t.TotalSeconds, in tags); // 记录请求耗时
        }
    }
}
</code></pre>
<p>接着在 Program.cs 中向 DI 注册指标类型：</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;ProxyMetrics&gt;();
</code></pre>
<p>然后在具体地方使用</p>
<pre><code class="language-csharp">private async Task DoHttp(HttpContext context, ListenEndPointOptions? options)
{
    try
    {
        logger.ProxyBegin(proxyFeature);
        ///......
    }
    finally
    {
        logger.ProxyEnd(proxyFeature);
    }
}
</code></pre>
<h3 id="链路">链路</h3>
<p>对于分布式链路追踪，其实dotnet现在已有内置抽象 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.diagnostics.activity?view=net-9.0" target="_blank" rel="noopener nofollow">Activity</a></p>
<p>这里举个简单例子说明 如何自定义链路</p>
<p>在 Program.cs 中向 DI 注册指标类型：</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.Services.TryAddSingleton(sp =&gt; new ActivitySource("VKProxy"));
builder.Services.TryAddSingleton(DistributedContextPropagator.Current);
</code></pre>
<p>使用  Activity 埋点信息</p>
<pre><code class="language-csharp">internal class ListenHandler : ListenHandlerBase
{
    internal const string ActivityName = "VKProxy.ReverseProxy";
    private readonly DistributedContextPropagator propagator;
    private readonly ActivitySource activitySource;

     public ListenHandler(...,
     DistributedContextPropagator propagator, ActivitySource activitySource)
    {
        this.propagator = propagator;
        this.activitySource = activitySource;
    }


    private async Task DoHttp(HttpContext context, ListenEndPointOptions? options)
    {
        Activity activity;
        if (activitySource.HasListeners())
        {
            var headers = context.Request.Headers;
            Activity.Current = activity = ActivityCreator.CreateFromRemote(activitySource, propagator, headers,
                static (object? carrier, string fieldName, out string? fieldValue, out IEnumerable&lt;string&gt;? fieldValues) =&gt;
            {
                fieldValues = default;
                var headers = (IHeaderDictionary)carrier!;
                fieldValue = headers[fieldName];
            },
            ActivityName,
            ActivityKind.Server,
            tags: null,
            links: null, false);
        }
        else
        {
            activity = null;
        }

        if (activity != null)
        {
            activity.Start();
            context.Features.Set&lt;IHttpActivityFeature&gt;(new HttpActivityFeature(activity));
            context.Features.Set&lt;IHttpMetricsTagsFeature&gt;(new HttpMetricsTagsFeature()
            {
                Method = context.Request.Method,
                Protocol = context.Request.Protocol,
                Scheme = context.Request.Scheme,
                MetricsDisabled = true,
            });
            activity.DisplayName = $"{context.Request.Method} {context.Request.Path.Value}";
            activity.SetTag("http.request.method", context.Request.Method);
            activity.SetTag("network.protocol.name", "http");
            activity.SetTag("url.scheme", context.Request.Scheme);
            activity.SetTag("url.path", context.Request.Path.Value);
            activity.SetTag("url.query", context.Request.QueryString.Value);
            if (ProtocolHelper.TryGetHttpVersion(context.Request.Protocol, out var httpVersion))
            {
                activity.SetTag("network.protocol.version", httpVersion);
            }
            activity.SetTag("http.request.host", context.Request.Host);
            activity.SetTag("http.request.content_type", context.Request.ContentType);
            var l = context.Request.ContentLength;
            if (l.HasValue)
                activity.SetTag("http.request.content_length", l.Value);
        }

        try
        {
            logger.ProxyBegin(proxyFeature);
            ///......
        }
        finally
        {
            if (activity != null)
            {
                var statusCode = context.Response.StatusCode;
                activity.SetTag("http.response.status_code", statusCode);
                activity.Stop();
                Activity.Current = null;
            }

            logger.ProxyEnd(proxyFeature);
        }
    }
</code></pre>
<h3 id="仪表盘">仪表盘</h3>
<p>遥测数据收集到哪儿，用什么展示，业界有各种方案， 比如</p>
<ul>
<li>将 OpenTelemetry 与 OTLP 和独立 Aspire 仪表板配合使用</li>
<li>将 OpenTelemetry 与 Prometheus、Grafana 和 Jaeger 结合使用</li>
<li>将 OpenTelemetry 与 SkyWalking ui  结合使用</li>
<li>等等</li>
</ul>
<p>大家可以根据自己喜好和实际选择</p>
<p>不过对应效果大致如 Aspire 一般</p>
<p><img alt="aspire-dashboard" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093410741-1786465598.png" class="lazyload"></p>
<h2 id="在vkproxy中如何使用">在VKProxy中如何使用？</h2>
<p>默认情况，OpenTelemetry 已经启用，并且配置为 otlp 协议，大家只需配置otlp收集器，</p>
<p>相关配置如下：</p>
<table>
<thead>
<tr>
<th>Environment variable</th>
<th>OtlpExporterOptions property</th>
</tr>
</thead>
<tbody>
<tr>
<td>OTEL_EXPORTER_OTLP_ENDPOINT</td>
<td>Endpoint</td>
</tr>
<tr>
<td>OTEL_EXPORTER_OTLP_HEADERS</td>
<td>Headers</td>
</tr>
<tr>
<td>OTEL_EXPORTER_OTLP_TIMEOUT</td>
<td>TimeoutMilliseconds</td>
</tr>
<tr>
<td>OTEL_EXPORTER_OTLP_PROTOCOL</td>
<td>Protocol (grpc or http/protobuf)</td>
</tr>
</tbody>
</table>
<p>(更多详细配置参见<a href="https://github.com/open-telemetry/opentelemetry-dotnet/tree/main/src/OpenTelemetry.Exporter.OpenTelemetryProtocol" target="_blank" rel="noopener nofollow">OpenTelemetry.Exporter.OpenTelemetryProtocol</a>)</p>
<p>这里我们用 <a href="https://learn.microsoft.com/zh-cn/dotnet/aspire/fundamentals/dashboard/overview?WT.mc_id=dapine&amp;tabs=bash" target="_blank" rel="noopener nofollow">Aspire 仪表盘</a>举例</p>
<p>因为它有个独立模式，只需启动一个镜像就可以尝试一下，当然真实产线还是需要配置其他存储等等</p>
<pre><code class="language-bash">docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \
    mcr.microsoft.com/dotnet/aspire-dashboard:9.0
</code></pre>
<p>前面的 Docker 命令：</p>
<ul>
<li>从 mcr.microsoft.com/dotnet/aspire-dashboard:9.0 映像启动容器。</li>
<li>公开两个端口的容器实例：
<ul>
<li>将仪表板的 OTLP 端口 18889 映射到主机的端口 4317。 端口 4317 从应用接收 OpenTelemetry 数据。 应用使用 OpenTelemetry 协议 （OTLP）发送数据。</li>
<li>将仪表板的端口 18888 映射到主机的端口 18888。 端口 18888 具有仪表板 UI。 导航到浏览器中 <a href="http://localhost:18888" target="_blank" rel="noopener nofollow">http://localhost:18888</a> 以查看仪表板。</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">// 设置收集器环境变量

set OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:4317/  

// 启动vkproxy （具体配置可参见之前的性能测试 https://www.cnblogs.com/fs7744/p/18978275 ）

vkproxy proxy -c D:\code\github\VKProxy\samples\CoreDemo\test.json
</code></pre>
<p>访问一下</p>
<pre><code class="language-bash">curl --location 'https://localhost:5001/WeatherForecast'
</code></pre>
<p>可以在 Aspire 中看到相关链路信息</p>
<p><img alt="tracing" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093448641-2128675342.jpg" class="lazyload"></p>
<p>指标信息</p>
<p><img alt="meters" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093501388-1525845490.jpg" class="lazyload"></p>
<p>日志信息</p>
<p><img alt="logs" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093510088-1958114050.jpg" class="lazyload"></p>
<p>当然你还可以通多如下命令调整过滤记录的信息</p>
<pre><code class="language-bash">     --telemetry (Environment:VKPROXY_TELEMETRY)
         Allow export telemetry data (metrics, logs, and traces) to help you analyze your software’s performance and behavior.

     --meter (Environment:VKPROXY_TELEMETRY_METER)
         Subscribe meters, default is System.Runtime,Microsoft.AspNetCore.Server.Kestrel,Microsoft.AspNetCore.Server.Kestrel.Udp,Microsoft.AspNetCore.MemoryPool,VKProxy.ReverseProxy

     --drop_instrument (Environment:VKPROXY_TELEMETRY_DROP_INSTRUMENT)
         Drop instruments

     --exporter (Environment:VKPROXY_TELEMETRY_EXPORTER)
         How to export telemetry data (metrics, logs, and traces), support prometheus,console,otlp , default is otlp, please set env like `OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:4317/`
</code></pre>
<h2 id="测一测性能">测一测性能</h2>
<pre><code class="language-bash">.\vegeta.exe attack -insecure -rate=10000/s -duration=60s -format=http -targets=http2proxy -output=http2proxyresults -http2 
// http2proxy content:
// GET https://127.0.0.1:5001/WeatherForecast
</code></pre>
<p><img alt="HTTP2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093031662-574789266.jpg" class="lazyload"></p>
<p><img alt="http2plot" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202508/818422-20250813093043404-1751770466.jpg" class="lazyload"></p>
<p>汇总</p>
<pre><code>Requests      [total, rate, throughput]         599999, 10000.94, 9992.64
Duration      [total, attack, wait]             59.994s, 59.994s, 0s
Latencies     [min, mean, 50, 90, 95, 99, max]  0s, 3.428ms, 2.015ms, 5.405ms, 6.882ms, 32.941ms, 301.44ms
Bytes In      [total, mean]                     231889817, 386.48
Bytes Out     [total, mean]                     0, 0.00
Success       [ratio]                           99.92%
Status Codes  [code:count]                      0:498  200:599501
Error Set:
Get "https://127.0.0.1:5001/WeatherForecast": dial tcp 0.0.0.0:0-&gt;127.0.0.1:5001: connectex: No connection could be made because the target machine actively refused it.
</code></pre>
<p>之前没有遥测的性能测试汇总</p>
<pre><code>Requests      [total, rate, throughput]         599930, 9998.35, 9998.35
Duration      [total, attack, wait]             1m0s, 1m0s, 0s
Latencies     [min, mean, 50, 90, 95, 99, max]  0s, 676.024µs, 0s, 2.56ms, 3.705ms, 5.367ms, 26.437ms
Bytes In      [total, mean]                     232052167, 386.80
Bytes Out     [total, mean]                     0, 0.00
Success       [ratio]                           100.00%
Status Codes  [code:count]                      200:599930
Error Set:
</code></pre>
<p>对比之前的测试而言，的确 otlp 遥测对性能有了不小的影响，但这点消耗单次请求看，消耗还是很低微的，总体利大于弊</p>
<p><a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">VKProxy</a> 是使用c#开发的基于 Kestrel 实现 L4/L7的代理（感兴趣的同学烦请点个<a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">github</a>小赞赞呢）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-13 09:37">2025-08-13 09:36</span>&nbsp;
<a href="https://www.cnblogs.com/fs7744">victor.x.qu</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19035113);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19035113', targetLink: 'https://www.cnblogs.com/fs7744/p/19035113', title: 'VKProxy 集成 OpenTelemetry' })">举报</a>
</div>
        