
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zphh/p/18587440" title="发布于 2025-01-12 16:35">
    <span role="heading" aria-level="2">线段树维护最大子段和及其类似问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引入">引入</h2>
<p><a href="https://www.luogu.com.cn/problem/P4513" target="_blank" rel="noopener nofollow">link</a>。</p>
<p>我们可以分析出上题就是带修改的最大子段和。</p>
<p>遇到这种类型的题目应该想到用线段树。</p>
<h2 id="实现">实现</h2>
<p>对于原数列，先建起一棵线段树，每个节点包含 最大前缀、最大后缀、最大字段和、区间和 信息。</p>
<blockquote>
<p>当你明确一道题是线段树时，要先思考 <code>pushup</code> 和 <code>pushdown</code> 怎么写，因为剩下的都是差不多的。 —— jzp.</p>
</blockquote>
<p>因为本题是单查，没有 <code>pushdown</code>，就先考虑 <code>pushup</code> 怎么写：</p>
<ul>
<li>最大前缀只可能是左儿子的最大前缀或是左儿子的和加上右儿子的最大前缀，即 <span class="math inline">\(maxl_i = \max\{maxl_l, sum_l + maxl_r\}\)</span>。</li>
<li>最大后缀同理，<span class="math inline">\(maxr_i = \max\{maxr_r, sum_r, maxr_l\}\)</span>。</li>
<li>最大子段和就是左儿子最大子段和或右儿子最大子段和或左儿子最大后缀加右儿子最大前缀，即 <span class="math inline">\(maxs_i = \max\{maxs_l, maxs_r, maxr_l + maxl_r\}\)</span>。</li>
<li>区间和很简单，不赘述。</li>
</ul>
<pre><code class="language-cpp">void pushup(int id) {
	sum(id) = sum(ls) + sum(rs);
	maxl(id) = max(maxl(ls), sum(ls) + maxl(rs));
	maxr(id) = max(maxr(rs), sum(rs) + maxr(ls));
	maxs(id) = max(max(maxs(ls), maxs(rs)), maxr(ls) + maxl(rs));
}
</code></pre>
<p>那么对于每一次询问，我们找到线段树上的左右端点 <span class="math inline">\(l\)</span>、<span class="math inline">\(r\)</span> 对应的两点 <span class="math inline">\(p_l\)</span>、<span class="math inline">\(p_r\)</span>。</p>
<p>当我们从上往下爬树爬到 <span class="math inline">\(k = LCA(p_l, p_r)\)</span> 时，<span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 就会分开为两个区间。</p>
<p>此时答案有几种可能：</p>
<ul>
<li><span class="math inline">\(l \le r \le m\)</span>，其中 <span class="math inline">\(m\)</span> 为该区间的中间点，此时递归左侧得到答案。</li>
<li><span class="math inline">\(m \lt l \le r\)</span>，此时递归右侧得到答案。</li>
<li><span class="math inline">\(l \le m \lt r\)</span>，此时合并两次得到的答案。</li>
</ul>
<p>以上三者取最大值返回。</p>
<p>这跟 cdq 分治的思想有异曲同工之妙。</p>
<p>当 <span class="math inline">\(l\)</span> 与 <span class="math inline">\(r\)</span> 并没有分叉时，就直接走下去即可。</p>
<p>那么此时查询也可以顺利地写出来了。</p>
<pre><code class="language-cpp">segment query(int id, int lft, int rht, int l, int r) {	// 这里用 segment 作为返回值是因为每层递归都需要用到下一层递归的结果
	if (l &lt;= lft &amp;&amp; rht &lt;= r) return seg[id];
	int mid = (lft + rht) &gt;&gt; 1;
	if (r &lt;= mid) return query(ls, lft, mid, l, r);
	if (l &gt; mid) return  query(rs, mid + 1, rht, l, r);
	segment a = query(ls, lft, mid, l, r), b = query(rs, mid + 1, rht, l, r), t;
	t.sum = a.sum + b.sum;
	t.maxl = max(a.maxl, a.sum + b.maxl);
	t.maxr = max(b.maxr, b.sum + a.maxr);
	t.maxs = max(max(a.maxs, b.maxs), a.maxr + b.maxl);
	return t;
}
</code></pre>
<p>整体代码：</p>
<pre><code class="language-cpp">struct segment_tree {
	#define ls (id &lt;&lt; 1)
	#define rs (id &lt;&lt; 1 | 1)
	#define sum(id) seg[id].sum
	#define maxl(id) seg[id].maxl
	#define maxr(id) seg[id].maxr
	#define maxs(id) seg[id].maxs
	struct segment {
		int maxl, maxr;
		int sum, maxs;
	} seg[N &lt;&lt; 2];
	void pushup(int id) {
		sum(id) = sum(ls) + sum(rs);
		maxl(id) = max(maxl(ls), sum(ls) + maxl(rs));
		maxr(id) = max(maxr(rs), sum(rs) + maxr(ls));
		maxs(id) = max(max(maxs(ls), maxs(rs)), maxr(ls) + maxl(rs));
	}
	void build(int id, int lft, int rht) {
		if (lft == rht) {
			sum(id) = a[lft];
			maxl(id) = maxr(id) = maxs(id) = a[lft];
			return;
		}
		int mid = (lft + rht) &gt;&gt; 1;
		build(ls, lft, mid), build(rs, mid + 1, rht);
		pushup(id);
	}
	void change(int id, int lft, int rht, int x, int v) {
//		if (lft &gt; x || rht &lt; x) return;
		if (lft == rht) {
//			a[lft] = v;
			sum(id) = v;
			maxl(id) = maxr(id) = maxs(id) = v;
			return;
		}
		int mid = (lft + rht) &gt;&gt; 1;
		if (x &lt;= mid) change(ls, lft, mid, x, v); 
		else change(rs, mid + 1, rht, x, v);
		pushup(id);
	}
	segment query(int id, int lft, int rht, int l, int r) {
//		if (lft &gt; r || rht &lt; l) return ;
		if (l &lt;= lft &amp;&amp; rht &lt;= r) return seg[id];
		int mid = (lft + rht) &gt;&gt; 1;
		if (r &lt;= mid) return query(ls, lft, mid, l, r);
		if (l &gt; mid) return  query(rs, mid + 1, rht, l, r);
		segment a = query(ls, lft, mid, l, r), b = query(rs, mid + 1, rht, l, r), t;
		t.sum = a.sum + b.sum;
		t.maxl = max(a.maxl, a.sum + b.maxl);
		t.maxr = max(b.maxr, b.sum + a.maxr);
		t.maxs = max(max(a.maxs, b.maxs), a.maxr + b.maxl);
		return t;
	}
} seg;
</code></pre>
<p>我们可以通过线段树维护最大子段和来推广到其他类似的问题。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23984432313310186" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-12 16:36">2025-01-12 16:35</span>&nbsp;
<a href="https://www.cnblogs.com/zphh">Archippus</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18587440" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18587440);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18587440', targetLink: 'https://www.cnblogs.com/zphh/p/18587440', title: '线段树维护最大子段和及其类似问题' })">举报</a>
</div>
        