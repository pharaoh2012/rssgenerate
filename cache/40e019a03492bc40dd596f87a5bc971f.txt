
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bbdhl/p/18710577" title="发布于 2025-02-11 22:15">
    <span role="heading" aria-level="2">node（上）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="nodejs">Node.js</h1>
<h2 id="commonjs">CommonJS</h2>
<ul>
<li>CommonJS 是一种模块化规范，主要用于在服务器端（如 Node.js 环境）实现模块化编程。以下是关于 CommonJS 的详细介绍：</li>
</ul>
<h3 id="1-背景">1. <strong>背景</strong></h3>
<p>在 JavaScript 的早期，代码通常是全局共享的，没有模块化的概念。随着项目复杂度的增加，代码的可维护性和可复用性变得很差。CommonJS 规范应运而生，它旨在为 JavaScript 提供一种模块化机制，方便开发者组织代码、避免命名冲突，并提高代码的可维护性。</p>
<h3 id="2-核心概念">2. <strong>核心概念</strong></h3>
<p>CommonJS 规范定义了模块的加载和导出机制，主要包括以下几个核心概念：</p>
<ul>
<li><strong>模块（Module）</strong>：每个文件被视为一个独立的模块。模块内部的变量和函数默认不会被外部访问，除非显式导出。</li>
<li><strong><code>require</code></strong>：用于加载模块。通过 <code>require</code> 函数可以引入其他模块的功能。</li>
<li><strong><code>module</code> 和 <code>exports</code></strong>：用于导出模块的功能。<code>module</code> 是一个对象，<code>exports</code> 是 <code>module</code> 的一个属性，通常用于导出模块的接口。</li>
</ul>
<h3 id="3-模块的导出">3. <strong>模块的导出</strong></h3>
<p>在 CommonJS 中，可以通过 <code>module.exports</code> 或 <code>exports</code> 来导出模块的内容：</p>
<ul>
<li>
<p><strong><code>module.exports</code></strong>：可以直接导出一个对象、函数、类等。它是模块的最终导出内容。</p>
<pre><code class="language-javascript">// math.js
const add = (a, b) =&gt; a + b;
const subtract = (a, b) =&gt; a - b;

module.exports = { add, subtract };
</code></pre>
</li>
<li>
<p><strong><code>exports</code></strong>：<code>exports</code> 是 <code>module.exports</code> 的引用，可以用来导出模块的部分内容。但需要注意，如果直接覆盖 <code>module.exports</code>，<code>exports</code> 的引用会失效。</p>
<pre><code class="language-javascript">// utils.js
exports.add = (a, b) =&gt; a + b;
exports.subtract = (a, b) =&gt; a - b;
</code></pre>
</li>
</ul>
<h3 id="4-模块的加载">4. <strong>模块的加载</strong></h3>
<p>通过 <code>require</code> 函数加载模块：</p>
<pre><code class="language-javascript">// app.js
const math = require('./math.js');
console.log(math.add(3, 5)); // 输出 8
console.log(math.subtract(10, 4)); // 输出 6
</code></pre>
<h3 id="5-模块缓存机制">5. <strong>模块缓存机制</strong></h3>
<p>CommonJS 模块加载时会进行缓存。当第一次加载模块时，模块的内容会被执行并缓存结果。后续再次加载时，直接返回缓存的结果，而不会重新执行模块代码。这可以提高性能，但需要注意，模块的状态是持久化的。</p>
<h3 id="6-适用场景">6. <strong>适用场景</strong></h3>
<p>CommonJS 主要用于 Node.js 环境，因为它非常适合服务器端的模块化开发。Node.js 原生支持 CommonJS 规范，使得开发者可以方便地组织代码，构建大型项目。</p>
<h3 id="7-与其他模块化规范的比较">7. <strong>与其他模块化规范的比较</strong></h3>
<ul>
<li><strong>与 AMD（Asynchronous Module Definition）比较</strong>：AMD 是一种异步加载模块的规范，主要用于浏览器端，支持异步加载模块，适合复杂的前端项目。CommonJS 是同步加载模块，更适合服务器端。</li>
<li><strong>与 ES6 模块（ESM）比较</strong>：ES6 模块是现代 JavaScript 的原生模块化规范，支持动态导入、静态分析等特性。CommonJS 是较早的规范，语法相对简单，但在现代项目中，ESM 的使用越来越广泛。</li>
</ul>
<p>CommonJS 是 JavaScript 模块化发展的重要一步，虽然在现代前端开发中逐渐被 ES6 模块取代，但它在 Node.js 环境中仍然具有重要地位。</p>
<h2 id="npm">npm</h2>
<p>npm（Node Package Manager）是 Node.js 生态系统中的核心工具，用于管理 JavaScript 项目中的依赖包。以下是关于 npm 的详细介绍：</p>
<h3 id="npm-的功能和作用">npm 的功能和作用</h3>
<ol>
<li><strong>包管理</strong>：
<ul>
<li><strong>安装依赖包</strong>：通过简单的命令（如 <code>npm install &lt;package&gt;</code>）可以快速安装项目所需的第三方库。</li>
<li><strong>更新和卸载包</strong>：使用 <code>npm update &lt;package&gt;</code> 和 <code>npm uninstall &lt;package&gt;</code> 可以方便地更新或卸载包。</li>
<li><strong>管理全局包</strong>：使用 <code>npm install -g &lt;package&gt;</code> 可以将包安装到全局环境中。</li>
</ul>
</li>
<li><strong>版本控制</strong>：
<ul>
<li>npm 支持语义化版本控制（SemVer），允许开发者指定依赖包的特定版本或版本范围。</li>
<li>在 <code>package.json</code> 中，可以使用符号（如 <code>^</code>、<code>~</code>）来定义版本范围。</li>
<li><code>package-lock.json</code> 文件可以锁定依赖包的具体版本，确保不同开发环境的一致性。</li>
</ul>
</li>
<li><strong>依赖解析</strong>：
<ul>
<li>npm 自动处理包之间的依赖关系，确保所有依赖都能正确安装。</li>
</ul>
</li>
<li><strong>脚本运行</strong>：
<ul>
<li>在 <code>package.json</code> 的 <code>scripts</code> 字段中定义自定义脚本，如构建、测试、部署等任务。</li>
<li>使用 <code>npm run &lt;script-name&gt;</code> 可以运行这些脚本。</li>
</ul>
</li>
<li><strong>包发布</strong>：
<ul>
<li>开发者可以将自己的代码打包并发布到 npm 官方仓库。</li>
<li>也可以搭建私有注册表，用于内部包的管理和分发。</li>
</ul>
</li>
<li><strong>生命周期钩子</strong>：
<ul>
<li>npm 提供了多种生命周期钩子（如 <code>preinstall</code>、<code>postinstall</code>、<code>prepublish</code> 等），允许在包的安装、测试、发布等过程中执行自定义脚本。</li>
</ul>
</li>
</ol>
<h3 id="npm-的使用">npm 的使用</h3>
<ol>
<li><strong>安装 npm</strong>：
<ul>
<li>npm 通常与 Node.js 一起安装。安装 Node.js 后，npm 也会随之安装。</li>
<li>可以通过 <code>npm -v</code> 命令检查 npm 是否安装成功。</li>
</ul>
</li>
<li><strong>初始化项目</strong>：
<ul>
<li>使用 <code>npm init</code> 命令可以创建一个 <code>package.json</code> 文件，记录项目的元数据和依赖信息。</li>
</ul>
</li>
<li><strong>常用命令</strong>：
<ul>
<li>安装依赖：<code>npm install</code> 或 <code>npm install &lt;package&gt;</code>。</li>
<li>更新依赖：<code>npm update</code> 或 <code>npm update &lt;package&gt;</code>。</li>
<li>卸载依赖：<code>npm uninstall &lt;package&gt;</code>。</li>
<li>查看已安装的包：<code>npm list</code>。</li>
<li>清除缓存：<code>npm cache clean --force</code>。</li>
</ul>
</li>
</ol>
<h3 id="高级用法">高级用法</h3>
<ol>
<li><strong>私有包和作用域</strong>：
<ul>
<li>使用作用域（如 <code>@myorg/mypackage</code>）可以组织相关包，并创建私有包。</li>
<li>发布私有包需要付费账户或组织。</li>
</ul>
</li>
<li><strong>镜像源</strong>：
<ul>
<li>由于 npm 官方服务器在国外，国内用户可以使用淘宝镜像（如 <code>cnpm</code>）来加速包的下载。</li>
</ul>
</li>
<li><strong>持续集成/持续部署（CI/CD）</strong>：
<ul>
<li>在 CI/CD 环境中，使用 <code>npm ci</code> 可以严格按照 <code>package-lock.json</code> 安装依赖。</li>
</ul>
</li>
</ol>
<p>npm 是现代 JavaScript 开发中不可或缺的工具，它极大地提高了开发效率并简化了依赖管理。</p>
<h2 id="yarn">yarn</h2>
<p>Yarn 是一个现代的包管理工具，旨在提高 JavaScript 项目的依赖管理和安装速度。以下是 Yarn 的基本用法，包括初始化项目、安装依赖、更新依赖、运行脚本等常见操作。</p>
<h3 id="1-安装-yarn">1. <strong>安装 Yarn</strong></h3>
<p>在安装 Yarn 之前，需要确保已经安装了 Node.js。可以通过以下命令安装 Yarn：</p>
<h4 id="使用-npm-安装-yarn">使用 npm 安装 Yarn：</h4>
<p>bash复制</p>
<pre><code class="language-bash">npm install --global yarn
</code></pre>
<h4 id="验证-yarn-是否安装成功">验证 Yarn 是否安装成功：</h4>
<p>bash复制</p>
<pre><code class="language-bash">yarn --version
</code></pre>
<p>如果返回版本号，则表示 Yarn 已正确安装。</p>
<h3 id="2-初始化项目">2. <strong>初始化项目</strong></h3>
<p>在项目的根目录下运行以下命令，创建 <code>package.json</code> 文件：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn init
</code></pre>
<p>按照提示输入项目信息（如名称、版本、描述、入口文件等）。也可以使用 <code>-y</code> 或 <code>--yes</code> 选项快速生成默认配置：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn init -y
</code></pre>
<h3 id="3-安装依赖">3. <strong>安装依赖</strong></h3>
<h4 id="1安装项目依赖">（1）安装项目依赖</h4>
<p>在项目根目录下运行以下命令，安装指定的包，并将其添加到 <code>package.json</code> 的 <code>dependencies</code> 中：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn add &lt;package-name&gt;
</code></pre>
<p>例如：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn add express
</code></pre>
<p>这会在项目中安装 <code>express</code> 包，并在 <code>package.json</code> 中添加如下内容：</p>
<p>JSON复制</p>
<pre><code class="language-json">"dependencies": {
  "express": "^4.18.2"
}
</code></pre>
<h4 id="2安装开发依赖">（2）安装开发依赖</h4>
<p>如果某些包仅在开发环境中使用（如测试工具、构建工具等），可以将其添加到 <code>devDependencies</code>：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn add &lt;package-name&gt; --dev
</code></pre>
<p>或简写为：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn add &lt;package-name&gt; -D
</code></pre>
<p>例如：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn add jest -D
</code></pre>
<h4 id="3安装全局包">（3）安装全局包</h4>
<p>某些工具（如 <code>create-react-app</code>）需要全局安装：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn global add &lt;package-name&gt;
</code></pre>
<p>例如：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn global add create-react-app
</code></pre>
<h3 id="4-更新依赖">4. <strong>更新依赖</strong></h3>
<p>更新项目中的某个依赖包：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn upgrade &lt;package-name&gt;
</code></pre>
<p>更新所有依赖包：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn upgrade
</code></pre>
<h3 id="5-卸载依赖">5. <strong>卸载依赖</strong></h3>
<p>卸载项目中的某个依赖包：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn remove &lt;package-name&gt;
</code></pre>
<h3 id="6-运行脚本">6. <strong>运行脚本</strong></h3>
<p>在 <code>package.json</code> 的 <code>scripts</code> 字段中定义脚本：</p>
<p>JSON复制</p>
<pre><code class="language-json">"scripts": {
  "start": "node index.js",
  "test": "jest"
}
</code></pre>
<p>运行脚本：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn run &lt;script-name&gt;
</code></pre>
<p>例如：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn run start
yarn run test
</code></pre>
<p>也可以省略 <code>run</code>，直接运行：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn start
yarn test
</code></pre>
<h3 id="7-查看已安装的包">7. <strong>查看已安装的包</strong></h3>
<p>查看项目中已安装的包：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn list
</code></pre>
<p>查看全局已安装的包：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn global list
</code></pre>
<h3 id="8-清理缓存">8. <strong>清理缓存</strong></h3>
<p>Yarn 会缓存已安装的包，以加快后续安装速度。如果需要清理缓存，可以运行：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn cache clean
</code></pre>
<h3 id="9-切换镜像源">9. <strong>切换镜像源</strong></h3>
<p>由于 Yarn 默认使用的是官方源，可能会受到网络问题的影响。可以切换到国内镜像源以提高下载速度。</p>
<h4 id="查询当前使用的镜像源">查询当前使用的镜像源：</h4>
<p>bash复制</p>
<pre><code class="language-bash">yarn config get registry
</code></pre>
<h4 id="切换到国内镜像源如淘宝镜像">切换到国内镜像源（如淘宝镜像）：</h4>
<p>bash复制</p>
<pre><code class="language-bash">yarn config set registry https://registry.npmmirror.com/
</code></pre>
<h4 id="切换回官方源">切换回官方源：</h4>
<p>bash复制</p>
<pre><code class="language-bash">yarn config set registry https://registry.yarnpkg.com/
</code></pre>
<h3 id="10-其他常用命令">10. <strong>其他常用命令</strong></h3>
<ul>
<li>
<p><strong>查看包信息</strong>：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn info &lt;package-name&gt;
</code></pre>
</li>
<li>
<p><strong>搜索包</strong>：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn search &lt;keyword&gt;
</code></pre>
</li>
<li>
<p><strong>查看 Yarn 配置</strong>：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn config list
</code></pre>
</li>
</ul>
<h3 id="11-使用-yarnlock-文件">11. <strong>使用 <code>yarn.lock</code> 文件</strong></h3>
<p>Yarn 使用 <code>yarn.lock</code> 文件来锁定依赖版本，确保在不同机器上安装的依赖完全一致。在项目中，<code>yarn.lock</code> 文件会自动生成，不要手动修改它。如果需要重新生成 <code>yarn.lock</code> 文件，可以删除旧文件后运行：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn install
</code></pre>
<h3 id="12-离线模式">12. <strong>离线模式</strong></h3>
<p>Yarn 支持离线模式，可以在没有网络的情况下安装依赖。确保本地缓存中有相关包后，运行：</p>
<p>bash复制</p>
<pre><code class="language-bash">yarn install --offline
</code></pre>
<p>通过以上命令和操作，你可以高效地使用 Yarn 来管理项目的依赖、运行脚本和发布包。Yarn 的设计目标是快速、可靠和安全，适合现代 JavaScript 项目的开发需求。</p>
<h2 id="内置模块http模块">内置模块（http模块）</h2>
<p>Node.js 的 <code>http</code> 模块是一个内置模块，用于创建 HTTP 服务器和客户端。它提供了底层的 HTTP 功能，允许开发者构建高性能的 HTTP 应用程序。以下是关于 Node.js 中 <code>http</code> 模块的详细介绍和使用方法。</p>
<h3 id="1-创建-http-服务器">1. <strong>创建 HTTP 服务器</strong></h3>
<p>使用 <code>http</code> 模块可以轻松创建一个 HTTP 服务器。以下是一个简单的示例：</p>
<pre><code class="language-javascript">const http = require('http');

// 创建 HTTP 服务器
const server = http.createServer((req, res) =&gt; {
  // 设置响应头
  res.writeHead(200, { 'Content-Type': 'text/plain' });

  // 发送响应内容
  res.end('Hello, World!\n');
});

// 监听端口
const PORT = 3000;
server.listen(PORT, () =&gt; {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</code></pre>
<h4 id="代码解析"><strong>代码解析</strong></h4>
<ul>
<li><code>http.createServer()</code>：创建一个 HTTP 服务器实例。
<ul>
<li>它接受一个回调函数，该回调函数会在每次请求到达时被调用。</li>
<li>回调函数的参数：
<ul>
<li><code>req</code>：<code>http.IncomingMessage</code> 对象，表示客户端的请求。</li>
<li><code>res</code>：<code>http.ServerResponse</code> 对象，用于向客户端发送响应。</li>
</ul>
</li>
</ul>
</li>
<li><code>res.writeHead()</code>：设置响应头，包括状态码和响应头字段。</li>
<li><code>res.end()</code>：结束响应，发送响应内容到客户端。</li>
<li><code>server.listen()</code>：让服务器监听指定的端口。</li>
</ul>
<h3 id="2-处理不同的-http-请求">2. <strong>处理不同的 HTTP 请求</strong></h3>
<p>可以通过检查 <code>req</code> 对象的属性来处理不同的请求路径和方法。</p>
<pre><code class="language-javascript">const http = require('http');

const server = http.createServer((req, res) =&gt; {
  const { method, url } = req;

  if (method === 'GET' &amp;&amp; url === '/') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('&lt;h1&gt;Welcome to the Home Page&lt;/h1&gt;');
  } else if (method === 'GET' &amp;&amp; url === '/about') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('&lt;h1&gt;About Us&lt;/h1&gt;');
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('404 Not Found');
  }
});

const PORT = 3000;
server.listen(PORT, () =&gt; {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</code></pre>
<h3 id="3-处理-post-请求">3. <strong>处理 POST 请求</strong></h3>
<p>处理 POST 请求时，需要从请求体中读取数据。可以通过监听 <code>data</code> 和 <code>end</code> 事件来实现。</p>
<pre><code class="language-javascript">const http = require('http');

const server = http.createServer((req, res) =&gt; {
  if (req.method === 'POST' &amp;&amp; req.url === '/submit') {
    let body = '';

    // 监听 data 事件，读取数据
    req.on('data', (chunk) =&gt; {
      body += chunk.toString();
    });

    // 监听 end 事件，处理数据
    req.on('end', () =&gt; {
      console.log('Received POST data:', body);
      res.writeHead(200, { 'Content-Type': 'text/plain' });
      res.end(`You sent: ${body}`);
    });
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('404 Not Found');
  }
});

const PORT = 3000;
server.listen(PORT, () =&gt; {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</code></pre>
<h3 id="4-发送-http-请求客户端">4. <strong>发送 HTTP 请求（客户端）</strong></h3>
<p><code>http</code> 模块也可以用于发送 HTTP 请求。以下是一个发送 GET 请求的示例：</p>
<pre><code class="language-javascript">const http = require('http');

const options = {
  hostname: 'example.com',
  port: 80,
  path: '/',
  method: 'GET',
};

const req = http.request(options, (res) =&gt; {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);

  res.on('data', (chunk) =&gt; {
    console.log(`BODY: ${chunk}`);
  });

  res.on('end', () =&gt; {
    console.log('No more data in response.');
  });
});

req.on('error', (e) =&gt; {
  console.error(`problem with request: ${e.message}`);
});

// 结束请求
req.end();
</code></pre>
<h3 id="5-使用-http-模块的优势">5. <strong>使用 HTTP 模块的优势</strong></h3>
<ul>
<li><strong>轻量级</strong>：<code>http</code> 模块是 Node.js 的内置模块，无需额外安装。</li>
<li><strong>高性能</strong>：基于 Node.js 的非阻塞 I/O 模型，可以处理高并发请求。</li>
<li><strong>灵活性</strong>：提供了底层的 HTTP 功能，可以自定义请求和响应的处理逻辑。</li>
</ul>
<h3 id="6-与其他框架的比较">6. <strong>与其他框架的比较</strong></h3>
<p>虽然 <code>http</code> 模块功能强大，但在实际开发中，通常会使用更高级的框架（如 Express.js）来简化开发过程。Express.js 基于 <code>http</code> 模块，提供了路由、中间件、模板引擎等高级功能，适合构建复杂的 Web 应用程序。</p>
<h3 id="示例使用-expressjs-创建服务器">示例：使用 Express.js 创建服务器</h3>
<pre><code class="language-javascript">const express = require('express');
const app = express();

app.get('/', (req, res) =&gt; {
  res.send('Hello, World!');
});

app.listen(3000, () =&gt; {
  console.log('Server is running on http://localhost:3000');
});
</code></pre>
<h3 id="总结">总结</h3>
<p>Node.js 的 <code>http</code> 模块是一个强大的工具，适用于构建高性能的 HTTP 服务器和客户端。它提供了底层的 HTTP 功能，允许开发者自定义请求和响应的处理逻辑</p>
<h2 id="内置模块url模块">内置模块（url模块）</h2>
<p>Node.js 的 <code>url</code> 模块是一个非常重要的内置模块，用于处理和解析 URL。它提供了多种方法和属性，可以帮助开发者轻松地解析、构建和操作 URL。以下是 <code>url</code> 模块的主要功能和用法：</p>
<h3 id="1-解析-url">1. <strong>解析 URL</strong></h3>
<p><code>url.parse()</code> 方法可以将一个 URL 字符串解析为一个对象，包含 URL 的各个组成部分。</p>
<pre><code class="language-javascript">const url = require('url');

const urlString = 'http://example.com:8080/path/to/file?query=123#hash';
const parsedUrl = url.parse(urlString);

console.log(parsedUrl);
</code></pre>
<p>输出示例：</p>
<pre><code class="language-javascript">Url {
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'example.com:8080',
  port: '8080',
  hostname: 'example.com',
  hash: '#hash',
  search: '?query=123',
  query: 'query=123',
  pathname: '/path/to/file',
  path: '/path/to/file?query=123',
  href: 'http://example.com:8080/path/to/file?query=123#hash'
}
</code></pre>
<h3 id="2-构建-url">2. <strong>构建 URL</strong></h3>
<p><code>url.format()</code> 方法可以将一个 URL 对象或字符串重新格式化为一个完整的 URL 字符串。</p>
<pre><code class="language-javascript">const url = require('url');

const urlObject = {
  protocol: 'http:',
  hostname: 'example.com',
  port: 8080,
  pathname: '/path/to/file',
  query: 'query=123',
  hash: '#hash'
};

const formattedUrl = url.format(urlObject);
console.log(formattedUrl); // 输出: http://example.com:8080/path/to/file?query=123#hash
</code></pre>
<h3 id="3-解析查询字符串">3. <strong>解析查询字符串</strong></h3>
<p><code>url.parse()</code> 方法解析 URL 后，会将查询字符串部分存储在 <code>query</code> 属性中。如果需要进一步解析查询字符串，可以使用 <code>querystring</code> 模块。</p>
<pre><code class="language-javascript">const url = require('url');
const querystring = require('querystring');

const urlString = 'http://example.com/path/to/file?query=123&amp;name=Kimi#hash';
const parsedUrl = url.parse(urlString);

const query = querystring.parse(parsedUrl.query);
console.log(query); // 输出: { query: '123', name: 'Kimi' }
</code></pre>
<h3 id="4-url-模块的现代替代url-和-urlsearchparams">4. <strong>URL 模块的现代替代：<code>URL</code> 和 <code>URLSearchParams</code></strong></h3>
<p>从 Node.js v10 开始，引入了与浏览器一致的 <code>URL</code> 和 <code>URLSearchParams</code> API，这些 API 更现代化且功能更强大。</p>
<pre><code class="language-javascript">const { URL, URLSearchParams } = require('url');

// 解析 URL
const urlString = 'http://example.com:8080/path/to/file?query=123#hash';
const myUrl = new URL(urlString);

console.log(myUrl.protocol); // http:
console.log(myUrl.hostname); // example.com
console.log(myUrl.port);     // 8080
console.log(myUrl.pathname); // /path/to/file
console.log(myUrl.search);   // ?query=123
console.log(myUrl.hash);     // #hash

// 解析查询字符串
const searchParams = new URLSearchParams(myUrl.search);
console.log(searchParams.get('query')); // 123

// 构建 URL
const newUrl = new URL('/path/to/file', 'http://example.com');
newUrl.search = 'query=123';
newUrl.hash = '#hash';
console.log(newUrl.href); // http://example.com/path/to/file?query=123#hash
</code></pre>
<h3 id="5-使用场景">5. <strong>使用场景</strong></h3>
<ul>
<li><strong>解析请求 URL</strong>：在 HTTP 服务器中，解析客户端请求的 URL，提取路径、查询参数等信息。</li>
<li><strong>构建响应 URL</strong>：根据业务逻辑动态生成 URL，用于重定向或生成链接。</li>
<li><strong>处理查询参数</strong>：方便地操作查询字符串，例如添加、删除或修改查询参数。</li>
</ul>
<h3 id="总结-1">总结</h3>
<p>Node.js 的 <code>url</code> 模块提供了丰富的功能，用于处理和解析 URL。虽然传统的 <code>url.parse()</code> 和 <code>url.format()</code> 方法仍然可用，但推荐使用现代的 <code>URL</code> 和 <code>URLSearchParams</code> API，因为它们更符合现代 JavaScript 的规范，并且功能更强大、更易于使用。</p>
<h2 id="内置模块querstring模块">内置模块（querstring模块）</h2>
<p><code>querystring</code> 是 Node.js 的一个内置模块，用于处理查询字符串（URL 中的 <code>?key=value&amp;...</code> 部分）。它提供了两个主要功能：解析查询字符串和构建查询字符串。</p>
<h3 id="1-解析查询字符串"><strong>1. 解析查询字符串</strong></h3>
<p>可以将查询字符串解析为一个对象。</p>
<pre><code class="language-javascript">const querystring = require('querystring');

const queryString = 'name=Kimi&amp;age=25&amp;city=Beijing';
const parsedQuery = querystring.parse(queryString);

console.log(parsedQuery);
// 输出：{ name: 'Kimi', age: '25', city: 'Beijing' }
</code></pre>
<h3 id="2-构建查询字符串"><strong>2. 构建查询字符串</strong></h3>
<p>可以将一个对象转换为查询字符串。</p>
<pre><code class="language-javascript">const querystring = require('querystring');

const queryParams = { name: 'Kimi', age: 25, city: 'Beijing' };
const queryString = querystring.stringify(queryParams);

console.log(queryString);
// 输出：name=Kimi&amp;age=25&amp;city=Beijing
</code></pre>
<h2 id="node-解决跨域问题">node 解决跨域问题</h2>
<p>在 Node.js 中解决跨域问题（CORS）有多种方法，以下是几种常见的解决方案：</p>
<h3 id="1-使用-cors-中间件">1. <strong>使用 <code>cors</code> 中间件</strong></h3>
<p><code>cors</code> 是一个专门用于解决跨域问题的 Node.js 中间件，非常简单易用。</p>
<h4 id="安装">安装</h4>
<p>bash复制</p>
<pre><code class="language-bash">npm install cors
</code></pre>
<h4 id="使用示例">使用示例</h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const express = require('express');
const cors = require('cors');

const app = express();

// 允许所有来源访问
app.use(cors());

// 或者指定特定来源
app.use(cors({
  origin: 'http://example.com'
}));

app.get('/data', (req, res) =&gt; {
  res.json({ message: 'This is CORS-enabled for only example.com.' });
});

app.listen(3000, () =&gt; {
  console.log('Server is running on port 3000');
});
</code></pre>
<h3 id="2-手动设置响应头">2. <strong>手动设置响应头</strong></h3>
<p>如果不想使用中间件，可以直接在响应头中设置 <code>Access-Control-Allow-Origin</code>。</p>
<h4 id="示例">示例</h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const express = require('express');
const app = express();

app.use((req, res, next) =&gt; {
  res.header('Access-Control-Allow-Origin', '*'); // 允许所有来源
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

app.get('/data', (req, res) =&gt; {
  res.json({ message: 'This is CORS-enabled.' });
});

app.listen(3000, () =&gt; {
  console.log('Server is running on port 3000');
});
</code></pre>
<h3 id="3-使用-http-proxy-middleware-代理">3. <strong>使用 <code>http-proxy-middleware</code> 代理</strong></h3>
<p>如果需要代理请求到其他服务器，可以使用 <code>http-proxy-middleware</code>。</p>
<h4 id="安装-1">安装</h4>
<p>bash复制</p>
<pre><code class="language-bash">npm install http-proxy-middleware
</code></pre>
<h4 id="示例-1">示例</h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const express = require('express');
const proxy = require('http-proxy-middleware');

const app = express();

app.use('/api', proxy({
  target: 'http://example.com', // 目标服务器
  changeOrigin: true,
  pathRewrite: {
    '^/api': '' // 重写路径
  }
}));

app.listen(3000, () =&gt; {
  console.log('Proxy server is running on port 3000');
});
</code></pre>
<h3 id="4-通过-nginx-代理">4. <strong>通过 Nginx 代理</strong></h3>
<p>如果使用 Nginx 作为反向代理服务器，也可以在 Nginx 配置中解决跨域问题。</p>
<h4 id="nginx-配置示例">Nginx 配置示例</h4>
<p>nginx复制</p>
<pre><code class="language-nginx">server {
  listen 80;
  server_name www.domain1.com;

  location / {
    proxy_pass http://www.domain2.com; # 目标服务器
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    add_header Access-Control-Allow-Origin *; # 允许所有来源
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
    add_header Access-Control-Allow-Headers "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization";
  }
}
</code></pre>
<h3 id="5-使用-jsonp">5. <strong>使用 JSONP</strong></h3>
<p>虽然 JSONP 只支持 GET 请求，但在某些场景下也可以作为一种解决方案。</p>
<h4 id="前端示例">前端示例</h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">$.ajax({
  url: 'http://example.com/data',
  type: 'GET',
  dataType: 'jsonp',
  jsonpCallback: 'callbackFunction',
  success: function(data) {
    console.log(data);
  }
});
</code></pre>
<h4 id="后端示例">后端示例</h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const http = require('http');
const querystring = require('querystring');

const server = http.createServer((req, res) =&gt; {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const params = querystring.parse(url.search.slice(1));
  const callback = params.callback;

  res.writeHead(200, { 'Content-Type': 'application/javascript' });
  res.end(`${callback}({"message": "Hello, JSONP!"})`);
server});

.listen(3000, () =&gt; {
  console.log('Server is running on port 3000');
});
</code></pre>
<h3 id="总结-2">总结</h3>
<ul>
<li><strong>推荐使用 <code>cors</code> 中间件</strong>，因为它简单且功能强大。</li>
<li>如果需要代理请求，可以使用 <code>http-proxy-middleware</code>。</li>
<li>如果使用 Nginx，可以通过 Nginx 配置解决跨域问题。</li>
<li>JSONP 是一种古老的解决方案，但只支持 GET 请求，适合简单场景</li>
</ul>
<h2 id="内置模块event模块">内置模块(event模块)</h2>
<p>在 Node.js 中，<code>events</code> 模块是一个核心模块，用于实现事件驱动编程。它提供了一个 <code>EventEmitter</code> 类，允许你创建可以发射（emit）和监听（listen）事件的对象。这种模式非常适合处理异步操作和事件驱动的编程场景。</p>
<h3 id="1-引入-events-模块"><strong>1. 引入 <code>events</code> 模块</strong></h3>
<p>要使用 <code>events</code> 模块，首先需要引入它：</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const EventEmitter = require('events');
</code></pre>
<h3 id="2-创建-eventemitter-实例"><strong>2. 创建 <code>EventEmitter</code> 实例</strong></h3>
<p>你可以通过继承 <code>EventEmitter</code> 类或直接使用其实例来创建事件发射器。</p>
<h4 id="示例-1直接使用-eventemitter-实例"><strong>示例 1：直接使用 <code>EventEmitter</code> 实例</strong></h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const EventEmitter = require('events');

// 创建 EventEmitter 实例
const emitter = new EventEmitter();

// 监听事件
emitter.on('greet', (message) =&gt; {
  console.log(`Received greeting: ${message}`);
});

// 发射事件
emitter.emit('greet', 'Hello, world!');
</code></pre>
<h4 id="示例-2通过继承-eventemitter-类"><strong>示例 2：通过继承 <code>EventEmitter</code> 类</strong></h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

myEmitter.on('greet', (message) =&gt; {
  console.log(`Received greeting: ${message}`);
});

myEmitter.emit('greet', 'Hello, world!');
</code></pre>
<h3 id="3-常用方法"><strong>3. 常用方法</strong></h3>
<p><code>EventEmitter</code> 提供了以下常用方法：</p>
<h4 id="onevent-listener"><strong><code>on(event, listener)</code></strong></h4>
<p>注册一个监听器，监听指定事件。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.on('event', (arg1, arg2) =&gt; {
  console.log(arg1, arg2);
});
</code></pre>
<h4 id="emitevent-args"><strong><code>emit(event, [...args])</code></strong></h4>
<p>发射一个事件，并将参数传递给监听器。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.emit('event', 'arg1', 'arg2');
</code></pre>
<h4 id="onceevent-listener"><strong><code>once(event, listener)</code></strong></h4>
<p>注册一个一次性监听器，监听指定事件。监听器在事件第一次发射后自动移除。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.once('event', () =&gt; {
  console.log('This will be called only once.');
});
</code></pre>
<h4 id="removelistenerevent-listener"><strong><code>removeListener(event, listener)</code></strong></h4>
<p>移除指定事件的监听器。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const listener = () =&gt; {
  console.log('This will be removed.');
};

emitter.on('event', listener);
emitter.removeListener('event', listener);
</code></pre>
<h4 id="offevent-listener"><strong><code>off(event, listener)</code></strong></h4>
<p>与 <code>removeListener</code> 相同，移除指定事件的监听器。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.off('event', listener);
</code></pre>
<h4 id="removealllistenersevent"><strong><code>removeAllListeners([event])</code></strong></h4>
<p>移除所有监听器，或者移除指定事件的所有监听器。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.removeAllListeners('event');
</code></pre>
<h4 id="listenersevent"><strong><code>listeners(event)</code></strong></h4>
<p>返回指定事件的所有监听器数组。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">console.log(emitter.listeners('event'));
</code></pre>
<h4 id="listenercountevent"><strong><code>listenerCount(event)</code></strong></h4>
<p>返回指定事件的监听器数量。</p>
<p>JavaScript复制</p>
<pre><code class="language-javascript">console.log(emitter.listenerCount('event'));
</code></pre>
<h3 id="4-事件驱动编程示例"><strong>4. 事件驱动编程示例</strong></h3>
<p>以下是一个完整的示例，展示如何使用 <code>events</code> 模块实现事件驱动编程。</p>
<h4 id="示例代码"><strong>示例代码</strong></h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">const EventEmitter = require('events');

class User extends EventEmitter {
  constructor(name) {
    super();
    this.name = name;
  }

  greet() {
    this.emit('greet', `Hello, ${this.name}!`);
  }
}

const user = new User('Kimi');
user.on('greet', (message) =&gt; {
  console.log(message);
});

user.greet(); // 输出：Hello, Kimi!
</code></pre>
<h3 id="5-注意事项"><strong>5. 注意事项</strong></h3>
<ul>
<li><strong>事件监听器数量限制</strong>：默认情况下，<code>EventEmitter</code> 对每个事件的监听器数量有限制（默认为 10）。如果需要更多监听器，可以通过 <code>emitter.setMaxListeners(n)</code> 设置最大监听器数量。</li>
<li><strong>内存泄漏</strong>：如果事件监听器没有被正确移除，可能会导致内存泄漏。建议在不需要时移除监听器。</li>
<li><strong>错误事件</strong>：<code>EventEmitter</code> 提供了一个特殊的 <code>error</code> 事件，用于处理错误。如果没有监听 <code>error</code> 事件，当发射 <code>error</code> 事件时，程序会抛出错误并可能崩溃。</li>
</ul>
<h4 id="示例监听-error-事件"><strong>示例：监听 <code>error</code> 事件</strong></h4>
<p>JavaScript复制</p>
<pre><code class="language-javascript">emitter.on('error', (err) =&gt; {
  console.error('Error occurred:', err.message);
});

emitter.emit('error', new Error('Something went wrong'));
</code></pre>
<h3 id="总结-3"><strong>总结</strong></h3>
<p><code>events</code> 模块是 Node.js 中实现事件驱动编程的核心工具。通过 <code>EventEmitter</code> 类，你可以轻松地创建事件发射器，注册事件监听器，并在需要时发射事件。这种模式非常适合处理异步操作和事件驱动的场景。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="9.586919109226852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 22:15">2025-02-11 22:15</span>&nbsp;
<a href="https://www.cnblogs.com/bbdhl">笨笨的虎狼</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710577" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710577);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710577', targetLink: 'https://www.cnblogs.com/bbdhl/p/18710577', title: 'node（上）' })">举报</a>
</div>
        