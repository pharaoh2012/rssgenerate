
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/19015298" title="发布于 2025-08-01 08:52">
    <span role="heading" aria-level="2">vue3中的watch详细讲解保证看的明明白白</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1425695/202508/1425695-20250801085250403-1329631327.jpg" alt="vue3-5" loading="lazy"></p>
<h4 id="vue3-中的-watch-只能监视以下四种数据">Vue3 中的 watch 只能监视以下四种数据</h4>
<p>1，ref 定义的数据。<br>
2，一个响应式对象（如：reactive 定义的数据）。<br>
3，函数的返回一个值（getter函数）。getter函数其实就是：能返回一个值的函数<br>
4，由以上类型的值组成的数组<br>
地址：<a href="https://cn.vuejs.org/api/reactivity-core.html#watch" target="_blank" rel="noopener nofollow">https://cn.vuejs.org/api/reactivity-core.html#watch</a><br>
<img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716191748910-433241841.png" alt="image" loading="lazy"></p>
<h4 id="vue3中watch监听-ref定义的基本数据类型">vue3中watch监听 ref定义的基本数据类型</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
   姓 &lt;input v-model="xingValue" /&gt; &lt;br&gt;
     &lt;button @click="changeHandler"&gt;更改值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch } from 'vue';
const xingValue = ref('Zhang');
function changeHandler(){
  xingValue.value = 'Li';
}

watch(xingValue, (newValue,oldValue)=&gt;{
  console.log('watch监听到的值新值：',newValue,'旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716192222305-499782490.png" alt="image" loading="lazy"></p>
<h4 id="watch监听ref声明的数据第1个参数是不需要点value">watch监听ref声明的数据，第1个参数是不需要点value</h4>
<p>如果我们使用watch监听ref声明的数据，第1个参数是不需要点value的。</p>
<pre><code>const age = ref(1);
// watch监听ref声明的数据，第1个参数是不需要点value
watch(age, (newValue,oldValue)=&gt;{
  console.log('watch监听到的值新值：',newValue,'旧值：', oldValue)
})
</code></pre>
<p>如果你使用ref声明的数据，如果你使用了点value。那么会报错的哈。<br>
<img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716193345297-1406771480.png" alt="image" loading="lazy"></p>
<h4 id="watch监听ref定义的对象数据类型">watch监听ref定义的对象数据类型</h4>
<p>watch监听ref定义的【对象】数据类型时，监听的是对象的地址。<br>
若是想要监听【对象内部属】性的变化，也就是细枝末节的变化。首要手动开启deep：true。<br>
若是不开启deep：true，则监听不到。</p>
<h4 id="watch监听ref定义的对象数据类型时若是不开启deeptrue则监听不到对象内部属性的变化">watch监听ref定义的【对象】数据类型时，若是不开启deep：true，则监听不到对象内部属性的变化。</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ perosn }}&lt;/p&gt;
     &lt;button @click="changeHandler"&gt;更改值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch } from 'vue';
const perosn = ref({
  name: 'zhangsan',
  age: 18
});
function changeHandler(){
 perosn.value.age+=1
}
watch(perosn, (newValue,oldValue)=&gt;{
  console.log('watch监听到的值新值：',newValue,'旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p>为啥更改ref定义的【对象】的属性时不会触发。<br>
因为：watch监听ref定义的【对象】数据类型时，监听的是对象的地址。<br>
地址没有发生改变，因此就不会触发。<br>
<img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716194834911-983845045.png" alt="image" loading="lazy"><br>
如果想要：地址不发生改变时，也触发 ，需要开启：deep:true<br>
watch开启deep:true监听ref对象内部属性的变化</p>
<h4 id="watch开启deeptrue监听ref对象内部属性的变化">watch开启deep:true监听ref对象内部属性的变化</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ perosn }}&lt;/p&gt;
     &lt;button @click="changeHandler"&gt;更改值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch } from 'vue';
const perosn = ref({
  name: 'zhangsan',
  age: 18
});
function changeHandler(){
 perosn.value.age+=1
}
watch(perosn, (newValue,oldValue)=&gt;{
  console.log('watch监听到的值新值：',newValue,'旧值：', oldValue)
},{
  deep: true
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716194622281-275322402.png" alt="image" loading="lazy"></p>
<h4 id="watch监听ref定义的对象内部属性变化时开启deeptrue-新值和旧值是一样的">watch监听ref定义的对象内部属性变化时，开启deep:true 新值和旧值是一样的</h4>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250717123939491-202454222.png" alt="image" loading="lazy"><br>
因为：watch监听ref定义的【对象】数据类型时，监听的是对象的地址。他们的地址是没有发生改变的。</p>
<h4 id="watch监听ref定义的对象时修改整个对象newvalue-和-oldvalue-是不一样的">watch监听ref定义的对象时，修改整个对象，newValue 和 oldValue 是不一样的</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ perosn }}&lt;/p&gt;
    &lt;button @click="allHandler"&gt;更改整个属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch } from 'vue';
const perosn = ref({
  name: 'zhangsan',
  age: 18
});

function allHandler(){
  // 若修改整个ref 定义的对象,这个时候地址发生变化了。
  // 如果你多次点击，会多次触发。
  perosn.value = {
    name: 'wangmazi',
    age: 30
  }
}
watch(perosn, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
},{
  deep: true
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250717125627459-1005982547.png" alt="image" loading="lazy"></p>
<h4 id="总结watch监听ref声明对象类型的数据时">总结：watch监听ref声明对象类型的数据时</h4>
<p>watch监视 ref 定义的【对象类型】数据时，直接写数据名，监视的是对象的【地址值】<br>
若想监视对象内部的数据，要手动开启深度监视<br>
若修改的是 ref 定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。<br>
若修改整个ref 定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了<br>
<img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250717124622154-2001501034.png" alt="image" loading="lazy"></p>
<h4 id="watch监视reactive定义的对象类型数据默认是开启深度监视的">watch监视【reactive】定义的【对象类型数据】，默认是开启深度监视的</h4>
<p>只要我们使用watch去监听reactive定义的对象类型数据<br>
无论数据层级有多么深，watch都是可以监听到的，并且它默认是开启了深度监听的。<br>
无论内部变化的是某个属性，还是对象，都可以监听到。<br>
监听这种是最省心的，因为无论怎么变化，都是可以监听到的哈哈。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{  person }}&lt;/h1&gt;
    &lt;button @click="allHandler"&gt;更改car这个对象&lt;/button&gt;
    &lt;button @click="oneNameHandler"&gt;更改某个属性name&lt;/button&gt;    
  &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import { watch,reactive } from 'vue';
const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});
function allHandler(){
  person.car = {
    c1:'小米',
    c2:'Su7'
  }
}
function oneNameHandler(){
  person.name = '李四';
}
// watch监视【reactive】定义的【对象类型数据】,默认是开启深度监视的 
// 无论内部变化的是某个属性，还是对象，都可以监听到。
watch(person, (newValue,oldValue)=&gt;{
   console.log('新值：',newValue)
   console.log('旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250727104213430-782469360.png" alt="image" loading="lazy"></p>
<p>有的文章会说：这种深度监听你是无法通过deep：false来进行关闭的。<br>
这种说法不太正确，在现在的vue3.5版本中。<br>
通过deep：false是可以关闭监听的。</p>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ person }}&lt;/p&gt;
    &lt;button @click="allHandler"&gt;更改整个属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch, reactive } from 'vue';
const person = reactive({
  a:{
    b:{
      c: 1
    }
  }
});
function allHandler(){
  person.a.b.c +=1
}
 watch(person, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
},{
  deep: false,
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718174353592-455617439.png" alt="image" loading="lazy"></p>
<h4 id="watch监视-ref-或-reactive定义的对象类型数据中的某个属性">watch监视 ref 或 reactive定义的【对象类型】数据中的某个属性</h4>
<p>watch监视 ref 或 reactive定义的【对象类型】数据中的某个属性，注意点如下：<br>
1,若该属性值是【对象类型】，可直接写数据源，也可写成函数(建议写成函数)。并且推荐开启深度监听。<br>
2,若该属性值不是【对象类型】，需要写成函数形式。否则会在控制台产生告警。</p>
<h4 id="若该属性值不是对象类型需要写成函数形式">若该属性值不是【对象类型】，需要写成函数形式</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ person }}&lt;/p&gt;
    &lt;button @click="allHandler"&gt;更改整个属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch, reactive } from 'vue';
const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});
function allHandler(){
  person.age+=1
}
// 监听person.age属性,会产生警告。
 watch(person.age, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718180049586-68270216.png" alt="image" loading="lazy"></p>
<pre><code>const person = ref({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});
watch(person.value.name, (newValue,oldValue)=&gt;{
  console.log('newValue', newValue)
  console.log('oldValue', oldValue)
})
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250727110749923-838850191.png" alt="image" loading="lazy"></p>
<p>现在有警告。为啥会警告。<br>
因为：watch监视 ref 或 reactive定义的【对象类型】数据中的某个属性时。<br>
如果这个属性值不是对象类型时，需要写成函数形式。【重点】</p>
<pre><code>// 因为这个属性值不是对象类型时，所以写成了函数形式
 watch(()=&gt; person.age, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
})
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718181402296-1742700985.png" alt="image" loading="lazy"></p>
<h4 id="watch监听reactive定义的对象监听的属性是对象写成数据源形式你替换整个对象监听不到">watch监听reactive定义的对象，监听的属性是对象（写成数据源形式），你替换整个对象，监听不到。</h4>
<pre><code>&lt;template&gt;
  &lt;div class="box"&gt;
     &lt;p&gt;{{ person }}&lt;/p&gt;
      &lt;button @click="allOneHandler"&gt;更改某个属性&lt;/button&gt;
      &lt;button @click="allHandler"&gt;更改整个对象&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import {  ref, computed, watch, reactive } from 'vue';
const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});

function allOneHandler(){
  person.car.c1 = '--我的电动车--';
}
function allHandler(){
  person.car = {
    c1:'--电动车--',
    c2:'--燃油车--'
  }
}
 watch(person.car, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718184047713-930365114.png" alt="image" loading="lazy"><br>
为什么上面的直接更改整个监听对象，监听不到。</p>
<pre><code>person.car = {
  c1:'--电动车--',
  c2:'--燃油车--'
}
watch(person.car,()=&gt;{})
</code></pre>
<p>因为：当你替换整个car的时候，已经不再是原来的car。因此无法监听到。<br>
怎么让它也可以监听到呢？写成函数形式。</p>
<pre><code>const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});

function allHandler(){
  person.car = {
    c1:'--电动车--',
    c2:'--燃油车--'
  }
}

 watch(()=&gt;person.car, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
})
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718195826822-464859143.png" alt="image" loading="lazy"></p>
<p>写成函数形式，监听整某个具体属性又不行了。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{  person }}&lt;/h1&gt;
    &lt;button @click="allHandler"&gt;更改car这个对象&lt;/button&gt;
    &lt;button @click="allOneHandler"&gt;更改某个属性&lt;/button&gt;

    
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { watch,reactive } from 'vue';

const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});

function allHandler(){
  person.car = {
    c1:'--电动车--',
    c2:'--燃油车--'
  }
}
function allOneHandler(){
  person.car.c1 += '--我的电动车--';
} 
 watch(()=&gt;person.car, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718200634852-1671305099.png" alt="image" loading="lazy"></p>
<h4 id="终极的解决办法">终极的解决办法</h4>
<pre><code>const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});

function allOneHandler(){
  person.car.c1 += '--我的电动车--';
}
function allHandler(){
  person.car = {
    c1:'--电动车--',
    c2:'--燃油车--'
  }
}

watch(()=&gt;person.car, (newValue,oldValue)=&gt;{
  console.log('新值：',newValue,'旧值：', oldValue)
},{ deep: true })
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250718201831849-640325494.png" alt="image" loading="lazy"><br>
这样无论是更改整个对象还是对象内部的属性变化。都可以监听到啦。<br>
总结：watch监听reactive/ref定义的内部属性时，监听的属性是对象，推荐写成函数形式，并且开启深度监听。</p>
<h4 id="watch的数据源写成一个数组">watch的数据源写成一个数组</h4>
<p>有些时候，我们需要监听一个对象中的几个属性或者好几个不同的对象。<br>
这个时候我们可以写成一个数组的形式</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{  person }}&lt;/h1&gt;
    &lt;button @click="allHandler"&gt;更改car这个对象&lt;/button&gt;
    &lt;button @click="oneNameHandler"&gt;更改某个属性name&lt;/button&gt;    
  &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;

import { watch, reactive } from 'vue';
const person = reactive({
  age:18,
  name:'张三',
  car:{
    c1:'电动车',
    c2:'燃油车'
  }
});
function allHandler(){
  person.car = {
    c1:'小米Su7',
    c2:'小米Yu7'
  }
}
function oneNameHandler(){
  person.name = '李四';
}

watch(()=&gt;[person.name, person.car.c1], (newValue,oldValue)=&gt;{
  console.log('newValue', newValue)
  console.log('oldValue', oldValue)
},{
  deep:true
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250727113330146-5439672.png" alt="image" loading="lazy"></p>
<h4 id="什么时候需要深度监听">什么时候需要深度监听？</h4>
<p>明明人家监听的是地址的变化，结果你想要监听某个值的变化</p>
<h4 id="再次说明watch为啥新值和旧值一样">再次说明：watch为啥新值和旧值一样？</h4>
<p>因为监听的是地址，你更改属性时，地址没有发生变化。<br>
Object.assign更改时，也是只更改了属性，并没有产生新的地址。<br>
相当于你新装修房子，你只换了灯，床，房子的地址没有发生变化。<br>
因此：新值和旧值是一样的。</p>
<h4 id="取消watch监听">取消watch监听</h4>
<p>将watch赋值给一个变量，调用这个变量。就可以停止监听了。</p>
<pre><code>import {  ref, computed, watch } from 'vue';
const age = ref(1);
function changeHandler(){
  age.value +=1
}
let stopWatch =  watch(age, (newValue,oldValue)=&gt;{
  console.log('watch监听到的值新值：',newValue,'旧值：', oldValue)
  if(newValue&gt;3){
    stopWatch()
  }
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202507/1425695-20250716192740443-1847206566.png" alt="image" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-01 08:53">2025-08-01 08:52</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19015298);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19015298', targetLink: 'https://www.cnblogs.com/IwishIcould/p/19015298', title: 'vue3中的watch详细讲解保证看的明明白白' })">举报</a>
</div>
        