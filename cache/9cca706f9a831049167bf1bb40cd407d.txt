
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zylyehuo/p/19015381" title="发布于 2025-08-08 19:46">
    <span role="heading" aria-level="2">循环神经网络的从零开始实现(RNN)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>博客地址：<a href="https://www.cnblogs.com/zylyehuo/" target="_blank">https://www.cnblogs.com/zylyehuo/</a></p>
</blockquote>
<blockquote>
<p>参考 <a href="https://zh-v2.d2l.ai/index.html" target="_blank" rel="noopener nofollow">《动手学深度学习》第二版</a></p>
</blockquote>
<h1 id="代码总览">代码总览</h1>
<pre><code class="language-python">%matplotlib inline
import math
import torch
from torch import nn
from torch.nn import functional as F
from d2l import torch as d2l
</code></pre>
<pre><code class="language-python">batch_size, num_steps = 32, 35
train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)
</code></pre>
<pre><code class="language-python"># 独热编码
</code></pre>
<pre><code class="language-python">F.one_hot(torch.tensor([0, 2]), len(vocab))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731155851056-2037463878.png" alt="image" loading="lazy"></p>
<pre><code class="language-python"># 小批量数据形状是二维张量： （批量大小，时间步数）
</code></pre>
<pre><code class="language-python">X = torch.arange(10).reshape((2, 5))
F.one_hot(X.T, 28).shape
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731155906502-1173002608.png" alt="image" loading="lazy"></p>
<pre><code class="language-python"># 初始化模型参数
</code></pre>
<pre><code class="language-python">def get_params(vocab_size, num_hiddens, device):
    num_inputs = num_outputs = vocab_size

    def normal(shape):
        return torch.randn(size=shape, device=device) * 0.01

    # 隐藏层参数
    W_xh = normal((num_inputs, num_hiddens))
    W_hh = normal((num_hiddens, num_hiddens))  # 这行若没有，就是一个单隐藏层的 MLP
    b_h = torch.zeros(num_hiddens, device=device)
    # 输出层参数
    W_hq = normal((num_hiddens, num_outputs))
    b_q = torch.zeros(num_outputs, device=device)
    # 附加梯度
    params = [W_xh, W_hh, b_h, W_hq, b_q]
    for param in params:
        param.requires_grad_(True)
    return params
</code></pre>
<pre><code class="language-python"># 一个 init_rnn_state 函数在初始化时返回隐状态
</code></pre>
<pre><code class="language-python">def init_rnn_state(batch_size, num_hiddens, device):
    return (torch.zeros((batch_size, num_hiddens), device=device), )
</code></pre>
<pre><code class="language-python"># 下面的rnn函数定义了如何在一个时间步内计算隐状态和输出
</code></pre>
<pre><code class="language-python">def rnn(inputs, state, params):
    # inputs的形状：(时间步数量，批量大小，词表大小)
    W_xh, W_hh, b_h, W_hq, b_q = params
    H, = state
    outputs = []
    # X的形状：(批量大小，词表大小)
    for X in inputs:
        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)
        Y = torch.mm(H, W_hq) + b_q
        outputs.append(Y)
    return torch.cat(outputs, dim=0), (H,)
</code></pre>
<pre><code class="language-python"># 创建一个类来包装这些函数， 并存储从零开始实现的循环神经网络模型的参数
</code></pre>
<pre><code class="language-python">class RNNModelScratch:
    """从零开始实现的循环神经网络模型"""
    def __init__(self, vocab_size, num_hiddens, device,
                 get_params, init_state, forward_fn):
        self.vocab_size, self.num_hiddens = vocab_size, num_hiddens
        self.params = get_params(vocab_size, num_hiddens, device)
        self.init_state, self.forward_fn = init_state, forward_fn

    def __call__(self, X, state):
        X = F.one_hot(X.T, self.vocab_size).type(torch.float32)
        return self.forward_fn(X, state, self.params)

    def begin_state(self, batch_size, device):
        return self.init_state(batch_size, self.num_hiddens, device)
</code></pre>
<pre><code class="language-python"># 检查输出是否具有正确的形状
</code></pre>
<pre><code class="language-python">num_hiddens = 512
net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params,
                      init_rnn_state, rnn)
state = net.begin_state(X.shape[0], d2l.try_gpu())
</code></pre>
<pre><code class="language-python">Y, new_state = net(X.to(d2l.try_gpu()), state)
Y.shape, len(new_state), new_state[0].shape
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731155927365-1811948865.png" alt="image" loading="lazy"></p>
<pre><code class="language-python"># 首先定义预测函数来生成prefix之后的新字符
</code></pre>
<pre><code class="language-python">def predict_ch8(prefix, num_preds, net, vocab, device):
    """在prefix后面生成新字符"""
    state = net.begin_state(batch_size=1, device=device)
    outputs = [vocab[prefix[0]]]
    get_input = lambda: torch.tensor([outputs[-1]], device=device).reshape((1, 1))
    for y in prefix[1:]:  # 预热期
        _, state = net(get_input(), state)
        outputs.append(vocab[y])
    for _ in range(num_preds):  # 预测num_preds步
        y, state = net(get_input(), state)
        outputs.append(int(y.argmax(dim=1).reshape(1)))
    return ''.join([vocab.idx_to_token[i] for i in outputs])
</code></pre>
<pre><code class="language-python">predict_ch8('time traveller ', 10, net, vocab, d2l.try_gpu())
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731155945875-2101583730.png" alt="image" loading="lazy"></p>
<pre><code class="language-python"># 梯度裁剪
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731155952920-1181207870.png" alt="image" loading="lazy"></p>
<pre><code class="language-python">def grad_clipping(net, theta):
    """裁剪梯度"""
    if isinstance(net, nn.Module):
        params = [p for p in net.parameters() if p.requires_grad]
    else:
        params = net.params
    norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params))
    if norm &gt; theta:
        for param in params:
            param.grad[:] *= theta / norm
</code></pre>
<pre><code class="language-python"># 定义一个函数在一个迭代周期内训练模型
</code></pre>
<pre><code class="language-python">def train_epoch_ch8(net, train_iter, loss, updater, device, use_random_iter):
    """训练网络一个迭代周期（定义见第8章）"""
    state, timer = None, d2l.Timer()
    metric = d2l.Accumulator(2)  # 训练损失之和,词元数量
    for X, Y in train_iter:
        if state is None or use_random_iter:
            # 在第一次迭代或使用随机抽样时初始化state
            state = net.begin_state(batch_size=X.shape[0], device=device)
        else:
            if isinstance(net, nn.Module) and not isinstance(state, tuple):
                # state对于nn.GRU是个张量
                state.detach_()
            else:
                # state对于nn.LSTM或对于我们从零开始实现的模型是个张量
                for s in state:
                    s.detach_()
        y = Y.T.reshape(-1)
        X, y = X.to(device), y.to(device)
        y_hat, state = net(X, state)
        l = loss(y_hat, y.long()).mean()
        if isinstance(updater, torch.optim.Optimizer):
            updater.zero_grad()
            l.backward()
            grad_clipping(net, 1)
            updater.step()
        else:
            l.backward()
            grad_clipping(net, 1)
            # 因为已经调用了mean函数
            updater(batch_size=1)
        metric.add(l * y.numel(), y.numel())
    return math.exp(metric[0] / metric[1]), metric[1] / timer.stop()
</code></pre>
<pre><code class="language-python"># 循环神经网络模型的训练函数既支持从零开始实现， 也可以使用高级API来实现
</code></pre>
<pre><code class="language-python">def train_ch8(net, train_iter, vocab, lr, num_epochs, device,
              use_random_iter=False):
    """训练模型（定义见第8章）"""
    loss = nn.CrossEntropyLoss()
    animator = d2l.Animator(xlabel='epoch', ylabel='perplexity',
                            legend=['train'], xlim=[10, num_epochs])
    # 初始化
    if isinstance(net, nn.Module):
        updater = torch.optim.SGD(net.parameters(), lr)
    else:
        updater = lambda batch_size: d2l.sgd(net.params, lr, batch_size)
    predict = lambda prefix: predict_ch8(prefix, 50, net, vocab, device)
    # 训练和预测
    for epoch in range(num_epochs):
        ppl, speed = train_epoch_ch8(
            net, train_iter, loss, updater, device, use_random_iter)
        if (epoch + 1) % 10 == 0:
            print(predict('time traveller'))
            animator.add(epoch + 1, [ppl])
    print(f'困惑度 {ppl:.1f}, {speed:.1f} 词元/秒 {str(device)}')
    print(predict('time traveller'))
    print(predict('traveller'))
</code></pre>
<pre><code class="language-python"># 现在，我们训练循环神经网络模型
</code></pre>
<pre><code class="language-python">num_epochs, lr = 500, 1
</code></pre>
<pre><code class="language-python">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu())
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731160021078-867306217.png" alt="image" loading="lazy"></p>
<pre><code class="language-python"># 最后，让我们检查一下使用随机抽样方法的结果
</code></pre>
<pre><code class="language-python">net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params, init_rnn_state, rnn)
</code></pre>
<pre><code class="language-python">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu(), use_random_iter=True)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3071480/202507/3071480-20250731160032980-1393937109.png" alt="image" loading="lazy"></p>
<h1 id="代码解释">代码解释</h1>
<h2 id="1-初始设置与数据准备">1. 初始设置与数据准备</h2>
<pre><code class="language-python">%matplotlib inline
import math
import torch
from torch import nn
from torch.nn import functional as F
from d2l import torch as d2l
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>%matplotlib inline: 在Jupyter Notebook中内嵌显示matplotlib图形</p>
</li>
<li>
<p>import math: 导入数学计算模块</p>
</li>
<li>
<p>import torch: 导入PyTorch深度学习框架</p>
</li>
<li>
<p>from torch import nn: 导入PyTorch的神经网络模块</p>
</li>
<li>
<p>from torch.nn import functional as F: 导入PyTorch的函数模块</p>
</li>
<li>
<p>from d2l import torch as d2l: 导入《动手学深度学习》的配套工具库</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">batch_size, num_steps = 32, 35
train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>设置批量大小为32，时间步数为35</p>
</li>
<li>
<p>加载时间机器数据集：</p>
<ul>
<li>
<p><strong>d2l.load_data_time_machine()</strong> 函数加载并预处理数据</p>
</li>
<li>
<p>返回数据迭代器(train_iter)和词汇表(vocab)</p>
</li>
<li>
<p>词汇表大小：28个字符（小写字母+空格+标点）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-数据预处理与表示">2. 数据预处理与表示</h2>
<pre><code class="language-python"># 独热编码
F.one_hot(torch.tensor([0, 2]), len(vocab))
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>演示如何将整数索引转换为独热编码</p>
</li>
<li>
<p>输入：[0, 2]（两个字符的索引）</p>
</li>
<li>
<p>输出：形状为(2, 28)的张量，每行对应一个字符的独热编码</p>
</li>
<li>
<p>例如：索引0 → [1,0,0,...]，索引2 → [0,0,1,0,...]</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 小批量数据形状是二维张量： （批量大小，时间步数）
X = torch.arange(10).reshape((2, 5))
F.one_hot(X.T, 28).shape
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>创建示例数据：2个样本，每个样本5个时间步</p>
</li>
<li>
<p>转置数据：从(2,5)变为(5,2)</p>
</li>
<li>
<p>应用独热编码：得到形状(5, 2, 28)</p>
</li>
<li>
<p>这表示：5个时间步，2个样本，每个时间步是28维的独热向量</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-模型参数初始化">3. 模型参数初始化</h2>
<pre><code class="language-python"># 初始化模型参数
def get_params(vocab_size, num_hiddens, device):
    num_inputs = num_outputs = vocab_size

    def normal(shape):
        return torch.randn(size=shape, device=device) * 0.01

    # 隐藏层参数
    W_xh = normal((num_inputs, num_hiddens))
    W_hh = normal((num_hiddens, num_hiddens))  # 这行若没有，就是一个单隐藏层的 MLP
    b_h = torch.zeros(num_hiddens, device=device)
    # 输出层参数
    W_hq = normal((num_hiddens, num_outputs))
    b_q = torch.zeros(num_outputs, device=device)
    # 附加梯度
    params = [W_xh, W_hh, b_h, W_hq, b_q]
    for param in params:
        param.requires_grad_(True)
    return params
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>初始化RNN的五个关键参数：</p>
<ul>
<li>
<p>W_xh: 输入到隐藏层的权重 (28×512)</p>
</li>
<li>
<p>W_hh: 隐藏层到隐藏层的权重 (512×512) - RNN的关键！</p>
</li>
<li>
<p>b_h: 隐藏层偏置 (512,)</p>
</li>
<li>
<p>W_hq: 隐藏层到输出层的权重 (512×28)</p>
</li>
<li>
<p>b_q: 输出层偏置 (28,)</p>
</li>
</ul>
</li>
<li>
<p>使用小随机数初始化权重(标准差0.01)</p>
</li>
<li>
<p>偏置初始化为0</p>
</li>
<li>
<p>所有参数设置为需要梯度计算</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-隐藏状态初始化">4. 隐藏状态初始化</h2>
<pre><code class="language-python"># 一个 init_rnn_state 函数在初始化时返回隐状态
def init_rnn_state(batch_size, num_hiddens, device):
    return (torch.zeros((batch_size, num_hiddens), device=device), )
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>创建初始隐藏状态(H0)</p>
</li>
<li>
<p>形状：(batch_size, num_hiddens) = (32, 512)</p>
</li>
<li>
<p>全部初始化为0</p>
</li>
<li>
<p>返回元组格式(为了与LSTM等更复杂模型兼容)</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-rnn前向传播">5. RNN前向传播</h2>
<pre><code class="language-python"># 下面的rnn函数定义了如何在一个时间步内计算隐状态和输出
def rnn(inputs, state, params):
    # inputs的形状：(时间步数量，批量大小，词表大小)
    W_xh, W_hh, b_h, W_hq, b_q = params
    H, = state
    outputs = []
    # X的形状：(批量大小，词表大小)
    for X in inputs:
        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)
        Y = torch.mm(H, W_hq) + b_q
        outputs.append(Y)
    return torch.cat(outputs, dim=0), (H,)
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>RNN核心计算逻辑</p>
</li>
<li>
<p>遍历每个时间步：</p>
<ul>
<li>
<p>计算新隐藏状态：H = tanh(X·W_xh + H·W_hh + b_h)</p>
</li>
<li>
<p>计算当前输出：Y = H·W_hq + b_q</p>
</li>
</ul>
</li>
<li>
<p>拼接所有时间步的输出</p>
</li>
<li>
<p>返回输出序列和最终隐藏状态</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-rnn模型封装">6. RNN模型封装</h2>
<pre><code class="language-python"># 创建一个类来包装这些函数， 并存储从零开始实现的循环神经网络模型的参数
class RNNModelScratch:
    """从零开始实现的循环神经网络模型"""
    def __init__(self, vocab_size, num_hiddens, device,
                 get_params, init_state, forward_fn):
        self.vocab_size, self.num_hiddens = vocab_size, num_hiddens
        self.params = get_params(vocab_size, num_hiddens, device)
        self.init_state, self.forward_fn = init_state, forward_fn

    def __call__(self, X, state):
        X = F.one_hot(X.T, self.vocab_size).type(torch.float32)
        return self.forward_fn(X, state, self.params)

    def begin_state(self, batch_size, device):
        return self.init_state(batch_size, self.num_hiddens, device)
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>封装RNN模型为可调用类</p>
</li>
<li>
<p>__init__: 初始化参数和前向函数</p>
</li>
<li>
<p>__call__:</p>
<ul>
<li>
<p>将输入转换为独热编码</p>
</li>
<li>
<p>调用前向传播函数</p>
</li>
</ul>
</li>
<li>
<p>begin_state: 创建初始隐藏状态</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-模型验证与文本生成">7. 模型验证与文本生成</h2>
<pre><code class="language-python"># 检查输出是否具有正确的形状
num_hiddens = 512
net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params,
                      init_rnn_state, rnn)
state = net.begin_state(X.shape[0], d2l.try_gpu())
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>实例化RNN模型</p>
</li>
<li>
<p>创建初始隐藏状态</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">Y, new_state = net(X.to(d2l.try_gpu()), state)
Y.shape, len(new_state), new_state[0].shape
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>执行前向传播</p>
</li>
<li>
<p>验证输出形状：(时间步×批量大小, 词汇表大小) = (10, 28)</p>
</li>
<li>
<p>验证隐藏状态形状：(批量大小, 隐藏单元数) = (2, 512)</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 首先定义预测函数来生成prefix之后的新字符
def predict_ch8(prefix, num_preds, net, vocab, device):
    """在prefix后面生成新字符"""
    state = net.begin_state(batch_size=1, device=device)
    outputs = [vocab[prefix[0]]]
    get_input = lambda: torch.tensor([outputs[-1]], device=device).reshape((1, 1))
    for y in prefix[1:]:  # 预热期
        _, state = net(get_input(), state)
        outputs.append(vocab[y])
    for _ in range(num_preds):  # 预测num_preds步
        y, state = net(get_input(), state)
        outputs.append(int(y.argmax(dim=1).reshape(1))
    return ''.join([vocab.idx_to_token[i] for i in outputs])
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>初始化隐藏状态</p>
</li>
<li>
<p>预热期：用前缀字符初始化状态</p>
</li>
<li>
<p>预测期：用模型预测下一个字符</p>
</li>
<li>
<p>将预测结果转换为字符串</p>
</li>
</ul>
</li>
</ul>
<h2 id="8-训练准备梯度裁剪">8. 训练准备：梯度裁剪</h2>
<pre><code class="language-python"># 梯度裁剪
def grad_clipping(net, theta):
    """裁剪梯度"""
    if isinstance(net, nn.Module):
        params = [p for p in net.parameters() if p.requires_grad]
    else:
        params = net.params
    norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params))
    if norm &gt; theta:
        for param in params:
            param.grad[:] *= theta / norm
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>防止梯度爆炸</p>
</li>
<li>
<p>计算所有参数梯度的L2范数</p>
</li>
<li>
<p>如果范数超过阈值(theta=1)，等比例缩小梯度</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-训练循环实现">9. 训练循环实现</h2>
<pre><code class="language-python"># 定义一个函数在一个迭代周期内训练模型
def train_epoch_ch8(net, train_iter, loss, updater, device, use_random_iter):
    """训练网络一个迭代周期（定义见第8章）"""
    state, timer = None, d2l.Timer()
    metric = d2l.Accumulator(2)  # 训练损失之和,词元数量
    for X, Y in train_iter:
        if state is None or use_random_iter:
            # 在第一次迭代或使用随机抽样时初始化state
            state = net.begin_state(batch_size=X.shape[0], device=device)
        else:
            if isinstance(net, nn.Module) and not isinstance(state, tuple):
                # state对于nn.GRU是个张量
                state.detach_()
            else:
                # state对于nn.LSTM或对于我们从零开始实现的模型是个张量
                for s in state:
                    s.detach_()
        y = Y.T.reshape(-1)
        X, y = X.to(device), y.to(device)
        y_hat, state = net(X, state)
        l = loss(y_hat, y.long()).mean()
        if isinstance(updater, torch.optim.Optimizer):
            updater.zero_grad()
            l.backward()
            grad_clipping(net, 1)
            updater.step()
        else:
            l.backward()
            grad_clipping(net, 1)
            # 因为已经调用了mean函数
            updater(batch_size=1)
        metric.add(l * y.numel(), y.numel())
    return math.exp(metric[0] / metric[1]), metric[1] / timer.stop()
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>管理隐藏状态（初始化或分离）</p>
</li>
<li>
<p>准备数据（移动到设备）</p>
</li>
<li>
<p>前向传播</p>
</li>
<li>
<p>计算损失（交叉熵）</p>
</li>
<li>
<p>反向传播</p>
</li>
<li>
<p>梯度裁剪</p>
</li>
<li>
<p>参数更新</p>
</li>
<li>
<p>计算困惑度(perplexity)和训练速度</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 循环神经网络模型的训练函数既支持从零开始实现， 也可以使用高级API来实现
def train_ch8(net, train_iter, vocab, lr, num_epochs, device,
              use_random_iter=False):
    """训练模型（定义见第8章）"""
    loss = nn.CrossEntropyLoss()
    animator = d2l.Animator(xlabel='epoch', ylabel='perplexity',
                            legend=['train'], xlim=[10, num_epochs])
    # 初始化
    if isinstance(net, nn.Module):
        updater = torch.optim.SGD(net.parameters(), lr)
    else:
        updater = lambda batch_size: d2l.sgd(net.params, lr, batch_size)
    predict = lambda prefix: predict_ch8(prefix, 50, net, vocab, device)
    # 训练和预测
    for epoch in range(num_epochs):
        ppl, speed = train_epoch_ch8(
            net, train_iter, loss, updater, device, use_random_iter)
        if (epoch + 1) % 10 == 0:
            print(predict('time traveller'))
            animator.add(epoch + 1, [ppl])
    print(f'困惑度 {ppl:.1f}, {speed:.1f} 词元/秒 {str(device)}')
    print(predict('time traveller'))
    print(predict('traveller'))
</code></pre>
<ul>
<li>
<p>功能：</p>
<ul>
<li>
<p>设置损失函数和可视化</p>
</li>
<li>
<p>初始化优化器</p>
</li>
<li>
<p>每10个epoch生成预测文本</p>
</li>
<li>
<p>绘制困惑度曲线</p>
</li>
<li>
<p>输出最终训练结果</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-模型训练执行">10. 模型训练执行</h2>
<pre><code class="language-python"># 训练循环神经网络模型
num_epochs, lr = 500, 1
</code></pre>
<ul>
<li>功能：设置训练轮数(500)和学习率(1)</li>
</ul>
<pre><code class="language-python">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu())
</code></pre>
<ul>
<li>功能：执行训练（顺序采样）</li>
</ul>
<pre><code class="language-python"># 最后，检查一下使用随机抽样方法的结果
net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params, init_rnn_state, rnn)
</code></pre>
<ul>
<li>功能：重新初始化模型（确保公平比较）</li>
</ul>
<pre><code class="language-python">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu(), use_random_iter=True)
</code></pre>
<ul>
<li>功能：执行训练（随机采样）</li>
</ul>
<h1 id="关键执行流程总结">关键执行流程总结</h1>
<h2 id="1-数据流">1. 数据流</h2>
<ul>
<li>
<p>文本数据 → 字符索引 → 独热编码</p>
</li>
<li>
<p>输入形状：(批量大小, 时间步数) → (时间步数, 批量大小, 词汇表大小)</p>
</li>
</ul>
<h2 id="2-模型流">2. 模型流</h2>
<pre><code class="language-bash">输入X → 独热编码 → RNN单元 → 隐藏状态H → 输出Y
         ↑        ↓
         └───[H]──┘
</code></pre>
<h2 id="3-训练流">3. 训练流</h2>
<pre><code class="language-bash">for epoch in 500:
    初始化隐藏状态
    for batch in 数据迭代器:
        前向传播 → 计算损失 → 反向传播 → 梯度裁剪 → 更新参数
    每10个epoch：生成文本并显示困惑度
</code></pre>
<h2 id="4-文本生成流">4. 文本生成流</h2>
<pre><code class="language-bash">给定前缀 → 预热状态 → 循环生成字符 → 拼接结果
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-08 19:47">2025-08-08 19:46</span>&nbsp;
<a href="https://www.cnblogs.com/zylyehuo">zylyehuo</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19015381);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19015381', targetLink: 'https://www.cnblogs.com/zylyehuo/p/19015381', title: '循环神经网络的从零开始实现(RNN)' })">举报</a>
</div>
        