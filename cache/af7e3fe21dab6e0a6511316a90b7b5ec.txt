
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/emanjusaka/p/18709398" title="发布于 2025-02-11 11:15">
    <span role="heading" aria-level="2">Java 中堆内存和栈内存上的数据分布和特点</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3230488/202502/3230488-20250211111404941-1042483306.png" alt="Java 中堆内存和栈内存上的数据分布和特点" class="desc_img">
        说到 Java 中内存我们一般笼统地划分为堆内存（Heap）和栈内存（Stack），那么哪些数据被放置在堆内存？哪些数据被放置在栈内存？这些数据的分布有什么特点吗？
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>博客：<a href="https://www.emanjusaka.com" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com</a><br>
博客园：<a href="https://www.cnblogs.com/emanjusaka" target="_blank">https://www.cnblogs.com/emanjusaka</a><br>
公众号：emanjusaka的编程栈</p>
<blockquote>
<p>by <a href="https://www.emanjusaka.com" target="_blank" rel="noopener nofollow">emanjusaka</a> from <a href="https://www.emanjusaka.com/archives/java-heap-stack-distribution-feature" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com/archives/java-heap-stack-distribution-feature</a><br>
本文为原创文章，可能会更新知识点以及修正文中的一些错误，全文转载请保留原文地址，避免产生因未即时修正导致的误导。</p>
</blockquote>
<p>经常有人把 Java 内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的 C、C++程序的内存布局结构，在 Java 语言就显得有些粗糙了，实际的内存区域划分是要更复杂一下。如下所示：</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/30-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.webp" alt="30-内存管理" loading="lazy"></p>
<p>方法区、堆是由所有线程共享的数据区。虚拟机栈、本地方法栈和程序计数器是线程隔离的数据区。</p>
<p>我们最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中“栈”通常就是指这里的虚拟机栈，更多情况下只是指虚拟机栈中局部变量表部分。下面我们详细分析一下堆内存和栈内存的数据分布。</p>
<h2 id="问题哪些数据放在栈上哪些数据放在堆上">问题：哪些数据放在栈上，哪些数据放在堆上？</h2>
<p>如果你擅长 Java 这种内存自动管理的语言，这个问题很好回答。</p>
<p>栈上的数据：</p>
<ul>
<li>
<p>基本数据类型（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>）</p>
</li>
<li>
<p>对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的应用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）</p>
</li>
<li>
<p>returnAddress 类型（指向了一条字节码指令的地址）</p>
</li>
</ul>
<p>堆上数据：</p>
<ul>
<li>
<p>普通对象：各种类的实例。</p>
</li>
<li>
<p>数组：数组是一种特殊类型的对象，可以存储多个相同类型的元素。</p>
</li>
<li>
<p>基本类型包装器对象：Java 提供了一些基本类型的包装器类：如 Integer、Double、Character 等。</p>
</li>
</ul>
<h2 id="栈和堆内存上的数据特点">栈和堆内存上的数据特点</h2>
<p>我们先来分析下程序中的栈和堆，然后总结出它们的特点。</p>
<h3 id="stack">Stack</h3>
<p>栈的数据结构特点是先进后出。由于这个特点，非常适合记录程序的函数调用，也称为函数调用栈。函数调用栈从下到上增长，每当函数执行时，就会在栈顶部分分配一块连续的内存，称为帧。这个帧存储了当前函数的通用寄存器和当前函数的局部变量的上下文信息。下面给出一个简单的 Java 函数调用，我们分析一下这个过程：</p>
<pre><code class="language-java">&nbsp;public class StackExample {  
&nbsp; &nbsp; &nbsp;public static void main(String[] args) {  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int result = add(3, 5);  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("结果是： " + result);  
&nbsp; &nbsp;  }  
&nbsp;​  
&nbsp; &nbsp; &nbsp;public static int add(int a, int b) {  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return a + b;  
&nbsp; &nbsp;  }  
&nbsp;} 

在这个例子中，`main`函数调用了`add`函数。当`main`函数开始执行时，会在栈内存中为`main`函数分配一块空间，包括局部变量`result`和参数`args`。然后，`main`函数调用`add`函数，此时会在栈内存中为`add`函数分配另一块空间，包括局部变量`a`、`b`和返回地址。当`add`函数执行完毕后，其占用的栈空间会被释放，控制权返回给`main`函数。最后，`main`函数执行完毕，整个程序结束。

通常情况下，它需要连续的内存空间，这意味着程序在调用下一个函数之前必须知道下一个函数需要多少内存空间。但是程序是怎样知道的呢？

答案是编译器为我们完成了这一切。当编译代码时，函数是一个最小的编译单位。每当编译器遇到一个函数时，它就知道当前函数使用寄存器和局部变量所需的空间。

因此，无法在编译时确定大小或可以更改大小的数据是不能安全地放置在栈上的。

### Heap

有些数据不能安全地放在栈上，所以最好放在堆上，比如下面的ArrayList：

```java
&nbsp;import java.util.ArrayList;
&nbsp;public class VariableLengthArrayExample {
&nbsp; &nbsp; &nbsp;public static void main(String[] args) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 创建一个空的 ArrayList
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 向 ArrayList 中添加元素
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arrayList.add(1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arrayList.add(2);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arrayList.add(3);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 输出 ArrayList 的大小
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("Size of the ArrayList: " + arrayList.size());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 访问 ArrayList 中的元素  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; arrayList.size(); i++) {  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("Element at index " + i + ": " + arrayList.get(i));  
&nbsp; &nbsp; &nbsp; &nbsp;  }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 删除 ArrayList 中的一个元素  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arrayList.remove(1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 再次输出 ArrayList 的大小和内容  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("Size of the ArrayList after removal: " + arrayList.size());  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; arrayList.size(); i++) {  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("Element at index " + i + ": " + arrayList.get(i));  
&nbsp; &nbsp; &nbsp; &nbsp;  }
&nbsp; &nbsp;  }
&nbsp;}
</code></pre>
<p>当创建一个ArrayList 时，程序需要动态的分配内存。如果数组的实际使用量超过了这个容量，程序会分配一个更大的内存块，将现有元素复制到其中，添加新元素，然后释放旧内存。此过程允许数组根据需要动态调整大小。请求系统调用并找到新的内存然后一一复制的过程是非常低效的。所以这里最好的做法是提前预留需要的空间。</p>
<p>另外，需要跨栈引用的内存也需要放在堆上，这很好理解，因为一旦一个栈帧被回收，其内部的局部变量也会被回收，所以在不同的调用栈中共享数据只能使用堆。</p>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>栈上存储的数据是静态的，大小固定，生命周期固定，线程隔离不能跨栈引用。</p>
</li>
<li>
<p>堆上存储的数据是动态的、不固定大小、不固定生命周期、线程共享可以跨栈引用。</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《深入理解 Java 虚拟机（第 3 版）》——周志明</li>
</ul>
<p><img src="https://file.emanjusaka.top/emanjusaka/30-yiyan.webp" alt="30-yiyan" loading="lazy"></p>
<blockquote>
<p>谦学于心，谷纳万物，静思致远，共筑收获之旅！<br>
原文地址： <a href="https://www.emanjusaka.com/archives/java-heap-stack-distribution-feature" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com/archives/java-heap-stack-distribution-feature</a><br>
微信公众号：emanjusaka的编程栈</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04305654209722222" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 11:16">2025-02-11 11:15</span>&nbsp;
<a href="https://www.cnblogs.com/emanjusaka">emanjusaka</a>&nbsp;
阅读(<span id="post_view_count">44</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18709398" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18709398);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18709398', targetLink: 'https://www.cnblogs.com/emanjusaka/p/18709398', title: 'Java 中堆内存和栈内存上的数据分布和特点' })">举报</a>
</div>
        