
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/18962457" title="发布于 2025-07-02 22:23">
    <span role="heading" aria-level="2">Golang基础笔记八之函数</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/2SRZttLbfD2n1J5fwDvvUQ" target="_blank" rel="noopener nofollow">Golang基础笔记八之函数</a></p>
</blockquote>
<p>本篇笔记介绍 Golang 里函数相关的内容，以下是本篇笔记目录：</p>
<ol>
<li>函数的定义语法</li>
<li>函数返回值</li>
<li>可变参数函数</li>
<li>匿名函数</li>
<li>闭包</li>
</ol>
<h3 id="1函数的定义语法">1、函数的定义语法</h3>
<p>函数的定义格式如下：</p>
<pre><code class="language-go">func 函数名(参数列表) (返回值列表) { 函数体 }
</code></pre>
<p>比如下面是一个两数相加返回其和的函数：</p>
<pre><code class="language-go">func add(a, b int) int {
&nbsp; &nbsp; return a + b
}
</code></pre>
<p>调用的话，直接传参调用即可：</p>
<pre><code class="language-go">sum := add(1, 4)
fmt.Println(sum)
</code></pre>
<p>传入的参数可以传值，也可以传指针，如果传指针的话，在函数内部修改后，会影响原值。</p>
<p>以下是一个传指针修改的示例：</p>
<pre><code class="language-go">func test(a *int, b int) {
&nbsp; &nbsp; *a += 2
&nbsp; &nbsp; b += 2
}
func main() {
&nbsp; &nbsp; a := 1
&nbsp; &nbsp; b := 1
&nbsp; &nbsp; fmt.Printf("调用前 a:%d, b:%d\n", a, b)
&nbsp; &nbsp; test(&amp;a, b)
&nbsp; &nbsp; fmt.Printf("调用后 a:%d, b:%d\n", a, b)
}
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-go">调用前 a:1, b:1
调用后 a:3, b:1
</code></pre>
<h3 id="2函数返回值">2、函数返回值</h3>
<p>函数返回值可以返回单个或多个，在函数定义的时候指定返回类型即可：</p>
<pre><code class="language-go">func add(a, b int) int {
&nbsp; &nbsp; return a + b
}
func swap(a, b int) (int, int) {
&nbsp; &nbsp; return b, a
}
</code></pre>
<p>还可以对返回值命名，就是在定义函数的时候，将返回值提前声明定义，然后在函数内部对其赋值，函数末尾可以省去 return 具体变量的操作。</p>
<p>比如下面：</p>
<pre><code class="language-go">func calc(a, b int) (sum, sub int) {
&nbsp; &nbsp; sum = a + b
&nbsp; &nbsp; sub = a - b
&nbsp; &nbsp; return
}
</code></pre>
<h3 id="3可变参数函数">3、可变参数函数</h3>
<p>可变参数函数可以接受任意数量的参数，在函数定义的时候，类型前面加上 <code>...</code> 即表示该参数是可变参数，而在函数内部，可将其作为切片使用。</p>
<p>下面是一个示例，可以接受任意多个元素，作为求和函数的参数：</p>
<pre><code class="language-go">func sum(nums ...int) int {
&nbsp; &nbsp; total := 0
&nbsp; &nbsp; for _, num := range nums {
&nbsp; &nbsp; &nbsp; &nbsp; total += num
&nbsp; &nbsp; }
&nbsp; &nbsp; return total
}
</code></pre>
<p>调用的时候，可以直接传入任意数量参数：</p>
<pre><code class="language-go">sum(1, 2, 3, 4)
</code></pre>
<p>也可以传入一个切片：</p>
<pre><code class="language-go">slice := []int{1, 2, 3}
s2 := sum(slice...)
</code></pre>
<h3 id="4匿名函数">4、匿名函数</h3>
<p>匿名函数通常用于临时需要处理某个功能，或需要将其作为参数传递给其他变量的场景。<br>
比如下面定义并立即调用了匿名函数：</p>
<pre><code class="language-go">total := func(a, b int) int {
&nbsp; &nbsp; return a + b
}(2, 4)
</code></pre>
<p>也可以将其赋值给某个变量，再由该变量来调用：</p>
<pre><code class="language-go">sumFunc := func(a, b int) int {
&nbsp; &nbsp; return a + b
}
sumFunc(1, 2)
</code></pre>
<h3 id="5闭包">5、闭包</h3>
<p>闭包是指能够读取其他函数内部变量的函数，即使该函数已经执行完毕，其作用域内的变量也不会被销毁。</p>
<p>我们可以使用闭包来捕获外部函数的局部变量，并将其生命周期延长至闭包本身，比如实现一个计数器：</p>
<pre><code class="language-go">func counter() func() int {
    count := 0
    return func() int {
        count += 1
        return count
    }
}

counterFunc := counter()
fmt.Println(counterFunc())
fmt.Println(counterFunc())
fmt.Println(counterFunc())
fmt.Println(counterFunc())
</code></pre>
<p>也可以根据外部传入的参数生成不同的闭包实例，比如实现一个计算器：</p>
<pre><code class="language-go">func calculate(calculate_type string) func(a, b int) int {
    if calculate_type == "add" {
        return func(a, b int) int {
            return a + b
        }
    } else if calculate_type == "sub" {
        return func(a, b int) int {
            return a - b
        }
    } else {
        return func(a, b int) int { return a + b }
    }
}


addFunc := calculate("add")
fmt.Println(addFunc(10, 5))

subFunc := calculate("sub")
fmt.Println(subFunc(3, 1))
</code></pre>
<p>而闭包也可以维护迭代的状态，因此可以实现迭代器的功能，比如实现一个斐波那契数列生成器：</p>
<pre><code class="language-go">func fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        f_count := a
        a, b = b, a+b
        return f_count
    }
}

f := fibonacci()
fmt.Println(f())
fmt.Println(f())
fmt.Println(f())
fmt.Println(f())
fmt.Println(f())
fmt.Println(f())
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-02 22:24">2025-07-02 22:23</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18962457);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18962457', targetLink: 'https://www.cnblogs.com/hunterxiong/p/18962457', title: 'Golang基础笔记八之函数' })">举报</a>
</div>
        