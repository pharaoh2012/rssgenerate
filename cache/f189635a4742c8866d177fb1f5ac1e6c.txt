<!----> <meta itemprop="headline" content="autohue.js：让你的图片和背景融为一体，绝了！"> <meta itemprop="keywords" content="前端,JavaScript,算法"> <meta itemprop="datePublished" content="2025-02-17T02:00:49.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="德莱厄斯"> <meta itemprop="url" content="https://juejin.cn/user/3919115686512942"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-38a6c62f="">
            autohue.js：让你的图片和背景融为一体，绝了！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-38a6c62f=""><div class="author-info-box" data-v-38a6c62f=""><div class="author-name" data-v-38a6c62f=""><a href="/user/3919115686512942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-38a6c62f=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    德莱厄斯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-38a6c62f=""><time datetime="2025-02-17T02:00:49.000Z" title="Mon Feb 17 2025 02:00:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-38a6c62f="">
                    2025-02-17
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-38a6c62f=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-38a6c62f=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-38a6c62f=""></circle></svg> <span class="views-count" data-v-38a6c62f="">
                    11,065
                  </span> <span class="read-time" data-v-38a6c62f=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-38a6c62f=""><rect width="16" height="16" fill="none" data-v-38a6c62f=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-38a6c62f=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-38a6c62f=""></path></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-38a6c62f=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-38a6c62f=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">需求</h2>
<p>先来看这样一个场景，拿一个网站举例</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d77846da42f4496b3fce343a1100180~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=VY4XkdQ44t4HiM3FcvHkkQz%2Fe%2Bk%3D" alt="image.png" loading="lazy"></p>
<p>这里有一个常见的网站 banner 图容器，大小为为1910*560，看起来背景图完美的充满了宽度，但是图片原始大小时，却是：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a7921b1792c470287a9d227155ca679~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=wwjgkYIN7OfWGb2agYq%2BrTHj%2FpU%3D" alt="image.png" loading="lazy"></p>
<p>它的宽度只有 1440，且 background-size 设置的是 contain ，即等比例缩放，那么可以断定它两边的蓝色是依靠背景色填充的。</p>
<p><strong>那么问题来了</strong>，这是一个 轮播banner，如果希望添加一张不是蓝色的图片呢？难道要给每张图片提前标注好背景颜色吗？这显然是非常死板的做法。</p>
<p>所以需要从图片中提取到图片的主题色，当然这对于 js 来说，也不是什么难事，市面上已经有众多的开源库供我们使用。</p>
<h2 data-id="heading-1">探索</h2>
<p>首先在网络上找到了以下几个库：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flokesh%2Fcolor-thief" target="_blank" title="https://github.com/lokesh/color-thief" ref="nofollow noopener noreferrer">color-thief</a> 这是一款基于 JavaScript 和 Canvas 的工具，能够从图像中提取主要颜色或代表性的调色板</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjariz%2Fvibrant.js" target="_blank" title="https://github.com/jariz/vibrant.js" ref="nofollow noopener noreferrer">vibrant.js </a> 该插件是 Android 支持库中 Palette 类的 JavaScript 版本，可以从图像中提取突出的颜色</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbriangonzalez%2Frgbaster.js" target="_blank" title="https://github.com/briangonzalez/rgbaster.js" ref="nofollow noopener noreferrer">rgbaster.js</a> 这是一段小型脚本，可以获取图片的主色、次色等信息，方便实现一些精彩的 Web 交互效果</li>
</ul>
<p>我取最轻量化的 rgbaster.js（此库非常搞笑，用TS编写，npm 包却没有指定 types） 来测试后发现，它给我在一个渐变色图片中，返回了七万多个色值，当然，它准确的提取出了面积最大的色值，但是这个色值不是图片边缘的颜色，导致设置为背景色后，并不能完美的融合。</p>
<p>另外的插件各位可以参考这几篇文章：</p>
<ul>
<li>文章1：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42998707%2Farticle%2Fdetails%2F108011092" target="_blank" title="https://blog.csdn.net/weixin_42998707/article/details/108011092" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_4299…</a></li>
<li>文章2：<a href="https://juejin.cn/post/6844903511956815885" target="_blank" title="https://juejin.cn/post/6844903511956815885">juejin.cn/post/684490…</a></li>
<li>文章3：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F08%2Fimage-dominant-color-get-rgbaster-js" target="_blank" title="https://www.zhangxinxu.com/wordpress/2014/08/image-dominant-color-get-rgbaster-js" ref="nofollow noopener noreferrer">www.zhangxinxu.com/wordpress/2…</a></li>
</ul>
<p>可以发现，这些插件主要功能就是取色，并没有考虑实际的应用场景，对于一个图片颜色分析工具来说，他们做的很到位，但是在大多数场景中，他们往往是不适用的。</p>
<p>在文章 2 中，作者对比了三款插件对于图片容器背景色的应用，看起来还是 rgbaster 效果好一点，但是我们刚刚也拿他试了，它并不能适用于颜色复杂度高的、渐变色的图片。</p>
<h2 data-id="heading-2">思考</h2>
<p>既然又又又没有人做这件事，正所谓我不入地狱谁入地狱，我手写一个</p>
<p>整理一下需求，我发现我希望得到的是：</p>
<ol>
<li>图片的主题色（面积占比最大）</li>
<li>次主题色（面积占比第二大）</li>
<li>合适的背景色（即图片边缘颜色，渐变时，需要边缘颜色来设置背景色）</li>
</ol>
<p>这样一来，就已经可以覆盖大部分需求了，1+2 可以生成相关的 主题 TAG、主题背景，3 可以使留白的图片容器完美融合。</p>
<h2 data-id="heading-3">开搞</h2>
<p><strong>⚠⚠ 本小节内容非常硬核，如果不想深究原理可以直接<a href="#heading-6" title="#heading-6">跳过</a>，文章末尾有用法和效果图 ⚠⚠</strong></p>
<h3 data-id="heading-4">思路</h3>
<p>首先需要避免上面提到的插件的缺点，即对渐变图片要做好处理，不能取出成千上万的颜色，体验太差且实用性不强，对于渐变色还有一点，即在渐变路径上，每一点的颜色都是不一样的，所以需要将他们以一个阈值分类，挑选出一众相近色，并计算出一个平均色，这样就不会导致主题色太精准进而没有代表性。</p>
<p>对于背景色，需要按情况分析，如果只是希望做一个协调的页面，那么大可以直接使用主题色做渐变过渡或蒙层，也就是类似于这种效果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13ad6e69b69b4e208bd0dd20c5089ad4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=Vlkvm1jIbCL8rimtufkBate4ECM%3D" alt="image.png" loading="lazy"></p>
<p>但是如果希望背景与图片完美衔接，让人看不出图片边界的感觉，就需要单独对边缘颜色取色了。</p>
<p>最后一个问题，如果图片分辨率过大，在遍历像素点时会非常消耗性能，所以需要降低采样率，虽然会导致一些精度上的丢失，但是调整为一个合适的值后应该基本可用。</p>
<p>剩余的细节问题，我会在下面的代码中解释</p>
<h3 data-id="heading-5">使用 JaveScript 编码</h3>
<p>接下来我将详细描述 autohue.js 的实现过程，由于本人对<code>色彩科学</code>不甚了解，如有解释不到位或错误，还请指出。</p>
<p>首先编写一个入口主函数，我目前考虑到的参数应该有：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">colorPicker</span>(<span class="hljs-params">imageSource: HTMLImageElement | <span class="hljs-built_in">string</span>, options?: autoColorPickerOptions</span>)
<span class="hljs-keyword">type</span> thresholdObj = { primary?: <span class="hljs-built_in">number</span>; left?: <span class="hljs-built_in">number</span>; right?: <span class="hljs-built_in">number</span>; top?: <span class="hljs-built_in">number</span>; bottom?: <span class="hljs-built_in">number</span> }
<span class="hljs-keyword">interface</span> autoColorPickerOptions {
  <span class="hljs-comment">/**
   * - 降采样后的最大尺寸（默认 100px）
   * - 降采样后的图片尺寸不会超过该值，可根据需求调整
   * - 降采样后的图片尺寸越小，处理速度越快，但可能会影响颜色提取的准确性
   **/</span>
  maxSize?: <span class="hljs-built_in">number</span>
  <span class="hljs-comment">/**
   * - Lab 距离阈值（默认 10）
   * - 低于此值的颜色归为同一簇，建议 8~12
   * - 值越大，颜色越容易被合并，提取的颜色越少
   * - 值越小，颜色越容易被区分，提取的颜色越多
   **/</span>
  threshold?: <span class="hljs-built_in">number</span> | thresholdObj
}
</code></pre>
<blockquote>
<p>概念解释 Lab ，全称：<code>CIE L*a*b</code> ，<code>CIE L*a*b*</code> 是<code>CIE XYZ</code>色彩模式的改进型。它的“L”（明亮度），“a”（绿色到红色）和“b”（蓝色到黄色）代表许多的值。与XYZ比较，<code>CIE L*a*b*</code>的色彩更适合于人眼感觉的色彩，正所谓<code>感知均匀</code></p>
</blockquote>
<p>然后需要实现一个正常的 loadImg 方法，使用 canvas 异步加载图片</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">imageSource: HTMLImageElement | <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">HTMLImageElement</span>&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">img</span>: <span class="hljs-title class_">HTMLImageElement</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> imageSource === <span class="hljs-string">'string'</span>) {
      img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()
      img.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">'Anonymous'</span>
      img.<span class="hljs-property">src</span> = imageSource
    } <span class="hljs-keyword">else</span> {
      img = imageSource
    }
    <span class="hljs-keyword">if</span> (img.<span class="hljs-property">complete</span>) {
      <span class="hljs-title function_">resolve</span>(img)
    } <span class="hljs-keyword">else</span> {
      img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(img)
      img.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err)
    }
  })
}
</code></pre>
<p>这样我们就获取到了图片对象。</p>
<p>然后为了图片过大，我们需要进行降采样处理</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 利用 Canvas 对图片进行降采样，返回 ImageData 对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getImageDataFromImage</span>(<span class="hljs-params">img: HTMLImageElement, maxSize: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span></span>): <span class="hljs-title class_">ImageData</span> {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>)
  <span class="hljs-keyword">let</span> width = img.<span class="hljs-property">naturalWidth</span>
  <span class="hljs-keyword">let</span> height = img.<span class="hljs-property">naturalHeight</span>
  <span class="hljs-keyword">if</span> (width &gt; maxSize || height &gt; maxSize) {
    <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxSize / width, maxSize / height)
    width = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width * scale)
    height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(height * scale)
  }
  canvas.<span class="hljs-property">width</span> = width
  canvas.<span class="hljs-property">height</span> = height
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>)
  <span class="hljs-keyword">if</span> (!ctx) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'无法获取 Canvas 上下文'</span>)
  }
  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)
  <span class="hljs-keyword">return</span> ctx.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)
}

</code></pre>
<blockquote>
<p>概念解释，降采样：降采样（Downsampling）是指在图像处理中，通过减少数据的采样率或分辨率来降低数据量的过程。具体来说，就是在保持原始信息大致特征的情况下，减少数据的复杂度和存储需求。这里简单理解为将图片强制压缩为 100*100 以内，也是 canvas 压缩图片的常见做法。</p>
</blockquote>
<p>得到图像信息后，就可以对图片进行像素遍历处理了，正如思考中提到的，我们需要对相近色提取并取平均色，并最终获取到主题色、次主题色。</p>
<p>那么问题来了，什么才算相近色，对于这个问题，在 常规的 rgb 中直接计算是不行的，因为它涉及到一个感知均匀的问题</p>
<blockquote>
<p>概念解释，感知均匀：XYZ系统和在它的色度图上表示的两种颜色之间的距离与颜色观察者感知的变化不一致，这个问题叫做感知均匀性(perceptual uniformity)问题，也就是颜色之间数字上的差别与视觉感知不一致。由于我们需要在颜色簇中计算出平均色，那么对于人眼来说哪些颜色是相近的？此时，我们需要把 sRGB 转化为 Lab 色彩空间（感知均匀的），再计算其欧氏距离，在某一阈值内的颜色，即可认为是相近色。</p>
</blockquote>
<p>所以我们首先需要将 rgb 转化为 Lab 色彩空间</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 将 sRGB 转换为 Lab 色彩空间</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rgbToLab</span>(<span class="hljs-params">r: <span class="hljs-built_in">number</span>, g: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] {
  <span class="hljs-keyword">let</span> R = r / <span class="hljs-number">255</span>,
    G = g / <span class="hljs-number">255</span>,
    B = b / <span class="hljs-number">255</span>
  R = R &gt; <span class="hljs-number">0.04045</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>((R + <span class="hljs-number">0.055</span>) / <span class="hljs-number">1.055</span>, <span class="hljs-number">2.4</span>) : R / <span class="hljs-number">12.92</span>
  G = G &gt; <span class="hljs-number">0.04045</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>((G + <span class="hljs-number">0.055</span>) / <span class="hljs-number">1.055</span>, <span class="hljs-number">2.4</span>) : G / <span class="hljs-number">12.92</span>
  B = B &gt; <span class="hljs-number">0.04045</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>((B + <span class="hljs-number">0.055</span>) / <span class="hljs-number">1.055</span>, <span class="hljs-number">2.4</span>) : B / <span class="hljs-number">12.92</span>

  <span class="hljs-keyword">let</span> X = R * <span class="hljs-number">0.4124</span> + G * <span class="hljs-number">0.3576</span> + B * <span class="hljs-number">0.1805</span>
  <span class="hljs-keyword">let</span> Y = R * <span class="hljs-number">0.2126</span> + G * <span class="hljs-number">0.7152</span> + B * <span class="hljs-number">0.0722</span>
  <span class="hljs-keyword">let</span> Z = R * <span class="hljs-number">0.0193</span> + G * <span class="hljs-number">0.1192</span> + B * <span class="hljs-number">0.9505</span>

  X = X / <span class="hljs-number">0.95047</span>
  Y = Y / <span class="hljs-number">1.0</span>
  Z = Z / <span class="hljs-number">1.08883</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">t: <span class="hljs-built_in">number</span></span>) =&gt; (t &gt; <span class="hljs-number">0.008856</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(t, <span class="hljs-number">1</span> / <span class="hljs-number">3</span>) : <span class="hljs-number">7.787</span> * t + <span class="hljs-number">16</span> / <span class="hljs-number">116</span>)
  <span class="hljs-keyword">const</span> fx = <span class="hljs-title function_">f</span>(X)
  <span class="hljs-keyword">const</span> fy = <span class="hljs-title function_">f</span>(Y)
  <span class="hljs-keyword">const</span> fz = <span class="hljs-title function_">f</span>(Z)
  <span class="hljs-keyword">const</span> L = <span class="hljs-number">116</span> * fy - <span class="hljs-number">16</span>
  <span class="hljs-keyword">const</span> a = <span class="hljs-number">500</span> * (fx - fy)
  <span class="hljs-keyword">const</span> bVal = <span class="hljs-number">200</span> * (fy - fz)
  <span class="hljs-keyword">return</span> [L, a, bVal]
}
</code></pre>
<p>这个函数使用了看起来很复杂的算法，不必深究，这是它的大概解释：</p>
<ol>
<li>
<p>获取到 rgb 参数</p>
</li>
<li>
<p>转化为线性 rgb（移除 gamma矫正），常量 <strong>0.04045</strong> 是sRGB（标准TGB）颜色空间中的一个阈值，用于区分非线性和线性的sRGB值，具体来说，当sRGB颜色分量大于0.04045时，需要通过 gamma 校正（即采用 <code>((R + 0.055) / 1.055) ^ 2.4</code>）来得到线性RGB；如果小于等于0.04045，则直接进行线性转换（即 <code>R / 12.92</code>）</p>
</li>
<li>
<p>线性RGB到XYZ空间的转换，转换公式如下：</p>
<ul>
<li><code>X = R * 0.4124 + G * 0.3576 + B * 0.1805</code></li>
<li><code>Y = R * 0.2126 + G * 0.7152 + B * 0.0722</code></li>
<li><code>Z = R * 0.0193 + G * 0.1192 + B * 0.9505</code></li>
</ul>
</li>
<li>
<p>归一化XYZ值，为了参考白点（D65），标准白点的XYZ值是 <code>(0.95047, 1.0, 1.08883)</code>。所以需要通过除以这些常数来进行归一化</p>
</li>
<li>
<p>XYZ到Lab的转换，公式函数：const f = (t: number) =&gt; (t &gt; 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116)</p>
</li>
<li>
<p>计算L, a, b 分量</p>
<p><strong>L</strong>：亮度分量（表示颜色的明暗程度）</p>
<ul>
<li><code>L = 116 * fy - 16</code></li>
</ul>
<p><strong>a</strong>：绿色到红色的色差分量</p>
<ul>
<li><code>a = 500 * (fx - fy)</code></li>
</ul>
<p><strong>b</strong>：蓝色到黄色的色差分量</p>
<ul>
<li><code>b = 200 * (fy - fz)</code></li>
</ul>
</li>
</ol>
<p>接下来实现聚类算法</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * 对满足条件的像素进行聚类
 * <span class="hljs-doctag">@param</span> imageData 图片像素数据
 * <span class="hljs-doctag">@param</span> condition 判断像素是否属于指定区域的条件函数（参数 x, y）
 * <span class="hljs-doctag">@param</span> threshold Lab 距离阈值，低于此值的颜色归为同一簇，建议 8~12
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clusterPixelsByCondition</span>(<span class="hljs-params">imageData: ImageData, condition: (x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">boolean</span>, threshold: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span></span>): <span class="hljs-title class_">Cluster</span>[] {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">clusters</span>: <span class="hljs-title class_">Cluster</span>[] = []
  <span class="hljs-keyword">const</span> data = imageData.<span class="hljs-property">data</span>
  <span class="hljs-keyword">const</span> width = imageData.<span class="hljs-property">width</span>
  <span class="hljs-keyword">const</span> height = imageData.<span class="hljs-property">height</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">condition</span>(x, y)) <span class="hljs-keyword">continue</span>
      <span class="hljs-keyword">const</span> index = (y * width + x) * <span class="hljs-number">4</span>
      <span class="hljs-keyword">if</span> (data[index + <span class="hljs-number">3</span>] === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 忽略透明像素</span>
      <span class="hljs-keyword">const</span> r = data[index]
      <span class="hljs-keyword">const</span> g = data[index + <span class="hljs-number">1</span>]
      <span class="hljs-keyword">const</span> b = data[index + <span class="hljs-number">2</span>]
      <span class="hljs-keyword">const</span> lab = <span class="hljs-title function_">rgbToLab</span>(r, g, b)
      <span class="hljs-keyword">let</span> added = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cluster <span class="hljs-keyword">of</span> clusters) {
        <span class="hljs-keyword">const</span> d = <span class="hljs-title function_">labDistance</span>(lab, cluster.<span class="hljs-property">averageLab</span>)
        <span class="hljs-keyword">if</span> (d &lt; threshold) {
          cluster.<span class="hljs-property">count</span>++
          cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">0</span>] += r
          cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">1</span>] += g
          cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">2</span>] += b
          cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">0</span>] += lab[<span class="hljs-number">0</span>]
          cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">1</span>] += lab[<span class="hljs-number">1</span>]
          cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">2</span>] += lab[<span class="hljs-number">2</span>]
          cluster.<span class="hljs-property">averageRgb</span> = [cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">0</span>] / cluster.<span class="hljs-property">count</span>, cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">1</span>] / cluster.<span class="hljs-property">count</span>, cluster.<span class="hljs-property">sumRgb</span>[<span class="hljs-number">2</span>] / cluster.<span class="hljs-property">count</span>]
          cluster.<span class="hljs-property">averageLab</span> = [cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">0</span>] / cluster.<span class="hljs-property">count</span>, cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">1</span>] / cluster.<span class="hljs-property">count</span>, cluster.<span class="hljs-property">sumLab</span>[<span class="hljs-number">2</span>] / cluster.<span class="hljs-property">count</span>]
          added = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>
        }
      }
      <span class="hljs-keyword">if</span> (!added) {
        clusters.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">sumRgb</span>: [r, g, b],
          <span class="hljs-attr">sumLab</span>: [lab[<span class="hljs-number">0</span>], lab[<span class="hljs-number">1</span>], lab[<span class="hljs-number">2</span>]],
          <span class="hljs-attr">averageRgb</span>: [r, g, b],
          <span class="hljs-attr">averageLab</span>: [lab[<span class="hljs-number">0</span>], lab[<span class="hljs-number">1</span>], lab[<span class="hljs-number">2</span>]]
        })
      }
    }
  }
  <span class="hljs-keyword">return</span> clusters
}
</code></pre>
<p>函数内部有一个 labDistance 的调用，labDistance 是计算 Lab 颜色空间中的欧氏距离的</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 计算 Lab 空间的欧氏距离</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">labDistance</span>(<span class="hljs-params">lab1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], lab2: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">const</span> dL = lab1[<span class="hljs-number">0</span>] - lab2[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> da = lab1[<span class="hljs-number">1</span>] - lab2[<span class="hljs-number">1</span>]
  <span class="hljs-keyword">const</span> db = lab1[<span class="hljs-number">2</span>] - lab2[<span class="hljs-number">2</span>]
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(dL * dL + da * da + db * db)
}
</code></pre>
<blockquote>
<p>概念解释，欧氏距离：Euclidean Distance，是一种在多维空间中测量两个点之间“直线”距离的方法。这种距离的计算基于欧几里得几何中两点之间的距离公式，通过计算两点在各个维度上的差的平方和，然后取平方根得到。欧氏距离是指n维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。</p>
</blockquote>
<p>总的来说，这个函数采用了类似 K-means 的聚类方式，将小于用户传入阈值的颜色归为一簇，并取平均色(使用 Lab 值)。</p>
<blockquote>
<p>概念解释，聚类算法：Clustering Algorithm 是一种无监督学习方法，其目的是将数据集中的元素分成不同的组（簇），使得同一组内的元素相似度较高，而不同组之间的元素相似度较低。这里是将相近色归为一簇。</p>
</blockquote>
<blockquote>
<p>概念解释，颜色簇：簇是聚类算法中一个常见的概念，可以大致理解为 "一类"</p>
</blockquote>
<p>得到了颜色簇集合后，就可以按照count大小来判断哪个是主题色了</p>
<pre><code class="hljs language-ts" lang="ts">  <span class="hljs-comment">// 对全图所有像素进行聚类</span>
  <span class="hljs-keyword">let</span> clusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>, threshold.<span class="hljs-property">primary</span>)
  clusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> primaryCluster = clusters[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> secondaryCluster = clusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? clusters[<span class="hljs-number">1</span>] : clusters[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> primaryColor = <span class="hljs-title function_">rgbToHex</span>(primaryCluster.<span class="hljs-property">averageRgb</span>)
  <span class="hljs-keyword">const</span> secondaryColor = <span class="hljs-title function_">rgbToHex</span>(secondaryCluster.<span class="hljs-property">averageRgb</span>)
</code></pre>
<p>现在我们已经获取到了主题色、次主题色 🎉🎉🎉</p>
<p>接下来，我们继续计算边缘颜色</p>
<p>按照同样的方法，只是把阈值设小一点，我这里直接设置为 1 （threshold.top 等都是1）</p>
<pre><code class="hljs language-ts" lang="ts">  <span class="hljs-comment">// 分别对上、右、下、左边缘进行聚类</span>
  <span class="hljs-keyword">const</span> topClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">_x, y</span>) =&gt;</span> y &lt; margin, threshold.<span class="hljs-property">top</span>)
  topClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> topColor = topClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(topClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> bottomClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">_x, y</span>) =&gt;</span> y &gt;= height - margin, threshold.<span class="hljs-property">bottom</span>)
  bottomClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> bottomColor = bottomClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(bottomClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> leftClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">x, _y</span>) =&gt;</span> x &lt; margin, threshold.<span class="hljs-property">left</span>)
  leftClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> leftColor = leftClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(leftClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> rightClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">x, _y</span>) =&gt;</span> x &gt;= width - margin, threshold.<span class="hljs-property">right</span>)
  rightClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> rightColor = rightClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(rightClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor
</code></pre>
<p>这样我们就获取到了上下左右四条边的颜色 🎉🎉🎉</p>
<p>这样大致的工作就完成了，最后我们将需要的属性导出给用户，我们的主函数最终长这样：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * 主函数：根据图片自动提取颜色
 * <span class="hljs-doctag">@param</span> imageSource 图片 URL 或 HTMLImageElement
 * <span class="hljs-doctag">@returns</span> 返回包含主要颜色、次要颜色和背景色对象（上、右、下、左）的结果
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">colorPicker</span>(<span class="hljs-params">imageSource: HTMLImageElement | <span class="hljs-built_in">string</span>, options?: autoColorPickerOptions</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">AutoHueResult</span>&gt; {
  <span class="hljs-keyword">const</span> { maxSize, threshold } = <span class="hljs-title function_">__handleAutoHueOptions</span>(options)
  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadImage</span>(imageSource)
  <span class="hljs-comment">// 降采样（最大尺寸 100px，可根据需求调整）</span>
  <span class="hljs-keyword">const</span> imageData = <span class="hljs-title function_">getImageDataFromImage</span>(img, maxSize)

  <span class="hljs-comment">// 对全图所有像素进行聚类</span>
  <span class="hljs-keyword">let</span> clusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>, threshold.<span class="hljs-property">primary</span>)
  clusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> primaryCluster = clusters[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> secondaryCluster = clusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? clusters[<span class="hljs-number">1</span>] : clusters[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> primaryColor = <span class="hljs-title function_">rgbToHex</span>(primaryCluster.<span class="hljs-property">averageRgb</span>)
  <span class="hljs-keyword">const</span> secondaryColor = <span class="hljs-title function_">rgbToHex</span>(secondaryCluster.<span class="hljs-property">averageRgb</span>)

  <span class="hljs-comment">// 定义边缘宽度（单位像素）</span>
  <span class="hljs-keyword">const</span> margin = <span class="hljs-number">10</span>
  <span class="hljs-keyword">const</span> width = imageData.<span class="hljs-property">width</span>
  <span class="hljs-keyword">const</span> height = imageData.<span class="hljs-property">height</span>

  <span class="hljs-comment">// 分别对上、右、下、左边缘进行聚类</span>
  <span class="hljs-keyword">const</span> topClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">_x, y</span>) =&gt;</span> y &lt; margin, threshold.<span class="hljs-property">top</span>)
  topClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> topColor = topClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(topClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> bottomClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">_x, y</span>) =&gt;</span> y &gt;= height - margin, threshold.<span class="hljs-property">bottom</span>)
  bottomClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> bottomColor = bottomClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(bottomClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> leftClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">x, _y</span>) =&gt;</span> x &lt; margin, threshold.<span class="hljs-property">left</span>)
  leftClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> leftColor = leftClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(leftClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">const</span> rightClusters = <span class="hljs-title function_">clusterPixelsByCondition</span>(imageData, <span class="hljs-function">(<span class="hljs-params">x, _y</span>) =&gt;</span> x &gt;= width - margin, threshold.<span class="hljs-property">right</span>)
  rightClusters.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">count</span> - a.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> rightColor = rightClusters.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title function_">rgbToHex</span>(rightClusters[<span class="hljs-number">0</span>].<span class="hljs-property">averageRgb</span>) : primaryColor

  <span class="hljs-keyword">return</span> {
    primaryColor,
    secondaryColor,
    <span class="hljs-attr">backgroundColor</span>: {
      <span class="hljs-attr">top</span>: topColor,
      <span class="hljs-attr">right</span>: rightColor,
      <span class="hljs-attr">bottom</span>: bottomColor,
      <span class="hljs-attr">left</span>: leftColor
    }
  }
}

</code></pre>
<p>还记得本小节一开始提到的参数吗，你可以自定义 maxSize（压缩大小，用于降采样）、threshold（阈值，用于设置簇大小）</p>
<p>为了用户友好，我还编写了 threshold 参数的可选类型：number | thresholdObj</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> thresholdObj = { primary?: <span class="hljs-built_in">number</span>; left?: <span class="hljs-built_in">number</span>; right?: <span class="hljs-built_in">number</span>; top?: <span class="hljs-built_in">number</span>; bottom?: <span class="hljs-built_in">number</span> }
</code></pre>
<p>可以单独设置主阈值、上下左右四边阈值，以适应更个性化的情况。</p>
<h2 data-id="heading-6">autohue.js 诞生了</h2>
<p>名字的由来：秉承一贯命名习惯，auto 家族成员又多一个，与颜色有关的单词有好多个，我取了最短最好记的一个 hue(色相)，也比较契合插件用途。</p>
<p>此插件已在 github 开源：<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin%2Fautohue.js" target="_blank" title="https://github.com/Auto-Plugin/autohue.js" ref="nofollow noopener noreferrer">GitHub autohue.js</a></strong></p>
<p>npm 主页：<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fautohue.js" target="_blank" title="https://www.npmjs.com/package/autohue.js" ref="nofollow noopener noreferrer">NPM autohue.js</a></strong></p>
<p>在线体验：<a href="https://link.juejin.cn?target=https%3A%2F%2Fauto-plugin.github.io%2Fautohue.js%2F" target="_blank" title="https://auto-plugin.github.io/autohue.js/" ref="nofollow noopener noreferrer">autohue.js 官方首页</a></p>
<h3 data-id="heading-7">安装与使用</h3>
<pre><code class="hljs language-shell" lang="shell">pnpm i autohue.js
</code></pre>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> autohue <span class="hljs-keyword">from</span> <span class="hljs-string">'autohue.js'</span>

<span class="hljs-title function_">autohue</span>(url, {
  <span class="hljs-attr">threshold</span>: {
    <span class="hljs-attr">primary</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">left</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">bottom</span>: <span class="hljs-number">12</span>
  },
  <span class="hljs-attr">maxSize</span>: <span class="hljs-number">50</span>
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
    <span class="hljs-comment">// 使用 console.log 打印出色块元素s</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`%c<span class="hljs-subst">${result.primaryColor}</span>`</span>, <span class="hljs-string">'color: #fff; background: '</span> + result.<span class="hljs-property">primaryColor</span>, <span class="hljs-string">'main'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`%c<span class="hljs-subst">${result.secondaryColor}</span>`</span>, <span class="hljs-string">'color: #fff; background: '</span> + result.<span class="hljs-property">secondaryColor</span>, <span class="hljs-string">'sub'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`%c<span class="hljs-subst">${result.backgroundColor.left}</span>`</span>, <span class="hljs-string">'color: #fff; background: '</span> + result.<span class="hljs-property">backgroundColor</span>.<span class="hljs-property">left</span>, <span class="hljs-string">'bg-left'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`%c<span class="hljs-subst">${result.backgroundColor.right}</span>`</span>, <span class="hljs-string">'color: #fff; background: '</span> + result.<span class="hljs-property">backgroundColor</span>.<span class="hljs-property">right</span>, <span class="hljs-string">'bg-right'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`%clinear-gradient to right`</span>, <span class="hljs-string">'color: #fff; background: linear-gradient(to right, '</span> + result.<span class="hljs-property">backgroundColor</span>.<span class="hljs-property">left</span> + <span class="hljs-string">', '</span> + result.<span class="hljs-property">backgroundColor</span>.<span class="hljs-property">right</span> + <span class="hljs-string">')'</span>, <span class="hljs-string">'bg'</span>)
    bg.<span class="hljs-property">value</span> = <span class="hljs-string">`linear-gradient(to right, <span class="hljs-subst">${result.backgroundColor.left}</span>, <span class="hljs-subst">${result.backgroundColor.right}</span>)`</span>
  })
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err))

</code></pre>
<h2 data-id="heading-8">最终效果</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f12b9b60723e4904a17b127267b2cc25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=8IWGHJ6pWb6CclLzlOICm%2BuvYDQ%3D" alt="image.png" loading="lazy"></p>
<p>复杂边缘效果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa6c3317d84749718ad30ae88bb4bda5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=r2tcsV23yke7RHWEY5CAtpHNcgM%3D" alt="image.png" loading="lazy"></p>
<p>纵向渐变效果（这里使用的是 left 和 right 边的值，可能使用 top 和 bottom 效果更佳）</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe207c4dfc2a461e9f6a7dd04b0ea3a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=6NKJkcOcQyFtMIOh79Joh2igwq4%3D" alt="image.png" loading="lazy"></p>
<p>纯色效果（因为单独对边缘采样，所以无论图片内容多复杂，纯色基本看不出边界）</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0bddbdc43e244bb4b41e3676617b29e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=8zz2MfLzX0P78iVWCXOM4DGBN%2BY%3D" alt="image.png" loading="lazy"></p>
<p>突变边缘效果（此时用css做渐变蒙层应该效果会更好）</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/596fb4fc81454766abb44912ab12c020~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1745984431&amp;x-signature=u2KCpTfNAPVsOem9hCP8oMksGUk%3D" alt="image.png" loading="lazy"></p>
<p>横向渐变效果（使用的是 left 和 right 的色值），基本看不出边界</p>
<h2 data-id="heading-9">参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F370371059" target="_blank" title="https://zhuanlan.zhihu.com/p/370371059" ref="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/370371059</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%259B%25BD%25E9%2599%2585%25E7%2585%25A7%25E6%2598%258E%25E5%25A7%2594%25E5%2591%2598%25E4%25BC%259A%2F10021151%3Ffromtitle%3DCIE%26fromid%3D8649998" target="_blank" title="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E7%85%A7%E6%98%8E%E5%A7%94%E5%91%98%E4%BC%9A/10021151?fromtitle=CIE&amp;fromid=8649998" ref="nofollow noopener noreferrer">baike.baidu.com/item/%E5%9B…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E6%25A0%2587%25E5%2587%2586%25E5%2585%2589%25E6%25BA%2590D65%2F20792406" target="_blank" title="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%85%89%E6%BA%90D65/20792406" ref="nofollow noopener noreferrer">baike.baidu.com/item/%E6%A0…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%25AC%25A7%25E5%2587%25A0%25E9%2587%258C%25E5%25BE%2597%25E8%25B7%259D%25E7%25A6%25BB" target="_blank" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB" ref="nofollow noopener noreferrer">zh.wikipedia.org/wiki/%E6%AC…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42560067%2Farticle%2Fdetails%2F116182991" target="_blank" title="https://blog.csdn.net/weixin_42560067/article/details/116182991" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_4256…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FK-%25E5%25B9%25B3%25E5%259D%2587%25E7%25AE%2597%25E6%25B3%2595" target="_blank" title="https://zh.wikipedia.org/wiki/K-%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95" ref="nofollow noopener noreferrer">zh.wikipedia.org/wiki/K-%E5%…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42998707%2Farticle%2Fdetails%2F108011092" target="_blank" title="https://blog.csdn.net/weixin_42998707/article/details/108011092" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_4299…</a></li>
<li><a href="https://juejin.cn/post/6844903511956815885" target="_blank" title="https://juejin.cn/post/6844903511956815885">juejin.cn/post/684490…</a></li>
</ul>
<h2 data-id="heading-10">番外</h2>
<p>Auto 家族的其他成员</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin" target="_blank" title="https://github.com/Auto-Plugin" ref="nofollow noopener noreferrer">Auto-Plugin</a>/<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin%2Fautofit.js" target="_blank" title="https://github.com/Auto-Plugin/autofit.js" ref="nofollow noopener noreferrer">autofit.js</a></strong> autofit.js 迄今为止最易用的自适应工具</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin" target="_blank" title="https://github.com/Auto-Plugin" ref="nofollow noopener noreferrer">Auto-Plugin</a>/<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin%2Fautolog.js" target="_blank" title="https://github.com/Auto-Plugin/autolog.js" ref="nofollow noopener noreferrer">autolog.js</a></strong> autolog.js 轻量化小弹窗</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin" target="_blank" title="https://github.com/Auto-Plugin" ref="nofollow noopener noreferrer">Auto-Plugin</a>/<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin%2Fautouno" target="_blank" title="https://github.com/Auto-Plugin/autouno" ref="nofollow noopener noreferrer">autouno</a></strong> autouno 直觉的UnoCSS预设方案</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin" target="_blank" title="https://github.com/Auto-Plugin" ref="nofollow noopener noreferrer">Auto-Plugin</a>/<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin%2Fautohue.js" target="_blank" title="https://github.com/Auto-Plugin/autohue.js" ref="nofollow noopener noreferrer">autohue.js</a></strong> 本品 一个自动提取图片主题色让图片和背景融为一体的工具</li>
</ul></div></div>