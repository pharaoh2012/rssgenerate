
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/guchen33/p/18742358" title="发布于 2025-02-27 23:48">
    <span role="heading" aria-level="2">自定义一个区域管理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我有一个想法，是跟据Prism框架想到的<br>
在Prism框架，我们经常会用到</p>
<pre><code>  &lt;Grid DockPanel.Dock="Left"&gt;
      &lt;ContentControl  prism:RegionManager.RegionName="{x:Static region:RegionNames.HeaderRegion}" /&gt;
</code></pre>
<pre><code> public class RegionNames
    {
        public static readonly string HeaderRegion = nameof(HeaderRegion);
        public static readonly string AsideRegion = nameof(AsideRegion);
        public static readonly string ContentRegion = nameof(ContentRegion);
        public static readonly string FooterRegion = nameof(FooterRegion);
        public static readonly string SettingsRegion = nameof(SettingsRegion);
        public static readonly string SettingsTabRegion = nameof(SettingsTabRegion);

    }
</code></pre>
<p>因为Prism有 RegionManager.RegisterViewWithRegion(RegionNames.AsideRegion, typeof(AsideView));可以实现将数据填充到界面，并且他这种区域管理非常优秀，我在不使用Prism框架的时候就必须写成了</p>
<pre><code>&lt;DataTemplate DataType="{x:Type viewModel:UniformGridViewModel}"&gt;
    &lt;view:UniformGridView /&gt;
&lt;/DataTemplate&gt; 
&lt;ContentControl Grid.Row="0" Content="{StaticResource UniformGridView}" /&gt;
</code></pre>
<p>不管是直接在ContentControl绑定View还是绑定ViewModel都没有Prism这种方法简便，我突发奇想，我在WPF原生的ContentControl使用静态绑定，由于Content可以绑定object，所以我新写的</p>
<pre><code>&lt;ContentControl Grid.Row="4" Content="{x:Static region:RegionNames.Header}" /&gt;
</code></pre>
<pre><code> public class RegionNames
 {
     public const string Header = nameof(Header);
 }
</code></pre>
<p>是完全可以绑定成功的，然后我发现了网上有人对Grid进行改造，它使用了</p>
<pre><code>[TypeConverter(typeof(GridLengthCollectionConverter))]
 public class GridLengthCollection : ReadOnlyCollection&lt;GridLength&gt;
 {
     public GridLengthCollection(IList&lt;GridLength&gt; list) : base(list)
     {
     }
 }和 public class GridLengthCollectionConverter : TypeConverter
 {
     public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
     {
         if (sourceType == typeof(string))
             return true;
         return base.CanConvertFrom(context, sourceType);
     }

     public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
     {
         if (destinationType == typeof(string))
             return true;
         return base.CanConvertTo(context, destinationType);
     }

     public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
     {
         string s = value as string;
         if (s != null)
             return ParseString(s, culture);
         return base.ConvertFrom(context, culture, value);
     }

     public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
     {
         if (destinationType == typeof(string) &amp;&amp; value is GridLengthCollection)
             return ToString((GridLengthCollection)value, culture);
         return base.ConvertTo(context, culture, value, destinationType);
     }

     private string ToString(GridLengthCollection value, CultureInfo culture)
     {
         var converter = new GridLengthConverter();
         return string.Join(",", value.Select(v =&gt; converter.ConvertToString(v)));
     }

     private GridLengthCollection ParseString(string s, CultureInfo culture)
     {
         var converter = new GridLengthConverter();
         var lengths = s.Split(',').Select(p =&gt; (GridLength)converter.ConvertFromString(p.Trim()));
         return new GridLengthCollection(lengths.ToArray());
     }
 }
</code></pre>
<p>我准备试试TypeConverter转换的强大，那么我上面提到的我结合Prism的想法，并且我对原生WPF的ContentControl的Content绑定一个静态的属性，使用TypeConverter能不能做到类似Prism框架那样显示的不是字符串而是一个界面，我开始进行封装</p>
<pre><code>public class RegionConverter : TypeConverter
{
    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
    {
        return sourceType == typeof(string);
    }

    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
    {
        if (value is string regionName)
        {
            switch (regionName)
            {
                case RegionNames.Header:
                    return new HeaderView();
                case RegionNames.Aside:
                    return new AsideView();
                case RegionNames.Content:
                    return new ContentView();
                default:
                    throw new ArgumentException($"Unknown region: {regionName}");
            }
        }
        throw new NotSupportedException();
    }
}
</code></pre>
<pre><code>&lt;Window.Resources&gt;
        &lt;!-- 注册 TypeConverter --&gt;
        &lt;local:RegionConverter x:Key="RegionConverter" /&gt;
    &lt;/Window.Resources&gt;
    &lt;Grid&gt;
        &lt;!-- 绑定区域名称并使用 TypeConverter 转换为 View --&gt;
        &lt;ContentControl Content="{Binding Source={x:Static local:RegionNames.Header}, Converter={StaticResource RegionConverter}}" /&gt;
    &lt;/Grid&gt;
</code></pre>
<p>但是编译不通过，并且运行失败，</p>
<pre><code>我强制运行后程序报错InvalidCastException: Unable to cast object of type '自定义一个区域管理.RegionConverter' to type 'System.Windows.Data.IValueConverter'.
</code></pre>
<p>在思考转换的时候，我想到WPF的IValueConverter也可以转换，我继续尝试</p>
<pre><code>public class RegionConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string regionName)
        {
            switch (regionName)
            {
                case RegionNames.Header:
                    return new HeaderView();
                case RegionNames.Aside:
                    return new AsideView();
                case RegionNames.Content:
                    return new ContentView();
                default:
                    throw new ArgumentException($"Unknown region: {regionName}");
            }
        }
        throw new NotSupportedException();
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
</code></pre>
<p>完美的解决了这个问题，以后不需要直接绑定View或者ViewModel，通过字符串进行转换，只需要在XAML绑定字符串即可</p>
<pre><code>&lt;ContentControl Content="{Binding Source={x:Static region:RegionNames.Header}, Converter={StaticResource RegionConverter}}" /&gt;
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.021606523331018517" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-27 23:48">2025-02-27 23:48</span>&nbsp;
<a href="https://www.cnblogs.com/guchen33">孤沉</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18742358" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18742358);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18742358', targetLink: 'https://www.cnblogs.com/guchen33/p/18742358', title: '自定义一个区域管理' })">举报</a>
</div>
        