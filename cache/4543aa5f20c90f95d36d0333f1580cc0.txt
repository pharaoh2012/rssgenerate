
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18843073" title="发布于 2025-04-23 17:03">
    <span role="heading" aria-level="2">聊聊SpringAI流式输出的底层实现？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 Spring AI 中，流式输出（Streaming Output）是一种逐步返回 AI 模型生成结果的技术，允许服务器将响应内容分批次实时传输给客户端，而不是等待全部内容生成完毕后再一次性返回。</p>
<p>这种机制能显著提升用户体验，尤其适用于大模型响应较慢的场景（如生成长文本或复杂推理结果）。</p>
<h2 id="技术实现">技术实现</h2>
<p>在 Spring AI 中流式输出的实现有以下两种方式：</p>
<ol>
<li>通过 ChatModel 实现流式输出。</li>
<li>通过 ChatClient 实现流式输出。</li>
</ol>
<h3 id="chatmodel-流式输出">ChatModel 流式输出</h3>
<p>Spring AI 中的流式输出实现非常简单，使用 ChatModel 中的 stream 即可实现：</p>
<pre><code class="language-java">@RequestMapping(value = "/streamChat", produces = "text/event-stream")
public Flux&lt;String&gt; streamChat(@RequestParam(value = "msg") String msg) {
    return chatModel.stream(msg);
}
</code></pre>
<h3 id="chatclient-流式输出">ChatClient 流式输出</h3>
<p>ChatClient 流式输出实现也很简单，也是调用 stream().content() 返回 Flux 对象即可：</p>
<pre><code class="language-java">@RequestMapping("/stream")
public Flux&lt;String&gt; stream(String question) {
    return chatClient.prompt(question)
            .stream()
            .content();
}
</code></pre>
<h2 id="底层实现">底层实现</h2>
<p>那么问题来了流式输出的底层实现究竟是啥呢？</p>
<p>根据以往的经验我们知道，流式输出的实现技术基本有两种：</p>
<ol>
<li>Spring MVC（Servlet）+ SSE 实现流式输出。</li>
<li>Spring WebFlux Reactor 模型实现流式输出。</li>
</ol>
<h3 id="sse-介绍">SSE 介绍</h3>
<p>SSE（Server-Sent Events）是一种允许服务器向浏览器或其他客户端推送实时更新的技术。它是一种单向通信机制，服务器可以主动向客户端发送数据，而客户端无需频繁轮询服务器请求数据。SSE 是基于 HTTP 协议的，使用标准的 <code>text/event-stream</code> MIME 类型来传输数据。</p>
<h4 id="sse-主要特点">SSE 主要特点</h4>
<ol>
<li><strong>单向通信</strong>：SSE 仅支持服务器到客户端的单向通信，客户端不能向服务器发送消息。如果需要双向通信，可以结合 WebSocket 或其他技术。</li>
<li><strong>基于 HTTP</strong>：SSE 使用标准的 HTTP 协议，不需要额外的协议支持，因此兼容性较好。</li>
<li><strong>自动重连</strong>：客户端在连接中断后会自动尝试重新连接。</li>
<li><strong>数据格式</strong>：SSE 数据以特定的格式发送，每条消息以 data: 开头，以两个换行符 \n\n 结尾。</li>
<li><strong>事件类型</strong>：可以为每条消息指定事件类型，客户端可以通过监听特定事件类型来处理不同的消息。</li>
</ol>
<p>Spring MVC（Spring Web）底层是基于 Servlet 实现的，它是使用 SseEmitter 技术实现 SSE 协议实现流式输出的。</p>
<h4 id="sseemitter-基本用法">SseEmitter 基本用法</h4>
<p>这里提供一个 SseEmitter 的简单使用案例，实现流式输出，让大家更好的理解这个技术点：</p>
<pre><code class="language-java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import java.io.IOException;

@RestController
public class SseDemoController {
    @GetMapping(value = "/sse-demo", produces = "text/event-stream")
    public SseEmitter streamData() {
        // 设置超时时间（单位：毫秒）
        SseEmitter emitter = new SseEmitter(30_000L); // 30秒超时

        // 异步任务模拟流式输出
        new Thread(() -&gt; {
            try {
                for (int i = 1; i &lt;= 5; i++) {
                    String message = "第 " + i + " 条消息";
                    emitter.send(message);
                    Thread.sleep(1000); // 每秒发送一次
                }
                emitter.complete(); // 完成推送
            } catch (IOException | InterruptedException e) {
                emitter.completeWithError(e); // 异常处理
            }
        }).start();

        return emitter;
    }
}
</code></pre>
<h3 id="spring-webflux-介绍">Spring WebFlux 介绍</h3>
<p>Spring WebFlux 是 Spring Framework 5 引入的响应式 Web 框架，旨在解决高并发场景下传统同步阻塞模型（如 Spring MVC）的性能瓶颈。其核心目标是通过非阻塞异步编程模型提升系统吞吐量，适用于 I/O 密集型任务（如微服务通信、实时数据流处理）。</p>
<p>Spring WebFlux 与 Spring MVC 不同，它基于 Reactive Streams 规范实现的，支持背压机制（Backpressure），防止数据生产者压垮消费者。</p>
<blockquote>
<p>背压机制：通过订阅者主动控制数据流速，避免内存溢出。例如，消费者可动态调整请求量，生产者根据反馈调整数据生成速度.</p>
</blockquote>
<h3 id="spring-ai-流式输出">Spring AI 流式输出</h3>
<p>说完了前置知识，咱们回到主题：Spring AI 是如何实现流式输出的？</p>
<p>要搞清楚这个问题，我们需要看流式输出对象 Flux 的实现源码：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202504/172074-20250423170250529-1824248658.png" alt="" loading="lazy"></p>
<p>查看 Flux 源码我们发现它是属于 reactor.core.publisher 包下的抽象类：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202504/172074-20250423170258373-1282377286.png" alt="" loading="lazy"></p>
<p>并且看类注释和类所在的 jar 包我们就明白了：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202504/172074-20250423170305769-1353459729.png" alt="" loading="lazy"></p>
<p>Spring AI 中的流式输出是通过 Reactor Streams 模型实现的，和 Spring WebFlux 的底层实现是一样的技术。</p>
<p><strong>具体执行流程</strong>：Reactor Streams 会订阅数据源，当有数据时，Reactor Streams 以分块流的方式发送给客户端（用户）。</p>
<h2 id="reactor-介绍">Reactor 介绍</h2>
<p>Reactor 是一种<strong>事件驱动的高性能网络编程模型</strong>，主要用于处理高并发的网络 I/O 请求。其核心思想是通过一个或多个线程监听事件，并将事件分发给相应的处理程序，从而实现高效的并发处理。</p>
<p>Reactor 模型的主要特征如下：</p>
<ol>
<li><strong>事件驱动</strong>：所有 I/O 操作都由事件触发并处理。</li>
<li><strong>非阻塞</strong>：操作不会因为 I/O 而挂起，避免了线程等待的开销。</li>
<li><strong>高效资源利用</strong>：通过少量线程处理大量并发连接，提升性能。</li>
<li><strong>组件分离</strong>：将事件监听（Reactor）、事件分发（Dispatcher）和事件处理（Handler）解耦，使代码结构更清晰。</li>
</ol>
<p>Reactor 实现方式有三种：</p>
<ol>
<li><strong>单线程 Reactor 模型</strong>：所有操作在一个线程完成，适用于低并发场景。</li>
<li><strong>多线程 Reactor 模型</strong>：主线程处理连接，子线程池处理 I/O 和业务。</li>
<li><strong>主从 Reactor 模型</strong>：主线程池处理连接，子线程池处理 I/O（进一步优化资源分配）。</li>
</ol>
<p>生产级别使用的 Reactor 基本都是主从 Reactor 模型，它的执行流程如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202504/172074-20250423170316552-1686357880.png" alt="" loading="lazy"></p>
<h2 id="小结">小结</h2>
<p>Spring AI 中的流式输出有两种实现，而通过查看这两种流式输出的实现源码可知，Spring AI 中的流式输出是<strong>通过 Reactor Streams 技术实现的</strong>，当客户端发送请求时，会建立连接并订阅数据源，当有数据时，Reactor Streams 以分块流的方式发送给客户端（用户）。</p>
<blockquote>
<p>本文已收录到我的技术小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：Spring AI、LangChain4j、MCP、Function Call、RAG、向量数据库、Prompt、多模态、向量数据库、嵌入模型等内容。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5497458360706019" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-23 17:03">2025-04-23 17:03</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">81</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18843073);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18843073', targetLink: 'https://www.cnblogs.com/vipstone/p/18843073', title: '聊聊SpringAI流式输出的底层实现？' })">举报</a>
</div>
        