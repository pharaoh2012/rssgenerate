
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nianzhilian/p/18877335" title="发布于 2025-05-15 10:54">
    <span role="heading" aria-level="2">详解中间件</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>中间件（Middleware）是软件开发中一种常见的设计模式，其核心思想是‌在核心逻辑的执行过程中插入可扩展的附加功能模块‌。以下是中间件的核心概念和特点：</p>
<h3>‌一、中间件的本质</h3>
<p>中间件本质上是 ‌"业务逻辑的增强层"‌，它像流水线上的加工环节，对输入的数据或事件进行预处理、拦截或后处理，但不改变核心逻辑本身。</p>
<h3>‌二、典型特征‌</h3>
<p>1、链式调用（洋葱模型）</p>
<p>多个中间件形成处理链，依次传递处理权，可以同时处理请求（Request）和响应（Response），类似流水线作业。</p>
<p>2、可插拔性</p>
<p>中间件可按需组合，灵活添加或移除功能模块，无需修改核心代码。</p>
<p>3、职责单一原则</p>
<p>每个中间件专注一个独立功能（如日志记录、权限验证等）。</p>
<h3>‌三、核心工作原理</h3>
<p>假设一个包含三个中间件的处理流程（伪代码）：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 中间件链式调用逻辑</span>
const middlewareChain =<span style="color: rgba(0, 0, 0, 1)"> [
  (next) </span>=&gt; (input) =&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    console.log(</span>"Middleware 1开始"<span style="color: rgba(0, 0, 0, 1)">);
    next(input); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 传递到下一个中间件</span>
    console.log("Middleware 1结束"<span style="color: rgba(0, 0, 0, 1)">);
  },
  (next) </span>=&gt; (input) =&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    console.log(</span>"Middleware 2开始"<span style="color: rgba(0, 0, 0, 1)">);
    next(input);
    console.log(</span>"Middleware 2结束"<span style="color: rgba(0, 0, 0, 1)">);
  },
  (next) </span>=&gt; (input) =&gt;<span style="color: rgba(0, 0, 0, 1)"> {
    console.log(</span>"核心逻辑执行"<span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> "处理结果"<span style="color: rgba(0, 0, 0, 1)">;
  }
];

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出结果：</span><span style="color: rgba(0, 128, 0, 1)">
//</span><span style="color: rgba(0, 128, 0, 1)"> Middleware 1开始</span><span style="color: rgba(0, 128, 0, 1)">
//</span><span style="color: rgba(0, 128, 0, 1)"> Middleware 2开始</span><span style="color: rgba(0, 128, 0, 1)">
//</span><span style="color: rgba(0, 128, 0, 1)"> 核心逻辑执行</span><span style="color: rgba(0, 128, 0, 1)">
//</span><span style="color: rgba(0, 128, 0, 1)"> Middleware 2结束</span><span style="color: rgba(0, 128, 0, 1)">
//</span><span style="color: rgba(0, 128, 0, 1)"> Middleware 1结束</span></pre>
</div>
<p>下面是一个手写redux的例子</p>
<p>createStore：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
 * 判断是否是平面对象
 * @param {*} obj 
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> isPlainObject(obj){
    </span><span style="color: rgba(0, 0, 255, 1)">if</span>(<span style="color: rgba(0, 0, 255, 1)">typeof</span> obj!='object'<span style="color: rgba(0, 0, 0, 1)">){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> Object.getPrototypeOf(obj) ===<span style="color: rgba(0, 0, 0, 1)"> Object.prototype
}
</span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
 * 生成一个6位的随机字符串
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> getRandomStr(len){
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> Math.random().toString(36).substring(2,len+2).split("").join("."<span style="color: rgba(0, 0, 0, 1)">);
}
export </span><span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(reducer,initState){
    let currentReducer </span>= reducer,currentState =<span style="color: rgba(0, 0, 0, 1)"> initState;
    let listens </span>=<span style="color: rgba(0, 0, 0, 1)"> [];
    </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> dispatch(action){
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">限制条件</span>
        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">action 必须是一个平面对象</span>
        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">必须有type属性</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span>(!<span style="color: rgba(0, 0, 0, 1)">isPlainObject(action)){
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> TypeError('action必须是平面对象'<span style="color: rgba(0, 0, 0, 1)">);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(action.type ===<span style="color: rgba(0, 0, 0, 1)"> undefined){
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> TypeError('action对象必须有type属性'<span style="color: rgba(0, 0, 0, 1)">);
        }
        currentState </span>=<span style="color: rgba(0, 0, 0, 1)"> currentReducer(currentState,action);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">store更新完state之后 依次调用添加的监听器</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (const listen of listens) {
            listen();
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">初始化store的时候会默认 dispatch一个特殊的type类型</span>
<span style="color: rgba(0, 0, 0, 1)">    dispatch({
        type:`@@redux</span>/INIT${getRandomStr(6)}`
<span style="color: rgba(0, 0, 0, 1)">    })

    </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> getState(){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> currentState;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> subscribe(listen){
        listens.push(listen);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果已经取消监听了 则直接返回</span>
        let isRemove = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">返回一个函数 执行清除监听器的操作</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(){
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(isRemove){
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            }
            const index </span>=<span style="color: rgba(0, 0, 0, 1)"> listens.indexOf(listen);
            listens.splice(index,</span>1<span style="color: rgba(0, 0, 0, 1)">);
            isRemove </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
        dispatch,
        getState,
        subscribe
    }
}</span></pre>
</div>
<p>bindActionCreators：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
 * //bindActionCreators 直接接收一个action创建函数 和 store.dispatch 如果是一个函数则直接调用 内部去dispatch action
//如果接收的是一个对象 返回的跟对象属性相同的数据结构  内部去dispatch action
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
export </span><span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(obj,dispatch){
    </span><span style="color: rgba(0, 0, 255, 1)">if</span>(<span style="color: rgba(0, 0, 255, 1)">typeof</span> obj === "function"<span style="color: rgba(0, 0, 0, 1)">){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> getAutoDispatchAction(obj,dispatch)
    }</span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(<span style="color: rgba(0, 0, 255, 1)">typeof</span> obj === "object"<span style="color: rgba(0, 0, 0, 1)">){
        let result </span>=<span style="color: rgba(0, 0, 0, 1)"> {};
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (const key <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> obj) {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (Object.prototype.hasOwnProperty.call(obj, key)) {
                const actionCreater </span>=<span style="color: rgba(0, 0, 0, 1)"> obj[key];
                result[key] </span>=<span style="color: rgba(0, 0, 0, 1)"> getAutoDispatchAction(actionCreater,dispatch);
            }
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> result;
    }</span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">{
        </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> TypeError("报错了"<span style="color: rgba(0, 0, 0, 1)">);
    }
}

</span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> getAutoDispatchAction(actionCreate,dispatch){
    </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
     * 将参数汇总成数组  (arg1,arg2)  变成[arg1,arg2]
     * 函数内部展开是重新变成（arg1,arg2） (展开运算符)
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(...args){
        const action </span>=<span style="color: rgba(0, 0, 0, 1)"> actionCreate(...args);
        dispatch(action);
    }
}</span></pre>
</div>
<p>applyMiddleware：</p>
<div class="cnblogs_code">
<pre>import compose from "./compose"<span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
 * 外层函数捕捉中间件集合
 * 中层函数接收创建原始厂库的函数
 * 内层函数 用来增强原始厂库 增强原始的dispatch函数
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
export </span><span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(...middlewares){
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(createStore){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(reducer,defaultState){
            const store </span>=<span style="color: rgba(0, 0, 0, 1)"> createStore(reducer,defaultState);
            let dispatch </span>= (...args)=&gt;<span style="color: rgba(0, 0, 0, 1)">{
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> Error("Dispatching while constructing your middleware is not allowed. "<span style="color: rgba(0, 0, 0, 1)">);
            };
            const simpleStore </span>=<span style="color: rgba(0, 0, 0, 1)"> {
                getState:store.getState,
                dispatch:(...arge) </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> dispatch(...arge)
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">返回的是创建dispatch函数的集合  每一个元素都是一个函数  调用函数会返回dispatch函数</span>
            const dispatchProducers = middlewares.map((mid)=&gt;<span style="color: rgba(0, 0, 0, 1)">mid(simpleStore));
            console.log(dispatchProducers)
            dispatch </span>=<span style="color: rgba(0, 0, 0, 1)"> compose(...dispatchProducers)(store.dispatch)
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
                ...store,
                dispatch
            }
        }
    }
}</span></pre>
</div>
<p>compose：</p>
<div class="cnblogs_code">
<pre>export <span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(...middlewares){
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> middlewares.reduce((a,b)=&gt;(...args)=&gt;<span style="color: rgba(0, 0, 0, 1)">a(b(...args)))
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> return function(...args){</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">     let lastReturn = null;</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">     for (let index = middlewares.length-1; index &gt;=0; index--) {</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">         //最后一个 将默认的dispatch传递给最后一个中间件  该中间件调用返回一个新的dispatch  并将这个新的dispatch作为参数传递给下一个中间件</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">         if(index == middlewares.length-1){</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">             //该函数接收一个dispatch函数 并返回一个新的dispatch函数</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">             lastReturn = middlewares[index](...args)</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">         }else{</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">             lastReturn = middlewares[index](lastReturn);</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">         }</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">         lastReturn.displayName = `applayMiddle-${index}`;</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">     }</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">     return lastReturn;</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> }</span>
}</pre>
</div>
<p>中间件的组合逻辑：</p>
<p>其核心原理确实与闭包密切相关。具体执行流程如下：</p>
<ol>
<li>‌中间件链式调用机制‌：</li>
</ol>
<ul>
<li>代码通过倒序循环（从最后一个中间件开始）构建调用链<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></span></span></span></li>
<li>每个中间件接收前一个中间件返回的函数作为参数（即<code>next</code>参数）<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></span></span></span></li>
<li>最终返回的是包装了所有中间件逻辑的新dispatch函数<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></li>
</ul>
<ol start="2">
<li>‌闭包的关键作用‌：</li>
</ol>
<ul>
<li>每个中间件函数都通过闭包保存了对前一个中间件返回函数的引用<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></span></span></span></li>
<li>当调用最终返回的dispatch时，会触发第一个中间件的执行，其内部的<code>next()</code>会调用闭包保存的下一个中间件<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></span></span></span></li>
<li>这种链式调用会一直传递到原始dispatch（即代码中的<code>...args</code>）</li>
</ul>
<p>这种设计模式被称为"洋葱模型"，请求从外层中间件进入，响应从内层中间件返回<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId ">。闭包机制确保了每个中间件都能访问到正确的next函数引用，从而形成完整的调用链。</span></span></span></span></span></span></span></p>
<p><span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId ">最后统一导出:</span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre>export {<span style="color: rgba(0, 0, 255, 1)">default</span> as createStore} from './createStore'<span style="color: rgba(0, 0, 0, 1)">;
export {</span><span style="color: rgba(0, 0, 255, 1)">default</span> as bindActionCreators} from './bindActionCreators'<span style="color: rgba(0, 0, 0, 1)">;
export {</span><span style="color: rgba(0, 0, 255, 1)">default</span> as combineReducers} from './combineReducers'<span style="color: rgba(0, 0, 0, 1)">;
export {</span><span style="color: rgba(0, 0, 255, 1)">default</span> as applyMiddleware} from './applyMiddleware';</pre>
</div>
<p>&nbsp;</p>
<div><span style="margin: 0; padding: 0; -webkit-font-smoothing: antialiased; scrollbar-color: rgba(184, 186, 193, 0.6) transparent; scrollbar-width: thin; color: rgba(51, 51, 51, 1); font-family: &quot;PingFang SC&quot;, Arial, sans-serif; font-size: 16px">&nbsp;</span></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8059364477071759" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-15 10:54">2025-05-15 10:54</span>&nbsp;
<a href="https://www.cnblogs.com/nianzhilian">飞奔的龟龟</a>&nbsp;
阅读(<span id="post_view_count">166</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18877335);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18877335', targetLink: 'https://www.cnblogs.com/nianzhilian/p/18877335', title: '详解中间件' })">举报</a>
</div>
        