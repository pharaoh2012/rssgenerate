
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tomorrowland/p/18731022" title="发布于 2025-02-22 16:46">
    <span role="heading" aria-level="2">Java中编译期异常和运行期异常的区别</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在Java中，异常分为<strong>运行期异常（Runtime Exception）</strong>和<strong>编译期异常（Checked Exception）</strong>，两者的核心区别在于 <strong>编译器是否强制要求处理</strong>。以下是它们的详细对比：</p>
<hr>
<h3 id="1-定义与分类"><strong>1. 定义与分类</strong></h3>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>运行期异常（Runtime Exception）</strong></th>
<th><strong>编译期异常（Checked Exception）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>继承关系</strong></td>
<td>继承自 <code>RuntimeException</code>（属于Unchecked Exception）</td>
<td>直接继承自 <code>Exception</code>（但不继承RuntimeException）</td>
</tr>
<tr>
<td><strong>处理要求</strong></td>
<td><strong>不强制处理</strong>（编译器不检查）</td>
<td><strong>必须显式处理</strong>（捕获或抛出，否则编译报错）</td>
</tr>
<tr>
<td><strong>设计意图</strong></td>
<td>表示程序逻辑错误或不可控的运行时问题（如空指针、数组越界）</td>
<td>表示可预见的、需要程序主动处理的异常（如文件不存在、网络中断）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="2-常见示例"><strong>2. 常见示例</strong></h3>
<table>
<thead>
<tr>
<th><strong>运行期异常</strong></th>
<th><strong>编译期异常</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NullPointerException</code></td>
<td><code>IOException</code></td>
</tr>
<tr>
<td><code>ArrayIndexOutOfBoundsException</code></td>
<td><code>SQLException</code></td>
</tr>
<tr>
<td><code>ClassCastException</code></td>
<td><code>FileNotFoundException</code></td>
</tr>
<tr>
<td><code>ArithmeticException</code>（除零错误）</td>
<td><code>InterruptedException</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="3-处理方式对比"><strong>3. 处理方式对比</strong></h3>
<h4 id="1-运行期异常runtime-exception"><strong>(1) 运行期异常（Runtime Exception）</strong></h4>
<ul>
<li><strong>无需强制处理</strong>，但建议在代码中主动避免或捕获。</li>
<li>如果未处理，异常会向上传播，最终导致程序崩溃。</li>
<li><strong>典型场景</strong>：<pre><code class="language-java">// 示例：可能抛出NullPointerException
String str = null;
System.out.println(str.length()); // 运行时抛出异常
</code></pre>
</li>
</ul>
<h4 id="2-编译期异常checked-exception"><strong>(2) 编译期异常（Checked Exception）</strong></h4>
<ul>
<li>
<p><strong>必须显式处理</strong>（否则编译失败）。</p>
</li>
<li>
<p><strong>两种处理方式</strong>：</p>
<ul>
<li><strong>捕获异常</strong>（<code>try-catch</code>）</li>
<li><strong>声明抛出</strong>（<code>throws</code>）</li>
</ul>
<pre><code class="language-java">// 示例：必须处理IOException（编译期检查）
public void readFile() throws IOException { // 方式1：声明抛出
    FileReader file = new FileReader("test.txt");
}

// 或
public void readFile() {
    try {
        FileReader file = new FileReader("test.txt");
    } catch (IOException e) { // 方式2：捕获处理
        e.printStackTrace();
    }
}
</code></pre>
</li>
</ul>
<hr>
<h3 id="4-核心区别总结"><strong>4. 核心区别总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>运行期异常</strong></th>
<th><strong>编译期异常</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>处理强制力</strong></td>
<td>不强制处理（程序员自行决定是否处理）</td>
<td>必须处理（否则编译失败）</td>
</tr>
<tr>
<td><strong>错误类型</strong></td>
<td>程序逻辑错误或不可控的运行时问题</td>
<td>外部依赖导致的、可预见的异常</td>
</tr>
<tr>
<td><strong>代码健壮性</strong></td>
<td>依赖程序员主动预防（如判空、校验参数）</td>
<td>强制程序员处理潜在问题</td>
</tr>
<tr>
<td><strong>典型修复方式</strong></td>
<td>通过代码逻辑修复（如避免空指针、数组越界）</td>
<td>通过异常处理或资源管理（如重试、关闭连接）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="5-为什么这样设计"><strong>5. 为什么这样设计？</strong></h3>
<ul>
<li>
<p><strong>运行期异常</strong>：<br>
通常由程序逻辑错误引起（如空指针、除零错误），属于开发者应主动避免的问题。编译器不强制处理，避免代码冗余。</p>
</li>
<li>
<p><strong>编译期异常</strong>：<br>
表示程序依赖的外部环境可能发生的问题（如文件不存在、网络中断）。强制处理是为了让开发者明确应对这些可预见的异常，提升代码可靠性。</p>
</li>
</ul>
<hr>
<h3 id="6-实际开发中的建议"><strong>6. 实际开发中的建议</strong></h3>
<ol>
<li>
<p><strong>运行期异常</strong>：</p>
<ul>
<li>通过代码逻辑避免（如判空、校验数组索引）。</li>
<li>在关键位置捕获处理（如框架层统一处理）。</li>
</ul>
</li>
<li>
<p><strong>编译期异常</strong>：</p>
<ul>
<li>优先明确处理（如重试文件读取）。</li>
<li>如果无法处理，可向上抛出并记录日志。</li>
</ul>
</li>
<li>
<p><strong>自定义异常</strong>：</p>
<ul>
<li>业务错误通常定义为<code>RuntimeException</code>（避免强制调用方处理）。</li>
<li>需要调用方主动处理的异常定义为<code>Checked Exception</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="一句话总结"><strong>一句话总结</strong></h3>
<ul>
<li><strong>运行期异常</strong>：程序员的锅，编译器不强制背锅。</li>
<li><strong>编译期异常：</strong> 调用方的锅，编译器要求必须背锅！-</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7535835922094908" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-22 16:47">2025-02-22 16:46</span>&nbsp;
<a href="https://www.cnblogs.com/Tomorrowland">Tomorrowland_D</a>&nbsp;
阅读(<span id="post_view_count">51</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18731022" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18731022);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18731022', targetLink: 'https://www.cnblogs.com/Tomorrowland/p/18731022', title: 'Java中编译期异常和运行期异常的区别' })">举报</a>
</div>
        