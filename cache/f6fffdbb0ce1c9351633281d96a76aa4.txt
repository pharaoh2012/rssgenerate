
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/19002752" title="发布于 2025-07-24 14:35">
    <span role="heading" aria-level="2">Django实时通信实战：WebSocket与ASGI全解析（上）</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250724143515401-1374591071.png" alt="Django实时通信实战：WebSocket与ASGI全解析（上）" class="desc_img">
        WebSocket 是一种全双工通信协议，支持实时数据传输，适用于聊天、协作、监控等场景。ASGI 是异步 Web 标准，配合 Uvicorn 服务器和 Django Channels，可实现 Django 的 WebSocket 功能，提升实时应用性能。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一实时通信的核心websocket-协议">一、实时通信的核心：WebSocket 协议</h2>
<h3 id="websocket-介绍">WebSocket 介绍</h3>
<p>在 Web 开发中，实时通信场景（如在线聊天、实时数据监控、协作工具等）越来越常见。传统的 HTTP 协议基于 "请求 - 响应" 模式，无法满足实时双向通信的需求。</p>
<p>WebSocket 是一种在单个 TCP 连接上提供全双工通信的网络协议，它打破了 HTTP 的单向请求限制，让服务器和客户端可以随时向对方发送数据。</p>
<h3 id="websocket-的工作流程">WebSocket 的工作流程</h3>
<ul>
<li>握手阶段：通信始于 HTTP 请求，客户端（通常是浏览器）发送包含<code>Upgrade: websocket</code>字段的请求，申请升级WebSocket 协议</li>
<li>协议切换：服务器同意后返回<code>101 Switching Protocols</code>响应，连接从 HTTP 切换为 WebSocket</li>
<li>数据传输：此后通过帧（Frame）格式传输数据，支持文本帧、二进制帧和控制帧（关闭、ping/pong）。文本帧用于传输文本数据，二进制帧用于传输二进制数据，控制帧用于维护连接状态等操作。</li>
</ul>
<h3 id="websocket-的优势">WebSocket 的优势</h3>
<p>相比传统的 HTTP 轮询（Polling）或长轮询（Long Polling），WebSocket 具有明显优势：</p>
<ul>
<li>低延迟：建立一次连接后持续复用，避免重复握手开销，减少了通信的延迟</li>
<li>全双工：服务器可主动推送数据，无需客户端频繁请求</li>
<li>高效率：帧结构简洁，头部信息远小于 HTTP 头，减少传输开销，提高数据传输效率</li>
</ul>
<h3 id="websocket-的应用场景">WebSocket 的应用场景</h3>
<ul>
<li>实时聊天应用</li>
<li>实时协作工具</li>
<li>金融实时数据监控</li>
<li>在线游戏与互动应用</li>
<li>物联网（IoT）设备控制</li>
<li>实时通知系统</li>
</ul>
<h2 id="二异步-web-的标准asgi">二、异步 Web 的标准：ASGI</h2>
<h3 id="为什么需要-asgi">为什么需要 ASGI？</h3>
<p>要在 Django 中使用 WebSocket，需要依赖 ASGI（Asynchronous Server Gateway Interface）——Python 异步 Web 应用的标准接口。</p>
<ul>
<li>传统的 WSGI 接口仅支持同步操作，无法处理 WebSocket 等异步场景</li>
<li>ASGI 基于 asyncio 实现，支持异步 I/O，能高效处理并发连接</li>
<li>兼容 WSGI 应用，可通过适配器运行现有同步应用</li>
</ul>
<h3 id="asgi-的核心特性">ASGI 的核心特性</h3>
<ul>
<li>原生支持 WebSocket 和 HTTP/2 等实时协议</li>
<li>异步非阻塞处理，提升高并发场景下的性能</li>
<li>标准化接口，让框架（如 Django、FastAPI）和服务器（如 Uvicorn）可无缝协作</li>
</ul>
<p>参考资料：<a href="https://asgi.readthedocs.io/en/latest/" target="_blank" rel="noopener nofollow">ASGI 项目文档</a></p>
<h2 id="三asgi-服务器uvicorn">三、ASGI 服务器：Uvicorn</h2>
<h3 id="uvicorn介绍">Uvicorn介绍</h3>
<p>Uvicorn 是一款高性能的 ASGI 服务器，专为异步 Web 应用设计，是运行 Django 实时应用的理想选择。</p>
<h3 id="安装uvicorn">安装uvicorn</h3>
<pre><code class="language-sh"># standard 是指包含WebSocket支持的完整版
pip install "uvicorn[standard]" 

# 查看版本
uvicorn --version
</code></pre>
<h3 id="运行-django-项目">运行 Django 项目</h3>
<p>Django 项目默认包含<code>asgi.py</code>入口文件，通过 Uvicorn 启动。进入项目根目录（包含manage.py的目录），运行下面命令</p>
<pre><code class="language-sh"># 开发环境（自动重载）
uvicorn mysite.asgi:application --reload

# 或指定地址和端口
uvicorn mysite.asgi:application --host 0.0.0.0 --port 8000 --reload
</code></pre>
<p>参考资料：<a href="https://www.uvicorn.org/" target="_blank" rel="noopener nofollow">uvicorn官方文档</a></p>
<h2 id="四django-channels让-django-支持-websocket">四、Django Channels：让 Django 支持 WebSocket</h2>
<h3 id="django-channels介绍">Django Channels介绍</h3>
<p>Django 本身不直接支持 WebSocket，需要通过Channels扩展实现。Channels 为 Django 添加了异步处理能力，使其能处理 WebSocket、HTTP2 等协议。</p>
<p>Django Channels的核心组件</p>
<ul>
<li>Consumers（消费者）：类似视图（View），处理 WebSocket 连接、消息收发</li>
<li>Routing（路由）：将 WebSocket URL 映射到对应的消费者</li>
<li>Channel Layers（通道层）：跨进程 / 服务器的消息代理，支持 Redis 等后端</li>
<li>Protocols：支持 HTTP、WebSocket 等协议</li>
</ul>
<h3 id="安装与配置">安装与配置</h3>
<p>安装</p>
<pre><code class="language-python">pip install channels
pip install channels_redis
</code></pre>
<p>安装Redis（过程略）</p>
<p>配置Django项目的<code>mysite\mysite\settings.py</code></p>
<pre><code class="language-python">INSTALLED_APPS = [
    # ...其他应用
    "channels",  # 添加Channels
]

# 指定ASGI应用入口
ASGI_APPLICATION = "mysite.asgi.application"

# 配置Redis通道层
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": ["redis://127.0.0.1:6379/3"],  # Redis地址
        },
    },
}
</code></pre>
<p><a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/mysite/settings.py" target="_blank" rel="noopener nofollow">点击查看完整代码</a></p>
<p>配置Django项目的<code>mysite\mysite\asgi.py</code></p>
<pre><code class="language-python">import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")
django_application = get_asgi_application()

# 延迟导入WebSocket路由（避免循环导入）
def get_websocket_application():
    from myapp.websocket.routing import websocket_urlpatterns
    return AuthMiddlewareStack(URLRouter(websocket_urlpatterns))

# 协议路由：区分HTTP和WebSocket请求
application = ProtocolTypeRouter({
    "http": django_application,
    "websocket": get_websocket_application()
})
</code></pre>
<p><a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/mysite/asgi.py" target="_blank" rel="noopener nofollow">点击查看完整代码</a></p>
<h3 id="消费者示例">消费者示例</h3>
<p>消费者（Consumer）是处理 WebSocket 逻辑的核心，类似 Django 的视图，支持同步和异步两种模式。</p>
<p>消费者类型</p>
<ul>
<li><code>AsyncWebsocketConsumer</code>：异步处理（推荐），适合高并发场景</li>
<li><code>SyncWebsocketConsumer</code>：同步处理，适合简单逻辑或需集成同步代码</li>
<li><code>JsonWebsocketConsumer</code>：专门处理 JSON 格式消息，自动解析 / 序列化</li>
</ul>
<p>异步消费者示例</p>
<ul>
<li>connect() ：当客户端发起 WebSocket 连接时调用。</li>
<li>disconnect() ：当客户端关闭 WebSocket 连接时调用。</li>
<li>receive() ：当接收到客户端发送的消息时调用。</li>
<li>send() ：用于向客户端发送消息。</li>
</ul>
<pre><code class="language-python">from channels.generic.websocket import AsyncWebsocketConsumer
import json

class ChatConsumer(AsyncWebsocketConsumer):
    # 连接建立时调用
    async def connect(self):
        # 从URL获取房间名
        self.room_name = self.scope["url_route"]["kwargs"]["room_name"]
        self.room_group_name = f"chat_{self.room_name}"
        
        # 加入房间组
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        # 接受连接
        await self.accept()

    # 连接关闭时调用
    async def disconnect(self, close_code):
        # 离开房间组
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    # 接收客户端消息
    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json["message"]
        
        # 发送消息到房间组（广播给同组所有连接）
        await self.channel_layer.group_send(
            self.room_group_name,
            {"type": "chat.message", "message": message}
        )

    # 处理房间组消息（方法名对应group_send中的type字段）
    async def chat.message(self, event):
        message = event["message"]
        # 发送消息给客户端
        await self.send(text_data=json.dumps({"message": message}))
</code></pre>
<h3 id="路由配置示例">路由配置示例</h3>
<p>通过路由将 WebSocket URL 映射到消费者，类似 Django 的 URL 配置</p>
<pre><code class="language-python"># routing.py
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r"ws/chat/(?P&lt;room_name&gt;\w+)/$", consumers.ChatConsumer.as_asgi()),
]
</code></pre>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-24 14:36">2025-07-24 14:35</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">19</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19002752);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19002752', targetLink: 'https://www.cnblogs.com/xwz1024/p/19002752', title: 'Django实时通信实战：WebSocket与ASGI全解析（上）' })">举报</a>
</div>
	