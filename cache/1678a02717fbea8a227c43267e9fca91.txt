
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/18824239" title="发布于 2025-04-14 10:08">
    <span role="heading" aria-level="2">基于源码分析 HikariCP 常见参数的具体含义</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        本文从源码角度对 HikariCP 中的一些常见参数进行分析，希望能帮助大家更加清晰地理解这些参数的具体含义。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-tool="mdnice编辑器"><span>HikariCP 是目前风头最劲的 JDBC 连接池，号称性能最佳，SpringBoot 2.0 也将 HikariCP 作为默认的数据库连接池。</span></p>
<p data-tool="mdnice编辑器"><span>要想用好 HikariCP，理解常见参数的具体含义至关重要。但是对于某些参数，尽管官方文档给出了详细解释，很多开发、DBA 读完后还是会感到困惑。</span></p>
<p data-tool="mdnice编辑器"><span>因此，本文将从源码角度对 HikariCP 中的一些常见参数进行分析，希望能帮助大家更加清晰地理解这些参数的具体含义。</span></p>
<p data-tool="mdnice编辑器"><span>本文将分析的参数包括：</span></p>
<ul class="list-paddingleft-1">
<li><span>maximumPoolSize</span></li>
<li><span>minimumIdle</span></li>
<li><span>connectionTimeout</span></li>
<li><span>idleTimeout 及空闲连接的清理逻辑。</span></li>
<li><span>maxLifetime</span></li>
<li><span>keepaliveTime</span></li>
<li><span>connectionTestQuery 及连接有效性检测的实现逻辑。</span></li>
<li><span>leakDetectionThreshold</span></li>
<li><span>什么时候会检测连接的有效性？</span></li>
</ul>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">maximumPoolSize</span></h1>
<p data-tool="mdnice编辑器"><span>连接池可以创建的最大连接数，包括空闲和活动连接。默认值为 10。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>if<span>&nbsp;(maxPoolSize &lt;&nbsp;1<span>) {<span><br><span>&nbsp; &nbsp;maxPoolSize = DEFAULT_POOL_SIZE;<span><br><span>}<span><br></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果未显式设置 maxPoolSize，则默认为 -1，此时连接池会使用默认的最大连接数 DEFAULT_POOL_SIZE（10）。</span></p>
<p data-tool="mdnice编辑器"><span>当连接池达到该限制且没有可用的空闲连接时，对新连接的请求（通过&nbsp;<code><span>getConnection()</span></code><span>）将会阻塞，最多等待 connectionTimeout 毫秒，然后超时失败。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;Connection&nbsp;<span>getConnection<span>()<span>&nbsp;<span>throws<span>&nbsp;SQLException<span><br><span>{<span><br><span>&nbsp; &nbsp;return<span>&nbsp;getConnection(connectionTimeout);<span><br><span>}<span><br><span><br><span>public<span>&nbsp;Connection&nbsp;<span>getConnection<span>(<span>final<span>&nbsp;<span>long<span>&nbsp;hardTimeout)<span>&nbsp;<span>throws<span>&nbsp;SQLException<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; suspendResumeLock.acquire();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;startTime = currentTime();<span><br><span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var<span>&nbsp;timeout = hardTimeout;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var<span>&nbsp;poolEntry = connectionBag.borrow(timeout, MILLISECONDS);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">minimumIdle</span></h1>
<p data-tool="mdnice编辑器"><span>最小空闲连接数。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>if<span>&nbsp;(minIdle &lt;&nbsp;0<span>&nbsp;|| minIdle &gt; maxPoolSize) {<span><br><span>&nbsp; &nbsp;minIdle = maxPoolSize;<span><br><span>}<span><br></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果未显式设置 minimumIdle，则默认为 -1，此时会取 maximumPoolSize 的值。官方建议不要设置这个参数，让 HikariCP 作为一个固定大小的连接池进行管理。</span></p>
<p data-tool="mdnice编辑器"><span>如果连接池中的空闲连接数低于 minimumIdle，且连接池中的总连接数小于 maximumPoolSize（最大连接数），HikariCP 会调用<code><span>fillPool</span></code><span>方法补充连接。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>private<span>&nbsp;<span>synchronized<span>&nbsp;<span>void<span>&nbsp;<span>fillPool<span>(<span>final<span>&nbsp;<span>boolean<span>&nbsp;isAfterAdd)<span><br><span>{ &nbsp;<span><br><span>&nbsp; &nbsp;// 获取当前空闲连接数<span><br><span>&nbsp; &nbsp;finalvar<span>&nbsp;idle = getIdleConnections();<span><br><span>&nbsp; &nbsp;// 检查是否需要创建新连接，创建新连接的条件是总连接数小于 maximumPoolSize 且空闲连接数小于 minimumIdle。<span><br><span>&nbsp; &nbsp;finalvar<span>&nbsp;shouldAdd = getTotalConnections() &lt; config.getMaximumPoolSize() &amp;&amp; idle &lt; config.getMinimumIdle();<span><br><span><br><span>&nbsp; &nbsp;if<span>&nbsp;(shouldAdd) {<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;// 计算需要创建的连接数<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;countToAdd = config.getMinimumIdle() - idle;<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;for<span>&nbsp;(int<span>&nbsp;i =&nbsp;0<span>; i &lt; countToAdd; i++)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addConnectionExecutor.submit(isAfterAdd ? postFillPoolEntryCreator : poolEntryCreator);<span><br><span>&nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp;elseif<span>&nbsp;(isAfterAdd) {<span><br><span>&nbsp; &nbsp; &nbsp; logger.debug("{} - Fill pool skipped, pool has sufficient level or currently being filled."<span>, poolName);<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><code><span>fillPool</span></code><span>会在三种场景下调用：</span></p>
<ol class="list-paddingleft-1">
<li><span>销毁连接时。</span></li>
<li><span>HouseKeeper 的周期性任务中。</span></li>
<li><span>恢复暂停的连接池时（这种场景不常见，可忽略）。</span></li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">connectionTimeout</span></h1>
<p data-tool="mdnice编辑器"><span>获取连接时的最大等待时间，单位为毫秒，默认值为 30000（30秒），最小允许值是 250。</span></p>
<p data-tool="mdnice编辑器"><span>如果 connectionTimeout 设置为 0，则它会取 Java&nbsp;<code><span>int</span></code><span>&nbsp;类型的最大值，即 2147483647，约 24.85 天。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;<span>void<span>&nbsp;<span>setConnectionTimeout<span>(<span>long<span>&nbsp;connectionTimeoutMs)<span><br><span>{<span><br><span>&nbsp; &nbsp;if<span>&nbsp;(connectionTimeoutMs ==&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;this<span>.connectionTimeout = Integer.MAX_VALUE;<span><br><span>&nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp;else<span>&nbsp;if<span>&nbsp;(connectionTimeoutMs &lt; SOFT_TIMEOUT_FLOOR) {<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;throw<span>&nbsp;new<span>&nbsp;IllegalArgumentException("connectionTimeout cannot be less than "<span>&nbsp;+ SOFT_TIMEOUT_FLOOR +&nbsp;"ms"<span>);<span><br><span>&nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;this<span>.connectionTimeout = connectionTimeoutMs;<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">idleTimeout</span></h1>
<p data-tool="mdnice编辑器"><span>空闲连接的超时时长，单位为毫秒。超过指定时长的连接将被销毁掉。默认值为 600000（10分钟），最小允许值是 10000（10秒）。</span></p>
<p data-tool="mdnice编辑器"><span>注意，如果 idleTimeout 的设置不合理，连接池会基于其它参数的值来设置 idleTimeout，具体逻辑如下：</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>// 如果 idleTimeout 与 maxLifetime 的值过于接近，且 maxLifetime 大于 0，连接池将禁用 idleTimeout，避免设置的超时时间影响连接生命周期。<span><br>if<span>&nbsp;(idleTimeout + SECONDS.toMillis(1<span>) &gt; maxLifetime &amp;&amp; maxLifetime &gt;&nbsp;0<span>&nbsp;&amp;&amp; minIdle &lt; maxPoolSize) {<span><br><span>&nbsp; &nbsp;LOGGER.warn("{} - idleTimeout is close to or more than maxLifetime, disabling it."<span>, poolName);<span><br><span>&nbsp; &nbsp;idleTimeout =&nbsp;0<span>;<span><br><span>}&nbsp;// 如果 idleTimeout 小于 10 秒，且 minIdle 小于最大连接数 maxPoolSize，连接池会将 idleTimeout 设置为默认值 IDLE_TIMEOUT（10分钟），避免空闲连接存活时间过短影响池的正常使用。<span><br>else<span>&nbsp;if<span>&nbsp;(idleTimeout !=&nbsp;0<span>&nbsp;&amp;&amp; idleTimeout &lt; SECONDS.toMillis(10<span>) &amp;&amp; minIdle &lt; maxPoolSize) {<span><br><span>&nbsp; &nbsp;LOGGER.warn("{} - idleTimeout is less than 10000ms, setting to default {}ms."<span>, poolName, IDLE_TIMEOUT);<span><br><span>&nbsp; &nbsp;idleTimeout = IDLE_TIMEOUT;<span><br><span>}&nbsp;// 如果连接池已配置为固定大小（即 minIdle == maxPoolSize），并且 idleTimeout 被显式设置，连接池会发出警告，说明该设置无效。<span><br>else<span>&nbsp;&nbsp;if<span>&nbsp;(idleTimeout != IDLE_TIMEOUT &amp;&amp; idleTimeout !=&nbsp;0<span>&nbsp;&amp;&amp; minIdle == maxPoolSize) {<span><br><span>&nbsp; &nbsp;LOGGER.warn("{} - idleTimeout has been set but has no effect because the pool is operating as a fixed size pool."<span>, poolName);<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>连接池中的空闲连接是指当前没有被使用、处于空闲状态的连接。空闲连接可以随时被借用（即从连接池中获取）来进行数据库操作。</span></p>
<p data-tool="mdnice编辑器"><span>注意，空闲连接在 MySQL 中的状态是<code><span>Sleep</span></code><span>，但不是所有<code><span>Sleep</span></code><span>状态的连接都是空闲连接。</span></span></span></p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">空闲连接的清理逻辑</span></h2>
<p data-tool="mdnice编辑器"><span>空闲连接由 HouseKeeper 定期清理。</span></p>
<p data-tool="mdnice编辑器"><span>HouseKeeper 是 HikariCP 中的一个定时任务，负责清理空闲连接、调整连接池大小等。</span></p>
<p data-tool="mdnice编辑器"><span>HouseKeeper 会在启动后 100 毫秒执行第一次任务，然后每隔 housekeepingPeriodMs 毫秒执行一次。</span></p>
<p data-tool="mdnice编辑器"><span>housekeepingPeriodMs 的值由<code><span>com.zaxxer.hikari.housekeeping.periodMs</span></code><span>决定，默认是 30000 毫秒（30秒）。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>private<span>&nbsp;final<span>&nbsp;long<span>&nbsp;housekeepingPeriodMs = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs"<span>, SECONDS.toMillis(30<span>));<span><br><span>&nbsp; &nbsp;<span><br>this<span>.houseKeeperTask = houseKeepingExecutorService.scheduleWithFixedDelay(new<span>&nbsp;HouseKeeper(),&nbsp;100L<span>, housekeepingPeriodMs, MILLISECONDS);<span><br></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>下面我们看看 HouseKeeper 任务具体的实现逻辑。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>private<span>&nbsp;final<span>class<span>&nbsp;<span>HouseKeeper<span>&nbsp;<span>implements<span>&nbsp;<span>Runnable<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;<span>public<span>&nbsp;<span>void<span>&nbsp;<span>run<span>()<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(idleTimeout &gt;&nbsp;0L<span>&nbsp;&amp;&amp; config.getMinimumIdle() &lt; config.getMaximumPoolSize()) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;logPoolState("Before cleanup "<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 获取连接池所有未使用的连接（STATE_NOT_IN_USE）<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;finalvar<span>&nbsp;notInUse = connectionBag.values(STATE_NOT_IN_USE);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 计算需要清理的连接数 maxToRemove，即当前未使用连接数减去最小空闲连接数。<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var<span>&nbsp;maxToRemove = notInUse.size() - config.getMinimumIdle();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for<span>&nbsp;(PoolEntry entry : notInUse) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果连接的空闲时间超过 idleTimeout，则关闭该连接。<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(maxToRemove &gt;&nbsp;0<span>&nbsp;&amp;&amp; elapsedMillis(entry.lastAccessed, now) &gt; idleTimeout &amp;&amp; connectionBag.reserve(entry)) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;closeConnection(entry,&nbsp;"(connection has passed idleTimeout)"<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;maxToRemove--;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;logPoolState("After cleanup &nbsp;"<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;logPoolState("Pool "<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 调用 fillPool(true) 以确保连接池维持最小空闲连接数。<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fillPool(true<span>);&nbsp;// Try to maintain minimum connections<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;catch<span>&nbsp;(Exception e) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.error("Unexpected exception in housekeeping task"<span>, e);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>可以看到，空闲连接能回收的前提是 idleTimeout 大于 0，且 minIdle 小于 maxPoolSize。</span></p>
<p data-tool="mdnice编辑器"><span>如果按照官方建议不显式设置 minIdle 的话，则 minIdle 会取 maxPoolSize 的值，此时空闲连接将不会被回收。</span></p>
<p data-tool="mdnice编辑器"><span>无论是否回收空闲连接，最后都会调用 fillPool 来填充连接池，以确保池中有足够的连接。</span></p>
<p data-tool="mdnice编辑器"><span>空闲连接的持续时长是通过<code><span>elapsedMillis(entry.lastAccessed, now)</span></code><span>计算的，其中 entry.lastAccessed 记录了连接最后一次被访问的时间。该时间戳会在以下两种场景下设置：</span></span></p>
<ol class="list-paddingleft-1">
<li><span>创建物理连接时：当一个新的连接被创建并加入连接池时，lastAccessed 会被设置为当前时间，表示连接的创建时间。</span></li>
<li><span>连接归还给连接池时：当连接被归还给连接池时，lastAccessed 会更新为归还时的时间。</span></li>
</ol>
<p data-tool="mdnice编辑器"><span>因此，空闲连接的持续时长实际上等于当前系统时间减去连接最后一次归还给连接池的时间。</span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">maxLifetime</span></h1>
<p data-tool="mdnice编辑器"><span>连接池中连接的最大生命周期，单位为毫秒。默认值为 1800000（30分钟），最小允许值是 30000（30秒）。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>if<span>&nbsp;(maxLifetime !=&nbsp;0<span>&nbsp;&amp;&amp; maxLifetime &lt; SECONDS.toMillis(30<span>)) {<span><br><span>&nbsp; &nbsp;LOGGER.warn("{} - maxLifetime is less than 30000ms, setting to default {}ms."<span>, poolName, MAX_LIFETIME);<span><br><span>&nbsp; &nbsp;maxLifetime = MAX_LIFETIME;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果 maxLifetime 设置为 0，则表示不限制连接的最大生命周期。</span></p>
<p data-tool="mdnice编辑器"><span>如果 maxLifetime 不等于 0 且小于 30 秒，则会输出警告日志，提示 maxLifetime 设置过短，并将 maxLifetime 设置为默认的最大生命周期 MAX_LIFETIME（即 30 分钟）。</span></p>
<p data-tool="mdnice编辑器"><span>在创建一个新的物理连接时，会为其设置一个到期执行的任务<code><span>MaxLifetimeTask</span></code><span>，该任务将在连接的生命周期到期时执行。连接的生命周期时间等于 maxLifetime 减去一个随机偏移量。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>private<span>&nbsp;PoolEntry&nbsp;<span>createPoolEntry<span>()<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;finalvar<span>&nbsp;poolEntry = newPoolEntry(getTotalConnections() ==&nbsp;0<span>);<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;finalvar<span>&nbsp;maxLifetime = config.getMaxLifetime();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if<span>&nbsp;(maxLifetime &gt;&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果 maxLifetime 大于 10000 毫秒，则生成一个最大为 maxLifetime 的 25% 的随机偏移量<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;variance = maxLifetime &gt;&nbsp;10_000L<span>&nbsp;? ThreadLocalRandom.current().nextLong( maxLifetime / lifeTimeVarianceFactor ) :&nbsp;0L<span>;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;lifetime = maxLifetime - variance;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolEntry.setFutureEol(houseKeepingExecutorService.schedule(new<span>&nbsp;MaxLifetimeTask(poolEntry), lifetime, MILLISECONDS));<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return<span>&nbsp;poolEntry;<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;returnnull<span>;<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>当连接的生命周期（lifetime）到期时，MaxLifetimeTask 会被触发，它会调用 softEvictConnection() 方法尝试驱逐该连接。如果驱逐成功，则会调用 addBagItem() 方法判断是否向连接池中添加新的连接。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>private<span>&nbsp;final<span>&nbsp;<span>class<span>&nbsp;<span>MaxLifetimeTask<span>&nbsp;<span>implements<span>&nbsp;<span>Runnable<span><br><span>{<span><br><span>&nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp;<span>public<span>&nbsp;<span>void<span>&nbsp;<span>run<span>()<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(softEvictConnection(poolEntry,&nbsp;"(connection has passed maxLifetime)"<span>,&nbsp;false<span>&nbsp;/* not owner */<span>)) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addBagItem(connectionBag.getWaitingThreadCount());<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>下面我们看看<code><span>softEvictConnection()</span></code><span>的实现逻辑。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>private<span>&nbsp;<span>boolean<span>&nbsp;<span>softEvictConnection<span>(<span>final<span>&nbsp;PoolEntry poolEntry,&nbsp;<span>final<span>&nbsp;String reason,&nbsp;<span>final<span>&nbsp;<span>boolean<span>&nbsp;owner)<span><br><span>{<span><br><span>&nbsp; &nbsp;// 将连接标记为驱逐状态<span><br><span>&nbsp; &nbsp;poolEntry.markEvicted();<span><br><span>&nbsp; &nbsp;if<span>&nbsp;(owner || connectionBag.reserve(poolEntry)) {<span><br><span>&nbsp; &nbsp; &nbsp; closeConnection(poolEntry, reason);<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;returntrue<span>;<span><br><span>&nbsp; &nbsp;}<span><br><span><br><span>&nbsp; &nbsp;returnfalse<span>;<span><br><span>}<span><br><span><br><span>void<span>&nbsp;<span>markEvicted<span>()<span><br><span>{<span><br><span>&nbsp; &nbsp;this<span>.evict =&nbsp;true<span>;<span><br><span>}<span><br><span><br><span>public<span>&nbsp;<span>boolean<span>&nbsp;<span>reserve<span>(<span>final<span>&nbsp;T bagEntry)<span><br><span>{<span><br><span>&nbsp; &nbsp;return<span>&nbsp;bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_RESERVED);<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>连接首先会被标记为驱逐状态。</span></p>
<p data-tool="mdnice编辑器"><span>如果调用者是连接的拥有者，或者连接的状态可以从 STATE_NOT_IN_USE（未使用）转变为 STATE_RESERVED（已预留），则会调用 closeConnection 销毁该连接。</span></p>
<p data-tool="mdnice编辑器"><span>需要注意的是，对于正在使用的连接，<strong>仅会将其标记为驱逐状态，而不会销毁</strong><span>，即使其生命周期已经到期。只有当连接被归还到连接池时，才会真正执行销毁操作。</span></span></p>
<p data-tool="mdnice编辑器"><span>下面是连接归还到连接池时的实现细节。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>void<span>&nbsp;<span>recycle<span>(<span>final<span>&nbsp;PoolEntry poolEntry)<span><br><span>{<span><br><span>&nbsp; &nbsp;metricsTracker.recordConnectionUsage(poolEntry);<span><br><span>&nbsp; &nbsp;// 如果连接被标记为驱逐状态，则销毁连接<span><br><span>&nbsp; &nbsp;if<span>&nbsp;(poolEntry.isMarkedEvicted()) {&nbsp;<span><br><span>&nbsp; &nbsp; &nbsp; closeConnection(poolEntry, EVICTED_CONNECTION_MESSAGE);<span><br><span>&nbsp; &nbsp;}&nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isRequestBoundariesEnabled) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolEntry.connection.endRequest();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;catch<span>&nbsp;(SQLException e) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.warn("endRequest Failed for: {},({})"<span>, poolEntry.connection, e.getMessage());<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;// 如果连接未被标记为驱逐，将执行正常的连接归还操作<span><br><span>&nbsp; &nbsp; &nbsp; connectionBag.requite(poolEntry);<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果连接被标记为驱逐状态，则会销毁该连接。如果连接未被标记为驱逐，则会执行正常的连接归还操作。</span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">keepaliveTime</span></h1>
<p data-tool="mdnice编辑器"><span>对空闲连接进行定期心跳检测的时间间隔，单位为毫秒。默认值为 120000（2分钟），最小允许值是 30000（30秒）。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>if<span>&nbsp;(keepaliveTime !=&nbsp;0<span>&nbsp;&amp;&amp; keepaliveTime &lt; SECONDS.toMillis(30<span>)) {<span><br><span>&nbsp; &nbsp;LOGGER.warn("{} - keepaliveTime is less than 30000ms, disabling it."<span>, poolName);<span><br><span>&nbsp; &nbsp;keepaliveTime =&nbsp;0L<span>;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果 keepaliveTime 不等于 0 且小于 30 秒，则输出警告日志，提示 keepaliveTime 设置过短，并禁用心跳检测（将 keepaliveTime &nbsp;设置为 0）。</span></p>
<p data-tool="mdnice编辑器"><span>定期检测的目的主要有两个：</span></p>
<ol class="list-paddingleft-1">
<li>
<p><span>检测连接是否失效。</span></p>
</li>
<li>
<p><span>防止连接因长时间空闲而被数据库或其他中间层关闭。</span></p>
</li>
</ol>
<p data-tool="mdnice编辑器"><span>在创建新的物理连接时，会为其设置一个定期执行的任务<code><span>KeepaliveTask</span></code><span>，该任务会在 heartbeatTime 后首次执行，并随后以相同的时间间隔（heartbeatTime）重复执行。heartbeatTime 等于 keepaliveTime 减去一个随机偏移量（variance）。</span></span></p>
<p data-tool="mdnice编辑器"><span>variance 是最大为 keepaliveTime 的 10% 的随机偏移量。引入该随机偏移量的目的是为了避免所有连接在同一时刻发送心跳，从而减轻系统资源竞争和负载。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>private<span>&nbsp;PoolEntry&nbsp;<span>createPoolEntry<span>()<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;finalvar<span>&nbsp;poolEntry = newPoolEntry(getTotalConnections() ==&nbsp;0<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;finallong<span>&nbsp;keepaliveTime = config.getKeepaliveTime();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if<span>&nbsp;(keepaliveTime &gt;&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// variance up to 10% of the heartbeat time<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;variance = ThreadLocalRandom.current().nextLong(keepaliveTime /&nbsp;10<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;heartbeatTime = keepaliveTime - variance;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolEntry.setKeepalive(houseKeepingExecutorService.scheduleWithFixedDelay(new<span>&nbsp;KeepaliveTask(poolEntry), heartbeatTime, heartbeatTime, MILLISECONDS));<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return<span>&nbsp;poolEntry;<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;returnnull<span>;<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>以下是 KeepaliveTask 的具体实现。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>private<span>&nbsp;final<span>class<span>&nbsp;<span>KeepaliveTask<span>&nbsp;<span>implements<span>&nbsp;<span>Runnable<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;<span>public<span>&nbsp;<span>void<span>&nbsp;<span>run<span>()<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 尝试将连接的状态从 STATE_NOT_IN_USE（未使用）改为 STATE_RESERVED（已保留），防止它被其他线程借用<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if<span>&nbsp;(connectionBag.reserve(poolEntry)) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 检查连接是否失效<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isConnectionDead(poolEntry.connection)) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 将连接从连接池中移除并关闭<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;softEvictConnection(poolEntry, DEAD_CONNECTION_MESSAGE,&nbsp;true<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 检查当前等待连接的线程数，判断是否向连接池中添加新的连接<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addBagItem(connectionBag.getWaitingThreadCount());<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;connectionBag.unreserve(poolEntry);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;logger.debug("{} - keepalive: connection {} is alive"<span>, poolName, poolEntry.connection);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">connectionTestQuery</span></h1>
<p data-tool="mdnice编辑器"><span>用于设置连接检测语句，默认为 none。</span></p>
<p data-tool="mdnice编辑器"><span>对于支持 JDBC4 的驱动程序，建议不要设置该参数，因为 JDBC4 提供了<code><span>Connection.isValid()</span></code><span>方法来进行连接有效性检查。</span></span></p>
<p data-tool="mdnice编辑器"><span>JDBC4 是 Java Database Connectivity (JDBC) 的第 4 版，首次在 Java 6（即 Java 1.6）中引入。因此，只要程序使用的是 Java 1.6 及更高版本，就可以使用<code><span>isValid()</span></code><span>方法。</span></span></p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">连接有效性检测的实现逻辑</span></h2>
<p data-tool="mdnice编辑器"><span>如果 connectionTestQuery 为 none，则会将 isUseJdbc4Validation 设置为 true。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>// 如果 connectionTestQuery 为 none，则将其设置为 null<span><br><span>connectionTestQuery = getNullIfEmpty(connectionTestQuery);<span><br><span><br>// 如果 connectionTestQuery 为 null，则 isUseJdbc4Validation 设置为 true。<span><br>this<span>.isUseJdbc4Validation = config.getConnectionTestQuery() ==&nbsp;null<span>;<span><br></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>isUseJdbc4Validation 会用在两个地方：</span></p>
<ol class="list-paddingleft-1">
<li>
<p><span>判断驱动是否支持<code><span>connection.isValid</span></code><span>方法。</span></span></p>
</li>
<li>
<p><span>检测连接是否失效。</span></p>
</li>
</ol>
<p data-tool="mdnice编辑器"><span>检测连接是否失效是在<code><span>isConnectionDead</span></code><span>中实现的。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>boolean<span>&nbsp;<span>isConnectionDead<span>(<span>final<span>&nbsp;Connection connection)<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setNetworkTimeout(connection, validationTimeout);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;validationSeconds = (int<span>) Math.max(1000L<span>, validationTimeout) /&nbsp;1000<span>;<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isUseJdbc4Validation) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return<span>&nbsp;!connection.isValid(validationSeconds);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;(var<span>&nbsp;statement = connection.createStatement()) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if<span>&nbsp;(isNetworkTimeoutSupported != TRUE) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setQueryTimeout(statement, validationSeconds);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statement.execute(config.getConnectionTestQuery());<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>可以看到，如果 isUseJdbc4Validation 为 true，则会调用<code><span>connection.isValid</span></code><span>方法来检测连接的有效性。否则，系统将使用配置的 connectionTestQuery 来执行 SQL 查询，以检查连接是否有效。</span></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">leakDetectionThreshold</span></h1>
<p data-tool="mdnice编辑器"><span>连接从池中取出后，如果未归还超过一定时间，则会记录日志，提示可能的连接泄漏。默认值为 0，表示禁用泄漏检测。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>if<span>&nbsp;(leakDetectionThreshold &gt;&nbsp;0<span>&nbsp;&amp;&amp; !unitTest) {<span><br><span>&nbsp; &nbsp;if<span>&nbsp;(leakDetectionThreshold &lt; SECONDS.toMillis(2<span>) || (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt;&nbsp;0<span>)) {<span><br><span>&nbsp; &nbsp; &nbsp; LOGGER.warn("{} - leakDetectionThreshold is less than 2000ms or more than maxLifetime, disabling it."<span>, poolName);<span><br><span>&nbsp; &nbsp; &nbsp; leakDetectionThreshold =&nbsp;0<span>;<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果 leakDetectionThreshold 小于 2 秒，或者 leakDetectionThreshold 大于连接池的 maxLifetime，则会发出警告，并将其重置为 0，禁用泄漏检测。</span></p>
<p data-tool="mdnice编辑器"><span>实现细节可参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTY2MjU5MQ==&amp;mid=2247496515&amp;idx=1&amp;sn=b223ba9e8608f5e9642a32cd9fc8a72f&amp;scene=21#wechat_redirect" rel="noopener nofollow"><span>如何定位 Druid &amp; HikariCP 连接池的连接泄漏问题？</span></a></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">什么时候会检测连接的有效性？</span></h1>
<p data-tool="mdnice编辑器"><span>除了通过 KeepaliveTask 定期检查连接的有效性外，HikariCP 还会在借用连接时进行有效性检测。</span></p>
<p data-tool="mdnice编辑器"><span>这个检测逻辑在 getConnection 方法中实现。具体来说，在从连接池借用连接后，会检查连接的最后归还时间（poolEntry.lastAccessed）与当前时间的差值是否超过 aliveBypassWindowMs（默认 500 毫秒）。如果超过该时间阈值，则会调用&nbsp;<code><span>isConnectionDead(poolEntry.connection)</span></code><span>&nbsp;来检查连接是否失效。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpYg55r1LRjLZWuxdAVB6FMcwEPe5TfyTMpq5oraT2UmAx2X5HBfnS5Q5AZVTNsFIWyfwawdLlELM/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;Connection&nbsp;<span>getConnection<span>(<span>final<span>&nbsp;<span>long<span>&nbsp;hardTimeout)<span>&nbsp;<span>throws<span>&nbsp;SQLException<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; suspendResumeLock.acquire();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;startTime = currentTime();<span><br><span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var<span>&nbsp;timeout = hardTimeout;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 从连接池中借用一个连接<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var<span>&nbsp;poolEntry = connectionBag.borrow(timeout, MILLISECONDS);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(poolEntry ==&nbsp;null<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break<span>;&nbsp;// We timed out... break and throw exception<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;now = currentTime();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(poolEntry.isMarkedEvicted() || (elapsedMillis(poolEntry.lastAccessed, now) &gt; aliveBypassWindowMs &amp;&amp; isConnectionDead(poolEntry.connection))) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;closeConnection(poolEntry, poolEntry.isMarkedEvicted() ? EVICTED_CONNECTION_MESSAGE : DEAD_CONNECTION_MESSAGE);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timeout = hardTimeout - elapsedMillis(startTime);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return<span>&nbsp;poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry));<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;while<span>&nbsp;(timeout &gt;&nbsp;0L<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>aliveBypassWindowMs 由配置项<code><span>com.zaxxer.hikari.aliveBypassWindowMs</span></code><span>控制，默认值为 500 毫秒。</span></span></p>
<p data-tool="mdnice编辑器"><span>这一逻辑与其他连接池中的 testOnBorrow 参数类似，只不过 testOnBorrow 是每次都检查，而 HikariCP 只有在连接空闲超过 500 毫秒时才会检查。</span></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6757972024930555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 10:08">2025-04-14 10:08</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18824239);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18824239', targetLink: 'https://www.cnblogs.com/ivictor/p/18824239', title: '基于源码分析 HikariCP 常见参数的具体含义' })">举报</a>
</div>
	