
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wangerdan115/p/18937605" title="发布于 2025-06-20 09:08">
    <span role="heading" aria-level="2">鸿蒙运动项目开发：封装超级好用的 RCP 网络库（下）—— 实战应用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="鸿蒙核心技术运动开发-remote-communication-kit远场通信服务">鸿蒙核心技术##运动开发## Remote Communication Kit（远场通信服务）</h2>
<p>在之前的文章中，我们详细介绍了如何封装一个功能完备的 RCP 网络库，并探讨了其核心功能和高级特性。在本篇中，我们将展示如何在鸿蒙运动项目中使用这个网络库来实现具体的网络请求功能。</p>
<h2 id="前言">前言</h2>
<p>在鸿蒙运动项目中，网络请求是实现功能的关键环节之一。无论是获取运动数据、同步用户信息，还是加载运动视频资源，都需要一个稳定、高效且易于使用的网络库。在本篇中，我们将通过实际代码样例，展示如何使用封装好的 RCP 网络库实现这些功能。</p>
<h2 id="一封装异常处理">一、封装异常处理</h2>
<p>在实际开发中，异常处理是网络请求中不可或缺的一部分。通过自定义异常类，我们可以更好地管理网络请求中可能出现的各种错误。</p>
<h3 id="一自定义异常类">（一）自定义异常类</h3>
<p>定义了一个 <code>ApiException</code> 类，用于封装 API 请求中的错误信息。</p>
<pre><code class="language-typescript">export class ApiException extends Error {
  apiCode?: number;
  apiMessage?: string;

  constructor(apiCode?: number, apiMessage?: string) {
    super();
    this.name = "ApiException";
    this.apiCode = apiCode;
    this.apiMessage = apiMessage;
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>自定义属性</strong>：<code>apiCode</code> 和 <code>apiMessage</code> 用于存储 API 返回的错误代码和错误信息。</li>
<li><strong>构造函数</strong>：通过构造函数初始化异常对象，并设置错误代码和错误信息。</li>
</ol>
<h2 id="二封装网络请求">二、封装网络请求</h2>
<p>为了简化网络请求的实现，你封装了一个 <code>ApiRequest</code> 类，用于统一管理网络请求和错误处理。</p>
<h3 id="一单例模式">（一）单例模式</h3>
<p><code>ApiRequest</code> 类使用了单例模式，确保全局只有一个实例。</p>
<pre><code class="language-typescript">
import { DataResult, ErrorCodes, ErrorData, LibToast, NetworkException, SuccessData } from "lib_base";
import { RcpNetworkService } from "lib_base/src/main/ets/utils/rcpnet/RcpService";
import { ApiResult } from "../data/models/ApiResult";
import { ApiException } from "./ApiException";

export interface IApiRequestHandleBusinessError{
  handleBusinessError(apiException: ApiException): boolean
}

export class ApiRequest{

  private static instance: ApiRequest


  static getInstance (): ApiRequest {
    if (!ApiRequest.instance) {
      ApiRequest.instance = new ApiRequest()
    }
    return ApiRequest.instance
  }

  private _net?: RcpNetworkService | undefined;
  private _i_api_equest_handle_business_error?: IApiRequestHandleBusinessError | undefined;

  public set i_api_equest_handle_business_error(value: IApiRequestHandleBusinessError | undefined) {
    this._i_api_equest_handle_business_error = value;
  }

  public set net(value: RcpNetworkService | undefined) {
    this._net = value;
  }

  public getService() : RcpNetworkService{
    return this._net!;
  }


  

}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>单例模式</strong>：通过 <code>getInstance</code> 方法确保 <code>ApiRequest</code> 的全局唯一性。</li>
<li><strong>依赖注入</strong>：通过 <code>set</code> 方法注入 <code>RcpNetworkService</code> 和 <code>IApiRequestHandleBusinessError</code>，增强类的灵活性。</li>
</ol>
<h3 id="二统一请求方法">（二）统一请求方法</h3>
<p><code>ApiRequest</code> 类提供了一个统一的请求方法 <code>remoteApi</code>，用于处理网络请求并封装返回结果。</p>
<pre><code class="language-typescript">export interface IApiRequestHandleBusinessError {
  handleBusinessError(apiException: ApiException): boolean;
}

export class ApiRequest {
  
  public static async remoteApi&lt;T&gt;(api:()=&gt;Promise&lt;ApiResult&lt;T&gt;&gt;): Promise&lt;DataResult&lt;ApiResult&lt;T&gt;|null&gt;&gt;{
    try{
      const data = await api()
      if(data.success &amp;&amp; data.success){
        let bean = new SuccessData&lt;ApiResult&lt;T&gt;&gt;(data)
        return bean;
      } else {
        let bean = ErrorData.fromError(new ApiException(data.code,data.msg) as Error,data.code?.toString(),data.msg)
        return bean;
      }
    }catch (e) {
      if(e instanceof NetworkException){
        let bean = ErrorData.fromError(e)
        //请求被框架取消，客户端不进入异常处理，避免业务弹窗
        if(e.code !== ErrorCodes.REQUEST_CANCEL){
          LibToast.show(e.message)
        }
        return bean;
      }
      throw e as Error
    }

  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>请求执行</strong>：通过传入的 <code>api</code> 函数执行具体的网络请求。</li>
<li><strong>成功处理</strong>：如果请求成功，返回 <code>SuccessData</code> 对象。</li>
<li><strong>失败处理</strong>：如果请求失败，根据错误类型返回 <code>ErrorData</code> 对象。</li>
<li><strong>网络异常处理</strong>：捕获 <code>NetworkException</code>，并根据错误代码决定是否显示提示信息。</li>
</ol>
<h3 id="三业务逻辑处理">（三）业务逻辑处理</h3>
<p><code>ApiRequest</code> 类还提供了一个 <code>service</code> 方法，用于处理业务逻辑和错误。</p>
<pre><code class="language-typescript">export class ApiRequest {
  // ... 其他代码 ...

  public static async service&lt;T&gt;(source:()=&gt;Promise&lt;DataResult&lt;ApiResult&lt;T&gt;|null&gt;&gt;,
    request : (data:DataResult&lt;T|null&gt;)=&gt;void,
    apiError : (apiError:ErrorData)=&gt;void,
    netError? : (netError:ErrorData)=&gt;void,
  ){
    let data = await source();
    if(data instanceof SuccessData){
      request(data.data)
    }else {
      let error = data as ErrorData
      if(error.error&amp;&amp;error.error instanceof ApiException){
        //业务异常
        if(ApiRequest.instance._i_api_equest_handle_business_error){
          ApiRequest.instance._i_api_equest_handle_business_error.handleBusinessError(error.error)
        }
        apiError(error)
      }else {
        //网络异常
        if(netError){
          netError(error)
        }
      }
    }
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>请求执行</strong>：通过 <code>source</code> 函数执行网络请求。</li>
<li><strong>成功处理</strong>：如果请求成功，调用 <code>request</code> 回调函数处理数据。</li>
<li><strong>错误处理</strong>：根据错误类型调用 <code>apiError</code> 或 <code>netError</code> 回调函数。</li>
<li><strong>业务逻辑分离</strong>：通过 <code>IApiRequestHandleBusinessError</code> 接口处理业务逻辑错误。</li>
</ol>
<h2 id="三封装公共请求头">三、封装公共请求头</h2>
<p>在实际开发中，许多请求都需要携带公共请求头，例如设备信息、用户令牌等。你通过 <code>CommonHeaderInterceptor</code> 类实现了公共请求头的封装。</p>
<pre><code class="language-typescript">export async function getCommonHeaders(): Promise&lt;Record&lt;string, string&gt;&gt; {
  return {
    "device": LibDevice.getDeviceInfo(),
    "machineCode": await USystem.getUniqueKey(),
    "terminalType": "1", // 示例终端类型
    "timestamp": new Date().toISOString(),
    "versionNumber": LibDevice.getAppVersionCode().toString(),
    "osId": Platform.appPlatform, // 示例 osId
    "versionCode": LibDevice.getAppVersionName(),
    "token": AccountManager.getToken()
  };
}

export class CommonHeaderInterceptor implements rcp.Interceptor {
  async intercept(context: rcp.RequestContext, next: rcp.RequestHandler): Promise&lt;rcp.Response&gt; {
    const commonHeaders = await getCommonHeaders();
    const keys = Object.keys(commonHeaders);
    for (let i = 0; i &lt; keys.length; i++) {
      const key = keys[i];
      if (!context.request.headers) {
        context.request.headers = {};
      }
      context.request.headers[key] = commonHeaders[key];
    }
    return next.handle(context);
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>公共头信息</strong>：通过 <code>getCommonHeaders</code> 函数获取公共头信息。</li>
<li><strong>拦截器实现</strong>：在 <code>intercept</code> 方法中，将公共头信息添加到请求头中。</li>
<li><strong>动态添加</strong>：通过循环动态添加公共头信息，确保每个请求都携带必要的信息。</li>
</ol>
<h2 id="四封装响应转换器">四、封装响应转换器</h2>
<p>为了更好地处理响应数据，封装一个 <code>CommonTextResponseConverter</code> 类，用于处理响应内容。</p>
<pre><code class="language-typescript">export class CommonTextResponseConverter extends TextResponseConverter {
  convert(response: rcp.Response): string | object | null {
    if (response.toJSON()) {
      return response.toJSON();
    } else {
      return super.convert(response);
    }
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>JSON 转换</strong>：优先尝试将响应内容转换为 JSON 格式。</li>
<li><strong>回退处理</strong>：如果无法转换为 JSON，调用父类的 <code>convert</code> 方法处理响应内容。</li>
</ol>
<h2 id="五实际应用案例获取运动数据">五、实际应用案例：获取运动数据</h2>
<p>假设我们需要从服务器获取用户的运动数据，例如运动记录、运动计划等。我们将通过封装好的 RCP 网络库来实现这一功能。</p>
<h3 id="一封装请求方法">（一）封装请求方法</h3>
<pre><code class="language-typescript">export async function getAllLookSubjectList(params: Record&lt;"parentId", string&gt;, requestKeyFun?: (str: string) =&gt; void): Promise&lt;ApiResult&lt;Subject[]&gt;&gt; {
  return ApiRequest.getInstance().getService().request&lt;ApiResult&lt;Subject[]&gt;&gt;&gt;({
    act: AllLOOK_SUBJECT_LIST,
    method: RequestMethod.POST,
    contentType: RcpContentType.JSON,
    content: params
  }, requestKeyFun);
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>请求配置</strong>：通过 <code>RequestOptions</code> 配置请求的基本信息，如 API 路径、请求方法和内容类型。</li>
<li><strong>请求发送</strong>：使用 <code>ApiRequest.getInstance().getService().request</code> 方法发送请求。</li>
<li><strong>回调函数</strong>：通过 <code>requestKeyFun</code> 提供请求键值，用于取消请求等操作。</li>
</ol>
<h3 id="二调用请求方法">（二）调用请求方法</h3>
<p>在实际的页面或组件中，我们可以调用封装好的请求方法来获取运动数据。</p>
<pre><code class="language-typescript">aboutToAppear(): void {
  super.aboutToAppear();
  this.showLoading();
  ApiRequest.service&lt;Subject[]&gt;(() =&gt; {
    return LookResponsitory.getInstance().getAllLookSubjectList("1", (requestKey) =&gt; {
      if (requestKey) {
        this.addRequestId(requestKey);
      }
    });
  }, (data) =&gt; {
    this.hideLoading();
    if (data.data &amp;&amp; data.data.length &gt; 0) {
      this.tabs = data.data;
    } else {
      this.setDefalutTab();
    }
  }, (apiError) =&gt; {
    this.hideLoading();
    this.setDefalutTab();
    // 业务异常
    // LibToast.show(apiError.message ?? "获取异常");
  }, () =&gt; {
    this.hideLoading();
    this.setDefalutTab();
    // 网络等异常
    // LibToast.show("网络异常");
  });
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>请求执行</strong>：通过 <code>ApiRequest.service</code> 方法执行网络请求。</li>
<li><strong>成功处理</strong>：如果请求成功，处理返回的数据。</li>
<li><strong>错误处理</strong>：根据错误类型调用相应的回调函数处理错误。</li>
<li><strong>加载状态</strong>：在请求开始时显示加载状态，在请求结束时隐藏加载状态。</li>
</ol>
<h2 id="六总结">六、总结</h2>
<p>通过本篇的实战案例，我们展示了如何使用封装好的 RCP 网络库实现具体的网络请求功能。通过定义异常类、封装请求方法、处理公共请求头和响应转换器，以及实现具体的请求逻辑，我们能够高效地完成网络请求任务。封装好的网络库不仅提供了基本的请求和响应处理功能，还具备错误处理、日志记录、会话管理和网络状态检测等高级特性，能够满足大多数网络请求场景的需求。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-20 09:08">2025-06-20 09:08</span>&nbsp;
<a href="https://www.cnblogs.com/wangerdan115">王二蛋和他的狗</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18937605);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18937605', targetLink: 'https://www.cnblogs.com/wangerdan115/p/18937605', title: '鸿蒙运动项目开发：封装超级好用的 RCP 网络库（下）—— 实战应用' })">举报</a>
</div>
        