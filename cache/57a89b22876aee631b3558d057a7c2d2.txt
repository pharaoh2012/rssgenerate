
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18964535" title="发布于 2025-07-05 12:28">
    <span role="heading" aria-level="2">MySQL 03 事务隔离：为什么你改了我还看不见？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在<strong>引擎层</strong>实现的，这也是InnoDB取代MyISAM的重要原因之一。</p>
<h3 id="隔离性与隔离级别">隔离性与隔离级别</h3>
<p>事务的四大特性：原子性、一致性、隔离性、持久性。本文主要讨论隔离性。</p>
<p>当数据库上有多个事务同时执行的时候，可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了<strong>隔离级别</strong>的概念。</p>
<p>SQL标准的事务隔离级别包括以下四种：</p>
<ul>
<li>
<p>读未提交：一个事务没提交时，它做的变更就能被别的事务看到。</p>
</li>
<li>
<p>读已提交：一个事务提交之后，它做的变更才会被其他事务看到。</p>
</li>
<li>
<p>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</p>
</li>
<li>
<p>串行化：对于同一行记录。写会加写锁，读会加读锁，当出现锁冲突，后访问的事务必须等待前一个事务执行完成，才能继续执行。</p>
</li>
</ul>
<p>下面举例说明隔离级别。假设有两个事务，其行为的时间顺序如下：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250703214023912-520697621.png" width="30%"></div>
<p>那么在不同的隔离级别下，事务A的查询结果为：</p>
<ul>
<li>
<p>读未提交：事务B的修改能被A看到，因此V1=V2=V3=2。</p>
</li>
<li>
<p>读已提交：事务B的修改在提交后才能被A看到，因此V1=1，V2=V3=2。</p>
</li>
<li>
<p>可重复读：事务A在执行过程中看到的数据，和事务A启动时看到的是一样的，因此V1=V2=1。由于之后事务A提交，因此V3=2。</p>
</li>
<li>
<p>串行化：事务B想要修改时会被锁住，直到事务A提交。因此V1=V2=1，V3=2。</p>
</li>
</ul>
<p>在实现上，数据库里会创建一个视图，访问时以视图的逻辑结果为准。在<strong>可重复读</strong>隔离级别下，视图是在事务启动时创建的，整个事务存在期间都用同一个视图。在<strong>读已提交</strong>隔离级别下，每个SQL语句开始执行时都会创建一个视图。</p>
<h3 id="事务隔离的实现">事务隔离的实现</h3>
<p>接下来，展开说明可重复读的实现。</p>
<p>在MySQL中，实际上每条记录在更新时都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到提前一个状态的值。假设一个值从1依次改成了2,3,4，那么回滚日志是下面这样的：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250703214109760-113751032.png" width="30%"></div>
<p>当前值是4，但是在查询时，不同时刻启动的事务有不同的read view，因此看到的值是不同的，并不一定是当前值。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。</p>
<p>MVCC可以实现隔离性，从上面也能看出，即使现在有另外的事务正在将4改成5，这个事务也不会影响read view A、B、C对应的事务。</p>
<p>回滚日志不是一直保留的，当系统判断没有事务再需要用到这些回滚日志时，回滚日志就会被删除。具体来说，当系统里没有比这个回滚日志更早的read view时，就会删除，如果详细了解过MVCC机制，这句话等同于：系统中不存在任何read view的<code>min_trx_id</code>比回滚日志所属事务的<code>trx_id</code>小。</p>
<p>基于以上实现，我们建议<strong>尽量不要使用长事务</strong>，因为长事务会意味着系统里存在很老的事务视图，那么在该事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会占用大量存储空间。除此之外，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>可以在infomation_schema库的innodb_trx表查询长事务，比如下面的语句，用于查找持续时间超过60秒的事务：</p>
<pre><code class="language-sql">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60
</code></pre>
<h3 id="事务的启动方式">事务的启动方式</h3>
<p>最后再讲讲事务的启动方式。MySQL事务启动方式有以下几种：</p>
<ul>
<li>
<p>显式启动。语句是begin或start transaction，配套的提交语句是commit，回滚语句是rollback。</p>
</li>
<li>
<p><code>set autocommit=0</code>，该命令会将线程的自动提交关闭。意味着如果只执行一个select语句，这个事务就会启动，但不会主动提交。事务持续存在直到主动提交或回滚，或者连接断开。</p>
</li>
</ul>
<p>有些客户端连接框架默认连接成功后就先执行<code>set autocommit=0</code>，这就导致接下来的查询都在事务中，可能会导致无意的长事务。因此，<strong>建议显式启动</strong>。</p>
<br>
<br>
<p>参考资料：极客时间专栏《MySQL实战45讲》<a href="https://time.geekbang.org/column/intro/100020801?tab=catalog" target="_blank" rel="noopener nofollow">https://time.geekbang.org/column/intro/100020801?tab=catalog</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-05 12:29">2025-07-05 12:28</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">64</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18964535);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18964535', targetLink: 'https://www.cnblogs.com/san-mu/p/18964535', title: 'MySQL 03 事务隔离：为什么你改了我还看不见？' })">举报</a>
</div>
        