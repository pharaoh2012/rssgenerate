
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yuzhihui/p/18657004" title="发布于 2025-01-07 10:37">
    <span role="heading" aria-level="2">JavaScript 实现支持过期时间的数据缓存功能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2023.cnblogs.com/blog/642487/202501/642487-20250107103524850-995108640.jpg" alt="JavaScript 实现支持过期时间的数据缓存功能" class="desc_img">
        JavaScript 实现支持过期时间的数据缓存功能
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="javascript-实现支持过期时间的数据缓存功能">JavaScript 实现支持过期时间的数据缓存功能</h1>
<p>要在 JavaScript 中实现数据缓存功能并支持设置过期时间，可以使用 <code>localStorage</code>、<code>sessionStorage</code> 或内存对象（如 <code>Map</code> 或普通对象）来存储数据，并为每个缓存项设置一个过期时间。以下是一个简单的实现示例：</p>
<hr>
<h2 id="javascript-实现支持过期时间的数据缓存功能-1"><strong>JavaScript 实现支持过期时间的数据缓存功能</strong></h2>
<h3 id="1-使用-localstorage-实现持久缓存"><strong>1. 使用 <code>localStorage</code> 实现持久缓存</strong></h3>
<pre><code class="language-javascript">const Cache = {
  /**
   * 设置缓存
   * @param {string} key - 缓存键
   * @param {*} value - 缓存值
   * @param {number} ttl - 缓存时间（毫秒）
   */
  set(key, value, ttl) {
    const data = {
      value,
      expiry: ttl ? Date.now() + ttl : null, // 计算过期时间
    };
    localStorage.setItem(key, JSON.stringify(data));
  },

  /**
   * 获取缓存
   * @param {string} key - 缓存键
   * @returns {*} 缓存值或 null（如果过期或不存在）
   */
  get(key) {
    const data = localStorage.getItem(key);
    if (!data) return null;

    try {
      const { value, expiry } = JSON.parse(data);
      if (expiry &amp;&amp; Date.now() &gt; expiry) {
        localStorage.removeItem(key); // 过期删除缓存
        return null;
      }
      return value;
    } catch (e) {
      console.warn("缓存数据解析失败", e);
      return null;
    }
  },

  /**
   * 删除缓存
   * @param {string} key - 缓存键
   */
  remove(key) {
    localStorage.removeItem(key);
  },

  /**
   * 清空所有缓存
   */
  clear() {
    localStorage.clear();
  },
};

// 使用示例
Cache.set("username", "Alice", 5000); // 设置缓存5秒后过期
console.log(Cache.get("username")); // 5秒内返回 'Alice'
setTimeout(() =&gt; console.log(Cache.get("username")), 6000); // 6秒后返回 null
</code></pre>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li><code>localStorage</code> 只能存储字符串，因此要使用 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 进行序列化和反序列化。</li>
<li><code>localStorage</code> 的存储空间一般有限（大约 5MB）。</li>
<li>如果是跨页面使用，请确保在相同的域名下。</li>
</ul>
<hr>
<h3 id="2-使用-sessionstorage-实现数据缓存适合页面级临时存储"><strong>2. 使用 <code>sessionStorage</code> 实现数据缓存（适合页面级临时存储）</strong></h3>
<p><code>sessionStorage</code> 是一种浏览器存储机制，它的特点是数据仅在<strong>页面会话（session）</strong> 期间有效，页面关闭后数据会被清除。</p>
<pre><code class="language-javascript">const SessionCache = {
  /**
   * 设置缓存
   * @param {string} key - 缓存键
   * @param {*} value - 缓存值
   * @param {number} ttl - 缓存时间（毫秒）
   */
  set(key, value, ttl) {
    const data = {
      value,
      expiry: ttl ? Date.now() + ttl : null, // 计算过期时间
    };
    sessionStorage.setItem(key, JSON.stringify(data));
  },

  /**
   * 获取缓存
   * @param {string} key - 缓存键
   * @returns {*} 缓存值或 null（如果过期或不存在）
   */
  get(key) {
    const data = sessionStorage.getItem(key);
    if (!data) return null;

    try {
      const { value, expiry } = JSON.parse(data);
      if (expiry &amp;&amp; Date.now() &gt; expiry) {
        sessionStorage.removeItem(key); // 缓存已过期，删除
        return null;
      }
      return value;
    } catch (e) {
      console.warn("缓存数据解析失败:", e);
      return null;
    }
  },

  /**
   * 删除缓存
   * @param {string} key - 缓存键
   */
  remove(key) {
    sessionStorage.removeItem(key);
  },

  /**
   * 清空所有缓存
   */
  clear() {
    sessionStorage.clear();
  },
};

// **使用示例**
// 设置缓存，5秒后过期
SessionCache.set("userToken", "abc123", 5000);

// 获取缓存
console.log(SessionCache.get("userToken")); // 5秒内返回 'abc123'

// 5秒后尝试获取缓存
setTimeout(() =&gt; {
  console.log(SessionCache.get("userToken")); // 返回 null
}, 6000);
</code></pre>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li><code>sessionStorage</code> 数据在<strong>页面关闭或会话结束</strong>时自动清除。</li>
<li>在不同的标签页中，<code>sessionStorage</code> 是<strong>独立的</strong>（不会共享）。</li>
<li><code>sessionStorage</code> 的存储空间一般为<strong>5MB</strong>左右。</li>
<li>数据存储在 <code>sessionStorage</code> 时必须经过 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 处理。</li>
</ul>
<hr>
<h3 id="3-使用内存对象实现轻量缓存适合短期缓存"><strong>3. 使用内存对象实现轻量缓存（适合短期缓存）</strong></h3>
<pre><code class="language-javascript">class MemoryCache {
  constructor() {
    this.cache = new Map();
  }

  /**
   * 设置缓存
   * @param {string} key - 缓存键
   * @param {*} value - 缓存值
   * @param {number} ttl - 缓存时间（毫秒）
   */
  set(key, value, ttl) {
    const expiry = ttl ? Date.now() + ttl : null;
    this.cache.set(key, { value, expiry });
  }

  /**
   * 获取缓存
   * @param {string} key - 缓存键
   * @returns {*} 缓存值或 null（如果过期或不存在）
   */
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (item.expiry &amp;&amp; Date.now() &gt; item.expiry) {
      this.cache.delete(key); // 缓存过期，删除
      return null;
    }
    return item.value;
  }

  /**
   * 删除缓存
   * @param {string} key - 缓存键
   */
  remove(key) {
    this.cache.delete(key);
  }

  /**
   * 清空所有缓存
   */
  clear() {
    this.cache.clear();
  }
}

// 使用示例
const memCache = new MemoryCache();
memCache.set("token", "abc123", 3000); // 设置缓存3秒后过期
console.log(memCache.get("token")); // 3秒内返回 'abc123'
setTimeout(() =&gt; console.log(memCache.get("token")), 4000); // 4秒后返回 null
</code></pre>
<h3 id="4-使用-indexeddb-实现持久缓存"><strong>4. 使用 IndexedDB 实现持久缓存</strong></h3>
<pre><code class="language-javascript">// 初始化 IndexedDB 数据库
class IndexedDBCache {
  constructor(dbName = "CacheDB", storeName = "CacheStore") {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
  }

  /**
   * 初始化数据库
   */
  async init() {
    return new Promise((resolve, reject) =&gt; {
      const request = indexedDB.open(this.dbName, 1);

      request.onupgradeneeded = (event) =&gt; {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: "key" });
        }
      };

      request.onsuccess = (event) =&gt; {
        this.db = event.target.result;
        resolve(this);
      };

      request.onerror = (event) =&gt; {
        console.error("IndexedDB 初始化失败:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * 获取对象存储
   */
  getObjectStore(mode = "readonly") {
    const transaction = this.db.transaction(this.storeName, mode);
    return transaction.objectStore(this.storeName);
  }

  /**
   * 添加或更新缓存
   * @param {string} key - 缓存键
   * @param {*} value - 缓存值
   * @param {number} ttl - 过期时间（毫秒）
   */
  async set(key, value, ttl) {
    const expiry = ttl ? Date.now() + ttl : null;
    const record = { key, value, expiry };

    return new Promise((resolve, reject) =&gt; {
      const store = this.getObjectStore("readwrite");
      const request = store.put(record);

      request.onsuccess = () =&gt; resolve(true);
      request.onerror = (event) =&gt; {
        console.error("数据写入失败:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * 获取缓存
   * @param {string} key - 缓存键
   * @returns {*} 缓存值或 null
   */
  async get(key) {
    return new Promise((resolve, reject) =&gt; {
      const store = this.getObjectStore("readonly");
      const request = store.get(key);

      request.onsuccess = (event) =&gt; {
        const record = event.target.result;
        if (!record) {
          resolve(null); // 数据不存在
          return;
        }

        if (record.expiry &amp;&amp; Date.now() &gt; record.expiry) {
          // 数据过期
          this.delete(key).then(() =&gt; resolve(null));
        } else {
          resolve(record.value); // 返回未过期数据
        }
      };

      request.onerror = (event) =&gt; {
        console.error("数据读取失败:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * 删除缓存
   * @param {string} key - 缓存键
   */
  async delete(key) {
    return new Promise((resolve, reject) =&gt; {
      const store = this.getObjectStore("readwrite");
      const request = store.delete(key);

      request.onsuccess = () =&gt; resolve(true);
      request.onerror = (event) =&gt; {
        console.error("数据删除失败:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * 清空缓存
   */
  async clear() {
    return new Promise((resolve, reject) =&gt; {
      const store = this.getObjectStore("readwrite");
      const request = store.clear();

      request.onsuccess = () =&gt; resolve(true);
      request.onerror = (event) =&gt; {
        console.error("缓存清空失败:", event.target.error);
        reject(event.target.error);
      };
    });
  }
}

// 使用示例
(async () =&gt; {
  // 创建缓存实例并初始化数据库
  const cache = new IndexedDBCache();
  await cache.init();

  // 设置缓存，数据 5 秒后过期
  await cache.set("userToken", "abc123", 5000);
  console.log("缓存设置完成");

  // 获取缓存
  console.log("立即获取:", await cache.get("userToken")); // 输出: abc123

  // 等待 6 秒后尝试获取缓存
  setTimeout(async () =&gt; {
    console.log("6 秒后获取:", await cache.get("userToken")); // 输出: null
  }, 6000);
})();
</code></pre>
<p>🔑 <strong>功能说明</strong></p>
<ol>
<li>
<p><strong><code>set(key, value, ttl)</code></strong></p>
<ul>
<li>添加或更新缓存。</li>
<li><code>ttl</code>（毫秒）：设置缓存的过期时间，<code>null</code> 表示永久有效。</li>
</ul>
</li>
<li>
<p><strong><code>get(key)</code></strong></p>
<ul>
<li>读取缓存时会检查过期时间。</li>
<li>如果数据已过期，会自动删除并返回 <code>null</code>。</li>
</ul>
</li>
<li>
<p><strong><code>delete(key)</code></strong></p>
<ul>
<li>删除指定的缓存。</li>
</ul>
</li>
<li>
<p><strong><code>clear()</code></strong></p>
<ul>
<li>清空所有缓存。</li>
</ul>
</li>
<li>
<p><strong>异步操作</strong></p>
<ul>
<li>所有方法基于 <code>Promise</code>，方便与现代异步代码（<code>async/await</code>）结合使用。</li>
</ul>
</li>
</ol>
<p>🌟 <strong>优点</strong></p>
<ol>
<li><strong>支持过期时间</strong>：在获取数据时会自动检查并清除过期数据。</li>
<li><strong>高效查询</strong>：利用 <code>IndexedDB</code> 的键值对存储，快速读写数据。</li>
<li><strong>持久化存储</strong>：数据保存在用户设备上，关闭浏览器后依然存在。</li>
</ol>
<p>⚠️ <strong>注意事项</strong></p>
<ol>
<li><strong>浏览器兼容性</strong>：确保目标用户的浏览器支持 <code>IndexedDB</code>（现代浏览器普遍支持）。</li>
<li><strong>性能优化</strong>：如果有大量过期数据，可以定期批量清理（如通过后台任务）。</li>
<li><strong>容量限制</strong>：大多数浏览器允许 <code>IndexedDB</code> 使用数百 MB 的存储空间，但仍需谨慎使用以避免存储满溢。</li>
</ol>
<h2 id="四种方式的对比"><strong>四种方式的对比</strong></h2>

<table>
<thead>
<tr>
<th>特性/方式</th>
<th><strong>localStorage</strong></th>
<th><strong>sessionStorage</strong></th>
<th><strong>IndexedDB</strong></th>
<th><strong>内存缓存 (Map)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>持久化能力</strong></td>
<td>长期持久化，直到手动清除</td>
<td>会话级存储，页面关闭即清除</td>
<td>长期持久化，直到手动清除或删除</td>
<td>无持久化能力，页面刷新即丢失</td>
</tr>
<tr>
<td><strong>存储容量</strong></td>
<td>约 5MB</td>
<td>约 5MB</td>
<td>通常 &gt;50MB，具体视浏览器实现而定</td>
<td>受内存限制，大小不固定</td>
</tr>
<tr>
<td><strong>过期时间实现</strong></td>
<td>需手动编码支持</td>
<td>需手动编码支持</td>
<td>原生支持复杂数据操作，需手动编码</td>
<td>直接使用定时器或清理机制实现</td>
</tr>
<tr>
<td><strong>数据存取性能</strong></td>
<td>高效，键值直接存取</td>
<td>高效，键值直接存取</td>
<td>高效，但比 <code>localStorage</code> 略慢</td>
<td>极高，内存操作无需异步</td>
</tr>
<tr>
<td><strong>异步操作支持</strong></td>
<td>不支持，操作是同步的</td>
<td>不支持，操作是同步的</td>
<td>原生异步，基于事件或 Promise</td>
<td>不需要，直接操作内存</td>
</tr>
<tr>
<td><strong>复杂数据支持</strong></td>
<td>必须使用 <code>JSON.stringify</code>/<code>parse</code></td>
<td>必须使用 <code>JSON.stringify</code>/<code>parse</code></td>
<td>支持复杂对象、Blob、ArrayBuffer</td>
<td>支持复杂对象，但无法序列化存储</td>
</tr>
<tr>
<td><strong>跨页面共享</strong></td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>跨页面长期数据存储（如用户设置）</td>
<td>单页面会话数据存储（如表单数据）</td>
<td>离线存储、大量复杂数据、文件缓存</td>
<td>短期临时数据、高性能场景</td>
</tr>
<tr>
<td><strong>过期机制复杂度</strong></td>
<td>中等（需要检查时间并清除过期数据）</td>
<td>中等（需要检查时间并清除过期数据）</td>
<td>较高（通过索引或批量检查清理）</td>
<td>简单（可用定时器直接清除）</td>
</tr>
</tbody>
</table>
<h2 id="-选择建议">💡 <strong>选择建议</strong></h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>建议选择</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>短期缓存，高性能需求</strong></td>
<td>内存缓存（Map）</td>
<td>速度最快，适合临时存储。</td>
</tr>
<tr>
<td><strong>会话级缓存，简单键值对</strong></td>
<td>sessionStorage</td>
<td>页面关闭后自动清除，无需手动管理。</td>
</tr>
<tr>
<td><strong>长期缓存，简单数据</strong></td>
<td>localStorage</td>
<td>数据持久化存储，适合小型缓存。</td>
</tr>
<tr>
<td><strong>长期缓存，复杂或大量数据</strong></td>
<td>IndexedDB</td>
<td>可管理大数据量，支持复杂数据结构与索引。</td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="17.195789570850696" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-11 09:38">2025-01-07 10:37</span>&nbsp;
<a href="https://www.cnblogs.com/yuzhihui">飞仔FeiZai</a>&nbsp;
阅读(<span id="post_view_count">66</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18657004" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18657004);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18657004', targetLink: 'https://www.cnblogs.com/yuzhihui/p/18657004', title: 'JavaScript 实现支持过期时间的数据缓存功能' })">举报</a>
</div>
        