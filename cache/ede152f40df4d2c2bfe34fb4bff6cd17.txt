
        <div class="postTitle">
            <h1><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenyishi/p/18664065" title="发布于 2025-01-10 15:24">
    <span role="heading" aria-level="2">AsyncLocal的妙用</span>
    

</a>
</h1>
        </div>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><code>AsyncLocal&lt;T&gt;</code>是一个在.NET中用来在同步任务和异步任务中保持全局变量的工具类。</p>
<p>它允许你在不同线程的同一个对象中保留一个特定值，这样你可以在不同的函数和任务中访问这个值。</p>
<p>这是在实现异步任务中维持一致性和优雅性的一种重要手段。</p>
<h4>用法</h4>
<p><strong>创建一个AsyncLocal实例：</strong></p>
<p>你可以使用<code>AsyncLocal&lt;T&gt;</code>来创建一个特定类型的实例，比如：</p>
<pre><code class="language-csharp">AsyncLocal&lt;string&gt; asyncLocalString = new AsyncLocal&lt;string&gt;();
</code></pre>
<p><strong>设置值：</strong></p>
<p>你可以通过<code>Value</code>属性设置或者读取值：</p>
<pre><code class="language-csharp">asyncLocalString.Value = "Hello, AsyncLocal!";
</code></pre>
<p><strong>读取值：</strong></p>
<p>在任务中的任意位置，你都可以读取这个值：</p>
<pre><code class="language-csharp">Console.WriteLine(asyncLocalString.Value);
</code></pre>
<p><strong>实例分享与给值变更：</strong></p>
<p>在不同任务和串行任务中，<code>AsyncLocal</code> 实例的值是不一样的：</p>
<pre><code class="language-csharp">asyncLocalString.Value = "Main Task";
Task.Run(() =&gt;
{
    asyncLocalString.Value = "Child Task";
    Console.WriteLine(asyncLocalString.Value); // 输出 "Child Task"
});
Console.WriteLine(asyncLocalString.Value); // 输出 "Main Task"</code></pre>
<h4>场景</h4>
<p><strong>数据传递：</strong></p>
<p>异步任务中，通过<code>AsyncLocal</code>进行全局数据传递而无需通过参数传递。这对于学习和复用代码很有帮助。</p>
<p><strong>上下文管理：</strong></p>
<p>在ASP.NET Core中，<code>AsyncLocal</code> 可用于管理用户请求上下文，实现不同请求之间的传递。当你需要保存一些请求相关的信息时，这是一种很有效的方法。</p>
<p><strong>百分比信息保存：</strong></p>
<p>记录不同任务和串行任务中的特定信息，说明这些任务是如何分布的。这在分析和跟踪异步操作时应对特别有用。</p>
<p><strong>系统日志和跟踪：</strong></p>
<p><code>AsyncLocal</code> 可用于在异步任务中保存和分享日志和跟踪信息，以便在运行时采集最有益的信息，有助于问题跟踪和分析。</p>
<h4>示例：保存日志和租户信息</h4>
<p>以下是一个使用<code>AsyncLocal</code>保存日志和租户信息的示例：</p>
<pre><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;

public class LogContext
{
    public string StackTrace { get; set; }
    public string UserInfo { get; set; }
}

public class TenantContext
{
    public string Name { get; set; }
}

public class Program
{
    private static AsyncLocal&lt;LogContext&gt; _logContext = new AsyncLocal&lt;LogContext&gt;();
    private static AsyncLocal&lt;TenantContext&gt; _tenantContext = new AsyncLocal&lt;TenantContext&gt;();

    public static async Task Main(string[] args)
    {
        _logContext.Value = new LogContext { StackTrace = "Main Stack Trace", UserInfo = "User1" };
        _tenantContext.Value = new TenantContext { Name = "Tenant A" };

        Console.WriteLine($"Initial Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");

        await Task.Run(() =&gt; LogAndProcess(new LogContext { StackTrace = "Child Stack Trace", UserInfo = "User2" }, new TenantContext { Name = "Tenant B" }));

        Console.WriteLine($"After Task Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
    }

    private static void LogAndProcess(LogContext logContext, TenantContext tenant)
    {
        _logContext.Value = logContext;
        _tenantContext.Value = tenant;

        Console.WriteLine($"In Task Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");

        // Simulate some processing
        Task.Delay(1000).Wait();

        Console.WriteLine($"After Processing Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
    }
}
</code></pre>
<p>在这个示例中，<code>AsyncLocal</code> 用于保存日志和租户信息，确保在不同的任务上下文中正确传递和使用这些信息。</p>
</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.112316492125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 15:35">2025-01-10 15:24</span>&nbsp;
<a href="https://www.cnblogs.com/chenyishi">chester·chen</a>&nbsp;
阅读(<span id="post_view_count">135</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664065" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664065);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664065', targetLink: 'https://www.cnblogs.com/chenyishi/p/18664065', title: 'AsyncLocal的妙用' })">举报</a>
</div>
    