
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18640391" title="发布于 2024-12-30 10:50">
    <span role="heading" aria-level="2">创建线程的8种方法，90%的人不知道</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>在Java开发中，<code>线程</code>是并发编程中的核心工具。</p>
<p>无论是为了提高程序运行效率，还是为了处理复杂的并发任务，我们都需要在代码中使用线程。</p>
<p>但如果你只知道 <code>Thread</code> 和 <code>Runnable</code> 两种方式，那可就有点落后了。</p>
<p>其实，Java 提供了多种方式来创建线程，每一种都有其独特的优势和适用场景。</p>
<p>这篇文章将从浅入深，详细剖析 <strong>Java 创建线程的8种方法</strong>，每种方法都会附带示例代码和场景解析，帮你彻底掌握线程的创建与管理，希望对你会有所帮助。</p>
<blockquote>
<p>(我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，欢迎访问和star。)[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
</blockquote>
<h2 id="1-继承-thread-类">1. 继承 Thread 类</h2>
<p>直接继承 <code>Thread</code> 类，重写 <code>run()</code> 方法，将任务逻辑写在 <code>run()</code> 中。</p>
<p>通过调用 <code>start()</code> 方法启动线程。</p>
<h3 id="示例代码">示例代码</h3>
<pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("线程名称：" + Thread.currentThread().getName() + " 正在执行任务");
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.start(); // 启动线程
        thread2.start();
    }
}
</code></pre>
<h3 id="场景解析">场景解析</h3>
<p>继承 <code>Thread</code> 是最简单的方式，非常适合初学者学习线程的基本原理。但这种方式扩展性差，因为 Java 是单继承语言，继承了 <code>Thread</code> 后就不能再继承其他类。</p>
<h3 id="优缺点">优缺点</h3>
<ul>
<li><strong>优点：</strong> 简单直观，适合小型任务。</li>
<li><strong>缺点：</strong> 限制了类的继承，无法复用已有的逻辑。</li>
</ul>
<h2 id="2-实现-runnable-接口">2. 实现 Runnable 接口</h2>
<p>实现 <code>Runnable</code> 接口，将任务逻辑写在 <code>run()</code> 方法中。</p>
<p>通过 <code>Thread</code> 构造方法将 <code>Runnable</code> 对象传入，启动线程。</p>
<h3 id="示例代码-1">示例代码</h3>
<pre><code class="language-java">class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程名称：" + Thread.currentThread().getName() + " 正在执行任务");
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable());
        Thread thread2 = new Thread(new MyRunnable());
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<h3 id="场景解析-1">场景解析</h3>
<p>相比继承 <code>Thread</code>，实现 <code>Runnable</code> 接口更灵活，避免了单继承的限制。大多数开发场景中，更推荐使用这种方式。</p>
<h3 id="优缺点-1">优缺点</h3>
<ul>
<li><strong>优点：</strong> 解耦任务逻辑和线程对象，灵活性更高。</li>
<li><strong>缺点：</strong> 需要额外创建 <code>Thread</code> 对象。</li>
</ul>
<h2 id="3-实现-callable-接口">3. 实现 Callable 接口</h2>
<p><code>Callable</code> 接口是 Java 5 引入的，类似于 <code>Runnable</code>，但它支持返回值，并可以抛出异常。</p>
<h3 id="示例代码-2">示例代码</h3>
<pre><code class="language-java">import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception {
        return "线程名称：" + Thread.currentThread().getName() + "，任务执行完成";
    }
}

public class CallableExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new MyCallable());
        Thread thread = new Thread(futureTask);
        thread.start();

        // 获取线程返回结果
        System.out.println("线程返回结果：" + futureTask.get());
    }
}
</code></pre>
<h3 id="场景解析-2">场景解析</h3>
<p>如果你的线程需要返回结果，<code>Callable</code> 是更好的选择，比如数据查询、复杂计算等场景。</p>
<h3 id="优缺点-2">优缺点</h3>
<ul>
<li><strong>优点：</strong> 支持返回值和异常处理，功能更强大。</li>
<li><strong>缺点：</strong> 代码复杂度比 <code>Runnable</code> 略高。</li>
</ul>
<h2 id="4-使用线程池">4. 使用线程池</h2>
<p>线程池是一种高效的线程管理机制，可以复用线程，减少创建和销毁线程的开销。</p>
<h3 id="示例代码-3">示例代码</h3>
<pre><code class="language-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        Runnable task = () -&gt; System.out.println("线程名称：" + Thread.currentThread().getName() + " 正在执行任务");

        for (int i = 0; i &lt; 5; i++) {
            executorService.execute(task);
        }

        executorService.shutdown();
    }
}
</code></pre>
<h3 id="场景解析-3">场景解析</h3>
<p>适用于需要高并发处理任务的场景，比如 Web 服务的请求处理。</p>
<h3 id="优缺点-3">优缺点</h3>
<ul>
<li><strong>优点：</strong> 高效管理线程生命周期，避免频繁创建和销毁线程。</li>
<li><strong>缺点：</strong> 需要合理配置线程池参数，否则可能导致资源浪费。</li>
</ul>
<h2 id="5-使用-scheduledexecutorservice">5. 使用 ScheduledExecutorService</h2>
<p><code>ScheduledExecutorService</code> 是 Java 提供的一种定时任务调度机制，可以在指定时间点或周期性地执行任务。</p>
<h3 id="示例代码-4">示例代码</h3>
<pre><code class="language-java">import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExample {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

        Runnable task = () -&gt; System.out.println("当前时间：" + System.currentTimeMillis());

        // 延迟1秒后，每2秒执行一次
        scheduler.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);

        // 程序运行一段时间后需要手动关闭线程池
        // scheduler.shutdown();
    }
}
</code></pre>
<h3 id="场景解析-4">场景解析</h3>
<p>适用于周期性任务，比如定时备份、定时清理缓存等。</p>
<h3 id="优缺点-4">优缺点</h3>
<ul>
<li><strong>优点：</strong> 易于实现定时和周期性任务。</li>
<li><strong>缺点：</strong> 不适合复杂调度场景。</li>
</ul>
<h2 id="6-使用-forkjoin-框架">6. 使用 Fork/Join 框架</h2>
<p><code>Fork/Join</code> 是 Java 7 引入的一种并行计算框架，适合将大任务分解成多个子任务并行处理。</p>
<h3 id="示例代码-5">示例代码</h3>
<pre><code class="language-java">import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class SumTask extends RecursiveTask&lt;Integer&gt; {
    private final int start, end;

    public SumTask(int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (end - start &lt;= 10) {
            int sum = 0;
            for (int i = start; i &lt;= end; i++) {
                sum += i;
            }
            return sum;
        } else {
            int mid = (start + end) / 2;
            SumTask leftTask = new SumTask(start, mid);
            SumTask rightTask = new SumTask(mid + 1, end);
            invokeAll(leftTask, rightTask);
            return leftTask.join() + rightTask.join();
        }
    }
}

public class ForkJoinExample {
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        SumTask task = new SumTask(1, 100);
        System.out.println("总和：" + pool.invoke(task));
    }
}
</code></pre>
<h3 id="场景解析-5">场景解析</h3>
<p>适合大量数据的并行处理，比如递归计算。</p>
<h3 id="优缺点-5">优缺点</h3>
<ul>
<li><strong>优点：</strong> 提高多核 CPU 的利用率。</li>
<li><strong>缺点：</strong> 不适合 I/O 密集型任务。</li>
</ul>
<h2 id="7-使用-completablefuture">7. 使用 CompletableFuture</h2>
<p><code>CompletableFuture</code> 是 Java 8 提供的一种异步编程工具，支持链式调用，非常适合复杂任务的分解与组合。</p>
<h3 id="示例代码-6">示例代码</h3>
<pre><code class="language-java">import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("任务执行：" + Thread.currentThread().getName());
            return "任务结果";
        }).thenApply(result -&gt; {
            System.out.println("处理结果：" + result);
            return "最终结果";
        }).thenAccept(System.out::println);
    }
}
</code></pre>
<h3 id="场景解析-6">场景解析</h3>
<p>适用于异步任务链式调用，比如远程服务调用。</p>
<h3 id="优缺点-6">优缺点</h3>
<ul>
<li><strong>优点：</strong> 功能强大，代码简洁。</li>
<li><strong>缺点：</strong> 学习成本较高。</li>
</ul>
<h2 id="8-使用-guava-的-listenablefuture">8. 使用 Guava 的 ListenableFuture</h2>
<p>Guava 提供了 <code>ListenableFuture</code>，对 <code>Future</code> 进行了增强，支持任务完成后的回调处理。</p>
<pre><code class="language-java">import com.google.common.util.concurrent.*;

import java.util.concurrent.Executors;

public class ListenableFutureExample {
    public static void main(String[] args) {
        ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(2));

        ListenableFuture&lt;String&gt; future = service.submit(() -&gt; {
            Thread.sleep(1000);
            return "任务完成";
        });

        Futures.addCallback(future, new FutureCallback&lt;String&gt;() {
            @Override
            public void onSuccess(String result) {
                System.out.println("任务成功，结果：" + result);
            }

            @Override
            public void onFailure(Throwable t) {
                System.out.println("任务失败：" + t.getMessage());
            }
        }, service);

        service.shutdown();
    }
}

</code></pre>
<h2 id="总结">总结</h2>
<p>以上就是 Java 中创建线程的 8 种方法，每一种方法都有其适用场景和优缺点。</p>
<p>下面给大家总结一下各自的优缺点：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>继承Thread类</td>
<td>简单任务</td>
<td>直观易懂</td>
<td>限制了类的继承</td>
</tr>
<tr>
<td>实现Runnable接口</td>
<td>大多数场景</td>
<td>灵活，不影响继承关系</td>
<td>无返回值</td>
</tr>
<tr>
<td>实现Callable接口</td>
<td>返回结果或抛异常的任务</td>
<td>支持返回值</td>
<td>需要配合 <code>FutureTask</code> 使用</td>
</tr>
<tr>
<td>线程池（ExecutorService）</td>
<td>高并发任务</td>
<td>高效管理线程</td>
<td>配置复杂</td>
</tr>
<tr>
<td>ScheduledExecutorService</td>
<td>周期性任务</td>
<td>易于实现定时调度</td>
<td>不适合复杂调度</td>
</tr>
<tr>
<td>Fork/Join框架</td>
<td>数据并行计算</td>
<td>提高多核利用率</td>
<td>不适合 I/O 密集型任务</td>
</tr>
<tr>
<td>CompletableFuture</td>
<td>异步任务链式调用</td>
<td>功能强大</td>
<td>学习曲线高</td>
</tr>
<tr>
<td>Guava的ListenableFuture</td>
<td>异步任务并带回调</td>
<td>回调机制强大，扩展性好</td>
<td>引入了第三方依赖</td>
</tr>
</tbody>
</table>
<p>希望大家在实际开发中，能根据场景选择合适的方式。</p>
<p>比如：小任务用 Runnable，复杂计算用 Callable，高并发场景用线程池，而异步任务可以用 CompletableFuture 或 ListenableFuture等等。</p>
<p>通过这些方法的组合，可以让你的代码更加高效、优雅！</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.061874044094907404" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 10:50">2024-12-30 10:50</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">42</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18640391" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18640391);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18640391', targetLink: 'https://www.cnblogs.com/12lisu/p/18640391', title: '创建线程的8种方法，90%的人不知道' })">举报</a>
</div>
        