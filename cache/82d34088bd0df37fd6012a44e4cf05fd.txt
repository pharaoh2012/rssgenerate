
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18921308" title="发布于 2025-06-10 17:30">
    <span role="heading" aria-level="2">[数据传输/网络传输/序列化/计算机组成原理] 字节序/大小端</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="缘起">缘起</h1>
<h2 id="can--dbc-字节序与大端">CAN / DBC 字节序与大端</h2>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250610141351282-1019923717.png" alt="" loading="lazy"></p>
<h1 id="概述-字节序byte-order--大小端endian---little-endian小端字节序--big-endian大端字节序网络序-">概述： 字节序(Byte Order) := 大小端(Endian) ：= <code>{ Little-Endian(小端字节序) , Big-Endian(大端字节序/网络序) }</code></h1>
<h2 id="大小端的由来">大小端的由来</h2>
<ul>
<li>关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：</li>
</ul>
<blockquote>
<p>Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。<br>
战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。<br>
然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。<br>
据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。<br>
这个故事其实在讽刺当时英国和法国之间持续的冲突。</p>
</blockquote>
<ul>
<li><code>Danny Cohen</code>，一位<strong>网络协议</strong>的开创者，第1次使用这两个术语指代<strong>字节顺序</strong>，后来就被大家广泛接受。</li>
</ul>
<h2 id="字节序的定义">字节序的定义</h2>
<ul>
<li><code>Little-Endian</code>(小端字节序) / <code>Big-Endian</code>(大端字节序)，这两个术语与 <code>CPU</code> <strong>体系结构</strong>中单词中<strong>字节的方向</strong>有关。</li>
</ul>
<blockquote>
<ul>
<li><code>endian</code> := <code>byte order</code> := 字节序</li>
</ul>
</blockquote>
<ul>
<li><strong>计算机内存</strong>由<strong>正整数地址</strong>引用。</li>
</ul>
<blockquote>
<p>在<strong>计算机内存</strong>中，存储<strong>最低有效字节</strong>位于<strong>最高有效字节</strong>之前的数字是“自然”的。<br>
有时，计算机设计人员更喜欢使用这种表示的<strong>倒序版本</strong>。</p>
</blockquote>
<ul>
<li>
<p>“自然”顺序，其中<strong>不太重要的字节</strong>在内存地址中较高的有效字节之前，称为 <code>little-endian</code>。</p>
</li>
<li>
<p>许多供应商（如 Motorola、IBM、CRAY 和 Sun）更喜欢相反的顺序，当然，这称为 <code>big-endian</code>。</p>
</li>
<li>
<p><code>Big-Endian</code>(大端字节序) := 数据的高字节在内存的低地址存放，数据的低字节在内存的高地址存放</p>
</li>
</ul>
<blockquote>
<p>:= <strong>Motorola 模式</strong> := <strong>网络字节序</strong>(Network Order， 即网络序，默认网络传输字节为大端)</p>
<ul>
<li>典型代表(CPU)： Motorola / IBM 390 / PowerPC CPU /</li>
<li>典型代表(程序): Sun / Java /</li>
<li>典型代表(文件): Adobe PS / JPEG / MacPaint /</li>
<li>其他代表: 绝大部分的【<strong>网络通讯协议</strong>】 / CRAY /</li>
</ul>
</blockquote>
<blockquote>
<p>即： 地址由小向大增加，而数据从高位往低位放<br>
这和我们的阅读习惯一致。</p>
</blockquote>
<ul>
<li><code>Little-Endian</code>(小端字节序) := 数据的高字节在内存的高地址存放，数据的低字节在内存的低地址存放</li>
</ul>
<blockquote>
<p>:= <strong>Intel 模式</strong></p>
<ul>
<li>典型代表(CPU): Intel / X86 CPU / DEC CPU</li>
<li>典型代表(程序): C 语言程序</li>
<li>典型代表(文件): RTF / GIF / BMP</li>
<li>其他代表:  大部分的【<strong>操作系统</strong>】</li>
</ul>
</blockquote>
<blockquote>
<p>这种存储模式将地址的高低和数据位权有效地结合起来： 高地址部分权值高，低地址部分权值低</p>
</blockquote>
<ul>
<li>特殊代表</li>
</ul>
<blockquote>
<ul>
<li>DXF文件(AutoCAD) – Variable(可灵活配置大小端)</li>
<li><code>ARM CPU</code>既可以工作在<strong>大端模式</strong>，也可以工作在<strong>小端模式</strong></li>
</ul>
<blockquote>
<p><strong>双端处理器</strong>可以在小端和大端两种模式下运行。当前一代的ARM处理器是双端处理器。</p>
</blockquote>
</blockquote>
<ul>
<li>示例： 4个字节的16进制值(<code>0x12345678</code>)将按不同的字节序方式存储在内存中</li>
</ul>
<pre><code class="language-txt">Address         00  01  02  03
------------------------------
Little-endian   78  56  34  12
Big-endian      12  34  56  78
</code></pre>
<h2 id="为什么会有大小端之分">为什么会有<strong>大小端</strong>之分?</h2>
<ul>
<li>在计算机系统中，我们是以<strong>字节(Byte)</strong>为单位的，每个<strong>地址单元</strong>都对应着一个<strong>字节</strong>，一个字节为8bit。</li>
<li>但是在<code>C</code>语言中，除了<code>8bit</code>的<code>char</code>之外，还有<code>16bit</code>的<code>short</code>型，<code>32bit</code>的<code>long</code>型（要看具体的编译器）。</li>
</ul>
<blockquote>
<p>另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于<strong>寄存器的宽度</strong>大于1个字节，那么必然存在着：多个字节的存放安排的问题。<br>
因此，就导致了<strong>大端存储模式</strong>和<strong>小端存储模式</strong>。</p>
</blockquote>
<ul>
<li>例如，一个16bit的short型x，在内存中的地址为<code>0x0010</code>，x的值为<code>0x1122</code>，那么<code>0x11</code>为高字节，<code>0x22</code>为低字节。</li>
</ul>
<blockquote>
<p>对于<strong>大端模式</strong>，就将<code>0x11</code>放在低地址中，即 <code>0x0010</code> 中，0x22放在高地址中，即0x0011中。<br>
对于<strong>小端模式</strong>，刚好相反。</p>
</blockquote>
<pre><code class="language-txt">bytes: 0x11(高字节) / 0x22(低字节)

Address         00(低地址)  10(高地址)
------------------------------------
Little-endian   22         11
Big-endian      11         22
</code></pre>
<ul>
<li>我们常用的<code>X86</code>CPU架构是<strong>小端模式</strong>，而<code>KEIL C51</code>则为<strong>大端模式</strong>。</li>
</ul>
<blockquote>
<p>很多的<code>ARM</code>，<code>DSP</code>都为<strong>小端模式</strong>。<br>
有些<code>ARM</code><strong>处理器</strong>，还可以由<strong>硬件</strong>来选择是<strong>大端模式</strong>还是<strong>小端模式</strong>。</p>
</blockquote>
<h2 id="字节顺序是否影响文件格式"><strong>字节顺序</strong>是否影响文件格式?</h2>
<ul>
<li>
<p>以<code>1</code>个字节为基本单位的文件格式，独立于字节顺序，例如: <code>ASCII</code>文件。</p>
</li>
<li>
<p><strong>其他文件格式</strong>，使用一些固定的<strong>端顺序格式</strong></p>
</li>
</ul>
<blockquote>
<p>例如: JPEG文件，以大端顺序格式存储。</p>
</blockquote>
<ul>
<li><code>java</code>程序文件及二进制文件，全部为<strong>大端</strong>(与平台无关)： Java二进制文件中的所有内容都以大端顺序存储。</li>
</ul>
<blockquote>
<p>这意味着如果您只使用Java，那么所有文件在所有平台(Mac、PC、UNIX等)上的处理方式都是相同的。</p>
</blockquote>
<ul>
<li><code>C</code>语言程序及二进制文件，默认是<strong>小端模式</strong>：用C语言编写的程序通常使用<strong>小端顺序</strong></li>
</ul>
<h2 id="如何判断机器的字节序">如何判断机器的字节序?</h2>
<h3 id="c-语言版">C 语言版</h3>
<ul>
<li>可以编写一段测试程序来判别机器的字节序</li>
</ul>
<pre><code class="language-c">BOOL IsBigEndian()  
{  
    int a = 0x1234;  
    char b =  *(char *)&amp;a;  //通过将 int 强制类型转换成 char 单字节，通过判断起始存储位置。即 等于 取b等于a的低地址部分  
    if( b == 0x12) //低地址的内容为 高字节序的值时  
    {  
        return TRUE; //大端
    }  
    return FALSE; //小端
}
</code></pre>
<ul>
<li><strong>联合体</strong>/<code>union</code>的<strong>存放顺序</strong>是所有成员都从<strong>低地址</strong>开始存放</li>
</ul>
<blockquote>
<p>利用该特性可以轻松地获得了<code>CPU</code>对内存采用<code>Little-endian</code>还是<code>Big-endian</code>模式读写：</p>
</blockquote>
<pre><code class="language-c">BOOL IsBigEndian()
{
    union NUM
    {
        int a;
        char b;
    }num;
    num.a = 0x1234;
    if( num.b == 0x12 )
    {
        return TRUE;
    }
    return FALSE;
}
</code></pre>
<h3 id="shell-版">Shell 版</h3>
<ul>
<li>方法1</li>
</ul>
<pre><code class="language-shell">echo -n I | od -o | head -n1 | cut -f2 -d" " | cut -c6
</code></pre>
<blockquote>
<p>解释： <code>od</code>命令的作用为将指定内容以八进制、十进制、十六进制、浮点格式或ASCII编码字符方式显示</p>
<ul>
<li>0: 大端字节序</li>
<li>1: 小端字节序</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250609211314843-1316393182.png" alt="" loading="lazy"></p>
<blockquote>
<p><code>Intel(R) Xeon(R) Platinum 8378C CPU @ 2.80GHz</code></p>
</blockquote>
<ul>
<li>方法2</li>
</ul>
<pre><code class="language-shell">echo -n I | od -o | head -n1 | awk '{print $2}'| cut -c6
</code></pre>
<blockquote>
<ul>
<li>输出：1为小端模式，0为大端模式；</li>
<li>解析：awk命令为文本处理。</li>
</ul>
</blockquote>
<ul>
<li>方法3</li>
</ul>
<pre><code class="language-shell">lscpu | grep -i byte
</code></pre>
<blockquote>
<ul>
<li>输出： Byte Order / Little Endian；</li>
<li>解析： <code>grep -i</code> 为不区分大小写匹配；</li>
<li>注意： 在低版本的Linux 或 Windows Git Bash 可能不支持<code>lscpu</code>命令。</li>
</ul>
</blockquote>
<ul>
<li>方法4</li>
</ul>
<pre><code class="language-shell">dpkg-architecture | grep -i end
</code></pre>
<blockquote>
<ul>
<li>输出：</li>
</ul>
<blockquote>
<p>DEB_BUILD_ARCH_ENDIAN=little<br>
DEB_HOST_ARCH_ENDIAN=little<br>
DEB_TARGET_ARCH_ENDIAN=little</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>解析： <code>dpkg-architecture</code> 命令是列出dpkg打包的一些环境参数；</li>
</ul>
</blockquote>
<h3 id="java-版">Java 版</h3>
<ul>
<li>在Java中，我们可以使用<code>ByteOrder.nativeOrder()</code>方法来获取<code>CPU</code>使用的<strong>字节顺序</strong>。</li>
</ul>
<blockquote>
<p>在使用<code>Intel CPU</code> 或 <code>AMD CPU</code>时，输出结果都是<strong>小端顺序</strong></p>
</blockquote>
<pre><code class="language-java">import java.nio.ByteOrder;

    /**
     * 获取机器的字节序
     * @return
     */
    public static ByteOrder getByteOrder(){
        ByteOrder byteOrder = ByteOrder.nativeOrder();
        return byteOrder;
    }
</code></pre>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18293230" target="_blank">基础工具： ByteUtils(字节操作) - 博客园/千千寰宇</a></li>
</ul>
<blockquote>
<p>含大小端的判断与处理</p>
</blockquote>
</blockquote>
<h2 id="大小端之间的转换">大小端之间的转换?</h2>
<ul>
<li>对于字数据（16位）：</li>
</ul>
<pre><code class="language-c">#define BigtoLittle16(A)   ( ( ((uint16)(A) &amp; 0xff00) &gt;&gt; 8)  |  (( (uint16)(A) &amp; 0x00ff) &lt;&lt; 8) )
</code></pre>
<ul>
<li>对于双字数据（32位）</li>
</ul>
<pre><code class="language-c">#define BigtoLittle32(A)   ((( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \
                                       (( (uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8)   | \
                                       (( (uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8)   | \
                                       (( (uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))
</code></pre>
<h2 id="java-中的字节序--big-endian">Java 中的字节序 := <code>Big-Endian</code></h2>
<ul>
<li>在两台计算机之间传输数据时，<strong>字节序的差异</strong>可能是一个问题。</li>
<li>Java <strong>二进制文件</strong>中的所有内容都以 <code>big-endian</code> 顺序存储。</li>
</ul>
<blockquote>
<p>这有时称为<strong>网络顺序</strong>。<br>
这意味着，如果您只使用 Java，则:<strong>所有文件</strong>在<strong>所有平台</strong>上都以相同的方式完成：<code>Mac</code>、<code>PC</code>、<code>UNIX</code> 等。<br>
您可以自由地以电子方式交换二进制数据，而<strong>无需担心字节序</strong>。</p>
</blockquote>
<ul>
<li>当您必须与一些不是用 <code>Java</code> 编写的、使用<strong>小端顺序</strong>的<strong>程序交换数据</strong>时，问题就出现了。</li>
</ul>
<blockquote>
<p>一些平台在内部使用 <code>big-endian order</code> （Mac， IBM 390）;有些使用 <code>little-endian order</code> （Intel）。<br>
最常见的是用 <code>C</code> 编写的程序。（<code>C</code>语言程序的默认字节序： 小端字节序）</p>
</blockquote>
<h2 id="从字节数组中按照指定的字节序提取bit序列">从字节数组中按照指定的字节序提取bit序列</h2>
<ul>
<li>参考文献</li>
</ul>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18921308" target="_blank">基础工具： ByteUtils(字节操作) - 博客园/千千寰宇</a></li>
</ul>
</blockquote>
<pre><code class="language-java">    /**
     * 从16进制序列中按照指定的大小端(字节序)，提取指定长度的、指定偏移位的二进制串
     * @note 本示例中的样例序列对应的结果，均为正确结果
     */
    @Test
    public void extractTargetBitsTest(){
        String bits = null;

        //CAN帧 Payload
        bits = BytesUtils.extractTargetBits("0050D4408102050A", ByteOrder.LITTLE_ENDIAN, 17, 9);//'001101010'
        log.info("bits:{}", bits);

        bits = BytesUtils.extractTargetBits("7f7f010110110021", ByteOrder.BIG_ENDIAN, 22, 7);// '0000001'
        log.info("bits:{}", bits);

        bits = BytesUtils.extractTargetBits("7f7f010110110021", ByteOrder.BIG_ENDIAN, 22, 7);// '0000001'
        log.info("bits:{}", bits);

        //SOME/IP 报文 Payload
        bits = BytesUtils.extractTargetBits("ff", ByteOrder.BIG_ENDIAN, 1*8-1, 8);// '11111111' (1个字节，从起始位 8-1 开始，从右往左数 8 个 bit)
        log.info("bits:{}", bits);
    }
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18293230" target="_blank">基础工具： ByteUtils(字节操作) - 博客园/千千寰宇</a></li>
</ul>
<blockquote>
<p>含大小端的判断与处理</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18115702" target="_blank">[车联网] CAN总线与DBC详解 - 博客园/千千寰宇</a></li>
</ul>
<blockquote>
<p>案例2：(小端模式/Intel/1) 【必读】<br>
案例3：(大端模式/Motorola/0) 【必读】</p>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://blog.csdn.net/d704791892/article/details/141787687" target="_blank" rel="noopener nofollow">C语言：大小端模式、判断大小端、大小端转换 - CSDN</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/275662870" target="_blank" rel="noopener nofollow">C语言中的大小端问题 - zhihu</a> 【推荐】</li>
<li><a href="https://www.cnblogs.com/gengtongyu/p/17465719.html" target="_blank">C语言中的强制转换、大端小端 - 博客园</a></li>
<li><a href="https://blog.csdn.net/nicai_xiaoqinxi/article/details/85311458" target="_blank" rel="noopener nofollow">Linux一句命令之判断大小端序 - CSDN</a> 【推荐】</li>
<li><a href="https://blog.csdn.net/penriver/article/details/124765592" target="_blank" rel="noopener nofollow">java -- Big Endian and Little Endian 大端和小端概念讲解及如何转换 - CSDN</a> 【推荐】</li>
<li><a href="https://howtodoinjava.com/java/basics/little-endian-big-endian/" target="_blank" rel="noopener nofollow">Little-Endian and Big-Endian in Java - howtodoinjava.com</a> 【推荐】</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011111111111111112" data-date-updated="2025-06-10 17:46">2025-06-10 17:30</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18921308);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18921308', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18921308', title: '[数据传输/网络传输/序列化/计算机组成原理] 字节序/大小端' })">举报</a>
</div>
        