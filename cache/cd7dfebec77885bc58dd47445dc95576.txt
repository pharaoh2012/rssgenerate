
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18725414" title="发布于 2025-02-19 22:06">
    <span role="heading" aria-level="2">『Python底层原理』--CPython的变量实现机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在<code>Python</code>中，变量的使用看起来非常简单，例如 <code>a = 10</code>，<code>s = "hello"</code>等等。</p>
<p>然而，这种简单的赋值操作背后，<code>CPython</code>其实做了很多复杂的工作。</p>
<p>本文将通过一些简单易懂的代码示例，一起探索<code>Python</code>变量背后的奥秘，让我们对它的实现机制有更深一步的理解。</p>
<h1 id="1-变量到底是什么">1. 变量到底是什么？</h1>
<p>在<code>Python</code>中，变量本质上是一个名字到值的映射。</p>
<p>例如，当你写<code>a = 1</code>时，<code>a</code>是一个名字，而<code>1</code>是一个值。</p>
<p><code>CPython</code>会将这个<strong>名字</strong>和<strong>值</strong>关联起来，以便你后续可以通过<strong>名字</strong>访问这个<strong>值</strong>。</p>
<pre><code class="language-python">a = 1
print(a)  # 输出：1
</code></pre>
<p>这种映射关系是通过一个名为<strong>命名空间</strong>的结构实现的。</p>
<p><strong>命名空间</strong>是一个字典，其中的键是变量名，值是变量对应的对象。</p>
<p>它的定义可参考CPython源码中的<code>Include/internal/pycore_frame.h</code>文件。</p>
<pre><code class="language-c">typedef struct _PyInterpreterFrame {
    // 省略... ...
    PyObject *f_globals; /* Borrowed reference. Only valid if not on C stack */
    PyObject *f_builtins; /* Borrowed reference. Only valid if not on C stack */
    PyObject *f_locals; /* Strong reference, may be NULL. Only valid if not on C stack */
    // 省略... ...
}
</code></pre>
<p>其中，<code>f_locals</code> 保存局部变量映射，函数执行时，局部变量值存于此；</p>
<p><code>f_globals</code> 用于全局变量，模块级代码块执行时，<code>f_globals</code> 指向模块全局命名空间字典；</p>
<p><code>f_builtins</code> 关联内置命名空间。</p>
<h1 id="2-变量的底层实现字节码">2. 变量的底层实现：字节码</h1>
<p>CPython在执行代码时，会先将代码编译成字节码，然后由虚拟机执行这些字节码。我们可以通过  dis  模块查看代码的字节码。</p>
<p>例如，对于<code>a = 1</code>，字节码如下：</p>
<pre><code class="language-python">import dis

code = """
a = b
"""
dis.dis(code)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526537-767849760.png" alt="" loading="lazy"></p>
<ul>
<li><code>LOAD_NAME</code>：从命名空间中加载变量<code>b</code>的值</li>
<li><code>STORE_NAME</code>：将值存储到变量<code>a</code>中</li>
</ul>
<p>这两个指令展示了<code>CPython</code>如何处理变量的读取和赋值。</p>
<h1 id="3-命名空间与作用域">3. 命名空间与作用域</h1>
<p><code>Python</code>中的变量存储在不同的命名空间中，而这些命名空间又与代码的作用域相关，作用域决定了变量的可见性。</p>
<p><code>Python</code>有三种主要的作用域：</p>
<ol>
<li><strong>局部作用域</strong>：函数内部的变量</li>
<li><strong>全局作用域</strong>：模块级别的变量</li>
<li><strong>内置作用域</strong>：包含内置函数和类型的命名空间</li>
</ol>
<pre><code class="language-python">x = "global"  # 全局变量

def func():
    y = "local"  # 局部变量
    print(x)  # 输出：global
    print(y)  # 输出：local

func()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526477-2061572698.png" alt="" loading="lazy"></p>
<p>在这个例子中，<code>x</code>是全局变量，<code>y</code>是局部变量。</p>
<p>如果在函数中尝试访问一个<strong>未定义</strong>的变量，<code>CPython</code>会按照以下顺序查找：</p>
<ol>
<li>
<p>局部命名空间（<code>f_locals</code>）</p>
</li>
<li>
<p>全局命名空间（<code>f_globals</code>）</p>
</li>
<li>
<p>内置命名空间（<code>f_builtins</code>）</p>
</li>
</ol>
<p>如果仍然找不到，就会抛出<code>NameError</code>异常。</p>
<h1 id="4-不同变量的字节码">4. 不同变量的字节码</h1>
<p><code>CPython</code>为不同作用域的变量提供了不同的字节码指令，以优化性能和实现特定的行为。</p>
<h2 id="41-局部变量">4.1. 局部变量</h2>
<p>在函数中，局部变量使用<code>LOAD_FAST</code>和<code>STORE_FAST</code>指令。</p>
<p>这些指令直接操作一个数组，而不是字典，因此速度更快。</p>
<pre><code class="language-python">def func():
    a = 1  # STORE_FAST
    b = a  # LOAD_FAST
    return b

dis.dis(func)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526549-1085894150.png" alt="" loading="lazy"></p>
<h2 id="42-全局变量">4.2. 全局变量</h2>
<p>全局变量使用<code>LOAD_GLOBAL</code>和<code>STORE_GLOBAL</code>指令。</p>
<p>这些指令会直接操作全局命名空间。</p>
<pre><code class="language-python">x = 1

def func():
    global x
    x = 2  # STORE_GLOBAL
    return x  # LOAD_GLOBAL

dis.dis(func)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526535-1161662675.png" alt="" loading="lazy"></p>
<h2 id="43-闭包变量">4.3. 闭包变量</h2>
<p>当函数嵌套时，内部函数可以访问外部函数的变量。</p>
<p>这些变量称为<strong>闭包变量</strong>，使用<code>LOAD_DEREF</code>和<code>STORE_DEREF</code>指令。</p>
<pre><code class="language-python">def outer():
    x = 1
    def inner():
        return x  # LOAD_DEREF
    return inner

dis.dis(outer)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526502-60028954.png" alt="" loading="lazy"></p>
<h1 id="5-类中的变量">5. 类中的变量</h1>
<p>在类定义中，变量的行为与函数不同。</p>
<p>类定义中的变量使用<code>LOAD_NAME</code>和<code>STORE_NAME</code>指令，因为类的命名空间会动态地与全局命名空间交互。</p>
<pre><code class="language-python">x = "global"

class MyClass:
    print(x)  # 使用 LOAD_NAME
    x = "local"
    print(x)  # 使用 LOAD_NAME

MyClass()
</code></pre>
<p>输出：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250219220526502-1629291996.png" alt="" loading="lazy"></p>
<p>查看指令的话，可以使用：<code>python.exe -m dis .\cpython-variable.py</code>命令。</p>
<p>如果在类中使用嵌套函数，<code>CPython</code>会使用<code>LOAD_CLASSDEREF</code>指令来处理闭包变量。</p>
<pre><code class="language-python">class MyClass:
    x = "cell"
    def method(self):
        print(x)  # 使用 LOAD_CLASSDEREF

MyClass().method()
</code></pre>
<h1 id="6-编译器如何选择指令">6. 编译器如何选择指令</h1>
<p><code>CPython</code>的编译器会根据变量的作用域和代码块类型选择合适的字节码指令。</p>
<p>例如：</p>
<ul>
<li>如果变量是局部变量，编译器会生成<code>LOAD_FAST</code>和<code>STORE_FAST</code></li>
<li>如果变量是全局变量，编译器会生成<code>LOAD_GLOBAL</code>和<code>STORE_GLOBAL</code></li>
<li>如果变量是闭包变量，编译器会生成<code>LOAD_DEREF</code>和<code>STORE_DEREF</code></li>
</ul>
<h1 id="7-总结">7. 总结</h1>
<p><code>Python</code>变量的实现机制比看起来复杂得多，它涉及到字节码指令、命名空间、作用域以及编译器的决策逻辑。</p>
<p>通过理解这些概念，可以更好地掌握<code>Python</code>的变量行为，尤其是在复杂的作用域场景中。</p>
<p>如果对<code>CPython</code>的实现感兴趣，可以进一步阅读其源码中与变量相关的部分。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0065636500706018515" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-19 22:06">2025-02-19 22:06</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18725414" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18725414);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18725414', targetLink: 'https://www.cnblogs.com/wang_yb/p/18725414', title: '『Python底层原理』--CPython的变量实现机制' })">举报</a>
</div>
        