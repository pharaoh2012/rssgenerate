
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18809665" title="发布于 2025-04-05 00:44">
    <span role="heading" aria-level="2">【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（5）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1154" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18809665" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18809665" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18809665</a></p>
<h2 id="开题--补题情况">开题 + 补题情况</h2>
<p>这场被自己唐到了，有点着急了，没能冷静下来思考，导致签到题一错再错，最后甚至完全偏离了自己原本的思路。<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202504/3572902-20250405000337720-1380743406.png" alt="image" loading="lazy"></p>
<h2 id="1001---小凯逛超市">1001 - 小凯逛超市</h2>
<p>很明显的无穷背包，但一开始没有好好读题，打成 01 背包了，不仔细的下场。</p>
<details>
<summary>点击查看代码（省略了取模类）</summary>
<pre><code class="language-cpp">void solve()
{
    int n, m, v;std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; v;

    std::vector&lt;i64&gt; a(n + 1);

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    std::vector&lt;std::vector&lt;Z&gt;&gt; dp(v + 1, std::vector&lt;Z&gt;(m + 1));

    dp[0][0] = 1;
    for(int i = 1;i &lt;= n;i ++) {
        for(int j = a[i];j &lt;= v;j ++) {
            for(int k = 1;k &lt;= m;k ++) {
                dp[j][k] += dp[j - a[i]][k - 1];
            }
        }
    }

    Z ans = 0;

    for(int i = 0;i &lt;= v;i ++) {
        ans += dp[i][m];
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1010---小凯做梦">1010 - 小凯做梦</h2>
<p>这个题还是很好的，要做出这个题，我们首先需要知道一个重要的计算树上两点路径距离的公式。<br>
记 <span class="math inline">\(dep_x\)</span> 为点 <span class="math inline">\(x\)</span> 到根的距离，<span class="math inline">\(d_{i,j}\)</span> 为点 <span class="math inline">\(i\)</span> 到点 <span class="math inline">\(j\)</span> 之间的距离，则有：</p>
<p></p><div class="math display">\[d_{i, j} = dep_i + dep_j - 2\times dep_{lca_{i, j}}
\]</div><p></p><p>如果将这个式子对 <span class="math inline">\(2\)</span> 取模，又会发生什么呢：</p>
<p></p><div class="math display">\[d_{i, j} \% 2 = dep_i \% 2 + dep_j \% 2
\]</div><p></p><p>而对于三个点 <span class="math inline">\(i, j, k\)</span>，要有 <span class="math inline">\(d_{i, j} = d_{j, k} = d_{i, k} (\mod 2)\)</span>，我们可以列出下面这几个式子：</p>
<p></p><div class="math display">\[dep_i \% 2 + dep_j \% 2 = dep_i \% 2 + dep_k \% 2
\]</div><p></p><p></p><div class="math display">\[dep_i \% 2 + dep_j \% 2 = dep_j \% 2 + dep_k \% 2
\]</div><p></p><p></p><div class="math display">\[dep_j \% 2 + dep_k \% 2 = dep_i \% 2 + dep_k \% 2
\]</div><p></p><p>消元可得：</p>
<p></p><div class="math display">\[dep_i \% 2 = dep_j \% 2 = dep_k \% 2
\]</div><p></p><p>然后这个问题就转化为一个很简单的组合数问题了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;
struct Node {
    int v;
    int w;
};

void solve()
{
    int n;std::cin &gt;&gt; n;

    std::vector&lt;std::vector&lt;Node&gt;&gt; g(n + 1);

    for(int i = 1;i &lt; n;i ++) {
        int u, v, w;std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        w %= 2;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    } 

    std::vector&lt;int&gt; dis(n + 1, 0);

    auto dfs = [&amp;](auto &amp;&amp;self, int st, int fa) -&gt; void {
        for(auto &amp;[v, w] : g[st]) {
            if(v == fa)continue;
            dis[v] = (dis[st] + w) % 2;
            self(self, v, st);
        }
    };

    dfs(dfs, 1, 0);

    std::array&lt;i64, 2&gt; sum{0, 0};

    for(int i = 1;i &lt;= n;i ++) {
        sum[dis[i]] ++;
    }

    i64 ans = 0;
    ans += sum[0] * sum[0] * sum[0];
    ans += sum[1] * sum[1] * sum[1];

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="1006---小凯在长跑补题">1006 - 小凯在长跑（补题）</h2>
<p>这个题是真的唐，不小心写出了一个 <span class="math inline">\(\sqrt{a^2 + b^2} = \sqrt{a^2} + \sqrt{b^2}\)</span> 然后被硬控两小时，记录于此，引以为戒，之后做题的时候一定要一步一步好好思考，式子想好了再写代码，不要凭空瞎造。<br>
题目思路还是很简单的，中学数学题，就不多写思路了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int d, r, x, y;std::cin &gt;&gt; d &gt;&gt; r &gt;&gt; x &gt;&gt; y;

    x = abs(x);
    y = abs(y);

    if(y &lt;= d) {
        std::cout &lt;&lt; abs(r - x) &lt;&lt; '\n';
    } else if(x * x + (y - d) * (y - d) &lt;= r * r){
        long double d1 = (long double)(x * x + (y - d) * (y - d));
        std::cout &lt;&lt; roundl(r - sqrtl(d1)) &lt;&lt; '\n';
    } else {
        long double d1 = sqrtl(x * x + (y - d) * (y - d)) - sqrtl(r * r);
        long double d2 = sqrtl((x - r) * (x - r) + (y - d) * (y - d));
        long double d3 = sqrtl(x * x + (y - d - r) * (y - d - r));

        std::cout &lt;&lt; roundl(std::min(d1, std::min(d2, d3))) &lt;&lt; '\n';
    }
}
</code></pre>
</details>
<h2 id="1009---小凯取石子补题">1009 - 小凯取石子（补题）</h2>
<p>个人认为这个题题目没有写清楚，对于小凯而言，应该是尽可能让自己获胜率高，但题目并没有对此进行说明也没有进行样例解析。<br>
这个题可以打表找规律，但赛时没能找到规律，因此没能开出（也受到了长跑那个题的影响吧，心态不太稳定，一直忍不住在想那个题，但及时换题才是正确之道）。<br>
用很常用的博弈手段来分析，我们从结果往回推，逐步分析博弈状态的转化，这里要注意，对于 Kc0，拿 <span class="math inline">\(1\)</span> 个和拿 <span class="math inline">\(4\)</span> 个都要分析，各有 <span class="math inline">\(1/2\)</span> 的概率，对于小凯，要选择的是转化后得到的新概率更大的状态，并乘上操作后转化得到的新状态的概率，就是当前的概率，打表过程可以自行尝试（还是很考验人的细心的），这里仅给出结论：</p>
<ul>
<li>当 <span class="math inline">\(n \% 5 = 0\)</span> 或 <span class="math inline">\(n \% 5 = 2\)</span> 时，必胜。</li>
<li>当 <span class="math inline">\(n = 1 时\)</span>，<span class="math inline">\(1 / 2\)</span> 的概率获胜。</li>
<li>当 <span class="math inline">\(n \% 5 = 1\)</span> 并且 <span class="math inline">\(n \neq 1\)</span> 时，有 <span class="math inline">\(1 - (1/2) ^ {n / 5}\)</span> 的概率获胜。</li>
<li>当 <span class="math inline">\(n \% 5 = 3\)</span> 时，有 <span class="math inline">\(1 - (1/2) ^ {n / 5 + 2}\)</span> 的概率获胜。</li>
<li>当 <span class="math inline">\(n \% 5 = 4\)</span> 时，有 <span class="math inline">\(1 - (1/2) ^ {n / 5 + 1}\)</span> 的概率获胜。</li>
</ul>
<p>至于为什么是对 <span class="math inline">\(5\)</span> 取模呢，其实打表过程也是有迹可循的，打表打着打着就会出现一些抉择是 Kc0 拿 <span class="math inline">\(1\)</span> 小凯拿 <span class="math inline">\(4\)</span> 和 Kc0 拿 <span class="math inline">\(4\)</span> 小凯拿 <span class="math inline">\(1\)</span>，感觉多多少少和这个有关系，至于严谨证明就暂时想不到了。</p>
<details>
<summary>点击查看代码（省略了取模类）</summary>
<pre><code class="language-cpp">void solve()
{
    i64 n;std::cin &gt;&gt; n;
    Z ans;
    Z t = 2;

    if(n % 5 == 0 || n % 5 == 2) {
        ans = 1;
    } else if(n == 1) {
        ans = Z(1) / 2; 
    } else if(n % 5 == 1) {
        ans = Z(1) - Z(1) / t.Pow(n / 5);
    } else if(n % 5 == 3) {
        ans = Z(1) - Z(1) / t.Pow(n / 5 + 2);
    } else if(n % 5 == 4) {
        ans = Z(1) - Z(1) / t.Pow(n / 5 + 1);
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.32178909936921296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-05 14:30">2025-04-05 00:44</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">62</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18809665" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18809665);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18809665', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18809665', title: '【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（5）' })">举报</a>
</div>
        