
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/henjay724/p/18761139" title="发布于 2025-03-09 18:26">
    <span role="heading" aria-level="2">痞子衡嵌入式：了解主从系统中i.MXRT系列MCU从主处理器接收App数据包超时机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<hr>
<p>　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是<strong>主从系统中i.MXRT系列MCU从主处理器接收App数据包超时机制</strong>。</p>
<p>　　在痞子衡旧文 <a href="https://www.cnblogs.com/henjay724/p/9034563.html" target="_blank">《RT四位数Boot模式》</a> 里的 1.2.1 Serial Downloader 模式、<a href="https://www.cnblogs.com/henjay724/p/11990219.html" target="_blank">《RT三位数Boot模式》</a> 里的 1.2.2 Serial Boot 模式里都介绍到了 i.MXRT 芯片内置 ROM 程序里支持与主机进行数据交互，而交互的通信协议均是 blhost 协议（这最早来自于飞思卡尔 Kinetis 系列 ROM ），有了这个功能，我们便可以直接将应用程序灌进 i.MXRT 内部 SRAM 去加载执行，这个功能在多处理器系统里（尤其是 i.MXRT 作为协处理器）大有用处。</p>
<p>　　最近有一个客户设计了高通 AR1 + 恩智浦 i.MXRT600 的主从系统，RT600 作为协处理器直接通过 SPI 接口从主处理器 AR1 接收应用程序 App 并加载到自身内部 SRAM 执行，这样硬件上便可省去 RT600 的专属非易失性存储器。客户已经将 blhost 协议代码集成进了 AR1 程序里，但在实际测试过程中发现有一定概率导致 RT600 程序加载失败，RT600 ROM 会返回 kStatus_AbortDataPhase（0x5A,0xA3），这是怎么回事？今天痞子衡就来聊聊这个话题：</p>
<h3 id="一imxrt与主机交互方法">一、i.MXRT与主机交互方法</h3>
<p>　　我们首先简单回顾下 i.MXRT 内置 ROM 程序配套的与主机交互方法，有如下三种。其中方法一是比较常用的，把 PC 当作主机，因为 UART/USB 接口可以直接从 PC 引出，这种方式一般集成在上位机 GUI 工具里（比如恩智浦官方的 SPT 以及痞子衡的 <a href="https://github.com/JayHeng/NXP-MCUBootUtility" target="_blank" rel="noopener nofollow">NXP-MCUBootUtility</a>)。方法二本质上和方式一差不多，主机仍然是 PC，只不过通信接口是 SPI/I2C，因为无法直接从 PC 引出，需要有一个桥接板，恩智浦一共做了三种不同的桥接实现。方式三就是本文提及的客户所用到的方法，把主处理器当作主机，因为处理器接口丰富，所以不管哪种通信方式均可以直连。</p>
<p>　　因为方式一和方式二均可以直接使用恩智浦提供的配套工具链，因此 blhost 协议实现细节以及注意事项都被包在了工具链里面，客户使用起来基本不会遇到问题。而方式三需要客户自己移植实现 blhost 协议到主处理器代码里，这可能会遇到一些协议细节上的设计问题。</p>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/cnblogs/i.MXRT-blhost-packet-timeout-OVERVIEW.png" alt="" loading="lazy"></p>
<p>　　这里需要特别提一下方式二里的 Embedded Host 桥接实现，在恩智浦官网 <a href="https://www.nxp.com/design/design-center/software/development-software/mcuxpresso-software-and-tools-/mcu-bootloader-for-nxp-microcontrollers:MCUBOOT?tid=vanMCUBOOT" target="_blank" rel="noopener nofollow">MCUBoot</a> 主页我们可以下载到 NXP_Kinetis_Bootloader_2_0_0.zip 包，在 \NXP_Kinetis_Bootloader_2_0_0\validation\embedded_host 路径下我们可以找到基于 Kinetis K65 的实现，如果你想移植 blhost 协议到处理器上运行，不妨参考这个代码。</p>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/cnblogs/i.MXRT-blhost-packet-timeout-KBOOT2.0.png" alt="" loading="lazy"></p>
<h3 id="二imxrt从主机接收数据包超时机制">二、i.MXRT从主机接收数据包超时机制</h3>
<p>　　现在我们谈回到 blhost 协议本身，这是一套数据包传输格式与支持命令的定义集合。打开 RT600 参考手册的 <strong>Non-Secure Boot ROM</strong> 章节，可以找到具体的协议细节，这里就不再赘述。我们只取其中关于 write-memory 命令的介绍，主机给 i.MXRT 下载数据(App)主要就是借助这个命令。</p>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/cnblogs/i.MXRT-blhost-packet-timeout-Protocol.png" alt="" loading="lazy"></p>
<p>　　write-memory 命令的过程其实很简单，主机(Host)先要发送含 write-memory 信息的命令包(0x5A, 0xA4 ...) 给 i.MXRT (图中叫 target)，收到确认的回复(0x5A, 0xA1)后，主机继续发送含 App 程序数据的数据包(0x5A, 0xA5 ...)，等待 i.MXRT 处理完成返回确认信息，然后主机不断发送数据包，直到 App 数据全部发送完成，最后还有一个结束命令包。</p>
<blockquote>
<ul>
<li>Note: 注意这里的 App 数据不是一个数据包就全部发送完的，而是被拆分成了很多个小数据包，每个小数据包最大长度是 512 字节。拆分成小包的目的是防止通信过程中有干扰导致数据错误，出现错误就只需要重新发送该包数据。如果不拆分数据包，出现错误就得全部 App 数据重发，效率太低。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/cnblogs/i.MXRT-blhost-packet-timeout-TIME.png" alt="" loading="lazy"></p>
<p>　　关于每个数据小包的接收与发送，i.MXRT 均设计了超时机制保护。如果主机已经开始发送当前小包数据(发完包固定起始字节 0x5A 后为超时起点)，那么需要在规定时间内（包剩余长度(Bytes) * 10ms/Bytes）完成该包数据发送，如果超时时间内未完成，i.MXRT 则返回 kStatus_AbortDataPhase。至于 read-memory 时主机接收小包数据时超时机制相同，只不过时间单元是 20ms/Bytes。</p>
<blockquote>
<ul>
<li>Note1：RT500/600/700 ROM 程序里数据包处理超时机制是一样的，发送和接收均有超时。</li>
<li>Note2：RT1160/1170/1180 ROM 程序里数据包处理仅有接收超时，没有发送超时。</li>
</ul>
</blockquote>
<p>　　当然文档里上述表述有未尽的地方，主机每发完一小包数据后都需要读确认信息(0x5A, 0xA1)，确认信息这里是否有超时限制？如果有，是怎样的机制？痞子衡就不卖关子了，这里是需要特别注意的，当主机发完一包数据后，i.MXRT 需要及时处理数据的，由于这里是加载程序进内部 SRAM，所以就是将该数据包从缓冲区搬到 SRAM 指定位置，这个时间 t2 很短，文档里并未给出。t3 是比较关键的时间，这里的计时起点并不是主机收到 ACK 包的第一个字节，而是 i.MXRT 处理完数据搬移后就开始了，因此主机每次发完数据包之后，都需要在 t2+t3 的时间内将确认信息数据包及时读走，否则 i.MXRT 则返回 kStatus_AbortDataPhase。</p>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/cnblogs/i.MXRT-blhost-packet-timeout-ANAL.png" alt="" loading="lazy"></p>
<p>　　那么问题来了，如果一小包数据是 200 bytes（包含 0x5A 包头等信息），请问主机发送数据和接收确认的超时时间分别是多少？答案是 1990ms 和 t2+40ms（这里主机接收确认消息只拿了 2 bytes 数据）。</p>
<h3 id="三客户主机发送数据包设计">三、客户主机发送数据包设计</h3>
<p>　　最后回到客户的问题，经过和客户的沟通，主处理器 AR1 运行得是一个非实时操作系统。在给 RT600 加载 App 程序过程中会出现任务调度情况，发送完一个小数据包后，因为任务调度的关系，导致主机读取确认消息(0x5A, 0xA1)的时间间隔不确定，有时候小于 40ms，有时候会超出 40ms，显然这是不符合 blhost 协议超时机制规定的。</p>
<p>　　至此，主从系统中i.MXRT系列MCU从主处理器接收App数据包超时机制痞子衡便介绍完毕了，掌声在哪里~~~</p>
<h3 id="欢迎订阅">欢迎订阅</h3>
<p>文章会同时发布到我的 <a href="https://www.cnblogs.com/henjay724/" target="_blank">博客园</a>、<a href="https://blog.csdn.net/henjay724" target="_blank" rel="noopener nofollow">CSDN</a>、<a href="http://weixin.sogou.com/weixin?type=1&amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F" target="_blank" rel="noopener nofollow">微信公众号</a>、<a href="https://www.zhihu.com/people/henjay724" target="_blank" rel="noopener nofollow">知乎</a>、<a href="https://www.eefocus.com/user/3876937/article/" target="_blank" rel="noopener nofollow">与非网</a>、<a href="https://blog.chinaaet.com/henjay724" target="_blank" rel="noopener nofollow">电子技术应用AET</a>、<a href="https://www.dianyuan.com/people/912268" target="_blank" rel="noopener nofollow">电子星球</a>、<a href="https://blog.51cto.com/henjay724" target="_blank" rel="noopener nofollow">51CTO</a> 平台上。</p>
<p>微信搜索"<strong>痞子衡嵌入式</strong>"或者扫描下面二维码，就可以在手机上第一时间看了哦。</p>
<p><img src="https://raw.githubusercontent.com/JayHeng/pzhmcu-picture/master/wechat/pzhMcu_qrcode_258x258.jpg" alt="" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    <div class="autograph"> 
  <p style="font-family: 楷体; font-size: 15px">&nbsp;&nbsp;最后欢迎关注痞子衡个人微信公众号【痞子衡嵌入式】，一个专注嵌入式技术的公众号，跟着痞子衡一起玩转嵌入式。</p>

  <img style="float: left" src="https://img2022.cnblogs.com/blog/623659/202211/623659-20221116165755872-427238307.jpg" alt="痞子衡嵌入式-微信二维码" class="img_avatar">

  <img style="float: right" src="http://henjay724.com/image/cnblogs/baogeMcu_payment_wechat_150x150.png" alt="痞子衡嵌入式-微信收款二维码" class="img_avatar">

  <img style="float: right" src="http://henjay724.com/image/cnblogs/baogeMcu_payment_alipay_150x150.jpg" alt="痞子衡嵌入式-支付宝收款二维码" class="img_avatar">

<br>
  <p>&nbsp;&nbsp;衡杰(痞子衡)，目前就职于某全球顶级半导体原厂MCU系统部门，担任高级嵌入式系统应用工程师。</p>

  <p>&nbsp;&nbsp;专栏内所有文章的转载请注明出处：<a href="http://www.cnblogs.com/henjay724/" target="_blank">http://www.cnblogs.com/henjay724/</a></p>

  <p>&nbsp;&nbsp;与痞子衡进一步交流或咨询业务合作请发邮件至 <a href="hengjie1989@foxmail.com" target="_blank">hengjie1989@foxmail.com</a></p>

  <p>&nbsp;&nbsp;可以关注痞子衡的Github主页 <a href="https://github.com/JayHeng" target="_blank">https://github.com/JayHeng</a>，有很多好玩的嵌入式项目。</p>

  <p><font color="yellow">&nbsp;&nbsp;关于专栏文章有任何疑问请直接在博客下面留言，痞子衡会及时回复免费(划重点)答疑。</font></p>

  <p><font color="red">&nbsp;&nbsp;痞子衡邮箱已被私信挤爆，技术问题不推荐私信，坚持私信请先扫码付款(5元起步)再发。</font></p>
<br>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0709331789375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-09 18:39">2025-03-09 18:26</span>&nbsp;
<a href="https://www.cnblogs.com/henjay724">痞子衡</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18761139" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18761139);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18761139', targetLink: 'https://www.cnblogs.com/henjay724/p/18761139', title: '痞子衡嵌入式：了解主从系统中i.MXRT系列MCU从主处理器接收App数据包超时机制' })">举报</a>
</div>
        