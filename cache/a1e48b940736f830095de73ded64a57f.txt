
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/VAllen/p/18658778/rx-subscribe-idisposable" title="发布于 2025-01-09 00:42">
    <span role="heading" aria-level="2">.NET 响应式编程 System.Reactive 系列文章（三）：Subscribe 和 IDisposable 的深入理解</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/402416/202501/402416-20250109003949798-388880637.png" alt=".NET 响应式编程 System.Reactive 系列文章（三）：Subscribe 和 IDisposable 的深入理解" class="desc_img">
        在 Rx 中，Subscribe() 方法返回一个 IDisposable 接口对象，用于手动取消订阅和释放资源。另外，System.Reactive 还提供了不返回 IDisposable 的 Subscribe 重载，这些重载方法通过 CancellationToken 管理订阅的生命周期。在本篇文章中，我们将深入探讨 Subscribe 和 IDisposable 的原理、这些特殊重载的设计原因，以及在实际使用中的应用场景。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="net-响应式编程-systemreactive-系列文章三subscribe-和-idisposable-的深入理解"><strong>.NET 响应式编程 System.Reactive 系列文章（三）：Subscribe 和 IDisposable 的深入理解</strong></h1>
<hr>
<h2 id="引言为什么理解-subscribe-和-idisposable-很重要"><strong>引言：为什么理解 Subscribe 和 IDisposable 很重要？</strong></h2>
<p>在前两篇文章中，我们详细介绍了 <strong><code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code></strong> 的核心概念及交互流程。但在实际使用 <strong>System.Reactive</strong> 时，一个常见的误区是认为数据流一旦订阅，就不需要额外管理。这种认知是危险的，因为 <strong>Observable 的订阅可能是无限的</strong>，如果不管理好订阅的生命周期，很容易导致<strong>内存泄漏</strong>和<strong>资源浪费</strong>。</p>
<p>在 Rx 中，<strong><code>Subscribe()</code> 方法返回一个 <code>IDisposable</code> 接口对象</strong>，用于<strong>手动取消订阅</strong>和释放资源。另外，<strong>System.Reactive</strong> 还提供了<strong>不返回 <code>IDisposable</code> 的 <code>Subscribe</code> 重载</strong>，这些重载方法通过 <strong><code>CancellationToken</code></strong> 管理订阅的生命周期。在本篇文章中，我们将深入探讨 <strong>Subscribe 和 IDisposable</strong> 的原理、这些特殊重载的设计原因，以及在实际使用中的应用场景。</p>
<hr>
<h2 id="1-subscribe-的内部机制"><strong>1. Subscribe 的内部机制</strong></h2>
<h3 id="11-subscribe-的作用"><strong>1.1 Subscribe 的作用</strong></h3>
<p><strong><code>Subscribe</code></strong> 是连接 <strong><code>IObservable&lt;T&gt;</code></strong> 和 <strong><code>IObserver&lt;T&gt;</code></strong> 的桥梁。当你调用 <strong><code>Subscribe()</code></strong> 方法时：</p>
<ul>
<li><strong><code>IObservable&lt;T&gt;</code> 开始向 <code>IObserver&lt;T&gt;</code> 推送数据</strong>。</li>
<li>订阅会保持活跃状态，直到：
<ul>
<li>数据流结束（调用 <code>OnCompleted()</code>）。</li>
<li>发生错误（调用 <code>OnError()</code>）。</li>
<li><strong>手动取消订阅（调用 <code>Dispose()</code>）。</strong></li>
<li><strong>超时取消订阅（向CancellationToken注册超时回调）。</strong></li>
</ul>
</li>
</ul>
<h3 id="12-为什么-subscribe-返回-idisposable"><strong>1.2 为什么 Subscribe 返回 IDisposable？</strong></h3>
<p>普通的 <strong><code>Subscribe</code> 重载</strong> 返回一个 <strong><code>IDisposable</code></strong> 对象，允许你通过调用 <strong><code>Dispose()</code></strong> 方法取消订阅。这是管理数据流生命周期的核心机制之一。</p>
<hr>
<h2 id="2-subscribe-重载不返回-idisposable-的特殊情况"><strong>2. Subscribe 重载：不返回 IDisposable 的特殊情况</strong></h2>
<p><strong><code>System.Reactive</code> 提供了一些特殊的 <code>Subscribe</code> 重载方法</strong>，它们不返回 <strong><code>IDisposable</code></strong>，而是依赖于 <strong><code>CancellationToken</code></strong> 来控制订阅的生命周期。这些方法设计的目的是为了提供一种<strong>外部取消订阅的机制</strong>，让你无需手动管理 <code>Dispose()</code> 的调用。</p>
<h3 id="21-方法签名"><strong>2.1 方法签名</strong></h3>
<p>以下是其中一个不返回 <code>IDisposable</code> 的 <code>Subscribe</code> 重载：</p>
<pre><code class="language-csharp">public static void Subscribe&lt;T&gt;(
    this IObservable&lt;T&gt; source,
    Action&lt;T&gt; onNext,
    Action&lt;Exception&gt; onError,
    Action onCompleted,
    CancellationToken cancellationToken
);
</code></pre>
<p>这种重载方法的使用场景是：<strong>你希望通过 <code>CancellationToken</code> 来控制订阅的生命周期</strong>，而不是手动调用 <code>Dispose()</code>。</p>
<hr>
<h3 id="22-示例代码使用-cancellationtoken-管理订阅"><strong>2.2 示例代码：使用 CancellationToken 管理订阅</strong></h3>
<h4 id="示例超时取消订阅"><strong>示例：超时取消订阅</strong></h4>
<pre><code class="language-csharp">using System;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

class Program
{
	static void Main(string[] args)
	{
		IObservable&lt;long&gt; observable = Observable.Interval(TimeSpan.FromSeconds(1));

		CancellationTokenSource cts = new();

		// 使用 Subscribe 方法并传入 CancellationToken
		observable.Subscribe(
			onNext: static value =&gt; Console.WriteLine($"Received: {value}"),
			onError: static ex =&gt; Console.WriteLine($"Error: {ex.Message}"),
			onCompleted: static () =&gt; Console.WriteLine("Completed"),
			token: cts.Token
		);

		// 模拟运行 5 秒后取消订阅
		Console.WriteLine("Running for 5 seconds...");
		Thread.Sleep(5000);
		cts.Cancel();
		Console.WriteLine("Subscription cancelled.");
	}
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Running for 5 seconds...
Received: 0
Received: 1
Received: 2
Received: 3
Subscription cancelled.
</code></pre>
<hr>
<h3 id="23-使用场景什么时候使用-cancellationtoken"><strong>2.3 使用场景：什么时候使用 CancellationToken？</strong></h3>
<table>
<thead>
<tr>
<th>使用场景</th>
<th>推荐的 Subscribe 重载</th>
</tr>
</thead>
<tbody>
<tr>
<td>需要手动取消订阅</td>
<td>返回 <code>IDisposable</code> 的重载</td>
</tr>
<tr>
<td>使用外部控制（如用户交互、超时）控制订阅</td>
<td>带 <code>CancellationToken</code> 的重载</td>
</tr>
</tbody>
</table>
<h4 id="典型场景"><strong>典型场景：</strong></h4>
<ol>
<li>
<p><strong>异步任务取消</strong><br>
在异步任务中使用 <strong><code>CancellationToken</code></strong> 取消订阅数据流，避免阻塞或内存泄漏。</p>
</li>
<li>
<p><strong>超时控制</strong><br>
使用 <strong><code>CancellationTokenSource.CancelAfter()</code></strong> 设置超时取消订阅。</p>
</li>
</ol>
<hr>
<h3 id="24-示例设置超时取消订阅"><strong>2.4 示例：设置超时取消订阅</strong></h3>
<pre><code class="language-csharp">using System;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

class Program
{
	static void Main(string[] args)
	{
		IObservable&lt;long&gt; observable = Observable.Interval(TimeSpan.FromSeconds(1));

		CancellationTokenSource cts = new();
		cts.CancelAfter(TimeSpan.FromSeconds(3)); // 设置 3 秒后自动取消订阅

		observable.Subscribe(
			onNext: static value =&gt; Console.WriteLine($"Received: {value}"),
			onError: static ex =&gt; Console.WriteLine($"Error: {ex.Message}"),
			onCompleted: static () =&gt; Console.WriteLine("Completed"),
			token: cts.Token
		);

		Console.WriteLine("Running...");
		Thread.Sleep(5000);
		Console.WriteLine("Program ended.");
	}
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Running...
Received: 0
Received: 1
Received: 2
Program ended.
</code></pre>
<hr>
<h2 id="3-使用场景总结"><strong>3. 使用场景总结</strong></h2>
<table>
<thead>
<tr>
<th><strong>使用方式</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>Subscribe</code> 返回 <code>IDisposable</code></strong></td>
<td>允许手动取消订阅</td>
<td>长时间订阅或频繁管理多个订阅</td>
</tr>
<tr>
<td><strong><code>Subscribe</code> 接受 <code>CancellationToken</code></strong></td>
<td>通过外部控制（如超时或用户交互）取消订阅</td>
<td>异步任务、超时控制、用户交互场景</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4-注意事项cancellationtoken-的局限性"><strong>4. 注意事项：CancellationToken 的局限性</strong></h2>
<p>虽然使用 <strong><code>CancellationToken</code></strong> 可以简化订阅管理，但也有一些需要注意的地方：</p>
<ol>
<li>
<p><strong>不支持手动取消</strong><br>
如果你使用的是返回 <code>IDisposable</code> 的 <code>Subscribe</code> 方法，你可以手动调用 <code>Dispose()</code> 取消订阅。但如果你使用带 <strong><code>CancellationToken</code></strong> 的重载，就无法通过 <code>Dispose()</code> 取消订阅。</p>
</li>
<li>
<p><strong>更适合一次性订阅</strong><br>
带 <strong><code>CancellationToken</code></strong> 的 <code>Subscribe</code> 重载更适合<strong>一次性订阅</strong>的场景。如果你需要频繁管理多个订阅，使用 <strong><code>CompositeDisposable</code></strong> 或手动管理 <code>IDisposable</code> 可能更合适。</p>
</li>
</ol>
<hr>
<h2 id="5-两种订阅方式的对比"><strong>5. 两种订阅方式的对比</strong></h2>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>返回 <code>IDisposable</code> 的 <code>Subscribe</code></strong></th>
<th><strong>带 <code>CancellationToken</code> 的 <code>Subscribe</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>是否支持手动取消订阅</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>是否支持外部控制订阅生命周期</td>
<td>❌ 需要手动调用 <code>Dispose()</code></td>
<td>✅ 通过 <code>CancellationToken</code> 控制</td>
</tr>
<tr>
<td>是否适合长期订阅</td>
<td>✅ 适合</td>
<td>❌ 更适合一次性订阅</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="6-subscribe-和-idisposable-的交互流程图"><strong>6. Subscribe 和 IDisposable 的交互流程图</strong></h2>
<div class="mermaid">sequenceDiagram
    participant Observer as IObserver&lt;T&gt;
    participant Observable as IObservable&lt;T&gt;
    participant IDisposable as IDisposable

    Observer -&gt;&gt; Observable: Subscribe()
    Observable -&gt;&gt; Observer: OnNext(T value)
    Observable -&gt;&gt; Observer: OnNext(T value)
    Observer -&gt;&gt; IDisposable: Dispose()
    Observable --&gt;&gt; Observer: 停止推送数据
</div><hr>
<h2 id="总结"><strong>总结</strong></h2>
<p>在本篇文章中，我们详细探讨了 <strong>Subscribe 和 IDisposable</strong> 的内部机制，并重点介绍了 <strong>带 <code>CancellationToken</code> 的 <code>Subscribe</code> 重载</strong>：</p>
<ol>
<li><strong><code>Subscribe()</code> 方法返回 <code>IDisposable</code></strong>，用于管理订阅的生命周期。</li>
<li><strong>不返回 <code>IDisposable</code> 的 <code>Subscribe</code> 重载</strong>，通过 <strong><code>CancellationToken</code></strong> 控制订阅的终止。</li>
<li><strong>使用场景不同</strong>：<code>IDisposable</code> 更适合长期订阅，<code>CancellationToken</code> 更适合一次性或外部控制的订阅。</li>
</ol>
<hr>
<h3 id="下一篇文章预告"><strong>下一篇文章预告</strong></h3>
<blockquote>
<p><strong>《.NET 响应式编程 System.Reactive 系列文章（四）：操作符基础》</strong><br>
下一篇文章将介绍 <strong>System.Reactive</strong> 的基础操作符，包括如何<strong>创建</strong>、<strong>转换</strong>和<strong>过滤</strong>数据流。我们将通过实战示例，帮助你快速掌握 Rx 的操作符使用方法。敬请期待！</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    作者：<a href="http://www.cnblogs.com/vallen/" target="_blank" title="VAllen">VAllen</a><br>出处：<a href="http://www.cnblogs.com/vallen" target="_blank" title="http://www.cnblogs.com/vallen">http://www.cnblogs.com/vallen</a><br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br><b>唯有偏执者得以生存。</b>
<img src="http://www.cnblogs.com/images/xml.gif" style="display:none;" onload="var s3=document.createElement('script');s3.text=decodeURIComponent(escape(window.atob('JCgiPGRpdiBjbGFzcz0nYmRzaGFyZWJ1dHRvbmJveCcgc3R5bGU9J21hcmdpbi10b3A6MTBweDsnPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfbW9yZScgZGF0YS1jbWQ9J21vcmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3F6b25lJyBkYXRhLWNtZD0ncXpvbmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RzaW5hJyBkYXRhLWNtZD0ndHNpbmEnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RxcScgZGF0YS1jbWQ9J3RxcSc+PC9hPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfcmVucmVuJyBkYXRhLWNtZD0ncmVucmVuJz48L2E+PGEgaHJlZj0nIycgY2xhc3M9J2Jkc193ZWl4aW4nIGRhdGEtY21kPSd3ZWl4aW4nPjwvYT48L2Rpdj4iKS5pbnNlcnRBZnRlcigiI015U2lnbmF0dXJlIik7d2luZG93Ll9iZF9zaGFyZV9jb25maWc9eyJjb21tb24iOnsiYmRTbnNLZXkiOnt9LCJiZFRleHQiOiIiLCJiZE1pbmkiOiIyIiwiYmRQaWMiOiIiLCJiZFN0eWxlIjoiMCIsImJkU2l6ZSI6IjMyIn0sInNoYXJlIjp7fSwiaW1hZ2UiOnsidmlld0xpc3QiOlsicXpvbmUiLCJ0c2luYSIsInRxcSIsInJlbnJlbiIsIndlaXhpbiJdLCJ2aWV3VGV4dCI6IuWIhuS6q+WIsO+8miIsInZpZXdTaXplIjoiMTYifSwic2VsZWN0U2hhcmUiOnsiYmRDb250YWluZXJDbGFzcyI6bnVsbCwiYmRTZWxlY3RNaW5pTGlzdCI6WyJxem9uZSIsInRzaW5hIiwidHFxIiwicmVucmVuIiwid2VpeGluIl19fTt3aXRoKGRvY3VtZW50KTBbKGdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF18fGJvZHkpLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKS5zcmM9J2h0dHA6Ly9iZGltZy5zaGFyZS5iYWlkdS5jb20vc3RhdGljL2FwaS9qcy9zaGFyZS5qcz92PTg5ODYwNTkzLmpzP2NkbnZlcnNpb249Jyt+KC1uZXcgRGF0ZSgpLzM2ZTUpXTs=')));s3.setAttribute('type','text/javascript');document.body.appendChild(s3);">
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.8994887199652775" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-09 00:43">2025-01-09 00:42</span>&nbsp;
<a href="https://www.cnblogs.com/VAllen">VAllen</a>&nbsp;
阅读(<span id="post_view_count">383</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18658778" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18658778);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18658778', targetLink: 'https://www.cnblogs.com/VAllen/p/18658778/rx-subscribe-idisposable', title: '.NET 响应式编程 System.Reactive 系列文章（三）：Subscribe 和 IDisposable 的深入理解' })">举报</a>
</div>
	