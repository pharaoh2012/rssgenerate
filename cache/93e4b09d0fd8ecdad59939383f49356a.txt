
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19062153" title="å‘å¸ƒäº 2025-08-28 10:37">
    <span role="heading" aria-level="2">ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP[æ¸²æŸ“è·¯å¾„]åº•å±‚æºç è§£æ</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250828104212575-485313448.png" alt="ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP[æ¸²æŸ“è·¯å¾„]åº•å±‚æºç è§£æ" class="desc_img">
        æœ¬æ–‡æ·±å…¥è§£æäº†Unity URPï¼ˆUniversal Render Pipelineï¼‰çš„æ¶æ„ä¸å®ç°æœºåˆ¶ã€‚URPåŸºäºSRPï¼ˆScriptable Render Pipelineï¼‰æ„å»ºï¼Œé€šè¿‡RenderPipelineåŸºç±»ã€ScriptableRenderContextç­‰æ ¸å¿ƒç»„ä»¶å®ç°å¯ç¼–ç¨‹æ¸²æŸ“ç®¡çº¿ã€‚æ–‡ç« è¯¦ç»†å‰–æäº†URPçš„åˆå§‹åŒ–æµç¨‹ã€æ¸²æŸ“é˜¶æ®µåˆ’åˆ†ï¼ˆå‡†å¤‡/å‡ ä½•/å…‰ç…§/å…‰æ …åŒ–/åå¤„ç†ï¼‰ä»¥åŠå…³é”®ä¼˜åŒ–æŠ€æœ¯ï¼ˆå¦‚SRP Batcherï¼‰ã€‚åŒæ—¶å¯¹æ¯”äº†URPä¸HDRPçš„åŒºåˆ«ï¼ŒåŒ…æ‹¬URPé‡‡ç”¨çš„ç®€åŒ–PBRæ¨¡å‹ã€è·¨å¹³å°é€‚é…ç­–ç•¥ç­‰ã€‚æœ€å
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘</a><strong>ä¸“æ -ç›´è¾¾</strong></p>
</blockquote>
<h1 id="srpæä¾›çš„æ ¸å¿ƒåŠŸèƒ½ä¸æ¶æ„"><strong>SRPæä¾›çš„æ ¸å¿ƒåŠŸèƒ½ä¸æ¶æ„â€Œ</strong></h1>
<h2 id="å¯ç¼–ç¨‹ç®¡çº¿åŸºç¡€">â€Œ<strong>å¯ç¼–ç¨‹ç®¡çº¿åŸºç¡€</strong>â€Œ</h2>
<h3 id="renderpipelineåŸºç±»">â€Œ<strong>RenderPipelineåŸºç±»</strong>â€Œ</h3>
<ul>
<li>é€šè¿‡ç»§æ‰¿è¯¥ç±»å¹¶é‡å†™<code>Render()</code>æ–¹æ³•ï¼Œå¼€å‘è€…å¯è‡ªå®šä¹‰æ¸²æŸ“æµç¨‹è°ƒåº¦é€»è¾‘ï¼Œæ›¿ä»£ä¼ ç»Ÿå›ºå®šç®¡çº¿ã€‚<em>ï¼ˆURPä¸­<code>UniversalRenderPipeline : RenderPipeline</code> ç»§æ‰¿å¹¶é‡å†™Renderæ–¹æ³•ã€‚ï¼‰</em></li>
</ul>
<h3 id="scriptablerendercontext">â€Œ<strong>ScriptableRenderContext</strong>â€Œ</h3>
<ul>
<li>ä½œä¸ºC#è„šæœ¬ä¸åº•å±‚å›¾å½¢APIçš„æ¡¥æ¢ï¼Œå…è®¸é€šè¿‡ä»£ç è°ƒåº¦æ¸²æŸ“å‘½ä»¤ï¼ˆå¦‚å‰”é™¤ã€ç»˜åˆ¶ï¼‰ã€‚<em>ï¼ˆ<code>public struct ScriptableRenderContext : IEquatable&lt;ScriptableRenderContext&gt;</code>å®šä¹‰<strong>è‡ªå®šä¹‰æ¸²æŸ“ç®¡é“</strong>ä½¿ç”¨çš„<strong>çŠ¶æ€</strong>å’Œ<strong>ç»˜å›¾å‘½ä»¤</strong>ã€‚ï¼‰</em></li>
</ul>
<h3 id="ç®¡çº¿èµ„æºåˆ†ç¦»æœºåˆ¶">â€Œ<strong>ç®¡çº¿èµ„æºåˆ†ç¦»æœºåˆ¶</strong>â€Œ</h3>
<ul>
<li><code>RenderPipelineAsset</code>ï¼šå­˜å‚¨é…ç½®æ•°æ®ï¼ˆå¦‚æè´¨ã€Shaderå‚æ•°ï¼‰<em>ï¼ˆURPä¸­æ˜¯<br>
<code>public partial class UniversalRenderPipelineAsset : RenderPipelineAsset, ISerializationCallbackReceiver</code>ï¼‰</em></li>
<li><code>RenderPipelineInstance</code>ï¼šæ‰§è¡Œå®é™…æ¸²æŸ“é€»è¾‘çš„å®ä¾‹ç±»ã€‚<em>ï¼ˆåœ¨URPä¸­ï¼Œä¸Šé¢çš„RenderPipelineAssetèµ„äº§ç±»ä¸­é‡å†™<code>protected override RenderPipeline CreatePipeline()</code>æ–¹æ³•ï¼Œåœ¨å…¶ä¸­åˆ›å»ºæ¸²æŸ“ç®¡çº¿å®ä¾‹<code>var pipeline = new UniversalRenderPipeline(this);</code>ï¼‰</em></li>
</ul>
<h2 id="å…³é”®æ‰©å±•ç‚¹">â€Œ<strong>å…³é”®æ‰©å±•ç‚¹</strong>â€Œ</h2>
<h3 id="äº‹ä»¶å›è°ƒ">â€Œ<strong>äº‹ä»¶å›è°ƒ</strong>â€Œ</h3>
<ul>
<li>é€šè¿‡<code>RenderPipelineManager</code>è®¢é˜…æ¸²æŸ“ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼ˆå¦‚<code>beginContextRendering</code>ï¼‰ï¼Œåœ¨ç‰¹å®šé˜¶æ®µæ³¨å…¥è‡ªå®šä¹‰é€»è¾‘ã€‚</li>
</ul>
<h3 id="åŠ¨æ€æ¸²æŸ“ç­–ç•¥">â€Œ<strong>åŠ¨æ€æ¸²æŸ“ç­–ç•¥</strong>â€Œ</h3>
<ul>
<li>æ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢æ¸²æŸ“è·¯å¾„ï¼ˆå¦‚æ­£å‘/å»¶è¿Ÿæ¸²æŸ“ï¼‰ï¼Œé€‚åº”ä¸åŒç¡¬ä»¶æ€§èƒ½éœ€æ±‚ï¼ˆè¿™é‡Œçš„æ¸²æŸ“è·¯å¾„æ˜¯URPæˆ–HDRPè‡ªå·±å®ç°çš„ï¼Œä¾‹å¦‚Forward+ä¹Ÿæ˜¯ï¼Œæ‰€ä»¥è¿™ä¸ªæ¸²æŸ“è·¯å¾„åªæ˜¯å®ç°ç®¡çº¿æ—¶çš„è‡ªå®šä¹‰æ¸²æŸ“ç­–ç•¥ï¼Œæ‰€ä»¥è¿è¡Œæ—¶èƒ½åˆ‡æ¢ã€‚ä½†æ˜¯ä¸€èˆ¬ä¸å»ºè®®åˆ‡æ¢ï¼Œå› ä¸ºå„ç§shaderå®ç°æ—¶éƒ½ä¼šæ ¹æ®æ¸²æŸ“è·¯å¾„å®ç°ç›¸åº”æ‰§è¡Œçš„Passï¼Œå¦‚æœéšä¾¿åˆ‡æ¢ï¼Œä¼šå¯¼è‡´éƒ¨åˆ†shaderå¯èƒ½å› ä¸ºåªé€‚é…æŸç§æ¸²æŸ“è·¯å¾„ï¼Œå¯¹å…¶ä»–æ¸²æŸ“è·¯å¾„æ˜¾ç¤ºæ¸²æŸ“å¼‚å¸¸ã€‚ï¼‰ã€‚</li>
</ul>
<h1 id="urpåœ¨srpä¸Šçš„å…·ä½“å®ç°"><strong>URPåœ¨SRPä¸Šçš„å…·ä½“å®ç°â€Œ</strong></h1>
<h2 id="èµ„æºä¸å®ä¾‹åˆå§‹åŒ–">â€Œ<strong>èµ„æºä¸å®ä¾‹åˆå§‹åŒ–</strong>â€Œ</h2>
<h3 id="urpç®¡çº¿èµ„æºuniversalrenderpipelineasset">â€Œ<strong>URPç®¡çº¿èµ„æº</strong>â€Œï¼ˆ<code>UniversalRenderPipelineAsset</code>ï¼‰ï¼š</h3>
<ul>
<li>å®šä¹‰é»˜è®¤Shaderã€å…‰ç…§æ¨¡å‹ã€åå¤„ç†æ ˆç­‰å‚æ•°ã€‚</li>
</ul>
<h3 id="å®ä¾‹åŒ–æµç¨‹">â€Œ<strong>å®ä¾‹åŒ–æµç¨‹</strong>â€Œï¼š</h3>
<ul>
<li>èµ„æºåˆ›å»ºæ—¶è°ƒç”¨<code>CreatePipeline()</code>ç”Ÿæˆ<code>UniversalRenderPipeline</code>å®ä¾‹ï¼Œæ¥ç®¡Unityæ¸²æŸ“å¾ªç¯ã€‚</li>
<li>å…¶ä¸­çš„æ¸²æŸ“å™¨åŸºç±»<code>ScriptableRenderer</code>ä½œä¸º æ¸²æŸ“å™¨å¯ä»¥ç”¨äºæ‰€æœ‰æ‘„åƒæœºï¼Œä¹Ÿå¯ä»¥åœ¨æ¯ä¸ªæ‘„åƒæœºçš„åŸºç¡€ä¸Šé‡å†™ã€‚å®ƒå°†å®ç°å…‰å‰”é™¤å’Œè®¾ç½®ï¼Œå¹¶æè¿°è¦åœ¨å¸§ä¸­æ‰§è¡Œçš„<code>ScriptableRenderPass</code>åˆ—è¡¨ã€‚æ¸²æŸ“å™¨å¯ä»¥é€šè¿‡é¢å¤–çš„<code>scriptablerendererfeature</code>è¿›è¡Œæ‰©å±•ï¼Œä»¥æ”¯æŒæ›´å¤šçš„æ•ˆæœã€‚æ¸²æŸ“å™¨çš„èµ„æºåœ¨<code>ScriptableRendererData</code>ä¸­åºåˆ—åŒ–ï¼ˆç¼–è¾‘å™¨ä¸­å°±åœ¨è¿™ä¸ªèµ„æºä¸ŠæŒ‚è½½è®¾ç½®RendererFeatureï¼‰ã€‚
<ul>
<li>
<p><code>UniversalRenderer</code> é»˜è®¤çš„3Dæ¸²æŸ“å™¨ç»§æ‰¿è‡ª<code>ScriptableRenderer</code>ã€‚åœ¨å…¶æ„é€ å‡½æ•°ä¸­<br>
<code>public UniversalRenderer(UniversalRendererData data) : base(data)</code> æ ¹æ®ä¸Šè¿°åºåˆ—åŒ–çš„Dataæ•°æ®ï¼Œåˆ›å»ºé»˜è®¤çš„æ¸²æŸ“Passé€»è¾‘ã€‚æ¸²æŸ“è·¯å¾„å°±æ˜¯åœ¨è¿™ä¸ªç±»æ–‡ä»¶ä¸­ä¸€åŒå®šä¹‰çš„ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­æ ¹æ®ä¸åŒè·¯å¾„ï¼Œç»™å‡ºä¸åŒç­–ç•¥æ‰§è¡ŒPassã€‚</p>
</li>
<li>
<p><strong>å®šä¹‰æ¸²æŸ“è·¯å¾„</strong></p>
<pre><code class="language-csharp">namespace UnityEngine.Rendering.Universal
{
    /// &lt;summary&gt;
    /// Rendering modes for Universal renderer.
    /// &lt;/summary&gt;
    public enum RenderingMode
    {
        /// &lt;summary&gt;Render all objects and lighting in one pass, with a hard limit on the number of lights that can be applied on an object.&lt;/summary&gt;
        Forward = 0,
        /// &lt;summary&gt;Render all objects and lighting in one pass using a clustered data structure to access lighting data.&lt;/summary&gt;
        [InspectorName("Forward+")]
        ForwardPlus = 2,
        /// &lt;summary&gt;Render all objects first in a g-buffer pass, then apply all lighting in a separate pass using deferred shading.&lt;/summary&gt;
        Deferred = 1
    };
    // çœç•¥ä¸‹é¢ä»£ç ã€‚ã€‚ã€‚
}
</code></pre>
</li>
<li>
<p><strong>æ„é€ å‡½æ•°æ ¹æ®æ¸²æŸ“è·¯å¾„ç»™å‡ºä¸åŒPassæ‰§è¡Œç­–ç•¥</strong></p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Constructor for the Universal Renderer.
/// &lt;/summary&gt;
/// &lt;param name="data"&gt;The settings to create the renderer with.&lt;/param&gt;
public UniversalRenderer(UniversalRendererData data) : base(data)
{
      // Query and cache runtime platform info first before setting up URP.
      PlatformAutoDetect.Initialize();
      ...
</code></pre>
<ul>
<li>
<p><strong>è®¾ç½®å„ç§æè´¨å’ŒçŠ¶æ€</strong></p>
<pre><code class="language-csharp">// è®¾ç½®å„ç§æè´¨å’ŒçŠ¶æ€

#if ENABLE_VR &amp;&amp; ENABLE_XR_MODULE
            Experimental.Rendering.XRSystem.Initialize(XRPassUniversal.Create, data.xrSystemData.shaders.xrOcclusionMeshPS, data.xrSystemData.shaders.xrMirrorViewPS);
#endif
            m_BlitMaterial = CoreUtils.CreateEngineMaterial(data.shaders.coreBlitPS);
            m_BlitHDRMaterial = CoreUtils.CreateEngineMaterial(data.shaders.blitHDROverlay);
            m_CopyDepthMaterial = CoreUtils.CreateEngineMaterial(data.shaders.copyDepthPS);
            m_SamplingMaterial = CoreUtils.CreateEngineMaterial(data.shaders.samplingPS);
            m_StencilDeferredMaterial = CoreUtils.CreateEngineMaterial(data.shaders.stencilDeferredPS);
            m_CameraMotionVecMaterial = CoreUtils.CreateEngineMaterial(data.shaders.cameraMotionVector);
            m_ObjectMotionVecMaterial = CoreUtils.CreateEngineMaterial(data.shaders.objectMotionVector);

            StencilStateData stencilData = data.defaultStencilState;
            m_DefaultStencilState = StencilState.defaultValue;
            m_DefaultStencilState.enabled = stencilData.overrideStencilState;
            m_DefaultStencilState.SetCompareFunction(stencilData.stencilCompareFunction);
            m_DefaultStencilState.SetPassOperation(stencilData.passOperation);
            m_DefaultStencilState.SetFailOperation(stencilData.failOperation);
            m_DefaultStencilState.SetZFailOperation(stencilData.zFailOperation);

            m_IntermediateTextureMode = data.intermediateTextureMode;

            if (UniversalRenderPipeline.asset?.supportsLightCookies ?? false)
            {
                var settings = LightCookieManager.Settings.Create();
                var asset = UniversalRenderPipeline.asset;
                if (asset)
                {
                    settings.atlas.format = asset.additionalLightsCookieFormat;
                    settings.atlas.resolution = asset.additionalLightsCookieResolution;
                }

                m_LightCookieManager = new LightCookieManager(ref settings);
            }

            this.stripShadowsOffVariants = true;
            this.stripAdditionalLightOffVariants = true;
#if ENABLE_VR &amp;&amp; ENABLE_VR_MODULE
#if PLATFORM_WINRT || PLATFORM_ANDROID
            // AdditionalLightOff variant is available on HL&amp;Quest platform due to performance consideration.
            this.stripAdditionalLightOffVariants = !PlatformAutoDetect.isXRMobile;
#endif
#endif
</code></pre>
</li>
<li>
<p><strong>Forwardå’ŒForward+ç¯å…‰å‡†å¤‡ï¼Œæ·±åº¦é¢„å¤„ç†ã€æ·±åº¦æ‹·è´æ¨¡å¼ç­‰è®¾ç½®ã€‚</strong></p>
<pre><code class="language-csharp">            ForwardLights.InitParams forwardInitParams;
            forwardInitParams.lightCookieManager = m_LightCookieManager;
            forwardInitParams.forwardPlus = data.renderingMode == RenderingMode.ForwardPlus;
            m_Clustering = data.renderingMode == RenderingMode.ForwardPlus;
            m_ForwardLights = new ForwardLights(forwardInitParams);
            //m_DeferredLights.LightCulling = data.lightCulling;
            this.m_RenderingMode = data.renderingMode;
            this.m_DepthPrimingMode = data.depthPrimingMode;
            this.m_CopyDepthMode = data.copyDepthMode;

#if UNITY_ANDROID || UNITY_IOS || UNITY_TVOS
            this.m_DepthPrimingRecommended = false;
#else
            this.m_DepthPrimingRecommended = true;
#endif

</code></pre>
</li>
<li>
<p>å…³é”®æ¥äº†ï¼URPå®šåˆ¶çš„æµç¨‹åœ¨è¿™é‡Œï¼ˆä»ç¯å…‰é˜´å½±æŠ•å°„ã€æ·±åº¦å’Œæ·±åº¦æ³•çº¿é¢„æ¸²æŸ“ã€åˆ°æ·±åº¦æ‹·è´ã€å»¶è¿Ÿæ¸²æŸ“ä¸­çš„ç‰¹åˆ«æ‰§è¡Œçš„LightModeï¼šâ€UniversalForwardOnlyâ€ã€å†åˆ°å»¶è¿Ÿæ¸²æŸ“çš„GBufferåŠå…¶å¯¹GBufferçš„å±å¹•ç©ºé—´çš„å…‰ç…§å¤„ç†ã€ä¸é€æ˜é˜¶æ®µPassã€æ·±åº¦æ‹·è´ã€è¿åŠ¨å‘é‡Passã€å¤©ç©ºç›’Passã€é€æ˜ç‰©ä½“Passã€ç¦»å±UIPassã€è¦†ç›–UIPassã€æœ€åçš„æ··åˆã€æ·±åº¦æ‹·è´ã€è¾“å‡ºåˆ°ç¼“å†²åŒºâ€œ_CameraColorAttachmentâ€ï¼‰</p>
<pre><code class="language-csharp">            // Note: Since all custom render passes inject first and we have stable sort,
            // we inject the builtin passes in the before events.
            m_MainLightShadowCasterPass = new MainLightShadowCasterPass(RenderPassEvent.BeforeRenderingShadows);
            m_AdditionalLightsShadowCasterPass = new AdditionalLightsShadowCasterPass(RenderPassEvent.BeforeRenderingShadows);

#if ENABLE_VR &amp;&amp; ENABLE_XR_MODULE
            m_XROcclusionMeshPass = new XROcclusionMeshPass(RenderPassEvent.BeforeRenderingOpaques);
            // Schedule XR copydepth right after m_FinalBlitPass
            m_XRCopyDepthPass = new CopyDepthPass(RenderPassEvent.AfterRendering + k_AfterFinalBlitPassQueueOffset, m_CopyDepthMaterial);
#endif
            m_DepthPrepass = new DepthOnlyPass(RenderPassEvent.BeforeRenderingPrePasses, RenderQueueRange.opaque, data.opaqueLayerMask);
            m_DepthNormalPrepass = new DepthNormalOnlyPass(RenderPassEvent.BeforeRenderingPrePasses, RenderQueueRange.opaque, data.opaqueLayerMask);

            if (renderingModeRequested == RenderingMode.Forward || renderingModeRequested == RenderingMode.ForwardPlus)
            {
                m_PrimedDepthCopyPass = new CopyDepthPass(RenderPassEvent.AfterRenderingPrePasses, m_CopyDepthMaterial, true);
            }

            if (this.renderingModeRequested == RenderingMode.Deferred)
            {
                var deferredInitParams = new DeferredLights.InitParams();
                deferredInitParams.stencilDeferredMaterial = m_StencilDeferredMaterial;
                deferredInitParams.lightCookieManager = m_LightCookieManager;
                m_DeferredLights = new DeferredLights(deferredInitParams, useRenderPassEnabled);
                m_DeferredLights.AccurateGbufferNormals = data.accurateGbufferNormals;

                m_GBufferPass = new GBufferPass(RenderPassEvent.BeforeRenderingGbuffer, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference, m_DeferredLights);
                // Forward-only pass only runs if deferred renderer is enabled.
                // It allows specific materials to be rendered in a forward-like pass.
                // We render both gbuffer pass and forward-only pass before the deferred lighting pass so we can minimize copies of depth buffer and
                // benefits from some depth rejection.
                // - If a material can be rendered either forward or deferred, then it should declare a UniversalForward and a UniversalGBuffer pass.
                // - If a material cannot be lit in deferred (unlit, bakedLit, special material such as hair, skin shader), then it should declare UniversalForwardOnly pass
                // - Legacy materials have unamed pass, which is implicitely renamed as SRPDefaultUnlit. In that case, they are considered forward-only too.
                // TO declare a material with unnamed pass and UniversalForward/UniversalForwardOnly pass is an ERROR, as the material will be rendered twice.
                StencilState forwardOnlyStencilState = DeferredLights.OverwriteStencil(m_DefaultStencilState, (int)StencilUsage.MaterialMask);
                ShaderTagId[] forwardOnlyShaderTagIds = new ShaderTagId[]
                {
                    new ShaderTagId("UniversalForwardOnly"),
                    new ShaderTagId("SRPDefaultUnlit"), // Legacy shaders (do not have a gbuffer pass) are considered forward-only for backward compatibility
                    new ShaderTagId("LightweightForward") // Legacy shaders (do not have a gbuffer pass) are considered forward-only for backward compatibility
                };
                int forwardOnlyStencilRef = stencilData.stencilReference | (int)StencilUsage.MaterialUnlit;
                m_GBufferCopyDepthPass = new CopyDepthPass(RenderPassEvent.BeforeRenderingGbuffer + 1, m_CopyDepthMaterial, true);
                m_DeferredPass = new DeferredPass(RenderPassEvent.BeforeRenderingDeferredLights, m_DeferredLights);
                m_RenderOpaqueForwardOnlyPass = new DrawObjectsPass("Render Opaques Forward Only", forwardOnlyShaderTagIds, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, forwardOnlyStencilState, forwardOnlyStencilRef);
            }

            // Always create this pass even in deferred because we use it for wireframe rendering in the Editor or offscreen depth texture rendering.
            m_RenderOpaqueForwardPass = new DrawObjectsPass(URPProfileId.DrawOpaqueObjects, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference);
            m_RenderOpaqueForwardWithRenderingLayersPass = new DrawObjectsWithRenderingLayersPass(URPProfileId.DrawOpaqueObjects, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference);

            bool copyDepthAfterTransparents = m_CopyDepthMode == CopyDepthMode.AfterTransparents;
            RenderPassEvent copyDepthEvent = copyDepthAfterTransparents ? RenderPassEvent.AfterRenderingTransparents : RenderPassEvent.AfterRenderingSkybox;

            m_CopyDepthPass = new CopyDepthPass(
                copyDepthEvent,
                m_CopyDepthMaterial,
                shouldClear: true,
                copyResolvedDepth: RenderingUtils.MultisampleDepthResolveSupported() &amp;&amp; SystemInfo.supportsMultisampleAutoResolve &amp;&amp; copyDepthAfterTransparents);

            // Motion vectors depend on the (copy) depth texture. Depth is reprojected to calculate motion vectors.
            m_MotionVectorPass = new MotionVectorRenderPass(copyDepthEvent + 1, m_CameraMotionVecMaterial, m_ObjectMotionVecMaterial, data.opaqueLayerMask);

            m_DrawSkyboxPass = new DrawSkyboxPass(RenderPassEvent.BeforeRenderingSkybox);
            m_CopyColorPass = new CopyColorPass(RenderPassEvent.AfterRenderingSkybox, m_SamplingMaterial, m_BlitMaterial);
#if ADAPTIVE_PERFORMANCE_2_1_0_OR_NEWER
            if (needTransparencyPass)
#endif
            {
                m_TransparentSettingsPass = new TransparentSettingsPass(RenderPassEvent.BeforeRenderingTransparents, data.shadowTransparentReceive);
                m_RenderTransparentForwardPass = new DrawObjectsPass(URPProfileId.DrawTransparentObjects, false, RenderPassEvent.BeforeRenderingTransparents, RenderQueueRange.transparent, data.transparentLayerMask, m_DefaultStencilState, stencilData.stencilReference);
            }
            m_OnRenderObjectCallbackPass = new InvokeOnRenderObjectCallbackPass(RenderPassEvent.BeforeRenderingPostProcessing);

            m_DrawOffscreenUIPass = new DrawScreenSpaceUIPass(RenderPassEvent.BeforeRenderingPostProcessing, true);
            m_DrawOverlayUIPass = new DrawScreenSpaceUIPass(RenderPassEvent.AfterRendering + k_AfterFinalBlitPassQueueOffset, false); // after m_FinalBlitPass

            {
                var postProcessParams = PostProcessParams.Create();
                postProcessParams.blitMaterial = m_BlitMaterial;
                postProcessParams.requestHDRFormat = GraphicsFormat.B10G11R11_UFloatPack32;
                var asset = UniversalRenderPipeline.asset;
                if (asset)
                    postProcessParams.requestHDRFormat = UniversalRenderPipeline.MakeRenderTextureGraphicsFormat(asset.supportsHDR, asset.hdrColorBufferPrecision, false);

                m_PostProcessPasses = new PostProcessPasses(data.postProcessData, ref postProcessParams);
            }

            m_CapturePass = new CapturePass(RenderPassEvent.AfterRendering);
            m_FinalBlitPass = new FinalBlitPass(RenderPassEvent.AfterRendering + k_FinalBlitPassQueueOffset, m_BlitMaterial, m_BlitHDRMaterial);

#if UNITY_EDITOR
            m_FinalDepthCopyPass = new CopyDepthPass(RenderPassEvent.AfterRendering + 9, m_CopyDepthMaterial);
#endif

            // RenderTexture format depends on camera and pipeline (HDR, non HDR, etc)
            // Samples (MSAA) depend on camera and pipeline
            m_ColorBufferSystem = new RenderTargetBufferSystem("_CameraColorAttachment");
</code></pre>
</li>
<li>
<p><strong>æœ€åæœ€ä¸€äº›å…¼å®¹æ“ä½œï¼Œç»“æŸæ„é€ ã€‚å®ŒæˆURPåŸºæœ¬ç®¡çº¿çš„ä¸»ä½“æµç¨‹ã€‚</strong></p>
<pre><code class="language-csharp">supportedRenderingFeatures = new RenderingFeatures();

            if (this.renderingModeRequested == RenderingMode.Deferred)
            {
                // Deferred rendering does not support MSAA.
                this.supportedRenderingFeatures.msaa = false;

                // Avoid legacy platforms: use vulkan instead.
                unsupportedGraphicsDeviceTypes = new GraphicsDeviceType[]
                {
                    GraphicsDeviceType.OpenGLCore,
                    GraphicsDeviceType.OpenGLES2,
                    GraphicsDeviceType.OpenGLES3
                };
            }

            LensFlareCommonSRP.mergeNeeded = 0;
            LensFlareCommonSRP.maxLensFlareWithOcclusionTemporalSample = 1;
            LensFlareCommonSRP.Initialize();

            m_VulkanEnablePreTransform = GraphicsSettings.HasShaderDefine(BuiltinShaderDefine.UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION);
        }
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="æ ¸å¿ƒæ¸²æŸ“æµç¨‹åˆ†è§£">â€Œ<strong>æ ¸å¿ƒæ¸²æŸ“æµç¨‹åˆ†è§£</strong>â€Œ</h3>
<p>URPå°†æ¸²æŸ“åˆ†ä¸ºäº”ä¸ªé˜¶æ®µï¼Œå‡åœ¨<code>Render()</code>æ–¹æ³•ä¸­è°ƒåº¦ï¼š</p>
<table>
<thead>
<tr>
<th>â€Œ<strong>é˜¶æ®µ</strong>â€Œ</th>
<th>â€Œ<strong>URPå®ç°ç»†èŠ‚</strong>â€Œ</th>
</tr>
</thead>
<tbody>
<tr>
<td>â€Œ<strong>å‡†å¤‡é˜¶æ®µ</strong>â€Œ</td>
<td>æ”¶é›†åœºæ™¯æ¸²æŸ“å¯¹è±¡ä¸å…‰æºæ•°æ®ï¼Œé…ç½®ç›¸æœºå‚æ•°ä¸ç›®æ ‡çº¹ç†ã€‚</td>
</tr>
<tr>
<td>â€Œ<strong>å‡ ä½•é˜¶æ®µ</strong>â€Œ</td>
<td>æ‰§è¡Œè§†é”¥å‰”é™¤ï¼Œç”ŸæˆGPUé¡¶ç‚¹æ•°æ®ï¼›é€šè¿‡<code>ScriptableRenderContext.DrawRenderers</code>æäº¤ç»˜åˆ¶å‘½ä»¤ã€‚</td>
</tr>
<tr>
<td>â€Œ<strong>å…‰ç…§é˜¶æ®µ</strong>â€Œ</td>
<td>é‡‡ç”¨ç®€åŒ–PBRæ¨¡å‹ï¼šè®¡ç®—å®æ—¶å…‰æºè´¡çŒ®ï¼Œæ”¯æŒçƒ˜ç„™å…‰ç…§æ··åˆï¼›åŠ¨æ€å…‰æºé‡‡ç”¨Tile-Basedä¼˜åŒ–ç­–ç•¥ï¼ˆForward+è·¯å¾„æ—¶ï¼‰ã€‚</td>
</tr>
<tr>
<td>â€Œ<strong>å…‰æ …åŒ–é˜¶æ®µ</strong>â€Œ</td>
<td>æ‰§è¡Œæ·±åº¦é¢„é€šé“ï¼ˆDepth Prepassï¼‰å‡å°‘è¿‡åº¦ç»˜åˆ¶ï¼Œç»“åˆGPU Instancingä¼˜åŒ–æ‰¹æ¬¡å¤„ç†ã€‚</td>
</tr>
<tr>
<td>â€Œ<strong>åå¤„ç†é˜¶æ®µ</strong>â€Œ</td>
<td>åœ¨ç‹¬ç«‹Passä¸­åº”ç”¨æŠ—é”¯é½¿ï¼ˆFXAA/TAAï¼‰ã€Bloomç­‰æ•ˆæœï¼Œæ”¯æŒ<strong>è‡ªå®šä¹‰RendererFeatureæ‰©å±•</strong>ã€‚</td>
</tr>
</tbody>
</table>
<h3 id="æ€§èƒ½ä¼˜åŒ–å…³é”®æŠ€æœ¯">â€Œ<strong>æ€§èƒ½ä¼˜åŒ–å…³é”®æŠ€æœ¯</strong>â€Œ</h3>
<ul>
<li>â€Œ<strong>SRP Batcher</strong>â€Œï¼šå¯¹ç›¸åŒShaderå˜ä½“ä½†ä¸åŒæè´¨çš„ç‰©ä½“è¿›è¡ŒåŠ¨æ€åˆæ‰¹ï¼Œæ˜¾è‘—é™ä½SetPass Callã€‚</li>
<li>â€Œ<strong>å…‰ç…§å‰”é™¤ä¼˜åŒ–</strong>â€Œï¼šæŒ‰å±‚çº§æ§åˆ¶å‰”é™¤è·ç¦»ï¼ˆ<code>layerCullDistances</code>ï¼‰ï¼Œå¯¹é™æ€ç‰©ä½“é¢„è®¡ç®—é®æŒ¡æ•°æ®ã€‚</li>
</ul>
<h3 id="urpå¯¹srpçš„æ‰©å±•ä¸ç®€åŒ–"><strong>URPå¯¹SRPçš„æ‰©å±•ä¸ç®€åŒ–â€Œ</strong></h3>
<ul>
<li>â€Œ<strong>æ ‡å‡†åŒ–åŠŸèƒ½å°è£…</strong>â€Œ
<ul>
<li>å†…ç½®è½»é‡çº§PBRå…‰ç…§æ¨¡å‹ï¼Œå–ä»£HDRPçš„å¤æ‚ç‰©ç†æ¨¡æ‹Ÿä»¥æå‡è·¨å¹³å°æ€§èƒ½ã€‚</li>
<li>é›†æˆâ€Œ<strong>Shader Graph</strong>â€Œå¯è§†åŒ–å·¥å…·é“¾ï¼Œé™ä½ç€è‰²å™¨å¼€å‘é—¨æ§›ã€‚ï¼ˆåæœŸç‰ˆæœ¬å†…ç½®ç®¡çº¿ä¹Ÿå¯ç”¨ShaderGraphäº†ï¼‰</li>
</ul>
</li>
<li>â€Œ<strong>è·¨å¹³å°é€‚é…ç­–ç•¥</strong>â€Œ
<ul>
<li>åŠ¨æ€åˆ‡æ¢æ¸²æŸ“ç²¾åº¦ï¼ˆå¦‚ç§»åŠ¨ç«¯ç¦ç”¨å®æ—¶é˜´å½±ï¼‰ï¼Œé€šè¿‡<code>QualitySettings</code>åˆ†çº§é…ç½®ã€‚</li>
<li>èµ„æºåŒ…ç²¾ç®€ï¼šå‰”é™¤HDRPçš„é«˜ç²¾åº¦è´´å›¾ä¸è®¡ç®—å¯†é›†å‹ç‰¹æ•ˆï¼Œç¼©å°è¿è¡Œæ—¶å†…å­˜å ç”¨ã€‚</li>
</ul>
</li>
</ul>
<h3 id="å¯¹urpçš„æ‰©å±•">å¯¹URPçš„æ‰©å±•</h3>
<ul>
<li>URPåŸºæœ¬ç®¡çº¿æµç¨‹åœ¨<code>UniversalRenderer</code>çš„æ„é€ å‡½æ•°ä¸­å·²ç»å®šä¹‰å®Œæ•´ã€‚å¹¶ä¸”åœ¨å…¶ä¸­æ¯ä¸ªé˜¶æ®µéƒ½ç»™å‡ºäº†æ’å…¥ç‚¹ã€‚é‚£ä¹ˆåªéœ€è¦åœ¨è¿™äº›æ’å…¥ç‚¹ç”¨åˆ›å»ºRendererFeatureçš„æ–¹å¼æ’å…¥è‡ªå®šä¹‰çš„Passæ¥å½±å“å’Œæ‰©å……åŸºæœ¬çš„URPç®¡çº¿ã€‚</li>
<li>è¿˜æœ‰ä¸€ç§æ–¹å¼ç”¨<code>RenderPipelineManager</code> æä¾›çš„ç‚¹ä½æ’å…¥è‡ªå®šä¹‰Passã€‚</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘</a><strong>ä¸“æ -ç›´è¾¾</strong></p>
</blockquote>
<p>ï¼ˆæ¬¢è¿<em>ç‚¹èµç•™è¨€</em>æ¢è®¨ï¼Œæ›´å¤šäººåŠ å…¥è¿›æ¥èƒ½æ›´åŠ å®Œå–„è¿™ä¸ªæ¢ç´¢çš„è¿‡ç¨‹ï¼ŒğŸ™ï¼‰</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004166666666666667" data-date-updated="2025-08-28 10:43">2025-08-28 10:37</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
é˜…è¯»(<span id="post_view_count">0</span>)&nbsp;
è¯„è®º(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19062153);return false;">æ”¶è—</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19062153', targetLink: 'https://www.cnblogs.com/SmalBox/p/19062153', title: 'ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP[æ¸²æŸ“è·¯å¾„]åº•å±‚æºç è§£æ' })">ä¸¾æŠ¥</a>
</div>
        