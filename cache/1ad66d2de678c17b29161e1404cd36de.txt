
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18886761" title="发布于 2025-05-20 13:53">
    <span role="heading" aria-level="2">Redisson读写锁和分布式锁的项目实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="问题1在修改分组时有短链接正在访问会出现什么问题怎么解决">问题1:在修改分组时,有短链接正在访问会出现什么问题?怎么解决</h2>
<ul>
<li>假设:现有线程A正在修改短链a的分组gid1为gid2(还未修改成功)</li>
<li>同时有一个线程B获取了短链a分组gid1,要进行统计pv,uv,uip操作时.发现gid1已经不存在了,就会发生并发问题</li>
</ul>
<h2 id="解决方案采用读写锁">解决方案:采用读写锁</h2>
<h3 id="什么是读写锁">什么是读写锁</h3>
<blockquote>
<p>Redisson读写锁是一种基于Redis实现特殊的机制,用于在分布式系统中协调对共享资源的访问,其继承了Java中的<code>ReentrantReadWriteLock</code>的思想.特别适用于读多写少的场景.<strong>其核心是:允许多个线程同时读取共享资源,但写操作必须占用资源</strong>.从而保证线程安全的同时提高并发性能</p>
</blockquote>
<ul>
<li>十分适合短链更新时:当某个线程需要更新资源时→需要获取写锁.此时所有的读操作和其他写线程会被阻塞,保证数据的一致性</li>
</ul>
<h1 id="核心原理">核心原理</h1>
<h3 id="读锁共享锁">读锁(共享锁):</h3>
<ul>
<li>共享性:允许多个线程同时持有读锁</li>
<li>互斥性:只要存在读锁,该线程就不能获取写锁</li>
</ul>
<h3 id="写锁排他锁">写锁(排他锁):</h3>
<ul>
<li>独占性:同一时刻只能占有一个线程持有写锁</li>
<li>互斥性:当一个线程获取了写锁,其他线程就无法同时获取写锁和读锁.写锁占用线程修改共享资源,确保了在修改时没有其他线程访问</li>
</ul>
<h3 id="基本代码结构如下">基本代码结构如下:</h3>
<pre><code class="language-java">RReadWriteLock configLock = redisson.getReadWriteLock("configLock");
// 读配置
configLock.readLock().lock();
try {
    return loadConfigFromCache();
} finally {
    configLock.readLock().unlock();
}
// 写配置
configLock.writeLock().lock();
try {
    updateConfigInDB();
    refreshCache();
} finally {
    configLock.writeLock().unlock();
}
</code></pre>
<h1 id="分布式锁redisson">分布式锁Redisson</h1>
<ul>
<li>为防止缓存击穿→大量并发请求同时查询一个失效的缓存，导致数据库压力骤增</li>
<li>通过 Redisson 的 <code>RLock</code>(分布式锁)确保同一时刻只有一个线程执行数据库查询操作</li>
</ul>
<h2 id="双重检查锁重建缓存">双重检查锁→重建缓存</h2>
<h3 id="双重检查流程"><strong>双重检查流程</strong></h3>
<ol>
<li><strong>第一次检查-无锁</strong>：
<ul>
<li><strong>未在代码中显式体现</strong>：通常在实际业务中，外层会先尝试从缓存读取数据。如果缓存命中，直接返回数据，无需加锁。此处代码直接处理未命中场景，可能外层已进行第一次检查。</li>
<li><strong>假设场景</strong>：当缓存未命中时，请求进入加锁逻辑。</li>
</ul>
</li>
<li><strong>加锁后第二次检查-关键</strong>：
<ul>
<li>在获取分布式锁后，<strong>再次检查缓存-</strong><code>stringRedisTemplate.opsForValue().get</code>。</li>
<li><strong>目的:</strong>确保在等待锁的过程中，其他线程可能已经更新了缓存，避免重复查询数据库。</li>
</ul>
</li>
</ol>
<h2 id="缓存穿透和缓存击穿解决方法">缓存穿透和缓存击穿解决方法</h2>
<ul>
<li>流程图如下:</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202505/3423316-20250520135130478-454749052.png" alt="" loading="lazy"></p>
<ul>
<li>布隆过滤器+缓存空值+redisson锁</li>
<li>缓存空值的操作对布隆过滤器误判操作进行保护→防止穿透</li>
<li>redisson锁操作对大量空值同时过期操作进行保护→防止击穿</li>
</ul>
<pre><code class="language-java">RLock lock = redissonClient.getLock(String.format(LOCK_SHORT_LINK_GOTO_KEY, fullShortUrl));
        // 加锁
        lock.lock();
        try {
            // 再次查询缓存
            String originalUrl = stringRedisTemplate.opsForValue().get(String.format(GOTO_SHORT_LINK_KEY, fullShortUrl));
            // 如果缓存中不存在，则查询数据库
            if (StrUtil.isBlank(originalUrl)) {

                //查询goto表
                LambdaQueryWrapper&lt;ShortLinkGotoDO&gt; linkGotoQueryWrapperqueryWrapper = Wrappers.lambdaQuery(ShortLinkGotoDO.class)
                        .eq(ShortLinkGotoDO::getFullShortUrl, fullShortUrl);

                ShortLinkGotoDO shortLinkGotoDO = shortLinkGotoMapper.selectOne(linkGotoQueryWrapperqueryWrapper);

                if (shortLinkGotoDO == null) {
                    //进行风控解决缓存穿透问题-&gt;设为空值
                    stringRedisTemplate.opsForValue().set(String.format(SHORT_LINK_IS_NULL_KEY, fullShortUrl), "-", 30, TimeUnit.MINUTES);
                    resp.sendRedirect("/page/notfound");
                    return;
                }

                //查询短链接表获取originUrl
                LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
                        .eq(ShortLinkDO::getGid, shortLinkGotoDO.getGid())
                        .eq(ShortLinkDO::getFullShortUrl, fullShortUrl)
                        .eq(ShortLinkDO::getEnableStatus, 0);

                ShortLinkDO shortLinkDO = baseMapper.selectOne(queryWrapper);

                //数据库中不存在或者短链接已经过期则跳转404页面
                if (shortLinkDO == null || (shortLinkDO.getValidDate() != null &amp;&amp; shortLinkDO.getValidDate().before(new Date()))) {
                    //短链接已经过期
                    stringRedisTemplate.opsForValue().set(String.format(SHORT_LINK_IS_NULL_KEY, fullShortUrl), "-", 30, TimeUnit.MINUTES);
                    resp.sendRedirect("/page/notfound");
                    return;
                }

                // 缓存原始链接
                stringRedisTemplate.opsForValue().set(String.format(GOTO_SHORT_LINK_KEY, fullShortUrl), shortLinkDO.getOriginUrl());

                //预热缓存
                stringRedisTemplate.opsForValue().set(
                        String.format(GOTO_SHORT_LINK_KEY, fullShortUrl),
                        shortLinkDO.getOriginUrl(),
                        LinkUtil.getShortLintCacheValidDate(shortLinkDO.getValidDate()),
                        TimeUnit.MILLISECONDS);

                // 访问统计
                shortLinkAccessStats(fullShortUrl, shortLinkDO.getGid(), req, resp);
                // 跳转
                resp.sendRedirect(shortLinkDO.getOriginUrl());
            }
        } finally {
            lock. Unlock();
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5197642901805556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-20 13:53">2025-05-20 13:53</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">128</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18886761);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18886761', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18886761', title: 'Redisson读写锁和分布式锁的项目实践' })">举报</a>
</div>
        