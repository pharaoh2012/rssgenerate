
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/iofomo/p/18687672" title="发布于 2025-01-23 13:51">
    <span role="heading" aria-level="2">Android平台从上到下，无需ROOT/解锁/刷机，应用级拦截框架的最后一环，SVC系统调用拦截。</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Android平台从上到下，无需ROOT/解锁/刷机，应用级拦截框架的最后一环，SVC系统调用拦截。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><code>Android</code>平台从上到下，无需ROOT/解锁/刷机，应用级拦截框架的最后一环 —— <code>SVC</code>系统调用拦截。</p>
</blockquote>
<p><a href="https://www.github.com/iofomo/abyss" target="_blank" rel="noopener nofollow">☞ Github: https://www.github.com/iofomo/abyss ☜</a>　</p>
<p><img src="https://img2024.cnblogs.com/blog/3369535/202501/3369535-20250123135036124-244677982.png" alt="" loading="lazy"></p>
<p>由于我们虚拟化产品的需求，需要支持在普通的<code>Android</code>手机运行。我们需要搭建覆盖应用从上到下各层的应用级拦截框架，而<code>Abyss</code>作为系统<code>SVC</code>指令的调用拦截，是我们最底层的终极方案。</p>
<p>源码位置：<a href="https://github.com/iofomo/abyss/tree/main/svcer" target="_blank" rel="noopener nofollow">https://github.com/iofomo/abyss/tree/main/svcer</a></p>
<h2 id="01--说明">01.  说明</h2>
<p><strong>Seccomp（Secure Computing Mode）：</strong></p>
<p><code>Seccomp</code> 是 <code>Linux</code> 内核的一个安全特性，用于限制进程可以执行的系统调用。它通过过滤系统调用，防止恶意程序执行危险操作。<code>Seccomp</code> 通常与 <code>BPF</code> 结合使用，以实现更灵活的过滤规则。</p>
<p><strong>BPF（Berkeley Packet Filter）：</strong></p>
<p><code>BPF</code> 是一种内核技术，最初用于网络数据包过滤，但后来被扩展用于更广泛的用途，包括系统调用过滤。<code>BPF</code> 程序可以在内核中运行，用于检查和过滤系统调用。</p>
<h2 id="02--主要流程">02.  主要流程</h2>
<p>首先，配置 <code>BPF</code> 规则，如下我们配置了目标系统调用号的拦截规则，不在这个名单内的就放过，这样可以实现仅拦截我们关心的系统调用（即函数），提升拦截效率和稳定性。</p>
<pre><code class="language-c">static void doInitSyscallNumberFilter(struct sock_filter* filter, unsigned short&amp; i) {
    // Load syscall number into accumulator
    filter[i++] = BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr)));
    // config target syscall
    // add more syscall here ...
//    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_openat, 5, 0);
//    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_getcwd, 4, 0);
//    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_chdir, 3, 0);
//    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_execve, 2, 0);
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_openat, 1, 0);

    filter[i++] = BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
}
</code></pre>
<p>然后，我们需要过滤掉一些系统库和自身库，防止写入死循环。</p>
<ul>
<li>自身实现库的过滤【必须】</li>
<li><code>vdso</code> 的过滤【必须】</li>
<li><code>linker</code> 的过滤【可选，提效】</li>
<li><code>libc</code> 的过滤【可选，提效】</li>
</ul>
<p>通过解析进程 <code>maps</code> 中对应库地址区间，配置跳过此区间的系统调用规则。</p>
<pre><code class="language-c">static void doInitSyscallLibFilterByAddr(struct sock_filter* filter, unsigned short&amp; i, const uintptr_t&amp; start, const uintptr_t&amp; end) {
    // Load syscall lib into accumulator
#if defined(__arm__)
    filter[i++] = BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer));
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, start, 0, 2);
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, end, 1, 0);
    filter[i++] = BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
#else // __aarch64__
    filter[i++] = BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, instruction_pointer) + 4));
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, (uint32_t)(start &gt;&gt; 32), 0, 4);
    filter[i++] = BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, instruction_pointer)));
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, (uint32_t)start, 0, 2);
    filter[i++] = BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, (uint32_t)end, 1, 0);
    filter[i++] = BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
#endif
}
</code></pre>
<p>其次，应用以上配置。</p>
<pre><code class="language-c">struct sigaction act = { 0 };
act.sa_flags = SA_SIGINFO | SA_NODEFER;
act.sa_sigaction = handleSignalAction;
struct sigaction old_sa = {};

ret = sigaction(SIGSYS, &amp;act, &amp;old_sa);
if (0 != ret) {
    LOGSVCE("sigaction: %d, %d, %s", ret, errno, strerror(errno))
    ::free(filter);
    __ASSERT(0)
    return -11;
}

// Unmask SIGSYS
sigset_t mask;
if (sigemptyset(&amp;mask) || sigaddset(&amp;mask, SIGSYS) ||
    sigprocmask(SIG_UNBLOCK, &amp;mask, nullptr)
    ) {
    LOGSVCE("sigprocmask: %d, %d, %s", ret, errno, strerror(errno))
    ::free(filter);
    __ASSERT(0)
    return -12;
}

struct sock_fprog prog = {
    .len = filterCount,
    .filter = filter,
};

// set to self process
ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
if (0 != ret) {
    LOGSVCE("PR_SET_NO_NEW_PRIVS: %d, %d, %s", ret, errno, strerror(errno))
    ::free(filter);
    __ASSERT(0)
    return -13;
}

// set seccomp to kernel
ret = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);
if (0 != ret) {
    LOGSVCE("PR_SET_SECCOMP: %d, %d, %s", ret, errno, strerror(errno))
    ::free(filter);
    __ASSERT(0)
    return -14;
}
</code></pre>
<p>最后，实现拦截后的处理。</p>
<pre><code class="language-c">static void handleSignalAction(int signo, siginfo_t* info, void* context) {
    if (!info || !context || signo != SIGSYS || info-&gt;si_code != SYS_SECCOMP) {
        LOGSVCW("signal: signo=%d, code=%d, errno=%d, call_addr=%p, arch=0x%x, syscall=0x%x,%s",
              info-&gt;si_signo, info-&gt;si_code, info-&gt;si_errno, info-&gt;si_call_addr, info-&gt;si_arch,
              info-&gt;si_syscall, SvcerDumper::index2name(info-&gt;si_syscall)
              )
        return;
    }

    ucontext_t *uc = reinterpret_cast&lt;ucontext_t *&gt;(context);
  
    intptr_t rc = SvcerSyscall::Call(SECCOMP_SYSCALL(uc),
                                   SECCOMP_PARM1(uc),
                                   SECCOMP_PARM2(uc),
                                   SECCOMP_PARM3(uc),
                                   SECCOMP_PARM4(uc),
                                   SECCOMP_PARM5(uc),
                                   SECCOMP_PARM6(uc)
    );
    SvcerSyscall::PutValueInUcontext(rc, uc);
}
</code></pre>
<h2 id="03--封装">03.  封装</h2>
<p>为了使用方便，封装了一些基础系统调用的日志打印接口。</p>
<p>1）添加要拦截的系统调用号。（日常日志打印）</p>
<pre><code class="language-c++">SvcerDumper::addDump(SVCER_SYSCALL_execve);
SvcerDumper::addDump(SVCER_SYSCALL_execveat);
SvcerDumper::addDump(SVCER_SYSCALL_open);
SvcerDumper::addDump(SVCER_SYSCALL_openat);
SvcerDumper::addAll();

SvcerHooker::init(ESvcerHookerMode_IgnoreAll, "libifmamts.so");
</code></pre>
<p>2）注册要拦截的系统调用回调。</p>
<pre><code class="language-c++">// 这里注册
for (int i=SVCER_SYSCALL_None; i&lt;SVCER_SYSCALL_Max; ++i) {
    SvcerHooker::registerCallback((TSVCER_SYSCALL_Type)i, handleSvcerHookerCallback);
}

// 这里实现

static void handleKonkerSvcerHookerCallback(int sn, SvcerHookerArgument* arg/*Not NULL*/) {
    switch (sn) {
    case __NR_statfs:// int statfs(const char* path, struct statfs* result);
    case __NR_truncate:// typedef int truncate(const char *filename, off_t len);
    case __NR_chdir:// int chdir(const char *path);
    {
        const char* pathname = (const char*)arg-&gt;getArgument1();
        char memString[512];
        if (memString == KonkerFixer::fixDataPath(pathname, memString)) {
            LOGSVCI("fixer, %s: %s", SvcerDumper::index2name(sn), __PRINTSTR(pathname))
            arg-&gt;setArgument1((intptr_t)memString);
        }
        arg-&gt;doSyscall();
        return;
    }
    default:
        LOGSVCI("ignore, %s", SvcerDumper::index2name(sn))
        break;
    }
    arg-&gt;doSyscall();
}
</code></pre>
<p>3）初始化</p>
<pre><code class="language-c++">// 设置要过滤的库和当前自身库名称
SvcerHooker::init(ESvcerHookerMode_IgnoreVdso|ESvcerHookerMode_IgnoreLibc|ESvcerHookerMode_IgnoreLinker, "libdemo.so");
</code></pre>
<h2 id="04--附">04.  附</h2>
<p><strong>额外模块：</strong></p>
<p>本框架实现了最基本的检测仿真，如通过 <code>__NR_rt_sigaction</code> 和 <code>__NR_prctl</code> 获取配置时，会对返回值进行还原。</p>
<p><strong>参考项目：</strong></p>
<p><a href="https://github.com/proot-me/proot" target="_blank" rel="noopener nofollow">https://github.com/proot-me/proot</a></p>
<p><a href="https://github.com/termux/proot" target="_blank" rel="noopener nofollow">https://github.com/termux/proot</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.019827104186342592" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 13:51">2025-01-23 13:51</span>&nbsp;
<a href="https://www.cnblogs.com/iofomo">iofomo</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18687672" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18687672);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18687672', targetLink: 'https://www.cnblogs.com/iofomo/p/18687672', title: 'Android平台从上到下，无需ROOT/解锁/刷机，应用级拦截框架的最后一环，SVC系统调用拦截。' })">举报</a>
</div>
        