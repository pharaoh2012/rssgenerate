
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18634364" title="发布于 2024-12-26 23:03">
    <span role="heading" aria-level="2">JVM实战—2.JVM内存设置与对象分配流转</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="1" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="2"><strong>1.JVM内存划分的原理细节</strong></p>
<p data-track="3"><strong>2.对象在JVM内存中如何分配如何流转</strong></p>
<p data-track="4"><strong>3.部署线上系统时如何设置JVM内存大小</strong></p>
<p data-track="5"><strong>4.如何设置JVM堆内存大小</strong></p>
<p data-track="6"><strong>5.如何设置JVM栈内存与永久代大小</strong></p>
<p data-track="7"><strong>6.问题汇总</strong></p>
<p data-track="8">&nbsp;</p>
<p data-track="9"><strong>1.JVM内存划分的原理细节</strong></p>
<p data-track="10"><strong>(1)背景引入</strong></p>
<p data-track="11"><strong>(2)大部分对象的存活周期都是极短的</strong></p>
<p data-track="12"><strong>(3)少数对象是长期存活的</strong></p>
<p data-track="13"><strong>(4)JVM分代模型：新生代和老年代</strong></p>
<p data-track="14"><strong>(5)为什么要分成新生代和老年代</strong></p>
<p data-track="15"><strong>(6)什么是永久代</strong></p>
<p data-track="16">&nbsp;</p>
<p data-track="17"><strong>(1)背景引入</strong></p>
<p data-track="18">接下来介绍JVM内存的分代模型：新生代、老年代、永久代。现在已知代码里创建的对象，都会进入到Java堆内存中。如下所示，main()方法会周期性执行loadReplicasFromDisk()方法来加载副本数据。</p>
<pre class="highlighter-hljs"><code>public class Kafka {
    public static void main(String[] args) {
        while (true) {
            loadReplicasFromDisk();
            Thread.sleep(1000);
        }
    }
    
    private static void loadReplicasFromDisk() {
        ReplicaManager replicaManager = new ReplicaManager();
        replicaManager.load();
    }
}</code></pre>
<p data-track="20">一.首先执行main()方法，就会把其栈帧压入main线程的Java虚拟机栈，如下图示：</p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/bcb4bf5716e3496cb1af349de9894830~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=KNKZscWcCbd9UKrkBy%2FPhsD5jp4%3D" data-ic="false" data-width="434" data-height="316" data-ic-uri=""></div>
<p data-track="21">二.然后main线程每次在while循环里调用loadReplicasFromDisk()方法，就会把loadReplicasFromDisk()方法的栈帧压入自己的Java虚拟机栈，如下图示：</p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6c78798611f84833a2ca20b4e16cd3fe~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=ckm2IeSKwbVeFGT%2BtStu1Mt0xfc%3D" data-ic="false" data-width="596" data-height="468" data-ic-uri=""></div>
<p data-track="22">三.接着在执行loadReplicasFromDisk()方法时，就会在Java堆内存里创建一个ReplicaManager对象实例。然后loadReplicasFromDisk()方法的栈帧会有一个replicaManager局部变量，replicaManager局部变量会引用Java堆内存的ReplicaManager对象实例，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/99a486bd34f14143befa76aaa9b12f1b~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=k5tYB9svlHP0ebPre1BlgEaA%2F9M%3D" data-ic="false" data-width="1038" data-height="474" data-ic-uri=""></div>
<p data-track="23">四.接着就会执行ReplicaManager对象实例的load()方法。</p>
<p data-track="24">&nbsp;</p>
<p data-track="25"><strong>(2)大部分对象的存活周期都是极短的</strong></p>
<p data-track="26">上面代码中的ReplicaManager对象，就是一个短暂存活的对象。在loadReplicasFromDisk()方法中创建这个ReplicaManager对象，然后执行ReplicaManager对象的load()方法。执行完毕后，loadReplicasFromDisk()方法就会结束。一旦方法执行结束，那么loadReplicasFromDisk()方法的栈帧就会出栈。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/44c943fbc1eb4d778038b55a21263940~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=XPs5FCRin5Gc65P%2F9A3mEo8%2FAbw%3D" data-ic="false" data-width="1028" data-height="330" data-ic-uri=""></div>
<p data-track="27">然后一旦这个ReplicaManager对象没被引用了，就会被JVM的垃圾回收线程给回收掉，释放内存空间。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f61f77f1111745bd8ce0c25839a544b2~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=SST3ehcpTJ58xYVC5HNwKetTm4E%3D" data-ic="false" data-width="1022" data-height="322" data-ic-uri=""></div>
<p data-track="28">继续回到main()方法的while循环里。下次循环执行loadReplicasFromDisk()方法时，又重复一遍上面的过程，把loadReplicasFromDisk()方法的栈帧压入Java虚拟机栈，然后构造一个ReplicaManager实例对象放在Java堆里。一旦执行完ReplicaManager对象的load()方法后，loadReplicasFromDisk()方法又会结束，再次出栈。然后垃圾回收释放掉Java堆内存里的ReplicaManager对象。</p>
<p data-track="29">&nbsp;</p>
<p data-track="30">所以上面代码的ReplicaManager对象，就是一个存活周期很短的对象。每次执行loadReplicasFromDisk()方法时，该对象就会被创建出来。然后执行对象的load()方法，接着可能1毫秒后，就要被垃圾回收掉。</p>
<p data-track="31">&nbsp;</p>
<p data-track="32">所以从这段代码就可以明显看出来：代码里大部分创建的对象，其实存活周期都是很短的。</p>
<p data-track="33">&nbsp;</p>
<p data-track="34"><strong>(3)少数对象是长期存活的</strong></p>
<p data-track="35">接下来看下面代码，用另外的方式来实现同样的功能，也就是给Kafka这个类定义一个静态变量replicaManager。</p>
<pre class="highlighter-hljs"><code>public class Kafka {
    private static ReplicaManager replicaManager = new ReplicaManager();
    
    public static void main(String[] args) {
        while (true) {
            loadReplicasFromDisk();
            Thread.sleep(1000);
        }
    }
    
    private static void loadReplicasFromDisk() {
        replicaManager.load();
    }
}</code></pre>
<p data-track="37">这个Kafka类位于JVM的方法区，它有一个静态变量replicaManager，replicaManager静态变量会引用一个在Java堆内存创建的ReplicaManager对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/face7bd7cd8b4f46b59f7138c41ddcd0~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=wJJp6tsxAaO2SIwOM7s7G0j9m8A%3D" data-ic="false" data-width="1044" data-height="330" data-ic-uri=""></div>
<p data-track="38">main()方法会通过while循环不停调用ReplicaManager对象的load()方法，这时这个ReplicaManager实例对象是会一直被Kafka的静态变量引用的。然后它会一直驻留在Java堆内存里，不会被垃圾回收掉。因为这个实例对象它需要长期被使用，周期性的被调用load()方法，所以这个ReplicaManager实例对象就成为了一个长时间存在的对象。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">类似这种被类的静态变量长期引用的对象，就会长期留在Java堆内存里。这种对象就是生命周期很长的对象，它不会轻易被垃圾回收。</p>
<p data-track="41">&nbsp;</p>
<p data-track="42"><strong>(4)JVM分代模型：新生代和老年代</strong></p>
<p data-track="43">可见，采用不同的方式来创建和使用对象，对象的生命周期是不同的。所以JVM将Java堆内存划分为两个区域：一个是新生代，一个是老年代。其中新生代，就是把创建和使用完之后，马上就要回收的对象放在里面。然后老年代，就是把创建后需要一直长期存在的对象放在里面，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9ba1f707b90d4dd789b8cc633fd898f4~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=gdUCSaZ3HoQLFF8JyZ7VtzGm8vk%3D" data-ic="false" data-width="434" data-height="444" data-ic-uri=""></div>
<p data-track="44">下面来看如下代码：</p>
<pre class="highlighter-hljs"><code>public class Kafka {
    private static ReplicaManager fetcher = new ReplicaFetcher();
    
    public static void main(String[] args) {
        loadReplicasFromDisk();
        while(true) {
            fetchReplicasFromRemote();
            Thread.sleep(1000);
        }
    }
    
    private static void loadReplicasFromDisk() {
        ReplicaManager replicaManager = new ReplicaManager();
        replicaManager.load();
    }
    
    private static void fetchReplicasFromRemote() {
        fetcher.fetch();    
    }
}</code></pre>
<p data-track="46">这段代码的意思是：</p>
<p data-track="47"><strong>一.类的静态变量fetcher引用了ReplicaFetcher对象，要长期驻留内存</strong></p>
<p data-track="48">所以ReplicaFetcher对象会在新生代停留一会儿，但最终会进入老年代，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c8ac0a72a5d449218f234623d2695b42~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=f0WBYoLjsqB%2F%2FuO6r1BaES0D4TQ%3D" data-ic="false" data-width="922" data-height="534" data-ic-uri=""></div>
<p data-track="49"><strong>二.进入main()方法后，会先调用loadReplicasFromDisk()方法</strong></p>
<p data-track="50">该方法意思是系统启动就从磁盘加载一次数据，这个方法的栈帧会入栈。然后在该方法里会创建一个ReplicaManager对象，这个对象用完就回收。所以ReplicaManager对象会放在新生代里，由栈帧里的局部变量来引用。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a2e4bda35a70420bbf3056d50a8b513a~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=bG0Ym5tZQCFLuBWiNUMpEEBNa78%3D" data-ic="false" data-width="1080" data-height="729" data-ic-uri=""></div>
<p data-track="51"><strong>三.一旦loadReplicasFromDisk()方法执行完毕，其栈帧就会出栈</strong></p>
<p data-track="52">对应的新生代里的ReplicaManager对象也会被回收掉，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8c06983871f1443c9ec49d762405f336~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=OSZapffaf7Dw8m%2Baldd04Kh9RrI%3D" data-ic="false" data-width="1080" data-height="594" data-ic-uri=""></div>
<p data-track="53"><strong>四.接着会执行一段while循环代码</strong></p>
<p data-track="54">即周期性调用ReplicaFetcher的fetch()方法，从远程加载副本数据。由于ReplicaFetcher这个对象被Kafka类的静态变量fetcher给引用了，所以它会长期存在于老年代里的，持续被使用。</p>
<p data-track="55">&nbsp;</p>
<p data-track="56"><strong>(5)为什么要分成新生代和老年代</strong></p>
<p data-track="57">之所示需要这么区分，是因为这和垃圾回收有关。新生代里的对象，创建后很快就会被回收，所以需要一种垃圾回收算法。老年代里的对象，需要长期存在，所以需要另一种垃圾回收算法。因此才需要分成两个区域来放不同的对象。</p>
<p data-track="58">&nbsp;</p>
<p data-track="59"><strong>(6)什么是永久代</strong></p>
<p data-track="60">JVM里的永久代其实就是方法区，方法区就是所谓的永久代，可以认为永久代就是放一些类的信息。</p>
<p data-track="61">&nbsp;</p>
<p data-track="62"><strong>(7)问题</strong></p>
<p data-track="63">每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，那么这个Java虚拟机栈里的局部变量需要进行垃圾回收吗？</p>
<p data-track="64">&nbsp;</p>
<p data-track="65">JVM垃圾回收针对的是新生代、老年代、方法区，不针对方法的栈帧。方法一旦执行完毕，栈帧出栈，里面的局部变量就从内存里清理掉了。</p>
<p data-track="66">&nbsp;</p>
<p data-track="67"><strong>2.对象在JVM内存中如何分配如何流转</strong></p>
<p data-track="68"><strong>(1)对象分配的基础知识总结</strong></p>
<p data-track="69"><strong>(2)大部分对象都优先在新生代分配内存</strong></p>
<p data-track="70"><strong>(3)什么情况下会触发新生代的垃圾回收</strong></p>
<p data-track="71"><strong>(4)长期存活的对象会躲过多次垃圾回收</strong></p>
<p data-track="72"><strong>(5)老年代会垃圾回收吗</strong></p>
<p data-track="73"><strong>(6)关于新生代和老年代的对象分配总结</strong></p>
<p data-track="74">&nbsp;</p>
<p data-track="75"><strong>(1)对象分配的基础知识总结</strong></p>
<p data-track="76">Java代码里创建出来的对象，一般就是两种：第一种是短期存活的，迅速使用完后就会被垃圾回收；第二种是长期存活的，一直存在Java堆内存里。</p>
<p data-track="77">&nbsp;</p>
<p data-track="78">第一种短期存活的对象，会在Java堆内存的新生代里。第二种长期存活的对象，会在Java堆内存的老年代里。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">那么对象什么时候进入新生代？</p>
<p data-track="81">什么情况下会进入老年代？</p>
<p data-track="82">&nbsp;</p>
<p data-track="83"><strong>(2)大部分对象都优先在新生代分配内存</strong></p>
<p data-track="84">大部分对象，都会优先在新生代分配内存。</p>
<pre class="highlighter-hljs"><code>public class Kafka {
    private static ReplicaManager fetcher = new ReplicaFetcher();
    
    public static void main(String[] args) {
        loadReplicasFromDisk();
        while(true) {
            fetchReplicasFromRemote();
            Thread.sleep(1000);
        }
    }
    
    private static void loadReplicasFromDisk() {
        ReplicaManager replicaManager = new ReplicaManager();
        replicaManager.load();
    }
    
    private static void fetchReplicasFromRemote() {
        fetcher.fetch();    
    }
}</code></pre>
<p>上述代码中：类的静态变量fetcher引用的ReplicaFetcher对象，会长期存活在内存里。但是该对象刚开始由new ReplicaFetcher()实例化时，是在新生代里的。loadReplicasFromDisk()中创建的ReplicaManager对象，也在新生代中。如下：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/37cba3f572cf41f3830f6606bc3414b7~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=kh1TQtEuRylKmdeF2OJEakf%2F%2BjU%3D" data-ic="false" data-width="1080" data-height="724" data-ic-uri=""></div>
<p data-track="87"><strong>(3)什么情况下会触发新生代的垃圾回收</strong></p>
<p data-track="88">一旦loadReplicasFromDisk()方法执行完毕后，这个方法的栈帧出栈，这个时候便没有任何局部变量引用ReplicaManager实例对象了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6121dd8281064c94b9f9f1ba78a1985d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=lr%2BJp5KGWvWQBOQkJv4mkFnEEas%3D" data-ic="false" data-width="1080" data-height="587" data-ic-uri=""></div>
<p data-track="89">此时是否会对没被使用的ReplicaManager实例对象进行垃圾回收？此时是不会马上对失去引用的Java堆实例对象进行垃圾回收的，因为垃圾回收也有触发条件。</p>
<p data-track="90">&nbsp;</p>
<p data-track="91">其中一个比较常见的触发场景是：假设代码创建了很多对象，然后导致Java堆内存里堆积了大量对象。然后这些对象之前都会被各方法中的局部变量引用，但现在没被引用了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4d385d2c3d8644979dd11dcbb8abc1c8~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=obVQLfDIxreK4AFCM9CT%2BEngLCY%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="92">这时如果新生代预先分配的内存空间，几乎都被全部对象给占满了，而代码还在继续运行。那么准备在新生代里分配一个对象时，发现新生代里内存空间不够，就会触发一次新生代内存空间的垃圾回收。新生代内存空间的垃圾回收，也称为Minor GC，有时也叫Young GC。Young GC会尝试把新生代里那些没被引用的垃圾对象，都给回收掉。</p>
<p data-track="93">&nbsp;</p>
<p data-track="94">比如上图的ReplicaManager实例对象，就是没有被引用的垃圾对象。即会把ReplicaManager对象回收，然后存放一个新的对象到新生代。包括上图中的大量实例对象，其实也没被引用。在这个新生代垃圾回收的过程中，就会把这些垃圾对象也都回收掉。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96">平时代码中创建的大部分对象，都是这种使用后马上就可回收的对象。当已经在新生代里分配了大量对象，且这些对象使用完后也没被引用了。而新生代又差不多满了，要继续分配新对象时发现新生代内存空间不足，就会触发一次垃圾回收，把所有垃圾对象给回收掉，腾出大量内存空间。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4740982bbc624859b8a9f66f9ec4d18a~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=mgn2%2FAW2W7QuLSu28UqfEMAEhak%3D" data-ic="false" data-width="1080" data-height="590" data-ic-uri=""></div>
<p data-track="97"><strong>(4)长期存活的对象会躲过多次垃圾回收</strong></p>
<p data-track="98">上图中的ReplicaFetcher实例对象，是一个被Kafka类的静态变量fetcher引用的、长期存活的对象。</p>
<p data-track="99">&nbsp;</p>
<p data-track="100">所以虽然新生代可能随着系统的运行，不停地创建对象，然后让新生代变满，接着进行垃圾回收，大量对象又会被回收掉。但是这个ReplicaFetcher对象，它会一直存活在新生代里。因为它一直被Kafka类的静态变量引用着，所以它不会被回收。</p>
<p data-track="101">&nbsp;</p>
<p data-track="102">因此JVM有规定：如果一个实例对象在新生代中成功躲过15次垃圾回收，就进入老年代。对象的年龄就是：每进行一次垃圾回收而没被回收掉，对象年龄就加1。</p>
<p data-track="103">&nbsp;</p>
<p data-track="104">所以如果ReplicaFetcher对象在新生代中成功躲过15多次垃圾回收，那么ReplicaFetcher对象就会被认为会长期存活在内存里，然后就会被转移到老年代中。老年代会存放一些年龄很大的对象，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2d1d1837358946028298f11cc6150c8c~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=%2BXp4XjpCb9L9FW793h%2BnYFHag7g%3D" data-ic="false" data-width="1080" data-height="514" data-ic-uri=""></div>
<p data-track="105"><strong>(5)老年代会垃圾回收吗</strong></p>
<p data-track="106">老年代里的那些对象会被垃圾回收吗？答案是肯定的。因为老年代的对象也有可能随着代码的运行不再被引用，也要垃圾回收。当越来越多对象进入老年代，一旦老年代满了，也要对老年代垃圾回收。</p>
<p data-track="107">&nbsp;</p>
<p data-track="108"><strong>(6)关于新生代和老年代的对象分配总结</strong></p>
<p data-track="109">目前已介绍如下机制：</p>
<p data-track="110">一.对象优先分配在新生代</p>
<p data-track="111">二.新生代对象满了就会触发垃圾回收把没有被引用的垃圾对象清理掉</p>
<p data-track="112">三.如果对象躲过了十五次垃圾回收就会进入老年代</p>
<p data-track="113">四.如果老年代满了也会触发垃圾回收把没有被引用的垃圾对象清理掉</p>
<p data-track="114">&nbsp;</p>
<p data-track="115">当然还有其他机制，比如：</p>
<p data-track="116">一.新生代垃圾回收后因为存活对象太多导致大量对象直接进入老年代</p>
<p data-track="117">二.大对象不经过新生代直接进入老年代</p>
<p data-track="118">三.对象动态年龄判断机制</p>
<p data-track="119">四.空间分配担保机制</p>
<p data-track="120">&nbsp;</p>
<p data-track="121"><strong>3.部署线上系统时如何设置JVM内存大小</strong></p>
<p data-track="122"><strong>(1)对象在JVM内存中的分配流转总结</strong></p>
<p data-track="123"><strong>(2)与JVM内存相关的几个核心参数图解</strong></p>
<p><strong>(3)如何在启动系统的时候设置JVM参数</strong></p>
<p data-track="125"><strong>(4)每日百万交易的支付系统JVM参数优化案例</strong></p>
<p data-track="126">&nbsp;</p>
<p data-track="127"><strong>(1)对象在JVM内存中的分配流转总结</strong></p>
<p data-track="128">代码里创建的对象，都是优先在新生代分配的。然后随着一些方法执行完毕，大部分对象就没有被引用而成为垃圾对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c2f568a9dd86424f8e28da45e77e52e5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=iKyzvv93Qz5EM8WC7KX993KRMuI%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="129">随着代码持续运行，新生代里的对象会越来越多。而且新生代里面大部分对象都是生命周期短的对象，很快就不会被引用。因此可以认为新生代里的大部分对象都会是一些垃圾对象。</p>
<p data-track="130">&nbsp;</p>
<p data-track="131">然后代码继续运行，肯定会创建新的对象，需要分配在新生代里。所以一旦新生代里内存不够了，就会触发一次Young GC。此时会把新生代里没被引用的垃圾对象都给回收掉，腾出内存空间。如下图示：</p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f65abe701ea4417283eea0388ef21247~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=rIfEDij97eSVUeI9dW7T8o5d%2FZU%3D" data-ic="false" data-width="1080" data-height="590" data-ic-uri=""></div>
<p data-track="132">对于那种长周期存活的对象，它会在新生代里持续躲过多次垃圾回收。每躲过一次垃圾回收，年龄会增长1岁。然后当它成为15岁的"老年对象"时，就会被转移到老年代里。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/26cda977f8684c118fdbdde99993aa01~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=n1r6Q4zSKtz6CdipNVg0Q3pph6k%3D" data-ic="false" data-width="1080" data-height="514" data-ic-uri=""></div>
<p data-track="133">所以核心的问题就是：短生存周期的对象和长生存周期的对象分别是什么，它们是如何在新生代里分配的，新生代什么时候触发YGC，长生存周期的对象如何转移到老年代里。</p>
<p data-track="134">&nbsp;</p>
<p data-track="135"><strong>(2)与JVM内存相关的几个核心参数图解</strong></p>
<p data-track="136">接下来介绍JVM的参数如何设置。在JVM内存分配中，有几个参数是比较核心的，如下所示：</p>
<p data-track="137">一.-Xms：Java堆内存的大小</p>
<p data-track="138">二.-Xmx：Java堆内存的最大大小</p>
<p data-track="139">三.-Xmn：Java堆内存中的新生代大小</p>
<p data-track="140">四.-XX:PermSize：永久代大小</p>
<p data-track="141">五.-XX:MaxPermSize：永久代最大大小</p>
<p data-track="142">六.-Xss：每个线程的栈内存大小</p>
<p data-track="143">&nbsp;</p>
<p data-track="144">下面对上述参数进行一一说明。</p>
<p data-track="145">&nbsp;</p>
<p data-track="146">-Xms和-Xmx：用于设置Java堆内存刚开始大小，以及允许的最大大小。对于这对参数，通常都会设置为完全一样的大小。这两个参数是用来限定Java堆内存的总大小的，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/aba3dec8a85d4288a1babb7582c2064a~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=N23QtPuTcG95%2Ft%2BHwZyfnPKbpPo%3D" data-ic="false" data-width="342" data-height="360" data-ic-uri=""></div>
<p data-track="147">-Xmn：这个参数用来设置Java堆内存中的新生代的大小，扣除新生代大小之后的剩余内存就是老年代的内存大小，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d875c6d428e84ce586d8302214b54b81~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=rNOW6ZMC2Q%2FuL1y%2FyAG5HMYLros%3D" data-ic="false" data-width="350" data-height="634" data-ic-uri=""></div>
<p data-track="148">-XX:PermSize和-XX:MaxPermSize：设置永久代大小和最大永久代大小。JDK1.8后被替换为-XX:MetaspaceSize和-XX:MaxMetaspaceSize，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d58610b9f28a4b49bdfb8f3657858eab~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=cpOPhKZKJzPG4kOtVoj4N2wR1H8%3D" data-ic="false" data-width="738" data-height="636" data-ic-uri=""></div>
<p data-track="149">-Xss：这个参数限定每个线程的栈内存大小。每个线程都有一个自己的虚拟机栈，然后每次执行一个方法，就会将方法的栈帧压入线程的栈里。方法执行完毕，那么栈帧就会从线程的栈里出栈。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d507a331294d4d80b9c96f806d5bbe55~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=QundZ8tN%2BaUsrs9Wf7jzoQPcIVc%3D" data-ic="false" data-width="748" data-height="720" data-ic-uri=""></div>
<p><strong>(3)如何在启动系统的时候设置JVM参数</strong></p>
<p data-track="151">比如以"java -jar"方式启动一个jar包里的系统时，可采用下面格式：</p>
<pre class="highlighter-hljs"><code>$ java -Xms512M -Xmx512M -Xmn256M -Xss1M 
-XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar</code></pre>
<p data-track="153"><strong>(4)每日百万交易的支付系统JVM优化案例</strong></p>
<p data-track="154">接下来分析一个支付系统的核心业务流程，然后结合JVM相关知识，来一步步探究JVM内存相关的核心参数，在上线一个生产系统时，应如何针对预估的并发压力，给出一个未经调优的比较合理的初始值。</p>
<p data-track="155">&nbsp;</p>
<p data-track="156">另外分析各种参数在设置时有哪些考虑的点，Java堆内存到底要多大？新生代和老年代的内存分别要多大？永久代和虚拟机栈分别要多大？</p>
<p data-track="157">&nbsp;</p>
<p data-track="158">其实JVM参数到底该如何设置，一定是根据不同业务场景来调整的。不会有一个通用的配置和模板，一切都要从案例出发，结合场景来分析。</p>
<p data-track="159">&nbsp;</p>
<p data-track="160"><strong>(5)问题</strong></p>
<p data-track="161">Tomcat、Spring Boot部署启动系统时，JVM参数如何设置？</p>
<p data-track="162">&nbsp;</p>
<p data-track="163">答：Spring Boot是在启动时可以加上JVM参数的，Tomcat则是在bin目录下的catalina.sh中加入JVM参数的。</p>
<p data-track="164">&nbsp;</p>
<p data-track="165"><strong>4.如何设置JVM堆内存大小</strong></p>
<p data-track="166"><strong>(1)支付系统核心业务流程</strong></p>
<p data-track="167"><strong>(2)每日百万交易的支付系统的压力在哪里</strong></p>
<p data-track="168"><strong>(3)支付系统每秒钟需要处理多少笔支付订单</strong></p>
<p data-track="169"><strong>(4)每个支付订单处理要耗时多久</strong></p>
<p data-track="170"><strong>(5)每个支付订单大概需要多大的内存空间</strong></p>
<p data-track="171"><strong>(6)每秒发起的支付请求对内存的占用</strong></p>
<p data-track="172"><strong>(7)让支付系统运行起来进行分析</strong></p>
<p data-track="173"><strong>(8)对完整的支付系统内存占用需要进行预估</strong></p>
<p data-track="174"><strong>(9)支付系统的JVM堆内存应该怎么设置</strong></p>
<p data-track="175"><strong>(10)总结</strong></p>
<p data-track="176">&nbsp;</p>
<p data-track="177"><strong>(1)支付系统核心业务流程</strong></p>
<p data-track="178">支付系统的核心业务流程如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d04ad7db2bc646abaa31799682aa0ece~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=0elnTF21bM4nO81ao8CuuMBtN2k%3D" data-ic="false" data-width="1080" data-height="462" data-ic-uri=""></div>
<p data-track="179">首先用户在商城系统提交一个支付订单的请求，接着商城系统把这个请求提交给支付系统。支付系统就会生成一个支付订单，此时订单状态可能是"待支付"的状态。然后支付系统指引用户跳转到付款页面，选择一个付款方式。然后用户进行支付，支付系统把实际支付请求转交给第三方支付渠道。第三方支付渠道可能是微信或支付宝，由它们处理支付请求转移资金。如果微信或者支付宝处理完支付后，就会返回支付结果给支付系统，支付系统可以更新自己本地的支付订单的状态变成"已完成"。</p>
<p data-track="180">&nbsp;</p>
<p data-track="181">当然，其实一个完整的支付系统还包含很多内容。比如还要负责对账以及跟合作商户之间的资金清算，支付系统要包含渠道管理、支付交易、对账管理、结算管理等各种功能，但是这里只关注最核心的支付流程即可。</p>
<p data-track="182">&nbsp;</p>
<p data-track="183"><strong>(2)每日百万交易的支付系统的压力在哪里</strong></p>
<p data-track="184">一个每日百万交易的支付系统的压力到底集中在哪里？比如上面的那个核心支付流程，假设每日要发生百万次交易。</p>
<p data-track="185">&nbsp;</p>
<p data-track="186">一般达到百万交易，要不然是国内最大的互联网公司，要不就是一个通用型第三方支付平台，对接各种APP的支付交易。</p>
<p data-track="187">&nbsp;</p>
<p data-track="188">其实通过上图都能明显看到，上述业务流程中，最核心的环节就是在用户发起支付请求时，会生成一个支付订单。这个支付订单需要记录清楚：是谁发起支付、对哪个商品支付等信息。如果每日百万交易，那么在JVM的角度看：就是每天会在JVM中创建百万个支付订单对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/742fec9e85294a38ab4badafc7b4147d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=EXE%2BBr1FyWyyz9Kuu137yx5%2BdEo%3D" data-ic="false" data-width="774" data-height="316" data-ic-uri=""></div>
<p data-track="189">所以这个每日百万交易的支付系统，它的压力有很多方面：如高并发访问、高性能处理、大量的支付订单数据需要存储等技术难点。但抛开这些系统架构层面的东西，单单在JVM层面支付系统最大的压力：就是每天JVM内存里会频繁创建和销毁100万个支付订单对象。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191">所以这里就牵扯到一些核心问题：</p>
<p data-track="192">一.支付系统需要部署多少台机器？</p>
<p data-track="193">二.每台机器需要多大的内存空间？</p>
<p data-track="194">三.每台机器启动的JVM需要分配多大堆内存空间？</p>
<p data-track="195">四.设置JVM多大内存才能创建这么多对象而不会导致内存不够而崩溃？</p>
<p data-track="196">&nbsp;</p>
<p data-track="197"><strong>(3)支付系统每秒钟需要处理多少笔支付订单</strong></p>
<p data-track="198">要解决线上系统最核心的一个参数，也就是合理设置JVM堆内存大小。首先第一个要计算的，就是每秒钟订单系统要处理多少笔支付订单。</p>
<p data-track="199">&nbsp;</p>
<p data-track="200">假设每天100万个支付订单。那么一般用户交易行为都会发生在每天的高峰期，比如中午或者晚上。假设每天高峰期大概是3个小时，将100万平均分配到3个小时里。那么大概每秒100笔订单，所以就以每秒100笔订单来进行计算。假设支付系统部署3台机器，则每台机器实际上每秒大概处理30笔订单。如下图示，这个图可以反映出支付系统每秒钟的订单处理压力。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/e8051083621b45a696911c593aa57f3e~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=NNW%2BlisQrGdukCtKsdwXuo2mHdM%3D" data-ic="false" data-width="780" data-height="972" data-ic-uri=""></div>
<p data-track="201"><strong>(4)每个支付订单处理要耗时多久</strong></p>
<p data-track="202">下一个问题，必须要弄清楚的是，每个支付订单大概要处理多长时间？</p>
<p data-track="203">&nbsp;</p>
<p data-track="204">如果用户发起一次支付请求：那么支付需要在JVM中创建一个支付订单对象，填充进数据。然后把这个支付订单写入数据库，以及可能处理一些其他事情。</p>
<p data-track="205">&nbsp;</p>
<p data-track="206">假设一次支付请求的处理包含一个支付订单的创建，大概需要1秒时间，那么每台机器一秒钟会接收到30笔支付订单的请求。然后会在JVM新生代里创建30个支付订单的对象，进行写库等处理。接着1秒后这30个支付订单就处理完毕，此时栈帧中对这些支付订单对象的引用就被回收了。然后这些订单对象在JVM的新生代里就是没被引用的垃圾对象了。接着下一秒会继续来处理30个支付订单，重复这个步骤。</p>
<p data-track="207">&nbsp;</p>
<p data-track="208"><strong>(5)每个支付订单大概需要多大的内存空间</strong></p>
<p data-track="209">接下来计算一下，每个支付订单对象大概需要多大的内存空间？</p>
<p data-track="210">&nbsp;</p>
<p data-track="211">可以直接根据支付订单类中的实例变量的类型来计算。比如支付订单类如下所示：一个Integer类型的变量数据4字节，一个Long类型的变量数据是8字节，还有别的类型的变量数据占据多少字节等，这样就可以计算出每个支付订单对象大致占多少字节了。</p>
<pre class="highlighter-hljs"><code>public class PayOrder {
    private Integer userId;
    private Long orderTime;
    private Integer orderId;
}</code></pre>
<p data-track="213">一般像支付订单这种核心类，可以按20个实例变量来计算。然后大概一个订单对象也就一两百字节，可以算它大一点。比如一个支付订单对象占据500字节的内存空间，也不到1K。</p>
<p data-track="214">&nbsp;</p>
<p data-track="215"><strong>(6)每秒发起的支付请求对内存的占用</strong></p>
<p data-track="216">假设有3台机器，每秒钟处理30笔支付订单的请求。那么在这1秒内，肯定有方法栈帧里的局部变量在引用这些支付订单对象。那么30个支付订单，大概占据的内存空间是30 * 500字节 = 15000字节。大概15K左右，其实是非常小的，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/712d8bf4234d48dcb345acc512eeb7c5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=1TLp3tsSR5z3b7YlAHQ4omgZH%2BA%3D" data-ic="false" data-width="1014" data-height="976" data-ic-uri=""></div>
<p data-track="217"><strong>(7)让支付系统运行起来进行分析</strong></p>
<p data-track="218">现在已经把整个系统运行的关键环节的数据都分析清楚了：每秒30个支付请求，每秒创建30个支付对象，每秒占15K的内存空间。接着1秒过后，这30个对象就没有被引用了，成为新生代里的垃圾。下一秒请求过来，系统继续创建30个支付对象放入新生代里，然后新生代里的对象就会持续累积增加。</p>
<p data-track="219">&nbsp;</p>
<p data-track="220">直到有一刻，发现可能新生代里都有几十万个对象。此时占据了几百M的内存空间，可能新生代空间就快满了。然后就会触发Young GC，把新生代里的垃圾对象都给回收掉。从而腾出内存空间，可以继续在内存里分配新的对象。</p>
<p data-track="221">&nbsp;</p>
<p data-track="222">这就是该支付系统在创建订单环节的JVM运行模型。</p>
<p data-track="223">&nbsp;</p>
<p data-track="224"><strong>(8)对完整的支付系统内存占用需要进行预估</strong></p>
<p data-track="225">前面的分析都是基于一个核心业务流程中的一个支付订单对象来分析的，但那其实那只是整个支付系统的一个小部分而已。</p>
<p data-track="226">&nbsp;</p>
<p data-track="227">真实的支付系统在线上运行时，肯定会每秒创建大量其他对象。所以可以结合这个访问压力以及核心对象的内存占据，大致估算一下整个支付系统每秒钟大致会占据多少内存空间。</p>
<p data-track="228">&nbsp;</p>
<p data-track="229">如果要估算的话，其实可以把上述的计算结果扩大10到20倍。即每秒除了在内存里创建支付订单对象，还会创建其他数十种对象。</p>
<p data-track="230">&nbsp;</p>
<p data-track="231">假设一台机器每秒创建100个500字节的支付订单对象，扩大20倍后，那么每秒创建出的被栈内存的局部变量引用的对象，大概占1M内存空间。然后下一秒对新请求，继续创建1M对象放入新生代，一秒后又变成垃圾。循环多次后，新生代里垃圾太多，就会触发Young GC回收掉这些垃圾。这就是一个完整的支付系统在JVM层面的内存使用模型。</p>
<p data-track="232">&nbsp;</p>
<p data-track="233"><strong>(9)支付系统的JVM堆内存应该怎么设置</strong></p>
<p data-track="234">一般来说这种线上业务系统的机器配置是2核4G或者是4核8G。</p>
<p data-track="235">&nbsp;</p>
<p data-track="236"><strong>一.2核4G的机器来部署则还是有点紧凑的</strong></p>
<p data-track="237">虽然机器有4G内存，但机器本身也用一些内存，最后JVM最多2G内存。然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是有1G多的内存空间。然后堆内存还分为新生代和老年代，老年代需要放置系统的一些长期存活的对象，也要占几百M的内存空间，那么这样下来新生代可能只剩下几百M的内存了。</p>
<p data-track="238">&nbsp;</p>
<p data-track="239">但上述仅仅是针对一个支付订单对象来分析的，实际上如果扩大20倍来对完整支付系统的预估后：一台机器每秒处理100个订单，每秒就会占据1M左右的内存空间。那么此时如果新生代就几百M的内存空间：就会导致运行几百秒后，新生代内存空间就满了，此时就会触发YGC。如果频繁触发YGC，还是会影响线上系统的性能稳定性的。</p>
<p data-track="240">&nbsp;</p>
<p data-track="241"><strong>二.可以考虑采用4核8G的机器来部署支付系统</strong></p>
<p data-track="242">此时JVM进程至少可以给4G以上内存，新生代至少可分配2G内存空间。这样就可以做到即便新生代每秒消耗1M左右的内存，也要将近半小时到1小时才会让新生代触发YGC，大大降低了GC频率。</p>
<p data-track="243">&nbsp;</p>
<p data-track="244"><strong>举个例子：</strong></p>
<p data-track="245">机器采用4核8G，-Xms和-Xmx设置为3G，给整个堆内存3G内存空间。-Xmn设置为2G，给新生代2G内存空间。而且假设业务量如果更大，则可以考虑不只部署3台机器，可以考虑横向扩展部署5台机器或者10台机器，这样每台机器处理的请求更少对JVM的压力更小。</p>
<p data-track="246">&nbsp;</p>
<p data-track="247"><strong>(10)总结</strong></p>
<p data-track="248">从一个日百万交易的支付系统出发，部署3台机器的场景下。每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理。每笔订单的核心对象每秒钟会对JVM占据多大内存空间，根据单个核心对象横向扩展预估整个系统每秒需要占据多大内存空间。接着根据上述数据模型推算出：在不同的机器配置之下，新生代大致会有多大的内存空间。然后在不同的新生代大小下，多久会触发一次Young GC。</p>
<p data-track="249">&nbsp;</p>
<p data-track="250">为了避免频繁的GC，那么应该选用什么样的机器配置。部署多少台机器，设置JVM堆内存、新生代分别多大的内存空间。</p>
<p data-track="251">&nbsp;</p>
<p data-track="252">根据这套配置，就可以推算出来整个系统的运行模型了。每秒钟创建多少对象在新生代，然后1秒之后成为垃圾。大概系统运行多久，新生代会触发一次GC，频率有多高。</p>
<p class="pgc-p" data-track="253">&nbsp;</p>
<p data-track="254"><strong>5.如何设置JVM栈内存与永久代大小</strong></p>
<p data-track="255"><strong>(1)如何设置JVM堆内存总结</strong></p>
<p data-track="256"><strong>(2)不合理设置内存的反面示例</strong></p>
<p data-track="257"><strong>(3)大促期间瞬时访问量增加十倍</strong></p>
<p data-track="258"><strong>(4)少数请求要几十秒处理导致老年代内存占用变大</strong></p>
<p data-track="259"><strong>(5)老年代对象越来越多导致频繁垃圾回收</strong></p>
<p data-track="260"><strong>(6)不合理设置内存的反面示例总结</strong></p>
<p data-track="261"><strong>(7)如何合理设置永久代大小</strong></p>
<p data-track="262"><strong>(8)如何合理设置栈内存大小</strong></p>
<p data-track="263">&nbsp;</p>
<p data-track="264"><strong>(1)如何设置JVM堆内存总结</strong></p>
<p data-track="265">如果准备上线一个新系统，如何根据这个系统预估的业务量和访问量，去推算系统每秒的并发量。然后推算每秒的请求对内存空间的占用，从而推算出整个系统运行期间的JVM内存运转模型。然后基于推算出的JVM内存运转模型，在上线前选择合理的机器配置，需要多大内存的机器才能让JVM堆内存空间拥有一个合理的大小。</p>
<p data-track="266">&nbsp;</p>
<p data-track="267">这是一项非常基础的技能，因为对于某些业务新系统，可能上线就会面临很大的访问压力。所以要合理预估内存压力，选择合适的机器配置，设置合理的内存大小。</p>
<p data-track="268">&nbsp;</p>
<p data-track="269">每个合格的工程师，都应该在上线系统时，对系统压力做出预估。然后对JVM内存、磁盘空间大小、网络带宽、数据库压力做出预估，最后在各方面都给出合理的配置。</p>
<p data-track="270">&nbsp;</p>
<p data-track="271"><strong>(2)不合理设置内存的反面示例</strong></p>
<p data-track="272">下面介绍一个不合理设置内存大小导致问题的反面案例。假设支付系统因为没有经过合理的内存预估，所以选用了1台2核4G的虚拟机来部署线上系统，而且只用一台机器。然后线上JVM给的堆内存大小仅仅只有1G，扣除老年代后，新生代只有几百M的内存空间。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1f609ac104d74dc79ab0b05d11520ebc~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=1zS6jlSJBqwirDL1RPkD9pLcl3Y%3D" data-ic="false" data-width="372" data-height="334" data-ic-uri=""></div>
<p data-track="273">接着业务压力还是每天100万交易，高峰期每秒大概100笔支付交易。那么对应的每秒就有100个支付订单对象有创建出来，每个支付订单对象占据500字节左右，总共是50K。然后假设处理一笔交易总共需要1秒，那么这100个对象在新生代中存在1秒的期间会被栈帧引用，无法被回收。此外进行全局预估时，会从支付订单对象横向扩展到系统其他对象。所以起码要把内存占用扩大10到20倍，比如扩大20倍。</p>
<p data-track="274">&nbsp;</p>
<p data-track="275">因此只用一台2核4G机器来处理每秒100个创建支付订单的请求，在1秒内总共会创建出大概1M对象，这些对象在这1秒内是无法被回收的。</p>
<p data-track="276">&nbsp;</p>
<p data-track="277"><strong>(3)大促期间瞬时访问量增加十倍</strong></p>
<p data-track="278">其实按照估算出的内存压力，在系统正常情况下，还不算什么大问题。因为每秒新增1M对象，几百秒过后新生代快满了。自然就会触发Young GC，回收掉里面99%的垃圾对象。如果新生代内存有500M，最多会发现系统每隔几分钟略微卡顿一下。因为这个时候在进行垃圾回收，会影响系统性能。</p>
<p data-track="279">&nbsp;</p>
<p data-track="280">但是现在假设电商系统搞大促活动，很可能会导致压力瞬间增大10倍。此时可能会发现，支付系统每秒要处理的不是100笔，而是上千笔订单。</p>
<p data-track="281">&nbsp;</p>
<p data-track="282">这时系统压力本身就会很大，不光是JVM堆内存，尤其是线程资源、CPU资源，都会几乎打满，JVM堆内存就更是岌岌可危了。</p>
<p data-track="283">&nbsp;</p>
<p data-track="284"><strong>(4)少数请求要几十秒处理导致老年代内存占用变大</strong></p>
<p data-track="285">现在假设一台机器每秒需要处理1000笔交易，那么支付系统每秒对内存的占用就增加到10M以上。甚至再大胆点，预估支付系统每秒对内存占用达到几十M，甚至上百M。因为毕竟大促时流量激增，就一切围绕这来预估。而且最可怕的是，可能每秒过来的1000笔交易，不再是1秒就能处理完。因压力骤增导致性能下降，可能出现处理完一个请求要几秒甚至几十秒。此时如下图示，假设新生代里已经积压了很多的数据，都快满了。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f1ce0770420f44bbbbb2bd185c406e42~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=VC5VGoXCDY0W12weO7iVjIHadAg%3D" data-ic="false" data-width="370" data-height="356" data-ic-uri=""></div>
<p data-track="286">此时内存里有几十M的对象都被引用着，因为少数请求突然处理特别慢。为什么会处理特别慢？因为压力太大，导致系统性能太差了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/67462b4a535b4939959817edfec87677~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=pjyOaijqX3mdJM3mUGx6UK3ZZu0%3D" data-ic="false" data-width="1080" data-height="559" data-ic-uri=""></div>
<p data-track="287">这时如果要在新生代里分配对象，那么就会导致一次YGC去回收新生代。但可能回收大量对象后，那少数几十M对象还在，因为少数请求特别慢。然后很快新生代继续被填满，再次触发YGC，然后少数几十M对象还在。此时多次YGC之后，这少数几十M对象就会被转移到老年代去。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8dec4fc653194b2084df88d898a0f941~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20241226230208D9415C460B2CC10CE416&amp;x-expires=2147483647&amp;x-signature=CB3oy8JOwnSQ9dhgUz48Ya7yPKI%3D" data-ic="false" data-width="1080" data-height="833" data-ic-uri=""></div>
<p data-track="288"><strong>(5)老年代对象越来越多导致频繁垃圾回收</strong></p>
<p data-track="289">上述流程如果反复来多次，时不时有少数请求特别慢，这些特别慢的请求创建的对象在新生代多次没法回收就会被移到老年代。然后后续处理完，老年代里的对象就没被引用了，成为了垃圾对象。</p>
<p data-track="290">&nbsp;</p>
<p data-track="291">经常重复这个流程，老年代里的垃圾对象，就会越来越多。一旦老年代的垃圾对象越来越多，那么老年代迟早会满，触发老年代的垃圾回收。而且这个老年代被占满的频率还很快，就会频繁触发老年代的垃圾回收。而老年代垃圾回收是很慢的，老年代频繁垃圾回收会极大影响系统性能。</p>
<p data-track="292">&nbsp;</p>
<p data-track="293">所以如果设置内存不合理，就会导致新生代内存不充足。在遇到大促等流量暴增时，就会导致偶尔卡顿。偶尔卡顿又会让很多本在新生代的对象不停迁移到老年代，最后导致老年代要不停地进行垃圾回收。</p>
<p data-track="294">&nbsp;</p>
<p data-track="295"><strong>(6)不合理设置内存的反面示例总结</strong></p>
<p data-track="296">如果内存设置过小，那么当遇到突发巨大流量压力、突发性能抖动时：可能会导致请求卡顿，引发很多新生代对象长期被栈引用，无法被回收。最后本应留在新生代的对象就会持续进入老年代，从而导致老年代内存被频繁占满，频繁触发老年代的垃圾回收。</p>
<p data-track="297">&nbsp;</p>
<p data-track="298">可见不合理预估业务系统压力、不合理设置内存大小，会导致很大问题。</p>
<p data-track="299">&nbsp;</p>
<p data-track="300"><strong>(7)如何合理设置永久代大小</strong></p>
<p data-track="301">永久代大小的设置没太多可以参考的规范。一般刚开始上线一个系统时可设置永久代为几百M，基本上都是够用的。因为永久代里主要存放的是类的信息，当然永久代也可能发生内存溢出。</p>
<p data-track="302">&nbsp;</p>
<p data-track="303"><strong>(8)如何合理设置栈内存大小</strong></p>
<p data-track="304">栈内存大小设置，一般无需特别预估和设置，默认的512K到1M都够了。栈内存大小其实就是指每个线程的栈内存空间大小，一般用来存放线程执行方法期间的各种局部变量，当然栈内存也会发生内存溢出。</p>
<p data-track="305"><br><strong>6.问题汇总</strong></p>
<p data-track="306"><strong>问题一：</strong></p>
<p data-track="307">既然栈帧存放了方法对应的局部变量数据，也包括方法执行的其它信息。那为何不把程序计数器记录执行的情况，也放在各个方法自己的栈帧里，而是单独列一个程序计数器去存储呢？</p>
<p data-track="308">&nbsp;</p>
<p data-track="309">答：这就涉及JVM设计者的设计思想了。程序计数器针对的是代码指令的执行，Java虚拟栈针对的是方法的执行。一个是指令，一个是数据，分开设计。</p>
<p data-track="310">&nbsp;</p>
<p data-track="311"><strong>问题二：</strong></p>
<p data-track="312">方法区的类什么时候会被回收？为什么？</p>
<p data-track="313">&nbsp;</p>
<p data-track="314">答：在以下几种情况下，方法区里的类会被回收：</p>
<p data-track="315">一.该类的所有实例对象都已从堆内存里回收</p>
<p data-track="316">二.加载该类的ClassLoader已被回收</p>
<p data-track="317">三.对该类的Class对象没有任何引用</p>
<p data-track="318">满足上面三个条件就可以回收该类了。</p>
<p data-track="319">&nbsp;</p>
<p data-track="320"><strong>问题三：</strong></p>
<p data-track="321">方法执行完后，栈帧马上被出栈，那该栈帧中的变量等数据是马上就被回收掉吗？还是需要等垃圾回收线程扫描到再回收？</p>
<p data-track="322">&nbsp;</p>
<p data-track="323">答：出栈就没了。</p>
<p data-track="324">&nbsp;</p>
<p data-track="325"><strong>问题四：</strong></p>
<p data-track="326">双亲委派模型的设计出发点是什么？</p>
<p data-track="327">&nbsp;</p>
<p data-track="328">答：双亲委派模型设计的出发点很重要：对于任意一个类，都需要由加载它的类加载器和这个类本身，来一同确立其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间。也就是说，判断两个类是否相等，只有在这2个类是由同一个类加载器加载的前提下才有意义。否则即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。</p>
<p data-track="329">&nbsp;</p>
<p data-track="330">基于双亲委派模型设计：</p>
<p data-track="331">那么Java中基础的类，Object类重复多个的问题就不会存在了。因为经过层层传递，加载请求最终都会被启动类加载器所响应，所以加载的Object类最后也会只有一个。否则如果用户自己编写一个java.lang.Object类，并放到ClassPath中，那么就会出现很多Object类，这样应用程序将一片混乱。</p>
<p data-track="332">&nbsp;</p>
<p data-track="333"><strong>问题五：</strong></p>
<p data-track="334">Tomcat需要破坏双亲委派模型的原因是什么？</p>
<p data-track="335">&nbsp;</p>
<p data-track="336">答：原因如下：</p>
<p data-track="337">(1)Tomcat中需要支持不同Web应用依赖同一个第三方类库的不同版本，所以Tomcat中的jar类库需要保证相互隔离。</p>
<p data-track="338">(2)同一个第三方类库的相同版本在不同的Web应用中可以共享。</p>
<p data-track="339">(3)Tomcat依赖的类库需要与应用依赖的类库隔离。</p>
<p data-track="340">(4)JSP需要支持修改后不用重启Tomcat即可生效，Tomcat为了类加载隔离和类更新不用重启，定制开发了各种类加载器。</p>
<p data-track="341">&nbsp;</p>
<p data-track="342"><strong>问题六：</strong></p>
<p data-track="343">引用Class对象的会是什么？</p>
<p data-track="344">&nbsp;</p>
<p data-track="345">答：比如用反射可以获取一个对象对应的类的Class对象实例，比如Class clazz = replicaManager.getClass()，可通过replicaManager引用的对象获取ReplicaManager类的Class对象。那个clazz变量，就可以引用这个Class对象。</p>
<p data-track="346">&nbsp;</p>
<p data-track="347"><strong>问题七：</strong></p>
<p data-track="348">Spring的对象和自定义的POJO对象会分配在哪里？</p>
<p data-track="349">&nbsp;</p>
<p data-track="350">答：托管给Spring管理的对象(配置了@Configration)会长期存在老年代。自定义那些POJO对象，如果不是类对象，那么就会朝生夕灭、会被分配在新生代。Spring容器的对象，默认采用单例方式加载，这些对象会存在老年代中。但在方法内new出来的对象不会存活太长，方法结束后会在下次垃圾回收的时候被回收。</p>
<p data-track="351">&nbsp;</p>
<p data-track="352"><strong>问题八：</strong></p>
<p data-track="353">如下代码的变量和实例对象何时会被销毁回收？</p>
<pre class="highlighter-hljs"><code>public void load() {
    A a = new A();
}</code></pre>
<p data-track="355">答：a这个变量是存放在虚拟机栈的，load()方法执行完后就会被销毁，new A()这个对象是需要等待垃圾回收线程扫描后才回收销毁。</p>
<p data-track="356">&nbsp;</p>
<p data-track="357"><strong>问题九：</strong></p>
<p data-track="358">软引用和弱引用的回收时机？</p>
<p data-track="359">&nbsp;</p>
<p data-track="360">答：内存不够才会回收软引用对象，内存足够不会回收软引用对象。弱引用不管内存空间够不够，只能撑到下次垃圾回收之前，就会被回收。</p>
<p data-track="361">&nbsp;</p>
<p data-track="362"><strong>问题十：</strong></p>
<p data-track="363">类初始化时，类变量引用的是new出来的对象，此时变量引用的对象会被实例化到堆内存吗？</p>
<p data-track="364">&nbsp;</p>
<p data-track="365">答：会实例化放到堆内存</p>
<p data-track="366">&nbsp;</p>
<p data-track="367"><strong>问题十一：</strong></p>
<p data-track="368">是不是应该尽量设大新生代，让系统在高峰期不产生GC？</p>
<p data-track="369">&nbsp;</p>
<p data-track="370">答：是的，尽量是这样。</p>
<p data-track="371">&nbsp;</p>
<p data-track="372"><strong>问题十二：</strong></p>
<p data-track="373">类初始化的时机都有哪些？</p>
<p data-track="374">&nbsp;</p>
<p data-track="375">答：类的"加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化"并不是一个连续的动作。也就是说，类即便加载了，也不一定立即会进行初始化。</p>
<p data-track="376">&nbsp;</p>
<p data-track="377">类初始化的时机如下：</p>
<p data-track="378">一.当创建某个类的新实例时(如通过new或者反射、克隆、反序列化等)</p>
<p data-track="379">二.当调用某个类的静态方法时</p>
<p data-track="380">三.当使用某个类或接口的静态字段时</p>
<p data-track="381">四.调用Java API中的某些反射方法时，如类Class中的方法、java.lang.reflect中的方法</p>
<p data-track="382">五.当初始化某个子类时</p>
<p data-track="383">六.当虚拟机启动某个被标明为启动类的类(即包含main方法的那个类)</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.054087166482638886" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-26 23:03">2024-12-26 23:03</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18634364" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18634364);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18634364', targetLink: 'https://www.cnblogs.com/mjunz/p/18634364', title: 'JVM实战—2.JVM内存设置与对象分配流转' })">举报</a>
</div>
        