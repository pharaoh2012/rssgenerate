
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/19013425" title="发布于 2025-07-30 17:45">
    <span role="heading" aria-level="2">Django模型关系：从一对多到多对多全解析</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250730174515783-134307390.png" alt="Django模型关系：从一对多到多对多全解析" class="desc_img">
        本文详解Django模型关系：一对多（ForeignKey）及多对多（ManyToManyField）关系的定义、操作与优化技巧。同时探讨外键约束的使用场景与权衡策略。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一一对多关系-foreignkey">一、一对多关系： ForeignKey</h2>
<p>一对多是最常见的模型关系，例如 "作者 - 书籍" 场景：假设一个作者可以写多本书，但每本书只能属于一个作者。</p>
<h3 id="定义关系">定义关系</h3>
<p>核心参数说明：</p>
<ul>
<li><code>on_delete=models.CASCADE</code>：当作者被删除时，关联的书籍也会被自动删除</li>
<li><code>related_name='books'</code>：定义反向查询名称，可通过<code>author.books.all()</code>获取作者的所有书籍</li>
</ul>
<pre><code class="language-python">from django.db import models

class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

class Book(models.Model):
    title = models.CharField(max_length=100)
    publication_date = models.DateField()
    # 外键关联Author，级联删除，反向查询名为books
    author = models.ForeignKey(
        Author, 
        on_delete=models.CASCADE, 
        related_name='books'
    )

    def __str__(self):
        return self.title
</code></pre>
<h3 id="数据操作示例">数据操作示例</h3>
<p>创建数据</p>
<pre><code class="language-python"># 创建作者
author1 = Author.objects.create(first_name='J.K.', last_name='Rowling')
author2 = Author.objects.create(first_name='George', last_name='Orwell')

# 创建书籍并关联作者
book1 = Book.objects.create(
    title='Harry Potter', 
    publication_date='1997-06-26', 
    author=author1
)
book2 = Book.objects.create(
    title='1984', 
    publication_date='1949-06-08', 
    author=author2
)
</code></pre>
<p>查询操作</p>
<pre><code class="language-python"># 正向查询：通过书籍找作者
book = Book.objects.get(title='1984')
print(book.author)  # 输出: George Orwell

# 反向查询：通过作者找书籍
author = Author.objects.get(last_name='Rowling')
for book in author.books.all():
    print(book.title)  # 输出: Harry Potter
</code></pre>
<h3 id="高级配置">高级配置</h3>
<p>禁用外键约束：当需要灵活管理关联关系（如允许删除存在关联数据的主表记录）时，可关闭数据库级约束</p>
<pre><code class="language-python">author = models.ForeignKey(
    Author, 
    on_delete=models.SET_NULL,
    related_name='books',
    db_constraint=False,  # 不创建数据库外键约束
    null=True
)
</code></pre>
<p>自定义数据库列名：默认会生成<code>&lt;ClassName&gt;_id</code>列，可通过<code>db_column</code>修改</p>
<pre><code class="language-python">dept_id = models.ForeignKey(
    "SystemDept",
    on_delete=models.SET_NULL,
    db_column="dept_id",  # 显式指定数据库列名
    null=True
)
</code></pre>
<h2 id="二多对多关系-manytomanyfield">二、多对多关系： ManyToManyField</h2>
<p>多对多关系适用于 "作者 - 书籍" 的另一种场景：假设一个作者可以写多本书，一本书也可以有多个作者。</p>
<h3 id="定义关系-1">定义关系</h3>
<p>Django 会自动创建中间表（默认名为<code>appname_book_authors</code>）存储关联关系，无需手动定义。</p>
<pre><code class="language-python">from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

    def __str__(self):
        return self.name

class Book(models.Model):
    title = models.CharField(max_length=200)
    publication_date = models.DateField()
    # 多对多关联Author
    authors = models.ManyToManyField(Author, related_name='books')

    def __str__(self):
        return self.title
</code></pre>
<h3 id="数据操作示例-1">数据操作示例</h3>
<p>添加 / 移除关联</p>
<pre><code class="language-python"># 创建实例
author1 = Author.objects.create(name='Alice', email='alice@example.com')
author2 = Author.objects.create(name='Bob', email='bob@example.com')
book = Book.objects.create(title='Example Book', publication_date='2023-01-01')

# 添加关联
book.authors.add(author1, author2)

# 移除关联
book.authors.remove(author1)
</code></pre>
<p>查询操作</p>
<pre><code class="language-python"># 正向查询：书籍的所有作者
book = Book.objects.get(title='Example Book')
for author in book.authors.all():
    print(author.name)

# 反向查询：作者的所有书籍
author = Author.objects.get(name='Bob')
for book in author.books.all():  # related_name='books'
    print(book.title)
</code></pre>
<h3 id="自定义中间表">自定义中间表</h3>
<p>当需要存储关联关系的额外信息（如邀请原因、加入时间）时，可自定义中间表</p>
<pre><code class="language-python">class Membership(models.Model):
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    inviter = models.ForeignKey(Person, related_name="invites", on_delete=models.CASCADE)
    invite_reason = models.CharField(max_length=64)  # 额外信息

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(
        Person,
        through="Membership",  # 指定中间表
        through_fields=("group", "person"),  # 关联字段
    )
</code></pre>
<h2 id="三性能优化技巧">三、性能优化技巧</h2>
<p>select_related：用于一对多关系，提前加载关联对象，减少数据库查询</p>
<pre><code class="language-python"># 普通查询（N+1问题）
entries = Entry.objects.all()
for entry in entries:
    print(entry.blog.name)  # 每次循环都会触发新查询

# 优化后（仅1次查询）
entries = Entry.objects.select_related('blog').all()
for entry in entries:
    print(entry.blog.name)  # 使用缓存数据
</code></pre>
<p>批量操作：利用update()进行批量更新，避免循环操作</p>
<pre><code class="language-python"># 批量标记站内信为已读
SystemNotifyMessage.objects.filter(
    id__in=ids.split(",")
).update(
    read_status=True, 
    read_time=timezone.now()
)
</code></pre>
<h2 id="四关于是否使用外键约束">四、关于是否使用外键约束</h2>
<p>在实际项目中，是否使用数据库外键约束需要权衡利弊</p>
<p>使用外键的优势</p>
<ul>
<li>数据完整性：数据库级别的约束保证关联数据一致性</li>
<li>开发效率：ORM 自动处理关联查询和级联操作</li>
<li>查询便捷：支持<code>select_related</code>等优化方法，简化多表查询</li>
</ul>
<p>禁用外键的场景</p>
<ul>
<li>高并发系统：外键会增加数据库锁竞争，影响写入性能</li>
<li>分布式架构：分库分表环境下，跨库外键无法生效</li>
<li>复杂迁移：避免循环依赖导致的迁移失败问题</li>
</ul>
<p>折中方案：使用<code>db_constraint=False</code> 参数</p>
<ul>
<li>数据库层面：无外键约束，数据库不会强制校验关联数据的存在性</li>
<li>Django ORM 层面：保留逻辑关联，ORM仍将字段视为外键关系（逻辑关联），支持 ORM 查询、操作语法</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center">特性</th>
<th style="text-align: center"><code>db_constraint=True</code> (默认)</th>
<th style="text-align: center"><code>db_constraint=False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><strong>数据库外键约束</strong></td>
<td style="text-align: center">创建，强制数据一致性</td>
<td style="text-align: center">不创建</td>
</tr>
<tr>
<td style="text-align: center"><strong>级联操作</strong></td>
<td style="text-align: center">数据库自动处理</td>
<td style="text-align: center">仅由 Django ORM 处理</td>
</tr>
<tr>
<td style="text-align: center"><strong>关联数据存在性校验</strong></td>
<td style="text-align: center">数据库强制校验</td>
<td style="text-align: center">不校验（需应用层保障）</td>
</tr>
<tr>
<td style="text-align: center"><strong>ORM 查询支持</strong></td>
<td style="text-align: center">完整支持</td>
<td style="text-align: center">完整支持（逻辑外键保留）</td>
</tr>
<tr>
<td style="text-align: center"><strong>性能影响</strong></td>
<td style="text-align: center">外键约束带来额外开销</td>
<td style="text-align: center">无约束开销</td>
</tr>
<tr>
<td style="text-align: center"><strong>适用场景</strong></td>
<td style="text-align: center">强数据一致性需求</td>
<td style="text-align: center">高频写入/跨库/历史数据迁移</td>
</tr>
</tbody>
</table>
<h2 id="五多对多关系实战">五、多对多关系实战</h2>
<p>实战场景：在一个后台管理系统中，用户与角色往往是多对多关系。一个用户可以分配多个角色，一个角色也可以属于多个用户。</p>
<p><img alt="image-20250730171424143" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250730174438056-320003089.png" class="lazyload"></p>
<p>模型定义：<a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/myapp_system/user/models.py" target="_blank" rel="noopener nofollow">点击查看完整代码</a></p>
<pre><code class="language-python">class SystemUsers(BaseModel, AbstractBaseUser):
    id = models.BigAutoField(primary_key=True, db_comment="用户ID", help_text="用户ID")
    username = models.CharField(
        max_length=30, unique=True, db_comment="用户账号", help_text="用户账号"
    )
    # ...
    # 与角色多对多关系
    roles = models.ManyToManyField(
        "SystemRole",
        through="SystemUserRole",
        through_fields=("user_id", "role_id"),
        related_name="users",
    )
    # ...    
    
class SystemUserRole(BaseModel):
    """用户和角色关联中间表"""
    id = models.BigAutoField(primary_key=True, db_comment="id")
    user_id = models.ForeignKey(
        "SystemUsers",
        on_delete=models.CASCADE,
        db_constraint=False,
        db_column="user_id",
        db_comment="用户ID",
    )
    role_id = models.ForeignKey(
        "SystemRole",
        on_delete=models.CASCADE,
        db_constraint=False,
        db_column="role_id",
        db_comment="角色ID",
    )

    class Meta:
        managed = True
        db_table = "system_user_role"
        db_table_comment = "用户和角色关联表"
        ordering = ["-id"]
</code></pre>
<p><code>system_user_role</code>数据库生成的中间表</p>
<p><img alt="image-20250730172028007" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250730174448033-1786256577.png" class="lazyload"></p>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-30 17:46">2025-07-30 17:45</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">72</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19013425);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19013425', targetLink: 'https://www.cnblogs.com/xwz1024/p/19013425', title: 'Django模型关系：从一对多到多对多全解析' })">举报</a>
</div>
	