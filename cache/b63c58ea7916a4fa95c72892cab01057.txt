
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jnzhsh/p/18771782" title="发布于 2025-03-14 11:32">
    <span role="heading" aria-level="2">当在 Entity Framework 中先删除实体、再修改其ID 、然后重新添加时发现的实体未被删除</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="问题描述">问题描述</h1>
<p>当在 Entity Framework Core 中先删除实体、再修改其ID 、然后重新添加时发现的实体未被删除。</p>
<h1 id="问题代码示例">问题代码示例</h1>
<pre><code class="language-csharp">using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;

var serviceCollection = new ServiceCollection();

serviceCollection.AddDbContext&lt;DbContext, TestDB&gt;(opt =&gt; opt.UseInMemoryDatabase("test"));
serviceCollection.AddScoped&lt;PostRepo&gt;();

var serviceProvider = serviceCollection.BuildServiceProvider();

var id = Guid.NewGuid();

using (var scope = serviceProvider.CreateScope())
{

    PostRepo repo = scope.ServiceProvider.GetRequiredService&lt;PostRepo&gt;();
    DbContext db = scope.ServiceProvider.GetRequiredService&lt;DbContext&gt;();

    repo.Save(new Post()
    {
        Id = id,
        Name = "123",
        Tags = new List&lt;Tag&gt;() { new Tag() { PostId = id, TagName = "Tag1" } }
    });

    db.SaveChanges();
}

using (var scope = serviceProvider.CreateScope())
{
    PostRepo repo = scope.ServiceProvider.GetRequiredService&lt;PostRepo&gt;();
    DbContext db = scope.ServiceProvider.GetRequiredService&lt;DbContext&gt;();

    var entity = repo.QueryById(id);

    repo.Save(entity);

    db.SaveChanges();
}


using (var scope = serviceProvider.CreateScope())
{
    PostRepo repo = scope.ServiceProvider.GetRequiredService&lt;PostRepo&gt;();
    DbContext db = scope.ServiceProvider.GetRequiredService&lt;DbContext&gt;();

    var entity = repo.QueryById(id);

    Console.WriteLine($"post.Tag Count {entity?.Tags.Count()}");
}

public class TestDB : DbContext
{
    public TestDB(DbContextOptions options) : base(options)
    {
    }


    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {


        base.OnModelCreating(modelBuilder);

    }

    public DbSet&lt;Post&gt; Posts { get; set; }
    public DbSet&lt;Tag&gt; Tags { get; set; }
}

public class Post
{
    public Guid Id { get; set; }
    public string Name { get; set; }

    [NotMapped]
    public List&lt;Tag&gt; Tags { get; set; }
}
public class Tag
{
    public Guid Id { get; set; }
    public Guid PostId { get; set; }
    public string TagName { get; set; }
}

public class PostRepo
{
    private readonly DbContext _db;
    public PostRepo(DbContext db)
    {
        _db = db;
    }

    public Post? QueryById(Guid id)
    {
        var post = _db.Set&lt;Post&gt;().Where(x =&gt; x.Id == id).FirstOrDefault();
        if (post == null)
            return null;
        var tags = _db.Set&lt;Tag&gt;().Where(x =&gt; x.PostId == id).ToList();

        post.Tags = tags;
        return post;
    }

    public void Save(Post entity)
    {
        var isExist = _db.Set&lt;Post&gt;().Where(x =&gt; x.Id == entity.Id).Any();
        if (isExist)
        {
            _db.Update(entity);
        }
        else
        {
            _db.Add(entity);
        }

        if (entity.Tags != null)
        {
            var temp = _db.Set&lt;Tag&gt;().Where(x =&gt; x.PostId == entity.Id).ToList();

            //clean old
            _db.RemoveRange(temp);

            // renew id
            entity.Tags.ForEach(x =&gt; { x.Id = Guid.NewGuid(); });

            // add as new ,this cause old entity state to add
            _db.AddRange(entity.Tags);
        }
    }
}

</code></pre>
<h1 id="问题分析">问题分析</h1>
<p>当我第一次调用<code>RemoveRange</code>时，ChangeTracker 将 tag 标记为 Delete</p>
<p>ChangeTracker的Debug View 如下所示</p>
<pre><code>Tag {Id: 3cb7d0a8-e044-4818-9afd-4f09c20ae60a} Deleted
</code></pre>
<p>当执行完 <code>entity.Tags.ForEach(x=&gt;{ x.Id =  Guid.NewGuid();});</code> 后<br>
ChangeTracker的Debug View 如下所示</p>
<pre><code>Tag {Id: ac9d9fc7-5a8d-4b2e-9ac7-ca1a2778af8d} Deleted
</code></pre>
<p>可以看到 Tag 的Id 产生了变化，这说明 ChangeTracker 追踪的是对象,自此tag的Id产生了变化，便无法删除了对于Id的数据了</p>
<p>当执行后续的<code>AddRanage</code>时，tag就变成了Add<br>
ChangeTracker的Debug View 如下所示</p>
<pre><code>Tag {Id: ac9d9fc7-5a8d-4b2e-9ac7-ca1a2778af8d} Added
</code></pre>
<p>所以就导致了原先想要删除Tag的删除信息丢失。</p>
<p><strong>根本原因</strong>： 就是 add和remove的都是同一个对象的引用，变更Id导致了数据的错位。</p>
<h1 id="解决方案">解决方案</h1>
<p>自行选择</p>
<ol>
<li>使用clone方案</li>
</ol>
<pre><code class="language-csharp">var items =  entity.Tags.Select(x=&gt;x.Clone()).ToList().ForEach(x =&gt; { x.Id = Guid.NewGuid(); });
 _db.AddRange(items);
</code></pre>
<ol start="2">
<li>对于一样Id的使用更新</li>
</ol>
<pre><code class="language-csharp"> var childItems = entity.Tags;
var deleteItem = temp.ExceptBy(childItems.Select(x =&gt; x.Id), x =&gt; x.Id);
var addItem = childItems.ExceptBy(temp.Select(x =&gt; x.Id), x =&gt; x.Id);
var update = childItems.IntersectBy(temp.Select(x =&gt; x.Id), x =&gt; x.Id);


_db.RemoveRange(deleteItem);
_db.AddRange(addItem);
_db.UpdateRange(update);
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.44693024494213" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-14 11:33">2025-03-14 11:32</span>&nbsp;
<a href="https://www.cnblogs.com/jnzhsh">jnzhcn</a>&nbsp;
阅读(<span id="post_view_count">89</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18771782" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18771782);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18771782', targetLink: 'https://www.cnblogs.com/jnzhsh/p/18771782', title: '当在 Entity Framework 中先删除实体、再修改其ID 、然后重新添加时发现的实体未被删除' })">举报</a>
</div>
        