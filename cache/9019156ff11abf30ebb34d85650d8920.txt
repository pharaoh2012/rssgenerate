
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dnboy/p/18680821" title="发布于 2025-01-20 09:53">
    <span role="heading" aria-level="2">分布式系统架构8：分布式缓存</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>这是小卷对分布式系统架构学习的第11篇文章，今天了解分布式缓存的理论知识以及Redis集群。</p>
<p>分布式缓存也是面试常见的问题，通常面试官会问为什么要用缓存，以及用的Redis是哪种模式，用的过程中遇到哪些问题这些</p>
</blockquote>
<h2 id="1-ap还是cp">1. AP还是CP</h2>
<p><strong>Redis 集群就是典型的 AP 式</strong>，它具有高性能、高可用等特点，但它却并不保证强一致性。</p>
<p>而能够保证强一致性的 ZooKeeper、Doozerd、Etcd 等框架，吞吐量比不过Redis，通常不会用作“缓存框架”，而是作为通知、协调、队列、分布式锁等使用</p>
<h2 id="2透明多级缓存tmc">2.透明多级缓存TMC</h2>
<p>实际开发中，同时搭配进程内缓存和分布式缓存，来构成<strong>透明多级缓存</strong>（Transparent Multilevel Cache，TMC）</p>
<p>多级缓存的查询过程如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202501/2784584-20250120095257550-615411805.png" alt="" loading="lazy"></p>
<p>缺点：代码侵入性大，由开发人员维护管理</p>
<p><strong>一、二级缓存数据不一致问题解决：</strong></p>
<ul>
<li>设计原则：<strong>变更以分布式缓存中的数据为准，查询以进程内缓存数据优先</strong></li>
</ul>
<h2 id="3实现方案">3.实现方案</h2>
<h3 id="31-memcached缓存">3.1 memcached缓存</h3>
<p>在服务端，memcached集群环境实际就是一个个memcached服务器的堆积</p>
<p>cache的分布式主要是在客户端实现，通过客户端的路由处理来达到分布式解决方案的目的。客户端做路由的原理，是在每次存取某key的value时，通过一致性哈希算法把key映射到某台memcached服务器node上。</p>
<p>如下是memcached客户端路由过程：</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202501/2784584-20250120095307406-511972235.png" alt="" loading="lazy"></p>
<h3 id="32-redis缓存">3.2 Redis缓存</h3>
<p>与memcached客户端支持分布式方案不同，Redis更倾向于在服务端构建分布式存储</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202501/2784584-20250120095315802-403458278.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202501/2784584-20250120095325248-1007057686.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>以Redis集群模式为例，它没有中心节点，具有线性可伸缩的功能。</p>
</li>
<li>
<p>节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信</p>
</li>
<li>
<p>在数据的放置策略上，Redis Cluster将整个key的数值域分成2的14次方16384个hash槽，每个节点上可以存储一个或多个hash槽，也就是说当前Redis Cluster支持的最大节点数就是16384</p>
</li>
<li>
<p>总结下：数据hash分布在不同redis节点实例，主/从切换采用Sentinel</p>
</li>
<li>
<p>写：只会写master Instance，从sentinel获取当前的master instance；</p>
</li>
<li>
<p>读：从redis node中基于权重选取一个实例读取，失败/超时则轮询其他实例；</p>
</li>
</ul>
<p>要想详细了解redis的面试过程中的问题，可以参考下面的思维导图自行整理：</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202501/2784584-20250120095334728-615901251.png" alt="" loading="lazy"></p>
<h2 id="4-缓存风险">4. 缓存风险</h2>
<h3 id="41-缓存穿透">4.1 缓存穿透</h3>
<p>缓存风险问题也是面试常考的八股文题目，这里还是简单说明下</p>
<p><strong>缓存穿透</strong>：查询的数据在数据库里根本不存在，缓存里也不会有，这样的请求每次都不会命中缓存，会请求到末端数据库。这种<strong>查询不存在数据的现象</strong>就是缓存穿透</p>
<p>解决办法：</p>
<ul>
<li><strong>对业务逻辑本身不能避免的缓存穿透</strong>：对返回为空的Key值进行缓存，如果数据库中对该key插入新记录，就需要主动清理缓存的key值。</li>
<li><strong>恶意攻击导致的缓存穿透</strong>：缓存之前设置一个布隆过滤器来解决，思路就是判断请求的数据是否存在，布隆过滤器可以判断某个元素是否在集合中</li>
</ul>
<h3 id="42-缓存击穿">4.2 缓存击穿</h3>
<p>概念：<strong>单个热点key失效</strong>，在失效的那一刻，同时有大量请求打到DB上，造成数据库压力剧增的情况</p>
<p>解决办法：</p>
<ul>
<li>设置<strong>热点key不过期</strong>，<strong>定时任务更新缓存</strong>或者设置<strong>互斥锁</strong>，当请求过来时，发现缓存不存在数据时，就给当前请求加锁，后面的请求等待或者返回，当从数据库中拿出来放到缓存中时，就可以释放锁资源。</li>
</ul>
<h3 id="43-缓存雪崩">4.3 缓存雪崩</h3>
<p>概念：<strong>多个热点key缓存失效</strong>，大量的key设置了相同的过期时间、导致缓存在同一时间全部失效，造成瞬时DB请求量大、压力剧增。</p>
<p>解决办法：</p>
<ul>
<li>存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>启用透明多级缓存，多个服务节点因为加载一级缓存的时间不一样，也能分散过期时间</li>
</ul>
<h3 id="44-缓存污染">4.4 缓存污染</h3>
<p>概念：缓存中的数据与真实数据源中的数据不一致的现象</p>
<p>解决办法：</p>
<p>使用更新缓存时遵循的设计模式，如：Cache Aside，Read/Write Through，Write Behind Caching这些</p>
<p>Cache Aside模式的工作方式：</p>
<ul>
<li>读数据时，先读缓存，如缓存中没有，则读数据库，再将数据写入缓存中；</li>
<li>写数据时，先写数据库，然后失效缓存（删除缓存数据）；</li>
</ul>
<p>面试可能遇到的两个关于Cache Aside的问题：</p>
<p><strong>1.更新先后顺序，为什么先更新数据库再删除缓存？</strong></p>
<ul>
<li>假设先删除缓存再更新数据库，会有一段时间是缓存已删除，数据库未更新的情况。这时如果有请求进来，缓存中没查到，就会查数据库中旧的数据，再放到缓存里。造成问题就是：数据库已经是最新数据，缓存中还是旧的，不一致的问题；</li>
</ul>
<p><strong>2.为什么是删除缓存，而不是更新缓存？</strong></p>
<ul>
<li>和上面一样，更新过程中，如果有其他更新请求进来更新数据库，缓存就会面临多次修改赋值的复杂时序问题。所以直接删除缓存就行。</li>
</ul>
<p>总结：本文只写了一些关于分布式缓存的简单理论内容，实际面试时大多围绕redis进行提问，下次再写关于redis的相关内容</p>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.9629334034837963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 09:54">2025-01-20 09:53</span>&nbsp;
<a href="https://www.cnblogs.com/dnboy">卷福同学</a>&nbsp;
阅读(<span id="post_view_count">230</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18680821" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18680821);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18680821', targetLink: 'https://www.cnblogs.com/dnboy/p/18680821', title: '分布式系统架构8：分布式缓存' })">举报</a>
</div>
