
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/www-htz-pw/p/18996832/xing-neng-you-hua-liang-tiaosql-suo-yin-you-huacpu" title="发布于 2025-07-21 22:51">
    <span role="heading" aria-level="2">性能优化：两条SQL索引优化，CPU占用率从40%降至25%</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<blockquote>
<p>我们的文章会在微信公众号<a href="https://mp.weixin.qq.com/s/Gkmr9MArgh_4vMXhVvQULA" rel="noopener nofollow">IT民工的龙马人生</a>和<a href="http://www.htz.pw" rel="noopener nofollow">博客网站</a>( <a href="http://www.htz.pw" rel="noopener nofollow">www.htz.pw</a> )同步更新 ，欢迎关注收藏，也欢迎大家转载，但是请在文章开始地方标注文章出处，谢谢！<br>
由于博客中有大量代码，通过页面浏览效果更佳。</p>
</blockquote>
<h2><a id="%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E4%B8%8D%E5%AF%BB%E5%B8%B8%E7%9A%84cpu%E5%91%8A%E8%AD%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、问题背景：不寻常的CPU告警</h2>
<p>近日，一位在医院工作的朋友找到我，说他们核心HIS系统的CPU使用率突然攀升至40%，而历史水平一直在20%左右，希望我能帮忙排查。凭借经验，我判断这很可能是一个典型的SQL性能问题。</p>
<p>果不其然，从分析到解决，整个过程不到10分钟。本文将完整复盘我的分析思路，希望能为大家提供一个高CPU消耗场景下的性能优化实战参考。</p>
<h2><a id="%E4%BA%8C%E3%80%81%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、性能诊断</h2>
<h3><a id="2-1%E5%AE%9A%E4%BD%8D-cpu%E6%B6%88%E8%80%97%E6%9D%A5%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 定位CPU消耗来源</h3>
<p>接到问题后，我首先请朋友帮忙执行<code>top</code>命令，获取CPU使用率的详细分解。单纯一个“40%”的指标过于笼统，我们需要深入分析CPU时间的具体去向。</p>
<pre><code class="language-plain_text">Cpu(s): 45.3%us,  2.5%sy,  0.0%ni, 50.8%id,  1.1%wa,  0.0%hi,  0.3%si,  0.0%st
</code></pre>
<p>我们重点关注以下三项：</p>
<ul>
<li><code>us</code> (user space)：用户空间程序占用的CPU百分比。在我们的场景中，这主要指向Oracle数据库进程。</li>
<li><code>sy</code> (system space)：内核空间占用的CPU百分比，通常为操作系统内核、驱动等消耗。</li>
<li><code>wa</code> (I/O wait)：CPU等待I/O操作完成的时间百分比。</li>
</ul>
<p>从<code>top</code>的输出可以看到，用户空间（us）占用了高达45.3%的CPU，而系统内核（sy）和IO等待（wa）的占比都非常低。这清晰地表明：<strong>系统的IO性能没有瓶颈，问题根源在于Oracle数据库自身消耗了过多的CPU资源。</strong></p>
<p>那么，什么情况下Oracle会消耗大量CPU而IO压力不大呢？常见原因包括：</p>
<ul>
<li><strong>密集的内存运算</strong>：如大量的逻辑读（Logical Reads）、复杂的函数或表达式计算、高频的Mutex/Latch争用等。</li>
<li><strong>低效的程序代码</strong>：如循环嵌套、无谓计算的PL/SQL或Java存储过程。</li>
<li><strong>特定内部功能</strong>：如Oracle的In-Memory (IM) Columnar Store等。</li>
</ul>
<p>在当前大内存服务器普及的背景下，这种“高CPU、低IO”的性能问题正变得越来越普遍。</p>
<h3><a id="2-2%E9%94%81%E5%AE%9A%E9%97%AE%E9%A2%98-sql" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 锁定问题SQL</h3>
<p>明确了方向后，我让朋友运行诊断脚本，重点关注处于<code>ON CPU</code>状态的会话及其执行的SQL。很快，我们就锁定了罪魁祸首，并通过关联<code>v$active_session_history</code>视图，获取了其执行计划和资源消耗情况。</p>
<pre><code class="language-plain_text">****************************************************************************************
PLAN STAT FROM ASH
****************************************************************************************
SQL_ID  f0kfhaa3z2p0f, child number 0
-------------------------------------
SELECT  ID,JK,ZJ,YWRQ,REQJSON,MESSAGEDRGS,RESPJSON,ISUPLOAD,MARK,CREATED
TIME,MODIFIEDTIME,NOTE,JKCODE  FROM HT_HTZZ_HTZPWD  WHERE MARK='1'
AND (JKCODE = :1  AND ZJ = :2  AND ISUPLOAD = :3 )
Plan hash value: 1313371775
------------------------------------------------------------------------------------
| Id  | Operation         | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |                |       |       |   117K(100)|          |CPU(2)(0%)                           |
|*  1 |  TABLE ACCESS FULL| TB_HMYY_UPLOAD |     1 |  1357 |   117K  (1)| 00:23:35 |CPU(92037)(100%)                     |
------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
1 - filter(("ZJ"=:2 AND "JKCODE"=:1 AND "ISUPLOAD"=:3 AND "MARK"='1'))

</code></pre>
<p>执行计划一目了然：<strong>全表扫描（TABLE ACCESS FULL）</strong>。<code>CPU(92037)(100%)</code>指标显示，几乎100%的成本都消耗在CPU上。这完美印证了我们之前的判断。</p>
<h3><a id="2-3%E9%87%8F%E5%8C%96%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.3 量化性能瓶颈</h3>
<p>为了进一步确认创建索引的必要性，我们用数据说话。通过分析历史执行记录，我们得到了更精确的性能指标：</p>
<pre><code class="language-plain_text">                                  PLAN            CPU      ELA      IO       ROWS     WRITE    GET      DISK     ROWS
END_TI I NAME               HASH VALUE EXEC       PRE EXEC PRE EXEC PER EXEC PRE EXEC PER EXEC PRE EXEC PRE EXEC PRE FETC
------ - --------------- ------------- ---------- -------- -------- -------- -------- -------- -------- -------- --------
16 09  1 HTZZ               1313371775 30         49.92s   50.09s   4.9ms    .97      0        45.13W   13.3     1
16 10  1 HTZZ               1313371775 30         51.45s   51.53s   .07ms    .97      0        45.13W   .17      1
16 10  1 HTZZ               1313371775 30         52.28s   53.37s   56.32ms  1        0        45.13W   138.93   1
</code></pre>
<p>关键数据解读：</p>
<ul>
<li><strong><code>ROWS PRE EXEC</code> (每次执行返回行数)</strong>：接近1。说明该查询非常高效，每次只返回极少数记录。</li>
<li><strong><code>GET PRE EXEC</code> (每次执行逻辑读)</strong>：高达 <strong>45万</strong>。为了找出1行数据，却扫描了45万个数据块，这是典型的低效查询。</li>
<li><strong><code>CPU PRE EXEC</code> (每次执行CPU耗时)</strong>：约50秒。巨大的CPU消耗完全源于海量的逻辑读。</li>
</ul>
<p>数据不会说谎，全表扫描导致了“高逻辑读、低返回行”的性能灾难，创建索引势在必行。</p>
<h3><a id="2-4%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.4 选择索引列</h3>
<p>那么，应该在哪一列上创建索引呢？<code>WHERE</code>子句涉及<code>JKCODE</code>, <code>ZJ</code>, <code>ISUPLOAD</code>, <code>MARK</code>四列。我们通过查询数据字典来分析这些列的选择性（selectivity）。</p>
<pre><code class="language-plain_text">COLUMN                                                            NUM      NUM               AVG                     LAST
NAME                                     NL      DENSITY        NULLS DISTINCT  BUCK      COL LEN  SAMPLE_SIZE HIST  ANALYZED
---------------------------------------- -- ------------ ------------ -------- ----- ------------ ------------ ----- --------
ID(VARCHAR2(64))                         N             0            0  2264030     1          20     2,264,030 NONE  20250711
JK(VARCHAR2(128))                        Y             0           10        7     7          30         5,469 FREQU 20250711
ZJ(VARCHAR2(128))                        Y             0            0  2076160   254          46         5,469 HEIGH 20250711
YWRQ(DATE(7))                            Y             0            0   586496   254           8         5,469 HEIGH 20250711
REQJSON(CLOB(4000))                      Y             0            0        0     0         964     2,264,030 NONE  20250711
MESSAGEDRGS(NVARCHAR2(4000))             Y             0            0       22     1          18     2,264,030 NONE  20250711
RESPJSON(CLOB(4000))                     Y             0            0        0     0         244     2,264,030 NONE  20250711
ISUPLOAD(CHAR(1))                        Y             0            0        2     2           2         5,469 FREQU 20250711
</code></pre>
<p><code>NUM DISTINCT</code>列显示了每列的唯一值数量。可以看到，<code>ZJ</code>列的唯一值数量（2,076,160）非常接近表的总行数（2,264,030），具有极高的选择性。因此，在<code>ZJ</code>列上创建索引是最佳选择。</p>
<h2><a id="%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%9C%A8%E7%BA%BF%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、解决方案：在线创建索引</h2>
<p>考虑到这是在线业务系统，为避免影响正常运行，我们采用<code>ONLINE</code>方式创建索引。</p>
<pre><code class="language-sql">create index hrip.ind_HT_HTZZ_HTZPWD_1 on hrip.HT_HTZZ_HTZPWD (ZJ)  online parallel 10 tablespace HTZZ;
alter index hrip.ind_HT_HTZZ_HTZPWD_1 noparallel;
</code></pre>
<h2><a id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、总结与反思</h2>
<p>索引创建后，效果立竿见影。系统CPU使用率迅速回落至正常水平。</p>
<pre><code class="language-plain_text">Cpu(s): 27.1%us,  2.7%sy,  0.0%ni, 68.8%id,  1.2%wa,  0.0%hi,  0.2%si,  0.0%st
</code></pre>
<p>经了解，这两条问题SQL都源于一个新上线的业务模块。这次“小事故”也暴露了一个普遍存在于许多企业的典型问题：<strong>业务上线前缺乏充分的性能测试和SQL审核</strong>。</p>
<p>这个案例虽然简单，但其反映的问题却值得我们深思。在此，我提出几点建议，希望能引起开发者、DBA和项目管理者的重视：</p>
<ol>
<li>
<p><strong>建立SQL审核制度</strong>：任何新功能或SQL变更上线前，都应由DBA或资深开发人员进行审核（Code Review）。重点关注查询是否使用了合适的索引、是否存在潜在的全表扫描、以及连接逻辑是否最优。</p>
</li>
<li>
<p><strong>性能测试左移</strong>：不要把性能测试推到上线前的最后一环。开发人员在开发阶段就应该关注SQL性能，利用<code>EXPLAIN PLAN</code>分析执行计划，并在开发库中进行小规模的压力测试。</p>
</li>
<li>
<p><strong>强化“数据导向”的优化思维</strong>：性能优化不能仅凭感觉。要善于利用数据库提供的性能视图（如AWR, ASH）和诊断工具，用数据定位瓶颈，用数据验证优化效果。</p>
</li>
<li>
<p><strong>培养开发人员的数据库意识</strong>：开发人员是SQL的生产者，他们的代码质量直接决定了数据库的健康状况。企业应定期组织培训，提升开发团队的数据库基础知识，让他们理解索引原理、执行计划、事务隔离等核心概念。</p>
</li>
</ol>
<p>幸运的是，强大的硬件和稳健的Oracle数据库为许多未经严格审查的业务提供了缓冲。但技术债终有需要偿还的一天。建立规范的开发、测试和上线流程，才是保障系统长期稳定、高效运行的根本之道。</p>
<p>------------------作者介绍-----------------------<br>
姓名：黄廷忠<br>
现就职：Oracle中国高级服务团队<br>
曾就职：OceanBase、云和恩墨、东方龙马等<br>
电话、微信、QQ：18081072613<br>
<a href="http://www.htz.pw" rel="noopener nofollow">个人博客:</a> (<a href="http://www.htz.pw" rel="noopener nofollow">http://www.htz.pw</a>)<br>
<a href="https://blog.csdn.net/wwwhtzpw" rel="noopener nofollow">CSDN地址:</a> (<a href="https://blog.csdn.net/wwwhtzpw" rel="noopener nofollow">https://blog.csdn.net/wwwhtzpw</a>)<br>
<a href="https://www.cnblogs.com/www-htz-pw">博客园地址:</a> (<a href="https://www.cnblogs.com/www-htz-pw">https://www.cnblogs.com/www-htz-pw</a>)<br>
<img alt="" data-src="http://htzaliyun.cdhtz.com/uPic/Y44TWC.png" class="lazyload"></p>
<hr>

</div>
<div id="MySignature" role="contentinfo">
    提供ORACLE技术支持(系统优化，故障处理，安装升级，数据恢复等） TEL:18081072613，微信、QQ同手机号。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-21 22:51">2025-07-21 22:51</span>&nbsp;
<a href="https://www.cnblogs.com/www-htz-pw">认真就输</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18996832);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18996832', targetLink: 'https://www.cnblogs.com/www-htz-pw/p/18996832/xing-neng-you-hua-liang-tiaosql-suo-yin-you-huacpu', title: '性能优化：两条SQL索引优化，CPU占用率从40%降至25%' })">举报</a>
</div>
        