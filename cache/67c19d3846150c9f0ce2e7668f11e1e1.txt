
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhuweisky/p/18817793" title="发布于 2025-04-10 10:30">
    <span role="heading" aria-level="2">在IM即时通讯系统中接入DeepSeek等AI大模型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        随着DeepSeek的热潮，越来越多的企业也开始部署并训练自己的AI大模型，于是有客户希望能在私有部署的即时通讯系统中集成AI大模型，这样可以大大提升办公效率。那么如何实现在IM中集成大模型了？
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　 随着DeepSeek的热潮，越来越多的企业也开始部署并训练自己的AI大模型，这样能使企业以前沉淀的专业知识和经验能更高效地被利用起来。有客户反馈了这样的需求场景：客户私有部署了自己的AI大模型以及私有化部署自己的内部即时通讯系统，他们希望可以在即时通讯的聊天界面中，直接和AI大模型对话，就像和同事对话一样，这将大大提升工作效率。所以，我们决定在&nbsp;<a href="https://www.oraytalk.com" target="_blank" rel="noopener nofollow">傲瑞通（OrayTalk）</a>&nbsp;中接入DeepSeek等AI大模型，来满足这一需求。</p>
<p>　　 那么具体如何实现了？</p>
<h2>1. 客户端UI实现</h2>
<p>　　 首先，傲瑞通客户端新增了与AI大模型对话的UI入口：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/9005/202504/9005-20250410095953913-616065234.png" alt="" width="602" height="452"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 在我的好友中，有一个“AI智能体”，点击它，就可以和AI大模型进行对话了。</p>
<p>　　 其次，傲瑞通客户端也提供了查询与AI对话的历史记录：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/9005/202504/9005-20250410100133318-988707878.png" alt="" width="390" height="496"></p>
<p>　　 点击对话记录中的问题，会弹出新窗口显示问题的答案。</p>
<p>　　&nbsp;<img src="https://img2024.cnblogs.com/blog/9005/202504/9005-20250410100232855-53572758.png" alt="" width="388" height="291"></p>
<h2>2. 数据库实现</h2>
<p>　　&nbsp;数据库中增加AIChatRecord表，用于存储与AI的对话记录。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AIChatRecord 表的创建脚本如下所示：</p>
<div class="cnblogs_code">
<pre>CREATE TABLE [dbo]<span>.AIChatRecord(
    [GUID] [nvarchar](50) NOT NULL<span>,
    [UserID] [nvarchar](50) NOT NULL<span>,
    [ModelType] [int] NOT NULL<span>,
    [Question] [nvarchar](max) NOT NULL<span>,
    [Attachments] [nvarchar](1000) NOT NULL<span>,
    [Answer] [nvarchar](max) NOT NULL<span>,
    [ProcessResult] [int] NOT NULL<span>,
    [ErrorMessage] [nvarchar](max) NOT NULL<span>,
    [CreateTime] [datetime] NOT NULL<span>,
 CONSTRAINT [PK_AIChatRecord] PRIMARY KEY CLUSTERED<span> 
(
    [GUID] ASC<span>
)</span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>　　&nbsp;AIChatRecord 表中几个关键字段的含义如下所示：</p>
<p>（1）ModelType：用于记录所采用的大模型类型，比如DeepSeek、通义千问、文心一言 等等。</p>
<p>（2）Question：记录所提问的问题。</p>
<p>（3）Attachments：表示该问题所涉及的附件的URL，如图片或文件的URL。</p>
<p>（4）ProcessResult：表示问题的处理结果。0表示成功，其它值表示不同类型的错误，如超时、API调用报错等。</p>
<p>（5）ErrorMessage：如果有报错，ErrorMessage字段记录了具体的错误信息。</p>
<p>（6）Answer：AI给出的问题的答案。只有当ProcessResult为0时，该值才有效。　　</p>
<h2>3. 服务端对接AI大模型</h2>
<p>　　 傲瑞通服务端实现了与私有部署的大模型（如DeepSeek、通义千问等）的对接。</p>
<p>　　 使用C#调用DeepSeek 的API是相当简单的，示例如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> DeepSeekApiClient
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> _apiKey;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> HttpClient _httpClient;
    
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 构造函数，传入你的API密钥</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> DeepSeekApiClient(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> apiKey)
    {
        _apiKey </span>=<span style="color: rgba(0, 0, 0, 1)"> apiKey;
        _httpClient </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpClient();
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置基础URL（根据DeepSeek API文档调整）</span>
        _httpClient.BaseAddress = <span style="color: rgba(0, 0, 255, 1)">new</span> Uri(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">https://api.deepseek.com/v1/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置授权头</span>
        _httpClient.DefaultRequestHeaders.Add(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Authorization</span><span style="color: rgba(128, 0, 0, 1)">"</span>, $<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Bearer {_apiKey}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }
    
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 发送聊天请求的异步方法</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; SendChatRequestAsync(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> prompt)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
        {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 构造请求体</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> requestBody = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">
            {
                model </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">deepseek-chat</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 根据API文档调整模型名称</span>
                messages = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">[]
                {
                    </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">
                    {
                        role </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">user</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
                        content </span>=<span style="color: rgba(0, 0, 0, 1)"> prompt
                    }
                },
                temperature </span>= <span style="color: rgba(128, 0, 128, 1)">0.7</span><span style="color: rgba(0, 0, 0, 1)">,
                max_tokens </span>= <span style="color: rgba(128, 0, 128, 1)">1000</span><span style="color: rgba(0, 0, 0, 1)">
            };
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 序列化为JSON</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> json =<span style="color: rgba(0, 0, 0, 1)"> JsonSerializer.Serialize(requestBody);
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> content = <span style="color: rgba(0, 0, 255, 1)">new</span> StringContent(json, Encoding.UTF8, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">application/json</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 发送POST请求</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> response = <span style="color: rgba(0, 0, 255, 1)">await</span> _httpClient.PostAsync(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">chat/completions</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, content);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 确保请求成功</span>
<span style="color: rgba(0, 0, 0, 1)">            response.EnsureSuccessStatusCode();
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读取并返回响应内容</span>
            <span style="color: rgba(0, 0, 255, 1)">var</span> responseContent = <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> response.Content.ReadAsStringAsync();
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> responseContent;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception ex)
        {
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Error calling DeepSeek API: {ex.Message}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span><span style="color: rgba(0, 0, 0, 1)">;
        }
    }
}</span></pre>
</div>
<p>　　服务端的主要业务逻辑如下：</p>
<p>（1）当服务端收到来自客户端的AI提问时，便在DB中插入一条记录，该记录的ProcessResult字段的值是“处理中”，然后将该问题通过上面的DeepSeekApiClient提交给AI大模型，并等待回复。</p>
<p>（2）当服务端收到了AI大模型的回复（或超时、或报错）后，再更新DB中对应的那条记录的ProcessResult、Answer等字段的值。接着，再将AI回复发送给客户端。</p>
<p>（3）特殊情况处理：比如，当在等待大模型回复期间，如果客户端掉线了的情况。</p>
<p>　　到这里，在<a href="https://www.oraytalk.com" target="_blank" rel="noopener nofollow">傲瑞通</a>中集成DeepSeek等AI大模型的工作就完成了，有兴趣的朋友欢迎留言多多交流！</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6442719198472222" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-10 10:53">2025-04-10 10:30</span>&nbsp;
<a href="https://www.cnblogs.com/zhuweisky">zhuweisky</a>&nbsp;
阅读(<span id="post_view_count">229</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18817793" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18817793);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18817793', targetLink: 'https://www.cnblogs.com/zhuweisky/p/18817793', title: '在IM即时通讯系统中接入DeepSeek等AI大模型' })">举报</a>
</div>
        