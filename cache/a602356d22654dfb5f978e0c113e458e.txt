
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/belgnas/p/18845660" title="发布于 2025-04-24 23:57">
    <span role="heading" aria-level="2">刷题：奇怪的电梯</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="题目名称字符串的展开">题目名称：字符串的展开</h1>
<p>时间：2025年4月25日</p>
<p>知识点：dfs、dijkstra...(应该有好多种解法)</p>
<hr>
<p>网址：<a href="https://www.luogu.com.cn/problem/P1135" target="_blank" rel="noopener nofollow">洛谷 P1135 奇怪的电梯</a></p>
<p>来源：散题</p>
<hr>
<p>个人感想：一道很好写，但是超超超难优化的，dfs题喵（应该还有其他的解法的说）</p>
<p>思路：</p>
<ul>
<li>刚开始写的时候花了不到20分钟就写了一个简单的dfs，果不其然STL了，于是开始想方设法优化减枝，先是尝试了能不能通过判断当前楼层到达的次数是否大于2来判断，发现完全没用，并且因为我的回溯出了问题导致反而通过的数据减少了，后来，我突然发现这题完全可以看成dijkstra来写，于是参考了dijkstra（记录一个点到其他所有点的最短距离）的思路，经过一番调试才写出来了，总用时大概1h。</li>
</ul>
<p>收获：（有的话就写）</p>
<ul>
<li>没有语法上的收获</li>
</ul>
<p>埋坑：要不我们再写个bfs和dijkstra的版本？</p>
<hr>
<p>完整代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

#define INF 0x3f3f3f3f

const int N = 210;

int nex[N], floor_min[N]; // nex数组存储每层可移动的层数，floor_min数组存储起点到每一层的最短步数
int n, st, ed;

void dfs(int floor, int step)
{
    floor_min[floor] = step; // 记录当前路径到达该楼层的步数（一定是更优的才会进入）

    // 向下移动
    if (floor - nex[floor] &gt;= 1 &amp;&amp; step + 1 &lt; floor_min[floor - nex[floor]]) // 若向下移动合法且步数更优
    {
        dfs(floor - nex[floor], step + 1);
    }

    // 向上移动
    if (floor + nex[floor] &lt;= n &amp;&amp; step + 1 &lt; floor_min[floor + nex[floor]]) // 若向上移动合法且步数更优
    {
        dfs(floor + nex[floor], step + 1);
    }
}

int main()
{
    IOS;
    memset(floor_min, INF, sizeof(floor_min)); // 初始化最短步数为无穷大

    cin &gt;&gt; n &gt;&gt; st &gt;&gt; ed; // 输入总楼层数、起点、终点
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; nex[i];

    floor_min[st] = 0; // 起点步数为0（初始位置无需移动）
    dfs(st, 0);  // 从起点开始搜索

    cout &lt;&lt; (floor_min[ed] == INF ? -1 : floor_min[ed]) &lt;&lt; endl; // 看了题解后果断放弃了自己单纯的if-else判断

    return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.009673201512731482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 00:08">2025-04-24 23:57</span>&nbsp;
<a href="https://www.cnblogs.com/belgnas">Belgnas</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18845660);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18845660', targetLink: 'https://www.cnblogs.com/belgnas/p/18845660', title: '刷题：奇怪的电梯' })">举报</a>
</div>
        