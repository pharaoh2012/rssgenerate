
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18963990" title="发布于 2025-07-03 17:04">
    <span role="heading" aria-level="2">10亿订单如何分库分表？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p><strong>场景痛点</strong>：某电商平台的MySQL订单表达到7亿行时，出现致命问题：</p>
<pre><code class="language-sql">-- 简单查询竟需12秒！
SELECT * FROM orders WHERE user_id=10086 LIMIT 10;

-- 统计全表耗时278秒
SELECT COUNT(*) FROM orders;
</code></pre>
<p><strong>核心矛盾</strong>：</p>
<ol>
<li>B+树索引深度达到5层，磁盘IO暴增。</li>
<li>单表超200GB导致备份时间窗突破6小时。</li>
<li>写并发量达8000QPS，主从延迟高达15分钟。</li>
</ol>
<blockquote>
<p><strong>关键认知</strong>：当单表数据量突破<strong>5000万行</strong>时，就该启动分库分表设计预案。</p>
</blockquote>
<p>那么问题来了，假如现在有10亿的订单数据，我们该如何做分库分表呢？</p>
<p>今天这篇文章就跟大家一起聊聊这个问题，希望对你会有所帮助。</p>
<h2 id="1-分库分表核心策略">1 分库分表核心策略</h2>
<h3 id="11-垂直拆分先给数据做减法">1.1 垂直拆分：先给数据做减法</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250703170307643-1823608919.png" class="lazyload"></p>
<p><strong>优化效果</strong>：</p>
<ul>
<li>核心表体积减少60%</li>
<li>高频查询字段集中提升缓存命中率</li>
</ul>
<h3 id="12-水平拆分终极解决方案">1.2 水平拆分：终极解决方案</h3>
<p><strong>分片键选择三原则</strong>：</p>
<ol>
<li><strong>离散性</strong>：避免数据热点（如user_id优于status）</li>
<li><strong>业务相关性</strong>：80%查询需携带该字段</li>
<li><strong>稳定性</strong>：值不随业务变更（避免使用手机号）</li>
</ol>
<p><strong>分片策略对比</strong>：</p>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>适用场景</th>
<th>扩容复杂度</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>范围分片</td>
<td>带时间范围的查询</td>
<td>简单</td>
<td>create_time按月分表</td>
</tr>
<tr>
<td>哈希取模</td>
<td>均匀分布</td>
<td>困难</td>
<td>user_id % 128</td>
</tr>
<tr>
<td>一致性哈希</td>
<td>动态扩容</td>
<td>中等</td>
<td>使用Ketama算法</td>
</tr>
<tr>
<td>基因分片</td>
<td>避免跨分片查询</td>
<td>复杂</td>
<td>从user_id提取分库基因</td>
</tr>
</tbody>
</table>
<h2 id="2-基因分片">2 基因分片</h2>
<p>针对订单系统的三大高频查询：</p>
<ol>
<li>用户查历史订单（user_id）</li>
<li>商家查订单（merchant_id）</li>
<li>客服按订单号查询（order_no）</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250703170328460-578200752.png" class="lazyload"></p>
<p><strong>Snowflake订单ID改造</strong>：</p>
<pre><code class="language-java">// 基因分片ID生成器
public class OrderIdGenerator {
    // 64位ID结构：符号位(1)+时间戳(41)+分片基因(12)+序列号(10)
    private static final int GENE_BITS = 12;
    
    public static long generateId(long userId) {
        long timestamp = System.currentTimeMillis() - 1288834974657L;
        // 提取用户ID后12位作为基因
        long gene = userId &amp; ((1 &lt;&lt; GENE_BITS) - 1); 
        long sequence = ... // 获取序列号
        
        return (timestamp &lt;&lt; 22) 
             | (gene &lt;&lt; 10) 
             | sequence;
    }
    
    // 从订单ID反推分片位置
    public static int getShardKey(long orderId) {
        return (int) ((orderId &gt;&gt; 10) &amp; 0xFFF); // 提取中间12位
    }
}
</code></pre>
<p><strong>路由逻辑</strong>：</p>
<pre><code class="language-java">// 分库分表路由引擎
public class OrderShardingRouter {
    // 分8个库 每个库16张表
    private static final int DB_COUNT = 8; 
    private static final int TABLE_COUNT_PER_DB = 16;
    
    public static String route(long orderId) {
        int gene = OrderIdGenerator.getShardKey(orderId);
        int dbIndex = gene % DB_COUNT;
        int tableIndex = gene % TABLE_COUNT_PER_DB;
        
        return "order_db_" + dbIndex + ".orders_" + tableIndex;
    }
}
</code></pre>
<blockquote>
<p><strong>关键突破</strong>：通过基因嵌入，使相同用户的订单始终落在同一分片，同时支持通过订单ID直接定位分片</p>
</blockquote>
<h2 id="3-跨分片查询">3 跨分片查询</h2>
<h3 id="31-异构索引表方案">3.1 异构索引表方案</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250703170340487-2016773149.png" class="lazyload"></p>
<p><strong>Elasticsearch索引表结构</strong>：</p>
<pre><code class="language-json">{
  "order_index": {
    "mappings": {
      "properties": {
        "order_no": { "type": "keyword" },
        "shard_key": { "type": "integer" },
        "create_time": { "type": "date" }
      }
    }
  }
}
</code></pre>
<h4 id="42-全局二级索引gsi">4.2 全局二级索引（GSI）</h4>
<pre><code class="language-sql">-- 在ShardingSphere中创建全局索引
CREATE SHARDING GLOBAL INDEX idx_merchant ON orders(merchant_id) 
    BY SHARDING_ALGORITHM(merchant_hash) 
    WITH STORAGE_UNIT(ds_0,ds_1);
</code></pre>
<h2 id="4数据迁移">4、数据迁移</h2>
<p><strong>双写迁移方案</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250703170351666-419924960.png" class="lazyload"></p>
<p><strong>灰度切换步骤</strong>：</p>
<ol>
<li>开启双写（新库写失败需回滚旧库）</li>
<li>全量迁移历史数据（采用分页批处理）</li>
<li>增量数据实时校验（校验不一致自动修复）</li>
<li>按用户ID灰度流量切换（从1%到100%）</li>
</ol>
<h2 id="5避坑指南">5、避坑指南</h2>
<h3 id="51-热点问题">5.1 热点问题</h3>
<p>双十一期间发现某网红店铺订单全部分到同一分片。</p>
<p>解决方案：引入复合分片键 <code>(merchant_id + user_id) % 1024</code></p>
<h3 id="52-分布式事务">5.2 分布式事务</h3>
<p>这里的分布式事务使用的RocketMQ的数据最终一致性方案：</p>
<pre><code class="language-java">// 最终一致性方案
@Transactional
public void createOrder(Order order) {
   orderDao.insert(order); // 写主库
   rocketMQTemplate.sendAsync("order_create_event", order); // 发消息
}

// 消费者处理
@RocketMQMessageListener(topic = "order_create_event")
public void handleEvent(OrderEvent event) {
   bonusService.addPoints(event.getUserId()); // 异步加积分
   inventoryService.deduct(event.getSkuId()); // 异步扣库存
}
</code></pre>
<h3 id="53-分页陷阱">5.3 分页陷阱</h3>
<p>跨分片查询页码错乱。</p>
<p>解决方案：改用ES聚合查询或业务折衷方案（只查最近3个月订单）。</p>
<h2 id="6-终极架构方案">6 终极架构方案</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250703170402871-1468268089.png" class="lazyload"></p>
<p><strong>性能指标</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>拆分前</th>
<th>拆分后</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户订单查询</td>
<td>3200ms</td>
<td>68ms</td>
</tr>
<tr>
<td>商家订单导出</td>
<td>超时失败</td>
<td>8s完成</td>
</tr>
<tr>
<td>全表统计</td>
<td>不可用</td>
<td>1.2s(近似)</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<ol>
<li><strong>分片键选择大于努力</strong>：基因分片是订单系统的最佳拍档。</li>
<li><strong>扩容预留空间</strong>：建议初始设计支持2年数据增长。</li>
<li><strong>避免过度设计</strong>：小表关联查询远比分布式Join高。效</li>
<li><strong>监控驱动优化</strong>：重点关注分片倾斜率&gt;15%的库。</li>
</ol>
<blockquote>
<p>真正的架构艺术，是在分与合之间找到平衡点。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-03 17:04">2025-07-03 17:04</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">234</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18963990);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18963990', targetLink: 'https://www.cnblogs.com/12lisu/p/18963990', title: '10亿订单如何分库分表？' })">举报</a>
</div>
        