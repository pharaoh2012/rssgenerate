
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/somefuture/p/18771720" title="发布于 2025-03-14 10:58">
    <span role="heading" aria-level="2">魔方求解器程序（层先法，java版本）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>实现了一个三阶魔方的层先法求解程序：<a href="https://github.com/davelet/java-puzzle-resolver" title="https://github.com/davelet/java-puzzle-resolver" target="_blank" rel="noopener nofollow">https://github.com/davelet/java-puzzle-resolver</a><br>
欢迎试用。</p>
<hr>
<h1 id="用法">用法</h1>
<h2 id="1-随机试用">1. 随机试用</h2>
<p>不关注起始状态的话可以用程序的随机拧乱工具打乱然后复原：</p>
<pre><code class="language-java">    private Cube cube;

    private CubeSolver cubeSolver;
    private CubeShuffler cubeShuffler;

    @BeforeEach
    void setUp() {
        cube = new Cube();
        cubeSolver = new CubeSolver(cube);
        cubeShuffler = new CubeShuffler(cube);
    }
	
    @Test
    void solve_ExecuteBottomCornerSolver() {
            // 打乱魔方，随机拧20次
            cubeShuffler.shuffle(20);
            // 执行测试
            cubeSolver.solve();
            // 验证结果
            assertTrue(cube.isSolved());
    }
</code></pre>
<h2 id="2-特定状态的求解">2. 特定状态的求解</h2>
<p>要把状态初始化成某个特定状态，可以使用Cube的构造器：</p>
<pre><code class="language-java">public class Cube implements Cloneable {
    private final Color[][][] state;

    public Cube() {
        state = new Color[6][SIZE][SIZE];
        initializeCube();
    }

// 使用这个方法传入一个三维数组
    public Cube(Color[][][] state) {
        this.state = state;
        if (!isValid()) {
            throw new IllegalArgumentException("提供的状态不是有效的魔方状态");
        }
    }
	// ...其他代码
	
}
</code></pre>
<p>状态是一个三维数组，维度分别是某个面、某一行、某一列。所以面做多6个（0～5），行和列做多3个。<br>
数组的元素是 <code>Color</code> 枚举对象：</p>
<pre><code class="language-java">public enum Color {
    WHITE("白", "\u001B[37m"),
    YELLOW("黄", "\u001B[33m"),
    RED("红", "\u001B[31m"),
    ORANGE("橙", "\u001B[38;5;208m"),
    BLUE("蓝", "\u001B[34m"),
    GREEN("绿", "\u001B[32m");
	// ...
}
</code></pre>
<h3 id="特别要注意的是这里要求市场标准魔方且不能转动魔方的方向">特别要注意的是，这里要求市场标准魔方且不能转动魔方的方向</h3>
<p>也就是说，魔方的六个面必需遵守 <em>上黄下白前蓝后绿左橙右红</em> 的布局；这样就要求状态数组中每个面的中心块 （<code>state[face][1][1]</code>）对应是面的颜色。</p>
<h1 id="求解">求解</h1>
<p>层先法的逻辑毕竟简单清晰。但是我实现过程中也查了非常多资料，因为不同博客对层先法的过程说得不一样，尤其是顶层还原的时候。<br>
而且我要实现的是求解过程不转动魔方方向，只拧某一层。很多资料都让上下颠倒魔方，或者找一个目标块放到左（右）手边。</p>
<p>求解过程每次拧动魔方（执行一套公式，里面会包含拧动好几次），都会打印日志：<br>
<img src="https://img2024.cnblogs.com/blog/2157887/202503/2157887-20250314105314689-1320257438.png" alt="image" loading="lazy"><br>
日志中的魔方是按照“上面、后面的镜像、左面、前面、右面、下面”顺序摆放的。<br>
如果某个块的颜色和当前面的颜色一样了，就用圆圈表示。</p>
<h1 id="代码结构">代码结构</h1>
<p><img src="https://img2024.cnblogs.com/blog/2157887/202503/2157887-20250314105752529-1941864521.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05761229221759259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-14 10:59">2025-03-14 10:58</span>&nbsp;
<a href="https://www.cnblogs.com/somefuture">大卫小东（Sheldon）</a>&nbsp;
阅读(<span id="post_view_count">37</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18771720" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18771720);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18771720', targetLink: 'https://www.cnblogs.com/somefuture/p/18771720', title: '魔方求解器程序（层先法，java版本）' })">举报</a>
</div>
        