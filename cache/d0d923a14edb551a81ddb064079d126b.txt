
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/songjiyang/p/18986808" title="发布于 2025-07-16 08:56">
    <span role="heading" aria-level="2">SpringSecurity配置和源码解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-背景">1. 背景</h1>
<p>Spring Security最主要的两个功能：<strong>认证和授权</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>解决的问题</th>
<th>Spring Security中主要类</th>
</tr>
</thead>
<tbody>
<tr>
<td>认证（Authentication）</td>
<td>你是谁</td>
<td>AuthenticationManager</td>
</tr>
<tr>
<td>授权（Authorization）</td>
<td>你可以做什么</td>
<td>AuthorizationManager</td>
</tr>
</tbody>
</table>
<p><a href="https://www.cnblogs.com/songjiyang/p/16093636.html" target="_blank">之前的文章</a>讲过了使用Spring Security来接入其他单点登录系统，其中单点登录系统来解决你是谁的问题，Spring Security用来解决你可以做什么的问题</p>
<p>这次我们主要使用Spring Security的认证功能</p>
<p>这次的需求是这样的，我们有一个A服务，A服务内部有n个接口，这些接口根据使用方的不同可以分为三部分</p>
<ol>
<li>C端用户使用的接口，需要c端账户体系鉴权，后续会有网关统一鉴权，目前暂时用账号密码鉴权</li>
<li>B端用户使用的接口，需要b端账户体系鉴权，由其他OAuth2 Server来鉴权</li>
<li>开发人员使用的接口，账号密码鉴权</li>
</ol>
<p><strong>Spring Security版本： 5.3.x</strong></p>
<h1 id="2-目的">2. 目的</h1>
<p>本篇文章的目的是通过实际的场景来让大家如何配置Spring Security来实现自己的需求，明白每一行的配置作用</p>
<h1 id="3-整体配置">3. 整体配置</h1>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Configuration
    @Order(1)
    public static class BSecurityConfig extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .csrf()
              			.disable()
                    .antMatcher("/b/**")
                    .authorizeRequests()
                    .anyRequest()
              			.authenticated()
                    .and()
                    .addFilterBefore(new MyTokenJwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
        }

        @Override
        public void configure(WebSecurity web) {
            web.ignoring().antMatchers("/b/api/auth/access_token");
        }
    }

    @Configuration
    @Order(2)
    public static class CSecurityConfig extends WebSecurityConfigurerAdapter {
        @Value("${algo-api.password}")
        private String password;

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .csrf().disable()
                    .antMatcher("/c/**")
                    .authorizeRequests()
                    .anyRequest()
                    .hasRole("C_ADMIN")
                    .and()
                    .httpBasic();

        }
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.inMemoryAuthentication()
                    .withUser("cAdmin777")
                    .password(password)  
                    .roles("ALGO_ADMIN");
        }
    }

    @Configuration
    @Order(3)
    public static class DevSecurityConfig extends WebSecurityConfigurerAdapter {

        @Value("${swagger.password}")
        private String password;
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .csrf().disable()
                    .authorizeRequests()
                    .antMatchers("/swagger-ui/**", "/v3/api-docs/**", "/test/**")
                    .hasRole("SWAGGER_ADMIN")
                    .antMatchers("/login", "/css/**", "/js/**", "/images/**")
                    .permitAll()
                    .anyRequest()
                    .denyAll()
                    .and()
                    .formLogin();
        }
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.inMemoryAuthentication()
                    .withUser("swaggerAdmin999")
                    .password(password) 
                    .roles("SWAGGER_ADMIN");
        }
    }
}
</code></pre>
<h2 id="31-配置解读">3.1 配置解读</h2>
<h3 id="311-securityconfig类">3.1.1 SecurityConfig类</h3>
<p>首先是一个SecurityConfig类，带了@Configuration和@EnableWebSecurity注解，代表接入了Springboot和开启了SpringSecurity功能</p>
<h3 id="312-websecurityconfigureradapter子类">3.1.2 WebSecurityConfigurerAdapter子类</h3>
<p>内部是三个静态内部类BSecurityConfig、CSecurityConfig、DevSecurityConfig分别对应我们的需求的使用方，B端用户、C端用户和开发人员，他们继承了WebSecurityConfigurerAdapter类，继承此类可以重写其中的方法来进行配置，具体Spring Security是如何做的可以看后面的源码分析<br>
<img src="https://img2024.cnblogs.com/blog/2058002/202507/2058002-20250716085341332-76108607.png" alt="image-20250710160748086" loading="lazy"></p>
<p>从<a href="https://docs.spring.io/spring-security/reference/5.7/servlet/architecture.html#servlet-securityfilterchain" target="_blank" rel="noopener nofollow">Spring Security官方文档</a>中可以看到，使用不同的SecurityFilterChain对不同的url前缀进行安全配置</p>
<p>所以，这里的三个静态内部类就是对应的三个SecurityFilterChain</p>
<blockquote>
<p>那么有的同学可能会问，如果url的路径冲突了怎么办，比如两个SecurityFilterChain的路径前缀一样，那就取决于WebSecurityConfigurerAdapter的子类加载顺序，会使用先匹配的SecurityFilterChain，可以看到我们的静态内部类也使用了@Order(3)这样的注解来标识顺序<br>
<img src="https://img2024.cnblogs.com/blog/2058002/202507/2058002-20250716085243493-1202191825.png" alt="image-20250710162239776" loading="lazy"></p>
</blockquote>
<p>从断点中可以有4个SecurityFilterChain，且每个SecurityFilterChain内部的过滤器数量不同</p>
<p>为什么多了一个SecurityFilterChain，因为在BSecurityConfig中我们忽略了/b/api/auth/access_token路径的安全配置，所以对于这个路径下一个过滤器也没有</p>
<p>WebSecurityConfigurerAdapter类三个的主要的配置方法，也就是我们需要重写的方法：</p>
<pre><code class="language-java">protected void configure(AuthenticationManagerBuilder auth)
public void configure(WebSecurity web)
protected void configure(HttpSecurity http)
</code></pre>
<p><code>AuthenticationManagerBuilder</code>这个类是来配置认证相关的，例如使用内存中的账号密码，还是JDBC的数据来认证，从图中可以看出其作用</p>
<p><img src="https://img2024.cnblogs.com/blog/2058002/202507/2058002-20250716085414288-733686436.png" alt="abstractauthenticationprocessingfilter" loading="lazy"></p>
<h3 id="313-httpsecurity配置">3.1.3 HttpSecurity配置</h3>
<p>这个是我们主要使用的配置类，它的常用方法有：</p>
<p>csrf和cors，具体可以参考我<a href="https://www.cnblogs.com/songjiyang/p/16113846.html" target="_blank">之前的博客</a></p>
<h4 id="3131-match方法">3.1.3.1 Match方法</h4>
<p>这些方法用来指定这个配置是对哪些路径生效的</p>
<ul>
<li>antMatcher</li>
<li>mvcMatcher</li>
<li>regexMatcher</li>
<li>requestMatchers</li>
</ul>
<p>其中requestMatchers是比较灵活的匹配路径的一种方式，适合匹配多个路径</p>
<p><strong>注意：</strong> 区分antMatcher和antMatchers</p>
<table>
<thead>
<tr>
<th></th>
<th>antMatchers</th>
<th>antMatcher</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属类</td>
<td>AbstractRequestMatcherRegistry</td>
<td>HttpSecurity</td>
</tr>
<tr>
<td>参数</td>
<td>多个url通配符</td>
<td>单个url通配符</td>
</tr>
<tr>
<td>作用</td>
<td>细粒度的鉴权，每个路径下面需要的鉴权不同，权限也可能不同</td>
<td>粗粒度的鉴权，每个路径是一个SecurityFilterChain，有一组过滤器</td>
</tr>
</tbody>
</table>
<h4 id="3132-authorizerequests方法">3.1.3.2 authorizeRequests方法</h4>
<p>返回的是<code>ExpressionUrlAuthorizationConfigurer</code>类</p>
<p>用来表示要开启一个细粒度的鉴权，两个方法功能一样，写法不一样，推荐下面这种，可以把某个细粒度的路径的鉴权写到一起，而不是整个链式，难以阅读，后续使用的类是<code>ExpressionInterceptUrlRegistry</code></p>
<ul>
<li>authorizeRequests</li>
<li>authorizeRequests(authorizeRequestsCustomizer)</li>
</ul>
<h5 id="31321-match">3.1.3.2.1 match</h5>
<p>和HttpSecurity一样，细粒度的圈选路径</p>
<ul>
<li>antMatchers，符合表达式的请求</li>
<li>mvcMatchers</li>
<li>regexMatchers</li>
<li>anyRequest，任意请求</li>
</ul>
<h5 id="31322-访问权限">3.1.3.2.2 访问权限</h5>
<p>在圈选完路径之后，声明此路径的鉴权方式，也就是需不需要登录，需要什么权限才能方法</p>
<ul>
<li>permitAll，允许访问</li>
<li>anonymous，允许匿名</li>
<li>rememberMe，记住我</li>
<li>denyAll，不允许访问</li>
<li>authenticated，允许登录后访问</li>
<li>hasRole，需要某个角色可以访问</li>
<li>hasAuthority，需要某个权限可以访问</li>
</ul>
<h4 id="3133-其他">3.1.3.3 其他</h4>
<h5 id="31331-xxxlogin">3.1.3.3.1 xxxLogin</h5>
<p>表示需要此种登录，例如formLogin表示需要进行表单登录，可以指定一些登录页，登录失败页面等，或者默认生成一些页面</p>
<p>oauth2Login表示使用OAuth2.0来做验证，这种就很方便的使用第三方应用来登录，例如支付宝授权登录</p>
<h5 id="31332-sessionmanagement">3.1.3.3.2 sessionManagement</h5>
<p>需要进行session管理</p>
<h5 id="31333-addfilterxxx">3.1.3.3.3 addFilterxxx</h5>
<p>手动的往Spring的过滤器链里面加一个过滤器，实际上，<strong>SpringSecurity所有的功能都是在过滤器链里面加过滤器</strong>，只不过有现成的稳定的类就不用我们自己写的，当现有的满足不了我们的需要时，我们可以自己来实现</p>
<h3 id="314-websecurity配置">3.1.4 WebSecurity配置</h3>
<p>WebSecurity是全局配置类，它的常用方法有：</p>
<ul>
<li>ignoring   配置不做控制的路径</li>
<li>httpFirewall  设置防火墙，拦截非法的请求，非法的http method，包含非法的符号等</li>
<li>debug  开启debug日志</li>
</ul>
<p>上面的代码中，我们对<code>/b/api/auth/access_token</code>路径的请求不做控制</p>
<h1 id="4-源码分析">4. 源码分析</h1>
<p><img src="https://img2024.cnblogs.com/blog/2058002/202507/2058002-20250716084954680-5676681.jpg" alt="spring_security" loading="lazy"></p>
<p>整体架构如上所示：</p>
<ul>
<li>SecurityBuilder和SecurityConfigurer是核心接口类，前者是构建者模式，后者负责定制化配置</li>
<li>HttpSecurity和WebSecurity是SecurityBuilder的两个核心实现类，一个负责收集整体的认证配置，一个负责收集指定路径的认证配置</li>
<li>XXXXSecurityConfigurer代表一系列的配置类，包括前面将的CRSF, CORS，登录、session等各种功能的实现</li>
<li>WebSecurityConfigurerAdapter是适配器模式，通过定制化HttpSecurity和WebSecurity这两个Builder来定制化真正的配置</li>
<li>WebSecurityConfiguration是自动配置类，也是Spring Security的启动类，它调用WebSecurity的init/build方法最终生成一个Filter，作为Servlet容器的一个普通Filter来使用</li>
</ul>
<h2 id="41-enablewebsecurity">4.1 EnableWebSecurity</h2>
<p>我们在使用Spring Security的时候需要加这个注解，这个注解使用@Import导入了WebSecurityConfiguration配置类</p>
<pre><code class="language-java">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@Target(value = { java.lang.annotation.ElementType.TYPE })
@Documented
@Import({ WebSecurityConfiguration.class,
		SpringWebMvcImportSelector.class,
		OAuth2ImportSelector.class })
@EnableGlobalAuthentication
@Configuration
public @interface EnableWebSecurity {

	/**
	 * Controls debugging support for Spring Security. Default is false.
	 * @return if true, enables debug support with Spring Security
	 */
	boolean debug() default false;
}
</code></pre>
<h2 id="42-websecurityconfiguration">4.2 WebSecurityConfiguration</h2>
<p>这个类很关键，下面是这个类的核心方法，通过Value注入了<code>List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt;</code> 这个就是我们配置的多个<code>WebSecurityConfigurerAdapter</code>的类的父类，也就是把我们的实现类都给收集起来，然后排序，最后放到webSecurity这个对象中去</p>
<pre><code class="language-java">	public void setFilterChainProxySecurityConfigurer(
			ObjectPostProcessor&lt;Object&gt; objectPostProcessor,
    	// 我们继承WebSecurityConfigurerAdapter的子类被在这被收集起来
			@Value("#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}") List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)
			throws Exception {
		webSecurity = objectPostProcessor
				.postProcess(new WebSecurity(objectPostProcessor));
		if (debugEnabled != null) {
			webSecurity.debug(debugEnabled);
		}
		// 排序
		webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);

		Integer previousOrder = null;
		Object previousConfig = null;
		for (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) {
			Integer order = AnnotationAwareOrderComparator.lookupOrder(config);
			if (previousOrder != null &amp;&amp; previousOrder.equals(order)) {
				throw new IllegalStateException(
						"@Order on WebSecurityConfigurers must be unique. Order of "
								+ order + " was already used on " + previousConfig + ", so it cannot be used on "
								+ config + " too.");
			}
			previousOrder = order;
			previousConfig = config;
		}
    // 放入webSecurity中
		for (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) {
			webSecurity.apply(webSecurityConfigurer);
		}
		this.webSecurityConfigurers = webSecurityConfigurers;
	
</code></pre>
<p>下面注册了一个Servlet Filter，这个Filter实现了整个Spring Security的功能</p>
<pre><code class="language-java">@Bean(
    name = {"springSecurityFilterChain"}
)
public Filter springSecurityFilterChain() throws Exception {
    boolean hasConfigurers = this.webSecurityConfigurers != null &amp;&amp; !this.webSecurityConfigurers.isEmpty();
  	// 假如开发者没有定制化过WebSecurityConfigurerAdapter，会默认new一个
    if (!hasConfigurers) {
        WebSecurityConfigurerAdapter adapter = (WebSecurityConfigurerAdapter)this.objectObjectPostProcessor.postProcess(new WebSecurityConfigurerAdapter() {
        });
        this.webSecurity.apply(adapter);
    }

    return (Filter)this.webSecurity.build();
}
</code></pre>
<h2 id="42-websecurity">4.2 WebSecurity</h2>
<p>其实没有很多逻辑在里面，基本就是构造者的思想，在不断填充各种属性，包括调用了HttpSecurity的 <code>securityFilterChainBuilder.build()</code></p>
<pre><code class="language-java">	protected Filter performBuild() throws Exception {
		Assert.state(
				!securityFilterChainBuilders.isEmpty(),
				() -&gt; "At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. "
						+ "Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. "
						+ "More advanced users can invoke "
						+ WebSecurity.class.getSimpleName()
						+ ".addSecurityFilterChainBuilder directly");
		int chainSize = ignoredRequests.size() + securityFilterChainBuilders.size();
		List&lt;SecurityFilterChain&gt; securityFilterChains = new ArrayList&lt;&gt;(
				chainSize);
		for (RequestMatcher ignoredRequest : ignoredRequests) {
			securityFilterChains.add(new DefaultSecurityFilterChain(ignoredRequest));
		}
		for (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) {
			securityFilterChains.add(securityFilterChainBuilder.build());
		}
		FilterChainProxy filterChainProxy = new FilterChainProxy(securityFilterChains);
		if (httpFirewall != null) {
			filterChainProxy.setFirewall(httpFirewall);
		}
		filterChainProxy.afterPropertiesSet();

		Filter result = filterChainProxy;
		if (debugEnabled) {
			logger.warn("\n\n"
					+ "********************************************************************\n"
					+ "**********        Security debugging is enabled.       *************\n"
					+ "**********    This may include sensitive information.  *************\n"
					+ "**********      Do not use in a production system!     *************\n"
					+ "********************************************************************\n\n");
			result = new DebugFilter(filterChainProxy);
		}
		postBuildAction.run();
		return result;
	
</code></pre>
<h2 id="43-httpsecurity">4.3 HttpSecurity</h2>
<p>也比较简单</p>
<pre><code>protected DefaultSecurityFilterChain performBuild() {
    this.filters.sort(this.comparator);
    return new DefaultSecurityFilterChain(this.requestMatcher, this.filters);
}
</code></pre>
<p>它的更多逻辑其实在父类AbstractConfiguredSecurityBuilder的模板方法里面，init方法和configure方法才是真正把我们配置的哪些XXXXSecurityConfigurer类真正实现和生效</p>
<pre><code class="language-java">   protected final O doBuild() throws Exception {
        synchronized(this.configurers) {
            this.buildState = AbstractConfiguredSecurityBuilder.BuildState.INITIALIZING;
            this.beforeInit();
            this.init();
            this.buildState = AbstractConfiguredSecurityBuilder.BuildState.CONFIGURING;
            this.beforeConfigure();
            this.configure();
            this.buildState = AbstractConfiguredSecurityBuilder.BuildState.BUILDING;
            O result = (O)this.performBuild();
            this.buildState = AbstractConfiguredSecurityBuilder.BuildState.BUILT;
            return result;
        }
   }

    private void init() throws Exception {
        for(SecurityConfigurer&lt;O, B&gt; configurer : this.getConfigurers()) {
            configurer.init(this);
        }

        for(SecurityConfigurer&lt;O, B&gt; configurer : this.configurersAddedInInitializing) {
            configurer.init(this);
        }

    }

    private void configure() throws Exception {
        for(SecurityConfigurer&lt;O, B&gt; configurer : this.getConfigurers()) {
            configurer.configure(this);
        }
    }
</code></pre>
<h2 id="44-xxxxsecurityconfigurer">4.4 XXXXSecurityConfigurer</h2>
<p>当我们调用HttpSecurity的cors方法后，是怎样把真正的Configurer注册的</p>
<p>可以看到HttpSecurity注册了一个CorsConfigurer类，这个类按照上面说的后面会被init和configure</p>
<pre><code class="language-java">  public CorsConfigurer&lt;HttpSecurity&gt; cors() throws Exception {
      return (CorsConfigurer)this.getOrApply(new CorsConfigurer());
  }
</code></pre>
<p>下面是CorsConfigurer的configure，可以看到它的实现非常容易理解，生成一个Filter，然后加到了HttpSecurity中，至于Filter内部的逻辑可以不必关注，就是一个普通的Servlet Filter，然后解决跨域访问的问题</p>
<pre><code class="language-java">    public void configure(H http) {
        ApplicationContext context = (ApplicationContext)http.getSharedObject(ApplicationContext.class);
        CorsFilter corsFilter = this.getCorsFilter(context);
        if (corsFilter == null) {
            throw new IllegalStateException("Please configure either a corsFilter bean or a corsConfigurationSourcebean.");
        } else {
            http.addFilter(corsFilter);
        }
    }
</code></pre>
<p>其他的SecurityConfigurer内部逻辑可能很复杂，但最终逻辑其实都是在过滤器链里面加过滤器，实现拦截或者通过</p>
<h1 id="附录">附录</h1>
<h2 id="如何查看和编译spring-security源码">如何查看和编译Spring Security源码</h2>
<p>下载仓库时，可以不下载历史，会更快和占更少的空间，指定分支</p>
<pre><code>git clone --depth 1 https://github.com/spring-projects/spring-security.git -b 5.3.x
</code></pre>
<p>在下载依赖时，某个spring的插件怎么也下载不下来，因为spring的插件仓库在2021年关闭了对公众的访问，需要授权才能用（可以理解，但是很难受）</p>
<p><a href="https://spring.io/blog/2020/10/29/notice-of-permissions-changes-to-repo-spring-io-fall-and-winter-2020" target="_blank" rel="noopener nofollow">https://spring.io/blog/2020/10/29/notice-of-permissions-changes-to-repo-spring-io-fall-and-winter-2020</a></p>
<p><a href="https://spring.io/blog/2022/12/14/notice-of-permissions-changes-to-repo-spring-io-january-2023" target="_blank" rel="noopener nofollow">https://spring.io/blog/2022/12/14/notice-of-permissions-changes-to-repo-spring-io-january-2023</a></p>
<p>从公告中看镜像插件应该是可用的，但确实git下载的代码无法同步到依赖</p>
<p>需要修改build.gradle文件,</p>
<pre><code>buildscript {
	configurations.all {
		resolutionStrategy.dependencySubstitution {
			substitute module('org.apache.xerces:xercesImpl') with module('xerces:xercesImpl:2.9.1')
			substitute module('org.apache.xerces:resolver') with module('xerces:resolver:2.9.1')
		}
	}
	dependencies {
		classpath 'io.spring.gradle:spring-build-conventions:0.0.38-SNAPSHOT'
		classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
		classpath 'io.spring.nohttp:nohttp-gradle:0.0.10'
		classpath "io.freefair.gradle:aspectj-plugin:4.1.6"
		classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
	}
	repositories {
		maven { url 'https://maven.aliyun.com/repository/spring-plugin' }
		maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
		maven {
			url = 'https://repo.spring.io/plugins-snapshot'
		}
		maven {
			url = 'https://repo.spring.io/plugins-milestone'
		}
		maven {
			url = 'https://repo.spring.io/plugins-release'
		}
		maven { url 'https://plugins.gradle.org/m2/' }
	}
}

apply plugin: 'io.spring.nohttp'
apply plugin: 'locks'
apply plugin: 'io.spring.convention.root'
apply plugin: 'org.jetbrains.kotlin.jvm'

group = 'org.springframework.security'
description = 'Spring Security'

ext.snapshotBuild = version.contains("SNAPSHOT")
ext.releaseBuild = version.contains("SNAPSHOT")
ext.milestoneBuild = !(snapshotBuild || releaseBuild)

dependencyManagementExport.projects = subprojects.findAll { !it.name.contains('-boot') }

repositories {
	mavenCentral()
}

subprojects {
	plugins.withType(JavaPlugin) {
		project.sourceCompatibility='1.8'
	}

	tasks.withType(JavaCompile) {
		options.encoding = "UTF-8"
	}
}

</code></pre>
<p>主要修改了两点：</p>
<ol>
<li>修改了插件spring-build-conventions的版本</li>
<li>新增了阿里云插件仓库</li>
</ol>
<p>总之，是部分包Spring的仓库有，部分包阿里云仓库有，<strong>运气好的情况下</strong>，正确同步到了依赖</p>
<blockquote>
<p>注意，最终还是没完全同步成功完依赖，因为某些spring仓库无法访问的问题，但可以进行部分类的跳转</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/songjiyang/" target="_blank">songtianer</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/songjiyang/p/18986808" target="_blank">https://www.cnblogs.com/songjiyang/p/18986808</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 08:56">2025-07-16 08:56</span>&nbsp;
<a href="https://www.cnblogs.com/songjiyang">songtianer</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18986808);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18986808', targetLink: 'https://www.cnblogs.com/songjiyang/p/18986808', title: 'SpringSecurity配置和源码解析' })">举报</a>
</div>
        