
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/caoruipeng/p/18759311" title="发布于 2025-03-08 14:59">
    <span role="heading" aria-level="2">Windows编程----进程：环境变量</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>什么是系统环境变量</h2>
<p>每台计算机针对当前用户和系统中所有用户分别提供了两个环境变量设置，通过计算机属性&gt;环境变量的界面，我们可以查看当前这台计算机上的所有环境变量，这些环境变量都是key-value键值对。具体如下：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842394-1988620025.png" height="605" width="480"></figure>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842549-777139575.png" height="666" width="618"></figure>
<p>上面看到的环境变量其实是存储在注册表中的，</p>
<p>系统环境变量存储在<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</code>路径下，</p>
<p>用户环境变量存储在<code>计算机\HKEY_CURRENT_USER\Environment</code>路径下</p>
<p>如下两张图分别是注册表中环境变量的值：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842469-341042085.png" height="745" width="1038"></figure>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842402-203999544.png" height="554" width="1047"></figure>
<h2>什么是进程环境变量</h2>
<p>我们知道，进程本质上就是一块很大的地址空间。这个地址空间分为很多个内存区。包含代码区、DLL程序集代码区、全局变量区域、线程堆栈区等。那么进程环境变量（注意这个和上面提到的系统环境变量不同）本质上也是分配在进程内存空间上的一个字符串。这个字符串的格式如下：</p>
<p><code>=::=::\0Var1=Value1\0 Var2=Value2\0 Var3=Value3\0 ... VarN=ValueN\0\0</code></p>
<p>字符串中每个环境变量的格式为<code>key=value</code>，变量之间用<code>\0</code>区分。同时环境变量字符串必须以两个<code>\0</code>结束。也就是以<code>\0\0</code>结尾。注意：对于环境变量开始的=::=::\我们可以忽略，以=号开头的所有环节变量都会被忽略掉。</p>
<p>默认情况下，当进程启动的时候，会将系统环境变量加载到进程的环境变量中，我们可以使用ProcessExplorer这个工具查看进程的环境变量。我们运行下面这个简单的C++控制台程序，然后打开ProcessExplorer工具找到指定进程,然后右键Properties查看属性，选中Environment这一列，就可以看到系统环境变量都被加载到了进程的环境变量中。</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main()
{
    while (true) {
		Sleep(1000);
    }
    return 0;
}</code></pre>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842497-1148823163.png" height="833" width="2145"></figure>
<p>从上图可以很明显看到系统环境变量都被加载到了进程环境变量，同时这里有几个点需要我们注意：</p>
<p>1、用户变量和系统变量如果名称一致的时候，会以用户变量为准（Path变量除外），比如说，我们看到用户变量和系统变量中都有TEMP这个环境变量，并且它们的值是不同的，在用户变量中取值为：<code>C:\Users\caoruipeng\AppData\Local\Temp</code>，但是在系统变量中取值为：<code>C:\Users\caoruipeng\AppData\Local\Temp</code>，在最终的进程环境变量中，我们可以很明显看到TEMP的值为<code>C:\Users\caoruipeng\AppData\Local\Temp</code>。具体如下图：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842522-2122081892.png" height="811" width="2136"></figure>
<p>2、Path这个环境变量比较特殊，用户变量和系统变量中都有这个变量，但是程序不会按照上面的规则直接以用户变量中的变量值为准。而是将两个变量的变量值合并在一起作为最终的环境变量值，不同路径之间用分号区分。具体我们可以自己查看。</p>
<p>3、当我们新增了用户变量和环境变量之后，一般需要重启机器或者注销重启才能使环境变量生效，这也是为什么有时候我们新增了环境变量，但是在程序中并没有读取到那个环境变量的原因。</p>
<p>4、进程环境变量只是系统环境变量的副本，对进程环境变量的修改并不会影响到系统环境变量。除非用户通过GUI手动修改系统环境变量。</p>
<h2>访问进程环境变量</h2>
<p>程序可以通过<code>GetEnvironmentVariable</code>&nbsp;和<code>SetEnvironmentVariable</code>获取或者设置环境变量的值。注意：<code>SetEnvironmentVariable</code>函数只会修改当前进程的环境变量，而不会修改系统环境变量或其他进程的环境变量。也就是说，使用&nbsp;<code>SetEnvironmentVariable&nbsp;</code>设置的环境变量只在当前进程及其子进程中有效。</p>
<p>下面的代码，我们获取到环境变量OneDrive的值，然后修改这个环境变量的值，并重新打印出来。</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

int main()
{
    // 定义环境变量名
    LPCWSTR envVarName = L"OneDrive";

    // 分配缓冲区,接受环境变量值
    std::wstring envVarValue(1024, L'\0');

    // 获取环境变量值的长度
    DWORD bufferSize = GetEnvironmentVariable(envVarName, &amp;envVarValue[0], 1024);

    // 输出环境变量值
    std::wcout &lt;&lt; envVarName &lt;&lt; L" = " &lt;&lt; envVarValue &lt;&lt; std::endl;

    // 修改环境变量的值
    LPCWSTR newEnvVarValue = L"NewValue";
    if (SetEnvironmentVariable(envVarName, newEnvVarValue) == 0) {
        std::cerr &lt;&lt; "Failed to set environment variable." &lt;&lt; std::endl;
        return 1;
    }

    // 再次获取并输出修改后的环境变量值
	envVarValue.assign(1024, L'\0');
    bufferSize = GetEnvironmentVariable(envVarName, &amp;envVarValue[0], 1024);
    std::wcout &lt;&lt; envVarName &lt;&lt; L" = " &lt;&lt; envVarValue &lt;&lt; std::endl;

    return 0;
}</code></pre>
<p>调试程序之后，执行结果如下：可以看到，正确的输出了环境变量<code>OneDrive</code>的值为C:\Users\caoruipeng\OneDrive。</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842364-2083025912.png" height="91" width="982"></figure>
<h2>重置环境变量</h2>
<p>上面我们提到，进程启动的时候，会将系统环境变量全部加载到了内存中，如果我们不需要这些系统环境变量的话。可以通过<code>SetEnvironmentStrings</code>可以设置当前进程的环境变量块，通过<code>GetEnvironmentStrings</code>可以获取我们设置的环境变量块，当然通过<code>GetEnvironmentVariable</code>也可以获取到指定环境变量的值，下面我们用代码来演示一下：</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int main()
{    
    // 定义新的环境块
    LPCWSTR newEnvStrings = L"VAR1=Value1\0VAR2=Value2\0\0";
    // 设置新的环境块
    SetEnvironmentStringsW((LPWCH)newEnvStrings);
    while (true) {
		Sleep(1000);
    }
    return 0;
}</code></pre>
<p>运行控制台程序之后，我们重新在ProcessExplorer中查看进程的环境变量，就会发现进程的环境变量只剩下两个VAR1和VAR2，和我们程序中设置的一样。请看下图：</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842378-1053861887.png" height="619" width="689"></figure>
<p>下面的代码我们首先设置整个进程的环境变量块，然后通过<code>GetEnvironmentStrings</code>获取整个环境变量块，并且输出：</p>
<p>&nbsp;</p>
<pre class="highlighter-hljs"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

int main()
{
    // 定义新的环境块
    LPCWSTR newEnvStrings = L"VAR1=Value1\0VAR2=Value2\0\0";
    // 设置新的环境块
    SetEnvironmentStringsW((LPWCH)newEnvStrings);
    // 获取当前进程的环境块
    LPWCH envStrings = GetEnvironmentStringsW();
    // 遍历并输出所有环境变量
    LPWCH current = envStrings;
    while (*current) {
        std::wcout &lt;&lt; current &lt;&lt; std::endl;
        current += wcslen(current) + 1;
    }
    
    // 定义环境变量名
    LPCWSTR envVarName = L"VAR1";
    // 分配缓冲区,接受环境变量值
    std::wstring envVarValue(1024, L'\0');
    // 获取环境变量值的长度
    DWORD bufferSize = GetEnvironmentVariable(envVarName, &amp;envVarValue[0], 1024);
    std::wcout &lt;&lt; envVarName &lt;&lt; L" = " &lt;&lt; envVarValue &lt;&lt; std::endl;
    
    // 释放环境块
    FreeEnvironmentStringsW(envStrings);
    return 0;
}</code></pre>
<p>调试程序之后，执行结果如下：可以看到<code>GetEnvironmentVariable</code>可以成功获取到<code>VAR1</code>的环境变量值</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202503/665785-20250308145842370-1908189435.png" height="239" width="976"></figure>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05323500888773148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-08 15:00">2025-03-08 14:59</span>&nbsp;
<a href="https://www.cnblogs.com/caoruipeng">caoruipeng</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18759311" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18759311);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18759311', targetLink: 'https://www.cnblogs.com/caoruipeng/p/18759311', title: 'Windows编程----进程：环境变量' })">举报</a>
</div>
        