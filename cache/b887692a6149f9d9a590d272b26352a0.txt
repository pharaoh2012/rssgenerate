
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/buachuan/p/18385701" title="发布于 2025-02-26 20:38">
    <span role="heading" aria-level="2">C# 委托与 Lambda 表达式转换机制及弱事件模式下的生命周期分析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2 data-start="149" data-end="161">1. 委托内部结构</h2>
<p data-start="163" data-end="180">委托类型包含三个重要的非公共字段：</p>
<ul data-start="182" data-end="380">
<li data-start="182" data-end="284">
<p data-start="184" data-end="200"><strong data-start="184" data-end="198">_target 字段</strong></p>
<ul data-start="203" data-end="284">
<li data-start="203" data-end="241"><strong data-start="205" data-end="215">静态方法包装</strong>：当委托包装一个静态方法时，该字段为 null。</li>
<li data-start="244" data-end="284"><strong data-start="246" data-end="256">实例方法包装</strong>：当委托包装实例方法时，该字段引用回调方法所操作的对象。</li>
</ul>
</li>
<li data-start="286" data-end="323">
<p data-start="288" data-end="307"><strong data-start="288" data-end="305">_methodPtr 字段</strong></p>
<ul data-start="310" data-end="323">
<li data-start="310" data-end="323">标识委托要调用的方法。</li>
</ul>
</li>
<li data-start="325" data-end="380">
<p data-start="327" data-end="351"><strong data-start="327" data-end="349">_invocationList 字段</strong></p>
<ul data-start="354" data-end="380">
<li data-start="354" data-end="380">存储委托链（即内部委托数组），用于实现多播委托。</li>
</ul>
</li>
</ul>
<hr data-start="382" data-end="385">
<h2 data-start="387" data-end="410">2. Lambda 表达式转换为委托实例</h2>
<p data-start="412" data-end="468">C# 编译器会将 lambda 表达式转换成相应的委托实例，具体转换方式依赖于 lambda 是否捕获外部数据。</p>
<h3 data-start="470" data-end="487">2.1 不捕获任何外部数据</h3>
<ul data-start="489" data-end="723">
<li data-start="489" data-end="571">
<p data-start="491" data-end="502"><strong data-start="491" data-end="499">转换方式</strong>：</p>
<ul data-start="505" data-end="571">
<li data-start="505" data-end="542">将 lambda 表达式生成为私有的静态函数（编译器自动生成方法名）。</li>
<li data-start="545" data-end="571">同时生成一个委托类型的静态字段用于缓存委托实例。</li>
</ul>
</li>
<li data-start="573" data-end="723">
<p data-start="575" data-end="591"><strong data-start="575" data-end="588">委托实例创建与缓存</strong>：</p>
<ul data-start="594" data-end="723">
<li data-start="594" data-end="632">当调用包含 lambda 的方法时，先检查静态字段是否为 null。</li>
<li data-start="635" data-end="688">若不为 null，则直接返回缓存的委托实例；若为 null，则创建新的委托实例，并赋值给静态字段。</li>
<li data-start="691" data-end="723">这种方式确保委托实例只创建一次，被静态字段引用后不会被回收。</li>
</ul>
</li>
</ul>
<h3 data-start="725" data-end="751">2.2 捕获实例成员（通过 this 访问）</h3>
<ul data-start="753" data-end="870">
<li data-start="753" data-end="806">
<p data-start="755" data-end="766"><strong data-start="755" data-end="763">转换方式</strong>：</p>
<ul data-start="769" data-end="806">
<li data-start="769" data-end="806">将 lambda 表达式生成为私有的实例函数（编译器自动生成方法名）。</li>
</ul>
</li>
<li data-start="808" data-end="870">
<p data-start="810" data-end="823"><strong data-start="810" data-end="820">委托实例创建</strong>：</p>
<ul data-start="826" data-end="870">
<li data-start="826" data-end="870">每次调用包含 lambda 的方法时，都会实时创建一个新的委托实例，包装该实例函数。</li>
</ul>
</li>
</ul>
<h3 data-start="872" data-end="895">2.3 捕获非实例成员（例如局部变量）</h3>
<ul data-start="897" data-end="1466">
<li data-start="897" data-end="1057">
<p data-start="899" data-end="910"><strong data-start="899" data-end="907">转换方式</strong>：</p>
<ul data-start="913" data-end="1057">
<li data-start="913" data-end="963">编译器生成一个私有的辅助闭包类（通常命名为 “&lt;&gt;c__DisplayClassXXX”）。</li>
<li data-start="966" data-end="1001">辅助类中包含公开字段，用于保存捕获的局部变量（或其他非实例数据）。</li>
<li data-start="1004" data-end="1057">在该辅助类中，将 lambda 表达式转换为公开的实例函数，该方法通过访问辅助类字段来使用捕获的数据。</li>
</ul>
</li>
<li data-start="1059" data-end="1466">
<p data-start="1061" data-end="1078"><strong data-start="1061" data-end="1075">委托与闭包实例的创建</strong>：</p>
<ul data-start="1081" data-end="1466">
<li data-start="1081" data-end="1116">每次调用包含 lambda 的方法时，都会生成一个辅助类实例。</li>
<li data-start="1119" data-end="1155">然后创建一个委托实例，其 _target 字段指向该辅助类实例。</li>
<li data-start="1158" data-end="1289"><strong data-start="1160" data-end="1166">注意</strong>：在循环中容易产生闭包陷阱——尽管每次迭代可能创建多个辅助类实例与委托实例，但这些辅助类实例中的捕获字段指向同一块内存（即共享同一循环变量）。由于 lambda 表达式通常在循环结束后执行，所有回调看到的循环变量值往往都是最后一次迭代的状态。</li>
<li data-start="1292" data-end="1466"><strong>另外，不同版本的 C# 对于循环中辅助类实例的创建可能存在差异，有的版本可能只在进入方法时创建一次，而有的版本则每次迭代都创建新的实例。至于委托实例，我猜测每次迭代都会创建一个新的委托实例（否则作为字典键时可能会出现重复的问题），但《CLR Via C# 第四版》中示例代码（17.7.3节，中文版365页）显示委托实例只创建了一次，这里感觉有点问题，有兴趣的朋友可以分析一下。</strong></li>
</ul>
</li>
</ul>
<hr data-start="1468" data-end="1471">
<h2 data-start="1473" data-end="1491">3. 委托实例的订阅与生命周期</h2>
<h3 data-start="1493" data-end="1510">3.1 常规委托/事件订阅</h3>
<ul data-start="1512" data-end="1577">
<li data-start="1512" data-end="1577">当委托实例订阅到常规委托或事件时，事件源对委托实例持有<strong data-start="1541" data-end="1548">强引用</strong>，从而延长委托实例的生命周期（直至取消订阅或事件源回收）。</li>
</ul>
<h3 data-start="1579" data-end="1592">3.2 弱事件订阅</h3>
<ul data-start="1594" data-end="2040">
<li data-start="1594" data-end="1649">
<p data-start="1596" data-end="1610"><strong data-start="1596" data-end="1607">弱事件模式特点</strong>：</p>
<ul data-start="1613" data-end="1649">
<li data-start="1613" data-end="1649">委托实例的生命周期至少大于其 _target 引用的对象的生命周期。</li>
</ul>
</li>
<li data-start="1651" data-end="1852">
<p data-start="1653" data-end="1664"><strong data-start="1653" data-end="1661">实现机制</strong>：</p>
<ul data-start="1667" data-end="1852">
<li data-start="1667" data-end="1770">利用 <code data-start="1672" data-end="1708">ConditionalWeakTable&lt;TKey, TValue&gt;</code> 进行关联：
<ul data-start="1721" data-end="1770">
<li data-start="1721" data-end="1747">将 _target 引用的对象作为 key。</li>
<li data-start="1752" data-end="1770">将委托实例作为 value。</li>
</ul>
</li>
<li data-start="1773" data-end="1852">ConditionalWeakTable 对 key 使用弱引用，但对 value 使用强引用，保证只要 key 存在，对应的 value 就不会被回收。</li>
</ul>
</li>
<li data-start="1854" data-end="2040">
<p data-start="1856" data-end="1867"><strong data-start="1856" data-end="1864">订阅流程</strong>：</p>
<ul data-start="1870" data-end="2040">
<li data-start="1870" data-end="2040">当委托实例通过 <code data-start="1880" data-end="1924">WeakEventManager&lt;TEventSource, TEventArgs&gt;</code> 订阅弱事件时，内部会通过 <code data-start="1938" data-end="1955">Delegate.Target</code> 获取 _target 引用的对象，并将该对象与委托实例关联到 ConditionalWeakTable 中，从而确保委托实例的生命周期至少与 _target 对象一致。</li>
</ul>
</li>
</ul>
<br>
<p><strong>上面用工具重新排版了下，下面是我编辑的原文：</strong></p>
<p>委托类型包含三个重要的非公共字段：_target字段，当委托实例包装一个静态方法时，该字段为空；包装实例方法时，这个字段引用回调方法要操作的对象。_methodPtr字段标识要回调的方法。_invocationList字段引用委托数组。</p>
<p>C#编译器将lambda方法替换为对应的委托实例。</p>
<p>当lambda不获取任何外部数据时，调用只创建一次委托实例并缓存：C#编译器将lambda表达式生成为私有的静态函数(编译器自动取名的方法)，并生成一个委托类型的静态字段。当调用使用lambda的方法时，先判断自动生成的静态字段是否为空，不为空则直接返回静态字段引用的委托实例，为空则先创建一个包装静态函数的委托实例赋值给静态委托字段。（这导致被静态字段引用的委托实例不会被释放，但委托实例只会被创建一次）。</p>
<p>当lambda获取实例成员时（通过this指针访问），每次调用都创建新的委托实例：C#编译器将lambda表达式生成为私有的实例函数(编译器自动取名的方法)。每次调用使用lambda的方法时都实时创建一个委托实例包装该自动生成的实例函数。</p>
<p>当lambda获取非实例成员时（不通过当前实例的this指针访问，比如局部变量），C#编译器创建一个私有的辅助类，辅助类拥有对应的公开字段引用非实例成员，在辅助类中将将lambda表达式生成为公开的实例函数。每次调用使用lambda的方法时都生成辅助类实例，引用相同的非实例成员，然后创建委托实例传入辅助类实例。（循环中的闭包陷阱就在于循环中虽然创建了多个辅助类实例与委托实例，但不同辅助类实例引用的非实例成员是同一块内存。lambda 表达式是在循环中创建，但其执行往往是在循环结束后才发生，所以所有回调看到的循环变量都是最终状态。<strong>并且<strong>不同版本C#实现在</strong>循环中可能并没有创建循环次数的辅助类实例，而是在进入方法时只创建一次。我猜测创建了循环次数的委托实例，不然作为字典的键时就应该出错了。但CLR Via C#第四版给的示例代码中委托实例只创建了一次，这可能有点问题，有兴趣的朋友可以分析一下。</strong>）</p>
<p>lambda被转换为委托实例后，当将该委托实例订阅到常规委托、事件时，事件源对委托实例进行强引用。</p>
<p>当将该委托实例订阅到弱事件时，存在有意思的现象：委托实例的生命周期最起码大于_target引用的对象的生命周期。这是通过ConditionalWeakTable&lt;TKey, TValue&gt;实现的，通过将_target引用的对象设置为key、将委托实例设置为value。该类负责数据间的关联，它对key是弱引用，但保证只要key在内存中，value就一定在内存中。</p>
<p>委托实例通过WeakEventManager&lt;TEventSource, TEventArgs&gt;订阅弱事件时，WeakEventManager&lt;TEventSource, TEventArgs&gt;内部会通过Delegate.Target拿到委托实例中_target引用的对象，作为ConditionalWeakTable的key，委托实例作为ConditionalWeakTable的value进行关联。这样就保证了弱事件模式下委托实例的生命周期至少大于_target引用的对象的生命周期。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> AddHandler(Delegate handler)
{
    Invariant.Assert(_users </span>== <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Cannot modify a ListenerList that is in use</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">object</span> obj =<span style="color: rgba(0, 0, 0, 1)"> handler.Target;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (obj == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        obj </span>=<span style="color: rgba(0, 0, 0, 1)"> StaticSource;
    }

    _list.Add(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Listener(obj, handler));
    AddHandlerToCWT(obj, handler);
}

</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> AddHandlerToCWT(<span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> target, Delegate handler)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!_cwt.TryGetValue(target, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">var</span><span style="color: rgba(0, 0, 0, 1)"> value))
    {
        _cwt.Add(target, handler);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    List</span>&lt;Delegate&gt; list = value <span style="color: rgba(0, 0, 255, 1)">as</span> List&lt;Delegate&gt;<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (list == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        Delegate item </span>= value <span style="color: rgba(0, 0, 255, 1)">as</span><span style="color: rgba(0, 0, 0, 1)"> Delegate;
        list </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;Delegate&gt;<span style="color: rgba(0, 0, 0, 1)">();
        list.Add(item);
        _cwt.Remove(target);
        _cwt.Add(target, list);
    }

    list.Add(handler);
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文作者：<a href="https://www.cnblogs.com/buachuan/" target="_blank">陈百川</a>，欢迎留言讨论。转载请注明原文链接：<a href="https://www.cnblogs.com/buachuan/p/18385701" target="_blank">https://www.cnblogs.com/buachuan/p/18385701</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.7505993617048612" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 20:38">2025-02-26 20:38</span>&nbsp;
<a href="https://www.cnblogs.com/buachuan">陈百川</a>&nbsp;
阅读(<span id="post_view_count">205</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18385701" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18385701);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18385701', targetLink: 'https://www.cnblogs.com/buachuan/p/18385701', title: 'C# 委托与 Lambda 表达式转换机制及弱事件模式下的生命周期分析' })">举报</a>
</div>
        