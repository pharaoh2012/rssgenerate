
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pretttyboy/p/18825245" title="发布于 2025-04-14 17:13">
    <span role="heading" aria-level="2">基于Zookeeper实现调度任务选主及心跳检测</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        分布式调度任务实现之Zookeeper
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在微服务架构中使用ZooKeeper实现分布式任务调度选主，并确保Follower节点能实时监控Master状态并及时触发重新选举，可以通过以下方案实现：</p>
<hr>
<h3 id="一核心设计原理">一、核心设计原理</h3>
<h4 id="1-zookeeper特性利用">1. <strong>ZooKeeper特性利用</strong></h4>
<table>
<thead>
<tr>
<th><strong>ZK功能</strong></th>
<th><strong>在选主中的应用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>临时节点(EPHEMERAL)</td>
<td>Master创建临时节点，会话断开时节点自动删除（相当于心跳检测）</td>
</tr>
<tr>
<td>Watcher机制</td>
<td>Follower监听Master节点变化</td>
</tr>
<tr>
<td>顺序节点(SEQUENTIAL)</td>
<td>实现公平的选举排序</td>
</tr>
</tbody>
</table>
<h4 id="2-状态监控流程">2. <strong>状态监控流程</strong></h4>
<div class="mermaid">sequenceDiagram
    participant Master
    participant Follower1
    participant Follower2
    participant ZK
    Master-&gt;&gt;ZK: 创建/master_leader临时节点
    Follower1-&gt;&gt;ZK: 监听/master_leader节点
    Follower2-&gt;&gt;ZK: 监听/master_leader节点
    Note over Master: 正常工作时定期刷新会话
    Master--xZK: 会话超时断开
    ZK-&gt;&gt;Follower1: 触发NodeDeleted事件
    ZK-&gt;&gt;Follower2: 触发NodeDeleted事件
    Follower1-&gt;&gt;ZK: 尝试创建新/master_leader节点
    ZK--&gt;&gt;Follower1: 创建成功，成为新Master
    Follower2-&gt;&gt;ZK: 监听新的/master_leader节点
</div><hr>
<h3 id="二完整实现方案">二、完整实现方案</h3>
<h4 id="1-添加依赖">1. 添加依赖</h4>
<pre><code class="language-xml">&lt;!-- Curator客户端（推荐） --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;version&gt;5.5.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2-选主服务实现">2. 选主服务实现</h4>
<pre><code class="language-java">import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.leader.LeaderSelector;
import org.apache.curator.framework.recipes.leader.LeaderSelectorListener;
import org.apache.curator.framework.state.ConnectionState;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class ZkLeaderElection {

    private final CuratorFramework zkClient;
    private LeaderSelector leaderSelector;
    private volatile boolean isLeader = false;

    public ZkLeaderElection(CuratorFramework zkClient) {
        this.zkClient = zkClient;
    }

    @PostConstruct
    public void init() throws Exception {
        leaderSelector = new LeaderSelector(zkClient, "/scheduler/leader", 
            new LeaderSelectorListener() {
                @Override
                public void takeLeadership(CuratorFramework client) throws Exception {
                    // 成为Leader后的逻辑
                    isLeader = true;
                    System.out.println("当前节点当选为Leader");
                    try {
                        while (true) {
                            Thread.sleep(1000); // 模拟持续工作
                        }
                    } finally {
                        isLeader = false;
                    }
                }

                @Override
                public void stateChanged(CuratorFramework client, ConnectionState newState) {
                    // 连接状态变化处理
                    if (newState == ConnectionState.LOST) {
                        isLeader = false;
                    }
                }
            });

        leaderSelector.autoRequeue(); // 自动重新参与选举
        leaderSelector.start();
    }

    @PreDestroy
    public void shutdown() {
        if (leaderSelector != null) {
            leaderSelector.close();
        }
    }

    public boolean isLeader() {
        return isLeader;
    }
}
</code></pre>
<h4 id="3-增强型状态监控生产级">3. 增强型状态监控（生产级）</h4>
<pre><code class="language-java">// 在init()方法中添加以下逻辑
public void init() throws Exception {
    // ...原有代码...
    
    // 添加额外的心跳检测
    zkClient.getConnectionStateListenable().addListener((client, newState) -&gt; {
        if (newState == ConnectionState.RECONNECTED) {
            // 重连后强制检查Leader状态
            checkLeaderStatus();
        }
    });
    
    // 启动定时检查任务
    Executors.newSingleThreadScheduledExecutor()
        .scheduleAtFixedRate(this::checkLeaderStatus, 0, 5, TimeUnit.SECONDS);
}

private void checkLeaderStatus() {
    try {
        if (zkClient.checkExists().forPath("/scheduler/leader") == null) {
            System.out.println("Leader节点不存在，触发重新选举");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<hr>
<h3 id="三关键优化点">三、关键优化点</h3>
<h4 id="1-双watch机制">1. <strong>双Watch机制</strong></h4>
<pre><code class="language-java">// 除了LeaderSelector内置监听，额外添加数据Watch
zkClient.getData().usingWatcher((Watcher) event -&gt; {
    if (event.getType() == Watcher.Event.EventType.NodeDeleted) {
        System.out.println("Leader节点被删除，立即触发选举");
    }
}).forPath("/scheduler/leader");
</code></pre>
<h4 id="2-选举性能优化">2. <strong>选举性能优化</strong></h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>推荐值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionTimeoutMs</td>
<td>10000-15000ms</td>
<td>根据网络状况调整</td>
</tr>
<tr>
<td>leaderSelector.autoRequeue()</td>
<td>必须启用</td>
<td>保证节点退出后重新参与选举</td>
</tr>
<tr>
<td>retryPolicy.baseSleepTimeMs</td>
<td>1000ms</td>
<td>首次重试延迟</td>
</tr>
</tbody>
</table>
<h4 id="3-故障转移时间控制">3. <strong>故障转移时间控制</strong></h4>
<pre><code class="language-java">// 在ZK配置中优化
@Bean
public CuratorFramework zkClient() {
    return CuratorFrameworkFactory.builder()
        .connectString("zk1:2181,zk2:2181,zk3:2181")
        .sessionTimeoutMs(15000) // 会话超时
        .connectionTimeoutMs(5000) // 连接超时
        .retryPolicy(new ExponentialBackoffRetry(1000, 3)) // 重试策略
        .build();
}
</code></pre>
<p><strong>故障转移时间</strong> = 会话超时时间 + 选举时间（通常可控制在15秒内）</p>
<hr>
<h3 id="四生产环境建议">四、生产环境建议</h3>
<h4 id="1-监控指标">1. <strong>监控指标</strong></h4>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>采集方式</th>
<th>告警阈值</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZK选举次数</td>
<td>ZK的<code>leader_election</code>计数器</td>
<td>1小时内&gt;5次</td>
</tr>
<tr>
<td>Master存活时间</td>
<td>节点数据中的时间戳</td>
<td>连续3次&lt;30秒</td>
</tr>
<tr>
<td>节点连接状态</td>
<td>Curator事件监听</td>
<td>RECONNECTED状态持续&gt;1分钟</td>
</tr>
</tbody>
</table>
<h4 id="2-部署架构">2. <strong>部署架构</strong></h4>
<pre><code>[微服务实例1] [微服务实例2] [微服务实例3]
      |            |            |
      +------------+------------+
                   |
           [ZooKeeper Ensemble]
                   |
            [监控系统(Prometheus + Grafana)]
</code></pre>
<h4 id="3-异常场景处理">3. <strong>异常场景处理</strong></h4>
<ul>
<li><strong>脑裂防护</strong>：启用ZK的<code>quorum</code>机制（至少3节点）</li>
<li><strong>网络分区</strong>：配合Sidecar代理检测真实网络状态</li>
<li><strong>持久化问题</strong>：定期备份<code>/scheduler</code>节点数据</li>
</ul>
<hr>
<h3 id="五与spring-cloud集成">五、与Spring Cloud集成</h3>
<h4 id="1-健康检查端点">1. 健康检查端点</h4>
<pre><code class="language-java">@RestController
@RequestMapping("/leader")
public class LeaderController {
    
    @Autowired
    private ZkLeaderElection election;

    @GetMapping("/status")
    public ResponseEntity&lt;String&gt; status() {
        return election.isLeader() 
            ? ResponseEntity.ok("MASTER")
            : ResponseEntity.ok("FOLLOWER");
    }
}
</code></pre>
<h4 id="2-调度任务示例">2. 调度任务示例</h4>
<pre><code class="language-java">@Scheduled(fixedRate = 5000)
public void scheduledTask() {
    if (zkLeaderElection.isLeader()) {
        System.out.println("只有Master执行的任务...");
    }
}
</code></pre>
<hr>
<h3 id="六对比redisson方案">六、对比Redisson方案</h3>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>ZooKeeper方案</strong></th>
<th><strong>Redisson方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>实时性</td>
<td>秒级（依赖ZK会话超时）</td>
<td>秒级（依赖Redis TTL）</td>
</tr>
<tr>
<td>可靠性</td>
<td>高（CP系统）</td>
<td>中（依赖Redis持久化）</td>
</tr>
<tr>
<td>运维复杂度</td>
<td>较高（需维护ZK集群）</td>
<td>较低（复用Redis）</td>
</tr>
<tr>
<td>适用场景</td>
<td>强一致性要求的系统</td>
<td>允许短暂脑裂的场景</td>
</tr>
</tbody>
</table>
<hr>
<p>通过以上方案，你的微服务可以实现：</p>
<ol>
<li><strong>秒级故障检测</strong>：基于ZK临时节点和Watcher机制</li>
<li><strong>自动快速选主</strong>：利用Curator的选举算法</li>
<li><strong>生产级可靠性</strong>：多重监控和防护机制</li>
<li><strong>无缝集成Spring生态</strong>：与<code>@Scheduled</code>等组件协同工作</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7434326667037037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 17:14">2025-04-14 17:13</span>&nbsp;
<a href="https://www.cnblogs.com/pretttyboy">想念泡凤爪的味道</a>&nbsp;
阅读(<span id="post_view_count">83</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18825245);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18825245', targetLink: 'https://www.cnblogs.com/pretttyboy/p/18825245', title: '基于Zookeeper实现调度任务选主及心跳检测' })">举报</a>
</div>
        