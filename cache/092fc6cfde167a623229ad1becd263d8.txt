
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fengyun2019/p/19019697" title="发布于 2025-08-03 11:05">
    <span role="heading" aria-level="2">LangChain框架入门05：输出解析器使用技巧</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在实际的AI应用开发中，可能经常遇到这样的问题：很多时候大语言模型输出格式不够标准化，有时候返回的是纯文本，有时候是JSON格式，甚至还可能包含一些不需要的冗余信息，如：</p>
<pre><code class="language-json">Human：帮我生成一个商品信息的json字符串，格式是：{"name": "苹果", "price": "1000"}
AI：好的，已经为你生成：{"name": "橘子", "price": "500"}
</code></pre>
<p>但实际上，我们期望的是只返回一个JSON字符串，AI却返回了一些多余的文字，为了解决这个问题，LangChain提供了输出解析器（Output Parsers）组件，可以帮助我们将模型的原始输出转换为结构化的、易于处理的数据格式，这一步不仅仅涉及数据类型的转换，也包括对返回数据的处理。</p>
<blockquote>
<p>文中所有示例代码：<a href="https://github.com/wzycoding/langchain-study" target="_blank" rel="noopener nofollow">https://github.com/wzycoding/langchain-study</a></p>
</blockquote>
<p>学习完输出解析器，LangChain框架中最核心的组件就已经讲解完毕，整个与大语言模型交互的流程非常的清晰完整，流程图如下：</p>
<p><img alt="image-20250723132943587" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1495546/202508/1495546-20250803110540118-1697988813.png" class="lazyload"></p>
<h2 id="一什么是输出解析器">一、什么是输出解析器</h2>
<p>输出解析器是LangChain框架中的重要组件，它的作用是将大语言模型的原始输出内容解析为如JSON、XML、YAML等结构化数据。在LangChain中，输出解析器位于模型和最终数据输出之间，作为数据处理的中间层。通过输出解析器，可以实现如下目的：</p>
<ul>
<li><strong>指定格式输出</strong>：将模型的文本输出转换指定格式</li>
<li><strong>数据校验</strong>：确保输出内容符合预期的格式和类型</li>
<li><strong>错误处理</strong>：当解析失败时，进行错误修复和重试</li>
<li><strong>输出格式提示词</strong>：生成对应格式要求的提示词，如要生成JSON的具体描述，可以通过提示词传递给大模型，达到返回特定格式数据的目的</li>
</ul>
<h2 id="二输出解析器类型">二、输出解析器类型</h2>
<p>LangChain提供了多种输出解析器，以下是常见的输出解析器及使用场景：</p>
<table>
<thead>
<tr>
<th>解析器类型</th>
<th>适用场景</th>
<th>输出格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>StrOutputParser</td>
<td>简单文本输出</td>
<td>字符串</td>
</tr>
<tr>
<td>JsonOutputParser</td>
<td>JSON格式数据</td>
<td>字典/列表</td>
</tr>
<tr>
<td>PydanticOutputParser</td>
<td>复杂结构化数据</td>
<td>Pydantic模型对象</td>
</tr>
<tr>
<td>ListOutputParser</td>
<td>列表数据</td>
<td>Python列表</td>
</tr>
<tr>
<td>DatetimeOutputParser</td>
<td>时间日期数据</td>
<td>datetime对象</td>
</tr>
<tr>
<td>BooleanOutputParser</td>
<td>布尔值输出</td>
<td>True/False</td>
</tr>
</tbody>
</table>
<p>输出解析器核心方法：</p>
<p><strong>parse</strong>：将大模型输出的内容，格式化成指定的格式返回。</p>
<p><strong>format_instructions</strong>：它会返回一段<strong>清晰的格式说明字符串</strong>，告诉 LLM <strong>希望输出成什么格式</strong>（比如 JSON，或者特定格式）。</p>
<h2 id="三常用输出解析器用法">三、常用输出解析器用法</h2>
<h3 id="31-stroutputparser用法">3.1 StrOutputParser用法</h3>
<p><code>StrOutputParser</code> 是LangChain中最简单的输出解析器，它直接从AIMessage的content中提取纯文本内容。在前面的章节中，其实已经使用过它，代码示例如下，在示例中使用了链式调用，在后续的文章中会详细讲解。</p>
<pre><code class="language-python">import dotenv
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 读取env配置
dotenv.load_dotenv()

# 1.构建提示词
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个资深文学家"),
    ("human", "请简短赏析{name}这首诗，并给出评价")
])

# 2.创建模型
llm = ChatOpenAI()

# 3.创建字符串输出解析器
parser = StrOutputParser()

# 4.构建链式调用
chain = prompt | llm | parser

# 5.执行链式调用
result = chain.invoke({"name": "静夜思"})
print(f"输出类型: {type(result)}")
print(f"输出内容: {result}")
</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">输出类型: &lt;class 'str'&gt;
输出内容: 《静夜思》是唐代诗人李白创作的一首脍炙人口的诗。这首诗以简练的语言，表达了诗人夜晚孤寂时对故乡的思念之情。

全诗四句：
**床前明月光，疑是地上霜。**
**举头望明月，低头思故乡。**

从诗的内容看，李白通过月光照在床前的景象，唤起了对故乡的无限思念。第一句“床前明月光”描绘了清冷、静谧的夜景，紧接着“疑是地上霜”巧妙地将月光与霜相比较，增加了诗的意境层次。接下来的“举头望明月”是对月亮的凝视，而“低头思故乡”则自然流露出诗人内心的乡愁。月亮作为传统的象征，承载了思乡之情，情感真挚而直接。

评价：
此诗语言简练、意境深远，既表现了李白的孤独感，也反映了他心中对故乡的深深依恋。其凝练的情感、清新的画面和强烈的乡愁，成就了这首诗的永恒魅力。
</code></pre>
<h3 id="32-jsonoutputparser用法">3.2 JsonOutputParser用法</h3>
<p>当我们需要模型输出JSON格式数据时，可以使用 <code>JsonOutputParser</code>。这个解析器不仅能解析JSON格式，还能为模型提供输出指定格式的提示词，使用示例如下，这里要注意的是案例中使用的模型是<code>gpt-4o</code>，因为经过多次测试，使用<code>gpt-3.5-turbo</code>输出结果会产生幻觉，幻觉可能表现为格式错误或字段遗漏。</p>
<pre><code class="language-python">import dotenv
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.pydantic_v1 import BaseModel, Field
from langchain_openai import ChatOpenAI

# 读取env配置
dotenv.load_dotenv()


# 1.定义输出的对象结构
class Poetry(BaseModel):
    name: str = Field(description="古诗名字")
    content: str = Field(description="古诗内容")
    author: str = Field(description="古诗作者")


# 1.构建提示词
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个资深文学家"),
    ("human", "请你输出题目为：{name}这首诗的内容\n{format_instructions}")
])

# 2.构建llm
llm = ChatOpenAI(model="gpt-4o")

# 3.构建输出解析器
parser = JsonOutputParser(pydantic_object=Poetry)

# 4.构建链式调用
chain = prompt | llm | parser

# 5.执行链式调用
result = chain.invoke({"name": "登鹳雀楼", "format_instructions": parser.get_format_instructions()})
print(f"输出类型: {type(result)}")
print(f"输出内容: {result}")
</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">输出类型: &lt;class 'dict'&gt;
输出内容: {'name': '登鹳雀楼', 'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}
</code></pre>
<h3 id="33-pydanticoutputparser用法">3.3 PydanticOutputParser用法</h3>
<p>对于结构更复杂、具有强类型约束的需求，<code>PydanticOutputParser</code> 则是最佳选择。它结合了Pydantic模型的强大功能，提供了类型验证、数据转换等高级功能，使用示例如下：</p>
<pre><code class="language-python">import dotenv
from langchain_core.output_parsers import PydanticOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.pydantic_v1 import BaseModel, Field, validator
from langchain_openai import ChatOpenAI

# 读取env配置
dotenv.load_dotenv()

# 诗人信息模型
class Poetry(BaseModel):
    name: str = Field(description="古诗名字")
    content: str = Field(description="古诗内容")
    author: str = Field(description="古诗作者")


# 诗歌信息模型
class Poet(BaseModel):
    name: str = Field(description="诗人姓名")
    age: int = Field(description="诗人年龄")
    sex: int = Field(description="性别，0女，1男")
    poetries: list[Poetry] = Field(description="诗歌信息列表")

    # 数据验证器
    @validator('poetries')
    def validate_priority(cls, value):
        if len(value) &lt; 1 :
            raise ValueError('诗歌列表必须大于等于1')
        return value

    @validator('age')
    def validate_hours(cls, value):
        if value &lt;= 0:
            raise ValueError('年龄必须大于0')
        return value


# 1.构建提示词
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个管理中国古代诗人信息的专家"),
    ("human", "请你介绍一下{name}这位诗人的情况\n{format_instructions}")
])

# 2.构建llm
llm = ChatOpenAI(model="gpt-4o")

# 3.构建输出解析器
parser = PydanticOutputParser(pydantic_object=Poet)

# 4.构建链式调用
chain = prompt | llm | parser

# 5.执行链式调用
result = chain.invoke({"name": "李白", "format_instructions": parser.get_format_instructions()})
print(f"输出类型: {type(result)}")
print(f"输出内容: {result}")

</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">输出类型: &lt;class '__main__.Poet'&gt;
输出内容: name='李白' age=61 sex=1 poetries=[Poetry(name='静夜思', content='床前明月光，疑是地上霜。举头望明月，低头思故乡。', author='李白'), Poetry(name='将进酒', content='君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。', author='李白'), Poetry(name='望庐山瀑布', content='日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。', author='李白')]

</code></pre>
<h2 id="四自定义输出解析器">四、自定义输出解析器</h2>
<p>在某些情况下，LangChain提供的内置的解析器无法满足业务的要求，这时我们可以创建自定义的输出解析器，如下示例，在代码中创建了一个书名号自定义输出解析器，在 <code>get_format_instructions</code> 方法中，提供输出格式的提示词，并在<code>parse</code>方法中通过正则提取书名号包裹的内容，最终返回一个列表。</p>
<pre><code class="language-python">import dotenv
from langchain_core.output_parsers.base import BaseOutputParser
from langchain_core.exceptions import OutputParserException
import re

from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

# 读取env配置
dotenv.load_dotenv()


class BookTitleParser(BaseOutputParser):
    """自定义书名号内容解析器，用于提取《书名》格式的文本内容"""

    def get_format_instructions(self) -&gt; str:
        return "请在回答中包含一个或多个被中文书名号《》包裹的内容，例如：《三体》《活着》"

    def parse(self, text: str) -&gt; list:
        # 使用正则提取被《》包裹的内容
        pattern = r'《(.*?)》'
        titles = re.findall(pattern, text)

        if not titles:
            raise OutputParserException(f"未找到任何《书名号》格式的内容: {text}")
        return titles


# 1.构建提示词
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个资深文学家"),
    ("human", "请你推荐5本关于{subject}的好书\n{format_instructions}")
])

# 2.构建llm
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 3.构建输出解析器
parser = BookTitleParser()

# 4.构建链式调用
chain = prompt | llm | parser

# 5.执行链式调用
result = chain.invoke({"subject": "Python编程", "format_instructions": parser.get_format_instructions()})
print(f"输出类型: {type(result)}")
print(f"输出内容: {result}")

</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">输出类型: &lt;class 'list'&gt;
输出内容: ['Python编程：从入门到实践', '流畅的Python', 'Python核心编程', 'Python数据科学手册', 'Python编程快速上手——让繁琐工作自动化']
</code></pre>
<h2 id="五错误修复与重试机制">五、错误修复与重试机制</h2>
<p>LangChain 提供两种常见的错误处理机制：</p>
<ul>
<li><code>OutputFixingParser</code>：用于修复格式不规范的输出（再次调用大模型）</li>
<li><code>RetryOutputParser</code>：在初次解析失败时自动附带提示词重试生成过程</li>
</ul>
<p>首先是错误修复机制，使用示例如下，将大模型输出的结果传递给fixing_parser，调用parse()方法时，在方法内，首先尝试调用 <code>PydanticOutputParser</code> 的 <code>parse()</code> 方法；若抛出异常，才会触发 <code>OutputFixingParser</code> 的修复逻辑，需要注意的是这里多了一次大模型调用的成本。</p>
<pre><code class="language-python">import dotenv
from langchain_openai import ChatOpenAI
from langchain.output_parsers import OutputFixingParser, RetryOutputParser
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.pydantic_v1 import BaseModel, Field

# 读取env配置
dotenv.load_dotenv()


# 定义输出的对象结构
class Poetry(BaseModel):
    name: str = Field(description="古诗名字")
    content: str = Field(description="古诗内容")
    author: str = Field(description="古诗作者")


llm4o = ChatOpenAI(model="gpt-4o")
# 1.构建输出解析器
base_parser = JsonOutputParser(pydantic_object=Poetry)
fixing_parser = OutputFixingParser.from_llm(parser=base_parser, llm=llm4o)

# 2.模拟错误的输出
error_str = "{'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}"

# 3.对比修复前后结果
print(f"修复前的内容:{error_str}")
print(f"修复后的内容:{fixing_parser.parse(error_str)}")
</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">修复前的内容:{'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}
修复后的内容:{'name': '登鹳雀楼', 'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}
</code></pre>
<p>除了错误修复机制，LangChain还提供了重试机制，使用示例如下，将大模型输出结果传递给retry_parser，内部会调用<code>PydanticOutputParser</code>的<code>parse()</code>方法，与 <code>OutputFixingParser</code> 不同，<code>RetryOutputParser</code> 会在解析失败时，将原始提示词与输出一并传回模型，尝试重新生成符合格式的内容，如果<code>parse_with_prompt</code>没有报错，不会去触发重试的，同样重试也会多调用一次大模型。</p>
<pre><code class="language-python">import dotenv
from langchain_openai import ChatOpenAI
from langchain.output_parsers import RetryOutputParser
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.pydantic_v1 import BaseModel, Field
from langchain_core.prompts import ChatPromptTemplate

# 读取env配置
dotenv.load_dotenv()


# 定义输出的对象结构
class Poetry(BaseModel):
    name: str = Field(description="古诗名字")
    content: str = Field(description="古诗内容")
    author: str = Field(description="古诗作者")


# 1.定义提示模板
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个资深文学家"),
    ("human", "请你输出题目为：{name}这首诗的内容\n{format_instructions}")
])

llm4o = ChatOpenAI(model="gpt-4o")
# 2.构建输出解析器
base_parser = JsonOutputParser(pydantic_object=Poetry)
retry_parser = RetryOutputParser.from_llm(parser=base_parser, llm=llm4o)

# 3.生成prompt_value
prompt_value = prompt.invoke({"name": "登鹳雀楼", "format_instructions": base_parser.get_format_instructions()})

# 4.模拟错误的输出
error_str = "{'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}"
# 5.对比重试前后结果
print(f"重试前的内容:{error_str}")
print(f"重试后的内容:{retry_parser.parse_with_prompt(error_str, prompt_value)}")

</code></pre>
<p>执行结果：</p>
<pre><code class="language-python">重试前的内容:{'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}
重试后的内容:{'name': '登鹳雀楼', 'content': '白日依山尽，黄河入海流。欲穷千里目，更上一层楼。', 'author': '王之涣'}
</code></pre>
<h2 id="六总结">六、总结</h2>
<p>输出解析器是LangChain框架中不可或缺的组件，它解决了大语言模型输出格式不规范的问题。通过本文的介绍，我们学习了基础解析器的使用从简单的<code>StrOutputParser</code>到复杂的<code>PydanticOutputParser</code>。</p>
<p>我们还了解了结构化数据处理，通过<code>JsonOutputParser</code>和<code>PydanticOutputParser</code>，可以将模型输出转换为结构化的Python对象、JSON对象，便于后续处理。当LangChain提供的内置解析器无法满足需求时，可以创建自定义解析器来处理特殊格式的数据。</p>
<p>在实际项目中，选择合适的输出解析器能够大大提升开发效率和数据处理的准确性。建议根据具体的业务需求，选择最适合的解析器类型，并结合错误处理机制确保系统的稳定性。</p>
<p>下一篇文章我们将继续深入LangChain的其他核心组件，探索更多实用的开发技巧，敬请期待。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-03 11:06">2025-08-03 11:05</span>&nbsp;
<a href="https://www.cnblogs.com/fengyun2019">大志说编程</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19019697);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19019697', targetLink: 'https://www.cnblogs.com/fengyun2019/p/19019697', title: 'LangChain框架入门05：输出解析器使用技巧' })">举报</a>
</div>
        