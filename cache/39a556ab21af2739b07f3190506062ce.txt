
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chaoguo1234/p/18906738" title="发布于 2025-06-02 04:38">
    <span role="heading" aria-level="2">NSDictionary 内存布局</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        NSDictionary 内存布局
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><code>NSDictionary</code>是<code>iOS</code>开发中经常用到的数据结构。</p>
<p>熟悉<code>NSDictionary</code>的内部实现，有助于我们更好的使用它们。</p>
<p>同时，在遇到相关崩溃，也能帮助我们更好的分析问题。</p>
<h1 id="1-类簇">1 类簇</h1>
<p>非可变字典由<code>NSDictionary</code>表示。</p>
<p>可变字典由<code>NSMutableDictionary</code>表示。</p>
<p>按照苹果官方文档的说法，<code>NSDictionary</code>和<code>NSMutableDictionary</code>都是类簇。</p>
<p>也就是说，<code>NSDictionary</code>和<code>NSMutableDictionary</code>只是暴露的公共接口，具体实现由内部众多私有子类完成。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043108820-574520138.png" alt="image" loading="lazy"></p>
<h1 id="2-类图">2 类图</h1>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043126087-1445491464.png" alt="image" loading="lazy"></p>
<h1 id="3-nsdictionary">3 NSDictionary</h1>
<p>下面介绍各个非可变字典的内存布局。</p>
<h2 id="31-__nsdictionary0">3.1 __NSDictionary0</h2>
<p><code>__NSDictioanry0</code>里面没有任何元素。</p>
<pre><code class="language-objectivec">NSDictionary *dict = @{};

NSDictionary *dict = [NSdictionary dictionary];
</code></pre>
<p>上面代码都会创建一个<code>__NSDictionary0</code>。</p>
<pre><code class="language-c++">(lldb) p dict
(__NSDictionary0 *) 0x00000001e3dd2390 0 key/value pairs
</code></pre>
<h2 id="32-nsconstantdictionary">3.2 NSConstantDictionary</h2>
<p>如果字典初始化时<code>key-value</code>对都是字符串常量，那么就会得到一个<code>NSConstantDictionary</code>。</p>
<pre><code class="language-objectivec">NSDictionary *dict = @{
  @"kaaa": @"aaa",
  @"kbbb": @"bbb",
  @"kccc": @"ccc",
  @"kddd": @"ddd",
};
</code></pre>
<p>上面代码会创建一个<code>NSConstantDictionary</code>。</p>
<pre><code class="language-c">(lldb) p dict
(NSConstantDictionary *) 0x00000001021b87c8 4 key/value pairs
</code></pre>
<p>如果<code>key</code>不全是字符串，也不会得到<code>NSConstantDictionary</code>:</p>
<pre><code class="language-objectivec">NSDictionary *dict = @{
        @1: @"aaa",
        @2: @"bbb",
        @3: @"ccc",
        @4: @"ddd",
    };
</code></pre>
<p>上面代码会得到一个<code>__NSDictionaryI</code>:</p>
<pre><code class="language-c">(lldb) p dict
(__NSDictionaryI *) 0x0000600002c0af80 4 key/value pairs
</code></pre>
<h3 id="321-内存布局">3.2.1 内存布局</h3>
<p><code>NSConstantDictionary</code>的内存布局如下图所示:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043209880-1233917645.png" alt="image" loading="lazy"></p>
<p><code>isa</code>指向对应的类对象。</p>
<p><code>options</code>在调试时只遇到过值为<code>1</code>的情形，表示字典的<code>key</code>全是字符串。</p>
<p>当调用<code>-[NSDictionary objectForKey:]</code>方法时，如果参数不是字符串，不会处理:</p>
<pre><code class="language-c">  -[NSConstantDictionary objectForKey:]:
  ...
  // 1. x21 中存储方法参数
  0x180430b60 &lt;+120&gt;: mov    x0, x21
  // 2. w23 存储的计时 options 的值
  0x180430b64 &lt;+124&gt;: tbnz   w23, #0x1, 0x180430b8c    ; &lt;+164&gt;
  // 3. 判断参数是否是字符串
  0x180430b68 &lt;+128&gt;: bl     0x1804cf7ac               ; _NSIsNSString
  ...
</code></pre>
<p>代码注释<code>1</code>，寄存器<code>x21</code>存储方法参数，传递给寄存器<code>x0</code>，作为下面函数<code>_NSIsNSString</code>的参数。</p>
<p>代码注释<code>2</code>，寄存器<code>w23</code>存储<code>options</code>的值，<code>options</code>为<code>1</code>，才会调用下面的函数<code>_NSIsNSString</code>方法。</p>
<p>代码注释<code>3</code>，调用<code>_NSIsNSString</code>方法对参数进行校验。</p>
<p><code>count</code>存储字典中<code>key-value</code>的个数</p>
<p><code>keys</code>是一个指针，指向字典中<code>key</code>所在的数组。</p>
<p><code>values</code>是一个指针，指向字典中<code>value</code>所在的数组。</p>
<h3 id="322-objectforkey">3.2.2 objectForKey:</h3>
<p>使用<code>objectForKey:</code>方法读取一个<code>key</code>对应的<code>value</code>时:</p>
<p><code>1</code> 使用二分法从<code>keys</code>数组中找到对应<code>key</code>所在的索引；</p>
<p><code>2</code> 从<code>values</code>数组中根据索引返回对应的<code>value</code>值。</p>
<pre><code class="language-c">  -[NSConstantDictionary objectForKey:]:
  ...
  // 1. 调用二分法寻找参数在 keys 数组中的地址
  0x180430c58 &lt;+368&gt;: bl     0x180547f18               ; symbol stub for: bsearch
  0x180430c5c &lt;+372&gt;: cbz    x0, 0x180430c6c           ; &lt;+388&gt;
  // 2. 计算参数在 keys 数组中的索引
  0x180430c60 &lt;+376&gt;: sub    x8, x0, x19
  // 3. 获取 value 在 values 数组中地址
  0x180430c64 &lt;+380&gt;: add    x22, x22, x8
  // 4. 获取 value 值
  0x180430c68 &lt;+384&gt;: ldr    x0, [x22]
  ...
</code></pre>
<p>代码注释<code>1</code>，调用二分法<code>bsearch</code>获取参数<code>key</code>在<code>keys</code>数组中所在地址，存储到<code>x0</code>。</p>
<p>代码注释<code>2</code>，<code>x19</code>指向<code>keys</code>数组首地址，这里计算出参数<code>key</code>在<code>keys</code>数组中的偏移量，也就是对应索引。</p>
<p>代码注释<code>3</code>，<code>x22</code>指向<code>values</code>数组首地址，这里计算出<code>value</code>在<code>values</code>数组中的地址。</p>
<p>代码注释<code>4</code>，从<code>values</code>数组中加载出<code>value</code>值，存储到<code>x0</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043249204-577542171.png" alt="image" loading="lazy"></p>
<h2 id="33-__nssingleentrydictionaryi">3.3 __NSSingleEntryDictionaryI</h2>
<p>如果字典中只有一个<code>key-value</code>对，就会得到<code>__NSSingleEntryDictionaryI</code>。</p>
<pre><code class="language-objectivec"> NSDictionary *dict = @{
        @5: @"555",
 };
</code></pre>
<p>上面代码会创建一个<code>__NSSingleEntryDictionaryI</code>:</p>
<pre><code class="language-c">(lldb) p dict
(__NSDictionaryI *) 0x0000600002c0af80 4 key/value pairs
</code></pre>
<p>但是，如果<code>key</code>是字符串，得到的还是<code>NSConstantDictionary</code>:</p>
<pre><code class="language-objectivec">NSDictionary *dict = @{
        @"5": @"555",
};
</code></pre>
<p>上面代码会创建一个<code>NSConstantDictionary</code>:</p>
<pre><code class="language-c">(lldb) p dict
(NSConstantDictionary *) 0x000000010445c7d8 1 key/value pair
</code></pre>
<h3 id="331-内存布局">3.3.1 内存布局</h3>
<p><code>__NSSingleEntryDictionaryI</code>的内存局部如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043324672-1599144723.png" alt="image" loading="lazy"></p>
<p><code>isa</code>指向对应类对象。</p>
<p><code>key</code>是一个指针，指向对应的<code>key</code>值</p>
<p><code>value</code>是一个指针，指向对应的<code>value</code>值。</p>
<h3 id="332-objectforkey">3.3.2 objectForKey:</h3>
<p><code>__NSSingleEntryDictionaryI</code>调用<code>objectForKey:</code>比较简单:</p>
<p><code>1</code> 比较参数是否和存储的<code>key</code>值相等；</p>
<p><code>2</code> 如果相等，就将存储的<code>value</code>返回。</p>
<h2 id="34-__nsdictionaryi">3.4 __NSDictionaryI</h2>
<p>大多数情况下，创建的<code>NSDictionary</code>对象，对应的类都是<code>__NSDictionaryI</code>。</p>
<h3 id="341-初始化">3.4.1 初始化</h3>
<p>通常我们会使用下面的函数初始化一个<code>NSDictionary</code>对象:</p>
<pre><code class="language-objectivec">NSDictionary *dict = @{
    @"kaaa": @"aaa",
    @"kbbb": @"bbb",
    @"kccc": @"ccc",
    @"kddd": @"ddd",
};

NSDictionary *dictI = [NSDictionary dictionaryWithDictionary:dict];
</code></pre>
<p>上面函数会创建一个<code>__NSDictionaryI</code>对象:</p>
<pre><code class="language-c">(lldb) p dictI
(__NSDictionaryI *) 0x0000600002c07f80 4 key/value pairs
</code></pre>
<p>下面我们来看一下<code>+[NSDictionary dictionaryWithDictionary:]</code>方法的初始化过程。</p>
<pre><code class="language-objectivec">CoreFoundation`+[NSDictionary dictionaryWithDictionary:]:
-&gt;  ...
    0x1804b81a4 &lt;+12&gt;: mov    x19, x2
    // 1. 调用 objc_alloc 方法
    0x1804b81a8 &lt;+16&gt;: bl     0x1805488cc               ; symbol stub for: objc_alloc
    0x1804b81ac &lt;+20&gt;: mov    x2, x19
    0x1804b81b0 &lt;+24&gt;: mov    w3, #0x0                  ; =0 
    // 2. 调用 initWithDictionary:copyItems: 方法
    0x1804b81b4 &lt;+28&gt;: bl     0x180757aa0               ; objc_msgSend$initWithDictionary:copyItems:
    ...
</code></pre>
<p>代码注释<code>1</code>，调用<code>objc_alloc</code>为一个<code>NSDictionary</code>对象的内存空间。</p>
<p>代码注释<code>2</code>，调用<code>initWithDictionary:copyItems:</code>方法初始化第<code>1</code>步分配的内存空间。</p>
<p>但是当断点到<code>initWithDictionary:copyItems:</code>方法时，发现调用的是<code>-[__NSPlaceholderDictionary initWithDictionary:compyItems:]</code>方法，而不是期望的<code>-[__NSDictionaryI initWithDictionary:copyItems:]</code>方法。</p>
<pre><code class="language-objectivec">CoreFoundation`-[__NSPlaceholderDictionary initWithDictionary:copyItems:]:
-&gt;  0x180528b2c &lt;+0&gt;:   sub    sp, sp, #0x60
    0x180528b30 &lt;+4&gt;:   stp    x24, x23, [sp, #0x20]
    0x180528b34 &lt;+8&gt;:   stp    x22, x21, [sp, #0x30]
    0x180528b38 &lt;+12&gt;:  stp    x20, x19, [sp, #0x40]
    0x180528b3c &lt;+16&gt;:  stp    x29, x30, [sp, #0x50]
</code></pre>
<p>那就说明，方法<code>objc_alloc</code>分配了一个<code>__NSPlaceholderDictionary</code>对象。</p>
<p>从上面的类图可以知道，<code>__NSPlaceholderDictionary</code>继承自<code>NSMutableDictionary</code>。</p>
<p><strong>非可变字典从可变字典初始化而来，出乎意料之外</strong>。</p>
<p>下面就来看下<code>objc_alloc</code>的实现。</p>
<p><code>objc_alloc</code>函数源码位于<code>objc4</code>中的<code>NSObject.mm</code>文件中。</p>
<p>但是我们还是从汇编角度来看一下它的实现。</p>
<pre><code class="language-c">libobjc.A.dylib`objc_alloc:
    ...
    // 1. 获取 isa 指针
    0x1800917dc &lt;+4&gt;:  ldr    x8, [x0]
    // 2. 掩码运算，剔除 isa 指针中的多余值
    0x1800917e0 &lt;+8&gt;:  and    x8, x8, #0x7ffffffffffff8
    // 3. 加载 AWZ 标志位
    0x1800917e4 &lt;+12&gt;: ldrh   w8, [x8, #0x1e]
    // 4. 判断是否没有设置 AWZ 标志
    0x1800917e8 &lt;+16&gt;: tbz    w8, #0xe, 0x1800917f4     ; &lt;+28&gt;
    // 5. 有 AWZ 标志位，就跳转执行 _objc_rootAllocWithZone 函数
    0x1800917ec &lt;+20&gt;: b      0x180086eec               ; _objc_rootAllocWithZone
    0x1800917f0 &lt;+24&gt;: ret    
    0x1800917f4 &lt;+28&gt;: adrp   x8, 482527
    // 6. 如果没有设置了 AWZ 标志，执行 allocWithZone: 方法
    0x1800917f8 &lt;+32&gt;: add    x1, x8, #0x6e0
    0x1800917fc &lt;+36&gt;: b      0x18006b400               ; objc_msgSend
</code></pre>
<p>代码注释<code>1</code>，获取<code>isa</code>指针。</p>
<p>由于我们调用<code>objc_alloc</code>传入的是<code>NSDictionary.class</code>对象，所以这里的<code>isa</code>指针指向<code>NSDictionary.class</code>的元类。</p>
<p><img src="https://files.mdnice.com/user/8441/d0bb7391-a1c7-4a1d-a197-5cba5823e2e8.png" alt="" loading="lazy"></p>
<p>代码注释<code>2</code>，对<code>isa</code>指针做掩码运算，剔除不相干的位。</p>
<p>众所周知，<code>iOS</code>中的<code>isa</code>并不是所有的<code>bit</code>都是类对象指针，有些<code>bit</code>用作了其他用处。</p>
<p><code>iOS 12</code>又引入了<code>PAC</code>指针验证机制，<code>isa</code>各个<code>bit</code>的使用有了变化。</p>
<p>下面是<code>objc4</code>源码中，对<code>isa</code>指针的最新定义:</p>
<pre><code>// isa.h
...
#   elif __has_feature(ptrauth_calls) || TARGET_OS_SIMULATOR
#     define ISA_MASK        0x007ffffffffffff8ULL
#     define ISA_MAGIC_MASK  0x0000000000000001ULL
#     define ISA_MAGIC_VALUE 0x0000000000000001ULL
#     define ISA_HAS_CXX_DTOR_BIT 0
#     define ISA_BITFIELD                                           
        uintptr_t nonpointer        : 1;  // 此标志为 1，表明 isa 指针并不是纯粹的类指针                            
        uintptr_t has_assoc         : 1;  // 是否有关联对象             
        uintptr_t weakly_referenced : 1;  // 是否有弱引用             
        uintptr_t shiftcls_and_sig  : 52;  // 真正的类指针             
        uintptr_t has_sidetable_rc  : 1;  // 是否启用了 sidetable 来引用计数                  
        uintptr_t extra_rc          : 8 // 优先使用 8 bit 进行引用计数
</code></pre>
<p>从定义中可以看到，<code>isa</code>指针中，只有<code>52bit</code>用于真正的类指针。</p>
<p>因此，<code>isa</code>指针的掩码为<code>0x7ffffffffffff8</code>，刚好<code>52</code>个<code>1</code>。</p>
<p>代码注释<code>3</code>，加载<code>NSDictionary</code>的元类中的<code>AWZ</code>标志。</p>
<p><code>AWZ</code>就是<code>AllocWithZone</code>的简写。</p>
<p>如果设置了<code>AWZ</code>标志，就说明这个类用默认的<code>alloc</code>或者<code>allocWithZone:</code>方法。</p>
<p>如果不设置<code>AWZ</code>标志，那就说明这个类对于<code>alloc</code>或者<code>allocWithZone:</code>方法有自己的实现。</p>
<p>我们可以看到在<code>objc4</code>源码中有对应的注释:</p>
<pre><code class="language-c">// objc-runtime-new.h
// class or superclass has default alloc/allocWithZone: implementation
// Note this is is stored in the metaclass.
#   define FAST_CACHE_HAS_DEFAULT_AWZ    (1&lt;&lt;14)
</code></pre>
<p>这个标志为<code>0</code>，说明该类自定义了<code>alloc</code>或者<code>allocWithZone:</code>方法。</p>
<p>那这个标志存在什么地方法呢？</p>
<p>从<code>objc4</code>源码可知，这个标志存在元类对象的<code>flags</code>属性中:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043429838-1068980260.png" alt="image" loading="lazy"></p>
<p>这个<code>flags</code>属性偏移元类对象首地址<code>0x1e</code>个字节。</p>
<p>代码注释<code>4</code>，判断是否没有设置<code>AWZ</code>标志。</p>
<p>从第<code>3</code>步介绍可知，<code>AWZ</code>标志设置在第<code>14</code>位，<code>tbz</code>指令查看<code>flags</code>的第<code>14</code>位是否为<code>0</code>。</p>
<p>代码注释<code>5</code>，如果设置了<code>AWZ</code>标志，那么使用使用默认的<code>alloc</code>或者<code>allocWithZone:</code>方法。</p>
<p>代码注释<code>6</code>，如果没有设置<code>AWZ</code>标志，那么就说明<code>NSDictionary</code>有自定义的<code>alloc</code>或者<code>allocWithZone:</code>方法。</p>
<p><code>x1</code>寄存器存储着<code>objc_msgsend</code>要调用的方法名，打印可知，这个方法正是<code>alloc</code>:</p>
<pre><code class="language-c">(lldb) po (char *)$x1
"alloc"
</code></pre>
<p>最终，方法会调用到<code>+[NSDictionary allocWithZone:]</code>方法。</p>
<p>下面来看一下<code>+[NSDictionary allocWithZone:]</code>的实现。</p>
<pre><code class="language-objectivec">CoreFoundation`+[NSDictionary allocWithZone:]:
    ...
    0x1804b6d04 &lt;+28&gt;:  adrp   x8, 407836
    0x1804b6d08 &lt;+32&gt;:  ldr    x8, [x8, #0x600]
    // 1. 比较当前类对象是否是 NSDictionary
-&gt;  0x1804b6d0c &lt;+36&gt;:  cmp    x8, x0
    0x1804b6d10 &lt;+40&gt;:  b.eq   0x1804b6d64               ; &lt;+124&gt;
    0x1804b6d14 &lt;+44&gt;:  adrp   x8, 407836
    0x1804b6d18 &lt;+48&gt;:  ldr    x8, [x8, #0x608]
    // 2. 比较当前类对象是否是 NSMutableDictionary
    0x1804b6d1c &lt;+52&gt;:  cmp    x8, x0
    0x1804b6d20 &lt;+56&gt;:  b.eq   0x1804b6d88               ; &lt;+160&gt;
    ...
    // 3. 当前类是 NSDictionary，将执行 __NSDictionaryImmutablePlaceholder 方法
    0x1804b6d84 &lt;+156&gt;: b      0x180528728               ; __NSDictionaryImmutablePlaceholder
    ...
    // 4. 当前类是 NSMutableDictionary，将执行 __NSDictionaryMutablePlaceholder 方法
    0x1804b6da8 &lt;+192&gt;: b      0x180528734               ; __NSDictionaryMutablePlaceholder
</code></pre>
<p>代码注释<code>1</code>，寄存器<code>x8</code>存储<code>NSDictionary</code>的类地址，寄存器<code>x0</code>存储当前类地址。</p>
<p>这里比较当前类地址是否是<code>NSDictionary</code>类。</p>
<p>如果比较成功，就会跳转执行<code>__NSDictionaryImmutablePlaceholder</code> 方法。</p>
<p>代码注释<code>2</code>，寄存器<code>x8</code>存储<code>NSMutableDictionary</code>的类地址。</p>
<p>这里比较当前类地址是否是<code>NSMutableDictionary</code>类。</p>
<p>如果比较成功，就会跳转执行<code>__NSDictionaryMutablePlaceholder</code>方法。</p>
<p>由于我们现在创建非可变字典，因此，代码最终会执行<code>__NSDictionaryImmutablePlaceholder</code>方法。</p>
<p><code>__NSDictionaryImmutablePlaceholder</code>方法很简单，直接返回一个<code>__NSPlaceholderDictionary</code>对象:</p>
<pre><code class="language-objectivec">CoreFoundation`__NSDictionaryImmutablePlaceholder:
    0x180528728 &lt;+0&gt;: adrp   x0, 407690
    0x18052872c &lt;+4&gt;: add    x0, x0, #0x338            ; ___immutablePlaceholderDictionary
-&gt;  0x180528730 &lt;+8&gt;: ret 
</code></pre>
<p>打印返回的对象:</p>
<pre><code class="language-c">(lldb) po [$x0 class]
__NSPlaceholderDictionary
</code></pre>
<p>顺便看一下<code>__NSDictionaryMutablePlaceholder</code>方法:</p>
<pre><code class="language-objectivec">CoreFoundation`__NSDictionaryMutablePlaceholder:
    0x180528734 &lt;+0&gt;: adrp   x0, 407690
    0x180528738 &lt;+4&gt;: add    x0, x0, #0x348            ; ___mutablePlaceholderDictionary
-&gt;  0x18052873c &lt;+8&gt;: ret
</code></pre>
<p>方法也很简单，也是直接返回一个<code>__NSPlaceholderDictionary</code>对象:</p>
<pre><code class="language-c">(lldb) po [$x0 class]
__NSPlaceholderDictionary
</code></pre>
<p><code>__NSPlaceholderDictionary</code>对象的创建流程我们已经清楚了。</p>
<p>接下来，继续看<code>-[__NSPlaceholderDictionary initWithDictionary:copyItems:]</code>方法。</p>
<p>汇编代码不看了，直接上伪代码:</p>
<pre><code class="language-objectivec">@interface __NSPlaceholderDictionary
...
@end

@implementation

- (instancetype)initWithDictionary:(NSDictionary *)dict copyItems:(BOOL)shouldCopy {
  if (dict.class != __NSDictionaryI.class &amp;&amp; dict.class != __NSDictionaryM.class &amp;&amp; dict.class != __NSFrozenDictionaryM.class) {
  return [super initWithDictionary:dict copyItems:shouldCopy];
  }
  
  if (self == ___mutablePlaceholderDictionary) {
    return [dict mutableCopyWithZone:0];
  }
  
  if (self == ___immutablePlaceholderDictionary) {
    return [dict copyWithZone:0];
  }
  
}
@end
</code></pre>
<p><code>__NSDictionaryM</code>和<code>__NSFrozenDictionaryM</code>在介绍可变字典时会涉及。</p>
<p>字典的拷贝在介绍完可变与非可变字典后会涉及。</p>
<p>由于本次例子中，我们使用的是一个<code>NSConstantDictionary</code>进行初始化，因此会调用到<code>-[super initWithDictionary:copyItems:]</code>方法。</p>
<p><code>__NSPlaceholderDictionary</code>的<code>super</code>中，<code>NSDictionary</code>实现了这个方法。</p>
<p><code>-[NSDictionary initWithDictionary:copyItems:]</code>不看汇编了，伪代码如下:</p>
<pre><code class="language-objectivec">@interface NSDictionary
...
@end

@implementation

- (instancetype)initWithDictionary:(NSDictionary *)dict copyItems:(BOOL)shouldCopy {
  NSInteger count = dict.count;
  if （count &gt;= 2^60) {
    // 创建的字典 key-value 对不能超过 2^60
    error "attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"
  }
  
  NSObject *keys = nil;
  NSObject *objects = nil;
  if (count &lt;= 0x100) {
    // key-value 对数量 &lt;= 256，在栈上分配空间
    NSObject * keysArr[count];
    NSObject * objectsArr[count];
    keys = keysArr;
    objects = objectsArr;
  } else {
   // key-value 对数量 &gt; 256，在堆上分配空间
   keys = _CFCreateArrayStorage(count, 0);
   objects = _CFCreateArrayStorage(count, 0);
  }
  
  // 读取参数 dict 的 keys 和 objects 到分配的数组中
  [dict getObjects:objects keys:keys count:count];
  
  if (count != 0 &amp;&amp; shouldCopy) {
    // 拷贝 key-value 对
    for (NSInteger i = 0; i &lt; count; i++) {
      NSObject *key = keys[i];
      keys[i] = [key copyWithZone:nil];
    }
    
    for (NSInteger i = 0; i &lt; count; i++) {
      NSObject *object = objects[i];
      objects[i] = [object copyWithZone:nil];
    }
  }
  
  return [self initWithObjects:objects forKeys:keys count:count]; 
}
</code></pre>
<p>从上面伪代码可以看到，最终会调用<code>NADictionary</code> 的<code>initWithObjects:forKeys:count:</code>方法完成初始化。</p>
<p><code>initWithObjects:forKeys:count:</code>正是<code>NSDictionary</code>的<code>designated initializer</code>方法。</p>
<p>下面就来看下这个方法。</p>
<p>由于此时的<code>self</code>真正的类型为<code>__NSPlaceholderDictionary</code>，所以此时真正调用的方法为<code>-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]</code>。</p>
<p>下面我们就来看这个方法的伪代码:</p>
<pre><code class="language-objectivec">// -[__NSPlaceholderDictionary initWithObjects:forKeys:count]

@interface __NSPlaceholderDictionary

...

@end

@implementation __NSPlaceholderDictionary

- (instancetype)initWithObjects:(ObjectType const[])objects forKeys:(ObjectTpye const[])keys count:(NSUInteger)count {
  if (keys == nil &amp;&amp; count == 0) {
    goto label;
  }
  
  if (keys == nil &amp;&amp; count != 0) {
    // 报错
    error "pointer to objects array is NULL but length is {count}";
  }
  
  if (keys != nil &amp;&amp; count == 0 {
    goto label;
  }
  
  if (keys != nil &amp;&amp; count != 0) {
    // 检测 keys 数组里的值是否有 nil
    for (NSInteger i = 0; i &lt; count; i++) {
      ObjectType key = keys[i];
      if (key == nil) {
        // 报错
        error "attempt to insert nil object from objects{[i]}";
      }
    }
  }
  
  if (objects == nil &amp;&amp; count == 0) {
    goto label;
  }
  
  if (objects == nil &amp;&amp; count != 0) {
    // 报错
    error "pointer to objects array is NULL but length is {count}";
  }
  
  if (objects != nil &amp;&amp; count == 0) {
    goto label;
  }
  
  if (objects != nil &amp;&amp; count != 0) {
    // 检测 objects 数组里是否有 nil
    for (NSInteger i = 0; i &lt; count; i++) {
      ObjectType object = objects[i];
      if (object == nil) {
        error "attempt to insert nil object from objects{[i]}";
      }
    }
  }
  
  label:
  if (self == ___immutablePlaceholderDictionary) {
    if (count == 0) {
      // 创建 __NSDictionary0
      return __NSDictionary0__();
    }
    
    if (count == 1) {
      // 创建 __NSSingleEntryDictionaryI
      return __NSSingleEntryDictionaryI_new(keys[0], objects[0], 1);
    }
    
    // 创建 __NSDictionaryI
    return __NSDictionaryI_new(keys, objects, 0, count, 1);
  } else if (self == ___mutablePlaceholderDictionary) {
    // 创建 __NSDictionaryM
    return __NSDictionaryM_new(keys, objecs, count, 3);
  }
  
  error "创建出错"
}
</code></pre>
<p>上面伪代码中，<code>___immutablePlaceholderDictionary</code>和<code>___mutablePlaceholderDictionary</code>在前面介绍<code>alloc</code>方法时提到过。</p>
<p>这里重点看下<code>__NSDictionryI_news</code>方法。</p>
<p><code>__NSDictionaryI_news</code>内部首先根据<code>count</code>值，遍历一个全局数组<code>__NSDictionaryCapacities</code>。</p>
<p><code>__NSDictionaryCapacities</code>总共有<code>64</code>项，每一项代表字典的<code>capacity</code>:</p>
<pre><code class="language-c">0x1803cc548 &lt;+72&gt;:  adrp   x8, 451
0x1803cc54c &lt;+76&gt;:  add    x8, x8, #0xc88            ; __NSDictionaryCapacities
</code></pre>
<p>在<code>Xcode</code>的<code>lldb</code>查看其内容为:</p>
<pre><code class="language-c">(lldb) x/64g $x8
0x18058fc88: 0x0000000000000000 0x0000000000000003
0x18058fc98: 0x0000000000000006 0x000000000000000b
0x18058fca8: 0x0000000000000013 0x0000000000000020
0x18058fcb8: 0x0000000000000034 0x0000000000000055
...
0x18058fe78: 0xc1d7fb9980000000 0xc2625e72e7800000
</code></pre>
<p>从上面的输出可以看到:</p>
<p>第<code>0</code>项的值为<code>0</code>；</p>
<p>第<code>1</code>项的值为<code>3</code>；</p>
<p>第<code>63</code>项的值为<code>0xc2625e72e7800000</code>，已经非常大了。</p>
<p>遍历<code>__NSDictionaryCapacity</code>数组的目的，是为了找到一个索引，这个索引对应的<code>capacity</code>大于或者等于<code>count</code>。</p>
<p>对应的伪代码为:</p>
<pre><code class="language-objectivec">BOOL found = NO;
NSInteger index = 0;
for (; index &lt; 64; index++) {
  if (__NSDictionaryCapacity[i] &gt;= count) {
    found = YES;
    break;
  }
}

if (!found) {
  error "不能创建 NSDictionary";
}
</code></pre>
<p>如果遍历了全部的<code>64</code>想，仍然没有满足条件的索引，那么程序就会<code>crash</code>。</p>
<p>需要注意的是，<code>__NSDictionaryCapacity</code>中存储的<code>capacity</code>，并不是要创建的字典的大小。</p>
<p>要创建的字典的大小，存储在全局变量<code>__NSDictionarySizes</code>中:</p>
<pre><code class="language-c">0x1803cc56c &lt;+108&gt;: adrp   x8, 451
0x1803cc570 &lt;+112&gt;: add    x8, x8, #0xb40            ; __NSDictionarySizes
</code></pre>
<p>在<code>Xcode</code>的<code>lldb</code>中查看其内容为:</p>
<pre><code class="language-c">(lldb) x/64g $x8
0x18058fb40: 0x0000000000000000 0x0000000000000003
0x18058fb50: 0x0000000000000007 0x000000000000000d
0x18058fb60: 0x0000000000000017 0x0000000000000029
0x18058fb70: 0x0000000000000047 0x000000000000007f
0x18058fb80: 0x00000000000000bf 0x00000000000000fb
...
</code></pre>
<p>从输出可以看到，除了第<code>0</code>项和第<code>1</code>项之外，其他各项的值与<code>__NSDictionaryCapacity</code>中的值都不相等。</p>
<p>通过上面遍历<code>__NSDictionaryCapacity</code>数组查找到的索引，就可以获取到要创建字典的大小:</p>
<pre><code class="language-objectivec">
NSUInteger size = __NSDictionarySizes[index];

</code></pre>
<p>按照道理，直接遍历<code>__NSDictionarySizes</code>也能达到效果。</p>
<p>至于为什么要分成<code>2</code>个数组<code>__NSDictionaryCapacity</code>和<code>__NSDictionarySizes</code>，暂时还不清楚原因。</p>
<p>有了要创建字典的大小，接下来就会创建对应的<code>__NSDictionaryI</code>对象:</p>
<pre><code class="language-objectivec">
___NSDictionaryI *dictI = __CFAllocateObject(__NSDictionaryI.class, size * 8 * 2);
</code></pre>
<p>上面代码中使用<code>size * 8 * 2</code>的原因是:</p>
<p><code>size</code>代表<code>key-value</code>对的个数；</p>
<p>每一个<code>key</code>或者<code>value</code>占用<code>8</code>字节；</p>
<p>因此，一个<code>key-value</code>对占用<code>16</code>字节。</p>
<p>创建出的<code>__NSDictionaryI</code>对象，此时还没有存储任何的<code>key-value</code>对。</p>
<p>其内存布局此时为:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043538552-1327958399.png" alt="image" loading="lazy"></p>
<p>从内存布局可以看到，<code>key-value</code>对将直接存储在对象当中。</p>
<p>在存储<code>key-value</code>之前，还有一些其他属性需要存储在<code>__NSDictionaryI</code>对象中。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043618221-209654052.png" alt="image" loading="lazy"></p>
<p>如上图所示:</p>
<p>第<code>8</code>字节的高<code>6 bit</code>存储这个字典对象<code>size</code>的索引，<code>6 bit</code>最多可以存储<code>64</code>项。</p>
<p>第<code>8</code>字节的第<code>7 bit</code>存储<code>__NSDictionaryI._copyKey</code>标志，但是现在暂时不知道它的作用。</p>
<p>第<code>8</code>字节剩余的<code>57 bit</code>存储实际的<code>key-value</code>对个数，初始值为<code>count</code>值。</p>
<p>这里有一个问题。</p>
<p>前面<code>-[NSDictionary initWithDictionary:copyItems:]</code>方法内部会对<code>count</code>值进行判断:</p>
<pre><code class="language-objectivec">if （count &gt;= 2^60) {
    // 创建的字典 key-value 对不能超过 2^60
    error "attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"
  }
</code></pre>
<p>可以看到，<code>count</code>的值最多可以占用<code>60 bit</code>。</p>
<p>但是这里只使用<code>57 bit</code>来存储<code>count</code>的值，不知道是不是<code>Apple</code>的<code>BUG</code>。</p>
<p>设置好这些属性，接下来就要遍历<code>keys</code>和<code>objects</code>数组，通过一个栈<code>block</code>给<code>__NSDictionaryI</code>对象填充<code>key-value</code>对:</p>
<pre><code class="language-objectivec">for (NSInteger i = 0; i &lt; count; i++) {
  ObjectType key = keys[i];
  ObjectTpye object = objects[i];
  ____NSDictionaryI_new_block_invoke(key, value);
}
</code></pre>
<p><code>____NSDictionaryI_new_block_invoke</code>内部，首先对<code>key</code>调用<code>hash</code>函数获取器哈希值:</p>
<pre><code class="language-objectivec">NSUInteger hashValue = [key hash];
</code></pre>
<p>计算出哈希值后，对字典的<code>size</code>进行取余，得到的结果作为<code>__NSDictionaryI</code>对象中，<code>key-value</code>对数组的索引:</p>
<pre><code class="language-objectivec">NSUInteger index = hashValue % size;
</code></pre>
<p><code>__NSDictionaryI</code>对象中的<code>key-value</code>对数组记作<code>__NSDictionaryI._list</code>。</p>
<p>有了<code>index</code>索引值，就可以从<code>__NSDictionaryI._list</code>数组中取出对应的值:</p>
<pre><code class="language-objectivec">ObjectType oldKey = __NSDictionaryI._list[index];
</code></pre>
<p>如果<code>oldKey</code>为<code>nil</code>，说明这个位置之前没有值，那么当前的<code>key-value</code>对可以安全的存储到这个位置:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043646367-670169018.png" alt="image" loading="lazy"></p>
<p><strong>需要注意的是，写入的时对 key 进行了 copy</strong>。</p>
<pre><code class="language-objecivec">[key copyWithZone:nil];
</code></pre>
<p>因此，字典中的<code>key</code>必须实现<code>copy</code>协议。</p>
<p>如果<code>oldKey</code>不为<code>nil</code>，说明这个位置已经被占用了，发生了<code>hash</code>冲突。</p>
<p>这时，需要分情形处理。</p>
<p>如果<code>oldKey</code>与<code>key</code>是同一个对象，或者他们的<code>isEqual</code>方法相等:</p>
<pre><code class="language-objectivec">
if (oldKey == key || [oldKey isEqual:key]) {
  ...
}
</code></pre>
<p>那么，当前的<code>key-value</code>对不会被写入，会被丢弃，同时<code>__NSDictionaryI._used</code>会减<code>1</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043658741-349880220.png" alt="image" loading="lazy"></p>
<p>如果<code>oldKey</code>与<code>key</code>不是同一个对象，同时，<code>isEqual</code>方法也不相等，那么就会从当前索引开始，遍历整个<code>__NSDictionaryI._list</code>数组。</p>
<p>如果遍历的过程中，找到了空位，那么就写入<code>key-value</code>对。</p>
<p>如果遍历的过程中，出现了上面<code>oldKey</code>与<code>key</code>相等的情形，那么就丢弃当前的<code>key-value</code>对，同时<code>__NSDictionaryI._used</code>减<code>1</code>。</p>
<p>由于字典的<code>size</code>总是大于或者等于<code>count</code>，因此不会出现遍历整个<code>__NSDictionaryI._list</code>数组，也找不到空位的情形。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043711771-444009233.png" alt="image" loading="lazy"></p>
<h3 id="342-内存布局">3.4.2 内存布局</h3>
<p><code>__NSDictionaryI</code>对象完整的内存布局如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043723434-1314348612.png" alt="image" loading="lazy"></p>
<h3 id="343-objectforkey">3.4.3 objectForKey:</h3>
<p><code>-[__NSDictionaryI objectForKey:]</code>方法首先调用参数<code>key</code>的<code>hash</code>方法:</p>
<pre><code class="language-objectivec">NSUInteger hashValue = [key hash];
</code></pre>
<p>和初始化过程一样，获取哈希值目的是为了得到<code>__NSDictionaryI._list</code>数组中的索引:</p>
<pre><code class="language-objectivec">NSUInteger index = hashValue % size;
</code></pre>
<p>那此时<code>size</code>是如何得到的呢？</p>
<p>上面<code>__NSDictionaryI</code>对象的内存布局可以知道，<code>size</code>的索引存储在第<code>8</code>字节上。</p>
<p>获取到这个值，就可以从<code>__NSDictionarySizes</code>数组中，取得<code>size</code>值。</p>
<p>获取到<code>index</code>之后，就可以从<code>__NSDictionaryI._list</code>数组中的值:</p>
<pre><code class="language-objectivec">ObjectType candidateKey = __NSDictionaryI._list[index];
</code></pre>
<p>如果<code>candidateKey</code>为<code>nil</code>，说明这个位置根本没有值，那么直接返回<code>nil</code>。</p>
<p>如果<code>candidateKey</code>不为<code>nil</code>，那么就看<code>candidateKey</code>与参数<code>key</code>是否是同一个对象，或者两者的<code>isEqual</code>方法相等:</p>
<pre><code class="language-objectivec">if (candidateKey == key || [candidateKey isEqual:key]) {
  ...
}
</code></pre>
<p>这种情况下，就是找到了目标<code>key-value</code>对，直接将对应的<code>value</code>值返回。</p>
<p>如果<code>candidateKey</code>与参数<code>key</code>既不是同一个对象，它们的<code>isEqual</code>方法也不相等，那么就从当前的<code>index</code>处开始遍历整个<code>__NSDictionaryI._list</code>数组。</p>
<p>这个过程和初始化过程有点类似:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250602043745465-678333161.png" alt="image" loading="lazy"></p>
<p>遍历过程中，如果有<code>candidateKey</code>与参数<code>key</code>是同一个对象，或者<code>isEqual</code>方法相等，那么就找到了目标<code>key-value</code>对，直接返回<code>value</code>值。</p>
<p>如果遍历了整个数组，还是没有发现目标<code>key-value</code>对，就返回<code>nil</code>。</p>
<p>可以看到，如果哈希冲突比较严重，<code>objectForKey:</code>并不能<code>O(1)</code>时间返回目标值，可能需要<code>O(size)</code>的时间。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4885991462962963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-02 04:39">2025-06-02 04:38</span>&nbsp;
<a href="https://www.cnblogs.com/chaoguo1234">chaoguo1234</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18906738);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18906738', targetLink: 'https://www.cnblogs.com/chaoguo1234/p/18906738', title: 'NSDictionary 内存布局' })">举报</a>
</div>
        