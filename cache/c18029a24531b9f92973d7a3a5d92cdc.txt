
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sword-successful/p/18650066" title="发布于 2025-01-03 14:27">
    <span role="heading" aria-level="2">.NET Core + Kafka 开发指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/359374/1735804678982-fdba62e2-0bda-4198-82d9-6848357435b5.jpeg" alt="" loading="lazy"></p>
<h1 id="什么是kafka">什么是Kafka</h1>
<p><font style="color: rgba(6, 6, 7, 1)">Apache Kafka是一个分布式流处理平台，由LinkedIn开发并开源，后来成为Apache软件基金会的顶级项目。Kafka主要用于构建实时数据管道和流式应用程序。</font></p>
<p><em><font style="color: rgba(6, 6, 7, 1)"></font></em></p>
<h1 id="kafka-架构">Kafka 架构</h1>
<p>从下面3张架构图中可以看出Kafka Server 实际扮演的是Broker的角色， 一个Kafka Cluster由多个Broker组成， 或者可以说是多个Topic组成。</p>
<p>图 1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/359374/1735803149887-a2bad129-d707-4090-885b-87687d78f76f.png" alt="" loading="lazy"></p>
<p>图 2</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/svg/359374/1735803646595-0f47a20f-9ee5-409f-b3ca-82d02a689627.svg" alt="" loading="lazy"></p>
<p>图 3</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/359374/1735803258104-67e3ad27-ca07-48a5-99e8-8cdab9b6b17a.png" alt="" loading="lazy"></p>
<h1 id="主要概念main-concepts和术语terminology">主要概念(Main Concepts)和术语(Terminology)</h1>
<h3 id="kafka-cluster">Kafka Cluster</h3>
<p><font style="color: rgba(6, 6, 7, 1)">一个Kafka集群是一个由多个Kafka代理组成的分布式系统，它们协同工作以处理实时流数据的存储和处理。它为大规模应用程序中高效的数据流和消息传递提供了容错性、可扩展性和高可用性。</font></p>
<h3 id="broker"><font style="color: rgba(6, 6, 7, 1)">Broker</font></h3>
<p>Broker是构成Kafka集群的服务器。 每个Broker负责接收、存储和提供数据。 它们处理来自生产者和消费者的读写操作。 Broker还管理数据的复制以确保容错性。</p>
<h3 id="topic-and-partitions">Topic and Partitions</h3>
<p><font style="color: rgba(6, 6, 7, 1)">Kafka中的数据被组织成主题（Topics），这些是生产者发送数据和消费者读取数据的逻辑通道。每个主题被划分为分区（partitions），它们是Kafka中并行处理的基本单位。分区允许Kafka通过在多个Broker 之间分布数据来水平扩展。</font></p>
<h3 id="producers">Producers</h3>
<p><font style="color: rgba(6, 6, 7, 1)">生产者是发布（写入）数据到Kafka主题的客户端应用程序。它们根据分区策略将记录发送到适当的主题和分区，分区策略可以是基于键（key-based）或轮询（round-robin）。</font></p>
<h3 id="consumers"><font style="color: rgba(6, 6, 7, 1)">Consumers</font></h3>
<p>消费者是订阅Kafka主题并处理数据的客户端应用程序。它们从主题中读取记录，并且可以是消费者组的一部分，这允许负载均衡和容错。每个组中的消费者从一组独特的分区中读取数据。</p>
<h3 id="zookeeper">Zookeeper</h3>
<p>ZooKeeper是一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供群组服务。在Kafka中，ZooKeeper用于管理和协调Kafka Broker。ZooKeeper被展示为与Kafka集群交互的独立组件。</p>
<h3 id="offsets">Offsets</h3>
<p>偏移量（offsets）是分配给分区中每条消息的唯一标识符。消费者将使用这些偏移量来跟踪他们在消费主题中消息的进度。</p>
<h1 id="kafka-vs-rabbitmq">Kafka vs RabbitMQ</h1>
<h2 id="相同点">相同点</h2>
<ol>
<li><strong>消息队列功能</strong>
<ul>
<li>Kafka和RabbitMQ都是流行的消息队列工具，支持生产者-消费者模式，能够解耦系统，提高系统的可扩展性和可靠性。</li>
</ul>
</li>
<li><strong>异步通信</strong>
<ul>
<li>两者都支持异步通信，允许生产者发送消息后立即返回，消费者可以异步处理消息。</li>
</ul>
</li>
<li><strong>多种消息传递模式</strong>
<ul>
<li>均支持点对点（P2P）和发布/订阅（Pub/Sub）模式。</li>
</ul>
</li>
<li><strong>持久化支持</strong>
<ul>
<li>Kafka和RabbitMQ都支持消息的持久化，以确保在系统故障或重启后消息不会丢失。</li>
</ul>
</li>
<li><strong>高可用性</strong>
<ul>
<li>两者都支持集群部署，具有高可用性和容错能力。</li>
</ul>
</li>
<li><strong>语言支持</strong>
<ul>
<li>提供多种语言的客户端库，支持不同编程语言的集成。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="不同点">不同点</h2>
<h3 id="架构和设计">架构和设计</h3>
<ol>
<li><strong>数据存储</strong>
<ul>
<li>Kafka：基于日志分区存储设计，适合高吞吐量的顺序读写。</li>
<li>RabbitMQ：基于AMQP协议，消息存储在队列中，适合低延迟的场景。</li>
</ul>
</li>
<li><strong>消息消费模式</strong>
<ul>
<li>Kafka：消息由消费者主动拉取，支持多次消费。</li>
<li>RabbitMQ：消息通过推送方式传递给消费者，消费后消息默认从队列中移除。</li>
</ul>
</li>
<li><strong>使用场景</strong>
<ul>
<li>Kafka：适用于大数据场景（日志聚合、流式处理），擅长处理高吞吐量、大规模消息传递。</li>
<li>RabbitMQ：适用于需要复杂路由和消息确认的场景（如事务性消息和实时通信）。</li>
</ul>
</li>
</ol>
<h3 id="性能与延迟">性能与延迟</h3>
<ol>
<li><strong>高吞吐量</strong>
<ul>
<li>Kafka：设计针对高吞吐量场景优化，能够支持百万级消息每秒。</li>
<li>RabbitMQ：吞吐量相对较低，但延迟更低。</li>
</ul>
</li>
<li><strong>延迟</strong>
<ul>
<li>Kafka：适合高吞吐量但对实时性要求不高的应用。</li>
<li>RabbitMQ：更适合低延迟应用，提供实时性支持。</li>
</ul>
</li>
</ol>
<h3 id="协议支持">协议支持</h3>
<ol>
<li><strong>协议类型</strong>
<ul>
<li>Kafka：自定义的二进制协议。</li>
<li>RabbitMQ：基于AMQP协议，支持丰富的消息功能（如TTL、优先级）。</li>
</ul>
</li>
<li><strong>兼容性</strong>
<ul>
<li>Kafka：需要Kafka专用客户端。</li>
<li>RabbitMQ：支持AMQP标准协议，兼容性较强。</li>
</ul>
</li>
</ol>
<h1 id="开发一个producer和一个consumer">开发一个Producer和一个Consumer</h1>
<p>本地docker环境启动一个kafka</p>
<pre><code class="language-typescript">version: '2'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.4
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - 22181:2181
  
  kafka:
    image: confluentinc/cp-kafka:7.4.4
    depends_on:
      - zookeeper
    ports:
      - 29092:29092
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
</code></pre>
<p>使用.NET CORE + Kafka开发一个消息生产者， 一个消息消费者， 客户端需要安装组件** Confluent.Kafka**</p>
<h2 id="inventoryupdateproducer">InventoryUpdateProducer</h2>
<pre><code class="language-typescript">public class ProducerService
{
    private readonly IConfiguration _configuration;
    private readonly IProducer&lt;Null, string&gt; _producer;
    private readonly ILogger&lt;ProducerService&gt; _logger;

    public ProducerService(IConfiguration configuration, ILogger&lt;ProducerService&gt; logger)
    {
        _configuration = configuration;
        _logger = logger;
        var config = new ProducerConfig
        {
            BootstrapServers = _configuration["Kafka:BootstrapServers"],

        };

        _producer = new ProducerBuilder&lt;Null, string&gt;(config).Build();
    }

    public async Task ProductAsync(string topic, string message)
    {
        var orderPlacedMessage = new Message&lt;Null, string&gt;
        {
            Value = message
        };

        await _producer.ProduceAsync(topic, orderPlacedMessage);

        _logger.LogInformation("Message sent to topic: {Topic}", topic);
    }
}
</code></pre>
<pre><code class="language-typescript">[Route("api/[controller]")]
[ApiController]
public class InventoryController : ControllerBase
{
    private readonly ProducerService _producerService;

    public InventoryController(ProducerService producerService)
    {
        _producerService = producerService;
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Post([FromBody] InventoryUpdateRequest request)
    {
        var message = System.Text.Json.JsonSerializer.Serialize(request);

        await _producerService.ProductAsync("inventory-update", message);

        return Ok("Inventory Updated Successfully...");
    }
}
</code></pre>
<p>启动项目，查看Swagger</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/359374/1735876009405-4b883e17-5f7d-46da-834d-1a8ad6e67009.png" alt="" loading="lazy"></p>
<h2 id="inventoryupdateconsumer">InventoryUpdateConsumer</h2>
<p>消息消费者程序使用.net core BackgroundService开发， 这个类需要在程序启动时注入进去，不要忘记。</p>
<pre><code class="language-typescript">public class ConsumerService : BackgroundService
{
    private readonly ILogger&lt;ConsumerService&gt; _logger;
    private readonly IConfiguration _configuration;
    private readonly IConsumer&lt;Ignore, string&gt; _consumer;

    public ConsumerService(ILogger&lt;ConsumerService&gt; logger, IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;

        var consumerConfig = new ConsumerConfig
        {
            BootstrapServers = configuration["Kafka:BootstrapServers"],
            GroupId = "InventoryConsumerGroup",
            AutoOffsetReset = AutoOffsetReset.Earliest
        };

        _consumer = new ConsumerBuilder&lt;Ignore, string&gt;(consumerConfig).Build();
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _consumer.Subscribe("inventory-update");

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                HandleMessage(stoppingToken);

                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Consumer service has been cancelled.");
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error in consuming messages: {ex.Message}");
        }
        finally
        {
            _consumer.Close();
        }
    }

    public void HandleMessage(CancellationToken cancellation)
    {
        try
        {
            var consumeResult = _consumer.Consume(cancellation);

            var message = consumeResult.Message.Value;

            _logger.LogInformation($"Received inventory update: {message}");
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error processing Kafka message: {ex.Message}");
        }
    }
}
</code></pre>
<pre><code class="language-typescript">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHostedService&lt;ConsumerService&gt;();
</code></pre>
<p>运行程序</p>
<p>Publish Message</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/359374/1735876252374-5f2e13db-2087-49ab-8f9b-d873c35d6c52.png" alt="" loading="lazy"></p>
<p>Consume Message</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/359374/1735876252325-57845904-230e-43f3-8e1c-e2ccf0967691.png" alt="" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p><font style="color: rgba(51, 51, 51, 1)">Apache Kafka不是消息中间件的一种实现。相反，它只是一种分布式流式系统。 不同于基于队列和交换器的RabbitMQ，Kafka的存储层是使用分区事务日志来实现的。Kafka也提供流式API用于实时的流处理以及连接器API用来更容易的和各种数据源集成。</font></p>

</div>
<div id="MySignature" role="contentinfo">
    <table>
<tbody><tr>
   <td id="tdSign">博客地址：</td><td><a href="http://www.cnblogs.com/sword-successful/">http://www.cnblogs.com/sword-successful/</a></td>
</tr>
<tr>
   <td>博客版权：</td><td>本文以学习、研究和分享为主，欢迎转载，但必须在文章页面明显位置给出原文连接。<br>如果文中有不妥或者错误的地方还望高手的你指出，以免误人子弟。如果觉得本文对你有所帮助不如【推荐】一下！如果你有更好的建议，不如留言一起讨论，共同进步！<br>再次感谢您耐心的读完本篇文章。</td>
</tr>
</tbody></table>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0780739137488426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-03 14:27">2025-01-03 14:27</span>&nbsp;
<a href="https://www.cnblogs.com/sword-successful">歪头儿在北京</a>&nbsp;
阅读(<span id="post_view_count">226</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18650066" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18650066);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18650066', targetLink: 'https://www.cnblogs.com/sword-successful/p/18650066', title: '.NET Core + Kafka 开发指南' })">举报</a>
</div>
        