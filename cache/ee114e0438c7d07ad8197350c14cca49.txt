
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/charlieroro/p/18632385" title="发布于 2024-12-30 09:46">
    <span role="heading" aria-level="2">vmstorage如何将原始指标转换为有组织的历史</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="vmstorage如何将原始指标转换为有组织的历史">vmstorage如何将原始指标转换为有组织的历史</h2>
<blockquote>
<p>参考自：<a href="https://victoriametrics.com/blog/vmstorage-how-it-handles-data-ingestion/" target="_blank" rel="noopener nofollow">vmstorage-how-it-handles-data-ingestion</a></p>
</blockquote>
<p>vmstorage是VictoriaMetrics中负责处理长期存储的组件。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226094924243-656184952.png" alt="image" style="zoom: 28%">
<h3 id="读取和解析数据">读取和解析数据</h3>
<p>在vmstorage接收到数据之后，并不会直接读取这些数据。首先会检查读并发限速器(限制为2倍的CPU cores)，如果读操作过多，则最终会排队等候处理。</p>
<p>vmstorage每次会读取一个block，block的结构如下，包含一个表示block大小的8字节的<code>size</code>字段以及一个body字段。一个block不能超过100MB。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226101145521-584618512.png" alt="image" style="zoom: 60%">
<p>有一个边缘场景值得注意：即当vmstorage在速磁盘空间不足时会转变为只读模式。该模式下vmstorage会对接收到的数据响应"read-only ack"，并忽略实际内容，vminsert会识别此种确认类型并重发数据(本文后面讨论)。</p>
<p>本阶段中，vmagent仅使用字节流方式读取原始block，并不会对其解析。这些原始字节最终会被拆分为rows进行处理。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226104714066-810183824.png" alt="image" style="zoom: 67%">
<p>如果block过大，vmstorage会以chunks为单位进行处理，每次处理10,000 rows数据并将其写入存储。</p>
<h3 id="查找每条metric的tsid">查找每条metric的TSID</h3>
<blockquote>
<p>TSID用于表示不同的时间序列，有如下作用：</p>
<p><strong>数据存储优化</strong>：</p>
<ul>
<li>TSID 在存储时序数据时起到索引的作用。VictoriaMetrics 使用 TSID 来将时间序列数据映射到磁盘的存储位置，从而避免直接存储复杂的指标名称和标签。</li>
<li>通过 TSID，可以快速找到时间序列对应的样本（samples，时间戳与值的组合）并高效地写入或读取数据。</li>
</ul>
<p><strong>查询加速</strong>：</p>
<ul>
<li>当查询某个指标时，VictoriaMetrics 会解析查询中指定的标签或指标名称，通过倒排索引查找与查询条件匹配的 TSID。</li>
</ul>
</blockquote>
<p>每条metric包含如下几个关键部分：</p>
<ul>
<li>一个metrics名称</li>
<li>一组metrics labels</li>
<li>一个时间戳(毫秒)</li>
<li>一个浮点数表示的metric value</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226110110941-851876106.png" alt="image" style="zoom: 40%">
<p>在计算metric的TSID之前，首先需要创建"<strong>规范的指标名称</strong>"，即将metric name和labels组合起来，然后按名字的字母顺序排列，目的是防止包含相同labels的metrics，只是因为labels顺序不同而被认为是不同的metric，如<code>metric{instance="host",job="app"}</code> 和 <code>metric{job="app",instance="host"}</code>是相同的metric，只是label顺序不同。</p>
<p>TSID是一种可以表示时间序列的唯一数字，用于快速定位数据。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226110941431-1941073829.png" alt="image" style="zoom: 50%">
<p>上一节中，vmstorage从block中获取到了原始的metrics(无排序)，然后通过查询TSID缓存来判断是否已经存在对应的TSID，如果存在，则直接插入该指标：</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226112951851-193983248.png" alt="image" style="zoom: 60%">
<p>如果不存在，则需要向IndexDB查询，由于涉及随机磁盘查询，因此这是一个比较慢的过程。在查找成功后缓存结果。</p>
<p>如果不存在，则说明这是一个全新的metric。此时，系统需要生成一个新的TSID，并将其同时注册到内存缓存和IndexDB，包括如下步骤：</p>
<ul>
<li>将"规范指标名称"映射到新的TSID</li>
<li>设置反向映射，这样TSID可以指向"规范指标名称"</li>
<li>倒排索引包含"规范指标名称"中的每个label，可以帮助系统在使用标签过滤时快速查询时序数据</li>
<li>创建以天为单位的索引，用于优化按时间范围查找数据的场景。</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226113326042-37481711.png" alt="image" style="zoom: 45%">
<p>注册新的时间序列涉及向磁盘写入与之相关的所有信息，该过程可能会拖慢整个系统，特别是当metric拥有很多labels或非常长的labels时。</p>
<p>这也是为什么要关注<a href="https://www.cnblogs.com/charlieroro/p/11821312.html#high-churn-rate" target="_blank">churn rate</a>的原因。vmstorage可以按小时 (<code>-storage.maxHourlySeries</code>)和天(<code>-storage.maxDailySeries</code>)限制新创建的时序数据总量。</p>
<h3 id="向内存缓冲插入数据">向内存缓冲插入数据</h3>
<p>一旦注册好TSID，VictoriaMetrics就可以处理实际的数据样本，包括TSID、时间戳、值等，并将其放入一个内存缓冲(称为"raw-row shards")，且一个partition(表示一个月的数据)的shards数目等于CPU cores的数目。例如，机器有4 cores，则每个月的数据有4个shards，每个shards最多可以有8 MB的数据，约149,796 rows。</p>
<p>如果shard被填满，则这些rows会被推入一个称为"pending series"的地方，等待被处理成“LSM part”，并最终写入磁盘。只有刷新到LSM part的数据才能被查询到，之后便完成了本block的数据处理，可以开始处理下一个block。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226115733007-361364945.png" alt="image" style="zoom: 30%">
<h3 id="数据如何写入磁盘">数据如何写入磁盘</h3>
<p>在如下两种情况中，Shard缓冲会刷新数据：</p>
<ol>
<li>当缓冲达到阈值(约120MB)，刷新pending series</li>
<li>如果距上一次刷新超过2s，则系统会自动刷新 pending series和raw-row shards</li>
</ol>
<p>在刷新过程中，数据会转换为一个LSM part，LSM part中的项会根据TSID和时间戳进行排序。</p>
<h4 id="lsm-parts的类型">LSM Parts的类型</h4>
<p>每个partition(涵盖一个月的数据)会将其数据组织为3种LSM parts类型：</p>
<ul>
<li>内存 part：存放raw-row shards首次刷新后的数据，此时数据可以被搜索和查询</li>
<li>Small part：比内存part稍大，存储在持久化磁盘上</li>
<li>big part：最大的parts，存储在磁盘上</li>
</ul>
<p>vmstorage同一时间最多可以持有60个内存parts，占用约10%的系统内存。例如，vmstorage内存为10GB，则内存parts占1GB，每个part约1MB～17MB。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226150845602-2088174196.png" alt="image" style="zoom: 27%">
<p>随着数据的写入，会创建越来越多的parts，当LSM parts过多(无论是内存还是磁盘)时，每个查询(如来自grafana的查询)都需要扫描并合并这些parts，可能会拖慢系统。</p>
<p>为了防止上述问题，vmstorage依赖两个关键处理：刷新和合并。</p>
<ul>
<li>刷新：将<strong>所有</strong>内存parts刷新到磁盘的small parts。每5s，vmstorage(<code>-inmemoryDataFlushInterval</code>)会将内存parts刷新到基于磁盘或文件的parts上。</li>
<li>合并：将多个parts合并为更高效的存储。这并不意味着将所有small parts合并为big parts，而是将一部分small parts合并为稍大一些的small parts</li>
</ul>
<h4 id="合并过程">合并过程</h4>
<p>合并并不是固定调度的。只要有parts累积，系统就会尝试合并这些parts，将内存parts合并为较大的内存part，将small parts合并为较大的small part，将big parts合并为较大的big part。</p>
<p>small parts不能超过10MB，big parts最大可以占用大约剩余磁盘空间/4，但不能超过1TB。注意small parts和big parts只是系统在合并过程中评估出来的需要创建的part类型，并不是说small parts一定小于big parts。</p>
<p>small parts合并的结果最终会被写入磁盘，该过程中会执行去重操作。</p>
<p>去重是确认并移除那些几乎相等，但记录时间略微不同的时间点。通常发生在出于冗余或可靠性目的，而使用两个或多个监控系统将相同指标并发往同一个存储的场景。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226161318383-1669966815.png" alt="image" style="zoom: 35%">
<p>默认关闭去重，可以通过<code>-dedup.minScrapeInterval</code>启用去重功能。</p>
<h3 id="retention-free-disk-space-guard和-downsampling">Retention, Free Disk Space Guard和 Downsampling</h3>
<p>vmstorage的默认回收周期是1个月。需要注意的是，每个part包含很多样本，只要有一个样本在回收周期内，则必须保留整个part。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226161747598-1749125825.png" alt="image" style="zoom: 45%">
<h4 id="free-disk-space-watcher-read-only-mode">Free Disk Space Watcher: Read Only Mode</h4>
<p>一开始提到，在磁盘空间不足的情况下，vmstorage会进入read-only模式，该模式下，vminset会接收到数据发送的确认信息，但vmstorage会忽略掉这些数据。此时vmstorage仍然能够提供查询请求，但停止接收任何写数据。一旦释放了磁盘空间<code>(-storage.minFreeDiskSpaceBytes</code>，默认10MB)，vmstorage会退出read-only模式。</p>
<h3 id="partition的结构">Partition的结构</h3>
<p>无论是内存parts，small parts还是big parts，其数据都是列模式，即TSID、时间戳和值都不会组合在一个记录中，而是被分散到不同的列，每一列都保存在各自的文件中。</p>
<ul>
<li>所有 TSIDs 都保存在 <code>index.bin</code>.</li>
<li>所有时间戳都保存在 <code>timestamps.bin</code>.</li>
<li>所有值都保存在 <code>values.bin</code>.</li>
</ul>
<p>对于内存parts，这些列结构已经就绪，可以直接刷新到基于文件的parts中。</p>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226162623285-219316036.png" alt="image" style="zoom: 50%">
<p>列模式便于压缩和快速查找。 <code>timestamps.bin</code> 和 <code>values.bin</code>中的每个block表示单个TSID行，一个block最多可以有8192 行。</p>
<p><code>index.bin</code>的每一行包括多个block首部，一个block首部包含：</p>
<ul>
<li>block的TSID</li>
<li>block的行数</li>
<li>block在<code>timestamps.bin</code> 和 <code>values.bin</code>中的位置</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/1334952/202412/1334952-20241226163538001-416403816.png" alt="image" style="zoom: 70%">
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/charlieroro/" target="_blank">charlieroro</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/charlieroro/p/18632385" target="_blank">https://www.cnblogs.com/charlieroro/p/18632385</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.044218795877314816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 09:46">2024-12-30 09:46</span>&nbsp;
<a href="https://www.cnblogs.com/charlieroro">charlieroro</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18632385" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18632385);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18632385', targetLink: 'https://www.cnblogs.com/charlieroro/p/18632385', title: 'vmstorage如何将原始指标转换为有组织的历史' })">举报</a>
</div>
	