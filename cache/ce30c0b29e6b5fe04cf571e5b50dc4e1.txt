
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18932272" title="发布于 2025-06-17 09:08">
    <span role="heading" aria-level="2">Just：告别 Makefile 的现代命令行任务运行器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本文推荐的一个轻量级命令行工具--<code>Just</code>，它提供了一种简单高效的方式来管理项目任务，类似于传统的 <code>Make</code> 工具，但具有更简洁的语法和更现代化的功能。</p>
<p>我目前在一些小项目中开始使用它来管理一些日常的任务，非常方便，它是基于<code>Rust</code>开发的工具，</p>
<p>所以它在<code>Windows</code>系统中使用也非常方便。</p>
<h1 id="just简介">Just简介</h1>
<p><code>Just</code>是一个简单而强大的命令运行器，它允许你将项目中常用的命令保存在一个名为<code>justfile</code>的文件中。</p>
<p>与传统的<code>Make</code>工具类似， 但是<code>Just</code>提供了更简洁的语法和更灵活的功能。</p>
<p>主要包括：</p>
<ul>
<li>跨平台支持（<code>Linux</code>、<code>macOS</code>、<code>Windows</code>）</li>
<li>错误信息清晰具体</li>
<li>支持命令行参数和环境变量</li>
<li>自动补全功能</li>
<li>无需声明<code>.PHONY</code>目标</li>
<li>可从项目任意子目录调用</li>
</ul>
<p>如果你平时也用Makefile来管理项目，那么上手<code>Just</code>会非常快。</p>
<p><code>Just</code>支持多种操作系统，包括 <code>Linux</code>、<code>MacOS</code> 和 <code>Windows</code>，并且无需额外依赖，它的目标是让命令管理变得简单、直观且易于维护。</p>
<p>它常用命令组织在名为<code>justfile</code>的文件中，通过简洁的语法定义任务（称为"配方"），然后通过 just 命令运行这些任务。</p>
<h1 id="主要组成部分">主要组成部分</h1>
<p><code>justfile</code>是<code>Just</code>的核心，它包含了所有可运行的命令（也称为配方）。</p>
<p>一个典型的<code>justfile</code>包括以下几个部分：</p>
<ul>
<li><strong>配方定义</strong>：每个配方定义了一个可执行的命令序列。</li>
<li><strong>变量定义</strong>：用于存储和复用的值。</li>
<li><strong>设置</strong>：用于控制<code>Just</code>行为的配置选项。</li>
<li><strong>注释</strong>：用于解释配方或变量的作用。</li>
</ul>
<p>以下是一个简单的<code>justfile</code>示例：</p>
<pre><code class="language-makefile"># 这是一个注释
build:
  echo "Building project..."
  cargo build

test:
  echo "Running tests..."
  cargo test
</code></pre>
<p>在这个例子中，<code>build</code>和<code>test</code>是两个配方，分别用于构建和测试项目。</p>
<h1 id="基本语法">基本语法</h1>
<p><code>justfile</code>的语法非常直观，而且和<code>Makefile</code>非常类似。</p>
<p>最简单的例子如下：</p>
<pre><code class="language-makefile"># 这是一个注释
hello:
    @echo "Hello, Just!"
</code></pre>
<p>命令行中运行结果：</p>
<pre><code class="language-powershell">$  just
Hello, Just!
</code></pre>
<h2 id="变量的使用">变量的使用</h2>
<p><strong>变量</strong>是我们编写<strong>配方</strong>时最常用的功能，<code>Just</code>支持多种变量的类型。</p>
<p><strong>变量</strong>可以通过<code>:=</code> 进行赋值，并在配方中通过<code>{{变量名}}</code>的方式进行引用。</p>
<ol>
<li><strong>普通变量</strong></li>
</ol>
<pre><code class="language-makefile">version := "1.0.0"

test:
    @echo {{version}}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-powershell">$  just test
1.0.0
</code></pre>
<ol start="2">
<li><strong>路径拼接</strong></li>
</ol>
<pre><code class="language-makefile">config_dir := "config"
config_file := config_dir / "settings.toml"

test:
    @echo {{config_dir}}
    @echo {{config_file}}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-powershell">$  just test
config
config/settings.toml
</code></pre>
<ol start="3">
<li><strong>变量插值</strong></li>
</ol>
<pre><code class="language-powershell">version := "1.0.0"

deploy:
  scp build/app-{{version}}.tar.gz server:/apps
</code></pre>
<p>执行时，<code>scp</code>命令中的<code>{{version}}</code>会替换成<code>version</code>变量的实际值。</p>
<ol start="4">
<li><strong>命令行覆盖变量</strong></li>
</ol>
<p>写在<code>justfile</code>中的变量并不是固定的，可以通过命令行来传入不同的值，比如第一个示例中：</p>
<pre><code class="language-makefile">version := "1.0.0"

test:
    @echo {{version}}
</code></pre>
<pre><code class="language-powershell">$  just test
1.0.0

$  just version=2.0.0 test
2.0.0
</code></pre>
<ol start="5">
<li><strong>环境变量</strong></li>
</ol>
<pre><code class="language-makefile">path := env_var('PATH')

# 访问环境变量
show_path:
    echo "PATH Var: {{path}}"
</code></pre>
<p>通过内置的<code>env_var</code>函数可以访问环境变量。</p>
<h2 id="条件判断">条件判断</h2>
<p>条件判断可以让我们编写配方时更加灵活，比如针对不同的平台编译不同的二进制。</p>
<pre><code class="language-makefile">build_type := if os() == "windows" { "exe" } else { "bin" }

build:
    @echo "可执行文件的后缀: {{build_type}}"
</code></pre>
<p>我是<code>windows</code>系统，执行结果如下：</p>
<pre><code class="language-powershell">$  just build
可执行文件的后缀: exe
</code></pre>
<p>如果条件分支比较多，可以使用<code>else if</code>，比如：</p>
<pre><code class="language-makefile">arch := if arch() == "x86_64" {
    "amd64"
} else if arch() == "aarch64" {
    "arm64"
} else {
    error("Unsupported architecture")
}
</code></pre>
<h1 id="内置函数">内置函数</h1>
<p><code>Just</code>中内置了很多函数，方便我们在编写任务时，获取一些必要的信息。</p>
<p>比如上面示例中使用的<code>os()</code>和<code>arch()</code>，都是内置函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>arch()</td>
<td>指令集结构</td>
<td>"aarch64", "arm", "asmjs", "hexagon", "mips", "msp430", "powerpc", "powerpc64", "s390x", "sparc", "wasm32", "x86", "x86_64", 和 "xcore"</td>
</tr>
<tr>
<td>os()</td>
<td>操作系统</td>
<td>"android", "bitrig", "dragonfly", "emscripten", "freebsd", "haiku", "ios", "linux", "macos", "netbsd", "openbsd", "solaris", 和 "windows"</td>
</tr>
<tr>
<td>os_family()</td>
<td>操作系统系列</td>
<td>"unix" 和 "windows"</td>
</tr>
<tr>
<td>env_var(key)</td>
<td>获取名称为 key 的环境变量</td>
<td>如果不存在则终止</td>
</tr>
<tr>
<td>env_var_or_default(key, default)</td>
<td>获取名称为 key 的环境变量</td>
<td>如果不存在则返回 default</td>
</tr>
<tr>
<td>invocation_directory()</td>
<td>获取 just 被调用时当前目录所对应的绝对路径</td>
<td>-</td>
</tr>
<tr>
<td>justfile()</td>
<td>取得当前 justfile 的路径</td>
<td>-</td>
</tr>
<tr>
<td>justfile_directory()</td>
<td>取得当前 justfile 文件父目录的路径</td>
<td>-</td>
</tr>
<tr>
<td>just_executable()</td>
<td>just 可执行文件的绝对路径</td>
<td>-</td>
</tr>
<tr>
<td>quote(s)</td>
<td>用单引号包裹字符串并转义内部单引号</td>
<td></td>
</tr>
<tr>
<td>replace(s, from, to)</td>
<td>替换字符串中的所有匹配项</td>
<td></td>
</tr>
<tr>
<td>replace_regex(s, regex, repl)</td>
<td>使用正则表达式替换字符串</td>
<td></td>
</tr>
<tr>
<td>trim(s)</td>
<td>移除首尾空白字符</td>
<td></td>
</tr>
<tr>
<td>trim_end(s)</td>
<td>移除尾部空白字符</td>
<td></td>
</tr>
<tr>
<td>trim_end_match(s, substr)</td>
<td>移除匹配的后缀</td>
<td></td>
</tr>
<tr>
<td>trim_end_matches(s, substr)</td>
<td>重复移除匹配的后缀</td>
<td></td>
</tr>
<tr>
<td>trim_start(s)</td>
<td>移除首部空白字符</td>
<td></td>
</tr>
<tr>
<td>trim_start_match(s, substr)</td>
<td>移除匹配的前缀</td>
<td></td>
</tr>
<tr>
<td>trim_start_matches(s, substr)</td>
<td>重复移除匹配的前缀</td>
<td></td>
</tr>
<tr>
<td>capitalize(s)</td>
<td>首字母大写其余小写</td>
<td><code>"hello"</code>-&gt;<code>"Hello"</code></td>
</tr>
<tr>
<td>kebabcase(s)</td>
<td>转换为 kebab-case</td>
<td><code>"fooBar"</code>-&gt;<code>"foo-bar"</code></td>
</tr>
<tr>
<td>lowercamelcase(s)</td>
<td>转换为 lowerCamelCase</td>
<td><code>"Foo_bar"</code>-&gt;<code>"fooBar"</code></td>
</tr>
<tr>
<td>lowercase(s)</td>
<td>转换为全小写</td>
<td><code>"HeLLo"</code>-&gt;<code>"hello"</code></td>
</tr>
<tr>
<td>shoutykebabcase(s)</td>
<td>转换为 SHOUTY-KEBAB-CASE</td>
<td><code>"fooBar"</code>-&gt;"FOO-BAR"</td>
</tr>
<tr>
<td>shoutysnakecase(s)</td>
<td>转换为 SHOUTY_SNAKE_CASE</td>
<td><code>"fooBar"</code>-&gt;"FOO_BAR"</td>
</tr>
<tr>
<td>snakecase(s)</td>
<td>转换为 snake_case</td>
<td><code>"fooBar"</code>-&gt;<code>"foo_bar"</code></td>
</tr>
<tr>
<td>titlecase(s)</td>
<td>转换为 Title Case</td>
<td><code>"hello world"</code>-&gt;<code>"Hello World"</code></td>
</tr>
<tr>
<td>uppercamelcase(s)</td>
<td>转换为 UpperCamelCase</td>
<td><code>"foo_bar"</code>-&gt;<code>"FooBar"</code></td>
</tr>
<tr>
<td>uppercase(s)</td>
<td>转换为全大写</td>
<td><code>"hello"</code>-&gt;<code>"HELLO"</code></td>
</tr>
<tr>
<td>absolute_path(path)</td>
<td>将相对路径转为绝对路径</td>
<td></td>
</tr>
<tr>
<td>extension(path)</td>
<td>获取文件扩展名</td>
<td></td>
</tr>
<tr>
<td>file_name(path)</td>
<td>获取文件名（含扩展名）</td>
<td></td>
</tr>
<tr>
<td>file_stem(path)</td>
<td>获取文件名（不含扩展名）</td>
<td></td>
</tr>
<tr>
<td>parent_directory(path)</td>
<td>获取父目录路径</td>
<td></td>
</tr>
<tr>
<td>without_extension(path)</td>
<td>获取不含扩展名的路径</td>
<td></td>
</tr>
<tr>
<td>clean(path)</td>
<td>简化路径（移除冗余部分）</td>
<td></td>
</tr>
<tr>
<td>join(a, b…)</td>
<td>拼接路径（自动处理分隔符）</td>
<td></td>
</tr>
<tr>
<td>path_exists(path)</td>
<td>检查路径是否存在</td>
<td></td>
</tr>
<tr>
<td>error(message)</td>
<td>终止执行并显示错误消息</td>
<td></td>
</tr>
<tr>
<td>sha256(string)</td>
<td>计算字符串的SHA-256哈希值（十六进制）</td>
<td></td>
</tr>
<tr>
<td>sha256_file(path)</td>
<td>计算文件的SHA-256哈希值（十六进制）</td>
<td></td>
</tr>
<tr>
<td>uuid()</td>
<td>生成随机UUID</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="执行系统命令">执行系统命令</h1>
<p><code>justfile</code>中，可以通过反引号来执行系统命令，比如：</p>
<pre><code class="language-makefile">current_branch := `git branch --show-current`

deploy:
  echo "Deploying branch {{current_branch}}"
</code></pre>
<h1 id="与makefile的比较">与Makefile的比较</h1>
<p>最后，整理了<code>justfile</code>与传统的<code>Makefile</code>相比，在特性方面的不同和改进，供参考：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Just</th>
<th>Make</th>
</tr>
</thead>
<tbody>
<tr>
<td>语法</td>
<td>简洁直观</td>
<td>较为复杂</td>
</tr>
<tr>
<td>跨平台</td>
<td>原生支持</td>
<td>需要兼容层</td>
</tr>
<tr>
<td>错误处理</td>
<td>清晰详细</td>
<td>有时晦涩</td>
</tr>
<tr>
<td>变量作用域</td>
<td>统一简单</td>
<td>多种类型</td>
</tr>
<tr>
<td>自动补全</td>
<td>完善支持</td>
<td>有限</td>
</tr>
<tr>
<td>.PHONY 声明</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>环境变量</td>
<td>内置支持</td>
<td>需要额外处理</td>
</tr>
<tr>
<td>现代功能</td>
<td>条件、函数等</td>
<td>有限</td>
</tr>
</tbody>
</table>
<p><code>Just</code>的优势主要体现在：</p>
<ul>
<li>避免 Make 的"up to date"问题</li>
<li>更友好的错误信息</li>
<li>内置函数和环境变量支持</li>
<li>更简洁的变量系统</li>
<li>无需声明伪目标</li>
</ul>
<p>如果你的项目也有<code>Makefile</code>的需求，不妨试试用<code>justfile</code>来试试！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-17 09:09">2025-06-17 09:08</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">94</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18932272);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18932272', targetLink: 'https://www.cnblogs.com/wang_yb/p/18932272', title: 'Just：告别 Makefile 的现代命令行任务运行器' })">举报</a>
</div>
        