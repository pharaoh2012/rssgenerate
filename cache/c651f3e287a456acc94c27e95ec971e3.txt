
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TheMagicalRainbowSea/p/18743151" title="发布于 2025-02-28 14:18">
    <span role="heading" aria-level="2">3. Nginx 命令行参数 &amp; nginx.conf 配置文件的详细说明(附有截图说明)</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="3-nginx-命令行参数--nginxconf-配置文件的详细说明附有截图说明">3. Nginx 命令行参数 &amp; nginx.conf 配置文件的详细说明(附有截图说明)</h1>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#3-nginx-命令行参数--nginxconf-配置文件的详细说明附有截图说明" rel="noopener nofollow">3. Nginx 命令行参数 &amp; nginx.conf 配置文件的详细说明(附有截图说明)</a></li><li><a href="#1-nginx-命令行参数" rel="noopener nofollow">1. Nginx 命令行参数</a></li><li><a href="#2-nginxconf-配置文件" rel="noopener nofollow">2. nginx.conf 配置文件</a></li><li><a href="#3-nginxconf-讲解" rel="noopener nofollow">3. nginx.conf 讲解</a></li><li><a href="#4-最后" rel="noopener nofollow">4. 最后：</a></li></ul></div><p></p>
<hr>
<h1 id="1-nginx-命令行参数">1. Nginx 命令行参数</h1>
<p>Nginx 指令说明：<a href="https://nginx.org/en/docs/switches.html" target="_blank" rel="noopener nofollow">https://nginx.org/en/docs/switches.html</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642002-1206391155.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>停止 Nginx 命令：</li>
</ul>
<pre><code class="language-sh">  /usr/local/nginx/sbin/nginx -s stop # 
</code></pre>
<pre><code class="language-sh">[root@localhost nginx]# /usr/local/nginx/sbin/nginx -s stop
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141641990-456274025.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>启动 Nginx 命令</li>
</ul>
<pre><code class="language-sh">[root@localhost nginx]# /usr/local/nginx/sbin/nginx
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642024-143901456.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>重新加载(不需要重启) /usr/local/nginx/sbin/nginx -s reload</li>
</ul>
<pre><code class="language-sh"> /usr/local/nginx/sbin/nginx -s reload
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642000-1053930329.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>查看版本</li>
</ul>
<pre><code class="language-sh">[root@localhost nginx]# /usr/local/nginx/sbin/nginx -v
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642000-144549848.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>查看版本、配置参数  /usr/local/nginx/sbin/nginx -V</li>
</ul>
<pre><code class="language-sh">[root@localhost nginx]# /usr/local/nginx/sbin/nginx -V
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141641986-1002740693.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-nginxconf-配置文件">2. nginx.conf 配置文件</h1>
<p>Nginx 的配置文件( nginx.conf )位置：</p>
<p>文件位置：</p>
<ul>
<li>安装目录  \conf \nginx.conf</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141641998-1979415472.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>安装目录 \nginx.conf （特别说明：这个路径下的文件，有的时候是没有的，而在 第一个路径的 conf\nginx.conf 当中就是有的）</li>
</ul>
<p><strong>两个文件是一样的</strong></p>
<p>使用  /usr/local/nginx/sbin/nginx  启动 Nginx  ，默认用的是  安装目录 \nginx.conf 配置文件</p>
<p><strong><code>nginx.conf</code> 配置文件的作用是：完成对 Nginx 的各种配置，包括端口，并发数，重写规则等。</strong></p>
<p><strong>nginx.conf 组成：</strong></p>
<ul>
<li>全局块</li>
<li>events 块</li>
<li>http 块</li>
</ul>
<p><code>nginx.conf</code> 详细文档：<a href="https://blog.csdn.net/liuchang19950703/article/details/110792007" target="_blank" rel="noopener nofollow">https://blog.csdn.net/liuchang19950703/article/details/110792007</a></p>
<pre><code class="language-properties"> 
#Nginx用户及组：用户 组。window下不指定
#user  nobody;
 
#工作进程：数目。根据硬件调整，通常等于CPU数量或者2倍于CPU。
worker_processes  1;
 
#错误日志：存放路径。
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
 
#pid(进程标识符)：存放路径
pid       /usr/local/nginx/logs/nginx.pid;
 
#一个进程能打开的文件描述符最大值，理论上该值因该是最多能打开的文件数除以进程数。
#但是由于nginx负载并不是完全均衡的，所以这个值最好等于最多能打开的文件数。
#LINUX系统可以执行 sysctl -a | grep fs.file 可以看到linux文件描述符。
worker_rlimit_nofile 65535;
 
 
events {
	#使用epoll的I/O 模型。linux建议epoll，FreeBSD建议采用kqueue，window下不指定。
	use epoll;
	
	#单个进程最大连接数（最大连接数=连接数*进程数）
    worker_connections  1024;
	
	#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，
	#一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。
	#client_header_buffer_size 4k;
}
 
 
http {
	#设定mime类型,类型由mime.type文件定义
    include       mime.types;
	
    default_type  application/octet-stream;
	
	#日志格式设置
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
	
		
	#用了log_format指令设置了日志格式之后，需要用access_log指令指定日志文件的存放路径
	#记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息
	#access_log  logs/host.access.log  main;
	#access_log  logs/host.access.404.log  log404;
	
	#服务器名字的hash表大小
    server_names_hash_bucket_size 128;
	
	#客户端请求头缓冲大小。
    #nginx默认会用client_header_buffer_size这个buffer来读取header值，
    #如果header过大，它会使用large_client_header_buffers来读取。
    #如果设置过小HTTP头/Cookie过大 会报400 错误 nginx 400 bad request
    #如果超过buffer，就会报HTTP 414错误(URI Too Long)
    #nginx接受最长的HTTP头部大小必须比其中一个buffer大
    #否则就会报400的HTTP错误(Bad Request)
    #client_header_buffer_size 32k;
    #large_client_header_buffers 4 32k;
	
	
	#隐藏ngnix版本号
    #server_tokens off;
	
	#忽略不合法的请求头
    #ignore_invalid_headers   on;
	
	#让 nginx 在处理自己内部重定向时不默认使用  server_name设置中的第一个域名
    #server_name_in_redirect off;
	
	
	#客户端请求体的大小
    #client_body_buffer_size    8m;
   
  
    #开启文件传输，一般应用都应设置为on；若是有下载的应用，则可以设置成off来平衡网络I/O和磁盘的I/O来降低系统负载
    sendfile        on;
	
	
	#告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。
    #tcp_nopush     on;
	
	#tcp_nodelay off 会增加通信的延时，但是会提高带宽利用率。在高延时、数据量大的通信场景中应该会有不错的效果
    #tcp_nodelay on，会增加小包的数量，但是可以提高响应速度。在及时性高的通信场景中应该会有不错的效果
	tcp_nodelay on;
	
 
    #长连接超时时间，单位是秒
    keepalive_timeout  65;
 
    #gzip模块设置，使用 gzip 压缩可以降低网站带宽消耗，同时提升访问速度。
    #gzip  on;                     #开启gzip
    #gzip_min_length  1k;          #最小压缩大小
    #gzip_buffers     4 16k;       #压缩缓冲区
    #gzip_http_version 1.0;        #压缩版本
    #gzip_comp_level 2;            #压缩等级
    #gzip_types   text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss;#压缩类型
    
	
	
	
    #负载均衡
	#max_fails为允许请求失败的次数，默认为1
	#weight为轮询权重，根据不同的权重分配可以用来平衡服务器的访问率。
    # upstream myServer{
    #   server  192.168.247.129:8080 max_fails=3 weight=2;
    #   server  192.168.247.129:8081 max_fails=3 weight=4;	
    # }
	
	
	
    #server {
    #    listen       80;
	#	
	#	#IP/域名可以有多个，用空格隔开
	#	server_name  192.168.247.129;
	#	#server_name  www.test.com;
	#
    #    #charset koi8-r;
	#
    #    #access_log  logs/host.access.log  main;
	#	
	#   #反向代理配置，
    #   #将所有请求为www.test.com的请求全部转发到upstream中定义的目标服务器中。
    #   location / {
	#   			
	#	    #此处配置的域名必须与upstream的域名一致，才能转发。
	#	    proxy_pass http://myServer;
	#	    #proxy_pass http://192.168.247.129:8080;
	#		
	#		 proxy_connect_timeout 20;          #nginx跟后端服务器连接超时时间(代理连接超时)
	#		
    #        #client_max_body_size       10m;   #允许客户端请求的最大单文件字节数
    #        #client_body_buffer_size    128k;  #缓冲区代理缓冲用户端请求的最大字节数
	#		 #proxy_send_timeout         300;   #后端服务器数据回传时间(代理发送超时)
    #        #proxy_read_timeout         300;   #连接成功后，后端服务器响应时间(代理接收超时)
    #        #proxy_buffer_size          4k;    #设置代理服务器（nginx）保存用户头信息的缓冲区大小
    #        #proxy_buffers              4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
    #        #proxy_busy_buffers_size    64k;   #高负荷下缓冲大小（proxy_buffers*2）
    #        #proxy_temp_file_write_size 64k;   #设定缓存文件夹大小，大于这个值，将从upstream服务器传    		
	#		
	#		root   html;
	#		
	#		#定义首页索引文件的名称
	#		index  index.html index.htm;
    #    }
	#
    #   #动静分离 静态资源走linux 动态资源走tomcat
    #   # 注意 /source/image/下面寻找资源
    #   location /image/ {
    #       root /source/;
	#       autoindex on;
    #   } 		
	#
	#
	#    # 出现50x错误时，使用/50x.html页返回给客户端
    #    error_page   500 502 503 504  /50x.html;
    #    location = /50x.html {
    #        root   html;
    #    }
    #}
		
		
		
	#下面是配置生产环境中既支持HTTP又支持HTTPS,保证用户在浏览器中输入HTTP也能正常访问
	
	# SSL证书 配置                                 
	ssl_certificate     	cert/yphtoy.com.pem;   #加密证书路径
	ssl_certificate_key	cert/yphtoy.com.key;       #加密私钥路径
	ssl_protocols		TLSv1 TLSv1.1 TLSv1.2;     #加密协议
	ssl_session_cache	shared:SSL:1m;             #加密访问缓存设置,可以大大提高访问速度
	ssl_session_timeout	10m;                       #加密访问缓存过期时间
	ssl_ciphers		HIGH:!aNULL:!MD5;              #加密算法
	ssl_prefer_server_ciphers on;	               #是否由服务器决定采用哪种加密算法
	
	# 负载均衡
	upstream api_upstream
	{
	    server 127.0.0.1:8080 max_fails=3 weight=1;
		server 127.0.0.1:8081 max_fails=3 weight=1;
	}
	
	#api 接口(兼容HTTP)
	server{
	    listen 80;
		server_name api.test.com;
		# 301重定向跳转到HTTPS接口
		return 301 https://$server_name$request_uri;
		error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
	}
	
	#api 接口(兼容HTTPS)
	server{
	    listen 443 ssl;
		server_name api.test.com;
		location / {
		   root html;
		   index  index.html index.htm;
		   proxy_pass http://api_upstream;
		   
		   #语法： proxy_cookie_path oldpath replacepath;
		   #oldpath就是你要替换的路径 replacepath 就是要替换的值
		   #作用：同一个web服务器下面多个应用之间能获取到cookie
		   proxy_cookie_path /api/ /;
		   
		   #服务端接收的请求头Cooke值不变
		   proxy_set_header Cookie $http_cookie;
		}
	}
	
	#管理后台端(兼容HTTP)
	server{
	    listen 80;
		server_name manage.test.com;
		# 301重定向跳转到HTTPS接口
		return 301 https://$server_name/$request_uri;
		error_page 500 502 503 504 /50x.html;
		location = /50x.html{
			 root html	
		}
	}
	
	#管理后台端(兼容HTTPS)
	server{
	    listen 443 ssl;
		server_name manage.test.com;
		location / {
		    root /home/test/web/dist
			
			index /index.html;
			
			
			#语法：try_files 【$uri】 【 $uri/】 【参数】
			#当用户请求https://manage.test.com/login时，
			#一.如果配置了上面的默认index,会依次请求
			#1./home/test/web/dist/login       查找有没有login这个文件，没有的话
			#2./home/test/web/dist/index.html  有就直接返回
			
			#二.如果没有配置了上面的默认index或者配置了没有找到对应的资源,会依次请求
			#1./home/test/web/dist/login        查找有没有login这个文件，没有的话
			#2./home/test/web/dist/login/       查找有没有login这个目录，没有的话
		    #3.请求https://manage.test.com/index.html  nginx内部做了一个子请求
			
			#三.总的来说,index的优先级比try_files高,请求会先去找index配置,这里最后一个参数必须存在
			try_files $uri $uri/ /index.html;	
			
			
			
			#解决跨域问题
            #允许跨域请求地址(*表示全部,但是无法满足带cookie请求,因为cookie只能在当前域请求)
            add_header Access-Control-Allow-Origin $http_origin;
            #允许接收cookie和发送cookie
            add_header Access-Control-Allow-Credentials 'true';
            #允许请求的方法
            add_header Access-Control-Allow-Methods 'GET,POST,DELETE,PUT,OPTIONS';
            #允许请求头（Content-Type:请求数据/媒体类型 x-requested-with:判断请求是异步还是同步 自定义header 比如 token）
            add_header Access-Control-Allow-Headers $http_access_control_request_headers;
            #浏览器缓存请求头信息,1800秒内,只会有1次请求，不会出现"OPTIONS"预请求,节约资源
            #add_header Access-Control-Max-Age '1800';
		    if ($request_method = 'OPTIONS') {
                    return 204;
            }
			
			
			#服务端HttpServletRequest可以获得用户的真实ip
		    proxy_set_header X-Real-IP $remote_addr;
			
			#服务端HttpServletRequest可以获得用户的真实ip和经过的每一层代理服务器的ip
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			
			#服务端接收的请求头Host值不变
            proxy_set_header Host  $http_host;
			
            proxy_set_header X-Nginx-Proxy true;
		}
	}
	
	
	
 
}
</code></pre>
<h1 id="3-nginxconf-讲解">3. nginx.conf 讲解</h1>
<p>一张图说明 nginx.conf 结构<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642079-686940558.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>我们可以打开 <code>nginx.conf</code> 文件查看其中的内容：</p>
<pre><code class="language-sh">[root@localhost conf]# vim /usr/local/nginx/conf/nginx.conf
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642039-105183386.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>全局块：</strong></p>
<blockquote>
<ol>
<li>从配置文件开始到  events  块之间的内容</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642021-1645250842.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<ol start="2">
<li>主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx服务器的用户[组]，允许生成的 worker process 数，进程 PID 存放路径，日志存放路径和类型以及配置文件的引入等。</li>
<li><code>worker_processes  1;</code> 这是  Nginx  服务器并发处理服务的关键配置，worker_processes  值越大，可以支持 的并发处理量也越多，但是会受到硬件、软件等设备的制约。</li>
</ol>
</blockquote>
<p><strong>events  块：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642022-1700921910.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<ol>
<li>events  块涉及的指令主要影响  Nginx 服务器与用户的网络连接</li>
<li>常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时 接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 work process 可以同 时支持的最大连接数等。</li>
<li><code>worker_connections  1024;</code> 述例子就表示每个  work process  支持的最大连接数为  1024,  这部分的配置对 Nginx 的性能影响较大，在实际中应根据实际情况配置。</li>
</ol>
</blockquote>
<p><strong>http 块</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642082-523157287.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<ol>
<li>这是  Nginx 服务器配置中最复杂的部分，代理、缓存和日志定义等绝大多数功能和第 三方模块的配置都在这里</li>
<li>http 块也可以包括  http  全局块、server  块</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141641957-1912164982.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<ol start="3">
<li>http  全局块配置的指令包括文件引入、MIME-TYPE  定义、日志自定义、连接超时时 间、单连接请求数上限等。</li>
</ol>
</blockquote>
<p><strong>server 块：</strong><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642042-1201261619.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<ol>
<li>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</li>
<li>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</li>
<li>每个 server 块也分为全局 server 块，以及可以同时包含多个 location 块。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642019-258287880.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<ul>
<li>全局  server  块：最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或  IP  配置。</li>
</ul>
</blockquote>
<p><strong>location  块：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642025-478337064.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<ol>
<li>一个  server  块可以配置多个  location  块</li>
</ol>
</blockquote>
<p><strong>小结：</strong></p>
<p>这块的主要作用是基于 Nginx 服务器接收到的请求字符串(例如：<code>server_name/uri-string</code>) ，对虚拟主机名称(也可以是 IP 别名) 之外的字符串(例如：前面的 <code>/uri-string</code> ) 进行匹配，对特定的请求进行处理。比如：地址定向，数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
<h1 id="4-最后">4. 最后：</h1>
<blockquote>
<p>“在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250228141642184-1628162105.gif" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.014233033364583333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 14:18">2025-02-28 14:18</span>&nbsp;
<a href="https://www.cnblogs.com/TheMagicalRainbowSea">Rainbow-Sea</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18743151" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18743151);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18743151', targetLink: 'https://www.cnblogs.com/TheMagicalRainbowSea/p/18743151', title: '3. Nginx 命令行参数 &amp;amp; nginx.conf 配置文件的详细说明(附有截图说明)' })">举报</a>
</div>
	