
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seazhan/p/18681536" title="发布于 2025-01-20 15:33">
    <span role="heading" aria-level="2">【RocketMQ 消息中间件】RocketMQ篇之-消息存储 为什么性能高 CommitLog ConsumeQueue IndexFile 刷盘机制 同步 异步</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153154653-468987132.png" alt="【RocketMQ 消息中间件】RocketMQ篇之-消息存储 为什么性能高 CommitLog ConsumeQueue IndexFile 刷盘机制 同步 异步" class="desc_img">
        RocketMQ是一款高可靠性的分布式消息中间件，其消息存储是核心组件之一。通过文件存储，消息持久化得到保障。主要存储组件包括CommitLog、ConsumeQueue和IndexFile，分别负责消息存储、消费队列和索引。RocketMQ利用顺序写入和零拷贝技术提升磁盘读写和网络传输性能。消息存储和发送过程中，消息首先写入CommitLog，随后ConsumeQueue和IndexFile进行索引，确保高效消费和快速检索。用户可选择同步刷盘（保障数据安全）或异步刷盘（提升性能）以满足不同需求。理解这些机制对掌握RocketMQ的消息存储非常重要。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="rocketmq篇之-消息存储">RocketMQ篇之-消息存储</h1>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#rocketmq篇之-消息存储" rel="noopener nofollow">RocketMQ篇之-消息存储</a><ul><li><a href="#前置消息存储交互流程" rel="noopener nofollow">（前置）消息存储交互流程</a></li><li><a href="#一存储系统" rel="noopener nofollow">（一）存储系统</a><ul><li><a href="#1-内存存储" rel="noopener nofollow">1. 内存存储</a></li><li><a href="#2-关系型数据库存储" rel="noopener nofollow">2. 关系型数据库存储</a></li><li><a href="#3-文件存储" rel="noopener nofollow">3. 文件存储</a></li></ul></li><li><a href="#二消息的存储和发送" rel="noopener nofollow">（二）消息的存储和发送</a><ul><li><a href="#1-消息存储顺序写入" rel="noopener nofollow">1. 消息存储（顺序写入）</a></li><li><a href="#2-消息发送零拷贝" rel="noopener nofollow">2. 消息发送（零拷贝）</a></li></ul></li><li><a href="#三存储文件结构" rel="noopener nofollow">（三）存储文件结构</a><ul><li><a href="#1-commitlog" rel="noopener nofollow">1. CommitLog</a><ul><li><a href="#用途" rel="noopener nofollow">用途：</a></li><li><a href="#存储内容" rel="noopener nofollow">存储内容：</a></li><li><a href="#联系" rel="noopener nofollow">联系：</a></li></ul></li><li><a href="#2-consumequeue" rel="noopener nofollow">2. ConsumeQueue</a><ul><li><a href="#用途-1" rel="noopener nofollow">用途：</a></li><li><a href="#存储内容-1" rel="noopener nofollow">存储内容：</a></li><li><a href="#联系和区别" rel="noopener nofollow">联系和区别：</a></li></ul></li><li><a href="#3-indexfile" rel="noopener nofollow">3. IndexFile</a><ul><li><a href="#用途-2" rel="noopener nofollow">用途：</a></li><li><a href="#存储内容-2" rel="noopener nofollow">存储内容：</a></li><li><a href="#联系和区别-1" rel="noopener nofollow">联系和区别：</a></li></ul></li><li><a href="#总结" rel="noopener nofollow">总结</a></li></ul></li><li><a href="#四刷盘机制" rel="noopener nofollow">（四）刷盘机制</a><ul><li><a href="#1-同步刷盘" rel="noopener nofollow">1. 同步刷盘</a></li><li><a href="#2-异步刷盘" rel="noopener nofollow">2. 异步刷盘</a></li><li><a href="#选择" rel="noopener nofollow">选择</a></li></ul></li><li><a href="#总结-1" rel="noopener nofollow">总结</a></li></ul></li></ul></div><p></p>
<p>RocketMQ作为一款分布式消息中间件，高可靠性是其最重要的特性之一。<br>
所以需要将消息进行持久化存储，以保证消息不丢失。</p>
<p>RocketMQ的消息存储是RocketMQ的核心组件之一，负责消息的存储和传输。RocketMQ的消息存储主要包括CommitLog、ConsumeQueue、IndexFile、Checkpoint等几个部分。</p>
<h2 id="前置消息存储交互流程">（前置）消息存储交互流程</h2>
<ol>
<li>生产者发送消息MQ；</li>
<li>MQ将消息存到存储系统；</li>
<li>返回消息存储结果；</li>
<li>消费者从存储系统拉取消息，消费消息；</li>
<li>消费者消费成功，返回消费结果；</li>
<li>存储系统删除消息。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153348518-1620433619.png" alt="" loading="lazy"></p>
<h2 id="一存储系统">（一）存储系统</h2>
<p>在上面的流程中，存储系统是RocketMQ的核心组件之一，负责消息的读写。</p>
<p>存储系统有以下几种选择：</p>
<ol>
<li>内存存储等；</li>
<li>关系型数据库存储；</li>
<li>文件存储；</li>
</ol>
<p><strong>在RocketMQ中，使用的是文件存储。</strong></p>
<h3 id="1-内存存储">1. 内存存储</h3>
<p>内存存储是一种高性能的存储方式，但是内存存储的数据是不稳定的，一旦断电，数据就会丢失。即便是以Redis为代表的内存数据库，也无法保证数据的持久化，在持久化方面，还是选择文件存储。所以对消息来说，内存存储是不适合的。</p>
<h3 id="2-关系型数据库存储">2. 关系型数据库存储</h3>
<p>关系型数据库存储是一种常见的存储方式，像MySQL、Oracle等都可以作为消息存储。阿帕奇的ActiveMQ、Pulsar等都是使用关系型数据库作为消息存储。但其实关系型数据库底层也是文件存储，所以对比直接使用文件存储，关系型数据库存储的性能会有所下降。<br>
<img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153355483-1585385585.png" alt="" loading="lazy"></p>
<h3 id="3-文件存储">3. 文件存储</h3>
<p>文件存储是一种常见的存储方式，像Kafka、RocketMQ、RabbitMQ等都是使用文件存储。文件存储的优点是性能高，稳定性好，适合消息存储。<br>
<img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153401093-1972954249.png" alt="" loading="lazy"></p>
<h2 id="二消息的存储和发送">（二）消息的存储和发送</h2>
<h3 id="1-消息存储顺序写入">1. 消息存储（顺序写入）</h3>
<p>磁盘的读写速度虽然比内存慢，但是和网络IO相比，磁盘的读写速度还是很快的。现在的磁盘读写速度已经达到了几百MB/s甚至上千MB/s，所以对于消息存储来说，磁盘的读写速度是足够的。<br>
但是在随机读写方面，磁盘的性能就会有比较严重的下降，所以RocketMQ的消息存储是<strong><em>顺序写入</em></strong>的，这样可以提高磁盘的读写性能。</p>
<h3 id="2-消息发送零拷贝">2. 消息发送（零拷贝）</h3>
<p>消息的发送，需要将磁盘内的数据发送到网络中，在这个过程中，会涉及到系统的内核态和用户态的切换，这个过程是比较耗时的。</p>
<p>把磁盘数据发送到网络中，需要经过以下几个步骤：</p>
<ol>
<li>从磁盘中读取数据；</li>
<li>将读取的数据发送到网络中；</li>
</ol>
<p>看似只有两个步骤，但是在实际的操作中，还会涉及到内核态和用户态的切换和数据复制等操作：</p>
<ol>
<li>从磁盘中读取数据，磁盘复制 -&gt; 内核态的缓冲区；</li>
<li>内核态的缓冲区复制 -&gt; 用户态的缓冲区；</li>
<li>将数据发送到网络中，从用户态的缓冲区复制 -&gt; 网络驱动的内核态缓冲区；</li>
<li>网络驱动的内核态缓冲区复制 -&gt; 网络中；</li>
</ol>
<p>重要‼️：<strong>RocketMQ通过mmap的方式将磁盘文件映射到内存中，这样可以减少内核态和用户态的切换，减少数据的复制，提高性能，也就是所谓的零拷贝。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153408295-193835351.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153414455-307610302.png" alt="" loading="lazy"></p>
<h2 id="三存储文件结构">（三）存储文件结构</h2>
<p><img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153422414-1594574405.png" alt="" loading="lazy"></p>
<p>在RocketMQ中，有三个重要的文件类型：commitlog、consumequeue和index文件。它们分别有不同的用途和存储内容。</p>
<h3 id="1-commitlog">1. CommitLog</h3>
<h4 id="用途">用途：</h4>
<p>CommitLog文件是RocketMQ存储消息的核心文件。所有的消息首先都会被写入到CommitLog文件中。<br>
它以顺序写的方式保存消息，以确保写入的高性能和可靠性。</p>
<h4 id="存储内容">存储内容：</h4>
<p>CommitLog文件存储的是消息的完整内容，包括消息的元数据（如消息ID、主题、队列ID等）和消息体。</p>
<h4 id="联系">联系：</h4>
<p>所有消息最初都会写入到CommitLog文件中，然后再由消息服务组件（例如：ConsumeQueue和IndexFile）进行进一步的处理。</p>
<h3 id="2-consumequeue">2. ConsumeQueue</h3>
<h4 id="用途-1">用途：</h4>
<p>ConsumeQueue是RocketMQ的消费者队列文件，主要用于提高消息消费的效率。<br>
它相当于消息的索引文件，消费者可以通过ConsumeQueue快速定位到需要消费的消息在CommitLog中的位置。</p>
<h4 id="存储内容-1">存储内容：</h4>
<p>ConsumeQueue文件存储的是消息在CommitLog中的物理偏移量、消息大小和消息的标签哈希值。</p>
<h4 id="联系和区别">联系和区别：</h4>
<p>ConsumeQueue是从CommitLog文件中生成的，用于加速消息消费。它只存储消息的索引信息，<strong><em>而不是消息的完整内容</em></strong>。</p>
<h3 id="3-indexfile">3. IndexFile</h3>
<h4 id="用途-2">用途：</h4>
<p>IndexFile是RocketMQ的索引文件，主要用于通过消息的索引（例如：消息的唯一标识符Key）快速查找消息。<br>
它实现了基于哈希的索引机制，支持消息的快速检索。</p>
<h4 id="存储内容-2">存储内容：</h4>
<p>IndexFile文件存储的是消息的Key（唯一标识符）、消息的物理偏移量和消息的存储时间。</p>
<h4 id="联系和区别-1">联系和区别：</h4>
<p>IndexFile也是从CommitLog文件中生成的，但它的目的是为了提供消息的快速检索功能。<br>
与ConsumeQueue不同，IndexFile是通过消息的Key来查找消息，而不是通过主题和队列。ConsumeQueue是通过消息的主题和队列ID来查找消息。</p>
<h3 id="总结">总结</h3>
<p>CommitLog：RocketMQ中存储所有消息的核心文件，保存消息的完整内容。<br>
ConsumeQueue：消费者队列文件，用于加速消息消费，存储消息的索引信息。<br>
IndexFile：索引文件，用于快速检索消息，存储消息的Key和物理偏移量。<br>
这三种文件共同协作，确保了RocketMQ的高性能和高可靠性。CommitLog负责消息的存储，ConsumeQueue提高了消息的消费效率，而IndexFile则提供了消息的快速检索能力。</p>
<h2 id="四刷盘机制">（四）刷盘机制</h2>
<p>RocketMQ的消息存在磁盘中，这样能保证在断电后消息不会丢失。<br>
在消息写入磁盘的过程中，有两种刷盘机制：<strong>同步刷盘和异步刷盘。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3585828/202501/3585828-20250120153431340-301132530.png" alt="" loading="lazy"></p>
<h3 id="1-同步刷盘">1. 同步刷盘</h3>
<p>同步刷盘是指在消息写入磁盘后，需要等待磁盘的写入操作完成后，才返回写入成功的结果。</p>
<p>同步刷盘的优点是数据安全，可以保证消息不会丢失。但是同步刷盘的缺点是性能较差，因为需要等待磁盘的写入操作完成后才能返回结果。</p>
<h3 id="2-异步刷盘">2. 异步刷盘</h3>
<p>异步刷盘是指在消息写入磁盘后，不需要等待磁盘的写入操作完成，可以立即返回写入成功的结果，然后由后台线程负责将数据刷盘到磁盘中。</p>
<p>异步刷盘的优点是性能较好，因为不需要等待磁盘的写入操作完成，可以立即返回结果。但是异步刷盘的缺点是数据不安全，可能会丢失部分消息。</p>
<h3 id="选择">选择</h3>
<p>在实际的应用中，可以根据业务的需求选择合适的刷盘机制。如果对数据的安全性要求较高，可以选择同步刷盘；如果对性能要求较高，可以选择异步刷盘。</p>
<h2 id="总结-1">总结</h2>
<p>RocketMQ的消息存储是RocketMQ的消息持久化的方式，保证消息不会丢失。<br>
我们讲了以下几部分相关的内容：</p>
<ol>
<li>存储系统的选择，选择了文件存储。</li>
<li>消息的存储和发送，通过顺序写入和零拷保证性能。（也是RocketMQ为什么高性能的主要原因）</li>
<li>存储文件结构，CommitLog、ConsumeQueue和IndexFile。</li>
<li>刷盘机制，同步刷盘和异步刷盘。</li>
</ol>
<p>这些内容是RocketMQ消息存储的核心内容，对于理解RocketMQ的消息存储机制非常重要。希望本文对你有所帮助，如果有任何问题，欢迎留言讨论。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7253746263229167" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 15:36">2025-01-20 15:33</span>&nbsp;
<a href="https://www.cnblogs.com/seazhan">Java记事本</a>&nbsp;
阅读(<span id="post_view_count">119</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18681536" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18681536);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18681536', targetLink: 'https://www.cnblogs.com/seazhan/p/18681536', title: '【RocketMQ 消息中间件】RocketMQ篇之-消息存储 为什么性能高 CommitLog ConsumeQueue IndexFile 刷盘机制 同步 异步' })">举报</a>
</div>
        