
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/newbe36524/p/18873875/0049-Dive-into-async-and-sync-completion" title="发布于 2025-05-13 10:41">
    <span role="heading" aria-level="2">好哥哥因为没有搞清楚同步完成和异步完成导致代码死循环了这档事</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        有个好哥哥说他遇到循环代码死循环的问题，所以仔细的研究了一下，于是发现了关于同步完成和异步完成的区别。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">

<p>有个好哥哥说他遇到循环代码死循环的问题，所以仔细的研究了一下，于是发现了关于同步完成和异步完成的区别。</p>
<h2>什么是死循环</h2>
<p>比如，长这个样子</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoop()
{
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will never reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">void <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(<span class="hljs-number">100); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (GetBool());

        <span class="hljs-keyword">return;

        <span class="hljs-function"><span class="hljs-built_in">bool <span class="hljs-title">GetBool()
        {
            <span class="hljs-keyword">return <span class="hljs-literal">true;
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>❌ 这段代码一但开始运行，将不会结束，也不会打印 <code>nice end</code>。 因为 <code>Yanjia_foRever_niCE</code> 这个方法是一个死循环，永远不会结束。</p>
<h2>那如果 <code>GetBool()</code> 返回 <code>Task&lt;bool&gt;</code> 呢</h2>
<p>比如，长这个样子</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoopWithSyncCompletion()
{
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will never reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">async Task <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(<span class="hljs-number">100); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (<span class="hljs-keyword">await GetBoolAsync());

        <span class="hljs-keyword">return;

        <span class="hljs-function">Task&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync()
        {
            <span class="hljs-keyword">return Task.FromResult(<span class="hljs-literal">true);
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>❌ 这个代码，看起来用了 Task 但是依然是一个死循环。因为 <code>GetBoolAsync</code> 返回的是一个 Task，但它是一个同步完成的 Task。所有的操作都会在当前线程完成，不会切换到其他线程。</p>
<h2>聪明的宝宝已经想到了可以加上 async await</h2>
<p>比如，长这个样子</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoopWithSyncCompletion2()
{
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will never reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">async Task <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(<span class="hljs-number">100); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (<span class="hljs-keyword">await GetBoolAsync());

        <span class="hljs-keyword">return;

        <span class="hljs-function"><span class="hljs-keyword">async Task&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync()
        {
            <span class="hljs-keyword">return <span class="hljs-literal">true;
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>❌ 但实际上，没有任何卵用，因为 <code>GetBoolAsync</code> 本质依然是一个同步完成的 Task。所有的操作都会在当前线程完成，不会切换到其他线程。 并且实际上会触发编译器警告，乖宝宝可不要这样写哟。</p>
<h2>但是我用 await Task.FromResult(true) 很开心</h2>
<p>比如，长这个样子</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoopWithSyncCompletion3()
{
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will never reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">async Task <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(<span class="hljs-number">100); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (<span class="hljs-keyword">await GetBoolAsync());

        <span class="hljs-keyword">return;

        <span class="hljs-function"><span class="hljs-keyword">async Task&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync()
        {
            <span class="hljs-keyword">return <span class="hljs-keyword">await Task.FromResult(<span class="hljs-literal">true);
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>❌ 确实曾经有好哥哥这么写过代码，但是实际上 <code>await Task.FromResult(true)</code> 依然是一个同步完成的 Task。 <code>async</code> 和 <code>await</code> 是不会改变 Task 的完成方式的。 它是同步完成，就一直都是同步完成。当然这样写还有一个好处就是可以略微增加代码量 XD。</p>
<h2>真的异步才行</h2>
<p>比如，长这个样子</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoopWithAsyncCompletion()
{
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">async Task <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(<span class="hljs-number">100); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (<span class="hljs-keyword">await GetBoolAsync());

        <span class="hljs-keyword">return;

        <span class="hljs-function"><span class="hljs-keyword">async Task&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync()
        {
            <span class="hljs-keyword">await Task.Delay(<span class="hljs-number">100);
            <span class="hljs-keyword">return <span class="hljs-literal">true;
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>✅ 这段代码就可以正常结束了，因为 <code>GetBoolAsync</code> 返回的是一个异步完成的 Task。其中的 <code>await Task.Delay(100)</code> 会真的触发异步完成。从而导致 <code>Yanjia_foRever_niCE</code> 由于没有 await 而直接推进到 <code>nice end</code> 这行代码。</p>
<h2>有人好奇 ValueTask 会怎么样</h2>
<p>实际上上面所有的 Task 换成 ValueTask 都是一样的。比如</p>
<pre><code class="language-csharp hljs"><span class="hljs-function">ValueTask&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync() <span class="hljs-comment">// ❌
{
    <span class="hljs-keyword">return ValueTask.FromResult(<span class="hljs-literal">true);
}

<span class="hljs-function"><span class="hljs-keyword">async ValueTask&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync() <span class="hljs-comment">// ❌
{
    <span class="hljs-keyword">return <span class="hljs-literal">true;
}

<span class="hljs-function"><span class="hljs-keyword">async ValueTask&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync() <span class="hljs-comment">// ❌
{
    <span class="hljs-keyword">return <span class="hljs-keyword">await ValueTask.FromResult(<span class="hljs-literal">true);
}

<span class="hljs-function"><span class="hljs-keyword">async ValueTask&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync() <span class="hljs-comment">// ✅
{
    <span class="hljs-keyword">await Task.Delay(<span class="hljs-number">100);
    <span class="hljs-keyword">return <span class="hljs-literal">true;
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>这些代码产生的效果和上面所有的 Task 代码是一样的。</p>
<p>也就是 ValueTask 也不会影响这段代码是同步完成还是异步完成。</p>
<h2>其实一开始是因为一个 Timer</h2>
<p>.NET6 中的 <code>PeriodicTimer</code> 是一个定时器，它的 <code>WaitForNextTickAsync</code> 方法是一个返回 <code>ValueTask&lt;bool&gt;</code> 的方法。</p>
<p>它有一个很合理但是可能有时候注意不到的地方，就是计时是从创建实例开始的，而不是从调用 <code>WaitForNextTickAsync</code> 开始的。</p>
<p>比如下面这段代码：</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">Test]
<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">EndlessLoopWithSyncCompletion()
{
    <span class="hljs-keyword">var timer = <span class="hljs-keyword">new PeriodicTimer(TimeSpan.FromSeconds(<span class="hljs-number">0.01));
    Yanjia_foRever_niCE();
    Console.WriteLine(<span class="hljs-string">"nice end"); <span class="hljs-comment">// it will never reach here
    <span class="hljs-keyword">return;

    <span class="hljs-function"><span class="hljs-keyword">async Task <span class="hljs-title">Yanjia_foRever_niCE()
    {
        <span class="hljs-keyword">do
        {
            Thread.Sleep(TimeSpan.FromSeconds(<span class="hljs-number">0.5)); <span class="hljs-comment">// some code running synchronously
            Console.WriteLine(<span class="hljs-string">"严架 nice");
        } <span class="hljs-keyword">while (<span class="hljs-keyword">await GetBoolAsync());

        <span class="hljs-keyword">return;

        <span class="hljs-function">ValueTask&lt;<span class="hljs-built_in">bool&gt; <span class="hljs-title">GetBoolAsync()
        {
            <span class="hljs-keyword">return timer.WaitForNextTickAsync();
        }
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>这段代码中， timer 的创建时间是 0.01 秒，而 <code>Thread.Sleep</code> 的时间是 0.5 秒。这也就意味者，在每次进入 <code>GetBoolAsync</code> 方法时， timer 早就已经到了下一个 tick 的时间了。</p>
<p>所以这个时候 <code>timer.WaitForNextTickAsync()</code> 返回的就是一个同步完成的 ValueTask。</p>
<p>因为它是一个同步完成的 ValueTask，所以 <code>await</code> 也不会切换到其他线程。从而就导致了死循环。</p>
<p>而，如果将 timer 的创建时间改成 1 秒，那么当 <code>Thread.Sleep</code> 结束时， timer 的 tick 还没有到达，所以 <code>timer.WaitForNextTickAsync()</code> 返回的就是一个异步完成的 ValueTask。</p>
<p>这时候 <code>await GetBoolAsync()</code> 就会切换到调度器上，从而导致 <code>Yanjia_foRever_niCE</code> 结束，打印 <code>nice end</code>。</p>
<p>这就是一开始好哥哥遇到的问题。</p>
<h2>总结</h2>
<p>代码是同步完成还是异步完成，和返回值是 Task 还是 ValueTask 没有关系，和有没有 async/await 也没有关系。</p>
<p>它只与实现的代码究竟有没有真异步操作有关。</p>
<p>测试代码在：<a href="https://github.com/newbe36524/Newbe.Demo/tree/main/src/BlogDemos/Newbe.NiceValueTasks" rel="noopener nofollow">GitHub</a></p>
<p>感谢阅读，如果觉得本文有用，不妨点击推荐👍或者在评论区留下 Mark，让更多的人可以看到。</p>
<blockquote>
<p>欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。 <img src="https://www.newbe.pro/images/weixin_public_qrcode.png" alt="关注微信公众号“newbe技术专栏”"></p>
</blockquote>
<ul>
<li>本文作者： <a href="https://www.newbe.pro/" rel="noopener nofollow">newbe36524</a></li>
<li>本文链接： <a href="https://www.newbe.pro/Others/0049-Dive-into-async-and-sync-completion/" rel="noopener nofollow">https://www.newbe.pro/Others/0049-Dive-into-async-and-sync-completion/</a></li>
<li>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</li>
</ul>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.020450069542824075" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-13 10:42">2025-05-13 10:41</span>&nbsp;
<a href="https://www.cnblogs.com/newbe36524">Newbe36524</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873875);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873875', targetLink: 'https://www.cnblogs.com/newbe36524/p/18873875/0049-Dive-into-async-and-sync-completion', title: '好哥哥因为没有搞清楚同步完成和异步完成导致代码死循环了这档事' })">举报</a>
</div>
        