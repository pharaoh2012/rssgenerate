
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18712938" title="发布于 2025-02-13 13:39">
    <span role="heading" aria-level="2">用网络流建模解决最大密度子图问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在图论中，子图是由原图的一部分节点和这些节点之间的边构成的图。图的密度通常是指图中边的数量与节点的数量之比。形式化地，对于一个图 $ H = (V, E) $，其密度定义为：</p>
<p></p><div class="math display">\[\text{密度}(H) = \frac{|E|}{|V|}
\]</div><p></p><p>其中，$ |E| $ 表示图 $ H $ 中的边的数量，$ |V| $ 是图 $ H $ 中节点的数量。图的密度即“边数/点数”。</p>
<p>最大密度子图问题要求这样一个目标：从给定的图中找出一个子图，使得该子图的<strong>密度</strong>最大。</p>
<p>最大密度子图问题在多个领域中都有重要的应用，特别是在社交网络分析、生物信息学、推荐系统等领域。通过找出一个图中最大密度的子图，我们能够捕捉到图中的重要结构或紧密联系的节点子集。这些子集往往包含了图中最具有信息价值的部分。</p>
<h2 id="二分猜测答案和最大流验证">二分猜测答案和最大流验证</h2>
<p>直接求解最大密度子图是一个 NP 难题。但通过网络流构造与二分法，我们可以在多项式时间内高效求解。</p>
<p>假设最大密度为 <span class="math inline">\(g^*\)</span>，我们通过二分猜测一个候选值 <span class="math inline">\(g\)</span>，并检验是否存在子图 <span class="math inline">\(S\)</span> 达到此密度，通过二分法不断调整 <span class="math inline">\(g\)</span>，直至收敛到 <span class="math inline">\(g^*\)</span>。</p>
<h4 id="网络流构造将密度检验映射为最小割">网络流构造：将密度检验映射为最小割</h4>
<p>对每个猜测的 <span class="math inline">\(g\)</span>，我们构造一个流网络，使得其最小割对应密度至少为 <span class="math inline">\(g\)</span> 的子图存在性。网络构造如下：</p>
<p><strong>顶点与边的定义</strong></p>
<ul>
<li>源点 <span class="math inline">\(s\)</span> 和汇点 <span class="math inline">\(t\)</span>：在原图外新添加两个点，用于划分子图候选集合 <span class="math inline">\(S\)</span>（与 <span class="math inline">\(s\)</span> 连通）和非候选集合 <span class="math inline">\(T\)</span>（与 <span class="math inline">\(t\)</span> 连通）。</li>
<li>边容量设计：
<ol>
<li><strong>源点 <span class="math inline">\(s\)</span> 到每个顶点 <span class="math inline">\(v\)</span></strong>：容量为 <span class="math inline">\(m\)</span>（原图总边数）。</li>
<li><strong>每个顶点 <span class="math inline">\(v\)</span> 到汇点 <span class="math inline">\(t\)</span></strong>：容量为 <span class="math inline">\(m + 2g - \text{deg}(v)\)</span>（<span class="math inline">\(\text{deg}(v)\)</span> 为顶点度数）。</li>
<li><strong>原图中的边 <span class="math inline">\((u, v)\)</span></strong>：拆分为两条有向边 <span class="math inline">\(u \to v\)</span> 和 <span class="math inline">\(v \to u\)</span>，容量均为 <span class="math inline">\(1\)</span>。</li>
</ol>
</li>
</ul>
<p><strong>为什么这么做？</strong></p>
<ul>
<li><strong>顶点到汇点的边</strong>：容量 <span class="math inline">\(m + 2g - \text{deg}(v)\)</span> 平衡了顶点选择的成本。度数高的顶点（可能贡献更多边）到 <span class="math inline">\(t\)</span> 的容量较低，更容易被保留在 <span class="math inline">\(S\)</span> 中。</li>
<li><strong>原边的双向容量</strong>：若子图 <span class="math inline">\(S\)</span> 包含边 <span class="math inline">\((u, v)\)</span>，则 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 均属于 <span class="math inline">\(S\)</span>，双向边不会被切割；否则至少一条边被切断，代价为 <span class="math inline">\(1\)</span>，对应损失这条边对密度的贡献。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250213132520615-700850813.png" alt="image" loading="lazy"></p>
<p>接下来运行最大流最小割算法。</p>
<h4 id="割容量公式">割容量公式</h4>
<p>对这样构造的图的任意割 <span class="math inline">\((S \cup \{s\}, T \cup \{t\})\)</span>，其总容量（也等于最小割）为：</p>
<p></p><div class="math display">\[\begin{aligned}
C &amp;= \underbrace{m|T|}_{\text{源到非候选集}} + \underbrace{\sum_{v \in S} \left(m + 2g - \text{deg}(v)\right)}_{\text{候选集到汇点}} + \underbrace{2c(S, T)}_{\text{原边切割}} \\
&amp;= mn + 2g|S| - 2|E(S)| + 2c(S, T),
\end{aligned}
\]</div><p></p><p>其中 <span class="math inline">\(c(S, T)\)</span> 是原图中 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的边数，<span class="math inline">\(n\)</span> 为总顶点数。当 <span class="math inline">\(C &lt; mn\)</span> 时，化简可得：</p>
<p></p><div class="math display">\[g|S| - |E(S)| + c(S, T) &lt; 0 \implies |E(S)| &gt; g|S| - c(S, T).
\]</div><p></p><p>由于 <span class="math inline">\(c(S, T) \geq 0\)</span>，此时至少存在子图 <span class="math inline">\(S\)</span> 满足 <span class="math inline">\(|E(S)| \geq g|S|\)</span>，即当前猜测 <span class="math inline">\(g\)</span> 可行。</p>
<p>若选取的 <span class="math inline">\(g\)</span> 足够小，到汇点的容量不足，源点出发的所有边不能灌满。最小割顶点更倾向于划入源点以避免高切割代价。当 <span class="math inline">\(g\)</span> 较大时，容量将总是 <span class="math inline">\(mn\)</span>，当最小割容量首次达到 <span class="math inline">\(mn\)</span>，此时对应的 <span class="math inline">\(g\)</span> 即为最大密度。此时最小割中所有的点及其互相相连的边刚好贯通所有流量，他们就构成了我们要的最大密度子图。</p>
<p>所以，若当前网络的最小割容量 <span class="math inline">\(C &lt; mn\)</span>，说明存在密度超过 <span class="math inline">\(g\)</span> 的子图，可尝试<strong>增大</strong> <span class="math inline">\(g\)</span>；否则需<strong>减小</strong> <span class="math inline">\(g\)</span>。最终当猜测区间足够小时结束算法，得到答案，而最终最小割对应的顶点集合 <span class="math inline">\(S\)</span> 即为最大密度子图。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19265117664583334" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 13:39">2025-02-13 13:39</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712938" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712938);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712938', targetLink: 'https://www.cnblogs.com/ofnoname/p/18712938', title: '用网络流建模解决最大密度子图问题' })">举报</a>
</div>
        