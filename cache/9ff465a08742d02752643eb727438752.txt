
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18628631" title="发布于 2024-12-25 14:13">
    <span role="heading" aria-level="2">【杂谈】Kafka的无锁设计</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>前言</h3>
<p>在分布式消息队列系统中，<strong>Kafka</strong> 的无锁设计是其高吞吐量和高并发的核心优势之一。通过避免锁的竞争，Kafka 能够在高并发和大规模的生产环境中保持高效的性能。为了更好地理解 Kafka 的无锁设计，我们首先对比传统的队列模型，然后探讨 Kafka 如何通过无锁机制优化生产者和消费者之间的工作。</p>
<h3>【应用级】多生产者，多消费者的队列是怎样的？</h3>
<p><strong>1）有锁的可变队列</strong></p>
<p>在传统的队列模型中，生产者和消费者必须争抢锁来读写队列的数据：</p>
<ul>
<li><strong>生产者</strong> 在获得锁后将消息插入队列。</li>
<li><strong>消费者</strong> 在获得锁后从队列中拉取消息。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225131216438-665110441.png" alt="" width="538" height="283" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225131309114-918606219.png" alt="" width="534" height="304" loading="lazy"></p>
<p>为什么要用锁呢？用锁的目的是保护数据，防止数据被错误覆盖。</p>
<p>然而，在高并发场景下，锁竞争成为了一个瓶颈，尤其是在生产者和消费者数量庞大的情况下，锁竞争会显著影响队列的性能和吞吐量。</p>
<p>&nbsp;</p>
<p><strong>2）无锁的环形队列</strong></p>
<p>在 Java 的 <strong>Disruptor</strong> 框架中，使用了性能优越的 <strong>RingBuffer</strong>（环形队列）作为存储结构。与传统队列不同，RingBuffer 在初始化时就预分配了内存空间，生产者和消费者通过<strong>读写指针</strong>来控制数据的读写位置</p>
<p>与上面的队列不同，这里的读操作不修改队列，仅修改指针</p>
<ul>
<li><strong>生产者</strong>：Disruptor推荐使用单生产者模式，这种性能最高。如果要使用多生产者模式，多个生产者需要通过CAS（Compare-And-Swap）来判断是否获得队列序号，进而修改队列。</li>
<li><strong>消费者</strong>：单消费者模式，需要CAS竞争读指针序号。多消费模式，则维护各自的读指针，避免了竞争</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225132455786-911106623.png" alt="" width="556" height="474" loading="lazy"></p>
<p>&nbsp;</p>
<h3>Kafka 生产者如何实现无锁设计？</h3>
<p>Kafka 生产者通过以下几种方式避免了锁的竞争，确保了高效的数据写入：</p>
<p><strong>1）追加写入（Append-Only）</strong></p>
<p>Kafka 的队列采用文件追加的方式来写入数据，这意味着每次数据写入都直接附加到文件末尾，而无需修改文件中的任何现有区域。这种设计避免了写入区域的竞争，也没有锁竞争的问题。即使有锁，也只是写锁，而文件追加操作本身是操作系统级别的原子操作，性能非常高。</p>
<p><strong>2）批量提交</strong><br>Kafka 生产者将多条消息批量打包成一个批次，并将整个批次作为一个单位提交到 Kafka Broker。通过批量提交，生产者无需为每条消息单独等待响应，这大大减少了锁竞争和网络延迟，从而显著提高了整体的吞吐量。</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225135711818-1654418126.png" alt="" width="666" height="377" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225135752011-287345368.png" alt="" width="675" height="372" loading="lazy"></p>
<p>&nbsp;</p>
<h3>Kafka 消费者如何实现无锁设计？</h3>
<p>Kafka 的消费者设计也遵循无锁的原则，具体体现在以下几个方面：</p>
<p><strong>1）分区独占</strong><br>每个 Kafka <strong>分区</strong> 只能由同一个 <strong>消费组</strong> 内的一个消费者处理。这样，同一消费者组内的消费者不会发生资源竞争，每个消费者只需处理自己分配到的分区数据，避免了多个消费者间的干扰。</p>
<p><strong>2）只读消费和偏移量管理</strong></p>
<p>Kafka 消费者从 Broker 拉取数据后，只进行读取操作，不对数据进行修改。每个消费者维护自己的消费进度（即 <strong>偏移量</strong>），并在成功处理消息后提交偏移量。由于消费者不修改数据内容，他们之间不会互相干扰，也不需要竞争对数据的锁。不同消费者组之间会各自维护各自的消费进度，避免了相互之间的竞争。</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202412/1313132-20241225140400238-398868962.png" alt="" width="558" height="524" loading="lazy"></p>
<h3>总结</h3>
<p>Kafka 的无锁设计通过多个机制有效避免了锁竞争，从而提升了系统的吞吐量和并发能力。通过批量提交、追加写入和分区独占等设计，Kafka 能够在高并发的环境中提供极高的性能。而消费者设计中的只读消费和偏移量管理，进一步优化了数据的读取效率，避免了无谓的竞争和资源浪费。这些无锁设计是 Kafka 高效、可靠的基础，确保它能够在大规模分布式环境中运行良好。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004173315765046297" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 14:14">2024-12-25 14:13</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628631" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628631);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628631', targetLink: 'https://www.cnblogs.com/longfurcat/p/18628631', title: '【杂谈】Kafka的无锁设计' })">举报</a>
</div>
        