
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/geekzone/p/18628805" title="发布于 2025-01-02 10:07">
    <span role="heading" aria-level="2">JMeter JSR223 Sampler 教程：性能测试的魔法棒</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="jmeter-jsr223-sampler-教程性能测试的魔法棒">JMeter JSR223 Sampler 教程：性能测试的魔法棒</h1>
<p>宝子们，今天咱要深入探索 JMeter 里超厉害的 JSR223 Sampler，它就像是一把万能钥匙，能打开性能测试的各种奇妙大门，让咱的测试变得超厉害！</p>
<p><img src="https://img2024.cnblogs.com/blog/3580944/202412/3580944-20241224220956023-1316580546.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3580944/202412/3580944-20241224221024893-1582630381.png" alt="" loading="lazy"></p>
<p><strong>一、简介</strong></p>
<p>JSR223 Sampler 可是 JMeter 中的一个宝藏组件哦！它是基于 JSR223 规范打造的，这就意味着它能和 Groovy、JavaScript、Python 等多种脚本语言愉快地玩耍，给咱们提供了超多的可能性。</p>
<p>比如说，在测试一个旅游预订平台的时候，它能帮咱大忙！像动态生成各种搜索条件，一会儿是查找去海边的度假套餐，一会儿是搜索山区的民宿，让测试场景更加丰富真实。还能对平台返回的酒店信息、价格数据等进行仔细的分析和处理，看看有没有啥不对劲的地方。而且，当用户预订流程中出现各种情况时，它可以通过自定义流程控制，巧妙地模拟用户的不同操作，像登录成功后预订酒店，或者登录失败后的重新尝试等等，是不是感觉很厉害呢？</p>
<p><strong>二、 JSR223 Sampler 与其他 Sampler 的关系</strong></p>
<ul>
<li>
<p>JSR223 Sampler 在性能测试中确实是一个强大的辅助工具，它与其他 Sampler 共同协作，为测试提供更全面、灵活的解决方案。例如，在测试一个复杂的电商系统时，HTTP 请求 Sampler 用于模拟用户登录、浏览商品、下单等常规操作，而 JSR223 Sampler 则可以在这些操作的基础上进行动态参数生成、响应数据处理以及自定义流程控制。</p>
</li>
<li>
<p>比如，在用户登录操作后，JSR223 Sampler 可以根据登录成功与否，动态决定后续的操作流程。如果登录成功，它可以从登录响应中提取用户 ID 等关键信息，并将其传递给后续的订单查询 Sampler，作为查询条件。如果登录失败，它可以控制流程重新回到登录页面，再次尝试登录，或者执行其他错误处理逻辑。</p>
</li>
<li>
<p>再比如，在测试商品搜索功能时，HTTP 请求 Sampler 发送搜索请求，JSR223 Sampler 可以根据不同的测试场景，动态生成搜索关键词，然后对搜索结果进行分析，判断搜索结果是否符合预期，如商品数量、价格范围等。这样，JSR223 Sampler 与 HTTP 请求 Sampler 相互配合，实现了更真实、更全面的性能测试场景模拟。</p>
</li>
</ul>
<p><strong>三、JSR223 Sampler 详细指南</strong></p>
<ol>
<li>
<p><strong>主要功能</strong></p>
<ul>
<li><strong>动态参数生成</strong>：想象一下，你在测试一个电商 APP，要模拟不同用户搜索不同商品的情况。JSR223 Sampler 就可以通过编写代码，像变魔术一样随机生成各种商品关键词，比如一会儿是 “时尚连衣裙”，一会儿是 “智能手表”，让测试更接近真实用户的行为，这样就能全面检测搜索功能在不同输入下的表现啦。</li>
<li><strong>响应数据处理</strong>：当电商 APP 返回商品列表数据后，它能像个精明的小助手一样，从返回的 JSON 格式数据里，把商品的价格、销量、评价数量等关键信息提取出来，然后咱们就可以根据这些数据来判断 APP 是不是正确地展示了商品信息，有没有隐藏的问题。</li>
<li><strong>自定义流程控制</strong>：如果是测试一个在线办公软件，登录后可能会有不同的操作路径，比如新建文档、编辑表格或者参加在线会议。JSR223 Sampler 可以根据前一个操作的结果，比如登录是否成功，来决定接下来执行哪个操作，就像一个智能导航，带领测试流程走向不同的方向，模拟出各种复杂的真实使用场景。</li>
<li><strong>与 JMeter API 交互</strong>：它还能和 JMeter 的各种内部组件 “聊天” 哦！比如说获取当前线程的详细信息，像是线程的编号、状态等，然后根据这些信息来调整测试的节奏。还可以轻松地操作测试计划里的变量，让不同的采样器之间能够默契配合，实现更复杂的业务流程模拟，就像一个团队的指挥官，协调着各个部分的工作。</li>
<li><strong>外部资源接入</strong>：要是测试一个金融交易系统，可能需要和外部的股票行情数据接口或者银行验证接口打交道。JSR223 Sampler 可以通过编写代码，使用各种编程语言的库和工具，像一个桥梁一样连接到这些外部资源，获取最新的股票价格或者验证银行账户信息，然后把这些数据融入到性能测试中，让测试更加真实可靠。</li>
</ul>
</li>
<li>
<p><strong>使用步骤</strong></p>
<ul>
<li><strong>添加 JSR223 Sampler</strong>：在咱们已经搭建好的测试计划里，找到合适的位置（一般就在线程组下面或者其他采样器旁边），右键轻轻一点，然后选择 “添加”-&gt;“Sampler”-&gt;“JSR223 Sampler”，这就相当于给测试计划请来了一个超级助手，准备大显身手啦。</li>
<li><strong>选择脚本语言</strong>：添加好之后，会看到一个下拉菜单，这里就是选择脚本语言的地方。就像在一个魔法工具盒里挑选最顺手的工具一样，你可以根据自己的喜好和对不同语言的熟悉程度来选择。比如你之前用 Python 写过一些数据分析的小脚本，那就选 Python；要是你对 Java 比较熟悉，那 Groovy 可能就是你的菜，因为它和 Java 兼容性很好，语法还更加简洁灵活；要是你经常在前端领域折腾，JavaScript 也能派上大用场，它有很多方便的函数和工具可以用。</li>
<li><strong>编写脚本</strong>：选好语言后，下面就会出现一个大框框，这就是咱们施展魔法的舞台啦！根据测试的需求，用所选语言的语法规则开始编写代码。比如说，用 Groovy 来实现从一个文件里读取用户登录信息，然后设置为 JMeter 变量的功能，代码可以这样写：</li>
</ul>
</li>
</ol>
<pre><code class="language-groovy">import org.apache.jmeter.services.FileServer

// 先找到文件在哪里，这就像在寻宝地图上找到宝藏的位置
String fileName = FileServer.getFileServer().getBaseDir() + "/path/to/your/file"

// 把文件里的内容读取出来，就像打开宝箱拿到里面的宝贝
String fileContent = new File(fileName).text

// 把这个宝贝（文件内容）变成 JMeter 能认识的变量，方便后面的测试使用
vars.put("fileContent", fileContent)
</code></pre>
<ul>
<li><strong>执行测试</strong>：代码写好后，别忘了保存哦！然后就像平常启动 JMeter 测试一样，点击那个绿色的三角形 “启动” 按钮，这时候 JSR223 Sampler 就会按照你写的脚本逻辑，和其他采样器一起默契配合，开始这场性能测试的奇妙之旅啦。</li>
</ul>
<ol start="3">
<li>
<p><strong>内置变量和对象</strong></p>
<ul>
<li><strong><code>log</code></strong>：这就像是测试过程中的一个小日记本，你可以在脚本里用 “<a href="https://log.info/" target="_blank" rel="noopener nofollow">log.info</a>("这是一个重要的调试信息哦，记录一下")” 这样的语句，把一些关键的信息记录下来，比如某个变量的值在某个时刻的变化情况，或者是代码执行到某个关键步骤的提示。这样，当测试出现问题时，咱们就可以通过查看这些记录，像翻看日记一样，找到问题的线索，看看是哪里出了岔子。</li>
<li><strong><code>vars</code></strong>：它可是变量的贴心小管家！比如说，你在登录采样器里获取到了用户的登录令牌，就可以用 “vars.put ("loginToken", "abcdefg")” 把这个令牌存起来，然后在后续的订单查询采样器里，用 “vars.get ("loginToken")” 把这个令牌取出来，用在查询请求中，这样就能保证整个测试流程中数据的连贯性，就像一个接力赛，每个采样器都能顺利地接过前一个采样器传递的 “接力棒”（变量值）。</li>
<li><strong><code>SampleResult</code></strong>：这个对象就像是一个魔法画笔，可以用来修改样本的结果信息。比如说，有时候服务器返回的响应数据可能不太符合预期，咱们可以用 “SampleResult.setResponseCode ("200")” 手动把响应状态码改成 200，模拟一个成功的响应，或者用 “SampleResult.setResponseData ("这是我自定义的响应数据哦", "UTF-8")” 来设置自定义的响应数据内容和字符编码，这样就能在测试中灵活地控制样本结果，更好地模拟各种情况。</li>
<li><strong><code>prev</code></strong>：它代表前一个样本的结果，就像一个时光回溯的魔法镜。比如说前一个采样器是发送了一个 HTTP 请求获取商品信息，那在 JSR223 Sampler 里，就可以用 “prev.getResponseCode ()” 看看前一个请求的响应状态码，判断请求是否成功；用 “prev.getResponseDataAsString ()” 获取响应数据的字符串形式，然后分析里面的商品价格、库存等信息，根据这些信息来决定接下来的测试步骤，是不是很神奇呢？</li>
<li><strong><code>sampler</code></strong>：这是指向当前采样器的一个小指针，通过它可以获取当前 JSR223 Sampler 的一些属性。比如 “sampler.getName ()” 能获取采样器的名字，这样在代码里就可以根据采样器的名字来执行不同的逻辑。如果有多个 JSR223 Sampler，就可以通过名字来区分它们，让每个采样器都能各司其职，完成自己独特的任务。</li>
<li><strong><code>ctx</code></strong>：它就像是一个万能的魔法口袋，里面装着关于当前测试执行上下文的各种信息。比如 “ctx.getThreadNum ()” 可以获取当前线程的编号，在多线程并发测试中，就可以根据线程编号来给不同的线程分配不同的任务或者数据，就像老师给不同学号的学生布置不同的作业一样。“ctx.getVariables ()” 还能获取当前线程上下文中的所有变量信息，这样就能对整个测试环境有更全面的了解，更好地控制测试流程。</li>
</ul>
</li>
<li>
<p><strong>参数传递</strong></p>
<ul>
<li><strong><code>parameters</code></strong>：在 JMeter 的界面上，咱们可以给 JSR223 Sampler 设置一些参数，就像给它偷偷塞了一些小纸条。在脚本里，用 “parameters.get ("parameterName")” 就能拿到这些纸条上写的内容啦。比如说，你在界面上设置了一个 “userID” 参数，值是 “12345”，那在脚本里用 “parameters.get ("userID")” 就能获取到 “12345” 这个值，然后就可以用这个用户 ID 去做各种和用户相关的操作，比如查询用户的订单历史、个人信息等等，是不是很方便呢？</li>
<li><strong><code>args</code></strong>：这是一个参数数组，当咱们在启动 JMeter 的时候，从命令行给它传递了一些参数，这些参数就会像一群小精灵一样，飞进这个数组里。比如说，在命令行里用 “jmeter -Jparam1=value1 -Jparam2=value2” 这样的方式启动 JMeter，然后在 JSR223 Sampler 的脚本里，就可以用 “args [0]” 获取到 “value1”，用 “args [1]” 获取到 “value2”，这样就能根据外部输入的参数，灵活地调整测试逻辑，就像根据天气预报来决定出门是带伞还是戴帽子一样。</li>
</ul>
</li>
<li>
<p><strong>脚本性能</strong></p>
<ul>
<li><strong>避免创建过多对象</strong>：宝子们，写脚本的时候可不能太任性哦！比如说，在一个循环里，如果不停地创建新的字符串对象或者其他复杂对象，就像在一个小房间里不停地堆放杂物，会让内存变得越来越拥挤，测试速度也会变慢。所以，要尽量避免这种情况，可以把一些对象的创建放在循环外面，或者使用字符串常量池、对象池等技术，就像把杂物整理好放在固定的收纳箱里，这样就能减少内存的占用，让测试跑得更快更顺畅。</li>
<li><strong>避免耗时操作</strong>：有些操作就像蜗牛爬行一样慢，比如在脚本里进行超级复杂的数学计算，或者对大量的数据进行排序，这会让单个线程的执行时间变得很长，就像堵车一样，影响整个测试的效率。要是真的需要做这些操作，可以想想办法优化一下，或者用异步的方式来处理，就像给慢车开辟一条专用车道，让其他车辆（线程）能继续快速行驶，这样就能提高测试的并发性能，让测试更快地完成。</li>
</ul>
</li>
<li>
<p><strong>安全性考虑</strong></p>
<ul>
<li><strong>避免执行恶意代码</strong>：因为 JSR223 Sampler 可以执行咱们写的代码，所以一定要小心，别让坏家伙把恶意代码偷偷塞进来，不然测试就会像被施了混乱魔法一样，乱成一团糟。在使用从外部获取的脚本代码或者数据时，要像安检员一样，仔细地进行安全检查和过滤，确保没有危险的指令或者操作，比如防止有人偷偷写了删除重要文件或者执行系统命令的代码。同时，要给脚本的执行权限戴上一个 “紧箍咒”，限制它对系统关键资源和文件的进行未经授权的访问，就像给一个调皮的孩子划定一个安全的活动范围，这样才能保证测试过程的安全稳定。</li>
<li><strong>沙箱环境</strong>：有些脚本语言有沙箱环境，这就像是给代码建了一个安全的 “小牢房”，限制它的活动范围和权限。比如说 JavaScript，通过配置沙箱环境，可以防止恶意脚本通过浏览器的敏感 API 进行非法操作，就像给窗户装上防盗网，让坏人进不来。在 JMeter 中，咱们也可以利用类似的安全机制，对 JSR223 Sampler 执行的脚本进行安全隔离和权限控制，这样即使脚本里有一些小漏洞，也不会对整个系统造成太大的影响，就像给房子加了一道防火墙，让安全隐患无处可逃。</li>
</ul>
</li>
<li>
<p><strong>调试和错误处理</strong></p>
<ul>
<li><strong>调试支持</strong>：当脚本出现问题时，别着急，咱们有办法调试它！如果用的是支持调试功能的脚本语言，比如 Groovy，就可以在专门的编程软件（像 IntelliJ IDEA、Eclipse 等）里设置断点，这就像在代码的路上设置了一些小陷阱。然后通过远程调试的方式连接到 JMeter 中正在执行的脚本，这样就能像一个侦探一样，一步步跟踪代码的执行过程，查看变量的值有没有问题，程序是不是按照咱们预想的路线在走，从而快速找到问题的根源，把它解决掉。同时，也可以在脚本里多用 “log” 对象输出一些调试信息，就像在路上留下一些标记，方便咱们了解脚本的执行情况，找到问题所在。</li>
<li><strong>错误处理</strong>：在脚本里，难免会出现一些意外情况，这时候就要学会处理错误，别让一个小错误导致整个测试 “翻车”。可以用 try-catch 语句块来抓住这些错误，就像用一个小网子把乱跑的小虫子（错误）抓住。比如说：</li>
</ul>
</li>
</ol>
<pre><code class="language-groovy">try {
    // 这里是可能会出错的代码，比如调用一个可能不存在的函数
    def result = someFunctionThatMightThrowException()
} catch (Exception e) {
    log.error("哎呀，出问题啦：" + e.getMessage())
    // 在这里可以进行一些错误处理操作，比如告诉其他采样器这个步骤出错了，或者记录下错误的详细信息，方便后续分析
    vars.put("errorFlag", "true")
}
</code></pre>
<p>这样，即使出现了错误，测试也能继续进行下去，而且咱们还能清楚地知道哪里出了问题，怎么去解决它。</p>
<ol start="8">
<li>
<p><strong>脚本语言选择</strong></p>
<ul>
<li><strong>语言特性</strong>：不同的脚本语言就像不同性格的小伙伴，各有各的特点和优势。Groovy 语言和 Java 是好兄弟，语法简洁灵活，写起来很顺手，还能轻松借用 Java 的强大功能；JavaScript 在前端的世界里可是个 “大明星”，有很多厉害的函数式编程技巧和丰富的库资源，特别适合处理和前端交互相关的逻辑；Python 呢，就像一个聪明的数学家，语法简单易懂，在数据处理和科学计算方面超级厉害，能快速地对大量的数据进行分析和处理。所以，在选择脚本语言时，要根据测试的具体需求和场景，像挑选合适的工具一样，选择最适合的语言来实现测试逻辑，让测试事半功倍。</li>
<li><strong>社区和资源</strong>：一个活跃的社区和丰富的资源就像一个强大的后盾，能给我们提供很多帮助。比如说 Python，它有一个超级庞大的开源社区，不管遇到什么问题，几乎都能在社区里找到答案，还有各种各样的第三方库，就像一个装满了各种神奇工具的宝库，能满足你几乎所有的需求。JavaScript 也不示弱，在前端开发领域有大量的开源框架和工具，随便一搜就能找到很多好用的东西。Groovy 虽然社区规模相对小一点，但因为和 Java 关系好，也能沾 Java 的光，利用 Java 的丰富生态系统来获取所需的资源和支持。所以，在选择脚本语言时，考虑一下它的社区活跃度和资源丰富程度，就像找一个有很多朋友帮忙的小伙伴一起做事情，能让脚本开发更加顺利，遇到问题也能更快地解决。</li>
</ul>
</li>
<li>
<p><strong>集成第三方库</strong></p>
<ul>
<li><strong>第三方库支持</strong>：有时候，为了完成一些特殊的任务，咱们可能需要借助第三方库的力量。比如说，要对一些敏感数据进行加密，或者和一些特定的外部系统进行复杂的交互，这时候就可以去找对应的第三方库来帮忙。以 Groovy 为例，如果要使用一个名为 “SomeLibrary” 的第三方库，首先要把这个库的.jar 文件放到 JMeter 的 “lib” 目录下（或者 “lib/ext” 目录，具体要看库的类型和 JMeter 的版本），然后在脚本里就可以用 “@Grab” 注解或者手动导入库的方式来使用里面的类和方法，就像把一个新的魔法工具放进咱们的魔法箱里，然后拿出来使用。比如：</li>
</ul>
</li>
</ol>
<pre><code class="language-groovy">// 用 @Grab 注解导入第三方库（前提是要有相应的依赖解析机制，比如 Grape）
@Grab('group:artifact:version')
import com.example.SomeLibraryClass

// 或者手动导入库（假设已经把库放到正确的目录下了）
import com.example.SomeLibraryClass

def someObject = new SomeLibraryClass()
// 然后就可以用这个库的方法来做一些厉害的事情啦，比如加密数据
someObject.someMethod()
</code></pre>
<p>对于 JavaScript，可以通过<code>&lt;script&gt;</code>标签引入外部的.js 文件，这样就能使用里面定义的函数和变量；Python 则可以用 “import” 语句导入已经安装好的第三方库模块。不过，在集成第三方库的时候，要注意库的版本兼容性，就像给机器换零件要找合适的型号一样，还要确保它和 JMeter 环境能和谐相处，避免因为库的引入而出现冲突或者性能问题，让测试顺利进行。</p>
<ol start="10">
<li><strong>性能监控</strong>
<ul>
<li>
<p><strong>监控脚本执行时间</strong>：在测试过程中，咱们要时刻关注 JSR223 Sampler 脚本的执行时间，这就像关注一场比赛的选手跑步速度一样重要。可以在脚本的开头和结尾记录时间戳，就像在比赛的起点和终点放两个计时器，然后计算它们的差值，就能知道脚本跑一次花了多长时间。如果发现某个脚本执行时间太长，就像选手跑得太慢一样，那可能就需要找找原因，是不是代码里有什么地方写得不好，让它跑得这么吃力，然后针对性地进行优化，让测试效率更高。</p>
</li>
<li>
<h3 id="资源使用监控">资源使用监控</h3>
<p>除了关注执行时间，还要留意脚本运行时对系统资源的使用情况，毕竟这就如同观察一辆车在路上跑，不仅要看它的速度，还得留意它耗了多少油、发动机温度高不高之类的情况，这样才能全面掌握其性能表现呀。以下是具体可以关注以及如何去监控的方面：</p>
</li>
<li>
<h3 id="cpu-使用率监控">CPU 使用率监控</h3>
<p>在性能测试过程中，脚本执行时如果占用 CPU 过高，可能会拖慢整个系统的运行速度，影响其他测试任务或者正常的系统业务。</p>
<ul>
<li>
<p><strong>利用 JMeter 插件（如 PerfMon Metrics Collector）</strong>：</p>
<ul>
<li>首先要安装相应的插件，把下载好的插件 JAR 文件放置在 JMeter 的 “lib/ext” 目录下，然后重启 JMeter。</li>
<li>在线程组或者测试计划的合适位置，右键点击并选择 “添加” -&gt; “监听器” -&gt; “jp@gc - PerfMon Metrics Collector” 来添加这个监听器。</li>
<li>在配置窗口里，在 “Host” 字段填写 JMeter 所在服务器（如果是本地测试就是本地的 IP 地址，比如 “127.0.0.1”），“Port” 字段按默认或者根据实际情况填写（一般保持默认即可），然后勾选 “CPU” 选项，设置好采样间隔时间（比如设置为每 5 秒收集一次数据）。这样在测试运行时，就能实时收集到 JMeter 以及执行 JSR223 Sampler 脚本时的 CPU 使用率情况了。</li>
<li>测试结束后，查看收集到的数据图表或者报表，分析在脚本执行期间 CPU 使用率的变化趋势。如果发现某个时间段内 CPU 使用率飙升，而对应的正是 JSR223 Sampler 脚本执行关键逻辑的时候，那就得仔细检查脚本里是不是存在大量复杂计算、循环嵌套过深等情况，这些都可能导致 CPU 资源被过度占用，进而需要针对性地优化代码逻辑，比如简化计算过程、优化循环条件等。</li>
</ul>
</li>
<li>
<p><strong>通过操作系统自带工具（以 Windows 和 Linux 为例）</strong>：</p>
<ul>
<li><strong>Windows 系统</strong>：可以打开 “任务管理器”（通过快捷键 Ctrl + Shift + Esc 快速打开），切换到 “性能” 选项卡，查看 CPU 使用率的总体情况，然后在 “详细信息” 选项卡里找到 JMeter 对应的进程（一般是 “jmeter.bat” 启动后的进程名），观察其 CPU 使用率的实时数据。在执行性能测试时，留意 JSR223 Sampler 相关脚本运行期间这个使用率的变化，要是使用率长时间居高不下，就需要排查脚本问题了。</li>
<li><strong>Linux 系统</strong>：使用像 “top” 命令，在命令行输入 “top” 后回车，就能看到各个进程的 CPU 使用率等相关信息，按下 “Shift + P” 可以按照 CPU 使用率进行排序，方便找到 JMeter 进程查看其 CPU 资源占用情况。或者使用 “htop” 命令（如果服务器安装了 htop 工具的话，它展示的信息会更直观、交互性更好），同样关注在 JSR223 Sampler 脚本执行时 JMeter 进程的 CPU 使用表现，根据情况分析脚本是否存在性能隐患。</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="内存使用监控">内存使用监控</h4>
<p>脚本运行时不合理的内存占用可能会导致内存溢出等问题，让测试无法正常进行下去，所以监控内存使用也是很关键的一环。</p>
<ul>
<li>
<p><strong>借助 JMeter 插件（同样以 PerfMon Metrics Collector 为例）</strong>：和监控 CPU 使用率时类似，在添加好 “jp@gc - PerfMon Metrics Collector” 监听器后，在配置窗口勾选 “Memory” 选项，就能在测试过程中收集 JMeter 运行时内存使用的数据了，包括堆内存、非堆内存等方面的使用量情况。测试结束后，通过查看收集到的数据，分析 JSR223 Sampler 脚本执行过程中内存占用量的变化。要是发现内存使用量一直在持续上升，没有回落的趋势，那很可能脚本里存在内存泄漏问题，比如创建了大量对象却没有及时释放，这时候就需要仔细检查代码中对象的创建和销毁逻辑，看看是否有地方忘记关闭资源、清理对象了，像文件流没有关闭、集合对象使用完后没有清空等情况都可能导致内存泄漏，要及时修正代码来优化内存使用。</p>
</li>
<li>
<p><strong>使用 JVM 自带的监控参数（适用于了解更底层的内存情况）</strong>：可以在启动 JMeter 时添加一些 JVM 参数来输出内存相关的信息。比如添加 “-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”，这样 JVM 在运行过程中进行垃圾回收（GC）操作时，就会把详细的 GC 信息打印出来，并存放到 “gc.log” 文件里（文件名可以根据自己的需求修改）。通过查看这个日志文件，可以了解到内存回收的频率、每次回收的内存大小等情况，进而推断出 JSR223 Sampler 脚本对内存的影响。如果发现 GC 过于频繁或者每次回收的内存量很大，那往往意味着脚本里内存管理存在问题，需要进一步排查代码中涉及内存操作的部分进行优化。</p>
</li>
</ul>
</li>
<li>
<h4 id="磁盘-io-监控">磁盘 I/O 监控</h4>
<p>当脚本涉及到读写文件等操作时，磁盘 I/O 的性能就会影响整体的执行效率，要是磁盘读写速度太慢，也会让脚本运行得磕磕绊绊的。</p>
<ul>
<li>
<p><strong>使用 JMeter 插件（如 PerfMon Metrics Collector）</strong>：在配置该监听器时，勾选 “Disk I/O” 相关的选项（比如磁盘读写速度、磁盘队列长度等指标，根据实际需求选择），然后设置好采样间隔等参数，就能收集磁盘 I/O 方面的数据了。在测试运行过程中，如果发现磁盘读写速度一直很低，或者磁盘队列长度经常很长，那就得看看脚本里对文件的读写操作是不是过于频繁、每次读写的数据量是不是过大等情况，可能需要优化文件读写的逻辑，比如采用缓冲流来提高读写效率、合理控制读写的频率和数据量等，以此来改善磁盘 I/O 的性能，让脚本运行得更顺畅。</p>
</li>
<li>
<p><strong>借助操作系统自带工具</strong>：</p>
</li>
<li>
<p><strong>Windows 系统</strong>：可以通过 “资源监视器”（在 “任务管理器” 里点击 “性能” 选项卡，再点击下方的 “打开资源监视器” 链接即可进入），在 “磁盘” 选项卡里查看各个进程的磁盘读写速度、活动时间等指标，找到 JMeter 对应的进程，观察在 JSR223 Sampler 脚本执行时磁盘 I/O 的情况，分析是否存在性能瓶颈。</p>
</li>
<li>
<p><strong>Linux 系统</strong>：使用像 “iostat” 命令，输入 “iostat -x 1”（后面的 “1” 表示每隔 1 秒输出一次数据）可以查看磁盘的详细 I/O 统计信息，包括每秒读写次数、每秒读写的数据量、平均等待时间等，通过观察这些数据判断 JMeter 在执行相关脚本时磁盘 I/O 是否正常，若不正常则针对性地优化脚本里涉及磁盘操作的部分。</p>
</li>
</ul>
</li>
<li>
<h4 id="网络资源监控">网络资源监控</h4>
<p>要是 JSR223 Sampler 脚本涉及到网络请求，比如调用外部 API、与数据库等进行网络交互，那网络资源的使用情况也不容忽视呀，网络太慢的话，整个脚本执行都会被拖后腿呢。</p>
<ul>
<li>
<p><strong>通过 JMeter 插件（如 PerfMon Metrics Collector）</strong>：配置该监听器时勾选 “Network” 相关的选项，例如网络带宽使用率、网络延迟等指标，设置好采样间隔后启动测试，就能收集到网络资源使用的数据了。查看收集的数据，如果发现网络带宽使用率长时间接近饱和，或者网络延迟过高，那就得检查脚本里的网络请求部分了，比如是不是同时发起了过多的网络请求，导致网络拥堵了，或者网络请求的超时设置不合理等情况，需要对网络请求的逻辑进行调整优化，比如合理控制并发网络请求的数量、优化网络请求的重试机制和超时时间设置等，来提升网络资源的利用效率，保障脚本顺利执行。</p>
</li>
<li>
<p><strong>使用网络分析工具（如 Wireshark 等，适用于更深入的网络分析）</strong>：在测试所在的服务器或者客户端机器上安装并启动 Wireshark 等网络抓包工具，设置好过滤条件（比如只抓取 JMeter 相关进程的网络数据包，通过指定进程对应的端口或者 IP 等信息来过滤），然后在执行性能测试时，它就能捕获到 JSR223 Sampler 脚本执行网络请求时的详细数据包信息，分析网络传输过程中是否存在丢包、重传等异常情况，根据分析结果来优化脚本里的网络交互逻辑，让网络通信更加顺畅高效。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过对这些系统资源使用情况的全面监控，咱们就能更清楚地知道 JSR223 Sampler 脚本在执行过程中的性能表现啦，一旦发现哪个资源方面存在问题，就可以精准地找到脚本里对应的 “病根”，然后对症下药进行优化，让咱们的性能测试更加准确、高效地完成呀。</p>
<p>总之呢，性能监控是个细致活，需要咱们多方面去关注、多维度去分析，这样才能充分发挥 JSR223 Sampler 在性能测试中的强大作用哦，宝子们可得用心去做呀。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02625926931712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-02 10:07">2025-01-02 10:07</span>&nbsp;
<a href="https://www.cnblogs.com/geekzone">云简</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628805" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628805);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628805', targetLink: 'https://www.cnblogs.com/geekzone/p/18628805', title: 'JMeter JSR223 Sampler 教程：性能测试的魔法棒' })">举报</a>
</div>
        