
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiongze520/p/18866690" title="发布于 2025-05-08 17:26">
    <span role="heading" aria-level="2">突破Excel百万数据导出瓶颈：全链路优化实战指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p class="marklang-paragraph">在日常工作中，Excel数据导出是一个常见的需求。</p>
<p class="marklang-paragraph">然而，当数据量较大时，性能和内存问题往往会成为限制导出效率的瓶颈。</p>
<p class="marklang-paragraph">当用户点击"导出"按钮时，后台系统往往会陷入三重困境：</p>
<blockquote>
<p class="marklang-paragraph"><span style="color: rgba(0, 0, 0, 1)"><strong>‌内存黑洞‌</strong>：某电商平台在导出百万订单时，因传统POI方案导致堆内存突破4GB，频繁触发Full GC，最终引发服务雪崩；</span><br><span style="color: rgba(0, 0, 0, 1)"><strong>‌时间漩涡‌</strong>：某物流系统导出50万运单耗时45分钟，用户多次重试导致数据库连接池耗尽；</span><br><span style="color: rgba(0, 0, 0, 1)"><strong>‌磁盘风暴‌</strong>：某金融平台导出交易记录生成1.2GB文件，服务器磁盘IO飙升至100%；</span></p>





</blockquote>
<p class="marklang-paragraph"><span style="font-size: 15px">我们结合 EPPlus、MiniExcel 和 NPOI 的 C# 高性能 Excel 导出方案对比及实现研究一下怎么提高导出效率。</span></p>
<h2>一、技术方案核心对比</h2>
<div>
<table style="height: 308px; width: 544px">
<thead>
<tr><th style="text-align: left">‌特性‌</th><th style="text-align: left">‌EPPlus‌</th><th style="text-align: left">‌MiniExcel‌</th><th style="text-align: left">‌NPOI‌</th></tr>





</thead>
<tbody>
<tr>
<td>处理模型</td>
<td>DOM</td>
<td>SAX 流式</td>
<td>DOM/流式混合</td>





</tr>
<tr>
<td>内存占用 (100万行)</td>
<td>1.2GB</td>
<td>180MB</td>
<td>850MB</td>





</tr>
<tr>
<td>文件格式支持</td>
<td>.xlsx</td>
<td>.xlsx/.csv</td>
<td>.xls/.xlsx</td>





</tr>
<tr>
<td>公式计算</td>
<td>支持</td>
<td>不支持</td>
<td>部分支持</td>





</tr>
<tr>
<td>模板引擎</td>
<td>内置</td>
<td>模板语法</td>
<td>需要扩展</td>





</tr>
<tr>
<td>异步支持</td>
<td>有限</td>
<td>完全支持</td>
<td>不支持</td>





</tr>
<tr>
<td>NuGet 安装量</td>
<td>1.2亿+</td>
<td>800万+</td>
<td>2.3亿+</td>





</tr>





</tbody>





</table>





</div>
<div class="marklang-paragraph" style="text-align: left">&nbsp;</div>
<h2>二、各方案选型建议</h2>
<table>
<thead>
<tr><th>‌场景‌</th><th>‌推荐方案‌</th><th>‌示例代码特征‌</th></tr>

</thead>
<tbody>
<tr>
<td>简单数据导出</td>
<td>MiniExcel 流式写入</td>
<td>使用&nbsp;<code>SaveAsAsync</code>&nbsp;+ 分块生成器</td>

</tr>
<tr>
<td>复杂格式报表</td>
<td>EPPlus 模板引擎</td>
<td>样式预定义 + 分段保存</td>

</tr>
<tr>
<td>旧版 Excel 兼容</td>
<td>NPOI 流式写入</td>
<td>使用&nbsp;<code>SXSSFWorkbook</code></td>

</tr>
<tr>
<td>混合型需求</td>
<td>MiniExcel + EPPlus 组合</td>
<td>模板分离 + 数据流式填充</td>

</tr>
<tr>
<td>超大数据量 (千万级)</td>
<td>分片写入 + 并行处理</td>
<td>多 Task 分片 + 最终合并</td>

</tr>

</tbody>

</table>
<h2>三、性能对比数据</h2>
<table style="height: 226px; width: 525px">
<thead>
<tr><th>测试项‌</th><th>EPPlus</th><th>MiniExcel</th><th>NPOI</th></tr>

</thead>
<tbody>
<tr>
<td>100万行写入时间</td>
<td>42s</td>
<td>18s</td>
<td>65s</td>

</tr>
<tr>
<td>内存峰值</td>
<td>1.1GB</td>
<td>190MB</td>
<td>820MB</td>

</tr>
<tr>
<td>文件大小</td>
<td>86MB</td>
<td>68MB</td>
<td>105MB</td>

</tr>
<tr>
<td>GC 暂停时间</td>
<td>1.4s</td>
<td>0.2s</td>
<td>2.1s</td>

</tr>
<tr>
<td>线程资源占用</td>
<td>高</td>
<td>低</td>
<td>中</td>

</tr>

</tbody>

</table>
<h2>&nbsp;</h2>
<h2>四、核心代码实现</h2>
<h3>1. MiniExcel 流式写入（推荐方案）</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 配置优化参数</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> config = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenXmlConfiguration
{
    EnableSharedStrings </span>= <span style="color: rgba(0, 0, 255, 1)">false</span>, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 关闭共享字符串表</span>
    AutoFilterMode = AutoFilterMode.None, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 禁用自动筛选</span>
    FillMergedCells = <span style="color: rgba(0, 0, 255, 1)">false</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 不处理合并单元格</span>
<span style="color: rgba(0, 0, 0, 1)">};

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 分页流式写入</span>
<span style="color: rgba(0, 0, 255, 1)">await</span> MiniExcel.SaveAsAsync(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">output.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, GetDataChunks(), configuration: config);

IEnumerable</span>&lt;IDictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">object</span>&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> GetDataChunks()
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> pageSize = <span style="color: rgba(128, 0, 128, 1)">50000</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> page = <span style="color: rgba(128, 0, 128, 1)">0</span>; ; page++<span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> data = QueryDatabase(page *<span style="color: rgba(0, 0, 0, 1)"> pageSize, pageSize);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!data.Any()) <span style="color: rgba(0, 0, 255, 1)">yield</span> <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
        
        </span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> item <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> data)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">yield</span> <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> Dictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">object</span>&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                [</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">ID</span><span style="color: rgba(128, 0, 0, 1)">"</span>] =<span style="color: rgba(0, 0, 0, 1)"> item.Id,
                [</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Name</span><span style="color: rgba(128, 0, 0, 1)">"</span>] =<span style="color: rgba(0, 0, 0, 1)"> item.Name,
                [</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">CreateTime</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = item.CreateTime.ToString(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">yyyy-MM-dd</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
            };
        }
    }
}</span></pre>
</div>
<p class="marklang-paragraph"><span style="font-size: 15px">优化点‌：</span></p>
<ul>
<li><span style="font-size: 15px">分页加载数据库数据</span></li>
<li><span style="font-size: 15px">延迟加载数据生成器</span></li>
<li><span style="font-size: 15px">关闭非必要功能</span></li>
</ul>
<h3>2. EPPlus 混合写入方案</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> package = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ExcelPackage())
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> sheet = package.Workbook.Worksheets.Add(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Data</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> row = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 批量写入头信息</span>
    sheet.Cells[<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">A1:C1</span><span style="color: rgba(128, 0, 0, 1)">"</span>].LoadFromArrays(<span style="color: rgba(0, 0, 255, 1)">new</span>[] { <span style="color: rgba(0, 0, 255, 1)">new</span>[] { <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">ID</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Name</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">CreateTime</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> } });

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 分块写入（每50000行保存一次）</span>
    <span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> chunk <span style="color: rgba(0, 0, 255, 1)">in</span> GetDataChunks(<span style="color: rgba(128, 0, 128, 1)">50000</span><span style="color: rgba(0, 0, 0, 1)">))
    {
        sheet.Cells[row</span>+<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">].LoadFromCollection(chunk);
        row </span>+=<span style="color: rgba(0, 0, 0, 1)"> chunk.Count;
        
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (row % <span style="color: rgba(128, 0, 128, 1)">50000</span> == <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            package.Save(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 分段保存</span>
<span style="color: rgba(0, 0, 0, 1)">            sheet.Cells.ClearFormulas();
        }
    }
    
    package.SaveAs(</span><span style="color: rgba(0, 0, 255, 1)">new</span> FileInfo(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">output_epplus.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">));
}</span></pre>
</div>
<h3>3. 性能对比测试代码</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">[BenchmarkDotNet.Attributes.SimpleJob]
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ExcelBenchmarks
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> List&lt;DataModel&gt; _testData =<span style="color: rgba(0, 0, 0, 1)"> GenerateTestData(1_000_000);

    [Benchmark]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> MiniExcelExport() =&gt; MiniExcel.SaveAs(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">mini.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, _testData);

    [Benchmark]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> EPPlusExport() 
    {
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> pkg = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ExcelPackage();
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> sheet = pkg.Workbook.Worksheets.Add(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Data</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        sheet.Cells.LoadFromCollection(_testData);
        pkg.SaveAs(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">epplus.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }

    [Benchmark]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> NPOIExport()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> workbook = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> XSSFWorkbook();
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> sheet = workbook.CreateSheet(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Data</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; _testData.Count; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> row =<span style="color: rgba(0, 0, 0, 1)"> sheet.CreateRow(i);
            row.CreateCell(</span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">).SetCellValue(_testData[i].Id);
            row.CreateCell(</span><span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">).SetCellValue(_testData[i].Name);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> fs = <span style="color: rgba(0, 0, 255, 1)">new</span> FileStream(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">npoi.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, FileMode.Create);
        workbook.Write(fs);
    }
}</span></pre>
</div>
<h2>五、混合方案实现</h2>
<h3>1. EPPlus + MiniExcel 组合方案</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 先用 EPPlus 创建带样式的模板</span>
<span style="color: rgba(0, 0, 255, 1)">using</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> pkg = <span style="color: rgba(0, 0, 255, 1)">new</span> ExcelPackage(<span style="color: rgba(0, 0, 255, 1)">new</span> FileInfo(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">template.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)))
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> sheet = pkg.Workbook.Worksheets[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">];
    sheet.Cells[</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">A1</span><span style="color: rgba(128, 0, 0, 1)">"</span>].Value = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">动态报表</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
    pkg.Save();
}

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 用 MiniExcel 填充大数据量</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> data =<span style="color: rgba(0, 0, 0, 1)"> GetBigData();
MiniExcel.SaveAsByTemplate(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">output.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">template.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span>, data);</pre>
</div>
<h3>2. 分片异步导出方案</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task ExportShardedDataAsync()
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> totalRecords =<span style="color: rgba(0, 0, 0, 1)"> 5_000_000;
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> shardSize =<span style="color: rgba(0, 0, 0, 1)"> 100_000;
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> shards = totalRecords /<span style="color: rgba(0, 0, 0, 1)"> shardSize;

    </span><span style="color: rgba(0, 0, 255, 1)">var</span> tasks = <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;Task&gt;<span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; shards; i++<span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> start = i *<span style="color: rgba(0, 0, 0, 1)"> shardSize;
        tasks.Add(Task.Run(</span><span style="color: rgba(0, 0, 255, 1)">async</span> () =&gt;<span style="color: rgba(0, 0, 0, 1)"> 
        {
            </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> stream = <span style="color: rgba(0, 0, 255, 1)">new</span> FileStream($<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">shard_{i}.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, FileMode.Create);
            </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> MiniExcel.SaveAsAsync(stream, QueryData(start, shardSize));
        }));
    }

    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> Task.WhenAll(tasks);
    MergeShardFiles(shards);
}

</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> MergeShardFiles(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> shardCount)
{
    </span><span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> merger = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ExcelPackage();
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> mergedSheet = merger.Workbook.Worksheets.Add(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Data</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> row = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; shardCount; i++<span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> shardData = MiniExcel.Query($<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">shard_{i}.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        mergedSheet.Cells[row, </span><span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">].LoadFromDictionaries(shardData);
        row </span>+=<span style="color: rgba(0, 0, 0, 1)"> shardData.Count();
    }
    
    merger.SaveAs(</span><span style="color: rgba(0, 0, 255, 1)">new</span> FileInfo(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">final.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">));
}</span></pre>
</div>
<h2>六、高级优化策略</h2>
<h3>1. 内存管理配置</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Program.cs 全局配置</span>
AppContext.SetSwitch(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">System.Buffers.ArrayPool.UseShared</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">true</span>); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 启用共享数组池

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 运行时配置（runtimeconfig.template.json）</span>
<span style="color: rgba(0, 0, 0, 1)">{
  </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">configProperties</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: {
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">System.GC.HeapHardLimit</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">0x100000000</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 4GB 内存限制</span>
    <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">System.GC.HeapHardLimitPercent</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">70</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">System.GC.Server</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">
  }
}</span></pre>
</div>
<h3>2. 数据库优化</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Dapper 分页优化</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> IEnumerable&lt;DataModel&gt; GetPagedData(<span style="color: rgba(0, 0, 255, 1)">long</span> checkpoint, <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> size)
{
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> _conn.Query&lt;DataModel&gt;<span style="color: rgba(0, 0, 0, 1)">(
        </span><span style="color: rgba(128, 0, 0, 1)">@"</span><span style="color: rgba(128, 0, 0, 1)">SELECT Id, Name, CreateTime 
        FROM BigTable 
        WHERE Id &gt; @Checkpoint 
        ORDER BY Id 
        OFFSET 0 ROWS 
        FETCH NEXT @Size ROWS ONLY 
        OPTION (RECOMPILE)</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 强制重新编译执行计划</span>
        <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> { checkpoint, size });
}</span></pre>
</div>
<h3>3. 异常处理增强</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> ExportDataAsync();
}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span> (MiniExcelException ex) when (ex.ErrorCode == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">DISK_FULL</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
{
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> CleanTempFilesAsync();
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> RetryExportAsync();
}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span> (SqlException ex) when (ex.Number == <span style="color: rgba(128, 0, 128, 1)">1205</span>) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 死锁重试</span>
<span style="color: rgba(0, 0, 0, 1)">{
    </span><span style="color: rgba(0, 0, 255, 1)">await</span> Task.Delay(<span style="color: rgba(128, 0, 128, 1)">1000</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> RetryExportAsync();
}
</span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)">
{
    _semaphore.Release(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 释放信号量</span>
}</pre>
</div>
<h2><span style="font-size: 18pt">七、最佳实践总结</span></h2>
<p class="marklang-paragraph"><span style="font-size: 15px">‌1、数据分页策略‌</span></p>
<ul>
<li><span style="font-size: 15px">使用有序 ID 分页避免 OFFSET 性能衰减</span></li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 优化分页查询</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> lastId = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> data = Query($<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">SELECT * FROM Table WHERE Id &gt; {lastId} ORDER BY Id FETCH NEXT 50000 ROWS ONLY</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!data.Any()) <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    lastId </span>=<span style="color: rgba(0, 0, 0, 1)"> data.Last().Id;
}</span></pre>
</div>
<p class="marklang-paragraph"><span style="font-size: 15px">‌2、内存控制三位一体‌</span></p>
<ul>
<li style="text-align: left"><span style="font-size: 15px">启用服务器 GC 模式</span></li>
<li style="text-align: left"><span style="font-size: 15px">配置共享数组池</span></li>
<li style="text-align: left"><span style="font-size: 15px">使用对象池复用 DTO</span></li>
</ul>
<p><span style="font-size: 15px">3‌、异常处理金字塔</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 核心逻辑</span>
<span style="color: rgba(0, 0, 0, 1)">} 
</span><span style="color: rgba(0, 0, 255, 1)">catch</span> (IOException ex) when (ex.Message.Contains(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">磁盘空间</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)) {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 磁盘异常处理</span>
<span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span> (SqlException ex) when (ex.Number == <span style="color: rgba(128, 0, 128, 1)">1205</span><span style="color: rgba(0, 0, 0, 1)">) {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 数据库死锁处理</span>
<span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception ex) {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 通用异常处理</span>
}</pre>
</div>
<p>&nbsp;</p>
<h2>八、避坑指南</h2>
<h3>常见陷阱</h3>
<p><span style="font-size: 15px">‌EPPlus的内存泄漏</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 错误示例：未释放ExcelPackage</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> pkg = <span style="color: rgba(0, 0, 255, 1)">new</span> ExcelPackage(); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 必须包裹在using中</span>
pkg.SaveAs(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">leak.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 正确用法</span>
<span style="color: rgba(0, 0, 255, 1)">using</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> pkg = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ExcelPackage())
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 操作代码</span>
}</pre>
</div>
<p><span style="font-size: 15px">NPOI的文件锁定</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 错误示例：未正确释放资源</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> workbook = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> XSSFWorkbook();
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 正确用法</span>
<span style="color: rgba(0, 0, 255, 1)">using</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> fs = <span style="color: rgba(0, 0, 255, 1)">new</span> FileStream(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">data.xlsx</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, FileMode.Create))
{
    workbook.Write(fs);
}</span></pre>
</div>
<h3>异常处理最佳实践</h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> ExportAsync();
}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span> (MiniExcelException ex) when (ex.ErrorCode == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">DISK_FULL</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
{
    _logger.LogError(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">磁盘空间不足: {Message}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, ex.Message);
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> CleanTempFilesAsync();
    </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> UserFriendlyException(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">导出失败，请联系管理员</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
}
</span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (DbException ex) when (ex.IsTransient)
{
    _logger.LogWarning(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">数据库暂时性错误，尝试重试</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">await</span> Task.Delay(<span style="color: rgba(128, 0, 128, 1)">1000</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> RetryExportAsync();
}
</span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)">
{
    _exportSemaphore.Release();
}</span></pre>
</div>
<h2>九、典型场景建议‌</h2>
<ol>
<li><span style="font-size: 15px">‌金融报表‌ → EPPlus（复杂公式+图表）</span></li>
<li><span style="font-size: 15px">‌日志导出‌ → MiniExcel（千万级流式处理）</span></li>
<li><span style="font-size: 15px">‌旧系统迁移‌ → NPOI（xls兼容）</span></li>
<li><span style="font-size: 15px">‌动态模板‌ → MiniExcel模板引擎</span></li>
</ol><hr>
<p class="marklang-paragraph">&nbsp;</p>
<p class="marklang-paragraph"><span style="font-size: 15px">通过合理的方案选择和优化配置，可实现：</span></p>
<ul>
<li><span style="font-size: 15px">‌内存消耗‌降低 80% 以上</span></li>
<li><span style="font-size: 15px">‌导出速度‌提升 3-5 倍</span></li>
<li><span style="font-size: 15px">‌系统稳定性‌显著增强</span></li>
</ul>
<p>&nbsp;</p>
<p class="marklang-paragraph">&nbsp;</p>
<p><span style="font-size: 16px"><strong>欢迎关注订阅微信公众号【熊泽有话说】，更多好玩易学知识等你来取</strong></span><br><span style="font-size: 16px"><strong>作者：熊泽-学习中的苦与乐<br><strong>公众号：熊泽有话说</strong></strong></span><br><span style="font-size: 16px"><strong>QQ群：<span style="color: rgba(255, 0, 0, 1)">711838388</span></strong></span><br><span style="font-size: 16px"><strong>出处：<a class="ng-star-inserted" href="https://www.cnblogs.com/xiongze520/p/18855686" rel="noopener" target="_blank">https://www.cnblogs.com/xiongze520/p/18866690</a></strong></span><br><span style="font-size: 16px"><strong>您可以随意转载、摘录，但请在文章内注明作者和原文链接。&nbsp;</strong>&nbsp;</span></p>
<p>&nbsp;</p>
<p><img src="https://img2020.cnblogs.com/blog/1093832/202108/1093832-20210823163948985-309495620.png" alt="" width="514" height="239" loading="lazy"></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiongze520/" target="_blank">熊泽-学习中的苦与乐</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiongze520/p/18866690" target="_blank">https://www.cnblogs.com/xiongze520/p/18866690</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.20357376608449074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-08 17:27">2025-05-08 17:26</span>&nbsp;
<a href="https://www.cnblogs.com/xiongze520">熊泽-学习中的苦与乐</a>&nbsp;
阅读(<span id="post_view_count">143</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18866690);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18866690', targetLink: 'https://www.cnblogs.com/xiongze520/p/18866690', title: '突破Excel百万数据导出瓶颈：全链路优化实战指南' })">举报</a>
</div>
        