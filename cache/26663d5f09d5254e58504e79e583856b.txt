<!----> <meta itemprop="headline" content="从前端的角度出发，目前最具性价比的全栈路线是啥❓❓❓"> <meta itemprop="keywords" content="前端,后端,JavaScript"> <meta itemprop="datePublished" content="2024-12-23T09:03:37.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Moment"> <meta itemprop="url" content="https://juejin.cn/user/3782764966460398"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            从前端的角度出发，目前最具性价比的全栈路线是啥❓❓❓
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/3782764966460398/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Moment
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-12-23T09:03:37.000Z" title="Mon Dec 23 2024 09:03:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-12-23
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    22,542
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><p>今年大部分时间都是在编码上和写文章上，但是也不知道自己都学到了啥，那就写篇文章来盘点一下目前的技术栈吧，也作为下一年的参考目标，方便知道每一年都学了些啥。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b989b6f544d24e5b9aea05d2047ad085~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1739161900&amp;x-signature=R8xPyH4ogKUP23jgbQcuB24TB1g%3D" alt="20241223154451" loading="lazy"></p>
<h2 data-id="heading-0">我的技术栈</h2>
<p>首先我先来对整体的技术做一个简单的介绍吧，然后后面再对当前的一些技术进行细分吧。</p>
<p>React、Typescript、React Native、mysql、prisma、NestJs、Redis、前端工程化。</p>
<h3 data-id="heading-1">React</h3>
<p>React 这个框架我花的时间应该是比较多的了，在校期间已经读了一遍源码了，对这些原理已经基本了解了。在随着技术的继续深入，今年毕业后又重新开始阅读了一遍源码，对之前的认知有了更深一步的了解。</p>
<p>也写了比较多跟 React 相关的文章，包括设计模式，原理，配套生态的使用等等都有一些涉及。</p>
<p>在状态管理方面，redux，zustand 我都用过，尤其在 Zustand 的使用上，我特别喜欢 Zustand，它使得我能够快速实现全局状态管理，同时避免了传统 Redux 中繁琐的样板代码，且性能更优。也对 Zustand 有比较深入的了解，也对其源码有过研究。</p>
<h3 data-id="heading-2">NextJs</h3>
<p>Next.js 是一个基于 React 的现代 Web 开发框架，它为开发者提供了一系列强大的功能和工具，旨在优化应用的性能、提高开发效率，并简化部署流程。Next.js 支持多种渲染模式，包括服务器端渲染（SSR）、静态生成（SSG）和增量静态生成（ISR），使得开发者可以根据不同的需求选择合适的渲染方式，从而在提升页面加载速度的同时优化 SEO。</p>
<p>在路由管理方面，Next.js 采用了基于文件系统的路由机制，这意味着开发者只需通过创建文件和文件夹来自动生成页面路由，无需手动配置。这种约定优于配置的方式让路由管理变得直观且高效。此外，Next.js 提供了动态路由支持，使得开发者可以轻松实现复杂的 URL 结构和参数化路径。</p>
<p>Next.js 还内置了 API 路由，允许开发者在同一个项目中编写后端 API，而无需独立配置服务器。通过这种方式，前后端开发可以在同一个代码库中协作，大大简化了全栈开发流程。同时，Next.js 对 TypeScript 提供了原生支持，帮助开发者提高代码的可维护性和可靠性。</p>
<h3 data-id="heading-3">Typescript</h3>
<p>今年所有的项目都是在用 ts 写了，真的要频繁修改的项目就知道用 ts 好处了，有时候用 js 写的函数修改了都不知道怎么回事，而用了 ts 之后，哪里引用到的都报红了，修改真的非常方便。</p>
<p>今年花了一点时间深入学习了一下 Ts 类型，对一些高级类型以及其实现原理也基本知道了，明年还是多花点时间在类型体操上，除了算法之外，感觉类型体操也可以算得上是前端程序员的内功心法了。</p>
<h3 data-id="heading-4">React Native</h3>
<blockquote>
<p>不得不说，React Native 不愧是接活神器啊，刚学完之后就来了个安卓和 ios 的私活，虽然没有谈成。</p>
</blockquote>
<p>React Native 和 Expo 是构建跨平台移动应用的两大热门工具，它们都基于 React，但在功能、开发体验和配置方式上存在一些差异。React Native 是一个开放源代码的框架，允许开发者使用 JavaScript 和 React 来构建 iOS 和 Android 原生应用。Expo 则是一个构建在 React Native 之上的开发平台，它提供了一套工具和服务，旨在简化 React Native 开发过程。</p>
<p>React Native 的核心优势在于其高效的跨平台开发能力。通过使用 React 语法和组件，开发者能够一次编写应用的 UI 和逻辑，然后部署到 iOS 和 Android 平台。React Native 提供了对原生模块的访问，使开发者能够使用原生 API 来扩展应用的功能，确保性能和用户体验能够接近原生应用。</p>
<p>Expo 在此基础上进一步简化了开发流程。作为一个开发工具，Expo 提供了许多内置的 API 和组件，使得开发者无需在项目中进行繁琐的原生模块配置，就能够快速实现设备的硬件访问功能（如摄像头、位置、推送通知等）。Expo 还内置了一个开发客户端，使得开发者可以实时预览应用，无需每次都进行完整的构建和部署。</p>
<p>另外，Expo 提供了一个完全托管的构建服务，开发者只需将应用推送到 Expo 服务器，Expo 就会自动处理 iOS 和 Android 应用的构建和发布。这大大简化了应用的构建和发布流程，尤其适合不想处理复杂原生配置的开发者。</p>
<p>然而，React Native 和 Expo 也有各自的局限性。React Native 提供更大的灵活性和自由度，开发者可以更自由地集成原生代码或使用第三方原生库，但这也意味着需要更多的配置和维护。Expo 则封装了很多功能，简化了开发，但在需要使用某些特定原生功能时，开发者可能需要“弹出”Expo 的托管环境，进行额外的原生开发。</p>
<p>样式方案的话我使用的是 twrnc，大部分组件都是手撸，因为有 cursor 和 chatgpt 的加持，开发效果还是杠杠的。</p>
<p>rn 原理也争取明年能多花点时间去研究研究，不然对着盲盒开发还是不好玩。</p>
<h3 data-id="heading-5">Nestjs</h3>
<p>NestJs 的话没啥好说的，之前也都写过很多篇文章了，感兴趣的可以直接观看：</p>
<ul>
<li>
<p><a href="https://juejin.cn/post/7359821247680675892" target="_blank" title="https://juejin.cn/post/7359821247680675892">面试官：为什么选择学习 Nestjs，而不是 Express？🧐🧐🧐</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/7360528073631039499" target="_blank" title="https://juejin.cn/post/7360528073631039499">NestJS 的生命周期钩子以及它们在不同阶段的都适合做什么？</a></p>
</li>
</ul>
<p>对 Nodejs 的底层也有了比较深的理解了：</p>
<ul>
<li><a href="https://juejin.cn/post/7356450983838384137" target="_blank" title="https://juejin.cn/post/7356450983838384137">探究 CPU 密集型与 IO 密集型任务：提升对 Node.js 中 libuv 库的理解</a></li>
</ul>
<h3 data-id="heading-6">Prisma &amp; mysql</h3>
<p>Prisma 是一个现代化的 ORM（对象关系映射）工具，旨在简化数据库操作并提高开发效率。它支持 MySQL 等关系型数据库，并为 Node.js 提供了类型安全的数据库客户端。在 NestJS 中使用 Prisma，可以让开发者轻松定义数据库模型，并通过自动生成的 Prisma Client 执行类型安全的查询操作。与 MySQL 配合时，Prisma 提供了一种简单、直观的方式来操作数据库，而无需手动编写复杂的 SQL 查询。</p>
<p>Prisma 的核心优势在于其强大的类型安全功能，所有的数据库操作都能通过 Prisma Client 提供的自动生成的类型来进行，这大大减少了代码中的错误，提升了开发的效率。它还包含数据库迁移工具 Prisma Migrate，能够帮助开发者方便地管理数据库结构的变化。此外，Prisma Client 的查询 API 具有很好的性能，能够高效地执行复杂的数据库查询，支持包括关系查询、聚合查询等高级功能。</p>
<p>与传统的 ORM 相比，Prisma 使得数据库交互更加简洁且高效，减少了配置和手动操作的复杂性，特别适合在 NestJS 项目中使用，能够与 NestJS 提供的依赖注入和模块化架构很好地结合，提升整体开发体验。</p>
<h3 data-id="heading-7">Redis</h3>
<p>Redis 和 mysql 都仅仅是会用的阶段，目前都是直接在 NestJs 项目中使用，都是已经封装好了的，直接传参调用就好了：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">Inject</span>, <span class="hljs-title class_">OnModuleDestroy</span>, <span class="hljs-title class_">Logger</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Redis</span>, { <span class="hljs-title class_">ClientContext</span>, <span class="hljs-title class_">Result</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"ioredis"</span>;

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ObjectType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types"</span>;

<span class="hljs-keyword">import</span> { isObject } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/utils"</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnModuleDestroy</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>(<span class="hljs-title class_">RedisService</span>.<span class="hljs-property">name</span>);

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Inject</span>(<span class="hljs-string">"REDIS_CLIENT"</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> redisClient: Redis</span>) {}

  <span class="hljs-title function_">onModuleDestroy</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">disconnect</span>();
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 设置值到redis中
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">set</span>(
    <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>,
    second?: <span class="hljs-built_in">number</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Result</span>&lt;<span class="hljs-string">"OK"</span>, <span class="hljs-title class_">ClientContext</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> formattedValue = <span class="hljs-title function_">isObject</span>(value)
        ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value)
        : <span class="hljs-title class_">String</span>(value);

      <span class="hljs-keyword">if</span> (!second) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">set</span>(key, formattedValue);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">set</span>(key, formattedValue, <span class="hljs-string">"EX"</span>, second);
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error setting key <span class="hljs-subst">${key}</span> in Redis`</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 获取redis缓存中的值
   * <span class="hljs-doctag">@param</span> key {String}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">get</span>(key);

      <span class="hljs-keyword">return</span> data ? data : <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error getting key <span class="hljs-subst">${key}</span> from Redis`</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 设置自动 +1
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">incr</span>(
    <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Result</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">ClientContext</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">incr</span>(key);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error incrementing key <span class="hljs-subst">${key}</span> in Redis`</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 删除redis缓存数据
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">del</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Result</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">ClientContext</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">del</span>(key);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error deleting key <span class="hljs-subst">${key}</span> from Redis`</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 设置hash结构
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">ObjectType</span>} <span class="hljs-variable">field</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">hset</span>(
    <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">field</span>: <span class="hljs-title class_">ObjectType</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Result</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">ClientContext</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">hset</span>(key, field);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error setting hash for key <span class="hljs-subst">${key}</span> in Redis`</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 获取单个hash值
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">field</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">hget</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">field</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">hget</span>(key, field);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">`Error getting hash field <span class="hljs-subst">${field}</span> from key <span class="hljs-subst">${key}</span> in Redis`</span>,
        error
      );

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 获取所有hash值
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">hgetall</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">hgetall</span>(key);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">`Error getting all hash fields from key <span class="hljs-subst">${key}</span> in Redis`</span>,
        error
      );

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 清空redis缓存
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">flushall</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Result</span>&lt;<span class="hljs-string">"OK"</span>, <span class="hljs-title class_">ClientContext</span>&gt; | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">flushall</span>();
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error flushing all Redis data"</span>, error);

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 保存离线通知
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">userId</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">notification</span>
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">saveOfflineNotification</span>(
    <span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">notification</span>: <span class="hljs-built_in">any</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">lpush</span>(
        <span class="hljs-string">`offline_notifications:<span class="hljs-subst">${userId}</span>`</span>,
        <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(notification)
      );
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">`Error saving offline notification for user <span class="hljs-subst">${userId}</span>`</span>,
        error
      );
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@Description</span>: 获取离线通知
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">userId</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">*</span>}
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">getOfflineNotifications</span>(<span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>[]&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> notifications = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">lrange</span>(
        <span class="hljs-string">`offline_notifications:<span class="hljs-subst">${userId}</span>`</span>,
        <span class="hljs-number">0</span>,
        -<span class="hljs-number">1</span>
      );
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">del</span>(<span class="hljs-string">`offline_notifications:<span class="hljs-subst">${userId}</span>`</span>);

      <span class="hljs-keyword">return</span> notifications.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">notification</span>) =&gt;</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(notification));
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">`Error getting offline notifications for user <span class="hljs-subst">${userId}</span>`</span>,
        error
      );

      <span class="hljs-keyword">return</span> [];
    }
  }

  <span class="hljs-comment">/**
   * 获取指定 key 的剩余生存时间
   * <span class="hljs-doctag">@param</span> key Redis key
   * <span class="hljs-doctag">@returns</span> 剩余生存时间（秒）
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">getTTL</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisClient</span>.<span class="hljs-title function_">ttl</span>(key);
  }
}
</code></pre>
<h3 data-id="heading-8">前端工程化</h3>
<p>前端工程化这块花了很多信息在 eslint、prettier、husky、commitlint、github action 上，现在很多项目都是直接复制之前写好的过来就直接用。</p>
<p>后续应该是投入更多的时间在性能优化、埋点、自动化部署上了，如果有机会的也去研究一下 k8s 了。</p>
<h2 data-id="heading-9">全栈性价比最高的一套技术</h2>
<p>最近刷到一个帖子，讲到了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c221da3f484942c797a37fb8b1d9ed0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1739161900&amp;x-signature=WgaSSmzO8gqxsKxusykPWiDrssw%3D" alt="20241223165138" loading="lazy"></p>
<p>我目前也算是一个小全栈了吧，我也来分享一下我的技术吧：</p>
<ol>
<li>
<p>NextJs</p>
</li>
<li>
<p>React Native</p>
</li>
<li>
<p>prisma</p>
</li>
<li>
<p>NestJs</p>
</li>
<li>
<p>taro (目前还不会，如果有需求就会去学)</p>
</li>
</ol>
<p>剩下的描述也是和他下面那句话一样了（毕业后对技术态度的转变就是什么能让我投入最小，让我最快赚到钱的就是好技术）</p>
<h2 data-id="heading-10">总结</h2>
<p>学无止境，任重道远。</p>
<p>最后再来提一下这两个开源项目，它们都是我们目前正在维护的开源项目：</p>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fonline-edit-web" target="_blank" title="https://github.com/xun082/online-edit-web" ref="nofollow noopener noreferrer">在线代码协同编辑器</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fcreate-neat" target="_blank" title="https://github.com/xun082/create-neat" ref="nofollow noopener noreferrer">前端脚手架 create-neat</a></p>
</li>
</ul>
<p>如果你想参与进来开发或者想进群学习，可以添加我微信 <code>yunmz777</code>，后面还会有很多需求，等这个项目完成之后还会有很多新的并且很有趣的开源项目等着你。</p></div></div>