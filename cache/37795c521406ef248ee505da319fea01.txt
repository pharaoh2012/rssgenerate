
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenjieyouge/p/18870302" title="发布于 2025-05-10 23:23">
    <span role="heading" aria-level="2">Go 层级菜单树转 json 处理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        层级菜单树和转json处理
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本篇是一个补充知识点, 目的是为了下篇的后台管理系统中, 菜单权限的接口进行铺垫一下.<br>
同时也是做个笔记, 因为在很多地方都会用这种 "树结构" 来实现很多权限, 层级, 菜单的处理哈.</p>
<p>在表设计层面通常是通过 <code>id</code> 和<code>pid</code>  来体现层级关系.</p>
<ul>
<li>id 表示表的每行菜单的唯一标识</li>
<li>pid 标识这一行的 <code>上级菜单id</code> 是谁, 这个 id 一定是在 所有 id 中的</li>
<li>假设我们约定, <code>pid = 0</code> 是顶级菜单</li>
</ul>
<h3 id="表结构设计">表结构设计</h3>
<p>于是表设计就可以这样:</p>
<pre><code class="language-sql">-- 菜单树的表结构
drop table if exists test_tree;
create table test_tree (
	id int auto_increment primary key comment '自增id'
	, pid int not null default 0      comment '父级id'
	, name varchar(100) not null      comment '名称'
	, orders int not null default 0   comment '排序号'
);

-- 插入数据
INSERT INTO test_tree (id, pid, name, orders) VALUES 
(1, 0, 'A1', 10),
(2, 1, 'A1-1', 20),
(3, 1, 'A1-2', 20),
(4, 3, 'A1-2-1', 30),
(5, 3, 'A1-2-2', 30),

(6, 0, 'B1', 10),
(7, 6, 'B1-1', 20),
(8, 7, 'B1-1-1', 30),
(9, 8, 'B1-1-1-1', 40);

-- 递归查询某个 id 及其子节点
WITH RECURSIVE subordinates AS (
    SELECT id, pid, name, orders
    FROM test_tree
    WHERE ID = 1
    UNION ALL
    SELECT t.ID, t.PID, t.Name, t.`Orders`
    FROM test_tree t
    INNER JOIN subordinates s ON t.PID = s.ID
)
SELECT * FROM subordinates;
</code></pre>
<pre><code>id, pid, orders
1	0	A1	10
2	1	A1-1	20
3	1	A1-2	20
4	3	A1-2-1	30
5	3	A1-2-2	30
</code></pre>
<h3 id="拼接为-json-树">拼接为 json 树</h3>
<p>目的是为了方便前端渲染层级菜单, 通过 <code>children</code> 来进行拓展.</p>
<p><strong>Python版</strong></p>
<pre><code class="language-python">from typing import List, Dict

def build_tree(menu_items: List[Dict], id='id', pid='pid') -&gt; List[Dict]:
  """将菜单层级数据的 id, pid 平铺为 json 方式的"""

  menu_dict = { menu.get(id): menu for menu in menu_items }
  tree = []

  for menu in menu_items:
    if not menu.get(pid):
      tree.append(menu)  # 根节点
    else:
      # 非根节点, 将其添加到父节点的 child 中
      parent_menu = menu_dict.get(menu[pid])
      print(parent_menu)
      if parent_menu:
        if 'children' not in parent_menu:
          parent_menu['children'] = []
        parent_menu['children'].append(menu)
    
  return tree
</code></pre>
<p><strong>Go版</strong></p>
<pre><code class="language-go">package main

import (
	"encoding/json"
	"fmt"
)

type Menu struct {
	ID       int     `json:"id"`
	PID      int     `json:"parent_id"`
	Name     string  `json:"name"`
	Order    int     `json:"order"`
	Children []*Menu `json:"children"`
}

func BuildMenuTree(items []*Menu) []*Menu {
	nodeMap := make(map[int]*Menu)
	for _, node := range items {
		nodeMap[node.ID] = node
	}

	var tree []*Menu
	for _, node := range items {
		// 已约定 pid = 0 则为顶层节点
		if node.PID == 0 {
			tree = append(tree, node)
		} else {
			// 找到父节点,将其挂载到其 children 中
			if parent, exist := nodeMap[node.PID]; exist {
				parent.Children = append(parent.Children, node)
			}
		}
	}
	return tree
}
</code></pre>
<p>Go 也是一样的逻辑, 只是代码编写上要复杂一点, 原因在于,</p>
<ul>
<li>它是静态编译型语言, 要确定类型, 同时结构体和 json 之间需要用到反射 <code>reflect</code></li>
<li>Go 中数组是 <code>值类型</code>, 切片是对它的引用, 在处理中需要用到 <code>指针</code>, 不然会进行节点<code>重复创建</code></li>
</ul>
<pre><code class="language-go">// 继续上面的测试
func main() {
	items := []*Menu{

		{ID: 1, PID: 0, Name: "A1", Order: 10},
		{ID: 2, PID: 1, Name: "A1-1", Order: 20},
		{ID: 3, PID: 1, Name: "A1-2", Order: 20},
		{ID: 4, PID: 3, Name: "A1-2-1", Order: 30},
		{ID: 5, PID: 3, Name: "A1-2-2", Order: 30},

		{ID: 6, PID: 0, Name: "B1", Order: 10},
		{ID: 7, PID: 6, Name: "B1-1", Order: 20},
		{ID: 8, PID: 7, Name: "B1-1-1", Order: 30},
		{ID: 9, PID: 8, Name: "B1-1-1-1", Order: 40},
	}

	tree := BuildMenuTree(items)

	// 将树结构体 (指针, 切片, 数组, map 等) 转为 json
	// prefix = "" 表示不用加前缀; indent = "  " 表示每层缩进2空格
	jsonData, err := json.MarshalIndent(tree, "", "  ")
	if err != nil {
		fmt.Println("转换j son 失败: ", err)
		return
	}
	fmt.Println(string(jsonData))
}
</code></pre>
<p>输出:</p>
<pre><code class="language-json">[
  {
    "id": 1,
    "parent_id": 0,
    "name": "A1",
    "order": 10,
    "children": [
      {
        "id": 2,
        "parent_id": 1,
        "name": "A1-1",
        "order": 20,
        "children": null
      },
      {
        "id": 3,
        "parent_id": 1,
        "name": "A1-2",
        "order": 20,
        "children": [
          {
            "id": 4,
            "parent_id": 3,
            "name": "A1-2-1",
            "order": 30,
            "children": null
          },
          {
            "id": 5,
            "parent_id": 3,
            "name": "A1-2-2",
            "order": 30,
            "children": null
          }
        ]
      }
    ]
  },
  {
    "id": 6,
    "parent_id": 0,
    "name": "B1",
    "order": 10,
    "children": [
      {
        "id": 7,
        "parent_id": 6,
        "name": "B1-1",
        "order": 20,
        "children": [
          {
            "id": 8,
            "parent_id": 7,
            "name": "B1-1-1",
            "order": 30,
            "children": [
              {
                "id": 9,
                "parent_id": 8,
                "name": "B1-1-1-1",
                "order": 40,
                "children": null
              }
            ]
          }
        ]
      }
    ]
  }
]
</code></pre>
<p>用的频率还是蛮高的, 但凡涉及这种树的结构, 基本都会用到这种 <code>id + parent_id</code> 的方式, 同时也是 SQL 的一个必备知识点, 即 <code>自关联 + 子查询</code>, 这个技能必须要拿下. 真的是自从有了 AI , 似乎理解知识点都是轻而易举呢.</p>

</div>
<div id="MySignature" role="contentinfo">
    耐心和恒心, 总会获得回报的. 
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7057466404155093" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 23:23">2025-05-10 23:23</span>&nbsp;
<a href="https://www.cnblogs.com/chenjieyouge">致于数据科学家的小陈</a>&nbsp;
阅读(<span id="post_view_count">41</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18870302);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18870302', targetLink: 'https://www.cnblogs.com/chenjieyouge/p/18870302', title: 'Go 层级菜单树转 json 处理' })">举报</a>
</div>
        