
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/panxk/p/18982247/docker_nginx_proxy" title="发布于 2025-07-13 14:07">
    <span role="heading" aria-level="2">Docker部署Nginx代理多个服务：公网域名与内网IP场景全解</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1993913/202507/1993913-20250713140644111-89265039.png" alt="Docker部署Nginx代理多个服务：公网域名与内网IP场景全解" class="desc_img">
        本文分享了我在公网和内网两种环境下，使用 Docker 部署 Nginx 并代理多个应用的完整实践。涵盖了常见的端口方式、路径方式、HTTPS 自动跳转、容器网络配置等关键细节，并附上完整的 docker-compose.yml 和 Nginx 配置模板。尤其是在内网环境下代理多个应用时，我也遇到了一些坑（如路径代理导致 SPA 应用失效），这里也详细记录了解决思路。适合需要部署内网服务、或希望统一 Nginx 入口管理多个容器服务的朋友参考。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1993913/202507/1993913-20250713134703023-1828478506.png" class="lazyload"></p>
<blockquote>
<p>本文分享了我在公网和内网两种环境下，使用 Docker 部署 Nginx 并代理多个应用的完整实践。涵盖了常见的端口方式、路径方式、HTTPS 自动跳转、容器网络配置等关键细节，并附上完整的 docker-compose.yml 和 Nginx 配置模板。尤其是在内网环境下代理多个应用时，我也遇到了一些坑（如路径代理导致 SPA 应用失效），这里也详细记录了解决思路。适合需要部署内网服务、或希望统一 Nginx 入口管理多个容器服务的朋友参考。</p>
</blockquote>
<h1 id="1-公网环境下的-nginx-部署与代理配置">1. 公网环境下的 Nginx 部署与代理配置</h1>
<h2 id="11-docker部署nginx">1.1 Docker部署Nginx</h2>
<p>通常是云服务器有公网IP，并且有域名已经解析到这个公网IP了。</p>
<ul>
<li>nginx-reverse-proxy网络负责Nginx和其他应用的交互。</li>
<li>internet网络负责Nginx发布接口的映射到服务器上。</li>
<li>正常监听80和443端口。</li>
<li>数据卷挂在Nginx的配置文件夹，日志及主机时间，证书和私钥。</li>
</ul>
<pre><code class="language-bash">services:
  nginx:
    image: nginx:latest
    container_name: nginx-reverse-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./log:/var/log/nginx
      - /etc/letsencrypt/live/zenseek.site/fullchain.pem:/etc/nginx/certs/fullchain.pem:ro
      - /etc/letsencrypt/live/zenseek.site/privkey.pem:/etc/nginx/certs/privkey.pem:ro
      - /etc/localtime:/etc/localtime:ro
    networks:
      - nginx-reverse-proxy
      - internet
    restart: always

networks:
  nginx-reverse-proxy:
    external: true
  internet:
    external: true
</code></pre>
<h2 id="12-nginx配置文件">1.2 Nginx配置文件</h2>
<h3 id="121-默认配置文件">1.2.1 默认配置文件</h3>
<ul>
<li>文件名<code>default.conf</code></li>
<li>默认配置主要负责将HTTP重定向到HTTPS上。</li>
</ul>
<pre><code class="language-bash">server {
    listen 80;
    server_name _;

    # Redirect all HTTP requests to HTTPS
    return 301 https://$host$request_uri;
}
</code></pre>
<h3 id="122-应用配置文件">1.2.2 应用配置文件</h3>
<ul>
<li>文件名<code>app.conf</code></li>
<li>将二级域名代理到容器内的应用。</li>
</ul>
<pre><code class="language-bash">server {
    listen 443 ssl;
    server_name prefix_domain_name;
    
    省略。。。
    
    location / {
        proxy_pass http://vaultwarden:80;
        省略。。。
    }
}
</code></pre>
<h1 id="2-内网环境中的-nginx-多应用代理方案">2. 内网环境中的 Nginx 多应用代理方案</h1>
<p>在内网环境部署Nginx和应用的话，除非是内网的生产应用会有内网的域名外，基本就是使用内网IP。在这种情况下，可以通过不同的端口号来区分应用，或是不同的路径名来区分应用。</p>
<h2 id="21-使用不同的端口来区分应用">2.1 使用不同的端口来区分应用</h2>
<p>Nginx的容器配置是基本不变的，需要使用什么接口就发布什么接口。</p>
<pre><code class="language-bash">    ports:
      - "8080:8080"
      - "8443:8443"
</code></pre>
<p>也可以使用范围来发布连续的端口号，这样可以减少配置量。</p>
<pre><code class="language-bash">    ports:
      - "8000-8010:8000-8010"
</code></pre>
<p>Nginx的配置文件则是按应用区分。</p>
<pre><code class="language-bash">server {
    listen 8004 ssl;
    server_name Intranet_IP;

    省略。。。

    location / {
        proxy_pass http://keycloak_web:8080;  # Proxy to Keycloak
        
        省略。。。
    }
}
</code></pre>
<p>这样通过访问服务器的内网IP加端口号就可以访问后端的应用。但是这种方式有一个缺点，就是无法自动从HTTP跳转到HTTPS。所以必须使用<code>https://IP:Port</code>的格式才行. 这个非常规的端口号不能既监听HTTP又监听HTTPS流量。但是这个方式比较保险，因为<code>https://IP:Port</code>后面跟的是根路径，后端应用不易出现问题。</p>
<h2 id="22-使用不同的路径来区分应用">2.2 使用不同的路径来区分应用</h2>
<p>Nginx容器的配置没有变化，就还是正常监听80和443端口。访问不同的应用则是通过后面的路径名来区分的。Nginx的配置文件则是变成一个文件，格式如下。</p>
<ul>
<li>第一个Server block是用于HTTP跳转到HTTPS。</li>
<li>第二个Server block是用于处理HTTPS的访问。</li>
<li>通过路径来区分将请求转到后端的哪个应用上。</li>
</ul>
<pre><code class="language-bash">server {
    listen 80;
    server_name _;

    # Redirect all HTTP requests to HTTPS
    return 301 https://$host:$request_uri;
}


server {
    listen 443 ssl;
    server_name _;

     省略。。。

    # /draw -&gt; Excalidraw
    location /draw/ {
        proxy_pass http://excalidraw:80; # reverse proxy to Excalidraw
        省略。。。
    }

    # /password -&gt; Vaultwarden
    location /password/ {
        proxy_pass http://vaultwarden:80; # reverse proxy to Vaultwarden
        省略。。。
    }

}
</code></pre>
<p>但是通过不同路径来区分应用的方式会导致一些后端应用无法运行。譬如像Excalidraw这样的应用，后端期待的根路径<code>/</code>开始的，但是实际上传过去的是<code>/draw/</code>，导致无法识别路径。虽然后来我加上了路径改写<code>rewrite ^/draw/(.*)$ /$1 break;</code>，但是依然不生效，返回的路径也把<code>/draw</code>给去掉了。</p>
<h2 id="23-结论">2.3 结论</h2>
<p>如果使用路径不影响应用的话，这种还是比较方便的，毕竟容易记，且还能重定向到HTTPS，也不用更改Nginx容器的发布端口的配置。</p>
<h1 id="-延伸阅读">📚 延伸阅读</h1>
<p>更多内容持续更新于我的博客：<a href="https://www.zenseek.site" target="_blank" rel="noopener nofollow">https://www.zenseek.site</a></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-13 14:07">2025-07-13 14:07</span>&nbsp;
<a href="https://www.cnblogs.com/panxk">潘晓可</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18982247);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18982247', targetLink: 'https://www.cnblogs.com/panxk/p/18982247/docker_nginx_proxy', title: 'Docker部署Nginx代理多个服务：公网域名与内网IP场景全解' })">举报</a>
</div>
	