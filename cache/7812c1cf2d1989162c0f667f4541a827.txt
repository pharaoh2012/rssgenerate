
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18725027" title="发布于 2025-02-19 19:14">
    <span role="heading" aria-level="2">Java反射机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="反射是什么">反射是什么</h1>
<blockquote>
<p>官方定义:在运行时可以动态地获取类的信息,并操作类属性和方法的能力<strong>(不需要提前知道这个类的具体细节)</strong>.简单来说,假设你有一个盒子,盒子里装满了玩具.正常的操作是:你已知盒子里是什么玩具,可以直接取出来.反射操作:闭着眼在盒子里摸索,通过形状,重量猜出是什么玩具</p>
</blockquote>
<h1 id="反射的作用">反射的作用</h1>
<ul>
<li><strong>反射的核心作用:动态性.</strong>反射让程序在运行时动态操作类和对象,而不是在编译时写死代码.就像给程序装了一个”扫描仪”,可以实时监测未知的类结构</li>
</ul>
<h1 id="反射的基础实现class对象">反射的基础实现:Class对象</h1>
<blockquote>
<p>Class对象简单来说就是类的”身份证”</p>
</blockquote>
<ul>
<li>
<p>对于每一个类来说比如(<code>String,ArrayList</code>),在JVM中都有一个对应的Class对象,这个Class对象记录了这个类的所有消息包括:类名,方法,字段,构造器等等</p>
</li>
<li>
<p>更加贴切的类比</p>
<blockquote>
<p>假设要组装一个电脑</p>
</blockquote>
<ul>
<li>类:相当于电脑的设计图纸</li>
<li>对象:根据图纸造出的实体电脑</li>
<li>Class对象:图纸的索引卡片(记录,图纸存放的位置,版本号,需要的零件信息)</li>
</ul>
<blockquote>
<p>若你要查看图纸,不是直接对图纸进行操作,<strong>而是通过索引卡片(Class对象)找到图纸信息</strong></p>
</blockquote>
</li>
</ul>
<h2 id="获取class对象的方法">获取Class对象的方法</h2>
<h3 id="类名class">类名.class</h3>
<pre><code class="language-java">        //类名.class(最直接)
        Class&lt;String&gt; stringClass = String.class;

</code></pre>
<ul>
<li>明确知道要操作的类,编译时检查类是否存在</li>
</ul>
<h3 id="对象getclass">对象.getClass()</h3>
<pre><code class="language-java">        //对象.getClass()
        String str = "Hello World";
        Class&lt;?&gt; strClass = str.getClass();
</code></pre>
<ul>
<li>前提已经存在对象实例,只能获取对象实例类型的Class</li>
</ul>
<h3 id="classforname">Class.forName()</h3>
<pre><code class="language-java">//Class.forName("完整类名")最灵活
        Class&lt;?&gt; arrayListClass = Class.forName("java.lang.ArrayList");
</code></pre>
<ul>
<li>动态加载类(根据配置),必须完成输入类型(包名+类名)</li>
</ul>
<h2 id="class对象的主要作用">Class对象的主要作用</h2>
<blockquote>
<p>通过Class对象,我们可以”解剖一个类”</p>
</blockquote>
<ul>
<li><strong>创建对象</strong>:即使不知道类名,也可以创建</li>
<li><strong>查看类信息</strong>:包括类名,包名,父类信息,接口等等</li>
<li><strong>获取所有方法和字段</strong>:甚至包括私有方法</li>
<li><strong>调用方法:</strong>包括私有方法</li>
<li><strong>动态操作字段值</strong></li>
</ul>
<h2 id="class对象获取构造函数方法">Class对象获取构造函数方法</h2>
<h3 id="获取构造函数方法">获取构造函数方法</h3>
<ul>
<li>
<p><code>Constructor&lt;?&gt;[] getConstructors()</code>:获取所有public构造函数方法</p>
<pre><code class="language-java"> //获取类的所有public构造函数
        Constructor&lt;?&gt;[] constructors = stuClass.getConstructors();
</code></pre>
</li>
<li>
<p><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>:获取所有的构造函数包括private</p>
<pre><code class="language-java"> //获取类所有的构造函数包括private
        Constructor&lt;?&gt;[] declaredConstructors = stuClass.getDeclaredConstructors();

</code></pre>
</li>
<li>
<p><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... paramTypes)</code>:获取无参或有参构造函数的</p>
<pre><code class="language-java"> //获取无参构造函数public
        Constructor&lt;Student&gt; classConstructor = stuClass.getConstructor();
</code></pre>
</li>
<li>
<p><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... paramTypes)</code>:获取任意访问权限的构造函数</p>
<pre><code class="language-java">        //获取有参构造函数private,需传入参数类型的Class对象
        Constructor&lt;Student&gt; declaredConstructor = stuClass.getDeclaredConstructor(Integer.class);
        declaredConstructor.setAccessible(true);//将访问权限置为true

</code></pre>
</li>
</ul>
<h3 id="通过构造函数创建对象的方法">通过构造函数创建对象的方法</h3>
<ul>
<li>
<p><code>T newInstance(Object... args)</code></p>
<ul>
<li>使用构造函数创建实例:</li>
</ul>
<pre><code class="language-java">        //无参构造函数创建对象
        Constructor&lt;Student&gt; constructor = Student.class.getConstructor();
        Student student = constructor.newInstance();

        //有参构造函数创建对象
        Constructor&lt;Student&gt; constructor1 = Student.class.getConstructor(String.class, Integer.class);
        Student student1 = constructor1.newInstance("张三",18);

</code></pre>
</li>
</ul>
<h3 id="字段操作">字段操作</h3>
<ul>
<li>
<p>获取字段</p>
<ul>
<li>
<p><code>Field[] getFields()</code>:获取所有public字段,包括父类</p>
<pre><code class="language-java">        //获取所有public字段
        Field[] fields = Student.class.getFields();

</code></pre>
</li>
<li>
<p><code>Field[] getDeclaredFields()</code>:获取本类所有字段,包括private</p>
<pre><code class="language-java">        //获取本类所有字段包括private字段
        Field[] declaredFields = Student.class.getDeclaredFields();

</code></pre>
</li>
<li>
<p><code>Field getField(String name)</code>:获取指定名称的public字段</p>
<pre><code class="language-java">        //获取指定名称的public字段
        Field name = Student.class.getField("name");

</code></pre>
</li>
<li>
<p><code>Field getDeclaredField(String name)</code>:获取任意访问权限的字段</p>
<pre><code class="language-java">        //获取任意访问权限的字段
        Field age = Student.class.getDeclaredField("age");
</code></pre>
</li>
</ul>
</li>
<li>
<p>操作字段值</p>
<ul>
<li>
<p><code>Object get(Object obj)</code>:获取字段值</p>
<pre><code class="language-java">        Field age = Student.class.getDeclaredField("age");
        age.setAccessible(true);
				 Integer num = (Integer) age.get(student);
</code></pre>
</li>
<li>
<p><code>void set(Object obj,Object value</code>:修改字段值</p>
<pre><code class="language-java">        Student student = new Student();
        Field nameField = Student.class.getDeclaredField("name");

        nameField.setAccessible(true);//突破访问权限
        nameField.set(student, "zhangsan");
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="方法操作">方法操作</h3>
<ul>
<li>
<p>获取方法</p>
<ul>
<li>
<p><code>Method[] getMethods()</code>:获取所有public方法</p>
<pre><code class="language-java">        //获取所有public方法包括父类
        Method[] methods = Student.class.getMethods();

</code></pre>
</li>
<li>
<p><code>Method[] getDeclaredMethods()</code>:获取所有方法包括private</p>
<pre><code class="language-java">        //获取所有private方法
        Method[] declaredMethods = Student.class.getDeclaredMethods();

</code></pre>
</li>
<li>
<p><code>Method[] getMethod(String name,Class&lt;?&gt;... paramTypes)</code>获取指定参数的public方法</p>
<pre><code class="language-java">        //获取指定参数的public方法
        Method setName = Student.class.getMethod("setName", String.class);
        Method setAge = Student.class.getMethod("setAge", Integer.class);

</code></pre>
</li>
<li>
<p><code>Method[] getDeclaredMethod(String name,Class&lt;?&gt;... paramTypes)</code></p>
<pre><code class="language-java">        //获取任意访问权限的方法
        Method getName = Student.class.getDeclaredMethod("getName");
        getName.setAccessible(true);
</code></pre>
</li>
</ul>
</li>
<li>
<p>调用方法</p>
<ul>
<li>
<p><code>Object invoke(Object obj, Object... args)</code>:调用方法</p>
<pre><code class="language-java">        Student student = new Student();
        Method getName = Student.class.getDeclaredMethod("getName");
        String name = (String) getName.invoke(student);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="案例理解">案例理解</h2>
<h3 id="封装一个通用方法支持传入各种的对象类型都可以实现对应方法">封装一个通用方法,支持传入各种的对象类型都可以实现对应方法</h3>
<pre><code class="language-java">    /*
     * @description:封装一个通用方法,支持传入各种的对象类型都可以实现对应方法
     * @author: HYJ
     * @date: 2025/2/17 10:25
     * @param: [className, methodName]
     * @return: void
     **/
    public static void invoke(String className, String methodName) {

        try {
            //获取Class对象
            Class&lt;?&gt; clazz = Class.forName(className);
            //获取构造器
            Constructor&lt;?&gt; constructor = clazz.getConstructor();

            //实例化对象
            Object instance = constructor.newInstance();

            //获取方法
            Method method = clazz.getMethod(methodName);

            //调用method的invoke执行方法
            method.invoke(instance);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.37505821194907407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-19 19:15">2025-02-19 19:14</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18725027" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18725027);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18725027', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18725027', title: 'Java反射机制' })">举报</a>
</div>
        