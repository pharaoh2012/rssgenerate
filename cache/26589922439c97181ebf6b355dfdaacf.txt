
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Planet-xx/p/18959884" title="发布于 2025-07-01 16:42">
    <span role="heading" aria-level="2">内网环境下Go module的包管理和包拉取解决方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>很多开发的小伙伴在工作中经常会遇到需要在内网环境下开发生产，因此就必须要解决内网环境下Go语言的包管理和包拉取问题。恰逢我司前端时间就需要在内网环境下开发新项目，因此在此记录我们内网环境下Go module的包管理和包拉取解决方案，希望给予其他小伙伴有所借鉴。Go 语言在1.16 版本以后已经默认使用 Go Module 模式进行依赖包管理，而Go Module默认使用<code>https://proxy.golang.org</code>作为代理地址来拉取第三方包，但该地址需要能够访问互联网，另外还需要考虑到很多无法直接访问公共的包管理器，如<code>GitHub</code>、<code>Golang.org</code>、<code>Gopkg.in</code>等。</p>
<h1 id="解决方案">解决方案</h1>
<p>在内网环境下，Go module的包管理和包拉取的常规解决方案主要有以下几种：</p>
<ol>
<li>私有代理</li>
</ol>
<p>在内网中，可以搭建私有的Go module代理服务来缓存、管理和拉取第三方包，以提高包的下载速度，同时解决内网环境下的拉包问题。常用的代理工具有<code>Goproxy</code>、<code>Athens</code>、<code>Nexus</code>等。在搭建好私有代理后，可以设置GOPXOY环境变量来使用私有代理，例如：</p>
<pre><code class="language-Shell">$ export GOPROXY = http://172.31.33.33:8080
</code></pre>
<ol start="2">
<li>Vender目录</li>
</ol>
<p>可以在项目的根目录下创建vendor目录,将依赖的第三方包直接下载到该目录下。在使用<code>go build</code>、<code>go test</code>等命令时，Go工具链会优先从vendor目录中查找所需的包。在项目根目录下执行以下命令，将当前模块的所有依赖包下载到vendor目录:</p>
<pre><code class="language-Shell">$ go mod vendor
</code></pre>
<p>需要注意的是，endor目录仅适用于项目内的依赖,如果依赖的包又依赖其他第三方包，则需要手动将这些包下载到vendor目录中。同时，如果vendor目录中存在多个版本的同一个包，则需要手动解决冲突。</p>
<ol start="3">
<li>将依赖包打包到二进制文件中</li>
</ol>
<p>可以使用go1.16及以上版本的<code>-embed</code>标志，将项目依赖的第三方包打包到二进制文件中，避免在运行时需要依赖外部的包。该方式适用于将应用程序部署到多个环境中，或将应用程序分发给客户端。</p>
<pre><code class="language-Shell">$ go build -o app -tags embed -ldflag3="-w -s -extldflags=-static" -embed
</code></pre>
<p>以上几个就是在内网中进行Go module包管理和包拉取的解决方案，再结合我们实际开发场景，方案2会导致项目整理越来越大，不利于项目的管理、部署和维护，方案3则是只适合再部署时使用，并不能满足正常的工作开发中的需求场景，因此我们选择方案1，通过内部搭建一个私有的go module代理服务来解决内网环境下的拉包问题。</p>
<h1 id="搭建私有go-module代理服务">搭建私有go module代理服务</h1>
<p><a href="https://pkg.go.dev/cmd/go@master#hdr-Module_proxy_protocol" target="_blank" rel="noopener nofollow">Go module proxy协议规范</a>发布后，Go社区出现了很多成熟的Goproxy开源实现。从最初的<a href="https://tonybai.com/2018/11/26/hello-go-module-proxy/" target="_blank" rel="noopener nofollow">athens</a>，再到国内的两个优秀的开源实现：<a href="https://github.com/goproxy/goproxy" target="_blank" rel="noopener nofollow">goproxy</a>和<a href="https://github.com/goproxyio/goproxy" target="_blank" rel="noopener nofollow">goproxy.io</a>等。最终，在考虑到代理服务的部署及维护的方便程度上，我们选择了使用更为简单的<code>goproxy</code>和<code>goproxy.io</code>来搭建私有go module代理服务。</p>
<h2 id="代理服务搭建">代理服务搭建</h2>
<h3 id="goproxy搭建">goproxy搭建</h3>
<ol>
<li>创建<code>goproxy</code>文件夹，<code>go mod</code>初始化<code>goproxy</code>：</li>
</ol>
<pre><code class="language-Shell">$ go mod init goproxy
</code></pre>
<ol start="2">
<li>创建<code>goproxy.go</code>文件，监听本地代理端口，初始化<code>goproxy</code>代理：</li>
</ol>
<pre><code class="language-Go">package main

import (
        "net/http"

        "github.com/goproxy/goproxy"
)

func main() {
        http.ListenAndServe("localhost:8080", &amp;goproxy.Goproxy{})
}
</code></pre>
<ol start="3">
<li>修改GOPROXY环境变量，拉取<code>goproxy</code>服务依赖</li>
</ol>
<pre><code class="language-Shell">$ go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
<ol start="4">
<li>拉取服务依赖，启动<code>goproxy</code>代理服务：</li>
</ol>
<pre><code class="language-Shell">$ cd goproxy
$ go mod tidy
$ go run goproxy.go
</code></pre>
<h3 id="goproxyio搭建">goproxy.io搭建</h3>
<ol>
<li>git clone拉取<code>goproxy.io</code>源码：</li>
</ol>
<pre><code class="language-Shell">$ git clone git@github.com:goproxyio/goproxy.git
</code></pre>
<ol start="2">
<li>编译<code>goproxy.io/goproxy</code>下的<code>main.go</code>文件</li>
</ol>
<pre><code class="language-Shell">$ cd goproxy.io/goproxy
$ make
</code></pre>
<ol start="3">
<li>命令行启动代理服务</li>
</ol>
<pre><code class="language-Shell"># 直接启动
$ ./bin/goproxy -listen=0.0.0.0:8088 -cacheDir=./modCache -proxy https://goproxy.cn
# 或者已进程方式后台运行时，命令如下：
$ nohup ./bin/goproxy -listen=0.0.0.0:8088 -cacheDir=./modCache -proxy https://goproxy.cn &amp;
</code></pre>
<h1 id="代理服务使用及测试">代理服务使用及测试</h1>
<p>搭建好私有代理服务后，我们就可以开始使用代理服务拉取第三方包了。使用go module代理服务很简单，通常情况下，我们都是使用对应的IDE工具来进行代码开发，直接在对应的IDE工具中为对应项目配置代理服务地址。以研发环境下GoLand为例，配置如下：</p>
<ol>
<li>修改研发机golang环境变量<code>GOPROXY</code>和<code>GONOSUMDB</code>；</li>
</ol>
<ul>
<li>修改<code>GOPROXY</code>环境变量，命令如下：</li>
</ul>
<pre><code class="language-Shell">$ go env -w GOPROXY=http://172.31.31.31:2326,direct
</code></pre>
<ul>
<li>修改<code>GONOSUMDB</code>环境变量，命令如下：</li>
</ul>
<pre><code class="language-Shell">$ go env -w GONOSUMDB=*
</code></pre>
<p><strong>默认情况下，当我们执行<code>go get</code>或<code>go mod tidy</code>等命令需要下载模块时，它们会将模块版本和校验和发送到<code>sum.golang.org</code>进行验证，以确保安全性和数据完整性。但由于研发机环境无法连接到环境无法连接到<code>sum.golang.org</code>，因此需要跳过模块的校验和（checksum）验证。</strong></p>
<p>而且，我们拉取的是代理服务器本地的缓存包，本来是已经在代理服务器上通过验证了，因此也可以保证其安全性和完成性。</p>
<ol start="2">
<li>配置GoLand中的<code>GOPROXY</code>环境变量；</li>
</ol>
<p>点击<code>Go Module</code>，新增<code>GOPROXY</code>配置项，配置代理服务地址为上述GOPROXY地址。</p>
<ol start="3">
<li>在代理服务器上清空本地go module缓存，使用代理服务器重新拉取 GO 模块</li>
</ol>
<pre><code class="language-Shell">$ go clean -modcache
$ go mod tidy
</code></pre>
<ol start="4">
<li>代理服务器拉包完成后，使用研发机拉取代理机上的包缓存即可</li>
</ol>
<pre><code class="language-Shell">$ go mod tidy
</code></pre>
<p>针对同一个项目，通过分别配置<code>goproxy</code>和<code>goproxy.io</code>代理服务地址进行测试，最终我们确定<code>goproxy.io</code>会比<code>goproxy</code>更加稳定一些，<code>goproxy</code>经常会以为网络问题出现部分丢包现象，因此我们确定使用<code>goproxy.io</code>来搭建<code>go module</code>私有代理服务。</p>
<p><strong>需要注意的是：内网环境下通过代理服务器拉取go mod，这种方式需要保证拉取的go mod依赖包与服务器缓存的依赖包版本一致，否则无法拉取依赖。</strong></p>
<h1 id="参考">参考</h1>
<p><a href="https://studygolang.com/articles/35235" target="_blank" rel="noopener nofollow">私有化仓库的 GO 模块使用实践</a></p>
<p><a href="https://tonybai.com/2021/09/03/the-approach-to-go-get-private-go-module-in-house/" target="_blank" rel="noopener nofollow">小厂内部私有Go module拉取方案</a></p>
<p><a href="https://github.com/goproxy/goproxy#quick-start" target="_blank" rel="noopener nofollow">goproxy.cn官方文档</a></p>
<p><a href="https://github.com/goproxyio/goproxy#started" target="_blank" rel="noopener nofollow">goproxy.io官方文档</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007638888888888889" data-date-updated="2025-07-01 16:53">2025-07-01 16:42</span>&nbsp;
<a href="https://www.cnblogs.com/Planet-xx">Planet-lxy</a>&nbsp;
阅读(<span id="post_view_count">77</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18959884);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18959884', targetLink: 'https://www.cnblogs.com/Planet-xx/p/18959884', title: '内网环境下Go module的包管理和包拉取解决方案' })">举报</a>
</div>
        