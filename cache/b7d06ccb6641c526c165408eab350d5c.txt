
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yangtb/p/19031663" title="发布于 2025-08-11 15:26">
    <span role="heading" aria-level="2">记一次C#平台调用中因非托管union类型导致的内存访问越界</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="离奇现象">离奇现象</h1>
<p>大家在C#代码中有没有遇到过这样的问题：一个局部变量，上一秒还是非null的，下一秒就变成null了，中间只调用了一个非托管函数。</p>
<p>我前几天就遇到了这样的问题，问题代码长这样：</p>
<pre><code>private static PropVariant GetProperty(Window window, PropertyKey key)
{
    var hwnd = new WindowInteropHelper(window).EnsureHandle();
    Win32.Shell32.SHGetPropertyStoreForWindow(hwnd, out IPropertyStore ps);
    ps.GetValue(ref key, out PropVariant value);
    return value;
}
</code></pre>
<p>ps是一个COM类型的对象，本来是非null的，调用完它的GetValue方法后，就变成null了，离奇地是，没有任何报错，调用返回值是正常的，value的结果也是正确的。<br>
<img alt="img" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2033325/202508/2033325-20250811153250515-1895758019.gif" class="lazyload"></p>
<p>在这里，IPropertyStore是一个Com类型，PropVariant类型的原型是这样的,具体可看官方文档：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/propidl/ns-propidl-propvariant" target="_blank" rel="noopener nofollow">PROPVARIANT 结构 (propidl.h)</a></p>
<pre><code>typedef struct tagPROPVARIANT {
  union {
    typedef struct {
      VARTYPE      vt;
      PROPVAR_PAD1 wReserved1;
      PROPVAR_PAD2 wReserved2;
      PROPVAR_PAD3 wReserved3;
      union {
        //....此处省略
      };
    } tag_inner_PROPVARIANT, PROPVARIANT, *LPPROPVARIANT;
    DECIMAL decVal;
  };
} PROPVARIANT, *LPPROPVARIANT;
</code></pre>
<p>然后我是这样封装的</p>
<pre><code>[StructLayout(LayoutKind.Sequential)]
internal record struct PropVariant(ushort vt, IntPtr pointer);
</code></pre>
<h1 id="暗藏玄机">暗藏玄机</h1>
<p>由于我对平台调用的机制不是特别熟悉，所以一开始想到的是，是不是因为我封装的结构体不对，导致平台调用的内部发生了什么异常。但是仔细一想感觉也不太可能，非托管代码里面不管发生了什么，应该都不会直接影响到我托管代码里的变量的值吧。</p>
<p>但是我觉得大概率还是PropVariant封装的有问题，所以我就尝试了一下把PropVariant的大小申明为128字节,再试了一下，果然就没问题了。</p>
<pre><code>[StructLayout(LayoutKind.Sequential, Size = 128)]
internal record struct PropVariant(ushort vt, IntPtr pointer);
</code></pre>
<p>这个封装在64位应用里面默认大小是16字节，我改成显式申明为128字节之后就没问题了，那么说明平台调用对PropVariant的操作实际上是大于16字节的，因为访问越界把ps变量的值给写掉了。不过问题是，这个越界是怎么越到ps这个变量上去的。</p>
<p>因为搞不懂到底非托管代码是怎么写到我的ps变量的，于是我就不断尝试变量申明的方式，试图避免非托管代码去改写我的ps变量。终于在尝试到下面这种写法的时候，让我发现了一点端倪：</p>
<pre><code>IPropertyStore ps;
var hwnd = new WindowInteropHelper(window).EnsureHandle();
Win32.Shell32.SHGetPropertyStoreForWindow(hwnd, out ps);
ps.GetValue(ref key, out PropVariant value);
return value;
</code></pre>
<p><img alt="img" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2033325/202508/2033325-20250811153936258-1121637355.gif" class="lazyload"></p>
<p>现在，被改写的变量从ps变成了hwnd，那么很容易可以联想到，局部变量是按照某种顺序排列在一起，当操作PropVariant越界的时候，自然就写到了它后面的变量。现在这种写法，大概率是改变了局部变量的排序，所以被改写的变量从ps变成了hwnd。</p>
<p>于是，我拿出了我几个月前刚学的的IL技能。GetValue这一行的IL代码是这样的：</p>
<pre><code>IL_0016: ldloc.0      // ps
IL_0017: ldarga.s     key
IL_0019: ldloca.s     'value'
IL_001b: callvirt     instance int32 IPropertyStore::GetValue(valuetype PropertyKey&amp;, valuetype PropVariant&amp;)
IL_0020: pop
</code></pre>
<p>ldloca.s指令把'value'这个变量的地址放入到计算堆栈中，然后调用了GetValue方法，于是平台调用在往'value'这个变量的地址写数据的时候，就越界到其他变量去了。</p>
<p>那'value'变量是存在哪里的呢，我搜索了一下，搜到了一个叫局部变量表（Record Frame）的东西，它在IL代码里长这样：</p>
<pre><code>.locals init (
    [0] class IPropertyStore ps,
    [1] native int hwnd,
    [2] valuetype PropVariant 'value',
    [3] valuetype PropVariant V_3
)
</code></pre>
<p>然后，在我的原始代码里，它长这样：</p>
<pre><code>.locals init (
    [0] native int hwnd,
    [1] class IPropertyStore ps,
    [2] valuetype PropVariant 'value',
    [3] valuetype PropVariant V_3
)
</code></pre>
<p>可以看到，hwnd和ps交换了位置。那么这个局部变量表应该就是以0~3这样的顺序入栈的，所以当写'value'变量越界的时候，就写到了它后面的hwnd或者ps的数据。</p>
<h1 id="罪魁祸首">罪魁祸首</h1>
<p>看到这里，几乎就可以肯定问题是PropVariant封装的大小不对了。PropVariant的原型还挺复杂的，套了几层的union。我为了图方便，让ai给我写了个例子，所以这个封装方式其实是ai帮我写的（小小ai，速来背锅），在调用IPropertyStore.SetValue方法的时候倒是没发现什么异常，没想到在这里给我埋了一个坑。</p>
<p>于是我用Win32Cs这个包生成了一个PropVariant的封装，首先确认了一下Win32Cs给我生成的封装调用是正常的，然后调用<code>Marshal.SizeOf&lt;PROPVARIANT&gt;();</code>看了一下它封装的大小，发现实际上是24字节。</p>
<p>这时候死去的C语言记忆突然开始攻击我：我们都知道，union类型的大小是它占用内存最大的成员的大小（还有考虑内存对齐）。让我们再来看看PropVariant的原型：</p>
<pre><code>typedef struct tagPROPVARIANT {
  union {
    typedef struct {
      VARTYPE      vt;
      PROPVAR_PAD1 wReserved1;
      PROPVAR_PAD2 wReserved2;
      PROPVAR_PAD3 wReserved3;
      union {
        //....此处省略
      };
    } tag_inner_PROPVARIANT, PROPVARIANT, *LPPROPVARIANT;
    DECIMAL decVal;
  };
} PROPVARIANT, *LPPROPVARIANT;
</code></pre>
<p>中间有个union的成员我省略掉了，为什么省略掉，因为太多了......于是我让ai帮我封装，它给我把union直接封装成了IntPtr，我一想也挺合理的，拿到IntPtr,想要什么类型的值再自己转换嘛，完全没有注意到这一长串的成员里面有一些长度超过了8个字节的结构体（关键也是我完全忘了union类型的大小了）。</p>
<p>这个union里面的某些成员的类型，大小是16个字节的，例如这个结构体类型，它是一个uint加一个指针：</p>
<pre><code>[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.183+73e6125f79.RR")]
internal partial struct CALPWSTR
{
    internal uint cElems;

    internal unsafe winmdroot.Foundation.PWSTR* pElems;
}
</code></pre>
<p>所以这个union的大小是16个字节，然后加上前面的8个字节，tag_inner_PROPVARIANT这个结构体的大小是24字节。外层的union中，DECIMAL在文档中说明是和tag_inner_PROPVARIANT具有相同的大小，所以，整个结构体的大小是24字节。</p>
<p>最后，我的代码就改成这样了:</p>
<pre><code>[StructLayout(LayoutKind.Sequential, Size = 24)]
internal record struct PropVariant(ushort vt, IntPtr pointer);
</code></pre>
<p>没错，只要显式申明封装大小是24字节就可以了，因为那个成员巨多的union里面，我只用到了string和bool，所以就不做复杂的封装了。</p>
<p>我后面又调试了一下，发现这样写在32位程序里面还是有问题的，因为32位程序里指针是4字节的，所以结构体大小应该是16字节，所以还是不偷懒了，改写成这样，64位和32位就都没有问题了</p>
<pre><code>[StructLayout(LayoutKind.Sequential)]
internal record struct PropVariant(VarEnum vt, IntPtr pointer)
{
    public VarEnum vt = vt;             //ushort
    private ushort r1;
    private ushort r2;
    private ushort r3;
    public IntPtr pointer = pointer;    //用一个InPtr可以获取bool或者string*
    private int r4;                     //用一个int占位
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8118055555555556" data-date-updated="2025-08-12 10:55">2025-08-11 15:26</span>&nbsp;
<a href="https://www.cnblogs.com/yangtb">昏睡红猹</a>&nbsp;
阅读(<span id="post_view_count">343</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19031663);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19031663', targetLink: 'https://www.cnblogs.com/yangtb/p/19031663', title: '记一次C#平台调用中因非托管union类型导致的内存访问越界' })">举报</a>
</div>
        