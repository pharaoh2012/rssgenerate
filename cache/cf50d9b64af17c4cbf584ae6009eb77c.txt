<!----> <meta itemprop="headline" content="new Image() 预加载 为什么比 <img>直接加载要好？"> <meta itemprop="keywords" content="前端,性能优化,面试"> <meta itemprop="datePublished" content="2024-11-26T03:20:42.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不爱说话郭德纲"> <meta itemprop="url" content="https://juejin.cn/user/4103820476156712"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            new Image() 预加载 为什么比 &lt;img&gt;直接加载要好？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/4103820476156712/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    不爱说话郭德纲
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-11-26T03:20:42.000Z" title="Tue Nov 26 2024 03:20:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-11-26
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    13,610
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0"><code>&lt;img&gt;</code> 直接加载对比 <code>new Image()</code> 预加载</h2>
<h3 data-id="heading-1">1.&nbsp;<strong>加载时机和页面渲染的差异</strong></h3>
<ul>
<li>
<p><strong>直接渲染到 <code>&lt;img&gt;</code> 标签</strong>： 当你直接在 HTML 中通过 <code>&lt;img&gt;</code> 标签加载图片时，浏览器在遇到 <code>&lt;img&gt;</code> 标签时会立即开始加载图片。这意味着浏览器在渲染页面的过程中，会同步进行图片请求。当页面需要渲染图片时，可能会导致图片显示之前页面的其它部分无法完全显示，或者图片加载的过程中页面会出现闪烁或布局跳动。</p>
<p>这种加载方式是 <strong>同步</strong> 的，即浏览器渲染页面时，图片的加载和显示是直接相关的。如果图片较大或者网络慢，用户可能会看到空白的占位符，直到图片加载完成。</p>
</li>
<li>
<p><strong>使用 <code>new Image()</code> 和 <code>img.src = src</code></strong>： 这种方式会在后台加载图片，不直接影响页面的渲染。也就是说，图片资源在浏览器缓存中已经加载好了，页面显示图片时，浏览器能快速地从缓存读取图片，而不必等待网络请求。浏览器不会因为加载图片而延迟页面的渲染。</p>
<p><strong>关键点是</strong>：通过 <code>new Image()</code> 加载图片会提前发起请求，将图片缓存到浏览器中，这意味着你可以在用户滚动或需要展示图片时，直接从缓存加载，而不需要重新请求网络资源。这个过程是 <strong>异步</strong> 的。</p>
</li>
</ul>
<h3 data-id="heading-2">2.&nbsp;<strong>浏览器的资源管理和缓存</strong></h3>
<ul>
<li>
<p><strong>图片预加载的缓存</strong>： 当你通过 <code>new Image()</code> 加载图片时，图片会被缓存在浏览器的内存中（通常是浏览器的资源缓存），因此如果图片已经被加载过，后续使用该图片时会直接从缓存读取，而不需要重新请求网络资源。</p>
<p>而如果你直接用 <code>&lt;img&gt;</code> 标签来加载图片，浏览器同样会请求并缓存图片，但如果图片在初次加载时不可见（比如在页面下方），用户滚动到该位置时，可能会再次触发网络请求，尤其是在使用懒加载（lazy load）等技术时。如果图片已经预加载过，浏览器就可以从缓存中直接加载，避免了再次请求。</p>
</li>
</ul>
<h3 data-id="heading-3">3.&nbsp;<strong>避免页面阻塞</strong></h3>
<ul>
<li><strong>直接使用 <code>&lt;img&gt;</code></strong> ：当浏览器在解析页面时遇到 <code>&lt;img&gt;</code> 标签，会立即发起网络请求来加载图片。如果图片资源很大或者服务器响应很慢，浏览器可能需要等待这些资源加载完成，才能继续渲染其他部分。这会导致页面的 <strong>渲染阻塞</strong>，即页面内容渲染较慢，特别是在图片多的情况下。</li>
<li><strong>使用 <code>new Image()</code> 预加载</strong>：通过 <code>new Image()</code> 预加载图片，可以避免渲染时对页面的阻塞。浏览器在后台加载图片，直到需要展示图片时，图片已经准备好了，这样页面展示可以更快，用户体验也更好。</li>
</ul>
<h3 data-id="heading-4">4.&nbsp;<strong>适用场景</strong></h3>
<ul>
<li><strong>直接 <code>&lt;img&gt;</code> 标签加载</strong>：适用于图片较少且页面上几乎所有图片都需要立即展示的场景。例如，单一图片展示的页面。</li>
<li><strong><code>new Image()</code> 预加载</strong>：适用于图片较多或需要延迟加载的场景，例如动态加载的图片、长页面或者需要懒加载的图片库。它允许你提前将图片加载到浏览器缓存中，减少后续显示时的加载时间。</li>
</ul>
<h3 data-id="heading-5">5.&nbsp;<strong>加载速度和时间</strong></h3>
<p>如果从加载速度和时间上来看，<strong>两者的差别可能不大</strong>，因为它们最终都会发起一次网络请求去加载图片。但是，<code>new Image()</code> 的优势在于：</p>
<ul>
<li>它允许你在图片真正需要显示之前就开始加载，这样当用户需要看到图片时，图片已经在浏览器缓存中，可以即时显示。</li>
<li>使用&nbsp;<code>new Image()</code>&nbsp;可以提前加载图片，而不会影响页面的渲染顺序和内容显示，不会造成页面的阻塞。</li>
</ul>
<h3 data-id="heading-6">6.&nbsp;<strong>网络请求优化</strong></h3>
<p><code>new Image()</code> 还可以和 <strong>并发请求</strong> 进行优化。如果你有多个图片需要预加载，可以通过多个 <code>new Image()</code> 实例来并行加载这些图片，而不影响页面的渲染。并且，如果你知道某些图片很可能会被需要（例如图片懒加载场景中的下拉加载图片），你可以提前加载这些图片，确保用户滚动时能立刻看到图片。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c49acdc10b14d7786faa536bf96189a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN54ix6K-06K-d6YOt5b6357qy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1739317541&amp;x-signature=5pkbQRrhqCjHWXmsm5XUidjY0fQ%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-7">7.&nbsp;<strong>总结对比</strong></h3>






























<table><thead><tr><th>特性</th><th><code>&lt;img&gt;</code>&nbsp;标签加载</th><th><code>new Image()</code>&nbsp;预加载</th></tr></thead><tbody><tr><td><strong>渲染影响</strong></td><td>直接渲染图片，可能导致页面闪烁或布局跳动</td><td>异步加载图片，不影响页面渲染</td></tr><tr><td><strong>缓存</strong></td><td>图片加载后会缓存，但可能会重复请求</td><td>图片预先加载到缓存中，避免重复请求</td></tr><tr><td><strong>适用场景</strong></td><td>单一图片，少量图片，图片快速加载</td><td>图片较多，懒加载，预加载</td></tr><tr><td><strong>加载时机</strong></td><td>页面渲染时加载，可能导致渲染延迟</td><td>提前加载，确保图片准备好时显示</td></tr></tbody></table>
<h3 data-id="heading-8">结论</h3>
<p>虽然从技术上讲，直接在 <code>&lt;img&gt;</code> 标签中加载图片和使用 <code>new Image()</code> 设置 <code>src</code> 都会触发相同的图片加载过程，但是 <strong>使用 <code>new Image()</code> 进行预加载</strong> 提供了更灵活的控制，使得你可以在页面渲染时避免图片加载阻塞，提升页面的加载速度和用户体验。</p>
<h3 data-id="heading-9">（补充：<a href="https://juejin.cn/post/7441842559386583077" target="_blank" title="https://juejin.cn/post/7441842559386583077">代码示例小demo传送门</a>)</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7521eff755e40e9b0bd23a0426ba0c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN54ix6K-06K-d6YOt5b6357qy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1739317541&amp;x-signature=EG2b%2Bm0aS%2BeOUQfPrvFJtV%2FDzho%3D" alt="1再见.png" loading="lazy"></p></div></div>