
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wenbochang/p/18788003" title="发布于 2025-03-23 16:36">
    <span role="heading" aria-level="2">CompletableFuture你真的懂了么，我劝你在项目中慎用</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-前言">1. 前言</h1>
<p>在实际做项目中，我们经常使用多线程、异步的来帮我们做一些事情。</p>
<p>比如用户抽取奖品，异步的给他发一个push。</p>
<p>又比如一段前后不相关的业务逻辑，原本是顺序执行，耗时=(A + B + C），现在使用多线程加快执行速度，耗时=Max(A, B, C)。</p>
<p>这时候很多时候为了方便，我们就直接使用<code>CompletableFuture</code>来处理，但它真的好多坑，让我们一一细说。</p>
<h1 id="2-completablefuture原理">2. CompletableFuture原理</h1>
<h3 id="21-completablefuture-api">2.1 CompletableFuture API</h3>
<p>在CompletableFuture中提交任务有以下几种方式</p>
<pre><code class="language-java">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) 
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) 
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) 
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)
</code></pre>
<p>这四个方法都是用来提交任务的，不同的是supplyAsync提交的任务有返回值，runAsync提交的任务没有返回值。两个接口都有一个重载的方法，第二个入参为指定的线程池，如果不指定，则默认使用ForkJoinPool.commonPool()线程池。</p>
<h3 id="22-forkjoinpool">2.2 ForkJoinPool</h3>
<p>Fork/Join 框架是一种<strong>并行计算框架</strong>，设计目的是提高具有递归性质任务的执行速度。典型的任务是将问题逐步分解成较小的任务，直到每一个子任务足够简单可以直接解决，然后再将结果聚合起来。</p>
<p>Fork/Join 框架基于"工作窃取"算法 (Work Stealing Algorithm)，该算法的核心思想是每个工作线程有自己的任务队列(双端队列, <code>Deque</code>)。当一个线程完成了自己队列中的任务时，便会窃取其他线程队列中的任务执行，这样就不会因为某个线程在等待而浪费 CPU 资源。</p>
<p>Fork/Join 框架非常适合以下这些工作负载：</p>
<ul>
<li><strong>递归任务</strong>：如斐波那契数列、归并排序等分治算法。</li>
<li><strong>大规模数据处理</strong>：快速对集合、数组等进行并行操作。</li>
<li><strong>图像处理</strong>：图像处理等数据量大的任务可以被分成多个小任务并行处理。</li>
</ul>
<p>也就是说ForkJoinPool<strong>比较适用于CPU密集型，而不太适合于IO密集型</strong>。但是我们业务中大多数都是IO密集型，比如等待数据库的返回，等待下游RPC的返回，等待子方法的返回等等</p>
<h3 id="23-forkjoinpool在completablefuture中的应用">2.3 ForkJoinPool在CompletableFuture中的应用</h3>
<p>先说结论：</p>
<ol>
<li>
<p>如果你在使用<code>CompletableFuture</code>没有指定线程池，就会使用默认的<code>ForkJoinPool</code></p>
</li>
<li>
<p>CompletableFuture是否使用默认线程池的依据，和机器的CPU核心数有关。当CPU核心数-1大于1时，才会使用默认的线程池，否则将会为每个CompletableFuture的任务<strong>创建一个新线程去执行</strong>。</p>
</li>
<li>
<p>如果你的CPU核心数为4核，那么也就是最多也只有<strong>3个核心线程</strong>(3个线程，你确定够用？)</p>
</li>
</ol>
<h1 id="3-completablefuture坑">3. CompletableFuture坑</h1>
<h3 id="31-forkjoinpool线程不够用处于等待状态">3.1 ForkJoinPool线程不够用，处于等待状态</h3>
<p>小明为了加快代码的运行，将原来的A+B+C的运行逻辑，改成了(A,B,C)的运行逻辑，使用了3个<code>CompletableFuture</code>来执行，耗时从原本的900ms，缩短到了300ms，简单代码如下：</p>
<pre><code class="language-java">public void test1() {
    a();
    b();
    c();
}

public void test2() {
    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; a());
    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; b());
    CompletableFuture&lt;Integer&gt; f3 = CompletableFuture.supplyAsync(() -&gt; c());
}
</code></pre>
<p>上线后，小明心情良好，坐等升职加薪，没想到第二天却遇到了线上告警，接口频繁的超时，比之前还要慢，有些达到了10s+，小明实在想不明白。</p>
<p>后来排查发现，在项目中有大量使用到<code>CompletableFuture.supplyAsync</code>的地方，而<strong>每台机器8核，也就是7个线程，根本不够用，因此大量都是在等待线程中度过</strong>，因此耗时越来越严重，最终形成了雪崩，接口直接无限超时。</p>
<p><strong>回答</strong>：使用<code>CompletableFuture</code>必须做到线程池隔离，不能使用默认的<code>ForkJoinPool</code>线程池</p>
<h3 id="32-completablefuture反而更慢了">3.2 CompletableFuture反而更慢了？</h3>
<p>小明经过这次事件学聪明了，使用<code>CompletableFuture</code>都自己写一个线程池。过了几天线上又告警出来了，大量接口超时，小明又蒙逼了，小明的代码如下：</p>
<pre><code class="language-java">ExecutorService es = Executors.newFixedThreadPool(5);
public void test1() {
    CompletableFuture.runAsync(a(1), es);
    CompletableFuture.runAsync(b(1), es);
    CompletableFuture.runAsync(c(1), es);
}
</code></pre>
<p>后来排查发现，springmvc tomcat默认线程池是200，而你的线程池只有5个，也就是说，当接口请求了攀升。</p>
<p>比如现在有200个请求过来，执行到test1的时候，如果不使用线程池，反而没任何问题。但是使用到了线程池，5个线程池根本不够用，等待线程的释放，那么会越来越慢，最终拖垮整个服务。</p>
<h3 id="33-completablefuture死锁">3.3 CompletableFuture死锁？</h3>
<p>小明说我再也不使用<code>CompletableFuture</code>了，小明说我直接调大线程池到200，那肯定没问题了，读者们思考下是否可行。答案是绝对不可行的，核心线程设置那么大，对cpu消耗非常严重，一定要设置合理的范围内。</p>
<p>再来看一个死锁问题，终于不是小明的锅了，这次轮到了小红，以下是死锁的代码：</p>
<pre><code class="language-java">ExecutorService es = Executors.newFixedThreadPool(5);
public void test() {
    for (int i = 0; i &lt; 5; i++) {
       CompletableFuture.runAsync(() -&gt; a(), es); 
    }
}

public void a() {
    CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(() -&gt; 1, es);
    try {
       f.get();
    } catch (Exception e) {}
}
</code></pre>
<p>这里不卖关子了。由于是5个线程，在test方法中，将5个线程全部使用，然后test调用子方法a的时候。由于<strong>共用</strong>同一个线程池es，a方法永远获取不到线程池，a方法永远不可能执行成功，那么test方法也永远执行不了成功，那么就会处于永远阻塞死锁的这么一个线程。</p>
<p>因此解决办法就是，不同的业务尽量不要使用同一个线程池，为自己业务定制自己的线程池，而不是为了方便，共用一个commonPool。</p>
<h1 id="4-最后">4. 最后</h1>
<p>通过以上对<code>CompletableFuture</code>的分析，以及一些实际踩坑的案例，相信你对<code>CompletableFuture</code>用法更加的了解了。</p>
<p>最后还是想说明一点，在业务代码中，<strong>能不使用多线程就不使用多线程</strong>，因为它带来的副作用远远比带来的好处要多的多得多，除非你非常清楚其中的原理。</p>
<p><code>CompletableFuture</code>你真的懂了么？欢迎评论区留言讨论。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07197389326620371" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-23 16:37">2025-03-23 16:36</span>&nbsp;
<a href="https://www.cnblogs.com/wenbochang">程序员博博</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18788003" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18788003);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18788003', targetLink: 'https://www.cnblogs.com/wenbochang/p/18788003', title: 'CompletableFuture你真的懂了么，我劝你在项目中慎用' })">举报</a>
</div>
        