
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jyzhao/p/18786055/jie-juelinux-xia-wen-ben-wen-jian-zhong-wen-luan-m" title="发布于 2025-03-21 23:11">
    <span role="heading" aria-level="2">解决Linux下文本文件中文乱码问题</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.5468814552407407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 23:11">2025-03-21 23:11</span>&nbsp;
<a href="https://www.cnblogs.com/jyzhao">AlfredZhao</a>&nbsp;
阅读(<span id="post_view_count">46</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18786055" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18786055);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18786055', targetLink: 'https://www.cnblogs.com/jyzhao/p/18786055/jie-juelinux-xia-wen-ben-wen-jian-zhong-wen-luan-m', title: '解决Linux下文本文件中文乱码问题' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上一篇我们提到了OS和DB的一些<a href="https://mp.weixin.qq.com/s/Tqr-rq5S_z0JJHKTFc_30g" target="_blank" rel="noopener nofollow">中文乱码问题</a>解决，本篇我们继续介绍下在OS上的文本文件中文乱码问题。</p>
<p>操作系统是Linux(OEL 8.10)，所有文件是打了一个压缩包上传的，上传解压后发现其中的文本文件中文乱码。类似现象如下：</p>
<pre><code class="language-bash">[oracle@dbtest AIDIR]$ cat yy.txt 
ʵa) (b)֪
Ʒ
b)a)ʵ0;
</code></pre>
<p>这通常是文本文件的字符编码导致。</p>
<p>举个例子。</p>
<p>现在有两个文件：</p>
<ul>
<li>xx.txt是我自己vi编辑新建的</li>
<li>yy.txt这里代表的是同事发我的一些测试文件</li>
</ul>
<pre><code class="language-bash"># 两个测试文本文件 xx.txt, yy.txt
[oracle@dbtest AIDIR]$ ls -l xx.txt
-rw-r--r-- 1 oracle oinstall 38 Mar 20 01:50 xx.txt
[oracle@dbtest AIDIR]$ ls -l yy.txt
-rw-r--r-- 1 oracle oinstall 291 Mar 20 01:50 yy.txt
# 使用file -i 文件名 查看其字符编码
[oracle@dbtest AIDIR]$ file -i xx.txt
xx.txt: text/plain; charset=utf-8
[oracle@dbtest AIDIR]$ file -i yy.txt
yy.txt: text/plain; charset=iso-8859-1
</code></pre>
<p>看到两个文件是<code>charset=utf-8</code>和<code>charset=iso-8859-1</code>，但同事已经提前告诉我相关测试文件是GBK编码的，所以我不需要过多考虑。</p>
<p>至于为什么显示iso-8859-1，是因为 file 命令有时可能会错误识别 GBK 为 ISO-8859-1。</p>
<p>所以这里真实情况是，分别是UTF-8和GBK。</p>
<p>下面需要的就是如何转换编码，需要用到iconv这个命令：</p>
<blockquote>
<p>iconv 是一个用于 字符编码转换 的命令，在 Unix/Linux 系统中常见，主要用于不同字符集（如 GBK、UTF-8、ISO-8859-1 等）之间的转换。</p>
</blockquote>
<p>使用iconv 命令尝试转换yy.txt到yy1.txt：</p>
<pre><code class="language-bash">iconv -f GBK -t UTF-8 yy.txt &gt; yy1.txt
</code></pre>
<p>若文件中的中文字符显示正常，说明我们的推断正确。</p>
<p>但涉及的文件其实很多，那么我们需要批量处理下：</p>
<h2 id="方案1基于现有文件名按规则生成新文件">方案1：基于现有文件名，按规则生成新文件</h2>
<p>保留现有文件，安全可控，新的文件是依据现有文件名，额外添加了<code>_utf8</code>标识。</p>
<pre><code class="language-bash">for file in *.txt; do
    iconv -f GBK -t UTF-8 "$file" -o "${file%.txt}_utf8.txt"
done
</code></pre>
<h2 id="方案2直接覆盖现有文件">方案2：直接覆盖现有文件</h2>
<p>文件名不变，适用于需要保持原文件路径的场景。<br>
因为我的源文件是有备份的，所以可以采纳这种方法。</p>
<pre><code class="language-bash">for file in *.txt; do
    iconv -f GBK -t UTF-8 "$file" -o tmpfile &amp;&amp; mv tmpfile "$file"
done
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    AlfredZhao©版权所有「从Oracle起航，领略精彩的IT技术。」
</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="jyzhao" blog-id="186567" post-id="18786055"></vc:categories-tags>
    </ul>
