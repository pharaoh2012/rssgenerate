
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/shootdown/p/18919304" title="发布于 2025-06-08 13:45">
    <span role="heading" aria-level="2">P1155 [NOIP 2008 提高组] 双栈排序</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>将一组数据分成两组，且组内不能冲突。考虑使用二分图。</p>
<p>我们来思考什么样的两个数不能存在于一个栈中。因为最后要求我们升序排序输出，所以在一个栈中的数字必定是降序。</p>
<p>那么当 <span class="math inline">\(i&lt;j\)</span> 时并且 <span class="math inline">\(p_i&lt;p_j\)</span>。<span class="math inline">\(i,j\)</span> 便不能存在于同一个栈中吗？</p>
<p>显然不是，我们来看 <span class="math inline">\(P=\left [1,3,2,4\right ]\)</span>。前两个数 <span class="math inline">\(1,3\)</span> 是可以满足上文的情况的，但是<strong>他们可以存在在一个栈里面</strong>。为什么会造成这种情况呢？我们发现数字 <span class="math inline">\(1\)</span> 入栈后就可以直接弹，因为它后面没有比它小的数字了。</p>
<p>所以我们还要加一个附加条件。即当 <span class="math inline">\(i&lt;j&lt;k\)</span> 且 <span class="math inline">\(p_k&lt;p_i&lt;p_j\)</span>  满足时，<span class="math inline">\(i,j\)</span> 不能共存于一个栈中。之后我们便在 <span class="math inline">\(i,j\)</span> 之间建边，去做二分图即可。</p>
<p>之后我们考虑如何让字典序最小，观察到两个栈的操作是独立的，那么如果相邻的两个操作是一个栈插入，另一个栈弹出，那么可以交换位置，以此让字典序达到最小。</p>
<p>讲的很详细了，代码就不放注释了。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1007;
int n,a[N],cnt=1,tot;
stack&lt;int&gt; s1,s2;
vector&lt;int&gt; G[N];
char ans[N*3];
bool vis[N],col[N];
void dfs(int u,int co){
//	cout&lt;&lt;u&lt;&lt;' '&lt;&lt;co&lt;&lt;'\n';
	vis[u]=1,col[u]=co;
	for(auto v:G[u]){
		if(vis[v]) {
			if(col[v]==col[u]) {
				cout&lt;&lt;0;
				exit(0);
			}
			continue;
		}
		dfs(v,co^1);
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	for(int i=n-1,x=a[n];i&gt;1;i--){
		for(int j=i-1;j&gt;=1;j--){
			if(a[j]&lt;a[i]&amp;&amp;x&lt;a[j]) G[a[j]].push_back(a[i]),G[a[i]].push_back(a[j]);
		}
		x=min(x,a[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(!vis[a[i]]) dfs(a[i],0);
	}
//	for(int i=1;i&lt;=n;i++) cout&lt;&lt;col[i]&lt;&lt;' ';
//	cout&lt;&lt;'\n';
	for(int i=1;i&lt;=n;i++){
		if(col[a[i]]==0) ans[++tot]+='a',s1.push(a[i]);
		else ans[++tot]+='c',s2.push(a[i]);
		while((!s1.empty()&amp;&amp;s1.top()==cnt)||(!s2.empty()&amp;&amp;s2.top()==cnt)){
			if(!s1.empty()&amp;&amp;s1.top()==cnt) ans[++tot]='b',s1.pop(),cnt++;
			else ans[++tot]='d',s2.pop(),cnt++;
		}
	}
	for(int i=tot-1;i&gt;=1;i--){
		for(int j=i;j&lt;tot;j++){
			if((ans[j]=='c'&amp;&amp;ans[j+1]=='b')||(ans[j]=='d'&amp;&amp;ans[j+1]=='a')) swap(ans[j],ans[j+1]);
			else break;
		}
	}
	for(int i=1;i&lt;=tot;i++) cout&lt;&lt;ans[i]&lt;&lt;' ';
	return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.18744662741087964" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-08 13:45">2025-06-08 13:45</span>&nbsp;
<a href="https://www.cnblogs.com/shootdown">shoot_down</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18919304);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18919304', targetLink: 'https://www.cnblogs.com/shootdown/p/18919304', title: 'P1155 [NOIP 2008 提高组] 双栈排序' })">举报</a>
</div>
        