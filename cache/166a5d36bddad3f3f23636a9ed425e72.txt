
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/19012497" title="发布于 2025-07-31 08:58">
    <span role="heading" aria-level="2">【MySQL索引失效场景】索引失效原因及最左前缀原则详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>好的，我们来详细解释一下<strong>最左前缀匹配原则</strong>，并尽可能全面地列出典型的<strong>索引失效情况</strong>，每个情况都配上示例。</p>
<h2 id="一最左前缀匹配原则-leftmost-prefix-rule">一、最左前缀匹配原则 (Leftmost Prefix Rule)</h2>
<ul>
<li><strong>核心概念：</strong> 当你在数据库表上创建了一个<strong>复合索引</strong>（也叫联合索引，包含多个列）时，这个索引可以被用来加速那些查询条件<strong>只使用了该索引最左边一个或连续多个列</strong>的查询。它并不要求查询条件必须包含索引中的所有列，但必须<strong>从最左边的列开始，并且是连续的</strong>（不能跳过中间的列）。</li>
<li><strong>类比理解：</strong> 想象一本电话簿，它首先按姓氏排序，姓氏相同再按名字排序。
<ul>
<li>查找“姓张的人”（只用最左列姓氏） - ✅ 索引有效（快速定位到所有张姓区域）</li>
<li>查找“姓张且名三的人”（用了连续的姓氏+名字） - ✅ 索引有效（在张姓区域内快速找到张三）</li>
<li>查找“名叫三的人”（只用名字，跳过了姓氏） - ❌ 索引无效（必须扫描整本书，因为名字的排序只在同姓下有效）</li>
<li>查找“姓张且出生日期是某天的人”（用了姓氏，跳过了名字，用了出生日期） - ❌ 索引无效（在张姓区域内，出生日期不是按索引排序的，除非索引包含了出生日期且名字条件用<code>IS NULL</code>或范围覆盖了所有可能名字，但这很特殊且通常低效）。</li>
</ul>
</li>
<li><strong>数据库底层原理 (B+树)：</strong> 复合索引在B+树中存储时，数据首先按索引定义的第一列排序，在第一列值相同的情况下，按第二列排序，以此类推。查询时，数据库只能有效地利用索引进行查找，如果它能提供一个或多个索引列的值，并且这些值是从索引定义的最左边开始的连续列。</li>
<li><strong>关键点总结：</strong>
<ol>
<li><strong>必须从最左列开始。</strong></li>
<li><strong>不能跳过中间的列。</strong> （除非跳过的列在查询条件中是<code>IS NULL</code>或使用了覆盖索引等特定情况，但通常视为失效或效率降低）</li>
<li><strong>可以只使用最左边连续的若干列。</strong></li>
<li><strong>范围查询后的列无法使用索引排序或精确匹配。</strong></li>
</ol>
</li>
</ul>
<h2 id="二典型的索引失效情况与示例">二、典型的索引失效情况与示例</h2>
<p>假设我们有一个用户表 <code>users</code>，并在其上创建了一些索引：</p>
<pre><code class="language-sql">CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    age INT,
    country VARCHAR(50),
    city VARCHAR(50),
    created_at DATETIME NOT NULL,
    INDEX idx_username (username), -- 单列索引
    INDEX idx_country_city (country, city), -- 复合索引
    INDEX idx_age_created (age, created_at) -- 复合索引
);
</code></pre>
<h3 id="典型索引失效情况">典型索引失效情况</h3>
<ol>
<li>
<p><strong>未遵循最左前缀原则 (跳过了最左列):</strong></p>
<ul>
<li><strong>原因:</strong> 复合索引 <code>(col1, col2, col3)</code> 的排序依赖于 <code>col1</code>。跳过 <code>col1</code> 直接查询 <code>col2</code> 或 <code>col3</code>，数据库无法利用索引的有序性进行快速定位。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE city = 'New York'; -- 索引 idx_country_city 失效，因为跳过了最左列 `country`
SELECT * FROM users WHERE created_at &gt; '2023-01-01'; -- 索引 idx_age_created 失效，因为跳过了最左列 `age`
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>在索引列上使用函数或表达式:</strong></p>
<ul>
<li><strong>原因:</strong> 索引存储的是列的原始值。对列应用函数或表达式后，数据库无法直接使用索引值进行匹配，需要计算每一行的函数结果后再比较。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE YEAR(created_at) = 2023; -- 在 created_at 上使用了 YEAR() 函数，任何包含 created_at 的索引都失效
SELECT * FROM users WHERE age + 1 &gt; 30; -- 在 age 上进行了计算，索引 idx_age_created 失效
SELECT * FROM users WHERE UPPER(username) = 'JOHNDOE'; -- 在 username 上使用了 UPPER() 函数，索引 idx_username 失效
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>在索引列上进行运算:</strong></p>
<ul>
<li><strong>原因:</strong> 同函数一样，运算改变了列的原始值。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE id * 2 = 100; -- 在 id (主键索引) 上进行了乘法运算，索引失效
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>OR</code> 连接非索引列条件:</strong></p>
<ul>
<li><strong>原因:</strong> 如果 <code>OR</code> 连接的多个条件中，<strong>并非所有涉及的列都单独建立了索引</strong>，数据库通常无法有效合并索引扫描结果（除非优化器选择 Index Merge 策略，但这并非总是可行或高效），最终可能退化为全表扫描。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE username = 'john' OR email = 'john@example.com';
-- 情况1: 只有 idx_username 存在，email 无索引 -&gt; 索引 idx_username 对 OR 条件整体失效（需全表扫）。
-- 情况2: 如果同时存在 idx_username 和 idx_email -&gt; 优化器 *可能* 使用 Index Merge 策略（如 union），此时两个索引都可能有效。但这取决于数据库优化器选择和版本。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>隐式类型转换:</strong></p>
<ul>
<li><strong>原因:</strong> 当查询条件中的值类型与索引列定义的类型不匹配时，数据库需要执行隐式类型转换。这相当于在列上应用了一个转换函数，导致索引失效。</li>
<li><strong>示例:</strong><pre><code class="language-sql">-- 假设 phone 字段是 VARCHAR(20) 且有索引
SELECT * FROM users WHERE phone = 13800138000; -- 数字 13800138000 被隐式转换为字符串，导致 phone 索引失效
-- 假设 age 是 INT 且有索引
SELECT * FROM users WHERE age = '30'; -- 字符串 '30' 被隐式转换为整数，通常 *可能不会* 导致索引失效（因为转换是确定性的且发生在常量端），但写法不推荐且依赖数据库实现。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>!=</code> 或 <code>&lt;&gt;</code> (不等于):</strong></p>
<ul>
<li><strong>原因:</strong> 不等于操作符需要查找所有不等于特定值的行。对于非唯一索引或非主键索引，数据库通常认为扫描整个索引或全表扫描比利用索引定位再过滤掉大量数据更高效（除非不等于的值匹配了极少数行，且优化器能识别）。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE username &lt;&gt; 'admin'; -- 索引 idx_username 很可能失效（除非 'admin' 是绝大多数行）
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>NOT IN</code> 或 <code>NOT EXISTS</code>:</strong></p>
<ul>
<li><strong>原因:</strong> 类似于 <code>!=</code>，需要排除大量数据，优化器倾向于全表扫描。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE country NOT IN ('US', 'UK'); -- 索引 idx_country_city 失效
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> (对非稀疏索引):</strong></p>
<ul>
<li><strong>原因:</strong> 标准B+树索引通常不存储 <code>NULL</code> 值（或将其视为特殊值）。查询 <code>IS NULL</code> 时，如果索引不包含 <code>NULL</code> 记录，则无法使用索引。查询 <code>IS NOT NULL</code> 时，需要排除 <code>NULL</code>，这通常相当于扫描所有非 <code>NULL</code> 值，优化器可能认为全表扫描更快。<strong>注意：</strong> 有些数据库（如 MySQL InnoDB）的二级索引是包含 <code>NULL</code> 值的，理论上 <code>IS NULL</code> 在特定条件下可能使用索引（如果 <code>NULL</code> 值很少），但 <code>IS NOT NULL</code> 通常仍会导致索引失效。<strong>实践中，通常认为两者都可能导致索引失效。</strong></li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE email IS NULL; -- 索引 (如果有在 email 上) 可能有效也可能无效，取决于数据库和 NULL 比例
SELECT * FROM users WHERE email IS NOT NULL; -- 索引 (如果有在 email 上) 很可能失效
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用前导通配符的 <code>LIKE</code> (<code>%xxx</code>):</strong></p>
<ul>
<li><strong>原因:</strong> 索引是按列值的完整内容排序的。以通配符 <code>%</code> 开头意味着模式的前缀是未知的，数据库无法利用索引的有序性进行快速定位（就像电话簿里找名字以 "son" 结尾的人一样困难）。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE username LIKE '%doe'; -- 索引 idx_username 失效
SELECT * FROM users WHERE username LIKE '%john%'; -- 索引 idx_username 失效 (两个 %)
</code></pre>
</li>
<li><strong>例外:</strong> <code>LIKE 'xxx%'</code> (后缀通配符) 通常<strong>可以</strong>有效利用索引，因为模式的开头是固定的。</li>
</ul>
</li>
<li>
<p><strong>复合索引中，第一列使用范围查询后，后续列索引失效:</strong></p>
<ul>
<li><strong>原因:</strong> 复合索引 <code>(col1, col2)</code>。当 <code>col1</code> 使用范围查询（<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>）时，数据库可以快速定位到 <code>col1</code> 满足范围的索引片段。但是，<strong>在这个片段内部，<code>col2</code> 的值是无序的</strong>（索引只在 <code>col1</code> 相同的情况下才按 <code>col2</code> 排序）。因此，对于 <code>col2</code> 的条件，数据库无法利用索引进行排序或高效的精确匹配/范围扫描，通常需要在 <code>col1</code> 的范围结果内逐行扫描过滤 <code>col2</code>。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE country = 'US' AND city = 'New York'; -- ✅ 索引 (country, city) 有效 (等值+等值)
SELECT * FROM users WHERE country = 'US' AND city LIKE 'N%'; -- ✅ 索引有效 (等值+后缀通配符)
SELECT * FROM users WHERE country IN ('US', 'CA') AND city = 'Seattle'; -- ❗ 对于 IN 内的每个 country，city 条件有效。但整体效率取决于 IN 列表大小和优化器。通常认为部分有效。
SELECT * FROM users WHERE country &gt; 'C' AND city = 'London'; -- ❌ `country` 是范围查询，`city` 条件无法利用索引排序和高效过滤。索引对 `city` 条件失效。
SELECT * FROM users WHERE age BETWEEN 20 AND 30 AND created_at = '2023-10-01'; -- ❌ `age` 是范围查询，`created_at` 条件无法利用索引。索引 idx_age_created 对 `created_at` 失效。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>查询列未被索引覆盖且需要回表，优化器判断全表扫描更快:</strong></p>
<ul>
<li><strong>原因:</strong> 如果 <code>SELECT *</code> 或者查询了不在索引中的列，数据库即使使用了索引定位行，也需要根据索引中的指针（通常是主键值）回到主键索引（聚簇索引）或数据文件中取出完整的行数据（称为 <strong>回表</strong>）。如果筛选条件过滤掉的行很少（即满足条件的行数非常多），优化器可能认为直接扫描整个表（尤其是如果表很小或大部分数据在内存中）比通过索引查找再大量回表更高效。</li>
<li><strong>示例:</strong><pre><code class="language-sql">-- 假设表很大，但 country='XX' 是一个非常大的国家，占表中大部分数据
SELECT * FROM users WHERE country = 'XX'; -- 虽然有索引 idx_country_city, 但优化器可能选择全表扫描，避免大量回表操作。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>索引列选择性过低 (数据重复度过高):</strong></p>
<ul>
<li><strong>原因:</strong> 如果索引列的值几乎都一样（例如 <code>gender</code> 列只有 'M'/'F'），那么使用这个索引筛选出的行数仍然非常多，数据库优化器可能会认为使用索引带来的好处（减少IO）不足以抵消额外的索引查找和可能的回表开销，从而选择全表扫描。</li>
<li><strong>示例:</strong><pre><code class="language-sql">-- 假设 country 列 90% 的值都是 'US'
SELECT * FROM users WHERE country = 'US'; -- 虽然有索引 idx_country_city, 但优化器很可能选择全表扫描。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>ORDER BY</code> 的列与索引排序方式不一致:</strong></p>
<ul>
<li><strong>原因:</strong> 索引默认是升序 (<code>ASC</code>) 存储的。如果 <code>ORDER BY</code> 子句使用了索引列，但是排序方向是降序 (<code>DESC</code>)，或者混合了升序降序（且与索引定义不一致），数据库可能无法直接利用索引的有序性来避免额外的排序操作（<code>filesort</code>）。</li>
<li><strong>示例:</strong><pre><code class="language-sql">SELECT * FROM users WHERE country = 'US' ORDER BY city DESC; -- 索引 (country, city ASC) 可能用于 WHERE, 但 ORDER BY city DESC 需要额外排序。
-- 创建索引 (country, city DESC) 可以优化这个查询。
SELECT * FROM users ORDER BY country ASC, city DESC; -- 索引 (country ASC, city ASC) 无法直接用于此混合排序。
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>统计信息过时:</strong></p>
<ul>
<li><strong>原因:</strong> 数据库优化器依赖表和索引的统计信息（如行数、不同值数量、数据分布直方图）来估算不同执行计划的成本。如果这些统计信息没有及时更新（例如在大量插入、删除、更新后），优化器可能会错误地估算使用索引的成本，从而选择次优计划（如本应使用索引却选择了全表扫描，或相反）。</li>
<li><strong>示例:</strong> 没有特定查询示例，这是一个维护问题。需要定期运行数据库的 <code>ANALYZE TABLE</code> 或类似命令更新统计信息。</li>
</ul>
</li>
</ol>
<h2 id="关键建议">关键建议</h2>
<ol>
<li><strong>善用 <code>EXPLAIN</code>:</strong> 这是诊断查询执行计划和索引使用情况的最重要工具。在你写的 SQL 语句前加上 <code>EXPLAIN</code> (或 <code>EXPLAIN ANALYZE</code>)，分析输出结果中的 <code>key</code> (使用的索引)、<code>type</code> (访问类型，如 <code>ref</code>, <code>range</code>, <code>index</code>, <code>ALL</code> 表示全表扫描)、<code>Extra</code> (额外信息，如 <code>Using where</code>, <code>Using filesort</code>, <code>Using index</code>) 等字段。</li>
<li><strong>设计合适的索引:</strong> 根据最频繁的查询模式（<code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>, <code>GROUP BY</code>）来设计索引，优先考虑高选择性的列，并遵循最左前缀原则。</li>
<li><strong>考虑覆盖索引:</strong> 如果查询只需要访问索引中包含的列，就可以避免回表操作，显著提升性能 (<code>EXPLAIN</code> 的 <code>Extra</code> 列会显示 <code>Using index</code>)。</li>
<li><strong>避免过度索引:</strong> 索引会占用空间，并在数据插入、更新、删除时带来维护开销。只为必要的查询创建索引。</li>
<li><strong>保持统计信息准确:</strong> 定期更新表统计信息，让优化器做出更明智的决定。</li>
<li><strong>理解数据库特性:</strong> 不同数据库管理系统（MySQL, PostgreSQL, SQL Server, Oracle）在索引实现和优化器行为上可能存在细微差异，查阅官方文档了解细节。</li>
</ol>
<p>通过理解最左前缀原则和这些典型的索引失效场景，你可以更有效地设计索引、编写高效的SQL查询，并诊断性能问题。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-31 08:58">2025-07-31 08:58</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">174</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19012497);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19012497', targetLink: 'https://www.cnblogs.com/sun-10387834/p/19012497', title: '【MySQL索引失效场景】索引失效原因及最左前缀原则详解' })">举报</a>
</div>
        