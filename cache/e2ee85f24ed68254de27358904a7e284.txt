
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wjw2003512/p/19037447" title="发布于 2025-08-14 11:38">
    <span role="heading" aria-level="2">磁盘挂载和Kafka概念和使用场景理解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1磁盘挂载到底在挂什么" rel="noopener nofollow">1.磁盘挂载：到底在“挂”什么？</a></li><li><a href="#2topic-到底是什么" rel="noopener nofollow">2.Topic 到底是什么？</a></li><li><a href="#3客户端能不能自己建-topic" rel="noopener nofollow">3.客户端能不能自己建 Topic？</a></li><li><a href="#4java-是必须的吗" rel="noopener nofollow">4.Java 是必须的吗？</a></li><li><a href="#5结论速查表" rel="noopener nofollow">5.结论速查表</a></li><li><a href="#6三副本高可用的话三台云主机是什么关系应该是每个主机上给一个brokerbroker是啥然后需要构建一主两从吗然后topic的理解是什么类似于创建数据库之后的用户自己建表那我如何理解kafka是什么呢" rel="noopener nofollow">6.三副本高可用的话三台云主机是什么关系？应该是每个主机上给一个broker（broker是啥），然后需要构建一主两从吗？然后topic的理解是什么？类似于创建数据库之后的用户自己建表？那我如何理解kafka是什么呢？</a><ul><li><a href="#3-台云主机--3-个独立进程broker" rel="noopener nofollow">①3 台云主机 = 3 个独立进程（Broker）</a></li><li><a href="#topic--数据库里的库表" rel="noopener nofollow">②Topic ≈ 数据库里的“库.表”</a></li><li><a href="#客户端自己建-topic" rel="noopener nofollow">③客户端自己建 Topic</a></li><li><a href="#kafka-在整条链路中的位置" rel="noopener nofollow">④Kafka 在整条链路中的位置</a></li></ul></li></ul></div><p></p>
<p>下面用 4 张图 + 1 张表，把「磁盘挂载」「三副本高可用」「Topic 本质」「客户端能否自行建 Topic」「Java 依赖」一口气讲透。</p>
<p>──────────────────</p>
<h4 id="1磁盘挂载到底在挂什么">1.磁盘挂载：到底在“挂”什么？</h4>
<p>• 定义：把云盘（/dev/vdb）映射到操作系统的一个目录（/data）。<br>
• 原理：Linux 一切皆文件，mount 只是把块设备挂到目录树的一个“入口”。<br>
• Kafka 场景：Kafka 的所有日志段（.log / .index / .timeindex）都会写到 log.dirs=/data/kafka-logs。这样：<br>
– 系统盘坏了，数据盘还在；<br>
– 实例想重装，数据盘解挂 → 挂到新实例即可“原地复活”。</p>
<p>（以上这两个场景的意义<strong>是针对「磁盘挂载」本身</strong>的，而不是 Kafka 特有的）</p>
<p>──────────────────</p>
<h4 id="2topic-到底是什么">2.Topic 到底是什么？</h4>
<p>• 类比：Topic 像“数据库里的表”，Producer 写入“表”，Consumer 读取“表”。<br>
• 物理形态：一个 Topic 会被拆成 1…N 个 Partition → 每个 Partition 是一组只追加的文件段（Segment）。<br>
• 副本：为了让数据不丢，每个 Partition 做 3 份拷贝（Leader + 2 Follower），分布在 3 台 Broker（云主机）上。<br>
因此「三副本高可用」最少要 3 台云主机，否则无法“跨机冗余”。</p>
<p>──────────────────</p>
<h4 id="3客户端能不能自己建-topic">3.客户端能不能自己建 Topic？</h4>
<p>• 默认：auto.create.topics.enable=true 时，Producer 第一次往不存在的 Topic 发消息，Kafka 会自动按默认参数（分区数、副本数）建 Topic。<br>
• 生产建议：把该参数关掉，由运维通过脚本提前建 Topic 并制定分区/副本/ACL。<br>
• 结论：不是“必须”3 台云主机才能建 Topic，而是“三副本高可用”本身就要求 ≥3 台 Broker。</p>
<p>──────────────────</p>
<h4 id="4java-是必须的吗">4.Java 是必须的吗？</h4>
<p>• Kafka Server：100 % 跑在 JVM 上，必须装 JDK 11（旧版 8 也行）。<br>
• 客户端：<br>
– Java/Scala 客户端：需要 JDK。<br>
– 其他语言：官方提供 librdkafka（C/C++）、confluent-kafka-python、confluent-kafka-go 等，都是 native 实现，不依赖系统 JDK。<br>
所以只有「Broker 节点」必须装 Java；业务侧用什么语言都行。</p>
<p>──────────────────</p>
<h4 id="5结论速查表">5.结论速查表</h4>
<table>
<thead>
<tr>
<th>疑问点</th>
<th>最短答案</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>三副本高可用最少几台云主机？</td>
<td>3 台</td>
<td>每台跑 1 个 Broker</td>
</tr>
<tr>
<td>客户端能否自行建 Topic？</td>
<td>可以（auto.create.topics.enable=true）</td>
<td>生产环境建议关闭</td>
</tr>
<tr>
<td>Topic 是什么？</td>
<td>逻辑上的“消息表”，物理上是若干只追加日志段</td>
<td>每个表可拆多分区</td>
</tr>
<tr>
<td>Kafka 必须 Java 吗？</td>
<td>Broker 端必须 JDK；客户端视语言而定</td>
<td>推荐 OpenJDK 11</td>
</tr>
<tr>
<td>磁盘挂载用途？</td>
<td>把数据盘挂到 /data，让 Kafka 日志与系统盘分离</td>
<td>方便迁移、扩容、快照</td>
</tr>
</tbody>
</table>
<p>把上面 5 点消化后，再回头看我的部署脚本，你会发现每一步都在解决这 5 个核心问题。</p>
<p>──────────────────</p>
<h4 id="6三副本高可用的话三台云主机是什么关系应该是每个主机上给一个brokerbroker是啥然后需要构建一主两从吗然后topic的理解是什么类似于创建数据库之后的用户自己建表那我如何理解kafka是什么呢">6.三副本高可用的话三台云主机是什么关系？应该是每个主机上给一个broker（broker是啥），然后需要构建一主两从吗？然后topic的理解是什么？类似于创建数据库之后的用户自己建表？那我如何理解kafka是什么呢？</h4>
<p>一句话先把概念拍扁：<br>
Kafka = 一个<strong>高吞吐、可持久化、分布式的日志系统（消息队列 + 流存储）</strong>。<br>
它把“一条消息”当成<strong>追加写死的日志记录</strong>，所有 Producer 只负责“写日志”，所有 Consumer 只负责“按顺序读日志”。</p>
<p>下面用 4 张图把 3 副本、Broker、Topic、数据库类比全对齐。</p>
<p>──────────────────</p>
<h5 id="3-台云主机--3-个独立进程broker">①3 台云主机 = 3 个独立进程（Broker）</h5>
<p>• 每台云主机跑 1 个 JVM 进程，官方叫 <strong>Broker</strong>（直译“代理人”）。<br>
• 这 3 个 Broker <strong>地位完全对等</strong>，没有“主节点”“从节点”的概念，只有 <strong>Leader/Follower 是针对分区（Partition）级别</strong>的。<br>
举个例子：<br>
──Topic A-Partition0：Leader 在 Broker1，Follower 在 Broker2/3<br>
──Topic A-Partition1：Leader 在 Broker2，Follower 在 Broker1/3<br>
──Topic B-Partition0：Leader 在 Broker3，Follower 在 Broker1/2<br>
所以<strong>不存在整集群意义上的“一主两从”</strong>，而是“<strong>每个分区一主多从</strong>”。</p>
<p>先把那三行“乱码”拆成大白话，你就能一眼看懂：</p>
<p>──────────────────</p>
<ul>
<li>Topic A-Partition0：Leader 在 Broker1，Follower 在 Broker2/3<br>
读法：<br>
• Topic A 的第 0 号分区（Partition0）<br>
• 这一分区的“主副本”落在 <strong>Broker1</strong>（负责所有读写）。<br>
• 另外两台机器（Broker2、Broker3）各存一份“从副本”Follower，只做同步备份，不对外服务。</li>
</ul>
<p>同理：<br>
• Topic A-Partition1：主副本换到 Broker2，从副本在 Broker1、Broker3。<br>
• Topic B-Partition0：主副本在 Broker3，从副本在 Broker1、Broker2。</p>
<p>──────────────────</p>
<ul>
<li>
<p>那串“分数”到底是啥？</p>
<p>Topic A-Partition0：Leader 在 Broker1，Follower 在 Broker2/3 那这个的意思就是从副本在broker2和3的意思，没有分数！</p>
<p>只是 <strong>“分区号”</strong>（0、1、2…）和 <strong>“Broker 编号”</strong>（1、2、3）。<br>
写成“Topic A-Partition0”就是“Topic A 的第 0 号分区”，不是 0 分、1 分的意思。</p>
<p>比如上面第一个：──Topic A-Partition0：Leader 在 Broker1，Follower 在 Broker2/3</p>
<p>每个分区在 3 台 Broker 上各放一份：<br>
Leader 在 1，Follower 在 2，Follower 在 3。<br>
• 任意一台挂掉，另外两台还有完整数据，可以立即重新选主继续服务。</p>
</li>
</ul>
<p>──────────────────</p>
<ul>
<li>Leader ≠ 创建者<br>
• Leader 是 <strong>动态选出来的主副本</strong>，负责所有读写。<br>
• Follower 只是 <strong>被动同步</strong> Leader 的数据，Leader 挂了立刻重新选主。<br>
• 谁当 Leader 由 Kafka 内部控制器（Controller）自动决定，跟“谁建的 Topic”毫无关系。</li>
</ul>
<p>──────────────────</p>
<ul>
<li>再给你一个极简对照表，彻底把“名词”和“现实”对上号：</li>
</ul>
<table>
<thead>
<tr>
<th>Kafka 术语</th>
<th>现实对应</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Topic</td>
<td>一张“消息表”</td>
<td>业务按主题分类</td>
</tr>
<tr>
<td>Partition</td>
<td>这张表的“第 N 个分片”</td>
<td>并行读写，提高吞吐</td>
</tr>
<tr>
<td>Broker</td>
<td>一台云主机上的一个 Kafka 进程</td>
<td>负责存这些分片</td>
</tr>
<tr>
<td>Leader</td>
<td>某分片的主副本</td>
<td>所有读写都找它</td>
</tr>
<tr>
<td>Follower</td>
<td>同一分片的备份副本</td>
<td>同步数据，Leader 挂了就顶上</td>
</tr>
<tr>
<td>3 副本</td>
<td>每个分片存 3 份</td>
<td>任意 2 台机器挂掉数据仍在</td>
</tr>
</tbody>
</table>
<p>把这张表记住，你再看那三行就一目了然了。</p>
<h5 id="topic--数据库里的库表">②Topic ≈ 数据库里的“库.表”</h5>
<p>• 建 Topic ≈ 建表，里面存的是一条条“行（消息）”。<br>
• 一个 Topic 可拆 <strong>多个分区（Partition）</strong> → 类似“水平分表”，提高并发。<br>
• 每个分区存 3 份（3 副本）→ 高可用。</p>
<p>然后解释一些开通topic和使用topic，给定的是命名规则：</p>
<ol>
<li>
<p>命名：<br>
“ESX-CDN--AccessLog” 和 “TopicA-Partition1” 在 Kafka 眼里都只是字符串，没有语义区别。<br>
你爱叫 <code>order-event</code>、<code>user_click</code>、<code>whatever_you_like</code> 都行，只要满足合法字符即可。</p>
</li>
<li>
<p>使用：<br>
• 建 Topic：</p>
<pre><code class="language-bash">kafka-topics.sh --create --topic ESX-CDN--AccessLog \
  --bootstrap-server ... --partitions 3 --replication-factor 3
</code></pre>
<p>• 生产/消费时，把同样的字符串写到命令行或客户端配置里就行：</p>
<pre><code class="language-bash">kafka-console-producer.sh --topic ESX-CDN--AccessLog ...
kafka-console-consumer.sh --topic ESX-CDN--AccessLog ...
</code></pre>
<p>换句话说，“给啥就用啥”，名字出现在脚本、配置、代码里即可，Kafka 只认字符串本身。</p>
</li>
</ol>
<h5 id="客户端自己建-topic">③客户端自己建 Topic</h5>
<p>• 允许 auto.create.topics.enable=true 时，Producer 第一次写不存在的 Topic，Kafka 就自动帮你“建表”。<br>
• 关闭该参数后，必须由运维脚本 kafka-topics.sh --create … 手动“建表”。</p>
<h5 id="kafka-在整条链路中的位置">④Kafka 在整条链路中的位置</h5>
<pre><code>业务 APP ──produce──▶ Kafka（Broker 集群，3 台云主机）
                           │持久化日志（多副本）
                           ▼
业务 APP ──consume──◀ Kafka
</code></pre>
<p>因此 Kafka 不是数据库，也不是简单的 MQ，而是一个<strong>分布式、可水平扩展的提交日志系统</strong>，所有实时数据（订单、点击、日志、IoT 事件……）先写进来，再被下游各系统并发地“按顺序读”。</p>
<p>──────────────────<br>
小结一句话记忆<br>
“Kafka = 把消息当成日志，分区做并发，副本做高可用；建 Topic 就是开一张日志表，3 台云主机各自跑一个 Broker 进程，共同组成这张表的分布式存储集群。”</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-14 11:38">2025-08-14 11:38</span>&nbsp;
<a href="https://www.cnblogs.com/wjw2003512">柒寒（平安）</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19037447);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19037447', targetLink: 'https://www.cnblogs.com/wjw2003512/p/19037447', title: '磁盘挂载和Kafka概念和使用场景理解' })">举报</a>
</div>
        