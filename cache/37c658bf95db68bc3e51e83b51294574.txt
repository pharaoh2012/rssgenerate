
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CUC-MenG/p/19043655" title="发布于 2025-08-17 20:30">
    <span role="heading" aria-level="2">2025牛客多校第十场 K.神奇集合 F.老师和Yuuka逛商场 E.老师与好感度 I.矩阵 个人题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="i矩阵">I.<a href="https://ac.nowcoder.com/acm/contest/108307/I" target="_blank" rel="noopener nofollow">矩阵</a></h1>
<h1 id="数学-贪心-构造">数学 #贪心 #构造</h1>
<h2 id="题目">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250817202813135-2116223454.png" alt="image" loading="lazy"></p>
<h2 id="思路">思路</h2>
<p>首先考虑有数最受条件的约束，因此尝试令数<span class="math inline">\(x\)</span>沿着某方向前进<span class="math inline">\(x\)</span>后回到原地：</p>
<p></p><div class="math display">\[\begin{align}
(x+x+1)\%n-1&amp;=x\\ \\
(2x+1)\%n&amp;=x+1\\ \\
2x+1&amp;\equiv x+1\mod n\\ \\
x&amp;\equiv 0\mod n
\end{align}
\]</div><p></p><p>则有<span class="math inline">\(x\)</span>为<span class="math inline">\(n\)</span>的因数</p>
<p>因此，当<span class="math inline">\(x\)</span>为<span class="math inline">\(n\)</span>的因数时，<span class="math inline">\(x\)</span>无法在<span class="math inline">\(n\)</span>方向上进行移动，<span class="math inline">\(m\)</span>方向同理</p>
<p>因此，<span class="math inline">\(x=lcm(n,m)\)</span>时，<span class="math inline">\(x\)</span>一定无法移动<br>
因此<span class="math inline">\(lcm(n,m)\)</span>必须为最后一个填入的数字，可以利用这一点进行<span class="math inline">\(YES/NO\)</span>的判断</p>
<p>接下来通过观察贪心地进行填空：</p>
<ul>
<li>尝试将一列填满后再填下一列</li>
<li>尝试每填完一个数就变换一次移动方向，比如这次在列方向上向下移动，下一次列方向上的移动就向上，这样可以保证移动后不会踩到已经被填过的格子</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<p>代码由<span class="math inline">\(phaethon 90\)</span>书写</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
#define endl '\n'

ll gcd(ll a,ll b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}
void eachT()
{
    ll n,m;
    cin&gt;&gt;n&gt;&gt;m;
    if(n/gcd(n,m)*m&lt;n*m)
    {
        cout&lt;&lt;"NO\n";
        return;
    }

    vector&lt;vector&lt;int&gt;&gt;mp(n+1,vector&lt;int&gt;(m+1,0));
    int i=0,j=0,cnt=0;
    int dirn=1,dirm=1;
    mp[0][0] = ++cnt;
    while(cnt&lt;n*m)
    {
        if(cnt%n==0)
        {
            j = (j+cnt%m*dirm+m*m)%m;
            mp[i][j] = ++cnt;
            dirm *= -1;
        }
        else
        {
            i = (i+cnt%n*dirn+n*n)%n;
            mp[i][j] = ++cnt;
            dirn *= -1;
        }
    }
    cout&lt;&lt;"YES\n";
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;m;j++)
        {
            cout&lt;&lt;mp[i][j]&lt;&lt;' ';
        }
        cout&lt;&lt;endl;
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    int t=1;
    // cin&gt;&gt;t;
    while(t--) eachT();
    return 0;
}
</code></pre>
<hr>
<h1 id="e-老师与好感度">E.<a href="https://ac.nowcoder.com/acm/contest/108307/E" target="_blank" rel="noopener nofollow"> 老师与好感度</a></h1>
<h1 id="dp-线性dp">dp #线性dp</h1>
<h2 id="题目-1">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250817202823525-1190884147.png" alt="image" loading="lazy"></p>
<h2 id="思路-1">思路</h2>
<p>由于<span class="math inline">\(0\leq a_{i}\leq 100\)</span>，很容易想到要枚举最后出现的<span class="math inline">\(m\)</span>个数，考虑<span class="math inline">\(m=2\)</span>的情况，即枚举两个目标<span class="math inline">\(tar_{1},tar_{2}\)</span>（<span class="math inline">\(target\)</span>）</p>
<p>状态表示：<br>
<span class="math inline">\(dp[i][j]\)</span>表示从<span class="math inline">\(1\)</span>遍历到<span class="math inline">\(i\)</span>，第<span class="math inline">\(i\)</span>个学生的好感度变为<span class="math inline">\(tar_{j}\)</span>（<span class="math inline">\(1\leq j\leq 2\)</span>）的最小总天数</p>
<p>状态转移：</p>
<p></p><div class="math display">\[\begin{align}
&amp;dp[i][j]=\min_{0\leq k\leq[m=2]}\{dp[i][j]\ , \ dp[i-1][k]+ \max\{ tar_{j}-a_{i}-(tar_{k}-a_{i-1})\ ,\ 0 \} \},0\leq j\leq[m=2]\\ \\
&amp;if(tar_{j}-a_{i}&lt;0)dp[i][j]=inf
\end{align}
\]</div><p></p><p>当<span class="math inline">\(m=2\)</span>的时候，<span class="math inline">\(dp[i][j]\)</span>将由<span class="math inline">\(i-1\)</span>时的两个状态转移过来，分别是选<span class="math inline">\(tar_{1},tar_{2}\)</span>的状态<br>
要与<span class="math inline">\(0\)</span>取<span class="math inline">\(max\)</span>是因为<span class="math inline">\(a_{i}\)</span>与<span class="math inline">\(tar\)</span>的差距可能比较小，仅用之前的天数就可以达到目标</p>
<p>枚举<span class="math inline">\(tar_{1},tar_{2}\)</span>，每次都取全局最小值即可</p>
<p>注意，<span class="math inline">\(tar_{1}\)</span>的上下界分别为<span class="math inline">\(a_{i}\)</span>的最大值与最小值，<span class="math inline">\(tar_{2}\)</span>的上下界分别为<span class="math inline">\(200\)</span>与<span class="math inline">\(tar_{1}\)</span></p>
<p><span class="math inline">\(tar_{2}\)</span>的上界不是<span class="math inline">\(a_{i}\)</span>的最大值，因为可能会有区间覆盖在<span class="math inline">\(a_{i}\)</span>最大值上使得它变大<br>
最坏情况下，<span class="math inline">\(a_{i}\)</span>的最大值被覆盖的次数量级为<span class="math inline">\(o(n)\)</span>，因此上界设为<span class="math inline">\(100+100\)</span>即可</p>
<h2 id="代码实现-1">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
constexpr int inf = 1e9 + 5;
// #define int ll 

const int up=155;
void chmin(int&amp;x,int y){
    x=min(x,y);
}
void chmax(int&amp;x,int y){
    x=max(x,y);
}

const int N=405;
int a[N],dp[N][2],t[2];

void eachT() {   
    int n,m;cin&gt;&gt;n&gt;&gt;m;
    int ma=0,mi=inf;
    rep(i,1,n){
        cin&gt;&gt;a[i];
        chmax(ma,a[i]);
        chmin(mi,a[i]);
        dp[i][0]=dp[i][1]=inf;
    }
    int ans=inf;
    rep(tar1,mi,ma){
        rep(tar2,tar1,up){
            t[0]=tar1,t[1]=tar2;
            dp[1][0]=t[0]-a[1];
            dp[1][1]=(m==2)?t[1]-a[1]:inf;  
            if(dp[1][0]&lt;0)dp[1][0]=inf;
            if(dp[1][1]&lt;0)dp[1][1]=inf;
            rep(i,2,n){
                rep(j,0,(m==2)){
                    rep(k,0,(m==2)){
                        chmin(dp[i][j],max(t[j]-a[i]-(t[k]-a[i-1]),0)+dp[i-1][k]);
                        if(t[j]-a[i]&lt;0)dp[i][j]=inf;
                    }
                }            
            }  
            chmin(ans,min(dp[n][0],dp[n][1]));
            rep(i,2,n)dp[i][0]=dp[i][1]=inf;
        }
    }
    cout&lt;&lt;ans&lt;&lt;'\n';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}
</code></pre>
<hr>
<h1 id="f-老师和-yuuka-逛商场">F. <a href="https://ac.nowcoder.com/acm/contest/108307/F" target="_blank" rel="noopener nofollow">老师和 Yuuka 逛商场</a></h1>
<h1 id="线段树-线段树二分">线段树 #线段树二分</h1>
<h2 id="题目-2">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250817202833678-1773960540.png" alt="image" loading="lazy"></p>
<h2 id="思路-2">思路</h2>
<p>由于要确定两个隔板，非常容易想到的一个思路便是<span class="math inline">\(o(n)\)</span>遍历左隔板，<span class="math inline">\(o(\log n)\)</span>查找最优右隔板，总复杂度<span class="math inline">\(o(n\log n)\)</span></p>
<p>设集合<span class="math inline">\(S_{l}\)</span>表示区间<span class="math inline">\([1,l]\)</span>内的元素（去重），那么<span class="math inline">\([l+1,n]\)</span>内能对答案有贡献的数字必然要属于<span class="math inline">\(S_{l}\)</span>，因此我们可以将<span class="math inline">\([l+1,n]\)</span>这一段序列视作只剩下了属于<span class="math inline">\(S_{l}\)</span>的元素</p>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250817202846235-631404.png" alt="image" loading="lazy"></p>
<p>我们将序列分为三段：<span class="math inline">\([1,l],[l+1,r-1],[r,n]\)</span><br>
目标即使得<span class="math inline">\([l+1,r-1],[r,n]\)</span>中共同元素的数量尽可能大<br>
因此我们对每个元素在区间<span class="math inline">\([l+1,n]\)</span>中最早出现和最晚出现的位置<span class="math inline">\(lpos,rpos\)</span>进行维护，当指针落于元素<span class="math inline">\(x\)</span>的<span class="math inline">\([lpos,rpos]\)</span>中时便说明该指针的左边与右边必定都有元素<span class="math inline">\(x\)</span>出现</p>
<p>每次移动<span class="math inline">\(l\)</span>指针的时候，都使用队列<span class="math inline">\(deque\)</span>更新元素<span class="math inline">\(a[l]\)</span>的<span class="math inline">\(lpos,rpos\)</span></p>
<p>接着，使用线段树对区间<span class="math inline">\([lpos+1,rpos]\)</span>进行区间<span class="math inline">\(+1\)</span>，同时维护区间的最大值<br>
为什么左端点是<span class="math inline">\(lpos+1\)</span>呢？<br>
这是为了保证指针<span class="math inline">\(r\)</span>坐落于区间中的时候，<span class="math inline">\([r,n]\)</span>上必定有元素<span class="math inline">\(x\)</span>，<span class="math inline">\([l+1,r-1]\)</span>上也必定有元素<span class="math inline">\(x\)</span><br>
考虑边缘情况，若<span class="math inline">\(r=lpos+1\)</span>，那么<span class="math inline">\(r-1=lpos\)</span>，刚好将最左边的元素<span class="math inline">\(x\)</span>包含进了区间中</p>
<p>令<span class="math inline">\(r\)</span>指针落在区间<span class="math inline">\([l+1,n]\)</span>的<span class="math inline">\(max\)</span>值的点上，此时左右区间必定有<span class="math inline">\(max\)</span>值个相同元素，此处便是最优分割处</p>
<p>如何在线段树上找到这个<span class="math inline">\(max\)</span>值的位置呢？<br>
我们可以在线段树上二分，通过<span class="math inline">\(pair\)</span>来储存<span class="math inline">\(max\)</span>的值与位置：</p>
<ul>
<li>
<p><span class="math inline">\(pair\!&lt;\!int,int\!&gt;\)</span>类型的<span class="math inline">\(find(p,l,r)\)</span>函数</p>
<ul>
<li>传回的<span class="math inline">\(pair\)</span>中，<span class="math inline">\(first\)</span>为<span class="math inline">\(max\)</span>的值，<span class="math inline">\(second\)</span>为<span class="math inline">\(max\)</span>值的位置</li>
<li>功能：查询区间<span class="math inline">\([l,r]\)</span>内的单点最大值及其位置</li>
<li>对比左右子树的<span class="math inline">\(max\)</span>值，选择<span class="math inline">\(max\)</span>值较大的子树分裂查询</li>
</ul>
</li>
<li>
<p><span class="math inline">\(pair\!&lt;\!int,int\!&gt;\)</span>类型的<span class="math inline">\(query(p,l,r,ql,qr)\)</span>函数</p>
<ul>
<li>传回的<span class="math inline">\(pair\)</span>中，<span class="math inline">\(first\)</span>为<span class="math inline">\(max\)</span>的值，<span class="math inline">\(second\)</span>为<span class="math inline">\(max\)</span>值的位置</li>
<li>功能：查询区间<span class="math inline">\([ql,qr]\)</span>内的单点最大值及其位置</li>
<li>若<span class="math inline">\([l,r]\)</span>被<span class="math inline">\([ql,qr]\)</span>完全覆盖，那么可以直接调用<span class="math inline">\(find(p,l,r)\)</span></li>
<li>否则需要分裂查询左子树与右子树，返回左右子树中的较大者</li>
</ul>
</li>
</ul>
<p>为什么要设计两个函数来二分查找？<br>
因为给定的<span class="math inline">\(ql,qr\)</span>不一定是某个已知线段树节点所维护的区间<span class="math inline">\(l,r\)</span>，可能需要分裂成多个区间进行比较<br>
通过<span class="math inline">\(query\)</span>函数将<span class="math inline">\([ql,qr]\)</span>分裂成一个个已知区间<span class="math inline">\([l,r]\)</span>，再通过<span class="math inline">\(find\)</span>函数在线段树上查找</p>
<p>每次更新<span class="math inline">\(l\)</span>指针时，先删去<span class="math inline">\(a[l]\)</span>的<span class="math inline">\([lpos+1,rpos]\)</span>，<span class="math inline">\(a[l]\)</span>的<span class="math inline">\(deque\)</span>进行<span class="math inline">\(pop\_front\)</span>之后再加回<span class="math inline">\([lpos'+1,rpos]\)</span><br>
调用<span class="math inline">\(query(1,1,n,l+2,n)\)</span>查询区间<span class="math inline">\([l+2,n]\)</span>中的最大值与位置以确定最优的<span class="math inline">\(r\)</span>指针<br>
之所以是<span class="math inline">\(l+2\)</span>的原因是，当<span class="math inline">\(r\)</span>取<span class="math inline">\(l+2\)</span>的时候，<span class="math inline">\(r-1\)</span>为<span class="math inline">\(l+1\)</span>，与之前讨论的边界情况相符</p>
<p>注意<span class="math inline">\(l,r\)</span>分别初始化为<span class="math inline">\(2,3\)</span>，以防<span class="math inline">\(n=3\)</span>的情况<br>
一直取全局最大值即可</p>
<h2 id="代码实现-2">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;unordered_set&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
constexpr int inf = 1e9;
#define int ll 
// #define double long double

const int N = 1e5 + 5e4 + 5;
int n, a[N];

unordered_map&lt;int, deque&lt;int&gt;&gt;mp;

#define ls p&lt;&lt;1
#define rs p&lt;&lt;1|1
#define mid ((l+r)&gt;&gt;1)

int add[N &lt;&lt; 2], ma[N &lt;&lt; 2];
void pushup(int p) {
    ma[p] = max(ma[ls], ma[rs]);
}
void pushdown(int p, int l, int r) {
    if (add[p]) {
        ma[ls] += add[p];
        ma[rs] += add[p];
        add[ls] += add[p];
        add[rs] += add[p];
        add[p] = 0;
    }
}
void modify(int p, int l, int r, int x, int y, int val) {
    if (x &lt;= l &amp;&amp; r &lt;= y) { ma[p] += val; add[p] += val; return; }
    pushdown(p, l, r);
    if (x &lt;= mid)modify(ls, l, mid, x, y, val);
    if (y &gt; mid)modify(rs, mid + 1, r, x, y, val);
    pushup(p);
}

pair&lt;int, int&gt; find(int p, int l, int r) {
    if (l == r)return { ma[p],l };
    pushdown(p, l, r);
    if (ma[ls] &gt;= ma[rs])return find(ls, l, mid);
    else return find(rs, mid + 1, r);
}

pair&lt;int, int&gt; query(int p, int l, int r, int ql, int qr) {
    if (ql &gt; r || qr &lt; l) return { -1,-1 }; 
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return find(p, l, r);
    pushdown(p, l, r);
    auto left = query(ls, l, mid, ql, qr);
    auto right = query(rs, mid + 1, r, ql, qr);
    return left.first &gt;= right.first ? left : right;
}

void build(int p, int l, int r) {
    ma[p] = add[p] = 0;
    if (l == r)return;
    build(ls, l, mid); build(rs, mid + 1, r);
}

void eachT() {
    cin &gt;&gt; n;

    mp.clear();
    build(1, 1, n);

    unordered_multiset&lt;int&gt;sl;
    rep(i, 1, n) {
        cin &gt;&gt; a[i];
        mp[a[i]].push_back(i);
    }
    int ans = 0, ansl = 2, ansr = 3;
    rep(l, 1, n) {
        if (!sl.count(a[l])) {
            mp[a[l]].pop_front();
            int posl = mp[a[l]].front(), posr = mp[a[l]].back();
            if (posl + 1 &lt;= posr)modify(1, 1, n, posl + 1, posr, 1);
        } else {
            int posl = mp[a[l]].front(), posr = mp[a[l]].back();
            if (posl + 1 &lt;= posr)modify(1, 1, n, posl + 1, posr, -1);
            mp[a[l]].pop_front();
            if (mp[a[l]].size() &gt;= 2) {
                int posl = mp[a[l]].front(), posr = mp[a[l]].back();
                if (posl + 1 &lt;= posr)modify(1, 1, n, posl + 1, posr, 1);
            }
        }
        sl.insert(a[l]);
        pair&lt;int, int&gt; now = query(1, 1, n, l + 2, n);
        if (ans &lt; now.first) {
            ans = now.first;
            ansl = l + 1, ansr = now.second;
        }
    }
    cout &lt;&lt; ans &lt;&lt; '\n' &lt;&lt; ansl &lt;&lt; " " &lt;&lt; ansr &lt;&lt; '\n';
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}
</code></pre>
<hr>
<h1 id="k-神奇集合">K. <a href="https://ac.nowcoder.com/acm/contest/108307/K" target="_blank" rel="noopener nofollow">神奇集合</a></h1>
<h1 id="强联通分量-树上背包-dp">强联通分量 #树上背包 #dp</h1>
<h2 id="题目-3">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250817202906084-1992044017.png" alt="image" loading="lazy"></p>
<h2 id="思路-3">思路</h2>
<p>注意到题目中添加的新边为<strong>返祖边</strong>，一旦选择了该连通块中的任意一个点，那么这整个连通块都必须要选择，因此考虑对图进行<span class="math inline">\(tarjan\)</span>缩点</p>
<p>缩点过程中，将新点的权值、入度进行记录</p>
<p>由于原图是树，则添加返祖边缩点后仍然是一棵树<br>
建好新图后遍历所有新节点，找出入度为0的点记为根节点<br>
从根节点进入，<span class="math inline">\(dfs\)</span>过程中进行树上背包dp：</p>
<p>状态表示：<br>
<span class="math inline">\(dp[u][j]=1 /0\)</span>代表以<span class="math inline">\(u\)</span>为根的子树中，是否存在总权值为<span class="math inline">\(j\)</span>的神奇集合</p>
<p>状态转移：</p>
<p></p><div class="math display">\[\begin{align}
&amp;sum_{u}\geq i\geq 0,sum_{son}\geq j\geq 0:dp[u][i+j]\ |=dp[u][i]\&amp;dp[son][j]\\ \\
&amp;dp[u][sum_{u}]=1
\end{align}
\]</div><p></p><p>从<span class="math inline">\(u\)</span>节点已经遍历的所有可能权值中取出权值为<span class="math inline">\(i\)</span>的情况，从<span class="math inline">\(son\)</span>节点的所有可能权值中取出权值为<span class="math inline">\(j\)</span>的情况，二者可以转移到<span class="math inline">\(dp[u][i+j]\)</span>的状态中</p>
<p>最后考虑整个子树都选上的情况<span class="math inline">\(dp[u][sum_{u}]\)</span></p>
<p>答案即为<span class="math inline">\(\sum_{i=0}^{N} dp[root][i]\)</span></p>
<h2 id="代码实现-3">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
#define int ll 
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
constexpr int inf = 1e9 + 5;

// #include &lt;ext/pb_ds/assoc_container.hpp&gt;
// using namespace __gnu_pbds;
const int N=1e4+5;
int w[N];

struct node{
    set&lt;int&gt;e;
    int dfn,low,in,scc;
}a[N];

struct node1{
    set&lt;int&gt;e;
    int siz,deg,w,sum;
}na[N];

int tot,cnt;
stack&lt;int&gt;st;
void tarjan(int u){
    a[u].dfn=a[u].low=++tot;
    st.push(u),a[u].in=1;
    for(auto&amp;son:a[u].e){
        if(!a[son].dfn){
            tarjan(son);
            a[u].low=min(a[u].low,a[son].low);
        }else if(a[son].in){
            a[u].low=min(a[u].low,a[son].low);
        }
    }
    if(a[u].dfn==a[u].low){
        int v;++cnt;
        do{
            v=st.top(),st.pop(),a[v].in=0;
            a[v].scc=cnt,++na[cnt].siz;
            na[cnt].w+=w[v];
        }while(u!=v);
    }
}

int n;
void build(){
    rep(i,1,n){
        for(auto&amp;son:a[i].e){
            if(a[i].scc!=a[son].scc){
                na[a[i].scc].e.insert(a[son].scc);
                na[a[son].scc].deg++;
            }
        }
    }
}

bool dp[N][N];

int dfs(int u,int fa){
    int sum=0;
    dp[u][0]=1;
    for(auto&amp;son:na[u].e){
        if(son==fa)continue;
        sum+=dfs(son,u);
        per(i,na[u].sum,0){
            per(j,na[son].sum,0){
                dp[u][i+j]|=dp[u][i]&amp;dp[son][j];
            }
        }
        na[u].sum=sum;
    }
    sum+=na[u].w;
    na[u].sum=sum;
    dp[u][sum]=1;
    return sum;
}

void eachT() {   
    cin&gt;&gt;n;
    rep(i,1,n)cin&gt;&gt;w[i];
    rep(i,1,n-1){
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        a[u].e.insert(v);
    }
    int m;cin&gt;&gt;m;
    rep(i,1,m){
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        if(u!=v)a[u].e.insert(v);
    }
    rep(i,1,n){
        if(!a[i].scc)tarjan(i);
    }
    build();
    int rt;
    rep(i,1,cnt){
        if(na[i].deg==0)rt=i;
    }
    dfs(rt,0);
    int cnt=0;
    rep(i,0,N-1)if(dp[rt][i])cnt++;
    cout&lt;&lt;cnt&lt;&lt;'\n';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    // cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}

</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-17 20:30">2025-08-17 20:30</span>&nbsp;
<a href="https://www.cnblogs.com/CUC-MenG">CUC-MenG</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19043655);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19043655', targetLink: 'https://www.cnblogs.com/CUC-MenG/p/19043655', title: '2025牛客多校第十场 K.神奇集合 F.老师和Yuuka逛商场 E.老师与好感度 I.矩阵 个人题解' })">举报</a>
</div>
        