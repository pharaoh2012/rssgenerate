
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bricheersz/p/18962588" title="发布于 2025-07-02 23:49">
    <span role="heading" aria-level="2">你应该懂的AI大模型（十）之 LLamaFactory 之 LoRA微调Llama3</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-source-line="1"><em>本文标题中说的微调 Llama3指的是局部微调，使用 LLamaFactory 局部微调 LIama3。</em></p>
<h1 id="一-什么是llamafactory" data-source-line="3">一、什么是LLamaFactory</h1>
<p data-source-line="5">LLaMA-Factory 是一个开源的大型语言模型微调框架，全称 Large Language Model Factory1。它致力于简化大模型应用开发流程，为开发者和研究者提供实用的工具和资源。<br>LLaMA-Factory 能做的事情主要包括以下方面：</p>
<ul data-source-line="8">
<li>支持多种模型微调：可支持 LLaMA、BLOOM、Mistral、Baichuan、Qwen、ChatGLM 等多种大型语言模型的微调，开发者能根据需求选择合适的模型进行操作。</li>
<li>集成多种微调方法：涵盖（增量）预训练、指令监督微调、奖励模型训练、PPO 训练、DPO 训练和 ORPO 训练等多种方法，满足不同场景下的微调需求。</li>
<li>提供多种运算精度：具备 32 比特全参数微调、16 比特冻结微调、16 比特 LoRA 微调和基于 AQLM/AWQ/GPTQ/LLM.int8 的 2/4/8 比特 QLoRA 微调等多种精度选择，同时还有 GaLore、DoRA、LongLoRA 等先进算法，帮助开发者优化训练过程，提高效率。</li>
<li>助力特定场景应用：通过对预训练模型进行定制化训练和调整，使其适应智能客服、语音识别、机器翻译等特定应用场景，提升模型在这些场景下的表现。</li>
<li>提供便捷操作界面：拥有简洁明了的操作界面和丰富的文档支持，用户即使无需编写大量代码，也能通过内置的 Web UI 灵活定制 100 多个 LLMs 的微调，还可实时监控训练状态。</li>

</ul>
<h1 id="二-autodl和remote" data-source-line="14">二、AutoDL和Remote</h1>
<p data-source-line="16">AutoDL是一个算力平台，本文中所说的本地部署指的就是在 AutoDL的服务器中。</p>
<p data-source-line="18">Remote 是 VSCode 的 SSH 插件，用来连接远程服务器，选择 VSCode是因为它自带端口转发，启动LLamaFactory 的 webUI能直接在本地浏览器上打开。当然也可以不使用 VSCode。</p>
<p data-source-line="20">关于 AutoDL、 Remote、AutoDL 配置端口转发再网络上有很多教程，笔者在这里就不赘述了。</p>
<h1 id="三-本地部署liama3" data-source-line="22">三、本地部署LIama3</h1>
<p data-source-line="24">我们从魔塔社区获取模型，先在AutoDL服务器上安装以下库</p>
<pre data-source-line="26"><code class="hljs language-shell"><span class="hljs-meta prompt_">#<span class="language-bash"><span class="zh-hans">这些库大家缺啥装啥就可以，不是都得装，看服务器提示缺什么。<br>pip install modelscope<br>pip install openai.<br>pip install tqdm.<br>pip install transformers<br>pip install vllm<br></span></span></span></code></pre>
<p data-source-line="35">在服务器autuodl-tmp目录（这个目录关机不清数据）下新建一个python文件写入以下代码并在终端执行：</p>
<pre data-source-line="37"><code class="hljs language-python"><span class="hljs-comment">#<span class="zh-hans">模型下载<br><span class="hljs-keyword">from&nbsp;modelscope&nbsp;<span class="hljs-keyword">import&nbsp;snapshot_download<br>model_dir = snapshot_download(<span class="hljs-string">'LLM-Research/Llama-3.2-1B-Instruct',cache_dir=<span class="hljs-string">"/root/autodl-tmp/LLM3-1B")<br></span></span></span></span></span></span></code></pre>
<p data-source-line="43">下载完成后，可能会有两个模型文件，这里我们不用纠结。</p>
<p data-source-line="43"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234126617-102635112.png" class="lazyload"></p>
<p data-source-line="47">再新建一个python文件验证一下下载下来的模型：</p>
<pre data-source-line="49"><code class="hljs language-python"><span class="hljs-keyword">from&nbsp;transformers&nbsp;<span class="hljs-keyword">import&nbsp;AutoTokenizer, AutoModelForCausalLM<br><span class="hljs-keyword">import&nbsp;torch<br><br><span class="hljs-comment"># <span class="zh-hans">检查是否有GPU<span class="zh-hans">可用<br>device =&nbsp;<span class="hljs-string">"cuda"&nbsp;<span class="hljs-keyword">if&nbsp;torch.cuda.is_available()&nbsp;<span class="hljs-keyword">else&nbsp;<span class="hljs-string">"cpu"<br><span class="hljs-built_in">print(<span class="hljs-string">f"<span class="zh-hans">使用设备:&nbsp;<span class="hljs-subst">{device}")<br><br><span class="hljs-keyword">def&nbsp;<span class="hljs-title function_">load_model_and_tokenizer(<span class="hljs-params">model_name):<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"""<span class="zh-hans">加载预训练模型和分词器"""<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"<span class="zh-hans">开始加载模型:&nbsp;<span class="hljs-subst">{model_name}")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">加载分词器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenizer = AutoTokenizer.from_pretrained(model_name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">加载模型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model = AutoModelForCausalLM.from_pretrained(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch_dtype=torch.float16&nbsp;<span class="hljs-keyword">if&nbsp;device ==&nbsp;<span class="hljs-string">"cuda"&nbsp;<span class="hljs-keyword">else&nbsp;torch.float32,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low_cpu_mem_usage=<span class="hljs-literal">True,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trust_remote_code=<span class="hljs-literal">True<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">将模型移至指定设备<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model.to(device)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"<span class="zh-hans">模型&nbsp;<span class="hljs-subst">{model_name}&nbsp;<span class="zh-hans">加载完成")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;model, tokenizer<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">except&nbsp;Exception&nbsp;<span class="hljs-keyword">as&nbsp;e:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"<span class="zh-hans">加载模型时出错:&nbsp;<span class="hljs-subst">{e}")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;<span class="hljs-literal">None,&nbsp;<span class="hljs-literal">None<br><br><span class="hljs-keyword">def&nbsp;<span class="hljs-title function_">generate_text(<span class="hljs-params">model, tokenizer, prompt, max_length=<span class="hljs-number">512, temperature=<span class="hljs-number">0.7):<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"""<span class="zh-hans">使用模型生成文本"""<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;model&nbsp;<span class="hljs-keyword">is&nbsp;<span class="hljs-literal">None&nbsp;<span class="hljs-keyword">or&nbsp;tokenizer&nbsp;<span class="hljs-keyword">is&nbsp;<span class="hljs-literal">None:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">"<span class="zh-hans">模型或分词器未正确加载")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">编码输入文本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs = tokenizer(prompt, return_tensors=<span class="hljs-string">"pt").to(device)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">生成文本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">with&nbsp;torch.no_grad():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputs = model.generate(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**inputs,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_length=max_length,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temperature=temperature,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_sample=<span class="hljs-literal">True,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad_token_id=tokenizer.eos_token_id<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">解码生成的文本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generated_text = tokenizer.decode(outputs[<span class="hljs-number">0], skip_special_tokens=<span class="hljs-literal">True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">提取模型生成的部分（去掉输入的提示）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = generated_text[<span class="hljs-built_in">len(prompt):].strip()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;response<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">except&nbsp;Exception&nbsp;<span class="hljs-keyword">as&nbsp;e:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"<span class="zh-hans">生成文本时出错:&nbsp;<span class="hljs-subst">{e}")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return&nbsp;<span class="hljs-literal">None<br><br><span class="hljs-keyword">def&nbsp;<span class="hljs-title function_">main():<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">模型名称 - <span class="zh-hans">根据实际情况修改<br>&nbsp;&nbsp;&nbsp;&nbsp;model_name =&nbsp;<span class="hljs-string">"/root/autodl-tmp/LLM3-1B/LLM-Research/Llama-3.2-1B-Instruct/"<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">加载模型和分词器<br>&nbsp;&nbsp;&nbsp;&nbsp;model, tokenizer = load_model_and_tokenizer(model_name)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;model&nbsp;<span class="hljs-keyword">and&nbsp;tokenizer:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">示例提示<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prompt =&nbsp;<span class="hljs-string">"<span class="zh-hans">请介绍一下你自己。"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"\n<span class="zh-hans">提示:&nbsp;<span class="hljs-subst">{prompt}")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">生成回答<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = generate_text(model, tokenizer, prompt)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if&nbsp;response:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">print(<span class="hljs-string">f"\n<span class="zh-hans">模型回答:\n<span class="hljs-subst">{response}")<br><br><span class="hljs-keyword">if&nbsp;__name__ ==&nbsp;<span class="hljs-string">"__main__":<br>&nbsp;&nbsp;&nbsp;&nbsp;main()<br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h1 id="四-本地部署llamafactory" data-source-line="133">四、本地部署LLamaFactory</h1>
<h2 id="41-step1" data-source-line="135">4.1 step1</h2>
<p data-source-line="137">在远程服务器上先开启学术加速（有时候不开也可以）</p>
<pre data-source-line="139"><code class="hljs language-shell">source /etc/network_turbo<br></code></pre>
<h2 id="42-step2" data-source-line="143">4.2 step2</h2>
<p data-source-line="145">下载LLamaFactory</p>
<pre data-source-line="147"><code class="hljs language-shell">git clone https://github.com/hiyouga/LLaMA-Factory.git<br></code></pre>
<h2 id="43-step3" data-source-line="151">4.3 step3</h2>
<p data-source-line="153">安装LLamaFactory</p>
<pre data-source-line="155"><code class="hljs language-shell"> cd LLaMA-Factory<br>&nbsp;pip install -e .<br></code></pre>
<h2 id="44-step4" data-source-line="160">4.4 step4</h2>
<p data-source-line="162">启动webUI</p>
<pre data-source-line="164"><code class="hljs language-shell">cd LLaMA-Factory<br>llamafactory-cli webui<br><span class="hljs-meta prompt_"><br>#&nbsp;<span class="language-bash"><span class="zh-hans">使用&nbsp;<span class="hljs-built_in">nohup&nbsp;<span class="zh-hans">命令可以在关闭当前终端的情况下后台运行<br>nohup llamafactory-cli webui &gt; output.log 2&gt;&amp;1 &amp;<br></span></span></span></span></span></code></pre>
<p data-source-line="172">在使用vscode remote插件的前提下，启动webui后，我们就能在我们自己电脑的浏览器上看到web页面了。</p>
<h2 id="45-step5" data-source-line="174">4.5 step5</h2>
<p data-source-line="176">构造数据集，在LLamaFactory的下载目录下打开data目录，identity.json就是一个构造好的数据集，我们将其中的占位符修改成我们自己的信息，就可以使用这个数据集进行模型自我认知的训练，我们也可以去社区获取或者自己构造数据集复制到data目录下，但是我们自己定义的数据集一定要符合LLamaFactory的数据集结构。</p>
<p data-source-line="178">LLamaFactory数据集的结构示例如下：</p>
<pre data-source-line="180"><code class="hljs language-json"><span class="hljs-punctuation">[<br>&nbsp;&nbsp;<span class="hljs-punctuation">{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"instruction"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">"<span class="zh-hans">解释量子计算的基本原理"<span class="hljs-punctuation">,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"input"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">""<span class="hljs-punctuation">,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"output"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">"<span class="zh-hans">量子计算利用量子力学现象..."<br>&nbsp;&nbsp;<span class="hljs-punctuation">}<span class="hljs-punctuation">,<br>&nbsp;&nbsp;<span class="hljs-punctuation">{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"instruction"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">"<span class="zh-hans">将这段文本翻译成英文"<span class="hljs-punctuation">,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"input"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">"<span class="zh-hans">你好世界"<span class="hljs-punctuation">,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">"output"<span class="hljs-punctuation">:&nbsp;<span class="hljs-string">"Hello world"<br>&nbsp;&nbsp;<span class="hljs-punctuation">}<br><span class="hljs-punctuation">]<br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<table data-source-line="195">
<thead>
<tr><th>字段</th><th>必选</th><th>描述</th></tr>
</thead>
<tbody>
<tr>
<td><code>instruction</code></td>
<td>✅</td>
<td>用户指令，描述任务目标（如 "写一首关于春天的诗"）</td>
</tr>
<tr>
<td><code>input</code></td>
<td>❌</td>
<td>指令的补充信息（如需要翻译的文本、待总结的文章等）</td>
</tr>
<tr>
<td><code>output</code></td>
<td>✅</td>
<td>模型应生成的目标输出</td>
</tr>
<tr>
<td><code>system</code></td>
<td>❌</td>
<td>（可选）系统级指令，设置模型行为（如 "你是一名专业翻译"）</td>
</tr>
</tbody>
</table>
<h1 id="五-看懂llamafactory-webui" data-source-line="202">五、看懂LLamaFactory WebUI</h1>
<p data-source-line="204">下图是笔者的 LLanaFactory WebUI，接下来我们将详细把这个页面中的基础部分和 Train各项逐项解释。</p>
<p data-source-line="206"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234145630-147637767.png" class="lazyload"></p>
<h2 id="51-语言" data-source-line="208">5.1 语言</h2>
<p data-source-line="210"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234201248-131694048.png" class="lazyload"></p>
<p data-source-line="212">启动页面之后第一件事儿，先把页面改成中文。</p>
<h2 id="52-模型名称-模型路径" data-source-line="214">5.2 模型名称、模型路径</h2>
<p data-source-line="216">选择模型模型名称，模型路径处会显示huggingface上的模型标识符，我们在这里把路径改成服务器上存放的模型路径，注意是绝对路径。</p>
<h2 id="53-微调方法-检查点路径" data-source-line="218">5.3 微调方法、检查点路径</h2>
<p data-source-line="220"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234213308-1332038028.png" class="lazyload"></p>
<p data-source-line="222">微调方法我们选择 Lora。</p>
<p data-source-line="224">检查点路径配置的是再本地服务器 LLamaFactory 下的 save 文件中保存的参数权重，这些参数权重是我们在训练模型时会按照设置步长所保存的权重（模型训练结束之后就能看到这些文件夹，里面保存的是模型参数），如下图：</p>
<p data-source-line="226"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234252813-1455998802.png" class="lazyload"></p>
<p>&nbsp;</p>
<blockquote data-source-line="228">
<p>什么是模型训练迭代的步长（训练步数）</p>
<p>训练步数指模型在整个训练过程中参数更新的总次数。每更新一次参数，称为一个 “训练步”（Step）。</p>
<p>计算方式：总训练步数=（样本总数×训练轮数Epoch）/批次大小Batch&nbsp;Size</p>
<p>示例：</p>
<ul>
<li>数据集有 10,000 个样本。</li>
<li>训练 2 个 Epoch（每个样本被使用 2 次）。</li>
<li>批次大小为 32。<br>则总训练步数为：（10000*2）/32 约为 625 步 ，即参数更新 625 次</li>

</ul>
<p>作用：</p>
<ul>
<li>控制训练的总迭代次数，影响模型的收敛程度。</li>
<li>与 Epoch 的关系：Epoch 是遍历整个数据集的次数，而 Step 是按批次更新的次数。</li>

</ul>
<h3 id="混淆点为什么容易混淆">混淆点：为什么容易混淆？</h3>
<ul>
<li>
<p>学习率的英文有时也被称为 “Step Size”（如在梯度下降中），强调每次更新的 “步长”。</p>

</li>
<li>
<p>训练步数的英文是 “Training Steps”，强调迭代次数。</p>

</li>
<li>
<p>两者都与优化过程相关，但含义完全不同。</p>

</li>
<li>
<p>**&nbsp;如何避免混淆？**</p>
<ul>
<li>
<p>看上下文：</p>
<ul>
<li>如果讨论优化算法的参数（如 Adam、SGD），步长通常指学习率。</li>
<li>如果讨论训练流程的配置（如总迭代次数），步长通常指训练步数。</li>

</ul>

</li>
<li>
<p>明确术语：</p>
<ul>
<li>使用 “学习率” 代替 “步长” 描述优化器参数。</li>
<li>使用 “训练步数” 或 “迭代次数” 描述更新次数。</li>

</ul>

</li>

</ul>

</li>

</ul>
<p>理解这两个概念的区别对调参和训练效率至关重要。</p>
<ul>
<li>学习率过大可能导致模型无法收敛。</li>
<li>训练步数不足可能导致模型欠拟合。</li>

</ul>

</blockquote>
<h3 id="531-full-fine-tuning全量微调" data-source-line="270">5.3.1 Full Fine-tuning（全量微调）</h3>
<ul data-source-line="272">
<li>
<p>参数更新范围：更新预训练模型的所有参数（权重和偏置）。</p>

</li>
<li>
<p>原理：将预训练模型在新的数据集上重新训练，允许模型根据新数据调整所有内部表示。</p>

</li>
<li>
<p>优势：</p>
<ul>
<li>理论上能获得最佳性能，尤其当新任务与预训练任务差异较大时。</li>
<li>充分利用模型的全部表达能力。</li>

</ul>

</li>
<li>
<p>劣势：</p>
<ul>
<li>计算成本极高：需要存储和更新所有参数的梯度，显存占用大。</li>
<li>容易过拟合：若新数据集较小，可能导致模型遗忘预训练知识。</li>

</ul>

</li>
<li>
<p>适用场景：</p>
<ul>
<li>有大量高质量标注数据。</li>
<li>计算资源充足（如多 GPU/TPU 集群）。</li>
<li>任务与预训练任务差异显著（如从通用语言模型微调为医学问答模型）。</li>

</ul>

</li>

</ul>
<h3 id="532-freeze-fine-tuning冻结微调" data-source-line="288">5.3.2 Freeze Fine-tuning（冻结微调）</h3>
<ul data-source-line="290">
<li>
<p>参数更新范围：冻结大部分预训练参数，只更新最后几层（如分类头）或特定模块。</p>

</li>
<li>
<p>原理：利用预训练模型的底层特征提取能力，仅调整上层结构以适应新任务。</p>

</li>
<li>
<p>优势：</p>
<ul>
<li>显存占用小：只需更新少量参数，适合资源有限的场景。</li>
<li>训练速度快：计算量显著减少。</li>
<li>缓解过拟合：保留预训练知识，仅针对新任务微调上层。</li>

</ul>

</li>
<li>
<p>劣势：</p>
<ul>
<li>性能上限较低，尤其当新任务与预训练任务差异较大时。</li>

</ul>

</li>
<li>
<p>适用场景：</p>
<ul>
<li>数据量有限。</li>
<li>希望快速验证模型在新任务上的可行性。</li>
<li>任务与预训练任务高度相关（如领域适应，从通用文本到法律文本）。</li>

</ul>

</li>

</ul>
<h3 id="533-loralow-rank-adaptation低秩适应" data-source-line="306">5.3.3 LoRA（Low-Rank Adaptation，低秩适应）</h3>
<ul data-source-line="308">
<li>
<p>参数更新范围：不直接更新原模型参数，而是通过添加少量可训练的低秩矩阵来间接调整模型行为。</p>

</li>
<li>
<p>原理：</p>
<ul>
<li>对于权重矩阵&nbsp;<em>W</em>∈R<em>d</em>×<em>k</em>，分解为&nbsp;<em>W</em>+Δ<em>W</em>=<em>W</em>+<em>B</em>⋅<em>A</em>，其中&nbsp;<em>B</em>∈R<em>d</em>×<em>r</em>&nbsp;和&nbsp;<em>A</em>∈R<em>r</em>×<em>k</em>&nbsp;是低秩矩阵（<em>r</em>≪<em>d</em>,<em>k</em>）。</li>
<li>仅训练&nbsp;<em>B</em>&nbsp;和&nbsp;<em>A</em>，而原权重&nbsp;<em>W</em>&nbsp;保持冻结。</li>

</ul>

</li>
<li>
<p>优势：</p>
<ul>
<li>参数效率极高：仅需存储和训练少量额外参数（通常为原模型的 0.01%~1%）。</li>
<li>显存占用极小：适合在单 GPU 上微调大型模型（如 7B/13B 参数模型）。</li>
<li>支持快速切换任务：不同任务的 LoRA 权重可独立保存，共享基础模型。</li>

</ul>

</li>
<li>
<p>劣势：</p>
<ul>
<li>需额外实现 LoRA 的权重合并逻辑（推理时将&nbsp;<em>W</em>&nbsp;和&nbsp;Δ<em>W</em>&nbsp;合并）。</li>

</ul>

</li>
<li>
<p>适用场景：</p>
<ul>
<li>资源受限环境（如单 GPU、边缘设备）。</li>
<li>多任务微调（每个任务保存独立的 LoRA 权重）。</li>
<li>与 Full Fine-tuning 效果接近，但成本显著降低。</li>

</ul>

</li>

</ul>
<h2 id="54-量化等级-量化方法-提示模板-rope插值方法-加速方式" data-source-line="327">5.4 量化等级、量化方法、提示模板、RoPE插值方法、加速方式</h2>
<p data-source-line="329"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234241462-331550355.png" class="lazyload"></p>
<p>&nbsp;</p>
<p data-source-line="331">一般情况下这里是不用动的。</p>
<h3 id="541-模型量化model-quantization" data-source-line="333">5.4.1&nbsp;模型量化（Model Quantization）</h3>
<p data-source-line="335">模型量化是一种通过减少模型参数和计算过程中的数值精度，从而降低模型大小和计算复杂度的技术。深度学习模型通常使用 32 位浮点数（FP32）进行训练，但在推理阶段可以用更低的精度表示而不会显著损失精度。</p>
<h3 id="542-量化等级" data-source-line="337">5.4.2 量化等级</h3>
<table data-source-line="339">
<thead>
<tr><th>化等级</th><th>位宽</th><th>表示方式</th><th>说明</th></tr>

</thead>
<tbody>
<tr>
<td>FP32</td>
<td>32 位</td>
<td>单精度浮点数</td>
<td>原始模型精度，存储和计算成本最高</td>

</tr>
<tr>
<td>FP16</td>
<td>16 位</td>
<td>半精度浮点数</td>
<td>精度损失较小，计算效率提升显著</td>

</tr>
<tr>
<td>BF16</td>
<td>16 位</td>
<td>Brain Floating Point</td>
<td>类似 FP16 但保留更多指数位，适合深度学习</td>

</tr>
<tr>
<td>INT8</td>
<td>8 位</td>
<td>整数</td>
<td>最常见的低精度量化，部分硬件有专用加速</td>

</tr>
<tr>
<td>INT4</td>
<td>4 位</td>
<td>整数</td>
<td>更高压缩率，但精度损失明显</td>

</tr>
<tr>
<td>INT2/INT1</td>
<td>2/1 位</td>
<td>整数</td>
<td>极端压缩，仅适用于简单任务或特殊场景</td>

</tr>

</tbody>

</table>
<h3 id="543-量化方法" data-source-line="348">5.4.3 量化方法</h3>
<p data-source-line="350"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234305849-1672512639.png" class="lazyload"></p>
<h4 id="1-bnb-bitsandbytes" data-source-line="352">1. BNB (BitsAndBytes)</h4>
<p data-source-line="354">核心特点：</p>
<ul data-source-line="356">
<li>专为大模型设计：支持 INT8/INT4 量化，在保持较高精度的同时大幅降低显存需求。</li>
<li>双量化技术：通过量化量化参数本身，进一步减少内存占用。</li>
<li>混合精度计算：权重用低比特表示，计算时动态恢复为更高精度（如 FP16/BF16），平衡精度与速度。</li>

</ul>
<p data-source-line="360"><br>适用场景：</p>
<ul data-source-line="363">
<li>大语言模型（如 LLaMA-7B/13B）在单 GPU 上的部署。</li>

</ul>
<h4 id="2-hqq-high-quality-quantization" data-source-line="365">2. HQQ (High Quality Quantization)</h4>
<p data-source-line="367">核心特点：</p>
<ul data-source-line="369">
<li>极致压缩：支持 INT3/INT2 超低位宽量化，模型大小可压缩至原始的 1/8 甚至 1/16。</li>
<li>自适应量化策略：根据权重分布动态调整量化参数，减少信息损失。</li>
<li>量化感知微调：提供微调工具，进一步提升低位宽模型的性能。</li>

</ul>
<p data-source-line="373"><br>适用场景：</p>
<ul data-source-line="376">
<li>对模型体积敏感的场景（如边缘设备部署）。</li>
<li>需要在极低比特下保持相对较高精度的任务。</li>

</ul>
<h4 id="3-eetq-efficient-exact-tensor-quantization" data-source-line="379">3. EETQ (Efficient Exact Tensor Quantization)</h4>
<p data-source-line="381">核心特点：</p>
<ul data-source-line="383">
<li>高精度保持：通过误差补偿机制和张量分解技术，在低位宽下仍能保持接近浮点精度的计算结果。</li>
<li>硬件感知优化：针对不同硬件架构（如 CPU/GPU/ASIC）生成最优量化方案。</li>
<li>精确量化计算：确保量化后的计算结果与浮点计算高度接近。</li>

</ul>
<p data-source-line="387"><br>适用场景：</p>
<ul data-source-line="390">
<li>对精度要求极高的科学计算、金融推理等领域。</li>
<li>需要严格控制量化误差的场景</li>

</ul>
<table data-source-line="393">
<thead>
<tr><th>方案</th><th>最低量化位宽</th><th>压缩率</th><th>精度保持</th><th>计算效率</th><th>典型应用</th></tr>

</thead>
<tbody>
<tr>
<td>BNB</td>
<td>INT4</td>
<td>4-8 倍</td>
<td>高</td>
<td>高</td>
<td>LLM 高效部署</td>

</tr>
<tr>
<td>HQQ</td>
<td>INT2</td>
<td>16 倍</td>
<td>中</td>
<td>中</td>
<td>边缘设备极致压缩</td>

</tr>
<tr>
<td>EETQ</td>
<td>INT4</td>
<td>4 倍</td>
<td>极高</td>
<td>中</td>
<td>高精度科学计算</td>

</tr>

</tbody>

</table>
<p data-source-line="399">建议：</p>
<ul data-source-line="401">
<li>优先使用 BNB：对于大多数 LLM 部署场景，BNB 的 INT4 量化在精度和效率上取得较好平衡。</li>
<li>尝试 HQQ：若需要极致压缩（如模型需通过网络频繁传输），可考虑 HQQ 的 INT3/INT2。</li>
<li>选择 EETQ：仅在对精度要求苛刻且能接受一定计算开销时使用。</li>

</ul>
<h3 id="544-加速方式" data-source-line="405">5.4.4 加速方式</h3>
<p data-source-line="407"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234317214-1086804112.png" class="lazyload"></p>
<ul data-source-line="409">
<li>auto：自动选择最佳的加速方式。</li>
<li>flashattn2:全称是FlashAttention，2是指第二代，FlashAttention的主要作用是全面降低显存读写，旨在减少计算复杂度并加快推理速度。</li>
<li>unsloth：开源的加速微调项目，地址：https: /&nbsp;<a href="http://github.com/unslothai/unsloth" target="_blank" rel="noopener nofollow">github.com/unslothai/unsloth</a></li>
<li>liger_kernel：也是加速训练的项目，地址： https: /&nbsp;<a href="http://github.com/linkedin/Liger-Kerne" target="_blank" rel="noopener nofollow">github.com/linkedin/Liger-Kerne</a></li>

</ul>
<h2 id="55-train" data-source-line="414">5.5 Train</h2>
<h3 id="551-train" data-source-line="416">5.5.1 Train</h3>
<p data-source-line="418"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234326355-1475067705.png" class="lazyload"></p>
<h4 id="1训练阶段" data-source-line="420">1.训练阶段</h4>
<p><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234407998-760207937.png" class="lazyload"></p>
<h5 id="1-基础训练阶段" data-source-line="424">1）、基础训练阶段</h5>
<h6 id="1-预训练pre-training" data-source-line="426">（1）.&nbsp;预训练（Pre-Training）</h6>
<ul data-source-line="428">
<li>
<p>目标：<br>在大规模无标注文本（如网页、书籍）上训练基础语言模型，学习通用语言表示。</p>

</li>
<li>
<p>特点：</p>
<ul>
<li>计算成本极高（如 LLaMA-7B 训练需数千 GPU 小时）。</li>
<li>模型参数全部可训练。</li>

</ul>

</li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>需指定海量语料库路径。</li>
<li>通常使用 AdamW 优化器，学习率约 1e-4。</li>

</ul>

</li>

</ul>
<h6 id="2-监督微调supervised-fine-tuning-sft" data-source-line="439">（2）.&nbsp;监督微调（Supervised Fine-Tuning, SFT）</h6>
<ul data-source-line="441">
<li>
<p>目标：<br>使用标注好的指令 - 响应数据（如 {"指令": "写一首诗", "响应": "床前明月光..."}）微调预训练模型，使其遵循人类意图。</p>

</li>
<li>
<p>特点：</p>
<ul>
<li>数据量通常较小（数万至数十万样本）。</li>
<li>可使用全量微调或参数高效微调（如 LoRA）。</li>

</ul>

</li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>学习率：5e-5（LoRA）或 1e-5（全量）。</li>
<li>训练轮数：3-5 轮。</li>

</ul>

</li>

</ul>
<h5 id="2-强化学习训练阶段" data-source-line="452">2）、强化学习训练阶段</h5>
<h6 id="3-奖励模型训练reward-modeling-rm" data-source-line="454">（3）.&nbsp;奖励模型训练（Reward Modeling, RM）</h6>
<ul data-source-line="456">
<li>
<p>目标：<br>训练一个奖励模型，对模型生成的不同回答进行评分（如人类更喜欢回答 A 而非 B）。</p>

</li>
<li>
<p>流程：</p>
<ol>
<li>收集同一问题的多个回答。</li>
<li>人类标注偏好排序（如 A&gt;B&gt;C）。</li>
<li>训练奖励模型预测这种偏好。</li>

</ol></li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>输入：问题 + 多个回答的排序数据。</li>
<li>输出：奖励分数（标量值）。</li>

</ul>

</li>

</ul>
<h6 id="4-近端策略优化proximal-policy-optimization-ppo" data-source-line="468">（4）.&nbsp;近端策略优化（Proximal Policy Optimization, PPO）</h6>
<ul data-source-line="470">
<li>
<p>目标：<br>使用奖励模型的反馈，通过强化学习进一步优化 SFT 模型，使其生成更符合人类偏好的回答。</p>

</li>
<li>
<p>特点：</p>
<ul>
<li>基于策略梯度的强化学习算法。</li>
<li>引入 KL 散度惩罚，防止模型参数更新过大。</li>

</ul>

</li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>需预训练好的奖励模型。</li>
<li>关键参数：KL 惩罚系数（通常 0.1-0.5）、学习率（1e-6-1e-5）。</li>

</ul>

</li>

</ul>
<h6 id="5-直接偏好优化direct-preference-optimization-dpo" data-source-line="481">（5）.&nbsp;直接偏好优化（Direct Preference Optimization, DPO）</h6>
<ul data-source-line="483">
<li>
<p>目标：<br>直接从人类偏好数据中学习，无需显式训练奖励模型，简化 RLHF 流程。</p>

</li>
<li>
<p>优势：</p>
<ul>
<li>训练效率更高（减少一个训练阶段）。</li>
<li>理论上能更好地利用偏好数据。</li>

</ul>

</li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>输入：与 RM 相同的偏好排序数据。</li>
<li>直接优化策略模型，无需中间奖励模型。</li>

</ul>

</li>

</ul>
<h6 id="6-知识蒸馏优化knowledge-transfer-optimization-kto" data-source-line="494">（6）.&nbsp;知识蒸馏优化（Knowledge Transfer Optimization, KTO）</h6>
<ul data-source-line="496">
<li>
<p>目标：<br>将大型教师模型的知识蒸馏到小型学生模型中，实现模型压缩。</p>

</li>
<li>
<p>流程：</p>
<ol>
<li>使用大型模型（如 LLaMA-7B）作为教师。</li>
<li>训练小型模型（如 LLaMA-1.3B）模仿教师的输出分布。</li>

</ol></li>
<li>
<p>LLaMAFactory 配置：</p>
<ul>
<li>需同时加载教师和学生模型。</li>
<li>损失函数：交叉熵（预测结果与教师输出）。</li>

</ul>

</li>

</ul>
<h4 id="2数据路径与数据集" data-source-line="507">2.数据路径与数据集</h4>
<p data-source-line="509">默认data路径，在数据集中可以多选data路径下的数据集。要想自己的数据能在这里被选到要在LLamaFactory的data路径下的data_info.json下把你的数据json配置上。</p>
<h4 id="3学习率learning-rate" data-source-line="511">3.学习率**（Learning Rate）**</h4>
<ul data-source-line="513">
<li>
<p>作用：控制参数更新步长，影响收敛速度和稳定性。</p>

</li>
<li>
<p>典型值：</p>
<ul>
<li>全量微调：<code>5e-5 ~ 1e-4</code></li>
<li>LoRA 微调：<code>1e-4 ~ 5e-3</code></li>

</ul>

</li>
<li>
<p>调优：</p>
<ul>
<li>若损失震荡：降低学习率；</li>
<li>若收敛缓慢：适当提高学习率。</li>

</ul>

</li>

</ul>
<h4 id="4训练轮数epochs" data-source-line="523">4.训练轮数**（Epochs）**</h4>
<ul data-source-line="525">
<li>
<p>作用：模型对整个数据集的遍历次数。</p>

</li>
<li>
<p>典型值：</p>
<ul>
<li>预训练：10~100 轮</li>
<li>微调：3~10 轮</li>

</ul>

</li>
<li>
<p>调优：</p>
<ul>
<li>通过验证集损失动态调整，避免过拟合（如早停策略）。</li>

</ul>

</li>

</ul>
<h4 id="5最大梯度范数max-gradient-norm" data-source-line="534">5.最大梯度范数**（Max Gradient Norm）**</h4>
<ul data-source-line="536">
<li>作用：梯度裁剪阈值，防止梯度爆炸。</li>
<li>典型值：1.0~5.0</li>

</ul>
<h4 id="6最大样本数" data-source-line="539">6.最大样本数</h4>
<ul data-source-line="541">
<li>
<p>作用：限制参与训练的样本总量（用于快速验证或资源有限场景）。</p>

</li>
<li>
<p>示例：</p>
<ul>
<li>设为<code>10000</code>时，仅使用前 10k 条样本。</li>

</ul>

</li>
<li>
<p>影响：</p>
<ul>
<li>过小：模型欠拟合；过大：训练时间延长。</li>

</ul>

</li>

</ul>
<h4 id="7计算类型compute-type" data-source-line="549">7.计算类型**（Compute Type）**</h4>
<p data-source-line="551"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234456208-686640623.png" class="lazyload"></p>
<ul data-source-line="553">
<li>
<p>作用：控制训练时的数值精度，影响显存和速度。</p>

</li>
<li>
<p>选项：</p>
<ul>
<li><code>fp32</code>：全精度（默认）</li>
<li><code>fp16</code>：半精度（需混合精度训练）</li>
<li><code>bf16</code>：Brain Floating Point（适合 LLM，NVIDIA Ampere 及以上）</li>

</ul>

</li>

</ul>
<h4 id="8截断长度max-sequence-length" data-source-line="560">8.截断长度**（Max Sequence Length）**</h4>
<ul data-source-line="562">
<li>
<p>用：限制输入序列的最大 token 数，影响长文本处理能力。</p>

</li>
<li>
<p>典型值：</p>
<ul>
<li>标准模型：2048</li>
<li>长文本模型：8192~131072（如 LLaMA-3）</li>

</ul>

</li>
<li>
<p>注意：</p>
<ul>
<li>过长会显著增加显存消耗（复杂度为 O (n²)）。</li>

</ul>

</li>

</ul>
<h4 id="9批处理大小batch-size" data-source-line="571">9.批处理大小**（Batch Size）**</h4>
<ul data-source-line="573">
<li>
<p>作用：单次前向 / 反向传播的样本数，影响显存占用和收敛稳定性。</p>

</li>
<li>
<p>典型值：</p>
<ul>
<li>单 GPU（7B 模型）：8~64</li>
<li>多 GPU：64~512</li>

</ul>

</li>
<li>
<p>调优：</p>
<ul>
<li>显存不足时：减小 Batch Size 并增大梯度累计步数。</li>

</ul>

</li>

</ul>
<h4 id="10梯度累计" data-source-line="582">10.梯度累计</h4>
<ul data-source-line="584">
<li>作用：分批次计算梯度并累加，等效实现更大 Batch Size。</li>
<li>**公式：**等效Batch Size = 实际Batch Size × 梯度累计步数</li>

</ul>
<h4 id="11验证集比例" data-source-line="587">11.验证集比例</h4>
<ul data-source-line="589">
<li>作用：从训练数据中划分验证集，评估模型泛化能力。</li>
<li>典型值：0.1~0.2（即 10%~20% 数据用于验证）。</li>

</ul>
<h4 id="12学习率调节器" data-source-line="592">12.学习率调节器</h4>
<p data-source-line="594"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234508642-294675854.png" class="lazyload"></p>
<table data-source-line="596">
<thead>
<tr><th>策略</th><th>特点</th><th>适用场景</th></tr>

</thead>
<tbody>
<tr>
<td>固定学习率</td>
<td>全程保持恒定学习率</td>
<td>简单任务或调试</td>

</tr>
<tr>
<td>Warmup</td>
<td>训练初期逐步提升学习率（如前 10% 步数），避免冷启动不稳定</td>
<td>所有场景（必用）</td>

</tr>
<tr>
<td>余弦衰减</td>
<td>学习率随训练进程按余弦曲线衰减</td>
<td>大多数场景</td>

</tr>
<tr>
<td>阶梯衰减</td>
<td>每隔固定步数突然降低学习率（如每 5k 步降为 1/10）</td>
<td>需要快速收敛的场景</td>

</tr>

</tbody>

</table>
<p data-source-line="603">LLaMA 微调推荐配置</p>
<pre data-source-line="605"><code class="hljs language-python"><span class="hljs-comment"># Hugging Face<span class="zh-hans">实现Warmup+<span class="zh-hans">余弦衰减<br><span class="hljs-keyword">from&nbsp;transformers&nbsp;<span class="hljs-keyword">import&nbsp;get_cosine_schedule_with_warmup<br><br>optimizer = AdamW(model.parameters(), lr=<span class="hljs-number">5e-5)<br>scheduler = get_cosine_schedule_with_warmup(<br>&nbsp;&nbsp;&nbsp;&nbsp;optimizer,<br>&nbsp;&nbsp;&nbsp;&nbsp;num_warmup_steps=<span class="hljs-number">1000,&nbsp;&nbsp;<span class="hljs-comment"># <span class="zh-hans">前1000<span class="zh-hans">步为Warmup<br>&nbsp;&nbsp;&nbsp;&nbsp;num_training_steps=total_steps<br>)<br></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3 id="552-其他参数设置" data-source-line="617">5.5.2 其他参数设置</h3>
<p data-source-line="619"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234525281-391529208.png" class="lazyload"></p>
<ul data-source-line="621">
<li>日志间隔：设定每隔多少步输出一次日志就是终端窗口窗口每隔多少步（steps）打印一次训练的日志。</li>
<li>保存间隔：用于定期保存模型参数以防止意外丢失训练成果。</li>
<li>预热步数：在训练过程中，学习率逐步增加到初始设定值之前的步数。</li>
<li>NEFTune噪声参数：嵌入向量所添加的噪声大小，用于正则化和提升模型泛化能力。</li>
</ul>
<h3 id="553-部分参数微调设置" data-source-line="626">5.5.3 部分参数微调设置</h3>
<p data-source-line="628"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234535703-1531365046.png" class="lazyload"></p>
<p data-source-line="630">这里我们一般不动。</p>
<ul data-source-line="632">
<li>可训练层数：控制模型中可以进行训练的层数。在微调过程中，你可以选择只对模型的部分层级进行训练，而不是全部。这可能是因为你想保留预训练模型的一些知识，或者因为你的数据集较小，全量训练可能导致过拟合。</li>
<li>可训模块：在这个文本框中，你可以指定要训练的具体模块名称。如果输入"all"，则表示所有模块都将被训练。否则，你需要提供一个逗号分隔的列表来指明哪些模块需要训练。这在一些复杂的模型结构中非常有用，比如Transformer模型，其中包含多个不同的组件，如自注意力层、多头注意力层等。通过选择特定的模块进行训练，你可以更好地控制模型的学习过程，避免过度训练某些部分并提高效率。</li>
<li>额外模块（非必须域）： 这个字段允许你添加除隐藏层之外的其他可训练模块。这些可能是模型中的特殊组件，如嵌入层、池化层或其他特定于任务的层。如果你想要微调的模块不是默认的隐藏层，那么在这里列出它们可以帮助你精确地控制哪些部分应该被更新。</li>
</ul>
<h3 id="554-lora-参数设置" data-source-line="636">5.5.4 LoRA 参数设置</h3>
<p data-source-line="638"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234546175-1990312170.png" class="lazyload"></p>
<p data-source-line="640">这里比较重要我们后面会有专门的文章解读这里的配置。</p>
<h3 id="555-rlhf-参数设置" data-source-line="642">5.5.5 RLHF 参数设置</h3>
<p data-source-line="644"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234554966-152216989.png" class="lazyload"></p>
<h3 id="556-多模态参数设置" data-source-line="646">5.5.6 多模态参数设置</h3>
<p data-source-line="648"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234603641-1138421786.png" class="lazyload"></p>
<h3 id="557-galore参数设置" data-source-line="650">5.5.7 GaLore参数设置</h3>
<p><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234635601-1131931702.png" class="lazyload"></p>
<h3 id="558-apollo参数设置" data-source-line="654">5.5.8 APOLLO参数设置</h3>
<p data-source-line="656"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234645690-1776254886.png" class="lazyload"></p>
<h3 id="559-badam参数设置" data-source-line="658">5.5.9 BAdam参数设置</h3>
<p data-source-line="660"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234654782-880954570.png" class="lazyload"></p>
<h3 id="5510-swanlab参数设置" data-source-line="662">5.5.10 SwanLab参数设置</h3>
<p data-source-line="664"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234704211-344137067.png" class="lazyload"></p>
<h2 id="56-evluatepredict" data-source-line="666">5.6 Evluate&amp;Predict</h2>
<p data-source-line="668">这儿是测试集的配置，可以用作模型评估。</p>
<p data-source-line="670"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234713522-356448742.png" class="lazyload"></p>
<h2 id="57-chat" data-source-line="672">5.7 Chat</h2>
<p data-source-line="674">这里可以调用我们配置的模型，如果我们既配置了模型路径，又配置了检查点路径，那么在这里我们对话的模型就是我们训练好的基座模型。</p>
<p data-source-line="676">推理引擎建议选择 vllm，比 huggingface快。</p>
<p data-source-line="678"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234723647-442741514.png" class="lazyload"></p>
<h2 id="58-export" data-source-line="680">5.8 Export</h2>
<p data-source-line="682"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234734802-1023222132.png" class="lazyload"></p>
<p data-source-line="684">Export模块是用于导出训练好的模型。lora 不能单独存在，因此我们需要吧基座模型和训练好的权重一起打包打出使其成为新的模型，导出的模型可以作为基座模型再训练。</p>
<p data-source-line="686">注意导出模型的时候尽量不要选导出旧格式，旧格式指的是老的模型格式，现在基本不会用了。</p>
<ul data-source-line="688">
<li>最大分块大小：用于设置导出文件的最大大小。这对于上传到某些平台（如Hugging Face Hub）有限制的文件大小很有用。你可以调整此值以确保导出的文件不会超过所选的最大大小。</li>
<li>导出量化等级：选择是否要对模型进行量化。选择 “none” 表示不进行量化，而选择其他选项可能会导致模型尺寸减小，但在某些情况下可能会影响准确率。</li>
<li>导出量化数据集：如果选择了量化级别，可以在这里选择用于量化评估的数据集。这通常是训练或验证数据的一个子集，用于评估和微调量化后的模型性能。</li>
<li>导出设备：选择模型将被导出到什么类型的设备上。CPU选项表示模型将被优化以在CPU上运行，而auto选项让系统自动决定最适合的设备类型。这取决于你的目标环境和可用硬件。</li>
<li>不使用safetensors格式保存模型: 这个复选框用于选择是否使用safetensors格式保存模型。safetensors是一种安全的张量格式，可以保护模型免受恶意攻击。取消勾选该选项表示将使用标准格式保存模型。 导出目录: 在这里，你可以指定一个路径来保存导出的模型文件。这是模型及其相关文件将被保存的位置。</li>
<li>HF Hub ID: 如果你想将模型上传到Hugging Face Hub，你可以在此处输入仓库ID。这是一个可选字段，如果你不想上传模型，则可以留空。</li>
</ul>
<h1 id="六-需要看懂的参数" data-source-line="695">六、需要看懂的参数</h1>
<h2 id="61-liama3输出的参数" data-source-line="697">6.1 LIama3输出的参数</h2>
<pre><code> Model config LlamaConfig {
  "architectures": [
    "LlamaForCausalLM"
  ],
  "attention_bias": false,
  "attention_dropout": 0.0,
  "bos_token_id": 128000,
  "eos_token_id": [
    128001,
    128008,
    128009
  ],
  "head_dim": 64,
  "hidden_act": "silu",
  "hidden_size": 2048,
  "initializer_range": 0.02,
  "intermediate_size": 8192,
  "max_position_embeddings": 131072,
  "mlp_bias": false,
  "model_type": "llama",
  "num_attention_heads": 32,
  "num_hidden_layers": 16,
  "num_key_value_heads": 8,
  "pretraining_tp": 1,
  "rms_norm_eps": 1e-05,
  "rope_scaling": {
    "factor": 32.0,
    "high_freq_factor": 4.0,
    "low_freq_factor": 1.0,
    "original_max_position_embeddings": 8192,
    "rope_type": "llama3"
  },
  "rope_theta": 500000.0,
  "tie_word_embeddings": true,
  "torch_dtype": "bfloat16",
  "transformers_version": "4.48.2",
  "use_cache": true,
  "vocab_size": 128256
}
</code></pre>
<ul data-source-line="739">
<li>
<p>【模型架构与类型】architectures：指定模型类型为自回归语言模型，通过前文预测下一个 token。</p>
</li>
<li>
<p>【注意力机制参数】attention_bias：注意力层不使用偏置项（bias），减少参数量。</p>
</li>
<li>
<p>【注意力机制参数】attention_dropout：注意力层不应用 dropout（丢弃率为 0），提升训练稳定性。</p>
</li>
<li>
<p>【词汇表与特殊 Token】bos_token_id：文本开始标记（Begin of Sequence）的 token ID 为 128000。</p>
</li>
<li>
<p>【词汇表与特殊 Token】eos_token_id：文本结束标记（End of Sequence）有多个候选 ID，模型可能根据不同场景使用不同的结束标记。</p>
</li>
<li>
<p>【注意力机制参数】head_dim：每个注意力头的维度为 64，总注意力维度 = 32×64 = 2048。</p>
</li>
<li>
<p>【模型规模与结构】hidden_act：隐藏层激活函数使用 SiLU（Swish），数学表达式为&nbsp;<code>x * sigmoid(x)</code>。</p>
</li>
<li>
<p>【模型规模与结构】hidden_size：Transformer 层的隐藏层维度为 2048，对应约 7B 参数量级。</p>
</li>
<li>
<p>【归一化与初始化】initializer_range：权重初始化的标准差为 0.02（遵循标准正态分布）。</p>
</li>
<li>
<p>【模型规模与结构】intermediate_size：MLP 层的中间维度，通常为 hidden_size 的 4 倍（2048×4=8192）。</p>
</li>
<li>
<p>【位置编码与上下文长度】max_position_embeddings：模型支持的最大上下文长度为 131,072 tokens（约 100 万字）。</p>
</li>
<li>
<p>【模型规模与结构】mlp_bias：MLP 层不使用偏置项，减少参数量。</p>
</li>
<li>
<p>【模型架构与类型】model_type：表明采用 Llama 架构，使用 Llama 特有的层归一化、激活函数等设计。</p>
</li>
<li>
<p>【注意力机制参数】num_attention_heads：注意力头数量为 32 个，并行处理不同子空间的信息。</p>
</li>
<li>
<p>【模型规模与结构】num_hidden_layers：模型共有 16 层 Transformer 块。</p>
</li>
<li>
<p>【注意力机制参数】num_key_value_heads：采用 Grouped Query Attention (GQA)，使用 8 个 KV 头降低内存消耗（Llama 3 优化）。</p>
</li>
<li>
<p>【归一化与初始化】pretraining_tp：预训练时不使用张量并行（tensor parallelism），值为 1 表示单设备训练。</p>
</li>
<li>
<p>【归一化与初始化】rms_norm_eps：RMSNorm 层的稳定性参数，防止数值计算时除以接近零的方差。</p>
</li>
<li>
<p>【位置编码与上下文长度】rope_scaling：Llama 3 改进的旋转位置编码（RoPE）缩放机制：</p>
<ul>
<li>factor=32.0：将原始 Llama 的 8192 tokens 上下文扩展 32 倍至 131K。</li>
<li>high_freq_factor=4.0：高频位置编码的缩放因子（优化长序列外推）。</li>
<li>low_freq_factor=1.0：低频位置编码保持不变。</li>
<li>rope_type="llama3"：使用 Llama 3 特有的 RoPE 实现。</li>
</ul>
</li>
<li>
<p>【位置编码与上下文长度】rope_theta：RoPE 的基础频率参数，增大至 500K（原始 Llama 为 10,000），提升长序列建模能力。</p>
</li>
<li>
<p>【量化与版本信息】tie_word_embeddings：共享输入和输出词嵌入矩阵（减少参数量）。</p>
</li>
<li>
<p>【量化与版本信息】torch_dtype：使用 bfloat16 数据类型训练，相比 FP16 更稳定（适合大模型）。</p>
</li>
<li>
<p>【注意力机制参数】use_cache：启用 KV 缓存，加速推理阶段的自回归生成（保存历史 key/value 矩阵）。</p>
</li>
<li>
<p>【词汇表与特殊 Token】vocab_size：词汇表大小为 128,256，支持更丰富的 token 表示（大于标准 Llama 2 的 32K）。</p>
</li>
</ul>
<h2 id="62-llamafactory输出的参数" data-source-line="769">6.2 LLamaFactory输出的参数</h2>
<ul data-source-line="771">
<li>
<p>Num examples = 10</p>
<ul>
<li>表示用于训练的样本总数为 10 条。这是你提供给模型进行学习的所有数据量。</li>
</ul>
</li>
<li>
<p>Batch size = 10</p>
<ul>
<li>表示每个训练批次包含 10 个样本。结合上面的 Num examples=10 来看，这里一个 epoch 只需要一个 batch 就能完成所有样本的训练。</li>
</ul>
</li>
<li>
<p>loss</p>
<ul>
<li>损失值</li>
<li>含义：衡量模型预测结果与真实标签之间的差异程度。损失值越低，模型预测越准确。</li>
<li>计算方式：常见的损失函数如交叉熵损失（用于分类任务）、均方误差（用于回归任务）等。</li>
<li>训练趋势：理想情况下，随着训练进行，loss 应逐渐下降并趋于稳定。若 loss 波动较大或不降反升，可能表示学习率设置不当或模型过拟合。</li>
</ul>
</li>
<li>
<p>epoch</p>
<ul>
<li>轮次</li>
<li>含义：一个 epoch 表示模型完整地遍历了一次训练数据。</li>
<li>与 Batch 的关系：若总样本数为 N，batch size 为 B，则一个 epoch 需要 N/B 个 batch。在你的例子中，10 个样本，batch size=10，因此每个 epoch 只需 1 个 batch。</li>
<li>训练策略：通常需要多个 epoch 来让模型充分学习数据特征，但过多的 epoch 可能导致过拟合。</li>
</ul>
</li>
<li>
<p>throughput</p>
<ul>
<li>吞吐量</li>
<li>含义：表示单位时间内模型处理的样本数量，通常以 “样本 / 秒” 为单位。</li>
<li>计算公式：吞吐量 = 处理的总样本数 / 总耗时。例如，若一个 epoch 处理 10 个样本耗时 2 秒，则吞吐量为 5 样本 / 秒。</li>
<li>意义：反映训练效率，吞吐量越高，说明模型在硬件上的运行效率越高，训练速度越快。</li>
</ul>
</li>
</ul>
<h2 id="63-看懂折线图" data-source-line="796">6.3 看懂折线图</h2>
<p data-source-line="798"><img alt="" data-src="https://img2024.cnblogs.com/blog/1462902/202507/1462902-20250702234747129-740969046.png" class="lazyload"></p>
<h3 id="631基本概念" data-source-line="800">6.3.1基本概念</h3>
<h4 id="1-original原始值" data-source-line="802">1.&nbsp;Original（原始值）</h4>
<ul data-source-line="804">
<li>
<p>定义：模型在每个训练步骤（step）中直接计算得到的未经过处理的原始指标值。</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>反映模型在当前批次数据上的即时表现。</li>
<li>波动较大，尤其是在小批量训练或学习率较高时，可能包含噪声。</li>
</ul>
</li>
</ul>
<h4 id="2-smoothed平滑值" data-source-line="810">2.&nbsp;Smoothed（平滑值）</h4>
<ul data-source-line="812">
<li>
<p>定义：通过某种平滑算法（如指数移动平均 EMA）对原始值进行处理后得到的指标值。</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>抑制短期波动，展示指标的长期趋势。</li>
<li>更适合判断模型是否真正收敛或过拟合。</li>
</ul>
</li>
</ul>
<h3 id="632如何查看和解读" data-source-line="818">6.3.2如何查看和解读</h3>
<h4 id="1-loss-曲线对比" data-source-line="820">1.&nbsp;Loss 曲线对比</h4>
<ul data-source-line="822">
<li>
<p>Original Loss：<br>若原始损失曲线剧烈波动，可能表示：</p>
<ul>
<li>学习率设置过高，模型参数更新不稳定。</li>
<li>批次数据分布不均匀（如样本难度差异大）。</li>

</ul>

</li>
<li>
<p>Smoothed Loss：<br>观察平滑损失的趋势：</p>
<ul>
<li>若持续下降，说明模型仍在学习。</li>
<li>若趋于稳定，可能接近收敛。</li>
<li>若开始上升，可能出现过拟合（尤其当原始损失仍在下降时）。</li>

</ul>

</li>

</ul>
<h4 id="2结论" data-source-line="834">2.结论</h4>
<table data-source-line="836">
<thead>
<tr><th>指标</th><th>优势</th><th>适用场景</th></tr>

</thead>
<tbody>
<tr>
<td>Original</td>
<td>反映即时性能，检测训练异常</td>
<td>调试学习率、排查数据问题</td>

</tr>
<tr>
<td>Smoothed</td>
<td>展示长期趋势，判断收敛与过拟合</td>
<td>评估模型整体训练效果、确定训练终止点</td>

</tr>

</tbody>

</table>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-02 23:50">2025-07-02 23:49</span>&nbsp;
<a href="https://www.cnblogs.com/bricheersz">BricheersZ</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18962588);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18962588', targetLink: 'https://www.cnblogs.com/bricheersz/p/18962588', title: '你应该懂的AI大模型（十）之 LLamaFactory 之 LoRA微调Llama3' })">举报</a>
</div>
        