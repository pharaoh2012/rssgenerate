
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Rong-/p/18687042" title="发布于 2025-01-23 06:56">
    <span role="heading" aria-level="2">HiJobQueue：一个简单的线程安全任务队列</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="hijobqueue一个简单的线程安全任务队列">HiJobQueue：一个简单的线程安全任务队列</h1>
<h2 id="概述">概述</h2>
<p><code>HiJobQueue</code>&nbsp;是一个线程安全的任务队列，用于在多线程环境中管理和执行异步任务。它的设计参考了&nbsp;<a href="https://github.com/youtube/cobalt/blob/main/starboard/shared/starboard/player/job_queue.h" target="_blank" rel="noopener nofollow">Cobalt 项目中的 JobQueue</a>，并做了适当的简化。<code>HiJobQueue</code>&nbsp;提供了任务推送（<code>push</code>）、任务弹出（<code>pop</code>）、队列退出（<code>quit</code>）等功能，适用于需要异步任务调度的场景。</p>
<hr>
<h2 id="核心功能">核心功能</h2>
<ol>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用&nbsp;<code>std::mutex</code>&nbsp;和&nbsp;<code>std::condition_variable</code>&nbsp;实现线程安全的任务队列。</li>
</ul>
</li>
<li>
<p><strong>任务调度</strong>：</p>
<ul>
<li>支持任务的异步推送和弹出。</li>
</ul>
</li>
<li>
<p><strong>退出机制</strong>：</p>
<ul>
<li>提供&nbsp;<code>quit()</code>&nbsp;方法，用于安全地停止任务队列。</li>
</ul>
</li>
<li>
<p><strong>跨平台</strong>：</p>
<ul>
<li>使用 C++ 标准库实现，不依赖平台特定的 API。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="实现代码">实现代码</h2>
<p>以下是&nbsp;<code>HiJobQueue</code>&nbsp;的实现代码：</p>
<pre><code class="language-cpp">#pragma once

#include &lt;mutex&gt;
#include &lt;functional&gt;
#include &lt;queue&gt;
#include &lt;condition_variable&gt;

/**
 * @brief 线程安全的任务队列，用于管理和执行异步任务。
 */
class HiJobQueue final {
public:
    using Job = std::function&lt;void()&gt;; // 任务类型

public:
    HiJobQueue() : is_exit_(false) {}

    /**
     * @brief 推送任务到队列。
     * @param job 要执行的任务。
     * @return 如果队列已退出，返回 false；否则返回 true。
     */
    bool push(Job job);

    /**
     * @brief 从队列中弹出任务。
     * @param job 用于存储弹出的任务。
     * @return 如果队列为空且已退出，返回 false；否则返回 true。
     */
    bool pop(Job&amp; job);

    /**
     * @brief 获取队列中的任务数量。
     * @return 队列中的任务数量。
     */
    size_t size();

    /**
     * @brief 退出队列，停止任务处理。
     */
    void quit();

    /**
     * @brief 检查队列是否已退出。
     * @return 如果队列已退出，返回 true；否则返回 false。
     */
    bool is_quited();

    // 禁用拷贝构造函数和赋值运算符
    HiJobQueue(HiJobQueue&amp;) = delete;
    HiJobQueue(const HiJobQueue&amp;) = delete;

private:
    bool is_exit_;                 // 队列退出标志
    std::mutex mutex_;             // 互斥锁，保护队列访问
    std::condition_variable cond_; // 条件变量，用于任务通知
    std::queue&lt;Job&gt; queue_;        // 任务队列
};

// 实现

bool HiJobQueue::push(Job job) {
    std::lock_guard&lt;std::mutex&gt; locker(mutex_);
    if (is_exit_) {
        return false;
    }
    queue_.push(std::move(job));
    cond_.notify_one();
    return true;
}

bool HiJobQueue::pop(Job&amp; job) {
    std::unique_lock&lt;std::mutex&gt; locker(mutex_);
    cond_.wait(locker, [this]() { return is_exit_ || !queue_.empty(); });
    if (is_exit_ &amp;&amp; queue_.empty()) {
        return false;
    }
    job = std::move(queue_.front());
    queue_.pop();
    return true;
}

size_t HiJobQueue::size() {
    std::lock_guard&lt;std::mutex&gt; locker(mutex_);
    return queue_.size();
}

void HiJobQueue::quit() {
    std::lock_guard&lt;std::mutex&gt; locker(mutex_);
    is_exit_ = true;
    cond_.notify_all();
}

bool HiJobQueue::is_quited() {
    std::lock_guard&lt;std::mutex&gt; locker(mutex_);
    return is_exit_;
}
</code></pre>
<hr>
<h2 id="测试用例">测试用例</h2>
<p>为了验证&nbsp;<code>HiJobQueue</code>&nbsp;的正确性和线程安全性，我们设计了以下测试用例：</p>
<h3 id="测试代码">测试代码</h3>
<pre><code class="language-cpp">#include &lt;gtest/gtest.h&gt;
#include &lt;future&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include "hi_job_queue.h"

class TestCls {
public:
    void test(const char* text, int i) {
        printf("%s-%d\n", text, i);
    }
};

TEST(HiJobQueueTest, ConcurrentPushPop) {
    HiJobQueue queue;
    TestCls cls;

    std::atomic&lt;int&gt; job_count{0}; 

    auto f1 = std::async(std::launch::async, [&amp;] {
        HiJobQueue::Job job;
        while (queue.pop(job)) {
            job();
            job_count++;
        }
    });

    auto f2 = std::async(std::launch::async, [&amp;] {
        HiJobQueue::Job job;
        while (queue.pop(job)) {
            job();
            job_count++;
        }
    });

    auto f3 = std::async(std::launch::async, [&amp;] {
        for (int i = 0; i &lt; 200; i++) {
            queue.push(std::bind(&amp;TestCls::test, &amp;cls, "test1", i));
            std::this_thread::sleep_for(std::chrono::milliseconds(5)); // 跨平台休眠
        }
    });

    auto f4 = std::async(std::launch::async, [&amp;] {
        for (int i = 0; i &lt; 200; i++) {
            queue.push(std::bind(&amp;TestCls::test, &amp;cls, "test2", i));
            std::this_thread::sleep_for(std::chrono::milliseconds(5)); // 跨平台休眠
        }
    });

    f3.wait();
    f4.wait();

    queue.quit();

    f1.wait();
    f2.wait();

    // 验证所有任务被执行
    EXPECT_EQ(job_count.load(), 400); // 200 (test1) + 200 (test2)
}

TEST(HiJobQueueTest, QuitBehavior) {
    HiJobQueue queue;

    auto consumer = std::async(std::launch::async, [&amp;] {
        HiJobQueue::Job job;
        while (queue.pop(job)) {
            job();
        }
    });

    for (int i = 0; i &lt; 10; i++) {
        queue.push([]() {});
    }

    queue.quit();

    consumer.wait();

    EXPECT_TRUE(queue.is_quited());

    EXPECT_FALSE(queue.push([]() {}));
}

TEST(HiJobQueueTest, EmptyQueueBehavior) {
    HiJobQueue queue;

    HiJobQueue::Job job;
    bool pop_result = false;

    auto pop_thread = std::async(std::launch::async, [&amp;] {
        pop_result = queue.pop(job);
    });

    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    EXPECT_FALSE(pop_result);

    queue.quit();

    pop_thread.wait();

    EXPECT_FALSE(pop_result);

    EXPECT_FALSE(queue.pop(job));
}
</code></pre>
<hr>
<h3 id="测试用例说明">测试用例说明</h3>
<ol>
<li>
<p><strong><code>ConcurrentPushPop</code></strong>：</p>
<ul>
<li>测试多线程环境下&nbsp;<code>push</code>&nbsp;和&nbsp;<code>pop</code>&nbsp;的并发行为。</li>
<li>验证所有任务是否被正确执行。</li>
</ul>
</li>
<li>
<p><strong><code>QuitBehavior</code></strong>：</p>
<ul>
<li>测试队列退出时的行为。</li>
<li>验证退出后是否不再接受新任务。</li>
</ul>
</li>
<li>
<p><strong><code>EmptyQueueBehavior</code></strong>：</p>
<ul>
<li>测试队列为空时的行为。</li>
<li>验证退出后&nbsp;<code>pop</code>&nbsp;的行为。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="适用场景">适用场景</h2>
<p><code>HiJobQueue</code>&nbsp;适用于以下场景：</p>
<ol>
<li>
<p><strong>多线程任务调度</strong>：</p>
<ul>
<li>在需要将任务分发到多个工作线程执行的场景中，<code>HiJobQueue</code>&nbsp;可以作为任务调度器使用。</li>
<li>例如：线程池中的任务队列。</li>
</ul>
</li>
<li>
<p><strong>事件驱动架构</strong>：</p>
<ul>
<li>在事件驱动的系统中，<code>HiJobQueue</code>&nbsp;可以用于存储和处理事件。</li>
<li>例如：GUI 应用中的事件队列。</li>
</ul>
</li>
<li>
<p><strong>异步任务处理</strong>：</p>
<ul>
<li>在需要异步执行任务的场景中，<code>HiJobQueue</code>&nbsp;可以用于存储任务并由后台线程处理。</li>
<li>例如：日志系统的异步写入。</li>
</ul>
</li>
<li>
<p><strong>生产者-消费者模型</strong>：</p>
<ul>
<li>在生产者-消费者模型中，<code>HiJobQueue</code>&nbsp;可以作为共享的任务缓冲区。</li>
<li>例如：多线程下载任务的分发。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="优缺点分析">优缺点分析</h2>
<h3 id="优点">优点</h3>
<ol>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>使用&nbsp;<code>std::mutex</code>&nbsp;和&nbsp;<code>std::condition_variable</code>&nbsp;确保多线程环境下的安全性。</li>
</ul>
</li>
<li>
<p><strong>简单易用</strong>：</p>
<ul>
<li>提供了简洁的接口（<code>push</code>、<code>pop</code>、<code>quit</code>），易于集成到现有项目中。</li>
</ul>
</li>
<li>
<p><strong>跨平台</strong>：</p>
<ul>
<li>基于 C++ 标准库实现，不依赖平台特定的 API，具有良好的可移植性。</li>
</ul>
</li>
<li>
<p><strong>退出机制</strong>：</p>
<ul>
<li>提供&nbsp;<code>quit()</code>&nbsp;方法，可以安全地停止任务队列，避免资源泄漏。</li>
</ul>
</li>
<li>
<p><strong>轻量级</strong>：</p>
<ul>
<li>代码简洁，性能开销小，适合对性能要求较高的场景。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="缺点">缺点</h3>
<ol>
<li>
<p><strong>功能单一</strong>：</p>
<ul>
<li>仅支持基本的任务队列功能，不支持优先级调度或任务取消。</li>
</ul>
</li>
<li>
<p><strong>性能瓶颈</strong>：</p>
<ul>
<li>在高并发场景下，<code>std::mutex</code>&nbsp;可能成为性能瓶颈。</li>
<li>如果需要更高的性能，可以考虑无锁队列（如&nbsp;<code>boost::lockfree::queue</code>）。</li>
</ul>
</li>
<li>
<p><strong>任务类型限制</strong>：</p>
<ul>
<li>任务类型为&nbsp;<code>std::function&lt;void()&gt;</code>，不支持返回值或参数传递。</li>
<li>如果需要更复杂的任务类型，需要自行扩展。</li>
</ul>
</li>
<li>
<p><strong>缺乏任务状态管理</strong>：</p>
<ul>
<li>不支持任务的状态管理（如任务完成通知或错误处理）。</li>
</ul>
</li>
<li>
<p><strong>退出时未执行任务</strong>：</p>
<ul>
<li>在调用 quit() 方法退出队列时，如果仍有未执行的任务，这些任务会被直接丢弃。</li>
<li>如果任务中存在阻塞操作（如等待 I/O、锁、条件变量等），可能导致进程无法及时退出。<br>
例如：在希望进程退出时，如果任务队列中有未执行的任务，且任务中存在阻塞操作，进程可能会卡住，无法正常退出。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结">总结</h2>
<p><code>HiJobQueue</code>&nbsp;是一个简单但功能强大的线程安全任务队列，适用于多线程环境中的异步任务调度。通过参考&nbsp;<a href="https://github.com/youtube/cobalt/blob/main/starboard/shared/starboard/player/job_queue.h" target="_blank" rel="noopener nofollow">Cobalt 项目中的 JobQueue</a>，我们实现了一个更轻量级的版本，并通过单元测试验证了其正确性和线程安全性。希望这篇文章能帮助你理解和使用&nbsp;<code>HiJobQueue</code>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19323806238541666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 07:41">2025-01-23 06:56</span>&nbsp;
<a href="https://www.cnblogs.com/Rong-">荣--</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18687042" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18687042);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18687042', targetLink: 'https://www.cnblogs.com/Rong-/p/18687042', title: 'HiJobQueue：一个简单的线程安全任务队列' })">举报</a>
</div>
        