
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bigdata1024/p/18675266" title="发布于 2025-01-16 16:55">
    <span role="heading" aria-level="2">基于Fluss 的流式湖仓架构</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-what" rel="noopener nofollow">1. What</a></li><li><a href="#2-架构" rel="noopener nofollow">2. 架构</a><ul><li><a href="#21-coordinatorserver" rel="noopener nofollow">2.1 CoordinatorServer</a></li><li><a href="#22-tabletserver" rel="noopener nofollow">2.2 TabletServer</a></li><li><a href="#23-logstore" rel="noopener nofollow">2.3 LogStore</a></li><li><a href="#24-kvstore" rel="noopener nofollow">2.4 KvStore</a></li><li><a href="#25-tablet--bucket" rel="noopener nofollow">2.5 Tablet / Bucket</a></li><li><a href="#26-zookeeper" rel="noopener nofollow">2.6 Zookeeper</a></li><li><a href="#27-remote-storage" rel="noopener nofollow">2.7 Remote Storage</a></li><li><a href="#28-client" rel="noopener nofollow">2.8 Client</a></li></ul></li><li><a href="#3-表设计" rel="noopener nofollow">3. 表设计</a><ul><li><a href="#31-概述" rel="noopener nofollow">3.1 概述</a><ul><li><a href="#311-database" rel="noopener nofollow">3.1.1 Database</a></li><li><a href="#312-table" rel="noopener nofollow">3.1.2 Table</a></li><li><a href="#313-table-数据组织" rel="noopener nofollow">3.1.3 Table 数据组织</a><ul><li><a href="#3131-partition" rel="noopener nofollow">3.1.3.1 Partition</a></li><li><a href="#3132-bucket" rel="noopener nofollow">3.1.3.2 Bucket</a></li><li><a href="#3133-logtablet" rel="noopener nofollow">3.1.3.3 LogTablet</a></li><li><a href="#3134-kvtablet" rel="noopener nofollow">3.1.3.4 KvTablet</a></li></ul></li></ul></li><li><a href="#32-表类型" rel="noopener nofollow">3.2 表类型</a><ul><li><a href="#321-log-table" rel="noopener nofollow">3.2.1 Log Table</a></li><li><a href="#322-primarykey-table" rel="noopener nofollow">3.2.2 PrimaryKey Table</a></li></ul></li><li><a href="#33-数据分布" rel="noopener nofollow">3.3 数据分布</a><ul><li><a href="#331--bucketing" rel="noopener nofollow">3.3.1  Bucketing</a></li><li><a href="#332-分区表" rel="noopener nofollow">3.3.2 分区表</a></li><li><a href="#333-ttl" rel="noopener nofollow">3.3.3 TTL</a></li></ul></li><li><a href="#34-数据类型" rel="noopener nofollow">3.4 数据类型</a></li></ul></li><li><a href="#4-流式湖仓" rel="noopener nofollow">4. 流式湖仓</a></li><li><a href="#5-how" rel="noopener nofollow">5. How</a><ul><li><a href="#51-安装docker" rel="noopener nofollow">5.1 安装docker</a></li><li><a href="#52-启动所需要的组件" rel="noopener nofollow">5.2 启动所需要的组件</a></li><li><a href="#53-进入sql客户端" rel="noopener nofollow">5.3 进入SQL客户端</a></li><li><a href="#54-创建fluss表格" rel="noopener nofollow">5.4 创建Fluss表格</a><ul><li><a href="#541-创建fluss-catalog" rel="noopener nofollow">5.4.1 创建fluss catalog</a></li><li><a href="#542-创建表" rel="noopener nofollow">5.4.2 创建表</a></li></ul></li><li><a href="#55-流式写入-fluss" rel="noopener nofollow">5.5 流式写入 Fluss</a></li><li><a href="#56-在-fluss-表上运行临时查询" rel="noopener nofollow">5.6 在 Fluss 表上运行临时查询</a></li><li><a href="#57--updatedelete-rows-on-fluss-tables" rel="noopener nofollow">5.7  Update/Delete rows on Fluss Tables</a><ul><li><a href="#571-update" rel="noopener nofollow">5.7.1 Update</a></li><li><a href="#572-delete" rel="noopener nofollow">5.7.2 Delete</a></li></ul></li><li><a href="#58-集成pamion" rel="noopener nofollow">5.8 集成pamion</a><ul><li><a href="#581-启动-lakehouse-分层服务" rel="noopener nofollow">5.8.1 启动 Lakehouse 分层服务</a></li><li><a href="#582-将数据流式写入-fluss-数据湖启用的表" rel="noopener nofollow">5.8.2 将数据流式写入 Fluss 数据湖启用的表</a></li><li><a href="#583-fluss-数据湖启用表上的实时分析" rel="noopener nofollow">5.8.3 Fluss 数据湖启用表上的实时分析</a></li></ul></li><li><a href="#59-clean-up" rel="noopener nofollow">5.9 clean up</a></li></ul></li><li><a href="#6-reference" rel="noopener nofollow">6. Reference</a></li></ul></div><p></p>
<h3 id="1-what">1. What</h3>
<p>Fluss 是一个用于实时分析的可扩展流存储，可以作为 Lakehouse 架构的实时数据层。</p>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116155136654-1845612628.png" alt="image" loading="lazy"></p>
<p>它通过实现低延迟、高吞吐量的数据摄取和处理，弥合了流数据和数据湖之间的差距，同时无缝集成流行的计算引擎，如Apache Flink，而Apache Spark和StarRocks也即将推出。<br>
Fluss 支持亚秒级延迟的 流式读取 和 写入，并以列式格式存储数据，从而提高查询性能并降低存储成本。 它提供灵活的表类型，包括仅追加的 日志表 和可更新的 主键表，以满足各种实时分析和处理需求。<br>
内置的复制功能可提供容错性、水平扩展性以及高级功能，如高QPS的查找连接和批量读写操作，Fluss非常适合用于支持实时分析、AI/ML流水线和流数据仓库。<br>
fluss（德语：河流，发音为/flus/）能够持续地流式传输数据，将其汇聚、分发并流入湖泊，就像一条河流</p>
<h3 id="2-架构">2. 架构</h3>
<p>一个Fluss集群由两个主要进程组成：CoordinatorServer和TabletServer。</p>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116160003240-1587432462.png" alt="image" loading="lazy"></p>
<h4 id="21-coordinatorserver">2.1 CoordinatorServer</h4>
<p>CoordinatorServer是集群的中心控制和管理工作组件。它负责维护元数据、管理表分配、列出节点和处理权限</p>
<p>此外，它协调关键操作，如：</p>
<ol>
<li>在节点扩缩期间重新平衡数据</li>
<li>在节点故障的情况下，管理数据迁移和服务节点切换。</li>
<li>监督表管理任务，包括创建或删除表以及更新桶计数<br>
CoordinatorServer作为集群的大脑，协调服务器确保集群的高效运行和资源的无缝管理</li>
</ol>
<h4 id="22-tabletserver">2.2 TabletServer</h4>
<p>TabletServer 负责数据存储、持久化，并向用户提供直接的 I/O 服务。它由两个关键组件组成：LogStore 和 KvStore</p>
<ul>
<li>对于支持更新的主键表，LogStore和KvStore都会被激活。KvStore用于高效地支持更新和点查找。LogStore用于存储表的变化日志</li>
<li>对于仅支持追加操作的日志表，仅激活LogStore，以优化写入密集型工作负载的性能</li>
</ul>
<p>这种架构确保TabletServer能够根据表类型提供定制的数据处理能力</p>
<h4 id="23-logstore">2.3 LogStore</h4>
<p>LogStore 设计用于存储日志数据，功能类似于数据库的二进制日志。 消息只能追加，不能修改，以确保数据完整性。 其主要目的是实现低延迟的流式读取，并作为KvStore的预写日志（WAL）</p>
<h4 id="24-kvstore">2.4 KvStore</h4>
<p>KvStore 用于存储表数据，功能类似于数据库表。它支持数据更新和删除，从而实现高效的查询和表管理。此外，它还生成全面的变更日志，以跟踪数据修改</p>
<h4 id="25-tablet--bucket">2.5 Tablet / Bucket</h4>
<p>表数据根据定义的桶策略被划分为多个桶<br>
LogStore 和 KvStore 的数据存储在Tablet中。每个Tablet由一个 LogTablet 和一个可选的 KvTablet 组成，具体取决于表是否支持更新。 LogStore 和 KvStore 都遵循相同的桶分割和Tablet分配策略。因此，具有相同 tablet_id 的 LogTablets 和 KvTablets 总是分配到同一个 TabletServer，以便高效地管理数据</p>
<p>LogTablet 支持基于表配置的复制因子进行多个副本，确保高可用性和容错性。目前，KvTablets 不支持复制</p>
<h4 id="26-zookeeper">2.6 Zookeeper</h4>
<p>Fluss 目前使用 ZooKeeper 进行集群协调、元数据存储和集群配置管理。 在即将发布的版本中，ZooKeeper 将被替换 为 KvStore 用于元数据存储，Raft 用于集群协调和确保一致性。这一过渡旨在简化操作并提高系统可靠性</p>
<h4 id="27-remote-storage">2.7 Remote Storage</h4>
<p>远程存储有两个主要用途：<br>
1.LogStores的分层存储：通过卸载LogStore数据，它减少了存储成本并加速了扩展操作<br>
2.KvStores 的持久存储： 它确保 KvStore 数据的持久存储，并与 LogStore 协作以实现故障恢复。<br>
此外，远程存储允许客户端对log和Kv数据进行批量读取操作，从而提高数据分析效率并减少Fluss服务器上的开销。未来，它还将支持批量写入操作，优化数据导入工作流程，以实现更大的可扩展性和性能。</p>
<h4 id="28-client">2.8 Client</h4>
<p>Fluss 客户端/SDK 支持流式读取/写入、批量读取/写入、DDL 和点查询。目前，客户端的主要实现是 Flink Connector。用户可以使用 Flink SQL 轻松操作 Fluss 表和数据。</p>
<h3 id="3-表设计">3. 表设计</h3>
<h4 id="31-概述">3.1 概述</h4>
<h5 id="311-database">3.1.1 Database</h5>
<p>数据库是表对象的集合。您可以在数据库中创建/删除数据库或创建/修改/删除表</p>
<h5 id="312-table">3.1.2 Table</h5>
<p>在Fluss中，表是用户数据存储的基本单元，由行和列组成。表存储在特定的数据库中，遵循层次结构（数据库 -&gt; 表）</p>
<p>根据主键的存在与否，表格分为两种类型：</p>
<ul>
<li>Log Tables<br>
专为仅追加场景设计，仅支持 INSERT 操作。</li>
<li>PrimaryKey Tables<br>
用于更新和管理业务数据库中的数据，支持基于定义的主键的 INSERT、UPDATE 和 DELETE 操作。</li>
</ul>
<p>当定义了分区列时，一个表会变成一个分区表。具有相同分区值的数据存储在同一个分区中。分区列可以应用于日志表和主键表，但需要考虑特定的因素：</p>
<ul>
<li>对于日志表，分区通常用于日志数据，通常基于日期列，以促进数据分离和清理</li>
<li>对于主键表，分区列必须是主键的子集，以确保唯一性<br>
该设计确保了高效的数据组织、处理不同用例的灵活性以及遵守数据完整性约束</li>
</ul>
<h5 id="313-table-数据组织">3.1.3 Table 数据组织</h5>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116161929326-199683529.png" alt="image" loading="lazy"></p>
<h6 id="3131-partition">3.1.3.1 Partition</h6>
<p>一个分区是根据一个或多个指定列（称为分区列）的值，将表的数据逻辑地划分为更小、更易于管理的子集。 分区列中的每个唯一值（或值的组合）定义了一个不同的分区</p>
<h6 id="3132-bucket">3.1.3.2 Bucket</h6>
<p>一个Bucket水平地将表/分区的数据根据桶策略划分为N个Bucket。 每个表可以配置N个Bucket的数量。Bucket是数据迁移和备份的最小单位。 Bucket的数据由一个LogTablet和一个（可选的）KvTablet组成</p>
<h6 id="3133-logtablet">3.1.3.3 LogTablet</h6>
<p>每个日志和主键表都需要生成一个LogTablet。 对于日志表，LogTablet既是primary table 数据又是日志数据。对于主键表，LogTablet充当primary table数据的日志数据</p>
<ul>
<li>Segment: LogTablet 中日志存储的最小单元。一个Segment由一个 .index 文件和一个 .log 数据文件组成</li>
<li>.index： 一个offset稀疏索引，用于存储消息中相对于offset的物理字节地址与.log文件之间的映射</li>
<li>.log: 日志数据的紧凑排列</li>
</ul>
<h6 id="3134-kvtablet">3.1.3.4 KvTablet</h6>
<p>PrimaryKey 表中的每个桶都需要生成一个 KvTablet。底层上，每个 KvTablet 对应一个嵌入的 RocksDB 实例。RocksDB 是一个 LSM（log structured merge）引擎，它帮助 KvTablet 支持高性能更新和查找查询</p>
<h4 id="32-表类型">3.2 表类型</h4>
<h5 id="321-log-table">3.2.1 Log Table</h5>
<p>日志表是Fluss中的一种表，用于按写入顺序存储数据。日志表仅支持追加记录，不支持更新/删除操作。 通常，日志表用于存储高吞吐量的日志，例如Apache Kafka的典型用例</p>
<p>日志表是在CREATE TABLE语句中未指定PRIMARY KEY子句时创建的。例如，以下Flink SQL语句将创建一个包含3个桶的日志表</p>
<pre><code>CREATE TABLE log_table (
  order_id BIGINT,
  item_id BIGINT,
  amount INT,
  address STRING
)
WITH ('bucket.num' = '3');
</code></pre>
<p>bucket.num 应该是一个正整数。如果未提供此值，集群将使用默认值作为表中的桶号</p>
<p><strong>bucket 分配</strong><br>
bucket是Fluss并行性和可扩展性的基本单元。Fluss中的一个表被划分为多个bucket。bucket是读取和写入的最小存储单元<br>
当将记录写入日志表时，Fluss会根据桶分配策略将每个记录分配到特定的桶中。Fluss中有3种桶分配策略：</p>
<ol>
<li>
<p>Sticky Bucket Strategy: 作为默认策略，随机选择一个桶，并持续写入该桶，直到记录批次填满。将client.writer.bucket.no-key-assigner=sticky设置为表属性以启用此策略</p>
</li>
<li>
<p>Round-Robin Strategy: 在写入记录之前，以轮询方式选择一个桶。将client.writer.bucket.no-key-assigner=round_robin设置为表属性以启用此策略</p>
</li>
<li>
<p>Hash-based Bucketing： 如果在表属性中设置了bucket.key属性，Fluss将根据指定桶键的哈希值来确定将记录分配到哪个桶，并且属性client.writer.bucket.no-key-assigner将被忽略。例如，设置'bucket.key' = 'c1,c2'将根据列c1和c2的值来分配桶。不同的列名应该用逗号分隔</p>
</li>
</ol>
<p><strong>Data Consumption</strong><br>
Fluss 中的日志表允许实时数据消费，同时保留每个桶中数据的写入顺序。具体来说</p>
<ul>
<li>对于来自同一表和同一桶的两个数据记录，首先写入Fluss表的数据将被优先消费</li>
<li>对于来自同一分区但不同桶的两个数据记录，消费顺序无法保证，因为不同的桶可能会被不同的数据消费作业同时处理</li>
</ul>
<p><strong>Log Tiering</strong><br>
日志表支持将数据分层存储到不同的存储层级</p>
<h5 id="322-primarykey-table">3.2.2 PrimaryKey Table</h5>
<p>Fluss中的主键表确保指定主键的唯一性，并支持INSERT、UPDATE和DELETE操作<br>
通过在CREATE TABLE语句中指定PRIMARY KEY子句来创建一个主键表。例如，以下Flink SQL语句创建了一个主键表，其中shop_id和user_id作为主键，并将数据分布到4个桶中：</p>
<pre><code>CREATE TABLE pk_table (
  shop_id BIGINT,
  user_id BIGINT,
  num_orders INT,
  total_amount INT,
  PRIMARY KEY (shop_id, user_id) NOT ENFORCED
) WITH (
  'bucket.num' = '4'
);
</code></pre>
<p>在Fluss主键表中，每行数据都有一个唯一的主键。 如果向Fluss主键表中写入多个具有相同主键的条目，则只保留最后一个条目<br>
对于分区主键表，主键必须包含分区键。</p>
<p><strong>bucket分配</strong><br>
对于主键表，Fluss总是根据每个记录的主键哈希值来确定数据属于哪个bucket。 具有相同哈希值的数据将被分配到同一个bucket中</p>
<p><strong>Partial Update</strong><br>
对于主键表，Fluss 支持部分列更新，允许您只写入部分列来逐步更新数据，最终实现完整数据。请注意，写入的列必须包括主键列<br>
例如，考虑以下Fluss主键表：</p>
<pre><code>CREATE TABLE T (
  k INT,
  v1 DOUBLE,
  v2 STRING,
  PRIMARY KEY (k) NOT ENFORCED
);
</code></pre>
<p>假设在开始时，只有k和v1列写入数据+I(1, 2.0)、+I(2, 3.0)，T中的数据如下：</p>
<table>
<thead>
<tr>
<th>k</th>
<th>v1</th>
<th>v2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2.0</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>3.0</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>然后，将数据 +I(1, 't1')、+I(2, 't2') 写入 k 和 v2 列，结果 T 中的数据如下：</p>
<table>
<thead>
<tr>
<th>k</th>
<th>v1</th>
<th>v2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2.0</td>
<td>t1</td>
</tr>
<tr>
<td>2</td>
<td>3.0</td>
<td>t2</td>
</tr>
</tbody>
</table>
<p><strong>数据查询</strong></p>
<p>对于主键表，Fluss 支持直接根据键查询数据</p>
<p><strong>Changelog Generation</strong></p>
<p>Fluss 将捕获在主键表上插入、更新、删除记录时的变化，这被称为变更日志。下游消费者可以直接消费变更日志以获取表中的变化。例如，考虑 Fluss 中的以下主键表：</p>
<pre><code>CREATE TABLE T (
  k INT,
  v1 DOUBLE,
  v2 STRING,
  PRIMARY KEY (k) NOT ENFORCED
);
</code></pre>
<p>如果写入主键表的数据是顺序的 +I(1, 2.0, 'apple')、+I(1, 4.0, 'banana')、-D(1, 4.0, 'banana')，那么将生成以下变更数据:</p>
<pre><code>+I(1, 2.0, 'apple')
-U(1, 2.0, 'apple')
+U(1, 4.0, 'banana')
-D(1, 4.0, 'banana')
</code></pre>
<p><strong>Data Consumption</strong><br>
对于主键表，默认的消费方式是先全量快照，然后是增量数据。首先，消费表的全量快照数据，然后是表的binlog数据。<br>
也可以只消费表中的binlog数据</p>
<h4 id="33-数据分布">3.3 数据分布</h4>
<h5 id="331--bucketing">3.3.1  Bucketing</h5>
<p>桶策略是一种数据分布技术，它将表数据分成小块，并将数据分布到多个主机和服务中<br>
当创建Fluss表时，您可以通过为表设置'bucket.num' = '<num>'属性来指定桶的数量。 目前，Fluss支持3种桶策略：Hash Bucketing、Sticky Bucketing和Round-Robin Bucketing。 主键表只允许使用Hash Bucketing。日志表默认使用Sticky Bucketing，但也可以使用其他两种桶策略。</num></p>
<p><strong>Hash Bucketing</strong><br>
哈希桶划分在OLAP场景中很常见。 其优势在于可以非常均匀地分布到多个节点上，充分利用分布式计算的能力，并且具有出色的可扩展性（重新划分桶或集群），以应对海量数据。<br>
用法：为表设置'bucket.key' = 'col1, col2'属性，以指定哈希分桶的桶键。 主键表默认使用主键（不包括分区键）作为桶键</p>
<p><strong>Sticky Bucketing</strong><br>
Sticky Bucketing在将记录写入日志表时，能够支持更大的批次并减少延迟。发送一个批次后，Sticky Bucketing会发生变化。随着时间的推移，记录会均匀地分布在所有桶中。 Sticky Bucketing策略是日志表的默认桶策略。这非常重要，因为日志表使用Apache Arrow作为底层数据格式，对于大批次来说非常高效。<br>
用法：为表设置'client.writer.bucket.no-key-assigner'='sticky'属性以启用此策略。主键表不支持此策略</p>
<p><strong>Round-Robin Bucketing</strong><br>
轮询桶策略是一种简单的策略，在写入记录之前，随机选择一个桶。这种策略适用于数据分布相对均匀且数据没有偏斜的场景<br>
用法：为表设置'client.writer.bucket.no-key-assigner'='round_robin'属性以启用此策略。PrimaryKey表不支持此策略</p>
<h5 id="332-分区表">3.3.2 分区表</h5>
<p>在Fluss中，一个分区表根据一个或多个分区键组织数据，提供了一种提高查询性能和管理大型数据集的方法。分区允许系统将数据划分为不同的段，每个段对应于分区键的特定值</p>
<p>对于分区表，Fluss 支持自动分区创建。可以根据在创建表时配置的自动分区规则自动创建分区，并且过期的分区会自动删除，确保数据不会无限扩展</p>
<p><strong>分区表的主要好处:</strong></p>
<ul>
<li>改进查询性能：通过将查询范围缩小到特定的分区，系统读取的数据更少，从而减少了查询执行时间</li>
<li>数据组织：分区有助于逻辑地组织数据，使其更容易管理和查询</li>
<li>可扩展性：对大型数据集进行分区可以将数据分布到更小、更易于管理的块中，从而提高可扩展性</li>
</ul>
<p><strong>限制:</strong></p>
<ul>
<li>只支持一个分区键，分区键的类型必须是字符串</li>
<li>如果表是主键表，则分区键必须是主键的子集</li>
<li>自动分区规则只能在创建分区表时进行配置；在表创建后修改自动分区规则是不支持的</li>
</ul>
<p><strong>自动分区选项</strong><br>
自动分区规则通过表选项进行配置。以下示例演示了如何使用Flink SQL创建一个名为site_access的表，该表支持自动分区。</p>
<pre><code>CREATE TABLE site_access(
  event_day STRING,
  site_id INT,
  city_code STRING,
  user_name STRING,
  pv BIGINT,
  PRIMARY KEY(event_day, site_id) NOT ENFORCED 
) PARTITIONED BY (event_day) WITH (
  'table.auto-partition.enabled' = 'true',
  'table.auto-partition.time-unit' = 'YEAR',
  'table.auto-partition.num-precreate' = '5',
  'table.auto-partition.num-retention' = '2',
  'table.auto_partitioning.time-zone' = 'Asia/Shanghai'
);
</code></pre>
<p>在这种情况下，当自动分区发生时（Fluss 将定期在后台对所有表进行操作），会预先创建四个分区，分区粒度为“年”，保留两个历史分区。时区设置为“Asia/Shanghai”</p>
<p><strong>分区生成规则</strong><br>
自动分区表的时间单位 auto-partition.time-unit 可以取值为 HOUR、DAY、MONTH、QUARTER 或 YEAR。自动分区将使用以下格式创建分区</p>
<table>
<thead>
<tr>
<th>Time Unit</th>
<th>Partition Format</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOUR</td>
<td>yyyyMMddHH</td>
<td>2024091922</td>
</tr>
<tr>
<td>DAY</td>
<td>yyyyMMdd</td>
<td>20240919</td>
</tr>
<tr>
<td>MONTH</td>
<td>yyyyMM</td>
<td>202409</td>
</tr>
<tr>
<td>QUARTER</td>
<td>yyyyQ</td>
<td>20241</td>
</tr>
<tr>
<td>YEAR</td>
<td>yyyy</td>
<td>2024</td>
</tr>
</tbody>
</table>
<p><strong>Fluss集群配置</strong><br>
以下是与Fluss集群和自动分区相关的配置项。</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto-partition.check.interval</td>
<td>Duration</td>
<td>10 minutes</td>
<td>自动分区检查的时间间隔默认设置为10分钟，这意味着它每10分钟检查一次表的分区状态，以查看是否符合自动分区的标准。如果不符合标准，分区将自动创建或删除。</td>
</tr>
</tbody>
</table>
<h5 id="333-ttl">3.3.3 TTL</h5>
<p>Fluss 支持通过为表设置 TTL 属性来支持数据 TTL，格式为 'table.log.ttl' = '<duration>'（默认值为 7 天）。Fluss 可以定期自动检查并清理表中过期的数据</duration></p>
<p>对于日志表，此属性表示日志表数据的过期时间。 对于主键表，此属性表示其binlog的过期时间，并不代表主键表数据的过期时间。如果您也想让主键表中的数据自动过期，请使用自动分区</p>
<h4 id="34-数据类型">3.4 数据类型</h4>
<p>Fluss 为用户提供了一组丰富的本地数据类型。Fluss 的所有数据类型如下：</p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BOOLEAN</td>
<td>一个带有（可能）三值逻辑的布尔值：TRUE, FALSE, UNKNOWN。</td>
</tr>
<tr>
<td>TINYINT</td>
<td>1字节有符号整数，范围从 -128 到 127。</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2字节有符号整数，范围从 -32,768 到 32,767。</td>
</tr>
<tr>
<td>INT</td>
<td>4字节有符号整数，范围从 -2,147,483,648 到 2,147,483,647。</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8字节有符号整数，范围从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4字节单精度浮点数。</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8字节双精度浮点数。</td>
</tr>
<tr>
<td>CHAR(n)</td>
<td>固定长度字符字符串，其中 n 是代码点的数量。n 必须在 1 和 Integer.MAX_VALUE 之间（包括两端）。</td>
</tr>
<tr>
<td>STRING</td>
<td>可变长度字符字符串。</td>
</tr>
<tr>
<td>DECIMAL(p, s)</td>
<td>精度和比例固定的十进制数，其中 p 是数字的总位数（=精度），s 是小数点右侧的位数（=比例）。p 必须在 1 和 38 之间（包括两端）。s 必须在 0 和 p 之间（包括两端）。</td>
</tr>
<tr>
<td>DATE</td>
<td>年-月-日格式的日期，范围从 0000-01-01 到 9999-12-31。</td>
</tr>
<tr>
<td>TIME</td>
<td>默认情况下没有时区且无分数秒的时间。实例由小时:分钟:秒组成，精度最高可达秒，范围从 00:00:00 到 23:59:59。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.LocalTime。</td>
</tr>
<tr>
<td>TIME(p)</td>
<td>没有时区的时间，p 表示分数秒的位数（=精度）。p 必须在 0 和 9 之间（包括两端）。实例由小时:分钟:秒[.小数部分]组成，精度最高可达纳秒，范围从 00:00:00.000000000 到 23:59:59.999999999。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.LocalTime。</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>默认情况下没有时区的时间戳，分数秒有 6 位。实例由年-月-日 小时:分钟:秒[.小数部分]组成，精度最高可达微秒，范围从 0000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.LocalDateTime。</td>
</tr>
<tr>
<td>TIMESTAMP(p)</td>
<td>没有时区的时间戳，p 表示分数秒的位数（=精度）。p 必须在 0 和 9 之间（包括两端）。实例由年-月-日 小时:分钟:秒[.小数部分]组成，精度最高可达纳秒，范围从 0000-01-01 00:00:00.000000000 到 9999-12-31 23:59:59.999999999。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.LocalDateTime。</td>
</tr>
<tr>
<td>TIMESTAMP_LTZ</td>
<td>带有时区的时间戳，默认分数秒有 6 位。实例由年-月-日 小时:分钟:秒[.小数部分] 组成，精度最高可达微秒，范围从 0000-01-01 00:00:00.000000 +14:59 到 9999-12-31 23:59:59.999999 -14:59。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.OffsetDateTime。</td>
</tr>
<tr>
<td>TIMESTAMP_LTZ(p)</td>
<td>带有时区的时间戳，p 表示分数秒的位数（=精度）。p 必须在 0 和 9 之间（包括两端）。实例由年-月-日 小时:分钟:秒[.小数部分] 组成，精度最高可达纳秒，范围从 0000-01-01 00:00:00.000000000 到 9999-12-31 23:59:59.999999999。不支持闰秒（23:59:60 和 23:59:61），语义上更接近 java.time.LocalDateTime。</td>
</tr>
<tr>
<td>BYTES</td>
<td>可变长度二进制字符串（=字节序列）。</td>
</tr>
</tbody>
</table>
<h3 id="4-流式湖仓">4. 流式湖仓</h3>
<p>Lakehouse 代表了一种新的开放架构，它结合了数据湖和数据仓库的最佳元素。 它将数据湖的可扩展性和成本效益与数据仓库的可靠性和性能相结合。 众所周知的数据湖格式，如 Apache Iceberg、Apache Paimon、Apache Hudi 和 Delta Lake 在 Lakehouse 架构中扮演着关键角色， 促进在单一、统一平台内数据存储、可靠性和分析能力之间的和谐平衡。 湖仓作为现代架构，在解决数据管理和分析复杂需求方面非常有效。 但由于它们的实现限制，它们很难满足需要亚秒级数据新鲜度的实时分析场景。 使用这些数据湖格式，你会陷入一个矛盾的局面：<br>
1.如果你需要低延迟，那么你需要频繁地写入和提交，这意味着会有很多小的 Parquet 文件。这对于必须处理大量小文件的读取操作来说变得低效<br>
2.如果你需要读取效率，那么你会累积数据，直到可以写入大型 Parquet 文件，但这会引入 更高的延迟</p>
<p>总体而言，这些数据湖格式在最佳使用条件下，通常也只能达到分钟级的数据新鲜度</p>
<p><strong>流处理与湖仓一体化</strong><br>
Fluss 是一种支持亚秒级低延迟的流式存储，支持流式读取和写入。 Fluss 通过在 Lakehouse 之上提供实时流数据，将数据流和数据 Lakehouse 统一。 这不仅为数据 Lakehouse 带来了低延迟，还为数据流增加了强大的分析功能</p>
<p>为了构建Streaming Lakehouse，Fluss维护了一个压缩服务，用于将Fluss集群中的实时数据压缩到Lakehouse存储中。 Fluss集群中的数据（流式Arrow格式）针对低延迟读写进行了优化，而Lakehouse中的压缩数据（带有压缩的Parquet格式）则针对强大的分析和存储长期数据进行了优化。 因此，Fluss集群中的数据服务于实时数据层，保留具有亚秒级新鲜度的几天数据，而Lakehouse中的数据服务于历史数据层，保留具有分钟级新鲜度的几个月数据</p>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116163402214-356185581.png" alt="image" loading="lazy"></p>
<p>Streaming Lakehouse 的核心思想是流和 Lakehouse 之间的共享数据和共享元数据，避免数据重复和元数据不一致。 它提供的一些强大功能包括：</p>
<ul>
<li>统一元数据：Fluss为Stream和Lakehouse中的数据提供了一个统一的表元数据。因此，用户只需处理一个表，但可以访问实时流数据、历史数据或它们的联合</li>
<li>Union Reads：计算引擎在表上执行查询时，将读取实时流数据与Lakehouse数据的联合。目前，只有Flink支持联合读取，但更多引擎已在roadmap上</li>
<li>实时湖仓：联合读取有助于湖仓从近实时分析发展到真正的实时分析。这使得企业能够从实时数据中获得更有价值的洞察</li>
<li>流式分析：该联合读取帮助数据流以具备强大的分析能力。这减少了开发流应用程序的复杂性，简化了调试过程，并允许立即访问实时数据洞察</li>
<li>连接到Lakehouse生态系统：Fluss将表元数据与数据湖目录保持同步，同时将数据压缩到Lakehouse中。这使得外部引擎如Spark、StarRocks、Flink、Trino可以直接通过连接到数据湖目录来读取数据</li>
</ul>
<p>目前，Fluss 支持 Paimon 作为 Lakehouse 存储，更多种类的数据湖格式将在roadmap中</p>
<h3 id="5-how">5. How</h3>
<p>下面使用Apache Flink进行实时分析，涵盖Fluss的一些强大功能，包括与Paimon的集成</p>
<h4 id="51-安装docker">5.1 安装docker</h4>
<ol>
<li>设置docker yum源</li>
</ol>
<pre><code>sudo yum install -y yum-utils
sudo yum-config-manager \
--add-repo \
http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ol start="2">
<li>安装docker</li>
</ol>
<pre><code>sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre>
<ol start="3">
<li>启动docker</li>
</ol>
<pre><code>sudo systemctl start docker
</code></pre>
<ol start="4">
<li>设置开机自启动</li>
</ol>
<pre><code>sudo systemctl enable docker
</code></pre>
<ol start="5">
<li>docker镜像配置</li>
</ol>
<pre><code># 创建目录

sudo mkdir -p /etc/docker

# 写入配置文件

sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'

{

    "registry-mirrors": [

        "https://docker-0.unsee.tech",

        "https://docker-cf.registry.cyou",

        "https://docker.1panel.live"

    ]

}

EOF


# 重启docker服务

sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker
</code></pre>
<h4 id="52-启动所需要的组件">5.2 启动所需要的组件</h4>
<ol>
<li>创建工作目录</li>
</ol>
<pre><code>mkdir fluss-quickstart-flink &amp; cd fluss-quickstart-flink
</code></pre>
<ol start="2">
<li>创建一个名为docker-compose.yml的文件</li>
</ol>
<pre><code>services:
  coordinator-server:
    image: fluss/fluss:0.5.0
    command: coordinatorServer
    depends_on:
      - zookeeper
    environment:
      - |
        FLUSS_PROPERTIES=
        zookeeper.address: zookeeper:2181
        coordinator.host: coordinator-server
        remote.data.dir: /tmp/fluss/remote-data
        lakehouse.storage: paimon
        paimon.catalog.metastore: filesystem
        paimon.catalog.warehouse: /tmp/paimon
  tablet-server:
    image: fluss/fluss:0.5.0
    command: tabletServer
    depends_on:
      - coordinator-server
    environment:
      - |
        FLUSS_PROPERTIES=
        zookeeper.address: zookeeper:2181
        tablet-server.host: tablet-server
        data.dir: /tmp/fluss/data
        remote.data.dir: /tmp/fluss/remote-data
        kv.snapshot.interval: 0s
        lakehouse.storage: paimon
        paimon.catalog.metastore: filesystem
        paimon.catalog.warehouse: /tmp/paimon
  zookeeper:
    restart: always
    image: zookeeper:3.8.4

  jobmanager:
    image: fluss/quickstart-flink:1.20-0.5
    ports:
      - "8083:8081"
    command: jobmanager
    environment:
      - |
        FLINK_PROPERTIES=
        jobmanager.rpc.address: jobmanager
    volumes:
      - shared-tmpfs:/tmp/paimon
  taskmanager:
    image: fluss/quickstart-flink:1.20-0.5
    depends_on:
      - jobmanager
    command: taskmanager
    environment:
      - |
        FLINK_PROPERTIES=
        jobmanager.rpc.address: jobmanager
        taskmanager.numberOfTaskSlots: 10
        taskmanager.memory.process.size: 2048m
        taskmanager.memory.framework.off-heap.size: 256m
    volumes:
      - shared-tmpfs:/tmp/paimon

volumes:
  shared-tmpfs:
    driver: local
    driver_opts:
      type: "tmpfs"
      device: "tmpfs"
</code></pre>
<p>Docker Compose 环境由以下容器组成：</p>
<ul>
<li>Fluss集群：一个Fluss CoordinatorServer，一个Fluss TabletServer 和一个ZooKeeper服务器</li>
<li>Flink集群：一个Flink JobManager 和一个Flink TaskManager 容器，用于执行查询。</li>
</ul>
<p>注意： fluss/quickstart-flink 镜像是基于 flink:1.20.0-java17，并包含 fluss-connector-flink、paimon-flink 和 flink-connector-faker</p>
<ol start="3">
<li>要启动所有容器，请运行：</li>
</ol>
<pre><code>docker compose up -d
</code></pre>
<p>该命令会自动以分离模式启动Docker Compose配置中定义的所有容器</p>
<pre><code>docker ps
</code></pre>
<p>检查所有容器是否正常运行</p>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164604943-598378970.png" alt="image" loading="lazy"></p>
<p>您也可以访问 <a href="http://localhost:8083/%EF%BC%8C%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener nofollow">http://localhost:8083/，查看</a> Flink 是否正常运行</p>
<blockquote>
<p>如果你想使用自己的Flink环境运行，请记得下载fluss-connector-flink、flink-connector-faker、paimon-flink连接器的jar文件，并将它们放入FLINK_HOME/lib/<br>
所有涉及docker compose的以下命令应在包含docker-compose.yml文件的创建工作目录中执行</p>
</blockquote>
<h4 id="53-进入sql客户端">5.3 进入SQL客户端</h4>
<p>首先，使用以下命令进入 Flink SQL CLI 容器：</p>
<pre><code>docker compose exec jobmanager ./sql-client
</code></pre>
<p>注意： 为了简化本指南，已预先创建了三个临时表，使用faker连接器生成数据。 您可以通过运行以下命令查看它们的模式：</p>
<pre><code>show create table source_customer

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164644208-967707881.png" alt="image" loading="lazy"></p>
<h4 id="54-创建fluss表格">5.4 创建Fluss表格</h4>
<h5 id="541-创建fluss-catalog">5.4.1 创建fluss catalog</h5>
<pre><code>CREATE CATALOG my_fluss WITH (
    'type' = 'fluss',
    'bootstrap.servers' = 'coordinator-server:9123'
);

USE CATALOG my_fluss;
</code></pre>
<h5 id="542-创建表">5.4.2 创建表</h5>
<p>运行以下 SQL 来创建 Fluss 表：</p>
<pre><code>CREATE TABLE fluss_order (
    `order_key` BIGINT,
    `cust_key` INT NOT NULL,
    `total_price` DECIMAL(15, 2),
    `order_date` DATE,
    `order_priority` STRING,
    `clerk` STRING,
    `ptime` AS PROCTIME(),
    PRIMARY KEY (`order_key`) NOT ENFORCED
);

CREATE TABLE fluss_customer (
    `cust_key` INT NOT NULL,
    `name` STRING,
    `phone` STRING,
    `nation_key` INT NOT NULL,
    `acctbal` DECIMAL(15, 2),
    `mktsegment` STRING,
    PRIMARY KEY (`cust_key`) NOT ENFORCED
);

CREATE TABLE `fluss_nation` (
  `nation_key` INT NOT NULL,
  `name`       STRING,
   PRIMARY KEY (`nation_key`) NOT ENFORCED
);

CREATE TABLE enriched_orders (
    `order_key` BIGINT,
    `cust_key` INT NOT NULL,
    `total_price` DECIMAL(15, 2),
    `order_date` DATE,
    `order_priority` STRING,
    `clerk` STRING,
    `cust_name` STRING,
    `cust_phone` STRING,
    `cust_acctbal` DECIMAL(15, 2),
    `cust_mktsegment` STRING,
    `nation_name` STRING,
    PRIMARY KEY (`order_key`) NOT ENFORCED
);
</code></pre>
<h4 id="55-流式写入-fluss">5.5 流式写入 Fluss</h4>
<p>首先，运行以下 SQL 将数据从源表同步到 Fluss 表</p>
<pre><code>EXECUTE STATEMENT SET
BEGIN
    INSERT INTO fluss_nation SELECT * FROM `default_catalog`.`default_database`.source_nation;
    INSERT INTO fluss_customer SELECT * FROM `default_catalog`.`default_database`.source_customer;
    INSERT INTO fluss_order SELECT * FROM `default_catalog`.`default_database`.source_order;
END;
</code></pre>
<p>Fluss 主键表支持高 QPS（每秒查询率）的主键点查查询。执行查找连接（lookup join）非常高效，您可以使用它来通过 fluss_customer 和 fluss_nation 主键表中的信息丰富 fluss_orders 表</p>
<pre><code>INSERT INTO enriched_orders
SELECT o.order_key, 
       o.cust_key, 
       o.total_price,
       o.order_date, 
       o.order_priority,
       o.clerk,
       c.name,
       c.phone,
       c.acctbal, 
       c.mktsegment,
       n.name
FROM fluss_order o 
LEFT JOIN fluss_customer FOR SYSTEM_TIME AS OF `o`.`ptime` AS `c` 
    ON o.cust_key = c.cust_key
LEFT JOIN fluss_nation FOR SYSTEM_TIME AS OF `o`.`ptime` AS `n` 
    ON c.nation_key = n.nation_key;
</code></pre>
<h4 id="56-在-fluss-表上运行临时查询">5.6 在 Fluss 表上运行临时查询</h4>
<p>现在，您可以直接在 Fluss 表上执行实时分析。例如，要计算特定客户下的订单数量，您可以执行以下 SQL 查询以获得即时的、实时的结果</p>
<pre><code>-- use tableau result mode
SET 'sql-client.execution.result-mode' = 'tableau';

-- switch to batch mode
SET 'execution.runtime-mode' = 'batch';

-- use limit to query the enriched_orders table
SELECT * FROM enriched_orders LIMIT 2;
</code></pre>
<p>结果：<br>
<img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164811746-2015336927.png" alt="image" loading="lazy"></p>
<p>如果您对特定客户感兴趣，可以通过在 cust_key 上执行查找来检索其详细信息。例如，您可以使用以下 SQL 查询来获取特定客户的详细信息：</p>
<pre><code>-- lookup by primary key
SELECT * FROM fluss_customer WHERE `cust_key` = 1;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164855013-1539475537.png" alt="image" loading="lazy"></p>
<p>总体来说，查询结果能够非常快速地返回，因为 Fluss 为定义了主键的表启用了高效的主键查找功能</p>
<h4 id="57--updatedelete-rows-on-fluss-tables">5.7  Update/Delete rows on Fluss Tables</h4>
<p>您可以使用 UPDATE 和 DELETE 语句来更新或删除 Fluss 表中的行</p>
<h5 id="571-update">5.7.1 Update</h5>
<pre><code>-- update by primary key
UPDATE fluss_customer SET `name` = 'fluss_updated' WHERE `cust_key` = 1;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164911448-628273920.png" alt="image" loading="lazy"></p>
<p>name列的数据已经更新成了fluss_updated</p>
<h5 id="572-delete">5.7.2 Delete</h5>
<pre><code>DELETE FROM fluss_customer WHERE `cust_key` = 1;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116164928408-2127114638.png" alt="image" loading="lazy"></p>
<h4 id="58-集成pamion">5.8 集成pamion</h4>
<h5 id="581-启动-lakehouse-分层服务">5.8.1 启动 Lakehouse 分层服务</h5>
<p>要与 Apache Paimon 集成，您需要启动 Lakehouse 分层服务。请打开一个新的终端，导航到 fluss-quickstart-flink 目录，并在此目录中执行以下命令以启动该服务：</p>
<pre><code>docker compose exec coordinator-server ./bin/lakehouse.sh -D flink.rest.address=jobmanager -D flink.rest.port=8081 -D flink.execution.checkpointing.interval=30s
</code></pre>
<p>在 Flink Web UI 中看到一个名为 fluss-paimon-tiering-service 的运行中的 Flink 作业</p>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116165015212-935827107.png" alt="image" loading="lazy"></p>
<h5 id="582-将数据流式写入-fluss-数据湖启用的表">5.8.2 将数据流式写入 Fluss 数据湖启用的表</h5>
<p>默认情况下，表的创建是不启用数据湖集成的，这意味着 Lakehouse 分层服务不会将表的数据分层存储到数据湖中。<br>
要为表启用作为分层存储解决方案的Lakehouse功能，您必须使用配置选项 table.datalake.enabled = true 创建该表。请返回 SQL 客户端并执行以下 SQL 语句，以创建启用了数据湖集成的表：</p>
<pre><code>CREATE TABLE datalake_enriched_orders (
    `order_key` BIGINT,
    `cust_key` INT NOT NULL,
    `total_price` DECIMAL(15, 2),
    `order_date` DATE,
    `order_priority` STRING,
    `clerk` STRING,
    `cust_name` STRING,
    `cust_phone` STRING,
    `cust_acctbal` DECIMAL(15, 2),
    `cust_mktsegment` STRING,
    `nation_name` STRING,
    PRIMARY KEY (`order_key`) NOT ENFORCED
) WITH ('table.datalake.enabled' = 'true');
</code></pre>
<p>接下来，执行流式数据写入到启用了数据湖的表 datalake_enriched_orders 中</p>
<pre><code>-- switch to streaming mode
SET 'execution.runtime-mode' = 'streaming';
</code></pre>
<pre><code>-- insert tuples into datalake_enriched_orders
INSERT INTO datalake_enriched_orders
SELECT o.order_key,
       o.cust_key,
       o.total_price,
       o.order_date,
       o.order_priority,
       o.clerk,
       c.name,
       c.phone,
       c.acctbal,
       c.mktsegment,
       n.name
FROM fluss_order o
       LEFT JOIN fluss_customer FOR SYSTEM_TIME AS OF `o`.`ptime` AS `c`
                 ON o.cust_key = c.cust_key
       LEFT JOIN fluss_nation FOR SYSTEM_TIME AS OF `o`.`ptime` AS `n`
                 ON c.nation_key = n.nation_key;
</code></pre>
<h5 id="583-fluss-数据湖启用表上的实时分析">5.8.3 Fluss 数据湖启用表上的实时分析</h5>
<p>datalake_enriched_orders 表的数据存储在两个地方：Fluss（用于实时数据）和 Paimon（用于历史数据）<br>
当查询 datalake_enriched_orders 表时，Fluss 使用联合操作（union operation），将来自 Fluss 和 Paimon 的数据合并在一起，以提供完整的数据集——即结合了实时数据和历史数据的结果.<br>
如果您只想查询存储在 Paimon 中的数据——这样可以提供高性能访问而无需承担联合数据的开销——您可以使用带有 <span class="math inline">\(lake 后缀的 datalake_enriched_orders\)</span>lake 表。这种方法也启用了所有 Flink Paimon table source 的优化和特性，包括系统表，如datalake_enriched_orders<span class="math inline">\(lake\)</span>snapshots</p>
<p>要直接从 Paimon 查询快照，请使用以下 SQL 语句:</p>
<pre><code>-- switch to batch mode
SET 'execution.runtime-mode' = 'batch';

-- query snapshots in paimon

SELECT snapshot_id, total_record_count FROM datalake_enriched_orders$lake$snapshots;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116165132316-1886278870.png" alt="image" loading="lazy"></p>
<p>确保在查询快照之前等待检查点（~30秒）完成，否则结果将是空的</p>
<p>要对 Paimon 中的数据进行分析，请运行以下 SQL 语句:</p>
<pre><code>-- to sum prices of all orders in paimon
 SELECT sum(total_price) as sum_price FROM datalake_enriched_orders$lake;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116165157927-1707506828.png" alt="image" loading="lazy"></p>
<p>为了实现亚秒级的数据新鲜度，您可以直接查询表，这将无缝统一来自 Fluss 和 Paimon 的数据</p>
<pre><code>-- to sum prices of all orders in fluss and paimon

SELECT sum(total_price) as sum_price FROM datalake_enriched_orders;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/682547/202501/682547-20250116165210257-1195246916.png" alt="image" loading="lazy"></p>
<p>您可以多次执行实时分析查询，并且每次的结果可能会有所不同，因为新的数据会持续实时地写入 Fluss。随着新数据的流入，查询结果将反映出最新的状态<br>
最终，您可以使用以下命令来查看存储在 Paimon 中的文件</p>
<pre><code>docker compose exec taskmanager tree /tmp/paimon/fluss.db
</code></pre>
<pre><code>[root@bigdata-bussiness-prod fluss-quickstart-flink]# docker compose exec taskmanager tree /tmp/paimon/fluss.db
/tmp/paimon/fluss.db
└── datalake_enriched_orders
    ├── bucket-0
    │   ├── changelog-c283a7b6-eb51-41cd-9950-5898a509baf1-0.orc
    │   └── data-c283a7b6-eb51-41cd-9950-5898a509baf1-1.orc
    ├── manifest
    │   ├── manifest-7c574c54-03f6-4b93-81e6-ef19d798868d-0
    │   ├── manifest-7c574c54-03f6-4b93-81e6-ef19d798868d-1
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-0
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-1
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-2
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-3
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-4
    │   ├── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-5
    │   └── manifest-list-f14c24ba-8c1b-4cd7-8186-0a195a1509f9-6
    ├── schema
    │   └── schema-0
    └── snapshot
        ├── EARLIEST
        ├── LATEST
        ├── snapshot-1
        ├── snapshot-2
        └── snapshot-3
</code></pre>
<p>Paimon 存储的文件遵循标准格式，这使得它们可以与其它查询引擎（如 StarRocks）无缝集成和查询</p>
<h4 id="59-clean-up">5.9 clean up</h4>
<p>停止所有的容器</p>
<pre><code>docker compose down -v
</code></pre>
<h3 id="6-reference">6. Reference</h3>
<ol>
<li><a href="https://alibaba.github.io/fluss-docs/" target="_blank" rel="noopener nofollow">https://alibaba.github.io/fluss-docs/</a></li>
</ol>

</div>
<div id="MySignature" role="contentinfo">
    <div>
<h3><span style="font: 400 16px Simsun; color: #0000C6"> 微信公众号</span></h3>
<h3><img style="width: 400px; margin-left: 2px;" src="https://images.cnblogs.com/cnblogs_com/bigdata1024/2014130/o_221015130328_%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></h3>
</div>
<div>
<h3><span style="font: 400 16px Simsun; color: #0000C6">作者：<a href="https://www.cnblogs.com/bigdata1024/" target="_blank">chaplinthink</a></span> 
<!-- <a style="color: green" href="https://www.cnblogs.com/bigdata1024/p/16795143.html">[犒赏]</a> -->
</h3>
<h3><span style="font: 400 16px Simsun; color: #0000C6">出处：<a href="https://www.cnblogs.com/bigdata1024/p/18675266" target="_blank">https://www.cnblogs.com/bigdata1024/p/18675266</a></span></h3>
<h3><span style="font: 400 16px Simsun; color: #0000C6">本文以学习、研究和分享为主，如需转载，请联系本人，标明作者和出处，非商业用途!</span></h3>
</div>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7399176935393519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 16:56">2025-01-16 16:55</span>&nbsp;
<a href="https://www.cnblogs.com/bigdata1024">chaplinthink</a>&nbsp;
阅读(<span id="post_view_count">56</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18675266" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18675266);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18675266', targetLink: 'https://www.cnblogs.com/bigdata1024/p/18675266', title: '基于Fluss 的流式湖仓架构' })">举报</a>
</div>
	