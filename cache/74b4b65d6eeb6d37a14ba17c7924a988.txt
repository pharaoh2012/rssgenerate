
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19038051" title="发布于 2025-08-14 17:09">
    <span role="heading" aria-level="2">PO、VO、BO、DTO、DAO、POJO傻傻分不清楚</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>最近有小伙伴问我：O、VO、BO、DTO、DAO、POJO有什么区别？</p>
<p>第一眼看到，你可能也会有点懵。</p>
<p>这些对象的概念很多，确实容易搞混。</p>
<p>今天这篇文章跟大家一起聊聊这6种对象的含义、职责、区别和常见的坑，希望对你会有所帮助。</p>
<h2 id="一6种对象的职责边界">一、6种对象的职责边界</h2>
<p><strong>对象设计的本质是关注点分离</strong>——每个对象只做一件事，且做好它！</p>
<h3 id="11-po">1.1 PO</h3>
<p>它的含义是Persistent Object，即持久化对象。</p>
<ul>
<li><strong>职责</strong>：与数据库表严格1:1映射，<strong>仅承载数据存储结构</strong></li>
<li><strong>特征</strong>：
<ul>
<li>属性与表字段完全对应</li>
<li>无业务逻辑方法（仅有getter/setter）</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<pre><code class="language-java">public class UserPO {  
  private Long id;      // 对应表主键  
  private String name;  // 对应name字段
}  
</code></pre>
<h3 id="12-dao">1.2 DAO</h3>
<p>它的含义是Data Access Object，即数据访问对象。</p>
<ul>
<li><strong>职责</strong>：<strong>封装所有数据库操作</strong>（CRUD），隔离业务与存储细节</li>
<li><strong>特征</strong>：
<ul>
<li>接口方法对应SQL操作</li>
<li>返回PO或PO集合</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<pre><code class="language-java">public interface UserDao {  
    // 根据ID查询PO  
    UserPO findById(Long id);  
    
    // 分页查询  
    List&lt;UserPO&gt; findPage(@Param("offset") int offset, @Param("limit") int limit);  
}  
</code></pre>
<p><strong>底层原理</strong>：DAO模式 = 接口 + 实现类 + PO</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250814170755724-1671378180.png" class="lazyload"></p>
<h3 id="13-bo">1.3 BO</h3>
<p>它的含义是Business Object，即业务对象。</p>
<ul>
<li><strong>职责</strong>：<strong>封装核心业务逻辑</strong>，聚合多个PO完成复杂操作</li>
<li><strong>特征</strong>：
<ul>
<li>包含业务状态机、校验规则</li>
<li>可持有多个PO引用</li>
</ul>
</li>
<li><strong>代码示例</strong>：订单退款BO</li>
</ul>
<pre><code class="language-java">public class OrderBO {  
   // 主订单数据  
   private OrderPO orderPO;  
   // 子订单项  
   private List&lt;OrderItemPO&gt; items; 
   
   // 业务方法：执行退款  
   public RefundResult refund(String reason) {     
   if (!"PAID".equals(orderPO.getStatus())) {  
      throw new IllegalStateException("未支付订单不可退款"); 
   }  // 计算退款金额、调用支付网关等  }  
}  
</code></pre>
<h3 id="14-dto">1.4 DTO</h3>
<p>它的含义是Data Transfer Object，即数据传输对象。</p>
<ul>
<li><strong>职责</strong>：<strong>跨层/跨服务数据传输</strong>，屏蔽敏感字段</li>
<li><strong>特征</strong>：
<ul>
<li>属性集是PO的子集（如排除<code>password</code>字段）</li>
<li>支持序列化（实现<code>Serializable</code>）</li>
</ul>
</li>
<li><strong>代码示例</strong>：用户信息DTO</li>
</ul>
<pre><code class="language-java">public class UserDTO implements Serializable {  
    private Long id;  
    private String name;  
}  
</code></pre>
<h3 id="15-vo">1.5 VO</h3>
<p>它的含义是View Object，即视图对象。</p>
<ul>
<li><strong>职责</strong>：<strong>适配前端展示</strong>，包含渲染逻辑</li>
<li><strong>特征</strong>：
<ul>
<li>属性可包含格式化数据（如日期转<code>yyyy-MM-dd</code>）</li>
<li>聚合多表数据（如订单VO包含用户名字）</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<pre><code class="language-java">public class OrderVO {  
  private String orderNo;  
  private String createTime; // 格式化后的日期   private String userName;   // 关联用户表字段    
  
  //状态码转文字描述  
  public String getStatusText() {  
     return OrderStatus.of(this.status).getDesc();  
  }  
}  
</code></pre>
<h3 id="16-pojo">1.6 POJO</h3>
<p>它的含义是Plain Old Java Object，即普通Java对象。</p>
<ul>
<li><strong>职责</strong>：<strong>基础数据容器</strong>，可扮演PO/DTO/VO角色</li>
<li><strong>特征</strong>：
<ul>
<li>只有属性+getter/setter</li>
<li>无框架依赖（如不继承Spring类）</li>
</ul>
</li>
<li><strong>典型实现</strong>：Lombok简化代码</li>
</ul>
<pre><code class="language-java">// 自动生成getter/setter  
@Data 
public class UserPOJO {  
  private Long id;  
  private String name;  
}  
</code></pre>
<h2 id="二主流的对象流转模型">二、主流的对象流转模型</h2>
<h3 id="场景1">场景1</h3>
<p>传统三层架构（DAO → DTO → VO）。</p>
<p><strong>适用系统</strong>：后台管理系统、工具类应用<br>
<strong>核心流程</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250814170814243-1458026113.png" class="lazyload"></p>
<p><strong>代码示例</strong>：用户查询服务</p>
<pre><code class="language-java">// Service层  
public UserDTO getUserById(Long id) {  
   UserPO userPO = userDao.findById(id); // 从DAO获取PO  
   UserDTO dto = new UserDTO();  
   dto.setId(userPO.getId());  
   dto.setName(userPO.getName()); // 过滤敏感字段  
   return dto; // 返回DTO  
}  

// Controller层  
public UserVO getUser(Long id) {  
   UserDTO dto = userService.getUserById(id);  
   UserVO vo = new UserVO();  
   vo.setUserId(dto.getId());  
   vo.setUserName(dto.getName());  
   vo.setRegisterTime(formatDate(dto.getCreateTime())); // 格式化日期  
   return vo;  
}  
</code></pre>
<p><strong>优点</strong>：简单直接，适合CRUD场景<br>
<strong>缺点</strong>：业务逻辑易泄漏到Service层</p>
<h3 id="场景2">场景2</h3>
<p>DDD架构（PO → DO → DTO → VO）。</p>
<p><strong>适用系统</strong>：电商、金融等复杂业务系统<br>
<strong>核心流程</strong>：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250814170827171-2014308076.png" class="lazyload"></p>
<p><strong>关键角色</strong>：DO（Domain Object）替代BO<br>
<strong>代码示例</strong>：订单支付域</p>
<pre><code class="language-java">// Domain层：订单领域对象  
public class OrderDO {  
   private OrderPO orderPO;  
   private PaymentPO paymentPO;  
   
   // 业务方法：支付校验  
   public void validatePayment() {  
     if (paymentPO.getAmount() &lt; orderPO.getTotalAmount()) {  
        throw new PaymentException("支付金额不足");  
      } 
   }  
}  

// App层：协调领域对象  
public OrderPaymentDTO pay(OrderPayCmd cmd) {  
    OrderDO order = orderRepo.findById(cmd.getOrderId());  
    order.validatePayment(); // 调用领域方法  return OrderConverter.toDTO(order); // 转DTO  
}  
</code></pre>
<p><strong>优点</strong>：业务高内聚，适合复杂规则系统<br>
<strong>缺点</strong>：转换层级多，开发成本高</p>
<h2 id="三高效转换工具">三、高效转换工具</h2>
<p>手动转换对象？效率低且易错！</p>
<p>苏三在这里推荐三大利器。</p>
<h3 id="31--mapstruct编译期代码生成">3.1  MapStruct：编译期代码生成</h3>
<p><strong>原理</strong>：APT注解处理器生成转换代码<br>
<strong>示例</strong>：PO转DTO</p>
<pre><code class="language-java">@Mapper  
public interface UserConverter {  
   UserConverter INSTANCE = Mappers.getMapper(UserConverter.class);  
   
   @Mapping(source = "createTime", target = "registerDate")  
   UserDTO poToDto(UserPO po);  
}  

// 编译后生成UserConverterImpl.java  
public class UserConverterImpl {  
   public UserDTO poToDto(UserPO po) {  
      UserDTO dto = new UserDTO();  
      dto.setRegisterDate(po.getCreateTime()); // 自动赋值！  
      return dto;  
  }  
}  
</code></pre>
<p><strong>优点</strong>：零反射损耗，性能接近手写代码<br>
<strong>开源地址</strong>：<a href="https://github.com/mapstruct/mapstruct" target="_blank" rel="noopener nofollow">https://github.com/mapstruct/mapstruct</a></p>
<h3 id="32-dozer--lombok注解驱动转换">3.2 Dozer + Lombok：注解驱动转换</h3>
<p><strong>组合方案</strong>：</p>
<ul>
<li><strong>Lombok</strong>：自动生成getter/setter</li>
<li><strong>Dozer</strong>：XML/注解配置字段映射</li>
</ul>
<pre><code class="language-java">// Lombok注解
@Data 
public class UserVO {  
   private String userId;  
   private String userName;  
}  

// 转换配置  
&lt;field&gt;  
  &lt;a&gt;userId&lt;/a&gt;  
  &lt;b&gt;id&lt;/b&gt;  
&lt;/field&gt;  
</code></pre>
<p><strong>适用场景</strong>：字段名不一致的复杂转换</p>
<h3 id="33-手动builder模式精细控制">3.3 手动Builder模式：精细控制</h3>
<p><strong>适用场景</strong>：需要动态构造的VO</p>
<pre><code class="language-java">public class OrderVOBuilder {  
   public OrderVO build(OrderDTO dto) {  
     return OrderVO.builder()  
        .orderNo(dto.getOrderNo())  
        .amount(dto.getAmount() + "元") // 动态拼接  
        .statusText(convertStatus(dto.getStatus()))  
        .build();  
    }  
}  
</code></pre>
<h2 id="四避坑指南">四、避坑指南</h2>
<h3 id="坑1po直接返回给前端">坑1：PO直接返回给前端</h3>
<pre><code class="language-java">// 致命错误：暴露数据库敏感字段！  
public UserPO getUser(Long id) {  
  // 返回的PO包含password  
  return userDao.findById(id); 
}  
</code></pre>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用DTO过滤字段</li>
<li>注解屏蔽：<code>@JsonIgnore</code></li>
</ul>
<h3 id="坑2dto中嵌入业务逻辑">坑2：DTO中嵌入业务逻辑</h3>
<pre><code class="language-java">public class OrderDTO {
    // 错误！DTO不应有业务方法  
    public void validate() { 
       if (amount &lt; 0) 
          throw new Exception();  
    }  
}  
</code></pre>
<p><strong>本质错误</strong>：混淆DTO与BO的职责</p>
<h3 id="坑3循环嵌套转换">坑3：循环嵌套转换</h3>
<pre><code class="language-java">// OrderVO中嵌套List&lt;ProductVO&gt;  
public class OrderVO {
   // 嵌套对象  
   private List&lt;ProductVO&gt; products; 
}  

// 转换时触发N+1查询  
orderVO.setProducts(order.getProducts()
       .stream()  
       .map(p -&gt; convertToVO(p)) // 循环查询数据库  
       .collect(toList()));  
</code></pre>
<p><strong>优化方案</strong>：批量查询 + 并行转换</p>
<h3 id="五如何选择对象模型">五、如何选择对象模型？</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202508/2238006-20250814170846460-909071477.png" class="lazyload"></p>
<h2 id="总结">总结</h2>
<p>关于对象的4个核心原则：</p>
<ol>
<li><strong>单一职责</strong>：<br>
PO只存数据，BO只管业务，VO只负责展示——<strong>绝不越界！</strong></li>
<li><strong>安全隔离</strong>：
<ul>
<li>PO永不出DAO层（防数据库泄露）</li>
<li>VO永不出Controller（防前端逻辑污染服务）</li>
</ul>
</li>
<li><strong>性能优先</strong>：
<ul>
<li>大对象转换用<strong>MapStruct</strong>（编译期生成代码）</li>
<li>嵌套集合用<strong>批量查询</strong>（杜绝N+1）</li>
</ul>
</li>
<li><strong>适度设计</strong>：
<ul>
<li>10张表以内的系统：可用POJO一撸到底</li>
<li>百张表以上核心系统：<strong>必须严格分层</strong></li>
</ul>
</li>
</ol>
<p>对象设计没有银弹，<strong>理解业务比套用模式更重要</strong>！</p>
<p>当你在为对象命名纠结时，不妨回到业务的起点问一句：“它此刻的核心职责是什么？”</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-14 17:09">2025-08-14 17:09</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">159</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19038051);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19038051', targetLink: 'https://www.cnblogs.com/12lisu/p/19038051', title: 'PO、VO、BO、DTO、DAO、POJO傻傻分不清楚' })">举报</a>
</div>
        