
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18894419" title="发布于 2025-05-24 18:33">
    <span role="heading" aria-level="2">[Redis] Redis (7) 连接与会话管理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="序文由">序：文由</h1>
<ul>
<li>因今日排查问题，发现微服务因 <code>ERR max number of clients reached</code> (<strong>已达到客户端的最大数量</strong>) redis异常，而导致服务在健康检测时未通过，进而导致高频宕机。</li>
</ul>
<h1 id="概述redis-连接与会话管理">概述：Redis 连接与会话管理</h1>
<h2 id="redis-连接会话的原理">Redis 连接会话的原理</h2>
<ul>
<li>redis通过监听一个TCP端口或socket的方式接收来自客户端的连接，当与客户端<strong>建立连接后</strong>，redis内部会进行如下操作：</li>
</ul>
<blockquote>
<p>（1）客户端socket会被设置为非阻塞模式，因为redis在网络时间处理上采用的是非阻塞多路复用模型；<br>
（2）为这个socket设置TCP_NODELAY属性，禁用Nagle算法；<br>
（3）创建一个可读的文件事件用于监听这个客户端socket的数据发送。</p>
</blockquote>
<h1 id="常用功能与指令">常用功能与指令</h1>
<h2 id="连接操作类">连接操作类</h2>
<h3 id="查看连接总数--info-clients">查看连接总数 : <code>info clients</code></h3>
<pre><code class="language-shell">&gt; info clients
# Clients
connected_clients:95
client_recent_max_input_buffer:2
client_recent_max_output_buffer:0
blocked_clients:0
rx_controlled_clients:0
total_real_rx_controlled:0
total_tx_controlled:0
total_rx_controlled:824214
proxy_header_error:0
</code></pre>
<h3 id="查看连接详情列表--client-list">查看连接详情列表 : <code>client list</code></h3>
<ul>
<li><code>client list</code> : 命令用于返回所有连接到服务器的客户端信息和统计数据。</li>
</ul>
<blockquote>
<p><a href="http://www.redis.cn/commands/client-list.html" target="_blank" rel="noopener nofollow">http://www.redis.cn/commands/client-list.html</a></p>
</blockquote>
<pre><code class="language-shell">client list
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202505/1173617-20250524154221698-385618689.png" alt="" loading="lazy"></p>
<ul>
<li>返回值</li>
</ul>
<blockquote>
<p><code>bulk-string-reply</code>: 一个独特的字符串。具体格式：</p>
<blockquote>
<p>每个已连接客户端对应一行（以 LF 分割）<br>
每行字符串由一系列 属性=值（property=value） 形式的域组成，每个域之间以空格分开。<br>
各字段的含义：:</p>
</blockquote>
</blockquote>
<pre><code class="language-txt">id: 唯一的64位的客户端ID(Redis 2.8.12加入)。
addr: 客户端的地址和端口
fd: 套接字所使用的文件描述符
age: 以秒计算的已连接时长
idle: 以秒计算的空闲时长
flags: 客户端 flag
db: 该客户端正在使用的数据库 ID
sub: 已订阅频道的数量
psub: 已订阅模式的数量
multi: 在事务中被执行的命令数量
qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）
qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）
obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）
oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）
omem: 输出缓冲区和输出列表占用的内存总量
events: 文件描述符事件
cmd: 最近一次执行的命令
</code></pre>
<h3 id="设置当前连接点redis的名称--client-setname">设置当前连接点redis的名称 : <code>CLIENT SETNAME</code></h3>
<pre><code class="language-shell">CLIENT SETNAME
</code></pre>
<h3 id="查看当前连接的名称--client-getname">查看当前连接的名称 : <code>CLIENT GETNAME</code></h3>
<pre><code class="language-shell">CLIENT GETNAME
</code></pre>
<h3 id="杀死指定连接--client-kill-ipport">杀死指定连接 : <code>CLIENT KILL {ip}:{port}</code></h3>
<pre><code>CLIENT KILL {ip}:{port}
</code></pre>
<h2 id="连接配置类">连接配置类</h2>
<h3 id="查看设置连接的默认超时自动断连时间空闲超时时间--config-getset-timeout-second">查看/设置连接的默认超时自动断连时间(空闲超时时间) : <code>config [get|set] timeout [{second}]</code></h3>
<ul>
<li>查看连接的默认超时自动断连时间(空闲超时时间)</li>
</ul>
<blockquote>
<p>默认值 = 0</p>
</blockquote>
<pre><code class="language-shell">&gt; config get timeout
0
</code></pre>
<ul>
<li>设置连接的默认超时自动断连时间(空闲超时时间)</li>
</ul>
<blockquote>
<p>单位：秒钟</p>
</blockquote>
<pre><code class="language-shell">config set timeout 600
</code></pre>
<h3 id="查询设置允许的最大连接数--config-get-maxclients">查询/设置允许的最大连接数 : <code>config get maxclients</code></h3>
<ul>
<li>查询允许的最大连接数</li>
</ul>
<pre><code class="language-shell">config get maxclients 
</code></pre>
<ul>
<li>设置允许的最大连接数</li>
</ul>
<blockquote>
<p>方法1：在2.6之后版本，可以修改最大连接数配置，默认<code>10000</code>，可以在<code>redis.conf</code>配置文件中修改</p>
</blockquote>
<pre><code class="language-shell">...
# maxclients 10000
...
</code></pre>
<blockquote>
<p>方法2: <code>config set maxclients num</code> 可以设置redis允许的最大连接数</p>
</blockquote>
<pre><code class="language-shell">127.0.0.1:6379&gt; CONFIG set maxclients 10
OK
127.0.0.1:6379&gt;
</code></pre>
<blockquote>
<p>方法3：启动<code>redis.service</code>服务时加参数<code>--maxclients 100000</code>来设置最大连接数限制</p>
</blockquote>
<pre><code class="language-shell">redis-server --maxclients 100000 -f /etc/redis.conf
</code></pre>
<h1 id="faq-for-redis-连接与会话管理">FAQ for Redis 连接与会话管理</h1>
<h2 id="q-连接过多乃至报err-max-number-of-clients-reachedredis客户端连接数已达到最大限制">Q: 连接过多，乃至报<code>ERR max number of clients reached</code>（Redis客户端连接数已达到最大限制）？</h2>
<ul>
<li>问题分析</li>
</ul>
<blockquote>
<ul>
<li><code>redis maxclients</code></li>
</ul>
<blockquote>
<p><code>redis maxclients</code> 是redis server的重要配置，它决定了<strong>客户端的最大连接数量</strong>、<strong>最大客户端连接数量</strong>。<br>
由于redis不区分连接是客户端连接、还是内部打开文件、或者和slave连接等。所以，<code>maxclients</code>最小存在32个连接数，如果超过了设置的maxclients，redis会给新的连接发送"<code>max number of clients reached</code>"，并<strong>关闭连接</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>硬编码限制</li>
</ul>
<blockquote>
<p>在Redis 2.4中，可以同时处理的最大客户端数量存在<strong>硬编码限制</strong>。<br>
在Redis 2.6中，此限制是<strong>动态</strong>的：默认情况下，它设置为10000个客户端，除非<code>Redis.conf</code>中的<code>maxclients</code>指令另有说明。</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>原因分析</li>
</ul>
<blockquote>
<p>绝大部分原因：由于客户端很多<strong>空闲连接</strong>都没有被及时释放掉，从而导致<code>connected_clients</code>非常高<br>
其他可能：<code>maxclients</code>设置的太少了<br>
还有可能：软硬件存在限制</p>
</blockquote>
</blockquote>
<ul>
<li>解决方法</li>
</ul>
<blockquote>
<ul>
<li>1 客户端 - 设置超时时间</li>
</ul>
</blockquote>
<pre><code class="language-java">JedisPoolConfig jedisPoolConfig = initPoolConfig();    
jedisPool = new JedisPool(jedisPoolConfig, "*.*.*.*", 6379);  

=========&gt; 修改为:

JedisPoolConfig jedisPoolConfig = initPoolConfig();    
jedisPool = new JedisPool(jedisPoolConfig, "*.*.*.*", 6379, 2*1000); //timeout = 2*1000 = connectionTimeout = soTimeout
</code></pre>
<blockquote>
<p><code>public JedisPool(final GenericObjectPoolConfig poolConfig, final String host, int port, final int connectionTimeout, final int soTimeout, final String password, final int database, final String clientName)</code></p>
</blockquote>
<blockquote>
<ul>
<li>2 客户端 - 回收连接资源</li>
</ul>
</blockquote>
<pre><code class="language-java">	Jedis jedis = JedisUtils.getJedis();
	try {
		//Todo 
    } catch (Exception e){
        throw new RuntimeException(e.getMessage(), e);
        JedisUtils.returnBrokenResource(jedis); //释放连接
    } finally {
        JedisUtils.returnResource(jedis); //释放连接
    }

----

    /**
	 * 回收Jedis对象资源
	 * 
	 * @param jedis
	 */
	public synchronized void returnResource(Jedis jedis) {
		if (jedis != null) {
			jedisPool.returnResource(jedis);
		}
	}
 
	/**
	 * Jedis对象出异常的时候，回收Jedis对象资源
	 * 
	 * @param jedis
	 */
	public synchronized void returnBrokenResource(Jedis jedis) {
		if (jedis != null) {
			jedisPool.returnBrokenResource(jedis);
		}
 
	}
</code></pre>
<blockquote>
<p>在 <code>Jedis 2.6.2</code> 以后，由于重写了<code>jedis.close()</code>,实现<strong>自动关闭</strong>,<code>2.6.3</code>以后正式使用，详见<a href="https://github.com/xetorthio/jedis/pull/912" target="_blank" rel="noopener nofollow">Deprecates JedisPool returnResource and returnBrokenResource</a> ，这样可以代码使用JDK7中新增的<code>try-with-resource</code>语法糖，这样代码会简洁很多如下:</p>
</blockquote>
<pre><code class="language-java">    try (Jedis jedis = JedisUtils.getJedis()) {
        //Todo 
    } catch (Exception e) {
        throw new RuntimeException(e.getMessage(), e);
    }
</code></pre>
<blockquote>
<ul>
<li>3 通过ip排查对应的service服务，查看是否还可以进行优化。</li>
<li>4 查看空闲超时时间: <code>config get timeout</code></li>
</ul>
<blockquote>
<p><code>0</code> : 默认不开启</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>5 设置空闲超时时间 : <code>config set timeout {second}</code></li>
</ul>
<blockquote>
<p>建议为<code>0</code>，尤其是有用分布式锁的情况下、具体看业务场景<br>
如：配置默认空闲超时时间为60s ： <code>config set timeout 60</code></p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>6 <code>config rewrit</code> : 保存</li>
</ul>
<blockquote>
<p>可在 <code>redis.conf</code> 配置文件中添加重启生效。</p>
</blockquote>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/cheyunhua/p/15903942.html" target="_blank">redis 连接工具_redis之timeout（默认建议为0） ， maxclients(重要)  - 博客园</a></li>
<li><a href="https://blog.csdn.net/tengxing007/article/details/88354218" target="_blank" rel="noopener nofollow">解决Redis 连接池报错：ERR max number of clients reached - CSDN</a> 【推荐】</li>
<li><a href="https://blog.csdn.net/zhanshixiang/article/details/129693694" target="_blank" rel="noopener nofollow">生产-已解决-Redis连接数占满 报错 (error) ERR max number of clients reached - CSDN</a> 【推荐】</li>
</ul>
<blockquote>
<p><code> (error) ERR max number of clients reached</code><br>
"我仔细审查了一下前同事写的Redis工具类，发现连接用完，全都没有归还连接"</p>
</blockquote>
<pre><code class="language-java">    public &lt;T&gt; T get(String key, String modulePrefix, Class&lt;T&gt; t) {
        checkJedisPool();
        key = generateKey(key, modulePrefix);
        try (Jedis jedis = jedisPool.getResource()) {
            String valueStr = jedis.get(key);
            return parse(valueStr, t);
        }
    }
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.74156552784375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-24 18:35">2025-05-24 18:33</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18894419);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18894419', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18894419', title: '[Redis] Redis (7) 连接与会话管理' })">举报</a>
</div>
        