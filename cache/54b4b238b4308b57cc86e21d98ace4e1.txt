
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/east7/p/18903584" title="发布于 2025-05-30 09:12">
    <span role="heading" aria-level="2">JAVA JUC干货之线程池实现原理和源码详解（上）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        分享JAVA JUC线程池干货，首先描述线程池的基本概念，然后介绍线程工厂和拒绝策略，其次逐步深入线程池实现原理和线程池状态机，最后结合实战讲解源码。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#综述" rel="noopener nofollow">综述</a></li><li><a href="#七个核心参数" rel="noopener nofollow">七个核心参数</a></li><li><a href="#线程工厂" rel="noopener nofollow">线程工厂</a></li><li><a href="#拒绝策略" rel="noopener nofollow">拒绝策略</a><ul><li><a href="#abortpolicy" rel="noopener nofollow">AbortPolicy</a></li><li><a href="#callerrunspolicy" rel="noopener nofollow">CallerRunsPolicy</a></li><li><a href="#discardoldestpolicy" rel="noopener nofollow">DiscardOldestPolicy</a></li><li><a href="#discardpolicy" rel="noopener nofollow">DiscardPolicy</a></li><li><a href="#自定义拒绝策略" rel="noopener nofollow">自定义拒绝策略</a></li></ul></li><li><a href="#监控线程池运行状态" rel="noopener nofollow">监控线程池运行状态</a></li><li><a href="#关闭和动态调整线程池done" rel="noopener nofollow">关闭和动态调整线程池|done</a></li><li><a href="#线程池的缺点" rel="noopener nofollow">线程池的缺点</a></li><li><a href="#提交任务" rel="noopener nofollow">提交任务</a></li><li><a href="#结束语" rel="noopener nofollow">结束语</a></li><li><a href="#reference" rel="noopener nofollow">Reference</a></li></ul></div><p></p>
<p><strong>摘要</strong>：分享JAVA JUC线程池干货，首先描述线程池的基本概念，然后介绍线程工厂和拒绝策略，其次逐步深入线程池实现原理和线程池状态机，最后结合实战讲解源码。</p>
<p>JUC干货系列目录：</p>
<ol>
<li><a href="https://www.cnblogs.com/east7/p/14417977.html" target="_blank">JAVA JUC干货之线程池状态和状态切换</a></li>
<li><a href="https://www.cnblogs.com/east7/p/18903584" target="_blank">JAVA JUC干货之线程池实现原理和源码详解（上）</a></li>
<li><a href="https://www.cnblogs.com/east7/p/18903603" target="_blank">JAVA JUC干货之线程池实现原理和源码详解（下）</a></li>
</ol>
<h3 id="综述">综述</h3>
<p>  世界唯一不变的事，就是世界一直在变，而且是瞬息万变，唯有不断学习、持续创新和迎接变化，才能立于不败之地。一位金融公司的CTO曾经问我“为什么使用线程池？线程池是怎样执行任务的？”我由于对这个知识点掌握的不透彻，只能临场发挥，导致结局尴尬。因此亡羊补牢，当天到家后就梳理了这个知识点，现在结合Java 21线程池源码落地到文档，分享一些关于线程池的干货，包括但不限于基本概念、执行流程、使用方法、最佳实践和大厂八股文。</p>
<p>  我们下面认识一下什么是线程池。线程池从字面意思上来看就是一个基于池化技术管理同一组工作线程的池子，基本概念如下：是一种用于管理线程生命周期和任务执行的工具，它通过复用已有的工作线程，避免频繁创建和销毁工作线程的开销，从而显著提高应用程序的响应速度和吞吐量，提升资源利用率。通常，我们会使用 java.util.concurrent.ThreadPoolExecutor 或者 Spring 提供的 ThreadPoolExecutor 来创建和管理线程池。</p>
<p>  Java在使用线程执行程序时，需要调用操作系统内核的API创建一个内核线程，操作系统要为线程分配一系列的系统资源；当该Java线程被终止时，对应的内核线程也会被回收。因此，频繁的创建和销毁线程需要消耗大量资源。此外，由于CPU核数有限，大量的线程上下文切换会增加系统的性能开销，无限制地创建线程还可能导致内存溢出。为此，Java在JDK1.5版本中引入了线程池。</p>
<p>  在项目开发过程中为什么使用线程池？我们先看看的ThreadPoolExecutor类中英文注释是怎么描述的：</p>
<pre><code class="language-java">Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, 
due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, 
including threads, consumed when executing a collection of tasks. Each {@code ThreadPoolExecutor} also maintains some basic statistics, 
such as the number of completed tasks.
</code></pre>
<p>  中文意思大致就是线程池解决了两个不同的问题：在执行大量异步任务时，它们一般通过复用线程降低每个任务的调用开销来提高性能，同时线程池还提供了一种限制和管理执行任务时所消耗资源（包括线程）的方法。每个 {@code ThreadPoolExecutor} 还会维护一些基本的统计信息，例如已完成的任务数量。简而言之，线程池能够对线程进行统一分配、调优和监控:</p>
<ul>
<li>通过线程复用机制降低资源开销。线程池维护了一个线程集合，尽可能复用线程完成不同的任务，避免了反反复复地创建和销毁线程带来的系统资源开销。</li>
<li>更有效的管理系统资源。使用线程池统一管理和监控系统资源，做到根据系统承载能力限制同时运行的线程数量，防止系统因创建过多线程而耗尽资源。还支持动态调整核心线程数。</li>
<li>提高响应速度。由于线程被提前预热，当有任务到达时立即被执行，因此显著减少了创建线程这段时间的开销，从而提高了系统的响应速度。据统计，创建一个线程大约<strong>耗时90微秒并占用1M内存</strong>。</li>
</ul>
<p>  鉴于以上线程池优势，合理使用线程池可以帮助我们构建更加高效、稳定和易于维护的多线程应用程序。在业务系统开发过程中，线程池的两个常见应用场景分别是快速响应用户请求和高效处理批量任务。本文将全方位深入探讨 Java 线程池，帮助读者掌握线程池使用技巧和精通其原理。线程池源码参考Java 21，具体版本是“21.0.6”。</p>
<h3 id="七个核心参数">七个核心参数</h3>
<p>  什么是任务执行器？它是实际执行任务的组件，包括执行任务的核心接口类 Executor和继承了 Executor 的 ExecutorService 接口。Executor 框架有几个关键类实现了 ExecutorService 接口：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor、ForkJoinPool。Executor定义了一个简单的 execute(Runnable command) 方法用于异步执行任务；而ExecutorService 接口继承自 Executor，添加了更丰富的任务提交和生命周期管理轮子，如 submit(Runnable task)、submit(Callable task) 、isTerminated()、shutdown() 等。</p>
<p>  <a href="https://www.cnblogs.com/east7/p/18692165" target="_blank">楼兰胡杨</a>在分析JUC线程池Executor框架体系时发现线程池的核心实现类是ThreadPoolExecutor，它是 Executor 框架中最重要的任务执行器实现，实现了 ExecutorService 接口。提供了一个可配置的线程池，用于执行异步任务。</p>
<p>  正所谓“先穿袜子后穿鞋，先当孙子后当爷”，如果要深入理解Java并发编程中的线程池，那么必须深入理解这个类的构造函数。我们来看一下ThreadPoolExecutor类中四个构造函数的源码：</p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue&lt;Runnable&gt; workQueue,
                      ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);
}
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);
}
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
    // 设置线程容器名称
    String name = Objects.toIdentityString(this);
    // 创建线程容器，这就是线程池本尊，线程池的说法也是因为这个线程容器
    this.container = SharedThreadContainer.create(name);
}
</code></pre>
<p>  SharedThreadContainer 是从 JDK 21 开始引入到源码中的类，目的是支持进一步优化虚拟线程，用于管理共享线程容器。从源码得知，ThreadPoolExecutor类提供了四个构造函数，事实上，前面三个构造器都是由第四个构造器衍生而来。下面基于入参最全的第四个构造函数解释线程池中的七大核心参数。</p>
<table>
<thead>
<tr>
<th>核心参数</th>
<th>业务含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>int corePoolSize</td>
<td>核心线程数</td>
</tr>
<tr>
<td>int maximumPoolSize</td>
<td>允许创建的最大线程数</td>
</tr>
<tr>
<td>long keepAliveTime</td>
<td>空闲时间，即空闲线程在终止之前等待新任务的最长时间</td>
</tr>
<tr>
<td>TimeUnit unit</td>
<td>keepAliveTime的时间单位</td>
</tr>
<tr>
<td>BlockingQueue workQueue</td>
<td>任务队列</td>
</tr>
<tr>
<td>ThreadFactory threadFactory</td>
<td>线程工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler handler</td>
<td>拒绝策略</td>
</tr>
</tbody>
</table>
<p>  下面对上述七大核心参数逐一详细介绍。</p>
<p>  <strong>corePoolSize</strong>：线程池中核心线程（常驻线程）的个数。</p>
<p>  线程池被创建后，默认情况下其中并没有任何线程，而是等待有任务到来才创建线程去执行当前任务。如果调用了 prestartAllCoreThreads() 或者 prestartCoreThread()方法，那么可以预创建线程，即在没有任务到来之前就创建corePoolSize个或者一个线程。</p>
<p>  关于corePoolSize的值，如果设置的比较小，则会频繁的创建和销毁线程；如果设置的比较大，则浪费系统资源，实际工作中需要根据业务场景调整。如果设置corePoolSize为 0，则表示在没有任务的时候，销毁线程池。</p>
<p>  <strong>maximumPoolSize</strong>：线程池最大线程数，表示在线程池中最多允许创建多少个线程。它表示当<strong>核心线程已满且任务队列也满时</strong>，线程池可以创建线程的最大个数。通常情况下，无界阻塞队列可以视为无底洞，无论放入多少任务都填不满，故maximumPoolSize对于使用了无界队列的线程池而言就是花瓶，中看不中用。</p>
<p>  <strong>keepAliveTime</strong>：线程的空闲时间或者存活时间，即当线程游手好闲没有任务执行时，继续存活的时间。</p>
<p>  线程池的核心线程可以被回收吗？ThreadPoolExecutor默认不回收核心线程，即 keepAliveTime 对它不起作用。但是提供了allowCoreThreadTimeOut(boolean value)方法，当传的参数为true时，可以在无事可做时间达到线程存活时间后，回收核心线程，直到线程池中的线程数为0。</p>
<p>  <strong>unit</strong>：参数keepAliveTime的时间单位，默认值为TimeUnit.MILLISECONDS，对应TimeUnit类中的7种静态属性：</p>
<pre><code class="language-java">TimeUnit.DAYS; //天 
TimeUnit.HOURS; //小时 
TimeUnit.MINUTES; //分钟
TimeUnit.SECONDS; //秒 
TimeUnit.MILLISECONDS; //毫秒，默认值
TimeUnit.MICROSECONDS; //微妙
TimeUnit.NANOSECONDS; //纳秒
</code></pre>
<p>  <strong>workQueue</strong>：任务队列，采用阻塞队列临时存储等待执行的任务，会对线程池的运行过程产生重大影响。</p>
<p>  当核心线程全部繁忙时，新提交的任务将存放在任务队列中，等待被空闲线程执行。在ThreadPoolExecutor线程池的API文档中，一共推荐了三种等待队列，它们分别是ArrayBlockingQueue、synchronousQueue和默认的LinkedBlockingQueue等。</p>
<p>  <strong>threadFactory</strong>：线程工厂，主要用来创建线程。默认线程工厂是DefaultThreadFactory。</p>
<p>  <strong>handler</strong>：饱和策略，又称拒绝策略，默认值为AbortPolicy。</p>
<h3 id="线程工厂">线程工厂</h3>
<p>  <strong>线程工厂有哪些作用？</strong> 负责生产线程去执行任务，通过线程工厂可以设置线程池中线程的属性，包括名称、优先级以及daemon类型等内容。同一个线程工厂创建的线程会归属于同一个线程组，拥有一样的优先级，而且都不是守护线程。通过自定义的线程工厂可以给每个新建的线程设置一个具有业务含义、易于识别的线程名。</p>
<p>  <strong>线程优先级的作用是什么？</strong> 线程优先级用整数表示，取值范围在 1-10 之间，默认优先级为 5。优先级表示当前线程被调度的权重，也就是说线程的优先级越高，被调度执行的可能性就越大。它会给线程调度器一个择优执行线程的建议，至于是不是优先级越高的越先执行存在不确定性。它这样设计的目的就是为了防止线程饿死。</p>
<p>  <strong>例1</strong> 通过引入<strong>com.google.guava</strong>包创建线程工厂。</p>
<pre><code class="language-java">import com.google.common.util.concurrent.ThreadFactoryBuilder;
// %d 表示从0开始增长的自然数
ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();
</code></pre>
<p>  <strong>例2</strong> 通过Java原汁原味的JUC包ThreadFactory创建线程工厂。</p>
<pre><code class="language-java">// 自定义线程工厂
ThreadFactory jucFactory = new ThreadFactory() {
    private final AtomicInteger mThreadNum = new AtomicInteger(1);
    @Override
    public Thread newThread(Runnable r) {
        // 为线程池创建线程
        Thread thread = new Thread(r);
        // 设置线程名称
        thread.setName("Wiener-"  + mThreadNum.getAndIncrement());
        // 设置线程优先级
        thread.setPriority(Thread.MAX_PRIORITY);
        // 设置线程类型 (前台/后台线程)
        thread.setDaemon(false);
        return thread;
    }
};
</code></pre>
<h3 id="拒绝策略">拒绝策略</h3>
<p>  假设线程数达到最大线程数maximumPoolSize且任务队列已满，如果继续提交新任务，那么线程池必须采取一种拒绝策略处理该任务，在ThreadPoolExecutor中预定义了4种拒绝策略，下面结合源码介绍。</p>
<h4 id="abortpolicy">AbortPolicy</h4>
<p>  ThreadPoolExecutor.AbortPolicy会拒绝执行任务并直接抛出RejectedExecutionException异常，是线程池的<strong>默认拒绝策略</strong>。源码如下：</p>
<pre><code class="language-java">    /**
     * A handler for rejected tasks that throws a
     * {@link RejectedExecutionException}.
     *
     * This is the default handler for {@link ThreadPoolExecutor} and
     * {@link ScheduledThreadPoolExecutor}.
     */
    public static class AbortPolicy implements RejectedExecutionHandler {
        /**
         * Creates an {@code AbortPolicy}.
         */
        public AbortPolicy() { }

        /**
         * Always throws RejectedExecutionException.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         * @throws RejectedExecutionException always
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            // 直接抛出RejectedExecutionException
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }
    }
</code></pre>
<h4 id="callerrunspolicy">CallerRunsPolicy</h4>
<p>  <strong>ThreadPoolExecutor.CallerRunsPolicy</strong> 由调用者所在的线程来执行新任务，而不是线程池中的线程执行。如果调用者线程已关闭，则抛弃任务。这种机制间接地对任务生产速率进行限流，有助于防止系统过载，同时确保没有任务被粗暴地丢弃。</p>
<pre><code class="language-java">    /**
     * A handler for rejected tasks that runs the rejected task
     * directly in the calling thread of the {@code execute} method,
     * unless the executor has been shut down, in which case the task
     * is discarded.
     */
    public static class CallerRunsPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code CallerRunsPolicy}.
         */
        public CallerRunsPolicy() { }

        /**
         * Executes task r in the caller's thread, unless the executor
         * has been shut down, in which case the task is discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run(); // 直接由调用者线程执行任务【r】，而不是线程池中的线程执行
            }
        }
    }
</code></pre>
<h4 id="discardoldestpolicy">DiscardOldestPolicy</h4>
<p>  ThreadPoolExecutor.DiscardOldestPolicy丢弃阻塞队列中最靠前的任务，然后尝试执行新任务。</p>
<p>  ThreadPoolExecutor.DiscardOldestPolicy先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致最高优先级的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h4 id="discardpolicy">DiscardPolicy</h4>
<p>  ThreadPoolExecutor.DiscardPolicy直接丢弃任务，但是不抛出异常。源码如下：</p>
<pre><code class="language-java">    /**
     * A handler for rejected tasks that silently discards the
     * rejected task.
     */
    public static class DiscardPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code DiscardPolicy}.
         */
        public DiscardPolicy() { }

        /**
         * Does nothing, which has the effect of discarding task r.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        }
    }
</code></pre>
<h4 id="自定义拒绝策略">自定义拒绝策略</h4>
<p>  我们也可以根据业务场景实现RejectedExecutionHandler中函数rejectedExecution，创建我们自己的饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<p>  下面是一个简单的例子，展示如何实现一个自定义的拒绝策略。这个策略会在任务被拒绝时打印一条消息，并记录被拒绝的任务信息,同时支持把此任务持久化到Redis。</p>
<pre><code class="language-java">public class RejectionImpl implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 这里写我们自定义的拒绝策略
        System.out.println("被拒绝任务是 " + r.toString());
        System.out.println("把此任务持久化到Redis");
    }
}
</code></pre>
<p>  在创建线程池的时候，把 <strong>new RejectionImpl()</strong> 传入即可，下文会给出实战案例。自定义拒绝策略通常可以做两件事：</p>
<ul>
<li>记录日志，以便追溯问题。</li>
<li>通知告警，摇相关人员解决问题。</li>
</ul>
<p>  <strong>面试官</strong>：你在实际工作中/项目中，使用的是哪一种拒绝策略？</p>
<p>  <strong>参考答案</strong>：如果不知道怎么回答，建议回答自定义拒绝策略，因为它比较灵活，可以设置想设置的逻辑，我在里面呢，首先可以把错误记录下来，其次可以给任务队列发一个邮件，或者发一个 MQ（消息不丢失）。</p>
<p>  <strong>面试官</strong>：如果不允许丢弃任务，应该选择哪种拒绝策略？</p>
<p>  <strong>参考答案</strong>：如果不担心阻塞主线程，可以选择CallerRunsPolicy。更丝滑的方案是基于任务持久化自定义拒绝策略，持久化方案包括但不限于：</p>
<ul>
<li>把任务存储到Redis中。</li>
<li>把任务存储到 MySQL 数据库中。</li>
<li>把任务提交到消息队列中。</li>
</ul>
<p>  这里以方案一为例，简单介绍一下实现逻辑：</p>
<p>  <strong>步骤一</strong> 使用前面刚刚自定义的拒绝策略RejectionImpl，将线程池需要拒绝处理的任务持久化到Redis中。</p>
<p>  <strong>步骤二</strong> 扩展LinkedBlockingQueue实现一个自定义阻塞队列。重写取任务的逻辑take()或者poll()方法，优先从Redis中读取最早存储的任务，Redis中无任务时再从线程池阻塞队列中取任务。</p>
<pre><code class="language-java">import java.util.concurrent.LinkedBlockingQueue;

/**
 * @Author Wiener
 * @Date 2025-04-17
 * @Description: 自定义阻塞队列
 */
public class CustomBlockingQueue&lt;E&gt; extends LinkedBlockingQueue&lt;E&gt; {

    @Override
    public E take() throws InterruptedException {
        E x;
        if (redis中有任务？) {
            // 从Redis读取最早放入的任务
        } else {
            // 从阻塞队列拿任务
            x = super.take();
        }
        // 返回拿到的任务
        return x;
    }
}
</code></pre>
<h3 id="监控线程池运行状态">监控线程池运行状态</h3>
<p>  可以使用ThreadPoolExecutor以下方法实时监控线程池运行状态：</p>
<p><strong>getTaskCount()</strong> Returns the approximate total number of tasks that have ever been scheduled for execution.</p>
<p><strong>getCompletedTaskCount()</strong> Returns the approximate total number of tasks that have completed execution. 返回结果少于getTaskCount()。</p>
<p><strong>getLargestPoolSize()</strong> Returns the largest number of threads that have ever simultaneously been in the pool. 返回结果小于等于maximumPoolSize</p>
<p><strong>getPoolSize()</strong> Returns the current number of threads in the pool.</p>
<p><strong>getActiveCount()</strong> Returns the approximate number of threads that are actively executing tasks.#</p>
<h3 id="关闭和动态调整线程池done">关闭和动态调整线程池|done</h3>
<p>  在应用程序结束时，要确保线程池能够被优雅地关闭。ThreadPoolExecutor提供了两个关闭线程池的轮子：</p>
<p>  <strong>shutdown()：</strong> 等所有阻塞队列中的任务都执行完后才关闭线程池，但再也不会接收新的任务。</p>
<p>  <strong>shutdownNow()：</strong> 立即尝试打断正在执行的任务，并且清空阻塞队列，返回尚未执行的任务。</p>
<p>  它们的原理都是遍历线程池的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法被停止。</p>
<p>  <strong>二者区别</strong>：shutdown函数将平缓的执行关闭过程，拒绝新提交的任务，完成所有运行中的任务，同时等待任务队列中的任务执行完成。shutdownNow方法将粗暴的执行关闭过程，它将尝试取消所有运行中的任务，并且无脑式地清空任务队列。</p>
<p>  只要调用了这两个关闭方法中的任意一个,isShutdown函数就会返回true，当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminated方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<p>  ThreadPoolExecutor提供了动态调整线程池容量大小的方法：</p>
<ul>
<li><strong>setCorePoolSize</strong> 设置核心线程池大小。</li>
<li><strong>setMaximumPoolSize</strong> 动态调整线程池最大线程数maximumPoolSize。</li>
</ul>
<p>  当从小到大调整上述两个参数时，ThreadPoolExecutor实时调整线程池配置，可能导致立即创建新的线程来执行任务。</p>
<h3 id="线程池的缺点">线程池的缺点</h3>
<p>  Java线程池虽然有很多优点，如在综述中提到的高效管理系统资源、减少资源消耗和提高响应速度等，但也存在一些缺点和需要格外留意的地方：</p>
<p><strong>复杂的错误处理</strong>：在线程池中运行的任务如果抛出未捕获异常，可能会导致线程终止，进而影响整个线程池的工作效率。</p>
<p><strong>资源耗尽</strong>：如果线程池配置得过小，当有大量并发请求时，可能导致请求排队时间过长甚至拒绝服务；相反，若线程池过大，则会消耗大量系统资源（如内存），还可能引起频繁的垃圾回收（GC）。</p>
<p><strong>线程饥饿</strong>：在某些情况下，比如线程池中的线程都在执行长时间运行的任务，那么新来的短期任务就可能会长时间等待，造成线程饥饿现象。</p>
<p><strong>死锁风险</strong>：如果线程池配置不当或者任务设计不合理，容易引发死锁问题。例如，线程池中的所有线程都在等待另一个任务完成，而这个任务又在等待线程池中的空闲线程，这样就会形成死锁。</p>
<p><strong>任务丢失</strong>：如果线程池的队列满了且设置了拒绝策略为丢弃任务，那么新的任务可能会直接被丢弃。</p>
<p>  为了克服上述缺点，合理地设置线程池参数、选择合适的线程池类型（如CachedThreadPool, SingleThreadExecutor等）以及正确实现任务逻辑是非常关键的。同时，也可以通过监控线程池的状态来动态调整其配置。</p>
<h3 id="提交任务">提交任务</h3>
<p>  既然谈到线程池如何执行任务，就必须先谈谈如何提交任务。我们在线程池中可以使用两种方式提交任务，一种是execute，另一种是submit。这两种方式的<strong>区别</strong>如下：</p>
<center>
    <img style="width: 77%; border-radius: 0.3125em; box-shadow: 0 2px 4px rgba(34, 36, 38, 0.12), 0 2px 10px rgba(34, 36, 38, 0.08)" src="https://img2024.cnblogs.com/blog/1208468/202505/1208468-20250530091613932-1037644820.png">
    <br>
    <div style="color: rgba(153, 153, 153, 1); border-bottom: 1px solid rgba(217, 217, 217, 1); display: inline-block; padding: 2px">两种提交任务的方式</div>
</center>
<ol>
<li>
<p>任务类型</p>
<ul>
<li>execute只支持提交Runnable类型的任务。</li>
<li>submit提交的任务类型既能是Runnable也能是Callable。</li>
</ul>
</li>
<li>
<p>执行结果</p>
<ul>
<li>execute没有返回值，故无法获取执行结果。</li>
<li>submit可以获取执行结果。它返回一个Future类型的对象，通过这个对象可以拿到任务执行结果和任务是否执行成功。如<code>Future&lt;Object&gt; futureResult = executor.submit(task)</code>。</li>
</ul>
</li>
<li>
<p>异常处理</p>
<ul>
<li>execute会直接抛出执行任务时遇到的异常，可以使用try catch来捕获，这一点和普通线程的处理方式完全一致。</li>
<li>submit函数会吃掉异常，但是如果调用Future的get方法，异常将重新抛出。</li>
</ul>
</li>
</ol>
<p>  虽然两者提交任务的入参类型有差异，但是最终处理任务的方法是相同的，都是ThreadPoolExecutor类的函数execute。总之，如果不需要拿到任务执行结果，直接调用execute会提高性能。</p>
<p>  在实际业务场景中，Future和Callable基本是成对出现的，Callable负责封装执行结果，Future负责获取结果。Future可以拿到异步执行任务的结果，不过，调用Future.get方法会导致主线程阻塞，直到Callable任务执行完成。</p>
<h3 id="结束语">结束语</h3>
<p>  至此，已经介绍完线程池基本概念，关于线程池实现原理和源码详解将在下一篇《<a href="https://www.cnblogs.com/east7/p/18903603" target="_blank">JAVA JUC干货之线程池实现原理和源码详解（下）</a>》中展开。预祝各位读者在工作中能够迅速而准确地处理线程池相关需求，就像运斤成风一样。</p>
<p>  在编程这个复杂严峻的环境中，请活得优雅坦然：也许你的钱包空空如也，也许你的工作不够好，也许你正处在困境中，也许你被情所弃。不论什么原因，请你在出门时，一定要把自己打扮地清清爽爽，昂起头，挺起胸，面带微笑，从容自若地面对生活和面对工作。人生就像蒲公英，没事尽量少吹风；只要你自己真正撑起来了一片天地，别人无论如何是压不垮你的，内心的强大才是真正的强大。</p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html#google_vignette" target="_blank" rel="noopener nofollow">JUC线程池: ThreadPoolExecutor详解</a></li>
<li><a href="https://blog.csdn.net/xaiobit_hl/article/details/132281971" target="_blank" rel="noopener nofollow">https://blog.csdn.net/xaiobit_hl/article/details/132281971</a></li>
<li><a href="https://blog.csdn.net/weixin_43918863/article/details/146354499" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_43918863/article/details/146354499</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/2983855645" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/2983855645</a></li>
<li><a href="https://www.cnblogs.com/w08e/p/18410687" target="_blank">https://www.cnblogs.com/w08e/p/18410687</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    
<div><hr></div>
<div class="aTip">  读后有收获，小礼物走一走，请作者喝咖啡。</div>
<div class="aTip">  <img class="tipwechat" src="https://common.cnblogs.com/images/wechat.png">Buy me a coffee. ☕Get red packets.</div>
<div class="zsdiv"><div class="tipRight">
        <img class="wechat" id="wechatTips" src="https://files.cnblogs.com/files/east7/tip7.ico">
        <img class="wechat" id="redPackets" src="https://blog-static.cnblogs.com/files/east7/11.ico">
</div></div>
<div>作者：<a href="https://www.cnblogs.com/east7/" target="_blank">楼兰胡杨</a></div>
<div>链接：<a href="https://www.cnblogs.com/east7/p/18903584" target="_blank">https://www.cnblogs.com/east7/p/18903584</a></div>
<div>本文版权归作者和博客园共有，欢迎转载，但请注明原文链接，并保留此段声明，否则保留追究法律责任的权利。</div>
        

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1982137442534722" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-30 09:36">2025-05-30 09:12</span>&nbsp;
<a href="https://www.cnblogs.com/east7">楼兰胡杨</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18903584);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18903584', targetLink: 'https://www.cnblogs.com/east7/p/18903584', title: 'JAVA JUC干货之线程池实现原理和源码详解（上）' })">举报</a>
</div>
        