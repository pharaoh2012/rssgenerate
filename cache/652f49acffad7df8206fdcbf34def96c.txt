
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18943368" title="发布于 2025-06-23 09:34">
    <span role="heading" aria-level="2">Java集合--从本质出发理解HashMap</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>文章内容较长，放宽心，带着疑问慢慢读，总能找到你想要的答案。</p>
</blockquote>
<h2 id="如何快速定位数据存储在内存地址的位置">如何快速定位数据存储在内存地址的位置？</h2>
<p>先提出一个问题：<strong>如何快速定位数据存储在内存地址的位置？</strong></p>
<p>聪明的你会想到使用<strong>数组</strong>：根据首地址+单个节点存储大小 x 数组下标，便可快速计算出目标的内存地址，从而做到时间复杂度为<code>O(1)</code>的查找速度。但这一切都建立在<strong>物理存储空间连续</strong>的情况。</p>
<p><strong>如果物理存储空间不连续</strong>？如何实现<code>y=f(x)</code>，根据<code>x</code>参数，通过<code>f(x)</code>函数，快速计算出<code>y</code> 目标地址呢？</p>
<p>在HashMap中，x参数就是<code>key</code>，这一切的计算都是围绕<code>key</code>进行展开的，这些计算可以简述为以下三行代码</p>
<pre><code class="language-java">int hashCode = key.hashCode();
int hash = hashCode ^ (hashCode &gt;&gt;&gt; 16);
int index = (arrLen - 1) &amp; hash
</code></pre>
<p><code>arrLen</code>变量为数组长度，你可以把这三行代码理解为<code>f(x)</code>，而参数<code>x=key</code>，计算结果为<code>y=index</code>，计算结果的<code>index</code>便是<strong>映射数组的下标</strong>。这个映射定位函数是<strong>多对一的函数</strong>，不同的key会得到相同的数组下标值。</p>
<p>在 HashMap 中，<code>f(key) = hash(key) &amp; (arrLen - 1)</code> 就是一个<strong>哈希映射数组索引函数</strong>，不同的 key 可能映射到相同的数组索引，被称为<strong>映射冲突</strong>或<strong>桶冲突</strong>，但是常常被称为<strong>哈希冲突</strong>，这称呼经常让人摸不着头脑，因为它的表述并不准确。</p>
<p><strong>哈希冲突和映射冲突的关系</strong></p>
<ul>
<li>
<p>哈希函数<code>hash(key)</code>内部产生相同值 → 叫「<strong>哈希冲突</strong>」</p>
</li>
<li>
<p>不同哈希值映射到同一个桶 → 叫「<strong>索引冲突</strong>」或「<strong>映射冲突</strong>」</p>
</li>
</ul>
<img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622222825925-1882544407.jpg " alt="" width="50%">
<p>🔑 <code>hash(key) &amp; (arrLen - 1)</code> 不会产生哈希值冲突，它是 <strong>哈希值到数组索引的映射</strong>。真正冲突的是：<strong>不同 key 的哈希值，映射到相同数组索引</strong> —— 这才是 HashMap 要解决的冲突点。</p>
<p>即不同的key可能映射到相同的数组下标，这就是为什么 <code>HashMap</code> 需要<strong>链表或红黑树</strong>来存储元素和处理冲突，而数组（桶）仅仅是用于存储<strong>链表头节点地址</strong>或<strong>红黑树的根节点地址</strong>，然后再结合链表或红黑树进行检索。</p>
<p>对于HashMap的学习，其实主要就是学习<code>Key</code>值是如何解决的。</p>
<h2 id="1-前置知识">1. 前置知识</h2>
<p><strong>哈希（Hash）</strong>，本质上就是把任意长度的输入（比如字符串、对象等）通过一个函数，映射成固定长度的“哈希值”或“哈希码”（通常是一个整数）。这个过程就像是给每个输入都贴上一个“标签”，以便快速比较和查找。</p>
<h3 id="11-什么是哈希函数">1.1. 什么是哈希函数？</h3>
<p>一种函数 H，接受任意长度的输入 x，并输出固定长度的整数（通常在 0 到 <code>2^k-1</code>之间）</p>
<ol>
<li>
<p><strong>映射性质</strong></p>
<ul>
<li>
<p>输入空间：可以是无限或非常大的（例如所有可能的字符串）。</p>
</li>
<li>
<p>输出空间：有限且固定（例如 32 位整数，共约 4 294 967 296 种可能）。</p>
</li>
<li>
<p>哈希函数：<code>h: 输入 → 输出</code>，把大空间“压缩”到小空间。</p>
</li>
</ul>
</li>
<li>
<p><strong>理想特性</strong></p>
<ul>
<li><strong>确定性</strong>：同样输入每次产生相同输出；</li>
<li><strong>高效性</strong>：计算速度要快，适合大量数据处理；</li>
<li><strong>均匀分布</strong>：对不同输入应尽量输出均匀分布，减少“碰撞”（不同输入映射到同一哈希值）的概率；</li>
<li><strong>固定长度</strong>：不论输入大小，输出长度相同，便于存储和比较。</li>
</ul>
</li>
</ol>
<h3 id="12-哈希冲突collision">1.2. 哈希冲突（Collision）</h3>
<p>由于输入空间远大于输出空间的原因，不同元素不可避免地“挤”到同一个标签上（鸽笼原理）。</p>
<blockquote>
<p><strong>鸽笼原理</strong>：如果有 n 个鸽子和 m 个鸽笼，且 n &gt; m，那么至少有一个笼子要装下不止一只鸽子。</p>
</blockquote>
<p>哈希冲突就是不同的输入被哈希函数映射到相同的哈希值。如果要想保存下这些冲突数据，必须要解决哈希函数必然带来的问题--哈希冲突。</p>
<p><strong>解决哈希冲突</strong>常见策略</p>
<ul>
<li>
<p>开放寻址：线性探测，二次探测，和双重哈希</p>
</li>
<li>
<p>闭散列：分离链接</p>
</li>
</ul>
<p><code>HashMap</code>解决哈希冲突采用的是<strong>分离链接策略</strong>。</p>
<h3 id="13-在java中怎么计算哈希值">1.3. 在Java中怎么计算哈希值</h3>
<p>在Java中默认所有对象计算哈希值的方法都是<code>identityHashCode(Object x)</code></p>
<p>常见的两种计算哈希值的方法：</p>
<ol>
<li><strong><code>hashCode()</code></strong>
<ul>
<li>这是实例方法，且在 <code>Object</code> 中声明为 <code>native</code>，所有类都继承它。</li>
<li>大多数类都会重写（<code>override</code>）它，以便根据类的内部状态（字段值）计算一个逻辑哈希码，比如 <code>String</code>、<code>List</code>、用户自定义的实体类等。</li>
<li>这个哈希码用于 <code>HashMap</code>、<code>HashSet</code>、<code>Hashtable</code> 等基于散列的集合，它要求：
<ul>
<li>相等的对象（<code>equals</code> 返回 <code>true</code>）必须具有相同的哈希码；</li>
<li>不相等的对象哈希码越分散越好，减少冲突。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>identityHashCode(Object x)</code></strong>
<ul>
<li>这是一个静态方法，不会被任何类覆盖，也不依赖于对象的 <code>equals</code>/<code>hashCode</code> 重写。</li>
<li>返回“原生的”对象身份哈希——也就是 <code>Object</code> 类刚开始提供的那个哈希值。</li>
<li>常用于调试或需要绕过用户重写的 <code>hashCode</code> 实现，以便获得真正基于对象身份（通常是内存地址或 VM 内部标识）的哈希。</li>
</ul>
</li>
</ol>
<p>这两种<strong>计算哈希值的底层算法</strong></p>
<p>在 HotSpot JVM 中， <code>Object.hashCode()</code>（即身份哈希）生成算法默认是基于 <strong>Marsaglia 的 Xor-Shift 伪随机数生成</strong>，并且使用的是<strong>线程本地</strong>的一组 32 位状态变量。哈希算法本质就是<strong>散列算法</strong>，类似于<code>MD5</code>这种散列算法，根据内容生成固定长度的内容，对于相同的内容每次计算结果都是相同的，但是反过来是无法解码的算法。更多详细内容可以学习JVM底层。</p>
<h2 id="2-数据结构概览">2. 数据结构概览</h2>
<p><strong>数组+链表/红黑树</strong><br>
底层维护一个类型为 <code>Node&lt;K,V&gt;[] table</code> 的数组，每个数组元素是链表或红黑树的根节点。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622222904913-85428612.jpg" alt="image" loading="lazy"></p>
<p><strong>源码关键字段</strong></p>
<pre><code class="language-java">transient Node&lt;K,V&gt;[] table;       // 存放节点的数组
transient int size;                // 当前 key-value 对数
int threshold;                     // 扩容阈值 = capacity × loadFactor
final float loadFactor;            // 负载因子（默认 0.75）
transient int modCount;            // 结构性修改次数，用于 fail-fast

static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 节点数组默认初始容量16
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;      // 节点数组最大容量 2的30次方
static final float DEFAULT_LOAD_FACTOR = 0.75f;  // 默认负载因子
static final int TREEIFY_THRESHOLD = 8;         // 树化阈值 8
static final int MIN_TREEIFY_CAPACITY = 64;    // 树化的节点数组最小容量 64
static final int UNTREEIFY_THRESHOLD = 6;     // 退树阈值 6
</code></pre>
<p><strong>初始容量与加载因子</strong>：</p>
<ul>
<li>
<p>默认初始容量：16</p>
</li>
<li>
<p>默认加载因子：0.75</p>
</li>
<li>
<p>当 <code>size &gt; threshold</code> 时，触发扩容并重新分配位置。</p>
</li>
</ul>
<h2 id="3-如果计算key的存放位置">3. 如果计算Key的存放位置？</h2>
<p>哈希值+扰动函数+下标取模 =&gt; <code>(h=key.hashCode())^(h&gt;&gt;&gt;16) &amp; (length-1)</code>;<br>
扰动函数的目的是降低哈希碰撞的概率！！哈希值h的高16位和低16位做异或计算，再与数组下标做与运算。</p>
<ul>
<li>
<p>异或运算：相同为0，不同为1；</p>
</li>
<li>
<p>与运算：不同为0，相同为0或1。</p>
</li>
</ul>
<p>我们拆分开来，一点一点来掌握。</p>
<h3 id="31-定位数组槽位">3.1. 定位数组槽位</h3>
<p><code>HashMap</code> 底层维护一个节点数组 <code>Node&lt;K,V&gt;[] table</code>，长度为 <code>n</code>（总是 2 的幂）。</p>
<pre><code class="language-java">int idx = (table.length - 1) &amp; hash;
</code></pre>
<ul>
<li><code>n - 1</code> 的二进制形式是：例如当 <code>n = 16</code>，<code>n-1 = 0b1111</code>。</li>
<li>与运算 <code>&amp;</code> 相当于取低 <code>log₂n</code> 位，因此新扰动后的哈希 <code>hash</code> 的低位会决定落到哪个桶，比如n=16时，只会取到低位的4位。</li>
</ul>
<p><strong>计算例子如图</strong>：<br>
<img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622222918305-1087710903.jpg" alt="image" loading="lazy"></p>
<p>那么hash值是怎么计算出来的呢？</p>
<h3 id="32-哈希值计算">3.2. 哈希值计算</h3>
<p>通过<strong>HashMap中的hash 函数</strong> 来实现哈希值计算，本质是使用<code>hashCode</code>函数计算，再对结果进行哈希值扰动，又称为<strong>哈希扰动函数</strong>。<br>
对象插入时，首先调用 <code>key.hashCode()</code>，得到一个 32 位的整型哈希值 <code>h</code>。为了减少高位数据丢失，<code>HashMap</code> 会对用户的 <code>key.hashCode()</code> 进一步扰动，将高 16 位与低 16 位异或，增加低位随机性，减少高位差异带来的冲突。</p>
<pre><code class="language-java">static final int hash(Object key) {
   int h;
   return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<ul>
<li><code>h &gt;&gt;&gt; 16</code>：将高 16 位无符号右移到低位。</li>
<li><code>h ^ (h &gt;&gt;&gt; 16)</code>：将高位信息与低位异或，混合到低 16 位，降低不同 <code>hashCode()</code> 但高位相同的对象冲突概率。</li>
<li>为什么右移16位？：因为hash的数据类型为<code>int </code>，长度为32位的数据类型。</li>
</ul>
<p><strong>等价判断</strong> 如果哈希槽中已有节点（hashCode 相同或不同都可能落到同一槽），会遍历链表/树，对每个节点调用 <code>equals</code> 判断真正相等与否，从而保证集合中不出现重复Key。</p>
<h3 id="33-什么情况要重写hashcode和equals方法">3.3. 什么情况要重写hashCode和equals方法</h3>
<p>在 Java 的 <code>HashMap</code> 中，键（key）对象并 <strong>不</strong> 是“必须”重写 <code>hashCode()</code> 和 <code>equals()</code>，但如果你希望基于对象内容而非内存地址来判断键的等价性，就 <strong>一定要</strong> 同时重写这两个方法。下面分几个方面来说明：</p>
<ol>
<li>
<p><strong>默认实现的行为</strong></p>
<p><code>Object</code> 类中默认的 <code>equals()</code> 比较的是对象引用是否相同（<code>==</code>）。</p>
<p>默认的 <code>hashCode()</code> 通常基于对象在内存中的地址（或编译器/虚拟机内部生成的唯一标识）。<br>
因此，如果你不重写这两个方法，<code>HashMap</code> 会把两个内容相同但引用不同的对象当作不同的 key 来存储。</p>
</li>
<li>
<p><strong>正确使用 <code>HashMap</code> 的关键：hashCode/equals 协议</strong><br>
根据 Java 规范，重写 <code>equals()</code> 必须同时重写 <code>hashCode()</code>，以满足以下契约：</p>
<blockquote>
<p>如果两个对象通过 <code>equals()</code> 被认为是相等的，那么这两个对象的 <code>hashCode()</code> 必须相同。<br>
违反这一契约会导致在 <code>HashMap</code>（或其他基于哈希的集合，如 <code>HashSet</code>）中出现查找失败、存储重复等诡异问题。</p>
</blockquote>
</li>
<li>
<p><strong>什么时候可以不重写？</strong></p>
<p>你 <strong>故意</strong> 要基于“身份”（identity）来做 key 比较，也就是只有同一个对象引用才能对应同一个键。键对象本身就是不可变且唯一的，比如你直接使用某些单例对象或枚举类型作为 key。这时，使用默认的 <code>equals</code>/<code>hashCode</code> 也是可行的。</p>
</li>
</ol>
<p><strong>最佳实践--推荐做法</strong></p>
<p><strong>自定义Key值对象</strong>，例如 <code>Person</code>等，需要根据内部字段来判断“逻辑相等”，就<strong>应当同时重写 <code>hashCode()</code> 和 <code>equals()</code></strong>，可以借助 IDE 自动生成（如 IntelliJ IDEA、Eclipse）或使用 Lombok 注解（<code>@EqualsAndHashCode</code>）来生成相应的代码。</p>
<p>并且<strong>Key值对象最好是不可变的</strong>，比如：<code>String</code>类是个<code>final</code>类，内部数组也是被<code>final</code>修饰。</p>
<p><strong>示例</strong>：<code>Person</code>类字段被<code>final</code>修饰，但类不是<code>final</code>，还是会被继承重写，但如果有人在继承后重写了 <code>equals</code>/<code>hashCode</code>，就可能引入「不对称」或「不一致」的比较逻辑，导致在同一个 <code>HashMap</code> 中，<strong>基类实例和子类实例的对比出现异常</strong>。</p>
<pre><code class="language-java">public class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 重写 equals：基于 name 和 age 判断相等
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person other = (Person) o;
        return age == other.age
            &amp;&amp; Objects.equals(name, other.name);
    }

    // 重写 hashCode：确保相等的对象有相同哈希值
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
</code></pre>
<h3 id="34-哈希扰动hash--h--h--16为什么能减少冲突">3.4. 哈希扰动（<code>hash = h ^ (h &gt;&gt;&gt; 16)</code>）为什么能减少冲突</h3>
<ol>
<li>
<p><strong>底层定位数组槽位只用低位</strong></p>
<pre><code class="language-java">index = (table.length – 1) &amp; hash;
</code></pre>
<p>因为 <code>table.length</code> 是 2 的幂，<code>length–1</code> 在二进制下像 <code>0b00…0111</code>，所以算出来的 <code>index</code> 只看 <code>hash</code> 的<strong>低几位</strong>。</p>
</li>
<li>
<p><strong>原始 <code>hashCode()</code> 的低位往往不够随机</strong></p>
<p>比如某些类型（<code>String</code>、自定义对象）算出的 <code>hashCode()</code>，高位变化很丰富，低位却常常相似。直接取低位就会把这批看似不同的对象都落到同几个桶里，冲突多。所以在开发中，常常会重写Object的<code>hashcode</code>方法。</p>
</li>
<li>
<p><strong>扰动函数把高位的信息混到低位</strong></p>
<pre><code class="language-java">static final int hash(Object key) {
int h = key.hashCode();
return h ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p><code>h &gt;&gt;&gt; 16</code>：把高 16 位“搬”到低 16 位，<code>^</code>（异或）：将这两部分交叉叠加。</p>
<p>结果是：原来只在高位有差异的两个 <code>hashCode()</code> 值，经过扰动后，差异也会反映到低位上。<strong>低位更多变化</strong>使得对象更可能被分散到不同桶，<strong>冲突自然就少了</strong>。</p>
</li>
</ol>
<h4 id="看完这个例子就明白了">看完这个例子就明白了</h4>
<p>例子计算过程如图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622222933266-303677833.jpg" alt="image" loading="lazy"></p>
<p>扰动函数结论如下</p>
<ul>
<li>
<p>如果不做扰动，那么只有当数组容量大于&nbsp;<code>2¹⁶ = 65536</code>&nbsp;时，才会用到 hash 值的高 16 位；</p>
</li>
<li>
<p>数组小于65536前做的扩容，可能并不会使得节点分散到不同的数组槽位；</p>
</li>
<li>
<p>不管何种情况，都让高16位和低16位哈希值都参与计算，使得计算结果尽可能分散，从而减少冲突。</p>
</li>
</ul>
<h3 id="34-小结">3.4. 小结</h3>
<p>通过<code>hash(Object key)</code>获取尽可能分散的<strong>哈希值</strong>，避免在哈希值计算层面的<strong>哈希冲突</strong>；再将哈希值通过<code>hash &amp; (n-1)</code> 映射（压缩）到数组范围内。</p>
<h2 id="4-为什么哈希码越分散冲突就越少">4. 为什么“哈希码越分散，冲突就越少”？</h2>
<ol>
<li>
<p><strong>均匀分布减少集中</strong></p>
<p>如果所有哈希值都集中在输出空间的某一小段区间，那这些标签对应的“桶”就会非常拥挤，冲突自然多。理想情况下，每个可能的哈希值被使用的概率都相等，输入均匀落在输出的各个位置上，任何两个不同元素映射到同一位置的概率才是最低的。</p>
</li>
<li>
<p><strong>碰撞概率分析</strong></p>
<p>假设有 N 个不同元素，要放到 M 个桶里（M 即哈希码空间大小），若哈希值均匀分布，那么任意两元素落在同一桶的概率约为 1/M。</p>
<p>总冲突概率与「元素对数」×「单对碰撞概率」成正比，约为<code>N(N−1)/2​×1/M</code></p>
<p>可以看到，当 M 越大／输出值越分散时， 越小，整体冲突概率就越低。</p>
</li>
<li>
<p><strong>对哈希表性能的影响</strong></p>
<p><strong>低冲突</strong>：每个桶的平均链长（或树深）接近 1，查找和插入都是 <code>O(1)</code>。</p>
<p><strong>高冲突</strong>：部分桶链长变长，最坏可能退化到 <code>O(n)</code>，性能急剧下降；Java 8 用树化把过长链表变成红黑树，最坏也能保证 <code>O(log n)</code>，但开销更大。</p>
</li>
</ol>
<p>用开篇时提到的问题：<strong>如何快速定位数据存储在内存地址的位置？</strong></p>
<p>函数<code>y=f(x)</code> ，<code>f(x)</code>为<strong>哈希映射数组索引函数</strong>，一个<code>x(key)</code>对应多个<code>y(数组的索引index)</code>。如果哈希码足够分散，分散到一个<code>x</code>对应一个<code>y</code>的这种理想情况，那么就可以根据函数直接计算出唯一的<code>y</code>，也就是说可以直接计算出目标内存地址，但这是一种接近数组查找速度的理想情况。为了尽可能提高计算目标内存地址的速度，就得让哈希码尽可能的分散。剩下影响哈希表性能的问题，便是哈希冲突问题如何高效解决？</p>
<p>将在下一篇HashMap文章展开，结合HashMap的四次扩容来剖析HashMap对哈希冲突问题的高效解决办法。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622222945309-1475475912.jpg" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250622223004870-1836529430.gif" alt="image" loading="lazy"></p>
<p><a href="https://mp.weixin.qq.com/s/CEpTaNSpCEbf4OYuTEtXbA" target="_blank" rel="noopener nofollow">Java集合--LinkedList源码可视化</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486763&amp;idx=1&amp;sn=214926d8cfaba2cada66106f26918764&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java集合源码--ArrayList的可视化操作过程</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486720&amp;idx=1&amp;sn=739bdfc99dc52128f9d9eb31a70a4c03&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式的两个秘籍</a></p>
<p>查看往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>
<p>原创不易，觉得还不错的，三连支持：点赞、分享、推荐↓</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-23 09:34">2025-06-23 09:34</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18943368);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18943368', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18943368', title: 'Java集合--从本质出发理解HashMap' })">举报</a>
</div>
        