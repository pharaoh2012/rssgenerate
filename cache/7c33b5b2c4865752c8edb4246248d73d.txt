
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pythonista/p/18870129" title="发布于 2025-05-10 21:07">
    <span role="heading" aria-level="2">Python 3.14 新特性盘点，更新了些什么？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Python 3.14.0 稳定版将于 2025 年 10 月正式发布，目前已进入 beta 测试阶段。这意味着在往后的几个月里，3.14 的新功能已冻结，不再合入新功能（除了修复问题和完善文档）。</p>
<p>3.14 正好是圈周率 π 的前几位，所以我们将要迎来的其实是一个“圆满”的版本😂</p>
<p>本文想梳理这个版本中一些值得关注的新特性，让我们先睹为快吧～</p>
<h2 id="重点更新">重点更新</h2>
<h3 id="1-类型提示惰性求值-pep-649">1. 类型提示惰性求值 (PEP 649)</h3>
<p>Python 3.14 对类型提示机制做了根本性改进。从这个版本开始，函数、类和模块上的类型提示不再立即计算，而是先存储起来，等真正需要时才进行求值。</p>
<p>这个特性解决了大型项目中一个老大难问题：大量类型提示导致的启动缓慢。对企业级应用和大型项目来说，这简直就是一个福音！</p>
<p>这个改进带来了几个实实在在的好处：</p>
<ul>
<li>项目启动速度大幅提升，尤其是大型代码仓</li>
<li>引用未定义类型时不再需要加引号，代码更加简洁</li>
<li>新增的 <code>annotationlib</code> 模块提供了灵活的类型提示检查方式</li>
</ul>
<p>下面的示例直观展示了这个特性带来的好处：</p>
<pre><code class="language-python"># Python 3.14 - 不再需要引号，即使类型未定义
&gt;&gt;&gt; from annotationlib import get_annotations, Format
&gt;&gt;&gt; def new_way(arg: Undefined):  # 直接使用未定义类型
...     pass

# Python 3.13 及之前版本需要这样写
&gt;&gt;&gt; def old_way(arg: "Undefined"):  # 必须加引号，否则报错
...     pass

# 可以用不同格式查看类型提示
&gt;&gt;&gt; get_annotations(new_way, format=Format.STRING)  # 字符串形式
{'arg': 'Undefined'}
&gt;&gt;&gt; get_annotations(new_way, format=Format.FORWARDREF)  # 前向引用对象形式
{'arg': ForwardRef('Undefined', owner=&lt;function new_way at 0x...&gt;)}
</code></pre>
<p>这项改进让 Python 的类型系统变得更加好用，尤其是在使用类型检查工具时确实很有帮助。</p>
<h3 id="2-基于尾调用的新解释器">2. 基于尾调用的新解释器</h3>
<p>Python 3.14 的 CPython 引入了新的解释器实现。不同于之前用大块 switch-case 的传统做法，新解释器用小型 C 函数之间的尾调用来处理字节码。</p>
<p>这种新的架构设计体现了 Python 团队对性能持续优化的决心，虽然效果可能没一开始宣传的那么震撼。</p>
<p>关于性能数据，这里有个有趣的小插曲：</p>
<ul>
<li>这个特性最早被官宣时，声称有 9-15% 的性能提升</li>
<li>但后来发现数据受到了 LLVM/Clang 19 编译器一个回归问题的影响</li>
<li>经过更严格的测试，实际数据显示：在标准 pyperformance 测试中，平均提升仅有 3-5%</li>
<li>不过在特定的字节码密集型计算中，性能提升仍然可以达到 30%</li>
</ul>
<p>这项改进的真正价值可能不在当下。从长远来看，这很可能是 Python 解释器架构的一次重要转型，为未来更大幅度的性能提升打下基础。</p>
<p>目前这个解释器只支持 Clang 19 及以上版本编译器，而且只能在 x86-64 和 AArch64 架构上跑。不过官方表示未来 GCC 也会支持。要使用这个功能，需要在编译 Python 时手动指定 <code>--with-tail-call-interp</code> 参数。<a href="https://pythoncat.top/posts/2025-05-08-python-3.14" target="_blank" rel="noopener nofollow">1</a></p>
<h3 id="3-无侵入调试接口-pep-768">3. 无侵入调试接口 (PEP 768)</h3>
<p>Python 3.14 新增的安全外部调试接口是个很给力的新功能，大大改善了 Python 程序的调试体验。以后不用预先在代码中插入任何调试语句，也能连上已经运行中的 Python 进程。</p>
<p>使用起来很简单：</p>
<pre><code class="language-python">python -m pdb -p 1234  # 直接连接到PID为1234的Python进程
</code></pre>
<p>实现这个功能的技术原理很巧妙：</p>
<ol>
<li>CPython 把关键内部结构的偏移量保存在 <code>_Py_DebugOffsets</code> 中，调试工具可以直接访问</li>
<li>在 <code>PyThreadState</code> 中新加了外部调试支持结构，可以注入调试脚本</li>
<li>通过 <code>sys.remote_exec()</code> 功能可以检查和控制运行中的进程</li>
</ol>
<p>这个特性不仅改善了开发者的调试体验，还为专业调试工具（如 pyspy、py-spy 等）提供了标准接口。这些工具以前必须为每个 Python 版本单独维护内存结构偏移量，现在不用这么麻烦了。生产环境下排查问题的难度也大大降低！</p>
<blockquote>
<p>附：<a href="https://www.manjusaka.blog/posts/2025/04/26/3-14-is-one-of-the-best-python-version/" target="_blank" rel="noopener nofollow">Python 3.14 调试特性的深度解读</a></p>
</blockquote>
<h3 id="4-模板字符串-pep-750">4. 模板字符串 (PEP 750)</h3>
<p>Python 3.14 新增了一种特别的字符串写法——模板字符串（t-string）。就像常用的 f-string 前面加 <code>f</code> 一样，这种新字符串前面加 <code>t</code>。</p>
<p>它主要解决了 Web 开发中的安全需求。在用 Django、Flask 这类框架开发网站时，如何安全地处理 HTML 内容和 SQL 语句一直是个老大难问题。这个新的 t-string 语法就是为了解决这个问题，它兼顾了代码的简洁性和内容的安全性。</p>
<p>简单的例子：</p>
<pre><code class="language-python">from string.templatelib import Template

name = "World"
template = t"Hello {name}"  # 返回一个 Template 对象，而不是字符串
</code></pre>
<p>t-string 与 f-string 最大的区别在于：f-string 会直接计算并返回字符串，而 t-string 生成的是 <code>Template</code> 类型的对象。有了这个对象，我们就能对模板内容做各种安全处理，比如 HTML 转义和 SQL 注入防护：</p>
<pre><code class="language-python">from string.templatelib import Template, html

# 有恶意代码
evil = "&lt;script&gt;alert('evil')&lt;/script&gt;"

# 用模板处理，防止 XSS 攻击
template = t"&lt;p&gt;{evil}&lt;/p&gt;"

# 使用 html() 函数转义危险字符
html_safe = html(template) 
assert html_safe == "&lt;p&gt;&amp;lt;script&amp;gt;alert('evil')&amp;lt;/script&amp;gt;&lt;/p&gt;"
</code></pre>
<p>这个新功能会让 Web 开发、日志记录、数据库操作等场景更加安全和方便。</p>
<blockquote>
<p>附：<a href="https://pythoncat.top/posts/2025-04-27-t-string" target="_blank" rel="noopener nofollow">Python 3.14 t-string 的全面解析与使用教程</a></p>
</blockquote>
<h2 id="其它重要更新">其它重要更新</h2>
<h3 id="1-支持-zstandard-压缩格式-pep-784">1. 支持 Zstandard 压缩格式 (PEP 784)</h3>
<p>Python 3.14 标准库新增了 <code>compression.zstd</code> 模块，正式把 Zstandard 压缩格式纳入标准支持。这种由 Meta 公司开发的格式既压得小又压得快，甚至超过很多老牌压缩算法，非常适合处理大数据和网络通信场景。</p>
<p>随之一起更新的还有 <code>tarfile</code>、<code>zipfile</code> 和 <code>shutil</code> 模块，现在都能直接处理 Zstandard 压缩包了。而原有的 <code>lzma</code>、<code>bz2</code> 等压缩模块也被整合到新的 <code>compression</code> 包下，统一了访问方式。</p>
<h3 id="2-用于-c-扩展的-python-配置-api-pep-741">2. 用于 C 扩展的 Python 配置 API (PEP 741)</h3>
<p>Python 3.14 新加了 C 语言的配置 API，写 C 扩展时操作 Python 配置变得简单多了。用这个 API 提供的函数，我们可以很方便地查询或改变 Python 的运行时配置。</p>
<p>比如，以前写 C 扩展必须深入了解 CPython 内部构造，现在只需用几行简单代码就能操作内存分配器、日志设置等：</p>
<pre><code class="language-c">// 看看调试模式是否开启
int debug_enabled = _PyConfig_GetBool(config, "debug");

// 指定模块搜索路径
_PyConfig_SetString(config, "pythonpath", "/custom/path");
</code></pre>
<p><a href="https://pythoncat.top/posts/2025-05-08-python-3.14" target="_blank" rel="noopener nofollow">博客原文</a></p>
<h3 id="3-实验性-jit-编译器-pep-744">3. 实验性 JIT 编译器 (PEP 744)</h3>
<p>Python 3.14 正式在官方 macOS 和 Windows 二进制版本中加入了实验性的即时编译器（JIT）。不推荐用于生产环境，仅供测试和尝鲜。</p>
<p>启用方式简单，只需设置环境变量：</p>
<pre><code class="language-bash"># 设置环境变量开启 JIT
PYTHON_JIT=1 python3.14 your_script.py
</code></pre>
<p>可以通过 <code>sys._jit</code> 模块检查 JIT 状态：</p>
<pre><code class="language-python">import sys

if hasattr(sys, "_jit"):
    print(f"JIT状态: {"启用" if sys._jit.is_enabled() else "未启用"}")
else:
    print("JIT不支持")
</code></pre>
<h3 id="4-repl-语法高亮">4. REPL 语法高亮</h3>
<p>Python 3.14 的交互式环境（REPL）正式支持语法高亮，大大提升了开发体验。这个功能默认开启，除非你设置了 <code>PYTHON_BASIC_REPL</code> 环境变量。</p>
<p>默认主题使用标准的 ANSI 颜色代码，确保兼容性的同时提供了清晰的视觉区分度，另外也支持自定义颜色主题。</p>
<p>这一改进让原生 Python 接近了 IPython 和 Jupyter 等现代工具的用户体验，也表明官方在重视开发者日常使用的小细节。</p>
<h3 id="5-放弃-pgp-签名-pep-761">5. 放弃 PGP 签名 (PEP 761)</h3>
<p>Python 3.14 版本将告别 PGP 签名，改用更现代的签名和验证方式来发布官方软件包。这一改变其实是 Python 跟上了开源软件分发领域的潮流，和当下大多数主流项目的做法一致。</p>
<h3 id="6-finally-块中不能再用跳转语句-pep-765">6. finally 块中不能再用跳转语句 (PEP 765)</h3>
<p>Python 3.14 增加了一项新限制：不能在 <code>finally</code> 块里用 <code>return</code>、<code>break</code> 和 <code>continue</code> 跳出去。这种写法以后会被视为语法错误。</p>
<p>这个限制有很实在的目的，因为 <code>finally</code> 中的跳转语句通常会导致代码难懂、难维护，容易把异常情况给吞掉，造成莫名其妙的问题。</p>
<pre><code class="language-python"># Python 3.13 允许这种危险写法，但异常会被吞
try:
    raise ValueError("重要错误")
except Exception as e:
    print(f"捕获到错误: {e}")
    raise
finally:
    # 这里写 return 会打断异常传递，调用方看不到原始错误
    return "似乎一切正常"

# Python 3.14 中，上述代码将在语法层面被禁止
</code></pre>
<h3 id="7-捕获多个异常时不用加括号了-pep-758">7. 捕获多个异常时不用加括号了 (PEP 758)</h3>
<p>Python 3.14 简化了异常处理的写法。以前想同时捕获多种异常类型必须加括号，而在 3.14 版本中可以直接用逗号分隔：</p>
<pre><code class="language-python">try:
    operation()
except ValueError, TypeError:  # 可以用逗号分隔多个异常类型
    print("处理值错误或类型错误")

# 对异常组也适用同样的语法
try:
    operation()
except* ValueError, TypeError:  # 异常组也可以用逗号分隔
    print("处理值错误或类型错误")
</code></pre>
<p>这种写法不仅更简洁，也将更符合直觉。</p>
<h2 id="不兼容变更">不兼容变更</h2>
<p>Python 3.14 带来了一些重要的不兼容变更，升级时需要特别注意：</p>
<ol>
<li>
<p>除了 macOS 和 Windows 外，其它平台上 <code>multiprocessing</code> 和 <code>ProcessPoolExecutor</code> 的默认启动方式从 <code>fork</code> 改成了 <code>forkserver</code>。这能避免一些多线程的问题，但可能要修改依赖于旧行为的代码。</p>
</li>
<li>
<p>CPython 解释器优化了引用计数机制，去掉了一些不必要的计数更新，所以 <code>sys.getrefcount()</code> 和 <code>Py_REFCNT()</code> 返回的数字可能和以前不一样了。</p>
</li>
<li>
<p>PEP 738 修改了 async/await 关键字的解析规则，一些极端情况下可能造成不兼容。</p>
</li>
<li>
<p><code>distutils</code> 模块在 3.12 中已经被强烈警告，3.14 版本会完全移除。如果还在使用，应该迁移到 <code>setuptools</code> 或 <code>sysconfig</code>。</p>
</li>
<li>
<p><code>imp</code> 模块所有标记为弃用的函数已经删除，应改用 <code>importlib</code>。</p>
</li>
<li>
<p><code>asyncio</code> 模块中的一些废弃函数如 <code>@coroutine</code> 装饰器已被移除，应该用 <code>async/await</code> 语法替代。</p>
</li>
<li>
<p>XML 模块默认开启了更严格的安全限制，可能会导致原有较宽松的解析器设置失效。</p>
</li>
<li>
<p>SSL/TLS 模块默认禁用了某些过时的加密算法和协议版本，对于需要与旧系统通信的应用可能要额外配置。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>这个带着圆周率数字的 Python 3.14 版本，给我们带来了全方位的升级。</p>
<p>在性能上，类型提示的惰性求值和全新的尾调用解释器大幅减轻了启动负担，而实验性的 JIT 编译器则在特定场景下展现了可观的速度提升。</p>
<p>在开发体验上，无侵入调试接口的加入和 REPL 的语法高亮功能使日常编程变得更加舒心逸意。</p>
<p>模板字符串和 Zstandard 压缩的加入则扩展了 Python 在 Web 开发和数据处理领域的应用空间。</p>
<p>除了功能增强，3.14 也带来了一系列语法优化，如异常捕获时不再需要括号以及 finally 块中禁用跳转语句等。这些简化和限制看似微小，却能减少代码中的隐藏 bug。同时，这个版本还作出了一些前瞻性的决定，如放弃 PGP 签名和改用 forkserver 作为默认启动方式。</p>
<p>总的来说，这个圆周率版本在性能、开发体验和语言功能上都有实质性的改进。不管是类型提示、解释器改进还是模板字符串，都展示了 Python 在各个领域的持续发力和进步。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://docs.python.org/3.14/whatsnew/3.14.html" target="_blank" rel="noopener nofollow">What's new in Python 3.14</a></p>
<p><a href="https://pythoncat.top/posts/2025-05-08-python-3.14" target="_blank" rel="noopener nofollow">Python 3.14 新特性解析</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2161667477210648" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 21:08">2025-05-10 21:07</span>&nbsp;
<a href="https://www.cnblogs.com/pythonista">豌豆花下猫</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18870129);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18870129', targetLink: 'https://www.cnblogs.com/pythonista/p/18870129', title: 'Python 3.14 新特性盘点，更新了些什么？' })">举报</a>
</div>
        