
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hugogoos/p/18699934" title="发布于 2025-02-05 18:00">
    <span role="heading" aria-level="2">并发编程 - 线程同步（三）之原子操作Interlocked简介</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        原子操作是不可分割的操作单元，Interlocked提供硬件级别原子操作，比传统锁机制效率高。Interlocked支持多种原子操作，如增减、替换、位操作等，确保多线程安全。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上一章我们了解了3种处理多线程中共享资源安全的方法，今天我们将更近一步，学习一种针对简单线程同步场景的解决方案——Interlocked。</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250205175054210-34364760.jpg" alt="" loading="lazy"></p>
<p>在此之前我们先学习一个概念——原子操作。</p>
<h1 id="01原子操作"><em><strong>01</strong></em>、原子操作</h1>
<p>原子操作，其概念源于化学领域，原子是构成化学元素的普通物质的最小单位；原子也是化学变化中最小的粒子及元素化学性质的最小单位。</p>
<p>借鉴到编程语言中原子操作指：不可分割的操作单元，是指一类不可中断的操作，它在执行时要么全部执行，要么全部不执行，不会被其他操作打断，而执行结果要么全部成功，要不全部失败，没有其他状态。</p>
<p>我们再回忆一下我们学习线程同步的目的——<strong>确保多个线程在访问共享资源时能够按顺序、安全地进行操作</strong>，从而避免并发执行带来的<strong>数据竞争</strong>和<strong>不一致的状态。</strong></p>
<p>可以说原子操作天然的解决了多线程共享资源安全问题。</p>
<p>在C#语言中，Interlocked类提供了一系列可以进行原子操作的工具。</p>
<h1 id="02interlocked实现原理"><em><strong>02</strong></em>、Interlocked实现原理</h1>
<p>Interlocked的原子操作是基于CPU本身实现，是硬件级别的原子指令封装，并且它不需要显式的线程阻塞，因此比传统的锁机制（如互斥锁、信号量等）效率更高，尤其是在高并发的场景下。</p>
<p>线程阻塞是指操作系统把当前线程从运行状态变更为阻塞状态，并且操作系统会把当前线程占用的CPU时间片分配给其他线程，使当前线程尽可能少的占用CPU时间。在分配CPU时间片时会涉及上下文切换等操作。</p>
<p>因此Interlocked的非阻塞特性，严格意义上来说并不是锁，但是效率却比锁高得多。</p>
<p>另外如果一个方法在CPU层面上被设计为对立不可分割的指令，那么它本质上就是原子的，严格的原子性可以阻止任何抢占的可能。因此在32位CPU中，一个操作数的大小为32位，因此可以提供32位即4个字节大小及以内的数据类型（如int，float）进行读写的原子操作。同理64位CPU，则可以提供64位级8个字节大小及以内的数据类型（如long，double）进行读写的原子操作。</p>
<p>其实在上一章也举个一个例子，在32位CPU环境下操作long类型，多线程情况下会出现线程不完全问题，因为对于32位CPU，操作一次long类型数据至少需要两个原子指令，因此就会出现线程安全问题。</p>
<h1 id="03interlocked常用方法"><em><strong>03</strong></em>、Interlocked常用方法</h1>
<p>Interlocked方法从.NET Framework 1.1到目前最新的.NET 9也经历了长足的发展和完善。可以总结为：支持的操作类型在增加，操作能力也再增加，由早期的简单递增、递减、替换操作到现在的复杂位操作，内存屏障操作等。</p>
<p>下面我们先整体了解一下Interlocked有那些方法。</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250205175103373-1145211926.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><strong>Read：</strong> 原子的读取64位值；</p>
</li>
<li>
<p><strong>Increment：</strong> 原子的递增指定的变量，并返回递增后的新值；</p>
</li>
<li>
<p><strong>Decrement：</strong> 原子的递减指定的变量，并返回递减后的新值；</p>
</li>
<li>
<p><strong>Add：</strong> 原子的对两个变量求和，将第一个变量替换为两者和，并返回操作后第一个变量的新值；</p>
</li>
<li>
<p><strong>Exchange：</strong> 原子的交换两个变量，并返回第一个变量的原始值；</p>
</li>
<li>
<p><strong>Exchange<t>：</t></strong> Exchange方法的泛型版本；</p>
</li>
<li>
<p><strong>CompareExchange：</strong> 原子的比较第一个变量和第三个变量是否相等，如果相等，则将第一个变量替换为第二个变量值，并返回第一个变量的原始值；</p>
</li>
<li>
<p><strong>CompareExchange<t>：</t></strong> CompareExchange方法的泛型版本；</p>
</li>
<li>
<p><strong>And：</strong> 原子的对两个变量进行按位与操作，将第一个变量替换为操作结果，并返回第一个变量的原始值；</p>
</li>
<li>
<p><strong>Or：</strong> 原子的对两个变量进行按位或操作，将第一个变量替换为操作结果，并返回第一个变量的原始值；</p>
</li>
<li>
<p><strong>MemoryBarrier：</strong> 强制执行内存屏障，作用范围当前线程，无返回值；</p>
</li>
<li>
<p><strong>MemoryBarrierProcessWide：</strong> 提供进程范围的内存屏障，确保任何 CPU 的读取和写入无法跨屏障移动；</p>
</li>
</ul>
<p>后面我们将详细讲解每个方法的如何使用。</p>
<p><em><strong>注</strong></em>：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。<a href="https://gitee.com/hugogoos/Planner" target="_blank" rel="noopener nofollow">https://gitee.com/hugogoos/Planner</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.34705658228703706" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-05 18:00">2025-02-05 18:00</span>&nbsp;
<a href="https://www.cnblogs.com/hugogoos">IT规划师</a>&nbsp;
阅读(<span id="post_view_count">29</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18699934" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18699934);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18699934', targetLink: 'https://www.cnblogs.com/hugogoos/p/18699934', title: '并发编程 - 线程同步（三）之原子操作Interlocked简介' })">举报</a>
</div>
        