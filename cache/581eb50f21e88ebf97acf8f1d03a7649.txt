
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lindexi/p/18843888" title="发布于 2025-04-24 07:13">
    <span role="heading" aria-level="2">WPF 从 WriteableBitmap 里获取到渲染线程使用的 IWICBitmap 对象</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在 WPF 框架底层里面，对 WriteableBitmap 的实现是有双份内存，具体实现放在 CSwDoubleBufferedBitmap 里面。表层的内存是一个数组，里层内存是 IWICBitmap 对象，渲染时将使用 IWICBitmap 对象加入到渲染管线
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">



<p>本文将告诉大家如何在 WPF 里面，从 WriteableBitmap 里获取到渲染线程使用的 IWICBitmap 对象。本文提供的方法仅仅只能用于辅助大家了解 WPF 的机制，对实际产品使用没有帮助。无法通过本文提供的方式减少 WriteableBitmap 的一次 CPU 拷贝</p>
<p>如 <a href="https://blog.lindexi.com/post/dotnet-%E8%AF%BB-WPF-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0-WriteableBitmap-%E7%9A%84%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0.html" target="_blank" rel="noopener nofollow">dotnet 读 WPF 源代码笔记 WriteableBitmap 的渲染和更新是如何实现</a> 博客所述，在 WPF 框架底层使用 CSwDoubleBufferedBitmap 存储 WriteableBitmap 的数据。如 CSwDoubleBufferedBitmap 命名所示，这是一个包含了双缓存的类型</p>
<p>在 CSwDoubleBufferedBitmap 里面包含的双缓存可以分为表层和里层两个缓存。表层是一个数组，用于给 WPF 应用上层业务方使用，直接可以在 UI 线程任何时刻使用。里层是 IWICBitmap 对象，这个 IWICBitmap 对象将从表层内存拷贝数据，渲染时将被加入到管线中参与绘制</p>
<p>这个过程里面，将发生两次 CPU 到 CPU 的内存拷贝，以及一次 CPU 到 GPU 的内存拷贝。为什么这么说呢，首先业务方需要将数据写入到 WriteableBitmap 里面，这个过程就是第一次 CPU 到 CPU 的内存拷贝。不严谨的表述可以这么认为，写入到 WriteableBitmap 的过程就是将数据“拷贝”到 WriteableBitmap 的过程，这个过程中完全发生在 CPU 计算里面，这就是我说的第一次 CPU 到 CPU 的内存拷贝过程。那第二次 CPU 到 CPU 发生在哪？发生在渲染线程中，第一次 CPU 到 CPU 拷贝过程里面是将业务方的数据拷贝到 WriteableBitmap 的表层内存里面，即 CSwDoubleBufferedBitmap 的 <code>m_pFrontBuffer</code> 里面，第二次 CPU 到 CPU 拷贝是在 CSwDoubleBufferedBitmap 里面，在 <code>CSwDoubleBufferedBitmap.CopyForwardDirtyRects</code> 里面从 <code>m_pFrontBuffer</code> 拷贝到 <code>CWriteProtectedBitmap *  m_pBackBufferAsWriteProtectedBitmap</code> 里面，即从表层内存拷贝到里层 IWICBitmap 对象里</p>
<p>最后一次 CPU 到 GPU 的内存拷贝是什么呢？那就是将 IWICBitmap 对象加入到渲染管线时，从 CPU 将数据同步到 GPU 上</p>
<p>我开始认为可以绕过 CSwDoubleBufferedBitmap 里面的一次 CPU 到 CPU 的拷贝，减少表层内存拷贝到里层 IWICBitmap 对象里的耗时，我直接就访问 CSwDoubleBufferedBitmap 的 <code>IWICBitmap * m_pBackBuffer</code> 对象，对其写入数据，于是就进行了本文的测试</p>
<p>当然了，最后我发现即使我成功拿到了 IWICBitmap 对象，且对其写入数据，最后要么就是没有通知到变更没有刷新渲染，要么就是被表层内存给覆盖了。没有任何的优化。如果大家对 WriteableBitmap 的写入性能感兴趣，推荐拉取 <a href="https://blog.lindexi.com/post/WPF-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html" target="_blank" rel="noopener nofollow">WPF 性能测试</a> 博客里面的代码进行测试</p>

<p>为了获取到 CSwDoubleBufferedBitmap 的 <code>IWICBitmap * m_pBackBuffer</code> 对象，我按照 <a href="https://blog.sdlsj.net" target="_blank" rel="noopener nofollow">lsj</a> 教我的方法，从 VisualStudio 里面查看 CSwDoubleBufferedBitmap 类的布局。即鼠标移动到类定义上，点击查看内存布局，即可看到如下图内容</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250424071235656-1682094120.png" alt="" loading="lazy"></p>
<p>如此即可看到 <code>IWICBitmap * m_pBackBuffer</code> 对象是 32 偏移量，刚好这是第一个指针，无论是 x86 还是 x64 都是 32 偏移量，于是定义如下结构体</p>
<pre><code class="language-csharp">[StructLayout(LayoutKind.Explicit)]
struct CSwDoubleBufferedBitmap
{
    // IWICBitmap *                        m_pBackBuffer;
    [FieldOffset(32)]
    public nint WicBitmap; // 刚好 m_pBackBuffer 就是第一个指针字段，无论是 x86 还是 x64 都刚好是第 32 个字节
}
</code></pre>
<p>在 WriteableBitmap 类型里面，将其存放到 <code>_pDoubleBufferedBitmap</code> 字段里面，如以下 WPF 代码所示</p>
<pre><code class="language-csharp">    public sealed class WriteableBitmap : BitmapSource
    {
        ... // 忽略其他代码

        private SafeMILHandle _pDoubleBufferedBitmap;   // CSwDoubleBufferedBitmap
    }
</code></pre>
<p>简单使用反射获取一下，然后指针转换为 <code>struct CSwDoubleBufferedBitmap</code> 结构体，代码如下</p>
<pre><code class="language-csharp">        var writeableBitmap = (WriteableBitmap) Image.Source;
        var type = writeableBitmap.GetType();

        var fieldInfo = type.GetField("_pDoubleBufferedBitmap", BindingFlags.NonPublic | BindingFlags.Instance);
        if (fieldInfo?.GetValue(writeableBitmap) is SafeHandleZeroOrMinusOneIsInvalid
            doubleBufferedBitmapHandle)
        {
            var handle = doubleBufferedBitmapHandle.DangerousGetHandle();
            var doubleBufferedBitmap = Marshal.PtrToStructure&lt;CSwDoubleBufferedBitmap&gt;(handle);
            ... // 忽略其他代码
        }
</code></pre>
<p>以上拿到的 <code>doubleBufferedBitmap</code> 就是 <code>struct CSwDoubleBufferedBitmap</code> 结构体</p>
<p>为了测试所拿到的 <code>CSwDoubleBufferedBitmap.WicBitmap</code> 是 IWICBitmap 对象，我通过 <code>stakx.WIC</code> 库将其转换为 <code>stakx.WIC.IWICBitmap</code> 对象，代码如下</p>
<pre><code class="language-csharp">            var wicBitmap = (IWICBitmap) Marshal.GetObjectForIUnknown(doubleBufferedBitmap.WicBitmap);
            var size = wicBitmap.GetSize();
</code></pre>
<p>以上尝试调用 GetSize 方法，如果能够返回创建 WriteableBitmap 时传入的尺寸，则证明获取正确</p>
<p>再进一步阅读 WPF 源代码，我发现了其实不需要从 CSwDoubleBufferedBitmap 里面即可拿到 IWICBitmap 对象，这是因为在 WriteableBitmap 还存在如下这一段代码</p>
<pre><code class="language-csharp">    public sealed class WriteableBitmap : BitmapSource
    {
        ... // 忽略其他代码
        private bool AcquireBackBuffer(TimeSpan timeout, bool waitForCopy)
        {
        	... // 忽略其他代码
            MILSwDoubleBufferedBitmap.GetBackBuffer(
                _pDoubleBufferedBitmap,
                out _pBackBuffer,
                out _backBufferSize);
        	_syncObject = WicSourceHandle = _pBackBuffer;
        	... // 忽略其他代码
        }
        private BitmapSourceSafeMILHandle _pBackBuffer; // IWICBitmap
    }
</code></pre>
<p>即可以直接拿到 <code>WicSourceHandle</code> 属性或 <code>_pBackBuffer</code> 字段即可，反射获取的代码如下</p>
<pre><code class="language-csharp">        var writeableBitmap = (WriteableBitmap) Image.Source;
        var type = writeableBitmap.GetType();
        var propertyInfo = type.GetProperty("WicSourceHandle", BindingFlags.NonPublic | BindingFlags.Instance);
        var value = propertyInfo?.GetValue(writeableBitmap);
        nint wicBitmapHandle = 0;
        if (value is SafeHandleZeroOrMinusOneIsInvalid safeHandle)
        {
            var handle = safeHandle.DangerousGetHandle();
            wicBitmapHandle = handle;
            var wicBitmap = (IWICBitmap) Marshal.GetObjectForIUnknown(handle);

            var size = wicBitmap.GetSize();
            var buffer = new byte[size.Width * size.Height * 4];
            Random.Shared.NextBytes(buffer);

            // 这里的绘制是无效的，因为在 WPF 底层会重新被 m_pFrontBuffer 覆盖
            wicBitmap.CopyPixels(4 * size.Width, buffer);
        }
        Debug.Assert(wicBitmapHandle != 0);
</code></pre>
<p>为了证明通过 WicSourceHandle 属性获取的和从 CSwDoubleBufferedBitmap 获取到相同的值，我添加了 <code>wicBitmapHandle</code> 局部变量，修改代码添加如下判断逻辑，实际证明两个方式获取到的是相同的值</p>
<pre><code class="language-csharp">        var fieldInfo = type.GetField("_pDoubleBufferedBitmap", BindingFlags.NonPublic | BindingFlags.Instance);
        if (fieldInfo?.GetValue(writeableBitmap) is SafeHandleZeroOrMinusOneIsInvalid
            doubleBufferedBitmapHandle)
        {
            var handle = doubleBufferedBitmapHandle.DangerousGetHandle();
            var doubleBufferedBitmap = Marshal.PtrToStructure&lt;CSwDoubleBufferedBitmap&gt;(handle);
            Debug.Assert(doubleBufferedBitmap.WicBitmap == wicBitmapHandle);
        }
</code></pre>
<p>这也符合 CSwDoubleBufferedBitmap 里面的逻辑</p>
<pre><code class="language-c++">void
CSwDoubleBufferedBitmap::GetBackBuffer(
    __deref_out IWICBitmap **ppBackBuffer,
    __out_opt UINT * pBackBufferSize
    ) const
{
    SetInterface(*ppBackBuffer, m_pBackBuffer);

    if (pBackBufferSize != NULL)
    {
        *pBackBufferSize = m_backBufferSize;
    }
}
</code></pre>
<p>本文代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/a920291d64e1163ffa40f4134c2a8c56cbbf1342/WPFDemo/CabawgakaicurrecalLalkiniyajagear" target="_blank" rel="noopener nofollow">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/blob/a920291d64e1163ffa40f4134c2a8c56cbbf1342/WPFDemo/CabawgakaicurrecalLalkiniyajagear" target="_blank" rel="noopener nofollow">gitee</a> 上，可以使用如下命令行拉取代码。我整个代码仓库比较庞大，使用以下命令行可以进行部分拉取，拉取速度比较快</p>
<p>先创建一个空文件夹，接着使用命令行 cd 命令进入此空文件夹，在命令行里面输入以下代码，即可获取到本文的代码</p>
<pre><code>git init
git remote add origin https://gitee.com/lindexi/lindexi_gd.git
git pull origin a920291d64e1163ffa40f4134c2a8c56cbbf1342
</code></pre>
<p>以上使用的是国内的 gitee 的源，如果 gitee 不能访问，请替换为 github 的源。请在命令行继续输入以下代码，将 gitee 源换成 github 源进行拉取代码。如果依然拉取不到代码，可以发邮件向我要代码</p>
<pre><code>git remote remove origin
git remote add origin https://github.com/lindexi/lindexi_gd.git
git pull origin a920291d64e1163ffa40f4134c2a8c56cbbf1342
</code></pre>
<p>获取代码之后，进入 WPFDemo/CabawgakaicurrecalLalkiniyajagear 文件夹，即可获取到源代码</p>
<p>更多 WPF 框架原理博客，请参阅 <a href="https://blog.lindexi.com/post/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA.html" target="_blank" rel="noopener nofollow">博客导航</a></p>
<p>更新：</p>
<p>有伙伴反馈说用 <code>stakx.WIC</code> 太旧了，没有能够用上最新的 COM 函数指针调用技术。用函数指针调用技术可以做到无中间商赚差价，无 COM 对象包装，直接调用，性能无敌且 AOT 友好。小伙伴就让我写用 Vortice 库的调用方法，直接走 Vortice 封装好的函数指针调用。我这里就来更新，先原有代码不动，先卸载 <code>stakx.WIC</code> 库，换成安装 <code>Vortice.Win32.Graphics.Imaging</code> 库，修改之后的 csproj 项目文件代码大概如下</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net9.0-windows&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Vortice.Win32.Graphics.Imaging" Version="2.2.7" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>依然是从反射获取 WriteableBitmap 的 WicSourceHandle 属性，拿到的 <code>wicBitmapHandle</code> 变量，原来代码如下</p>
<pre><code class="language-csharp">        var writeableBitmap = (WriteableBitmap) Image.Source;
        var type = writeableBitmap.GetType();
        var propertyInfo = type.GetProperty("WicSourceHandle", BindingFlags.NonPublic | BindingFlags.Instance);
        var value = propertyInfo?.GetValue(writeableBitmap);
        nint wicBitmapHandle = 0;
        if (value is SafeHandleZeroOrMinusOneIsInvalid safeHandle)
        {
            var handle = safeHandle.DangerousGetHandle();
            wicBitmapHandle = handle;
            ...
        }
</code></pre>
<p>这里拿到的 <code>wicBitmapHandle</code> 实际上是一个 COM 的 pvtable 指针，对应着 C# 函数指针里面应该是 <code>(void***)</code> 类型，需要取值才能作为 <code>void**</code> 传入到 <code>Win32.Graphics.Imaging.IWICBitmap</code> 的 lpVtbl 字段里面。也可以这么认为，拿到的 <code>wicBitmapHandle</code> 就是 COM 对象本身，这个 COM 对象首个字段就是 <code>vtable</code> 字段，取首个字段的值就是取 <code>wicBitmapHandle[0]</code> 的值，刚好 <code>[0]</code> 等于自身，可以约掉不写。整理之后的代码如下，请不要被 <code>(void***)</code> 吓到</p>
<pre><code class="language-csharp">            var handle = safeHandle.DangerousGetHandle();
            wicBitmapHandle = handle;
            var wicBitmap = new IWICBitmap();
            unsafe
            {
                void*** pvtable = (void***) wicBitmapHandle;
                void** vtable = *pvtable;
                wicBitmap.lpVtbl = vtable;

                uint w = 0, h = 0;
                wicBitmap.GetSize(&amp;w, &amp;h);
            }
</code></pre>
<p>转换完成之后，尝试调用 GetSize 方法，可以获取到宽度高度符合传入的初始宽度高度，证明转换正确</p>
<p>更新的代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/ff2b1566292ce1ebc40d579d9f7ea71c0086f9a3/WPFDemo/JaikikerallkurBerhayeajur" target="_blank" rel="noopener nofollow">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/blob/ff2b1566292ce1ebc40d579d9f7ea71c0086f9a3/WPFDemo/JaikikerallkurBerhayeajur" target="_blank" rel="noopener nofollow">gitee</a> 上，可以使用如下命令行拉取代码。我整个代码仓库比较庞大，使用以下命令行可以进行部分拉取，拉取速度比较快</p>
<p>先创建一个空文件夹，接着使用命令行 cd 命令进入此空文件夹，在命令行里面输入以下代码，即可获取到本文的代码</p>
<pre><code>git init
git remote add origin https://gitee.com/lindexi/lindexi_gd.git
git pull origin ff2b1566292ce1ebc40d579d9f7ea71c0086f9a3
</code></pre>
<p>以上使用的是国内的 gitee 的源，如果 gitee 不能访问，请替换为 github 的源。请在命令行继续输入以下代码，将 gitee 源换成 github 源进行拉取代码。如果依然拉取不到代码，可以发邮件向我要代码</p>
<pre><code>git remote remove origin
git remote add origin https://github.com/lindexi/lindexi_gd.git
git pull origin ff2b1566292ce1ebc40d579d9f7ea71c0086f9a3
</code></pre>
<p>获取代码之后，进入 WPFDemo/JaikikerallkurBerhayeajur 文件夹，即可获取到源代码</p>
<p>更多 COM 函数指针调用，请参阅 <a href="https://blog.lindexi.com/post/%E6%BC%94%E7%BB%83-dotnet-%E4%BD%BF%E7%94%A8-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E8%B0%83%E7%94%A8-COM-%E6%8E%A5%E5%8F%A3.html" target="_blank" rel="noopener nofollow">演练 dotnet 使用 函数指针 调用 COM 接口</a></p>


</div>
<div id="MySignature" role="contentinfo">
    <p>博客园博客只做备份，博客发布就不再更新，如果想看最新博客，请访问 https://blog.lindexi.com/</p>

<p>如图片看不见，请在浏览器开启不安全http内容兼容</p>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width: 0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](https://www.cnblogs.com/lindexi)(包含链接:https://www.cnblogs.com/lindexi )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6230411191689815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-26 07:18">2025-04-24 07:13</span>&nbsp;
<a href="https://www.cnblogs.com/lindexi">lindexi</a>&nbsp;
阅读(<span id="post_view_count">99</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18843888);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18843888', targetLink: 'https://www.cnblogs.com/lindexi/p/18843888', title: 'WPF 从 WriteableBitmap 里获取到渲染线程使用的 IWICBitmap 对象' })">举报</a>
</div>
        