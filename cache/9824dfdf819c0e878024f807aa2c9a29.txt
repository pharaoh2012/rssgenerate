
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18908161" title="发布于 2025-06-03 11:14">
    <span role="heading" aria-level="2">超实用！Dify快速接入本地MCP服务</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Dify 可以通过插件实现 MCP 服务调用，而被调用的 MCP 服务基本可以分为以下两类：</p>
<ol>
<li>通用 MCP 服务（非本地 MCP 服务）。</li>
<li>本地 MCP 服务。</li>
</ol>
<blockquote>
<p>本地 MCP 服务指的是本地通过 Java 或其他语言实现的 MCP 服务器端。</p>
</blockquote>
<p>当你会用 Dify 调用本地 MCP 服务，也就意味着你会使用 Dify 调用通用 MCP 服务了，因为实现步骤和原理基本都是一样。</p>
<h2 id="1什么是mcp">1.什么是MCP？</h2>
<p><strong>MCP 是 Model Context Protocol，模型上下文协议</strong>，它是由 Anthropic（Claude 大模型母公司）提出的开放协议，用于大模型连接外部“数据源”的一种协议。</p>
<p>它可以通俗的理解为 Java 界的 Spring Cloud Openfeign，只不过 Openfeign 是用于微服务通讯的，而 MCP 用于大模型通讯的，但它们都是为了通讯获取某项数据的一种机制，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111354728-1128995905.png" alt="" loading="lazy"></p>
<h2 id="2为什么需要mcp">2.为什么需要MCP？</h2>
<p>MCP 存在的意义是它解决了大模型时代最关键的三个问题：<strong>数据孤岛<strong><strong>、开发低效和生态</strong></strong>碎片化</strong>等问题。</p>
<h3 id="1打破数据孤岛让ai连接万物"><strong>1.打破数据孤岛，让AI“连接万物”</strong></h3>
<p>大模型本身无法直接访问实时数据或本地资源（如数据库、文件系统），传统方式需要手动复制粘贴或定制接口。MCP 通过标准化协议，让大模型像“插USB”一样直接调用外部工具和数据源，例如：</p>
<ul>
<li>查天气时自动调用气象 API，无需手动输入数据。</li>
<li>分析企业数据时直接连接内部数据库，避免信息割裂。</li>
</ul>
<h3 id="2降低开发成本一次适配所有场景"><strong>2.降低开发成本，一次适配所有场景</strong></h3>
<p>在之前每个大模型（如 DeepSeek、ChatGPT）需要为每个工具单独开发接口（Function Calling），导致重复劳动，MCP 通过统一协议：</p>
<ul>
<li>开发者只需写一次 MCP 服务端，所有兼容 MCP 的模型都能调用。</li>
<li>用户无需关心技术细节，大模型可直接操作本地文件、设计软件等。</li>
</ul>
<h3 id="3提升安全性与互操作性"><strong>3.提升安全性与互操作性</strong></h3>
<ul>
<li><strong>安全性</strong>：MCP 内置权限控制和加密机制，比直接开放数据库更安全。</li>
<li><strong>生态统一</strong>：类似 USB 接口，MCP 让不同厂商的工具能“即插即用”，避免生态分裂。</li>
</ul>
<h3 id="4推动aiagent的进化"><strong>4.推动AIAgent的进化</strong></h3>
<p>MCP 让大模型从“被动应答”变为“主动调用工具”，例如：</p>
<ul>
<li>自动抓取网页新闻补充实时知识。</li>
<li>打开 Idea 编写一个“Hello World”的代码。</li>
</ul>
<p>MCP 的诞生，相当于为AI世界建立了“通用语言”，让模型、数据和工具能高效协作，最终释放大模型的全部潜力。</p>
<h2 id="3mcp组成和执行流程">3.MCP组成和执行流程</h2>
<p>MCP 架构分为以下 3 部分：</p>
<ul>
<li><strong>客户端</strong>：大模型应用（如 DeepSeek、ChatGPT）发起 MCP 协议请求。</li>
<li><strong>服务器端</strong>：服务器端响应客户端的请求，并查询自己的业务实现请求处理和结果返回。</li>
</ul>
<p><strong>运行流程</strong>：</p>
<ol>
<li>用户提问 LLM。</li>
<li>LLM 查询 MCP 服务列表。</li>
<li>找到需要调用 MCP 服务，调用 MCP 服务器端。</li>
<li>MCP 服务器接收到指令。</li>
<li>调用对应工具（如数据库）执行。</li>
<li>返回结果给 LLM。</li>
</ol>
<h2 id="4编写本地mcp服务">4.编写本地MCP服务</h2>
<p>接下来，我们使用 Spring AI 来实现本地 MCP 服务器端，它的主要实现步骤如下：</p>
<ol>
<li>添加 MCP Server 依赖。</li>
<li>设置 MCP 配置信息。</li>
<li>编写 MCP Server 服务代码。</li>
<li>将 MCP Server 进行暴露设置。</li>
</ol>
<p>关键实现代码如下。</p>
<h3 id="41-添加-mcp-server-依赖">4.1 添加 MCP Server 依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-starter-mcp-server-webflux&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;repositories&gt;
  &lt;repository&gt;
    &lt;name&gt;Central Portal Snapshots&lt;/name&gt;
    &lt;id&gt;central-portal-snapshots&lt;/id&gt;
    &lt;url&gt;https://central.sonatype.com/repository/maven-snapshots/&lt;/url&gt;
    &lt;releases&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/releases&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
  &lt;/repository&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-milestones&lt;/id&gt;
    &lt;name&gt;Spring Milestones&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/snapshots&gt;
  &lt;/repository&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-snapshots&lt;/id&gt;
    &lt;name&gt;Spring Snapshots&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
    &lt;releases&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/releases&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p>MCP Server 依赖有三种类型：</p>
<ul>
<li><strong>标准输入/输出 （STDIO）</strong>：spring-ai-starter-mcp-server</li>
<li><strong>Spring MVC****（服务器发送的事件）</strong>：spring-ai-starter-mcp-server-webmvc</li>
<li><strong>Spring WebFlux（响应式 SSE）</strong>：spring-ai-starter-mcp-server-webflux</li>
</ul>
<h3 id="42-设置-mcp-配置信息">4.2 设置 MCP 配置信息</h3>
<p>MCP Server 包含以下配置信息：</p>
<table>
<thead>
<tr>
<th><strong>配置项</strong></th>
<th><strong>描述</strong></th>
<th><strong>默认值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>enabled</td>
<td>启用/禁用 MCP 服务器</td>
<td>TRUE</td>
</tr>
<tr>
<td>stdio</td>
<td>启用/禁用 stdio 传输</td>
<td>FALSE</td>
</tr>
<tr>
<td>name</td>
<td>用于标识的服务器名称</td>
<td>mcp-server</td>
</tr>
<tr>
<td>version</td>
<td>服务器版本</td>
<td>1.0.0</td>
</tr>
<tr>
<td>type</td>
<td>服务器类型 （SYNC/ASYNC）</td>
<td>SYNC</td>
</tr>
<tr>
<td>resource-change-notification</td>
<td>启用资源更改通知</td>
<td>TRUE</td>
</tr>
<tr>
<td>prompt-change-notification</td>
<td>启用提示更改通知</td>
<td>TRUE</td>
</tr>
<tr>
<td>tool-change-notification</td>
<td>启用工具更改通知</td>
<td>TRUE</td>
</tr>
<tr>
<td>tool-response-mime-type</td>
<td>（可选）每个工具名称的响应 MIME 类型。例如，将 mime 类型与工具名称相关联spring.ai.mcp.server.tool-response-mime-type.generateImage=image/pngimage/pnggenerateImage()</td>
<td>-</td>
</tr>
<tr>
<td>sse-message-endpoint</td>
<td>Web 传输的 SSE 终端节点路径</td>
<td>/mcp/message</td>
</tr>
</tbody>
</table>
<p>其中 MCP Server 又分为以下两种类型。</p>
<h4 id="服务器类型">服务器类型</h4>
<ul>
<li><strong>同步服务器</strong>：默认服务器类型，它专为应用程序中的简单请求-响应模式而设计。要启用此服务器类型，请在您的配置中设置。 激活后，它会自动处理同步工具规格的配置，spring.ai.mcp.server.type=SYNC。</li>
<li><strong>异步服务器：</strong>异步服务器实现使用非阻塞作并针对非阻塞作进行了优化。要启用此服务器类型，请使用配置您的应用程序。此服务器类型会自动设置具有内置 Project Reactor 支持的异步工具规范，spring.ai.mcp.server.type=ASYNC。</li>
</ul>
<h3 id="43-编写mcpserver服务代码">4.3 编写MCPServer服务代码</h3>
<p>编写天气预报查询伪代码：</p>
<pre><code class="language-java">import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class WeatherService {

    @Tool(description = "根据城市名称获取天气预报")
    public String getWeatherByCity(String city) {
        Map&lt;String, String&gt; mockData = Map.of(
            "西安", "晴天",
            "北京", "小雨",
            "上海", "大雨"
        );
        return mockData.getOrDefault(city, "抱歉：未查询到对应城市！");
    }

}
</code></pre>
<h3 id="44-将服务暴露出去">4.4 将服务暴露出去</h3>
<pre><code class="language-java">@Bean
public ToolCallbackProvider weatherTools(WeatherService weatherService) {
return MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
}
</code></pre>
<p>这样 MCP Server 就编写完成了。</p>
<h2 id="5dify调用本地mcp">5.Dify调用本地MCP</h2>
<p>Dify 调用 MCP 主要步骤如下：</p>
<ol>
<li>安装 MCP 插件。</li>
<li>配置 MCP 服务 HTTP 地址。</li>
<li>配置 Agent 相关信息。</li>
<li>运行测试。</li>
</ol>
<p>具体配置如下。</p>
<h3 id="51-安装-mcp-插件">5.1 安装 MCP 插件</h3>
<p>安装 Agent 策略（支持 MCP 工具）如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111402900-1784154705.png" alt="" loading="lazy"></p>
<blockquote>
<p>MCP SSE 选装，非必须，可以为后续 Agent 提供 MCP 工具列表，方便 LLM 正确理解和调用工具。</p>
</blockquote>
<h3 id="52-配置-mcp-服务地址">5.2 配置 MCP 服务地址</h3>
<p>Dify 只支持 HTTP 协议的 MCP 服务调用，它的配置格式如下：</p>
<pre><code class="language-json">{
  "server_name1": {
    "transport": "sse",
    "url": "http://127.0.0.1:8000/sse",
    "headers": {},
    "timeout": 50,
    "sse_read_timeout": 50
  },
  "server_name2": {
    "transport": "sse",
    "url": "http://127.0.0.1:8001/sse"
  },
  "server_name3": {
    "transport": "streamable_http",
    "url": "http://127.0.0.1:8002/mcp",
    "headers": {},
    "timeout": 50
  },
  "server_name4": {
    "transport": "streamable_http",
    "url": "http://127.0.0.1:8003/mcp"
  }
}
</code></pre>
<p>支持配置多个 MCP 服务，或者是以下 JSON 格式也支持：</p>
<pre><code class="language-json">{
  "mcpServers": {
      "server_name1": {
        "transport": "sse",
        "url": "http://127.0.0.1:8000/sse",
        "headers": {},
        "timeout": 50,
        "sse_read_timeout": 50
      },
      "server_name2": {
        "transport": "sse",
        "url": "http://127.0.0.1:8001/sse"
      },
      "server_name3": {
        "transport": "streamable_http",
        "url": "http://127.0.0.1:8002/mcp",
        "headers": {},
        "timeout": 50
      },
      "server_name4": {
        "transport": "streamable_http",
        "url": "http://127.0.0.1:8003/mcp"
      }
    }
}
</code></pre>
<h3 id="53-配置-agent">5.3 配置 Agent</h3>
<p>Agent 需要配置的项目比较多，首先是 Agent 策略：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111413782-1298373810.png" alt="" loading="lazy"></p>
<p>然后是 LLM，选择合适的大模型即可，之后配置 MCP 工具和 HTTP 地址，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111424221-1579104037.png" alt="" loading="lazy"></p>
<p>之后配置指令和查询问题：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111432088-556306495.png" alt="" loading="lazy"></p>
<h3 id="54-测试-mcp-调用">5.4 测试 MCP 调用</h3>
<p>我们创建的是一个 ChatFlow，执行效果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/172074/202506/172074-20250603111439002-264543170.png" alt="" loading="lazy"></p>
<p>执行符合预期。</p>
<h2 id="小结">小结</h2>
<p>Dify 调用 MCP 服务主要依靠的是 HTTP 地址和 MCP 协议，对于用户来说他面向的是大模型，对于程序来说是大模型调用了 MCP 服务，所以大模型端也就是 MCP 的客户端。我们会调用本地 MCP 服务了，那么问题来了，如何调用通用的 MCP 服务呢？</p>
<blockquote>
<p>本文已收录到我的技术小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：Spring AI、LangChain4j、Dify、AI Agent、MCP、Function Call、RAG、向量数据库、Prompt、多模态、向量数据库、嵌入模型等内容。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5461470055763888" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-03 11:15">2025-06-03 11:14</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">195</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18908161);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18908161', targetLink: 'https://www.cnblogs.com/vipstone/p/18908161', title: '超实用！Dify快速接入本地MCP服务' })">举报</a>
</div>
        