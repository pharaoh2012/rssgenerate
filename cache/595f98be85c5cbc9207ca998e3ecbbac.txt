
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18860943" title="发布于 2025-05-06 09:20">
    <span role="heading" aria-level="2">MySQL同步ES的6种方案！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>在分布式架构中，MySQL与Elasticsearch（ES）的协同已成为解决高并发查询与复杂检索的标配组合。</p>
<p>然而，如何实现两者间的高效数据同步，是架构设计中绕不开的难题。</p>
<p>这篇文章跟大家一起聊聊MySQL同步ES的6种主流方案，结合代码示例与场景案例，帮助开发者避开常见陷阱，做出最优技术选型。</p>
<h2 id="方案一同步双写">方案一：同步双写</h2>
<p><strong>场景</strong>：适用于对数据实时性要求极高，且业务逻辑简单的场景，如金融交易记录同步。</p>
<p>在业务代码中同时写入MySQL与ES。</p>
<p>代码如下：</p>
<pre><code class="language-java">@Transactional  
public void createOrder(Order order) {  
    // 写入MySQL  
    orderMapper.insert(order);  
    // 同步写入ES  
    IndexRequest request = new IndexRequest("orders")  
        .id(order.getId())  
        .source(JSON.toJSONString(order), XContentType.JSON);  
    client.index(request, RequestOptions.DEFAULT);  
}
</code></pre>
<p><strong>痛点</strong>：</p>
<ol>
<li><strong>硬编码侵入</strong>：所有涉及写操作的地方均需添加ES写入逻辑。</li>
<li><strong>性能瓶颈</strong>：双写操作导致事务时间延长，TPS下降30%以上。</li>
<li><strong>数据一致性风险</strong>：若ES写入失败，需引入补偿机制（如本地事务表+定时重试）。</li>
</ol>
<h2 id="方案二异步双写">方案二：异步双写</h2>
<p><strong>场景</strong>：电商订单状态更新后需同步至ES供客服系统检索。</p>
<p>我们可以使用MQ进行解耦。</p>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/29517de9-ed70-4ea5-b0bc-0943f8114a38.png" alt="" loading="lazy"></p>
<p><strong>代码示例如下</strong>：</p>
<pre><code class="language-java">// 生产者端  
public void updateProduct(Product product) {  
    productMapper.update(product);  
    kafkaTemplate.send("product-update", product.getId());  
}  

// 消费者端  
@KafkaListener(topics = "product-update")  
public void syncToEs(String productId) {  
    Product product = productMapper.selectById(productId);  
    esClient.index(product);  
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>吞吐量提升：通过MQ削峰填谷，可承载万级QPS。</li>
<li>故障隔离：ES宕机不影响主业务链路。</li>
</ul>
<p><strong>缺陷</strong>：</p>
<ul>
<li><strong>消息堆积</strong>：突发流量可能导致消费延迟（需监控Lag值）。</li>
<li><strong>顺序性问题</strong>：需通过分区键保证同一数据的顺序消费。</li>
</ul>
<h2 id="方案三logstash定时拉取">方案三：Logstash定时拉取</h2>
<p><strong>场景</strong>：用户行为日志的T+1分析场景。</p>
<p>该方案低侵入但高延迟。</p>
<p><strong>配置示例如下</strong>：</p>
<pre><code class="language-yml">input {  
  jdbc {  
    jdbc_driver =&gt; "com.mysql.jdbc.Driver"  
    jdbc_url =&gt; "jdbc:mysql://localhost:3306/log_db"  
    schedule =&gt; "*/5 * * * *"  # 每5分钟执行  
    statement =&gt; "SELECT * FROM user_log WHERE update_time &gt; :sql_last_value"  
  }  
}  
output {  
  elasticsearch {  
    hosts =&gt; ["es-host:9200"]  
    index =&gt; "user_logs"  
  }  
}
</code></pre>
<p><strong>适用性分析</strong>：</p>
<ul>
<li><strong>优点</strong>：零代码改造，适合历史数据迁移。</li>
<li><strong>致命伤</strong>：
<ul>
<li>分钟级延迟（无法满足实时搜索）</li>
<li>全表扫描压力大（需优化增量字段索引）</li>
</ul>
</li>
</ul>
<h2 id="方案四canal监听binlog">方案四：Canal监听Binlog</h2>
<p><strong>场景</strong>：社交平台动态实时搜索（如微博热搜更新）。<br>
<strong>技术栈</strong>：Canal + RocketMQ + ES</p>
<p>该方案高实时，并且低侵入。</p>
<p><strong>架构流程如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/081129b4-8f7f-4d4e-8ec9-27d2dc48f518.png" alt="" loading="lazy"></p>
<p><strong>关键配置</strong>：</p>
<pre><code class="language-yml"># canal.properties  
canal.instance.master.address=127.0.0.1:3306  
canal.mq.topic=canal.es.sync
</code></pre>
<p><strong>避坑指南</strong>：</p>
<ol>
<li><strong>数据漂移</strong>：需处理DDL变更（通过Schema Registry管理映射）。</li>
<li><strong>幂等消费</strong>：通过<code>_id</code>唯一键避免重复写入。</li>
</ol>
<h2 id="方案五datax批量同步">方案五：DataX批量同步</h2>
<p><strong>场景</strong>：将历史订单数据从分库分表MySQL迁移至ES。</p>
<p>该方案是大数据迁移的首选。</p>
<p><strong>配置文件如下</strong>：</p>
<pre><code class="language-yml">{  
  "job": {  
    "content": [{  
      "reader": {  
        "name": "mysqlreader",  
        "parameter": { "splitPk": "id", "querySql": "SELECT * FROM orders" }  
      },  
      "writer": {  
        "name": "elasticsearchwriter",  
        "parameter": { "endpoint": "http://es-host:9200", "index": "orders" }  
      }  
    }]  
  }  
}
</code></pre>
<p><strong>性能调优</strong>：</p>
<ul>
<li>调整<code>channel</code>数提升并发（建议与分片数对齐）</li>
<li>启用<code>limit</code>分批查询避免OOM</li>
</ul>
<h2 id="方案六flink流处理">方案六：Flink流处理</h2>
<p><strong>场景</strong>：商品价格变更时，需关联用户画像计算实时推荐评分。</p>
<p>该方案适合于复杂的ETL场景。</p>
<p><strong>代码片段如下</strong>：</p>
<pre><code class="language-java">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();  
env.addSource(new CanalSource())  
   .map(record -&gt; parseToPriceEvent(record))  
   .keyBy(event -&gt; event.getProductId())  
   .connect(userProfileBroadcastStream)  
   .process(new PriceRecommendationProcess())  
   .addSink(new ElasticsearchSink());
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>状态管理</strong>：精准处理乱序事件（Watermark机制）</li>
<li><strong>维表关联</strong>：通过Broadcast State实现实时画像关联</li>
</ul>
<h2 id="总结">总结：</h2>
<p>对于文章上面给出的这6种技术方案，我们在实际工作中，该如何做选型呢？</p>
<p>下面用一张表格做对比：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>实时性</th>
<th>侵入性</th>
<th>复杂度</th>
<th>适用阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步双写</td>
<td>秒级</td>
<td>高</td>
<td>低</td>
<td>小型单体项目</td>
</tr>
<tr>
<td>MQ异步</td>
<td>秒级</td>
<td>中</td>
<td>中</td>
<td>中型分布式系统</td>
</tr>
<tr>
<td>Logstash</td>
<td>分钟级</td>
<td>无</td>
<td>低</td>
<td>离线分析</td>
</tr>
<tr>
<td>Canal</td>
<td>毫秒级</td>
<td>无</td>
<td>高</td>
<td>高并发生产环境</td>
</tr>
<tr>
<td>DataX</td>
<td>小时级</td>
<td>无</td>
<td>中</td>
<td>历史数据迁移</td>
</tr>
<tr>
<td>Flink</td>
<td>毫秒级</td>
<td>低</td>
<td>极高</td>
<td>实时数仓</td>
</tr>
</tbody>
</table>
<p><strong>苏三的建议</strong>：</p>
<ol>
<li>若团队无运维中间件能力 → 选择Logstash或同步双写</li>
<li>需秒级延迟且允许改造 → MQ异步 + 本地事务表</li>
<li>追求极致实时且资源充足 → Canal + Flink双保险</li>
</ol>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。<br>
求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的50万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7130544172361111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-06 09:20">2025-05-06 09:20</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">366</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18860943);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18860943', targetLink: 'https://www.cnblogs.com/12lisu/p/18860943', title: 'MySQL同步ES的6种方案！' })">举报</a>
</div>
        