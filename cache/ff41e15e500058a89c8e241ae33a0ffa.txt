
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18800409" title="发布于 2025-03-31 08:15">
    <span role="heading" aria-level="2">【Guava】集合工具类-Immutable&amp;Lists&amp;Maps&amp;Sets</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="immutable">Immutable</h2>
<p>如<a href="https://www.seven97.top/books/software-quality/effectivejava-summary.html#_1%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8" target="_blank" rel="noopener nofollow">《Effective Java》Item1</a>)所述，在设计类的时候，倾向优先使用静态工厂方法(static factory method)而非构造函数(constructor)创建对象，优点在于:</p>
<ol>
<li>静态工厂方法多了一层名称信息，比构造函数更富表达性。</li>
<li>可以更灵活地创建对象，比如缓式初始化，缓存已创建对象。</li>
<li>静态方法内部返回的对象类型，可以是其声明类型的子类。</li>
</ol>
<p>同样，如<a href="https://www.seven97.top/books/software-quality/effectivejava-summary.html#_17%E3%80%81%E6%9C%80%E5%B0%8F%E5%8C%96%E5%8F%AF%E5%8F%98%E6%80%A7" target="_blank" rel="noopener nofollow">《Effective Java》Item17</a>所述，需要最小化可变性，<code>ImmutableList</code>遵循了最佳实践。首先，<code>ImmutableList</code>不可以通过构造函数实例化，更准确地说，不可以在<code>package</code>外部通过构造函数实例化。</p>
<p>而在程序设计中使用不可变对象，也可以提高代码的可靠性和可维护性，其优势包括：</p>
<ol>
<li><strong>线程安全性（Thread Safety）</strong>：不可变对象是线程安全的，无需同步操作，避免了竞态条件</li>
<li><strong>安全性</strong>：可以防止在程序运行时被意外修改，提高了程序的安全性</li>
<li><strong>易于理解和测试</strong>：不可变对象在创建后不会发生变化，更容易理解和测试</li>
<li><strong>克隆和拷贝</strong>：不可变对象不需要实现可变对象的复制（Clone）和拷贝（Copy）逻辑，因为它们的状态不可变，克隆即是自己</li>
</ol>
<p>创建对象的不可变拷贝是一项很好的防御性编程技巧。Guava为所有JDK标准集合类型和Guava新集合类型都提供了简单易用的不可变版本。JDK也提供了Collections.unmodifiableXXX方法把集合包装为不可变形式.</p>
<h3 id="jdk不可变集合存在的问题">JDK不可变集合存在的问题</h3>
<p>JDK 的 Collections 提供了 Unmodified Collections 不可变集合，但仅仅是通过装饰器模式提供了一个只读的视图，unmodifiableList本身是无法进行add等修改操作，但并没有阻止对原始集合的修改操作，所以说Collections.unmodifiableList实现的不是真正的不可变集合。</p>
<pre><code class="language-java">List&lt;String&gt; list=new ArrayList&lt;String&gt;();
list.add("a");
list.add("b");
list.add("c");

//通过list创建一个不可变的unmodifiableList集合
List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);
System.out.println(unmodifiableList);//[a,b,c]

//通过list添加元素
list.add("ddd");
System.out.println("往list添加一个元素:" + list);//[a,b,c,ddd]
System.out.println("通过list添加元素之后的unmodifiableList:" + unmodifiableList);[]//[a,b,c,ddd]

 //通过unmodifiableList添加元素
unmodifiableList.add("eee");//报错
System.out.println("往unmodifiableList添加一个元素:" + unmodifiableList);

</code></pre>
<ul>
<li>笨重而且累赘：不能舒适地用在所有想做防御性拷贝的场景；</li>
<li>不安全：要保证没人通过原集合的引用进行修改，返回的集合才是事实上不可变的；</li>
<li>低效：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。</li>
</ul>
<h3 id="guava不可变集合案例">Guava不可变集合案例</h3>
<p>而 Guava 提供的不可变集合不是原容器的视图，而是原容器的一份拷贝，因此更加简单高效，确保了真正的不可变性。</p>
<blockquote>
<p>但是还要注意，由于immutable只是copy了元容器本身，并不是deep copy，因此对原容器的引用的内容进行修改，也会影响immutableXXX</p>
</blockquote>
<p><strong>注意</strong>：每个Guava immutable集合类的实现都拒绝null值。如果确实需要能接受null值的集合类，可以考虑用Collections.unmodifiableXXX。</p>
<p>immutable集合可以有以下几种方式来创建：</p>
<ol>
<li>用copyOf方法，比如，ImmutableSet.copyOf(set)</li>
<li>使用of方法，比如，ImmutableSet.of("a", "b", "c") 或者 ImmutableMap.of("a", 1, "b", 2)</li>
<li>使用Builder类：减少中间对象的创建，提高内存使用效率。</li>
</ol>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("a");
list.add("b");
list.add("c");
System.out.println("list：" + list);//[a, b, c]

ImmutableList&lt;String&gt; imlist = ImmutableList.copyOf(list);
System.out.println("imlist：" + imlist);//[a, b, c]

ImmutableList&lt;String&gt; imOflist = ImmutableList.of("seven", "seven1", "seven2");
System.out.println("imOflist：" + imOflist);//[seven, seven1, seven2]

ImmutableSortedSet&lt;String&gt; imSortList = ImmutableSortedSet.of("a", "b", "c", "a", "d", "b");
System.out.println("imSortList：" + imSortList);//[a, b, c, d]

list.add("seven");
System.out.println("list add a item after list:" + list);//[a, b, c, seven]
System.out.println("list add a item after imlist:" + imlist);//[a, b, c]

ImmutableSet&lt;Color&gt; imColorSet =
       ImmutableSet.&lt;Color&gt;builder()
             .add(new Color(0, 255, 255))
             .add(new Color(0, 191, 255))
             .build();

System.out.println("imColorSet:" + imColorSet); //[java.awt.Color[r=0,g=255,b=255], java.awt.Color[r=0,g=191,b=255]]
</code></pre>
<h3 id="更智能的copyof">更智能的copyOf</h3>
<p>ImmutableXXX.copyOf会在合适的情况下避免拷贝元素的操作。</p>
<pre><code class="language-java">ImmutableSet&lt;String&gt; imSet = ImmutableSet.of("seven", "lisa", "seven1", "lisa1");
System.out.println("imSet：" + imSet);//[seven, lisa, seven1, lisa1]
ImmutableList&lt;String&gt; imlist = ImmutableList.copyOf(imSet);
System.out.println("imlist：" + imlist);//[seven, lisa, seven1, lisa1]
ImmutableSortedSet&lt;String&gt; imSortSet = ImmutableSortedSet.copyOf(imSet);
System.out.println("imSortSet：" + imSortSet);//[lisa, lisa1, seven, seven1]

List&lt;String&gt; list = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; 20; i++) {
       list.add(i + "x");
 }
System.out.println("list：" + list);//[0x, 1x, 2x, 3x, 4x, 5x, 6x, 7x, 8x, 9x, 10x, 11x, 12x, 13x, 14x, 15x, 16x, 17x, 18x, 19x]
ImmutableList&lt;String&gt; imInfolist = ImmutableList.copyOf(list.subList(2, 18));
System.out.println("imInfolist：" + imInfolist);//[2x, 3x, 4x, 5x, 6x, 7x, 8x, 9x, 10x, 11x, 12x, 13x, 14x, 15x, 16x, 17x]
int imInfolistSize = imInfolist.size();
System.out.println("imInfolistSize：" + imInfolistSize);//16
ImmutableSet&lt;String&gt; imInfoSet = ImmutableSet.copyOf(imInfolist.subList(2, imInfolistSize - 3));
System.out.println("imInfoSet：" + imInfoSet);//[4x, 5x, 6x, 7x, 8x, 9x, 10x, 11x, 12x, 13x, 14x]
</code></pre>
<p>在这段代码中，ImmutableList.copyOf(imSet)会智能地直接返回 imSet.asList()，它是一个ImmutableSet的常量时间复杂度的List视图。</p>
<p>实际上，要实现<code>copyOf</code>方法，最简单的就是直接将底层的每个元素做深拷贝然后生成<code>ImmutableList</code>。但是对于所有情况都深拷贝的话，性能和存储开销必然比较大，那么源码里面是如何优化的呢？</p>
<p>所有不可变集合都有一个asList() 方法提供ImmutableList视图，让我们可以用列表形式方便地读取集合元素。例如，我们可以使用sortedSet.asList().get(k) 从 ImmutableSortedSet 中读取第k个最小元素。<br>
asList()返回的ImmutableList 通常是（但并不总是）开销稳定的视图实现，而不是简单地把元素拷贝进List，也就是说，asList返回的列表视图通常比一般的列表平均性能更好，比如，在底层集合支持的情况下，它总是使用高效的contains方法。</p>
<p>源码如下：</p>
<pre><code class="language-java">// com.google.common.collect.ImmutableList#copyOf(java.util.Collection&lt;? extends E&gt;)
public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
    //判断是否是不可变集合
    if (elements instanceof ImmutableCollection) {
        //如果传入的结合本身就是一个不可变集合，那么asList获取视图后返回；其实就是直接复用原来的collection
        ImmutableList&lt;E&gt; list = ((ImmutableCollection)elements).asList();
        //判断是否是要返回局部视图：是的话重新构建-&gt;调用Arrays.copyOf做深拷；不是的话就复用原来的
        return list.isPartialView() ? asImmutableList(list.toArray()) : list;
    } else {//如果不是，则执行construct方法：底层调用Arrays.copyOf做深拷贝
        return construct(elements.toArray());
    }
}

// com.google.common.collect.ImmutableCollection#asList
public ImmutableList&lt;E&gt; asList() {
    switch (this.size()) {
        case 0:
            // 返回一个空的不可变集合，这个空集合是个static final常量，可复用
            return ImmutableList.of();
        case 1:
            // 返回一个不可变的 SingletonImmutableList 集合
            return ImmutableList.of(this.iterator().next());
        default:
            return new RegularImmutableAsList(this, this.toArray());
    }
}

//com.google.common.collect.RegularImmutableAsList#RegularImmutableAsList(com.google.common.collect.ImmutableCollection&lt;E&gt;, java.lang.Object[])
RegularImmutableAsList(ImmutableCollection&lt;E&gt; delegate, Object[] array) {
    this(delegate, ImmutableList.asImmutableList(array));
}
RegularImmutableAsList(ImmutableCollection&lt;E&gt; delegate, ImmutableList&lt;? extends E&gt; delegateList) {
    this.delegate = delegate;
    this.delegateList = delegateList;
}
</code></pre>
<p>实际上，ImmutableXXX.copyOf(ImmutableCollection)会试图对如下情况避免线性时间拷贝：</p>
<ul>
<li><strong>在常量时间内使用底层数据结构是可能的</strong>：因为会获取视图后返回</li>
<li><strong>不会造成内存泄露</strong>：例如，有个很大的不可变集合<code>ImmutableList&lt;String&gt; hugeList</code>， <code>ImmutableList.copyOf(hugeList.subList(0, 10))</code>就会显式地拷贝（如上源码，会判断是否是局部视图），以免不必要地持有hugeList的引用。</li>
<li><strong>不改变语义</strong>：所以ImmutableSet.copyOf(myImmutableSortedSet)都会显式地拷贝，因为和基于比较器的ImmutableSortedSet相比，ImmutableSet对hashCode()和equals有不同语义。</li>
</ul>
<p>在可能的情况下避免线性拷贝，可以最大限度地减少防御性编程风格所带来的性能开销。</p>
<h3 id="guava集合和不可变对应关系">Guava集合和不可变对应关系</h3>
<table>
<thead>
<tr>
<th><strong>可变集合类型</strong></th>
<th><strong>可变集合源：JDK or Guava?</strong></th>
<th><strong>Guava不可变集合</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td>JDK</td>
<td>ImmutableCollection</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>ImmutableSet</td>
</tr>
<tr>
<td>SortedSet/NavigableSet</td>
<td>JDK</td>
<td>ImmutableSortedSet</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>ImmutableMap</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>ImmutableSortedMap</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>ImmutableMultiset</td>
</tr>
<tr>
<td>SortedMultiset</td>
<td>Guava</td>
<td>ImmutableSortedMultiset</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>ImmutableMultimap</td>
</tr>
<tr>
<td>ListMultimap</td>
<td>Guava</td>
<td>ImmutableListMultimap</td>
</tr>
<tr>
<td>SetMultimap</td>
<td>Guava</td>
<td>ImmutableSetMultimap</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>ClassToInstanceMap</td>
<td>Guava</td>
<td>ImmutableClassToInstanceMap</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>ImmutableTable</td>
</tr>
</tbody>
</table>
<h2 id="lists">Lists</h2>
<pre><code class="language-java">private Lists() {
}
</code></pre>
<p>私有的构造方法，可以看到这是一个真正的功能函数，下面对其函数进行分析</p>
<h3 id="功能函数">功能函数</h3>
<p>首先根据每一个函数的更能进行了分类：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建ArrayList方法</td>
<td>1、newArrayList()<br>2、newArrayList(E... elements)<br>3、newArrayList(Iterable&lt;? extends E&gt; elements)<br>4、newArrayList(Iterator&lt;? extends E&gt; elements)<br>5、newArrayListWithCapacity(int initialArraySize)<br>6、newArrayListWithExpectedSize(int estimatedSize)</td>
</tr>
<tr>
<td>创建LinkedList方法</td>
<td>1、newLinkedList()<br>2、newLinkedList(Iterable&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建CopyOnWriteArrayList方法</td>
<td>1、newCopyOnWriteArrayList()<br>2、newCopyOnWriteArrayList(Iterable&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建自制List规则</td>
<td>1、asList(@Nullable E first, E[] rest)<br>2、asList(@Nullable E first, @Nullable E second, E[] rest)</td>
</tr>
<tr>
<td>List笛卡尔乘积</td>
<td>1、cartesianProduct(List&lt;? extends List&lt;? extends B&gt;&gt; lists)<br>2、cartesianProduct(List&lt;? extends B&gt;... lists)</td>
</tr>
<tr>
<td>List变形</td>
<td>transform(List&lt;F&gt; fromList, Function&lt;? super F, ? extends T&gt; function)</td>
</tr>
<tr>
<td>分割list（作用之一：分页）</td>
<td>partition(List&lt;T&gt; list, int size)</td>
</tr>
<tr>
<td>将字符串作为字符数组进行操作</td>
<td>1、charactersOf(String string)<br>2、charactersOf(CharSequence sequence)</td>
</tr>
<tr>
<td>将list逆序</td>
<td>reverse(List&lt;T&gt; list)</td>
</tr>
</tbody>
</table>
<h3 id="创建arraylist方法">创建ArrayList方法</h3>
<ol>
<li>
<p>没有参数的创建ArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList() {
    return new ArrayList();//直接返回一个新的ArrayList容器
}
</code></pre>
</li>
<li>
<p>传入一个数组，返回一个ArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList(E... elements) {
    //对数组进行判空处理
    Preconditions.checkNotNull(elements);
    // computeArrayListCapacity对当前数量进行优化
    int capacity = computeArrayListCapacity(elements.length);
    //这里根据优化后的数量进行创建一个新的ArrayList
    ArrayList list = new ArrayList(capacity);
    //将数组里面的元素都存储在List中
    Collections.addAll(list, elements);
    return list;
}

//目的是为了给定一个期望的元素数量（arraySize），计算出为了避免或减少动态扩容带来的开销，列表初始化时应该分配的容量
@VisibleForTesting
static int computeArrayListCapacity(int arraySize) {
    //确保arraySize非负数
    CollectPreconditions.checkNonnegative(arraySize, "arraySize");
    //确保最后的数值在 int范围内
    return Ints.saturatedCast(5L + (long)arraySize + (long)(arraySize / 10));
}
</code></pre>
</li>
<li>
<p>传入一个集合顶级接口，然后返回一个ArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList(Iterable&lt;? extends E&gt; elements) {
    //对集合进行判空
    Preconditions.checkNotNull(elements);
    //根据传入的实际类型，进行分别处理
    return elements instanceof Collection ? new ArrayList(Collections2.cast(elements)):newArrayList((Iterator)elements.
iterator());
}
</code></pre>
</li>
<li>
<p>传入一个迭代器，返回一个ArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList(Iterator&lt;? extends E&gt; elements) {
    ArrayList list = newArrayList();
    //根据Iterators中的addAll方法将迭代器中的源码装入list集合中
    Iterators.addAll(list, elements);
    return list;
}
</code></pre>
</li>
<li>
<p>传入想要的list长度，返回一个与传入值等长的ArrayList</p>
<pre><code class="language-java">//直接返回一个新的ArrayList，并且长度为传入的长度
public static &lt;E&gt; ArrayList&lt;E&gt; newArrayListWithCapacity(int initialArraySize) {
    CollectPreconditions.checkNonnegative(initialArraySize, "initialArraySize");
    return new ArrayList(initialArraySize);
}
</code></pre>
</li>
<li>
<p>传入一个想要的list长度，返回一个程序调优后的长度的ArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayListWithExpectedSize(int estimatedSize) {
    return new ArrayList(computeArrayListCapacity(estimatedSize));//返回一个长度调优后的ArrayList
}
</code></pre>
</li>
</ol>
<h3 id="创建linkedlist方法">创建LinkedList方法</h3>
<ol>
<li>
<p>不传入参数，直接返回一个LinkedList</p>
<pre><code class="language-java">public static &lt;E&gt; LinkedList&lt;E&gt; newLinkedList() {
    return new LinkedList();//直接返回一个LinkedList
}
</code></pre>
</li>
<li>
<p>传入一个容器，返回一个LinkedList</p>
<pre><code class="language-java">public static &lt;E&gt; LinkedList&lt;E&gt; newLinkedList(Iterable&lt;? extends E&gt; elements) {
    LinkedList list = newLinkedList();
    //将传入的容器，使用Iterables的addAll方法进行的数据转移
    Iterables.addAll(list, elements);
    return list;
}
</code></pre>
</li>
</ol>
<h3 id="创建copyonwritearraylist方法">创建CopyOnWriteArrayList方法</h3>
<ol>
<li>
<p>不传入参数，直接返回一个新的CopyOnWriteArrayList</p>
<pre><code class="language-java">public static &lt;E&gt; CopyOnWriteArrayList&lt;E&gt; newCopyOnWriteArrayList() {
    return new CopyOnWriteArrayList();//直接返回一个新的CopyOnWriteArrayList
}
</code></pre>
</li>
<li>
<p>传入一个容器，返回一个CopyOnWriteArrayList，带有传入容器的值</p>
<pre><code class="language-java">public static &lt;E&gt; CopyOnWriteArrayList&lt;E&gt; newCopyOnWriteArrayList(Iterable&lt;? extends E&gt; elements) {
    Object elementsCollection = elements instanceof Collection?Collections2.cast(elements):newArrayList((Iterable)elements);
    return new CopyOnWriteArrayList((Collection)elementsCollection);
}
</code></pre>
</li>
</ol>
<h3 id="创建自制list规则">创建自制List规则</h3>
<p>使用案例：</p>
<pre><code class="language-java">String leader = "leader";
String[] members = {"member1", "member2", "member3"};

List&lt;String&gt; group = Lists.asList(leader, members);
System.out.println(group);
</code></pre>
<p>这样做的一个好处是可以提高代码的可读性，因为它明确地区分了 "leader" 和 "members"，而不是将它们混在一起。而且，如果 "members" 是动态确定的（例如，它们来自另一个方法或计算结果），那么这个 <code>asList</code> 方法将比手动创建 <code>List</code> 并添加元素更为方便。</p>
<p><strong>注意</strong>：asList返回的是视图，也就是说，原容器的变更会影响这些方法返回的容器内容</p>
<ol>
<li>
<p>根据参数生成一个多一个参数的List</p>
<pre><code class="language-java">public static &lt;E&gt; List&lt;E&gt; asList(@Nullable E first, E[] rest) {
    return new Lists.OnePlusArrayList(first, rest);//返回一个Lists中的内部类OnePlusArrayList
}

private static class OnePlusArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Serializable, RandomAccess {
    final E first;
    final E[] rest;
    private static final long serialVersionUID = 0L;
 
    OnePlusArrayList(@Nullable E first, E[] rest) {
        this.first = first;
        this.rest = (Object[])Preconditions.checkNotNull(rest);
    }
 
    // 重写了size和get方法
    // 因为是比原来数组多1个数，所以size方法在原来的基础上进行了+1操作。
    public int size() {
        return this.rest.length + 1;
    }
 
    //对get的重写是将所有的下标逻辑上后移了一位。
    public E get(int index) {
        Preconditions.checkElementIndex(index, this.size());
        return index == 0 ? this.first:this.rest[index - 1];
    }
}
</code></pre>
</li>
<li>
<p>根据参数生成一个多两个个参数的List</p>
<pre><code class="language-java">public static &lt;E&gt; List&lt;E&gt; asList(@Nullable E first, @Nullable E second, E[] rest) {
    return new Lists.TwoPlusArrayList(first, second, rest);//返回一个Lists中的内部类TwoPlusArrayList
}

private static class TwoPlusArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Serializable, RandomAccess {
    final E first;
    final E second;
    final E[] rest;
    private static final long serialVersionUID = 0L;
 
    TwoPlusArrayList(@Nullable E first, @Nullable E second, E[] rest) {
        this.first = first;
        this.second = second;
        this.rest = (Object[])Preconditions.checkNotNull(rest);
    }
 
    // 重写了size和get两个方法，size在实际数组长度上进行了+2的操作
    public int size() {
        return this.rest.length + 2;
    }
 
    //get则在逻辑上将下标进行了后移两位
    public E get(int index) {
        switch(index) {
        case 0:
            return this.first;
        case 1:
            return this.second;
        default:
            Preconditions.checkElementIndex(index, this.size());
            return this.rest[index - 2];
        }
    }
} 
</code></pre>
</li>
</ol>
<h3 id="list笛卡尔乘积">List笛卡尔乘积</h3>
<pre><code class="language-java">public static &lt;B&gt; List&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends List&lt;? extends B&gt;&gt; lists) {
    return CartesianList.create(lists);
}

//整个方法的逻辑是将输入的一组列表转换成一个表示它们所有可能组合（笛卡尔积）的列表结构，同时确保输入列表的不可变性。
//这种方法在需要处理多维数据组合时特别有用，例如在配置管理、测试用例生成等应用场景中。
static &lt;E&gt; List&lt;List&lt;E&gt;&gt; create(List&lt;? extends List&lt;? extends E&gt;&gt; lists) {
    ImmutableList.Builder&lt;List&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder(lists.size());
    Iterator var2 = lists.iterator();

    while(var2.hasNext()) {
        List&lt;? extends E&gt; list = (List)var2.next();
        List&lt;E&gt; copy = ImmutableList.copyOf(list);
        if (copy.isEmpty()) {
            //如果任意一个子列表为空，则整个笛卡尔积列表也应为空（因为任何东西与空集的笛卡尔积都是空集），因此直接返回一个空的不可变列表。
            return ImmutableList.of();
        }

        axesBuilder.add(copy);
    }

    return new CartesianList(axesBuilder.build());
}
</code></pre>
<h3 id="list变形">List变形</h3>
<p>使用案例：</p>
<pre><code class="language-java">List&lt;String&gt; stringList = Arrays.asList("1", "2", "3");
List&lt;Integer&gt; integerList = transform(stringList, s -&gt; Integer.parseInt(s));
</code></pre>
<p>源码：</p>
<pre><code class="language-java">public static &lt;F, T&gt; List&lt;T&gt; transform(List&lt;F&gt; fromList, Function&lt;? super F, ? extends T&gt; function) {
    //依据 fromList 是否支持随机访问（例如 ArrayList），来决定使用哪种内部实现方式，以提高效率。
    //不过无论使用哪种方式进行处理，在他们的实现类中都重写了listIterator方法
    return (List)(fromList instanceof RandomAccess?new Lists.TransformingRandomAccessList(fromList, function):new Lists.TransformingSequentialList(fromList, function));
}


private static class TransformingRandomAccessList&lt;F, T&gt; extends AbstractList&lt;T&gt; implements RandomAccess, Serializable {
    final List&lt;F&gt; fromList;
    final Function&lt;? super F, ? extends T&gt; function;
    private static final long serialVersionUID = 0L;
 
    TransformingRandomAccessList(List&lt;F&gt; fromList, Function&lt;? super F, ? extends T&gt; function) {
        this.fromList = (List)Preconditions.checkNotNull(fromList);
        this.function = (Function)Preconditions.checkNotNull(function);
    }
    public ListIterator&lt;T&gt; listIterator(int index) {
        //当通过 listIterator 方法获取迭代器时，实际上是获取了原始列表 fromList 的迭代器，并将其包装在 TransformedListIterator 中。
		//每次迭代时，TransformedListIterator 会调用 transform 方法，该方法使用 function 将原始列表中的元素转换为目标类型 T。
        return new TransformedListIterator(this.fromList.listIterator(index)) {
            T transform(F from) {
                return TransformingRandomAccessList.this.function.apply(from);
            }
        };
    }
}
</code></pre>
<h3 id="分割list作用之一分页">分割list（作用之一：分页）</h3>
<pre><code class="language-java">// 程序根据传入的List进行分类处理
public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; list, int size) {
    Preconditions.checkNotNull(list);
    Preconditions.checkArgument(size &gt; 0);
    return (List)(list instanceof RandomAccess?new Lists.RandomAccessPartition(list, size):new Lists.Partition(list, size));
}
</code></pre>
<p>这里的RandomAccessPartition是Partition的子类，且RandomAccessPartition对其的处理是直接调用了父类的方法，所以我们只需要解析Partition类就可以了</p>
<pre><code class="language-java">private static class Partition&lt;T&gt; extends AbstractList&lt;List&lt;T&gt;&gt; {
    final List&lt;T&gt; list;
    final int size;
    Partition(List&lt;T&gt; list, int size) {
        this.list = list;
        this.size = size;
    }
    //get方法进行了截取操作，而它的截取底层是subList实现的。它所get的下标为第几组List
    public List&lt;T&gt; get(int index) {
        Preconditions.checkElementIndex(index, this.size());
        int start = index * this.size;
        int end = Math.min(start + this.size, this.list.size());
        return this.list.subList(start, end);
    }
    public int size() {
        return IntMath.divide(this.list.size(), this.size, RoundingMode.CEILING);
    }
    public boolean isEmpty() {
        return this.list.isEmpty();
    }
}
</code></pre>
<h3 id="将字符串作为字符数组进行操作">将字符串作为字符数组进行操作</h3>
<p>主要用于将一个字符串转换为一个不可变的 <code>List&lt;Character&gt;</code>，使得字符串的字符可以像列表元素一样进行操作。</p>
<pre><code class="language-java">//两个方法分别接收字符串和CharSequence作为参数，将参数传入CharSequenceAsList类中进行处理：
public static ImmutableList&lt;Character&gt; charactersOf(String string) {
    return new Lists.StringAsImmutableList((String)Preconditions.checkNotNull(string));
}
public static List&lt;Character&gt; charactersOf(CharSequence sequence) {
    return new Lists.CharSequenceAsList((CharSequence)Preconditions.checkNotNull(sequence));
}
</code></pre>
<pre><code class="language-java">//实际上就是对间接使用String类中的方法进行处理字符串
private static final class StringAsImmutableList extends ImmutableList&lt;Character&gt; {
    private final String string;
 
    StringAsImmutableList(String string) {
        this.string = string;
    }
 
    public int indexOf(@Nullable Object object) {
        return object instanceof Character?this.string.indexOf(((Character)object).charValue()):-1;
    }
 
    public int lastIndexOf(@Nullable Object object) {
        return object instanceof Character?this.string.lastIndexOf(((Character)object).charValue()):-1;
    }
 
    public ImmutableList&lt;Character&gt; subList(int fromIndex, int toIndex) {
        Preconditions.checkPositionIndexes(fromIndex, toIndex, this.size());
        return Lists.charactersOf((String)this.string.substring(fromIndex, toIndex));
    }
 
    boolean isPartialView() {
        return false;
    }
 
    public Character get(int index) {
        Preconditions.checkElementIndex(index, this.size());
        return Character.valueOf(this.string.charAt(index));
    }
 
    public int size() {
        return this.string.length();
    }
}
</code></pre>
<h3 id="list逆序">list逆序</h3>
<pre><code class="language-java">public static &lt;T&gt; List&lt;T&gt; reverse(List&lt;T&gt; list) {
    if (list instanceof ImmutableList) {
        List&lt;?&gt; reversed = ((ImmutableList)list).reverse();
        List&lt;T&gt; result = reversed;
        return result;
    } else if (list instanceof ReverseList) {
        return ((ReverseList)list).getForwardList();
    } else {
        return (List)(list instanceof RandomAccess ? new RandomAccessReverseList(list) : new ReverseList(list));
    }
}
</code></pre>
<p>实际上调用了ImmutableList类的reverse方法进行处理的逆序</p>
<h2 id="maps">Maps</h2>
<pre><code class="language-java">private Maps() {
}
</code></pre>
<p>私有的构造方法，可以看到这是一个真正的功能函数，下面对其函数进行分析</p>
<h3 id="功能函数-1">功能函数</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建EnumMap</td>
<td>1、EnumMap&lt;K, V&gt; newEnumMap(Class&lt;K&gt; type)<br>2、EnumMap&lt;K, V&gt; newEnumMap(Map&lt;K, ? extends V&gt; map)</td>
</tr>
<tr>
<td>返回不可变EnumMap</td>
<td>ImmutableMap&lt;K, V&gt; immutableEnumMap(Map&lt;K, ? extends V&gt; map)</td>
</tr>
<tr>
<td>创建HashMap</td>
<td>1、HashMap&lt;K, V&gt; newHashMap()<br>2、HashMap&lt;K, V&gt; newHashMapWithExpectedSize(int expectedSize)<br>3、HashMap&lt;K, V&gt; newHashMap(Map&lt;? extends K, ? extends V&gt; map)</td>
</tr>
<tr>
<td>创建LinkedHashMap</td>
<td>1、LinkedHashMap&lt;K, V&gt; newLinkedHashMap()<br>2、LinkedHashMap&lt;K, V&gt; newLinkedHashMap(Map&lt;? extends K, ? extends V&gt; map)</td>
</tr>
<tr>
<td>创建ConcurrentMap</td>
<td>ConcurrentMap&lt;K, V&gt; newConcurrentMap()</td>
</tr>
<tr>
<td>创建TreeMap</td>
<td>1、TreeMap&lt;K, V&gt; newTreeMap()<br>2、TreeMap&lt;K, V&gt; newTreeMap(SortedMap&lt;K, ? extends V&gt; map)<br>3、TreeMap&lt;K, V&gt; newTreeMap(@Nullable Comparator&lt;C&gt; comparator)</td>
</tr>
<tr>
<td>创建IdentityHashMap</td>
<td>IdentityHashMap&lt;K, V&gt; newIdentityHashMap()</td>
</tr>
<tr>
<td>获取两个Map中不同元素的值</td>
<td>1、MapDifference&lt;K, V&gt; difference(Map&lt;? extends K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right)<br>2、MapDifference&lt;K, V&gt; difference(Map&lt;? extends K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right, Equivalence&lt;? super V&gt; valueEquivalence)<br>3、SortedMapDifference&lt;K, V&gt; difference(SortedMap&lt;K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right)</td>
</tr>
<tr>
<td>根据函数和set，构造Map</td>
<td>1、Map&lt;K, V&gt; asMap(Set&lt;K&gt; set, Function&lt;? super K, V&gt; function)<br>2、SortedMap&lt;K, V&gt; asMap(SortedSet&lt;K&gt; set, Function&lt;? super K, V&gt; function)<br>3、NavigableMap&lt;K, V&gt; asMap(NavigableSet&lt;K&gt; set, Function&lt;? super K, V&gt; function)</td>
</tr>
<tr>
<td>根据函数和迭代器，构造不可变的Map</td>
<td>1、ImmutableMap&lt;K, V&gt; toMap(Iterator&lt;K&gt; keys, Function&lt;? super K, V&gt; valueFunction)<br>2、ImmutableMap&lt;K, V&gt; toMap(Iterator&lt;K&gt; keys, Function&lt;? super K, V&gt; valueFunction)<br>3、ImmutableMap&lt;K, V&gt; uniqueIndex(Iterable&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction)<br>4、ImmutableMap&lt;K, V&gt; uniqueIndex(Iterator&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction)</td>
</tr>
<tr>
<td>从配置文件中读取数据，创建不可变的Map</td>
<td>ImmutableMap&lt;String, String&gt; fromProperties(Properties properties)</td>
</tr>
<tr>
<td>返回Entry或Entry集合</td>
<td>1、Entry&lt;K, V&gt; immutableEntry(@Nullable K key, @Nullable V value)<br>2、Set&lt;Entry&lt;K, V&gt;&gt; unmodifiableEntrySet(Set&lt;Entry&lt;K, V&gt;&gt; entrySet)<br>3、Entry&lt;K, V&gt; unmodifiableEntry(final Entry&lt;? extends K, ? extends V&gt; entry)</td>
</tr>
<tr>
<td>返回特殊的BiMap类</td>
<td>1、BiMap&lt;K, V&gt; synchronizedBiMap(BiMap&lt;K, V&gt; bimap)<br>2、BiMap&lt;K, V&gt; unmodifiableBiMap(BiMap&lt;? extends K, ? extends V&gt; bimap)</td>
</tr>
<tr>
<td>根据Map和函数对Map进行转型</td>
<td>1、Map&lt;K, V2&gt; transformValues(Map&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function)<br>2、SortedMap&lt;K, V2&gt; transformValues(SortedMap&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function)<br>3、NavigableMap&lt;K, V2&gt; transformValues(NavigableMap&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function)<br>4、Map&lt;K, V2&gt; transformEntries(Map&lt;K, V1&gt; fromMap, Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer)<br>5、SortedMap&lt;K, V2&gt; transformEntries(SortedMap&lt;K, V1&gt; fromMap, Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer)<br>6、NavigableMap&lt;K, V2&gt; transformEntries(NavigableMap&lt;K, V1&gt; fromMap, Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer)</td>
</tr>
<tr>
<td>使用函数进行过滤Map，然后返回同类型的Map</td>
<td>分为4种过滤<br>一、针对Key进行过滤<br>1.Map&lt;K, V&gt; filterKeys(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate)<br>2.SortedMap&lt;K, V&gt; filterKeys(SortedMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate)<br>3.NavigableMap&lt;K, V&gt; filterKeys(NavigableMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate)<br>4.BiMap&lt;K, V&gt; filterKeys(BiMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate)<br>二、针对Value进行过滤<br>1.Map&lt;K, V&gt; filterValues(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super V&gt; valuePredicate)<br>2.SortedMap&lt;K, V&gt; filterValues(SortedMap&lt;K, V&gt; unfiltered, Predicate&lt;? super V&gt; valuePredicate)<br>3.NavigableMap&lt;K, V&gt; filterValues(NavigableMap&lt;K, V&gt; unfiltered, Predicate&lt;? super V&gt; valuePredicate)<br>4.BiMap&lt;K, V&gt; filterValues(BiMap&lt;K, V&gt; unfiltered, Predicate&lt;? super V&gt; valuePredicate)<br>三、针对Entry进行过滤<br>1.Map&lt;K, V&gt; filterEntries(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>2.SortedMap&lt;K, V&gt; filterEntries(SortedMap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>3.SortedMap&lt;K, V&gt; filterSortedIgnoreNavigable(SortedMap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>4.NavigableMap&lt;K, V&gt; filterEntries(NavigableMap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>5.BiMap&lt;K, V&gt; filterEntries(BiMap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>四、为含有过滤规则的Map进行过滤<br>1.Map&lt;K, V&gt; filterFiltered(Maps.AbstractFilteredMap&lt;K, V&gt; map, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>2.SortedMap&lt;K, V&gt; filterFiltered(Maps.FilteredEntrySortedMap&lt;K, V&gt; map, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>3.NavigableMap&lt;K, V&gt; filterFiltered(Maps.FilteredEntryNavigableMap&lt;K, V&gt; map, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)<br>4.BiMap&lt;K, V&gt; filterFiltered(Maps.FilteredEntryBiMap&lt;K, V&gt; map, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate)</td>
</tr>
</tbody>
</table>
<h3 id="创建enummap">创建EnumMap</h3>
<ol>
<li>
<p>传入一个Class变量，返回一个EnumMap</p>
<pre><code class="language-java">public static &lt;K extends Enum&lt;K&gt;, V&gt; EnumMap&lt;K, V&gt; newEnumMap(Class&lt;K&gt; type) {
    return new EnumMap((Class)Preconditions.checkNotNull(type));
}
</code></pre>
</li>
<li>
<p>传入一个Map变量，返回一个EnumMap</p>
<pre><code class="language-java">public static &lt;K extends Enum&lt;K&gt;, V&gt; EnumMap&lt;K, V&gt; newEnumMap(Map&lt;K, ? extends V&gt; map) {
    return new EnumMap(map);
}

//java.util.EnumMap#EnumMap(java.util.Map&lt;K,? extends V&gt;)
public EnumMap(Map&lt;K, ? extends V&gt; m) {
    if (m instanceof EnumMap) {
        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;
        keyType = em.keyType;
        keyUniverse = em.keyUniverse;
        vals = em.vals.clone();
        size = em.size;
    } else {
        if (m.isEmpty())
            throw new IllegalArgumentException("Specified map is empty");
        keyType = m.keySet().iterator().next().getDeclaringClass();
        keyUniverse = getKeyUniverse(keyType);
        vals = new Object[keyUniverse.length];
        //对于传入的Map赋值给新的EnumMap步骤就由EnumMap的putAll方法进行操作了。
        putAll(m);
    }
}
</code></pre>
</li>
</ol>
<h3 id="返回不可变enummap">返回不可变EnumMap</h3>
<p>传入一个Map，返回一个不可变的Map容器</p>
<pre><code class="language-java">public static &lt;K extends Enum&lt;K&gt;, V&gt; ImmutableMap&lt;K, V&gt; immutableEnumMap(Map&lt;K, ? extends V&gt; map) {
    if(map instanceof ImmutableEnumMap) {
        //如果map为ImmutableEnumMap类型，直接强转为ImmutableEnumMap类型的容器
        ImmutableEnumMap&lt;K, V&gt; result = (ImmutableEnumMap)map;
        return result;
    } else  {
        Iterator&lt;? extends Map.Entry&lt;K, ? extends V&gt;&gt; entryItr = map.entrySet().iterator();
        if (!entryItr.hasNext()) {
            //如果map为空，则直接返回新建的空的ImmutableMap容器
            return ImmutableMap.of();
        } else {
            Map.Entry&lt;K, ? extends V&gt; entry1 = (Map.Entry)entryItr.next();
            K key1 = (Enum)entry1.getKey();
            V value1 = entry1.getValue();
            CollectPreconditions.checkEntryNotNull(key1, value1);
            Class&lt;K&gt; clazz = key1.getDeclaringClass();
            EnumMap&lt;K, V&gt; enumMap = new EnumMap(clazz);
            enumMap.put(key1, value1);

            while(entryItr.hasNext()) {
                Map.Entry&lt;K, ? extends V&gt; entry = (Map.Entry)entryItr.next();
                K key = (Enum)entry.getKey();
                V value = entry.getValue();
                //key和value都不能为null
                CollectPreconditions.checkEntryNotNull(key, value);
                enumMap.put(key, value);
            }
			
            //以上成立，则直接使用ImmutableEnumMap中函数为map进行转换
            return ImmutableEnumMap.asImmutable(enumMap);
        }
    }
}
</code></pre>
<h3 id="创建hashmap">创建HashMap</h3>
<ol>
<li>
<p>直接返回一个新的HashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap() {
    return new HashMap();
}
</code></pre>
</li>
<li>
<p>返回一个有初始长度的HashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMapWithExpectedSize(int expectedSize) {
    return new HashMap(capacity(expectedSize));
}

//根据传入的长度，返回一个实际可用expectedSize的HashMap，capacity方法就是计算实际长度的一个方法
static int capacity(int expectedSize) {
    if(expectedSize &lt; 3) {
        CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
        return expectedSize + 1;
    } else {
        // 假设传入的是8，返回的就是8/0.75 + 1 = 11，根据HashMap的原则，会扩容成16。所以这里考虑的是什么？为什么这么设置
        return expectedSize &lt; 1073741824 ? (int)((float)expectedSize / 0.75F + 1.0F) : Integer.MAX_VALUE;
    }
}
</code></pre>
<blockquote>
<p>这里为什么是 0.75这个系数呢？</p>
</blockquote>
</li>
<li>
<p>传入一个Map型变量，返回一个HashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap(Map&lt;? extends K, ? extends V&gt; map) {
    return new HashMap(map);//这个步骤就由HashMap的putMapEntries方法进行操作了
}
</code></pre>
</li>
</ol>
<h3 id="创建linkedhashmap">创建LinkedHashMap</h3>
<ol>
<li>
<p>直接返回一个新的LinkedHashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; newLinkedHashMap() {
    return new LinkedHashMap();
}
</code></pre>
</li>
<li>
<p>传入一个Map变量，返回一个LinkedHashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; newLinkedHashMap(Map&lt;? extends K, ? extends V&gt; map) {
    return new LinkedHashMap(map);//这个步骤就由LinkedHashMap的putMapEntries方法进行操作了。
}
</code></pre>
</li>
</ol>
<h3 id="创建concurrentmap">创建ConcurrentMap</h3>
<p>直接返回一个新的ConcurrentMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; ConcurrentMap&lt;K, V&gt; newConcurrentMap() {
    return new ConcurrentHashMap();
}
</code></pre>
<h3 id="创建treemap">创建TreeMap</h3>
<ol>
<li>
<p>直接返回一个新的TreeMap</p>
<pre><code class="language-java">public static &lt;K extends Comparable, V&gt; TreeMap&lt;K, V&gt; newTreeMap() {
    return new TreeMap();
}
</code></pre>
</li>
<li>
<p>传入一个Map变量，返回一个TreeMap，并将Map的值赋值给TreeMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; TreeMap&lt;K, V&gt; newTreeMap(SortedMap&lt;K, ? extends V&gt; map) {
    return new TreeMap(map);
}
</code></pre>
</li>
<li>
<p>传入一个比较接口，返回一个根据传入的比较规则形成的TreeMap</p>
<pre><code class="language-java">public static &lt;C, K extends C, V&gt; TreeMap&lt;K, V&gt; newTreeMap(@Nullable Comparator&lt;C&gt; comparator) {
    return new TreeMap(comparator);
}
</code></pre>
</li>
</ol>
<h3 id="创建identityhashmap">创建IdentityHashMap</h3>
<p>直接返回一个identityHashMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; IdentityHashMap&lt;K, V&gt; newIdentityHashMap() {
    return new IdentityHashMap();
}
</code></pre>
<p>IdentityHashMap与HashMap不同之处在于可以存入相同类的相同值，实际上他在put里的添加操作是不是使用equals而是用的==进行判断的</p>
<h3 id="获取两个map中不同元素的值">获取两个Map中不同元素的值</h3>
<p>在说明Maps中这三个方法之前，先了解一下MapDifference接口和的实现类MapDifferenceImpl可以表现什么吧：</p>
<pre><code class="language-java">public interface MapDifference&lt;K, V&gt; {
    boolean areEqual();
    Map&lt;K, V&gt; entriesOnlyOnLeft();
    Map&lt;K, V&gt; entriesOnlyOnRight();
    Map&lt;K, V&gt; entriesInCommon();
    Map&lt;K, ValueDifference&lt;V&gt;&gt; entriesDiffering();
    boolean equals(@CheckForNull Object var1);
    int hashCode();

    @DoNotMock("Use Maps.difference")
    public interface ValueDifference&lt;V&gt; {
        @ParametricNullness
        V leftValue();
        @ParametricNullness
        V rightValue();
        
        boolean equals(@CheckForNull Object var1);
        int hashCode();
    }
}

static class MapDifferenceImpl&lt;K, V&gt; implements MapDifference&lt;K, V&gt; {
    final Map&lt;K, V&gt; onlyOnLeft;
    final Map&lt;K, V&gt; onlyOnRight;
    final Map&lt;K, V&gt; onBoth;
    final Map&lt;K, ValueDifference&lt;V&gt;&gt; differences;
 
    MapDifferenceImpl(Map&lt;K, V&gt; onlyOnLeft, Map&lt;K, V&gt; onlyOnRight, Map&lt;K, V&gt; onBoth, Map&lt;K, ValueDifference&lt;V&gt;&gt; differences) {
        this.onlyOnLeft = Maps.unmodifiableMap(onlyOnLeft);
        this.onlyOnRight = Maps.unmodifiableMap(onlyOnRight);
        this.onBoth = Maps.unmodifiableMap(onBoth);
        this.differences = Maps.unmodifiableMap(differences);
    }
    
    public boolean areEqual() {
        return this.onlyOnLeft.isEmpty() &amp;&amp; this.onlyOnRight.isEmpty() &amp;&amp; this.differences.isEmpty();
    }
    public Map&lt;K, V&gt; entriesOnlyOnLeft() {return this.onlyOnLeft; }
    public Map&lt;K, V&gt; entriesOnlyOnRight() {return this.onlyOnRight; }
    public Map&lt;K, V&gt; entriesInCommon() {return this.onBoth; }
    public Map&lt;K, ValueDifference&lt;V&gt;&gt; entriesDiffering() { return this.differences; }
    
    //equals等其它方法...
}
</code></pre>
<p>可以看到 MapDifferenceImpl 实现类中有4个变量</p>
<ul>
<li>onlyOnLeft只存变量名为left的Map中独有的；</li>
<li>onlyOnRight只存变量名为right的Map中独有的；</li>
<li>onBoth存储两个map中共有的key并且value也相等的元素；</li>
<li>differences因为value存储的类型为ValueDifference，differences中存储的是共有的key并且value不同的元素</li>
</ul>
<ol>
<li>
<p>传入两个Map变量，根据left变量名的Map的类型进行判断交给哪个difference方法去处理</p>
<pre><code class="language-java">public static &lt;K, V&gt; MapDifference&lt;K, V&gt; difference(Map&lt;? extends K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right) {
    if(left instanceof SortedMap) {
        SortedMap&lt;K, ? extends V&gt; sortedLeft = (SortedMap)left;
        return difference(sortedLeft, right);
    } else {
        MapDifference&lt;K, V&gt; result = difference(left, right, Equivalence.equals());
        return result;
    }
}
</code></pre>
</li>
<li>
<p>传入两个Map，使用doDifference方法将两个Map中的元素进行分类</p>
<pre><code class="language-java">public static &lt;K, V&gt; MapDifference&lt;K, V&gt; difference(Map&lt;? extends K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right, Equivalence&lt;? super V&gt; valueEquivalence) {
    Preconditions.checkNotNull(valueEquivalence);
    HashMap onlyOnLeft = newHashMap();
    HashMap onlyOnRight = new HashMap(right);
    HashMap onBoth = newHashMap();
    Map&lt;K, MapDifference.ValueDifference&lt;V&gt;&gt; differences = newLinkedHashMap();
    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);
    return new Maps.MapDifferenceImpl(onlyOnLeft, onlyOnRight, onBoth, differences);
}

private static &lt;K, V&gt; void doDifference(Map&lt;? extends K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right, Equivalence&lt;? super V&gt; valueEquivalence, Map&lt;K, V&gt; onlyOnLeft, Map&lt;K, V&gt; onlyOnRight, Map&lt;K, V&gt; onBoth, Map&lt;K, MapDifference.ValueDifference&lt;V&gt;&gt; differences) {
    Iterator var7 = left.entrySet().iterator();

    //对left进行遍历操作
    while(var7.hasNext()) {
        Map.Entry&lt;? extends K, ? extends V&gt; entry = (Map.Entry)var7.next();
        K leftKey = entry.getKey();
        V leftValue = entry.getValue();
        //查看right中是否包括这个key值
        if (right.containsKey(leftKey)) {
            //如果right中也包括这个key值，则将这个值在right中去除
            V rightValue = NullnessCasts.uncheckedCastNullableTToT(onlyOnRight.remove(leftKey));
            //判断这个key值的left和right的value值是否相等
            if (valueEquivalence.equivalent(leftValue, rightValue)) {
                //如果两个value值相等，将其填入onBoth的Map容器中
                onBoth.put(leftKey, leftValue);
            } else {
                //如果两个value值不相等，将其填入differences的Map容器中
                differences.put(leftKey, Maps.ValueDifferenceImpl.create(leftValue, rightValue));
            }
        } else {
            //如果这个key在right中不存在，则将其填入onlyOnLeft容器中
            onlyOnLeft.put(leftKey, leftValue);
        }
    }
}
</code></pre>
</li>
<li>
<p>传入一个SortedMap和一个Map变量，返回一个分类后的类</p>
<pre><code class="language-java">public static &lt;K, V&gt; SortedMapDifference&lt;K, V&gt; difference(SortedMap&lt;K, ? extends V&gt; left, Map&lt;? extends K, ? extends V&gt; right) {
    Preconditions.checkNotNull(left);
    Preconditions.checkNotNull(right);
    Comparator&lt;? super K&gt; comparator = orNaturalOrder(left.comparator());
    SortedMap&lt;K, V&gt; onlyOnLeft = newTreeMap(comparator);
    SortedMap&lt;K, V&gt; onlyOnRight = newTreeMap(comparator);
    onlyOnRight.putAll(right);
    SortedMap&lt;K, V&gt; onBoth = newTreeMap(comparator);
    SortedMap&lt;K, MapDifference.ValueDifference&lt;V&gt;&gt; differences = newTreeMap(comparator);
    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);
    return new SortedMapDifferenceImpl(onlyOnLeft, onlyOnRight, onBoth, differences);
}
</code></pre>
</li>
</ol>
<h3 id="根据函数和set构造map">根据函数和set，构造Map</h3>
<p>这个方法展示了如何将一个<code>Set</code>和一个<code>Function</code> 结合起来，创建一个视图（view），这个视图在每次查询时通过应用函数来动态生成键值对。</p>
<ol>
<li><strong>视图特性</strong>：<code>AsMapView</code>创建的是一个视图，而不是一个独立的新集合。这意味着原始集合（<code>Set</code>）的任何修改都会反映在<code>AsMapView</code>中，反之亦然。这种行为类似于如何通过<code>Collections.unmodifiableList()</code>方法得到的不可修改的视图，但<code>AsMapView</code>是可修改的，其修改会影响到原始的集合。</li>
<li><strong>延迟加载</strong>：<code>AsMapView</code>在实际调用其<code>get()</code>方法之前不会计算键对应的值。这意味着如果你有一个非常昂贵的转换逻辑，它只有在实际需要该值时才会执行，这有助于提高效率。</li>
<li><strong>用途</strong>：这个类非常适合创建动态计算的映射，其中映射的值是依赖于键的，并且可能不希望提前计算所有可能的值。例如，可以用它来根据需要生成配置设置、进行数据转换等。</li>
<li><strong>实现</strong>：在内部，<code>AsMapView</code>使用了提供的<code>Set</code>和<code>Function</code>来实现<code>Map</code>接口。当调用<code>get(Object key)</code>时，如果<code>key</code>存在于集合中，则使用<code>Function</code>来计算值。</li>
</ol>
<p>使用案例：</p>
<pre><code class="language-java">//假设有一组产品ID，需要根据产品ID动态获取产品价格。价格计算可能依赖于多种因素，如商品的实时供需状况、促销活动等，这些都可以通过一个函数来实现：
Set&lt;Integer&gt; productIds = new HashSet&lt;&gt;();
productIds.add(1);
productIds.add(2);

Function&lt;Integer, Double&gt; priceFunction = productId -&gt; {
    // 假设这里进行一些复杂的计算来决定价格
    return productId * 10.0; // 简单的示例
};

Map&lt;Integer, Double&gt; priceMap = Maps.asMap(productIds, priceFunction);

System.out.println("Price of Product 1: " + priceMap.get(1));  // 输出 10.0
System.out.println("Price of Product 2: " + priceMap.get(2));  // 输出 20.0
</code></pre>
<p>方法介绍：</p>
<ol>
<li>
<p>传入一个set和一个规则，返回一个Map</p>
<pre><code class="language-java">public static &lt;K, V&gt; Map&lt;K, V&gt; asMap(Set&lt;K&gt; set, Function&lt;? super K, V&gt; function) {
    return new AsMapView(set, function);
}
</code></pre>
</li>
<li>
<p>传入一个SortedSet和一个规则，返回一个SortMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; SortedMap&lt;K, V&gt; asMap(SortedSet&lt;K&gt; set, Function&lt;? super K, V&gt; function) {
    return new SortedAsMapView(set, function);
}
</code></pre>
</li>
<li>
<p>传入一个NavigableSet和一个规则，返回一个NavigableMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; NavigableMap&lt;K, V&gt; asMap(NavigableSet&lt;K&gt; set, Function&lt;? super K, V&gt; function) {
    return new Maps.NavigableAsMapView(set, function);
}
</code></pre>
</li>
</ol>
<h3 id="根据函数和迭代器构造不可变的map">根据函数和迭代器，构造不可变的Map</h3>
<p>此类方法传入的是一个容器的迭代器和一个规则，然后返回一个不可变的Map容器</p>
<ol>
<li>
<p>传入一个key值容器和一个规则，直接交给重载函数去处理，返回一个不可变的Map容器</p>
<pre><code class="language-java">public static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; toMap(Iterable&lt;K&gt; keys, Function&lt;? super K, V&gt; valueFunction) {
    return toMap((Iterator)keys.iterator(), valueFunction);
}

</code></pre>
</li>
<li>
<p>传入一个key值迭代器和一个规则返回一个不可变的map容器</p>
<pre><code class="language-java">public static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; toMap(Iterator&lt;K&gt; keys, Function&lt;? super K, V&gt; valueFunction) {
    Preconditions.checkNotNull(valueFunction);
    LinkedHashMap builder = newLinkedHashMap();
    //使用迭代器中的值作为key值，使用规则计算出的值作为value值，存入builder中
    while(keys.hasNext()) {
        Object key = keys.next();
        builder.put(key, valueFunction.apply(key));
    }
    //返回一个不可变的容器
    return ImmutableMap.copyOf(builder);
}
</code></pre>
</li>
<li>
<p>根据value值容器和一个规则，直接交给重载函数去处理，返回一个不可变的Map容器</p>
<pre><code class="language-java">public static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; uniqueIndex(Iterable&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction) {
    return uniqueIndex((Iterator)values.iterator(), keyFunction);
}
</code></pre>
</li>
<li>
<p>传入一个value值迭代器和一个规则返回一个不可变的map容器</p>
<pre><code class="language-java">public static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; uniqueIndex(Iterator&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction) {
    Preconditions.checkNotNull(keyFunction);
    Builder builder = ImmutableMap.builder();
    //使用迭代器中的值作为value值，使用规则计算出的值作为key值，存入builder中
    while(values.hasNext()) {
        Object value = values.next();
        builder.put(keyFunction.apply(value), value);
    }
    //返回一个不可变的容器
    return builder.build();
}
</code></pre>
</li>
</ol>
<h3 id="从properties文件中读取数据创建不可变的map">从properties文件中读取数据，创建不可变的Map</h3>
<p>从Properties获取的key和value，返回一个不可变的Map</p>
<pre><code class="language-java">public static ImmutableMap&lt;String, String&gt; fromProperties(Properties properties) {
    Builder builder = ImmutableMap.builder();
    Enumeration e = properties.propertyNames();
    //从properties获取的key和value，赋值到builder中
    while(e.hasMoreElements()) {
        String key = (String)e.nextElement();
        builder.put(key, properties.getProperty(key));
    }
    //返回一个不可变的Map
    return builder.build();
}
</code></pre>
<h3 id="返回entry或entry集合">返回Entry或Entry集合</h3>
<p>传入一个key和一个value，返回一个不可变的Entry</p>
<pre><code class="language-java">public static &lt;K, V&gt; Entry&lt;K, V&gt; immutableEntry(@Nullable K key, @Nullable V value) {
    return new ImmutableEntry(key, value);
}
</code></pre>
<h3 id="返回特殊的bimap类">返回特殊的BiMap类</h3>
<p>Guava 提供了 BiMap 支持支持双向的映射关系，关于BiMap详情可以看后文</p>
<ol>
<li>
<p>传入一个BiMap返回一个线程安全的BiMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; BiMap&lt;K, V&gt; synchronizedBiMap(BiMap&lt;K, V&gt; bimap) {
    return Synchronized.biMap(bimap, (Object)null);
}
</code></pre>
</li>
<li>
<p>传入一个BiMap返回一个unmodifiableBiMap</p>
<pre><code class="language-java">public static &lt;K, V&gt; BiMap&lt;K, V&gt; unmodifiableBiMap(BiMap&lt;? extends K, ? extends V&gt; bimap) {
    return new Maps.UnmodifiableBiMap(bimap, (BiMap)null);
}
</code></pre>
</li>
</ol>
<h3 id="根据map和函数对map进行转型">根据Map和函数对Map进行转型</h3>
<p>此类方法使用使用到了函数式编程，将一个Map的value作为新的Map的key，根据函数的规则计算出新的Map的Value，而这个转换只有在查看的时候才会做计算，而真正存储的是传入的map</p>
<ol>
<li>
<p>传入一个Map和一个规则，返回一个有规则计算出来的Map</p>
<pre><code class="language-java">public static &lt;K, V1, V2&gt; Map&lt;K, V2&gt; transformValues(Map&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function) {
    return transformEntries((Map)fromMap, asEntryTransformer(function));
}
</code></pre>
</li>
<li>
<p>传入一个SortedMap和一个规则，返回一个由规则计算出来的新的Map</p>
<pre><code class="language-java">public static &lt;K, V1, V2&gt; SortedMap&lt;K, V2&gt; transformValues(SortedMap&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function) {
    return transformEntries((SortedMap)fromMap, asEntryTransformer(function));
}
</code></pre>
</li>
<li>
<p>传入一个NavigableMap和一个规则，返回一个由规则计算出来的NavigableMap</p>
<pre><code class="language-java">public static &lt;K, V1, V2&gt; NavigableMap&lt;K, V2&gt; transformValues(NavigableMap&lt;K, V1&gt; fromMap, Function&lt;? super V1, V2&gt; function) {
    return transformEntries((NavigableMap)fromMap, asEntryTransformer(function));
}
</code></pre>
</li>
<li>
<p>传入一个Map和一个Maps规定的规则格式，根据规则返回一个新的Map</p>
<pre><code class="language-java">public static &lt;K, V1, V2&gt; Map&lt;K, V2&gt; transformEntries(Map&lt;K, V1&gt; fromMap, Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
    return (Map)(fromMap instanceof SortedMap?transformEntries((SortedMap)((SortedMap)fromMap), transformer):new Maps.TransformedEntriesMap(fromMap, transformer));
}
</code></pre>
</li>
<li>
<p>传入一个NavigableMap和一个Maps规定的规则格式，根据规则返回一个新的NavigableMap</p>
<pre><code class="language-java">public static &lt;K, V1, V2&gt; NavigableMap&lt;K, V2&gt; transformEntries(NavigableMap&lt;K, V1&gt; fromMap, Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
    return new Maps.TransformedEntriesNavigableMap(fromMap, transformer);
}
</code></pre>
</li>
</ol>
<h3 id="使用函数进行过滤map然后返回同类型的map">使用函数进行过滤Map，然后返回同类型的Map</h3>
<blockquote>
<p>这里我们主要针对Key进行过滤的源码进行分析。当然Maps还提供了一些对Value、Entry、含有过滤器的Map进行过滤的方法。与上面过滤key的方法大体一样，都是继承了AbstractFilteredMap抽象类，实现了各自的过滤功能</p>
</blockquote>
<p>使用keyPredicate函数接口制定过滤规则，对Map进行过滤，对于Map中Key进行过滤的类FilteredKeyMap源码如下：</p>
<pre><code class="language-java">// 对KeySet进行了过滤处理，使用了Set中的filter方法
private static class FilteredKeyMap&lt;K, V&gt; extends Maps.AbstractFilteredMap&lt;K, V&gt; {
    Predicate&lt;? super K&gt; keyPredicate;
    FilteredKeyMap(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) {
        super(unfiltered, entryPredicate);
        this.keyPredicate = keyPredicate;
    }
    protected Set&lt;Entry&lt;K, V&gt;&gt; createEntrySet() {
        return Sets.filter(this.unfiltered.entrySet(), this.predicate);
    }
 
    Set&lt;K&gt; createKeySet() {
        return Sets.filter(this.unfiltered.keySet(), this.keyPredicate);
    }
 
    public boolean containsKey(Object key) {
        return this.unfiltered.containsKey(key) &amp;&amp; this.keyPredicate.apply(key);
    }
}
</code></pre>
<ol>
<li>
<p>传入一个Map和过滤他的规则，返回一个新的Map</p>
<pre><code class="language-java">public static &lt;K, V&gt; Map&lt;K, V&gt; filterKeys(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate) {
        Preconditions.checkNotNull(keyPredicate);
        Predicate&lt;Map.Entry&lt;K, ?&gt;&gt; entryPredicate = keyPredicateOnEntries(keyPredicate);
        return (Map)(unfiltered instanceof AbstractFilteredMap ? filterFiltered((AbstractFilteredMap)unfiltered, entryPredicate) : new FilteredKeyMap((Map)Preconditions.checkNotNull(unfiltered), keyPredicate, entryPredicate));
    }
</code></pre>
</li>
<li>
<p>传入一个SortedMap，然后交给filterEntries方法进行处理</p>
<pre><code class="language-java">public static &lt;K, V&gt; SortedMap&lt;K, V&gt; filterKeys(SortedMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate) {
    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));
}
</code></pre>
</li>
<li>
<p>传入一个NavigableMap，然后交给filterEntries方法进行处理</p>
<pre><code class="language-java">public static &lt;K, V&gt; NavigableMap&lt;K, V&gt; filterKeys(NavigableMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate) {
    return filterEntries((NavigableMap)unfiltered, keyPredicateOnEntries(keyPredicate));
}
</code></pre>
</li>
<li>
<p>传入一个BiMap，然后交给filterEntries方法进行处理</p>
<pre><code class="language-java">public static &lt;K, V&gt; BiMap&lt;K, V&gt; filterKeys(BiMap&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate) {
    Preconditions.checkNotNull(keyPredicate);
    return filterEntries((BiMap)unfiltered, keyPredicateOnEntries(keyPredicate));
}
</code></pre>
</li>
</ol>
<h2 id="sets">Sets</h2>
<h3 id="功能函数-2">功能函数</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建不可变的set</td>
<td>1、ImmutableSet&lt;E&gt; immutableEnumSet(E anElement, E... otherElements)<br>2、ImmutableSet&lt;E&gt; immutableEnumSet(Iterable&lt;E&gt; elements)</td>
</tr>
<tr>
<td>创建HashSet</td>
<td>1、HashSet&lt;E&gt; newHashSet()<br>2、HashSet&lt;E&gt; newHashSet(E... elements)<br>3、HashSet&lt;E&gt; newHashSetWithExpectedSize(int expectedSize)<br>4、HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements)<br>5、HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建线程安全的Set</td>
<td>1、Set&lt;E&gt; newConcurrentHashSet()<br>2、Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建LinkedHashMap</td>
<td>1、LinkedHashSet&lt;E&gt; newLinkedHashSet()<br>2、LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(int expectedSize)<br>3、LinkedHashSet&lt;E&gt; newLinkedHashSet(Iterable&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建TreeSet</td>
<td>1、TreeSet&lt;E&gt; newTreeSet()<br>2、TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements)<br>3、TreeSet&lt;E&gt; newTreeSet(Comparator&lt;? super E&gt; comparator)</td>
</tr>
<tr>
<td>创建IdentityHashSet</td>
<td>Set&lt;E&gt; newIdentityHashSet()</td>
</tr>
<tr>
<td>创建CopyOnWriteArraySet</td>
<td>1、CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet()<br>2、CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(Iterable&lt;? extends E&gt; elements)</td>
</tr>
<tr>
<td>创建EnumSet</td>
<td>1、EnumSet&lt;E&gt; newEnumSet(Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType)<br>2、EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection)<br>3、EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection, Class&lt;E&gt; type)<br>4、EnumSet&lt;E&gt; makeComplementByHand(Collection&lt;E&gt; collection, Class&lt;E&gt; type)</td>
</tr>
<tr>
<td>根据Map创建一个Set</td>
<td>Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map)</td>
</tr>
<tr>
<td>以两个Set的并集作为视图</td>
<td>Sets.SetView&lt;E&gt; union(final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2)</td>
</tr>
<tr>
<td>以两个Set的交集作为视图</td>
<td>Sets.SetView&lt;E&gt; intersection(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2)</td>
</tr>
<tr>
<td>以两个Set的互不重叠的部分作为视图</td>
<td>Sets.SetView&lt;E&gt; difference(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2)</td>
</tr>
<tr>
<td>以两个Set的对称部分作为视图</td>
<td>Sets.SetView&lt;E&gt; symmetricDifference(Set&lt;? extends E&gt; set1, Set&lt;? extends E&gt; set2)</td>
</tr>
<tr>
<td>过滤Set</td>
<td>1、filter(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate)<br>2、SortedSet&lt;E&gt; filter(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate)<br>3、SortedSet&lt;E&gt; filterSortedIgnoreNavigable(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate)<br>4、NavigableSet&lt;E&gt; filter(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate)</td>
</tr>
<tr>
<td>获取两个Set集合的笛卡尔积</td>
<td>1、Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets)<br>2、Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets)</td>
</tr>
</tbody>
</table>
<h3 id="创建不可变的set">创建不可变的Set</h3>
<ol>
<li>
<p>根据传入的参数，创建一个不可变的Set</p>
<pre><code class="language-java">public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(E anElement, E... otherElements) {
    //使用ImmutableEnumSet.asImmutable函数将EnumSet转为ImmutableSet
    return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
}

//EnumSet.of方法是将anElement和otherElements合并成一个EnumSet
public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E first, E... rest) {
    EnumSet&lt;E&gt; result = noneOf(first.getDeclaringClass());
    //将第一个参数先插入到EnumSet中
    result.add(first);
    //在将传入的数组全部插入到EnumSet中
    for (E e : rest)
        result.add(e);
    return result;
}
</code></pre>
</li>
<li>
<p>根据一个集合创建一个不可变的Set</p>
<pre><code class="language-java">public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(Iterable&lt;E&gt; elements) {
    //如果是一个ImmutableEnumSet，则直接转换为ImmutableEnumSet
    if(elements instanceof ImmutableEnumSet) {
        return (ImmutableEnumSet)elements;
    } else if(elements instanceof Collection) {
        //如果是一个Collection且不为空则，直接使用ImmutableEnumSet.asImmutable方法转化为ImmutableEnumSet
        Collection itr1 = (Collection)elements;
        return itr1.isEmpty()?ImmutableSet.of():ImmutableEnumSet.asImmutable(EnumSet.copyOf(itr1));
    } else {
        //其他类型，则获取他的迭代器，然后制作一个ImmutableEnumSet
        Iterator itr = elements.iterator();
        if(itr.hasNext()) {
            EnumSet enumSet = EnumSet.of((Enum)itr.next());
            Iterators.addAll(enumSet, itr);
            return ImmutableEnumSet.asImmutable(enumSet);
        } else {
            return ImmutableSet.of();
        }
    }
}
</code></pre>
</li>
</ol>
<h3 id="创建hashset">创建HashSet</h3>
<ol>
<li>
<p>直接new一个HashSet</p>
<pre><code class="language-java">public static &lt;E&gt; HashSet&lt;E&gt; newHashSet() {
    return new HashSet();
}
</code></pre>
</li>
<li>
<p>传入一个数组，返回一个HashSet</p>
<pre><code class="language-java">public static &lt;E&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
    //创建一个期望大小为elements.length的HashSet
    HashSet set = newHashSetWithExpectedSize(elements.length);
    //将数组中的元素，全部赋值给新的HashSet
    Collections.addAll(set, elements);
    return set;
}
</code></pre>
</li>
<li>
<p>创建一个期望大小的HashSet</p>
<pre><code class="language-java">public static &lt;E&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(int expectedSize) {
    //创建一个HashSet，大小为Maps.capacity方法计算后的值，这个方法最终返回原值的4/3
    return new HashSet(Maps.capacity(expectedSize));
}
</code></pre>
</li>
<li>
<p>根据传入的集合创建一个HashSet</p>
<pre><code class="language-java">public static &lt;E&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
    return elements instanceof Collection?new HashSet(Collections2.cast(elements)):newHashSet((Iterator)elements.iterator());
}
</code></pre>
</li>
<li>
<p>根据传入的迭代器创建一个HashSet</p>
<pre><code class="language-java">public static &lt;E&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
    //创建一个HashSet
    HashSet set = newHashSet();
    //使用Guava中的Iterators.addAll方法将迭代器中的元素添加到set中
    Iterators.addAll(set, elements);
    return set;
}
</code></pre>
</li>
</ol>
<h3 id="创建线程安全的set">创建线程安全的Set</h3>
<ol>
<li>
<p>使用ConcurrentHashMap创建一个Set</p>
<pre><code class="language-java">public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
    //创建一个ConcurrentHashMap，使用newSetFromMap方法将ConcurrentHashMap的值转为Set
    return newSetFromMap(new ConcurrentHashMap());
}
</code></pre>
</li>
<li>
<p>使用传入的集合创建一个线程安全的Set</p>
<pre><code class="language-java">public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
    //创建一个ConcurrentHashSet
    Set set = newConcurrentHashSet();
    //使用Guava中的Iterables.addAll方法将集合elements中的元素添加到set中
    Iterables.addAll(set, elements);
    return set;
}
</code></pre>
</li>
</ol>
<h3 id="创建linkedhashset">创建LinkedHashSet</h3>
<ol>
<li>
<p>直接创建一个LinkedHashSet</p>
<pre><code class="language-java">public static &lt;E&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
    return new LinkedHashSet();
}
</code></pre>
</li>
<li>
<p>创建一个期望大小的LinkedHashSet</p>
<pre><code class="language-java">public static &lt;E&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(int expectedSize) {
    //返回一个LinkedHashSet，大小为expectedSize的4/3
    return new LinkedHashSet(Maps.capacity(expectedSize));
}
</code></pre>
</li>
<li>
<p>根据传入的集合，返回一个LinkedHashSet</p>
<pre><code class="language-java">public static &lt;E&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(Iterable&lt;? extends E&gt; elements) {
    //如果是一个Collection类型，则直接创建LinkedHashSet，并将集合中的值赋值给新的LinkedHashSet
    if(elements instanceof Collection) {
        return new LinkedHashSet(Collections2.cast(elements));
    } else {
        LinkedHashSet set = newLinkedHashSet();
        Iterables.addAll(set, elements);
        return set;
    }
}



</code></pre>
</li>
</ol>
<h3 id="创建treeset">创建TreeSet</h3>
<ol>
<li>
<p>直接创建一个TreeSet</p>
<pre><code class="language-java">public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
    return new TreeSet();
}
</code></pre>
</li>
<li>
<p>传入一个集合，返回一个TreeSet，并将集合中的元素赋值给TreeSet</p>
<pre><code class="language-java">public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
    //创建一个TreeSet
    TreeSet set = newTreeSet();
    //将集合中的元素赋值给TreeSet
    Iterables.addAll(set, elements);
    return set;
}
</code></pre>
</li>
<li>
<p>传入一个Comparator，根据Comparator的规则创建一个TreeSet</p>
<pre><code class="language-java">public static &lt;E&gt; TreeSet&lt;E&gt; newTreeSet(Comparator&lt;? super E&gt; comparator) {
    return new TreeSet((Comparator)Preconditions.checkNotNull(comparator));
}
</code></pre>
</li>
</ol>
<h3 id="创建identityhashset">创建IdentityHashSet</h3>
<p>根据Maps.newIdentityHashMap()和Sets.newSetFromMap两个方法创建一个IdentityHashSet</p>
<pre><code class="language-java">public static &lt;E&gt; Set&lt;E&gt; newIdentityHashSet() {
    //使用Maps.newIdentityHashMap()方法创建一个IdentityHashMap，然后使用newSetFromMap方法将Map转为Set
    return newSetFromMap(Maps.newIdentityHashMap());
}
</code></pre>
<h3 id="创建copyonwritearrayset">创建CopyOnWriteArraySet</h3>
<ol>
<li>
<p>直接创建一个CopyOnWriteArraySet</p>
<pre><code class="language-java">public static &lt;E&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
    return new CopyOnWriteArraySet();
}
</code></pre>
</li>
<li>
<p>根据传入的集合创建一个CopyOnWriteArraySet，并将集合中的数据赋值给CopyOnWriteArraySet</p>
<pre><code class="language-java">public static &lt;E&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(Iterable&lt;? extends E&gt; elements) {
    //如果是一个Collection，直接将其转为Collection，如果不是则使用Lists创建一个List
    Object elementsCollection = elements instanceof Collection?Collections2.cast(elements):Lists.newArrayList(elements);
    return new CopyOnWriteArraySet((Collection)elementsCollection);
}
</code></pre>
</li>
</ol>
<h3 id="创建enumset">创建EnumSet</h3>
<ol>
<li>
<p>根据传入的集合和一个类型，返回一个EnumSet</p>
<pre><code class="language-java">public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
    //根据传入的类型，创建一个set
    EnumSet set = EnumSet.noneOf(elementType);
    //将集合中的元素添加到set中
    Iterables.addAll(set, iterable);
    return set;
}
</code></pre>
</li>
<li>
<p>传入一个集合，返回一个EnumSet</p>
<pre><code class="language-java">public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
    if(collection instanceof EnumSet) {
        return EnumSet.complementOf((EnumSet)collection);
    } else {
        Preconditions.checkArgument(!collection.isEmpty(), "collection is empty; use the other version of this method");
        Class type = ((Enum)collection.iterator().next()).getDeclaringClass();
        return makeComplementByHand(collection, type);
    }
}
</code></pre>
</li>
</ol>
<h3 id="根据一个map创建一个set">根据一个Map创建一个Set</h3>
<p>根据Map创建一个Set</p>
<pre><code class="language-java">public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
    return Platform.newSetFromMap(map);
}
//Platform.newSetFromMap方法，一层一层往上追，最终可以看到，实际上使用的是Collections.SetFromMap类：

private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable{
    private final Map&lt;E, Boolean&gt; m;  // The backing map
    private transient Set&lt;E&gt; s;       // Its keySet
    SetFromMap(Map&lt;E, Boolean&gt; map) {//其实就是将map中的key集合作为一个Set了
        if (!map.isEmpty())
            throw new IllegalArgumentException("Map is non-empty");
        m = map;
        s = map.keySet();
    }
}
</code></pre>
<h3 id="以两个set的互不重叠的部分作为视图">以两个Set的互不重叠的部分作为视图</h3>
<p>传入两个Set，返回一个两个set1中不包含set2中的元素</p>
<pre><code class="language-java">public static &lt;E&gt; Sets.SetView&lt;E&gt; difference(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    //创建一个过滤规则（规则为，不能包含set2中的元素）
    final Predicate notInSet2 = Predicates.not(Predicates.in(set2));
    return new Sets.SetView(null) {
        //重写iterator，使用Iterators.filter过滤出不含set2元素的一个迭代器
        public Iterator&lt;E&gt; iterator() {
            return Iterators.filter(set1.iterator(), notInSet2);
        }
        //根据最终返回的迭代器计算长度
        public int size() {
            return Iterators.size(this.iterator());
        }
        //如果set1和set2中全部相等，就为空
        public boolean isEmpty() {
            return set2.containsAll(set1);
        }
        public boolean contains(Object element) {
            return set1.contains(element) &amp;&amp; !set2.contains(element);
        }
    };
}
</code></pre>
<h3 id="以两个set的并集作为视图">以两个Set的并集作为视图</h3>
<pre><code class="language-java">public static &lt;E&gt; Sets.SetView&lt;E&gt; union(final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    //获取set2，中不包含set1的所有元素
    final Sets.SetView set2minus1 = difference(set2, set1);
    return new Sets.SetView(null) {
        //获取set1的全部长度和set2minus1视图的长度
        public int size() {
            return set1.size() + set2minus1.size();
        }
        public boolean isEmpty() {
            return set1.isEmpty() &amp;&amp; set2.isEmpty();
        }
        public Iterator&lt;E&gt; iterator() {
            return Iterators.unmodifiableIterator(Iterators.concat(set1.iterator(), set2minus1.iterator()));
        }
        public boolean contains(Object object) {
            return set1.contains(object) || set2.contains(object);
        }
        //返回所有元素
        public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
            set.addAll(set1);
            set.addAll(set2);
            return set;
        }
        public ImmutableSet&lt;E&gt; immutableCopy() {
            return (new Builder()).addAll(set1).addAll(set2).build();
        }
    };
}
</code></pre>
<h3 id="以两个set的交集作为视图">以两个Set的交集作为视图</h3>
<pre><code class="language-java">public static &lt;E&gt; Sets.SetView&lt;E&gt; intersection(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    //创建一个过滤规则（规则为：全部set2元素）
    final Predicate inSet2 = Predicates.in(set2);
    return new Sets.SetView(null) {
        //返回set1中包含set2中的所有元素
        public Iterator&lt;E&gt; iterator() {
            return Iterators.filter(set1.iterator(), inSet2);
        }
        //根据计算出的迭代器计算长度
        public int size() {
            return Iterators.size(this.iterator());
        }
        //根据迭代器判断是否为空
        public boolean isEmpty() {
            return !this.iterator().hasNext();
        }
        public boolean contains(Object object) {
            return set1.contains(object) &amp;&amp; set2.contains(object);
        }
        public boolean containsAll(Collection&lt;?&gt; collection) {
            return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
        }
    };
}
</code></pre>
<h3 id="以两个set的对称部分作为视图">以两个Set的对称部分作为视图</h3>
<pre><code class="language-java">public static &lt;E&gt; Sets.SetView&lt;E&gt; symmetricDifference(Set&lt;? extends E&gt; set1, Set&lt;? extends E&gt; set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    return difference(union(set1, set2), intersection(set1, set2));
}
</code></pre>
<h3 id="过滤set">过滤Set</h3>
<p>Set的过滤和Maps中实现的各种过滤都是大同小异。</p>
<p>传入一个Set和一个过滤规则，返回一个过滤后的Set：</p>
<pre><code class="language-java">public static &lt;E&gt; Set&lt;E&gt; filter(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    //如果传入的Set为SortedSet类型，使用传入SortedSet的方法进行处理
    if(unfiltered instanceof SortedSet) {
        return filter((SortedSet)((SortedSet)unfiltered), predicate);
    } else if(unfiltered instanceof Sets.FilteredSet) {
        Sets.FilteredSet filtered = (Sets.FilteredSet)unfiltered;
        Predicate combinedPredicate = Predicates.and(filtered.predicate, predicate);
        return new Sets.FilteredSet((Set)filtered.unfiltered, combinedPredicate);
    } else {
        return new Sets.FilteredSet((Set)Preconditions.checkNotNull(unfiltered), (Predicate)Preconditions.checkNotNull(predicate));
    }
}
</code></pre>
<h2 id="往期推荐">往期推荐</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qb4XACLMRNgsNdi5DdevhA" target="_blank" rel="noopener nofollow">《SpringBoot》EasyExcel实现百万数据的导入导出</a></li>
<li><a href="https://mp.weixin.qq.com/s/MgC_iK536FxTLgm7CJMlqQ" target="_blank" rel="noopener nofollow">《SpringBoot》史上最全SpringBoot相关注解介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s/-3H6VyhKfl9byf6ifnk1ug" target="_blank" rel="noopener nofollow">Spring框架IoC核心详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/O0W6vCuqQfeAH0UB7elpeA" target="_blank" rel="noopener nofollow">万字长文带你窥探Spring中所有的扩展点</a></li>
<li><a href="https://mp.weixin.qq.com/s/tATN-g66NyW5BzyiHWoRkA" target="_blank" rel="noopener nofollow">如何实现一个通用的接口限流、防重、防抖机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/gg6N6e90ZtbA0MH4KIEHlg" target="_blank" rel="noopener nofollow">万字长文带你深入Redis底层数据结构</a></li>
<li><a href="https://mp.weixin.qq.com/s/QhOFMEJWjIJM0jVFsCfJdA" target="_blank" rel="noopener nofollow">volatile关键字最全原理剖析</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.039047545259259256" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 08:15">2025-03-31 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18800409" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18800409);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18800409', targetLink: 'https://www.cnblogs.com/seven97-top/p/18800409', title: '【Guava】集合工具类-Immutable&amp;amp;Lists&amp;amp;Maps&amp;amp;Sets' })">举报</a>
</div>
        