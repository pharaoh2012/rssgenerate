
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/k1115h0t/p/18913107" title="发布于 2025-06-05 20:47">
    <span role="heading" aria-level="2">Java安全_SQL注入</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>[!NOTE]</p>
<p>本次学习使用开源项目：<br>
<a href="https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/SQLI.java" target="_blank" rel="noopener nofollow">https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/SQLI.java</a></p>
<p>使用工具：<br>
浏览器</p>
<p>IDEA</p>
</blockquote>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#什么是-sql-注入" rel="noopener nofollow">什么是 SQL 注入</a></li><li><a href="#jdbc-模式下的-sql-注入" rel="noopener nofollow">JDBC 模式下的 SQL 注入</a><ul><li><a href="#1最原始的拼接注入" rel="noopener nofollow">1、最原始的拼接注入</a><ul><li><a href="#修复方式" rel="noopener nofollow"><strong>修复方式</strong></a></li></ul></li></ul></li><li><a href="#mybatis模式下的sql注入" rel="noopener nofollow">Mybatis模式下的SQL注入</a><ul><li><a href="#mybatis下sql的写法" rel="noopener nofollow">Mybatis下SQL的写法</a></li><li><a href="#关于mybatis下sql的两种拼接方法" rel="noopener nofollow">关于Mybatis下SQL的两种拼接方法</a><ul><li><a href="#那么体现在sql语句上这两种方法有什么区别呢" rel="noopener nofollow">那么体现在SQL语句上，这两种方法有什么区别呢？</a><ul><li><ul><li><ul><li><a href="#能否使用的总结表格" rel="noopener nofollow"><strong><u><em>能否使用#{}的总结表格：</em></u></strong></a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div><p></p>
<h1 id="什么是-sql-注入">什么是 SQL 注入</h1>
<p><strong>SQL 注入（SQL Injection）</strong> 是 JavaWeb 应用中最常见、最严重的安全漏洞之一。它指的是攻击者将恶意 SQL 语句作为用户输入传入系统，并被后台拼接执行，从而操控数据库。</p>
<p>在 JavaWeb 项目中，最容易出现 SQL 注入的地方是：</p>
<ul>
<li>登录验证</li>
<li>搜索查询</li>
<li>数据过滤接口</li>
<li>URL 参数拼接数据库语句</li>
</ul>
<p>如下面的代码</p>
<pre><code class="language-java">            Statement statement = con.createStatement();
            String sql = "select * from users where username = '" + username + "'";
            logger.info(sql);
            ResultSet rs = statement.executeQuery(sql);
</code></pre>
<p>如果攻击者输入：</p>
<ul>
<li>用户名：<code>username = ' OR '1'='1</code></li>
</ul>
<p>那么 SQL 就变成：</p>
<pre><code class="language-sql">select * from users where username = '' OR '1'='1'
</code></pre>
<p>那么条件判断永远为真，就能达到绕过的目的</p>
<h1 id="jdbc-模式下的-sql-注入">JDBC 模式下的 SQL 注入</h1>
<h2 id="1最原始的拼接注入">1、最原始的拼接注入</h2>
<p>关键 Code</p>
<pre><code class="language-java">public String jdbc_sqli_vul( String username) {

        StringBuilder result = new StringBuilder();

        try {
            Class.forName(driver);
            Connection con = DriverManager.getConnection(url, user, password);

            if (!con.isClosed())
                System.out.println("Connect to database successfully.");

            // sqli vuln code
            Statement statement = con.createStatement();
            String sql = "select * from users where username = '" + username + "'";
            logger.info(sql);
            ResultSet rs = statement.executeQuery(sql);

            while (rs.next()) {
                String res_name = rs.getString("username");
                String res_pwd = rs.getString("password");
                String info = String.format("%s: %s\n", res_name, res_pwd);
                result.append(info);
                logger.info(info);
            }
            rs.close();
            con.close();


        } catch (ClassNotFoundException e) {
            logger.error("Sorry,can`t find the Driver!");
        } catch (SQLException e) {
            logger.error(e.toString());
        }
        return result.toString();
    }
</code></pre>
<p>可以看到接受 Get 参数之后，直接进行了 SQL 语句拼接处理</p>
<p>下面为漏洞关键代码</p>
<pre><code class="language-java">            Statement statement = con.createStatement();
            String sql = "select * from users where username = '" + username + "'";
            logger.info(sql);
            ResultSet rs = statement.executeQuery(sql);
</code></pre>
<p>构造 Payload</p>
<pre><code>http://127.0.0.1:8081/sqli/jdbc/vuln?username=joychou' or '1'='1
</code></pre>
<p>通过打断点查看，发现最终执行的 SQL 语句变成了 <code>select * from users where username = 'joychou' or '1'='1'</code>，从而达到绕过的目的</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250605204644857-812678881.png" alt="" loading="lazy"></p>
<h3 id="修复方式"><strong>修复方式</strong></h3>
<p>通过参数化查询+预编译，可以达到避免 SQL 注入的目的，代码示例如下：</p>
<pre><code class="language-java">String sql = "select * from users where username = ?";
PreparedStatement st = con.prepareStatement(sql);
st.setString(1, username);
ResultSet rs = st.executeQuery();
</code></pre>
<p><code>PreparedStatement</code> 是 Java JDBC 提供的预编译 SQL 语句接口，它允许开发者在 SQL 语句中使用占位符 <code>?</code>，然后通过绑定参数的方式传入用户数据。数据库在执行时会先对 SQL 语句结构进行编译，之后再将参数作为数据绑定进去，保证了输入内容不会被当作 SQL 代码执行。</p>
<p>这种机制有效防止了 SQL 注入攻击，因为即便用户输入中包含恶意的 SQL 片段，也不会被当作语句解析执行，而只会作为普通字符串处理，从而提高了系统的安全性和稳定性。此外，<code>PreparedStatement</code> 还可以提升执行效率，尤其是对相同语句多次执行时，可以复用预编译结果，减少数据库负担。</p>
<p>在使用参数化查询+预编译后，在对代码进行调试，查看最终执行的 SQL 语句</p>
<p>可以发现，最终执行的语句变成了 <code>select * from users where username = 'joychou\' or \'1\'=\'1'</code></p>
<p>在这里，预编译机制会将用户输入作为 <strong>纯字符串值</strong> 处理，自动对特殊字符（如单引号 <code>'</code>）进行转义，因此即使输入中包含类似 <code>' or '1'='1</code> 的恶意内容，也不会改变 SQL 语句的逻辑结构。从而达到了防止 SQL 注入的目的</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250605204705195-1101597423.png" alt="" loading="lazy"></p>
<h1 id="mybatis模式下的sql注入">Mybatis模式下的SQL注入</h1>
<h2 id="mybatis下sql的写法">Mybatis下SQL的写法</h2>
<p>​	Mybatis有两种SQL语句写法：</p>
<ul>
<li>
<p>使用注解</p>
<pre><code class="language-java">    @Select("select * from users where username = #{username}")
    User findByUserName(@Param("username") String username);
</code></pre>
</li>
<li>
<p>使用XML文件映射</p>
<pre><code class="language-xml">    &lt;select id="findByUserNameVsec02" parameterType="String" resultMap="User"&gt;
        select * from users where username like concat('%',#{_parameter}, '%')
    &lt;/select&gt;
</code></pre>
</li>
</ul>
<p>​</p>
<h2 id="关于mybatis下sql的两种拼接方法">关于Mybatis下SQL的两种拼接方法</h2>
<p>​	Mybatis中存在两种SQL语句拼接方法：</p>
<ul>
<li><strong>${xxxxxx} 直接拼接</strong>，可以理解为上面的JDBC最原始的拼接 ，是一种不安全的方法</li>
<li><strong>#{xxxxxx} 预处理后拼接</strong>，是一种安全的方法</li>
</ul>
<p>​	在 MyBatis 中，<code>${}</code> 和 <code>#{}</code> 的区别非常关键，它们直接影响到 SQL 是否存在注入风险：</p>
<ul>
<li>
<p><code>${}</code> 是<strong>字符串替换</strong>，会在 SQL 拼接阶段将参数原样插入 SQL 中，<strong>不经过任何预处理或转义</strong>。如果用户输入中包含恶意 SQL 片段，就可能被拼接进最终 SQL 并执行，<strong>存在严重的 SQL 注入风险</strong>。</p>
<p>例如：</p>
<pre><code class="language-xml">&lt;select id="findUser" resultType="User"&gt;
    select * from users where username = '${username}'
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p>​	如果用户输入是 <code>joychou' or '1'='1</code>，最终 SQL 将变为：</p>
<pre><code class="language-sql">select * from users where username = 'joychou' or '1'='1'
</code></pre>
<h3 id="那么体现在sql语句上这两种方法有什么区别呢">那么体现在SQL语句上，这两种方法有什么区别呢？</h3>
<p>​		<strong>#{}会给传入的值自动加上单引号</strong></p>
<p>​		如<code>select * from #{param}</code> ，如给param传入值为xxxx时，SQL会被拼接成 <code>select * from 'xxxx'</code> ，这是因为#{}自动给拼接上的参数加上了单引号</p>
<p>​		<strong>${}就是什么都不变的直接拼接了</strong></p>
<p>​		如 <code>select * from ${param}</code> ，如给param传入值为xxxx时，SQL会被拼接成 <code>select * from xxxx</code>  ，可以注意这里并没有单引号，因为<code>${}</code>是直接拼接</p>
<p>​		这就给Mybatis下的SQL注入带来了可乘之机</p>
<p>​		在SQL语句中存在很多不能包含单引号的情况，例如：<code>被拼接的参数是表名、数据库名、字段名等</code> , 这一情况在 <code>order by</code> 中尤为常见</p>
<h6 id="能否使用的总结表格"><strong><u><em>能否使用#{}的总结表格：</em></u></strong></h6>
<table>
<thead>
<tr>
<th>场景</th>
<th>能否使用 <code>#{}</code></th>
<th>是否建议用 <code>${}</code></th>
<th>风险说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>表名</td>
<td>❌ 否</td>
<td>✅ 可用（需白名单）</td>
<td>否则无法拼接 SQL</td>
</tr>
<tr>
<td>列名 / 字段名</td>
<td>❌ 否</td>
<td>✅ 可用（需白名单）</td>
<td>常用于排序、动态列选择</td>
</tr>
<tr>
<td>排序方向（ASC/DESC）</td>
<td>❌ 否</td>
<td>✅ 可用（需白名单）</td>
<td>否则 SQL 报错</td>
</tr>
<tr>
<td>SQL 关键字</td>
<td>❌ 否</td>
<td>✅ 可用（需白名单）</td>
<td>如运算符、动态语法结构</td>
</tr>
<tr>
<td>LIMIT / OFFSET</td>
<td>一般 ✅ 可用</td>
<td>✅ 可用（需数值校验）</td>
<td>数据库版本不同兼容性需注意</td>
</tr>
<tr>
<td>数据库函数名</td>
<td>❌ 否</td>
<td>✅ 可用（需白名单）</td>
<td>如 <code>count</code>, <code>sum</code> 可拼接但需控制</td>
</tr>
</tbody>
</table>
<p>​</p>
<p>​		因此，在这种不得不使用${}的情况下，需要格外注意对参数的过滤，如下面的代码</p>
<pre><code class="language-java">//使用了过滤器的order by执行语句
@GetMapping("/mybatis/orderby/sec04")
    public List&lt;User&gt; mybatisOrderBySec04(@RequestParam("sort") String sort) {
        String filter_order = SecurityUtil.sqlFilter(sort);
        return userMapper.findByUserNameVuln03(filter_order);
    }
</code></pre>
<pre><code class="language-java">//过滤器
private static final Pattern FILTER_PATTERN = Pattern.compile("^[a-zA-Z0-9_/\\.-]+$");
public static String sqlFilter(String sql) {
        if (!FILTER_PATTERN.matcher(sql).matches()) {
            return null;
        }
        return sql;
    }
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7336658367384259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-05 20:48">2025-06-05 20:47</span>&nbsp;
<a href="https://www.cnblogs.com/k1115h0t">k1115h0t</a>&nbsp;
阅读(<span id="post_view_count">92</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18913107);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18913107', targetLink: 'https://www.cnblogs.com/k1115h0t/p/18913107', title: 'Java安全_SQL注入' })">举报</a>
</div>
        