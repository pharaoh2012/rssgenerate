
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sq1201/p/18664227" title="发布于 2025-01-14 14:23">
    <span role="heading" aria-level="2">.NET8.0多线程编码结合异步编码示例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>1、创建一个.NET8.0控制台项目来演示多线程的应用</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110153615295-951956573.png" alt="" loading="lazy"></p>
<p><strong>2、快速创建一个线程</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110153929149-1104568658.png" alt="" loading="lazy"></p>
<p><strong>3、多次运行程序，可以得到输出结果</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110154304242-1314268772.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110154526937-1883976196.png" alt="" loading="lazy"></p>
<p>这就是多线程的特点 - 当多个线程并行执行时，它们的具体执行顺序是不确定的，除非我们使用同步机制（如 lock、信号量等）来控制执行顺序。</p>
<p><strong>4、新建一个类TestThread,以及一个静态的测试方法，用来做测试使用</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110155544512-1287872555.png" alt="" loading="lazy"></p>
<p><strong>5、在Program中，把输出改成调用TestThread类中的测试方法再次执行测试一下</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110155651717-1542452262.png" alt="" loading="lazy"></p>
<p><strong>6、执行以后的输出结果，如下图所示</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110161424357-1654801332.png" alt="" loading="lazy"></p>
<p><strong>7、Thread.Sleep(毫秒)：线程的等待(睡眠)</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110162106930-502147827.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110162127671-1159240124.png" alt="" loading="lazy"></p>
<p>执行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110162152045-487466894.png" alt="" loading="lazy"></p>
<p><strong>8、Thread.Join() 代表线程执行完毕以后，才可以继续执行后续的代码</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110162925822-1134117853.png" alt="" loading="lazy"></p>
<p>如下图所示，在thread线程内部执行完成以后，很快就接着执行最后的打印输出方法了<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110162956335-187272428.png" alt="" loading="lazy"></p>
<p><strong>9、Thread.Join(毫秒) 代表等待当前线程执行多长时间，如果超出设定的毫秒数，就会直接执行后续的代码</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110163522970-988313216.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110163549321-1232477756.png" alt="" loading="lazy"></p>
<p>运行程序，查看执行结果<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110163610803-1999250879.png" alt="" loading="lazy"></p>
<hr>
<p><strong>1、新增Test2方法，用来测试线程池ThreadPool使用</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110164446505-1854887220.png" alt="" loading="lazy"></p>
<p><strong>2、WaitCallback也是一个委托，传入需要在线程池内执行的方法名称。以下代码内，“线程池”字符串为要执行方法对应的参数</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110165346464-1170237116.png" alt="" loading="lazy"></p>
<pre><code>ThreadPool：
这是.NET中的线程池类
它维护着一组可重用的线程
比直接创建新线程更有效率

QueueUserWorkItem：
这个方法用于将工作项添加到线程池队列中
线程池会自动分配空闲线程来执行这些工作项

WaitCallback：
这是一个委托类型
定义了线程池中的线程要执行的方法
可以接收一个 object 类型的参数

TestThread.Test2：
这是你定义的要在线程池中执行的方法
它有这样的签名：public static void Test2(object state)

"线程池"：
这是传递给 Test2 方法的参数
</code></pre>
<p><strong>3、除了直接传入回调方法，也可以直接在线程池开启的方法内，直接写代码块来当做多线程执行的部分</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110165804168-303349928.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250110165858232-1251522930.png" alt="" loading="lazy"></p>
<p><strong>4、线程池内，可以通过设置Manual信号量，来识别线程池内的线程什么时候执行完成。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113135956896-6416291.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113140004238-627388825.png" alt="" loading="lazy"></p>
<hr>
<p>**1、创建一个TestAsyncAction类，添加一个模拟的异步方法TestAction</p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113143705550-956012921.png" alt="" loading="lazy"></p>
<p><strong>2、使用Task快读创建一个线程。最简单的方法：Task.Run(()=&gt;{ 代码块 })</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113143850556-545576835.png" alt="" loading="lazy"></p>
<p><strong>3、两个线程并行执行，查询执行结果</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113144000834-884861953.png" alt="" loading="lazy"></p>
<p><strong>4、如果想等待新开线程执行完再继续执行后续的代码，可以使用如下方式：使用 await 等待整个操作完成</strong></p>
<pre><code>await Task.Run(async () =&gt;
{
   await TestAsyncAction.TestAction();
});

代码会等待异步操作完成才继续执行
</code></pre>
<p>执行结果：<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113152006450-1951930811.png" alt="" loading="lazy"></p>
<p><strong>5、也可以使用Task.Factory创建一个任务工厂来实现</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113152724709-633363607.png" alt="" loading="lazy"></p>
<p><strong>6、查看执行结果</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113152748055-954848895.png" alt="" loading="lazy"></p>
<hr>
<p><strong>1、【异步结合多线程】如果有多个任务在执行期间，在任意一个线程执行完毕以后进行执行某种操作，可以使用 ContinueWhenAny来进行</strong></p>
<pre><code>// See https://aka.ms/new-console-template for more information
using MultiThreading;

Console.WriteLine($"{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}&gt;&gt;&gt;&gt;Hello, World!");


var tasks = new Task[3];

TaskFactory factory = new();

/*
 * .Unwrap() 主要是用来处理嵌套任务问题。
 * 使用 StartNew 执行 async lambda 时，会得到一个 Task&lt;Task&gt; (双层嵌套的Task)
 *          // 不使用 Unwrap
            var task1 = factory.StartNew(async () =&gt; {
                await Task.Delay(1000);
                return "Hello";
            });
            // task1 的类型是 Task&lt;Task&lt;string&gt;&gt;
            // 需要两次 await
            string result1 = await (await task1);
    ---------------------------------------------------
            // 使用 Unwrap
            var task2 = factory.StartNew(async () =&gt; {
                await Task.Delay(1000);
                return "Hello";
            }).Unwrap();
            // task2 的类型是 Task&lt;string&gt;
            // 只需要一次 await
            string result2 = await task2;
 */
tasks[0] = factory.StartNew(async () =&gt;
{
    await TestAsyncAction.AsyncAction1();
}).Unwrap();

tasks[1] = factory.StartNew(async () =&gt;
{
    await TestAsyncAction.AsyncAction2();
}).Unwrap();

tasks[2] = factory.StartNew(async () =&gt;
{
    await TestAsyncAction.AsyncAction3();
}).Unwrap();

_ = factory.ContinueWhenAny(tasks, x =&gt;
{
    Console.WriteLine($"{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}&gt;&gt;&gt;&gt;正常代码");
});

Console.ReadLine();//阻止程序退出

PS：如果后续代码依赖于续联任务的完成，使用 await
    如果不关心续联任务何时完成，使用 _=
</code></pre>
<p>查看执行结果：<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113161133485-275309715.png" alt="" loading="lazy"></p>
<p><strong>2、【异步结合多线程】如果要等任务全部执行完毕以后才执行某个代码块，可以使用ContinueWhenAll</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113161331053-432339112.png" alt="" loading="lazy"></p>
<p>查看执行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113161348429-1281114914.png" alt="" loading="lazy"></p>
<pre><code>PS：
// 可以使用 Task.WhenAny 替代 ContinueWhenAny
_ = Task.WhenAny(tasks).ContinueWith(t =&gt; {
    Console.WriteLine("&gt;&gt;&gt;&gt;正常代码");
});
</code></pre>
<p><strong>3、异步方法中 使用 WhenAll 和 WhenAny（这个仅模拟纯IO操作，不涉及多线程）</strong></p>
<pre><code>  当遇到 await 时，当前方法会返回到调用者
  主线程可以继续处理其他工作（比如UI响应、处理其他事件等）
  这些任务会被放到线程池中执行

  当前方法内 await 后面的代码会被打包成续接(continuation)
  这个续接会等待所有任务完成后才执行
  但这个等待是异步的，不会占用主线程资源
</code></pre>
<ul>
<li><strong>.WhenAll（）</strong><br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113171010288-1644312669.png" alt="" loading="lazy"></li>
</ul>
<p>查看执行结果：<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113171039092-245224073.png" alt="" loading="lazy"></p>
<ul>
<li><strong>.WhenAny（）</strong></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113171615667-387565661.png" alt="" loading="lazy"></p>
<p>查看执行结果：<br>
<img src="https://img2024.cnblogs.com/blog/3578996/202501/3578996-20250113171421975-1908797835.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6399667458344908" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 17:40">2025-01-14 14:23</span>&nbsp;
<a href="https://www.cnblogs.com/sq1201">sq1201</a>&nbsp;
阅读(<span id="post_view_count">327</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664227" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664227);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664227', targetLink: 'https://www.cnblogs.com/sq1201/p/18664227', title: '.NET8.0多线程编码结合异步编码示例' })">举报</a>
</div>
        