
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/graphics/p/18968833" title="发布于 2025-07-06 15:45">
    <span role="heading" aria-level="2">typescript结构化类型应用两例</span>
    

</a>

        </h2>
        <div class="postbody">
            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="介绍">介绍</h2>
<p>结构化类型是typescript类型系统的一个重要特性，如果不了解这个特性，则经常会被typescript的行为搞得一头雾水，导致我们期待的行为与实际的行为不一致。今天我们就来看两个例子。</p>
<p>不了解结构化类型的同学，可以先看看这篇：<a href="https://www.cnblogs.com/graphics/p/18967447" target="_blank">TypeScript结构化类型初探</a></p>
<h2 id="第一个例子">第一个例子</h2>
<p>下面的代码定义了一个<code>Person</code>类型</p>
<pre><code class="language-typescript">interface Person {
  name: string;
  age: number;
}
</code></pre>
<p>然后又定义了一个函数打印这个类型的对象</p>
<pre><code class="language-typescript">function printPerson(person: Person) {
  console.log(`Name: ${person.name}, Age: ${person.age}`);
}
</code></pre>
<p>按道理来说，要调用这个函数，必须传递一个<code>Person</code>类型的对象，但是你会发现，直接传一个对象进去也行。</p>
<pre><code class="language-typescript">printPerson({ name: "Alice", age: 30 });
</code></pre>
<p>这段代码没有报错，为什么呢？因为typescript的结构化类型系统认为，只要传入的对象包含了<code>Person</code>类型所需的所有属性，就可以被认为是<code>Person</code>类型。你甚至可以多加一些属性，比如：</p>
<pre><code class="language-typescript">printPerson({ name: "Alice", age: 30, location: "Wonderland" });
</code></pre>
<p>代码一样可以正常运行！</p>
<p>为什么？因为在typescript中，类型是<code>基于结构</code>的，而不是基于名称的。只要对象的结构符合要求，就可以被认为是该类型。如果一个类型A包含了类型B的所有属性，那么类型A就可以被认为是类型B。在使用类型B的地方，就可以使用类型A代替。</p>
<h2 id="第二个例子">第二个例子</h2>
<p>还是以上面的<code>Person</code>类型为例，假设我们要打印<code>Person</code>对象中的所有属性，有的同学可能不假思索的写下如下代码：</p>
<pre><code class="language-typescript">interface Person {
  name: string;
  age: number;
}

const person: Person = { name: "Alice", age: 30 };

function printProperties(person: Person) {
  for (const property in person) {
    console.log(`${property}: ${person[property]}`);
  }
}

printProperties(person);
</code></pre>
<p>但是这段代码却报错了：</p>
<pre><code class="language-bash">TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Person'. No index signature with a parameter of type 'string' was found on type 'Person'.
</code></pre>
<p>当我第一次看到这个错误时，我只想撞墙，我哪里用<code>any</code>了，这不是胡扯吗？但这不是对待错误的正确态度，这种错误如果不彻底解决，那么它就会一直困扰你，只有将它彻底击败，下次再遇到时才能得心应手！</p>
<p>仔细看一下这个报错，它大概描述了两件事情：</p>
<ol>
<li><code>string</code>类型的值不能用来索引<code>Person</code>类型。</li>
<li><code>Person</code>类型没有定义索引签名。</li>
</ol>
<p>其实这两件事本质上说的是一个问题，那就是在TypeScript中，只有在类型中显式定义了索引签名，才能使用<code>string</code>类型的值来索引该类型。那么我们就给<code>Person</code>类型添加一个索引签名：</p>
<h3 id="方式一为person类型添加索引签名">方式一：为<code>Person</code>类型添加索引签名</h3>
<pre><code class="language-typescript">interface Person {
  name: string;
  age: number;
  [key: string]: any; // 索引签名
}
</code></pre>
<blockquote>
<p><code>[key: string]: any;</code> 这行代码的意思是，<code>Person</code>类型可以有任意数量的属性，属性名必须是字符串类型 (<code>[key: string]</code>)，属性值可以是任意类型(<code>any</code>)。</p>
</blockquote>
<p>现在我们再来运行<code>printProperties</code>函数，就不会报错了。</p>
<h3 id="方式二使用keyof关键字">方式二：使用<code>keyof</code>关键字</h3>
<p>坦白的说，为了一个遍历函数给<code>Person</code>类型添加一个索引签名有点过于冗余了，其实我们可以使用另一个方法来解决这个问题，那就是使用<code>keyof</code>关键字来获取<code>Person</code>类型的所有属性名。</p>
<pre><code class="language-typescript">function printProperties(person: Person) {
  for (const property in person) {
    console.log(`${property}: ${person[property as keyof typeof person]}`);
  }
}
</code></pre>
<p>来看这一句代码<code>property as keyof typeof person</code>, 它的执行步骤是这样的：</p>
<ol>
<li>先执行<code>typeof person</code>，得到<code>Person</code>类型。</li>
<li>再执行<code>keyof Person</code>，得到<code>Person</code>类型的所有属性名的联合类型 - <code>name | age</code>。</li>
<li>最后使用<code>as</code>操作符将<code>property</code>转换为这个联合类型。</li>
</ol>
<p>这样做的好处是，<code>property</code>的类型被限制为<code>Person</code>类型的属性名，在本例中就是<code>name</code>和<code>age</code>这两个属性，绝不会超出这个范围，这样就可以安全地索引<code>person</code>对象了。</p>
<p>眼力好的同学可能已经发现了，上面这个写法可以简化一下，<code>property as keyof typeof person</code>可以简化为<code>property as keyof Person</code>，因为<code>person</code>的类型就是<code>Person</code>，所以我们可以直接使用<code>Person</code>类型来代替。这样可以节省一个<code>typeof</code>操作符的使用。</p>
<h3 id="方式三使用objectentries">方式三：使用<code>Object.entries</code></h3>
<p>当然，我们还可以使用<code>Object.entries</code>方法来遍历对象的属性，这样就不需要担心索引签名的问题了。</p>
<pre><code class="language-typescript">function printProperty(person: Person) {
  Object.entries(person).forEach(([key, value]) =&gt; {
    console.log(`${key}: ${value}`);
  });
}
</code></pre>
<p>分析一下这段代码：</p>
<ol>
<li><code>Object.entries</code>方法会返回一个二维数组，其中每个元素又是一个数组，这个数组包含了对象的属性名和属性值。以上面的<code>person</code>对象为例，<code>Object.entries(person)</code>会返回<code>[['name', 'Alice'], ['age', 30]]</code>，</li>
<li>接下来的<code>forEach</code>方法会遍历这个数组，这里使用了一个数组解构操作符<code>([key, value])</code>，将每个属性的名字赋值给key，属性的值赋值给value，</li>
<li>最后使用<code>console.log</code>打印出来。</li>
</ol>
<p>我比较喜欢方式三，简洁易懂，无需额外的操作。</p>
<p>今天就到这里了，觉得有用就点个关注吧，我们下次再见，我要去打弹弓了。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="ZddSignature">
<div>作者：<a href="http://www.cnblogs.com/graphics/" target="_blank">zdd</a></div>
<div>出处：<a href="http://www.cnblogs.com/graphics/" target="_blank">http://www.cnblogs.com/graphics/</a>
<div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.24722222222222223" data-date-updated="2025-07-06 21:41">2025-07-06 15:45</span>&nbsp;
<a href="https://www.cnblogs.com/graphics">前端风云志</a>&nbsp;
阅读(<span id="post_view_count">57</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18968833);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18968833', targetLink: 'https://www.cnblogs.com/graphics/p/18968833', title: 'typescript结构化类型应用两例' })">举报</a>

        </p>
    