
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lanzhi666/p/18669512" title="发布于 2025-01-13 21:57">
    <span role="heading" aria-level="2">java第二章数组学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="java第二章数组">java第二章数组</h2>
<h3 id="数组的概念和特点">数组的概念和特点</h3>
<ul>
<li>数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个 名字命名，并通过编号的方式对这些数据进行统一管理。</li>
<li>特点
<ul>
<li>数组本身是<code>引用数据类型</code>，而数组中的元素可以是<code>任何数据类型</code>，包括基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块<code>连续的空间</code>。占据的空间的大小，取决于数组的长度和数组中元素的类型。</li>
<li>数组中的元素在内存中是依次紧密排列的，有序的。</li>
<li>数组名中引用的是这块连续空间的首地址。</li>
<li>数组，一旦初始化完成，其长度就是确定的。数组的<code>长度一旦确定，就不能修改</code>。</li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快</li>
</ul>
</li>
</ul>
<h3 id="一维数组">一维数组</h3>
<pre><code class="language-java">元素的数据类型[] 一维数组的名称;

元素的数据类型  一维数组名[];
int[] arr;
int arr1[];
double[] arr2;
String[] arr3; 
</code></pre>
<p><strong>数组的声明，需要明确：</strong></p>
<p>（1）数组的维度：在Java中数组的符号是[]，[]表示一维，[][]表示二维。</p>
<p>（2）数组的元素类型：即创建的数组容器可以存储什么数据类型的数据。元素的类型可以是任意的Java的数据类型。例如：int、String、Student等。</p>
<p>（3）数组名：就是代表某个数组的标识符，数组名其实也是变量名，按照变量的命名规范来命名。数组名是个引用数据类型的变量，因为它代表一组数据。</p>
<h3 id="一维数组的初始化">一维数组的初始化</h3>
<h4 id="静态初始化">静态初始化</h4>
<ul>
<li>
<p>如果数组变量的初始化和数组元素的赋值操作同时进行，那就称为静态初始化。</p>
</li>
<li>
<p>静态初始化，本质是用静态数据（编译时已知）为数组初始化。此时数组的长度由静态数据的个数决定。</p>
</li>
<li>
<p><strong>一维数组声明和静态初始化格式1：</strong></p>
<pre><code class="language-java">数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3,...};

或
    
数据类型[] 数组名;
数组名 = new 数据类型[]{元素1,元素2,元素3,...};
</code></pre>
<ul>
<li>new：关键字，创建数组使用的关键字。因为数组本身是引用数据类型，所以要用new创建数组实体。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">int[] arr = new int[]{1,2,3,4,5};//正确
//或
int[] arr;
arr = new int[]{1,2,3,4,5};//正确
</code></pre>
<ul>
<li><strong>一维数组声明和静态初始化格式2：</strong></li>
</ul>
<pre><code class="language-java">数据类型[] 数组名 = {元素1,元素2,元素3...};//必须在一个语句中完成，不能分成两个语句写
</code></pre>
<p>例如，定义存储1，2，3，4，5整数的数组容器</p>
<pre><code class="language-java">int[] arr = {1,2,3,4,5};//正确

int[] arr;
arr = {1,2,3,4,5};//错误
</code></pre>
<h4 id="动态初始化">动态初始化</h4>
<ul>
<li>
<p>概念：数组变量的初始化和数组元素的赋值操作分开进行，即为动态初始化。</p>
<p>格式：</p>
<pre><code class="language-java">数组存储的元素的数据类型[] 数组名字 = new 数组存储的元素的数据类型[长度];

或

数组存储的数据类型[] 数组名字;
数组名字 = new 数组存储的数据类型[长度];

</code></pre>
</li>
<li>
<p>长度确定了就不能再改变</p>
<pre><code class="language-java">int[] arr = new int[5];

int[] arr;
arr = new int[5];
</code></pre>
</li>
</ul>
<h3 id="一维数组的遍历">一维数组的遍历</h3>
<ul>
<li>
<p>搭配for 循环</p>
<pre><code class="language-java">public class Arraydemo1{
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,3,4,5};
        //遍历输出数组中的元素
        for(int i=0; i&lt;arr.length; i++){//length表示数组长度
            System.out.println(arr[i]);
        }
    }
}
</code></pre>
</li>
</ul>
<h3 id="默认值">默认值</h3>
<ul>
<li>数组是引用类型，当我们使用动态初始化方式创建数组时，元素值只是默认值int[]默认值为0。</li>
<li>对于引用数据类型而言，默认初始化值为null（注意与0不同！)</li>
</ul>
<h2 id="二维数组">二维数组</h2>
<ul>
<li>
<p>如果说可以把一维数组当成几何中的<code>线性图形</code>，那么二维数组就相当于是<code>一个表格</code>，像Excel中的表格、围棋棋盘一样。</p>
</li>
<li>
<p>对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。</p>
<ul>
<li>小技巧：二维数组的两个中括号[][]中，第一个可以看做控制行数，第二个可以看做控制列数。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">int[][] arr; //arr是一个二维数组，可以看成元素是int[]一维数组类型的一维数组
</code></pre>
<h3 id="初始化">初始化</h3>
<pre><code class="language-java">//推荐
元素的数据类型[][] 二维数组的名称;

//不推荐
元素的数据类型  二维数组名[][];
//不推荐
元素的数据类型[]  二维数组名[];
</code></pre>
<h3 id="静态初始化-1">静态初始化</h3>
<p>格式：</p>
<pre><code class="language-java">int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};
</code></pre>
<p>示例：</p>
<pre><code class="language-java">int[][] arr = {{1,2,3},{4,5,6},{7,8,9,10}};//声明与初始化必须在一句完成

int[][] arr = new int[][]{{1,2,3},{4,5,6},{7,8,9,10}};

int[][] arr;
arr = new int[][]{{1,2,3},{4,5,6},{7,8,9,10}};

arr = new int[3][3]{{1,2,3},{4,5,6},{7,8,9,10}};//错误，静态初始化右边new 数据类型[][]中不能写数字

public class TwoDimensionalArrayInitialize {
    public static void main(String[] args) {
        //存储多组成绩
        int[][] grades = {
                    {89,75,99,100},
                    {88,96,78,63,100,86},
                    {56,63,58},
                    {99,66,77,88}
                };

        //存储多组姓名
        String[][] names = {
            {"张三","李四", "王五", "赵六"},
            {"刘备","关羽","张飞","诸葛亮","赵云","马超"},
            {"曹丕","曹植","曹冲"},
            {"孙权","周瑜","鲁肃","黄盖"}
        };
    }
}
</code></pre>
<h3 id="动态初始化-1">动态初始化</h3>
<p>如果二维数组的每一个数据，甚至是每一行的列数，需要后期单独确定，那么就只能使用动态初始化方式了。动态初始化方式分为两种格式：</p>
<p><strong>格式1：规则二维表：每一行的列数是相同的</strong></p>
<pre><code class="language-java">//（1）确定行数和列数
元素的数据类型[][] 二维数组名 = new 元素的数据类型[m][n];
	//其中，m:表示这个二维数组有多少个一维数组。或者说一共二维表有几行
	//其中，n:表示每一个一维数组的元素有多少个。或者说每一行共有一个单元格

//此时创建完数组，行数、列数确定，而且元素也都有默认值

//（2）再为元素赋新值
二维数组名[行下标][列下标] = 值;

int[][] arr = new int[3][2];
</code></pre>
<p><strong>格式2：不规则：每一行的列数不一样</strong></p>
<pre><code class="language-java">//（1）先确定总行数
元素的数据类型[][] 二维数组名 = new 元素的数据类型[总行数][];

//此时只是确定了总行数，每一行里面现在是null

//（2）再确定每一行的列数，创建每一行的一维数组
二维数组名[行下标] = new 元素的数据类型[该行的总列数];

//此时已经new完的行的元素就有默认值了，没有new的行还是null

//(3)再为元素赋值
二维数组名[行下标][列下标] = 值;
int[][] arr = new int[3][];
</code></pre>
<ul>
<li>二维数组中有3个一维数组。</li>
<li>每个一维数组都是默认初始化值null (注意：区别于格式1）</li>
<li>可以对这个三个一维数组分别进行初始化：arr[0] = new int[3];    arr[1] = new int[1];   arr[2] = new int[2];</li>
<li>注：<code>int[][]arr = new int[][3]; </code> //非法</li>
</ul>
<h3 id="二维数组遍历">二维数组遍历</h3>
<ul>
<li>格式：</li>
</ul>
<pre><code class="language-java">双重for 循环
for(int i=0; i&lt;二维数组名.length; i++){ //二维数组对象.length
    for(int j=0; j&lt;二维数组名[i].length; j++){//二维数组行对象.length
        System.out.print(二维数组名[i][j]);
    }
    System.out.println();
}
</code></pre>
<pre><code class="language-java">//1、声明二维数组，并确定行数和列数
		int[][] arr = new int[4][5];
		
		//2、确定元素的值
		for (int i = 0; i &lt; arr.length; i++) {
			for (int j = 0; j &lt; arr.length; j++) {
				arr[i][j] = i + 1;
			}
		}	
</code></pre>
<pre><code class="language-java">public class Test{
    public static void main(String[] args) {
        //存储3个小组的学员的成绩，分开存储，使用二维数组。
        int[][] scores = {
                {85,96,85,75},
                {99,96,74,72,75},
                {52,42,56,75}
        };

        System.out.println("一共有" + scores.length +"组成绩.");
        for (int i = 0; i &lt; scores.length; i++) {
            System.out.print("第" + (i+1) +"组有" + scores[i].length + "个学员，成绩如下：");
            for (int j = 0; j &lt; scores[i].length; j++) {
                System.out.print(scores[i][j]+"\t");
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="数组常见算法">数组常见算法</h3>
<p><strong>举例1：</strong>数组统计：求总和、均值</p>
<pre><code class="language-java">public class TestArrayElementSum {
    public static void main(String[] args) {
        int[] arr = {4,5,6,1,9};
        //求总和、均值
        int sum = 0;//因为0加上任何数都不影响结果
        for(int i=0; i&lt;arr.length; i++){
            sum += arr[i];
        }
        double avg = (double)sum/arr.length;

        System.out.println("sum = " + sum);
        System.out.println("avg = " + avg);
    }
}
</code></pre>
<p><strong>举例2：</strong>求数组元素的总乘积</p>
<pre><code class="language-java">public class TestArrayElementMul {
    public static void main(String[] args) {
        int[] arr = {4,5,6,1,9};

        //求总乘积
        long result = 1;//因为1乘以任何数都不影响结果
        for(int i=0; i&lt;arr.length; i++){
            result *= arr[i];
        }

        System.out.println("result = " + result);
    }
}
</code></pre>
<p><strong>举例3：</strong>求数组元素中偶数的个数</p>
<pre><code class="language-java">public class TestArrayElementEvenCount {
    public static void main(String[] args) {
        int[] arr = {4,5,6,1,9};
        //统计偶数个数
        int evenCount = 0;
        for(int i=0; i&lt;arr.length; i++){
            if(arr[i]%2==0){
                evenCount++;
            }
        }

        System.out.println("evenCount = " + evenCount);
    }
}
</code></pre>
<p><strong>举例4：</strong>求数组元素的最大值</p>
<pre><code class="language-java">public class TestArrayMax {
    public static void main(String[] args) {
        int[] arr = {4,5,6,1,9};
        //找最大值
        int max = arr[0];
        for(int i=1; i&lt;arr.length; i++){//此处i从1开始，是max不需要与arr[0]再比较一次了
            if(arr[i] &gt; max){
                max = arr[i];
            }
        }

        System.out.println("max = " + max);
    }
}
</code></pre>
<p><strong>举例5：</strong>找最值及其第一次出现的下标:</p>
<pre><code class="language-java">public class TestMaxIndex {
    public static void main(String[] args) {
        int[] arr = {4,5,6,1,9};
        //找最大值以及第一个最大值下标
        int max = arr[0];
        int index = 0;
        for(int i=1; i&lt;arr.length; i++){
            if(arr[i] &gt; max){
                max = arr[i];
                index = i;
            }
        }

        System.out.println("max = " + max);
        System.out.println("index = " + index);
    }
}
</code></pre>
<h3 id="数组元素的反转">数组元素的反转</h3>
<p><strong>实现思想：</strong>数组对称位置的元素互换。</p>
<pre><code class="language-java">public class TestArrayReverse1 {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5};
        System.out.println("反转之前：");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }

        //反转
         /*
        思路：首尾对应位置的元素交换
        （1）确定交换几次
           次数 = 数组.length / 2
        （2）谁和谁交换
        for(int i=0; i&lt;次数; i++){
             int temp = arr[i];
             arr[i] = arr[arr.length-1-i];
             arr[arr.length-1-i] = temp;
        }
         */
        for(int i=0; i&lt;arr.length/2; i++){
            int temp = arr[i];
            arr[i] = arr[arr.length-1-i];
            arr[arr.length-1-i] = temp;
        }

        System.out.println("反转之后：");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }

}
</code></pre>
<pre><code class="language-java">双指针
public class TestArrayReverse2 {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5};
        System.out.println("反转之前：");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }

        //反转
        //左右对称位置交换
        for(int left=0,right=arr.length-1; left&lt;right; left++,right--){
            //首  与  尾交换
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
        }

        System.out.println("反转之后：");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
</code></pre>
<h3 id="数组的元素查找">数组的元素查找</h3>
<p><strong>1、顺序查找</strong></p>
<pre><code class="language-java">public class TestArrayOrderSearch {
    //查找value第一次在数组中出现的index
    public static void main(String[] args){
        int[] arr = {4,5,6,1,9};
        int value = 1;
        int index = -1;

        for(int i=0; i&lt;arr.length; i++){
            if(arr[i] == value){
                index = i;
                break;
            }
        }

        if(index==-1){
            System.out.println(value + "不存在");
        }else{
            System.out.println(value + "的下标是" + index);
        }
    }
}
</code></pre>
<p><strong>2、二分查找</strong></p>
<pre><code class="language-java">//二分法查找：要求此数组必须是有序的。
int[] arr3 = new int[]{-99,-54,-2,0,2,33,43,256,999};
boolean isFlag = true;
int value = 256;
//int value = 25;
int head = 0;//首索引位置
int end = arr3.length - 1;//尾索引位置
while(head &lt;= end){
    int middle = (head + end) / 2;
    if(arr3[middle] == value){
        System.out.println("找到指定的元素，索引为：" + middle);
        isFlag = false;
        break;
    }else if(arr3[middle] &gt; value){
        end = middle - 1;
    }else{//arr3[middle] &lt; value
        head = middle + 1;
    }
}
if(isFlag){
    System.out.println("未找打指定的元素");
}

</code></pre>
<h3 id="排序算法">排序算法</h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p><strong>排序思想：</strong></p>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</p>
</li>
</ol>
<p><strong>动态演示：</strong><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener nofollow">https://visualgo.net/zh/sorting</a></p>
<pre><code class="language-java">/*
1、冒泡排序（最经典）
思想：每一次比较“相邻（位置相邻）”元素，如果它们不符合目标顺序（例如：从小到大），
     就交换它们，经过多轮比较，最终实现排序。
	 （例如：从小到大）	 每一轮可以把最大的沉底，或最小的冒顶。
	 
过程：arr{6,9,2,9,1}  目标：从小到大

第一轮：
	第1次，arr[0]与arr[1]，6&gt;9不成立，满足目标要求，不交换
	第2次，arr[1]与arr[2]，9&gt;2成立，不满足目标要求，交换arr[1]与arr[2] {6,2,9,9,1}
	第3次，arr[2]与arr[3]，9&gt;9不成立，满足目标要求，不交换
	第4次，arr[3]与arr[4]，9&gt;1成立，不满足目标要求，交换arr[3]与arr[4] {6,2,9,1,9}
	第一轮所有元素{6,9,2,9,1}已经都参与了比较，结束。
	第一轮的结果：第“一”最大值9沉底（本次是后面的9沉底），即到{6,2,9,1,9}元素的最右边

第二轮：
	第1次，arr[0]与arr[1]，6&gt;2成立，不满足目标要求，交换arr[0]与arr[1] {2,6,9,1,9}
	第2次，arr[1]与arr[2]，6&gt;9不成立，满足目标要求，不交换
	第3次：arr[2]与arr[3]，9&gt;1成立，不满足目标要求，交换arr[2]与arr[3] {2,6,1,9,9}
	第二轮未排序的所有元素 {6,2,9,1}已经都参与了比较，结束。
	第二轮的结果：第“二”最大值9沉底（本次是前面的9沉底），即到{2,6,1,9}元素的最右边
第三轮：
	第1次，arr[0]与arr[1]，2&gt;6不成立，满足目标要求，不交换
	第2次，arr[1]与arr[2]，6&gt;1成立，不满足目标要求，交换arr[1]与arr[2] {2,1,6,9,9}
	第三轮未排序的所有元素{2,6,1}已经都参与了比较，结束。
	第三轮的结果：第三最大值6沉底，即到 {2,1,6}元素的最右边
第四轮：
	第1次，arr[0]与arr[1]，2&gt;1成立，不满足目标要求，交换arr[0]与arr[1] {1,2,6,9,9}
	第四轮未排序的所有元素{2,1}已经都参与了比较，结束。
	第四轮的结果：第四最大值2沉底，即到{1,2}元素的最右边

*/
public class Test19BubbleSort{
    public static void main(String[] args){
        int[] arr = {6,9,2,9,1};

        //目标：从小到大
        //冒泡排序的轮数 = 元素的总个数 - 1
        //轮数是多轮，每一轮比较的次数是多次，需要用到双重循环，即循环嵌套
        //外循环控制 轮数，内循环控制每一轮的比较次数和过程
        for(int i=1; i&lt;arr.length; i++){ //循环次数是arr.length-1次/轮
			/*
			假设arr.length=5
			i=1,第1轮，比较4次
				arr[0]与arr[1]
				arr[1]与arr[2]
				arr[2]与arr[3]
				arr[3]与arr[4]
				
				arr[j]与arr[j+1]，int j=0;j&lt;4; j++
				
			i=2,第2轮，比较3次
				arr[0]与arr[1]
				arr[1]与arr[2]
				arr[2]与arr[3]
				
				arr[j]与arr[j+1]，int j=0;j&lt;3; j++
				
			i=3,第3轮，比较2次
				arr[0]与arr[1]
				arr[1]与arr[2]
				
				arr[j]与arr[j+1]，int j=0;j&lt;2; j++
			i=4,第4轮，比较1次
				arr[0]与arr[1]
			
				arr[j]与arr[j+1]，int j=0;j&lt;1; j++
				
				int j=0; j&lt;arr.length-i; j++
			*/
            for(int j=0; j&lt;arr.length-i; j++){
                //希望的是arr[j] &lt; arr[j+1]
                if(arr[j] &gt; arr[j+1]){
                    //交换arr[j]与arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }

        //完成排序，遍历结果
        for(int i=0; i&lt;arr.length; i++){
            System.out.print(arr[i]+"  ");
        }
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013573426962962962" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 21:58">2025-01-13 21:57</span>&nbsp;
<a href="https://www.cnblogs.com/lanzhi666">晚枫cy</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18669512" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18669512);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18669512', targetLink: 'https://www.cnblogs.com/lanzhi666/p/18669512', title: 'java第二章数组学习' })">举报</a>
</div>
        