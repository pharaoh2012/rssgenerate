
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18934606" title="发布于 2025-06-24 20:14">
    <span role="heading" aria-level="2">[车载以太网] SOME/IP 参数和数据结构的序列化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="序">序</h1>
<ul>
<li>本篇系对以太网SOME/IP协议的参数数据结构的序列化/反序列化的解读。</li>
</ul>
<h1 id="概述someip-参数和数据结构的序列化">概述：SOME/IP 参数和数据结构的序列化</h1>
<h2 id="大小端字节序">大小端/字节序</h2>
<ul>
<li>
<p>每个参数（parameter）的<strong>字节顺序</strong>由接口定义进行规定。</p>
</li>
<li>
<p>所有的 SOME/IP Header 字段，应该以网络字节序(<strong>大端</strong>)编码。</p>
</li>
</ul>
<blockquote>
<p>PRS_SOME/IP_00368</p>
</blockquote>
<ul>
<li>Payload中参数的字节顺序由配置决定。</li>
</ul>
<blockquote>
<p>PRS_SPME/IP_00026</p>
</blockquote>
<h2 id="参数和数据结构的序列化">参数和数据结构的序列化</h2>
<ul>
<li><strong>序列化</strong>（<code>Serialization</code>）是指将<strong>数据结构</strong>或<strong>对象状态</strong>转换为<strong>二进制串（字节数组）</strong>的过程。</li>
</ul>
<blockquote>
<p><strong>SOME/IP协议</strong>在传输过程中也自然需要进行<strong>序列化</strong>和<strong>反序列化</strong>。</p>
</blockquote>
<ul>
<li><strong>SOME/IP</strong>需要基于<strong>通信接口规范</strong>定义的参数列表进行序列化。</li>
</ul>
<blockquote>
<p>接口规范明确了<code>PDU</code>（<strong>协议数据单元</strong>）中所有数据结构的精确位置，并且在设计时必须考虑<strong>存储器对齐</strong>的问题。</p>
</blockquote>
<ul>
<li><strong>对齐操作</strong>通过在数据项之后<strong>添加填充元素</strong>来【调整数据的起始位置】，以确保数据从特定的、对齐的内存地址开始。</li>
</ul>
<blockquote>
<p>这是因为在某些处理器架构中，当数据从某个数的倍数（例如32位的倍数）地址开始时，数据访问会更加高效。</p>
</blockquote>
<ul>
<li>如果可变大小数据不是序列化数据流中的最后一个元素，则：应该通过在可变大小数据后面插入填充元素来实现数据的对齐。</li>
</ul>
<blockquote>
<p>PRS_SOMEIP_00611 / RS_SOMEIP_00028 , RS_SOMEIP_00029</p>
</blockquote>
<ul>
<li>请注意，Padding 值未被定义。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618111338657-1206210220.png" alt="" loading="lazy"></p>
<blockquote>
<p>Member2: 以 UInt8 元素组成的一维可变长数组 / Member5: 以 UInt8 元素组成的一维可变长数组</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618111350350-728769979.png" alt="" loading="lazy"></p>
<blockquote>
<p>Member2: 以 UInt8 元素组成的一维可变长数组 / Member5: 以 UInt8 元素组成的一维可变长数组</p>
</blockquote>
<ul>
<li>
<p>对齐应该能总是被计算出，从 SOME/IP 报文的起始处。</p>
</li>
<li>
<p><strong>固定长度数据元素</strong>后面不得有填充元素，以确保后面数据的对齐。</p>
</li>
</ul>
<blockquote>
<p>如果定长数据元素后面的数据被填充，则这必须被显式地考虑进数据类型定义中。</p>
</blockquote>
<ul>
<li><strong>可变长度数据元素</strong>后面的数据对齐应为8、16、32、64、128或256位。</li>
</ul>
<blockquote>
<p>RS_SOMEIP_000028 / RS_SOMEIP_000029</p>
</blockquote>
<h2 id="基本数据类型">基本数据类型</h2>
<ul>
<li>应支持以下基本数据类型：</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Size [bit]</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>TRUE/FALSE value</td>
<td>8</td>
<td>FALSE (0), TRUE (1)</td>
</tr>
<tr>
<td>uint8</td>
<td>unsigned Integer</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td>unsigned Integer</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>unsigned Integer</td>
<td>32</td>
<td></td>
</tr>
<tr>
<td>sint8</td>
<td>signed Integer</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>sint16</td>
<td>signed Integer</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>sint32</td>
<td>signed Integer</td>
<td>32</td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>floating point number</td>
<td>32</td>
<td>IEEE 754 binary32 (Single Precision)</td>
</tr>
<tr>
<td>float64</td>
<td>floating point number</td>
<td>64</td>
<td>IEEE 754 binary64 (Double Precision)</td>
</tr>
</tbody>
</table>
<ul>
<li>每个参数的字节顺序由接口定义进行规定。</li>
</ul>
<h2 id="结构化数据类型-结构体">结构化数据类型 (结构体)</h2>
<ul>
<li><strong>结构体的序列化</strong>应尽可能接近<strong>内存布局</strong>。</li>
</ul>
<blockquote>
<p>这意味着<strong>参数</strong>应按顺序<strong>序列化</strong>到<strong>缓冲区</strong>中。<br>
对于结构体来说，特别要考虑正确的<strong>内存对齐</strong>。<br>
如果需要对齐，请在接口定义中插入<strong>保留/填充元素</strong>，因为SOME/IP实现不会自动添加此类填充。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618110803414-2070333840.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>SOME/IP实现不应自动插入虚拟/填充元素。</p>
</li>
<li>
<p>如果SOME/IP实现遇到导致<code>PDU</code>未正确对齐的接口规范（例如，由于未对齐的结构体），SOME/IP实现应在发现<strong>不对齐的结构体</strong>时发出警告，<strong>但不应在生成代码时失败</strong>。</p>
</li>
<li>
<p>结构体的序列化应按照规范精确地进行。</p>
</li>
<li>
<p>可以在结构体前面添加一个8位、16位或32位的【可选】的【长度字段】，其取决于接口规范的配置。</p>
</li>
</ul>
<blockquote>
<p>如果未指定长度字段的长度，则必须假定长度为0，并且消息中没有长度字段。</p>
</blockquote>
<ul>
<li><strong>结构体的长度字段</strong>描述了<strong>结构体的字节数</strong>。</li>
</ul>
<blockquote>
<p>如果长度大于接口定义中指定的结构体长度，则只有接口规范中指定的字节将被解释，其他字节将根据长度字段被跳过。<br>
这样可以实现可扩展的结构体，从而更好地实现接口的迁移。</p>
</blockquote>
<ul>
<li>
<p>如果长度效于所有结构体成员的长度之和，且接收者无法在本地提供缺失数据的替换时，则 反序列化应被中止，且该报文应被视为是畸形的。</p>
</li>
<li>
<p>结构体的序列化应遵循结构化的数据类型的【深度优先遍历】。</p>
</li>
</ul>
<h2 id="字符串">字符串</h2>
<blockquote>
<p>如下需求是定长字符串和动态长度字符串的<strong>共同点</strong>。</p>
</blockquote>
<ul>
<li>[PRS_SOMEIP_00372] 不同的Unicode字符集编码应被支持，包括： UTF-8 / UTF-16BE / UTF-16LE</li>
</ul>
<blockquote>
<p>PRS_SOMEIP_00372 / RS_SOMEIP_00038</p>
</blockquote>
<ul>
<li>[PRS_SOMEIP_00948] UTF-8 字符串应以 <code>\0</code> 字符 结束。</li>
</ul>
<blockquote>
<p>这意味着字符串应以 1 个 <code>0x00</code> 字节结束。<br>
RS_SOMEIP_00038</p>
</blockquote>
<ul>
<li>
<p>[PRS_SOMEIP_00084] UTF-16LE 和 UTF-16BE 字符串应以“<code>\0</code>”字符结尾。这意味着它们应以（至少）两个<code>0x00</code>字节结束</p>
</li>
<li>
<p>[PRS_SOMEIP_00085] UTF-16LE和UTF-16BE字符串的应是偶数的长度(<code>even length</code>)。</p>
</li>
<li>
<p>[PRS_SOMEIP_00086] 应忽略UTF-16LE和UTF-16BE有一个奇数长度的最后一个字节将被忽略。</p>
</li>
<li>
<p>[PRS_SOMEIP_00087] 所有字符串应始终以包含字符串的待序列化数组的前三个（UTF-8）或两个（UTF-16）字节中的<strong>字节顺序标记</strong>（<code>BOM</code>）开头。</p>
</li>
</ul>
<blockquote>
<p><code>BOM</code>应包含在固定长度字符串和动态长度字符串中。<br>
<code>BOM</code>允许检测所使用的编码。</p>
</blockquote>
<h3 id="固定长度的字符串">固定长度的字符串</h3>
<ul>
<li>[PRS_SOMEIP_00760] 固定长度的字符串可以以可选的【长度字段】开头。 PRS_SOMEIP_00760</li>
</ul>
<blockquote>
<p>Upstream requirements: RS_SOMEIP_00038</p>
</blockquote>
<ul>
<li>
<p>[PRS_SOMEIP_00373] 尽管字符串长度固定，但应以“<code>\0</code>”字符结尾</p>
</li>
<li>
<p>[PRS_SOMEIP_00374] 必须在数据类型定义中指定字符串（包括“<code>\0</code>”）的长度（以字节为单位）</p>
</li>
</ul>
<h3 id="动态长度的字符串">动态长度的字符串</h3>
<ul>
<li>[PRS_SOMEIP_00089] 动态长度的字符串应以长度字段开头。（强制要求）</li>
</ul>
<blockquote>
<p>长度以<strong>字节</strong>为单位</p>
</blockquote>
<ul>
<li>
<p>[PRS_SOMEIP_00090] <strong>长度字段</strong>放置在BOM之前，BOM包含在长度中</p>
</li>
<li>
<p>[PRS_SOMEIP_00091] 字符串以“<code>\0</code>”结尾。 PRS_SOMEIP_00091</p>
</li>
</ul>
<blockquote>
<ul>
<li>注意，字符串的<strong>最大字节数</strong>（包括以“\0”结尾）也应从<strong>数据类型定义</strong>中得出。</li>
</ul>
</blockquote>
<ul>
<li>
<p>[PRS_SOMEIP_00092] : 对于 [PRS_SOMEIP_00084], [PRS_SOMEIP_00085] 和 [PRS_SOMEIP_00086] 条款，也适用于具有动态长度的字符串</p>
</li>
<li>
<p>[PRS_SOMEIP_00093] 动态长度字符串的长度字段应为8、16或32位。这应由配置决定。</p>
</li>
<li>
<p>[PRS_SOMEIP_00094] 如果未配置该字段，则添加在字符串前面的长度字段的长度为32位（长度字段的默认长度）。</p>
</li>
<li>
<p>[PRS_SOMEIP_00095] <strong>长度字段的值</strong>中不考虑字符串长度字段的长度；即 长度字段本身不计数。</p>
</li>
</ul>
<h2 id="数组">数组</h2>
<h3 id="固定长度的数组">固定长度的数组</h3>
<ul>
<li>
<p>固定长度数组更容易在非常小的设备中使用。使用动态长度数组的ECU可能需要更多资源。</p>
</li>
<li>
<p>[PRS_SOMEIP_00944] 固定长度的数组可以以可选的长度字段开头</p>
</li>
</ul>
<blockquote>
<p>注意，固定大小数组的溢出只能通过长度字段检测。</p>
</blockquote>
<h4 id="一维数组">一维数组</h4>
<ul>
<li>[PRS_SOMEIP_00099] 具有固定长度“<code>n</code>”的一维数组应恰好包含相同类型的“<code>n</code>”个元素。可选的长度字段可以位于第1个元素之前</li>
</ul>
<blockquote>
<p>注意，如果为特定的固定长度数组定义了【长度字段】，则该数组在总线上表示为长度字段和相同数据类型的n个元素的集合的组合<br>
[PRS_SOMEIP_00099]的布局如图4.7所示。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618135011929-151340719.png" alt="" loading="lazy"></p>
<h4 id="多维数组">多维数组</h4>
<ul>
<li>[PRS_SOMEIP_00101] 多维数组的序列化遵循C/C++编程语言中多维数组的内存布局（以行为主的顺序 / row-major order）</li>
</ul>
<blockquote>
<p>注意，如果为特定的多维固定长度数组定义了【长度字段】，则该数组在总线上表示为长度字段和n个集合的组合，每个集合由一个长度字段和相同数据类型的m个元素组成。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618135325497-1002482427.png" alt="" loading="lazy"></p>
<h3 id="动态长度的数组">动态长度的数组</h3>
<ul>
<li>
<p>[PRS_SOMEIP_00375] 具有动态长度的数组布局应基于固定长度数组的布局</p>
</li>
<li>
<p>[PRS_SOMEIP_00376] 动态长度数组开头的长度字段应该用于指定数组的长度（以字节为单位）</p>
</li>
<li>
<p>[PRS_SOMEIP_00107] 动态长度数组应具有长度为8、16或32位的长度字段。这应由配置决定</p>
</li>
<li>
<p>[PRS_SOMEIP_00377] 长度不包括长度字段的大小。</p>
</li>
</ul>
<blockquote>
<p>如果长度字段的长度设置为0位，则数组中的元素数量必须固定；因此，此时是固定长度的数组。 （参考图 4.9 / 4.10）</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618135817894-2113302761.png" alt="" loading="lazy"></p>
<ul>
<li>在一维数组中，使用一个长度字段，该字段携带用于数组的字节数。</li>
<li>静态长度元素的数量，可以很容易地通过除以元素的大小来计算。</li>
<li>在动态长度元素的情况下，无法直接计算元素的数量，必须按顺序解析元素。</li>
</ul>
<blockquote>
<p>图4.10显示了动态长度多维数组的结构。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250618140111633-2033820798.png" alt="" loading="lazy"></p>
<ul>
<li>[PRS_SOMEIP_00114]</li>
</ul>
<blockquote>
<ul>
<li>在多维数组中，每个不同维度的子数组都应有自己的长度字段。</li>
<li>如果需要静态缓冲区大小分配，数据类型定义应定义每个维度的最大长度。</li>
<li>理由：在以字节为单位测量长度时，可以在<strong>反序列化</strong>中跳过复杂的多维数组。</li>
<li>SOME/IP还支持同一维度中列的不同长度和行的不同长度。见图4.10中的k_1和k_2。每个动态长度数组前面都需要有一个长度指示器。这适用于外部和所有内部/嵌套数组。</li>
</ul>
</blockquote>
<ul>
<li>[PRS_SOMEIP_00945] 如果未配置，则添加在动态长度数组前面的长度字段的长度为32位（长度字段的默认长度）。</li>
</ul>
<h2 id="枚举类型enumeration">枚举类型(Enumeration)</h2>
<ul>
<li>[PRS_SOMEIP_00705] 在SOME/IP中不考虑枚举。枚举应作为无符号整数数据类型传输</li>
</ul>
<h2 id="位域bit-field">位域(Bit Field)</h2>
<ul>
<li>[PRS_SOMEIP_00300] 位字段应作为无符号数据类型uint8/uint16/uint32/uint64传输。</li>
</ul>
<blockquote>
<ul>
<li>数据类型定义将能够定义每个位的名称和值</li>
</ul>
</blockquote>
<h2 id="union--variant">Union / Variant</h2>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.autosar.org/fileadmin/standards/R24-11/FO/AUTOSAR_FO_PRS_SOMEIPProtocol.pdf" target="_blank" rel="noopener nofollow">SOME/IP Protocol Specification - Autosar</a></li>
</ul>
<blockquote>
<p><a href="https://www.autosar.org/fileadmin/standards/R24-11/FO/AUTOSAR_FO_PRS_SOMEIPProtocol.pdf" target="_blank" rel="noopener nofollow">https://www.autosar.org/fileadmin/standards/R24-11/FO/AUTOSAR_FO_PRS_SOMEIPProtocol.pdf</a></p>
</blockquote>
<ul>
<li><a href="https://www.autosar.org/fileadmin/standards/R19-11/FO/AUTOSAR_RS_SOMEIPProtocol.pdf" target="_blank" rel="noopener nofollow">RequirementsonSOME/IP Protocol - Autosar</a></li>
</ul>
<blockquote>
<p><a href="https://www.autosar.org/fileadmin/standards/R19-11/FO/AUTOSAR_RS_SOMEIPProtocol.pdf" target="_blank" rel="noopener nofollow">https://www.autosar.org/fileadmin/standards/R19-11/FO/AUTOSAR_RS_SOMEIPProtocol.pdf</a></p>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-24 20:15">2025-06-24 20:14</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18934606);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18934606', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18934606', title: '[车载以太网] SOME/IP 参数和数据结构的序列化' })">举报</a>
</div>
        