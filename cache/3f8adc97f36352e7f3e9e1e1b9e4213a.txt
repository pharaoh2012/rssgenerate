
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TheMagicalRainbowSea/p/18703659" title="发布于 2025-02-08 09:36">
    <span role="heading" aria-level="2">十二. Redis 集群操作配置(超详细配图，配截图详细说明)</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="十二-redis-集群操作配置超详细配图配截图详细说明">十二. Redis 集群操作配置(超详细配图，配截图详细说明)</h1>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#十二-redis-集群操作配置超详细配图配截图详细说明" rel="noopener nofollow">十二. Redis 集群操作配置(超详细配图，配截图详细说明)</a></li><li><a href="#1-为什么需要集群-高可用性" rel="noopener nofollow">1. 为什么需要集群-高可用性</a></li><li><a href="#2-集群概述及其搭建" rel="noopener nofollow">2. 集群概述(及其搭建)</a></li><li><a href="#3-redis-集群的使用" rel="noopener nofollow">3. Redis 集群的使用</a></li><li><a href="#4-redis-集群故障恢复" rel="noopener nofollow">4. Redis 集群故障恢复</a></li><li><a href="#5-redis-集群的-jedis-开发使用java程序连接-redis-同时开启集群" rel="noopener nofollow">5. Redis 集群的 Jedis 开发(使用Java程序连接 Redis 同时开启集群)</a></li><li><a href="#6-redis-集群的优缺点" rel="noopener nofollow">6. Redis 集群的优缺点</a></li><li><a href="#7-补充" rel="noopener nofollow">7. 补充：</a></li><li><a href="#8-最后" rel="noopener nofollow">8. 最后：</a></li></ul></div><p></p>
<hr>
<h1 id="1-为什么需要集群-高可用性">1. 为什么需要集群-高可用性</h1>
<p><strong>为什么需要集群-高可用性：</strong></p>
<ol>
<li>生产环境的实际需求和问题：
<ol>
<li>容量不够，redis 如何进行扩容。</li>
<li>并发写操作，redis 如何分摊。</li>
<li>主从模式，薪火相传模式，主机宕机，会导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址，端口等信息。</li>
</ol>
</li>
<li>传统解决方案 代理主机来解决</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418235-1523040879.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>上图解图：</strong></p>
<blockquote>
<ol>
<li>客户端请求先到代理服务器</li>
<li>由代理服务器进行请求转发到对应的业务处理器</li>
<li>为了高可用，代理服务，A服务，B服务，C服务都需要搭建主从结构(至少是<strong>一主一从</strong> 这样就需求搭建至少 8 台服务器)。</li>
<li>这种方案的缺点是：成本高，维护困难，如果是一主多从，成本就会更高。</li>
</ol>
</blockquote>
<p><strong>redis3.0 提供解决方案 无中心化集群配置：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418195-708817066.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li>各个 Redis 服务仍然采用主从结构。</li>
<li>各个 Redis 服务是连通的，<strong>任何一台服务器，都可以作为请求入口</strong> 。</li>
<li>各个 Redis 服务器因为是连通的，可以进行请求转发</li>
<li>这种方式，就<strong>无中心化</strong> 集群配置，可以看到，只需要 6 台服务器即可搞定。</li>
<li><strong>无中心化集群配置</strong> ，还会根据 key 值，计算 slot ，把数据分散到不同的主机，从而缓解单个主机的存取压力</li>
<li>Redis 推荐使用无中心化集群配置。</li>
<li>在实际生成环境，各个 Redis 服务器，应当部署到不同的机器(防止机器宕机，主从复制失效)。</li>
</ol>
<h1 id="2-集群概述及其搭建">2. 集群概述(及其搭建)</h1>
<ol>
<li>Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 Redis 节点，将整个数据库分布存储在这个  N 个节点中，每个节点存储总数居的 1 / N</li>
<li>Redis 集群通过分区(partition) 来提供一定程度的可用性(availability) ，即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</li>
</ol>
<p><strong>Redis 集群搭建：实操演示：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417646-24939015.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li><strong><code>redis.conf</code> 配置修改</strong></li>
</ol>
<pre><code class="language-properties">cluster-enabled yes        打开集群模式
cluster-config-file nodes-6379.conf    设定节点配置文件名
cluster-node-timeout 15000      设定节点失联时间，超过该时间（毫秒），集群自动进行主 从切换
</code></pre>
<ol start="2">
<li><code>vi /rainbowsea/redis6379.conf</code> ,  删除不必要的内容   增加 cluster 配置,  文件最后内容,如图</li>
</ol>
<pre><code class="language-properties">include /rainbowsea/redis.conf
pidfile "/var/run/redis_6379.pid"
port 6379
dbfilename "dump6379.rdb"
masterauth rainbowsea
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418013-383979244.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418143-2101153352.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">[root@localhost rainbowsea]# cp redis6379.conf redis6380.conf 
[root@localhost rainbowsea]# cp redis6379.conf redis6381.conf 
[root@localhost rainbowsea]# cp redis6379.conf redis6389.conf 
[root@localhost rainbowsea]# cp redis6379.conf redis6390.conf 
[root@localhost rainbowsea]# cp redis6379.conf redis6391.conf 
[root@localhost rainbowsea]# 

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417975-1320413438.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418022-1444480024.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="3">
<li><strong>使用查找替换修改另外 5 个文件</strong></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417812-330866632.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418096-1310955482.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">换指令    :%s/6379/6380
</code></pre>
<blockquote>
<p>其它几个文件以此操作即可, 操作的时候,一定要小心, 最后建议再检查一下</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418015-1469019078.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417745-117761839.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417104-1469935517.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418024-186357830.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418028-2006766398.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>所有的都要加上这个 <code>masterauth rainbowsea</code>  加上 Redis 的密码，没有设置密码的则不用配置这个。</p>
<p>所有的都要加上这个 <code>masterauth rainbowsea</code>  加上 Redis 的密码，没有设置密码的则不用配置这个。</p>
<p>所有的都要加上这个 <code>masterauth rainbowsea</code>  加上 Redis 的密码，没有设置密码的则不用配置这个。</p>
<pre><code class="language-properties">include /rainbowsea/redis.conf
pidfile "/var/run/redis_6379.pid"
port 6379
dbfilename "dump6379.rdb"
masterauth rainbowsea
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
</code></pre>
<ol start="4">
<li><strong>启动 6 个 Redis 服务</strong></li>
</ol>
<pre><code class="language-sh">[root@localhost rainbowsea]# redis-server /rainbowsea/redis6379.conf
[root@localhost rainbowsea]# redis-server /rainbowsea/redis6380.conf
[root@localhost rainbowsea]# redis-server /rainbowsea/redis6381.conf
[root@localhost rainbowsea]# redis-server /rainbowsea/redis6389.conf
[root@localhost rainbowsea]# redis-server /rainbowsea/redis6390.conf
[root@localhost rainbowsea]# redis-server /rainbowsea/redis6391.conf
[root@localhost rainbowsea]# ps -aux | grep redis

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418011-1652200207.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418185-2023317765.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="5">
<li><strong>将六个节点合成一个集群</strong></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418158-555912589.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418151-331038708.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>进入到该路径下后，将六个节点合成一个集群的指令:</p>
<p>如下这个是 Redis 没有配置密码的，指令</p>
<pre><code class="language-sh">redis-cli --cluster create --cluster-replicas 1 192.168.76.147:6379 192.168.76.147:6380 192.168.76.147:6381 192.168.76.147:6389 192.168.76.147:6390 192.168.76.147:6391
</code></pre>
<p>如下这个是 Redis 配置了密码的，指令</p>
<pre><code class="language-sh">redis-cli --cluster create -a rainbowsea --cluster-replicas 1 192.168.76.147:6379 192.168.76.147:6380 192.168.76.147:6381 192.168.76.147:6389 192.168.76.147:6390 192.168.76.147:6391
</code></pre>
<p><strong>注意事项和细节：</strong></p>
<ol>
<li>组合之前，确保所有(你要使用上的端口的) Redis服务器都是启动的，同时在 root 目录下(我这里是 root 配置的) <code>nodes-xxxx.conf</code> 文件都生成正常。</li>
<li>此时不可以用 127.0.0.1 ，需要使用真实的 IP地址(就是你连接 Linux 的地址，Linux 当中使用<code>ifconfig</code> 指令查询到的地址)，在真实生产环境 IP都是独立的。</li>
<li><code>replicas 1</code> 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</li>
<li>搭建加群如果没有成功，把 <code>sentinel</code> 进程关闭掉，再试一下。</li>
<li>分许主从对应关系。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417979-688318610.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417916-863104122.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>分析主从对应关系：如下</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418098-98807450.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417765-1277424985.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="6">
<li><strong>集群方式登录：</strong></li>
</ol>
<p>指令: redis-cli -c -p 6379</p>
<p>指令: cluster nodes 命令查看集群信息, 主从的对应关系, 主要看这里我标注的颜色</p>
<pre><code class="language-sh">[root@localhost src]# redis-cli -c -p 6379
127.0.0.1:6379&gt; auth rainbowsea
127.0.0.1:6379&gt; cluster nodes
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417750-1603751334.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417968-917488754.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>注意事项和细节：</strong></p>
<pre><code class="language-sh">[root@localhost src]# redis-cli -c -p 6379
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417565-131904149.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li>一个集群至少要有三个主节点。</li>
<li>选项 <code>--cluster-replicas 1</code> 表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li><strong>分配原则：</strong> 尽量保证主服务器和从服务器各自运行在不同的 IP 地址(机器)，防止机器故障导致主从机制失效，高可用性得不到保障。</li>
</ol>
<h1 id="3-redis-集群的使用">3. Redis 集群的使用</h1>
<p>什么是 slots：</p>
<p>Redis 集群启动后,  你会看到如下提示：</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417957-1363904529.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418130-2104685934.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li>一个 Redis 集群包含了 <strong><code>16384</code></strong>  个插槽(hash slot) ，编号从 <code>0-16383</code> ，Redis 中的每个键都属于这 16384 个插槽的其中一个。<strong>注意：这里虽然只有 16384个插槽，但是并不是只能插入 16384个键，多个不同的键可以插入到同一个插槽的，并不是一个插槽一个键的</strong> 。</li>
<li>集群使用公式 <strong><code>CRC16(key) % 16384</code></strong> 来计算键 key 属于哪个槽，其中 CRC16(key) 语句用于计算键 key 的 CRC16的校验和</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418122-1900883587.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="3">
<li>集群中的每个节点负责处理一部分插槽。举个例子：如果一个集群可以有主节点，其中</li>
</ol>
<blockquote>
<ul>
<li>节点 A 负责处理 <code>0号 ~ 5460号</code> 插槽</li>
<li>节点 B 负责处理 <code>5461号 ~ 10922号</code> 插槽</li>
<li>节点 C 负责处理 <code>10923号 ~ 16383号</code> 插槽</li>
</ul>
</blockquote>
<p><strong>在集群中录入值：</strong></p>
<ol>
<li>在 Redis 每次录入，查询键值，redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会告知前往的 Redis 实例地址和端口。</li>
<li>Redis-cli 客户端提供了 <code>-c</code> 参数实现自动重定向。</li>
<li>如 <code>redis-cli -c -p 6379</code> 登入后，再录入，查询键值对可以自动重定向</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418145-1477666722.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417982-1723827422.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418059-1011143532.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418000-751485397.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><strong>不在一个 slot 下的键值，是不能使用 mget,mset 等多键操作</strong>。</li>
</ul>
<pre><code class="language-sh">192.168.76.147:6381&gt; mset k1 "v1" k2 "v2" k3 "v3"
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417556-1907371147.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418133-1161849386.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>可以通过<code>{}</code>来定义组的概念，从而使 key 中<code>{}</code>内相同内容的键值对放到一个 <code>slot</code> 中去，就解决了上面 mget 分布到不同 slot 而导致失败的原因。</li>
</ul>
<pre><code class="language-sh">192.168.76.147:6381&gt; mest k1{order} "v1" k2{order} "v2" k3{order} "v3"
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417960-279388653.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>注意：你如果对键加上了{}组，那么你想要获取到该值的时候，也是要加上对应的{}组的，才能获取到的。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417986-1078777613.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417506-1540463616.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417783-456944169.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>查询集群中的值：</strong></p>
<ol>
<li>指令: <code>CLUSTER KEYSLOT &lt;key&gt;</code> 返回  key 对应的 slot 值</li>
</ol>
<pre><code class="language-sh">192.168.76.147:6381&gt; cluster keyslot k1
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417642-354357291.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">192.168.76.147:6381&gt; cluster keyslot k2{order}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417827-1939705654.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>可以看到归属于<code>{}</code>同一组的，Redis都是分配到了同一个 slot 插槽数值当中。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417688-1363265562.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<ol start="2">
<li>指令: <code>CLUSTER COUNTKEYSINSLOT &lt;slot&gt;</code>  返回  slot 有多少个 key</li>
</ol>
<pre><code class="language-sh">192.168.76.147:6381&gt; cluster countkeysinslot 12706
(integer) 1
192.168.76.147:6381&gt; cluster countkeysinslot 16025
(integer) 3
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417921-91525864.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="3">
<li>指令: <code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt; </code>返回 count 个 slot 槽中的键</li>
</ol>
<pre><code class="language-sh">192.168.76.147:6381&gt; cluster getkeysinslot 16025 1
1) "k1{order}"
192.168.76.147:6381&gt; cluster getkeysinslot 16025 2
1) "k1{order}"
2) "k2{order}"
192.168.76.147:6381&gt; cluster getkeysinslot 16025 3

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417966-1159521894.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418177-1666209559.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-redis-集群故障恢复">4. Redis 集群故障恢复</h1>
<ol>
<li>如果主节点下线,  从节点会自动升为主节点(注意 15 秒超时,  再观察比较准确)</li>
</ol>
<pre><code class="language-sh">[root@localhost ~]# redis-cli -c -p 6380

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418003-2062292245.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417321-574755840.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417699-1832355520.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>这里我们将 6380 主机关闭了。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418036-931782043.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417763-1072922883.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><strong>主节点恢复后，主节点回来变成从机</strong></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417750-978276803.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417631-856385969.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>如果所有某一段插槽的<code>主从节点都宕掉了</code> ，Redis 服务是否还能继续，要根据不同的配置而言。</strong></p>
<blockquote>
<ol>
<li>如果某一段插槽的<strong>主从</strong> 都宕机了，而在 redis.conf 配置文件当中 <code>cluster-require-full-coverage</code> 为 <code>yes</code>  ，那么，整个集群都会被宕掉，无法使用。</li>
<li>如果某一段插槽的<strong>主从</strong> 都宕机了，而在 redis.conf 配置文件当中 <code>cluster-require-full-coverage</code> 为 <code>no</code>  ，那么，仅仅只是该段插槽的数据不能使用了，也无法存储了，其他插槽的数据还可以继续使用。</li>
<li>redis.conf 文件当中的参数 <code>cluster-require-full-coverage</code></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418148-1251878731.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote></blockquote>
<h1 id="5-redis-集群的-jedis-开发使用java程序连接-redis-同时开启集群">5. Redis 集群的 Jedis 开发(使用Java程序连接 Redis 同时开启集群)</h1>
<ol>
<li>即使连接的不是主机，集群会自动切换主机进行存储，<strong>主机写，从机读</strong> 。</li>
<li><strong>无中心化主从集群，无论从哪台主机写的数据，其他主机上都能读到数据。</strong></li>
<li>注意：需要将 Redis 相关的端口都打开   否则会报错</li>
</ol>
<p>配置防火墙将所有相关 Redis 的端口都打开。</p>
<pre><code class="language-sh">[root@localhost src]# firewall-cmd --add-port=6379/tcp --permanent
Warning: ALREADY_ENABLED: 6379:tcp
success
[root@localhost src]# firewall-cmd --add-port=6380/tcp --permanent
success
[root@localhost src]# firewall-cmd --add-port=6381/tcp --permanent
success
[root@localhost src]# firewall-cmd --add-port=6389/tcp --permanent
success
[root@localhost src]# firewall-cmd --add-port=6390/tcp --permanent
success
[root@localhost src]# firewall-cmd --add-port=6391/tcp --permanent
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417993-1422227629.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">[root@localhost src]# firewall-cmd --reload
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417786-1602622232.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">[root@localhost src]# firewall-cmd --list-all
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417989-2104764302.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>在 <code>pom.xml </code> 当中引入 <code>redis.clients</code> 依赖。如下：</p>
<pre><code class="language-xml">   &lt;!--        引入 jedis 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418114-737611743.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>首先测试，是否可以连接到 Redis 服务器。<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418008-1780250293.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.jedis;

import org.junit.Test;
import redis.clients.jedis.Jedis;

public class JedisCluster_ {

    @Test
    public void con() {
        // 使用 ip地址 + redis的端口的构造器方法
        Jedis jedis = new Jedis("192.168.76.147", 6379);

        // 如果Redis 配置了密码，则需要进行身份校验
        jedis.auth("rainbowsea");
        String ping = jedis.ping();
        System.out.println("连接成功 ping 返回的结果 = " + ping);

        jedis.close();  // 关闭当前连接，注意并没有关闭 Redis

    }

}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418005-1138801201.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418099-1790183019.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">
import org.junit.Test;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisCluster;
import redis.clients.jedis.JedisPoolConfig;

import java.util.HashSet;
import java.util.Set;

public class JedisCluster_ {
    public static void main(String[] args) {
        Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;();
        set.add(new HostAndPort("192.168.76.147", 6379));

        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 对连接池进行配置
        jedisPoolConfig.setMaxTotal(200);
        jedisPoolConfig.setMaxIdle(32);
        jedisPoolConfig.setMaxWaitMillis(60 * 1000); // 单位是毫秒
        jedisPoolConfig.setBlockWhenExhausted(true);
        jedisPoolConfig.setTestOnBorrow(true);

        JedisCluster jedisCluster = new JedisCluster(set,5000,5000,5,"rainbowsea",jedisPoolConfig );
        jedisCluster.set("address", "bj");
        String address = jedisCluster.get("address");
        System.out.println("address=&gt;" + address);
        jedisCluster.close();

    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417255-285696761.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418188-600336464.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418207-610456536.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-redis-集群的优缺点">6. Redis 集群的优缺点</h1>
<p><strong>优点：</strong></p>
<ol>
<li>实现扩容。</li>
<li>分摊压力。</li>
<li>无中心配置相对简单。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>多键操作是不被支持的。</li>
<li>多键的 Redis 事务是不被支持的。 lua 脚本不被支持</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而其它方案想要迁移至 redis cluster ，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ol>
<h1 id="7-补充">7. 补充：</h1>
<p>将 root 目录下的，rdb、aof 文件都删除掉</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418201-908874712.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">[root@localhost ~]# rm -f dump*.rdb
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418216-527783788.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418199-1892252709.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092418209-1855174236.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417783-118909298.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="8-最后">8. 最后：</h1>
<blockquote>
<p>“在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250208092417436-6466994.gif" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0439192769525463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-08 09:37">2025-02-08 09:36</span>&nbsp;
<a href="https://www.cnblogs.com/TheMagicalRainbowSea">Rainbow-Sea</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18703659" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18703659);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18703659', targetLink: 'https://www.cnblogs.com/TheMagicalRainbowSea/p/18703659', title: '十二. Redis 集群操作配置(超详细配图，配截图详细说明)' })">举报</a>
</div>
	