
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chopper-poet/p/18734795" title="发布于 2025-02-26 10:01">
    <span role="heading" aria-level="2">没有源码，如何修改代码逻辑？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><img src="https://img2024.cnblogs.com/blog/846817/202502/846817-20250224201544002-2001382765.png" alt="" loading="lazy"></p>
<div style="text-align: right">&nbsp;拍摄于西安德福巷</div>
<div style="text-align: left">&nbsp;</div>
<div style="text-align: left"><span style="color: rgba(192, 192, 192, 1)">前段时间接手了一个二次开发其他团队代码的项目，过程中发生了不少有意思的小插曲。今天正好有点空闲时间，就简单梳理一下，希望能给大家提供一些参考和帮助。</span></div>
<div style="text-align: left">&nbsp;</div>
<div style="text-align: left">
<p><span><span><span style="color: rgba(0, 0, 0, 1)">当我咨询对方团队：“大哥，我们这边要对你们在xxx项目上的代码进行二次开发，想了解下你们的二开机制是怎样的？”</span><span><br><span><br><span><span>对方回复道：“我们没有特别明确的二开机制。不过标品这边会提供jar包给你们，你们只需新建一个Spring Boot工程，然后通过依赖这个标品jar包来搭建二开工程。要是想修改业务逻辑，基于Spring的AOP机制进行操作就行，自由度还是比较高的。”<span><br><span><br><span><span>我听后有些惊讶：“原来是这样操作啊，我一开始还以为是从你们的代码仓库拉分支或者fork一份代码，然后我们在这个基础上进行修改呢。”<span><br><span><br><span><span>不得不说，基于AOP进行二次开发确实有很大的灵活性，开发者可以根据自己的需求自由发挥。但这种方式也存在明显的弊端，一旦项目出现问题，排查起来会比较困难。而且过度使用AOP，会导致业务逻辑分散在各个地方，不利于维护。回顾以往的开发经验，我使用AOP主要是进行一些横向的功能补充或扩展，比如权限控制、异常处理等方面，还真没试过用它来实现核心功能</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<span><span>接下来，正式进入今天的主题：在没有源码的情况下，怎样修改代码逻辑 ？</span></span></div>
<h2 style="text-align: left"><span><span><span><span>方式一：基于Spring AOP</span></span></span></span></h2>
<p style="text-align: left"><span><span><span><span>至于AOP的基础概念我就不啰嗦了，请自行前往官网了解。</span></span><span><span>通过一段简单代码来看下如何通过AOP来修改代码逻辑：</span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class BizService {
     //原有逻辑
    public void testBiz(){
        System.out.println("testBiz");
    }
}

通过切面修改BizService的testBiz逻辑

@Aspect
@Component
public class BizAspectTest {
    //Around切面拦截BizService的testBiz方法
    @Around("execution(* com.example.demo.BizService.testBiz())")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around");
        //继续原逻辑。如果想完全修改，也可以不继续
        joinPoint.proceed();
    }
}
</pre>
</div>
<p>　　</p>
<p><span><span>到这里，我们成功修改了 BizService 的 testBiz 方法逻辑，却没有对 BizService 的代码做任何改动。</span></span></p>
<p><span><span>一切看似风平浪静，可不出意外的话，新问题马上就要接踵而至了。</span></span></p>
<h2>方式二：类覆盖</h2>
<p>方式一基于Spring 的AOP机制来做逻辑的更改，前提是技术框架基于Spring，且Bean的生命周期还必须交给Spring托管才可以，如果是直接new出来的Bean，AOP也无能为力，比如：</p>
<p>&nbsp;</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class BizService2 {
    public void testBiz(){
        System.out.println("testBiz in BizService2");
    }
}

BizService2 bizService2 = new BizService2();
bizService2.testBiz()
</pre>
</div>
<p><span><span>遇到这种情况该如何处理呢？起初，我想到的办法是在自己的二开工程里定义一个与原类同名的 BizService2 。接着，把需要修改的代码复制过来，针对要二次开发的部分进行调整。倘若我们要修改的 BizService2 位于 biz.jar 中，那么就在这个二次开发工程内，定义一个类路径与原类完全一致的 BizService2 ，如此一来，便可以按照需求自由编写代码了。其实，这里运用的是Spring Boot类加载机制的顺序原理，通过这种方式巧妙地实现了代码的定制化修改。</span></span></p>
<p><span><span><span style="color: rgba(192, 192, 192, 1)">Spring Boot 使用 LaunchedURLClassLoader 来加载类，该类加载器在加载类时会按照一定的顺序搜索类路径。在搜索过程中，会先从 BOOT-INF/classes 目录查找所需的类，如果在该目录下找到了对应的类文件，就会直接加载该类，而不会再去 BOOT-INF/lib 目录下的 JAR 文件中查找同名类。（来源于网络）</span><span><br></span></span></span></p>
<p><span><span>不难发现，这种方法简单直接，弊端也很明显，会留下大量冗余代码。就算仅仅是修改一行代码，也不得不把其余代码都保留下来，这无疑增加了后续维护的难度和成本。既然这种方式存在不足，那么接下来，就让我们一起看看方法三，说不定能找到更优解。</span></span></p>
<h2><span><span><span><span>方式三：<span><span>Mojo's AspectJ Maven Plugin</span></span></span></span></span></span></h2>
<p><span><span><span><span><span><span><span>这是一个Maven的插件，可以在编译期对代码进行植入，和Spring AOP的最终效果类似，Spring AOP是运行时植入，而它是编译时植入，第一次知道它的时候确实让我眼前一亮，以植入<span class="code-snippet__type">BizService2<span>为例看看怎么操作：</span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">//1.依然定义切面类，语法和使用Spring AOP时一样
@Aspect
public class BizAspect2Test {
    //Around切面拦截BizService的testBiz方法
    @Around("execution(* com.example.demo.BizService2.testBiz())")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around");
        joinPoint.proceed();
    }
}

//2.配置maven插件
&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.15.0&lt;/version&gt;
      &lt;configuration&gt;
        &lt;complianceLevel&gt;16&lt;/complianceLevel&gt;
        &lt;source&gt;16&lt;/source&gt;
        &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt;
        &lt;!--如果要植入的类在jar包内，一定要这里指定--&gt;
        &lt;weaveDependencies&gt;
          &lt;weaveDependency&gt;
            &lt;groupId&gt;com.xxx&lt;/groupId&gt;
            &lt;artifactId&gt;yyy&lt;/artifactId&gt;
          &lt;/weaveDependency&gt;
        &lt;/weaveDependencies&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;configuration&gt;
            &lt;skip&gt;false&lt;/skip&gt;
          &lt;/configuration&gt;
          &lt;goals&gt;
            &lt;goal&gt;compile&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;

//3.引入aspectjrt
&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
  &lt;version&gt;1.9.19&lt;/version&gt;
&lt;/dependency&gt;	
</pre>
</div>
<p><span>接下来就是使用maven正常编译，看看编译以后<span class="code-snippet__type">BizService2<span>会发生什么变化，我们反编译<span class="code-snippet__type">BizService2<span>看看：</span></span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">import com.example.demo.BizAspect2Test;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.runtime.reflect.Factory;
public class BizService2 {
    private static /* synthetic */ JoinPoint.StaticPart ajc$tjp_0;
    static {
        // 1
        BizService2.ajc$preClinit();
    }
    public void testBiz() {
        // 1
        JoinPoint joinPoint = Factory.makeJP(ajc$tjp_0, this, this);
        BizService2.testBiz_aroundBody1$advice(this, joinPoint, BizAspect2Test.aspectOf(), (ProceedingJoinPoint) joinPoint);
    }
    private static /* synthetic */ void ajc$preClinit() {
        Factory factory = new Factory("BizService2.java", BizService2.class);
        ajc$tjp_0 = factory.makeSJP("method-execution", (Signature) factory.makeMethodSig("1", "testBiz", "com.example.demo.BizService2", "", "", "", "void"), 4);
    }
    private static final /* synthetic */ void testBiz_aroundBody1$advice(BizService2 ajc$this, JoinPoint thisJoinPoint, BizAspect2Test ajc$aspectInstance, ProceedingJoinPoint joinPoint) {
        // 13
        System.out.println("around");
        // 14
        ProceedingJoinPoint proceedingJoinPoint = joinPoint;
        System.out.println("testBiz in BizService2");
    }
}       
</pre>
</div>
<p><span><span>可以看到BizServer2内部已经融合了<span class="code-snippet__title">BizAspect2Test<span>的相关逻辑，是不是很强大。</span></span></span></span><span><span>最后借助豆包的回答来看看aspectjrt和Spring AOP实现原理的对比：</span></span></p>
<ul class="list-paddingleft-1">
<li><strong><span><span>aspectjrt</span></span></strong></li>
<ul class="list-paddingleft-1">
<li><span><span>AspectJ 采用了编译时织入（Compile-time weaving）、加载时织入（Load-time weaving）等方式。编译时织入是在 Java 源代码编译成字节码的过程中，就将切面逻辑合并到目标类的字节码中；加载时织入则是在类加载到 JVM 时，通过特殊的类加载器对字节码进行修改，插入切面逻辑。</span></span></li>
<li><span><span>这种方式生成的代码在运行时没有额外的性能开销，因为切面逻辑已经成为目标类的一部分。</span></span></li>
</ul>
<li><strong><span><span>Spring AOP</span></span></strong></li>
<ul class="list-paddingleft-1">
<li><span><span>Spring AOP 主要基于代理模式实现，分为 JDK 动态代理和 CGLIB 代理。当目标对象实现了接口时，使用 JDK 动态代理；当目标对象没有实现接口时，使用 CGLIB 代理。</span></span></li>
<li><span><span>代理模式在运行时创建代理对象，通过代理对象来调用目标对象的方法，并在方法调用前后插入切面逻辑。因此，在运行时会有一定的性能开销，尤其是在频繁调用方法时。</span></span></li>
</ul>
</ul>
<h2><span><span>推荐阅读</span></span><span style="font-size: 14px"><br></span></h2>
<p><span><span>https://www.mojohaus.org/aspectj-maven-plugin/index.html</span></span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/846817/202502/846817-20250224202547879-1972721840.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03922696739699074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 10:02">2025-02-26 10:01</span>&nbsp;
<a href="https://www.cnblogs.com/chopper-poet">踩刀诗人</a>&nbsp;
阅读(<span id="post_view_count">96</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18734795" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18734795);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18734795', targetLink: 'https://www.cnblogs.com/chopper-poet/p/18734795', title: '没有源码，如何修改代码逻辑？' })">举报</a>
</div>
        