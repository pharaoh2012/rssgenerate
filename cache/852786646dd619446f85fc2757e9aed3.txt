
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18810298" title="发布于 2025-04-05 21:57">
    <span role="heading" aria-level="2">[设计模式/Java] 设计模式之工厂方法模式【11】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概述工厂方法模式---factory-method-pattern">概述：工厂方法模式  := Factory Method Pattern</h1>
<h2 id="工厂模式的3种细分模式-简单工厂模式--工厂方法模式--抽象工厂模式">工厂模式的3种细分模式： 简单工厂模式 / 工厂方法模式 / 抽象工厂模式</h2>
<ul>
<li><strong>工厂模式</strong>（<code>Factory Pattern</code>）是 <code>Java</code> 中<strong>最常用的设计模式</strong>之一</li>
</ul>
<blockquote>
<ul>
<li>其提供了一种<strong>创建对象的方式</strong>，使得<strong>创建对象的过程</strong>与<strong>使用对象的过程</strong>分离。</li>
<li><strong>工厂模式</strong>提供了一种<strong>创建对象的方式</strong>，而无需指定要创建的具体类。</li>
<li>通过使用<strong>工厂模式</strong>，可以将<strong>对象的创建逻辑</strong>封装在一个工厂类中，而不是在<strong>客户端代码</strong>中<strong>直接实例化对象</strong>，这样可以提高代码的<strong>可维护性</strong>和<strong>可扩展性</strong>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>简单工厂模式</strong>（Simple Factory Pattern）：</li>
</ul>
<blockquote>
<p><strong>简单工厂模式</strong>不是一个<strong>正式的设计模式</strong>，但它是<strong>工厂模式的基础</strong>。<br>
它使用一个<strong>单独的工厂类</strong>来<strong>创建不同的对象</strong>，根据<strong>传入的参数</strong>决定创建哪种类型的对象。</p>
</blockquote>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215903527-353650677.png" alt="" loading="lazy"></p>
<blockquote>
<ul>
<li><strong>工厂方法模式</strong>（Factory Method Pattern）：</li>
</ul>
<blockquote>
<p>工厂方法模式定义了一个<strong>创建对象的接口</strong>，但由<strong>子类</strong>决定实例化哪个类。<br>
工厂方法<span style="color: rgba(255, 0, 0, 1)">将<strong>对象的创建</strong>延迟到子类。</span></p>
</blockquote>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215917383-4036252.png" alt="" loading="lazy"></p>
<blockquote>
<ul>
<li><strong>抽象工厂模式</strong>（Abstract Factory Pattern）：</li>
</ul>
<blockquote>
<p><strong>抽象工厂模式</strong>提供一个创建一系列相关的产品 或 互相依赖对象的接口，而无需指定它们具体的产品类。</p>
</blockquote>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215937977-1862205611.png" alt="" loading="lazy"></p>
<h2 id="模式定义--工厂方法模式">模式定义 : 工厂方法模式</h2>
<ul>
<li><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。</li>
</ul>
<h2 id="模式分析">模式分析</h2>
<ul>
<li>主要解决</li>
</ul>
<blockquote>
<p>接口选择的问题。</p>
</blockquote>
<ul>
<li>如何解决</li>
</ul>
<blockquote>
<p>通过让<strong>子类</strong>实现<strong>工厂接口</strong>，返回一个<strong>抽象的产品</strong>。</p>
</blockquote>
<ul>
<li>关键代码</li>
</ul>
<blockquote>
<p><strong>对象的创建过程</strong>在<strong>子类</strong>中实现。</p>
</blockquote>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>何时使用</li>
</ul>
<blockquote>
<p>当我们需要在<strong>不同条件</strong>下创建不同实例时。</p>
</blockquote>
<h2 id="模型特点">模型特点</h2>
<h3 id="优点">优点</h3>
<ul>
<li><strong>扩展性高</strong>、更符合<strong>开-闭原则</strong></li>
</ul>
<blockquote>
<ul>
<li>如果需要增加新产品，只需扩展一个工厂类即可。</li>
<li>新增一种产品时，只需要增加相应的<strong>具体产品类</strong>和<strong>相应的工厂子类</strong>即可</li>
</ul>
</blockquote>
<pre><code class="language-txt">相比【简单工厂模式】: 需要修改工厂类的判断逻辑
</code></pre>
<ul>
<li>符合<strong>单一职责</strong>原则 / <strong>屏蔽实现</strong> : 每个具体工厂类只负责创建对应的产品</li>
</ul>
<blockquote>
<ul>
<li>屏蔽了产品的具体实现</li>
</ul>
</blockquote>
<pre><code class="language-txt">相比【简单工厂模式】：其工厂类存在复杂的switch逻辑判断
</code></pre>
<ul>
<li>不使用<strong>静态工厂方法</strong>，可形成<strong>基于继承的等级结构</strong></li>
</ul>
<blockquote>
<p>相比【简单工厂模式】：其工厂类使用<strong>静态工厂方法</strong></p>
</blockquote>
<blockquote>
<p><strong>工厂(方法)模式</strong>可以说是<strong>简单工厂模式</strong>的进一步抽象和拓展，在保留了<strong>简单工厂</strong>的封装优点的同时，让<strong>扩展</strong>变得简单，让<strong>继承</strong>变得可行，增加了<strong>多态性</strong>的体现。</p>
</blockquote>
<h3 id="缺点">缺点</h3>
<ul>
<li>每次增加一个产品时，都需要增加一个<strong>具体类</strong>和<strong>对应的工厂</strong>，使系统中类的数量成倍增加，增加了<strong>系统的复杂度</strong>和<strong>具体类的依赖</strong>。</li>
</ul>
<blockquote>
<p>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；<br>
同时，有更多的类需要<strong>编译</strong>和<strong>运行</strong>，会给系统带来一些<strong>额外的开销</strong>；</p>
</blockquote>
<ul>
<li>系统的实现难度、理解难度：有所上升</li>
</ul>
<blockquote>
<p>由于考虑到<strong>系统的可扩展性</strong>，需要引入<strong>抽象层</strong>，在<strong>客户端代码</strong>中均使用<strong>抽象层</strong>进行定义，增加了<strong>系统的抽象性</strong>和<strong>理解难度</strong>，且在实现时可能需要用到<code>DOM</code>、<strong>反射</strong>等技术，增加了<strong>系统的实现难度</strong>。</p>
</blockquote>
<ul>
<li>更换产品时，客户端仍然需要通过<strong>修改代码</strong>来实现</li>
</ul>
<blockquote>
<p>虽然保证了<strong>工厂方法</strong>内的<strong>对修改关闭</strong>，但对于<strong>使用工厂方法的类(Client)</strong>，如果要<strong>更换另外一种产品</strong>，仍然需要修改实例化的具体工厂类；</p>
</blockquote>
<ul>
<li>一个<strong>具体工厂</strong>只能创建一种<strong>具体产品</strong></li>
</ul>
<h2 id="适用场景-1">适用场景</h2>
<ul>
<li>当一个类<strong>不知道它所需要的对象的类</strong>时</li>
</ul>
<blockquote>
<p>在<strong>工厂方法模式</strong>中，客户端不需要知道具体产品类的类名，<strong>只需要知道所对应的工厂</strong>即可；</p>
</blockquote>
<ul>
<li>当一个类希望通过其<strong>子类</strong>来指定创建对象时</li>
</ul>
<blockquote>
<p>在<strong>工厂方法模式</strong>中，对于<strong>抽象工厂类</strong>只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用<strong>面向对象</strong>的多态性和<strong>里氏代换原则</strong>，在程序运行时，<strong>子类对象</strong>将覆盖父类对象，从而使得<strong>系统更容易扩展</strong>。</p>
</blockquote>
<ul>
<li>将<strong>创建对象的任务</strong>委托给多个工厂子类中的某一个，<strong>客户端</strong>在使用时可以无须关心是<strong>哪一个工厂子类</strong>创建<strong>产品子类</strong>，需要时再<strong>动态指定</strong>，可将具体工厂类的类名存储在<strong>配置文件</strong>或<strong>数据库</strong>中。</li>
</ul>
<h2 id="模式的组成">模式的组成</h2>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405212901167-1005830277.png" alt="" loading="lazy"></p>
<ul>
<li><strong>抽象产品</strong>（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。</li>
<li><strong>具体产品</strong>（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。</li>
<li><strong>抽象工厂</strong>（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。</li>
<li><strong>具体工厂</strong>（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。</li>
</ul>
<h2 id="模式实现">模式实现</h2>
<p>参见本文档: | 案例：不同工厂生产不同品类的产品</p>
<h1 id="案例实践">案例实践</h1>
<h2 id="案例不同工厂生产不同品类的产品">案例：不同工厂生产不同品类的产品</h2>
<h3 id="需求描述">需求描述</h3>
<p>背景：小成有一间<strong>塑料加工厂</strong>（仅生产A类产品）；随着客户需求的变化，客户需要<strong>生产B类产品</strong>；<br>
冲突：改变<strong>原有塑料加工厂的配置和变化</strong>非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；<br>
解决方案：小成决定置办<strong>塑料分厂B</strong>来生产B类产品；</p>
<blockquote>
<p>即 工厂方法模式</p>
</blockquote>
<h3 id="源码--factory--抽象工厂类">源码 | Factory : 抽象工厂类</h3>
<blockquote>
<p>创建<strong>抽象工厂类</strong>，定义具体工厂的公共接口</p>
</blockquote>
<pre><code class="language-java">abstract class Factory {
    public abstract Product Manufacture();
}
</code></pre>
<h3 id="源码--product--抽象产品">源码 | Product : 抽象产品</h3>
<blockquote>
<p>创建<strong>抽象产品类</strong> ，定义具体产品的公共接口；</p>
</blockquote>
<pre><code class="language-java">abstract class Product {
    public abstract void Show();
}
</code></pre>
<h3 id="源码--producta--productb----多个具体产品类">源码 | ProductA / ProductB / ... : 多个具体产品类</h3>
<blockquote>
<p>创建<strong>具体产品类</strong>（继承抽象产品类）， 定义生产的具体产品；</p>
</blockquote>
<ul>
<li>ProductA</li>
</ul>
<pre><code class="language-java">//具体产品A类
class ProductA extends  Product {
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
</code></pre>
<ul>
<li>ProductB</li>
</ul>
<pre><code class="language-java">//具体产品B类
class  ProductB extends  Product {
    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
</code></pre>
<h3 id="源码--producta--productb--具体工厂类">源码 | ProductA / ProductB : 具体工厂类</h3>
<blockquote>
<p>创建<strong>具体工厂类</strong>（继承<strong>抽象工厂类</strong>），定义创建对应具体产品实例的方法；</p>
</blockquote>
<ul>
<li>FactoryA</li>
</ul>
<pre><code class="language-java">//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}
</code></pre>
<ul>
<li>FactoryB</li>
</ul>
<pre><code class="language-java">//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
</code></pre>
<h3 id="源码--client">源码 | Client</h3>
<blockquote>
<p>外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</p>
</blockquote>
<pre><code class="language-java">//生产工作流程
public class Client {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();
 
        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
</code></pre>
<blockquote>
<p>out</p>
</blockquote>
<pre><code class="language-log">生产出了产品A
生产出了产品C
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/17189752.html" target="_blank">设计模式之总述 - 博客园/千千寰宇</a></li>
</ul>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://blog.csdn.net/varyall/article/details/82355964" target="_blank" rel="noopener nofollow">工厂方法模式（Factory Method）-最易懂的设计模式解析 - CSDN</a></li>
<li><a href="https://blog.csdn.net/qq_42804736/article/details/115168313" target="_blank" rel="noopener nofollow">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂） - CSDN</a> 【推荐】</li>
<li><a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener nofollow">工厂模式 - 菜鸟教程</a> 【不推荐/内容质量差】</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8437140315497685" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-05 22:01">2025-04-05 21:57</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">33</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18810298" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18810298);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18810298', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18810298', title: '[设计模式/Java] 设计模式之工厂方法模式【11】' })">举报</a>
</div>
        