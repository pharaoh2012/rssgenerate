
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18670246" title="发布于 2025-01-14 10:17">
    <span role="heading" aria-level="2">manim边做边学--动画联动</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>今天介绍<code>Manim</code>中的动画联动的技巧，在数学动画中，动画联动是常用的功能，</p>
<p>比如讲解平面几何中三角形与圆的位置关系变化，通过动画联动可以让圆沿着三角形的边滚动，或者让三角形的顶点在圆上移动，从而直观地展示内切、外接等几何关系。</p>
<p>总之，通过动画联动，可以将复杂的概念、关系或变化过程以动态的方式展示出来。</p>
<p>这种动态展示比静态的图像或文字描述更具吸引力，能让观众更容易理解抽象的知识。</p>
<h1 id="1-联动原理">1. 联动原理</h1>
<p>在<code>Manim</code>中，每个<code>Mobject</code>对象都有一个<code>add_updater</code>函数，这个函数是实现动画联动的关键。</p>
<p><code>add_updater</code>这个更新函数会在每一帧渲染之前被调用，用于更新<code>Mobject</code>的属性。</p>
<p>例如，你可以用它来改变一个图形的位置、颜色、大小等属性，从而创建动态的动画效果。</p>
<p>当你有多个<code>Mobject</code>并且希望它们的动画相互关联时，<code>add_updater</code>就非常有用。</p>
<p>比如，你有一个圆形和一个正方形，你想让正方形的位置始终跟随圆形的位置变化，就可以通过为正方形添加一个<code>updater</code>函数，在函数内部根据圆形的位置来更新正方形的位置。</p>
<p><code>add_updater</code>是<code>Mobject</code>类的一个方法。其基本函数原型如下：</p>
<p><code>add_updater(update_function, index=None, call_updater=False)</code></p>
<p>其中：</p>
<ol>
<li><code>update_function</code>：这是最重要的参数，它是一个可调用对象（通常是一个函数），用于更新<code>Mobject</code>的属性</li>
<li><code>index</code>：当有多个<code>updater</code>联动函数时，<code>index</code>表示<code>updater</code>的调用顺序</li>
<li><code>call_updater</code>：是否在被调用后立即执行一次，而不仅仅是在每一帧渲染之前执行</li>
</ol>
<h1 id="2-联动示例">2. 联动示例</h1>
<p>示例是最好的学习资料，之前做尺规作图的动画时，模拟圆规动作的动画就是一个联动动画。</p>
<p>下面的示例主要介绍如何通过联动动画来完成其中的圆规动作。</p>
<p>圆规动画目的是画一个 <strong>圆弧</strong>，只是在绘制的圆弧的过程中还需要展示了圆弧的起点，终点，</p>
<p>以及绘制过程中动态更新起点终点之间的线。</p>
<p>首先，定义绘制函数：</p>
<pre><code class="language-python">
def ruler(sc: Scene, p1, p2, color=GREEN, angle=PI, axis=OUT):
    """
    圆规动画


    Parameters
    ---------
    sc
        绘制动画的场景
    p1
        代表圆规的针，绘制时不动的点
    p2
        代表圆规的笔芯，绘制圆弧的点
    color
        圆弧的颜色，默认绿色
    angle
        绘制圆弧的角度，默认PI，相当于绘制半个圆
    axis
        只有2个值 IN/OUT，分别表示顺时针还是逆时针作弧
    """
    # 省略。。。
    return arc
</code></pre>
<p>实现动画的思路如下：</p>
<ol>
<li>构建3个元素，即：
<ol>
<li><code>d1</code>(根据参数中p1坐标绘制的点)</li>
<li><code>d2</code>(根据参数中p2坐标绘制的点)</li>
<li><code>dl</code>(连接p1和p2的虚线)</li>
</ol>
</li>
<li>设置<code>dl</code>的动画，随着 <code>d1</code>和<code>d2</code>变化不断重新绘制（这里 <code>d1</code>其实是不会变的）</li>
<li>再设置圆弧的动画，随着 <code>d2</code>的变动，不断绘制新的圆弧（圆弧就是起点到<code>d2</code>的弧）</li>
<li>通过 <code>Manim</code>自带的动画函数让 <code>d2</code>先动，其他动画随之运动</li>
<li>最后删除不必要的元素，只保留圆弧在 场景(<code>sc</code>)中</li>
</ol>
<pre><code class="language-python">def ruler(sc: Scene, p1, p2, color=GREEN, angle=PI, axis=OUT):
    d1 = Dot(point=p1, color=RED)
    d2 = Dot(point=p2, color=color)
    dl = DashedLine(d1.get_center(), d2.get_center())

    r = np.linalg.norm(p2 - p1)
    arc = ArcBetweenPoints(p2, p2, stroke_width=2)

    dl.add_updater(lambda z: z.become(DashedLine(d1.get_center(), d2.get_center())))
    if np.array_equal(axis, OUT):
        arc.add_updater(
            lambda z: z.become(
                ArcBetweenPoints(
                    p2, d2.get_center(), radius=r, stroke_color=color, stroke_width=2
                )
            )
        )
    if np.array_equal(axis, IN):
        arc.add_updater(
            lambda z: z.become(
                ArcBetweenPoints(
                    d2.get_center(), p2, radius=r, stroke_color=color, stroke_width=2
                )
            )
        )

    sc.add(d1, d2, dl, arc)
    sc.play(
        Rotate(
            d2,
            about_point=d1.get_center(),
            axis=axis,
            angle=angle,
            rate_func=linear,
        )
    )

    arc.clear_updaters()
    dl.clear_updaters()
    sc.remove(d1, d2, dl)
    return arc
</code></pre>
<p>调用这个函数的效果如下：</p>
<pre><code class="language-python">ruler(self, np.array([-1, 0, 0]), np.array([-1, 1, 0]))
ruler(self, np.array([1, 0, 0]), np.array([1, 1, 0]), axis=IN)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250114101638415-36061697.gif" alt="" loading="lazy"></p>
<p>画两个圆弧的交叉效果：</p>
<pre><code class="language-python">ruler(self, np.array([-1, -1, 0]), np.array([1.1, -0.2222, 0]), angle=PI / 3)
ruler(
    self,
    np.array([1, -1, 0]),
    np.array([-1.1, -0.2222, 0]),
    axis=IN,
    angle=PI / 3,
)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250114101638614-1500346809.gif" alt="" loading="lazy"></p>
<h1 id="3-注意事项">3. 注意事项</h1>
<p>使用<code>add_updater</code>函数时，首先需要注意的是<strong>性能问题</strong>，由于<code>add_updater</code>函数会在每一帧渲染前被调用，所以要避免在<code>updater</code>函数中进行复杂的计算。</p>
<p>例如，在一个场景中有大量的<code>Mobject</code>，如果在<code>updater</code>函数中进行高复杂度的矩阵运算或者嵌套循环来更新每个<code>Mobject</code>的位置，会导致动画渲染速度变慢，甚至可能出现卡顿。</p>
<p>其次，当多个<code>Mobject</code>之间存在复杂的依赖关系并且都使用<code>add_updater</code>方法时，要确保更新函数的逻辑正确。</p>
<p>要注意更新函数内部不要出现无意的无限循环或递归情况。</p>
<p>最后，当动画的某个阶段不再需要<code>updater</code>函数来更新<code>Mobject</code>时，要及时使用<code>remove_updater</code>方法移除更新器。</p>
<p>如果不及时移除不再需要的更新器，可能会导致内存泄漏和资源浪费。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.016351700314814813" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 10:17">2025-01-14 10:17</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18670246" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18670246);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18670246', targetLink: 'https://www.cnblogs.com/wang_yb/p/18670246', title: 'manim边做边学--动画联动' })">举报</a>
</div>
        