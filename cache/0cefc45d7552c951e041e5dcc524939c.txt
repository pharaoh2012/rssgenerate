
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangSir-devops/p/18859122" title="发布于 2025-05-10 13:08">
    <span role="heading" aria-level="2">K8s新手系列之Service资源</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="概述">概述</h2>
<p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/</a></p>
<p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504124541547-1490456237.png" alt="image" loading="lazy"></p>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504124614237-722412312.png" alt="image" loading="lazy"></p>
<p><strong>简单点说就是：Service可以实现pod的负载均衡和服务发现功能，为访问Pod提供了统一的访问入口。</strong></p>
<h2 id="service的类型">Service的类型</h2>
<p>Service的类型有四类：分别是以下四类</p>
<h3 id="clusterip">ClusterIP</h3>
<p>这是svc默认的类型，是k8s集群内部分配的虚拟IP，适用于集群内部进行访问，外部访问不到，但是可以使用 Ingress 或者 Gateway API 来公开服务。创建svc时会自动关联endpoints资源。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125042139-1730108600.png" alt="image" loading="lazy"></p>
<h3 id="nodeport">NodePort</h3>
<p>在ClusterIP基础之上，多添加了对所有Worker节点实现端口映射的功能。NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125023986-1940989601.png" alt="image" loading="lazy"></p>
<h3 id="loadbalancer">LoadBalancer</h3>
<p>实现负载均衡的服务，主要应用场景是云厂商环境，它能够为服务提供外部可访问的 IP 地址。这种类型的服务通过云服务提供商的负载均衡器实现，允许外部流量进入集群中的 Pod。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125113794-1197540018.png" alt="image" loading="lazy"></p>
<h3 id="externalname">ExternalName</h3>
<p>ExternalName类型的Service用于引入集群外部的服务，它通过ExternalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125148444-1191004622.png" alt="image" loading="lazy"></p>
<h2 id="service的作用">Service的作用</h2>
<h3 id="服务发现与负载均衡">服务发现与负载均衡</h3>
<ul>
<li>
<p>服务发现：Kubernetes 中的 Pod 是动态创建和销毁的，它们的 IP 地址也是动态分配的。Service 为一组具有相同功能的 Pod 提供了一个固定的虚拟 IP 地址和 DNS 名称。其他组件可以通过这个固定的地址来访问这些 Pod，而无需关心具体 Pod 的 IP 地址变化。</p>
</li>
<li>
<p>负载均衡：Service 可以将流量均匀地分发到后端的多个 Pod 上，实现负载均衡的功能。这样可以确保应用能够处理大量的并发请求，提高系统的性能和可靠性。例如，一个 Web 应用可能由多个 Pod 组成，通过 Service 可以将用户的请求均衡地分配到这些 Pod 上，避免单个 Pod 因负载过高而出现性能问题。</p>
</li>
</ul>
<h3 id="应用解耦">应用解耦</h3>
<ul>
<li>
<p>解耦客户端与服务端：Service 使得客户端与后端服务的 Pod 之间实现了解耦。客户端只需要知道 Service 的地址，而不需要了解后端具体有哪些 Pod 以及它们的状态。当后端 Pod 发生变化（如扩容、缩容或升级）时，客户端无需进行任何修改，仍然可以通过 Service 正常访问服务。</p>
</li>
<li>
<p>支持微服务架构：在微服务架构中，不同的微服务之间通常需要相互调用。Service 为每个微服务提供了独立的访问入口，使得各个微服务可以独立地进行部署、扩展和升级，而不会影响到其他微服务。这种解耦方式提高了整个系统的可维护性和可扩展性。</p>
</li>
</ul>
<h3 id="提供稳定的网络端点">提供稳定的网络端点</h3>
<ul>
<li>
<p>外部访问入口：对于需要对外提供服务的应用，Service 可以作为外部访问的入口点。通过将 Service 设置为 NodePort 类型或 LoadBalancer 类型，可以将服务暴露到集群外部，让外部用户能够访问到 Kubernetes 集群中的应用。</p>
</li>
<li>
<p>内部网络隔离：在 Kubernetes 集群内部，Service 还可以用于实现网络隔离。通过定义不同的 Service 和相应的访问规则，可以限制哪些 Pod 能够访问特定的服务，从而提高集群的安全性和稳定性。</p>
</li>
</ul>
<h3 id="方便应用管理与维护">方便应用管理与维护</h3>
<ul>
<li>
<p>统一管理：通过 Service，可以对一组相关的 Pod 进行统一的管理和配置。例如，可以通过 Service 来设置访问策略、监控指标收集等，而无需对每个 Pod 单独进行配置。</p>
</li>
<li>
<p>简化运维操作：当需要对应用进行升级、回滚或其他运维操作时，只需要对 Service 进行相应的配置修改，Kubernetes 会自动根据 Service 的定义来调整后端 Pod 的状态，从而简化了运维操作的复杂度。</p>
</li>
</ul>
<h2 id="service的工作原理">Service的工作原理</h2>
<p>Service 通过<code> Label Selector</code> 来选择对应的 Pods，当 Service 接收到请求时，它会根据负载均衡算法将请求转发到后端的某个 Pod 上。K8s 中的 <code>kube - proxy</code> 组件负责在节点上维护网络规则，确保 Service 能够正确地将流量路由到后端 Pods。</p>
<h2 id="service的资源配置文件">Service的资源配置文件</h2>
<pre><code>apiVersion: v1          # API版本，Service属于核心API组，固定使用v1
kind: Service           # 资源类型为Service

metadata:               # 元数据，定义Service的标识信息
  name: my-service      # Service名称，必须符合DNS标签规范
  namespace: default    # 命名空间，默认为default
  labels:               # 标签，用于组织和选择资源
    app: my-app
    tier: backend
  annotations:          # 注解，用于存储非标识性元数据（如配置信息）
    service.beta.kubernetes.io/aws-load-balancer-type: nlb

spec:                   # 服务规范，定义Service的行为和关联的Pod
  type: ClusterIP       # Service类型（ClusterIP/NodePort/LoadBalancer/ExternalName）
  
  selector:             # 标签选择器，用于确定哪些Pod属于此服务
    app: my-app
    tier: backend
  
  ports:                # 端口配置，定义服务如何接收流量
  - name: http          # 端口名称，必须符合DNS标签规范
    protocol: TCP       # 协议类型，支持TCP/UDP/SCTP，默认为TCP
    port: 80            # 服务暴露的端口（集群内部访问使用）
    targetPort: 8080    # 后端Pod接收流量的端口
    nodePort: 30080     # NodePort类型时，节点上暴露的端口（30000-32767）
  
  externalIPs:          # 外部IP列表，允许通过这些IP访问服务
  - 80.11.12.10
  
  sessionAffinity: None # 会话亲和性（None/ClientIP），默认为None
  sessionAffinityConfig:  # 会话亲和性配置（仅当sessionAffinity为ClientIP时有效）
    clientIP:
      timeoutSeconds: 10800  # 客户端IP会话保持时间（秒）
  
  loadBalancerIP: 70.42.103.12  # LoadBalancer类型时，指定负载均衡器的IP
  loadBalancerSourceRanges:    # 限制访问LoadBalancer的客户端IP范围
  - 10.0.0.0/8
  
  externalName: my.database.example.com  # ExternalName类型时，指定外部域名
  
  publishNotReadyAddresses: false  # 是否发布未就绪的端点，默认为false
</code></pre>
<h2 id="service之clusterip实战">Service之ClusterIP实战</h2>
<p>这是svc默认的类型，是k8s集群内部分配的虚拟IP，适用于集群内部进行访问，外部访问不到，但是可以使用 Ingress 或者 Gateway API 来公开服务。创建svc时会自动关联endpoints资源。</p>
<h3 id="创建一个deployment">创建一个Deployment</h3>
<pre><code>[root@master01 ~/deploy]# cat deploy-nginx.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-nginx
  namespace: default
spec:
  # 设置Pod的副本数量
  replicas: 3
  selector:
    # 标签匹配规则
    matchLabels:
      app: nginx
  template:
    metadata:
      name: pod-nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: container-nginx
        image: nginx:1.14.1
      restartPolicy: Always

# 创建deploy
[root@master01 ~/deploy]# kubectl apply -f deploy-nginx.yaml
deployment.apps/deployment-nginx created
</code></pre>
<h3 id="创建service">创建Service</h3>
<pre><code># 定义service
[root@master01 ~/service]# cat service-clusterip.yaml
apiVersion: v1
kind: Service
metadata:
  # 需要和pod在一个命名空间内
  namespace: default
  name: nginx-svc-clusterip
spec:
  # 定义service的类型
  type: ClusterIP
  # 标签选择器，选择pod的标签，而不是deploy的标签
  selector:
    app: nginx
  # 定义端口映射
  ports:
  - name: clusterip-nginx
    # 访问service的端口
    port: 6789
    # 容器的端口
    targetPort: 80
    protocol: TCP

# 创建service
[root@master01 ~/service]# kubectl apply -f service-clusterip.yaml
service/nginx-svc-clusterip created
</code></pre>
<h3 id="查看service的详情">查看service的详情</h3>
<pre><code># 查看service
[root@master01 ~/service]# kubectl get svc -o wide
NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE   SELECTOR
nginx-svc-clusterip   ClusterIP   10.96.3.77   &lt;none&gt;        6789/TCP   91s   app=nginx

# 查看详情
[root@master01 ~/service]# kubectl describe svc nginx-svc-clusterip
Name:              nginx-svc-clusterip
Namespace:         default
Labels:            &lt;none&gt;
Annotations:       &lt;none&gt;
Selector:          app=nginx
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                10.96.3.77
IPs:               10.96.3.77
Port:              clusterip-nginx  6789/TCP
TargetPort:        80/TCP
Endpoints:         100.117.144.188:80,100.117.144.189:80,100.95.185.217:80
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre>
<p>注意看Endpoints字段，该字段对应的是关联的所有的pod的<code>IP:PORT</code>地址，service和pod之间的联系是通过endpoints实现的。</p>
<h3 id="访问service">访问service</h3>
<p>访问clusterip的service需要通过分配给service的IP和PORT进行访问</p>
<pre><code># 可以看到CLUSTER-IP字段分配的值是10.96.3.77，PORT(S)字段的值是6789（我们在资源配置文件中定义的）
[root@master01 ~/service]# kubectl get svc -o wide
NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE   SELECTOR
nginx-svc-clusterip   ClusterIP   10.96.3.77   &lt;none&gt;        6789/TCP   91s   app=nginx

# 访问service
[root@master01 ~/service]# curl 10.96.3.77:6789
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
# 省略部分内容

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="service之nodeport实战">Service之NodePort实战</h2>
<p>ClusterIP只能在K8s集群内部访问，外部无法访问，而NodePort在ClusterIP基础之上，多添加了对所有Worker节点实现端口映射的功能。实现了外部访问Pod。<br>
NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。</p>
<h3 id="创建deployment">创建deployment</h3>
<pre><code># 定义资源文件
[root@master01 ~/deploy]# cat deploy-tomcat.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-tomcat
  namespace: default
spec:
  # 定义更新策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  replicas: 3
  selector:
    matchLabels:
      app: tomcat
  template:
    metadata:
      name: pod-tomcat
      labels:
        app: tomcat
    spec:
      containers:
      - name: container-tomcat
        image: tomcat:9.0
      restartPolicy: Always
# 创建deployment
[root@master01 ~/deploy]# kubectl apply -f deploy-tomcat.yaml
deployment.apps/deployment-tomcat created
</code></pre>
<h3 id="创建service-1">创建service</h3>
<pre><code># 定义资源文件
[root@master01 ~/service]# cat service-nodeport.yaml
apiVersion: v1
kind: Service
metadata:
  # 需要和pod在一个命名空间内
  namespace: default
  name: tomcat-svc-nodeport
spec:
  # 定义service的类型
  type: NodePort
  # 标签选择器，选择pod的标签，而不是deploy的标签
  selector:
    app: tomcat
  # 定义端口映射
  ports:
  - name: nodeport-tomcat
    # 访问service的端口
    port: 16789
    # 容器的端口
    targetPort: 8080
    # nodePort的取值是30000-32767，会随机生成，但建议配置
    nodePort: 31180
    protocol: TCP
# 创建service
[root@master01 ~/service]# kubectl apply -f service-nodeport.yaml
service/tomcat-svc-nodeport created
</code></pre>
<h3 id="查看service">查看service</h3>
<pre><code>## 查看service
[root@master01 ~/service]# kubectl get svc -o wide
NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)           AGE     SELECTOR
tomcat-svc-nodeport   NodePort    10.96.0.110   &lt;none&gt;        16789:31180/TCP   54s     app=tomcat

# 查看详情
[root@master01 ~/service]# kubectl describe svc tomcat-svc-nodeport
Name:                     tomcat-svc-nodeport
Namespace:                default
Labels:                   &lt;none&gt;
Annotations:              &lt;none&gt;
Selector:                 app=tomcat
Type:                     NodePort
IP Family Policy:         SingleStack
IP Families:              IPv4
IP:                       10.96.0.110
IPs:                      10.96.0.110
Port:                     nodeport-tomcat  16789/TCP
TargetPort:               8080/TCP
NodePort:                 nodeport-tomcat  31180/TCP
Endpoints:                &lt;none&gt;
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;
</code></pre>
<h3 id="访问service-1">访问service</h3>
<p>访问nodeport的service可以通过集群内部的<code>IP:PORT</code>进行访问，也可以通过node节点的<code>IP:PORT</code>进行访问</p>
<p>通过所有node节点均可访问</p>
<pre><code>## 查看service
[root@master01 ~/service]# kubectl get svc -o wide
NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)           AGE     SELECTOR
tomcat-svc-nodeport   NodePort    10.96.0.110   &lt;none&gt;        16789:31180/TCP   54s     app=tomcat

# 通过集群内部
curl 10.96.0.110:16789

# 通过node节点进行访问
curl 10.0.0.30:31180
curl 10.0.0.31:31180
curl 10.0.0.32:31180
</code></pre>
<h2 id="service之externalname实战">Service之ExternalName实战</h2>
<p>ExternalName类型的Service用于引入集群外部的服务，它通过ExternalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<h3 id="创建service-2">创建service</h3>
<pre><code># 定义配置文件
[root@master01 ~/service]# cat service-externalname.yaml
apiVersion: v1
kind: Service
metadata:
    name: baidu-externalname
spec:
    type: ExternalName
    externalName: www.baidu.com
    #ports:
    #- name: baidu-name
    #  port: 443            # 服务端口（集群内部使用）
    #  targetPort: 443      # 外部服务实际端口
    #  protocol: TCP
# 创建service
[root@master01 ~/service]# kubectl apply -f service-externalname.yaml
service/baidu-externalname created
</code></pre>
<h3 id="查看详情">查看详情</h3>
<pre><code># 查看service
[root@master01 ~/service]# kubectl get svc
NAME                  TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)           AGE
baidu-externalname    ExternalName   &lt;none&gt;        www.baidu.com   &lt;none&gt;            47s
# 查看service详情
[root@master01 ~/service]# kubectl describe svc baidu-externalname
Name:              baidu-externalname
Namespace:         default
Labels:            &lt;none&gt;
Annotations:       &lt;none&gt;
Selector:          &lt;none&gt;
Type:              ExternalName
IP Families:       &lt;none&gt;
IP:
IPs:               &lt;none&gt;
External Name:     www.baidu.com
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre>
<h3 id="验证集群内部访问">验证集群内部访问</h3>
<pre><code># 创建busybox容器进行访问测试
[root@master01 ~/service]# kubectl run -it --rm dns-test --image=busybox:1.28
If you don't see a command prompt, try pressing enter.

# nslookup 验证
/ # nslookup baidu-externalname
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      baidu-externalname
Address 1: 2409:8c00:6c21:118b:0:ff:b0e8:f003
Address 2: 2409:8c00:6c21:11eb:0:ff:b0bf:59ca
Address 3: 39.156.70.239
Address 4: 39.156.70.46

# ping进行访问
/ # ping  baidu-externalname
PING baidu-externalname (39.156.70.239): 56 data bytes
64 bytes from 39.156.70.239: seq=0 ttl=127 time=15.301 ms
64 bytes from 39.156.70.239: seq=1 ttl=127 time=14.258 ms
64 bytes from 39.156.70.239: seq=2 ttl=127 time=29.040 ms
</code></pre>
<h2 id="service之loadbalancer省略">Service之LoadBalancer（省略）</h2>
<p>LoadBalancer目前没有云环境，在这儿先省略</p>
<h2 id="service的管理">Service的管理</h2>
<h3 id="查看service-1">查看Service</h3>
<p>语法：</p>
<pre><code>kubectl get svc &lt;svc-name&gt; -n &lt;namespace&gt;
</code></pre>
<p>示例：</p>
<pre><code>[root@master01 ~/service]# kubectl get svc
NAME                  TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)           AGE
baidu-externalname    ExternalName   &lt;none&gt;        www.baidu.com   &lt;none&gt;            23m
kubernetes            ClusterIP      10.96.0.1     &lt;none&gt;          443/TCP           13d
nginx-svc-clusterip   ClusterIP      10.96.3.77    &lt;none&gt;          6789/TCP          4d20h
tomcat-svc-nodeport   NodePort       10.96.0.110   &lt;none&gt;          16789:31180/TCP   49m
</code></pre>
<h3 id="修改service">修改Service</h3>
<p>有两种方式，一种是通过<code>kubectl edit svc &lt;svc-name&gt;</code>来进行修改，会打开一个类似vim的界面，修改其对应的值即可，最后wq保存即可应用你的配置.<br>
另一种方式则是修改对应的资源文件，最后使用<code>kubectl apply -f &lt;file&gt;</code>即可。</p>
<h3 id="删除service">删除Service</h3>
<p>语法：</p>
<pre><code>kubectl delete svc &lt;svc-name&gt; -n &lt;namespace&gt;
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/huangSir-devops/" target="_blank">huangSir-devops</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/huangSir-devops/p/18859122" target="_blank">https://www.cnblogs.com/huangSir-devops/p/18859122</a>，微信Vac666666，欢迎交流</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2134268651400463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 13:09">2025-05-10 13:08</span>&nbsp;
<a href="https://www.cnblogs.com/huangSir-devops">huangSir-devops</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18859122);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18859122', targetLink: 'https://www.cnblogs.com/huangSir-devops/p/18859122', title: 'K8s新手系列之Service资源' })">举报</a>
</div>
        