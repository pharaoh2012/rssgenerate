
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18958338" title="发布于 2025-06-30 18:41">
    <span role="heading" aria-level="2">9.Java SDK源码分析系列笔记-LinkedHashMap</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-使用" rel="noopener nofollow">2. 使用</a></li><li><a href="#3-实现" rel="noopener nofollow">3. 实现</a><ul><li><a href="#31-uml" rel="noopener nofollow">3.1. uml</a></li><li><a href="#32-构造方法" rel="noopener nofollow">3.2. 构造方法</a></li><li><a href="#33-put" rel="noopener nofollow">3.3. put</a><ul><li><a href="#331-创建linkedhashmap增强的节点--entry既是node数组的节点又是双向链表的节点" rel="noopener nofollow">3.3.1. 创建LinkedHashMap增强的节点--Entry【既是Node数组的节点又是双向链表的节点】</a><ul><li><a href="#3311-创建的时候就把节点插入到双向链表尾部" rel="noopener nofollow">3.3.1.1. 创建的时候就把节点插入到双向链表尾部</a></li></ul></li><li><a href="#332-put的节点不是新插入的而是更新value需要维护双向链表的顺序输出的顺序" rel="noopener nofollow">3.3.2. put的节点（不是新插入的而是更新value），需要维护双向链表的顺序【输出的顺序】</a><ul><li><a href="#3321-把这个节点移动到双向链表尾部" rel="noopener nofollow">3.3.2.1. 把这个节点移动到双向链表尾部</a></li></ul></li><li><a href="#333-put的节点不管是新插入的还是更新value后判断是否需要删除头节点最少访问的节点" rel="noopener nofollow">3.3.3. put的节点（不管是新插入的还是更新value）后判断是否需要删除头节点【最少访问的节点】</a></li></ul></li><li><a href="#34-get" rel="noopener nofollow">3.4. get</a><ul><li><a href="#341-get节点后需要维护双向链表的顺序输出的顺序" rel="noopener nofollow">3.4.1. get节点后需要维护双向链表的顺序【输出的顺序】</a><ul><li><a href="#3411-把访问的当前节点放到链表的末尾" rel="noopener nofollow">3.4.1.1. 把访问的当前节点放到链表的末尾</a></li></ul></li></ul></li><li><a href="#35-containskey" rel="noopener nofollow">3.5. containsKey</a></li><li><a href="#36-containsvalue" rel="noopener nofollow">3.6. containsValue</a></li><li><a href="#37-remove" rel="noopener nofollow">3.7. remove</a><ul><li><a href="#371-remove节点后需要从双向链表删除该节点" rel="noopener nofollow">3.7.1. remove节点后需要从双向链表删除该节点</a></li></ul></li><li><a href="#38-entryset" rel="noopener nofollow">3.8. entrySet</a><ul><li><a href="#381-要研究的代码" rel="noopener nofollow">3.8.1. 要研究的代码</a></li><li><a href="#382-linkedhashmapentryset返回的是linkedentryset" rel="noopener nofollow">3.8.2. LinkedHashMap.entrySet()返回的是LinkedEntrySet</a></li><li><a href="#383-linkedhashmapentrysetiterator返回的是linkedentryiterator" rel="noopener nofollow">3.8.3. LinkedHashMap.entrySet().iterator()返回的是LinkedEntryIterator</a><ul><li><a href="#3831-linkedentryiterator继承了linkedhashiterator" rel="noopener nofollow">3.8.3.1. LinkedEntryIterator继承了LinkedHashIterator</a></li></ul></li></ul></li></ul></li><li><a href="#4-总结" rel="noopener nofollow">4. 总结</a></li><li><a href="#5-参考" rel="noopener nofollow">5. 参考</a></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<ul>
<li>使用双向链表+HashMap（数组+链表+红黑树）实现</li>
<li>相比于HashMap保存了顺序
<ul>
<li>迭代时输出的顺序是
<ul>
<li>按照插入节点的顺序来输出</li>
<li>也可以指定成按照访问的顺序输出(LRU)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-使用">2. 使用</h2>
<ul>
<li>按照插入节点的顺序来输出</li>
</ul>
<pre><code class="language-java">public class LinkedHashMapTest
{
    public static void main(String[] args)
    {
        LinkedHashMap&lt;String,Object&gt; map = new LinkedHashMap&lt;&gt;();
        map.put("name","zsk");
        map.put("age",24);
        map.put("height", 172L);

        Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator();
        while (iterator.hasNext())
        {
            Map.Entry&lt;String, Object&gt; entry = iterator.next();
            /*插入的顺序是怎样那么输出就是怎样
            *   name=zsk
                age=24
                height=172
            * */
            System.out.println(entry);
        }
        //上面的输出跟这个一样

        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet())
        {
            /*插入的顺序是怎样那么输出就是怎样
            *   name=zsk
                age=24
                height=172
            * */
            System.out.println(entry);
        }

        System.out.println(map.containsKey("name"));//true
        System.out.println(map.get("name"));//zsk
        map.remove("name");
        System.out.println(map.containsKey("name"));//false
    }
}
</code></pre>
<ul>
<li>按照访问的顺序输出</li>
</ul>
<pre><code class="language-java">public class LinkedHashMapTest
{
    public static void main(String[] args)
    {
        LinkedHashMap&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(2, 0.75F, true);
        map.put("1", "a");
        map.put("2", "b");
        map.put("3", "c");


        Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator();
        while (iterator.hasNext())
        {
            Map.Entry&lt;String, Object&gt; entry = iterator.next();
            //            1=a
            //            2=b
            //            3=c
            System.out.println(entry);
        }
        //上面的输出跟这个一样

        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet())
        {
            //            1=a
            //            2=b
            //            3=c
            System.out.println(entry);
        }

        System.out.println(map.get("1"));//访问了1，那么1所在的节点被移到链表末尾
        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet())
        {
            //最近被访问的节点被放到链表末尾
            //            2=b
            //            3=c
            //            1=a
            System.out.println(entry);
        }
    }
}


</code></pre>
<h2 id="3-实现">3. 实现</h2>
<h3 id="31-uml">3.1. uml</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200123101454.png" class="lazyload"><br>
继承了HashMap，可克隆，可序列化</p>
<h3 id="32-构造方法">3.2. 构造方法</h3>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt;
    extends HashMap&lt;K,V&gt;//继承HashMap 
    implements Map&lt;K,V&gt;
{
	//链表的节点。双向链表
	 static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
		    Entry&lt;K,V&gt; before, after;
		    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
		        super(hash, key, value, next);
		    }
		}


    //双向链表的头尾节点
    transient LinkedHashMap.Entry&lt;K,V&gt; head;
    transient LinkedHashMap.Entry&lt;K,V&gt; tail;

    //true的话保持访问的顺序，false的话保持插入的顺序
    final boolean accessOrder;
	public LinkedHashMap() {
		//调用HashMap的构造方法
	    super();
	    accessOrder = false;
	}
}
</code></pre>
<p>LinkedHashMap继承了HashMap，所以map的get、set、remove等方法都是调用的HashMap的方法，而且LinkedHashMap还增强了HashMap的Node，定义了自己的Entry，加入了双向链表</p>
<h3 id="33-put">3.3. put</h3>
<p>其实就是调用的HashMap的put方法把插入新的节点或者替换value，只不过多了一些其他操作</p>
<ul>
<li>HashMap.put</li>
</ul>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        //LinkedHashMap重写了newNode方法
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //节点已经存在，只是更新value的情况
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            //需要维护双向链表中的顺序
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    //removeEldest方法返回true的时候，需要删除头节点【最少访问的节点】
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<p>需要注意的以下几点：</p>
<ul>
<li>12行：LinkedHashMap重写了newNode方法</li>
<li>35-42行：更新value之后要维护双向链表中的顺序</li>
<li>48行：不管是插入了新的节点还是更新了value，都需要根据情况（removeEldest方法是否返回true）删除链表头节点</li>
</ul>
<h4 id="331-创建linkedhashmap增强的节点--entry既是node数组的节点又是双向链表的节点">3.3.1. 创建LinkedHashMap增强的节点--Entry【既是Node数组的节点又是双向链表的节点】</h4>
<ul>
<li>LinkedHashMap.newNode</li>
</ul>
<pre><code class="language-java">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    //创建的是LinkedHashMap增强的Entry
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    //插入到链表尾部
    linkNodeLast(p);
    return p;
}
</code></pre>
<h5 id="3311-创建的时候就把节点插入到双向链表尾部">3.3.1.1. 创建的时候就把节点插入到双向链表尾部</h5>
<ul>
<li>linkNodeLast</li>
</ul>
<pre><code class="language-java">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    tail = p;
    //把当前节点插入到链表的末尾的操作
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}
</code></pre>
<h4 id="332-put的节点不是新插入的而是更新value需要维护双向链表的顺序输出的顺序">3.3.2. put的节点（不是新插入的而是更新value），需要维护双向链表的顺序【输出的顺序】</h4>
<pre><code class="language-java">//节点已经存在，只是更新value的情况
    if (e != null) { // existing mapping for key
        V oldValue = e.value;
        if (!onlyIfAbsent || oldValue == null)
            e.value = value;
        //需要维护双向链表中的顺序
        afterNodeAccess(e);
        return oldValue;
    }
</code></pre>
<h5 id="3321-把这个节点移动到双向链表尾部">3.3.2.1. 把这个节点移动到双向链表尾部</h5>
<ul>
<li>afterNodeAccess</li>
</ul>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    //指定了访问顺序 并且 当前节点不是尾巴节点【即不是新插入的节点】
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        //以下的操作把当前节点移动到双向链表的末尾
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h4 id="333-put的节点不管是新插入的还是更新value后判断是否需要删除头节点最少访问的节点">3.3.3. put的节点（不管是新插入的还是更新value）后判断是否需要删除头节点【最少访问的节点】</h4>
<ul>
<li>afterNodeInsertion</li>
</ul>
<pre><code class="language-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    //removeEldestEntry返回true的时候【场景：比如定义LRU算法超过一定容量删除最少访问的节点】
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
       //删除头节点
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
</code></pre>
<h3 id="34-get">3.4. get</h3>
<p>其实就是调用HashMap的getNode方法获取节点，然后在调用LinkedHashMap的afterNodeAccess把访问的当前节点放到链表的末尾</p>
<ul>
<li>LinkedHashMap.get</li>
</ul>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
	//调用HashMap的getNode获取节点
    if ((e = getNode(hash(key), key)) == null)
        return null;
    //如果设置按照访问顺序的话，那么
    if (accessOrder)
        afterNodeAccess(e);
    
    return e.value;
}
</code></pre>
<ul>
<li>7-8行：如果设置按照访问顺序的话，那么调用LinkedHashMap的afterNodeAccess把当前访问的节点移动到双向链表的末尾（最新的节点）</li>
</ul>
<h4 id="341-get节点后需要维护双向链表的顺序输出的顺序">3.4.1. get节点后需要维护双向链表的顺序【输出的顺序】</h4>
<pre><code class="language-java">//如果设置按照访问顺序的话，那么
if (accessOrder)
    afterNodeAccess(e);
</code></pre>
<h5 id="3411-把访问的当前节点放到链表的末尾">3.4.1.1. 把访问的当前节点放到链表的末尾</h5>
<ul>
<li>LinkedHashMap afterNodeAccess<br>
同put操作一样，就是把访问的当前节点放到链表的末尾</li>
</ul>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
    	//p代表当前节点，a代表后一个节点，b代表前一个节点
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        //前面节点的next指向后一个节点
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;

        //后一个节点的prev指向前一个节点
        if (a != null)
            a.before = b;
        else
            last = b;

        //当前节点的prev指向尾节点，尾节点的next指向当前节点
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        //更新尾节点为当前节点
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h3 id="35-containskey">3.5. containsKey</h3>
<p>就是调用HashMap的containsKey方法</p>
<pre><code class="language-java">public boolean containsKey(Object key) {
    //依然是HashMap.getNode,没什么特殊的地方
    return getNode(hash(key), key) != null;
}
</code></pre>
<h3 id="36-containsvalue">3.6. containsValue</h3>
<p>重写了HashMap的方法，效率更高</p>
<pre><code class="language-java">public boolean containsValue(Object value) {
	//遍历双向链表，效率O（N）,不同于HashMap的O(N2)
    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) {
        V v = e.value;
        if (v == value || (value != null &amp;&amp; value.equals(v)))
            return true;
    }
    return false;
}

</code></pre>
<h3 id="37-remove">3.7. remove</h3>
<p>其实就是调用HashMap的remove方法删除节点，再调用LinkedHashMap的afterNodeRemoval把当前节点从双向链表中删除</p>
<ul>
<li>HashMap.remove</li>
</ul>
<pre><code class="language-java">public V remove(Object key) {
    Node&lt;K,V&gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            //删除了节点后需要维护双向链表
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<h4 id="371-remove节点后需要从双向链表删除该节点">3.7.1. remove节点后需要从双向链表删除该节点</h4>
<ul>
<li>LinkedHashMap afterNodeRemoval</li>
</ul>
<pre><code class="language-java">void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    //以下的操作把当前删除的节点从双向链表中删除
	//p是当前被删除的节点，b是p的前一个节点，a是p的后一个节点
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    p.before = p.after = null;
    //修改前一个节点的next指针
    if (b == null)
        head = a;
    else
        b.after = a;
    //修改后一个节点的prev指针
    if (a == null)
        tail = b;
    else
        a.before = b;
}
</code></pre>
<h3 id="38-entryset">3.8. entrySet</h3>
<h4 id="381-要研究的代码">3.8.1. 要研究的代码</h4>
<pre><code class="language-java">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator();
</code></pre>
<ul>
<li>LinkedHashMap entrySet</li>
</ul>
<pre><code class="language-java">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
    //这个entrySet属性什么时候set的？
    //返回LinkedEntrySet
    return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;
}
</code></pre>
<p>调用map.entrySet()返回的是LinkedEntrySet，如下</p>
<h4 id="382-linkedhashmapentryset返回的是linkedentryset">3.8.2. LinkedHashMap.entrySet()返回的是LinkedEntrySet</h4>
<ul>
<li>LinkedEntrySet</li>
</ul>
<pre><code class="language-java">final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
    public final int size()                 { return size; }
    public final void clear()               { LinkedHashMap.this.clear(); }
    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
        //遍历器是LinkedEntryIterator
        return new LinkedEntryIterator();
    }
    public final boolean contains(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
        Object key = e.getKey();
        Node&lt;K,V&gt; candidate = getNode(hash(key), key);
        return candidate != null &amp;&amp; candidate.equals(e);
    }
    public final boolean remove(Object o) {
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
            Object key = e.getKey();
            Object value = e.getValue();
            return removeNode(hash(key), key, value, true, true) != null;
        }
        return false;
    }
    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
        return Spliterators.spliterator(this, Spliterator.SIZED |
                                        Spliterator.ORDERED |
                                        Spliterator.DISTINCT);
    }
    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
        if (action == null)
            throw new NullPointerException();
        int mc = modCount;
        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)
            action.accept(e);
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>再调用LinkedEntrySet的iterator返回的是LinkedEntryIterator</p>
<h4 id="383-linkedhashmapentrysetiterator返回的是linkedentryiterator">3.8.3. LinkedHashMap.entrySet().iterator()返回的是LinkedEntryIterator</h4>
<pre><code class="language-LinkedEntryIterator">final class LinkedEntryIterator extends LinkedHashIterator//继承了LinkedHashIterator
        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        //重写了next方法，调用LinkedHashIterator的nextNode
        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }
    }
</code></pre>
<p>这个LinkedEntryIterator继承了LinkedHashIterator，如下</p>
<h5 id="3831-linkedentryiterator继承了linkedhashiterator">3.8.3.1. LinkedEntryIterator继承了LinkedHashIterator</h5>
<ul>
<li>LinkedHashIterator</li>
</ul>
<pre><code class="language-java"> abstract class LinkedHashIterator {
    LinkedHashMap.Entry&lt;K,V&gt; next;
    LinkedHashMap.Entry&lt;K,V&gt; current;
    int expectedModCount;

    LinkedHashIterator() {
    	//从链表头部开始遍历
        next = head;
        expectedModCount = modCount;
        current = null;
    }

    public final boolean hasNext() {
        return next != null;
    }

	//next会调用这个方法
    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() {
        LinkedHashMap.Entry&lt;K,V&gt; e = next;
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        if (e == null)
            throw new NoSuchElementException();
        //链表中当前节点的下一个节点
        current = e;
        next = e.after;
        return e;
    }

    public final void remove() {
        Node&lt;K,V&gt; p = current;
        if (p == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        current = null;
        K key = p.key;
    	//HashMap的removeNode方法
        removeNode(hash(key), key, null, false, false);
        expectedModCount = modCount;
    }
}

</code></pre>
<p>可以看出迭代输出的时候是从头到尾输出的，也就是旧的先打印，然后在打印新的节点</p>
<h2 id="4-总结">4. 总结</h2>
<p>在HashMap的基础上+双向链表实现的<br>
迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出。<br>
而双链表节点的顺序在LinkedHashMap的get、put时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</p>
<h2 id="5-参考">5. 参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/2889777/difference-between-hashmap-linkedhashmap-and-treemap" target="_blank" rel="noopener nofollow">java - Difference between HashMap, LinkedHashMap and TreeMap - Stack Overflow</a></li>
<li><a href="https://juejin.im/post/5997ff966fb9a024851009b7#heading-9" target="_blank" rel="noopener nofollow">面试必备：LinkedHashMap源码解析（JDK8） - 掘金</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-30 18:42">2025-06-30 18:41</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18958338);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18958338', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18958338', title: '9.Java SDK源码分析系列笔记-LinkedHashMap' })">举报</a>
</div>
        