
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18711375" title="发布于 2025-02-12 13:01">
    <span role="heading" aria-level="2">C# Winform 当音频播放完成后，播放下一个音频，怎么知道音频有没有播放完成</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>程序在预警时，会发出报警音，当报警音频播放时间，超过预警频率时，就会像我们打印文档一样，像打印机发送10次打印任务。当打出第1张纸的时候，这时候想取消打印。就不能在电脑端通过软件操作了。因此为了避免这种事情发生，就只有等打印机打完一张，再发下一个任务。这样的话，可以随时发起取消打印任务。</p>
<p>如果实现在报警音频结束前，不再给任务</p>
<h3 id="soundplayer">SoundPlayer</h3>
<p>在C#中，SoundPlayer 类本身没有直接提供事件或属性来检测音频是否播放完成。不过，你可以通过以下方法来实现这一功能：PlaySync 方法会阻塞当前线程，直到音频播放完成。<font color="red">你可以将播放操作放在一个单独的线程中，以避免阻塞主线程。</font><br>
满足不了我想要的功能</p>
<pre><code class="language-C#">using System;
using System.Media;
using System.Threading;

class Program
{
    static void Main()
    {
        string[] audioFiles = { "audio1.wav", "audio2.wav", "audio3.wav" };
        SoundPlayer player = new SoundPlayer();

        foreach (string file in audioFiles)
        {
            //TODO 如果任务取消，break 跳出循环
            player.SoundLocation = file;
            player.Load(); // 加载音频文件
            player.PlaySync(); // 阻塞播放，直到当前音频播放完成
            Console.WriteLine($"播放完成: {file}");
        }

        Console.WriteLine("所有音频播放完成");
    }
}
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>实现简单，代码直观。</li>
<li>不需要额外的事件处理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>PlaySync会阻塞当前线程，可能导致UI线程卡住（如果是在UI线程中运行）。</li>
</ul>
<h3 id="naudio">NAudio</h3>
<p><a href="https://www.cnblogs.com/vipsoft" target="_blank">C# Winform 通过 NAudio 获取控制电脑操作系统音量</a><br>
NAudio库提供了更强大的音频处理功能，可以通过PlaybackStopped事件来实现连续播放<br>
<font color="#ad6a71">NAudio 中，WaveOutEvent 是一个用于播放音频的类，它封装了底层的音频设备资源。如果在使用完毕后没有调用 Dispose() 方法，垃圾回收器（GC）会在对象被回收时调用其析构函数（Finalize），但此时可能已经无法正确释放资源，从而导致错误。</font><br>
如果 WaveOutEvent 使用了 AudioFileReader 或其他资源，确保这些资源也被释放：</p>
<pre><code class="language-c#">using System;
using System.Collections.Generic;
using NAudio.Wave;

public class MyForm : Form
{
    private Label myLabel;

    public MyForm()
    { 
 
    }
    
    WaveOutEvent waveOut; 
    AudioFileReader audioFile； //要单独拿出来，进行释放
	
    List&lt;string&gt; audioFiles = new List&lt;string&gt; { "audio1.wav", "audio2.wav", "audio3.wav" };
    
    private void OnLineCustodyOrderFrm_Load(object sender, EventArgs e)
    {
        waveOut = new WaveOutEvent();
        waveOut.PlaybackStopped += WaveOut_PlaybackStopped;
        PlayNextAudio();
    }

    private void WaveOut_PlaybackStopped(object sender, StoppedEventArgs e)
    {
        if (waveOut != null &amp;&amp; waveOut.PlaybackState == PlaybackState.Stopped)
        {
            waveOut.Dispose();
        }
        Console.WriteLine($"播放完成: {audioFiles[currentIndex - 1]}");
        PlayNextAudio();
    }

    private void PlayNextAudio()
    {
        if (currentIndex &lt; audioFiles.Count)
        {
            audioFile = new AudioFileReader(audioFiles[currentIndex]);
            waveOut.Init(audioFile);
            waveOut.Play();
            Console.WriteLine($"开始播放: {audioFiles[currentIndex]}");
            currentIndex++;
        }
        else
        {
            Console.WriteLine("所有音频播放完成");
        }
    }

    private void MyForm_FormClosing(object sender, FormClosingEventArgs e)
    {
         CloseWaveOut();
    }

    private void CloseWaveOut()
    {
        if (waveOut != null)
        {
           waveOut.Stop();
        }
        if (AudioFile != null)
        {
            AudioFile.Dispose();
            AudioFile = null;
        }
        //窗体关系，要释放资源
        if (waveOut != null)
        {
            waveOut.Dispose(); // 确保控件被释放
            waveOut = null;
        }
    }
}
</code></pre>
<p>关键点<br>
<strong>显式释放资源：</strong></p>
<ul>
<li>在每次音频播放完成后，调用 waveOut.Dispose() 释放当前的 WaveOutEvent 对象。</li>
<li>在程序退出前，确保释放所有资源。</li>
</ul>
<p><strong>重新创建 WaveOutEvent：</strong></p>
<ul>
<li>每次播放新的音频文件时，重新创建一个新的 WaveOutEvent 对象，而不是复用之前的对象。</li>
</ul>
<p><strong>释放 AudioFileReader：</strong></p>
<ul>
<li>如果使用了 AudioFileReader，也需要确保在播放完成后释放它。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18711375" target="_blank">https://www.cnblogs.com/vipsoft/p/18711375</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="6.767592915350694" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 14:37">2025-02-12 13:01</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">605</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18711375" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18711375);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18711375', targetLink: 'https://www.cnblogs.com/vipsoft/p/18711375', title: 'C# Winform 当音频播放完成后，播放下一个音频，怎么知道音频有没有播放完成' })">举报</a>
</div>
        