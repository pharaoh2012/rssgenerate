<!----> <meta itemprop="headline" content="别再用 100vh 了！移动端视口高度的终极解决方案"> <meta itemprop="keywords" content="前端,CSS,HTML"> <meta itemprop="datePublished" content="2025-06-28T09:48:48.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            别再用 100vh 了！移动端视口高度的终极解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-06-28T09:48:48.000Z" title="Sat Jun 28 2025 09:48:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-06-28
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    18,725
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>作为一名前端开发者，我们一定都遇到过这样的需求：实现一个占满整个屏幕的欢迎页、弹窗蒙层或者一个 fixed 定位的底部菜单。</p>
<p>直觉告诉我们，这很简单，给它一个 <code>height: 100vh</code> 就行了。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.fullscreen-element</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10em</span>;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
}
</code></pre>
<p>在PC端预览，完美！然而，当你在手机上打开时，可能会看到下面这个令人抓狂的场景：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7f392f4a85349f8af693c0711fa214f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755316846&amp;x-signature=mxD1lMbU2Q54PWBYcOdk4elMTkE%3D" alt="27589118d4b2c7b4b9438f86121f084.png" loading="lazy"></p>
<p>明明是 <code>100vh</code>，为什么会超出屏幕高度？这个烦人的滚动条到底从何而来？</p>
<p>如果你也曾为此抓耳挠腮，那么恭喜你，这篇文章就是你的“终极答案”。今天，我将带你彻底搞懂 <code>100vh</code> 在移动端的“坑”，并为你介绍当下最完美的解决方案。</p>
<hr>
<h3 data-id="heading-0">1. 问题根源：移动端动态变化的“视口”</h3>
<p>要理解问题的本质，我们首先要明白 <code>vh</code> (Viewport Height) 单位的定义：<code>1vh</code> 等于视口高度的 1%。</p>
<p>在PC端，浏览器窗口大小是相对固定的，所以 <code>100vh</code> 就是浏览器窗口的可见高度，这没有问题。</p>
<p>但在移动端，情况变得复杂了。为了在有限的屏幕空间里提供更好的浏览体验，手机浏览器（尤其是Safari和Chrome）的<strong>地址栏和底部工具栏是动态变化的</strong>。</p>
<ul>
<li><strong>初始状态</strong>：当你刚进入页面时，地址栏和工具栏是完全显示的。</li>
<li><strong>滚动时</strong>：当你向下滚动页面，这些UI元素会自动收缩，甚至隐藏，以腾出更多空间展示网页内容。</li>
</ul>
<p><strong>关键点来了</strong>：大多数移动端浏览器将 <code>100vh</code> 定义为“最大视口高度”，也就是当地址栏和工具栏完全收起时的高度。</p>
<p>这就导致了：</p>
<blockquote>
<p>在页面初始加载、地址栏还未收起时，<code>100vh</code> 的实际计算高度 &gt; 屏幕当前可见区域的高度。</p>
</blockquote>
<p>于是，那个恼人的滚动条就出现了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be964290f0714371af7bbcb8c07e9a39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755316846&amp;x-signature=W2aIkQlkL9oofTjSxvTXM74Au%2B0%3D" alt="image.png" loading="lazy"></p>
<hr>
<h3 data-id="heading-1">2. “过去式”的解决方案：JavaScript 动态计算</h3>
<p>在很长一段时间里，前端开发者们只能求助于 JavaScript 来解决这个问题。思路很简单：通过 <code>window.innerHeight</code> 获取当前可见视口的高度，然后用它来动态设置元素的 <code>height</code>。</p>
<p>JavaScript</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setRealVH</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> vh = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * <span class="hljs-number">0.01</span>;
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-title function_">setProperty</span>(<span class="hljs-string">'--vh'</span>, <span class="hljs-string">`<span class="hljs-subst">${vh}</span>px`</span>);
}

<span class="hljs-comment">// 初始加载时设置</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, setRealVH);
<span class="hljs-comment">// 窗口大小改变或旋转屏幕时重新设置</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, setRealVH);
</code></pre>
<p>然后在 CSS 中这样使用：</p>
<p>CSS</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.fullscreen-element</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--vh, <span class="hljs-number">1vh</span>) * <span class="hljs-number">100</span>);
}
</code></pre>
<p><strong>这个方案的缺点显而易见：</strong></p>
<ul>
<li><strong>性能开销</strong>：监听 <code>resize</code> 事件过于频繁，可能会引发性能问题。</li>
<li><strong>逻辑耦合</strong>：纯粹的样式问题却需要JS来解决，不够优雅。</li>
<li><strong>时机问题</strong>：执行时机需要精确控制，否则可能出现闪烁。</li>
</ul>
<p>虽然能解决问题，但这绝不是我们想要的“终极方案”。</p>
<hr>
<h3 data-id="heading-2">3. “现在时”的终极解决方案：CSS动态视口单位</h3>
<p>谢天谢地，CSS 工作组听到了我们的呼声！为了解决这个老大难问题，CSS Values and Units Module Level 4 引入了一套全新的动态视口单位。</p>
<p>它们就是我们今天的“主角”：</p>
<ul>
<li><code>svh</code> (Small Viewport Height): <strong>最小视口高度</strong>。对应于地址栏和工具栏完全展开时的可见高度。</li>
<li><code>lvh</code> (Large Viewport Height): <strong>最大视口高度</strong>。对应于地址栏和工具栏完全收起时的高度（这其实就等同于旧的 <code>100vh</code>）。</li>
<li><code>dvh</code> (Dynamic Viewport Height): <strong>动态视口高度</strong>。这是最智能、最实用的单位！它的值会随着浏览器UI元素（地址栏）的出现和消失而动态改变。</li>
</ul>
<p>所以，我们的终极解决方案就是：</p>
<p>CSS</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.fullscreen-element</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100s</span>vh; <span class="hljs-comment">/* 如果你希望高度固定，且永远不被遮挡 */</span>
  <span class="hljs-comment">/* 或者，也是我最推荐的 */</span>
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100</span>dvh; <span class="hljs-comment">/* 如果你希望元素能动态地撑满整个可见区域 */</span>
}
</code></pre>
<p>使用 <code>100dvh</code>，当地址栏收起时，元素高度会平滑地增加以填满屏幕；当地址栏滑出时，元素高度又会平滑地减小。整个过程如丝般顺滑，没有任何滚动条，完美！</p>
<h4 data-id="heading-3">浏览器兼容性</h4>
<p>你可能会担心兼容性问题。好消息是，从2023年开始，所有主流现代浏览器（Safari, Chrome, Edge, Firefox）都已经支持了这些新的视口单位。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff53e73a0fa0486883c1fce03dd9f38e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755316846&amp;x-signature=iMOdXvQsTS04G1LVtghbEDQM5kc%3D" alt="image.png" loading="lazy"></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb138a4a52e34b85910a2e2a4c5260a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755316846&amp;x-signature=Nu7Q2sSjNadZL6j97CmjKAm4x3w%3D" alt="image.png" loading="lazy">
<em>(数据截至2025年6月，兼容性已非常好)</em></p>
<p>可以看到，兼容性已经非常理想。除非你需要支持非常古老的浏览器版本，否则完全可以放心地在生产环境中使用。</p>
<hr>
<h3 data-id="heading-4"><strong>告别 <code>100vh</code> 的时代</strong></h3>
<p>让我们来快速回顾一下：</p>
<ol>
<li><strong>问题</strong>：在移动端，<code>100vh</code> 通常被解析为“最大视口高度”，导致在浏览器UI未收起时内容溢出。</li>
<li><strong>旧方案</strong>：使用 JavaScript 的 <code>window.innerHeight</code> 动态计算，但有性能和维护问题。</li>
<li><strong>终极方案</strong>：使用CSS新的动态视口单位，尤其是 <code>100dvh</code>，它能根据浏览器UI的变化自动调整高度，完美解决问题。</li>
</ol>
<p>当需要实现移动端全屏布局时，请大胆地告别 <code>100vh</code>，拥抱 <code>100dvh</code>！</p></div></div>