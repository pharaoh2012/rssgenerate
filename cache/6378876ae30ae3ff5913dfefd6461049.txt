
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhyan8/p/18639011" title="发布于 2024-12-29 15:45">
    <span role="heading" aria-level="2">【OpenGL ES】GLSL基础语法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-前言">1 前言</h1>
<p>​    本文将介绍 GLSL 中数据类型、数组、结构体、宏、运算符、向量运算、矩阵运算、函数、流程控制、精度限定符、变量限定符（in、out、inout）、函数参数限定符等内容，另外提供了一个 include 工具，方便多文件管理 glsl 代码，实现代码的精简、复用。</p>
<p>​    Unity 中 Shader 介绍详见 → <a href="https://zhyan8.blog.csdn.net/article/details/128980596" target="_blank" rel="noopener nofollow">【Unity3D】Shader常量、变量、结构体、函数</a>，渲染管线介绍详见 → <a href="https://zhyan8.blog.csdn.net/article/details/126715869" target="_blank" rel="noopener nofollow">【OpenGL ES】渲染管线</a>。</p>
<h1 id="2-数据类型">2 数据类型</h1>
<h2 id="21-基本数据类型">2.1 基本数据类型</h2>
<h3 id="211-基本数据类型">2.1.1 基本数据类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>void</strong></td>
<td>空类型，即不返回任何值</td>
<td>void fun()</td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td>布尔类型 true、false</td>
<td>bool a = true;</td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>带符号的整数</td>
<td>int a = 0;</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>带符号的浮点数</td>
<td>float a = 1.0; <br>float b = 2.;</td>
</tr>
<tr>
<td><strong>vec2、vec3、vec4</strong></td>
<td>2 维、3 维、4 维浮点数向量</td>
<td>vec2 a = vec2(1., 2.); <br>vec2 b = vec2(1.); // ⇔ vec2(1., 1.) <br>vec3 c = vec3(a, 3.); // ⇔ vec3(1., 2., 3.)</td>
</tr>
<tr>
<td><strong>bvec2、bvec3、bvec4</strong></td>
<td>2 维、3 维、4 维布尔向量</td>
<td>bvec2 a = bvec2(true, false); <br>bvec2 b = bvec2(true); // ⇔ bvec2(true, true) <br>bec3 c = bvec3(a, true); // ⇔ bvec3(true, false, true)</td>
</tr>
<tr>
<td><strong>ivec2、ivec3、ivec4</strong></td>
<td>2 维、3 维、4 维整数向量</td>
<td>ivec2 a = ivec2(1, 2); <br>ivec2 b = ivec2(1); // ⇔ ivec2(1, 1) <br>ivec3 c = ivec3(a, 3); // ⇔ ivec3(1, 2, 3)</td>
</tr>
<tr>
<td><strong>mat2、mat3、mat4</strong></td>
<td>2x2、3x3、4x4 浮点数矩阵 (列向量)</td>
<td>mat2 a = mat2(1., 2., 3., 4.); <br>mat2 b = mat2(1.); // ⇔ mat2(1., 1., 1., 1.)</td>
</tr>
<tr>
<td><strong>sampler2D</strong></td>
<td>2D 纹理</td>
<td>sampler2D sampler;</td>
</tr>
<tr>
<td><strong>samplerCube</strong></td>
<td>盒纹理</td>
<td>samplerCube sampler;</td>
</tr>
</tbody>
</table>
<p>​    说明：mat2、mat3、mat4 中的元素都是按照列向量的顺序排列的，即 mat2 m = mat2(m11, m21, m12, m22) 对应的公式如下。</p>
<p><img src="https://img2024.cnblogs.com/blog/3135663/202412/3135663-20241229154325404-1402468398.png" alt="img" loading="lazy"></p>
<h3 id="212-向量分量访问">2.1.2 向量分量访问</h3>
<p>​    GLSL 中的向量（vec2、vec3、vec4）可以表示一个空间坐标 (x, y, z, w)，也可以表示一个颜色 (r, g, b, a)，还可以表示一个纹理坐标 (s, t ,p, q)，所以 GLSL 提供了多样的分量访问方式。</p>
<pre><code class="language-cpp">vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
float x1 = v.x; // 1.0
float x2 = v.r; // 1.0
float x3 = v.s; // 1.0
float x4 = v[0]; // 1.0

vec3 xyz = v.xyz; // vec3(1.0, 2.0, 3.0)
vec3 stq = v.stq; // vec3(1.0, 2.0, 3.0)
vec3 rgb = v.rgb; // vec3(1.0, 2.0, 3.0)
vec3 abc = vec3(v[0], v[1], v[2]); // vec3(1.0, 2.0, 3.0)
</code></pre>
<h3 id="213-数据类型转换">2.1.3 数据类型转换</h3>
<p>​    GLSL 可以使用构造函数进行显式类型转换。</p>
<pre><code class="language-cpp">// 0或0.0转换为false, 非0转换为true
bool a1 = bool(1.0); // true
bool a2 = bool(0); // false

// true转换为1或1.0, false转换为0或0.0
int a3 = int(true); // 1
float a4 = float(false); // 0.0

int a5 = int(2.0); // 2
float a6 = float(1); // 1.0
</code></pre>
<h2 id="22-数组">2.2 数组</h2>
<p>​    GLSL 只支持一维数组。</p>
<pre><code class="language-cpp">// float 数组
float[3] a = float[] (1.0, 2.0, 3.0);
float b[3] = float[] (1.0, 2.0, 3.0);
float c[3] = float[3] (1.0, 2.0, 3.0);

// vec 数组
vec2[2] d = vec2[] (vec2(0.0), vec2(1.0));
</code></pre>
<h2 id="23-结构体">2.3 结构体</h2>
<pre><code class="language-cpp">struct light {
    vec4 color;
    vec3 pos;
};
const light lgt = light(vec4(1.0), vec3(0.0));
</code></pre>
<p>​    说明：结构体中的字段不可用 const 修饰。</p>
<h2 id="24-内置变量">2.4 内置变量</h2>
<table>
<thead>
<tr>
<th><strong>范围</strong></th>
<th><strong>变量</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>顶点着色器的 Output 变量</td>
<td>highp vec4 <strong>gl_Position</strong>;</td>
<td>顶点坐标信息</td>
</tr>
<tr>
<td>顶点着色器的 Output 变量</td>
<td>mediump float <strong>gl_PointSize</strong>;</td>
<td>顶点大小 (只在 GL_POINTS 图元模式下有效)</td>
</tr>
<tr>
<td>片元着色器的 Input 变量</td>
<td>mediump vec4 <strong>gl_FragCoord</strong>;</td>
<td>片元在屏幕空间的坐标，假设屏幕宽高分别为 width、height <br>x: 片元的x坐标，值域 [0, width - 1] <br>y: 片元的x坐标，值域 [0, height - 1] <br>z: 片元的深度坐标，值域 [0, 1] <br>w: 总是 1，通常用于透视除法</td>
</tr>
<tr>
<td>片元着色器的 Input 变量</td>
<td>bool <strong>gl_FrontFacing</strong>;</td>
<td>标志当前图元是否是正面图元的一部分</td>
</tr>
<tr>
<td>片元着色器的 Output 变量</td>
<td>mediump vec4 <strong>gl_FragColor</strong>;</td>
<td>设置当前片点的颜色</td>
</tr>
</tbody>
</table>
<h2 id="25-宏">2.5 宏</h2>
<p>​    与 C 语言一样，GLSL 中也可以通过 #define 定义宏，如下。</p>
<pre><code class="language-cpp">#define PI 3.14159265359
</code></pre>
<p>​    另外，GLSL 也提供了一些内置宏。</p>
<pre><code class="language-cpp">__LINE__ // 当前源码中的行号
__VERSION__ // 当前glsl版本号, 如: 300
GL_ES // 当前运行环境是否是 OPGL ES, 1 表示是
GL_FRAGMENT_PRECISION_HIGH // 当前系统的片元着色器是否支持高浮点精度, 1表示支持
</code></pre>
<h1 id="3-运算符">3 运算符</h1>
<h2 id="31-基础运算符">3.1 基础运算符</h2>
<table>
<thead>
<tr>
<th>优先级 (越小越高)</th>
<th>运算符</th>
<th>说明</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>()</strong></td>
<td>聚组: a * (b + c)</td>
<td>N/A</td>
</tr>
<tr>
<td>2</td>
<td><strong>[]</strong> <br><strong>()</strong>  <br><strong>.</strong> <br><strong>++ --</strong></td>
<td>数组下标 <br>方法参数: fun(arg1, arg2) <br>属性访问 <br>自增 (a++) / 自减 (a--)</td>
<td>L - R</td>
</tr>
<tr>
<td>3</td>
<td><strong>++ --</strong>  <br><strong>+ -</strong> <br><strong>!</strong></td>
<td>自增 (++a) / 自减 (--a) <br>正 (+a) 负 (-a) 号 <br>取反 (!a)</td>
<td>R - L</td>
</tr>
<tr>
<td>4</td>
<td><strong>*</strong> <strong>/</strong> <br><strong>%</strong></td>
<td>乘法 / 除法运算 <br>整数求余运算 (浮点数求余用 mod 函数)</td>
<td>L - R</td>
</tr>
<tr>
<td>5</td>
<td><strong>+ -</strong></td>
<td>加法 / 减法运算</td>
<td>L - R</td>
</tr>
<tr>
<td>7</td>
<td><strong>&lt; &gt; &lt;= &gt;=</strong></td>
<td>关系运算符</td>
<td>L - R</td>
</tr>
<tr>
<td>8</td>
<td><strong>== !=</strong></td>
<td>相等性运算符</td>
<td>L - R</td>
</tr>
<tr>
<td>12</td>
<td><strong>&amp;&amp;</strong></td>
<td>逻辑与</td>
<td>L - R</td>
</tr>
<tr>
<td>13</td>
<td><strong>^^</strong></td>
<td>逻辑排他或 (用处基本等于 !=)</td>
<td>L - R</td>
</tr>
<tr>
<td>14</td>
<td><strong>||</strong></td>
<td>逻辑或</td>
<td>L - R</td>
</tr>
<tr>
<td>15</td>
<td><strong>? :</strong></td>
<td>三目运算符</td>
<td>L - R</td>
</tr>
<tr>
<td>16</td>
<td><strong>= += -= *= /=</strong></td>
<td>赋值和复合赋值</td>
<td>L - R</td>
</tr>
<tr>
<td>17</td>
<td><strong>,</strong></td>
<td>顺序分配运算</td>
<td>L - R</td>
</tr>
</tbody>
</table>
<p>​    说明：GLSL 中没有隐式类型转换，因此任何表达式左右两侧的类型必须一致，以下表达式都是错误的。</p>
<pre><code class="language-cpp">// 以下代码运行时会报错
int a = 2.;
int b = 1. + 2;
float c = 2;
float d = 2. + 1;
bool e = 0;
vec2 f = vec2(1., 2.) * 2;
</code></pre>
<h2 id="32-向量运算符">3.2 向量运算符</h2>
<pre><code class="language-cpp">// 标量与向量运算
vec2 a = vec2(1., 2.) + 3.; // vec2(4., 5.)
vec2 b = 3. + vec2(1., 2.); // vec2(4., 5.)
vec2 c = vec2(1., 2.) * 3.; // vec2(3., 6.)
vec2 d = 3. * vec2(1., 2.); // vec2(3., 6.)

// 向量与向量运算
vec2 e = vec2(1., 2.) + vec2(3., 4.); // vec2(4., 6.)
vec2 f = vec2(1., 2.) * vec2(3., 4.); // vec2(3., 8.)
</code></pre>
<h2 id="33-矩阵运算符">3.3 矩阵运算符</h2>
<pre><code class="language-cpp">// 标量与矩阵运算
mat2 a = mat2(1.) + 2.; // mat2(3.)
mat2 b = 2. + mat2(1.); // mat2(3.)
mat2 c = mat2(1.) * 2.; // mat2(2.)
mat2 d = 2. * mat2(1.); // mat2(2.)

// 向量与矩阵运算
vec2 e = vec2(1., 2.) * mat2(1., 2., 3., 4.); // vec2(5., 11.)
vec2 f = mat2(1., 2., 3., 4.) * vec2(1., 2.); // vec2(7., 10.)

// 矩阵与矩阵运算(矩阵对应元素运算)
mat2 g = mat2(1.) + mat2(2.); // mat2(3.)
mat2 h = matrixCompMult(mat2(1.), mat2(2.)); // mat2(2.)

// 矩阵与矩阵运算(矩阵乘法)
mat2 i = mat2(1., 2., 3., 4.) * mat2(5., 6., 7., 8.); // mat2(23., 34., 31., 46.)
mat2 j = mat2(5., 6., 7., 8.) * mat2(1., 2., 3., 4.); // mat2(19., 22., 43., 50.)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3135663/202412/3135663-20241229154325388-1247803515.png" alt="img" loading="lazy"></p>
<h1 id="4-函数">4 函数</h1>
<h2 id="41-自定义函数">4.1 自定义函数</h2>
<p>​    GLSL 允许在程序的最外部声明函数，函数不能嵌套、不能递归调用，且必须声明返回值类型（无返回值时声明为 void）在其他方面 GLSL 函数与 C 语言函数非常类似。</p>
<pre><code class="language-cpp">vec4 getPosition() { 
    vec4 pos = vec4(0.,0.,0.,1.);
    return pos;
}

void doubleSize(inout float size) {
    size = size * 2.0;
}
</code></pre>
<h2 id="42-内置函数">4.2 内置函数</h2>
<p>​    <strong>1）数值运算</strong></p>
<pre><code class="language-cpp">sign(x)、abs(x) // 符号、绝对值
min(a, b)、max(a, b) // 最值函数
ceil(x)、floor(x)、round(x) // 取整函数
fract(x) // 取小数部分
mod(x, y) // 取余数
sqrt(x)、pow(x)、inversesqrt(x) // 幂函数, inversesqrt(x)=1/sqrt(x)
exp(x)、exp2(x) // 指数函数(e^x、2^x)
log(x)、log2(x) // 对数函数
degrees(x)、radians(x) // 角度转换函数
sin(x)、cos(x)、tan(x)、asin(x)、acos(x)、atan(x) // 三角函数
sinh(x)、cosh(x)、tanh(x) // 双曲线函数
clamp(x, min, max) // 将x约束在min和max之间, 超过边界就取边界值
smoothstep(min, max, x) // 平滑比例, 公式: k=saturate((x-min)/(max-min)), y=k*k*(3-2*k)
mix(a, b, f) // 混合, 公式: y=(1-f)*a+f*b
step(a, b) // 如果a&gt;b, 返回0; 如果a&lt;=b, 返回1; 当a、b是向量时, 每个分量独立判断, 如: step(fixed2(1,1),fixed(0,2))=(0,1)
</code></pre>
<p>​    说明：以上函数输入的可以是：float、vec2、vec3、vec4，且可以逐分量操作；对于整数求余运算，只能用 %；对于浮点数求余运算，只能用 mod。</p>
<p>​    <strong>2）逻辑运算</strong></p>
<pre><code class="language-cpp">bvec z = lessThan(x, y) // 逐分量比较x &lt; y, 将结果写入z的对应位置
bvec z = lessThanEqual(x, y) // 逐分量比较x &lt;= y, 将结果写入z的对应位置
bvec z = greaterThan(x, y) // 逐分量比较x &gt; y, 将结果写入z的对应位置
bvec z = greaterThanEqual(x, y) // 逐分量比较x &gt;= y, 将结果写入z的对应位置
bvec z = equal(x, y) // 逐分量比较x == y, 将结果写入z的对应位置
bvec z = notEqual(x, y) // 逐分量比较x != y, 将结果写入z的对应位置
bvec y = not(x) // bool矢量的逐分量取反
bool y = any(x) // 如果x的任意一个分量是true, 则结果为true
bool y = all(x) // 如果x的所有分量是true, 则结果为true
</code></pre>
<p>​    <strong>3）向量运算</strong></p>
<pre><code class="language-cpp">distance(pos1, pos2) // 计算pos1与pos2之间的距离
length(vec) // 计算向量的模长
normalize(vec) // 计算向量的单位向量
dot(v1, v2) // 向量点乘
cross(v1, v2) // 向量叉乘
reflect(i, n) // 根据入射向量和法线向量, 计算反射向量(i和n不需要归一化)
refract(i, n, ratio); // 根据入射向量、法线向量、折射率比值, 计算折射向量(i和n需要归一化, ratio为入射介质折射率/折射介质折射率, 或sin(折射角)/sin(入射角))
</code></pre>
<p>​    <strong>4）矩阵运算</strong></p>
<pre><code class="language-cpp">// 矩阵与矩阵运算(矩阵对应元素运算)
mat2 a = mat2(1.) + mat2(2.); // mat2(3.)
mat2 b = matrixCompMult(mat2(1.), mat2(2.)); // mat2(2.)

// 矩阵与矩阵运算(矩阵乘法)
mat2 c = mat2(1., 2., 3., 4.) * mat2(5., 6., 7., 8.); // mat2(23., 34., 31., 46.)
mat2 d = mat2(5., 6., 7., 8.) * mat2(1., 2., 3., 4.); // mat2(19., 22., 43., 50.)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3135663/202412/3135663-20241229154325372-229745723.png" alt="img" loading="lazy"></p>
<p>​    <strong>5）纹理查询函数</strong></p>
<pre><code class="language-cpp">vec4 texture(sampler2D sampler, vec2 coord);
vec4 texture2D(sampler2D sampler, vec2 coord);
vec4 texture2DProj(sampler2D sampler, vec3 coord);
vec4 texture2DProj(sampler2D sampler, vec4 coord);
vec4 textureCube(samplerCube sampler, vec3 coord);
</code></pre>
<h1 id="5-流程控制">5 流程控制</h1>
<p>​    GLSL 的流控制与 C 语言非常相似，主要有 if、for、while、continue、break，不同的是 GLSL 中多了 discard。使用 discard 会退出片元着色器，不会执行后面的操作，片元也不会写入帧缓冲区。</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 10; i++) {
    sum += a[i];
    if (sum &gt; 5.0)
        break;
}

while (i &lt; 10) {
    sum += a[i];
    if (i % 3 == 1)
        continue;
    i++;
}

do {
    sum += a[i];
    if (sum &gt; 5.0)
        discard;
    i++;
} while (i &lt; 10)
</code></pre>
<h1 id="6-限定符">6 限定符</h1>
<h2 id="61-精度限定符">6.1 精度限定符</h2>
<p>​    片元着色器中，对于浮点数 GLSL 有 highp（高）、mediump（中）、lowp（低） 三种精度。</p>
<pre><code class="language-cpp">lowp float color;
varying mediump vec2 Coord;
lowp ivec2 foo(lowp mat3);
highp mat4 m;
</code></pre>
<p>​    在片元着色器的第一行加上 precision highp float，表示设定了默认的精度，所有没有显式表明精度的变量都会按照默认精度处理。</p>
<pre><code class="language-cpp">precision highp float;
</code></pre>
<p>​    通过判断系统环境，来选择合适的精度。</p>
<pre><code class="language-cpp">#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif
</code></pre>
<h2 id="62-变量限定符">6.2 变量限定符</h2>
<table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>none</strong></td>
<td>默认的变量限定符，可省略，可读写。</td>
</tr>
<tr>
<td><strong>const</strong></td>
<td>修饰的变量为只读类型，变量在定义时必须初始化。</td>
</tr>
<tr>
<td><strong>attribute</strong></td>
<td>只能在顶点着色器中使用，修饰全局只读变量，一般用于修饰顶点属性，如：顶点的位置、法线、纹理坐标、颜色等。</td>
</tr>
<tr>
<td><strong>uniform</strong></td>
<td>修饰全局只读变量，一般用于修饰程序传递给 shader 的变量，如：屏幕宽高比、光源位置等。</td>
</tr>
<tr>
<td><strong>varying</strong></td>
<td>修饰需要进行光栅化插值的变量，在片元着色器中是只读的，如：纹理坐标等。</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">// 顶点着色器
attribute vec4 a_position;
attribute vec2 a_texCoord0;
varying vec2 v_texCoord0;

void main() {
    gl_Position = vec4(a_position, 1.0);
    v_texCoord0 = a_texCoord0;
}

// 片元着色器
precision highp float;
uniform sampler2D u_texture;
varying vec2 v_texCoord0;

void main() {
  gl_FragColor = texture(u_texture, v_texCoord0);
}
</code></pre>
<h2 id="63-函数参数限定符">6.3 函数参数限定符</h2>
<p>​    函数的参数默认以拷贝的形式传递，即值传递，我们可以为参数添加限定符实现引用传递，GLSL 中提供的参数限定符如下。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>默认的限定符，参数是值传递，在函数中可读写。</td>
</tr>
<tr>
<td>out</td>
<td>参数是引用传递，在函数中只能写（write-only）。</td>
</tr>
<tr>
<td>inout</td>
<td>参数是引用传递，在函数中可读写（read-write）。</td>
</tr>
</tbody>
</table>
<p>​    除了函数的参数可以用 in、out、inout 修饰，全局变量也可以用这些限定符修饰，如下。</p>
<pre><code class="language-cpp">// 顶点着色器
in vec3 a_position;
in vec2 a_texCoord0;
out vec2 v_texCoord0;

void main() {
    gl_Position = vec4(a_position, 1.0);
    v_texCoord0 = a_texCoord0;
}

// 片元着色器
precision highp float;
uniform sampler2D u_texture;
in vec2 v_texCoord0;
out vec4 o_fragColor;

void main() {
    o_fragColor = texture(u_texture, v_texCoord0);
}
</code></pre>
<h1 id="7-include">7 include</h1>
<p>​    GLSL 中没有提供 #include 功能，如以下代码会运行报错。</p>
<pre><code class="language-cpp">#include &lt;shaders/utils/constant.glsl&gt;
</code></pre>
<p>​    要想实现一个 glsl 文件依赖另一个 glsl 文件，可以使用以下工具加载 glsl 字符串。</p>
<p>​    ShaderUtils.java</p>
<pre><code class="language-java">import android.content.Context;

import java.util.HashSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Shader工具类
 * @author little fat sheep
 */
public class ShaderUtils {
    // 匹配: #include &lt;xxx&gt; 或 #include “xxx”, 并且不以"//"开头
    private static final String INCLUDE_REGEX = "(?m)^(?!//\\s*)#include\\s+(&lt;([^&gt;]+)&gt;|\"([^\"]+)\")";

    /**
     * 通过asset加载shader
     * @param vertexShader 顶点着色器路径, 如: "shaders/origin_vert.glsl"
     * @param fragmentShader 片元着色器路径, 如: "shaders/origin_frag.glsl"
     */
    public static String[] loadShader(Context context, String vertexShader, String fragmentShader) {
        String vertex = StringUtils.loadString(context, vertexShader);
        String fragment = StringUtils.loadString(context, fragmentShader);
        String vertex1 = replaceIncludeFiles(context, vertex);
        String fragment1 = replaceIncludeFiles(context, fragment);
        return new String[] { vertex1, fragment1 };
    }

    /**
     * 通过资源id加载shader
     * @param vertexShader 顶点着色器资源id, 如: R.raw.origin_vertex
     * @param fragmentShader 片元着色器资源id, 如: R.raw.origin_fragment
     */
    public static String[] loadShader(Context context, int vertexShader, int fragmentShader) {
        String vertex = StringUtils.loadString(context, vertexShader);
        String fragment = StringUtils.loadString(context, fragmentShader);
        String vertex1 = replaceIncludeFiles(context, vertex);
        String fragment1 = replaceIncludeFiles(context, fragment);
        return new String[] { vertex1, fragment1 };
    }

    /**
     * 将shader字符串中#include的文件替换为文件内容
     */
    public static String replaceIncludeFiles(Context context, String shaderContent) {
        Pattern pattern = Pattern.compile(INCLUDE_REGEX);
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); // 用于去掉重复的include
        return replaceIncludeFiles(context, shaderContent, pattern, set);
    }

    /**
     * 将shader字符串中#include的文件替换为文件内容(include的文件中可能也有include, 需要递归调用)
     */
    private static String replaceIncludeFiles(Context context, String shaderContent, Pattern pattern, HashSet&lt;String&gt; set) {
        Matcher matcher = pattern.matcher(shaderContent);
        StringBuffer sb = new StringBuffer(shaderContent.length());
        while (matcher.find()) {
            String angleBrackets = matcher.group(2); // 尖括号内的路径
            String quotationMarks = matcher.group(3); // 引号内的路径
            String file = angleBrackets != null ? angleBrackets : quotationMarks;
            if (set.contains(file)) {
                matcher.appendReplacement(sb, ""); // 删除重复的include
            } else {
                set.add(file);
                String includeShader = StringUtils.loadString(context, file); // 加载include文件中的字符串
                String quoteShader = Matcher.quoteReplacement(includeShader); // 替换字符串中的转义字符
                String wholeShader = replaceIncludeFiles(context, quoteShader, pattern, set); // 递归替换字串中的include
                matcher.appendReplacement(sb, wholeShader); // 将字符串添加到sb中
            }
        }
        matcher.appendTail(sb);
        return sb.toString();
    }
}
</code></pre>
<p>​    StringUtils.java</p>
<pre><code class="language-cpp">import android.content.Context;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * 字符串工具类
 * @author little fat sheep
 */
public class StringUtils {
    /**
     * 根据资源路径读取字符串
     * @param assetPath 资源路径, 如: "shaders/origin_vert.glsl"
     */
    public static String loadString(Context context, String assetPath) {
        String str = "";
        try (InputStream inputStream = context.getAssets().open(assetPath)) {
            str = loadString(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }

    /**
     * 根据资源id读取字符串
     * @param rawId 资源id, 如: R.raw.origin_vertex
     */
    public static String loadString(Context context, int rawId) {
        String str = "";
        try (InputStream inputStream = context.getResources().openRawResource(rawId)) {
            str = loadString(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }

    private static String loadString(InputStream inputStream) {
        StringBuilder sb = new StringBuilder();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {
            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line).append("\n");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return sb.toString();
    }
}
</code></pre>
<p>​    声明：本文转自<a href="https://zhyan8.blog.csdn.net/article/details/144776879" target="_blank" rel="noopener nofollow">【OpenGL ES】GLSL基础语法</a>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3530927108425926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-29 15:53">2024-12-29 15:45</span>&nbsp;
<a href="https://www.cnblogs.com/zhyan8">little_fat_sheep</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18639011" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18639011);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18639011', targetLink: 'https://www.cnblogs.com/zhyan8/p/18639011', title: '【OpenGL ES】GLSL基础语法' })">举报</a>
</div>
        