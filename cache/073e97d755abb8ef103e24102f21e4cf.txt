
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18903527" title="发布于 2025-05-30 09:02">
    <span role="heading" aria-level="2">秒杀系统—4.第二版升级优化的技术文档二</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="4" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="5"><strong>7.秒杀系统的秒杀活动服务实现</strong></p>
<p data-track="6"><strong>(1)数据库表设计</strong></p>
<p data-track="7"><strong>(2)秒杀活动状态机</strong></p>
<p data-track="8"><strong>(3)添加秒杀活动</strong></p>
<p data-track="9"><strong>(4)删除秒杀活动</strong></p>
<p data-track="10"><strong>(5)修改秒杀活动</strong></p>
<p data-track="11"><strong>(6)后台查询秒杀活动</strong></p>
<p data-track="12"><strong>(7)前台查询秒杀活动</strong></p>
<p data-track="13"><strong>(8)查询秒杀商品的销售进度</strong></p>
<p data-track="14"><strong>(9)秒杀活动添加秒杀商品</strong></p>
<p data-track="15"><strong>(10)秒杀活动删除秒杀商品</strong></p>
<p data-track="16"><strong>(11)触发渲染秒杀活动的商品列表页和商品详情页</strong></p>
<p data-track="17"><strong>(12)触发库存分片并同步到Redis</strong></p>
<p data-track="18"><strong>(13)清理秒杀活动相关的数据</strong></p>
<p data-track="19">&nbsp;</p>
<p data-track="20"><strong>7.秒杀系统的秒杀活动服务实现</strong></p>
<p data-track="21"><strong>(1)数据库表设计</strong></p>
<p data-track="22"><strong>(2)秒杀活动状态机</strong></p>
<p data-track="23"><strong>(3)添加秒杀活动</strong></p>
<p data-track="24"><strong>(4)删除秒杀活动</strong></p>
<p data-track="25"><strong>(5)修改秒杀活动</strong></p>
<p data-track="26"><strong>(6)后台查询秒杀活动</strong></p>
<p data-track="27"><strong>(7)前台查询秒杀活动</strong></p>
<p data-track="28"><strong>(8)查询秒杀商品的销售进度</strong></p>
<p data-track="29"><strong>(9)秒杀活动添加秒杀商品</strong></p>
<p data-track="30"><strong>(10)秒杀活动删除秒杀商品</strong></p>
<p data-track="31"><strong>(11)触发渲染秒杀活动的商品列表页和商品详情页</strong></p>
<p data-track="32"><strong>(12)触发库存分片并同步到Redis</strong></p>
<p data-track="33"><strong>(13)清理秒杀活动相关的数据</strong></p>
<p data-track="34">&nbsp;</p>
<p data-track="35"><strong>(1)数据库表设计</strong></p>
<p data-track="36"><strong>一.秒杀活动表</strong></p>
<pre class="highlighter-hljs"><code>@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("seckill_activity")
public class Activity implements Serializable {
    //主键
    private Long id;
    //秒杀活动名称
    private String activityName;
    //秒杀活动开始展示时间
    private Date showTime;
    //秒杀活动开始时间
    private Date startTime;
    //秒杀活动结束时间
    private Date endTime;
    //秒杀活动状态
    private Integer status;
    //秒杀活动的商品列表页是否已经渲染好了，秒杀活动页面是否渲染好
    private Boolean pageReady;
    //审核备注
    private String auditComment;
    private Date createTime;
    private Date updateTime;
}</code></pre>
<p data-track="38"><strong>二.秒杀活动和秒杀商品关系表</strong></p>
<pre class="highlighter-hljs"><code>@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("seckill_activity_sku_ref")
public class ActivitySkuRef implements Serializable {
    //主键
    private Long id;
    //秒杀活动id
    private Long activityId;
    //商品skuId
    private Long skuId;
    //秒杀商品的原价
    private Integer price;
    //秒杀商品的秒杀库存
    private Integer seckillStock;
    //下面三个字段是秒杀结束之后的库存状态
    private Integer salableStock;
    //对秒杀系统里的Redis库存进行锁定
    private Integer lockedStock;
    //如果用户抢购商品成功后完成了订单支付，就会把商品库存进行扣减，已售库存
    private Integer soldStock;
    //秒杀商品的详情页是否已经渲染好
    private Boolean pageReady;
    private Date createTime;
    private Date updateTime;
}</code></pre>
<p data-track="40"><strong>(2)秒杀活动状态机</strong></p>
<div class="pgc-img"><img src="https://p6-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/482a3c557a71410f914a1a3334871ec2~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250530085608B491FF59ED25B5E102FC&amp;x-expires=2147483647&amp;x-signature=INp6P2rllRs0PZEZ8PUKbvXtK8o%3D" data-ic="false" data-width="1080" data-height="385" data-ic-uri=""></div>
<p data-track="41"><strong>(3)添加秒杀活动</strong></p>
<p data-track="42">步骤一：构建一个秒杀活动记录对象</p>
<p data-track="43">步骤二：将该秒杀活动对象的状态设为"新创建"</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity")
public class ActivityController {
    @Autowired
    private ActivityService activityService;
    ...
    
    //添加秒杀活动
    @PostMapping("/save")
    public MapResult save(@RequestBody ActivitySaveRequest request) {
        String validateResult = request.validateParams();
        if (Objects.nonNull(validateResult)) {
            return MapResult.errorResult().setInfo(validateResult);
        }
  
        //构造器模式，构建一个秒杀活动
        Activity.ActivityBuilder builder = Activity.builder();
        //设置来自参数的字段值
        builder.activityName(request.getActivityName()).showTime(request.getShowTime()).startTime(request.getStartTime()).endTime(request.getEndTime());
        //将该秒杀活动对象的状态设为"新创建"
        builder.status(ActivityStatusVal.NEW_CREATE.getCode());
        builder.pageReady(Boolean.FALSE);
        builder.auditComment(null);
  
        Activity activity = builder.build();
        activityService.save(activity);
        log.info("保存活动，activityId={}，activity={}", activity.getId(), JSON.toJSONString(activity));
        return MapResult.successResult().set("id", activity.getId());
    }
    ...
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    @Override
    public void save(Activity activity) {
        activity.setCreateTime(new Date());
        activity.setUpdateTime(activity.getCreateTime());
        activityMapper.insert(activity);
    }
    ...
}</code></pre>
<p data-track="45"><strong>(4)删除秒杀活动</strong></p>
<p data-track="46">如果一场秒杀活动处于新创建的状态，那么是可以进行删除的。如果一场秒杀活动处于审核通过的状态，那么也是可以进行删除的。但如果一场秒杀活动处于页面渲染中以及之后的状态，则不能随便删除。</p>
<p data-track="47">&nbsp;</p>
<p data-track="48">所以可以规定一场秒杀活动：如果处于"页面渲染中"之前的状态，则都可以直接删除。如果处于"页面渲染中"以及之后的状态，则都不可以删除，但可标记无效。当一场秒杀活动被标记为无效后，可以让其执行正常的结束清理逻辑。</p>
<p data-track="49">&nbsp;</p>
<p data-track="50">删除秒杀活动的具体逻辑是：首先判断是否可以删除，如果可以删除则释放商品库存 + 删除商品和活动的关系 + 删除秒杀活动。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity")
public class ActivityController {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private ProductApi productApi;
    ...
    
    //删除秒杀活动
    @DeleteMapping("/remove/{id}")
    public MapResult remove(@PathVariable("id") Long id) {
        //查询秒杀活动
        Activity activity = activityService.queryById(id);
  
        //如果秒杀活动activity处于"页面渲染中"之前的状态，则可以直接删除；
        //如果秒杀活动activity处于"页面渲染中"以及之后的状态，则不可以删除，但可标记无效；
        //比如秒杀活动已经审核通过并展示给用户了、快准备开始了，此时则不能删除
        //比如秒杀活动已经开始了，而且秒杀活动还没结束，此时也不能删除
        if (activity.getStatus() &gt;= ActivityStatusVal.PAGE_RENDERING.getCode()) {
            return MapResult.errorResult().setInfo("活动在当前状态下不可以删除");
        }
      
        //查询秒杀商品和秒杀活动的关联关系
        List&lt;ActivitySkuRef&gt; activitySkuRefs = activitySkuRefService.queryByActivityId(id);
        List&lt;SkuIdAndStock&gt; skuIdAndStockList = new ArrayList&lt;&gt;();
        for (ActivitySkuRef activitySkuRef : activitySkuRefs) {
            skuIdAndStockList.add(new SkuIdAndStock(activitySkuRef.getSkuId(), activitySkuRef.getSeckillStock()));
        }
      
        //调用商品服务释放商品库存
        productApi.batchReleaseStock(skuIdAndStockList);
        log.info("释放秒杀活动关联的秒杀商品的库存");
  
        //删除秒杀商品和秒杀活动的关联关系
        List&lt;Long&gt; activitySkuRefIds = activitySkuRefs.stream().map(ActivitySkuRef::getId).collect(Collectors.toList());
        if (CollectionUtils.isNotEmpty(activitySkuRefIds)) {
            activitySkuRefService.batchRemove(activitySkuRefIds);
        }
        log.info("删除秒杀活动和秒杀商品关联关系");
  
        //删除秒杀活动
        activityService.remove(id);
        log.info("删除秒杀活动");
        return MapResult.successResult();
    }
    ...
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    
    //查询秒杀活动
    @Override
    public Activity queryById(Long id) {
        return activityMapper.selectById(id);
    }
    
    //删除秒杀活动
    @Override
    public void remove(Long id) {
        activityMapper.deleteById(id);
    }
    ...
}

@Service
public class ActivitySkuRefServiceImpl implements ActivitySkuRefService {
    @Autowired
    private ActivitySkuRefMapper activitySkuRefMapper;
    
    @Override
    public ActivitySkuRef queryById(Long id) {
        return activitySkuRefMapper.selectById(id);
    }
    
    //查询秒杀商品和秒杀活动的关系
    @Override
    public List&lt;ActivitySkuRef&gt; queryByActivityId(Long activityId) {
        return queryByActivityIds(Collections.singletonList(activityId));
    }
    
    //删除秒杀商品和秒杀活动的关联关系
    @Override
    public void batchRemove(List&lt;Long&gt; ids) {
        activitySkuRefMapper.deleteBatchIds(ids);
    }
    ...
}

@FeignClient("demo-product-system")
@RequestMapping("/product")
public interface ProductApi {
    //根据多个skuId和指定的商品数量批量释放商品库存
    @PostMapping("/batchReleaseStock")
    MapResult batchReleaseStock(@RequestBody List&lt;SkuIdAndStock&gt; skuIdAndStockList);
    ...
}

@RestController
@RequestMapping("/product")
public class ProductController {
    @Autowired
    private SkuService skuService;
    ...
    
    @PutMapping("/lockStock")
    public Boolean lockStock(@RequestParam("skuId") Long skuId, @RequestParam("count") Integer count) {
        if (skuService.lockStock(skuId, count)) {
            log.info("锁定商品库存, skuId={}, 锁定的库存={}", skuId, count);
            return Boolean.TRUE;
        }
        log.info("锁定商品库存但是库存不足, skuId={}, 锁定的库存={}", skuId, count);
        return Boolean.FALSE;
    }
    
    @PutMapping("/batchReleaseStock")
    public Boolean batchReleaseStock(@RequestBody List&lt;SkuIdAndStock&gt; skuIdAndStockList) {
        for (SkuIdAndStock skuIdAndStock : skuIdAndStockList) {
            skuService.releaseStock(skuIdAndStock.getSkuId(), skuIdAndStock.getStock());
            log.info("释放商品库存, skuId={}, 锁定的库存={}", skuIdAndStock.getSkuId(), skuIdAndStock.getStock());
        }
        return Boolean.TRUE;
    }
    ...
}

@Service
public class SkuServiceImpl implements SkuService {
    @Autowired
    private SkuMapper skuMapper;
    ...
    
    @Override
    public boolean lockStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.lockStock(skuId, count);
        return affectedRows == 1;
    }
    
    @Override
    public boolean releaseStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.releaseStock(skuId, count);
        return affectedRows == 1;
    }
    ...
}

public interface SkuMapper extends BaseMapper&lt;Sku&gt; {
    @Update("UPDATE sku SET current_stock = current_stock - #{count}, locked_stock = locked_stock + #{count} " +
        "WHERE id = #{id} AND current_stock &gt; #{count}")
    @ResultType(Integer.class)
    int lockStock(@Param("id") Long id, @Param("count") Integer count);

    @Update("UPDATE sku SET current_stock = current_stock + #{count}, locked_stock = locked_stock - #{count} " +
        "WHERE id = #{id} AND locked_stock &gt; #{count}")
    @ResultType(Integer.class)
    int releaseStock(@Param("id") Long id, @Param("count") Integer count);
}</code></pre>
<p data-track="52"><strong>(5)修改秒杀活动</strong></p>
<p data-track="53">一.判断是否可修改("审核通过"前的状态都可修改)</p>
<p data-track="54">二.可以修改的字段：名称、开始时间、结束时间</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity")
public class ActivityController {
    @Autowired
    private ActivityService activityService;
    ...
    
    //修改秒杀活动
    @PutMapping("/modify")
    public MapResult modify(@RequestBody ActivityModifyRequest request) {
        String validateResult = request.validateParams();
        if (Objects.nonNull(validateResult)) {
            return MapResult.errorResult().setInfo(validateResult);
        }
        Activity activity = activityService.queryById(request.getActivityId());
        if (Objects.isNull(activity)) {
            return MapResult.errorResult().setInfo("活动不存在");
        }
        //采取严格的措施，但凡秒杀活动审核已通过，则不让修改
        if (activity.getStatus() &gt;= ActivityStatusVal.AUDIT_PASS.getCode()) {
            return MapResult.errorResult().setInfo("该活动在当前状态下不允许修改");
        }
        activityService.modify(request);
        return MapResult.successResult();
    }
    ...
    
    //提交审核秒杀活动
    @PutMapping("/submit/{id}")
    public MapResult submit(@PathVariable("id") Long id) {
        activityService.updateStatus(id, ActivityStatusVal.NEW_CREATE.getCode(), ActivityStatusVal.AUDIT_PENDING.getCode());
        return MapResult.successResult();
    }
    
    //审核秒杀活动
    @PutMapping("/audit/{id}")
    public MapResult audit(@PathVariable("id") Long id, Boolean result) {
        if (result) {
            //审核通过
            activityService.updateStatus(id, ActivityStatusVal.AUDIT_PENDING.getCode(), ActivityStatusVal.AUDIT_PASS.getCode());
        } else {
            //审核不通过
            activityService.updateStatus(id, ActivityStatusVal.AUDIT_PENDING.getCode(), ActivityStatusVal.AUDIT_NOT_PASS.getCode());
        }
        return MapResult.successResult();
    }
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    //查询秒杀活动
    @Override
    public Activity queryById(Long id) {
        return activityMapper.selectById(id);
    }
    
    @Override
    public void modify(ActivityModifyRequest request) {
        Activity.ActivityBuilder builder = Activity.builder().id(request.getActivityId());
        if (StringUtils.isNotBlank(request.getActivityName())) {
            builder.activityName(request.getActivityName());
        }
        if (Objects.nonNull(request.getStartTime())) {
            builder.startTime(request.getStartTime());
        }
        if (Objects.nonNull(request.getEndTime())) {
            builder.endTime(request.getEndTime());
        }
        activityMapper.updateById(builder.build());
    }
    
    @Override
    public boolean updateStatus(Long activityId, Integer oldStatus, Integer newStatus) {
        Activity activity = Activity.builder().status(newStatus).build();
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.eq("id", activityId);
        if (Objects.nonNull(oldStatus)) {
            queryWrapper.eq("status", oldStatus);
        }
        int affectedRows = activityMapper.update(activity, queryWrapper);
        return affectedRows == 1;
    }
    ...
}</code></pre>
<p data-track="56"><strong>(6)后台查询秒杀活动</strong></p>
<p data-track="57">一.按照名称、状态、时间范围分页查询</p>
<p data-track="58">二.返回秒杀活动信息和秒杀活动下的商品数量</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity")
public class ActivityController {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    ...
    
    //后台查询秒杀活动
    @GetMapping("/queryPage")
    public MapResult queryPage(@RequestBody ActivityQueryPageRequest request) {
        String validateResult = request.validateParams();
        if (Objects.nonNull(validateResult)) {
            return MapResult.errorResult().setInfo(validateResult);
        }
  
        IPage&lt;Activity&gt; page = activityService.queryPage(request);
        List&lt;Activity&gt; activities = page.getRecords();
        if (CollectionUtils.isEmpty(activities)) {
            return MapResult.successResult().set("totalPage", 1).set("totalCount", 0).set("dataList", Collections.emptyList());
        }
  
        List&lt;Long&gt; activityIds = activities.stream().map(Activity::getId).collect(Collectors.toList());
        List&lt;ActivitySkuRef&gt; activitySkuRefs = activitySkuRefService.queryByActivityIds(activityIds);
        Map&lt;Long, List&lt;ActivitySkuRef&gt;&gt; activityIdSkuRefMap = activitySkuRefs.stream().collect(Collectors.groupingBy(ActivitySkuRef::getActivityId));
  
        List&lt;Object&gt; dataList = new ArrayList&lt;&gt;();
        for (Activity activity : activities) {
            Map&lt;String, Object&gt; data = new LinkedHashMap&lt;&gt;();
            data.put("activityId", activity.getId());
            data.put("activityName", activity.getActivityName());
            data.put("showTime", activity.getShowTime());
            data.put("startTime", activity.getStartTime());
            data.put("endTime", activity.getEndTime());
            data.put("status", activity.getStatus());
            data.put("pageReady", activity.getPageReady());
            data.put("auditComment", activity.getAuditComment());
            data.put("createTime", activity.getCreateTime());
            data.put("updateTime", activity.getUpdateTime());
            data.put("seckillSkuCount", Optional.ofNullable(activityIdSkuRefMap).map(e -&gt; e.get(activity.getId())).map(List::size).orElse(0));
            dataList.add(data);
        }
        return MapResult.successResult().set("totalPage", page.getPages()).set("totalCount", page.getTotal()).set("dataList", dataList);
    }
    ...
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    @Override
    public IPage&lt;Activity&gt; queryPage(ActivityQueryPageRequest request) {
        Page&lt;Activity&gt; page = new Page&lt;&gt;(request.getPageNum(), request.getPageSize());
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        if (StringUtils.isNotBlank(request.getActivityName())) {
            queryWrapper.eq("activity_name", request.getActivityName());
        }
        if (StringUtils.isNotBlank(request.getMinStartTime())) {
            queryWrapper.ge("start_time", request.getMinStartTime());
        }
        if (StringUtils.isNotBlank(request.getMaxStartTime())) {
            queryWrapper.le("start_time", request.getMaxStartTime());
        }
        return activityMapper.selectPage(page, queryWrapper);
    }
    ...
}

@Service
public class ActivitySkuRefServiceImpl implements ActivitySkuRefService {
    @Autowired
    private ActivitySkuRefMapper activitySkuRefMapper;
    ...
    
    @Override
    public List&lt;ActivitySkuRef&gt; queryByActivityIds(List&lt;Long&gt; activityIds) {
        QueryWrapper&lt;ActivitySkuRef&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.in("activity_id", activityIds);
        return activitySkuRefMapper.selectList(queryWrapper);
    }
    ...
}</code></pre>
<p data-track="60"><strong>(7)前台查询秒杀活动</strong></p>
<p data-track="61">对于已经开始和即将开始的秒杀活动，可让用户查看对应的商品列表⻚。对于已经结束的和要过很久才开始的秒杀活动，则不让用户在前台查看。</p>
<p data-track="62">&nbsp;</p>
<p data-track="63">至于⼀场秒杀活动什么时候可以被被展示出来，决定于提前多久把该秒杀活动对应的静态⻚⾯渲染好、商品库存同步好。</p>
<p data-track="64">&nbsp;</p>
<p data-track="65">一场秒杀活动的商品列表按道理应该要被提前展示出来，这样⽤户才能查看，但不同性质的秒杀活动提前展示的时间是不同的。比如特别热⻔的秒杀活动，可能需要让⽤户提前一天来查看。而不是特别热门的秒杀活动，则只需要让用户提前半天来查看。</p>
<p data-track="66">&nbsp;</p>
<p data-track="67">因此，前台查询秒杀活动的接口应该：返回已经到了"开始展示时间"的所有秒杀活动 + 通过读取内存缓存来进行查询。比如定时把⼀段时间内需要展示的秒杀活动全部都加载到内存缓存中，因为秒杀活动的特点就是直到秒杀结束后都是固定不会变的。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity/frontend")
public class FrontendActivityController {
    @Autowired
    private ActivityCacheSupport activityCacheSupport;

    //可以新增一个接口，让用户实时查看某个商品秒杀售卖的进度
    //进度就从Redis里查询，秒杀进度 = (锁定库存 + 已售库存) / 总库存
    //总库存 = 可售库存 + 锁定库存 + 已售库存
    //进度可以缓存在本地JVM里，每隔1分钟刷新一次

    //前台查询秒杀活动
    @GetMapping("/queryList")
    public MapResult queryList() {
        List&lt;Activity&gt; activities = activityCacheSupport.queryShowableActivity();
        if (CollectionUtils.isEmpty(activities)) {
            return MapResult.successResult().set("dataList", Collections.emptyList());
        }
        List&lt;Object&gt; dataList = new ArrayList&lt;&gt;();
        for (Activity activity : activities) {
            Map&lt;String, Object&gt; data = new LinkedHashMap&lt;&gt;();
            data.put("activityId", activity.getId());
            data.put("activityName", activity.getActivityName());
            data.put("showTime", activity.getShowTime());
            data.put("startTime", activity.getStartTime());
            data.put("endTime", activity.getEndTime());
            dataList.add(data);
        }
        return MapResult.successResult().set("data", dataList);
    }
}

@Component
public class ActivityCacheSupport implements InitializingBean {
    @Autowired
    private ActivityService activityService;

    private final LoadingCache&lt;String, List&lt;Activity&gt;&gt; currentMinuteShowableActivityCache = CacheBuilder.newBuilder()
        .maximumSize(100)
        .refreshAfterWrite(30, TimeUnit.SECONDS)//每次间隔30s以后自动去做一个刷新缓存
        .build(new CacheLoader&lt;String, List&lt;Activity&gt;&gt;() {
            @Override
            public List&lt;Activity&gt; load(String key) throws Exception {
                return loadActivityList();
            }
        });
   
    //从DB中加载秒杀活动列表
    private List&lt;Activity&gt; loadActivityList() {
        List&lt;Activity&gt; activities = activityService.queryShowableList();
        if (CollectionUtils.isEmpty(activities)) {
            return Collections.emptyList();
        }
        return activities;
    }

    public List&lt;Activity&gt; queryShowableActivity() {
        String currentMinute = FastDateFormat.getInstance("yyyy-MM-dd HH:mm").format(new Date());
        try {
            //如果当前这一分钟的key不存在，Guava Cache会通过CacheLoader.load()方法去加载数据
            //也就是会从DB里加载达到showTime的秒杀活动的最新列表，然后缓存在JVM本地
            //本地缓存currentMinuteShowableActivityCache的有效时间也就1分钟，这也有利于展示已渲染好的、新的秒杀活动
            //get方法注释：Returns the value associated with key in this cache, first loading that value if necessary.
            return currentMinuteShowableActivityCache.get(currentMinute);
        } catch (ExecutionException e) {
            List&lt;Activity&gt; activities = loadActivityList();
            currentMinuteShowableActivityCache.put(currentMinute, activities);
            return activities;
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        String currentMinute = FastDateFormat.getInstance("yyyy-MM-dd HH:mm").format(new Date());
        currentMinuteShowableActivityCache.put(currentMinute, activityService.queryShowableList());
    }
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    //查询用户可以看到的秒杀活动
    //此时此刻用户需要看到2种类型的秒杀活动
    //1.还未开始的但是已经到了展示时间了，showTime &lt;= now
    //2.已经开始了的但是还没结束的，endTime &gt;= now
    @Override
    public List&lt;Activity&gt; queryShowableList() {
        String now = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss").format(new Date());
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.le("show_time", now);
        queryWrapper.ge("end_time", now);
        queryWrapper.eq("status", ActivityStatusVal.INVENTORY_SYNCED.getCode());
        return activityMapper.selectList(queryWrapper);
    }
    ...
}</code></pre>
<p data-track="69"><strong>(8)查询秒杀商品的销售进度</strong></p>
<p data-track="70">秒杀活动开始后：⽤户访问秒杀活动的商品列表时，需要看到每个秒杀商品的销售进度。前端在加载完秒杀商品列表后，会异步请求所有秒杀商品的销售进度。这个数据是⼀个百分⽐的数字，可以不是实时的，取⼀个近似值即可。</p>
<p data-track="71">&nbsp;</p>
<p data-track="72">查询秒杀商品的销售进度的接口：需要前台传来秒杀活动的ID，根据秒杀活动ID查询出所有的秒杀商品(直接查内存缓存)，根据秒杀商品skuId查询出所有商品对应的销售进度(直接查内存缓存)。因为这个数据查的只是当前正在进⾏的秒杀活动的商品数据，所以数据量很⼩，可以直接存入内存缓存。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/inventory/frontend")
public class FrontendInventoryController {
    @Autowired
    private InventoryService inventoryService;
    
    private final LoadingCache&lt;String, List&lt;SalePercent&gt;&gt; salePercentCache = CacheBuilder.newBuilder()
        .maximumSize(100)
        .expireAfterWrite(15, TimeUnit.SECONDS)
        .refreshAfterWrite(10, TimeUnit.SECONDS)//每10秒刷新
        .build(new CacheLoader&lt;String, List&lt;SalePercent&gt;&gt;() {
            @Override
            public List&lt;SalePercent&gt; load(String key) throws Exception {
                //从Redis中获取库存数据，更新到本地缓存
                return loadSalePercent(key);
            }
        });

    @PostMapping("/queryCurrentStock")
    public MapResult queryCurrentStock(@RequestBody QueryCurrentStockRequest request) {
        String validateResult = request.validateParams();
        if (Objects.nonNull(validateResult)) {
            return MapResult.errorResult().setInfo(validateResult);
        }
  
        //key的格式为activityId:skuId,skuId
        String key = request.getActivityId() + ":" + request.getSkuIds().stream().map(e -&gt; e + "").collect(Collectors.joining(","));
        List&lt;SalePercent&gt; dataList = Collections.emptyList();
        try {
            dataList = salePercentCache.get(key);
        } catch (ExecutionException e) {
            dataList = loadSalePercent(key);
        }
        return MapResult.successResult().setDataList(dataList);
    }

    //从Redis中获取库存数据
    private List&lt;SalePercent&gt; loadSalePercent(String key) {
        String activityId = key.substring(0, key.indexOf(":"));
        String[] skuIds = key.substring(key.indexOf(":") + 1).split(",");
        List&lt;SalePercent&gt; list = new ArrayList&lt;&gt;();
        for (String skuId : skuIds) {
            //从Redis中获取当前库存数据
            ProductStockVo productStockVo = inventoryService.queryCurrentStock(Long.parseLong(activityId), Long.parseLong(skuId));
            list.add(calculateSalePercent(productStockVo));
        }
        return list;
    }

    private SalePercent calculateSalePercent(ProductStockVo productStockVo) {
        Integer salableStock = productStockVo.getSalableStock();
        Integer lockedStock = productStockVo.getLockedStock();
        Integer soldStock = productStockVo.getSoldStock();
  
        //三者相加等于这个商品的总库存
        int totalStock = salableStock + lockedStock + soldStock;
        double percent = (double) (totalStock - salableStock) / totalStock;
        NumberFormat percentInstance = NumberFormat.getPercentInstance();
        String format = percentInstance.format(percent);
        return new SalePercent(productStockVo.getSkuId(), format);
    }
}

@Service
public class InventoryServiceImpl implements InventoryService {
    @Autowired
    private CacheSupport cacheSupport;
    
    //从Redis中获取当前库存数据
    @Override
    public ProductStockVo queryCurrentStock(Long activityId, Long skuId) {
        //调用RedisCacheSupport.hgetAllOnAllRedis()方法
        List&lt;Map&lt;String, String&gt;&gt; stockList = cacheSupport.hgetAllOnAllRedis(CacheKey.buildStockKey(activityId, skuId));
        int salableStock = 0;
        int lockedStock = 0;
        int soldStock = 0;
        for (Map&lt;String, String&gt; stockMap : stockList) {
            salableStock += Integer.parseInt(stockMap.get(CacheKey.SALABLE_STOCK));
            lockedStock += Integer.parseInt(stockMap.get(CacheKey.LOCKED_STOCK));
            soldStock += Integer.parseInt(stockMap.get(CacheKey.SALED_STOCK));
        }
        return ProductStockVo.builder().activityId(activityId).skuId(skuId).salableStock(salableStock).lockedStock(lockedStock).soldStock(soldStock).build();
    }
    ...
}

public class RedisCacheSupport implements CacheSupport {
    private final JedisManager jedisManager;
    
    public RedisCacheSupport(JedisManager jedisManager) {
        this.jedisManager = jedisManager;
    }
    
    @Override
    public int getRedisCount() {
        return jedisManager.getRedisCount();
    }
    ...
    
    //由于一个商品的库存数据可能会分散在各个Redis节点上
    //所以需要从各个Redis节点查询商品库存数据，然后合并起来才算是一份总的数据
    @Override
    public List&lt;Map&lt;String, String&gt;&gt; hgetAllOnAllRedis(String key) {
        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; jedisManager.getRedisCount(); i++) {
            try (Jedis jedis = jedisManager.getJedisByIndex(i)) {
                list.add(jedis.hgetAll(key));
            }
        }
        return list;
    }
    ...
}</code></pre>
<p data-track="74"><strong>(9)秒杀活动添加秒杀商品</strong></p>
<p data-track="75">需要传入秒杀活动的ID + 参加秒杀的商品skuId，需要状态校验("待审核"状态后的秒杀活动都不可以再添加秒杀商品)。如果可以添加商品，则调⽤商品系统锁定库存(库存不⾜返回提示)。最后保存⼀条ActivitySkuRef记录。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity/skuRef")
public class ActivitySkuRefController {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private ProductApi productApi;
    ...
    
    //给活动添加一个秒杀商品
    @PostMapping("/save")
    public MapResult save(@RequestBody ActivitySkuRefSaveRequest request) {
        String validateResult = request.validateParams();
        if (Objects.nonNull(validateResult)) {
            return MapResult.errorResult().setInfo(validateResult);
        }
  
        //校验活动状态，如果已经审核通过了就不能再添加商品了
        Activity activity = activityService.queryById(request.getActivityId());
        if (Objects.isNull(activity)) {
            return MapResult.errorResult().setInfo("活动不存在");
        }
        if (activity.getStatus() &gt; ActivityStatusVal.AUDIT_PASS.getCode()) {
            return MapResult.errorResult().setInfo("该活动在当前状态下不允许添加商品");
        }
  
        //校验sku是否重复
        Integer count = activitySkuRefService.countByActivityIdAndSkuId(request.getActivityId(), request.getSkuId());
        if (count &gt; 0) {
            return MapResult.errorResult().setInfo("该商品已存在");
        }
  
        //调用依赖的商品系统接口锁定商品库存
        if (!productApi.lockStock(request.getSkuId(), request.getSeckillStock())) {
            return MapResult.errorResult().setInfo("锁定商品库存失败");
        }
        log.info("调用依赖的商品系统锁定商品库存, skuId={}, 锁定的库存={}", request.getSkuId(), request.getSeckillStock());
  
        ActivitySkuRef.ActivitySkuRefBuilder builder = ActivitySkuRef.builder();
        //来自参数的字段值
        builder.activityId(request.getActivityId()).skuId(request.getSkuId()).price(request.getPrice()).seckillStock(request.getSeckillStock());
        //设置字段的初始值
        builder.pageReady(Boolean.FALSE);
        ActivitySkuRef activitySkuRef = builder.build();
        activitySkuRefService.save(activitySkuRef);
        log.info("保存活动和商品之间的关联关系, activitySkuRefId={}", activitySkuRef.getId());
        return MapResult.successResult().set("id", activitySkuRef.getId());
    }
    ...
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    
    //查询秒杀活动
    @Override
    public Activity queryById(Long id) {
        return activityMapper.selectById(id);
    }
    ...
}

@Service
public class ActivitySkuRefServiceImpl implements ActivitySkuRefService {
    @Autowired
    private ActivitySkuRefMapper activitySkuRefMapper;
    ...
    
    @Override
    public Integer countByActivityIdAndSkuId(Long activityId, Long skuId) {
        QueryWrapper&lt;ActivitySkuRef&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.eq("activity_id", activityId);
        queryWrapper.eq("sku_id", skuId);
        return activitySkuRefMapper.selectCount(queryWrapper);
    }
    
    @Override
    public void save(ActivitySkuRef activitySkuRef) {
        activitySkuRef.setCreateTime(new Date());
        activitySkuRef.setUpdateTime(activitySkuRef.getCreateTime());
        activitySkuRefMapper.insert(activitySkuRef);
    }
    ...
}

@FeignClient("demo-product-system")
@RequestMapping("/product")
public interface ProductApi {
    ...
    //根据skuId和指定的商品数量锁定对应的商品库存，不能修改库存
    @PutMapping("/lockStock")
    Boolean lockStock(@RequestParam("skuId") Long skuId, @RequestParam("count") Integer count);
    ...
}

@RestController
@RequestMapping("/product")
public class ProductController {
    @Autowired
    private SkuService skuService;
    ...
    
    @PutMapping("/lockStock")
    public Boolean lockStock(@RequestParam("skuId") Long skuId, @RequestParam("count") Integer count) {
        if (skuService.lockStock(skuId, count)) {
            log.info("锁定商品库存, skuId={}, 锁定的库存={}", skuId, count);
            return Boolean.TRUE;
        }
        log.info("锁定商品库存但是库存不足, skuId={}, 锁定的库存={}", skuId, count);
        return Boolean.FALSE;
    }
    ...
}

@Service
public class SkuServiceImpl implements SkuService {
    @Autowired
    private SkuMapper skuMapper;
    ...
    
    @Override
    public boolean lockStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.lockStock(skuId, count);
        return affectedRows == 1;
    }
    
    @Override
    public boolean releaseStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.releaseStock(skuId, count);
        return affectedRows == 1;
    }
    ...
}

public interface SkuMapper extends BaseMapper&lt;Sku&gt; {
    @Update("UPDATE sku SET current_stock = current_stock - #{count}, locked_stock = locked_stock + #{count} " +
        "WHERE id = #{id} AND current_stock &gt; #{count}")
    @ResultType(Integer.class)
    int lockStock(@Param("id") Long id, @Param("count") Integer count);

    @Update("UPDATE sku SET current_stock = current_stock + #{count}, locked_stock = locked_stock - #{count} " +
        "WHERE id = #{id} AND locked_stock &gt; #{count}")
    @ResultType(Integer.class)
    int releaseStock(@Param("id") Long id, @Param("count") Integer count);
}</code></pre>
<p data-track="77"><strong>(10)秒杀活动删除秒杀商品</strong></p>
<p data-track="78">需要传入ActivitySkuRef的ID，然后状态校验(在"待审核"状态之后的活动都不可以再删除秒杀商品)，接着调⽤商品系统的接口释放商品库存，最后删除ActivitySkuRef记录。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/activity/skuRef")
public class ActivitySkuRefController {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private ProductApi productApi;
    ...
    
    //删除秒杀活动的商品
    @DeleteMapping("/remove")
    public MapResult remove(Long activitySkyRefId) {
        if (Objects.isNull(activitySkyRefId) || activitySkyRefId &lt;= 0) {
            return MapResult.errorResult().setInfo("参数不合法");
        }
        ActivitySkuRef activitySkuRef = activitySkuRefService.queryById(activitySkyRefId);
  
        //校验活动状态，如果已经审核通过了就不能再删除商品了
        Activity activity = activityService.queryById(activitySkuRef.getActivityId());
        if (Objects.isNull(activity)) {
            return MapResult.errorResult().setInfo("活动不存在");
        }
        if (activity.getStatus() &gt; ActivityStatusVal.AUDIT_PASS.getCode()) {
            return MapResult.errorResult().setInfo("该活动在当前状态下不允许删除商品");
        }
  
        //释放库存
        if (!productApi.releaseStock(activitySkuRef.getSkuId(), activitySkuRef.getSeckillStock())) {
            return MapResult.errorResult().setInfo("操作库存失败");
        }
        activitySkuRefService.remove(activitySkyRefId);
        return MapResult.successResult();
    }
    ...
}

@Service
public class ActivitySkuRefServiceImpl implements ActivitySkuRefService {
    @Autowired
    private ActivitySkuRefMapper activitySkuRefMapper;
   
    //查询秒杀商品和秒杀活动的关系
    @Override
    public ActivitySkuRef queryById(Long id) {
        return activitySkuRefMapper.selectById(id);
    }
    ...
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    
    //查询秒杀活动
    @Override
    public Activity queryById(Long id) {
        return activityMapper.selectById(id);
    }
    ...
}

@FeignClient("demo-product-system")
@RequestMapping("/product")
public interface ProductApi {
    ...
    //根据skuId和指定的商品数量释放对应的商品库存，可以修改库存了
    @PutMapping("/releaseStock")
    Boolean releaseStock(@RequestParam("skuId") Long skuId, @RequestParam("count") Integer count);
    ...
}

@RestController
@RequestMapping("/product")
public class ProductController {
    @Autowired
    private SkuService skuService;
    ...
    
    @PutMapping("/releaseStock")
    public Boolean releaseStock(@RequestParam("skuId") Long skuId, @RequestParam("count") Integer count) {
        skuService.releaseStock(skuId, count);
        log.info("释放商品库存, skuId={}, 锁定的库存={}", skuId, count);
        return Boolean.TRUE;
    }
    ...
}

@Service
public class SkuServiceImpl implements SkuService {
    @Autowired
    private SkuMapper skuMapper;
    ...
    
    @Override
    public boolean lockStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.lockStock(skuId, count);
        return affectedRows == 1;
    }
    
    @Override
    public boolean releaseStock(Long skuId, Integer count) {
        int affectedRows = skuMapper.releaseStock(skuId, count);
        return affectedRows == 1;
    }
    ...
}

public interface SkuMapper extends BaseMapper&lt;Sku&gt; {
    @Update("UPDATE sku SET current_stock = current_stock - #{count}, locked_stock = locked_stock + #{count} " +
        "WHERE id = #{id} AND current_stock &gt; #{count}")
    @ResultType(Integer.class)
    int lockStock(@Param("id") Long id, @Param("count") Integer count);

    @Update("UPDATE sku SET current_stock = current_stock + #{count}, locked_stock = locked_stock - #{count} " +
        "WHERE id = #{id} AND locked_stock &gt; #{count}")
    @ResultType(Integer.class)
    int releaseStock(@Param("id") Long id, @Param("count") Integer count);
}</code></pre>
<p data-track="80"><strong>(11)触发渲染秒杀活动的商品列表页和商品详情页</strong></p>
<p data-track="81"><strong>一.什么时候触发渲染</strong></p>
<p data-track="82">首先必须在秒杀活动的展示时间之前完成渲染，因为⼀旦到了展示时间，虽然秒杀活动还没开始，但⽤户已经能看到。⽤户可以看到秒杀活动，就会查看秒杀活动⾥有哪些秒杀商品。也就是会查看秒杀活动的商品列表⻚，以及查看秒杀商品的详情⻚。这时⻚⾯上是不会展示任何与库存相关的信息的，因为活动还没开始，所以可以在秒杀活动展示时间的前1⼩时就开始渲染这些⻚⾯。</p>
<p data-track="83">&nbsp;</p>
<p data-track="84"><strong>二.如何知道所有⻚⾯已渲染完成</strong></p>
<p data-track="85">⾸先必须要知道什么时候完成了⻚⾯渲染，因为当所有⻚⾯渲染完成后，才可以去同步库存到Redis。当⼀个⻚⾯渲染完成之后，会发送一条页面渲染结果的消息到MQ，然后就可以消费该消息修改对应Activity表和ActivitySkuRef表的字段，接着再count⼀下判断是否所有⻚⾯都已渲染完成。如果是那就修改活动的状态，表示已经完成页面渲染。</p>
<p data-track="86">&nbsp;</p>
<p data-track="87"><strong>三.详细步骤的时序图</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f1ab799763024787874382df4aa12e6e~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250530085608B491FF59ED25B5E102FC&amp;x-expires=2147483647&amp;x-signature=eMOA0beHtG84JeESG60OWWTOXJ4%3D" data-ic="false" data-width="1080" data-height="763" data-ic-uri=""></div>
<p data-track="88">下面是发送渲染页面消息的定时任务：</p>
<pre class="highlighter-hljs"><code>@Component
public class TriggerPageTask {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private LockService lockService;
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    @Scheduled(fixedDelay = 10_000)
    public void run() {
        //通过加锁，可以确保，同时只有一个定时调度任务在处理页面渲染触发
        String lockToken = lockService.tryLock(CacheKey.TRIGGER_PAGE_LOCK, 1, TimeUnit.SECONDS);
        if (lockToken == null) {
            return;
        }
        log.info("触发渲染页面，获取分布式锁成功, lockToken={}", lockToken);
        try {
            //在秒杀活动展示之前1小时开始渲染页面
            //发起渲染条件是：showTime - now &lt; 1小时，同时秒杀活动已通过审核
            List&lt;Activity&gt; activities = activityService.queryListForTriggerPageTask();
            if (CollectionUtils.isEmpty(activities)) {
                return;
            }
            for (Activity activity : activities) {
                Long id = activity.getId();
                List&lt;ActivitySkuRef&gt; activitySkuRefs = activitySkuRefService.queryByActivityId(id);
                if (CollectionUtils.isEmpty(activitySkuRefs)) {
                    continue;
                }
                //发送渲染秒杀活动商品列表页的消息
                List&lt;Long&gt; skuIds = activitySkuRefs.stream().map(ActivitySkuRef::getSkuId).collect(Collectors.toList());
                String renderActivityPageMessage = PageRenderMessage.builder()
                    .pageCode("seckill_activity")
                    .bizData(ImmutableMap.of("type", "activity", "activityId", id))
                    .params(ImmutableMap.of("activityId", id, "activityName", activity.getActivityName(), "startTime", activity.getStartTime(), "endTime", activity.getEndTime(), "skuIds", skuIds))
                    .fileName(FileNameUtils.generateSeckillActivityFilename(id))
                    .build().toJsonString();
                rocketMQTemplate.syncSend(QueueKey.QUEUE_RENDER_PAGE, renderActivityPageMessage);
                log.info("触发渲染页面，发送渲染商品列表页的消息, message={}", renderActivityPageMessage);
  
                for (ActivitySkuRef activitySkuRef : activitySkuRefs) {
                    //发送渲染秒杀商品详情页的消息
                    Long skuId = activitySkuRef.getSkuId();
                    String renderProductPageMessage = PageRenderMessage.builder()
                        .pageCode("seckill_product")
                        .bizData(ImmutableMap.of("type", "product", "activityId", id, "skuId", skuId))
                        .params(ImmutableMap.of("skuId", skuId))
                        .fileName(FileNameUtils.generateSeckillProductFilename(skuId))
                        .build().toJsonString();
                    rocketMQTemplate.syncSend(QueueKey.QUEUE_RENDER_PAGE, renderProductPageMessage);
                    log.info("触发渲染页面，发送渲染商品详情页的消息, message={}", renderProductPageMessage);
                }
  
                //把秒杀活动的状态修改为页面渲染中
                activityService.updateStatus(id, ActivityStatusVal.AUDIT_PASS.getCode(), ActivityStatusVal.PAGE_RENDERING.getCode());
                log.info("触发渲染页面，把秒杀活动状态改成页面渲染中");
            }
        } finally {
            lockService.release(CacheKey.TRIGGER_PAGE_LOCK, lockToken);
            log.info("触发渲染页面，释放分布式锁");
        }
    }
}

//进行Redis加锁时，会对key进行hash路由到某个Redis节点，再执行具体的加锁逻辑
public class RedisLockService implements LockService {
    private static final String DEL_KEY_BY_VALUE = 
        "if redis.call('get', '%s') == '%s'" +
        "then" +
        "   redis.call('del','%s');" +
        "   return '1';" +
        "else" +
        "    return '0'" +
        "end";
        
    private final JedisManager jedisManager;
    
    public RedisLockService(JedisManager jedisManager) {
        this.jedisManager = jedisManager;
    }

    @Override
    public String tryLock(String lockKey, long expiration, TimeUnit timeUnit) {
        int hashKey = lockKey.hashCode();
        try (Jedis jedis = jedisManager.getJedisByHashKey(hashKey)) {
            String lockToken = UUID.randomUUID().toString();
            String result = jedis.set(lockKey, lockToken, SetParams.setParams().nx().px(timeUnit.toMillis(expiration)));
            if ("OK".equals(result)) {
                return lockToken;
            }
        }
        return null;
    }

    @Override
    public boolean release(String lockKey, String lockToken) {
        int hashKey = lockKey.hashCode();
        try (Jedis jedis = jedisManager.getJedisByHashKey(hashKey)) {
            String script = String.format(DEL_KEY_BY_VALUE, lockKey, lockToken, lockKey);
            String result = (String) jedis.eval(script);
            if ("1".equals(result)) {
                return true;
            }
        }
        return false;
    }
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    //1.距离展示时间还有1小时
    //2.状态是已审核的
    @Override
    public List&lt;Activity&gt; queryListForTriggerPageTask() {
        Date showTime = DateUtils.addHours(new Date(), 1);
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.le("show_time", showTime);
        queryWrapper.eq("status", ActivityStatusVal.AUDIT_PASS.getCode());
        return activityMapper.selectList(queryWrapper);
    }
    
    @Override
    public boolean updateStatus(Long activityId, Integer oldStatus, Integer newStatus) {
        Activity activity = Activity.builder().status(newStatus).build();
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.eq("id", activityId);
        if (Objects.nonNull(oldStatus)) {
            queryWrapper.eq("status", oldStatus);
        }
        int affectedRows = activityMapper.update(activity, queryWrapper);
        return affectedRows == 1;
    }
    ...
}</code></pre>
<p data-track="90">下面是消费渲染页面结果的消息：</p>
<pre class="highlighter-hljs"><code>//消费渲染页面结果的消息(每渲染完一个页面就会发送一条页面渲染结果的消息)
@Component
@RocketMQMessageListener(topic = QueueKey.QUEUE_RENDER_PAGE_RESULT, consumerGroup = "pageResultGroup")
public class PageResultListener implements RocketMQListener&lt;String&gt; {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Override
    public void onMessage(String messageString) {
        log.info("收到渲染页面的结果, message={}", messageString);
        JSONObject message = JSONObject.parseObject(messageString);
        if (!message.getBoolean("success")) {
            log.error("页面渲染失败，需要及时查看问题");
            return;
        }
  
        //获取指定的bizData
        //渲染秒杀活动列表页时指定的bizData如下：
        //.bizData(ImmutableMap.of("type", "activity", "activityId", activity.getId()))
        //渲染秒杀商品详情页时指定的bizData如下：
        //.bizData(ImmutableMap.of("type", "product", "activityId", activity.getId(), "skuId", activitySkuRef.getSkuId()))
        JSONObject bizData = message.getJSONObject("bizData");
        String type = bizData.getString("type");
        Long activityId = bizData.getLong("activityId");
  
        //判断本次渲染成功的页面，是活动列表页还是商品详情页
        if (StringUtils.equals(type, "activity")) {
            activityService.updatePageReady(activityId, true);
            log.info("收到渲染页面的结果, 是活动页面的结果, 把活动的pageReady字段修改为true");
        } else if (StringUtils.equals(type, "product")) {
            activitySkuRefService.updatePageReady(activityId, bizData.getLong("skuId"), true);
            log.info("收到渲染页面的结果, 是商品页面的结果, 把商品的pageReady字段修改为true");
        }
  
        //判断当前活动是否所有的静态页面都渲染好了
        Activity activity = activityService.queryById(activityId);
        //count一下该秒杀活动下还没渲染完成的商品数量
        Integer count = activitySkuRefService.countByActivityIdAndPageReady(activityId, false);
        //当秒杀活动的页面已渲染成功 + 秒杀活动的所有商品详情页也渲染成功，则更新秒杀活动的状态为'页面已完成渲染'
        if (activity.getPageReady() &amp;&amp; count == 0) {
            //更新该秒杀活动的状态，从"页面渲染中"到"页面已完成渲染"
            activityService.updateStatus(activityId, ActivityStatusVal.PAGE_RENDERING.getCode(), ActivityStatusVal.PAGE_RENDERED.getCode());
            log.info("收到渲染页面的结果, 检查后发现当前活动的活动页面和商品页面都渲染好了，把活动状态改为'页面已渲染'");
            //下一步就是同步库存到Redis，进行库存数据的初始化了
            //触发执行库存数据初始化的定时任务的两个条件：
            //1.秒杀活动的所有页面已渲染完毕 + 2.now距离showTime在1小时以内
        }
    }
}</code></pre>
<p data-track="92"><strong>(12)触发库存分片并同步到Redis</strong></p>
<p data-track="93"><strong>一.什么时候触发库存分片</strong></p>
<p data-track="94">由于只有秒杀活动开始后才需要库存相关的数据，所以执行库存分片时所有静态⻚⾯都已渲染完毕，且秒杀活动还没开始。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96">可以在秒杀活动开始时间前1⼩时，把秒杀商品的库存分⽚同步到Redis，进行库存分片时可以同步调⽤库存服务的接⼝。库存分片完成后，则修改秒杀活动的状态为"库存已同步"。这样，这个秒杀活动就算就绪了，只要时间⼀到，⽤户就可以发起抢购。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>二.详细步骤的时序图</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d4aa954f42554c769a926bc298c87392~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250530085608B491FF59ED25B5E102FC&amp;x-expires=2147483647&amp;x-signature=OjEENC9V4N8z08G%2FNqmg6syxzbg%3D" data-ic="false" data-width="1080" data-height="502" data-ic-uri=""></div>
<pre class="highlighter-hljs"><code>//库存分片和同步库存
@Component
public class TriggerStockTask {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private LockService lockService;
    
    @Autowired
    private InventoryApi inventoryApi;

    @Scheduled(fixedDelay = 10_000)
    public void run() {
        String lockToken = lockService.tryLock(CacheKey.TRIGGER_STOCK_LOCK, 1, TimeUnit.SECONDS);
        if (lockToken == null) {
            return;
        }
        log.info("触发库存分片和同步库存，获取分布式锁成功, lockToken={}", lockToken);
        try {
            //查询已经渲染好页面的所有秒杀活动
            List&lt;Activity&gt; activities = activityService.queryListForTriggerStockTask();
            if (CollectionUtils.isEmpty(activities)) {
                return;
            }
            for (Activity activity : activities) {
                List&lt;ActivitySkuRef&gt; activitySkuRefs = activitySkuRefService.queryByActivityId(activity.getId());
                if (CollectionUtils.isEmpty(activitySkuRefs)) {
                    continue;
                }
                //要进行缓存初始化的商品，封装库存初始化请求
                List&lt;SyncProductStockRequest&gt; request = new ArrayList&lt;&gt;();
                for (ActivitySkuRef activitySkuRef : activitySkuRefs) {
                    SyncProductStockRequest syncProductStockRequest = SyncProductStockRequest.builder()
                        .activityId(activitySkuRef.getActivityId())
                        .skuId(activitySkuRef.getSkuId())
                        .seckillStock(activitySkuRef.getSeckillStock()).build();
                    request.add(syncProductStockRequest);
                }
                //把封装的库存初始化请求，发送到秒杀库存服务里
                //每个商品的库存数据都会分散到各个Redis节点上去，实现对商品库存分片存放
                if (inventoryApi.syncStock(request)) {
                    log.info("触发库存分片和同步库存，调用库存接口将商品库存同步到Redis");
                    activityService.updateStatus(activity.getId(), ActivityStatusVal.PAGE_RENDERED.getCode(), ActivityStatusVal.INVENTORY_SYNCED.getCode());
                    log.info("触发库存分片和同步库存，将秒杀活动的状态修改为库存已同步");
                    //完成库存分片后，用户就可以对商品发起秒杀抢购了
                } else {
                    log.error("触发库存分片和同步库存，库存同步失败");
                }
            }
        } finally {
            lockService.release(CacheKey.TRIGGER_STOCK_LOCK, lockToken);
            log.info("触发库存分片和同步库存，释放分布式锁");
        }
    }
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    //获取状态是已渲染好页面的秒杀活动
    @Override
    public List&lt;Activity&gt; queryListForTriggerStockTask() {
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.eq("status", ActivityStatusVal.PAGE_RENDERED.getCode());
        return activityMapper.selectList(queryWrapper);
    }
    ...
}

@FeignClient("demo-seckill-inventory-service")
@RequestMapping("/inventory")
public interface InventoryApi {
    @PostMapping("/syncStock")
    Boolean syncStock(@RequestBody List&lt;SyncProductStockRequest&gt; request);
    ...
}


@RestController
@RequestMapping("/inventory")
public class InventoryController {
    @Autowired
    private InventoryService inventoryService;
    
    @PostMapping("/syncStock")
    Boolean syncStock(@RequestBody List&lt;SyncProductStockRequest&gt; request) {
        for (SyncProductStockRequest syncProductStockRequest : request) {
            inventoryService.syncStock(syncProductStockRequest.getActivityId(), syncProductStockRequest.getSkuId(), syncProductStockRequest.getSeckillStock());
            log.info("同步商品库存, syncProductStockRequest={}", JSON.toJSONString(syncProductStockRequest));
        }
        return Boolean.TRUE;
    }
    ...
}

@Service
public class InventoryServiceImpl implements InventoryService {
    @Autowired
    private CacheSupport cacheSupport;
    ...
    
    @Override
    public Boolean syncStock(Long activityId, Long skuId, Integer stock) {
        //下面这种分片方式会有一个问题
        //比如，现在库存是10，Redis的节点个数是6
        //那么按照如下方式，最后的结果是：1、1、1、1、1、5
        //但是我们希望尽可能均分成：2、2、2、2、1、1
        //int redisCount = cacheSupport.getRedisCount();
        //int stockPerRedis = stock / redisCount;
        //int stockLastRedis = stock - (stockPerRedis * (redisCount - 1));
  
        //所以改成如下这种分片方式
        //首先获取Redis实例数量，将库存拆分为与Redis实例个数一样的redisCount个库存分片
        int redisCount = cacheSupport.getRedisCount();
        //然后将具体的库存分片结果存放到一个Map中
        //其中key是某Redis节点的索引，value是该Redis节点应该分的库存
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; stock; i++) {
            //均匀把stock的数据分散放到我们的各个节点上去
            int index = i % redisCount;
            //对每个节点的库存数量不停进行累加操作
            map.putIfAbsent(index, 0);
            map.put(index, map.get(index) + 1);
        }
  
        List&lt;Map&lt;String, String&gt;&gt; stockList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; redisCount; i++) {
            Map&lt;String, String&gt; stockMap = new HashMap&lt;&gt;();
            stockMap.put(CacheKey.SALABLE_STOCK, map.get(i) + "");
            stockMap.put(CacheKey.LOCKED_STOCK, "0");
            stockMap.put(CacheKey.SOLD_STOCK, "0");
            stockList.add(stockMap);
            log.info("库存分片 stockMap={}", JSON.toJSONString(stockMap));
        }
        cacheSupport.hsetOnAllRedis(CacheKey.buildStockKey(activityId, skuId), stockList);
        return Boolean.TRUE;
    }
    ...
}

public class RedisCacheSupport implements CacheSupport {
    private final JedisManager jedisManager;
    
    public RedisCacheSupport(JedisManager jedisManager) {
        this.jedisManager = jedisManager;
    }
    
    @Override
    public int getRedisCount() {
        return jedisManager.getRedisCount();
    }
    ...
    
    @Override
    public void hsetOnAllRedis(String key, List&lt;Map&lt;String, String&gt;&gt; hashList) {
        for (int i = 0; i &lt; jedisManager.getRedisCount(); i++) {
            //通过hset命令，向每个Redis节点写入库存分片数据
            try (Jedis jedis = jedisManager.getJedisByIndex(i)) {
                jedis.hset(key, hashList.get(i));
            }
        }
    }
    ...
}</code></pre>
<p data-track="100"><strong>(13)清理秒杀活动相关的数据</strong></p>
<p data-track="101">当秒杀活动结束后，就需要清理静态⻚⾯的数据和⽤户相关的缓存数据。比如以到了实际结束时间之后为准，不考虑因为库存抢购完⽽结束的情况。其中对于缓存数据的清理，会通过⼿动设置过期时间来实现⾃动过期。</p>
<pre class="highlighter-hljs"><code>@Component
public class CleanDataTask {
    @Autowired
    private ActivityService activityService;
    
    @Autowired
    private ActivitySkuRefService activitySkuRefService;
    
    @Autowired
    private LockService lockService;
    
    @Autowired
    private InventoryApi inventoryApi;

    @Scheduled(fixedDelay = 10_000)
    public void run() {
        String lockToken = lockService.tryLock(CacheKey.CLEAN_DATA_LOCK, 1, TimeUnit.SECONDS);
        if (lockToken == null) {
            return;
        }
        log.info("秒杀活动结束后清理数据，获取分布式锁成功, lockToken={}", lockToken);
        try {
            //查询已经结束1小时的秒杀活动
            //当秒杀活动都结束1小时后，对于抢购成功的商品，要么已支付，要么已自动取消，因为订单默认是超过30分钟不支付就取消的
            List&lt;Activity&gt; activities = activityService.queryListForCleanDataTask();
            if (CollectionUtils.isEmpty(activities)) {
                return;
            }
  
            for (Activity activity : activities) {
                List&lt;ActivitySkuRef&gt; activitySkuRefs = activitySkuRefService.queryByActivityId(activity.getId());
                if (CollectionUtils.isEmpty(activitySkuRefs)) {
                    continue;
                }
  
                //清理库存
                List&lt;Long&gt; skuIds = activitySkuRefs.stream().map(ActivitySkuRef::getSkuId).collect(Collectors.toList());
                CleanStockRequest request = CleanStockRequest.builder().activityId(activity.getId()).skuIds(skuIds).build();
                List&lt;ProductStockVo&gt; productStockVos = inventoryApi.cleanStock(request);
  
                //将此时秒杀商品的库存数据保存到数据库中，方便以后查看本次秒杀活动最终数据
                for (ProductStockVo vo : productStockVos) {
                    activitySkuRefService.modify(vo.getActivityId(), vo.getSkuId(), vo.getSalableStock(), vo.getLockedStock(), vo.getSoldStock());
                    log.info("秒杀活动结束后清理数据，保存库存信息, stock={}", JSON.toJSONString(vo));
                }
  
                //修改秒杀活动状态
                activityService.updateStatus(activity.getId(), ActivityStatusVal.INVENTORY_SYNCED.getCode(), ActivityStatusVal.DATA_CLEANED.getCode());
            }
        } finally {
            lockService.release(CacheKey.TRIGGER_STOCK_LOCK, lockToken);
            log.info("秒杀活动结束之后请清理数据，释放分布式锁");
        }
    }
}

//进行Redis加锁时，会对key进行hash路由到某个Redis节点，再执行具体的加锁逻辑
public class RedisLockService implements LockService {
    private static final String DEL_KEY_BY_VALUE = 
        "if redis.call('get', '%s') == '%s'" +
        "then" +
        "   redis.call('del','%s');" +
        "   return '1';" +
        "else" +
        "    return '0'" +
        "end";
    
    private final JedisManager jedisManager;
    
    public RedisLockService(JedisManager jedisManager) {
        this.jedisManager = jedisManager;
    }
    
    @Override
    public String tryLock(String lockKey, long expiration, TimeUnit timeUnit) {
        int hashKey = lockKey.hashCode();
        try (Jedis jedis = jedisManager.getJedisByHashKey(hashKey)) {
            String lockToken = UUID.randomUUID().toString();
            String result = jedis.set(lockKey, lockToken, SetParams.setParams().nx().px(timeUnit.toMillis(expiration)));
            if ("OK".equals(result)) {
                return lockToken;
            }
        }
        return null;
    }

    @Override
    public boolean release(String lockKey, String lockToken) {
        int hashKey = lockKey.hashCode();
        try (Jedis jedis = jedisManager.getJedisByHashKey(hashKey)) {
            String script = String.format(DEL_KEY_BY_VALUE, lockKey, lockToken, lockKey);
            String result = (String) jedis.eval(script);
            if ("1".equals(result)) {
                return true;
            }
        }
        return false;
    }
}

@Service
public class ActivityServiceImpl implements ActivityService {
    @Autowired
    private ActivityMapper activityMapper;
    ...
    
    //获取状态是库存已同步+结束时间已经过了1小时的秒杀活动
    @Override
    public List&lt;Activity&gt; queryListForCleanDataTask() {
        Date endTime = DateUtils.addHours(new Date(), -1);
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.le("end_time", endTime);
        queryWrapper.eq("status", ActivityStatusVal.INVENTORY_SYNCED.getCode());
        return activityMapper.selectList(queryWrapper);
    }
    
    @Override
    public boolean updateStatus(Long activityId, Integer oldStatus, Integer newStatus) {
        Activity activity = Activity.builder().status(newStatus).build();
        QueryWrapper&lt;Activity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.eq("id", activityId);
        if (Objects.nonNull(oldStatus)) {
            queryWrapper.eq("status", oldStatus);
        }
        int affectedRows = activityMapper.update(activity, queryWrapper);
        return affectedRows == 1;
    }
    ...
}

@FeignClient("demo-seckill-inventory-service")
@RequestMapping("/inventory")
public interface InventoryApi {
    ...
    @PostMapping("/cleanStock")
    List&lt;ProductStockVo&gt; cleanStock(@RequestBody CleanStockRequest request);
}

@RestController
@RequestMapping("/inventory")
public class InventoryController {
    @Autowired
    private InventoryService inventoryService;
    ...
    
    @PostMapping("/cleanStock")
    List&lt;ProductStockVo&gt; cleanStock(@RequestBody CleanStockRequest request) {
        List&lt;ProductStockVo&gt; resultList = new ArrayList&lt;&gt;();
        Long activityId = request.getActivityId();
        //查询库存&amp;删除库存
        for (Long skuId : request.getSkuIds()) {
            ProductStockVo productStockVo = inventoryService.queryCurrentStock(activityId, skuId);
            inventoryService.cleanStock(activityId, skuId);
            resultList.add(productStockVo);
        }
        return resultList;
    }
    ...
}

@Service
public class InventoryServiceImpl implements InventoryService {
    @Autowired
    private CacheSupport cacheSupport;
    
    //从Redis中获取当前库存数据
    @Override
    public ProductStockVo queryCurrentStock(Long activityId, Long skuId) {
        List&lt;Map&lt;String, String&gt;&gt; stockList = cacheSupport.hgetAllOnAllRedis(CacheKey.buildStockKey(activityId, skuId));
        int salableStock = 0;
        int lockedStock = 0;
        int soldStock = 0;
        for (Map&lt;String, String&gt; stockMap : stockList) {
            salableStock += Integer.parseInt(stockMap.get(CacheKey.SALABLE_STOCK));
            lockedStock += Integer.parseInt(stockMap.get(CacheKey.LOCKED_STOCK));
            soldStock += Integer.parseInt(stockMap.get(CacheKey.SOLD_STOCK));
        }
        return ProductStockVo.builder().activityId(activityId).skuId(skuId).salableStock(salableStock).lockedStock(lockedStock).soldStock(soldStock).build();
    }
    
    @Override
    public Boolean cleanStock(Long activityId, Long skuId) {
        cacheSupport.delOnAllRedis(CacheKey.buildStockKey(activityId, skuId));
        return Boolean.TRUE;
    }
    ...
}

public class RedisCacheSupport implements CacheSupport {
    private final JedisManager jedisManager;
    
    public RedisCacheSupport(JedisManager jedisManager) {
        this.jedisManager = jedisManager;
    }
    
    @Override
    public int getRedisCount() {
        return jedisManager.getRedisCount();
    }
    ...
    
    @Override
    public List&lt;Map&lt;String, String&gt;&gt; hgetAllOnAllRedis(String key) {
        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; jedisManager.getRedisCount(); i++) {
            try (Jedis jedis = jedisManager.getJedisByIndex(i)) {
                list.add(jedis.hgetAll(key));
            }
        }
        return list;
    }
    
    @Override
    public Long delOnAllRedis(String key) {
        for (int i = 0; i &lt; jedisManager.getRedisCount(); i++) {
            try (Jedis jedis = jedisManager.getJedisByIndex(i)) {
                jedis.del(key);
            }
        }
        return 1L;
    }
    ...
}</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004421111356481482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-30 09:03">2025-05-30 09:02</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18903527);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18903527', targetLink: 'https://www.cnblogs.com/mjunz/p/18903527', title: '秒杀系统—4.第二版升级优化的技术文档二' })">举报</a>
</div>
        