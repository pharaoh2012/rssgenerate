
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ludangxin/p/18730466" title="发布于 2025-02-22 00:09">
    <span role="heading" aria-level="2">5. 想在代码中验证sql的正确性？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<p>我们在平时的开发中可能会遇到需要验证一下sql是否正确，也就是需要check一下sql。</p>
<p>判断sql是否正确一般包含一下几点：</p>
<pre><code>1. sql中使用的列是否存在
2. sql语法是否正确
3. sql中使用到的操作符/函数是否存在，有没有正确的使用
</code></pre>
<p>我们可以用以下的sql示例来探究一下使用calcite如何校验sql</p>
<pre><code class="language-sql">select 
	u.sex,
    max(u.age)
from user u
         inner join role r on u.role_id = r.id
where r.id = 1
group by u.sex
</code></pre>
<h2 id="2-maven">2. Maven</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;
    &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;
    &lt;version&gt;1.37.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.33&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-验证">3. 验证</h2>
<p>首先 在calcite中验证sql的正确性是通过使用calcite中的<code>SqlValidator</code>类进行校验的，但<code>SqlValidator</code>是一个接口， 通常是通过<code>SqlValidatorUtil.newValidator(...)</code>方法进行实例化的, 如下：</p>
<pre><code class="language-java">public static SqlValidatorWithHints newValidator(SqlOperatorTable opTab,
                                                 SqlValidatorCatalogReader catalogReader, 
                                                 RelDataTypeFactory typeFactory, 
                                                 SqlValidator.Config config) 
{
    return new SqlValidatorImpl(opTab, catalogReader, typeFactory, config);    
}
</code></pre>
<ul>
<li>SqlOperatorTable：用来提供sql验证所需的操作符（SqlOperator）和函数（SqlFunction）例如：&gt;, &lt;, = 或max(),in()</li>
<li>SqlValidatorCatalogReader：用来提供验证所需的元数据信息 例如： schema, table, column</li>
<li>RelDataTypeFactory：处理数据类型的工厂类，用来提供类型、java类型和集合类型的创建和转化。针对不同的接口形式，calcite支持sql和java两种实现（SqlTypeFactoryImpl和JavaTypeFactoryImpl），当然这里用户可以针对不同的情况自行扩展</li>
<li>SqlValidator.Config：可以自定义一些配置，例如是否开启类型隐式转换、是否开启 SQL 重写等等</li>
</ul>
<h3 id="31-创建sqlvalidator">3.1 创建SqlValidator</h3>
<p>创建<code>SqlValidator</code>之前需要先实例化上述的四个入参对象，好在calcite提供了对应属性的默认实现，使得我们能很方便的创建<code>SqlValidator</code>对象</p>
<pre><code class="language-java">SqlValidator validator = SqlValidatorUtil.newValidator(
    SqlStdOperatorTable.instance(),
    catalogReader, // catalog信息需要自己手动创建
    new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT),
    SqlValidator.Config.DEFAULT);
</code></pre>
<p>这里除了<code>SqlValidatorCatalogReader</code>对象需要额外的自己创建，如果没有特殊的需求，我们都可以使用calcite提供的默认实现。</p>
<p>我们这里着重讲一下<code>SqlValidatorCatalogReader</code>对象如何创建</p>
<p>首先<code>SqlValidatorCatalogReader</code>使用来提供验证所需的catalog信息的，那我们就需要提供一下catalog信息（因为calcite需要做元数据的验证，比如表，字段是否存在，不提供元数据calcite谈何验证）</p>
<p>创建<code>SqlValidatorCatalogReader</code>有两种方式：</p>
<ol>
<li>
<p>通过数据源的方式，也就是我们知道执行sql的server信息，把连接信息给calcite，让calcite自己去获取元信息并进行验证，也就是这个时候需要去连接db才能进行验证</p>
<pre><code class="language-java">@SneakyThrows
private static CalciteCatalogReader createCatalogReaderWithDataSource() {
    Connection connection = DriverManager.getConnection("jdbc:calcite:");
    CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
    SchemaPlus rootSchema = calciteConnection.getRootSchema();
    DataSource dataSource = JdbcSchema.dataSource(
        "jdbc:mysql://localhost:3306/test",
        "com.mysql.cj.jdbc.Driver",
        "root",
        "123456"
    );
    JdbcSchema jdbcSchema = JdbcSchema.create(rootSchema, "my_mysql", dataSource, null, null);
    rootSchema.add("my_mysql", jdbcSchema);
    calciteConnection.setSchema("my_mysql");
    CalciteServerStatement statement = connection.createStatement().unwrap(CalciteServerStatement.class);
    CalcitePrepare.Context prepareContext = statement.createPrepareContext();
    SqlTypeFactoryImpl factory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);

    return new CalciteCatalogReader(
        prepareContext.getRootSchema(),
        prepareContext.getDefaultSchemaPath(),
        factory,
        calciteConnection.config());
}
</code></pre>
</li>
<li>
<p>手动添加catalog信息，不需要连库就能验证</p>
<pre><code class="language-java">private static CalciteCatalogReader createCatalogReaderWithMeta() {
    SchemaPlus rootSchema = Frameworks.createRootSchema(true);
    RelDataTypeSystem relDataTypeSystem = RelDataTypeSystem.DEFAULT;
    RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(relDataTypeSystem);
    rootSchema.add("user", new AbstractTable() {
        @Override
        public RelDataType getRowType(RelDataTypeFactory typeFactory) {
            RelDataTypeFactory.Builder builder = typeFactory.builder();
            builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
            builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
            builder.add("age", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
            builder.add("sex", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
            builder.add("role_id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
            return builder.build();
        }
    });
    rootSchema.add("role", new AbstractTable() {
        @Override
        public RelDataType getRowType(RelDataTypeFactory typeFactory) {
            RelDataTypeFactory.Builder builder = typeFactory.builder();
            builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
            builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
            return builder.build();
        }
    });
    CalciteConnectionConfig connectionConfig = CalciteConnectionConfig.DEFAULT;

    return new CalciteCatalogReader(
        CalciteSchema.from(rootSchema),
        CalciteSchema.from(rootSchema).path(null),
        typeFactory,
        connectionConfig);
}
</code></pre>
<p>ok，至此创建<code>SqlValidator</code>所需的参数都已备齐，但是当执行验证方法的时候所需的参数并不是sql字符串而是<code>SqlValidator.validate(SqlNode topNode)</code>, 那么<code>SqlNode</code>又要怎么创建 ?</p>
</li>
</ol>
<h3 id="32-解析sql">3.2 解析Sql</h3>
<p><code>SqlNode</code> 顾名思义就是sql节点对象，直接通过<code>SqlParser</code>对象创建，如下</p>
<pre><code class="language-java">SqlParser.Config config = SqlParser.config()
                                     // 解析工厂
                                     .withParserFactory(SqlParserImpl.FACTORY)
                                     // 也可以直接设置为对应数据库的词法分析器
                                     // .withLex(Lex.MYSQL) 
                                     // 不区分大小写
                                     .withCaseSensitive(false)
                                     // 引用符号为反引号
                                     .withQuoting(Quoting.BACK_TICK)
                                     // 未加引号的标识符在解析时不做处理
                                     .withUnquotedCasing(Casing.UNCHANGED)
                                     // 加引号的标识符在解析时不做处理
                                     .withQuotedCasing(Casing.UNCHANGED)
                                     // 使用默认的语法规则
                                     .withConformance(SqlConformanceEnum.DEFAULT);
// sql解析器
final SqlParser parser = SqlParser.create(SQL, config);
// 将sql转换为calcite的SqlNode
SqlNode sqlNode = parser.parseQuery();
</code></pre>
<h3 id="33-执行验证">3.3 执行验证</h3>
<p>通过上述的步骤 我们已经能创建<code>SqlValidator</code>对象并且能创建其验证时需要的<code>SqlNode</code>对象，其实很简单， 只要验证时不报错，即sql是正确的</p>
<pre><code class="language-java">try{
 // 校验 sql
 validator.validate(sqlNode);
 log.info("sql is valid");
}
catch (Exception e) {
 log.error("sql is invalid", e);
}
</code></pre>
<h2 id="4-完整验证代码">4. 完整验证代码</h2>
<h3 id="41-通过sqlvalidator进行验证">4.1 通过SqlValidator进行验证</h3>
<pre><code class="language-java">package com.ldx.calcite;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.adapter.jdbc.JdbcSchema;
import org.apache.calcite.avatica.util.Casing;
import org.apache.calcite.avatica.util.Quoting;
import org.apache.calcite.config.CalciteConnectionConfig;
import org.apache.calcite.jdbc.CalciteConnection;
import org.apache.calcite.jdbc.CalcitePrepare;
import org.apache.calcite.jdbc.CalciteSchema;
import org.apache.calcite.prepare.CalciteCatalogReader;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rel.type.RelDataTypeFactory;
import org.apache.calcite.rel.type.RelDataTypeSystem;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.schema.impl.AbstractTable;
import org.apache.calcite.server.CalciteServerStatement;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.parser.SqlParser;
import org.apache.calcite.sql.parser.impl.SqlParserImpl;
import org.apache.calcite.sql.type.BasicSqlType;
import org.apache.calcite.sql.type.SqlTypeFactoryImpl;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.calcite.sql.validate.SqlConformanceEnum;
import org.apache.calcite.sql.validate.SqlValidator;
import org.apache.calcite.sql.validate.SqlValidatorUtil;
import org.apache.calcite.tools.Frameworks;
import org.junit.jupiter.api.Test;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.DriverManager;

@Slf4j
public class SqlValidatorTest {
    private static final String SQL = "select u.sex, max(u.age) from `user` u inner join role r on u.role_id = r.id where r.id = 1 group by u.sex";

    @Test
    @SneakyThrows
    public void given_sql_and_meta_then_validate_sql() {
        SqlParser.Config config = SqlParser.config()
                                           // 解析工厂
                                           .withParserFactory(SqlParserImpl.FACTORY)
                                           // 也可以直接设置为对应数据库的词法分析器
                                           // .withLex(Lex.MYSQL)
                                           // 不区分大小写
                                           .withCaseSensitive(false)
                                           // 引用符号为反引号
                                           .withQuoting(Quoting.BACK_TICK)
                                           // 未加引号的标识符在解析时不做处理
                                           .withUnquotedCasing(Casing.UNCHANGED)
                                           // 加引号的标识符在解析时不做处理
                                           .withQuotedCasing(Casing.UNCHANGED)
                                           // 使用默认的语法规则
                                           .withConformance(SqlConformanceEnum.DEFAULT);
        // sql解析器
        final SqlParser parser = SqlParser.create(SQL, config);
        // 将SQL转换为Calcite的SqlNode
        SqlNode sqlNode = parser.parseQuery();
        // 创建 SqlValidator 来进行校验
        SqlValidator validator = SqlValidatorUtil.newValidator(
                SqlStdOperatorTable.instance(),
                // 使用直接提供元信息的方式
                createCatalogReaderWithMeta(),
                // 使用提供数据源的方式
                //createCatalogReaderWithDataSource(),
                new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT),
                SqlValidator.Config.DEFAULT);
        try{
            // 校验 sql
            validator.validate(sqlNode);
            log.info("sql is valid");
        }
        catch (Exception e) {
            log.error("sql is invalid", e);
        }
    }

    private static CalciteCatalogReader createCatalogReaderWithMeta() {
        SchemaPlus rootSchema = Frameworks.createRootSchema(true);
        RelDataTypeSystem relDataTypeSystem = RelDataTypeSystem.DEFAULT;
        RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(relDataTypeSystem);
        rootSchema.add("user", new AbstractTable() {
                    @Override
                    public RelDataType getRowType(RelDataTypeFactory typeFactory) {
                        RelDataTypeFactory.Builder builder = typeFactory.builder();
                        builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                        builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                        builder.add("age", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                        builder.add("sex", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                        builder.add("role_id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                        return builder.build();
                    }
                });
        rootSchema.add("role", new AbstractTable() {
            @Override
            public RelDataType getRowType(RelDataTypeFactory typeFactory) {
                RelDataTypeFactory.Builder builder = typeFactory.builder();
                builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                return builder.build();
            }
        });
        CalciteConnectionConfig connectionConfig = CalciteConnectionConfig.DEFAULT;

        return new CalciteCatalogReader(
                CalciteSchema.from(rootSchema),
                CalciteSchema.from(rootSchema).path(null),
                typeFactory,
                connectionConfig);
    }

    @SneakyThrows
    private static CalciteCatalogReader createCatalogReaderWithDataSource() {
        Connection connection = DriverManager.getConnection("jdbc:calcite:");
        CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
        SchemaPlus rootSchema = calciteConnection.getRootSchema();
        DataSource dataSource = JdbcSchema.dataSource(
                "jdbc:mysql://localhost:3306/test",
                "com.mysql.cj.jdbc.Driver",
                "root",
                "123456"
        );
        JdbcSchema jdbcSchema = JdbcSchema.create(rootSchema, "my_mysql", dataSource, null, null);
        rootSchema.add("my_mysql", jdbcSchema);
        calciteConnection.setSchema("my_mysql");
        CalciteServerStatement statement = connection.createStatement().unwrap(CalciteServerStatement.class);
        CalcitePrepare.Context prepareContext = statement.createPrepareContext();
        SqlTypeFactoryImpl factory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);

        return new CalciteCatalogReader(
                prepareContext.getRootSchema(),
                prepareContext.getDefaultSchemaPath(),
                factory,
                calciteConnection.config());
    }
}
</code></pre>
<h3 id="42-使用planner对象进行验证">4.2 使用Planner对象进行验证</h3>
<blockquote>
<p>其实Planner.validate方法其底层使用的还是SqlValidator对象进行验证</p>
</blockquote>
<pre><code class="language-java">package com.ldx.calcite;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.avatica.util.Casing;
import org.apache.calcite.avatica.util.Quoting;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rel.type.RelDataTypeFactory;
import org.apache.calcite.rel.type.RelDataTypeSystem;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.schema.impl.AbstractTable;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.parser.SqlParser;
import org.apache.calcite.sql.parser.impl.SqlParserImpl;
import org.apache.calcite.sql.type.BasicSqlType;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.calcite.sql.validate.SqlConformanceEnum;
import org.apache.calcite.tools.FrameworkConfig;
import org.apache.calcite.tools.Frameworks;
import org.apache.calcite.tools.Planner;
import org.apache.calcite.tools.ValidationException;
import org.junit.jupiter.api.Test;

@Slf4j
public class SqlValidatorWithPlannerTest {
    private static final String SQL = "select u.sex, max(u.age) from `user` u inner join role r on u.role_id = r.id where r.id = 1 group by u.sex";

    @Test
    @SneakyThrows
    public void given_sql_and_meta_then_validate_sql() {
        // 创建Calcite配置
        FrameworkConfig config = createFrameworkConfig();
        // 创建Planner
        Planner planner = Frameworks.getPlanner(config);
        // 解析SQL
        final SqlNode parse = planner.parse(SQL);

        try {
            // 获取SqlValidator进行校验
            planner.validate(parse);
            log.info("sql is valid");
        } catch (ValidationException e) {
            log.error("sql is invalid", e);
        }
    }

    private static FrameworkConfig createFrameworkConfig() {
        SchemaPlus rootSchema = Frameworks.createRootSchema(true);
        RelDataTypeSystem relDataTypeSystem = RelDataTypeSystem.DEFAULT;
        rootSchema.add("user", new AbstractTable() {
            @Override
            public RelDataType getRowType(RelDataTypeFactory typeFactory) {
                RelDataTypeFactory.Builder builder = typeFactory.builder();
                builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                builder.add("age", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                builder.add("sex", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                builder.add("role_id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                return builder.build();
            }
        });
        rootSchema.add("role", new AbstractTable() {
            @Override
            public RelDataType getRowType(RelDataTypeFactory typeFactory) {
                RelDataTypeFactory.Builder builder = typeFactory.builder();
                builder.add("id", new BasicSqlType(relDataTypeSystem, SqlTypeName.INTEGER));
                builder.add("name", new BasicSqlType(relDataTypeSystem, SqlTypeName.VARCHAR));
                return builder.build();
            }
        });
        SqlParser.Config config = SqlParser.config()
                                           .withParserFactory(SqlParserImpl.FACTORY)
                                           .withQuoting(Quoting.BACK_TICK)
                                           .withCaseSensitive(false)
                                           .withUnquotedCasing(Casing.UNCHANGED)
                                           .withQuotedCasing(Casing.UNCHANGED)
                                           .withConformance(SqlConformanceEnum.DEFAULT);
        return Frameworks
                .newConfigBuilder()
                .defaultSchema(rootSchema)
                .parserConfig(config)
                .build();
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1691937224074074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-22 00:11">2025-02-22 00:09</span>&nbsp;
<a href="https://www.cnblogs.com/ludangxin">张铁牛</a>&nbsp;
阅读(<span id="post_view_count">25</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18730466" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18730466);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18730466', targetLink: 'https://www.cnblogs.com/ludangxin/p/18730466', title: '5. 想在代码中验证sql的正确性？' })">举报</a>
</div>
        