
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18796941" title="发布于 2025-03-27 21:55">
    <span role="heading" aria-level="2">Netty源码—8.编解码原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="3" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="4"><strong>1.读数据入口</strong></p>
<p data-track="5"><strong>2.拆包原理</strong></p>
<p data-track="6"><strong>3.ByteToMessageDecoder解码步骤</strong></p>
<p data-track="7"><strong>4.解码器抽象的解码过程总结</strong></p>
<p data-track="8"><strong>5.Netty里常见的开箱即用的解码器</strong></p>
<p data-track="9"><strong>6.writeAndFlush()方法的大体步骤</strong></p>
<p data-track="10"><strong>7.MessageToByteEncoder的编码步骤</strong></p>
<p data-track="11"><strong>8.unsafe.write()写队列</strong></p>
<p data-track="12"><strong>9.unsafe.flush()刷新写队列</strong></p>
<p data-track="13"><strong>10.如何把对象变成字节流写到unsafe底层</strong></p>
<p data-track="14">&nbsp;</p>
<p data-track="15"><strong>1.读数据入口</strong></p>
<p data-track="16">当客户端Channel的Reactor线程NioEventLoop检测到有读事件时，会执行NioByteUnsafe的read()方法。该方法会调用doReadBytes()方法将TCP缓冲区的数据读到由ByteBufAllocator分配的一个ByteBuf对象中，然后通过pipeline.fireChannelRead()方法带上这个ByteBuf对象向下传播ChannelRead事件。</p>
<p data-track="17">&nbsp;</p>
<p data-track="18">在传播的过程中，首先会来到pipeline的head结点的channelRead()方法。该方法会继续带着那个ByteBuf对象向下传播ChannelRead事件，比如会来到ByteToMessageDecoder结点的channelRead()方法。</p>
<p data-track="19">&nbsp;</p>
<p data-track="20">注意：服务端Channel的unsafe变量是一个NioMessageUnsafe对象，客户端Channel的unsafe变量是一个NioByteUnsafe对象。</p>
<pre class="highlighter-hljs"><code>//SingleThreadEventLoop implementation which register the Channel's to a Selector and so does the multi-plexing of these in the event loop.
public&nbsp;final&nbsp;class&nbsp;NioEventLoop&nbsp;extends&nbsp;SingleThreadEventLoop&nbsp;{
&nbsp; &nbsp; Selector selector;
&nbsp; &nbsp;&nbsp;private&nbsp;SelectedSelectionKeySet selectedKeys;
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;needsToSelectAgain;
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;cancelledKeys;
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;protected&nbsp;void&nbsp;run()&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(;;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.调用select()方法执行一次事件轮询
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; select(wakenUp.getAndSet(false));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(wakenUp.get()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selector.wakeup();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.处理产生IO事件的Channel
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needsToSelectAgain =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processSelectedKeys();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.执行外部线程放入TaskQueue的任务
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runAllTasks(ioTime * (100&nbsp;- ioRatio) / ioRatio);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;processSelectedKeys()&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(selectedKeys !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//selectedKeys.flip()会返回一个数组
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processSelectedKeysOptimized(selectedKeys.flip());
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processSelectedKeysPlain(selector.selectedKeys());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;processSelectedKeysOptimized(SelectionKey[] selectedKeys)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;; i ++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.首先取出IO事件
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;SelectionKey&nbsp;k&nbsp;=&nbsp;selectedKeys[i];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(k ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectedKeys[i] =&nbsp;null;//Help GC
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.然后获取对应的Channel和处理该Channel
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//默认情况下，这个a就是NioChannel，也就是服务端启动时经过Netty封装的Channel
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;Object&nbsp;a&nbsp;=&nbsp;k.attachment();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(a&nbsp;instanceof&nbsp;AbstractNioChannel) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//网络事件的处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processSelectedKey(k, (AbstractNioChannel) a);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//NioTask主要用于当一个SelectableChannel注册到Selector时，执行的一些任务
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processSelectedKey(k, task);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.最后判断是否应该再进行一次轮询
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(needsToSelectAgain) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(;;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(selectedKeys[i] ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectedKeys[i] =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectAgain();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//selectedKeys.flip()会返回一个数组
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectedKeys =&nbsp;this.selectedKeys.flip();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = -1;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;processSelectedKey(SelectionKey k, AbstractNioChannel ch)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;AbstractNioChannel.NioUnsafe&nbsp;unsafe&nbsp;=&nbsp;ch.unsafe();
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;readyOps&nbsp;=&nbsp;k.readyOps();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//新连接已准备接入或者已经存在的连接有数据可读
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !=&nbsp;0&nbsp;|| readyOps ==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果是新连接已准备接入，则调用NioMessageUnsafe的read()方法
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果是已经存在的连接有数据可读，执行的是NioByteUnsafe的read()方法
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsafe.read();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!ch.isOpen()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(CancelledKeyException ignored) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsafe.close(unsafe.voidPromise());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}

public&nbsp;abstract&nbsp;class&nbsp;AbstractNioByteChannel&nbsp;extends&nbsp;AbstractNioChannel&nbsp;{
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;protected&nbsp;class&nbsp;NioByteUnsafe&nbsp;extends&nbsp;AbstractNioUnsafe&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;final&nbsp;void&nbsp;read()&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ChannelConfig&nbsp;config&nbsp;=&nbsp;config();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ChannelPipeline&nbsp;pipeline&nbsp;=&nbsp;pipeline();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//创建ByteBuf分配器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ByteBufAllocator&nbsp;allocator&nbsp;=&nbsp;config.getAllocator();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;RecvByteBufAllocator.Handle&nbsp;allocHandle&nbsp;=&nbsp;recvBufAllocHandle();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocHandle.reset(config);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;byteBuf&nbsp;=&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;do&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.分配一个ByteBuf
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteBuf = allocHandle.allocate(allocator);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.将数据读取到分配的ByteBuf中
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocHandle.lastBytesRead(doReadBytes(byteBuf));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(allocHandle.lastBytesRead() &lt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteBuf.release();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteBuf =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close = allocHandle.lastBytesRead() &lt;&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.调用DefaultChannelPipeline的fireChannelRead()方法从Head结点开始传播事件
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipeline.fireChannelRead(byteBuf);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteBuf =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;while&nbsp;(allocHandle.continueReading());

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocHandle.readComplete();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4.调用DefaultChannelPipeline的fireChannelReadComplete()方法从Head结点开始传播事件
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipeline.fireChannelReadComplete();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</code></pre>
<p data-track="22">NioByteUnsafe主要会进行如下处理：</p>
<p data-track="23">一.通过客户端Channel的ChannelConfig获取内存分配器ByteBufAllocator，然后用内存分配器来分配一个ByteBuf对象</p>
<p data-track="24">二.将客户端Channel中的TCP缓冲区的数据读取到ByteBuf对象</p>
<p data-track="25">三.读取完数据后便调用DefaultChannelPipeline的fireChannelReadComplete()方法，从HeadContext结点开始在整个ChannelPipeline中传播ChannelRead事件</p>
<p data-track="26">&nbsp;</p>
<p data-track="27"><strong>2.拆包原理</strong></p>
<p data-track="28"><strong>一.不用Netty的拆包原理</strong></p>
<p data-track="29">不断地从TCP缓冲区中读取数据，每次读完都判断是否为一个完整的数据包。如果当前读取的数据不足以拼接成一个完整的数据包，就保留数据，继续从TCP缓冲区中读。如果当前读取的数据加上已读取的数据足够拼成完整的数据包，就将拼好的数据包往业务传递，而多余的数据则保留。</p>
<p data-track="30">&nbsp;</p>
<p data-track="31"><strong>二.Netty的拆包原理</strong></p>
<p data-track="32">Netty拆包基类内部会有一个字节容器，每次读取到数据就添加到字节容器中。然后尝试对累加的字节数据进行拆包，拆成一个完整的业务数据包，这个拆包基类叫ByteToMessageDecoder。</p>
<p data-track="33">&nbsp;</p>
<p data-track="34"><strong>3.ByteToMessageDecoder解码步骤</strong></p>
<p data-track="35"><strong>(1)解码的整体步骤</strong></p>
<p data-track="36"><strong>(2)首先累加字节流</strong></p>
<p data-track="37"><strong>(3)然后调用子类的decode()方法进行解析</strong></p>
<p data-track="38"><strong>(4)接着清理累加字节容器</strong></p>
<p data-track="39"><strong>(5)最后将解析到的ByteBuf向下传播</strong></p>
<p data-track="40">&nbsp;</p>
<p data-track="41"><strong>(1)解码的整体介绍</strong></p>
<p data-track="42">一.累加字节流</p>
<p data-track="43">Netty会通过一个ByteBuf字节容器cumulation，把所有读取到的字节流累加到该字节容器。</p>
<p data-track="44">&nbsp;</p>
<p data-track="45">二.调用子类的decode()方法进行解析</p>
<p data-track="46">把累加字节容器里的字节流通过子类的decode()方法进行解析。</p>
<p data-track="47">&nbsp;</p>
<p data-track="48">三.将解析到的ByteBuf向下传播</p>
<p data-track="49">如果调用子类的decode()方法可以解析到一个ByteBuf对象，则将这个ByteBuf对象向下传播。</p>
<pre class="highlighter-hljs"><code>public&nbsp;abstract&nbsp;class&nbsp;ByteToMessageDecoder&nbsp;extends&nbsp;ChannelInboundHandlerAdapter&nbsp;{
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;channelRead(ChannelHandlerContext ctx, Object msg)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//只基于ByteBuf对象进行解码
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(msg&nbsp;instanceof&nbsp;ByteBuf) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.累加字节流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.调用子类的decode()方法进行解析
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.清理累加字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4.将解析到的ByteBuf向下传播
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx.fireChannelRead(msg);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}</code></pre>
<p data-track="51"><strong>(2)首先累加字节流</strong></p>
<p data-track="52">如果当前字节容器中没有数据，那么就将字节容器的指针指向新读取的数据。如果当前字节容器中有数据，那么就调用累加器的cumulate()方法将数据累加到字节容器。</p>
<pre class="highlighter-hljs"><code>public&nbsp;abstract&nbsp;class&nbsp;ByteToMessageDecoder&nbsp;extends&nbsp;ChannelInboundHandlerAdapter&nbsp;{
&nbsp; &nbsp; ByteBuf cumulation;//字节容器
&nbsp; &nbsp;&nbsp;private&nbsp;Cumulator&nbsp;cumulator&nbsp;=&nbsp;MERGE_CUMULATOR;//默认的累加器
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;decodeWasNull;
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;first;
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;discardAfterReads&nbsp;=&nbsp;16;
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;numReads;
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//Cumulate ByteBufs by merge them into one ByteBuf's, using memory copies.
&nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;Cumulator&nbsp;MERGE_CUMULATOR&nbsp;=&nbsp;new&nbsp;Cumulator() {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//累加器的累加方法，会传入一个字节容器cumulation
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;ByteBuf&nbsp;cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ByteBuf buffer;//一个大的字节容器，用来copy传入的字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes() || cumulation.refCnt() &gt;&nbsp;1) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = expandCumulation(alloc, cumulation, in.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = cumulation;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.writeBytes(in);//将当前数据累加到copy的字节容器中
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.release();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;buffer;//返回copy的字节容器
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; };

&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;channelRead(ChannelHandlerContext ctx, Object msg)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(msg&nbsp;instanceof&nbsp;ByteBuf) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;CodecOutputList&nbsp;out&nbsp;=&nbsp;CodecOutputList.newInstance();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.累加字节流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;data&nbsp;=&nbsp;(ByteBuf) msg;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first = cumulation ==&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(first) {//如果当前字节容器中没有数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//就将字节容器的指针指向新读取的数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation = data;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{//如果当前字节容器中有数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//则调用累加器的cumulate()方法将数据累加到字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.将字节容器里的数据传递给业务拆包器进行拆包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//调用callDecode()方法对数据进行拆包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callDecode(ctx, cumulation, out);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(DecoderException e) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable t) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;DecoderException(t);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;finally&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.清理字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(cumulation !=&nbsp;null&nbsp;&amp;&amp; !cumulation.isReadable()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReads =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation.release();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(++ numReads &gt;= discardAfterReads) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReads =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardSomeReadBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4.将解析到的ByteBuf向下传播
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;size&nbsp;=&nbsp;out.size();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decodeWasNull = !out.insertSinceRecycled();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fireChannelRead(ctx, out, size);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.recycle();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx.fireChannelRead(msg);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;static&nbsp;ByteBuf&nbsp;expandCumulation(ByteBufAllocator alloc, ByteBuf cumulation,&nbsp;int&nbsp;readable)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;oldCumulation&nbsp;=&nbsp;cumulation;
&nbsp; &nbsp; &nbsp; &nbsp; cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);
&nbsp; &nbsp; &nbsp; &nbsp; cumulation.writeBytes(oldCumulation);
&nbsp; &nbsp; &nbsp; &nbsp; oldCumulation.release();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;cumulation;
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}</code></pre>
<p data-track="54"><strong>(3)然后调用子类的decode()方法进行解析</strong></p>
<p data-track="55">将数据累加到字节容器之后，就会调用callDecode()方法，这个方法会尝试将字节容器的数据拆分成业务数据包并将业务数据包放入业务数据容器out中。</p>
<p data-track="56">&nbsp;</p>
<p data-track="57">Netty对各种用户协议的支持就体现在ByteToMessageDecoder的抽象方法decode()中，decode()方法的入参是当前读取到的未被处理的所有数据in和业务数据包容器out，所有拆包器都需要实现ByteToMessageDecoder的decoed()方法。</p>
<p data-track="58">&nbsp;</p>
<p data-track="59">拆包器完成一次拆包后：如果没有拆到一个完整的数据包，此时若拆包器未读取任何数据则跳出循环，否则继续拆包。如果已经拆到一个完整的数据包，但此时拆包器未读取任何数据，则抛出一个异常DecodeException。</p>
<pre class="highlighter-hljs"><code>public&nbsp;abstract&nbsp;class&nbsp;ByteToMessageDecoder&nbsp;extends&nbsp;ChannelInboundHandlerAdapter&nbsp;{
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//Called once data should be decoded from the given ByteBuf.&nbsp;
&nbsp; &nbsp;&nbsp;//This method will call #decode(ChannelHandlerContext, ByteBuf, List) as long as decoding should take place.
&nbsp; &nbsp;&nbsp;//@param ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param in，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@param out，the List to which decoded messages should be added
&nbsp; &nbsp;&nbsp;protected&nbsp;void&nbsp;callDecode(ChannelHandlerContext ctx, ByteBuf&nbsp;in, List&lt;Object&gt;&nbsp;out)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;while&nbsp;(in.isReadable()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;outSize =&nbsp;out.size();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(outSize &gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fireChannelRead(ctx,&nbsp;out, outSize);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;out.clear();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Check if this handler was removed before continuing with decoding.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//If it was removed, it is not safe to continue to operate on the buffer.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(ctx.isRemoved()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outSize =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;oldInputLength =&nbsp;in.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//调用拆包器实现的decode()方法
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decode(ctx,&nbsp;in,&nbsp;out);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//拆包器完成一次拆包后：
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Check if this handler was removed before continuing the loop.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//If it was removed, it is not safe to continue to operate on the buffer.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(ctx.isRemoved()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//outSize == out.size()表示没有拆到一个完整的数据包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(outSize ==&nbsp;out.size()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(oldInputLength ==&nbsp;in.readableBytes()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//此时拆包器未读取任何数据则跳出循环
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//此时拆包器已读取到数据则继续拆包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//执行到此处表明已经拆到一个完整的数据包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(oldInputLength ==&nbsp;in.readableBytes()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//此时拆包器未读取任何数据，于是抛出一个异常DecodeException
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;DecoderException(StringUtil.simpleClassName(getClass()) +&nbsp;".decode() did not read anything but decoded a message.");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(isSingleDecode()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(DecoderException e) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable cause) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;DecoderException(cause);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;//Decode the from one ByteBuf to an other.&nbsp;
&nbsp; &nbsp;&nbsp;//This method will be called till either the input ByteBuf has nothing to read&nbsp;
&nbsp; &nbsp;&nbsp;//when return from this method or till nothing was read from the input ByteBuf.
&nbsp; &nbsp;&nbsp;//@param ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param in，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@param out，the List to which decoded messages should be added
&nbsp; &nbsp;&nbsp;//@throws Exception，is thrown if an error accour
&nbsp; &nbsp;&nbsp;protected&nbsp;abstract&nbsp;void&nbsp;decode(ChannelHandlerContext ctx, ByteBuf&nbsp;in, List&lt;Object&gt;&nbsp;out) throws Exception;
&nbsp; &nbsp; ...
}</code></pre>
<p data-track="61"><strong>(4)接着清理字节容器</strong></p>
<p data-track="62">拆包器完成拆包后，只是从字节容器中取走了数据，但这部分空间对字节容器来说还依然被保留。而字节容器每次累加字节数据时都是将字节数据追加到尾部，如果不对字节容器进行清理，那么时间一长可能就会OOM。</p>
<p data-track="63">&nbsp;</p>
<p data-track="64">正常情况下，每次读取完数据之后，ByteToMessageDecoder解码器都会在channelReadComplete()方法里清理字节容器。但是如果发送端发送数据过快，那么解码器的channelReadComplete()方法可能会很久才被调用一次。</p>
<p data-track="65">&nbsp;</p>
<p data-track="66">所以为了防止发送端发送数据过快，ByteToMessageDecoder会在读取完一次数据并完成业务拆包后，清理字节容器。如果字节容器当前已无数据可读，则调用字节容器的release()方法释放字节容器。如果字节容器当前还有数据可读，并且已经连续读取了16次还有未拆包的数据，那么就进行压缩处理。</p>
<pre class="highlighter-hljs"><code>public&nbsp;abstract&nbsp;class&nbsp;ByteToMessageDecoder&nbsp;extends&nbsp;ChannelInboundHandlerAdapter&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;discardAfterReads =&nbsp;16;
&nbsp; &nbsp; ...
&nbsp; &nbsp; @Override
&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;channelRead(ChannelHandlerContext ctx, Object msg) throws Exception&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(msg instanceof ByteBuf) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CodecOutputList&nbsp;out&nbsp;= CodecOutputList.newInstance();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1.累加字节流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ByteBuf data = (ByteBuf) msg;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first = cumulation ==&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(first) {//如果当前字节容器中没有数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//就将字节容器的指针指向新读取的数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation = data;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{//如果当前字节容器中有数据
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//则调用累加器的cumulate()方法将数据累加到字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2.将字节容器里的数据传递给业务拆包器进行拆包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//调用callDecode()方法对数据进行拆包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callDecode(ctx, cumulation,&nbsp;out);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(DecoderException e) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable t) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;DecoderException(t);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;finally&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3.清理字节容器
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(cumulation !=&nbsp;null&nbsp;&amp;&amp; !cumulation.isReadable()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果字节容器当前已无数据可读，则设置numReads为0，并释放字节容器cumulation
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReads =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation.release();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cumulation =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(++ numReads &gt;= discardAfterReads) {//numReads &gt;= 16
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果当前还有数据可读，并且已经连续读取了16次即numReads &gt;= 16，
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//此时字节容器中仍有未被业务拆包器拆包的数据，那么就做一次压缩处理；
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReads =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardSomeReadBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4.将解析到的ByteBuf向下传播
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;size =&nbsp;out.size();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decodeWasNull = !out.insertSinceRecycled();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fireChannelRead(ctx,&nbsp;out, size);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;out.recycle();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx.fireChannelRead(msg);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;//Get numElements out of the CodecOutputList and forward these through the pipeline.
&nbsp; &nbsp;&nbsp;static&nbsp;void&nbsp;fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs,&nbsp;int&nbsp;numElements)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//遍历业务数据包容器
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for(int&nbsp;i =&nbsp;0; i &lt; numElements; i ++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将一个个完整的业务数据包ByteBuf传递到后续的ChannelHandler进行处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx.fireChannelRead(msgs.getUnsafe(i));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}</code></pre>
<p data-track="68"><strong>(5)最后将解析到的ByteBuf向下传播</strong></p>
<p data-track="69">也就是调用fireChannelRead()方法，遍历业务数据包容器，将一个个完整的业务数据包ByteBuf传递到后续的ChannelHandler中进行处理。</p>
<p data-track="70">&nbsp;</p>
<p data-track="71"><strong>4.解码器抽象的解码过程总结</strong></p>
<p data-track="72">解码过程是通过一个叫ByteToMessageDecoder的抽象解码器来实现的，ByteToMessageDecoder实现的解码过程分为如下四步。</p>
<p data-track="73">&nbsp;</p>
<p data-track="74">步骤一：累加字节流</p>
<p data-track="75">也就是把当前读到的字节流累加到一个字节容器里。</p>
<p data-track="76">&nbsp;</p>
<p data-track="77">步骤二：调用子类的decode()方法进行解析</p>
<p data-track="78">ByteToMessageDecoder的decode()方法是一个抽象方法，不同种类的解码器会有自己的decode()方法逻辑。该decode()方法被调用时会传入两个关键参数：一个是ByteBuf对象表示当前累加的字节流，一个是List列表用来存放被成功解码的业务数据包。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">步骤三：清理字节容器</p>
<p data-track="81">为了防止发送端发送数据过快，ByteToMessageDecoder会在读取完一次数据并完成业务拆包后，清理字节容器。</p>
<p data-track="82">&nbsp;</p>
<p data-track="83">步骤四：传播已解码的业务数据包</p>
<p data-track="84">如果List列表里有解析出来的业务数据包，那么就通过pipeline的事件传播机制往下进行传播。</p>
<p data-track="85">&nbsp;</p>
<p data-track="86"><strong>5.Netty里常见的开箱即用的解码器</strong></p>
<p data-track="87"><strong>(1)基于固定长度解码器</strong></p>
<p data-track="88"><strong>(2)基于行分隔符解码器</strong></p>
<p data-track="89"><strong>(3)基于分隔符解码器</strong></p>
<p data-track="90"><strong>(4)基于长度域解码器</strong></p>
<p data-track="91">&nbsp;</p>
<p data-track="92"><strong>(1)基于固定长度解码器</strong></p>
<p data-track="93">判断当前字节容器可读字节是否小于固定长度。</p>
<pre class="highlighter-hljs"><code>//A decoder that splits the received ByteBufs by the fixed number of bytes.&nbsp;
//For example, if you received the following four fragmented packets:
//+---+----+------+----+
//| A | BC | DEFG | HI |
//+---+----+------+----+
//A FixedLengthFrameDecoder (3) will decode them into the following three packets with the fixed length:
//+-----+-----+-----+
//| ABC | DEF | GHI |
//+-----+-----+-----+
public&nbsp;class&nbsp;FixedLengthFrameDecoder&nbsp;extends&nbsp;ByteToMessageDecoder&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;frameLength;
&nbsp; &nbsp;&nbsp;//Creates a new instance.
&nbsp; &nbsp;&nbsp;public&nbsp;FixedLengthFrameDecoder(int&nbsp;frameLength)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &lt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("frameLength must be a positive integer: "&nbsp;+ frameLength);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.frameLength = frameLength;
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;decoded&nbsp;=&nbsp;decode(ctx, in);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(decoded !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.add(decoded);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Create a frame out of the ByteBuf and return it.
&nbsp; &nbsp;&nbsp;//@param &nbsp; ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param &nbsp; in，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@return &nbsp;frame，the ByteBuf which represent the frame or null if no frame could be created.
&nbsp; &nbsp;&nbsp;protected&nbsp;Object&nbsp;decode(@SuppressWarnings("UnusedParameters")&nbsp;ChannelHandlerContext ctx, ByteBuf in)&nbsp;throws&nbsp;Exception {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(in.readableBytes() &lt; frameLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;in.readRetainedSlice(frameLength);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</code></pre>
<p data-track="95"><strong>(2)基于行分隔符解码器</strong></p>
<p data-track="96">基于行分隔符的拆包器可以同时处理\n和\r\n两种类型的行分隔符，其处理逻辑分为非丢弃模式和丢弃模式、找到行分隔符和未找到行分隔符的情况。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>一.非丢弃模式时找到行分隔符</strong></p>
<p data-track="99">首先新建一个帧，也就是ByteBuf frame。然后计算需要解码的数据包的长度和分隔符的长度。接着判断需要拆包的长度是否大于该拆包器允许的最大长度，如果大于，则丢弃这段数据，返回null。然后将一个完整的数据包取出，如果stripDelimiter在构造方法中被设置为false，则数据包含分隔符。</p>
<p data-track="100">&nbsp;</p>
<p data-track="101"><strong>二.非丢弃模式时未找到行分隔符</strong></p>
<p data-track="102">首先取得当前字节容器的可读字节数，然后判断是否超出允许的最大长度。如果没超过最大长度，则直接返回null，字节容器的数据没有改变。如果已超过最大长度，则进入丢弃模式，设置discarding为true。</p>
<p data-track="103">&nbsp;</p>
<p data-track="104"><strong>三.丢弃模式下找到行分隔符</strong></p>
<p data-track="105">这种情况下需要将分隔符之前的数据都丢弃。在计算出分隔符的长度之后，会通过移动字节容器的readerIndex指针把分隔符之前的数据全部丢弃，当然丢弃的数据也包括分隔符。经过这么一次丢弃后，后面就有可能是正常的数据包。于是设置discarding为false进入非丢弃模式，这样下次解码数据包时就会进入正常的解码流程。</p>
<p data-track="106">&nbsp;</p>
<p data-track="107"><strong>四.丢弃模式下未找到行分隔符</strong></p>
<p data-track="108">由于当前还处于丢弃模式，没有找到行分隔符意味着当前一个完整的数据包还没丢弃完，所以当前数据继续丢弃，移动字节容器的readerIndex指针。</p>
<pre class="highlighter-hljs"><code>//A decoder that splits the received {@link ByteBuf}s on line endings.
//Both "\n" and "\r\n" are handled.
//For a more general delimiter-based decoder, see DelimiterBasedFrameDecoder.
public&nbsp;class&nbsp;LineBasedFrameDecoder&nbsp;extends&nbsp;ByteToMessageDecoder&nbsp;{
&nbsp; &nbsp;&nbsp;//Maximum length of a frame we're willing to decode.
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;maxLength;
&nbsp; &nbsp;&nbsp;//Whether or not to throw an exception as soon as we exceed maxLength.
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;boolean&nbsp;failFast;
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;boolean&nbsp;stripDelimiter;
&nbsp; &nbsp;&nbsp;//True if we're discarding input because we're already over maxLength.
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;discarding;
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;discardedBytes;

&nbsp; &nbsp;&nbsp;public&nbsp;LineBasedFrameDecoder(final&nbsp;int&nbsp;maxLength)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this(maxLength,&nbsp;true,&nbsp;false);
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;public&nbsp;LineBasedFrameDecoder(final&nbsp;int&nbsp;maxLength,&nbsp;final&nbsp;boolean&nbsp;stripDelimiter,&nbsp;final&nbsp;boolean&nbsp;failFast)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.maxLength = maxLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.failFast = failFast;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.stripDelimiter = stripDelimiter;
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;decoded&nbsp;=&nbsp;decode(ctx, in);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(decoded !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.add(decoded);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Create a frame out of the ByteBuf and return it.
&nbsp; &nbsp;&nbsp;//@param &nbsp; ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param &nbsp; buffer，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@return &nbsp;frame，the ByteBuf which represent the frame or null if no frame could be created.
&nbsp; &nbsp;&nbsp;protected&nbsp;Object&nbsp;decode(ChannelHandlerContext ctx, ByteBuf buffer)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;eol&nbsp;=&nbsp;findEndOfLine(buffer);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!discarding) {//非丢弃模式
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(eol &gt;=&nbsp;0) {//找到行分隔符
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//新建一个帧，也就是ByteBuf frame
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ByteBuf frame;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算需要解码的数据包的长度
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;length&nbsp;=&nbsp;eol - buffer.readerIndex();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算分隔符的长度
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;delimLength&nbsp;=&nbsp;buffer.getByte(eol) ==&nbsp;'\r'?&nbsp;2&nbsp;:&nbsp;1;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//判断需要拆包的长度是否大于该拆包器允许的最大长度
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(length &gt; maxLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果大于，则丢弃这段数据，返回null
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.readerIndex(eol + delimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(ctx, length);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将一个完整的数据包取出
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(stripDelimiter) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame = buffer.readRetainedSlice(length);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(delimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果stripDelimiter在构造方法中被设置为false，则数据包含分隔符
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame = buffer.readRetainedSlice(length + delimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;frame;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{//未找到行分隔符
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//首先取得当前字节容器的可读字节数
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;length&nbsp;=&nbsp;buffer.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//然后判断是否超出允许的最大长度
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(length &gt; maxLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果已超过最大长度，则进入丢弃模式，设置discarding为true
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardedBytes = length;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.readerIndex(buffer.writerIndex());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discarding =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(failFast) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(ctx,&nbsp;"over "&nbsp;+ discardedBytes);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果没超过最大长度，则直接返回null，字节容器的数据没有改变
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{//丢弃模式
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(eol &gt;=&nbsp;0) {//找到行分隔符
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;length&nbsp;=&nbsp;discardedBytes + eol - buffer.readerIndex();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算出分隔符的长度
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;delimLength&nbsp;=&nbsp;buffer.getByte(eol) ==&nbsp;'\r'?&nbsp;2&nbsp;:&nbsp;1;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//把分隔符之前的数据全部丢弃，移动字节容器的readerIndex指针
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.readerIndex(eol + delimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardedBytes =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//经过这么一次丢弃后，后面就有可能是正常的数据包
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//于是设置discarding为false，这样下次解码数据包时就会进入正常的解码流程
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discarding =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!failFast) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(ctx, length);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{//未找到行分隔符
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//当前还处于丢弃模式，没有找到行分隔符意味着当前一个完整的数据包还没丢弃完
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//所以当前数据继续丢弃，移动字节容器的readerIndex指针
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardedBytes += buffer.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.readerIndex(buffer.writerIndex());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;fail(final&nbsp;ChannelHandlerContext ctx,&nbsp;int&nbsp;length)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; fail(ctx, String.valueOf(length));
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;fail(final&nbsp;ChannelHandlerContext ctx, String length)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; ctx.fireExceptionCaught(new&nbsp;TooLongFrameException("frame length ("&nbsp;+ length +&nbsp;") exceeds the allowed maximum ("&nbsp;+ maxLength +&nbsp;')'));
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Returns the index in the buffer of the end of line found.
&nbsp; &nbsp;&nbsp;//Returns -1 if no end of line was found in the buffer.
&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;findEndOfLine(final&nbsp;ByteBuf buffer)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;buffer.forEachByte(ByteProcessor.FIND_LF);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(i &gt;&nbsp;0&nbsp;&amp;&amp; buffer.getByte(i -&nbsp;1) ==&nbsp;'\r') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i--;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;i;
&nbsp; &nbsp; }
}</code></pre>
<p data-track="110"><strong>(3)基于分隔符解码器</strong></p>
<p data-track="111">可以向基于分隔符解码器DelimiterBasedFrameDecoder传递一个分隔符列表，这样该解码器就会按照分隔符列表对数据包进行拆分。基于分隔符解码器的decode()方法和基于行分隔符解码器的decode()方法基本类似。</p>
<pre class="highlighter-hljs"><code>//A decoder that splits the received ByteBufs by one or more delimiters. &nbsp;
public&nbsp;class&nbsp;DelimiterBasedFrameDecoder&nbsp;extends&nbsp;ByteToMessageDecoder&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;ByteBuf[] delimiters;
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;maxFrameLength;
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;boolean&nbsp;stripDelimiter;
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;boolean&nbsp;failFast;
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;discardingTooLongFrame;
&nbsp; &nbsp;&nbsp;private&nbsp;int&nbsp;tooLongFrameLength;
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;LineBasedFrameDecoder lineBasedDecoder;
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//Creates a new instance.
&nbsp; &nbsp;&nbsp;//@param maxFrameLength，the maximum length of the decoded frame.
&nbsp; &nbsp;&nbsp;//A TooLongFrameException is thrown if the length of the frame exceeds this value.
&nbsp; &nbsp;&nbsp;//@param stripDelimiter，whether the decoded frame should strip out the delimiter or not
&nbsp; &nbsp;&nbsp;//@param failFast，If true, a TooLongFrameException is thrown as soon as the decoder&nbsp;
&nbsp; &nbsp;&nbsp;//notices the length of the frame will exceed maxFrameLength regardless of&nbsp;
&nbsp; &nbsp;&nbsp;//whether the entire frame has been read.
&nbsp; &nbsp;&nbsp;//If false, a TooLongFrameException is thrown after the entire frame that exceeds maxFrameLength has been read.
&nbsp; &nbsp;&nbsp;//@param delimiters &nbsp;the delimiters
&nbsp; &nbsp;&nbsp;public&nbsp;DelimiterBasedFrameDecoder(int&nbsp;maxFrameLength,&nbsp;boolean&nbsp;stripDelimiter,&nbsp;boolean&nbsp;failFast, ByteBuf... delimiters)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; validateMaxFrameLength(maxFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(delimiters ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException("delimiters");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(delimiters.length ==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("empty delimiters");
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(isLineBased(delimiters) &amp;&amp; !isSubclass()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineBasedDecoder =&nbsp;new&nbsp;LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.delimiters =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.delimiters =&nbsp;new&nbsp;ByteBuf[delimiters.length];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0; i &lt; delimiters.length; i ++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;d&nbsp;=&nbsp;delimiters[i];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validateDelimiter(d);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.delimiters[i] = d.slice(d.readerIndex(), d.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineBasedDecoder =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.maxFrameLength = maxFrameLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.stripDelimiter = stripDelimiter;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.failFast = failFast;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;//Returns true if the delimiters are "\n" and "\r\n".
&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;boolean&nbsp;isLineBased(final&nbsp;ByteBuf[] delimiters)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(delimiters.length !=&nbsp;2) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;a&nbsp;=&nbsp;delimiters[0];
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;b&nbsp;=&nbsp;delimiters[1];
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(a.capacity() &lt; b.capacity()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = delimiters[1];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = delimiters[0];
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;a.capacity() ==&nbsp;2&nbsp;&amp;&amp; b.capacity() ==&nbsp;1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; a.getByte(0) ==&nbsp;'\r'&nbsp;&amp;&amp; a.getByte(1) ==&nbsp;'\n'
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; b.getByte(0) ==&nbsp;'\n';
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Return true if the current instance is a subclass of DelimiterBasedFrameDecoder
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;isSubclass()&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getClass() != DelimiterBasedFrameDecoder.class;
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;decoded&nbsp;=&nbsp;decode(ctx, in);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(decoded !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.add(decoded);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Create a frame out of the {@link ByteBuf} and return it.
&nbsp; &nbsp;&nbsp;//@param &nbsp; ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param &nbsp; buffer，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@return &nbsp;frame，the ByteBuf which represent the frame or null if no frame could be created.
&nbsp; &nbsp;&nbsp;protected&nbsp;Object&nbsp;decode(ChannelHandlerContext ctx, ByteBuf buffer)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(lineBasedDecoder !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;lineBasedDecoder.decode(ctx, buffer);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Try all delimiters and choose the delimiter which yields the shortest frame.
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;minFrameLength&nbsp;=&nbsp;Integer.MAX_VALUE;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;minDelim&nbsp;=&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(ByteBuf delim: delimiters) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;frameLength&nbsp;=&nbsp;indexOf(buffer, delim);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &gt;=&nbsp;0&nbsp;&amp;&amp; frameLength &lt; minFrameLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minFrameLength = frameLength;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minDelim = delim;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(minDelim !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;minDelimLength&nbsp;=&nbsp;minDelim.capacity();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ByteBuf frame;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(discardingTooLongFrame) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//We've just finished discarding a very large frame.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Go back to the initial state.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardingTooLongFrame =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(minFrameLength + minDelimLength);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;tooLongFrameLength&nbsp;=&nbsp;this.tooLongFrameLength;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.tooLongFrameLength =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!failFast) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(tooLongFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(minFrameLength &gt; maxFrameLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Discard read frame.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(minFrameLength + minDelimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(minFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(stripDelimiter) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame = buffer.readRetainedSlice(minFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(minDelimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;frame;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!discardingTooLongFrame) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(buffer.readableBytes() &gt; maxFrameLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Discard the content of the buffer until a delimiter is found.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tooLongFrameLength = buffer.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(buffer.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardingTooLongFrame =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(failFast) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(tooLongFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Still discarding the buffer since a delimiter is not found.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tooLongFrameLength += buffer.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer.skipBytes(buffer.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;fail(long&nbsp;frameLength)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;TooLongFrameException("frame length exceeds "&nbsp;+ maxFrameLength +&nbsp;": "&nbsp;+ frameLength +&nbsp;" - discarded");
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;TooLongFrameException("frame length exceeds "&nbsp;+ maxFrameLength +&nbsp;" - discarding");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Returns the number of bytes between the readerIndex of the haystack and the first needle found in the haystack. &nbsp;
&nbsp; &nbsp;&nbsp;//-1 is returned if no needle is found in the haystack.
&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;indexOf(ByteBuf haystack, ByteBuf needle)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;haystack.readerIndex(); i &lt; haystack.writerIndex(); i ++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;haystackIndex&nbsp;=&nbsp;i;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;needleIndex;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(needleIndex =&nbsp;0; needleIndex &lt; needle.capacity(); needleIndex ++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(haystack.getByte(haystackIndex) != needle.getByte(needleIndex)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haystackIndex ++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(haystackIndex == haystack.writerIndex() &amp;&amp; needleIndex != needle.capacity() -&nbsp;1) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;-1;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(needleIndex == needle.capacity()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Found the needle from the haystack!
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;i - haystack.readerIndex();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;-1;
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;validateDelimiter(ByteBuf delimiter)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(delimiter ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException("delimiter");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!delimiter.isReadable()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("empty delimiter");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;validateMaxFrameLength(int&nbsp;maxFrameLength)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(maxFrameLength &lt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("maxFrameLength must be a positive integer: "&nbsp;+ maxFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}</code></pre>
<p data-track="113"><strong>(4)基于长度域解码器</strong></p>
<p data-track="114">主要的逻辑步骤如下：</p>
<p data-track="115">一.丢弃模式的处理</p>
<p data-track="116">二.获取待拆数据包的大小</p>
<p data-track="117">三.对数据包进行长度校验</p>
<p data-track="118">四.跳过指定字节长度</p>
<p data-track="119">五.抽取数据包</p>
<pre class="highlighter-hljs"><code>public&nbsp;class&nbsp;LengthFieldBasedFrameDecoder&nbsp;extends&nbsp;ByteToMessageDecoder&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;ByteOrder byteOrder;//表示字节流表示的数据是大端还是小端，用于长度域的读取
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;maxFrameLength;//表示数据包的最大长度
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;lengthFieldOffset;//表示长度域的偏移量
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;lengthFieldLength;//表示长度域的长度
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;lengthFieldEndOffset;//表示紧跟长度域字段后面的第一字节在整个数据包中的偏移量
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;lengthAdjustment;//表示数据包体长度调整大小，长度域只表示数据包体的长度
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;initialBytesToStrip;//表示拿到完整的数据包之后，向业务解码器传递之前，应该跳过多少字节
&nbsp; &nbsp;&nbsp;private&nbsp;final&nbsp;boolean&nbsp;failFast;//默认为true，否则可能会OOM
&nbsp; &nbsp;&nbsp;private&nbsp;boolean&nbsp;discardingTooLongFrame;
&nbsp; &nbsp;&nbsp;private&nbsp;long&nbsp;tooLongFrameLength;
&nbsp; &nbsp;&nbsp;private&nbsp;long&nbsp;bytesToDiscard;
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//Creates a new instance.
&nbsp; &nbsp;&nbsp;//@param byteOrder，the ByteOrder of the length field
&nbsp; &nbsp;&nbsp;//@param maxFrameLength，the maximum length of the frame. &nbsp;
&nbsp; &nbsp;&nbsp;//If the length of the frame is greater than this value, TooLongFrameException will be thrown.
&nbsp; &nbsp;&nbsp;//@param lengthFieldOffset，the offset of the length field
&nbsp; &nbsp;&nbsp;//@param lengthFieldLength，the length of the length field
&nbsp; &nbsp;&nbsp;//@param lengthAdjustment，the compensation value to add to the value of the length field
&nbsp; &nbsp;&nbsp;//@param initialBytesToStrip，the number of first bytes to strip out from the decoded frame
&nbsp; &nbsp;&nbsp;//@param failFast，If true, a TooLongFrameException is thrown as soon as the decoder notices the length of the frame&nbsp;
&nbsp; &nbsp;&nbsp;//will exceed maxFrameLength regardless of whether the entire frame has been read.
&nbsp; &nbsp;&nbsp;//If false, a TooLongFrameException is thrown after the entire frame that exceeds maxFrameLength has been read.
&nbsp; &nbsp;&nbsp;public&nbsp;LengthFieldBasedFrameDecoder(ByteOrder byteOrder,&nbsp;int&nbsp;maxFrameLength,&nbsp;int&nbsp;lengthFieldOffset,&nbsp;int&nbsp;lengthFieldLength,&nbsp;int&nbsp;lengthAdjustment,&nbsp;int&nbsp;initialBytesToStrip,&nbsp;boolean&nbsp;failFast)&nbsp;{&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.byteOrder = byteOrder;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.maxFrameLength = maxFrameLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.lengthFieldOffset = lengthFieldOffset;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.lengthFieldLength = lengthFieldLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.lengthAdjustment = lengthAdjustment;
&nbsp; &nbsp; &nbsp; &nbsp; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.initialBytesToStrip = initialBytesToStrip;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.failFast = failFast;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;@Override
&nbsp; &nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;decoded&nbsp;=&nbsp;decode(ctx, in);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(decoded !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out.add(decoded);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;//Create a frame out of the {@link ByteBuf} and return it.
&nbsp; &nbsp;&nbsp;//@param &nbsp; ctx，the ChannelHandlerContext which this ByteToMessageDecoder belongs to
&nbsp; &nbsp;&nbsp;//@param &nbsp; in，the ByteBuf from which to read data
&nbsp; &nbsp;&nbsp;//@return &nbsp;frame，the ByteBuf which represent the frame or null if no frame could be created.
&nbsp; &nbsp;&nbsp;protected&nbsp;Object&nbsp;decode(ChannelHandlerContext ctx, ByteBuf in)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤一开始：丢弃模式的处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(discardingTooLongFrame) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果当前处于丢弃模式，则先计算需要丢弃多少字节，取当前还需可丢弃字节和可读字节的最小值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;bytesToDiscard&nbsp;=&nbsp;this.bytesToDiscard;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;localBytesToDiscard&nbsp;=&nbsp;(int) Math.min(bytesToDiscard, in.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(localBytesToDiscard);//进行丢弃
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytesToDiscard -= localBytesToDiscard;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.bytesToDiscard = bytesToDiscard;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failIfNecessary(false);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤一结束
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤二开始：获取待拆数据包的大小
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果当前可读字节还没达到长度域的偏移，说明肯定是读不到长度域的，则直接不读
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(in.readableBytes() &lt; lengthFieldEndOffset) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算长度域的实际字节偏移
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;actualLengthFieldOffset&nbsp;=&nbsp;in.readerIndex() + lengthFieldOffset;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//拿到实际的未调整过的数据包长度
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;frameLength&nbsp;=&nbsp;getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果拿到的长度为负数，则直接跳过长度域并抛出异常
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &lt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(lengthFieldEndOffset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;CorruptedFrameException("negative pre-adjustment length field: "&nbsp;+ frameLength);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//调整数据包的长度，后面统一做拆分
&nbsp; &nbsp; &nbsp; &nbsp; frameLength += lengthAdjustment + lengthFieldEndOffset;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤二结束
&nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤三开始：对数据包进行长度校验
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//整个数据包的长度还没有长度域长，则直接抛出异常
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &lt; lengthFieldEndOffset) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(lengthFieldEndOffset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;CorruptedFrameException("Adjusted frame length ("&nbsp;+ frameLength +&nbsp;") is less "&nbsp;+&nbsp;"than lengthFieldEndOffset: "&nbsp;+ lengthFieldEndOffset);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//数据包长度超出最大数据包长度，进入丢弃模式
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &gt; maxFrameLength) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;discard&nbsp;=&nbsp;frameLength - in.readableBytes();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tooLongFrameLength = frameLength;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(discard &lt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//当前可读字节已达到frameLength，直接跳过frameLength字节
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//丢弃之后，后面又可能就是一个合法的数据包了
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes((int) frameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//当前可读字节未达到frameLength，说明后面未读到的字节也需要丢弃，进入丢弃模式，先把当前累积的字节全部丢弃
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardingTooLongFrame =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//bytesToDiscard表示还需要丢弃多少字节
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytesToDiscard = discard;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(in.readableBytes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//调用failIfNecessary判断是否需要抛出异常
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failIfNecessary(true);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤三结束
&nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤四开始：跳过指定字节长度
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//never overflows because it's less than maxFrameLength
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;frameLengthInt&nbsp;=&nbsp;(int) frameLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(in.readableBytes() &lt; frameLengthInt) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果可读字节还是小于数据包的长度，则返回，下次继续读取
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(initialBytesToStrip &gt; frameLengthInt) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果跳过的字节大于数据包的长度，则抛异常
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(frameLengthInt);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;CorruptedFrameException("Adjusted frame length ("&nbsp;+ frameLength +&nbsp;") is less "&nbsp;+&nbsp;"than initialBytesToStrip: "&nbsp;+ initialBytesToStrip);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; in.skipBytes(initialBytesToStrip);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤四结束
&nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//步骤五开始：抽取数据包
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//拿到当前累积数据的读指针
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;readerIndex&nbsp;=&nbsp;in.readerIndex();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//拿到待抽取数据包的实际长度进行抽取
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;actualFrameLength&nbsp;=&nbsp;frameLengthInt - initialBytesToStrip;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//进行抽取数据
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ByteBuf&nbsp;frame&nbsp;=&nbsp;extractFrame(ctx, in, readerIndex, actualFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//移动读指针
&nbsp; &nbsp; &nbsp; &nbsp; in.readerIndex(readerIndex + actualFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;frame;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;protected&nbsp;ByteBuf&nbsp;extractFrame(ChannelHandlerContext ctx, ByteBuf buffer,&nbsp;int&nbsp;index,&nbsp;int&nbsp;length)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;buffer.retainedSlice(index, length);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;//拿到实际的未调整过的数据包长度
&nbsp; &nbsp;&nbsp;//如果长度域代表的值表达的含义不是正常的int、short等类型，则可以重写这个方法
&nbsp; &nbsp;&nbsp;//比如有的长度域虽然是4字节，比如0x1234，但是它的含义是十进制的，即长度就是十进制的1234
&nbsp; &nbsp;&nbsp;protected&nbsp;long&nbsp;getUnadjustedFrameLength(ByteBuf buf,&nbsp;int&nbsp;offset,&nbsp;int&nbsp;length, ByteOrder order)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; buf = buf.order(order);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;frameLength;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;switch&nbsp;(length) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;case&nbsp;1:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameLength = buf.getUnsignedByte(offset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;case&nbsp;2:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameLength = buf.getUnsignedShort(offset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;case&nbsp;3:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameLength = buf.getUnsignedMedium(offset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;case&nbsp;4:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameLength = buf.getUnsignedInt(offset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;case&nbsp;8:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameLength = buf.getLong(offset);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;default:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;DecoderException("unsupported lengthFieldLength: "&nbsp;+ lengthFieldLength +&nbsp;" (expected: 1, 2, 3, 4, or 8)");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;frameLength;
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;failIfNecessary(boolean&nbsp;firstDetectionOfTooLongFrame)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//不需要再丢弃后面的未读字节，就开始重置丢弃状态
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(bytesToDiscard ==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//Reset to the initial state and tell the handlers that the frame was too large.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;tooLongFrameLength&nbsp;=&nbsp;this.tooLongFrameLength;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.tooLongFrameLength =&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; discardingTooLongFrame =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，则抛出异常，让Handler处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!failFast || failFast &amp;&amp; firstDetectionOfTooLongFrame) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(tooLongFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如果设置了快速失败，并且是第一次检测到打包错误，则抛出异常，让Handler处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(failFast &amp;&amp; firstDetectionOfTooLongFrame) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail(tooLongFrameLength);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;protected&nbsp;ByteBuf&nbsp;extractFrame(ChannelHandlerContext ctx, ByteBuf buffer,&nbsp;int&nbsp;index,&nbsp;int&nbsp;length)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;buffer.retainedSlice(index, length);
&nbsp; &nbsp; }

&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;fail(long&nbsp;frameLength)&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(frameLength &gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;TooLongFrameException("Adjusted frame length exceeds "&nbsp;+ maxFrameLength +&nbsp;": "&nbsp;+ frameLength +&nbsp;" - discarded");
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;TooLongFrameException("Adjusted frame length exceeds "&nbsp;+ maxFrameLength +&nbsp;" - discarding");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ...
}</code></pre>
<p>&nbsp;</p>
<p data-track="120" data-pm-slice="1 1 []"><strong>6.writeAndFlush()方法的大体步骤</strong></p>
<p data-track="121"><strong>(1)writeAndFlush()方法的调用入口</strong></p>
<p data-track="122"><strong>(2)writeAndFlush()方法的执行流程</strong></p>
<p data-track="123">&nbsp;</p>
<p data-track="124"><strong>(1)writeAndFlush()方法的调用入口</strong></p>
<p data-track="125">入口通常是：ctx.channel().writeAndFlush()。</p>
<pre class="highlighter-hljs"><code>public class NettyServerHandler extends ChannelInboundHandlerAdapter {
    //网络连接tcp三次握手后，就会建立和封装一个Channel(网络连接的通信管道)
    //此时这个Channel就可以实现一个激活
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Channel Active......");
        ctx.channel().writeAndFlush("test5");
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println("Channel Read: " + (String)msg);
        String response = "Hello World......";
        ByteBuf responseByteBuf = Unpooled.buffer();
        responseByteBuf.writeBytes(response.getBytes());

        ctx.channel().writeAndFlush(responseByteBuf);
        System.out.println("Channel Write: " + response);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Channel Read Complete......");
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}</code></pre>
<p data-track="127"><strong>(2)writeAndFlush()方法的执行流程</strong></p>
<p data-track="128">首先从tail结点开始往前传播。然后逐个调用ChannelHandler的write()方法，直到某个ChannelHandler不再往前传播write事件。接着逐个调用ChannelHandler的flush()方法，直到某个ChannelHandler不再往前传播flush事件。</p>
<p data-track="129">&nbsp;</p>
<p data-track="130">一般而言，只要每个ChannelHandler都往下传播write事件和flush事件，那么最后都会传播到HeadContext结点的write()方法和flush()方法，然后分别执行unsafe.write()和unsafe.flush()将数据通过底层的unsafe写到JDK底层的Channel。</p>
<pre class="highlighter-hljs"><code>public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    private final DefaultChannelPipeline pipeline;
    ...
    @Override
    public ChannelFuture writeAndFlush(Object msg) {
        return pipeline.writeAndFlush(msg);
    }
    ...
}

public class DefaultChannelPipeline implements ChannelPipeline {
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    private final Channel channel;
    
    protected DefaultChannelPipeline(Channel channel) {
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        tail = new TailContext(this);
        head = new HeadContext(this);
        head.next = tail;
        tail.prev = head;
    }
    
    @Override
    public final ChannelFuture writeAndFlush(Object msg) {
        //从TailContext开始传播
        //但TailContext没有重写writeAndFlush()方法
        //所以会调用AbstractChannelHandlerContext的writeAndFlush()方法
        return tail.writeAndFlush(msg);
    }
    ...
}

abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {
    volatile AbstractChannelHandlerContext next;
    volatile AbstractChannelHandlerContext prev;
    ...
    @Override
    public ChannelFuture writeAndFlush(Object msg) {
        return writeAndFlush(msg, newPromise());
    }
    
    @Override
    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
        if (msg == null) throw new NullPointerException("msg");
        if (!validatePromise(promise, true)) {
            ReferenceCountUtil.release(msg);
            return promise;
        }
        write(msg, true, promise);
        return promise;
    }
    
    private void write(Object msg, boolean flush, ChannelPromise promise) {
        //反向遍历链表进行查找
        AbstractChannelHandlerContext next = findContextOutbound();
        final Object m = pipeline.touch(msg, next);
        EventExecutor executor = next.executor();
        //最终都会由Reactor线程处理Channel的数据读写
        if (executor.inEventLoop()) {
            if (flush) {
                //调用结点的invokeWriteAndFlush()方法
                next.invokeWriteAndFlush(m, promise);
            } else {
                next.invokeWrite(m, promise);
            }
        } else {
            AbstractWriteTask task;
            if (flush) {
                task = WriteAndFlushTask.newInstance(next, m, promise);
            }  else {
                task = WriteTask.newInstance(next, m, promise);
            }
            safeExecute(executor, task, promise, m);
        }
    }
    
    private void invokeWriteAndFlush(Object msg, ChannelPromise promise) {
        if (invokeHandler()) {
            //逐个调用ChannelHandler结点的write()方法，但前提是当前ChannelHandler可以往下传
            //即write()方法在最后也像ChannelOutboundHandlerAdapter那样，调用了ctx.write()往下传播
            invokeWrite0(msg, promise);
            //逐个调用ChannelHandler结点的flush()方法，但前提是当前ChannelHandler可以往下传
            //即flush()方法在最后也像ChannelOutboundHandlerAdapter那样，调用了ctx.flush()往下传播
            invokeFlush0();
        } else {
            writeAndFlush(msg, promise);
        }
    }
    
    private void invokeWrite0(Object msg, ChannelPromise promise) {
        try {
            //逐个调用，最终回到HeadContext的write()方法
            ((ChannelOutboundHandler) handler()).write(this, msg, promise);
        } catch (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
    
    private void invokeFlush0() {
        try {
            //逐个调用，最终回到HeadContext的flush()方法
            ((ChannelOutboundHandler) handler()).flush(this);
        } catch (Throwable t) {
            notifyHandlerException(t);
        }
    }
    ...
}

public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }

        @Override
        public void flush(ChannelHandlerContext ctx) throws Exception {
            unsafe.flush();
        }
    }
    ...
}

//Skeleton implementation of a ChannelOutboundHandler. This implementation just forwards each method call via the ChannelHandlerContext.
public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
    //Calls ChannelHandlerContext#bind(SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.bind(localAddress, promise);
    }

    //Calls ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline. 
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.connect(remoteAddress, localAddress, promise);
    }

    //Calls ChannelHandlerContext#disconnect(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.disconnect(promise);
    }

    //Calls ChannelHandlerContext#close(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.close(promise);
    }

    //Calls ChannelHandlerContext#deregister(ChannelPromise) to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.deregister(promise);
    }

    //Calls ChannelHandlerContext#read() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void read(ChannelHandlerContext ctx) throws Exception {
        ctx.read();
    }

    //Calls ChannelHandlerContext#write(Object, ChannelPromise)} to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ctx.write(msg, promise);
    }

    //Calls ChannelHandlerContext#flush() to forward to the next ChannelOutboundHandler in the ChannelPipeline.
    @Override
    public void flush(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}</code></pre>
<p data-track="132">&nbsp;</p>
<p data-track="133"><strong>7.MessageToByteEncoder的编码步骤</strong></p>
<p data-track="134"><strong>(1)编码的具体步骤</strong></p>
<p data-track="135"><strong>(2)编码步骤的总结</strong></p>
<p data-track="136"><strong>(3)子类实现编码的例子</strong></p>
<p data-track="137">&nbsp;</p>
<p data-track="138"><strong>(1)编码的具体步骤</strong></p>
<p data-track="139"><strong>步骤一：判断对象</strong></p>
<p data-track="140">判断当前ChannelHandler结点能否处理写入传入的Java对象。如果能处理，则往下执行，否则直接传递给下一个ChannelHandler结点进行处理。</p>
<p data-track="141">&nbsp;</p>
<p data-track="142"><strong>步骤二：分配内存</strong></p>
<p data-track="143">给新创建的ByteBuf对象分配一块内存空间，这块内存空间将会存放由Java对象转换来的字节数据。</p>
<p data-track="144">&nbsp;</p>
<p data-track="145"><strong>步骤三：调用encode</strong></p>
<p data-track="146">子类会实现MessageToByteEncoder的抽象方法encode()来定义自己的编码协议，子类的encode()方法会将Java对象转换来的字节数据写入ByteBuf。</p>
<p data-track="147">&nbsp;</p>
<p data-track="148"><strong>步骤四：释放对象</strong></p>
<p data-track="149">由于传入的Java对象已经转换成ByteBuf字节流了，所以传入的Java对象已不再使用可进行释放。</p>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>步骤五：传播数据</strong></p>
<p data-track="152">当子类的encode()方法将数据写入了ByteBuf对象以及释放完对象之后，则会往前一个ChannelHandler结点传播该ByteBuf对象，否则往前一个ChannelHandler结点传播空对象。</p>
<p data-track="153">&nbsp;</p>
<p data-track="154"><strong>步骤六：释放内存</strong></p>
<p data-track="155">如果出现异常或者ByteBuf没有写入数据或者ByteBuf在pipeline中已处理完，则释放分配给ByteBuf对象的内存。</p>
<pre class="highlighter-hljs"><code>//ChannelOutboundHandlerAdapter which encodes message in a stream-like fashion from one message to an ByteBuf.
//Example implementation which encodes Integers to a ByteBuf.
//public class IntegerEncoder extends MessageToByteEncoder&lt;Integer&gt; {
//    @code @Override
//    public void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception {
//        out.writeInt(msg);
//    }
//}
public abstract class MessageToByteEncoder&lt;I&gt; extends ChannelOutboundHandlerAdapter {
    private final TypeParameterMatcher matcher;
    private final boolean preferDirect;

    protected MessageToByteEncoder() {
        this(true);
    }
    
    protected MessageToByteEncoder(Class&lt;? extends I&gt; outboundMessageType) {
        this(outboundMessageType, true);
    }

    //Create a new instance which will try to detect the types to match out of the type parameter of the class.
    //@param preferDirect，true if a direct ByteBuf should be tried to be used as target for the encoded messages. 
    //If false is used it will allocate a heap ByteBuf, which is backed by an byte array.
    protected MessageToByteEncoder(boolean preferDirect) {
        matcher = TypeParameterMatcher.find(this, MessageToByteEncoder.class, "I");
        this.preferDirect = preferDirect;
    }

    //Create a new instance
    //@param outboundMessageType，The tpye of messages to match
    //@param preferDirect，true if a direct ByteBuf should be tried to be used as target for the encoded messages. 
    //If false is used it will allocate a heap ByteBuf, which is backed by an byte array.
    protected MessageToByteEncoder(Class&lt;? extends I&gt; outboundMessageType, boolean preferDirect) {
        matcher = TypeParameterMatcher.get(outboundMessageType);
        this.preferDirect = preferDirect;
    }

    //Returns true if the given message should be handled. 
    //If false it will be passed to the next ChannelOutboundHandler in the ChannelPipeline.
    public boolean acceptOutboundMessage(Object msg) throws Exception {
        return matcher.match(msg);
    }

    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ByteBuf buf = null;
        try {
            //步骤一：判断当前ChannelHandler能否处理写入的消息
            if (acceptOutboundMessage(msg)) {
                @SuppressWarnings("unchecked")
                I cast = (I) msg;//强制转换
                //步骤二：给ByteBuf对象分配内存
                buf = allocateBuffer(ctx, cast, preferDirect);
                try {
                    //步骤三：调用子类实现的encode()方法
                    encode(ctx, cast, buf);
                } finally {
                    //步骤四：释放对象
                    //既然自定义的Java对象msg已经转换为ByteBuf对象了，那么该对象已经没有用，需要释放掉了
                    //注意：当传入的msg的类型是ByteBuf类型时，则不需要释放
                    ReferenceCountUtil.release(cast);
                }
                //步骤五：如果buf中写入了数据，就把buf传到下一个ChannelHandler结点
                if (buf.isReadable()) {
                    ctx.write(buf, promise);
                } else {
                    //步骤六：如果buf中没有写入数据，则释放buf，并将一个空数据传到下一个ChannelHandler结点
                    buf.release();
                    ctx.write(Unpooled.EMPTY_BUFFER, promise);
                }
                buf = null;
            } else {
                ctx.write(msg, promise);
            }
        } catch (EncoderException e) {
            throw e;
        } catch (Throwable e) {
            throw new EncoderException(e);
        } finally {
            if (buf != null) {
                buf.release();//当buf在pipeline中处理完了，需要进行释放
            }
        }
    }

    //Allocate a ByteBuf which will be used as argument of #encode(ChannelHandlerContext, I, ByteBuf).
    //Sub-classes may override this method to returna ByteBuf with a perfect matching initialCapacity.
    protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg, boolean preferDirect) throws Exception { 
        if (preferDirect) {
            return ctx.alloc().ioBuffer();
        } else {
            return ctx.alloc().heapBuffer();
        }
    }

    //Encode a message into a ByteBuf. 
    //This method will be called for each written message that can be handled by this encoder.
    //@param ctx，the ChannelHandlerContext which this MessageToByteEncoder belongs to
    //@param msg，the message to encode
    //@param out，the ByteBuf into which the encoded message will be written
    //@throws Exception，is thrown if an error accour
    protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;
}</code></pre>
<p data-track="157"><strong>(2)编码步骤的总结</strong></p>
<p data-track="158">在MessageToByteEncoder的编码过程中，首先会判断当前ChannelHandler能否处理传入的Java对象，如果能处理就对新创建的ByteBuf对象分配一块内存空间。然后由子类的encode()方法实现具体的编码协议，并且把编码后的数据存放到分配给ByteBuf对象的内存空间中。最后把ByteBuf对象往前一个ChannelHandler结点进行传播。</p>
<p data-track="159">&nbsp;</p>
<p data-track="160">如果在编码的过程中出现异常，那么就把已申请出来的、分配给ByteBuf对象的内存空间进行释放。</p>
<p data-track="161">&nbsp;</p>
<p data-track="162">如果传入的Java对象就是一个ByteBuf对象，那么Netty在自定义编码结束后，会自动帮忙释放该对象，不需要在子类中对该对象进行释放。</p>
<p data-track="163">&nbsp;</p>
<p data-track="164"><strong>(3)子类实现编码的例子</strong></p>
<p data-track="165">下面的Encoder便实现了将自定义的Response对象转换为字节流并写到Socket底层的效果。</p>
<pre class="highlighter-hljs"><code>public class Encoder extends MessageToByteEncoder&lt;Response&gt; {
    protected void encode(ChannelHandlerContext ctx, Response response, ByteBuf out) throws Exception {
        out.writeByte(response.getVersion());
        out.writeInt(4+ response.getData().length);
        out.writeBytes(response.getData());    
    }
}</code></pre>
<p data-track="167">&nbsp;</p>
<p data-track="168"><strong>8.unsafe.write()将数据添加到写缓冲区</strong></p>
<p data-track="169"><strong>(1)unsafe.write()的入口</strong></p>
<p data-track="170"><strong>(2)unsafe.write()的主要逻辑</strong></p>
<p data-track="171"><strong>(3)写缓冲区(写队列)的数据结构</strong></p>
<p data-track="172">&nbsp;</p>
<p data-track="173"><strong>(1)unsafe.write()的入口</strong></p>
<p data-track="174">不管是ctx.channel().write()还是ctx.write()，最终都会来到pipeline中的head结点。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }

        @Override
        public void flush(ChannelHandlerContext ctx) throws Exception {
            unsafe.flush();
        }
    }
    ...
}</code></pre>
<p data-track="176"><strong>(2)unsafe.write()的主要逻辑</strong></p>
<p data-track="177">unsafe.write()方法将数据添加到写缓冲区(写队列)的主要逻辑如下。</p>
<p data-track="178">&nbsp;</p>
<p data-track="179"><strong>一.Direct化ByteBuf对象</strong></p>
<p data-track="180">如果传进来的ByteBuf对象不是堆外内存，那么就直接转换成堆外内存，并且估算出其大小。</p>
<p data-track="181">&nbsp;</p>
<p data-track="182"><strong>二.添加到写缓冲区</strong></p>
<p data-track="183">转换成堆外内存的ByteBuf对象首先会被封装成一个Entry对象，然后再将该Entry对象添加到写缓冲区，其中会通过几个指针来标识写缓冲区的状态。</p>
<p data-track="184">&nbsp;</p>
<p data-track="185"><strong>三.设置写状态</strong></p>
<p data-track="186">如果内存不足，那么是不可以一直往写缓冲区里添加ByteBuf对象的。如果写缓冲区已经大于默认的64KB的大小，则会通过自旋 + CAS设置当前Channel为不可写状态。</p>
<pre class="highlighter-hljs"><code>public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    private final DefaultChannelPipeline pipeline;
    ...
    protected abstract class AbstractUnsafe implements Unsafe {
        //写缓冲区(写队列)
        private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);
        ...
        @Override
        public final void write(Object msg, ChannelPromise promise) {
            //确保该方法的调用是在Reactor线程中
            assertEventLoop();
            //写缓冲区
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            ...
            int size;
            try {
                //转换成堆外内存
                msg = filterOutboundMessage(msg);
                //估算出需要写入的ByteBuf的size
                size = pipeline.estimatorHandle().size(msg);
                if (size &lt; 0) {
                    size = 0;
                }
            } catch (Throwable t) {
                safeSetFailure(promise, t);
                ReferenceCountUtil.release(msg);
                return;
            }
            //将转换成堆外内存的msg添加到写缓冲区outboundBuffer
            outboundBuffer.addMessage(msg, size, promise);
        }
        ...
    }    
    ...
}

public abstract class AbstractNioByteChannel extends AbstractNioChannel {
    ...
    @Override
    protected final Object filterOutboundMessage(Object msg) {
        if (msg instanceof ByteBuf) {
            ByteBuf buf = (ByteBuf) msg;
            if (buf.isDirect()) {
                return msg;
            }
            return newDirectBuffer(buf);
        }
        if (msg instanceof FileRegion) {
            return msg;
        }
        throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(msg) + EXPECTED_TYPES); 
    }
    ...
}</code></pre>
<p data-track="188"><strong>(3)写缓冲区(写队列)的数据结构</strong></p>
<p data-track="189">ChannelOutboundBuffer里的数据结构是一个单向链表，单向链表的每个结点都是一个Entry对象。在一个Entry对象中会包含着待写出的ByteBuf对象及消息回调promise。flushedEntry指针表示第一个被写入Socket缓冲区的结点，unflushedEntry指针表示第一个未被写入Socket缓冲区的结点，tailEntry指针表示ChannelOutboundBuffer缓冲区的最后一个结点。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191">初次调用ChannelOutboundBuffer的addMessage()方法后，flushedEntry指针指向NULL，unflushedEntry指针和tailEntry指针都指向新添加的结点。调用多次ChannelOutboundBuffer的addMessage()方法后，如果flushedEntry指针一直指向NULL，则表示现在还没有结点的ByteBuf对象写出到Socket缓冲区。如果unflushedEntry指针之后有n个结点，则表示当前还有n个结点的ByteBuf对象还没写出到Socket缓冲区。</p>
<pre class="highlighter-hljs"><code>public final class ChannelOutboundBuffer {
    private final Channel channel;
    
    //Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)
    //The Entry that is the first in the linked-list structure that was flushed
    private Entry flushedEntry;
    //The Entry which is the first unflushed in the linked-list structure
    private Entry unflushedEntry;
    //The Entry which represents the tail of the buffer
    private Entry tailEntry;
    ...
    
    ChannelOutboundBuffer(AbstractChannel channel) {
        this.channel = channel;
    }

    //Add given message to this ChannelOutboundBuffer. 
    //The given {@link ChannelPromise} will be notified once the message was written.
    public void addMessage(Object msg, int size, ChannelPromise promise) {
        Entry entry = Entry.newInstance(msg, size, total(msg), promise);
        if (tailEntry == null) {
            flushedEntry = null;
            tailEntry = entry;
        } else {
            Entry tail = tailEntry;
            tail.next = entry;
            tailEntry = entry;
        }
        if (unflushedEntry == null) {
            unflushedEntry = entry;
        }

        //increment pending bytes after adding message to the unflushed arrays.
        incrementPendingOutboundBytes(size, false);
    }
    
    static final class Entry {
        private static final Recycler&lt;Entry&gt; RECYCLER = new Recycler&lt;Entry&gt;() {
            @Override
            protected Entry newObject(Handle handle) {
                return new Entry(handle);
            }
        };
        private final Handle&lt;Entry&gt; handle;
        Entry next;
        Object msg;
        ByteBuffer[] bufs;
        ByteBuffer buf;
        ChannelPromise promise;
        long progress;
        long total;
        int pendingSize;
        int count = -1;
        boolean cancelled;
  
        private Entry(Handle&lt;Entry&gt; handle) {
            this.handle = handle;
        }

        static Entry newInstance(Object msg, int size, long total, ChannelPromise promise) {
            Entry entry = RECYCLER.get();
            entry.msg = msg;
            entry.pendingSize = size;
            entry.total = total;
            entry.promise = promise;
            return entry;
        }
        ...
    }
}</code></pre>
<p data-track="193">&nbsp;</p>
<p data-track="194"><strong>9.unsafe.flush()刷新写缓冲区的数据</strong></p>
<p data-track="195"><strong>(1)unsafe.flush()的入口</strong></p>
<p data-track="196"><strong>(2)unsafe.flush()的主要逻辑</strong></p>
<p data-track="197">&nbsp;</p>
<p data-track="198"><strong>(1)unsafe.flush()的入口</strong></p>
<p data-track="199">不管是ctx.channel().flush()还是ctx.flush()，最终都会来到pipeline中的head结点。</p>
<pre class="highlighter-hljs"><code>public class DefaultChannelPipeline implements ChannelPipeline {
    ...
    final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
        private final Unsafe unsafe;
        HeadContext(DefaultChannelPipeline pipeline) {
            super(pipeline, null, HEAD_NAME, false, true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
        ...
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }

        @Override
        public void flush(ChannelHandlerContext ctx) throws Exception {
            unsafe.flush();
        }
    }
    ...
}</code></pre>
<p data-track="201"><strong>(2)unsafe.flush()的主要逻辑</strong></p>
<p data-track="202"><strong>步骤一：</strong>设置flushedEntry指针指向unflushedEntry指针所指向的Entry结点，并统计需要刷新的Entry结点的数量。</p>
<p data-track="203">&nbsp;</p>
<p data-track="204"><strong>步骤二：</strong>遍历写缓冲区的Entry结点把对应的ByteBuf对象写到Socket，然后移除Entry结点。如果写缓冲区大小已经小于32KB，则通过自旋 + CAS设置Channel为可写状态。</p>
<pre class="highlighter-hljs"><code>public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    private final DefaultChannelPipeline pipeline;
    ...
    protected abstract class AbstractUnsafe implements Unsafe {
        private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this); 
        ...
        @Override
        public final void flush() {
            assertEventLoop();
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null) {
                return;
            }
            //步骤一
            outboundBuffer.addFlush();
            //步骤二
            flush0();
        }
        protected void flush0() {
            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            ...
            doWrite(outboundBuffer);
            ...
        }
    }
    
    //Flush the content of the given buffer to the remote peer.
    protected abstract void doWrite(ChannelOutboundBuffer in) throws Exception;
}

public abstract class AbstractNioByteChannel extends AbstractNioChannel {
    ...
    @Override
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        //默认自旋16次，以提高内存使用率和写的吞吐量
        int writeSpinCount = config().getWriteSpinCount();
        do {
            Object msg = in.current();
            if (msg == null) {
                //重新注册，不关注OP_WRITE事件
                clearOpWrite();
                return;
            }
            writeSpinCount -= doWriteInternal(in, msg);
        } while(writeSpinCount &gt; 0);
        incompleteWrite(setOpWrite);
    }
    
    private int doWriteInternal(ChannelOutboundBuffer in, Object msg) {
        ...
        ByteBuf buf = (ByteBuf) msg;
        if (!buf.isReadable()) {
            //从写缓冲区(写队列)中移除结点
            in.remove();
            return 0;
        }
        //把ByteBuf对象写到Socket里
        final int localFlushedAmount = doWriteBytes(buf);
        if (localFlushedAmount &gt; 0) {
            in.progress(localFlushedAmount);
            if (!buf.isReadable()) {
                //从写缓冲区(写队列)中移除结点
                in.remove();
            }
            return 1;
        }
        ...
    }
    
    protected final void clearOpWrite() {
        final SelectionKey key = selectionKey();
        //Check first if the key is still valid as it may be canceled as part of the deregistration from the EventLoop. 
        if (!key.isValid()) {
            return;
        }
        final int interestOps = key.interestOps();
        if ((interestOps &amp; SelectionKey.OP_WRITE) != 0) {
            key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);
        }
    }
    
    @Override
    protected int doWriteBytes(ByteBuf buf) throws Exception {
        final int expectedWrittenBytes = buf.readableBytes();
        return buf.readBytes(javaChannel(), expectedWrittenBytes);
    }
    ...
}

public final class ChannelOutboundBuffer {
    private final Channel channel;
    
    //Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)
    //The Entry that is the first in the linked-list structure that was flushed
    private Entry flushedEntry;
    //The Entry which is the first unflushed in the linked-list structure
    private Entry unflushedEntry;
    //The Entry which represents the tail of the buffer
    private Entry tailEntry;
    
    private static final AtomicIntegerFieldUpdater&lt;ChannelOutboundBuffer&gt; UNWRITABLE_UPDATER;
    @SuppressWarnings("UnusedDeclaration")
    private volatile int unwritable;
    
    //The number of flushed entries that are not written yet
    private int flushed;
    ...
    
    //设置flushedEntry指针指向unflushedEntry指针所指向的Entry结点，
    //并统计需要刷新的Entry结点的数量
    public void addFlush() {
        Entry entry = unflushedEntry;
        if (entry != null) {
            if (flushedEntry == null) {
                flushedEntry = entry;
            }
            do {
                flushed ++;//所要flush的结点数
                entry = entry.next;
            } while (entry != null);
            unflushedEntry = null;
        }
    }
    
    public boolean remove() {
        //获取当前正在被flush的结点
        Entry e = flushedEntry;
        Object msg = e.msg;
        //获取该结点的回调对象
        ChannelPromise promise = e.promise;
        int size = e.pendingSize;
        //从写缓冲队列中移除结点
        removeEntry(e);
        if (!e.cancelled) {
            ReferenceCountUtil.safeRelease(msg);
            safeSuccess(promise);
            //如果写缓冲区大小小于32KB，就通过自旋+CAS设置Channel状态为可写
            decrementPendingOutboundBytes(size, false, true);
        }
        //回收实体
        e.recycle();
        return true;
    }
    
    private void removeEntry(Entry e) {
        if (-- flushed == 0) {
            flushedEntry = null;
            if (e == tailEntry) {
                tailEntry = null;
                unflushedEntry = null;
            }
        } else {
            flushedEntry = e.next;
        }
    }

    //Return the current message to write or null if nothing was flushed before and so is ready to be written.
    public Object current() {
        Entry entry = flushedEntry;
        if (entry == null) {
            return null;
        }
        return entry.msg;
    }

    //Notify the ChannelPromise of the current message about writing progress.
    public void progress(long amount) {
        Entry e = flushedEntry;
        assert e != null;
        ChannelPromise p = e.promise;
        if (p instanceof ChannelProgressivePromise) {
            long progress = e.progress + amount;
            e.progress = progress;
            ((ChannelProgressivePromise) p).tryProgress(progress, e.total);
        }
    }
    
    private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability) {
        if (size == 0) {
            return;
        }
        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, -size);
        if (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) {
            setWritable(invokeLater);
        }
    }
    
    private void setWritable(boolean invokeLater) {
        for (;;) {
            final int oldValue = unwritable;
            final int newValue = oldValue &amp; ~1;
            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {
                if (oldValue != 0 &amp;&amp; newValue == 0) {
                    fireChannelWritabilityChanged(invokeLater);
                }
                break;
            }
        }
    }
    ...
}</code></pre>
<p data-track="206">&nbsp;</p>
<p data-track="207"><strong>10.如何把对象变成字节流写到unsafe底层</strong></p>
<p data-track="208">当调用ctx.channel().writeAndFlush(user)将自定义的User对象沿着整个Pipeline进行传播时：</p>
<p data-track="209">&nbsp;</p>
<p data-track="210">首先会调用tail结点的write()方法开始往前传播，传播到一个继承自MessageToByteEncoder的结点。该结点会实现MessageToByteEncoder的encode()方法来把自定义的User对象转换成一个ByteBuf对象。转换的过程首先会由MessageToByteEncoder分配一个ByteBuf对象，然后再调用其子类实现的抽象方法encode()将User对象填充到ByteBuf对象中。填充完之后继续调用write()方法把该ByteBuf对象往前进行传播，默认下最终会传播到head结点。</p>
<p data-track="211">&nbsp;</p>
<p data-track="212">其中head结点的write()方法会通过底层的unsafe进行如下处理：把当前的ByteBuf对象添加到unsafe维护的一个写缓冲区里，同时计算写缓冲区大小是否超过64KB。如果写缓冲区大小超过了64KB，则设置当前Channel不可写。完成write()方法的传播后，head结点的unsafe对象维护的写缓冲区便对应着一个ByteBuf队列，它是一个单向链表。</p>
<p data-track="213">&nbsp;</p>
<p data-track="214">然后会调用tail结点的flush()方法开始往前传播，默认下最终会传播到head结点。head结点在接收到flush事件时会通过底层的unsafe进行如下处理：首先进行指针调整，然后通过循环遍历从写缓冲区里把ByteBuf对象取出来。每拿出一个ByteBuf对象都会把它转化为JDK底层可以接受的ByteBuffer对象，最终通过JDK的Channel把该ByteBuffer对象写出去。每写完一个ByteBuffer对象都会把写缓冲区里的当前ByteBuf所在的Entry结点进行删除，并且判断如果当前写缓冲区里的大小已经小于32KB就通过自旋 + CAS重新设置Channel为可写。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.685280139074074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-27 21:55">2025-03-27 21:55</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">36</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18796941" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18796941);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18796941', targetLink: 'https://www.cnblogs.com/mjunz/p/18796941', title: 'Netty源码—8.编解码原理' })">举报</a>
</div>
        