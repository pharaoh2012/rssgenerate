
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sanyejun/p/19009064" title="发布于 2025-07-28 15:56">
    <span role="heading" aria-level="2">Unity 射线检测优化：使用 Job System 实现高性能射线批处理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2 data-start="87" data-end="94">✨ 前言</h2>
<p data-start="96" data-end="139">在 Unity 中，射线检测（Raycast）是游戏开发中不可或缺的一环，被广泛用于：</p>
<ul data-start="141" data-end="191">
<li data-start="141" data-end="151">
<p data-start="143" data-end="151">玩家射击命中判断</p>
</li>
<li data-start="152" data-end="168">
<p data-start="154" data-end="168">AI 感知（视野/地形探测）</p>
</li>
<li data-start="169" data-end="175">
<p data-start="171" data-end="175">环境交互</p>
</li>
<li data-start="176" data-end="184">
<p data-start="178" data-end="184">鼠标点击选中</p>
</li>
<li data-start="185" data-end="191">
<p data-start="187" data-end="191">地形贴合</p>
</li>
</ul>
<p data-start="193" data-end="274">然而，<strong data-start="196" data-end="237">传统的 <code data-start="202" data-end="221">Physics.Raycast()</code> 是一个同步阻塞的主线程操作</strong>，当射线数量变多时（&gt;几十条/帧），会严重影响性能，造成帧率抖动甚至卡顿。</p>
<hr data-start="276" data-end="279">
<h2 data-start="281" data-end="306">🚫 问题：传统射线检测在高并发场景下的瓶颈</h2>
<div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between h-9 bg-token-sidebar-surface-primary select-none rounded-t-2xl">csharp</div>
<div class="sticky top-9">
<div class="absolute end-0 bottom-0 flex h-9 items-center pe-2">
<div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><button class="flex gap-1 items-center select-none py-1">复制</button><span data-state="closed"><button class="flex items-center gap-1 py-1 select-none">编辑</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-csharp"><span class="hljs-keyword">for (<span class="hljs-built_in">int i = <span class="hljs-number">0; i &lt; <span class="hljs-number">100; i++) { Physics.Raycast(...); <span class="hljs-comment">// 每次调用都阻塞主线程 } </span></span></span></span></span></code></div>
</div>
<h3 data-start="397" data-end="406">❗ 结果：</h3>
<ul data-start="407" data-end="509">
<li data-start="407" data-end="422">
<p data-start="409" data-end="422">每条射线都在主线程逐条执行</p>
</li>
<li data-start="423" data-end="465">
<p data-start="425" data-end="465">每次 <code data-start="428" data-end="445">Physics.Raycast</code> 都从 C# 跳到 C++（跨语言调用）</p>
</li>
<li data-start="466" data-end="479">
<p data-start="468" data-end="479">没有并行，无法利用多核</p>
</li>
<li data-start="480" data-end="509">
<p data-start="482" data-end="509">100~1000 条射线 → 主线程爆炸 → 严重掉帧</p>
</li>
</ul>
<hr data-start="511" data-end="514">
<h2 data-start="516" data-end="576">✅ 解决方案：使用 Unity 的 <code data-start="537" data-end="553">RaycastCommand</code> + Job System 实现“射线批处理”</h2>
<p data-start="578" data-end="602">Unity 提供了一个专为此类场景设计的结构体：</p>
<div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between h-9 bg-token-sidebar-surface-primary select-none rounded-t-2xl">csharp</div>
<div class="sticky top-9">
<div class="absolute end-0 bottom-0 flex h-9 items-center pe-2">
<div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><button class="flex gap-1 items-center select-none py-1">复制</button><span data-state="closed"><button class="flex items-center gap-1 py-1 select-none">编辑</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-csharp">RaycastCommand </code></div>
</div>
<p data-start="634" data-end="684">它允许我们将多个射线打包，<strong data-start="647" data-end="683">一次性发给 Unity Job System，并行在多线程中执行</strong>。</p>
<hr data-start="686" data-end="689">
<h2 data-start="691" data-end="701">🧠 原理概览</h2>
<div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between h-9 bg-token-sidebar-surface-primary select-none rounded-t-2xl">text</div>
<div class="sticky top-9">
<div class="absolute end-0 bottom-0 flex h-9 items-center pe-2">
<div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><button class="flex gap-1 items-center select-none py-1">复制</button><span data-state="closed"><button class="flex items-center gap-1 py-1 select-none">编辑</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"> 多个请求者（脚本） ↓ RaycastBatchManager（收集请求） ↓ NativeArray&lt;RaycastCommand&gt;（批处理） ↓ Job System ScheduleBatch 并行调度 ↓ NativeArray&lt;RaycastHit&gt;（结果） ↓ 主线程派发回调 </code></div>
</div>
<hr data-start="989" data-end="992">
<h2 data-start="994" data-end="1009">⚡ 性能对比（实测结果）</h2>
<div class="_tableContainer_80l1q_1">
<div class="_tableWrapper_80l1q_14 group flex w-fit flex-col-reverse">
<table class="w-fit min-w-(--thread-content-width)" data-start="1011" data-end="1340">
<thead data-start="1011" data-end="1071">
<tr data-start="1011" data-end="1071"><th data-start="1011" data-end="1018" data-col-size="sm">射线数量</th><th data-start="1018" data-end="1044" data-col-size="sm"><code data-start="1020" data-end="1039">Physics.Raycast()</code> 主线程</th><th data-start="1044" data-end="1071" data-col-size="sm"><code data-start="1046" data-end="1062">RaycastCommand</code> 并行 Job</th></tr>
</thead>
<tbody data-start="1143" data-end="1340">
<tr data-start="1143" data-end="1211">
<td data-start="1143" data-end="1154" data-col-size="sm">10</td>
<td data-col-size="sm" data-start="1154" data-end="1182">约 0.2 ms</td>
<td data-col-size="sm" data-start="1182" data-end="1211">约 0.1 ms</td>
</tr>
<tr data-start="1212" data-end="1277">
<td data-start="1212" data-end="1223" data-col-size="sm">100</td>
<td data-col-size="sm" data-start="1223" data-end="1248">约 2~5 ms（掉帧）</td>
<td data-col-size="sm" data-start="1248" data-end="1277">约 0.3~1 ms ✅</td>
</tr>
<tr data-start="1278" data-end="1340">
<td data-start="1278" data-end="1289" data-col-size="sm">500</td>
<td data-col-size="sm" data-start="1289" data-end="1312">10+ ms（明显卡顿）</td>
<td data-col-size="sm" data-start="1312" data-end="1340">约 2~3 ms ✅✅</td>
</tr>
</tbody>
</table>
<div class="sticky end-(--thread-content-margin) h-0 self-end select-none">&nbsp;</div>
</div>
</div>
<p data-start="1342" data-end="1363">（注：数据视硬件和场景复杂度不同略有浮动）</p>
<hr data-start="1365" data-end="1368">
<h2 data-start="1370" data-end="1407">🧱 我们构建的解决方案：<code data-start="1386" data-end="1407">RaycastBatchManager</code></h2>
<p data-start="1409" data-end="1451">为了解耦结构、集中管理，我们封装了一个 <strong data-start="1429" data-end="1447">Raycast 批处理调度器</strong>，具备：</p>
<ul data-start="1453" data-end="1588">
<li data-start="1453" data-end="1469">
<p data-start="1455" data-end="1469">✅ <strong data-start="1457" data-end="1469">每帧收集射线请求</strong></p>
</li>
<li data-start="1470" data-end="1518">
<p data-start="1472" data-end="1518">✅ <strong data-start="1474" data-end="1518">使用 <code data-start="1479" data-end="1511">RaycastCommand.ScheduleBatch()</code> 并行处理</strong></p>
</li>
<li data-start="1519" data-end="1537">
<p data-start="1521" data-end="1537">✅ <strong data-start="1523" data-end="1537">结果自动回调给请求者</strong></p>
</li>
<li data-start="1538" data-end="1560">
<p data-start="1540" data-end="1560">✅ <strong data-start="1542" data-end="1560">可配置每帧最大处理量（限流）</strong></p>
</li>
<li data-start="1561" data-end="1588">
<p data-start="1563" data-end="1588">✅ <strong data-start="1565" data-end="1588">可视化调试：Debug.DrawRay</strong></p>
</li>
</ul>
<h3 data-start="1590" data-end="1601">🧩 使用方式</h3>
<div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between h-9 bg-token-sidebar-surface-primary select-none rounded-t-2xl">csharp</div>
<div class="sticky top-9">
<div class="absolute end-0 bottom-0 flex h-9 items-center pe-2">
<div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><button class="flex gap-1 items-center select-none py-1">复制</button><span data-state="closed"><button class="flex items-center gap-1 py-1 select-none">编辑</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-csharp">RaycastBatchManager.Instance.RequestRaycast( transform.position, transform.forward, <span class="hljs-number">100f, LayerMask.GetMask(<span class="hljs-string">"Enemy"), hit =&gt; { <span class="hljs-keyword">if (hit.collider != <span class="hljs-literal">null) Debug.Log(<span class="hljs-string">"Hit " + hit.collider.name); }); </span></span></span></span></span></code></div>
</div>
<hr data-start="1858" data-end="1861">
<h2 data-start="1863" data-end="1875">🛠 技术优势总结</h2>
<div class="_tableContainer_80l1q_1">
<div class="_tableWrapper_80l1q_14 group flex w-fit flex-col-reverse">
<table class="w-fit min-w-(--thread-content-width)" data-start="1877" data-end="2455">
<thead data-start="1877" data-end="1961">
<tr data-start="1877" data-end="1961"><th data-start="1877" data-end="1905" data-col-size="sm">优点</th><th data-start="1905" data-end="1961" data-col-size="sm">说明</th></tr>
</thead>
<tbody data-start="2051" data-end="2455">
<tr data-start="2051" data-end="2121">
<td data-start="2051" data-end="2075" data-col-size="sm">✅ 主线程轻负载</td>
<td data-col-size="sm" data-start="2075" data-end="2121">所有检测在 Job 中完成，避免卡顿</td>
</tr>
<tr data-start="2122" data-end="2181">
<td data-start="2122" data-end="2141" data-col-size="sm">✅ 支持成百上千射线并发</td>
<td data-col-size="sm" data-start="2141" data-end="2181">极高扩展性，适用于大规模 AI 感知、技能判定等</td>
</tr>
<tr data-start="2182" data-end="2247">
<td data-start="2182" data-end="2208" data-col-size="sm">✅ 回调解耦</td>
<td data-col-size="sm" data-start="2208" data-end="2247">业务层无需关心处理流程，只管发出请求 + 收到命中</td>
</tr>
<tr data-start="2248" data-end="2321">
<td data-start="2248" data-end="2276" data-col-size="sm">✅ LayerMask 过滤</td>
<td data-col-size="sm" data-start="2276" data-end="2321">支持每条射线独立设置过滤层级</td>
</tr>
<tr data-start="2322" data-end="2385">
<td data-start="2322" data-end="2346" data-col-size="sm">✅ 限流/节流保护</td>
<td data-col-size="sm" data-start="2346" data-end="2385">每帧可设置最大射线数，防止爆量请求拖慢整帧</td>
</tr>
<tr data-start="2386" data-end="2455">
<td data-start="2386" data-end="2413" data-col-size="sm">✅ Debug 可视化</td>
<td data-col-size="sm" data-start="2413" data-end="2455">每条射线可视化调试，便于开发定位问题</td>
</tr>
</tbody>
</table>
<div class="sticky end-(--thread-content-margin) h-0 self-end select-none">&nbsp;</div>
</div>
</div>
<hr data-start="2457" data-end="2460">
<h2 data-start="2462" data-end="2474">💡 场景适用建议</h2>
<div class="_tableContainer_80l1q_1">
<div class="_tableWrapper_80l1q_14 group flex w-fit flex-col-reverse">
<table class="w-fit min-w-(--thread-content-width)" data-start="2476" data-end="2870">
<thead data-start="2476" data-end="2525">
<tr data-start="2476" data-end="2525"><th data-start="2476" data-end="2510" data-col-size="sm">使用场景</th><th data-start="2510" data-end="2525" data-col-size="sm">是否推荐使用射线批处理</th></tr>
</thead>
<tbody data-start="2593" data-end="2870">
<tr data-start="2593" data-end="2644">
<td data-start="2593" data-end="2618" data-col-size="sm">枪械射击系统（子弹多发）</td>
<td data-col-size="sm" data-start="2618" data-end="2644">✅✅✅</td>
</tr>
<tr data-start="2645" data-end="2697">
<td data-start="2645" data-end="2671" data-col-size="sm">AI 感知系统（视野、地形）</td>
<td data-col-size="sm" data-start="2671" data-end="2697">✅✅✅</td>
</tr>
<tr data-start="2698" data-end="2746">
<td data-start="2698" data-end="2719" data-col-size="sm">技能判定（扇形射线、范围碰撞）</td>
<td data-col-size="sm" data-start="2719" data-end="2746">✅✅</td>
</tr>
<tr data-start="2747" data-end="2805">
<td data-start="2747" data-end="2776" data-col-size="sm">鼠标点击（单条）</td>
<td data-col-size="sm" data-start="2776" data-end="2805">❌（单发用 Physics.Raycast 就行）</td>
</tr>
<tr data-start="2806" data-end="2870">
<td data-start="2806" data-end="2836" data-col-size="sm">ECS 项目（全用 Unity.Physics）</td>
<td data-col-size="sm" data-start="2836" data-end="2870">❌（使用 <code data-start="2843" data-end="2867">CollisionWorld.CastRay</code>）</td>
</tr>
</tbody>
</table>
<div class="sticky end-(--thread-content-margin) h-0 self-end select-none">&nbsp;</div>
</div>
</div>
<hr data-start="2872" data-end="2875">
<h2 data-start="2877" data-end="2887">✅ 总结一句话</h2>
<blockquote data-start="2889" data-end="3026">
<p data-start="2891" data-end="2953"><strong data-start="2891" data-end="2953">RaycastCommand + Job System 是 Unity 非 ECS 项目中进行大量射线检测的最优解。</strong></p>
<p data-start="2960" data-end="3026">若你仍然在主线程用 <code data-start="2970" data-end="2989">Physics.Raycast()</code> 做大量检测，请立即切换，<strong data-start="3002" data-end="3025">性能收益巨大、架构更合理、使用难度极低</strong>。</p>
</blockquote>
<p>&nbsp;</p>
<p>【核心代码】</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Collections.Generic;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Diagnostics;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> Unity.Collections;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> Unity.Jobs;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> UnityEngine;
</span><span style="color: rgba(0, 0, 255, 1)">using</span> Debug =<span style="color: rgba(0, 0, 0, 1)"> UnityEngine.Debug;

</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 射线批处理调度器：收集射线请求，批量执行，主线程回调
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> RaycastBatchManager : MonoBehaviour
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> RaycastBatchManager Instance { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }

    [Header(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">性能设置</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
    [Tooltip(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">每帧最多处理多少条射线（限流防卡顿）</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span> maxRaysPerFrame = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
    <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 射线请求结构
    </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> RaycastRequest
    {
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Vector3 origin;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Vector3 direction;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> distance;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> layerMask;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> Action&lt;RaycastHit&gt;<span style="color: rgba(0, 0, 0, 1)"> callback;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> List&lt;RaycastRequest&gt; requestQueue = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">();

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> NativeArray&lt;RaycastCommand&gt;<span style="color: rgba(0, 0, 0, 1)"> commands;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> NativeArray&lt;RaycastHit&gt;<span style="color: rgba(0, 0, 0, 1)"> results;

    </span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> Awake()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (Instance != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; Instance != <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            Destroy(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        Instance </span>= <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
    <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 由外部调用：发起一条射线请求（延迟到本帧 LateUpdate 执行）
    </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> RequestRaycast(Vector3 origin, Vector3 direction, <span style="color: rgba(0, 0, 255, 1)">float</span> distance, <span style="color: rgba(0, 0, 255, 1)">int</span> layerMask, Action&lt;RaycastHit&gt;<span style="color: rgba(0, 0, 0, 1)"> callback)
    {
        requestQueue.Add(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> RaycastRequest
        {
            origin </span>=<span style="color: rgba(0, 0, 0, 1)"> origin,
            direction </span>=<span style="color: rgba(0, 0, 0, 1)"> direction,
            distance </span>=<span style="color: rgba(0, 0, 0, 1)"> distance,
            layerMask </span>=<span style="color: rgba(0, 0, 0, 1)"> layerMask,
            callback </span>=<span style="color: rgba(0, 0, 0, 1)"> callback
        });
    }

    </span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> LateUpdate()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> totalRequests =<span style="color: rgba(0, 0, 0, 1)"> requestQueue.Count;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (totalRequests == <span style="color: rgba(128, 0, 128, 1)">0</span>) <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 0, 255, 1)">int</span> count =<span style="color: rgba(0, 0, 0, 1)"> Mathf.Min(maxRaysPerFrame, totalRequests);
        Debug.Log(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">当前批处理射线数量</span><span style="color: rgba(128, 0, 0, 1)">"</span> +<span style="color: rgba(0, 0, 0, 1)"> count);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">性能监测</span>
        Stopwatch stopwatch =<span style="color: rgba(0, 0, 0, 1)"> Stopwatch.StartNew();
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 分配 NativeArray（临时 Job 用）</span>
        commands = <span style="color: rgba(0, 0, 255, 1)">new</span> NativeArray&lt;RaycastCommand&gt;<span style="color: rgba(0, 0, 0, 1)">(count, Allocator.TempJob);
        results </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> NativeArray&lt;RaycastHit&gt;<span style="color: rgba(0, 0, 0, 1)">(count, Allocator.TempJob);

        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; count; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> req =<span style="color: rgba(0, 0, 0, 1)"> requestQueue[i];
            commands[i] </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> RaycastCommand(req.origin, req.direction, req.distance, req.layerMask);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 👇 可视化（调试用）
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">Debug.DrawRay(req.origin, req.direction * req.distance, Color.green, 0.1f);</span>
<span style="color: rgba(0, 0, 0, 1)">        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 并行调度</span>
        JobHandle handle = RaycastCommand.ScheduleBatch(commands, results, <span style="color: rgba(128, 0, 128, 1)">32</span><span style="color: rgba(0, 0, 0, 1)">);
        handle.Complete(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 阻塞直到 Job 完成（确保结果可用）

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 回调结果</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; count; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            requestQueue[i].callback</span>?<span style="color: rgba(0, 0, 0, 1)">.Invoke(results[i]);
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 分帧处理，保留未处理的请求</span>
        requestQueue.RemoveRange(<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, count);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 安全释放 NativeArray</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (commands.IsCreated) commands.Dispose();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (results.IsCreated) results.Dispose();
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 性能统计输出</span>
<span style="color: rgba(0, 0, 0, 1)">        stopwatch.Stop();
        UnityEngine.Debug.Log($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">[RaycastBatchManager] {count} 射线耗时: {stopwatch.ElapsedMilliseconds} ms</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>【测试用例】</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">            RaycastBatchManager.Instance.RequestRaycast(
                transform.position,
                transform.forward,
                100f,
                LayerMask.GetMask(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Default</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
                hit </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
                {
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (hit.collider != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
                        Debug.Log(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">命中: </span><span style="color: rgba(128, 0, 0, 1)">"</span> +<span style="color: rgba(0, 0, 0, 1)"> hit.collider.name);
                    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
                        Debug.Log(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">未命中</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
                });</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-28 15:57">2025-07-28 15:56</span>&nbsp;
<a href="https://www.cnblogs.com/sanyejun">三页菌</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19009064);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19009064', targetLink: 'https://www.cnblogs.com/sanyejun/p/19009064', title: 'Unity 射线检测优化：使用 Job System 实现高性能射线批处理' })">举报</a>
</div>
        