
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangSir-devops/p/18859111" title="发布于 2025-05-11 13:37">
    <span role="heading" aria-level="2">K8s新手系列之Pod的基本存储</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="概念">概念</h2>
<p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-volume-storage/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-volume-storage/</a><br>
卷：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/</a></p>
<p>容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h2 id="基本存储之emptydir">基本存储之EmptyDir</h2>
<p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir</a></p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时，EmptyDir中的数据也会被永久删除。使用在<strong>临时缓存文件、中间计算结果（无需持久化）。</strong><br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250511121752601-445328740.png" alt="image" loading="lazy"></p>
<h3 id="特点">特点</h3>
<ul>
<li>Pod 创建时自动创建空目录，Pod 删除时数据清除。</li>
<li>数据仅存于 Pod 所在节点的内存或磁盘（可通过medium参数指定，默认""表示节点默认存储，Memory表示内存存储，数据易失）。</li>
<li>支持 Pod 内多个容器共享数据。</li>
</ul>
<h3 id="emptydir使用场景">EmptyDir使用场景</h3>
<ul>
<li>临时缓存文件、中间计算结果（无需持久化）</li>
<li>例如：filebeat采集日志</li>
</ul>
<h3 id="emptydir实战案例">EmptyDir实战案例</h3>
<p>示例：</p>
<pre><code># 定义清单文件
[root@master01 ~/volumes]# cat empty-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: empty-pod
spec:
  # 定义数据卷
  volumes:
  # 数据卷名称
  - name: data-volume
    # volume的类型
    emptyDir: {}
  containers:
  - name: writer-busybox
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "hello emptyDir" &gt;&gt; /data/hello.txt;
        sleep 3600
    # 指定挂载的数据卷
    volumeMounts:
      # 要挂载的数据卷名称
    - name: data-volume
      # 挂载到容器内部的路径
      mountPath: /data
      # 是否只读，false为可读可写，true为只读
      readOnly: false
  - name: reader-busybox
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
      - |
        cat /data/hello.txt;
        sleep 3600
    volumeMounts:
    - name: data-volume
      mountPath: /data
      readOnly: true
</code></pre>
<p>查看pod打印的日志</p>
<pre><code>[root@master01 ~/volumes]# kubectl logs empty-pod reader-busybox
hello emptyDir
</code></pre>
<h2 id="基本存储之hostpath">基本存储之HostPath</h2>
<p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath</a></p>
<p>EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250511123952101-897473886.png" alt="image" loading="lazy"></p>
<h3 id="特点-1">特点</h3>
<ul>
<li>挂载节点上的本地文件或目录（如/var/lib/data）到 Pod 中。</li>
<li>数据随节点存在而保留，Pod 删除后数据仍在节点上，但跨节点调度时无法共享。</li>
<li>需注意节点路径权限（如使用hostPath.type指定路径类型，如DirectoryOrCreate自动创建目录）。</li>
</ul>
<h3 id="hostpath实战案例">HostPath实战案例</h3>
<pre><code># 定义清单文件
[root@master01 ~/volumes]# cat hostpath-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-pod
spec:
  volumes:
  - name: hostpath
    hostPath:
      # 节点上的存储位置
      path: /data/nginx/
      # 类型，文件夹不存在时自动创建
      type: DirectoryOrCreate
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: hostpath
      mountPath: /usr/share/nginx/html

# 创建Pod
[root@master01 ~/volumes]# kubectl apply -f hostpath-pod.yaml
pod/hostpath-pod created

# 查看Pod调度到哪个节点上
[root@master01 ~/volumes]# kubectl get po hostpath-pod -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES
hostpath-pod   1/1     Running   0          89s   100.95.185.242   node02   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>前往node02节点上查看</p>
<pre><code># 发现目录已经创建成功了
[root@node02 ~]# stat /data/nginx/
  File: /data/nginx/
  Size: 4096            Blocks: 8          IO Block: 4096   directory
Device: fd00h/64768d    Inode: 1441794     Links: 2
Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2025-05-11 12:52:34.507395315 +0800
Modify: 2025-05-11 12:51:28.658324447 +0800
Change: 2025-05-11 12:51:28.658324447 +0800
 Birth: 2025-05-11 12:49:08.272029814 +0800

# 写入一个文件进行访问测试
[root@node02 ~]# echo I am huangsir &gt; /data/nginx/index.html
[root@node02 ~]# cat /data/nginx/index.html
I am huangsir

# 访问nginx，发现绑定成功
[root@node02 ~]# curl 100.95.185.242
I am huangsir
</code></pre>
<h3 id="hostpath中type的可用值">hostPath中type的可用值</h3>
<ul>
<li>
<p>DirectoryOrCreate：如果在给定路径上什么都不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 kubelet 相同的组和属主信息。</p>
</li>
<li>
<p>Directory：在给定路径上必须存在的目录。</p>
</li>
<li>
<p>FileOrCreate：如果在给定路径上什么都不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 kubelet 相同的组和所有权。</p>
</li>
<li>
<p>File：在给定路径上必须存在的文件。</p>
</li>
<li>
<p>Socket：在给定路径上必须存在的 UNIX 套接字。</p>
</li>
<li>
<p>CharDevice：（仅 Linux 节点） 在给定路径上必须存在的字符设备。</p>
</li>
<li>
<p>BlockDevice：（仅 Linux 节点） 在给定路径上必须存在的块设备。</p>
</li>
</ul>
<h2 id="基本存储之nfs">基本存储之NFS</h2>
<p>官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#nfs" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#nfs</a></p>
<p>HostPath依赖节点，如果Pod重启之后调度到另一个节点中，那么所依赖数据将不存在。</p>
<p>NFS可以解决这个问题，</p>
<h3 id="nfs存储特点">NFS存储特点</h3>
<ul>
<li>挂载远程 NFS 服务器的共享目录，支持跨节点共享数据。</li>
<li>数据持久化存储在 NFS 服务器，不依赖 Pod 或节点生命周期。</li>
</ul>
<h3 id="使用场景">使用场景</h3>
<p>多 Pod 共享数据（如分布式应用的共享配置）。</p>
<h3 id="nfs实战案例">NFS实战案例</h3>
<h4 id="安装nfs">安装NFS</h4>
<p>首先我们需要安装NFS，可以参考这篇文章：<a href="https://www.cnblogs.com/huangSir-devops/p/18802386" title="NFS搭建及使用" target="_blank">NFS搭建及使用</a></p>
<h4 id="master节点安装服务端">master节点安装服务端</h4>
<pre><code>apt update -y
apt install -y nfs-kernel-server
# 检查状态
systemctl status nfs-kernel-server
# 创建共享目录
mkdir -p /data/nfs/nginx
echo '/data/nfs/nginx 10.0.0.0/24(rw,sync,no_root_squash,no_subtree_check)' &gt;&gt; /etc/exports
exportfs -ra
systemctl restart nfs-kernel-server
</code></pre>
<h4 id="node节点安装客户端可以不用操作">node节点安装客户端（可以不用操作）</h4>
<pre><code>apt update -y
apt install -y nfs-common
mkdir -p /data/nfs/nginx
# 挂载
mount -t nfs 10.0.0.30:/data/nfs/nginx /data/nfs/nginx
# 开机自启动挂载
echo 10.0.0.30:/data/nfs/nginx /data/nfs/nginx nfs defaults        0 0 &gt;&gt; /etc/fstab
# 检查是否挂载成功
df -h | grep /data/nfs/nginx
</code></pre>
<h4 id="创建pod测试">创建Pod测试</h4>
<pre><code># 定义资源文件
[root@master01 ~/volumes]# cat nfs-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nfs-pod
spec:
  # 指定Pod调度到node01节点上
  nodeName: node01
  volumes:
  - name: nfs
    nfs:
      # nfs服务端的地址
      server: 10.0.0.30
      # 挂载nfs服务器的路径
      path: /data/nfs/nginx
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: nfs
      mountPath: /usr/share/nginx/html

# 创建Pod
[root@master01 ~/volumes]# kubectl apply -f nfs-pod.yaml
pod/nfs-pod created

# 查看pod信息，发现调度到node01节点上，IP为100.117.144.145
[root@master01 ~/volumes]# kubectl get po nfs-pod -o wide
NAME      READY   STATUS    RESTARTS   AGE   IP                NODE     NOMINATED NODE   READINESS GATES
nfs-pod   1/1     Running   0          16s   100.117.144.145   node01   &lt;none&gt;           &lt;none&gt;

</code></pre>
<p>配置测试内容并访问测试</p>
<pre><code>[root@master01 ~/volumes]#  echo nfs-server &gt; index.html
# 访问测试
[root@master01 ~/volumes]# curl 100.117.144.145
nfs-server
</code></pre>
<p>再将Pod调度到node02节点上，测试访问内容是否会发生变化</p>
<pre><code>[root@master01 ~/volumes]# cat nfs-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nfs-pod
spec:
  # 指定Pod调度到node02节点上
  nodeName: node02
  volumes:
  - name: nfs
    nfs:
      # nfs服务端的地址
      server: 10.0.0.30
      # 挂载nfs服务器的路径
      path: /data/nfs/nginx
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: nfs
      mountPath: /usr/share/nginx/html

# 创建Pod，需要将上一步创建Pod删除哦~
[root@master01 ~/volumes]# kubectl apply -f nfs-pod.yaml
pod/nfs-pod created

# 查看pod调度及IP
[root@master01 ~/volumes]# kubectl get po nfs-pod -o wide
NAME      READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES
nfs-pod   1/1     Running   0          10s   100.95.185.244   node02   &lt;none&gt;           &lt;none&gt;

# 访问，发现内容并没有发生变化
[root@master01 ~/volumes]# curl 100.95.185.244
nfs-seerver
</code></pre>
<h2 id="配置存储configmap和secret">配置存储ConfigMap和Secret</h2>
<p>可以参考下面这两篇文章</p>
<ul>
<li><a href="https://www.cnblogs.com/huangSir-devops/p/18857588" title="K8s新手系列之ConfigMap资源" target="_blank">K8s新手系列之ConfigMap资源</a></li>
<li><a href="https://www.cnblogs.com/huangSir-devops/p/18857798" title="K8s新手系列之Secret资源" target="_blank">K8s新手系列之Secret资源</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/huangSir-devops/" target="_blank">huangSir-devops</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/huangSir-devops/p/18859111" target="_blank">https://www.cnblogs.com/huangSir-devops/p/18859111</a>，微信Vac666666，欢迎交流</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23787843587152777" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-11 16:36">2025-05-11 13:37</span>&nbsp;
<a href="https://www.cnblogs.com/huangSir-devops">huangSir-devops</a>&nbsp;
阅读(<span id="post_view_count">34</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18859111);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18859111', targetLink: 'https://www.cnblogs.com/huangSir-devops/p/18859111', title: 'K8s新手系列之Pod的基本存储' })">举报</a>
</div>
        