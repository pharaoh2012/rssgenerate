
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/graphics/p/18956299" title="发布于 2025-06-29 22:23">
    <span role="heading" aria-level="2">一文搞懂javascript中的var、let、const</span>
    

</a>

        </h2>
        <div class="postbody">
            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p><code>var</code>, <code>let</code> and <code>const</code>是JavaScript中三种定义变量的方式，它们之间有什么区别呢？这是前端面试中常见的一道题，今天我们来一文说透它。<br>
<code>let</code>和<code>const</code>区别不大，主要是<code>const</code>声明的是常量，不可修改，而<code>let</code>声明的变量是可修改的。所以我们重点放在<code>var</code>和<code>let</code>上。</p>
<h1 id="变量初始化">变量初始化</h1>
<p>声明变量的同时为其赋值叫做初始化。</p>
<ul>
<li><code>var</code>和<code>let</code>声明的变量都可以不赋值，此时变量的值为<code>undefined</code>。</li>
<li><code>const</code>声明的变量必须赋值，否则会报错。</li>
</ul>
<pre><code class="language-js">// `var`和`let`声明的变量可以不赋值，此时变量的值为`undefined`。
var num; // num的值是undefined
num = 1; // num的值是1

let str; // str的值是undefined
str = 'hello'; // str的值是'hello' 
</code></pre>
<pre><code class="language-js">// `const`声明的变量必须赋值，否则会报错。
const a; // SyntaxError: Missing initializer in const declaration
</code></pre>
<h1 id="变量提升---hoisting">变量提升 - Hoisting</h1>
<p><code>Hoisting</code>这个词中文译为提升，就是将变量的声明提升到其作用域的顶部，注意提升的是声明，而不是赋值。</p>
<ul>
<li><code>var</code>声明的变量会被提升至其作用域顶部。</li>
<li><code>let</code>和<code>const</code>声明的变量不会被提升。（注意这个说法有争议，详见<a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" target="_blank" rel="noopener nofollow">MDN</a>）</li>
<li>提升只针对变量声明，不包括赋值。</li>
</ul>
<h2 id="如果var是在全局作用域声明的那么它会被提升到全局作用域的顶部">如果var是在全局作用域声明的，那么它会被提升到全局作用域的顶部。</h2>
<pre><code class="language-javascript">console.log(name); // undefined
var name = 'Philip';
</code></pre>
<p>以上代码等价于：</p>
<pre><code class="language-javascript">var name; // `var`声明的变量会被提升到其作用域顶部。
console.log(name); // undefined
name = 'Philip';
</code></pre>
<h2 id="如果var是在函数作用域声明的那么它会被提升到函数作用域的顶部">如果var是在函数作用域声明的，那么它会被提升到函数作用域的顶部。</h2>
<pre><code class="language-javascript">function printName() {
  console.log(name); // undefined
  var name = 'Philip';
}
printName();
</code></pre>
<p>以上代码等价于：</p>
<pre><code class="language-javascript">function printName() {
  var name; // `var`声明的变量会被提升到其作用域顶部。
  console.log(name); // undefined
  name = 'Philip';
}
printName();
</code></pre>
<h2 id="let和const声明的变量不会被提升"><code>let</code>和<code>const</code>声明的变量不会被提升。</h2>
<p>对于<code>let</code>和<code>const</code>，它们不会被提升，所以下面代码会报错。</p>
<pre><code class="language-javascript">console.log(num); // ReferenceError: Cannot access 'num' before initialization
const num = 1;
</code></pre>
<p>前面说过，关于<code>let</code>和<code>const</code>是否被提升有争议。</p>
<ul>
<li>一种说法是<code>let</code>和<code>const</code>不会被提升，所以在声明之前访问会报错。</li>
<li>另一种说法是<code>let</code>和<code>const</code>会被提升，但是在声明之前访问会抛出<code>Temporal Dead Zone</code>错误。</li>
</ul>
<p>比如下面的代码：</p>
<pre><code class="language-javascript">const x = 1;
{
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  const x = 2;
}
</code></pre>
<p>这段代码会报错，但是如果我们把<code>{}</code>内的<code>const x = 2;</code>注释掉，那么代码就不会报错。如果<code>const x = 2</code>没有被提升的话，那么<code>console.log(x)</code>应该可以访问到全局的<code>const x = 1</code>，而不会报错。换句话说：因为<code>const x = 2</code>被提升了，所以<code>console.log(x)</code>访问的是提升后的<code>x</code>，而此时<code>x</code>还没有被初始化，所以报错。</p>
<h2 id="提升只针对变量声明不包括赋值">提升只针对变量声明，不包括赋值。</h2>
<p>下面的代码会报错，因为x = 1是赋值，并不是声明，所以不会提升。(注意：如果变量声明前没有加<code>var</code>, <code>let</code>或<code>const</code>，那么其实产生的是一个意外的全局变量。)</p>
<pre><code class="language-javascript">console.log(x); // ReferenceError: x is not defined
x = 1;
</code></pre>
<h2 id="如果有同名函数和变量那么提升后变量位于函数之前或者说函数会覆盖变量">如果有同名函数和变量，那么提升后，变量位于函数之前（或者说函数会覆盖变量）。</h2>
<p>以下代码中有一个同名的函数和变量。</p>
<pre><code class="language-javascript">console.log(foo); // [Function: foo], not undefined.

function foo() {
  console.log('function foo');
}

var foo = 1;
</code></pre>
<p>提升后代码如下：</p>
<pre><code class="language-javascript">var foo;
function foo() {
  console.log('function foo');
}
console.log(foo);
foo = 1;
</code></pre>
<h2 id="面试题">面试题</h2>
<p>看几道面试题，以下几段代码输出什么？</p>
<ol>
<li>第一题</li>
</ol>
<pre><code class="language-javascript">a = 2;
var a;
console.log(a); // 2
</code></pre>
<p>解决var提升的问题很简单，就是按照提升规则将代码重写一下，上面的代码等价于如下代码，结果一目了然。</p>
<pre><code class="language-javascript">var a;
a = 2;
console.log(a); // 2
</code></pre>
<ol start="2">
<li>第二题</li>
</ol>
<pre><code class="language-javascript">var a = true;
foo();

function foo() {
  if (a) {
    var a = 10;
  }
  console.log(a);
}
</code></pre>
<p>只要函数内部有<code>var</code>声明的变量，那么所有全局声明的<code>var</code>变量都会被忽略，以上代码提升后等价于如下代码（注意<code>function</code>也有提升），函数内部的var永远会覆盖全局的<code>var</code>。</p>
<pre><code class="language-javascript">var a = true;

function foo() {
  var a; // value of a is `undefined`
  if (a) {
    a = 10; // never executed.
  }
  console.log(a);
}

foo();
</code></pre>
<ol start="3">
<li>第三题</li>
</ol>
<pre><code class="language-javascript">function fn() {
  console.log(typeof foo);
  var foo = 'variable';

  function foo() {
    return 'function';
  }

  console.log(typeof foo);
}

fn();
</code></pre>
<p>还是那句话，此类题目的解法就是按照提升规则把代码重新写一遍，以上代码提升后等价于如下代码：</p>
<pre><code class="language-javascript">function fn() {
  var foo;

  function foo() {
    return 'function';
  }

  console.log(typeof foo);
  
  foo = 'variable';

  console.log(typeof foo);
}

fn();
</code></pre>
<p>所以输出结果是<code>function</code>和<code>string</code>。</p>
<h1 id="变量的作用域">变量的作用域</h1>
<ul>
<li><code>var</code>声明的变量有只两种作用域：全局作用域和函数作用域。（没有块级作用域）</li>
<li><code>let</code>和<code>const</code>声明的变量有三种作用域：全局作用域，函数作用域和块级作用域。</li>
<li><code>var</code>声明的全局变量会挂载到<code>window</code>对象上，而<code>let</code>和<code>const</code>不会。</li>
<li><code>let</code>和<code>const</code>有临时性死区，而<code>var</code>没有。</li>
</ul>
<h2 id="面试题-1">面试题</h2>
<h3 id="第一题">第一题</h3>
<p>以下代码输出什么？</p>
<pre><code class="language-js">let x = 1;
{
  let x = 2;
}

console.log(x);
</code></pre>
<p>答案：1，因为<code>let</code>有块级作用域，所以<code>let x = 2</code>只在<code>{}</code>内有效。</p>
<h3 id="第二题">第二题</h3>
<p>以下代码输出什么？</p>
<pre><code class="language-js">var x = 1;
{
  var x = 2;
}

console.log(x);
</code></pre>
<p>答案：2，因为<code>var</code>没有块级作用域，所以<code>var x = 2</code>会覆盖外部的<code>var x = 1</code>。</p>
<h3 id="第三题">第三题</h3>
<p>以下代码输出什么？</p>
<pre><code class="language-js">let name = 'zdd';
{
  console.log(name); 
  let name = 'Philip';
}
</code></pre>
<p>答案：ReferenceError: Cannot access 'name' before initialization。因为<code>let</code>有块级作用域，所以<code>console.log(name);</code>访问的是<code>let name = 'Philip';</code>之前的<code>name</code>，而此时<code>name</code>还没有被初始化，处于暂时性死区中，所以报错。</p>
<h3 id="第四题">第四题</h3>
<p>以下代码输出什么？</p>
<pre><code class="language-js">'use strict';

{
  function foo() {
    console.log('foo');
  }
}

foo();
</code></pre>
<p>答案：ReferenceError: foo is not defined。因为<code>foo</code>是在块级作用域内声明的，所以在外部无法访问。但是如果我们把<code>'use strict';</code>去掉，那么代码就可以正常运行。因为在非严格模式下，函数声明会被提升到全局作用域。</p>
<h3 id="第五题">第五题</h3>
<p>以下代码输出什么？</p>
<pre><code class="language-js">(() =&gt; {
  let x;
  let y;
  try {
    throw new Error();
  } catch (x) {
    x = 1;
    y = 2;
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
</code></pre>
<p>答案：1 <code>undefined</code> 2。因为<code>catch</code>中的<code>x</code>是一个新的变量，不是外部的<code>x</code>，所以<code>x = 1</code>只会改变<code>catch</code>中的<code>x</code>，而不会改变外部的<code>x</code>。而<code>y = 2</code>不是<code>catch</code>的参数，只是在<code>catch</code>中赋值的，所以会改变外部的<code>y</code>。</p>
<h1 id="暂时性死区---temporal-dead-zone">暂时性死区 - Temporal Dead Zone</h1>
<p>TDZ即<code>Temporal Dead Zone</code> - 中文名暂时性死区，是指<code>let</code>和<code>const</code>声明的变量在其作用域开始到变量声明之间的这段区域。在暂时性死区内无法访问变量，访问会报错。</p>
<pre><code class="language-javascript">function foo() {
  console.log(b); // ReferenceError: Cannot access 'b' before initialization
  let a = 1;
  const b = 2;
}

foo();
</code></pre>
<p>对于以上代码，常量<code>b</code>的暂时性死区开始于函数的第一行，终止于<code>b</code>的声明，而<code>console.log(b);</code>这句恰恰在暂时性死区内访问了<code>b</code>，所以会报错。</p>
<h2 id="面试题-2">面试题</h2>
<p>以下代码输出什么？</p>
<pre><code class="language-js">function foo() {
  console.log(typeof bar);
  const bar = 1;
}

foo();
</code></pre>
<p>答案：<br>
<code>ReferenceError: Cannot access 'bar' before initialization</code><br>
因为<code>console.log(typeof bar);</code>这句在<code>bar</code>的暂时性死区内访问了<code>bar</code>，所以会报错。可以看到，即使强如<code>typeof</code>这种几乎不会报错的操作符也无法规避暂时性死区。</p>
<p>如果我们把<code>const bar = 1;</code>去掉，那么代码就不会报错。<code>typeof</code>操作符对于没有声明的变量不会报错，而是返回<code>undefined</code>。</p>
<pre><code class="language-js">function foo() {
  console.log(typeof bar); // 输出undefined
}
</code></pre>
<h1 id="重新声明--redeclaration">重新声明- Redeclaration</h1>
<ul>
<li><code>var</code>声明的变量可以被重复声明，后声明的覆盖先声明的。</li>
<li><code>let</code>和<code>const</code>声明的变量不可以被重复声明。</li>
</ul>
<h2 id="面试题-3">面试题</h2>
<p>看几道面试题，以下几段代码输出什么？</p>
<ol>
<li>第一题</li>
</ol>
<pre><code class="language-javascript">var a = 1;

function foo() {
  var a = 2;
  {
    var a = 3;
    console.log(a);
  }
  console.log(a);
}

foo();

console.log(a);
</code></pre>
<p>答案：3 3 1, 这个题主要考察两个知识点：</p>
<ol>
<li><code>var</code>声明的变量没有块级作用域。</li>
<li><code>var</code>声明的变量可以被重复声明，后声明的会覆盖先声明的。<br>
所以<code>var a = 3</code>会覆盖外部的<code>var a = 2</code>，但是<code>var a = 2</code>不会覆盖最外面的<code>var a = 1</code>。因为<code>var</code>有函数作用域。</li>
</ol>
<p>以上代码提升后等价于如下代码：</p>
<pre><code class="language-javascript">var a;
a = 1;
function foo() {
  var a;
  var a; // redeclaration
  a = 2;
  {
    a = 3;
    console.log(a);
  }
  console.log(a);
}
foo();
console.log(a);
</code></pre>
<p>注意：面试题中凡事用<code>{}</code>包裹<code>var</code>的都是障眼法，<code>var</code>没有块级作用域。</p>
<h3 id="第二题-1">第二题</h3>
<p>这道题比较简单，考察的是<code>let</code>的块级作用域，代码输出2, 1。因为<code>let</code>有块级作用域。<code>let a = 2</code>只在<code>{}</code>内有效。</p>
<pre><code class="language-javascript">function foo() {
  let a = 1;
  {
    let a = 2;
    console.log(a);
  }
  console.log(a);
}

foo();
</code></pre>
<h1 id="意外的全局变量">意外的全局变量</h1>
<p>如果我们声明变量的时候忘记了写<code>var</code>, <code>let</code>或者<code>const</code>，那么这个变量就是所谓的<code>Accidental Global Variables</code>，意思是<code>意外的全局变量</code>。</p>
<pre><code class="language-javascript">function f1() {
  b = 2; // accident global variable
}
f1();
console.log(b); // 2
</code></pre>
<h1 id="面试题-4">面试题</h1>
<p>以下代码输出什么？</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i);
  })
}
</code></pre>
<p>答案：3 3 3<br>
因为<code>var</code>没有块级作用域，所以<code>setTimeout</code>内的<code>i</code>都是指向同一个<code>i</code>，而<code>setTimeout</code>是异步的，其回调函数代码需要先进入宏任务队列，待<code>for</code>循环结束后才能执行，此时<code>i</code>已经是3了。关于这道题的详细解释，请看<a href="https://zdd.github.io/2024/11/16/javascript-interview-questions-02/" target="_blank" rel="noopener nofollow">这篇</a>。</p>
<h1 id="最佳实践">最佳实践</h1>
<ol>
<li>
<p>如今ES6已经普及，对于业务代码来说，基本不需要使用<code>var</code>了，<code>var</code>目前只有JS框架或者底层工具库才会使用。</p>
</li>
<li>
<p>对于<code>let</code>和<code>const</code>，优先使用<code>const</code>，只有在需要修改变量的情况下才使用<code>let</code>。</p>
</li>
<li>
<p>经典for循环使用<code>let</code>，因为循环变量会被修改。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 5; i++) {
  console.log(i);
}
</code></pre>
</li>
<li>
<p><code>for...in</code>和<code>for...of</code>使用<code>const</code>，因为循环变量不会被修改。</p>
<pre><code class="language-js">const arr = [1, 2, 3];
for (const item of arr) {
  console.log(item);
}
</code></pre>
<pre><code class="language-js">const obj = {a: 1, b: 2};
for (const key in obj) {
  console.log(key);
}
</code></pre>
</li>
</ol>
<p>祝大家编程愉快，如果觉得有用就点个关注，每篇文章都是纯古法手打，在AI大行其道的当下，认认真真写文章的人不多了，您的点赞转发评论就是对我最大的支持！</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="ZddSignature">
<div>作者：<a href="http://www.cnblogs.com/graphics/" target="_blank">zdd</a></div>
<div>出处：<a href="http://www.cnblogs.com/graphics/" target="_blank">http://www.cnblogs.com/graphics/</a>
<div>
<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-29 22:23">2025-06-29 22:23</span>&nbsp;
<a href="https://www.cnblogs.com/graphics">前端风云志</a>&nbsp;
阅读(<span id="post_view_count">171</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18956299);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18956299', targetLink: 'https://www.cnblogs.com/graphics/p/18956299', title: '一文搞懂javascript中的var、let、const' })">举报</a>

        </p>
    