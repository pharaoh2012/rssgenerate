
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youzhibing/p/19034101" title="发布于 2025-08-13 09:04">
    <span role="heading" aria-level="2">关于布尔类型的变量不要加 is 前缀，被网友们吐槽了，特来完善下</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="开心一刻">开心一刻</h2>
<p>一老农养猪，母的，怎么配也怀不上小猪，于是找兽医<br>兽医来到他家看了猪一眼说：不行就人工授精吧<br>老农绕着猪走了三圈，点燃一根烟，貌似下了很大决心，说到：行倒是行，就怕生下来像我</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161519271-1831158377.gif" alt="开心一刻"></div>
<h2 id="被网友吐槽">被网友吐槽</h2>
<p><a href="https://www.cnblogs.com/youzhibing/p/18958862" target="_blank">都说了布尔类型的变量不要加 is 前缀，非要加，这不是坑我了嘛</a>一经发布，<code>吐槽</code>不断</p>
<p>有吐槽 <code>框架</code> 的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517227-580944952.png" alt="吐槽_框架问题"></div>
<p>有吐槽 <code>IDE</code> 的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517651-122162921.png" alt="吐槽_IDE问题"></div>
<p>有吐槽 <code>Java</code> 的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517263-1382126584.png" alt="吐槽_java"></div>
<p>有吐槽楼主落后，不用 <code>Lombok</code> 的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517475-72206142.png" alt="吐槽_楼主"></div>
<p>也有吐槽 <code>水文</code> 的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517913-730882765.png" alt="吐槽_水文"></div>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517569-1741802709.png" alt="吐槽_水文1"></div>
<p>说实话，前面的吐槽不会让我有任何波澜，但是这个 <code>水文</code> 让我内心泛起了 <code>涟漪</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161518626-1018239851.gif" alt="谁赞成谁反对"></div>
<p>作为一个严谨的博主，怎能让 <code>水文</code> 出现在我的写作生涯中？特来补充、完善下</p>
<h2 id="javabeans-规范">JavaBeans 规范</h2>
<p>关于 <code>JavaBean</code> 的属性该如何读写，<code>sun</code> 官方给出了规范：<a href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/" target="_blank" rel="noopener nofollow">JavaBeans Spec</a>，其中有这么一段</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517695-1101138924.png" alt="boolean属性官方说明"></div>
<p>与本文密切相关，我给你们翻译下</p>
<ol>
<li>
<p>简单属性</p>
<p>默认情况下，通过识别特定格式的方法（方法命名模式）来定位属性：</p>
<pre><code class="language-java">public &lt;PropertyType&gt; get&lt;PropertyName&gt;();
public void set&lt;PropertyName&gt;(&lt;PropertyType&gt; a);
</code></pre>
<p>如果我们发现一对方法：<code>get&lt;PropertyName&gt;()</code> 、<code>set&lt;PropertyName&gt;</code>，<code>set</code> 方法的入参类型与 <code>get</code> 方法的返回类型相同，那么我们将这对方法视为 <code>&lt;propertyName&gt;</code> 的读写属性。我们将使用 <code>get&lt;PropertyName&gt;</code>  方法获取属性值，并使用 <code>set&lt;PropertyName&gt;</code> 方法设置属性值。这对方法可以位于同一个类中，也可以一个位于基类中，另一个位于派生类中。</p>
<p>如果我们只找到了这对方法中的某个方法，我们则认为只定义了 <code>&lt;propertyName&gt;</code> 的只读属性或只写属性</p>
<p>默认情况下，我们预设属性既非绑定属性，亦非约束属性</p>
<blockquote>
<p>绑定属性与约束属性与本文无关，不展开</p>
</blockquote>
<p>因此，一个简单的可读写属性 <code>foo</code> 通常会通过以下方法对表示：</p>
<pre><code class="language-java">public Wombat getFoo();
public void setFoo(Wombat w);
</code></pre>
</li>
<li>
<p>布尔属性</p>
<p>此外，对于布尔属性，我们允许 getter 方法匹配以下模式：</p>
<pre><code class="language-java">public boolean is&lt;PropertyName&gt;();
</code></pre>
<p>我们可以用<code>is&lt;PropertyName&gt;</code> 方法来替换 <code>get&lt;PropertyName&gt;</code> 方法，也可用 <code>is&lt;PropertyName&gt;</code> 方法补充 <code>get&lt;PropertyName&gt;</code> 方法。无论哪种情况，只要布尔属性存在 <code>is&lt;PropertyName&gt;</code>  方法，则使用 <code>is&lt;PropertyName&gt;</code> 方法获取属性值。</p>
<p>一个布尔属性示例可能如下：</p>
<pre><code class="language-java">public boolean isMarsupial();
public void setMarsupial(boolean m);
</code></pre>
</li>
</ol>
<p>至此，我相信大家对 <code>JavaBean</code> 的 <code>setter</code>、<code>getter</code> 规范有了个基本了解了，我再总结下</p>
<blockquote>
<ol>
<li>简单属性（非布尔属性），通过 <code>get&lt;PropertyName&gt;()</code> 和 <code>set&lt;PropertyName&gt;</code> 来获取、设置属性值</li>
<li>布尔属性，通过 <code>set&lt;PropertyName&gt;</code> 设置属性值，通过 <code>get&lt;PropertyName&gt;</code> 或 <code>is&lt;PropertyName&gt;</code> 来获取属性值，如果两个获取方法同时存在，使用 <code>is&lt;PropertyName&gt;</code> 来获取属性值</li>
</ol>
</blockquote>
<p>规范，官方是制定了，但实现者是不是按规范实现的呢，我们以 <code>IntelliJ IDEA</code> 和 <code>Lombok</code> 为例，来看看它们是否遵循了规范</p>
<ol>
<li>
<p>IDEA</p>
<p>版本：<code>IntelliJ IDEA 2023.3.2</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517607-1120586344.png" alt="IDEA_setter_getter"></div>
<p>生成的 <code>setter</code>、<code>getter</code> 方法如下</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
public class JavaBeanEntity {
    private String id;
    private int age;
    private boolean enabled;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
}
</code></pre>
<p>属性 <code>id</code>、<code>age</code> 的类型不是布尔类型，其 <code>setter</code>、<code>getter</code> 方法符合简单属性的规范；属性 <code>enabled</code> 的类型是布尔类型，其 <code>getter</code> 方法是 <code>isEnabled</code>，<code>setter</code> 方法是 <code>setEnabled</code>，符合布尔属性的规范</p>
<blockquote>
<p>也就是说 <code>IDEA</code> 遵循了 JavaBeans 属性规范</p>
</blockquote>
</li>
<li>
<p>Lombak</p>
<p>我们再来看看 <code>Lombok</code>，版本：<code>1.18.30</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517579-1347371297.png"></div>
<p>属性 <code>id</code>、<code>age</code> 的类型不是布尔类型，其 <code>setter</code>、<code>getter</code> 方法符合简单属性的规范；属性 <code>enabled</code> 的类型是布尔类型，其 <code>getter</code> 方法是 <code>isEnabled</code>，<code>setter</code> 方法是 <code>setEnabled</code>，符合布尔属性的规范</p>
<blockquote>
<p>也就是说 <code>Lombok</code> 也遵循了 JavaBeans 属性规范</p>
</blockquote>
</li>
</ol>
<h2 id="json-序列化与反序列化">JSON 序列化与反序列化</h2>
<p>因为我们平时是基于 <code>Spring Web</code> 提供 <code>HTTP</code> 接口，<code>Spring Web</code> 默认又是使用 <code>Jackson</code> 完成 JavaBean 实例与 JSON 之间的转换，所以我们基于 <code>Jackson</code> 来验证下 JavaBean 实例与 JSON 之间的转换是否正常；验证之前，我先调整下 <code>JavaBeanEntity</code> 的 <code>isEnabled</code> 方法</p>
<pre><code class="language-java">public boolean isEnabled() {
    System.out.println("isEnabled 方法被调用");
    return enabled;
}
</code></pre>
<p>增加了一行输出：<code>isEnabled 方法被调用</code>，方便验证 <code>isEnabled</code> 被调用了；我们先来看 Bean 实例转 JSON</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    JavaBeanEntity entity = new JavaBeanEntity();
    entity.setId("1");
    entity.setAge(18);
    entity.setEnabled(true);

    ObjectMapper mapper = new ObjectMapper();
    System.out.println(mapper.writeValueAsString(entity));
}
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517520-1091586963.png" alt="jackson_实例转json"></div>
<p>可以看到转换是没问题的；我们接着看下 JSON 转 Bean 实例</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    String jsonStr = "{\"id\":\"44\",\"age\":16,\"enabled\":false}";

    ObjectMapper mapper = new ObjectMapper();
    JavaBeanEntity javaBeanEntity = mapper.readValue(jsonStr, JavaBeanEntity.class);
    System.out.printf("id: %s, age: %d, enabled: %b%n",
            javaBeanEntity.getId(), javaBeanEntity.getAge(), javaBeanEntity.isEnabled());
}
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517503-36994614.png" alt="jackson_json转实例"></div>
<p>JSON 转实例也是没问题的；如果 <code>enabled</code> 的 getter 方法不是以 <code>is</code> 开头，而是以 <code>get</code> 开头，会不会有问题呢，我们来看下</p>
<pre><code class="language-java">public boolean getEnabled() {
    System.out.println("getEnabled 方法被调用");
    return enabled;
}
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517699-1187527297.png" alt="jackson_实例转json_boolean_get"></div>
<p>同样没问题；如果 <code>enabled</code> 的 getter 方法同时存在 <code>is</code> 和 <code>get</code>，是否如规范规定的那样：<code>is</code> 方法生效，我们来看看</p>
<pre><code class="language-java">public boolean isEnabled() {
    System.out.println("isEnabled 方法被调用");
    return enabled;
}

public boolean getEnabled() {
    System.out.println("getEnabled 方法被调用");
    return enabled;
}
</code></pre>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517849-642812709.png" alt="jackson_实例转json_get生效"></div>
<p>生效的竟然是 <code>getEnabled</code> 方法，不符合 JavaBeans 规范吖！！！这是为什么？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161518116-103373707.png" alt="20240115000802"></div>
<p>我们跟下 <code>Jackson</code> 的源码，版本 <code>2.13.5</code>，看看其实现；问题又来了：怎么跟 Jackson 的源码？切入点其实很好找，<code>getEnabled</code> 不是被调用了吗，直接在其方法体内打个断点</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517352-1853870153.png" alt="getEnabled断点"></div>
<p>然后 <code>debug</code> 运行，从调用栈中切入</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517496-1494887849.png" alt="getEnabled调用栈"></div>
<p>从上往下看，<code>invoke</code> 相关的就不用看了，这是反射调用，所以我们从 <code>serializeAsField</code> 开始寻找答案，直接鼠标左击调用栈中的 serializeAsField</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517704-1480524176.png" alt="debug_serializeAsField"></div>
<p>此时，已经采用 <code>getEnabled</code> 了，说明选择 <code>isEnabled</code> 还是 <code>getEnabled</code> 的逻辑已经完成了，我们应该继续往下看调用栈中的 <code>serializeFields</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517543-1875655827.png" alt="debug_serializeFields"></div>
<p>我们看下 <code>_props</code> 内容</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517788-1370864671.png" alt="debug_serializeFields_props"></div>
<p>此时，属性 <code>enabled</code> 的 getter 方法已经确定是 <code>genEnabled</code>，这个时候我们不能继续跟调用栈了，而是要跟 <code>_props</code> 的赋值过程了，跟的过程不是那么简单，我省略一部分，直接带你们看重点</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517967-2042746729.png" alt="findBeanProperties" width="900px"></div>
<p>两个 getter 方法目前都存在，<code>Jackson</code> 还未进行抉择，说明离真相很近了，我们继续跟进 <code>removeIgnorableTypes</code> ，一路跟进去，会来到 <code>POJOPropertyBuilder#getGetter</code> 方法</p>
<pre><code class="language-java">@Override
public AnnotatedMethod getGetter()
{
    // Easy with zero or one getters...
    Linked&lt;AnnotatedMethod&gt; curr = _getters;
    if (curr == null) {
        return null;
    }
    Linked&lt;AnnotatedMethod&gt; next = curr.next;
    if (next == null) {
        return curr.value;
    }
    // But if multiple, verify that they do not conflict...
    for (; next != null; next = next.next) {
        /* [JACKSON-255] Allow masking, i.e. do not report exception if one
         *   is in super-class from the other
         */
        Class&lt;?&gt; currClass = curr.value.getDeclaringClass();
        Class&lt;?&gt; nextClass = next.value.getDeclaringClass();
        if (currClass != nextClass) {
            if (currClass.isAssignableFrom(nextClass)) { // next is more specific
                curr = next;
                continue;
            }
            if (nextClass.isAssignableFrom(currClass)) { // current more specific
                continue;
            }
        }
        /* 30-May-2014, tatu: Three levels of precedence:
         * 
         * 1. Regular getters ("getX")
         * 2. Is-getters ("isX")
         * 3. Implicit, possible getters ("x")
         */
        int priNext = _getterPriority(next.value);
        int priCurr = _getterPriority(curr.value);

        if (priNext != priCurr) {
            if (priNext &lt; priCurr) {
                curr = next;
            }
            continue;
        }
        throw new IllegalArgumentException("Conflicting getter definitions for property \""+getName()+"\": "
                +curr.value.getFullName()+" vs "+next.value.getFullName());
    }
    // One more thing; to avoid having to do it again...
    _getters = curr.withoutNext();
    return curr.value;
}
</code></pre>
<p>代码就不分析了，相信你们都能看懂，我们来看下其中的注释</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517877-1107745134.png" alt="getter优先级"></div>
<p>结合 <code>_getterPriority</code></p>
<pre><code class="language-java">protected int _getterPriority(AnnotatedMethod m)
{
    final String name = m.getName();
    // [databind#238]: Also, regular getters have precedence over "is-getters"
    if (name.startsWith("get") &amp;&amp; name.length() &gt; 3) {
        // should we check capitalization?
        return 1;
    }
    if (name.startsWith("is") &amp;&amp; name.length() &gt; 2) {
        return 2;
    }
    return 3;
}
</code></pre>
<p>答案已然揭晓</p>
<blockquote>
<p>三个优先级，从高到底分别是</p>
<ol>
<li>常规 getters（<code>get&lt;PropertyName&gt;()</code>）</li>
<li>is getters（<code>is&lt;PropertyName&gt;()</code>）</li>
<li>隐式的，可能的 getters（<code>propertyName()</code>）</li>
</ol>
</blockquote>
<p>所以，生效的是 <code>getEnabled</code>，也就是说</p>
<blockquote>
<p>Jackson 2.13.5  对 JavaBean 属性的 getter 实现，遵循了 JavaBeans 规范，但又没完全遵循</p>
</blockquote>
<p>此刻，我觉得你们应该联想到其他问题</p>
<blockquote>
<ol>
<li>隐式的，可能的 getters（<code>propertyName()</code>）什么时候会生效</li>
<li>Jackson 的其他版本也是这样实现的吗</li>
<li>Hutool 的实现又是怎样的</li>
</ol>
</blockquote>
<p>知识面是不是一下就打开了？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517889-2126528456.png" alt="你懂我意思吧_不懂" width="300px"></div>
<h2 id="布尔包装类">布尔包装类</h2>
<p>我们仔细看 JavaBeans 规范对布尔类型的规定</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517456-121918287.png" alt="JavaBeans规范_boolean"></div>
<p>是不是只对布尔基础类型进行了规范，并未对其包装类型进行说明？既然官方都未说明，那各个实现者就可以按自己的规则来实现了</p>
<ol>
<li>
<p>IDEA</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
public class JavaBeanEntity {
    private String id;
    private Integer age;
    private Boolean enabled;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Boolean getEnabled() {
        return enabled;
    }

    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }
}
</code></pre>
<blockquote>
<p>属性 <code>enabled</code> 的类型是 <code>Boolean</code>，其 <code>getter</code> 方法是 <code>getEnabled</code></p>
</blockquote>
</li>
<li>
<p>Lombok</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517489-522984443.png" alt="Boolean_getter"></div>
<blockquote>
<p>属性 <code>enabled</code> 的类型是 <code>Boolean</code>，其 <code>getter</code> 方法是 <code>getEnabled</code></p>
</blockquote>
</li>
</ol>
<p>所以 <code>Boolean</code> 属性与 <code>boolean</code> 属性的 <code>getter</code> 实现有所不同，各个实现者可以按自己的规则来实现 <code>Boolean</code> 类型属性的 <code>getter</code></p>
<p>再带你们回顾下 Java开发手册 中的一项规约</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161518043-574150052.png" alt="基本数据类型与包装数据类型使用规范"></div>
<p>结合这项规约来看的话，JavaBeans 规范对布尔类型属性 getter 的规定，是不是就没什么约束力了？</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517326-2099490521.jpg" alt="你细品"></div>
<h2 id="is-前缀的布尔属性">is 前缀的布尔属性</h2>
<p>JavaBeans 规范并未明确规定 <code>is</code> 开头的布尔属性的 getter 该如何实现，那么套用规范中 <code>boolean</code> 属性的规则的话，getter 就会以两个 <code>is</code> 开头，例如 <code>isIsEnabled</code>，看着是不是有点反人类？所以实现者就会按自己的规则进行实现，同样以 <code>IDEA</code> 和 <code>Lombok</code> 为例，我们来看看它们是怎么实现这种情况的，先看基本数据类型 <code>boolean</code></p>
<ol>
<li>
<p>IDEA</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
public class JavaBeanEntity {
    private String id;
    private Integer age;
    private boolean isEnabled;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public boolean isEnabled() {
        return isEnabled;
    }

    public void setEnabled(boolean enabled) {
        isEnabled = enabled;
    }
}
</code></pre>
<blockquote>
<p>getter 是 <code>isEnabled</code>，setter 是 <code>setEnabled</code>，并未遵循 JavaBean 规范</p>
</blockquote>
<p>此时 JSON 序列化，得到的字符串是</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517829-1653320553.png" alt="is开头_json序列化"></div>
<p>看仔细了，key 值是 <code>enabled</code>，而非 <code>isEnabled</code>；那么 JSON 串</p>
<pre><code class="language-json">{
    "id": "44",
    "age": 16,
    "isEnabled": true
}
</code></pre>
<p>反序列化得到的 JavaBeanEntity 实例，其 isEnabled 值是什么？</p>
</li>
<li>
<p>Lombok</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517583-1716163724.png" alt="is开头_json序列化_lombok"></div>
<blockquote>
<p>getter 是 <code>isEnabled</code>，setter 是 <code>setEnabled</code>，并未遵循 JavaBean 规范</p>
</blockquote>
<p>与 <code>IDEA</code> 实现一致</p>
</li>
</ol>
<p>再看看包装数据类型 <code>Boolean</code></p>
<ol>
<li>
<p>IDEA</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
public class JavaBeanEntity {
    private String id;
    private Integer age;
    private Boolean isEnabled;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Boolean getEnabled() {
        return isEnabled;
    }

    public void setEnabled(Boolean enabled) {
        isEnabled = enabled;
    }
}
</code></pre>
<blockquote>
<p>getter 是 <code>getEnabled</code>，setter 是 <code>setEnabled</code></p>
</blockquote>
<p>JSON序列化与反序列化的结果是什么？我相信你们能立马答出来</p>
</li>
<li>
<p>Lombok</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517888-1787416050.png" alt="is开头_Boolean_getter"></div>
<blockquote>
<p>getter 是 <code>getIsEnabled</code>，setter 是 <code>setIsEnabled</code></p>
</blockquote>
<p>此时 JSON 序列化的结果</p>
<pre><code class="language-json">{
    "id": "1",
    "age": 18,
    "isEnabled": true
}
</code></pre>
<p>key 值与 JavaBeanEntity 的属性名完全对应上了；那么 JSON 串</p>
<pre><code class="language-json">{
    "id": "44",
    "age": 16,
    "isEnabled": true
}
</code></pre>
<p>反序列化得到的 JavaBeanEntity 实例，其 isEnabled 值是什么？</p>
</li>
</ol>
<h2 id="要不要加-is-前缀">要不要加 is 前缀</h2>
<p>关于布尔类型的属性，并且是 <code>Boolean</code> 类型的属性，能不能加 <code>is</code> 前缀，答案肯定是能的，但是不推荐，我们来看看 <code>deepseek</code> 是怎么说的</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161517508-1675230513.png" alt="deepseek建议"></div>
<p>在你们心中，<code>Boolean</code> 类型的属性名，<code>is</code> 前缀是不是有了替代方案？</p>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>JavaBeans 规范，只对 <code>boolean</code> 属性进行了规定，并未对 <code>Boolean</code> 属性进行规定，不同的实现者对 <code>Boolean</code> 属性的 getter 的实现可能各不相同，大家不要觉得不可理解</p>
</li>
<li>
<p>老老实实遵循 <a href="https://developer.aliyun.com/topic/java20" target="_blank" rel="noopener nofollow">Java开发手册</a>，可以规避很多前人踩过的坑</p>
<p>与本文相关的就是</p>
<ol>
<li>POJO 类中的任何布尔类型的变量，都不要加 is 前缀</li>
<li>所有的 POJO 类属性必须使用包装数据类型，RPC 方法的返回值和参数必须使用包装数据类型，所有的局部变量推荐使用基本数据类型</li>
</ol>
</li>
<li>
<p>说<a href="https://www.cnblogs.com/youzhibing/p/18958862" target="_blank">都说了布尔类型的变量不要加 is 前缀，非要加，这不是坑我了嘛</a>是水文，鄙人实难苟同</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202508/747662-20250812161518564-739024780.gif" alt="BD12305694818934"></div>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-13 09:04">2025-08-13 09:04</span>&nbsp;
<a href="https://www.cnblogs.com/youzhibing">青石路</a>&nbsp;
阅读(<span id="post_view_count">241</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19034101);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19034101', targetLink: 'https://www.cnblogs.com/youzhibing/p/19034101', title: '关于布尔类型的变量不要加 is 前缀，被网友们吐槽了，特来完善下' })">举报</a>
</div>
        