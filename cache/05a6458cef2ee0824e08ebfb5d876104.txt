
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kitty-38/p/18684844" title="发布于 2025-01-22 01:44">
    <span role="heading" aria-level="2">JavaScript的其他常用库</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3588703/202501/3588703-20250122014327500-1663191662.png" alt="JavaScript的其他常用库" class="desc_img">
        setTimeout与setInterval、requestAnimationFrame、Map与Set、localStorage、JSON、日期、WebSocket、window、canvas等常用库ε=ε=ε=(~￣▽￣)~
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<h1 id="settimeout与setinterval">setTimeout与setInterval</h1>
</blockquote>
<h3 id="settimeoutfunc-delay--delay毫秒后执行函数func"><code>setTimeout(func, delay)</code>  ：delay毫秒后，执行函数func()。</h3>
<p>例如：</p>
<pre><code>let main = function() {
    let $div = $('div');

    $div.click(function() {
        setTimeout(function() {  // 2秒后执行函数
            console.log("hello");
        }, 2000);
    });
}

export {
    main
}
</code></pre>
<br>
<h3 id="cleartimeout--关闭定时器"><code>clearTimeout()</code>  ：关闭定时器。</h3>
<p>例如：</p>
<pre><code>let timeout_id = setTimeout(function() {
    console.log("Hello World!")
}, 2000);  // 2秒后在控制台输出"Hello World"

clearTimeout(timeout_id);  // 清除定时器
</code></pre>
<br>
<h3 id="setintervalfunc-delay-每隔delay毫秒执行一次函数func第一次在第delay毫秒后执行"><code>setInterval(func, delay)</code> ：每隔delay毫秒，执行一次函数func()。第一次在第delay毫秒后执行。</h3>
<p>例如：</p>
<pre><code>let main = function() {
    let $div = $('div');

    $div.click(function() {
        setInterval(function() {  // 每2秒执行一次函数
            console.log("hello");
        }, 2000);
    });
}

export {
    main
}
</code></pre>
<br>
<h3 id="clearinterval-关闭周期执行的函数"><code>clearInterval()</code> ：关闭周期执行的函数。</h3>
<p>例如：</p>
<pre><code>let interval_id = setInterval(() =&gt; {
    console.log("Hello World!")
}, 2000);  // 每隔2秒，输出一次"Hello World"

clearInterval(interval_id);  // 清除周期执行的函数
</code></pre>
<br>
<br>
<blockquote>
<h1 id="requestanimationframe">requestAnimationFrame</h1>
</blockquote>
<h3 id="requestanimationframefunc-该函数会在下次浏览器刷新页面之前执行一次通常会用递归写法使其每秒执行60次func函数调用时会传入一个参数表示函数执行的时间戳单位为毫秒"><code>requestAnimationFrame(func)</code> ：该函数会在下次浏览器刷新页面之前执行一次，通常会用递归写法使其每秒执行60次<code>func</code>函数。调用时会传入一个参数，表示函数执行的时间戳，单位为毫秒。</h3>
<p>例如：</p>
<pre><code>let step = (timestamp) =&gt; {  // 每帧将div的宽度增加1像素
    let div = document.querySelector('div');
    div.style.width = div.clientWidth + 1 + 'px';
    requestAnimationFrame(step);
};

requestAnimationFrame(step);
</code></pre>
<p>例如：</p>
<pre><code>let main = function() {
    let step = () =&gt; {   // 每帧将div的宽度增加1像素
        $('div').width($('div').width() + 1);
        requestAnimationFrame(step);
    };

    requestAnimationFrame(step);
}

export {
    main
}
</code></pre>
<br>
<h2 id="与settimeout和setinterval的区别">与<code>setTimeout</code>和<code>setInterval</code>的区别：</h2>
<ul>
<li>
<h3 id="requestanimationframe渲染动画的效果更好性能更加">requestAnimationFrame渲染动画的效果更好，性能更加。</h3>
</li>
<li>
<h3 id="该函数可以保证每两次调用之间的时间间隔相同但settimeout与setinterval不能保证这点settmeout两次调用之间的间隔包含回调函数的执行时间setinterval只能保证按固定时间间隔将回调函数压入栈中但具体的执行时间间隔仍然受回调函数的执行时间影响">该函数可以保证每两次调用之间的时间间隔相同，但setTimeout与setInterval不能保证这点。setTmeout两次调用之间的间隔包含回调函数的执行时间；setInterval只能保证按固定时间间隔将回调函数压入栈中，但具体的执行时间间隔仍然受回调函数的执行时间影响。</h3>
</li>
<li>
<h3 id="当页面在后台时因为页面不再渲染因此requestanimationframe不再执行但settimeout与setinterval函数会继续执行">当页面在后台时，因为页面不再渲染，因此requestAnimationFrame不再执行。但setTimeout与setInterval函数会继续执行。</h3>
</li>
</ul>
<br>
<br>
<blockquote>
<h1 id="map与set">Map与Set</h1>
</blockquote>
<h2 id="map">Map：</h2>
<h3 id="map-对象保存键值对"><code>Map</code> 对象保存键值对。</h3>
<ul>
<li>
<h3 id="用forof或者foreach可以按插入顺序遍历">用<code>for...of</code>或者<code>forEach</code>可以按插入顺序遍历。</h3>
</li>
<li>
<h3 id="键值可以为任意值包括函数对象或任意基本类型">键值可以为任意值，包括函数、对象或任意基本类型。</h3>
</li>
</ul>
<br>
<h3 id="常用api">常用API：</h3>
<ul>
<li>
<h3 id="setkey-value插入键值对如果key已存在则会覆盖原有的value"><code>set(key, value)</code>：插入键值对，如果key已存在，则会覆盖原有的value</h3>
</li>
<li>
<h3 id="getkey查找关键字如果不存在返回undefined"><code>get(key)</code>：查找关键字，如果不存在，返回undefined</h3>
</li>
<li>
<h3 id="size返回键值对数量"><code>size</code>：返回键值对数量</h3>
</li>
<li>
<h3 id="haskey返回是否包含关键字key"><code>has(key)</code>：返回是否包含关键字key</h3>
</li>
<li>
<h3 id="deletekey删除关键字key"><code>delete(key)</code>：删除关键字key</h3>
</li>
<li>
<h3 id="clear删除所有元素"><code>clear()</code>：删除所有元素</h3>
</li>
</ul>
<p>&nbsp;</p>
<p>例如：</p>
<pre><code>let main = function() {
    let map = new Map();  // 定义一个map

    map.set('name', 'kitty');  // 插入键值对
    map.set('age', 18);
    console.log(map);

    console.log(map.get('name'));  // 查找值

    console.log(map.size);  // 返回元素数量

    for (let [key, value] of map) {  // 遍历
        console.log(key, value);
    };

    map.forEach(function(value, key) {  // 遍历
        console.log(key, value);
    });

    map.delete('age');  // 删除
    console.log(map);

    map.clear();  // 清空
    console.log(map);
}

export {
    main
}
</code></pre>
<br>
<h2 id="set">Set：</h2>
<h3 id="set-对象允许你存储任何类型的唯一值无论是原始值或者是对象引用"><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</h3>
<ul>
<li>
<h3 id="用forof或者foreach可以按插入顺序遍历-1">用<code>for...of</code>或者<code>forEach</code>可以按插入顺序遍历。</h3>
</li>
</ul>
<br>
<h3 id="常用api-1">常用API：</h3>
<ul>
<li>
<h3 id="add添加元素"><code>add()</code>：添加元素</h3>
</li>
<li>
<h3 id="has返回是否包含某个元素"><code>has()</code>：返回是否包含某个元素</h3>
</li>
<li>
<h3 id="size返回元素数量"><code>size</code>：返回元素数量</h3>
</li>
<li>
<h3 id="delete删除某个元素"><code>delete()</code>：删除某个元素</h3>
</li>
<li>
<h3 id="clear删除所有元素-1"><code>clear()</code>：删除所有元素</h3>
</li>
</ul>
<p>&nbsp;</p>
<p>例如：</p>
<pre><code>let main = function() {
    let set = new Set();  // 定义一个set

    set.add('name');  // 插入
    set.add(18);
    
    set.add(()=&gt; {  // 插入函数
        console.log("hello");
    });

    console.log(set);

    set.delete(18);  // 删除
    console.log(set);

    console.log(set.has(18));  // 返回是否存在18

    console.log(set.size);  // 返回元素的数量

    set.clear();  // 清空
    console.log(set);
    
}

export {
    main
}
</code></pre>
<br>
<br>
<blockquote>
<h1 id="localstorage">localStorage</h1>
</blockquote>
<h3 id="可以在用户的浏览器上存储键值对">可以在用户的浏览器上存储键值对。</h3>
<h3 id="常用api-2">常用API：</h3>
<ul>
<li>
<h3 id="setitemkey-value插入"><code>setItem(key, value)</code>：插入</h3>
</li>
<li>
<h3 id="getitemkey查找"><code>getItem(key)</code>：查找</h3>
</li>
<li>
<h3 id="removeitemkey删除"><code>removeItem(key)</code>：删除</h3>
</li>
<li>
<h3 id="clear清空"><code>clear()</code>：清空</h3>
</li>
</ul>
<p>&nbsp;<br>
例如：</p>
<pre><code>let main = function() {
    localStorage.setItem('name', 'kitty');  // 在用户的浏览器上存储键值对
    console.log(localStorage.getItem('name'));  // 查找

    localStorage.removeItem('name');  // 删除
    console.log(localStorage.getItem('name'));  // 查找

    localStorage.clear();  // 清空
    console.log(localStorage);
    
}

export {
    main
}
</code></pre>
<br>
<br>
<blockquote>
<h1 id="json">JSON</h1>
</blockquote>
<h3 id="json对象用于序列化对象数组数值字符串布尔值和null">JSON对象用于序列化对象、数组、数值、字符串、布尔值和null。</h3>
<h3 id="常用api-3">常用API：</h3>
<ul>
<li>
<h3 id="jsonparse将字符串解析成对象"><code>JSON.parse()</code>：将字符串解析成对象</h3>
</li>
<li>
<h3 id="jsonstringify将对象转化为字符串"><code>JSON.stringify()</code>：将对象转化为字符串</h3>
</li>
</ul>
<p>&nbsp;<br>
例如：</p>
<pre><code>let main = function() {
    let obj = {
        name: "kitty",
        age:18,
    };

    let str = JSON.stringify(obj);  // 将对象转化为字符串
    console.log(typeof str);  // 返回string

    let new_obj = JSON.parse(str);  // 将字符串解析成对象
    console.log(typeof new_obj);  // 返回object
    
}

export {
    main
}
</code></pre>
<br>
<br>
<blockquote>
<h1 id="日期">日期</h1>
</blockquote>
<h3 id="返回值为整数的api数值为1970-1-1-000000-utc世界标准时间到某个时刻所经过的毫秒数">返回值为整数的API，数值为1970-1-1 00:00:00 UTC（世界标准时间）到某个时刻所经过的毫秒数：</h3>
<ul>
<li>
<h3 id="datenow返回现在时刻"><code>Date.now()</code>：返回现在时刻。</h3>
</li>
<li>
<h3 id="dateparse2022-04-15t1530000000800返回北京时间2022年4月15日-153000的时刻"><code>Date.parse("2022-04-15T15:30:00.000+08:00")</code>：返回北京时间2022年4月15日 15:30:00的时刻。</h3>
</li>
</ul>
<br>
<h3 id="与date对象的实例相关的api">与<code>Date</code>对象的实例相关的API：</h3>
<ul>
<li>
<h3 id="new-date返回现在时刻"><code>new Date()</code>：返回现在时刻。</h3>
</li>
<li>
<h3 id="new-date2022-04-15t1530000000800返回北京时间2022年4月15日-153000的时刻"><code>new Date("2022-04-15T15:30:00.000+08:00")</code>：返回北京时间2022年4月15日 15:30:00的时刻。</h3>
</li>
<li>
<h3 id="两个date对象实例的差值为毫秒数">两个Date对象实例的差值为毫秒数</h3>
</li>
<li>
<h3 id="getday返回星期0表示星期日1-6表示星期一至星期六"><code>getDay()</code>：返回星期，0表示星期日，1-6表示星期一至星期六</h3>
</li>
<li>
<h3 id="getdate返回日数值为1-31"><code>getDate()</code>：返回日，数值为1-31</h3>
</li>
<li>
<h3 id="getmonth返回月数值为0-11"><code>getMonth()</code>：返回月，数值为0-11</h3>
</li>
<li>
<h3 id="getfullyear返回年份"><code>getFullYear()</code>：返回年份</h3>
</li>
<li>
<h3 id="gethours返回小时"><code>getHours()</code>：返回小时</h3>
</li>
<li>
<h3 id="getminutes返回分钟"><code>getMinutes()</code>：返回分钟</h3>
</li>
<li>
<h3 id="getseconds返回秒"><code>getSeconds()</code>：返回秒</h3>
</li>
<li>
<h3 id="getmilliseconds返回毫秒"><code>getMilliseconds()</code>：返回毫秒</h3>
</li>
</ul>
<p>&nbsp;<br>
例如：</p>
<pre><code>let main = function() {
    console.log(Date.now());  // 返回数值为1970-1-1 00:00:00 UTC（世界标准时间）到现在时刻所经过的毫秒数

    console.log(Date.parse("2025-01-22T15:30:00.000+08:00"));  // 返回1970-1-1 00:00:00 UTC（世界标准时间）到北京时间2025年1月22日15:30:00的时刻所经过的毫秒数

    let starttime = new Date();  
    //let starttime = new Date("2025-01-22T15:30:00.000+08:00");   返回北京时间2025年1月22日 15:30:00的时刻
    console.log(starttime);  // 返回现在的时间

    console.log(starttime.getDay());  // 返回星期，0表示星期日，1-6表示星期一至星期六

    console.log(starttime.getDate()); // 返回日，数值为1-31

    console.log(starttime.getMonth());  // 返回月，数值为0-11

    console.log(starttime.getFullYear());  // 返回年份

    console.log(starttime.getHours());  // 返回小时

    console.log(starttime.getMinutes());  // 返回分钟

    console.log(starttime.getSeconds());  // 返回秒

    console.log(starttime.getMilliseconds());  // 返回毫秒
 
}

export {
    main
}
</code></pre>
<br>
<br>
<blockquote>
<h1 id="websocket">WebSocket</h1>
</blockquote>
<h3 id="与服务器建立全双工连接">与服务器建立全双工连接。</h3>
<h3 id="常用api-4">常用API：</h3>
<ul>
<li>
<h3 id="new-websocketwslocalhost8080建立ws连接"><code>new WebSocket('ws://localhost:8080');</code>：建立ws连接。</h3>
</li>
<li>
<h3 id="send向服务器端发送一个字符串一般用json将传入的对象序列化为字符串"><code>send()</code>：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。</h3>
</li>
<li>
<h3 id="onopen类似于onclick当连接建立时触发"><code>onopen</code>：类似于onclick，当连接建立时触发。</h3>
</li>
<li>
<h3 id="onmessage当从服务器端接收到消息时触发"><code>onmessage</code>：当从服务器端接收到消息时触发。</h3>
</li>
<li>
<h3 id="close关闭连接"><code>close()</code>：关闭连接。</h3>
</li>
<li>
<h3 id="onclose当连接关闭后触发"><code>onclose</code>：当连接关闭后触发。</h3>
</li>
</ul>
<br>
<br>
<blockquote>
<h1 id="window">window</h1>
</blockquote>
<ul>
<li>
<h3 id="windowopenhttpswwwacwingcom在新标签栏中打开页面"><code>window.open("https://www.acwing.com")</code>：在新标签栏中打开页面。</h3>
</li>
<li>
<h3 id="locationreload刷新页面"><code>location.reload()</code>：刷新页面。</h3>
</li>
<li>
<h3 id="locationhref--httpswwwacwingcom在当前标签栏中打开页面"><code>location.href = "https://www.acwing.com"</code>：在当前标签栏中打开页面。</h3>
</li>
</ul>
<br>
<br>
<blockquote>
<h1 id="canvas">canvas</h1>
</blockquote>
<p>画布</p>
<h3 id="canvas教程httpsdevelopermozillaorgzh-cndocswebapicanvas_apitutorial">canvas教程：<code>https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial</code></h3>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.522626408709491" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 01:47">2025-01-22 01:44</span>&nbsp;
<a href="https://www.cnblogs.com/kitty-38">kitty又困了</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18684844" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18684844);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18684844', targetLink: 'https://www.cnblogs.com/kitty-38/p/18684844', title: 'JavaScript的其他常用库' })">举报</a>
</div>
        