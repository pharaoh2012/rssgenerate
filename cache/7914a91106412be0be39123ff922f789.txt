
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Saintwaters/p/19065616" title="发布于 2025-08-30 11:34">
    <span role="heading" aria-level="2">Java深拷贝与浅拷贝核心解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>​</p>
<h2 id="java深拷贝与浅拷贝的概念">Java深拷贝与浅拷贝的概念</h2>
<p>浅拷贝（Shallow Copy）只复制对象的引用，而不复制对象本身。拷贝后的对象和原对象共享同一块内存地址中的子对象。修改其中一个对象的非基本类型属性时，另一个对象的对应属性也会被修改。</p>
<p>深拷贝（Deep Copy）会复制对象及其所有子对象，生成一个完全独立的新对象。拷贝后的对象和原对象完全分离，修改其中一个对象的属性不会影响另一个对象。</p>
<h3 id="内存分析示例">内存分析示例</h3>
<p>假设有一个Person类，包含name（String）和address（Address类）属性：</p>
<pre><code>class Address {
    String city;
    // 构造方法、getter/setter省略
}

class Person implements Cloneable {
    String name;
    Address address;
    
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 默认浅拷贝
    }
}
</code></pre>
<h2 id="浅拷贝实现与内存表现">浅拷贝实现与内存表现</h2>
<pre><code>Person p1 = new Person();
p1.name = "Alice";
p1.address = new Address("Beijing");

Person p2 = (Person)p1.clone();
</code></pre>
<h3 id="内存表现">内存表现：</h3>
<p>p1和p2是两个独立对象，但它们的address属性指向同一个Address对象<br>
修改p2.address.city会影响p1.address.city</p>
<h2 id="深拷贝实现方式">深拷贝实现方式</h2>
<h3 id="方法1重写clone">方法1：重写clone()</h3>
<pre><code>@Override
protected Object clone() throws CloneNotSupportedException {
    Person cloned = (Person)super.clone();
    cloned.address = (Address)this.address.clone(); // 递归克隆引用对象
    return cloned;
}
</code></pre>
<h3 id="方法2序列化实现">方法2：序列化实现</h3>
<pre><code>public Person deepCopy() throws IOException, ClassNotFoundException {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(this);
    
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return (Person)ois.readObject();
}
</code></pre>
<h3 id="内存表现-1">内存表现：</h3>
<p>p1和p2完全独立，包括所有引用类型属性<br>
修改p2.address.city不会影响p1.address.city</p>
<h2 id="性能与适用场景">性能与适用场景</h2>
<h3 id="浅拷贝">浅拷贝：</h3>
<p>性能更好，仅复制引用<br>
适合引用对象不可变或不需要独立修改的场景</p>
<h3 id="深拷贝">深拷贝：</h3>
<p>性能开销较大，需要递归复制所有对象<br>
适合需要完全独立对象的场景，如多线程环境</p>
<h2 id="注意事项">注意事项</h2>
<p>String等不可变对象在浅拷贝中是安全的<br>
数组的clone()方法是浅拷贝<br>
深拷贝可能导致循环引用问题<br>
使用第三方库（如Apache Commons Lang的SerializationUtils）可以简化深拷贝实现<br>
​</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-30 11:35">2025-08-30 11:34</span>&nbsp;
<a href="https://www.cnblogs.com/Saintwaters">三水彡彡</a>&nbsp;
阅读(<span id="post_view_count">43</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19065616);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19065616', targetLink: 'https://www.cnblogs.com/Saintwaters/p/19065616', title: 'Java深拷贝与浅拷贝核心解析' })">举报</a>
</div>
        