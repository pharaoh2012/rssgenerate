
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18997181" title="发布于 2025-07-22 09:37">
    <span role="heading" aria-level="2">微服务的10大问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>作为工作多年的老司机，我主导过3次微服务重构，见过太多团队掉进微服务陷阱：<strong>拆分时春风得意，运维时步履维艰</strong>。</p>
<p>某电商平台从单体拆分为120个微服务后，故障率飙升300%，排障时间从10分钟恶化到3小时。</p>
<p>这篇文章跟大家一起聊聊微服务中的10个最常见的问题，希望对你会有所帮助。</p>
<h2 id="1错误的拆分问题">1.错误的拆分问题</h2>
<p><strong>典型场景</strong>：按代码包名拆分服务</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093438782-973329627.png" class="lazyload"></p>
<p><strong>后果</strong>：</p>
<ul>
<li>订单查询需调用4个服务</li>
<li>接口延迟从50ms→350ms</li>
<li>链路追踪日志爆炸式增长</li>
</ul>
<p><strong>正确方案</strong>：基于业务能力拆分</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093453412-2013193759.png" class="lazyload"></p>
<p><strong>拆分原则</strong>：</p>
<ol>
<li>单一职责（一个服务解决一类问题）</li>
<li>团队自治（2 Pizza Team可独立交付）</li>
<li>数据自治（服务独占数据库）</li>
</ol>
<h2 id="2分布式事务问题">2.分布式事务问题</h2>
<p><strong>错误示范</strong>：跨服务数据库操作</p>
<pre><code class="language-java">@Transactional // 本地事务失效！  
public void createOrder(OrderDTO dto) {  
    // 1.订单服务写库  
    orderService.save(dto);  
    
    // 2.调用库存服务  
    stockFeignClient.deduct(dto.getSkuId());  
}  
</code></pre>
<p><strong>后果</strong>：订单创建成功但库存未扣减 → <strong>超卖事故</strong></p>
<p><strong>解决方案</strong>：Saga模式 + 可靠事件</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093506892-356934373.png" class="lazyload"></p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-java">@SagaStart  
public void createOrder(OrderDTO dto) {  
    Saga.with("freezeStock", () -&gt; stockClient.freeze(dto))  
        .with("saveOrder", () -&gt; orderService.save(dto))  
        .compensate("saveOrder", () -&gt; orderService.delete(dto.getId()))  
        .compensate("freezeStock", () -&gt; stockClient.unfreeze(dto))  
        .execute();  
}  
</code></pre>
<h2 id="3连环雪崩问题">3.连环雪崩问题</h2>
<p><strong>场景复现</strong>：服务A → 服务B → 服务C，C超时导致全链路崩溃</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093517054-1356565379.png" class="lazyload"></p>
<p><strong>防御方案</strong>：熔断+降级+超时</p>
<pre><code class="language-java">@FeignClient(name = "stock-service",  
  configuration = FeignConfig.class,  
  fallback = StockFallback.class) // 降级类  
public interface StockClient {  
    @GetMapping("/deduct")  
    @TimeLimiter(fallbackMethod = "defaultResult") // 超时控制  
    CompletableFuture&lt;Boolean&gt; deduct(@RequestParam String skuId);  
}  

// 熔断配置  
circuitBreaker:  
  failureRateThreshold: 50  
  waitDurationInOpenState: 10s  
  slidingWindowSize: 20  
</code></pre>
<h2 id="4配置管理混乱问题">4.配置管理混乱问题</h2>
<p><strong>反模式</strong>：配置文件散落各服务</p>
<pre><code>├── user-service  
│   ├── application-dev.yml  
│   ├── application-prod.yml  
├── order-service  
│   ├── application-dev.yml  
│   └── application-prod.yml  
</code></pre>
<p><strong>后果</strong>：</p>
<ul>
<li>修改日志级别需重新部署10个服务</li>
<li>生产环境误用dev配置</li>
</ul>
<p><strong>正确方案</strong>：统一配置中心</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093531291-657414305.png" class="lazyload"></p>
<p><strong>关键配置</strong>：</p>
<pre><code class="language-yaml">spring:  
  cloud:  
    nacos:  
      config:  
        server-addr: 192.168.1.10:8848  
        file-extension: yaml  
        shared-configs:  
          - data-id: common.yaml # 公共配置  
</code></pre>
<h2 id="5日志追踪碎片化问题">5.日志追踪碎片化问题</h2>
<p><strong>问题现象</strong>：</p>
<pre><code>[user-service] 用户查询成功 userId=100  
[order-service] 订单创建失败 userId=100  
[payment-service] 支付超时 userId=100  
</code></pre>
<p><strong>痛苦</strong>：跨3个日志系统拼凑调用链</p>
<p><strong>解决方案</strong>：Sleuth+Zipkin全链路追踪</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093542955-1656195686.png" class="lazyload"></p>
<p><strong>日志格式</strong>：</p>
<pre><code>2023-08-20 14:30 [user-service,7a3b,9f2c] INFO 用户查询  
2023-08-20 14:30 [order-service,7a3b,d8e1] ERROR 订单创建失败  
</code></pre>
<p>其中：</p>
<ul>
<li><code>7a3b</code>：全局Trace ID</li>
<li><code>9f2c/d8e1</code>：各服务ID</li>
</ul>
<h2 id="6数据库拆分问题">6.数据库拆分问题</h2>
<p><strong>错误操作</strong>：服务共用数据库</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093553794-201633860.png" class="lazyload"></p>
<p><strong>后果</strong>：</p>
<ul>
<li>订单表锁阻塞用户注册</li>
<li>无法独立扩缩容</li>
</ul>
<p><strong>正确设计</strong>：数据库垂直拆分</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093610771-1200271625.png" class="lazyload"></p>
<p><strong>分库分表策略</strong>：</p>
<pre><code class="language-java">// 用户ID取模分片  
public String determineDatabase(Long userId) {  
    int dbIndex = userId % 4;  
    return "user_db_" + dbIndex;  
}  
</code></pre>
<h2 id="7接口兼容性问题">7.接口兼容性问题</h2>
<p><strong>血案</strong>：订单服务升级v2接口，未通知支付服务</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093622642-1393985169.png" class="lazyload"></p>
<p><strong>解决方案</strong>：三版本策略</p>
<pre><code>/v1/createOrder (旧版)  
/v2/createOrder (新版)  
/v3/createOrder (预发布)  
</code></pre>
<p><strong>Spring Cloud灰度发布</strong>：</p>
<pre><code class="language-yaml">spring:  
  cloud:  
    gateway:  
      routes:  
        - id: order_v2  
          uri: lb://order-service  
          predicates:  
            - Header=version, v2  
          filters:  
            - StripPrefix=1  
</code></pre>
<h2 id="8持续集成问题">8.持续集成问题</h2>
<p><strong>典型问题</strong>：120个服务独立构建 → 流水线拥堵</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093633498-1661607126.png" class="lazyload"></p>
<p><strong>优化方案</strong>：</p>
<ol>
<li><strong>分层构建</strong>：</li>
</ol>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093644317-1210279629.png" class="lazyload"></p>
<ol start="2">
<li><strong>并行构建</strong>：</li>
</ol>
<pre><code class="language-groovy">// Jenkinsfile并行配置  
stage('Parallel Build') {  
  parallel {  
      stage('Service A') { steps { sh './build-serviceA.sh' } }  
      stage('Service B') { steps { sh './build-serviceB.sh' } }  
  }  
}  
</code></pre>
<h2 id="9监控缺失问题">9.监控缺失问题</h2>
<p><strong>惨痛教训</strong>：</p>
<ul>
<li>磁盘写满8小时无人察觉</li>
<li>数据库连接池耗尽导致全站崩溃</li>
</ul>
<p><strong>监控体系黄金四件套</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093658025-1074724463.png" class="lazyload"></p>
<p><strong>关键告警规则</strong>：</p>
<pre><code class="language-yaml">rules:  
  - alert: HighErrorRate  
    expr: sum(rate(http_server_requests_errors_total[5m])) &gt; 0.5  
    for: 2m  
  - alert: DBConnectionExhausted  
    expr: db_connections_active &gt; db_connections_max * 0.9  
    for: 1m  
</code></pre>
<h2 id="10团队协作问题">10.团队协作问题</h2>
<p><strong>现实困境</strong>：</p>
<table>
<thead>
<tr>
<th>团队</th>
<th>技术栈</th>
<th>部署方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户组</td>
<td>Java+MySQL</td>
<td>K8s</td>
</tr>
<tr>
<td>订单组</td>
<td>Go+Postgres</td>
<td>VM</td>
</tr>
<tr>
<td>支付组</td>
<td>Node+Mongo</td>
<td>Serverless</td>
</tr>
</tbody>
</table>
<p><strong>解决方案</strong>：</p>
<h3 id="101统一技术公约">10.1统一技术公约</h3>
<ol>
<li>RESTful接口规范</li>
<li>错误码全局定义</li>
<li>日志格式标准</li>
<li>健康检查端点<code>/actuator/health</code></li>
</ol>
<h3 id="102基础设施共享">10.2基础设施共享</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093711193-740540707.png" class="lazyload"></p>
<h2 id="总结">总结</h2>
<p>由此可见，微服务如果用不好问题还是挺多的，需要有丰富的实战经验，才能把微服务项目真正的做好。</p>
<p><strong>微服务的三层防御体系</strong>：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250722093722724-1969429925.png" class="lazyload"></p>
<p><strong>微服务的十条军规</strong>：</p>
<ol>
<li>服务粒度按业务能力而非代码量</li>
<li>跨服务事务用最终一致性替代强一致</li>
<li>必须配置熔断超时阈值</li>
<li>配置中心统一管理所有环境参数</li>
<li>全链路追踪ID穿透所有服务</li>
<li>每个服务独占数据库</li>
<li>接口版本兼容至少2个迭代</li>
<li>建立分层构建流水线</li>
<li>核心指标监控覆盖率100%</li>
<li>制定跨团队技术公约</li>
</ol>
<blockquote>
<p>微服务的本质不是技术升级，而是组织关系的重构。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-22 09:38">2025-07-22 09:37</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">498</span>)&nbsp;
评论(<span id="post_comment_count">6</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18997181);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18997181', targetLink: 'https://www.cnblogs.com/12lisu/p/18997181', title: '微服务的10大问题' })">举报</a>
</div>
        