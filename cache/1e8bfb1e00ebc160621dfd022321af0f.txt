
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18995014" title="发布于 2025-07-21 02:03">
    <span role="heading" aria-level="2">【暑期多校补题记录】2025牛客多校(1)(2) 杭电多校(1)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18995014" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18995014" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18995014</a></p>
<h2 id="开题情况">开题情况</h2>
<p>7.15牛客多校1 ： 4题 - EGKL<br>
7.17牛客多校2 ： 5题 - ABFIL<br>
7.18杭电多校1 ： 4题 - 5、6、9、10</p>
<p>总的来说符合我们正常发挥，但每场都有瓶颈卡啊，慢慢补题查漏补缺吧。</p>
<h2 id="本人个人补题情况">本人个人补题情况</h2>
<p>7.15牛客多校1 ： 0题 -<br>
7.17牛客多校2 ： 1题 - G<br>
7.18杭电多校1 ： 2题 - 3、7</p>
<p>这周还在考试，加上有东西不会学得慢，补的有点慢T_T。</p>
<h2 id="牛客多校1补题">牛客多校1补题</h2>
<h2 id="牛客多校2补题">牛客多校2补题</h2>
<h3 id="g---几何朋友">G - 几何，朋友</h3>
<p>这个题，赛时思路完全正确，但对于角度的处理不当，导致被卡精度。<br>
思路：</p>
<ul>
<li>如果点在凸多边形外，则一定是 <span class="math inline">\(2\pi\)</span>，因为最后会形成一个同心圆，而靠内的圆一定是由一个点旋转得来，因为以点为圆心做圆，和凸多边形相切的点，最多只会有一个。</li>
<li>如果点在凸多边形内，则最后一定会形成一个圆，所以只需要考虑距离点最远的点，这些远点和旋转点形成的边，取相邻最大角度，就是答案，因为最大的被覆盖过了，则更小的角也一定会被覆盖到。</li>
</ul>
<p>对于角度的处理，赛时选择了逆时针依次求向量夹角 + 判断方向，如果方向得到的是顺时针，则要用 <span class="math inline">\(2\pi\)</span> 减去求得的夹角，才是真正旋转时的角度。<br>
但这样一直过不去，大概率是被卡精度了。<br>
赛后使用 <span class="math inline">\(atan2\)</span> 函数一发过掉（赛时不知道这个函数T_T）。</p>
<details>
<summary>点击查看代码（包含计算几何大模板）</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
#define double long double

const double eps = 1e-25;	// 根据题目精度要求进行修改
const double PI = acos(-1.0);	// pai, 3.1415926....

int sgn(double x) {	// 进行判断, 提高精度
    if (fabs(x) &lt; eps) return 0;	// x == 0, 精度范围内的近似相等
    return x &gt; 0 ? 1 : -1;			// 返回正负
}

struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}  // 构造函数, 初始值为 0

    Point operator- (const Point &amp;B) const { return Point(x - B.x, y - B.y); }
    
    Point operator+ (const Point &amp;B) const { return Point(x + B.x, y + B.y); }
    
    // 向量 × 向量 (叉积)
    int operator^ (const Point &amp;B) const { return x * B.y - y * B.x; }
    
    // 向量 · 向量 (点积)
    int operator* (const Point &amp;B) const { return x * B.x + y * B.y; }
    
    Point operator* (const double &amp;B) const { return Point(x * B, y * B); }
    
    Point operator/ (const double &amp;B) const { return Point(x / B, y / B); }
    
    bool operator&lt; (const Point &amp;B) const { return x &lt; B.x || (x == B.x &amp;&amp; y &lt; B.y); }
    
    bool operator== (const Point &amp;B) const { return sgn(x - B.x) == 0 &amp;&amp; sgn(y - B.y) == 0; }
    
    bool operator!= (const Point &amp;B) const { return sgn(x - B.x) || sgn(y - B.y); }

    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Point &amp;obj) {
        is &gt;&gt; obj.x &gt;&gt; obj.y;
        return is;
    }

    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Point &amp;obj) {
        os &lt;&lt; obj.x &lt;&lt; ' ' &lt;&lt; obj.y;
        return os;
    }
};

struct Line {
    Point s, e;
    Line() {}
    Line(Point x, Point y):s(x), e(y) {}
};

using Vector = Point;

//两点间的直线距离
double dist(Point a, Point b) { return sqrt((a - b) * (a - b)); }

//向量模长
double len(Vector A) { return sqrtl(A * A); }

//单位向量
Vector norm(Vector A) { return A / len(A); }

// 判断点在直线/向量的哪一边
// 点在直线上, 返回 0 (三点共线)
// 点在直线的逆时针方向, 返回 1
// 点在直线的顺时针方向, 返回 -1
// 点 a, b (向量ab) 所在的直线和点 c
// 使用的时候要注意 a 和 b 的顺序, 有时顺序不同, 结果不同
int Cross(Point a, Point b, Point c) { return sgn((b - a) ^ (c - a)); }

// 两种分情况使用
double Cross1(Point a, Point b, Point c) { return (b - a) ^ (c - a); }

// 点 P 到直线 AB 的距离
double Dist_point_to_line(Point P, Point A, Point B) {
    Vector v1 = B - A, v2 = P - A;
    return fabs((v1 ^ v2) / len(v1));
}

// 点 P 到线段 AB 的距离
double Dist_point_to_seg(Point P, Point A, Point B) {
    if (A == B) return len(P - A);		// 如果重合, 那么就是两点的距离
    Vector v1 = B - A, v2 = P - A, v3 = P - B;
    if (sgn(v1 * v2) &lt; 0) return len(v2);	// AP 最短
    if (sgn(v1 * v3) &gt; 0) return len(v3);	// BP 最短
    return fabs((v1 ^ v2) / len(v1));		// 垂线
}

// 判断点是否在线段上
bool OnSegment(Point P, Point A, Point B) {
    Vector PA = A - P, PB = B - P;
    return sgn(PA ^ PB) == 0 &amp;&amp; sgn(PA * PB) &lt;= 0;	// &lt;=, 包括端点; &lt;, 不包括端点
}

//两向量的夹角
double Angle(Vector A, Vector B) {
    double t = acosl(1.0 * (A * B) / len(A) / len(B));
    return t;               // 返回 [0, π]
    //return t * (180 / PI);  // 返回 [0, 180] (角度)
}

//点到直线的映射
Point projection(Point p, Point a, Point b) {
    Vector v = b - a, u = p - a;
    return a + v * ((v * u) / (v * v));
}

//点关于直线的对称点
Point Symmetrypoint(Point p, Point a, Point b) {
    Vector v = b - a, u = p - a;
    Point q = projection(p, a, b);
    return q + (q - p);
}

// 向量 A 和要逆时针转的角度 [0, PI]
// PI / 2, 90度
Vector Rotate(Vector A, double b) {
    Vector B(sin(b), cos(b));
    return Vector(A ^ B, A * B);
}

//向量b相对于向量a是顺时针旋转还是逆时针旋转
int Vector_direction(Vector a, Vector b) {
    int cha = a ^ b;

    if(cha &gt; 0) {
        return 0;//逆时针
    } else {
        return 1;//顺时针
    }
}

//判断三点共线
bool In_one_line(Point A, Point B, Point C) { return !sgn((B - A) ^ (C - B)); }

// 判断直线与线段是否相交
// 直线 ab 与线段 cd
bool Intersect_line_seg(Point a, Point b, Point c, Point d) {
    return Cross(a, b, c) * Cross(a, b, d) &lt;= 0;
}

// 判断两线段是否相交（包括端点）
// 线段 ab 与线段 cd
bool Intersect_seg(Point a, Point b, Point c, Point d) {
    if (OnSegment(a, c, d) || OnSegment(b, c, d) || OnSegment(c, a, b) || OnSegment(d, a, b)) return 1;
    if (Cross(a, b, c) * Cross(a, b, d) &gt;= 0) return 0;
    if (Cross(c, d, a) * Cross(c, d, b) &gt;= 0) return 0;
    return 1;
}

// 求两线段距离
// 线段 ab 与线段 cd
double Dist_seg_to_seg(Point a, Point b, Point c, Point d) {
    if(Intersect_seg(a, b, c, d)) {
        return 0;
    } else {
        double ans = 1000000000;//最大值根据题目数据范围适当修改
        ans = std::min(ans, Dist_point_to_seg(a, c, d));
        ans = std::min(ans, Dist_point_to_seg(b, c, d));
        ans = std::min(ans, Dist_point_to_seg(c, a, b));
        ans = std::min(ans, Dist_point_to_seg(d, a, b));
        return ans;
    }
}

// 求两直线交点
// 首先要判断两直线是否相交, 即不平行(不重合)
// a, b 所在直线与 c, d 所在直线的交点
Point Intersection_line(Point a, Point b, Point c, Point d) {
    Vector u = b - a, v = d - c;
    double t = ((a - c) ^ v) / (v ^ u);
    return a + u * t;
}

// 判断两直线平行
// 返回true: 平行/重合, false: 相交
bool Line_parallel(Line A, Line B) { return sgn((A.s - A.e) ^ (B.s - B.e)) == 0; }

// 海伦公式求三角形面积（若题目所有信息都为整数，慎用）
double Triangle_area(Point A, Point B, Point C) {
    double a = len(A - B), b = len(A - C), c = len(B - C);
    double p = (a + b + c) / 2;
    return sqrt(p * (p - a) * (p - b) * (p - c));
}

// 叉积求三角形面积（题目信息为整数时最好是这个）
double Triangle_area2(Point A, Point B, Point C) {
    return fabs((B - A) ^ (C - A)) / 2;
}

// 当然，三角形其他公式也可以使用，比如已知两边长和夹角，则S = absinC / 2

// 求多边形面积
// 因为叉积求得的三角形面积是有向的, 在外面的面积可以正负抵消掉
// 所以能够求任意多边形面积(凸, !凸)
// p下标从 0 开始, 长度为 n
double Polygon_area(std::vector&lt;Point&gt; &amp;p) {
    int n = p.size();
    double area = 0;
    for (int i = 1; i &lt;= n - 2; i++) 
        area += (p[i] - p[0]) ^ (p[i + 1] - p[0]);
    return fabs(area / 2);  // 无向面积
	// return area / 2;        // 有向面积
}

// 鞋带定理求多边形面积
// 原理和上面相同, 不过是把原点(0, 0) 作为被指向点
// p下标从 0 开始, 长度为 n
double Polygon_area2(std::vector&lt;Point&gt; &amp;p) {
    int n = p.size();
    double area = 0;
    for (int i = 0, j = n - 1; i &lt; n; j = i++) 
        area += (p[j] ^ p[i]);
	return fabs(area / 2);  // 无向面积
    // return area / 2;        // 有向面积
}

// 判断是否是凸多边形
// 顶点必须按顺时针(或逆时针)给出, 允许共线边
// p下标从 0 开始, 长度为 n
bool Is_contex(std::vector&lt;Point&gt; &amp;p) {
    int n = p.size();
    std::array&lt;bool, 3&gt; s{};
    for (int i = 0, j = n - 1, k = n - 2; i &lt; n; k = j, j = i ++) {
        int cnt = sgn((p[i] - p[j]) ^ (p[k] - p[j])) + 1;
        s[cnt] = true;
        if (s[0] &amp;&amp; s[2]) return false;
    }
    return true;
}

// 判断点在多边形的位置
// 适用于任意多边形, 不用考虑精度误差和多边形的给出顺序
// 点在多边形边上, 返回 -1
// 点在多边形内, 返回 1
// 点在多边形外, 返回 0
// p的下标从 0 开始, 长度为 n
int InPolygon(Point P, std::vector&lt;Point&gt; &amp;p) {
    int n = p.size();
    bool flag = false;		// 相当于计数
    for (int i = 0, j = n - 1; i &lt; n; j = i++) {
        Point p1 = p[i], p2 = p[j];
        if (OnSegment(P, p1, p2)) return -1;
        if (sgn(P.y - p1.y) &gt; 0 == sgn(P.y - p2.y) &gt; 0) continue;
        if (sgn((P.y - p1.y) * (p1.x - p2.x) / (p1.y - p2.y) + p1.x - P.x) &gt; 0) 
            flag = !flag;
    }
    return flag;
}

// 根据方向判断点在多边形的位置
// 局限性：只能用于判断点是否在凸多边形内，并且要求点的给出顺序是顺时针（或逆时针）并且多边形点的个数&gt;= 2
// 点在多边形边上, 返回 -1
// 点在多边形内, 返回 1
// 点在多边形外, 返回 0
// p[] 的下标从 0 开始, 长度为 n
int InPolygon1(Point P, std::vector&lt;Point&gt; &amp;p, int n) {
    std::array&lt;int, 3&gt; st{};
    for (int i = 0, j = n - 1; i &lt; n; j = i++) {
        st[Cross(p[j], p[i], P) + 1]++;
        if (st[0] &amp;&amp; st[2]) return 0;
    }
    if (st[1]) return -1;
    return 1;
}

// 点集 p[] 的下标从 0 开始, 长度为 n
std::vector&lt;Point&gt; Andrew(std::vector&lt;Point&gt; &amp;p) {
    std::vector&lt;Point&gt; res;
    int top = 0;
    int n = p.size();
    std::sort(p.begin(), p.end());
    for (int i = 0; i &lt; n; i++) {  // 下凸包
        while (top &gt; 1 &amp;&amp; Cross1(res[top - 2], res[top - 1], p[i]) &lt;= 0) {
            res.pop_back();
            top --;
        }
        res.push_back(p[i]);
        top ++;
    }
    int t = top;
    for (int i = n - 2; i &gt;= 0; i--) {	// 上凸包
        while (top &gt; t &amp;&amp; Cross1(res[top - 2], res[top - 1], p[i]) &lt;= 0) {
            res.pop_back();
            top --;
        }
        res.push_back(p[i]);
        top ++;
    }

    res.pop_back();  // 因为首尾都会加一次第一个点, 所以去掉最后一个
    return res;
}

void solve() {
    int n;std::cin &gt;&gt; n;
    std::vector&lt;Point&gt; a(n);

    Point p;
    std::cin &gt;&gt; p.x &gt;&gt; p.y;

    for(auto &amp;[x, y] : a) {
        std::cin &gt;&gt; x &gt;&gt; y;
    }

    std::vector&lt;int&gt; d(n);

    int mx = 0;
    
    for(int i = 0;i &lt; n;i ++) {
        d[i] = (a[i].x - p.x) * (a[i].x - p.x) + (a[i].y - p.y) * (a[i].y - p.y);
        mx = std::max(mx, d[i]);
    }

    std::vector&lt;Point&gt; c, e;
    for(int i = 0;i &lt; n;i ++) {
        if(mx == d[i]) {
            c.push_back(a[i]);
        }
    }

    if(InPolygon1(p, a, n) != 0) {
        if(c.size() == 1) {
            std::cout &lt;&lt; 2 * PI &lt;&lt; '\n';
            return;
        }
    
        double m = 0;
    
        c.push_back(c[0]);
    
        for(int i = 0;i &lt; c.size() - 1;i ++) {
            double tmp = atan2l(c[i].y - p.y, c[i].x - p.x);
            double tmp1 = atan2l(c[i + 1].y - p.y, c[i + 1].x - p.x);

            if(tmp1 - tmp &lt; 0) m = std::max(m, tmp1 - tmp + 2 * PI);
            else m = std::max(m, tmp1 - tmp);
        }
    
        std::cout &lt;&lt; m &lt;&lt; '\n';
    } else {
        std::cout &lt;&lt; 2 * PI &lt;&lt; '\n';
    }
} 

signed main() {
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(15);

    int t = 1;std::cin &gt;&gt; t;
    while(t --) {
        solve();
    }

    return 0;
}
</code></pre>
</details>
<h2 id="杭电多校1补题">杭电多校1补题</h2>
<h3 id="1003---奸商">1003 - 奸商</h3>
<p>思路很简单，对于奇数区间，不用考虑，中间那个一定对称。<br>
对于偶数区间，一定会包含一个更小的居中的偶数区间，因此只需要最小的偶数区间满足即可。<br>
正解还没看，但是暴力剪枝过了，目前有两种猜测，希望有大佬可以解答一下。</p>
<ol>
<li>杭电数据弱了</li>
<li>由于颜色数很少，导致如果想让某一个区间遇上匹配很慢或是根本匹配不上的话，会间接导致其它区间匹配速度加快。</li>
</ol>
<p>均为猜测，尤其是第二条，没有严谨证明，但这个猜测是在我试图造一个卡掉暴力的数据造了半个小时发现很难造后得出的大胆的猜测。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

void solve() {
    int n;std::cin &gt;&gt; n;

    std::string s;std::cin &gt;&gt; s;

    std::vector&lt;int&gt; a(17);

    for(auto &amp; x : a) {
        std::cin &gt;&gt; x;
    }

    int len;std::cin &gt;&gt; len;
    if(len &amp; 1)len ++;

    if(len &gt; n) {
        std::cout &lt;&lt; 0 &lt;&lt; '\n';
        return;
    }

    int ans = 1e9;
    for(int k = 0;k &lt; (1 &lt;&lt; 17);k ++) {
        int tmp = 0;
        for(int i = 0;i &lt; 17;i ++) {
            if(k &gt;&gt; i &amp; 1) {
                tmp += a[i];
            }
        }

        if(tmp &gt;= ans)continue;

        bool ck = true;
        for(int i = 0;i + len - 1 &lt; n;i ++) {
            if(!ck)break;
            bool fg = false;
            for(int j = 0;i + j &lt; i + len - 1 - j;j ++) {
                if(s[i + j] == s[i + len - 1 - j]) {
                    fg = true;
                    break;
                }

                char c = std::min(s[i + j], s[i + len - 1 - j]);
                if((k &gt;&gt; (c - 'a')) &amp; 1) {
                    fg = true;
                    break;
                }
            }
            ck = fg;
        }

        if(ck) {
            ans = tmp;
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    
    int t = 1;std::cin &gt;&gt; t;
    while(t --) {
        solve();
    }

    return 0;
}
</code></pre>
</details>
<h3 id="1007---树上lcm">1007 - 树上LCM</h3>
<p>赛时看到这个题目可高兴了，统计树上路径信息，这不妥妥的点分治板子嘛，然后，我就写了整整后半场……从TLE到WA。<br>
这个题使用点分治理论上应该是可解的，但是难点在于，由于一个LCM可能对应很多种不同的另一个LCM，导致贡献很难算，码量巨大，还会提高代码常数，因此点分治很难解。<br>
此题有两个解法，分别是高维前缀和和莫比乌斯反演。</p>
<h4 id="解法1高维前缀和">解法1：高维前缀和</h4>
<p>此解法也就是官方给出的解法。<br>
首先，在题目数据范围内，一个数的质因子数量最多为 <span class="math inline">\(7\)</span>，因此可以考虑状压，每一位对应一个分解出的素数。<br>
对于任何一个结点的值，我们先按照下面这个规则转化为一个状压值：</p>
<ul>
<li>如果 <span class="math inline">\(x \mod a[u] \neq 0\)</span>，那么设置为 <span class="math inline">\(-1\)</span>，因为包含这个结点的路径的 LCM 不可能是 <span class="math inline">\(x\)</span>。</li>
<li>如果 <span class="math inline">\(x \mod a[u] = 0\)</span>，那么按照这个规则设置状压值：对于每一个 <span class="math inline">\(x\)</span> 分解出的素数，如果该素数在 <span class="math inline">\(a[u]\)</span> 的次数和在 <span class="math inline">\(x\)</span> 的次数相同，则该位设置为 <span class="math inline">\(1\)</span>，否则设置为 <span class="math inline">\(0\)</span>。</li>
</ul>
<p>这样做了过后，就会发现，如果对于某一个数 <span class="math inline">\(i\)</span> 转化得到的状压值的一部分位为 <span class="math inline">\(1\)</span>，那么要让它和另一个数 <span class="math inline">\(j\)</span> 的 LCM 为 <span class="math inline">\(x\)</span>，对于这些 <span class="math inline">\(i\)</span> 中已经为 <span class="math inline">\(1\)</span> 的位，<span class="math inline">\(j\)</span> 可以为 <span class="math inline">\(1\)</span> 也可以为 <span class="math inline">\(0\)</span>，而对于那些 <span class="math inline">\(i\)</span> 中为 <span class="math inline">\(0\)</span> 的位，必须要让 <span class="math inline">\(j\)</span> 的对应位为 <span class="math inline">\(1\)</span> 才行，也就是说，要找寻的答案，也就是某些位指定为 <span class="math inline">\(1\)</span>，其它位随意带来的贡献，但这样计算的话，复杂度必定很高，因为要去枚举不定的位的 <span class="math inline">\(01\)</span> 情况，这时候，就是高维前缀和发挥作用的时候了。<br>
我们可以把这些情况，使用高维前缀和，全都加到最基本的状态中，也就是对于 <span class="math inline">\(i\)</span> 中为 <span class="math inline">\(1\)</span> 的位，在 <span class="math inline">\(j\)</span> 中为 <span class="math inline">\(0\)</span>，在 <span class="math inline">\(i\)</span> 中为 <span class="math inline">\(0\)</span> 的位，在 <span class="math inline">\(j\)</span> 中为 <span class="math inline">\(1\)</span>，这样的话，用 <span class="math inline">\(i \oplus ((1 &lt;&lt; k) - 1)\)</span> 就可以得到要查询的 <span class="math inline">\(j\)</span> 了，实现 <span class="math inline">\(O(1)\)</span> 查询。</p>
<p>至于求答案，可以采用合并式的树形DP，记 <span class="math inline">\(dp[u][p]\)</span> 为子树 <span class="math inline">\(u\)</span> 的状压值为 <span class="math inline">\(p\)</span> 的以 <span class="math inline">\(u\)</span> 为起点的路径数。<br>
假设每个结点 <span class="math inline">\(u\)</span> 最开始只有自己一个结点，然后一棵子树一棵子树地合并上来，合并之前算一下新加的子树和当前结点 <span class="math inline">\(u\)</span> 形成的树组合而成的贡献，然后把这棵子树合并上来，组合的过程按照上面这样计算答案贡献就行了，具体的详见代码。<br>
这个DP方式类似于<a href="https://codeforces.com/gym/105924/attachments" title="今年上半年CCPC东北四省邀请赛 - E.树上删边" target="_blank" rel="noopener nofollow">今年上半年CCPC东北四省邀请赛 - E.树上删边</a>。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using i64 = long long;

void solve() {
    int n, x;std::cin &gt;&gt; n &gt;&gt; x;
    
    std::vector&lt;std::vector&lt;int&gt;&gt; g(n + 1);
    
    for(int i = 1;i &lt; n;i ++) {
        int u, v;std::cin &gt;&gt; u &gt;&gt; v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    std::vector&lt;int&gt; a(n + 1);
    
    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    
    std::map&lt;int, int&gt; cnt;
    
    int tmp = x;
    for(int i = 2;i * i &lt;= tmp;i ++) {
        if(tmp % i == 0) {
            int now = 0;
            while(tmp % i == 0) {
                now ++;
                tmp /= i;
            }
            cnt[i] = now;
        }
    }

    if(tmp != 1)cnt[tmp] = 1;
    
    auto get = [&amp;](i64 y) -&gt; int {
        int res = 0;
        if(std::lcm(1ll * x, y) != x) {
            return -1;
        }
        
        int th = 0;
        for(auto &amp;[u, v] : cnt) {
            if(y % u == 0) {
                int now = 0;
                while(y % u == 0) {
                    now ++;
                    y /= u;
                }
                
                if(now == v) {
                    res |= (1 &lt;&lt; th);
                }
            }
            
            th ++;
        }
        
        return res;
    };
    
    for(int i = 1;i &lt;= n;i ++) {
        a[i] = get(a[i]);
    }

    const int k = cnt.size();

    std::vector dp(n + 1, std::vector&lt;i64&gt;(1 &lt;&lt; k));

    i64 ans = 0;
    auto dfs = [&amp;](auto &amp;&amp;self, int st, int pre) -&gt; void {
        for(auto &amp;v : g[st]) {
            if(v == pre)continue;
            self(self, v, st);
        }

        if(a[st] == -1)return;

        dp[st][a[st]] = 1;
        
        if(a[st] == (1 &lt;&lt; k) - 1)ans ++;

        for(auto &amp;v : g[st]) {
            if(v == pre)continue;

            auto suf = dp[st];
            for(int j = 0;j &lt; k;j ++) {
                for(int i = 0;i &lt; (1 &lt;&lt; k);i ++) {
                    if(!(i &gt;&gt; j &amp; 1)) {
                        suf[i] += suf[i | (1 &lt;&lt; j)];
                    }
                }
            }

            for(int i = 0;i &lt; (1 &lt;&lt; k);i ++) {
                int now = a[st] | i;
                ans += 1ll * suf[now ^ ((1 &lt;&lt; k) - 1)] * dp[v][i];
                dp[st][now] += dp[v][i];
            }
        }
    };

    dfs(dfs, 1, 0);

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t = 1;std::cin &gt;&gt; t;
    while(t --) {
        solve();
    }

    return 0;
}
</code></pre>
</details>
<h4 id="解法2莫比乌斯反演">解法2：莫比乌斯反演</h4>
<p>为了补这个题专门学了莫反，然后发现……如果知道莫反的话，这不是就莫反板子题吗???<br>
首先回顾一下莫反的公式：<br>
如果有：</p>
<p></p><div class="math display">\[f(n) = \sum_{d|n} g(d)
\]</div><p></p><p>那么有：</p>
<p></p><div class="math display">\[g(n) = \sum_{d|n}\mu(d) \times f(n/d)
\]</div><p></p><p>然后回到我们这个题目，我们定义一下 <span class="math inline">\(f(n)\)</span> 和 <span class="math inline">\(g(n)\)</span>。<br>
我们定义 <span class="math inline">\(f(n)\)</span> 为：所有满足 <span class="math inline">\(LCM | n\)</span> 的路径数。<br>
我们定义 <span class="math inline">\(g(n)\)</span> 为：所有满足 <span class="math inline">\(LCM = n\)</span> 的路径数。<br>
很显然，此题我们要求的就是 <span class="math inline">\(g(x)\)</span>，但是这并不好求，正如一开始提到的，要精确为 <span class="math inline">\(x\)</span>，情况很多，很难计算。<br>
那 <span class="math inline">\(f(x)\)</span> 呢？我们发现，<span class="math inline">\(f(x)\)</span> 是很好求的，因为满足一个路径的 <span class="math inline">\(LCM | x\)</span>，只需要这条路径上面所有数字都能整除 <span class="math inline">\(x\)</span> 即可。<br>
再仔细观察可以发现，我们定义的 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span>，不正好是满足 <span class="math inline">\(f(n) = \sum_{d|n} g(d)\)</span> 的吗？<br>
因此，我们可以求 <span class="math inline">\(x\)</span> 的所有因子的 <span class="math inline">\(f(d)\)</span>，然后反演求得 <span class="math inline">\(g(x)\)</span>，完美解决。<br>
<span class="math inline">\(f(d)\)</span> 的求法，这里提供一个比较简便的思路，把一棵树划分成很多连通块，每一个块都满足所有数字都能整除枚举的 <span class="math inline">\(d\)</span>，对每一个块两两组合一下即可，由于任何两个点都会有唯一路径，所以答案也就是块的大小求等差数列的和，此过程可以使用树形DP简便维护，也可以提前跑一下并查集。<br>
然后套用莫反求 <span class="math inline">\(g(x)\)</span> 即可。<br>
时间复杂度 <span class="math inline">\(O(n \sqrt{x})\)</span>。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using i64 = long long;

const int N = 1e7 + 9;
int mu[N], notprime[N];
std::vector&lt;int&gt; prime;

void init() {
    notprime[0] = notprime[1] = true;
    mu[1] = 1;

    for(int i = 2;i &lt; N;i ++) {
        if(!notprime[i])prime.push_back(i), mu[i] = -1;
        for(int j = 0;j &lt; prime.size() &amp;&amp; i * prime[j] &lt; N;j ++) {
            notprime[i * prime[j]] = true;
            if(i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
} 

void solve() {
    int n, s;std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;std::vector&lt;int&gt;&gt; g(n + 1);
    std::vector&lt;i64&gt; a(n + 1);

    for(int i = 1;i &lt; n;i ++) {
        int u, v;std::cin &gt;&gt; u &gt;&gt; v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    std::vector&lt;int&gt; b;

    for(int i = 1;i * i &lt;= s;i ++) {
        if(s % i == 0) {
            b.push_back(i);
            if(s / i != i) {
                b.push_back(s / i);
            }
        }
    }

    std::sort(b.begin(), b.end());

    std::vector&lt;i64&gt; dp(n + 1);

    i64 ans = 0, res = 0;

    auto dfs = [&amp;](auto &amp;&amp;self, int st, int pre, int x) -&gt; void {
        dp[st] = (x % a[st] == 0);
        
        for(auto &amp;v : g[st]) {
            if(v == pre)continue;
            self(self, v, st, x);
            dp[st] += dp[v];
        } 

        if(x % a[st] != 0)dp[st] = 0;
        if(st == 1 || x % a[pre] != 0)res += 1ll * (dp[st] + 1) * dp[st] / 2;
    };

    for(auto &amp;x : b) {
        res = 0;
        dfs(dfs, 1, 0, x);
        ans += res * mu[s / x];
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    init();

    int t = 1;std::cin &gt;&gt; t;
    while(t --) {
        solve();
    }

    return 0;
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.001388888888888889" data-date-updated="2025-07-21 02:05">2025-07-21 02:03</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18995014);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18995014', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18995014', title: '【暑期多校补题记录】2025牛客多校(1)(2) 杭电多校(1)' })">举报</a>
</div>
        