
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18769510" title="发布于 2025-03-13 15:11">
    <span role="heading" aria-level="2">重生之数据结构与算法----常见排序算法(二)</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>上文中，我们讲到了选择排序，冒泡排序，插入排序，希尔排序。<br>
都是相对比较简单的实现方式，因为它们都是以<code>人的思维</code>，维护一个index,将index与周围元素逐步对比。直到整个数组有序。<br>
但越是效率高的算法，反而要越接近<code>计算的的思维</code>。否则非常难以突破O(N^2)的桎梏。<br>
而接下来的几种效率高算法，则是一步一步接近计算机的思维，实现排序高效。</p>
<h1 id="二叉树前序遍历快速排序">二叉树前序遍历：快速排序</h1>
<p>快速排序的核心思路是：<code>先将一个元素排好序，然后递归排序剩下的元素</code></p>
<p>这里可能难以理解，这说的是什么逼话？我们再拆解一下。</p>
<ol>
<li>在数组中随机选一个作为排序元素</li>
</ol>
<pre><code>[3,1,4,1,5,9,2,6]
 ^
pivot
</code></pre>
<ol start="2">
<li>进行排序，将大于pivot的元素放右边，小于的放左边</li>
</ol>
<pre><code>[1,1,2,3,4,5,9,6]
       ^
	 pivot
</code></pre>
<ol start="3">
<li>递归重复以上步骤，寻找新的切分元素，然后交换。</li>
</ol>
<pre><code>[[1,1,2],3,  [4,5,9,6]]
  ^      ^    ^
pivot2 pivot pivot3
</code></pre>
<ol start="4">
<li>直到全部排序完成</li>
</ol>
<pre><code>[1,1,2,3,4,5,6,9]
</code></pre>
<p>根据上面的思维描述,我们可以写出一个代码框架，并将它们抽象成一颗二叉树</p>
<pre><code>        public void Sort(int[] arr,int left,int right)
        {
            if (left &gt; right)
                return;

            //进行切分，并将P排好序
            int p = Partition(arr, left, right);

            //对左右子数
            //是不是类似二叉树的前序遍历？
            Sort(arr, left, p - 1);
            Sort(arr, p + 1, right);
        }
		
		        /// &lt;summary&gt;
        /// 分区操作
        /// &lt;/summary&gt;
        /// &lt;param name="arr"&gt;&lt;/param&gt;
        /// &lt;param name="left"&gt;&lt;/param&gt;
        /// &lt;param name="right"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private static int Partition(int[] arr, int left, int right)
        {
            // 选择最右边的元素作为基准元素
            int pivot = arr[right];
            int i = left - 1;

            for (int j = left; j &lt; right; j++)
            {
                if (arr[j] &lt;= pivot)
                {
                    i++;
                    (arr[i], arr[j]) = (arr[j], arr[i]);
                }
            }
            (arr[i + 1], arr[right]) = (arr[right], arr[i + 1]);
            return i + 1;
        }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250313120825244-262159984.png" alt="image" loading="lazy"></p>
<h2 id="复杂度分析">复杂度分析</h2>
<ol>
<li>时间复杂度<br>
在理想情况下，这是一颗平衡二叉树，但在极端情况下退化成单链表。因此时间复杂度平均为O(n log n),最坏为O(n ^2)</li>
<li>空间复杂度<br>
平均情况下为O(log n)，最坏情况下为O(n)，主要取决于递归调用栈的深度</li>
<li>排序稳定性<br>
排序不稳定，因此排序稳定的前提是交换左右元素，而Partition会带来切分，所以这是可以推理出来的。</li>
<li>原地排序<br>
快速排序不需要额外的辅助空间，所以是原地排序算法。在遍历二叉树时，递归深度为树的高度，所以空间复杂度为O(log n)</li>
</ol>
<h1 id="二叉树的后序遍历归并排序">二叉树的后序遍历：归并排序</h1>
<p>上面说到，快速排序的核心思路是先将一个元素排好序，然后递归排序剩下的元素。<br>
而归并排序的思路是，把数组切成两半，然后单独排序，最后再合并。</p>
<pre><code>        public void Sort(int[] arr)
        {
            if (arr.Length &lt;= 1)
                return;
            int mid = arr.Length / 2;

            //归并排序需要空间来合并有序数组，复杂度O(N)
            int[] left = new int[mid];
            int[] right = new int[arr.Length - mid];
            Array.Copy(arr, 0, left, 0, mid);
            Array.Copy(arr, mid, right, 0, arr.Length - mid);

            Sort(left);
            Sort(right);

            //合并有序数组，是不是有点类似二叉树的后序位置？
            Merge(arr, left, right);
        }

        private static void Merge(int[] arr, int[] left, int[] right)
        {
            int i = 0, j = 0, k = 0;
            while (i &lt; left.Length &amp;&amp; j &lt; right.Length)
            {
                if (left[i] &lt; right[j])
                {
                    arr[k] = left[i];
                    i++;
                }
                else
                {
                    arr[k] = right[j];
                    j++;
                }
                k++;
            }
            while (i &lt; left.Length)
            {
                arr[k] = left[i];
                i++;
                k++;
            }
            while (j &lt; right.Length)
            {
                arr[k] = right[j];
                j++;
                k++;
            }
        }
</code></pre>
<h2 id="复杂度分析-1">复杂度分析</h2>
<ol>
<li>时间复杂度<br>
归并排序的时间复杂度始终为O(n log n)，其中&nbsp;n&nbsp;是数组的长度。这是因为每次分解数组的时间复杂度为O(log n)，而每次合并数组的时间复杂度为O(n)。</li>
<li>空间复杂度<br>
O(n)，主要用于存储合并过程中临时创建的数组。</li>
<li>排序稳定性<br>
稳定排序，因为在合并过程中，当两个元素相等时，会优先选择左边子数组的元素，从而保证相同元素的相对顺序不变。</li>
<li>原地排序<br>
不是原地排序，因为需要额外的辅助数组。</li>
</ol>
<h1 id="二叉堆的妙用堆排序">二叉堆的妙用：堆排序</h1>
<p>堆排序是二叉堆衍生出来的排序算法，核心分为两步。第一在原数组上建堆(大顶堆 or 小顶堆)，在进行原地排序。</p>
<p>最简单的堆排序算法，就是直接利用二叉堆的<code>优先级队列</code>，然后用一个数组存储结果不就好了吗？</p>
<pre><code>        public static void Run()
        {
            //创建一个小顶堆
            var q = new PriorityQueueSimple(10);
            q.Push(3);
            q.Push(2);
            q.Push(1);
            q.Push(5);
            q.Push(4);

            var arr = new int[q.Count];
            for (int i = 0; i &lt; arr.Length; i++)
            {
                arr[i] = q.Pop();

                Console.WriteLine(arr[i]);
            }
        }
</code></pre>
<p>这里带来的问题是，我们额外用了一个数组来存储元素。而我们希望是原地排序，不带来额外的空间复杂度。</p>
<p>因此，我们优化后的代码就变成了：</p>
<pre><code>    public class HeapSort
    {
        public static void Run()
        {
            var t =new HeapSort();
            //第一步，原地建堆
            var arr = new int[] { 3, 1, 4, 1, 5, 9, 2, 6 };
            for (int i = 0; i &lt; arr.Length; i++)
            {
                t.MinHeapSwim(arr, i);
            }

            //第二部，排序
            var length = arr.Length;
            while (length &gt; 0)
            {
                //删除堆顶，并放到堆最后面
                (arr[0], arr[length - 1]) = (arr[length - 1], arr[0]);
                length--;

                //下浮
                t.MinHeapSink(arr, 0, length);
            }
            

            for (int i = arr.Length-1; i&gt;=0; i--)
            {
                Console.WriteLine(arr[i]);
            }
        }
        /// &lt;summary&gt;
        /// 小顶堆的上浮
        /// &lt;/summary&gt;
        /// &lt;param name="heap"&gt;&lt;/param&gt;
        /// &lt;param name="node"&gt;&lt;/param&gt;
        void MinHeapSwim(int[] heap,int node)
        {
            while(heap[node] &lt; heap[Parent(node)])
            {
                //swap
                (heap[Parent(node)], heap[node]) = (heap[node], heap[Parent(node)]);
                node = Parent(node);
            }
        }
        
        void MinHeapSink(int[] heap, int node,int count)
        {
            while (Left(node) &lt; count || Right(node) &lt; count)
            {
                int minNode = node;
                if (Left(node) &lt; count&amp;&amp; heap[node] &gt; heap[Left(node)])
                {
                    minNode = Left(node);
                }

                if (Right(node) &lt; count &amp;&amp; heap[minNode] &gt; heap[Right(node)])
                {
                    minNode = Right(node);
                }

                if (minNode == node)
                {
                    break;
                }
                //swap
                (heap[node], heap[minNode]) = (heap[minNode], heap[node]);
            }



            
        }

        // 父节点的索引
        int Parent(int node)
        {
            return (node - 1) / 2;
        }

        // 左子节点的索引
        int Left(int node)
        {
            return node * 2 + 1;
        }

        // 右子节点的索引
        int Right(int node)
        {
            return node * 2 + 2;
        }

    }
</code></pre>
<p>其实没什么变化，相对之前实现的优先级队列来说。只是把数组作为参数传递，实现原地排序而已。</p>
<h2 id="复杂度分析-2">复杂度分析</h2>
<ol>
<li>时间复杂度<br>
O(n log n) ，因为要对swim/sink要对每个元素调用</li>
<li>空间复杂度<br>
O(1)</li>
<li>排序稳定性<br>
不稳定，因为skin过程中，要将堆顶元素，与堆尾元素交换。 违背了相邻元素交换的原则，所以不稳定。</li>
<li>原地排序<br>
是，我们的优化过程就是为了结果原地排序的问题。</li>
</ol>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.5449588409965278" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 15:12">2025-03-13 15:11</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">94</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18769510" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18769510);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18769510', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18769510', title: '重生之数据结构与算法----常见排序算法(二)' })">举报</a>

		</p>
	