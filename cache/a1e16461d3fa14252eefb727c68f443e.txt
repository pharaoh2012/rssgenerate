
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lindexi/p/18847625" title="发布于 2025-04-26 07:18">
    <span role="heading" aria-level="2">dotnet 9 通过 AppHostRelativeDotNet 指定自定义的运行时路径</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        进行框架依赖发布的时候，应用程序需要有 dotnet runtime 运行时才能跑起来。在 dotnet 9 之前，通常都是需要安装到系统的 Program File 文件夹下的全局 dotnet 运行时的支持。在 dotnet 9 时，引入了 AppHostRelativeDotNet 机制，允许开发者自定义依赖框架发布的应用使用的 dotnet 运行时路径
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">



<p>在 2022 时，我写了一个提案，允许应用程序自定义使用的 dotnet 运行时文件夹路径。详细请看 <a href="https://github.com/dotnet/runtime/issues/64430" target="_blank" rel="noopener nofollow">https://github.com/dotnet/runtime/issues/64430</a></p>
<p>这个提案的背景是我有很多个应用准备发布给到用户端上，如果这么多应用都走独立发布，自然会让用户的 C 盘充满重复的文件。如果是将 dotnet 运行时交给的是 Program File 文件夹下的全局文件夹，则可能会遇到各种被投毒问题，比如某次系统更新之后，应用程序就因为 .NET 环境损坏而无法启动</p>
<p>我所在的团队那会也在迁移一个大型的 .NET Framework 项目到 .NET 6 上，原本的项目会有多 exe 入口问题，这部分设计也改不动。多入口情况下也不适合每个入口都做独立发布，尽管独立发布的重复 BCL 等文件能够在安装包里面被压缩，但是在安装到用户设备上时，解压缩出来的内容依然会撑满用户的 C 盘</p>
<p>为此，我所在的团队就制作和开源了 <a href="https://github.com/dotnet-campus/dotnetCampus.AppHost" target="_blank" rel="noopener nofollow">https://github.com/dotnet-campus/dotnetCampus.AppHost</a> 项目，细节原理请参阅 <a href="https://blog.walterlv.com/post/how-does-the-dotnet-campus-apphost-work" target="_blank" rel="noopener nofollow">如何让 .NET 程序脱离系统安装的 .NET 运行时独立运行？除了 Self-Contained 之外还有更好方法！谈 dotnetCampus.AppHost 的工作原理 - walterlv</a></p>
<p>关于我所在的团队迁移大型项目的经验请参阅 <a href="https://blog.lindexi.com/post/%E8%AE%B0%E5%B0%86%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9E%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0-dotnet-6-%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%92%8C%E5%86%B3%E7%AD%96.html" target="_blank" rel="noopener nofollow">记将一个大型客户端应用项目迁移到 dotnet 6 的经验和决策</a></p>
<p>我那会预期的情况是这样的，我在自己控制的路径下，如 <code>C:\Program Files\CompanyName</code> 文件夹下，放入了自己的 <code>DotNETRuntime[Version]</code> 文件夹。然后再依次部署上多个应用程序，这些应用程序都是采用依赖框架（Publish framework-dependent）方式发布，总的文件夹布局情况如下</p>
<pre><code>C:\Program Files\CompanyName\DotNETRuntime[Version]\
C:\Program Files\CompanyName\Produce1\
C:\Program Files\CompanyName\Produce2\
C:\Program Files\CompanyName\Produce3\
</code></pre>
<p>如此即可让 Produce1 Produce2 Produce3 三个产品共用一个 dotnet 运行时</p>
<p>我的这个<a href="https://github.com/dotnet/runtime/issues/64430" target="_blank" rel="noopener nofollow">提案</a>被 dotnet 官方采纳了，加入到 .NET Host 提升计划里面，详细请看 <a href="https://github.com/dotnet/runtime/issues/97931" target="_blank" rel="noopener nofollow">https://github.com/dotnet/runtime/issues/97931</a> 。经过了三年（实际上绝大部分时间都在讨论）的开发，终于在 dotnet 9 支持了这个功能，能够完全实现我预期的功能</p>
<p>此项功能被命名为 Embedded install location options for apphost ，被我翻译为嵌入 dotnet 安装路径到 AppHost 里的功能，我也对外宣称这是为依赖框架的应用自定义 .NET Runtime 文件夹路径的功能</p>
<p>接下来我将和大家介绍此功能的用法和效果</p>
<p>此功能涉及到的关键属性分别如下：</p>
<ul>
<li>AppHostDotNetSearch ： 决定从哪里开始寻找，可选参数为 AppLocal、 AppRelative、 EnvironmentVariables 和 Global，可认为在此之前就是 Global 的值。允许设置多个参数，多个参数之间依然用 <code>;</code> 分号隔开。在本文里面，核心功能将由 <code>AppRelative</code> 参数实现</li>
<li>AppHostRelativeDotNet ： 配置相对于 exe 的路径，这个路径将被作为 dotnet 运行时的查找路径</li>
</ul>
<p>默认情况下，可只需设置 AppHostRelativeDotNet 属性即可。当 AppHostRelativeDotNet 属性被设置的时候，隐式设置了 AppHostDotNetSearch 属性为 AppRelative 的值。但通常来讲，可以将 AppHostDotNetSearch 属性设置为 <code>AppHostDotNetSearch=AppRelative;Global</code> 的值，这就意味着如果从相对路径没有找到 dotnet 运行时，将自动回滚到从 Global 全局进行查找。这里的 Global 全局即 <code>C:\Program Files\dotnet\</code> 或 <code>C:\Program Files (x86)\dotnet\</code> 文件夹或全局注册表记录的路径</p>
<p>为了演示此功能的用法，我创建了一个名为 LinerewheldeholearjearHalllurlecayawfea 的控制台项目，控制台项目使用的是 .NET 9 默认控制台模版代码。编辑 csproj 项目文件，添加 AppHostDotNetSearch 和 AppHostRelativeDotNet 属性，修改之后的 csproj 项目文件代码大概如下。本文内容里面只给出关键代码片段，如需要全部的项目文件，可到本文末尾找到本文所有代码的下载方法</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;AppHostDotNetSearch&gt;AppRelative;Global;&lt;/AppHostDotNetSearch&gt;
    &lt;AppHostRelativeDotNet&gt;../relative/path/to/runtime&lt;/AppHostRelativeDotNet&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>可以看到我在 AppHostRelativeDotNet 写入的是相对于 exe 的上一层文件夹空间的 <code>relative/path/to/runtime</code> 路径</p>
<p>准备工作就此完成，接下来就是设置进行框架依赖发布。这里需要特别说明的是 .NET Core （包含 .NET 5 和更高版本）的输出 exe 是不能实现 .NET Framework 的 AnyCpu 魔法的，在使用自定义 dotnet 运行时路径时，需要根据自己的需求，明确指定其版本。这里也需要额外说明的是，尽管本文内容都在 Windows 下测试，但事实上本文介绍的 dotnet 这项新功能是可以在全平台使用的，即在 Linux 或 mac 上也适用</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071743379-1303235077.png" alt="" loading="lazy"></p>
<p>我的发布配置文件 FolderProfile.pubxml 代码如下</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- https://go.microsoft.com/fwlink/?LinkID=208121. --&gt;
&lt;Project&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration&gt;Release&lt;/Configuration&gt;
    &lt;Platform&gt;Any CPU&lt;/Platform&gt;
    &lt;PublishDir&gt;bin\Release\net9.0\publish\win-x86\&lt;/PublishDir&gt;
    &lt;PublishProtocol&gt;FileSystem&lt;/PublishProtocol&gt;
    &lt;_TargetId&gt;Folder&lt;/_TargetId&gt;
    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;
    &lt;RuntimeIdentifier&gt;win-x86&lt;/RuntimeIdentifier&gt;
    &lt;SelfContained&gt;false&lt;/SelfContained&gt;
    &lt;PublishSingleFile&gt;false&lt;/PublishSingleFile&gt;
    &lt;PublishReadyToRun&gt;false&lt;/PublishReadyToRun&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>配置完成之后，直接进行发布，此时可以看到发布创建的文件只有几个。有了这项技术就不怕发布大量工具了，有了这项技术就可以让发布的 .NET Core（包含.NET 5及更高版本）应用也和 .NET Framework 应用一样小体积占用</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071743912-1840864164.png" alt="" loading="lazy"></p>
<p>发布完成之后，可不能和进行独立发布（Self-Contained）一样，直接就将此分发给到用户了，咱还需要对此进行包装文件夹布局</p>
<p>刚才在 AppHostRelativeDotNet 写的是相对于 <code>../relative/path/to/runtime</code> 文件夹，嗯，这里只能写相对文件夹路径，不能写绝对文件夹路径。那咱就需要将发布输出的文件包装为里一层文件夹，我这里选择将其放入到名为 App1 的文件夹里面，这样我如果有第二个应用，就可以放入到 App2 文件夹里面</p>
<p>再接着将 App1 文件夹放入到名为 App 的文件夹里面。再在 App 文件夹里面的 <code>relative/path/to/runtime</code> 文件夹里面放入 dotnet 运行时。如此就完成了包装文件夹布局，此时直接双击 <code>App\App1\LinerewheldeholearjearHalllurlecayawfea.exe</code> 就能运行了</p>
<p>包装完成的文件夹布局情况如下</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071744249-1178032683.png" alt="" loading="lazy"></p>
<pre><code class="language-csharp">C:\LINDEXI\APP
|   
+---App1
|       LinerewheldeholearjearHalllurlecayawfea.deps.json
|       LinerewheldeholearjearHalllurlecayawfea.dll
|       LinerewheldeholearjearHalllurlecayawfea.exe
|       LinerewheldeholearjearHalllurlecayawfea.pdb
|       LinerewheldeholearjearHalllurlecayawfea.runtimeconfig.json
|       
\---relative
    \---path
        \---to
            \---runtime
                |   dotnet.exe
                |   LICENSE.txt
                |   ThirdPartyNotices.txt
                |   
                +---host
                |   \---fxr
                |       \---9.0.4
                |               hostfxr.dll
                |               
                \---shared
                    \---Microsoft.NETCore.App
                        \---9.0.4
                                .version
                                clretwrc.dll
                                clrgc.dll
                                clrjit.dll
                                coreclr.dll
                                createdump.exe
                                hostpolicy.dll
                                Microsoft.CSharp.dll
                                Microsoft.DiaSymReader.Native.x86.dll
                                Microsoft.NETCore.App.deps.json
                                Microsoft.NETCore.App.runtimeconfig.json
                                Microsoft.VisualBasic.Core.dll
                                Microsoft.VisualBasic.dll
                                Microsoft.Win32.Primitives.dll
                                Microsoft.Win32.Registry.dll
                                ...
                                System.Xml.XPath.dll
                                System.Xml.XPath.XDocument.dll
                                WindowsBase.dll

</code></pre>
<p>也许伙伴们有一个问题，那就是这里的 .NET Runtime 运行时文件夹组织是哪里来的，文件是从哪里来的。这是从 dotnet 官方下载的，下载链接是： <a href="https://dotnet.microsoft.com/zh-cn/download/dotnet/9.0" target="_blank" rel="noopener nofollow">https://dotnet.microsoft.com/zh-cn/download/dotnet/9.0</a></p>
<p>下载右边“运行应用 - 运行时”这一列的内容</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071744979-1608892421.png" alt="" loading="lazy"></p>
<p>运行时这一列有很多选项，具体应该下哪一个呢？这就看自己的需求了。如我只是一个简单的控制台，且准备发布的是 x86 应用，那我就应该下载 x86 二进制文件，就是这样的对应关系，先取决于要用什么框架，再决定用什么平台</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071745337-1893165724.png" alt="" loading="lazy"></p>
<p>下载下来的是一个 zip 压缩包，打开压缩包就可以看到这就是上文提到的 <code>relative/path/to/runtime</code> 文件夹内的结构，按照本文提供的方式将其解压缩就好了</p>

<p><img src="https://img2023.cnblogs.com/blog/1080237/202504/1080237-20250426071745633-509595437.png" alt="" loading="lazy"></p>
<p>额外需要说明的是，现在对于桌面应用来说是没有提供二进制包，只有安装包。即对于 WPF 和 WinForms 来说，现在只有安装包可用。那咋办呢？很简单，只需要找一个干净的系统（如虚拟机内），下载安装包且安装。安装完成之后，即可在 <code>C:\Program Files\dotnet\</code> 或 <code>C:\Program Files (x86)\dotnet\</code> 文件夹内找到安装输出的文件，将其拷贝出来放入到 <code>relative/path/to/runtime</code> 文件夹内即可</p>
<p>通过此项技术，即可让多个应用共用一个私有分发的 .NET 运行时。也可以作为单应用多 exe 入口程序的共享运行时技术实现。这项技术对于小工具项目特别友好，避免小工具项目要么各自带着运行时独立发布，要么被第三方或系统投毒运行时的选择</p>
<p>既然这可以使用私有分发的 .NET 运行时，那对于一些动手能力强的开发者来说，也可以在这里面带上自己魔改之后的 .NET 版本，实现更多有趣的功能</p>
<p>本文代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/1e09f77a553d664872cb12324a118649ffd23ad9/Workbench/LinerewheldeholearjearHalllurlecayawfea" target="_blank" rel="noopener nofollow">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/blob/1e09f77a553d664872cb12324a118649ffd23ad9/Workbench/LinerewheldeholearjearHalllurlecayawfea" target="_blank" rel="noopener nofollow">gitee</a> 上，可以使用如下命令行拉取代码。我整个代码仓库比较庞大，使用以下命令行可以进行部分拉取，拉取速度比较快</p>
<p>先创建一个空文件夹，接着使用命令行 cd 命令进入此空文件夹，在命令行里面输入以下代码，即可获取到本文的代码</p>
<pre><code>git init
git remote add origin https://gitee.com/lindexi/lindexi_gd.git
git pull origin 1e09f77a553d664872cb12324a118649ffd23ad9
</code></pre>
<p>以上使用的是国内的 gitee 的源，如果 gitee 不能访问，请替换为 github 的源。请在命令行继续输入以下代码，将 gitee 源换成 github 源进行拉取代码。如果依然拉取不到代码，可以发邮件向我要代码</p>
<pre><code>git remote remove origin
git remote add origin https://github.com/lindexi/lindexi_gd.git
git pull origin 1e09f77a553d664872cb12324a118649ffd23ad9
</code></pre>
<p>获取代码之后，进入 Workbench/LinerewheldeholearjearHalllurlecayawfea 文件夹，即可获取到源代码</p>
<p>参考文档：</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/issues/97931" target="_blank" rel="noopener nofollow">https://github.com/dotnet/runtime/issues/97931</a></li>
<li><a href="https://github.com/dotnet/designs/blob/main/proposed/apphost-embed-install-location.md" target="_blank" rel="noopener nofollow">https://github.com/dotnet/designs/blob/main/proposed/apphost-embed-install-location.md</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props</a></li>
<li><a href="https://github.com/dotnet/runtime/issues/64430" target="_blank" rel="noopener nofollow">https://github.com/dotnet/runtime/issues/64430</a></li>
<li><a href="https://github.com/dotnet/designs/blob/main/accepted/2020/install-locations.md" target="_blank" rel="noopener nofollow">https://github.com/dotnet/designs/blob/main/accepted/2020/install-locations.md</a></li>
</ul>
<p>更多技术博客，请参阅 <a href="https://blog.lindexi.com/post/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA.html" target="_blank" rel="noopener nofollow">博客导航</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>博客园博客只做备份，博客发布就不再更新，如果想看最新博客，请访问 https://blog.lindexi.com/</p>

<p>如图片看不见，请在浏览器开启不安全http内容兼容</p>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width: 0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](https://www.cnblogs.com/lindexi)(包含链接:https://www.cnblogs.com/lindexi )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.38231720309953704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-01 07:11">2025-04-26 07:18</span>&nbsp;
<a href="https://www.cnblogs.com/lindexi">lindexi</a>&nbsp;
阅读(<span id="post_view_count">1313</span>)&nbsp;
评论(<span id="post_comment_count">7</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18847625);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18847625', targetLink: 'https://www.cnblogs.com/lindexi/p/18847625', title: 'dotnet 9 通过 AppHostRelativeDotNet 指定自定义的运行时路径' })">举报</a>
</div>
        