
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiezhr/p/18897864" title="发布于 2025-05-27 08:25">
    <span role="heading" aria-level="2">SpringBoot3整合SpringSecurity6(五)自定义登陆页面</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>大家好，我是晓凡</strong></p>
<h3 id="写在前面">写在前面</h3>
<p>在前面的文章中，我们学习了<code>SpringSecurity</code> 登录认证流程，对其应该有个大概印象了。</p>
<p>忘记的小伙伴点击下面自己复习去~</p>
<p>在前面的学习中，我们使用的都是<code>SpringSecurity</code> 框架提供的登录页面，而实际开发中，我们往往都需要自定义登录页面。</p>
<h3 id="一准备登录页面">一、准备登录页面</h3>
<blockquote>
<p>这里呢，我们先采取<code>Themleaf</code>模板引擎来开发登录页面。后续会说到前后端分离的场景，小伙伴们不要着急，慢慢来</p>
</blockquote>
<p>在<code>resources/templates</code>下创建<code>mylogin.html</code>登录页面，代码如下</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="https://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;title&gt;晓凡登录页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;登录&lt;/h1&gt;
&lt;div th:if="${param.error}"&gt;
    用户名或者密码错误
&lt;/div&gt;

&lt;!--method必须为"post"--&gt;
&lt;!--mylogin: 和登录页面保持一致即可，SpringSecurity自动进行登录认证--&gt;
&lt;form th:action="@{/mylogin}" method="post"&gt;
    &lt;div&gt;
        &lt;!--name必须为"username"--&gt;
        &lt;input type="text" name="username" placeholder="用户名"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;!--name必须为"password"--&gt;
        &lt;input type="password" name="password" placeholder="密码"/&gt;
    &lt;/div&gt;
    &lt;input type="submit" value="登录" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202505/2381533-20250527081920208-1743698786.png" alt="自定义的登录页面" loading="lazy"></p>
<p><strong>注：</strong></p>
<ul>
<li>
<p>需要采用post方式提交表单</p>
</li>
<li>
<p>用户名输入框的name属性必须是<code>username</code>，<code>SpringSecurity</code> 框架默认接收name="username"参数</p>
</li>
<li>
<p>密码输入框的name属性必须是<code>password</code>，<code>SpringSecurity</code> 框架默认接收name="password"参数 。当然这里可以自定义，我们后面再细说。</p>
</li>
</ul>
<h3 id="二编写登录接口">二、编写登录接口</h3>
<blockquote>
<p>上面写的登录页面提交地址是<code>/login</code> （<code>th:action="@{/login}"</code>）,所以接下来我们来写一个登录接口，代码如下</p>
</blockquote>
<pre><code class="language-java">@Controller
public class LoginController {
    @GetMapping("/mylogin")
    public String login() {
        //跳转到mylogin试图解析器（上面自定义登录页面）
        return "mylogin";
    }
}
</code></pre>
<p>登录页面和登录接口都写好了，我们来试下是否能访问到我们自定义的登录页面。</p>
<p>浏览器地址栏输入：<a href="http://localhost:8080" target="_blank" rel="noopener nofollow">http://localhost:8080</a> 回车后，我们发现还是系统的登录页面。结果如下</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202505/2381533-20250527081920152-71731090.png" alt="依然还是系统登录页面" loading="lazy"></p>
<h3 id="三配置自定义登录页面">三、配置自定义登录页面</h3>
<p>默认情况下，应用程序在走到我们写的<code>LonginController</code>之前，会经过一系列的过滤器。在过滤器中，其中配置的一个过滤器就是</p>
<pre><code class="language-java">http.formLogin(withDefaults());
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202505/2381533-20250527081920178-2090505884.png" alt="默认配置" loading="lazy"></p>
<p>这个过滤器默认会这样处理：如果应用程序没有进行授权的话，它会将浏览器跳转到/login 这个地址当中，如果/login这个地址作为请求发送到后端服务器。</p>
<p><code>SpringSecurity</code> 就回去找默认的登录页面。</p>
<p>所以，我们要做的就是修改这个默认配置</p>
<pre><code class="language-java">// 自定义登录页面
http.formLogin(form-&gt;{
    form.loginPage("/mylogin");
});
</code></pre>
<p>这时候我们，再重启服务，看看有没有达到我们的预期，结果如下</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202505/2381533-20250527082104953-1780999477.png" alt="重定向过多报错" loading="lazy"></p>
<p>这是为什么呢？因为下面的配置会对所有请求进行授权保护</p>
<pre><code class="language-java">http.authorizeHttpRequests(
    authorize-&gt;authorize
    //对所有请求开启授权保护
    .anyRequest()
    //已认证的请求会被自动授权
    .authenticated()

);
</code></pre>
<p>我们只需要对<code>mylogin</code>页面进行放行即可，修改后如下</p>
<pre><code class="language-java">// 自定义登录页面
http.formLogin(form-&gt;{
    form.loginPage("/mylogin").permitAll();
});
</code></pre>
<p>经过修改之后，我们再来验证一下，浏览器地址栏输入：<a href="http://localhost:8080" target="_blank" rel="noopener nofollow">http://localhost:8080</a> 后</p>
<p><img src="http://blog.xiezhrspace.cn/blog-img/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.gif" alt="登录页面" loading="lazy"></p>
<p>成功跳转到我们自定义的登录页面了，登录界面虽然丑了一点，但功能是实现了~</p>
<h3 id="四csrf攻击">四、csrf攻击</h3>
<p>细心的小伙伴可能发现了，我们在编写登录页面的时候，form表单使用的是动态参数，具体如下</p>
<pre><code class="language-html">&lt;form th:action="@{/mylogin}" method="post"&gt;
</code></pre>
<p>动态参数<code>th:action="@{/login}"</code> 这种写法可以防止csrf 攻击，我们来看下我们的登陆页面源码。</p>
<p>当然了，我们需要把csrf打开，csrf攻击只存在单体应用中。后面要学的前后端分离是不存在的，我们可以把csrf关闭</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202505/2381533-20250527081920241-1033481994.png" alt="防止csrf攻击" loading="lazy"></p>
<h3 id="五小结">五、小结</h3>
<p>本篇文章的核心知识点就是下面的自定义登录页面配置，理解了这儿就够了</p>
<pre><code class="language-java">// 自定义登录页面
http.formLogin(form-&gt;{
    form.loginPage("/mylogin").permitAll();
});
</code></pre>
<p>我是晓凡，再小的帆也能远航~</p>
<p>希望本篇文章能帮助到您~</p>
<p>我们下期再见 ヾ(•ω•`)o  (●'◡'●)</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiezhr/" target="_blank">程序员晓凡</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiezhr/p/18897864" target="_blank">https://www.cnblogs.com/xiezhr/p/18897864</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03177554340625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 08:25">2025-05-27 08:25</span>&nbsp;
<a href="https://www.cnblogs.com/xiezhr">程序员晓凡</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18897864);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18897864', targetLink: 'https://www.cnblogs.com/xiezhr/p/18897864', title: 'SpringBoot3整合SpringSecurity6(五)自定义登陆页面' })">举报</a>
</div>
        