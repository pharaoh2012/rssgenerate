
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhangchen-trunk/p/18733091" title="发布于 2025-02-23 23:19">
    <span role="heading" aria-level="2">另类方式实现.Net下的多语言</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>关于.Net下的多语言方案已经有很多成熟的方案，例如：# <a href="https://www.cnblogs.com/Dotnet9-com/p/18618351" target="_blank">Avalonia 国际化之路：Resx 资源文件的深度应用与探索</a>，或者# <a href="https://www.cnblogs.com/Dotnet9-com/p/18618358" target="_blank">Avalonia使用XML文件实现国际化</a>，基本都围绕官方的Satellite Assembly方案来实现。实际上，我们可以使用非常原始的方式来实现多语言。</p>
<h1 id="步骤">步骤</h1>
<h2 id="1-resources资源文件生成">1. resources资源文件生成</h2>
<p>创建如下文本文件(假设为rex.txt)</p>
<pre><code class="language-txt">Greeting=Hello
</code></pre>
<p>将ResGen.exe从framework的工具目录（使用everything找下就可以看到）拷贝到当前目录，执行如下命令</p>
<pre><code class="language-cmd">PS D:\workSpace\Code\测试\resx&gt; .\ResGen.exe .\rex.txt
Read in 1 resources from ".\rex.txt"
Writing resource file...  Done.
</code></pre>
<p>就可以得到我们第一步的<code>rex.resources</code>。</p>
<p>说明：<br>
ResGen.exe工具同样支持resx文件，具体使用与文件格式参考https://learn.microsoft.com/en-us/dotnet/framework/tools/resgen-exe-resource-file-generator 官方文档，事实上，这也是我们使用的IDE编辑时msbuild背后调用的工具。</p>
<h2 id="2-dll文件生成">2. Dll文件生成</h2>
<p>有了resources资源文件，我们就可以通过链接器（al.exe,同样在framework的工具目录中）将resources资源文件链接成动态链接库。</p>
<pre><code class="language-cmd">PS D:\workSpace\Code\测试\resx&gt; .\al.exe -target:lib -embed:.\rex.resources -out:Res.dll
Microsoft(R) Assembly Linker 版本 14.7.2053.0
Copyright (C) Microsoft Corporation. All rights reserved.
</code></pre>
<p>说明：</p>
<ol>
<li><code>-target:lib</code>代表产物为类库</li>
<li><code>-embed:.\rex.resources</code>代表嵌入刚刚第一步的生成资源文件</li>
<li><code>-out:Res.dll</code> 代表生成物名称</li>
<li>使用ilspy打开就可以看到嵌入的资源文件。</li>
<li>注意我们这里并没有指定<code>-culture:zh-Hans</code>参数，而官方文档说这个参数必须传（<a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/create-satellite-assemblies%EF%BC%89" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/en-us/dotnet/core/extensions/create-satellite-assemblies）</a> 是因为我们完全没使用.net的语言资源机制，也完全不用遵从其hub-and-spoke模型（指的是轮子的中心和车轮的辐条的关系模型，也就是主dll和卫星资源dll的位置关系模型）</li>
<li>这里要对.Net下dll的结构有一定认识，大家可以参考前面链接中的图片。</li>
<li>也可以使用<code>-template:Example.dll</code>来指定生成dll的元数据模版，不然生成的dll在ilspy中元数据表的<code>TypeDef</code>会显示<code>&lt;Module&gt;</code>这样未命名的记录。</li>
<li>我们这里用的是链接器，其实也能用编译器(.net core下就是这样)，参考前面的链接。</li>
</ol>
<h2 id="3-使用">3. 使用</h2>
<p>创建控制台应用，代码如下：</p>
<pre><code class="language-csharp">using System;
using System.Globalization;
using System.Reflection;
using System.Resources;
using System.Threading;

namespace ConsoleApp1
{
    internal class Program
    {
        static void Main(string[] args)
        {
           // 手动加载刚刚链接器生成的程序集
           Assembly ass = Assembly.LoadFile(@"D:\workSpace\Code\测试\resx\Res.dll");
           // 第一个参数"rex"即为我们嵌入的rex.resources的文件名，第二个参数为应用程序集
           ResourceManager rm = new ResourceManager("rex", ass);
            var s = rm.GetString("Greeting");
            Console.WriteLine(s);
        }
    }
}
</code></pre>
<p>输出为：</p>
<pre><code>Hello

D:\workSpace\Code\测试\resx\ConsoleApp1\bin\Debug\ConsoleApp1.exe (进程 5184)已退出，代码为 0 (0x0)。
按任意键关闭此窗口. . .

</code></pre>
<p>就能拿到我们定义的语言资源啦。</p>
<p>说明：</p>
<ol>
<li>由于我们这里是纯手工加载，<code>Thread.CurrentThread.CurrentCulture = new CultureInfo("en-us");</code>这样是完全没影响的，同样, 链接器的cultrue参数也不影响，大家可以自行测试。</li>
</ol>
<h2 id="how-to">How to:</h2>
<p>看完这个和文章中的参考资料，应该对大家理解.Net的多语言有很大帮助。接下来就是我的方案（也许是胡说）<br>
如果想统一在一个文件中管理整个sln的语言资源（举例一下特殊需求），可以通过msbuild自定义Task的方式（大家可以类比下编辑的Grpc的proto文件自动生成代码的过程，实际上谷歌也是这么干的），（或者结合下T4模版？）直接生成所有语言的ResourceManager字典。封装方法返回对应语言的资源，有特殊需求的可以自行尝试，如果不行就当我是胡说。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7905267715185185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-23 23:19">2025-02-23 23:19</span>&nbsp;
<a href="https://www.cnblogs.com/zhangchen-trunk">时风拖拉机</a>&nbsp;
阅读(<span id="post_view_count">209</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18733091" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18733091);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18733091', targetLink: 'https://www.cnblogs.com/zhangchen-trunk/p/18733091', title: '另类方式实现.Net下的多语言' })">举报</a>
</div>
        