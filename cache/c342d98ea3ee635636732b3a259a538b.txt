<!----> <meta itemprop="headline" content="同事用了个@vue:mounted，我去官网找了半天没找到"> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"> <meta itemprop="datePublished" content="2025-06-11T06:20:49.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="奈德丽"> <meta itemprop="url" content="https://juejin.cn/user/620537392934711"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            同事用了个@vue:mounted，我去官网找了半天没找到
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/620537392934711/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    奈德丽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-06-11T06:20:49.000Z" title="Wed Jun 11 2025 06:20:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-06-11
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    15,432
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p>大家好，我是奈德丽。</p>
<p>上周在做代码review的时候，看到同事小李写了这样一行代码：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;component :is="currentComponent" @vue:mounted="handleMounted" /&gt;
</code></pre>
<p>我第一反应是："这什么语法？似曾相识的样子，有点像在vue2中用过的<code>@hook:mounted</code>, 但我们项目是vue3，然后去Vue3官方文档搜索<code>@vue:mounted</code>，结果什么都没找到，一开始我以为是他研究了源码，结果他说是百度到的，那我们一起来来研究研究这个东西吧。</p>
<h2 data-id="heading-1">从一个动态组件说起</h2>
<p>小李的需求其实很简单：在子组件加载或更新或销毁后，需要获取组件的某些信息。这家伙是不是还看源码了，有这种骚操作，他的代码是这样的：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="demo-container"&gt;
    &lt;h2&gt;动态组件加载监控&lt;/h2&gt;
    &lt;div class="status"&gt;当前组件状态：{{ componentStatus }}&lt;/div&gt;
    
    &lt;div class="controls"&gt;
      &lt;button @click="loadComponent('ComponentA')"&gt;加载组件A&lt;/button&gt;
      &lt;button @click="loadComponent('ComponentB')"&gt;加载组件B&lt;/button&gt;
      &lt;button @click="unloadComponent"&gt;卸载组件&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;!-- 小李写的代码 --&gt;
    &lt;component 
      :is="currentComponent" 
      v-if="currentComponent"
      @vue:mounted="handleMounted"
      @vue:updated="handleUpdated"
      @vue:beforeUnmount="handleBeforeUnmount"
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const currentComponent = ref(null)
const componentStatus = ref('无组件')

const handleMounted = () =&gt; {
  componentStatus.value = '✅ 组件已挂载'
  console.log('组件挂载完成')
}

const handleUpdated = () =&gt; {
  componentStatus.value = '🔄 组件已更新'
  console.log('组件更新完成')
}

const handleBeforeUnmount = () =&gt; {
  componentStatus.value = '❌ 组件即将卸载'
  console.log('组件即将卸载')
}

const loadComponent = (name) =&gt; {
  currentComponent.value = name
}

const unloadComponent = () =&gt; {
  currentComponent.value = null
  componentStatus.value = '无组件'
}
&lt;/script&gt;
</code></pre>
<p>我仔细分析了一下，在这个动态组件的场景下，<code>@vue:mounted</code>确实有它的优势。最大的好处是<strong>只需要在父组件一个地方处理</strong>，不用去修改每个可能被动态加载的子组件。想象一下，如果有十几个不同的组件都可能被动态加载，你得在每个组件里都加上emit事件，维护起来确实麻烦。</p>
<p>而用<code>@vue:mounted</code>的话，所有的生命周期监听逻辑都集中在父组件这一个地方，代码看起来更集中，也更好管理。</p>
<p>但是，我心里还是有疑虑：<strong>这个语法为什么在官方文档里找不到？</strong></p>
<h2 data-id="heading-2">深入探索：未文档化的功能</h2>
<p>经过一番搜索，我在Vue的GitHub讨论区找到了答案。原来这个功能确实存在，但Vue核心团队明确表示：</p>
<blockquote>
<p>"这个功能不是为用户应用程序设计的，这就是为什么我们决定不文档化它。"</p>
</blockquote>
<p>引用来源：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Forgs%2Fvuejs%2Fdiscussions%2F9298" target="_blank" title="https://github.com/orgs/vuejs/discussions/9298" ref="nofollow noopener noreferrer">github.com/orgs/vuejs/…</a></p>
<p>换句话说：</p>
<ul>
<li>✅ 这个功能确实存在且能用</li>
<li>❌ 但官方不保证稳定性</li>
<li>⚠️ 可能在未来版本中被移除</li>
<li>🚫 不推荐在生产环境使用</li>
</ul>
<p>我们来看一下vue迁移文档中关于Vnode的部分，关键点我用下划线标红了。有趣的是这个@vue：[生命周期]语法不仅可以用在组件上，也可以用在所有虚拟节点中。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34c2468ec8ea4e87a1f3bdd4d6c9174c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWI5b635Li9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755578489&amp;x-signature=slXNivhhi16dCIe3crCAWEuQ41U%3D" alt="image.png" loading="lazy"></p>
<p>虽然在Vue 3迁移指南中有提到从<code>@hook:</code>（Vue 2）改为<code>@vue:</code>（Vue 3）的变化，但这更多是为了兼容性考虑，而不是鼓励使用。</p>
<h3 data-id="heading-3">为什么小李的代码"看起来"没问题？</h3>
<p>回到小李的动态组件场景，<code>@vue:mounted</code>确实解决了问题：</p>
<ol>
<li><strong>集中管理</strong> - 所有生命周期监听逻辑都在父组件一个地方</li>
<li><strong>动态性强</strong> - 不需要知道具体加载哪个组件</li>
<li><strong>代码简洁</strong> - 不需要修改每个子组件</li>
<li><strong>即用即走</strong> - 临时监听，用完就完</li>
</ol>
<p>但问题在于，这是一个<strong>不稳定的API</strong>，随时可能被移除。</p>
<h2 data-id="heading-4">我给出的review意见</h2>
<p>考虑到安全性和稳定性，还是以下方案靠谱</p>
<h3 data-id="heading-5">方案一：子组件主动汇报（推荐）</h3>
<p>虽然需要修改子组件，但这是最可靠的方案：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- ComponentA.vue --&gt;
&lt;template&gt;
  &lt;div class="component-a"&gt;
    &lt;h3&gt;我是组件A&lt;/h3&gt;
    &lt;button @click="counter++"&gt;点击次数: {{ counter }}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted, onUpdated, onBeforeUnmount } from 'vue'

const emit = defineEmits(['lifecycle'])
const counter = ref(0)

onMounted(() =&gt; {
  emit('lifecycle', { type: 'mounted', componentName: 'ComponentA' })
})

onUpdated(() =&gt; {
  emit('lifecycle', { type: 'updated', componentName: 'ComponentA' })
})

onBeforeUnmount(() =&gt; {
  emit('lifecycle', { type: 'beforeUnmount', componentName: 'ComponentA' })
})
&lt;/script&gt;
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- ComponentB.vue --&gt;
&lt;template&gt;
  &lt;div class="component-b"&gt;
    &lt;h3&gt;我是组件B&lt;/h3&gt;
    &lt;input v-model="text" placeholder="输入文字"&gt;
    &lt;p&gt;{{ text }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted, onUpdated, onBeforeUnmount } from 'vue'

const emit = defineEmits(['lifecycle'])
const text = ref('')

onMounted(() =&gt; {
  emit('lifecycle', { type: 'mounted', componentName: 'ComponentB' })
})

onUpdated(() =&gt; {
  emit('lifecycle', { type: 'updated', componentName: 'ComponentB' })
})

onBeforeUnmount(() =&gt; {
  emit('lifecycle', { type: 'beforeUnmount', componentName: 'ComponentB' })
})
&lt;/script&gt;
</code></pre>
<p>父组件使用：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;component 
  :is="currentComponent" 
  v-if="currentComponent"
  @lifecycle="handleLifecycle"
/&gt;

&lt;script setup&gt;
const handleLifecycle = ({ type, componentName }) =&gt; {
  const statusMap = {
    mounted: '✅ 已挂载',
    updated: '🔄 已更新', 
    beforeUnmount: '❌ 即将卸载'
  }
  componentStatus.value = `${componentName} ${statusMap[type]}`
  console.log(`${componentName} ${type}`)
}
&lt;/script&gt;
</code></pre>
<p><strong>优点</strong>：稳定可靠，官方推荐</p>
<p><strong>缺点</strong>：需要修改每个子组件，有一定的重复代码</p>
<h3 data-id="heading-6">方案二：通过ref访问（适合特定场景）</h3>
<p>如果你确实需要访问组件实例：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;component 
  :is="currentComponent" 
  v-if="currentComponent"
  ref="dynamicComponentRef"
/&gt;

&lt;script setup&gt;
import { ref, watch, nextTick } from 'vue'

const dynamicComponentRef = ref(null)

// 监听组件变化
watch(currentComponent, async (newComponent) =&gt; {
  if (newComponent) {
    await nextTick()
    console.log('组件实例:', dynamicComponentRef.value)
    componentStatus.value = '✅ 组件已挂载'
    // 可以访问组件的方法和数据
    if (dynamicComponentRef.value?.someMethod) {
      dynamicComponentRef.value.someMethod()
    }
  }
}, { immediate: true })
&lt;/script&gt;
</code></pre>
<p><strong>优点</strong>：可以直接访问组件实例和方法</p>
<p><strong>缺点</strong>：只能监听到挂载，无法监听更新和卸载</p>
<h3 data-id="heading-7">方案三：provide/inject（深层通信）</h3>
<p>如果是复杂的嵌套场景，组件层级深的时候我们可以使用这个：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 父组件 --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue'

const componentStatus = ref('无组件')

const lifecycleHandler = {
  onMounted: (name) =&gt; {
    componentStatus.value = `✅ ${name} 已挂载`
    console.log(`${name} 已挂载`)
  },
  onUpdated: (name) =&gt; {
    componentStatus.value = `🔄 ${name} 已更新`
    console.log(`${name} 已更新`)
  },
  onBeforeUnmount: (name) =&gt; {
    componentStatus.value = `❌ ${name} 即将卸载`
    console.log(`${name} 即将卸载`)
  }
}

provide('lifecycleHandler', lifecycleHandler)
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;
    &lt;div class="status"&gt;{{ componentStatus }}&lt;/div&gt;
    &lt;component :is="currentComponent" v-if="currentComponent" /&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 子组件 --&gt;
&lt;script setup&gt;
import { inject, onMounted, onUpdated, onBeforeUnmount } from 'vue'

const lifecycleHandler = inject('lifecycleHandler', {})
const componentName = 'ComponentA' // 每个组件设置自己的名称

onMounted(() =&gt; {
  lifecycleHandler.onMounted?.(componentName)
})

onUpdated(() =&gt; {
  lifecycleHandler.onUpdated?.(componentName)
})

onBeforeUnmount(() =&gt; {
  lifecycleHandler.onBeforeUnmount?.(componentName)
})
&lt;/script&gt;
</code></pre>
<p><strong>优点</strong>：适合深层嵌套，可以跨多层传递</p>
<h3 data-id="heading-8">各种方案的对比</h3>













































<table><thead><tr><th>方案</th><th>实现难度</th><th>可靠性</th><th>维护性</th><th>集中管理</th><th>适用场景</th></tr></thead><tbody><tr><td>emit事件</td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>❌</td><td>🏆 大部分场景的首选</td></tr><tr><td>ref访问</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>✅</td><td>需要调用组件方法时</td></tr><tr><td>provide/inject</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>✅</td><td>深层嵌套组件通信</td></tr><tr><td>@vue:mounted</td><td>⭐</td><td>⭐⭐</td><td>⭐</td><td>✅</td><td>⚠️ 自己项目可以玩玩，不推荐生产使用</td></tr></tbody></table>
<h2 data-id="heading-9">总结</h2>
<p>通过这次code review，我们学到了：</p>
<ol>
<li>
<p><strong>技术选型要考虑长远</strong> - 不是所有能用的功能都应该用，稳定性比便利性更重要</p>
</li>
<li>
<p><strong>特定场景的权衡</strong> - 在动态组件场景下，<code>@vue:[生命周期]</code>确实有集中管理的优势，但要权衡风险</p>
</li>
<li>
<p><strong>迁移策略很重要</strong> - 不能一刀切，要有合理的过渡方案</p>
</li>
<li>
<p><strong>代码review的价值</strong> - 不仅仅是找bug，更是知识分享和技术决策的过程</p>
</li>
<li>
<p><strong>文档化的重要性</strong> - 未文档化的API往往意味着不稳定，使用时要谨慎</p>
</li>
</ol>
<p>虽然<code>@vue:[生命周期]</code>在动态组件场景下确实好用，但从工程化角度考虑，还是建议逐步迁移到官方推荐的方案。毕竟，今天的便利可能是明天的技术债务。</p>
<p>当然，如果你正在维护老项目，且迁移成本较高，也可以考虑先保留现有代码，但一定要有明确的迁移计划和风险控制措施。</p>
<p>恩恩……懦夫的味道</p></div></div>