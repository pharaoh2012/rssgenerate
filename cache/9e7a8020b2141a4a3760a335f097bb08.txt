
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/doooge/p/19013307" title="发布于 2025-07-30 17:08">
    <span role="heading" aria-level="2">浅析快速傅里叶变换（FFT）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>哈喽大家好，我是 doooge，今天给大家来点想看的东西啊。</p>
<p></p><div class="math display">\[\Huge \sf 浅析快速傅里叶变换（FFT）
\]</div><p></p><h1 id="1-前置知识">1. 前置知识</h1>
<p>工欲善其事，必先利其器，讲 FFT 之前我先将一些废话，如果你是 dalao 你也可以不听。</p>
<h2 id="11-复数">1.1 复数</h2>
<p>高中数学里的一个非常高深的东西叫做虚数，但是它的定义很简单：</p>
<p></p><div class="math display">\[\large i=\sqrt{-1}
\]</div><p></p><p>而复数，就是虚数和实数相结合的东西， 它的表现方式为 <span class="math inline">\(a+bi\)</span>，这个东西的运算比较简单，我在这里稍稍赘述一下：</p>
<p></p><div class="math display">\[\large (a+bi)+(c+di)=a+c+(b+d)i
\]</div><p></p><p></p><div class="math display">\[\large (a+bi)-(c+di)=a-c+(b-d)i
\]</div><p></p><p></p><div class="math display">\[\large (a+bi)(c+di)=ac+adi+bci+dbi^2=a(c+di)+b(ci-d)
\]</div><p></p><p>至于除法嘛，就不太需要了，绝对不是因为我懒（</p>
<p>那我们怎么才能表示一个复数呢？我们可以用两个轴，实数轴和虚数轴，这个玩意叫复平面：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x56f26iu.png" alt="" loading="lazy"></p>
<p>在 c++ 中，STL 提供了 <code>complex</code> 类型来表示复数，但是我个人更倾向与用结构体来定义：</p>
<pre><code class="language-cpp">struct Mycomplex{
	double x,i;
	Mycomplex operator+(const Mycomplex &amp;a){return {x+a.x,i+a.i};}
	Mycomplex operator-(const Mycomplex &amp;a){return {x-a.x,i-a.i};}
	Mycomplex operator*(const Mycomplex &amp;a){return {x*a.x-i*a.i,x*a.i+i*a.x};}
}a[1000010];
</code></pre>
<h2 id="12-单位根">1.2 单位根</h2>
<p>我们在复平面上画一个半径为 <span class="math inline">\(1\)</span> 的圆，圆的边上每一个点都满足 <span class="math inline">\(x^2+y^2=1\)</span>，也就是每一个点都满足它到 <span class="math inline">\((0,0)\)</span> 的点为 <span class="math inline">\(1\)</span>。</p>
<p>了解 FFT 前，我们先要知道 <span class="math inline">\(n\)</span> 次单位根，定义 <span class="math inline">\(\omega_{n}\)</span> 为 <span class="math inline">\(x^n=1\)</span> 的根，如果 <span class="math inline">\(x\)</span> 只能为实数，显然最多只能有两个根 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span>，但是我们转到复数上时，这样的根有 <span class="math inline">\(n\)</span> 个：<span class="math inline">\(\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1}\)</span>。</p>
<p>伟大的数学家欧拉告诉我们：</p>
<p></p><div class="math display">\[\large e^{ix}=\cos x+i\sin x
\]</div><p></p><p>不难发现，我们刚才求的 <span class="math inline">\(\omega_{n}^x\)</span> 似乎都与欧拉公式有关：</p>
<p></p><div class="math display">\[\large\omega_{n}^i=e^{i2\pi\cdot\frac{x}{n}}=e^{\frac{2ix\pi}{n}}
\]</div><p></p><p>也就是：</p>
<p></p><div class="math display">\[\omega_{n}^x=\cos x+i\sin x
\]</div><p></p><p>我们把它放在图上，不难看出 <span class="math inline">\(-\omega_n^x=\omega_n^{n+x}\)</span>：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/p4mmrwer.png" alt="" loading="lazy"></p>
<p>但是如果这样就下结论的话，也太扯淡了，我们还需要证明，证明如下：</p>
<ul>
<li>当 <span class="math inline">\(x=1\)</span>，显然成立。</li>
<li>当 <span class="math inline">\(x=k-1\)</span> 成立时，<span class="math inline">\(w_{n}^k=w_{n}^{k-1}\cdot w_{n}^1=(\cos (k-1)+i\sin(k-1))\cdot (\cos 1+i \sin 1)=\cos k+i\sin k\)</span>。</li>
</ul>
<p>证毕。</p>
<h2 id="13-多项式">1.3 多项式</h2>
<p>设有一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(f(k)\)</span>，我们有 <span class="math inline">\(n\)</span> 个系数 <span class="math inline">\(a_0,a_1,\cdots,a_{n-1}\)</span>：</p>
<p></p><div class="math display">\[\large f(k)=\sum_{i=0}^{n-1} a_ix^i
\]</div><p></p><p>显然可以用 <span class="math inline">\(n\)</span> 个系数来表示这个多项式，这个东西叫做系数表示法。</p>
<p>我们可以用 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_0,y_0),\cdots,(x_{n-1},y_{n-1})\)</span> 来表示一个 <span class="math inline">\(n-1\)</span> 次的多项式（至于为什么我也不知道），这个东西叫做点值表示法，感兴趣的可以自己去搜一下。</p>
<h2 id="14-多项式乘法">1.4 多项式乘法</h2>
<p>记乘出的多项式用系数表示法为 <span class="math inline">\(C\)</span>，乘起来的两个多项式为 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，那么：</p>
<p></p><div class="math display">\[\large C_i=\sum_{i=0}^{n-1}A_iB_{n-i-1}
\]</div><p></p><p>如果是用点值表示法那就更简单了：</p>
<p></p><div class="math display">\[\large C_i=A_iB_i
\]</div><p></p><p>是不是挺像高精度的？</p>
<p>好了，前置知识就这么多了，正片开始！</p>
<h1 id="2-快速傅里叶变换fft">2. 快速傅里叶变换（FFT）</h1>
<p>如果我们直接暴力枚举 <span class="math inline">\(n+1\)</span> 个点表示系数，在将系数相乘，复杂度 <span class="math inline">\(O(n^2)\)</span>，不够优秀。我们尝试换一种方法。</p>
<p>假设原本的多项式为 <span class="math inline">\(A\)</span>，我们重新设两个多项式 <span class="math inline">\(A_0\)</span> 和 <span class="math inline">\(A_1\)</span> 来表示 <span class="math inline">\(A\)</span> 中的第奇数、偶数项函数，就比如：</p>
<p></p><div class="math display">\[A(x)=3+2x+5x^2+4x^3
\]</div><p></p><p></p><div class="math display">\[A_0(x^2)=3+5x^2
\]</div><p></p><p></p><div class="math display">\[A_1(x^2)=2+4x^2
\]</div><p></p><p>不难看出：</p>
<p></p><div class="math display">\[A(x)=A_0(x^2)+xA_1(x^2)
\]</div><p></p><p></p><div class="math display">\[A(-x)=A_0(x^2)-A_1(x^2)
\]</div><p></p><p>但是如果 <span class="math inline">\(x\)</span> 为负数，这个做法就行不通了，我们可以把单位根带进去：</p>
<p></p><div class="math display">\[\begin{aligned}
A(\omega_n^x)=A_0(\omega_n^{2x})+\omega_n^xA_1(\omega_n^{2x})\\
=A_0(\omega_{\frac{n}{2}}^x)+\omega_{n}^xA_1(\omega_{\frac{n}{2}}^x)
\end{aligned}
\]</div><p></p><p></p><div class="math display">\[A(-\omega_{n}^{x})=A(\omega_{n}^{n+x})=A_0(\omega_{\frac{n}{2}}^{n+x})+\omega_{n}^{n+x}A_1(\omega_{\frac{n}{2}}^{n+x})
\]</div><p></p><p>我们可以递归求解 <span class="math inline">\(A_0\)</span> 和 <span class="math inline">\(A_1\)</span>。具体来说，我们已经求出了 <span class="math inline">\(A_0,A_1\)</span> 在 <span class="math inline">\(x\)</span> 等于 <span class="math inline">\(\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}\)</span> 时的值，我们就能在 <span class="math inline">\(O(n)\)</span> 的情况下求出 <span class="math inline">\(A\)</span> 在这些地方的值。</p>
<p>代码：</p>
<pre><code class="language-cpp">const double pi=3.141592653589793238;//这个不用背
//也可以这样写#define pi acos(1.0)
void FastFastTLE(Mycomplex a[],int n){
	if(n==1){
		return;
		//系数为1时，怎么递归都一样了，这里直接返回 
	}
	Mycomplex a0[(n&gt;&gt;1)+1],a1[(n&gt;&gt;1)+1];//保证每层空间都是线性，但是别忘了+1 
	for(int i=0;i&lt;n;i++){ 
		if(i&amp;1)a1[i&gt;&gt;1]=a[i];
		else a0[i&gt;&gt;1]=a[i];
	}//处理系数
	FastFastTLE(a0,n&gt;&gt;1),FastFastTLE(a1,n&gt;&gt;1);
	Mycomplex w_n1={cos(2*pi/n),sin(2*pi/n)},W={1,0};//W初始为w_n^0
	for(int i=0;i&lt;n&gt;&gt;1;i++){
		a[i]=a0[i]+W*a1[i];
		a[i+(n&gt;&gt;1)]=a0[i]-W*a1[i];
		W=W*w_n1;//w_ni=w_n(i-1)*w_n^1
	} 
	return;
}
</code></pre>
<h1 id="3-fft逆变换ifft">3. FFT逆变换（IFFT）</h1>
<p>我们现在虽然能够将一个多项式转化成点值表示法，但是我们因该如何将他转回系数表示法呢？回想一下，为什么我们要给 <span class="math inline">\(A\)</span> 找 <span class="math inline">\(\omega_{n}^x\)</span> 这样的取值，当然是因为它的特殊性质。</p>
<p>这里给一个结论：我们知道了 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(\omega_n^i\)</span>，我们设 <span class="math inline">\(B\)</span> 的系数 <span class="math inline">\(B_i=A\)</span> 的 <span class="math inline">\(w_n^i\)</span> 处的取值，取单位根的复数 <span class="math inline">\(\omega_n^0,\omega_n^{-1},\cdots,\omega_n^{-(n-1)}\)</span>，再带入 <span class="math inline">\(B\)</span>，得出结果 <span class="math inline">\(C\)</span> 的各项除上 <span class="math inline">\(n\)</span>，就是 <span class="math inline">\(A\)</span> 的各个系数。</p>
<p>下面给出证明（这是我抄网上的，如果看不懂就直接记结论吧）：</p>
<p>首先设多项式 <span class="math inline">\(A\)</span>：</p>
<p></p><div class="math display">\[\large A=\sum_{i=0}^{n-1}a_ix^i
\]</div><p></p><p>再设 <span class="math inline">\(y_0,y_1,\cdots,y_n\)</span> 为 <span class="math inline">\(A\)</span> 的傅里叶变换，设多项式 <span class="math inline">\(B\)</span>：</p>
<p></p><div class="math display">\[\large B=\sum_{i=0}^{n-1}y_ix^i
\]</div><p></p><p>将 <span class="math inline">\(\omega_n^0,\omega_n^{-1},\cdots,\omega_n^{-(n-1)}\)</span> 代入 <span class="math inline">\(B\)</span>，得到 <span class="math inline">\((z_0,z_1,\cdots,z_n)\)</span>，而此时：</p>
<p></p><div class="math display">\[\begin{aligned}
z_k=\sum_{i=0}^{n-1} y_i (\omega_n^{-k})^i\\
=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i\\
=\sum_{j=0}^{n-1}a_j(\sum_{i=0}^{n-1}(\omega_{n}^i)^{j-k})
\end{aligned}
\]</div><p></p><p>当 <span class="math inline">\(j-k=0\)</span> 时，<span class="math inline">\(\sum_{i=0}^{n-1}(\omega_{n}^i)^{j-k}=n\)</span>，否则，我们可以用等比数列求和公式 <span class="math inline">\(S_n=\frac{a_1(1-q^n)}{1-q}\)</span> 得到：</p>
<p></p><div class="math display">\[\begin{aligned}
\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=\frac{(\omega_n^{j-k})^n-1}{\omega_{n}^{j-k}-1}\\
=\frac{(\omega_n^n)^{j-k}-1}{w_{n}^{j-k}-1}\\
=\frac{(\omega_n^0)^{j-k}-1}{w_{n}^{j-k}-1}\\
=\frac{1-1}{1}\\
=0
\end{aligned}
\]</div><p></p><p>所以 <span class="math inline">\(z_k=n\cdot a_k\)</span>，<span class="math inline">\(a_k=\frac{z_k}{n}\)</span>，证毕。</p>
<p>我们就能愉快的 FFT 了！但是先别急，虽然递归 FFT 的时间 / 空间复杂度都是 <span class="math inline">\(O(n\log n)\)</span>，但是常数比较大，我们还要进一步优化。</p>
<h1 id="4-非递归版-fft">4. 非递归版 FFT</h1>
<p>我们尝试优化 FFT 的递归过程</p>
<p>我们知道递归 FFT 是让这个多项式的奇偶分开再分别递归，我们能否找到一些规律呢？当然可以，画个图试试，假设 <span class="math inline">\(n=8\)</span>：</p>
<p><span class="math inline">\(0,1,2,3,4,5,6,7\)</span><br>
<span class="math inline">\(0,2,4,6|1,3,5,7\)</span><br>
<span class="math inline">\(0,4|2,6|1,5|3,7\)</span><br>
结果：<br>
<span class="math inline">\(0,4,2,6,1,3,5,7\)</span></p>
<p>看不出什么规律？我们把这个数列初始和结束的二进制写出来：</p>
<p><span class="math inline">\((000)_2,(001)_2,(010)_2,(011)_2,(100)_2,(101)_2,(110)_2,(111)_2\)</span><br>
<span class="math inline">\((000)_2,(100)_2,(010)_2,(110)_2,(001)_2,(101)_2,(011)_2,(111)_2\)</span><br>
<strong>注意：n必须要是2的次幂，我们可以在前面补0解决</strong></p>
<p>欸？开始和结束每个数字的二进制区别不就是翻转了一遍吗？</p>
<p>处理起来是这样的：</p>
<pre><code class="language-cpp">rev[0]=0;//rev[i]表示i二进制转换后的值 
for(int i=1;i&lt;n;i++){
	rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(1&lt;&lt;(l&gt;&gt;1)));//前i-1位转换后的值+这一位要不要翻转 
}
</code></pre>
<p>然后呢？我们可以模拟它合并的过程，下面给出代码：</p>
<pre><code class="language-cpp">void FastFastTLE(Mycomplex A[],int n,int typ){//typ=1为正变换，typ=-1为逆变换 
	for(int i=0;i&lt;n;i++){//处理交换 
		if(i&lt;rev[i])swap(A[i],A[rev[i]]);
	}
	for(int l=1;l&lt;n;l&lt;&lt;=1){//枚举长度 
		Mycomplex w={cos(pi/l),typ*sin(pi/l)};
		for(int i=0;i&lt;n;i+=l&lt;&lt;1){//枚举每一次合并的位置 
			Mycomplex o={1,0};
			for(int j=0;j&lt;l;j++){
				Mycomplex x=A[i+j],y=A[i+j+l]*o;
				A[i+j]=x+y;
				A[i+j+l]=x-y;
				o=o*w;
			} 
		} 
	}
	return;
}
</code></pre>
<h1 id="5-完整代码">5. 完整代码</h1>
<p>模板题：<a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener nofollow">P3803 【模板】多项式乘法（FFT）</a>，<a href="https://www.luogu.com.cn/problem/P1919" target="_blank" rel="noopener nofollow">P1919 【模板】高精度乘法 | A*B Problem 升级版</a>。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const double pi=3.141592653589793238;
struct Mycomplex{
	double x,i;
	Mycomplex operator+(const Mycomplex &amp;a){return {x+a.x,i+a.i};}
	Mycomplex operator-(const Mycomplex &amp;a){return {x-a.x,i-a.i};}
	Mycomplex operator*(const Mycomplex &amp;a){return {x*a.x-i*a.i,x*a.i+i*a.x};}
}a[3000010],b[3000010],c[30000010];//建议开3倍空间防止RE 
int rev[3000010],n=1;
void init(){//预处理翻转和w_n^i 
	rev[0]=0;
	for(int i=1;i&lt;n;i++){
		rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1));
	}
	return;
}
void FastFastTLE(Mycomplex A[],int n,int typ){//typ=1为正变换，typ=-1为逆变换 
	for(int i=0;i&lt;n;i++){//处理交换 
		if(i&lt;rev[i])swap(A[i],A[rev[i]]);
	}
	for(int l=1;l&lt;n;l&lt;&lt;=1){//枚举长度 
		Mycomplex w={cos(pi/l),typ*sin(pi/l)};
		for(int i=0;i&lt;n;i+=l&lt;&lt;1){//枚举每一次合并的位置 
			Mycomplex o={1,0};
			for(int j=0;j&lt;l;j++){
				Mycomplex x=A[i+j],y=A[i+j+l]*o;
				A[i+j]=x+y;
				A[i+j+l]=x-y;
				o=o*w;
			} 
		} 
	}
	return;
}
int main(){
	int N,M;
	cin&gt;&gt;N&gt;&gt;M;
	for(int i=0;i&lt;=N;i++){
		cin&gt;&gt;a[i].x;
	}
	for(int i=0;i&lt;=M;i++){
		cin&gt;&gt;b[i].x;
	}
	while(n&lt;=N+M)n&lt;&lt;=1;
	//特别注意这里n必须要是2的整数次幂！！！
	init();
	FastFastTLE(a,n,1);
	FastFastTLE(b,n,1);
	for(int i=0;i&lt;=n;i++){//直接乘点值 
		c[i]=a[i]*b[i];
	} 
	FastFastTLE(c,n,-1);
	for(int i=0;i&lt;=N+M;i++){
		printf("%d ",int(c[i].x/n+0.5));//注意这里的四舍五入 
	}
	cout&lt;&lt;endl; 
	return 0;
}//完结撒花！！！ 
</code></pre>
<h1 id="6-闲话">6. 闲话</h1>
<p>最害怕的一集。</p>
<p>其实在去年CSP集训前就想学 FFT 了，但奈何我的数学太差（虽然现在数学也不好），导致一直没啃下来，但由于主播马上要小升初了，打算写完这篇文章（？）</p>
<p>首先膜拜巨佬 _FastFT2013 的<a href="https://www.luogu.me/article/7aas5pdl" target="_blank" rel="noopener nofollow">文章</a> 和巨佬 Sunrise_beforeglow 的<a href="https://www.luogu.com.cn/article/1673btlk" target="_blank" rel="noopener nofollow">文章</a>，如有雷同，一定是我抄他的。</p>
<p>蒟蒻不才，膜拜大佬，如果文章有什么错字等问题，请在评论区提醒我。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011805555555555555" data-date-updated="2025-07-30 17:25">2025-07-30 17:08</span>&nbsp;
<a href="https://www.cnblogs.com/doooge">doooge</a>&nbsp;
阅读(<span id="post_view_count">132</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19013307);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19013307', targetLink: 'https://www.cnblogs.com/doooge/p/19013307', title: '浅析快速傅里叶变换（FFT）' })">举报</a>
</div>
        