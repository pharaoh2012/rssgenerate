
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18888400" title="发布于 2025-05-21 09:55">
    <span role="heading" aria-level="2">高效缓存的10条军规</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>"苏工！首页崩了！"</p>
<p>凌晨三点接到电话时，我正梦见自己成了缓存之神。</p>
<p>打开监控一看：</p>
<pre><code>缓存命中率：0%  
数据库QPS：10万+  
线程阻塞数：2000+
</code></pre>
<p>根本原因竟是之前有同事写的这段代码：</p>
<pre><code class="language-java">public Product getProduct(Long id) {  
    return productDao.findById(id); 
}
</code></pre>
<p>直连数据库，未加缓存。</p>
<p>这一刻我意识到：<strong>不会用缓存的程序员，就像不会刹车的赛车手</strong>。</p>
<p>今天这篇文章跟大家一起聊聊使用缓存的10条军规，希望对你会有所帮助。</p>
<h2 id="军规1-避免大key">军规1: 避免大key</h2>
<p><strong>反例场景</strong>：</p>
<pre><code class="language-java">@Cacheable(value = "user", key = "#id")  
public User getUser(Long id) {  
    return userDao.findWithAllRelations(id); 
}
</code></pre>
<p>这里一次查询出了用户及其所有关联对象，然后添加到内存缓存中。</p>
<p>如果通过id查询用户信息的请求量非常大，会导致频繁的GC。</p>
<p><strong>正确实践</strong>：</p>
<pre><code class="language-java">@Cacheable(value = "user_base", key = "#id")  
public UserBase getBaseInfo(Long id) { /*...*/ }  

@Cacheable(value = "user_detail", key = "#id")  
public UserDetail getDetailInfo(Long id) { /*...*/ }
</code></pre>
<p>这种情况，需要拆分缓存对象，比如：将用户基本信息和用户详细信息分开缓存。</p>
<p>缓存不是存储数据的垃圾桶，需要根据数据访问频率、读写比例、数据一致性要求进行分级管理。</p>
<p>大对象缓存会导致内存碎片化，甚至触发Full GC。</p>
<p>建议将基础信息（如用户ID、名称）与扩展信息（如订单记录）分离存储。</p>
<h2 id="军规2-永远设置过期时间">军规2: 永远设置过期时间</h2>
<p><strong>血泪案例</strong>：<br>
某系统将配置信息缓存设置为永不过期，导致修改配置后三天才生效。</p>
<p><strong>正确配置</strong>：</p>
<pre><code class="language-java">@Cacheable(value = "config", key = "#key",  
           unless = "#result == null",  
           cacheManager = "redisCacheManager")  
public String getConfig(String key) {  
    return configDao.get(key);  
}
</code></pre>
<p>Redis配置如下：</p>
<pre><code class="language-yml">spring.cache.redis.time-to-live=300000 // 5分钟  
spring.cache.redis.cache-null-values=false
</code></pre>
<p>需要指定key的存活时间，比如：time-to-live设置成5分钟。</p>
<p><strong>TTL设置公式</strong>：</p>
<pre><code class="language-plain">最优TTL = 平均数据变更周期 × 0.3
</code></pre>
<p><strong>深层思考</strong>：<br>
过期时间过短会导致缓存穿透风险，过长会导致数据不一致。</p>
<blockquote>
<p>建议采用动态TTL策略。</p>
</blockquote>
<p>例如电商商品详情页可设置30分钟基础TTL+随机5分钟抖动。</p>
<h2 id="军规3-避免批量失效">军规3: 避免批量失效</h2>
<p><strong>典型事故</strong>：<br>
所有缓存设置相同TTL，导致每天凌晨集中失效，数据库瞬时被打爆。</p>
<p><strong>解决方案</strong>：</p>
<p>使用基础TTL + 随机抖动的方案：</p>
<pre><code class="language-java">public long randomTtl(long baseTtl) {  
    return baseTtl + new Random().nextInt(300); 
}  
</code></pre>
<p>TTL增加0-5分钟随机值。</p>
<p>使用示例</p>
<pre><code>redisTemplate.opsForValue().set(key, value, randomTtl(1800), TimeUnit.SECONDS);
</code></pre>
<p><strong>失效时间分布</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/540c8bdc-f490-4070-b483-fe1c3ecca309.png" alt="" loading="lazy"></p>
<h2 id="军规4-需要增加熔断降级">军规4: 需要增加熔断降级</h2>
<p>我们在使用缓存的时候，需要增加熔断降级策略，防止万一缓存挂了，不能影响整个服务的可用性。</p>
<p><strong>Hystrix实现示例</strong>：</p>
<pre><code class="language-java">@HystrixCommand(fallbackMethod = "getProductFallback",  
               commandProperties = {  
                   @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"),  
                   @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "5000")  
               })  
public Product getProduct(Long id) {  
    return productDao.findById(id);  
}  

public Product getProductFallback(Long id) {  
    return new Product().setDefault(); // 返回兜底数据  
}
</code></pre>
<p><strong>熔断状态机</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/b607fd2b-114a-40b4-be53-f0eb36b271e9.png" alt="" loading="lazy"></p>
<h2 id="-军规5-空值缓存">▶ 军规5: 空值缓存</h2>
<p>在用户请求并发量大的业务场景种，我们需要把空值缓存起来。</p>
<p>防止大批量在系统中不存在的用户id，没有命中缓存，而直接查询数据库的情况。</p>
<p><strong>典型代码</strong>：</p>
<pre><code class="language-java">public Product getProduct(Long id) {  
    String key = "product:" + id;  
    Product product = redis.get(key);  
    if (product != null) {  
        if (product.isEmpty()) { // 空对象标识  
            return null;  
        }  
        return product;  
    }  

    product = productDao.findById(id);  
    if (product == null) {  
        redis.setex(key, 300, "empty"); // 缓存空值5分钟  
        return null;  
    }  

    redis.setex(key, 3600, product);  
    return product;  
}
</code></pre>
<p><strong>空值缓存原理</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/59b0d6da-80bb-4253-bbf5-c0e43a34cae6.png" alt="" loading="lazy"></p>
<p>需要将数据库中返回的空值，缓存起来。</p>
<p>后面如果有相同的key查询数据，则直接从缓存中返回空值。</p>
<p>而无需再查询一次数据库。</p>
<h2 id="军规6-分布式锁用redisson">军规6: 分布式锁用Redisson</h2>
<p>用Redis做分布式锁的时候，可能会遇到很多问题。</p>
<p>感兴趣的小伙伴可以看看我的这篇文章《<a href="https://mp.weixin.qq.com/s/EhucmYblfrRxbAuJTdPlfg" target="_blank" rel="noopener nofollow">聊聊redis分布式锁的8大坑</a>》。</p>
<p>建议大家使用Redisson做分布式锁。</p>
<p><strong>Redisson分布式锁实现</strong>：</p>
<pre><code class="language-plain">public Product getProduct(Long id) {  
    String key = "product:" + id;  
    Product product = redis.get(key);  
    if (product == null) {  
        RLock lock = redisson.getLock("lock:" + key);  
        try {  
            if (lock.tryLock(3, 30, TimeUnit.SECONDS)) {  
                product = productDao.findById(id);  
                redis.setex(key, 3600, product);  
            }  
        } finally {  
            lock.unlock();  
        }  
    }  
    return product;  
}
</code></pre>
<p><strong>锁竞争流程图</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/56303460-f89a-4845-b710-7f22037069b2.png" alt="" loading="lazy"></p>
<h2 id="军规7-延迟双删策略">军规7: 延迟双删策略</h2>
<p>在保证数据库和缓存双写数据一致性的业务场景种，可以使用延迟双删的策略。</p>
<p>例如：</p>
<pre><code class="language-java">@Transactional  
public void updateProduct(Product product) {  
    // 1. 先删缓存  
    redis.delete("product:" + product.getId());  

    // 2. 更新数据库  
    productDao.update(product);  

    // 3. 延时再删  
    executor.schedule(() -&gt; {  
        redis.delete("product:" + product.getId());  
    }, 500, TimeUnit.MILLISECONDS);  
}
</code></pre>
<h2 id="军规8-最终一致性方案">军规8: 最终一致性方案</h2>
<p>延迟双删可能还有其他的问题。</p>
<p>对延迟双删问题比较感兴趣的小伙伴可以看看我的《<a href="https://mp.weixin.qq.com/s/4hP-T0h8QPyjcpH8m0cbsA" target="_blank" rel="noopener nofollow">如何保证数据库和缓存双写一致性？</a>》，里面有详细的介绍。</p>
<p>我们可以使用最终一致性方案。</p>
<p><strong>基于Binlog的方案</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/24047e7d-37ac-4ad6-b5fb-293fa0b0dcd5.png" alt="" loading="lazy"></p>
<p>DB更新数据之后，Canal会自动监听数据的变化，它会解析数据事件，然后发送一条MQ消息。</p>
<p>在MQ消费者中，删除缓存。</p>
<h2 id="军规9-热点数据预加载">军规9: 热点数据预加载</h2>
<p>对于一些经常使用的热点数据，我们可以提前做数据的预加载。</p>
<p><strong>实时监控方案</strong>：</p>
<pre><code class="language-java">// 使用Redis HyperLogLog统计访问频率  
public void recordAccess(Long productId) {  
    String key = "access:product:" + productId;  
    redis.pfadd(key, UUID.randomUUID().toString());  
    redis.expire(key, 60); // 统计最近60秒  
}  

// 定时任务检测热点  
@Scheduled(fixedRate = 10000)  
public void detectHotKeys() {  
    Set&lt;String&gt; keys = redis.keys("access:product:*");  
    keys.forEach(key -&gt; {  
        long count = redis.pfcount(key);  
        if (count &gt; 1000) { // 阈值  
            Long productId = extractId(key);  
            preloadProduct(productId);  
        }  
    });  
}
</code></pre>
<p>定时任务检测热点，并且更新到缓存中。</p>
<h2 id="军规10-根据场景选择数据结构">军规10: 根据场景选择数据结构</h2>
<p><strong>血泪案例</strong>：<br>
某社交平台使用String类型存储用户信息。</p>
<p>错误用String存储对象：</p>
<pre><code class="language-java">redis.set("user:123", JSON.toJSONString(user));  

</code></pre>
<p>每次更新单个字段都需要反序列化整个对象。</p>
<p>导致问题：</p>
<ol>
<li>序列化/反序列化开销大</li>
<li>更新单个字段需读写整个对象</li>
<li>内存占用高<br>
正确实践：</li>
</ol>
<pre><code>// 使用Hash存储  
redis.opsForHash().putAll("user:123", userToMap(user));  

// 局部更新  
redis.opsForHash().put("user:123", "age", "25"); 
</code></pre>
<p>数据结构选择矩阵：</p>
<p><img src="https://files.mdnice.com/user/5303/4d61565d-e1a4-40c7-a7e1-fe36162d4163.png" alt="" loading="lazy"></p>
<p>各数据结构最佳实践：</p>
<h3 id="1string">1.String</h3>
<p>计数器</p>
<pre><code>redis.opsForValue().increment("article:123:views");  
</code></pre>
<p>分布式锁</p>
<pre><code>redis.opsForValue().set("lock:order:456", "1", "NX", "EX", 30);  
</code></pre>
<h3 id="2hash">2.Hash</h3>
<p>存储商品信息</p>
<pre><code>Map&lt;String, String&gt; productMap = new HashMap&lt;&gt;();  
productMap.put("name", "iPhone15");  
productMap.put("price", "7999");  
redis.opsForHash().putAll("product:789", productMap);  
</code></pre>
<p>部分更新</p>
<pre><code>redis.opsForHash().put("product:789", "stock", "100");  
</code></pre>
<h3 id="3list">3.List</h3>
<p>消息队列</p>
<pre><code>redis.opsForList().leftPush("queue:payment", orderJson);  
</code></pre>
<p>最新N条记录</p>
<pre><code>redis.opsForList().trim("user:123:logs", 0, 99); 
</code></pre>
<h3 id="4set">4.Set</h3>
<p>标签系统</p>
<pre><code>redis.opsForSet().add("article:123:tags", "科技", "数码");  
</code></pre>
<p>共同好友</p>
<pre><code>redis.opsForSet().intersect("user:123:friends", "user:456:friends"); 
</code></pre>
<h3 id="5zset">5.ZSet</h3>
<p>排行榜</p>
<pre><code>redis.opsForZSet().add("leaderboard", "player1", 2500);  
redis.opsForZSet().reverseRange("leaderboard", 0, 9);  
</code></pre>
<p>延迟队列</p>
<pre><code>redis.opsForZSet().add("delay:queue", "task1", System.currentTimeMillis() + 5000); 
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="缓存治理黄金法则">缓存治理黄金法则</h3>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>推荐方案</th>
<th>工具推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存穿透</td>
<td>空值缓存+布隆过滤器</td>
<td>Redisson BloomFilter</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>随机TTL+熔断降级</td>
<td>Hystrix/Sentinel</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>互斥锁+热点预加载</td>
<td>Redisson Lock</td>
</tr>
<tr>
<td>数据一致性</td>
<td>延迟双删+最终一致性</td>
<td>Canal+RocketMQ</td>
</tr>
</tbody>
</table>
<p><img src="https://files.mdnice.com/user/5303/92c414f2-396d-4ddb-95b0-e2b2e3a84949.png" alt="" loading="lazy"></p>
<p><strong>最后忠告</strong>：缓存是把双刃剑，用得好是性能利器，用不好就是定时炸弹。</p>
<p>当你准备引入缓存时，先问自己三个问题：</p>
<ol>
<li>真的需要缓存吗？</li>
<li>缓存方案是否完整？</li>
<li>有没有兜底措施？</li>
</ol>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，我的所有文章都会在公众号上首发，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05220903786111111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-21 09:55">2025-05-21 09:55</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18888400);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18888400', targetLink: 'https://www.cnblogs.com/12lisu/p/18888400', title: '高效缓存的10条军规' })">举报</a>
</div>
        