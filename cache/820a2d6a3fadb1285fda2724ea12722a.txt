
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18944922" title="发布于 2025-06-23 19:22">
    <span role="heading" aria-level="2">STL：迭代器与常用算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="迭代器">迭代器</h1>
<p>C++ STL（Standard Template Library，标准模板库）中<strong>迭代器</strong>与<strong>常用算法</strong>是泛型编程的核心组成部分。它们配合使用，可以对容器进行高效、统一的操作。下面是对它们的系统性总结。</p>
<hr>
<h2 id="一什么是迭代器iterator">一、什么是迭代器（Iterator）</h2>
<p><strong>迭代器</strong>是 STL 的核心，用于访问容器中的元素。迭代器本质上就是一种“广义的指针”，它提供了统一的方式来访问容器中的元素。</p>
<h3 id="功能包括">功能包括：</h3>
<ul>
<li><strong>访问</strong>元素：通过 <code>*it</code> 读取元素</li>
<li><strong>遍历</strong>元素：使用 <code>++it</code>、<code>--it</code>、<code>it + n</code> 等</li>
<li><strong>修改</strong>元素（对于非 const 迭代器）</li>
</ul>
<hr>
<h2 id="二迭代器的分类五种类型">二、迭代器的分类（五种类型）</h2>
<p>STL 中的迭代器按功能分为五种类型，定义在 <code>&lt;iterator&gt;</code> 中：</p>
<ol>
<li><strong>输入迭代器（Input Iterator）</strong>：只能进行单次读取操作，不能进行写入操作。</li>
<li><strong>输出迭代器（Output Iterator）</strong>：只能进行单次写入操作，不能进行读取操作。</li>
<li><strong>正向迭代器（Forward Iterator）</strong>：可以进行读取和写入操作，并且可以向前移动。</li>
<li><strong>双向迭代器（Bidirectional Iterator）</strong>：除了可以进行正向迭代器的所有操作外，还可以向后移动。</li>
<li><strong>随机访问迭代器（Random Access Iterator）</strong>：除了可以进行双向迭代器的所有操作外，还可以进行随机访问，例如通过下标访问元素。</li>
</ol>
<p>📌 <strong>记忆技巧</strong>：每类迭代器是对上一级的扩展。</p>
<h2 id="三迭代器基本操作">三、迭代器基本操作</h2>
<p>以 <code>vector&lt;int&gt;</code> 为例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;

int main() {
    // 创建一个 vector 容器并初始化
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};

    // 使用迭代器遍历 vector
    for (std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // 使用 auto 关键字简化迭代器类型
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // 使用 C++11 范围 for 循环
    for (int elem : vec) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<hr>
<h2 id="四const_iterator-与-reverse_iterator">四、const_iterator 与 reverse_iterator</h2>
<p><code>const_iterator</code> 和 <code>reverse_iterator</code> 是C++标准库中提供的两种迭代器类型，它们用于遍历容器（如vector、list、map等）中的元素，但各自有不同的用途和行为。</p>
<h3 id="const_iterator">const_iterator</h3>
<p><code>const_iterator</code> 是一种不能用来修改其所指向元素值的迭代器。</p>
<ul>
<li>
<p><strong>声明方式</strong>：通常，容器类提供了一个名为 <code>cbegin()</code> 和 <code>cend()</code> 的成员函数来返回一个 <code>const_iterator</code>，即使在非const对象上调用这些方法也是如此。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
for (std::vector&lt;int&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
    // *it = 10; // 错误，无法通过 const_iterator 修改值
    std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>
</li>
</ul>
<h3 id="reverse_iterator">reverse_iterator</h3>
<p><code>reverse_iterator</code> 则是一种允许从容器末尾向头部进行遍历的迭代器。</p>
<ul>
<li>
<p><strong>声明方式</strong>：容器类提供了名为 <code>rbegin()</code> 和 <code>rend()</code> 的成员函数来获取 <code>reverse_iterator</code>，分别指向容器的最后一个元素和第一个元素之前的位置。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
for (std::vector&lt;int&gt;::reverse_iterator rit = vec.rbegin(); rit != vec.rend(); ++rit) {
    std::cout &lt;&lt; *rit &lt;&lt; " "; // 输出将是 4 3 2 1
}

for (std::vector&lt;int&gt;::const_reverse_iterator rit = vec.rbegin(); rit != vec.rend(); ++rit) {
    std::cout &lt;&lt; *rit &lt;&lt; " "; // 输出将是 4 3 2 1
}
</code></pre>
</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li>使用 <code>const_iterator</code> 来确保你只能读取而不能修改容器中的数据。</li>
<li>使用 <code>reverse_iterator</code> 当你需要以逆序的方式遍历容器的内容时。</li>
</ul>
<p>此外，还有 <code>const_reverse_iterator</code> 类型，它是 <code>reverse_iterator</code> 的常量版本，既不允许修改容器中的元素也不允许通过它改变容器的大小。这种类型的迭代器可以通过容器的 <code>crbegin()</code> 和 <code>crend()</code> 成员函数获得。</p>
<h2 id="五与-stl-算法结合使用">五、与 STL 算法结合使用</h2>
<p>所有 <code>&lt;algorithm&gt;</code> 算法都基于迭代器设计：</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
std::vector&lt;int&gt; v = {5, 2, 8, 1};

std::sort(v.begin(), v.end());  // 从小到大排序
auto it = std::find(v.begin(), v.end(), 2);  // 查找值为2的元素
std::reverse(v.begin(), v.end());  // 反转
</code></pre>
<hr>
<h2 id="六迭代器失效invalidation">六、迭代器失效（Invalidation）</h2>
<p>迭代器失效（<strong>Iterator Invalidation</strong>）是 C++ 编程中一个非常重要但常被忽视的概念。如果对它不了解，程序<strong>可能编译通过但运行崩溃或行为异常</strong>，是调试中非常棘手的一类错误。<strong>STL 迭代器是对地址的封装，地址变了，迭代器就失效了</strong>！！！！！！！</p>
<h3 id="什么是迭代器失效">什么是迭代器失效</h3>
<blockquote>
<p><strong>迭代器失效</strong>指的是：当你对容器做某些操作（如插入、删除、重排）之后，<strong>已有的迭代器、引用或指针变得不再有效</strong>，再使用它们就会导致未定义行为（UB）。</p>
<p>迭代器本质上就是一个“封装了访问容器中某个元素信息”的对象，可能是一个裸指针、也可能是一个封装指针和状态的类。</p>
<p>如果元素被<strong>销毁</strong>了（如 <code>erase()</code>） 那么迭代器就指向一块<strong>无效内存</strong>；<br>
如果元素被<strong>搬移了</strong>（如 <code>vector::insert()</code>）那么迭代器里的地址就<strong>过时了；</strong><br>
如果结构被<strong>重构</strong>（如 <code>unordered_map</code> 的 rehash） 那么迭代器指向的桶或节点被换掉了；</p>
<p>换句话说：</p>
<p><strong>失效的迭代器 = 仍然保存着原始访问信息，但这个信息已经不再与容器同步</strong></p>
</blockquote>
<h3 id="哪些容器容易失效">哪些容器容易失效</h3>
<table>
<thead>
<tr>
<th>容器</th>
<th>增删元素是否可能导致迭代器失效</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code>, <code>deque</code>, <code>string</code></td>
<td><strong>插入、删除、realloc 后迭代器会失效</strong></td>
</tr>
<tr>
<td><code>list</code>, <code>forward_list</code></td>
<td>插入不会失效，<strong>删除对应元素会导致该元素的迭代器失效</strong></td>
</tr>
<tr>
<td><code>set</code>, <code>map</code>, <code>unordered_set</code>, <code>unordered_map</code></td>
<td>插入不会使已有迭代器失效，但<strong>删除某个元素会使该元素迭代器失效</strong></td>
</tr>
</tbody>
</table>
<h3 id="各容器常见操作的迭代器失效表">各容器常见操作的迭代器失效表</h3>
<table>
<thead>
<tr>
<th>容器</th>
<th><code>insert</code></th>
<th><code>erase</code></th>
<th><code>push_back</code> / <code>push_front</code></th>
<th><code>clear</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code></td>
<td>可能失效 reallocation 导致地址变更</td>
<td>删除点之后失效</td>
<td>可能失效 reallocation 导致地址变更</td>
<td>所有失效</td>
</tr>
<tr>
<td><code>list</code></td>
<td>不失效</td>
<td>仅删除点失效</td>
<td>不失效</td>
<td>所有失效</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>可能失效</td>
<td>删除点之后失效</td>
<td>可能失效</td>
<td>所有失效</td>
</tr>
<tr>
<td><code>set</code> / <code>map</code></td>
<td>不失效</td>
<td>删除点失效</td>
<td>不适用</td>
<td>所有失效</td>
</tr>
<tr>
<td><code>unordered_set</code> / <code>unordered_map</code></td>
<td>插入可能失效（rehash）</td>
<td>删除点失效</td>
<td>插入可能失效</td>
<td>所有失效</td>
</tr>
</tbody>
</table>
<h3 id="常见迭代器失效场景详解">常见迭代器失效场景详解</h3>
<h4 id="1-vector-或-string-的插入删除扩容">1. <code>vector</code> 或 <code>string</code> 的插入/删除/扩容</h4>
<ul>
<li>扩容插入：<code>vector</code> 会在容量不足时发生<strong>realloc</strong>扩容（重新分配内存），地址变更，所有旧的迭代器/指针/引用会失效。</li>
<li><code>vector::erase</code> 会使<strong>被删除位置及其后的所有迭代器失效</strong>。因为 <code>vector</code> 的底层实现是<strong>连续内存数组</strong>，删除一个元素后：
<ul>
<li>所有<strong>后续元素</strong>都会<strong>向前搬移一个位置</strong></li>
<li>所以这些元素的原始地址全部变化</li>
<li>而 STL 迭代器是对地址的封装，<strong>地址变了，迭代器就失效了</strong></li>
</ul>
</li>
</ul>
<p>错误示例 ：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3};
auto it = v.begin();
v.push_back(4);  // 如果触发了扩容，it 失效
std::cout &lt;&lt; *it;  // 未定义行为！

std::vector&lt;int&gt; v = {1,2,3,4};
for (auto it = v.begin(); it != v.end(); ++it) {
    if (*it == 2) v.erase(it);  // ❌ 之后的 ++it 已失效
}
</code></pre>
<p>✅ <strong>安全做法：每次操作后重置迭代器</strong></p>
<p>正确用法：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1,2,3,4,5};
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0)
        it = v.erase(it);  // 安全写法：用返回值更新 it
    else
        ++it;
}
</code></pre>
<h4 id="2-list-的插入是安全的但删除某元素后该迭代器失效">2. <code>list</code> 的插入是安全的，但<strong>删除某元素后该迭代器失效</strong></h4>
<pre><code class="language-cpp">std::list&lt;int&gt; l = {1, 2, 3};
auto it = l.begin();
l.erase(it);   // it 失效
// std::cout &lt;&lt; *it;  // ❌ UB
</code></pre>
<p><strong>为什么 <code>std::list</code> 的插入是“安全”的？</strong></p>
<p><code>std::list</code> 是一个 <strong>双向链表</strong>，其元素在内存中<strong>不连续</strong>，每个元素是一个节点，节点通过指针链接：插入时，只是修改节点的 <code>next</code> / <code>prev</code> 指针，不需要移动已有节点或重新分配内存。</p>
<ul>
<li><strong>已有迭代器仍然指向原节点</strong></li>
<li>插入不会破坏旧节点，也不会导致地址变化</li>
</ul>
<p><strong>为什么删除某个元素后该迭代器会失效</strong>？</p>
<p>当你调用 <code>l.erase(it)</code> 删除某个节点时：</p>
<ul>
<li>该节点的内存被释放</li>
<li>该迭代器内部的指针指向的内存被销毁了</li>
</ul>
<pre><code>std::list&lt;int&gt; l = {1, 2, 3};
auto it = std::next(l.begin()); // 指向 2
l.erase(it); // 删除 2
std::cout &lt;&lt; *it &lt;&lt; "\n"; // ❌ it 已失效，UB
</code></pre>
<p>在开启调试的编译器中（如 <code>-D_GLIBCXX_DEBUG</code>），这句会抛出异常。</p>
<hr>
<h4 id="4-set--map-的删除会使该元素的迭代器失效unordered_-容器的插入或-rehash-可能使所有迭代器失效">4. <code>set</code> / <code>map</code> 的删除会使<strong>该元素的迭代器失效</strong>，<code>unordered_*</code> 容器的插入或 rehash 可能使所有迭代器失效</h4>
<table>
<thead>
<tr>
<th>操作</th>
<th><code>std::set</code> / <code>std::map</code></th>
<th><code>std::unordered_set</code> / <code>unordered_map</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>插入是否导致迭代器失效？</td>
<td>❌ 不会失效 ✅</td>
<td>✅ 可能全部失效（rehash）</td>
</tr>
<tr>
<td>删除是否导致迭代器失效？</td>
<td>✅ 被删的失效</td>
<td>✅ 被删的失效</td>
</tr>
</tbody>
</table>
<h5 id="原因容器底层结构不同">原因：容器底层结构不同：</h5>
<p><strong><code>std::set</code> / <code>std::map</code> 底层结构：红黑树（红黑平衡二叉搜索树）</strong>：</p>
<ul>
<li>插入/删除操作都只是<strong>局部旋转或链调整</strong></li>
<li><strong>节点地址不变</strong>，不搬家、不分桶</li>
<li>所以：<strong>除被删节点外，其他节点位置稳定</strong>，迭代器不失效</li>
</ul>
<pre><code class="language-cpp">std::set&lt;int&gt; s = {1,2,3};
auto it = s.begin();  // 指向1
s.insert(4);          // 树中添加新节点
std::cout &lt;&lt; *it;     // ✅ 安全，仍输出1
</code></pre>
<hr>
<p><strong><code>std::unordered_set</code> / <code>unordered_map</code> 底层结构：哈希表（带链式或桶数组）</strong>：</p>
<ul>
<li>插入会导致 <strong>rehash</strong>（哈希桶重分配）</li>
<li><strong>所有元素会搬到新桶中</strong>，地址变化</li>
<li>所以：<strong>所有迭代器都失效</strong></li>
<li>如果你提前调用 <code>.reserve(容量)</code>，就可以避免 rehash，从而保证插入不失效。</li>
</ul>
<blockquote>
<p>这个问题触及了 <strong>哈希表结构的本质</strong>，我们来深入解释：</p>
<p><strong><code>unordered_map</code> rehash 会重新分配哈希桶并搬移元素位置</strong>，所以所有迭代器（包括指向元素的）都<strong>失效</strong>。</p>
<p><strong>哈希表（hash table）</strong> 典型结构如下：</p>
<pre><code>哈希桶数组（bucket array）：
+--------+--------+--------+--------+--------+
| bucket0| bucket1| bucket2| bucket3| bucket4|
+--------+--------+--------+--------+--------+
     |        |        |        |        |
     ↓        ↓        ↓        ↓        ↓
   nodeA    nodeB    NULL     nodeC     nodeD
</code></pre>
<p>每个桶是一个<strong>链表（或链式结构）</strong>，用于存放哈希值落在该桶的元素。</p>
<p>当插入太多元素，<strong>负载因子 α = 元素数 / 桶数</strong>超过一定阈值时：</p>
<p>STL 会 <strong>自动扩容桶数组（rehash）</strong>，比如将桶数翻倍，从 8 → 16 → 32...</p>
<hr>
<p>rehash 会：</p>
<ul>
<li>分配 <strong>新的桶数组</strong>（新的内存空间）</li>
<li>遍历旧元素，<strong>重新计算哈希值 % 新桶数</strong>，将它们<strong>重新分配到新桶</strong>中</li>
<li>每个元素的位置、所属桶、链表结构都<strong>全部变了</strong></li>
</ul>
</blockquote>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1,2,3};
auto it = us.begin();
us.insert(1000);  // 插入过多元素触发 rehash
std::cout &lt;&lt; *it;  // ❌ UB，地址可能已变化
</code></pre>
<hr>
<h5 id="为什么删除操作一定会导致该元素迭代器失效">为什么删除操作一定会导致该元素迭代器失效？</h5>
<p>不管是红黑树（有序容器）还是哈希表（无序容器），<code>erase(it)</code> 都会销毁该节点 → 这个地址失效，<code>it</code> 失效：</p>
<pre><code class="language-cpp">std::set&lt;int&gt; s = {1, 2, 3};
auto it = s.find(2);
s.erase(it);
std::cout &lt;&lt; *it;  // ❌ it 失效（指向被释放的节点）
</code></pre>
<hr>
<h5 id="补充插入时为什么-setmap-可以保证其他迭代器稳定">补充：插入时，为什么 <code>set/map</code> 可以保证其他迭代器稳定？</h5>
<p>因为 <strong>新节点永远是“新分配的”，不会干扰旧节点位置</strong>，而迭代器只要指向旧节点，就不会失效。</p>
<h3 id="如何避免迭代器失效问题">如何避免迭代器失效问题？</h3>
<ol>
<li>每次插入/删除/变更结构后<strong>不要继续使用原迭代器</strong></li>
</ol>
<ul>
<li>特别是 <code>vector</code> 的 <code>push_back</code>、<code>insert</code>、<code>erase</code> 等操作</li>
</ul>
<ol start="2">
<li>若算法中要边遍历边修改结构，请用：</li>
</ol>
<pre><code class="language-cpp">it = container.erase(it);  // 使用返回值
</code></pre>
<ol start="3">
<li>若需要保持迭代器稳定，可考虑用：</li>
</ol>
<ul>
<li><code>std::list</code>（插入安全）</li>
<li><code>std::map</code> / <code>std::set</code>（插入安全）</li>
</ul>
<h2 id="七迭代器适配器iterator-adapter">七、迭代器适配器（Iterator Adapter）</h2>
<p>C++ STL 提供了三种非常实用的<strong>迭代器适配器（iterator adapters）</strong>，用于将 STL 算法的输出“适配”到容器的不同插入方式。</p>
<hr>
<h3 id="迭代器适配器总览">迭代器适配器总览</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>插入方式</th>
<th>适用容器</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::back_inserter</code></td>
<td>调用 <code>push_back</code></td>
<td><code>vector</code>, <code>deque</code>, <code>list</code></td>
<td>末尾插入</td>
</tr>
<tr>
<td><code>std::front_inserter</code></td>
<td>调用 <code>push_front</code></td>
<td><code>deque</code>, <code>list</code></td>
<td>头部插入</td>
</tr>
<tr>
<td><code>std::inserter</code></td>
<td>调用 <code>insert(pos, val)</code></td>
<td><code>set</code>, <code>map</code>, <code>list</code>, <code>vector</code></td>
<td>在指定位置插入或根据规则</td>
</tr>
</tbody>
</table>
<p>它们都定义在头文件：</p>
<pre><code class="language-cpp">#include &lt;iterator&gt;
</code></pre>
<h3 id="1-stdback_inserter">1. <code>std::back_inserter</code></h3>
<pre><code class="language-cpp">std::back_inserter(container)
</code></pre>
<p>适用于支持 <code>push_back()</code> 的容器，如 <code>vector</code>, <code>deque</code>, <code>list</code>。</p>
<h4 id="示例">示例：</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; src = {1, 2, 3};
std::vector&lt;int&gt; dst;

std::copy(src.begin(), src.end(), std::back_inserter(dst));
// dst = {1, 2, 3}
</code></pre>
<hr>
<h3 id="2-stdfront_inserter">2. <code>std::front_inserter</code></h3>
<pre><code class="language-cpp">std::front_inserter(container)
</code></pre>
<p>适用于支持 <code>push_front()</code> 的容器，如 <code>list</code>, <code>deque</code>（⚠️ <code>vector</code> 不支持）。</p>
<h4 id="示例-1">示例：</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; src = {1, 2, 3};
std::vector&lt;int&gt; dst;

std::copy(src.begin(), src.end(), std::front_inserter(dst));
// dst = {3, 2, 1}，相当于反序插入
</code></pre>
<hr>
<h3 id="3-stdinserter">3. <code>std::inserter</code></h3>
<pre><code class="language-cpp">std::inserter(container, pos)
</code></pre>
<p>适用于支持 <code>insert(pos, val)</code> 或 <code>insert(val)</code> 的容器，比如：</p>
<ul>
<li>顺序容器：<code>list</code>, <code>vector</code>, <code>deque</code></li>
<li>关联容器：<code>set</code>, <code>map</code>, <code>unordered_set</code>, <code>unordered_map</code></li>
</ul>
<p>它的工作方式是：每次调用 <code>*it = val</code>，会变成 <code>container.insert(pos, val)</code> 或 <code>container.insert(val)</code>，根据容器类型自动处理。</p>
<h4 id="示例vector">示例（vector）：</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 4, 5};
std::vector&lt;int&gt; to_insert = {2, 3};

std::copy(to_insert.begin(), to_insert.end(), std::inserter(v, v.begin() + 1));
// v = {1, 2, 3, 4, 5}
</code></pre>
<h4 id="示例set">示例（set）：</h4>
<pre><code class="language-cpp">std::set&lt;int&gt; s;
std::vector&lt;int&gt; v = {3, 1, 4};

std::copy(v.begin(), v.end(), std::inserter(s, s.begin()));
// s = {1, 3, 4}（自动去重 + 排序）
</code></pre>
<hr>
<h2 id="示例对比">示例对比</h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; src = {1, 2, 3};

    // back_inserter
    std::vector&lt;int&gt; v;
    std::copy(src.begin(), src.end(), std::back_inserter(v));  // v = 1 2 3

    // front_inserter
    std::list&lt;int&gt; l;
    std::copy(src.begin(), src.end(), std::front_inserter(l));  // l = 3 2 1

    // inserter (middle insert into vector)
    std::vector&lt;int&gt; a = {0, 4};
    std::copy(src.begin(), src.end(), std::inserter(a, a.begin() + 1));  // a = 0 1 2 3 4

    // inserter (into set)
    std::set&lt;int&gt; s;
    std::copy(src.begin(), src.end(), std::inserter(s, s.begin()));  // s = 1 2 3
}
</code></pre>
<h2 id="八迭代器的现代替代品">八、迭代器的现代替代品</h2>
<h3 id="c11--范围-for-循环range-based-for-loop">C++11  范围 for 循环（range-based for loop）</h3>
<p>在 C++11 中，引入了“<strong>范围 for 循环（range-based for loop）</strong>”语法，它是对传统迭代器遍历的一种简化封装。它本质上仍然依赖于<strong>迭代器接口</strong>，只是把编写迭代器的模板代码藏在了语法糖后面。</p>
<hr>
<h4 id="1语法示例">1、语法示例</h4>
<table>
<thead>
<tr>
<th>写法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for (int x : v)</code></td>
<td>拷贝元素（无法修改原始容器）</td>
</tr>
<tr>
<td><code>for (int&amp; x : v)</code></td>
<td>引用访问元素（可修改）</td>
</tr>
<tr>
<td><code>for (const int&amp; x : v)</code></td>
<td>常量引用（节省拷贝成本，无法修改）</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4};
    // 使用范围 for 循环
    for (int x : vec) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }
    std::cout&lt;&lt; std::endl;
    // 等价于
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        int x = *it;
        std::cout &lt;&lt; x &lt;&lt; " ";
    }
}

</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec1 = {1, 2, 3, 4};
    std::vector&lt;int&gt; vec2 = {1, 2, 3, 4};

    // 如果使用引用或引用修改
    for (int&amp; x : vec1) {
        x *= 2;  // 修改元素值
    }
    for (int x : vec1) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }
    
    std::cout&lt;&lt; std::endl;
    // 等价于
    for (auto it = vec2.begin(); it != vec2.end(); ++it) {
        *it *= 2;
    }
    for (int x : vec2) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }
}

</code></pre>
<h4 id="2工作原理使用-begin-和-end">2、工作原理：使用 <code>begin()</code> 和 <code>end()</code></h4>
<p>编译器在处理 <code>for (auto x : container)</code> 时会：</p>
<pre><code class="language-cpp">{
    auto __begin = std::begin(container);
    auto __end = std::end(container);
    for (; __begin != __end; ++__begin) {
        auto x = *__begin;
        // 循环体
    }
}
</code></pre>
<p>即：</p>
<ul>
<li>使用容器的 <code>begin()</code> 和 <code>end()</code> 函数获取迭代器范围</li>
<li>使用迭代器 <code>*</code> 访问元素，<code>++</code> 进行遍历</li>
</ul>
<p>支持 <code>range-based for</code> 的关键：容器必须有 <code>begin()</code> 和 <code>end()</code> 方法（成员或非成员）返回迭代器。</p>
<h3 id="c20-ranges">C++20 Ranges</h3>
<p>C++20 引入 <code>ranges</code>，简化迭代器和算法结合的写法：</p>
<p>C++20 引入的 <strong>Ranges</strong> 是对传统 STL 算法与迭代器体系的重大升级，它让容器操作更加<strong>直观、可组合、函数式、懒惰（lazy）</strong>，是 C++ 泛型编程的一大进步。</p>
<hr>
<h4 id="1什么是-ranges">1、什么是 Ranges？</h4>
<p>更 <strong>简洁</strong>，更 <strong>可读</strong> ，<strong>懒惰求值</strong>（只有遍历时才计算），更 <strong>易组合</strong></p>
<p>对一个vector<strong>取奇数，乘2，前3个</strong>的操作：</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};

    // 取奇数，排序，只保留前两个元素
    // 第一步：filter - 筛选奇数
    std::vector&lt;int&gt; filtered;
    std::copy_if(v.begin(), v.end(), std::back_inserter(filtered),
                 [](int x) { return x % 2 == 1; });

    // 第二步：transform - 乘2
    std::vector&lt;int&gt; transformed;
    std::transform(filtered.begin(), filtered.end(), std::back_inserter(transformed),
                   [](int x) { return x * 10; });

    // 第三步：take 3 - 取前3个
    std::vector&lt;int&gt; result;
    std::copy_n(transformed.begin(),
                std::min&lt;size_t&gt;(3, transformed.size()),
                std::back_inserter(result));

    // 输出结果
    for (int x : result) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }

    // c++20 管道式组合：取奇数，乘2，前3个
    auto view = v
                | std::views::filter([](int x){ return x % 2 == 1; })
                | std::views::transform([](int x){ return x * 10; })
                | std::views::take(3);

    for (int x : view) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    }

}

</code></pre>
<h4 id="2核心组成">2、核心组成</h4>
<p>Ranges 头文件</p>
<pre><code class="language-cpp">#include &lt;ranges&gt;  // 所有 ranges 组件
</code></pre>
<hr>
<p>Views（视图） - 核心特性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>views::filter</code></td>
<td>过滤元素</td>
<td><code>x % 2 == 0</code></td>
</tr>
<tr>
<td><code>views::transform</code></td>
<td>元素变换</td>
<td><code>x * 2</code></td>
</tr>
<tr>
<td><code>views::take(n)</code></td>
<td>取前 n 个元素</td>
<td><code>take(5)</code></td>
</tr>
<tr>
<td><code>views::drop(n)</code></td>
<td>跳过前 n 个元素</td>
<td><code>drop(3)</code></td>
</tr>
<tr>
<td><code>views::reverse</code></td>
<td>反转视图</td>
<td></td>
</tr>
<tr>
<td><code>views::iota(start, end)</code></td>
<td>生成数列</td>
<td><code>iota(1, 10)</code></td>
</tr>
<tr>
<td><code>views::enumerate</code></td>
<td>带索引</td>
<td>C++23 引入</td>
</tr>
</tbody>
</table>
<h4 id="3range-与容器的区别">3、Range 与容器的区别</h4>
<table>
<thead>
<tr>
<th>项目</th>
<th>容器（如 vector）</th>
<th>Ranges View</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否持有数据</td>
<td>是（拥有所有权）</td>
<td>否（引用或包装）</td>
</tr>
<tr>
<td>是否懒惰求值</td>
<td>否（立即计算）</td>
<td>是（按需计算）</td>
</tr>
<tr>
<td>是否可组合</td>
<td>需要临时变量</td>
<td>可以链式组合</td>
</tr>
<tr>
<td>开销</td>
<td>复制内存</td>
<td>几乎为零开销（按需生成）</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="4与算法结合ranges">4、与算法结合（<code>ranges::</code>）</h4>
<p>C++20 引入 <code>std::ranges::</code> 下的算法，替代传统 <code>&lt;algorithm&gt;</code> 版本，支持<strong>range</strong> 作为输入。</p>
<pre><code class="language-cpp">#include &lt;ranges&gt;
#include &lt;algorithm&gt;

std::vector&lt;int&gt; v = {3, 1, 4, 1, 5};

// 更简洁的写法：
std::ranges::sort(v);  // 不需要手动传 begin/end
</code></pre>
<ul>
<li>许多算法接受 range 或 iterator：
<ul>
<li><code>ranges::find(range, value)</code></li>
<li><code>ranges::count(range, pred)</code></li>
<li><code>ranges::for_each(range, fn)</code></li>
<li><code>ranges::all_of(range, pred)</code></li>
</ul>
</li>
</ul>
<h1 id="stl-常用算法">STL 常用算法<algorithm></algorithm></h1>
<p>C++ STL（标准模板库）提供了大量<strong>泛型算法</strong>，位于头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;numeric&gt;</code> 中。它们基于迭代器设计，支持几乎所有 STL 容器（如 <code>vector</code>, <code>list</code>, <code>set</code>, <code>map</code> 等）。</p>
<p>以下是对 STL <strong>常用算法分类及用法</strong>的系统总结，并附上示例。</p>
<hr>
<h2 id="一头文件说明">一、头文件说明</h2>
<pre><code class="language-cpp">#include &lt;algorithm&gt;  // 绝大多数 STL 算法
#include &lt;numeric&gt;    // accumulate, inner_product 等
</code></pre>
<hr>
<h2 id="二stl-算法分类总览">二、STL 算法分类总览</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>常用算法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>遍历类</td>
<td><code>for_each</code>, <code>transform</code></td>
<td>对每个元素执行操作</td>
</tr>
<tr>
<td>查找类</td>
<td><code>find</code>, <code>find_if</code>, <code>count</code>, <code>binary_search</code></td>
<td>查找元素</td>
</tr>
<tr>
<td>修改类</td>
<td><code>copy</code>, <code>replace</code>, <code>fill</code>, <code>remove</code></td>
<td>修改或生成新数据</td>
</tr>
<tr>
<td>排序类</td>
<td><code>sort</code>, <code>stable_sort</code>, <code>reverse</code>, <code>partial_sort</code></td>
<td>排序与重排</td>
</tr>
<tr>
<td>比较类</td>
<td><code>equal</code>, <code>mismatch</code>, <code>lexicographical_compare</code></td>
<td>比较区间内容</td>
</tr>
<tr>
<td>数值类</td>
<td><code>accumulate</code>, <code>inner_product</code>, <code>iota</code></td>
<td>数值计算</td>
</tr>
<tr>
<td>集合类</td>
<td><code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code></td>
<td>需要排序</td>
</tr>
<tr>
<td>分区类</td>
<td><code>partition</code>, <code>stable_partition</code>, <code>is_partitioned</code></td>
<td>分组元素</td>
</tr>
<tr>
<td>辅助类</td>
<td><code>min</code>, <code>max</code>, <code>swap</code>, <code>iter_swap</code></td>
<td>辅助操作</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三常用算法详解与示例">三、常用算法详解与示例</h2>
<h3 id="1-遍历类">1. 遍历类</h3>
<p><code>std::for_each</code> 和 <code>std::transform</code> 是 C++ STL 中两个非常常用的算法函数，它们都用于<strong>遍历容器元素并对其应用某种操作</strong>，但用途略有不同。</p>
<h4 id="stdfor_each"><code>std::for_each</code></h4>
<p>对指定范围内的<strong>每个元素执行某个操作</strong>，<strong>不返回新容器</strong>。原型：</p>
<pre><code class="language-cpp">template&lt;class InputIterator, class Function&gt;
Function for_each(InputIterator first, InputIterator last, Function f);
</code></pre>
<ul>
<li>对容器中元素应用 <code>f(x)</code></li>
<li>常用于打印、累加等副作用操作</li>
<li>不会改变容器内容（除非 <code>f</code> 修改引用）</li>
</ul>
<p>📦 示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; v = {1, 2, 3, 4};
    std::for_each(v.begin(), v.end(), [](int x) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    });
    std::cout &lt;&lt; std::endl; 
    // 💡 如果你用引用参数，可以修改容器元素：
    std::for_each(v.begin(), v.end(), [](int &amp;x) { x *= 2; });
    std::for_each(v.begin(), v.end(), [](int x) {
        std::cout &lt;&lt; x &lt;&lt; " ";
    });
}
//输出
1 2 3 4 
2 4 6 8 
Process finished with exit code 0
</code></pre>
<hr>
<h4 id="stdtransform"><code>std::transform</code></h4>
<p>对一个（或两个）区间中的元素应用函数，并将结果<strong>写入另一个区间</strong>，<strong>返回的是结果迭代器</strong>。</p>
<p>原型（单输入）：</p>
<pre><code class="language-cpp">template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
OutputIterator transform(InputIterator first1, InputIterator last1,
                         OutputIterator result, UnaryOperation op);
</code></pre>
<p>特点：</p>
<ul>
<li>输入一个或两个区间，输出一个新结果区间</li>
<li>不修改原始容器</li>
<li>常用于“映射”（map）操作</li>
</ul>
<p>示例（单输入）：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3};
std::vector&lt;int&gt; result;

std::transform(v.begin(), v.end(), std::back_inserter(result),
               [](int x){ return x * 2; });  // result = {2, 4, 6}
</code></pre>
<p>示例（双输入）：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; a = {1, 2, 3};
std::vector&lt;int&gt; b = {4, 5, 6};
std::vector&lt;int&gt; result;

std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result),
               [](int x, int y){ return x + y; });  // result = {5, 7, 9}
</code></pre>
<hr>
<h4 id="总结对比">总结对比</h4>
<table>
<thead>
<tr>
<th>项目</th>
<th><code>std::for_each</code></th>
<th><code>std::transform</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>是否有输出容器</td>
<td>否</td>
<td>是，结果写入新容器</td>
</tr>
<tr>
<td>用途</td>
<td>遍历打印/修改/统计</td>
<td>映射生成新数据</td>
</tr>
<tr>
<td>是否能修改原容器</td>
<td>是（通过引用）</td>
<td>否（默认写入新容器）</td>
</tr>
<tr>
<td>是否懒惰求值</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>等价于</td>
<td>Python 的 <code>for x in</code></td>
<td>Python 的 <code>map()</code></td>
</tr>
</tbody>
</table>
<hr>
<h4 id="选择建议">选择建议：</h4>
<ul>
<li>需要<strong>对元素进行处理或收集</strong> → 使用 <code>std::transform</code></li>
<li>只想<strong>对每个元素做操作（如打印、修改）</strong> → 使用 <code>std::for_each</code></li>
</ul>
<h3 id="2-查找类">2. 查找类</h3>
<p>当然，下面是对 C++ STL 中 <strong>查找类算法</strong> 的系统整理和详细讲解，包括功能、使用方式、适用场景和示例代码。你将了解如何用标准库高效地在各种容器中查找、定位和判断元素。</p>
<hr>
<h4 id="查找类算法总览">查找类算法总览</h4>
<table>
<thead>
<tr>
<th>算法名</th>
<th>功能</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::find</code></td>
<td>查找等于某值的元素</td>
<td>线性查找</td>
</tr>
<tr>
<td><code>std::find_if</code> / <code>find_if_not</code></td>
<td>查找满足（或不满足）某条件的元素</td>
<td>可自定义谓词</td>
</tr>
<tr>
<td><code>std::count</code> / <code>count_if</code></td>
<td>统计等于某值（或满足条件）的元素个数</td>
<td>线性统计</td>
</tr>
<tr>
<td><code>std::any_of</code> / <code>all_of</code> / <code>none_of</code></td>
<td>判断是否存在、全部、全部不满足某条件</td>
<td>快速判断</td>
</tr>
<tr>
<td><code>std::search</code> / <code>search_n</code></td>
<td>查找子序列或重复值</td>
<td>区间查找</td>
</tr>
<tr>
<td><code>std::adjacent_find</code></td>
<td>查找相邻重复元素</td>
<td>连续判断</td>
</tr>
<tr>
<td><code>std::binary_search</code></td>
<td>二分查找</td>
<td>有序区间</td>
</tr>
<tr>
<td><code>std::lower_bound</code> / <code>upper_bound</code></td>
<td>查找第一个不小于 / 大于指定值的位置</td>
<td>有序区间</td>
</tr>
<tr>
<td><code>std::equal_range</code></td>
<td>同时返回 <code>lower_bound</code> 和 <code>upper_bound</code></td>
<td>范围查找</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="1-stdfind">1. <code>std::find</code></h4>
<p>在线性序列中查找“等于某值”的第一个元素。</p>
<pre><code class="language-cpp">template&lt;class InputIt, class T&gt;
InputIt find(InputIt first, InputIt last, const T&amp; value);
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4};
auto it = std::find(v.begin(), v.end(), 3);
if (it != v.end()) std::cout &lt;&lt; "Found: " &lt;&lt; *it;
</code></pre>
<hr>
<h4 id="2-stdfind_if--find_if_not">2. <code>std::find_if</code> / <code>find_if_not</code></h4>
<p>查找<strong>满足（或不满足）谓词条件</strong>的第一个元素。</p>
<pre><code class="language-cpp">template&lt;class InputIt, class UnaryPredicate&gt;
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">auto it = std::find_if(v.begin(), v.end(), [](int x){ return x % 2 == 0; });  // 第一个偶数
</code></pre>
<hr>
<h4 id="3-stdcount--count_if">3. <code>std::count</code> / <code>count_if</code></h4>
<p>统计等于某值，或满足某条件的元素个数。</p>
<p>示例：</p>
<pre><code class="language-cpp">int n1 = std::count(v.begin(), v.end(), 5);  // 有几个 5
int n2 = std::count_if(v.begin(), v.end(), [](int x){ return x &gt; 3; });  // 有几个大于3
</code></pre>
<hr>
<h4 id="4-stdany_of--all_of--none_of">4. <code>std::any_of</code> / <code>all_of</code> / <code>none_of</code></h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>any_of</code></td>
<td>有任意一个满足</td>
</tr>
<tr>
<td><code>all_of</code></td>
<td>所有都满足</td>
</tr>
<tr>
<td><code>none_of</code></td>
<td>全部都不满足</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="language-cpp">bool any_even = std::any_of(v.begin(), v.end(), [](int x){ return x % 2 == 0; });
bool all_positive = std::all_of(v.begin(), v.end(), [](int x){ return x &gt; 0; });
bool none_negative = std::none_of(v.begin(), v.end(), [](int x){ return x &lt; 0; });
</code></pre>
<hr>
<h4 id="5-stdadjacent_find">5. <code>std::adjacent_find</code></h4>
<p>查找<strong>相邻的两个相等元素</strong>或满足某自定义条件的一对相邻元素。</p>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 2, 3, 4};
auto it = std::adjacent_find(v.begin(), v.end());  // 找到第一个 2,2
</code></pre>
<hr>
<h4 id="6-stdsearch--search_n">6. <code>std::search</code> / <code>search_n</code></h4>
<p>在序列中查找某个<strong>子序列</strong> 或 <strong>连续 n 个值</strong> 出现的位置。</p>
<p>示例：</p>
<p><strong><code>std::search</code> – 查找子序列</strong></p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1,2,3,4,5};
std::vector&lt;int&gt; pattern = {3,4};
auto it = std::search(v.begin(), v.end(), pattern.begin(), pattern.end());
</code></pre>
<p><strong><code>std::search_n</code> – 查找 n 连续值</strong></p>
<pre><code class="language-cpp">auto it = std::search_n(v.begin(), v.end(), 3, 7);  // 连续3个7
</code></pre>
<hr>
<h4 id="7-二分查找类-需要已排序">7. 二分查找类（⚠ 需要已排序）</h4>
<p>常用于：<code>vector</code>, <code>array</code>, 或 <code>set</code> 中，元素按升序排列</p>
<p><strong><code>std::binary_search</code>（只返回是否存在）</strong></p>
<pre><code class="language-cpp">std::sort(v.begin(), v.end());  // 必须排序
bool found = std::binary_search(v.begin(), v.end(), 5);
</code></pre>
<p><strong><code>std::lower_bound</code> / <code>upper_bound</code></strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lower_bound</code></td>
<td>第一个 ≥ val 的位置</td>
</tr>
<tr>
<td><code>upper_bound</code></td>
<td>第一个 &gt; val 的位置</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">auto lb = std::lower_bound(v.begin(), v.end(), 5);
auto ub = std::upper_bound(v.begin(), v.end(), 5);
</code></pre>
<p><strong><code>std::equal_range</code></strong></p>
<pre><code class="language-cpp">auto [low, up] = std::equal_range(v.begin(), v.end(), 5);  // 一次查两个
</code></pre>
<hr>
<p>示例：计数有几个等于 5 的元素（已排序容器）</p>
<pre><code class="language-cpp">int count = std::upper_bound(v.begin(), v.end(), 5) -
            std::lower_bound(v.begin(), v.end(), 5);
</code></pre>
<hr>
<h4 id="查找类算法使用建议">查找类算法使用建议</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>精确查找</td>
<td><code>std::find</code></td>
</tr>
<tr>
<td>条件查找</td>
<td><code>std::find_if</code></td>
</tr>
<tr>
<td>计数值出现次数</td>
<td><code>std::count</code></td>
</tr>
<tr>
<td>判断是否有某种元素</td>
<td><code>std::any_of</code></td>
</tr>
<tr>
<td>相邻重复查找</td>
<td><code>std::adjacent_find</code></td>
</tr>
<tr>
<td>查找子序列</td>
<td><code>std::search</code></td>
</tr>
<tr>
<td>二分查找（有序）</td>
<td><code>std::binary_search</code>, <code>lower_bound</code></td>
</tr>
</tbody>
</table>
<hr>
<h4 id="性能">性能</h4>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find</code>, <code>count</code> 等线性查找</td>
<td>O(n)</td>
<td>无需排序</td>
</tr>
<tr>
<td><code>binary_search</code>, <code>lower_bound</code></td>
<td>O(log n)</td>
<td><strong>必须排序</strong>，支持随机访问迭代器</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="3-修改类">3. 修改类</h3>
<hr>
<h4 id="修改类算法总览">修改类算法总览</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>算法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>拷贝类</td>
<td><code>std::copy</code>, <code>copy_n</code>, <code>copy_if</code>, <code>move</code></td>
<td>拷贝元素或移动元素</td>
</tr>
<tr>
<td>替换类</td>
<td><code>std::replace</code>, <code>replace_if</code>, <code>replace_copy</code></td>
<td>替换满足条件的元素</td>
</tr>
<tr>
<td>填充类</td>
<td><code>std::fill</code>, <code>fill_n</code>, <code>generate</code>, <code>generate_n</code>, <code>iota</code></td>
<td>填充或生成元素</td>
</tr>
<tr>
<td>删除类</td>
<td><code>std::remove</code>, <code>remove_if</code>, <code>unique</code></td>
<td>移除或压缩元素（惰性）</td>
</tr>
<tr>
<td>交换类</td>
<td><code>std::swap</code>, <code>iter_swap</code>, <code>swap_ranges</code></td>
<td>交换元素或范围</td>
</tr>
<tr>
<td>反转类</td>
<td><code>std::reverse</code>, <code>reverse_copy</code>, <code>rotate</code>, <code>shuffle</code></td>
<td>调整元素顺序</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="1-拷贝类">1. 拷贝类</h4>
<h5 id="stdcopy--复制整个区间"><code>std::copy</code> – 复制整个区间</h5>
<pre><code class="language-cpp">std::copy(src.begin(), src.end(), dest.begin());
</code></pre>
<ul>
<li>注意 <code>dest</code> 必须有足够空间，或用 <code>back_inserter</code> 增长容器。</li>
</ul>
<h5 id="stdcopy_if--条件复制"><code>std::copy_if</code> – 条件复制</h5>
<pre><code class="language-cpp">std::copy_if(v.begin(), v.end(), std::back_inserter(result),
             [](int x){ return x % 2 == 0; });
</code></pre>
<h5 id="stdcopy_n--复制固定数量元素"><code>std::copy_n</code> – 复制固定数量元素</h5>
<pre><code class="language-cpp">std::copy_n(src.begin(), 5, std::back_inserter(result));
</code></pre>
<hr>
<h4 id="2-替换类">2. 替换类</h4>
<h5 id="stdreplace--替换值"><code>std::replace</code> – 替换值</h5>
<pre><code class="language-cpp">std::replace(v.begin(), v.end(), 3, 99);  // 把 3 替换成 99
</code></pre>
<h5 id="stdreplace_if--满足条件的元素被替换"><code>std::replace_if</code> – 满足条件的元素被替换</h5>
<pre><code class="language-cpp">std::replace_if(v.begin(), v.end(), [](int x){ return x &lt; 0; }, 0);
</code></pre>
<h5 id="stdreplace_copy--替换并写入另一个容器"><code>std::replace_copy</code> – 替换并写入另一个容器</h5>
<pre><code class="language-cpp">std::replace_copy(v.begin(), v.end(), std::back_inserter(result), 3, 100);
</code></pre>
<hr>
<h4 id="3-填充类">3. 填充类</h4>
<h5 id="stdfill--将区间填充为某个值"><code>std::fill</code> – 将区间填充为某个值</h5>
<pre><code class="language-cpp">std::fill(v.begin(), v.end(), 0);
</code></pre>
<h5 id="stdfill_n--从起点填充-n-个值"><code>std::fill_n</code> – 从起点填充 n 个值</h5>
<pre><code class="language-cpp">std::fill_n(v.begin(), 5, 1);
</code></pre>
<h5 id="stdgenerate--用函数填充区间"><code>std::generate</code> – 用函数填充区间</h5>
<pre><code class="language-cpp">int n = 0;
std::generate(v.begin(), v.end(), [&amp;](){ return ++n; });  // v = {1,2,3,...}
</code></pre>
<h5 id="stdgenerate_n"><code>std::generate_n</code></h5>
<pre><code class="language-cpp">std::generate_n(std::back_inserter(v), 5, [](){ return rand(); });
</code></pre>
<h5 id="stdiota在-numeric-中-递增填充"><code>std::iota</code>（在 <code>&lt;numeric&gt;</code> 中）– 递增填充</h5>
<pre><code class="language-cpp">std::iota(v.begin(), v.end(), 1);  // v = {1, 2, 3, ...}
</code></pre>
<hr>
<h4 id="4-删除类惰性删除需要配合-erase">4. 删除类（惰性删除，需要配合 <code>erase</code>）</h4>
<h5 id="stdremove--移除某个值不改变容器大小"><code>std::remove</code> – 移除某个值（不改变容器大小）</h5>
<pre><code class="language-cpp">auto it = std::remove(v.begin(), v.end(), 3);
v.erase(it, v.end());  // 物理删除
</code></pre>
<h5 id="stdremove_if--按条件移除元素"><code>std::remove_if</code> – 按条件移除元素</h5>
<pre><code class="language-cpp">auto it = std::remove_if(v.begin(), v.end(), [](int x){ return x &lt; 0; });
v.erase(it, v.end());
</code></pre>
<h5 id="stdunique--移除相邻重复元素"><code>std::unique</code> – 移除相邻重复元素</h5>
<pre><code class="language-cpp">std::sort(v.begin(), v.end());
auto it = std::unique(v.begin(), v.end());
v.erase(it, v.end());  // 只保留唯一值
</code></pre>
<hr>
<h4 id="5-交换类">5. 交换类</h4>
<h5 id="stdswap--交换两个变量"><code>std::swap</code> – 交换两个变量</h5>
<pre><code class="language-cpp">std::swap(a, b);
</code></pre>
<h5 id="stditer_swap--交换两个迭代器指向的元素"><code>std::iter_swap</code> – 交换两个迭代器指向的元素</h5>
<pre><code class="language-cpp">std::iter_swap(it1, it2);
</code></pre>
<h5 id="stdswap_ranges--交换两个区间元素"><code>std::swap_ranges</code> – 交换两个区间元素</h5>
<pre><code class="language-cpp">std::swap_ranges(a.begin(), a.end(), b.begin());
</code></pre>
<hr>
<h4 id="6-反转类--重排类">6. 反转类 / 重排类</h4>
<h5 id="stdreverse--原地反转区间"><code>std::reverse</code> – 原地反转区间</h5>
<pre><code class="language-cpp">std::reverse(v.begin(), v.end());
</code></pre>
<h5 id="stdreverse_copy"><code>std::reverse_copy</code></h5>
<pre><code class="language-cpp">std::reverse_copy(v.begin(), v.end(), std::back_inserter(result));
</code></pre>
<h5 id="stdrotate--左旋或右旋"><code>std::rotate</code> – 左旋或右旋</h5>
<pre><code class="language-cpp">std::rotate(v.begin(), v.begin() + 2, v.end());  // 左旋 2 位
</code></pre>
<h5 id="stdshufflec11-起"><code>std::shuffle</code>（C++11 起）</h5>
<pre><code class="language-cpp">std::random_device rd;
std::mt19937 g(rd());
std::shuffle(v.begin(), v.end(), g);
</code></pre>
<hr>
<h4 id="示例从容器中删去所有负数并将剩下的数全部翻倍">示例：从容器中删去所有负数，并将剩下的数全部翻倍</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {-1, 2, -3, 4, 5};

// 1. 删除负数
v.erase(std::remove_if(v.begin(), v.end(), [](int x){ return x &lt; 0; }), v.end());

// 2. 翻倍（用 transform 修改原容器）
std::transform(v.begin(), v.end(), v.begin(), [](int x){ return x * 2; });
</code></pre>
<hr>
<h4 id="总结对比表">总结对比表</h4>
<table>
<thead>
<tr>
<th>算法</th>
<th>功能</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>copy</code>, <code>copy_if</code>, <code>copy_n</code></td>
<td>拷贝区间元素</td>
<td>输出容器要预留空间</td>
</tr>
<tr>
<td><code>replace</code>, <code>replace_if</code></td>
<td>替换元素</td>
<td>改变原容器内容</td>
</tr>
<tr>
<td><code>fill</code>, <code>generate</code>, <code>iota</code></td>
<td>批量填充</td>
<td>常用于初始化容器</td>
</tr>
<tr>
<td><code>remove</code>, <code>remove_if</code></td>
<td>移除元素（惰性）</td>
<td>需 <code>erase</code> 才真正删除</td>
</tr>
<tr>
<td><code>reverse</code>, <code>rotate</code>, <code>shuffle</code></td>
<td>调整顺序</td>
<td>可用于打乱、移动、翻转</td>
</tr>
<tr>
<td><code>swap</code>, <code>iter_swap</code></td>
<td>元素互换</td>
<td>常用于排序内部实现</td>
</tr>
</tbody>
</table>
<h3 id="4-排序类">4. 排序类</h3>
<p>当然，下面是对 C++ STL 中 <strong>排序类算法（Sorting Algorithms）</strong> 的<strong>详细介绍</strong>，包括常用函数、功能差异、适用场景、性能，以及使用示例。</p>
<hr>
<h4 id="排序类算法总览">排序类算法总览</h4>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>功能</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::sort</code></td>
<td>快速排序，默认升序</td>
<td><strong>最快</strong>，不稳定排序</td>
</tr>
<tr>
<td><code>std::stable_sort</code></td>
<td>稳定排序（归并）</td>
<td>保留相等元素相对顺序</td>
</tr>
<tr>
<td><code>std::partial_sort</code></td>
<td>只排序前 <code>k</code> 个元素</td>
<td>部分排序</td>
</tr>
<tr>
<td><code>std::nth_element</code></td>
<td>将第 n 小元素放到第 n 位</td>
<td>非完全排序，适合找中位数</td>
</tr>
<tr>
<td><code>std::is_sorted</code></td>
<td>判断是否有序</td>
<td>布尔返回值</td>
</tr>
<tr>
<td><code>std::is_sorted_until</code></td>
<td>找到未排序的位置</td>
<td>返回迭代器</td>
</tr>
<tr>
<td><code>std::reverse</code></td>
<td>反转序列</td>
<td>非排序，但常结合使用</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="1-stdsort--快速排序默认">1. <code>std::sort</code> – 快速排序（默认）</h4>
<p>将容器内的元素<strong>按升序</strong>或自定义规则<strong>排序</strong>，原型：</p>
<pre><code class="language-cpp">template &lt;class RandomIt&gt;
void sort(RandomIt first, RandomIt last);

template &lt;class RandomIt, class Compare&gt;
void sort(RandomIt first, RandomIt last, Compare comp);
</code></pre>
<p>注意：</p>
<ul>
<li>仅适用于<strong>随机访问迭代器</strong>：如 <code>vector</code>, <code>array</code>, <code>deque</code></li>
<li>平均时间复杂度 <strong>O(n log n)</strong>，最坏 <strong>O(n²)</strong>（但实现做了优化）</li>
<li><strong>不稳定排序</strong>（相等元素相对位置可能变化）</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {5, 3, 1, 4};
std::sort(v.begin(), v.end());  // 升序
std::sort(v.begin(), v.end(), std::greater&lt;&gt;());  // 降序
</code></pre>
<hr>
<h4 id="2-stdstable_sort--稳定排序">2. <code>std::stable_sort</code> – 稳定排序</h4>
<p>排序后<strong>保留相等元素的原始顺序</strong>，原型</p>
<pre><code class="language-cpp">template &lt;class RandomIt&gt;
void stable_sort(RandomIt first, RandomIt last);

template &lt;class RandomIt, class Compare&gt;
void stable_sort(RandomIt first, RandomIt last, Compare comp);
</code></pre>
<p>特点：</p>
<ul>
<li><strong>归并排序</strong>实现，时间复杂度 <strong>O(n log² n)</strong> 或 <strong>O(n log n)</strong>（部分实现优化）</li>
<li>对于排序后仍需依赖原始顺序的情况非常有用</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">struct Person { std::string name; int age; };

std::vector&lt;Person&gt; people = {{"Alice", 30}, {"Bob", 25}, {"Amy", 30}};
std::stable_sort(people.begin(), people.end(), 
    [](const Person&amp; a, const Person&amp; b){ return a.age &lt; b.age; });
</code></pre>
<hr>
<h4 id="3-stdpartial_sort--部分排序">3. <code>std::partial_sort</code> – 部分排序</h4>
<p>只对<strong>前 k 个元素排序</strong></p>
<pre><code class="language-cpp">template &lt;class RandomIt&gt;
void partial_sort(RandomIt first, RandomIt middle, RandomIt last);

template &lt;class RandomIt, class Compare&gt;
void partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp);
</code></pre>
<p>原理：</p>
<ul>
<li>对 <code>first</code> 到 <code>last</code> 区间排序</li>
<li>排好序的前 <code>middle - first</code> 个元素放在 <code>[first, middle)</code></li>
</ul>
<p>示例：找前 3 小：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {9, 2, 7, 4, 1, 5};
std::partial_sort(v.begin(), v.begin() + 3, v.end());  // v[0..2] 是最小的 3 个元素
</code></pre>
<hr>
<h4 id="4-stdnth_element--找第-n-小的元素">4. <code>std::nth_element</code> – 找第 n 小的元素</h4>
<p>将第 <code>n</code> 小的元素放到正确位置，左边比它小，右边比它大，但左右<strong>不保证排序</strong></p>
<pre><code class="language-cpp">template &lt;class RandomIt&gt;
void nth_element(RandomIt first, RandomIt nth, RandomIt last);

template &lt;class RandomIt, class Compare&gt;
void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);
</code></pre>
<ul>
<li>平均时间复杂度为 <strong>O(n)</strong>（适合大数据场景）</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {7, 2, 4, 8, 1, 5};
std::nth_element(v.begin(), v.begin() + 2, v.end());  // 第 3 小的数放在 v[2]
</code></pre>
<hr>
<h4 id="5-stdis_sorted--is_sorted_until">5. <code>std::is_sorted</code> / <code>is_sorted_until</code></h4>
<p><code>std::is_sorted</code>：</p>
<p>判断区间是否已经排序</p>
<pre><code class="language-cpp">bool ok = std::is_sorted(v.begin(), v.end());
</code></pre>
<p><code>std::is_sorted_until</code>：</p>
<p>返回第一个<strong>不满足排序规则</strong>的迭代器</p>
<pre><code class="language-cpp">auto it = std::is_sorted_until(v.begin(), v.end());
</code></pre>
<hr>
<h4 id="6-stdreverse--反转">6. <code>std::reverse</code> – 反转</h4>
<p>将容器内数据反转</p>
<pre><code class="language-cpp">std::reverse(v.begin(), v.end());
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; v = {9, 2, 7, 4, 1, 5};
    std::reverse(v.begin(), v.end());
    for (int v1: v) {
        std::cout &lt;&lt; v1 &lt;&lt; " ";
    }
    //输出 5 1 4 7 2 9
}
</code></pre>
<h4 id="应用实例对比">应用实例对比</h4>
<p>✔ 找出前 5 个最大值（降序）</p>
<pre><code class="language-cpp">std::partial_sort(v.begin(), v.begin() + 5, v.end(), std::greater&lt;&gt;());
</code></pre>
<p>✔ 排序自定义对象（按多个字段）</p>
<pre><code class="language-cpp">struct Student { std::string name; int score; int age; };

std::sort(v.begin(), v.end(), [](const Student&amp; a, const Student&amp; b){
    return std::tie(a.score, a.age) &gt; std::tie(b.score, b.age);  // score优先降序，age降序
});
</code></pre>
<hr>
<h4 id="选择建议-1">选择建议</h4>
<table>
<thead>
<tr>
<th>需求</th>
<th>推荐算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>完整排序，速度优先</td>
<td><code>std::sort</code></td>
</tr>
<tr>
<td>完整排序，顺序稳定</td>
<td><code>std::stable_sort</code></td>
</tr>
<tr>
<td>找第 n 小（或前 k 小）</td>
<td><code>std::nth_element</code></td>
</tr>
<tr>
<td>排前几项即可</td>
<td><code>std::partial_sort</code></td>
</tr>
<tr>
<td>判断是否已排序</td>
<td><code>std::is_sorted</code></td>
</tr>
</tbody>
</table>
<h3 id="5-比较类">5. 比较类</h3>
<h4 id="stdequal"><code>std::equal</code></h4>
<p>判断两个序列的所有对应元素是否相等。</p>
<pre><code class="language-cpp">// 第一种：两个范围 [first1, last1) 和 从 first2 开始的序列
template&lt;class InputIt1, class InputIt2&gt;
bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);

// 第二种：自定义比较函数
template&lt;class InputIt1, class InputIt2, class BinaryPredicate&gt;
bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p);

</code></pre>
<p>自定义比较器：</p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;

bool char_equal_ignore_case(char a, char b) {
    return std::tolower(a) == std::tolower(b);
}

int main() {
    std::string s1 = "Hello";
    std::string s2 = "hELLo";

    if (std::equal(s1.begin(), s1.end(), s2.begin(), char_equal_ignore_case)) {
        std::cout &lt;&lt; "Equal ignoring case\n";
    }
}

</code></pre>
<h4 id="stdlexicographical_compare"><code>std::lexicographical_compare</code></h4>
<p><code>std::lexicographical_compare</code> 是一个 STL 算法，用于判断两个序列的<strong>字典序（lexicographical order）大小关系</strong>。</p>
<pre><code class="language-cpp">bool smaller = std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
</code></pre>
<hr>
<h3 id="6-数值类需-numeric">6. 数值类（需 <code>&lt;numeric&gt;</code>）</h3>
<p>数值类算法是 <code>&lt;numeric&gt;</code> 头文件中定义的 STL 算法，主要用于<strong>对容器中的数值数据进行数学计算</strong>。这些算法是对“数值序列”的常见处理模式的抽象，例如求和、求积、生成数列等。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>作用</th>
<th>常见用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::accumulate</code></td>
<td>求区间元素的累加或其他二元操作的结果</td>
<td>求和、拼接字符串、自定义累积</td>
</tr>
<tr>
<td><code>std::inner_product</code></td>
<td>求两个区间的<strong>内积</strong>（点积）</td>
<td>向量相乘、相似度计算等</td>
</tr>
<tr>
<td><code>std::iota</code></td>
<td>用顺序值填充容器</td>
<td>初始化、编号等</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="stdaccumulate累加--累积值"><code>std::accumulate</code>：累加 / 累积值</h4>
<ul>
<li>对区间 <code>[first, last)</code> 中的元素进行累计处理</li>
<li>默认是执行 <code>init + x1 + x2 + ...</code></li>
</ul>
<pre><code class="language-cpp">template&lt;class InputIt, class T&gt;
T accumulate(InputIt first, InputIt last, T init);

// 可自定义操作
template&lt;class InputIt, class T, class BinaryOperation&gt;
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4};
int sum = std::accumulate(v.begin(), v.end(), 0);  // 10

std::string s = std::accumulate(v.begin(), v.end(), std::string(),
                                [](std::string acc, int x) {
                                    return acc + std::to_string(x);
                                });  // s = "1234"
</code></pre>
<hr>
<h4 id="stdinner_product内积--点积"><code>std::inner_product</code>：内积 / 点积</h4>
<ul>
<li>对两个序列执行：<code>init + a1*b1 + a2*b2 + ...</code></li>
<li>可自定义加法和乘法操作</li>
</ul>
<pre><code class="language-cpp">template&lt;class InputIt1, class InputIt2, class T&gt;
T inner_product(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init);

// 自定义操作
template&lt;class InputIt1, class InputIt2, class T,
         class BinaryOperation1, class BinaryOperation2&gt;
T inner_product(InputIt1 first1, InputIt1 last1,
                InputIt2 first2, T init,
                BinaryOperation1 add_op,
                BinaryOperation2 mul_op);
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; a = {1, 2, 3};
std::vector&lt;int&gt; b = {4, 5, 6};

int dot = std::inner_product(a.begin(), a.end(), b.begin(), 0);  // 1×4 + 2×5 + 3×6 = 32
</code></pre>
<h4 id="stdiota填充顺序值"><code>std::iota</code>：填充顺序值</h4>
<ul>
<li>将容器中的元素从起始值开始，逐个递增填充（默认+1）</li>
</ul>
<pre><code class="language-cpp">template&lt;class ForwardIt, class T&gt;
void iota(ForwardIt first, ForwardIt last, T value);
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v(5);
std::iota(v.begin(), v.end(), 100);  // v = {100, 101, 102, 103, 104}
</code></pre>
<h3 id="7-集合类容器必须有序">7. 集合类（容器必须有序）</h3>
<h4 id="stdset_union-set_intersection-set_difference"><code>std::set_union</code>, <code>set_intersection</code>, <code>set_difference</code></h4>
<p>集合类算法是 STL <code>&lt;algorithm&gt;</code> 中用于<strong>处理两个有序容器之间集合关系</strong>的一组算法。它们模拟了集合的并集、交集、差集等操作。</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>作用</th>
<th>返回范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::set_union</code></td>
<td>并集：A ∪ B</td>
<td>所有在 A 或 B 中的元素</td>
</tr>
<tr>
<td><code>std::set_intersection</code></td>
<td>交集：A ∩ B</td>
<td>只出现在 A 和 B 中的元素</td>
</tr>
<tr>
<td><code>std::set_difference</code></td>
<td>差集：A - B</td>
<td>只出现在 A 中、不在 B 中的元素</td>
</tr>
<tr>
<td><code>std::set_symmetric_difference</code></td>
<td>对称差集：A △ B</td>
<td>A 或 B 中出现但不都出现的元素</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>容器必须有序</strong>（如 <code>std::set</code>, <code>std::vector</code> 排好序）</li>
<li>通常输出结果放到另一个容器，用 <code>std::back_inserter</code></li>
</ul>
<hr>
<h4 id="示例代码">示例代码</h4>
<ol>
<li>并集 <code>std::set_union</code></li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; a = {1, 2, 4};
std::vector&lt;int&gt; b = {2, 3, 5};
std::vector&lt;int&gt; result;

std::set_union(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
// result = {1, 2, 3, 4, 5}
</code></pre>
<hr>
<ol start="2">
<li>交集 <code>std::set_intersection</code></li>
</ol>
<pre><code class="language-cpp">std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
// result = {2}
</code></pre>
<hr>
<ol start="3">
<li>差集 <code>std::set_difference</code>（A - B）</li>
</ol>
<pre><code class="language-cpp">std::set_difference(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
// result = {1, 4}
</code></pre>
<hr>
<ol start="4">
<li>对称差集 <code>std::set_symmetric_difference</code></li>
</ol>
<pre><code class="language-cpp">std::set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
// result = {1, 3, 4, 5}
</code></pre>
<h3 id="8-分区类">8. 分区类</h3>
<h4 id="stdpartition-stable_partition"><code>std::partition</code>, <code>stable_partition</code></h4>
<p><code>std::partition</code> 和 <code>std::stable_partition</code> 是 STL 中的<strong>分区类算法</strong>，用于根据某个条件（谓词）将一个序列<strong>划分成两部分</strong>：</p>
<blockquote>
<p>按照指定条件，把容器中的元素<strong>分成两组</strong>：一组满足条件，另一组不满足。</p>
</blockquote>
<ul>
<li><code>std::partition</code>：<strong>不保证相对顺序</strong></li>
<li><code>std::stable_partition</code>：<strong>保持相对顺序稳定</strong></li>
</ul>
<pre><code class="language-cpp">// 不稳定分区
template&lt;class BidirIt, class UnaryPredicate&gt;
BidirIt partition(BidirIt first, BidirIt last, UnaryPredicate p);

// 稳定分区
template&lt;class BidirIt, class UnaryPredicate&gt;
BidirIt stable_partition(BidirIt first, BidirIt last, UnaryPredicate p);
</code></pre>
<p>返回值都是 <strong>新的“中间”迭代器</strong>：</p>
<ul>
<li><code>[first, new_iter)</code> 是满足条件的部分</li>
<li><code>[new_iter, last)</code> 是不满足的部分</li>
</ul>
<hr>
<h4 id="示例代码分区奇偶">示例代码（分区奇偶）</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool is_odd(int x) { return x % 2 != 0; }

int main() {
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};

    // std::partition（不稳定）
    auto it = std::partition(v.begin(), v.end(), is_odd);

    std::cout &lt;&lt; "Partition result: ";
    for (int n : v) std::cout &lt;&lt; n &lt;&lt; " ";
    std::cout &lt;&lt; "\nFirst even: " &lt;&lt; *it &lt;&lt; "\n";
}
</code></pre>
<p><strong>可能输出：</strong>（顺序不保证）</p>
<pre><code>Partition result: 5 3 1 4 2 6
First even: 4
</code></pre>
<hr>
<h4 id="稳定版本stdstable_partition">稳定版本：<code>std::stable_partition</code></h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};

auto it = std::stable_partition(v.begin(), v.end(), is_odd);

// 输出：1 3 5 2 4 6
</code></pre>
<p>稳定分区<strong>保留了原始顺序</strong>，即奇数仍然是原来的顺序 1, 3, 5，偶数仍然是 2, 4, 6。</p>
<h3 id="四常见组合示例">四、常见组合示例</h3>
<p>取奇数 → 乘2 → 排序 → 取前 3 个</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1,2,3,4,5,6,7,8};
std::vector&lt;int&gt; filtered, mapped, result;

std::copy_if(v.begin(), v.end(), std::back_inserter(filtered),
             [](int x){ return x % 2 == 1; });
std::transform(filtered.begin(), filtered.end(), std::back_inserter(mapped),
               [](int x){ return x * 2; });
std::sort(mapped.begin(), mapped.end());
std::copy_n(mapped.begin(), std::min&lt;size_t&gt;(3, mapped.size()), std::back_inserter(result));
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18944922" target="_blank">https://www.cnblogs.com/aslanvon/p/18944922</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-23 19:23">2025-06-23 19:22</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18944922);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18944922', targetLink: 'https://www.cnblogs.com/aslanvon/p/18944922', title: 'STL：迭代器与常用算法' })">举报</a>
</div>
        