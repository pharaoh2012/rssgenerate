
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/code-daily/p/18985234" title="发布于 2025-07-15 10:39">
    <span role="heading" aria-level="2">从 Redis 客户端超时到 .NET 线程池挑战：饥饿、窃取与阻塞的全景解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<section id="nice" style="background: linear-gradient(90deg, rgba(50, 0, 0, 0.03) 0, rgba(255, 255, 255, 0) 0) left top / 20px 20px repeat scroll padding-box border-box, linear-gradient(360deg, rgba(50, 0, 0, 0.04) 0, rgba(255, 255, 255, 0) 0) repeat rgba(0, 0, 0, 0); width: auto; font-family: Optima, PingFangSC-light, serif; font-size: 16px; color: rgba(0, 0, 0, 1); line-height: 1.5em; word-spacing: 0; letter-spacing: 0; overflow-wrap: break-word; text-align: left; padding: 0 10px; margin: 0" data-tool="mdnice编辑器" data-website="https://www.mdnice.com">
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在开发 .NET 应用时，我偶然遇到使用 StackExchange.Redis 作为 Redis 客户端时出现的超时问题。经查验，这些问题往往不是 Redis 服务器本身出了故障，而是客户端侧的配置和资源管理不当所致。尤其是当应用运行在高并发环境下，比如 ASP.NET Core 服务中使用 Kestrel 服务器时，超时异常如 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">RedisTimeoutException</code> 或 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">Timeout performing GET</code> 会频繁出现，让人头疼不已。</p>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">通过多次排查和优化，我发现这些问题的根源大多指向 .NET 的线程池（ThreadPool）管理机制，包括线程饥饿（thread starvation）、线程窃取（thread theft）和线程池阻塞等现象。本文将从 StackExchange.Redis 的超时问题入手，逐步深入探讨这些线程池相关的挑战，提供详细的分析、代码示例和优化建议。希望能帮助大家在实际项目中避开这些坑。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">StackExchange.Redis 超时问题的常见表现与初步诊断</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">StackExchange.Redis 是一个高效的 .NET Redis 客户端，支持异步操作和多路复用，但它对底层线程资源的依赖很强。一旦超时发生，异常消息通常会携带丰富的诊断信息，例如：</p>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>Timeout&nbsp;performing&nbsp;GET&nbsp;MyKey&nbsp;(5000ms),&nbsp;inst:&nbsp;1,&nbsp;qs:&nbsp;10,&nbsp;in:&nbsp;1024,&nbsp;mgr:&nbsp;8&nbsp;of&nbsp;10&nbsp;available,&nbsp;IOCP:&nbsp;(Busy=5,Free=995,Min=4,Max=1000),&nbsp;WORKER:&nbsp;(Busy=3,Free=997,Min=4,Max=1000)</code></pre>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">这里，<code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">qs</code> 表示等待响应的请求数，<code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">in</code> 是输入缓冲区字节数，<code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">mgr</code> 是专用线程池状态，<code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">IOCP</code> 和 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">WORKER</code> 则反映了 .NET 全局线程池的忙碌情况。如果 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">qs</code> 值持续增长，或者忙碌线程数（Busy）接近或超过最小线程数（Min），很可能就是线程池问题在作祟。根据 StackExchange.Redis 的官方文档，超时往往源于网络绑定、CPU 负载或线程池饱和。</p>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在我的项目中，一个典型的场景是：在高并发请求下，应用突然出现批量超时。起初，我怀疑是 Redis 服务器负载过高，但通过监控发现服务器端响应正常，问题出在客户端。进一步检查日志，发现线程池的忙碌线程数激增，这让我意识到需要深入了解 .NET 的线程池管理。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">.NET 线程池的管理机制</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">.NET 的线程池是 CLR（Common Language Runtime）提供的一个共享线程资源池，用于处理异步任务、I/O 操作和定时器回调等。它分为两种线程：Worker Threads（用于 CPU 密集型任务）和 IOCP Threads（I/O Completion Port Threads，用于异步 I/O 操作）。线程池的设计目标是高效复用线程，避免开发者手动创建线程带来的开销。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">线程池的动态调整算法</span></h3>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">线程池的大小不是固定的，而是动态调整的。默认最小线程数（MinThreads）通常与 CPU 核心数相关，例如在 4 核机器上，Min 为 4，Max 为 1023。CLR 会根据负载自动增长或收缩线程：</p>
<ul style="list-style-type: disc; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">增长机制</strong>：当任务队列中有待处理项时，每 500ms 添加一个新线程，直到达到 MaxThreads。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">收缩机制</strong>：空闲线程超过一定时间（约 15 秒）后被销毁，降到 MinThreads。</section>
</li>
</ul>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">这种算法在大多数场景下工作良好，但有一个明显的延迟：从最小线程数到增长需要时间。如果突发高负载，初始线程不足会导致任务排队，形成“饥饿”状态。</p>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">你可以通过 C# 代码查询当前线程池状态：</p>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>using&nbsp;System;
using&nbsp;System.Threading;

class&nbsp;ThreadPoolMonitor
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPool.GetMinThreads(out&nbsp;int&nbsp;workerMin,&nbsp;out&nbsp;int&nbsp;iocpMin);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPool.GetMaxThreads(out&nbsp;int&nbsp;workerMax,&nbsp;out&nbsp;int&nbsp;iocpMax);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"最小&nbsp;Worker&nbsp;Threads:&nbsp;{workerMin},&nbsp;IOCP&nbsp;Threads:&nbsp;{iocpMin}");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"最大&nbsp;Worker&nbsp;Threads:&nbsp;{workerMax},&nbsp;IOCP&nbsp;Threads:&nbsp;{iocpMax}");
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在 StackExchange.Redis 中，异步命令如 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">StringGetAsync</code> 会依赖 IOCP 线程处理网络读取。如果 IOCP 线程忙碌，响应回调就会延迟，导致超时。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">StackExchange.Redis 对线程池的依赖</span></h3>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">从 2.0 版本开始，StackExchange.Redis 引入了专用线程池（SocketManager），用于处理大多数异步完成操作。这减少了对全局线程池的依赖，但如果专用线程池饱和（mgr 显示 busy 高），工作仍会溢出到全局线程池。专用线程池大小固定，适合常见负载，但在大规模应用中可能不足。</p>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">例如，在一个连接中，Redis 的读取循环需要专用线程从服务器拉取数据。如果这个线程被阻塞或窃取，整个连接就会卡住。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">线程饥饿：资源耗尽的罪魁祸首</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">线程饥饿是指线程池可用线程被完全占用，无法及时分配给新任务，导致任务在队列中等待过久。为什么会出现饥饿？主要成因包括：</p>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">负载突发</strong>：高并发时，初始 MinThreads 太小，无法立即应对。CLR 的 500ms 增长延迟会放大问题。</p>
</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">同步阻塞异步</strong>：在异步代码中使用 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; height: auto; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">Task.Result</code> 或 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; height: auto; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">Thread.Sleep</code> 会阻塞线程池线程，使其无法复用。例如：</p>
</section>
</li>
</ol>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>var&nbsp;task&nbsp;=&nbsp;db.StringGetAsync("key");
var&nbsp;value&nbsp;=&nbsp;task.Result;&nbsp;&nbsp;//&nbsp;这会阻塞当前线程</code></pre>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">这种操作在高负载下会快速耗尽线程，导致饥饿。</p>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" start="3" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">I/O 操作密集</strong>：Redis 的网络 I/O 需要 IOCP 线程。如果 Min IOCP 太小，突发读取会排队。</section>
</li>
</ol>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在 StackExchange.Redis 中，饥饿表现为 busy IOCP 或 WORKER 高于 Min，qs 值增加。在很多项目中，通过调高 MinThreads 可以有效解决类似问题。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">线程饥饿的流程图</span></h3>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">为了更直观地理解线程饥饿的过程，我绘制了一个简单的流程图：</p>
<figure style="display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/365286/202507/365286-20250715103753810-1410028743.png" alt="" style="display: block; max-width: 100%; border-radius: 8px; object-fit: fill; box-shadow: 2px 4px 8px rgba(153, 153, 153, 1); border: 3px none rgba(0, 0, 0, 0.4); margin: 0 auto"></figure>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">这个图展示了从任务提交到饥饿的链条。如果延迟积累，Redis 操作就会超时。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">线程窃取：专用线程的劫持</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">线程窃取是 StackExchange.Redis 特有的问题，指读取循环线程被其他逻辑“劫持”，导致数据读取中断。官方文档中，如果异常的 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">rs</code> 参数显示 “CompletePendingMessage*”，很可能就是窃取在作祟。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">为什么会出现线程窃取？</span></h3>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">SynchronizationContext 的影响</strong>：在 ASP.NET Core 中，异步延续可能在当前线程（读取线程）上同步执行，导致窃取。</p>
</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">用户代码占用</strong>：回调中执行长操作，会劫持读取线程。</p>
</section>
</li>
</ol>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">解决方案：启用 <code style="color: rgba(53, 148, 247, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0; background: none left top / auto no-repeat scroll padding-box border-box rgba(27, 31, 35, 0.05); width: auto; height: auto; border-radius: 4px; overflow-wrap: break-word; font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace; word-break: break-all; border-top: 3px none rgba(0, 0, 0, 1); border-right: 3px none rgba(0, 0, 0, 0.4); border-bottom: 3px none rgba(0, 0, 0, 0.4); border-left: 3px none rgba(0, 0, 0, 0.4); padding: 2px 4px; margin: 0 2px">preventthreadtheft</code> 标志，将完成操作队列到线程池。</p>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>ConnectionMultiplexer.SetFeatureFlag("preventthreadtheft",&nbsp;true);
var&nbsp;conn&nbsp;=&nbsp;ConnectionMultiplexer.Connect("localhost");</code></pre>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">这能有效避免窃取，但需注意潜在的线程池压力增加。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">窃取与饥饿的交互</span></h3>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">窃取往往与饥饿结合：饥饿时，系统更倾向复用现有线程，包括专用读取线程，进一步恶化问题。<strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">在 Linux 环境下，这种交互更明显，而 Windows 可能不那么敏感</strong>。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">线程池阻塞：综合影响与优化策略</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">线程池阻塞是饥饿和窃取的综合表现，导致整个池无法响应新任务。在 Redis 场景下，阻塞会造成级联超时：一个大请求阻塞连接，后续小请求全军覆没。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">阻塞的深层影响</span></h3>
<ul style="list-style-type: disc; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">性能下降</strong>：响应时间从毫秒级飙升到秒级。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">应用崩溃</strong>：极端情况下，队列无限增长，导致 OOM。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">诊断难度</strong>：需监控忙碌线程数和队列长度。</section>
</li>
</ul>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">我从一个朋友那边了解到，他的线程池阻塞源于同步日志记录，使用信号量保护缓冲区导致。</p>
<h3 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: block; flex-direction: unset; float: unset; height: auto; justify-content: unset; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; border-top: 1px none rgba(0, 0, 0, 1); border-right: 1px none rgba(0, 0, 0, 1); border-bottom: 4px solid rgba(64, 184, 250, 1); border-left: 1px none rgba(0, 0, 0, 1); padding: 0; margin: 30px 0 15px" data-tool="mdnice编辑器"><span class="content" style="font-size: 20px; color: rgba(64, 184, 250, 1); line-height: 1.5em; letter-spacing: 0; align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; font-weight: bold; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 0 0 0 25px; border: 1px none rgba(0, 0, 0, 1)">优化策略与代码实践</span></h3>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">调整线程池配置</strong>：启动时设置 MinThreads。</section>
</li>
</ol>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>ThreadPool.SetMinThreads(200,&nbsp;200);&nbsp;&nbsp;//&nbsp;Worker&nbsp;和&nbsp;IOCP&nbsp;均设为200</code></pre>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">但别过度：高值增加上下文切换开销。</p>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" start="2" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">使用连接池</strong>：维护多个 ConnectionMultiplexer，分散负载。</section>
</li>
</ol>
<pre class="custom highlighter-hljs" style="border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.55); text-align: left; padding: 0; margin: 10px 0" data-tool="mdnice编辑器"><code>private&nbsp;static&nbsp;readonly&nbsp;List&lt;ConnectionMultiplexer&gt;&nbsp;_redisPool&nbsp;=&nbsp;new&nbsp;List&lt;ConnectionMultiplexer&gt;();

public&nbsp;static&nbsp;ConnectionMultiplexer&nbsp;GetAvailableConnection()
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;逻辑：创建或返回负载低的连接
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_redisPool.Count&nbsp;&lt;&nbsp;5)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_redisPool.Add(ConnectionMultiplexer.Connect("localhost"));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_redisPool[0];&nbsp;&nbsp;//&nbsp;简化示例
}</code></pre>
<ol style="list-style-type: decimal; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" start="3" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">监控与重试</strong>：集成 Polly 重试超时操作。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">避免慢命令</strong>：使用 Redis SLOWLOG 检查并优化。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal"><strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">专用线程池自定义</strong>：对于极端场景，自定义 SocketManager。</section>
</li>
</ol>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在我的一个微服务项目中，通过这些优化，超时率从 5% 降到 0.1%。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">案例研究：生产环境中的排查</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">拿一个真实案例来说：在 Azure 上部署的 .NET Core 应用，使用 StackExchange.Redis 缓存用户数据。高峰期超时频发。排查步骤：</p>
<ul style="list-style-type: disc; color: rgba(0, 0, 0, 1); padding: 0 0 0 25px; margin: 8px 0" data-tool="mdnice编辑器">
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">检查异常：qs 高，busy IOCP 超过 Min。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">监控线程池：发现饥饿。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">优化：设 MinThreads 200，启用 preventthreadtheft。</section>
</li>
<li>
<section style="margin-top: 5px; margin-bottom: 5px; color: rgba(89, 89, 89, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; font-weight: normal">结果：问题解决，但内存使用增加 20%。</section>
</li>
</ul>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">在某些场景下，同步等待导致 PhysicalBridge 阻塞，解决方案是<strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">全异步化</strong>。</p>
<h2 style="align-items: unset; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; display: flex; flex-direction: unset; float: unset; height: auto; justify-content: center; line-height: 1.5em; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0; margin: 30px 0 15px; border: 1px none rgba(0, 0, 0, 1)" data-tool="mdnice编辑器"><span class="content" style="font-size: 22px; line-height: 1.8em; letter-spacing: 0; align-items: unset; background: linear-gradient(0deg, rgba(231, 247, 252, 1) 40%, rgba(0, 0, 0, 0) 40%) left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); border-radius: 0; box-shadow: none; color: rgba(112, 188, 234, 1); display: block; font-weight: bold; font-style: normal; flex-direction: unset; float: unset; height: auto; justify-content: unset; overflow-x: unset; overflow-y: unset; position: relative; text-align: left; text-indent: 0; text-shadow: none; transform: none; width: auto; -webkit-box-reflect: unset; padding: 0 10px 0 0; margin: 0; border: 1px none rgba(0, 0, 0, 1)">结语：线程池管理的平衡艺术</span></h2>
<p style="color: rgba(43, 43, 43, 1); font-size: 14px; line-height: 1.8em; letter-spacing: 0.02em; text-align: left; text-indent: 0; padding: 8px 0; margin: 0" data-tool="mdnice编辑器">从 StackExchange.Redis 超时问题出发，我们看到了 .NET 线程池管理的复杂性。线程饥饿、窃取和阻塞不是孤立问题，而是相互交织的。优化需要从配置、代码和监控多角度入手。<strong style="color: rgba(53, 148, 247, 1); font-weight: bold; background: none left top / auto no-repeat scroll padding-box border-box rgba(0, 0, 0, 0); width: auto; height: auto; border-radius: 0; border: 3px none rgba(0, 0, 0, 0.4); padding: 0; margin: 0">记住，线程池是共享资源，过度依赖会放大风险。</strong> 建议在项目初期就规划好异步模式，并定期进行负载测试。</p>
</section>
</div>
<div id="MySignature" role="contentinfo">
    <p>
    本文来自博客园，作者：<a href="https://www.cnblogs.com/code-daily/" target="_blank">AI·NET极客圈</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/code-daily/p/18985234" target="_blank">https://www.cnblogs.com/code-daily/p/18985234</a> 
</p>
<img src="https://images.cnblogs.com/cnblogs_com/blogs/272929/galleries/2447197/o_250311050355_AI.NET%20Logo.png" width="61.8%" style="margin-left:20px">

<p>
    欢迎关注我们的公众号，作为.NET工程师，我们聚焦人工智能技术，探讨 AI 的前沿应用与发展趋势，为你立体呈现人工智能的无限可能，让我们共同携手共同进步。
</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-15 10:39">2025-07-15 10:39</span>&nbsp;
<a href="https://www.cnblogs.com/code-daily">AI·NET极客圈</a>&nbsp;
阅读(<span id="post_view_count">39</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18985234);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18985234', targetLink: 'https://www.cnblogs.com/code-daily/p/18985234', title: '从 Redis 客户端超时到 .NET 线程池挑战：饥饿、窃取与阻塞的全景解析' })">举报</a>
</div>
        