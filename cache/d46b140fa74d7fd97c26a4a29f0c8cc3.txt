
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tiger-Rory/p/18993762" title="发布于 2025-07-20 10:56">
    <span role="heading" aria-level="2">题解：Luogu-P8624 [蓝桥杯 2015 省 AB] 垒骰子</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        动态规划，矩阵快速幂
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>复习了一遍矩阵快速幂，感谢 @<a href="https://www.luogu.com.cn/user/734703" target="_blank" rel="noopener nofollow">naroto2022</a> 的讲课和分享的好题。</p>
<p>本题是一道动态规划结合矩阵加速的好题。</p>
<p>读完题考虑设计状态，记 <span class="math inline">\(f_{i,j}\)</span> 为第 <span class="math inline">\(i\)</span> 个骰子点数 <span class="math inline">\(j\)</span> 朝上时的方案数，则初步得出转移方程为 <span class="math inline">\(f_{i,j} = \sum_{k = 1}^{6}f_{i-1,k}\times 4\)</span>（乘上 <span class="math inline">\(4\)</span> 是因为侧面翻转有 <span class="math inline">\(4\)</span> 种情况）。</p>
<p>接下来对题目中给出的约束条件进行思考，不妨标记一个二维数组 <span class="math inline">\(to\)</span> 来保存每个限制。当 <span class="math inline">\(to_{u,v}\)</span> 为 <span class="math inline">\(0\)</span> 时，方案舍去；否则就维持原状。再标记一个 <span class="math inline">\(opp\)</span> 数组，标记每个点数的对面点数。于是得出进一步的转移方程为 <span class="math inline">\(f_{i,j}=\sum_{k=1}^{6}f_{i-1,k}\times4\times to_{opp_j,k}\)</span>。</p>
<p>此时已经接近正解了，但转移复杂度为 <span class="math inline">\(O(36n)\)</span>，无法接受，于是考虑使用矩阵加速。</p>
<p>由于转移过程与 <span class="math inline">\(i\)</span> 无关，所以考虑矩阵加速转移，记 <span class="math inline">\(mp_{i,j}\)</span> 为上一个骰子 <span class="math inline">\(i\)</span> 点数朝上，当前骰子 <span class="math inline">\(j\)</span> 点数朝上的方案数，这样就可以以 <span class="math inline">\(O(6^3logn)\)</span> 的复杂度通过本题。</p>
<p>接下来是参考代码。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int M=40,N=1e9+5,P=1e9+7; 
int n,m; 
int opp[7]={0,4,5,6,1,2,3}; 
bool to[7][7]; 
struct JZ {
	int mp[7][7]; 
	JZ() {
		memset(mp,0,sizeof mp); 
	}
}a,ans;
JZ operator*(const JZ &amp;x,const JZ &amp;y) {
	JZ z; 
	for(int k=1;k&lt;=6;k++){
		for(int i=1;i&lt;=6;i++){
			for(int j=1;j&lt;=6;j++){
				z.mp[i][j]=(z.mp[i][j]+x.mp[i][k]*y.mp[k][j]%P)%P; 
			}
		}
	}
	return z; 
}//矩阵基本操作
void qpow(int k) {
//答案矩阵预处理
	for(int i=1;i&lt;=6;i++)ans.mp[1][i]=4;
//答案矩阵第一行赋初始值4，因为第一个骰子可以放任意位置

//常数矩阵a预处理
	for(int i=1;i&lt;=6;i++){
		for(int j=1;j&lt;=6;j++){
			if(to[i][opp[j]])a.mp[i][j]=0;//不合法,舍去 
			else a.mp[i][j]=4;//否则合法 
		}
	}
	
	while(k){
		if(k&amp;1)ans=ans*a; 
		a=a*a; 
		k&gt;&gt;=1; 
	}//矩阵快速幂转移计算答案
	return; 
}

signed main() {
	cin.tie(0)-&gt;sync_with_stdio(0);cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m; 
	while(m--){
		int u,v; 
		cin&gt;&gt;u&gt;&gt;v; 
		to[u][v]=1,to[v][u]=1;
//这里的to数组为了方便，与上述的标记意义相反，1为舍去
	}
	qpow(n-1); 
	int res=0; 
	for(int i=1;i&lt;=6;i++){  
		res=(res+ans.mp[1][i]%P)%P; 
	}//所得矩阵第一行元素之和即为答案
	cout&lt;&lt;res; 
	return 0;
}
</code></pre>
<p>如有不足，还请指出，感谢大家观看！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5159722222222223" data-date-updated="2025-07-20 23:19">2025-07-20 10:56</span>&nbsp;
<a href="https://www.cnblogs.com/Tiger-Rory">Tiger_Rory</a>&nbsp;
阅读(<span id="post_view_count">49</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18993762);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18993762', targetLink: 'https://www.cnblogs.com/Tiger-Rory/p/18993762', title: '题解：Luogu-P8624 [蓝桥杯 2015 省 AB] 垒骰子' })">举报</a>
</div>
        