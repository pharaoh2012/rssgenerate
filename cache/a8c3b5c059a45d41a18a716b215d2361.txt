
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/YaoMa/p/18964128" title="发布于 2025-07-03 17:53">
    <span role="heading" aria-level="2">二维差分矩阵</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="差分矩阵">差分矩阵</h3>
<p>输入一个 <code>n</code> 行 <code>m</code> 列的整数矩阵，再输入 <code>q</code> 个操作，每个操作包含五个整数 <code>x1, y1, x2, y2, c</code>，其中 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 <code>c</code>。请你将进行完所有操作后的矩阵输出。</p>
<h3 id="所用方法和基本原理">所用方法和基本原理</h3>
<ol>
<li><strong>二维差分矩阵原理</strong>：
<ul>
<li>与一维差分类似，二维差分是二维前缀和的逆运算。对于一个二维数组 <code>a</code>，其对应的二维差分数组 <code>b</code> 满足：<br>
[b_{i,j}=a_{i,j}-a_{i - 1,j}-a_{i,j - 1}+a_{i - 1,j - 1}]</li>
<li>对二维差分数组 <code>b</code> 进行操作 <code>insert(x1, y1, x2, y2, c)</code>，即对 <code>b[x1][y1] += c</code>，<code>b[x2 + 1][y1] -= c</code>，<code>b[x1][y2 + 1] -= c</code>，<code>b[x2 + 1][y2 + 1] += c</code>，这等价于对原二维数组 <code>a</code> 中以 <code>(x1, y1)</code> 为左上角、<code>(x2, y2)</code> 为右下角的子矩阵内的每个元素都加上 <code>c</code>。</li>
<li>当通过前缀和还原原数组时，这样的操作能保证子矩阵内元素增加 <code>c</code>，而子矩阵外元素不受影响。例如，在计算原矩阵某位置 <code>(i, j)</code> 的值时，由于差分数组的修改，子矩阵内的元素会累加到正确的值。</li>
</ul>
</li>
<li><strong>具体实现</strong>：
<ul>
<li><code>insert</code> 方法实现了对二维差分数组的操作，按照上述规则修改差分数组对应位置的值。</li>
<li><code>prefixSum</code> 方法通过对二维差分数组求前缀和来还原出经过所有操作后的原矩阵。利用二维前缀和的计算方式，通过双重循环遍历差分数组 <code>b</code>，根据公式 <code>a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j]</code> 来计算原矩阵每个位置的值。</li>
</ul>
</li>
</ol>
<h3 id="代码及注释">代码及注释</h3>
<pre><code class="language-java">import java.util.Scanner;

public class DifferenceMatrix {
    // 定义二维差分数组b，这里预留了一定的额外空间
    public static int[][] b = new int[1000 + 10][1000 + 10];

    // 插入操作，对二维差分数组进行修改
    public static void insert(int x1, int y1, int x2, int y2, int c) {
        b[x1][y1] += c;
        b[x2 + 1][y1] -= c;
        b[x1][y2 + 1] -= c;
        b[x2 + 1][y2 + 1] += c;
    }

    // 通过二维差分数组求前缀和还原出最终的矩阵
    public static int[][] prefixSum(int[][] b) {
        int[][] a = new int[b.length][b[0].length];
        for (int i = 1; i &lt; b.length; i++) {
            for (int j = 1; j &lt; b[0].length; j++) {
                // 根据二维前缀和公式计算原矩阵的值
                a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];
            }
        }
        return a;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();
        // 初始化二维差分数组，将原矩阵的每个元素看作是1x1的子矩阵插入
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                int tmp = sc.nextInt();
                insert(i, j, i, j, tmp);
            }
        }
        // 进行q次操作
        for (int i = 0; i &lt; q; i++) {
            int x1 = sc.nextInt();
            int y1 = sc.nextInt();
            int x2 = sc.nextInt();
            int y2 = sc.nextInt();
            int c = sc.nextInt();
            insert(x1, y1, x2, y2, c);
        }
        // 通过二维差分数组还原出最终的矩阵
        int[][] a = prefixSum(b);

        // 输出最终的矩阵
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="举例说明">举例说明</h3>
<p>假设输入一个 <code>3x3</code> 的矩阵 <code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code>，即 <code>n = 3</code>，<code>m = 3</code>，有 <code>q = 1</code> 个操作，操作参数为 <code>x1 = 1</code>，<code>y1 = 1</code>，<code>x2 = 2</code>，<code>y2 = 2</code>，<code>c = 2</code>。</p>
<ol>
<li>
<p><strong>初始化二维差分数组</strong>：</p>
<ul>
<li>对原矩阵每个元素进行 <code>insert(i, j, i, j, tmp)</code> 操作。</li>
<li>例如，对于 <code>(1, 1)</code> 位置，执行 <code>insert(1, 1, 1, 1, 1)</code>，差分数组 <code>b</code> 相应位置改变。最终差分数组 <code>b</code> 反映了原矩阵每个元素的初始化状态。</li>
</ul>
</li>
<li>
<p><strong>进行操作</strong>：</p>
<ul>
<li>
<p>执行操作 <code>insert(1, 1, 2, 2, 2)</code>，差分数组 <code>b</code> 变为：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>-2</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>-2</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p><strong>还原矩阵</strong>：</p>
<ul>
<li>
<p>通过 <code>prefixSum</code> 方法还原矩阵。</p>
</li>
<li>
<p>以 <code>(2, 2)</code> 位置为例，<code>a[2][2] = a[1][2] + a[2][1] - a[1][1] + b[2][2]</code>。逐步计算整个矩阵的值，最终得到操作后的矩阵：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>4</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ol>
<h3 id="方法的优劣">方法的优劣</h3>
<ol>
<li><strong>时间复杂度</strong>：
<ul>
<li><strong>初始化阶段</strong>：初始化二维差分数组，通过双重循环遍历原矩阵每个元素，时间复杂度为 (O(n \times m))。</li>
<li><strong>操作阶段</strong>：进行 <code>q</code> 次操作，每次操作对差分数组的修改时间复杂度为 (O(1))，所以这部分时间复杂度为 (O(q))。</li>
<li><strong>还原阶段</strong>：通过双重循环对二维差分数组求前缀和还原矩阵，时间复杂度为 (O(n \times m))。</li>
<li>总体时间复杂度为 (O(n \times m + q))。相比于每次操作都遍历子矩阵内所有元素的暴力解法（时间复杂度为 (O(q \times n \times m))），在处理多个操作时效率有显著提升。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：
<ul>
<li>需要额外的空间来存储二维差分数组 <code>b</code>，空间复杂度为 (O(n \times m))，因为二维差分数组的大小与原矩阵相同（这里预留了额外空间）。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：<br>
- 对于频繁的子矩阵区间修改操作，时间复杂度较低，能高效处理大量操作。<br>
- 实现思路基于二维前缀和与差分的关系，逻辑相对清晰，易于理解和实现。</p>
<p><strong>缺点</strong>：<br>
- 空间复杂度较高，需要与原矩阵相同大小的额外空间来存储差分数组，对于大规模矩阵可能会占用较多内存。<br>
- 仅适用于子矩阵区间修改、单点查询的场景，如果需要进行子矩阵区间查询等其他操作，可能需要结合其他数据结构。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-03 17:53">2025-07-03 17:53</span>&nbsp;
<a href="https://www.cnblogs.com/YaoMa">起个数先</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18964128);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18964128', targetLink: 'https://www.cnblogs.com/YaoMa/p/18964128', title: '二维差分矩阵' })">举报</a>
</div>
        