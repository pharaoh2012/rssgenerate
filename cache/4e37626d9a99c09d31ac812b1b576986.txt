
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ludangxin/p/18684137" title="发布于 2025-01-22 08:24">
    <span role="heading" aria-level="2">4. 使用sql查询excel内容</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<p>我们在前面的文章中提到了calcite支持csv和json文件的数据源适配, 其实就是将文件解析成表然后以文件夹为schema, 然后将生成的schema注册到<code>RootSehema(RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下)</code>下, 最终使用calcite的特性进行sql的解析查询返回.</p>
<p>但其实我们的数据文件一般使用excel进行存储,流转, 但很可惜, calcite本身没有excel的适配器, 但其实我们可以模仿<code>calcite-file</code>, 自己搞一个<code>calcite-file-excel</code>, 也可以熟悉calcite的工作原理.</p>
<h2 id="2-实现思路">2. 实现思路</h2>
<p>因为excel有sheet的概念, 所以可以将一个excel解析成schema, 每个sheet解析成table, 实现步骤如下:</p>
<ol>
<li>实现<code>SchemaFactory</code>重写create方法: schema工厂 用于创建schema</li>
<li>继承<code>AbstractSchema</code>: schema描述类 用于解析excel, 创建table(解析sheet)</li>
<li>继承<code>AbstractTable, ScannableTable</code>: table描述类 提供字段信息和数据内容等(解析sheet data)</li>
</ol>
<h2 id="3-excel样例">3. Excel样例</h2>
<p>excel有两个sheet页, 分别是<code>user_info</code> 和 <code>role_info</code>如下:<br>
<img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250121182140464-1400739924.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250121182149746-1419890368.png" alt="" loading="lazy"><br>
ok, 万事具备.</p>
<h2 id="4-maven">4. Maven</h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
    &lt;version&gt;5.2.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
    &lt;artifactId&gt;poi&lt;/artifactId&gt;
    &lt;version&gt;5.2.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;
    &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;
    &lt;version&gt;1.37.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="5-核心代码">5. 核心代码</h2>
<h3 id="51-schemafactory">5.1 SchemaFactory</h3>
<pre><code class="language-java">package com.ldx.calcite.excel;

import com.google.common.collect.Lists;
import org.apache.calcite.schema.Schema;
import org.apache.calcite.schema.SchemaFactory;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;

import java.io.File;
import java.util.List;
import java.util.Map;

/**
 * schema factory
 */
public class ExcelSchemaFactory implements SchemaFactory {
    public final static ExcelSchemaFactory INSTANCE = new ExcelSchemaFactory();

    private ExcelSchemaFactory(){}

    @Override
    public Schema create(SchemaPlus parentSchema, String name, Map&lt;String, Object&gt; operand) {
        final Object filePath = operand.get("filePath");

        if (ObjectUtils.isEmpty(filePath)) {
            throw new NullPointerException("can not find excel file");
        }

        return this.create(filePath.toString());
    }

    public Schema create(String excelFilePath) {
        if (StringUtils.isBlank(excelFilePath)) {
            throw new NullPointerException("can not find excel file");
        }

        return this.create(new File(excelFilePath));
    }

    public Schema create(File excelFile) {
        if (ObjectUtils.isEmpty(excelFile) || !excelFile.exists()) {
            throw new NullPointerException("can not find excel file");
        }

        if (!excelFile.isFile() || !isExcelFile(excelFile)) {
            throw new RuntimeException("can not find excel file: " + excelFile.getAbsolutePath());
        }

        return new ExcelSchema(excelFile);
    }

    protected List&lt;String&gt; supportedFileSuffix() {
        return Lists.newArrayList("xls", "xlsx");
    }

    private boolean isExcelFile(File excelFile) {
        if (ObjectUtils.isEmpty(excelFile)) {
            return false;
        }

        final String name = excelFile.getName();
        return StringUtils.endsWithAny(name, this.supportedFileSuffix().toArray(new String[0]));
    }
}
</code></pre>
<p>schema中有多个重载的create方法用于方便的创建schema, 最终将excel file 交给<code>ExcelSchema</code>创建一个schema对象</p>
<h3 id="52-schema">5.2 Schema</h3>
<pre><code class="language-java">package com.ldx.calcite.excel;

import org.apache.calcite.schema.Table;
import org.apache.calcite.schema.impl.AbstractSchema;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.testng.collections.Maps;

import java.io.File;
import java.util.Iterator;
import java.util.Map;

/**
 * schema
 */
public class ExcelSchema extends AbstractSchema {
    private final File excelFile;

    private Map&lt;String, Table&gt; tableMap;

    public ExcelSchema(File excelFile) {
        this.excelFile = excelFile;
    }

    @Override
    protected Map&lt;String, Table&gt; getTableMap() {
        if (ObjectUtils.isEmpty(tableMap)) {
            tableMap = createTableMap();
        }

        return tableMap;
    }

    private Map&lt;String, Table&gt; createTableMap() {
        final Map&lt;String, Table&gt; result = Maps.newHashMap();

        try (Workbook workbook = WorkbookFactory.create(excelFile)) {
            final Iterator&lt;Sheet&gt; sheetIterator = workbook.sheetIterator();

            while (sheetIterator.hasNext()) {
                final Sheet sheet = sheetIterator.next();
                final ExcelScannableTable excelScannableTable = new ExcelScannableTable(sheet, null);
                result.put(sheet.getSheetName(), excelScannableTable);
            }
        }
        catch (Exception ignored) {}

        return result;
    }
}
</code></pre>
<p>schema类读取Excel file, 并循环读取sheet, 将每个sheet解析成<code>ExcelScannableTable</code>并存储</p>
<h3 id="53-table">5.3 Table</h3>
<pre><code class="language-java">package com.ldx.calcite.excel;

import com.google.common.collect.Lists;
import com.ldx.calcite.excel.enums.JavaFileTypeEnum;
import org.apache.calcite.DataContext;
import org.apache.calcite.adapter.java.JavaTypeFactory;
import org.apache.calcite.linq4j.Enumerable;
import org.apache.calcite.linq4j.Linq4j;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rel.type.RelDataTypeFactory;
import org.apache.calcite.rel.type.RelProtoDataType;
import org.apache.calcite.schema.ScannableTable;
import org.apache.calcite.schema.impl.AbstractTable;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.calcite.util.Pair;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.List;

/**
 * table
 */
public class ExcelScannableTable extends AbstractTable implements ScannableTable {
    private final RelProtoDataType protoRowType;

    private final Sheet sheet;

    private RelDataType rowType;

    private List&lt;JavaFileTypeEnum&gt; fieldTypes;

    private List&lt;Object[]&gt; rowDataList;

    public ExcelScannableTable(Sheet sheet, RelProtoDataType protoRowType) {
        this.protoRowType = protoRowType;
        this.sheet = sheet;
    }

    @Override
    public Enumerable&lt;@Nullable Object[]&gt; scan(DataContext root) {
        JavaTypeFactory typeFactory = root.getTypeFactory();
        final List&lt;JavaFileTypeEnum&gt; fieldTypes = this.getFieldTypes(typeFactory);

        if (rowDataList == null) {
            rowDataList = readExcelData(sheet, fieldTypes);
        }

        return Linq4j.asEnumerable(rowDataList);
    }

    @Override
    public RelDataType getRowType(RelDataTypeFactory typeFactory) {
        if (ObjectUtils.isNotEmpty(protoRowType)) {
            return protoRowType.apply(typeFactory);
        }

        if (ObjectUtils.isEmpty(rowType)) {
            rowType = deduceRowType((JavaTypeFactory) typeFactory, sheet, null);
        }

        return rowType;
    }

    public List&lt;JavaFileTypeEnum&gt; getFieldTypes(RelDataTypeFactory typeFactory) {
        if (fieldTypes == null) {
            fieldTypes = Lists.newArrayList();
            deduceRowType((JavaTypeFactory) typeFactory, sheet, fieldTypes);
        }
        return fieldTypes;
    }

    private List&lt;Object[]&gt; readExcelData(Sheet sheet, List&lt;JavaFileTypeEnum&gt; fieldTypes) {
        List&lt;Object[]&gt; rowDataList = Lists.newArrayList();

        for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
            Row row = sheet.getRow(rowIndex);
            Object[] rowData = new Object[fieldTypes.size()];

            for (int i = 0; i &lt; row.getLastCellNum(); i++) {
                final JavaFileTypeEnum javaFileTypeEnum = fieldTypes.get(i);
                Cell cell = row.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                final Object cellValue = javaFileTypeEnum.getCellValue(cell);
                rowData[i] = cellValue;
            }

            rowDataList.add(rowData);
        }

        return rowDataList;
    }

    public static RelDataType deduceRowType(JavaTypeFactory typeFactory, Sheet sheet, List&lt;JavaFileTypeEnum&gt; fieldTypes) {
        final List&lt;String&gt; names = Lists.newArrayList();
        final List&lt;RelDataType&gt; types = Lists.newArrayList();

        if (sheet != null) {
            Row headerRow = sheet.getRow(0);

            if (headerRow != null) {
                for (int i = 0; i &lt; headerRow.getLastCellNum(); i++) {
                    Cell cell = headerRow.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                    String[] columnInfo = cell
                            .getStringCellValue()
                            .split(":");
                    String columnName = columnInfo[0].trim();
                    String columnType = null;

                    if (columnInfo.length == 2) {
                        columnType = columnInfo[1].trim();
                    }

                    final JavaFileTypeEnum javaFileType = JavaFileTypeEnum
                            .of(columnType)
                            .orElse(JavaFileTypeEnum.UNKNOWN);
                    final RelDataType sqlType = typeFactory.createSqlType(javaFileType.getSqlTypeName());
                    names.add(columnName);
                    types.add(sqlType);

                    if (fieldTypes != null) {
                        fieldTypes.add(javaFileType);
                    }
                }
            }
        }

        if (names.isEmpty()) {
            names.add("line");
            types.add(typeFactory.createSqlType(SqlTypeName.VARCHAR));
        }

        return typeFactory.createStructType(Pair.zip(names, types));
    }
}
</code></pre>
<p>table类中其中有两个比较关键的方法</p>
<ul>
<li>
<p><code>scan</code>: 扫描表内容, 我们这里将sheet页面的数据内容解析存储最后交给calcite</p>
</li>
<li>
<p><code>getRowType</code>: 获取字段信息, 我们这里默认使用第一条记录作为表头(row[0]) 并解析为字段信息, 字段规则跟csv一样 <code>name:string</code>, 冒号前面的是字段key, 冒号后面的是字段类型, 如果未指定字段类型, 则解析为<code>UNKNOWN</code>, 后续<code>JavaFileTypeEnum</code>会进行类型推断, 最终在结果处理时calcite也会进行推断</p>
</li>
<li>
<p><code>deduceRowType</code>: 推断字段类型, 方法中使用<code>JavaFileTypeEnum</code>枚举类对java type &amp; sql type &amp; 字段值转化处理方法 进行管理</p>
</li>
</ul>
<h3 id="54-columntypeenum">5.4 ColumnTypeEnum</h3>
<pre><code class="language-java">package com.ldx.calcite.excel.enums;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.avatica.util.DateTimeUtils;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.FastDateFormat;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.util.CellUtil;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Optional;
import java.util.TimeZone;
import java.util.function.Function;

/**
 * type converter
 */
@Slf4j
@Getter
public enum JavaFileTypeEnum {
    STRING("string", SqlTypeName.VARCHAR, Cell::getStringCellValue),
    BOOLEAN("boolean", SqlTypeName.BOOLEAN, Cell::getBooleanCellValue),
    BYTE("byte", SqlTypeName.TINYINT, Cell::getStringCellValue),
    CHAR("char", SqlTypeName.CHAR, Cell::getStringCellValue),
    SHORT("short", SqlTypeName.SMALLINT, Cell::getNumericCellValue),
    INT("int", SqlTypeName.INTEGER, cell -&gt; (Double.valueOf(cell.getNumericCellValue()).intValue())),
    LONG("long", SqlTypeName.BIGINT, cell -&gt; (Double.valueOf(cell.getNumericCellValue()).longValue())),
    FLOAT("float", SqlTypeName.REAL, Cell::getNumericCellValue),
    DOUBLE("double", SqlTypeName.DOUBLE, Cell::getNumericCellValue),
    DATE("date", SqlTypeName.DATE, getValueWithDate()),
    TIMESTAMP("timestamp", SqlTypeName.TIMESTAMP, getValueWithTimestamp()),
    TIME("time", SqlTypeName.TIME, getValueWithTime()),
    UNKNOWN("unknown", SqlTypeName.UNKNOWN, getValueWithUnknown()),;
    // cell type
    private final String typeName;
	// sql type
    private final SqlTypeName sqlTypeName;
    // value convert func
    private final Function&lt;Cell, Object&gt; cellValueFunc;

    private static final FastDateFormat TIME_FORMAT_DATE;

    private static final FastDateFormat TIME_FORMAT_TIME;

    private static final FastDateFormat TIME_FORMAT_TIMESTAMP;

    static {
        final TimeZone gmt = TimeZone.getTimeZone("GMT");
        TIME_FORMAT_DATE = FastDateFormat.getInstance("yyyy-MM-dd", gmt);
        TIME_FORMAT_TIME = FastDateFormat.getInstance("HH:mm:ss", gmt);
        TIME_FORMAT_TIMESTAMP = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss", gmt);
    }

    JavaFileTypeEnum(String typeName, SqlTypeName sqlTypeName, Function&lt;Cell, Object&gt; cellValueFunc) {
        this.typeName = typeName;
        this.sqlTypeName = sqlTypeName;
        this.cellValueFunc = cellValueFunc;
    }

    public static Optional&lt;JavaFileTypeEnum&gt; of(String typeName) {
        return Arrays
                .stream(values())
                .filter(type -&gt; StringUtils.equalsIgnoreCase(typeName, type.getTypeName()))
                .findFirst();
    }

    public static SqlTypeName findSqlTypeName(String typeName) {
        final Optional&lt;JavaFileTypeEnum&gt; javaFileTypeOptional = of(typeName);

        if (javaFileTypeOptional.isPresent()) {
            return javaFileTypeOptional
                    .get()
                    .getSqlTypeName();
        }

        return SqlTypeName.UNKNOWN;
    }

    public Object getCellValue(Cell cell) {
        return cellValueFunc.apply(cell);
    }

    public static Function&lt;Cell, Object&gt; getValueWithUnknown() {
        return cell -&gt; {
            if (ObjectUtils.isEmpty(cell)) {
                return null;
            }

            switch (cell.getCellType()) {
                case STRING:
                    return cell.getStringCellValue();
                case NUMERIC:
                    if (DateUtil.isCellDateFormatted(cell)) {
                        // 如果是日期类型，返回日期对象
                        return cell.getDateCellValue();
                    }
                    else {
                        // 否则返回数值
                        return cell.getNumericCellValue();
                    }
                case BOOLEAN:
                    return cell.getBooleanCellValue();
                case FORMULA:
                    // 对于公式单元格，先计算公式结果，再获取其值
                    try {
                        return cell.getNumericCellValue();
                    }
                    catch (Exception e) {
                        try {
                            return cell.getStringCellValue();
                        }
                        catch (Exception ex) {
                            log.error("parse unknown data error, cellRowIndex:{}, cellColumnIndex:{}", cell.getRowIndex(), cell.getColumnIndex(), e);
                            return null;
                        }
                    }
                case BLANK:
                    return "";
                default:
                    return null;
            }
        };
    }

    public static Function&lt;Cell, Object&gt; getValueWithDate() {
        return cell -&gt; {
            Date date = cell.getDateCellValue();

            if(ObjectUtils.isEmpty(date)) {
                return null;
            }

            try {
                final String formated = new SimpleDateFormat("yyyy-MM-dd").format(date);
                Date newDate = TIME_FORMAT_DATE.parse(formated);
                return (int) (newDate.getTime() / DateTimeUtils.MILLIS_PER_DAY);
            }
            catch (ParseException e) {
                log.error("parse date error, date:{}", date, e);
            }

            return null;
        };
    }

    public static Function&lt;Cell, Object&gt; getValueWithTimestamp() {
        return cell -&gt; {
            Date date = cell.getDateCellValue();

            if(ObjectUtils.isEmpty(date)) {
                return null;
            }

            try {
                final String formated = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);
                Date newDate = TIME_FORMAT_TIMESTAMP.parse(formated);
                return (int) newDate.getTime();
            }
            catch (ParseException e) {
                log.error("parse timestamp error, date:{}", date, e);
            }

            return null;
        };
    }

    public static Function&lt;Cell, Object&gt; getValueWithTime() {
        return cell -&gt; {
            Date date = cell.getDateCellValue();

            if(ObjectUtils.isEmpty(date)) {
                return null;
            }

            try {
                final String formated = new SimpleDateFormat("HH:mm:ss").format(date);
                Date newDate = TIME_FORMAT_TIME.parse(formated);
                return newDate.getTime();
            }
            catch (ParseException e) {
                log.error("parse time error, date:{}", date, e);
            }

            return null;
        };
    }
}
</code></pre>
<p>该枚举类主要管理了<code>java type</code>&amp; <code>sql type</code> &amp; <code>cell value convert func</code>, 方便统一管理类型映射及单元格内容提取时的转换方法(这里借用了java8 function函数特性)</p>
<blockquote>
<p>注: 这里的日期转换只能这样写, 即使用GMT的时区(抄的<code>calcite-file</code>), 要不然输出的日期时间一直有时差...</p>
</blockquote>
<h3 id="6-测试查询">6. 测试查询</h3>
<pre><code class="language-java">package com.ldx.calcite;

import com.ldx.calcite.excel.ExcelSchemaFactory;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.config.CalciteConnectionProperty;
import org.apache.calcite.jdbc.CalciteConnection;
import org.apache.calcite.schema.Schema;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.util.Sources;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.testng.collections.Maps;

import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.Properties;

@Slf4j
public class CalciteExcelTest {
    private static Connection connection;

    private static SchemaPlus rootSchema;

    private static CalciteConnection calciteConnection;

    @BeforeAll
    @SneakyThrows
    public static void beforeAll() {
        Properties info = new Properties();
        // 不区分sql大小写
        info.setProperty(CalciteConnectionProperty.CASE_SENSITIVE.camelName(), "false");
        // 创建Calcite连接
        connection = DriverManager.getConnection("jdbc:calcite:", info);
        calciteConnection = connection.unwrap(CalciteConnection.class);
        // 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
        rootSchema = calciteConnection.getRootSchema();
    }

    @Test
    @SneakyThrows
    public void test_execute_query() {
        final Schema schema = ExcelSchemaFactory.INSTANCE.create(resourcePath("file/test.xlsx"));
        rootSchema.add("test", schema);
        // 设置默认的schema
        calciteConnection.setSchema("test");
        final Statement statement = calciteConnection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM user_info");
        printResultSet(resultSet);
        System.out.println("=========");
        ResultSet resultSet2 = statement.executeQuery("SELECT * FROM test.user_info where id &gt; 110 and birthday &gt; '2003-01-01'");
        printResultSet(resultSet2);
        System.out.println("=========");
        ResultSet resultSet3 = statement.executeQuery("SELECT * FROM test.user_info ui inner join  test.role_info ri on ui.role_id = ri.id");
        printResultSet(resultSet3);
    }

    @AfterAll
    @SneakyThrows
    public static void closeResource() {
        connection.close();
    }

    private static String resourcePath(String path) {
        final URL url = CalciteExcelTest.class.getResource("/" + path);
        return Sources.of(url).file().getAbsolutePath();
    }

    public static void printResultSet(ResultSet resultSet) throws SQLException {
        // 获取 ResultSet 元数据
        ResultSetMetaData metaData = resultSet.getMetaData();

        // 获取列数
        int columnCount = metaData.getColumnCount();
        log.info("Number of columns: {}",columnCount);

        // 遍历 ResultSet 并打印结果
        while (resultSet.next()) {
            final Map&lt;String, String&gt; item = Maps.newHashMap();
            // 遍历每一列并打印
            for (int i = 1; i &lt;= columnCount; i++) {
                String columnName = metaData.getColumnName(i);
                String columnValue = resultSet.getString(i);
                item.put(columnName, columnValue);
            }

            log.info(item.toString());
        }
    }
}
</code></pre>
<p>测试结果如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250121182221167-264895142.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7057316409675926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 11:19">2025-01-22 08:24</span>&nbsp;
<a href="https://www.cnblogs.com/ludangxin">张铁牛</a>&nbsp;
阅读(<span id="post_view_count">503</span>)&nbsp;
评论(<span id="post_comment_count">20</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18684137" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18684137);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18684137', targetLink: 'https://www.cnblogs.com/ludangxin/p/18684137', title: '4. 使用sql查询excel内容' })">举报</a>
</div>
        