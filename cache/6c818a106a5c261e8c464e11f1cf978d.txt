
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vigourice/p/18860423" title="发布于 2025-05-05 20:35">
    <span role="heading" aria-level="2">为React组件库引入自动化测试：从零到完善的实践之路</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="为什么我们需要测试">为什么我们需要测试？</h1>
<p>我们的 React+TypeScript 业务组件库已经稳定运行了一段时间，主要承载各类UI展示组件，如卡片、通知等。项目初期，迫于紧张的开发周期，我们暂时搁置了自动化测试的引入。当时团队成员对组件逻辑了如指掌，即便没有测试也能游刃有余。</p>
<p>然而随着时间推移，问题逐渐显现。当新成员加入或老组件需要迭代时，我们常常陷入两难：修改代码可能破坏原有功能，但不修改又无法满足新需求。特别是在处理那些具有多种交互状态的复杂组件时，手动测试变得既耗时又不可靠。这时，引入自动化测试的必要性就凸显出来了。</p>
<h1 id="搭建测试环境">搭建测试环境</h1>
<h2 id="依赖安装">依赖安装</h2>
<p>我们首先从安装核心测试依赖开始，这些工具将构成我们测试体系的基础框架：</p>
<ul>
<li>测试运行核心：jest和jsdom环境包</li>
<li>TypeScript支持：确保类型安全的测试环境</li>
<li>React测试工具：专门为React组件设计的测试工具链</li>
</ul>
<pre><code class="language-javascript">npm install jest jest-environment-jsdom @types/jest ts-jest @testing-library/react @testing-library/jest-dom @testing-library/user-event --save-dev
</code></pre>
<h2 id="配置jest">配置Jest</h2>
<p>创建jest.config.ts配置文件时，有几个关注点：</p>
<ul>
<li>针对TypeScript项目的特殊处理</li>
<li>浏览器环境的模拟</li>
<li>测试初始化流程</li>
<li>文件转换规则</li>
</ul>
<pre><code class="language-javascript">module.exports = {
  preset: "ts-jest", // 为 TypeScript 项目准备的 Jest 配置预设
  testEnvironment: "jsdom", // 测试运行在模拟的浏览器环境中
  setupFilesAfterEnv: ["&lt;rootDir&gt;/jest.setup.ts"], // 指定在测试环境初始化后立即执行的文件
  transform: {
    "^.+\\.(ts|tsx)$": "ts-jest", // 使用 ts-jest 处理所有 .ts 和 .tsx 文件
  },
  testPathIgnorePatterns: ["/node_modules/", "/dist/"], // 忽略指定目录下的测试文件
  moduleFileExtensions: ["ts", "tsx", "js", "jsx", "json", "node"], // 定义 Jest 能识别的模块文件扩展名
};

export {}; // 使文件成为模块
</code></pre>
<p>创建jest.setup.ts文件引入断言库：</p>
<pre><code class="language-javascript">import "@testing-library/jest-dom";
</code></pre>
<h2 id="typescript配置">TypeScript配置</h2>
<p>修改tsconfig.json包含测试相关文件：</p>
<pre><code class="language-javascript">{
  "include": [
    "src",
    "jest.config.ts",
    "jest.setup.ts",
    "__mocks__/**/*.ts"
  ]
}
</code></pre>
<h1 id="测试用例编写">测试用例编写</h1>
<p>我们以一个通知组件为例，该组件有两种UI形态：</p>
<ul>
<li>标题和描述组合的时间内容文案提示</li>
<li>带有喇叭图标的提示，点击关闭按钮时调用接口保存用户状态<br>
<img src="https://img2024.cnblogs.com/blog/1408181/202505/1408181-20250505202427070-1832792820.png" alt="" loading="lazy"></li>
</ul>
<h2 id="特殊依赖处理">特殊依赖处理</h2>
<p>组件中有三类特殊引入需要处理：</p>
<pre><code class="language-javascript">import './index.less';
import { noticeIcon, closeIcon } from "$src/common/icon";
import request from "$src/request";
</code></pre>
<p><strong>1、处理 CSS/LESS 资源</strong><br>
Jest 默认无法解析 CSS/LESS 文件，我们可以通过配置将其模拟为空对象：</p>
<pre><code class="language-javascript">// jest.config.js
module.exports = {
  moduleNameMapper: {
    "\\.(less|css)$': '&lt;rootDir&gt;/__mocks__/styleMock.ts", // 指向一个空文件
  },
};

// __mocks__/styleMock.ts
module.exports = {};
</code></pre>
<p><strong>2、配置路径别名</strong><br>
对于&nbsp;<code>$src</code>&nbsp;这样的路径别名，需要在 Jest 配置中映射：</p>
<pre><code class="language-javascript">// jest.config.js
module.exports = {
  moduleNameMapper: {
    '^\\$src/(.*)$': '&lt;rootDir&gt;/src/$1',
  },
};
</code></pre>
<p><strong>3、模拟图标资源</strong><br>
对于图标这类静态资源，我们可以在测试文件中直接模拟：</p>
<pre><code class="language-javascript">// __tests__/index.test.tsx
jest.mock('$src/common/icon', () =&gt; ({
  noticeIcon: 'notice-icon-path',
  closeIcon: 'close-icon-path',
}));
</code></pre>
<p><strong>4、模拟 API 请求</strong></p>
<p>对于网络请求模块，我们可以将其转换为 Jest 模拟函数：</p>
<pre><code class="language-javascript">// __tests__/index.test.tsx
import request from '$src/request';

const mockedRequest = request as jest.MockedFunction&lt;typeof request&gt;;

jest.mock('$src/request', () =&gt; ({
  __esModule: true, // 标识这是 ES Module
  default: jest.fn(() =&gt; Promise.resolve({ data: {} })),
}));
</code></pre>
<p>通过以上配置，我们能够有效地隔离组件测试环境，专注于组件逻辑本身的测试，而不受样式、静态资源和网络请求等外部因素的影响。</p>
<h2 id="基础测试框架搭建">基础测试框架搭建</h2>
<p>我们首先建立测试的基本结构：</p>
<pre><code class="language-javascript">describe("Notification组件", () =&gt; {
  // 公共props定义
  const baseProps = {
    body: {},
    tokenId: "test-token",
    urlPrefix: "https://api.example.com",
  };

  // 每个测试用例前的清理工作
  beforeEach(() =&gt; {
    jest.clearAllMocks();
    mockedRequest.mockReset();
  });
});
</code></pre>
<h2 id="核心测试场景覆盖">核心测试场景覆盖</h2>
<p>在配置好 Jest 测试环境后，我们将针对通知组件编写全面的测试用例。该组件具有两种展示形态和交互逻辑，我们将从四个关键维度进行测试覆盖：</p>
<p><strong>1、边界情况测试</strong></p>
<p>我们首先考虑最极端的场景——当传入无效props时，组件是否能够优雅处理：</p>
<pre><code class="language-javascript">it("当传入无效body时应安全地返回null", () =&gt; {
  const { container } = render(&lt;Notification {...baseProps} body={null} /&gt;);
  expect(container.firstChild).toBeNull();
});
</code></pre>
<p><strong>2、日期类型展示验证</strong><br>
对于日期类型的通知，我们需要确认：</p>
<ul>
<li>关键文本是否正确渲染</li>
<li>DOM结构是否符合预期</li>
<li>样式类是否准确应用</li>
</ul>
<pre><code class="language-javascript">it("应正确渲染日期类型通知", () =&gt; {
  render(&lt;Notification {...dateProps} /&gt;);
  
  expect(screen.getByText("今日公告")).toBeInTheDocument();
  expect(screen.getByText("2023-06-15")).toBeInTheDocument();
  
  const dateContainer = screen.getByText("今日公告").parentElement;
  expect(dateContainer).toHaveClass("notice-header-date");
});
</code></pre>
<p><strong>3、广播类型交互测试</strong></p>
<p>广播通知的测试更加复杂，需要验证：</p>
<ul>
<li>初始状态下的元素展示</li>
<li>图标资源是否正确加载</li>
<li>点击关闭后的行为</li>
</ul>
<pre><code class="language-javascript">it("点击关闭按钮后应隐藏通知内容", async () =&gt; {
  render(&lt;Notification {...broadcastProps} /&gt;);
  
  const closeButton = screen.getAllByRole("img")[1].parentElement;
  fireEvent.click(closeButton!);
  
  await waitFor(() =&gt; {
    expect(screen.queryByText("重要通知内容")).not.toBeInTheDocument();
  });
});
</code></pre>
<p><strong>4、网络请求场景全覆盖</strong><br>
对于涉及API调用的场景，我们设计了多维度测试：</p>
<ul>
<li>正常请求流程</li>
<li>无请求场景请求</li>
<li>失败处理</li>
<li>请求中的状态管理</li>
</ul>
<pre><code class="language-javascript">describe("网络请求测试", () =&gt; {
  const broadcastPropsWithCloseUrl = {
    ...baseProps,
    body: {
      type: BROADCAST_TYPE,
      content: "重要通知内容",
      closeUrl: "/close-notice",
    },
  };

  const broadcastPropsWithoutCloseUrl = {
    ...baseProps,
    body: {
      type: BROADCAST_TYPE,
      content: "重要通知内容",
      // 没有closeUrl
    },
  };

  it("点击关闭时应该发送请求", async () =&gt; {
    // 模拟请求成功
    mockedRequest.mockResolvedValue({ data: {} });

    render(&lt;Notification {...broadcastPropsWithCloseUrl} /&gt;);

    const closeButton = screen.getAllByRole("img")[1].parentElement;

    await act(async () =&gt; {
      fireEvent.click(closeButton!);
    });

    //验证请求参数
    expect(request).toHaveBeenCalledWith({
      url: "https://api.example.com/close-notice",
      method: "post",
      data: {},
      headers: {
        tokenId: "test-token",
      },
    });

    // 验证UI更新
    expect(screen.queryByText("重要通知内容")).not.toBeInTheDocument();
  });

  it("当没有closeUrl时不发送请求", async () =&gt; {
    render(&lt;Notification {...broadcastPropsWithoutCloseUrl} /&gt;);

    const closeButton = screen.getAllByRole("img")[1].parentElement;

    await act(async () =&gt; {
      fireEvent.click(closeButton!);
    });

    expect(request).not.toHaveBeenCalled();
    // 验证UI仍然会更新
    expect(screen.queryByText("重要通知内容")).not.toBeInTheDocument();
  });

  it("请求失败时仍然关闭通知", async () =&gt; {
    // 模拟请求失败
    mockedRequest.mockResolvedValue(new Error("Request failed"));

    render(&lt;Notification {...broadcastPropsWithCloseUrl} /&gt;);

    const closeButton = screen.getAllByRole("img")[1].parentElement;

    await act(async () =&gt; {
      fireEvent.click(closeButton!);
    });

    // 验证即使请求失败，UI也会更新
    expect(screen.queryByText("重要通知内容")).not.toBeInTheDocument();
    expect(request).toHaveBeenCalled();
  });

  it("请求期间UI应保持响应", async () =&gt; {
    // 创建一个未立即resolve的Promise
    let resolveRequest: any;
    const promise = new Promise((resolve) =&gt; {
      resolveRequest = resolve;
    });
    mockedRequest.mockReturnValue(promise);

    render(&lt;Notification {...broadcastPropsWithCloseUrl} /&gt;);

    const closeButton = screen.getAllByRole("img")[1].parentElement;

    // 第一次点击
    fireEvent.click(closeButton!);

    // 验证UI已立即更新
    expect(screen.queryByText("重要通知内容")).not.toBeInTheDocument();

    // 完成请求
    await act(async () =&gt; {
      resolveRequest({ data: {} });
    });
});
</code></pre>
<h1 id="测试执行与覆盖率">测试执行与覆盖率</h1>
<h2 id="基础测试执行">基础测试执行</h2>
<p>在完成通知组件的测试用例编写后，可以在&nbsp;package.json&nbsp;中配置测试脚本：</p>
<pre><code class="language-javascript">{
  "scripts": {
    "test": "jest"
  }
}
</code></pre>
<p>执行&nbsp;npm run test&nbsp;命令后，如下图所示，Jest 会在终端输出测试结果，包括：</p>
<ul>
<li>测试文件数量</li>
<li>通过的测试用例数</li>
<li>失败的测试用例详情（包含错误堆栈信息）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202505/1408181-20250505202448129-843650154.png" alt="" loading="lazy"></p>
<h2 id="覆盖率报告配置">覆盖率报告配置</h2>
<p>为了更全面地评估测试质量，可以通过修改&nbsp;jest.config.ts&nbsp;启用覆盖率统计：</p>
<pre><code class="language-javascript">module.exports = {
  collectCoverage: true, // 启用覆盖率收集
  coverageDirectory: "coverage", // 指定覆盖率报告的输出目录
  coverageReporters: ["text", "html", "lcov", "clover"], //指定生成的覆盖率报告格式
  coverageThreshold: {
    // 设置覆盖率的最低阈值，如果未达标，Jest 会报错
    global: {
      // 全局覆盖率要求
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
    "./src/components/**/*.tsx": {
      // 针对特定目录/文件设置更高要求
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90,
    },
  },
}  
</code></pre>
<p>执行测试后：终端会显示各维度的覆盖率百分比，在&nbsp;coverage/&nbsp;目录下生成详细报告：index.html&nbsp;提供可视化分析可逐层查看未覆盖的代码路径。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202505/1408181-20250505202456621-2081665508.png" alt="" loading="lazy"></p>
<p>示例输出中显示&nbsp;common/util.ts&nbsp;仅 32.39% 覆盖率，低于预设阈值。此时应该优先补充核心工具函数的测试用例。通过持续完善测试覆盖，可以有效提升组件迭代的可靠性，并为后续重构提供安全保障。</p>
<p>通过引入自动化测试，我们实现了从"人肉测试"到系统化保障的转变。精心设计的测试用例覆盖了各种边界情况，配合覆盖率分析，构建了多层次的质量防护体系。</p>
<p>如果你对前端工程化有兴趣，或者想了解更多相关的内容，欢迎查看我的其他文章，这些内容将持续更新，希望能给你带来更多的灵感和技术分享~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4031567263310185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-05 20:35">2025-05-05 20:35</span>&nbsp;
<a href="https://www.cnblogs.com/vigourice">一颗冰淇淋</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18860423);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18860423', targetLink: 'https://www.cnblogs.com/vigourice/p/18860423', title: '为React组件库引入自动化测试：从零到完善的实践之路' })">举报</a>
</div>
	