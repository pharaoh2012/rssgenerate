
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sdcb/p/18995424/mcp-http-insights" title="发布于 2025-07-22 08:45">
    <span role="heading" aria-level="2">官方文档没告诉你的：通过抓包，深入揭秘MCP协议底层通信</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，今天我们来深入探讨一个很有意思的话题——MCP（Model Context Protocol）。</p>
<p>MCP 是Anthropic发起的一种开放协议，旨在标准化应用程序向大型语言模型（LLM）提供上下文的方式。我们可以把 MCP 想象成 AI 应用领域的 <strong>USB-C</strong> 接口。正如 USB-C 为你的设备与各种外设和配件的连接提供了标准化方式一样，MCP 也为 AI 模型与不同数据源和工具的连接提供了标准化的方法。</p>
<p>然而，MCP官网只模糊地提到它是基于 <strong>JSON-RPC 2.0</strong> 的协议，并提供了包括 C# 在内的八种语言的SDK。但对于其底层的HTTP请求和响应格式，官方文档并未给出清晰的描述，这让许多想要深入了解或自行实现的开发者感到困惑。</p>
<p>本文将通过一个具体的 C# 实例，结合抓包数据，一步步揭开 MCP 协议在 HTTP 层面上的神秘面纱。</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202507/233608-20250721180000411-120184038.png" alt="image" loading="lazy"></p>
<h3 id="准备工作示例代码">准备工作：示例代码</h3>
<p>为了抓包和演示，我们首先需要一个客户端和一个服务端。这里我们使用的是 <code>ModelContextProtocol 0.3.0-preview.3</code> 版本的 NuGet 包。</p>
<h4 id="客户端-client">客户端 (Client)</h4>
<p>客户端代码负责发起连接、列出可用工具并调用它们。</p>
<pre><code class="language-csharp">// 需要安装NuGet包：ModelContextProtocol 0.3.0-preview.3

var clientTransport = new SseClientTransport(new SseClientTransportOptions()
{
    Name = "MyServer",
    Endpoint = new Uri("http://localhost:5000/"),
});

var client = await McpClientFactory.CreateAsync(clientTransport);

// Print the list of tools available from the server.
(await client.ListToolsAsync()).Select(x =&gt; new { x.Name, Desc = JsonObject.Parse(x.JsonSchema.ToString()) }).Dump();

// Execute a tool (this would normally be driven by LLM tool invocations).
(await client.CallToolAsync(
    "echo",
    new Dictionary&lt;string, object?&gt;() { ["message"] = ".NET is awesome!" },
    cancellationToken: CancellationToken.None)).Dump();

(await client.CallToolAsync(
    "count",
    new Dictionary&lt;string, object?&gt;() { ["n"] = 5 },
    new Reporter(),
    cancellationToken: CancellationToken.None)).Dump();

(await client.CallToolAsync("test_throw", cancellationToken: CancellationToken.None)).Dump();

(await client.CallToolAsync("not-existing-tool", cancellationToken: CancellationToken.None)).Dump();

public class Reporter : IProgress&lt;ProgressNotificationValue&gt;
{
    public void Report(ProgressNotificationValue value)
    {
        value.Dump();
    }
}
</code></pre>
<h4 id="服务端-server">服务端 (Server)</h4>
<p>服务端代码定义了几个可供客户端调用的工具（Tool），并处理 MCP 请求。</p>
<pre><code class="language-csharp">// 需要安装NuGet包：ModelContextProtocol.AspNetCore 0.3.0-preview.3
var builder = WebApplication.CreateBuilder();

builder.Logging.AddConsole(consoleLogOptions =&gt;
{
    // Configure all logs to go to stderr
    consoleLogOptions.LogToStandardErrorThreshold = LogLevel.Trace;
});
builder.Services
    .AddHttpContextAccessor()
    .AddMcpServer()
    .WithHttpTransport(c =&gt; c.Stateless = true) // 注意这里！
    .WithTools&lt;Tools&gt;();
var app = builder.Build();

app.MapMcp();
await app.RunAsync(QueryCancelToken);

[McpServerToolType]
public class Tools(IHttpContextAccessor http)
{
    [McpServerTool, Description("Echoes the message back to the client.")]
    public string Echo(string message) =&gt; $"hello {message}";

    [McpServerTool, Description("Returns the IP address of the client.")]
    public string EchoIP() =&gt; http.HttpContext?.Connection.RemoteIpAddress?.ToString() ?? "Unknown";

    [McpServerTool, Description("Counts from 0 to n, reporting progress at each step.")]
    public async Task&lt;int&gt; Count(int n, IProgress&lt;ProgressNotificationValue&gt; progress)
    {
        for (int i = 0; i &lt; n; ++i)
        {
            progress.Report(new ProgressNotificationValue()
            {
                Progress = i,
                Total = n,
                Message = $"Step {i} of {n}",
            });
            await Task.Delay(100);
        }
        return n;
    }

    [McpServerTool, Description("Throws an exception for testing purposes.")]
    public string TestThrow()
    {
        throw new Exception("This is a test exception");
    }
}
</code></pre>
<blockquote>
<p><strong>特别注意</strong>：在我的服务端示例中，我明确指定了 <code>.WithHttpTransport(c =&gt; c.Stateless = true)</code>。这代表我使用的是<strong>无状态</strong>的HTTP传输方式。MCP目前默认是有状态的，如果使用有状态模式，具体的请求和响应格式会略有不同。本文的分析全部基于此处的无状态模式。</p>
</blockquote>
<h3 id="第一部分初始化握手">第一部分：初始化握手</h3>
<p>MCP的连接始于一个分为两步的初始化过程，我们可以称之为“协商”与“确认”。</p>
<h4 id="1-协商-negotiation">1. 协商 (Negotiation)</h4>
<p>客户端首先向服务器发送一个<code>initialize</code>方法的JSON-RPC请求。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {},
    "clientInfo": {
      "name": "LINQPad.ScriptHost",
      "version": "1.0.0.0"
    }
  },
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p>这个请求告诉服务器：客户端期望使用<code>2025-06-18</code>版本的协议，并附上了自己的身份信息。</p>
<p>服务器收到后，会返回一个 <strong>Server-Sent Events (SSE)</strong> 响应。这个响应中包含一个关键的HTTP头 <code>Mcp-Session-Id</code>，以及对初始化请求的回复。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 01:57:01 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA

event: message
data: {"result":{"protocolVersion":"2025-06-18","capabilities":{"logging":{},"tools":{"listChanged":true}},"serverInfo":{"name":"LINQPad.ScriptHost","version":"1.0.0.0"}},"id":1,"jsonrpc":"2.0"}

</code></pre>
<p>从响应中可以看到，服务器同意使用<code>2025-06-18</code>协议版本，并返回了自己的能力（<code>capabilities</code>）。最重要的是，它提供了一个唯一的会话ID <code>Mcp-Session-Id</code>，这个ID将用于后续的所有通信。</p>
<h4 id="2-确认-confirmation">2. 确认 (Confirmation)</h4>
<p>拿到会话ID后，客户端会发送第二个请求，这次是<code>notifications/initialized</code>通知，用于确认初始化。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "notifications/initialized",
  "params": {},
  "jsonrpc": "2.0"
}
</code></pre>
<p>这个请求在HTTP头中带上了上一步获取的<code>Mcp-Session-Id</code>和双方商定的<code>MCP-Protocol-Version</code>。</p>
<p>服务器收到后，会再次返回一个SSE响应，内容与第一次类似，标志着握手完成，会话正式建立。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 01:57:01 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA

event: message
data: {"result":{"protocolVersion":"2025-06-18","capabilities":{"logging":{},"tools":{"listChanged":true}},"serverInfo":{"name":"LINQPad.ScriptHost","version":"1.0.0.0"}},"id":1,"jsonrpc":"2.0"}

</code></pre>
<h4 id="深度解析为何需要两步初始化">深度解析：为何需要两步初始化？</h4>
<p>你可能会问，为什么设计如此复杂的两步初始化过程？</p>
<p>根本原因在于，这是一个健壮且灵活的协议设计模式，其核心思想是<strong>分离“协商”与“确认”</strong>。这确保了客户端和服务器在开始正式数据交换前，就所有关键参数（如协议版本、会话ID、双方能力等）达成完全一致。</p>
<ul>
<li><strong>第一步 <code>initialize</code> (协商阶段)</strong>：客户端发起提议，服务器响应提议、确定通信参数并创建会话，返回会话ID（<code>Mcp-Session-Id</code>）。此时，双方只是达成了“如何沟通”的共识。</li>
<li><strong>第二步 <code>initialized</code> (确认阶段)</strong>：客户端使用会话ID和协议版本发起确认，告诉服务器：“我已经收到你的响应，并准备好按商定的规则开始通信了。”</li>
</ul>
<p>这种设计的必要性体现在：</p>
<ol>
<li><strong>避免竞态条件 (Race Conditions)</strong>：如果没有第二步确认，客户端可能在收到<code>initialize</code>响应后立即发送业务请求，但此时服务器可能还未完全准备好。第二步就像一个明确的同步信号。</li>
<li><strong>保证状态一致性</strong>：类似TCP的三次握手，这种模式确保了通信双方对会话状态的认知完全一致，为后续的稳定通信奠定基础。</li>
<li><strong>灵活性和扩展性</strong>：该设计允许在协商阶段加入更复杂的逻辑。例如，服务器可以要求客户端在确认前完成某些额外设置。</li>
</ol>
<p>简单类比一下，这就像一个正式的电话会议：</p>
<ol>
<li><strong>第一步 (initialize)</strong>: 你打电话：“你好，我是张三，能现在开会讨论项目A吗？” 对方回答：“可以，我是李四。我们就用中文讨论，会议号是12345。”</li>
<li><strong>第二步 (initialized)</strong>: 你说：“好的，收到，会议号12345，我们正式开始吧。”</li>
</ol>
<p>没有第二步，对方就无法确定你是否已准备就绪。总之，MCP通过两步初始化，实现了一个<strong>可靠、同步且灵活的握手过程</strong>。</p>
<h3 id="第二部分方法确认-get请求">第二部分：方法确认 (GET请求)</h3>
<p>在初始化完成后，SDK可能会尝试发送一个<code>GET</code>请求来确认连接。</p>
<pre><code class="language-http">GET / HTTP/1.1
Host: localhost:5000
Accept: text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA
MCP-Protocol-Version: 2025-06-18
</code></pre>
<p>然而，在我使用的 <code>ModelContextProtocol.AspNetCore 0.3.0-preview.3</code> 版本中，服务端并未实现对<code>GET</code>请求的处理逻辑。因此，服务器返回了 <code>HTTP 405 Method Not Allowed</code>，并在 <code>Allow</code> 头中明确指出只支持 <code>POST</code>。</p>
<pre><code class="language-http">HTTP/1.1 405 Method Not Allowed
Content-Length: 0
Date: Mon, 21 Jul 2025 01:57:01 GMT
Server: Kestrel
Allow: POST
</code></pre>
<h3 id="第三部分正常通信">第三部分：正常通信</h3>
<p>握手成功后，客户端和服务端就可以开始真正的数据交换了。所有业务请求都通过<code>POST</code>方法进行。</p>
<h4 id="1-列出可用工具">1. 列出可用工具</h4>
<p>首先，我们发送一个 <code>tools/list</code> 请求来获取服务端提供的所有工具。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "tools/list",
  "params": {},
  "id": 2,
  "jsonrpc": "2.0"
}
</code></pre>
<p>服务器返回一个SSE消息，<code>data</code>字段中包含了工具列表的JSON数组，每个工具都有名称、描述和输入参数的Schema。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 01:57:01 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7__UKHVt_9PM30T9KfWqDcHrSQUy3f34bIXzMKW-r2xhMrKclIQijzdY8FIWAAMLXnHVpWepSgNmZ02LKSIgsThMwffivlsALrlt_5PBExlLXRZo59M7NL3sDmWf22zTLPGymVcJHKk_lPOvSxV5ClxspnQbKLx-XgqPCAU6yt6D2E060A-fJoZ_vYNqpYe08bXkTvOdsvCrbweWBcsdL1cABx5jwfypX1CuZkcbuTUA

event: message
data: {"result":{"tools":[{"name":"echo","description":"Echoes the message back to the client.","inputSchema":{"type":"object","properties":{"message":{"type":"string"}},"required":["message"]}},{"name":"test_throw","description":"Throws an exception for testing purposes.","inputSchema":{"type":"object","properties":{}}},{"name":"count","description":"Counts from 0 to n, reporting progress at each step.","inputSchema":{"type":"object","properties":{"n":{"type":"integer"}},"required":["n"]}},{"name":"echo_ip","description":"Returns the IP address of the client.","inputSchema":{"type":"object","properties":{}}}]},"id":2,"jsonrpc":"2.0"}

</code></pre>
<h4 id="2-调用简单工具-echo">2. 调用简单工具 (<code>echo</code>)</h4>
<p>接下来，我们调用 <code>echo</code> 工具。请求的 <code>method</code> 为 <code>tools/call</code>，<code>params</code> 中指定了工具名称和参数。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij52NgZZYYWNIR0QjlQMp-3gHqqQtWdqoCun83RIwOM6LbD-qaJs4wCuiWspDO0LfV39fueDbONZIRWdm8iEsSrFQTAgsgBkxNtsUqlHDtbPvnkFNScCfVtzljqHOc9xfiuxHaBGoLaQJFxWM98Ko9aLy7FcWEeKEOuyvYg7biTtdjyYzyFwZ3ijmP2UBC0mzbP7SrW2Kdu58E1i2MMF3y2p7XHmkaPL6RuOOWSFfwCTeA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "tools/call",
  "params": {
    "name": "echo",
    "arguments": {
      "message": ".NET is awesome!"
    }
  },
  "id": 3,
  "jsonrpc": "2.0"
}
</code></pre>
<p>服务器返回结果，<code>result.content</code> 字段包含了工具的输出。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 02:28:19 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij52NgZZYYWNIR0QjlQMp-3gHqqQtWdqoCun83RIwOM6LbD-qaJs4wCuiWspDO0LfV39fueDbONZIRWdm8iEsSrFQTAgsgBkxNtsUqlHDtbPvnkFNScCfVtzljqHOc9xfiuxHaBGoLaQJFxWM98Ko9aLy7FcWEeKEOuyvYg7biTtdjyYzyFwZ3ijmP2UBC0mzbP7SrW2Kdu58E1i2MMF3y2p7XHmkaPL6RuOOWSFfwCTeA

event: message
data: {"result":{"content":[{"type":"text","text":"hello .NET is awesome!"}]},"id":3,"jsonrpc":"2.0"}

</code></pre>
<h4 id="3-调用带进度报告的工具-count">3. 调用带进度报告的工具 (<code>count</code>)</h4>
<p>MCP的一个强大功能是支持进度报告。我们通过调用 <code>count</code> 工具来演示。注意，请求的<code>params</code>中增加了一个 <code>_meta</code> 字段，其中包含一个客户端生成的 <code>progressToken</code>。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij52NgZZYYWNIR0QjlQMp-3gHqqQtWdqoCun83RIwOM6LbD-qaJs4wCuiWspDO0LfV39fueDbONZIRWdm8iEsSrFQTAgsgBkxNtsUqlHDtbPvnkFNScCfVtzljqHOc9xfiuxHaBGoLaQJFxWM98Ko9aLy7FcWEeKEOuyvYg7biTtdjyYzyFwZ3ijmP2UBC0mzbP7SrW2Kdu58E1i2MMF3y2p7XHmkaPL6RuOOWSFfwCTeA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "tools/call",
  "params": {
    "name": "count",
    "arguments": {
      "n": 5
    },
    "_meta": {
      "progressToken": "9021fd27304a48e8ada90e35a66bc1dd"
    }
  },
  "id": 4,
  "jsonrpc": "2.0"
}
</code></pre>
<p>这次，服务器的SSE响应是一个<strong>事件流</strong>。它会陆续发送多个 <code>event: message</code>，其中包含了进度更新。这些进度通知的<code>method</code>是<code>notifications/progress</code>，并通过 <code>progressToken</code> 与原始请求关联。当任务完成后，最后一条消息才包含最终的<code>result</code>。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 02:28:19 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij52NgZZYYWNIR0QjlQMp-3gHqqQtWdqoCun83RIwOM6LbD-qaJs4wCuiWspDO0LfV39fueDbONZIRWdm8iEsSrFQTAgsgBkxNtsUqlHDtbPvnkFNScCfVtzljqHOc9xfiuxHaBGoLaQJFxWM98Ko9aLy7FcWEeKEOuyvYg7biTtdjyYzyFwZ3ijmP2UBC0mzbP7SrW2Kdu58E1i2MMF3y2p7XHmkaPL6RuOOWSFfwCTeA

event: message
data: {"method":"notifications/progress","params":{"progressToken":"9021fd27304a48e8ada90e35a66bc1dd","progress":0,"total":5,"message":"Step 0 of 5"},"jsonrpc":"2.0"}

event: message
data: {"method":"notifications/progress","params":{"progressToken":"9021fd27304a48e8ada90e35a66bc1dd","progress":1,"total":5,"message":"Step 1 of 5"},"jsonrpc":"2.0"}

event: message
data: {"method":"notifications/progress","params":{"progressToken":"9021fd27304a48e8ada90e35a66bc1dd","progress":2,"total":5,"message":"Step 2 of 5"},"jsonrpc":"2.0"}

event: message
data: {"method":"notifications/progress","params":{"progressToken":"9021fd27304a48e8ada90e35a66bc1dd","progress":3,"total":5,"message":"Step 3 of 5"},"jsonrpc":"2.0"}

event: message
data: {"method":"notifications/progress","params":{"progressToken":"9021fd27304a48e8ada90e35a66bc1dd","progress":4,"total":5,"message":"Step 4 of 5"},"jsonrpc":"2.0"}

event: message
data: {"result":{"content":[{"type":"text","text":"5"}]},"id":4,"jsonrpc":"2.0"}

</code></pre>
<h3 id="第四部分异常与错误处理">第四部分：异常与错误处理</h3>
<p>一个健壮的协议必须能优雅地处理各种意外情况。MCP协议通过两种不同的方式来报告错误，我们通过调用 <code>test_throw</code>（在服务端会主动抛出异常）和调用一个不存在的工具 <code>not-existing-tool</code> 来观察这两种机制。</p>
<h4 id="4-工具执行时抛出异常-test_throw">4. 工具执行时抛出异常 (<code>test_throw</code>)</h4>
<p>现在，我们调用那个被设计为一定会失败的 <code>test_throw</code> 工具。</p>
<p><strong>请求 (Request)</strong></p>
<p>请求本身与调用普通工具无异，它遵循标准的 <code>tools/call</code> 格式。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7KnxH5A76vXaHfcu5WUlT2qwOcZKw7FC0F8iyfmDU4-weDzJNcH1AjCirhnrqpCjAXI52umwTrb8y7K4rEnuC-l89Frm26vXrg06cNEySoeTevw6g_SYt7fJRu-1vb3OprOeeUjJMQUJH4v5sf__UMpAkO9caBvjxc1Qiqko2Fy0UiB_gCq0jsTQ_keGq_kfDqD9LUSj41LLfUboRlnln4_xWhQ8jLmbNvDiR5F6B9LA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "tools/call",
  "params": {
    "name": "test_throw"
  },
  "id": 5,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>响应 (Response)</strong></p>
<p>这是有趣的地方。服务器返回的HTTP状态码依然是 <code>200 OK</code>，表示HTTP通信本身是成功的。然而，响应体内的JSON-RPC报文揭示了真实情况。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 03:17:20 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7KnxH5A76vXaHfcu5WUlT2qwOcZKw7FC0F8iyfmDU4-weDzJNcH1AjCirhnrqpCjAXI52umwTrb8y7K4rEnuC-l89Frm26vXrg06cNEySoeTevw6g_SYt7fJRu-1vb3OprOeeUjJMQUJH4v5sf__UMpAkO9caBvjxc1Qiqko2Fy0UiB_gCq0jsTQ_keGq_kfDqD9LUSj41LLfUboRlnln4_xWhQ8jLmbNvDiR5F6B9LA

event: message
data: {"result":{"content":[{"type":"text","text":"An error occurred invoking 'test_throw'."}],"isError":true},"id":5,"jsonrpc":"2.0"}
</code></pre>
<p><strong>深度解析：</strong></p>
<p>请注意，JSON-RPC报文返回的<strong>不是</strong>一个顶级的 <code>error</code> 对象，而是一个 <code>result</code> 对象。这说明从JSON-RPC协议的层面来看，这次调用是“成功”的。但是，<code>result</code> 对象内部增加了一个关键字段：<code>"isError": true</code>。</p>
<p>这是一种精巧的设计：它区分了<strong>协议层面的错误</strong>和<strong>业务逻辑层面的错误</strong>。</p>
<ul>
<li><strong>协议层面</strong>：客户端的请求格式正确，服务器也找到了名为 <code>test_throw</code> 的工具并成功尝试执行它。因此，JSON-RPC的交互流程是完整的。</li>
<li><strong>业务逻辑层面</strong>：工具在执行期间内部发生了未捕获的异常。MCP服务端捕获了这个异常，并将其封装成一个“错误结果”返回。<code>isError: true</code> 就是一个明确的信号，告诉客户端：“我尝试执行了，但工具自己出错了”。</li>
</ul>
<p>这种方式让客户端可以统一处理所有 <code>tools/call</code> 的响应，然后通过检查 <code>isError</code> 标志来判断工具的执行是否真正成功。</p>
<h4 id="5-调用不存在的工具">5. 调用不存在的工具</h4>
<p>接下来，我们尝试调用一个从未在服务端定义过的工具：<code>not-existing-tool</code>。</p>
<p><strong>请求 (Request)</strong></p>
<p>请求结构依然是标准的 <code>tools/call</code>。</p>
<pre><code class="language-http">POST / HTTP/1.1
Host: localhost:5000
Accept: application/json, text/event-stream
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7KnxH5A76vXaHfcu5WUlT2qwOcZKw7FC0F8iyfmDU4-weDzJNcH1AjCirhnrqpCjAXI52umwTrb8y7K4rEnuC-l89Frm26vXrg06cNEySoeTevw6g_SYt7fJRu-1vb3OprOeeUjJMQUJH4v5sf__UMpAkO9caBvjxc1Qiqko2Fy0UiB_gCq0jsTQ_keGq_kfDqD9LUSj41LLfUboRlnln4_xWhQ8jLmbNvDiR5F6B9LA
MCP-Protocol-Version: 2025-06-18
Transfer-Encoding: chunked
Content-Type: application/json; charset=utf-8

{
  "method": "tools/call",
  "params": {
    "name": "not-existing-tool"
  },
  "id": 6,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>响应 (Response)</strong></p>
<p>这次的响应与上一个场景截然不同。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/event-stream
Date: Mon, 21 Jul 2025 03:17:20 GMT
Server: Kestrel
Cache-Control: no-cache,no-store
Content-Encoding: identity
Transfer-Encoding: chunked
Mcp-Session-Id: CfDJ8PaF_EVr9adHn4ULGk-4ij7KnxH5A76vXaHfcu5WUlT2qwOcZKw7FC0F8iyfmDU4-weDzJNcH1AjCirhnrqpCjAXI52umwTrb8y7K4rEnuC-l89Frm26vXrg06cNEySoeTevw6g_SYt7fJRu-1vb3OprOeeUjJMQUJH4v5sf__UMpAkO9caBvjxc1Qiqko2Fy0UiB_gCq0jsTQ_keGq_kfDqD9LUSj41LLfUboRlnln4_xWhQ8jLmbNvDiR5F6B9LA

event: message
data: {"error":{"code":-32602,"message":"Unknown tool: 'not-existing-tool'"},"id":6,"jsonrpc":"2.0"}
</code></pre>
<p><strong>深度解析：</strong></p>
<p>看到区别了吗？这次的响应体直接包含了一个顶级的 <code>error</code> 对象，完全符合JSON-RPC 2.0的错误响应规范。</p>
<ul>
<li><code>"code": -32602</code>：这是JSON-RPC的一个标准错误码，代表 “Invalid params” (无效参数)。在这里，服务端认为<code>tools/call</code>方法中的<code>name</code>参数值<code>"not-existing-tool"</code>是无效的，因为找不到对应的工具。</li>
<li><code>"message": "Unknown tool: 'not-existing-tool'"</code>：提供了人类可读的错误描述。</li>
</ul>
<p>这被视为一个<strong>协议层面的错误</strong>，因为客户端请求执行一个从服务器视角看根本不存在的方法（或资源）。服务器甚至都无法开始“执行工具”这个业务逻辑，因为它在第一步——查找工具时——就失败了。因此，它直接返回一个标准的JSON-RPC错误，终止了这次调用。</p>
<h3 id="总结">总结</h3>
<p>通过以上的抓包分析，我们可以清晰地总结出（无状态）MCP协议的核心通信模式：</p>
<ol>
<li><strong>协议基础</strong>：MCP构建在 <strong>JSON-RPC 2.0</strong> 之上，通过 HTTP <code>POST</code> 请求进行交互。</li>
<li><strong>会话管理</strong>：通过一个健壮的<strong>两步握手</strong>（<code>initialize</code> 和 <code>initialized</code>）来建立会话，并使用 <code>Mcp-Session-Id</code> HTTP头来标识和维持该会话。</li>
<li><strong>响应机制</strong>：服务端使用 <strong>Server-Sent Events (SSE)</strong> (<code>Content-Type: text/event-stream</code>) 来响应客户端。这种方式天然支持流式数据，非常适合长任务的进度报告。</li>
<li><strong>数据格式</strong>：无论是请求的<code>body</code>还是SSE返回的<code>data</code>部分，都遵循JSON-RPC 2.0的报文结构 (<code>{"jsonrpc": "2.0", "method": "...", "params": ..., "id": ...}</code> 或 <code>{"jsonrpc": "2.0", "result": ..., "id": ...}</code>）。</li>
<li><strong>错误处理</strong>：MCP协议区分了两种错误。<strong>协议层面的错误</strong>（如调用不存在的工具）会返回标准的JSON-RPC <code>error</code>对象。而<strong>工具执行期间的业务逻辑错误</strong>则通过在成功的 <code>result</code> 对象中附加 <code>isError: true</code> 标志来表示，实现了协议与业务的分离。</li>
</ol>
<p>希望本文能帮助你彻底搞懂MCP的底层通信原理。掌握了这些，你不仅能更好地使用官方SDK，甚至可以在不支持的语言或环境中实现自己的MCP客户端或服务端。</p>
<hr>
<p>感谢您的阅读，如果您有任何问题或想法，欢迎在评论区留言讨论。</p>
<p>也欢迎加入我们的 <strong>.NET骚操作</strong> QQ群一起探讨：<strong>495782587</strong></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-22 08:45">2025-07-22 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/sdcb">.NET骚操作</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18995424);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18995424', targetLink: 'https://www.cnblogs.com/sdcb/p/18995424/mcp-http-insights', title: '官方文档没告诉你的：通过抓包，深入揭秘MCP协议底层通信' })">举报</a>
</div>
        