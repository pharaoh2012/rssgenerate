
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/18651734" title="发布于 2025-01-04 11:49">
    <span role="heading" aria-level="2">itextpdf 找出PDF中 文字的坐标</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#添加引用" rel="noopener nofollow">添加引用</a></li><li><a href="#添加工具类" rel="noopener nofollow">添加工具类</a></li><li><a href="#调用" rel="noopener nofollow">调用</a></li></ul></div><br>
找到位置，签名的话见：<a href="https://www.cnblogs.com/vipsoft/p/18644127" target="_blank">https://www.cnblogs.com/vipsoft/p/18644127</a><p></p>
<p>新项目可以尝试一下 iText 7 , 我这边是老项目所以还是继续使用 iText 5，主打够用<br>
iText 5 没有直接提供获取文本精确位置的功能。它只能提取文本内容，而文本位置通常需要通过额外的解析和计算来确定。</p>
<p>思路：在同一行，且一些词是连续的，前后没有空白字符串，即认为是一个词<br>
需要特殊处理：</p>
<ul>
<li>“姓 名：” 中间有空格</li>
<li>读取PDF时，有些肉眼看上去是一行的字，可能会被解析为多个，导致找不到满足条件的关键字</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/80824/202501/80824-20250104114813101-1955422589.png" alt="image" loading="lazy"></p>
<h3 id="添加引用">添加引用</h3>
<pre><code class="language-xml">&lt;itextpdf.version&gt;5.5.13&lt;/itextpdf.version&gt;
&lt;itext-asian.version&gt;5.2.0&lt;/itext-asian.version&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
    &lt;artifactId&gt;itextpdf&lt;/artifactId&gt;
    &lt;version&gt;${itextpdf.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--没有这个的话，添加文字会报错--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
    &lt;artifactId&gt;itext-asian&lt;/artifactId&gt;
    &lt;version&gt;${itext-asian.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="添加工具类">添加工具类</h3>
<pre><code class="language-java">package com.vipsoft.web;

import cn.hutool.core.util.StrUtil;
import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.RenderListener;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.awt.geom.Rectangle2D.Float;

import java.util.ArrayList;
import java.util.List;


public class KeyWordPositionListener implements RenderListener {

    /**
     * 用来存储页面上所有的词
     * - 排除连续空格
     */
    private List&lt;WordItem&gt; allItems = new ArrayList&lt;WordItem&gt;();

    /**
     * 搜索关键词
     */
    private String keyWord;
    /**
     * 是否是新的词
     */
    private boolean newWord = false;
    /**
     * 记录上一个字符 -- 用于判断是否是一组词
     */
    private WordItem prevItem = new WordItem();

    /**
     * 已找到的词信息
     */
    private WordItem wordItem;

    public WordItem getWordItem() {
        return wordItem;
    }

    public void setKeyWord(String keyWord) {
        this.keyWord = keyWord;
    }

    @Override
    public void beginTextBlock() {
        // TODO Auto-generated method stub
    }

    /**
     * 方法会在解析文本时被调用，它检查每个文本片段是否包含关键词，并记录其位置。
     *
     * @param renderInfo
     */
    @Override
    public void renderText(TextRenderInfo renderInfo) {
        if (wordItem != null || StrUtil.isEmpty(keyWord)) {
            return;
        }
        // 读取PDF时，有些肉眼看上去是一行的字，可能会被解析为多个，导致找不到满足条件的关键字，这里做了简单的处理
        // 即如果一些词是连续的，前后没有空白字符串，即认为是一个词
        String content = renderInfo.getText().trim();
        Float textRectangle = renderInfo.getBaseline().getBoundingRectange();
        if (StrUtil.isEmpty(content)) {
            // 当前扫出来的是空字符串，视新一个新的词即将开始
            newWord = true;
//            System.out.println("扫出空的，跳过  x=" + textRectangle.getX() + " y=" + textRectangle.getY());
            return;
        }
        if (StrUtil.isEmpty(prevItem.getContent())) {
            // 这段可以不需要
            // prevItem 中还没有存内容的，当前文字也视为新的词
            newWord = true;
//            System.out.println("prevItem 中还没有存内容的，视为新词");
        }
        if (StrUtil.isNotEmpty(prevItem.getContent()) &amp;&amp; (Math.abs((int) prevItem.getY() - (int) textRectangle.getY()) &gt; 5)) {
            //Y 正负2内，视为同一行
            System.out.println("不在同一行：prevItem=" + prevItem.getContent() + " x=" + (int) prevItem.getX() + " y=" + (int) prevItem.getY());
            System.out.println("不在同一行：content=" + content + " x=" + (int) textRectangle.getX() + " y=" + (int) textRectangle.getY());
            System.out.println("当前内容和prevItem 不在同一行，视为新词");
            newWord = true;
        }
        if (newWord) {
            //重置
            System.out.println("重置 prevItem: " + prevItem.getContent());
            prevItem = new WordItem();
        }
        System.out.println("已扫到字：content=" + content + " x=" + textRectangle.getX() + " y=" + textRectangle.getY());
        String preContent = StrUtil.isNotEmpty(prevItem.getContent()) ? prevItem.getContent() : "";
        prevItem.setContent(preContent + content);
        prevItem.setX(textRectangle.getX());
        prevItem.setY(textRectangle.getY());
        if (prevItem.getContent().contains(keyWord)) {
            //System.out.println("找到了【" + keyWord + "】 " + prevItem.getContent() + " x= " + prevItem.getX() + " y= " + prevItem.getY());
            wordItem = prevItem;
        }
        newWord = false;
    }

    @Override
    public void endTextBlock() {
        // TODO Auto-generated method stub
    }

    @Override
    public void renderImage(ImageRenderInfo renderInfo) {
        // TODO Auto-generated method stub
    }

}

/**
 * 存储一个词的信息
 */
class WordItem {
    private String content;
    private double x;
    private double y;

   ... getters and setters ...
}
</code></pre>
<h3 id="调用">调用</h3>
<pre><code class="language-java">@Test
void searchText() throws Exception {
    String filepath = "D:\\Report.pdf";
    String keyWord = "审核医生";
    int page = 1;
    PdfReader pdfReader = new PdfReader(filepath);
    //int pageNum = pdfReader.getNumberOfPages(); //循环没页PDF查找
    PdfReaderContentParser pdfReaderContentParser = new PdfReaderContentParser(pdfReader);
    KeyWordPositionListener renderListener = new KeyWordPositionListener();
    renderListener.setKeyWord(keyWord);
    pdfReaderContentParser.processContent(page, renderListener);
    WordItem wordItem = renderListener.getWordItem();
    if (wordItem == null) {
        System.out.println("没找到 " + keyWord);
        return;
    }
    System.out.println("找到了【" + keyWord + "】 " + wordItem.getContent() + " x= " + wordItem.getX() + " y= " + wordItem.getY());
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/18651734" target="_blank">https://www.cnblogs.com/vipsoft/p/18651734</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8866296699039352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-04 11:50">2025-01-04 11:49</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">116</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18651734" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18651734);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18651734', targetLink: 'https://www.cnblogs.com/vipsoft/p/18651734', title: 'itextpdf 找出PDF中 文字的坐标' })">举报</a>
</div>
        