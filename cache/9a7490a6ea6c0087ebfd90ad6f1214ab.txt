
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/19009022" title="发布于 2025-07-28 15:34">
    <span role="heading" aria-level="2">Django缓存机制详解：从配置到实战应用</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250728153423394-1759742944.png" alt="Django缓存机制详解：从配置到实战应用" class="desc_img">
        本文介绍了 Django 缓存机制的基础知识与实战应用，涵盖缓存概念、Redis 安装配置、缓存策略及 API 使用，并通过 RBAC 权限系统演示缓存的读写与删除操作，助力提升 Web 应用性能。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一缓存基础与环境准备">一、缓存基础与环境准备</h2>
<h3 id="什么是缓存">什么是缓存？</h3>
<p>缓存是指保存计算密集型操作的结果，当再次需要该结果时直接从缓存中获取，而无需重新计算。在 Django 中，缓存可以应用于不同粒度：</p>
<ul>
<li>整个网站缓存</li>
<li>特定视图缓存</li>
<li>页面片段缓存</li>
<li>任意 Python 对象缓存</li>
</ul>
<h3 id="安装redis">安装Redis</h3>
<p>Django 支持多种缓存后端，其中 Redis 因其高性能和丰富的特性成为常用选择。</p>
<ul>
<li>安装Redis：过程略</li>
<li>安装 Redis 客户端</li>
</ul>
<pre><code class="language-sh">pip install redis
</code></pre>
<h3 id="redis-缓存配置">Redis 缓存配置</h3>
<p>在 Django 项目的<code>settings.py</code>文件中，通过<code>CACHES</code>配置项设置 Redis 缓存后端。</p>
<ul>
<li><code>TIMEOUT</code>：默认缓存超时时间（秒），默认为 300 秒（5 分钟）</li>
<li><code>OPTIONS</code>：传递给缓存后端的选项</li>
<li><code>KEY_PREFIX</code>：所有缓存键的前缀字符串</li>
<li><code>VERSION</code>：缓存键的默认版本号</li>
<li><code>KEY_FUNCTION</code>：定义缓存键生成规则的函数路径</li>
</ul>
<pre><code class="language-python">CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": "redis://password@127.0.0.1:6379",
        "OPTIONS": {
            "db": 0,
        },
        "KEY_PREFIX": "mars_framework",  # 缓存前缀
        "TIMEOUT": 60 * 60 * 12,  # 缓存过期时间，单位为秒
    }
}
</code></pre>
<h2 id="二缓存使用策略">二、缓存使用策略</h2>
<h3 id="站点缓存不常用">站点缓存（不常用）</h3>
<p>缓存整个站点是最简单的缓存方式，适用于内容不常变化的网站。配置方式如下（在<code>settings.py</code>的<code>MIDDLEWARE</code>中添加缓存中间件）</p>
<pre><code class="language-python">MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',  # 放在最前面
    # 其他中间件...
    'django.middleware.cache.FetchFromCacheMiddleware',  # 放在最后面
]
</code></pre>
<h3 id="视图缓存">视图缓存</h3>
<p>针对特定视图进行缓存是更灵活的方式，适用于不同视图有不同更新频率的场景。</p>
<p>使用装饰器缓存视图</p>
<pre><code class="language-python">from django.views.decorators.cache import cache_page

@cache_page(60 * 15)  # 缓存15分钟
def my_view(request):
    # 视图逻辑...

</code></pre>
<p>视图缓存的特点</p>
<ul>
<li>以 URL 为缓存键，不同 URL 指向同一视图会分别缓存</li>
<li>示例：<code>/foo/1/</code>和<code>/foo/23/</code>会被分别缓存</li>
</ul>
<pre><code class="language-python">urlpatterns = [
    path("foo/&lt;int:code&gt;/", my_view),
]
</code></pre>
<p>自定义缓存前缀：可以为不同视图设置不同的缓存前缀</p>
<pre><code class="language-python">@cache_page(60 * 15, key_prefix="site1")
def my_view(request):
    ...
</code></pre>
<p>在 URLconf 中配置缓存</p>
<pre><code class="language-python">from django.views.decorators.cache import cache_page

urlpatterns = [
    path("foo/&lt;int:code&gt;/", cache_page(60 * 15)(my_view)),
]
</code></pre>
<h2 id="三缓存api详解">三、缓存API详解</h2>
<p>当需要更精细的缓存控制时，可以使用 Django 提供的缓存 API，直接操作缓存中的数据。</p>
<h3 id="导入缓存模块">导入缓存模块</h3>
<pre><code class="language-python">from django.core.cache import cache
</code></pre>
<h3 id="基本操作">基本操作</h3>
<p>设置缓存</p>
<pre><code class="language-python"># 语法：cache.set(key, value, timeout=默认超时, version=None)
cache.set('my_key', 'hello, world!', 30)  # 缓存30秒
</code></pre>
<p>获取缓存</p>
<pre><code class="language-python"># 语法：cache.get(key, default=None, version=None)
value = cache.get('my_key')  # 获取缓存值，如果不存在返回None
value = cache.get('my_key', 'default_value')  # 指定默认值
</code></pre>
<p>新增缓存（仅当键不存在时）</p>
<pre><code class="language-python"># 如果键不存在则添加，返回布尔值表示是否成功
success = cache.add("add_key", "Initial value")
</code></pre>
<p>获取或设置缓存</p>
<pre><code class="language-python"># 如果键存在则获取，否则设置并返回默认值
value = cache.get_or_set("my_new_key", "my new value", 100)
</code></pre>
<p>删除缓存</p>
<pre><code class="language-python"># 删除指定键，返回布尔值表示是否成功
success = cache.delete("a")
</code></pre>
<p>更新缓存过期时间</p>
<pre><code class="language-python"># 为已有键设置新的过期时间
success = cache.touch("a", 10)  # 新超时时间10秒
</code></pre>
<h2 id="四缓存实战">四、缓存实战</h2>
<h3 id="场景说明">场景说明</h3>
<p>RBAC（Role-Based Access Control，基于角色的访问控制）是一种广泛使用的权限管理模型。在 Django+Vue 实现的后台管理系统中，一般采用RBAC权限策略。使用缓存机制，避免重复计算用户<strong>权限标识集合</strong>。</p>
<h3 id="写入缓存">写入缓存</h3>
<p>用户成功登录后，前端自动调用获取登录用户的权限信息接口，获取登录用户的权限信息，包括</p>
<ul>
<li>用户基本信息 user</li>
<li>用户角色集合 roles</li>
<li>用户<strong>权限标识集合</strong> permissions</li>
<li>用户树状菜单集合 menus</li>
</ul>
<p>将计算后的上述权限信息，写入Redis缓存。同时返回给前端，生成动态菜单。</p>
<pre><code class="language-python">@extend_schema(tags=["管理后台-system-认证"])
class AuthViewSet(viewsets.GenericViewSet):
    serializer_class = AuthLoginSerializer
    queryset = SystemUsers.objects.none()

    @extend_schema(summary="获取登录用户的权限信息")
    @action(methods=["get"], detail=False, url_path="get-permission-info")
    def get_permission_info(self, request, *args, **kwargs):
        """获取登录用户的权限信息"""
        user_id = request.user.id
        cache_key = f"system_users_{user_id}"
        user = SystemUsers.objects.prefetch_related("roles", "roles__menus").get(
            id=user_id
        )
        serializer = AuthPermissionInfoSerializer(user, context={"request": request})
        cache.set(cache_key, serializer.data, timeout=None)
        return CommonResponse.success(data=serializer.data)
</code></pre>
<p><img alt="image-20250728143531737" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250728153308323-1467799781.png" class="lazyload"></p>
<h3 id="读取缓存">读取缓存</h3>
<p>用户执行某个API接口时，会进行权限判断。后端权限判断时，会从缓存中读取当前请求用户的<strong>权限标识集合</strong>，然后对比本次请求的权限标识（如 "system:post:query"）。如果包含在集合中，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p><img alt="image-20250623113039283" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202507/1565852-20250728153320059-10162074.png" class="lazyload"></p>
<p><a href="https://docs.marsmgn.cn/backend/backend-rbac" target="_blank" rel="noopener nofollow">点击查看RBAC权限原理</a></p>
<h3 id="删除缓存">删除缓存</h3>
<p>当用户退出登录时，删除用户的缓存信息</p>
<pre><code class="language-python">    @extend_schema(summary="登出系统")
    @action(
        methods=["post"],
        detail=False,
        url_path="logout",
        permission_classes=[AllowAny],
    )
    def logout(self, request, *args, **kwargs):
        """登出系统"""
        cache.delete(f"system_users_{request.user.id}")  # 清空用户Redis
        # ... 
</code></pre>
<p><a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/myapp_system/auth/views.py" target="_blank" rel="noopener nofollow">点击查看完整代码</a></p>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-28 15:35">2025-07-28 15:34</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">78</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19009022);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19009022', targetLink: 'https://www.cnblogs.com/xwz1024/p/19009022', title: 'Django缓存机制详解：从配置到实战应用' })">举报</a>
</div>
	