
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Can-daydayup/p/18798838" title="发布于 2025-03-29 08:00">
    <span role="heading" aria-level="2">C# 13 中的新增功能实操</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2 data-tool="mdnice编辑器"><span>前言</span></h2>
<p data-tool="mdnice编辑器"><span>今天大姚带领大家一起来看看 C# 13 中的新增几大功能，并了解其功能特性和实际应用场景。</span></p>
<ul>
<li><span style="color: rgba(0, 0, 255, 1)"><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247511601&amp;idx=1&amp;sn=974ec95cb0f1b247b3ecdefefb98cafb&amp;scene=21#wechat_redirect" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">C# 中比较实用的关键字，基础高频面试题！</span></a></span></li>
<li><span style="color: rgba(0, 0, 255, 1)"><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247511000&amp;idx=1&amp;sn=95a590f63dc27f714c1d6748c2c70dc0&amp;scene=21#wechat_redirect" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">互联网寒冬下，如何写好一份.NET求职简历？附带简洁简历模板和简历优化服务来了！！！</span></a></span></li>
</ul>
<h2 data-tool="mdnice编辑器"><span>前提准备</span></h2>
<p data-tool="mdnice编辑器"><span>要体验 C# 13 新增的功能可以使用最新的 Visual Studio 2022 版本或 .NET 9 SDK 尝试这些功能。</span></p>
<h3 data-tool="mdnice编辑器"><span>Visual Studio 2022安装</span></h3>
<ul class="list-paddingleft-1">
<li><span style="color: rgba(0, 0, 255, 1)"><a href="https://visualstudio.microsoft.com/zh-hans/downloads" target="_blank" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">https://visualstudio.microsoft.com/zh-hans/downloads</span></a></span></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202503/1336199-20250328213320260-1384718605.png" alt="" loading="lazy"></p>
<h3 data-tool="mdnice编辑器"><span>.NET 9 SDK</span></h3>
<ul class="list-paddingleft-1">
<li><span style="color: rgba(0, 0, 255, 1)"><a href="https://dotnet.microsoft.com/zh-cn/download/dotnet/9.0" target="_blank" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">https://dotnet.microsoft.com/zh-cn/download/dotnet/9.0</span></a></span></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202503/1336199-20250328213445951-411349395.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<h2 data-tool="mdnice编辑器"><span>params 集合</span></h2>
<p data-tool="mdnice编辑器"><span>在 C# 13 中，params 的改进使其从可变数量的数组参数升级为可变数量的集合类型参数。这一改进通过支持高性能集合类型（如<code><span>Span&lt;T&gt;、ReadOnlySpan&lt;T&gt;</span></code><span>）和简化调用语法，显著提升了代码的灵活性和效率。</span></span></p>
<blockquote>
<p><span>C# 13 中的 params 集合变得类型更灵活，满足更复杂的应用场景，并且性能得到了进一步的提升。</span></p>
</blockquote>
<h3 data-tool="mdnice编辑器"><span>在 C# 13 之前：</span></h3>
<p data-tool="mdnice编辑器"><span>params 仅支持一维数组（如<code><span>params int[] list</span></code><span>、<code><span>params object[] list</span></code><span>）。调用方法时需显式传递数组或数组元素类型的参数的逗号分隔列表。</span></span></span></p>
<h3 data-tool="mdnice编辑器"><span>在 C# 13 中：</span></h3>
<p data-tool="mdnice编辑器"><span>params 修饰符并不局限于数组类型。 现在可以将 params 用于任何已识别的集合类型，包括&nbsp;<code><span>System.Span&lt;T&gt;、System.ReadOnlySpan&lt;T&gt;</span></code><span>，以及那些实现&nbsp;<code><span>System.Collections.Generic.IEnumerable&lt;T&gt;</span></code><span>&nbsp;并具有 Add 方法的类型。 除了具体类型外，还可以使用接口&nbsp;<code><span>System.Collections.Generic.IEnumerable&lt;T&gt;、System.Collections.Generic.IReadOnlyCollection&lt;T&gt;、System.Collections.Generic.IReadOnlyList&lt;T&gt;、System.Collections.Generic.ICollection&lt;T&gt;和 System.Collections.Generic.IList&lt;T&gt;</span></code><span>。</span></span></span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void&nbsp;SpanDataPrintRun<span>()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Span&lt;int&gt; originalSpan = [1, 2, 3, 4, 5];<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpanDataPrint(originalSpan);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void SpanDataPrint&lt;T&gt;(params Span&lt;T&gt; spans)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for<span>&nbsp;(int i = 0; i &lt; spans.Length; i++)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine(spans[i]);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span>新增Lock锁对象</span></h2>
<p data-tool="mdnice编辑器"><span>.NET 9 包含一种新的用于互斥的&nbsp;<code><span>System.Threading.Lock</span></code><span>&nbsp;类型，比仅在任意&nbsp;<code><span>System.Object</span></code><span>&nbsp;实例上进行锁定更有效。该类型通过其 API 提供更好的线程同步，通过<code><span>Lock.EnterScope()</span></code><span>返回的<code><span>ref struct</span></code><span>自动管理锁的释放，减少死锁风险。</span></span></span></span></span></p>
<ul class="list-paddingleft-1">
<li>System.Threading.Lock类型提案：<span style="color: rgba(0, 0, 255, 1)"><a href="https://github.com/dotnet/runtime/issues/34812" target="_blank" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">https://github.com/dotnet/runtime/issues/34812</span></a></span></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202503/1336199-20250328213523579-2047288791.png" alt="" loading="lazy"></p>
<pre data-tool="mdnice编辑器"><code><span>&nbsp; &nbsp; &nbsp; &nbsp; private object _oldLock = new object();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; private System.Threading.Lock _newLock = new System.Threading.Lock();<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; public void&nbsp;LockTest<span>()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock (_oldLock)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("Old lock"<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock (_newLock)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 传统 lock 语法（优化版）<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (_newLock.EnterScope())<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;作用域自动释放（推荐写法）<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _newLock.Enter();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 显式 Enter/Exit 调用<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finally { _newLock.Exit(); }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(_newLock.TryEnter())<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 非阻塞尝试获取锁<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finally { _newLock.Exit(); }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h2 data-tool="mdnice编辑器"><span>新的转义序列</span></h2>
<p data-tool="mdnice编辑器"><span>新增&nbsp;<code><span>\e</span></code><span>&nbsp;转义字符作为&nbsp;<code><span>ESCAPE</span></code><span>&nbsp;字符&nbsp;<code><span>Unicode U+001B</span></code><span>&nbsp;的字符文本转义序列。以前，只能使用的是&nbsp;<code><span>\u001b</span></code><span>&nbsp;或&nbsp;<code><span>\x1b</span></code><span>。不建议使用<code><span>\x1b</span></code><span>，因为如果&nbsp;<code><span>1b</span></code><span>&nbsp;后面的下一个字符是有效的十六进制数字，则那些字符会成为转义序列的一部分。</span></span></span></span></span></span></span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void&nbsp;NewEscapeSequence<span>()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("[31m红色文本[0m"<span>);<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C# 13 之前<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("\u001b[31m红色文本\u001b[0m"<span>); //输出红色文字<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // C# 13 中<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("\e[31m红色文本\e[0m"<span>);//功能相同，语法更简洁<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202503/1336199-20250328213618444-314711359.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<h2 data-tool="mdnice编辑器"><span>方法组自然类型改进</span></h2>
<p data-tool="mdnice编辑器"><span>此功能对涉及方法组的重载解析进行了少量优化。方法组是一个方法，并且所有重载都具有相同的名称。 编译器以前的行为是为方法组构造完整的候选方法集。如果需要自然类型，则自然类型是根据整套候选方法确定的。</span></p>
<ul class="list-paddingleft-1">
<li><span>详细介绍：https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-13.0/method-group-natural-type-improvements</span></li>
</ul>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>// C# 13 中可以直接使用方法组并推断自然类型：<span><br><span>var a = Example.Method; // 成功推断为Action&lt;int&gt;（选择第一个匹配的委托类型）<span><br><span><br><span>// 通过上下文进一步优化推断：<span><br><span>List&lt;Action&lt;int&gt;&gt; actions =&nbsp;new<span>() { Example.Method }; // 根据集合类型推断为Action&lt;int&gt;<span><br><span><br></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span>隐式索引访问</span></h2>
<p data-tool="mdnice编辑器"><span>在C# 13中允许在对象初始化表达式中使用<code><span>^</span></code><span>&nbsp;运算符（<code><span>从末尾</span></code><span>索引）直接为集合元素赋值。</span></span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp; &nbsp; &nbsp; &nbsp; public class Numbers<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public int[] Datas { get;&nbsp;set<span>; } = new int[8];<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void&nbsp;ImplicitIndexAccess<span>()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var countdown = new&nbsp;Numbers<span>()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datas =<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1] = 0,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2] = 1,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 从 C# 13 开始可以执行下面方式赋值<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[^3] = 2,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[^4] = 3,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[^5] = 4<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span>异步和迭代器方法中的 ref 与 unsafe 支持</span></h2>
<p data-tool="mdnice编辑器"><span>在 C# 13 之前，迭代器方法（使用&nbsp;<code><span>yield return</span></code><span>&nbsp;的方法）和&nbsp;<code><span>async</span></code><span>&nbsp;方法不能声明局部&nbsp;<code><span>ref</span></code><span>&nbsp;变量，也不能使用&nbsp;<code><span>unsafe</span></code><span>&nbsp;上下文。</span></span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>在 C# 13 中，<code><span>async</span></code><span>&nbsp;方法可以声明&nbsp;<code><span>ref</span></code><span>&nbsp;局部变量或&nbsp;<code><span>ref struct</span></code><span>&nbsp;类型的局部变量。 但不可跨&nbsp;<code><span>await</span></code><span>&nbsp;或&nbsp;<code><span>yield return</span></code><span>&nbsp;使用。</span></span></span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>同样，C# 13 允许在迭代器方法中使用&nbsp;<code><span>unsafe</span></code><span>&nbsp;上下文。但是，所有&nbsp;<code><span>yield return</span></code><span>&nbsp;和&nbsp;<code><span>yield break</span></code><span>&nbsp;语句都必须在安全的上下文中。</span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>应用场景：提升内存敏感操作（如高性能 Span 处理）的灵活性。</span></p>
<h2 data-tool="mdnice编辑器"><span>allows ref struct</span></h2>
<p data-tool="mdnice编辑器"><span>在 C# 13 之前，<code><span>ref struct</span></code><span>&nbsp;类型不能声明为泛型或方法的类型参数。现在，泛型类型声明可以添加反约束&nbsp;<code><span>allows ref struct</span></code><span>。 此反约束声明为该类型参数提供的类型参数可以是&nbsp;<code><span>ref struct</span></code><span>&nbsp;类型。编译器会对该类型参数的所有实例执行&nbsp;<code><span>ref</span></code><span>&nbsp;安全规则。</span></span></span></span></span></p>
<ul class="list-paddingleft-1">
<li><span>应用场景：适用于游戏引擎、实时数据处理等需要低延迟内存操作的领域。通过泛型约束，可编写同时支持&nbsp;<code><span>ref struct</span></code><span>&nbsp;和非&nbsp;<code><span>ref struct</span></code><span>&nbsp;的通用代码。</span></span></span></li>
</ul>
<p data-tool="mdnice编辑器"><span>例如，可以像下面的代码一样声明一个泛型类型：</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public class C&lt;T&gt;&nbsp;where<span>&nbsp;T : allows ref struct<span><br><span>{<span><br><span>&nbsp; &nbsp; // 使用 T 作为 ref struct:<span><br><span>&nbsp; &nbsp; public void M(scoped T p)<span><br><span>&nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; //参数 p 必须遵循 ref 安全规则&nbsp;<span><br><span>&nbsp; &nbsp; }<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>allows ref struct 反约束声明相应的类型参数可以是 ref struct 类型。 该类型参数的实例必须遵循以下规则：</span></p>
<ul class="list-paddingleft-1">
<li><span>它不能被装箱。</span></li>
<li><span>它参与引用安全规则。</span></li>
<li><span>不能在不允许 ref struct 类型的地方使用实例，例如 static 字段。</span></li>
<li><span>实例可以使用 scoped 修饰符进行标记。</span></li>
</ul>
<h2 data-tool="mdnice编辑器"><span>partial类型中现在允许使用部分属性和索引器</span></h2>
<p data-tool="mdnice编辑器"><span>现如今可以在 C# 13 中声明&nbsp;<code><span>partial属性</span></code><span>和<code><span>partial索引器</span></code><span>。<code><span>partial</span></code><span>属性和索引器通常遵循与<code><span>partial</span></code><span>方法相同的规则：创建一个定义声明，一个实现声明。这两种声明的签名必须匹配。一个限制是，不能使用自动属性声明来实现部分属性。未声明正文的属性被视为声明声明。</span></span></span></span></span></p>
<blockquote>
<p><span>注意：不允许对构造函数、终结器、重载运算符或事件声明使用 partial 关键字。在 C# 13 之前，不允许对属性或索引器使用partial。</span></p>
</blockquote>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public partial class MyClass<span><br><span>{<span><br><span>&nbsp; &nbsp; public partial string Name { get;&nbsp;set<span>; }<span><br><span>}<span><br><span><br><span>public partial class MyClass<span><br><span>{<span><br><span>&nbsp; &nbsp; private string _name;<span><br><span>&nbsp; &nbsp; public partial string Name<span><br><span>&nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; get =&gt; _name;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;set<span>&nbsp;=&gt; _name = value;<span><br><span>&nbsp; &nbsp; }<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span>重载解析优先级</span></h2>
<p data-tool="mdnice编辑器"><span>在 C# 13 中，编译器识别&nbsp;<code><span>OverloadResolutionPriorityAttribute</span></code><span>，以便优先选择一个重载而不是另一个。库作者可以使用该属性确保新的、更好的重载比现有的重载更受青睐。</span></span></p>
<p data-tool="mdnice编辑器"><span>应用场景：适用于解决特定场景下的重载冲突和性能优化需求。通过合理设置优先级，开发者可以在保持代码兼容性的同时，优化编译器的选择逻辑。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/9M0PhLTmTIfzNFlBn3E31X4riaibtRCShbTQd4WHVMb1ADUqwRtjNjhmpWEImqTuCl0ljd7X6IczcjEPA24eXTkXaaLev52jy7/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp; &nbsp; public class Printer<span><br><span>&nbsp; &nbsp; {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; [OverloadResolutionPriority(1)] //优先调用<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void PrintWay(params int[] numberList) { }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; public static void PrintWay(params ReadOnlySpan&lt;int&gt; numberList) { }<span><br><span>&nbsp; &nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span>参考文章</span></h2>
<ul class="list-paddingleft-1">
<li><span style="color: rgba(0, 0, 255, 1)"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-13" target="_blank" rel="noopener nofollow"><span style="color: rgba(0, 0, 255, 1)">https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-13</span></a></span></li>
</ul>
</div>
<div id="MySignature" role="contentinfo">
    <blockquote>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;"><span style="font-size: 17px; ">作者名称：</span><a href="https://www.cnblogs.com/Can-daydayup/" target="_blank">追逐时光者</a></p>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;"><span style="font-size: 17px; ">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;">
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a onclick="votePost(cb_entryId,'Digg')" href="javascript:void(0)" style="color:red;">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。
</p>
</blockquote>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4234408029212963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-29 23:02">2025-03-29 08:00</span>&nbsp;
<a href="https://www.cnblogs.com/Can-daydayup">追逐时光者</a>&nbsp;
阅读(<span id="post_view_count">348</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18798838" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18798838);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18798838', targetLink: 'https://www.cnblogs.com/Can-daydayup/p/18798838', title: 'C# 13 中的新增功能实操' })">举报</a>
</div>
        