
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/assassinx/p/18691774" title="发布于 2025-01-26 14:31">
    <span role="heading" aria-level="2">应用程序取得当前目录和退出</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>如题c#获取当前运行应用程序所在目录和退出</p>
<h1>前言</h1>
<p>现在这浮躁社会，领导都是拍脑袋，大家都是图个短平快，压力进度给着，迫不得已在这种环境下大家都只能以搬砖的态度对待工作，都是用搜索引擎找 然后到处抄代码对吧。找了一片的方法，有AppDomain.CurrentDomain.BaseDirectory，有返回当前应用程序的根目录System.Reflection.Assembly.GetExecutingAssembly().Location回当前执行的程序集的路径。Application.ExecutablePath Application.StartupPath甚至我还知道其他方式。你还别说，嘿。。。。。抄了一片代码来试试，还都可以运行能够达到效果。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">通过assembly
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">得到exe文件完整路径</span>
<span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appPath2 =<span style="color: rgba(0, 0, 0, 1)"> System.Reflection.Assembly.GetExecutingAssembly().Location;
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">得到exe文件所在目录</span>
<span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appPath1 = System.AppDomain.CurrentDomain.BaseDirectory;</pre>
</div>
<p>进程方式访问</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">可取到主窗体标题</span>
<span style="color: rgba(0, 128, 128, 1)">2</span>  <span style="color: rgba(0, 0, 255, 1)">var</span> mainwindowTitle =<span style="color: rgba(0, 0, 0, 1)"> Process.GetCurrentProcess().MainWindowTitle;
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">注意，，这种方式取不到exe文件路径</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 255, 1)">var</span> appPath5 =<span style="color: rgba(0, 0, 0, 1)"> Process.GetCurrentProcess().StartInfo.FileName;
</span><span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">这种方式可获取当前进程的 exe文件完整路径</span>
<span style="color: rgba(0, 128, 128, 1)">6</span> <span style="color: rgba(0, 0, 255, 1)">var</span> appPath6 = Process.GetCurrentProcess().MainModule.FileName;</pre>
</div>
<p>&nbsp;</p>
<h1>概念梳理</h1>
<p>本身有几个概念请大家认识清楚。我们本身运行的exe那一堆东西 叫应用程序集 也叫Assembly 也叫进程 Process 都是一个意思，东西是一个东西，但是概念上是不同的。还有注意上面的代码获取exe执行程序路径的</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appPath2 =<span style="color: rgba(0, 0, 0, 1)"> System.Reflection.Assembly.GetExecutingAssembly().Location;
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 255, 1)">var</span> appPath6 = Process.GetCurrentProcess().MainModule.FileName;</pre>
</div>
<p>本意概念都是“主运行模块”的文件的路径，因为代码有可能不是直接从你这运行的有可能从其他地方加载的。</p>
<ul>
<li>Assembly从意义上强调被调用的那一坨exe或者dll其内部的功能和方法元数据定义。</li>
<li>Process 本质是 当前的if else 判断 改变量 这堆状态机代码 在 哪个进程执行。从意义上强调被操作系统调度的应用程序进程及收操作系统管控的那块内存区域。</li>
</ul>
<p>我们都称之为运行的"东西"，应用程序对象，我们知道vc++里有 application。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> CMFCh11App::ExitInstance()
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">TODO: 处理可能已添加的附加资源</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 0, 1)">    AfxOleTerm(FALSE);
</span><span style="color: rgba(0, 128, 128, 1)">5</span> 
<span style="color: rgba(0, 128, 128, 1)">6</span>     <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> CWinApp::ExitInstance();
</span><span style="color: rgba(0, 128, 128, 1)">7</span> }</pre>
</div>
<p>这些东西自己称自己为 为"application"于是乎我们在Winform里可以找到有Winform的application。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">得到exe文件完整路径</span>
<span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appPath3 =<span style="color: rgba(0, 0, 0, 1)"> System.Windows.Forms.Application.ExecutablePath;
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">得到exe文件所在目录</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appPath4 = System.Windows.Forms.Application.StartupPath;</pre>
</div>
<p><em id="__mceDel"><em id="__mceDel">在wpf里可以找到有wpf的application，注意wpf的application取不到所运行的exe所在目录。</em></em></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">string</span> appstr = Application.Current.MainWindow.ToString();</pre>
</div>
<h1>回归本质概念</h1>
<p>而这个东西本质就应该是天然的 操作系统应该给到应用程序级的信息 ，应用程序应该天然的知道自己从哪里启动的，事情的本质 ，嗯 不错 又回归到事情的本质。我们进行文件接口操作不是 Directory 吗 ，我们写文件时不是./" 目录 就是写到当前应用程序目录吗 ，这个东西不应该本身就是天然的吗。是的。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> DirectoryInfo dir = <span style="color: rgba(0, 0, 255, 1)">new</span> DirectoryInfo(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">./</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">输出d:\xxx\</span>
<span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 0, 1)">Console.WriteLine(dir.FullName);
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">输出d:\xxx</span>
<span style="color: rgba(0, 128, 128, 1)">5</span> Console.WriteLine(Directory.GetCurrentDirectory());</pre>
</div>
<p>注意这个结尾，多一个斜杠在Path.Combine( ) 的时候会出幺蛾子。</p>
<h1>关于应用程序的退出</h1>
<p>应用程序如何退出，想想我们为什么被叫做程序员，不就是编写流水线作业的么。没那么高大上。计算机运转需要连续不断的喂指令。想想在dos时代或者单片机上编程，当没有指令喂的时候可不就自然结束了么，要啥特别操作，你说要啥操作根本不需要。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Program
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Main(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">[] args)
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">5</span>         Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">aaa</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">6</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">到此处应用程序就结束了</span>
<span style="color: rgba(0, 128, 128, 1)">7</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">8</span> }</pre>
</div>
<p>好，你非要钻牛角非要说中途退出，你中途return不就得了，或者可以</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> Environment.Exit(<span style="color: rgba(128, 0, 128, 1)">0</span>);</pre>
</div>
<p>所以说dos程序根本没有“不知道自己何时退出”这个概念哈，只有图形化界面才“不知道自己何时退出”因为窗体自己本身在一个死循环周期里通过Windows消息机制在维持。</p>
<p>winform退出</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> System.Windows.Forms.Application.Exit();</pre>
</div>
<p>wpf退出</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> System.Windows.Application.Current.Shutdown(<span style="color: rgba(128, 0, 128, 1)">0</span>);</pre>
</div>
<p>由于最开始的时候只有winform支持后来又添加了wpf，可以在命名空间上看得出来在整个.NetFramework实际功能和概念上有很多重叠的地方。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="6.07290024228125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-26 14:32">2025-01-26 14:31</span>&nbsp;
<a href="https://www.cnblogs.com/assassinx">assassinx</a>&nbsp;
阅读(<span id="post_view_count">162</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18691774" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18691774);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18691774', targetLink: 'https://www.cnblogs.com/assassinx/p/18691774', title: '应用程序取得当前目录和退出' })">举报</a>
</div>
        