
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18894299" title="发布于 2025-05-24 14:01">
    <span role="heading" aria-level="2">.NET外挂系列：8. harmony 的IL编织 Transpiler</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>前面文章所介绍的一些注入技术都是以<code>方法</code>为原子单位，但在一些罕见的场合中，这种方法粒度又太大了，能不能以<code>语句</code>为单位，那这个就是我们这篇介绍的 <code>Transpiler</code>，它可以修改方法的 IL 代码，甚至重构，所以这就非常考验你的 IL 功底，个人建议在写的时候要多借助如下三个工具：</p>
<ul>
<li>ILSpy：观察原生代码</li>
<li>日志： 多看harmony日志，即方法上加盖 HarmonyDebug 特性。</li>
<li>DeepSeek：大模型是一个非常好的助手，合理利用定会效率加倍。</li>
</ul>
<p>否则遇到稍微复杂一点的，真的难搞。。。</p>
<h2 id="二有趣的il编织案例">二：有趣的IL编织案例</h2>
<h3 id="1-如何将sub中的加法改成减法">1. 如何将Sub中的加法改成减法</h3>
<p>为了方便演示，我们先上一段代码，实现一个简单的 <code>a+b</code> 操作，代码如下：</p>
<pre><code class="language-C#">    internal class Program
    {
        static void Main(string[] args)
        {
            var num = MyMath.Sub(40, 30);
            Console.WriteLine($"Result: {num}");

            Console.ReadLine();
        }
    }

    public class MyMath
    {
        public static int Sub(object a, object b)
        {
            var num1 = Convert.ToInt32(a);
            var num2 = Convert.ToInt32(b);

            var num = num1 + num2;

            return num;
        }
    }

</code></pre>
<p>上面卦中的 <code>Sub</code> 方法的 IL 代码如下：</p>
<pre><code class="language-C#">
	.method public hidebysig static 
		int32 Sub (
			object a,
			object b
		) cil managed 
	{
		.custom instance void [System.Runtime]System.Runtime.CompilerServices.NullableContextAttribute::.ctor(uint8) = (
			01 00 01 00 00
		)
		// Method begins at RVA 0x20b0
		// Header size: 12
		// Code size: 25 (0x19)
		.maxstack 2
		.locals init (
			[0] int32 num1,
			[1] int32 num2,
			[2] int32 sum,
			[3] int32
		)

		IL_0000: nop
		IL_0001: ldarg.0
		IL_0002: call int32 [System.Runtime]System.Convert::ToInt32(object)
		IL_0007: stloc.0
		IL_0008: ldarg.1
		IL_0009: call int32 [System.Runtime]System.Convert::ToInt32(object)
		IL_000e: stloc.1
		IL_000f: ldloc.0
		IL_0010: ldloc.1
		IL_0011: add
		IL_0012: stloc.2
		IL_0013: ldloc.2
		IL_0014: stloc.3
		IL_0015: br.s IL_0017

		IL_0017: ldloc.3
		IL_0018: ret
	} // end of method MyMath::Sub

</code></pre>
<p>因为Sub怎么可能是<code>a+b</code>，所以现在我的需求就是将 <code>num1 + num2</code> 改成 <code>num1 - num2</code>，从 il 的角度就是将 <code>IL_0011: add</code> 改成 <code>IL_0011: sub</code> 即可，如何做到呢？用 harmony 的 CodeMatcher 类去替换IL代码即可，完整的代码如下：</p>
<pre><code class="language-C#">
namespace Example_20_1_1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // 应用Harmony补丁								
            var harmony = new Harmony("com.example.patch");
            harmony.PatchAll();

            var num = MyMath.Sub(40, 30);
            Console.WriteLine($"Result: {num}"); // 原应输出70，补丁后输出10								

            Console.ReadLine();
        }
    }

    public class MyMath
    {
        public static int Sub(object a, object b)
        {
            var num1 = Convert.ToInt32(a);
            var num2 = Convert.ToInt32(b);

            var num = num1 + num2; // 此行将被Transpiler修改为减法								

            return num;
        }
    }

    [HarmonyPatch(typeof(MyMath), "Sub")]
    [HarmonyDebug]
    public static class MyMathPatch
    {
        static IEnumerable&lt;CodeInstruction&gt; Transpiler(IEnumerable&lt;CodeInstruction&gt; instructions)
        {
            var codeMatcher = new CodeMatcher(instructions);

            codeMatcher.MatchStartForward(new CodeMatch(OpCodes.Add))     // 匹配加法操作 (add 指令)	
                       .ThrowIfInvalid("Could not find add instruction")
                       .SetOpcodeAndAdvance(OpCodes.Sub);                 // 将 add 指令替换为 sub 指令	

            return codeMatcher.Instructions();
        }
    }

}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250524140038209-1951038779.png" alt="" loading="lazy"></p>
<p>从卦中的输出看，我们修改成功了，这里稍微说一下 <code>CodeMatcher</code> 的方法。</p>
<ul>
<li>MatchStartForward：这个就是游标，定位到 <code>OpCodes.Add</code> 行。</li>
<li>ThrowIfInvalid：   如果没有定位到就抛出异常。</li>
<li>SetOpcodeAndAdvance：替换 IL中的add为sub，并向下移动一行，可以理解成 i++。</li>
</ul>
<p>由于在 MyMathPatch 上加了一个 <code>[HarmonyDebug]</code> 特性，打开 <code>harmony.log.txt</code> 的输出结果，成功看到了替换后的sub，参考如下：</p>
<pre><code class="language-C#">
### Patch: static System.Int32 Example_20_1_1.MyMath::Sub(System.Object a, System.Object b)
### Replacement: static System.Int32 Example_20_1_1.MyMath::Example_20_1_1.MyMath.Sub_Patch0(System.Object a, System.Object b)
IL_0000: Local var 0: System.Int32
IL_0000: Local var 1: System.Int32
IL_0000: Local var 2: System.Int32
IL_0000: Local var 3: System.Int32
IL_0000: // start original
IL_0000: nop
IL_0001: ldarg.0
IL_0002: call       static System.Int32 System.Convert::ToInt32(System.Object value)
IL_0007: stloc.0
IL_0008: ldarg.1
IL_0009: call       static System.Int32 System.Convert::ToInt32(System.Object value)
IL_000E: stloc.1
IL_000F: ldloc.0
IL_0010: ldloc.1
IL_0011: sub
IL_0012: stloc.2
IL_0013: ldloc.2
IL_0014: stloc.3
IL_0015: br =&gt;      Label0
IL_001A: Label0
IL_001A: ldloc.3
IL_001B: // end original
IL_001B: ret
DONE

</code></pre>
<h3 id="2-如何给sub加业务逻辑">2. 如何给Sub加业务逻辑</h3>
<p>上面的例子本质上是<code>IL代码</code>的原地替换，接下来我们看下如何对IL代码进行<code>删增</code>操作，我的业务需求是这样的，想将 <code>num1 + num2</code> 改成 <code>num1 - num2 - num3</code>，我想要最终的 C# 代码变为这样：</p>
<pre><code class="language-C#">
    public class MyMath
    {
        public static int Sub(object a, object b)
        {
            var num1 = Convert.ToInt32(a);
            var num2 = Convert.ToInt32(b);
            var num3 = Convert.ToInt32("20");   // 新增的代码

            var num = num1 - num2 - num3;
            return num;
        }
    }

</code></pre>
<p>接下来用<code>Transpiler</code>进行编织，代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(MyMath), "Sub")]
    [HarmonyDebug]
    public static class MyMathPatch
    {
        public static IEnumerable&lt;CodeInstruction&gt; Transpiler(IEnumerable&lt;CodeInstruction&gt; instructions, ILGenerator generator)
        {
            var codeMatcher = new CodeMatcher(instructions, generator)

                .MatchStartForward(                     // 匹配模式：ldloc.0, ldloc.1, add
                    new CodeMatch(OpCodes.Ldloc_0),
                    new CodeMatch(OpCodes.Ldloc_1),
                    new CodeMatch(OpCodes.Add)
                )
                .ThrowIfInvalid("Could not find add operation pattern")

                // 移除原来的三条指令
                .RemoveInstructions(3)

                // 插入新的指令序列
                .InsertAndAdvance(
                                    new CodeInstruction(OpCodes.Ldloc_0),
                                    new CodeInstruction(OpCodes.Ldloc_1),
                                    new CodeInstruction(OpCodes.Sub),
                                    new CodeInstruction(OpCodes.Ldstr, "20"),
                                    new CodeInstruction(OpCodes.Call, typeof(Convert).GetMethod(
                                                                      nameof(Convert.ToInt32),
                                                                      new[] { typeof(string) })),
                                    new CodeInstruction(OpCodes.Sub)
                );

            return codeMatcher.InstructionEnumeration();
        }
    }

</code></pre>
<p>代码的逻辑非常简单，先在IL代码中定位到 <code>num1 + num2</code>，然后删除再写入 <code>num1 - num2 - num3</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250524140038209-353668098.png" alt="" loading="lazy"></p>
<h3 id="3-如何添加try-catch">3. 如何添加try catch</h3>
<p>最后我们来一个比较实用的修改，即在 <code>Sub</code> 中增加<code>try catch</code>，理想的代码如下：</p>
<pre><code class="language-C#">
    public class MyMath
    {
        public static int Sub(object a, object b)
        {
            try
            {
                var num1 = Convert.ToInt32(a);
                var num2 = Convert.ToInt32(b);

                var num = num1 - num2;

                return num;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return 0;
            }
        }
    }

</code></pre>
<p>接下来就要开始编织了，这是从0开始的代码段，完整代码如下：</p>
<pre><code class="language-C#">
namespace Example_20_1_1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // 应用Harmony补丁										
            var harmony = new Harmony("com.example.patch");
            harmony.PatchAll();

            // 测试原始方法										
            var num = MyMath.Sub("a", 30);
            Console.WriteLine($"异常: {num}");

            var num2 = MyMath.Sub(50, 30);
            Console.WriteLine($"正常: {num2}");


            Console.ReadLine();
        }
    }

    public class MyMath
    {
        public static int Sub(object a, object b)
        {
            try
            {
                var num1 = Convert.ToInt32(a);
                var num2 = Convert.ToInt32(b);

                var num = num1 - num2;

                return num;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return 0;
            }
        }
    }

    [HarmonyPatch(typeof(MyMath), "Sub")]
    [HarmonyDebug]
    public static class MyMathPatch
    {
        static IEnumerable&lt;CodeInstruction&gt; Transpiler(IEnumerable&lt;CodeInstruction&gt; originalInstructions, ILGenerator generator)
        {
            // 定义标签
            Label tryStart = generator.DefineLabel();
            Label tryEnd = generator.DefineLabel();
            Label catchStart = generator.DefineLabel();
            Label endLabel = generator.DefineLabel();

            // 声明局部变量
            var exVar = generator.DeclareLocal(typeof(Exception)); // 用于存储异常的变量
            var resultVar = generator.DeclareLocal(typeof(int));   // 用于存储返回值的变量

            var newInstructions = new List&lt;CodeInstruction&gt;();

            // 1. try 块开始
            newInstructions.Add(new CodeInstruction(OpCodes.Nop).WithLabels(tryStart));

            // 2. 添加原始方法体（保持不变）
            newInstructions.AddRange(originalInstructions);

            // 3. 存储结果并离开 try 块
            newInstructions.Add(new CodeInstruction(OpCodes.Stloc, resultVar));
            newInstructions.Add(new CodeInstruction(OpCodes.Leave, endLabel).WithLabels(tryEnd));

            // 4. catch 块
            newInstructions.Add(new CodeInstruction(OpCodes.Stloc, exVar).WithLabels(catchStart));
            newInstructions.Add(new CodeInstruction(OpCodes.Nop));
            newInstructions.Add(new CodeInstruction(OpCodes.Ldloc, exVar));
            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt,
                typeof(Exception).GetProperty("Message").GetGetMethod()));
            newInstructions.Add(new CodeInstruction(OpCodes.Call,
                typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })));
            newInstructions.Add(new CodeInstruction(OpCodes.Ldc_I4_0)); // 返回0
            newInstructions.Add(new CodeInstruction(OpCodes.Stloc, resultVar));
            newInstructions.Add(new CodeInstruction(OpCodes.Leave, endLabel));

            // 5. 方法结束（加载结果并返回）
            newInstructions.Add(new CodeInstruction(OpCodes.Ldloc, resultVar).WithLabels(endLabel));
            newInstructions.Add(new CodeInstruction(OpCodes.Ret));

            // 添加异常处理
            generator.BeginExceptionBlock();
            generator.BeginCatchBlock(typeof(Exception));
            generator.EndExceptionBlock();

            return newInstructions;
        }
    }
}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250524140038214-618541105.png" alt="" loading="lazy"></p>
<p>哈哈，上面的代码正如我们所料。。。如果不借助 ILSpy 和 DeepSeek，不敢想象得要浪费多少时间。。。门槛太高了。。。</p>
<h2 id="三总结">三：总结</h2>
<p>这个系列总计8篇，已经全部写完啦！希望对同行们在解决<code>.NET程序疑难杂症</code>相关问题时提供一些资料和灵感，同时也是对<code>.NET调试训练营</code> 的学员们功力提升添砖加瓦！<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6753653338206018" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-24 14:01">2025-05-24 14:01</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18894299);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18894299', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18894299', title: '.NET外挂系列：8. harmony 的IL编织 Transpiler' })">举报</a>
</div>
        