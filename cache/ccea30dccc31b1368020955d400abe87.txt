
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuhuacong/p/18636134" title="发布于 2024-12-27 18:35">
    <span role="heading" aria-level="2">WxPython跨平台开发框架之复杂界面内容的分拆和重组处理</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        复杂界面内容的分拆和重组处理是现代软件开发中常见的做法，尤其在开发大型应用程序时，可以大幅提升开发效率、可维护性和用户体验。通过将复杂的界面内容分拆成更小的模块，每个模块都专注于单一功能或组件，代码更容易理解和维护。模块化的界面组件可以在多个地方复用，减少了重复开发的工作。通过将复杂的界面分拆为多个小模块，开发者可以更专注于每个模块的细节，优化每个部分的用户体验。本篇随笔介绍一下基于WxPython跨平台开发框架的一些界面内容的的分拆和重组处理实现。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>复杂界面内容的分拆和重组处理是现代软件开发中常见的做法，尤其在开发大型应用程序时，可以大幅提升开发效率、可维护性和用户体验。通过将复杂的界面内容分拆成更小的模块，每个模块都专注于单一功能或组件，代码更容易理解和维护。模块化的界面组件可以在多个地方复用，减少了重复开发的工作。通过将复杂的界面分拆为多个小模块，开发者可以更专注于每个模块的细节，优化每个部分的用户体验。本篇随笔介绍一下基于WxPython跨平台开发框架的一些界面内容的的分拆和重组处理实现。</p>
<h3>1、随笔中我们项目的相关实现</h3>
<p>我曾经在《<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2020-07-14 12:44" href="https://www.cnblogs.com/wuhuacong/p/13293893.html">循序渐进VUE+Element 前端应用开发(16）--- 组织机构和角色管理模块的处理</a>》中介绍过基于Vue+Element的前端界面组件的分拆和组合管理，</p>
<p>随笔中介绍过机构或角色信息中，界面内容比较多，可以进行拆分，根据内容的展示不同，拆分为各自的组件模块，然后合并使用即可，如下所示。</p>
<p>在对象UML的图例中，应该是如下所示的效果图，组织机构包含组织成员和角色的内容。</p>
<p><img src="https://img2020.cnblogs.com/blog/8867/202007/8867-20200713172524064-321772392.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>在界面上，组织成员还需要添加成员的功能，同理角色也需要添加角色的处理，如下UML图示。</p>
<p><img src="https://img2020.cnblogs.com/blog/8867/202007/8867-20200713173050552-254132834.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>其中每个角色，除了包含基本信息外，还会包含拥有的权限（功能控制点）、包含用户，以及拥有的菜单，其中权限是用来控制界面元素，如操作按钮的显示的，而拥有的菜单，则是用户以指定账号登录系统后，获得对应角色的菜单，然后构建对应的访问入口的。</p>
<p>角色界面模块UML类图如下所示。&nbsp;</p>
<p><img src="https://img2020.cnblogs.com/blog/8867/202007/8867-20200713172611456-1627083929.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>在Vue+Element的BS前端项目上， 我们以不同的Tab来展示这些信息，如下所示。&nbsp;&nbsp;其中可以看到不同的Tab显示不同的内容。</p>
<p><img src="https://img2020.cnblogs.com/blog/8867/202007/8867-20200714114901330-1297134214.png" alt="" class="medium-zoom-image" loading="lazy"></p>
<p>另外用户信息和角色信息类似，也需要展示复杂的相关信息，用户本身拥有的权限功能点和拥有的菜单，如下界面所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227163536579-1490154404.png" alt="" width="553" height="614" loading="lazy"></p>
<p>&nbsp;上面介绍是基于Vue+Element的前端开发界面处理，其实对于Python的WxPython组件的分拆和组合来说一样非常有必要，也更加方便。</p>
<p>&nbsp;</p>
<h3>2、wxPython 中复杂界面的分拆和重组</h3>
<p>在 Python 的 wxPython 框架中，复杂界面内容的分拆和重组同样是非常重要的做法。由于 wxPython 提供了许多丰富的控件和布局管理器，能够帮助开发者高效地构建界面，分拆和重组组件不仅有助于提高代码的可维护性和可复用性，还能够提升界面的响应性和用户体验。</p>
<h4>1）. <strong>组件化设计</strong></h4>
<p>和前面提到的模块化设计类似，wxPython 的组件化设计就是将界面拆分成多个小的、功能明确的控件或子窗口，这些控件可以是：</p>
<ul>
<li><strong>基本控件</strong>：例如按钮、文本框、标签、选择框等。</li>
<li><strong>容器控件</strong>：如 <code>Panel</code>、<code>BoxSizer</code>、<code>SplitterWindow</code>，用于管理其他控件的布局和显示。</li>
<li><strong>自定义控件</strong>：通过继承 wxPython 的基本控件来创建自己的控件（例如，自定义表格、树状视图等）。</li>
</ul>
<p><strong>常见做法：</strong></p>
<ul>
<li>将一个复杂的窗口分解成多个 <code>Panel</code> 或子窗口（子界面），每个 Panel 专注于处理特定的任务（例如，数据输入区、数据展示区、按钮区等）。</li>
<li>创建可复用的组件类（如自定义控件），将不同的 UI 元素封装在类内部，使得这些控件可以在不同地方重用。</li>
</ul>
<h4>2）. <strong>布局管理器</strong></h4>
<p>wxPython 提供了多种布局管理器（如 <code>BoxSizer</code>、<code>GridSizer</code>、<code>FlexGridSizer</code> 等）来帮助自动调整控件的大小和位置，适应不同的窗口大小，提升界面响应性。</p>
<p><strong>常见做法：</strong></p>
<ul>
<li><strong>BoxSizer</strong>：常用于垂直或水平布局。通过 <code>wx.BoxSizer(wx.HORIZONTAL)</code> 或 <code>wx.BoxSizer(wx.VERTICAL)</code> 将控件按顺序排列。</li>
<li><strong>GridSizer</strong>：用于将控件组织成网格布局。</li>
<li><strong>FlexGridSizer</strong>：类似于 <code>GridSizer</code>，但支持单元格自适应大小，适合处理复杂的布局需求。</li>
<li><strong>SplitterWindow</strong>：允许在多个子窗口之间进行分割，以便显示多个视图或控件。</li>
</ul>
<p>通过合理地使用布局管理器，可以有效地分拆界面并控制各个控件的布局和展示。</p>
<h4>3）. <strong>事件绑定与回调函数</strong></h4>
<p>在 wxPython 中，界面控件的交互通过事件机制来处理。通过事件绑定，可以将用户操作（如按钮点击、文本框输入等）与特定的回调函数（事件处理函数）关联起来。</p>
<h4>4）. <strong>使用自定义对话框</strong></h4>
<p>对于复杂的交互逻辑，使用自定义对话框（<code>wx.Dialog</code>）是一个有效的分拆方法。可以将一些特定功能（如设置、用户登录等）封装到单独的对话框中，避免主界面过于复杂。</p>
<h4>5）. <strong>分拆大型界面为多个窗口或视图</strong></h4>
<p>在复杂应用中，往往需要处理多个界面或视图。例如，可以将主界面和设置、帮助等内容分开，使用 <code>wx.Notebook</code>、<code>wx.SplitterWindow</code> 或多文档界面（MDI）来实现不同界面之间的切换和组织。</p>
<p><strong>常见做法：</strong></p>
<ul>
<li>使用 <code>wx.Notebook</code> 来实现标签页式布局，每个标签页对应一个不同的功能模块。</li>
<li>使用 <code>wx.SplitterWindow</code> 来分隔主界面的上下或左右区域，使得界面更加灵活和适应不同的操作需求。</li>
</ul>
<p>这些做法能够帮助开发者有效组织复杂的 wxPython 界面，使其更加灵活、易于维护并提供良好的用户体验。</p>
<p>介绍完理论知识后，我们来实际看看在WxPython跨平台开发框架中是如何实现界面的分拆和重组的。</p>
<p>在WxPython的项目中，角色信息的展示也是类似的多选项卡来实现分来展示的。其中包括：角色基本信息、可操作功能、可访问菜单、可访问数据等等内容。如下界面所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227181143585-1398922817.png" alt="" loading="lazy"></p>
<p>如果把这些内容的控件布局，和具体的事件整合在一个文件里，那么界面代码比较臃肿，也很难修改维护。因此把它们分门别类的进行独立分拆。</p>
<p>初步我们可以把这些内容按选项卡的界面来分别创建多个面板（Panel)的创建和实现，然后在主界面上整合它们即可，进一步，我们还可以把相同的列表或者局部界面进行独立出来重用，多次重构后，可以使得我们的界面维护起来更加方便。</p>
<p>如我们先根据界面的不同部分进行创建不同的文件，用来构建局部内容的展示处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227181651904-2102195521.png" alt="" loading="lazy"></p>
<p>&nbsp;然后在主界面frm_role.py 进行汇总整合即可，如下所示，先引入相关的局部面板界面。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227181821015-1922305864.png" alt="" loading="lazy"></p>
<p>然后我们通过编写一个函数，让他们组合到wx.NoteBook控件上即可，如下代码所示。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> create_content(self, parent: wx.Panel):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">创建列表面板</span><span style="color: rgba(128, 0, 0, 1)">"""</span>

        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 为NotBook 准备图标</span>
        img_list = get_image_list([<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">group_key</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">key</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">menu</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">organ</span><span style="color: rgba(128, 0, 0, 1)">"</span>], 16<span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 添加NoteBook</span>
        self.notebook =<span style="color: rgba(0, 0, 0, 1)"> wx.Notebook(parent)
        self.notebook.AssignImageList(img_list)
        self.notebook.AddPage(self.create_main_basic(self.notebook), </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">角色基本信息</span><span style="color: rgba(128, 0, 0, 1)">"</span>, imageId=<span style="color: rgba(0, 0, 0, 1)">0)

        self.role_function_panel </span>=<span style="color: rgba(0, 0, 0, 1)"> Role_Function(self.notebook)
        self.notebook.AddPage(self.role_function_panel, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">可操作功能</span><span style="color: rgba(128, 0, 0, 1)">"</span>, imageId=1<span style="color: rgba(0, 0, 0, 1)">)<br>
        self.role_menu_panel </span>=<span style="color: rgba(0, 0, 0, 1)"> Role_Menu(self.notebook)
        self.notebook.AddPage(self.role_menu_panel, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">可访问菜单</span><span style="color: rgba(128, 0, 0, 1)">"</span>, imageId=2<span style="color: rgba(0, 0, 0, 1)">)<br>
        self.role_data_panel </span>=<span style="color: rgba(0, 0, 0, 1)"> Role_RoleData(self.notebook)
        self.notebook.AddPage(self.role_data_panel, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">可访问数据</span><span style="color: rgba(128, 0, 0, 1)">"</span>, imageId=3<span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> self.notebook</pre>
</div>
<p>这样各司其职，各个部分负责自己内部的界面展示和数据初始化的逻辑即可，如果我们需要调用某个组件的处理，那么公布对应的方法来操作数据即可。</p>
<p>如我们在数据显示的时候，让它们组件各自负责相关的更新处理即可，如下代码所示是在对具体角色的数据进行显示的时候，调用各个组件对象进行更新显示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227182537184-1233557642.png" alt="" loading="lazy"></p>
<p>&nbsp;类似这样处理，我们就可以控制界面组件的有限操作即可，其他交由内部的事件进行相关数据的保存操作即可。</p>
<p>同样，对于其他模块，我们也可以采用同样的方式来简化界面的处理逻辑，同时也是分拆关注点，便于我们更加快捷的处理问题。</p>
<p>如用户管理模块的信息展示中，也是包含 很多内容。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227182958257-1376335388.png" alt="" loading="lazy"></p>
<p>我们把常用到的树形列表，封装为一个独立的界面控件，这样可以在很多场合上使用，如只需要展示类别，而不需要勾选的时候，如上图所示，如果需要勾选，我们通过一个变量来控制显示复选框即可，如下界面所示。上面和下面的两个树形列表的展示，是基于一个自定义的树形控件再封装的。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241227183200651-1600156739.png" alt="" loading="lazy"></p>
<p>&nbsp;以上就是WxPython跨平台开发框架之复杂界面内容的分拆和重组处理的一些经验分享，希望你喜欢，可以在分析复杂界面的时候，运用这些分而治之的理念，通过分拆内容，实现关注点的聚焦，从而能够快捷的处理一些复杂的问题。</p>
</div>
<div id="MySignature" role="contentinfo">
    <div style="border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;">
    <img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" align="top" alt="">
    <span style="color: #000000"><span class="Apple-tab-span" style="white-space: pre"></span>
     专注于代码生成工具、.Net/.NetCore 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架等框架产品。
     <br>&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href="http://www.iqidi.com/" target="_blank">http://www.iqidi.com</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.07622009381828704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 18:40">2024-12-27 18:35</span>&nbsp;
<a href="https://www.cnblogs.com/wuhuacong">伍华聪</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18636134" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18636134);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18636134', targetLink: 'https://www.cnblogs.com/wuhuacong/p/18636134', title: 'WxPython跨平台开发框架之复杂界面内容的分拆和重组处理' })">举报</a>

        </p>
    