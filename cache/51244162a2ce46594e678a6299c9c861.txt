
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/birthcat/p/18992659" title="发布于 2025-07-19 11:01">
    <span role="heading" aria-level="2">[ThingsBoard] 3. 源码解读Actor</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一前言">一、前言</h2>
<p><strong>本文基于 ThingsBoard 4.0.2 编写</strong>，对应提交<code>Version set to 4.0.2(01c5ba7d37006e1f8a3492afbb3c67d017ca8dd3)</code>。<br>
由于个人技术能力和写作经验有限，欢迎读者指出文中的错误与不足。</p>
<h2 id="二actor模型">二、Actor模型</h2>
<blockquote>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/86460724" target="_blank" rel="noopener nofollow">Actor模型是解决高并发的终极解决方案 - 知乎</a><br>
本人写的一般，可以看参考文章</p>
</blockquote>
<h3 id="1-actor">1. Actor</h3>
<p>Actor 模型则将一切视为 Actor。Actor 是并发执行的基本单元，与其他 Actor 之间通过消息传递进行通信，当接收到消息时，一个 Actor 可以并行地执行三件事：向其他 Actor 发送消息、创建新的 Actor，以及决定如何处理下一条消息。</p>
<h3 id="2-消息传递">2. 消息传递</h3>
<p>Actor之间互相并行，因此消息传递都是异步的，Mailbox负责给Actor进行消息传递。<br>
两个Actor之间消息传递时，Actor A发送到Actor B的Mailbox。等到Actor B处理消息时。<br>
它就会从自己的Mailbox中获取消息，进行处理。</p>
<h2 id="三thingsboard中的actor">三、ThingsBoard中的Actor</h2>
<blockquote>
<p><code>ThingsBoard</code>以下简称TB，代码进行一些精简，方法使用lambda方法引用表示。</p>
</blockquote>
<h3 id="1-tbactormailbox">1. TbActorMailBox</h3>
<p>在TB的Actor模型中，<code>Mailbox</code>对应的实现类是<code>TbActorMailbox</code>，其继承关系为<code>TbActorMailbox</code>→<code>TbActorCtx</code>→<code>TbActorRef</code>。值得注意的是，<code>TbActorCtx</code>和<code>TbActorRef</code>在整个系统中都只有<code>TbActorMailbox</code>这一个实现类，因此在之后的代码阅读中可以将<code>TbActorRef</code>和<code>TbActorCtx</code>都认为是<code>TbActorMailbox</code>。<strong>这点在之后的代码分析很有用</strong>。</p>
<p>Actor通过其<code>::tell</code>和<code>::tellWithHighPriority</code>传递消息其对应的Actor。每个<code>TbActor</code>都只对应一个<code>TbActorMailbox</code></p>
<pre><code class="language-java">private final TbActor actor;

public void tell(TbActorMsg actorMsg) {
    enqueue(actorMsg, NORMAL_PRIORITY);
}

public void tellWithHighPriority(TbActorMsg actorMsg) {
    enqueue(actorMsg, HIGH_PRIORITY);
}

private void tryProcessQueue(boolean newMsg) {
    dispatcher.getExecutor().execute(this::processMailbox);
}


private void enqueue(TbActorMsg msg, boolean highPriority) {
    if (highPriority) {
        highPriorityMsgs.add(msg);
    } else {
        normalPriorityMsgs.add(msg);
    }
    tryProcessQueue();
}
</code></pre>
<p>其中<code>::tryProcessQueue</code>会异步处理消息队列，实际的处理逻辑在<code>::processMailbox</code>中。通过<code>actor::process</code>委托给实际的Actor执行。</p>
<pre><code class="language-java">private void processMailbox() {
    for (int i = 0; i &lt; settings.getActorThroughput(); i++) {
        TbActorMsg msg = highPriorityMsgs.poll();
        if (msg == null) {
            msg = normalPriorityMsgs.poll();
        }
        if (msg != null) {
            actor.process(msg);
        }
    }
}
</code></pre>
<h3 id="2actor的初始化">2.Actor的初始化：</h3>
<blockquote>
<p>初始化的逻辑只选择部分重点分析，其他部分可以让ai能进行逐行分析。</p>
</blockquote>
<p>Actor可以分为两大类</p>
<ul>
<li>管理其他Actor，负责创建其管理的Actor，传递消息。</li>
<li>逻辑处理，接收消息，将消息委托给processor字段类处理。</li>
</ul>
<h3 id="21-管理创建actor的actor">2.1 管理创建Actor的Actor</h3>
<h4 id="appactor">AppActor</h4>
<p>首先TB也是一个Spring应用，因此Actor的创建也是从被Spring管理的Bean开始第一个的创建。其受到Spring管理的就是<code>DefaultActorService</code>类在<code>::initActorSystem</code>中创建了<code>AppActor</code>。<br>
看向<code>TbActorSystem::createRootActor</code>方法，它需要一个<code>TbActorCreator</code>的实例，而<code>TbActorCreator</code>则是负责创建每个<code>TbActor</code>的对象。会调用<code>::createActor</code>。</p>
<pre><code class="language-java">@PostConstruct
public void initActorSystem() {
    appActor = system.createRootActor(APP_DISPATCHER_NAME, new AppActor.ActorCreator(actorContext));
}
</code></pre>
<p><code>::createActor</code>中创建了一个<code>TbActorMailbox</code>。<br>
在<code>TbActorSystem</code>内部会逐步调用到<code>::createActor(String, TbActorCreator, TbActorId)</code>，它加锁进行创建。</p>
<pre><code class="language-java">
public TbActorRef createRootActor(String dispatcherId, TbActorCreator creator) {
    return createActor(dispatcherId, creator, null);
}

public TbActorRef createChildActor(String dispatcherId, TbActorCreator creator, TbActorId parent) {
    return createActor(dispatcherId, creator, parent);
}

private TbActorRef createActor(String dispatcherId, TbActorCreator creator, TbActorId parent) {
    Dispatcher dispatcher = dispatchers.get(dispatcherId)
    TbActorId actorId = creator.createActorId();
    TbActorMailbox actorMailbox = actors.get(actorId);
    Lock actorCreationLock = actorCreationLocks.computeIfAbsent(actorId, id -&gt; new ReentrantLock());
    actorCreationLock.lock();
    try {
    if (actorMailbox == null) {
        log.debug("Creating actor with id [{}]!", actorId);
        TbActor actor = creator.createActor();
        TbActorRef parentRef = null;
        if (parent != null) {
            parentRef = getActor(parent);
        }
        TbActorMailbox mailbox = new TbActorMailbox(this, settings, actorId, parentRef, actor, dispatcher);
        actors.put(actorId, mailbox);
        mailbox.initActor(); // 注意此处
        actorMailbox = mailbox;
    } else {
        log.debug("Actor with id [{}] is already registered!", actorId);
    }

    } finally {
        actorCreationLock.unlock();
        actorCreationLocks.remove(actorId);
    }
    return actorMailbox;
}

private TbActorRef createActor(String dispatcherId, TbActorCreator creator, TbActorId parent) {
    TbActor actor = creator.createActor();
    TbActorRef parentRef = null;
    if (parent != null) {
        parentRef = getActor(parent);
    }
    TbActorMailbox mailbox = new TbActorMailbox(this, settings, actorId, parentRef, actor, dispatcher);
    actors.put(actorId, mailbox);
    mailbox.initActor();
}
</code></pre>
<p>而在<code>TbActorMailbox::initActor</code>方法中，会提交<code>::tryInit</code>的异步初始化，其中<code>actor.init(this)</code>。就进行了Actor的初始化。</p>
<pre><code class="language-java">public void initActor() {
    dispatcher.getExecutor().execute(() -&gt; tryInit(1));
}

private void tryInit(int attempt) {
    actor.init(this);
}
</code></pre>
<h4 id="tenantactor">TenantActor</h4>
<p><code>AppActor::doProcess</code>的第一个if，调用<code>::initTenantActors</code>,它初始化所有<code>TenantActor</code>。<br>
AppActor自己管理着所有的TenantActors。其<code>::getOrCreateTenantActor</code>则完成了获取和创建的工作。<br>
实现了一个懒加载的功能。</p>
<pre><code class="language-java">protected boolean doProcess(TbActorMsg msg) {
    if (!ruleChainsInitialized) {
        if (MsgType.APP_INIT_MSG.equals(msg.getMsgType())) {
            initTenantActors();
            ruleChainsInitialized = true;
        }
    }
}

private void initTenantActors() {
    PageDataIterable&lt;Tenant&gt; tenantIterator = new PageDataIterable&lt;&gt;(tenantService::findTenants, ENTITY_PACK_LIMIT);
    for (Tenant tenant : tenantIterator) {
        log.debug("[{}] Creating tenant actor", tenant.getId());
        getOrCreateTenantActor(tenant.getId())
    }
}
</code></pre>
<p>追溯<code>::getOrCreateTenantActor</code>，他会使用类型为TbActorCtx的ctx字段的<code>getOrCreateChildActor</code>，根据之前的分析我们可以直接到<code>TbActorMailbox</code>进行分析。</p>
<pre><code class="language-java">private Optional&lt;TbActorRef&gt; getOrCreateTenantActor(TenantId tenantId) {
    return Optional.ofNullable(ctx.getOrCreateChildActor(new TbEntityActorId(tenantId),
            () -&gt; DefaultActorService.TENANT_DISPATCHER_NAME,
            () -&gt; new TenantActor.ActorCreator(systemContext, tenantId),
            () -&gt; true));
}
</code></pre>
<p>显示从类型为<code>TbActorSystem</code>的<code>system</code>字段获取actor。实现上<code>DefaultTbActorSystem</code>内有一个<code>actors</code>的<code>ConcurrentMap</code>的字段用于存储系统中所有的Actor。之后就和<code>AppActor</code>创建处一致的执行流程。</p>
<pre><code class="language-java">public TbActorRef getOrCreateChildActor(TbActorId actorId, Supplier&lt;String&gt; dispatcher, Supplier&lt;TbActorCreator&gt; creator, Supplier&lt;Boolean&gt; createCondition) {
    TbActorRef actorRef = system.getActor(actorId);
    if (actorRef == null &amp;&amp; createCondition.get()) {
        return system.createChildActor(dispatcher.get(), creator.get(), selfId);
    } else {
        return actorRef;
    }
}
</code></pre>
<h4 id="rulechainactor">RuleChainActor</h4>
<p>同理<code>RuleChainActor</code>也是由<code>TenantActor</code>进行创建的。不过实际的逻辑在<code>TenantActor</code>的父类<code>RuleChainManagerActor</code>中。<br>
一般都是在<code>::init</code>方法中调用<code>::initRuleChains</code>方法.<code>initRuleChains</code>方法就会从数据库中获取所有RuleChain并初始化。</p>
<h3 id="22-负责逻辑处理的actor">2.2 负责逻辑处理的Actor</h3>
<h4 id="rulechainactor-1">RuleChainActor</h4>
<p>到了它，明显有了不一样，一下子类一下子变得简洁了。类本身只有两个方法<br>
分析一下它的父类。<code>RuleChainActor</code>→<code>RuleEngineComponentActor</code>→<code>ComponentActor</code>。<br>
其中的<code>ComponentActor::init</code>方法就调用了抽象方法<code>ComponentActor::createProcessor</code>。</p>
<pre><code class="language-java">@Override
public void init(TbActorCtx ctx) throws TbActorException {
    this.processor = createProcessor(ctx);
    initProcessor(ctx);
}
</code></pre>
<p>再向上看<code>ComponentActor</code>的父类<code>ContextAwareActor</code>就发现，<code>::process</code>变成对<code>::process</code>做了个封装。只是添加了打印日志的功能。<code>::doProcess</code>其中，只是将对应的消息委托给了对应的<code>processor</code>。</p>
<pre><code class="language-java">public boolean process(TbActorMsg msg) {
    if (log.isDebugEnabled()) {
        log.debug("Processing msg: {}", msg);
    }
    if (!doProcess(msg)) {
        log.warn("Unprocessed message: {}!", msg);
    }
    return false;
}
</code></pre>
<h4 id="rulenodeactor">RuleNodeActor</h4>
<p>这就是规则引擎最核心的部分，可以明显的推测到每个<code>TbNode</code>都对应着一个<code>RuleNodeActor</code>。<br>
不过同理，它的实际逻辑也委托给了<code>processor</code>。但是明显它的创建更加复杂。<br>
它的创建实际上是由<code>RuleChainActor</code>中的<code>processor</code>负责的，即<code>RuleChainActorMessageProcessor</code>类。</p>
<pre><code class="language-java"> public void init(TbActorCtx ctx)  {
    this.processor = createProcessor(ctx);
    initProcessor(ctx);
}

protected void initProcessor(TbActorCtx ctx) {
    processor.start(ctx);
}
</code></pre>
<p>其中的<code>::start</code>方法，而<code>::start</code>的方法则是在前文<code>TbActor</code>的父类<code>ComponentActor::init</code>中再调用<code>::initProcessor</code>中，<br>
调用的<code>RuleChainActorMessageProcessor::start</code>方法。</p>
<pre><code class="language-java">public void start(TbActorCtx context) {
    List&lt;RuleNode&gt; ruleNodeList = service.getRuleChainNodes(tenantId, entityId);
    for (RuleNode ruleNode : ruleNodeList) {
        TbActorRef ruleNodeActor = createRuleNodeActor(context, ruleNode);
        nodeActors.put(ruleNode.getId(), new RuleNodeCtx(tenantId, self, ruleNodeActor, ruleNode));
    }
    initRoutes(ruleChain, ruleNodeList);
}
</code></pre>
<p>其中从数据库中读取到所有<code>nodeActors</code>的信息并将其全部创建。<br>
再调用<code>::initRoutes</code>初始化<code>ruleChain</code>中对应的路由。</p>
<pre><code class="language-java">private void initRoutes(RuleChain ruleChain, List&lt;RuleNode&gt; ruleNodeList) {
    for (RuleNode ruleNode : ruleNodeList) {
        List&lt;EntityRelation&gt; relations = service.getRuleNodeRelations(TenantId.SYS_TENANT_ID, ruleNode.getId());
        log.trace("[{}][{}][{}] Processing rule node relations [{}]", tenantId, entityId, ruleNode.getId(), relations.size());
        if (relations.isEmpty()) {
            nodeRoutes.put(ruleNode.getId(), Collections.emptyList());
        } else {
            for (EntityRelation relation : relations) {
                nodeRoutes.computeIfAbsent(ruleNode.getId(), k -&gt; new ArrayList&lt;&gt;())
                        .add(new RuleNodeRelation(ruleNode.getId(), relation.getTo(), relation.getType()));
            }
        }
    }
}
</code></pre>
<p>能看出<code>nodeRoutes</code>接近一个邻接表的结构，构建了整个路由。至此将Actor创建的三种模式介绍清楚。</p>
<ol>
<li>由外部创建，如<code>AppActor</code>。</li>
<li>由其父Actor创建，如<code>TenantActor</code>。</li>
<li>由对应的一个<code>processor</code>字段创建，如<code>RuleChainActor</code>。</li>
</ol>
<h2 id="四结尾">四、结尾</h2>
<p>最开始分析的时候，我还不了解Actor模型，纯粹看着代码进行分析，惊叹于设计的巧妙。但是在QQ水群突然有人提及自己在改为了无锁的Actor模型，我搜索一番，原来这是一个很成熟的通用的设计了啊。自己写小项目还是喜欢<code>Executor</code>和<code>Future</code>一股脑的用。不知道下一篇要多久才更新了。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005555555555555556" data-date-updated="2025-07-19 11:09">2025-07-19 11:01</span>&nbsp;
<a href="https://www.cnblogs.com/birthcat">sheng_ri</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18992659);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18992659', targetLink: 'https://www.cnblogs.com/birthcat/p/18992659', title: '[ThingsBoard] 3. 源码解读Actor' })">举报</a>
</div>
        