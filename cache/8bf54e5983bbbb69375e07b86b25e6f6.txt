
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kFM9j5ONLe/p/18927348" title="发布于 2025-06-13 16:37">
    <span role="heading" aria-level="2">JavaScript 防抖和节流</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="概念">概念</h2>
<p>防抖（Debounce）是指在事件触发后，只有在经过设定的时间间隔内没有再次触发，事件处理器才会执行。防抖<strong>限制</strong>事件的触发时间间隔，避免事件被频繁触发。这适用于在搜索框输入建议、调整窗口大小、表单验证、表单提交等场景。</p>
<p>节流（Throttle）则是指在一定时间间隔内，不论事件触发多少次，事件处理器只执行一次。节流<strong>控制</strong>执行时间间隔，降低事件的执行频率。这适用于页面滚动加载、鼠标移动、游戏角色控制、实时数据图表更新等场景。</p>
<blockquote>
<p>注意：事件触发≠函数执行。触发在执行前。</p>
<p>比如，我反馈了一个Bug，但是该Bug不一定在被修复。</p>
</blockquote>
<blockquote>
<p>疑问：防抖和节流都可用于控制事件处理函数的执行频率，那它们能否互相替代？</p>
<p><strong>防抖是为了确保多次触发、一次执行，只关注最终状态；节流是为了确保函数的周期性执行，更关注过程中的均匀响应。</strong></p>
<p>故防抖、节流不能完全互相替代，也就是说它两的应用场景是有所侧重的。</p>
<p>比如，对于搜索框输入建议这个场景，理应使用防抖而非节流，理由：我们监听的是输入事件，且应该在用户输入完想要输入的内容后再给出建议，若使用节流，就可能在用户还没输入完成时给出了无效建议。</p>
</blockquote>
<h2 id="实现">实现</h2>
<h3 id="防抖实现">防抖实现</h3>
<p>（1）防抖开始时不调用，结束时才调用。</p>
<pre><code class="language-js">function debounce(func, delay = 0){
    let timer = null;

    return function(){
        clearTimeout(timer);
        timer = setTimeout(()=&gt;{
            func.apply(this, arguments);
        }, delay);
    }
}
</code></pre>
<p>（2）防抖开始时立即调用，结束时也调用。</p>
<pre><code class="language-js">// func 是待防抖函数
// delay 是最短执行时间间隔，单位 ms
// options 是额外配置，包括首次调用立即执行
function debounce(func, delay, options = {}) {
    let timer; // 计时器 ID
    const { leading = false } = options; // 默认首次调用不立即执行

    const debounced = function (...args) {
        // 保留执行时上下文
        const context = this;

        // 首次调用执行
        if (leading &amp;&amp; !timer) func.apply(context, args);
        
        // 控制触发时间间隔的关键点
        clearTimeout(timer);
        timer = setTimeout(()=&gt;{
            // 避免重复执行，首次调用执行了尾部延迟结束就不再执行
            if (!leading) func.apply(context, args);
            
            timer = null;
        }, delay);
    };

	// 取消防抖的功能函数
    debounced.cancel = () =&gt; {
        clearTimeout(timer);
        timer = null;
    };

    return debounced;
}
</code></pre>
<blockquote>
<p><strong>为什么要在更新 <code>timer</code> 为<code>null</code>前执行 <code>clearTimeout</code>？</strong></p>
<p>更新 <code>timer</code> 为<code>null</code>不会使得<code>timer</code>关联的计时器失效。</p>
</blockquote>
<h3 id="节流实现">节流实现</h3>
<p>（1）时间戳版本：<u>强调在节流开始时就会调用函数，节流结束时不调用</u>。</p>
<pre><code class="language-js">function throttle(func, delay = 0){
    let lastExecTime = 0;
    
    return function(){
        let context = this;
        let args = arguments;
        let remaining = delay - (Date.now() - lastExecTime);

        if(remaining &lt; 0){
            func.apply(context, args);
            lastExecTime = Date.now();
        }
    }
}
</code></pre>
<p>（2）定时器版本：<u>关注点在节流结束时再调用函数，而开始时不会调用函数</u>。</p>
<pre><code class="language-js">function throttle(func, delay = 0){
    let timer = null;
    
    return function(){
        let context = this;
        let args = arguments;

        if(!timer){
            timer = setTimeout(()=&gt;{
                timer = null;
                func.apply(context, args);
            }, delay);
        }
    }
}
</code></pre>
<p>（3）合并版本：<u>结合使用时间戳和定时器，节流开始和结束时都会执行</u>。</p>
<pre><code class="language-javascript">// option 配置项：
//  - leading：在节流开始时执行
//  - trailing：在节流结束后执行
function throttle(func, delay = 0, option = {}){
    let timer = null;
    let lastExecTime = 0;
    const { leading = true, trailing = true } = option;
    
    const throttled = function(...args) {
        const context = this;
        const remaining = delay - (Date.now() - lastExecTime);

        if(leading &amp;&amp; remaining &lt; 0) {
            lastExecTime = Date.now();
            if(timer){
                clearTimeout(timer);
                timer = null;
            }
            func.apply(context, args);
        }
        else if(trailing &amp;&amp; remaining &gt;= 0 &amp;&amp; !timer) {
            timer = setTimeout(()=&gt;{
                lastExecTime = Date.now();
                timer = null;
                func.apply(context, args);
            }, remaining);
        }
    }

    return throttled;
}
</code></pre>
<p>应用示例：</p>
<p>🌺对鼠标移动事件添加节流：</p>
<pre><code class="language-js">window.addEventListener('mousemove', throttle(function(){
    console.log('鼠标移动');
}, 1000));
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>如有错误和建议，欢迎在评论区告知！</p>
<p>本文由 <strong><a href="https://www.cnblogs.com/kFM9j5ONLe/" target="_blank">dawnkylin</a></strong> 创作，采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC
        BY-NC-SA 4.0</a> 许可协议。</p>
<p>原文链接：<a href="https://www.cnblogs.com/kFM9j5ONLe/p/18927348" target="_blank">https://www.cnblogs.com/kFM9j5ONLe/p/18927348</a>
</p><p>转载请注明出处！</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03194444444444444" data-date-updated="2025-06-13 17:23">2025-06-13 16:37</span>&nbsp;
<a href="https://www.cnblogs.com/kFM9j5ONLe">dawnkylin</a>&nbsp;
阅读(<span id="post_view_count">54</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18927348);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18927348', targetLink: 'https://www.cnblogs.com/kFM9j5ONLe/p/18927348', title: 'JavaScript 防抖和节流' })">举报</a>
</div>
        