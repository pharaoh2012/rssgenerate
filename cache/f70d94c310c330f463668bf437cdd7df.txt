
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ClownLMe/p/19026101" title="发布于 2025-08-07 00:00">
    <span role="heading" aria-level="2">逆向：x86,x64从汇编分析函数调用约定详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>网上大多教程都是对x86汇编进行分析，少有x64的，因此，本次对x86和x64的函数调用的参数传递以及函数的调用约定进行详细的分析对比和总结。<br>
（cdecl,fastcall,stdcall,vectorcall,thiscall）<br>
<mark>注意本次实验中（环境）：x86的cdecl, fastcall, stdcall代码以debug模式编译，x86的thiscall，以及x64代码均以relase模式下编译并关闭性能优化</mark></p>
<h1 id="x86-汇编分析-cdecl-fastcall-stdcallthiscall">x86 汇编分析 (cdecl, fastcall, stdcall，thiscall)</h1>
<h3 id="分析汇编的源码">分析汇编的源码：</h3>
<pre><code class="language-c">#include &lt;iostream&gt;

int __cdecl cdecl_test(int a, int b, int c, int d, int e, int f, int g) {
	char p[] = "Hello, World!";
	int result = 0;
	result += a + b + c + d + e + f + g;
	return result;
}

int __fastcall fastcall_test(int a, int b, int c, int d, int e, int f, int g) {
	char p[] = "Hello, World!";
	int result = 0;
	result += a + b + c + d + e + f + g;
	return result;
}

int __stdcall stdcall_test(int a, int b, int c, int d, int e, int f, int g) {
	char p[] = "Hello, World!";
	int result = 0;
	result += a + b + c + d + e + f + g;
	return result;
}

int main(){
	int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7;
	int result = 0;
	result = cdecl_test(a, b, c, d, e, f, g);
	printf("cdecl_test result: %d\n", result);
	result = fastcall_test(a, b, c, d, e, f, g);
	printf("fastcall_test result: %d\n", result);
	result = stdcall_test(a, b, c, d, e, f, g);
	printf("stdcall_test result: %d\n", result);
	return 0;
}
</code></pre>
<pre><code class="language-c">#include &lt;iostream&gt;

class Test {
public:
	int func(int a, int b, int c, int d, int e, int f, int g) {
		int result = 0;
		result += a + b + c + d + e + f + g;
		printf("Result: %d\n", result);
		return result;
	}
};

int main() {
	int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7;
	int result = 0;
	Test test;
	result = test.func(a, b, c, d, e, f, g);
	printf("Result: %d\n", result);
	return 0;
}
</code></pre>
<h3 id="cdecl">cdecl</h3>
<hr>
<p>传递参数<br>
<img alt="PixPin_2025-08-05_21-46-26" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235140982-1355115334.png" class="lazyload"></p>
<p>开辟栈空间，保存栈环境<br>
<img alt="PixPin_2025-08-05_22-14-58" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235211088-1777945362.png" class="lazyload"></p>
<p>恢复环境，恢复栈空间，返回<br>
<img alt="PixPin_2025-08-05_22-22-04" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235331186-205695975.png" class="lazyload"></p>
<p>平栈，保存返回值<br>
<img alt="PixPin_2025-08-05_22-20-12" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235437445-1364700299.png" class="lazyload"></p>
<h3 id="fastcall">fastcall</h3>
<hr>
<p>传递参数<br>
<img alt="PixPin_2025-08-05_22-30-09" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235452450-1776028852.png" class="lazyload"></p>
<p>开辟栈空间，保存环境<br>
<img alt="PixPin_2025-08-05_22-37-30" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235534342-643261812.png" class="lazyload"></p>
<p>恢复环境，恢复栈空间，平栈<br>
<img alt="PixPin_2025-08-05_22-41-04" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235559385-341305718.png" class="lazyload"></p>
<h3 id="stdcall">stdcall</h3>
<hr>
<p>传递参数<br>
<img alt="PixPin_2025-08-05_22-45-41" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235615458-1745685101.png" class="lazyload"></p>
<p>开辟栈空间，保存环境<br>
<img alt="PixPin_2025-08-05_22-48-34" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235625477-122048674.png" class="lazyload"></p>
<p>恢复环境，恢复栈空间，平栈<br>
<img alt="PixPin_2025-08-05_22-50-15" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235639162-1462557301.png" class="lazyload"></p>
<h3 id="thiscall">thiscall</h3>
<hr>
<p>传递参数<br>
<img alt="PixPin_2025-08-06_23-37-52" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235649170-909867663.png" class="lazyload"></p>
<p>开辟栈空间，保存环境<br>
<img alt="PixPin_2025-08-06_23-38-03" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235701144-1574193378.png" class="lazyload"></p>
<p>恢复环境，恢复栈空间，平栈<br>
<img alt="PixPin_2025-08-06_23-38-09" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235709914-285419702.png" class="lazyload"></p>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th>函数调用约定</th>
<th>参数传递方式</th>
<th>平栈方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdecl(默认)</td>
<td>push(从右到左)</td>
<td>函数外平栈</td>
</tr>
<tr>
<td>fastcall</td>
<td>ecx(参数1)，edx(参数2)，push(从右到左)</td>
<td>函数内平栈</td>
</tr>
<tr>
<td>stdcall</td>
<td>push(从右到左)</td>
<td>函数内平栈</td>
</tr>
<tr>
<td>thiscall</td>
<td>ecx(this指针)，push(从右到左)</td>
<td>函数内平栈</td>
</tr>
</tbody>
</table>
<p><strong><mark>值得注意的是：在winapi中大多是用stdcall</mark></strong></p>
<h1 id="x64-汇编分析vectorcall-thiscall">x64 汇编分析（vectorcall， thiscall）</h1>
<h3 id="分析汇编的源码-1">分析汇编的源码</h3>
<pre><code class="language-c">#include &lt;iostream&gt;

int __vectorcall test(int a, int b, int c, int d, int e, int f, int g) {
	int result = 0;
	result += a + b + c + d + e + f + g;
	printf("Result: %d\n", result);
	return result;
}

int main() {
	int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7;
	int result = 0;
	result = test(a, b, c, d, e, f, g);
	printf("Result: %d\n", result);
	return 0;
}
</code></pre>
<h3 id="vectorcall">vectorcall</h3>
<hr>
<p>传递参数<br>
<img alt="PixPin_2025-08-06_23-06-12" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235814017-1660246000.png" class="lazyload"></p>
<p>保存参数，开辟栈空间，（保存环境）<br>
<img alt="PixPin_2025-08-06_23-06-43" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235824513-1910623782.png" class="lazyload"></p>
<p>恢复栈空间<br>
<img alt="PixPin_2025-08-06_23-06-43" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2450496/202508/2450496-20250806235906576-53864509.png" class="lazyload"></p>
<h3 id="总结-1">总结</h3>
<table>
<thead>
<tr>
<th>函数调用约定</th>
<th>参数1</th>
<th>参数2</th>
<th>参数3</th>
<th>参数4</th>
<th>参数5以上</th>
<th>平栈方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>vectorcall</td>
<td>rcx</td>
<td>rdx</td>
<td>r8</td>
<td>r9</td>
<td>堆栈传递</td>
<td>函数内平栈</td>
</tr>
<tr>
<td>vectorcall(浮点参数)</td>
<td>xmm0</td>
<td>xmm1</td>
<td>xmm2</td>
<td>xmm3</td>
<td>堆栈传递</td>
<td>函数内平栈</td>
</tr>
<tr>
<td>thiscall</td>
<td>rcx(this)</td>
<td>rdx</td>
<td>r8</td>
<td>r9</td>
<td>堆栈传递</td>
<td>函数内平栈</td>
</tr>
</tbody>
</table>
<p><code>我这里给出thiscall,vectorcall的浮点表现形式，thiscall，因为在底层默认函数第一个参数传递this指针，这两种函数调用约定在x64中本质是一样的</code></p>
<h1 id="以上出现错误可评论区提醒">以上出现错误可评论区提醒！</h1>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-07 00:01">2025-08-07 00:00</span>&nbsp;
<a href="https://www.cnblogs.com/ClownLMe">ClownLMe</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19026101);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19026101', targetLink: 'https://www.cnblogs.com/ClownLMe/p/19026101', title: '逆向：x86,x64从汇编分析函数调用约定详解' })">举报</a>
</div>
        