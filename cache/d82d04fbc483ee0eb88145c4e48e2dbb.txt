
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18800559" title="发布于 2025-03-30 14:03">
    <span role="heading" aria-level="2">Java24发布，精心总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Java 24作为2025年3月发布的最新版本，延续了Java平台每半年发布一次的节奏，带来了24项重要改进。本文将按照核心改进领域分类，详细解析每个特性的技术原理和实际价值，帮助开发者全面了解这一版本的能力边界和应用场景。</p>
<p>不过Java24是自Java 21 以来的第三个非长期支持版本，下一个长期支持版是&nbsp;<strong>Java 25</strong>，预计今年 9 月份发布。</p>
<h2 id="性能优化">性能优化</h2>
<h3 id="分代shenandoah垃圾回收器提升吞吐量与响应速度">分代Shenandoah垃圾回收器提升吞吐量与响应速度</h3>
<p><a href="https://openjdk.org/jeps/404" target="_blank" rel="noopener nofollow"><strong>JEP 404: Generational Shenandoah</strong></a></p>
<p>该JEP主要是提供了一个实验性的分代模式，将分代概念引入Shenandoah GC，通过区分新生代和老年代实现了显著的性能突破。传统Shenandoah作为全堆回收器，每次GC都需要扫描整个堆空间，而分代版本通过以下机制优化：</p>
<ul>
<li><strong>新生代专用回收策略</strong>：采用复制算法快速回收短生命周期对象，减少老年代扫描频率</li>
<li><strong>卡表(Card Table)优化</strong>：精确记录老年代到新生代的跨代引用，降低GC停顿时间30%以上</li>
<li><strong>并行标记增强</strong>：在并发标记阶段优先处理新生代区域，使平均GC暂停时间控制在2ms以内 实测表明，在16GB堆内存的微服务场景下，分代Shenandoah相比原版吞吐量提升40%，同时保持亚毫秒级的最大暂停时间，成为低延迟应用的理想选择。</li>
</ul>
<h3 id="紧凑对象头设计减少内存占用">紧凑对象头设计减少内存占用</h3>
<p><a href="https://openjdk.org/jeps/450" target="_blank" rel="noopener nofollow"><strong>JEP 450: Compact Object Headers</strong></a></p>
<p>重构了Java对象的内存布局，将 HotSpot JVM中的对象标头大小从96到128位减少到64位。Java程序中的对象往往很小，作为 Project Lilliput的一部分进行的实验表明，许多工作负载的平均对象大小为 256 到 512 位（32 到 64 字节）。这意味着超过 20% 的实时数据可以单独由对象标头获取。因此，即使对象标头大小略有改进，也可以显著减少占用空间、数据局部性并减轻 GC压力。在实际应用程序中试用过Project Lilliput的早期采用者证实，内存占用通常会减少10%–20%。关键技术突破包括：</p>
<ul>
<li><strong>压缩锁标志位</strong>：将原有的2字节Mark Word压缩为1字节，保留基本锁状态和hashcode信息</li>
<li><strong>类型指针优化</strong>：使用32位偏移量替代64位类指针，配合压缩类空间(Compressed Class Space)工作</li>
<li><strong>对齐填充智能分配</strong>：根据CPU缓存行特性动态调整对象填充策略 在包含百万级对象的电商应用中，该特性减少堆内存使用15%，同时由于更好的缓存局部性，使整体吞吐量提升8%。需要注意的是，该特性要求所有依赖JOL(Java Object Layout)工具的分析代码进行相应适配。</li>
</ul>
<h3 id="g1垃圾回收器屏障优化提高效率">G1垃圾回收器屏障优化提高效率</h3>
<p><a href="https://openjdk.org/jeps/475" target="_blank" rel="noopener nofollow"><strong>JEP 475: Late Barrier Expansion for G1</strong></a></p>
<p>该特性主要是将Late Barrier Expansion引进到G1中。Barrier expansion是指在垃圾回收过程中插入或生成额外代码（称为“屏障”）以管理内存并确保垃圾回收的正确性。这些屏障通常被插入到字节码中的特定位置，例如在内存访问之前或之后，以执行以下任务：</p>
<ul>
<li>记住写操作：跟踪对象的更改，这有助于垃圾回收器识别需要扫描的堆的部分。例如，写屏障（write barrier）会在每次存储操作之前执行，记录哪些对象被修改，从而帮助垃圾回收器维护对象的可达性信息。</li>
<li>保持一致性：确保程序对内存的视图与垃圾回收器的视图保持一致，特别是在并发垃圾回收阶段。例如，读屏障（read barrier）会在读取操作之前检查指针是否指向堆内存，并记录这些操作，以防止垃圾回收器误判对象的可达性。</li>
<li>处理引用：管理对象之间的引用，特别是在压缩或迁移阶段。例如，在垃圾回收的增量收集中，屏障可以阻止指向未分配空间（fromspace）的指针进入寄存器，从而避免垃圾回收器无法追踪到这些对象。</li>
</ul>
<p>Early barrier expansion的含义是这些屏障在编译过程的早期插入或生成，而如果在过程的后期进行（正如JEP所提议的），则可以实现更优化的放置，并可能减少这些屏障相关的开销，具体为：</p>
<ul>
<li><strong>动态屏障插入</strong>：在JIT编译的优化阶段而非解析阶段插入写屏障，基于实际使用模式生成最小化屏障代码</li>
<li><strong>条件屏障消除</strong>：通过<a href="https://www.seven97.top/java/jvm/01-jvmbasic3-jvmmemorystructure.html#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener nofollow">逃逸分析</a>识别不需要屏障的内存操作，在安全情况下完全省略屏障</li>
<li><strong>SIMD屏障优化</strong>：对数组批量操作生成向量化屏障指令，提升批量写操作的吞吐量 基准测试显示，该优化使G1在写密集型负载下的吞吐量提升12%，同时减少JIT编译代码大小5-7%。对于使用大量<code>ConcurrentHashMap</code>或<code>CopyOnWriteArrayList</code>的并发应用收益尤为明显。</li>
</ul>
<h2 id="安全性增强">安全性增强</h2>
<h3 id="新增密钥派生函数api支持现代加密标准">新增密钥派生函数API支持现代加密标准</h3>
<p><a href="https://openjdk.org/jeps/478" target="_blank" rel="noopener nofollow"><strong>JEP 478: Key Derivation Functions API</strong> </a>引入了符合NIST SP 800-56C标准的密钥派生实现。</p>
<p>随着量子计算领域的进步，传统加密算法变得更容易受到实际攻击。因此，Java平台必须整合后量子密码学（PQC），以抵御这些威胁。Java的长期目标是最终实现混合公钥加密（HPKE），以便无缝过渡到量子安全加密。JDK 21中包含的<a href="https://openjdk.org/jeps/452" target="_blank" rel="noopener nofollow">KEM API（JEP 452）</a>是HPKE的一个组成部分，标志着Java朝着HPKE迈出的第一步，并为后量子挑战做好了准备。该JEP提出了HPKE的另一个组成部分，作为这一方向上的下一步：密钥派生函数（KDFs）的API。</p>
<p>使用示例如下：</p>
<pre><code class="language-java">// 示例：使用HKDF-SHA256从主密钥派生会话密钥 
KeyDerivationFunction kdf = KeyDerivationFunctions.of("HKDF-SHA256"); 
SecretKey sessionKey = kdf.deriveKey(masterKey, 
	"SessionKey".getBytes(StandardCharsets.UTF_8),
	256, // 密钥长度     
	new byte[32] // 可选盐值 );
</code></pre>
<p>该API支持：</p>
<ul>
<li><strong>HKDF</strong>：基于HMAC的提取-扩展密钥派生框架</li>
<li><strong>PBKDF2</strong>：密码-Based密钥派生，替代已废弃的<code>PBEKeySpec</code></li>
<li><strong>Argon2</strong>：抗侧信道攻击的内存困难型算法 特别在微服务间TLS通信场景中，开发者现在可以标准化密钥派生流程，避免各服务实现不一致导致的安全隐患。</li>
</ul>
<blockquote>
<p>由于是preview特性，需要执行的时候添加<code>--enable-preview</code>参数</p>
</blockquote>
<h3 id="永久禁用安全管理器">永久禁用安全管理器</h3>
<p><a href="https://openjdk.org/jeps/486" target="_blank" rel="noopener nofollow">JEP 486: Permanently Disable the Security Manager</a></p>
<p>安全性管理器（Security Manager）并不是Java客户端代码的主要安全手段，也极少用于服务器端代码。此外，维护它成本高昂。因此，在Java 17中通过<a href="https://openjdk.org/jeps/411" target="_blank" rel="noopener nofollow">JEP 411: Deprecate the Security Manager for Removal</a>将其弃用以备移除。本特性则完全禁止开发者启用安全性管理器，Security Manager API将在未来的版本中被移除。</p>
<h3 id="后量子加密技术前瞻性支持">后量子加密技术前瞻性支持</h3>
<p><a href="https://openjdk.org/jeps/496" target="_blank" rel="noopener nofollow">JEP 496:Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism</a></p>
<p>引入了三种抗量子计算攻击的算法：</p>
<ol>
<li><strong>ML-KEM</strong>（原CRYSTALS-Kyber）：基于格理论的密钥封装机制</li>
<li><strong>ML-DSA</strong>（原CRYSTALS-Dilithium）：数字签名算法</li>
<li><strong>SLH-DSA</strong>：基于哈希的签名方案</li>
</ol>
<pre><code class="language-java">// 生成抗量子密钥对示例 
KeyPairGenerator kpg = KeyPairGenerator.getInstance("ML-DSA"); 
kpg.initialize(new MLDSAParameterSpec(MLDSAParameterSpec.ML_DSA_65)); 
KeyPair keyPair = kpg.generateKeyPair();
</code></pre>
<p>``<br>
虽然这些算法尚未进入最终标准，但预览版允许金融、政务等敏感领域提前进行技术验证和性能测试，为即将到来的量子计算时代做好准备。</p>
<h2 id="语言特性">语言特性</h2>
<h3 id="作用域值scoped-values">作用域值（Scoped Values）</h3>
<blockquote>
<p>JDK19的<a href="https://openjdk.org/jeps/428" target="_blank" rel="noopener nofollow">JEP 428: Structured Concurrency (Incubator)</a>作为第一次incubator<br>
JDK20的<a href="https://openjdk.org/jeps/437" target="_blank" rel="noopener nofollow">JEP 437: Structured Concurrency (Second Incubator)</a>作为第二次incubator<br>
JDK21的<a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener nofollow">JEP 453: Structured Concurrency (Preview)</a>作为首次preview<br>
JDK22的<a href="https://openjdk.org/jeps/462" target="_blank" rel="noopener nofollow">JEP 462: Structured Concurrency (Second Preview)</a>作为第二次preview<br>
JDK23的<a href="https://openjdk.org/jeps/480" target="_blank" rel="noopener nofollow">JEP 480: Structured Concurrency (Third Preview)</a>作为第三次preview<br>
JDK24则作为第四次preview，与JDK23不同的是callWhere以及runWhere方法从ScopedValue类中移除，可以使用ScopedValue.where()再链式调用run(Runnable)或者call(Callable)</p>
</blockquote>
<p><strong>并发编程模型革新</strong>：</p>
<pre><code class="language-java">final static ScopedValue&lt;User&gt; CURRENT_USER = ScopedValue.newInstance(); 
void processRequest(Request req) {     
	ScopedValue.where(CURRENT_USER, fetchUser(req)).run(() -&gt; handleRequest());
} 
void handleRequest() {     
	User user = CURRENT_USER.get(); // 线程内安全访问     
	// ...业务逻辑 
}
</code></pre>
<p><strong>技术对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadLocal</th>
<th>ScopedValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存泄漏风险</td>
<td>高</td>
<td>零</td>
</tr>
<tr>
<td>子线程继承</td>
<td>需显式传递</td>
<td>自动继承</td>
</tr>
<tr>
<td>性能开销</td>
<td>约15ns/访问</td>
<td>约3ns/访问</td>
</tr>
</tbody>
</table>
<h3 id="虚拟线程的同步而不固定平台线程">虚拟线程的同步而不固定平台线程</h3>
<p><a href="https://openjdk.org/jeps/491" target="_blank" rel="noopener nofollow">JEP 491: Synchronize Virtual Threads without Pinning</a> 优化了虚拟线程与&nbsp;<code>synchronized</code>&nbsp;的工作机制。</p>
<p>JDK21引入虚拟线程时还有个pinning的问题，就是当虚拟线程在其载体上运行同步代码块时，它无法从载体上卸载。比如：</p>
<pre><code class="language-java">class CustomerCounter {
    private final StoreRepository storeRepo;
    private int customerCount;
    CustomerCounter(StoreRepository storeRepo) {
        this.storeRepo = storeRepo;
        customerCount = 0;
    }
    synchronized void customerEnters() {
        if (customerCount &lt; storeRepo.fetchCapacity()) {
            customerCount++;
        }
    }
    synchronized void customerExits() {
        customerCount--;
    }
}
</code></pre>
<blockquote>
<p>如果是单纯调用storeRepo.fetchCapacity()则没问题，虚拟线程会从其载体unmount，释放平台线程给其他虚拟线程mount；但是如果是调用customerEnters，它用synchronized修饰则JVM会将该虚拟线程pin住防止其被unmount，这样子的话虚拟线程与平台线程都会blocked，直到fetchCapacity方法返回。</p>
</blockquote>
<p>之所以pinning是因为synchronized依赖于monitors来确保它们只能由单个线程同时进入。在进入synchronized块之前，线程必须获取与实例相关联的monitor。JVM在平台线程级别跟踪这些monitor的所有权，而不是在虚拟线程级别跟踪。基于这些信息，假设不存在pinning，理论上，虚拟线程#1可以在synchronized块中间卸载，而虚拟线程#2可以装载到相同的平台线程上，并继续执行该synchronized块，因为承载线程是相同的，仍然持有对象的monitor。</p>
<p>从Java 24开始，虚拟线程可以获取、持有和释放监视器，而无需绑定到其载体线程。这意味着由于线程pinning而切换到不同的锁机制已不再是必需的。从现在起，无论是使用虚拟线程还是其他方法，性能表现都将相当一致。</p>
<p>在少数情况下，虚拟线程仍然会被pinning，其中一个情况是当它调用本地代码并返回到执行阻塞操作的Java代码时。在这种情况下，JDK Flight Recorder（JFR）会记录一个jdk.VirtualThreadPinned事件，如果要跟踪这些情况，可以启用JFR。</p>
<h3 id="灵活构造函数体">灵活构造函数体</h3>
<p><a href="https://openjdk.org/jeps/492" target="_blank" rel="noopener nofollow">JEP 492 Flexible Constructor Bodies (Third Preview)</a></p>
<blockquote>
<p>JDK22的<a href="https://openjdk.org/jeps/447" target="_blank" rel="noopener nofollow">JEP 447: Statements before super(...) (Preview)</a>作为第一次preview<br>
JDK23的<a href="https://openjdk.org/jeps/482" target="_blank" rel="noopener nofollow">JEP 482: Flexible Constructor Bodies (Second Preview)</a>作为第二次preview<br>
JDK24作为第三次preview</p>
</blockquote>
<p>灵活的构造函数体解决了这一问题，它允许在构造函数体内，在调用 super(..) 或 this(..) 之前编写语句，这些语句可以初始化字段，但不能引用正在构造的实例。这样可以防止在父类构造函数中调用子类方法时，子类的字段未被正确初始化，增强了类构造的可靠性。</p>
<p>这一特性解决了之前 Java 语法限制了构造函数代码组织的问题，让开发者能够更自由、更自然地表达构造函数的行为，例如在构造函数中直接进行参数验证、准备和共享，而无需依赖辅助方法或构造函数，提高了代码的可读性和可维护性。</p>
<pre><code class="language-java">class Person {
    private final String name;
    private int age;

    public Person(String name, int age) {
        if (age &lt; 0) {
            throw new IllegalArgumentException("Age cannot be negative.");
        }
        this.name = name; 
        this.age = age;
        // ... 其他初始化代码
    }
}

class Employee extends Person {
    private final int employeeId;

    public Employee(String name, int age, int employeeId) {
        this.employeeId = employeeId; // 在调用父类构造函数之前初始化字段
        super(name, age); // 调用父类构造函数
        // ... 其他初始化代码
    }
}
</code></pre>
<h3 id="原始类型模式匹配">原始类型模式匹配</h3>
<p><a href="https://openjdk.org/jeps/488" target="_blank" rel="noopener nofollow">JEP 488: Primitive Types in Patterns, instanceof, and switch (Second Preview)</a></p>
<blockquote>
<p>JDK19的<a href="https://openjdk.org/jeps/405" target="_blank" rel="noopener nofollow">JEP 405: Record Patterns (Preview)</a>将Record的模式匹配作为第一次preview<br>
JDK20的<a href="https://openjdk.org/jeps/432" target="_blank" rel="noopener nofollow">JEP 432: Record Patterns (Second Preview)</a>作为Record模式匹配第二次preview<br>
JDK21的<a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener nofollow">JEP 440: Record Patterns</a>则将Record模式匹配正式发布<br>
JDK23的<a href="https://openjdk.org/jeps/455" target="_blank" rel="noopener nofollow">JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview)</a>将原始类型的匹配作为第一次preview<br>
JDK24作为第二次preview</p>
</blockquote>
<p><strong>技术实现</strong>：</p>
<pre><code class="language-java">// 传统类型检查与转换 
if (obj instanceof Integer) {     
	int value = ((Integer)obj).intValue();     
	System.out.println(value * 2); 
} 

// Java 24新模式 
if (obj instanceof int value) {     
	System.out.println(value * 2); 
	// 自动拆箱为原始类型 
}
</code></pre>
<p><strong>底层优化</strong>：</p>
<ol>
<li>字节码层面消除冗余的类型转换指令</li>
<li>模式变量直接绑定到原始类型而非包装类</li>
<li>JIT编译器可进行更激进的标量替换优化</li>
</ol>
<p><strong>性能影响</strong>：</p>
<ul>
<li>数值计算密集型代码性能提升8-12%</li>
<li>减少50%的临时对象分配</li>
</ul>
<h2 id="工具链增强">工具链增强</h2>
<h3 id="流收集器">流收集器</h3>
<p>Stream Gatherers API（JEP 461扩展）</p>
<p>流收集器&nbsp;<code>Stream::gather(Gatherer)</code>&nbsp;是一个强大的新特性，它允许开发者定义自定义的中间操作，从而实现更复杂、更灵活的数据转换。<code>Gatherer</code>&nbsp;接口是该特性的核心，它定义了如何从流中收集元素，维护中间状态，并在处理过程中生成结果。例如，可以使用&nbsp;<code>Stream::gather</code>&nbsp;实现滑动窗口、自定义规则的去重、或者更复杂的状态转换和聚合。</p>
<p><strong>复杂流处理示例</strong>：</p>
<pre><code class="language-java">List&lt;Order&gt; orders = ...; 
List&lt;Order&gt; window = orders.stream().gather(Gatherers.windowSliding(5)) // 5元素滑动窗口     
.filter(window -&gt; window.stream().mapToDouble(Order::amount).average().orElse(0) &gt; 1000)
.flatMap(List::stream)
.toList();
</code></pre>
<p><strong>新增内置Gatherers</strong>：</p>
<ol>
<li><code>fold()</code>：实现可变状态聚合</li>
<li><code>scan()</code>：生成中间结果的流</li>
<li><code>fixedWindow()</code>：固定大小批处理</li>
</ol>
<p><strong>性能特性</strong>：</p>
<ul>
<li>比传统collect操作减少40%的中间集合分配</li>
<li>支持短路操作优化</li>
</ul>
<h3 id="向量api第九次孵化">向量API（第九次孵化）</h3>
<blockquote>
<p>JDK16引入了<a href="https://openjdk.org/jeps/338" target="_blank" rel="noopener nofollow">JEP 338: Vector API (Incubator)</a>提供了jdk.incubator.vector来用于矢量计算<br>
JDK17进行改进并作为第二轮的incubator<a href="https://openjdk.org/jeps/414" target="_blank" rel="noopener nofollow">JEP 414: Vector API (Second Incubator)</a><br>
JDK18的<a href="https://openjdk.org/jeps/417" target="_blank" rel="noopener nofollow">JEP 417: Vector API (Third Incubator)</a>进行改进并作为第三轮的incubator<br>
JDK19的<a href="https://openjdk.org/jeps/426" target="_blank" rel="noopener nofollow">JEP 426:Vector API (Fourth Incubator)</a>作为第四轮的incubator<br>
JDK20的<a href="https://openjdk.org/jeps/438" target="_blank" rel="noopener nofollow">JEP 438: Vector API (Fifth Incubator)</a>作为第五轮的incubator<br>
JDK21的<a href="https://openjdk.org/jeps/448" target="_blank" rel="noopener nofollow">JEP 448: Vector API (Sixth Incubator)</a>作为第六轮的incubator<br>
JDK22的<a href="https://openjdk.org/jeps/460" target="_blank" rel="noopener nofollow">JEP 460: Vector API (Seventh Incubator)</a>作为第七轮的incubator<br>
JDK23的<a href="https://openjdk.org/jeps/469" target="_blank" rel="noopener nofollow">JEP 469: Vector API (Eighth Incubator)</a>作为第八轮incubator<br>
JDK24则作为第九轮incubator，与JDK23相比做了一些变动：比如引入了一个新的基于值的类Float16，用于表示IEEE 754二进制16格式的16位浮点数。</p>
</blockquote>
<p><strong>SIMD编程模型</strong>：</p>
<pre><code class="language-java">// 计算两个浮点数组的点积 
void vectorComputation(float[] a, float[] b, float[] c) {     
	for (int i = 0; i &lt; a.length; i += FloatVector.SPECIES_512.length()) {         
		var va = FloatVector.fromArray(FloatVector.SPECIES_512, a, i);         
		var vb = FloatVector.fromArray(FloatVector.SPECIES_512, b, i);         
		var vc = va.mul(vb)
			.add(va.lanewise(VectorOperators.POW, 2))
			.add(vb.lanewise(VectorOperators.POW, 2));         
		vc.intoArray(c, i);     
	} 
}
</code></pre>
<p><strong>硬件加速支持</strong>：</p>
<table>
<thead>
<tr>
<th>指令集</th>
<th>支持操作</th>
<th>加速比</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVX-512</td>
<td>8x双精度浮点并行</td>
<td>6.8x</td>
</tr>
<tr>
<td>NEON</td>
<td>4x单精度浮点并行</td>
<td>3.2x</td>
</tr>
<tr>
<td>SVE</td>
<td>可变长度向量操作</td>
<td>4.5x</td>
</tr>
</tbody>
</table>
<h3 id="结构化并发">结构化并发</h3>
<p><a href="https://openjdk.org/jeps/499" target="_blank" rel="noopener nofollow">JEP 499: Structured Concurrency (Fourth Preview)</a></p>
<blockquote>
<p>JDK19的<a href="https://openjdk.org/jeps/428" target="_blank" rel="noopener nofollow">JEP 428: Structured Concurrency (Incubator)</a>作为第一次incubator<br>
JDK20的<a href="https://openjdk.org/jeps/437" target="_blank" rel="noopener nofollow">JEP 437: Structured Concurrency (Second Incubator)</a>作为第二次incubator<br>
JDK21的<a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener nofollow">JEP 453: Structured Concurrency (Preview)</a>作为首次preview<br>
JDK22的<a href="https://openjdk.org/jeps/462" target="_blank" rel="noopener nofollow">JEP 462: Structured Concurrency (Second Preview)</a>作为第二次preview<br>
JDK23的<a href="https://openjdk.org/jeps/480" target="_blank" rel="noopener nofollow">JEP 480: Structured Concurrency (Third Preview)</a>作为第三次preview<br>
JDK24作为第四次preview</p>
</blockquote>
<p>JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>
<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>
<p><strong>错误处理改进</strong>：</p>
<pre><code class="language-java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {     
	Future&lt;String&gt; user = scope.fork(() -&gt; fetchUser());     
	Future&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());          
	scope.join(); // 等待所有子任务     
	return new Response(user.resultNow(), order.resultNow()); // 自动处理取消和异常传播
} 
</code></pre>
<p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>
<p><strong>新增特性</strong>：</p>
<ol>
<li>deadline支持：<code>scope.withDeadline(Instant.now().plusSeconds(5))</code></li>
<li>嵌套scope的层次化取消</li>
<li>与虚拟线程深度集成</li>
</ol>
<h2 id="开发者体验优化">开发者体验优化</h2>
<h3 id="提前类加载和链接">提前类加载和链接</h3>
<p><a href="https://openjdk.org/jeps/483" target="_blank" rel="noopener nofollow">JEP 483: Ahead-of-Time Class Loading &amp; Linking</a></p>
<p>在传统 JVM 中，应用在每次启动时需要动态加载和链接类。这种机制对启动时间敏感的应用（如微服务或无服务器函数）带来了显著的性能瓶颈。该特性通过缓存已加载和链接的类，显著减少了重复工作的开销，显著减少 Java 应用程序的启动时间。该特性通过Ahead-of-Time Cache来存储已经读取、解析、加载和链接的类。</p>
<p>这个优化是零侵入性的，对应用程序、库或框架的代码无需任何更改，启动也方式保持一致，仅需添加相关 JVM 参数（如&nbsp;<code>-XX:+ClassDataSharing</code>）。</p>
<ul>
<li>首先运行application来记录AOT配置:</li>
</ul>
<pre><code class="language-shell">java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf -cp app.jar com.example.App ...
</code></pre>
<ul>
<li>接着使用该配置来创建AOT缓存：</li>
</ul>
<pre><code class="language-shell">java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf -XX:AOTCache=app.aot -cp app.jar
</code></pre>
<ul>
<li>最后使用AOT缓存启动：</li>
</ul>
<pre><code class="language-shell">java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
</code></pre>
<p>AOT缓存将读取、解析、加载和链接（通常在程序执行期间即时完成）的任务提前到缓存创建的早期阶段。因此，在执行阶段，程序启动速度更快，因为其类可以从缓存中快速访问。其性能提升可以高达 42%。</p>
<h3 id="类文件-api">类文件 API</h3>
<p><a href="484" target="_blank" rel="noopener nofollow">JEP 484: Class-File API</a></p>
<blockquote>
<p>JDK22的<a href="https://openjdk.org/jeps/457" target="_blank" rel="noopener nofollow">JEP 457: Class-File API (Preview)</a>提供了一个用于解析、生成和转换 Java 类文件的标准 API<br>
JDK23的<a href="https://openjdk.org/jeps/466" target="_blank" rel="noopener nofollow">JEP 466: Class-File API (Second Preview)</a>则作为第二次preview<br>
JDK24则转为正式版本发布</p>
</blockquote>
<p>类文件 API 的目标是提供一套标准化的 API，用于解析、生成和转换 Java 类文件，取代过去对第三方库（如 ASM）在类文件处理上的依赖。</p>
<p>使用Class-File API如下：</p>
<pre><code class="language-java">//&nbsp;创建一个 ClassFile 对象，这是操作类文件的入口。  
ClassFile&nbsp;cf&nbsp;=&nbsp;ClassFile.of();  
//&nbsp;解析字节数组为&nbsp;ClassModel  
ClassModel&nbsp;classModel&nbsp;=&nbsp;cf.parse(bytes);  
  
//&nbsp;构建新的类文件，移除以&nbsp;"debug"&nbsp;开头的所有方法  
byte[]&nbsp;newBytes&nbsp;=&nbsp;cf.build(classModel.thisClass().asSymbol(),  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classBuilder&nbsp;-&gt;&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;遍历所有类元素  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(ClassElement&nbsp;ce&nbsp;:&nbsp;classModel)&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断是否为方法&nbsp;且&nbsp;方法名以&nbsp;"debug"&nbsp;开头  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(ce&nbsp;instanceof&nbsp;MethodModel&nbsp;mm  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;mm.methodName().stringValue().startsWith("debug")))&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加到新的类文件中  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classBuilder.with(ce);  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
</code></pre>
<h3 id="简化源文件启动第四次预览">简化源文件启动（第四次预览）</h3>
<p><a href="https://openjdk.org/jeps/495" target="_blank" rel="noopener nofollow">JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)</a></p>
<p>没有使用该特性之前定义一个 <code>main</code> 方法：</p>
<pre><code class="language-java">public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
</code></pre>
<p>使用该新特性之后定义一个 <code>main</code> 方法：</p>
<pre><code class="language-java">class HelloWorld {
    void main() {
        System.out.println("Hello, World!");
    }
}
</code></pre>
<p>进一步简化（未命名的类允许我们省略类名）</p>
<pre><code class="language-java">void main() {
   System.out.println("Hello, World!");
}
</code></pre>
<p>这里连类都没有了，隐式声明类继承自 Object，不实现接口，并且不能在源代码中按名称引用。此外，实例主方法也不再强制要求它们是 static 或 public 的，并且不带参数的方法也可以作为有效的程序入口点。</p>
<p><strong>编译执行变化</strong>：</p>
<ol>
<li>隐式<code>class</code>生成规则优化</li>
<li>支持包声明和模块指令</li>
<li>错误消息指向用户代码行而非生成代码</li>
</ol>
<h3 id="使用sunmiscunsafe内存访问方法时发出警告">使用<code>sun.misc.Unsafe</code>内存访问方法时发出警告</h3>
<p><a href="https://openjdk.org/jeps/498" target="_blank" rel="noopener nofollow">JEP 498: Warn upon Use of Memory-Access Methods in sun.misc.Unsafe</a></p>
<blockquote>
<p>JDK9的<a href="https://openjdk.org/jeps/193" target="_blank" rel="noopener nofollow">JEP 193: Variable Handles</a>引入了VarHandle API用于替代sun.misc.Unsafe<br>
JDK14的<a href="https://openjdk.org/jeps/370" target="_blank" rel="noopener nofollow">JEP 370: Foreign-Memory Access API (Incubator)</a>引入了Foreign-Memory Access API作为incubator<br>
JDK15的<a href="https://openjdk.org/jeps/383" target="_blank" rel="noopener nofollow">JEP 383: Foreign-Memory Access API (Second Incubator)</a>Foreign-Memory Access API作为第二轮incubator<br>
JDK16的<a href="https://openjdk.org/jeps/393" target="_blank" rel="noopener nofollow">JEP 393: Foreign-Memory Access API (Third Incubator)</a>作为第三轮，它引入了Foreign Linker API (JEP&nbsp;<a href="https://openjdk.org/jeps/389" target="_blank" rel="noopener nofollow">389</a>)<br>
FFM API在JDK 17的<a href="https://openjdk.org/jeps/412" target="_blank" rel="noopener nofollow">JEP 412: Foreign Function &amp; Memory API (Incubator)</a>作为incubator引入<br>
FFM API在JDK 18的<a href="https://openjdk.org/jeps/419" target="_blank" rel="noopener nofollow">JEP 419: Foreign Function &amp; Memory API (Second Incubator)</a>作为第二轮incubator<br>
JDK19的<a href="https://openjdk.org/jeps/424" target="_blank" rel="noopener nofollow">JEP 424: Foreign Function &amp; Memory API (Preview)</a>则将FFM API作为preview API<br>
JDK20的<a href="https://openjdk.org/jeps/434" target="_blank" rel="noopener nofollow">JEP 434: Foreign Function &amp; Memory API (Second Preview)</a>作为第二轮preview<br>
JDK21的<a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener nofollow">JEP 442: Foreign Function &amp; Memory API (Third Preview)</a>作为第三轮preview<br>
JDK22的<a href="https://openjdk.org/jeps/454" target="_blank" rel="noopener nofollow">JEP 454: Foreign Function &amp; Memory API</a>则正式发布此特性<br>
JDK23的<a href="https://openjdk.org/jeps/471" target="_blank" rel="noopener nofollow">JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal</a>废弃sun.misc.Unsafe，以便后续版本移除</p>
</blockquote>
<p>JDK24默认情况下将在首次使用任何内存访问方法时发出警告，无论这些方法是直接调用还是通过反射调用。也就是说，无论使用了哪些内存访问方法，以及任何特定方法被调用的次数如何，最多只会发出一次警告。这将提醒应用程序开发者和用户即将移除这些方法，并需要升级库。</p>
<p>这些不安全的方法已有安全高效的替代方案：</p>
<ul>
<li><code>java.lang.invoke.VarHandle</code>&nbsp;：JDK 9 (JEP 193) 中引入，提供了一种安全有效地操作堆内存的方法，包括对象的字段、类的静态字段以及数组元素。</li>
<li><code>java.lang.foreign.MemorySegment</code>&nbsp;：JDK 22 (JEP 454) 中引入，提供了一种安全有效地访问堆外内存的方法，有时会与&nbsp;<code>VarHandle</code>&nbsp;协同工作。</li>
</ul>
<p>这两个类是 Foreign Function &amp; Memory API（外部函数和内存 API） 的核心组件，分别用于管理和操作堆外内存。Foreign Function &amp; Memory API 在 JDK 22 中正式成为标准特性。</p>
<h2 id="升级建议">升级建议</h2>
<p>Java 24作为非LTS版本，建议根据具体场景评估升级策略：</p>
<p><strong>推荐升级场景</strong>：</p>
<ul>
<li>需要分代Shenandoah的实时交易系统</li>
<li>处理敏感数据的金融应用（利用新加密API）</li>
<li>AI推理服务（受益于向量API优化）</li>
</ul>
<p><strong>暂缓升级场景</strong>：</p>
<ul>
<li>仍依赖安全管理器的遗留系统</li>
<li>使用sun.misc.Unsafe的底层库（如Netty、Cassandra需等待适配版本）</li>
<li>已稳定运行且无性能瓶颈的长期服务</li>
</ul>
<h2 id="结语">结语</h2>
<p>Java 24通过分代Shenandoah、紧凑对象头等特性继续巩固其在性能敏感领域的地位，同时借助后量子加密等创新保持技术前瞻性。虽然非LTS版本的生产部署需要谨慎评估，但其在各方面的改进，无疑也为Java生态注入了新的活力。</p>
<h2 id="其它java-新特性系列">其它Java 新特性系列</h2>
<p>如果你想系统了解 Java 8 以及之后版本的新特性，可以在我的网站上阅读对应的文章：www.seven97.top</p>
<p><img src="https://files.mdnice.com/user/73351/d8590936-5429-4691-9d4b-77acf87aebed.png" alt="" loading="lazy"></p>
<h2 id="往期推荐">往期推荐</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qb4XACLMRNgsNdi5DdevhA" target="_blank" rel="noopener nofollow">《SpringBoot》EasyExcel实现百万数据的导入导出</a></li>
<li><a href="https://mp.weixin.qq.com/s/MgC_iK536FxTLgm7CJMlqQ" target="_blank" rel="noopener nofollow">《SpringBoot》史上最全SpringBoot相关注解介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s/-3H6VyhKfl9byf6ifnk1ug" target="_blank" rel="noopener nofollow">Spring框架IoC核心详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/O0W6vCuqQfeAH0UB7elpeA" target="_blank" rel="noopener nofollow">万字长文带你窥探Spring中所有的扩展点</a></li>
<li><a href="https://mp.weixin.qq.com/s/tATN-g66NyW5BzyiHWoRkA" target="_blank" rel="noopener nofollow">如何实现一个通用的接口限流、防重、防抖机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/gg6N6e90ZtbA0MH4KIEHlg" target="_blank" rel="noopener nofollow">万字长文带你深入Redis底层数据结构</a></li>
<li><a href="https://mp.weixin.qq.com/s/QhOFMEJWjIJM0jVFsCfJdA" target="_blank" rel="noopener nofollow">volatile关键字最全原理剖析</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010974405016203703" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-30 14:04">2025-03-30 14:03</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18800559" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18800559);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18800559', targetLink: 'https://www.cnblogs.com/seven97-top/p/18800559', title: 'Java24发布，精心总结' })">举报</a>
</div>
        