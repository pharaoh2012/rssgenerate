
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18930667" title="发布于 2025-06-16 09:41">
    <span role="heading" aria-level="2">Java集合--LinkedList源码可视化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>集合节点保存的都是对象的引用，而非具体值，文中案例仅仅为了方便实现原理的演示。</p>
</blockquote>
<h2 id="1-底层数据结构">📝1. 底层数据结构</h2>
<p><code>LinkedList</code> 基于 <strong>双向链表</strong> 实现，内部通过 <code>Node&lt;E&gt;</code> 节点相互连接：</p>
<pre><code class="language-java">private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre>
<p>在 <code>LinkedList</code> 类中，通过以下字段维护链表头尾：</p>
<pre><code class="language-java">transient Node&lt;E&gt; first; // 链表的头节点引用
transient Node&lt;E&gt; last;  // 链表的尾节点引用
</code></pre>
<p><code>first</code> 始终指向第一个节点，<code>last</code> 始终指向最后一个节点。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093717954-558509483.jpg" alt="image" loading="lazy"></p>
<p>双向链表支持从头或尾进行 <strong>快速插入/删除</strong>。但不能像数组一样，根据索引下标进行地址计算，所以不支持 <strong>随机访问</strong>，通过索引访问需要 <strong>遍历</strong>节点。</p>
<h3 id="11-linkedlist-特性">1.1. LinkedList 特性</h3>
<ul>
<li>
<p><strong>顺序存储</strong>：维护插入顺序，但本质为链式结构；</p>
</li>
<li>
<p><strong>节点插入/删除</strong>：在任意位置插入或删除均为 <strong>O(1)</strong>（找到节点后）；</p>
</li>
<li>
<p><strong>访问效率</strong>：按索引访问需 <strong>O(n)</strong>，因为需要从头或尾遍历；</p>
</li>
<li>
<p>支持 <strong>null 元素</strong>，保存的是对象引用。</p>
</li>
</ul>
<h2 id="2-元素插入增">🚀2. 元素插入（增）</h2>
<p><code>LinkedList</code> 提供四种常用插入方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(E e)</code></td>
<td>在末尾插入</td>
</tr>
<tr>
<td><code>add(int index, E element)</code></td>
<td>在指定位置插入</td>
</tr>
<tr>
<td><code>addFirst(E e)</code> / <code>offerFirst(E e)</code></td>
<td>在头部插入</td>
</tr>
<tr>
<td><code>addLast(E e)</code> / <code>offerLast(E e)</code></td>
<td>在尾部插入</td>
</tr>
</tbody>
</table>
<h3 id="21-linkfirst和linklast-核心源码">2.1. linkFirst和linkLast 核心源码</h3>
<p><code>link</code>指的是连接节点的意思，<code>first</code>和<code>last</code>分别表示从头部连接（插入）节点和从尾部连接（插入）节点。所以，在学习插入元素时，需要相对这两块源码熟悉。</p>
<pre><code class="language-java">private void linkFirst(E e) {
    final Node&lt;E&gt; f = first;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}

private void linkLast(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<ul>
<li>
<p>创建新节点并调整前后指针；</p>
</li>
<li>
<p>首次插入时 <code>first</code> 和 <code>last</code> 同时指向该节点；</p>
</li>
<li>
<p><code>size++</code>、<code>modCount++</code> 支持 fail-fast。</p>
</li>
</ul>
<p>在<strong>尾部插入</strong>调用<code>linkLast</code>方法即可，源码如下</p>
<pre><code class="language-java">public void addLast(E e) {
    linkLast(e);
}
</code></pre>
<p>尾部插入动画效果</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093744845-1555801587.gif" alt="image" loading="lazy"></p>
<p>在<strong>头部插入</strong>调用<code>linkFirst</code>方法即可，源码如下</p>
<pre><code class="language-java">public void addFirst(E e) {
    linkFirst(e);
}
</code></pre>
<p>头部插入动画效果</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093756795-2006664976.gif" alt="image" loading="lazy"></p>
<h3 id="22-在中间位置插入">2.2. 在中间位置插入</h3>
<pre><code class="language-java">public void add(int index, E element) {
    checkPositionIndex(index);
    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

void linkBefore(E e, Node&lt;E&gt; succ) {
    final Node&lt;E&gt; pred = succ.prev;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<ul>
<li>
<p><code>node(index)</code> 根据索引返回目标节点，内部会判断从头或尾遍历更快；</p>
</li>
<li>
<p>连接新节点至前后节点。</p>
</li>
</ul>
<p>在中间插入的动画效果</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093814228-2104020717.gif" alt="image" loading="lazy"></p>
<h3 id="23-nodeindex检索算法重要">2.3. node(index)检索算法（重要）</h3>
<p>链表数据结构无法像数组那样，可以直接根据索引下标和首地址来计算目标元素地址，只能从头部<code>first</code>节点或尾部<code>tail</code>节点一步一步的<strong>遍历到目标位置</strong>，从而获取到目标节点。</p>
<p>源码如下，（具体检索过程的动图可到<strong>修改元素</strong>章节感受）</p>
<pre><code class="language-java">Node&lt;E&gt; node(int index) {
    // 如果索引在前半部分，从 head 开始向后遍历
    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {
        // 否则从 tail 向前遍历
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</code></pre>
<p><strong>算法解析</strong>：</p>
<ol>
<li>
<p>将链表逻辑分为两段：前半段 <code>[0, size/2)</code> 和后半段 <code>[size/2, size)</code>；</p>
</li>
<li>
<p>若目标索引位于前半段，则从 <code>first</code> 开始，依次沿 <code>next</code> 找到第 <code>index</code> 个节点；</p>
</li>
<li>
<p>若在后半段，则从 <code>last</code> 开始，沿 <code>prev</code> 向前遍历直到到达；</p>
</li>
<li>
<p>这种折半遍历相当于对链表元素位置进行“裁剪”，最坏需要遍历 <code>size/2</code> 步，平均遍历 <code>size/4</code> 步，但仍为 <strong>O(n)</strong>。</p>
</li>
</ol>
<p><strong>适用场景</strong>：在随机访问时，通过双向遍历能显著减少平均查找距离，提高链表访问效率。</p>
<h2 id="3-移除元素删">📍3. 移除元素（删）</h2>
<p><code>LinkedList</code> 提供多种删除方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove()</code></td>
<td>删除并返回头节点元素</td>
</tr>
<tr>
<td><code>remove(int index)</code></td>
<td>删除指定索引元素</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>删除首次匹配的元素</td>
</tr>
<tr>
<td><code>removeFirst()</code> / <code>pollFirst()</code></td>
<td>删除头部节点</td>
</tr>
<tr>
<td><code>removeLast()</code> / <code>pollLast()</code></td>
<td>删除尾部节点</td>
</tr>
</tbody>
</table>
<h3 id="31-unlink核心源码">3.1. unlink核心源码</h3>
<p><code>unlink</code>指的是断开节点连接，删除的本质是断开节点连接，使其前后节点重新连接，此时删除的节点在内存中就成了游离状态，后续会被GC清理回收。</p>
<pre><code class="language-java">E unlink(Node&lt;E&gt; x) {
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;

    if (prev == null)
        first = next;
    else
        prev.next = next;

    if (next == null)
        last = prev;
    else
        next.prev = prev;

    x.item = null;
    x.next = null;
    x.prev = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<ul>
<li>
<p>调整前后节点指针，再断开目标节点；</p>
</li>
<li>
<p>GC 清理旧引用；</p>
</li>
<li>
<p><code>size--</code>、<code>modCount++</code>。</p>
</li>
</ul>
<h3 id="32-删除头部节点">3.2. 删除头部节点</h3>
<p>删除头部节点并返回的源码：</p>
<pre><code class="language-java">// 删除并返回头部节点
public E remove() {
    return removeFirst();
}
public E removeFirst() {
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
}
</code></pre>
<p>删除过程效果图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093852884-2045299509.gif" alt="image" loading="lazy"></p>
<h3 id="33-删除尾部节点">3.3. 删除尾部节点</h3>
<p>删除尾部节点并返回的源码：</p>
<pre><code class="language-java">public E removeLast() {
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}
</code></pre>
<p>删除过程效果图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093912008-207887715.gif" alt="image" loading="lazy"></p>
<h3 id="34-删除指定索引节点">3.4. 删除指定索引节点</h3>
<p>删除指定索引节点并返回的源码：</p>
<pre><code class="language-java">public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
</code></pre>
<p>删除过程效果图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093935982-1279166119.gif" alt="image" loading="lazy"></p>
<h2 id="4-修改元素改">📌4. 修改元素（改）</h2>
<p><code>set(int index, E element)</code>：找到指定索引节点后直接覆盖</p>
<pre><code class="language-java">public E set(int index, E element) {
    checkElementIndex(index);
    Node&lt;E&gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}
</code></pre>
<p>检索算法还是<code>node(index)</code>，找到节点后直接修改节点内容的指向。</p>
<p>效果如图：将索引为2的<code>-46</code>改为<code>88</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093956052-925244655.gif" alt="image" loading="lazy"></p>
<p>如果在<code>-46</code>元素后面还多一个元素呢？效果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616094012450-1500080220.gif" alt="image" loading="lazy"></p>
<h2 id="5-获取和检索元素查">🎯5. 获取和检索元素（查）</h2>
<h3 id="51-获取元素">5.1. 获取元素</h3>
<pre><code class="language-java">public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
</code></pre>
<p>通过 <code>node(index)</code> 遍历链表查找节点，复杂度 <strong>O(n)</strong>。</p>
<h3 id="52-检索元素">5.2. 检索元素</h3>
<ul>
<li><code>contains(Object o)</code> / <code>indexOf</code> / <code>lastIndexOf</code>：同 <code>ArrayList</code>，但比较的是链表节点的 <code>item</code>，需线性遍历，时间复杂度<strong>O(n)</strong>；</li>
</ul>
<h2 id="6-linkedlist-的迭代器">6. LinkedList 的迭代器</h2>
<p><code>LinkedList</code> 实现了 <strong>双向迭代</strong>：</p>
<ol>
<li>
<p><code>Iterator&lt;E&gt; iterator()</code> 返回基于头到尾的迭代器；</p>
</li>
<li>
<p><code>ListIterator&lt;E&gt; listIterator()</code> 支持从任意位置开始双向遍历。</p>
</li>
</ol>
<p>核心与 <code>ArrayList</code> 类似，使用 <code>modCount</code> 检测并发修改，<code>next()</code>/<code>previous()</code> 拿到节点后返回 <code>item</code>。</p>
<h2 id="7-并发安全问题">7. 并发安全问题</h2>
<p><code>LinkedList</code> 同样<strong>线程不安全</strong>；</p>
<p>多线程操作同一实例时需自行同步：</p>
<ul>
<li>
<p><code>Collections.synchronizedList(new LinkedList&lt;&gt;())</code></p>
</li>
<li>
<p>使用 <code>CopyOnWriteArrayList</code> <strong>不适用于链表</strong>，可改用 <code>ConcurrentLinkedDeque</code> 作为替代；</p>
</li>
</ul>
<h2 id="8-时间复杂度汇总">8. 时间复杂度汇总</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>头/尾插入</td>
<td>O(1)</td>
<td><code>linkFirst</code> / <code>linkLast</code></td>
</tr>
<tr>
<td>中间插入</td>
<td>O(n)</td>
<td>查找节点 O(n) + 插入 O(1)</td>
</tr>
<tr>
<td>头/尾删除</td>
<td>O(1)</td>
<td><code>unlinkFirst</code> / <code>unlinkLast</code></td>
</tr>
<tr>
<td>中间删除</td>
<td>O(n)</td>
<td>查找节点 O(n) + 删除 O(1)</td>
</tr>
<tr>
<td>修改元素</td>
<td>O(n)</td>
<td>查找节点 O(n)</td>
</tr>
<tr>
<td>获取元素</td>
<td>O(n)</td>
<td>查找节点 O(n)</td>
</tr>
<tr>
<td>检索/contains/indexOf</td>
<td>O(n)</td>
<td>遍历比较</td>
</tr>
<tr>
<td>迭代</td>
<td>O(n)</td>
<td>每次 next O(1) 总 O(n)</td>
</tr>
</tbody>
</table>
<h2 id="9-总结">9. 总结</h2>
<p><code>LinkedList</code> 适合<strong>频繁插入/删除</strong>的场景，尤其是在头尾操作；不适合<strong>随机访问</strong>，大规模 <code>get/set</code> 性能较差；在并发场景下需要显式同步或选用合适的并发链表实现；</p>
<p>根据场景选择：</p>
<ul>
<li>
<p><strong>读多写少、随机访问</strong> 用 <code>ArrayList</code>；</p>
</li>
<li>
<p><strong>插入/删除频繁、双端操作</strong> 用 <code>LinkedList</code>。</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202506/1209017-20250616093624914-1012901470.gif" alt="image" loading="lazy"></p>
<p><a href="https://mp.weixin.qq.com/s/g-MsdPkZYHtZzaBDeki1Uw" target="_blank" rel="noopener nofollow">Java集合源码--ArrayList的可视化操作过程</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486720&amp;idx=1&amp;sn=739bdfc99dc52128f9d9eb31a70a4c03&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式的两个秘籍</a></p>
<p>查看往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>
<p>觉得还不错的，三连支持：点赞、分享、推荐↓</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-16 09:41">2025-06-16 09:41</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18930667);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18930667', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18930667', title: 'Java集合--LinkedList源码可视化' })">举报</a>
</div>
        