
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mingupupu/p/19048215" title="发布于 2025-08-20 11:20">
    <span role="heading" aria-level="2">回顾一下WPF原生实现命令</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>最近在学习Stylet中<code>Command="{s:Action 方法名}"</code>的设计与实现，但要弄明白这个之前，必须对原生实现命令比较熟悉，一想我也很久没有自己实现原生的命令了，之前都是用<code>Community.Mvvm</code>库来实现，所以今天先来回顾一下，在WPF中如何实现原生的命令。</p>
<p>借助AI使用原生的WPF写法实现了一个跟Stylet例子Hello一样的效果：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250820111959337-159120392.png" class="lazyload"></p>
<h2 id="wpf中如何使用命令">WPF中如何使用命令</h2>
<p>WPF命令是实现用户界面交互的核心机制，通过实现<code>ICommand</code>接口来封装可执行的操作。命令支持松耦合的UI设计，可以绑定到按钮、菜单等控件，实现统一的执行逻辑。WPF提供了丰富的内置命令如<code>ApplicationCommands</code>、<code>NavigationCommands</code>等，同时也支持自定义命令，便于实现撤销/重做、数据绑定等复杂功能。</p>
<p>现在先来看看这个例子中是如何使用命令的吧！！</p>
<pre><code class="language-csharp"> public class RelayCommand : ICommand
 {
     private readonly Action&lt;object?&gt; _execute;
     private readonly Predicate&lt;object?&gt;? _canExecute;

     public RelayCommand(Action&lt;object?&gt; execute, Predicate&lt;object?&gt;? canExecute = null)
     {
         _execute = execute ?? throw new ArgumentNullException(nameof(execute));
         _canExecute = canExecute;
     }

     public event EventHandler? CanExecuteChanged
     {
         add =&gt; CommandManager.RequerySuggested += value;
         remove =&gt; CommandManager.RequerySuggested -= value;
     }

     public bool CanExecute(object? parameter)
     {
         return _canExecute == null || _canExecute(parameter);
     }

     public void Execute(object? parameter)
     {
         _execute(parameter);
     }

     public void RaiseCanExecuteChanged()
     {
         CommandManager.InvalidateRequerySuggested();
     }
 }
</code></pre>
<p>这个例子中自己实现了一个实现<code>ICommand</code>接口的<code>RelayCommand</code>类。</p>
<p>先来看看<code>ICommand</code>接口：</p>
<pre><code class="language-csharp">    public interface ICommand
    {
        event EventHandler? CanExecuteChanged;
        bool CanExecute(object? parameter); 
        void Execute(object? parameter);
    }
</code></pre>
<p>这个<code>ICommand</code>接口起到了什么作用呢？</p>
<ul>
<li>统一命令规范：定义了命令的标准结构，包含执行方法Execute和状态判断方法CanExecute</li>
<li>实现命令绑定：允许UI控件（如Button、MenuItem）通过Command属性绑定到具体命令实现</li>
<li>控制可用性：CanExecute方法动态控制控件的启用/禁用状态，CanExecuteChanged事件通知UI更新状态</li>
<li>参数传递：通过parameter参数在UI和命令逻辑间传递数据</li>
<li>解耦UI与业务逻辑：将界面操作与具体实现分离，提高代码的可维护性和可测试性</li>
</ul>
<p>在<code>RelayCommand</code>中：</p>
<pre><code class="language-csharp"> private readonly Action&lt;object?&gt; _execute;
 private readonly Predicate&lt;object?&gt;? _canExecute;
</code></pre>
<p><code>_execute (Action&lt;object?&gt;)</code>: 存储要执行的操作委托</p>
<p><code>_canExecute (Predicate&lt;object?&gt;?)</code>: 存储判断命令是否可执行的谓词委托，可为 null</p>
<pre><code class="language-csharp"> public event EventHandler? CanExecuteChanged
 {
     add =&gt; CommandManager.RequerySuggested += value;
     remove =&gt; CommandManager.RequerySuggested -= value;
 }
</code></pre>
<p>这里出现了一个<code>CommandManager</code>：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250820111959348-496894590.png" class="lazyload"></p>
<p>WPF 中的 <code>CommandManager</code> 是一个帮助类，位于<code>System.Windows.Input</code>命名空间。它并不负责“执行命令”，而是为整个命令系统<code>（RoutedCommand / RoutedUICommand）</code>提供基础支撑，核心职责可以概括为四类：</p>
<p><strong>1、处理路由命令的 4 个附加事件</strong></p>
<p>CommandManager 预定义了 4 个 static 的 RoutedEvent，都是附加事件，所有 UIElement 都可以通过它们监听或引发命令相关路由事件：</p>
<table>
<thead>
<tr>
<th>附加事件</th>
<th>触发时机</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>PreviewCanExecuteEvent</td>
<td>准备询问某命令能否执行时触发（隧道）</td>
<td>用于全局或父级拦截“能否执行”判断</td>
</tr>
<tr>
<td>CanExecuteEvent</td>
<td>同上，但为冒泡阶段</td>
<td>本地逻辑判断命令当前是否可用</td>
</tr>
<tr>
<td>PreviewExecutedEvent</td>
<td>准备执行命令时触发（隧道）</td>
<td>做执行前的统一拦截，例如日志、撤销栈</td>
</tr>
<tr>
<td>ExecutedEvent</td>
<td>同上，但为冒泡阶段</td>
<td>实际执行业务逻辑（如 Save、Cut、Paste）</td>
</tr>
</tbody>
</table>
<p>这里出现了<code>隧道</code>与<code>冒泡</code>两个概念，该如何理解呢？</p>
<p>在 WPF 路由事件体系中，<code>隧道（Tunneling）</code>与<code>冒泡（Bubbling）</code>是指事件在可视化树上传递的<strong>两个方向</strong>，想象成“从上到下”还是“从下到上”即可。与命令系统结合时，理解这两个方向就等于知道“谁先被通知”、“谁可以打断谁”。</p>
<p>树结构：</p>
<p><code>Window → Grid → StackPanel → Button</code></p>
<p>这是典型的一棵可视化树。</p>
<p><strong>隧道（Preview……）→ 从根向叶</strong></p>
<p>PreviewCanExecute / PreviewExecuted 这类以 Preview 开头的事件，先由 Window 收到，再依次 Grid、StackPanel，最后才到达实际声明 CommandBinding / 声明 InputBindings 的那个 Button。</p>
<p>作用：你可以在高层（例如 Window 一级）拦截事件，做“统一处理”或“统一否决”，比如给所有按钮加日志、在全局禁止某些快捷键等。只要沿途某级标记 e.Handled = true，它就终止继续向下传递。</p>
<p><strong>冒泡（……无 Preview）→ 从叶向根</strong></p>
<p>隧道阶段结束后如果仍然 Handled == false，则进入冒泡阶段。方向反过来：Button 先收到，再依次 StackPanel、Grid、Window。</p>
<p>作用：一般在最具体元素（Button）里决定命令是否可用或执行，而父容器只做辅助行为，如更新状态栏、刷新菜单对勾等。同样可以用 e.Handled = true 阻止再向上传。</p>
<p><strong>2、提供 4 组 Add xxx Handler / Remove xxx Handler 的快捷方法</strong></p>
<p>这些只是对 UIElement.AddHandler、RemoveHandler 的二次封装，方便挂接或注销上述 4 种附加事件，省去记忆事件标识符或强制转换类型的麻烦。</p>
<p><strong>3、维护全局命令“有效性”通知：RequerySuggested</strong></p>
<p>事件定义：public static event EventHandler RequerySuggested;</p>
<p>作用：当系统条件变化（键盘焦点变化、文本被修改、网络状态变更等）时，所有命令需要重新询问“是否能执行”。WPF 内部的按钮、菜单项等在订阅此事件后，就会再次调用 ICommand.CanExecute 来决定 IsEnabled。</p>
<p>手动触发：CommandManager.InvalidateRequerySuggested(); 会立即引发该事件，从而强制刷新所有绑定命令的可执行状态。</p>
<p><strong>4、提供“类级别” CommandBinding / InputBinding 注册</strong></p>
<p><code>RegisterClassCommandBinding(Type type, CommandBinding commandBinding)</code></p>
<p>为指定类型（而不仅是某个实例）注册 CommandBinding，在所有实例共享同一组绑定逻辑，等同于在静态构造函数里写：</p>
<pre><code class="language-csharp">CommandManager.RegisterClassCommandBinding(
      typeof(MyControl),
      new CommandBinding(ApplicationCommands.Save, OnSaveExecuted, OnSaveCanExecute));
RegisterClassInputBinding(Type type, InputBinding inputBinding)
</code></pre>
<p>同样道理，为某个控件类统一注册快捷键：</p>
<pre><code class="language-csharp">CommandManager.RegisterClassInputBinding(
      typeof(MyWindow),
      new KeyBinding(ApplicationCommands.Save, Key.S, ModifierKeys.Control));
</code></pre>
<p>现在来看看整体流程：</p>
<pre><code class="language-xaml">  &lt;Button Content="Say Hello" 
          Command="{Binding SayHelloCommand}"
          Height="30"
          FontSize="14"/&gt;
</code></pre>
<p>在View中绑定这个命令。</p>
<p>刚开始这个命令不可执行：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250820111959307-1578343326.png" class="lazyload"></p>
<p>是因为在ViewModel中是这样写的，首先在构造函数中这样写：</p>
<pre><code class="language-csharp">  public ShellViewModel()
  {
      SayHelloCommand = new RelayCommand(
          execute: _ =&gt; ShowHelloMessage(),
          canExecute: _ =&gt; CanSayHello
      );
  }
</code></pre>
<p>其中控制是否能执行的，设置了一个属性来管理：</p>
<pre><code class="language-csharp"> public bool CanSayHello =&gt; !string.IsNullOrEmpty(Name);
</code></pre>
<p>命令执行的方法为：</p>
<pre><code class="language-csharp">  private void ShowHelloMessage()
  {
      MessageBox.Show($"Hello, {Name}", "Hello, Native WPF", MessageBoxButton.OK, MessageBoxImage.Information);
  }
</code></pre>
<p>刚开始Name属性为空，所以CanSayHello为false，所以命令不能执行。</p>
<p>为什么输入东西就可以变成执行了呢？</p>
<pre><code class="language-csharp"> public string Name
 {
     get =&gt; _name;
     set
     {
         if (SetProperty(ref _name, value))
         {
             ((RelayCommand)SayHelloCommand).RaiseCanExecuteChanged();
         }
     }
 }
</code></pre>
<p>在<code>RelayCommand</code>中有一个<code>RaiseCanExecuteChanged</code>方法：</p>
<pre><code class="language-csharp">   public void RaiseCanExecuteChanged()
   {
       CommandManager.InvalidateRequerySuggested();
   }
</code></pre>
<p><code>CommandManager.InvalidateRequerySuggested(); </code>是 WPF 中用于<strong>强制刷新命令的可执行状态</strong>的方法。所有绑定了<code>ICommand</code>的控件（如 Button、MenuItem 等）马上重新评估自己的 CanExecute 状态。</p>
<p>然后因为Name不为空，CanSayHello为True，这个命令就可以执行了。</p>
<p>点击按钮就会触发<code>RelayCommand</code>中的<code>Execute</code>方法：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250820111959345-2003121315.png" class="lazyload"></p>
<p>在ViewModel的构造函数中。实例化了一个<code>RelayCommand</code>对象，并且将<code>_ =&gt; ShowHelloMessage()</code>这个委托赋值给了<code>execute</code>，所以触发命令之后就会执行<code>ShowHelloMessage</code>方法。</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250820111959325-1473715965.png" class="lazyload"></p>
<p>以上就是使用WPF原生的方法实现的一个使用命令的例子。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-20 11:20">2025-08-20 11:20</span>&nbsp;
<a href="https://www.cnblogs.com/mingupupu">mingupupup</a>&nbsp;
阅读(<span id="post_view_count">177</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19048215);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19048215', targetLink: 'https://www.cnblogs.com/mingupupu/p/19048215', title: '回顾一下WPF原生实现命令' })">举报</a>
</div>
        