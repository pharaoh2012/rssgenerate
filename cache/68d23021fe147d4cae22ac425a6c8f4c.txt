
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18725636" title="发布于 2025-02-19 23:57">
    <span role="heading" aria-level="2">【忍者算法】从拉链到链表：探索有序链表的合并之道｜LeetCode 21 合并两个有序链表</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从拉链到链表探索有序链表的合并之道">从拉链到链表：探索有序链表的合并之道</h1>
<h2 id="生活中的合并">生活中的合并</h2>
<p>想象你正在整理两叠按日期排好序的收据。最自然的方式就是：拿起两叠收据，每次比较最上面的日期，选择日期较早的那张放入新的一叠中。这个简单的日常操作，恰恰就是我们今天要讨论的有序链表合并问题的真实写照。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第21题"合并两个有序链表"要求：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>例如：</p>
<pre><code>输入：1 → 2 → 4, 1 → 3 → 4
输出：1 → 1 → 2 → 3 → 4 → 4

输入：空链表, 0
输出：0

输入：空链表, 空链表
输出：空链表
</code></pre>
<h2 id="暴力解法转换为数组排序">暴力解法：转换为数组排序</h2>
<p>最直观的想法可能是：把两个链表的值都放到一个数组里，排序后再创建新链表。这种方法虽然不够优雅，但对于理解问题很有帮助。</p>
<h3 id="暴力解法实现">暴力解法实现</h3>
<pre><code class="language-java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 创建数组存储所有节点值
    List&lt;Integer&gt; values = new ArrayList&lt;&gt;();
    
    // 遍历第一个链表
    while (list1 != null) {
        values.add(list1.val);
        list1 = list1.next;
    }
    
    // 遍历第二个链表
    while (list2 != null) {
        values.add(list2.val);
        list2 = list2.next;
    }
    
    // 排序数组
    Collections.sort(values);
    
    // 构建新链表
    ListNode dummy = new ListNode(0);  // 哨兵节点
    ListNode current = dummy;
    
    // 根据排序后的数组创建新链表
    for (int value : values) {
        current.next = new ListNode(value);
        current = current.next;
    }
    
    return dummy.next;
}
</code></pre>
<h2 id="优化解法双指针遍历">优化解法：双指针遍历</h2>
<p>既然输入的链表已经排好序，我们完全可以模拟整理收据的过程：同时遍历两个链表，每次选择较小的节点连接到结果链表中。这就像拉链一样，将两个有序序列合并成一个。</p>
<h3 id="代码实现与详解">代码实现与详解</h3>
<pre><code class="language-java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 创建哨兵节点，简化边界情况处理
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    // 当两个链表都不为空时，比较并连接
    while (list1 != null &amp;&amp; list2 != null) {
        if (list1.val &lt;= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 处理剩余节点
    if (list1 != null) {
        current.next = list1;
    }
    if (list2 != null) {
        current.next = list2;
    }
    
    return dummy.next;
}
</code></pre>
<h3 id="图解过程">图解过程</h3>
<pre><code>1) 初始状态：
list1: 1 → 2 → 4
list2: 1 → 3 → 4
result: dummy →

2) 第一次比较后：
list1: 2 → 4
list2: 1 → 3 → 4
result: dummy → 1 →

3) 第二次比较后：
list1: 2 → 4
list2: 3 → 4
result: dummy → 1 → 1 →

4) 最终结果：
result: dummy → 1 → 1 → 2 → 3 → 4 → 4
</code></pre>
<h2 id="复杂度比较">复杂度比较</h2>
<p>暴力解法：</p>
<ul>
<li>时间复杂度：O(nlogn)，主要来自排序过程</li>
<li>空间复杂度：O(n)，需要额外数组存储所有节点</li>
<li>缺点：没有利用链表已排序的特性</li>
</ul>
<p>双指针解法：</p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次</li>
<li>空间复杂度：O(1)，只需要几个指针</li>
<li>优点：充分利用了输入链表已排序的特性</li>
</ul>
<h2 id="技巧与思考">技巧与思考</h2>
<ol>
<li>
<p>哨兵节点的妙用</p>
<ul>
<li>使用哨兵节点可以统一边界情况处理</li>
<li>避免了对头节点的特殊处理</li>
</ul>
</li>
<li>
<p>就地合并的思想</p>
<ul>
<li>不需要创建新节点</li>
<li>通过改变指针指向来实现合并</li>
</ul>
</li>
<li>
<p>处理剩余节点</p>
<ul>
<li>直接连接剩余链表</li>
<li>避免了继续遍历剩余节点</li>
</ul>
</li>
</ol>
<h2 id="实际应用延伸">实际应用延伸</h2>
<p>合并有序链表的思想在实际开发中很常见：</p>
<ol>
<li>数据库中的有序结果集合并</li>
<li>文件系统中有序文件的合并</li>
<li>日志系统中按时间戳排序的日志合并</li>
</ol>
<h2 id="小结">小结</h2>
<p>合并有序链表看似简单，实则蕴含着重要的算法思想：</p>
<ol>
<li>如何高效处理有序数据</li>
<li>指针操作的技巧</li>
<li>如何简化边界条件处理</li>
</ol>
<p>记住：当遇到类似的合并问题时，先考虑数据是否有序，如果有序，往往可以设计出更优雅高效的解法。</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.01482398703587963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-19 23:57">2025-02-19 23:57</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18725636" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18725636);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18725636', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18725636', title: '【忍者算法】从拉链到链表：探索有序链表的合并之道｜LeetCode 21 合并两个有序链表' })">举报</a>
</div>
        