
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/haoxianrui/p/18683051" title="发布于 2025-01-21 10:05">
    <span role="heading" aria-level="2">「youlai-boot」入门篇：从0到1搭建 Java、Spring Boot、Spring Security 企业级权限管理系统</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/675291/202501/675291-20250121095917679-540016379.png" alt="「youlai-boot」入门篇：从0到1搭建 Java、Spring Boot、Spring Security 企业级权限管理系统" class="desc_img">
        本文介绍了如何使用 Java 和 Spring Boot 3，从零开始构建开源的 youlai-boot 企业级权限管理系统，涵盖 MySQL、Redis 整合及 Spring Security，适合前端开发者和后端初学者。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>🚀 作者主页： <a href="https://www.youlai.tech" target="_blank" rel="noopener nofollow">有来技术</a><br>
🔥 开源项目： <a href="https://gitee.com/youlaitech/youlai-mall" target="_blank" rel="noopener nofollow">youlai-mall </a>︱<a href="https://gitee.com/youlaiorg/vue3-element-admin" target="_blank" rel="noopener nofollow">vue3-element-admin</a>︱<a href="https://gitee.com/youlaiorg/youlai-boot" target="_blank" rel="noopener nofollow">youlai-boot</a>︱<a href="https://gitee.com/youlaiorg/vue-uniapp-template" target="_blank" rel="noopener nofollow">vue-uniapp-template</a><br>
🌺 仓库主页： <a href="https://gitcode.com/org/youlai" target="_blank" rel="noopener nofollow">GitCode</a>︱ <a href="https://gitee.com/haoxr" target="_blank" rel="noopener nofollow">Gitee</a>  ︱ <a href="https://github.com/haoxianrui" target="_blank" rel="noopener nofollow">Github</a><br>
💖 欢迎点赞 👍 收藏 ⭐评论 📝 如有错误敬请纠正！</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>本文基于 <strong>Java</strong> 和 <strong>Spring Boot 3</strong>，从 0 到 1 完成一个企业级后端项目的开发。依次整合 <strong>MySQL</strong> 和 <strong>Redis</strong>，实现基础的增删改查（CRUD）接口，并通过 <strong>Spring Security</strong> 完成登录认证与接口权限控制，最终构建完整的企业级安全管理框架。</p>
<p>作为开源项目<a href="https://gitee.com/youlaiorg/youlai-boot" target="_blank" rel="noopener nofollow"><strong>youlai-boot</strong></a> 的入门篇，本文旨在帮助前端开发者或后端初学者快速上手 Java 后端开发。通过一步步实践，掌握项目的核心逻辑与实现细节，不仅能放心使用，还能轻松扩展和二次开发。</p>
<h1 id="环境准备">环境准备</h1>
<p>本章节介绍安装 Java 开发所需的环境，包括 JDK、Maven 和 IntelliJ IDEA（简称 IDEA），这些工具是 Java 开发的核心环境。</p>
<hr>
<h2 id="安装-jdk">安装 JDK</h2>
<p><strong>JDK（Java Development Kit）</strong> 是 Java 开发工具包，包含编译器、运行时环境等，支持 Java 应用程序的开发与运行。</p>
<h3 id="下载-jdk">下载 JDK</h3>
<p>访问以下链接，下载最新版本的 JDK 安装包：<br>
<a href="https://download.oracle.com/java/17/latest/jdk-17_windows-x64_bin.exe" target="_blank" rel="noopener nofollow">https://download.oracle.com/java/17/latest/jdk-17_windows-x64_bin.exe</a></p>
<h3 id="安装-jdk-1">安装 JDK</h3>
<p>下载完成后，双击安装包，根据引导完成安装。<br>
示例安装路径：<code>D:\Java\jdk-17.0.3.1</code></p>
<h3 id="配置环境变量">配置环境变量</h3>
<ul>
<li>打开 <strong>系统属性</strong> -&gt; <strong>高级系统设置</strong> -&gt; <strong>环境变量</strong></li>
<li>新建系统变量 <code>JAVA_HOME</code>，值为 <code>D:\Java\jdk-17.0.3.1</code></li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/image-20241127172500691.png" alt="" loading="lazy"></p>
<ul>
<li>在 <code>Path</code> 环境变量中，添加 <code>%JAVA_HOME%\bin</code></li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/image-20241127172531273.png" alt="" loading="lazy"></p>
<h3 id="验证安装">验证安装</h3>
<p>在命令行中执行以下命令，查看 Java 版本：</p>
<pre><code class="language-bash">java -version
</code></pre>
<p>输出类似如下内容表示安装成功：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241127174145418.png" alt="" loading="lazy"></p>
<hr>
<h2 id="安装-maven">安装 Maven</h2>
<p><strong>Maven</strong> 是一个流行的 Java 构建和依赖管理工具，类似于前端的 npm，用于管理项目的构建流程及第三方依赖库。</p>
<h3 id="下载-maven">下载 Maven</h3>
<p>访问以下链接，下载最新的 <code>bin.zip</code> 文件：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener nofollow">https://maven.apache.org/download.cgi</a></p>
<p>将 <code>bin.zip</code> 解压到本地目录，示例解压路径：<code>D:\Soft\apache-maven-3.9.5</code></p>
<h3 id="配置阿里云镜像">配置阿里云镜像</h3>
<p>编辑配置文件 <code>D:\Soft\apache-maven-3.9.5\conf\settings.xml</code>，在 <code>&lt;mirrors&gt;</code> 节点中添加以下配置：</p>
<pre><code class="language-xml">&lt;mirrors&gt;
    &lt;mirror&gt;
        &lt;id&gt;alimaven&lt;/id&gt;
        &lt;name&gt;aliyun maven&lt;/name&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       
    &lt;/mirror&gt;
&lt;/mirrors&gt;
</code></pre>
<h3 id="配置环境变量-1">配置环境变量</h3>
<ul>
<li>新建系统变量 <code>M2_HOME</code>，值为 <code>D:\Soft\apache-maven-3.9.5</code></li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/image-20241127175409747.png" alt="" loading="lazy"></p>
<ul>
<li>在 <code>Path</code> 环境变量中，添加 <code>%M2_HOME%\bin</code></li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/wps2.jpg" alt="" loading="lazy"></p>
<h3 id="验证安装-1">验证安装</h3>
<p>在命令行中执行以下命令，查看 Maven 版本：</p>
<pre><code class="language-bash">mvn -v
</code></pre>
<p>输出类似如下内容表示安装成功：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241127180216250.png" alt="" loading="lazy"></p>
<hr>
<h2 id="安装-idea">安装 IDEA</h2>
<p><strong>IntelliJ IDEA</strong> 是一款功能强大的 Java 集成开发环境（IDE），由 JetBrains 开发，广泛用于 Java 项目的开发、调试和运行。</p>
<h3 id="下载-idea">下载 IDEA</h3>
<p>访问以下链接，下载适合您系统的安装包：<br>
<a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener nofollow">https://www.jetbrains.com/idea/download</a></p>
<h3 id="安装-idea-1">安装 IDEA</h3>
<p>下载完成后，双击安装包，按引导完成安装即可。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241128104857210.png" alt="" loading="lazy"></p>
<p>具体的配置在创建项目之前说明。</p>
<h2 id="安装-mysql">安装 MySQL</h2>
<h3 id="安装-mysql-服务">安装 MySQL 服务</h3>
<ul>
<li><strong>Windows 安装 MySQL 8</strong>：<a href="https://youlai.blog.csdn.net/article/details/133272887" target="_blank" rel="noopener nofollow">https://youlai.blog.csdn.net/article/details/133272887</a></li>
<li><strong>Linux  安装 MySQL 8</strong>：<a href="https://youlai.blog.csdn.net/article/details/130398179" target="_blank" rel="noopener nofollow">https://youlai.blog.csdn.net/article/details/130398179</a></li>
</ul>
<h3 id="安装-mysql-可视化工具">安装 MySQL 可视化工具</h3>
<p>推荐使用 <strong>Navicat</strong>，这是一款功能强大的数据库管理工具，但需要付费。如果你因未付费而遇到使用限制，可以选择 <strong>DBeaver</strong> 作为替代方案。</p>
<ul>
<li><strong>Navicat 官方下载地址</strong>：<a href="https://www.navicat.com.cn/download/navicat-premium" target="_blank" rel="noopener nofollow">https://www.navicat.com.cn/download/navicat-premium</a></li>
<li><strong>DBeaver 官方下载地址</strong>：<a href="https://dbeaver.io/" target="_blank" rel="noopener nofollow">https://dbeaver.io/</a></li>
</ul>
<p>下载并安装 Navicat 后，你将获得 <strong>14 天的免费试用期</strong>。安装完成后，连接到 MySQL 服务，即可对数据库和表进行可视化操作，体验非常流畅。</p>
<p><strong>Navicat 界面效果：</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20250115170806505.png" alt="" loading="lazy"></p>
<h2 id="安装-redis">安装 Redis</h2>
<h3 id="安装-redis-服务">安装 Redis 服务</h3>
<ul>
<li><strong>Windows 安装 Redis</strong>：<a href="https://youlai.blog.csdn.net/article/details/133410293" target="_blank" rel="noopener nofollow">https://youlai.blog.csdn.net/article/details/133410293</a></li>
<li><strong>Linux 安装 Redis</strong>：<a href="https://youlai.blog.csdn.net/article/details/130439335" target="_blank" rel="noopener nofollow">https://youlai.blog.csdn.net/article/details/130439335</a></li>
</ul>
<h3 id="安装-redis-可视化工具">安装 Redis 可视化工具</h3>
<p>推荐使用开源的 <strong>AnotherRedisDesktopManager</strong>，这是一款功能强大且免费的 Redis 可视化工具。</p>
<ul>
<li><strong>AnotherRedisDesktopManager 下载地址</strong>：<a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/releases" target="_blank" rel="noopener nofollow">https://gitee.com/qishibo/AnotherRedisDesktopManager/releases</a></li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/2983a0881f3361783b37e31862f2da02.png" alt="" loading="lazy"></p>
<p><strong>安装步骤：</strong></p>
<ol>
<li>下载安装程序（.exe 文件）。</li>
<li>按照安装向导逐步操作，完成安装。</li>
</ol>
<p><strong>使用步骤：</strong></p>
<ol>
<li>打开软件，点击“新建连接”。</li>
<li>输入 Redis 服务器的连接信息（如主机地址、端口、密码等）。</li>
<li>连接成功后，即可对 Redis 数据进行可视化操作。</li>
</ol>
<p><strong>AnotherRedisDesktopManager 界面效果：</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/49210f908669a078d930113c1558f68b.png" alt="" loading="lazy"></p>
<p><strong>连接成功示例：</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/6d9c76824e2094c20e631b636d484531.png" alt="" loading="lazy"></p>
<h1 id="项目搭建">项目搭建</h1>
<h2 id="新建项目">新建项目</h2>
<p>打开 <strong>IDEA</strong>，选择 <strong>Projects → New Project</strong>。</p>
<ol>
<li><strong>项目名称</strong>：输入 <code>youlai-boot</code>（可根据实际需求调整）。</li>
<li><strong>项目类型</strong>：选择 <strong>Maven</strong>。</li>
<li><strong>JDK 版本</strong>：选择 <strong>JDK 17</strong>（确保已安装 JDK 17）。</li>
<li><strong>项目信息</strong>：
<ul>
<li><strong>Group</strong>：填写 <code>com.youlai</code>（可根据实际需求调整）。</li>
<li><strong>Artifact</strong>：填写 <code>youlai-boot</code>（可根据实际需求调整）。</li>
<li><strong>Package name</strong>：填写 <code>com.youlai.boot</code>（可根据实际需求调整）。</li>
</ul>
</li>
</ol>
<p><img src="https://www.youlai.tech/storage/blog/image-20241128124956778.png" alt="" loading="lazy"></p>
<p>点击 <strong>Next</strong>，在左侧的依赖列表中勾选项目所需的依赖。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129131335505.png" alt="" loading="lazy"></p>
<p>完成项目初始化后，项目结构如下：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241128130027516.png" alt="" loading="lazy"></p>
<h2 id="配置开发环境">配置开发环境</h2>
<h3 id="配置-jdk">配置 JDK</h3>
<p>通过 <strong>File → Project Structure</strong>（快捷键 <strong>Ctrl + Alt + Shift + S</strong>）打开项目结构配置面板，确保 <strong>Project</strong> 和 <strong>Modules</strong> 使用的 SDK 版本为前面安装的 JDK 17。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241128164048566.png" alt="" loading="lazy"></p>
<h3 id="配置-maven">配置 Maven</h3>
<p>通过 <strong>File  → Settings</strong>（快捷键 <strong>Ctrl + Alt + S</strong>）打开设置面板，切换到 <strong>Maven</strong> 选项，并将 Maven 设置为前面安装到本地的版本。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241128164823123.png" alt="" loading="lazy"></p>
<h3 id="验证配置">验证配置</h3>
<p>在 IDEA 的 Terminal 中输入以下命令 <code>mvn -v</code>，验证 Maven 是否正确使用了 JDK 17：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129130035208.png" alt="" loading="lazy"></p>
<h2 id="快速开始">快速开始</h2>
<h3 id="创建第一个接口">创建第一个接口</h3>
<ol>
<li>在 <code>src/main/java</code> 目录下的 <code>com.youlai.boot</code> 包中，新建一个名为 <code>controller</code> 的包。</li>
<li>在 <code>controller</code> 包下创建一个名为 <code>TestController</code> 的 Java 类。</li>
<li>在 <code>TestController</code> 类中添加一个简单的 <code>hello-world</code> 接口。</li>
</ol>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129132039510.png" alt="" loading="lazy"></p>
<p>以下是 <code>TestController</code> 类的代码：</p>
<pre><code class="language-java">/**
 * 测试接口
 *
 * @author youlai
 */
@RestController
public class TestController {

    @GetMapping("/hello-world")
    public String test() {
        return "hello world";
    }

}
</code></pre>
<h3 id="启动测试">启动测试</h3>
<p>在项目的右上角，点击 🐞 (手动绿色)图标以调试运行项目。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129132302035.png" alt="" loading="lazy"></p>
<p>控制台显示 <code>Tomcat 已在端口 8080 (http) </code>，表示应用成功启动</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129133403785.png" alt="" loading="lazy"></p>
<p>打开浏览器，访问 <code>http://localhost:8080/hello-world</code>，页面将显示 <code>hello world</code>，表示接口正常运行。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129133430981.png" alt="" loading="lazy"></p>
<h2 id="连接数据库">连接数据库</h2>
<p>为实现应用与 MySQL 的连接与操作，整合 MyBatis-Plus 可简化数据库操作，减少重复的 CRUD 代码，提升开发效率，实现高效、简洁、可维护的持久层开发。</p>
<h3 id="创建数据库">创建数据库</h3>
<p>使用 MySQL 可视化工具 (Navicat) 执行下面脚本完成数据库的创建名为 youlai-boot 的数据库，其中包含测试的用户表</p>
<pre><code class="language-sql">    -- ----------------------------
    -- 1. 创建数据库
    -- ----------------------------
    CREATE DATABASE IF NOT EXISTS youlai_boot DEFAULT CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_general_ci;

    -- ----------------------------
    -- 2. 创建表 &amp;&amp; 数据初始化
    -- ----------------------------
    use youlai_boot;
	
	-- ----------------------------
    -- Table structure for sys_user
    -- ----------------------------
    DROP TABLE IF EXISTS `sys_user`;
    CREATE TABLE `sys_user` (
        `id` int NOT NULL AUTO_INCREMENT,
        `username` varchar(64) NULL DEFAULT NULL COMMENT '用户名',
        `nickname` varchar(64) NULL DEFAULT NULL COMMENT '昵称',
        `gender` tinyint(1) NULL DEFAULT 1 COMMENT '性别(1-男 2-女 0-保密)',
        `password` varchar(100) NULL DEFAULT NULL COMMENT '密码',
        `dept_id` int NULL DEFAULT NULL COMMENT '部门ID',
        `avatar` varchar(255) NULL DEFAULT '' COMMENT '用户头像',
        `mobile` varchar(20) NULL DEFAULT NULL COMMENT '联系方式',
        `status` tinyint(1) NULL DEFAULT 1 COMMENT '状态(1-正常 0-禁用)',
        `email` varchar(128) NULL DEFAULT NULL COMMENT '用户邮箱',
        `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
        `create_by` bigint NULL DEFAULT NULL COMMENT '创建人ID',
        `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
        `update_by` bigint NULL DEFAULT NULL COMMENT '修改人ID',
        `is_deleted` tinyint(1) NULL DEFAULT 0 COMMENT '逻辑删除标识(0-未删除 1-已删除)',
        PRIMARY KEY (`id`) USING BTREE
    ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = DYNAMIC;

    -- ----------------------------
    -- Records of sys_user
    -- ----------------------------
    INSERT INTO `sys_user` VALUES (1, 'root', '有来技术', 0, '$2a$10$xVWsNOhHrCxh5UbpCE7/HuJ.PAOKcYAqRxD2CO2nVnJS.IAXkr5aq', NULL, 'https://foruda.gitee.com/images/1723603502796844527/03cdca2a_716974.gif', '18866668888', 1, 'youlaitech@163.com', NULL, NULL, NULL, NULL, 0);
    INSERT INTO `sys_user` VALUES (2, 'admin', '系统管理员', 1, '$2a$10$xVWsNOhHrCxh5UbpCE7/HuJ.PAOKcYAqRxD2CO2nVnJS.IAXkr5aq', 1, 'https://foruda.gitee.com/images/1723603502796844527/03cdca2a_716974.gif', '18866668887', 1, '', now(), NULL, now(), NULL, 0);
    INSERT INTO `sys_user` VALUES (3, 'websocket', '测试小用户', 1, '$2a$10$xVWsNOhHrCxh5UbpCE7/HuJ.PAOKcYAqRxD2CO2nVnJS.IAXkr5aq', 3, 'https://foruda.gitee.com/images/1723603502796844527/03cdca2a_716974.gif', '18866668886', 1, 'youlaitech@163.com', now(), NULL, now(), NULL, 0);

</code></pre>
<h3 id="添加依赖">添加依赖</h3>
<p>项目 <code>pom.xml</code> 添加 MySQL 驱动和 Mybatis-Plus 依赖：</p>
<pre><code class="language-xml">&lt;!-- MySQL 8 驱动 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
	&lt;version&gt;9.1.0&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Druid 数据库连接池 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
	&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;1.2.24&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- MyBatis Plus Starter--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;
	&lt;version&gt;3.5.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置数据源">配置数据源</h3>
<p>将 <code>src/main/resources/application.properties</code> 文件修改为 <code>src/main/resources/application.yml</code>，因为我们更倾向于使用 yml 格式。然后，在 yml 文件中添加以下内容：</p>
<pre><code class="language-yaml">server:
  port: 8080
  
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/youlai_boot?useSSL=false&amp;serverTimezone==Asia/Shanghai&amp;&amp;characterEncoding=utf8
    username: root
    password: 123456

mybatis-plus:
  configuration:
    # 驼峰命名映射
    map-underscore-to-camel-case: true
    # 打印 sql 日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: auto # 主键策略
      logic-delete-field: is_deleted # 全局逻辑删除字段（可选）
</code></pre>
<h2 id="增删改查接口">增删改查接口</h2>
<h3 id="安装-mybatisx-插件">安装 MybatisX 插件</h3>
<p>在 IDEA 中依次点击 <strong>File → Settings</strong>（快捷键 <strong>Ctrl + Alt + S</strong>），打开设置面板，切换到 <strong>Plugins</strong> 选项卡，搜索 <strong>MybatisX</strong> 并安装插件。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129180051551.png" alt="image-20241129180051551" loading="lazy"></p>
<h3 id="自动代码生成">自动代码生成</h3>
<p>在 IDEA 右侧导航栏点击 <strong>Database</strong>，打开数据库配置面板，选择新增数据源。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129180148500.png" alt="" loading="lazy"></p>
<p>输入数据库的 <strong>主机地址</strong>、<strong>用户名</strong> 和 <strong>密码</strong>，测试连接成功后点击 <code>OK</code> 保存。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129180534866.png" alt="" loading="lazy"></p>
<p>配置完数据源后，展开数据库中的表，右击 <strong>sys_user</strong> 表，选择 <strong>MybatisX-Generator</strong> 打开代码生成面板。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129181402702.png" alt="" loading="lazy"></p>
<p>设置代码生成的目标路径，并选择 <strong>Mybatis-Plus 3 + Lombok</strong> 代码风格。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129182206666.png" alt="" loading="lazy"></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129181916422.png" alt="" loading="lazy"></p>
<p>点击 <code>Finish</code> 生成，自动生成相关代码。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241129182513179.png" alt="" loading="lazy"></p>
<p>MybatisX 生成的代码存在以下问题：</p>
<ul>
<li><code>SysUserMapper.java</code> 文件未标注 <code>@Mapper</code> 注解，导致无法被 Spring Boot 识别为 Mybatis 的 Mapper 接口。如果已配置 <code>@MapperScan</code>，可以省略此注解，但最简单的方法是直接在 <code>SysUserMapper.java</code> 文件中添加 <code>@Mapper</code> 注解。注意避免导入错误的包。</li>
</ul>
<p><img src="https://www.youlai.tech/storage/blog/image-20241204150356053.png" alt="" loading="lazy"></p>
<h3 id="添加增删改查接口">添加增删改查接口</h3>
<p>在 <code>controller</code> 包下创建 <code>UserController.java</code>，编写用户管理接口：</p>
<pre><code class="language-java">/**
 * 用户控制层
 *
 * @author youlai
 * @since 2024/12/04
 */
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final SysUserService userService;

    /**
     * 获取用户列表
     */
    @GetMapping
    public List&lt;SysUser&gt; listUsers() {
        return userService.list();
    }

    /**
     * 获取用户详情
     */
    @GetMapping("/{id}")
    public SysUser getUserById(@PathVariable Long id) {
        return userService.getById(id);
    }

    /**
     * 新增用户
     */
    @PostMapping
    public String createUser(@RequestBody SysUser user) {
        userService.save(user);
        return "用户创建成功";
    }

    /**
     * 更新用户信息
     */
    @PutMapping("/{id}")
    public String updateUser(@PathVariable Long id, @RequestBody SysUser user) {
        userService.updateById(user);
        return "用户更新成功";
    }

    /**
     * 删除用户
     */
    @DeleteMapping("/{id}")
    public String deleteUser(@PathVariable Long id) {
        userService.removeById(id);
        return "用户删除成功";
    }

}

</code></pre>
<p><img src="https://www.youlai.tech/storage/blog/image-20241204152327778.png" alt="" loading="lazy"></p>
<h3 id="接口测试">接口测试</h3>
<p>重新启动应用，在浏览器中访问 <a href="http://localhost:8080/users%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E3%80%82" target="_blank" rel="noopener nofollow">http://localhost:8080/users，查看用户数据。</a></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241204161516388.png" alt="" loading="lazy"></p>
<p>其他增删改接口可以通过后续整合接口文档进行测试。</p>
<h2 id="集成-knife4j-接口文档">集成 Knife4j 接口文档</h2>
<p><strong>Knife4j</strong> 是基于 <strong>Swagger2</strong> 和 <strong>OpenAPI3</strong> 的增强解决方案，旨在提供更友好的界面和更多功能扩展，帮助开发者更便捷地调试和测试 API。以下是通过参考 Knife4j 官方文档 <a href="https://doc.xiaominfo.com/docs/quick-start" target="_blank" rel="noopener nofollow">Spring Boot 3 整合 Knife4j</a> 实现集成的过程。</p>
<h3 id="添加依赖-1">添加依赖</h3>
<p>在 <code>pom.xml</code> 文件中引入 Knife4j 的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
    &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;4.5.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置接口文档">配置接口文档</h3>
<p>在 <code>application.yml</code> 文件中进行配置。注意，<code>packages-to-scan</code> 需要配置为项目的包路径，以确保接口能够被正确扫描，其他配置保持默认即可。</p>
<pre><code class="language-yaml"># springdoc-openapi 项目配置
springdoc:
  swagger-ui:
    path: /swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha
  api-docs:
    path: /v3/api-docs
  group-configs:
    - group: 'default'
      paths-to-match: '/**'
      packages-to-scan: com.youlai.boot.controller # 需要修改成自己项目的接口包路径
# knife4j的增强配置，不需要增强可以不配
knife4j:
  enable: true
  # 是否为生产环境，true 表示生产环境，接口文档将被禁用
  production: false
  setting:
    language: zh_cn # 设置文档语言为中文
</code></pre>
<p>添加接口文档配置，在 <code>com.youlai.boot.config</code> 添加 <code>OpenApiConfig</code> 接口文档配置</p>
<pre><code class="language-java">package com.youlai.boot.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springdoc.core.customizers.GlobalOpenApiCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpHeaders;

/**
 * OpenAPI 接口文档配置
 *
 * @author youlai
 */
@Configuration
@RequiredArgsConstructor
@Slf4j
public class OpenApiConfig {

    private final Environment environment;

    /**
     * 接口信息
     */

    @Bean
    public OpenAPI openApi() {

        String appVersion = environment.getProperty("project.version", "1.0.0");

        return new OpenAPI()
                .info(new Info()
                        .title("系统接口文档")
                        .version(appVersion)
                )
                // 配置全局鉴权参数-Authorize
                .components(new Components()
                        .addSecuritySchemes(HttpHeaders.AUTHORIZATION,
                                new SecurityScheme()
                                        .name(HttpHeaders.AUTHORIZATION)
                                        .type(SecurityScheme.Type.APIKEY)
                                        .in(SecurityScheme.In.HEADER)
                                        .scheme("Bearer")
                                        .bearerFormat("JWT")
                        )
                );
    }


    /**
     * 全局自定义扩展
     * &lt;p&gt;
     * 在OpenAPI规范中，Operation 是一个表示 API 端点（Endpoint）或操作的对象。
     * 每个路径（Path）对象可以包含一个或多个 Operation 对象，用于描述与该路径相关联的不同 HTTP 方法（例如 GET、POST、PUT 等）。
     */
    @Bean
    public GlobalOpenApiCustomizer globalOpenApiCustomizer() {
        return openApi -&gt; {
            // 全局添加鉴权参数
            if (openApi.getPaths() != null) {
                openApi.getPaths().forEach((s, pathItem) -&gt; {
                    // 登录接口/验证码不需要添加鉴权参数
                    if ("/api/v1/auth/login".equals(s)) {
                        return;
                    }
                    // 接口添加鉴权参数
                    pathItem.readOperations()
                            .forEach(operation -&gt;
                                    operation.addSecurityItem(new SecurityRequirement().addList(HttpHeaders.AUTHORIZATION))
                            );
                });
            }
        };
    }

}
</code></pre>
<h3 id="完善接口文档">完善接口文档</h3>
<p><strong>完善接口描述</strong></p>
<p>在已有的 REST 接口中，使用 OpenAPI 规范注解来描述接口的详细信息，以便通过 Knife4j 生成更加清晰的接口文档。以下是如何为用户的增删改查接口添加文档描述注解的示例：</p>
<pre><code class="language-java">@Tag(name = "用户接口")
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final SysUserService userService;

    @Operation(summary = "获取用户列表")
    @GetMapping
    public List&lt;SysUser&gt; listUsers() {
        return userService.list();
    }

    @Operation(summary = "获取用户详情")
    @GetMapping("/{id}")
    public SysUser getUserById(
            @Parameter(description = "用户ID") @PathVariable Long id
    ) {
        return userService.getById(id);
    }

    @Operation(summary = "新增用户")
    @PostMapping
    public String createUser(@RequestBody SysUser user) {
        userService.save(user);
        return "新增用户成功";
    }

    @Operation(summary = "修改用户")
    @PutMapping("/{id}")
    public String updateUser(
            @Parameter(description = "用户ID") @PathVariable Long id,
            @RequestBody SysUser user
    ) {
        userService.updateById(user);
        return "修改用户成功";
    }

    @Operation(summary = "删除用户")
    @DeleteMapping("/{id}")
    public String deleteUser(
            @Parameter(description = "用户ID") @PathVariable Long id
    ) {
        userService.removeById(id);
        return "用户删除成功";
    }

}
</code></pre>
<p><strong>完善实体类描述</strong></p>
<p>在 <code>SysUser</code> 实体类中为每个字段添加 <code>@Schema</code> 注解，用于在接口文档中显示字段的详细说明及示例值：</p>
<pre><code class="language-java">@Schema(description = "用户对象")
@TableName(value = "sys_user")
@Data
public class SysUser implements Serializable {

    @Schema(description = "用户ID", example = "1")
    @TableId(type = IdType.AUTO)
    private Integer id;

    @Schema(description = "用户名", example = "admin")
    private String username;

    @Schema(description = "昵称", example = "管理员")
    private String nickname;

    @Schema(description = "性别（1-男，2-女，0-保密）", example = "1")
    private Integer gender;

    @Schema(description = "用户头像URL", example = "https://example.com/avatar.png")
    private String avatar;

    @Schema(description = "联系方式", example = "13800000000")
    private String mobile;

    @Schema(description = "用户邮箱", example = "admin@example.com")
    private String email;
    
    // ... 
}
</code></pre>
<h3 id="使用接口文档">使用接口文档</h3>
<p>完成以上步骤后，重新启动应用并访问生成的接口文档。</p>
<ul>
<li>Swagger UI 文档地址：<a href="http://localhost:8080/swagger-ui/index.html" target="_blank" rel="noopener nofollow">http://localhost:8080/swagger-ui/index.html</a></li>
<li>Knife4j 文档地址：<a href="http://localhost:8080/doc.html" target="_blank" rel="noopener nofollow">http://localhost:8080/doc.html</a></li>
</ul>
<p>通过左侧的接口列表查看增删改查接口，并点击具体接口查看详细参数说明及示例值：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241204181853122.png" alt="" loading="lazy"></p>
<p>接着，可以通过接口文档新增用户，接口返回成功后，可以看到数据库表中新增了一条用户数据：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241204181600480.png" alt="" loading="lazy"></p>
<h2 id="集成-redis-缓存">集成 Redis 缓存</h2>
<p>Redis 是当前广泛使用的高性能缓存中间件，能够显著提升系统性能，减轻数据库压力，几乎成为现代应用的标配。</p>
<h3 id="添加依赖-2">添加依赖</h3>
<p>在 <code>pom.xml</code> 文件中添加 Spring Boot Redis 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="配置-redis-连接">配置 Redis 连接</h3>
<p>在 <code>application.yml</code> 文件中配置 Redis 连接信息：</p>
<pre><code class="language-yaml">spring:
  data:
    redis:
      database: 0    # Redis 数据库索引
      host: localhost  # Redis 主机地址
      port: 6379  # Redis 端口
      # 如果Redis 服务未设置密码，需要将password删掉或注释，而不是设置为空字符串
      password: 123456
      timeout: 10s
</code></pre>
<h3 id="自定义序列化">自定义序列化</h3>
<p>Spring Boot 默认使用 <code>JdkSerializationRedisSerializer</code> 进行序列化。我们可以通过自定义 <code>RedisTemplate</code>，将其修改为更易读的 <code>String</code> 和 <code>JSON</code> 序列化方式：</p>
<pre><code class="language-java">/**
 *  Redis 自动装配配置
 *
 * @author youlai
 * @since 2024/12/5
 */
@Configuration
public class RedisConfig {

    /**
     * 自定义 RedisTemplate
     * &lt;p&gt;
     * 修改 Redis 序列化方式，默认 JdkSerializationRedisSerializer
     *
     * @param redisConnectionFactory {@link RedisConnectionFactory}
     * @return {@link RedisTemplate}
     */
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {

        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setValueSerializer(RedisSerializer.json());

        redisTemplate.setHashKeySerializer(RedisSerializer.string());
        redisTemplate.setHashValueSerializer(RedisSerializer.json());

        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

}

</code></pre>
<h3 id="单元测试">单元测试</h3>
<p>在 <code>src/test/java</code> 目录的 <code>com.youlai.boot</code> 包下创建 <code>RedisTests</code> 单元测试类，用于验证数据的存储与读取。</p>
<pre><code class="language-java">@SpringBootTest
@Slf4j
class RedisTests {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @Autowired
    private SysUserService userService;

    @Test
    void testSetAndGet() {
        Long userId = 1L;
        // 1. 从数据库中获取用户信息
        SysUser user = userService.getById(userId);
        log.info("从数据库中获取用户信息: {}", user);

        // 2. 将用户信息缓存到 Redis
        redisTemplate.opsForValue().set("user:" + userId, user);

        // 3. 从 Redis 中获取缓存的用户信息
        SysUser cachedUser = (SysUser) redisTemplate.opsForValue().get("user:" + userId);
        log.info("从 Redis 中获取用户信息: {}", cachedUser);
    }
}
</code></pre>
<p>点击测试类方法左侧的 ▶️ 图标运行单元测试。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241205172902017.png" alt="" loading="lazy"></p>
<p>运行后，稍等片刻，若控制台成功打印从 Redis 获取的用户信息，则表示 Spring Boot 已成功集成 Redis。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241205174150218.png" alt="" loading="lazy"></p>
<h2 id="完善--web-框架">完善  Web 框架</h2>
<h3 id="统一响应处理">统一响应处理</h3>
<hr>
<p><strong>为什么需要统一响应？</strong></p>
<p>默认接口返回的数据结构仅包含业务数据，缺少状态码和提示信息，无法清晰表达操作结果。通过统一封装响应结构，可以提升接口的规范性，便于前后端协同开发和快速定位问题。</p>
<p>下图展示了不规范与规范响应数据的对比：左侧是默认返回的非标准数据，右侧是统一封装后的规范数据。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241211135138054.png" alt="" loading="lazy"></p>
<hr>
<p><strong>定义统一业务状态码</strong></p>
<p>在 <code>com.youlai.boot.common.result</code> 包下创建 <code>ResultCode</code>  枚举，错误码规范参考 <a href="https://developer.aliyun.com/article/766288" target="_blank" rel="noopener nofollow">阿里开发手册-错误码设计</a>。</p>
<pre><code class="language-java">package com.youlai.boot.common.result;

import java.io.Serializable;
import lombok.Getter;

/**
 * 统一业务状态码枚举
 *
 * @author youlai
 */
@Getter
public enum ResultCode implements Serializable {

    SUCCESS("00000", "操作成功"),
    TOKEN_INVALID("A0230", "Token 无效或已过期"),
    ACCESS_UNAUTHORIZED("A0301", "访问未授权"),
    SYSTEM_ERROR("B0001", "系统错误");

    private final String code;
    private final String message;

    ResultCode(String code, String message) {
        this.code = code;
        this.message = message;
    }
}
</code></pre>
<hr>
<p><strong>创建统一响应结构</strong></p>
<p>定义 <code>Result</code> 类，封装响应码、消息和数据。</p>
<pre><code class="language-java">package com.youlai.boot.common.result;

import lombok.Data;
import java.io.Serializable;

/**
 * 统一响应结构
 *
 * @author youlai
 **/
@Data
public class Result&lt;T&gt; implements Serializable {
    // 响应码
    private String code;
    // 响应数据
    private T data;
    // 响应信息
    private String msg;

    /**
     * 成功响应
     */
    public static &lt;T&gt; Result&lt;T&gt; success(T data) {
        Result&lt;T&gt; result = new Result&lt;&gt;();
        result.setCode(ResultCode.SUCCESS.getCode());
        result.setMsg(ResultCode.SUCCESS.getMsg());
        result.setData(data);
        return result;
    }

    /**
     * 失败响应
     */
    public static &lt;T&gt; Result&lt;T&gt; failed(ResultCode resultCode) {
        Result&lt;T&gt; result = new Result&lt;&gt;();
        result.setCode(resultCode.getCode());
        result.setMsg(resultCode.getMsg());
        return result;
    }

    /**
     * 失败响应(系统默认错误)
     */
    public static &lt;T&gt; Result&lt;T&gt; failed() {
        Result&lt;T&gt; result = new Result&lt;&gt;();
        result.setCode(ResultCode.SYSTEM_ERROR.getCode());
        result.setMsg(ResultCode.SYSTEM_ERROR.getMsg());
        return result;
    }

}
</code></pre>
<hr>
<p><strong>封装接口返回结果</strong></p>
<p>调整接口代码，返回统一的响应格式。</p>
<pre><code class="language-java">@Operation(summary = "获取用户详情")
@GetMapping("/{id}")
public Result&lt;SysUser&gt; getUserById(
    @Parameter(description = "用户ID") @PathVariable Long id
) {
    SysUser user = userService.getById(id);
    return Result.success(user);
}
</code></pre>
<hr>
<p><strong>效果预览</strong></p>
<p>接口返回结构变为标准格式：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241217162820446.png" alt="标准响应结果" loading="lazy"></p>
<p>通过以上步骤，接口响应数据已完成统一封装，具备良好的规范性和可维护性，有助于前后端协同开发与错误定位。</p>
<h3 id="全局异常处理">全局异常处理</h3>
<hr>
<p><strong>为什么需要全局异常处理</strong></p>
<p>如果没有统一的异常处理机制，抛出的业务异常和系统异常会以非标准格式返回，给前端的数据处理和问题排查带来困难。为了规范接口响应数据格式，需要引入全局异常处理。</p>
<p>以下接口模拟了一个业务逻辑中的异常：</p>
<pre><code class="language-java">@Operation(summary = "获取用户详情")
@GetMapping("/{id}")
public Result&lt;SysUser&gt; getUserById(
    @Parameter(description = "用户ID") @PathVariable Long id
) {
    // 模拟异常
    int i = 1 / 0;

    SysUser user = userService.getById(id);
    return Result.success(user);
}
</code></pre>
<p>当发生异常时，默认返回的数据格式如下所示：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241218002327617.png" alt="" loading="lazy"></p>
<p>这类非标准的响应格式既不直观，也不利于前后端协作。</p>
<p><strong>全局异常处理器</strong></p>
<p>在 <code>com.youlai.boot.common.exception</code> 包下创建全局异常处理器，用于捕获和处理系统异常。</p>
<pre><code class="language-java">package com.youlai.boot.common.exception;

import com.youlai.boot.common.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器
 *
 * @author youlai
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 处理系统异常
     * &lt;p&gt;
     * 兜底异常处理，处理未被捕获的异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public &lt;T&gt; Result&lt;T&gt; handleNullPointerException(Exception e) {
        log.error(e.getMessage(), e);
        return Result.failed("系统异常:" + e.getMessage());
    }

}
</code></pre>
<p><strong>验证全局异常处理</strong></p>
<p>再次访问用户接口  <a target="_blank">localhost:8080/users/1</a> ，可以看到响应已经包含状态码和提示信息，数据格式变得更加规范：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241218002541937.png" alt="" loading="lazy"></p>
<p><strong>自定义业务异常</strong></p>
<p>在实际开发中，可能需要对特定的业务异常进行处理。通过自定义异常类 <code>BusinessException</code>，可以实现更灵活的异常处理机制。</p>
<pre><code class="language-java">package com.youlai.boot.common.exception;

import com.youlai.boot.common.result.ResultCode;
import lombok.Getter;

/**
 * 自定义业务异常
 *
 * @author youlai
 */
@Getter
public class BusinessException extends RuntimeException {

    public ResultCode resultCode;

    public BusinessException(ResultCode errorCode) {
        super(errorCode.getMsg());
        this.resultCode = errorCode;
    }

    public BusinessException(String message) {
        super(message);
    }

}
</code></pre>
<p>在全局异常处理器中添加业务异常处理逻辑</p>
<pre><code class="language-java">@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 处理自定义业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public &lt;T&gt; Result&lt;T&gt; handleBusinessException(BusinessException e) {
        log.error(e.getMessage(), e);
        if(e.getResultCode()!=null){
            return Result.failed(e.getResultCode());
        }
        return Result.failed(e.getMessage());
    }

}
</code></pre>
<p>模拟业务异常</p>
<pre><code class="language-java">    @Operation(summary = "获取用户详情")
    @GetMapping("/{id}")
    public Result&lt;SysUser&gt; getUserById(
            @Parameter(description = "用户ID") @PathVariable Long id
    ) {
        SysUser user = userService.getById(-1);
        // 模拟异常
        if (user == null) {
            throw new BusinessException("用户不存在");
        }
        return Result.success(user);
    }

</code></pre>
<p>请求不存在的用户时，响应如下：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241218011857731.png" alt="" loading="lazy"></p>
<p>通过全局异常处理的引入和自定义业务异常的定义，接口的响应数据得以标准化，提升了前后端协作的效率和系统的可维护性。</p>
<h3 id="日志输出配置">日志输出配置</h3>
<p>日志作为企业级应用项目中的重要一环，不仅是调试问题的关键手段，更是用户问题排查和争议解决的强有力支持工具</p>
<p><strong>配置 <code>logback-spring.xml</code> 日志文件</strong></p>
<p>在 <code>src/main/resources</code> 目录下，新增 <code>logback-spring.xml</code> 配置文件。基于 Spring Boot "约定优于配置" 的设计理念，项目默认会自动加载并使用该配置文件。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;
&lt;configuration&gt;

    &lt;!-- SpringBoot默认logback的配置 --&gt;
    &lt;include resource="org/springframework/boot/logging/logback/defaults.xml"/&gt;

    &lt;springProperty scope="context" name="APP_NAME" source="spring.application.name"/&gt;
    &lt;property name="LOG_HOME" value="/logs/${APP_NAME}"/&gt;

    &lt;!-- 1. 输出到控制台--&gt;
    &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;!-- &lt;withJansi&gt;true&lt;/withJansi&gt;--&gt;
        &lt;!--此日志appender是为开发使用，只配置最低级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;
        &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;
            &lt;level&gt;DEBUG&lt;/level&gt;
        &lt;/filter&gt;
        &lt;encoder&gt;
            &lt;Pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/Pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 2. 输出到文件  --&gt;
    &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
        &lt;!-- 当前记录的日志文档完整路径 --&gt;
        &lt;file&gt;${LOG_HOME}/log.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;!--日志文档输出格式--&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} -%5level ---[%15.15thread] %-40.40logger{39} : %msg%n%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
        &lt;!-- 日志记录器的滚动策略，按大小和时间记录 --&gt;
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt;
            &lt;!-- 滚动后的日志文件命名模式 --&gt;
            &lt;fileNamePattern&gt;${LOG_HOME}/%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;
            &lt;!-- 单个日志文件的最大大小 --&gt;
            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
            &lt;!-- 最大保留30天的日志 --&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
            &lt;!-- 总日志文件大小不超过3GB --&gt;
            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;!-- 临界值过滤器，输出大于INFO级别日志 --&gt;
        &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;
            &lt;level&gt;INFO&lt;/level&gt;
        &lt;/filter&gt;
    &lt;/appender&gt;

    &lt;!-- 根日志记录器配置 --&gt;
    &lt;root level="INFO"&gt;
        &lt;!-- 引用上面定义的两个appender，日志将同时输出到控制台和文件 --&gt;
        &lt;appender-ref ref="CONSOLE"/&gt;
        &lt;appender-ref ref="FILE"/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>查看日志输出效果</strong></p>
<p>添加配置文件后，启动项目并触发相关日志行为，控制台和日志文件会同时输出日志信息：</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241218112111080.png" alt="" loading="lazy"></p>
<h2 id="集成--spring-security">集成  Spring Security</h2>
<p>Spring Security 是一个强大的安全框架，可用于身份认证和权限管理。</p>
<h3 id="添加依赖-3">添加依赖</h3>
<p>在 <code>pom.xml</code> 添加 <code>Spring Security</code> 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="获取用户认证信息">获取用户认证信息</h3>
<p>从数据库获取用户信息(用户名、密码、角色)，用于和前端输入的用户名密码做判读，如果认证成功，将角色权限信息绑定到用户会话，简单概括就是提供给认证授权的用户信息。</p>
<p><strong>定义用户认证信息类 UserDetails</strong></p>
<p>创建 <code>com.youlai.boot.security.model</code> 包，新建 <code>SysUserDetails</code> 用户认证信息对象，继承 Spring Security 的 UserDetails 接口</p>
<pre><code class="language-java">/**
 * Spring Security 用户认证信息对象
 * &lt;p&gt;
 * 封装了用户的基本信息和权限信息，供 Spring Security 进行用户认证与授权。
 * 实现了 {@link UserDetails} 接口，提供用户的核心信息。
 *
 * @author youlai
 */
@Data
@NoArgsConstructor
public class SysUserDetails implements UserDetails {

    /**
     * 用户ID
     */
    private Integer userId;

    /**
     * 用户名
     */
    private String username;

    /**
     * 密码
     */
    private String password;

    /**
     * 账号是否启用（true：启用，false：禁用）
     */
    private Boolean enabled;

    /**
     * 用户角色权限集合
     */
    private Collection&lt;SimpleGrantedAuthority&gt; authorities;

    /**
     * 根据用户认证信息初始化用户详情对象
     */
    public SysUserDetails(SysUser user) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.password = user.getPassword();
        this.enabled = ObjectUtil.equal(user.getStatus(), 1);

        // 初始化角色权限集合
        this.authorities = CollectionUtil.isNotEmpty(user.getRoles())
                ? user.getRoles().stream()
                // 角色名加上前缀 "ROLE_"，用于区分角色 (ROLE_ADMIN) 和权限 (sys:user:add)
                .map(role -&gt; new SimpleGrantedAuthority("ROLE_" + role))
                .collect(Collectors.toSet())
                : Collections.emptySet();
    }

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return this.authorities;
    }

    @Override
    public String getPassword() {
        return this.password;
    }

    @Override
    public String getUsername() {
        return this.username;
    }

    @Override
    public boolean isEnabled() {
        return this.enabled;
    }
}
</code></pre>
<p><strong>获取用户认证信息服务类</strong></p>
<p>创建 <code>com.youlai.boot.security.service</code> 包，新建 <code>SysUserDetailsService</code> 用户认证信息加载服务类，继承 Spring Security 的 UserDetailsService 接口</p>
<pre><code class="language-java">/**
 * 用户认证信息加载服务类
 * &lt;p&gt;
 * 在用户登录时，Spring Security 会自动调用该类的 {@link #loadUserByUsername(String)} 方法，
 * 获取封装后的用户信息对象 {@link SysUserDetails}，用于后续的身份验证和权限管理。
 *
 * @author youlai
 */
@Service
@RequiredArgsConstructor
public class SysUserDetailsService implements UserDetailsService {

    private final SysUserService userService;

    /**
     * 根据用户名加载用户的认证信息
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 查询用户基本信息
        SysUser user = userService.getOne(new LambdaQueryWrapper&lt;SysUser&gt;()
                .eq(SysUser::getUsername, username)
        );
        if (user == null) {
            throw new UsernameNotFoundException(username);
        }
        // 模拟设置角色，实际应从数据库获取用户角色信息
        Set&lt;String&gt; roles = Set.of("ADMIN");
        user.setRoles(roles);

        // 模拟设置权限，实际应从数据库获取用户权限信息
        Set&lt;String&gt; perms = Set.of("sys:user:query");
        user.setPerms(perms);

        // 将数据库中查询到的用户信息封装成 Spring Security 需要的 UserDetails 对象
        return new SysUserDetails(user);
    }
}
</code></pre>
<h3 id="认证鉴权异常处理">认证鉴权异常处理</h3>
<p>在 <code>com.youlai.boot.common.util</code> 添加响应工具类  <code>ResponseUtils</code></p>
<pre><code class="language-java">@Slf4j
public class ResponseUtils {

    /**
     * 异常消息返回(适用过滤器中处理异常响应)
     *
     * @param response  HttpServletResponse
     * @param resultCode 响应结果码
     */
    public static void writeErrMsg(HttpServletResponse response, ResultCode resultCode) {
        // 根据不同的结果码设置HTTP状态
        int status = switch (resultCode) {
            case ACCESS_UNAUTHORIZED, 
            	ACCESS_TOKEN_INVALID 
                    -&gt; HttpStatus.UNAUTHORIZED.value();
            default -&gt; HttpStatus.BAD_REQUEST.value();
        };

        response.setStatus(status);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        try (PrintWriter writer = response.getWriter()) {
            String jsonResponse = JSONUtil.toJsonStr(Result.failed(resultCode));
            writer.print(jsonResponse);
            writer.flush(); // 确保将响应内容写入到输出流
        } catch (IOException e) {
            log.error("响应异常处理失败", e);
        }
    }

}
</code></pre>
<table>
<thead>
<tr>
<th>功能</th>
<th><code>AuthenticationEntryPoint</code></th>
<th><code>AccessDeniedHandler</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>对应异常</strong></td>
<td><code>AuthenticationException</code></td>
<td><code>AccessDeniedException</code></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>用户未认证（无凭证或凭证无效）</td>
<td>用户已认证但无权限</td>
</tr>
<tr>
<td><strong>返回 HTTP 状态码</strong></td>
<td><code>401 Unauthorized</code></td>
<td><code>403 Forbidden</code></td>
</tr>
<tr>
<td><strong>常见使用位置</strong></td>
<td>用于处理身份认证失败的全局入口逻辑</td>
<td>用于处理权限不足时的逻辑</td>
</tr>
</tbody>
</table>
<p><strong>用户未认证处理器</strong></p>
<pre><code class="language-java">/**
 * 未认证处理器
 *
 * @author youlai
 */
@Slf4j
public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {
        if (authException instanceof BadCredentialsException) {
            // 用户名或密码错误
            ResponseUtils.writeErrMsg(response, ResultCode.USER_PASSWORD_ERROR);
        } else {
            // token 无效或者 token 过期
            ResponseUtils.writeErrMsg(response, ResultCode.TOKEN_INVALID);
        }
    }
    
}
</code></pre>
<p><strong>无权限访问处理器</strong></p>
<pre><code class="language-java">/**
 * 无权限访问处理器
 *
 * @author youlai
 */
public class MyAccessDeniedHandler implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) {
        ResponseUtils.writeErrMsg(response, ResultCode.ACCESS_UNAUTHORIZED);
    }

}
</code></pre>
<p><strong>注意事项</strong></p>
<p>需要在全局异常不能捕获认证和鉴权异常，不然不能交给 spring security 异常处理器处理</p>
<pre><code class="language-java">public class GlobalExceptionHandler {

    /**
     * 处理系统异常
     * &lt;p&gt;
     * 兜底异常处理，处理未被捕获的异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public &lt;T&gt; Result&lt;T&gt; handleNullPointerException(Exception e) throws Exception {
        // 如果是 Spring Security 的认证异常或授权异常，直接抛出，交由 Spring Security 的异常处理器处理
        if (e instanceof AccessDeniedException
                || e instanceof AuthenticationException) {
            throw e;
        }

        log.error(e.getMessage(), e);
        return Result.failed("系统异常，请联系管理员");
    }

}
</code></pre>
<h3 id="认证授权配置">认证授权配置</h3>
<p>在 <code>com.youlai.boot.config</code> 包下新建 <code>SecurityConfig</code> 用来 Spring Security 安全配置</p>
<pre><code class="language-java">/**
 * Spring Security 安全配置
 *
 * @author youlai
 */
@Configuration
@EnableWebSecurity  // 启用 Spring Security 的 Web 安全功能，允许配置安全过滤链
@EnableMethodSecurity // 启用方法级别的安全控制（如 @PreAuthorize 等）
public class SecurityConfig {

    /**
     * 忽略认证的 URI 地址
     */
    private final String[] IGNORE_URIS = {"/api/v1/auth/login"};

    /**
     * 配置安全过滤链，用于定义哪些请求需要认证或授权
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        // 配置认证与授权规则
        http
                .authorizeHttpRequests(requestMatcherRegistry -&gt;
                        requestMatcherRegistry
                                .requestMatchers(IGNORE_URIS).permitAll() // 登录接口无需认证
                                .anyRequest().authenticated() // 其他请求必须认证
                )
                // 使用无状态认证，禁用 Session 管理（前后端分离 + JWT）
                .sessionManagement(configurer -&gt;
                        configurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                // 禁用 CSRF 防护（前后端分离通过 Token 验证，不需要 CSRF）
                .csrf(AbstractHttpConfigurer::disable)
                // 禁用默认的表单登录功能
                .formLogin(AbstractHttpConfigurer::disable)
                // 禁用 HTTP Basic 认证（统一使用 JWT 认证）
                .httpBasic(AbstractHttpConfigurer::disable)
                // 禁用 X-Frame-Options 响应头，允许页面被嵌套到 iframe 中
                .headers(headers -&gt;
                        headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::disable)
                )
                // 异常处理
                .exceptionHandling(configurer -&gt; {
                    configurer
                            .authenticationEntryPoint(new MyAuthenticationEntryPoint()) // 未认证处理器
                            .accessDeniedHandler(new MyAccessDeniedHandler()); // 无权限访问处理器
                });
            
            ;

        return http.build();
    }

    /**
     * 配置密码加密器
     *
     * @return 密码加密器
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
     /**
     * 用于配置不需要认证的 URI 地址
     */
    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (web) -&gt; {
            web.ignoring().requestMatchers(
                    "/v3/api-docs/**",
                    "/swagger-ui/**",
                    "/swagger-ui.html",
                    "/webjars/**",
                    "/doc.html"
            );
        };
    }

    /**
     *认证管理器
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }
}

</code></pre>
<h3 id="token-工具类">Token 工具类</h3>
<p>在 <code>com.youlai.boot.security.manager</code> 包下新建 <code>JwtTokenManager</code> ，用于生成和解析 token</p>
<pre><code class="language-java">/**
 * JWT Token 管理类
 *
 * @author youlai
 */
@Service
public class JwtTokenManager {

    /**
     * JWT 密钥，用于签名和解签名
     */
    private final String secretKey = " SecretKey012345678901234567890123456789012345678901234567890123456789";

    /**
     * 访问令牌有效期(单位：秒), 默认 1 小时
     */
    private final Integer accessTokenTimeToLive = 3600;

    /**
     *  生成 JWT 访问令牌 - 用于登录认证成功后生成 JWT Token
     *
     * @param authentication 用户认证信息
     * @return JWT 访问令牌
     */
    public String generateToken(Authentication authentication) {
        SysUserDetails userDetails = (SysUserDetails) authentication.getPrincipal();
        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();
        // 将用户 ID 放入 JWT 载荷中， 如有其他扩展字段也可以放入
        payload.put("userId", userDetails.getUserId());

        // 将用户的角色和权限信息放入 JWT 载荷中，例如：["ROLE_ADMIN", "sys:user:query"]
        Set&lt;String&gt; authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());
        payload.put("authorities", authorities);

        Date now = new Date();
        payload.put(JWTPayload.ISSUED_AT, now);

        // 设置过期时间 -1 表示永不过期
        if (accessTokenTimeToLive != -1) {
            Date expiresAt = DateUtil.offsetSecond(now, accessTokenTimeToLive);
            payload.put(JWTPayload.EXPIRES_AT, expiresAt);
        }
        payload.put(JWTPayload.SUBJECT, authentication.getName());
        payload.put(JWTPayload.JWT_ID, IdUtil.simpleUUID());

        return JWTUtil.createToken(payload, secretKey.getBytes());
    }


    /**
     * 解析 JWT Token 获取 Authentication 对象 - 用于接口请求时解析 JWT Token 获取用户信息
     *
     * @param token JWT Token
     * @return Authentication 对象
     */
    public Authentication parseToken(String token) {

        JWT jwt = JWTUtil.parseToken(token);
        JSONObject payloads = jwt.getPayloads();
        SysUserDetails userDetails = new SysUserDetails();
        userDetails.setUserId(payloads.getInt("userId")); // 用户ID
        userDetails.setUsername(payloads.getStr(JWTPayload.SUBJECT)); // 用户名
        // 角色集合
        Set&lt;SimpleGrantedAuthority&gt; authorities = payloads.getJSONArray("authorities")
                .stream()
                .map(authority -&gt; new SimpleGrantedAuthority(Convert.toStr(authority)))
                .collect(Collectors.toSet());

        return new UsernamePasswordAuthenticationToken(userDetails, "", authorities);
    }

    /**
     *  验证 JWT Token 是否有效
     *
     * @param token JWT Token 不携带 Bearer 前缀
     * @return 是否有效
     */
    public boolean validateToken(String token) {
        JWT jwt = JWTUtil.parseToken(token);
        // 检查 Token 是否有效(验签 + 是否过期)
        return jwt.setKey(secretKey.getBytes()).validate(0);
    }

}
</code></pre>
<h3 id="登录认证接口">登录认证接口</h3>
<p>在 <code>com.youlai.boot.controller</code> 包下新建 <code>AuthController</code></p>
<pre><code class="language-java">/**
 * 认证控制器
 *
 * @author youlai
 */
@Tag(name = "01.认证中心")
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthController {

    // 认证管理器 - 用于执行认证
    private final AuthenticationManager authenticationManager;

    // JWT 令牌服务类 - 用于生成 JWT 令牌
    private final JwtTokenManager jwtTokenManager;

    @Operation(summary = "登录")
    @PostMapping("/login")
    public Result&lt;String&gt; login(
            @Parameter(description = "用户名", example = "admin") @RequestParam String username,
            @Parameter(description = "密码", example = "123456") @RequestParam String password
    ) {

        // 1. 创建用于密码认证的令牌（未认证）
        UsernamePasswordAuthenticationToken authenticationToken =
                new UsernamePasswordAuthenticationToken(username.trim(), password);

        // 2. 执行认证（认证中）
        Authentication authentication = authenticationManager.authenticate(authenticationToken);

        // 3. 认证成功后生成 JWT 令牌（已认证）
        String accessToken = jwtTokenManager.generateToken(authentication);

        return Result.success(accessToken);
    }
}
</code></pre>
<p>访问本地接口文档 <a href="http://localhost:8080/doc.html" target="_blank" rel="noopener nofollow">http://localhost:8080/doc.html</a> 选择登录接口进行调试发送请求，输入用户名和密码，如果登录成功返回访问令牌 token</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241222162606665.png" alt="image-20241222162606665" loading="lazy"></p>
<p>访问 <a href="https://jwt.io/" target="_blank" rel="noopener nofollow">https://jwt.io/</a> 解析返回的 token ，主要分为三部分  Header(头部) 、Payload(负载) 和 Signature(签名) ，其中负载除了固定字段之外，还出现自定义扩展的字段 userId。</p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241222163923899.png" alt="" loading="lazy"></p>
<h3 id="访问鉴权">访问鉴权</h3>
<p>我们拿获取用户列表举例，首先需要验证我们在上一步登录拿到的访问令牌 token 是否有效（验签、是否过期等），然后需要校验该用户是否有访问接口的权限，本节就围绕以上问题展开。</p>
<p><strong>验证解析 Token 过滤器</strong></p>
<p>新建 <code>com.youlai.boot.security.filter</code>  添加  <code>JwtValidationFilter</code> 过滤器 用于验证和解析token</p>
<pre><code class="language-java">/**
 * JWT Token 验证和解析过滤器
 * &lt;p&gt;
 * 负责从请求头中获取 JWT Token，验证其有效性并将用户信息设置到 Spring Security 上下文中。
 * 如果 Token 无效或解析失败，直接返回错误响应。
 * &lt;/p&gt;
 *
 * @author youlai
 */
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final String BEARER_PREFIX = "Bearer ";

    private final JwtTokenManager jwtTokenManager;

    public JwtAuthenticationFilter(JwtTokenManager jwtTokenManager) {
        this.jwtTokenManager = jwtTokenManager;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);
        try {
            if (StrUtil.isNotBlank(token) &amp;&amp; token.startsWith(BEARER_PREFIX)) {
                // 去除 Bearer 前缀
                token = token.substring(BEARER_PREFIX.length());
                // 校验 JWT Token ，包括验签和是否过期
                boolean isValidate = jwtTokenService.validateToken(token);
                if (!isValidate) {
                    writeErrMsg(response, ResultCode.TOKEN_INVALID);
                    return;
                }
                // 将 Token 解析为 Authentication 对象，并设置到 Spring Security 上下文中
                Authentication authentication = jwtTokenManager.parseToken(token);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            SecurityContextHolder.clearContext();
            writeErrMsg(response, ResultCode.TOKEN_INVALID);
            return;
        }
        
        // 无 Token 或 Token 验证通过时，继续执行过滤链。
        // 如果请求不在白名单内（例如登录接口、静态资源等），
        // 后续的 AuthorizationFilter 会根据配置的权限规则和安全策略进行权限校验。
        // 例如：
        // - 匹配到 permitAll() 的规则会直接放行。
        // - 需要认证的请求会校验 SecurityContext 中是否存在有效的 Authentication。
        // 若无有效 Authentication 或权限不足，则返回 403 Forbidden。
        filterChain.doFilter(request, response);
    }

    /**
     * 异常消息返回
     *
     * @param response  HttpServletResponse
     * @param resultCode 响应结果码
     */
    public static void writeErrMsg(HttpServletResponse response, ResultCode resultCode) {
        int status = switch (resultCode) {
            case ACCESS_UNAUTHORIZED, TOKEN_INVALID -&gt; HttpStatus.UNAUTHORIZED.value();
            default -&gt; HttpStatus.BAD_REQUEST.value();
        };

        response.setStatus(status);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        try (PrintWriter writer = response.getWriter()) {
            String jsonResponse = JSONUtil.toJsonStr(Result.failed(resultCode));
            writer.print(jsonResponse);
            writer.flush();
        } catch (IOException e) {
            // 日志记录：捕获响应写入失败异常
            // LOGGER.error("Error writing response", e);
        }
    }
}
</code></pre>
<p><strong>添加 JWT 验证和解析过滤器</strong></p>
<p>在 SecurityConfig 过滤器链添加 JWT token校验和解析成 Authentication 对象的过滤器。</p>
<pre><code class="language-java">/**
 * Spring Security 安全配置
 *
 * @author youlai
 */
@RequiredArgsConstructor
public class SecurityConfig {

    // JWT Token 服务 , 用于 Token 的生成、解析、验证等操作
    private final JwtTokenManager jwtTokenManager;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      	return http 
                // ... 
                // JWT 验证和解析过滤器
                .addFilterBefore(new JwtAuthenticationFilter(jwtTokenManager), UsernamePasswordAuthenticationFilter.class)
		  .build();
    }

    // ...
}

</code></pre>
<p><strong>获取用户列表接口</strong></p>
<pre><code class="language-java">
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final SysUserService userService;

    @Operation(summary = "获取用户列表")
    @GetMapping
    @PreAuthorize("hasAuthority('sys:user:query')")
    public List&lt;SysUser&gt; listUsers() {
        return userService.list();
    }
    
}
</code></pre>
<p>访问一个主要测试访问凭据令牌是否认证以及对应的用户是否有访问该接口所需的权限，上面获取用户信息列表的接口未配置在security的白名单中，也就是需要认证，且被 @PreAuthorize("hasAuthority('sys:user:query')") 标记说明用户需要有 <code>sys:user:query</code>的权限，也就是所谓的鉴权。</p>
<p><strong>正常访问</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241224175237422.png" alt="" loading="lazy"></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241224175350088.png" alt="image-20241224175350088" loading="lazy"></p>
<p><strong>不携带 token 访问</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241224175510723.png" alt="" loading="lazy"></p>
<p><strong>携带错误/过期的 token</strong></p>
<p><img src="https://www.youlai.tech/storage/blog/image-20241224175837092.png" alt="" loading="lazy"></p>
<p><strong>有访问权限</strong></p>
<p>用户拥有的权限 <code>sys:user:query</code></p>
<pre><code class="language-java">public class UserController {

    @Operation(summary = "获取用户列表")
    @GetMapping
    @PreAuthorize("hasAuthority('sys:user:query')")  // 需要 sys:user:query 权限
    public List&lt;SysUser&gt; listUsers() {
        return userService.list();
    }
    
}
</code></pre>
<p><img src="https://www.youlai.tech/storage/blog/image-20241225000633295.png" alt="image-20241225000633295" loading="lazy"></p>
<p><strong>无访问权限</strong></p>
<p>用户没有拥有的权限 <code>sys:user:info</code></p>
<pre><code class="language-java">public class UserController {

    @Operation(summary = "获取用户详情")
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('sys:user:info')") // 需要 sys:user:info 权限
    public Result&lt;SysUser&gt; getUserById(
            @Parameter(description = "用户ID") @PathVariable Long id
    ) {
        SysUser user = userService.getById(id);
    }     
}
</code></pre>
<p><img src="https://www.youlai.tech/storage/blog/image-20241225000802438.png" alt="" loading="lazy"></p>
<h1 id="结语">结语</h1>
<p>通过本文，您将了解企业级后端开发的核心技能和项目从搭建到部署的完整流程。如有兴趣，欢迎访问开源项目：<a href="https://gitee.com/youlaiorg" target="_blank" rel="noopener nofollow">https://gitee.com/youlaiorg</a>，关注公众号 有来技术，或添加微信（微信号：haoxianrui）参与开源交流。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3466893622951389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-21 10:06">2025-01-21 10:05</span>&nbsp;
<a href="https://www.cnblogs.com/haoxianrui">有来技术</a>&nbsp;
阅读(<span id="post_view_count">157</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18683051" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18683051);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18683051', targetLink: 'https://www.cnblogs.com/haoxianrui/p/18683051', title: '「youlai-boot」入门篇：从0到1搭建 Java、Spring Boot、Spring Security 企业级权限管理系统' })">举报</a>
</div>
        