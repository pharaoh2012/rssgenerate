
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/18949074" title="发布于 2025-06-25 23:54">
    <span role="heading" aria-level="2">Golang基础笔记四之map</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/nMglcZmoN8o-AGjqEkodpg" target="_blank" rel="noopener nofollow">Golang基础笔记四之map</a></p>
</blockquote>
<p>这一篇笔记介绍 Golang 里 map 相关的内容，以下是本篇笔记目录：</p>
<ol>
<li>map 的概念及其声明与初始化</li>
<li>map 的增删改查</li>
<li>map 的遍历</li>
</ol>
<h3 id="1map-的概念及其声明与初始化">1、map 的概念及其声明与初始化</h3>
<p>map，即映射，是 Golang 里无序键值对的集合。</p>
<p>以下是创建 map 的两种方式。</p>
<h4 id="1-使用-make-的方式创建">1. 使用 make 的方式创建</h4>
<pre><code class="language-go">    m := make(map[string]int)
    m["Hunter"] = 1
    fmt.Println(m)
</code></pre>
<p>使用 make 进行初始化的时候，也可以指定其容量大小：</p>
<pre><code class="language-go">m := make(map[string]int, 4)
</code></pre>
<h4 id="2-映射字面量初始化">2. 映射字面量初始化</h4>
<pre><code class="language-go">    m := map[string]int{
        "Hunter": 1,
    }
    fmt.Println(m)
</code></pre>
<p><strong>注意</strong>：当我们声明一个 map 之后，它的值是 nil，即 Go 里的空值，一定要对其初始化之后才可向其中添加元素。</p>
<p>比如下面的操作会引发错误：</p>
<pre><code class="language-go">    var m map[string]int
    m["Hunter"] = 1 // 错误，需要初始化
</code></pre>
<p>下面的操作才是正确的操作：</p>
<pre><code class="language-go">    var m map[string]int
    m = make(map[string]int)
    m["Hunter"] = 1
    fmt.Println(m)
</code></pre>
<p>介绍这个操作是因为在多重 map 或者说嵌套的 map 里很容易忘记这个操作。</p>
<h4 id="3-多重-map">3. 多重 map</h4>
<p>比如我们想创建一个多重 map，其示例数据如下：</p>
<pre><code class="language-json">{
    "张三": {
        "number": "00001",
        "email": "123@qq.com"
    },
    "李四": {
        "number": "00002",
        "email": "456@qq.com"
    }
}
</code></pre>
<p>我们可以如此操作：</p>
<pre><code class="language-go">var m = make(map[string]map[string]string)
m["张三"] = make(map[string]string)
m["张三"]["number"] = "00001"
m["张三"]["email"] = "123@qq.com"

m["李四"] = make(map[string]string)
m["李四"]["number"] = "00002"
m["李四"]["email"] = "456@qq.com"

fmt.Println(m)
</code></pre>
<h3 id="2map-的增删改查">2、map 的增删改查</h3>
<p>我们先定义一个 map 如下：</p>
<pre><code class="language-go">m := make(map[string]int)
</code></pre>
<h4 id="1-增">1. 增</h4>
<p>如果想要往其中增加一个 key-value，可以直接添加：</p>
<pre><code class="language-go">m["a"] = 1
</code></pre>
<h4 id="2-改">2. 改</h4>
<p>如果想要修改其中的值，跟增加一个元素的操作一样：</p>
<pre><code class="language-go">m["a"] = 2
</code></pre>
<h4 id="3-查">3. 查</h4>
<p>如果想查询某个 key 对应的 value，可以如下操作：</p>
<pre><code class="language-go">value := m["a"]
fmt.Println(value)
</code></pre>
<p>而如果这个 key 是不存在的，这个操作也不会报错，而是会返回对应 value 类型的零值。</p>
<p>所谓零值，就是变量被声明但却未显式初始化时，系统自动赋予该变量的默认值，比如整型变量的零值是 0，布尔型的零值是 false，字符串的零值是空字符串 "" 等。</p>
<p>比如这里我们获取 <code>key = "b"</code>，其返回的结果就是 int 型的零值 0：</p>
<pre><code class="language-go">value := m["b"]
fmt.Println(value) // 0
</code></pre>
<p>这里如果我们要区分 map 中这个 key 对应的 value 值是 0，还是这个 key 不存在于 map 中的话，有时候会不太好判断，那么我们可以用另一种方式来操作：</p>
<pre><code class="language-go">value, exists := m["b"]
if exists {
    fmt.Printf("m 存在 key 为 b 的数据，value 为 %d", value)
} else {
    fmt.Printf("m 不存在 key 为 b 的数据")
}
</code></pre>
<h4 id="4-删">4. 删</h4>
<p>如果想要删除 map 中的某个 key，可以如下操作：</p>
<pre><code class="language-go">delete(m, "a")
</code></pre>
<p>这里，即便是对应的 key 不存在于 map 中，这个操作也不会报错。</p>
<h4 id="5-清空-map">5. 清空 map</h4>
<p>如果想要清空一个 map，可以使用 for 循环对 map 的 key 挨个删除：</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 2,
&nbsp; &nbsp; "c": 3,
}
fmt.Println(m)
for key, _ := range m {
&nbsp; &nbsp; delete(m, key)
}
fmt.Println(m)
</code></pre>
<p>另一种更高效的方案就是重新对其初始化操作：</p>
<pre><code class="language-go">fmt.Println(m)
m = make(map[string]int)
fmt.Println(m)
</code></pre>
<h3 id="3map-的遍历">3、map 的遍历</h3>
<p>我们可以使用 for 循环对 map 进行遍历操作：</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 2,
&nbsp; &nbsp; "c": 3,
}
for key, value := range m {
&nbsp; &nbsp; fmt.Printf("Key: %s, Value: %d\n", key, value)
}
</code></pre>
<h4 id="1-按照-key-正序排列遍历打印">1. 按照 key 正序排列遍历打印</h4>
<p>下面这个操作是先将 map 中的 key 做成一个切片，然后对切片进行排序，最后再遍历切片即可。</p>
<p>注意：这里需要引入 <code>sort</code> 模块</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 3,
&nbsp; &nbsp; "c": 2,
}

keyList := make([]string, 0, len(m))

for key, _ := range m {
&nbsp; &nbsp; keyList = append(keyList, key)
}

sort.Strings(keyList)

for _, key := range keyList {
&nbsp; &nbsp; fmt.Println(key, m[key])
}
</code></pre>
<h4 id="2-按照-key-倒序排列遍历打印">2. 按照 key 倒序排列遍历打印</h4>
<p>同样，这里也是将 key 全部取出来，然后倒序操作：</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 3,
&nbsp; &nbsp; "c": 2,
}

keyList := make([]string, 0, len(m))

for key, _ := range m {
&nbsp; &nbsp; keyList = append(keyList, key)
}

sort.Slice(keyList, func(i, j int) bool {
&nbsp; &nbsp; return keyList[i] &gt; keyList[j]
})

for _, key := range keyList {
&nbsp; &nbsp; fmt.Println(key, m[key])
}
</code></pre>
<h4 id="3-按照-value-正序排列遍历打印">3. 按照 value 正序排列遍历打印</h4>
<p>对 value 进行排序，这里的做法是先定义一个结构体 struct，然后将 map 中的 key-value 赋值到这个 struct，做成一个 struct 切片，然后对结构体切片按 value 进行排序。</p>
<p>这里结构体的概念会在后面介绍，这里先直接使用：</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 3,
&nbsp; &nbsp; "c": 2,
}

type kv struct {
&nbsp; &nbsp; Key &nbsp; string
&nbsp; &nbsp; Value int
}

var sortedKV []kv

for k, v := range m {
&nbsp; &nbsp; sortedKV = append(sortedKV, kv{k, v})
}

sort.Slice(sortedKV, func(i, j int) bool {
&nbsp; &nbsp; return sortedKV[i].Value &lt; sortedKV[j].Value
})

for _, kv := range sortedKV {
&nbsp; &nbsp; fmt.Printf("%s: %d\n", kv.Key, kv.Value)
}
</code></pre>
<h4 id="4-按照-value-倒序排列遍历打印">4. 按照 value 倒序排列遍历打印</h4>
<p>按照 value 倒序排列的方式与按 value 正序排列的方式类似，只是需要将排序规则改为 <code>&gt;</code> 即可：</p>
<pre><code class="language-go">m := map[string]int{
&nbsp; &nbsp; "a": 1,
&nbsp; &nbsp; "b": 3,
&nbsp; &nbsp; "c": 2,
}

type kv struct {
&nbsp; &nbsp; Key &nbsp; string
&nbsp; &nbsp; Value int
}

var sortedKV []kv

for k, v := range m {
&nbsp; &nbsp; sortedKV = append(sortedKV, kv{k, v})
}

sort.Slice(sortedKV, func(i, j int) bool {
&nbsp; &nbsp; return sortedKV[i].Value &gt; sortedKV[j].Value
})

for _, kv := range sortedKV {
&nbsp; &nbsp; fmt.Printf("%s: %d\n", kv.Key, kv.Value)
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-25 23:54">2025-06-25 23:54</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18949074);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18949074', targetLink: 'https://www.cnblogs.com/hunterxiong/p/18949074', title: 'Golang基础笔记四之map' })">举报</a>
</div>
        