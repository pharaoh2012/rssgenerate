
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18719177" title="发布于 2025-02-16 23:59">
    <span role="heading" aria-level="2">JUC并发-4.wait和notify以及Atomic原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="1" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="2"><strong>1.wait()与notify()实现一个简易的内存队列</strong></p>
<p data-track="3"><strong>2.wait()与notify()的底层原理</strong></p>
<p data-track="4"><strong>3.分布式存储系统NameNode机制介绍</strong></p>
<p data-track="5"><strong>4.分布式存储系统的edits log机制介绍</strong></p>
<p data-track="6"><strong>5.分布式存储系统的NameNode实现</strong></p>
<p data-track="7"><strong>6.分布式存储系统的创建目录功能的实现</strong></p>
<p data-track="8"><strong>7.edits log的全局txid机制和双缓冲机制实现</strong></p>
<p data-track="9"><strong>8.synchronized实现edits log分段加锁机制</strong></p>
<p data-track="10"><strong>9.wait()与notify()实现edits log批量刷磁盘</strong></p>
<p data-track="11"><strong>10.i++和AtomicInteger分别实现并发安全</strong></p>
<p data-track="12"><strong>11.AtomicInteger中的CAS无锁化原理</strong></p>
<p data-track="13"><strong>12.Atomic源码之仅限JDK使用的Unsafe类</strong></p>
<p data-track="14"><strong>13.Atomic源码之无限重复循环以及CAS操作</strong></p>
<p data-track="15"><strong>14.Atomic原子类基于CAS操作的三大问题</strong></p>
<p data-track="16"><strong>15.AtomicLong优化服务注册中心心跳计数器</strong></p>
<p data-track="17"><strong>16.LongAdder的分段CAS优化多线程自旋</strong></p>
<p data-track="18"><strong>17.LongAdder的分段CAS优化心跳计数器</strong></p>
<p data-track="19"><strong>18.服务注册中心的增量拉取机制</strong></p>
<p data-track="20"><strong>19.AtomicReference优化客户端缓存注册表</strong></p>
<p data-track="21"><strong>20.AtomicStampedReference解决ABA问题</strong></p>
<p data-track="22"><strong>21.AtomicLong多线程拉取注册表版本不错乱</strong></p>
<p data-track="23">&nbsp;</p>
<p data-track="24"><strong>1.wait()与notify()实现一个简易的内存队列</strong></p>
<p data-track="25">在多线程开发中，wait()和notify()/notifyAll()还是挺常见的。在分布式系统里经常会使用wait()和notifyAll()来进行线程通信，当某个线程处于阻塞等待状态时，其他线程可以进行通知并唤醒它。</p>
<p data-track="26">&nbsp;</p>
<p data-track="27">如下代码向内存队列添加元素和获取元素时，都使用了MyQueue对象锁。当内存队列满或者空时，需要释放锁，才能让添加或者获取继续下去。其中wait()方法会释放锁，并让当前线程进入等待状态，而notify()方法和notifyAll()方法会唤醒等待获取锁的线程。所以wait()和notify()主要是用来控制线程的，当然也可认为用于线程通信。</p>
<pre class="highlighter-hljs"><code>public class MyQueue {
    private final static int MAX_SIZE = 100;
    private LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();
   
    //向内存队列添加一个元素
    public synchronized void offer(String element) {
        try {
            if (queue.size() == MAX_SIZE) {
                //一个线程只要执行到这一步，就说明已经获取到锁
                //但现在内存队列已经满了，所以可以让线程进入一个等待的状态，并释放锁
                wait();
            }
            queue.addLast(element);
            //唤醒当前在等待锁的线程
            notifyAll();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取内存队列的第一个元素
    public synchronized String take() {
        //别的线程可以通过take()方法从队列里获取数据
        String element = null;
        try {
            if (queue.size() == 0) {
                //释放锁，并让当前线程自己进行阻塞等待
                //等待其他线程往内存队列放入数据后，通过notifyAll()来唤醒自己
                wait();
            }
            element = queue.removeFirst();
            //唤醒当前在等待锁的线程
            notifyAll();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return element;
    }
}</code></pre>
<p data-track="29">&nbsp;</p>
<p data-track="30"><strong>2.wait()与notify()的底层原理</strong></p>
<p data-track="31"><strong>(1)获取重量级锁之前的锁膨胀</strong></p>
<p data-track="32"><strong>(2)ObjectMonitor对象的重要字段</strong></p>
<p data-track="33"><strong>(3)重量级锁的获取流程</strong></p>
<p data-track="34"><strong>(4)重量级锁的释放流程</strong></p>
<p data-track="35"><strong>(5)wait()与notify()的底层原理</strong></p>
<p data-track="36"><strong>(6)wait()与notify()在使用时的注意事项</strong></p>
<p data-track="37">&nbsp;</p>
<p data-track="38"><strong>(1)获取重量级锁之前的锁膨胀</strong></p>
<p data-track="39">如果线程在运行synchronized修饰的同步块代码时，发现锁状态是轻量级锁并且有其他线程抢占了锁资源，那么该线程就会触发锁膨胀升级到重量级锁。</p>
<p data-track="40">&nbsp;</p>
<p data-track="41">在获取重量级锁之前会先实现锁膨胀，锁膨胀时首先会创建一个ObjectMonitor对象，然后把ObjectMonitor对象的指针保存到锁对象的Mark Word中。</p>
<p data-track="42">&nbsp;</p>
<p data-track="43">重量级锁的实现是在ObjectMonitor中完成的，所以锁膨胀的意义就是构建一个ObjectMonitor对象。</p>
<p data-track="44">&nbsp;</p>
<p data-track="45"><strong>(2)ObjectMonitor对象的重要字段</strong></p>
<p data-track="46">_owner：保存当前持有锁的线程</p>
<p data-track="47">_cxq：没有获得锁的线程队列</p>
<p data-track="48">_waitset：被wait()方法阻塞的线程队列</p>
<p data-track="49">_recursions：锁被重入的次数</p>
<p data-track="50">&nbsp;</p>
<p data-track="51"><strong>(3)重量级锁的获取流程</strong></p>
<p data-track="52">重量级锁的竞争都是在ObjectMonitor对象中完成的。首先判断当前线程是否是重入，如果是则重入次数+1。然后通过CAS自旋来判断ObjectMonitor中的_owner字段是否为空。如果为空，则表示重量级锁已经被释放，当前线程可以获得锁。如果不为空，就继续进行自适应自旋重试。最后如果通过自旋竞争锁失败，则把当前线程构建成一个ObjectWaiter结点，插入到ObjectMonitor的_cxq队列的队头，再调用park()方法阻塞当前线程。</p>
<p data-track="53">&nbsp;</p>
<p data-track="54"><strong>(4)重量级锁的释放流程</strong></p>
<p data-track="55">首先把ObjectMonitor的_owner字段设置为null，然后从ObjectMonitor的_cxq队列中调用unpark()方法唤醒一个阻塞的线程。被唤醒的线程会重新竞争重量级锁，如果没抢到，则继续阻塞等待。因为synchronized是非公平锁，被唤醒的线程不一定能重新抢占到锁。</p>
<p data-track="56">&nbsp;</p>
<p data-track="57"><strong>(5)wait()与notify()的底层原理</strong></p>
<p data-track="58">这与synchronized的原理(ObjectMonitor对象)相关，ObjectMonitor对象有一个_waitset队列和重入计数器。使用wait()和notify()时必须对同一个对象实例进行加synchronized锁。如果对象实例加锁，那么重入计数器 + 1。如果对象实例释放锁，那么重入计数器 - 1。</p>
<p data-track="59">&nbsp;</p>
<p data-track="60">执行wait()方法时会释放锁 + 阻塞当前线程 + 把当前线程放入_waitset队列，执行notify()方法时会唤醒_waitset队列里的被阻塞的线程。</p>
<p data-track="61">&nbsp;</p>
<p data-track="62"><strong>(6)wait()与notify()在使用时的注意事项</strong></p>
<p data-track="63">wait()与sleep()的区别：两者都会等待，前者释放锁，后者不释放锁。wait()必须要有其他线程调用notify()来唤醒它。wait(timeout)会阻塞一段时间，然后自己唤醒自己，继续争抢锁。wait()与notify()必须与synchornized一起，对同一个对象进行使用。notify()会唤醒阻塞状态的一个线程，notifyall()会唤醒阻塞状态的所有线程。</p>
<p data-track="64">&nbsp;</p>
<p data-track="65"><strong>3.分布式存储系统NameNode机制介绍</strong></p>
<p data-track="66"><strong>(1)HDFS的DataNode和NameNode</strong></p>
<p data-track="67"><strong>(2)HDFS的NameNode架构简介</strong></p>
<p data-track="68">&nbsp;</p>
<p data-track="69"><strong>(1)HDFS的DataNode和NameNode</strong></p>
<p data-track="70">HDFS是Hadoop的分布式文件系统，它由很多机器组成。每台机器上运行一个DataNode进程，存储一部分数据。然后会有一台机器上运行一个NameNode进程，NameNode可以认为是负责管理整个HDFS集群的进程，NameNode里存储了HDFS集群的所有元数据。</p>
<p data-track="71">&nbsp;</p>
<p data-track="72"><strong>(2)HDFS的NameNode架构简介</strong></p>
<p data-track="73"><strong>一.每次修改元数据都顺序追加edits log</strong></p>
<p data-track="74"><strong>二.如何避免edits log过大导致恢复过慢</strong></p>
<p data-track="75"><strong>三.NameNode主备高可用故障转移机制</strong></p>
<p data-track="76">&nbsp;</p>
<p data-track="77"><strong>一.每次修改元数据都顺序追加edits log</strong></p>
<p data-track="78">NameNode的核心功能是管理整个HDFS集群的元数据，比如文件目录树、权限设置、副本数设置等。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">HDFS客户端每次上传文件时，都要维护NameNode的文件目录树。但是NameNode的文件目录树是在内存里的，万一NameNode宕机，内存里的文件目录树可能就会丢失。</p>
<p data-track="81">&nbsp;</p>
<p data-track="82">所以每次修改内存，就顺序追加一条edits log(元数据操作日志)到磁盘文件。每次NameNode重启，就把edits log(元数据操作日志)读到内存恢复数据。</p>
<p data-track="83">&nbsp;</p>
<p data-track="84"><strong>二.如何避免edits log过大导致恢复过慢</strong></p>
<p data-track="85">为了避免edits log(元数据操作日志)越来越大每次重启恢复过慢，于是引入了一个新的磁盘文件fsimage、一个JournalNodes集群、一个Active NameNode(主节点)、一个Standby NameNode(备节点)。</p>
<p data-track="86">&nbsp;</p>
<p data-track="87">主节点每修改一条元数据都会生成一条edits log。每条edits log除了写到主节点外，还会写到JournalNodes集群。然后备节点会从JournalNodes集群拉取edits log到自己内存的文件目录树里，这样备节点的数据就可以跟主节点的数据保持一致了。</p>
<p data-track="88">&nbsp;</p>
<p data-track="89">每隔一段时间备节点会把自己内存的文件目录树写一份到fsimage磁盘文件，这个也就是所谓的checkpoint检查点操作。然后备节点再把这个fsimage磁盘文件上传到到主节点，接着清空掉主节点上的旧的edits log文件(可能几十万行)。之后主节点继续处理修改元数据请求，那么可能只有几十行edits log日志了。</p>
<p data-track="90">&nbsp;</p>
<p data-track="91">如果此时主节点重启，首先把备节点传过来的fsimage文件读到内存里，然后把新的edits log里少量的几十行操作日志重新恢复到内存中即可。</p>
<p data-track="92">&nbsp;</p>
<p data-track="93"><strong>三.NameNode主备高可用故障转移机制</strong></p>
<p data-track="94">整个过程有两个NameNode：一是对外提供服务接收请求的主节点NameNode，二是同步主节点edits log + 定期执行checkpoint的备节点NameNode。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96">这两个NameNode内存里的元数据几乎一模一样。所以如果主节点挂了，可以马上切换到备节点对外提供服务，而这就是所谓的NameNode主备高可用故障转移机制了。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>4.分布式存储系统的edits log机制介绍</strong></p>
<p data-track="99"><strong>(1)高并发请求下NameNode会遇到的问题</strong></p>
<p data-track="100"><strong>(2)通过双缓冲机制来提升写edits log的性能</strong></p>
<p data-track="101">&nbsp;</p>
<p data-track="102"><strong>(1)高并发请求下NameNode会遇到的问题</strong></p>
<p data-track="103">NameNode每修改一条元数据都要写一条edits log，这包括两个步骤：写入本地磁盘和通过网络传输给JournalNodes集群。</p>
<p data-track="104">&nbsp;</p>
<p data-track="105">NameNode必须保证写入的每条edits log都有一个全局顺序递增的txid，这样才可以标识出一条edits log的先后顺序。</p>
<p data-track="106">&nbsp;</p>
<p data-track="107">如果要保证每条edits log的txid都是递增的，那么就必须要加锁。每个线程修改完元数据准备写一条edits log时，按顺序排队获取锁，获取到锁之后才能生成一个递增的txid给要准备写的edits log。</p>
<p data-track="108">&nbsp;</p>
<p data-track="109">但是如果每次在加锁的代码块里生成txid，然后写磁盘文件edits log，接着通过网络传输写入JournalNodes，那么性能就一定很低。所以每个线程写edits log时最好不要串行化排队来执行这3个操作：生成txid + 写磁盘 + 写JournalNode。</p>
<p data-track="110">&nbsp;</p>
<p data-track="111"><strong>(2)通过双缓冲机制来提升写edits log的性能</strong></p>
<p data-track="112">为了避免线程写edits log时串行化排队去生成txid + 写磁盘 + 写JournalNode，可以考虑增加内存缓冲。首先将edits log写入到内存缓冲里，然后通过后台线程将内存中的edits log刷入磁盘 + 写入JournalNode。而且将edits log刷盘的过程中，其他线程依然可以将edits log写入内存缓冲。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114">如果针对同一块内存缓冲，同时有线程写入、同时有线程读取后刷入磁盘，那么是会存在并发读写问题的，因为不能并发读写一块共享内存数据。</p>
<p data-track="115">&nbsp;</p>
<p data-track="116">所以HDFS采取了双缓冲机制来处理，也就是将一块内存缓冲分成两部分。其中一部分只用来写入，另一部分只用来读取进行刷盘。</p>
<p data-track="117">&nbsp;</p>
<p data-track="118"><strong>5.分布式存储系统的NameNode实现</strong></p>
<p data-track="119"><strong>(1)NameNode的基本功能</strong></p>
<p data-track="120"><strong>(2)NameNode的核心启动类</strong></p>
<p data-track="121"><strong>(3)NameNode的RPC服务接口</strong></p>
<p data-track="122"><strong>(4)负责管理元数据的FSNamesystem</strong></p>
<p data-track="123"><strong>(5)负责管理文件目录树的FSDirectory</strong></p>
<p data-track="124"><strong>(6)负责管理edits log日志的FSEditlog</strong></p>
<p data-track="125">&nbsp;</p>
<p data-track="126"><strong>(1)NameNode的基本功能</strong></p>
<p data-track="127">如果NameNode执行命令创建一个目录，那么会做两件事情：一是在内存里的文件目录树中加入目录节点，二是在磁盘里写入一条edits log日志来记录本次元数据修改。</p>
<p data-track="128">&nbsp;</p>
<p data-track="129">所以接下来要实现两个功能：一是在内存文件目录树中加入目录节点，二是写edits log到磁盘文件。</p>
<p data-track="130">&nbsp;</p>
<p data-track="131">如下是NameNode的核心组件说明：</p>
<p data-track="132">FSNamesystem类：作为NameNode里元数据操作的核心入口，负责管理所有的元数据的操作，会调用其他组件完成相关事情。</p>
<p data-track="133">FSDirectory类：管理内存中的文件目录树。</p>
<p data-track="134">FSEditLog类：写入edits log到磁盘文件里。</p>
<p data-track="135">&nbsp;</p>
<p data-track="136"><strong>(2)NameNode的核心启动类</strong></p>
<pre class="highlighter-hljs"><code>//NameNode核心启动类
public class NameNode {
    //NameNode是否在运行
    private volatile Boolean shouldRun;
  
    //负责管理元数据的核心组件
    private FSNamesystem namesystem;
  
    //NameNode对外提供RPC接口的Server，可以响应请求
    private NameNodeRpcServer rpcServer;
  
    public NameNode() {
        this.shouldRun = true;
    }
  
    //初始化NameNode
    private void initialize() {
        this.namesystem = new FSNamesystem();
        this.rpcServer = new NameNodeRpcServer(this.namesystem);  
        this.rpcServer.start();
    }
  
    //让NameNode运行起来
    private void run() {
        try {
            while(shouldRun) {
                Thread.sleep(10000);  
            }  
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
  
    public static void main(String[] args) throws Exception {
        NameNode namenode = new NameNode();
        namenode.initialize();
        namenode.run();
    }
}</code></pre>
<p data-track="138"><strong>(3)NameNode的RPC服务接口</strong></p>
<pre class="highlighter-hljs"><code>//NameNode的rpc服务的接口
public class NameNodeRpcServer {
    //负责管理元数据的核心组件
    private FSNamesystem namesystem;
  
    public NameNodeRpcServer(FSNamesystem namesystem) {
        this.namesystem = namesystem;
    }
  
    //创建目录
    public Boolean mkdir(String path) throws Exception {
        return this.namesystem.mkdir(path);
    }

    //启动这个rpc server
    public void start() {
        System.out.println("开始监听指定的rpc server的端口号，来接收请求");  
    }
}</code></pre>
<p data-track="140"><strong>(4)负责管理元数据的FSNamesystem</strong></p>
<pre class="highlighter-hljs"><code>//负责管理元数据的核心组件
public class FSNamesystem {
    //负责管理内存文件目录树的组件
    private FSDirectory directory;
  
    //负责管理edits log写入磁盘的组件
    private FSEditlog editlog;
  
    public FSNamesystem() {
        this.directory = new FSDirectory();
        this.editlog = new FSEditlog();
    }
  
    //创建目录
    public Boolean mkdir(String path) throws Exception {
        this.directory.mkdir(path); 
        this.editlog.logEdit("创建了一个目录：" + path);   
        return true;
    }
}</code></pre>
<p data-track="142"><strong>(5)负责管理文件目录树的FSDirectory</strong></p>
<pre class="highlighter-hljs"><code>//负责管理内存中的文件目录树的核心组件
public class FSDirectory {
    //创建目录
    public void mkdir(String path) {
    }
}</code></pre>
<p data-track="144"><strong>(6)负责管理edits log日志的FSEditlog</strong></p>
<pre class="highlighter-hljs"><code>//负责管理edits log日志的核心组件
public class FSEditlog {
    //记录edits log日志
    public void logEdit(String log) {
    }
}</code></pre>
<p data-track="146">&nbsp;</p>
<p data-track="147"><strong>6.分布式存储系统的创建目录功能实现</strong></p>
<p data-track="148">在内存的文件目录树中创建一个目录节点的代码如下。内存里的文件目录树是会被多线程并发写的资源，所以创建目录的代码块必须要用synchronized保护起来。</p>
<pre class="highlighter-hljs"><code>//负责管理内存中的文件目录树的核心组件
public class FSDirectory {
    //内存中的文件目录树
    private INodeDirectory dirTree;
    
    public FSDirectory() {
        this.dirTree = new INodeDirectory("/");  
    }
    
    //创建目录
    public void mkdir(String path) {
        //path = /usr/warehouse/hive
        //首先判断'/'根目录下有没有一个'usr'目录
        //如果有，那么再判断'/usr'目录下有没有一个'/warehouse'目录
        //如果没有，那么就得先在'/usr'目录下创建一个'/warehosue'目录
        //接着再在'/warehosue'目录下，创建'hive'这个目录节点
        synchronized(dirTree) {
            String[] pathes = path.split("/");
            INodeDirectory parent = dirTree;
            for (String splitedPath : pathes) {
                if (splitedPath.trim().equals("")) {
                    continue;
                }
                INodeDirectory dir = findDirectory(parent, splitedPath);
                if (dir != null) {
                    parent = dir;
                    continue;
                }
                INodeDirectory child = new INodeDirectory(splitedPath); 
                parent.addChild(child);  
            }
        }
    }
    
    //对文件目录树递归查找目录
    private INodeDirectory findDirectory(INodeDirectory dir, String path) {
        if (dir.getChildren().size() == 0) {
            return null;
        }
        INodeDirectory resultDir = null;
        for (INode child : dir.getChildren()) {
            if (child instanceof INodeDirectory) {
                INodeDirectory childDir = (INodeDirectory) child;
                if ((childDir.getPath().equals(path))) {
                    return childDir;
                }
                resultDir = findDirectory(childDir, path);
                if (resultDir != null) {
                    return resultDir;
                }
            }
        }
        return null;
    }
   
    //代表的是文件目录树中的一个节点
    private interface INode {
      
    }
    
    //代表文件目录树中的一个目录
    public static class INodeDirectory implements INode {
        private String path;
        private List&lt;INode&gt; children;
        public INodeDirectory(String path) {
            this.path = path;
            this.children = new LinkedList&lt;INode&gt;();
        }
        public void addChild(INode inode) {
            this.children.add(inode);
        }
        public String getPath() {
            return path;
        }
        public void setPath(String path) {
            this.path = path;
        }
        public List&lt;INode&gt; getChildren() {
            return children;
        }
        public void setChildren(List&lt;INode&gt; children) {
            this.children = children;
        }
    }
    
    //代表文件目录树中的一个文件
    public static class INodeFile implements INode {
        private String name;
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}</code></pre>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>7.edits log的全局txid机制和双缓冲机制实现</strong></p>
<p data-track="152">全局txid机制 + 双缓冲机制的代码如下：</p>
<pre class="highlighter-hljs"><code>//负责管理edits log日志的核心组件
public class FSEditlog {
    //当前递增到的txid的序号
    private long txidSeq = 0L;
    
    //内存双缓冲区
    private DoubleBuffer editLogBuffer = new DoubleBuffer();
    
    //记录edits log日志
    public void logEdit(String content) {
        //这里必须加锁
        synchronized(this) {
            //获取全局唯一递增的txid，代表了edits log的序号
            txidSeq++;
            long txid = txidSeq;
            //构造一条edits log对象
            EditLog log = new EditLog(txid, content);
            //将edits log写入内存缓冲中，不是直接刷入磁盘文件
            editLogBuffer.write(log);  
        }
    }
   
    //代表了一条edits log，内部类
    private class EditLog {
        long txid;
        String content;
        public EditLog(long txid, String content) {
            this.txid = txid;
            this.content = content;
        }
    }
   
    //内存双缓冲，内部类
    private class DoubleBuffer {
        //专门用来承载线程写入edits log
        LinkedList&lt;EditLog&gt; currentBuffer = new LinkedList&lt;EditLog&gt;();

        //专门用来将数据同步到磁盘中去的一块缓冲
        LinkedList&lt;EditLog&gt; syncBuffer = new LinkedList&lt;EditLog&gt;();

        //将edits log写到内存缓冲里去
        public void write(EditLog log) {
            currentBuffer.add(log);
        }

        //交换两块缓冲区，为同步内存数据到磁盘做准备
        public void setReadyToSync() {
            LinkedList&lt;EditLog&gt; tmp = currentBuffer;
            currentBuffer = syncBuffer;
            syncBuffer = tmp;
        }

        //获取sync buffer缓冲区里的最大的一个txid
        public Long getSyncMaxTxid() {
            return syncBuffer.getLast().txid;
        }

        //将syncBuffer缓冲区中的数据刷入磁盘中
        public void flush() {
            for (EditLog log : syncBuffer) {
                System.out.println("将edit log写入磁盘文件中：" + log); 
                //正常来说，就是用文件输出流将数据写入磁盘文件中
            }
            syncBuffer.clear();  
        }
    }
}</code></pre>
<p data-track="154">&nbsp;</p>
<p data-track="155"><strong>8.synchronized实现edits log分段加锁机制</strong></p>
<p data-track="156">logSync()方法通过分两段加synchronized锁，将耗时的刷盘操作放在锁外，然后通过更改标志位以及使用wait()和notify()来控制线程的等待和锁的释放，从而保证高并发下的刷盘性能。</p>
<pre class="highlighter-hljs"><code>//负责管理edits log日志的核心组件
public class FSEditlog {
    //当前递增到的txid的序号
    private long txidSeq = 0L;
    //内存双缓冲区
    private DoubleBuffer editLogBuffer = new DoubleBuffer();
    //当前是否在将内存缓冲刷入磁盘中
    private volatile Boolean isSyncRunning = false;
    //当前是否有线程在等待刷新下一批edits log到磁盘里去
    private volatile Boolean isWaitSync = false;
    //在同步到磁盘中的最大的一个txid
    private volatile Long syncMaxTxid = 0L;
    //每个线程自己本地的txid副本
    private ThreadLocal&lt;Long&gt; localTxid = new ThreadLocal&lt;Long&gt;();
   
    //记录edits log日志
    public void logEdit(String content) {
        //这里直接加锁，有线程执行logSync()方法时这里没有其他线程能进来
        synchronized(this) {
            //获取全局唯一递增的txid，代表了edits log的序号
            txidSeq++;
            long txid = txidSeq;
            localTxid.set(txid);
            //构造一条edits log对象
            EditLog log = new EditLog(txid, content);
            //将edits log写入内存缓冲中，不是直接刷入磁盘文件
            editLogBuffer.write(log);  
        }
        //尝试允许某一个执行logEdit()方法的线程，一次性将内存缓冲中的数据刷入到磁盘文件中
        logSync();
    }
   
    //将内存缓冲中的数据刷入磁盘文件中
    //在这里尝试允许某一个线程一次性将内存缓冲中的数据刷入到磁盘文件中
    //相当于批量将内存缓冲的数据刷入磁盘
    private void logSync() {
        //再次尝试加锁，只有一个线程能进来，这个过程很快，纳秒级别，这里属于第一段加锁
        synchronized(this) {
            //如果当前正好有线程在刷内存缓冲到磁盘中去
            if (isSyncRunning) {
                ...
            }

            //交换两块缓冲区
            editLogBuffer.setReadyToSync();

            //然后保存当前要同步到磁盘中的最大txid，此时editLogBuffer中的syncBuffer在交换完以后可能有多条数据
            //而且里面的edits log的txid一定是从小到大的，此时要同步的txid = 6,7,8,9,10,11,12，所以syncMaxTxid = 12
            syncMaxTxid = editLogBuffer.getSyncMaxTxid();

            //设置当前正在同步到磁盘的标志位
            isSyncRunning = true;
        }
      
        //释放锁，开始同步内存缓冲的数据到磁盘文件里去
        //这个过程其实是比较慢，基本上肯定是毫秒级了，弄不好就要几十毫秒
        editLogBuffer.flush();  
      
        //这里属于另外一段加锁
        synchronized(this) {
            //同步完了磁盘之后，就会将标志位复位，再释放锁
            isSyncRunning = false;
            //唤醒可能正在等待他同步完磁盘的线程
            notifyAll();
        }
    }
    ...
}</code></pre>
<p data-track="158">&nbsp;</p>
<p data-track="159"><strong>9.wait()与notify()实现edits log批量刷磁盘</strong></p>
<pre class="highlighter-hljs"><code>//负责管理edits log日志的核心组件
public class FSEditlog {
    //当前递增到的txid的序号
    private long txidSeq = 0L;
    //内存双缓冲区
    private DoubleBuffer editLogBuffer = new DoubleBuffer();
    //当前是否在将内存缓冲刷入磁盘中
    private volatile Boolean isSyncRunning = false;
    //当前是否有线程在等待刷新下一批edits log到磁盘里去
    private volatile Boolean isWaitSync = false;
    //在同步到磁盘中的最大的一个txid
    private volatile Long syncMaxTxid = 0L;
    //每个线程自己本地的txid副本
    private ThreadLocal&lt;Long&gt; localTxid = new ThreadLocal&lt;Long&gt;();
   
    //记录edits log日志
    public void logEdit(String content) {
        //这里直接加锁，有线程执行logSync()方法时这里没有其他线程能进来
        synchronized(this) {
            //获取全局唯一递增的txid，代表了edits log的序号
            txidSeq++;
            long txid = txidSeq;
            localTxid.set(txid);
            //构造一条edits log对象
            EditLog log = new EditLog(txid, content);
            //将edits log写入内存缓冲中，不是直接刷入磁盘文件
            editLogBuffer.write(log);  
        }
        //尝试允许某一个执行logEdit()方法的线程，一次性将内存缓冲中的数据刷入到磁盘文件中
        logSync();
    }
   
    //将内存缓冲中的数据刷入磁盘文件中
    //在这里尝试允许某一个线程一次性将内存缓冲中的数据刷入到磁盘文件中
    //相当于批量将内存缓冲的数据刷入磁盘
    private void logSync() {
        //再次尝试加锁，只有一个线程能进来，这个过程很快，纳秒级别，这里属于第一段加锁
        synchronized(this) {
            //如果当前正好有线程在刷内存缓冲到磁盘中去
            if (isSyncRunning) {
                //假如某个线程正在把txid = 6,7,8,9,10,11,12的edits log从syncBuffer刷入磁盘
                //此时syncMaxTxid = 12，代表的是正在刷入磁盘的最大txid
                //那么刷盘的线程释放锁进行刷盘后，这时来一个线程对应的txid = 10，此时它可以直接返回
                //因为它对应的edits log被刷盘的线程正在刷入或者已经刷入磁盘了，这时txid = 12的线程就不需要等待
                long txid = localTxid.get();
                if (txid &lt;= syncMaxTxid) {
                    return;
                }
   
                //此时如果来的是一个txid = 13的线程，那么就会发现已经有线程在等待刷下一批数据到磁盘，此时会直接返回
                if (isWaitSync) {
                    return;
                }

                //此时如果来的是一个txid = 14的线程，并且刷盘还没刷完，
                //那么就在这里等待或者成为下一个刷盘的线程，只有一个线程在等
                isWaitSync = true;
                while (isSyncRunning) {
                    try {
                        wait(2000);//释放锁并自己等2秒或者等别人唤醒
                    } catch (Exception e) {
                        e.printStackTrace();  
                    }
                }
                isWaitSync = false;
            }

            //交换两块缓冲区
            editLogBuffer.setReadyToSync();

            //然后保存当前要同步到磁盘中的最大txid，此时editLogBuffer中的syncBuffer在交换完以后可能有多条数据
            //而且里面的edits log的txid一定是从小到大的，此时要同步的txid = 6,7,8,9,10,11,12，所以syncMaxTxid = 12
            syncMaxTxid = editLogBuffer.getSyncMaxTxid();

            //设置当前正在同步到磁盘的标志位
            isSyncRunning = true;
        }
      
        //释放锁，开始同步内存缓冲的数据到磁盘文件里去
        //这个过程其实是比较慢，基本上肯定是毫秒级了，弄不好就要几十毫秒
        editLogBuffer.flush();  
      
        //这里属于另外一段加锁
        synchronized(this) {
            //同步完了磁盘之后，就会将标志位复位，再释放锁
            isSyncRunning = false;
            //唤醒可能正在等待他同步完磁盘的线程
            notifyAll();
        }
    }
    ...
}</code></pre>
<p data-track="161">&nbsp;</p>
<p data-track="162"><strong>10.i++和AtomicInteger分别实现并发安全</strong></p>
<pre class="highlighter-hljs"><code>public class AtomicIntegerDemo {
    static Integer i = 0;
    static AtomicInteger j = new AtomicInteger(0); 

    public static void main(String[] args) {
        synchronizedAdd();
        atomicAdd();
    }

    private static void synchronizedAdd() {
        for (int i = 0; i &lt; 10; i++) {
            new Thread() {
                public void run() {
                    //10个线程就要串行依次的一个一个进入锁代码块，然后依次对i变量进行++的操作
                    //每次操作完i++，就写回到主存，下一个线程间进行从主存来加载，再次i++
                    synchronized(AtomicIntegerDemo.class) {
                        System.out.println(++AtomicIntegerDemo.i);
                    }
                }
            }.start();
        }
    }

    private static void atomicAdd() {
        for (int i = 0; i &lt; 10; i++) {
            new Thread() {
                public void run() {
                    //通过atomic实现多线程并发安全
                    System.out.println(AtomicIntegerDemo.j.incrementAndGet()); 
                }
            }.start();
        }
    }
}</code></pre>
<p data-track="164">&nbsp;</p>
<p data-track="165"><strong>11.AtomicInteger中的CAS无锁化原理</strong></p>
<p data-track="166"><strong>(1)CAS简介</strong></p>
<p data-track="167"><strong>(2)Atomic原子类简介</strong></p>
<p data-track="168">&nbsp;</p>
<p data-track="169"><strong>(1)CAS简介</strong></p>
<p data-track="170">CAS就是Compare and Set，首先判断此时内存中是否是某个值。如果是则修改，如果不是则重新查询最新的值，再执行判断。</p>
<p data-track="171">&nbsp;</p>
<p data-track="172"><strong>(2)Atomic原子类简介</strong></p>
<p data-track="173">Atomic的原子类分别有：</p>
<p data-track="174">AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference、LongAdder等。</p>
<p data-track="175">&nbsp;</p>
<p data-track="176">Atomic原子类底层的核心原理就是CAS，属于一种乐观锁。每次修改时就先对比原值，看看有没有其他线程修改过原值。如果没有修改过就可以修改，如果有修改就重新查出最新值来重复这个过程。</p>
<p data-track="177">&nbsp;</p>
<p data-track="178"><strong>12.Atomic源码之仅限JDK使用的Unsafe类</strong></p>
<p data-track="179"><strong>(1)Atomic原子类通过Unsafe执行CAS操作</strong></p>
<p data-track="180"><strong>(2)Unsafe类仅限JDK内部使用</strong></p>
<p data-track="181">&nbsp;</p>
<p data-track="182"><strong>(1)Atomic原子类通过Unsafe执行CAS操作</strong></p>
<pre class="highlighter-hljs"><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    private volatile int value;
    ...
    //Creates a new AtomicInteger with the given initial value.
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }

    //Creates a new AtomicInteger with initial value {@code 0}.
    public AtomicInteger() {
        
    }

    //Gets the current value.
    public final int get() {
        return value;
    }

    //Sets to the given value.
    public final void set(int newValue) {
        value = newValue;
    }

    //Eventually sets to the given value.
    public final void lazySet(int newValue) {
        unsafe.putOrderedInt(this, valueOffset, newValue);
    }

    //Atomically sets to the given value and returns the old value.
    public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }

    //Atomically sets the value to the given updated value if the current value == the expected value.
    //@param expect the expected value
    //@param update the new value
    //@return true if successful. False return indicates that the actual value was not equal to the expected value.
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    //Atomically increments by one the current value.
    //@return the previous value
    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }

    //Atomically decrements by one the current value.
    //@return the previous value
    public final int getAndDecrement() {
        return unsafe.getAndAddInt(this, valueOffset, -1);
    }

    //Atomically adds the given value to the current value.
    //@param delta the value to add
    //@return the previous value
    public final int getAndAdd(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }

    //Atomically increments by one the current value.
    //@return the updated value
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }

    //Atomically decrements by one the current value.
    //@return the updated value
    public final int decrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;
    }

    //Atomically adds the given value to the current value.
    //@param delta the value to add
    //@return the updated value
    public final int addAndGet(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;
    }
    
    //Atomically updates the current value with the results of applying the given function, returning the previous value. 
    //The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
    //@param updateFunction a side-effect-free function
    //@return the previous value
    public final int getAndUpdate(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return prev;
    }
    
    //Atomically updates the current value with the results of applying the given function, returning the updated value. 
    //The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
    //@param updateFunction a side-effect-free function
    //@return the updated value
    public final int updateAndGet(IntUnaryOperator updateFunction) {
        int prev, next;
        do {
            prev = get();
            next = updateFunction.applyAsInt(prev);
        } while (!compareAndSet(prev, next));
        return next;
    }

    //Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. 
    //The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  
    //The function is applied with the current value as its first argument, and the given update as the second argument.
    //@param x the update value
    //@param accumulatorFunction a side-effect-free function of two arguments
    //@return the previous value
    public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) {
        int prev, next;
        do {
            prev = get();
            next = accumulatorFunction.applyAsInt(prev, x);
        } while (!compareAndSet(prev, next));
        return prev;
    }

    //Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value.
    //The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  
    //The function is applied with the current value as its first argument, and the given update as the second argument.
    //@param x the update value
    //@param accumulatorFunction a side-effect-free function of two arguments
    //@return the updated value
    public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) {
        int prev, next;
        do {
            prev = get();
            next = accumulatorFunction.applyAsInt(prev, x);
        } while (!compareAndSet(prev, next));
        return next;
    }
    ...
}</code></pre>
<p data-track="184"><strong>(2)Unsafe类仅限JDK内部使用</strong></p>
<p data-track="185">Unsafe类是JDK底层的一个类，不允许被实例化和使用它里面的方法。因为Unsafe类的构造函数是私有的，所以不能手动进行实例化。其次调用Unsafe.getUnsafe()方法来获取一个UnSafe实例也不被允许。</p>
<pre class="highlighter-hljs"><code>public final class Unsafe {
    ...
    private Unsafe() {
    }

    @CallerSensitive
    public static Unsafe getUnsafe() {
        Class var0 = Reflection.getCallerClass();
        if (!VM.isSystemDomainLoader(var0.getClassLoader())) {
            throw new SecurityException("Unsafe");
        } else {
            return theUnsafe;
        }
    }
    ...
}</code></pre>
<p data-track="187">&nbsp;</p>
<p data-track="188"><strong>13.Atomic源码之无限重复循环以及CAS操作</strong></p>
<p data-track="189"><strong>(1)AtomicInteger类的初始化</strong></p>
<p data-track="190"><strong>(2)Unsafe类的getAndAddInt()方法</strong></p>
<p data-track="191"><strong>(3)CAS的底层工作原理</strong></p>
<p data-track="192"><strong>(4)自旋策略与阻塞策略</strong></p>
<p data-track="193">&nbsp;</p>
<p data-track="194"><strong>(1)AtomicInteger类的初始化</strong></p>
<p data-track="195">AtomicInteger类初始化时，会执行静态代码块，即初始化valueOffset变量为value变量在AtomicInteger类中的偏移量。</p>
<p data-track="196">&nbsp;</p>
<p data-track="197">这个valueOffset偏移量可以理解为：value变量在AtomicInteger类的位置。由于valueOffset偏移量是final的，所以一旦初始化完毕就不会再改变。</p>
<pre class="highlighter-hljs"><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    private volatile int value;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) {
            throw new Error(ex);
        }
    }

    //Atomically increments by one the current value.
    //@return the updated value
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }

    //Atomically sets the value to the given updated value if the current value == the expected value.
    //@param expect the expected value
    //@param update the new value
    //@return true if successful. False return indicates that the actual value was not equal to the expected value.
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
    ...
}</code></pre>
<p data-track="199"><strong>(2)Unsafe类的getAndAddInt()方法</strong></p>
<pre class="highlighter-hljs"><code>public final class Unsafe {
    ...
    //compareAndSwapInt()属于CAS方法
    //这个方法会拿刚刚获取到的那个l值，认为是当前value的最新值
    //然后和当前AtomicInteger对象实例中的value值进行比较
    //如果一样，就将value的值给设置为：l(之前拿到的值) + delta(递增的值)
    //如果不一样，compareAndSwapInt()方法就会返回false，自动进入下一轮while循环
    //直到while循环结束，最后会返回一个l值，是递增delta前的旧值
    public final int getAndAddInt(Object paramObject, long valueOffset, int delta) {
        int l;
        do {
            //Unsafe的getIntVolatile方法会从AtomicInteger对象实例中，
            //根据valueOffset偏移量(value变量的位置)，去获取当前value的最新值为l
            l = this.getIntVolatile(paramObject, valueOffset);
        } while(!this.compareAndSwapInt(paramObject, valueOffset, l, l + delta));
        return l;
    }

    public native int getIntVolatile(Object paramObject, long valueOffset);

    //paramObject表示当前的实例对象
    //valueOffset表示实例变量的内存地址偏移量
    //expect表示期望值
    //update表示更新后的值
    public final native boolean compareAndSwapInt(Object paramObject, long valueOffset, int expect, int update);
    ...
}</code></pre>
<p data-track="201"><strong>(3)CAS的底层工作原理</strong></p>
<p data-track="202">下图表示通过CAS对变量V进行原子更新操作，底层的CAS方法中会传递三个参数。第一个参数V表示要更新的变量，第二个参数E表示期望值，第三个参数U表示更新后的值。</p>
<p data-track="203">&nbsp;</p>
<p data-track="204">更新的方式是：如果V == E，表示预期值和实际值相等，则将V修改成U并返回true；否则修改失败，然后返回false。</p>
<div class="pgc-img"><img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MjIyZGRmODNlYWFkMTdkODU2ZmQzOWZiNDliNTYwMDMsMTczOTcyMTUzODM4Nw==" data-ic="false" data-width="918" data-height="890" data-ic-uri=""></div>
<p data-track="205"><strong>(4)自旋策略与阻塞策略</strong></p>
<p data-track="206">当一个线程拿不到锁时，有两种基本策略。</p>
<p data-track="207">策略一：放弃CPU进入阻塞状态，等待后续被唤醒，再重新被操作系统调度。</p>
<p data-track="208">策略二：不放弃CPU，而是进入空转进行不断重试，也就是自旋。</p>
<p data-track="209">&nbsp;</p>
<p data-track="210">单核CPU只能使用策略一，AtomicInteger就是使用了自旋策略。synchronized则是先自旋几圈，自旋后还获取不到锁再阻塞。</p>
<p data-track="211">&nbsp;</p>
<p data-track="212"><strong>14.Atomic原子类基于CAS操作的三大问题</strong></p>
<p data-track="213"><strong>(1)ABA问题</strong></p>
<p data-track="214"><strong>(2)无限循环问题</strong></p>
<p data-track="215"><strong>(3)多个变量的原子性问题</strong></p>
<p data-track="216">&nbsp;</p>
<p data-track="217"><strong>(1)ABA问题</strong></p>
<p data-track="218">ABA问题就是：如果某个值一开始是A，后来变成了B，然后又变成了A。AtomicStampedReference能原子更新带有版本号的引用类型，解决ABA问题。此外一般用AtomicInteger进行的是不断累加计数，所以ABA问题比较少。</p>
<p data-track="219">&nbsp;</p>
<p data-track="220"><strong>(2)无限循环问题</strong></p>
<p data-track="221">Atomic原子类设置值的时候会进入一个无限循环，只要不成功就不停循环再次尝试，在高并发修改值时是挺常见的。</p>
<p data-track="222">&nbsp;</p>
<p data-track="223">比如用AtomicInteger定义一个原子变量，高并发下修改时，可能会导致compareAndSet()要循环很多次才设置成功。所以引入了LongAdder来解决，通过分段CAS的思路来解决无限循环问题。</p>
<p data-track="224">&nbsp;</p>
<p data-track="225"><strong>(3)多个变量的原子性问题</strong></p>
<p data-track="226">一般的AtomicInteger，只能保证一个变量的原子性，但是如果多个变量呢？</p>
<p data-track="227">&nbsp;</p>
<p data-track="228">要保证多个变量的原子性，可以使用AtomicReference来封装自定义对象。将多个变量放在一个对象里，通过对象的引用来实现多个变量的原子性。</p>
<p data-track="229">&nbsp;</p>
<p data-track="230"><strong>15.AtomicLong优化服务注册中心心跳计数器</strong></p>
<p data-track="231">可以使用AtomicLong来优化服务注册中心内部的心跳计数器。</p>
<pre class="highlighter-hljs"><code>//心跳请求计数器
public class HeartbeatCounter {
    //单例实例
    private static HeartbeatCounter instance = new HeartbeatCounter();

    //最近一分钟的心跳次数
    private AtomicLong latestMinuteHeartbeatRate = new AtomicLong(0L); 

    //最近一分钟的时间戳
    private long latestMinuteTimestamp = System.currentTimeMillis();

    private HeartbeatCounter() {
        Daemon daemon = new Daemon();
        daemon.setDaemon(true);  
        daemon.start();
    }

    //获取单例实例
    public static HeartbeatCounter getInstance() {
        return instance;
    }

    //增加最近一分钟的心跳次数
    public /**synchronized*/ void increment() {
        //通过synchronized上锁，在很多线程的情况下，性能其实是很差的
        //如果服务实例很多，比如1万个服务实例，那么每秒需要很多线程来处理大量的心跳请求
        //这样就会出现很多线程卡在这里，一个一个排队获取锁，这样就会非常影响并发性能
        //但换成AtomicLong之后，就不用加锁了，通过CAS操作实现无锁化编程，而且还保证了原子性
        latestMinuteHeartbeatRate.incrementAndGet();  
    }

    //获取最近一分钟的心跳次数
    public /**synchronized*/ long get() {
        return latestMinuteHeartbeatRate.get();
    }

    private class Daemon extends Thread {
        @Override
        public void run() {
            while(true) {
                try {
                    long currentTime = System.currentTimeMillis();
                    if (currentTime - latestMinuteTimestamp &gt; 60 * 1000) {
                        latestMinuteHeartbeatRate = new AtomicLong(0L); 
                        latestMinuteTimestamp = System.currentTimeMillis();
                    }
                    Thread.sleep(1000); 
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre>
<p data-track="233">&nbsp;</p>
<p data-track="234"><strong>16.LongAdder的分段CAS优化多线程自旋</strong></p>
<p data-track="235"><strong>(1)采用分段CAS降低重试频率</strong></p>
<p data-track="236"><strong>(2)通过惰性求值提升自增性能</strong></p>
<p data-track="237"><strong>(3)LongAdder和AtomicLong对比</strong></p>
<p data-track="238"><strong>(4)LongAdder的源码分析</strong></p>
<p data-track="239"><strong>(5)LongAdder的设计总结</strong></p>
<p data-track="240"><strong>(6)伪共享问题说明</strong></p>
<p data-track="241">&nbsp;</p>
<p data-track="242"><strong>(1)采用分段CAS降低重试频率</strong></p>
<p data-track="243">这种分段的做法类似于JDK7中的ConcurrentHashMap的分段锁。</p>
<p data-track="244">&nbsp;</p>
<p data-track="245">高并发场景下，value变量其实就是一个热点数据，大量线程竞争一个热点。LongAdder基本思路就是分散热点，将value分散到一个Cell数组中。不同线程会命中数组的不同槽位，各线程只对自己槽位的value进行CAS操作。这样热点就被分散了，冲突概率就变小了。</p>
<p data-track="246">&nbsp;</p>
<p data-track="247">LongAdder内部有一个base变量和一个Cell[ ]数组。当并发不高的时候都是通过CAS来直接操作base变量的值。如果对base变量的CAS失败，则再针对Cell[ ]数组中的Cell进行CAS操作。如果对Cell[ ]数组中的Cell进行CAS失败，则换一个Cell进行CAS操作。</p>
<p data-track="248">&nbsp;</p>
<p data-track="249">LongAdder在无竞争情况下，跟AtomicLong是一样的， 对同一个base进行操作。当出现竞争的时候，则采用化整为零分散热点的做法，用空间换时间。通过使用一个Cell[ ]数组，将一个value拆分进这个Cell[ ]数组中。</p>
<p data-track="250">&nbsp;</p>
<p data-track="251"><strong>(2)通过惰性求值提升自增性能</strong></p>
<p data-track="252">只有在使用longValue()方法获取当前累加值时才会真正去结算计数的数据。LongAdder.longValue()方法其实就是调用LongAdder.sum()方法，LongAdder.sum()方法会将Cell数组中的各元素value和base累加作为返回值。</p>
<p data-track="253">&nbsp;</p>
<p data-track="254">AtomicLong.incrementAndGet()方法每次都会返回long类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。</p>
<p data-track="255">&nbsp;</p>
<p data-track="256"><strong>(3)LongAdder和AtomicLong对比</strong></p>
<p data-track="257"><strong>一.AtomicLong总结</strong></p>
<p data-track="258">AtomicLong的实现原理是：</p>
<p data-track="259">基于CAS + 自旋操作，CAS是基于硬件来实现原子性的，可以保障线程安全。</p>
<p data-track="260">&nbsp;</p>
<p data-track="261">AtomicLong的使用场景：</p>
<p data-track="262">低并发下的全局计数器、序列号生成器。</p>
<p data-track="263">&nbsp;</p>
<p data-track="264">AtomicLong的优势是：</p>
<p data-track="265">占用空间小。</p>
<p data-track="266">&nbsp;</p>
<p data-track="267">AtomicLong的缺点是：</p>
<p data-track="268">高并发下性能急剧下降，N个线程同时进行自旋，N-1个线程会自旋失败、不断重试。</p>
<p data-track="269">&nbsp;</p>
<p data-track="270"><strong>二.LongAdder总结</strong></p>
<p data-track="271">LongAdder设计思想是：</p>
<p data-track="272">空间换时间，分散热点数据value的值。</p>
<p data-track="273">&nbsp;</p>
<p data-track="274">LongAdder的实现原理是：</p>
<p data-track="275">高并发时通过Cell[ ]数组进行分段CAS。</p>
<p data-track="276">&nbsp;</p>
<p data-track="277">LongAdder的使用场景是：</p>
<p data-track="278">高并发下的全局计数器。</p>
<p data-track="279">&nbsp;</p>
<p data-track="280">LongAdder的优势是：</p>
<p data-track="281">减少CAS重试次数、防止伪共享、惰性求值。</p>
<p data-track="282">&nbsp;</p>
<p data-track="283">LongAdder的缺点是：</p>
<p data-track="284">如果使用它的sum()方法时有并发更新，可能数据结果存在误差。</p>
<p data-track="285">&nbsp;</p>
<p data-track="286"><strong>(4)LongAdder的源码分析</strong></p>
<pre class="highlighter-hljs"><code>//并发不高的时候，直接更新base，类似AtomicLong；
//高并发的时候，将每个线程的操作hash到不同的cells数组中；
//从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中，从而降低更新热点
//而需要得到当前值时，直接将所有cell中的value与base相加即可；
//但是和AtomicLong的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，
//而LongAdder的更新操作返回的是void
public class LongAdder extends Striped64 implements Serializable {
    //入参x是累加值
    public void add(long x) {
        //as是累加单元数组cells的引用
        Cell[] as;
        //b是指获取的base值，v是指期望值(当前Cell存储的值)
        long b, v;
        //m是cells数组的长度
        int m;
        //当前线程命中的cells数组元素Cell对象
        Cell a;
        //如果是第一次执行，则直接case操作base
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;
            //as数组为空(null或者size为0) 或者 当前线程取模as数组大小为空 或者 cas更新Cell失败
            if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) {
                longAccumulate(x, null, uncontended);
            }
        }
    }

    public long sum() {
        //通过累加base与cells数组中的value从而获得sum
        Cell[] as = cells; Cell a;
        long sum = base;
        if (as != null) {
            for (int i = 0; i &lt; as.length; ++i) {
                if ((a = as[i]) != null) {
                    sum += a.value;
                }
            }
        }
        return sum;
    }
}

abstract class Striped64 extends Number {
    //@Contended是防止缓存行伪共享的注解
    //CPU缓存是以缓存行为单位的，每个缓存行对应着一块内存，一般是64字节(8个long)
    //Cell即为累加单元
    @sun.misc.Contended static final class Cell {
        //保存累加结果
        volatile long value;
      
        //构造方法中会初始化value值
        Cell(long x) {
            value = x;
        }
      
        //使用CAS方式进行累加，cmp表示旧值，val表示新值
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }

        private static final sun.misc.Unsafe UNSAFE;
        private static final long valueOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class&lt;?&gt; ak = Cell.class;
                valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField("value"));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }

    private static final sun.misc.Unsafe UNSAFE;
    private static final long BASE;
    private static final long CELLSBUSY;
    private static final long PROBE;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&lt;?&gt; sk = Striped64.class;
            BASE = UNSAFE.objectFieldOffset(sk.getDeclaredField("base"));
            CELLSBUSY = UNSAFE.objectFieldOffset(sk.getDeclaredField("cellsBusy"));
            Class&lt;?&gt; tk = Thread.class;
            //返回Field在内存中相对于对象内存地址的偏移量
            PROBE = UNSAFE.objectFieldOffset(tk.getDeclaredField("threadLocalRandomProbe"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }

    //CPU数量，即cells数组的最大长度
    static final int NCPU = Runtime.getRuntime().availableProcessors();

    //cells数组，大小为2的幂，这里的Cell是Striped64的静态内部类
    transient volatile Cell[] cells;

    //在没有竞争的情况下，将操作值累到base中
    //在cells数组初始化过程中，cells数组还不可用，这时候也会通过CAS将操作值累到base中
    transient volatile long base;

    //cellsBusy有两个值0和1，它的作用是当要修改cells数组时加锁，防止多线程同时修改cells数组
    //加锁的情况有三种：一.cells数组初始化的时候；二.cells数组扩容的时候；
    //三.如果cells数组中某个元素为null，给这个位置创建新的Cell对象的时候；
    transient volatile int cellsBusy;

    final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) {
        //存储线程的hash值，有了hash值旧可以知道当前线程进入哪个槽位
        int h;
        //如果getProbe()为0，说明随机数未初始化，需要初始化后，线程才能进入对应槽位
        if ((h = getProbe()) == 0) {
            //使用ThreadLocalRandom为当前线程重新计算一个hash值，强制初始化
            ThreadLocalRandom.current(); // force initialization
            //重新获取hash值
            h = getProbe();
            //重新获取hash值后，认为此次不算一次竞争，所以wasUncontended表示的是否竞争状态为true
            wasUncontended = true;
        }
        boolean collide = false;

        //失败重试
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {
                //若as数组已经初始化，(n-1) &amp; h 即为取模操作，相对 % 效率要更高
                if ((a = as[(n - 1) &amp; h]) == null) {
                    //其他线程没有使用，自然就没有加锁
                    if (cellsBusy == 0) {
                        //创建累加单元，还没赋值到cells数组中
                        Cell r = new Cell(x);

                        //可能会有多个线程执行了"new Cell(x)"，因此需要进行CAS操作，避免线程安全的问题
                        //同时需要再判断一次，避免正在初始化的时其他线程再进行额外的CAS操作
                        //这里的if条件是将创建的累加单元，设置到cells数组的空位置(cells[0]或cells[1])
                        //双重检查cellsBusy == 0，避免并发场景下重复赋值
                        //进入该if条件之前通过casCellsBusy()尝试加锁，保证赋值时是线程安全的
                        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                            boolean created = false;
                            try {
                                Cell[] rs; int m, j;
                                //重新检查一下是否已经创建成功了
                                if ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) {
                                    rs[j] = r;//赋值到空槽位
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;//解锁
                            }
                            if (created) {
                                break;//退出
                            }
                            //槽位现在是非空了，continue到下次循环重试
                            continue;
                        }
                    }
                    collide = false;
                } else if (!wasUncontended) {
                    //wasUncontended为false说明在同一个槽位竞争失败
                    wasUncontended = true;
                } else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) {
                    //尝试对已经有值的单元Cell进行累加，成功则退出
                    break;//若CAS更新成功则跳出循环，否则继续重试
                } else if (n &gt;= NCPU || cells != as) {
                    //累加失败，判断是否超过CPU上限
                    //超过CPU上限后，设置collide为false，为了让下次循环进入下一个条件，防止进行扩容
                    collide = false;
                } else if (!collide) {
                    collide = true;
                } else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                    //其他线程没加锁，当前线程进入时再自己加锁
                    try {
                        //对cells进行扩容
                        if (cells == as) {
                            //每次扩容2倍
                            Cell[] rs = new Cell[n &lt;&lt; 1];
                            for (int i = 0; i &lt; n; ++i) {
                                //将旧数组拷贝到新数组中
                                rs[i] = as[i];
                            }
                            cells = rs;
                        }
                    } finally {
                        cellsBusy = 0;//解锁
                    }
                    collide = false;
                    //重新找槽位
                    continue;
                }

                //执行到这一步说明，前面的步骤都没成功，需要尝试换一个累加单元Cell进行累加
                h = advanceProbe(h);
            } else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
                boolean init = false;
                try {
                    //再次检查cells引用是否改变，双重检查是为了避免并发场景下重复创建cells
                    if (cells == as) {
                        Cell[] rs = new Cell[2];//创建长度为2的cells数组
                        rs[h &amp; 1] = new Cell(x);//将累加值x随机存放到cell数组对应的索引下标位置
                        cells = rs;//再将创建的cell数组引用赋值到cells
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;//创建完cells数组后，解锁
                }
                if (init) {
                    break;
                }
            } else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) {//尝试CAS累加
                //若已经有另一个线程在初始化，那么尝试直接更新base
                break;
            }
        }
    }

    final boolean casCellsBusy() {
        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);
    }

    static final int getProbe() {
        //通过Unsafe获取Thread中threadLocalRandomProbe的值
        return UNSAFE.getInt(Thread.currentThread(), PROBE);
    }
    ...
}</code></pre>
<p data-track="288">longAccumulate()方法的流程图：</p>
<div class="pgc-img"><img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YjkzNGY3NTYwNjEzZDQ0ZmE2MjI4NTJkMmQzYWMyZTUsMTczOTcyMTUzODM4Nw==" data-ic="false" data-width="1080" data-height="1015" data-ic-uri=""></div>
<p data-track="289"><strong>(5)LongAdder的设计总结</strong></p>
<p data-track="290"><strong>一.分段CAS机制</strong></p>
<p data-track="291">把一个变量拆成多份变成多个变量，类似JDK 1.7的ConcurrentHashMap的分段锁。具体来说就是把一个Long型变量拆成一个base变量外加多个Cell变量，每个Cell变量包装了一个Long型变量。当多个线程并发累加时，如果并发度低就直接加到base变量上，如果并发度高就分散到Cell变量上。在最后取值时，再把base变量和这些Cell变量进行累加求和运算。</p>
<p data-track="292">&nbsp;</p>
<p data-track="293">LongAddr只能进行累加操作，并且初始值默认为0。LongAccumulator可以自定义一个二元操作符，而且可以传入一个初始值。</p>
<p data-track="294">&nbsp;</p>
<p data-track="295"><strong>二.最终一致性</strong></p>
<p data-track="296">LongAddr的sum()方法并没有对cell[ ]数组加锁，所以存在一边有线程对cell[ ]数组求和、一边有线程修改数组的情况。类似于ConcurrentHashMap的clear()方法，一边清空数据一边放入数据。</p>
<p data-track="297">&nbsp;</p>
<p data-track="298"><strong>三.伪共享与缓存行填充</strong></p>
<p data-track="299">LongAddr在定义Cell时，使用了注解@Contended。这个注解可以用来进行缓存行填充，从而解决伪共享问题。</p>
<p data-track="300">&nbsp;</p>
<p data-track="301"><strong>四.数组扩容</strong></p>
<p data-track="302">Cell[ ]数组的大小始终是2的整数次方，每次扩容都变为原来的2倍。</p>
<p data-track="303">&nbsp;</p>
<p data-track="304"><strong>(6)伪共享问题说明</strong></p>
<p data-track="305">每个CPU都有自己的缓存，也就是高速缓存。CPU缓存与主内存进行数据交换的基本单位叫缓存行。CPU缓存是由若干个缓存行组成的，缓存行是CPU缓存的最小存储单位。在64位的x86架构中，每个缓存行是64字节，也就是8个Long型的大小。当CPU的缓存失效了需要从主内存刷新数据时，至少需要刷新64字节。</p>
<p data-track="306">&nbsp;</p>
<p data-track="307">假设主内存的Long型变量X、Y已被CPU1和CPU2分别读入自己的缓存，且Long型变量X、Y在CPU缓存和主内存中都是放在同一行缓存行中的。这样当CPU1修改了变量X，需要失效整个缓存行时，就会往总线发送消息，通知CPU2对应的缓存行失效。所以虽然CPU2并没有修改变量Y，但也需要刷新变量Y所在的缓存行。这就是伪共享问题，缓存行上的不同变量，读CPU受到写CPU的影响。</p>
<p data-track="308">&nbsp;</p>
<p data-track="309"><strong>17.LongAdder的分段CAS优化心跳计数器</strong></p>
<p data-track="310">使用LongAdder替代AtomicLong：</p>
<pre class="highlighter-hljs"><code>//private AtomicLong latestMinuteHeartbeatRate = new AtomicLong(0L); 
private LongAdder latestMinuteHeartbeatRate = new LongAdder(); 
...
//latestMinuteHeartbeatRate.incrementAndGet();  
latestMinuteHeartbeatRate.increment();
...
//return latestMinuteHeartbeatRate.get();
return latestMinuteHeartbeatRate.longValue();
...
//latestMinuteHeartbeatRate = new AtomicLong(0L); 
latestMinuteHeartbeatRate = new LongAdder();</code></pre>
<p data-track="312">&nbsp;</p>
<p data-track="313"><strong>18.服务注册中心的增量拉取机制</strong></p>
<p data-track="314"><strong>(1)服务注册中心的增量拉取机制</strong></p>
<p data-track="315"><strong>(2)增量拉取服务注册表的实现</strong></p>
<p data-track="316"><strong>(3)提供全量和增量拉取注册表的接口</strong></p>
<p data-track="317"><strong>(4)客户端启动时拉取全量注册表</strong></p>
<p data-track="318"><strong>(5)客户端定时拉取增量注册表到本地</strong></p>
<p data-track="319"><strong>(6)客户端增量合并注册表后的校验与全量纠正</strong></p>
<p data-track="320">&nbsp;</p>
<p data-track="321"><strong>(1)服务注册中心的增量拉取机制</strong></p>
<p data-track="322">由于服务注册表的每一条数据并不是都会变化的，每隔30秒可能只有少数几个服务实例的数据会出现变化，所以并不需要每隔30秒就全量拉取服务注册表的所有数据。</p>
<p data-track="323">&nbsp;</p>
<p data-track="324">否则，如果服务实例有几万个，那么服务注册表里对应有几万条数据。每30秒拉取几万条数据，将对网络开销、注册中心的性能产生巨大压力。</p>
<p data-track="325">&nbsp;</p>
<p data-track="326">注册中心启动时，会先全量拉取一次服务注册表，然后每隔30秒增量拉取一次服务注册表。所以每隔30秒，拉取最近30秒变化的少量服务实例信息即可。</p>
<p data-track="327">&nbsp;</p>
<p data-track="328"><strong>(2)增量拉取服务注册表的实现</strong></p>
<p data-track="329">可以使用一个队列，队列里存放的就是最近3分钟有变化的服务实例。</p>
<pre class="highlighter-hljs"><code>//服务注册表
public class ServiceRegistry {
    public static final Long RECENTLY_CHANGED_ITEM_CHECK_INTERVAL = 3000L;
    public static final Long RECENTLY_CHANGED_ITEM_EXPIRED = 3 * 60 * 1000L;

    //注册表是一个单例
    private static ServiceRegistry instance = new ServiceRegistry();

    //核心的内存数据结构：注册表，Map：key是服务名称，value是这个服务的所有的服务实例
    private Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry = new HashMap&lt;String, Map&lt;String, ServiceInstance&gt;&gt;();
    
		//最近变更的服务实例的队列  
    private LinkedList&lt;RecentlyChangedServiceInstance&gt; recentlyChangedQueue = new LinkedList&lt;RecentlyChangedServiceInstance&gt;();
    
    //获取服务注册表的单例实例
    public static ServiceRegistry getInstance() {
        return instance;
    }
    
    //构造函数
    private ServiceRegistry() {
        //启动后台线程监控最近变更的队列
        RecentlyChangedQueueMonitor recentlyChangedQueueMonitor = new RecentlyChangedQueueMonitor();
        recentlyChangedQueueMonitor.setDaemon(true); 
        recentlyChangedQueueMonitor.start();
    }
    
    //服务注册
    public synchronized void register(ServiceInstance serviceInstance) {
        //将服务实例放入最近变更的队列中
        RecentlyChangedServiceInstance recentlyChangedItem = new RecentlyChangedServiceInstance(serviceInstance, System.currentTimeMillis(), ServiceInstanceOperation.REGISTER);
        recentlyChangedQueue.offer(recentlyChangedItem);
        //将服务实例放入注册表中
        Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(serviceInstance.getServiceName());
        if (serviceInstanceMap == null) {
            serviceInstanceMap = new HashMap&lt;String, ServiceInstance&gt;();
            registry.put(serviceInstance.getServiceName(), serviceInstanceMap);
        }
        serviceInstanceMap.put(serviceInstance.getServiceInstanceId(), serviceInstance);
        System.out.println("服务实例，完成注册......【" + serviceInstance + "】");  
        System.out.println("注册表：" + registry); 
    }
    
    //获取服务实例
    public synchronized ServiceInstance getServiceInstance(String serviceName, String serviceInstanceId) {
        Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(serviceName);
        return serviceInstanceMap.get(serviceInstanceId);
    }
    
    //获取整个注册表
    public synchronized Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; getRegistry() {
        return registry;
    }
    
    //从注册表删除一个服务实例
    public synchronized void remove(String serviceName, String serviceInstanceId) {
        System.out.println("服务实例从注册表中摘除[" + serviceName + ", " + serviceInstanceId + "]");
        //获取服务实例
        Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(serviceName);
        ServiceInstance serviceInstance = serviceInstanceMap.get(serviceInstanceId);
        //将服务实例变更信息放入队列中
        RecentlyChangedServiceInstance recentlyChangedItem = new RecentlyChangedServiceInstance(serviceInstance, System.currentTimeMillis(), ServiceInstanceOperation.REMOVE);
        recentlyChangedQueue.offer(recentlyChangedItem);
        //从服务注册表删除服务实例
        serviceInstanceMap.remove(serviceInstanceId);
    }
        
    //最近变化的服务实例-内部类
    class RecentlyChangedServiceInstance {
        //服务实例
        ServiceInstance serviceInstance;
        //发生变更的时间戳
        Long changedTimestamp;
        //变更操作
        String serviceInstanceOperation;
        public RecentlyChangedServiceInstance(ServiceInstance serviceInstance, Long changedTimestamp, String serviceInstanceOperation) {
            this.serviceInstance = serviceInstance;
            this.changedTimestamp = changedTimestamp;
            this.serviceInstanceOperation = serviceInstanceOperation;
        }
    }
    
    //服务实例操作-内部类
    class ServiceInstanceOperation {
        public static final String REGISTER = "register";//注册
        public static final String REMOVE = "REMOVE";//删除
    }
    
    //最近变更队列的监控线程-内部类
    class RecentlyChangedQueueMonitor extends Thread {
        @Override
        public void run() {
            while(true) {
                try {
                    //和remove与register锁的都是注册表instance实例
                    synchronized(instance) {
                        RecentlyChangedServiceInstance recentlyChangedItem = null;
                        Long currentTimestamp = System.currentTimeMillis();
                        while ((recentlyChangedItem = recentlyChangedQueue.peek()) != null) {
                            //判断如果一个服务实例变更信息已经在队列里存在超过3分钟了，就从队列中移除
                            if (currentTimestamp - recentlyChangedItem.changedTimestamp &gt; RECENTLY_CHANGED_ITEM_EXPIRED) {
                                recentlyChangedQueue.pop();
                            }
                        }
                    }
                    Thread.sleep(RECENTLY_CHANGED_ITEM_CHECK_INTERVAL);
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
        }
    }
}</code></pre>
<p data-track="331"><strong>(3)提供全量和增量拉取注册表的接口</strong></p>
<pre class="highlighter-hljs"><code>//负责接收register-client发送过来的请求的
public class RegisterServerController {
    private ServiceRegistry registry = ServiceRegistry.getInstance();
    
    //服务注册
    public RegisterResponse register(RegisterRequest registerRequest) {
        ...
    }
     
    //发送心跳
    public HeartbeatResponse heartbeat(HeartbeatRequest heartbeatRequest) { 
        ...
    }
    
    //拉取全量注册表
    public Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; fetchFullServiceRegistry() {
        return registry.getRegistry();
    }
    
    //拉取增量注册表
    public LinkedList&lt;RecentlyChangedServiceInstance&gt; fetchDeltaServiceRegistry() {
        return registry.getRecentlyChangedQueue();
    }
    
    //服务下线
    public void cancel(String serviceName, String serviceInstanceId) {
        ...
    }
}

public class ServiceRegistry {
    ...
    //获取整个注册表
    public synchronized Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; getRegistry() {
        return registry;
    }
      
    //获取最近有变化的注册表
    public synchronized LinkedList&lt;RecentlyChangedServiceInstance&gt; getRecentlyChangedQueue() {
        return recentlyChangedQueue;
    }
    ...
}</code></pre>
<p data-track="333"><strong>(4)客户端启动时拉取全量注册表</strong></p>
<pre class="highlighter-hljs"><code>//服务注册中心的客户端缓存的一个服务注册表
public class CachedServiceRegistry {
    ...
    //负责定时拉取注册表到客户端进行缓存的后台线程
    private FetchDeltaRegistryWorker fetchDeltaRegistryWorker;

    ...
    //构造函数
    public CachedServiceRegistry(RegisterClient registerClient, HttpSender httpSender) {
        this.fetchDeltaRegistryWorker = new FetchDeltaRegistryWorker();
        this.registerClient = registerClient;
        this.httpSender = httpSender;
    }

    //初始化
    public void initialize() {
        //启动全量拉取注册表的线程
        FetchFullRegistryWorker fetchFullRegistryWorker = new FetchFullRegistryWorker();
        fetchFullRegistryWorker.start();  
        //启动增量拉取注册表的线程
        this.fetchDeltaRegistryWorker.start();
    }

    //销毁这个组件
    public void destroy() {
        this.fetchDeltaRegistryWorker.interrupt();
    }

    //全量拉取注册表的后台线程
    private class FetchFullRegistryWorker extends Thread {
        @Override
        public void run() {
            registry = httpSender.fetchServiceRegistry();
        }
    }

    //增量拉取注册表的后台线程
    private class FetchDeltaRegistryWorker extends Thread {
        @Override
        public void run() {
            while(registerClient.isRunning()) {  
                try {
                    ...
                    Thread.sleep(SERVICE_REGISTRY_FETCH_INTERVAL);  
                } catch (Exception e) {
                    e.printStackTrace();  
                }
            }
        }
    }
    ...
}

//负责发送各种http请求的组件
public class HttpSender {
    ...
    //全量拉取服务注册表
    public Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; fetchServiceRegistry() {
        Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry = new HashMap&lt;String, Map&lt;String, ServiceInstance&gt;&gt;();
        ServiceInstance serviceInstance = new ServiceInstance();
        serviceInstance.setHostname("finance-service-01");  
        serviceInstance.setIp("192.168.31.1207");  
        serviceInstance.setPort(9000);  
        serviceInstance.setServiceInstanceId("FINANCE-SERVICE-192.168.31.207:9000");  
        serviceInstance.setServiceName("FINANCE-SERVICE");
        Map&lt;String, ServiceInstance&gt; serviceInstances = new HashMap&lt;String, ServiceInstance&gt;();
        serviceInstances.put("FINANCE-SERVICE-192.168.31.207:9000", serviceInstance);
        registry.put("FINANCE-SERVICE", serviceInstances);
        System.out.println("拉取注册表：" + registry);
        return registry;
    }
    
    //增量拉取服务注册表
    public LinkedList&lt;RecentlyChangedServiceInstance&gt; fetchDeltaServiceRegistry() {
        LinkedList&lt;RecentlyChangedServiceInstance&gt; recentlyChangedQueue = new LinkedList&lt;RecentlyChangedServiceInstance&gt;();
        ServiceInstance serviceInstance = new ServiceInstance();
        serviceInstance.setHostname("order-service-01");  
        serviceInstance.setIp("192.168.31.288");  
        serviceInstance.setPort(9000);  
        serviceInstance.setServiceInstanceId("ORDER-SERVICE-192.168.31.288:9000");  
        serviceInstance.setServiceName("ORDER-SERVICE");
        RecentlyChangedServiceInstance recentlyChangedItem = new RecentlyChangedServiceInstance(serviceInstance, System.currentTimeMillis(), "register");
        recentlyChangedQueue.add(recentlyChangedItem);
        System.out.println("拉取增量注册表：" + recentlyChangedQueue);
        return recentlyChangedQueue;
    }
    ...
}</code></pre>
<p data-track="335"><strong>(5)客户端定时拉取增量注册表到本地</strong></p>
<pre class="highlighter-hljs"><code>//服务注册中心的客户端缓存的一个服务注册表
public class CachedServiceRegistry {
    ...
    //增量拉取注册表的后台线程
    private class FetchDeltaRegistryWorker extends Thread {
        @Override
        public void run() {
            while(registerClient.isRunning()) {  
                try {
                    //拉取回来的是最近3分钟变化的服务实例
                    Thread.sleep(SERVICE_REGISTRY_FETCH_INTERVAL);
                    LinkedList&lt;RecentlyChangedServiceInstance&gt; deltaRegistry = httpSender.fetchDeltaServiceRegistry();
               
                    //增量信息有两类：一类是注册，一类是删除
                    //如果是注册信息，就判断一下这个服务实例是否在这个本地缓存的注册表中，如果不在就放到本地缓存注册表里
                    //如果是删除信息，就看服务实例是否存在，存在就删除
                    //这里会大量修改本地缓存的注册表，所以需要加锁
                    synchronized(registry) {
                        mergeDeltaRegistry(deltaRegistry);
                    }
                } catch (Exception e) {
                    e.printStackTrace();  
                }
            }
        }
      
        //合并增量注册表到本地缓存注册表
        private void mergeDeltaRegistry(LinkedList&lt;RecentlyChangedServiceInstance&gt; deltaRegistry) {
            for (RecentlyChangedServiceInstance recentlyChangedItem : deltaRegistry) {
                //如果是注册操作
                if (ServiceInstanceOperation.REGISTER.equals(recentlyChangedItem.serviceInstanceOperation)) {
                    Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(recentlyChangedItem.serviceInstance.getServiceName());
                    if (serviceInstanceMap == null) {
                        serviceInstanceMap = new HashMap&lt;String, ServiceInstance&gt;();
                        registry.put(recentlyChangedItem.serviceInstance.getServiceName(), serviceInstanceMap);
                    }
                    ServiceInstance serviceInstance = serviceInstanceMap.get(recentlyChangedItem.serviceInstance.getServiceInstanceId());
                    if (serviceInstance == null) {
                        serviceInstanceMap.put(recentlyChangedItem.serviceInstance.getServiceInstanceId(), recentlyChangedItem.serviceInstance);
                    }
                }
                //如果是删除操作
                else if (ServiceInstanceOperation.REMOVE.equals(recentlyChangedItem.serviceInstanceOperation)) {
                    Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(recentlyChangedItem.serviceInstance.getServiceName());
                    if (serviceInstanceMap != null) {
                        serviceInstanceMap.remove(recentlyChangedItem.serviceInstance.getServiceInstanceId());
                    }
                }
            }
        }
    }
    ...
}</code></pre>
<p data-track="337"><strong>(6)客户端增量合并注册表后的校验与全量纠正</strong></p>
<pre class="highlighter-hljs"><code>//增量拉取注册表的后台线程
private class FetchDeltaRegistryWorker extends Thread {
    @Override
    public void run() {
        while(registerClient.isRunning()) {  
            try {
                Thread.sleep(SERVICE_REGISTRY_FETCH_INTERVAL); 
            
                //拉取回来的是最近3分钟变化的服务实例
                DeltaRegistry deltaRegistry = httpSender.fetchDeltaRegistry();
            
                //一类是注册，一类是删除
                //如果是注册，就判断这个服务实例是否在本地缓存的注册表中
                //如果不在，就放到本地缓存注册表里
                //如果是删除，且服务实例还存在，那么就进行删除
                //这里会大量修改本地缓存的注册表，所以需要加锁
                synchronized(registry) {
                    mergeDeltaRegistry(deltaRegistry.getRecentlyChangedQueue()); 
                }
            
                //再检查一下，跟服务端的注册表的服务实例相比，数量是否是一致
                //封装增量注册表的对象，也就是拉取增量注册表时，
                //一方面要返回那个数据，另外一方面要那个对应的register-server端的服务实例的数量
                Long serverSideTotalCount = deltaRegistry.getServiceInstanceTotalCount();
            
                Long clientSideTotalCount = 0L;
                for (Map&lt;String, ServiceInstance&gt; serviceInstanceMap : registry.values()) {
                    clientSideTotalCount += serviceInstanceMap.size();
                }
            
                if (serverSideTotalCount != clientSideTotalCount) {
                    //重新拉取全量注册表进行纠正
                    registry = httpSender.fetchFullRegistry();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ...
}</code></pre>
<p data-track="339">&nbsp;</p>
<p data-track="340"><strong>19.AtomicReference优化客户端缓存注册表</strong></p>
<p data-track="341">多个线程同时对缓存的注册表信息进行修改时，必然存在并发冲突问题，此时可用AtomicReference的CAS操作来替代使用加重量级锁。</p>
<pre class="highlighter-hljs"><code>//完整的服务实例的信息
public class Applications {
    private Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry = new HashMap&lt;String, Map&lt;String, ServiceInstance&gt;&gt;();
    
		public Applications() {
        
    }

    public Applications(Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry) {
        this.registry = registry;
    }

    public Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; getRegistry() {
        return registry;
    }

    public void setRegistry(Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry) {
        this.registry = registry;
    }
}


//服务注册中心的客户端缓存的一个服务注册表
public class CachedServiceRegistry {
    //服务注册表拉取间隔时间
    private static final Long SERVICE_REGISTRY_FETCH_INTERVAL = 30 * 1000L;

    //客户端缓存的所有的服务实例的信息
    private AtomicReference&lt;Applications&gt; applications = new AtomicReference&lt;Applications&gt;(new Applications());
    
		//负责定时拉取注册表到客户端进行缓存的后台线程
    private FetchDeltaRegistryWorker fetchDeltaRegistryWorker;

    //RegisterClient
    private RegisterClient registerClient;

    //http通信组件
    private HttpSender httpSender;
    
    //构造函数
    public CachedServiceRegistry(RegisterClient registerClient, HttpSender httpSender) {
        this.fetchDeltaRegistryWorker = new FetchDeltaRegistryWorker();
        this.registerClient = registerClient;
        this.httpSender = httpSender;
    }
    
    //初始化
    public void initialize() {
        //启动全量拉取注册表的线程
        FetchFullRegistryWorker fetchFullRegistryWorker = new FetchFullRegistryWorker();
        fetchFullRegistryWorker.start();  
        //启动增量拉取注册表的线程
        this.fetchDeltaRegistryWorker.start();
    }
    
    //销毁这个组件
    public void destroy() {
        this.fetchDeltaRegistryWorker.interrupt();
    }
    
    //全量拉取注册表的后台线程
    private class FetchFullRegistryWorker extends Thread {
        @Override
        public void run() {
            //拉取全量注册表
            Applications fetchedApplications = httpSender.fetchFullRegistry();
            while (true) {
                Applications expectedApplications = applications.get();
                if (applications.compareAndSet(expectedApplications, fetchedApplications)) {
                    break;
                }
            }
        }
    }
    
    //增量拉取注册表的后台线程
    private class FetchDeltaRegistryWorker extends Thread {
        @Override
        public void run() {
            while (registerClient.isRunning()) {
                try {
                    Thread.sleep(SERVICE_REGISTRY_FETCH_INTERVAL);
                    //拉取回来的是最近3分钟变化的服务实例
                    DeltaRegistry deltaRegistry = httpSender.fetchDeltaRegistry();

                    //一类是注册，一类是删除
                    //如果是注册，就判断这个服务实例是否在这个本地缓存的注册表中
                    //如果不在，就放到本地缓存注册表里
                    //如果是删除，且服务实例还存在，就进行删除
                    mergeDeltaRegistry(deltaRegistry);

                    //再检查一下，跟服务端的注册表的服务实例相比，数量是否一致
                    //封装增量注册表的对象，也就是拉取增量注册表时，
                    //一方面要返回那个数据，另外一方面要那个对应的register-server端的服务实例的数量
                    reconcileRegistry(deltaRegistry);  
                } catch (Exception e) {
                    e.printStackTrace();  
                }
            }
        }
      
        //合并增量注册表到本地缓存注册表里去
        private void mergeDeltaRegistry(DeltaRegistry deltaRegistry) {
            synchronized(applications) {
                Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry = applications.get().getRegistry();
                LinkedList&lt;RecentlyChangedServiceInstance&gt; recentlyChangedQueue = deltaRegistry.getRecentlyChangedQueue();
                for (RecentlyChangedServiceInstance recentlyChangedItem : recentlyChangedQueue) {
                    String serviceName = recentlyChangedItem.serviceInstance.getServiceName();
                    String serviceInstanceId = recentlyChangedItem.serviceInstance.getServiceInstanceId();
                    //如果是注册操作
                    if (ServiceInstanceOperation.REGISTER.equals(recentlyChangedItem.serviceInstanceOperation)) {
                        Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(serviceName);
                        if (serviceInstanceMap == null) {
                            serviceInstanceMap = new HashMap&lt;String, ServiceInstance&gt;();
                            registry.put(serviceName, serviceInstanceMap);
                        }
                        ServiceInstance serviceInstance = serviceInstanceMap.get(serviceInstanceId);
                        if (serviceInstance == null) {
                            serviceInstanceMap.put(serviceInstanceId, recentlyChangedItem.serviceInstance);
                        }
                    }
                    //如果是删除操作
                    else if (ServiceInstanceOperation.REMOVE.equals(recentlyChangedItem.serviceInstanceOperation)) {
                        Map&lt;String, ServiceInstance&gt; serviceInstanceMap = registry.get(serviceName);
                        if (serviceInstanceMap != null) {
                            serviceInstanceMap.remove(serviceInstanceId); 
                        }
                    }
                }
            }
        }
      
        //校对调整注册表
        private void reconcileRegistry(DeltaRegistry deltaRegistry) {
            Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; registry = applications.get().getRegistry();
            Long serverSideTotalCount = deltaRegistry.getServiceInstanceTotalCount();
            Long clientSideTotalCount = 0L;
            for (Map&lt;String, ServiceInstance&gt; serviceInstanceMap : registry.values()) {
                clientSideTotalCount += serviceInstanceMap.size(); 
            }
         
            if (serverSideTotalCount != clientSideTotalCount) {
                //重新拉取全量注册表进行纠正
                Applications fetchedApplications = httpSender.fetchFullRegistry();
                while(true) {
                    Applications expectedApplications = applications.get();
                    if (applications.compareAndSet(expectedApplications, fetchedApplications)) {
                        break;
                    }
                } 
            }
        }
    }

    //服务实例操作
    class ServiceInstanceOperation {
        public static final String REGISTER = "register";//注册
        public static final String REMOVE = "REMOVE";//删除
    }
    
    //获取服务注册表
    public Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt; getRegistry() {
        return applications.get().getRegistry();
    } 

    //最近变更的实例信息
    static class RecentlyChangedServiceInstance {
        //服务实例
        ServiceInstance serviceInstance;
      
        //发生变更的时间戳
        Long changedTimestamp;
      
        //变更操作
        String serviceInstanceOperation;
      
        public RecentlyChangedServiceInstance(ServiceInstance serviceInstance, Long changedTimestamp, String serviceInstanceOperation) {
            this.serviceInstance = serviceInstance;
            this.changedTimestamp = changedTimestamp;
            this.serviceInstanceOperation = serviceInstanceOperation;
        }
      
        @Override
        public String toString() {
            return"RecentlyChangedServiceInstance [serviceInstance=" + serviceInstance + ", changedTimestamp=" + changedTimestamp + ", serviceInstanceOperation=" + serviceInstanceOperation + "]";
        }
    }
}</code></pre>
<p data-track="343">&nbsp;</p>
<p data-track="344"><strong>20.AtomicStampedReference解决ABA问题</strong></p>
<pre class="highlighter-hljs"><code>public class CachedServiceRegistry {
    ...
    //客户端缓存的所有的服务实例的信息
    private AtomicStampedReference&lt;Applications&gt; applications;
    ...
    //构造函数
    public CachedServiceRegistry(RegisterClient registerClient, HttpSender httpSender) {
        this.fetchDeltaRegistryWorker = new FetchDeltaRegistryWorker();
        this.registerClient = registerClient;
        this.httpSender = httpSender;
        this.applications = new AtomicStampedReference&lt;Applications&gt;(new Applications(), 0);  
    }
    ...
    //全量拉取注册表的后台线程
    private class FetchFullRegistryWorker extends Thread {
        @Override
        public void run() {
            //拉取全量注册表
            Applications fetchedApplications = httpSender.fetchFullRegistry();
            while(true) {
                Applications expectedApplications = applications.getReference();
                int expectedStamp = applications.getStamp();
                if (applications.compareAndSet(expectedApplications, fetchedApplications, expectedStamp, expectedStamp + 1)) {
                    break;
                }
            }
        }
    }
    ...
}</code></pre>
<p data-track="346">&nbsp;</p>
<p data-track="347"><strong>21.AtomicLong多线程拉取注册表版本不错乱</strong></p>
<p data-track="348"><strong>(1)发生版本错乱问题的情况</strong></p>
<p data-track="349"><strong>(2)AtomicLong解决注册表版本错乱问题</strong></p>
<p data-track="350">&nbsp;</p>
<p data-track="351">前面使用AtomicReference来解决多线程并发赋值时的原子性问题，下面使用AtomicLong来解决多线程并发拉注册表时可能的版本混乱问题。</p>
<p data-track="352">&nbsp;</p>
<p data-track="353"><strong>(1)发生版本错乱问题的情况</strong></p>
<pre class="highlighter-hljs"><code>public class CachedServiceRegistry {
    ...
    //全量拉取注册表的后台线程
    private class FetchFullRegistryWorker extends Thread {
        @Override
        public void run() {
            //拉取全量注册表操作需要通过网络完成，但是可能网络异常一直卡住，导致该请求的数据没有返回
            //卡了几分钟后，此时客户端已经缓存了很多服务实例，总服务实例已达40个
            //但该请求却可以返回了，而返回的数据却已经成为旧版本了，里面仅包含30个服务实例
            //该请求对应的全量拉取注册表线程被唤醒后，将30个服务实例的旧版本数据赋值给本地缓存注册表
            //于是便发生了版本错乱问题
           
            //所以在发起网络请求前，需要先拿到一个当时的版本号
            fetchFullRegistry();
        }
    }
    ...
}</code></pre>
<p data-track="355"><strong>(2)AtomicLong解决注册表版本错乱问题</strong></p>
<pre class="highlighter-hljs"><code>public class CachedServiceRegistry {
    ...
    //代表当前本地缓存的服务注册表的一个版本号
    private AtomicLong applicationsVersion = new AtomicLong(0L);
    ...
    //拉取全量注册表到本地
    private void fetchFullRegistry() {
        Long expectedVersion = applicationsVersion.get(); // version = 0
        Applications fetchedApplications = httpSender.fetchFullRegistry();
        if (applicationsVersion.compareAndSet(expectedVersion, expectedVersion + 1)) {
            while (true) {
                Applications expectedApplications = applications.getReference();
                int expectedStamp = applications.getStamp();
                if (applications.compareAndSet(expectedApplications, fetchedApplications, expectedStamp, expectedStamp + 1)) {
                    break;
                }
            }
        }
    }

    //增量拉取注册表的后台线程  
    private class FetchDeltaRegistryWorker extends Thread {
        @Override
        public void run() {
            while(registerClient.isRunning()) {  
                try {
                    Thread.sleep(SERVICE_REGISTRY_FETCH_INTERVAL); 
                    Long expectedVersion = applicationsVersion.get();
                    if (applicationsVersion.compareAndSet(expectedVersion, expectedVersion + 1)) {
                        DeltaRegistry deltaRegistry = httpSender.fetchDeltaRegistry();
                        mergeDeltaRegistry(deltaRegistry); 
                        //和服务端的注册表的服务实例的数量相比是否一致
                        reconcileRegistry(deltaRegistry);  
                    }
                } catch (Exception e) {
                    e.printStackTrace();  
                }
            }
        }
        ...
    }
    ...
}</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013953007807870371" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-17 00:00">2025-02-16 23:59</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18719177" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18719177);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18719177', targetLink: 'https://www.cnblogs.com/mjunz/p/18719177', title: 'JUC并发-4.wait和notify以及Atomic原理' })">举报</a>
</div>
        