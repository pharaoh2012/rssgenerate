
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/heymar/p/18573955" title="发布于 2024-11-28 11:24">
    <span role="heading" aria-level="2">ThreeJs-02Threejs开发入门与调试</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="这两天没有上传笔记在解决图床的问题主打一个白嫖所以要费点心思先是用了gitee的图床好不容易配好后发现居然加了防盗链后面又转了github的咱目前来说github也是最稳定且免费的但是有个问题这玩意得用梯子才能看到作为国内的博客谁随时挂个梯子上来所以最后还是用了收点费不是很多但能很省心的阿里云oss存储方案">这两天没有上传笔记，在解决图床的问题，主打一个白嫖，所以要费点心思，先是用了gitee的图床好不容易配好后发现居然加了防盗链，后面又转了github的咱目前来说github也是最稳定且免费的，但是有个问题，这玩意得用梯子才能看到，作为国内的博客谁随时挂个梯子上来，所以最后还是用了收点费不是很多，但能很省心的阿里云oss存储方案</h1>
<h1 id="1轨道控制器">1.轨道控制器</h1>
<h2 id="1-控制物体移动">1 控制物体移动</h2>
<p><img src="https://raw.githubusercontent.com/HeymarJR/blog-pic/main/undefined1659155882101-110d7057-c4f7-495a-8570-9a085e24acdb.gif" alt="" loading="lazy"></p>
<p>前面我们创建了物体，为了让物体移动起来。我们可以设置它的position属性进行位置的设置。</p>
<p>相机和立方体都是物体。每个物体都是1个对象。</p>
<p>在官方文档里，我们可以看到相机camera和物体mesh都继承Object3D类。所以camera、mesh都属于3d对象。从3d对象的官方文档里，我们可以找到position属性，并且该属性一个vector3对象。因此通过官方vector3类的文档，我们可以简单使用下面2种方式来修改position位置，当然后面还会讲解更多的方式。</p>
<pre><code class="language-javascript">//设置该向量的x、y 和 z 分量。
mesh.position.set(x,y,z);
//直接设置position的x,y,z属性
mesh.position.x = x;
mesh.position.y = y;
mesh.position.z = z;
</code></pre>
<p>官方文档：<a href="https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3" target="_blank" rel="noopener nofollow">https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3</a></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281117689.png" alt="" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281115598.png" alt="" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281115191.png" alt="" loading="lazy"></p>
<h3 id="11-每一帧修改一点位置形成动画">1.1 每一帧修改一点位置形成动画</h3>
<p>例如，每一帧让立方体向右移动0.01，并且当位置大于5时，从0开始。那么可以这么设置。</p>
<pre><code class="language-javascript">function render() {
  cube.position.x += 0.01;
  if (cube.position.x &gt; 5) {
    cube.position.x = 0;
  }
  renderer.render(scene, camera);
  //   渲染下一帧的时候就会调用render函数
  requestAnimationFrame(render);
}

render();
</code></pre>
<h2 id="2-综合上述代码"><font style="color: rgba(68, 68, 68, 1)">2 综合上述代码</font></h2>
<p>1、在前面创建的项目中的main.js文件写入代码</p>
<pre><code class="language-javascript">import * as THREE from "three";
// 导入轨道控制器
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

// console.log(THREE);

// 目标：控制3d物体移动

// 1、创建场景
const scene = new THREE.Scene();

// 2、创建相机
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

// 设置相机位置
camera.position.set(0, 0, 10);
scene.add(camera);

// 添加物体
// 创建几何体
const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
// 根据几何体和材质创建物体
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

// 修改物体的位置
// cube.position.set(5, 0, 0);
cube.position.x = 3;

// 将几何体添加到场景中
scene.add(cube);

console.log(cube);

// 初始化渲染器
const renderer = new THREE.WebGLRenderer();
// 设置渲染的尺寸大小
renderer.setSize(window.innerWidth, window.innerHeight);
// console.log(renderer);
// 将webgl渲染的canvas内容添加到body
document.body.appendChild(renderer.domElement);

// // 使用渲染器，通过相机将场景渲染进来
// renderer.render(scene, camera);

// 创建轨道控制器  
const controls = new OrbitControls(camera, renderer.domElement);

// 添加坐标轴辅助器
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

function render() {
  cube.position.x += 0.01;
  if (cube.position.x &gt; 5) {
    cube.position.x = 0;
  }
  renderer.render(scene, camera);
  //   渲染下一帧的时候就会调用render函数
  requestAnimationFrame(render);
}

render();

</code></pre>
<p>效果演示：</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281117442.gif" alt="" loading="lazy"></p>
<h2 id="3总结">3.总结</h2>
<p>就能放大缩小画面了</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118016.png" alt="image-20241115205706667" loading="lazy"></p>
<p>自动在中心原点处</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118985.png" alt="image-20241115205843624" loading="lazy"></p>
<p><mark>设置位置，还可以父子级网格，子级是相对于父级来设置位置</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118503.png" alt="image-20241115210215338" loading="lazy"></p>
<p>子级相较于父级的正3位置所以还是原点</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118539.png" alt="image-20241115210246725" loading="lazy"></p>
<h1 id="2物体缩放与旋转">2.物体缩放与旋转</h1>
<p>物体的缩放与旋转是我们经常要操作的方式。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118379.gif" alt="" loading="lazy"></p>
<h2 id="1-scale设置缩放">1 scale设置缩放</h2>
<p>因为物体的scale属性是vector3对象，因此按照vector的属性和方法，设置x/y/z轴方向的缩放大小。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118243.png" alt="" loading="lazy"></p>
<pre><code class="language-javascript">//例如设置x轴放大3倍、y轴方向放大2倍、z轴方向不变
cube.scale.set(3, 2, 1);
//单独设置某个轴的缩放
cube.scale.x = 3

</code></pre>
<h2 id="2-rotation设置旋转">2 rotation设置旋转</h2>
<p>因为的旋转通过设置rotation属性，该属性是Euler类的实例，因此可以通过Euler类的方法进行设置旋转角度。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118714.png" alt="" loading="lazy"></p>
<p>因此可以通过以下方式设置旋转物体</p>
<pre><code class="language-javascript">//直接设置旋转属性，例如围绕x轴旋转90度
cube.rotation.x = -Math.PI/2

//围绕x轴旋转45度
cube.rotation.set(-Math.PI / 4, 0, 0, "XZY");
</code></pre>
<p>set方法，每个参数具体定义</p>
<p><font style="color: rgba(68, 68, 68, 1)">.</font>set<font style="color: rgba(68, 68, 68, 1)"> ( x : </font><font style="color: rgba(153, 153, 153, 1)">Float</font><font style="color: rgba(68, 68, 68, 1)">, y : </font><font style="color: rgba(153, 153, 153, 1)">Float</font><font style="color: rgba(68, 68, 68, 1)">, z : </font><font style="color: rgba(153, 153, 153, 1)">Float</font><font style="color: rgba(68, 68, 68, 1)">, order : </font><font style="color: rgba(153, 153, 153, 1)">String</font><font style="color: rgba(68, 68, 68, 1)"> ) : </font><font style="color: rgba(153, 153, 153, 1)">this</font></p>
<p>x<font style="color: rgba(68, 68, 68, 1)"> - 用弧度表示x轴旋转量。<br>
</font>y<font style="color: rgba(68, 68, 68, 1)"> - 用弧度表示y轴旋转量。<br>
</font>z<font style="color: rgba(68, 68, 68, 1)"> - 用弧度表示z轴旋转量。<br>
</font>order<font style="color: rgba(68, 68, 68, 1)"> - (optional) 表示旋转顺序的字符串。</font></p>
<h3 id="21-旋转动画"><font style="color: rgba(68, 68, 68, 1)">2.1 旋转动画</font></h3>
<p>每一帧旋转弧度制的0.01角度，实现动画代码</p>
<pre><code class="language-javascript">function render() {
  cube.position.x += 0.01;
  cube.rotation.x += 0.01;
  if (cube.position.x &gt; 5) {
    cube.position.x = 0;
  }
  renderer.render(scene, camera);
  //   渲染下一帧的时候就会调用render函数
  requestAnimationFrame(render);
}
</code></pre>
<h2 id="3-综合上述代码"><font style="color: rgba(68, 68, 68, 1)">3 综合上述代码</font></h2>
<p>1、在前面创建的项目中的main.js文件写入代码</p>
<pre><code class="language-javascript">import * as THREE from "three";
// 导入轨道控制器
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

// console.log(THREE);

// 目标：控制3d物体移动

// 1、创建场景
const scene = new THREE.Scene();

// 2、创建相机
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

// 设置相机位置
camera.position.set(0, 0, 10);
scene.add(camera);

// 添加物体
// 创建几何体
const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
// 根据几何体和材质创建物体
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

// 修改物体的位置
// cube.position.set(5, 0, 0);
cube.position.x = 3;

// 将几何体添加到场景中
scene.add(cube);

console.log(cube);

// 初始化渲染器
const renderer = new THREE.WebGLRenderer();
// 设置渲染的尺寸大小
renderer.setSize(window.innerWidth, window.innerHeight);
// console.log(renderer);
// 将webgl渲染的canvas内容添加到body
document.body.appendChild(renderer.domElement);

// // 使用渲染器，通过相机将场景渲染进来
// renderer.render(scene, camera);

// 创建轨道控制器
const controls = new OrbitControls(camera, renderer.domElement);

// 添加坐标轴辅助器
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

function render() {
  cube.position.x += 0.01;
  if (cube.position.x &gt; 5) {
    cube.position.x = 0;
  }
  renderer.render(scene, camera);
  //   渲染下一帧的时候就会调用render函数
  requestAnimationFrame(render);
}

render();

</code></pre>
<p>效果演示：</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281118999.gif" alt="" loading="lazy"></p>
<h2 id="4总结">4.总结</h2>
<p>缩放也是较于父级，父级变大，子级跟着大</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119805.png" alt="image-20241115210609890" loading="lazy"></p>
<h1 id="3自适应屏幕大小">3.自适应屏幕大小</h1>
<h2 id="11-自适应屏幕大小"><font style="color: rgba(51, 51, 51, 1)">1.1 自适应屏幕大小</font></h2>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119071.gif" alt="" loading="lazy"></p>
<p><font style="color: rgba(51, 51, 51, 1)">你会发现，我们前面写好的代码，在页面尺寸发生改变的时候，并不能自适应的改变尺寸，而出现空白或者滚动条突出的情况。所以监听屏幕大小的改变，来重新设置相机的宽高比例和渲染器的尺寸大小，代码如下：</font></p>
<pre><code class="language-plain">// 监听画面变化，更新渲染画面
window.addEventListener("resize", () =&gt; {
 &nbsp;// &nbsp; console.log("画面变化了");
 &nbsp;// 更新摄像头
 &nbsp;camera.aspect = window.innerWidth / window.innerHeight;
 &nbsp;// &nbsp; 更新摄像机的投影矩阵
 &nbsp;camera.updateProjectionMatrix();

 &nbsp;// &nbsp; 更新渲染器
 &nbsp;renderer.setSize(window.innerWidth, window.innerHeight);
 &nbsp;// &nbsp; 设置渲染器的像素比
 &nbsp;renderer.setPixelRatio(window.devicePixelRatio);
});
</code></pre>
<p><font style="color: rgba(51, 51, 51, 1)">aspect属性是设置摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。camera.updateProjectionMatrix()用于更新摄像机投影矩阵，相机任何参数被改变以后必须被调用</font></p>
<h2 id="12-控制场景全屏"><font style="color: rgba(51, 51, 51, 1)">1.2 控制场景全屏</font></h2>
<p><font style="color: rgba(51, 51, 51, 1)">经常我们需要全屏的展示三维场景。例如，我们想要双击，实现全屏效果，代码如下：</font></p>
<pre><code class="language-plain">window.addEventListener("dblclick", () =&gt; {
 &nbsp;const fullScreenElement = document.fullscreenElement;
 &nbsp;if (!fullScreenElement) {
 &nbsp; &nbsp;// &nbsp; 双击控制屏幕进入全屏，退出全屏
 &nbsp; &nbsp;// 让画布对象全屏
 &nbsp; &nbsp;renderer.domElement.requestFullscreen();
  } else {
 &nbsp; &nbsp;// &nbsp; 退出全屏，使用document对象
 &nbsp; &nbsp;document.exitFullscreen();
  }
});
</code></pre>
<p><strong><font style="color: rgba(51, 51, 51, 1)">fullscreenElement</font></strong><font style="color: rgba(51, 51, 51, 1)">只读属性返回当前在此文档中以全屏模式显示的元素。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">如果文档当前未使用全屏模式，则返回值为null。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">使用</font><a href="https://www.nhooo.com/jsref/elem_requestfullscreen.html" target="_blank" rel="noopener nofollow">element.requestFullscreen()</a><font style="color: rgba(51, 51, 51, 1)">方法以全屏模式查看元素，exitFullscreen方法退出全屏。</font></p>
<h2 id="2-综合上述代码-1"><font style="color: rgba(51, 51, 51, 1)">2 综合上述代码</font></h2>
<p><font style="color: rgba(51, 51, 51, 1)">1、在前面创建的项目中的main.js文件写入代码</font></p>
<pre><code class="language-plain">import * as THREE from "three";
// 导入轨道控制器
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
// 导入动画库
import gsap from "gsap";

// console.log(THREE);

// 目标：js控制画面全屏

// 1、创建场景
const scene = new THREE.Scene();

// 2、创建相机
const camera = new THREE.PerspectiveCamera(
 &nbsp;75,
 &nbsp;window.innerWidth / window.innerHeight,
 &nbsp;0.1,
 &nbsp;1000
);

// 设置相机位置
camera.position.set(0, 0, 10);
scene.add(camera);

// 添加物体
// 创建几何体
const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
// 根据几何体和材质创建物体
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

// 修改物体的位置
// cube.position.set(5, 0, 0);
// cube.position.x = 3;
// 缩放
// cube.scale.set(3, 2, 1);
// cube.scale.x = 5;
// 旋转
cube.rotation.set(Math.PI / 4, 0, 0, "XZY");

// 将几何体添加到场景中
scene.add(cube);

console.log(cube);

// 初始化渲染器
const renderer = new THREE.WebGLRenderer();
// 设置渲染的尺寸大小
renderer.setSize(window.innerWidth, window.innerHeight);
// console.log(renderer);
// 将webgl渲染的canvas内容添加到body
document.body.appendChild(renderer.domElement);

// // 使用渲染器，通过相机将场景渲染进来
// renderer.render(scene, camera);

// 创建轨道控制器
const controls = new OrbitControls(camera, renderer.domElement);
// 设置控制器阻尼，让控制器更有真实效果,必须在动画循环里调用.update()。
controls.enableDamping = true;

// 添加坐标轴辅助器
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);
// 设置时钟
const clock = new THREE.Clock();

window.addEventListener("dblclick", () =&gt; {
 &nbsp;const fullScreenElement = document.fullscreenElement;
 &nbsp;if (!fullScreenElement) {
 &nbsp; &nbsp;// &nbsp; 双击控制屏幕进入全屏，退出全屏
 &nbsp; &nbsp;// 让画布对象全屏
 &nbsp; &nbsp;renderer.domElement.requestFullscreen();
  } else {
 &nbsp; &nbsp;// &nbsp; 退出全屏，使用document对象
 &nbsp; &nbsp;document.exitFullscreen();
  }
 &nbsp;// &nbsp; console.log(fullScreenElement);
});

function render() {
 &nbsp;controls.update();
 &nbsp;renderer.render(scene, camera);
 &nbsp;// &nbsp; 渲染下一帧的时候就会调用render函数
 &nbsp;requestAnimationFrame(render);
}

render();

// 监听画面变化，更新渲染画面
window.addEventListener("resize", () =&gt; {
 &nbsp;// &nbsp; console.log("画面变化了");
 &nbsp;// 更新摄像头
 &nbsp;camera.aspect = window.innerWidth / window.innerHeight;
 &nbsp;// &nbsp; 更新摄像机的投影矩阵
 &nbsp;camera.updateProjectionMatrix();

 &nbsp;// &nbsp; 更新渲染器
 &nbsp;renderer.setSize(window.innerWidth, window.innerHeight);
 &nbsp;// &nbsp; 设置渲染器的像素比
 &nbsp;renderer.setPixelRatio(window.devicePixelRatio);
});
</code></pre>
<p><font style="color: rgba(51, 51, 51, 1)">效果演示：</font></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119423.gif" alt="" loading="lazy"></p>
<h2 id="应对hd-dpi显示器"><font style="color: rgba(51, 51, 51, 1)">应对HD-DPI显示器</font></h2>
<p><font style="color: rgba(51, 51, 51, 1)">HD-DPI代表每英寸高密度点显示器(视网膜显示器)。它指的是当今大多数的Mac和windows机器以及几乎所有的智能手机。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">浏览器中的工作方式是不管屏幕的分辨率有多高使用CSS像素设置尺寸会被认为是一样的。 同样的物理尺寸浏览器会渲染出字体的更多细节。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">使用three.js有多种方法来应对HD-DPI。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">第一种就是不做任何特别的事情。这可以说是最常见的。 渲染三维图形需要大量的GPU处理能力。移动端的GPU能力比桌面端的要弱。至少截止到2018年, 手机都有非常高的分辨率显示器。 目前最好的手机的HD-DPI比例为3x，意思是非高密度点显示器上的一个像素在高密度显示器上是9个像素。 意味着需要9倍的渲染。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">计算9倍的像素是个大工程所以如果保持代码不变我们将计算一个像素然后浏览器将以三倍大小绘制(3x3=9像素)。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">对于大型的three.js应用来说上面就是你想要的否侧你的帧速率会很低。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">尽管如此如果你确实想用设备的分辨率来渲染，three.js中有两种方法来实现。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">一种是使用renderer.setPixelRatio来告诉three.js分辨率的倍数。 访问浏览器从CSS像素到设备像素的倍数然后传给three.js。</font></p>
<p>renderer.setPixelRatio(window.devicePixelRatio);</p>
<p><font style="color: rgba(51, 51, 51, 1)">之后任何对renderer.setSize的调用都会神奇地使用您请求的大小乘以您传入的像素比例. 强烈不建议这样。 看下面。</font></p>
<p><font style="color: rgba(51, 51, 51, 1)">另一种方法是在调整canvas的大小时自己处理。</font></p>
<pre><code class="language-plain">function resizeRendererToDisplaySize(renderer) {
 &nbsp; &nbsp; &nbsp;const canvas = renderer.domElement;
 &nbsp; &nbsp; &nbsp;const pixelRatio = window.devicePixelRatio;
 &nbsp; &nbsp; &nbsp;const width = canvas.clientWidth * pixelRatio | 0;
 &nbsp; &nbsp; &nbsp;const height = canvas.clientHeight * pixelRatio | 0;
 &nbsp; &nbsp; &nbsp;const needResize = canvas.width !== width || canvas.height !== height;
 &nbsp; &nbsp; &nbsp;if (needResize) {
 &nbsp; &nbsp; &nbsp; &nbsp;renderer.setSize(width, height, false);
 &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp;return needResize;
 &nbsp;  }
</code></pre>
<p><font style="color: rgba(51, 51, 51, 1)">第二章方法从客观上来说更好。为什么？因为我拿到了我想要的。 在使用three.js时有很多种情况下我们需要知道canvas的绘图缓冲区的确切尺寸。 比如制作后期处理滤镜或者我们在操作着色器需要访问gl_FragCoord变量，如果我们截屏或者给GPU 读取像素，绘制到二维的canvas等等。 通过我们自己处理我们会一直知道使用的尺寸是不是我们需要的。 幕后并没有什么特殊的魔法发生。</font></p>
<h2 id="3其他补充">3.其他补充</h2>
<h3 id="31-gui调试工具">3.1 gui调试工具</h3>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119312.png" alt="image-20241115220219132" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119277.png" alt="image-20241115221840993" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119641.png" alt="image-20241115221832251" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119260.png" alt="image-20241115222155709" loading="lazy"></p>
<h3 id="32-创建顶点形成三角形">3.2 创建顶点，形成三角形</h3>
<p>three里面所有材质平面都是由三角形组成<img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119757.png" alt="image-20241118205745969" loading="lazy"></p>
<p>一个面顶点的数量，因为设置了共用顶点</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119145.png" alt="image-20241118205809786" loading="lazy"></p>
<h3 id="33-顶点组">3.3 顶点组</h3>
<p>可以一个网格的多个材质拆分开，分别设置，需要设置顶点组，材质所以在的顶点为一个组</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119823.png" alt="image-20241118210130874" loading="lazy"></p>
<p>创建几何体，在分别创建不同的材质，注意材质用数组</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119783.png" alt="image-20241118210342341" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119956.png" alt="image-20241118210401796" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119774.png" alt="image-20241118210446710" loading="lazy"></p>
<h3 id="34-快速创建几何体">3.4 快速创建几何体</h3>
<p>刚才看到的是用材质创建</p>
<p>官网可以快速创建</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119021.png" alt="image-20241118211811954" loading="lazy"></p>
<h2 id="4基础材质">4.基础材质</h2>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281119397.png" alt="image-20241118213320472" loading="lazy"></p>
<p><mark>基础材质不受光照影响</mark></p>
<p>贴图</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120208.png" alt="image-20241118213405522" loading="lazy"></p>
<p>加上透明度</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120807.png" alt="image-20241118213422445" loading="lazy"></p>
<p>透明度贴图，黑色部分完全透明，只剩下白色部分</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120461.png" alt="image-20241118213502815" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120539.png" alt="image-20241118213509915" loading="lazy"></p>
<p>加上背景，环境以及环境贴图都为同一张鱼眼图后，可让材质如同在这个场景中</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120968.png" alt="image-20241118213629041" loading="lazy"></p>
<p>高光贴图，越亮的区域反射光线越明显</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120599.png" alt="image-20241118213716547" loading="lazy"></p>
<p>光照贴图，让材质能够有此贴图的光照效果</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120185.png" alt="image-20241118213748077" loading="lazy"></p>
<p><mark>代码实现</mark></p>
<p>创建几何体，创建材质，几何体和材质形成物体</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120777.png" alt="image-20241118213912347" loading="lazy"></p>
<p>加载纹理贴图</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120713.png" alt="image-20241118214011902" loading="lazy"></p>
<p>允许透明度</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120153.png" alt="image-20241118214058364" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120253.png" alt="image-20241118214043065" loading="lazy"></p>
<p><mark>加载ao贴图</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120840.png" alt="image-20241118214343414" loading="lazy"></p>
<p><mark>透明贴图</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281120612.png" alt="image-20241118214505728" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121347.png" alt="image-20241118214802119" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121882.png" alt="image-20241118214807540" loading="lazy"></p>
<p><mark>光照贴图</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121562.png" alt="image-20241118214844829" loading="lazy"></p>
<p><mark>环境贴图，需要hdr加载器</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121443.png" alt="image-20241118214927473" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121865.png" alt="image-20241118214950629" loading="lazy"></p>
<p>想让环境包裹场景</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121671.png" alt="image-20241118215026319" loading="lazy"></p>
<p>还可以在里面设置环境贴图，让材质可以在这个环境反射，透明等更为真实</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121306.png" alt="image-20241118215331467" loading="lazy"></p>
<p><mark>光照贴图，高光贴图</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121637.png" alt="image-20241118215207611" loading="lazy"></p>
<h3 id="41-纹理属性">4.1 纹理属性</h3>
<p>如果感觉有色差，那么看下是不是纹理属性的色彩原因，默认是线性，和	srgb，同在50%，srbg分布的更均匀一点，从暗到白</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121919.png" alt="image-20241118220122048" loading="lazy"></p>
<p>切换方法</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121018.png" alt="image-20241118220145911" loading="lazy"></p>
<h3 id="42-雾">4.2 雾</h3>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121192.png" alt="image-20241118220250959" loading="lazy"></p>
<p>两种，一种线性（慢慢开始有雾），一种指数（很快就被雾包裹）</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121823.png" alt="image-20241118220413328" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121839.png" alt="image-20241118220425318" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121838.png" alt="image-20241118220506312" loading="lazy"></p>
<h1 id="4gltf模型加载">4.gltf模型加载</h1>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281121495.gif" alt="GIF" loading="lazy"></p>
<p><strong>真正的three场景，比如下面这样，并不是一个一个考代码写出来会很累，也很复杂，一般都是用建模软件建好之后，用gitf加载进来</strong></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122819.png" alt="image-20241118220817312" loading="lazy"></p>
<p>GLTFLoader是Three.js中用于加载glTF 2.0资源的加载器。glTF是一种开放格式规范，旨在更高效地传输和加载3D内容。该格式文件以JSON或二进制(.glb)格式提供，可以包含外部文件存储贴图(.jpg、.png)和额外的二进制数据(.bin)。</p>
<p>一个glTF文件可以包含一个或多个场景，每个场景包括网格、材质、贴图、蒙皮、骨架、变形目标、动画、灯光以及摄像机等组件。这些组件可以通过GLTFLoader进行加载和解析，并在Three.js中使用。</p>
<p>下面是一个简单的案例，演示如何使用GLTFLoader加载模型并在Three.js中进行渲染：</p>
<pre><code class="language-javascript">// 创建场景
const scene = new THREE.Scene();

// 创建相机
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

// 创建渲染器
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 创建GLTFLoader对象并加载模型
const loader = new THREE.GLTFLoader();
loader.load('model.gltf', function (gltf) {
  // 将模型添加到场景中
  scene.add(gltf.scene);

  // 设置相机位置和渲染目标
  camera.position.x += (Math.sin(Date.now() * 0.001) * 500);
  camera.position.y += (Math.sin(Date.now() * 0.001) * 500);
  camera.lookAt(scene.position);

  // 在每一帧更新时更新相机位置和渲染目标
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
}, undefined, function (error) {
  console.error(error);
});
</code></pre>
<p>在这个案例中，我们首先创建了一个场景、一个相机和一个渲染器。然后创建了一个GLTFLoader对象并调用<code>load()</code>方法来加载glTF资源。当加载完成时，我们将模型添加到场景中，并设置相机的位置和渲染目标。最后在每一帧更新时调用渲染器的<code>render()</code>方法来渲染整个场景。如果加载过程中出现错误，会输出错误信息到控制台。</p>
<p>导进来这个物体也是个组对象，这也是个3D对象，可以去设置属性</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122660.png" alt="image-20241118221449090" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122657.png" alt="image-20241118221501119" loading="lazy"></p>
<p>要让这个物体的材质有颜色并且可以反射光，可以去设置一个环境贴图，并且球体贴图，让四周都能够染色</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122327.png" alt="image-20241118221636555" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122587.png" alt="image-20241118221644927" loading="lazy"></p>
<h2 id="解压缩">解压缩</h2>
<p>如果一个场景物体过大需要解压缩</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122780.png" alt="image-20241118221807216" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122618.png" alt="image-20241118221826066" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122411.png" alt="image-20241118221845083" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122847.png" alt="image-20241118221921365" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122715.png" alt="image-20241118221932865" loading="lazy"></p>
<h1 id="5补件动画tween">5.补件动画tween</h1>
<h2 id="光线投射实现场景交互">光线投射实现场景交互</h2>
<p>要拿到three里面的材质，不能通过事件，只能通过从摄像机射出一个光投射过可以拿到物体</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122638.png" alt="image-20241119203821979" loading="lazy"></p>
<p>创建三个球</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122794.png" alt="image-20241119203909379" loading="lazy"></p>
<p>创建射线和鼠标向量</p>
<p>在全局点击事件里面，将当前点击的鼠标坐标转换成three的向量坐标，-1—1的范围，<mark>可以直接记公式</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122989.png" alt="image-20241119204509570" loading="lazy"></p>
<p>在全局点击事件里面，通过摄像机和鼠标点击位置更新射线，同时计算射线穿过去的物体，<strong>括号里面可以写一个数组为你创建的物体，也可以直接scene.children</strong>会检测到所有穿过去的物体为一个数组</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122866.png" alt="image-20241119205111936" loading="lazy"></p>
<p>拿到这个物体后就可以去做一些事情，比如让点击到的第一个物体为一个颜色，再次点击回到原来颜色</p>
<p><mark>注意：getHex方法获取到颜色的十六进制</mark></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122323.png" alt="image-20241119205239544" loading="lazy"></p>
<h2 id="tween-是什么如何使用你为什么想用它">tween 是什么？如何使用？你为什么想用它？</h2>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122000.png" alt="" loading="lazy"></p>
<p>补间(动画)（来自 <a href="https://en.wikipedia.org/wiki/Inbetweening" target="_blank" rel="noopener nofollow">in-between</a>）是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122685.png" alt="image-20241119205448782" loading="lazy"></p>
<p>创建实例，什么轴到哪个位置，多少毫秒内完成</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281122098.png" alt="image-20241119205707702" loading="lazy"></p>
<p>例如，<code>position</code>对象拥有<code>x</code>和<code>y</code>两个坐标:</p>
<pre><code class="language-javascript">var position = {x: 100, y: 0}
</code></pre>
<p>如果你想将<code>x</code>坐标的值从<code>100</code>变成<code>200</code>，你应该这么做：</p>
<pre><code class="language-javascript">// 首先为位置创建一个补间(tween)
var tween = new TWEEN.Tween(position)

// 然后告诉 tween 我们想要在1000毫秒内以动画的形式移动 x 的位置
tween.to({x: 200}, 1000)
</code></pre>
<p>一般来说这样还不够，tween 已经被创建了，但是它还没被激活(使用)，你需要这样启动：</p>
<pre><code class="language-javascript">// 启动
tween.start()
</code></pre>
<p>最后，想要成功的完成这种效果，你需要在主函数中调用<code>TWEEN.update</code>，如下使用：</p>
<pre><code class="language-javascript">animate()

function animate() {
	requestAnimationFrame(animate)
	// [...]
	TWEEN.update()
	// [...]
}
</code></pre>
<p>这样在更新每帧的时候都会运行补间动画；经过 1 秒后 (1000 毫秒) <code>position.x</code>将会变成 <code>200</code>。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281123406.png" alt="image-20241119210307197" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281123275.png" alt="image-20241119210447052" loading="lazy"></p>
<p>除非你在控制台中打印出 <code>x</code> 的值，不然你看不到它的变化。你可能想要使用 <code>onUpdate</code> 回调:</p>
<pre><code class="language-javascript">tween.onUpdate(function (object) {
	console.log(object.x)
})
</code></pre>
<blockquote>
<p>tips:你可能在这里获取不到 <code>object.x</code> ,具体的见我提的这个 <a href="https://github.com/tweenjs/tween.js/issues/402" target="_blank" rel="noopener nofollow">issue</a></p>
</blockquote>
<p>这个函数将会在动画每次更新的时候被调用；这种情况发生的频率取决于很多因素 - 例如，计算机或设备的速度有多快（以及如何繁忙）。</p>
<p>到目前为止，我们只使用补间动画向控制台输出值，但是您可以将它与 three.js 对象结合：</p>
<pre><code class="language-javascript">var tween = new TWEEN.Tween(cube.position).to({x: 100, y: 100, z: 100}, 10000).start()

animate()

function animate() {
	requestAnimationFrame(animate)
	TWEEN.update()

	threeRenderer.render(scene, camera)
}
</code></pre>
<p>在这种情况下，因为 three.js 渲染器将在渲染之前查看对象的位置，所以不需要使用明确的<code>onUpdate</code>回调。</p>
<p>你可能也注意到了一些不同的地方：tween.js 可以链式调用！ 每个<code>tween</code>函数都会返回<code>tween</code>实例，所以你可以重写下面的代码：</p>
<pre><code class="language-javascript">var tween = new TWEEN.Tween(position)
tween.to({x: 200}, 1000)
tween.start()
</code></pre>
<p>改成这样：</p>
<pre><code class="language-javascript">var tween = new TWEEN.Tween(position).to({x: 200}, 1000).start()
</code></pre>
<p>在将会看到很多例子，所以熟悉它是很好的！比如 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/04_simplest.html" target="_blank" rel="noopener nofollow">04-simplest</a> 这个例子。</p>
<h2 id="tweenjs-的动画">tween.js 的动画</h2>
<p>Tween.js 不会自行运行。你需要显式的调用 <code>update</code> 方法来告诉它何时运行。推荐的方法是在主动画循环中执行这个操作。使用 <code>requestAnimationFrame</code> 调用此循环以获得最佳的图形性能。</p>
<p>比如之前这个例子：</p>
<pre><code class="language-javascript">animate()

function animate() {
	requestAnimationFrame(animate)
	// [...]
	TWEEN.update()
	// [...]
}
</code></pre>
<p>如果调用的时候不传入参数，<code>update</code> 将会判断当前时间点以确定自上次运行以来已经有多久。</p>
<p>当然你也可以传递一个明确的时间参数给 <code>update</code></p>
<pre><code class="language-javascript">TWEEN.update(100)
</code></pre>
<p>意思是"更新时间 = 100 毫秒"。你可以使用它来确保代码中的所有时间相关函数都使用相同的时间值。例如，假设你有一个播放器，并希望同步运行补间。 你的 <code>animate</code> 函数可能看起来像这样：</p>
<pre><code class="language-javascript">var currentTime = player.currentTime
TWEEN.update(currentTime)
</code></pre>
<p>我们使用明确的时间值进行单元测试。你可以看下 <a href="../src/tests.ts" target="_blank" rel="noopener nofollow">tests.ts</a> 这个例子，看看我们如何用不同的值调用<code>TWEEN.update()</code> 来模拟时间传递。</p>
<h2 id="控制一个补间">控制一个补间</h2>
<h3 id="start-和-stop">start 和 stop</h3>
<p>到目前为止，我们已经了解了<code>Tween.start</code>方法，但是还有更多的方法来控制单个补间。 也许最重要的一个是 <code>start</code> 对应的方法：<code>停止</code> 。 如果你想取消一个补间，只要调用这个方法通过一个单独的补间:</p>
<pre><code class="language-javascript">tween.stop()
</code></pre>
<p>停止一个从未开始或已经停止的补间没有任何效果。 没有错误被抛出。</p>
<p><code>start</code> 方法接受一个参数 <code>time</code>。如果你使用它，那么补间不会立即开始，直到特定时刻，否则会尽快启动（i.e 即在下次调用 <code>TWEEN.update</code>）。</p>
<h3 id="update">update</h3>
<p>补间也有一个更新的方法---这实际上是由 <code>TWEEN.update</code> 调用的。 你通常不需要直接调用它，除非你是个 疯狂的 hacker。</p>
<h3 id="chain">chain</h3>
<p>当你顺序排列不同的补间时，事情会变得有趣，例如在上一个补间结束的时候立即启动另外一个补间。我们称这为链式补间，这使用 <code>chain</code> 方法去做。因此，为了使 <code>tweenB</code> 在 <code>tewwnA</code> 启动：</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281123659.png" alt="image-20241119211332110" loading="lazy"></p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281123847.gif" alt="GIF" loading="lazy"></p>
<pre><code class="language-javascript">tweenA.chain(tweenB)
</code></pre>
<p>或者，对于一个无限的链式，设置 tweenA 一旦 tweenB 完成就开始：</p>
<pre><code class="language-javascript">tweenA.chain(tweenB)
tweenB.chain(tweenA)
</code></pre>
<p>关于无限的链式查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/00_hello_world.html" target="_blank" rel="noopener nofollow">Hello world</a> 。</p>
<p>在其他情况下，您可能需要将多个补间链接到另一个补间，以使它们（链接的补间）同时开始动画：</p>
<pre><code class="language-javascript">tweenA.chain(tweenB, tweenC)
</code></pre>
<blockquote>
<p>警告：调用 <code>tweenA.chain（tweenB）</code> 实际上修改了 tweenA，所以 tweenA 总是在 tweenA 完成时启动。 <code>chain</code> 的返回值只是 tweenA，不是一个新的 tween。</p>
</blockquote>
<h3 id="repeat">repeat</h3>
<p>如果你想让一个补间永远重复，你可以链接到自己，但更好的方法是使用 <code>repeat</code> 方法。 它接受一个参数，描述第一个补间完成后需要多少次重复</p>
<pre><code class="language-javascript">tween.repeat(10) // 循环10次
tween.repeat(Infinity) // 无限循环
</code></pre>
<p>补间的总次数将是重复参数加上一个初始补间。查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/08_repeat.html" target="_blank" rel="noopener nofollow">Repeat</a>。</p>
<h3 id="yoyo">yoyo</h3>
<p>这个功能只有在独自使用 <code>repeat</code> 时才有效果。 活跃时，补间的行为将像 yoyo 一样，i.e 它会从起始值和结束值之间跳出，而不是从头开始重复相同的顺序。</p>
<h3 id="delay">delay</h3>
<p>更复杂的安排可能需要在实际开始运行之前延迟补间。 你可以使用 <code>delay</code> 方法来做到这一点</p>
<pre><code class="language-javascript">tween.delay(1000)
tween.start()
</code></pre>
<p>将在调用启动方法后的 1 秒钟后开始执行。</p>
<h2 id="控制所有补间">控制所有补间</h2>
<p>在 TWEEN 全局对象中可以找到以下方法，除了 <code>update</code> 之外，通常不需要使用其中的大部分对象。</p>
<h3 id="tweenupdatetime">TWEEN.update(time)</h3>
<p>我们已经讨论过这种方法。 它用于更新所有活动的补间。<br>
如果 <code>time</code> 不指定，它将使用当前时间。</p>
<h3 id="tweengetall-and-tweenremoveall">TWEEN.getAll and TWEEN.removeAll</h3>
<p>用于获取对活动 <code>tweens</code> 数组的引用，并分别仅从一个调用中将它们全部从数组中删除</p>
<h3 id="tweenaddtween-and-tweenremovetween">TWEEN.add(tween) and TWEEN.remove(tween)</h3>
<p>用于将补间添加到活动补间的列表，或者分别从列表中删除特定的补间。</p>
<p>这些方法通常只在内部使用，但是如果您想要做一些有趣的事情，则会被暴露。</p>
<h2 id="控制补间组">控制补间组</h2>
<p>使用 <code>TWEEN</code> 单例来管理补间可能会导致包含许多组件的大型应用程序出现问题。 在这些情况下，您可能希望创建自己的更小的补间组。</p>
<h3 id="示例交叉组件冲突">示例：交叉组件冲突</h3>
<p>如果使用 <code>TWEEN</code> 有多个组件，并且每个组件都想管理自己的一组补间，则可能发生冲突。 如果一个组件调用 <code>TWEEN.update（）</code> 或 <code>TWEEN.removeAll（）</code>，则其他组件的补间也将被更新或删除。</p>
<h3 id="创建你自己的补间组">创建你自己的补间组</h3>
<p>为了解决这个问题，每个组件都可以创建自己的 <code>TWEEN.Group</code> 实例（这是全局的 <code>TWEEN</code> 对象在内部使用的）。 实例化新的补间时，可以将这些组作为第二个可选参数传入：</p>
<pre><code class="language-javascript">var groupA = new TWEEN.Group()
var groupB = new TWEEN.Group()

var tweenA = new TWEEN.Tween({x: 1}, groupA).to({x: 10}, 100).start()

var tweenB = new TWEEN.Tween({x: 1}, groupB).to({x: 10}, 100).start()

var tweenC = new TWEEN.Tween({x: 1}).to({x: 10}, 100).start()

groupA.update() // 只更新tweenA
groupB.update() // 只更新tweenB
TWEEN.update() // 只更新tweenC

groupA.removeAll() // 只移除tweenA
groupB.removeAll() // 只移除tweenB
TWEEN.removeAll() // 只移除tweenC
</code></pre>
<p>通过这种方式，每个组件都可以处理创建，更新和销毁自己的一组补间。</p>
<h2 id="改变缓动功能">改变缓动功能</h2>
<p>Tween.js 将以线性方式执行值之间的插值（即缓动），所以变化将与流逝的时间成正比。 这是可以预见的，但在视觉上也是相当无趣的。 不要担心 - 使用缓动方法可以轻松更改此行为。 例如：</p>
<pre><code class="language-javascript">tween.easing(TWEEN.Easing.Quadratic.In)
</code></pre>
<p>这将导致缓慢地开始向最终值变化，向中间加速，然后迅速达到其最终值，相反，<code>TWEEN.Easing.Quadratic.Out</code> 一开始会加速，但随着值的接近最终放缓。</p>
<h3 id="可用的缓动函数tweeneasing">可用的缓动函数：TWEEN.Easing</h3>
<p>tween.js 提供了一些现有的缓动功能。它们按照它们表示的方程式进行分组：线性，二次，三次，四次，五次，正弦，指数，圆形，弹性，背部和弹跳，然后是缓动型：In，Out 和 InOut。</p>
<p>除非您已经熟悉这些概念，否则这些名称可能不会对您说什么，所以您可能需要查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/03_graphs.html" target="_blank" rel="noopener nofollow">Graphs</a> 示例，该示例将一个页面中的所有曲线进行图形化，以便比较它们如何看待一瞥。</p>
<p>这些功能是从 Robert Penner 慷慨地提供几年前作为自由软件提供的原始方程派生而来的，但是已经被优化以便与 JavaScript 很好地发挥作用。</p>
<p><img src="https://heymar.oss-cn-chengdu.aliyuncs.com/undefined202411281123491.png" alt="image-20241119211028024" loading="lazy"></p>
<h3 id="使用自定义缓动功能">使用自定义缓动功能</h3>
<p>您不仅可以使用任何现有的功能，还可以提供您自己的功能，只要遵循一些约定即可：</p>
<ul>
<li>它必须接受一个参数：
<ul>
<li><code>k</code>: 缓动过程，或我们的补间所处的时间有多长。允许的值在[0，1]的范围内。</li>
</ul>
</li>
<li>它必须根据输入参数返回一个值。</li>
</ul>
<p>不管要修改多少个属性，easing 函数在每次更新时只调用一次。 然后将结果与初始值以及这个值和最终值之间的差值（delta）一起使用，就像这个伪代码一样：</p>
<pre><code class="language-javascript">easedElapsed = easing(k);
for each property:
	newPropertyValue = initialPropertyValue + propertyDelta * easedElapsed;
</code></pre>
<p>对于更注重性能表现的人来说：只有在补间上调用 <code>start()</code> 时才会计算增量值。</p>
<p>因此，让我们假设您想使用一个缓解值的自定义缓动函数，但是将 Math.floor 应用于输出，所以只返回整数部分，从而产生一种梯级输出:</p>
<pre><code class="language-javascript">function tenStepEasing(k) {
	return Math.floor(k * 10) / 10
}
</code></pre>
<p>你可以通过简单地调用它的缓动方法来使用它，就像我们之前看到的那样：</p>
<pre><code class="language-javascript">tween.easing(tenStepEasing)
</code></pre>
<p>查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/12_graphs_custom_functions.html" target="_blank" rel="noopener nofollow">graphs for custom easing functions</a> 示例，以查看这个动作（还有一些用于生成步进函数的元编程）。</p>
<h2 id="回调函数">回调函数</h2>
<p>另一个强大的特性是能够在每个补间的生命周期的特定时间运行自己的功能。 当更改属性不够时，通常需要这样做。</p>
<p>例如，假设你正在试图给一些不能直接访问属性的对象设置动画，但是需要你调用 setter。 您可以使用 <code>update</code> 回调来读取新的更新值，然后手动调用 setters。 所有的回调函数都将补间对象作为唯一的参数。</p>
<pre><code class="language-javascript">var trickyObjTween = new TWEEN.Tween({
	propertyA: trickyObj.getPropertyA(),
	propertyB: trickyObj.getPropertyB(),
})
	.to({propertyA: 100, propertyB: 200})
	.onUpdate(function (object) {
		object.setA(object.propertyA)
		object.setB(object.propertyB)
	})
</code></pre>
<p>或者想象一下，当一个补间开始时，你想播放声音。你可以使用 <code>start</code> 回调：</p>
<pre><code class="language-javascript">var tween = new TWEEN.Tween(obj).to({x: 100}).onStart(function () {
	sound.play()
})
</code></pre>
<p>每个回调的范围是补间对象--在这种情况下，是 <code>obj</code>。</p>
<h3 id="onstart">onStart</h3>
<p>在补间开始之前执行--i.e. 在计算之前。每个补间只能执行一次，i.e. 当通过 <code>repeat()</code> 重复补间时，它将不会运行。</p>
<p>同步到其他事件或触发您要在补间启动时发生的操作是非常好的。</p>
<p>补间对象作为第一个参数传入。</p>
<h3 id="onstop">onStop</h3>
<p>当通过 <code>stop()</code> 显式停止补间时执行，但在正常完成时并且在停止任何可能的链补间之前执行补间。</p>
<p>补间对象作为第一个参数传入。</p>
<h3 id="onupdate">onUpdate</h3>
<p>每次补间更新时执行，实际更新后的值。</p>
<p>补间对象作为第一个参数传入。</p>
<h3 id="oncomplete">onComplete</h3>
<p>当补间正常完成（即不停止）时执行。</p>
<p>补间对象作为第一个参数传入。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="29.89681486633565" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-11-28 11:30">2024-11-28 11:24</span>&nbsp;
<a href="https://www.cnblogs.com/heymar">Heymar-10</a>&nbsp;
阅读(<span id="post_view_count">141</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18573955" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18573955);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18573955', targetLink: 'https://www.cnblogs.com/heymar/p/18573955', title: 'ThreeJs-02Threejs开发入门与调试' })">举报</a>
</div>
        