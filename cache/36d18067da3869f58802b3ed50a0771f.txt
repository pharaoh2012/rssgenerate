<!----> <meta itemprop="headline" content="记 2025-02-27 裸辞，2025-03-21 收获 offer"> <meta itemprop="keywords" content="前端"> <meta itemprop="datePublished" content="2025-03-24T06:36:22.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="岁月可贵"> <meta itemprop="url" content="https://juejin.cn/user/1258302989143437"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-a534e47e="">
            记 2025-02-27 裸辞，2025-03-21 收获 offer
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-a534e47e=""><div class="author-info-box" data-v-a534e47e=""><div class="author-name" data-v-a534e47e=""><a href="/user/1258302989143437/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-a534e47e=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    岁月可贵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-a534e47e=""><time datetime="2025-03-24T06:36:22.000Z" title="Mon Mar 24 2025 06:36:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-a534e47e="">
                    2025-03-24
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-a534e47e=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-a534e47e=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-a534e47e=""></circle></svg> <span class="views-count" data-v-a534e47e="">
                    0
                  </span> <span class="read-time" data-v-a534e47e=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-a534e47e=""><rect width="16" height="16" fill="none" data-v-a534e47e=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-a534e47e=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-a534e47e=""></path></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-a534e47e=""></div> <!----> <!----></div> <!----> <!----> <!----> <img src="https://p26-piu.byteimg.com/tos-cn-i-8jisjyls3a/56f1f29e316346e4bf4d8d5562a7cd25~tplv-8jisjyls3a-image.image" style="width:100%;height:auto;display:block;" data-v-a534e47e=""> <div id="article-root" itemprop="articleBody" class="main" data-v-a534e47e=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">前言</h2>
<p>本人 2025-02-27 裸辞，2025-03-21 收获 offer。该文章记录了在面试过程中被提问到的问题，并进行总结记录。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c59b3ae662541a1bc1196dfcce017c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bKB5pyI5Y-v6LS1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743402982&amp;x-signature=nqwvOtmlkZxYtqROSPvcqUNt9EY%3D" alt="1.png" loading="lazy"></p>
<h2 data-id="heading-1">面试题</h2>
<h3 data-id="heading-2">Vue2.0 和 Vue3.0 有什么区别</h3>
<p>1、响应式重新配置，使用 proxy 替换 Object.defineProperty</p>
<ul>
<li>
<p>Object.defineProperty：劫持整个对象，然后进行<strong>深度遍历所有属性</strong>，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p>
</li>
<li>
<p>proxy ： 劫持整个对象，但不用<strong>深度遍历所有属性</strong>，同样需要添加 <code>getter</code> 和 <code>setter</code>、<code>deleteProperty</code>，实现响应式</p>
</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, {
  <span class="hljs-comment">// 拦截读取属性值</span>
  get (target, prop) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)
  },
  <span class="hljs-comment">// 拦截设置属性值或添加新属性</span>
  set (target, prop, value) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)
  },
  <span class="hljs-comment">// 拦截删除属性</span>
  deleteProperty (target, prop) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)
  }
})
</code></pre>
<p>2、新增组合 API（Composition API），更好的逻辑重用和代码组织</p>
<p>3、<code>v-if </code>和<code>v-for</code>的优先级</p>
<p>5、支持多个根节点（<code>template</code>中不需要唯一根节点，可以直接放文本或者同级标签）</p>
<p>6、打包体积优化 （任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包）tree shanking</p>
<p>7、编译阶段的不同</p>
<p>Vue.js 2.x</p>
<ul>
<li>通过标记静态节点，优化 diff 的过程</li>
</ul>
<p>vue.js 3.x</p>
<ul>
<li>标记和提升所有的静态节点，diff的时候<strong>只需要对比动态节点内容</strong></li>
<li><em>静态提升</em>(hoistStatic),当使用静态提升时，所有静态的节点都被提升到 render 方法之外。只会在应用启动的时候被创建一次，之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。</li>
<li>patch flag, 在动态标签末尾加上相应的标记，只能带 patchFlag 的节点才被认为是动态的元素，会被追踪属性的修改，能快速的找到动态节点，而<strong>不用逐个逐层遍历，提高了虚拟dom diff的性能</strong>。</li>
<li>缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数</li>
</ul>
<p>8、生命周期变化</p>
<ul>
<li>
<p>vue3.x 中可以继续使用 vue2.x 的生命周期钩子，但有俩个被更名；</p>
<pre><code class="hljs language-javascript" lang="javascript">beforeDestroy 修改成 beforeUnmount
destroyed 修改成 unmounted
</code></pre>
</li>
<li>
<p>vue3.x 生命周期钩子，与 vue2.x 中对应关系</p>


















































<table><thead><tr><th>vue2.x</th><th>vue3.x</th><th>解释</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup()</td><td>数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说<strong>不能访问到data、computed、watch、methods上的方法和数据</strong>。</td></tr><tr><td>created</td><td>setup()</td><td>实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时<strong>渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性</strong>。</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：<strong>编译模板</strong>，把data里面的数据和模板生成html。<strong>此时还没有挂载html到页面上</strong>。</td></tr><tr><td>mounted</td><td>onMounted</td><td>用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>响应式数据更新时调用，此时虽然响应式数据更新了，但是<strong>对应的真实 DOM 还没有被渲染</strong>。</td></tr><tr><td>updated</td><td>onUpdated</td><td>发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，<strong>该钩子在服务器端渲染期间不被调用</strong>。</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td><td>实例销毁之前调用。这一步，实例仍然完全可用，<strong><code>this</code> 仍能获取到实例</strong>。</td></tr><tr><td>unmounted</td><td>onUnmounted</td><td>实例销毁后调用，调用后，<strong>Vue 实例指示的所有东西都会解绑定</strong>，所有的事件监听器会被移除，所有的子实例也会被销毁。<strong>该钩子在服务器端渲染期间不被调用</strong></td></tr></tbody></table>
</li>
</ul>
<hr>
<h3 data-id="heading-3">组件的双向数据绑定</h3>
<ol>
<li>vue3.4 之前</li>
</ol>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">:value</span>=<span class="hljs-string">"props.modelValue"</span>
    @<span class="hljs-attr">input</span>=<span class="hljs-string">"emit('update:modelValue', $event.target.value)"</span>
  /&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>根据上面的基本写法，同理对于<strong>自定义组件</strong>而言，我们的写法如下：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">objRange</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"range"</span> /&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
    
<span class="hljs-keyword">const</span> range = <span class="hljs-title function_">ref</span>([])    
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- objRange --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { defineEmits, defineProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-comment">// v-model 默认绑定到 modelValue 属性</span>
  <span class="hljs-attr">modelValue</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> []
  }
})

<span class="hljs-comment">// 定义事件抛出 update:xxx 中的 xxx 是对应绑定的属性</span>
<span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])

<span class="hljs-comment">// 改变值</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeValue</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> newValue = [<span class="hljs-string">'GRP-90843'</span>]
  <span class="hljs-comment">// 将 update:xxx 事件抛出，实现数据双向绑定 </span>
  <span class="hljs-title function_">emits</span>(<span class="hljs-string">'update:modelValue'</span>, newValue)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<p><code>v-model</code> 默认是绑定到 <code>modelvalue</code> 属性上，我们也可以绑定到其他属性上，由此衍生这里可以衍生出<strong>多个属性的双向数据绑定</strong>，具体写法如下：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">objRange</span> <span class="hljs-attr">v-model:range</span>=<span class="hljs-string">"range"</span> <span class="hljs-attr">v-model:area</span>=<span class="hljs-string">"area"</span> /&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
    
<span class="hljs-keyword">const</span> range = <span class="hljs-title function_">ref</span>([])    
<span class="hljs-keyword">const</span> area = <span class="hljs-title function_">ref</span>([])
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- objRange --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { defineEmits, defineProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">range</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> []
  },
  <span class="hljs-attr">area</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> []
  }
})
<span class="hljs-comment">// 将对应的 update:xxx 抛出即可</span>
<span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:range'</span>, <span class="hljs-string">'update:area'</span>])
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<hr>
<h3 data-id="heading-4">Composition Api 与 Options Api 有什么不同</h3>
<p>1、代码组织</p>
<ul>
<li>Options Api  代码按照<strong>选项</strong>（data<code>、</code>methods<code>、</code>computed<code>、</code>watch）进行分组</li>
<li>Composition Api 代码按照<strong>逻辑功能</strong>进行分组</li>
</ul>
<p>2、逻辑复用</p>
<ul>
<li>Options Api  逻辑复用通常通过 <code>mixins</code> 来实现，但容易导致命名冲突和代码可读性下降。</li>
<li>Composition Api  逻辑复用通过自定义 Hook（类似于 React 的 Hooks）实现，可以将逻辑提取到独立的函数中，更灵活且易于维护。</li>
</ul>
<p>3、this 的使用</p>
<ul>
<li>Options Api 通过 <code>this</code> 访问组件实例的属性和方法</li>
<li>Composition API 在 <code>setup</code> 函数中没有 <code>this</code>，所有数据和函数都需要通过 <code>return</code> 暴露给模板</li>
</ul>
<hr>
<h3 data-id="heading-5">Vue中的$nextTick有什么作用</h3>
<p>Vue 的响应式系统是异步的。</p>
<p>当数据发生变化时，Vue 并不会立即更新 DOM，而是将更新操作推入一个队列，并在下一个事件循环中批量处理。</p>
<p>意味着，如果在数据变化后立即访问 DOM，可能会获取到未更新的 DOM 状态。</p>
<p><code>$nextTick</code> 提供了一种机制，确保在 DOM 更新完成后再执行代码。</p>
<hr>
<h3 data-id="heading-6">keep-alive 有什么作用</h3>
<p>1、keep-alive 是 vue 的内置组件，主要用来<strong>缓存动态组件</strong> 和<strong>路由组件</strong>的，避免组件在切换时被销毁和重新创建。</p>
<p>2、使用场景</p>
<ul>
<li>
<p>缓存路由组件</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;keep-alive&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/keep-alive&gt;
&lt;/template&gt;
</code></pre>
</li>
<li>
<p>缓存动态组件</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;keep-alive&gt;
    &lt;component :is="currentComponent"&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
<p>3、<code>&lt;keep-alive&gt;</code> 会触发两个额外的生命周期钩子</p>
<ul>
<li><strong><code>activated</code></strong>
当缓存的组件被激活时调用（即组件再次显示时）</li>
<li><strong><code>deactivated</code></strong>
当缓存的组件被停用时调用（即组件被隐藏时）</li>
</ul>
<p>4、<code>&lt;keep-alive&gt;</code> 支持以下属性</p>
<ul>
<li><code>include</code>：只有名称匹配的组件会被缓存。可以是字符串、正则表达式或数组</li>
<li><code>exclude</code>：名称匹配的组件不会被缓存。可以是字符串、正则表达式或数组</li>
</ul>
<p>5、缓存组件实例会占用内存，如果缓存过多组件，可能会导致内存占用过高。</p>
<hr>
<h3 data-id="heading-7">为什么data属性是一个函数而不是一个对象</h3>
<p>确保每个组件实例都有自己独立的数据副本，避免多个组件实例共享同一个数据对象，从而导致数据污染和状态混乱。</p>
<hr>
<h3 data-id="heading-8">watch、computed的区别</h3>
<ul>
<li>computed 作用：是通过多个变量计算得出一个变量的值（多对一）。并且 computed有缓存的功能。当多个变量值，没有发生改变时，直接在缓存中读取该值。不支持异步操作。</li>
<li>watch 作用：侦听一个变量，从而影响其他变量（一对多）。支持异步操作。</li>
</ul>
<hr>
<h3 data-id="heading-9">Vue 列表为什么要加 key</h3>
<p>Vue 使用虚拟 DOM 来优化渲染性能。当列表数据发生变化时，Vue 会通过对比新旧虚拟 DOM 来确定需要更新的部分。如果没有 <code>key</code>，Vue 会默认使用“就地复用”策略，即尽可能复用相同类型的元素，而不是重新创建或移动它们。</p>
<hr>
<h3 data-id="heading-10">MVVM是什么？和MVC有何区别呢？</h3>
<ul>
<li>Model(模型)：负责从数据库中取数据</li>
<li>View(视图)：负责展示数据的地方</li>
<li>Controller(控制器)：用户交互的地方，例如点击事件等等</li>
<li>VM： 视图模型</li>
</ul>
<p>在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性。VM 会自动将数据更新到页面中，而 MVC 需要手动操作 dom 将数据进行更新</p>
<hr>
<h3 data-id="heading-11">ref、unref、isRef 、toRef、toRefs、toRaw 区别</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 定义响应式变量</span>
<span class="hljs-keyword">const</span> name1 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'name1'</span>) 
<span class="hljs-comment">// 普通变量</span>
<span class="hljs-keyword">const</span> name2 = <span class="hljs-string">'name2'</span>
<span class="hljs-comment">// reactive 定义响应式变量</span>
<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'name3'</span> })

<span class="hljs-comment">// isRef 是判断变量是否为 ref</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isRef</span>(name1), <span class="hljs-title function_">isRef</span>(name2), <span class="hljs-title function_">isRef</span>(obj)) <span class="hljs-comment">// true false false</span>

<span class="hljs-comment">// unref 如果是 ref 返回其内部的值，反之返回参数本身</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unref</span>(name1), <span class="hljs-title function_">unref</span>(name2), <span class="hljs-title function_">unref</span>(obj)) <span class="hljs-comment">// name1 name2 { name: 'name3' }(参数本身)</span>

<span class="hljs-comment">// toRef 针对响应式数据的单一属性</span>
<span class="hljs-keyword">const</span> name3 = <span class="hljs-title function_">toref</span>(obj, <span class="hljs-string">'name'</span>)
<span class="hljs-comment">// 此时修改 name3；会影响到 obj.name</span>
<span class="hljs-comment">// 同理修改 obj.name；也会影响到 name3</span>

<span class="hljs-comment">// toRefs 针对响应式数据的所有属性</span>
<span class="hljs-comment">// 若使用下述代码，解构出来的属性是没有响应式的</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">name4</span>: name } = obj
<span class="hljs-comment">// 正确的解构应该是</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">name5</span>: name } = <span class="hljs-title function_">toRefs</span>(obj)
<span class="hljs-comment">// 此时修改 name5；会影响到 obj.name</span>
<span class="hljs-comment">// 同理修改 obj.name；也会影响到 name5</span>

<span class="hljs-comment">// toRefs 也可以用于解构 prop，确保解构出来的属性有响应式</span>
<span class="hljs-keyword">const</span> {} = prop


<span class="hljs-comment">// toRaw 可以返回 reactive、readonly、shallowReactive 创建的代理所对应的原始对象</span>
<span class="hljs-keyword">const</span> original = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }
<span class="hljs-keyword">const</span> reactiveData = <span class="hljs-title function_">reactive</span>(original)

<span class="hljs-keyword">const</span> rawData = <span class="hljs-title function_">toRaw</span>(reactiveData) <span class="hljs-comment">// 获取原始对象</span>

rawData.<span class="hljs-property">count</span> += <span class="hljs-number">10</span> <span class="hljs-comment">// ❌ 修改原始对象，不会触发更新</span>
</code></pre>
<hr>
<h3 data-id="heading-12">isProxy 、isReactive、isReadOnly 区别</h3>
<p>（很少用到）</p>
<ul>
<li>isProxy：检查对象是否是由reactive或readonly创建的代理。</li>
<li>isReactive：检查对象是否是reactive创建的，或者被包裹在一个readonly中的原始reactive代理。</li>
<li>isReadonly：检查对象是否是readonly创建的代理。</li>
</ul>

























<table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>作用</strong></th><th align="left"><strong>典型返回值场景</strong></th></tr></thead><tbody><tr><td align="left"><code>isProxy</code></td><td align="left">检测对象是否是 <strong>任意代理对象</strong>（由 <code>reactive</code> 或 <code>readonly</code> 创建）</td><td align="left"><code>reactive(obj)</code> → <code>true</code> <code>readonly(obj)</code> → <code>true</code> <code>普通对象</code> → <code>false</code></td></tr><tr><td align="left"><code>isReactive</code></td><td align="left">检测对象是否是 <strong>响应式代理</strong>（由 <code>reactive</code> 创建或被 <code>readonly</code> 包裹的响应式对象）</td><td align="left"><code>reactive(obj)</code> → <code>true</code> <code>readonly(reactive(obj))</code> → <code>true</code> <code>readonly(obj)</code> → <code>false</code></td></tr><tr><td align="left"><code>isReadonly</code></td><td align="left">检测对象是否是 <strong>只读代理</strong>（由 <code>readonly</code> 创建）</td><td align="left"><code>readonly(obj)</code> → <code>true</code> <code>reactive(obj)</code> → <code>false</code></td></tr></tbody></table>
<p>验证代码</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>原始对象: {{ rawObject }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>响应式对象: {{ reactiveObj }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>只读对象: {{ readonlyObj }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>只读包裹响应式对象: {{ readonlyReactiveObj }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { reactive, readonly, isProxy, isReactive, isReadonly } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 原始对象</span>
<span class="hljs-keyword">const</span> rawObject = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> }

<span class="hljs-comment">// 响应式对象</span>
<span class="hljs-keyword">const</span> reactiveObj = <span class="hljs-title function_">reactive</span>(rawObject)

<span class="hljs-comment">// 只读对象（直接包裹原始对象）</span>
<span class="hljs-keyword">const</span> readonlyObj = <span class="hljs-title function_">readonly</span>(rawObject)

<span class="hljs-comment">// 只读包裹响应式对象</span>
<span class="hljs-keyword">const</span> readonlyReactiveObj = <span class="hljs-title function_">readonly</span>(<span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> }))

<span class="hljs-comment">// 检测函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">check</span> = (<span class="hljs-params">obj, name</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`----- <span class="hljs-subst">${name}</span> -----`</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'isProxy:'</span>, <span class="hljs-title function_">isProxy</span>(obj))
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'isReactive:'</span>, <span class="hljs-title function_">isReactive</span>(obj))
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'isReadonly:'</span>, <span class="hljs-title function_">isReadonly</span>(obj))
}

<span class="hljs-comment">// 执行检测</span>
<span class="hljs-title function_">check</span>(rawObject, <span class="hljs-string">'原始对象'</span>)          <span class="hljs-comment">// 全部返回 false</span>
<span class="hljs-title function_">check</span>(reactiveObj, <span class="hljs-string">'响应式对象'</span>)       <span class="hljs-comment">// isProxy: true, isReactive: true, isReadonly: false</span>
<span class="hljs-title function_">check</span>(readonlyObj, <span class="hljs-string">'只读对象'</span>)         <span class="hljs-comment">// isProxy: true, isReactive: false, isReadonly: true</span>
<span class="hljs-title function_">check</span>(readonlyReactiveObj, <span class="hljs-string">'只读包裹响应式对象'</span>) 
<span class="hljs-comment">// isProxy: true, isReactive: true, isReadonly: true</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<hr>
<h3 data-id="heading-13">ref、 shallowRef、reactive、shallowReactive 区别</h3>

















<table><thead><tr><th>ref</th><th>shallowRef</th></tr></thead><tbody><tr><td>refValue.value.count++ // 触发更新</td><td>shallowRefValue.value.count++ // 不触发更新<br>shallowRefValue.value = newObj // 触发更新</td></tr><tr><td>内部值会被深度代理，修改嵌套属性会触发响应式更新</td><td>仅监听 <code>.value</code> 的引用变化，不会深度代理内部属性</td></tr></tbody></table>

















<table><thead><tr><th>reactive</th><th>shallowReactive</th></tr></thead><tbody><tr><td>reactiveObj.nested.count++ // 触发更新</td><td>shallowReactiveObj.nested.count++ // 不触发更新<br>shallowReactiveObj.nested = { count: 100 }</td></tr><tr><td>递归代理所有层级的属性，嵌套对象也会响应式</td><td>只代理对象的第一层属性，嵌套对象保持原始状态</td></tr></tbody></table>
<p><strong>验证代码</strong></p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>ref vs shallowRef<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ref: {{ refValue.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>shallowRef: {{ shallowRefValue.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeRefInner"</span>&gt;</span>修改 ref 内部属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeShallowRefInner"</span>&gt;</span>修改 shallowRef 内部属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeShallowRefValue"</span>&gt;</span>替换 shallowRef 整个值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>reactive vs shallowReactive<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>reactive.nested: {{ reactiveObj.nested.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>shallowReactive.nested: {{ shallowReactiveObj.nested.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeReactiveNested"</span>&gt;</span>修改 reactive 嵌套属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeShallowReactiveNested"</span>&gt;</span>修改 shallowReactive 嵌套属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeShallowReactiveValue"</span>&gt;</span>替换 shallowReactive 整个值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, shallowRef, reactive, shallowReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// ----------------------</span>
<span class="hljs-comment">// 1. ref vs shallowRef</span>
<span class="hljs-comment">// ----------------------</span>
<span class="hljs-keyword">const</span> refValue = <span class="hljs-title function_">ref</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }) <span class="hljs-comment">// 深层响应式</span>
<span class="hljs-keyword">const</span> shallowRefValue = <span class="hljs-title function_">shallowRef</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }) <span class="hljs-comment">// 仅监听 .value 变化</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeRefInner</span> = (<span class="hljs-params"></span>) =&gt; {
  refValue.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++ <span class="hljs-comment">// 触发更新</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeShallowRefInner</span> = (<span class="hljs-params"></span>) =&gt; {
  shallowRefValue.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++ <span class="hljs-comment">// ❌ 不会触发更新</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeShallowRefValue</span> = (<span class="hljs-params"></span>) =&gt; {
  shallowRefValue.<span class="hljs-property">value</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">100</span> } <span class="hljs-comment">// ✅ 触发更新</span>
}

<span class="hljs-comment">// ----------------------</span>
<span class="hljs-comment">// 2. reactive vs shallowReactive</span>
<span class="hljs-comment">// ----------------------</span>
<span class="hljs-keyword">const</span> reactiveObj = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> } <span class="hljs-comment">// 深层响应式</span>
})

<span class="hljs-keyword">const</span> shallowReactiveObj = <span class="hljs-title function_">shallowReactive</span>({
  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> } <span class="hljs-comment">// 仅顶层响应式</span>
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeReactiveNested</span> = (<span class="hljs-params"></span>) =&gt; {
  reactiveObj.<span class="hljs-property">nested</span>.<span class="hljs-property">count</span>++ <span class="hljs-comment">// ✅ 触发更新</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeShallowReactiveNested</span> = (<span class="hljs-params"></span>) =&gt; {
  shallowReactiveObj.<span class="hljs-property">nested</span>.<span class="hljs-property">count</span>++ <span class="hljs-comment">// ❌ 不会触发更新</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeShallowReactiveValue</span> = (<span class="hljs-params"></span>) =&gt; {
  shallowReactiveObj.<span class="hljs-property">nested</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> } <span class="hljs-comment">// ✅ 触发更新</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-14">defineProps 参数有哪些</h3>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineProps</span>({
    <span class="hljs-attr">theme</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-string">'dark'</span>,
        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">validator</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> [<span class="hljs-string">'dark'</span>, <span class="hljs-string">'light'</span>].<span class="hljs-title function_">includes</span>(value)
        }
    }
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>Suspense 是如何使用的</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 默认插槽：显示异步组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- fallback 插槽：加载中显示的内容 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 定义一个异步组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'./AsyncComponent.vue'</span>)
)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-15">v-slotted 选择器如何使用</h3>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child-component"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 定义插槽 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.child-component</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
}

<span class="hljs-comment">/* 选择插槽内带有.container 类的元素 */</span>
::<span class="hljs-built_in">v-slotted</span>(.container) {
  <span class="hljs-attribute">background-color</span>: lightyellow;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ffcc00</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 使用子组件并向插槽传递内容 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是插槽内.container 里的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是插槽内普通的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ChildComponent</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ChildComponent.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">ChildComponent</span>
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b75ac735b294908bb05fbef54968266~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bKB5pyI5Y-v6LS1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743402982&amp;x-signature=NSVHBwBv291KqJuuI096aqD%2BuJs%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-16">pina 和 vuex 在使用上有什么区别</h3>
<ul>
<li>pina 使用上更为简洁，基于 composition API；而 vuex 是基于 options API；</li>
<li>pina 天然模块化，每一个 store 都是独立的；而 vuex 需要手动划分；</li>
<li>pina 对 TS 的支持更为友好；vuex 需要额外配置</li>
<li>pina 体积更小；vuex 体积稍大</li>
<li>pina 允许直接修改状态，更为灵活；vue 需要通过 <code>mutations</code> 修改状态，更为严格</li>
</ul>
<h3 data-id="heading-17">localStorage 、cookie、sessionStorage 三者的区别</h3>
<ul>
<li>存储大小：Cookie 4k；Storage 5M；</li>
<li>有效期：Cookie 拥有有效期；localStorage 永久存储；sessionStorage 会话存储</li>
<li>Cookie 会发送到服务器端，存储在内存中；Storage 只会存储在浏览器端</li>
<li>路径：Cookie 有路径限制，Storage 只存储在域名下</li>
<li>API：Cookie 没有特定的 API；Storage 有对应的 API；</li>
</ul>
<h3 data-id="heading-18">数组去重方法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方法一</span>
<span class="hljs-keyword">const</span> arr1 = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(originalArr)]

<span class="hljs-comment">// 方法二（缺点 无法过滤 NaN） [NaN].indexOf(NaN) = -1</span>
<span class="hljs-keyword">const</span> arr2 = originalArr.<span class="hljs-title function_">fillter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> originalArr.<span class="hljs-title function_">indexof</span>(item) === index)

<span class="hljs-comment">// 方法三</span>
<span class="hljs-keyword">const</span> arr3 = originalArr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc.<span class="hljs-title function_">includes</span>(cur) ? acc : [...acc, cur], [])
</code></pre>
<h3 data-id="heading-19">对象拷贝方法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 浅拷贝</span>

<span class="hljs-comment">// 方法一 扩展运算符</span>
<span class="hljs-keyword">const</span> obj = { ... originalObj }

<span class="hljs-comment">// 方法二 Object.assign</span>
<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, originalObj)

<span class="hljs-comment">// 方法三 for in </span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> originalObj) {
    <span class="hljs-keyword">if</span> (originalObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
        obj[key] = originalObj[key]
    }
}

<span class="hljs-comment">// 深拷贝</span>

<span class="hljs-comment">// 方法一：缺点 无法拷贝函数</span>
<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(originalObj))

<span class="hljs-comment">// 方法二 递归</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">originalObj</span>) {
    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> originalObj != <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span> originalObj
    
    <span class="hljs-keyword">const</span> clone = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originalObj) ? [] : {}
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> originalObj) {
        <span class="hljs-keyword">if</span> (originalObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
            clone[key] = <span class="hljs-title function_">deepClone</span>(originalObj[key])
        }
    }
    
    <span class="hljs-keyword">return</span> clone
}
</code></pre>
<h3 data-id="heading-20">数组交集、并集、差集</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">let</span> arr3 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

<span class="hljs-comment">// 交集</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> arr3.<span class="hljs-title function_">includes</span>(item)))

<span class="hljs-comment">// 并集</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...arr2, ...arr3])))

<span class="hljs-comment">// arr2 差集</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !arr2.<span class="hljs-title function_">includes</span>(item)))

<span class="hljs-comment">// arr3 差集</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !arr3.<span class="hljs-title function_">includes</span>(item)))
</code></pre>
<h3 data-id="heading-21">数组扁平</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatter</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">if</span> (!arr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;
  
  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? [...pre, ...<span class="hljs-title function_">flatter</span>(cur)] : [...pre, cur]
  }, []);
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>]]]]]
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatter</span>(arr));
</code></pre>
<h3 data-id="heading-22">CSS 如何实现水平垂直方向居中</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 方法一 flex 布局 */</span> 
<span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
}


<span class="hljs-comment">/* 方法二 绝对定位 + transform */</span> 
<span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-selector-class">.child</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, <span class="hljs-number">50%</span>)
}


<span class="hljs-comment">/* 方法三 绝对定位 + margin */</span>
<span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-selector-class">.child</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">margin</span>: auto;
}

<span class="hljs-comment">/* 方法四 表格布局 */</span>
<span class="hljs-selector-class">.container</span> {
    disaply: table-cell;
    <span class="hljs-attribute">vertical-align</span>: middle;
    <span class="hljs-attribute">text-align</span>: center;
}

<span class="hljs-selector-class">.child</span> {
    <span class="hljs-attribute">display</span>: inline-block;
}
</code></pre>
<h3 data-id="heading-23">讲一下 let 和 const</h3>
<p>提出了 <strong>块级作用域</strong> 概念</p>
<p>1、什么是块级作用域：</p>
<ul>
<li>在该作用域外无法访问该变量</li>
</ul>
<p>2、块级作用域存在于：</p>
<ul>
<li>函数内部</li>
<li>块中(字符 { 和 } 之间的区域)</li>
</ul>
<p>3、let 和 const 特性</p>
<ul>
<li>
<p>变量不会被提升</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// Uncaught ReferenceError: value is not defined</span>
</code></pre>
</li>
<li>
<p>重复声明该变量会报错</p>
</li>
<li>
<p>不会绑定到全局作用域上</p>
</li>
</ul>
<p>4、临时性死区（TDZ）</p>
<p>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> value); <span class="hljs-comment">// Uncaught ReferenceError: value is not defined</span>
<span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;
</code></pre>
<h3 data-id="heading-24">介绍一下箭头函数</h3>
<ul>
<li>
<p>箭头函数没有 this 指向，需要通过作用域来确定 this 的值</p>
<blockquote>
<p><code>this</code> 绑定的就是最近一层非箭头函数的 <code>this</code></p>
<p>由于没有 this，因此 call，apply，bind 不能被使用</p>
<p>三者的区别：</p>
<ul>
<li>三者都可以绑定函数的 this 指向</li>
<li>三者第一个参数都是 this 要指向的对象，若该参数为 undefined 或 null，this则默认指向全局</li>
<li>传参不同：apply 是数组；call 是参数列表，而 bind 可以分多次传入，实现参数合并</li>
<li>call apply 是立即执行，bind 是返回绑定 this 之后的函数,如果这个新的函数作为构造函数被调用，那么 this 不再指向传入给 bind 的第一个参数，而是指向新生成的对象</li>
</ul>
</blockquote>
</li>
<li>
<p>箭头函数没有 arguments 对象</p>
</li>
<li>
<p>不能通过 new 关键字进行调用</p>
</li>
<li>
<p>没有原型</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; {};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// undefined</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-25">如何遍历对象</h3>
<p>可以查看另外一篇文章:<a href="https://juejin.cn/post/7470390096380444699" target="_blank" title="https://juejin.cn/post/7470390096380444699"> # 细究 ES6 中多种遍历对象键名方式的区别</a></p>
<p><code>for…of </code> 和 <code>for…in</code>的区别如下</p>
<ul>
<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结</strong></p>
<p>for...in 循环主要是为了遍历对象而生，不适用于遍历数组；</p>
<p>for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p></div></div>