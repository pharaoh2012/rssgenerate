
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18787027" title="发布于 2025-03-22 20:14">
    <span role="heading" aria-level="2">Mybatis-Plus知识点详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>Mybatis-plus(简称MP),基于Mybatis的增强工具,<strong>保留了Mybatis的所有功能,同时增加了通用的CRUD,条件构造器,分页插件等等实用工具</strong></p>
</blockquote>
<h1 id="特性">特性</h1>
<ul>
<li>即拿即用:通过通用Mapper和Service,无需编写XML既可以完成单表CURE操作</li>
<li>Lambda支持:使用Lambda表达式构建查询条件,避免硬编码字段名,提升代码安全性</li>
<li>更多的主键策略:支持多种主键生成方式,如雪花算法,自增等等</li>
<li>分页插件:内置分页插件,支持多种数据库,简化分页查询操作</li>
</ul>
<h2 id="与mybatis相比">与Mybatis相比</h2>
<ul>
<li>提供大量自动化功能,如通用的CRUD,条件构造器,分页支持极大减少操作代码,提高开发效率</li>
<li>Mybatis需手动编写SQL,编写XML文件和映射接口DAO</li>
</ul>
<h1 id="快速入门">快速入门</h1>
<h2 id="日志配置">日志配置</h2>
<ul>
<li>日志输出到标准输出流中</li>
</ul>
<pre><code class="language-yaml">mybatis-plus:
  # mapper配置文件
  mapper-locations: classpath:mapper/*.xml
  # resultType别名，没有这个配置resultType包名要写全，配置后只要写类名
  type-aliases-package: com.mashang.springboot04.domain
  //
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<h2 id="添加依赖与配置applicationyml">添加依赖与配置application.yml</h2>
<ul>
<li>本人使用<code>SpringBoot 2.7.18,JDK1.8</code>:导入的依赖如下</li>
</ul>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.3.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<ul>
<li>application.yml如下:</li>
</ul>
<pre><code class="language-yaml"># 也是springboot的配置文件，两个都可以用
server:
  port: 8080
  servlet:
    #配置根路径
    context-path: /
# 配置数据源
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/xiaomi_store?userSSL=false;serverTimezone=Asia/Shanghai
    username: root
    password: root
mybatis-plus:
  # mapper配置文件
  mapper-locations: classpath:mapper/*.xml
  # resultType别名，没有这个配置resultType包名要写全，配置后只要写类名
  type-aliases-package: com.mashang.springboot03.domain

</code></pre>
<h2 id="定义实体类与mapper接口">定义实体类与Mapper接口</h2>
<h3 id="实体类">实体类</h3>
<ul>
<li>在实体类上使用Mybatis-plus的注解</li>
<li><code>@TableName()</code>→指定数据库查询的表,不添加默认将类名改为下划线型数据库名</li>
<li><code>@TableId(name,type)</code>→用于给主键标记,name为数据库对应名,用于指定自增算法
<ul>
<li>雪花算法(Snowflake)是由Twitter开源的一种分布式ID生成算法.<strong>其核心思想是将64位的long型ID</strong>分为四个部分,分别为:符号位,时间戳,工作机器ID,序列号</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Data
@TableName("user")  // 指定数据库表名
public class User {
    @TableId(type = IdType.AUTO)  // 主键自增
    private Long id;
    private String name;
    private Integer age;
}
</code></pre>
<h3 id="mapper接口">Mapper接口</h3>
<ul>
<li>Mapper接口需继承<code>BaseMapper&lt;T&gt;</code>类,则此接口即可获得所有基本的CRUD方法</li>
</ul>
<pre><code class="language-java">public interface UserMapper extends BaseMapper&lt;User&gt; {
    // 如果需要扩展自定义方法，也可以在此添加
}
</code></pre>
<h2 id="service层与service实现层">Service层与Service实现层</h2>
<blockquote>
<p>MP也提供了<strong>IService接口和ServiceImpl类</strong>方便在Service层使用封装好的CRUD方法</p>
</blockquote>
<h3 id="service层">Service层</h3>
<ul>
<li><strong>extends(继承)IService<t>接口</t></strong></li>
</ul>
<pre><code class="language-java">public interface UserService extends IService&lt;User&gt; {
    // 可以在此定义更多业务方法
}
</code></pre>
<h3 id="serviceimpl层">ServiceImpl层</h3>
<ul>
<li><strong>继承 <code>ServiceImpl&lt;UserMapper, User&gt;</code> 和实现 <code>IService&lt;User&gt;</code> 接口,</strong>可以直接调用封装好的 CRUD 方法</li>
</ul>
<pre><code class="language-java">@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {
    // 继承了 ServiceImpl 后，已拥有 BaseMapper 中所有的 CRUD 方法
}
</code></pre>
<h2 id="basemapper接口中常用的crud方法">BaseMapper<t>接口中常用的CRUD方法</t></h2>
<ul>
<li>即Mapper层中的常见方法,已经集成好了,直接操作数据库的原子性方法</li>
</ul>
<h3 id="插入操作">插入操作</h3>
<pre><code class="language-java">// 插入一条记录
int insert(T entity);
</code></pre>
<h3 id="查询操作">查询操作</h3>
<pre><code class="language-java">// 根据 ID 查询
T selectById(Serializable id);
// 根据 entity 条件，查询一条记录
T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

// 查询（根据ID 批量查询）
List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);
// 根据 entity 条件，查询全部记录
List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
// 查询（根据 columnMap 条件）
List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);
// 根据 Wrapper 条件，查询全部记录
List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值
List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

// 根据 entity 条件，查询全部记录（并翻页）
IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
// 根据 Wrapper 条件，查询全部记录（并翻页）
IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
// 根据 Wrapper 条件，查询总记录数
Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
</code></pre>
<h3 id="删除操作">删除操作</h3>
<pre><code class="language-java">// 根据 entity 条件，删除记录
int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);
// 删除（根据ID 批量删除）
int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);
// 根据 ID 删除
int deleteById(Serializable id);
// 根据 columnMap 条件，删除记录
int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);
</code></pre>
<h3 id="更新操作">更新操作</h3>
<pre><code class="language-java">// 根据 whereWrapper 条件，更新记录
int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);
// 根据 ID 修改
int updateById(@Param(Constants.ENTITY) T entity);
</code></pre>
<h2 id="iservice接口中的常用方法">IService<t>接口中的常用方法</t></h2>
<ul>
<li>即service层常见方法,业务逻辑层,可组合多个 Mapper 方法,添加事务等</li>
</ul>
<h3 id="插入操作save">插入操作(save)</h3>
<pre><code class="language-java">// 插入一条记录（选择字段，策略插入）
boolean save(T entity);
// 插入（批量）
boolean saveBatch(Collection&lt;T&gt; entityList);
// 插入（批量）
boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);
</code></pre>
<h3 id="存在更新不存在插入saveorupdate">存在更新,不存在插入(saveOrUpdate)</h3>
<ul>
<li><code>boolean saveOrUpdate(T entity);</code>:根据@TableId标识的主键判断,若主键不存在→执行<code>INSERT</code>,若主键存在→执行<code>UPDATE</code></li>
<li><code>boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);</code>:先根据updateWrapper尝试进行更新操作,若影响行数为0,则回退到<code>saveOrUpdate(T entity)</code>逻辑(根据主键判断是否更新或插入)</li>
<li><strong><code>saveOrUpdateBatch(Collection&lt;T&gt;entityList)</code>&nbsp;和&nbsp;<code>saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize)</code>:</strong>批量处理集合中的实体，逻与&nbsp;<code>saveOrUpdate(T)</code>&nbsp;一致</li>
</ul>
<h3 id="删除操作remove">删除操作(Remove)</h3>
<blockquote>
<p><strong>可配合</strong><code>@TableLogic</code>实现逻辑删除</p>
</blockquote>
<pre><code class="language-java">// 根据 Wrapper 构造的条件删除记录 支持复杂条件
boolean remove(Wrapper&lt;T&gt; queryWrapper);
// 根据 ID 删除
boolean removeById(Serializable id);
//根据 columnMap 中的字段值匹配删除记录 仅支持等值条件,
boolean removeByMap(Map&lt;String, Object&gt; columnMap);
// 删除（根据ID 批量删除）
boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);
</code></pre>
<h3 id="更新操作update">更新操作(Update)</h3>
<blockquote>
<p><strong>必须设置&nbsp;<code>SET</code>&nbsp;字段,</strong>如果未调用&nbsp;<code>.set()</code>，SQL会缺少更新内容导致错误</p>
</blockquote>
<pre><code class="language-java">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset
boolean update(Wrapper&lt;T&gt; updateWrapper);
// 根据 whereWrapper 条件，更新记录
boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);
// 根据 ID 选择修改
boolean updateById(T entity);
// 根据ID 批量更新
boolean updateBatchById(Collection&lt;T&gt; entityList);
// 根据ID 批量更新
boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);
</code></pre>
<h3 id="查询单个对象getone">查询单个对象(getOne)</h3>
<blockquote>
<p>若实体类配置了&nbsp;<code>@TableLogic</code>，查询时会自动过滤已删除数<code>deleted = 0</code></p>
</blockquote>
<pre><code class="language-java">// 根据 ID 查询
T getById(Serializable id);

// 根据 Wrapper，查询一条记录,结果集，如果是多个会抛出异常, 随机取一条加上限制条件 wrapper.last("LIMIT 1")
T getOne(Wrapper&lt;T&gt; queryWrapper);

// 根据 Wrapper，查询一条记录,可控制是否在结果不唯一时抛出异常
//不抛出异常，返回第一条记录
T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);

// 根据 Wrapper，查询一条记录
Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);

// 根据 Wrapper，查询一条记录
&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);
</code></pre>
<h3 id="查询列表list">查询列表(list)</h3>
<pre><code class="language-java">// 查询所有
List&lt;T&gt; list();

// 查询列表
List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);

// 查询（根据ID 批量查询）
Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);

// 查询（根据 columnMap 条件）
Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);

// 查询所有列表
List&lt;Map&lt;String, Object&gt;&gt; listMaps();

// 查询列表
List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);

// 查询全部记录
List&lt;Object&gt; listObjs();

// 查询全部记录
&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);

// 根据 Wrapper 条件，查询全部记录
List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);

// 根据 Wrapper 条件，查询全部记录
&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);
</code></pre>
<h3 id="分页查询page">分页查询(page)</h3>
<ul>
<li>
<p>分页对象<strong>Page<t>类</t></strong></p>
<ul>
<li>主要属性:
<ul>
<li><code>current</code>:当前页码,从 1 开始</li>
<li><code>size</code>:每页显示的记录数</li>
<li><code>searchCount</code>:是否执行&nbsp;<code>SELECT COUNT(*)</code>&nbsp;查询总记录数,不统计总数适用于大数据量场景</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Page&lt;User&gt; pageParam = new Page&lt;&gt;(1, 10);
LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.gt(User::getAge, 25)
       .orderByDesc(User::getCreateTime);

IPage&lt;User&gt; userPage = userService.page(pageParam, wrapper);
</code></pre>
</li>
</ul>
<pre><code class="language-java">// 无条件分页查询
IPage&lt;T&gt; page(IPage&lt;T&gt; page);
// 条件分页查询
IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);
// 无条件分页查询
IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);
// 条件分页查询
IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);
</code></pre>
<h3 id="查询记录数count">查询记录数(count)</h3>
<pre><code class="language-java">// 查询总记录数
int count();
// 根据 Wrapper 条件，查询总记录数
int count(Wrapper&lt;T&gt; queryWrapper);
</code></pre>
<pre><code class="language-java">// 统计年龄大于25且状态为激活的用户数量
LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.gt(User::getAge, 25)
       .eq(User::getStatus, 1);

int count = userService.count(wrapper);
</code></pre>
<h2 id="条件构造器">条件构造器</h2>
<ul>
<li>条件构造器<strong>用于动态生成SQL中的WHERE条件</strong>,替代手动拼接SQL语句,MP中提供了两种主要的条件构造器:QueryWrapper与LambdaQueryWrapper
<ul>
<li>QueryWrapper:基于字符串名的条件构造器,写法直观,但存在字段拼写错误的风险</li>
<li>LambdaQuertWrapped:基于Lambda表达式的构造器,避免了硬编码字段,更加推荐使用</li>
</ul>
</li>
</ul>
<h3 id="常用方法">常用方法</h3>
<h3 id="等于eq">等于.eq()</h3>
<ul>
<li>
<p>用于生成<code>字段＝值</code>的条件</p>
<ul>
<li>使用字符串</li>
</ul>
<pre><code class="language-java">new QueryWrapper&lt;User&gt;().eq("age", 25); // 生成 SQL: WHERE age = 25

</code></pre>
<ul>
<li>使用Lambda表达式</li>
</ul>
<pre><code class="language-java">new LambdaQueryWrapper&lt;User&gt;().eq(User::getAge, 25);
</code></pre>
</li>
</ul>
<h3 id="不等于nq">不等于.nq()</h3>
<ul>
<li>生成<code>字段&lt;&gt;值</code>条件</li>
</ul>
<pre><code class="language-java">new LambdaQueryWrapper&lt;User&gt;().ne(User::getStatus, 0); // SQL: WHERE status &lt;&gt; 0
</code></pre>
<h3 id="模糊查询like">模糊查询.like()</h3>
<ul>
<li>
<p>生成<code>字段LIKE ‘%值%’</code>条件</p>
<pre><code class="language-java"> new LambdaQueryWrapper&lt;User&gt;().like(User::getName, "张"); // SQL: WHERE name LIKE '%张%'
</code></pre>
</li>
</ul>
<h3 id="逻辑连接or与and">逻辑连接or()与and()</h3>
<ul>
<li>or():一般用法</li>
</ul>
<pre><code class="language-java">new LambdaQueryWrapper&lt;User&gt;()
    .eq(User::getAge, 25)
    .or()
    .eq(User::getName, "张三");
// 生成 SQL: WHERE age = 25 OR name = '张三'
</code></pre>
<ul>
<li>嵌套用法</li>
</ul>
<pre><code class="language-java">new LambdaQueryWrapper&lt;User&gt;()
    .or(wrapper -&gt; wrapper
        .eq(User::getAge, 25)
        .ne(User::getStatus, 0)
    );
// 生成 SQL: OR (age = 25 AND status &lt;&gt; 0)
</code></pre>
<ul>
<li>and():作用是拼接多个条件,用 AND 连接默认条件连接就是 AND,一般无需显式调用</li>
</ul>
<h3 id="动态查询">动态查询</h3>
<ul>
<li>在查询条件前加上布尔判断,true则执行</li>
</ul>
<pre><code class="language-java">new LambdaQueryWrapper&lt;User&gt;()
    .eq(age != null, User::getAge, age) // 当 age 不为 null 时生效
    .like(StringUtils.isNotBlank(name), User::getName, name); // 当 name 非空时生效
</code></pre>
<h2 id="分页查询">分页查询</h2>
<ul>
<li>
<p>MP中内置了分页插件,使用Page对象来封装分页参数和结果</p>
</li>
<li>
<p>在Springboot中通过配置类启动分页插件</p>
<ul>
<li>启用 MyBatis-Plus 的分页功能,使得在查询时可以直接使用分页方法</li>
</ul>
<pre><code class="language-java">@Configuration
public class MyBatisPlusConfig {
    // MybatisPlus的配置
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 在拦截器中加入了一个分页的拦截器
        // 指定数据库类型为 MySQL
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
</code></pre>
<pre><code class="language-java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.gt(User::getAge, 20);
Page&lt;User&gt; pageParam = new Page&lt;&gt;(1, 10);
IPage&lt;User&gt; userPage = userService.page(pageParam, wrapper);
</code></pre>
</li>
</ul>
<h1 id="进阶操作">进阶操作</h1>
<h2 id="敏感字段屏蔽">敏感字段屏蔽</h2>
<ul>
<li>某些字段直接发给前端会被用户恶意使用,导致安全隐患.有些字段(如日志字段,update_time,内部状态等等)对前端并无必要,过滤这些可以减少网络数据量,提高性能</li>
</ul>
<h3 id="方案一手动赋值">方案一:手动赋值</h3>
<ul>
<li>手动创建VO对象,并逐字赋值</li>
</ul>
<pre><code class="language-java">List&lt;StudentVo&gt; studentVos = new ArrayList&lt;&gt;();
for (Student s : students) {
    StudentVo vo = new StudentVo();
    vo.setName(s.getName());
    vo.setClassId(s.getClassId());
    // 其它字段也需手动赋值
    studentVos.add(vo);
}
</code></pre>
<ul>
<li>优点:可控,不存在反射性能开销</li>
<li>缺点:当字段过多时,代码冗长,维护成本高,若实体类改变,需要改变多个地方</li>
</ul>
<h3 id="方案二beanutilscopyproperties">方案二:BeanUtils.copyProperties</h3>
<ul>
<li>实现方法:利用反射机制自动复制同名属性</li>
</ul>
<pre><code class="language-java">List&lt;StudentVo&gt; studentVos = new ArrayList&lt;&gt;();
for (Student s : students) {
    StudentVo vo = new StudentVo();
		BeanUtils.copyProperties(student, vo);
    studentVos.add(vo);
}
</code></pre>
<ul>
<li>优点:代码简洁,快速复制</li>
<li>缺点:反射操作性能慢,约为手动复制的10倍,缺乏灵活性</li>
</ul>
<h3 id="方案三mapstruct-推荐"><strong>方案三:MapStruct 推荐</strong></h3>
<ul>
<li>
<p>导入MapStruct依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
    &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;
    &lt;version&gt;1.4.2.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;
    &lt;version&gt;1.4.2.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p><strong>建一个专门用于映射的文件夹mapping,编写映射接口,利用MapStruct在编译阶段自动生成高效映射代码</strong></p>
</li>
</ul>
<pre><code class="language-java">@Mapper//注意mapper注解不要引错了,要引入mapstruct包下的
public interface StudentMapping {
    StudentMapping INSTANCE = Mappers.getMapper(StudentMapping.class);
    StudentVo toStudentVo(Student student);
    List&lt;StudentVo&gt; toStudentVoList(List&lt;Student&gt; list);
}
</code></pre>
<pre><code class="language-java">//使用方法如下:
List&lt;StudentVo&gt; vos = StudentMapping.INSTANCE.toStudentVoList(students);
</code></pre>
<ul>
<li>优点:性能高,生成的代码类似于手动赋值,运行时没有反射开销,灵活性高</li>
</ul>
<h2 id="联表分页查询">联表分页查询</h2>
<ul>
<li>假设需要查询主表数据(如商品),及其关联的子表数据(如评论),支持分页和条件过滤.以商品(<strong>主表</strong>)和评论(<strong>子表</strong>)为例</li>
</ul>
<h3 id="集中式">集中式</h3>
<ul>
<li>
<p>核心逻辑是提供JOIN查询主表和子数据,在单次SQL中完成所有数据的获取</p>
</li>
<li>
<p>代码实例</p>
<ul>
<li>mapper.xml</li>
</ul>
<pre><code class="language-xml">&lt;!-- 商品和评论联表查询 --&gt;
&lt;select id="selectProductWithComments" resultMap="productWithCommentsMap"&gt;
    SELECT 
        p.id, 
        p.name, 
        p.price,
        c.id AS comment_id,
        c.content,
        c.user_id
    FROM product p
    LEFT JOIN comment c ON p.id = c.product_id
    ${ew.customSqlSegment}  &lt;!-- 动态条件 --&gt;
&lt;/select&gt;

&lt;!-- 结果映射 --&gt;
&lt;resultMap id="productWithCommentsMap" type="ProductVO"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;result property="price" column="price"/&gt;
    
    &lt;collection property="comments" ofType="Comment"&gt;
        &lt;id property="id" column="comment_id"/&gt;
        &lt;result property="content" column="content"/&gt;
        &lt;result property="userId" column="user_id"/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<ul>
<li>核心点:
<ul>
<li>
<p>使用<collection>处理一对多的关系,将子表数据映射为集合</collection></p>
</li>
<li>
<p><code>${ew.customSqlSegment}</code></p>
<ul>
<li>其是MP中用于<strong>动态拼接的特殊占位符</strong>,将<code>QueryWrapper</code>或<code>LambdaQueryWrapper</code>中定义的查询条件如(<code>eq,like,between</code>),转换为合法的Sql片段,并插入到XML映射文件的SQL语句中</li>
<li>mapper接口定义</li>
</ul>
<pre><code class="language-java">// 方法参数中必须声明 @Param(Constants.WRAPPER)
Page&lt;ProductVO&gt; selectPage(
    @Param("page") Page&lt;ProductVO&gt; page, 
    @Param(Constants.WRAPPER) Wrapper&lt;ProductVO&gt; wrapper // 关键参数
);
</code></pre>
<ul>
<li>XML的使用</li>
</ul>
<pre><code class="language-xml">&lt;select id="selectPage" resultMap="productMap"&gt;
    SELECT * FROM product
    ${ew.customSqlSegment}  &lt;!-- 动态插入 WHERE 条件 --&gt;
&lt;/select&gt;
</code></pre>
<ul>
<li>核心机制
<ul>
<li>ew是Wrapper的别名,对应Mapper接口方法中的<code>@Param(Constans.WRAPPER)</code>参数</li>
<li>当调用<code>wrapper.eq(”name”,”张三”)</code>时,会自动赋值为<code>WHERE name= ‘张三’如WHERE name = '手机'</code>需直接拼接,不能作为预编译参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分布式嵌套查询">分布式(嵌套查询)</h3>
<ul>
<li>分为两次查询:1.分页查询主表()商品表,2.子查询:<strong>根据主表id批量查询关联的子表数据(评论表)</strong></li>
<li>代码实例</li>
</ul>
<pre><code class="language-xml">&lt;!-- 主查询 --&gt;
&lt;select id="selectProductPage" resultMap="productPageMap"&gt;
    SELECT id, name, price FROM product
    ${ew.customSqlSegment}  &lt;!-- 动态条件 --&gt;
&lt;/select&gt;

&lt;!-- 嵌套子查询 根据商品ID查评论 --&gt;
&lt;select id="selectCommentsByProductIds" resultType="Comment"&gt;
    SELECT id, content, user_id, product_id 
    FROM comment 
    WHERE product_id IN 
    &lt;foreach collection="productIds" item="id" open="(" separator="," close=")"&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/select&gt;

&lt;!-- 结果映射 --&gt;
&lt;resultMap id="productPageMap" type="ProductVO"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;result property="price" column="price"/&gt;
    &lt;collection 
        property="comments" 
        ofType="Comment"
        select="selectCommentsByProductIds"  &lt;!-- 关联子查询方法 --&gt;
        column="{productIds=id}"             &lt;!-- 传递参数 --&gt;
    /&gt;
&lt;/resultMap&gt;
</code></pre>
<h2 id="字段填充">字段填充</h2>
<ul>
<li>再更新或者新增行时,通常需要添加一些属性如创建时间,更新时间,操作人员,MP提供了一种方法自动化处理填充</li>
</ul>
<h3 id="代码层面的实现">代码层面的实现</h3>
<ol>
<li>
<p>再实体类中标记需要填充的字段</p>
<ol>
<li>使用<code>@TableFiled</code>主键的<code>fill</code>属性指定填充策略</li>
</ol>
<pre><code class="language-java">@Data
public class Orders implements Serializable {
    private static final long serialVersionUID = -29854105041572661L;

    @TableId(type = IdType.ASSIGN_ID)
    private Long orderId;

    private String orderNum;

    private Integer userId;

    @TableField(fill = FieldFill.INSERT)
    private Date orderTime;
    /**
     * 创建者
     */
    @TableField(fill = FieldFill.INSERT)
    private String createBy;
    /**
     * 创建时间
     */
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    /**
     * 更新者
     */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private String updateBy;
    /**
     * 更新时间
     */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
    /**
     * 备注
     */
    private String remark;

}
</code></pre>
<p>b. 实现MetaObjectHandler接口</p>
<pre><code class="language-java">@Slf4j
@Component
public class FieldHandler implements MetaObjectHandler {
    // 在插入数据时，自动填充createTime和createBy字段
    @Override
    public void insertFill(MetaObject metaObject) {

        log.info("start insert fill...");
        // 设置createTime字段的值为当前时间
        this.setFieldValByName("createTime", new Date(), metaObject);

        // 设置createBy字段的值为admin
        this.setFieldValByName("createBy", "admin", metaObject);

        // 设置orderTime字段的值为当前时间
        this.setFieldValByName("orderTime", new Date(), metaObject);

        // 设置updateTime字段的值为当前时间
        this.setFieldValByName("updateTime", new Date(), metaObject);

        // 设置updateBy字段的值为admin
        this.setFieldValByName("updateBy", "admin", metaObject);
    }

    // 在更新数据时，自动填充updateTime和updateBy字段
    @Override
    public void updateFill(MetaObject metaObject) {

        log.info("start update fill...");
        // 设置updateTime字段的值为当前时间
        this.setFieldValByName("updateTime", new Date(), metaObject);

        // 设置updateBy字段的值为admin
        this.setFieldValByName("updateBy", "admin", metaObject);
    }
}

</code></pre>
</li>
</ol>
<h2 id="逻辑删除">逻辑删除</h2>
<ul>
<li>数据“删除”后仍保留在数据库中,通过标记is_deleted字段过滤,在实体类中使用 <code>@TableLogic</code> 注解</li>
<li>避免误删导致数据永久丢失,防止删除主表数据后,关联的子表数据失效(如用户删除后,历史订单需保留)</li>
</ul>
<pre><code class="language-java">public class User {
    @TableLogic
    private Integer deleted; // 1 表示删除，0 表示未删除
}

</code></pre>
<ul>
<li>当执行删除操作时,实际是在执行update操作</li>
</ul>
<pre><code class="language-java">userMapper.deleteById(1); 
//实际执行
 UPDATE user SET is_deleted = 1 WHERE id = 1;
</code></pre>
<ul>
<li>查询操作通过is_deteted过滤</li>
</ul>
<pre><code class="language-java">List&lt;User&gt; list = userMapper.selectList(null);
//实际执行
SELECT * FROM user WHERE is_deleted = 0;
</code></pre>
<h2 id="乐观锁">乐观锁</h2>
<ul>
<li><strong>通过版本号(如Vesion字段)或时间戳,再数据提交时检查是否发生并非冲突,若冲突则拒绝操作,</strong>提示重试或回滚,先操作,提交时再检查冲突,使用于低并发</li>
</ul>
<h3 id="mp实现乐观锁">MP实现乐观锁</h3>
<ul>
<li>在实体类中添加版本号,并使用@Version注解标记</li>
</ul>
<pre><code class="language-java">public class Product {
    private Long id;
    private String name;
    
    @Version  // 版本号字段（MP自动管理）
    private Integer version;
}
</code></pre>
<ul>
<li>在配置类中添加乐观锁插件</li>
</ul>
<pre><code class="language-java">@EnableTransactionManagement
public class MPConfig {

    // 创建MybatisPlusInterceptor对象
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {

        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 添加分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        // 添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
}
</code></pre>
<blockquote>
<p><strong>当存在多线程的修改操作时,MP会通过SQL语句检查version版本是否一致</strong>,如查询商品时version为1,提交完修改时MP执行<code>UPDATE product SET name='新名字', version=2 WHERE id=1 AND version=1;</code>,若存在另一个线程抢先修改,则version变为2,你的更新就会失效</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5390157780844907" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-22 20:14">2025-03-22 20:14</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">60</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18787027" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18787027);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18787027', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18787027', title: 'Mybatis-Plus知识点详解' })">举报</a>
</div>
        