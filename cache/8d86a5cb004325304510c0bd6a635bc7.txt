
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wherewhere/p/18770443" title="发布于 2025-03-13 18:44">
    <span role="heading" aria-level="2">【UAP】使用 .NET Core App 编写 UAP</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        众所周知，2024年9月微软正式宣布了 .NET Core App 的 UWP 支持，至此我们终于可以在新版 csproj 用 .NET 8 及以上编写 UWP 了，那么我们可不可以通过修改清单的方式来让 UWP 变成 UAP 呢？
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>众所周知，2024年9月微软正式宣布了 .NET Core App 的 UWP 支持，至此我们终于可以在新版 csproj 用 .NET 8 及以上编写 UWP 了，那么我们可不可以通过修改清单的方式来让 UWP 变成 UAP 呢？</p>
<p><img src="https://img2024.cnblogs.com/blog/2662465/202503/2662465-20250313182540184-1607140402.png"></p>
<p>UWP 和 UAP 使用的是同一套 WinRT API ，Windows 区分 UAP 和 UWP 的方式是看清单，只要是用 UAP 的清单就会仿真成 Win8.1 模式，于是我们只需要将清单变成 UAP 的样子就行了。所以首先我们新建一个 .NET 9 Native AOT 的 UWP 项目</p>
<p><img src="https://img2024.cnblogs.com/blog/2662465/202503/2662465-20250313175331510-101384388.png"></p>
<p>然后我们修改清单，Win8 App 清单如下，内容按需填写，Win8.1 App 的清单可以通过在 Github 搜索<code>OSMaxVersionTested language:XML</code>找到，<code>6.2</code>是 Win8，<code>6.3</code>是 Win8.1 (<code>$targetentrypoint$</code>需配合<code> ApplicationEntryPoint</code>使用)</p>
<pre class="language-xml highlighter-hljs"><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;Package xmlns="http://schemas.microsoft.com/appx/2010/manifest"&gt;

  &lt;Identity
    Name="wherewhere.CoreAppUAP"
    Publisher="CN=where"
    Version="0.0.1.0" /&gt;

  &lt;Properties&gt;
    &lt;DisplayName&gt;CoreAppUAP&lt;/DisplayName&gt;
    &lt;PublisherDisplayName&gt;wherewhere&lt;/PublisherDisplayName&gt;
    &lt;Logo&gt;Assets\StoreLogo.png&lt;/Logo&gt;
  &lt;/Properties&gt;

  &lt;Prerequisites&gt;
    &lt;OSMinVersion&gt;6.2.0&lt;/OSMinVersion&gt;
    &lt;OSMaxVersionTested&gt;6.3.0&lt;/OSMaxVersionTested&gt;
  &lt;/Prerequisites&gt;

  &lt;Resources&gt;
    &lt;Resource Language="x-generate"/&gt;
  &lt;/Resources&gt;

  &lt;Applications&gt;
    &lt;Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="$targetentrypoint$"&gt;
      &lt;VisualElements
        DisplayName="CoreAppUAP"
        Logo="Assets\MediumTile.png"
        SmallLogo="Assets\AppIcon.png"
        Description="CoreAppUAP"
        ForegroundText="light"
        BackgroundColor="transparent"&gt;
        &lt;DefaultTile WideLogo="Assets\WideTile.png"/&gt;
        &lt;SplashScreen Image="Assets\SplashScreen.png"/&gt;
        &lt;InitialRotationPreference&gt;
          &lt;Rotation Preference="landscape"/&gt;
          &lt;Rotation Preference="portrait"/&gt;
          &lt;Rotation Preference="landscapeFlipped"/&gt;
          &lt;Rotation Preference="portraitFlipped"/&gt;
        &lt;/InitialRotationPreference&gt;
        &lt;LockScreen Notification="badgeAndTileText" BadgeLogo="Assets\BadgeLogo.png"/&gt;
      &lt;/VisualElements&gt;
    &lt;/Application&gt;
  &lt;/Applications&gt;

  &lt;Capabilities&gt;
    &lt;Capability Name="internetClient" /&gt;
  &lt;/Capabilities&gt;
&lt;/Package&gt;</code></pre>
<p>然后我们在<code>csproj</code>中添加以下内容来取消引用<code>VC++</code>和<code>TargetDeviceFamily</code></p>
<pre class="language-xml highlighter-hljs"><code>&lt;PropertyGroup&gt;
  &lt;AddMicrosoftVCLibsSDKReference&gt;False&lt;/AddMicrosoftVCLibsSDKReference&gt;
  &lt;EnableAppxWindowsUniversalTargetDeviceFamilyItem&gt;False&lt;/EnableAppxWindowsUniversalTargetDeviceFamilyItem&gt;
&lt;/PropertyGroup&gt;</code></pre>
<p>不过删除了这些引用仍然会在清单生成<code>Dependencies</code>标签，如果<code>Dependencies</code>是空的注册时会报错，所以我们需要添加任务来删除清单中的<code>Dependencies</code>元素</p>
<pre class="language-xml highlighter-hljs"><code>&lt;UsingTask
  TaskName="RemoveDependencies"
  TaskFactory="CodeTaskFactory"
  AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"&gt;
  &lt;ParameterGroup&gt;
    &lt;AppxManifestPath ParameterType="System.String" Required="true" /&gt;
  &lt;/ParameterGroup&gt;
  &lt;Task&gt;
    &lt;Reference Include="System.Xml" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Using Namespace="System.Linq" /&gt;
    &lt;Using Namespace="System.Xml.Linq" /&gt;
    &lt;Code Type="Fragment" Language="cs"&gt;
      &lt;![CDATA[
          try
          {
              var xdoc = XDocument.Load(AppxManifestPath);
              var ns = xdoc.Root.Name.Namespace;
              var dependencies = xdoc.Root.Descendants(ns + "Dependencies");
              if (dependencies != null)
              {
                  foreach (var node in dependencies.ToArray())
                  {
                      if (!node.HasElements)
                      {
                          node.Remove();
                      }
                  }
              }
              xdoc.Save(AppxManifestPath);
          }
          catch
          {
              Log.LogError("Failed to load Appx Manifest.");
              _Success = false;
          }
      ]]&gt;
    &lt;/Code&gt;
  &lt;/Task&gt;
&lt;/UsingTask&gt;

&lt;Target
  Name="RemoveDependencies"
  AfterTargets="AfterGenerateAppxManifest"&gt;
  &lt;Message Importance="high" Text="RemoveDependencies" /&gt;
  &lt;RemoveDependencies AppxManifestPath="%(FinalAppxManifest.Identity)" /&gt;
&lt;/Target&gt;</code></pre>
<p>由于 XAML 编译器编译<code>App.xaml</code>时生成的入口点会使用<code>DispatcherQueueSynchronizationContext</code>来注册线程上下文，这是<code>16299</code>才加入的 API，UAP 在获取<code>DispatcherQueue</code>时会返回<code>null</code>，所以我们需要手动生成入口点和注册线程上下文</p>
<p>首先我们需要添加<code>DISABLE_XAML_GENERATED_MAIN</code>来注释自动生成的入口点</p>
<pre class="language-xml highlighter-hljs"><code>&lt;DefineConstants&gt;$(DefineConstants);DISABLE_XAML_GENERATED_MAIN&lt;/DefineConstants&gt;</code></pre>
<p>然后手动编写程序入口点</p>
<pre class="language-csharp highlighter-hljs"><code>public static class Program
{
    public static void Main(string[] args) =&gt; Application.Start(static p =&gt; _ = new App());
}</code></pre>
<p>接着我们需要手动创建一个使用<code>CoreDispatcher</code>的线程上下文</p>
<pre class="language-csharp highlighter-hljs"><code>/// &lt;summary&gt;
/// Provides a synchronization context for &lt;see cref="CoreDispatcher"/&gt;.
/// &lt;/summary&gt;
/// &lt;param name="dispatcher"&gt;The &lt;see cref="CoreDispatcher"/&gt; to associate this &lt;see cref="CoreDispatcherSynchronizationContext"/&gt; with.&lt;/param&gt;
public sealed class CoreDispatcherSynchronizationContext(CoreDispatcher dispatcher) : SynchronizationContext
{
    /// &lt;inheritdoc /&gt;
    public override void Post(SendOrPostCallback d, object? state)
    {
        ArgumentNullException.ThrowIfNull(d);
        _ = dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =&gt; d.Invoke(state));
    }

    /// &lt;inheritdoc /&gt;
    public override SynchronizationContext CreateCopy() =&gt; new CoreDispatcherSynchronizationContext(dispatcher);

    /// &lt;inheritdoc /&gt;
    public override void Send(SendOrPostCallback d, object? state) =&gt; throw new NotSupportedException("'SynchronizationContext.Send' is not supported.");
}</code></pre>
<p>并在合适的时间注册线程上下文，比如<code>OnWindowCreated</code></p>
<pre class="language-csharp highlighter-hljs"><code>protected override void OnWindowCreated(WindowCreatedEventArgs e)
{
    if (SynchronizationContext.Current == null)
    {
        CoreDispatcherSynchronizationContext context = new(e.Window.Dispatcher);
        SynchronizationContext.SetSynchronizationContext(context);
    }
    base.OnWindowCreated(e);
}</code></pre>
<p>然后就可以点运行运行了</p>
<p><img src="https://img2024.cnblogs.com/blog/2662465/202503/2662465-20250313182043104-1841107475.png" alt="" height="1603" width="2052"></p>
<p id="1741861256420">经测试，热重载等调试功能正常，UAP 可以调用一些与 UI 无关的新 WinRT API，甚至可以扩展标题栏，不过打包后无法成功在 Win8.1 安装，原因未知</p>
<p><img src="https://img2024.cnblogs.com/blog/2662465/202503/2662465-20250313182414427-969553412.png"></p>
<p>最后附上示例应用：<a href="https://github.com/wherewhere/CoreAppUAP" target="_blank" rel="noopener nofollow">https://github.com/wherewhere/CoreAppUAP</a></p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/wherewhere/" target="_blank">where-where</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/wherewhere/p/18770443" target="_blank">https://www.cnblogs.com/wherewhere/p/18770443</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9029131448587963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 18:44">2025-03-13 18:44</span>&nbsp;
<a href="https://www.cnblogs.com/wherewhere">where-where</a>&nbsp;
阅读(<span id="post_view_count">35</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18770443" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18770443);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18770443', targetLink: 'https://www.cnblogs.com/wherewhere/p/18770443', title: '【UAP】使用 .NET Core App 编写 UAP' })">举报</a>
</div>
        