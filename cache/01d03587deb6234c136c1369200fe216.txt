
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19040484" title="发布于 2025-08-15 22:20">
    <span role="heading" aria-level="2">【渲染流水线】[几何阶段]-[图元装配]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250815222430490-1532261579.png" alt="【渲染流水线】[几何阶段]-[图元装配]以UnityURP为例" class="desc_img">
        本文介绍了Unity URP渲染管线中的图元装配过程，重点解析了几何图元（三角形、线段等）的组装原理与实现方式。文章详细说明了通过MeshTopology和索引缓冲区定义图元类型的方法，包括三角形、三角形条带等五种图元及其连接规则，特别强调了顶点缠绕顺序对表面剔除的影响。同时，提供了URP中不同图元类型的代码实现示例，并指出底层实现的关键文件和调试方法。最后指出可通过继承ScriptableRendererFeature实现自定义几何处理，为开发者探索URP渲染管线提供了实践指导。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>图元装配负责将离散顶点组装成完整几何图元（如点、线、三角形、三角形条带）</p>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="输入数据"><strong>输入数据</strong>‌</h1>
<p>接收‌<strong>顶点着色器输出的离散顶点数据</strong>‌，包括：</p>
<ul>
<li>变换后的空间坐标（如裁剪空间位置）</li>
<li>顶点属性（颜色、法线、纹理坐标等</li>
</ul>
<h1 id="输出数据"><strong>输出数据</strong>‌</h1>
<p>生成‌<strong>完整几何图元</strong>‌（Primitive），例如：</p>
<ul>
<li>三角形（<code>GL_TRIANGLES</code>）</li>
<li>线段（<code>GL_LINES</code>）</li>
<li>点（<code>GL_POINTS</code>）‌</li>
</ul>
<h1 id="在unity中图元装配的实现">在Unity中，图元装配的实现</h1>
<p>主要通过‌<strong>网格拓扑（Mesh Topology）</strong>‌和‌<strong>索引缓冲区（Index Buffer）</strong>‌完成。</p>
<h2 id="顶点分组模式"><strong>顶点分组模式‌</strong></h2>
<ol>
<li>
<p>‌<strong>索引分组模式</strong>‌通过索引数组（如<code>Mesh.triangles</code>或<code>Mesh.GetIndices()</code>）定义顶点连接顺序，每个索引指向顶点缓冲区中的位置，按预设拓扑规则分组‌。例如：</p>
<pre><code>text
索引数组 [0,1,2,3,4,5]
三角形拓扑 → 分组为△(0,1,2)和△(3,4,5)
</code></pre>
</li>
<li>
<p>‌<strong>顺序分组模式</strong>‌无索引时直接按顶点提交顺序分组（如连续3顶点构成一个三角形）‌。</p>
</li>
</ol>
<hr>
<h2 id="unity支持的图元类型"><strong>‌Unity支持的图元类型‌</strong></h2>
<table>
<thead>
<tr>
<th>‌<strong>图元类型</strong>‌</th>
<th>‌<strong>描述</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>三角形（<code>Triangles</code>）</td>
<td>每3个独立顶点构成一个三角形，默认用于3D模型渲染‌。</td>
</tr>
<tr>
<td>三角形条带（<code>TriangleStrip</code>）</td>
<td>复用前2顶点与当前顶点生成新三角形，减少顶点重复提交‌。</td>
</tr>
<tr>
<td>四边形（<code>Quads</code>）</td>
<td>每4顶点构成一个四边形（实际渲染时拆分为2个三角形）。</td>
</tr>
<tr>
<td>线段（<code>Lines</code>）</td>
<td>每2顶点构成一条线段，用于线框渲染‌。</td>
</tr>
<tr>
<td>点（<code>Points</code>）</td>
<td>每个顶点独立渲染为屏幕上的点‌。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="拓扑连接规则"><strong>‌拓扑连接规则‌</strong></h2>
<ol>
<li>‌<strong>缠绕顺序（Winding Order）</strong>‌Unity默认使用‌<strong>顺时针顺序</strong>‌判定三角形正面，逆时针面会被剔除‌。例如：
<ul>
<li>顶点顺序<code>(v1,v2,v3)</code>为顺时针 → 可见</li>
<li>顺序<code>(v1,v3,v2)</code>为逆时针 → 剔除‌。</li>
</ul>
</li>
<li>‌<strong>共享顶点优化</strong>‌索引数组可复用顶点（如<code>[0,1,2,1,2,3]</code>生成两个共享边<code>(1,2)</code>的三角形）。</li>
</ol>
<hr>
<h2 id="关键实现接口"><strong>‌关键实现接口‌</strong></h2>
<ol>
<li>‌<strong>设置拓扑类型</strong>‌通过<code>MeshTopology</code>枚举指定图元类型（如<code>MeshTopology.Triangles</code>）‌。</li>
<li>‌<strong>索引缓冲区操作</strong>‌
<ul>
<li><code>Mesh.SetIndices()</code>：自定义索引分组规则</li>
<li><code>Mesh.triangles</code>：直接设置三角形索引（旧API，效率较低）‌</li>
</ul>
</li>
</ol>
<h1 id="urp中对图元装配的调用位置与示例">URP中对图元装配的调用位置与示例</h1>
<p>在Unity URP (Universal Render Pipeline) 中，几何阶段的图元装配是由底层渲染管线自动处理的，主要通过<code>ScriptableRenderContext</code>和<code>CommandBuffer</code>系统完成。</p>
<h2 id="核心类与调用流程"><strong>‌核心类与调用流程‌</strong></h2>
<ul>
<li>‌<strong>UniversalRenderPipeline.RenderSingleCamera</strong>‌入口点，通过<code>ScriptableRenderContext</code>提交绘制命令</li>
<li>‌<strong>ScriptableRenderContext.DrawRenderers</strong>‌触发几何处理，最终调用底层图形API (如OpenGL/D3D)</li>
<li>‌<strong>CommandBuffer.DrawProcedural</strong>‌直接控制图元装配（手动模式）</li>
</ul>
<hr>
<h2 id="图元装配示例代码">图元装配示例代码‌</h2>
<p>以下是不同图元类型的装配方式示例：</p>
<h3 id="三角形-triangles">三角形 (Triangles)‌</h3>
<pre><code class="language-csharp">csharp
// 通过MeshFilter自动装配var meshFilter = GetComponent&lt;MeshFilter&gt;();
Graphics.DrawMesh(meshFilter.sharedMesh, transform.position, transform.rotation, material, 0);
</code></pre>
<h3 id="三角形带-triangle-strip">三角形带 (Triangle Strip)‌</h3>
<pre><code class="language-csharp">csharp
// 手动通过CommandBuffer装配
CommandBuffer cmd = new CommandBuffer();
cmd.DrawProcedural(
    Matrix4x4.identity,
    material,
    0,
    MeshTopology.TriangleStrip,
    vertexCount: 4// 需要至少4个顶点形成2个三角形
);
context.ExecuteCommandBuffer(cmd);
</code></pre>
<h3 id="四边形-quads">四边形 (Quads)‌</h3>
<pre><code class="language-csharp">csharp
// URP中四边形会被拆分为三角形处理
Mesh quadMesh = new Mesh();
quadMesh.vertices = new Vector3[] {/* 4个顶点 */ };
quadMesh.SetIndices(new int[] {0,1,2, 0,2,3}, MeshTopology.Triangles, 0);
Graphics.DrawMesh(quadMesh, Matrix4x4.identity, material, 0);
</code></pre>
<h3 id="线段-lines">线段 (Lines)‌</h3>
<pre><code class="language-csharp">csharp
// 使用GL.LINES或LineRenderer组件
CommandBuffer cmd = new CommandBuffer();
cmd.DrawProcedural(
    Matrix4x4.identity,
    lineMaterial,
    0,
    MeshTopology.Lines,
    vertexCount: 2
);
</code></pre>
<h3 id="点-points">点 (Points)‌</h3>
<pre><code class="language-csharp">csharp
// 使用MeshTopology.Points
CommandBuffer cmd = new CommandBuffer();
cmd.DrawProcedural(
    Matrix4x4.identity,
    pointMaterial,
    0,
    MeshTopology.Points,
    vertexCount: 1
);
</code></pre>
<hr>
<h2 id="底层实现位置">底层实现位置‌</h2>
<ul>
<li>‌<strong>URP源码关键文件</strong>‌:<code>UniversalRenderPipelineCore.cs</code>&nbsp;→&nbsp;<code>ExecuteRenderPass</code>方法<code>ScriptableRenderer.cs</code>&nbsp;→&nbsp;<code>EnqueuePass</code>提交绘制命令</li>
<li>‌<strong>Shader支持</strong>‌:在Shader中需声明正确的<code>#pragma target</code>和几何着色器（如需要）</li>
</ul>
<hr>
<h2 id="调试">调试</h2>
<ol>
<li>使用<code>Frame Debugger</code>查看实际提交的图元类型</li>
<li>在URP设置中启用<code>Native Rendering Debugger</code></li>
<li>检查材质的<code>Render Queue</code>和<code>Shader Pass</code>设置</li>
</ol>
<p>更深入的管线定制，可继承<code>ScriptableRendererFeature</code>实现自定义几何处理。</p>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.003472222222222222" data-date-updated="2025-08-15 22:25">2025-08-15 22:20</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">61</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19040484);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19040484', targetLink: 'https://www.cnblogs.com/SmalBox/p/19040484', title: '【渲染流水线】[几何阶段]-[图元装配]以UnityURP为例' })">举报</a>
</div>
        