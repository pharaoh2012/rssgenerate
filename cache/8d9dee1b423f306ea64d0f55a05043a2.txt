
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Naylor/p/18948402" title="发布于 2025-06-25 17:01">
    <span role="heading" aria-level="2">探索 JavaCV：开启计算机视觉与多媒体处理新世界</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#javacv-是什么" rel="noopener nofollow">JavaCV 是什么？</a></li><li><a href="#安装指南" rel="noopener nofollow">安装指南</a></li><li><a href="#有趣的-javacv-使用示例" rel="noopener nofollow">有趣的 JavaCV 使用示例</a><ul><li><a href="#录制-rtmp-直播流" rel="noopener nofollow">录制 RTMP 直播流</a></li><li><a href="#捕获摄像头画面" rel="noopener nofollow">捕获摄像头画面</a></li><li><a href="#美颜相机" rel="noopener nofollow">美颜相机</a></li></ul></li><li><a href="#引用" rel="noopener nofollow">引用</a></li></ul></div><p></p>
<p>在当今的技术领域，计算机视觉和多媒体处理的应用愈发广泛。从视频监控到直播录制，再到美颜相机等有趣的功能，都离不开强大的处理库。JavaCV 作为基于 OpenCV 和 FFmpeg 的 Java 接口库，为 Java 开发者打开了一扇通往这些功能的大门。接下来，就让我们一起深入了解 JavaCV 的神奇之处吧！</p>
<h2 id="javacv-是什么">JavaCV 是什么？</h2>
<p>JavaCV 就像是一个超级桥梁，它将 OpenCV 和 FFmpeg 这两个在 C++ 世界中叱咤风云的库，引入到了 Java 的环境里。有了 JavaCV，开发者无需再纠结于 C++ 的复杂语法和编译环境，在 Java 里就能轻松实现视频处理、图像分析、特征提取等高端操作。</p>
<p><strong>它的特性超厉害</strong></p>
<ul>
<li>OpenCV 功能封装：JavaCV 把 OpenCV 的 C++ API 进行了精心封装，提供了和原生 API 很相似的 Java 接口。不管是图像处理、特征检测，还是目标跟踪，都能信手拈来。</li>
<li>FFmpeg 集成：集成了 FFmpeg 库，意味着 JavaCV 支持多种音视频格式的编解码、转码以及流媒体处理。以后处理音视频，就像吃蛋糕一样简单。</li>
<li>GPU 加速支持：在这个追求速度的时代，JavaCV 支持利用 GPU 进行加速计算。对于那些计算密集型任务，速度提升可不是一星半点。</li>
<li>多平台兼容：无论是 Windows、Linux 还是 macOS，JavaCV 都能完美运行，跨平台性一流。</li>
</ul>
<h2 id="安装指南">安装指南</h2>
<p>如果你使用 Gradle，安装 JavaCV 就像下面这样简单：</p>
<pre><code class="language-java">
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    
    // JavaCV 核心依赖
    implementation group: 'org.bytedeco', name: 'javacv-platform', version: '1.5.7'
    
    // Tesseract JavaCPP Presets
    implementation group: 'org.bytedeco', name: 'tesseract-platform', version: 
'5.0.1-1.5.7'


    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    // Apache HttpClient 依赖
    implementation 'org.apache.httpcomponents:httpclient:4.5.14'
    // fastjson2 核心依赖
    implementation 'com.alibaba.fastjson2:fastjson2:2.0.36'
    implementation 'cn.hutool:hutool-all:5.8.1'
    implementation 'org.springdoc:springdoc-openapi-ui:1.7.0'
}

</code></pre>
<p>这里要注意啦，本文使用的 SpringBoot 版本为 2.7.6，JDK 版本为 11。而且在 Intellj IDEA 的“外部库”依赖关系中可以发现，javacv - platform 已经自带了很多依赖包，甚至连 ffmpeg 库都包含在内，所以使用时无需单独安装 ffmpeg 库。</p>
<p><img src="https://img2024.cnblogs.com/blog/718864/202506/718864-20250625165956470-1559300767.png" alt="自包含ffmpeg" loading="lazy"></p>
<h2 id="有趣的-javacv-使用示例">有趣的 JavaCV 使用示例</h2>
<h3 id="录制-rtmp-直播流">录制 RTMP 直播流</h3>
<p>想象一下，你正在观看一场精彩的直播，想要把它录制下来慢慢回味。JavaCV 就能帮你轻松实现这个需求。</p>
<p><strong>核心对象揭秘</strong></p>
<ul>
<li>FFmpegFrameGrabber：它就像一个勤劳的小蜜蜂，从直播源中抓取帧数据。</li>
<li>FFmpegFrameRecorder：负责把抓取到的帧数据录制下来，保存成 MP4 文件。</li>
</ul>
<p>下面是封装在 Spring Boot 中的示例代码：</p>
<pre><code class="language-java">
@Slf4j
@RequiredArgsConstructor
@Component
public class RecordComponent {

    /**
     * 录制MP4
     *
     * @param deviceCode 设备编码
     * @param videoUrl  直播url
     * @param dpi 录制的视频质量（720p，1080p，2k）
     * @return
     */
    @Async("customThreadPool")
    public String record(String deviceCode, String videoUrl, DpiEnum dpi) {
        log.debug("video_record_param:deviceCode={},videoUrl={},dpi={}", deviceCode, videoUrl, dpi);
        try (FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(videoUrl)) {
            if (videoUrl.startsWith("rtmp")) {
                //使用 TCP 避免丢包
                grabber.setOption("rtmp_transport", "tcp");
            }
            if (videoUrl.startsWith("rtsp")) {
                //使用 TCP 避免丢包
                grabber.setOption("rtsp_transport", "tcp");
            }
            //禁用数据缓冲区,直接从源读取，适用于实时流（如 RTSP/RTMP），减少从源到帧抓取的延迟
            grabber.setOption("fflags", "nobuffer");
            grabber.start();
            
            String videoSavePath="";
            try (FFmpegFrameRecorder recorder = new FFmpegFrameRecorder(videoSavePath, dpi.getWidth(), dpi.getHeight())) {
                // 禁用音频,若源中存在音频通道(即grabber.getAudioChannels()&gt;0)，此配置无法生效
                recorder.setAudioChannels(0);
                //设置编码格式：h264
                recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);
                recorder.setFormat("mp4");
                //fps,帧率表示视频中每秒钟显示的静态画面数量
                recorder.setFrameRate(grabber.getFrameRate());
                //视频色彩相关配置
                recorder.setPixelFormat(avutil.AV_PIX_FMT_YUV420P);
                //降低视频编码延迟，适用于对实时性要求极高的场景
                recorder.setOption("tune", "zerolatency");
                //预设值影响编码速度和压缩效率的平衡
                recorder.setOption("preset", "veryfast");
                recorder.start();
                
                Frame frame;
                while ((frame = grabber.grab()) != null) {
                    recorder.record(frame);
                    log.debug("video_record_{}视频帧录制成功", deviceCode);
                }
            } catch (Exception e) {
                log.error("video_record_recorder_error,msg={},deviceCode={}", e.getMessage(), deviceCode);
                log.error("video_record_recorder_error", e);
            }
        } catch (Exception e) {
            log.error("video_record_grabber_error,msg={},deviceCode={}", e.getMessage(), deviceCode);
            log.error("video_record_grabber_error", e);
        }
    }
}

</code></pre>
<p>这里的 @Component 让这个类成为 Spring IOC 组件，方便在其他地方注入使用。@Async 开启了异步线程，因为录制直播可能需要很长时间，不能让请求方一直等待。</p>
<p>原理：通过 FFmpegFrameGrabber 从指定的直播地址抓取帧数据，然后通过 FFmpegFrameRecorder 将帧数据录制为 mp4 文件。这里面会通过调用自包含的ffmpeg库，实现录制功能。</p>
<h3 id="捕获摄像头画面">捕获摄像头画面</h3>
<p>想不想用 Java 打开笔记本的摄像头，看看自己帅气或美丽的脸庞？下面的代码就能帮你实现：</p>
<pre><code class="language-java">
public class CameraComponent {

    /**
     * 打开摄像头并显示视频流，不可以以SpringBoot Web方式调用， 可以使用 main 调用。
     */
    public static void openCamera() {
        try (OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0)) {
            grabber.start();

            CanvasFrame frameViewer = new CanvasFrame("摄像头视频");
            frameViewer.setCanvasSize(grabber.getImageWidth(), grabber.getImageHeight());

            Frame frame;
            while ((frame = grabber.grab()) != null &amp;&amp; frameViewer.isVisible()) {
                frameViewer.showImage(frame);
            }
            
            frameViewer.dispose();
        } catch (Exception e) {
            log.error("打开摄像头失败", e);
        }
    }

    public static void main(String[] args) {
        openCamera();
    }
}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/718864/202506/718864-20250625170011338-1659321344.png" alt="开启摄像头" loading="lazy"></p>
<p>OpenCVFrameGrabber&nbsp;负责捕获摄像头的视频流，CanvasFrame&nbsp;则用来显示视频流。不过要注意哦，这个方法只能在 main 方法里运行，Spring Boot Web 项目启动会报错。</p>
<h3 id="美颜相机">美颜相机</h3>
<p>有了摄像头，怎么能少了美颜功能呢？JavaCV 也能实现简单的美颜效果。</p>
<pre><code class="language-java">
public class CameraComponent {

    /**
     * 美颜相机
     */
    public static void beautyFace() {
        try (OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0)) {
            CanvasFrame frameViewer = new CanvasFrame("美颜相机");
            grabber.start();
            frameViewer.setCanvasSize(grabber.getImageWidth(), grabber.getImageHeight());

            String cascadePath = "D:\\temp\\haarcascade_frontalface_default.xml";
            System.out.println("人脸检测器路径: " + cascadePath);
            CascadeClassifier faceDetector = new CascadeClassifier(cascadePath);

            OpenCVFrameConverter.ToMat converter = new OpenCVFrameConverter.ToMat();

            Frame frame;
            while ((frame = grabber.grab()) != null &amp;&amp; frameViewer.isVisible()) {
                Mat mat = converter.convert(frame);
                if (mat == null) continue;

                Mat gray = new Mat();
                cvtColor(mat, gray, COLOR_BGR2GRAY);
                equalizeHist(gray, gray);

                RectVector faceDetections = new RectVector();
                faceDetector.detectMultiScale(gray, faceDetections);

                gray.release();

                for (int i = 0; i &lt; faceDetections.size(); i++) {
                    Rect rect = faceDetections.get(i);
                    applyBeautyFilter(mat, rect);
                }

                frameViewer.showImage(converter.convert(mat));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 简化版美颜滤镜实现
     * @param frame
     * @param face
     */
    private static void applyBeautyFilter(Mat frame, Rect face) {
        int expand = face.width() / 4;
        Rect expandedFace = new Rect(
                Math.max(0, face.x() - expand),
                Math.max(0, face.y() - expand),
                Math.min(frame.cols() - face.x() - 1, face.width() + 2 * expand),
                Math.min(frame.rows() - face.y() - 1, face.height() + 2 * expand)
        );

        Mat faceROI = new Mat(frame, expandedFace);

        Mat smoothed = new Mat();
        bilateralFilter(faceROI, smoothed, 15, 80, 80);

        smoothed.copyTo(new Mat(frame, expandedFace));

        smoothed.release();
        faceROI.release();
    }
}

</code></pre>
<p>这个美颜功能主要是磨皮和虚化，让你的皮肤看起来更加光滑。不过它只对正脸有效哦，如果侧着脸或者没有检测到人脸，就不会有效果啦。</p>
<p>大致思路为，先捕捉摄像头的视频流，解析出帧数据，然后将帧数据转成图片给OpenCV库处理，处理完毕就是美颜之后的图片，再渲染到播放窗口上。</p>
<p>bilateralFilter：调用OpenCV的这个方法，实现磨皮效果。具体这个方法的作用可以参考：<a href="https://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener nofollow">https://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></p>
<p>haarcascade_frontalface_default.xml： 这是 OpenCV 提供的一个预训练模型文件，用于人脸检测。它基于 Haar 级联分类器（Haar Cascade Classifier） 算法，包含了训练好的人脸特征数据，用于识别图像中的正面人脸区域。</p>
<p>faceDetections：这个对象的size 大于0 ，说明检测到了人脸。</p>
<hr>
<p>JavaCV 的功能远不止这些，它就像一个宝藏库，等待着开发者们去挖掘更多有趣又实用的功能。赶紧动手试试吧！</p>
<h2 id="引用">引用</h2>
<p><a href="https://github.com/bytedeco/javacv" target="_blank" rel="noopener nofollow">https://github.com/bytedeco/javacv</a></p>
<p><a href="https://bytedeco.org/" target="_blank" rel="noopener nofollow">https://bytedeco.org/</a></p>
<p><a href="https://gitee.com/naylor_personal/ramble-spring-boot/tree/master/java-cv" target="_blank" rel="noopener nofollow">https://gitee.com/naylor_personal/ramble-spring-boot/tree/master/java-cv</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <div>
邮箱：cnaylor@163.com  
</div>
<div>
技术交流QQ群：1158377441 
</div>
<div>
欢迎关注我的微信公众号【TechnologyRamble】，后续博文将在公众号首发： 
</div>
<div>
<a href="http://img.anlu58.com/logo/2.png"><img src="https://images.cnblogs.com/cnblogs_com/Naylor/2399439/o_240521084523_2.png" alt="TechnologyRamble" border="0"></a>
</div>
<div>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-25 17:01">2025-06-25 17:01</span>&nbsp;
<a href="https://www.cnblogs.com/Naylor">Naylor</a>&nbsp;
阅读(<span id="post_view_count">84</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18948402);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18948402', targetLink: 'https://www.cnblogs.com/Naylor/p/18948402', title: '探索 JavaCV：开启计算机视觉与多媒体处理新世界' })">举报</a>
</div>
        