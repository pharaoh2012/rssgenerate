
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lcword/p/18785485" title="发布于 2025-03-21 17:24">
    <span role="heading" aria-level="2">Oracle存储过程里操作BLOB的字节数据的办法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="postText">
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一缘由">一、缘由</h2>
<p>BLOB是指二进制大对象，也就是英文Binary Large Object的缩写。<br>
在很多时候，我们是通过其他编程语言（如Java）访问BLOB的字节数据，进行字节级的操作的。<br>
但是有些时候工作量很小，感觉专门为BLOB字节级操作而专门开发个程序，是比较麻烦的。于是我研究了一下如何直接在Oracle存储过程里操作BLOB的字节数据。</p>
<h2 id="二办法">二、办法</h2>
<h2 id="21-基本操作">2.1 基本操作</h2>
<p>使用 length 函数，可以获取blob的字节长度。如 <code>v_len := length(i_blob);</code> 。<br>
与字符串（如 varchar2 等）一样，blob为 <code>null</code> 时，length的返回值是 <code>null</code>。故建议加上 nvl 做一下转换，如 <code>v_len := nvl(length(i_blob), 0);</code> 。</p>
<p>为了避免 <code>null</code> 问题，可使用 empty_blob 函数，它的作用是返回一个长度为0的blob。如 <code>v_blob := empty_blob();</code> 。</p>
<p>empty_blob返回的blog只是一个初始化，它是不能修改字节数据的。于是需要使用 dbms_lob.createtemporary 来创建一个能进行字节数据操作的临时blob。如 <code>dbms_lob.createtemporary(v_blob, TRUE);</code> 。</p>
<h2 id="22-dbms_lob包">2.2 DBMS_LOB包</h2>
<p>为了便于BLOB类型的使用，Oracle官方提供了 DBMS_LOB 包，它提供了很多工具函数。例如先前我们使用了createtemporary函数。<br>
DBMS_LOB所提供的过程有——</p>
<ul>
<li>APPEND：将源LOB中的内容加到目的LOB中。</li>
<li>CLOSE：关闭已经打开的LOB。</li>
<li>CREATETEMPORARY：在用户的临时表空间中，建立临时LOB。</li>
<li>FILECLOSE：关闭打开的BFILE定位符所指向的OS文件。</li>
<li>FILECLOSEALL：关闭当前会话已经打开的所有BFILE文件。</li>
<li>FILEEXISTS：确定file_loc对应的OS文件是否存在，1：存在。0：不存在。</li>
<li>FILEGETNAME：获取BFILE定位符所对应的目录别名和文件名。</li>
<li>FILEISOPEN：确定BFILE对应的OS文件是否打开。</li>
<li>FREETEMPORARY：释放在默认临时表空间中的临时LOB。</li>
<li>FILEOPEN：打开文件。</li>
<li>GETCHUNKSIZE：当建立包含CLOB/BLOB列的表时，通过指定CHUNK参数可以指定操纵LOB需要分配的字节数（数据库尺寸的整数倍）默认为数据块的尺寸。</li>
<li>COPY：从源LOB中复制数据到目的LOB。</li>
<li>ERASE：删除LOB中全部或部分内容。</li>
<li>TRIM：将LOB值减少到指定的长度。</li>
<li>WRITE：向LOB中写入数据。</li>
<li>INSTR：返回特定样式数据从LOB某偏移位置开始出现N次的具体位置。</li>
<li>IDOPEN：确定LOB是否打开，打开：1，未打开：0。</li>
<li>ISTEMPORARY：确定定位符是否为临时LOB。</li>
<li>LOADFROMFILE：将BFILE的部分或全部内容复制到目标LOB变量。</li>
<li>LOADBLOBFROMFILE：将BFILE数据装载到BLOB中，并且在装载后取得最新的偏移位置。</li>
<li>OPEN：打开LOB，open_mode（只读：dbms_lob.lob_readonly，写：dbms_lob.lob_readwrite）。</li>
<li>COMPARE：比较两个同种数据类型的LOB的部分或全部值是否相同。</li>
<li>GETLENGTH：获取LOB的长度。</li>
<li>READ：从LOB中读出数据。</li>
<li>SUBSTR：与字符处理函数SUBSTR使用方法一样。</li>
<li>WRITEAPPEND：将缓冲区数据写到LOB尾部。</li>

</ul>
<p>有了DBMS_LOB包后，对于（变量级的）BLOB操作就比较方便了。例如我们想将两个blob的内容，连续拼接到1个blob中，则可以这样做——</p>
<pre class="highlighter-hljs"><code class="highlighter-hljs language-sql hljs">  <span class="hljs-keyword">function test_blob_join(i_blob1 <span class="hljs-keyword">in <span class="hljs-type">blob, i_blob2 <span class="hljs-keyword">in <span class="hljs-type">blob) <span class="hljs-keyword">return <span class="hljs-type">blob <span class="hljs-keyword">is
    v_rt <span class="hljs-type">blob :<span class="hljs-operator">= empty_blob();
  <span class="hljs-keyword">begin
    dbms_lob.createtemporary(v_rt, <span class="hljs-literal">TRUE);  <span class="hljs-comment">-- 分配临时的 blob .
    dbms_lob.append(v_rt, i_blob1);        <span class="hljs-comment">-- 拼接 i_blob1 .
    dbms_lob.append(v_rt, i_blob2);        <span class="hljs-comment">-- 拼接 i_blob2 .
    <span class="hljs-keyword">return v_rt;
  <span class="hljs-keyword">end;
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>可这样测试——</p>
<pre class="highlighter-hljs"><code class="highlighter-hljs language-sql hljs"><span class="hljs-keyword">select PKG_FINGER.test_blob_join(hextoraw(<span class="hljs-string">'0102'), hextoraw(<span class="hljs-string">'A1A2')) <span class="hljs-keyword">from dual;
</span></span></span></span></code></pre>
<p>它返回blob的字节数据是 <code>01 02 A1 A2</code>。验证通过。</p>
<h2 id="23-字节级操作与raw数据类型">2.3 字节级操作与RAW数据类型</h2>
<p>现在对实现BLOB的的变量级操作是没有问题了。那么，该怎样实现BLOB的字节级操作呢？<br>
例如——怎么从blob中截取位置开始的一串字节？在blob中替换每个位置的字节？在blob的最后追加字节数据？<br>
其实dbms_lob的 substr、write、writeappend 可分别解决这3个问题。<br>
然后仔细一看，会发现这些过程使用了 RAW 类型。<br>
对于RAW类型，很多资料是这样说的——</p>
<pre class="highlighter-hljs"><code class="highlighter-hljs hljs language-scss">RAW类型是Oracle中用于保存位串的一种数据类型，类似于CHAR，使用RAW（L) 方式声明，最长可达<span class="hljs-number">32767字节。
</span></code></pre>
<p>RAW与BLOB的关系——</p>
<ul>
<li>BLOB中的一段字节数据，就是RAW类型的。例如通过 dbms_lob.substr 截取得到的数据。</li>
<li>其次可根据 RAW数据 去替换BLOB中的某段字节数据。即使用 dbms_lob.write 。</li>
<li>可在BLOB的最后追加 RAW数据 。即使用 dbms_lob.writeappend 。</li>
<li>Oracle支持 RAW 隐式转型为 BLOB 类型。</li>
</ul>
<p>观察dbms_lob的帮助文档，会发现每个函数既有BLOB版，又有CLOB版。而且，CLOB版用VARCHAR2类型时，其BLOB版是RAW类型。即 RAW与VARCHAR2 是类似的，一个是字节串，一个是字符串。<br>
许多常用的字符串函数也对 RAW 是有效的。例如 length 与 sustr 。</p>
<p>RAW 可用十六进制字符串来表示。所以一般使用 hextoraw 函数，将十六进制字符串转为RAW。例如 <code>hextoraw('A1A2')</code> 。<br>
RAW 可看作十六进制字符串。所以对raw变量使用length函数时，其返回值是 字节长度的2倍（因为对于十六进制字符串，一个字节是用2个十六进制字符表示的）。substr 等函数也存在同样的情况。<br>
还可以用 rawtohex，将 RAW类型的数据 转换为 十六进制字符串（VARCHAR2）。</p>
<h2 id="24-utl_raw包">2.4 UTL_RAW包</h2>
<p>上面提到 RAW 的length结果是 字节长度的2倍，它是不太方便的。这时可以使用 UTL_RAW包。例如 utl_raw.length的结果就是 字节长度。<br>
常见的UTL_RAW过程有——</p>
<ul>
<li>length：长度计算函数，得到一个raw类型变量的长度，单位为字节</li>
<li>concat：拼接函数，用于拼接两个raw类型变量</li>
<li>substr：获取子串函数</li>
<li>bit_and：位与函数</li>
<li>bit_or：位或函数</li>
<li>bit_xor：位异或函数</li>
<li>overlay：给指定字节赋值</li>
<li>cast_to_raw：字符串 转 RAW</li>
<li>cast_to_varchar2：RAW 转 varchar2</li>
<li>cast_to_nvarchar2：RAW 转 nvarchar2</li>
<li>cast_to_number：RAW 转 number</li>
<li>cast_from_number：number 转 RAW</li>
<li>cast_to_binary_integer：RAW 转 binary_integer</li>
<li>cast_from_binary_integer：binary_integer 转 RAW</li>

</ul>
<h2 id="三使用心得">三、使用心得</h2>
<h3 id="31-32位整数转换函数">3.1 32位整数转换函数</h3>
<p>最开始不知道 binary_integer就是32位整数。于是自己写了32位整数与 RAW 的转换函数。虽然现在用不上了，但觉得它们还是很适合作为应用示范的。</p>
<pre class="highlighter-hljs"><code class="highlighter-hljs language-sql hljs">  <span class="hljs-comment">-- 将数字转为 raw(4)类型的 大端方式32位整数 .
  <span class="hljs-keyword">function TO_INT32BE(i_src <span class="hljs-keyword">in number) <span class="hljs-keyword">return raw <span class="hljs-keyword">is
    v_src number;
    v_hexstr varchar2(<span class="hljs-number">20);
    v_rt raw(<span class="hljs-number">4);
  <span class="hljs-keyword">begin
    v_src :<span class="hljs-operator">= i_src;
    if (v_src<span class="hljs-operator">&lt;<span class="hljs-number">0) <span class="hljs-keyword">then
      v_src:<span class="hljs-operator">=v_src <span class="hljs-operator">+ <span class="hljs-number">4294967296;    <span class="hljs-comment">-- 为了支持负数.
    <span class="hljs-keyword">end if;
    v_hexstr :<span class="hljs-operator">= <span class="hljs-string">'0000000' <span class="hljs-operator">|| <span class="hljs-built_in">trim(to_char(v_src,<span class="hljs-string">'XXXXXXXX'));
    v_hexstr :<span class="hljs-operator">= substr(v_hexstr, length(v_hexstr)<span class="hljs-number">-7, length(v_hexstr));
    v_rt :<span class="hljs-operator">= hextoraw(v_hexstr);
    <span class="hljs-keyword">return v_rt;
  <span class="hljs-keyword">end;
  
  <span class="hljs-comment">-- 将数字转为 raw(4)类型的 小端方式32位整数 .
  <span class="hljs-keyword">function TO_INT32LE(i_src <span class="hljs-keyword">in number) <span class="hljs-keyword">return raw <span class="hljs-keyword">is
    v_src number;
    v_hexstr varchar2(<span class="hljs-number">20);
    v_rt raw(<span class="hljs-number">4);
  <span class="hljs-keyword">begin
    v_src :<span class="hljs-operator">= i_src;
    if (v_src<span class="hljs-operator">&lt;<span class="hljs-number">0) <span class="hljs-keyword">then
      v_src:<span class="hljs-operator">=v_src <span class="hljs-operator">+ <span class="hljs-number">4294967296;    <span class="hljs-comment">-- 为了支持负数.
    <span class="hljs-keyword">end if;
    v_hexstr :<span class="hljs-operator">= <span class="hljs-string">'0000000' <span class="hljs-operator">|| <span class="hljs-built_in">trim(to_char(v_src,<span class="hljs-string">'XXXXXXXX'));
    v_hexstr :<span class="hljs-operator">= substr(v_hexstr, length(v_hexstr)<span class="hljs-number">-7, length(v_hexstr));
    v_hexstr :<span class="hljs-operator">= substr(v_hexstr, <span class="hljs-number">7, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">5, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">3, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">1, <span class="hljs-number">2)
      ;
    v_rt :<span class="hljs-operator">= hextoraw(v_hexstr);
    <span class="hljs-keyword">return v_rt;
  <span class="hljs-keyword">end;
  
  <span class="hljs-comment">-- 将 存储在raw(4)中的大端方式32位整数 转为数字. 值域为 0~4294967295 .
  <span class="hljs-keyword">function FROM_INT32BE(i_src <span class="hljs-keyword">in raw) <span class="hljs-keyword">return number <span class="hljs-keyword">is
    v_src raw(<span class="hljs-number">8);
    v_hexstr varchar2(<span class="hljs-number">20):<span class="hljs-operator">=<span class="hljs-string">'';
    v_rt number:<span class="hljs-operator">=<span class="hljs-number">0;
  <span class="hljs-keyword">begin
    if ( (nvl(length(i_src), <span class="hljs-number">0)<span class="hljs-operator">&lt;=<span class="hljs-number">0) ) <span class="hljs-keyword">then
      <span class="hljs-keyword">return v_rt;
    <span class="hljs-keyword">end if;
    if (length(i_src) <span class="hljs-operator">&gt;= <span class="hljs-number">8) <span class="hljs-keyword">then    <span class="hljs-comment">-- length、substr均把 raw 的1个字节看作 2个（十六进制）字符.
      v_src :<span class="hljs-operator">= substr(i_src, <span class="hljs-number">1, <span class="hljs-number">8);
      v_hexstr :<span class="hljs-operator">= rawtohex(v_src);
    <span class="hljs-keyword">else
      v_hexstr :<span class="hljs-operator">= <span class="hljs-string">'000000' <span class="hljs-operator">|| rawtohex(i_src);
      v_hexstr :<span class="hljs-operator">= substr(v_hexstr, length(v_hexstr)<span class="hljs-number">-7, length(v_hexstr));
    <span class="hljs-keyword">end if;
    v_rt :<span class="hljs-operator">= to_number(v_hexstr,<span class="hljs-string">'XXXXXXXX');
    <span class="hljs-keyword">return v_rt;
  <span class="hljs-keyword">end;
  
  <span class="hljs-comment">-- 将 存储在raw(4)中的小端方式32位整数 转为数字. 值域为 0~4294967295 .
  <span class="hljs-keyword">function FROM_INT32LE(i_src <span class="hljs-keyword">in raw) <span class="hljs-keyword">return number <span class="hljs-keyword">is
    v_src raw(<span class="hljs-number">8);
    v_hexstr varchar2(<span class="hljs-number">20):<span class="hljs-operator">=<span class="hljs-string">'';
    v_rt number:<span class="hljs-operator">=<span class="hljs-number">0;
  <span class="hljs-keyword">begin
    if ( (nvl(length(i_src), <span class="hljs-number">0)<span class="hljs-operator">&lt;=<span class="hljs-number">0) ) <span class="hljs-keyword">then
      <span class="hljs-keyword">return v_rt;
    <span class="hljs-keyword">end if;
    if (length(i_src) <span class="hljs-operator">&gt;= <span class="hljs-number">8) <span class="hljs-keyword">then    <span class="hljs-comment">-- length、substr均把 raw 的1个字节看作 2个（十六进制）字符.
      v_src :<span class="hljs-operator">= substr(i_src, <span class="hljs-number">1, <span class="hljs-number">8);
      v_hexstr :<span class="hljs-operator">= rawtohex(v_src);
    <span class="hljs-keyword">else
      v_hexstr :<span class="hljs-operator">= rawtohex(i_src) <span class="hljs-operator">|| <span class="hljs-string">'000000';
      v_hexstr :<span class="hljs-operator">= substr(v_hexstr, <span class="hljs-number">1, <span class="hljs-number">8);
    <span class="hljs-keyword">end if;
    v_hexstr :<span class="hljs-operator">= substr(v_hexstr, <span class="hljs-number">7, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">5, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">3, <span class="hljs-number">2)
      <span class="hljs-operator">|| substr(v_hexstr, <span class="hljs-number">1, <span class="hljs-number">2)
      ;
    v_rt :<span class="hljs-operator">= to_number(v_hexstr,<span class="hljs-string">'XXXXXXXX');
    <span class="hljs-keyword">return v_rt;
  <span class="hljs-keyword">end;
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3 id="32-将32位整数追加到blob">3.2 将32位整数追加到blob</h3>
<p>很多时候需要给blob追加一个 32位整数。现在利用上面的函数，可以这样做——</p>
<pre class="highlighter-hljs"><code class="highlighter-hljs language-sql hljs">      v_tempraw :<span class="hljs-operator">= TO_INT32LE(nvl(i_int32, <span class="hljs-number">0));
      dbms_lob.writeappend(v_blob, <span class="hljs-number">4, v_tempraw);
</span></span></span></code></pre>
<p>（完）</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>Oracle Database Online Documentation / DBMS_LOB . <a href="https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/d_lob.htm#TTPLP600" rel="noopener nofollow" target="_blank">https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/d_lob.htm#TTPLP600</a></li>
<li>Oracle Database Online Documentation / UTL_RAW . <a href="https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/u_raw.htm#TTPLP072" rel="noopener nofollow" target="_blank">https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/u_raw.htm#TTPLP072</a></li>
<li>旺仔丶小馒头《DBMS_LOB》 . <a href="https://www.cnblogs.com/wang-chen/p/5756475.html" target="_blank">https://www.cnblogs.com/wang-chen/p/5756475.html</a></li>
<li>Hornsey《Oracle RAW类型基本操作函数及使用示例》 . <a href="https://blog.csdn.net/nalw2012/article/details/72466256" rel="noopener nofollow" target="_blank">https://blog.csdn.net/nalw2012/article/details/72466256</a></li>
<li>jimeper《ORACLE十进制与十六进制的转换》 . <a href="https://www.cnblogs.com/jimeper/archive/2013/01/24/2875245.html" target="_blank">https://www.cnblogs.com/jimeper/archive/2013/01/24/2875245.html</a></li>
</ul>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.037202821150462966" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 17:24">2025-03-21 17:24</span>&nbsp;
<a href="https://www.cnblogs.com/lcword">lclc</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18785485" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18785485);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18785485', targetLink: 'https://www.cnblogs.com/lcword/p/18785485', title: 'Oracle存储过程里操作BLOB的字节数据的办法' })">举报</a>
</div>
        