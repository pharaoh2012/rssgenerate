
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aaronlinv/p/18628447" title="发布于 2024-12-27 08:31">
    <span role="heading" aria-level="2">重拾 iptables</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>iptables 是一个常看常忘的命令，本文试图从应用的角度理解它</p>
<p>iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发</p>
<h2 id="一些常用的场景">一些常用的场景</h2>
<h3 id="1-禁止-ip-访问后端-ip">1. 禁止 ip 访问后端 IP</h3>
<p>在 <code>192.168.64.6</code> 上增加规则：</p>
<pre><code class="language-sh"># -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量
# -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP
# -d 192.168.64.6: 指定目标 IP 地址，即后端 IP
# -j DROP: 表示丢弃匹配的流量
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP

# -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT

# -p 指定协议类型为 TCP
# --dport 指定目标端口
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT

# 看当前的 iptables 规则
# -L "list"，列出当前的规则
# -n "numeric"，即使用数字 IP 地址和端口号而不是主机名和服务名
# -v "verbose"，显示详细信息
iptables -L -n -v
</code></pre>
<pre><code class="language-sh"># 列出带编号的规则
iptables -L --line-numbers
# 删除 INPUT 链中的第 1 条规则
# 注意！删除成功后序号会改变，需要重新查询序号
iptables -D INPUT 1
# 清除 INPUT 链所有规则
iptables -F INPUT  

# 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则
# 等同于 iptables -F -t filter
iptables -F
</code></pre>
<h3 id="2-端口转发">2. 端口转发</h3>
<p>默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 <code>net.ipv4.ip_forward</code></p>
<p>需要注意，上面的命令仅临时启用 IPv4 数据包。需要永久启用转发，需要修改 <code>/etc/sysctl.conf</code> 文件。 在该文件中添加或修改 <code>net.ipv4.ip_forward=1</code> 一行。 然后运行 <code>sudo sysctl -p</code> 应用更改</p>
<pre><code class="language-sh">cat /proc/sys/net/ipv4/ip_forward
sudo sysctl -w net.ipv4.ip_forward=1
</code></pre>
<h4 id="将本机的-8080-端口转发到-80-端口">将本机的 8080 端口转发到 80 端口</h4>
<pre><code class="language-sh">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 80

# curl 127.0.0.1:8080
# curl 192.168.64.6:8080
# curl: (7) Failed to connect to 127.0.0.1 port 8080 after 1 ms: Couldn't connect to server

# 非本机访问 ok
# curl 192.168.64.6:8080
</code></pre>
<p>PREROUTING 链修改的是从外部连接过来时的转发，所以上面的方式本机 <code>curl 127.0.0.1:8080</code> 会提示：Couldn't connect to server</p>
<p>如果本机连接到本机的转发，需要修改为 OUTPUT 链：</p>
<pre><code class="language-sh"># 清除已有 nat 规则
# iptables -F -t nat
iptables -t nat -A OUTPUT -p tcp --dport 8080 -j REDIRECT --to-port 80

# 非本机访问失败：
# curl 192.168.64.6:8080
# curl: (7) Failed to connect to 192.168.64.6 port 8080 after 1 ms: Connection refused

# 本机访问 ok
# curl 192.168.64.6:8080
# curl 127.0.0.1:8080
</code></pre>
<h4 id="转发内网-ip">转发内网 IP</h4>
<p>在 <code>192.168.64.6</code> 上增加规则：</p>
<pre><code class="language-sh"># 清除已有 nat 规则
# iptables -F -t nat

iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.64.7:80
iptables -t nat -A POSTROUTING -p tcp -d 192.168.64.7 --dport 80 -j SNAT --to-source 192.168.64.6
</code></pre>
<h4 id="转发公网的-ip-和端口">转发公网的 IP 和端口</h4>
<pre><code class="language-sh"># 清除已有 nat 规则
# iptables -F -t nat

iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 106.55.113.110:80
# --to-source 使用公网地址会无法访问
iptables -t nat -A POSTROUTING -p tcp -d 106.55.113.110 --dport 80 -j SNAT --to-source 192.168.64.6
</code></pre>
<p>需要注意的是 <code>SNAT</code> 的 <code>--to-source</code> 需要设置为连接公网的网卡对应的内网 IP（通过 ip ad 查询），如果设置为公网 IP，数据包可能被丢弃</p>
<h3 id="3-内部-ip-共享上网">3. 内部 IP 共享上网</h3>
<p>NAT 目的是为了解决 IPv4 公网 IP 不足的问题：</p>
<ul>
<li>当私有网络中的设备发送数据包到公共网络时，NAT 设备会将数据包的 源IP地址（内网 IP）从私有地址转换为 公共IP地址，并维护一个转换表，记录所有的地址转换关系</li>
<li>NAT 设备接收数据包时，会根据转换表将数据包的目标 IP 地址转换为内部设备的内网 IP，并将其发送到内部网络</li>
</ul>
<p>包含的操作：</p>
<ul>
<li>SNAT (Source Network Address Translation)：修改数据包的源 IP 地址</li>
<li>DNAT (Destination Network Address Translation)：修改数据包的目的 IP 地址</li>
<li>MASQUERADE：和 SNAT 类似，但是对每个包都会动态获取指定输出接口（网卡）的 IP，因此如果接口的 IP 地址发送了变化，MASQUERADE 规则不受影响</li>
</ul>
<p>举个 NAT 的例子：村民张三需要写信给河南的李四，写完后他在信封上写上，寄件人地址：<code>勤劳村 8 号</code>，收件人地址：<code>河南省孟津县陈倪路 20 号</code>。然后就把这封信投递到村里的邮局。邮递员拿到信件一看，这信要是寄出去，收件人通过 <code>勤劳村 8 号</code> 这个回信肯定没办法寄回村里，于是就将信封上寄件人地址修改为：<code>四川省兴文县勤劳村邮局</code>，再将信件发出，同时在本子上记录发往河南的这封信对应的是 <code>勤劳村 8 号</code>。 李四收到信件就按照信件上的信息编写信封，寄件人地址：<code>河南省孟津县陈倪路 20 号</code>，收件人地址：<code>四川省兴文县勤劳村邮局</code>，这样这封回信就寄到了村里的邮局，邮递员一看到这封信是来自河南，对着笔记本就知道这封信是送往 <code>勤劳村 8 号</code>，于是将收件人地址修改为了 <code>勤劳村 8 号</code>，这样邮递员派件的时候就可以把回信送到张三家</p>
<p>详细 NAT 原理可以参考这篇文章：<a href="https://arthurchiao.art/blog/how-nat-traversal-works-zh/" target="_blank" rel="noopener nofollow">[译] NAT 穿透是如何工作的：技术原理及企业级实践</a></p>
<h4 id="实践">实践</h4>
<p>我是按着 <a href="https://zu1k.com/posts/linux/ubuntu-iptables-nat/" target="_blank" rel="noopener nofollow">使用iptables将ubuntu配置为路由器</a> 进行操作，最后的效果：客户端可以通过连接一台配置了 SNAT 或者 MASQUERADE 的机器访问公网</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202412/1929786-20241226222042735-736860458.png" alt="" loading="lazy"></p>
<p>注意：给网关和客户端指定 <code>vmnet15</code> 后还需要手动配置一下 <code>虚拟网络</code>：</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202412/1929786-20241226214350729-1589273688.png" alt="" loading="lazy"></p>
<p>网关 IP 配置：</p>
<pre><code class="language-yaml">network:
  version: 2
  ethernets:
    ens33: # WAN 接口
      dhcp4: true
    ens34: # LAN 接口
      dhcp4: no
      addresses:&nbsp;[10.1.2.1/24]
</code></pre>
<p>客户端配置：</p>
<pre><code class="language-yaml">network:
  version: 2
  ethernets:
    ens33:
      dhcp4: no
      addresses: [10.1.2.2/24]
      gateway4: 10.1.2.1 # 网关
      nameservers:
        addresses:&nbsp;[114.114.114.114]
</code></pre>
<p>在网关机器上进行 iptables 的配置：</p>
<pre><code class="language-sh">sudo sysctl -w net.ipv4.ip_forward=1
</code></pre>
<pre><code class="language-sh"># 将 10.1.2.0/24 网络中的所有主机伪装成 192.168.184.131 这个公网IP地址，以便它们可以访问外部网络
# -o ens33: 匹配通过 ens33 接口出站的数据包
iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o ens33 -j SNAT --to-source 192.168.184.131
</code></pre>
<p>这条命令允许内部网络的设备通过网关访问互联网。内部设备的 IP 地址在数据包离开网关时被替换为网关的公共 IP 地址，从而使外部网络只看到网关的 IP 地址，除了 SNAT 还可以使用 MASQUERADE，二者效果类似</p>
<pre><code class="language-sh">iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j MASQUERADE
</code></pre>
<h2 id="理解-iptables">理解 iptables</h2>
<p>表:</p>
<ol>
<li>filter 表: 这是默认表，用于过滤数据包，决定是否允许数据包通过</li>
<li>nat 表: 用于网络地址转换 (Network Address Translation, NAT)。它主要用于修改数据包的源地址或目标地址，例如将私有 IP 地址转换为公有 IP 地址</li>
<li>mangle 表: 用于修改数据包的头部信息，例如修改 TTL (Time To Live) 值、TOS (Type of Service) 值等</li>
<li>raw 表: 用于在连接跟踪之前处理数据包，主要用于控制连接跟踪是否启用</li>
<li>security 表: (较新版本) 用于安全策略的实施，例如 SELinux</li>
</ol>
<p>链：</p>
<ol>
<li>PREROUTING</li>
<li>INPUT</li>
<li>FORWARD</li>
<li>OUTPUT</li>
<li>POSTROUTING</li>
</ol>
<p>数据包的不同场景：</p>
<ul>
<li>收到的、目的是本机的包：PRETOUTING -&gt; INPUT</li>
<li>收到的、目的是其他主机的包：PRETOUTING -&gt; FORWARD -&gt; POSTROUTING</li>
<li>本地产生的包：OUTPUT -&gt; POSTROUTING</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202412/1929786-20241225175420216-669810024.png" alt="" loading="lazy"><br>
图片来自：<a href="https://morven.life/posts/iptables-wiki/" target="_blank" rel="noopener nofollow">从零开始认识 iptables</a></p>
<p>表包含若干个链：</p>
<ol>
<li>filter 表包含三个链：INPUT, FORWARD, OUTPUT</li>
<li>nat 表包含三个链：PREROUTING, POSTROUTING, OUTPUT</li>
<li>mangle 表五个链都包含</li>
<li>raw 表包含两个链：PREROUTING, OUTPUT</li>
</ol>
<p>看到这些排列组合，可能已经凌乱了，可以看下面的这张图，<code>conntrack</code> 理解为 <code>raw</code> 表，来自：<a href="http://linux-ip.net/pages/diagrams.html#netfilter-kernel-packet-traversal" target="_blank" rel="noopener nofollow">Netfilter Kernel (Packet) Traversal</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202412/1929786-20241224180931964-769258297.png" alt="" loading="lazy"></p>
<p>Netfilter 内核数据包遍历就像保卫萝卜（塔防游戏）一样，数据包就像游戏中的怪物，会按照特定的路径移动，链就像在特定位置安置的炮塔，<strong>当数据包经过某个链时，链就会对数据包进行一些操作</strong>，链中包含若干条规则</p>
<p>既然已经有了链，可以在数据包的不同阶段执行特定操作，为什么还需要表呢？原因是不同规则的执行顺序可能会影响结果。比如，有两条规则：</p>
<ol>
<li>对数据包执行 SNAT</li>
<li>对数据包的源 IP 进行过滤</li>
</ol>
<p>如果先执行 SNAT，过滤操作会基于 SNAT 修改后的 IP 和端口进行匹配。但如果先执行过滤，数据包可能在 SNAT 应用之前就被过滤掉了。每个表的操作结果都会影响后续表的处理，所以 <strong>表的作用是将规则按照功能进行分类，避免执行顺序导致规则失效</strong>。表的处理顺序：<code>raw -&gt; mangle -&gt; nat -&gt; filter</code></p>
<p>注意：<strong>相同表中相同链中如果多个规则匹配同一个数据包，则只有第一个匹配的规则会被执行</strong></p>
<p>需要注意的是，在使用 iptables 命令时，如果没有指定表，默认表是 filter（最后处理的那个表）</p>
<pre><code class="language-sh"># 手动指定 -t 为 nat 表
iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 80
</code></pre>
<h2 id="持久化">持久化</h2>
<p>iptables 规则存储在内存中，<strong>系统重启后规则会丢失</strong>，可以安装 <code>iptables-persistent</code> 来持久化规则，规则保存在 <code>/etc/iptables/rules.v4</code></p>
<pre><code class="language-sh">sudo apt update
sudo apt install iptables-persistent
</code></pre>
<p>配置好 iptables 规则后，需要手动运行以下命令持久化规则：</p>
<pre><code class="language-sh">sudo netfilter-persistent save
</code></pre>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zh.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener nofollow">iptables - wiki</a><br>
<a href="https://tinychen.com/20200414-iptables-principle-introduction/" target="_blank" rel="noopener nofollow">iptables的四表五链与NAT工作原理</a><br>
<a href="https://www.cnblogs.com/paul8339/p/14688156.html" target="_blank">iptables做TCP/UDP端口转发【转】</a><br>
<a href="https://xstarcd.github.io/wiki/Linux/iptables_forward_internetshare.html" target="_blank" rel="noopener nofollow">通过iptables实现端口转发和内网共享上网</a><br>
<a href="https://serverfault.com/a/563036" target="_blank" rel="noopener nofollow">iptables error: unknown option --dport</a><br>
<a href="https://unix.stackexchange.com/a/189906" target="_blank" rel="noopener nofollow">How iptables tables and chains are traversed</a><br>
<a href="https://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener nofollow">[译] NAT - 网络地址转换（2016）</a><br>
<a href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener nofollow">[译] 深入理解 iptables 和 netfilter 架构</a><br>
<a href="https://cloud.tencent.com/developer/article/1718100" target="_blank" rel="noopener nofollow">VMware实现iptables NAT及端口映射</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.021801411811342594" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 08:31">2024-12-27 08:31</span>&nbsp;
<a href="https://www.cnblogs.com/aaronlinv">AaronLin</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18628447" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18628447);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18628447', targetLink: 'https://www.cnblogs.com/aaronlinv/p/18628447', title: '重拾 iptables' })">举报</a>
</div>
        