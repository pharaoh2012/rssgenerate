
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pythonista/p/18669415" title="发布于 2025-01-13 20:29">
    <span role="heading" aria-level="2">为什么在 Python 中 hash(-1) == hash(-2)?</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>英文：<a href="https://omairmajid.com/posts/2021-07-16-why-is-hash-in-python" target="_blank" rel="noopener nofollow">https://omairmajid.com/posts/2021-07-16-why-is-hash-in-python</a></p>
<p>作者：Omair Majid</p>
<p>译者：豌豆花下猫&amp;Claude-3.5-Sonnet</p>
<p>时间：原文发布于 2021.07.16，翻译于 2025.01.11</p>
<p>收录于：Python为什么系列  <a href="https://github.com/chinesehuazhou/python-whydo" target="_blank" rel="noopener nofollow">https://github.com/chinesehuazhou/python-whydo</a></p>
<p>当我在<a href="https://xkcd.com/303/" target="_blank" rel="noopener nofollow">等待代码编译</a>的时候，我在 Reddit 的 r/Python 上看到了这个问题：</p>
<blockquote>
<p><a href="https://www.reddit.com/r/Python/comments/oks5km/is_hash_1hash2_an_easter_egg/" target="_blank" rel="noopener nofollow">hash(-1) == hash(-2) 是个彩蛋吗？</a></p>
</blockquote>
<p>等等，这是真的吗？</p>
<pre><code class="language-python">$ python
Python 3.9.6 (default, Jun 29 2021, 00:00:00)
[GCC 11.1.1 20210531 (Red Hat 11.1.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash(-1)
-2
&gt;&gt;&gt; hash(-2)
-2
&gt;&gt;&gt; hash(-1) == hash(-2)
True
</code></pre>
<p>是的，确实如此。真让人惊讶！</p>
<p>让我们看看其它一些常见的哈希值：</p>
<pre><code class="language-python">&gt;&gt;&gt; hash(1)
1
&gt;&gt;&gt; hash(0)
0
&gt;&gt;&gt; hash(3)
3
&gt;&gt;&gt; hash(-4)
-4
</code></pre>
<p>看起来所有小整数的哈希值都等于它们自身，除了 <code>-1</code>...</p>
<p>现在我完全被这个问题吸引住了。我试图自己找出答案。在接下来的内容中，我将带你了解如何自己寻找这个答案。</p>
<p>如何开始呢？什么能给我们一个权威的答案？</p>
<p>让我们看看源代码！Python 的实际实现代码！</p>
<h2 id="获取源代码">获取源代码</h2>
<p>我假设你和我一样，对 Python 的源代码在哪里完全没有概念。</p>
<p>那么，我们（假设从未看过 Python 的源代码）如何获取源代码来回答最初的问题呢？</p>
<p>也许我们可以用 Google？搜索 "python implementation" 会带来一些有趣的结果。</p>
<p>我搜索的 <a href="https://wiki.python.org/moin/PythonImplementations" target="_blank" rel="noopener nofollow">第一个结果</a> 提到了 "CPython 参考实现"。</p>
<p>Github 上 <a href="https://github.com/python" target="_blank" rel="noopener nofollow">Python 组织</a> 的第二个仓库就是 "cpython"。这看起来很靠谱。我们如何确保万无一失呢？</p>
<p>我们可以访问 python.org。让我们去到源码下载页面。最终我找到了 <a href="https://www.python.org/ftp/python/3.9.6/Python-3.9.6.tgz" target="_blank" rel="noopener nofollow">Python 3.9.6 的压缩包 </a>。解压后，<code>README.rst</code> 也指向了 Github 上的 CPython。</p>
<p>好的，这就是我们的起点。让我们获取这些代码，以便后续搜索：</p>
<pre><code class="language-shell">git clone https://github.com/python/cpython --depth 1
</code></pre>
<p><code>--depth 1</code> 参数使 <code>git</code> 只获取有限的历史记录。这样可以让克隆操作快很多。如果之后需要完整的历史记录，我们可以再获取。</p>
<h2 id="让我们深入研究">让我们深入研究</h2>
<p>在研究代码时，我们需要找到一个起点。最好是容易搜索的东西，比如一个简单的字符串，不会有太多误导性的匹配。</p>
<p>也许我们可以使用 <code>hash</code> 函数的文档？我们可以用 <code>help(hash)</code> 来查看文档内容：</p>
<pre><code class="language-python">&gt;&gt;&gt; hash
&lt;built-in function hash&gt;
&gt;&gt;&gt; help(hash)
Help on built-in function hash in module builtins:

hash(obj, /)
    Return the hash value for the given object.

    Two objects that compare equal must also have the same hash value, but the
    reverse is not necessarily true.
</code></pre>
<p>现在，我们可以用它来找到 <code>hash()</code> 的实现：</p>
<pre><code class="language-python">$ grep -r 'Return the hash value'
Python/clinic/bltinmodule.c.h:"Return the hash value for the given object.\n"
Python/bltinmodule.c:Return the hash value for the given object.
Doc/library/functions.rst:   Return the hash value of the object (if it has one).  Hash values are
Lib/hmac.py:        """Return the hash value of this hashing object.
</code></pre>
<p><code>hmac</code> 可能与加密的 HMAC 实现有关，所以我们可以忽略它。<code>functions.rst</code> 是一个文档文件，所以也可以忽略。</p>
<p><code>Python/bltinmodule.c</code> 看起来很有趣。如果我们查看这个文件，会找到这样一段代码：</p>
<pre><code class="language-python">/*
...
Return the hash value for the given object.

Two objects that compare equal must also have the same hash value, but the
reverse is not necessarily true.
[clinic start generated code]*/

static PyObject *
builtin_hash(PyObject *module, PyObject *obj)
/*[clinic end generated code: output=237668e9d7688db7 input=58c48be822bf9c54]*/
{
    Py_hash_t x;

    x = PyObject_Hash(obj);
    if (x == -1)
        return NULL;
    return PyLong_FromSsize_t(x);
}
</code></pre>
<p>搜索 <code>PyLong</code> 带我来到<a href="https://docs.python.org/3/c-api/long.html" target="_blank" rel="noopener nofollow">这里</a>。看起来 <code>PyLongObject</code> 是 Python 整数的原生表示（这在稍后会派上用场）。在浏览了 <code>PyLongObject</code> 文档并重读这段代码后，看起来是这样的：</p>
<ol>
<li>我们调用 <code>PyObject_Hash</code> 来获得一个对象的哈希值</li>
<li>如果计算出的哈希值是 -1，那表示是一个错误
<ul>
<li>看起来我们用 -1 来表示错误，所以没有哈希函数会为真实对象计算出 -1</li>
</ul>
</li>
<li>我们将 <code>Py_Ssize_t</code> 转换为 <code>PyLongObject</code>（文档中称之为："这是 PyObject 的子类型，表示一个 Python 整数对象"）</li>
</ol>
<p>啊哈！这就解释了为什么 <code>hash(0)</code> 是 <code>0</code>，<code>hash(1)</code> 是 <code>1</code>，<code>hash(-2)</code> 是 <code>-2</code>，但 <code>hash(-1)</code> 不是 <code>-1</code>。这是因为 <code>-1</code> 在内部被用来表示错误。</p>
<p>但为什么 <code>hash(-1)</code> 是 <code>-2</code> 呢？是什么将它设置成了这个值？</p>
<p>让我们看看能否找出原因。</p>
<p>我们可以先查找 <code>PyObject_Hash</code> 。让我们搜索一下。</p>
<pre><code class="language-python">$ ag PyObject_Hash
...
Objects/rangeobject.c
552:    result = PyObject_Hash(t);

Objects/object.c
777:PyObject_HashNotImplemented(PyObject *v)
785:PyObject_Hash(PyObject *v)
802:    return PyObject_HashNotImplemented(v);

Objects/classobject.c
307:    y = PyObject_Hash(a-&gt;im_func);
538:    y = PyObject_Hash(PyInstanceMethod_GET_FUNCTION(self));
...
</code></pre>
<p>虽然有很多干扰，但唯一的实现似乎在 <code>Objects/object.c</code> 中：</p>
<pre><code class="language-python">Py_hash_t
PyObject_Hash(PyObject *v)
{
    PyTypeObject *tp = Py_TYPE(v);
    if (tp-&gt;tp_hash != NULL)
        return (*tp-&gt;tp_hash)(v);
    /* 为了保持通用做法：在 C 代码中仅从 object 继承的类型，应该无需显式调用 PyType_Ready 就能工作，
     * 我们在这里隐式调用 PyType_Ready，然后再次检查 tp_hash 槽
     */
    if (tp-&gt;tp_dict == NULL) {
        if (PyType_Ready(tp) &lt; 0)
            return -1;
        if (tp-&gt;tp_hash != NULL)
            return (*tp-&gt;tp_hash)(v);
    }
    /* Otherwise, the object can't be hashed */
    return PyObject_HashNotImplemented(v);
}
</code></pre>
<p>这段代码相当令人困惑。幸运的是，注释很清晰。在多次阅读后，似乎这段代码——考虑到类型的一些延迟加载（？）——先找到对象的类型（使用 <code>Py_TYPE</code>）。然后寻找该类型的 <code>tp_hash</code> 函数，并在 v 上调用该函数：<code>(*tp-&gt;tp_hash)(v)</code></p>
<p>我们在哪里能找到 <code>-1</code> 的 <code>tp_hash</code> 呢？让我们再次搜索 <code>tp_hash</code>：</p>
<pre><code class="language-python">$ ag tp_hash -l
...
Modules/_multiprocessing/semaphore.c
Objects/sliceobject.c
Objects/moduleobject.c
Objects/exceptions.c
Modules/_pickle.c
Objects/frameobject.c
Objects/setobject.c
Objects/rangeobject.c
Objects/longobject.c
Objects/object.c
Objects/methodobject.c
Objects/classobject.c
Objects/enumobject.c
Objects/odictobject.c
Objects/complexobject.c
...
</code></pre>
<p>这是一个很长的列表。回想一下文档中关于 <code>PyLongObject</code> 的说明（"这个...表示一个 Python 整数对象"），我先查看下 <code>Objects/longobject.c</code> ：</p>
<pre><code class="language-python">PyTypeObject PyLong_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "int",                                      /* tp_name */
    offsetof(PyLongObject, ob_digit),           /* tp_basicsize */
    sizeof(digit),                              /* tp_itemsize */
    0,                                          /* tp_dealloc */
    0,                                          /* tp_vectorcall_offset */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_as_async */
    long_to_decimal_string,                     /* tp_repr */
    &amp;long_as_number,                            /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    (hashfunc)long_hash,                        /* tp_hash */
    ...
</code></pre>
<p>所以 <code>PyLongObject</code> 类型对象的 <code>tp_hash</code> 是 <code>long_hash</code>。让我们看看这个函数。</p>
<pre><code class="language-python">static Py_hash_t
long_hash(PyLongObject *v)
{
    Py_uhash_t x;
    Py_ssize_t i;
    int sign;

    ...

    if (x == (Py_uhash_t)-1)
        x = (Py_uhash_t)-2;
    return (Py_hash_t)x;
}
</code></pre>
<p>注意我删除了大部分实现细节。但这个函数的结尾正好符合我们的预期：<code>-1</code> 被保留用作错误信号，所以代码明确地将该返回值转换为 <code>-2</code>！</p>
<p>这就解释了为什么 <code>hash(-1)</code> 最终与 <code>hash(-2)</code> 相同。这不是一个彩蛋，只是为了避免使用 <code>-1</code> 作为 <code>hash()</code> 方法的返回值，因此采取的变通方法。</p>
<h2 id="这是正确完整的答案吗">这是正确/完整的答案吗？</h2>
<p>如前所述，我从未看过 Python 代码库。我认为自己找到了答案。但这是对的吗？我可能完全错了。</p>
<p>幸运的是，<a href="https://www.reddit.com/r/Python/comments/oks5km/is_hash_1hash2_an_easter_egg/h5a7ylc/" target="_blank" rel="noopener nofollow">/u/ExoticMandibles 在 Reddit 帖子中提供了答案</a>：</p>
<blockquote>
<p>Python 的参考实现是 "CPython"，这很可能就是你正在使用的 Python。CPython 是用 C 语言编写的，与 Python 不同，C 语言没有异常处理。所以，在 C 语言中，当你设计一个函数，并且想要表示"发生了错误"时，必须通过返回值来表示这个错误。</p>
<p>CPython 中的 hash() 函数可能返回错误，所以它定义返回值 -1 表示"发生了错误"。但如果哈希计算正确，而对象的实际哈希值恰好是 -1，这可能会造成混淆。所以约定是：如果哈希计算成功，并得到值是 -1，就返回 -2。</p>
<p>在 CPython 中，整数（"长整型对象"）的哈希函数中有专门的代码来处理这种情况：</p>
<p><a href="https://github.com/python/cpython/blob/main/Objects/longobject.c#L2967" target="_blank" rel="noopener nofollow">https://github.com/python/cpython/blob/main/Objects/longobject.c#L2967</a></p>
</blockquote>
<p>这正是我通过阅读代码推测出的结果。</p>
<h2 id="结论">结论</h2>
<p>我从一个看似难以回答的问题开始。但是通过几分钟的代码探索——Python 整洁的代码库使得查看它的代码比我见过的其它代码库要容易得多——很容易就发现和理解了答案！如果你接触过计算机，这应该不足为奇。这里没有魔法，只有层层的抽象和代码。</p>
<p>如果本文有什么启示的话，那就是：<a href="https://wiki.c2.com/?UseTheSourceLuke" target="_blank" rel="noopener nofollow">查看源代码！</a> （文档可能会过时，注释可能不准确，但源码是永恒的。）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5908235058506944" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 20:30">2025-01-13 20:29</span>&nbsp;
<a href="https://www.cnblogs.com/pythonista">豌豆花下猫</a>&nbsp;
阅读(<span id="post_view_count">40</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18669415" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18669415);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18669415', targetLink: 'https://www.cnblogs.com/pythonista/p/18669415', title: '为什么在 Python 中 hash(-1) == hash(-2)?' })">举报</a>
</div>
        