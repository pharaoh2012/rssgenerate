
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18740366" title="发布于 2025-02-27 10:14">
    <span role="heading" aria-level="2">Svelte 最新中文文档教程（21）—— 自定义元素</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p><a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">Svelte</a>，一个语法简洁、入门容易，面向未来的前端框架。</p>
<p>从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://yayujs-blog.oss-cn-beijing.aliyuncs.com/405488775-48df16b1-939c-489b-8d52-6071869893f0.png" alt="image.png" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目</strong>。</p>
<p>为了帮助大家学习 Svelte，我同时搭建了 Svelte 最新的<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">中文文档</a>站点。</p>
<p>如果需要进阶学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上<a href="https://t.zsxq.com/DfGhx" target="_blank" rel="noopener nofollow">“前端大佬成长之路”</a>。</p>
<h2 id="自定义元素">自定义元素</h2>

<p>Svelte 组件也可以使用 <code>customElement: true</code> 编译器选项编译为自定义元素（又称 Web 组件）。你应该使用 <code>&lt;svelte:options&gt;</code> <a href="https://svelte.yayujs.com/docs/svelte/svelte-options" target="_blank" rel="noopener nofollow">元素</a> 为组该件指定一个标签名。</p>
<pre><code class="language-svelte">&lt;svelte:options customElement="my-element" /&gt;

&lt;script&gt;
  let { name = 'world' } = $props();
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
&lt;slot /&gt;
</code></pre>
<p>对于那些你不想暴露的内部组件，你可以省略标签名，并像使用常规 Svelte 组件一样使用它们。如果需要，组件的使用者仍然可以在之后通过静态 <code>element</code> 属性来命名它，该属性包含自定义元素构造函数，并且在 <code>customElement</code> 编译器选项为 <code>true</code> 时可用。</p>
<pre><code class="language-js">// @noErrors
import MyElement from './MyElement.svelte';

customElements.define('my-element', MyElement.element);
</code></pre>
<p>一旦自定义元素被定义，它就可以作为常规 DOM 元素一样使用：</p>
<pre><code class="language-js">document.body.innerHTML = `
  &lt;my-element&gt;
    &lt;p&gt;这是一些插槽内容&lt;/p&gt;
  &lt;/my-element&gt;
`;
</code></pre>
<p>任何 <a href="https://svelte.yayujs.com/docs/svelte/basic-markup#Component-props" target="_blank" rel="noopener nofollow">props</a> 都会作为 DOM 元素的属性暴露出来（并且在可能的情况下作为属性可读/可写）。</p>
<pre><code class="language-js">// @noErrors
const el = document.querySelector('my-element');

// 获取 'name' 属性的当前值
console.log(el.name);

// 设置新值，更新 shadow DOM
el.name = 'everybody';
</code></pre>
<p>注意，你需要明确列出所有属性，即在 <a href="https://svelte.yayujs.com/docs/svelte/custom-elements#Component-options" target="_blank" rel="noopener nofollow">组件选项</a> 中没有声明 <code>props</code> 时使用 <code>let props = $props()</code> 意味着 Svelte 无法知道要在 DOM 元素上暴露哪些属性。</p>
<h2 id="组件生命周期">组件生命周期</h2>
<p>自定义元素是使用包装器方法从 Svelte 组件创建的。这意味着内部 Svelte 组件并不知道它是一个自定义元素。自定义元素包装器负责适当地处理其生命周期。</p>
<p>当创建一个自定义元素时，它包裹的 Svelte 组件并不会立即创建。只有在调用 <code>connectedCallback</code> 后的下一个 tick 中创建。在将自定义元素插入 DOM 之前分配给它的属性会被临时保存，然后在组件创建时设置，因此它们的值不会丢失。</p>
<p>但是这对于调用自定义元素上导出的函数并不奏效,它们只有在元素挂载后才可用。如果你需要在组件创建之前调用函数,可以使用 <a href="https://svelte.yayujs.com/docs/svelte/custom-elements#Component-options" target="_blank" rel="noopener nofollow"><code>extend</code> 选项</a> 选项来解决这个问题。</p>
<p>当使用 Svelte 编写的自定义元素被创建或更新时，shadow DOM 将在下一个 tick 反映该值，而不是立即反映。这种方式可以对更新进行批处理，并且临时（但同步地）将元素从 DOM 中分离的 DOM 移动不会导致内部组件被卸载。</p>
<p>内部 Svelte 组件会在调用 <code>disconnectedCallback</code> 后的下一个 tick 中被销毁。</p>
<h2 id="组件选项">组件选项</h2>
<p>构造自定义元素时，自 Svelte 4 起，你可以通过在 <code>&lt;svelte:options&gt;</code> 中定义 <code>customElement</code> 为一个对象来定制多个方面。这个对象可以包含以下属性：</p>
<ul>
<li><code>tag: string</code>：自定义元素名称的可选 <code>tag</code> 属性。如果设置,则在导入此组件时,会在文档的 <code>customElements</code> 注册表中定义具有此标记名称的自定义元素。</li>
<li><code>shadow</code>：一个可选属性，可以设置为 <code>"none"</code> 以避免创建 shadow root。注意，样式就不再被封装，并且你不能使用插槽</li>
<li><code>props</code>：一个可选属性，用于修改组件属性的某些细节和行为。它提供以下设置：
<ul>
<li><code>attribute: string</code>：要更新自定义元素的 prop，您有两个替代方法：要么像上面演示的那样在自定义元素的引用上设置属性，要么使用 HTML 属性。对于后者，默认属性名称是小写的属性名。通过分配 <code>attribute: "&lt;desired name&gt;"</code> 来修改此项。</li>
<li><code>reflect: boolean</code>：默认情况下，更新后的 prop 值不会反映到 DOM 上。要启用此行为，设置 <code>reflect: true</code>。</li>
<li><code>type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'</code>：在将属性值转换为 prop 值并反映回去时，prop 值默认为 <code>String</code>。这可能并不总是准确的。例如，对于数字类型，使用 <code>type: "Number"</code> 定义。您不需要列出所有属性，未列出的属性将使用默认设置。</li>
</ul>
</li>
<li><code>extend</code>：一个可选属性，它期望一个函数作为其参数。它会传入由 Svelte 生成的自定义元素类，并期望返回一个自定义元素类。如果你对自定义元素的生命周期有非常具体的要求，或者想要增强该类，例如使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals#examples" target="_blank" rel="noopener nofollow">ElementInternals</a> 以获得更好的 HTML 表单集成，这会很有用。</li>
</ul>
<pre><code class="language-svelte">&lt;svelte:options
  customElement={{
    tag: 'custom-element',
    shadow: 'none',
    props: {
      name: { reflect: true, type: 'Number', attribute: 'element-index' }
    },
    extend: (customElementConstructor) =&gt; {
      // 扩展类，以便让它参与 HTML 表单
      return class extends customElementConstructor {
        static formAssociated = true;

        constructor() {
          super();
          this.attachedInternals = this.attachInternals();
        }

        // 在这里添加函数，而不是在下面的组件中
        // 这样它始终可用，而不仅仅是在内部 Svelte 组件
        // 挂载时才可用
        randomIndex() {
          this.elementIndex = Math.random();
        }
      };
    }
  }}
/&gt;

&lt;script&gt;
  let { elementIndex, attachedInternals } = $props();
  // ...
  function check() {
    attachedInternals.checkValidity();
  }
&lt;/script&gt;

...
</code></pre>
<h2 id="注意事项和限制">注意事项和限制</h2>
<p>自定义元素可以作为一种有用的方式来打包组件以在非 Svelte 应用程序中使用，因为它们可以与原生 HTML 和 JavaScript 以及<a href="https://custom-elements-everywhere.com/" target="_blank" rel="noopener nofollow">大多数框架</a>一起工作。然而，有一些重要的差异需要注意：</p>
<ul>
<li>样式是<em>封装的</em>，而不是仅仅 <em>scoped</em> 的（除非你设置 <code>shadow: "none"</code>）。这意味着任何非组件样式（比如你在 <code>global.css</code> 文件中的样式）都不会应用到自定义元素上，包括带有 <code>:global(...)</code> 修饰符的样式</li>
<li>样式被内联到组件中作为 JavaScript 字符串，而不是被提取出来作为单独的 .css 文件。</li>
<li>自定义元素通常不适合服务端渲染，因为在 JavaScript 加载之前，shadow DOM 是不可见的</li>
<li>在 Svelte 中，插槽内容是<em>延迟</em>渲染的。在 DOM 中，它是<em>立即</em>渲染的。换句话说，即使组件的 <code>&lt;slot&gt;</code> 元素在 <code>{#if ...}</code> 块内，它也会始终被创建。类似地，在 <code>{#each ...}</code> 块中包含 <code>&lt;slot&gt;</code> 不会导致插槽内容被多次渲染</li>
<li>已废弃的 <code>let:</code> 指令没有效果，因为自定义元素没有办法将数据传递给填充插槽的父组件</li>
<li>需要 polyfills 来支持较旧的浏览器</li>
<li>你可以在自定义元素内的常规 Svelte 组件之间使用 Svelte 的上下文功能，但不能在自定义元素之间使用。换句话说，您不能在父自定义元素上使用 <code>setContext</code> 并在子自定义元素中用 <code>getContext</code> 读取它。</li>
</ul>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>点击查看《<a href="https://svelte.yayujs.com/docs/svelte/custom-elements" target="_blank" rel="noopener nofollow">Svelte 自定义元素</a>》介绍。</p>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上<a href="https://t.zsxq.com/DfGhx" target="_blank" rel="noopener nofollow">“前端大佬成长之路”</a>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="17.953831774768517" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-27 10:15">2025-02-27 10:14</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18740366" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18740366);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18740366', targetLink: 'https://www.cnblogs.com/yayujs/p/18740366', title: 'Svelte 最新中文文档教程（21）—— 自定义元素' })">举报</a>
</div>
        