
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/handsometaoa/p/18723172" title="发布于 2025-03-13 21:54">
    <span role="heading" aria-level="2">学习高可靠Redis分布式锁实现思路</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一分布式锁的必要性">一、分布式锁的必要性</h2>
<p>在单体应用时代，我们使用<code>ReentrantLock</code>或<code>synchronized</code>就能解决线程安全问题。但当系统拆分为分布式架构后（目前大多数公司应该不会只是单体应用了），<strong>跨进程的共享资源竞争</strong>就成了必须要解决的问题。</p>
<p>分布式锁由此应运而生，但是必须解决三大核心问题：</p>
<ol>
<li>竞态条件：多人操作共享资源，顺序不可控</li>
<li>锁失效：锁自动过期但业务未执行完，其他客户端抢占资源 <strong>/</strong> 加锁成功但未设置过期时间，服务宕机导致死锁</li>
<li>锁误删：客户端A释放了客户端B持有的锁。</li>
</ol>
<h2 id="二核心实现解析附源码">二、核心实现解析（附源码）</h2>
<h3 id="21-原子性加锁">2.1 原子性加锁</h3>
<pre><code class="language-lua">local lockKey = KEYS[1]              -- 锁的键名，如"order_lock_123"
local lockSecret = ARGV[1]           -- 锁的唯一标识（建议UUID）
local expireTime = tonumber(ARGV[2]) -- 过期时间（单位：秒）

-- 参数有效性校验
if not expireTime or expireTime &lt;= 0 then
    return "0" -- 参数非法直接返回失败
end

-- 原子操作：SET lockKey lockSecret NX EX expireTime
local result = redis.call("set", lockKey, lockSecret, "NX", "EX", expireTime)
return result and "1" or "0" -- 成功返回"1"，失败返回"0"
</code></pre>
<p><strong>设计思路：</strong></p>
<ul>
<li>value使用客户端唯一标识（推荐SnowflakeID）</li>
<li>参数校验：防止传入非法过期时间</li>
<li>原子性：单命令完成"判断+设置+过期"操作</li>
</ul>
<h3 id="22-看门狗续期机制">2.2 看门狗续期机制</h3>
<pre><code class="language-lua">local lockKey = KEYS[1]              -- 锁的键名
local lockSecret = ARGV[1]           -- 锁标识
local expireTime = tonumber(ARGV[2]) -- 新的过期时间

-- 参数校验
if not expireTime or expireTime &lt;= 0 then
    return "0"
end

-- 获取当前锁的值
local storedSecret = redis.call("get", lockKey)

-- 续期逻辑
if storedSecret == lockSecret then
    -- 值匹配则延长过期时间
    local result = redis.call("expire", lockKey, expireTime)
    return result == 1 and "1" or "0" -- 续期成功返回"1"
else
    -- 锁不存在或值不匹配
    return "0"
end
</code></pre>
<pre><code class="language-java">// 定时续约线程
watchdogExecutor.scheduleAtFixedRate(() -&gt; {
    locks.entrySet().removeIf(entry -&gt; entry.getValue().isCancelled());
    for (Entry&lt;String, Lock&gt; entry : locks.entrySet()) {
        if (!entry.getValue().isCancelled()) {
            String result = redisTemplate.execute(RENEWAL_SCRIPT, 
                Collections.singletonList(key), 
                lock.value, "30");
            if ("0".equals(result)) lock.cancel();
        }
    }
}, 0, 10, TimeUnit.SECONDS);
</code></pre>
<p><strong>设计思路：</strong></p>
<ul>
<li>续期间隔=过期时间/3（如30s过期则10s续期）</li>
<li>异步线程池需单独配置</li>
<li>双重校验锁状态（内存标记+Redis实际值）</li>
</ul>
<h3 id="23-安全释放锁">2.3 安全释放锁</h3>
<pre><code class="language-lua">local lockKey = KEYS[1]       -- 锁的键名
local lockSecret = ARGV[1]    -- 要释放的锁标识

-- 获取当前锁的值
local storedSecret = redis.call("get", lockKey)

-- 校验锁归属
if storedSecret == lockSecret then
    -- 值匹配则删除Key
    return redis.call("del", lockKey) == 1 and "1" or "0"
else
    -- 值不匹配
    return "0" 
end
</code></pre>
<p><strong>设计思路：</strong></p>
<ul>
<li>校验value避免误删其他线程的锁</li>
</ul>
<h2 id="三源码">三、源码</h2>
<pre><code class="language-java">package org.example.tao.util;

import com.alibaba.fastjson2.JSON;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.RedisScript;

import javax.annotation.PreDestroy;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class RedisUtils {

    static class Lock {
        private final String value;
        private volatile boolean isCancelled = false;

        public Lock(String value) {
            this.value = value;
        }

        public boolean isCancelled() {
            return isCancelled;
        }

        public void cancel() {
            isCancelled = true;
        }
    }

    private static final String LOCK_LUA = "local lockKey = KEYS[1]\n" + "local lockSecret = ARGV[1]\n" + "local expireTime = tonumber(ARGV[2])  -- 动态过期时间\n" + "if not expireTime or expireTime &lt;= 0 then\n" + "    return \"0\"\n" + "end\n" + "local result = redis.call(\"set\", lockKey, lockSecret, \"NX\", \"EX\", expireTime)\n" + "return result and \"1\" or \"0\"";
    private static final String RELEASE_LOCK_LUA = "local lockKey = KEYS[1]\n" + "local lockSecret = ARGV[1]\n" + "local storedSecret = redis.call(\"get\", lockKey)\n" + "if storedSecret == lockSecret then\n" + "    return redis.call(\"del\", lockKey) == 1 and \"1\" or \"0\"\n" + "else\n" + "    return \"0\"\n" + "end";
    private static final String RENEWAL_LUA = "local lockKey = KEYS[1]\n" + "local lockSecret = ARGV[1]\n" + "local expireTime = tonumber(ARGV[2])\n" + "if not expireTime or expireTime &lt;= 0 then\n" + "    return \"0\"\n" + "end\n" + "local storedSecret = redis.call(\"get\", lockKey)\n" + "if storedSecret == lockSecret then\n" + "    local result = redis.call(\"expire\", lockKey, expireTime)\n" + "    return result == 1 and \"1\" or \"0\"\n" + "else\n" + "    return \"0\"\n" + "end";

    private final String defaultExpireTime = "30";
    private final RedisTemplate&lt;String, String&gt; redisTemplate;
    private final Map&lt;String, Lock&gt; locks = new ConcurrentHashMap&lt;&gt;();
    private final ScheduledExecutorService watchdogExecutor = Executors.newScheduledThreadPool(1);

    public RedisUtils(RedisTemplate&lt;String, String&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
        watchdogExecutor.scheduleAtFixedRate(() -&gt; {
            try {
                System.out.println("watchdogExecutor 执行中... locks =&gt; " + JSON.toJSONString(locks));
                locks.entrySet().removeIf(entry -&gt; entry.getValue().isCancelled());
                for (Map.Entry&lt;String, Lock&gt; entry : locks.entrySet()) {
                    String key = entry.getKey();
                    Lock lock = entry.getValue();
                    if (!lock.isCancelled()) {
                        RedisScript&lt;String&gt; redisScript = RedisScript.of(RENEWAL_LUA, String.class);
                        String result = redisTemplate.execute(redisScript, Collections.singletonList(key), lock.value, defaultExpireTime);
                        if (Objects.equals(result, "0")) {
                            lock.cancel(); // 移除已经释放的锁
                        }
                    }
                }
            } catch (Exception e) {
                System.err.println("看门狗任务执行失败: " + e.getMessage());
            }
        }, 0, 10, TimeUnit.SECONDS);
    }

    public boolean acquireLock(String key, String value) {
        RedisScript&lt;String&gt; redisScript = RedisScript.of(LOCK_LUA, String.class);
        String result = redisTemplate.execute(redisScript, Collections.singletonList(key), value, defaultExpireTime);
        if (Objects.equals(result, "1")) {
            locks.put(key, new Lock(value));
            return true;
        }
        return false;
    }

    public boolean acquireLockWithRetry(String key, String value, int maxRetries, long retryIntervalMillis) {
        int retryCount = 0;
        while (retryCount &lt; maxRetries) {
            boolean result = this.acquireLock(key, value);
            if (result) {
                locks.put(key, new Lock(value));
                return true;
            }
            retryCount++;
            try {
                Thread.sleep(retryIntervalMillis);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        return false;
    }

    public boolean releaseLock(String key, String value) {
        RedisScript&lt;String&gt; redisScript = RedisScript.of(RELEASE_LOCK_LUA, String.class);
        String result = redisTemplate.execute(redisScript, Collections.singletonList(key), value);
        if (Objects.equals(result, "1")) {
            Lock lock = locks.get(key);
            if (lock != null) {
                lock.cancel();
            }
            return true;
        }
        return false;
    }

    @PreDestroy
    public void shutdown() {
        watchdogExecutor.shutdown();
        try {
            if (!watchdogExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                watchdogExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            watchdogExecutor.shutdownNow();
        }
    }
}

</code></pre>
<h2 id="四如何使用">四、如何使用</h2>
<h3 id="41-配置类">4.1 配置类</h3>
<pre><code>@Configuration
public class AppConfig {

    @Resource
    private RedisTemplate&lt;String, String&gt; redisTemplate;

    @Bean
    public RedisUtils init() {
        return new RedisUtils(redisTemplate);
    }

}
</code></pre>
<h3 id="42-使用">4.2 使用</h3>
<pre><code>@RestController
@RequestMapping("/users")
public class UserController {
    @Resource
    private RedisTemplate&lt;String, String&gt; redisTemplate;


    @PostMapping("/test2")
    public Boolean test2(@RequestBody Map&lt;String, String&gt; map) {
        boolean res;
        if (Objects.equals(map.get("lockFlag"), "true")) {
            res = redisUtils.acquireLock(map.get("key"), map.get("value"));
        } else {
            res = redisUtils.releaseLock(map.get("key"), map.get("value"));
        }
        return res;
    }

}
</code></pre>
<h2 id="后记">后记</h2>
<p>还是免责声明，仅供学习参考</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/handsometaoa/" target="_blank">帅气的涛啊</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/handsometaoa/p/18723172" target="_blank">https://www.cnblogs.com/handsometaoa/p/18723172</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5423573860046297" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 21:55">2025-03-13 21:54</span>&nbsp;
<a href="https://www.cnblogs.com/handsometaoa">帅气的涛啊</a>&nbsp;
阅读(<span id="post_view_count">87</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18723172" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18723172);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18723172', targetLink: 'https://www.cnblogs.com/handsometaoa/p/18723172', title: '学习高可靠Redis分布式锁实现思路' })">举报</a>
</div>
        