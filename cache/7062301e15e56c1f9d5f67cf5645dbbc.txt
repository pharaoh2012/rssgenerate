
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengbiaobiao2016/p/18702338" title="发布于 2025-02-07 11:46">
    <span role="heading" aria-level="2">Java虚拟线程探索</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在Java 21中，引入了虚拟线程，这是一个非常非常重要的特性，之前一直苦苦寻找的Java协程，终于问世了。在高并发以及IO密集型的应用中，虚拟线程能极大的提高应用的性能和吞吐量。</p>
<h2 id="什么是虚拟线程">什么是虚拟线程</h2>
<p>先来看一下虚拟线程的概念。</p>
<h3 id="虚拟线程概念">虚拟线程概念</h3>
<p>DK 21 引入了虚拟线程的支持，这是为了改善 Java 应用程序在高并发场景下的性能。虚拟线程是一种轻量级线程，<strong>具有较小的内存占用，能够更高效地进行上下文切换，适用于 I/O 密集型的应用程序</strong>。</p>
<h3 id="虚拟线程的工作原理">虚拟线程的工作原理</h3>
<p>当应用程序启动一个虚拟线程时，JVM会将这个虚拟线程交给JVM底层的线程池去执行，这个底层的线程池是一个传统线程池，并且真正执行虚拟线程中任务的线程，也是传统线程（操作系统线程）。当虚拟线程遇到阻塞时，JVM会立刻将虚拟线程挂起，让其它虚拟线程执行。也就是说，开启一个虚拟线程，并不需要启用一个传统线程，一般一个传统线程，可以执行多个虚拟线程的任务。在执行过程中，可以把虚拟线程理解成任务task。</p>
<p>这里举一个列子，假设用户创建了1000个虚拟线程，JVM的执行虚拟线程的线程池线程数是10，那么当第一个虚拟线程V1需要执行时，JVM会将V1调度到传统线程T1上，以此类推，虚拟线程V2会被调度到传统线程T2上，那么V3-&gt;T3，V4-&gt;T4，… V10-&gt;T10。当执行到V11时，这里有三种情况：</p>
<ul>
<li>
<p>如果V1~V10中有任何一个线程遇到阻塞，我们这里假设V3遇到阻塞，那么JVM会将V3挂起，此时T3线程可用，那么V11被T3执行。</p>
</li>
<li>
<p>如果V1~V10没有线程被阻塞，那么JVM根据划分的时间片，假设每个虚拟线程允许执行100ns，那么过了100ns后，这里V1最新执行，JVM则将V1挂起，让T1去执行V11。</p>
</li>
<li>
<p>如果以上两种情况都不满足，那么先将V11挂起，等待有可用的传统线程时，再执行V11。</p>
</li>
</ul>
<p>对于被阻塞的线程，如V3，当IO结束后，操作系统会通过事件，如epoll通知JVM，V3的IO操作已结束，此时JVM重新唤醒V3，选择可用的传统线程，来执行V3的任务。</p>
<p>这里需要注意两点：</p>
<ul>
<li>
<p><strong>虚拟线程IO执行完成后，会通过操作系统的事件通知机制，如epoll来通知JVM。</strong>这一点对于虚拟线程的高效调度至关重要，因为它确保了 阻塞的 I/O 操作 不会占用操作系统线程的时间片，避免了传统线程池的高资源消耗和效率低下。。</p>
</li>
<li>
<p><strong>JVM在对虚拟线程进行上下文切换时，因为不涉及到操作系统级别的线程上下文切换，代价非常低，速度也非常快。</strong></p>
</li>
</ul>
<h3 id="虚拟线程的调度">虚拟线程的调度</h3>
<p>一般来说，程序员不需要对虚拟线程的调度进行管理，在JDK 21中，JVM默认启用了虚拟线程，并且会使用默认的ForkJoinPool线程池来执行虚拟线程，并且线程池的大小，也会根据虚拟线程的数量，进行动态调整。如果需要手动管理执行虚拟线程的线程池大小，那么需要自定义线程池，并将虚拟线程交给自定义的线程池来执行，这样虽然可行，通常没有必要。</p>
<h3 id="虚拟线程与传统线程区别">虚拟线程与传统线程区别</h3>
<p>虚拟线程与传统线程的区别主要在于：</p>
<ul>
<li>
<p>创建虚拟线程时，JVM不会创建一个操作系统线程，创建一个传统线程时，JVM会创建一个操作系统线程。一个传统线程，可以轮询执行多个虚拟线程。</p>
</li>
<li>
<p>虚拟线程是由传统线程来执行的，虚拟线程的调度由JVM控制，传统线程的执行和调度，由操作系统来控制。</p>
</li>
<li>
<p>虚拟线程的上下文切换是由JVM控制的，因为不涉及到操作系统级别线程的上下文切换，虚拟线程上下文切换速度非常快，可以满足高并发需求。</p>
</li>
<li>
<p>创建一个虚拟线程占用的内存非常小，相对而言，创建一个传统线程，占用的内存空间大。在应用中，可以创建大量的虚拟线程，一般支持到百万级，而创建传统线程，一般只能到几千，我们一般也不建议创建这么多传统线程。</p>
</li>
</ul>
<p>虚拟线程类似于task，传统系统与操作系统线程对应，一个传统线程可以执行多个虚拟线程。虚拟线程与task的区别是，当传统线程执行虚拟线程时，遇到阻塞会挂起虚拟线程，当传统线程执行task时，遇到阻塞就真的阻塞了。当然传统中的task继承自runnable，虚拟线程继承自Thread，他们属于不同的类，可调用的方法也不一样。</p>
<p>JDK也提供了虚拟线程池，可以通过下面方式得到一个虚拟线程池。</p>
<pre><code class="language-java">import java.util.concurrent.*;

public class VirtualThreadPoolExample {
    public static void main(String[] args) {
        // 创建一个虚拟线程池
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

        // 提交多个任务到线程池
        for (int i = 0; i &lt; 10; i++) {
            final int taskId = i;
            executor.submit(() -&gt; {
                System.out.println("Task " + taskId + " running in " + Thread.currentThread());
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}

</code></pre>
<p>上面代码中，提交给线程池的任务，JVM都会为其创建一个虚拟线程，然后以虚拟线程的方式执行。</p>
<p>与传统的线程池相比，<strong>虚拟线程池无法设置核心线程数、最大线程数、线程池大小、任务队列等参数，也不需要设置这些参数。</strong></p>
<p>虚拟线程与传统线程的相同之处：</p>
<ul>
<li>
<p>他们都继承自Thread，用法一摸一样。也都支持线程池。</p>
</li>
<li>
<p>与传统一样，虚拟线程也有new，runnable，waiting，blocked，terminated等状态。</p>
</li>
<li>
<p>所有的锁，同步机制，对虚拟线程都适用，并且与传统线程一样，虚拟线程也会有资源争夺以及状态同步问题。并且也有上下文切换，虽然虚拟线程的上下文切换，代价非常小。</p>
</li>
<li>
<p>异常处理机制一样，如果遇到异常不处理，虚拟线程也会终止执行。</p>
</li>
</ul>
<h3 id="虚拟线程与协程的区别">虚拟线程与协程的区别</h3>
<p>协程是python中的异步编程技术，对于IO密集型应用，协程可以发挥很大的优势。协程的异步工作原理与虚拟线程相似，也是遇到IO就阻塞，让主线程继续执行其它任务，当IO完成时，操作系统通过事件机制，如epoll，通知python进程，产生一个事件，放到event loop队列中，最后由主线程执行。</p>
<p>虚拟线程与协程的主要区别在于：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>虚拟线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>并发/并行</td>
<td>虚拟线程是并行的，多个虚拟线程可以同时在多个CPU上运行，同一时刻，可以运行多个虚拟线程。从这个角度将，虚拟线程能支持更高的并发。</td>
<td>协程不是并行的，因为只有一个主线程执行任务事件，同一时刻，只有一个任务被处理。</td>
</tr>
<tr>
<td>资源争夺</td>
<td>虚拟线程中，存在资源争夺问题，以及状态同步问题，在编写代码时，需要考虑并发控制。甚至需要做合理的并发设计。</td>
<td>因为只有一个主线程在执行任务事件，没有并发问题，编程时也不需要考虑并发问题。</td>
</tr>
<tr>
<td>框架支持</td>
<td>虚拟线程是JDK 21的新特性，不需要任何框架支持。</td>
<td>需要框架支持，写异步代码和同步代码，使用的是两个完全不同的框架，另外学习异步编程，增加了学习成本。并且异步编程有些难度，debug也变得复杂些。</td>
</tr>
</tbody>
</table>
<h2 id="怎样使用虚拟线程">怎样使用虚拟线程</h2>
<p>在JDK 21中，使用虚拟线程有两种方式：</p>
<ul>
<li>直接创建并启动虚拟线程。</li>
</ul>
<pre><code class="language-java">public class VirtualThreadExample {
    public static void main(String[] args) {
        Thread virtualThread = Thread.ofVirtual().start(() -&gt; {
            System.out.println("Hello virtual thread ");
        });

        try {
            virtualThread.join();  // 等待虚拟线程完成
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

</code></pre>
<ul>
<li>通过线程池执行虚拟线程。</li>
</ul>
<pre><code class="language-java">import java.util.concurrent.*;

public class VirtualThreadPoolExample {
    public static void main(String[] args) {
        // 创建一个虚拟线程池
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

        // 提交多个任务到线程池
        for (int i = 0; i &lt; 10; i++) {
            final int taskId = i;
            executor.submit(() -&gt; {
                System.out.println("Task " + taskId + " running in " + Thread.currentThread());
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}
</code></pre>
<p><strong>通过线程池执行任务时，无法对并发实现控制，容易造成OOM，或耗尽服务方资源，可以自定义以下虚拟线程池，实现资源控制：</strong></p>
<pre><code class="language-java">package com.zengbiaobiao.demo.vitrualthreaddemo;

import org.springframework.lang.NonNull;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/*****
 * 虚拟线程池，支持配置任务队列数和最大并发任务数
 */
public class VirtualThreadExecutorService extends AbstractExecutorService {

    private volatile boolean shouldStop = false;

    private final ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
    private final Semaphore semaphore;
    private final BlockingQueue&lt;Runnable&gt; taskQueue;

    /******
     * 构造函数
     * @param taskQueueSize，任务队列大小，任务队列是一个阻塞队列，如果任务队列满了，那么调用execute方法会阻塞
     * @param concurrencySize，并发任务大小，同时执行的IO任务个数，防止并发过重，或者资源不够
     */
    public VirtualThreadExecutorService(int taskQueueSize, int concurrencySize) {
        this.semaphore = new Semaphore(concurrencySize);
        taskQueue = new LinkedBlockingQueue&lt;&gt;(taskQueueSize);
        this.loopEvent();
    }

    private void loopEvent() {
        Thread.ofVirtual().name("VirtualThreadExecutor").start(() -&gt; {
            while (!shouldStop) {
                try {
                    Runnable task = taskQueue.take();
                    semaphore.acquire();
                    executor.execute(() -&gt; {
                        try {
                            try {
                                task.run();
                            } finally {
                                semaphore.release();
                            }
                        } catch (Exception e) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException(e);
                        }
                    });
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    if (shouldStop) break;
                }
            }
        });
    }

    @Override
    public void shutdown() {
        shouldStop = true;
        executor.shutdown();
    }

    /**
     * @return The task not executed
     */
    @Override
    public List&lt;Runnable&gt; shutdownNow() {
        shouldStop = true;
        List&lt;Runnable&gt; remainingTasks = new ArrayList&lt;&gt;(taskQueue);
        taskQueue.clear();
        executor.shutdownNow();
        return remainingTasks;
    }

    @Override
    public boolean isShutdown() {
        return shouldStop;
    }

    @Override
    public boolean isTerminated() {
        return shouldStop &amp;&amp; executor.isTerminated();
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return executor.awaitTermination(timeout, unit);
    }

    @Override
    public void execute(Runnable command) {
        try {
            taskQueue.put(command); // 阻塞直到队列有空间
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RejectedExecutionException("Task submission interrupted.", e);
        }
    }
}

</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-java">package com.zengbiaobiao.demo.vitrualthreaddemo;

import org.apache.tomcat.util.threads.VirtualThreadExecutor;

public class VirtualThreadExecutorServiceDemo {
    public static void main(String[] args) throws InterruptedException {

        VirtualThreadExecutorService executorService = new VirtualThreadExecutorService(10, 2);


        for (int i = 0; i &lt; 100000; i++) {
            final String threadName = "thread-" + i;
            System.out.println(Thread.currentThread() + ": try to create task " + threadName);
            executorService.submit(() -&gt; {
                System.out.println(Thread.currentThread() + ": " + threadName + " created!");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread() + ": " + threadName + " finished!");
            });
        }

        Thread.sleep(5000000);

    }
}

</code></pre>
<h2 id="哪些场景下可以应用虚拟线程">哪些场景下可以应用虚拟线程</h2>
<p>虚拟线程在IO密集型的高并发应用中能发挥出巨大的威力，在所有IO密集型应用中，具体来说，下列场景中，使用虚拟线程是比较合适的：</p>
<ul>
<li>
<p>短时间需要完成的任务，且没有资源争夺或乱序问题，比如数据库写入，服务器 HTTP 请求处理，远程 RESTful API 调用，RabbitMQ 消息处理等应用场景。。</p>
</li>
<li>
<p>长时间运行的任务，但是对消息处理由顺序要求的任务。比如在电梯监控系统中，需要对每台电梯的数据进行处理，但是需要保证消息被处理的顺序。这时可以为每台电梯创建一个虚拟线程，这台电梯的数据交给专门的虚拟线程处理。因为应用中可以创建大量虚拟线程，并且虚拟线程一般都是异步处理任务，所以这个场景中，使用虚拟线程，可以满足高性能和高并发的要求。</p>
</li>
<li>
<p>API网关中，对多个上游API数据进行查询，组装合并，使用虚拟线程，相比传统线程，效果更佳。虚拟线程，也支持CountDownLatch，Semaphore等工具类。</p>
</li>
<li>
<p>事件驱动的架构中，使用虚拟线程，效果也很好。比如spring boot中的异步事件，默认使用的是传统线程池，如果将其改成虚拟线程池，并发处理能力可以极大提高。</p>
</li>
</ul>
<p>那么哪些场景下不合适使用虚拟线程呢？</p>
<ul>
<li>
<p>CPU密集型应用，比如大数据处理、图像处理、矩阵运算等。</p>
</li>
<li>
<p>如果应用有很高的并发资源争夺，或者状态同步，并且造成系统吞吐量低，需要考虑优化并发模型，这种场景下，不但传统线程不合适，虚拟线程也不合适。</p>
</li>
</ul>
<h2 id="虚拟线程实际应用场景举例">虚拟线程实际应用场景举例</h2>
<p>在一个spring boot项目中，有时候因为异步事件处理不过来，造成吞吐量下降，在JDK 21中，可以将事件改成虚拟线程来执行，代码如下：</p>
<pre><code class="language-java">package com.zengbiaobiao.demo.vitrualthreaddemo;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        // 最大并行任务数
        Semaphore semaphore = new Semaphore(100);
        ExecutorService virtualThreadPool = Executors.newVirtualThreadPerTaskExecutor();

        return runnable -&gt; {
            try {
                // 控制并行任务数
                semaphore.acquire();
                virtualThreadPool.submit(() -&gt; {
                    try {
                        runnable.run();
                    } finally {
                        semaphore.release();
                    }
                });
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Task submission interrupted", e);
            }
        };
    }
}

</code></pre>
<p>事件发送和处理代码如下：</p>
<pre><code class="language-java">package com.zengbiaobiao.demo.vitrualthreaddemo;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/home")
public class HomeController {

    private final ApplicationEventPublisher eventPublisher;

    public HomeController(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    @GetMapping("/index")
    public String index() {
        for (int i = 0; i &lt; 1000; i++) {
            eventPublisher.publishEvent("event " + i);
        }
        return "success";
    }

    @EventListener
    @Async
    public void handleEvent(String event) {
        System.out.println(Thread.currentThread() + ": " + event);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>VirtualThread[#2031]/runnable@ForkJoinPool-1-worker-4: event 976
VirtualThread[#2039]/runnable@ForkJoinPool-1-worker-1: event 980
VirtualThread[#1064]/runnable@ForkJoinPool-1-worker-1: event 983
VirtualThread[#2047]/runnable@ForkJoinPool-1-worker-2: event 984
VirtualThread[#2049]/runnable@ForkJoinPool-1-worker-9: event 985
VirtualThread[#2057]/runnable@ForkJoinPool-1-worker-2: event 989
VirtualThread[#2059]/runnable@ForkJoinPool-1-worker-3: event 990
VirtualThread[#2061]/runnable@ForkJoinPool-1-worker-6: event 991
VirtualThread[#2063]/runnable@ForkJoinPool-1-worker-10: event 992
VirtualThread[#2065]/runnable@ForkJoinPool-1-worker-10: event 993
VirtualThread[#2071]/runnable@ForkJoinPool-1-worker-3: event 996
VirtualThread[#2069]/runnable@ForkJoinPool-1-worker-2: event 995
VirtualThread[#2075]/runnable@ForkJoinPool-1-worker-7: event 998
VirtualThread[#2077]/runnable@ForkJoinPool-1-worker-10: event 999

</code></pre>
<p>上面输出结果中，每次并发执行100个任务，当虚拟线程池任务达到100之后，执行eventPublisher.publishEvent("event " + i)代码时，代码阻塞，过100ms之后，100个任务执行完成，下一批任务被执行。</p>
<h2 id="虚拟线程使用注意事项">虚拟线程使用注意事项</h2>
<ul>
<li>
<p>搞清楚任务类型，是IO密集型，还是CPU密集型</p>
</li>
<li>
<p>与传统线程结合使用</p>
</li>
<li>
<p><strong>关注性能和资源，使用虚拟线程无法通过线程池等工具控制并发，需要借助Semepha，CountdownLatch等工具才能限流，如果不限流，容易造成OOM，或对目标系统造成巨大流量冲击。</strong></p>
</li>
<li>
<p><strong>在异步框架中，关注隐藏的传统线程，</strong>比如在HttpClient的异步请求中，每次异步请求都会创建一个HttpClient回调线程。大量的传统线程被间接创建，也容易引起OOM。</p>
</li>
<li>
<p>由synchronized关键字引起的pinned问题，看起来在JDK 21中，做了一些优化，即便虚拟线程pinned到传统线程，也只是性能退回到传统线程，无非是慢一点，反而不是太大问题。经过大量测试，发现基本只出现一次，之后不会再出现。不过使用ReentrantLock，效果确实会好很多，将synchronized关键字改成lock.()和lock.unlock()，ForkJoinPool中的线程数量会降低，并且任务分配均衡。</p>
</li>
<li>
<p>不要忽略软件设计，尤其在需要大量同步的应用中。</p>
</li>
</ul>
<p>经过验证，<strong>虚拟线程在遇到IO时，确实会让步，并且不消耗太多资源，核心特点是，让异步编程变得简单，并且不需要框架支持。但是容易因大的并发，造成OOM，或者对目标系统造成冲击，追求高并发可用，但一定要做测试和验证。</strong>对于需要做状态同步，如需要加锁，或需要使用synchronize关键字的代码，需要优化设计，如果无法规避，那么，使用虚拟线程，和使用线程池，效果差不多。</p>
<p>虚拟线程存在的问题：</p>
<p><a href="https://medium.com/@phil_3582/java-virtual-threads-some-early-gotchas-to-look-out-for-f65df1bad0db" target="_blank" rel="noopener nofollow">Java Virtual Threads — some early gotchas to look out for</a></p>
<p><a href="https://blog.flowdirector.io/two-pitfalls-by-moving-to-java-virtual-threads-3246d6f5075d" target="_blank" rel="noopener nofollow">Two Pitfalls by moving to Java Virtual Threads</a></p>
<p><a href="https://netflixtechblog.com/java-21-virtual-threads-dude-wheres-my-lock-3052540e231d" target="_blank" rel="noopener nofollow">Java 21 Virtual Threads - Dude, Where’s My Lock?</a></p>
<p><a href="https://blog.ycrash.io/pitfalls-to-avoid-when-switching-to-virtual-threads/" target="_blank" rel="noopener nofollow">Pitfalls to avoid when switching to Virtual threads </a></p>
<p><a href="https://stackoverflow.com/questions/78318131/do-java-21-virtual-threads-address-the-main-reason-to-switch-to-reactive-single" target="_blank" rel="noopener nofollow">Do Java 21 virtual threads address the main reason to switch to reactive single-thread frameworks?</a></p>
<p><a href="https://abhishekvrshny.medium.com/pinning-a-pitfall-to-avoid-when-using-virtual-threads-in-java-482c5eab78a3" target="_blank" rel="noopener nofollow">Pinning: A pitfall to avoid when using virtual threads in Java </a></p>
<p><a href="https://dzone.com/articles/taming-the-virtual-threads-embracing-concurrency-w" target="_blank" rel="noopener nofollow">Taming the Virtual Threads: Embracing Concurrency With Pitfall Avoidance </a></p>
<p><a href="https://davidvlijmincx.com/posts/pitfalls-of-virtual-threads/" target="_blank" rel="noopener nofollow">Pitfalls you encounter with virtual threads </a></p>
<hr>
<p>示例代码在<a href="https://gitee.com/zengbiaobiao/java-virtual-thread.git" target="_blank" rel="noopener nofollow">Gitee</a>上同步，你也可以访问<a href="http://zengbiaobiao.com" target="_blank" rel="noopener nofollow">曾彪彪的个人博客</a>点击查看作者更多文章</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.021306976096064814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-07 11:47">2025-02-07 11:46</span>&nbsp;
<a href="https://www.cnblogs.com/zengbiaobiao2016">曾彪彪</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18702338" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18702338);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18702338', targetLink: 'https://www.cnblogs.com/zengbiaobiao2016/p/18702338', title: 'Java虚拟线程探索' })">举报</a>
</div>
        