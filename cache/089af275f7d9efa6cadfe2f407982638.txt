
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aksoam/p/18759622" title="发布于 2025-03-08 17:43">
    <span role="heading" aria-level="2">Note_Fem边界条件的处理和numpy实现的四种方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>将单元刚度矩阵组装为全局刚度矩阵后,有:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250307213419.png" alt="Img" loading="lazy"></p>
<p>此时的线性方程没有唯一解,<span class="math inline">\([K]\)</span>是奇异矩阵,这是没有引入边界条件,消除刚体位移的原因.</p>
<p>边界条件分为两类:Forced and Geometric;对于力边界条件可以直接附加到节点力向量<span class="math inline">\([P]\)</span>中,即<span class="math inline">\(P_j=P_j^{*}\)</span>,<span class="math inline">\(P_j^{*}\)</span>是给定的节点力值.</p>
<p>因此我们基本只需要处理Geometric Boundary condition.下面介绍三种方法,将Bcs引入到<span class="math inline">\([K]、[P]\)</span></p>
<p>以位移边界条件为例,指定相关自由度值即:<span class="math inline">\(\Phi_j=\Phi_j^{*}\)</span></p>
<h2 id="method-1">Method 1</h2>
<p>将开头的<span class="math inline">\([K][\Phi]=[P]\)</span>划分为:</p>
<p></p><div class="math display">\[\begin{bmatrix}
[K_{11}] &amp; [K_{12}] \\
[K_{21}] &amp; [K_{22}]
\end{bmatrix}
\begin{Bmatrix}
\overrightarrow{\Phi}_1 \\
\overrightarrow{\Phi}_2
\end{Bmatrix}=
\begin{Bmatrix}
\overrightarrow{P}_1 \\
\overrightarrow{P}_2
\end{Bmatrix}
\tag{1}
\]</div><p></p><p>其中,<span class="math inline">\(\Phi_1\)</span>是<mark>未知的</mark>自由节点自由度向量(free dofs);<span class="math inline">\(\Phi_2\)</span>是已知的约束节点自由度值<span class="math inline">\(\Phi_j^{*}\)</span>向量(specified nodal dof);<span class="math inline">\(P_1\)</span>是<strong>已知节点力</strong>向量;<span class="math inline">\(P_2\)</span>是未知的支反力向量</p>
<p>公式2进一步:</p>
<p></p><div class="math display">\[[K_{11}]\overrightarrow{\Phi}_1+[K_{12}]\overrightarrow{\Phi}_2=\overrightarrow{P}_1\tag{2}
\]</div><p></p><p></p><div class="math display">\[[K_{21}]\overrightarrow{\Phi}_1+[K_{22}]\overrightarrow{\Phi}_2=\overrightarrow{P}_2\tag{3}
\]</div><p></p><p>这时,<span class="math inline">\([K_{11}]\)</span>是非奇异矩阵.因此<strong>自由节点自由度(未知节点位移)</strong>可求:</p>
<p></p><div class="math display">\[\overrightarrow{\Phi}_1=[K_{11}]^{-1}(\overrightarrow{P}_1-[K_{12}]\overrightarrow{\Phi}_2)\tag{4}
\]</div><p></p><p>一旦<span class="math inline">\(\Phi_1\)</span>求得,则未知支反力<span class="math inline">\(P_2\)</span>可由公式3求得.</p>
<h2 id="method-2">Method 2</h2>
<p>也称<strong>划行划列法</strong>.method 1 中需要对<span class="math inline">\([K] ,[\Phi],[P]\)</span>进行行列对调,重新排序.当出现非0位移边界时,method 1耗时长且需要记录过程,之后还需要恢复刚度矩阵.因此和method 1等效的处理方法是构建下式:</p>
<p></p><div class="math display">\[\begin{bmatrix}
\left[K_{11}\right] &amp; \left[0\right] \\
\left[0\right] &amp; \left[I\right]
\end{bmatrix}
\begin{bmatrix}
\overrightarrow{\Phi}_1 \\
\overrightarrow{\Phi}_2
\end{bmatrix}=
\begin{bmatrix}
\overrightarrow{P}_1-\left[K_{12}\right]\overrightarrow{\Phi}_2\\{\overrightarrow{\Phi}_2}
\end{bmatrix}\tag{5}
\]</div><p></p><p>实际计算中,不需要对刚度阵重新排序.算法操作如下:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308121618.png" alt="Img" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308121641.png" alt="Img" loading="lazy"></p>
<p>对所有的约束自由度<span class="math inline">\(\Phi_j\)</span>重复Step 1~3即可,这种操作能够保持刚度和方程的对称性.</p>
<h2 id="method-3">Method 3</h2>
<p>该方法也称<strong>乘大数法</strong>.假设约束自由度为<span class="math inline">\(\Phi_j=\Phi_j^*\)</span>,操作如下:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308122237.png" alt="Img" loading="lazy"></p>
<blockquote>
<p>该方法通用性强,适合大多数的静力学线性问题,但数值精度与大数的取值有关,太小了精度差,太大了容易出现"矩阵奇异"的现象</p>
</blockquote>
<h2 id="method-4对角元素置1法">Method 4(对角元素置1法)</h2>
<p>该方法的做法是,对于约束自由度<span class="math inline">\(\Phi_j=0\)</span>,把<span class="math inline">\([K]\)</span>的j行j列置0,但对角元素Kjj=1,<span class="math inline">\([P]\)</span>中对应元素置0.</p>
<p>以6x6的刚度矩阵为例子,</p>
<p></p><div class="math display">\[\begin{gathered}
\begin{bmatrix}
k_{11} &amp; k_{12} &amp; 0 &amp; k_{14} &amp; k_{15} &amp; k_{16} \\
k_{21} &amp; k_{22} &amp; 0 &amp; k_{24} &amp; k_{25} &amp; k_{26} \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
k_{41} &amp; k_{42} &amp; 0 &amp; k_{44} &amp; k_{45} &amp; k_{46} \\
k_{51} &amp; k_{52} &amp; 0 &amp; k_{54} &amp; k_{55} &amp; k_{56} \\
k_{e1} &amp; k_{e3} &amp; 0 &amp; k_{eA} &amp; k_{e5} &amp; k_{e6}
\end{bmatrix}
\begin{bmatrix}
\delta_1 \\
\delta_2 \\
\delta_3 \\
\delta_4 \\
\delta_5 \\
\delta_6
\end{bmatrix}=
\begin{bmatrix}
f_1 \\
f_2 \\
0 \\
f_4 \\
f_5 \\
f_6
\end{bmatrix}
\end{gathered}
\]</div><p></p><blockquote>
<p>不引入大数,避免了数值稳定性的问题,不会影响矩阵的条件数; <strong>但只适合<span class="math inline">\(\Phi_j=0\)</span>这样的简单边界</strong>;可能影响系统矩阵的特性,直接替换可能改变矩阵的对称性(尤其在动力学和非线性问题中);<strong>不能处理非0的位移加载,只能处理力加载</strong></p>
</blockquote>
<h2 id="example">Example</h2>
<p>例题来自《The Finite Element Method in Engineering》的悬臂梁模型(example6.4, page227)</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308133920.png" alt="Img" loading="lazy"></p>
<p>静力平衡方程为:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134055.png" alt="Img" loading="lazy"></p>
<p>解为:</p>
<p></p><div class="math display">\[W=[0,0,-16.5667,-0.2480]
\]</div><p></p><p></p><div class="math display">\[P=[50.0,4980.0,-50,20]
\]</div><p></p><h3 id="solve-by-method-1">solve by method 1</h3>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134239.png" alt="Img" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134331.png" alt="Img" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134454.png" alt="Img" loading="lazy"></p>
<h3 id="solve-by-method-2">solve by method 2</h3>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134658.png" alt="Img" loading="lazy"></p>
<p>循环每个位移约束,<strong>需要注意高亮处的操作</strong>:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134859.png" alt="Img" loading="lazy"></p>
<p>求解:</p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308134949.png" alt="Img" loading="lazy"></p>
<h3 id="solve-by-method-3">solve by method 3</h3>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308135453.png" alt="Img" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/qinguoming/PicGoImg/main/yank-note-picgo-img-20250308135513.png" alt="Img" loading="lazy"></p>
<h2 id="code-realize">Code Realize</h2>
<p>四种方法进行Python+Numpy+Scipy编程实现,并与Example的解进行对比.</p>
<pre><code class="language-python">#-------------------------------------------------------------------------------
# Name:        BcsProcess
# Purpose:     引入边界条件到[K]中,并返回解[U],[P]
#               input:
#                   K:全局刚度矩阵,(M,M) numpy.array
#                   BcDict:位移约束,key (int) = 自由度序号(1-based) , value (float) = 自由度约束值
#                   LoadDict:节点力加载,key (int) = 自由度序号(1-based) , value (float) = 施加的节点力加载或者等效节点力加载
#
# Author:      Administrator
#
# Created:     08-03-2025
# Copyright:   (c) Administrator 2025
# Licence:     &lt;your licence&gt;
#-------------------------------------------------------------------------------
import numpy as np
from typing import Dict,List,Tuple
import scipy as sc
def Method1(K:np.ndarray,BcDict:Dict[int,float],LoadDict:Dict[int,float])-&gt;Tuple:
    dofNum=K.shape[0]
    # 初始化向量
    U,P=np.zeros((dofNum,1)),np.zeros((dofNum,1))
    prescribedDofIndexs=np.array(list(BcDict.keys()))-1

    #使用集合运算,全部自由度与约束自由度求差, 得到自由位移自由度的
    freeDofIndexs=np.array(list(set(range(dofNum))-set(prescribedDofIndexs.tolist())),dtype=int)

    # 已知节点力加到P
    for label,Pval in LoadDict.items():
        ind=label-1
        P[ind,0]+=Pval
    # 已知节点位移(prescribed dof)
    for label,Uval in BcDict.items():
        ind=label-1
        U[ind,0]+=Uval
    U2=U[np.ix_(prescribedDofIndexs,[0])].copy()
    # 已知节点力(free dof)
    P1=P[np.ix_(freeDofIndexs,[0])].copy()
    # 重新划分K行列
    K11=K[np.ix_(freeDofIndexs,freeDofIndexs)].copy()
    K12=K[np.ix_(freeDofIndexs,prescribedDofIndexs)].copy()
    K21=K[np.ix_(prescribedDofIndexs,freeDofIndexs)].copy()
    K22=K[np.ix_(prescribedDofIndexs,prescribedDofIndexs)].copy()
    # 计算自由节点位移值
    U1=np.dot(sc.linalg.inv(K11),P1-K12.dot(U2))
    # 计算支反力
    P2=np.dot(K21,U1)+np.dot(K22,U2)

    # 合并到U,P向量
    U[np.ix_(freeDofIndexs,[0])]=U1
    P[np.ix_(prescribedDofIndexs,[0])]=P2
    return U,P

def Method2(K:np.ndarray,BcDict:Dict[int,float],LoadDict:Dict[int,float])-&gt;Tuple:
    K_origin=K.copy()
    dofNum=K.shape[0]
    # 初始化向量
    U,P=np.zeros((dofNum,1)),np.zeros((dofNum,1))
    # 已知节点力加到 P
    for label,Pval in LoadDict.items():
        ind=label-1
        P[ind,0]+=Pval
    # 循环所有的位移约束
    for label,Uval in BcDict.items():
        j=label-1
        #Step1
        for i in range(dofNum):
            P[i,0]=P[i,0]-K[i,j]*Uval
        #Step2
        for i in range(dofNum):
            K[i,j]=0
            K[j,i]=0
        K[j,j]=1
        #Step3
        P[j,0]=Uval

    # 求解 K'U=P'
    U_=sc.linalg.solve(K,P)
    P_=np.dot(K_origin,U_)

    return U_,P_

def Method3(K:np.ndarray,BcDict:Dict[int,float],LoadDict:Dict[int,float])-&gt;Tuple:
    C=np.max(K)*10e6
    K_origin=K.copy()
    dofNum=K.shape[0]
    # 初始化向量
    U,P=np.zeros((dofNum,1)),np.zeros((dofNum,1))
    # 已知节点力加到 P
    for label,Pval in LoadDict.items():
        ind=label-1
        P[ind,0]+=Pval
    # 循环所有位移约束
    for label,Uval in BcDict.items():
        j=label-1
        # Step1
        K[j,j]=K[j,j]*C
        # Step2
        P[j,0]=K[j,j]*Uval

    # 求解 K'U=P'
    U_=sc.linalg.solve(K,P)
    P_=np.dot(K_origin,U_)

    return U_,P_

def Method4(K:np.ndarray,BcDict:Dict[int,float],LoadDict:Dict[int,float])-&gt;Tuple:
    if np.any(np.array(list(BcDict.values())) != 0):
       raise ValueError('该方法不能处理非0位移加载')
    K_origin=K.copy()
    dofNum=K.shape[0]
    # 初始化向量
    U,P=np.zeros((dofNum,1)),np.zeros((dofNum,1))

    # 已知节点力加到 P
    for label,Pval in LoadDict.items():
        ind=label-1
        P[ind,0]+=Pval

    # loop all nodal bcs
    for label, Uval in BcDict.items():
        j=label-1
        K[j,:]=0.0
        K[:,j]=0.0
        K[j,j]=1.0
        P[j,0]=0

    # solve K'U=P'
    U_=sc.linalg.solve(K,P)
    P_=np.dot(K_origin,U_)

    return U_,P_

if __name__ == '__main__':
    K=np.array([[12,600,-12,600],
                [600,40000,-600,20000],
                [-12,-600,12,-600],
                [600,20000,-600,40000]])
    Bcs={1:0,2:0}
    loads={3:-50,4:20}

    # 精确解
    extract_U=np.array([0,0,-16.5667,-0.2480])
    extract_P=np.array([50.0,4980.0,-50,20])
    # 求解
    u,p=Method4(K,Bcs,loads)

    print(f"extract U=\n{extract_U}")
    print(f"u=\n{u.T}")
    print(f"extract_P=\n{extract_P}")
    print(f"p=\n{p.T}")


</code></pre>
<p>计算结果:</p>
<pre><code class="language-shell">extract_U=
[  0.       0.     -16.5667  -0.248 ]
extract_P=
[  50. 4980.  -50.   20.]

solving by method 1
u=
[[  0.           0.         -16.56666667  -0.248     ]]
p=
[[  50. 4980.  -50.   20.]]

solving by method 2
u=
[[  0.           0.         -16.56666667  -0.248     ]]
p=
[[  50. 4980.  -50.   20.]]

solving by method 3
u=
[[-1.04166667e-11 -3.11250000e-13 -1.65666667e+01 -2.48000000e-01]]
p=
[[  50. 4980.  -50.   20.]]

solving by method 4
u=
[[  0.           0.         -16.56666667  -0.248     ]]
p=
[[  50. 4980.  -50.   20.]]
</code></pre>
<h2 id="总结">总结</h2>
<p>列举了四种直接节点位移边界条件的处理办法,并编程实现,求解案例.对比结果发现:<strong>相比Method3存在数值误差,其他三个都更加精确.</strong></p>
<p><strong>如果需要处理多点耦合边界条件,则有罚函数法,拉格朗日乘子法等</strong>.</p>
<p>参考资料:</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0ODQzOTg2NQ==&amp;mid=2247492870&amp;idx=1&amp;sn=1f008f134e831750bc29e9fe6a34d298&amp;chksm=c3653b50f412b246cd64203060ddb594a629d3fa1b3312bd5193685dd9393b4f4fb31028363c&amp;cur_album_id=2797947940425302018&amp;scene=190#rd" target="_blank" rel="noopener nofollow">有限元基础编程 | 边界条件专题(对角元素置"1"法、乘大数法、划行划列法、拉格朗日乘子法、罚函数法)</a></li>
<li><a href="https://fanyublog.com/" target="_blank" rel="noopener nofollow">范雨有限元博客</a></li>
<li><a href="https://cfem2nli.wordpress.com/" target="_blank" rel="noopener nofollow">有限元软件开发  致力于国产大型通用商业有限元计算软件的开发</a></li>
<li><the finite="" element="" method="" in="" engineering="">Singiresu S. Rao, sixth edition</the></li>
</ul>
<blockquote>
<p>Note Completed at 2025/03/08</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/aksoam/" target="_blank">FE-有限元鹰</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/aksoam/p/18759622" target="_blank">https://www.cnblogs.com/aksoam/p/18759622</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5199357460439815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-08 17:43">2025-03-08 17:43</span>&nbsp;
<a href="https://www.cnblogs.com/aksoam">FE-有限元鹰</a>&nbsp;
阅读(<span id="post_view_count">41</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18759622" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18759622);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18759622', targetLink: 'https://www.cnblogs.com/aksoam/p/18759622', title: 'Note_Fem边界条件的处理和numpy实现的四种方法' })">举报</a>
</div>
        