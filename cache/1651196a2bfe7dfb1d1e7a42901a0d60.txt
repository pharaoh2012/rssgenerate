
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiuqian/p/18898640" title="发布于 2025-05-27 14:50">
    <span role="heading" aria-level="2">前端预览和打印PDF的两种方式</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-size: 14px">最近工作中遇到了一个需求，就是前端选择表格中的某一条数据去请求后端接口，后端返回的是一个PDF文件的下载地址，但是需求不希望用户下载下来再去打印，而是直接预览展示，然后就能打印。</span></p>
<p><span style="font-size: 14px">一开始按照网上的方式去操作，但是每一次浏览器直接就下载了下来，后面一看响应头，原来后端的Content-type设置成了如图所示，直接触发了浏览器的下载。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/697941/202505/697941-20250527142618777-1396522061.png" alt="" loading="lazy"></p>
<p><span style="font-size: 14px">&nbsp;怎么办呢？于是就想到了以下两种方案，两种方案都是</span>再一次去请求返回的地址，只不过前端改成了用二进制Blob（responseType: 'blob'），<span style="background-color: rgba(253, 253, 254, 1); color: rgba(6, 7, 31, 1); font-family: PingFang-SC-Regular">获取原始二进制数据</span></p>
<p><span style="color: rgba(255, 0, 0, 1)"><strong><span style="font-size: 14px">方案一如下图所示：</span></strong></span></p>
<p><span style="font-size: 14px">其中的data为要传入的地址，然后将拿到的结果创建一个Blob对象，并重新指定其MIME类型为<span style="color: rgba(255, 0, 0, 1)">{ type: 'application/pdf '}</span>，这样就不会再触发浏览器的下载功能。接着使用<span style="color: rgba(255, 0, 0, 1)"><code class=" inline" style="box-sizing: border-box; padding: 1px 4px; -webkit-font-smoothing: antialiased; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; list-style: none; margin: 0 2px; scrollbar-width: none; font-size: 12.75px; tab-size: 4; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px">URL.createObjectURL()</code></span>生成临时访问地址，通过<span style="color: rgba(255, 0, 0, 1)">window.open()</span>的方式在新窗口打开预览，等待加载后自动打印。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/697941/202505/697941-20250527143257037-1708355179.png" alt="" loading="lazy"></p>
<p>&nbsp;但是这种方案要确保后端设置了如下的CORS头，这种方案兼容所有现代浏览器（Chrome/Firefox/Edge/Safari）</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">Access-Control-Allow-Origin: *

Access-Control-Allow-Methods: GET
</pre>
</div>
<p><strong style="color: rgba(255, 0, 0, 1)">方案二如下图所示：</strong></p>
<p><span style="color: rgba(35, 38, 59, 1); font-family: -apple-system, BlinkMacSystemFont, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px; letter-spacing: 0.24px; background-color: rgba(255, 255, 255, 0.9)">创建一个隐藏的iframe标签src设置为pdf地址；前端通过获取隐藏的iframe标签的id来实现打印指定内容；</span></p>
<p><img src="https://img2024.cnblogs.com/blog/697941/202505/697941-20250527144727499-1187517206.png" alt="" loading="lazy"></p>
<p>附上具体代码：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)"> async batchPrintReturn(data) {
      axios.get(data,{responseType: </span>'blob'}).then(res =&gt; { <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 以二进制Blob格式接收</span>
        console.log('res&gt;'<span style="color: rgba(0, 0, 0, 1)">, res)
        const blob </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> Blob([res.data], { type: 'application/pdf' }); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建Blob对象并指定新的MIME类型</span>
        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 方案一</span>
        const objectUrl = URL.createObjectURL(blob); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 生成临时URL</span>
        const previewWindow = window.open(objectUrl, '_blank'); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 打开新窗口预览</span>
        previewWindow.onload = <span style="color: rgba(0, 0, 255, 1)">function</span>() { <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 等待加载后自动打印</span>
<span style="color: rgba(0, 0, 0, 1)">          previewWindow.print();
        };
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 方案二</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> date = (<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Date()).getTime()
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> ifr = document.createElement('iframe'<span style="color: rgba(0, 0, 0, 1)">)
        ifr.style.frameborder </span>= 'no'<span style="color: rgba(0, 0, 0, 1)">
        ifr.style.display </span>= 'none'<span style="color: rgba(0, 0, 0, 1)">
        ifr.style.pageBreakBefore </span>= 'always'<span style="color: rgba(0, 0, 0, 1)">
        ifr.setAttribute(</span>'id', 'printPdf' +<span style="color: rgba(0, 0, 0, 1)"> date)
        ifr.setAttribute(</span>'name', 'printPdf' +<span style="color: rgba(0, 0, 0, 1)"> date)
        ifr.src </span>=<span style="color: rgba(0, 0, 0, 1)"> window.URL.createObjectURL(blob)
        document.body.appendChild(ifr)
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.doPrint('printPdf' +<span style="color: rgba(0, 0, 0, 1)"> date)
        window.URL.revokeObjectURL(ifr.src) </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 释放URL 对象</span>
<span style="color: rgba(0, 0, 0, 1)">      })
    },
    doPrint(val) {
      </span><span style="color: rgba(0, 0, 255, 1)">var</span> ordonnance =<span style="color: rgba(0, 0, 0, 1)"> document.getElementById(val).contentWindow
      setTimeout(() </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> {
        ordonnance.print()
      }, </span>100<span style="color: rgba(0, 0, 0, 1)">)
    },</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<span style="color: rgba(6, 7, 31, 1); font-family: PingFang-SC-Regular; font-size: 15px; background-color: rgba(253, 253, 254, 1)">获取原始二进制数据</span>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5608465683518519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 14:50">2025-05-27 14:50</span>&nbsp;
<a href="https://www.cnblogs.com/xiuqian">修谦得益</a>&nbsp;
阅读(<span id="post_view_count">335</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18898640);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18898640', targetLink: 'https://www.cnblogs.com/xiuqian/p/18898640', title: '前端预览和打印PDF的两种方式' })">举报</a>
</div>
	