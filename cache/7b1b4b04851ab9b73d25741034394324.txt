
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18656342" title="发布于 2025-01-08 08:11">
    <span role="heading" aria-level="2">掌握设计模式--桥接模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>桥接设计模式（Bridge Pattern）是一种结构型设计模式，它通过将抽象部分与实现部分分离，使它们可以独立地变化。这种模式特别适合于需要在多个维度上扩展的场景，避免了类爆炸（类的数量随着组合需求呈指数级增长）的情况。</p>
<h3 id="核心思想">核心思想</h3>
<ul>
<li><strong>抽象部分</strong>：定义对象的主要功能或者高层操作接口。</li>
<li><strong>实现部分</strong>：实现抽象部分定义的具体功能。</li>
<li><strong>桥接</strong>：通过组合（而非继承）将抽象部分与实现部分连接在一起。</li>
</ul>
<p>桥接模式关注的是<strong>将抽象层和实现层解耦</strong>，使得它们可以独立变化，以便应对复杂的变化场景。通过这种分离，抽象和实现可以独立扩展，不会互相影响，通常是为了<code>处理多维度扩展问题</code>。</p>
<h3 id="组成部分">组成部分</h3>
<ol>
<li><strong>Abstraction（抽象类）</strong></li>
</ol>
<ul>
<li>定义抽象的接口或基类。</li>
<li>持有一个对实现类（Implementor）的引用。</li>
</ul>
<ol start="2">
<li><strong>RefinedAbstraction（细化抽象类）</strong></li>
</ol>
<ul>
<li>扩展或实现抽象类的功能。</li>
</ul>
<ol start="3">
<li><strong>Implementor（实现类接口）</strong></li>
</ol>
<ul>
<li>定义实现类的通用接口。</li>
</ul>
<ol start="4">
<li><strong>ConcreteImplementor（具体实现类）</strong></li>
</ol>
<ul>
<li>实现 <code>Implementor</code> 接口的具体逻辑。</li>
</ul>
<h2 id="案例--支付系统中的桥接模式">案例--支付系统中的桥接模式</h2>
<p>在支付系统中，我们需要支持不同的<code>支付方式</code>（如微信支付、支付宝支付、信用卡支付等），而且支付方式可能会随着时间和需求的变化而不断增加。同时，每种支付方式又可能需要处理不同的<code>支付类型</code>（例如，消费、退款等操作）。<strong>桥接模式</strong>可以帮助我们将支付方式和支付类型分离，让它们独立扩展，减少类的数量。</p>
<h3 id="0-类图">0. 类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106213724968-514370671.png" alt="image" loading="lazy"></p>
<h3 id="1-抽象部分支付操作">1. 抽象部分：支付操作</h3>
<p>首先，我们定义一个抽象的 <code>Payment</code> 类，代表支付操作。该类包含一个指向支付方式的引用，支付方式可以是微信支付、支付宝支付等。</p>
<pre><code class="language-java">// Abstraction: 抽象的支付操作类
abstract class Payment {
    protected PaymentMethod paymentMethod; // 支付方式

    public Payment(PaymentMethod paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    // 执行支付操作
    abstract void executePayment(double amount);
}
</code></pre>
<h3 id="2-具体支付操作消费和退款">2. 具体支付操作：消费和退款</h3>
<p>然后，我们定义两种支付类型：消费和退款。每种支付类型都可以独立扩展。</p>
<pre><code class="language-java">// RefinedAbstraction: 消费支付
class ConsumerPayment extends Payment {
    public ConsumerPayment(PaymentMethod paymentMethod) {
        super(paymentMethod);
    }

    @Override
    void executePayment(double amount) {
        System.out.println("Initiating consumer payment of " + amount + " using " + paymentMethod.getMethodName());
        paymentMethod.processPayment(amount);
    }
}

// RefinedAbstraction: 退款支付
class RefundPayment extends Payment {
    public RefundPayment(PaymentMethod paymentMethod) {
        super(paymentMethod);
    }

    @Override
    void executePayment(double amount) {
        System.out.println("Initiating refund payment of " + amount + " using " + paymentMethod.getMethodName());
        paymentMethod.processPayment(amount);
    }
}
</code></pre>
<h3 id="3-实现部分支付方式">3. 实现部分：支付方式</h3>
<p>接下来，我们定义支付方式接口 <code>PaymentMethod</code>，以及它的具体实现类：微信支付、支付宝支付、信用卡支付等。</p>
<pre><code class="language-java">// Implementor: 支付方式接口
interface PaymentMethod {
    String getMethodName(); // 获取支付方式名称
    void processPayment(double amount); // 处理支付操作
}

// ConcreteImplementor: 微信支付
class WeChatPayment implements PaymentMethod {
    @Override
    public String getMethodName() {
        return "WeChat Payment";
    }

    @Override
    public void processPayment(double amount) {
        System.out.println("Processing payment of " + amount + " through WeChat.");
    }
}

// ConcreteImplementor: 支付宝支付
class AlipayPayment implements PaymentMethod {
    @Override
    public String getMethodName() {
        return "Alipay Payment";
    }

    @Override
    public void processPayment(double amount) {
        System.out.println("Processing payment of " + amount + " through Alipay.");
    }
}

// ConcreteImplementor: 信用卡支付
class CreditCardPayment implements PaymentMethod {
    @Override
    public String getMethodName() {
        return "Credit Card Payment";
    }

    @Override
    public void processPayment(double amount) {
        System.out.println("Processing payment of " + amount + " through Credit Card.");
    }
}
</code></pre>
<h3 id="4-使用桥接模式的客户端">4. 使用桥接模式的客户端</h3>
<p>我们可以通过客户端代码来进行测试。客户端可以动态地组合不同的支付方式和支付操作类型（如消费或退款）。</p>
<pre><code class="language-java">public class BridgePatternExample {
    public static void main(String[] args) {
        // 使用微信支付进行消费
        Payment payment1 = new ConsumerPayment(new WeChatPayment());
        payment1.executePayment(100.0);

        // 使用支付宝支付进行退款
        Payment payment2 = new RefundPayment(new AlipayPayment());
        payment2.executePayment(50.0);

        // 使用信用卡支付进行消费
        Payment payment3 = new ConsumerPayment(new CreditCardPayment());
        payment3.executePayment(200.0);
    }
}
</code></pre>
<h3 id="5-运行结果">5. 运行结果</h3>
<p>我们通过桥接模式将<code>支付操作</code>（抽象）和<code>支付方式</code>（具体）分离开来，<strong>使得支付操作和支付方式可以独立扩展</strong>。之所以，称<code>支付操作</code>为<strong>抽象部分</strong>、<code>支付方式</code>为<strong>具体部分</strong>，那是因为支付操作并没有实实在在调用支付接口完成支付操作，而是由<code>支付方式</code>去调用支付接口完成的支付操作。 如果将来我们需要添加新的支付操作（例如银行转账等）或支付方式（例如代付、分期付款等），我们可以独立地扩展它们，而不需要修改现有的代码。</p>
<h2 id="桥接模式与策略模式的对比">桥接模式与策略模式的对比</h2>
<ul>
<li>
<p><strong>策略模式</strong>：如果你希望在运行时动态地切换支付方式，而不需要知道具体的支付操作（如消费、退款等），<strong>策略模式</strong>更合适。在这种模式下，我们将支付方式作为一种策略，并在运行时选择适当的策略来处理支付。</p>
</li>
<li>
<p><strong>桥接模式</strong>：如果你有多个维度需要扩展（比如支付操作和支付方式），并且希望将抽象和实现分离，使得它们可以独立变化，<strong>桥接模式</strong>则更为合适。桥接模式适合需要同时支持多个变化维度（例如支付方式和支付类型）的场景。</p>
</li>
</ul>
<h3 id="桥接模式的优点">桥接模式的优点</h3>
<ol>
<li><strong>分离抽象和实现</strong>：可以分别独立开发，不互相影响；</li>
<li><strong>提高系统的扩展性</strong>：增加新的抽象类或实现类都非常方便；</li>
<li><strong>多维度遵循开闭原则</strong>：在多维度场景问题中，修改或扩展某一维度不会影响其他部分。</li>
</ol>
<h3 id="桥接模式的适用场景">桥接模式的适用场景</h3>
<ol>
<li><strong>一个类有两个（或多个）独立变化的维度</strong>，且需要独立扩展时。</li>
<li>不希望通过继承增加类的数量。</li>
<li>需要在运行时切换实现。</li>
</ol>
<h2 id="总结">总结</h2>
<p>桥接模式通过将抽象部分和实现部分分离，极大地增强了代码的灵活性和可维护性。它是一种非常实用的设计模式，尤其在需要扩展多个维度的场景中，可以显著减少代码复杂度。</p>
<p>桥接模式<strong>强调抽象和实现分离及多维度扩展</strong>，在这些情况下可以考虑使用桥接模式。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250106213705570-898570662.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03513608161689815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-08 08:12">2025-01-08 08:11</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656342" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656342);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656342', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18656342', title: '掌握设计模式--桥接模式' })">举报</a>
</div>
        