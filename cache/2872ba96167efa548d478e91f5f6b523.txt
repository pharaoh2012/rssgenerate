
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TwilightLemon/p/18909374" title="发布于 2025-06-04 00:46">
    <span role="heading" aria-level="2">WPF 使用CompositionTarget.Rendering实现平滑流畅滚动的ScrollViewer，支持滚轮、触控板、触摸屏和笔</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>之前的文章中用WPF自带的动画库实现了一个简陋的平滑滚动ScrollViewer，它在只使用鼠标滚轮的情况下表现良好，但仍然有明显的设计缺陷和不足：</p>
<ol>
<li>没有实现真正的动画衔接，只是单纯结束掉上一个动画，而不是继承其滚动速率；</li>
<li>使用触控板的体验极差</li>
<li>对触控屏和笔设备无效</li>
</ol>
<p>为了解决以上问题，本文提出一种新的方案来实现平滑滚动ScrollViewer。该方案在<code>OnMouseWheel</code>、<code>OnManipulationDelta</code>和<code>OnManipulationCompleted</code>中直接处理(禁用)了系统的滚动效果，使用<code>CompositionTarget.Rendering</code>事件来驱动滚动动画。并针对滚轮方式和触控“跟手”分别进行优化，使用<code>缓动滚动模型</code>和<code>精确滚动模型</code>来实现平滑滚动。笔的支持得益于<code>EleCho.WpfSuite</code>库提供的<code>StylusTouchDevice</code>模拟，将笔输入映射为触摸输入。</p>
<p>为了最直观和最简单地解决问题，我们将应用场景设置为垂直滚动，水平滚动可以通过类似的方式实现。 在github中查看最小可运行代码：</p>
<p><a href="https://github.com/TwilightLemon/FluentScrollViewer" rel="noopener nofollow">TwilightLemon/FluentScrollViewer: WPF 实现平滑流畅滚动的ScrollViewer，支持滚轮、触控板、触摸屏和笔</a></p>
<h1 id="一一些先验事实和设计思路">一、一些先验事实和设计思路<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#%E4%B8%80%E4%B8%80%E4%BA%9B%E5%85%88%E9%AA%8C%E4%BA%8B%E5%AE%9E%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h1>
<h2 id="11-onmousewheel的触发逻辑">1.1 OnMouseWheel的触发逻辑<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#11-onmousewheel%E7%9A%84%E8%A7%A6%E5%8F%91%E9%80%BB%E8%BE%91" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p><code>OnMouseWheel(MouseWheelEventArgs e)</code>事件由WPF触发，<code>e.Delta</code>指示鼠标单次滚动的偏移值，通常为120或-120，这个值可以通过<code>Mouse.MouseWheelDeltaForOneLine</code>获得。这一逻辑在传统鼠标滚轮上顺理成章，但是在精准滚动设备（如触控板）上，滚动偏移量变得非常小，事件在高频率低偏移地触发，导致基于动画触发的滚动体验不佳。<br>测试发现，在以下两种场景中，OnMouseWheel事件具有特定的行为：</p>
<table>
<thead>
<tr><th>设备</th><th>缓慢滚动</th><th>快速滚动</th></tr>

</thead>
<tbody>
<tr>
<td>鼠标滚轮</td>
<td>单个触发、一次一个事件</td>
<td>可能多个合并触发，e.Delta 是滚动值的倍数</td>

</tr>
<tr>
<td>触控板</td>
<td>持续滚动，间隔触发，e.Delta 值很小</td>
<td>Delta 快速增长，最后变为很小的值</td>

</tr>

</tbody>

</table>
<p>因为触控板、触摸屏等精准滚动的使用场景，设备与人交互，意味着其数据本身就遵循物理规律。但是滚动的速率和距离被离散地传递给WPF，导致了滚动的生硬和不自然。<br>那么有没有一种思路，我们只需先接收这些滚动数据，然后在每一帧中根据这些数据来计算滚动位置？相当于把离散的滚动数据重新平滑化。</p>
<h2 id="12-compositiontargetrendering">1.2 CompositionTarget.Rendering<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#12-compositiontargetrendering" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p><code>CompositionTarget.Rendering</code>是WPF渲染管线的一个事件，它在每一帧渲染之前触发。我们可以利用这个事件来实现自定义的滚动逻辑：先收集滚动参数，然后在OnRender事件中计算实际偏移值，并应用到ScrollViewer上。</p>
<h2 id="13-两种场景两种模型">1.3 两种场景、两种模型<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#13-%E4%B8%A4%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p>我们将滚动分为两种场景：滚轮和触控，分别对应缓动滚动模型和精确滚动模型。</p>
<h3 id="131-缓动滚动模型">1.3.1 缓动滚动模型<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#131-%E7%BC%93%E5%8A%A8%E6%BB%9A%E5%8A%A8%E6%A8%A1%E5%9E%8B" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h3>
<p>类似于鞭挞陀螺使其旋转，每打一次都会给陀螺附加新的加速度，然后在接下来的时间中由于摩擦的存在而缓慢减速。我们基于这个思路来实现简易的缓动滚动模型：</p>
<ol>
<li>先定义几个参数：速率v、衰减系数f、叠加速率力度系数n,假设刷新率是60Hz，则每帧的时间间隔<code>deltaTime = 1/60s</code>(因为只是模拟数据，实际上并不会影响滚动的流畅度)</li>
<li>每次OnMouseWheel事件触发时，计算新的速率：<code>v += e.Delta * n</code></li>
<li>更新速率：<code>v *= f</code>，模拟摩擦力的影响</li>
<li>在<code>CompositionTarget.Rendering</code>事件中，计算新的位置：<code>offset += v * deltaTime</code></li>
<li>将新的位置应用到ScrollViewer上</li>

</ol>
<h3 id="132-精确滚动模型">1.3.2 精确滚动模型<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#132-%E7%B2%BE%E7%A1%AE%E6%BB%9A%E5%8A%A8%E6%A8%A1%E5%9E%8B" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h3>
<p>对于一个指定的滚动距离，我们希望能够精确地滚动到目标位置，而不是依赖于速率和衰减。模型只需要对离散距离补帧即可。具体而言，定义一个插值系数l，指示接近目标位置的速率，则<code>offset=_targetOffset - _currentOffset) *l</code>.</p>
<h1 id="二实现">二、实现<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#%E4%BA%8C%E5%AE%9E%E7%8E%B0" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h1>
<p>现在我们已经有思路了：先捕获<code>OnMouseWheel</code>等事件-&gt;判断使用哪个模型-&gt;挂载<code>OnRender</code>事件-&gt;在每一帧中计算新的滚动位置-&gt;应用到ScrollViewer上。以下实现通过继承<code>ScrollViewer</code>创建新的控件来实现。</p>
<h2 id="21-先从鼠标滚轮与触控板开始">2.1 先从鼠标滚轮与触控板开始<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#21-%E5%85%88%E4%BB%8E%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%B8%8E%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%BC%80%E5%A7%8B" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p>从<code>OnMouseWheel</code>中收集数据并判断模型:</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span>  <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnMouseWheel(MouseWheelEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)"> {
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>      e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> 
<span style="color: rgba(0, 128, 128, 1)"> 5</span>      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">触摸板使用精确滚动模型</span>
<span style="color: rgba(0, 128, 128, 1)"> 6</span>      _isAccuracyControl =<span style="color: rgba(0, 0, 0, 1)"> IsTouchpadScroll(e);
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> 
<span style="color: rgba(0, 128, 128, 1)"> 8</span>      <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (_isAccuracyControl)
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>          _targetOffset = Math.Clamp(_currentOffset - e.Delta, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)">10</span>      <span style="color: rgba(0, 0, 255, 1)">else</span>
<span style="color: rgba(0, 128, 128, 1)">11</span>          _targetVelocity += -e.Delta * VelocityFactor;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 鼠标滚动，叠加速度（惯性滚动）</span>
<span style="color: rgba(0, 128, 128, 1)">12</span> 
<span style="color: rgba(0, 128, 128, 1)">13</span>      <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 0, 1)">     {
</span><span style="color: rgba(0, 128, 128, 1)">15</span>          CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">16</span>          _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">17</span> <span style="color: rgba(0, 0, 0, 1)">     }
</span><span style="color: rgba(0, 128, 128, 1)">18</span>  }</pre>
</div>
<p>WPF似乎并没有提供直接判断触发设备的方法，这里使用了一个启发式判断逻辑：判断触发间隔时间和偏移值是否为滚轮偏移值的倍数。这一代码在诺尔大佬的<code>EleCho.WpfSuite</code>中亦有记载。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> IsTouchpadScroll(MouseWheelEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">var</span> tickCount =<span style="color: rgba(0, 0, 0, 1)"> Environment.TickCount;
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span>     <span style="color: rgba(0, 0, 255, 1)">var</span> isTouchpadScrolling =
<span style="color: rgba(0, 128, 128, 1)"> 5</span>             e.Delta % Mouse.MouseWheelDeltaForOneLine != <span style="color: rgba(128, 0, 128, 1)">0</span> ||
<span style="color: rgba(0, 128, 128, 1)"> 6</span>             (tickCount - _lastScrollingTick &lt; <span style="color: rgba(128, 0, 128, 1)">100</span> &amp;&amp; _lastScrollDelta % Mouse,MouseWheelDeltaForOneLine != <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>     _lastScrollDelta =<span style="color: rgba(0, 0, 0, 1)"> e.Delta;
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     _lastScrollingTick =<span style="color: rgba(0, 0, 0, 1)"> e.Timestamp;
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> isTouchpadScrolling;
</span><span style="color: rgba(0, 128, 128, 1)">10</span>     }</pre>
</div>
<h2 id="22-适配触摸屏和笔">2.2 适配触摸屏和笔<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#22-%E9%80%82%E9%85%8D%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%92%8C%E7%AC%94" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p>触摸屏的输入可以通过<code>ManipulationDelta</code>和<code>ManipulationCompleted</code>事件来处理。我们将触摸输入映射为滚动偏移量，并使用精确滚动模型，在结束滚动时，可能还有由于快速滑动造成的惯性速率，我们在<code>ManipulationCompleted</code>中交给惯性滚动模型处理。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnManipulationDelta(ManipulationDeltaEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">base</span>.OnManipulationDelta(e);    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果没有这一行则不会触发ManipulationCompleted事件??</span>
<span style="color: rgba(0, 128, 128, 1)"> 4</span>     e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> 
<span style="color: rgba(0, 128, 128, 1)"> 6</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">手还在屏幕上，使用精确滚动</span>
<span style="color: rgba(0, 128, 128, 1)"> 7</span>     _isAccuracyControl = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     <span style="color: rgba(0, 0, 255, 1)">double</span> deltaY = -<span style="color: rgba(0, 0, 0, 1)">e.DeltaManipulation.Translation.Y;
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     _targetOffset = Math.Clamp(_targetOffset + deltaY, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)">10</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 记录最后一次速度</span>
<span style="color: rgba(0, 128, 128, 1)">11</span>     _lastTouchVelocity = -<span style="color: rgba(0, 0, 0, 1)">e.Velocities.LinearVelocity.Y;
</span><span style="color: rgba(0, 128, 128, 1)">12</span> 
<span style="color: rgba(0, 128, 128, 1)">13</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">15</span>         CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">16</span>         _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">17</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">18</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">19</span> 
<span style="color: rgba(0, 128, 128, 1)">20</span> <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnManipulationCompleted(ManipulationCompletedEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)">21</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">22</span>     <span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">.OnManipulationCompleted(e);
</span><span style="color: rgba(0, 128, 128, 1)">23</span>     e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">24</span>     Debug.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">vel: </span><span style="color: rgba(128, 0, 0, 1)">"</span>+<span style="color: rgba(0, 0, 0, 1)"> _lastTouchVelocity);
</span><span style="color: rgba(0, 128, 128, 1)">25</span>     _targetVelocity = _lastTouchVelocity; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 用系统识别的速度继续滚动</span>
<span style="color: rgba(0, 128, 128, 1)">26</span>     _isAccuracyControl = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">27</span> 
<span style="color: rgba(0, 128, 128, 1)">28</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)">29</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">30</span>         CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">31</span>         _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">32</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">33</span> }</pre>
</div>
<p>适配笔只需要把笔设备映射为触摸设备即可。这里使用了<code>EleCho.WpfSuite</code>库中的<code>StylusTouchDevice</code>来模拟触摸输入，最小可用代码在仓库中给出。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> MyScrollViewer()
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">...</span>
<span style="color: rgba(0, 128, 128, 1)">4</span>     StylusTouchDevice.SetSimulate(<span style="color: rgba(0, 0, 255, 1)">this</span>, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">5</span> }</pre>
</div>
<h2 id="23-onrender事件">2.3 OnRender事件<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#23-onrender%E4%BA%8B%E4%BB%B6" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h2>
<p>在<code>CompositionTarget.Rendering</code>事件中，我们根据当前模型计算新的滚动位置，并应用到ScrollViewer上。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> OnRendering(<span style="color: rgba(0, 0, 255, 1)">object</span>?<span style="color: rgba(0, 0, 0, 1)"> sender, EventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (_isAccuracyControl)
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 精确滚动：Lerp 逼近目标</span>
<span style="color: rgba(0, 128, 128, 1)"> 6</span>         _currentOffset += (_targetOffset - _currentOffset) *<span style="color: rgba(0, 0, 0, 1)"> LerpFactor;
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> 
<span style="color: rgba(0, 128, 128, 1)"> 8</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果已经接近目标，就停止</span>
<span style="color: rgba(0, 128, 128, 1)"> 9</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (Math.Abs(_targetOffset - _currentOffset) &lt; <span style="color: rgba(128, 0, 128, 1)">0.5</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">11</span>             _currentOffset =<span style="color: rgba(0, 0, 0, 1)"> _targetOffset;
</span><span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 0, 1)">            StopRendering();
</span><span style="color: rgba(0, 128, 128, 1)">13</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">15</span>     <span style="color: rgba(0, 0, 255, 1)">else</span>
<span style="color: rgba(0, 128, 128, 1)">16</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">17</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 缓动滚动：速度衰减模拟</span>
<span style="color: rgba(0, 128, 128, 1)">18</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (Math.Abs(_targetVelocity) &lt; <span style="color: rgba(128, 0, 128, 1)">0.1</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">19</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">20</span>             _targetVelocity = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">21</span> <span style="color: rgba(0, 0, 0, 1)">            StopRendering();
</span><span style="color: rgba(0, 128, 128, 1)">22</span>             <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">23</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">24</span> 
<span style="color: rgba(0, 128, 128, 1)">25</span>         _targetVelocity *=<span style="color: rgba(0, 0, 0, 1)"> Friction;
</span><span style="color: rgba(0, 128, 128, 1)">26</span>         _currentOffset = Math.Clamp(_currentOffset + _targetVelocity * (<span style="color: rgba(128, 0, 128, 1)">1.0</span> / <span style="color: rgba(128, 0, 128, 1)">60</span>), <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)">27</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">28</span> 
<span style="color: rgba(0, 128, 128, 1)">29</span> <span style="color: rgba(0, 0, 0, 1)">    ScrollToVerticalOffset(_currentOffset);
</span><span style="color: rgba(0, 128, 128, 1)">30</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">31</span> 
<span style="color: rgba(0, 128, 128, 1)">32</span> <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> StopRendering()
</span><span style="color: rgba(0, 128, 128, 1)">33</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">34</span>     CompositionTarget.Rendering -=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">35</span>     _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">36</span> }</pre>
</div>
<h1 id="三已知问题">三、已知问题<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#%E4%B8%89%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h1>
<ol>
<li>使用触摸屏时可能会造成闪烁，因为并没有完全禁用系统的滚动实现。如果禁用<code>base.OnManipulationDelta(e)</code>，则无法触发<code>ManipulationCompleted</code>事件，导致无法处理惯性滚动。</li>
<li>尚未测试与ListBox等控件的兼容性。</li>
</ol>
<h1 id="四完整代码">四、完整代码<a class="anchor" href="http://127.0.0.1:4321/posts/wpf-fluent-scrollviewer-with-all-device-supported/#%E5%9B%9B%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="noopener nofollow"><span class="anchor-icon" data-pagefind-ignore=""><br></span></a></h1>
<p>以下是完整的<code>MyScrollViewer</code>代码，包含了上述所有实现细节。</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_94b7dd84-ebf4-41e9-bf4f-d4ab71589a51" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_94b7dd84-ebf4-41e9-bf4f-d4ab71589a51" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_94b7dd84-ebf4-41e9-bf4f-d4ab71589a51" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> <span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> EleCho.WpfSuite;
</span><span style="color: rgba(0, 128, 128, 1)">  2</span> <span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Diagnostics;
</span><span style="color: rgba(0, 128, 128, 1)">  3</span> <span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Windows.Controls;
</span><span style="color: rgba(0, 128, 128, 1)">  4</span> <span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Windows.Input;
</span><span style="color: rgba(0, 128, 128, 1)">  5</span> <span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Windows.Media;
</span><span style="color: rgba(0, 128, 128, 1)">  6</span> 
<span style="color: rgba(0, 128, 128, 1)">  7</span> <span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> FluentScrollViewer;
</span><span style="color: rgba(0, 128, 128, 1)">  8</span> 
<span style="color: rgba(0, 128, 128, 1)">  9</span> <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MyScrollViewer : ScrollViewer
</span><span style="color: rgba(0, 128, 128, 1)"> 10</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 11</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 12</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 精确滚动模型，指定目标偏移
</span><span style="color: rgba(0, 128, 128, 1)"> 13</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 14</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> _targetOffset = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 15</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 16</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 缓动滚动模型，指定目标速度
</span><span style="color: rgba(0, 128, 128, 1)"> 17</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 18</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> _targetVelocity = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 19</span> 
<span style="color: rgba(0, 128, 128, 1)"> 20</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 21</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 缓动模型的叠加速度力度
</span><span style="color: rgba(0, 128, 128, 1)"> 22</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 23</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">double</span> VelocityFactor = <span style="color: rgba(128, 0, 128, 1)">1.2</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 24</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 25</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 缓动模型的速度衰减系数，数值越小，滚动越慢
</span><span style="color: rgba(0, 128, 128, 1)"> 26</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 27</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">double</span> Friction = <span style="color: rgba(128, 0, 128, 1)">0.96</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 28</span> 
<span style="color: rgba(0, 128, 128, 1)"> 29</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 30</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 精确模型的插值系数，数值越大，滚动越快接近目标
</span><span style="color: rgba(0, 128, 128, 1)"> 31</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 32</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">double</span> LerpFactor = <span style="color: rgba(128, 0, 128, 1)">0.35</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 33</span> 
<span style="color: rgba(0, 128, 128, 1)"> 34</span>     <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> MyScrollViewer()
</span><span style="color: rgba(0, 128, 128, 1)"> 35</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span>         _currentOffset =<span style="color: rgba(0, 0, 0, 1)"> VerticalOffset;
</span><span style="color: rgba(0, 128, 128, 1)"> 37</span> 
<span style="color: rgba(0, 128, 128, 1)"> 38</span>         <span style="color: rgba(0, 0, 255, 1)">this</span>.IsManipulationEnabled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span>         <span style="color: rgba(0, 0, 255, 1)">this</span>.PanningMode =<span style="color: rgba(0, 0, 0, 1)"> PanningMode.VerticalOnly;
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span>         <span style="color: rgba(0, 0, 255, 1)">this</span>.PanningDeceleration = <span style="color: rgba(128, 0, 128, 1)">0</span>; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 禁用默认惯性</span>
<span style="color: rgba(0, 128, 128, 1)"> 41</span> 
<span style="color: rgba(0, 128, 128, 1)"> 42</span>         StylusTouchDevice.SetSimulate(<span style="color: rgba(0, 0, 255, 1)">this</span>, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 43</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">记录参数</span>
<span style="color: rgba(0, 128, 128, 1)"> 45</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> _lastScrollingTick = <span style="color: rgba(128, 0, 128, 1)">0</span>, _lastScrollDelta = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 46</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> _lastTouchVelocity = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 47</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> _currentOffset = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 48</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">标志位</span>
<span style="color: rgba(0, 128, 128, 1)"> 49</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 50</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> _isAccuracyControl = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 51</span>     <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnManipulationDelta(ManipulationDeltaEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span>         <span style="color: rgba(0, 0, 255, 1)">base</span>.OnManipulationDelta(e);    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果没有这一行则不会触发ManipulationCompleted事件??</span>
<span style="color: rgba(0, 128, 128, 1)"> 54</span>         e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 55</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">手还在屏幕上，使用精确滚动</span>
<span style="color: rgba(0, 128, 128, 1)"> 56</span>         _isAccuracyControl = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span>         <span style="color: rgba(0, 0, 255, 1)">double</span> deltaY = -<span style="color: rgba(0, 0, 0, 1)">e.DeltaManipulation.Translation.Y;
</span><span style="color: rgba(0, 128, 128, 1)"> 58</span>         _targetOffset = Math.Clamp(_targetOffset + deltaY, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)"> 59</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 记录最后一次速度</span>
<span style="color: rgba(0, 128, 128, 1)"> 60</span>         _lastTouchVelocity = -<span style="color: rgba(0, 0, 0, 1)">e.Velocities.LinearVelocity.Y;
</span><span style="color: rgba(0, 128, 128, 1)"> 61</span> 
<span style="color: rgba(0, 128, 128, 1)"> 62</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)"> 63</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)"> 64</span>             CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)"> 65</span>             _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 66</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)"> 67</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 68</span> 
<span style="color: rgba(0, 128, 128, 1)"> 69</span>     <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnManipulationCompleted(ManipulationCompletedEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 70</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 71</span>         <span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">.OnManipulationCompleted(e);
</span><span style="color: rgba(0, 128, 128, 1)"> 72</span>         e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 73</span>         Debug.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">vel: </span><span style="color: rgba(128, 0, 0, 1)">"</span>+<span style="color: rgba(0, 0, 0, 1)"> _lastTouchVelocity);
</span><span style="color: rgba(0, 128, 128, 1)"> 74</span>         _targetVelocity = _lastTouchVelocity; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 用系统识别的速度继续滚动</span>
<span style="color: rgba(0, 128, 128, 1)"> 75</span>         _isAccuracyControl = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 76</span> 
<span style="color: rgba(0, 128, 128, 1)"> 77</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)"> 78</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)"> 79</span>             CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)"> 80</span>             _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 83</span> 
<span style="color: rgba(0, 128, 128, 1)"> 84</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 85</span>     <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 判断MouseWheel事件由鼠标触发还是由触控板触发
</span><span style="color: rgba(0, 128, 128, 1)"> 86</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 87</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="e"&gt;&lt;/param&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 88</span>     <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
<span style="color: rgba(0, 128, 128, 1)"> 89</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> IsTouchpadScroll(MouseWheelEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)"> 90</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span>         <span style="color: rgba(0, 0, 255, 1)">var</span> tickCount =<span style="color: rgba(0, 0, 0, 1)"> Environment.TickCount;
</span><span style="color: rgba(0, 128, 128, 1)"> 92</span>         <span style="color: rgba(0, 0, 255, 1)">var</span> isTouchpadScrolling =
<span style="color: rgba(0, 128, 128, 1)"> 93</span>                 e.Delta % Mouse.MouseWheelDeltaForOneLine != <span style="color: rgba(128, 0, 128, 1)">0</span> ||
<span style="color: rgba(0, 128, 128, 1)"> 94</span>                 (tickCount - _lastScrollingTick &lt; <span style="color: rgba(128, 0, 128, 1)">100</span> &amp;&amp; _lastScrollDelta % Mouse.MouseWheelDeltaForOneLine != <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 95</span>         _lastScrollDelta =<span style="color: rgba(0, 0, 0, 1)"> e.Delta;
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span>         _lastScrollingTick =<span style="color: rgba(0, 0, 0, 1)"> e.Timestamp;
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span>         <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> isTouchpadScrolling;
</span><span style="color: rgba(0, 128, 128, 1)"> 98</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 99</span> 
<span style="color: rgba(0, 128, 128, 1)">100</span>     <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> OnMouseWheel(MouseWheelEventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)">101</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">102</span>         e.Handled = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">103</span> 
<span style="color: rgba(0, 128, 128, 1)">104</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">触摸板使用精确滚动模型</span>
<span style="color: rgba(0, 128, 128, 1)">105</span>         _isAccuracyControl =<span style="color: rgba(0, 0, 0, 1)"> IsTouchpadScroll(e);
</span><span style="color: rgba(0, 128, 128, 1)">106</span> 
<span style="color: rgba(0, 128, 128, 1)">107</span>         <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (_isAccuracyControl)
</span><span style="color: rgba(0, 128, 128, 1)">108</span>             _targetOffset = Math.Clamp(_currentOffset - e.Delta, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)">109</span>         <span style="color: rgba(0, 0, 255, 1)">else</span>
<span style="color: rgba(0, 128, 128, 1)">110</span>             _targetVelocity += -e.Delta * VelocityFactor;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 鼠标滚动，叠加速度（惯性滚动）</span>
<span style="color: rgba(0, 128, 128, 1)">111</span> 
<span style="color: rgba(0, 128, 128, 1)">112</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">_isRenderingHooked)
</span><span style="color: rgba(0, 128, 128, 1)">113</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">114</span>             CompositionTarget.Rendering +=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">115</span>             _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">116</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">117</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">118</span> 
<span style="color: rgba(0, 128, 128, 1)">119</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> OnRendering(<span style="color: rgba(0, 0, 255, 1)">object</span>?<span style="color: rgba(0, 0, 0, 1)"> sender, EventArgs e)
</span><span style="color: rgba(0, 128, 128, 1)">120</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">121</span>         <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (_isAccuracyControl)
</span><span style="color: rgba(0, 128, 128, 1)">122</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">123</span>             <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 精确滚动：Lerp 逼近目标</span>
<span style="color: rgba(0, 128, 128, 1)">124</span>             _currentOffset += (_targetOffset - _currentOffset) *<span style="color: rgba(0, 0, 0, 1)"> LerpFactor;
</span><span style="color: rgba(0, 128, 128, 1)">125</span> 
<span style="color: rgba(0, 128, 128, 1)">126</span>             <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果已经接近目标，就停止</span>
<span style="color: rgba(0, 128, 128, 1)">127</span>             <span style="color: rgba(0, 0, 255, 1)">if</span> (Math.Abs(_targetOffset - _currentOffset) &lt; <span style="color: rgba(128, 0, 128, 1)">0.5</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">128</span> <span style="color: rgba(0, 0, 0, 1)">            {
</span><span style="color: rgba(0, 128, 128, 1)">129</span>                 _currentOffset =<span style="color: rgba(0, 0, 0, 1)"> _targetOffset;
</span><span style="color: rgba(0, 128, 128, 1)">130</span> <span style="color: rgba(0, 0, 0, 1)">                StopRendering();
</span><span style="color: rgba(0, 128, 128, 1)">131</span> <span style="color: rgba(0, 0, 0, 1)">            }
</span><span style="color: rgba(0, 128, 128, 1)">132</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">133</span>         <span style="color: rgba(0, 0, 255, 1)">else</span>
<span style="color: rgba(0, 128, 128, 1)">134</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)">135</span>             <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 缓动滚动：速度衰减模拟</span>
<span style="color: rgba(0, 128, 128, 1)">136</span>             <span style="color: rgba(0, 0, 255, 1)">if</span> (Math.Abs(_targetVelocity) &lt; <span style="color: rgba(128, 0, 128, 1)">0.1</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">137</span> <span style="color: rgba(0, 0, 0, 1)">            {
</span><span style="color: rgba(0, 128, 128, 1)">138</span>                 _targetVelocity = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">139</span> <span style="color: rgba(0, 0, 0, 1)">                StopRendering();
</span><span style="color: rgba(0, 128, 128, 1)">140</span>                 <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">141</span> <span style="color: rgba(0, 0, 0, 1)">            }
</span><span style="color: rgba(0, 128, 128, 1)">142</span> 
<span style="color: rgba(0, 128, 128, 1)">143</span>             _targetVelocity *=<span style="color: rgba(0, 0, 0, 1)"> Friction;
</span><span style="color: rgba(0, 128, 128, 1)">144</span>             _currentOffset = Math.Clamp(_currentOffset + _targetVelocity * (<span style="color: rgba(128, 0, 128, 1)">1.0</span> / <span style="color: rgba(128, 0, 128, 1)">60</span>), <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, ScrollableHeight);
</span><span style="color: rgba(0, 128, 128, 1)">145</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">146</span> 
<span style="color: rgba(0, 128, 128, 1)">147</span> <span style="color: rgba(0, 0, 0, 1)">        ScrollToVerticalOffset(_currentOffset);
</span><span style="color: rgba(0, 128, 128, 1)">148</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">149</span> 
<span style="color: rgba(0, 128, 128, 1)">150</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> StopRendering()
</span><span style="color: rgba(0, 128, 128, 1)">151</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">152</span>         CompositionTarget.Rendering -=<span style="color: rgba(0, 0, 0, 1)"> OnRendering;
</span><span style="color: rgba(0, 128, 128, 1)">153</span>         _isRenderingHooked = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">154</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">155</span> }</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1188749/202407/1188749-20240702112134529-1920703459.png" alt="" loading="lazy"></p>
<p>&nbsp; 本文可能会不定期更新，请关注原文：<a href="https://blog.twlmgatito.cn/posts/wpf-fluent-scrollviewer-with-all-device-supported/" rel="noopener nofollow">WPF 使用CompositionTarget.Rendering实现平滑流畅滚动的ScrollViewer，支持滚轮、触控板、触摸屏和笔 - Twlm's Blog</a></p>
<p>&nbsp; 本作品采用&nbsp;<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener nofollow">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>&nbsp;进行许可。欢迎转载、使用、重新发布，但务必保留文章署名TwilightLemon，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3511233664918981" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-04 00:47">2025-06-04 00:46</span>&nbsp;
<a href="https://www.cnblogs.com/TwilightLemon">TwilightLemon</a>&nbsp;
阅读(<span id="post_view_count">73</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18909374);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18909374', targetLink: 'https://www.cnblogs.com/TwilightLemon/p/18909374', title: 'WPF 使用CompositionTarget.Rendering实现平滑流畅滚动的ScrollViewer，支持滚轮、触控板、触摸屏和笔' })">举报</a>
</div>
        