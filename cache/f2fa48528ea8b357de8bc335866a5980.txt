
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19050455" title="发布于 2025-08-21 11:50">
    <span role="heading" aria-level="2">【渲染流水线】[逐片元阶段]-[透明度测试]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250821115641144-1967940391.png" alt="【渲染流水线】[逐片元阶段]-[透明度测试]以UnityURP为例" class="desc_img">
        本文系统介绍了Unity URP中透明度测试(AlphaTest)的技术原理与实践应用。核心机制是通过clip()函数比较片元Alpha值与预设阈值_Cutoff，实现"全有或全无"的硬性透明效果，适用于需要锐利边缘的物体如植被、栅栏等。文章详细阐述了AlphaTest的发展历程，从Built-in管线到现代URP的演进，包括URP14+新增的多重裁剪通道和GPU实例化支持等特性。同时分析了AlphaTest与Early-Z的互斥关系，并提供了Shader配置示例和性能优化建议，如合理设
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><strong>透明度测试与透明度混合（Blend）互斥，需根据需求选择其一！</strong></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>透明度测试(Alpha Test)是一种通过阈值筛选片元的硬性透明方案，其核心逻辑是通过<code>clip()</code>函数比较片元Alpha值与预设阈值<code>_Cutoff</code>：当Alpha低于阈值时直接丢弃片元，反之则完整渲染。</p>
<ul>
<li><strong>二元判定</strong>：呈现"全有或全无"的视觉效果，适用于栅栏、树叶等需要锐利边缘的物体</li>
<li><strong>性能优势</strong>：无需混合计算，在移动端和低配设备上表现优异</li>
</ul>
<h1 id="核心应用场景">核心应用场景</h1>
<ul>
<li>游戏美术优化
<ul>
<li>植被系统：实现树叶镂空效果（性能较Alpha Blend提升40%）</li>
<li>建筑遮罩：快速创建栅栏、铁丝网等规则镂空结构</li>
</ul>
</li>
<li>特效制作
<ul>
<li>粒子消融：配合噪声图实现燃烧/腐蚀动画</li>
<li>UI遮罩：用于异形界面元素裁剪</li>
</ul>
</li>
<li>技术美术方案
<ul>
<li>低成本半透模拟：通过抖动阈值(dithering)实现伪半透效果</li>
<li>遮挡剔除辅助：标记透明区域实现自定义遮挡逻辑</li>
</ul>
</li>
</ul>
<h1 id="历史简述">历史简述</h1>
<h2 id="built-in管线阶段2018年前">Built-in管线阶段（2018年前）</h2>
<ul>
<li>早期Unity内置管线通过<code>Queue="AlphaTest"</code>标签实现基础功能，但存在：
<ul>
<li>着色器代码冗余，需手动处理光照模型兼容性</li>
<li>与延迟渲染路径存在兼容性问题</li>
</ul>
</li>
</ul>
<h2 id="urp标准化阶段2019-2022">URP标准化阶段（2019-2022）</h2>
<ul>
<li>URP 7.x版本引入关键改进：
<ul>
<li><strong>Shader Graph集成</strong>：可视化配置<code>Alpha Clip Threshold</code>属性</li>
<li><strong>渲染队列优化</strong>：自动处理AlphaTest物体在3000-3500队列的排序逻辑</li>
<li><strong>跨平台一致性</strong>：在OpenGL ES 3.0与Metal API中实现相同裁剪行为</li>
</ul>
</li>
</ul>
<h2 id="现代urp增强2023-2025">现代URP增强（2023-2025）</h2>
<ul>
<li>最新URP 14+版本新增特性：
<ul>
<li><strong>多重裁剪通道</strong>：支持基于R/G/B通道的复合测试条件</li>
<li><strong>GPU实例化支持</strong>：透明测试物体可参与实例化渲染批次</li>
<li><strong>VFX Graph兼容</strong>：粒子系统可直接引用透明度测试材质</li>
</ul>
</li>
</ul>
<h1 id="如果启用了alphatest-那么early-z则被弃用">如果启用了AlphaTest 那么Early-Z则被弃用</h1>
<ul>
<li>因为AlphaTest的clip()操作是在片元中，而Early-Z是在光栅化和片元之前做的测试，如果在片元着色中主动抛弃了片元，那么被遮挡的片元就可见了，但是Early-Z中已经因为提前计算不可见给重新可见的片元丢弃了，这样就无法正常进行计算。那么GPU在优化算法时，如果检查到片元着色器中存在抛弃片元和改写片元深度的操作时，放弃Early-Z的操作。</li>
<li>Early-Z由GPU自动实现，涉及两个pass，第一个Z-pre-pass，对于所有写入深度数据的物体先用一个超级简单的pass写入深度缓存。第二个pass关闭深度写入，开启深度测试，正常渲染流程渲染。</li>
</ul>
<h1 id="使用注意">使用注意</h1>
<ul>
<li>AlphaTest 物体建议标记为&nbsp;<code>"Queue"="AlphaTest"</code>（值2450），确保在透明物体前渲染‌</li>
<li>使用&nbsp;<code>Always</code>/<code>Never</code>&nbsp;可完全绕过测试，减少GPU分支判断‌</li>
<li>复杂比较函数（如&nbsp;<code>NotEqual</code>）可能增加片元着色器指令数‌</li>
<li>根据alpha值阈值决定片元保留/丢弃</li>
<li>常用于植被、镂空材质等效果实现‌</li>
</ul>
<h1 id="unity-中的透明度测试alphatest具体过程"><strong>Unity 中的透明度测试（AlphaTest）具体过程</strong></h1>
<h2 id="subshader-与-pass-设置"><strong>SubShader 与 Pass 设置</strong>‌</h2>
<ul>
<li>配置渲染通道（Pass）启用 AlphaTest，指定比较函数（如 Greater 或 Less）‌</li>
</ul>
<h3 id="比较函数列表"><strong>比较函数列表‌</strong></h3>
<table>
<thead>
<tr>
<th>函数指令</th>
<th>逻辑条件</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Greater</code></td>
<td>alpha &gt; 阈值 (<code>_Cutoff</code>)</td>
<td>硬边遮罩（如树叶镂空）‌</td>
</tr>
<tr>
<td><code>GEqual</code></td>
<td>alpha ≥ 阈值</td>
<td>半透明边缘抗锯齿优化‌</td>
</tr>
<tr>
<td><code>Less</code></td>
<td>alpha &lt; 阈值</td>
<td>反向遮罩（如洞孔效果）‌</td>
</tr>
<tr>
<td><code>LEqual</code></td>
<td>alpha ≤ 阈值</td>
<td>透明渐变剔除‌</td>
</tr>
<tr>
<td><code>Equal</code></td>
<td>alpha == 阈值</td>
<td>精确匹配特定透明度‌</td>
</tr>
<tr>
<td><code>NotEqual</code></td>
<td>alpha != 阈值</td>
<td>排除特定透明值‌</td>
</tr>
<tr>
<td><code>Always</code></td>
<td>始终通过测试</td>
<td>强制禁用透明度测试‌</td>
</tr>
<tr>
<td><code>Never</code></td>
<td>始终丢弃片元</td>
<td>完全隐藏物体‌</td>
</tr>
</tbody>
</table>
<h3 id="配置示例"><strong>‌配置示例‌</strong></h3>
<ul>
<li>在 SubShader 的 Pass 中声明比较函数与阈值：</li>
</ul>
<pre><code class="language-c">SubShader {
    Pass {
        // 启用AlphaTest并设置比较模式
        AlphaTest Greater 0.5  // 仅保留alpha&gt;0.5的片元
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        uniform float _Cutoff; // 阈值变量

        fixed4 frag (v2f i) : SV_Target {
            fixed4 col = tex2D(_MainTex, i.uv);
            clip(col.a - _Cutoff); // 等效于AlphaTest Greater
            return col;
        }
        ENDCG
    }
}
</code></pre>
<blockquote>
<p>注：clip()&nbsp;函数在片元着色器中可直接实现阈值比较，与&nbsp;AlphaTest&nbsp;指令效果等价‌</p>
</blockquote>
<h1 id="自定义shader中片元着色器中剔除或混合">自定义shader中片元着色器中剔除或混合</h1>
<h2 id="shader-属性定义"><strong>Shader 属性定义</strong>‌</h2>
<ul>
<li>在 Shader 代码中声明阈值属性（如&nbsp;<code>_Cutoff</code>），用于控制 alpha 的临界值‌</li>
</ul>
<h2 id="片元着色器处理"><strong>片元着色器处理</strong>‌</h2>
<ul>
<li>在片元着色器中，计算片元 alpha 值并与&nbsp;<code>_Cutoff</code>&nbsp;比较；若未达标，则使用&nbsp;<code>clip()</code>&nbsp;或&nbsp;<code>discard</code>&nbsp;指令丢弃片元，阻止其进入后续测试‌</li>
</ul>
<h2 id="渲染输出"><strong>渲染输出</strong>‌</h2>
<ul>
<li>通过测试的片元参与颜色混合等后续流程，否则被剔除‌</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-08-21 11:57">2025-08-21 11:50</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19050455);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19050455', targetLink: 'https://www.cnblogs.com/SmalBox/p/19050455', title: '【渲染流水线】[逐片元阶段]-[透明度测试]以UnityURP为例' })">举报</a>
</div>
        