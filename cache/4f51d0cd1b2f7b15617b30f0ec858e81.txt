
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/whuanle/p/18832422" title="发布于 2025-04-18 11:08">
    <span role="heading" aria-level="2">Hangfire Redis 实现秒级定时任务、使用 CQRS 实现动态执行代码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#定时任务需求" rel="noopener nofollow">定时任务需求</a></li><li><a href="#核心逻辑" rel="noopener nofollow">核心逻辑</a></li><li><a href="#使用-redis-实现秒级定时任务" rel="noopener nofollow">使用 Redis 实现秒级定时任务</a><ul><li><a href="#第一步" rel="noopener nofollow"><strong>第一步</strong></a></li><li><a href="#第二步" rel="noopener nofollow"><strong>第二步</strong></a></li><li><a href="#第三步" rel="noopener nofollow"><strong>第三步</strong></a></li><li><a href="#第四步" rel="noopener nofollow"><strong>第四步</strong></a></li></ul></li><li><a href="#业务服务实现动态代码" rel="noopener nofollow">业务服务实现动态代码</a><ul><li><a href="#第一步-1" rel="noopener nofollow">第一步</a></li><li><a href="#第二步-1" rel="noopener nofollow">第二步</a></li><li><a href="#第三步-1" rel="noopener nofollow">第三步</a></li><li><a href="#第四步-1" rel="noopener nofollow">第四步</a></li><li><a href="#第五步" rel="noopener nofollow">第五步</a></li></ul></li><li><a href="#最后" rel="noopener nofollow">最后</a></li></ul></div><p></p>
<h3 id="定时任务需求">定时任务需求</h3>
<p>本文示例项目仓库：<a href="https://github.com/whuanle/HangfireDemo" target="_blank" rel="noopener nofollow">https://github.com/whuanle/HangfireDemo</a></p>
<br>
<p>主要有两个核心需求：</p>
<ul>
<li>需要实现秒级定时任务；</li>
<li>开发者使用定时任务要简单，不要弄复杂了；</li>
</ul>
<br>
<p>在微服务架构中中，定时任务是最常用的基础设施组件之一，社区中有很多定时任务类库或平台，例如 Quartz.NET、xxx-job，使用方法差异很大，比如 xxx-job 的核心是 http 请求，配置定时任务实现 http 请求具体的接口，不过用起来还是比较复杂的。</p>
<p>在微服务中，使用的组件太多了，如果每个组件的集成都搞得很麻烦，那么服务的代码很可能会大量膨胀，并且容易出现各种 bug。以 xxx-job 为例，如果项目中有 N 个定时任务，设计 N 个 http 接口被 xxx-job 回调触发，除了 http 接口数量庞大，在各个环节中还容易出现 bug。</p>
<br>
<p>在近期项目需求中，刚好要用到定时任务，结合 C# 语言的特性，笔者的方法是利用 Hangfire 框架和语言特性，封装一些方法，使得开发者可以无感使用定时任务，大大简化链路和使用难度。</p>
<p>使用示例，结合 MediatR 框架定义 CQRS ，该 Command 将会被定时任务触发执行：</p>
<pre><code class="language-csharp">public class MyTestRequest : HangfireRequest, IRequest&lt;ExecteTasResult&gt;
{
}

/// &lt;summary&gt;
/// 要被定时任务执行的代码.
/// &lt;/summary&gt;
public class MyTestHandler : IRequestHandler&lt;MyTestRequest, ExecteTasResult&gt;
{
    public async Task&lt;ExecteTasResult&gt; Handle(MyTestRequest request, CancellationToken cancellationToken)
    {
        // 逻辑
        
        return new ExecteTasResult
        {
            CancelTask = false
        };
    }
}
</code></pre>
<br>
<p>要启动一个定时任务，只需要：</p>
<pre><code class="language-csharp">private readonly SendHangfireService _hangfireService;

public SendTaskController(SendHangfireService hangfireService)
{
	_hangfireService = hangfireService;
}

[HttpGet("aaa")]
public async Task&lt;string&gt; SendAsync()
{
	await _hangfireService.Send(new MyTestRequest
	{
		CreateTime = DateTimeOffset.Now,
		CronExpression = "* * * * * *",
		TaskId = Guid.NewGuid().ToString(),
	});

	return "aaa";
}
</code></pre>
<br>
<p>通过这种方式使用定时任务，开发者只需要使用很简单的代码即可完成需求，不需要关注细节，也不需要定义各种 http 接口，并且犹豫不需要关注使用的外部定时任务框架，所以随时可以切换不同的定时任务实现。</p>
<h3 id="核心逻辑">核心逻辑</h3>
<p>本文示例项目仓库：<a href="https://github.com/whuanle/HangfireDemo" target="_blank" rel="noopener nofollow">whuanle/HangfireDemo</a></p>
<br>
<p>示例项目结构如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105716051-623347144.png" alt="image-20250418084329362" loading="lazy"></p>
<br>
<p>HangfireServer 是定时任务服务实现，HangfireServer 服务只需要暴露两个接口 <code>addtask</code>、<code>cancel</code>，分别用于添加定时任务和取消定时任务，无论什么业务的服务，都通过 <code>addtask</code> 服务添加。</p>
<br>
<p>DemoApi 则是业务服务，业务服务只需要暴露一个· <code>execute</code> 接口用于触发定时任务即可。</p>
<br>
<p>基础逻辑如下：</p>
<br>
<div class="mermaid">graph LR
subgraph DemoApi
A[定义 Command] -- 序列化参数Command --&gt; AA[发送定时任务]
E[DemoApi：execute 接口] --&gt; F[DemoApi：执行 Command]
end
subgraph Hangfire
B[addtask] --&gt; C[Hangfire：存储任务]
C --&gt; D[Hangfire：执行任务]
D --&gt; DD[发起请求]
end
  %% 同时建立必要的连接
    AA -- 添加定时任务 --&gt; B
    DD -- 请求 --&gt; E
</div><br>
<p>由于项目中使用的是 MediatR 框架实现 CQRS 模式，因此很容易实现定时任务动态调用代码，只需要按照平时的 CQRS 发送定时任务命令，指定定时任务要执行的 Command 即可。</p>
<p>例如，有以下 Command 需要被定时任务执行：</p>
<pre><code>ACommand
BCommand
CCommand
</code></pre>
<p><br>首先这些命令会被序列化为 json ，发送到 HangfireServer 服务，HangfireServer 在恰当时机将参数原封不动推送到 DemoApi 服务，DemoApi 服务拿到这些参数序列化为对应的类型，然后通过 MediatR 发送命令，即可实现任意命令的定时任务动态调用。</p>
<br>
<p>下面来分别实现 HangfireServer 、DemoApi 服务。</p>
<p>在 Shred 项目中添加以下文件。</p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105711945-1621232199.png" alt="image-20250418093956062" loading="lazy"></p>
<br>
<p>其中 TaskRequest 内容如下，其它文件请参考示例项目。</p>
<pre><code class="language-csharp">public class TaskRequest
{
    /// &lt;summary&gt;
    /// 任务 id.
    /// &lt;/summary&gt;
    public string TaskId { get; set; } = "";

    /// &lt;summary&gt;
    /// 定时任务要请求的服务地址或服务名称.
    /// &lt;/summary&gt;
    public string ServiceName { get; set; } = "";

    /// &lt;summary&gt;
    /// 参数类型名称.
    /// &lt;/summary&gt;
    public string CommandType { get; set; } = "";

    /// &lt;summary&gt;
    /// 请求参数内容，json 序列化后的字符串.
    /// &lt;/summary&gt;
    public string CommandBody { get; set; } = "";

    /// &lt;summary&gt;
    /// Cron 表达式.
    /// &lt;/summary&gt;
    public string CronExpression { get; set; } = "";

    /// &lt;summary&gt;
    /// 创建时间.
    /// &lt;/summary&gt;
    public string CreateTime { get; set; } = "";
}
</code></pre>
<h3 id="使用-redis-实现秒级定时任务">使用 Redis 实现秒级定时任务</h3>
<p>Hangfire 本身配置比较复杂，其分布式实现对数据库性能要求比较高，因此使用 Mysql、Sqlserver 等数据库存储数据会带了很大的压力，而且要求实现秒级定时任务，NoSql 数据库可以更加好地实现这一需求，笔者这里使用 Redis 来存储任务数据。</p>
<p>HangfireServer 项目结构如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105711688-800012485.png" alt="image-20250418094109409" loading="lazy"></p>
<br>
<p>对 HangfireServer 的设计主要分为几步：</p>
<ul>
<li>Hangfire 支持容器管理；</li>
<li>配置 Hangfire ；</li>
<li>定义 RecurringJobHandler 执行任务发起 http 请求到业务系统；</li>
<li>定义 http 接口，接收定时任务；</li>
</ul>
<p><br>引入类库：</p>
<pre><code class="language-xml">&lt;PackageReference Include="Hangfire.AspNetCore" Version="1.8.18" /&gt;
&lt;PackageReference Include="Hangfire.Redis.StackExchange" Version="1.12.0" /&gt;
</code></pre>
<br>
<p>首先是关于 Hangfire 本身的配置，现在几乎都是基于依赖注入的设计，不搞静态类型，所以我们需要实现定时任务执行器创建服务实例的，以便每次定时任务请求时，服务实例都是在一个新的容器，处以一个新的上下文中。</p>
<h4 id="第一步"><strong>第一步</strong></h4>
<p>创建 HangfireJobActivatorScope、HangfireActivator 两个文件，实现 Hangfire 支持容器上下文。</p>
<br>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 任务容器.
/// &lt;/summary&gt;
public class HangfireJobActivatorScope : JobActivatorScope
{
    private readonly IServiceScope _serviceScope;
    private readonly string _jobId;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="HangfireJobActivatorScope"/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name="serviceScope"&gt;&lt;/param&gt;
    /// &lt;param name="jobId"&gt;&lt;/param&gt;
    public HangfireJobActivatorScope([NotNull] IServiceScope serviceScope, string jobId)
    {
        _serviceScope = serviceScope ?? throw new ArgumentNullException(nameof(serviceScope));
        _jobId = jobId;
    }

    /// &lt;inheritdoc/&gt;
    public override object Resolve(Type type)
    {
        var res = ActivatorUtilities.GetServiceOrCreateInstance(_serviceScope.ServiceProvider, type);
        return res;
    }

    /// &lt;inheritdoc/&gt;
    public override void DisposeScope()
    {
        _serviceScope.Dispose();
    }
}
</code></pre>
<br>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// JobActivator.
/// &lt;/summary&gt;
public class HangfireActivator : JobActivator
{
    private readonly IServiceScopeFactory _serviceScopeFactory;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="HangfireActivator"/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name="serviceScopeFactory"&gt;&lt;/param&gt;
    public HangfireActivator(IServiceScopeFactory serviceScopeFactory)
    {
        _serviceScopeFactory = serviceScopeFactory ?? throw new ArgumentNullException(nameof(serviceScopeFactory));
    }

    /// &lt;inheritdoc/&gt;
    public override JobActivatorScope BeginScope(JobActivatorContext context)
    {
        return new HangfireJobActivatorScope(_serviceScopeFactory.CreateScope(), context.BackgroundJob.Id);
    }
}
</code></pre>
<h4 id="第二步"><strong>第二步</strong></h4>
<p>配置 Hangfire 服务，使其支持 Redis，并且配置一些参数。</p>
<pre><code class="language-csharp">private void ConfigureHangfire(IServiceCollection services)
{
	var options =
		new RedisStorageOptions
		{
            // 配置 redis 前缀，每个任务实例都会创建一个 key
			Prefix = "aaa:aaa:hangfire",
		};

	services.AddHangfire(
		config =&gt;
		{
			config.UseRedisStorage("{redis连接字符串}", options)
			.SetDataCompatibilityLevel(CompatibilityLevel.Version_180)
			.UseSimpleAssemblyNameTypeSerializer()
			.UseRecommendedSerializerSettings();
			config.UseActivator(new HangfireActivator(services.BuildServiceProvider().GetRequiredService&lt;IServiceScopeFactory&gt;()));
		});

	services.AddHangfireServer(options =&gt;
	{
        // 注意，这里必须设置非常小的间隔
		options.SchedulePollingInterval = TimeSpan.FromSeconds(1);
        
        // 如果考虑到后续任务比较多，则需要调大此参数
		options.WorkerCount = 50;
	});
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105711542-959469925.png" alt="1744940846417" loading="lazy"></p>
<h4 id="第三步"><strong>第三步</strong></h4>
<p>实现 RecurringJobHandler 执行定时任务，发起 http 请求业务系统。</p>
<p>被调用方要返回 TaskInterfaceResponse 类型，主要考虑如果被调用方后续不需要在继续此定时任务，那么返回参数 <code>CancelTask = tre</code> 时，定时任务服务直接取消后续的任务即可，不需要被调用方手动调用接口取消。</p>
<pre><code class="language-csharp">public class RecurringJobHandler
{
    private readonly IServiceProvider _serviceProvider;
    public RecurringJobHandler(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    /// &lt;summary&gt;
    /// 执行任务.
    /// &lt;/summary&gt;
    /// &lt;param name="taskRequest"&gt;&lt;/param&gt;
    /// &lt;returns&gt;Task.&lt;/returns&gt;
    public async Task Handler(TaskRequest taskRequest)
    {
        var ioc = _serviceProvider;

        var recurringJobManager = ioc.GetRequiredService&lt;IRecurringJobManager&gt;();
        var httpClientFactory = ioc.GetRequiredService&lt;IHttpClientFactory&gt;();
        var logger = ioc.GetRequiredService&lt;ILogger&lt;RecurringJobHandler&gt;&gt;();
        using var httpClient = httpClientFactory.CreateClient(taskRequest.ServiceName);

        // 无论是否请求成功，都算完成了本次任务
        try
        {
            // 请求子系统的接口
            var response = await httpClient.PostAsJsonAsync(taskRequest.ServiceName, taskRequest);

            var execteResult = await response.Content.ReadFromJsonAsync&lt;ExecteTasResult&gt;();

            // 被调用方要求取消任务
            if (execteResult != null &amp;&amp; execteResult.CancelTask)
            {
                recurringJobManager.RemoveIfExists(taskRequest.TaskId);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Task error.");
        }
    }
}
</code></pre>
<h4 id="第四步"><strong>第四步</strong></h4>
<p>配置好 Hangfire 后，开始考虑如何接收任务和发起请求，首先定义一个 Http 接口或 grpc 接口。</p>
<pre><code class="language-csharp">[ApiController]
[Route("/execute")]
public class HangfireController : ControllerBase
{
    private readonly IRecurringJobManager _recurringJobManager;

    public HangfireController(IRecurringJobManager recurringJobManager)
    {
        _recurringJobManager = recurringJobManager;
    }

    [HttpPost("addtask")]
    public async Task&lt;TaskResponse&gt; AddTask(TaskRequest value)
    {
        await Task.CompletedTask;
        _recurringJobManager.AddOrUpdate&lt;RecurringJobHandler&gt;(
            value.TaskId,
            task =&gt; task.Handler(value),
            cronExpression: value.CronExpression,
            options: new RecurringJobOptions
            {
            });
        return new TaskResponse {  };
    }

    [HttpPost("cancel")]
    public async Task&lt;TaskResponse&gt; Cancel(CancelTaskRequest value)
    {
        await Task.CompletedTask;
        _recurringJobManager.RemoveIfExists(value.TaskId);

        return new TaskResponse
        {
        };
    }
}

</code></pre>
<h3 id="业务服务实现动态代码">业务服务实现动态代码</h3>
<p>业务服务只需要暴露一个 <code>exceute</code> 接口给 HangfireServer 即可，DemoApi 将 Command 序列化包装为请求参数给 HangfireServer ，然后 HangfireServer 原封不动地将参数请求到 <code>exceute</code> 接口。</p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105712173-1440172227.png" alt="image-20250418095553964" loading="lazy"></p>
<br>
<p>对 DemoApi 主要设计过程如下：</p>
<ul>
<li>定义 SendHangfireService 服务，包装 Command 数据和一些定时任务参数，通过 http 发送到 HangfireServer 中；</li>
<li>定义 ExecuteTaskHandler ，当接口被触发时，实现反序列化参数并使用 MediatR 发送 Command，实现动态执行；</li>
<li>定义 ExecuteController 接口，接收 HangfireServer 请求，并调用 ExecuteTaskHandler 处理请求；</li>
</ul>
<br>
<p>DemoApi 引入类库如下-：</p>
<pre><code class="language-xml">&lt;PackageReference Include="Maomi.Core" Version="2.2.0" /&gt;-
&lt;PackageReference Include="MediatR" Version="12.5.0" /&gt;
</code></pre>
<blockquote>
<p>Maomi.Core 是一个模块化和自动服务注册框架。</p>
</blockquote>
<br>
<h4 id="第一步-1">第一步</h4>
<p>定义 SendHangfireService 服务，包装 Command 数据和一些定时任务参数，通过 http 发送到 HangfireServer 中。</p>
<p>接收 HangfireServer 请求时，需要通过字符串查找出 Type，这就需要 DemoApi 启动时，自动扫描程序集并将对应的类型缓存起来。</p>
<p>为了将定时任务命令和其它 Command 区分处理，需要定义一个统一的抽象，当然也可以不这样做，也可以通过特性注解的方式做处理。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 定时任务抽象参数.
/// &lt;/summary&gt;
public abstract class HangfireRequest : IRequest&lt;HangfireResponse&gt;
{
    /// &lt;summary&gt;
    /// 定时任务 id.
    /// &lt;/summary&gt;
    public string TaskId { get; init; } = string.Empty;

    /// &lt;summary&gt;
    /// 该任务创建时间.
    /// &lt;/summary&gt;
    public DateTimeOffset CreateTime { get; init; }
}
</code></pre>
<br>
<p>定义 HangireTypeFactory ，以便能够通过字符串快速查找 Type。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 记录 CQRS 中的命令类型，以便能够通过字符串快速查找 Type.
/// &lt;/summary&gt;
public class HangireTypeFactory
{
    private readonly ConcurrentDictionary&lt;string, Type&gt; _typeDictionary;
    public HangireTypeFactory()
    {
        _typeDictionary = new ConcurrentDictionary&lt;string, Type&gt;();
    }

    public void Add(Type type)
    {
        if (!_typeDictionary.ContainsKey(type.Name))
        {
            _typeDictionary[type.Name] = type;
        }
    }

    public Type? Get(string typeName)
    {
        if (_typeDictionary.TryGetValue(typeName, out var type))
        {
            return type;
        }

        return _typeDictionary.FirstOrDefault(x =&gt; x.Value.FullName == typeName).Value;
    }
}
</code></pre>
<br>
<p>最后实现 SendHangfireService 服务，能够包装参数发送到 HangfireServer 中。</p>
<blockquote>
<p>当然，可以使用 CQRS 处理。</p>
</blockquote>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 定时任务服务，用于发送定时任务请求.
/// &lt;/summary&gt;
[InjectOnScoped]
public class SendHangfireService
{
    private static readonly JsonSerializerOptions JsonOptions = new JsonSerializerOptions
    {
        AllowTrailingCommas = true,
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        ReadCommentHandling = JsonCommentHandling.Skip
    };

    private readonly IHttpClientFactory _httpClientFactory;

    public SendHangfireService(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    /// &lt;summary&gt;
    /// 发送定时任务请求.
    /// &lt;/summary&gt;
    /// &lt;typeparam name="TCommand"&gt;&lt;/typeparam&gt;
    /// &lt;param name="request"&gt;&lt;/param&gt;
    /// &lt;param name="cancellationToken"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="TypeLoadException"&gt;&lt;/exception&gt;
    public async Task Send&lt;TCommand&gt;(TCommand request)
        where TCommand : HangfireRequest
    {
        using var httpClient = _httpClientFactory.CreateClient();

        var taskRequest = new TaskRequest
        {
            TaskId = request.TaskId,
            CommandBody = JsonSerializer.Serialize(request, JsonOptions),
            ServiceName = "http://127.0.0.1:5000/hangfire/execute",
            CommandType = typeof(TCommand).Name ?? throw new TypeLoadException(typeof(TCommand).Name),
            CreateTime = request.CreateTime.ToUnixTimeMilliseconds().ToString(),
            CronExpression = request.CronExpression,
        };

        _ = await httpClient.PostAsJsonAsync("http://127.0.0.1:5001/execute/addtask", taskRequest);
    }

    /// &lt;summary&gt;
    /// 取消定时任务.
    /// &lt;/summary&gt;
    /// &lt;param name="taskId"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task Cancel(string taskId)
    {
        using var httpClient = _httpClientFactory.CreateClient();
        _ = await httpClient.PostAsJsonAsync("http://127.0.0.1:5001/hangfire/cancel", new CancelTaskRequest
        {
            TaskId = taskId
        });

    }
}
</code></pre>
<h4 id="第二步-1">第二步</h4>
<p>要实现通过 Type 动态执行某个 Command ，其实思路比较简单，也并不需要表达式树等麻烦的方式。</p>
<p>笔者的实现思路如下，定义 ExecuteTaskHandler 泛型类，直接以强类型的方式触发 Command，但是为了屏蔽泛型类型强类型在代码调用中的麻烦，需要再抽象一个接口  IHangfireTaskHandler 屏蔽泛型。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 定义执行任务的抽象，便于忽略泛型处理.
/// &lt;/summary&gt;
public interface IHangfireTaskHandler
{
    /// &lt;summary&gt;
    /// 执行任务.
    /// &lt;/summary&gt;
    /// &lt;param name="taskRequest"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    Task&lt;ExecteTasResult&gt; Handler(TaskRequest taskRequest);
}
</code></pre>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 用于反序列化参数并发送 Command.
/// &lt;/summary&gt;
/// &lt;typeparam name="TCommand"&gt;命令.&lt;/typeparam&gt;
public class ExecuteTaskHandler&lt;TCommand&gt; : IHangfireTaskHandler
    where TCommand : HangfireRequest, IRequest&lt;ExecteTasResult&gt;
{
    private readonly IMediator _mediator;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="ExecuteTaskHandler{TCommand}"/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name="mediator"&gt;&lt;/param&gt;
    public ExecuteTaskHandler(IMediator mediator)
    {
        _mediator = mediator;
    }

    private static readonly JsonSerializerOptions JsonSerializerOptions = new JsonSerializerOptions
    {
        AllowTrailingCommas = true,
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        ReadCommentHandling = JsonCommentHandling.Skip
    };

    /// &lt;inheritdoc/&gt;
    public async Task&lt;ExecteTasResult&gt; Handler(TaskRequest taskRequest)
    {
        var command = JsonSerializer.Deserialize&lt;TCommand&gt;(taskRequest.CommandBody, JsonSerializerOptions)!;
        if (command == null)
        {
            throw new Exception("解析命令参数失败");
        }

        // 处理命令的逻辑
        var response = await _mediator.Send(command);
        return response;
    }
}
</code></pre>
<h4 id="第三步-1">第三步</h4>
<p>实现定时任务 <code>execute</code> 触发接口，然后将参数转发到 ExecuteTaskHandler 中，这里通过依赖注入的方式屏蔽和解决强类型的问题。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 定时任务触发入口.
/// &lt;/summary&gt;
[ApiController]
[Route("/hangfire")]
public class ExecuteController : ControllerBase
{
    private readonly IServiceProvider _serviceProvider;
    private readonly HangireTypeFactory _hangireTypeFactory;

    public ExecuteController(IServiceProvider serviceProvider, HangireTypeFactory hangireTypeFactory)
    {
        _serviceProvider = serviceProvider;
        _hangireTypeFactory = hangireTypeFactory;
    }

    [HttpPost("execute")]
    public async Task&lt;ExecteTasResult&gt; ExecuteTask([FromBody] TaskRequest request)
    {
        var commandType = _hangireTypeFactory.Get(request.CommandType);

        // 找不到该事件类型，取消后续事件执行
        if (commandType == null)
        {
            return new ExecteTasResult
            {
                CancelTask = true
            };
        }

        var commandTypeHandler = typeof(ExecuteTaskHandler&lt;&gt;).MakeGenericType(commandType);

        var handler = _serviceProvider.GetService(commandTypeHandler) as IHangfireTaskHandler;
        if(handler == null)
        {
            return new ExecteTasResult
            {
                CancelTask = true
            };
        }

        return await handler.Handler(request);
    }
}
</code></pre>
<h4 id="第四步-1">第四步</h4>
<p>封装好代码后，开始最后一个环境，配置和注册服务，由于笔者使用 <code>Maomi.Core</code> 框架，因此服务注册配置和扫描程序集变得非常简单，只需要通过 <code>Maomi.Core</code> 框架提供的接口即可最简单地实现功能。</p>
<pre><code class="language-csharp">public class ApiModule : Maomi.ModuleCore, IModule
{
    private readonly HangireTypeFactory _hangireTypeFactory;

    public ApiModule()
    {
        _hangireTypeFactory = new HangireTypeFactory();
    }

    public override void ConfigureServices(ServiceContext context)
    {
        context.Services.AddTransient(typeof(ExecuteTaskHandler&lt;&gt;));
        context.Services.AddSingleton(_hangireTypeFactory);
        context.Services.AddHttpClient();
        context.Services.AddMediatR(o =&gt;
        {
            o.RegisterServicesFromAssemblies(context.Modules.Select(x =&gt; x.Assembly).ToArray());
        });
    }

    public override void TypeFilter(Type type)
    {
        if (!type.IsClass || type.IsAbstract)
        {
            return;
        }

        if (type.IsAssignableTo(typeof(HangfireRequest)))
        {
            _hangireTypeFactory.Add(type);
        }
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105712698-552988339.png" alt="1744942983410" loading="lazy"></p>
<h4 id="第五步">第五步</h4>
<p>开发者可以这样写定时任务 Command 以及执行器，然后通过接口触发定时任务。</p>
<pre><code class="language-csharp">public class MyTestRequest : HangfireRequest, IRequest&lt;ExecteTasResult&gt;
{
}


/// &lt;summary&gt;
/// 要被定时任务执行的代码.
/// &lt;/summary&gt;
public class MyTestHandler : IRequestHandler&lt;MyTestRequest, ExecteTasResult&gt;
{
    private static volatile int _count;
    private static DateTimeOffset _lastTime;

    public async Task&lt;ExecteTasResult&gt; Handle(MyTestRequest request, CancellationToken cancellationToken)
    {
        _count++;
        if (_lastTime == default)
        {
            _lastTime = DateTimeOffset.Now;
        }

        Console.WriteLine($"""
            执行时间：{DateTimeOffset.Now.ToString("HH:mm:ss.ffff")}
            执行频率(每 10s)：{(_count / (DateTimeOffset.Now - _lastTime).TotalSeconds * 10)}
            """);

        return new ExecteTasResult
        {
            CancelTask = false
        };
    }
}
</code></pre>
<pre><code class="language-csharp">[ApiController]
[Route("/test")]
public class SendTaskController : ControllerBase
{
    private readonly SendHangfireService _hangfireService;

    public SendTaskController(SendHangfireService hangfireService)
    {
        _hangfireService = hangfireService;
    }

    [HttpGet("aaa")]
    public async Task&lt;string&gt; SendAsync()
    {
        await _hangfireService.Send(new MyTestRequest
        {
            CreateTime = DateTimeOffset.Now,
            CronExpression = "* * * * * *",
            TaskId = Guid.NewGuid().ToString(),
        });

        return "aaa";
    }
}

</code></pre>
<h3 id="最后">最后</h3>
<p>启动项目测试代码，记录执行频率和时间间隔。</p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105713429-271305303.png" alt="image-20250418103509714" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1315495/202504/1315495-20250418105741809-446806948.gif" alt="动画" loading="lazy"></p>

</div>
<div id="MySignature" role="contentinfo">
    痴者工良(https://whuanle.cn)
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.044986953355324" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 11:14">2025-04-18 11:08</span>&nbsp;
<a href="https://www.cnblogs.com/whuanle">痴者工良</a>&nbsp;
阅读(<span id="post_view_count">483</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18832422);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18832422', targetLink: 'https://www.cnblogs.com/whuanle/p/18832422', title: 'Hangfire Redis 实现秒级定时任务、使用 CQRS 实现动态执行代码' })">举报</a>
</div>
        