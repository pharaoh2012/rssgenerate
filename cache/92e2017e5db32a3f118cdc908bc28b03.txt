
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18663610" title="发布于 2025-02-26 10:43">
    <span role="heading" aria-level="2">Task VS ValueTask</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 C# 中，异步编程是构建响应式应用程序的基础。Task 是表示异步操作的首选类型。但是，在某些高性能场景中，与 Task 相关的开销可能会达到一个瓶颈。ValueTask 是 .NET Core 2.1 中引入的结构。与引用类型的 Task 不同，ValueTask 是一种值类型，这使得它在某些情况下效率更高，尤其是在异步操作通常同步完成时。</p>
<h3 id="1-task-的特点">1. <code>Task</code> 的特点</h3>
<h4 id="定义">定义</h4>
<ul>
<li>• <code>Task</code> 是 C# 中表示异步操作的基础类型。</li>
<li>• 它是一个引用类型，用于表示一个可能尚未完成的异步操作。</li>
</ul>
<h4 id="适用场景">适用场景</h4>
<ul>
<li>• 适用于大多数异步操作，尤其是那些可能需要较长时间完成的操作（如 I/O 操作、网络请求等）。</li>
<li>• 当异步操作的结果可能不会立即完成时，<code>Task</code> 是一个通用的选择。</li>
</ul>
<h4 id="优点">优点</h4>
<ul>
<li>• 功能强大，支持复杂的异步操作。</li>
<li>• 可以表示没有返回值（<code>Task</code>）和有返回值（<code>Task&lt;T&gt;</code>）的异步操作。</li>
<li>• 支持任务组合（如 <code>Task.WhenAll</code>、<code>Task.WhenAny</code>）。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>• 由于是引用类型，每次创建 <code>Task</code> 都会在堆上分配内存，可能对性能产生一定影响，尤其是在高频调用的场景中。</li>
</ul>
<h3 id="2-valuetask-的特点">2. <code>ValueTask</code> 的特点</h3>
<h4 id="定义-1">定义</h4>
<ul>
<li>• <code>ValueTask</code> 是 C# 7.0 引入的一种轻量级的异步操作类型。</li>
<li>• 它是一个值类型，用于表示可能同步完成或异步完成的操作。</li>
</ul>
<h4 id="适用场景-1">适用场景</h4>
<ul>
<li>• 适用于高频调用的异步操作，尤其是那些可能经常同步完成的操作。</li>
<li>• 当异步操作的结果可能立即完成时，<code>ValueTask</code> 可以避免不必要的堆分配，从而提高性能。</li>
</ul>
<h4 id="优点-1">优点</h4>
<ul>
<li>• 由于是值类型，<code>ValueTask</code> 在栈上分配内存，避免了堆分配的开销。</li>
<li>• 在同步完成的场景中，性能优于 <code>Task</code>。</li>
<li>• 支持与 <code>Task</code> 相同的功能，如 <code>await</code> 和异步操作组合。</li>
</ul>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>• 功能相对简单，不适合复杂的异步操作（均不支持任务组合、取消操作、任务状态等等）。</li>
<li>• 由于是值类型，不能为 <code>null</code>，且不能直接转换为 <code>Task</code>。</li>
</ul>
<h3 id="3-valuetask-和-task-的区别">3. <code>ValueTask</code> 和 <code>Task</code> 的区别</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Task</code></th>
<th><code>ValueTask</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>引用类型（class）</td>
<td>值类型（struct）</td>
</tr>
<tr>
<td>内存分配</td>
<td>堆分配</td>
<td>栈分配（在同步完成时）</td>
</tr>
<tr>
<td>性能</td>
<td>适用于大多数场景，但可能有堆分配开销</td>
<td>在高频调用或同步完成时性能更优</td>
</tr>
<tr>
<td>适用场景</td>
<td>通用异步操作</td>
<td>高频调用或可能同步完成的异步操作</td>
</tr>
<tr>
<td>复杂性</td>
<td>功能强大，支持复杂操作</td>
<td>功能相对简单</td>
</tr>
<tr>
<td>是否可为 <code>null</code></td>
<td>可以</td>
<td>不可以</td>
</tr>
</tbody>
</table>
<h3 id="4-举例说明">4. 举例说明</h3>
<h4 id="从缓存中读取数据">从缓存中读取数据</h4>
<p>假设有一个方法，尝试从缓存中读取数据。如果缓存中有数据，则直接返回；如果没有，则从数据库异步获取数据并缓存。</p>
<h5 id="使用-task-的实现">使用 <code>Task</code> 的实现</h5>
<pre><code>public&nbsp;async&nbsp;Task&lt;ProductDto&gt;&nbsp;GetProductAsync(int&nbsp;productId)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;key&nbsp;=&nbsp;$"Product_{productId}";

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;尝试从缓存中同步获取数据
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_memoryCache.TryGetValue(key,&nbsp;out&nbsp;var&nbsp;cachedData))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cachedData;&nbsp;//&nbsp;如果数据在缓存中，直接返回
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果数据不在缓存中，异步获取数据并缓存
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;data&nbsp;=&nbsp;await&nbsp;_productRepo.GetDataAsync(productId);
&nbsp;&nbsp;&nbsp;&nbsp;_memoryCache.Set(key,&nbsp;data,&nbsp;TimeSpan.FromMinutes(60));&nbsp;//&nbsp;设置缓存过期时间
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data;
}
</code></pre>
<ul>
<li>• 问题：
<ul>
<li>• 即使缓存命中（同步操作），<code>Task</code> 也会在堆上分配内存。</li>
<li>• 如果缓存命中率很高，频繁的内存分配会影响性能。</li>
</ul>
</li>
</ul>
<h5 id="使用-valuetask-的实现">使用 <code>ValueTask</code> 的实现</h5>
<pre><code>public&nbsp;async&nbsp;ValueTask&lt;ProductDto&gt;&nbsp;GetProductAsync(int&nbsp;productId)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;key&nbsp;=&nbsp;$"Product_{productId}";

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;尝试从缓存中同步获取数据
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_memoryCache.TryGetValue(key,&nbsp;out&nbsp;var&nbsp;cachedData))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cachedData;&nbsp;//&nbsp;如果数据在缓存中，直接返回
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果数据不在缓存中，异步获取数据并缓存
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;data&nbsp;=&nbsp;await&nbsp;_productRepo.GetDataAsync(productId);
&nbsp;&nbsp;&nbsp;&nbsp;_memoryCache.Set(key,&nbsp;data,&nbsp;TimeSpan.FromMinutes(60));&nbsp;//&nbsp;设置缓存过期时间
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data;
}
</code></pre>
<ul>
<li>• 优点：
<ul>
<li>• 如果缓存命中（同步操作），<code>ValueTask</code> 不会在堆上分配内存，性能更高。</li>
<li>• 如果缓存未命中（异步操作），<code>ValueTask</code> 会退化为 <code>Task</code>，性能与 <code>Task</code> 相同。</li>
</ul>
</li>
</ul>
<p><code>ValueTask</code> 的内部结构主要由以下两部分组成：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44535886/1736418480173-ceac26ff-5c46-4e3b-9c2f-7de3793fe1e5.png" alt="" title="null" loading="lazy"></p>
<ol>
<li>1. <code>TResult</code>：
<ul>
<li>• 用于存储同步操作的结果值。</li>
</ul>
</li>
<li>2. <code>Task&lt;TResult&gt;</code> 或 <code>IValueTaskSource&lt;TResult&gt;</code>：
<ul>
<li>• 用于表示异步操作的任务。</li>
</ul>
</li>
</ol>
<p>通过这种设计，<code>ValueTask</code> 可以根据操作的实际完成方式（同步或异步）动态选择最合适的实现方式。</p>
<h3 id="5如何选择">5.如何选择</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐类型</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>大多数异步操作（如 I/O 操作）</td>
<td><code>Task</code></td>
<td>代码简单，易于理解。</td>
</tr>
<tr>
<td>高频调用（如缓存读取）</td>
<td><code>ValueTask</code></td>
<td>减少内存分配，提升性能。</td>
</tr>
<tr>
<td>可能同步完成的操作</td>
<td><code>ValueTask</code></td>
<td>同步完成时不会分配堆内存。</td>
</tr>
<tr>
<td>长时间运行的操作</td>
<td><code>Task</code></td>
<td><code>Task</code>更适合长时间运行的异步操作。</td>
</tr>
<tr>
<td>需要多次 <code>await</code>的操作</td>
<td><code>Task</code></td>
<td><code>ValueTask</code>不能多次 <code>await</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="6-注意事项">6. 注意事项</h3>
<h4 id="task-的注意事项"><code>Task</code> 的注意事项</h4>
<ul>
<li>• 内存分配：
<ul>
<li>• 每次调用都会在堆上分配内存，即使操作是同步完成的。</li>
</ul>
</li>
<li>• 简单性：
<ul>
<li>• 代码更易于理解和维护。</li>
</ul>
</li>
</ul>
<h4 id="valuetask-的注意事项"><code>ValueTask</code> 的注意事项</h4>
<ul>
<li>• 不能多次 <code>await</code>：
<ul>
<li>• <code>ValueTask</code> 只能被 <code>await</code> 一次，如果需要多次等待，应先转换为 <code>Task</code>。</li>
<li>• 例如：<code>await (await GetProductAsync()).ConfigureAwait(false);</code> 是不允许的。</li>
</ul>
</li>
<li>• 复杂性：
<ul>
<li>• 需要更多注意，避免误用。</li>
</ul>
</li>
<li>• 性能优化：
<ul>
<li>• 只有在高频调用或可能同步完成的场景下，<code>ValueTask</code> 的性能优势才明显。</li>
</ul>
</li>
</ul>
<h3 id="7总结">7.总结</h3>
<ul>
<li>• <code>Task</code>：
<ul>
<li>• 适用于大多数异步场景，代码简单易用。</li>
<li>• 每次调用都会在堆上分配内存。</li>
</ul>
</li>
<li>• <code>ValueTask</code>：
<ul>
<li>• 适用于高频调用或可能同步完成的场景，性能更高。</li>
<li>• 需要更多注意，避免误用。</li>
</ul>
</li>
</ul>
<p>根据你的具体需求选择合适的类型。如果性能是关键，且缓存命中率较高，推荐使用 <code>ValueTask</code>；否则，使用 <code>Task</code> 是更通用的选择。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202502/2063798-20250225115552178-1733613084.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4904054209814815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 10:43">2025-02-26 10:43</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">270</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18663610" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18663610);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18663610', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18663610', title: 'Task VS ValueTask' })">举报</a>
</div>
        