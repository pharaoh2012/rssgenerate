
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19035523" title="发布于 2025-08-13 12:07">
    <span role="heading" aria-level="2">【渲染流水线】[几何阶段]-[曲面细分]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250813121315216-901546302.png" alt="【渲染流水线】[几何阶段]-[曲面细分]以UnityURP为例" class="desc_img">
        本文介绍了细分着色器的核心原理与实现方法。细分着色器分为曲面细分着色器和细分计算着色器，主要用于动态增加模型细节，提升草地、地形等场景的渲染效果。文章详细解析了细分过程的三个阶段：Hull Shader定义细分因子，Tessellation Primitive Generator执行硬件级细分操作，Domain Shader完成顶点空间转换。重点阐述了Delaunay三角剖分原则在URP中的实现，包括空圆特性和局部优化方法。最后提供了一个完整的URP细分着色器示例，展示了动态细分控制、顶点位移等关键技术，并
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li><strong>细分着色器分为</strong>：曲面细分着色器（Unity在指定平台硬件支持）、细分计算着色器。使用片面来描述一个物体形状，并增加顶点和片面数量，使模型外观开起来更平滑。</li>
<li>‌<strong>作用</strong>‌：动态细分三角面片，提升模型细节（如草地、地形渲染），优化大场景性能 ‌。</li>
<li>这是一个‌<strong>可选</strong>‌阶段。它在顶点着色器之后运行，负责根据设定的细分因子 (Tessellation Factor) 将输入的图元（通常是三角形面片）动态细分为更小的三角面片，生成更多顶点。‌</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="三个子阶段">三个子阶段：</h1>
<h2 id="hull-shader定义每条边和内部分割因子tessellation-factor">Hull Shader：定义每条边和内部分割因子（Tessellation Factor）。‌</h2>
<ul>
<li>接收原始控制点数据并定义细分因子(Tessellation Factor)</li>
<li>通过<code>patch constant function</code>计算每条边和内部的细分等级</li>
<li>支持分数细分模式(fractional_odd/fractional_even)实现平滑过渡</li>
</ul>
<h3 id="目标"><strong>目标</strong>‌：</h3>
<ul>
<li>定义原始控制点数据并计算细分因子(Tessellation Factor)</li>
<li>确定每个patch的边和内部细分等级</li>
</ul>
<h3 id="输入输出">‌<strong>输入输出</strong>‌：</h3>
<ul>
<li>输入：原始控制点数据（位置、法线、UV等）</li>
<li>输出：
<ul>
<li>细分因子（<code>SV_TessFactor</code>标记边，<code>SV_InsideTessFactor</code>标记内部）</li>
<li>处理后的控制点数据（通过<code>INTERNALTESSPOS</code>语义标记）</li>
</ul>
</li>
</ul>
<h3 id="实现关键">‌<strong>实现关键</strong>‌：</h3>
<pre><code class="language-glsl">hlsl
struct TessFactors {
    float edge[3] : SV_TessFactor; // 三条边的细分因子
    float inside : SV_InsideTessFactor; // 内部细分因子
};
</code></pre>
<h2 id="tessellation-primitive-generator-固定功能硬件根据-hull-shader-输出的因子实际执行细分操作">‌<strong>Tessellation Primitive Generator 固定功能</strong>‌：硬件根据 Hull Shader 输出的因子实际执行细分操作。‌</h2>
<ul>
<li>GPU固定功能阶段，根据Hull Shader输出的细分因子生成新顶点拓扑</li>
</ul>
<h3 id="目标-1"><strong>目标</strong>‌：</h3>
<ul>
<li>根据Hull Shader输出的细分因子生成新顶点拓扑</li>
<li>将原始patch细分为更密集的三角网格</li>
</ul>
<h3 id="输入输出-1">‌<strong>输入输出</strong>‌：</h3>
<ul>
<li>
<p><strong>输入：Hull Shader输出的细分因子和控制点</strong></p>
<pre><code class="language-glsl">hlsl

// 来自Hull Shader的输出
struct TessControlPoint {
    float4 positionOS : INTERNALTESSPOS;
    float3 normalOS : NORMAL;
    float2 uv : TEXCOORD0;
};

// 细分因子定义
struct TessFactors {
    float edge[3] : SV_TessFactor; // 每条边的细分等级
    float inside : SV_InsideTessFactor; // 内部细分等级
};
</code></pre>
</li>
<li>
<p><strong>输出：细分后的顶点UV坐标和拓扑关系</strong></p>
<ul>
<li>
<p>生成的重心坐标数据：</p>
<pre><code class="language-glsl">hlsl
float3 baryCoords : SV_DomainLocation; // 新顶点的重心坐标
</code></pre>
</li>
<li>
<p>输出拓扑类型由Hull Shader的<code>[outputtopology]</code>属性定义（如triangle_cw）</p>
</li>
</ul>
</li>
</ul>
<h3 id="特性">‌<strong>特性</strong>‌：</h3>
<ul>
<li>GPU自动执行，无需开发者编码</li>
<li>支持分数细分模式实现平滑过渡</li>
</ul>
<h2 id="实现原理"><strong>实现原理</strong></h2>
<h3 id="细分算法">‌<strong>细分算法</strong>‌</h3>
<ul>
<li>
<p>对原始三角面片进行递归细分，采用Delaunay三角剖分原则</p>
<p>GPU使用的Delaunay三角剖分原则是一种优化网格拓扑的数学方法</p>
<ul>
<li>
<p>‌<strong>Delaunay三角剖分原则</strong>‌</p>
<ol>
<li>‌<strong>空圆特性</strong>‌：任意三角形的外接圆内不包含其他顶点</li>
<li>‌<strong>最大化最小角</strong>‌：避免出现尖锐三角形，提高网格质量</li>
<li>‌<strong>局部优化</strong>‌：通过边翻转(edge flip)逐步优化三角网格</li>
</ol>
</li>
<li>
<p>‌<strong>URP中的实现特点</strong>‌：</p>
<ol>
<li>在Tessellation Primitive Generator阶段自动应用</li>
<li>对细分后的新顶点进行拓扑优化</li>
<li>保持与原网格的平滑过渡</li>
</ol>
</li>
<li>
<p>‌<strong>具体示例</strong>‌：</p>
<p>原始三角面片（控制点A/B/C）经过细分后：</p>
<ul>
<li>计算细分因子为3时：</li>
</ul>
<pre><code>原始三角形： A
            / \
           C---B

细分后拓扑：
      A
     /|\
    / | \
   C--D--B
    \ | /
     \|/
      E
</code></pre>
<ul>
<li>其中D/E是新生成的顶点，所有三角形都满足：
<ul>
<li>∠ADB + ∠AEB ≈ 180°</li>
<li>外接圆不包含其他顶点</li>
</ul>
</li>
</ul>
</li>
<li>
<p>‌<strong>URP中的实际应用</strong>‌：</p>
<ol>
<li>当使用<code>[partitioning("fractional_odd")]</code>时：
<ul>
<li>会在过渡区域自动应用Delaunay优化</li>
<li>确保不同细分等级间的平滑连接</li>
</ul>
</li>
<li>位移贴图处理时：
<ul>
<li>新顶点根据Delaunay规则分布</li>
<li>位移后的法线计算更准确</li>
</ul>
</li>
</ol>
</li>
<li>
<p>这种剖分方式使得：</p>
<ul>
<li>细分后的网格更适应曲面变形</li>
<li>避免渲染时的褶皱现象</li>
<li>提升位移贴图的视觉效果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>根据分数细分模式（fractional_odd/even）处理过渡区域</p>
</li>
</ul>
<h3 id="坐标转换-pnewp0up1vp2w">‌坐标转换 $Pnew=P0⋅u+P1⋅v+P2⋅w$</h3>
<ul>
<li>将参数空间坐标(u,v,w)转换为新的顶点位置</li>
</ul>
<h3 id="性能优化"><strong>性能优化</strong>‌</h3>
<ul>
<li>采用并行计算处理多个patch</li>
<li>自动剔除屏幕空间不可见的细分结果</li>
</ul>
<h2 id="domain-shader">‌<strong>Domain Shader</strong>‌：</h2>
<p>将细分后位于<strong>重心坐标系</strong>(<em>重心坐标内容后续单开一篇讲解</em>)中的新顶点位置转换到目标空间（如世界空间或裁剪空间）。‌</p>
<ul>
<li>将细分后的UV坐标映射到3D空间</li>
<li>执行顶点位移等后期处理</li>
</ul>
<h3 id="目标-2"><strong>目标</strong>‌：</h3>
<ul>
<li>将细分后的UV坐标映射到3D空间</li>
<li>执行顶点位移等后期处理</li>
</ul>
<h3 id="输入输出-2">‌<strong>输入输出</strong>‌：</h3>
<ul>
<li>输入：细分后的UV坐标和原始控制点数据</li>
<li>输出：最终顶点位置（<code>SV_POSITION</code>）和其他顶点属性</li>
</ul>
<h3 id="实现示例">‌<strong>实现示例</strong>‌：</h3>
<pre><code class="language-glsl">hlsl
[domain("tri")] // 声明处理三角形patch
Varyings domain(TessFactors factors, OutputPatch&lt;DomainAttributes, 3&gt; patch, float3 baryCoords : SV_DomainLocation) {
    Varyings OUT;
    // 插值计算新顶点属性
    OUT.positionWS = TransformObjectToWorld(patch[0].positionOS * baryCoords.x + ...);
    return OUT;
}
</code></pre>
<h3 id="动态控制技巧">‌<strong>动态控制技巧</strong>‌：</h3>
<ul>
<li>
<p>通过摄像机距离调整细分因子：</p>
<pre><code class="language-glsl">hlsl
float CalcTessFactor(float3 worldPos) {
    return lerp(_MaxTess, _MinTess, saturate(distance(_WorldSpaceCameraPos, worldPos) / _TessRange));
}
</code></pre>
</li>
<li>
<p>结合高度图实现位移效果</p>
</li>
</ul>
<h1 id="配置">‌配置：</h1>
<ul>
<li>需显式启用（HLSL 中声明&nbsp;<code>hull</code>&nbsp;和&nbsp;<code>domain</code>&nbsp;函数）。</li>
<li>必须声明<code>#pragma target 4.6</code>以启用DX11/OpenGL Core特性3</li>
<li>需手动实现Hull/Domain Shader，URP不提供表面着色器的简化写法</li>
<li>建议结合摄像机距离动态控制细分因子以优化性能</li>
</ul>
<h1 id="urp中的具体实现步骤">URP中的具体实现步骤：</h1>
<h2 id="声明编译目标为46以上">声明编译目标为4.6以上：</h2>
<pre><code class="language-glsl">hlsl
#pragma target 4.6
</code></pre>
<h2 id="定义三个关键程序">定义三个关键程序：</h2>
<pre><code class="language-glsl">hlsl
#pragma vertex BeforeTessVert
#pragma hull HullProgram
#pragma domain DomainProgram
</code></pre>
<h2 id="控制点数据结构需包含顶点位置法线等基础属性">控制点数据结构需包含顶点位置、法线等基础属性</h2>
<h3 id="动态细分控制样例">‌动态细分控制样例：</h3>
<ul>
<li>通过距离或屏幕空间尺寸自动调整细分因子：</li>
</ul>
<pre><code class="language-glsl">hlsl
// 根据摄像机距离动态计算细分因子
float CalcTessFactor(float3 worldPos) {
    float dist = distance(_WorldSpaceCameraPos, worldPos);
    return lerp(_MaxTess, _MinTess, saturate(dist / _TessRange));
}
</code></pre>
<h3 id="常见应用场景">常见应用场景：</h3>
<ul>
<li>地形动态LOD：根据视角距离细分地面网格3</li>
<li>曲面平滑：将低模转换为高模曲面2</li>
<li>动态位移：结合高度图实现实时凹凸效果6</li>
</ul>
<h3 id="注意事项">‌注意事项：</h3>
<ul>
<li>仅支持DX11/OpenGL Core等现代图形API6</li>
<li>细分过度会导致性能下降，需合理设置上限5</li>
<li>URP中需手动实现Hull/Domain Shader，不同于内置管线的表面着色器简化写法</li>
</ul>
<h2 id="unity-urp中完整的曲面细分着色器示例包含顶点位移效果和动态细分控制"><strong>Unity URP中完整的曲面细分着色器示例，包含顶点位移效果和动态细分控制</strong></h2>
<h2 id="示例实现功能"><strong>示例实现功能：</strong></h2>
<ul>
<li>动态细分控制：根据摄像机距离自动调整细分因子</li>
<li>顶点位移效果：通过高度图(_DispTex)驱动顶点偏移</li>
<li>分数细分模式：使用fractional_odd实现平滑过渡</li>
<li>完整渲染管线：包含顶点/细分/片元全阶段处理</li>
<li>URP兼容性：使用URP的ShaderLibrary核心函数</li>
</ul>
<h2 id="使用说明"><strong>使用说明：</strong></h2>
<ul>
<li>创建材质球并应用此着色器</li>
<li>为_DispTex指定高度图纹理</li>
<li>调整_TessFactor控制细分密度</li>
<li>通过_Displacement参数控制位移强度</li>
</ul>
<h2 id="tessellationexampleshader"><strong>TessellationExample.shader</strong></h2>
<pre><code class="language-glsl">// HLSL
Shader "Custom/TessellationExample"
{
    Properties
    {
        _MainTex ("Base Texture", 2D) = "white" {}
        _TessFactor ("Tessellation Factor", Range(1, 64)) = 4
        _Displacement ("Displacement", Range(0, 1.0)) = 0.3
        _DispTex ("Displacement Texture", 2D) = "gray" {}
    }

    SubShader
    {
        Tags { "RenderPipeline"="UniversalPipeline" }

        HLSLINCLUDE
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

        struct Attributes
        {
            float4 positionOS : POSITION;
            float3 normalOS : NORMAL;
            float2 uv : TEXCOORD0;
        };

        struct TessControlPoint
        {
            float4 positionOS : INTERNALTESSPOS;
            float3 normalOS : NORMAL;
            float2 uv : TEXCOORD0;
        };

        struct TessFactors
        {
            float edge[3] : SV_TessFactor;
            float inside : SV_InsideTessFactor;
        };

        struct DomainOutput
        {
            float4 positionCS : SV_POSITION;
            float2 uv : TEXCOORD0;
            float3 normalWS : NORMAL;
        };
        ENDHLSL

        Pass
        {
            Name "ForwardLit"
            Tags { "LightMode"="UniversalForward" }

            HLSLPROGRAM
            #pragma vertex vert
            #pragma hull hull
            #pragma domain domain
            #pragma fragment frag
            #pragma target 4.6

            sampler2D _MainTex;
            sampler2D _DispTex;
            float _TessFactor;
            float _Displacement;

            TessControlPoint vert(Attributes v)
            {
                TessControlPoint o;
                o.positionOS = v.positionOS;
                o.normalOS = v.normalOS;
                o.uv = v.uv;
                return o;
            }

            [domain("tri")]
            [partitioning("fractional_odd")]
            [outputtopology("triangle_cw")]
            [outputcontrolpoints(3)]
            [patchconstantfunc("patchConstantFunc")]
            TessControlPoint hull(InputPatch&lt;TessControlPoint, 3&gt; patch, uint id : SV_OutputControlPointID)
            {
                return patch[id];
            }

            TessFactors patchConstantFunc(InputPatch&lt;TessControlPoint, 3&gt; patch)
            {
                TessFactors f;
                float avgTess = _TessFactor * (1 - saturate(length(_WorldSpaceCameraPos - TransformObjectToWorld(patch[0].positionOS.xyz)) / 20));
                f.edge[0] = f.edge[1] = f.edge[2] = avgTess;
                f.inside = avgTess;
                return f;
            }

            [domain("tri")]
            DomainOutput domain(TessFactors factors, OutputPatch&lt;TessControlPoint, 3&gt; patch, float3 baryCoords : SV_DomainLocation)
            {
                DomainOutput o;
                
                // 插值计算基础属性
                float3 positionOS = patch[0].positionOS.xyz * baryCoords.x + 
                                   patch[1].positionOS.xyz * baryCoords.y + 
                                   patch[2].positionOS.xyz * baryCoords.z;
                
                float2 uv = patch[0].uv * baryCoords.x + 
                            patch[1].uv * baryCoords.y + 
                            patch[2].uv * baryCoords.z;
                
                // 从高度图获取位移值
                float disp = tex2Dlod(_DispTex, float4(uv, 0, 0)).r * _Displacement;
                positionOS += normalize(patch[0].normalOS) * disp;
                
                // 转换到裁剪空间
                o.positionCS = TransformObjectToHClip(positionOS);
                o.uv = uv;
                o.normalWS = TransformObjectToWorldNormal(patch[0].normalOS);
                return o;
            }

            half4 frag(DomainOutput i) : SV_Target
            {
                half4 col = tex2D(_MainTex, i.uv);
                return col;
            }
            ENDHLSL
        }
    }
}
</code></pre>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎点赞留言探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-08-13 12:14">2025-08-13 12:07</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">41</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19035523);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19035523', targetLink: 'https://www.cnblogs.com/SmalBox/p/19035523', title: '【渲染流水线】[几何阶段]-[曲面细分]以UnityURP为例' })">举报</a>
</div>
        