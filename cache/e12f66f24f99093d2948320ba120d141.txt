
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mingupupu/p/18843138" title="发布于 2025-04-23 17:33">
    <span role="heading" aria-level="2">使用这个工具，基于代码仓库直接生成教程文档，感觉比我自己写的还好</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>我比较喜欢写教程，但是纯手写的话，一方面太麻烦了，另一方面就是觉得自己写的不太好，很多时候都喜欢直接贴代码算了。但直接贴代码对有编程基础的人而言可能很有帮助，但是对想入门的小白而言，一上来就是一大堆代码就很容易劝退。</p>
<p>怎么把教程写好，是我一直都在探索的事情。</p>
<p>昨天在GitHub上偶然刷到了一个项目，说是基于代码仓库直接就能生成教程文档，我抱着试一试的心态去尝试了一下，结果确实被惊艳到了，今天就来分享给大家，我也会带大家实践一下。</p>
<p>这个项目叫Tutorial-Codebase-Knowledge。</p>
<p>GitHub地址：<a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge" target="_blank" rel="noopener nofollow">https://github.com/The-Pocket/Tutorial-Codebase-Knowledge</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3288240/202504/3288240-20250423173332080-1986574020.png" alt="image-20250423163151094" loading="lazy"></p>
<h2 id="tutorial-codebase-knowledge介绍">Tutorial-Codebase-Knowledge介绍</h2>
<p>这是一个 Pocket Flow 的教程项目，一个仅100行代码的LLM框架。它爬取 GitHub 仓库，并从代码中构建知识库。它分析整个代码库以识别核心抽象及其交互方式，并将复杂的代码转化为带有清晰可视化内容的初学者友好教程。</p>
<h2 id="实践">实践</h2>
<p>创建一个python虚拟环境，安装包：</p>
<pre><code class="language-python">pip install -r requirements.txt
</code></pre>
<p>需要修改一下call_llm.py：</p>
<p>使用谷歌的模型可以这样写：</p>
<pre><code class="language-python">def call_llm(prompt, use_cache: bool = True):    
    client = genai.Client(
        api_key=os.getenv("GEMINI_API_KEY", "你的api key"),
    )
    model = os.getenv("GEMINI_MODEL", "gemini-2.5-pro-exp-03-25")
    response = client.models.generate_content(
        model=model,
        contents=[prompt]
    )
    response_text = response.text
    return response_text
</code></pre>
<p>使用兼容OpenAI格式的模型可以这样写：</p>
<pre><code class="language-python"># Use OpenAI o1
def call_llm(prompt, use_cache: bool = True):    
    from openai import OpenAI
    client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY", "你的api key"),
                     base_url="https://api.siliconflow.cn/v1")
     r = client.chat.completions.create(
         model="Qwen/QwQ-32B",
         messages=[{"role": "user", "content": prompt}],
        response_format={
             "type": "text"
         },
        reasoning_effort="medium",
         store=False
     )
     return r.choices[0].message.content
</code></pre>
<p>使用这个命令用于测试：</p>
<pre><code class="language-python">python utils/call_llm.py
</code></pre>
<p>参考README的使用方法：</p>
<pre><code class="language-python"># Analyze a GitHub repository
python main.py --repo https://github.com/username/repo --include "*.py" "*.js" --exclude "tests/*" --max-size 50000

# Or, analyze a local directory
python main.py --dir /path/to/your/codebase --include "*.py" --exclude "*test*"

# Or, generate a tutorial in Chinese
python main.py --repo https://github.com/username/repo --language "Chinese"
</code></pre>
<p>--repo 或 --dir - 指定 GitHub 仓库 URL 或本地目录路径（必需，互斥）<br>
-n, --name - 项目名称（可选，如果省略则从 URL/目录派生）<br>
-t, --token - GitHub 令牌（或设置 GITHUB_TOKEN 环境变量）<br>
-o, --output - 输出目录（默认：./output）<br>
-i, --include - 要包含的文件（例如，".py" ".js"）<br>
-e, --exclude - 要排除的文件（例如，"tests/" "docs/"）<br>
-s, --max-size - 文件最大大小（以字节为单位，默认：100KB）<br>
--language - 生成教程的语言（默认："english"）</p>
<p>正常运行如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/3288240/202504/3288240-20250423173332053-595694453.png" alt="image-20250423164613454" loading="lazy"></p>
<p>会开始分析章节然后开始写章节的内容。</p>
<p>以自己的一个教程仓库为例，我使用了不同的模型创建教程，把生成的教程我上传到GitHub了。</p>
<p>地址：<a href="https://github.com/Ming-jiayou/Avalonia_With_Dependency_Injection_Example/tree/main/Tutorials" target="_blank" rel="noopener nofollow">https://github.com/Ming-jiayou/Avalonia_With_Dependency_Injection_Example/tree/main/Tutorials</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3288240/202504/3288240-20250423173332081-1115063246.png" alt="image-20250423164851899" loading="lazy"></p>
<p>在我使用的模型中，我觉得效果最好的是gemini-2.5-pro-exp-03-25。</p>
<p>感兴趣的朋友可以自己看看对比一下。</p>
<p>我现在把gemini-2.5-pro-exp-03-25生成的贴出来看看。</p>
<h1 id="tutorial-avalonia_with_dependency_injection_example">Tutorial: Avalonia_With_Dependency_Injection_Example</h1>
<p>本项目 <strong>Avalonia_With_Dependency_Injection_Example</strong> 是一个使用 <em>Avalonia UI</em> 与 <em>依赖注入</em> 技术构建的示例应用。它展示了如何通过依赖注入管理应用的 <strong>组件和服务</strong>，并通过 <em>导航服务</em> 实现不同视图之间的切换。通过视图模型与视图的分离设计，项目实现了模块化开发，提高了代码的复用性和可维护性。</p>
<p><strong>Source Repository:</strong> <a href="https://github.com/Ming-jiayou/Avalonia_With_Dependency_Injection_Example" target="_blank" rel="noopener nofollow">https://github.com/Ming-jiayou/Avalonia_With_Dependency_Injection_Example</a></p>
<div class="mermaid">flowchart TD
    A0["主应用程序配置
"]
    A1["依赖注入
"]
    A2["导航服务
"]
    A3["视图模型基类
"]
    A4["视图定位器
"]
    A5["主窗口视图模型
"]
    A6["页面视图模型
"]
    A7["主窗口视图
"]
    A8["页面视图
"]
    A9["应用程序生命周期
"]
    A0 -- "初始化依赖注入" --&gt; A1
    A0 -- "管理生命周期" --&gt; A9
    A1 -- "注册视图模型" --&gt; A3
    A1 -- "注册视图定位器" --&gt; A4
    A1 -- "注册导航服务" --&gt; A2
    A2 -- "管理导航" --&gt; A5
    A5 -- "使用导航服务" --&gt; A2
    A5 -- "切换页面视图模型" --&gt; A6
    A4 -- "定位主窗口视图" --&gt; A7
    A4 -- "定位页面视图" --&gt; A8
    A7 -- "绑定视图模型" --&gt; A5
    A8 -- "绑定视图模型" --&gt; A6
    A6 -- "管理页面视图" --&gt; A8
    A3 -- "继承基类" --&gt; A6
    A3 -- "继承基类" --&gt; A5
</div><h1 id="chapter-1-主应用程序配置">Chapter 1: 主应用程序配置</h1>
<h2 id="欢迎初学者">欢迎初学者！</h2>
<p>欢迎来到我们的第一个章节！在这个章节中，我们将学习如何配置和启动Avalonia应用程序。如果你是第一次接触Avalonia或者依赖注入（Dependency Injection, DI），请不要担心，我们将通过具体的例子来一步步引导你。</p>
<h2 id="为什么要配置主应用程序">为什么要配置主应用程序？</h2>
<p>在开发任何应用程序时，首先需要做的一件事情就是配置和启动它。在Avalonia中，主应用程序配置类似于一家公司的前台，负责接待访客并引导他们进入正确的房间。在这个例子中，我们的“前台”会做一些必要的初始化工作，比如设置主窗口和初始化依赖注入。这样的配置能确保应用程序能够顺利启动，用户可以使用所有的功能。</p>
<h2 id="具体实现">具体实现</h2>
<h3 id="1-创建应用程序类">1. 创建应用程序类</h3>
<p>我们从创建应用程序类开始。在Avalonia中，应用程序类继承自<code>Application</code>，并重写一些方法来配置应用程序。我们来看一下<code>App.axaml.cs</code>文件中的代码：</p>
<pre><code class="language-csharp">using System.Linq;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using AvaloniaWithDependencyInjection.ViewModels;
using AvaloniaWithDependencyInjection.Views;
using Microsoft.Extensions.DependencyInjection;

namespace AvaloniaWithDependencyInjection
{
    public partial class App : Application
    {
        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);
        }

        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                DisableAvaloniaDataAnnotationValidation();

                var mainWindow = Program.ServiceProvider?.GetRequiredService&lt;MainWindow&gt;();
                var mainViewModel = Program.ServiceProvider?.GetRequiredService&lt;MainWindowViewModel&gt;();

                if (mainWindow != null &amp;&amp; mainViewModel != null)
                {
                    mainWindow.DataContext = mainViewModel;
                    desktop.MainWindow = mainWindow;
                }
            }

            base.OnFrameworkInitializationCompleted();
        }

        private void DisableAvaloniaDataAnnotationValidation()
        {
            var dataValidationPluginsToRemove =
                BindingPlugins.DataValidators.OfType&lt;DataAnnotationsValidationPlugin&gt;().ToArray();

            foreach (var plugin in dataValidationPluginsToRemove)
            {
                BindingPlugins.DataValidators.Remove(plugin);
            }
        }
    }
}
</code></pre>
<h3 id="代码解释">代码解释</h3>
<ol>
<li>
<p><strong>Initialize 方法</strong>:</p>
<ul>
<li><code>AvaloniaXamlLoader.Load(this);</code>：加载XAML资源，初始化用户界面。</li>
</ul>
</li>
<li>
<p><strong>OnFrameworkInitializationCompleted 方法</strong>:</p>
<ul>
<li><code>ApplicationLifetime</code>：检查应用程序是否在传统的桌面环境中运行。</li>
<li><code>DisableAvaloniaDataAnnotationValidation()</code>：禁用Avalonia的数据注释验证，避免与CommunityToolkit重复验证。</li>
<li><code>Program.ServiceProvider.GetRequiredService&lt;MainWindow&gt;()</code> 和 <code>Program.ServiceProvider.GetRequiredService&lt;MainWindowViewModel&gt;()</code>：从依赖注入服务中获取主窗口和主窗口视图模型。</li>
<li><code>mainWindow.DataContext = mainViewModel;</code>：将主窗口的 DataContext 设置为主窗口视图模型。</li>
<li><code>desktop.MainWindow = mainWindow;</code>：设置应用程序的主窗口。</li>
</ul>
</li>
<li>
<p><strong>DisableAvaloniaDataAnnotationValidation 方法</strong>:</p>
<ul>
<li>从数据验证插件中移除Avalonia的数据注释验证插件，避免重复验证。</li>
</ul>
</li>
</ol>
<h3 id="2-配置依赖注入">2. 配置依赖注入</h3>
<p>接下来，我们来看看如何配置依赖注入。在<code>Program.cs</code>文件中，我们会创建一个服务集合，并注册所需的依赖项：</p>
<pre><code class="language-csharp">using System;
using Avalonia;
using Microsoft.Extensions.DependencyInjection;

namespace AvaloniaWithDependencyInjection
{
    internal sealed class Program
    {
        public static IServiceProvider? ServiceProvider { get; private set; }

        [STAThread]
        public static void Main(string[] args)
        {
            var services = new ServiceCollection();
            
            services.AddViews()
                    .AddViewModels()
                    .AddServices();
            
            ServiceProvider = services.BuildServiceProvider();
            
            BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
        }

        public static AppBuilder BuildAvaloniaApp()
            =&gt; AppBuilder.Configure&lt;App&gt;()
                .UsePlatformDetect()
                .WithInterFont()
                .LogToTrace();
    }
}
</code></pre>
<h3 id="代码解释-1">代码解释</h3>
<ol>
<li>
<p><strong>Main 方法</strong>:</p>
<ul>
<li><code>var services = new ServiceCollection();</code>：创建一个服务集合。</li>
<li><code>services.AddViews().AddViewModels().AddServices();</code>：注册视图、视图模型和其他服务。</li>
<li><code>ServiceProvider = services.BuildServiceProvider();</code>：构建服务提供者。</li>
<li><code>BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);</code>：配置并启动Avalonia应用程序。</li>
</ul>
</li>
<li>
<p><strong>BuildAvaloniaApp 方法</strong>:</p>
<ul>
<li><code>AppBuilder.Configure&lt;App&gt;()</code>：配置应用程序。</li>
<li><code>UsePlatformDetect()</code>：自动检测平台。</li>
<li><code>WithInterFont()</code>：使用Inter字体。</li>
<li><code>LogToTrace()</code>：将日志记录到跟踪。</li>
</ul>
</li>
</ol>
<h3 id="内部实现">内部实现</h3>
<h4 id="步骤详解">步骤详解</h4>
<ol>
<li>
<p><strong>创建应用程序类</strong>:</p>
<ul>
<li>继承自<code>Application</code>。</li>
<li>重写<code>Initialize</code>方法，加载XAML资源。</li>
<li>重写<code>OnFrameworkInitializationCompleted</code>方法，配置主窗口和依赖注入。</li>
</ul>
</li>
<li>
<p><strong>配置依赖注入</strong>:</p>
<ul>
<li>创建服务集合。</li>
<li>注册所需的视图、视图模型和其他服务。</li>
<li>构建服务提供者。</li>
<li>启动Avalonia应用程序。</li>
</ul>
</li>
</ol>
<h4 id="序列图">序列图</h4>
<div class="mermaid">sequenceDiagram
    participant 程序入口
    participant 服务集合
    participant 服务提供者
    participant 应用程序
    participant 主窗口

    程序入口-&gt;&gt;服务集合: 创建服务集合
    程序入口-&gt;&gt;服务集合: 注册视图、视图模型和其他服务
    服务集合-&gt;&gt;服务提供者: 构建服务提供者
    程序入口-&gt;&gt;应用程序: 配置并启动应用程序
    应用程序-&gt;&gt;主窗口: 设置主窗口和视图模型
</div><h2 id="结论">结论</h2>
<p>通过本章，我们学习了如何配置和启动Avalonia应用程序。我们介绍了应用程序类的创建和依赖注入的配置。希望你现在已经能够理解这些基本概念，并能够自己动手配置一个简单Avalonia应用程序。</p>
<p>接下来，我们将深入学习依赖注入的更多内容。请继续阅读：<a href="02_%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5_.md" target="_blank" rel="noopener nofollow">依赖注入</a>。</p>
<h1 id="chapter-2-依赖注入">Chapter 2: 依赖注入</h1>
<h2 id="从上一章过渡">从上一章过渡</h2>
<p>在上一章 <a href="01_%E4%B8%BB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE_.md" target="_blank" rel="noopener nofollow">主应用程序配置</a> 中，我们学习了如何配置和启动一个Avalonia应用程序。我们介绍了应用程序类的创建和依赖注入的基本概念。在这一章中，我们将深入探讨依赖注入（Dependency Injection, 简称DI）这一重要的设计模式。通过理解依赖注入，你将能够更灵活地管理和使用应用程序中的各个组件。</p>
<h2 id="依赖注入的基本概念">依赖注入的基本概念</h2>
<h3 id="为什么使用依赖注入">为什么使用依赖注入？</h3>
<p>假设你正在开发一个应用程序，其中包含多个组件，例如视图（View）、视图模型（ViewModel）和服务（Service）。每个组件都可能需要依赖其他组件来完成特定的功能。例如，一个视图模型可能会依赖一个服务来获取数据。如果没有依赖注入，每个组件都需要自己创建或查找依赖，这样会导致代码耦合度高，难以测试和维护。</p>
<p>依赖注入通过将依赖关系从组件内部移到外部来解决这个问题。就像在一个团队中，领导分配任务，而不是每个成员自己找任务。这种方式使得组件更加独立和模块化，更容易测试和维护。</p>
<h3 id="依赖注入的关键概念">依赖注入的关键概念</h3>
<ol>
<li>
<p><strong>依赖（Dependency）</strong>：</p>
<ul>
<li>一个组件需要使用的其他组件。例如，视图模型可能需要一个服务来获取数据。</li>
</ul>
</li>
<li>
<p><strong>注入（Injection）</strong>：</p>
<ul>
<li>通过构造函数、属性或方法将依赖传递给组件的过程。这种方式使得组件不需要自己创建或查找依赖。</li>
</ul>
</li>
<li>
<p><strong>依赖注入容器（Dependency Injection Container）</strong>：</p>
<ul>
<li>管理和提供依赖的工具。在Avalonia中，我们使用 <code>Microsoft.Extensions.DependencyInjection</code> 来创建和管理依赖注入容器。</li>
</ul>
</li>
</ol>
<h2 id="如何使用依赖注入">如何使用依赖注入</h2>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>假设我们有一个视图模型 <code>MainWindowViewModel</code>，它需要使用一个服务 <code>DataService</code> 来获取数据。我们可以通过依赖注入来实现这一点。</p>
<h4 id="定义服务">定义服务</h4>
<p>首先，我们定义一个服务 <code>DataService</code>：</p>
<pre><code class="language-csharp">namespace AvaloniaWithDependencyInjection.Services
{
    public interface IDataService
    {
        string GetData();
    }

    public class DataService : IDataService
    {
        public string GetData()
        {
            return "Hello, World!";
        }
    }
}
</code></pre>
<h4 id="注册服务">注册服务</h4>
<p>接下来，我们需要在依赖注入容器中注册这个服务。我们已经在 <code>Program.cs</code> 文件中完成了这一部分：</p>
<pre><code class="language-csharp">public static AppBuilder BuildAvaloniaApp()
    =&gt; AppBuilder.Configure&lt;App&gt;()
        .UsePlatformDetect()
        .WithInterFont()
        .LogToTrace();

[STAThread]
public static void Main(string[] args)
{
    var services = new ServiceCollection();

    services.AddViews()
            .AddViewModels()
            .AddServices();

    ServiceProvider = services.BuildServiceProvider();

    BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
}
</code></pre>
<p>在 <code>ServiceCollectionExtensions.cs</code> 文件中，我们注册了所有的视图、视图模型和服务：</p>
<pre><code class="language-csharp">public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddViews(this IServiceCollection services)
    {
        services.AddSingleton&lt;MainWindow&gt;();
        services.AddSingleton&lt;Page1View&gt;();
        services.AddSingleton&lt;Page2View&gt;();

        return services;
    }

    public static IServiceCollection AddViewModels(this IServiceCollection services)
    {
        services.AddSingleton&lt;MainWindowViewModel&gt;();
        services.AddSingleton&lt;Page1ViewModel&gt;();
        services.AddSingleton&lt;Page2ViewModel&gt;();

        return services;
    }

    public static IServiceCollection AddServices(this IServiceCollection services)
    {
        services.AddSingleton&lt;IDataService, DataService&gt;();

        return services;
    }
}
</code></pre>
<h4 id="注入依赖">注入依赖</h4>
<p>现在，我们可以在 <code>MainWindowViewModel</code> 中注入 <code>DataService</code>：</p>
<pre><code class="language-csharp">namespace AvaloniaWithDependencyInjection.ViewModels
{
    public class MainWindowViewModel
    {
        private readonly IDataService _dataService;

        public string Data { get; private set; }

        public MainWindowViewModel(IDataService dataService)
        {
            _dataService = dataService;
            Data = _dataService.GetData();
        }
    }
}
</code></pre>
<h3 id="代码解释-2">代码解释</h3>
<ol>
<li>
<p><strong>定义服务</strong>：</p>
<ul>
<li><code>DataService</code> 实现了 <code>IDataService</code> 接口，并提供了 <code>GetData</code> 方法。</li>
</ul>
</li>
<li>
<p><strong>注册服务</strong>：</p>
<ul>
<li>在 <code>ServiceCollectionExtensions</code> 中，我们通过 <code>AddServices</code> 方法注册了 <code>DataService</code>。</li>
</ul>
</li>
<li>
<p><strong>注入依赖</strong>：</p>
<ul>
<li>在 <code>MainWindowViewModel</code> 中，我们通过构造函数注入了 <code>IDataService</code>，并在构造函数中调用了 <code>GetData</code> 方法。</li>
</ul>
</li>
</ol>
<h3 id="运行结果">运行结果</h3>
<p>当应用程序启动时，依赖注入容器会自动创建 <code>DataService</code> 实例，并将其传递给 <code>MainWindowViewModel</code> 的构造函数。<code>MainWindowViewModel</code> 会调用 <code>GetData</code> 方法，并将返回的数据赋值给 <code>Data</code> 属性。最终，<code>Data</code> 属性的值会显示在主窗口中。</p>
<h2 id="内部实现-1">内部实现</h2>
<h3 id="依赖注入容器的工作原理">依赖注入容器的工作原理</h3>
<ol>
<li>
<p><strong>创建服务集合</strong>：</p>
<ul>
<li>在 <code>Program.cs</code> 中，我们创建了一个 <code>ServiceCollection</code> 实例。</li>
</ul>
</li>
<li>
<p><strong>注册依赖</strong>：</p>
<ul>
<li>通过 <code>AddViews</code>、<code>AddViewModels</code> 和 <code>AddServices</code> 方法，我们注册了所有的视图、视图模型和服务。</li>
</ul>
</li>
<li>
<p><strong>构建服务提供者</strong>：</p>
<ul>
<li>使用 <code>services.BuildServiceProvider()</code> 方法，我们构建了一个 <code>IServiceProvider</code> 实例。</li>
</ul>
</li>
<li>
<p><strong>获取服务</strong>：</p>
<ul>
<li>在 <code>App.axaml.cs</code> 文件中，我们通过 <code>Program.ServiceProvider.GetRequiredService&lt;MainWindow&gt;()</code> 和 <code>Program.ServiceProvider.GetRequiredService&lt;MainWindowViewModel&gt;()</code> 方法从服务提供者中获取主窗口和主窗口视图模型。</li>
</ul>
</li>
</ol>
<h3 id="序列图-1">序列图</h3>
<p><img src="https://img2024.cnblogs.com/blog/3288240/202504/3288240-20250423173332034-1391176389.png" alt="image-20250423171232102" loading="lazy"></p>
<h2 id="结论-1">结论</h2>
<p>通过本章，我们深入探讨了依赖注入的基本概念和使用方法。我们学习了如何通过依赖注入来管理和使用应用程序中的各个组件，使得代码更加模块化和易于测试。希望你现在能够理解依赖注入的重要性和使用方法。</p>
<p>接下来，我们将学习 <a href="03_%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_.md" target="_blank" rel="noopener nofollow">应用程序生命周期</a> 的相关内容。请继续阅读，了解应用程序的各个生命周期阶段。</p>
<h2 id="最后">最后</h2>
<p>多的就不放了，感兴趣的朋友可以去GitHub上看完整的，让我惊讶的地方是感觉gemini-2.5-pro-exp-03-25的图画的很不错，在教程中多放点这种图，会让读者更加清晰易懂。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4470680791342593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-23 17:34">2025-04-23 17:33</span>&nbsp;
<a href="https://www.cnblogs.com/mingupupu">mingupupup</a>&nbsp;
阅读(<span id="post_view_count">174</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18843138);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18843138', targetLink: 'https://www.cnblogs.com/mingupupu/p/18843138', title: '使用这个工具，基于代码仓库直接生成教程文档，感觉比我自己写的还好' })">举报</a>
</div>
        