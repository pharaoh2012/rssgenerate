<!----> <meta itemprop="headline" content="迈向前端 Leader - 落地前端监控"> <meta itemprop="keywords" content="前端,监控,性能优化"> <meta itemprop="datePublished" content="2025-03-19T01:03:07.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风骨"> <meta itemprop="url" content="https://juejin.cn/user/1714893871914381"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            迈向前端 Leader - 落地前端监控
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893871914381/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风骨
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-03-19T01:03:07.000Z" title="Wed Mar 19 2025 01:03:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-03-19
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    6,207
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>大家好，我是风骨，在前端领域能让我们深入探究的方向有很多，比如今天的主题：<strong>前端监控</strong>。</p>
<p>在大型项目中，<strong>前端监控</strong> 是不可或缺的一部分。它的优势可以体现在以下场景：</p>
<ol>
<li><strong>稳定性</strong>：尽早发现程序运行错误并及时修复；</li>
<li><strong>用户体验</strong>：性能监控分析，持续优化改善网站使用体验；</li>
<li><strong>业务扩展</strong>：常见的数据埋点，如统计 PV 页面浏览量。</li>
</ol>
<p>其中 <strong>稳定性</strong> 和 <strong>用户体验</strong> 是我们完成前端基建必不可少的组成部分。</p>
<p>而要实现一套完整的前端监控，需要经历以下过程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1edb3d6e6af4595a91bdce20d71272a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=mC1TVvyCFQp%2FjVjbq8dx69ddl7k%3D" alt="image.png" loading="lazy"></p>
<p>其中：</p>
<ul>
<li><code>SDK</code>，负责处理客户端（浏览器）程序在运行期间的监控日志收集和上报；</li>
<li><code>日志服务器</code>，负责接收 <code>SDK</code> 上报的 <code>Log</code> 日志，进行清洗过滤存入数据库；</li>
<li><code>可视化平台</code>，则是以可视化形式，直观展示上报过来的数据。</li>
</ul>
<p>在这里，<code>日志服务器</code> 可以使用 Node.js 技术栈实现 server 端逻辑，<code>可视化平台</code> 可以基于统计数据实现报表展示。</p>
<p>下面，我们重点从 0 到 1 一步步来构建一个 Web 监控 SDK。文章大纲如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/773955507fb0403587cfd4b2c4370718~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=rN4utE%2FfSUE8fNRL5dezBexggu0%3D" alt="image.png" loading="lazy"></p>
<p>PS：监控 SDK 代码仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FL-excellence%2Fmonitor-sdk" target="_blank" title="https://github.com/L-excellence/monitor-sdk" ref="nofollow noopener noreferrer">github.com/L-excellenc…</a> ，欢迎点个 <code>star</code>。</p>
<h2 data-id="heading-0">一、设计 SDK</h2>
<p>SDK 承担了<strong>前端监控和数据上报</strong>的工作，通常我们会以 <code>&lt;script&gt; js</code> 脚本文件的形式接入到业务项目中。</p>
<p>下面，首要工作是建立一个 SDK 项目仓库，利用打包工具（如 <code>Rollup</code>）构建出 JS 脚本文件。</p>
<h3 data-id="heading-1">1、搭建 Rollup 构建环境</h3>
<p>构建工具我们选用 <code>Rollup</code>，它非常适合构建一些工具库、组件库。我们初始化一个 <code>monitor-sdk</code> 目录，并完成 Rollup 打包配置。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> monitor-sdk
<span class="hljs-built_in">cd</span> monitor-sdk
npm init -y
npm install rollup rollup-plugin-terser @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-babel typescript @babel/preset-typescript @babel/preset-env @babel/core @babel/cli -D
tsc --init
<span class="hljs-built_in">touch</span> index.ts
<span class="hljs-built_in">touch</span> rollup.config.js
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// rollup.config.js</span>
<span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">"@rollup/plugin-node-resolve"</span>;
<span class="hljs-keyword">import</span> commonjs <span class="hljs-keyword">from</span> <span class="hljs-string">"@rollup/plugin-commonjs"</span>;
<span class="hljs-keyword">import</span> { babel } <span class="hljs-keyword">from</span> <span class="hljs-string">"@rollup/plugin-babel"</span>;
<span class="hljs-keyword">import</span> { terser } <span class="hljs-keyword">from</span> <span class="hljs-string">"rollup-plugin-terser"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-keyword">const</span> extensions = [<span class="hljs-string">".ts"</span>, <span class="hljs-string">".tsx"</span>, <span class="hljs-string">".js"</span>, <span class="hljs-string">".jsx"</span>];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; ({
  <span class="hljs-attr">input</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"index.ts"</span>),
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">file</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"dist/myMonitor.js"</span>),
    <span class="hljs-attr">format</span>: <span class="hljs-string">"umd"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"myMonitor"</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">resolve</span>({
      extensions, <span class="hljs-comment">// 指定 import 模块后缀解析规则</span>
    }),
    <span class="hljs-title function_">commonjs</span>(),
    <span class="hljs-title function_">babel</span>({
      extensions,
      <span class="hljs-attr">presets</span>: [
        <span class="hljs-string">"@babel/preset-env"</span>,
        [
          <span class="hljs-string">"@babel/preset-typescript"</span>,
          {
            <span class="hljs-attr">isTSX</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">allExtensions</span>: <span class="hljs-literal">true</span>,
          },
        ],
      ],
      <span class="hljs-attr">babelHelpers</span>: <span class="hljs-string">"bundled"</span>,
    }),
    <span class="hljs-title function_">terser</span>(),
  ],
});
</code></pre>
<p>最后，我们在 <code>package.json</code> 中加入 <code>build</code> 命令，运行 <code>npm run build</code> 完成 dist/myMonitor.js 构建。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rollup -c rollup.config.js -w"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>PS：另外我们可以配置 ESLint、Prettier 等前端规范工具，由于非本文中心主题，跳过详细描述。</p>
<h3 data-id="heading-2">2、异常监控</h3>
<p>在前端，程序发生异常的种类有很多，比如：<strong>JS 代码执行错误、Promise 未被处理的错误、React/Vue 组件 render 错误、静态资源加载错误、请求 API 出错等。</strong></p>
<p>以上这些异常场景，都需要我们进行监控并上报到服务器。</p>
<h4 data-id="heading-3">2.1、JS 代码执行错误</h4>
<p>首先，我们模拟一个代码错误：<code>访问一个未定义的对象的属性</code>。</p>
<pre><code class="hljs language-html" lang="html">// examples/jsError.html
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"点击抛出错误"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"errorClick()"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">errorClick</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">// 模拟代码错误：访问一个未定义的对象的属性</span>
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">someVal</span>.<span class="hljs-property">error</span> = <span class="hljs-string">"error"</span>;
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>当点击按钮后，会发生报错：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5864132b369b4f4dad81cac108e4cf6d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=5UIwZ0iT%2BIticBilKhvgOd3yFKU%3D" alt="image.png" loading="lazy"></p>
<p>在 JS 中未被 try/catch 捕获的代码错误，可以通过 <code>window.addEventListener('error')</code> 全局监听到。</p>
<p>在监控到错误以后，我们需要对错误进行 <strong>数据建模</strong>，拿到能够描述和定位此错误的有用信息。</p>
<p>异常日志数据建模可以遵循以下类型结构：<code>ErrorLog</code></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// interface/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ErrorLog</span> {
  <span class="hljs-comment">// type 监控类型：error（代码错误）</span>
  <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>;
  <span class="hljs-comment">// 错误类型：jsError（JS 代码错误）</span>
  <span class="hljs-attr">errorType</span>: <span class="hljs-string">"jsError"</span> | ...;
  <span class="hljs-comment">// 错误信息</span>
  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 错误发生的文件</span>
  <span class="hljs-attr">filename</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 错误发生的行列信息</span>
  <span class="hljs-attr">position</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 错误堆栈信息</span>
  <span class="hljs-attr">stack</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// 错误发生在 DOM 到顶层元素的链路信息（使用选择器表示，如：body div#container input）</span>
  selector?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>有了上面的铺垫，我们来实现 JS 代码执行错误的监控。</p>
<p>新建 <code>module/jsError.ts</code> 文件，注册 <code>window.addEventListener('error')</code> 监听错误，并对错误信息进行数据建模，得到可以用于上报的 <code>log</code> 数据。</p>
<blockquote>
<p>PS：注意是在错误事件传播的 <strong><code>捕获阶段</code></strong> 处理错误，避免错误在冒泡过程中可能被其他代码干扰或覆盖。</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// index.ts</span>
<span class="hljs-keyword">import</span> injectJSError <span class="hljs-keyword">from</span> <span class="hljs-string">"./modules/jsError"</span>;
<span class="hljs-title function_">injectJSError</span>();

<span class="hljs-comment">// modules/jsError.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ErrorLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;
<span class="hljs-keyword">import</span> { formatStack } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;
<span class="hljs-keyword">import</span> getLastEvent <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/getLastEvent"</span>;
<span class="hljs-keyword">import</span> getSelector <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/getSelector"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectJSError</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 1、监听全局未被 try/catch 捕获的错误</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(
    <span class="hljs-string">"error"</span>,
    <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"js error event: "</span>, event);
      <span class="hljs-keyword">const</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>(); <span class="hljs-comment">// 监听到错误后，获取到最后一个交互事件</span>

      <span class="hljs-comment">// 1.1、数据建模存储</span>
      <span class="hljs-keyword">const</span> <span class="hljs-attr">errorLog</span>: <span class="hljs-title class_">ErrorLog</span> = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
        <span class="hljs-attr">errorType</span>: <span class="hljs-string">"jsError"</span>,
        <span class="hljs-attr">message</span>: event.<span class="hljs-property">message</span>,
        <span class="hljs-attr">filename</span>: event.<span class="hljs-property">filename</span>,
        <span class="hljs-attr">position</span>: <span class="hljs-string">`<span class="hljs-subst">${event.lineno}</span>:<span class="hljs-subst">${event.colno}</span>`</span>,
        <span class="hljs-attr">stack</span>: <span class="hljs-title function_">formatStack</span>(event.<span class="hljs-property">error</span>.<span class="hljs-property">stack</span>),
        <span class="hljs-attr">selector</span>: lastEvent ? <span class="hljs-title function_">getSelector</span>() : <span class="hljs-string">""</span>,
      };
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"js error log: "</span>, errorLog);

      <span class="hljs-comment">// 1.2、上报数据（TODO...）</span>
    },
    <span class="hljs-comment">// !!! 使用事件捕获进行监听</span>
    <span class="hljs-literal">true</span>
  );
}
</code></pre>
<p>其中 <code>errorType</code> 标识是一个 JS 代码错误，<code>message</code>、<code>filename</code>、<code>position</code> 信息都可以从 <code>event</code> 错误事件对象上获取。</p>
<p>这里重点介绍一下 <code>stack</code> 和 <code>selector</code> 的信息来源。</p>
<ol>
<li><code>stack</code> 统计函数调用错误栈信息：</li>
</ol>
<p>首先，访问 <code>event.error.stack</code> 得到的是发生错误的执行调用栈信息（<code>String</code>）：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/691bdc915e1d48808a2b7a72ce75ad2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=FFnH9GkhBygeQWZKBe2amLP5E5w%3D" alt="image.png" loading="lazy"></p>
<p>我们调用 <code>formatStack()</code> 稍做加工一下，得到一个更直观的调用栈的信息，加工后展示如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44912e30957f474caf17887682ca1f6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=dKLwzT7X7WR3H9FawFw58r7hm20%3D" alt="image.png" loading="lazy"></p>
<p><code>formatStack</code> 的实现：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// utils/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatStack</span>(<span class="hljs-params">stack: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">return</span> stack
    .<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>)
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+at\s+/g</span>, <span class="hljs-string">""</span>))
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>);
}
</code></pre>
<hr>
<ol start="2">
<li><code>selector</code> 统计 DOM 节点层级树信息：</li>
</ol>
<p><code>getLastEvent()</code> 函数用来返回最近一个交互事件，当错误发生来自于用户与页面交互时（如 <code>onclick</code>），<code>lastEvent</code> 将是该事件的 <code>event</code> 对象。记录<code>lastEvent</code> 可以在全局绑定相关交互事件：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">lastEvent</span>: <span class="hljs-title class_">Event</span> | <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">lastEventPath</span>: <span class="hljs-built_in">any</span>[];

[<span class="hljs-string">"click"</span>, <span class="hljs-string">"touchstart"</span>, <span class="hljs-string">"mousedown"</span>, <span class="hljs-string">"keydown"</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> {
  <span class="hljs-comment">// 埋点方式：无痕埋点 -&gt; 全部埋点</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(
    eventType,
    <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      lastEvent = event;
      <span class="hljs-comment">// 新版浏览器中 event.path 已被废弃，改用 event.composedPath()</span>
      lastEventPath = event.<span class="hljs-property">path</span> || event.<span class="hljs-title function_">composedPath</span>();
    },
    {
      <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 以捕获形式监听（因为默认元素的事件都是冒泡形式，如果出现阻止默认事件，在这里将监听不到）</span>
      <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>,
    },
  );
});

<span class="hljs-comment">// 获取最近一次的事件调用栈</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLastEventPath</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> lastEventPath;
}

<span class="hljs-comment">// 获取最近一次的事件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLastEvent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> lastEvent;
}
</code></pre>
<p>当错误发生时，事件对象 <code>event.composedPath()</code> 可以拿到 DOM 树层级信息：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a4f9f17a34f423c822442d4fb6408e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=3hBCnBT0HaAJu6Ql79b5msebHlk%3D" alt="image.png" loading="lazy"></p>
<p>最后，<code>getSelector()</code> 方法对则是对 DOM 树层级进行进行加工，得到一个包含 DOM 选择器的层级字符串。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cab08aab9a334e86acdaa3172108e8e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=BLOr65b1U6XmSnpc5tfa3LlNlLY%3D" alt="image.png" loading="lazy"></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// getSelector.ts 获取当前事件链路上的元素选择器</span>
<span class="hljs-keyword">import</span> { getLastEventPath } <span class="hljs-keyword">from</span> <span class="hljs-string">"./getLastEvent"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelectorByPath</span>(<span class="hljs-params">path: <span class="hljs-built_in">any</span>[]</span>) {
  <span class="hljs-keyword">return</span> path
    .<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 翻转 Path 中的元素</span>
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
      <span class="hljs-comment">// 过滤掉 window、document 和 html</span>
      <span class="hljs-keyword">return</span> element !== <span class="hljs-variable language_">window</span> &amp;&amp; element !== <span class="hljs-variable language_">document</span> &amp;&amp; element !== <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;
    })
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (element.<span class="hljs-property">id</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${element.nodeName.toLowerCase()}</span>#<span class="hljs-subst">${element.id}</span>`</span>; <span class="hljs-comment">// 返回 标签名#id</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">className</span> &amp;&amp; <span class="hljs-keyword">typeof</span> element.<span class="hljs-property">className</span> === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${element.nodeName.toLowerCase()}</span>#<span class="hljs-subst">${element.className}</span>`</span>; <span class="hljs-comment">// 返回 标签名.class</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> element.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// 返回 标签名</span>
      }
    })
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">" "</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelector</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> path = <span class="hljs-title function_">getLastEventPath</span>();
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(path)) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getSelectorByPath</span>(path);
  }
}
</code></pre>
<p>现在，在上述示例中引入 <code>monitor sdk js</code>，点击按钮模拟 JS 执行错误，就可以监控到 <code>errorLog</code> 日志：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6d54b27577d444da6842838cc232be5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=jPC%2Fgfqlf0PPsaPp%2BytxVBeYAqo%3D" alt="image.png" loading="lazy"></p>
<p>有了错误日志，接下来便是考虑数据上报。</p>
<h4 data-id="heading-4">2.2、数据上报方式</h4>
<p>在前端，可供数据上报至服务器的方式有三种：</p>
<ol>
<li><code>ajax</code> 传统与服务端通信请求；</li>
<li><code>img GIF</code> 图片 GET 请求方式上报，优点：速度快，没有跨域问题；</li>
<li><code>navigator.sendBeacon()</code> 方法通过 HTTP 将少量数据异步传输到 Web 服务器。</li>
</ol>
<p><code>ajax</code> 方式我们再熟悉不过了，不论是 <code>xhr</code> 对象还是 <code>fetch</code> 函数，都可以将数据传递到服务器。</p>
<p><code>navigator.sendBeacon()</code> 也是一种不错的方式，它的最大优势在于 <strong>异步</strong>，确保数据在页面卸载过程中仍然能够被发送，而不会被中断。</p>
<blockquote>
<p>PS: 有关 <code>navigator.sendBeacon()</code> 的使用可以查阅文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FNavigator%2FsendBeacon" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></p>
</blockquote>
<p>重点介绍一下 <code>img GIF</code> 的上报方式。</p>
<p>简单来说，我们可以<strong>在服务器上放置一个非常小的 gif 图片（1kb），将日志数据作为图片 <code>url queryString</code> 参数，访问这个图片来达成数据上报至服务器</strong>。</p>
<p>下面来看看具体实现。</p>
<p>首先，创建一个 <code>Tracker 类</code>，并提供一个 <code>send</code> 方法，通过 <code>img</code> 标签访问服务器上的图片来完成日志数据的上传。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// utils/tracker.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MonitorLog</span>, <span class="hljs-title class_">MonitorTypeLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;
<span class="hljs-keyword">import</span> getLogBaseData <span class="hljs-keyword">from</span> <span class="hljs-string">"./getLogBaseData"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tracker</span> {
  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 上报日志服务器地址（服务器上的 gif 图片）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = <span class="hljs-string">"http://localhost:8080/send/monitor.gif"</span>;
  }

  <span class="hljs-title function_">send</span>(<span class="hljs-params">data: MonitorTypeLog</span>) {
    <span class="hljs-comment">// 获取基础日志数据</span>
    <span class="hljs-keyword">const</span> baseData = <span class="hljs-title function_">getLogBaseData</span>();
    <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">MonitorLog</span> = {
      <span class="hljs-attr">baseLog</span>: baseData,
      ...data,
    };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"send log"</span>, log);

    <span class="hljs-comment">// 进行数据上报</span>
    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title class_">Image</span>();
    img.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.url}</span>?data=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-built_in">JSON</span>.stringify(log))}</span>`</span>;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tracker</span>();
</code></pre>
<p>这里 <code>baseData</code> 表示日志上报可以携带一些设备的基础信息，比如浏览器型号、版本等。此外，你还可以加入一些业务信息如 用户身份 进行上报。</p>
<p>设备信息来自于 <code>navigator.userAgent</code>，可以使用 <code>ua-parser-js</code> 三方库来完成设备参数解析。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// utils/getLogBaseData.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UAParser</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"ua-parser-js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BaseLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;

<span class="hljs-comment">// 获取设备信息</span>
<span class="hljs-keyword">const</span> { browser, device, os } = <span class="hljs-title class_">UAParser</span>(navigator.<span class="hljs-property">userAgent</span>);

<span class="hljs-comment">/**
 * getLogBaseData 获取日志基本信息
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLogBaseData</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">BaseLog</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>,
    <span class="hljs-attr">url</span>: location.<span class="hljs-property">href</span>,
    <span class="hljs-attr">userAgent</span>: navigator.<span class="hljs-property">userAgent</span>,
    <span class="hljs-attr">browser</span>: <span class="hljs-string">`<span class="hljs-subst">${browser.name}</span> <span class="hljs-subst">${browser.version}</span>`</span>,
    <span class="hljs-attr">device</span>: <span class="hljs-string">`<span class="hljs-subst">${device.model}</span> <span class="hljs-subst">${device.vendor}</span>`</span>,
    <span class="hljs-attr">os</span>: <span class="hljs-string">`<span class="hljs-subst">${os.name}</span> <span class="hljs-subst">${os.version}</span>`</span>,
  };
}
</code></pre>
<p>最后，在监控到报错时，调用 <code>tracker.send() </code>将错误日志上报到服务器。</p>
<pre><code class="hljs language-diff" lang="diff">// jsError.ts
export default function injectJSError() {
  // 1、监听全局未被 try/catch 捕获的错误
  window.addEventListener(
    "error",
    event =&gt; {
      const lastEvent = getLastEvent(); // 监听到错误后，获取到最后一个交互事件

      // 1.1、数据建模存储
      const errorLog: ErrorLog = {...}

<span class="hljs-addition">+     // 1.2、上报数据</span>
<span class="hljs-addition">+     tracker.send(errorLog);</span>
    },
    // !!! 使用捕获
    true,
  );
}
</code></pre>
<p>接下来，就是在服务端的处理，通过处理图片请求，拿到请求上的 <code>queryString</code> 参数，进行数据清洗和入口，在本文不多做阐述。</p>
<h4 data-id="heading-5">2.3、Promise 未处理的错误</h4>
<p>Promise 错误一般是指：在 <code>Promise execute、then</code> 方法中代码执行出错，或 <code>Promise execute reject()</code> 变成失败态，且没有被 <code>.catch</code> 函数进行捕获处理。</p>
<p>如下，是 Promise 抛出错误的代码示例：</p>
<pre><code class="hljs language-html" lang="html">// examples/promiseError.html
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"点击抛出 Promise 错误"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"promiseErrorClick()"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseErrorClick</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-comment">// 抛出错误方式 1：</span>
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">someVal</span>.<span class="hljs-property">error</span> = <span class="hljs-string">"error"</span>;
        <span class="hljs-comment">// 抛出错误方式 2：</span>
        <span class="hljs-title function_">reject</span>(<span class="hljs-string">"错误原因：模拟一个 Promise 错误。"</span>);
      });
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>然而，Promise 未处理的错误不会被 <code>window.addEventListener('error')</code> 所监听，需要使用另一个监听事件 <code>unhandledrejection</code> 来完成。</p>
<p>同时，<code>unhandledrejection</code> 的事件对象 <code>event.reason</code> 在这两个错误场景下表现有所不同：</p>
<ol>
<li><strong>代码执行错误</strong>：<code>event.reason</code> 是一个对象，<code>reason.stack</code> 包含调用栈信息，可以从中拿到错误文件、行和列等信息；</li>
<li><strong>reject() 变更 Promise 为失败状态</strong>：<code>event.reason</code> 是一个字符串，值为传递给 <code>reason()</code> 函数的失败原因参数。</li>
</ol>
<p>因此，在数据建模时，需要依据 <code>event.reason</code> 进行区分：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// modules/jsError.ts</span>
...

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectJSError</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 1、监听全局未被 try/catch 捕获的错误</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"error"</span>, ...);
  
  <span class="hljs-comment">// 2、监听未被捕获的 Promise 错误</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(
    <span class="hljs-string">"unhandledrejection"</span>,
    <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Promise error event: "</span>, event);
      <span class="hljs-keyword">const</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>(); <span class="hljs-comment">// 监听到错误后，获取到最后一个交互事件</span>

      <span class="hljs-keyword">let</span> message;
      <span class="hljs-keyword">const</span> reason = event.<span class="hljs-property">reason</span>; <span class="hljs-comment">// Promise 失败的原因</span>
      <span class="hljs-keyword">let</span> filename;
      <span class="hljs-keyword">let</span> line = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">let</span> column = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">let</span> stack = <span class="hljs-string">""</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">reason</span> === <span class="hljs-string">"string"</span>) {
        <span class="hljs-comment">// 情况 1、是 Promise reject 抛出的错误（没有办法获取 stack 等信息）</span>
        message = reason;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reason === <span class="hljs-string">"object"</span>) {
        <span class="hljs-comment">// 情况 2、是 Promise 中 JS 代码执行出错</span>
        message = reason.<span class="hljs-property">message</span>;
        <span class="hljs-keyword">if</span> (reason.<span class="hljs-property">stack</span>) {
          <span class="hljs-comment">// 从错误信息中匹配到关键信息。stack 示例：at http://localhost:8080/examples/promiseError.html:29:32</span>
          <span class="hljs-keyword">const</span> matchResult = reason.<span class="hljs-property">stack</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/at\s+(.+):(\d+):(\d+)/</span>);
          filename = matchResult[<span class="hljs-number">1</span>];
          line = matchResult[<span class="hljs-number">2</span>];
          column = matchResult[<span class="hljs-number">3</span>];
          stack = <span class="hljs-title function_">formatStack</span>(reason.<span class="hljs-property">stack</span>);
        }
      }

      <span class="hljs-comment">// 2.1、数据建模存储</span>
      <span class="hljs-keyword">const</span> <span class="hljs-attr">errorLog</span>: <span class="hljs-title class_">ErrorLog</span> = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
        <span class="hljs-attr">errorType</span>: <span class="hljs-string">"promiseError"</span>, <span class="hljs-comment">// 错误类型 - Promise 代码错误</span>
        message,
        filename,
        <span class="hljs-attr">position</span>: <span class="hljs-string">`<span class="hljs-subst">${line}</span>:<span class="hljs-subst">${column}</span>`</span>,
        stack,
        <span class="hljs-attr">selector</span>: lastEvent ? <span class="hljs-title function_">getSelector</span>() : <span class="hljs-string">""</span>,
      };

      <span class="hljs-comment">// 2.2、上报数据</span>
      tracker.<span class="hljs-title function_">send</span>(errorLog);
    },
    <span class="hljs-literal">true</span>,
  );
}
</code></pre>
<p>对于 <code>Promise 中的代码执行错误</code>，收集到的错误日志信息和「JS 代码执行错误」基本一致：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0aa3184ce9524e029d498795ff5a78a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=IyhVE3hqzTPu2RMqNasjg4MsvsY%3D" alt="image.png" loading="lazy"></p>
<p>而对于 <code>Promise reject 变更为失败态</code>，收集到的错误日志信息如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b4c975dfcde433faf75afc216fedee7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=QvE8RMR3L42oNYO%2FuYgG%2Fi4R0QA%3D" alt="image.png" loading="lazy"></p>
<h4 data-id="heading-6">2.4、资源加载错误</h4>
<p>资源一般是指 <code>JS、CSS、图片</code>，当访问这些资源出错或 404 找不到时，我们可以监控进行上报。</p>
<p>如下，我们随意访问一个不存在的资源 <code>/someError.js</code>，模拟资源加载 404。</p>
<pre><code class="hljs language-html" lang="html">// examples/loadResourceError.html
<span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>资源加载出错.<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../dist/myMonitor.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;img src="/someError.png" /&gt; --&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;link rel="stylesheet" href="/someError.css" /&gt; --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/someError.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>加载资源需要使用特定的 HTML 标签元素（<code>script、link、img</code>），比如加载 JS 文件需要使用 <code>script</code> 标签。</p>
<p>除了通过 <code>标签 onerror</code> 事件监听错误外，还可以通过 <code>window.addEventListener('error')</code> 在全局统一监听资源加载错误。</p>
<p>我们在 <code>jsError.ts</code> 中的 <code>error</code> 事件监听处理函数中，加入监控资源加载出错逻辑。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// modules/jsError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectJSError</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(
    <span class="hljs-string">"error"</span>,
    <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      <span class="hljs-comment">// 监听 JS/CSS 资源文件加载错误</span>
      <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLScriptElement</span> | <span class="hljs-title class_">HTMLImageElement</span> | <span class="hljs-title class_">HTMLLinkElement</span> | <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">let</span> filename;
      <span class="hljs-keyword">if</span> (target &amp;&amp; (filename = (target <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLScriptElement</span> | <span class="hljs-title class_">HTMLImageElement</span>).<span class="hljs-property">src</span> || (target <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLLinkElement</span>).<span class="hljs-property">href</span>)) {
        <span class="hljs-comment">// 1、数据建模存储</span>
        <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">ErrorLog</span> = {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
          <span class="hljs-attr">errorType</span>: <span class="hljs-string">"loadResourceError"</span>, <span class="hljs-comment">// 错误类型 - JS/CSS 资源加载错误</span>
          <span class="hljs-attr">message</span>: <span class="hljs-string">`<span class="hljs-subst">${filename}</span> resource loading fail.`</span>,
          filename, <span class="hljs-comment">// 报错的文件</span>
          <span class="hljs-attr">tagName</span>: target.<span class="hljs-property">tagName</span>, <span class="hljs-comment">// 资源标签名称</span>
          <span class="hljs-attr">selector</span>: <span class="hljs-title function_">getSelector</span>(event.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>), <span class="hljs-comment">// body script</span>
        };
        <span class="hljs-comment">// 2、上报数据</span>
        tracker.<span class="hljs-title function_">send</span>(log);
      }
      
      <span class="hljs-comment">// 监听 JS 代码执行出错</span>
      <span class="hljs-keyword">else</span> { ... }
    },
    <span class="hljs-literal">true</span>,
  );
}
</code></pre>
<p>对于 <code>script 和 img</code> 元素，可通过 <code>src</code> 属性来识别，而 <code>link</code> 则可以用 <code>href</code> 属性来识别。</p>
<p>最后在数据建模获取 <code>selector</code> 时，传递 <code>target</code> 元素来获取节点树上的层级信息。</p>
<pre><code class="hljs language-diff" lang="diff">export default function getSelector(ele?: HTMLElement) {
  const path = getLastEventPath();
  if (Array.isArray(path)) {
    return getSelectorByPath(path);
<span class="hljs-addition">+ } else if (ele) {</span>
<span class="hljs-addition">+   return getSelectorByEle(ele);</span>
<span class="hljs-addition">+ }</span>
}

<span class="hljs-addition">+ function getSelectorByEle(ele: HTMLElement) {</span>
<span class="hljs-addition">+   let node: HTMLElement | null = ele;</span>
<span class="hljs-addition">+   const path: string[] = [];</span>
<span class="hljs-addition">+   while (node &amp;&amp; filterTopLevelNode(node)) {</span>
<span class="hljs-addition">+     path.unshift(getEleSelector(node));</span>
<span class="hljs-addition">+     node = node.parentElement;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return path.join(" ");</span>
<span class="hljs-addition">+ }</span>

<span class="hljs-addition">+ function filterTopLevelNode(element: Window | Document | HTMLElement) {</span>
<span class="hljs-addition">+   // 过滤掉 window、document 和 html</span>
<span class="hljs-addition">+   return element !== window &amp;&amp; element !== document &amp;&amp; element !== + document.documentElement;</span>
<span class="hljs-addition">+ }</span>

<span class="hljs-addition">+ function getEleSelector(element: HTMLElement) {</span>
<span class="hljs-addition">+   if (element.id) {</span>
<span class="hljs-addition">+     return `${element.nodeName.toLowerCase()}#${element.id}`; // 返回 标签名#id</span>
<span class="hljs-addition">+   } else if (element.className &amp;&amp; typeof element.className === "string") {</span>
<span class="hljs-addition">+     return `${element.nodeName.toLowerCase()}#${element.className}`; // 返回 标签名.class</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     return element.nodeName.toLowerCase(); // 返回 标签名</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
</code></pre>
<h4 data-id="heading-7">2.5、API 请求报错</h4>
<p>在客户端（浏览器），可以通过 <code>xhr/fetch</code> 请求服务端接口。为了保证前后端交互的稳定性，双方都可以去做 <strong>API 请求监控</strong>。</p>
<p>以 <code>xhr ajax</code> 为例，要监控 API 请求的状态，推荐的做法是采用 <strong>「重写 <code>XMLHttpRequest</code> 构造函数原型上的方法」</strong> 来实现。</p>
<p>以下是一个简单的模拟 xhr 请求服务器 API 出现 500 错误的示例，对应前后端代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 前端：</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 访问一个报错的 api，模拟 500 错误</span>
  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">"get"</span>, <span class="hljs-string">"http://localhost:3000/error?name=test"</span>, <span class="hljs-literal">true</span>);
  xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>);
  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 在 onload 事件中检查 xhr.status 是否在 200-299 的范围内。如 404 或 500 错误，都会在这里进行监控上报。</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"onload: "</span>, xhr);
  };
  xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
    <span class="hljs-comment">// onerror 事件主要用于处理 跨域问题、网络错误 等无法正常连接到服务器的情况，例如本地无网络。</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"error: "</span>, error, xhr);
  };
  xhr.<span class="hljs-title function_">send</span>();
};

<span class="hljs-comment">// 服务端：</span>
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-comment">// 允许跨域</span>
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-string">"*"</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, <span class="hljs-string">"GET, POST, PUT, DELETE, OPTIONS"</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Content-Type, Authorization"</span>);

  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">"OPTIONS"</span>) {
    <span class="hljs-comment">// 处理预检请求</span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">204</span>);
    res.<span class="hljs-title function_">end</span>();
  } <span class="hljs-keyword">else</span> {
    
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"/error"</span>)) {
      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">500</span>, { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/plain"</span> });
      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">"Server Error, code is 500."</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 处理正常请求</span>
      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/plain"</span> });
      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">"Hello, world!"</span>);
    }
  }
});
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Server running on port 3000"</span>));
</code></pre>
<p>重写 <code>XMLHttpRequest</code> 原型方法来完成 API 请求监控，分以下步骤：</p>
<ol>
<li>重写 <code>XMLHttpRequest.prototype.setRequestHeader</code> 方法，保存设置的请求头信息；</li>
<li>重写 <code>XMLHttpRequest.prototype.open</code> 方法，保存 API 请求的 <code>method</code> 和 <code>url</code>；</li>
<li>重点！重写 <code>XMLHttpRequest.prototype.send</code> 方法，当判定请求出错时（如：<strong>跨域、404、500</strong>），收集请求信息进行数据上报。</li>
</ol>
<p>另外，我们还需要配置一个白名单 <code>whiteList</code>，可跳过无需监控的请求，比如「上报方式为 ajax」。</p>
<p>核心功能实现如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// modules/xhr.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ErrorLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;
<span class="hljs-keyword">import</span> { parseQueryString } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;
<span class="hljs-keyword">import</span> tracker <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/tracker"</span>;

<span class="hljs-comment">// 不需要监控的接口白名单</span>
<span class="hljs-keyword">const</span> whiteList = [
  <span class="hljs-string">"http://localhost:8080/send/monitor"</span>, <span class="hljs-comment">// 日志服务接口</span>
];

<span class="hljs-comment">// 增强 XHR：通过重写 XHR 主要方法，实现拦截和增强 XHR</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectXHR</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">XMLHttpRequest</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>;

  <span class="hljs-comment">// 1、重写 setRequestHeader 方法增强功能 - 记录 request headers 数据</span>
  <span class="hljs-keyword">const</span> oldSetRequestHeader = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setRequestHeader</span>;
  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setRequestHeader</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestHeaders</span>) (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestHeaders</span> = {});
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestHeaders</span>[key] = value;
    <span class="hljs-keyword">return</span> oldSetRequestHeader.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };

  <span class="hljs-comment">// 2、重写 open 方法增强功能 - 记录请求方式和 url</span>
  <span class="hljs-keyword">const</span> oldOpen = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">open</span>; <span class="hljs-comment">// 记录老的 open 方法</span>
  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">open</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, <span class="hljs-keyword">async</span></span>) {
    <span class="hljs-comment">// 跳过 白名单接口 防止出现死循环。</span>
    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">indexOf</span>(url) === -<span class="hljs-number">1</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span> = { <span class="hljs-attr">method</span>: method.<span class="hljs-title function_">toUpperCase</span>(), url }; <span class="hljs-comment">// 存储数据</span>
    }
    <span class="hljs-keyword">return</span> oldOpen.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };

  <span class="hljs-comment">// 3、重写 send 方法增强功能 - 监控上报数据</span>
  <span class="hljs-keyword">const</span> oldSend = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span>; <span class="hljs-comment">// 记录老的 send 方法</span>
  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span>) {
      <span class="hljs-comment">// 在 send 发送之前，记录请求开始时间</span>
      <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">type: <span class="hljs-string">"load"</span> | <span class="hljs-string">"error"</span></span>) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime; <span class="hljs-comment">// 持续的时间</span>
          <span class="hljs-keyword">const</span> status = <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span>; <span class="hljs-comment">// 200 | 400 | 500</span>
          <span class="hljs-keyword">const</span> statusText = <span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>; <span class="hljs-comment">// OK | Server Error</span>
          <span class="hljs-keyword">const</span> { url, method } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span>;
          <span class="hljs-keyword">const</span> params = [<span class="hljs-string">'GET'</span>, <span class="hljs-string">'DELETE'</span>].<span class="hljs-title function_">indexOf</span>(method) &gt; -<span class="hljs-number">1</span> ? <span class="hljs-title function_">parseQueryString</span>(url) : body;

          <span class="hljs-comment">// 当请求发生错误时，上报数据（忽略无网络的错误，处理像 跨域错误、404、500 等错误）</span>
          <span class="hljs-keyword">if</span> ((type === <span class="hljs-string">"error"</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span>.<span class="hljs-property">onLine</span>) || (type === <span class="hljs-string">"load"</span> &amp;&amp; status &gt;= <span class="hljs-number">400</span>)) {
            <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">ErrorLog</span> = {
              <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
              <span class="hljs-attr">errorType</span>: <span class="hljs-string">"xhrError"</span>, <span class="hljs-comment">// 错误类型是 xhr</span>
              <span class="hljs-attr">message</span>: statusText, <span class="hljs-comment">// 错误信息</span>
              <span class="hljs-attr">xhrData</span>: {
                <span class="hljs-attr">eventType</span>: type, <span class="hljs-comment">// load | error</span>
                url, <span class="hljs-comment">// api 路径</span>
                method, <span class="hljs-comment">// 请求方式</span>
                <span class="hljs-attr">header</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestHeaders</span>, <span class="hljs-comment">// 请求头</span>
                params, <span class="hljs-comment">// 请求参数</span>
                duration, <span class="hljs-comment">// 请求时长</span>
                status,
                <span class="hljs-attr">response</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span> ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>) : <span class="hljs-string">""</span>, <span class="hljs-comment">// 请求结果</span>
              },
            };
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"XHR log: "</span>, log);
            tracker.<span class="hljs-title function_">send</span>(log); 
          }
        };
      };
      <span class="hljs-comment">// 服务端返回 status 为 500 也会进入 load，需要进一步判断 status</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"load"</span>, <span class="hljs-title function_">handler</span>(<span class="hljs-string">"load"</span>), <span class="hljs-literal">false</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"error"</span>, <span class="hljs-title function_">handler</span>(<span class="hljs-string">"error"</span>), <span class="hljs-literal">false</span>);
    }
    <span class="hljs-keyword">return</span> oldSend.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };
}
</code></pre>
<h3 data-id="heading-8">3、白屏监控</h3>
<p>白屏通常是由 <code>代码执行错误</code> 引起，导致框架（如 React）渲染流程中断。所以白屏可以结合【异常监控】一起上报，可以关联到导致白屏的错误原因。</p>
<p>我们思考一下：如何判定当前页面是白屏呢？</p>
<p>可以采用【页面采样识别检测】：通过在页面上确定多个采样点，使用 <code>elementFromPoint</code> 方法获取采样点的元素，判断采样点元素是否为有效元素（比如非 <code>body、#root</code> 等根节点）。</p>
<p>关于采样点的定义，以页面为中心的 水平 和 垂直线上，来定义多个采样点。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c49464367264e97beb1d6117389f98b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=TzcdhLRwM9seH40%2BqX196LdNy4o%3D" alt="image.png" loading="lazy"></p>
<p>白屏检测的实现如下：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// modules/xhr.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkWhiteScreen</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 最顶层的空白元素（判断是白屏的依据）</span>
  <span class="hljs-keyword">const</span> wrapperElements = [<span class="hljs-string">"html"</span>, <span class="hljs-string">"body"</span>, <span class="hljs-string">"#root"</span>];
  <span class="hljs-keyword">let</span> emptyPoints = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录空白的点的个数</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelector</span>(<span class="hljs-params">element: Element</span>) {
    <span class="hljs-keyword">let</span> selector;
    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">id</span>) {
      selector = <span class="hljs-string">`#<span class="hljs-subst">${element.id}</span>`</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">className</span> &amp;&amp; <span class="hljs-keyword">typeof</span> element.<span class="hljs-property">className</span> === <span class="hljs-string">"string"</span>) {
      <span class="hljs-comment">// prettier-ignore</span>
      selector = <span class="hljs-string">"."</span> + element.<span class="hljs-property">className</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !!item).<span class="hljs-title function_">join</span>(<span class="hljs-string">"."</span>);
    } <span class="hljs-keyword">else</span> {
      selector = element.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();
    }
    <span class="hljs-keyword">return</span> selector;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isWrapper</span>(<span class="hljs-params">element: Element</span>) {
    <span class="hljs-keyword">const</span> selector = <span class="hljs-title function_">getSelector</span>(element);
    <span class="hljs-keyword">if</span> (wrapperElements.<span class="hljs-title function_">indexOf</span>(selector) &gt; -<span class="hljs-number">1</span>) {
      emptyPoints++; <span class="hljs-comment">// 是空白点</span>
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) {
    <span class="hljs-comment">// 在高度一半的位置，横坐标均分取 9 个点，查看这 9 个点上的元素</span>
    <span class="hljs-keyword">const</span> xElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementFromPoint</span>(
      (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-number">10</span>) * i,
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / <span class="hljs-number">2</span>,
    );
    <span class="hljs-comment">// 在宽度一半的位置，纵坐标均分取 9 个点，查看这 9 个点上的元素</span>
    <span class="hljs-keyword">const</span> yElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementFromPoint</span>(
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-number">2</span>,
      (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / <span class="hljs-number">10</span>) * i,
    );

    <span class="hljs-comment">// 判断点的位置，是否是空白元素</span>
    <span class="hljs-title function_">isWrapper</span>(xElements!);
    <span class="hljs-title function_">isWrapper</span>(yElements!);
  }

  <span class="hljs-comment">// 定义阈值，比如 当所有的点（18个）都是空白点，那么就认为是空白页面，有一个点上有元素，就认为不是空白页面。</span>
  <span class="hljs-keyword">if</span> (emptyPoints === <span class="hljs-number">18</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>当发生 JS 执行错误后，进行白屏检测并一起上报数据。</p>
<pre><code class="hljs language-diff" lang="diff">// modules/jsError.ts
...
<span class="hljs-addition">+ import checkWhiteScreen from "../utils/checkWhiteScreen";</span>

export default function injectJSError() {
  window.addEventListener(
    "error",
    event =&gt; {
      ...

<span class="hljs-addition">+     const isWhiteScreen = checkWhiteScreen(); // 检查是否白屏</span>
      // 1.1、数据建模存储
      const errorLog: ErrorLog = {
        // kind: "stability", // 监控指标的大类
        type: "error",
        errorType: "jsError",
        message: event.message,
        filename: event.filename,
        position: `${event.lineno}:${event.colno}`,
        stack: formatStack(event.error.stack),
        selector: lastEvent ? getSelector() : "",
<span class="hljs-addition">+       isWhiteScreen,</span>
      };
      console.log("js error log: ", errorLog);

      // 1.2、上报数据
      tracker.send(errorLog);
    },
    // !!! 使用捕获
    true,
  );
  ...
}
</code></pre>
<h3 data-id="heading-9">4、统计页面加载时间</h3>
<p>页面加载时间的指标信息有很多，一般会重点分析&nbsp;<strong>DOM 树构建完成的时间（<code>DOMContentLoaded</code>） 和 页面完整的加载时间（<code>load</code>）</strong> 。</p>
<p>浏览器 <code>PerformanceNavigationTiming</code> 对象提供了关于页面加载性能的详细信息。（<code>对应旧版本的 performance.timing 对象</code>）</p>
<p>在统计加载时间前，我们先了解两个 JS 事件的执行时机：</p>
<ul>
<li><code>DOMContentLoaded</code>，是一个 DOM 事件，当浏览器完成 HTML 文档的解析，构建完成 DOM 树后触发，但不包含图片、CSS、JavaScript 等外部资源的加载。</li>
<li><code>onLoad</code>，是一个 JS 事件，它在页面的所有资源（包括 HTML、CSS、图片、JavaScript 等）完全加载完成后触发。</li>
</ul>
<p>如何统计这两个加载时间呢？需要用到以下信息：</p>
<ul>
<li><code>fetchStart</code>：浏览器开始发起 HTTP 请求文档的时间；</li>
<li><code>domContentLoadedEventStart</code>：DOM 树构建完成后触发 DOMContentLoaded 事件的时间；</li>
<li><code>loadEventStart</code>：页面所有资源（包括图片）加载完成后触发 window.onload 事件发生的时间。</li>
</ul>
<p>如下示例，在 DOM 树构建完成后，请求一个图片资源：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://picsum.photos/200/300"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>对应的先得到 <code>DOMContentLoaded</code> 时间，等待图片加载完成后，得到 <code>onLoad</code> 时间。</p>
<p>监听统计加载时间实现如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// modules/timing.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">TimingLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;
<span class="hljs-keyword">import</span> tracker <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/tracker"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectTiming</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"load"</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-title class_">DOMContentLoadedTime</span> = <span class="hljs-number">0</span>,
      loadTime = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 新版浏览器 API：PerformanceNavigationTiming 提供了关于页面加载性能的详细信息，替代旧的 performance.timing</span>
    <span class="hljs-keyword">if</span> (performance.<span class="hljs-property">getEntriesByType</span>) {
      <span class="hljs-keyword">const</span> perfEntries = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">"navigation"</span>);
      <span class="hljs-keyword">if</span> (perfEntries.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> navigationEntry = perfEntries[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">const</span> { fetchStart, domContentLoadedEventStart, loadEventStart } =
          navigationEntry <span class="hljs-keyword">as</span> <span class="hljs-title class_">PerformanceNavigationTiming</span>;

        <span class="hljs-comment">// DOM 树构建完成后触发 DOMContentLoaded 事件</span>
        <span class="hljs-title class_">DOMContentLoadedTime</span> = domContentLoadedEventStart - fetchStart;

        <span class="hljs-comment">// 页面完整的加载时间</span>
        loadTime = loadEventStart - fetchStart;
      }
    }
    <span class="hljs-comment">// 旧版浏览器降级使用 performance.timing</span>
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> { fetchStart, domContentLoadedEventStart, loadEventStart } = performance.<span class="hljs-property">timing</span>;
      <span class="hljs-title class_">DOMContentLoadedTime</span> = domContentLoadedEventStart - fetchStart;
      loadTime = loadEventStart - fetchStart;
    }

    <span class="hljs-comment">// 1、数据建模存储</span>
    <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">TimingLog</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"timing"</span>,
      <span class="hljs-title class_">DOMContentLoadedTime</span>,
      loadTime,
    };

    <span class="hljs-comment">// 2、上报数据</span>
    tracker.<span class="hljs-title function_">send</span>(log);
  });
}
</code></pre>
<p>加载时间统计结果大致如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75db94ec5fc44b09b88ad9dac76a1797~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=tba%2F%2FplP0zwiMhGVBj6TU7FwiiM%3D" alt="image.png" loading="lazy"></p>
<p>PS：页面加载性能详细信息参考资料：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformanceNavigationTiming" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigationTiming" ref="nofollow noopener noreferrer">PerformanceNavigationTiming</a></p>
<h3 data-id="heading-10">5、性能指标</h3>
<p>性能指标，类似算法里面的【时间复杂度】，可用来衡量一个网站的响应速度。通过监控和分析性能指标，来改善页面性能，提升用户体验。</p>
<p>常见的性能指标有：</p>
<ol>
<li><code>FP, First Paint(首次绘制 - 首次像素绘制)</code>：包括了任何用户自定义的背景绘制，它是首次将像素绘制到屏幕的时刻；</li>
<li><code>FCP, First Content Paint(首次内容绘制)</code>：<strong>是浏览器将第一个有内容的 DOM 渲染到屏幕的时间，内容可以是 文本、图像、SVG 等,这其实就是白屏时间</strong>；</li>
<li><code>FMP, First Meaningful Paint(首次有意义内容绘制)</code>：页面有意义的内容（由我们指定）渲染的时间；</li>
<li><code>LCP, (Largest Contentful Paint)(最大内容渲染)</code>：LCP 指标代表的是视窗最大可见<code>图片或者文本块</code>的渲染时间。（以百度首页为例，LCP 对应的元素是百度 Logo）；</li>
</ol>
<h4 data-id="heading-11">5.1、FP 和 FCP</h4>
<p>如下示例，我们在 0.5s 后给 div 设置背景色进行首次像素绘制（FP），1s 后在页面呈现有效内容（FCP）。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 0.5s 后进行首次像素绘制</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      root.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">"gray"</span>;
      root.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">"100px"</span>;
    }, <span class="hljs-number">500</span>);

    <span class="hljs-comment">// 1s 后在页面呈现有效内容</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      root.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">"content"</span>;
    }, <span class="hljs-number">1000</span>);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>FP 和 FCP 指标都可以通过 <code>PerformanceObserver API</code> 观察 <code>type: paint</code> 来计算。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// modules/paint.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectPaint</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">PerformanceObserver</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FP</span>, <span class="hljs-variable constant_">FCP</span>;

    <span class="hljs-comment">// 1、监控性能指标 FP（First Paint） 和 FCP（First Contentful Paint）</span>
    <span class="hljs-keyword">const</span> observerFPAndFCP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">entryList</span>) {
      <span class="hljs-keyword">const</span> perfEntries = entryList.<span class="hljs-title function_">getEntries</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> perfEntry <span class="hljs-keyword">of</span> perfEntries) {
        <span class="hljs-keyword">if</span> (perfEntry.<span class="hljs-property">name</span> === <span class="hljs-string">"first-paint"</span>) {
          <span class="hljs-variable constant_">FP</span> = perfEntry;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"首次像素绘制 时间："</span>, <span class="hljs-variable constant_">FP</span>?.<span class="hljs-property">startTime</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (perfEntry.<span class="hljs-property">name</span> === <span class="hljs-string">"first-contentful-paint"</span>) {
          <span class="hljs-variable constant_">FCP</span> = perfEntry;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"首次内容绘制 时间："</span>, <span class="hljs-variable constant_">FCP</span>?.<span class="hljs-property">startTime</span>);
          observerFPAndFCP.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 得到 FCP 后，断开观察，不再观察了</span>
        }
      }
    });
    <span class="hljs-comment">// 观察 paint 相关性能指标</span>
    observerFPAndFCP.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"paint"</span>] });
  }
}
</code></pre>
<h4 data-id="heading-12">5.2、FMP</h4>
<p>这里我们先认识一个 HTML 属性：</p>
<p><code>elementtiming</code> 属性用于标记页面中特定元素（如图片、视频、文本块等），以便通过 <code>PerformanceObserver</code> 的 <code>element</code> 类型监控这些元素的加载和渲染时间。</p>
<blockquote>
<p><code>PerformanceObserver</code> 的 <code>element</code> 类型主要支持监控以下元素类型：</p>
<ul>
<li><strong>图片（<code>&lt;img&gt;</code>）</strong> ：结合设置 <code>elementtiming</code> 属性来监控其渲染时间；</li>
<li><strong>文本块（<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>（验证发现 <code>&lt;span&gt;</code> 不行））</strong> ：这类元素内容是纯文本，结合设置 <code>elementtiming</code> 属性来监控其渲染时间；</li>
</ul>
</blockquote>
<p>如下示例，我们在 1.5s 后向页面添加 <code>有意义（属性标识）</code> 的元素。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 1.5s 后向页面添加 有意义（属性标识） 的元素</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> ele = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
  ele.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">"meaningful ele."</span>;
  ele.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"elementtiming"</span>, <span class="hljs-string">"meaningful ele"</span>); <span class="hljs-comment">// 设置 root 元素为「最有意义的元素」</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(ele);
}, <span class="hljs-number">1500</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>我们使用 <code>PerformanceObserver API</code> 观察 <code>type: element</code> 来计算 FMP。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// modules/paint.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectPaint</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">PerformanceObserver</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FP</span>, <span class="hljs-variable constant_">FCP</span>, <span class="hljs-variable constant_">FMP</span>;

    ...

    <span class="hljs-comment">// 2、监控性能指标：FMP（First Meaningful Paint）</span>
    <span class="hljs-keyword">const</span> observerFMP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function"><span class="hljs-params">entryList</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> perfEntries = entryList.<span class="hljs-title function_">getEntries</span>();
      <span class="hljs-variable constant_">FMP</span> = perfEntries[<span class="hljs-number">0</span>];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"首次有意义元素绘制 时间："</span>, <span class="hljs-variable constant_">FMP</span>?.<span class="hljs-property">startTime</span>);
      observerFMP.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 断开观察，不再观察了</span>
    });
    observerFMP.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"element"</span>] });
  }
}
</code></pre>
<h4 data-id="heading-13">5.3、LCP</h4>
<p>LCP 可通过 <code>PerformanceObserver API</code> 观察 <code>type: largest-contentful-paint</code> 来监听统计。</p>
<p>需要注意的是，LCP 可能会在页面加载过程中多次触发，当最大内容元素发生变化时。</p>
<p>如下示例，由于 div2 的内容大于之前的 div1 内容，LCP 的统计会触发两次：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
div1.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">"这是一段很长的文本"</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div1);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> div2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
  div2.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">"这是一段很长很长很长的文本"</span>;
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div2);
}, <span class="hljs-number">500</span>);
</code></pre>
<p>那么什么时候停止 LCP 监控呢？我们可以在需要上报性能指标时（比如 <code>load</code> 事件），停止对 LCP 的监控，这时收集到的 LCP 就是此刻页面中最大的内容。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// modules/paint.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectPaint</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">PerformanceObserver</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FP</span>, <span class="hljs-variable constant_">FCP</span>, <span class="hljs-variable constant_">FMP</span>, <span class="hljs-variable constant_">LCP</span>;

    ...

    <span class="hljs-comment">// 3、创建性能观察者，观察 LCP</span>
    <span class="hljs-keyword">const</span> observerLCP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function"><span class="hljs-params">entryList</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> perfEntries = entryList.<span class="hljs-title function_">getEntries</span>();
      <span class="hljs-variable constant_">LCP</span> = perfEntries[<span class="hljs-number">0</span>];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"最大内容绘制 时间："</span>, <span class="hljs-variable constant_">LCP</span>?.<span class="hljs-property">startTime</span>, perfEntries);
    });
    <span class="hljs-comment">// 观察页面中最大内容的绘制</span>
    observerLCP.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"largest-contentful-paint"</span>] });

    <span class="hljs-comment">// TODO... 在上报性能指标数据的时候，停止观察。</span>
    observerLCP.<span class="hljs-title function_">disconnect</span>();
  }
}
</code></pre>
<h4 data-id="heading-14">5.4、上报性能指标</h4>
<p>收集到 FP、FCP、FMP、LCP 性能指标以后，便可以上报数据。上报时机这里选择在页面 load 以后等待 3s 进行上报。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// modules/paint.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectPaint</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">PerformanceObserver</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">FP</span>: <span class="hljs-title class_">PerformanceEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">FCP</span>: <span class="hljs-title class_">PerformanceEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">FMP</span>: <span class="hljs-title class_">PerformanceEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">LCP</span>: <span class="hljs-title class_">PerformanceEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

    ...
    
    <span class="hljs-comment">// 上送性能指标</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"load"</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// 在上报性能指标数据的时候，停止 LCP 的观察。</span>
        observerLCP.<span class="hljs-title function_">disconnect</span>();
        <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">PaintLog</span> = {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"paint"</span>,
          <span class="hljs-attr">FP</span>: <span class="hljs-variable constant_">FP</span>?.<span class="hljs-property">startTime</span>, <span class="hljs-comment">// FP</span>
          <span class="hljs-attr">FCP</span>: <span class="hljs-variable constant_">FCP</span>?.<span class="hljs-property">startTime</span>, <span class="hljs-comment">// FCP</span>
          <span class="hljs-attr">FMP</span>: <span class="hljs-variable constant_">FMP</span>?.<span class="hljs-property">startTime</span>, <span class="hljs-comment">// FMP</span>
          <span class="hljs-attr">LCP</span>: <span class="hljs-variable constant_">LCP</span>?.<span class="hljs-property">startTime</span>, <span class="hljs-comment">// LCP</span>
        };
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"paint log: "</span>, log);
        tracker.<span class="hljs-title function_">send</span>(log);
      }, <span class="hljs-number">3000</span>);
    });
  }
}
</code></pre>
<h3 data-id="heading-15">6、卡顿监控</h3>
<p>在 JS 同步执行复杂的计算、大量的 DOM 操作等工作的时候，主线程会被占用，其他操作（比如用户交互、动画渲染）都会被阻塞。</p>
<p><strong>PerformanceObserver</strong> 是一个强大的 API，可以用来监听各种性能事件，包括 <strong><code>长任务（longtask）</code></strong>。当主线程上的任务执行时间超过 100 毫秒时（设定一个阈值），可以认为这是一个长任务，可能会导致页面卡顿。</p>
<p>下面我们使用 while 循环模拟一个 200ms 长任务：</p>
<pre><code class="hljs language-html" lang="html">// examples/longTask.html
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"longTaskBtn"</span>&gt;</span>长任务<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">longTask</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &lt; <span class="hljs-number">200</span> + start) {}
    }
    longTaskBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, longTask);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>新建 <code>module/longTask.ts</code> 文件，监听 <strong>长任务（longtask）</strong> 作为卡顿现象进行数据上报。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// module/longTask.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PerformanceLog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../interface"</span>;
<span class="hljs-keyword">import</span> getLastEvent <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/getLastEvent"</span>;
<span class="hljs-keyword">import</span> getSelector <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/getSelector"</span>;
<span class="hljs-keyword">import</span> tracker <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/tracker"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectLongTask</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">PerformanceObserver</span>) {
    <span class="hljs-keyword">const</span> observerLongTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> {
      list.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
        <span class="hljs-comment">// 执行时长大于 100 ms</span>
        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">100</span>) {
          <span class="hljs-keyword">const</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>();
          
          <span class="hljs-keyword">const</span> <span class="hljs-attr">log</span>: <span class="hljs-title class_">LongTaskLog</span> = {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"longTask"</span>,
            <span class="hljs-attr">startTime</span>: entry.<span class="hljs-property">startTime</span>, <span class="hljs-comment">// 开始时间</span>
            <span class="hljs-attr">duration</span>: entry.<span class="hljs-property">duration</span>, <span class="hljs-comment">// 持续时间</span>
            <span class="hljs-attr">selector</span>: lastEvent ? <span class="hljs-title function_">getSelector</span>() : <span class="hljs-string">""</span>,
            <span class="hljs-attr">eventType</span>: lastEvent?.<span class="hljs-property">type</span>,
          };

          tracker.<span class="hljs-title function_">send</span>(log);
        }
      });
    });

    observerLongTask.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"longtask"</span>] });
  }
}
</code></pre>
<h2 data-id="heading-16">二、重难点实现</h2>
<h3 data-id="heading-17">1、Source Map 源代码定位</h3>
<p>在前端项目中，为了节省构建资源体积，不暴露业务逻辑，都会选择将代码进行混淆和压缩。但在优化性能 和 提升用户体验的同时，也为异常的处理带来了麻烦。</p>
<p><code>Source Map</code> 是一个源代码信息文件，里面存储着代码压缩混淆前后的对应关系。我们<strong>输入混淆后的行列号，就能够获得对应的原始代码的行列号，结合源代码文件便可定位到真实的报错位置</strong>。</p>
<p>但在生产环境下，我们不建议将 Source Map 放到网站上，对于具有一定规模和保密性的项目，这样等于将页面逻辑直接暴露给了网站使用者。</p>
<p>在这种情况下，监控 SDK 收集和上传的错误信息也是混淆和压缩后的，并不利于我们定位异常。那有没有其他办法来定位错误呢？</p>
<p>一般来说 Source Map 的应用都是在监控系统中，开发者<strong>构建完应用后，通过插件（例如自定义 webpack plugin）将 Source Map 文件（含源代码）上传至监控平台中</strong>。（例如 <code>Sentry</code> 监控平台也是这样做的）</p>
<p>一旦客户端上报错误后，我们就可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmozilla%2Fsource-map" target="_blank" title="https://github.com/mozilla/source-map" ref="nofollow noopener noreferrer">source-map</a> 这个库来还原错误信息在源代码中的位置，方便开发者快速定位线上问题。</p>
<h3 data-id="heading-18">2、错误信息聚合</h3>
<p>为了避免异常错误列表被大量的重复上报给占满，需要将具有相同特征的错误上报，归类为同一种异常，并且在统计平台只对用户暴露这种聚合后的异常。</p>
<p>一个错误信息的结构如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/382533f119804ff68bf702f6bd0a3672~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=HkVsqi5YoMWhG4LbVrOXyLT3JQk%3D" alt="image.png" loading="lazy"></p>
<ul>
<li><code>name</code>： 异常的 Type，例如 <code>TypeError, SyntaxError, DOMError</code>；</li>
<li><code>Message</code>：异常的相关信息，通常是异常原因，例如 <code>a is not defined.</code>；</li>
<li><code>Stack</code> 异常的上下文堆栈信息，通常为字符串，例如 <code>errirClick、HTMLInputElement.onclick</code>；</li>
</ul>
<p>经过监控 SDK 收集到的 error log 如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2f776fa28844cef829dece7e49a6cfc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749285856&amp;x-signature=CafFOxyA0%2BIhXlnq6Uq4GlPuS68%3D" alt="image.png" loading="lazy"></p>
<p><strong>错误信息聚合的思路 - 为每个错误生成唯一的标识符（uid）</strong>：</p>
<p>比如我们可以使用 <code>name + message + stack</code> 作为聚合依据，生成一个 <code>hash 值</code> 来作为这个错误的<code>唯一性的&nbsp;ID</code>。</p>
<p>如果后续捕获到的错误生成的 <code>hash 值</code> 与之前某个错误的 <code>hash 值</code> 相同，则认为是重复错误，不再进行数据入库或者是统计错误发生次数 + 1。</p>
<h3 data-id="heading-19">3、数据加工和清洗</h3>
<p>数据加工和清洗发生在服务端。在对数据进行入库前，进行数据加工和清洗的意义在于：</p>
<ul>
<li><code>数据加工</code> 可以对数据提取出关键指标和有价值的信息，以及扩展一些额外信息（如：在服务端才能获取的 <code>IP地址</code>）；</li>
<li><code>数据清洗</code> 可以剔除无效、重复或冗余的数据，减少存储空间的浪费，同时提高数据处理的效率。</li>
</ul>
<h3 data-id="heading-20">4、异常报警</h3>
<p>在出现程序执行出错异常后，需要及时反馈通知到开发人员，并及早跟进和处理问题。</p>
<p>错误报警可以从两个维度进行：<strong>对新增异常的报警 和 对错误指标的数量（达到某个阈值）的报警</strong>。</p>
<p>常见的报警的方式：邮件报警、接入办公即时通信应用（自研产品、企业钉钉）等。</p>
<h2 data-id="heading-21">文末</h2>
<p>以上内容是作者结合当前所掌握的知识，整理出来的一套前端监控 SDK 实现思路，后续也会继续根据工作场景，对本文内容进行扩充和完善。</p>
<p>感谢你的阅读！文章内容你觉得有用，可以<strong>点赞</strong>支持一下~</p>
<p>参考：<br>
<a href="https://juejin.cn/post/7195496297150709821" target="_blank" title="https://juejin.cn/post/7195496297150709821">字节前端监控实践</a></p></div></div>