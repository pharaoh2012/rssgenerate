
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hsiang/p/18622806" title="发布于 2024-12-30 12:00">
    <span role="heading" aria-level="2">进程间通信组件ZeroMQ详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在一些复杂的项目中，往往会由不同功能的程序组成，且在程序运行期间，各个程序还需要进行互相通信，实现进程间通信的方式有很多种，最常用的就是通过消息中间件，比如RabbitMQ，Kafaka，以及ZeroMQ等，而RabbitMQ和Kafaka这两款中间件往往都需要独立安装步骤才能使用，ZeroMQ却不需要独立安装部署，而是作为动态库直接在程序中引用即可。今天以一个简单的小例子，简述ZeroMQ的常见用法，仅供学习分享使用，如有不足之处，还请指正。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在一些复杂的项目中，往往会由不同功能的程序组成，且在程序运行期间，各个程序还需要进行互相通信，实现进程间通信的方式有很多种，最常用的就是通过消息中间件，比如RabbitMQ，Kafka，以及ZeroMQ等，而RabbitMQ和Kafka这两款中间件往往都需要独立安装步骤才能使用，ZeroMQ却不需要独立安装部署，而是作为动态库直接在程序中引用即可。今天以一个简单的小例子，简述ZeroMQ的常见用法，仅供学习分享使用，如有不足之处，还请指正。</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241228225749156-1490502760.png"></p>
<p>ZeroMQ （又被称为 ØMQ, 0MQ, or zmq），虽然看起来像是可嵌入的网络组件，实际上却是一款并发框架。ZeroMQ作为一款开源通用消息组件，通过Socket可以将原子消息通过不同协议（进程内，进程间，TCP和广播等）进行传输。基于ZeroMQ，可以由多种模式进行选择，如：fan-out，发布-订阅，任务分发，请求-应答等，并且支持1-N，N-N等多端通信。对于C#开发人员，ZeroMQ有两种方式可供选择，1. NetMQ，提供一个端口给C#；2. clrzmq4通过C#绑定到libzmq。而NetMQ正是ZeroMQ推荐的使用方式</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241222191441066-1177491342.png"></p>
<h1>ZeroMQ通信模式</h1>
<p>&nbsp;</p>
<p>ZeroMQ提供了多种通信模式，主要有以下几种：</p>
<ul>
<li>请求应答（Request-Response）模式，此模式是ZeroMQ所有通信方式中最简单的一种模式，当客户端发出请求时，期望得到应答，且必须得到应答，才算一个完整的通信。</li>
</ul>
<ul>
<li>发布订阅（Publish-Subscriber）模式，此模式发送者并不直接发送消息给接收者，而是将要发送的消息进行分类，接收者根据分类只接收自己感兴趣的消息，这就是发布订阅模式。这里提及的消息分类，通常被称为主题（topic）或过滤器（filter）。ZeroMQ通过多种信息来表达主题内容，以字节数组或者字符串的形式表示。</li>
<li>生产者-消费者（Push-Pull）模式，此模式是一个消息分发机制，主要用于任务并发和并行处理场景，正常情况下，一个或者多个生产者发送消息，而一个或多个消费者接收并处理这些消息，这种模式特别适合于需要高效任务分发的场景，如分布式计算，大数据处理等。</li>
<li>路由经销商（Router-Dealer）模式，此种模式是请求回复模式的一种升级，当Router收到消息的时候，会自动在消息的前面添加一帧，用来识别发送端的地址。当发送一个消息的时候，需要先发送一帧对端的地址，然后再发送消息，如果目的地址指向的对端不存在了，这个消息就会被丢弃。对端的地址默认情况下由ZMQ来产生一个唯一标识UUID。DEALER可以任意读写，不需要额外的地址帧，当有多个对端的时候，循环给单个对端发送消息。（注意：不是群发消息，与PUB不同）。</li>
<li>多发布订阅（XPub-XSub），通常情况下，发布订阅模式适用于一个发布者，多个订阅者的场景。如果需要多个消息发布者，那XPub-XSub模式将会比较适用。</li>
</ul>
<p>本文主要讲解请求应答模式和发布订阅模式，其他通信模式，如果感兴趣可以参考官方文档。</p>
<h1>请求应答</h1>
<p>请求应答（Request-Response），此模式是ZeroMQ所有通信方式中最简单的一种模式，当客户端发出请求时，期望得到应答，且必须得到应答，才算一个完整的通信。请求应答模式是同步阻塞模式，如果发送消息顺序错误，会抛出异常。正确的请求应答顺序如下：</p>
<ol>
<li>请求端（RequestSocket）发送一个消息</li>
<li>响应端（ResponseSocket）阅读请求消息</li>
<li>响应端（ResponseSocket）发送响应信息</li>
<li>请求端（RequestSocket）接收响应端（ResponseSocket）发送的信息。</li>
</ol>
<p>请求应答模式，主要由RequestSocket和ResponseSocket组成，实现消息的请求和应答。</p>
<p>请求端发送消息之前，需要先进行连接Connect，然后才能发送消息。示例代码如下所示：</p>
<pre class="language-csharp highlighter-hljs"><code>public class ZeroMQRequest:IDisposable
{
	public Action&lt;string&gt; Received;
	public Action&lt;string&gt; Sended;
	private string url = string.Empty;

	private RequestSocket request;

	public ZeroMQRequest(string url)
	{
		this.request = new RequestSocket();
		this.url = url;
	}

	public void Connect()
	{
		request.Connect(this.url);
	}

	public void BeginReceive()
	{
		string msg = this.request.ReceiveFrameString();
		Received?.Invoke(msg);
	}

	public void SendMsg(string msg)
	{
		this.request.SendFrame(msg);
		if (Sended != null)
		{
			Sended.Invoke(msg);
		}
	}

	public void Disconnect()
	{
		request.Disconnect(this.url);
	}

	public void Dispose()
	{
		request.Close();
		request.Dispose();
	}
}</code></pre>
<p>响应端接收消息之前，需要先进行绑定（Bind）到对应的网络端口，然后才能接收消息。示例代码如下所示：</p>
<pre class="language-csharp highlighter-hljs"><code>public class ZeroMQResponse:IDisposable
{
	public Action&lt;string&gt; Received;
	public Action&lt;string&gt; Sended;
	private string url = string.Empty;
	private ResponseSocket response;

	public ZeroMQResponse(string url)
	{
		this.url = url;
		this.response = new ResponseSocket();
		this.response.Bind(this.url);
	}

	public void BeginReceive()
	{
		Task.Run(() =&gt;
		{
			while (true)
			{
				string msg = this.response.ReceiveFrameString();
				Received?.Invoke(msg);
				//收到回复
				Send("Ok");
			}
		});
		
	}

	public void Send(string msg)
	{
		this.response.SendFrame(msg);
		if (Sended != null)
		{
			Sended.Invoke(msg);
		}
	}

	public void Dispose()
	{
		this.response.Dispose();
	}
}</code></pre>
<p>上述代码是将ReuqestSocket和ResponseSocket进行封装，并通过委托Action公开了接收和发送后响应接口，在使用时进行调用即可。</p>
<p>请求应答模式示例截图如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241229220330039-1277705182.png"></p>
<p>由于请求应答模式是阻塞模式，如果没有发送就调用接收方法，或连续调用接收方法，或连续发送（发送没有响应就再次发送），则会抛出异常。</p>
<p>连续两次发送，异常信息如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241229194536454-50489222.png"></p>
<p>连续两次接收，异常信息如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241229194703995-762308824.png"></p>
<h1>发布订阅</h1>
<p>发布订阅模式，将要发送的信息按照主题（Topic）进行分类，哪个接收端订阅了这个主题，就接收对应的消息，而不是直接发发送给接收者，这样有助于对消息进行分类处理。所以发布订阅模式并非阻塞模式，也不是一对一的请求响应，而是按需分类，异步响应模式。此模式主要有PublisherSocket和SubscriberSocket两个类，分别用于处理消息的发布和订阅。正确的发布订阅顺序，如下所示：</p>
<ol>
<li>发送端：定义PubliserSocket对象，并绑定（Bind）到指定端口。然后发送主题和消息。</li>
<li>接收端：定义SubscriberSocket对象，连接到指定端口，订阅主题，接收指定主题的消息。</li>
</ol>
<p>消息发布类（PublisherSocket），在消息发送之前，首先绑定一个端口，然后才能发送主题和消息，示例代码如下所示：</p>
<pre class="language-csharp highlighter-hljs"><code>public class ZeroMQPublisher : IDisposable
{
	private string url=string.Empty;
	private PublisherSocket publisher;
	public Action&lt;string&gt; Sended;


	public ZeroMQPublisher(string url)
	{
		this.url = url;
		this.publisher = new PublisherSocket();
		this.publisher.Bind(url);
	}

	public void Send(string topic,string msg)
	{
		this.publisher.SendMoreFrame(topic);
		this.publisher.SendFrame(msg);
		if(Sended != null)
		{
			Sended.Invoke($"send msg,topic:{topic},msg:{msg},time is {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
		}
	}

	public void Dispose()
	{
		this.publisher.Close();
		this.publisher.Dispose();
	}
}</code></pre>
<p>消息订阅类（SubscriberSocket），在消息接收之前，首先连接端口，订阅主题（Subscribe方法），然后才能进行消息的接收，示例代码如下所示：</p>
<pre class="language-csharp highlighter-hljs"><code>public class ZeroMQSubscriber : IDisposable
{
	private string url=string.Empty;
	private SubscriberSocket subscriber;

	public Action&lt;string&gt; Received;
	private bool isRunning = false;

	public ZeroMQSubscriber(string url)
	{
		this.url = url;
		this.subscriber = new SubscriberSocket();
		this.subscriber.Connect(url);
		this.subscriber.Subscribe(string.Empty);
		this.isRunning = true;
	}

	public void BeginReceive()
	{
		Task.Run(() =&gt;
		{
			while(isRunning)
			{
				var topic = this.subscriber.ReceiveFrameString();
				var msg = this.subscriber.ReceiveFrameString();
				if(Received != null)
				{
					Received.Invoke($"received msg,topic:{topic},msg:{msg},time is {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
				}
			}
		});
	}

	public void DisConnect()
	{
		isRunning = false;
		this.subscriber.Disconnect(this.url);
	}

	public void Dispose()
	{
		this.isRunning=false;
		this.subscriber.Close();
		this.subscriber?.Dispose();
	}
}</code></pre>
<p>注意，发布订阅模式是单向触发的，即消息发布者，不可以接收消息；消息接收者，也不可以发布消息。接收端在调用Subscribe方法时，如果主题为空，则表示可以订阅任何主题。</p>
<p>发布订阅模式示例截图如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241229220604206-33499186.png"></p>
<h1>源码下载</h1>
<p>关注老码识途公众号，回复关键字ZeroMQ，即可获取示例源码，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1068941/202412/1068941-20241229223148789-668038902.png"></p>
<p>以上就是《进程间通信组件库ZeroMQ详解》的全部内容。</p>
</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">
 
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 30px; font-family: 微软雅黑; font-size: 12px" id="PSignature">
<br>
  <a style="float: left; display: block; padding-right: 10px" target="_blank" href="https://images.cnblogs.com/cnblogs_com/hsiang/1154298/o_115f1cd8.jpg">
   <img alt="" src="https://images.cnblogs.com/cnblogs_com/hsiang/1154298/o_115f1cd8.jpg" width="80px" height="80px">
   </a>
    作者：<a href="http://www.cnblogs.com/hsiang/" target="_blank">老码识途</a>
    <br>
    出处：<a href="http://www.cnblogs.com/hsiang/" target="_blank">http://www.cnblogs.com/hsiang/</a>
    <br>
    本文版权归作者和博客园共有，写文不易，支持原创，欢迎转载【点赞】，转载请保留此段声明，且在文章页面明显位置给出原文连接，谢谢。
    <br>关注个人公众号，定时同步更新技术及职场文章
<br><br>
   </p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.877336905261574" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 12:00">2024-12-30 12:00</span>&nbsp;
<a href="https://www.cnblogs.com/hsiang">老码识途呀</a>&nbsp;
阅读(<span id="post_view_count">37</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18622806" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18622806);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18622806', targetLink: 'https://www.cnblogs.com/hsiang/p/18622806', title: '进程间通信组件ZeroMQ详解' })">举报</a>
</div>
        