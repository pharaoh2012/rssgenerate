
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/forges/p/18742735" title="发布于 2025-02-28 10:27">
    <span role="heading" aria-level="2">如何在.NET Core中解决缓存穿透、缓存雪崩和缓存击穿问题：多级缓存策略详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<br>
<p class="md-end-block md-p"><span class="md-plain">在构建高性能的分布式系统时，缓存是一个必不可少的组件。它能显著提高系统的响应速度，减少对数据库的访问压力。然而，缓存机制的设计需要注意一些常见的问题，如<span class="md-pair-s"><strong><span class="md-plain">缓存穿透</span></strong><span class="md-plain">、<span class="md-pair-s "><strong><span class="md-plain">缓存雪崩</span></strong><span class="md-plain">和<span class="md-pair-s "><strong><span class="md-plain">缓存击穿</span></strong><span class="md-plain">，这些问题若处理不当，会导致系统性能下降，甚至系统崩溃。</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p md-focus"><span class="md-plain md-expand">本文将详细介绍如何在.NET Core中解决这些问题，尤其是通过多级缓存策略来提高系统的性能和稳定性。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">一、缓存穿透：如何避免查询无效数据</span></h2>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">什么是缓存穿透？</span></strong></span></h3>
<p class="md-end-block md-p"><span class="md-plain">缓存穿透是指查询的数据既不在缓存中，也不在数据库中。当发生缓存穿透时，所有的请求都会直接访问数据库，导致数据库压力增大，系统性能下降。典型的例子是，用户查询的某个数据根本不存在，但是每个请求都会直接访问数据库进行查询。</span></p>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">解决方法：</span></strong></span></h3>
<ol class="ol-list">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓存空数据</span></strong><span class="md-plain">： 为了避免每次请求都查询数据库，可以在缓存中保存“空数据”。当查询的数据不存在时，我们将空结果（例如<span class="md-pair-s"><code>null</code><span class="md-plain">或空字符串）缓存一定时间，之后的相同请求将直接从缓存中获取空数据，从而避免重复查询数据库。</span></span></span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">async <span class="cm-variable-3">Task<span class="cm-operator">&lt;<span class="cm-variable-3">string<span class="cm-operator">&gt; <span class="cm-def">GetDataAsync(<span class="cm-variable-3">string <span class="cm-variable">key)<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">cachedResult <span class="cm-operator">= <span class="cm-keyword">await <span class="cm-variable">_cache.<span class="cm-variable">GetStringAsync(<span class="cm-variable">key);<br><span> &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">cachedResult <span class="cm-operator">== <span class="cm-atom">null)<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 查询数据库<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">dbResult <span class="cm-operator">= <span class="cm-variable">GetDataFromDatabase(<span class="cm-variable">key);<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">dbResult <span class="cm-operator">== <span class="cm-atom">null)<br><span> &nbsp; &nbsp; &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 数据库中也不存在，缓存空结果<br><span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable">_cache.<span class="cm-variable">SetStringAsync(<span class="cm-variable">key, <span class="cm-variable-3">string.<span class="cm-variable">Empty, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">5)); &nbsp;<span class="cm-comment">// 设置一个较短的过期时间<br><span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-atom">null;<br><span> &nbsp; &nbsp; &nbsp;  }<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 数据库查询结果缓存<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable">_cache.<span class="cm-variable">SetStringAsync(<span class="cm-variable">key, <span class="cm-variable">dbResult, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30));<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">dbResult;<br><span> &nbsp;  }<br><span>​<br><span> &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">cachedResult <span class="cm-operator">== <span class="cm-variable-3">string.<span class="cm-variable">Empty <span class="cm-operator">? <span class="cm-atom">null : <span class="cm-variable">cachedResult;<br><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">请求参数校验</span></strong><span class="md-plain">： 在查询数据库之前，对请求参数进行校验。如果请求的参数无效（例如非法的ID或格式错误），则可以直接返回错误信息，避免恶意请求或无效请求进入缓存查询逻辑。</span></span></p>
<p class="md-end-block md-p"><span class="md-plain">例如，检查用户请求的ID是否符合合法格式，若不合法，直接返回错误提示。</span></p>
</li>
</ol>
<h2 class="md-end-block md-heading"><span class="md-plain">二、缓存雪崩：避免大量数据同时失效</span></h2>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">什么是缓存雪崩？</span></strong></span></h3>
<p class="md-end-block md-p"><span class="md-plain">缓存雪崩是指缓存中大量数据在同一时刻失效，导致大量请求直接访问数据库。这种情况通常发生在缓存的失效时间设置过于集中，导致大量缓存同时过期，从而给数据库带来巨大的负载。</span></p>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">解决方法：</span></strong></span></h3>
<ol class="ol-list">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">随机过期时间</span></strong><span class="md-plain">： 为每个缓存项设置不同的过期时间，通过加入随机偏移量来避免大量缓存同时过期，分散过期的时间点，减少数据库的压力。</span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">void <span class="cm-variable">SetCacheWithRandomExpiration(<span class="cm-variable-3">string <span class="cm-variable">key, <span class="cm-variable-3">string <span class="cm-keyword">value)<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">randomOffset <span class="cm-operator">= <span class="cm-keyword">new <span class="cm-variable">Random().<span class="cm-variable">Next(<span class="cm-number">1, <span class="cm-number">60); <span class="cm-comment">// 随机生成1到60分钟的偏移量<br><span> &nbsp; &nbsp;<span class="cm-variable">_cache.<span class="cm-variable">Set(<span class="cm-variable">key, <span class="cm-keyword">value, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30 <span class="cm-operator">+ <span class="cm-variable">randomOffset)); <span class="cm-comment">// 设置缓存，过期时间是30分钟加上偏移量<br><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓存预热（提前加载缓存）</span></strong><span class="md-plain">： 可以在系统流量较低时（例如凌晨）主动预加载缓存，将热点数据提前加载到缓存中，以避免高峰期大量请求直接访问数据库。</span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">void <span class="cm-variable">PreloadCache()<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">data <span class="cm-operator">= <span class="cm-variable">GetDataFromDatabase();<br><span> &nbsp; &nbsp;<span class="cm-variable">_cache.<span class="cm-variable">Set(<span class="cm-string">"some_key", <span class="cm-variable">data, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30)); &nbsp;<span class="cm-comment">// 预热缓存<br><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">使用滑动过期</span></strong><span class="md-plain">： 滑动过期是一种缓存过期策略，不是在固定时间点过期，而是根据缓存的访问时间来重新计算过期时间。例如，每次访问缓存时，过期时间会重新设置。</span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-variable">_cache.<span class="cm-variable">Set(<span class="cm-string">"some_key", <span class="cm-keyword">value, <span class="cm-keyword">new <span class="cm-variable">MemoryCacheEntryOptions<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-variable">SlidingExpiration <span class="cm-operator">= <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30) <span class="cm-comment">// 滑动过期<br><span>});</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
</ol>
<h2 class="md-end-block md-heading"><span class="md-plain">三、缓存击穿：避免热门数据失效时压力剧增</span></h2>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">什么是缓存击穿？</span></strong></span></h3>
<p class="md-end-block md-p"><span class="md-plain">缓存击穿是指某一热点数据的缓存失效，导致大量请求同时访问数据库。通常发生在某些热点数据（如用户信息、商品详情等）缓存过期时。如果没有有效的控制措施，所有请求都将同时查询数据库，给数据库带来巨大的压力。</span></p>
<h3 class="md-end-block md-heading"><span class="md-pair-s "><strong><span class="md-plain">解决方法：</span></strong></span></h3>
<ol class="ol-list">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">分布式锁机制</span></strong><span class="md-plain">： 使用分布式锁可以保证同一时刻只有一个请求能够查询数据库并更新缓存，其他请求则等待获取最新的缓存结果。这样可以避免多个请求同时查询数据库，造成数据库的压力。</span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">async <span class="cm-variable-3">Task<span class="cm-operator">&lt;<span class="cm-variable-3">string<span class="cm-operator">&gt; <span class="cm-def">GetDataWithLockAsync(<span class="cm-variable-3">string <span class="cm-variable">key)<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">lockKey <span class="cm-operator">= <span class="cm-variable">$<span class="cm-string">"{key}_lock";<br><span> &nbsp; &nbsp;<br><span> &nbsp; &nbsp;<span class="cm-comment">// 获取分布式锁，确保只有一个线程查询数据库<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">lockAcquired <span class="cm-operator">= <span class="cm-keyword">await <span class="cm-variable">_redisLock.<span class="cm-variable">TryAcquireLockAsync(<span class="cm-variable">lockKey, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromSeconds(<span class="cm-number">10));<br><span> &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-operator">!<span class="cm-variable">lockAcquired)<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 锁被其他请求持有，稍后重试<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable-3">Task.<span class="cm-variable">Delay(<span class="cm-number">1000);<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-keyword">await <span class="cm-variable">GetDataWithLockAsync(<span class="cm-variable">key);<br><span> &nbsp;  }<br><span> &nbsp; &nbsp;<br><span> &nbsp; &nbsp;<span class="cm-keyword">try<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 查询缓存<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">cachedResult <span class="cm-operator">= <span class="cm-keyword">await <span class="cm-variable">_cache.<span class="cm-variable">GetStringAsync(<span class="cm-variable">key);<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">cachedResult <span class="cm-operator">!= <span class="cm-atom">null)<br><span> &nbsp; &nbsp; &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">cachedResult;<br><span> &nbsp; &nbsp; &nbsp;  }<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 缓存没有，查询数据库<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">dbResult <span class="cm-operator">= <span class="cm-variable">GetDataFromDatabase(<span class="cm-variable">key);<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable">_cache.<span class="cm-variable">SetStringAsync(<span class="cm-variable">key, <span class="cm-variable">dbResult, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30));<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">dbResult;<br><span> &nbsp;  }<br><span> &nbsp; &nbsp;<span class="cm-keyword">finally<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 释放锁<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable">_redisLock.<span class="cm-variable">ReleaseLockAsync(<span class="cm-variable">lockKey);<br><span> &nbsp;  }<br><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">多级缓存：本地缓存与分布式缓存结合使用</span></strong><span class="md-plain"> 使用多级缓存策略，首先尝试从本地缓存（如 MemoryCache）获取数据，如果本地缓存中没有，再尝试从分布式缓存（如 Redis）获取，如果Redis中也没有，则最后查询数据库。通过这种方式，我们可以减轻数据库压力，提高缓存命中率。</span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">async <span class="cm-variable-3">Task<span class="cm-operator">&lt;<span class="cm-variable-3">string<span class="cm-operator">&gt; <span class="cm-def">GetDataWithMultiLevelCache(<span class="cm-variable-3">string <span class="cm-variable">key)<br><span>{<br><span> &nbsp; &nbsp;<span class="cm-comment">// 1. 从本地缓存中查找<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">localCache <span class="cm-operator">= <span class="cm-variable">_memoryCache.<span class="cm-variable">Get<span class="cm-operator">&lt;<span class="cm-variable-3">string<span class="cm-operator">&gt;(<span class="cm-variable">key);<br><span> &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">localCache <span class="cm-operator">!= <span class="cm-atom">null)<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">localCache;<br><span> &nbsp;  }<br><span> &nbsp; &nbsp;<br><span> &nbsp; &nbsp;<span class="cm-comment">// 2. 从分布式缓存（如 Redis）获取<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">distributedCache <span class="cm-operator">= <span class="cm-keyword">await <span class="cm-variable">_redisCache.<span class="cm-variable">GetStringAsync(<span class="cm-variable">key);<br><span> &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">distributedCache <span class="cm-operator">!= <span class="cm-atom">null)<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 设置本地缓存<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">_memoryCache.<span class="cm-variable">Set(<span class="cm-variable">key, <span class="cm-variable">distributedCache, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30));<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">distributedCache;<br><span> &nbsp;  }<br><span> &nbsp; &nbsp;<br><span> &nbsp; &nbsp;<span class="cm-comment">// 3. 从数据库获取<br><span> &nbsp; &nbsp;<span class="cm-keyword">var <span class="cm-def">dbResult <span class="cm-operator">= <span class="cm-variable">GetDataFromDatabase(<span class="cm-variable">key);<br><span> &nbsp; &nbsp;<span class="cm-keyword">if (<span class="cm-variable">dbResult <span class="cm-operator">!= <span class="cm-atom">null)<br><span> &nbsp;  {<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">_memoryCache.<span class="cm-variable">Set(<span class="cm-variable">key, <span class="cm-variable">dbResult, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30));<br><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">await <span class="cm-variable">_redisCache.<span class="cm-variable">SetStringAsync(<span class="cm-variable">key, <span class="cm-variable">dbResult, <span class="cm-variable-3">TimeSpan.<span class="cm-variable">FromMinutes(<span class="cm-number">30));<br><span> &nbsp;  }<br><span> &nbsp; &nbsp;<br><span> &nbsp; &nbsp;<span class="cm-keyword">return <span class="cm-variable">dbResult;<br><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</li>
</ol>
<h2 class="md-end-block md-heading"><span class="md-plain">四、总结</span></h2>
<p class="md-end-block md-p"><span class="md-plain">在.NET Core应用中，合理的缓存策略不仅能提升系统性能，还能有效减轻数据库的负载。面对缓存穿透、缓存雪崩和缓存击穿等问题，我们可以通过以下方式进行优化：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓存穿透</span></strong><span class="md-plain">：通过缓存空数据或校验请求参数，避免无效请求频繁访问数据库。</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓存雪崩</span></strong><span class="md-plain">：通过设置随机过期时间、缓存预热和滑动过期，避免大量数据同时失效。</span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong><span class="md-plain">缓存击穿</span></strong><span class="md-plain">：使用分布式锁确保只有一个请求能够查询数据库，并通过多级缓存策略提高缓存命中率。</span></span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain md-expand">通过这些策略的组合应用，可以有效地提高系统的稳定性和性能，从而减少对数据库的依赖，确保系统在高并发情况下的稳定运行。</span></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.017722336515046296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 10:28">2025-02-28 10:27</span>&nbsp;
<a href="https://www.cnblogs.com/forges">努力，努力再努力</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18742735" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18742735);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18742735', targetLink: 'https://www.cnblogs.com/forges/p/18742735', title: '如何在.NET Core中解决缓存穿透、缓存雪崩和缓存击穿问题：多级缓存策略详解' })">举报</a>
</div>
        