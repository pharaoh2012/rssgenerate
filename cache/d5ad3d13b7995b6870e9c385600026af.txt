
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cyyhcyyh/p/18688569" title="发布于 2025-01-23 19:54">
    <span role="heading" aria-level="2">线段树与矩阵</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="线段树">线段树</h1>
<h2 id="线段树的双半群模型">线段树的双半群模型</h2>
<p>线段树上每个节点都有 数据 与 标记 两种信息，称作 <span class="math inline">\(D\)</span> 与 <span class="math inline">\(T\)</span>。</p>
<ul>
<li>
<p>则需要存在 <span class="math inline">\(D*D=D^\prime\)</span> 的转移，即 数据合并。</p>
</li>
<li>
<p>以及 <span class="math inline">\(D*T=D^\prime\)</span>, 即 标记转移。</p>
</li>
<li>
<p>以及 <span class="math inline">\(T*T=T^{\prime}\)</span>, 即 标记合并。</p>
</li>
</ul>
<p>同时还需要满足 结合律 与 分配律，这是一个 半群，再存在一个单位元 <span class="math inline">\(\epsilon\)</span> ,使<span class="math inline">\(T*\epsilon=\epsilon*T=T\)</span> 则为 幺半群。则我们可以维护两个结构体，将三种转移加入即可。<br>
这里举个例子。<br>
区间加，区间乘，区间查询。则有<span class="math inline">\(D=\{l,s\}\)</span> , <span class="math inline">\(T=\{a,b\}\)</span> 。<br>
则有 <span class="math inline">\((l_1,s_1)*(l_2,s_2)=(l_1+l_2,s_1+s_2)\)</span>。<br>
以及 <span class="math inline">\((l,s)*(a,b)=(l,as+lb)\)</span>。<br>
以及 <span class="math inline">\((a_1,b_1)*(a_2,b_2)=(a_1a_2,b_1a_2+b_2)\)</span>。</p>
<p>显然，这些东西都是可以用矩阵维护的。</p>
<h2 id="矩阵乘法与线段树标记">矩阵乘法与线段树标记</h2>
<h3 id="区间加法线段树">区间加法线段树</h3>
<p>考虑每一个区间维护一个向量 <span class="math inline">\(\vec{a}:\)</span></p>
<p></p><div class="math display">\[\vec{a}=\begin{bmatrix}sum\\len\end{bmatrix}
\]</div><p></p><p>我们对于这个区间加上某一个数的操作可以看作左乘一个矩阵：</p>
<p></p><div class="math display">\[\begin{bmatrix}sum+c\times len\\len\end{bmatrix}=\begin{bmatrix}1&amp;c\\0&amp;1\end{bmatrix}\begin{bmatrix}sum\\len\end{bmatrix}
\]</div><p></p><p>此时，我们只需要维护左乘矩阵即可。</p>
<p>这里可以解释为什么只需要一个懒标记标记维护区间加信息。<br>
考虑到左乘的是一个上三角矩阵，而可以证明上三角乘上三角还是上三角，并且在这个情景中，只有右上角的位置数值会变化，于是只需要用一个标记维护右上角的值即可，也就是我们平时维护的那个懒标记。</p>
<h3 id="线段树历史版本和">线段树历史版本和</h3>
<p>假设只有区间加操作。<br>
每一个区间维护一个向量 <span class="math inline">\(\vec{a}:\)</span></p>
<p></p><div class="math display">\[\vec{a}=\begin{bmatrix}his\\sum\\len\end{bmatrix}
\]</div><p></p><p>其中 <span class="math inline">\(his\)</span> 表示历史版本和，<span class="math inline">\(sum\)</span> 表示当前区间和，<span class="math inline">\(len\)</span> 是区间长度。</p>
<p>对于区间加的操作左乘矩阵没有什么变化。</p>
<p>但是我们多了令 <span class="math inline">\(his\leftarrow his+sum\)</span> 的操作，考虑利用矩阵表示：</p>
<p></p><div class="math display">\[\begin{bmatrix}his+sum\\sum\\len\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}his\\sum\\len\end{bmatrix}
\]</div><p></p><p>还是维护左乘矩阵即可。</p>
<h3 id="线段树历史最值">线段树历史最值</h3>
<h4 id="广义矩阵">广义矩阵</h4>
<p>两个矩阵 <span class="math inline">\(A_{i, k}, B_{k, j}\)</span> 相乘得到 <span class="math inline">\(C_{i, j}\)</span> ，满足 <span class="math inline">\(C_{i, j}=\sum A_{i, k} B_{k, j}\)</span> 。<br>
而处理区间最值和历史最值时，常用广义矩乘，即 <span class="math inline">\(C_{i, j}=\max \left(A_{i, k}+B_{k, j}\right)\)</span> 。</p>
<p>这里，我们只要维护,<span class="math inline">\(+ \max\)</span> 两种运算，它们满足</p>
<ul>
<li>交换律：<span class="math inline">\(a+b=b+a, \max (a, b)=\max (b, a)\)</span> 。</li>
<li>结合律：<span class="math inline">\((a+b)+c=a+(b+c), \max (\max (a, b), c)=\max (a, \max (b, c))\)</span> 。</li>
<li>单位元：<span class="math inline">\(a+0=0+a=a, \max (a,-\infty)=\max (-\infty, a)=a\)</span> 。</li>
<li>加法逆元（相反数）：<span class="math inline">\(a+(-a)=(-a)+a=0\)</span> 。</li>
<li>分配律：<span class="math inline">\(a+\max (b, c)=\max (a+b, a+c), \max (a, b)+c=\max (a+c, b+c)\)</span> 。</li>
</ul>
<p>广义矩阵乘法显然具有结合律。</p>
<h4 id="区间历史最值维护">区间历史最值维护。</h4>
<p>考虑序列每一个数维护一个向量 <span class="math inline">\(\left[\begin{array}{l}a_i \\ b_i\end{array}\right], ~ a_i\)</span> 表示当前值，<span class="math inline">\(b_i\)</span> 表示历史最值，用线段树维护区间向量和 （即 <span class="math inline">\(a_i, b_i\)</span> 的最大值）。<br>
那么区间加 <span class="math inline">\(k\)</span> 可以看作 <span class="math inline">\(\left[\begin{array}{l}a \\ b\end{array}\right] \leftarrow\left[\begin{array}{c}a+k \\ \max \{b, a+k\}\end{array}\right]\)</span> ，可以很容易地构造广义矩阵乘法： <span class="math inline">\(\begin{bmatrix}
k &amp; -\infty \\
k &amp; 0
\end{bmatrix}
\begin{bmatrix}
a \\
b
\end{bmatrix}=\left[\begin{array}{c}a+k \\ \max \{b, a+k\}\end{array}\right]\)</span> ，故可以将懒标记设为 <span class="math inline">\(\begin{bmatrix}
k &amp; -\infty \\
k &amp; 0
\end{bmatrix}\)</span> 这个矩阵。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4314" target="_blank" rel="noopener nofollow">P4314 CPU 监控 - 洛谷 | 计算机科学教育新生态</a></p>
<p>本题需要支持区间赋值。（这个操作可以转化为区间加，就是即使线段树节点被区间完包，只要最大值不等于最小值，就递归下去，根据颜色段均雊理论，这部分的均摊时间复杂度为 <span class="math inline">\(O(n)\)</span> ）。<br>
可以给向量再加—维，使其变为 <span class="math inline">\(\left[\begin{array}{l}a \\ b \\ 0\end{array}\right]\)</span> ，这样就有 <span class="math inline">\(\left[\begin{array}{ccc}
-\infty &amp; -\infty &amp; k \\
-\infty &amp; 0 &amp; k \\
-\infty &amp; -\infty &amp; 0
\end{array}\right]\left[\begin{array}{l}
a \\
b \\
0
\end{array}\right]=\left[\begin{array}{c}
k \\
\max \{b, k\} \\
0
\end{array}\right]\)</span>。</p>
<h4 id="将矩阵转为标记">将矩阵转为标记</h4>
<p>在普通的历史最值维护中，我们可以注意到：</p>
<p><span class="math inline">\(\begin{bmatrix}a&amp;-\infty\\b&amp;0\end{bmatrix}+\begin{bmatrix}c&amp;-\infty\\d&amp;0\end{bmatrix}=\begin{bmatrix}\max(a,c)&amp;-\infty\\\max(b,d)&amp;0\end{bmatrix}\\\begin{bmatrix}a&amp;-\infty\\b&amp;0\end{bmatrix}\begin{bmatrix}c&amp;-\infty\\d&amp;0\end{bmatrix}=\begin{bmatrix}a+c&amp;-\infty\\\max(b+c,d)&amp;0\end{bmatrix}\)</span></p>
<p>左乘矩阵的第二列的值始终不变，只有第一列的值在变化，故维护矩阵第一列的值即可。</p>
<p>事实上，左乘矩阵第一列的两个值分别对应论文中的 “加减标记” 和 “历史最大加减标记”。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P6242" target="_blank" rel="noopener nofollow">P6242 【模板】线段树 3（区间最值操作、区间历史最值） - 洛谷 | 计算机科学教育新生态</a></p>
<p>先不考虑历史最值问题。</p>
<p>考虑到区间取 <span class="math inline">\(\min\)</span> 的操作只会对最大值不超过 <span class="math inline">\(k\)</span> 的节点产生影响，我们可以在这方面产生思路。为了使复杂度变对，线段树的一个节点要维护三个信息：区间最大值 <span class="math inline">\(mx\)</span>, 区间严格次大值 <span class="math inline">\(se\)</span> 和最大值的个数 <span class="math inline">\(cnt\)</span>。那么，一次区间最值操作作用在这个节点上时，可以被分为以下三种情况：</p>
<ul>
<li><span class="math inline">\(k\geq mx\)</span>, 此时该操作不会对当前节点产生影响，直接退出；</li>
<li><span class="math inline">\(se&lt;k&lt;mx\)</span>, 此时这个节点维护的区间中所有最大值都会被修改为<span class="math inline">\(k\)</span>,而最大值个数不变。将<br>
区间和加上 <span class="math inline">\(cnt\times (k-mx)\)</span> ,打上懒标记，然后退出即可；</li>
<li><span class="math inline">\(k\leq se\)</span>, 此时无法快速更新区间信息，因此我们需要继续递归到左右子树中，回溯时合并信息。</li>
</ul>
<p>原论文的证明告诉我们在没有修改操作时复杂度为 <span class="math inline">\(O(m\log n)\)</span> 的。</p>
<p>由于区间加减操作，某些节点的值域会增大。论文里给的时间复杂度是 <span class="math inline">\(O(m\log^2n)\)</span> 。而实际实现时会发现这个上界其实往往是跑不满的，速度几乎与大常数一个 <span class="math inline">\(\log\)</span> 接近。</p>
<p>此时，返回原题。我们将本题划分值域为最大值与非最大值，分别维护信息与 <span class="math inline">\(tag\)</span>。</p>
<p>此处的矩阵只能分别简化最大值与非最大值的历史最值变化过程。在广义矩阵下并不能直接维护 <span class="math inline">\(sum\)</span>，同时次大值以及最大值个数的记录也需要单独记录。本题更好的方法是直接用 <span class="math inline">\(tag\)</span> 转移（本人不会完全使用矩阵完成这道题）。</p>
<pre><code>const int N = 5e5 + 5;
struct SGT {
    ll sum;
    int maxa, maxb, cnt, se;
    int add1, add2, hadd1, hadd2; // 最大值/非最大值的标记 最大值/非最大值的历史最大标记
} tr[N &lt;&lt; 2];
#define ls (id &lt;&lt; 1)
#define rs (id &lt;&lt; 1 | 1)
#define mid (l + r &gt;&gt; 1)
il void pushup(int id) {
    tr[id].sum = tr[ls].sum + tr[rs].sum;
    tr[id].maxa = max(tr[ls].maxa, tr[rs].maxa);
    tr[id].maxb = max(tr[ls].maxb, tr[rs].maxb);
    if (tr[ls].maxa == tr[rs].maxa) {
        tr[id].se = max(tr[ls].se, tr[rs].se);
        tr[id].cnt = tr[ls].cnt + tr[rs].cnt;
    } else if (tr[ls].maxa &gt; tr[rs].maxa) {
        tr[id].se = max(tr[ls].se, tr[rs].maxa);
        tr[id].cnt = tr[ls].cnt;
    } else {
        tr[id].se = max(tr[ls].maxa, tr[rs].se);
        tr[id].cnt = tr[rs].cnt;
    }
}
void build(int l, int r, int id) {
    if (l == r) {
        int x; read(x); tr[id].add1 = tr[id].add2 = tr[id].hadd1 = tr[id].hadd2 = 0;
        return tr[id].sum = tr[id].maxa = tr[id].maxb = x, tr[id].se = -2e9, tr[id].cnt = 1, void();
    }
    build(l, mid, ls), build(mid + 1, r, rs);
    pushup(id);
}
il void work(int tag1, int tag2, int htag1, int htag2, int l, int r, int id) {
    tr[id].sum += 1ll * tag1 * tr[id].cnt + 1ll * tag2 * (r - l + 1 - tr[id].cnt);
    tr[id].maxb = max(tr[id].maxb, tr[id].maxa + htag1); tr[id].maxa += tag1; 
    if (tr[id].se != -2e9) tr[id].se += tag2;
    tr[id].hadd1 = max(tr[id].hadd1, tr[id].add1 + htag1);
    tr[id].hadd2 = max(tr[id].hadd2, tr[id].add2 + htag2);
    tr[id].add1 += tag1, tr[id].add2 += tag2;
}
il void pushdown(int l, int r, int id) {
    int mx = max(tr[ls].maxa, tr[rs].maxa);
    if (tr[ls].maxa == mx) work(tr[id].add1, tr[id].add2, tr[id].hadd1, tr[id].hadd2, l, mid, ls);
    else work(tr[id].add2, tr[id].add2, tr[id].hadd2, tr[id].hadd2, l, mid, ls);
    if (tr[rs].maxa == mx) work(tr[id].add1, tr[id].add2, tr[id].hadd1, tr[id].hadd2, mid + 1, r, rs);
    else work(tr[id].add2, tr[id].add2, tr[id].hadd2, tr[id].hadd2, mid + 1, r, rs);
    tr[id].add1 = tr[id].add2 = tr[id].hadd1 = tr[id].hadd2 = 0;
}
il void add(int l, int r, int x, int y, int k, int id) {
    if (l &gt; y || r &lt; x) return ;
    if (l &gt;= x &amp;&amp; r &lt;= y) {
        tr[id].sum += 1LL * k * (r - l + 1);
        tr[id].maxa += k; tr[id].maxb = max(tr[id].maxb, tr[id].maxa);
        if (tr[id].se != -2e9) tr[id].se += k;
        tr[id].add1 += k, tr[id].add2 += k;
        tr[id].hadd1 = max(tr[id].hadd1, tr[id].add1);
        tr[id].hadd2 = max(tr[id].hadd1, tr[id].add2);
        return ;
    }
    pushdown(l, r, id);
    add(l, mid, x, y, k, ls), add(mid + 1, r, x, y, k, rs);
    pushup(id);
}
il void mdf(int l, int r, int x, int y, int k, int id) {
    if (l &gt; y || r &lt; x || tr[id].maxa &lt;= k) return ;
    if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; tr[id].se &lt; k) {
        int t = tr[id].maxa - k;
        tr[id].sum -= 1LL * tr[id].cnt * t;
        tr[id].maxa = k, tr[id].add1 -= t;
        return ;
    }
    pushdown(l, r, id);
    mdf(l, mid, x, y, k, ls), mdf(mid + 1, r, x, y, k, rs);
    pushup(id);
}
il ll qry_sum(int l, int r, int x, int y, int id) {
    if (l &gt; y || r &lt; x) return 0;
    if (l &gt;= x &amp;&amp; r &lt;= y) return tr[id].sum;
    pushdown(l, r, id);
    return qry_sum(l, mid, x, y, ls) + qry_sum(mid + 1, r, x, y, rs);
}
il ll qry_a(int l, int r, int x, int y, int id) {
    if (l &gt; y || r &lt; x) return -2e9;
    if (l &gt;= x &amp;&amp; r &lt;= y) return tr[id].maxa;
    pushdown(l, r, id);
    return max(qry_a(l, mid, x, y, ls), qry_a(mid + 1, r, x, y, rs));
}
il ll qry_b(int l, int r, int x, int y, int id) {
    if (l &gt; y || r &lt; x) return -2e9;
    if (l &gt;= x &amp;&amp; r &lt;= y) return tr[id].maxb;
    pushdown(l, r, id);
    return max(qry_b(l, mid, x, y, ls), qry_b(mid + 1, r, x, y, rs));
}
int n, m;
signed main() {
    read(n, m);
    build(1, n, 1);
    while (m--) {
        int op, l, r, k;
        read(op, l, r);
        if (op == 1) read(k), add(1, n, l, r, k, 1);
        else if (op == 2) read(k), mdf(1, n, l, r, k, 1);
        else if (op == 3) write(qry_sum(1, n, l, r, 1)), ptc('\n');
        else if (op == 4) write(qry_a(1, n, l, r, 1)), ptc('\n');
        else if (op == 5) write(qry_b(1, n, l, r, 1)), ptc('\n');
    }
    return 0;
}
</code></pre>
<p>我始终认为这种题看代码是最好的理解方式。</p>
<h3 id="普通矩阵乘法与区间历史和">普通矩阵乘法与区间历史和</h3>
<p>例题：<a href="https://www.luogu.com.cn/problem/P8868" target="_blank" rel="noopener nofollow">P8868[NOIP2022] 比赛</a></p>
<p>我们离线所有询问，对右端点<span class="math inline">\(r\)</span>进行扫描线。</p>
<p>在扫描过程中，我们设 <span class="math inline">\(X_l\)</span> 和 <span class="math inline">\(Y_l\)</span> 分别表示 <span class="math inline">\(l,\ldots,r\)</span> 范围内 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_i\)</span> 的最大值。</p>
<p>我们可以在扫描的时候，对每个<span class="math inline">\(l\)</span>,维护</p>
<p></p><div class="math display">\[S_{l,r}=\sum_{r'=l}^rX_{l,r'}\times Y_{l,r'}.
\]</div><p></p><p>这样的话，我们要查询的就是 <span class="math inline">\(l\sim r\)</span> 的区间 <span class="math inline">\(S\)</span> 和。</p>
<p>而我们的操作则是区间 <span class="math inline">\(X\)</span> 修改 (覆盖),区间 <span class="math inline">\(Y\)</span> 修改 (覆盖), 以及 <span class="math inline">\(S\leftarrow S+X\times Y\)</span>。</p>
<p>至此，本题转为了区间覆盖，区间历史和问题。</p>
<p>维护向量：</p>
<p></p><div class="math display">\[\vec{a}=\begin{bmatrix}his\\ab\\a\\b\\len\end{bmatrix}
\]</div><p></p><p>其中 <span class="math inline">\(his\)</span> 表示历史版本和，<span class="math inline">\(ab\)</span> 表示 <span class="math inline">\((\sum A_i)\times(\sum B_i)\)</span>, <span class="math inline">\(a,b\)</span> 分别表示 <span class="math inline">\(\sum A_i,\sum B_i\)</span>。<br>
于是，对于 <span class="math inline">\(A\)</span> 的区间加操作可以表示为：</p>
<p></p><div class="math display">\[\begin{bmatrix}his\\ab+x\times b\\a+x\times len\\b\\len\end{bmatrix}=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;x&amp;0\\0&amp;0&amp;1&amp;0&amp;x\\0&amp;0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}his\\ab\\a\\b\\len\end{bmatrix}
\]</div><p></p><p>对 <span class="math inline">\(B\)</span> 的操作同理。</p>
<p>刷新历史和的操作可以表示为：</p>
<p></p><div class="math display">\[\begin{bmatrix}his+ab\\ab\\a\\b\\len\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}his\\ab\\a\\b\\len\end{bmatrix}
\]</div><p></p><p>维护左乘矩阵即可。复杂度 <span class="math inline">\(O(k^3n\log n)\)</span>，可以获得 <span class="math inline">\(76\)</span> 分。在卡常和乘法展开后也许可以获得满分。</p>
<h3 id="优化标记常数">优化标记常数</h3>
<p>就像前面提到的，矩阵中总有很多信息始终不变，那么这些信息理论是不必要记录的。</p>
<p>我们以如下乘法为例：</p>
<p></p><div class="math display">\[\begin{bmatrix}his+sum\\sum\\len\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}his\\sum\\len\end{bmatrix}
\]</div><p></p><p>操作的矩阵有两种：</p>
<p></p><div class="math display">\[\begin{bmatrix}1&amp;1&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix},\begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;x\\0&amp;0&amp;1\end{bmatrix}
\]</div><p></p><p>也就意味着我们只需要关注形如：</p>
<p></p><div class="math display">\[\begin{bmatrix}1&amp;a&amp;0\\0&amp;1&amp;b\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;c&amp;0\\0&amp;1&amp;d\\0&amp;0&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;c+a&amp;ad\\0&amp;1&amp;b+b\\0&amp;0&amp;1\end{bmatrix}
\]</div><p></p><p>于是意味着我们只需要维护右上角的三个位置，每次按照上式直接修改即可，这样常数大大减少，与维护一堆tag的常数一致了。</p>
<p>然而发现事实上右上角都会有值，于是重新修正：</p>
<p></p><div class="math display">\[\begin{bmatrix}1&amp;a&amp;b\\0&amp;1&amp;c\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;d&amp;e\\0&amp;1&amp;f\\0&amp;0&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;a+d&amp;e+af+b\\0&amp;1&amp;c+f\\0&amp;0&amp;1\end{bmatrix}
\]</div><p></p><p>这意味着我们只需要维护右上角的三个位置，每次按照上式直接修改即可，这样常数大大减少。</p>
<p>同理，对于<a href="https://www.luogu.com.cn/problem/P8868" target="_blank" rel="noopener nofollow">P8868[NOIP2022] 比赛</a>，发现有用的位置只有 <span class="math inline">\(9\)</span> 个，维护这 <span class="math inline">\(9\)</span> 个位置即可。</p>
<p>如果不好观察，不妨给矩阵随机赋值，打表出不变的位置即可。</p>
<h4 id="关于向量构造的一些小技巧">关于向量构造的一些小技巧</h4>
<p>一般来说，我们需要构造出来的向量，对于每一个操作都应该是一个上/下三角矩阵的形式，这样更加方便我们观察，理解，优化。<br>
而如果要成为一个上三角，就意味着对于 <span class="math inline">\(\vec{a}_i\)</span> 只会由 <span class="math inline">\(j&gt;i,\vec{a}_j\)</span> 转移而来。<br>
于是一般来说，会将不变的长度放在最下面，将历史版本信息放在最上面，一般的信息则放在中间。</p>
<h3 id="结语">结语</h3>
<p>本文大部分为优质博客的誊抄。</p>
<p><a href="https://www.luogu.com/article/yk7nrae0" target="_blank" rel="noopener nofollow">浅谈矩阵乘法维护线段树标记的技巧 - 洛谷专栏</a></p>
<p><a href="https://www.cnblogs.com/jeefy/p/17807239.html" target="_blank">算法学习笔记(34): 矩阵乘法与线段树标记 - jeefy - 博客园</a></p>
<p><a href="https://www.luogu.com.cn/article/tafs5gxk" target="_blank" rel="noopener nofollow">区间历史操作，从矩阵乘法到标记 - 洛谷专栏</a></p>
<p><a href="https://www.cnblogs.com/HaoXu-qwq/p/18317214/segment-tree-advanced" target="_blank">线段树进阶笔记 - oXUo - 博客园</a></p>
<p><a href="https://www.luogu.com.cn/article/rr574zx9" target="_blank" rel="noopener nofollow">[NOIP 2022] T4 比赛 题解</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1748909370138889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 20:12">2025-01-23 19:54</span>&nbsp;
<a href="https://www.cnblogs.com/cyyhcyyh">Zelotz</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688569" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688569);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688569', targetLink: 'https://www.cnblogs.com/cyyhcyyh/p/18688569', title: '线段树与矩阵' })">举报</a>
</div>
        