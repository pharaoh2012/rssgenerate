
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18715203" title="发布于 2025-02-14 17:04">
    <span role="heading" aria-level="2">分合之道：最小生成树的 Kruskal 与 Prim 算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="最小生成树问题">最小生成树问题</h2>
<p>想象你是一位城市规划师，面前摊开一张地图，标记着散落的村庄。你的任务是用最经济的成本，在村庄间铺设道路，让所有村庄互通。这个问题看似简单，却隐藏着一个经典的数学命题：<strong>如何在一张“带权图”中，找到一棵总权重最小的树，连接所有节点？</strong></p>
<p><strong>数学定义</strong><br>
给定一个<strong>连通无向图</strong> <span class="math inline">\(G=(V,E)\)</span>，其中每条边 <span class="math inline">\(e \in E\)</span> 有一个权重 <span class="math inline">\(w(e)\)</span>，最小生成树（MST）的目标是选择一个边集 <span class="math inline">\(T \subseteq E\)</span>，满足：</p>
<ol>
<li><strong>连通性</strong>：<span class="math inline">\(T\)</span> 连接所有顶点，形成一棵树（无环且覆盖全部 <span class="math inline">\(|V|\)</span> 个顶点）；</li>
<li><strong>最小总权</strong>：边集的总权重最小。</li>
</ol>
<p>公式化表达为：</p>
<p></p><div class="math display">\[T = \arg\min_{T' \subseteq E} \left\{ \sum_{e \in T'} w(e) \ \bigg| \ \text{$T'$ 是树且覆盖所有顶点} \right\} 
\]</div><p></p><p>你可以将 MST 想象成一张“最优化的网”：</p>
<ul>
<li><strong>节点</strong>是村庄，<strong>边</strong>是可能的道路，<strong>权重</strong>是修路成本。</li>
<li>MST 要求用最少的“钢筋水泥”铺就一张四通八达的路网，<strong>避免环路</strong>（否则浪费资源），<strong>覆盖所有村庄</strong>（否则有人被孤立）。</li>
</ul>
<p><strong>实际场景</strong><br>
最小生成树渗透在生活方方面面的“无形之网”中：</p>
<ul>
<li><strong>通信基站</strong>：用最低成本铺设光纤，覆盖所有信号塔；</li>
<li><strong>电路设计</strong>：用最短导线连接芯片引脚，避免短路；</li>
<li><strong>物流规划</strong>：构建仓库间的高效运输链路，减少冗余路径。</li>
</ul>
<h2 id="kruskal-算法条条大路通罗马">Kruskal 算法：条条大路通罗马</h2>
<p>假设你面前有一群互不相识的村民（节点），他们需要通过道路（边）连接成一个整体。每条道路的修建成本（边权）不同。Kruskal 算法的策略是贪心选取，既然要总道路最便宜，那么就每次让最便宜的边优先获得修建权，但必须遵守一条铁律：<strong>绝不允许形成闭环</strong>，不可以连接已经相连的点。</p>
<p>具体来说，Kruskal 算法的步骤如下：</p>
<ol>
<li><strong>全边排序</strong>：将所有边按权重升序排列，形成候选队列。</li>
<li><strong>逐轮选择</strong>：从最小的边开始，依次检查每条边：
<ul>
<li>若这条边连接的是两个尚未连通的村庄（即加入后不形成环），则采纳它；</li>
<li>若这条边会让两个已连通的村庄形成冗余环路，则淘汰它。</li>
</ul>
</li>
<li><strong>终局条件</strong>：树的边数总是比比点数少 1，所以当选中 <span class="math inline">\(|V|-1\)</span> 条边时，所有村庄连通，选举结束。</li>
</ol>
<h3 id="正确性">正确性</h3>
<p>Kruskal 的贪心策略看似简单，但为何正确？关键在于<strong>“安全边定理”</strong>：</p>
<blockquote>
<p><strong>定理</strong>：若边 <span class="math inline">\(e\)</span> 是当前未被选中的最小权重边，且连接两个不同的连通分量，则 <span class="math inline">\(e\)</span> 必定属于某个最小生成树。</p>
</blockquote>
<p>用微扰法的思路反证，假设存在一个不包含 <span class="math inline">\(e\)</span> 的 MST <span class="math inline">\(T\)</span>。将 <span class="math inline">\(e\)</span> 加入 <span class="math inline">\(T\)</span> 会形成一个环，此时环中必然存在另一条边 <span class="math inline">\(e'\)</span> 权重大于等于 <span class="math inline">\(e\)</span>（因为 <span class="math inline">\(e\)</span> 是当前最小）。用 <span class="math inline">\(e\)</span> 替换 <span class="math inline">\(e'\)</span> 可得到总权更小或相等的树，矛盾。因此 <span class="math inline">\(e\)</span> 必须属于某个 MST，我们一定会选择它。</p>
<p><strong>归纳法视角</strong>：</p>
<ul>
<li><strong>初始状态</strong>：所有节点独立，属于不同的连通分量。</li>
<li><strong>归纳假设</strong>：已选的边集 <span class="math inline">\(T_k\)</span> 是某个 MST 的子集。</li>
<li><strong>归纳步骤</strong>：选择下一条最小边 <span class="math inline">\(e\)</span>，若它连接两个不同分量，则必属于该 MST。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250214170353349-690976935.png" alt="image" loading="lazy"></p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>Kruskal 的效率取决于两大操作：</p>
<ol>
<li><strong>排序边</strong>：<span class="math inline">\(O(|E| \log |E|)\)</span></li>
<li><strong>并查集操作（查询节点是否已经连接）</strong>：
<ul>
<li><code>find</code> 和 <code>union</code> 的单次操作近乎常数时间（<span class="math inline">\(O(\alpha(|V|))\)</span>，<span class="math inline">\(\alpha\)</span>为反阿克曼函数）。</li>
<li>总操作次数为 <span class="math inline">\(O(|E|)\)</span>，因此并查集的总成本为 <span class="math inline">\(O(|E| \cdot \alpha(|V|))\)</span>，低于排序开销。</li>
</ul>
</li>
</ol>
<p><strong>复杂度总结</strong>：<span class="math inline">\(O(|E| \log |E|)\)</span>，性能瓶颈在于排序。</p>
<hr>
<h3 id="实例演示">实例演示</h3>
<p>假设有 4 个村庄（A, B, C, D），边权如下：</p>
<ul>
<li>AB: 1, AC: 3, AD: 4</li>
<li>BC: 2, BD: 5, CD: 6</li>
</ul>
<p><strong>执行流程</strong>：</p>
<ol>
<li><strong>排序边</strong>：AB(1) → BC(2) → AC(3) → AD(4) → BD(5) → CD(6)</li>
<li><strong>依次选择</strong>：
<ul>
<li>选AB（连通{A,B}，剩余需选3条边）</li>
<li>选BC（连通{A,B,C}，剩余需选2条）</li>
<li>跳过AC（A和C已连通，形成环）</li>
<li>选AD（连通{A,B,C,D}，任务完成）</li>
</ul>
</li>
</ol>
<p>最终 MST 总权重：1 + 2 + 4 = 7</p>
<pre><code class="language-cpp">// 参考题目：https://judge.yosupo.jp/problem/minimum_spanning_tree，为稀疏图

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
using namespace std;

class Graph {
    struct Edge {
        int u, v, w, i;
        bool operator&lt;(const Edge&amp; other) const {
            return w &lt; other.w;
        }
    };

    vector&lt;Edge&gt; edges;
    int n, m;

public:
    void addEdge(int u, int v, int w, int i) {
        edges.push_back({u, v, w, i});
    }

    Graph(int n, int m) : n(n), m(m), edges(m) {} // 构造函数，本题编号从 0 开始

    long long kruskal(vector&lt;int&gt;&amp; ans) {
        sort(edges.begin(), edges.end());
        ufs uf(n); // 并查集实现略
        long long mst_weight = 0;
        for (const auto&amp; edge : edges) {
            if (!uf.get(edge.u, edge.v)) {
                uf.set(edge.u, edge.v);
                mst_weight += edge.w;
                ans.push_back(edge.i);
            }
        }

        // 若 ans 里的边数不为 n - 1，则说明图不连通，略
        return mst_weight;
    }
};
</code></pre>
<h2 id="prim-算法以点破面聚沙成塔">Prim 算法：以点破面，聚沙成塔</h2>
<p>想象你是一位部落首领，想要以最少的资源统一整片大陆。你的策略不是四处开花，而是<strong>从一座核心城池出发，步步为营，将最近的未征服领土纳入版图</strong>。Prim 算法正是这种“中心化扩张”的数学映射——<strong>以点为锚，逐步吞噬最小代价的边疆</strong>。其关注点而不是边，和 Dijkstra 很相似。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>选定起点</strong>：任选一个节点作为初始据点占领（如村庄A），作为最小生成树中的第一个点。</li>
<li><strong>维护优先队列</strong>：记录当前“已占领区域”与“未占领区域”之间的所有边（称为<strong>前沿边</strong>），并始终选择其中权重最小的边。</li>
<li><strong>扩张领土</strong>：将这条最小边连接的未占领节点纳入版图，并更新前沿边集合。</li>
<li><strong>循环直至统一</strong>：重复直到所有节点被占领（选出 <span class="math inline">\(|V|-1\)</span> 条边）。</li>
</ol>
<h3 id="正确性证明">正确性证明</h3>
<p>Prim 的正确性依赖于<strong>“切割性质”</strong>：</p>
<blockquote>
<p><strong>定理</strong>：对于图的任意一个切割（将顶点分为两个集合 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(V-S\)</span>），若边 <span class="math inline">\(e\)</span> 是横跨该切割的最小权重边，则 <span class="math inline">\(e\)</span> 属于某个最小生成树。</p>
</blockquote>
<p>假设存在一个不包含 <span class="math inline">\(e\)</span> 的 MST <span class="math inline">\(T\)</span>。将 <span class="math inline">\(e\)</span> 加入 <span class="math inline">\(T\)</span> 会形成一个环，环中必有一条边 <span class="math inline">\(e'\)</span> 横跨同一切割且权重大于等于 <span class="math inline">\(e\)</span>。用 <span class="math inline">\(e\)</span> 替换 <span class="math inline">\(e'\)</span> 可得到总权更小或相等的树，矛盾。因此 <span class="math inline">\(e\)</span> 必须属于 MST。</p>
<p><strong>归纳法视角</strong>：</p>
<ul>
<li><strong>初始状态</strong>：集合 <span class="math inline">\(S\)</span> 仅包含起点，此时所有连接 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(V-S\)</span> 的边构成前沿边。</li>
<li><strong>归纳假设</strong>：已选的边集 <span class="math inline">\(T_k\)</span> 是某个 MST 的子集，且 <span class="math inline">\(S\)</span> 是连通子图。</li>
<li><strong>归纳步骤</strong>：选择最小前沿边 <span class="math inline">\(e\)</span>，将其加入 <span class="math inline">\(T_k\)</span>，扩展 <span class="math inline">\(S\)</span>，保证 <span class="math inline">\(T_{k+1}\)</span> 仍属于 MST。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250214170412887-1737735345.png" alt="image" loading="lazy"></p>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p>Prim 的性能因实现方式差异悬殊，其关键在于如何维护当前“未选择节点”到“已选择节点”的距离，并从中选出最小值。</p>
<ul>
<li>
<p><strong>二叉堆维护</strong>：</p>
<ul>
<li>这是最常见的做法，使用优先队列维护前沿边，每次提取最小值 <span class="math inline">\(O(\log |V|)\)</span>。</li>
<li>总操作次数 <span class="math inline">\(O(|E| \log |V|)\)</span>，适合<strong>稀疏图</strong>。</li>
</ul>
</li>
<li>
<p><strong>暴力实现（邻接矩阵）</strong>：</p>
<ul>
<li>每次遍历所有点，选择应该加入的点，时间复杂度 <span class="math inline">\(O(|V|^2)\)</span>。</li>
<li>这反而适合<strong>稠密图</strong>（如完全图），此时 <span class="math inline">\(|E| \approx |V|^2\)</span>，复杂度与 Kruskal 的 <span class="math inline">\(O(|E| \log |E|)\)</span> 相当。</li>
</ul>
</li>
<li>
<p><strong>斐波那契堆维护</strong>：</p>
<ul>
<li>已经在堆内的节点，其距离值还可能降低。二叉堆无法直接实现降低一个堆内元素，只能让一个点多次入队并仅处理第一次；但斐波那契堆可以均摊 $O(1) $ 实现。</li>
<li>降低了优先级更新的成本，复杂度 <span class="math inline">\(O(|E| + |V| \log |V|)\)</span>。</li>
<li>这是 Prim 的理论最优实现，但常数较大，且斐波那契堆的实现较难，实际应用较少。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">// 二叉堆版本

class Graph {
    struct Edge {
        int to, weight, index;
        Edge(int t, int w, int i) : to(t), weight(w), index(i) {}
        bool operator&lt;(const Edge&amp; other) const {
            return weight &gt; other.weight; // 优先队列是最大堆
        }
    };
    vector&lt;vector&lt;Edge&gt;&gt; adj; // 邻接表
    int n;
public:
    Graph(int n) : n(n), adj(n) {}

    void addEdge(int u, int v, int w, int i) {
        adj[u].emplace_back(v, w, i);
        adj[v].emplace_back(u, w, i); 
    }

    long long prim(vector&lt;int&gt;&amp; ans) {
        vector&lt;bool&gt; inMST(n, false);
        priority_queue&lt;Edge&gt; pq;
        long long mst_weight = 0;
        pq.emplace(0, 0, -1); // 从任意节点（此处选择 0）开始
        while (!pq.empty()) {
            Edge edge = pq.top(); pq.pop();
            
            int v = edge.to;
            if (inMST[v]) continue; // 如果节点已经在生成树中，跳过
            inMST[v] = true;
            mst_weight += edge.weight;
            if (edge.index != -1) ans.push_back(edge.index); // 跳过虚拟的起始边
            for (const Edge&amp; e : adj[v]) {
                if (!inMST[e.to]) {
                    pq.emplace(e.to, e.weight, e.index);
                }
            }
        }
        return mst_weight;
    }
};

</code></pre>
<h3 id="实例演示-1">实例演示</h3>
<p>沿用 Kruskal 的例子：4 个村庄（A, B, C, D），边权如下：</p>
<ul>
<li>AB: 1, AC: 3, AD: 4</li>
<li>BC: 2, BD: 5, CD: 6</li>
</ul>
<p><strong>从A出发的执行流程</strong>：</p>
<ol>
<li><strong>初始前沿边</strong>：AB(1), AC(3), AD(4)
<ul>
<li>选AB(1)，占领B，前沿边更新为：AC(3), AD(4), BC(2), BD(5)</li>
</ul>
</li>
<li><strong>当前前沿边</strong>：AC(3), AD(4), BC(2), BD(5)
<ul>
<li>选BC(2)，占领C，前沿边更新为：AC(3), AD(4), BD(5), CD(6)</li>
</ul>
</li>
<li><strong>当前前沿边</strong>：AC(3), AD(4), BD(5), CD(6)
<ul>
<li>选AD(4)，占领D，任务完成</li>
</ul>
</li>
</ol>
<p>最终 MST 总权重：1 + 2 + 4 = 7（与 Kruskal 结果一致）</p>
<h2 id="kruskal-与-prim-的对决">Kruskal 与 Prim 的对决</h2>
<ul>
<li>
<p><strong>Kruskal</strong>：</p>
<ul>
<li>关注边的选择</li>
<li>所有边按权排序，通过并查集动态维护连通性，像一场自下而上的“边缘力量联合”。</li>
<li>若图中存在大量高权冗余边（如完全图），排序开销可能拖累全局效率。</li>
</ul>
</li>
<li>
<p><strong>Prim</strong>：</p>
<ul>
<li>关注点的选择</li>
<li>以核心据点为中心，逐步将点加入生成树。通过优先队列维护扩张前沿，像一支训练有素的军队攻城略地。</li>
<li>若图结构松散（如稀疏图），频繁的优先队列更新可能得不偿失。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>实战性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th>**Kruskal **</th>
<th>**Prim **</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>稀疏图</strong></td>
<td>✅ 稳赢（ <span class="math inline">\(|E| \approx |V|\)</span> ）</td>
<td>❌ 二叉堆实现勉强一战</td>
</tr>
<tr>
<td><strong>稠密图</strong></td>
<td>❌ 排序成本过高</td>
<td>✅ 暴力实现碾压（<span class="math inline">\(O(|V|^2)\)</span>）</td>
</tr>
<tr>
<td><strong>动态增边</strong></td>
<td>✅ 天然支持</td>
<td>❌ 需重新计算</td>
</tr>
<tr>
<td><strong>分布式计算</strong></td>
<td>✅ 边排序可并行</td>
<td>❌ 强依赖全局状态</td>
</tr>
</tbody>
</table>
<p><strong>选择指南</strong></p>
<ol>
<li><strong>“边多选 Prim，边少选 Kruskal”</strong>：
<ul>
<li>若 <span class="math inline">\(|E| \gg |V|\)</span>（如完全图），Prim 的暴力实现更优；</li>
<li>若 <span class="math inline">\(|E| \ll |V|^2\)</span>（如树状图），Kruskal 的排序+并查集组合更高效。</li>
</ul>
</li>
<li><strong>“动态变化选 Kruskal，静态结构选 Prim”</strong>：
<ul>
<li>需要动态增删边？Kruskal 天然支持；</li>
<li>图结构固定且需频繁求解？Prim 可预处理邻接矩阵。</li>
</ul>
</li>
<li><strong>“若要分布式，Kruskal 是唯一解”</strong>：
<ul>
<li>MapReduce 处理超大规模图时，Kruskal 的边排序和并查集更易并行化。</li>
</ul>
</li>
</ol>
<p>尽管路径迥异，Kruskal 与 Prim 最终都收敛于同一个最小总权值——这印证了数学的确定性之美。它们都在贪心策略的框架下，以局部最优逼近全局最优，正是算法设计中最深邃的智慧。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04546257776388889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 17:10">2025-02-14 17:04</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18715203" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18715203);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18715203', targetLink: 'https://www.cnblogs.com/ofnoname/p/18715203', title: '分合之道：最小生成树的 Kruskal 与 Prim 算法' })">举报</a>
</div>
        