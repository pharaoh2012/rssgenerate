
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/18951127" title="发布于 2025-06-26 23:14">
    <span role="heading" aria-level="2">Golang基础笔记五之结构体</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/THUKrpWB9hN8BXT003SOWw" target="_blank" rel="noopener nofollow">Golang基础笔记五之结构体</a></p>
</blockquote>
<p>本篇笔记介绍 Golang 中的结构体。</p>
<p>在 Go 中，结构体是一种用户自定义的数据类型，可以将不同类型的数据组合在一起。</p>
<p>以下是本篇笔记目录：</p>
<ol>
<li>结构体的定义和使用</li>
<li>嵌套结构体</li>
<li>创建结构体递归结构</li>
<li>结构体标签</li>
</ol>
<h3 id="1结构体的定义和使用">1、结构体的定义和使用</h3>
<p>结构体定义的基本语法如下：</p>
<pre><code class="language-go">type 结构体名称 struct{
&nbsp; &nbsp; field1 type
&nbsp; &nbsp; field2 type
}
</code></pre>
<p>我们可以先创建一个 struct：</p>
<pre><code class="language-go">type Person struct {
&nbsp; &nbsp; Name string
&nbsp; &nbsp; Age &nbsp;int
}
</code></pre>
<p>下面介绍几种方式来实例化结构体：</p>
<h4 id="1-使用结构体字面量初始化">1. 使用结构体字面量初始化</h4>
<p>使用结构体字面量初始化结构体变量，在创建结构体变量时，将字段值直接赋给结构体的字段。</p>
<p>其语法如下：</p>
<pre><code class="language-go">person := Person{Name: "Alice", Age: 30}
fmt.Println(person)
</code></pre>
<p>在这里，如果有字段没有赋值，那么这个字段的值就是该类型的零值。</p>
<h4 id="2-按字段顺序初始化">2. 按字段顺序初始化</h4>
<p>我们可以在初始化的时候不指定字段，那么它会按照结构体中的字段顺序进行赋值：</p>
<pre><code class="language-go">person := Person{"Alice", 30}
fmt.Println(person)
</code></pre>
<p>但是这个操作有个问题，就是结构体中的全部字段都需要赋值。</p>
<h4 id="3-使用-new-函数创建结构体指针">3. 使用 new 函数创建结构体指针</h4>
<p>可以使用 new() 函数创建一个结构体，但是注意，其返回值是对应结构体的指针：</p>
<pre><code class="language-go">var person *Person = new(Person)
person.Age = 1
person.Name = "Hunter"
</code></pre>
<h3 id="2嵌套结构体">2、嵌套结构体</h3>
<p>结构体可以嵌套在另一个结构体里，这个就是嵌套结构体。</p>
<h4 id="1-匿名嵌套">1. 匿名嵌套</h4>
<p>在嵌套的时候如果直接嵌套不指定字段名，这个就叫匿名嵌套，比如下面的示例：</p>
<pre><code class="language-go">type Address struct {
&nbsp; &nbsp; City string
}
type Person struct {
&nbsp; &nbsp; Name string
&nbsp; &nbsp; Age &nbsp;int
&nbsp; &nbsp; Address
}
</code></pre>
<p>这里没有给 Address 指定字段名，所以这个 Address 就是一个匿名字段。</p>
<p>以下是一个初始化的例子：</p>
<pre><code class="language-go">person := Person{
&nbsp; &nbsp; Name: "Hunter",
&nbsp; &nbsp; Age: &nbsp;18,
&nbsp; &nbsp; Address: Address{
&nbsp; &nbsp; &nbsp; &nbsp; City: "Beijing",
&nbsp; &nbsp; },
}
</code></pre>
<p>使用匿名嵌套，我们可以直接访问到嵌套的结构体的字段：</p>
<pre><code class="language-go">fmt.Println(person.City)
</code></pre>
<p>这里 City 是 Addree 结构体的字段，但因为是匿名嵌套，所以可以直接访问到。</p>
<p>当然，也可以通过 Address 结构体进行访问：</p>
<pre><code class="language-go">fmt.Println(person.Address.City)
</code></pre>
<h4 id="2-具名嵌套">2. 具名嵌套</h4>
<p>如果嵌套的时候显式指定字段名，就叫具名嵌套，比如：</p>
<pre><code class="language-go">type Company struct {
&nbsp; &nbsp; CompanyName string
}
type Person struct {
&nbsp; &nbsp; Name string
&nbsp; &nbsp; Age &nbsp;int
&nbsp; &nbsp; CompanyInfo Company
}
</code></pre>
<p>这里为了以示区分，给 Company 结构体的字段名设为 CompanyInfo，其初始化的方式还是类似的：</p>
<pre><code class="language-go">person := Person{
&nbsp; &nbsp; Name: "Hunter",
&nbsp; &nbsp; Age: &nbsp;18,
&nbsp; &nbsp; CompanyInfo: Company{
&nbsp; &nbsp; &nbsp; &nbsp; CompanyName: "ACompany",
&nbsp; &nbsp; },
}
</code></pre>
<p>而如果要访问到嵌套的结构体的字段，则需要通过 CompanyInfo 进行访问：</p>
<pre><code class="language-go">fmt.Println(person.CompanyInfo.CompanyName)
</code></pre>
<h3 id="3创建结构体递归结构">3、创建结构体递归结构</h3>
<p>我们可以通过结构体嵌套自己来形成递归结构，但是嵌套的类型需要是自身结构体的指针。</p>
<p>下面介绍一下使用结构体来创建链表和二叉树。</p>
<h4 id="1-链表">1. 链表</h4>
<p>链表的结构体如下：</p>
<pre><code class="language-go">type ListNode struct {
&nbsp; &nbsp; Val &nbsp;int
&nbsp; &nbsp; Next *ListNode
}
</code></pre>
<p>接下来创建一个链表，并打印节点内容：</p>
<pre><code class="language-go">head := &amp;ListNode{Val: 1}
node2 := &amp;ListNode{Val: 2}
node3 := &amp;ListNode{Val: 3}
head.Next = node2
node2.Next = node3
node := head
for {
&nbsp; &nbsp; if node == nil {
&nbsp; &nbsp; &nbsp; &nbsp; break
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; fmt.Println(node.Val)
&nbsp; &nbsp; &nbsp; &nbsp; node = node.Next
&nbsp; &nbsp; }
}
</code></pre>
<h4 id="2-二叉树">2. 二叉树</h4>
<p>以下是二叉树的结构体：</p>
<pre><code class="language-go">type TreeNode struct {
&nbsp; &nbsp; Val &nbsp; int
&nbsp; &nbsp; Left &nbsp;*TreeNode
&nbsp; &nbsp; Right *TreeNode
}
</code></pre>
<p>接下来创建一个二叉树，并用前序遍历打印二叉树节点：</p>
<pre><code class="language-go">func preorderTraversal(root *TreeNode) {
&nbsp; &nbsp; if root == nil {
&nbsp; &nbsp; &nbsp; &nbsp; return
&nbsp; &nbsp; }
&nbsp; &nbsp; fmt.Println(root.Val)
&nbsp; &nbsp; if root.Left != nil {
&nbsp; &nbsp; &nbsp; &nbsp; preorderTraversal(root.Left)
&nbsp; &nbsp; }
&nbsp; &nbsp; if root.Right != nil {
&nbsp; &nbsp; &nbsp; &nbsp; preorderTraversal(root.Right)
&nbsp; &nbsp; }
}
root := &amp;TreeNode{Val: 1}
root.Left = &amp;TreeNode{Val: 2}
root.Right = &amp;TreeNode{Val: 3}
root.Left.Left = &amp;TreeNode{Val: 4}
root.Left.Right = &amp;TreeNode{Val: 5}
preorderTraversal(root)
</code></pre>
<h3 id="4结构体标签">4、结构体标签</h3>
<p>结构体标签是附加在结构体字段后的元数据字符串，可以用于 json 序列化和反序列化、Web 框架表单数据绑定、数据库 ORM 映射等。</p>
<p>下面介绍一下 json 标签的使用。</p>
<h4 id="json-标签">json 标签</h4>
<p>json 标签用于 JSON 的序列化和反序列化，有以下几个功能：</p>
<ol>
<li>字段映射：json:"field_name" 指定 JSON 字段名，如果不设置，默认为 struct 的字段名</li>
<li>忽略字段：json:"-" 表示该字段不参与序列化</li>
<li>忽略空值：json:"omitempty" 表示如果字段值为零值时，则不参与序列化</li>
<li>类型转换：json:"field_name,string", 表示将数值转换为字符串类型</li>
</ol>
<p>下面是一个结构体示例：</p>
<pre><code class="language-go">type Person struct {
&nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp;string `json:"name"`
&nbsp; &nbsp; Age &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;`json:"age,omitempty,string"`
&nbsp; &nbsp; Gender &nbsp; &nbsp; &nbsp;string `json:""`
&nbsp; &nbsp; Address &nbsp; &nbsp; string `json:"address"`
&nbsp; &nbsp; NoJsonField string `json:"-"`
}
</code></pre>
<p>在上面的结构体中，分别对字段实现了下面的操作：</p>
<ol>
<li>将 Name 字段映射为 json 里的 name 字段</li>
<li>Age 字段映射为 age 字段，如果 Age 字段值为零值，则不参与序列化，如果 Age 字段值不为零值，则将 Age 字段值转换为字符串类型</li>
<li>Gender 字段映射到 json，但是不改变字段名</li>
<li>Address 字段映射为 address 字段</li>
<li>NoJsonField 字段不参与序列化</li>
</ol>
<p>对于这些操作，我们使用下面的代码进行测试，记住，要先引入 json 模块：</p>
<pre><code class="language-go">import (
&nbsp; &nbsp; "encoding/json"
)
</code></pre>
<p>然后进行操作：</p>
<pre><code class="language-go">person := Person{
&nbsp; &nbsp; Name: &nbsp; &nbsp; &nbsp; &nbsp;"Hunter",
&nbsp; &nbsp; Age: &nbsp; &nbsp; &nbsp; &nbsp; 18,
&nbsp; &nbsp; Gender: &nbsp; &nbsp; &nbsp;"Male",
&nbsp; &nbsp; Address: &nbsp; &nbsp; "Beijing",
&nbsp; &nbsp; NoJsonField: "NoJsonValue",
}

_person, err := json.Marshal(person)

if err != nil {
&nbsp; &nbsp; fmt.Println("JSON 编码错误:", err)
} else {
&nbsp; &nbsp; fmt.Println(string(_person))
}

// 测试 omitempty，为零值时忽略
person.Age = 0
_person, err = json.Marshal(person)
if err != nil {
&nbsp; &nbsp; fmt.Println("JSON 编码错误:", err)
} else {
&nbsp; &nbsp; fmt.Println(string(_person))
}
</code></pre>
<p>分别打印出两条 json 数据：</p>
<pre><code class="language-json">{"name":"Hunter","age":"18","Gender":"Male","address":"Beijing"}
{"name":"Hunter","Gender":"Male","address":"Beijing"}
</code></pre>
<p>输出的结果可以印证前面我们对字段进行的定义逻辑。</p>
<p>除了 json 标签，还有 form 标签用于表单数据绑定，gorm 标签用于数据库映射，validate 标签用于数据验证等，后面有用到的时候再做介绍。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-26 23:15">2025-06-26 23:14</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">42</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18951127);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18951127', targetLink: 'https://www.cnblogs.com/hunterxiong/p/18951127', title: 'Golang基础笔记五之结构体' })">举报</a>
</div>
        