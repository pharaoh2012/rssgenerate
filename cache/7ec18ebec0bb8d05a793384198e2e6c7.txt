
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zoubilin/p/18686990" title="发布于 2025-01-23 00:02">
    <span role="heading" aria-level="2">单纯形法原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2744125/202501/2744125-20250123000153836-331519948.png" alt="单纯形法原理" class="desc_img">
        单纯形法的原理介绍及python实现代码
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="单纯形法">单纯形法</h1>
<blockquote>
<p>参考连接：<a href="https://www.dohkoai.com/usr/show?id=20" target="_blank" rel="noopener nofollow">单纯形法</a></p>
</blockquote>
<p>单纯形法是针对求解线性规划问题的一个算法，这个名称里的 <strong>“单纯形”</strong> 是代数拓扑里的一个概念，可以简单将“单纯形”理解为一个<strong>凸集</strong>，标准的线性规划问题（线性规划标准型）可以表示为：</p>
<p></p><div class="math display">\[max\,(or\,min)\quad{f(x)=cx}\\
\quad\quad\quad{s.t.}\quad{Ax=b}\\
\quad\quad\quad\quad\quad{x}\geq{0}
\]</div><p></p><p>单纯形法最早由 George Dantzig于1947年提出，单纯形法对于求解线性规划问题是具有跨时代意义的，其实不仅仅是针对线性规划，非线性规划问题在求解的过程中也大量依赖单纯形法。</p>
<h1 id="一凸集及其性质的介绍">一、凸集及其性质的介绍</h1>
<h2 id="11-凸集的概念">1.1 凸集的概念</h2>
<p><strong>单纯形可以理解为一个凸集</strong>，介绍单纯形法之前有必要先来了解一下凸集概念及其性质，凸集上求最优解是凸优化的一个分支，凸集对于简化问题是有重要意义的。</p>
<p>凸集可以用图形表示为<strong>一个没有洞的联通区域</strong>，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/2744125/202501/2744125-20250122235948114-867542823.png" alt="" loading="lazy"></p>
<p><strong>凸集的概念：</strong></p>
<ul>
<li>
<p>（1）如果集合<span class="math inline">\(C\)</span>中任意两个点<span class="math inline">\(X_1,X_2\)</span>，其连线上所有的点也都是集合<span class="math inline">\(C\)</span>中的点，称<span class="math inline">\(C\)</span>为凸集</p>
</li>
<li>
<p>（2）<span class="math inline">\(X_1,X_2\)</span>的连线可以表示为：<span class="math inline">\(aX_1+(1-a)X_2\quad(0&lt;a&lt;1)\)</span></p>
</li>
<li>
<p>（3）凸集定义用数学解析式可表示为：对<span class="math inline">\(\forall{X_1,X_2}\in{C}\)</span>，有：<span class="math inline">\(aX_1+(1-a)X_2\in{C}\quad(0&lt;a&lt;1)\)</span></p>
</li>
</ul>
<p>关于（2），以一个一维坐标例子简单理解一下。如图，<span class="math inline">\(aX_1+(1-a)X_2=a(X_1-X_2)+X_2\quad(0&lt;a&lt;1)\)</span>，其中<span class="math inline">\(a=0\)</span>和<span class="math inline">\(a=1\)</span>分别代表<span class="math inline">\(X_2、X_1\)</span>；<span class="math inline">\(a\in(0,1)\)</span>代表点<span class="math inline">\(X_1\)</span>和点<span class="math inline">\(X_2\)</span>连线中任意一点</p>
<p><img src="https://img2024.cnblogs.com/blog/2744125/202501/2744125-20250123000004725-25407972.png" alt="" loading="lazy"></p>
<p>根据定义下面这个图形所定义的区域不是凸集：</p>
<p><img src="https://img2024.cnblogs.com/blog/2744125/202501/2744125-20250123000016343-2067729615.png" alt="" loading="lazy"></p>
<h2 id="12-凸集的顶点">1.2 凸集的顶点</h2>
<p><strong>顶点：</strong></p>
<p>凸集<span class="math inline">\(C\)</span>中满足下述条件的点<span class="math inline">\(X\)</span>称为顶点：</p>
<ul>
<li>
<p>如果<span class="math inline">\(C\)</span>中不存在任何两个不同的点<span class="math inline">\(X_1,X_2\)</span>，使<span class="math inline">\(X\)</span>成为这两个点连线上的一个点。</p>
</li>
<li>
<p>或者这样表述：对<span class="math inline">\(\forall{X_1,X_2}\in{C}\)</span>，不存在<span class="math inline">\(X=aX_1+(1-a)X_2\quad(0&lt;a&lt;1)\)</span>，则称<span class="math inline">\(X\)</span>是凸集<span class="math inline">\(C\)</span>的顶点</p>
</li>
</ul>
<p>如图，因为<span class="math inline">\(a≠0或1\)</span>，所以<span class="math inline">\(X\)</span>不能成为<span class="math inline">\(C\)</span>中某条连线上的一个点。</p>
<p><img src="https://img2024.cnblogs.com/blog/2744125/202501/2744125-20250123000027812-1697342466.png" alt="" loading="lazy"></p>
<h2 id="13-几个基本定理">1.3 几个基本定理</h2>
<p><strong>定理1</strong>&nbsp;&nbsp;&nbsp;&nbsp;若线性规划问题存在可行解，则问题的<strong>可行域是凸集</strong></p>
<ul>
<li>证明见《运筹学教程（第五版）》第20页</li>
</ul>
<p><strong>定理2</strong>&nbsp;&nbsp;&nbsp;&nbsp;线性规划问题的<strong>基可行解</strong><span class="math inline">\(X\)</span>对应线性规划问题<strong>可行域（凸集）的顶点</strong></p>
<p><strong>定理3</strong>&nbsp;&nbsp;&nbsp;&nbsp;若线性规划问题有最优解，<strong>一定</strong>存在一个<strong>基可行解是最优解</strong></p>
<h1 id="二单纯形法原理">二、单纯形法原理</h1>
<h2 id="21-线性规划问题的解的概念">2.1 线性规划问题的解的概念</h2>
<ul>
<li>
<p><strong>可行解</strong>&nbsp;&nbsp;&nbsp;&nbsp;满足所有约束条件的解，称为线性规划问题的可行解。全部可行解的集合称为<strong>可行域</strong>。</p>
</li>
<li>
<p><strong>最优解</strong>&nbsp;&nbsp;&nbsp;&nbsp;使目标函数达到最大值的可行解称为最优解。</p>
</li>
<li>
<p><strong>基</strong>&nbsp;&nbsp;&nbsp;&nbsp;设<span class="math inline">\(A\)</span>为约束方程组的<span class="math inline">\(m×n(m&gt;n)\)</span>阶系数矩阵，其秩为<span class="math inline">\(m\)</span>，<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>的一个<span class="math inline">\(m×m\)</span>阶<strong>满秩子矩阵</strong>，称<span class="math inline">\(B\)</span>是线性规划问题的一个<strong>基</strong>。</p>
<ul>
<li>
<p><span class="math inline">\(B\)</span>中每一个列向量<span class="math inline">\(P_j(j=1,\dots,m)\)</span>称为<strong>基向量</strong></p>
</li>
<li>
<p>与基向量<span class="math inline">\(P_j\)</span>对应的变量<span class="math inline">\(x_j\)</span>称为<strong>基变量</strong></p>
</li>
<li>
<p>线性规划中除基变量以外的变量称为<strong>非基变量</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>基解</strong>&nbsp;&nbsp;&nbsp;&nbsp;由<span class="math inline">\(m\)</span>个约束方程可解出<span class="math inline">\(m\)</span>个基变量的唯一解<span class="math inline">\(X_B\)</span>，将这个解加上<strong>非基变量取</strong><span class="math inline">\(0\)</span>的值产生的解<span class="math inline">\(X\)</span>，称为线性规划问题的基解。</p>
<ul>
<li>基解中变量取非<span class="math inline">\(0\)</span>值的个数不大于方程数<span class="math inline">\(m\)</span>，故基解的总数不超过<span class="math inline">\(C^m_n\)</span>个</li>
</ul>
</li>
<li>
<p><strong>基可行解</strong>&nbsp;&nbsp;&nbsp;&nbsp;满足变量非负约束条件（如<span class="math inline">\(x\geq0\)</span>）的基解称为基可行解</p>
<ul>
<li>单纯型法应用于标准化形式的线性规划问题，所以在线性规划问题中决策变量<span class="math inline">\(x\)</span>均大于等于<span class="math inline">\(0\)</span></li>
</ul>
</li>
<li>
<p><strong>可行基</strong>&nbsp;&nbsp;&nbsp;&nbsp;对应于基可行解的基称为可行基</p>
</li>
</ul>
<h2 id="22-单纯形法的实现">2.2 单纯形法的实现</h2>
<p>根据定理2和定理3，最优解一定是一个基可行解，且为凸集的一个顶点。</p>
<p><strong>单纯形法的核心思想可以归纳为：</strong> 找到每一个基本可行解，代入目标函数后计算函数值取其最大或最小值即可。单纯形法上从代数角度是寻找约束条件的每一个基本可行解，从几何意义上来说是<strong>遍历凸集的每一个顶点</strong>，根据算法的特性有时也称为转轴法。</p>
<p><strong>当求解最小值问题时，如果借助梯度的概念，在得到一个顶点后，切换下一个顶点方向是函数变小的方向无疑会节省很多时间</strong>。</p>
<h3 id="221-单纯形法的迭代">2.2.1 单纯形法的迭代</h3>
<blockquote>
<p>约束条件系数矩阵<span class="math inline">\(A\)</span>中，将作为基的列集合记作<span class="math inline">\(B\)</span>（或者说<span class="math inline">\(B\)</span>为线性规划问题的一个基）；非基的列集合记作<span class="math inline">\(N\)</span>，则有：<span class="math inline">\(A=(N,B)\)</span>。其中，<span class="math inline">\(N、B\)</span>均为<span class="math inline">\(A\)</span>的一个分块矩阵。</p>
</blockquote>
<blockquote>
<p>同样地，把<span class="math inline">\(x=\left[\begin{matrix}x_{1}\\x_{2}\\\vdots\\x_n\end{matrix}\right]\)</span>分量中基变量的的集合记作<span class="math inline">\(x_B\)</span>，非基变量集合记为<span class="math inline">\(x_N\)</span></p>
</blockquote>
<p>约束条件可写为：<span class="math inline">\((N,B)(x_N,x_B)=b\)</span>，得到等式<span class="math inline">\(Nx_N+Bx_b=b\)</span>，矩阵<span class="math inline">\(B\)</span>是基矩阵且可逆，得到：</p>
<p></p><div class="math display">\[Bx_B=b-Nx_N\\
B^{-1}Bx_B=B^{-1}b-B^{-1}Nx_N\\
x_B=B^{-1}b-B^{-1}Nx_N\tag{1}
\]</div><p></p><p>当<span class="math inline">\(x_N=0\)</span>时，<span class="math inline">\(x_B=B^{-1}b\)</span>，若<span class="math inline">\(B^{-1}b\geq0\)</span>，则称<span class="math inline">\(x_B\)</span>为<strong>初始基可行解</strong></p>
<blockquote>
<p>同样地，将目标函数中的系数向量<span class="math inline">\(c\)</span>也分为两部分，基变量对应的系数向量记为<span class="math inline">\(c_B\)</span>，非基变量对应的系数记为<span class="math inline">\(c_N\)</span></p>
</blockquote>
<p>由此，可得到目标函数的另一种表达形式：</p>
<p></p><div class="math display">\[f(x)=c_Bx_B+c_Nx_N\tag{2}
\]</div><p></p><p>把(1)代入(2)中，得到目标函数另一种表达形式：</p>
<p></p><div class="math display">\[f(x)=c_B(B^{-1}b-B^{-1}Nx_N)+c_Nx_N=c_BB^{-1}b-(c_BB^{-1}N-c_N)x_N\tag{3}
\]</div><p></p><p>若此时存在初始基可行解，即<span class="math inline">\(x_N=0，x_B=B^{-1}b\)</span>，代入(3)后可得到：</p>
<p></p><div class="math display">\[f(x)=c_BB^{-1}b\tag{4}
\]</div><p></p><p>对(3)进行求导，可得：</p>
<p></p><div class="math display">\[\frac{\partial{f}}{\partial{x}}=-(c_BB^{-1}N-c_N)\tag{5}
\]</div><p></p><p>若<span class="math inline">\(\frac{\partial{f}}{\partial{x}}&lt;0\)</span>，即<span class="math inline">\(c_BB^{-1}N-c_N&gt;0\)</span>，说明此时目标函数是单调递减的，也就是<strong>在取初始基可行解后目标函数还有变小的空间</strong>。此时可以选择矩阵中某个非基变量（非基集合中的某一列）来替代现有基变量（替代现有基），即选择入基。</p>
<p>如何选择入基呢？函数的微分形式有：</p>
<p></p><div class="math display">\[f(x+\Delta{x})=f(x)+\frac{\partial{f}}{\partial{x}}\Delta{x}\tag{6}
\]</div><p></p><ul>
<li>补充说明：<span class="math inline">\(\frac{\partial{f}}{\partial{x}}=\frac{\Delta{f(x)}}{\Delta{x}}\)</span>，所以：<span class="math inline">\(\Delta{f(x)}=\frac{\partial{f}}{\partial{x}}\Delta{x}\)</span>。又因为：<span class="math inline">\(\Delta{f(x)}=f(x+\Delta{x})-f(x)\)</span>，所以<span class="math inline">\(f(x+\Delta{x})=f(x)+\Delta{f(x)}=f(x)+\frac{\partial{f}}{\partial{x}}\Delta{x}\)</span></li>
</ul>
<p>由(5)可得，<span class="math inline">\(c_BB^{-1}N-c_N\)</span>越大则<span class="math inline">\(\frac{\partial{f}}{\partial{x}}\)</span>越小，目标函数变小的幅度也就越大。将此作为选择入基的标准，遍历每个非基列<span class="math inline">\(p_j\)</span>（<span class="math inline">\(p_j\)</span>为<span class="math inline">\(N\)</span>中的一个列向量），由于每次都只选择一个列作为入基，<span class="math inline">\(x_N\)</span>其他分量为<span class="math inline">\(0\)</span></p>
<p>所以，<span class="math inline">\(c_BB^{-1}N-c_N\)</span>简化为<span class="math inline">\(c_BB^{-1}p_j-c_j\)</span>，引入每一个待选列检验量<span class="math inline">\(\sigma_j=c_BB^{-1}p_j-c_j\)</span>，<strong>如果检验量大于<span class="math inline">\(0\)</span>，就选择这其中检验量最大的列作为入基就能保证目标函数在最大程度上变小，如果待选列检验量都小于等于<span class="math inline">\(0\)</span>，则代表此时已经得到最小值</strong>。</p>
<hr>
<p>入基已经准备就绪，那么如何选择出基呢？即如何选择被替代的基列？在选择入基是其实还有一个隐含的问题，入基被选择后，新的基变量值是多少？这些可以从公式(1)中得到答案：</p>
<p></p><div class="math display">\[x_B=B^{-1}b-B^{-1}Nx_N=B^{-1}b-B^{-1}p_jx_j\tag{7}
\]</div><p></p><p><span class="math inline">\(x_j\)</span>原来是<span class="math inline">\(x_N\)</span>中分量，初始时为0，将这个非基变量相关列选择作为新的基，<span class="math inline">\(x_j\)</span>也将获得新的值。</p>
<p>这里设<span class="math inline">\(\widetilde{b}=B^{-1}b,\,y_j=B^{-1}p_j\)</span>。很明显，<span class="math inline">\(\widetilde{b}\)</span>是初始基可行解，可行解<span class="math inline">\(x_B\)</span>可写成矩阵形式：</p>
<p></p><div class="math display">\[x_B=\left[\begin{matrix}\widetilde{b_1}\\\widetilde{b_2}\\\vdots\\\widetilde{b_m}\end{matrix}\right]
-\left[\begin{matrix}y_{j1}\\y_{j2}\\\vdots\\y_{jm}\end{matrix}\right]x_j
=\left[\begin{matrix}x_{B1}\\x_{B2}\\\vdots\\x_{Bm}\end{matrix}\right]
-\left[\begin{matrix}y_{j1}\\y_{j2}\\\vdots\\y_{jm}\end{matrix}\right]x_j
=\left[\begin{matrix}x_{B1}-y_{j1}x_j\\x_{B2}-y_{j2}x_j\\\vdots\\x_{Bm}-y_{jm}x_j\end{matrix}\right]\tag{8}
\]</div><p></p><p>由于约束条件<span class="math inline">\(x_B\geq0\)</span>的限制，所以<span class="math inline">\(x_j\)</span>的范围也有限制，即<span class="math inline">\(x_{Bi}-y_{ji}x_j\geq0\)</span>，也就是<span class="math inline">\(x_j\leq\frac{x_{Bi}}{y_{ji}}\)</span></p>
<p>故此，当<span class="math inline">\(x_j\)</span>取<span class="math inline">\(min\{\frac{x_{Bi}}{y_{ji}}\}\quad(y_{ji}&gt;0)\)</span>时，即可保证新生成的<span class="math inline">\(x_B\geq0\)</span></p>
<p>得到<span class="math inline">\(x_j\)</span>的值后代入（8），使得原<span class="math inline">\(x_B\)</span>中有一个基变量变为<span class="math inline">\(0\)</span>，我们知道<span class="math inline">\(x_B\)</span>中每一个分量都是与基的列一一对应的，如果其中一个分量变量变为0，则代表这个基被替换，分量变为0的基为出基。</p>
<h3 id="223-单纯形法代码">2.2.3 单纯形法代码</h3>
<p></p><div class="math display">\[min\quad{-4x_1-x_2}\\
s.t.\quad-x_1+2x_2\leq4\\
\quad\quad2x_1+3x_2\leq12\\
\quad\quad{x_1}-x_2\leq3\\
\quad\quad{x_1},x_2\geq0
\]</div><p></p><pre><code class="language-python">import numpy as np
BASEINDEX=2
#列变换实现单纯形法
def simplex_ColTranslate(c ,A,b,flagstable):
    B=A[:,BASEINDEX:]
    Binv=np.linalg.inv(B)
    xb=np.dot(Binv  ,b)
    cb=c[:,BASEINDEX:]
    f=np.dot(cb,xb )
    Inbaseindex=-1
    OutBaseIndex = -1
    tempvalue=0
    for i in range(BASEINDEX):
        v=np.squeeze(np.dot(np.dot(cb,Binv),A[:,i])-c[:,i],0)
        if tempvalue&lt;=v:
            #找出入基
            tempvalue=v
            Inbaseindex=i
    if tempvalue==0:
        #找到最优解
        return  xb,f,c,flagstable
    else:
        #入基出基替换，同时交换系数c
        y=np.dot(Binv,A[:,Inbaseindex])
        minivalue=None
        for i in range(y.shape[0]):
            if y[i]&gt;0:
                x=xb[i]/y[ i]
                #找出最小值，保证xb&gt;=0
                if minivalue is None or minivalue&gt;x :
                    minivalue=x
                    OutBaseIndex=i+BASEINDEX
        for i in range(A.shape[1]):
            if i==OutBaseIndex:
                for j in range(A.shape[0]):
                    tmp=A[j,i].copy()
                    A[j,i]=A[j, Inbaseindex]
                    A[j, Inbaseindex]=tmp
        tempc= np.squeeze( c[:,OutBaseIndex],0).copy()
        c[:,OutBaseIndex]=c[:,Inbaseindex]
        c[:,Inbaseindex]=tempc
        flagstable[OutBaseIndex-BASEINDEX]=Inbaseindex
        return simplex_ColTranslate(c, A, b,flagstable) 

def useColTranslate():
    BASEINDEX = 2
    c = np.array([[-4, -1, 0, 0, 0]],dtype=np.float)
    A = np.array([[-1, 2, 1, 0, 0], [2, 3, 0, 1, 0], [1, -1, 0, 0, 1]],dtype=np.float)
    b = np.array([[4], [12], [3]],dtype=np.float)
    # 记录下标变动情况
    flagstable = {}
    for i in range(c.shape[1] - BASEINDEX):
        flagstable[i] = BASEINDEX + i
    x, f, c, flags = simplex_ColTranslate(c, A, b, flagstable)
    print('最优解:%.2f' % (f[0, 0]))
    for j in range(x.shape[0]):
        print('x%d=%.1f' % (flags[j] + 1, x[j, 0])) 

if __name__ == '__main__':
    useColTranslate()
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.012169733440972223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 00:02">2025-01-23 00:02</span>&nbsp;
<a href="https://www.cnblogs.com/zoubilin">码头牛牛</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18686990" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18686990);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18686990', targetLink: 'https://www.cnblogs.com/zoubilin/p/18686990', title: '单纯形法原理' })">举报</a>
</div>
        