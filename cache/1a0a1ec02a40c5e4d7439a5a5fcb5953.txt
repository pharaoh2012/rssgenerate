
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dnboy/p/18701250" title="发布于 2025-02-06 16:13">
    <span role="heading" aria-level="2">设计模式1：工厂模式</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>开始学习设计模式，这是小卷学习设计模式的第1篇文章，今天了解下工厂模式，以及框架中用到工厂模式的案例</p>
</blockquote>
<h2 id="1概览">1.概览</h2>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202502/2784584-20250206161323085-338098364.png" alt="" loading="lazy"></p>
<h2 id="2分类">2.分类</h2>
<p>设计模式分为三类：</p>
<ul>
<li><strong>创建型</strong>：在创建对象的同时隐藏创建逻辑，不使用new直接实例化对象，程序判断创建哪些对象时更灵活</li>
<li><strong>结构型</strong>：通过类和接口间的继承、引用实现创建复杂结构的对象。</li>
<li><strong>行为型</strong>：通过类之间不同通信方式实现不同行为。</li>
</ul>
<p>工厂模式属于创建型设计模式，具体可以分为三类：</p>
<ul>
<li><strong>简单工厂模式</strong>，定义一个工厂类，根据传入参数动态创建不同类型的对象，缺点是新增产品需要修改工厂类逻辑，违背开闭原则</li>
<li><strong>工厂方法模式</strong>，将对象的创建延迟到子类，每个产品对应一个工厂类，扩展更好</li>
<li><strong>抽象工厂模式</strong>，用于创建产品族（多个相关联的系列对象），比如汽车工厂同时生产轮胎和引擎</li>
</ul>
<h2 id="3简单工厂模式">3.简单工厂模式</h2>
<p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻<br>
辑，只需提供传⼊⼯⼚的参数。</p>
<p>如：Spring的<code>BeanFactory</code>使用了简单工厂模式，根据传入一个唯一标识来获取<code>Bean</code>对象</p>
<p>下面是简单工厂模式的示例代码：</p>
<pre><code class="language-java">interface Car {
    void drive();
}

class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("Benz.......");
    }
}

class Bmw implements Car {
    @Override
    public void drive() {
        System.out.println("Bmw......");
    }
}

class CarFactory {
    public Car createCar(String type) {
        if ("Benz".equals(type)) {
            return new Benz();
        }
        if ("Bmw".equals(type)) {
            return new Bmw();
        }
        throw new IllegalArgumentException("unknown type");
    }
}

public class SimpleFactory {
    public static void main(String[] args) {
        Car car = CarFactory.createCar("Bmw");
        car.drive(); //输出Bmw......
    }
}
</code></pre>
<h2 id="4工厂方法模式">4.工厂方法模式</h2>
<p>定义一个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产<br>
品，将⽣产任务交给不同的派⽣类⼯⼚</p>
<p>示例代码：</p>
<pre><code class="language-java">//工厂接口
interface CarFactory {
    Car createCar();
}
//每个产品对应一个工厂
class BenzFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Benz();
    }
}

class BmwFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Bmw();
    }
}

public class MethondFactory {
    public static void main(String[] args) {
        CarFactory carFactory = new BenzFactory();
        Car car = carFactory.createCar();
        car.drive(); //输出Benz.......
    }
}
</code></pre>
<h2 id="5抽象工厂模式">5.抽象工厂模式</h2>
<p>简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产<br>
品，如果要⽣成另⼀种产品，就⽐较难办了！</p>
<p>抽象工厂模式通过在 <code>AbstarctFactory </code>中增加创建产品的接⼝，并在具体⼦<br>
工厂中实现新加产品的创建</p>
<pre><code class="language-java">//产品族接口（汽车 + 轮胎）
interface Car {
    void drive();
}

interface Tire {
    void wear();
}

//具体产品族，Benz族系列
class BenzCar implements Car {
    @Override
    public void drive() {
        System.out.println("Benz Car.......");
    }
}

class BenzTire implements Tire {
    @Override
    public void wear() {
        System.out.println("Benz Tire......");
    }
}
//抽象工厂接口
interface CarAbstractFactory {
    Car createCar();
    Tire createTire();
}
//具体工厂实现
class BenzFactory implements CarAbstractFactory {
    @Override
    public Car createCar() {
        return new BenzCar();
    }
    @Override
    public Tire createTire() {
        return new BenzTire();
    }
}
//使用
public class AbstractFactory {
    public static void main(String[] args) {
        CarAbstractFactory carAbstractFactory = new BenzFactory();
        Car car = carAbstractFactory.createCar();
        Tire tire = carAbstractFactory.createTire();
        car.drive(); //输出Benz Car.......
        tire.wear();
    }
}
</code></pre>
<h2 id="6具体框架案例">6.具体框架案例</h2>
<p>如<code>SLF4J</code>的<code>LoggerFactory</code>就使用了<strong>工厂模式</strong>，调用<code>getLogger()</code>方法来获取<code>Logger</code>实例</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Demo {
    private static final Logger logger = LoggerFactory.getLogger(Demo.class);
    
    public static void main(String[] args) {
        logger.info("Hello SLF4J");
    }
}
</code></pre>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.0026916360347222223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-06 16:14">2025-02-06 16:13</span>&nbsp;
<a href="https://www.cnblogs.com/dnboy">卷福同学</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18701250" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18701250);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18701250', targetLink: 'https://www.cnblogs.com/dnboy/p/18701250', title: '设计模式1：工厂模式' })">举报</a>
</div>
