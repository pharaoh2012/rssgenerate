
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CUC-MenG/p/19036764" title="发布于 2025-08-13 21:26">
    <span role="heading" aria-level="2">2025杭电多校第八场 最有节目效果的一集、最自律的松鼠、最甜的小情侣、最努力的活着 个人题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="最努力的活着"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1179&amp;pid=1009" target="_blank" rel="noopener nofollow">最努力的活着</a></h1>
<h1 id="数学-高精度">数学 #高精度</h1>
<h2 id="题目">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212237950-240744989.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212241610-766581954.png" alt="image" loading="lazy"></p>
<h2 id="思路">思路</h2>
<p>注意到本题给的<span class="math inline">\(1\leq n\leq 1e 12\)</span>，因此需要使用<span class="math inline">\(\_\_int 128\)</span>（最大可以存<span class="math inline">\(2^{128}\)</span>）来提高精度</p>
<p>贪心地想，为了使得最后的答案最大，每次删去的数必然要尽可能小，因此每次删去最小的<span class="math inline">\(\frac{len}{w}\)</span>个数即可</p>
<p>然而暴力模拟是会<span class="math inline">\(TLE\)</span>的，因此还需要考虑优化：<br>
设：</p>
<ul>
<li><span class="math inline">\(cnt:\)</span>当前剩多少数</li>
<li><span class="math inline">\(cnt_{2}:\)</span>删几次</li>
<li><span class="math inline">\(cnt_{3}:\)</span>一次删多少数<br>
那么对于每一个确定的<span class="math inline">\(cnt 3\)</span>，我们希望可以计算出一次性算出删掉<span class="math inline">\(cnt 3\)</span>个数的过程中对答案的贡献<span class="math inline">\(add\)</span>，因此利用这三个变量进行公式推导：</li>
</ul>
<p></p><div class="math display">\[\begin{align}
&amp;对于第i次操作 ,剩余的 数为 cnt-i\times cnt_{3}\\ \\
&amp;对于第i次操作,假设剩余k个数,对答案的贡献为n+n-1+\dots+n-k+1=\frac{(2n-k+1)\times k}{2}\\ \\
&amp;将k=cnt-i\times cnt_{3}带入得: \\ \\
add&amp;=\sum_{i=0}^{cnt_{2}-1} [2n-(cnt-i\times cnt_{3})+1]\times(cnt-i\times cnt_{3})\times \frac{1}{2}\\  \\
&amp;=\sum_{i=0}^{cnt_{2}-1}(2n-cnt+1+i\times cnt_{3})\times(cnt-i\times cnt_{3})\times \frac{1}{2}\\ \\
&amp;令A=2n-cnt+1,则:\\ \\
add&amp;=\sum_{i=0}^{cnt_{2}-1}(A+cnt_{3}\times i)\times(-cnt_{3}\times i+cnt)\times \frac{1}{2}\\ \\
&amp;=\sum_{i=0}^{cnt_{2}-1}[-cnt_{3}^2\times i^2+(cnt\times cnt_{3}-A\times cnt_{3})\times i+A\times cnt]\times \frac{1}{2}
\end{align}
\]</div><p></p><p></p><div class="math display">\[\begin{align}
&amp;由中学知识:\sum_{i=1}^{n}i^2= \frac{n(n+1)(2n+1)}{6}\\ \\
add&amp;= \left\{  -cnt_{3}^2\times \frac{(cnt_{2}-1)\times cnt_{2}\times (2cnt_{2}-1)}{6}+[cnt\times cnt_{3}-A\times cnt_{3}]\times \frac{cnt_{2}\times(cnt_{2}-1)}{2}+A\times cnt\times cnt_{2}  \right\} \times \frac{1}{2}
\end{align}
\]</div><p></p><p>因此只需要计算出<span class="math inline">\(cnt,cnt_{2},cnt_{3}\)</span>即可得到答案！</p>
<ul>
<li><span class="math inline">\(cnt_{3}\)</span>表示一次删多少数，自然是<span class="math inline">\(\frac{cnt}{w}\)</span></li>
<li><span class="math inline">\(cnt_{2}\)</span>表示可以删多少次，<span class="math inline">\({cnt\%w}\)</span>表示可以用于填补删去的空位的数，则<span class="math inline">\(\frac{cnt\%w}{cnt_{3}}+1\)</span>代表可以删多少次</li>
<li>每次计算完<span class="math inline">\(add\)</span>之后，需要让当前的<span class="math inline">\(cnt\)</span>更新，<span class="math inline">\(cnt-=cnt_{2}\times cnt_{3}\)</span></li>
</ul>
<h2 id="代码实现">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
#define int ll

#define int128 __int128
int128 read() {
    int128 x = 0, w = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') {if (ch == '-') w = -w;ch = getchar();}
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0';ch = getchar();}
    return w * x;
}
void print(int128 x) {
    if (x &lt; 0) {putchar('-');x = -x;}
    if (x &gt; 9) print(x / 10);
    putchar(x % 10 + '0');
}

void eachT() {
    int nn,ww;cin&gt;&gt;nn&gt;&gt;ww;
    int128 n=nn,w=ww,cnt=n,sum=0,cnt2=0,cnt3=0;
    while(1){
        int128 A=2*n-cnt+1;
        cnt3 = cnt/w;
        if(cnt3==0){
            sum += A*cnt/2;
            break;
        }
        cnt2 = cnt%w/cnt3+1;
        int128 add=(-cnt3*cnt3*(cnt2-1)*cnt2*(2*cnt2-1)/6+(cnt*cnt3-A*cnt3)*cnt2*(cnt2-1)/2+A*cnt*cnt2)/2;
        sum+=add;
        if(cnt&lt;w)break;
        cnt-=cnt3*cnt2;
    } 
    print(sum);
    cout&lt;&lt;'\n';
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    cin &gt;&gt; t;
    while (t--) eachT();
}
</code></pre>
<hr>
<h1 id="最甜的小情侣"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1179&amp;pid=1006" target="_blank" rel="noopener nofollow">最甜的小情侣</a></h1>
<h1 id="线段树-线段树维护矩阵-dp-线性dp">线段树 #线段树维护矩阵 #dp #线性dp</h1>
<h2 id="题目-1">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212302703-1771536030.png" alt="image" loading="lazy"></p>
<h2 id="思路-1">思路</h2>
<p>在不考虑修改操作的时候，我们可以很快写出线性递推：</p>
<ul>
<li>状态表示：
<ul>
<li><span class="math inline">\(dp[i][j]\)</span>表示<span class="math inline">\(1\sim i\)</span>中，第<span class="math inline">\(i\)</span>位是连续的第<span class="math inline">\(j\)</span>个宝珠，宝珠最大价值和</li>
</ul>
</li>
<li>状态转移：</li>
</ul>
<p></p><div class="math display">\[\begin{align}
&amp;dp[i][0]=\max_{0\leq j\leq 3}\{\  dp[i-1][j] \ \}\\ \\
&amp;dp[i][j]=dp[i-1][j-1]\ \ (1\leq j\leq 3)
\end{align}
\]</div><p></p><p>但是本题加入了单点修改操作，这要求我们在<span class="math inline">\(o(\log n)\)</span>的复杂度内解决每一次修改与查询</p>
<p>因此很自然想到了使用<strong>线段树</strong>一类的数据结构来维护dp信息</p>
<p>线性dp的状态转移实际上可以看作<span class="math inline">\(dp[i]=f(dp[i-1])\)</span>，其中<span class="math inline">\(f(x)\)</span>为对于<span class="math inline">\(x\)</span>的某种变换<br>
创建一个<strong>变换矩阵</strong><span class="math inline">\(A\)</span>，那么上式可以写作<span class="math inline">\(dp[i]=A\times dp[i-1]\)</span><br>
本题中，<span class="math inline">\(dp[i]\)</span>是一个四维的列向量：</p>
<p></p><div class="math display">\[dp[i]_{4\times 1}=
\begin{pmatrix}
dp[i][0]\\ 
dp[i][1] \\
dp[i][2] \\
dp[i][3]
\end{pmatrix}
\]</div><p></p><p>因此可以尝试构造一个变换矩阵<span class="math inline">\(A\)</span>描述状态转移：</p>
<p></p><div class="math display">\[\begin{align}
dp[i]_{4\times 1}&amp;=A_{4\times 4}\times dp[i-1]_{4\times 1}\\ \\
\begin{pmatrix}
dp[i][0]\\ 
dp[i][1] \\
dp[i][2] \\
dp[i][3]
\end{pmatrix}&amp;= 
\begin{pmatrix}
\ ?\quad?\quad?\quad?\ \\
\ ?\quad?\quad?\quad?\ \\
\ ?\quad?\quad?\quad?\ \\
\ ?\quad?\quad?\quad?\
\end{pmatrix} 
\times 
\begin{pmatrix}
dp[i-1][0]\\ 
dp[i-1][1] \\
dp[i-1][2] \\
dp[i-1][3]
\end{pmatrix}
\end{align}
\]</div><p></p><p>为了描述取<span class="math inline">\(max\)</span>运算的过程，需要对矩阵内的运算进行<strong>重载</strong>：</p>
<p></p><div class="math display">\[\begin{align}
&amp;a+b\to max\{ a,b \}\\ \\
&amp;a\times b\to a+b
\end{align}
\]</div><p></p><p>此时可以通过观察构造出变换矩阵：</p>
<p></p><div class="math display">\[\begin{align}
\begin{pmatrix}
dp[i][0]\\ 
dp[i][1] \\
dp[i][2] \\
dp[i][3]
\end{pmatrix}&amp;= 
\left(
\begin{array}{rc}
&amp;0 &amp;0 &amp;0 &amp;0\\ 
&amp;-inf &amp;w[i] &amp;-inf &amp;-inf \\
&amp;-inf &amp;-inf &amp;w[i] &amp;-inf \\ 
&amp;-inf &amp;-inf &amp;-inf &amp;w[i] 
\end{array}
\right)
\times 
\begin{pmatrix}
dp[i-1][0]\\ 
dp[i-1][1] \\
dp[i-1][2] \\
dp[i-1][3]
\end{pmatrix}
\end{align}
\]</div><p></p><p>对于一个区间<span class="math inline">\([l,r]\)</span>，可以通过线段树维护从<span class="math inline">\(l\)</span>到<span class="math inline">\(r\)</span>上所有的矩阵<span class="math inline">\(A\)</span>的乘积<span class="math inline">\(A_{l}A_{l+1}···A_{r}=A_{l\sim r}\)</span><br>
则可以进行<span class="math inline">\(pushup\)</span>操作：</p>
<p></p><div class="math display">\[A_{l\sim r}=A_{l\sim mid}\times A_{mid+1\sim r}
\]</div><p></p><p>用线段树维护累乘信息即可</p>
<p>解决了修改问题，还剩下一个问题没有解决：该过程在环上进行</p>
<p>一般的思路是将序列倍增，滑动窗口解决<br>
但是本题不允许使用滑动窗口+线段树每次询问<span class="math inline">\(o(n\log n)\)</span>的复杂度，因此需要考虑其他优化<br>
而注意到限制条件中的连续数量不大于3，可以考虑分类！</p>
<p>仍然先让序列倍增至<span class="math inline">\(2n\)</span>，对开头的几个元素进行分类：<br>
<img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212837667-2109717630.png" alt="image" loading="lazy"></p>
<p>×代表该位置不选宝珠，√代表该位置选宝珠<br>
由此可以通过四个分类将环形问题的连接处的所有情况考虑到，不需要倍增，只需要维护<span class="math inline">\(1\sim n+3\)</span>的序列<br>
但是，每次都查询四个区间，<span class="math inline">\(4\log n\)</span>的复杂度将导致常数过大，会被卡常<br>
因此需要取四个查询的交集，即<span class="math inline">\([5,n]\)</span>，每次只查询这个区间，其他的区间可以直接<span class="math inline">\(o(1)\)</span>调用其线段树节点所维护的矩阵，再进行矩阵乘法</p>
<p>在取出区间<span class="math inline">\([l,r]\)</span>上的矩阵后，我们需要拿一个全零的列向量与其相乘，随后取答案向量四个维度的最大值<br>
然而我们重定义了乘法为取最大值，因此全零向量作乘法实际上就是在对矩阵的所有元素取最大值<br>
因此只需要将整个矩阵中的所有元素取<span class="math inline">\(max\)</span>即可完成一次查询</p>
<h2 id="代码实现-1">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
#define int ll
const int inf=1e18;
const int N=2e5+15;

unordered_map&lt;int,int&gt;id;

struct M {
    int size;
    int data[4][4];
    M() : size(4){
        rep(i,0,3)rep(j,0,3)data[i][j]=-inf;
    }
    M operator*(const M&amp; other) const {
        M res;
        rep(i, 0, size - 1) {
            rep(j, 0, size - 1) {
                rep(k, 0, size - 1) {
                    res.data[i][j] = max(res.data[i][j], data[i][k] + other.data[k][j]);
                }
            }
        }
        return res;
    }
    void init(int w){
        int tmp[4][4]={{0,0,0,0},{w,-inf,-inf,-inf},{-inf,w,-inf,-inf},{-inf,-inf,w,-inf}};
        rep(i,0,3)rep(j,0,3)data[i][j]=tmp[i][j];
    }
};

#define lc p&lt;&lt;1
#define rc p&lt;&lt;1|1
#define mid ((l+r)&gt;&gt;1)
int ls[N&lt;&lt;2],rs[N&lt;&lt;2],w[N];
M m[N&lt;&lt;2];
int n,q;

void pushup(int p){
    m[p]=m[lc]*m[rc];
}

void build(int p,int l,int r){  
    if(l==r){
        m[p].init(w[l]);
        if(l&lt;=4)id[l]=p;
        if(n+1&lt;=l&amp;&amp;l&lt;=n+3)id[l]=p;
        return;
    }    
    build(lc,l,mid),build(rc,mid+1,r);
    pushup(p);
}

void update(int p,int l,int r,int pos,int val){
    if(l==r){m[p].init(val);return;}
    if(pos&lt;=mid)update(lc,l,mid,pos,val);
    else update(rc,mid+1,r,pos,val);
    pushup(p);
}

M query(int p,int l,int r,int x,int y){
    if(x&lt;=l&amp;&amp;r&lt;=y)return m[p];
    M res1,res2;
    bool L=0,R=0;
    if(x&lt;=mid)res1=query(lc,l,mid,x,y),L=1;
    if(y&gt;mid)res2=query(rc,mid+1,r,x,y),R=1;
    if(L&amp;&amp;R)return res1*res2;
    if(L)return res1;
    if(R)return res2;
}

int getans(M&amp;t){
    int res=0;
    rep(i,0,3)rep(j,0,3)res=max(res,t.data[i][j]);
    return res;
}

void maxans(int&amp;ans){
    M t=query(1,1,n+10,5,n);
    M p=m[id[2]]*m[id[3]]*m[id[4]]*t;
    ans=max(ans,getans(p));
    p=m[id[3]]*m[id[4]]*t*m[id[n+1]];
    ans=max(ans,getans(p));
    p=m[id[4]]*t*m[id[n+1]]*m[id[n+2]];
    ans=max(ans,getans(p));
    p=t*m[id[n+1]]*m[id[n+2]]*m[id[n+3]];
    ans=max(ans,getans(p));
}

void eachT() {
    cin&gt;&gt;n&gt;&gt;q;
    rep(i,1,n){
        cin&gt;&gt;w[i];
        if(i&lt;=10)w[i+n]=w[i];
    }
    build(1,1,n+10);
    int ans=0;
    maxans(ans);
    cout&lt;&lt;ans&lt;&lt;'\n';
    rep(i,1,q){
        int x,v;cin&gt;&gt;x&gt;&gt;v;
        update(1,1,n+10,x,v);
        if(x&lt;=10)update(1,1,n+10,x+n,v);
        int ans=0;
        maxans(ans);
        cout&lt;&lt;ans&lt;&lt;'\n';
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    cin &gt;&gt; t;
    while (t--) eachT();
}
</code></pre>
<hr>
<h1 id="最自律的松鼠"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1179&amp;pid=1005" target="_blank" rel="noopener nofollow">最自律的松鼠</a></h1>
<h1 id="模拟">模拟</h1>
<h2 id="题目-2">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212321958-1957765483.png" alt="image" loading="lazy"></p>
<h2 id="思路-2">思路</h2>
<p>如果将图进行简化，绿线代表主干道，黄线代表从主干道上延伸出去的支路<br>
考虑一种特殊情况：<br>
<img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212328523-96597572.png" alt="image" loading="lazy"></p>
<p></p><div class="math display">\[\begin{align}
&amp;假设x&lt;a,b&lt;y\\ \\
&amp;则有x+b&lt;y+a\\ \\
&amp;x+b+r&lt;y+a+r\\ \\
&amp;x+y+r&lt;x+b+r&lt;y+a+r\\ \\
&amp;然而所有支路长度不得大于主干道,因此假设不成立\\ \\
&amp;因此有x\geq a,y\geq b
\end{align}
\]</div><p></p><p>同理可证<span class="math inline">\(x\leq a,y\leq b\)</span><br>
因此有<span class="math inline">\(x=a,y=b\)</span><br>
<img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212334660-1994457684.png" alt="image" loading="lazy"></p>
<p>因此每次对支路新增节点只需维护其子树的最大深度即可</p>
<p>易知，能够作为等待边的必然在主干路上，而上图中的<span class="math inline">\(r\)</span>段就是一个可能区域<br>
我们的目标便是找到所有<span class="math inline">\(r\)</span>段的交集<br>
因此，设置<span class="math inline">\(l\)</span>从左向右更新，维护最靠右的合法支路；设置<span class="math inline">\(r\)</span>从右向左更新，维护最靠左的合法支路</p>
<p>对于一个查询，直接输出主干路上的<span class="math inline">\([l,r]\)</span>上的区间和即可<br>
当然，如果出现了<span class="math inline">\(r\leq l\)</span>的情况，那么就直接输出0即可</p>
<h2 id="代码实现-2">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
#define int ll
const int inf=1e18;
const int N=5e5+15;
int n,w,root,leaf,tot,l,r;

struct node{
    int dep,rt;
}a[N];

int maxdep[N],pre[N];

void eachT() {
    cin&gt;&gt;n&gt;&gt;w;
    root=1,leaf=2,tot=2,l=1,r=2;
    maxdep[1]=maxdep[2]=0;
    a[1].dep=a[2].dep=0;
    a[1].rt=a[2].rt=0;

    rep(i,1,n){
        pre[i]=maxdep[i]=0;
    }
    pre[2]=w;
    unordered_map&lt;int,int&gt;id;
    int main=2;
    id[1]=1,id[2]=2;

    rep(i,1,n){
        int op;cin&gt;&gt;op;
        if(op==1){
            tot++;
            int w;cin&gt;&gt;w;
            id[tot]=++main;
            pre[main]=pre[main-1]+w;
            leaf=tot;
            a[leaf].dep=a[leaf].rt=0;
            r=main;
        }else if(op==2){
            tot++;
            int x,w;cin&gt;&gt;x&gt;&gt;w;
            a[tot].dep=a[x].dep+w;
            if(a[x].rt==0)a[tot].rt=x;
            else a[tot].rt=a[x].rt;
            int rt=a[tot].rt;
            maxdep[rt]=max(maxdep[rt],a[tot].dep);
            if(maxdep[rt]==pre[id[rt]])l=max(l,id[rt]);
            if(maxdep[rt]==pre[main]-pre[id[rt]])r=min(r,id[rt]);
        }else{
            if(l&gt;=r)cout&lt;&lt;0&lt;&lt;'\n';
            else cout&lt;&lt;pre[r]-pre[l]&lt;&lt;'\n';
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    cin &gt;&gt; t;
    while (t--) eachT();
}
</code></pre>
<hr>
<h1 id="最有节目效果的一集"><a href="https://acm.hdu.edu.cn/contest/problem?cid=1179&amp;pid=1011" target="_blank" rel="noopener nofollow">最有节目效果的一集</a></h1>
<h1 id="平衡树-红黑树-模拟">平衡树 #红黑树 #模拟</h1>
<h2 id="题目-3">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212346038-1043872331.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212350410-817220081.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250813212354621-887094559.png" alt="image" loading="lazy"></p>
<h2 id="思路-3">思路</h2>
<p>本题为模拟题，关键在于面向对象以及排名的修改查询的实现</p>
<p>结构体<span class="math inline">\(Team\)</span>：</p>
<ul>
<li><span class="math inline">\(win\ num\)</span>：该队伍赢的局数</li>
<li><span class="math inline">\(win\ score\)</span>：该队伍的净胜分</li>
<li><span class="math inline">\(group\)</span>：该队伍属于哪个组</li>
<li><span class="math inline">\(name\)</span>：该队伍的名字</li>
<li><span class="math inline">\(team\ cmp\)</span>：三关键字的比较函数</li>
</ul>
<p><span class="math inline">\(Team\)</span>类数组<span class="math inline">\(team[3\times N]\)</span>，用于储存所有队伍的信息</p>
<p>红黑树<span class="math inline">\(orderd\ set\)</span>，简称<span class="math inline">\(os\)</span>，开三棵用于维护三个组的<span class="math inline">\(Team\)</span>，其中的比较函数采用<span class="math inline">\(team \ cmp\)</span></p>
<p>结构体<span class="math inline">\(Information\)</span>：</p>
<ul>
<li><span class="math inline">\(team_{1},team_{2}\)</span>：信息中的两个队伍</li>
<li><span class="math inline">\(score_{1},score_{2}\)</span>两个队伍对应的比分</li>
<li><span class="math inline">\(time\)</span>：该信息出现的时间</li>
<li>比较函数：以<span class="math inline">\(time\)</span>为关键字比较</li>
</ul>
<p><span class="math inline">\(Information\)</span>类数组<span class="math inline">\(info[M]\)</span>，用于储存所有的论坛信息</p>
<p><span class="math inline">\(bool\)</span>型数组<span class="math inline">\(del[M]\)</span>，用于标记当前信息是否已经被删除<br>
<span class="math inline">\(map\langle \  pair\langle string,string\rangle\ ,\ set\langle Information\ \rangle\ \rangle mp\)</span>，其中<span class="math inline">\(mp[\ \{ A,B \}\ ]\)</span>代表关于 <span class="math inline">\(A,B\)</span>两个队伍的论坛信息集合，按照时间升序排序</p>
<p><span class="math inline">\(hash\langle\ string,int\ \rangle id\_people,id\_team\)</span>，分别表示某成员所在队伍的编号、某队伍的编号</p>
<p>相信读者在理解所有使用的<span class="math inline">\(stl\)</span>与结构体后，都能自己想到怎么模拟这个过程了，在此不过多赘述</p>
<p>但其中有部分细节需要注意：</p>
<ul>
<li>无效信息不得放入<span class="math inline">\(mp\)</span>中，否则会引起错误</li>
<li>写一个<span class="math inline">\(change\)</span>函数用于修改红黑树中的值，先删去原有的值，修改完毕后再插入回去</li>
<li>题目有可能多次删除同一条信息，因此需要<span class="math inline">\(del[M]\)</span>数组</li>
<li>在删除信息的时候，需要判断删除的是否是正在使用的信息</li>
<li>需要对删除信息之后集合是否非空进行特判</li>
<li>红黑树的<span class="math inline">\(.order\_of\_key()\)</span>函数返回的是<span class="math inline">\(0-based\)</span>下标，答案需要+1得到排名</li>
</ul>
<h2 id="代码实现-3">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(int i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
constexpr ll inf = 1e9 + 5;
// #define int ll 

const int N=1e3+5,M=1e5+5;
int n,k;

#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
using namespace __gnu_pbds;

gp_hash_table&lt;string,int&gt;id_pp,id_team;

struct Team{
    int winnum,winscore,group;
    string name;
    void print(){
        cout&lt;&lt;"name:"&lt;&lt;name&lt;&lt;" winnum:"&lt;&lt;winnum&lt;&lt;" winscore:"&lt;&lt;winscore&lt;&lt;" group:"&lt;&lt;group&lt;&lt;endl;
    }
}team[3*N];
struct teamcmp{
    bool operator()(const Team&amp;a,const Team&amp;b)const{
        if(a.winnum!=b.winnum)return a.winnum&gt;b.winnum;
        if(a.winscore!=b.winscore)return a.winscore&gt;b.winscore;
        return a.name&lt;b.name;
    }
};
tree&lt;
    Team, 
    null_type, 
    teamcmp, 
    rb_tree_tag, 
    tree_order_statistics_node_update
&gt;os[4];

struct Info{
    string team1,team2;
    int score1,score2,tim;
    bool operator&lt;(const Info&amp;t)const{
        return tim&lt;t.tim;
    }
}info[M];
bool del[M];
map&lt;pair&lt;string,string&gt;,set&lt;Info&gt;&gt;mp;

void change(string A,string B,int Ascore,int Bscore,int ida,int idb,int pd){
    if(A&gt;B)swap(A,B),swap(Ascore,Bscore);  
    os[ida].erase(team[id_team[A]]);
    os[idb].erase(team[id_team[B]]);
    team[id_team[A]].winnum+=(Ascore&gt;Bscore)*pd;
    team[id_team[B]].winnum+=(Bscore&gt;Ascore)*pd;
    team[id_team[A]].winscore+=(Ascore-Bscore)*pd;
    team[id_team[B]].winscore+=(Bscore-Ascore)*pd;
    os[ida].insert(team[id_team[A]]);
    os[idb].insert(team[id_team[B]]);
}

void read(string&amp;A,string&amp;B,int&amp;Ascore,int&amp;Bscore){
    string x;
    rep(i,1,3)cin&gt;&gt;x;
    cin&gt;&gt;x;
    x.pop_back();
    A=x;
    rep(i,1,7)cin&gt;&gt;x;
    cin&gt;&gt;x;
    B=x;
    cin&gt;&gt;x;cin&gt;&gt;x;
    Ascore=x[0]-'0';
    Bscore=x[2]-'0';
}

void eachT() {   
    cin&gt;&gt;n&gt;&gt;k;

    id_pp.clear();
    id_team.clear();
    mp.clear();
    rep(i,1,3)os[i].clear();
    rep(i,1,3*n)del[i]=0;

    rep(i,1,3*n){
        string tm;cin&gt;&gt;tm;      
        rep(j,0,4){
            string x;cin&gt;&gt;x;
            id_pp[x]=i;
        }
        int group;cin&gt;&gt;group;
        id_team[tm]=i;
        team[i]={0,0,group,tm};
        os[group].insert(team[i]);
    }
    int tim=0;
    rep(i,1,k){
        int op;cin&gt;&gt;op;
        if(op==1){
            tim++;
            string A,B;int Ascore,Bscore;        
            read(A,B,Ascore,Bscore);
            
            if(id_team[A]==0)A=team[id_pp[A]].name;
            if(A&gt;B)swap(A,B),swap(Ascore,Bscore);

            info[tim]={A,B,Ascore,Bscore,tim};
            del[tim]=0;
            int ida=team[id_team[A]].group,idb=team[id_team[B]].group;
            if(ida!=idb)continue;//无效信息

            mp[{A,B}].insert(info[tim]);
            if(mp[{A,B}].size()==1){
                change(A,B,Ascore,Bscore,ida,idb,1);
            }
        }else if(op==2){
            int x;cin&gt;&gt;x;
            string A=info[x].team1,B=info[x].team2;
            if(A&gt;B)swap(A,B);
            int ida=team[id_team[A]].group,idb=team[id_team[B]].group;
            if(ida!=idb)continue;//无效信息

            if(del[x])continue;
            del[x]=1;
            Info now=*mp[{A,B}].begin();
            if(info[x].tim==now.tim){//删掉的刚好是正在使用的信息
                change(A,B,now.score1,now.score2,ida,idb,-1);
                mp[{A,B}].erase(info[x]);          
                if(mp[{A,B}].empty())continue;

                Info modify=*mp[{A,B}].begin();
                int Ascore=modify.score1,Bscore=modify.score2;
                change(A,B,Ascore,Bscore,ida,idb,1);
            }else{
                mp[{A,B}].erase(info[x]);
            }
        }else{//op==3
            int x;cin&gt;&gt;x;
            int group=team[x].group;
            cout&lt;&lt;os[group].order_of_key(team[x])+1&lt;&lt;'\n';
        }
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    cin &gt;&gt; t;
    while (t--) {
        eachT();
    }
}

</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-08-13 21:29">2025-08-13 21:26</span>&nbsp;
<a href="https://www.cnblogs.com/CUC-MenG">CUC-MenG</a>&nbsp;
阅读(<span id="post_view_count">48</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19036764);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19036764', targetLink: 'https://www.cnblogs.com/CUC-MenG/p/19036764', title: '2025杭电多校第八场 最有节目效果的一集、最自律的松鼠、最甜的小情侣、最努力的活着 个人题解' })">举报</a>
</div>
        