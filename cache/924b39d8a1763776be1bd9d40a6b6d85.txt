
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lavender-vv/p/18703379" title="发布于 2025-02-07 22:11">
    <span role="heading" aria-level="2">LeetCode 第3题：无重复字符的最长子串</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="leetcode-第3题无重复字符的最长子串">LeetCode 第3题：无重复字符的最长子串</h1>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p>
<h2 id="难度">难度</h2>
<p>中等</p>
<h2 id="题目链接">题目链接</h2>
<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener nofollow">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
<h2 id="示例">示例</h2>
<h3 id="示例-1">示例 1：</h3>
<pre><code>输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</code></pre>
<h3 id="示例-2">示例 2：</h3>
<pre><code>输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
</code></pre>
<h3 id="示例-3">示例 3：</h3>
<pre><code>输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
</code></pre>
<h2 id="提示">提示</h2>
<ul>
<li>0 &lt;= s.length &lt;= 5 * 104</li>
<li>s 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<p>这道题可以使用滑动窗口的方法解决。滑动窗口是一种在数组或字符串上使用双指针的技巧，通过移动左右指针形成一个窗口，在窗口内进行操作。</p>
<p>关键点：</p>
<ol>
<li>使用两个指针（left和right）维护一个滑动窗口</li>
<li>使用HashSet记录窗口内的字符，保证无重复</li>
<li>当遇到重复字符时，移动左指针直到删除重复字符</li>
<li>在移动过程中更新最大长度</li>
</ol>
<p>具体步骤：</p>
<ol>
<li>初始化左指针left = 0，右指针right = 0</li>
<li>创建HashSet存储窗口内的字符</li>
<li>移动右指针，将字符加入Set：
<ul>
<li>如果字符不在Set中，加入Set并更新最大长度</li>
<li>如果字符在Set中，移动左指针并删除字符，直到没有重复</li>
</ul>
</li>
<li>重复步骤3直到右指针到达字符串末尾</li>
</ol>
<p>时间复杂度：O(n)，其中n是字符串长度<br>
空间复杂度：O(min(m,n))，其中m是字符集大小</p>
<h3 id="方法二优化的滑动窗口">方法二：优化的滑动窗口</h3>
<p>使用Dictionary/HashMap代替HashSet，存储字符最后出现的位置，可以直接跳转左指针位置，避免一个个删除字符。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="c-实现基本滑动窗口">C# 实现（基本滑动窗口）</h3>
<pre><code class="language-csharp">public class Solution {
    public int LengthOfLongestSubstring(string s) {
        // 特殊情况处理
        if (string.IsNullOrEmpty(s)) return 0;
      
        // 创建HashSet存储当前窗口中的字符
        HashSet&lt;char&gt; window = new HashSet&lt;char&gt;();
        int maxLength = 0;
        int left = 0;
      
        // 右指针遍历字符串
        for (int right = 0; right &lt; s.Length; right++) {
            // 如果发现重复字符，移动左指针直到删除重复字符
            while (window.Contains(s[right])) {
                window.Remove(s[left]);
                left++;
            }
          
            // 将当前字符加入窗口
            window.Add(s[right]);
          
            // 更新最大长度
            maxLength = Math.Max(maxLength, right - left + 1);
        }
      
        return maxLength;
    }
}
</code></pre>
<h3 id="c-实现优化的滑动窗口">C# 实现（优化的滑动窗口）</h3>
<pre><code class="language-csharp">public class Solution {
    public int LengthOfLongestSubstring(string s) {
        // 特殊情况处理
        if (string.IsNullOrEmpty(s)) return 0;
      
        // 创建Dictionary存储字符最后出现的位置
        Dictionary&lt;char, int&gt; lastPos = new Dictionary&lt;char, int&gt;();
        int maxLength = 0;
        int left = 0;
      
        // 右指针遍历字符串
        for (int right = 0; right &lt; s.Length; right++) {
            char currentChar = s[right];
          
            // 如果字符已存在，直接将左指针移动到重复字符的下一位
            if (lastPos.ContainsKey(currentChar)) {
                left = Math.Max(left, lastPos[currentChar] + 1);
            }
          
            // 更新字符最后出现的位置
            lastPos[currentChar] = right;
          
            // 更新最大长度
            maxLength = Math.Max(maxLength, right - left + 1);
        }
      
        return maxLength;
    }
}
</code></pre>
<h2 id="代码详解">代码详解</h2>
<h3 id="基本滑动窗口版本">基本滑动窗口版本：</h3>
<ol>
<li><code>HashSet&lt;char&gt; window</code>：用于存储当前窗口中的字符，保证无重复</li>
<li><code>while (window.Contains(s[right]))</code>：当发现重复字符时，不断移动左指针并删除字符</li>
<li><code>maxLength = Math.Max(maxLength, right - left + 1)</code>：更新最大长度</li>
</ol>
<h3 id="优化版本">优化版本：</h3>
<ol>
<li><code>Dictionary&lt;char, int&gt; lastPos</code>：存储每个字符最后出现的位置</li>
<li><code>left = Math.Max(left, lastPos[currentChar] + 1)</code>：
<ul>
<li>当发现重复字符时，直接将左指针移动到重复字符上次出现位置的下一位</li>
<li>使用Math.Max是为了防止左指针回退</li>
</ul>
</li>
</ol>
<h2 id="执行结果">执行结果</h2>
<h3 id="基本滑动窗口版本-1">基本滑动窗口版本：</h3>
<ul>
<li>执行用时：84 ms</li>
<li>内存消耗：39.5 MB</li>
</ul>
<h3 id="优化版本-1">优化版本：</h3>
<ul>
<li>执行用时：72 ms</li>
<li>内存消耗：39.8 MB</li>
</ul>
<h2 id="总结与反思">总结与反思</h2>
<ol>
<li>这是一道经典的滑动窗口题目，考察了：
<ul>
<li>滑动窗口的基本应用</li>
<li>字符串的处理</li>
<li>哈希表的使用</li>
</ul>
</li>
<li>两种实现方式各有优势：
<ul>
<li>基本版本思路更直观，易于理解</li>
<li>优化版本性能更好，避免了多次移动左指针</li>
</ul>
</li>
<li>关键点：
<ul>
<li>理解子串和子序列的区别</li>
<li>正确维护滑动窗口</li>
<li>高效处理重复字符</li>
</ul>
</li>
</ol>
<h2 id="相关题目">相关题目</h2>
<ul>
<li>LeetCode 第159题：至多包含两个不同字符的最长子串</li>
<li>LeetCode 第340题：至多包含 K 个不同字符的最长子串</li>
<li>LeetCode 第395题：至少有 K 个重复字符的最长子串</li>
<li>LeetCode 第424题：替换后的最长重复字符</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.000984656474537037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-07 22:12">2025-02-07 22:11</span>&nbsp;
<a href="https://www.cnblogs.com/lavender-vv">旧厂街小江</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18703379" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18703379);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18703379', targetLink: 'https://www.cnblogs.com/lavender-vv/p/18703379', title: 'LeetCode 第3题：无重复字符的最长子串' })">举报</a>
</div>
        