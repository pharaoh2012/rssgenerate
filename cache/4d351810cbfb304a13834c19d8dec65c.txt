
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/18805791" title="发布于 2025-04-02 13:46">
    <span role="heading" aria-level="2">vue3第二次传递数据方法无法获取到最新的值</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402134535536-708751194.jpg" alt="" loading="lazy"></p>
<h4 id="使用reactive父组件第二次传递给子组件的数据方法中可以获取到最新数据">使用reactive父组件第二次传递给子组件的数据：方法中可以获取到最新数据</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;h1&gt;子组件&lt;/h1&gt;
      &lt;child :infoObj='infoObj' ref="childRef"&gt;&lt;/child&gt;
    &lt;/div&gt;
    &lt;button @click='updateHandler'&gt;跟新值&lt;/button&gt;
    &lt;div&gt;
      &lt;h1&gt;父页面&lt;/h1&gt;
      &lt;p&gt;{{ infoObj }}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import child from '@/components/child.vue'
import { ref,reactive } from 'vue'
let infoObj = reactive({
  name:'张三',
  age:26
})
const childRef = ref()
function updateHandler(){
  infoObj.name = '李四'
  infoObj.age = 28
  // 跟新值后，调用父组件的方法。
  childRef.value.getData()
}
&lt;/script&gt;
</code></pre>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt; {{ props.infoObj }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
let props = defineProps({
  infoObj:Object,
})
function getData(){
  console.log('infoObj', props.infoObj)
}
defineExpose({
  getData
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402133835998-232104998.png" alt="" loading="lazy"></p>
<h4 id="使用ref父组件第二次传递给子组件的数据不能获取到最新的数据">使用ref父组件第二次传递给子组件的数据：不能获取到最新的数据</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;h1&gt;子组件&lt;/h1&gt;
      &lt;child :infoObj='infoObj' ref="childRef"&gt;&lt;/child&gt;
    &lt;/div&gt;
    &lt;button @click='updateHandler'&gt;跟新值&lt;/button&gt;
    &lt;div&gt;
      &lt;h1&gt;父页面&lt;/h1&gt;
      &lt;p&gt;{{ infoObj }}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import child from '@/components/child.vue'
import { ref } from 'vue'
let infoObj = ref({
  name:'张三',
  age:26
})
const childRef = ref()
function updateHandler(){
  infoObj.value = {
    name:'李四',
    age:28
  }
  // 跟新值后，调用父组件的方法。看下getData是否可以获取到最新的值
  childRef.value.getData()
}
&lt;/script&gt;
</code></pre>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt; {{ props.infoObj }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
let props = defineProps({
  infoObj:Object,
})
function getData(){
  console.log('infoObj', props.infoObj)
}
defineExpose({
  getData
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402133848136-958439717.png" alt="" loading="lazy"></p>
<h4 id="办法1将数据作为函数的参数进行传递">办法1:将数据作为函数的参数进行传递</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;h1&gt;子组件&lt;/h1&gt;
      &lt;child :infoObj='infoObj' ref="childRef"&gt;&lt;/child&gt;
    &lt;/div&gt;
    &lt;button @click='updateHandler'&gt;跟新值&lt;/button&gt;
    &lt;div&gt;
      &lt;h1&gt;父页面&lt;/h1&gt;
      &lt;p&gt;{{ infoObj }}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import child from '@/components/child.vue'
import { ref } from 'vue'
let infoObj = ref({
  name:'张三',
  age:26
})
const childRef = ref()
function updateHandler(){
  infoObj.value = {
    name:'李四',
    age:28
  }
  // 将数据作为函数的参数进行传递
  childRef.value.getData(infoObj.value)
}
&lt;/script&gt;
</code></pre>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt; {{ props.infoObj }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
let props = defineProps({
  infoObj:Object,
})
function getData(mess:any){
  console.log('infoObj', props.infoObj)
  console.log('将数据作为函数的参数进行传递：mess', mess)
}
defineExpose({
  getData
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402133903455-916987854.png" alt="" loading="lazy"></p>
<h4 id="解决办法2在调用方法时使用-nexttick">解决办法2:在调用方法时使用 nextTick</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;h1&gt;子组件&lt;/h1&gt;
      &lt;child :infoObj='infoObj' ref="childRef"&gt;&lt;/child&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;h1&gt;父页面&lt;/h1&gt;
      &lt;p&gt;{{ infoObj }}&lt;/p&gt;
    &lt;/div&gt;
    &lt;button @click='updateHandler'&gt;跟新值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import child from '@/components/child.vue'
import { nextTick, ref } from 'vue'
let infoObj = ref({
  name:'张三',
  age:26
})
const childRef = ref()
function updateHandler(){
  infoObj.value = { name: '李四', age: 28 };
  // 推荐在这里使用nextTick
  nextTick(() =&gt; {
    childRef.value.getData()
  })
}
&lt;/script&gt;
</code></pre>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt; {{ props.infoObj }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
let props = defineProps({
  infoObj:Object,
})
function getData(){
  // 或者在这里使用nextTick。
  console.log('getData 方法获取值',  props.infoObj.name, props.infoObj.age)
}
defineExpose({
  getData
})
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402133915220-1905635730.png" alt="" loading="lazy"></p>
<h4 id="结论">结论</h4>
<p>使用ref父组件第二次传递给子组件的数据(基本数据和引用数据):不能获取到最新的数据。</p>
<h4 id="使用reactive和ref传递参数给子组件为啥ref第二次子组件无法获取最新的数据而reactive可以">使用reactive和ref传递参数给子组件，为啥ref第二次子组件无法获取最新的数据？而reactive可以</h4>
<p>在 Vue 3 中，reactive 和 ref 在传递给子组件时的行为有所不同。<br>
这也说明了 reactive 和 ref 是有区别的(屁话)。</p>
<h4 id="ref-和-reactive-的区别">ref 和 reactive 的区别</h4>
<p>1,ref可以试用于任何数据类型，而reactive只适用于对象类型。<br>
2,在js模块ref获取值,设置值,需要点value, ‌在模板中使用不需要点value。 而reactive都不需要。<br>
3,ref可以完全替换整个对象，不会失去响应式。<br>
reactive不能直接替换整个对象(否则会失去响应式)。需要逐个修改属性或使用 Object.assign<br>
4,返回值不同。ref返回一个‌包装对象‌。reactive返回一个‌Proxy 对象‌</p>
<h4 id="ref完全替换-不会失去响应式">ref完全替换 不会失去响应式</h4>
<pre><code>&lt;template&gt;
  &lt;button type="button" @click="updateHandler"&gt;更改数据&lt;/button&gt;
  &lt;p&gt;数据{{ objRef }}&lt;/p&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { ref } from 'vue';
const objRef = ref({ age: 1 })
function updateHandler(){
  //完全替换 不会失去响应式
  objRef.value = { age: 100 } 
}
&lt;/script&gt;
</code></pre>
<h4 id="reactive不能直接替换整个对象会失去响应式">reactive不能直接替换整个对象(会失去响应式)</h4>
<pre><code>const objReactive = reactive({ a: 1 })
// 错误方式（失去响应性）
objReactive = { b: 2 }

// 正确方式 或者逐个修改属性
Object.assign(objReactive, { b: 2 })
</code></pre>
<h4 id="错误ref解构不会失去响应式reactive解构或展开会失去响应式这句话不正确">[错误]:ref解构不会失去响应式。reactive解构或展开会失去响应式。[这句话不正确]</h4>
<p>ref和reactive解构都会失去响应式。都需要通过toRefs 或者toRef 来进行解决。</p>
<h4 id="reactive-解构会失去响应式">reactive 解构会失去响应式</h4>
<pre><code>&lt;template&gt;
  &lt;button type="button" @click="updateHandler"&gt;更改数据&lt;/button&gt;
  &lt;p&gt;数据{{ name }} {{  age}}&lt;/p&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { reactive } from 'vue';
const state = reactive({ name: '张三', age: 20 })
// reactive解构会失去响应式
let { name, age } = state
function updateHandler(){
  // 更新数据后，页面不会跟新
  name = '王麻子'
  age = 1000
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402134324489-1756687814.png" alt="" loading="lazy"></p>
<h4 id="ref-解构会失去响应式">ref 解构会失去响应式</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Name: {{ name }}&lt;/p&gt;
    &lt;p&gt;Age: {{ age }}&lt;/p&gt;
    &lt;button @click="changeName"&gt;Change Name&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'
// 使用 ref 创建响应式对象
const user = ref({
  name: 'Alice',
  age: 25
})
// 解构 ref 对象 - 会失去响应式,视图不会跟新
let { name, age } = user.value
function changeName() {
  name = 'Bob' // 直接修改解构出来的属性
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402133951306-266172927.png" alt="" loading="lazy"></p>
<h4 id="torefs解构ref解构后仍然保持响应式">toRefs()​解构ref，解构后仍然保持响应式</h4>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Name: {{ name }}&lt;/p&gt;
    &lt;p&gt;Age: {{ age }}&lt;/p&gt;
    &lt;button @click="changeName"&gt;Change Name&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref,toRefs } from 'vue'
// 使用 ref 创建响应式对象
const user = ref({
  name: 'Alice',
  age: 25
})
// 通过toRefs解构不会失去响应式
let { name, age } = toRefs(user.value) 
function changeName() {
  name.value = '大大再大' // 直接修改解构出来的属性
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402134001323-432402982.png" alt="" loading="lazy"></p>
<h4 id="toref解构reactive解构后仍然保持响应式">toRef()​解构reactive，解构后仍然保持响应式</h4>
<pre><code>&lt;template&gt;
  &lt;button type="button" @click="updateHandler"&gt;更改数据&lt;/button&gt;
  &lt;p&gt;数据{{ name }} {{  age}}&lt;/p&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { reactive, toRefs } from 'vue';
const state = reactive({ name: '张三', age: 20 })
// 通过toRefs解构不会失去响应式
let { name, age } =  toRefs(state) 
function updateHandler(){
  // 更新数据后，页面不会跟新
  name.value = '王麻子'
  age.value = 1000
}
&lt;/script&gt;
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202504/1425695-20250402134012334-611550345.png" alt="" loading="lazy"></p>
<h4 id="torefs">toRefs()​</h4>
<p>官网:将一个响应式对象转换为一个普通对象。<br>
这个普通对象的[每个属性]都是指向源对象[相应属性的] ref。<br>
每个单独的 ref 都是使用 toRef() 创建的。<br>
我的理解：<br>
toRefs 可以把一个响应式对象转换为普通的对象。<br>
该普通对象的每一个值都是ref。<br>
由于变成了ref，所以我们使用每个属性的时候需要点value。</p>
<h4 id="ref和reactive的使用场景">ref和reactive的使用场景</h4>
<p>ref 适合于基本数据类型，reactive适合于对象类型。<br>
ref 适合完全替换整个对象<br>
我喜欢用ref定义基本数据类型和数组。对象使用reactive。</p>
<h4 id="ref的本质">ref的本质</h4>
<p>我理解的ref本质上是reactive的再封装。<br>
使用reactive定义响应式数据时，若数据不是对象类型直接就返回了。<br>
就不会进行后续的数据响应式处理了。<br>
这也就是我只用reactive定义对象型响应式数据的原因</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.023974086431712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-02 13:47">2025-04-02 13:46</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18805791" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18805791);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18805791', targetLink: 'https://www.cnblogs.com/IwishIcould/p/18805791', title: 'vue3第二次传递数据方法无法获取到最新的值' })">举报</a>
</div>
        