
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youring2/p/18799312" title="发布于 2025-03-29 11:54">
    <span role="heading" aria-level="2">Ollama本地部署大模型总结</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>日拱一卒，功不唐捐</p>
</blockquote>
<p>今天计划对之前ollama系列做个回顾，从如何部署到API使用，整理到一篇内容中，提供给大家参考。</p>
<h2 id="安装指南">安装指南</h2>
<h3 id="第一步安装ollama">第一步：安装ollama</h3>
<p>我们可以从官网下载ollama，此步骤支持windows、mac、ubuntu操作系统，此处仅以windows作为演示。</p>
<p>打开ollama官网：<a href="https://ollama.com" target="_blank" rel="noopener nofollow">https://ollama.com</a>  点击download按钮进行下载，下载完成后点击安装。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319366-1934347161.png" alt="" loading="lazy"></p>
<p>安装完成后，你的电脑右下角会有ollama的图标（如果没有看到，可以展开这点的状态栏检查）</p>
<p>验证安装是否成功：打开命令行（<code>WIN+R</code>，在运行中输入<code>cmd</code>后回车），输入<code>ollama --version</code>，如果命令执行成功，并输出了版本信息，说明安装成功了。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319341-955593310.png" alt="" loading="lazy"></p>
<h3 id="第二步下载deepseek">第二步：下载deepseek</h3>
<p>打开命令行（<code>WIN+R</code>，在运行中输入<code>cmd</code>后回车），下载并运行deepseek-r1 1.5b蒸馏版。</p>
<pre><code>ollama run deepseek-r1:1.5b
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319317-1033336789.png" alt="" loading="lazy"></p>
<p>下载完成后，ollama会为我们运行刚下载的大模型。下面是我运行成功的截图：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319352-2086000505.png" alt="" loading="lazy"></p>
<h3 id="第三步使用大模型">第三步：使用大模型</h3>
<p>恭喜你已经在本地成功安装了第一个私有大模型。运行成功以后，我们可以直接在命令行和deepseek对话。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319428-1462200247.png" alt="" loading="lazy"></p>
<p>如你所见，这就是一个简单的对话窗口，也是大模型最原始的形态。</p>
<h2 id="使用指南">使用指南</h2>
<p>安装完成后我们看到的是一个命令行窗口，使用起来并不方便。为了解决这个问题，我们需要将ollama集成到常用的AI工具中进行使用。</p>
<h3 id="chatbox篇">Chatbox篇</h3>
<p>进入下载页面 <a href="https://chatboxai.app/zh" target="_blank" rel="noopener nofollow">https://chatboxai.app/zh</a> 点击免费下载，下载完成后双击下载文件，完成安装。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319329-54626238.png" alt="image" loading="lazy"></p>
<p>安装完成后打开，你会看到一个聊天窗口：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319347-2057419478.png" alt="image" loading="lazy"></p>
<h4 id="使用ollama中的大模型">使用ollama中的大模型</h4>
<p>我们在上一篇中在本地安装了ollama和deepseek，现在我们把它集成到刚安装的chatbox中。</p>
<p>点击chatbox左下角的设置，我们仅需要三步即可完成配置：</p>
<ol>
<li>模型提供方，选择Ollama API</li>
<li>API域名，使用默认值</li>
<li>模型下拉框，我们选择deepseek-r1:1.5b</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319330-1400539800.png" alt="image" loading="lazy"></p>
<p>设置完成后点击保存，我们就完成了ollama的集成。</p>
<h4 id="和本地大模型对话">和本地大模型对话</h4>
<p>点击左侧新对话，开启新的对话。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319326-1930033781.png" alt="image" loading="lazy"></p>
<p>向大模型提问试试吧</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319380-1943167544.png" alt="image" loading="lazy"></p>
<h4 id="创建智能体">创建智能体</h4>
<p>恭喜你已经完成了ollama和chatbox的集成，现在你的对话数据都保留在本地，绝对的安全和隐私。</p>
<p>接下来，我们要定义一个自己的智能体，它可以为你完成特定的任务。</p>
<p>点击左下方的“我的搭档”，可以看到里面有很多chatbox预设的智能体：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319362-2034875405.png" alt="image" loading="lazy"></p>
<p>如果没有找到你想要的，那么我们可以自定义一个智能体，让deepseek帮我们写周报。</p>
<p><strong>点击新增</strong></p>
<p>点击“创建新的AI搭档”按钮，打开创建智能体的对话框。我们需要两步：</p>
<ol>
<li>输入搭档名称：周报生成器</li>
<li>输入人物设定：</li>
</ol>
<pre><code class="language-txt">角色：你是一个高效可靠的周报生成器，能够将用户输入的信息转化为一份高质量的周报。
目标：收集用户输入的工作内容，对工作内容进行筛选和精简，做好排版，将排版好的周报输出。阅读对象是直属领导，需要注意语气和措辞
</code></pre>
<ol start="3">
<li>勾选掉分享给其它用户，然后保存</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319433-488338876.png" alt="image" loading="lazy"></p>
<h4 id="使用周报生成器">使用周报生成器</h4>
<p>回到“我的搭档”对话框，点击刚刚定义好的周报生成器，开启新的对话窗口。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319302-175626384.png" alt="image" loading="lazy"></p>
<p>输入你本周的工作内容，试试deepseek帮你生成的周报吧</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319350-1351823832.png" alt="image" loading="lazy"></p>
<p>我这里看着还不错，甚至可以直接发给领导了，你生成的内容怎么样？遇到任何问题欢迎评论区和我交流</p>
<h3 id="cherrystudio篇">CherryStudio篇</h3>
<blockquote>
<p>CherryStudio 是一款集多模型对话、知识库管理、AI 绘画、翻译等功能于一体的全能 AI 助手平台。 CherryStudio的高度自定义的设计、强大的扩展能力和友好的用户体验，使其成为专业用户和 AI 爱好者的理想选择。无论是零基础用户还是开发者，都能在 CherryStudio 中找到适合自己的AI功能，提升工作效率和创造力。</p>
</blockquote>
<h4 id="安装cherrystudio">安装cherryStudio</h4>
<p>官网地址：<a href="https://cherry-ai.com/" target="_blank" rel="noopener nofollow">https://cherry-ai.com/</a><br>
源代码地址：<a href="https://github.com/CherryHQ/cherry-studio" target="_blank" rel="noopener nofollow">https://github.com/CherryHQ/cherry-studio</a></p>
<p>从官网进行下载，小伙伴们注意，这个软件是完全免费的，不要相信任何收费版。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319415-1296429276.png" alt="" loading="lazy"></p>
<p>下载完成后进行安装。运行起来后界面如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319339-1632121444.png" alt="" loading="lazy"></p>
<h4 id="集成ollama中的本地模型">集成ollama中的本地模型</h4>
<p>将cherryStudio运行起来后，点击界面左下角的小齿轮进行设置。</p>
<ol>
<li>点击左下角的小齿轮打开设置</li>
<li>在模型列表中选择ollama</li>
<li>点击右上角开关打开ollama</li>
<li>API密钥空着不要填，API地址使用本地地址</li>
<li>点击管理，选择我们之前已经下载的deepseek r1模型</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319391-1580792496.png" alt="" loading="lazy"></p>
<p>设置完成后点击左上角的聊天图标，即可开始进行AI对话了。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319354-1074864745.png" alt="" loading="lazy"></p>
<p>恭喜你，完成这一步骤，我们就已经成功的将ollama和cherryStudio集成到了一起。接下来让我们试试创建智能体吧。</p>
<h4 id="创建智能体-1">创建智能体</h4>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319351-1550727194.png" alt="" loading="lazy"></p>
<p>在cherryStudio中集成了很多智能体，你只需要点击添加即可开始使用。</p>
<p>我们点击右侧“创建智能体”来创建一个自定义的智能体。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319378-536821896.png" alt="" loading="lazy"></p>
<p>名字：周报生成器<br>
提示词：</p>
<blockquote>
<p>角色：你是一个高效可靠的周报生成器，能够将用户输入的信息转化为一份高质量的周报。<br>
目标：收集用户输入的工作内容，对工作内容进行筛选和精简，做好排版，将排版好的周报输出。阅读对象是直属领导，需要注意语气和措辞</p>
</blockquote>
<p>创建完成后，点击智能体，添加到助手中。然后回到聊天界面，使用新创建的智能体开始对话：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319371-1615922778.png" alt="" loading="lazy"></p>
<h3 id="搭建知识库">搭建知识库</h3>
<blockquote>
<p>AI知识库，作为人工智能技术与传统知识库概念的融合，是指利用人工智能算法和技术构建、管理和维护的信息存储系统。它不仅包含了大量的结构化、半结构化和非结构化数据，还具备智能检索、推理分析、自我学习和优化等高级功能。AI知识库通过模拟人类的认知过程，实现了对知识的有效组织和高效利用，为各种应用场景提供了强大的支持。</p>
</blockquote>
<h4 id="知识库是如何工作的">知识库是如何工作的？</h4>
<p>知识库工作流程图（来源于CherryStudio Doc）：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319439-2025681413.png" alt="" loading="lazy"></p>
<p>在上面的流程图里，我们可以看到知识库工作的步骤：</p>
<ol>
<li>用户提问时，AI工具先查询知识库里已有的内容</li>
<li>将查询到的内容和用户的提问发送给大模型</li>
<li>大模型根据提供的内容生成答案</li>
</ol>
<p>使用知识库增强检索来生成答案的技术有一个专门的名词RAG，这里面涉及到几个概念，如果你感兴趣可以继续深挖（由于本篇内容针对的是入门教程，不做太多概念性的讲解，后面有机会了再专门介绍）</p>
<h4 id="构建私有知识库">构建私有知识库</h4>
<p>接下来我们通过cherryStudio来构建私有的知识库。</p>
<p>首先打开cherryStudio，点击左侧的知识库：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319334-1514372924.png" alt="" loading="lazy"></p>
<p><strong>获取嵌入模型</strong><br>
在构建知识库的过程中，需要选择要使用的嵌入模型。嵌入模型的主要功能是将用户的文本、图片等内容生成向量数据，用作向量搜索的。</p>
<p>在ollama中有很多嵌入模型供我们选择使用。我这里使用的是bge-m3，你可以通过下面的指令获取：</p>
<pre><code class="language-txt">ollama pull bge-m3
</code></pre>
<p><em>注意：嵌入模型保存后不允许修改</em></p>
<p><strong>添加知识内容</strong><br>
为了进行演示，我们将本系列教程的前三篇放入知识库中：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319339-2102540814.png" alt="" loading="lazy"></p>
<p>然后创建一个新的对话，在对话中选择创建的知识库：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319426-1915334628.png" alt="" loading="lazy"></p>
<p>验证一下效果（效果并不理想）：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319412-1112331189.png" alt="" loading="lazy"></p>
<p>话外音</p>
<blockquote>
<p>感觉deepseek又开始一本正经的胡说八道了，这可能和我们选择的模型有关，我们当前使用的是1.5b的模型，如果你的硬件允许，可以尝试下载更大的模型进行测试</p>
</blockquote>
<p>我换了一个deepseek-r1:7b的模型重新验证了一下，效果比上面的要好一些：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319450-2004743180.png" alt="" loading="lazy"></p>
<h4 id="影响知识库的因素">影响知识库的因素</h4>
<p>通过上面的例子我们可以看到，当切换了模型之后，生成内容的准确性有所提高。这说明我们需要尝试不同的模型，来达到自己满意的效果。</p>
<p>通常来说影响知识库输出质量的因素有：</p>
<ul>
<li>文档的质量</li>
<li>嵌入模型的能力</li>
<li>向量数据库的检索</li>
<li>文档相关性排序能力</li>
<li>系统Prompt质量</li>
<li>大模型生成能力</li>
</ul>
<p>当我们在进行实践时，切记一定要先进行验证，验证满意后再进行大规模的实施。</p>
<h2 id="ollama-api-使用指南">Ollama API 使用指南</h2>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319390-672540360.png" alt="" loading="lazy"></p>
<p>Ollama 提供了一套简单好用的接口，让开发者能通过API轻松使用大语言模型。</p>
<p>本篇内容将使用Postman作为请求工具，和开发语言无关。</p>
<h3 id="基本概念">基本概念</h3>
<p>在开始之前，我们先了解几个基本的概念：</p>
<ul>
<li><strong>Model</strong>：模型，我们调用接口时使用的模型名字。我们可以把Ollama理解为模型商店，它里面运行着很多模型，每个模型都有一个唯一的名字，例如<code>deepseek-r1:1.5b</code></li>
<li><strong>Prompt</strong>: 提示词，是我们给模型的指令。比如<code>天空为什么是蓝色的</code>就是一条简单的提示词。</li>
<li><strong>Token</strong>：字符块，是大模型的最小输出单位，同时也是大模型的计费单位。举个例子，对于<code>天空为什么是蓝色的</code>这句话，大模型会进行拆分<code>天空/为什么/是/蓝色/的</code>，每一段就是一个token（实际情况会比这个例子复杂）</li>
</ul>
<h3 id="内容生成apigenerate">内容生成（/api/generate）</h3>
<p>让大模型帮我们生成指定的内容，就可以使用内容生成接口。一问一答，不带上下文。</p>
<p>我们试着用最少的参数来调用：</p>
<pre><code>{
  "model": "deepseek-r1:1.5b",
  "prompt": "天空为什么是蓝色的"
}
</code></pre>
<p>在postman里面看看输出：</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319366-1743650838.png" alt="" loading="lazy"></p>
<p>可以看到输出的内容很长，这是因为默认采用的是stream的方式输出的，也就是我们在deepseek app里面看到的一个字一个字输出的那种效果。我们可以将stream参数设置成false来禁用流式输出。</p>
<pre><code>{
    "model": "deepseek-r1:1.5b",
    "prompt": "天空为什么是蓝色的",
    "stream": false
}
</code></pre>
<p><strong>参数列表</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必填</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td>是</td>
<td>模型名称</td>
</tr>
<tr>
<td><code>prompt</code></td>
<td>是</td>
<td>需要生成响应的提示词</td>
</tr>
<tr>
<td><code>suffix</code></td>
<td>否</td>
<td>模型响应后追加的文本</td>
</tr>
<tr>
<td><code>images</code></td>
<td>否</td>
<td>Base64编码的图片列表（适用于多模态模型如llava）</td>
</tr>
<tr>
<td><code>format</code></td>
<td>否</td>
<td>返回响应的格式（可选值：<code>json</code> 或符合 JSON Schema 的结构）</td>
</tr>
<tr>
<td><code>options</code></td>
<td>否</td>
<td>模型额外参数（对应 Modelfile 文档中的配置如 <code>temperature</code>）</td>
</tr>
<tr>
<td><code>system</code></td>
<td>否</td>
<td>自定义系统消息（覆盖 Modelfile 中的定义）</td>
</tr>
<tr>
<td><code>template</code></td>
<td>否</td>
<td>使用的提示词模板（覆盖 Modelfile 中的定义）</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>否</td>
<td>设为 <code>false</code> 时返回单个响应对象而非流式对象</td>
</tr>
<tr>
<td><code>raw</code></td>
<td>否</td>
<td>设为 <code>true</code> 时不格式化提示词（适用于已指定完整模板的情况）</td>
</tr>
<tr>
<td><code>keep_alive</code></td>
<td>否</td>
<td>控制模型在内存中的保持时长（默认：5m）</td>
</tr>
<tr>
<td><code>context</code></td>
<td>否</td>
<td>（已弃用）来自前次 <code>/generate</code> 请求的上下文参数，用于维持短期对话记忆</td>
</tr>
</tbody>
</table>
<h3 id="生成对话apichat">生成对话（/api/chat）</h3>
<p>生成对话，是一种具备上下文记忆的内容生成。在内容生成API中，我们仅传入了prompt，大模型仅对我们本地的prompt进行回答，而在生成对话API中，我们还可以传入messages参数，包含我们多轮对话内容，使大模型具备记忆功能。</p>
<p><strong>最简单的调用</strong>（为了方便演示，我们将stream参数设置为false）：</p>
<pre><code>{
    "model": "deepseek-r1:1.5b",
    "messages": [
        {
            "role": "user",
            "content": "天空通常是什么颜色"
        }
    ],
    "stream": false
}
</code></pre>
<p>postman调用截图：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319372-285243481.png" alt="" loading="lazy"></p>
<p><strong>多轮对话</strong></p>
<p>聊天的时候，ollama通过messages参数保持上下文记忆。当模型给我们回复内容之后，如果我们要继续追问，则可以使用以下方法（<strong>注意：deepseek-r1模型需要在上下文中移除think中的内容</strong>）：</p>
<pre><code>{
    "model": "deepseek-r1:1.5b",
    "messages": [
        {
            "role": "user",
            "content": "天空通常是什么颜色"
        },
        {
            "role": "assistant",
            "content": "天空通常看起来是**柔和的、明快的或稍微有些昏黄的色调**。具体颜色可能会因不同的天气情况而有所变化，例如：\n\n1. **晴朗天气**：天空可能呈现出温暖、明亮的颜色，比如蓝天、碧空等。\n2. **下雨天**：云层覆盖天空，可能导致颜色较为阴郁或变黑。\n3. **雨后天气**：雨后的天空可能恢复为明亮的色调。\n\n总的来说，天空的颜色主要取决于大气中的光线反射和折射情况，以及太阳的位置。"
        },
        {
            "role": "user",
            "content": "为什么是蓝色的？"
        }
    ],
    "stream": false
}
</code></pre>
<p>postman调用截图：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319411-2000825804.png" alt="" loading="lazy"></p>
<p><strong>结构化数据提取</strong></p>
<p>当我们和系统对接时，通常要需要从用户的自然语言中提到结构化数据，用来调用现有的外部系统的接口。在ollama中我们只需要指定format参数，就可以实现结构化数据的提取：</p>
<pre><code>{
    "model": "deepseek-r1:1.5b",
    "messages": [
        {
            "role": "user",
            "content": "哈喽，大家好呀~ 我是拓荒者IT，今年36岁了，是一名软件工程师"
        }
    ],
    "format": {
        "type": "object",
        "properties": {
            "name": {
                "type": "string"
            },
            "age": {
                "type": "integer"
            },
            "job": {
                "type": "string"
            }
        },
        "required": [
            "name",
            "age",
            "job"
        ]
    },
    "stream": false
}
</code></pre>
<p><strong>参数列表</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必填</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td>是</td>
<td>模型名称</td>
</tr>
<tr>
<td><code>messages</code></td>
<td>是</td>
<td>聊天消息数组（用于维持对话记忆）</td>
</tr>
<tr>
<td><code>messages.role</code></td>
<td>是</td>
<td>消息角色（可选值：<code>system</code>, <code>user</code>, <code>assistant</code>, <code>tool</code>）</td>
</tr>
<tr>
<td><code>messages.content</code></td>
<td>是</td>
<td>消息内容</td>
</tr>
<tr>
<td><code>messages.images</code></td>
<td>否</td>
<td>消息中Base64编码的图片列表（适用于多模态模型如llava）</td>
</tr>
<tr>
<td><code>messages.tool_calls</code></td>
<td>否</td>
<td>模型希望调用的工具列表（JSON格式）</td>
</tr>
<tr>
<td><code>tools</code></td>
<td>否</td>
<td>模型可使用的工具列表（JSON格式，需模型支持）</td>
</tr>
<tr>
<td><code>format</code></td>
<td>否</td>
<td>返回响应的格式（可选值：<code>json</code> 或符合 JSON Schema 的结构）</td>
</tr>
<tr>
<td><code>options</code></td>
<td>否</td>
<td>模型额外参数（对应 Modelfile 文档中的配置如 <code>temperature</code>）</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>否</td>
<td>设为 <code>false</code> 时返回单个响应对象而非流式对象</td>
</tr>
<tr>
<td><code>keep_alive</code></td>
<td>否</td>
<td>控制模型在内存中的保持时长（默认：5m）</td>
</tr>
</tbody>
</table>
<h3 id="生成嵌入数据apiembed">生成嵌入数据（/api/embed）</h3>
<p>嵌入数据的作用是将输入内容转换成向量，可以用于向量检索等场景。比如我们在第四篇中介绍的知识库，就需要用到embedding模型。</p>
<p>在调用embed接口时，我们要选择支持Embedding功能的模型，deepseek是不支持的。</p>
<p>调用示例：</p>
<pre><code>{
  "model": "bge-m3",
  "input": "为什么天空是蓝色的呢？"
}
</code></pre>
<p>postman调用截图：<br>
<img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319361-1250851691.png" alt="" loading="lazy"></p>
<h3 id="兼容openai接口">兼容openAI接口</h3>
<p>因为现在很多应用、类库都是基于OpenAI构建的，为了让这些系统能够使用Ollama提供的模型，Ollama提供了一套兼容OpenAI的接口（官方说是实验性的，以后可能会有重大调整）。</p>
<p>因为这种兼容，使得我们可以直接通过OpenAI的python库、node库来访问ollama的服务，确实方便了不少。</p>
<p><strong>注意：ollama属于第三方接口，不能100%支持OpenAI的接口能力，因此在使用的时候需要先了解清楚兼容的情况。</strong></p>
<h3 id="其它接口">其它接口</h3>
<p>ollama还有一些其它的接口，用来实现对模型的管理等功能，而这些功能我们通常会在命令行完成，因此不做详细说明。这些API的列表如下：</p>
<ul>
<li>模型创建（/api/create）</li>
<li>列出本地模型（/api/tags）</li>
<li>查看模型信息（/api/show）</li>
<li>复制模型（/api/copy）</li>
<li>删除模型（/api/delete）</li>
<li>拉取模型（/api/pull）</li>
<li>推送（上传）模型（/api/push）</li>
<li>列出运行中的模型（/api/ps）</li>
<li>查看ollama版本（/api/version）</li>
</ul>
<p>这些接口的调用都非常简单，大家感兴趣的可以尝试以下。</p>
<h2 id="c集成指南">C#集成指南</h2>
<p>Ollama 提供了HTTP API的访问，如果需要使用SDK集成到项目中，需要引用第三方库<code>OllamaSharp</code>，直接使用nuget进行安装即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319380-1866625574.png" alt="" loading="lazy"></p>
<h3 id="ollamasharp功能亮点">OllamaSharp功能亮点</h3>
<ul>
<li>简单易用：几行代码就能玩转Ollama</li>
<li>值得信赖：已为Semantic Kernal、.NET Aspire和Microsoft.Extensions.AI提供支持</li>
<li>全接口覆盖：支持所有Ollama API接口，包括聊天对话、嵌入生成、模型列表查看、模型下载与创建等</li>
<li>实时流传输：直接将响应流推送到您的应用</li>
<li>进度可视化：实时反馈模型下载等任务的进度状态</li>
<li>工具引擎：通过源码生成器提供强大的工具支持</li>
<li>多模态能力：支持视觉模型处理</li>
</ul>
<h3 id="调用示例">调用示例</h3>
<p><strong>初始化client</strong></p>
<pre><code>// set up the client
var uri = new Uri("http://localhost:11434");
var ollama = new OllamaApiClient(uri);
</code></pre>
<p><strong>获取模型列表</strong></p>
<pre><code>// list models
var models = await ollama.ListLocalModelsAsync();
if (models != null &amp;&amp; models.Any())
{
    Console.WriteLine("Models: ");
    foreach (var model in models)
    {
        Console.WriteLine("  " + model.Name);
    }
}
</code></pre>
<p><strong>创建对话</strong></p>
<pre><code>// chat with ollama
var chat = new Chat(ollama);
Console.WriteLine();
Console.WriteLine($"Chat with {ollama.SelectedModel}");

while (true)
{
    var currentMessageCount = chat.Messages.Count;

    Console.Write("&gt;&gt;");
    var message = Console.ReadLine();
    await foreach (var answerToken in chat.SendAsync(message, Tools))
        Console.Write(answerToken);

    Console.WriteLine();

    // find the latest message from the assistant and possible tools
    var newMessages = chat.Messages.Skip(currentMessageCount - 1);
    foreach (var newMessage in newMessages)
    {
        if (newMessage.ToolCalls?.Any() ?? false)
        {
            Console.WriteLine("\nTools used:");

            foreach (var function in newMessage.ToolCalls.Where(t =&gt; t.Function != null).Select(t =&gt; t.Function))
            {
                Console.WriteLine($"  - {function!.Name}");
                Console.WriteLine($"    - parameters");

                if (function?.Arguments is not null)
                {
                    foreach (var argument in function.Arguments)
                        Console.WriteLine($"      - {argument.Key}: {argument.Value}");
                }
            }
        }

        if (newMessage.Role.GetValueOrDefault() == OllamaSharp.Models.Chat.ChatRole.Tool)
            Console.WriteLine($"    - results: \"{newMessage.Content}\"");
    }
}
</code></pre>
<p><strong>Tools</strong></p>
<p>如果是LLM是大脑，那么工具就是四肢，通过工具我们能具备LLM与外界交互的能力。</p>
<p>定义工具：</p>
<pre><code>/// &lt;summary&gt;
/// Gets the current datetime
/// &lt;/summary&gt;
/// &lt;returns&gt;The current datetime&lt;/returns&gt;
[OllamaTool]
public static string GetDateTime() =&gt; $"{DateTime.Now: yyyy-MM-dd HH:mm:ss ddd}";
</code></pre>
<p>使用工具：</p>
<pre><code>public static List&lt;object&gt; Tools { get; } = [
    new GetDateTimeTool(),
];

await chat.SendAsync(message, Tools)
</code></pre>
<p>以上就是近期Ollama系列的回顾，感兴趣的朋友可以关注我的公众号 <strong>[拓荒者IT]</strong> 了解更多内容！</p>
<p>👉 <strong>持续分享AI工具，AI应用场景，AI学习资源</strong> ❤️</p>
<p><img src="https://img2024.cnblogs.com/blog/44814/202503/44814-20250329115319443-61530221.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0167569464224537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-29 11:54">2025-03-29 11:54</span>&nbsp;
<a href="https://www.cnblogs.com/youring2">拓荒者IT</a>&nbsp;
阅读(<span id="post_view_count">207</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18799312" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18799312);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18799312', targetLink: 'https://www.cnblogs.com/youring2/p/18799312', title: 'Ollama本地部署大模型总结' })">举报</a>
</div>
        