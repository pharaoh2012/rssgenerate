
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chingho/p/18896462" title="发布于 2025-05-26 10:25">
    <span role="heading" aria-level="2">C#实现MCP Client 与 LLM 连接，抓取网页内容功能！</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>前面的课程，我们已经用C#实现了，自己的MCP Client。</p>
<p>下面我们一起来实现，MCP Client与LLM 对接。</p>
<h1 id="一添加依赖库">一、添加依赖库</h1>
<p>目前来说，绝大部分的大模型的API，都是遵循OpenAI的接口规范。</p>
<p>Microsoft.Extensions.AI 是微软官方提供的一套 统一的 AI 抽象层 ，大大简化 AI 模型在 .NET 应用中的集成。</p>
<p>添加依赖库：Microsoft.Extensions.AI.OpenAI，版本为：最新预发行版 9.4.4-preview.1.25259.16<strong>，添加的时候记得勾选：包括预发行版。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102445697-68499631.png" alt="图片" loading="lazy"></p>
<p>添加依赖库：Microsoft.Extensions.AI，版本为：9.4.4-preview.1.25259.16。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102445217-849530122.png" alt="图片" loading="lazy"></p>
<h1 id="二openai-客户端实现">二、OpenAI 客户端实现</h1>
<p>新增文件：<strong>ChatAIClient</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102444780-444407118.png" alt="图片" loading="lazy"></p>
<h2 id="21-初始化openai客户端">2.1 初始化OpenAI客户端</h2>
<hr>
<p>初始化OpenAI客户端，并使用UseFunctionInvocation 来增强客户端， 这里启用函数调用。</p>
<p><strong>备注：以下代码涉及的秘钥，记得替换为自己的。</strong></p>
<pre><code>using&nbsp;Microsoft.Extensions.AI;
using&nbsp;OpenAI;
using&nbsp;System.ClientModel;
namespace&nbsp;MCPClient
{
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp;&nbsp;///&nbsp;表示一个用于与 AI 聊天模型交互的客户端封装类。
&nbsp; &nbsp;&nbsp;///&nbsp;负责初始化聊天客户端并维护对话上下文。
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp;&nbsp;public&nbsp;class&nbsp;ChatAIClient
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;封装后的 AI 聊天客户端接口，支持函数调用等功能。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;IChatClient ChatClient;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;存储当前会话中的所有聊天消息记录。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;IList&lt;ChatMessage&gt; Messages;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;API 访问密钥，用于身份认证。【记得替换为自己的】
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;const&nbsp;string&nbsp;_apiKey =&nbsp;"6092598c-ce00-48fd-a5be-0d758088c888";
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;AI 服务的基础请求地址。【记得替换为自己的】
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;const&nbsp;string&nbsp;_baseURL =&nbsp;"https://api-inference.modelscope.cn/v1/";
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;使用的 AI 模型标识符。【记得替换为自己的】
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;const&nbsp;string&nbsp;_modelID =&nbsp;"Qwen/Qwen2.5-72B-Instruct";
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;初始化一个新的&nbsp;&lt;see cref="ChatAIClient"/&gt;&nbsp;实例。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;构造函数中自动完成聊天客户端的初始化配置。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;ChatAIClient()
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitIChatClient();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;初始化内部使用的 AI 聊天客户端实例。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;配置 API 凭证、服务端点，并构建具备函数调用能力的客户端。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;同时初始化系统消息作为对话起点。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;InitIChatClient()
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 创建 API 密钥凭证
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ApiKeyCredential apiKeyCredential =&nbsp;new&nbsp;ApiKeyCredential(_apiKey);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 设置 OpenAI 客户端选项，如自定义服务端点
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpenAIClientOptions openAIClientOptions =&nbsp;new&nbsp;OpenAIClientOptions();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; openAIClientOptions.Endpoint =&nbsp;new&nbsp;Uri(_baseURL);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 创建 OpenAI 客户端并获取指定模型的聊天接口
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;openaiClient =&nbsp;new&nbsp;OpenAIClient(apiKeyCredential, openAIClientOptions)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .GetChatClient(_modelID)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .AsIChatClient();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 构建增强功能的聊天客户端（例如启用函数调用）
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ChatClient =&nbsp;new&nbsp;ChatClientBuilder(openaiClient)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .UseFunctionInvocation()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .Build();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 初始化对话历史，包含一条系统提示信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Messages =
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 添加系统角色消息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new(ChatRole.System,&nbsp;"您是一位乐于助人的助手，帮助我们测试MCP服务器功能，优先使用中文回答！"),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ];
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
</code></pre>
<h2 id="22-处理用户的自然语言查询">2.2 处理用户的自然语言查询</h2>
<p>在<strong>ChatAIClient文件，添加如下代码，实现与 AI 模型交互，并传入 MCP 工具。</strong></p>
<pre><code>///&nbsp;&lt;summary&gt;
///&nbsp;异步处理用户的自然语言查询，并与 AI 模型进行交互，支持 MCP 工具调用。
///&nbsp;&lt;/summary&gt;
///&nbsp;&lt;param name="query"&gt;用户的自然语言查询内容&lt;/param&gt;
///&nbsp;&lt;param name="tools"&gt;可用的 MCP 工具列表，用于扩展 AI 的外部能力&lt;/param&gt;
///&nbsp;&lt;returns&gt;AI 返回的最终文本响应结果&lt;/returns&gt;
public&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;ProcessQueryAsync(string&nbsp;query, IList&lt;McpClientTool&gt; tools)
{
&nbsp; &nbsp;&nbsp;// 如果消息历史为空，则初始化系统提示消息
&nbsp; &nbsp;&nbsp;if&nbsp;(Messages.Count ==&nbsp;0)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Messages =&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new(ChatRole.System,&nbsp;"您是一位乐于助人的助手，帮助我们测试MCP服务器功能，优先使用中文回答！")
&nbsp; &nbsp; &nbsp; &nbsp; ];
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 添加用户输入的消息到对话历史
&nbsp; &nbsp; Messages.Add(new(ChatRole.User, query));
&nbsp; &nbsp;&nbsp;// 设置请求选项，注入可用工具
&nbsp; &nbsp;&nbsp;var&nbsp;options =&nbsp;new&nbsp;ChatOptions
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Tools = [.. tools]
&nbsp; &nbsp; };
&nbsp; &nbsp;&nbsp;// 调用 AI 客户端获取响应
&nbsp; &nbsp;&nbsp;var&nbsp;response =&nbsp;await&nbsp;ChatClient.GetResponseAsync(Messages, options);
&nbsp; &nbsp;&nbsp;// 将 AI 响应加入对话历史
&nbsp; &nbsp; Messages.AddMessages(response);
&nbsp; &nbsp;&nbsp;// 输出调用的工具信息
&nbsp; &nbsp; OutputToolUsageInfo(response);
&nbsp; &nbsp;&nbsp;// 返回模型生成的文本响应
&nbsp; &nbsp;&nbsp;return&nbsp;response.Text;
}
</code></pre>
<h2 id="23-mcp-工具使用情况日志">2.3 MCP 工具使用情况日志</h2>
<hr>
<p>在<strong>ChatAIClient文件，添加如下代码，输出 AI 调用MCP 工具的情况。</strong></p>
<pre><code>&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp;&nbsp;///&nbsp;辅助方法：输出 AI 在响应中调用的工具信息到控制台。
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;param name="response"&gt;来自 AI 的完整响应对象&lt;/param&gt;
&nbsp; &nbsp;&nbsp;private&nbsp;void&nbsp;OutputToolUsageInfo(ChatResponse response)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 获取所有 Tool 角色的消息
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;toolUseMessages = response.Messages.Where(m =&gt; m.Role == ChatRole.Tool).ToList();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 判断是否调用了工具
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 获取响应中所有角色为 Tool 的消息（即 AI 调用了哪些工具）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;toolUseMessage = response.Messages.Where(m =&gt; m.Role == ChatRole.Tool);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 判断第一条消息的内容是否多于一个（通常第一个消息是用户问题，第二个是调用函数）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(response.Messages[0].Contents.Count &gt;&nbsp;1)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 尝试从第一条消息的第二个内容项提取出函数调用信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;functionCall = (FunctionCallContent)response.Messages[0].Contents[1];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 设置控制台输出颜色为绿色，用于突出显示工具调用信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.Green;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;string&nbsp;arguments =&nbsp;"";
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果函数调用包含参数，则拼接参数信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(functionCall.Arguments !=&nbsp;null)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;foreach&nbsp;(var&nbsp;arg&nbsp;in&nbsp;functionCall.Arguments)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arguments +=&nbsp;$"{arg.Key}:{arg.Value};";
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 输出调用的方法名及参数信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine($"调用方法名:{functionCall.Name};参数信息：{arguments}");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 遍历所有 Tool 消息，输出每个工具调用的结果
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;foreach&nbsp;(var&nbsp;message&nbsp;in&nbsp;toolUseMessage)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 提取工具调用后的执行结果
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;functionResultContent = (FunctionResultContent)message.Contents[0];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine($"调用工具结果：{functionResultContent.Result}");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 恢复控制台默认颜色（白色）
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.White;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果没有参数
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("工具参数为空");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.Green;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("本次没有调用工具");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.White;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
</code></pre>
<h1 id="三为llm添加工具能力">三、为LLM<strong>添加工具能力</strong></h1>
<p>在前面课程基础之上，在Program.cs添加代码。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102445089-262502573.png" alt="图片" loading="lazy"></p>
<p><strong>代码说明：</strong>为LLM添加工具能力，并处理客户提交的内容。</p>
<pre><code>// 创建聊天客户端实例
ChatAIClient chatAIClient =&nbsp;new&nbsp;ChatAIClient();
// 进入主循环，持续接收用户输入直到输入 "exit"
while&nbsp;(true)
{
&nbsp; &nbsp;&nbsp;try
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 设置控制台文字颜色为黄色，提示用户输入问题
&nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.Yellow;
&nbsp; &nbsp; &nbsp; &nbsp; Console.Write("\n提问: ");
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 读取用户输入并去除前后空格，若为空则赋默认空字符串
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;string&nbsp;query = Console.ReadLine()?.Trim() ??&nbsp;string.Empty;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 判断用户是否输入 "exit" 以退出程序
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(query.ToLower() ==&nbsp;"exit")
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 调用异步方法处理用户查询，并传入预定义的工具列表（listToolsResult）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;string&nbsp;response =&nbsp;await&nbsp;chatAIClient.ProcessQueryAsync(query, listToolsResult);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 设置输出颜色为黄色，显示 AI 的响应内容
&nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.Yellow;
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine($"AI：{response}");
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 恢复控制台默认颜色（白色）
&nbsp; &nbsp; &nbsp; &nbsp; Console.ForegroundColor = ConsoleColor.White;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;catch&nbsp;(Exception ex)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 捕获所有异常并输出错误信息，防止程序崩溃
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine($"\nError:&nbsp;{ex.Message}");
&nbsp; &nbsp; }
}
</code></pre>
<h1 id="四测试效果">四、测试效果</h1>
<p>启动项目，并输入以下内容：</p>
<pre><code>抓取&nbsp;https://blog.csdn.net/daremeself/article/details/147166987 的内容，并markdown格式输出
</code></pre>
<p>调用MCP Server的工具的情况日志。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102445960-2146669104.png" alt="图片" loading="lazy"></p>
<p>AI响应的结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202505/93789-20250526102445709-878393127.png" alt="图片" loading="lazy"></p>
<p>好了，今天就分享到这边！</p>
<p>下一个课程：<strong>实现自己的MCP Server。</strong></p>
<p><strong>文中示例代码：</strong> <strong><a href="https://pan.quark.cn/s/b5b8853200f9" target="_blank" rel="noopener nofollow">https://pan.quark.cn/s/b5b8853200f9</a></strong></p>
<blockquote>
<p>该专栏优先在飞书发布，欢迎收藏关注！</p>
<p><a href="https://www.feishu.cn/community/article?id=7507084665509904403" target="_blank" rel="noopener nofollow">https://www.feishu.cn/community/article?id=7507084665509904403</a></p>
</blockquote>
<p>- End -</p>
<p>推荐阅读</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946235&amp;idx=1&amp;sn=a56c877cf4e1ddbccc157de1ee060f8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">VS Code + Cline + 魔搭MCP Server 实现抓取网页内容。</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946207&amp;idx=1&amp;sn=e2650b43d0019b2f222762545bf73a43&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">C#实现自己的MCP Client</a></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6633357736134259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-26 10:25">2025-05-26 10:25</span>&nbsp;
<a href="https://www.cnblogs.com/chingho">chingho</a>&nbsp;
阅读(<span id="post_view_count">292</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18896462);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18896462', targetLink: 'https://www.cnblogs.com/chingho/p/18896462', title: 'C#实现MCP Client 与 LLM 连接，抓取网页内容功能！' })">举报</a>
</div>
	