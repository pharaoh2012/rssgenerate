
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fs7744/p/18869624" title="发布于 2025-05-10 15:05">
    <span role="heading" aria-level="2">莫想到有一天得重新写个 etcd client</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="莫想到有一天得重新写个-etcd-client">莫想到有一天得重新写个 etcd client</h1>
<p>其实8年前搞过一个，</p>
<p>不过经过8年时间，etcd 多了很多功能 ，原来的多半不行了</p>
<p>虽然暂时我也没啥需求，但是怕kv和watch有变化</p>
<p>而且其实通过 grpc api 访问 etcd 没啥技术难度，搞client 也没啥意思的 （只要有<code>.proto</code>文件，可以直接生成grpc client代码, 参见<a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/basics?view=aspnetcore-9.0#c-tooling-support-for-proto-files" target="_blank" rel="noopener nofollow">微软文档</a>）</p>
<p>现成的也很多</p>
<p>所以本来不想写， 直接从 nuget 上找了个下载量最高的 <a href="https://www.nuget.org/packages/dotnet-etcd" target="_blank" rel="noopener nofollow">https://www.nuget.org/packages/dotnet-etcd</a></p>
<p>最开始使用也ok，能读能写</p>
<p>但是当我使用<code>watch</code>时， 居然没有任何变更触发</p>
<p>当然也有其他人发现这个bug 对应issue: <a href="https://github.com/shubhamranjan/dotnet-etcd/issues/238" target="_blank" rel="noopener nofollow">https://github.com/shubhamranjan/dotnet-etcd/issues/238</a>（不过我遇见问题时还没人提issue，我看了源码，找到问题原因之后，这位同志已经写了issue了，）</p>
<p>如下是 issue 内容</p>
<pre><code class="language-csharp">using dotnet_etcd;
using Etcdserverpb;

EtcdClient etcdClient = new EtcdClient("http://localhost:2379");
etcdClient.Watch(
    "test",
    (WatchResponse response) =&gt;
    {
        if (!response.Events.Any())
            return;
        var value = response.Events[0].Kv.Value.ToStringUtf8();
        Console.WriteLine(value);
    }
);
</code></pre>
<p>If you run this sample with 8.0.0, the watch callback never triggers if you modify the key test. If you run it with 6.0.1 it triggers correctly.</p>
<p>为什么 <code>Watch</code> 没用呢？</p>
<p>不是etcd版本问题， 不是网络访问有限制，不是你们第一直觉想到的问题</p>
<p>而是 <strong>作者没实现</strong></p>
<p>在 <a href="https://github.com/shubhamranjan/dotnet-etcd/commit/4ba94d0a174fec42d190bffda733ded3a24055e0" target="_blank" rel="noopener nofollow">https://github.com/shubhamranjan/dotnet-etcd/commit/4ba94d0a174fec42d190bffda733ded3a24055e0</a> 这次代码提交中</p>
<p>watch 的 核心处理代码被删了， 但是package 依然水灵灵提交到了nuget上， 所以 当然不可能监听变更啦  囧  （issue 上我也加了描述，以免其他人遇见迷茫）</p>
<p>然后查看其原来实现， 还发现有个问题： <strong>根本没有处理异常重连</strong></p>
<p>更别提 etcd mvcc 避免变更丢失时要特别注意的 <code>revsion</code> 了</p>
<p>然后作者记录显示，已经近一个月没有更新</p>
<p>所以也不可能指望作者修正问题了</p>
<p>算了，还是自己来吧，</p>
<p>没想到 8年之后还得再次生成 etcd 的 grpc client</p>
<p>根据 最新的 etcd <code>.proto</code>文件 生成了最新的 grpc client</p>
<p>然后为 <code>DependencyInjection</code> 以及使用 简单封装了一下， 源码放在了 <a href="https://github.com/fs7744/etcdcsharp" target="_blank" rel="noopener nofollow">https://github.com/fs7744/etcdcsharp</a></p>
<p>如下是简单的使用文档</p>
<h1 id="etcd-v3-client">ETCD V3 Client</h1>
<p>base code all Generate by grpc tools.</p>
<h2 id="quick-start">Quick start</h2>
<h3 id="install-package">Install package</h3>
<ul>
<li>Package Manager</li>
</ul>
<pre><code>Install-Package etcd.v3 -Version 0.0.2
Install-Package etcd.v3.Configuration -Version 0.0.2
</code></pre>
<ul>
<li>.NET CLI</li>
</ul>
<pre><code>dotnet add package etcd.v3 --version 0.0.2
dotnet add package etcd.v3.Configuration --version 0.0.2
</code></pre>
<h3 id="new-client">new client</h3>
<h4 id="new-client-with-di">new client with DI</h4>
<pre><code class="language-csharp"> ServiceCollection services = new();
 services.UseEtcdClient();
 services.AddEtcdClient("test", new EtcdClientOptions() { Address = ["http://xxx:2379"] });
 var p = services.BuildServiceProvider();

 var client = p.GetRequiredKeyedService&lt;IEtcdClient&gt;("test");

 // you also can create client by factory
 var factory = p.GetRequiredService&lt;IEtcdClientFactory&gt;();
var client2 = factory.CreateClient(new EtcdClientOptions() { Address = ["http://xxx:2379"] });


// get all config
foreach (var i in await client.GetRangeValueUtf8Async("/ReverseProxy/"))
{
   Console.WriteLine($"{i.Key} : {i.Value}");
}

// OR get client in ctor
public class Testt
{
    private readonly IEtcdClient client;

    public Testt([FromKeyedServices("test")] IEtcdClient client)
    {
        this.client = client;
    }
}


</code></pre>
<h4 id="new-client-without-di">new client without DI</h4>
<pre><code class="language-csharp"> var factory = EtcdClientFactory.Create();
var client = factory.CreateClient(new EtcdClientOptions() { Address = ["http://xxx:2379"] });

// get all config
foreach (var i in await client.GetRangeValueUtf8Async("/ReverseProxy/"))
{
   Console.WriteLine($"{i.Key} : {i.Value}");
}
</code></pre>
<h4 id="use-with-configuration">use with Configuration</h4>
<pre><code class="language-csharp">var b = new ConfigurationBuilder();
b.UseEtcd(new Etcd.Configuration.EtcdConfigurationOptions()
{
    Prefix = "/ReverseProxy/",
    RemovePrefix = true,
    EtcdClientOptions = new EtcdClientOptions() { Address = ["http://xxx:2379"] }
});
var c = b.Build();

// test watch change
Test(c);

private static void Test(IConfigurationRoot c)
{
    foreach (var i in c.GetChildren())
    {
        Console.WriteLine($"{i.Key} : {i.Value}");
    }
    c.GetReloadToken().RegisterChangeCallback(i =&gt;
    {
        Test(i as IConfigurationRoot);
    }, c);
}
</code></pre>
<h4 id="address">Address</h4>
<p>Address just parse by <code>GrpcChannel.ForAddress</code>, so support</p>
<ul>
<li><a href="http://xxx" target="_blank" rel="noopener nofollow">http://xxx</a>:port</li>
<li><a href="https://xxx" target="_blank" rel="noopener nofollow">https://xxx</a>:port</li>
<li>dns://xxx:port</li>
</ul>
<h3 id="kv">KV</h3>
<h4 id="get-one-by-key">get one by key</h4>
<pre><code class="language-csharp">string v = await client.GetValueUtf8Async("/ReverseProxy/");
//or 
string v = (await client.GetAsync("/ReverseProxy/")).Kvs?.First().Value.ToStrUtf8();
//or
string v = (await client.RangeAsync(new RangeRequest() { Key = ByteString.CopyFromUtf8("/ReverseProxy/") })).Kvs?.First().Value.ToStrUtf8();
</code></pre>
<h5 id="get-all-idictionarystring-string">get all IDictionary&lt;string, string&gt;</h5>
<pre><code class="language-csharp">foreach (var i in await client.GetRangeValueUtf8Async("/ReverseProxy/"))
{
    Console.WriteLine($"{i.Key} : {i.Value}");
}
//or
foreach (var i in (await client.GetRangeAsync("/ReverseProxy/")).Kvs)
{
    Console.WriteLine($"{i.Key.ToStrUtf8()} : {i.Value.ToStrUtf8()}");
}
//or
foreach (var i in (await client.RangeAsync(new RangeRequest() { Key = ByteString.CopyFromUtf8("/ReverseProxy/"), RangeEnd = ByteString.CopyFromUtf8("/ReverseProxy/".GetRangeEnd()) })).Kvs)
{
    Console.WriteLine($"{i.Key.ToStrUtf8()} : {i.Value.ToStrUtf8()}");
}
</code></pre>
<h4 id="put">Put</h4>
<pre><code class="language-csharp">await client.PutAsync("/ReverseProxy/test", "1");
//or
await client.PutAsync(new PutRequest() { Key = ByteString.CopyFromUtf8("/ReverseProxy/test"), Value = ByteString.CopyFromUtf8("1") });
</code></pre>
<h4 id="delete-one">Delete one</h4>
<pre><code class="language-csharp">await client.DeleteAsync("/ReverseProxy/test");
//or
await client.DeleteRangeAsync(new DeleteRangeRequest() { Key = ByteString.CopyFromUtf8("/ReverseProxy/test") });
</code></pre>
<h4 id="delete-all">Delete all</h4>
<pre><code class="language-csharp">await client.DeleteRangeAsync("/ReverseProxy/test");
//or
await client.DeleteRangeAsync(new DeleteRangeRequest() { Key = ByteString.CopyFromUtf8("/ReverseProxy/test"), RangeEnd = ByteString.CopyFromUtf8("/ReverseProxy/test".GetRangeEnd())) });
</code></pre>
<h4 id="watch">Watch</h4>
<pre><code class="language-csharp"> await client.WatchRangeBackendAsync("/ReverseProxy/", i =&gt;
 {
     if (i.Events.Count &gt; 0)
     {
         foreach (var item in i.Events)
         {
             Console.WriteLine($"{item.Type} {item.Kv.Key.ToStrUtf8()}");
         }
     }
     return Task.CompletedTask;
 }, startRevision: 6, reWatchWhenException: true);

 // or
await Task.Factory.StartNew(async () =&gt;
{
    long startRevision = 6;
    while (true)
    {
        try
        {
            using var watcher = await client.WatchRangeAsync("/ReverseProxy/", startRevision: startRevision);
            await watcher.ForAllAsync(i =&gt;
            {
                startRevision = i.FindRevision(startRevision);
                foreach (var item in i.Events)
                {
                    Console.WriteLine($"{item.Type} {item.Kv.Key.ToStrUtf8()}");
                }
                return Task.CompletedTask;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Exception: {ex.Message}");
        }
    }
});
</code></pre>
<h4 id="all-grpc-client">all grpc client</h4>
<p>if IEtcdClient Missing some grpc method , you can just use grpc client to do</p>
<pre><code class="language-csharp">public partial interface IEtcdClient
{
    public AuthClient AuthClient { get; }
    public Cluster.ClusterClient ClusterClient { get; }
    public ElectionClient ElectionClient { get; }
    public KV.KVClient KVClient { get; }
    public LeaseClient LeaseClient { get; }
    public LockClient LockClient { get; }
    public MaintenanceClient MaintenanceClient { get; }
    public Watch.WatchClient WatchClient { get; }
}
</code></pre>
<h3 id="api-doc">api doc</h3>
<p>Main api doc please see</p>
<p><a href="https://fs7744.github.io/etcdcsharp/api/Etcd.html" target="_blank" rel="noopener nofollow">https://fs7744.github.io/etcdcsharp/api/Etcd.html</a><br>
<a href="https://fs7744.github.io/etcdcsharp/api/Microsoft.Extensions.Configuration.EtcdConfigurationExtensions.html" target="_blank" rel="noopener nofollow">https://fs7744.github.io/etcdcsharp/api/Microsoft.Extensions.Configuration.EtcdConfigurationExtensions.html</a></p>
<p>All api doc ( include code generate by grpc tool ) please see</p>
<p><a href="https://fs7744.github.io/etcdcsharp/api/index.html" target="_blank" rel="noopener nofollow">https://fs7744.github.io/etcdcsharp/api/index.html</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5487265964918981" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 15:05">2025-05-10 15:05</span>&nbsp;
<a href="https://www.cnblogs.com/fs7744">victor.x.qu</a>&nbsp;
阅读(<span id="post_view_count">58</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869624);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869624', targetLink: 'https://www.cnblogs.com/fs7744/p/18869624', title: '莫想到有一天得重新写个 etcd client' })">举报</a>
</div>
        