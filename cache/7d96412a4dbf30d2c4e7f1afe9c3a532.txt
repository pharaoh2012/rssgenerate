
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wJiang/p/18883448" title="发布于 2025-05-19 10:43">
    <span role="heading" aria-level="2">【实战】深入浅出 Rust 并发：RwLock 与 Mutex 在 Tauri 项目中的实践</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.7316506626655093" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-19 10:43">2025-05-19 10:43</span>&nbsp;
<a href="https://www.cnblogs.com/wJiang">姜 萌@cnblogs</a>&nbsp;
阅读(<span id="post_view_count">123</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18883448);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18883448', targetLink: 'https://www.cnblogs.com/wJiang/p/18883448', title: '【实战】深入浅出 Rust 并发：RwLock 与 Mutex 在 Tauri 项目中的实践' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p><strong>你是否遇到过 Rust 并发场景下的资源竞争、性能瓶颈？</strong><br>
当多个线程同时抓取网页导致 IP 被封、多线程读写本地数据引发一致性问题时，如何优雅地实现线程安全？</p>
<p><strong>本文结合开源项目 Saga Reader 的真实开发场景</strong>，深度解析 Arc/Mutex/RwLock 的实战技巧，带你从 “踩坑” 到 “优化”，掌握 Rust 并发编程的核心方法论，文末附项目地址，欢迎 star 交流！<br>
关于开源项目Saga Reader（中文麒睿智库），之前我在博客园中有详细介绍，新朋友可以先阅读<a href="https://www.cnblogs.com/wJiang/p/18873839" target="_blank"><strong>这篇文章</strong></a>。</p>
<h2 id="技术背景">技术背景</h2>
<blockquote>
<p>在 Rust 编程的世界里，并发编程是一个既强大又充满挑战的领域。为了实现高效、安全的并发操作，Rust 提供了一系列实用的工具，其中 Arc（原子引用计数指针）和 Mutex（互斥锁）、RwLock（读写锁）是非常关键的组件。本文将结合 Saga Reader 项目中的实际应用案例，深入探讨 Arc、Mutex、RwLock 的使用场景、技术要点，并结合我们的 Saga Reader 项目中的实际案例，分享它们在并发场景下的使用技巧和设计哲学。</p>
</blockquote>
<h3 id="什么是saga-reader">什么是Saga Reader</h3>
<p>基于Tauri开发的开源AI驱动的智库式阅读器（前端部分使用Web框架），能根据用户指定的主题和偏好关键词自动从互联网上检索信息。它使用云端或本地大型模型进行总结和提供指导，并包括一个AI驱动的互动阅读伴读功能，你可以与AI讨论和交换阅读内容的想法。</p>
<p>这个项目我5月刚放到Github上（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><strong>Github - Saga Reader</strong></a>），欢迎大家关注分享。🧑‍💻码农🧑‍💻开源不易，各位好人路过请给个小星星💗<strong>Star</strong>💗。</p>
<p><strong>核心技术栈</strong>：Rust + Tauri（跨平台）+ Svelte（前端）+ LLM（大语言模型集成），支持<strong>本地 / 云端双模式</strong></p>
<p><strong>关键词</strong>：端智能，边缘大模型；Tauri 2.0；桌面端安装包 &lt; 5MB，内存占用 &lt; 20MB。</p>
<p><strong>运行截图</strong><br>
<img src="https://img2024.cnblogs.com/blog/98620/202505/98620-20250519103925790-758214173.png" alt="" loading="lazy"></p>
<p><strong>项目核心模块</strong><br>
<img src="https://img2024.cnblogs.com/blog/98620/202505/98620-20250519103957106-1444915782.png" alt="" loading="lazy"></p>
<h3 id="问题初现无-arc-与-mutex-的困境">问题初现：无 Arc 与 Mutex 的困境</h3>
<p>因为是本地桌面端，涉及到本地数据的并发读写以及数据抓取的并发限流控制。以网页内容抓取模块为例，多个线程同时进行网页抓取操作，代码如下：</p>
<pre><code class="language-rs">// 早期网页抓取示例
use reqwest;

async fn scrap_text_by_url(url: &amp;str) -&gt; anyhow::Result&lt;String&gt; {
    let response = reqwest::get(url).await?;
    let text = response.text().await?;
    // 处理网页内容
    Ok(text)
}
</code></pre>
<p>由于没有任何同步机制，多个线程可能会同时访问同一个网页资源，服务器可能会将这些请求视为恶意攻击，从而对 IP 进行封禁。同时，多个线程同时处理抓取到的内容，可能会导致数据处理混乱，影响最终结果的准确性。</p>
<p>再比如对本地数据的读取，无并发控制会引起数据不一致问题。</p>
<h3 id="引入-arc-与-mutex柳暗花明">引入 Arc 与 Mutex：柳暗花明</h3>
<h4 id="arc"><code>Arc</code></h4>
<p><code>Arc</code> 是 Rust 标准库中的一个智能指针，全称为 <code>Atomic Reference Counting</code>。在多线程环境中，多个线程可能需要同时访问同一个资源，<code>Arc</code> 可以让多个线程安全地共享同一个数据实例。它通过原子操作来管理引用计数，当引用计数降为 0 时，数据会被自动释放，从而避免了数据竞争和内存泄漏的问题。</p>
<h4 id="mutex"><code>Mutex</code></h4>
<p><code>Mutex</code> 即互斥锁，是一种用于实现线程同步的机制。在多线程编程中，多个线程可能会同时访问和修改共享资源，这可能会导致数据不一致或其他竞态条件。<code>Mutex</code> 可以确保在同一时间只有一个线程能够访问被保护的资源，从而保证数据的一致性和线程安全。</p>
<p><strong>Saga Reader 中的 Mutex 实战</strong></p>
<blockquote>
<p>源码：<a href="https://github.com/sopaco/saga-reader/blob/main/crates/scrap/src/simulator.rs" target="_blank" rel="noopener nofollow"><code>scrap/src/simulator.rs</code></a></p>
</blockquote>
<p>在 Saga Reader 项目中，我们有一个模拟浏览器行为来抓取网页内容的功能，位于 <mcfile name="simulator.rs" path="/Users/jiangmeng/workspace/research/saga-reader/crates/scrap/src/simulator.rs"></mcfile>。由于创建和管理模拟的 Webview 窗口是资源密集型操作，并且可能涉及到一些全局状态或限制（例如，不能同时打开多个同名的模拟窗口），我们需要确保这部分操作的串行化执行。</p>
<blockquote>
<p><strong>为什么选择 Mutex 而非其他锁？</strong><br>
&gt; 模拟 Webview 窗口创建是<strong>资源密集型操作</strong>，且需保证<strong>同一时刻仅允许一个实例运行</strong>（避免内存泄漏和窗口句柄冲突）。此时<strong>写操作（创建窗口）是核心操作</strong>，读操作极少，因此选择 Mutex 保证独占性，而非引入 RwLock 的复杂度。</p>
</blockquote>
<pre><code class="language-rust:/Users/jiangmeng/workspace/research/saga-reader/crates/scrap/src/simulator.rs">// ... existing code ...
use tokio::sync::{oneshot, Mutex}; // 引入 Tokio 的异步 Mutex
// ... existing code ...

// 使用 once_cell 的 Lazy 来延迟初始化一个全局的、带 Arc 的 Mutex
// Arc&lt;Mutex&lt;()&gt;&gt; 中的 () 表示我们用这个 Mutex 保护的不是具体数据，
// 而是保护一段代码逻辑的独占执行权。
static MUTEX: Lazy&lt;Arc&lt;Mutex&lt;()&gt;&gt;&gt; = Lazy::new(|| Arc::new(Mutex::new(())));

pub async fn scrap_text_by_url&lt;R: Runtime&gt;(
    app_handle: AppHandle&lt;R&gt;,
    url: &amp;str,
) -&gt; anyhow::Result&lt;String&gt; {
    // 在关键代码段开始前，异步获取锁
    // _lock 是一个 RAII 守护（guard），当它离开作用域时，锁会自动释放
    let _lock = MUTEX.lock().await;
    match app_handle.get_webview_window(WINDOW_SCRAP_HOST) {
        Some(_) =&gt; {
            error!("The scrap host for simulator was busy to use, scrap pages at the same time was not support currently!");
            Err(anyhow::anyhow!("Scrap host is busy"))
        }
        None =&gt; {
            // ... 创建和操作 Webview 窗口的代码 ...
            // 这部分代码在持有锁的期间执行，保证了同一时间只有一个任务能执行到这里
            let window = WebviewWindowBuilder::new(
// ... existing code ...
            Ok(result)
        }
    }
    // _lock 在这里离开作用域，Mutex 自动释放
}
</code></pre>
<p>在这个例子中，<code>static MUTEX: Lazy&lt;Arc&lt;Mutex&lt;()&gt;&gt;&gt;</code> 定义了一个全局静态的互斥锁。<code>Arc</code> 使得这个 <code>Mutex</code> 可以在多个异步任务之间安全共享。<code>Lazy</code> 确保 <code>Mutex</code> 只在第一次被访问时初始化。<code>Mutex&lt;()&gt;</code> 表示这个锁并不直接保护某个具体的数据，而是用来控制对一段代码逻辑（即创建和使用 <code>WINDOW_SCRAP_HOST</code> 窗口的过程）的独占访问。通过 <code>MUTEX.lock().await</code>，任何尝试执行 <code>scrap_text_by_url</code> 的任务都必须先获得这个锁，从而保证了模拟器资源的串行使用，避免了潜在的冲突和错误。</p>
<h3 id="读多写少场景的性能利器rwlock">读多写少场景的性能利器：RwLock</h3>
<p>虽然 <code>Mutex</code> 提供了强大的数据保护能力，但它的独占性在某些场景下可能会成为性能瓶颈。想象一个场景：我们有一个共享的配置对象，它很少被修改（写操作），但会被非常频繁地读取（读操作）。如果使用 <code>Mutex</code>，即使是多个读操作也不得不排队等待，这显然不是最优的。</p>
<p><code>RwLock&lt;T&gt;</code> (Read-Write Lock) 正是为了解决这类“读多写少”的场景而设计的。它允许多个读取者同时访问共享数据，或者一个写入者独占访问共享数据。规则如下：</p>
<ul>
<li><strong>共享读</strong>：可以有任意数量的读取者同时持有读锁。</li>
<li><strong>独占写</strong>：当有写入者持有写锁时，其他所有读取者和写入者都必须等待。</li>
<li><strong>读写互斥</strong>：当有任何读取者持有读锁时，写入者必须等待；反之亦然。</li>
</ul>
<p><strong>RwLock 的核心特性：</strong></p>
<ul>
<li><strong>提高读并发</strong>：在读取操作远多于写入操作时，<code>RwLock</code> 能显著提高并发性能。</li>
<li><strong>写操作依然独占</strong>：保证了数据修改时的安全性。</li>
</ul>
<p><strong>Saga Reader 中的 RwLock 实战</strong></p>
<blockquote>
<p>源码：<a href="https://github.com/sopaco/saga-reader/blob/main/crates/feed_api_rs/src/features/impl_default.rs" target="_blank" rel="noopener nofollow"><code>feed_api_rs/src/features/impl_default.rs</code></a></p>
</blockquote>
<p>在 Saga Reader 的核心功能模块 <mcfile name="impl_default.rs" path="/Users/jiangmeng/workspace/research/saga-reader/crates/feed_api_rs/src/features/impl_default.rs"></mcfile> 中，<code>FeaturesAPIImpl</code> 结构体持有一个 <code>ApplicationContext</code>，这个上下文中包含了用户配置 (<code>UserConfig</code>) 和应用配置 (<code>AppConfig</code>) 等共享状态。这些配置信息会被多个 API 调用读取，而修改配置的操作相对较少。</p>
<pre><code class="language-rust:/Users/jiangmeng/workspace/research/saga-reader/crates/feed_api_rs/src/features/impl_default.rs">// ... existing code ...
use tokio::sync::RwLock; // 引入 Tokio 的异步 RwLock
// ... existing code ...

pub struct FeaturesAPIImpl {
    // ApplicationContext 被 Arc 和 RwLock 包裹，以便在异步任务间安全共享和并发访问
    context: Arc&lt;RwLock&lt;ApplicationContext&gt;&gt;,
    scrap_provider: ScrapProviderEnums,
    article_recorder_service: ArticleRecorderService,
}

impl FeaturesAPIImpl {
    pub async fn new(ctx: ApplicationContext) -&gt; anyhow::Result&lt;Self&gt; {
        // ... 初始化代码 ...
        let context = Arc::new(RwLock::new(ctx)); // 创建 RwLock 实例
        // ...
        Ok(FeaturesAPIImpl {
            context,
            scrap_provider,
            article_recorder_service,
        })
    }

    // 示例：读取配置 (读操作)
    async fn update_feed_contents&lt;R: Runtime&gt;(
        &amp;self,
        package_id: &amp;str,
        feed_id: &amp;str,
        app_handle: Option&lt;AppHandle&lt;R&gt;&gt;,
    ) -&gt; anyhow::Result&lt;()&gt; {
        let user_config;
        let llm_section;
        {
            // 获取读锁，允许多个任务同时读取 context
            let context_guarded = self.context.read().await;
            user_config = context_guarded.user_config.clone();
            llm_section = context_guarded.app_config.llm.clone();
        } // 读锁在此处释放
        // ... 后续逻辑使用 user_config 和 llm_section ...
        Ok(())
    }

    // 示例：修改用户配置 (写操作)
    async fn add_feeds_package(&amp;self, feeds_package: FeedsPackage) -&gt; anyhow::Result&lt;()&gt; {
        // 获取写锁，独占访问 context
        let context_guarded = &amp;mut self.context.write().await;
        let user_config = &amp;mut context_guarded.user_config;
        if user_config.add_feeds_packages(feeds_package) {
            return self.sync_user_profile(user_config).await;
        }
        // ...
        Err(anyhow::Error::msg(
            "add_feeds_package failure, may be the feeds package already existed",
        ))
        // 写锁在此处释放
    }
}
</code></pre>
<p><code>context: Arc&lt;RwLock&lt;ApplicationContext&gt;&gt;</code> 使得 <code>ApplicationContext</code> 可以在多个异步的 API 请求处理任务之间安全地共享。当一个任务需要读取配置，它会调用 <code>self.context.read().await</code> 来获取一个读锁。多个任务可以同时持有读锁并访问 <code>ApplicationContext</code>。当一个任务需要修改配置，它会调用 <code>self.context.write().await</code> 来获取一个写锁。此时，其他任何尝试获取读锁或写锁的任务都会被阻塞，直到写锁被释放。这种机制极大地提高了读取密集型操作的并发性能，同时保证了写操作的原子性和数据一致性。</p>
<p><strong>关于 <code>tauri::State</code> 和 <code>Arc</code>：</strong></p>
<p>我们经常看到 Tauri 命令的参数形如 <code>state: State&lt;'_, Arc&lt;HybridRuntimeState&gt;&gt;</code>。这里的 <code>Arc&lt;HybridRuntimeState&gt;</code> 表明 <code>HybridRuntimeState</code> 是一个被多所有权共享的状态对象。Tauri 的 <code>State</code> 管理器本身会确保以线程安全的方式将这个状态注入到命令处理函数中。如果 <code>HybridRuntimeState</code> 内部的数据需要细粒度的并发控制，那么它内部可能就会使用 <code>Mutex</code> 或 <code>RwLock</code>。例如，我们的 <code>FeaturesAPIImpl</code> 实例（它内部使用了 <code>RwLock</code>）就是通过 <code>HybridRuntimeState</code> 共享给各个 Tauri 命令的。</p>
<pre><code class="language-rs">// ... existing code ...
// 在插件初始化时，创建 FeaturesAPIImpl 实例并放入 Arc 中
// 然后通过 app_handle.manage() 交给 Tauri 的状态管理器
.setup(|app_handle, _plugin| {
    let features_api = tauri::async_runtime::block_on(async {
        let context_host = Startup::launch().await.unwrap();
        let context = context_host.copy_context();
        FeaturesAPIImpl::new(context).await.expect("tauri-plugin-feed-api setup the features instance failure")
    });

    app_handle.manage(Arc::new(HybridRuntimeState { features_api })); // features_api 内部有 RwLock
    Ok(())
})
// ... existing code ...
</code></pre>
<pre><code class="language-rs">// ... existing code ...
// Tauri 命令通过 State 获取共享的 HybridRuntimeState
#[tauri::command(rename_all = "snake_case")]
pub(crate) async fn get_feeds_packages(
    state: State&lt;'_, Arc&lt;HybridRuntimeState&gt;&gt;,
) -&gt; Result&lt;Vec&lt;FeedsPackage&gt;, ()&gt; {
    // features_api 内部的 RwLock 会在这里发挥作用
    let features_api = &amp;state.features_api;
    Ok(features_api.get_feeds_packages().await)
}
// ... existing code ...
</code></pre>
<h3 id="mutex-vs-rwlock如何选择">Mutex vs. RwLock：如何选择？</h3>
<table>
<thead>
<tr>
<th style="text-align: left">特性</th>
<th style="text-align: left">Mutex</th>
<th style="text-align: left">RwLock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">基本原理</td>
<td style="text-align: left">独占访问</td>
<td style="text-align: left">共享读，独占写</td>
</tr>
<tr>
<td style="text-align: left">适用场景</td>
<td style="text-align: left">写操作频繁，或读写操作均衡，或逻辑简单</td>
<td style="text-align: left">读操作远多于写操作，且读操作耗时较长</td>
</tr>
<tr>
<td style="text-align: left">锁的粒度</td>
<td style="text-align: left">通常较粗，保护整个数据结构或代码块</td>
<td style="text-align: left">可以更细粒度，但通常也保护整个数据结构</td>
</tr>
<tr>
<td style="text-align: left">性能（读多）</td>
<td style="text-align: left">可能成为瓶颈</td>
<td style="text-align: left">显著优于 Mutex</td>
</tr>
<tr>
<td style="text-align: left">性能（写多）</td>
<td style="text-align: left">与 RwLock 类似，或略优（因逻辑更简单）</td>
<td style="text-align: left">可能不如 Mutex（因内部状态管理更复杂）</td>
</tr>
<tr>
<td style="text-align: left">死锁风险</td>
<td style="text-align: left">存在（如ABBA死锁）</td>
<td style="text-align: left">存在，且可能更复杂（如写锁饥饿读锁）</td>
</tr>
</tbody>
</table>
<p><strong>选择建议：</strong></p>
<ul>
<li><strong>优先简单</strong>：如果不确定，或者共享数据的访问模式不清晰，可以从 <code>Mutex</code> 开始，因为它的语义更简单，更不容易出错。</li>
<li><strong>分析瓶颈</strong>：如果性能分析表明某个 <code>Mutex</code> 成为了瓶颈，并且该场景符合“读多写少”的特点，那么可以考虑替换为 <code>RwLock</code>。</li>
<li><strong>警惕写锁饥饿</strong>：<code>RwLock</code> 的一个潜在问题是写锁饥饿。如果读请求非常频繁，写操作可能长时间无法获得锁。一些 <code>RwLock</code> 的实现可能提供公平性策略来缓解这个问题，但仍需注意。</li>
<li><strong>锁的持有时间</strong>：无论使用 <code>Mutex</code> 还是 <code>RwLock</code>，都应尽可能缩短锁的持有时间，以减少线程阻塞和提高并发度。将耗时操作移出临界区（持有锁的代码段）。</li>
</ul>
<h3 id="总结与展望">总结与展望</h3>
<p><code>Mutex</code> 和 <code>RwLock</code> 是 Rust 并发编程中不可或缺的同步原语。它们以不同的策略平衡了数据安全和并发性能的需求。在 Saga Reader 项目中，我们根据具体的业务场景和数据访问模式，恰当地选择了 <code>Mutex</code> 来保证资源操作的串行化，以及 <code>RwLock</code> 来优化共享配置的并发读取性能。</p>
<p>理解并熟练运用这些并发工具，是构建高效、健壮的 Rust 应用的基石。随着项目的发展，我们也将持续关注并发性能，并在必要时对锁的使用策略进行调优，以确保 Saga Reader 能够为用户带来流畅、稳定的阅读体验。</p>
<h3 id="参与开源一起构建高效阅读器"><strong>参与开源，一起构建高效阅读器！</strong></h3>
<p>Saga Reader 是一个<strong>完全开源的跨平台项目</strong>，目前正在快速迭代中，急需以下方向的贡献者：</p>
<ul>
<li><strong>Rust 开发</strong>：优化并发逻辑、扩展本地大模型支持；</li>
<li><strong>前端开发</strong>：基于 Svelte 优化用户交互；</li>
<li><strong>AI 算法</strong>：改进文本总结与伴读功能的语义理解；</li>
</ul>
<p><strong>如何参与？</strong></p>
<ol>
<li>🧑‍💻码农🧑‍💻开源不易，各位好人路过请给个小星星💗<strong>Star</strong>💗。 → <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow">GitHub - Saga Reader</a></li>
<li>加入 Issues 讨论：提出功能建议或参与 Bug 修复；</li>
<li>提交 PR：我们会提供详细的开发文档与技术支持！</li>
</ol>
<p><strong>福利</strong>：活跃贡献者可获得项目代码署名！</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>&nbsp;</p>
<div style="filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=1,StartColorStr='#6699FF',EndColorStr='#A1FBFF">
<table>
<tbody>
<tr>
<td rowspan="4"><img alt="" src="https://images.cnblogs.com/cnblogs_com/wJiang/233935/t_a.jpg"></td>
<td>
<p>网名：</p></td>
<td>
<p>无疆_炎戎<br>无疆_寒冰</p></td></tr>
<tr>
<td>
<p>实名：</p>
</td><td>
<p>姜萌</p></td></tr>
<tr>
<td colspan="2"><a href="http://www.wjiangathpc.spaces.live.com/" target="_blank">http://www.wjiangathpc.spaces.live.com/</a></td></tr>
<tr>
<td colspan="2"><a href="http://www.cnblogs.com/wJiang" target="_blank">http://www.cnblogs.com/wJiang</a></td></tr></tbody></table></div>
<p>&nbsp;</p>
<div id="license"><a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" alt="Creative Commons License" src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png"></a><br>本<span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" rel="dc:type">作品</span>由<a href="http://www.cnblogs.com/" rel="cc:attributionURL" target="_blank" xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">姜萌</a>创作，采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank">知识共享署名 2.5 中国大陆许可协议</a>进行许可。 </div>
</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="wJiang" blog-id="64968" post-id="18883448"></vc:categories-tags>
    </ul>
