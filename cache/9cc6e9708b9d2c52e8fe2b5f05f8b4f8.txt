
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/19016894" title="发布于 2025-08-01 14:52">
    <span role="heading" aria-level="2">Django模型查询与性能调优：告别N+1问题</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250801145215021-1407699965.png" alt="Django模型查询与性能调优：告别N+1问题" class="desc_img">
        本文详解Django数据库查询基础与优化技巧，涵盖QuerySet使用、关联查询（一对多/多对多）、N+1查询问题及解决方案（select_related、prefetch_related）、高级查询方法及项目实战中的数据权限控制实现。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一查询基础">一、查询基础</h2>
<h3 id="queryset-详解">QuerySet 详解</h3>
<p>Django 中通过模型类的 Manager 构建 QuerySet 来检索数据库对象，其核心特性包括：</p>
<ul>
<li>代表数据库中对象的集合</li>
<li>可通过过滤器缩小查询范围</li>
<li>具有惰性执行特性（仅在需要结果时才执行 SQL）</li>
</ul>
<p>常用过滤器</p>
<ul>
<li><code>all()</code>：返回所有对象</li>
<li><code>filter(**kwargs)</code>：返回满足条件的对象</li>
<li><code>exclude(** kwargs)</code>：返回不满足条件的对象</li>
<li><code>get(**kwargs)</code>：返回单个匹配对象（无匹配或多匹配会抛异常）</li>
<li>切片</li>
</ul>
<pre><code class="language-python"># 切片操作示例：返回前5个对象（LIMIT 5）
Book.objects.all()[:5]
</code></pre>
<h3 id="一对多关联查询">一对多关联查询</h3>
<p>假设一个作者可以写多本书，但每本书只能属于一个作者。</p>
<pre><code class="language-python">from django.db import models

class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

class Book(models.Model):
    title = models.CharField(max_length=100)
    publication_date = models.DateField()
    # 外键关联Author，级联删除，反向查询名为books
    author = models.ForeignKey(
        Author, 
        on_delete=models.CASCADE, 
        related_name='books'
    )

    def __str__(self):
        return self.title
</code></pre>
<p><strong>正向查询（通过外键属性访问）</strong></p>
<pre><code class="language-python">b = Book.objects.get(id=2)
b.author  # 获取关联的Blog对象，查询数据库
b.author = some_body  # 设置关联对象
b.save()  # 保存更改
</code></pre>
<p>使用 <code>select_related()</code> 预加载关联对象，避免额外查询</p>
<pre><code class="language-python">b = Book.objects.select_related().get(id=2)
print(b.author)  # 已预加载到缓存，使用缓存，不查询数据库
</code></pre>
<p><strong>反向查询（通过关联管理器）</strong></p>
<pre><code class="language-python"># 未定义related_name， 默认Manager名称为：&lt;模型名称小写&gt;_set
a = Author.objects.get(id=1)
a.book_set.all()  # 返回所有关联的Book

# 定义了related_name='books'
a.books.all()  # 更直观的访问方式
</code></pre>
<p>关联对象操作方法如下。所有 “反向” 操作对数据库都是立刻生效，保存到数据库。</p>
<ul>
<li><code>add(obj1, obj2)</code>：添加关联对象</li>
<li><code>create(**kwargs)</code>：创建并关联新对象</li>
<li><code>remove(obj1, obj2)</code>：移除关联对象</li>
<li><code>clear()</code>：清空所有关联</li>
<li><code>set(objs)</code>：替换关联集合</li>
</ul>
<pre><code class="language-python">a = Author.objects.get(id=1)
a.books.set([b1, b2]) #  b1 和 b2 都是 Book 实例
</code></pre>
<h3 id="多对多关联查询">多对多关联查询</h3>
<p>假设一个作者可以写多本书，一本书也可以有多个作者。</p>
<pre><code class="language-python">from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

    def __str__(self):
        return self.name

class Book(models.Model):
    title = models.CharField(max_length=200)
    publication_date = models.DateField()
    # 多对多关联Author
    authors = models.ManyToManyField(Author, related_name='books')

    def __str__(self):
        return self.title
</code></pre>
<p>正向与反向查询示例</p>
<pre><code class="language-python"># 正向查询
b = Book.objects.get(id=3)
b.authors.all() # 获取所有关联的Author
b.authors.count()
b.authors.filter(name__contains="张三")

# 反向查询
a = Author.objects.get(id=5)
a.book_set.all()  # 获取所有关联的Book
</code></pre>
<p>多对多关联中，add()、set() 和 remove() 可直接使用主键</p>
<pre><code class="language-python">a = Author.objects.get(id=5)
a.book_set.set([b1, b2])
# 等价于
a.book_set.set([b1.pk, b2.pk])
</code></pre>
<h2 id="二n1查询问题">二、N+1查询问题</h2>
<h3 id="问题分析">问题分析</h3>
<p>N+1 查询是常见的性能问题，表现为主查询后执行 N 次额外查询。例如：</p>
<pre><code class="language-python">books = Book.objects.all()
for book in books:
    print(book.author.first_name)
</code></pre>
<p>以上代码会产生 1 次查询获取所有 Book，加上 N 次查询获取对应的 Author（N 为 Book 数量），共 N+1 次查询。</p>
<h3 id="检测方法">检测方法</h3>
<ul>
<li>Django Debug Toolbar：直观显示请求中的 SQL 查询</li>
<li>日志记录：配置日志记录 SQL 语句</li>
<li>性能分析工具：如 Django Silk 分析查询性能</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<p><strong>方法 1：使用 <code>select_related</code></strong></p>
<p>适用于一对多（正向）和一对一关系，通过 SQL JOIN 预加载关联对象</p>
<ul>
<li>语法：<code>select_related('related_field')</code>，<code>related_field</code> 是模型中定义的 <code>ForeignKey</code> 或 <code>OneToOneField</code> 字段</li>
</ul>
<pre><code class="language-python">books = Book.objects.select_related('author').all()
for book in books:
    print(book.author.first_name) # 无额外查询 
</code></pre>
<p>可结合 <code>only()</code> 选择需要的字段</p>
<pre><code class="language-python">books = Book.objects.select_related('author').only('title', 'author__name')
</code></pre>
<p>支持多级关联</p>
<pre><code class="language-python"># 加载书籍、作者及作者家乡信息
books = Book.objects.select_related('author__hometown').all()
for book in books:
    print(book.author.hometown.name)  # 无额外查询
</code></pre>
<p><strong>方法 2：使用 <code>prefetch_related</code></strong></p>
<p>适用于多对多和反向关系，通过批量查询后在 Python 中关联。适用场景：</p>
<ul>
<li>多对多关系（ManyToManyField）</li>
<li>反向一对多关系</li>
<li>反向一对一关系</li>
</ul>
<pre><code class="language-python">books = Book.objects.prefetch_related('authors').all()
for book in books:
    print(book.authors.all())  # 无额外查询
</code></pre>
<p>参考资料：<a href="https://docs.djangoproject.com/zh-hans/4.2/topics/db/optimization/" target="_blank" rel="noopener nofollow">Django 数据库访问优化</a></p>
<h2 id="三高级查询优化">三、高级查询优化</h2>
<h3 id="values">values()</h3>
<p>返回字典形式的查询集（返回一个 <code>ValuesQuerySet</code> 对象，其中每个元素是一个字典），适合提取特定字段</p>
<pre><code class="language-python">books = Book.objects.values('title', 'author')
for book in books:
    print(book) 
    
# 输出示例
{'title': 'Book1', 'author': 'Author1'}
{'title': 'Book2', 'author': 'Author2'}
</code></pre>
<h3 id="values_list">values_list()</h3>
<p>返回元组形式的查询集（返回一个 <code>ValuesListQuerySet</code> 对象，其中每个元素是一个元组），内存占用更低</p>
<pre><code class="language-python">books = Book.objects.values_list('title', 'author')
for book in books:
    print(book)
    
### 输出示例
('Book1', 'Author1')
('Book2', 'Author2')
</code></pre>
<p>使用 <code>flat=True</code> 获取单一字段值列表。如果有多个字段时，传入 <code>flat</code> 会报错。</p>
<pre><code class="language-python">titles = Book.objects.values_list('title', flat=True)
# &lt;QuerySet ['红楼梦', '西游记', ...]&gt;
</code></pre>
<p>使用 <code>named=True</code> ，结果返回 <code>namedtuple()</code></p>
<pre><code class="language-python">books_info = Book.objects.values_list("id", "title", named=True)
# &lt;QuerySet [Row(id=1, title='红楼梦'), ...]&gt;
</code></pre>
<h3 id="values和values_list对比">values()和values_list()对比</h3>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><code>values()</code></th>
<th><code>values_list()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>返回值类型</strong></td>
<td>返回一个包含字典的查询集，字典的键为字段名，值为字段对应的数据</td>
<td>返回一个包含元组的查询集，元组中的元素依次对应指定字段的值</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>相对较高，因为字典需要存储键值对信息</td>
<td>通常更节省内存，元组是更轻量的数据结构，无需存储字段名</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>适合需要通过字段名访问字段值的场景，例如需要明确知道每个值对应的字段时</td>
<td>适合仅需要获取字段值的场景，例如只需批量获取某个或某几个字段的具体数据时</td>
</tr>
</tbody>
</table>
<h3 id="q-对象复杂查询">Q() 对象复杂查询</h3>
<p><code>Q()</code> 对象用于构建复杂查询条件，支持逻辑运算</p>
<ul>
<li><code>&amp;</code>：逻辑与（AND）</li>
<li><code>|</code>：逻辑或（OR）</li>
<li><code>~</code>：逻辑非（NOT）</li>
</ul>
<pre><code class="language-python">from django.db.models import Q

# 标题含Python或作者为John的书籍
books = Book.objects.filter(
    Q(title__icontains="Python") | Q(author="John")
)

# 复杂组合条件
books = Book.objects.filter(
    (Q(title__icontains="Python") | Q(title__icontains="Django")) &amp;
    ~Q(author="John")
)
</code></pre>
<h3 id="查看生成的-sql">查看生成的 SQL</h3>
<p>调试时可查看 QuerySet 生成的 SQL</p>
<pre><code class="language-python">queryset = Book.objects.filter(author="John")
print(queryset.query)  # 输出对应的SQL语句
</code></pre>
<h2 id="四项目实战">四、项目实战</h2>
<h3 id="场景">场景</h3>
<p>Django+Vue 后台管理系统中，一般需要支持不同的数据权限</p>
<ul>
<li>仅本人数据权限</li>
<li>本部门及以下数据权限</li>
<li>本部门数据权限</li>
<li>指定部门数据权限</li>
<li>全部数据权限</li>
</ul>
<p><img alt="image-20250801113536987" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250801145141393-1587642265.png" class="lazyload"></p>
<p>数据权限与功能权限（基于RBAC实现）的区别</p>
<ul>
<li>功能权限：控制 “能做什么”（如新增、删除按钮的显示和执行）</li>
<li>数据权限：控制 “能看到什么数据”（如销售经理只能查看自己团队的数据）</li>
</ul>
<h3 id="实战">实战</h3>
<p>使用Q() 对象构建复杂查询，实现灵活的数据权限计算</p>
<p><img alt="image-20250801113855216" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250801145148416-2126063402.png" class="lazyload"></p>
<p><a href="https://gitee.com/zhulj993/mars-mgn/blob/master/mysite/mars_framework/viewsets/base.py" target="_blank" rel="noopener nofollow">点击查看完整代码</a></p>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-01 14:53">2025-08-01 14:52</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">109</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19016894);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19016894', targetLink: 'https://www.cnblogs.com/xwz1024/p/19016894', title: 'Django模型查询与性能调优：告别N+1问题' })">举报</a>
</div>
	