
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18722469" title="发布于 2025-02-18 17:13">
    <span role="heading" aria-level="2">面试官：谈谈RabbitMQ的队头阻塞问题？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>RabbitMQ 延迟消息的队头阻塞问题是指，在使用死信队列（DLX）和 TTL（消息过期时间）实现延迟消息时，<strong>由于队列的先进先出（FIFO）特性，在队列头部消息未过期的情况下，即使后续消息已经过期也不能及时处理的情况</strong>。</p>
<h2 id="实现原理">实现原理</h2>
<p>RabbitMQ 延迟消息的实现方式有以下两种：</p>
<ol>
<li><strong>死信队列+TTL</strong>。</li>
<li><strong>使用 rabbitmq-delayed-message-exchange 插件</strong>。</li>
</ol>
<p>而我们本文要讨论的“RabbitMQ 延迟消息的队头阻塞问题”只会发生在死信队列+TTL 的实现方式中。</p>
<p>死信队列 + TTL 的实现流程如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1739867620388-d8fea771-c020-4080-b539-7dab76ce3663.png" alt="" loading="lazy"></p>
<ol>
<li>生产者先将设置了 TTL（过期时间）的消息发送到普通队列。</li>
<li>普通队列没有消息者，所以一定会过期，消息过期之后就会发送到死信队列。</li>
<li>消费者订阅死信队列获取消息，并执行延迟任务。</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<p>死信队列 + TTL 在 Spring Boot 项目中的实现代码如下。</p>
<ol>
<li><strong>定义死信<strong><strong>交换器</strong></strong>（DLX）和死信队列</strong>：</li>
</ol>
<pre><code class="language-java">// Spring Boot 配置示例
@Configuration
public class RabbitConfig {
    // 定义死信交换器
    @Bean
    public DirectExchange dlxExchange() {
        return new DirectExchange("dlx.exchange");
    }

    // 定义死信队列
    @Bean
    public Queue dlxQueue() {
        return new Queue("dlx.queue");
    }

    // 绑定死信队列到 DLX
    @Bean
    public Binding dlxBinding() {
        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with("dlx.routing.key");
    }

    // 定义普通队列，设置死信交换器和路由键
    @Bean
    public Queue mainQueue() {
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put("x-dead-letter-exchange", "dlx.exchange");
        args.put("x-dead-letter-routing-key", "dlx.routing.key");
        // 可选：设置队列级别的 TTL（所有消息统一过期时间）
        args.put("x-message-ttl", 10000); // 10秒
        return new Queue("main.queue", true, false, false, args);
    }

    // 主队列绑定到默认交换器（根据需要调整）
    @Bean
    public Binding mainBinding() {
        return BindingBuilder.bind(mainQueue()).to(new DirectExchange("default.exchange")).with("main.routing.key");
    }
}
</code></pre>
<ol start="2">
<li><strong>发送消息时设置 <strong><strong>TTL</strong></strong>（消息级别）</strong>：</li>
</ol>
<pre><code class="language-java">// 发送延迟消息（消息级别 TTL）
public void sendDelayedMessage(String message, int delayMs) {
    rabbitTemplate.convertAndSend("default.exchange", "main.routing.key", message, msg -&gt; {
        // 设置消息过期时间（覆盖队列级别的 TTL）
        msg.getMessageProperties().setExpiration(String.valueOf(delayMs));
        return msg;
    });
}
</code></pre>
<ol start="3">
<li><strong>消费者监听死信队列</strong>：</li>
</ol>
<pre><code class="language-java">@RabbitListener(queues = "dlx.queue")
public void handleDelayedMessage(String message) {
System.out.println("处理延迟消息: " + message);
}
</code></pre>
<p>所以说消息的过期时间 TTL 的设置方式有以下两种：</p>
<ol>
<li><strong>队列级别</strong>：通过设置队列的 x-message-ttl 参数，设置队列统一的过期时间。</li>
</ol>
<pre><code class="language-java">Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
args.put("x-message-ttl", 60000); // 设置队列消息过期时间为 60 秒
channel.queueDeclare(queueName, true, false, false, args);
</code></pre>
<ol start="2">
<li><strong>消息级别</strong>：通过给每个消息设置 expiration 属性，为每个消息设置过期时间。</li>
</ol>
<pre><code class="language-java">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
        .deliveryMode(2) // 消息持久化
        .expiration("60000") // 设置消息过期时间为 60 秒
        .build();
channel.basicPublish(exchangeName, routingKey, properties, message.getBytes());
</code></pre>
<p>如果同时设置了消息级 TTL 和队列级 TTL，消息的实际过期时间会取两者中的最小值。</p>
<h2 id="造成队头阻塞的原因">造成队头阻塞的原因</h2>
<p>造成队头阻塞的原因有以下两个：</p>
<ol>
<li><strong>先进先出的队列特性</strong>：队列中的消息必须按顺序处理，即使后面的消息 TTL 较短且已过期，也必须等待队头的消息先被处理（或过期）。</li>
<li><strong>TTL 检查机制</strong>：RabbitMQ 默认仅在处理队头消息时检查其 TTL，如果队头消息的 TTL 较长（例如 10 分钟），即使后续消息的 TTL 更短（例如 1 分钟），这些消息也会被阻塞，直到队头消息过期或被移除。</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1739868352319-6d14026d-0d62-487a-82ce-5baf3152c9af.png" alt="" loading="lazy"></p>
<h2 id="解决方案">解决方案</h2>
<ol>
<li><strong>为不同延迟时间创建独立队列</strong>：将相同 TTL 的消息放入同一队列，避免消息的过期时间不一致。</li>
<li><strong>使用延迟插件</strong>：使用 RabbitMQ 的延迟插件 rabbitmq_delayed_message_exchange，直接通过延迟交换机实现延迟消息，绕过死信队列的 FIFO 限制。延迟插件是通过将消息存储到内置数据库 Mnesia，再通过不断判断过期消息，实现延迟消息的投递和执行的，因此它不存在队列的先进先出和队头阻塞的问题。</li>
</ol>
<h2 id="小结">小结</h2>
<p>队头阻塞问题是发生在使用死信队列加 TTL 实现 RabbitMQ 延迟消息的场景中，造成的原因是队列先进先出的特性，加上延迟消息的检查机制导致的，我们可以使用 RabbitMQ 的延迟插件来避免此问题。</p>
<p>那么问题来了，使用延迟插件如何实现延迟任务？它和死信队列的实现方式有哪些具体的区别呢？</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：场景题、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列等模块。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.043022122159722224" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-18 17:14">2025-02-18 17:13</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">40</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18722469" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18722469);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18722469', targetLink: 'https://www.cnblogs.com/vipstone/p/18722469', title: '面试官：谈谈RabbitMQ的队头阻塞问题？' })">举报</a>
</div>
        