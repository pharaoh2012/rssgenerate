
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MintBH/p/19065578" title="发布于 2025-08-30 11:52">
    <span role="heading" aria-level="2">FPGA:同步复位、异步复位与异步复位同步释放</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>以下皆以低电平有效的复位信号为例，内容参考 <strong>@数字逻辑君Zlaker</strong></p>
<hr>
<p><strong>同步复位</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2597964/202508/2597964-20250830104214396-1172438150.png" alt="QQ20250830-104135" loading="lazy"></p>
<pre><code>module sync_rest(
  input        sys_clk,
  input        sys_rst_n,
  input        i_din,
  output wire  o_dout
);

reg r_dout;
assign o_dout = r_dout;//方便例化

always @(posedge sys_clk) begin
  if (!sys_rst_n)
    r_dout &lt;= 1'd0;
  else
    r_dout &lt;= i_din;
end

endmodule
</code></pre>
<p>特点说明：<br>
  当复位信号有效时，只能在时钟上升沿的时候更新，能有效避免毛刺干扰，但对复位信号的脉宽有一定的要求（至少大于一个周期）</p>
<hr>
<p><strong>异步复位</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2597964/202508/2597964-20250830105714449-1114013366.png" alt="QQ20250830-105651" loading="lazy"></p>
<pre><code>module async_rest(
  input        sys_clk,
  input        sys_rst_n,
  input        i_din,
  output wire  o_dout
);

reg r_dout;
assign o_dout = r_dout;//方便例化

always @(posedge sys_clk or negedge sys_rst_n) begin
  if (!sys_rst_n)
    r_dout &lt;= 1'd0;
  else
    r_dout &lt;= i_din;
end

endmodule
</code></pre>
<p>特点说明：<br>
  在复位信号有效时立即更新，但是抗干扰能力弱，容易被毛刺误触发</p>
<hr>
<p><strong>异步复位同步释放</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2597964/202508/2597964-20250830110109279-1832493735.png" alt="QQ20250830-110019" loading="lazy"></p>
<pre><code>module async_rest_sync_release(
  input sys_clk,
  input i_sys_async_rst_n,
  output sys_rst_n
);
reg [1:0] r_sync_rest_n;
assign sys_rst_n=r_sync_rest_n[1];
always @(posedge sys_clk or negedge i_sys_async_rst_n) begin
  if (!i_sys_async_rst_n)
    r_sync_rest_n&lt;=2'b00;
  else begin
    r_sync_rest_n[0]&lt;=1'b1;
    r_sync_rest_n[1]&lt;=r_sync_rest_n[0];
  end
end
endmodule
</code></pre>
<p>仿真<br>
<img src="https://img2024.cnblogs.com/blog/2597964/202508/2597964-20250830113214845-1694748618.png" alt="image" loading="lazy"><br>
特点说明：<br>
  与异步复位类似，在复位信号有效时立即更新，但是通过寄存器打一拍拓宽了复位信号，这样同步释放后，后续的模块都可以使用同步复位，无需担心捕捉不到脉宽小的复位信号。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-30 11:52">2025-08-30 11:52</span>&nbsp;
<a href="https://www.cnblogs.com/MintBH">薄荷BH</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19065578);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19065578', targetLink: 'https://www.cnblogs.com/MintBH/p/19065578', title: 'FPGA:同步复位、异步复位与异步复位同步释放' })">举报</a>
</div>
        