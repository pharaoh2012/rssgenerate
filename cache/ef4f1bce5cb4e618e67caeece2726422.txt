
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18849484" title="发布于 2025-04-27 15:04">
    <span role="heading" aria-level="2">微服务之间有哪些调用方式？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>随着微服务架构的广泛应用，服务之间的通信方式成为了系统设计中的重要一环。微服务的核心理念是将系统拆分为多个独立的服务，每个服务负责特定的业务功能。为了实现这些服务之间的协作，通信方式的选择至关重要。</p>
<h5 id="微服务之间的通信方式主要分为两大类"><strong>微服务之间的通信方式主要分为两大类：</strong></h5>
<ol>
<li><strong>同步通信</strong>：服务之间直接调用，通常需要立即返回结果。</li>
<li><strong>异步通信</strong>：服务之间通过消息队列等中间件进行通信，调用方无需等待结果。</li>
</ol>
<h4 id="一同步通信实时交互强依赖场景">一、同步通信<font style="color: rgba(64, 64, 64, 1)">：实时交互，强依赖场景</font></h4>
<h5 id="1-httprestful-api">1. <strong>HTTP/RESTful API</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>基于HTTP协议，使用JSON/XML传输数据</li>
<li>简单通用，跨语言兼容性强</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要实时响应的操作（如支付、库存扣减）</li>
<li>外部系统对接或前后端分离架构</li>
</ul>
<p><strong>.NET Core示例</strong>：</p>
<pre><code class="language-csharp">// 订单服务调用库存服务（同步HTTP调用）
[HttpPost("create")]
public async Task&lt;IActionResult&gt; CreateOrder([FromBody] OrderDto order)
{
    // 调用库存服务接口
    using var client = _httpClientFactory.CreateClient();
    var response = await client.PostAsJsonAsync(
        "http://xxxxxx/api/stock/deduct",
        new { order.ProductId, order.Quantity }
    );
    
    if (!response.IsSuccessStatusCode)
        return BadRequest("库存不足");
    
    // 继续处理订单逻辑...
    return Ok();
}
</code></pre>
<p><strong>选型建议</strong>：</p>
<ul>
<li>优先选择短链路、低延迟的内部调用</li>
<li>配合熔断器（如Polly）防止级联故障</li>
</ul>
<h5 id="2-grpc">2. <strong>gRPC</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>基于HTTP/2协议，高性能二进制传输</li>
<li>支持双向流、多语言代码自动生成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>高频内部服务调用（如数据分析、实时监控）</li>
<li>需要流式数据传输（如文件上传、实时聊天）</li>
</ul>
<p><strong>.NET Core示例</strong>：</p>
<ol>
<li>定义Proto文件（stock.proto）：</li>
</ol>
<pre><code class="language-protobuf">syntax = "proto3";
service StockService {
    rpc DeductStock (DeductRequest) returns (DeductResponse);
}
message DeductRequest {
    string productId = 1;
    int32 quantity = 2;
}
message DeductResponse {
    bool success = 1;
}
</code></pre>
<ol start="2">
<li>服务端实现：</li>
</ol>
<pre><code class="language-csharp">public class StockService : StockService.StockServiceBase
{
    public override Task&lt;DeductResponse&gt; DeductStock(DeductRequest request, ServerCallContext context)
    {
        // 扣减库存逻辑
        return Task.FromResult(new DeductResponse { Success = true });
    }
}
</code></pre>
<ol start="3">
<li>客户端调用：</li>
</ol>
<pre><code class="language-csharp">var channel = GrpcChannel.ForAddress("http://xxxxxx:5000");
var client = new StockService.StockServiceClient(channel);
var response = await client.DeductStockAsync(new DeductRequest { ProductId = "P1001", Quantity = 5 });
</code></pre>
<p><strong>选型建议</strong>：</p>
<ul>
<li>适合对性能要求高的内部服务</li>
<li>避免在浏览器端直接使用</li>
</ul>
<h4 id="二异步通信解耦系统提升吞吐量">二、异步通信：解耦系统，提升吞吐量</h4>
<h5 id="1-消息队列rabbitmqkafka">1. <strong>消息队列（RabbitMQ/Kafka）</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>基于发布/订阅模型，削峰填谷</li>
<li>支持消息持久化、重试机制</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>非实时任务（如发送邮件、生成报表）</li>
<li>事件驱动架构（如订单状态变更通知）</li>
</ul>
<p><strong>.NET Core示例（RabbitMQ）</strong>：</p>
<ol>
<li>生产者（订单服务）：</li>
</ol>
<pre><code class="language-csharp">var factory = new ConnectionFactory { HostName = "rabbitmq" };
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

// 声明队列
channel.QueueDeclare(queue: "order_created", durable: true);

// 发布消息
var message = new { OrderId = Guid.NewGuid(), Amount = 100.0 };
var body = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));

channel.BasicPublish(exchange: "", routingKey: "order_created", body: body);
</code></pre>
<ol start="2">
<li>消费者（通知服务）：</li>
</ol>
<pre><code class="language-csharp">var factory = new ConnectionFactory { HostName = "rabbitmq" };
var connection = factory.CreateConnection();
var channel = connection.CreateModel();

var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =&gt;
{
    var body = ea.Body.ToArray();
    var message = JsonSerializer.Deserialize&lt;OrderCreatedEvent&gt;(body);
    // 发送短信通知用户
    _smsService.Send(message.UserId, "您的订单已创建");
};
channel.BasicConsume(queue: "order_created", autoAck: true, consumer: consumer);
</code></pre>
<p><strong>选型建议</strong>：</p>
<ul>
<li>RabbitMQ适合中小规模，Kafka适合高吞吐量场景</li>
<li>使用MassTransit库简化消息处理（支持重试、死信队列）</li>
</ul>
<h5 id="2-事件总线event-bus">2. <strong>事件总线（Event Bus）</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>服务间通过事件（Event）广播状态变化</li>
<li>松耦合，支持事件溯源（Event Sourcing）</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>跨服务状态同步（如用户注销后清理多系统数据）</li>
<li>审计日志、数据一致性补偿</li>
</ul>
<p><strong>.NET Core示例（使用MediatR实现事件总线）</strong>：</p>
<pre><code class="language-csharp">// 定义事件
public class OrderCreatedEvent : INotification
{
    public Guid OrderId { get; set; }
    public decimal Amount { get; set; }
}

// 发布事件（订单服务）
[HttpPost]
public async Task&lt;IActionResult&gt; CreateOrder([FromBody] OrderDto order)
{
    // 创建订单逻辑...
    await _mediator.Publish(new OrderCreatedEvent { OrderId = order.Id, Amount = order.Amount });
    return Ok();
}

// 订阅事件（日志服务）
public class LogOrderCreatedEventHandler : INotificationHandler&lt;OrderCreatedEvent&gt;
{
    public Task Handle(OrderCreatedEvent notification, CancellationToken cancellationToken)
    {
        _logger.LogInformation($"订单已创建：ID={notification.OrderId}, 金额={notification.Amount}");
        return Task.CompletedTask;
    }
}
</code></pre>
<p><strong>选型建议</strong>：</p>
<ul>
<li>结合CQRS模式使用效果更佳</li>
<li>使用<code>CAP</code>库实现分布式事务（支持本地消息表）</li>
</ul>
<h4 id="三高级通信模式服务网格与网关">三、高级通信模式：服务网格与网关</h4>
<h5 id="1-服务网格service-mesh">1. <strong>服务网格（Service Mesh）</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>通过Sidecar代理管理通信</li>
<li>提供熔断、限流、链路追踪等治理能力</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>大规模微服务集群</li>
<li>需要统一的安全策略和监控</li>
</ul>
<p><strong>.NET Core集成示例（使用Consul + Envoy）</strong>：</p>
<pre><code class="language-csharp">// 服务注册（Startup.cs）
services.AddConsulConfig(Configuration);

// 服务发现调用
var client = _httpClientFactory.CreateClient("consul");
var response = await client.GetAsync("http://inventory-service-xxxxxx/api/stock");
</code></pre>
<h5 id="2-api网关ocelotyarp">2. <strong>API网关（Ocelot/YARP）</strong></h5>
<p><strong>核心特点</strong>：</p>
<ul>
<li>统一入口，聚合路由、鉴权、限流</li>
<li>减少客户端与服务的直接耦合</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>多终端应用（Web、Mobile、第三方API）</li>
<li>需要集中式权限管理</li>
</ul>
<p><strong>.NET Core示例（Ocelot配置）</strong>：</p>
<pre><code class="language-json">// ocelot.json
{
  "Routes": [
    {
      "DownstreamPathTemplate": "/api/orders/{everything}",
      "DownstreamScheme": "http",
      "UpstreamPathTemplate": "/gateway/orders/{everything}",
      "UpstreamHttpMethod": [ "GET", "POST" ],
      "ServiceName": "order-service",
      "LoadBalancerOptions": { "Type": "LeastConnection" }
    }
  ]
}
</code></pre>
<hr>
<h4 id="四如何选择通信方式一张表搞定">四、如何选择通信方式？一张表搞定！</h4>
<table>
<thead>
<tr>
<th><strong>通信方式</strong></th>
<th><strong>延迟</strong></th>
<th><strong>耦合性</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>推荐工具</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/REST</td>
<td>高</td>
<td>强</td>
<td>外部API、简单查询</td>
<td>HttpClientFactory + Polly</td>
</tr>
<tr>
<td>gRPC</td>
<td>低</td>
<td>中</td>
<td>内部高性能调用、流式数据</td>
<td>Grpc.AspNetCore</td>
</tr>
<tr>
<td>消息队列</td>
<td>可变</td>
<td>弱</td>
<td>异步任务、事件驱动</td>
<td>RabbitMQ.Client + MassTransit</td>
</tr>
<tr>
<td>事件总线</td>
<td>中</td>
<td>弱</td>
<td>跨服务状态同步、审计日志</td>
<td>MediatR + CAP</td>
</tr>
<tr>
<td>服务网格</td>
<td>中</td>
<td>弱</td>
<td>大规模集群治理</td>
<td>Consul + Envoy</td>
</tr>
</tbody>
</table>
<p><strong>参考</strong>：</p>
<ol>
<li><font style="color: rgba(64, 64, 64, 1)">是否需要实时响应？  </font></li>
</ol>
<ul>
<li><strong><font style="color: rgba(64, 64, 64, 1)">是</font></strong><font style="color: rgba(64, 64, 64, 1)">：选同步（HTTP/gRPC）；</font></li>
<li><strong><font style="color: rgba(64, 64, 64, 1)">否</font></strong><font style="color: rgba(64, 64, 64, 1)">：选异步（消息队列）</font></li>
</ul>
<ol start="2">
<li><font style="color: rgba(64, 64, 64, 1)">是否跨团队/跨语言？ </font></li>
</ol>
<ul>
<li><strong><font style="color: rgba(64, 64, 64, 1)">是</font></strong><font style="color: rgba(64, 64, 64, 1)">：优先HTTP/REST；</font></li>
<li><strong><font style="color: rgba(64, 64, 64, 1)">否</font></strong><font style="color: rgba(64, 64, 64, 1)">：优先gRPC</font></li>
</ul>
<ol start="3">
<li><font style="color: rgba(64, 64, 64, 1)">是否需要严格顺序？   </font></li>
</ol>
<ul>
<li><strong><font style="color: rgba(64, 64, 64, 1)">是</font></strong><font style="color: rgba(64, 64, 64, 1)">：选Kafka分区队列；</font></li>
<li><strong><font style="color: rgba(64, 64, 64, 1)">否</font></strong><font style="color: rgba(64, 64, 64, 1)">：选RabbitMQ</font></li>
</ul>
<ol start="4">
<li><font style="color: rgba(64, 64, 64, 1)">是否需要治理能力？   </font></li>
</ol>
<ul>
<li><strong><font style="color: rgba(64, 64, 64, 1)">是</font></strong><font style="color: rgba(64, 64, 64, 1)">：引入服务网格</font></li>
</ul>
<h4 id="五实战经验总结">五、实战经验总结</h4>
<ol>
<li><strong>避免过度设计</strong>
<ul>
<li>中小型系统优先使用HTTP+消息队列组合</li>
<li>仅在必要时引入服务网格等复杂架构</li>
</ul>
</li>
<li><strong>容错是关键</strong></li>
</ol>
<pre><code class="language-csharp">// 使用Polly实现重试与熔断
services.AddHttpClient("InventoryService")
    .AddTransientHttpErrorPolicy(policy =&gt; 
        policy.WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))
    .AddCircuitBreaker(5, TimeSpan.FromSeconds(30));
</code></pre>
<ol start="3">
<li><strong>监控与可观测性</strong>
<ul>
<li>使用Prometheus+Grafana监控接口耗时、错误率</li>
<li>通过SkyWalking或Elastic APM追踪跨服务调用链</li>
</ul>
</li>
<li><strong>协议升级策略</strong>
<ul>
<li>从HTTP逐步迁移到gRPC：先在新服务试点，再逐步改造旧服务</li>
<li>使用API网关统一新旧协议入口</li>
</ul>
</li>
</ol>
<h4 id="结语">结语</h4>
<p>微服务通信方式的选择没有“银弹”，核心在于理解业务需求与技术特性的平衡。在.NET Core生态中，开发者可以灵活选择从轻量级HTTP到高性能gRPC，再到解耦的消息队列，结合服务网格等高级模式，构建适应不同场景	的通信体系。</p>
<p><strong>记住</strong>：</p>
<ul>
<li>80%的场景可以用HTTP+消息队列覆盖</li>
<li>性能优化前先确保功能正确性</li>
<li>可观测性比协议本身更重要<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202504/2063798-20250427150405340-1464468825.png" alt="" loading="lazy"></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.22304978859722221" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-27 15:06">2025-04-27 15:04</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18849484);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18849484', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18849484', title: '微服务之间有哪些调用方式？' })">举报</a>
</div>
        