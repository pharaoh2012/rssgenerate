
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/VAllen/p/18658766/rx-iobservable-iobserver" title="发布于 2025-01-08 00:53">
    <span role="heading" aria-level="2">.NET 响应式编程 System.Reactive 系列文章（二）：深入理解 IObservable&lt;T&gt; 和 IObserver&lt;T&gt;</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/402416/202501/402416-20250108004920205-597723571.png" alt=".NET 响应式编程 System.Reactive 系列文章（二）：深入理解 IObservable&amp;lt;T&amp;gt; 和 IObserver&amp;lt;T&amp;gt;" class="desc_img">
        在 Rx 中，数据流的生产和消费是通过 观察者模式（Observer Pattern） 实现的。这种模式定义了两种角色：IObservable和IObserver
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="net-响应式编程-systemreactive-系列文章二深入理解-iobservablet-和-iobservert"><strong>.NET 响应式编程 System.Reactive 系列文章（二）：深入理解 IObservable&lt;T&gt; 和 IObserver&lt;T&gt;</strong></h1>
<hr>
<h2 id="引言为什么我们调整了学习顺序"><strong>引言：为什么我们调整了学习顺序？</strong></h2>
<p>在上一篇文章的结尾，我原本计划在本篇介绍 <strong>System.Reactive</strong> 的基础操作符，比如如何创建、转换和过滤数据流。但在撰写内容时，我意识到，对于刚接触 <strong>System.Reactive</strong> 的读者来说，直接介绍操作符可能有些仓促，因为 <strong>操作符的使用必须建立在对 <code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code> 这两个核心接口的深刻理解之上</strong>。</p>
<p>正如在传统编程中，你需要先理解 <strong>集合（Collection）</strong> 和 <strong>迭代器（Iterator）</strong> 的本质，才能更好地使用 <strong>LINQ</strong> 操作符一样。而在 Rx 中，<strong><code>IObservable&lt;T&gt;</code> 是数据流的生产者，<code>IObserver&lt;T&gt;</code> 是数据流的消费者</strong>，理解这两个接口是掌握 Rx 的基础。</p>
<p>因此，我决定调整顺序，在本篇文章中，<strong>深入介绍 <code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code> 的核心概念、方法和使用方式</strong>，为后续学习操作符打下坚实的基础。</p>
<hr>
<h2 id="iobservablet-和-iobservert-的关系"><strong>IObservable&lt;T&gt; 和 IObserver&lt;T&gt; 的关系</strong></h2>
<p>在 Rx 中，数据流的生产和消费是通过 <strong>观察者模式（Observer Pattern）</strong> 实现的。这种模式定义了两种角色：</p>
<ul>
<li><strong><code>IObservable&lt;T&gt;</code>（可观察对象/数据流的生产者）</strong></li>
<li><strong><code>IObserver&lt;T&gt;</code>（观察者/数据流的消费者）</strong></li>
</ul>
<p>二者的关系可以简单理解为：</p>
<ul>
<li><strong><code>IObservable&lt;T&gt;</code> 负责“推送”数据项</strong>。</li>
<li><strong><code>IObserver&lt;T&gt;</code> 负责“接收”数据项</strong>。</li>
</ul>
<p><strong>订阅（Subscribe）</strong> 是连接这两者的桥梁。当 <code>IObserver&lt;T&gt;</code> 订阅一个 <code>IObservable&lt;T&gt;</code> 时，数据流开始传递。</p>
<hr>
<h3 id="1-iobservablet-的定义和职责"><strong>1. <code>IObservable&lt;T&gt;</code> 的定义和职责</strong></h3>
<h4 id="iobservablet-接口定义"><strong><code>IObservable&lt;T&gt;</code> 接口定义</strong></h4>
<pre><code class="language-csharp">public interface IObservable&lt;out T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}
</code></pre>
<p><strong><code>IObservable&lt;T&gt;</code> 的职责：</strong></p>
<ul>
<li>代表一个<strong>数据流</strong>，它可以产生零个、一个或多个数据项。</li>
<li>当一个观察者（<code>IObserver&lt;T&gt;</code>）订阅这个数据流时，它会调用 <strong><code>Subscribe</code></strong> 方法，并开始推送数据。</li>
<li>数据流可能会因为<strong>正常完成</strong>或<strong>发生错误</strong>而终止。</li>
</ul>
<hr>
<h3 id="2-iobservert-的定义和职责"><strong>2. <code>IObserver&lt;T&gt;</code> 的定义和职责</strong></h3>
<h4 id="iobservert-接口定义"><strong><code>IObserver&lt;T&gt;</code> 接口定义</strong></h4>
<pre><code class="language-csharp">public interface IObserver&lt;in T&gt;
{
    void OnNext(T value);
    void OnError(Exception error);
    void OnCompleted();
}
</code></pre>
<p><strong><code>IObserver&lt;T&gt;</code> 的职责：</strong></p>
<ul>
<li>代表一个<strong>数据的消费者</strong>，它对 <code>IObservable&lt;T&gt;</code> 提供的数据流做出响应。</li>
<li><code>IObserver&lt;T&gt;</code> 需要实现三个方法：
<ul>
<li><strong><code>OnNext(T value)</code></strong>：当有新的数据项时调用。</li>
<li><strong><code>OnError(Exception error)</code></strong>：当数据流发生错误时调用。</li>
<li><strong><code>OnCompleted()</code></strong>：当数据流正常结束时调用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-iobservablet-和-iobservert-的交互流程"><strong>3. <code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code> 的交互流程</strong></h3>
<p>让我们通过一个实际的交互流程图来直观地理解 <strong><code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code></strong> 的关系：</p>
<ol>
<li><strong>观察者（Observer）通过 <code>Subscribe</code> 方法订阅可观察对象（Observable）。</strong></li>
<li><strong>可观察对象（Observable）调用 Observer 的 <code>OnNext</code> 方法推送数据。</strong></li>
<li><strong>如果发生错误，可观察对象（Observable）调用 <code>OnError</code> 方法终止数据流。</strong></li>
<li><strong>如果数据流正常结束，可观察对象（Observable）调用 <code>OnCompleted</code> 方法终止数据流。</strong></li>
</ol>
<div class="mermaid">sequenceDiagram
    participant Observable as IObservable&lt;T&gt;
    participant Observer as IObserver&lt;T&gt;

    Observer -&gt;&gt; Observable: Subscribe()
    Observable -&gt;&gt; Observer: OnNext(T value)
    Observable -&gt;&gt; Observer: OnNext(T value)
    alt 数据流正常结束
        Observable -&gt;&gt; Observer: OnCompleted()
    else 发生错误
        Observable -&gt;&gt; Observer: OnError(Exception error)
    end
</div><hr>
<h3 id="4-示例代码实现一个简单的-observable-和-observer"><strong>4. 示例代码：实现一个简单的 Observable 和 Observer</strong></h3>
<p>为了更好地理解这两个接口，我们从零开始，手动实现一个简单的 <code>IObservable</code> 和 <code>IObserver</code>。</p>
<h4 id="实现自定义-observable"><strong>实现自定义 Observable</strong></h4>
<pre><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;

public sealed class SimpleObservable : IObservable&lt;int&gt;
{
	IDisposable IObservable&lt;int&gt;.Subscribe(IObserver&lt;int&gt; observer)
	{
		SimpleDisposable disposable = new();

		Task.Run(() =&gt;
		{
			// 模拟数据的生产，以及假设每次生产都需要时间，消费者可以随时调用Dispose方法取消订阅
			for (int i = 1; i &lt;= 5; i++)
			{
				if (disposable.IsDisposed)
				{
					return;
				}
				observer.OnNext(i);
                // 模拟产生数据需要耗时50毫秒
				Thread.Sleep(50);
			}

			observer.OnCompleted();
		});

		return disposable;
	}

	private sealed class SimpleDisposable : IDisposable
	{
		internal bool IsDisposed { get; private set; }
		void IDisposable.Dispose()
		{
			IsDisposed = true;
			Console.WriteLine("Subscription disposed.");
		}
	}
}
</code></pre>
<h4 id="实现自定义-observer"><strong>实现自定义 Observer</strong></h4>
<pre><code class="language-csharp">using System;

public sealed class SimpleObserver : IObserver&lt;int&gt;
{
	void IObserver&lt;int&gt;.OnNext(int value) =&gt; Console.WriteLine($"Received: {value}");

	void IObserver&lt;int&gt;.OnError(Exception error) =&gt; Console.WriteLine($"Error: {error.Message}");

	void IObserver&lt;int&gt;.OnCompleted() =&gt; Console.WriteLine("Sequence Completed.");
}
</code></pre>
<h4 id="订阅和运行"><strong>订阅和运行</strong></h4>
<pre><code class="language-csharp">using System;
using System.Threading;

class Program
{
	static void Main(string[] args)
	{
		IObservable&lt;int&gt; observable = new SimpleObservable();
		IObserver&lt;int&gt; observer = new SimpleObserver();

		IDisposable subscription = observable.Subscribe(observer);

        // 模拟消费数据100毫秒后取消订阅
		Thread.Sleep(100);
		subscription.Dispose();
	}
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Received: 1
Received: 2
Subscription disposed.
</code></pre>
<hr>
<h3 id="5-常见问题解答"><strong>5. 常见问题解答</strong></h3>
<h4 id="q1为什么-subscribe-方法返回-idisposable"><strong>Q1：为什么 <code>Subscribe</code> 方法返回 <code>IDisposable</code>？</strong></h4>
<p><code>Subscribe</code> 方法返回一个 <strong><code>IDisposable</code></strong> 对象，允许订阅者在不再需要数据流时<strong>取消订阅</strong>，以释放资源，避免内存泄漏。</p>
<h4 id="q2onerror-和-oncompleted-可以同时调用吗"><strong>Q2：<code>OnError</code> 和 <code>OnCompleted</code> 可以同时调用吗？</strong></h4>
<p>不能。<strong>数据流要么以错误终止，要么正常结束</strong>，二者是<strong>互斥的</strong>。</p>
<h4 id="q3iobservablet-可以被多个-iobservert-订阅吗"><strong>Q3：<code>IObservable&lt;T&gt;</code> 可以被多个 <code>IObserver&lt;T&gt;</code> 订阅吗？</strong></h4>
<p>可以。一个 <strong><code>IObservable&lt;T&gt;</code></strong> 可以被<strong>多个观察者</strong>订阅，每个观察者都会接收到数据流的推送。</p>
<hr>
<h2 id="总结"><strong>总结</strong></h2>
<p>在本篇文章中，我们深入探讨了 <strong><code>IObservable&lt;T&gt;</code> 和 <code>IObserver&lt;T&gt;</code></strong> 这两个核心接口的定义和职责，并通过代码示例展示了它们如何交互。</p>
<h3 id="核心要点"><strong>核心要点：</strong></h3>
<ol>
<li><strong><code>IObservable&lt;T&gt;</code> 是数据流的生产者</strong>，它负责推送数据。</li>
<li><strong><code>IObserver&lt;T&gt;</code> 是数据流的消费者</strong>，它负责接收和处理数据。</li>
<li><strong><code>Subscribe</code> 方法将生产者和消费者连接起来</strong>，并返回一个 <strong><code>IDisposable</code></strong> 对象，用于取消订阅。</li>
</ol>
<hr>
<h3 id="下一篇文章预告"><strong>下一篇文章预告</strong></h3>
<blockquote>
<p><strong>《.NET 响应式编程 System.Reactive 系列文章（三）：Subscribe 和 IDisposable 的深入理解》</strong><br>
在下一篇文章中，我们将重点探讨 <strong><code>Subscribe</code> 方法的内部工作机制</strong>、<strong><code>IDisposable</code> 的作用</strong>，以及如何<strong>优雅地管理订阅的生命周期</strong>。敬请期待！</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    作者：<a href="http://www.cnblogs.com/vallen/" target="_blank" title="VAllen">VAllen</a><br>出处：<a href="http://www.cnblogs.com/vallen" target="_blank" title="http://www.cnblogs.com/vallen">http://www.cnblogs.com/vallen</a><br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br><b>唯有偏执者得以生存。</b>
<img src="http://www.cnblogs.com/images/xml.gif" style="display:none;" onload="var s3=document.createElement('script');s3.text=decodeURIComponent(escape(window.atob('JCgiPGRpdiBjbGFzcz0nYmRzaGFyZWJ1dHRvbmJveCcgc3R5bGU9J21hcmdpbi10b3A6MTBweDsnPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfbW9yZScgZGF0YS1jbWQ9J21vcmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3F6b25lJyBkYXRhLWNtZD0ncXpvbmUnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RzaW5hJyBkYXRhLWNtZD0ndHNpbmEnPjwvYT48YSBocmVmPScjJyBjbGFzcz0nYmRzX3RxcScgZGF0YS1jbWQ9J3RxcSc+PC9hPjxhIGhyZWY9JyMnIGNsYXNzPSdiZHNfcmVucmVuJyBkYXRhLWNtZD0ncmVucmVuJz48L2E+PGEgaHJlZj0nIycgY2xhc3M9J2Jkc193ZWl4aW4nIGRhdGEtY21kPSd3ZWl4aW4nPjwvYT48L2Rpdj4iKS5pbnNlcnRBZnRlcigiI015U2lnbmF0dXJlIik7d2luZG93Ll9iZF9zaGFyZV9jb25maWc9eyJjb21tb24iOnsiYmRTbnNLZXkiOnt9LCJiZFRleHQiOiIiLCJiZE1pbmkiOiIyIiwiYmRQaWMiOiIiLCJiZFN0eWxlIjoiMCIsImJkU2l6ZSI6IjMyIn0sInNoYXJlIjp7fSwiaW1hZ2UiOnsidmlld0xpc3QiOlsicXpvbmUiLCJ0c2luYSIsInRxcSIsInJlbnJlbiIsIndlaXhpbiJdLCJ2aWV3VGV4dCI6IuWIhuS6q+WIsO+8miIsInZpZXdTaXplIjoiMTYifSwic2VsZWN0U2hhcmUiOnsiYmRDb250YWluZXJDbGFzcyI6bnVsbCwiYmRTZWxlY3RNaW5pTGlzdCI6WyJxem9uZSIsInRzaW5hIiwidHFxIiwicmVucmVuIiwid2VpeGluIl19fTt3aXRoKGRvY3VtZW50KTBbKGdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF18fGJvZHkpLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKS5zcmM9J2h0dHA6Ly9iZGltZy5zaGFyZS5iYWlkdS5jb20vc3RhdGljL2FwaS9qcy9zaGFyZS5qcz92PTg5ODYwNTkzLmpzP2NkbnZlcnNpb249Jyt+KC1uZXcgRGF0ZSgpLzM2ZTUpXTs=')));s3.setAttribute('type','text/javascript');document.body.appendChild(s3);">
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.8778090249849537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-08 01:13">2025-01-08 00:53</span>&nbsp;
<a href="https://www.cnblogs.com/VAllen">VAllen</a>&nbsp;
阅读(<span id="post_view_count">446</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18658766" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18658766);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18658766', targetLink: 'https://www.cnblogs.com/VAllen/p/18658766/rx-iobservable-iobserver', title: '.NET 响应式编程 System.Reactive 系列文章（二）：深入理解 IObservable&amp;lt;T&amp;gt; 和 IObserver&amp;lt;T&amp;gt;' })">举报</a>
</div>
	