
		<div class="postcontent">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="springboot-常用跨域处理方案">SpringBoot 常用跨域处理方案</h1>
<h2 id="1什么是跨域">1.什么是跨域？</h2>
<p>跨域是浏览器为了保障安全而遵循的一种规则，是同源策略的一部分。</p>
<ul>
<li>同源：要求协议、域名、端口三者完全相同。</li>
<li>跨域：只要协议、域名、端口中有任何一个不同，浏览器就会判定为跨域请求。</li>
</ul>
<p>跨域（Cross-Origin）是浏览器独有的安全策略，不存在于安卓、iOS、Node.js、Python、Java 等原生客户端或服务器端环境中。因为浏览器是一个开放的、执行不可信代码，也就是各个网站的 js 脚本的环境，同源策略是为了保证用户的信息安全。</p>
<p>所以，如果平时测试接口用的是 postman 发送请求，不需要关心跨域问题，但是如果是前后端联调就必须处理跨域问题。</p>
<h2 id="2浏览器处理跨域请求的方式">2.浏览器处理跨域请求的方式</h2>
<p>浏览器遵循同源策略，不允许页面获取跨域请求返回的响应结果。</p>
<p>比如：当前网页是 <a href="http://127.0.0.1:63342" target="_blank" rel="noopener nofollow">http://127.0.0.1:63342</a>，然后向服务器 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener nofollow">http://127.0.0.1:8080</a> 发送 GET 请求获取数据。整个过程分成三步：</p>
<ul>
<li>浏览器发送请求</li>
<li>服务器接收请求，处理业务，返回响应</li>
<li>浏览器获取服务器返回的响应并根据响应渲染页面</li>
</ul>
<p>无论是跨域请求还是非跨域请求，浏览器都可以发送给服务器，并且接收服务器返回的响应数据。</p>
<ul>
<li>如果该请求是非跨域请求，则 js 脚本可以访问响应数据</li>
<li>如果该请求是跨域请求，浏览器会拦截响应数据，不让 js 访问这些数据</li>
</ul>
<p>其实浏览器可以向不同的域名发送请求，但是浏览器会拦截响应内容，不让 js 访问，无论请求是否成功。</p>
<h2 id="3跨域处理方案">3.跨域处理方案</h2>
<p>跨域处理的核心：让浏览器不要拦截跨域请求返回的数据。</p>
<p>服务器的响应中如果有 Access-Control-Allow-Origin: * 这个响应头，就是告诉浏览器："我是服务器，虽然我跟这个网页不是同源的，但是我允许这个网页跟我通信，我们之间的通信是安全的"，浏览器就不会拦截 js 对响应数据的访问。</p>
<p>浏览器发送的请求可以分为简单请求和复杂请求：</p>
<ul>
<li>如果是简单请求，则浏览器直接发送。</li>
<li>如果是复杂请求，则浏览器先发送一个预检请求，即 OPTIONS 请求，问一句："我可以发送一个超级复杂的跨域请求吗？"，服务器需要返回针对 OPTIONS 的响应。如果服务器允许发送这个复杂请求，浏览器才会真正发送请求。</li>
</ul>
<p>常见的跨域处理方案有：代理服务器、后端服务器跨域配置。</p>
<h3 id="31代理服务器">3.1代理服务器</h3>
<p>浏览器将请求发送到跟页面同源的代理服务器，代理服务器再将请求转发到目标服务器。因为服务器间通信不受同源策略限制。比如常见的用 nginx 作为代理服务器。</p>
<p>请求处理过程：</p>
<ul>
<li>前端发送请求，请求经过 nginx，请求被转发到后端服务器。</li>
<li>服务器返回原始响应，原始响应经过 nginx，nginx 自动添加 Access-Control-Allow-Origin: * 响应头，响应返回给前端，js 可以访问响应数据。</li>
</ul>
<pre><code># nginx.conf
server {
    listen 63342;
    # 前端页面的域名或ip
    server_name 127.0.0.1;

    # 代理所有以 /api/ 开头的请求到后端服务器
    location /api/ {
        # 后端服务器地址
        proxy_pass http://127.0.0.1:8080/; 

        # 修改请求头，确保后端能收到正确的原始主机信息
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_set_header X-Forwarded-Proto $scheme;

        # 添加CORS响应头，允许所有来源的请求，生产环境应关闭
        add_header 'Access-Control-Allow-Origin' '*'; 
        
        # 允许的请求方法
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH';
        
        if ($request_method = 'OPTIONS') {
            # 对于OPTIONS请求，直接返回204状态码，不需要转发到后端
            return 204;
        }
    }
}
</code></pre>
<h3 id="32-后端跨域配置">3.2 后端跨域配置</h3>
<h4 id="321-配置-cors">3.2.1 配置 CORS</h4>
<p>配置全局 CORS 规则，在所有响应头都配置可以跨域访问。</p>
<pre><code class="language-java">import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 允许所有接口跨域
                .allowCredentials(true) // 允许浏览器在跨域请求中发送认证信息
                .allowedOriginPatterns("*") // 允许访问资源的源(协议、域名、端口)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // 允许的方法
                .allowedHeaders("*") // 允许的请求头
                .exposedHeaders("*"); // 哪些响应头可以暴露给前端js
    }
}
</code></pre>
<h4 id="322-提供-corsfilter">3.2.2 提供 CorsFilter</h4>
<p>提供一个 CorsFilter 的 Bean 作为过滤器。</p>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class MyCorsFilter {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();

        config.addAllowedOriginPattern("*"); // 放行所有域名，生产环境请对此进行修改

        config.setAllowCredentials(true); // 是否发送cookie

        config.addAllowedMethod("*");  // 放行的请求方式

        config.addAllowedHeader("*"); // 放行的请求头

        config.addExposedHeader("*"); // 暴露头部信息

        // UrlBasedCorsConfigurationSource: 可以为不同的URL路径设置不同的CORS规则
        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();
        // 所有的URL路径都使用同一个CORS规则
        corsConfigurationSource.registerCorsConfiguration("/**", config);

        return new CorsFilter(corsConfigurationSource);
    }
}
</code></pre>
<h4 id="323-crossorigin-注解">3.2.3 @CrossOrigin 注解</h4>
<p>在接口类上或者接口方法上添加 @CrossOrigin 注解，表示整个类、单个接口的响应不会被拦截。</p>
<pre><code class="language-java">@RestController
@CrossOrigin
public class DemoController {

    @PutMapping("/put")
    public Integer put(MultipartFile file) {
        System.out.println(file.getOriginalFilename());
        return 200;
    }

    @GetMapping("/get")
    public Integer get() {
        return 200;
    }
}
</code></pre>

</div>
<div class="clear"></div>

		</div>
		<div class="itemdesc">
			posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-25 23:59">2025-08-25 23:59</span>&nbsp;
<a href="https://www.cnblogs.com/ningqw">ningqw</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19057916);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19057916', targetLink: 'https://www.cnblogs.com/ningqw/p/19057916', title: 'SpringBoot 常用跨域处理方案' })">举报</a>

		</div>
	