
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yayujs/p/18737984" title="发布于 2025-02-26 10:49">
    <span role="heading" aria-level="2">Svelte 最新中文文档教程（20）—— TypeScript</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>Svelte，一个语法简洁、入门容易，面向未来的前端框架。从 Svelte 诞生之初，就备受开发者的喜爱，根据统计，<strong>从 2019 年到 2024 年，连续 6 年一直是开发者最感兴趣的前端框架 No.1</strong>：</p>
<p><img src="https://yayujs-blog.oss-cn-beijing.aliyuncs.com/405488775-48df16b1-939c-489b-8d52-6071869893f0.png" alt="image.png" loading="lazy"></p>
<p>Svelte 以其独特的编译时优化机制著称，具有<strong>轻量级</strong>、<strong>高性能</strong>、<strong>易上手</strong>等特性，<strong>非常适合构建轻量级 Web 项目，也是我做个人项目的首选技术栈。</strong></p>
<p>目前 Svelte 基于 Svelte 5 发布了最新的官方文档，但却缺少对应的中文文档。为了帮助大家学习 Svelte，为爱发电翻译了官方文档。</p>
<p>我同时搭建了 Svelte 最新的中文文档站点：<a href="https://svelte.yayujs.com" target="_blank" rel="noopener nofollow">https://svelte.yayujs.com</a> ，如果需要辅助学习，也可以入手我的小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>，语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>虽说是翻译，但个人并不喜欢严格遵守原文，为了保证中文阅读流畅，会删减部分语句，对难懂的部分也会另做补充解释，希望能给大家带来一个好的中文学习体验。</p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上<a href="https://t.zsxq.com/DfGhx" target="_blank" rel="noopener nofollow">“前端大佬成长之路”</a>。</p>
<h2 id="typescript">TypeScript</h2>

<p>您可以在 Svelte 组件中使用 TypeScript。像 <a href="https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode" target="_blank" rel="noopener nofollow">Svelte VS Code 扩展</a> 这样的 IDE 扩展可以帮助您在编辑器中捕获错误，而 <a href="https://www.npmjs.com/package/svelte-check" target="_blank" rel="noopener nofollow"><code>svelte-check</code></a> 在命令行上做相同的事情，您可以将其集成到您的 CI 中。</p>
<h2 id="script-langts"><code>&lt;script lang="ts"&gt;</code></h2>
<p>要在 Svelte 组件中使用 TypeScript，请在 <code>script</code> 标签中添加 <code>lang="ts"</code>：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  let name: string = 'world';

  function greet(name: string) {
    alert(`你好，${name}！`);
  }
&lt;/script&gt;

&lt;button onclick={(e: Event) =&gt; greet(e.target.innerText)}&gt;
  {name as string}
&lt;/button&gt;
</code></pre>
<p>这样做可以让您使用 TypeScript 的 <em>仅使用类型（type-only）</em> 功能。</p>
<p>所谓“仅使用类型”功能，也就是所有在转译为 JavaScript 时会消失的功能，例如类型注解或接口声明。需要 TypeScript 编译器输出实际代码的功能则不被支持，包括：</p>
<ul>
<li>使用枚举（enums）</li>
<li>在构造函数中与初始化器（initializers）一起使用 <code>private</code>、<code>protected</code> 或 <code>public</code> 修饰符</li>
<li>使用尚未成为 ECMAScript 标准的功能（即未达到 TC39 流程的第 4 阶段），因为没有到达最后的阶段，所以 Svelte 用于解析 JavaScript 的解析器 Acorn 还尚未实现这些功能。</li>
</ul>
<p>如果您想使用这些功能中的一种，您需要设置一个 <code>script</code> 预处理器。</p>
<h2 id="预处理器设置">预处理器设置</h2>
<p>要在 Svelte 组件中使用非<em>仅使用类型</em>的 TypeScript 功能，您需要添加一个预处理器，将 TypeScript 转换为 JavaScript。</p>
<pre><code class="language-ts">/// file: svelte.config.js
// @noErrors
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

const config = {
	// 注意额外的 `{ script: true }`
	preprocess: vitePreprocess({ script: true })
};

export default config;
</code></pre>
<h3 id="使用-sveltekit-或-vite">使用 SvelteKit 或 Vite</h3>
<p>最简单的开始方式是输入 <code>npx sv create</code> 搭建一个新的 SvelteKit 项目，然后按照提示选择 TypeScript 选项。</p>
<pre><code class="language-ts">/// file: svelte.config.js
// @noErrors
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

const config = {
	preprocess: vitePreprocess()
};

export default config;
</code></pre>
<p>如果您不需要或不想要 SvelteKit 提供的所有功能，您可以通过输入 <code>npm create vite@latest</code> 并选择 <code>svelte-ts</code> 选项来搭建一个 Svelte 风格的 Vite 项目。</p>
<p>在这两种情况下，将添加一个带有 <code>vitePreprocess</code> 的 <code>svelte.config.js</code>。Vite/SvelteKit 将从此配置文件中读取。</p>
<h3 id="其他构建工具">其他构建工具</h3>
<p>如果您使用的是 Rollup 或 Webpack 等工具，请安装各自的 Svelte 插件。对于 Rollup，使用 <a href="https://github.com/sveltejs/rollup-plugin-svelte" target="_blank" rel="noopener nofollow">rollup-plugin-svelte</a>，对于 Webpack，使用 <a href="https://github.com/sveltejs/svelte-loader" target="_blank" rel="noopener nofollow">svelte-loader</a>。</p>
<p>对于这两者，您需要安装 <code>typescript</code> 和 <code>svelte-preprocess</code> 并将预处理器添加到插件配置中（请参阅各自的 README 了解更多信息）。如果您正在启动一个新项目，您还可以使用 <a href="https://github.com/sveltejs/template" target="_blank" rel="noopener nofollow">rollup</a> 或 <a href="https://github.com/sveltejs/template-webpack" target="_blank" rel="noopener nofollow">webpack</a> 模板搭建设置环境。</p>
<blockquote>
<p>[!NOTE] 如果您要开启一个新项目，建议使用 SvelteKit 或 Vite</p>
</blockquote>
<h2 id="tsconfigjson-设置">tsconfig.json 设置</h2>
<p>当使用 TypeScript 时，请确保您的 <code>tsconfig.json</code> 设置正确。</p>
<ul>
<li>使用至少为 <code>ES2022</code> 的 <a href="https://www.typescriptlang.org/tsconfig/#target" target="_blank" rel="noopener nofollow"><code>target</code></a>，或至少为 <code>ES2015</code> 的 <code>target</code> 以及 <a href="https://www.typescriptlang.org/tsconfig/#useDefineForClassFields" target="_blank" rel="noopener nofollow"><code>useDefineForClassFields</code></a>。这样可以确保类字段上的符文声明不会被干扰，否则会破坏 Svelte 编译器。</li>
<li>将 <a href="https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax" target="_blank" rel="noopener nofollow"><code>verbatimModuleSyntax</code></a> 设置为 <code>true</code>，以便导入保持不变。</li>
<li>将 <a href="https://www.typescriptlang.org/tsconfig/#isolatedModules" target="_blank" rel="noopener nofollow"><code>isolatedModules</code></a> 设置为 <code>true</code>，以便单独查看每个文件。TypeScript 有一些需要跨文件分析和编译的特性，而 Svelte 编译器和 Vite 等工具并不执行这些操作。</li>
</ul>
<h2 id="props-类型定义"><code>$props</code> 类型定义</h2>
<p>将 <code>$props</code> 当成包含一些属性的普通对象一样使用：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  import type { Snippet } from 'svelte';

  interface Props {
    requiredProperty: number;
    optionalProperty?: boolean;
    snippetWithStringArgument: Snippet&lt;[string]&gt;;
    eventHandler: (arg: string) =&gt; void;
    [key: string]: unknown;
  }

  let {
    requiredProperty,
    optionalProperty,
    snippetWithStringArgument,
    eventHandler,
    ...everythingElse
  }: Props = $props();
&lt;/script&gt;

&lt;button onclick={() =&gt; eventHandler('点击按钮')}&gt;
  {@render snippetWithStringArgument('你好')}
&lt;/button&gt;
</code></pre>
<h2 id="泛型-props">泛型 <code>$props</code></h2>
<p>组件可以声明其属性之间的泛型关系。下面的示例是一个通用列表组件，接收一个条目列表和一个回调属性，该回调接收列表中的一个条目。为了声明 <code>items</code> 属性和 <code>select</code> 回调对同一类型进行操作，请在 <code>script</code> 标记中添加 <code>generics</code> 属性:</p>
<pre><code class="language-svelte">&lt;script lang="ts" generics="Item extends { text: string }"&gt;
  interface Props {
    items: Item[];
    select(item: Item): void;
  }

  let { items, select }: Props = $props();
&lt;/script&gt;

{#each items as item}
  &lt;button onclick={() =&gt; select(item)}&gt;
    {item.text}
  &lt;/button&gt;
{/each}
</code></pre>
<p><code>generics</code> 的内容是您放置在泛型函数 <code>&lt;...&gt;</code> 标签之间的内容。换句话说，您可以使用多个泛型、<code>extends</code> 和后备类型。</p>
<h2 id="包裹组件的类型定义">包裹组件的类型定义</h2>
<p>如果您编写的组件是一个包裹原生元素的组件，您可能想要将底层元素的所有属性暴露给用户。在这种情况下，请使用（或 extend）<code>svelte/elements</code> 提供的接口。以下是一个 <code>Button</code> 组件的示例：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  import type { HTMLButtonAttributes } from 'svelte/elements';

  let { children, ...rest }: HTMLButtonAttributes = $props();
&lt;/script&gt;

&lt;button {...rest}&gt;
  {@render children?.()}
&lt;/button&gt;
</code></pre>
<p>并非所有元素都有专门的类型定义。对于那些没有的元素，可以使用 <code>SvelteHTMLElements</code>：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  import type { SvelteHTMLElements } from 'svelte/elements';

  let { children, ...rest }: SvelteHTMLElements['div'] = $props();
&lt;/script&gt;

&lt;div {...rest}&gt;
  {@render children?.()}
&lt;/div&gt;
</code></pre>
<h2 id="state-类型定义"><code>$state</code> 类型定义</h2>
<p>您可以像其他变量一样对 <code>$state</code> 进行类型定义。</p>
<pre><code class="language-ts">let count: number = $state(0);
</code></pre>
<p>如果您没有给 <code>$state</code> 提供初始值，它的部分类型将是 <code>undefined</code>。</p>
<pre><code class="language-ts">// @noErrors
// 错误：类型 'number | undefined' 不可分配给类型 'number'
let count: number = $state();
</code></pre>
<p>如果您知道这个变量 <em>将在</em> 第一次使用之前被定义，请使用 <code>as</code> 强制类型转换。这在类的上下文中特别有用：</p>
<pre><code class="language-ts">class Counter {
	count = $state() as number;
	constructor(initial: number) {
		this.count = initial;
	}
}
</code></pre>
<h2 id="component-类型"><code>Component</code> 类型</h2>
<p>Svelte 组件的类型为 <code>Component</code>。您可以使用它及其相关类型来表达各种约束。</p>
<p>将它与动态组件一起使用，以限制可以传递给它的组件类型：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  import type { Component } from 'svelte';

  interface Props {
    // 仅允许传递至多需要 "prop"
    // 属性的组件
    DynamicComponent: Component&lt;{ prop: string }&gt;;
  }

  let { DynamicComponent }: Props = $props();
&lt;/script&gt;

&lt;DynamicComponent prop="foo" /&gt;
</code></pre>
<blockquote>
<p>[!遗留模式] 在 Svelte 4 中，组件的类型是 <code>SvelteComponent</code></p>
</blockquote>
<p>要从组件中提取属性，请使用 <code>ComponentProps</code>。</p>
<pre><code class="language-ts">import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&lt;TComponent extends Component&lt;any&gt;&gt;(
	component: TComponent,
	props: ComponentProps&lt;TComponent&gt;
) {}

// 如果第二个参数不是第一个参数的组件所期望的正确属性，则会产生错误。
withProps(MyComponent, { foo: 'bar' });
</code></pre>
<p>要声明一个变量是组件的构造函数或实例类型：</p>
<pre><code class="language-svelte">&lt;script lang="ts"&gt;
  import MyComponent from './MyComponent.svelte';

  let componentConstructor: typeof MyComponent = MyComponent;
  let componentInstance: MyComponent;
&lt;/script&gt;

&lt;MyComponent bind:this={componentInstance} /&gt;
</code></pre>
<h2 id="增强内置-dom-类型">增强内置 DOM 类型</h2>
<p>Svelte 尝试尽可能支持所有存在的 HTML DOM 类型。但有时，您可能希望使用实验性属性或来自 action 的自定义事件。在这些情况下，TypeScript 会抛出类型错误，表示它不知道这些类型。如果是非实验性标准属性/事件，很可能是我们 <a href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/elements.d.ts" target="_blank" rel="noopener nofollow">HTML 类型定义</a> 中缺少了一些类型。在这种情况下，欢迎您提起一个 issue 和（或）提交一个修复的 PR。</p>
<p>如果这是一个自定义或实验性属性/事件，您可以像这样增强类型定义：</p>
<pre><code class="language-ts">/// file: additional-svelte-typings.d.ts
declare namespace svelteHTML {
	// 增强元素
	interface IntrinsicElements {
		'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent&lt;any&gt;) =&gt; void };
	}
	// 增强属性
	interface HTMLAttributes&lt;T&gt; {
		// 如果您想使用 beforeinstallprompt 事件
		onbeforeinstallprompt?: (event: any) =&gt; any;
		// 如果您想使用 myCustomAttribute={..} （NOTE: 全小写）
		mycustomattribute?: any; // 如果需要，您可以将 any 替换为更具体的类型
	}
}
</code></pre>
<p>然后确保在您的 <code>tsconfig.json</code> 中引用了 <code>d.ts</code> 文件。如果它的内容类似于 <code>"include": ["src/**/*"]</code> 并且您的 <code>d.ts</code> 文件位于 <code>src</code> 目录中，它应该可以正常工作。您可能需要重新加载以使更改生效。</p>
<p>您还可以通过增强 <code>svelte/elements</code> 模块来声明类型，如下所示：</p>
<pre><code class="language-ts">/// file: additional-svelte-typings.d.ts
import { HTMLButtonAttributes } from 'svelte/elements';

declare module 'svelte/elements' {
	export interface SvelteHTMLElements {
		'custom-button': HTMLButtonAttributes;
	}

	// 允许对要添加类型定义的元素进行更细粒度的控制
	export interface HTMLButtonAttributes {
		veryexperimentalattribute?: string;
	}
}

export {}; // 确保这不是一个环境模块，否则类型会被覆盖而不是增强
</code></pre>
<h2 id="svelte-中文文档">Svelte 中文文档</h2>
<p>系统学习 Svelte，欢迎入手小册<a href="https://s.juejin.cn/ds/iycmvygA/" target="_blank" rel="noopener nofollow">《Svelte 开发指南》</a>。语法篇、实战篇、原理篇三大篇章带你系统掌握 Svelte！</p>
<p>此外我还写过 <a href="https://juejin.cn/column/7035531575974592520" target="_blank" rel="noopener nofollow">JavaScript 系列</a>、<a href="https://juejin.cn/column/7029490086710345742" target="_blank" rel="noopener nofollow">TypeScript 系列</a>、<a href="https://juejin.cn/column/7142674773930147853" target="_blank" rel="noopener nofollow">React 系列</a>、<a href="https://juejin.cn/column/7343569488744611849" target="_blank" rel="noopener nofollow">Next.js 系列</a>、<a href="https://juejin.cn/column/7039526067891077151" target="_blank" rel="noopener nofollow">冴羽答读者问</a>等 14 个系列文章， 全系列文章目录：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener nofollow">https://github.com/mqyqingfeng/Blog</a></p>
<p>欢迎围观我的<a href="https://yayujs.com" target="_blank" rel="noopener nofollow">“网页版朋友圈”</a>、加入<a href="https://www.yuque.com/yayu/nice-people/xou8qr" target="_blank" rel="noopener nofollow">“冴羽·成长陪伴社群”</a>，踏上<a href="https://t.zsxq.com/DfGhx" target="_blank" rel="noopener nofollow">“前端大佬成长之路”</a>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.477753650686343" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 10:49">2025-02-26 10:49</span>&nbsp;
<a href="https://www.cnblogs.com/yayujs">冴羽</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737984" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737984);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737984', targetLink: 'https://www.cnblogs.com/yayujs/p/18737984', title: 'Svelte 最新中文文档教程（20）—— TypeScript' })">举报</a>
</div>
        