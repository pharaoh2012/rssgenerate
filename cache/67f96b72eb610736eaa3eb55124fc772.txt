
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18836050" title="发布于 2025-04-24 08:15">
    <span role="heading" aria-level="2">如何统计不同电话号码的个数？—位图法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>已知某个文件内包含100亿个电话号码，每个号码为8位数字，如何统计不同号码的个数？内存限制100M</strong></p>
<p>有人说遍历，使用HashSet或者int数组来存储，这里先不谈算法效率的问题，这100亿数据如何在能否在内存中放下也是一个问题。</p>
<p>如果用int类型来存储这100亿个电话号码，那么就需要 100亿 * 4字节 = 37GB ≈ 40GB。所以这些方法行不通的根本原因实际上是内存不够。</p>
<h2 id="思路分析">思路分析</h2>
<p>这类题目其实是求解数据重复的问题。对于这类问题，可以使用位图法处理</p>
<p>实际上只需要判断数据是否存在，可以使用0表示存在，1表示不存在。那么在程序中，就可以使用最小的单位bit来进行表示，1个bit就有两种取值：0和1。所以位图其实就是一种直接定址法的哈希，只不过位图只能表示这个值在或者不在。</p>
<p>8位电话号码可以表示的范围为00000000～99999999。如果用1 bit表示一个号码，那么总共需要1亿个bit，总共需要大约<strong>10MB</strong>的内存。</p>
<p>申请一个位图并初始化为0，然后遍历所有电话号码，<strong>把遍历到的电话号码对应的位图中的bit设置为1</strong>。当遍历完成后，如果bit值为1，则表示这个电话号码在文件中存在，否则这个bit对应的电话号码在文件中不存在。</p>
<p>最后这个<strong>位图中bit值为1的数量</strong>就是不同电话号码的个数了。</p>
<p>那么如何确定电话号码对应的是位图中的哪一位呢？</p>
<p>可以使用下面的方法来做<strong>电话号码和位图的映射</strong>。</p>
<pre><code class="language-java">00000000 对应位图最后一位：0×0000…000001。
00000001 对应位图倒数第二位：0×0000…0000010（1 向左移 1 位）。
00000002 对应位图倒数第三位：0×0000…0000100（1 向左移 2 位）。
……
00000012 对应位图的倒数第十三位：0×0000…0001 0000 0000 0000（1 向左移 12 位）。
</code></pre>
<p>也就是说，电话号码就是1这个数字左移的次数。</p>
<h2 id="具体实现">具体实现</h2>
<p>首先位图可以使用一个<strong>int数组</strong>来实现（在Java中int占用<strong>4byte</strong>）。</p>
<p>假设电话号码为 P，而通过电话号码获取位图中对应位置的方法为：</p>
<p><strong>第一步</strong>，因为int整数占用4*8=32bit，通过 <strong>P/32</strong> 就可以计算出该电话号码在 bitmap 数组中的下标，从而可以确定它对应的 bit 在数组中的位置。</p>
<p><strong>第二步</strong>，通过 <strong>P%32</strong> 就可以计算出这个电话号码在这个int数字中具体的bit的位置。只要把1向左移 <strong>P%32</strong> 位，然后把得到的值与这个数组中的值做或运算，就可以把这个电话号码在位图中对应的位设置为1。</p>
<p>以00000100号码为例。</p>
<ol>
<li>首先计算数组下标，100 / 32 = 3，得到数组下标位3。</li>
<li>然后计算电话号码在这个int数字中具体的bit的位置，100 % 32 = 4。取余为0左移1位，故取余为4左移5位，得到000...000010000</li>
<li>将位图中对应的位设置为 1，即arr[2] = arr[2] <strong>|</strong> 000..00010000。</li>
<li>这就将电话号码映射到了位图的某一位了。</li>
</ol>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202411210013338.png" alt="" loading="lazy"></p>
<p>最后，统计位图中bit值为1的数量，便能得到不同电话号码的个数了。</p>
<h2 id="位图的缺点">位图的缺点</h2>
<ul>
<li>位图存储的元素大小受限于存储空间的大小。比如，1K 字节内存，能存储 8K 个值 且大小上限为 8K 的元素
<ul>
<li>比如，要存储 值为 65535 的数，就需要8Kb的内存。这就有可能导致大量的内存浪费。也就是说，在数据比较稠密的情况下，位图算法能够节约存储空间，但是如果数据稀疏且值较大，存储空间同样会存在一定程度的浪费。基于此，就提出了位图的改进版 - 稀疏位图</li>
</ul>
</li>
<li>不能存储真实数据值，即只能判断数据存在不存在，且只适用于整数型数据。如果判断字符串以及其他类型数据存在与否，此时就可以使用布隆过滤器</li>
</ul>
<h2 id="稀疏位图">稀疏位图</h2>
<p>较为经典的位图压缩算法RoaringBitmap</p>
<p>RoaringBitmap的核心思想就是，将32位无符号整数按照高16位分桶，即最多可能有 2^16=65536 个桶，高16位的值作为其桶的索引，每个桶对应一个容器container。存储数据时，按照数据的高16位找到container（找不到就会新建一个），再将低16位放入container中。也就是说，Roaring将Bitmap从一层的连续存储，转换为一个二级的存储结构</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404270852502.png" alt="" loading="lazy"><br>
图中示例(这只是例子)：</p>
<ul>
<li>高16位为0000H的container，存储有前1000个62的倍数。</li>
<li>高16位为0001H的container，存储有[2^16, 2^16+100)区间内的100个数。</li>
<li>高16位为0002H的container，存储有[2×2^16, 3×2^16)区间内的所有偶数，共215个。</li>
</ul>
<p>实际上，container容器的结构有三种类型：有序数组、未压缩位图、和行程长度编码。</p>
<ul>
<li>区间内数据较多，且分布零散，则选择（未压缩）位图。当低16位中，元素个数大于4096时，则使用（未压缩）位图</li>
<li>区间内数据较少，且分布零散，则选择使用有序数组。当低16位中，元素个数小于4096时，采用有序数组的结构进行存储。在查找元素时，使用二分查找方法。</li>
<li>区间内数据连续分布，则选择用Run Length Encoding编码。行程长度编码是一种无损数据压缩技术，其原理是，将连续出现的数据存储为起始值和计算两部分。比如，数据列表[1,2,3,4,5,6]存储为[1,5]，表示以1开始，后面连续递增5个数值。</li>
</ul>
<p>在进行插入和删除操作之后，需要根据元素个数进行容器转换。插入元素时，若元素个数达到4096，则需要转换为未压缩位图进行存储。删除元素时，若元素个数小于4096时，则需要转换为有序数组存储。</p>
<blockquote>
<p>那么这里为什么阈值选择的是4096呢？<br>
论文中提到，由于container中只需要存储低16位的数，那么数组存储的时候是使用2字节即16 bit的short类型存储的，那么数组中存一个数字就是2字节，存4096个数字就是 8KB<br>
而当需要存储的数字大于4096个数后，可以使用2^16 bit 的位图来存储，2^16 bit 的位图的存储空间恒等于8KB，有某一个数字，就把那个位置为1，没有就置为0<br>
如下图所示，显然当元素个数小于4096时，占用空间就是 元素个数 * 2B &lt; 8KB;当元素个数大于4096时，占用空间就是8KB</p>
</blockquote>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404270852295.jpeg" alt="" loading="lazy"></p>
<p>Roaring 提供O(logn)的查找性能：</p>
<ol>
<li>首先二分查找key值的高16位是否在分片（chunk）中</li>
<li>如果分片存在，则查找分片对应的Container是否存在
<ul>
<li>如果Bitmap Container，查找性能是O(1)</li>
<li>其它两种Container，需要进行二分查找</li>
</ul>
</li>
</ol>
<p>因此RoaringBitMap尽量节省空间，但也同时影响了效率，相当于时间换空间。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3386489954699074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-24 08:15">2025-04-24 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">278</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18836050);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18836050', targetLink: 'https://www.cnblogs.com/seven97-top/p/18836050', title: '如何统计不同电话号码的个数？—位图法' })">举报</a>
</div>
        