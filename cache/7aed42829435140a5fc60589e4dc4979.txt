
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Rong-/p/18682641" title="发布于 2025-01-20 22:55">
    <span role="heading" aria-level="2">回顾我的软件开发经历：我与代码生成器的涅槃之路</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h4><strong>前言</strong></h4>
<p>这是我《回顾我的开发经历》系列的第二篇，聚焦于我与代码生成器的故事。从最初的简单工具到最终演变成一个功能强大的ORM框架，这段经历不仅让我在技术上得到了极大的提升，也让我深刻理解了重构、设计模式和系统架构的重要性。希望通过这篇文章，能为大家提供一些启发和思考。</p>
<hr>
<h4><strong>初识代码生成器</strong></h4>
<p>工作几年后，我第一次接触到了代码生成器。虽然最初的版本非常简单，但这个思路让我眼前一亮。在接下来的十几年里，我不断扩展和完善这个代码生成器，最终实现了通过数据库自动生成具备完整增删改查功能的网站。这段经历让我受益匪浅，我将其中一些关键点总结在这篇博客中：<a href="https://www.cnblogs.com/Rong-/p/18677552" rel="noreferrer" target="_blank">代码生成器的成长历程</a>。</p>
<hr>
<h4><strong>代码生成器与阅读</strong></h4>
<p>刚开始编写代码生成器时，我对面向对象开发的理解还很模糊。当时，我正在阅读《C# Primer Plus》，一边学习，一边将书中的知识应用到代码生成器中。有时遇到问题不知道如何解决，有时学到新的知识点，立刻就能在代码生成器中实践。这段经历非常奇妙，我甚至常常在走路时思考书中的内容，以至于多次错过路口。我在《<a title="我的读书生涯" href="https://mp.csdn.net/mp_blog/creation/editor/2184960" target="_blank" rel="noopener nofollow">我的读书生涯</a>》中回顾了这段经历。</p>
<p>在这种边学习边实践的过程中，代码生成器逐渐发生了变化：功能不断扩展，代码量减少，但继承关系变得复杂。我甚至为业务对象设计了一个基类，后来发现这是一个误区。尽管如此，代码生成器逐渐演变成了一个框架——一个属于我自己的框架。代码生成器本身的代码量和生成的代码都显著减少，功能却更强大，可维护性也更强。</p>
<hr>
<h4><strong>ORM框架的诞生</strong></h4>
<p>有时候，改变源于一句不经意的话。在与同事讨论时，有人提到“不应该将SQL语句放在逻辑代码中”。这句话触动了我，我开始在代码生成器中将SQL语句从代码中移除，这为后来形成ORM框架奠定了基础。</p>
<p>ORM框架的另一个技术来源是C#的开源项目DNN（Dot Net Nuke）。我从中学到了<a title="CBO" href="https://www.cnblogs.com/admin11/archive/2005/07/15/193298.html" target="_blank">CBO</a>（基于元数据的对象创建与赋值），这成为ORM框架的核心技术之一。例如，将一个DataTable中的Row转换为对象，或将对象转换为DataRow；<a href="https://www.cnblogs.com/admin11/archive/2005/07/26/200313.html" target="_blank">还有Null类</a>。此外，<a href="https://www.cnblogs.com/admin11/archive/2005/09/09/232929.html" target="_blank">DNN中的策略模式</a>也为我提供了灵感，使ORM框架能够支持多种数据库。</p>
<p>在2006年到2007年间，我实现了一个类似MyBatis的ORM框架，甚至一度觉得它比MyBatis更好用（惭愧中）。</p>
<hr>
<h4><strong>XML读取与数据库访问</strong></h4>
<p>在ORM框架中，我将SQL语句和参数放到XML中，并设计了一个访问框架，实现了缓存和更新功能。为了支持<a href="https://www.cnblogs.com/admin11/archive/2009/10/23/1588487.html" target="_blank">多种数据库</a>，我应用了设计模式，尽管当时对设计模式的理解还不够深入。后来我意识到，设计模式并不是刻意学习的，而是在实践中自然“长”出来的。我多次重构数据库访问程序，最终形成了一个稳定且高效的库。</p>
<hr>
<h4><strong>技术追求的弯路：Attributes</strong></h4>
<p>在这段经历中，我也曾走过弯路。例如，我曾过度使用<a href="https://www.cnblogs.com/admin11?page=11" target="_blank">C#的Attributes</a>，甚至将其放到业务对象类中。后来意识到这是错误的，便将其移除。这段经历让我明白，技术工具的使用需要适度，不能为了炫技而牺牲代码的可维护性。</p>
<hr>
<h4><strong>前端控件的发展</strong></h4>
<p>在代码生成器的早期，我主要做Web开发，前端使用ASP.NET，后来转向Castle Monorail。为了减少Web页面和后台的代码生成量，我不断扩展Web控件，将能前端处理的功能尽量放到前端，并抽象出通用功能。前端控件的抽象经历了两个阶段：</p>
<ol start="1">
<li>
<p><strong>第一阶段</strong>：抽象出包含后台代码的Web控件，例如<a href="https://www.cnblogs.com/admin11/archive/2007/11/27/974000.html" target="_blank">扩展DataGrid和</a><a href="https://www.cnblogs.com/admin11/archive/2008/08/04/1259577.html" target="_blank">TextBox控件</a>。</p>
</li>
<li>
<p><strong>第二阶段</strong>：使用纯前端控件，进一步提升灵活性和可维护性。</p>
</li>
</ol><hr>
<h4><strong>前端自动输入合法性验证框架</strong></h4>
<p>除了扩展控件，我还为前端输入合法性验证设计了一个<a href="https://www.cnblogs.com/admin11/archive/2008/01/14/1037675.html" target="_blank">框架</a>。通过JavaScript遍历所有DOM控件，根据扩展属性（如是否为空、最大最小长度、是否整数等）进行合法性验证，并在控件下方弹出提示信息。这一设计大大减少了后端验证的负担。</p>
<hr>
<h4><strong>使用模板技术</strong></h4>
<p>最初，代码生成器的所有代码都是通过字符串拼接生成的。随着框架的升级，生成的代码量减少，字符串拼接的工作量也大幅下降。后来，我意识到可以使用模板生成代码，于是设计了一个简单的模板引擎，用“#***#”格式替换变量。再后来，我引入了VTL等模板技术，进一步减少了代码生成器的代码量。</p>
<hr>
<h4><strong>Excel操作</strong></h4>
<p>我为框架添加了Excel导入导出功能，根据数据库结构生成Excel文件，并支持数据合法性验证和格式设置。用户可以在Excel中编辑数据后，再导入系统，实现批量添加数据，同时严格遵循主外键关系，避免脏数据。这一功能在后来的视频监控配置中发挥了巨大作用，将原本需要数天的配置工作缩短到十几分钟。</p>
<hr>
<h4><strong>框架与库</strong></h4>
<p>经过几年的开发，我发现框架不一定要以单一的形式存在，而是可以拆分为多个独立的库。每个库可以单独使用，组合起来又能形成一个完整的框架。基于这一思路，我将框架拆分为数据访问库、元数据映射库（CBO）、SQL缓存库、前端合法性检查库、前端控件库、Excel导入导出库和通用库等。</p>
<hr>
<h4><strong>代码生成器的扩展</strong></h4>
<p>代码生成器最初是一个简单的Form页面，后来逐渐扩展为包含多个Panel的界面，支持数据库表树、代码生成区域、数据库表结构选择以及代码类型选项。生成的代码不仅支持ASP.NET，还支持Java、C++、Castle Monorail的页面代码以及多语言配置。</p>
<hr>
<h4><strong>代码生成器与重构</strong></h4>
<p>重构的习惯是在编写代码生成器的过程中逐渐养成的。从最初的混乱代码到一个完整的框架，再到拆分为多个库，重构起到了关键作用。这段经历让我形成了几个重要的认知：</p>
<ol start="1">
<li>
<p>重构要小步快跑，步子太大会迷失方向。</p>
</li>
<li>
<p>代码越重构，越敢动它；否则，代码会逐渐僵化。</p>
</li>
<li>
<p>几次小的重构后，需要进行一次相对完整的验证，避免浪费时间。</p>
</li>
<li>
<p>重构的目标可以大一些，但要从小步开始，逐步实现。</p>
</li>
<li>
<p>重构的最终目标是让代码更清晰、更灵活。</p>
</li>
</ol><hr>
<h4><strong>后续</strong></h4>
<p>这个代码生成器我写了十几年，乐在其中，也学到了很多。我还用Python和Java实现了类似的工具，例如Python版的代码生成器（<a href="https://gitee.com/hi_py/Mysql_CodeGen" rel="noopener nofollow" target="_blank">Mysql_CodeGen</a>）和Java版的框架（<a href="https://gitee.com/xumingxsh/hijdb" rel="noopener nofollow" target="_blank">HiJDB</a>）。此外，我还开发了一个C#版的DataGridView辅助类（<a href="https://www.cnblogs.com/Rong-/p/5412606.html" rel="noreferrer" target="_blank">DataGridView辅助类</a>）。</p>
<hr>
<h4><strong>总结</strong></h4>
<p>通过编写代码生成器，我的技术能力得到了极大的提升，对重构、面向对象、设计模式、前端技术和后端技术都有了深入的理解。唯一的遗憾是，这段经历主要是单打独斗，如果能与更多人合作，可能会成长得更快，收获更多。在未来的工作中，我希望能再次找到类似的机会。就像我的代码生成器一样，从无到有，从框架到库，不断重构和突破，逐步完善自己。</p>
<p>其实，在开发方面，我也的确又遇到了类似的工作，例如：ACE，例如后来做的智慧校园平台。<br>就像我的代码生成器，从无框架到有框架到打破框架形成多个库，不破不立，期望在任何好的或坏的情形下，都有重构自己的勇气，正反正的螺旋上升，逐步完善。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.727972787037037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 22:56">2025-01-20 22:55</span>&nbsp;
<a href="https://www.cnblogs.com/Rong-">荣--</a>&nbsp;
阅读(<span id="post_view_count">406</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18682641" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18682641);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18682641', targetLink: 'https://www.cnblogs.com/Rong-/p/18682641', title: '回顾我的软件开发经历：我与代码生成器的涅槃之路' })">举报</a>
</div>
        