
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/madtom/p/18664378" title="发布于 2025-01-10 17:36">
    <span role="heading" aria-level="2">[.NET] 使用客户端缓存提高API性能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        在现代应用程序中，性能始终是一个关键的考虑因素。无论是提高响应速度，降低延迟，还是减轻服务器负载，开发者都在寻找各种方法来优化他们的API。在Web开发中，利用客户端缓存是一种有效的方法，可以显著提高API的性能。本文将结合Replicant与Delta库，深入探讨如何在.NET中使用客户端缓存，巧妙地提升API的响应速度。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="使用客户端缓存提高api性能">使用客户端缓存提高API性能</h1>
<h2 id="摘要">摘要</h2>
<p>在现代应用程序中，性能始终是一个关键的考虑因素。无论是提高响应速度，降低延迟，还是减轻服务器负载，开发者都在寻找各种方法来优化他们的API。在Web开发中，利用客户端缓存是一种有效的方法，可以显著提高API的性能。本文将结合<a href="https://github.com/SimonCropp/Replicant" target="_blank" rel="noopener nofollow">Replicant</a>和<a href="https://github.com/SimonCropp/Delta" target="_blank" rel="noopener nofollow">Delta</a>，深入探讨如何在.NET中使用客户端缓存，巧妙地提升API的响应速度。</p>
<h2 id="问题概述">问题概述</h2>
<p>尽管数据库已经过优化，但在实际应用中，我们仍然会遇到一些性能瓶颈。例如，当数据库中有数百万条记录时，即使添加了索引，某些查询（如对用户名的部分匹配搜索）仍可能导致响应延迟。在API集成中，每次请求都需要花费较长的时间，这不仅影响用户体验，还会增加服务器的负载。</p>
<h2 id="解决方案概述">解决方案概述</h2>
<p>为了应对这些性能挑战，我们可以采用以下策略：</p>
<ol>
<li><strong>利用客户端缓存</strong>：通过在客户端缓存API响应，减少重复请求，提高响应速度。</li>
<li><strong>使用HTTP缓存头</strong>：利用HTTP的缓存控制头信息（如<code>ETag</code>、<code>Cache-Control</code>）来管理缓存，实现高效的数据更新检测。</li>
<li><strong>引入辅助库</strong>：使用诸如<a href="https://github.com/SimonCropp/Replicant" target="_blank" rel="noopener nofollow">Replicant</a>和<a href="https://github.com/username/Delta" target="_blank" rel="noopener nofollow">Delta</a>这样的库，简化缓存的实现方式，降低开发成本。</li>
</ol>
<p>接下来，我们将详细探讨如何在.NET中实现上述策略，并提供具体的代码示例。</p>
<h2 id="客户端缓存概述">客户端缓存概述</h2>
<h3 id="什么是http缓存头">什么是HTTP缓存头？</h3>
<p>HTTP提供了一系列头信息，用于管理缓存行为。这些头信息包括：</p>
<ul>
<li><strong>ETag</strong>：实体标签，用于标识资源的版本。当资源发生变化时，<code>ETag</code>也会随之更新。</li>
<li><strong>Cache-Control</strong>：指定缓存策略，如<code>no-cache</code>、<code>max-age</code>等。</li>
<li><strong>Last-Modified</strong>：指示资源的最后修改时间。</li>
</ul>
<p>通过合理地设置这些头信息，客户端和服务器可以协同工作，实现高效的缓存机制。</p>
<h3 id="浏览器中的缓存机制">浏览器中的缓存机制</h3>
<p>当浏览器发送请求时，如果服务器返回了<code>ETag</code>或<code>Last-Modified</code>等头信息，浏览器会缓存响应。当再次请求相同资源时，浏览器会携带<code>If-None-Match</code>或<code>If-Modified-Since</code>等条件请求头，询问服务器资源是否更新。如果资源未更新，服务器返回<code>304 Not Modified</code>，浏览器直接使用本地缓存的数据。</p>
<h3 id="在http客户端中实现缓存">在HTTP客户端中实现缓存</h3>
<p>在非浏览器环境（如使用<code>HttpClient</code>进行API调用）中，实现类似的缓存机制需要额外的工作。幸运的是，<a href="https://github.com/SimonCropp/Replicant" target="_blank" rel="noopener nofollow">Replicant</a>库提供了便利的解决方案。</p>
<h2 id="使用delta优化服务器端缓存">使用Delta优化服务器端缓存</h2>
<h3 id="什么是delta">什么是Delta？</h3>
<p>Delta是一个开源的.NET库，通过在数据库中添加一个版本列（如<code>RowVersion</code>）或数据库自带的追踪数据，结合浏览器或客户端的缓存机制，实现高效的数据更新检测。它可以自动处理<code>ETag</code>的生成和验证，简化服务器端的开发工作。</p>
<h3 id="如何使用delta">如何使用Delta？</h3>
<ol>
<li>
<p><strong>安装NuGet包</strong></p>
<pre><code class="language-bash">Install-Package Delta
</code></pre>
</li>
<li>
<p><strong>配置中间件</strong></p>
<p>在<code>Startup.cs</code>或<code>Program.cs</code>中，添加Delta的中间件：</p>
<pre><code class="language-csharp"> app.UseDelta&lt;BloggingContext&gt;(); //Delta内置了对EFCore的支持，只要是基于ADO.NET的ORM都可以使用Delta
</code></pre>
</li>
<li>
<p><strong>修改数据库</strong></p>
</li>
</ol>
<ul>
<li>
<p><strong>SQL Server</strong></p>
<p>在相关的数据库表中，添加一个时间戳或版本列，用于跟踪数据的变化。例如，使用<code>RowVersion</code>列：</p>
<pre><code class="language-csharp">[Timestamp]
public byte[] RowVersion { get; set; }
</code></pre>
</li>
<li>
<p><strong>PostgreSQL</strong><br>
启用<code>track_commit_timestamp</code>功能</p>
</li>
</ul>
<h3 id="delta的工作原理">Delta的工作原理</h3>
<div class="mermaid">graph LR
    请求
    计算ETag[根据时间戳&lt;br/&gt;从 WebAssembly 和 SQL&lt;br/&gt;计算当前 ETag]
    是否有IfNoneMatch{是否有&lt;br/&gt;If-None-Match&lt;br/&gt;Header?}
    Etag匹配{当前&lt;br/&gt;ETag与&lt;br/&gt;If-None-Match匹配?}
    添加ETag[将当前 ETag&lt;br/&gt;添加到响应头]
    304[响应&lt;br/&gt;304 未修改]
    请求 --&gt; 计算ETag
    计算ETag --&gt; 是否有IfNoneMatch
    是否有IfNoneMatch --&gt;|是| Etag匹配
    是否有IfNoneMatch --&gt;|否| 添加ETag
    Etag匹配 --&gt;|否| 添加ETag
    Etag匹配 --&gt;|是| 304

</div><ul>
<li><strong>ETag生成</strong>：Delta会根据数据库中的<code>RowVersion</code>或时间戳列，自动生成<code>ETag</code>。</li>
<li><strong>条件请求</strong>：当客户端发送请求时，携带<code>If-None-Match</code>头信息，Delta会根据<code>ETag</code>判断数据是否发生变化。</li>
<li><strong>响应优化</strong>：如果数据未变化，服务器直接返回<code>304 Not Modified</code>，客户端可以使用缓存的数据。</li>
</ul>
<h3 id="使用delta的优势">使用Delta的优势</h3>
<ul>
<li><strong>非侵入式</strong>：无需对现有的API进行大量修改，只需简单配置即可。</li>
<li><strong>性能提升</strong>：在数据未变化的情况下，避免了不必要的数据库查询和数据传输。</li>
<li><strong>适用性强</strong>：适用于各种类型的API，包括RESTful API、GraphQL等。</li>
</ul>
<h2 id="使用replicant实现http客户端缓存">使用Replicant实现HTTP客户端缓存</h2>
<h3 id="什么是replicant">什么是Replicant？</h3>
<p>Replicant是由Simon Cropp开发的一个开源.NET库，用于实现HTTP客户端的缓存机制。它利用了与浏览器相同的HTTP缓存头（如<code>ETag</code>、<code>Cache-Control</code>），可以缓存HTTP响应，避免重复请求。</p>
<h3 id="使用replicant的步骤">使用Replicant的步骤</h3>
<ol>
<li>
<p><strong>安装NuGet包</strong></p>
<p>在项目中安装Replicant包：</p>
<pre><code class="language-bash">Install-Package Replicant
</code></pre>
</li>
<li>
<p><strong>替换HttpClient</strong></p>
<p>Replicant提供了一个包装的<code>HttpClient</code>，在创建客户端时使用<code>HttpCache</code>：</p>
<pre><code class="language-csharp">HttpCache cachedClient = HttpCache.Default;
</code></pre>
</li>
<li>
<p><strong>发送请求</strong></p>
<p>使用<code>HttpCache</code>发送请求，与普通的<code>HttpClient</code>用法相同：</p>
<pre><code class="language-csharp">var response = await httpClient.ResponseAsync("https://api.example.com/products");
var content = await response.Content.ReadAsStringAsync();
</code></pre>
</li>
</ol>
<h3 id="replicant的工作原理">Replicant的工作原理</h3>
<ul>
<li><strong>首次请求</strong>：当第一次请求某个资源时，Replicant会将响应的内容和相关的缓存头信息（如<code>ETag</code>）存储在本地缓存中。</li>
<li><strong>后续请求</strong>：再次请求相同资源时，Replicant会检查本地缓存的有效性。如果缓存有效，且资源未更新，Replicant会直接返回缓存的内容，避免实际的HTTP请求。</li>
</ul>
<h2 id="综合示例提升api集成请求性能">综合示例：提升API集成请求性能</h2>
<p>下面，我们将结合Replicant和Delta，提供一个完整的示例，展示如何利用客户端和服务器端缓存，提高API的性能。</p>
<h3 id="后端代码示例">后端代码示例</h3>
<p>以下是使用Delta库的后端代码示例。该示例中，我们构建了一个简单的博客应用，包含了博客（Blog）和帖子（Post）两个实体。</p>
<h4 id="1-配置programcs">1. 配置<code>Program.cs</code></h4>
<pre><code class="language-csharp">using Delta;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;
using System.Text.Json.Serialization;
using TutorialClientCache.Components;

var builder = WebApplication.CreateBuilder(args);
builder.AddNpgsqlDbContext&lt;BloggingContext&gt;("mydb");

// 添加服务到容器
builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

builder.Services.AddBootstrapBlazor();

var app = builder.Build();

// 使用Delta中间件
app.UseDelta&lt;BloggingContext&gt;();

// 定义API端点
app.MapGet("/posts", async (string? title, BloggingContext db) =&gt;
{
    var query = db.Posts
        .Where(p =&gt; title == null || p.Title.Contains(title))
        .OrderByDescending(p =&gt; p.Title)
        .ThenBy(p =&gt; p.Content)
        .Take(10);

    return await query.ToListAsync();
});

// 配置HTTP请求管道
if (app.Environment.IsDevelopment())
{
    app.UseWebAssemblyDebugging();
}
else
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
}

app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(TutorialClientCache.Client._Imports).Assembly);

app.Run();
</code></pre>
<h4 id="2-定义数据上下文和实体">2. 定义数据上下文和实体</h4>
<p><strong>数据上下文 <code>BloggingContext</code></strong></p>
<pre><code class="language-csharp">public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options)
        : base(options)
    {
    }

    public DbSet&lt;Blog&gt; Blogs { get; set; }
    public DbSet&lt;Post&gt; Posts { get; set; }
}
</code></pre>
<p><strong>实体类 <code>Blog</code> 和 <code>Post</code></strong></p>
<pre><code class="language-csharp">public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    public List&lt;Post&gt; Posts { get; } = new List&lt;Post&gt;();
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}
</code></pre>
<h3 id="客户端代码示例">客户端代码示例</h3>
<p>由于浏览器<code>HttpClient</code>已经内置客户端缓存逻辑，这里提供一个可以在其他Runtime环境内使用缓存的例子：</p>
<pre><code class="language-csharp">// See https://aka.ms/new-console-template for more information
using Replicant;
using System.Diagnostics;

Console.WriteLine("Hello, World!");

string url = "http://localhost:5225/posts?title=CSS";

//warm up
await MeasureHttpClientPerformance(url);
await MeasureHttpCachePerformance(url);

for (int i = 0; i &lt; 5; i++)
{
    var httpClientTime = await MeasureHttpClientPerformance(url);
    Console.WriteLine($"HttpClient Time: {httpClientTime} ms");
}
for (int i = 0; i &lt; 5; i++)
{
    var httpCacheTime = await MeasureHttpCachePerformance(url);
    Console.WriteLine($"HttpCache Time: {httpCacheTime} ms");
}


static async Task&lt;long&gt; MeasureHttpClientPerformance(string url)
{
    using var httpClient = new HttpClient();
    var stopwatch = Stopwatch.StartNew();

    var response = await httpClient.GetAsync(url);
    response.EnsureSuccessStatusCode();
    var content = await response.Content.ReadAsStringAsync();

    stopwatch.Stop();
    return stopwatch.ElapsedMilliseconds;
}

static async Task&lt;long&gt; MeasureHttpCachePerformance(string url)
{
    HttpCache cachedClient = HttpCache.Default;
    var stopwatch = Stopwatch.StartNew();

    var response = await cachedClient.ResponseAsync(url);
    response.EnsureSuccessStatusCode();
    var content = await response.Content.ReadAsStringAsync();

    stopwatch.Stop();
    return stopwatch.ElapsedMilliseconds;
}
</code></pre>
<h3 id="效果">效果</h3>
<p><img src="https://img2024.cnblogs.com/blog/3358435/202501/3358435-20250110173130525-1797296321.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3358435/202501/3358435-20250110173135876-873570712.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3358435/202501/3358435-20250110173159319-427215224.png" alt="image" loading="lazy"></p>
<h2 id="结论">结论</h2>
<p>通过结合使用Delta和Replicant，我们可以在.NET应用程序中有效地利用客户端缓存机制，显著提升API的性能。利用<code>ETag</code>和<code>304 Not Modified</code>等HTTP特性，我们能够减少不必要的网络请求和数据传输，提高应用的响应速度和用户体验。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://github.com/SimonCropp/Replicant" target="_blank" rel="noopener nofollow">Replicant GitHub 仓库</a></li>
<li><a href="https://github.com/SimonCropp/Delta" target="_blank" rel="noopener nofollow">Delta GitHub 仓库</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching" target="_blank" rel="noopener nofollow">HTTP 缓存机制详解</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/" target="_blank" rel="noopener nofollow">ASP.NET Core 使用中间件</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.024707768306712962" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 17:41">2025-01-10 17:36</span>&nbsp;
<a href="https://www.cnblogs.com/madtom">MadLongTom</a>&nbsp;
阅读(<span id="post_view_count">40</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664378" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664378);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664378', targetLink: 'https://www.cnblogs.com/madtom/p/18664378', title: '[.NET] 使用客户端缓存提高API性能' })">举报</a>
</div>
        