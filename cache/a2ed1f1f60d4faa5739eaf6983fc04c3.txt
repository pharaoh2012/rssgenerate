
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/deali/p/18792592" title="发布于 2025-03-25 23:37">
    <span role="heading" aria-level="2">基于.NetCore开发 StarBlog 番外篇 (2) 深入解析Markdig源码，优化ToC标题提取和文章目录树生成逻辑</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>虽然现在工作重心以AI为主了，不过相比起各种大模型的宏大叙事，我还是更喜欢自己构思功能、写代码，享受解决问题和发布上线的过程。</p>
<p>之前 StarBlog 系列更新的时候我也有提到，随着功能更新，会在教程系列完结之后继续写番外，这不第一篇番外就来了。</p>
<p>这次是全新设计的访问统计功能。</p>
<h2 id="访问统计">访问统计</h2>
<p>访问统计功能很早就已经实现了，在之前这篇 <a href="https://www.cnblogs.com/deali/p/16349155.html" target="_blank">基于.NetCore开发博客项目 StarBlog - (11) 实现访问统计</a></p>
<h2 id="旧实现存在的问题">旧实现存在的问题</h2>
<p>之前是添加了一个中间件 <code>VisitRecordMiddleware</code> ，每个请求都写入到数据库里</p>
<p>这样会导致两个问题：</p>
<ol>
<li>
<p>影响性能</p>
</li>
<li>
<p>导致数据库太大，不好备份</p>
</li>
</ol>
<h2 id="新的实现">新的实现</h2>
<p>我一直对之前这个实现不满意</p>
<p>这次索性重新设计了，一次性把以上提到的问题都解决了</p>
<p>我用 mermaid 画了个简单的图（第一次尝试在文章里插入 mermaid 画的图，不知道效果咋样）</p>
<p><a href="https://mermaid.js.org/syntax/flowchart.html" target="_blank" rel="noopener nofollow">https://mermaid.js.org/syntax/flowchart.html</a></p>
<div class="mermaid">取出日志
写入数据库
用户请求
访问日志中间件
日志队列
后台定时任务
访问日志独立数据库
新的访问统计功能设计图
</div><p>新的实现用一个队列来暂存访问日志</p>
<p>并且添加了后台任务，定时从队列里取出访问日志来写入数据库</p>
<p>这样就不会影响访问速度</p>
<p>到这里这个新的功能基本就介绍完了</p>
<p>当然具体实现会有一些细节需要注意，接下来的代码部分会介绍</p>
<p>新的技术栈.</p>
<p>这次我用了 EFCore 作为 ORM</p>
<p>原因和如何引入我在之前这篇文章有介绍了：<a href="https://www.cnblogs.com/deali/p/17749676.html" target="_blank">Asp-Net-Core开发笔记：快速在已有项目中引入efcore</a></p>
<p>主要目的是使用 EFCore 能更方便实现分库</p>
<h2 id="具体实现">具体实现</h2>
<p>接下来是具体的代码实现</p>
<h3 id="队列">队列</h3>
<p>在 <code>StarBlog.Web/Services</code> 里添加 <code>VisitRecordQueueService.cs</code> 文件</p>
<pre><code class="language-c#">public class VisitRecordQueueService {
 &nbsp;private readonly ConcurrentQueue&lt;VisitRecord&gt; _logQueue = new ConcurrentQueue&lt;VisitRecord&gt;();
 &nbsp;private readonly ILogger&lt;VisitRecordQueueService&gt; _logger;
 &nbsp;private readonly IServiceScopeFactory _scopeFactory;
​
 &nbsp;/// &lt;summary&gt;
 &nbsp;/// 批量大小
 &nbsp;/// &lt;/summary&gt;
 &nbsp;private const int BatchSize = 10;
​
 &nbsp;public VisitRecordQueueService(ILogger&lt;VisitRecordQueueService&gt; logger, IServiceScopeFactory scopeFactory) {
 &nbsp; &nbsp;_logger = logger;
 &nbsp; &nbsp;_scopeFactory = scopeFactory;
  }
​
 &nbsp;// 将日志加入队列
 &nbsp;public void EnqueueLog(VisitRecord log) {
 &nbsp; &nbsp;_logQueue.Enqueue(log);
  }
​
 &nbsp;// 定期批量写入数据库的
 &nbsp;public async Task WriteLogsToDatabaseAsync(CancellationToken cancellationToken) {
 &nbsp; &nbsp;if (_logQueue.IsEmpty) {
 &nbsp; &nbsp; &nbsp;// 暂时等待，避免高频次无意义的检查
 &nbsp; &nbsp; &nbsp;await Task.Delay(1000, cancellationToken);
 &nbsp; &nbsp; &nbsp;return;
 &nbsp;  }
​
 &nbsp; &nbsp;var batch = new List&lt;VisitRecord&gt;();
 &nbsp; &nbsp;// 从队列中取出一批日志
 &nbsp; &nbsp;while (_logQueue.TryDequeue(out var log) &amp;&amp; batch.Count &lt; BatchSize) {
 &nbsp; &nbsp; &nbsp;batch.Add(log);
 &nbsp;  }
​
 &nbsp; &nbsp;try {
 &nbsp; &nbsp; &nbsp;using var scope = _scopeFactory.CreateScope();
 &nbsp; &nbsp; &nbsp;var dbCtx = scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;();
 &nbsp; &nbsp; &nbsp;await using var transaction = await dbCtx.Database.BeginTransactionAsync(cancellationToken);
 &nbsp; &nbsp; &nbsp;try {
 &nbsp; &nbsp; &nbsp; &nbsp;dbCtx.VisitRecords.AddRange(batch);
 &nbsp; &nbsp; &nbsp; &nbsp;await dbCtx.SaveChangesAsync(cancellationToken);
 &nbsp; &nbsp; &nbsp; &nbsp;await transaction.CommitAsync(cancellationToken);
 &nbsp; &nbsp; &nbsp; &nbsp;_logger.LogInformation("访问日志 Successfully wrote {BatchCount} logs to the database", batch.Count);
 &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp;catch (Exception) {
 &nbsp; &nbsp; &nbsp; &nbsp;await transaction.RollbackAsync(cancellationToken);
 &nbsp; &nbsp; &nbsp; &nbsp;throw;
 &nbsp; &nbsp;  }
 &nbsp;  }
 &nbsp; &nbsp;catch (Exception ex) {
 &nbsp; &nbsp; &nbsp;_logger.LogError(ex, "访问日志 Error writing logs to the database: {ExMessage}", ex.Message);
 &nbsp;  }
  }
}
</code></pre>
<p>这里使用了：</p>
<ul>
<li><code>ConcurrentQueue</code> 这个线程安全的FIFO队列</li>
<li>在批量写入数据库的时候用了事务，遇到报错自动回滚</li>
</ul>
<h3 id="中间件">中间件</h3>
<p>修改 StarBlog.Web/Middlewares/VisitRecordMiddleware.cs</p>
<ul>
<li></li>
</ul>
<h2 id="public-class-visitrecordmiddleware-private-readonly-requestdelegate-_nextpublic-visitrecordmiddlewarerequestdelegate-requestdelegate--_next--requestdelegatepublic-task-invokehttpcontext-context-visitrecordqueueservice-logqueue--var-request--contextrequest-var-ip--contextgetremoteipaddresstostring-var-item--new-visitrecord---ip--iptostring--requestpath--requestpath--requestquerystring--requestquerystringvalue--requestmethod--requestmethod--useragent--requestheadersuseragent--time--datetimenow---logqueueenqueuelogitem-return-_nextcontext">public class VisitRecordMiddleware {<br>
&nbsp;private readonly RequestDelegate _next;<br>
​<br>
&nbsp;public VisitRecordMiddleware(RequestDelegate requestDelegate) {<br>
&nbsp; &nbsp;_next = requestDelegate;<br>
}<br>
​<br>
&nbsp;public Task Invoke(HttpContext context, VisitRecordQueueService logQueue) {<br>
&nbsp; &nbsp;var request = context.Request;<br>
&nbsp; &nbsp;var ip = context.GetRemoteIpAddress()?.ToString();<br>
&nbsp; &nbsp;var item = new VisitRecord {<br>
&nbsp; &nbsp; &nbsp;Ip = ip?.ToString(),<br>
&nbsp; &nbsp; &nbsp;RequestPath = request.Path,<br>
&nbsp; &nbsp; &nbsp;RequestQueryString = request.QueryString.Value,<br>
&nbsp; &nbsp; &nbsp;RequestMethod = request.Method,<br>
&nbsp; &nbsp; &nbsp;UserAgent = request.Headers.UserAgent,<br>
&nbsp; &nbsp; &nbsp;Time = DateTime.Now<br>
&nbsp;  };<br>
&nbsp; &nbsp;logQueue.EnqueueLog(item);<br>
​<br>
&nbsp; &nbsp;return _next(context);<br>
}<br>
}</h2>
<p>没什么特别的，就是把之前数据库操作替换为添加到队列</p>
<p>注意依赖注入不能在中间件的构造方法里，<code>IApplicationBuilder</code> 注册中间件的时候依赖注入容器还没完全准备好</p>
<h3 id="后台任务">后台任务</h3>
<p>在 StarBlog.Web/Services 里添加 <code>VisitRecordWorker.cs</code> 文件</p>
<pre><code class="language-c#">public class VisitRecordWorker : BackgroundService {
 &nbsp;private readonly ILogger&lt;VisitRecordWorker&gt; _logger;
 &nbsp;private readonly IServiceScopeFactory _scopeFactory;
 &nbsp;private readonly VisitRecordQueueService _logQueue;
 &nbsp;private readonly TimeSpan _executeInterval = TimeSpan.FromSeconds(30);
​
 &nbsp;public VisitRecordWorker(ILogger&lt;VisitRecordWorker&gt; logger, IServiceScopeFactory scopeFactory, VisitRecordQueueService logQueue) {
 &nbsp; &nbsp;_logger = logger;
 &nbsp; &nbsp;_scopeFactory = scopeFactory;
 &nbsp; &nbsp;_logQueue = logQueue;
  }
​
 &nbsp;protected override async Task ExecuteAsync(CancellationToken stoppingToken) {
 &nbsp; &nbsp;while (!stoppingToken.IsCancellationRequested) {
 &nbsp; &nbsp; &nbsp;await _logQueue.WriteLogsToDatabaseAsync(stoppingToken);
 &nbsp; &nbsp; &nbsp;await Task.Delay(_executeInterval, stoppingToken);
 &nbsp; &nbsp; &nbsp;_logger.LogDebug("后台任务 VisitRecordWorker ExecuteAsync");
 &nbsp;  }
  }
}
</code></pre>
<p>要注意的是，BackgroundService 是 singleton 生命周期的，而数据库相关的是 scoped 生命周期，所以在使用前要先获取 scope ，而不是直接注入。</p>
<p>这里使用了 <code>IServiceScopeFactory</code> 而不是 <code>IServiceProvider</code></p>
<p>在多线程环境里可以保证可以获取根容器的实例，这也是微软文档里推荐的做法。</p>
<h2 id="分库与重构">分库与重构</h2>
<h3 id="引入efcore">引入EFCore</h3>
<p>如上文所说，访问日志是比较大的，上线这个功能之后几个月的时间，就积累了几十万的数据，在数据库里占用也有100多M了，虽然这还远远达不到数据库的瓶颈</p>
<p>但是对于我们这个轻量级的项目来说，当我想要备份的时候，相比起几个MB的博客数据，这上百MB的访问日志就成了冗余数据，这部分几乎没有备份的意义</p>
<p>所以分库就是势在必得的</p>
<p>这次我使用了EFCore来单独操作这个新的数据库</p>
<p>具体如何引入和实现，之前那篇文章介绍得很详细了，本文不再重复。</p>
<p><a href="https://www.cnblogs.com/deali/p/17749676.html" target="_blank">Asp-Net-Core开发笔记：快速在已有项目中引入efcore</a></p>
<h3 id="重构服务">重构服务</h3>
<p>因为使用了EFCore，涉及到的服务也需要调整一下，从FreeSQL换到EFCore</p>
<p>修改 StarBlog.Web/Services/VisitRecordService.cs</p>
<pre><code class="language-c#">public class VisitRecordService {
 &nbsp;private readonly ILogger&lt;VisitRecordService&gt; _logger;
 &nbsp;private readonly AppDbContext _dbContext;
​
 &nbsp;public VisitRecordService(ILogger&lt;VisitRecordService&gt; logger, AppDbContext dbContext) {
 &nbsp; &nbsp;_logger = logger;
 &nbsp; &nbsp;_dbContext = dbContext;
  }
​
 &nbsp;public async Task&lt;VisitRecord?&gt; GetById(int id) {
 &nbsp; &nbsp;var item = await _dbContext.VisitRecords.FirstOrDefaultAsync(e =&gt; e.Id == id);
 &nbsp; &nbsp;return item;
  }
​
 &nbsp;public async Task&lt;List&lt;VisitRecord&gt;&gt; GetAll() {
 &nbsp; &nbsp;return await _dbContext.VisitRecords.OrderByDescending(e =&gt; e.Time).ToListAsync();
  }
​
 &nbsp;public async Task&lt;IPagedList&lt;VisitRecord&gt;&gt; GetPagedList(VisitRecordQueryParameters param) {
 &nbsp; &nbsp;var querySet = _dbContext.VisitRecords.AsQueryable();
​
 &nbsp; &nbsp;// 搜索
 &nbsp; &nbsp;if (!string.IsNullOrEmpty(param.Search)) {
 &nbsp; &nbsp; &nbsp;querySet = querySet.Where(a =&gt; a.RequestPath.Contains(param.Search));
 &nbsp;  }
​
 &nbsp; &nbsp;// 排序
 &nbsp; &nbsp;if (!string.IsNullOrEmpty(param.SortBy)) {
 &nbsp; &nbsp; &nbsp;var isDesc = param.SortBy.StartsWith("-");
 &nbsp; &nbsp; &nbsp;var orderByProperty = param.SortBy.Trim('-');
 &nbsp; &nbsp; &nbsp;if (isDesc) {
 &nbsp; &nbsp; &nbsp; &nbsp;orderByProperty = $"{orderByProperty} desc";
 &nbsp; &nbsp;  }
​
 &nbsp; &nbsp; &nbsp;querySet = querySet.OrderBy(orderByProperty);
 &nbsp;  }
 &nbsp; &nbsp;
 &nbsp; &nbsp;IPagedList&lt;VisitRecord&gt; pagedList = new StaticPagedList&lt;VisitRecord&gt;(
 &nbsp; &nbsp; &nbsp;await querySet.Page(param.Page, param.PageSize).ToListAsync(),
 &nbsp; &nbsp; &nbsp;param.Page, param.PageSize,
 &nbsp; &nbsp; &nbsp;Convert.ToInt32(await querySet.CountAsync())
 &nbsp;  );
 &nbsp; &nbsp;return pagedList;
  }
​
 &nbsp;/// &lt;summary&gt;
 &nbsp;/// 总览数据
 &nbsp;/// &lt;/summary&gt;
 &nbsp;public async Task&lt;object&gt; Overview() {
 &nbsp; &nbsp;var querySet = _dbContext.VisitRecords
 &nbsp; &nbsp;  .Where(e =&gt; !e.RequestPath.StartsWith("/Api"));
​
 &nbsp; &nbsp;return new {
 &nbsp; &nbsp; &nbsp;TotalVisit = await querySet.CountAsync(),
 &nbsp; &nbsp; &nbsp;TodayVisit = await querySet.Where(e =&gt; e.Time.Date == DateTime.Today).CountAsync(),
 &nbsp; &nbsp; &nbsp;YesterdayVisit = await querySet
 &nbsp; &nbsp; &nbsp;  .Where(e =&gt; e.Time.Date == DateTime.Today.AddDays(-1).Date)
 &nbsp; &nbsp; &nbsp;  .CountAsync()
 &nbsp;  };
  }
​
 &nbsp;/// &lt;summary&gt;
 &nbsp;/// 趋势数据
 &nbsp;/// &lt;/summary&gt;
 &nbsp;/// &lt;param name="days"&gt;查看最近几天的数据，默认7天&lt;/param&gt;
 &nbsp;public async Task&lt;object&gt; Trend(int days = 7) {
 &nbsp; &nbsp;var startDate = DateTime.Today.AddDays(-days).Date;
 &nbsp; &nbsp;return await _dbContext.VisitRecords
 &nbsp; &nbsp;  .Where(e =&gt; !e.RequestPath.StartsWith("/Api"))
 &nbsp; &nbsp;  .Where(e =&gt; e.Time.Date &gt;= startDate)
 &nbsp; &nbsp;  .GroupBy(e =&gt; e.Time.Date)
 &nbsp; &nbsp;  .Select(g =&gt; new {
 &nbsp; &nbsp; &nbsp; &nbsp;time = g.Key,
 &nbsp; &nbsp; &nbsp; &nbsp;date = $"{g.Key.Month}-{g.Key.Day}",
 &nbsp; &nbsp; &nbsp; &nbsp;count = g.Count()
 &nbsp; &nbsp;  })
 &nbsp; &nbsp;  .OrderBy(e =&gt; e.time)
 &nbsp; &nbsp;  .ToListAsync();
  }
​
 &nbsp;/// &lt;summary&gt;
 &nbsp;/// 统计数据
 &nbsp;/// &lt;/summary&gt;
 &nbsp;public async Task&lt;object&gt; Stats(DateTime date) {
 &nbsp; &nbsp;return new {
 &nbsp; &nbsp; &nbsp;Count = await _dbContext.VisitRecords
 &nbsp; &nbsp; &nbsp;  .Where(e =&gt; e.Time.Date == date)
 &nbsp; &nbsp; &nbsp;  .Where(e =&gt; !e.RequestPath.StartsWith("/Api"))
 &nbsp; &nbsp; &nbsp;  .CountAsync()
 &nbsp;  };
  }
}
</code></pre>
<p>主要变动的就是 GetPagedList 和 Overview 接口</p>
<p>{0}. EFCore默认不支持按字段名称排序，为此我引入了 Microsoft.EntityFrameworkCore.DynamicLinq 库来实现<br>
{0}. EFCore 似乎没有FreeSQL的Aggregate API，可以用原生SQL来替换，但我没有这么做，还是做了多次查询，其实影响不大</p>
<p>其他的属于语法的区别，简单修改即可。</p>
<h2 id="小结">小结</h2>
<p>时隔好久再次为 StarBlog 开发新功能，C# 的开发体验还是那么丝滑</p>
<p>然而 "Packages with vulnerabilities have been detected" 的警告也在提醒我这个项目的SDK版本已经outdated了</p>
<p>所以接下来会找时间尽快升级</p>
<p>预告一波：下一个功能与备份有关</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/scoped-service" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/scoped-service</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/wucy/p/16566495.html" target="_blank">https://www.cnblogs.com/wucy/p/16566495.html</a></p>
</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    微信公众号：「程序设计实验室」
专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6975351546180556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-25 23:37">2025-03-25 23:37</span>&nbsp;
<a href="https://www.cnblogs.com/deali">程序设计实验室</a>&nbsp;
阅读(<span id="post_view_count">109</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18792592" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18792592);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18792592', targetLink: 'https://www.cnblogs.com/deali/p/18792592', title: '基于.NetCore开发 StarBlog 番外篇 (2) 深入解析Markdig源码，优化ToC标题提取和文章目录树生成逻辑' })">举报</a>
</div>
        