
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ITnoteforlsy/p/18838786" title="发布于 2025-04-22 09:14">
    <span role="heading" aria-level="2">借助 QT 的反射机制实现 C++ 数据类的序列化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 C++ 工程中经常需要使用数据类，并对数据类进行存储、打印、调试等操作。由于数据类中有大量数据字段，每次都编写存储或输出数据内容，工作重复量太大。C++ 不支持用户自定义的注解，所以没办法使用类似 java 中类似 Lombok 的插件。但是 QT 的属性系统和 moc 编译系统，为简化数据类的序列化提供了可能性。</p>
<h3 id="设计预期">设计预期</h3>
<ol>
<li>保持数据类的简洁，最好通过类似 Lombok 的注解语法，只让声明序列化的数据字段支持序列化；</li>
<li>自动生成 getter 和 setter 方法；</li>
<li>支持数据流输入/输出；</li>
<li>支持 QDebug 直接输出对象内容；</li>
<li>能自动解包 QPoint、QRect、QVariant 等结构化数据。</li>
</ol>
<h3 id="设计思路">设计思路</h3>
<ol>
<li>使用宏代理注解完成 getter 和 setter 方法的自动生成；</li>
<li>使用反射系统结合宏定义记录需要序列化的字段信息；</li>
<li>使用基类完成序列化的模板代码，让数据类继承序列化基类即可完成数据的序列化。</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<p>以下代码中 Serializable 是数据类的基类，在其 cpp 文件中内置了许多模板代码用于支持处理数据流及 QDebug 操作。宏 SERIALIZE(className) 用于指定需要序列化的类，宏JSONFIELD(field, alias, ...) 用于指定需要序列化的字段。为了保证数据类的轻量化，此处没有使用 QObject 类，而是使用了轻量化的 Q_GADGET，这样在预编译时不会产生太多的代码。</p>
<pre><code>// serializable.h
#ifndef SERIALIZABLE_H
#define SERIALIZABLE_H

#include "qjsonobject.h"

#include &lt;QObject&gt;
#include &lt;QMetaObject&gt;
#include &lt;QMetaProperty&gt;
#include &lt;QDebug&gt;
#include &lt;QFile&gt;

#include &lt;QtWidgets/QMessageBox&gt;

// SERIALIZE 宏内不能包含 Q_GADGET ，必须在子类中单独使用 Q_GADGET，
// 因为 moc 时不引入其它头文件，此处定义Q_GADGET对子类无效，子类不会生成moc文件
//const_cast&lt;className&amp;&gt;(explicit
#define SERIALIZE(className) \
Q_CLASSINFO("base", "Serializable") \
public: \
className(const className &amp;other){ \
    copy(other, *this); \
} \
inline const QMetaObject* getMetaInfo() const override{ \
    return &amp;staticMetaObject; \
}

#ifndef Q_MOC_RUN
// define the tag text as empty, so the compiler doesn't see it
#  define JSON_FLAG
#endif
#define VAR_TYPE(var) decltype(var)

#ifdef CHAIN
#define SETTER(field, alias) \
inline auto set##alias(const __type_##field &amp;value) { \
    field = value; \
return this; \
}
#else
#define SETTER(field, alias) \
inline void set##alias(const __type_##field &amp;value) { \
    field = const_cast&lt;__type_##field&gt;(value); \
}
#endif

#define JSONFIELD(field, alias, ...) \
using __type_##field = decltype(field) ;\
Q_PROPERTY(__type_##field field READ get##alias WRITE set##alias) \
    public: \
    Q_INVOKABLE JSON_FLAG inline QMap&lt;QString, QString&gt; __get##alias##Info__(){ \
        QMap&lt;QString, QString&gt; info; \
        info["name"] = #field; \
        info["alias"] = #alias; \
        info["args"] = QString(#__VA_ARGS__); \
        return info; \
    } \
    inline __type_##field get##alias() const { return field; } \
    inline void set##alias(const __type_##field &amp;value) { \
            field = value; \
    }

class Serializable
{
public:
    Serializable();
    virtual ~Serializable();
    static bool isSubClass(QMetaType type);
    virtual const QMetaObject* getMetaInfo() const = 0;
    void copy(const Serializable &amp;from, Serializable &amp;to);
    void copy(const Serializable &amp;from);
    virtual QString hashCode();
    virtual bool equals(Serializable &amp;obj);
    virtual bool operator==(Serializable &amp;obj);
    virtual QString toString();
    template&lt;typename T&gt;
    T invokeMethod(const QMetaObject *metaInfo, int index);
    virtual QVariant getValue(QString fieldName);
    virtual void setValue(QString fieldName, QVariant value);

    friend QDataStream &amp;operator&lt;&lt;(QDataStream &amp;stream, const Serializable &amp;data);
    friend QDataStream &amp;operator&gt;&gt;(QDataStream &amp;stream, Serializable &amp;data);
    friend QDebug operator&lt;&lt;(QDebug dbg, const Serializable &amp;data);

private:
    QString id;
};

Q_DECLARE_METATYPE(Serializable)

#endif // SERIALIZABLE_H
</code></pre>
<p>由于 cpp 文件的代码太多，此处不再贴出来，需要的请到项目 <a href="https://github.com/lsyeei/dashboard" target="_blank" rel="noopener nofollow">https://github.com/lsyeei/dashboard</a> 的源码目录 /common/ 中查看 serializable.cpp</p>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>子类继承 Serializable</li>
<li>子类中须使用宏 Q_GADGET</li>
<li>子类中使用宏 SERIALIZE(className) 开启序列化功能</li>
<li>子类中使用 JSONFIELD(field, alias, ...) 指定哪些字段需要序列化</li>
<li>使用Q_DECLARE_METATYPE(className)注册元数据类型</li>
</ol>
<p>说明：</p>
<ol>
<li>使用 SERIALIZE 会自动生成拷贝构造函数</li>
<li>使用 JSONFIELD 指定的字段会自动生成 get和set函数，不必单独声明<br>
举例：</li>
</ol>
<pre><code>class Student : public Serializable
{
 Q_GADGET
 SERIALIZE(Student)
 public:
     Student();
     ~Student();
 private:
     QString name;
     int age;

     JSONFIELD(name, Name)
     JSONFIELD(age, Age)
};
Q_DECLARE_METATYPE(Cunstom)
</code></pre>
<p>Student的使用方法：</p>
<pre><code>Student student;
student.setName("li");
student.setAge(15);
qDebug() &lt;&lt; student;
QByteArray array;
QDataStream stream(&amp;array, QIODeviceBase::WriteOnly);
stream &lt;&lt; student;
</code></pre>
<p>项目 <a href="https://github.com/lsyeei/dashboard" target="_blank" rel="noopener nofollow">Compelling Data Designer</a> 用于数据的可视化设计，软件采用可扩展架构，支持扩展图形插件、数据接口。项目仍在开发中，目前已设计完成基本图形、多属性配置、动画等功能。结合 Serializable 类，项目中还提供了 JSON 序列化的实现方式。具体介绍见：<a href="https://www.cnblogs.com/ITnoteforlsy/p/18840486" target="_blank">QT 实现 C++ 数据类与 json 的转换</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250421163503119-611157632.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407102627551-720752550.gif" alt="demo" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.10808587591203704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-22 15:43">2025-04-22 09:14</span>&nbsp;
<a href="https://www.cnblogs.com/ITnoteforlsy">永不停转</a>&nbsp;
阅读(<span id="post_view_count">82</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18838786);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18838786', targetLink: 'https://www.cnblogs.com/ITnoteforlsy/p/18838786', title: '借助 QT 的反射机制实现 C++ 数据类的序列化' })">举报</a>
</div>
        