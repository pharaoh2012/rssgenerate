
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tengzijian/p/18775674" title="发布于 2025-03-16 21:20">
    <span role="heading" aria-level="2">依赖倒置 DIP、依赖注入 DI、控制反转 IoC 和工厂模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-依赖倒置">1. 依赖倒置</h2>
<p>依赖倒置原则（Dependency Inversion Principle, DIP）是 SOLID 原则中的一项，其<strong>核心思想</strong>是通过<strong>抽象</strong>解耦高层模块和低层模块，使<strong>二者都依赖于抽象而非具体实现</strong>。</p>
<p><strong>依赖反转/倒置的体现</strong>：传统依赖方向是高层模块直接调用低层模块，在源码级别上高层模块依赖低层细节模块。而 DIP 通过抽象反转这种依赖关系，使低层模块的实现在源码级别上依赖高层定义的抽象（<strong>视为高层模块的一部分</strong>）。</p>
<h3 id="11-依赖倒置原则的核心">1.1 依赖倒置原则的核心</h3>
<ol>
<li><strong>高层模块不直接依赖低层模块</strong>，二者都应依赖抽象（接口或抽象类，接口由高层模块定义，视为高层模块的一部分）。</li>
<li><strong>抽象不依赖细节</strong>，细节（具体实现）应依赖抽象。</li>
</ol>
<h3 id="12-依赖倒置指导方针">1.2 依赖倒置指导方针</h3>
<ul>
<li>变量不可以持有具体类的引用——改用工厂，<strong>避免直接使用 new 持有具体类的引用（new 具体类的操作都封装到工厂中）</strong></li>
<li>不要让类派生自具体类——派生自抽象类或接口，这样就不依赖具体类了</li>
<li>不要覆盖基类中已经实现的方法——如果这样，说明不是一个真正适合被继承的抽象</li>
</ul>
<h3 id="13-示例"><strong>1.3 示例</strong></h3>
<h4 id="场景"><strong>场景</strong></h4>
<ul>
<li>高层模块 <code>ReportGenerator</code> 需要生成报告，依赖数据获取功能。</li>
<li>低层模块 <code>MySQLDatabase</code> 和 <code>SQLiteDatabase</code> 提供具体的数据操作。</li>
</ul>
<h4 id="传统实现未遵循-dip"><strong>传统实现（未遵循 DIP）</strong></h4>
<pre><code class="language-cpp">// 低层模块：直接依赖具体实现
class MySQLDatabase {
public:
    void connect() { /* MySQL 连接逻辑 */ }
    std::string fetchData() { return "MySQL 数据"; }
};

// 高层模块直接依赖低层具体类
class ReportGenerator {
private:
    MySQLDatabase db;  // 直接依赖具体实现
public:
    void generateReport() {
        db.connect();
        auto data = db.fetchData();
        std::cout &lt;&lt; "报告数据: " &lt;&lt; data &lt;&lt; std::endl;
    }
};
</code></pre>
<p><strong>问题</strong>：<code>ReportGenerator</code> 直接依赖 <code>MySQLDatabase</code>，更换数据库（如改用 SQLite）需修改高层代码。</p>
<h4 id="遵循-dip-的实现"><strong>遵循 DIP 的实现</strong></h4>
<ol>
<li><strong>定义抽象接口</strong>：</li>
</ol>
<pre><code class="language-cpp">class Database {
public:
    virtual ~Database() = default;
    virtual void connect() = 0;
    virtual std::string fetchData() = 0;
};
</code></pre>
<ol start="2">
<li><strong>低层模块实现接口</strong>：</li>
</ol>
<pre><code class="language-cpp">class MySQLDatabase : public Database {
public:
    void connect() override { /* MySQL 连接逻辑 */ }
    std::string fetchData() override { return "MySQL 数据"; }
};

class SQLiteDatabase : public Database {
public:
    void connect() override { /* SQLite 连接逻辑 */ }
    std::string fetchData() override { return "SQLite 数据"; }
};
</code></pre>
<ol start="3">
<li><strong>高层模块依赖抽象</strong>：</li>
</ol>
<pre><code class="language-cpp">class ReportGenerator {
private:
    Database&amp; db;  // 依赖抽象接口
public:
    ReportGenerator(Database&amp; database) : db(database) {}  // 依赖注入
    void generateReport() {
        db.connect();
        auto data = db.fetchData();
        std::cout &lt;&lt; "报告数据: " &lt;&lt; data &lt;&lt; std::endl;
    }
};
</code></pre>
<ol start="4">
<li><strong>使用示例</strong>：</li>
</ol>
<pre><code class="language-cpp">int main() {
    MySQLDatabase mysqlDb;
    SQLiteDatabase sqliteDb;

    ReportGenerator report1(mysqlDb);   // 使用 MySQL
    report1.generateReport();

    ReportGenerator report2(sqliteDb);  // 使用 SQLite
    report2.generateReport();

    return 0;
}
</code></pre>
<h3 id="14-依赖倒置优势">1.4 依赖倒置优势</h3>
<ul>
<li><strong>解耦</strong>：高层模块不依赖低层具体实现，可灵活替换数据库（如新增 <code>MongoDB</code> 只需实现 <code>Database</code> 接口）。</li>
<li><strong>可维护性</strong>：修改低层代码（如优化 <code>MySQLDatabase</code>）不影响高层模块。</li>
<li><strong>可测试性</strong>：可通过 Mock 对象（实现 <code>Database</code> 接口）轻松测试 <code>ReportGenerator</code>。</li>
</ul>
<h3 id="15-依赖倒置小结">1.5 依赖倒置小结</h3>
<p>依赖倒置原则通过抽象解耦模块，使依赖关系从“高层 → 低层”变为“高层 → 抽象 ← 低层”，从而提升系统的灵活性和可维护性。在 C++ 中，可通过抽象类（接口）和依赖注入（如构造函数传入接口指针/引用）实现这一原则。</p>
<h2 id="2-依赖注入-di">2. 依赖注入 DI</h2>
<p>依赖注入（<strong>Dependency Injection, DI</strong>）是一种<strong>将对象依赖关系的外部化技术</strong>，其核心思想是：<strong>对象不直接创建或管理自己的依赖，而是由外部（调用者或框架）提供依赖的实例</strong>。通过这种方式，代码的耦合度降低，灵活性和可测试性显著提高。</p>
<h3 id="21-依赖注入的本质">2.1 依赖注入的本质</h3>
<ol>
<li><strong>控制反转（IoC）</strong><br>
依赖注入是控制反转的一种实现方式。传统代码中，对象自己控制依赖的创建（如 <code>new</code> 一个具体类），而依赖注入将这一控制权交给外部，实现“<strong>依赖被注入到对象中</strong>”。</li>
<li><strong>依赖抽象而非实现</strong><br>
依赖注入通常结合接口或抽象类使用，确保对象依赖的是抽象，而非具体实现（符合<strong>依赖倒置原则</strong>）。</li>
</ol>
<h3 id="22-依赖注入的三种方式">2.2 依赖注入的三种方式</h3>
<h4 id="1-构造函数注入最常用">1. <strong>构造函数注入（最常用）</strong></h4>
<p>通过构造函数传递依赖，确保对象在创建时即具备完整依赖。</p>
<pre><code class="language-cpp">class NotificationService {
private:
    MessageSender&amp; sender;  // 依赖抽象接口
public:
    NotificationService(MessageSender&amp; sender) : sender(sender) {}  // 构造函数注入
    void sendMessage(const std::string&amp; msg) {
        sender.send(msg);
    }
};
</code></pre>
<h4 id="2-属性注入setter-注入">2. <strong>属性注入（Setter 注入）</strong></h4>
<p>通过公开的成员属性或 Setter 方法动态设置依赖。</p>
<pre><code class="language-cpp">class NotificationService {
public:
    void setSender(MessageSender&amp; sender) {  // Setter 注入
        this-&gt;sender = &amp;sender;
    }
private:
    MessageSender* sender;
};
</code></pre>
<h4 id="3-方法注入">3. <strong>方法注入</strong></h4>
<p>通过方法参数传递依赖，适用于临时或局部依赖。</p>
<pre><code class="language-cpp">class NotificationService {
public:
    void sendMessage(MessageSender&amp; sender, const std::string&amp; msg) {  // 方法注入
        sender.send(msg);
    }
};
</code></pre>
<h3 id="23-为什么需要依赖注入">2.3 为什么需要依赖注入？</h3>
<h4 id="1-解耦与可维护性">1. <strong>解耦与可维护性</strong></h4>
<ul>
<li>
<p><strong>传统代码</strong>：对象内部直接创建依赖，导致紧耦合。</p>
<pre><code class="language-cpp"></code></pre>
</li>
</ul>
<p>class UserService {<br>
private:<br>
MySQLDatabase db;  // 直接依赖具体类<br>
};</p>
<pre><code>
若需改用 `SQLiteDatabase`，必须修改 `UserService` 的代码。

- **依赖注入**：通过接口解耦，仅需注入不同实现。

```cpp
class UserService {
private:
    Database&amp; db;  // 依赖抽象
public:
    UserService(Database&amp; db) : db(db) {}
};
</code></pre>
<h4 id="2-可测试性">2. <strong>可测试性</strong></h4>
<ul>
<li>
<p>依赖注入允许在测试时替换为 Mock 对象。</p>
<pre><code class="language-cpp">class MockDatabase : public Database { /* 模拟实现 */ };

TEST(UserServiceTest) {
    MockDatabase mockDb;
    UserService service(mockDb);  // 注入 Mock 对象
    // 执行测试...
}
</code></pre>
</li>
</ul>
<h4 id="3-扩展性">3. <strong>扩展性</strong></h4>
<ul>
<li>
<p>新增功能时，只需实现新依赖并注入，无需修改现有代码。</p>
<pre><code class="language-cpp">class MongoDB : public Database { /* 新数据库实现 */ };

MongoDB mongoDb;
UserService service(mongoDb);  // 直接注入新依赖
</code></pre>
</li>
</ul>
<h3 id="24-c-依赖注入的实践技巧">2.4 C++ 依赖注入的实践技巧</h3>
<h4 id="1-使用智能指针管理生命周期">1. <strong>使用智能指针管理生命周期</strong></h4>
<p>避免裸指针导致的内存泄漏，使用 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code>。</p>
<p>cpp</p>
<pre><code class="language-cpp">class NotificationService {
private:
    std::shared_ptr&lt;MessageSender&gt; sender;  // 智能指针管理依赖
public:
    NotificationService(std::shared_ptr&lt;MessageSender&gt; sender) : sender(sender) {}
};
</code></pre>
<h4 id="2-结合工厂模式">2. <strong>结合工厂模式</strong></h4>
<p>通过工厂类集中管理依赖的创建逻辑。</p>
<pre><code class="language-cpp">class SenderFactory {
public:
    static std::shared_ptr&lt;MessageSender&gt; createSender(const std::string&amp; type) {
        if (type == "email") return std::make_shared&lt;EmailSender&gt;();
        else return std::make_shared&lt;SmsSender&gt;();
    }
};

// 使用工厂创建依赖
auto sender = SenderFactory::createSender("email");
NotificationService service(sender);
</code></pre>
<h4 id="3-依赖注入容器ioc-container">3. <strong>依赖注入容器（IoC Container）</strong></h4>
<p>在复杂项目中，使用容器自动管理依赖关系（如 Boost.DI）。</p>
<pre><code class="language-cpp">#include &lt;boost/di.hpp&gt;
namespace di = boost::di;

// 定义接口和实现
class Database { /* ... */ };
class MySQLDatabase : public Database { /* ... */ };

// 配置容器
auto injector = di::make_injector(
    di::bind&lt;Database&gt;().to&lt;MySQLDatabase&gt;()
);

// 自动注入依赖
class UserService {
public:
    UserService(Database&amp; db) { /* ... */ }
};
UserService service = injector.create&lt;UserService&gt;();
</code></pre>
<h3 id="25-依赖注入的常见误区">2.5 依赖注入的常见误区</h3>
<ol>
<li><strong>依赖注入 ≠ 工厂模式</strong><br>
工厂模式负责创建对象，而依赖注入负责传递对象。二者常结合使用，但目的不同。</li>
<li><strong>依赖注入 ≠ 必须用框架</strong><br>
即使不用框架（如 Boost.DI），通过构造函数或参数传递依赖，也能实现依赖注入。</li>
<li><strong>过度注入问题</strong><br>
若一个类需要注入过多依赖（如超过 4 个），可能设计存在问题，需考虑拆分职责。</li>
</ol>
<h3 id="26-依赖注入小结">2.6 依赖注入小结</h3>
<ul>
<li>
<p><strong>依赖注入的核心</strong>：将依赖的创建和绑定从对象内部转移到外部。</p>
</li>
<li>
<p><strong>核心价值</strong>：解耦、可测试、可扩展。</p>
</li>
<li>
<p>C++ 实现关键：</p>
<ul>
<li>通过接口抽象依赖。</li>
<li>使用构造函数/智能指针传递依赖。</li>
<li>结合<strong>工厂模式</strong>或 IoC 容器管理复杂依赖关系。</li>
</ul>
</li>
</ul>
<h2 id="3-控制反转-ioc">3. 控制反转 IoC</h2>
<p><strong>IoC（Inversion of Control，控制反转）</strong> 是一种<strong>软件设计原则</strong>，其核心思想是<strong>将程序流程的控制权从开发者转移给框架或容器</strong>，以降低代码的耦合度，提高模块化和可维护性。它是实现依赖倒置原则（DIP）的关键机制，也是现代框架（如 Spring、.NET Core）和依赖注入（DI）容器的基础。</p>
<h3 id="31-控制反转-ioc-vs-依赖注入-di">3.1 控制反转 IoC vs. 依赖注入 DI</h3>
<ul>
<li><strong>IoC（控制反转）</strong>：广义的设计原则，表示控制权转移的范式。其本质是<strong>将程序流程的控制权从开发者转移到框架或容器</strong>。</li>
<li><strong>DI（依赖注入）</strong>：IoC 的一种具体实现技术，通过外部传递依赖。</li>
</ul>
<p><strong>关系</strong>：</p>
<ul>
<li>依赖注入是控制反转的实现方式之一。</li>
<li>控制反转还可以通过模板方法、回调（关联：好莱坞原则）等方式实现。</li>
<li>使用 IoC 容器（如 Boost.DI）自动管理复杂依赖关系。</li>
</ul>
<h2 id="4-工厂模式">4. 工厂模式</h2>
<p>尽管依赖倒置和依赖注入都强调面向抽象编程，但在实际编码中仍需创建（new）具体底层组件（ConcreteClass）</p>
<p>工厂模式主要分为三种，严格来说包括 <strong>简单工厂模式</strong>、<strong>工厂方法模式</strong> 和 <strong>抽象工厂模式</strong>。以下是它们的核心区别、适用场景及 C++ 示例：</p>
<h3 id="41-简单工厂模式simple-factory">4.1 简单工厂模式（Simple Factory）</h3>
<p>有时候简单工厂不被视为正式的设计模式，而是一个编程习惯。</p>
<h4 id="核心思想"><strong>核心思想</strong></h4>
<ul>
<li>通过一个工厂类，根据传入的<strong>参数</strong>决定创建哪种具体产品对象。</li>
<li><strong>不符合开闭原则</strong>（新增产品需修改工厂类逻辑）。</li>
</ul>
<h4 id="适用场景"><strong>适用场景</strong></h4>
<ul>
<li>产品类型较少且创建逻辑简单。</li>
<li>不需要频繁扩展新类型。</li>
</ul>
<h4 id="c-示例"><strong>C++ 示例</strong></h4>
<pre><code class="language-cpp">// 抽象产品
class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

// 具体产品
class Circle : public Shape {
public:
    void draw() override { std::cout &lt;&lt; "画一个圆形" &lt;&lt; std::endl; }
};

class Square : public Shape {
public:
    void draw() override { std::cout &lt;&lt; "画一个正方形" &lt;&lt; std::endl; }
};

// 简单工厂类
class ShapeFactory {
public:
    static Shape* createShape(const std::string&amp; type) {
        if (type == "circle") return new Circle();
        else if (type == "square") return new Square();
        else return nullptr;
    }
};

// 使用示例
int main() {
    Shape* circle = ShapeFactory::createShape("circle");
    circle-&gt;draw();  // 输出: 画一个圆形
    delete circle;
    return 0;
}
</code></pre>
<h3 id="42-工厂方法模式factory-method">4.2 工厂方法模式（Factory Method）</h3>
<h4 id="核心思想-1"><strong>核心思想</strong></h4>
<ul>
<li>定义一个创建对象的<strong>抽象方法</strong>，由子类决定实例化哪个类。</li>
<li><strong>符合开闭原则</strong>（新增产品只需新增子类工厂）。</li>
</ul>
<h4 id="适用场景-1"><strong>适用场景</strong></h4>
<ul>
<li>产品类型可能频繁扩展。</li>
<li>需要将对象创建延迟到子类。</li>
</ul>
<h4 id="c-示例-1"><strong>C++ 示例</strong></h4>
<pre><code class="language-cpp">// 抽象产品
class Database {
public:
    virtual void connect() = 0;
    virtual ~Database() = default;
};

// 具体产品
class MySQL : public Database {
public:
    void connect() override { std::cout &lt;&lt; "连接到 MySQL" &lt;&lt; std::endl; }
};

class PostgreSQL : public Database {
public:
    void connect() override { std::cout &lt;&lt; "连接到 PostgreSQL" &lt;&lt; std::endl; }
};

// 抽象工厂
class DatabaseFactory {
public:
    virtual Database* createDatabase() = 0;
    virtual ~DatabaseFactory() = default;
};

// 具体工厂
class MySQLFactory : public DatabaseFactory {
public:
    Database* createDatabase() override { return new MySQL(); }
};

class PostgreSQLFactory : public DatabaseFactory {
public:
    Database* createDatabase() override { return new PostgreSQL(); }
};

// 使用示例
int main() {
    DatabaseFactory* factory = new PostgreSQLFactory();
    Database* db = factory-&gt;createDatabase();
    db-&gt;connect();  // 输出: 连接到 PostgreSQL
    delete db;
    delete factory;
    return 0;
}
</code></pre>
<h3 id="43-抽象工厂模式abstract-factory">4.3 抽象工厂模式（Abstract Factory）</h3>
<h4 id="核心思想-2"><strong>核心思想</strong></h4>
<ul>
<li>提供一个接口，用于创建<strong>相关或依赖对象族</strong>，而无需指定具体类。</li>
<li>抽象工厂包含<strong>多个工厂方法</strong>，每个方法负责创建一个产品族中的对象。</li>
</ul>
<h4 id="适用场景-2"><strong>适用场景</strong></h4>
<ul>
<li>需要创建一组相关或依赖的对象（例如 GUI 组件：按钮、文本框、下拉菜单等）。</li>
<li>系统需要独立于产品的创建、组合和表示。</li>
</ul>
<h4 id="c-示例-2"><strong>C++ 示例</strong></h4>
<pre><code class="language-cpp">// 抽象产品：按钮
class Button {
public:
    virtual void render() = 0;
    virtual ~Button() = default;
};

// 具体产品：Windows 按钮
class WindowsButton : public Button {
public:
    void render() override { std::cout &lt;&lt; "Windows 风格按钮" &lt;&lt; std::endl; }
};

// 具体产品：MacOS 按钮
class MacOSButton : public Button {
public:
    void render() override { std::cout &lt;&lt; "MacOS 风格按钮" &lt;&lt; std::endl; }
};

// 抽象产品：文本框
class TextBox {
public:
    virtual void display() = 0;
    virtual ~TextBox() = default;
};

// 具体产品：Windows 文本框
class WindowsTextBox : public TextBox {
public:
    void display() override { std::cout &lt;&lt; "Windows 风格文本框" &lt;&lt; std::endl; }
};

// 具体产品：MacOS 文本框
class MacOSTextBox : public TextBox {
public:
    void display() override { std::cout &lt;&lt; "MacOS 风格文本框" &lt;&lt; std::endl; }
};

// 抽象工厂
class GUIFactory {
public:
    virtual Button* createButton() = 0;
    virtual TextBox* createTextBox() = 0;
    virtual ~GUIFactory() = default;
};

// 具体工厂：Windows 风格组件
class WindowsFactory : public GUIFactory {
public:
    Button* createButton() override { return new WindowsButton(); }
    TextBox* createTextBox() override { return new WindowsTextBox(); }
};

// 具体工厂：MacOS 风格组件
class MacOSFactory : public GUIFactory {
public:
    Button* createButton() override { return new MacOSButton(); }
    TextBox* createTextBox() override { return new MacOSTextBox(); }
};

// 使用示例
int main() {
    GUIFactory* factory = new MacOSFactory();

    Button* button = factory-&gt;createButton();
    button-&gt;render();  // 输出: MacOS 风格按钮

    TextBox* textBox = factory-&gt;createTextBox();
    textBox-&gt;display(); // 输出: MacOS 风格文本框

    delete button;
    delete textBox;
    delete factory;
    return 0;
}
</code></pre>
<h3 id="44-三种工厂模式对比">4.4 三种工厂模式对比</h3>
<table>
<thead>
<tr>
<th style="text-align: center">模式</th>
<th style="text-align: center">核心目标</th>
<th style="text-align: center">扩展性</th>
<th style="text-align: center">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><strong>简单工厂</strong></td>
<td style="text-align: center">集中创建单一类型的不同对象</td>
<td style="text-align: center">差（需修改工厂类）</td>
<td style="text-align: center">少量固定类型，无需频繁扩展</td>
</tr>
<tr>
<td style="text-align: center"><strong>工厂方法</strong></td>
<td style="text-align: center">将对象创建延迟到子类</td>
<td style="text-align: center">好（新增工厂子类）</td>
<td style="text-align: center">单一产品，类型可能频繁扩展</td>
</tr>
<tr>
<td style="text-align: center"><strong>抽象工厂</strong></td>
<td style="text-align: center">创建多个相关或依赖的对象族</td>
<td style="text-align: center">好（新增工厂子类）</td>
<td style="text-align: center">多个关联产品，需保持风格一致性</td>
</tr>
</tbody>
</table>
<h3 id="45-工厂模式小结">4.5 工厂模式小结</h3>
<ul>
<li><strong>简单工厂</strong>：适合简单场景，但违背开闭原则。</li>
<li><strong>工厂方法</strong>：解决单一产品的扩展问题。</li>
<li><strong>抽象工厂</strong>：解决多产品族的创建问题，强调产品之间的关联性。</li>
</ul>
<p>根据需求选择合适模式：若产品单一且可能扩展，用工厂方法；若需创建一组关联对象，用抽象工厂；若产品类型固定且简单，用简单工厂。</p>
<h2 id="5-总结">5. 总结</h2>
<p>依赖倒置（DIP）、依赖注入（DI）、控制反转（IoC）和工厂模式是软件设计中紧密相关的概念，它们共同服务于代码的解耦和可维护性。</p>
<h3 id="51-关联">5.1 关联</h3>
<ul>
<li>
<p>依赖倒置原则（Dependency Inversion Principle, DIP）：高层模块不依赖低层模块，两者都依赖抽象（接口或抽象类）。该思想指导工厂模式、DI 和 IoC 的设计方向。</p>
</li>
<li>
<p>控制反转（Inversion of Control, IoC）：将对象的创建和生命周期管理权从程序内部转移给外部容器（如框架）。例如：依赖由外部容器（如工厂或框架）创建并注入，而不是直接创建依赖。工厂模式和依赖注入 DI 是实现 IoC 的具体方式。</p>
</li>
<li>
<p>依赖注入（Dependency Injection, DI）：通过构造函数、Setter 或接口，将依赖对象<strong>被动传递</strong>给使用方。是实现 IoC 的具体技术手段。工厂模式常用于生成这些依赖对象。</p>
</li>
<li>
<p>工厂模式（Factory Pattern）：封装具体对象创建逻辑，通过工厂类统一创建对象。是实现 IoC 的手段之一，隐藏实例化细节，支持 DIP 和 DI。是依赖注入 DI 和控制反转 IoC 的底层支撑。</p>
</li>
</ul>
<p>四者共同目标是<strong>解耦代码</strong>，提升扩展性和可维护性。</p>
<h3 id="52-示例全链路">5.2 示例全链路</h3>
<pre><code class="language-cpp">// 1. 遵循 DIP：定义抽象接口
class IStorage { /* ... */ };

// 2. 具体实现
class DatabaseStorage : public IStorage { /* ... */ };

// 3. 工厂模式：封装对象创建
class StorageFactory {
public:
    static IStorage* createStorage() { return new DatabaseStorage(); }
};

// 4. 依赖注入：通过构造函数传递对象
class UserService {
private:
    IStorage* storage;
public:
    UserService(IStorage* storage) : storage(storage) {}
};

// 5. 控制反转：由工厂创建依赖，而非 UserService 内部创建
int main() {
    IStorage* storage = StorageFactory::createStorage();
    UserService userService(storage); // DI 注入
    userService.saveUser();
    delete storage;
    return 0;
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <br>
本文作者：Zijian/TENG（微信公众号：好记性如烂笔头），转载请注明原文链接：<a href="https://www.cnblogs.com/tengzijian/p/18775674" target="_blank">https://www.cnblogs.com/tengzijian/p/18775674</a>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7923798302430556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-16 21:21">2025-03-16 21:20</span>&nbsp;
<a href="https://www.cnblogs.com/tengzijian">Zijian/TENG</a>&nbsp;
阅读(<span id="post_view_count">61</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18775674" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18775674);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18775674', targetLink: 'https://www.cnblogs.com/tengzijian/p/18775674', title: '依赖倒置 DIP、依赖注入 DI、控制反转 IoC 和工厂模式' })">举报</a>
</div>
        