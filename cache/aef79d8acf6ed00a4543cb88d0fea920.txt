
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18742618" title="发布于 2025-02-28 11:40">
    <span role="heading" aria-level="2">Log4j2 中三种常见 File 类 Appender 对比与选择</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.017538170619212964" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 11:54">2025-02-28 11:40</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18742618" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18742618);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18742618', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18742618', title: 'Log4j2 中三种常见 File 类 Appender 对比与选择' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 Log4j2 中，若不考虑 Rolling（支持滚动和压缩）类文件 Appender，则包含以下三种文件 Appender：FileAppender、RandomAccessFileAppender 和 MemoryMappedFileAppender。接下来将介绍这三种 Appender 的功能、优缺点以及在实际研发中应如何选择与使用。</p>
<h2 id="一三种-appender-简介">一、三种 Appender 简介</h2>
<h3 id="1-fileappender">1. FileAppender</h3>
<p>FileAppender 是 Log4j2 中最基础的文件 Appender，它基于传统的 java.io.FileOutputStream 将日志写入文件，简单可靠。</p>
<h3 id="2-randomaccessfileappender">2. RandomAccessFileAppender</h3>
<p>RandomAccessFileAppender 基于 ByteBuffer 和 RandomAccessFile 实现，与标准的 FileAppender 类似，不过它始终使用由 bufferSize 参数指定大小的内存缓冲区。从官方文件介绍来看，与使用默认配置的 FileAppender 相比，性能可提高 20% 至 200%。然而，由于使用了内存缓冲区，增加了内存开销，同时也提高了日志丢失的风险，若程序崩溃，缓冲区中的日志将会丢失。</p>
<h3 id="3-memorymappedfileappender">3. MemoryMappedFileAppender</h3>
<p>MemoryMappedFileAppender 基于内存映射文件（Memory-Mapped File）实现，文件直接映射到内存中，将日志直接写入这块内存，并依赖操作系统的虚拟内存管理器持久化到存储设备，使得能够在不经过操作系统缓存的情况下直接将日志写入磁盘，减少了 I/O 开销，进而性能有明显提升。然而，该 Appender 内存占用较多，且依赖于底层操作系统和硬件支持，若程序崩溃，未持久化的日志可能丢失。</p>
<p>默认内存映射区域大小为 32M，可通过“regionLength”参数进行调整；该 Appender 无对应的 Rolling 类，无法支持日志滚动切换和备份。</p>
<h2 id="二功能对比">二、功能对比</h2>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>FileAppender</strong></th>
<th><strong>RandomAccessFileAppender</strong></th>
<th><strong>MemoryMappedFileAppender</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>底层实现</td>
<td><code>java.io.FileOutputStream</code></td>
<td><code>java.io.RandomAccessFile</code></td>
<td>内存映射文件（Memory-Mapped File）</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>较高（缓冲区未刷新时）</td>
<td>略低（内存映射未刷新时）</td>
</tr>
<tr>
<td>性能</td>
<td>略低</td>
<td>略高</td>
<td>高</td>
</tr>
<tr>
<td>平台兼容性</td>
<td>高</td>
<td>高</td>
<td>略低，依赖操作系统和硬件支持</td>
</tr>
<tr>
<td>内存占用</td>
<td>较低</td>
<td>中等</td>
<td>较高</td>
</tr>
<tr>
<td>无 GC（Garbage-free）模式</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>文件 Rolling</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>日志输出顺序性</td>
<td>有序</td>
<td>有序</td>
<td>有序</td>
</tr>
</tbody>
</table>
<h2 id="三同步性能对比">三、同步性能对比</h2>
<h3 id="1-基准环境">1. 基准环境</h3>
<p>（1）硬件：Windows 笔记本，配置为 I5-1350P CPU、32G DDR5 5200 内存以及三星 MZVL4512HBLU-00BLL 512G SSD（顺序写入速度为 2430MB/s）。</p>
<p>（2）软件：基于 JDK 1.8.171，使用 1.37 版 JMH 和 2.24.3 版 Log4j2。</p>
<p>（3）配置：三种 Appender 均采用默认配置（append 和 immediateFlush 都为 true），使用同步 Logger 进行压测。</p>
<p>（4）参考实际使用情况，输出长度为 100 个的固定字符串，同时，有 20% 的概率输出包含 100 层堆栈的异常，日志布局为：<code>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %pid %t %C.%M:%L - %msg %ex{full} %n</code>。</p>
<p>（5）压测三次，取结果平均值。</p>
<h3 id="2-配置文件">2. 配置文件</h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration name="log4j2AppenderTest" status="error"&gt;
	&lt;Properties&gt;
		&lt;Property name="log.pattern"&gt;
			%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %pid %t %C.%M:%L - %msg %ex{full} %n
		&lt;/Property&gt;
	&lt;/Properties&gt;

	&lt;Appenders&gt;
		&lt;Console name="Console"&gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/Console&gt;
		&lt;File name="File"
			fileName="target/test-output/log4j2-file.log"&gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/File&gt;
		&lt;RandomAccessFile name="RandomAccessFile"
						  fileName="target/test-output/log4j2-random-access-file.log" &gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/RandomAccessFile&gt;
		&lt;MemoryMappedFile name="MemoryMappedFile"
						  fileName="target/test-output/log4j2-memory-mapped-file.log" &gt;
			&lt;PatternLayout pattern="${log.pattern}"/&gt;
		&lt;/MemoryMappedFile&gt;
	&lt;/Appenders&gt;

	&lt;Loggers&gt;
		&lt;Root level="debug"&gt;
			&lt;AppenderRef ref="Console" /&gt;
		&lt;/Root&gt;
		&lt;Logger name="FileLogger" level="debug" additivity="false"&gt;
			&lt;AppenderRef ref="File" /&gt;
		&lt;/Logger&gt;
		&lt;Logger name="RandomAccessFileLogger" level="debug" additivity="false"&gt;
			&lt;AppenderRef ref="RandomAccessFile" /&gt;
		&lt;/Logger&gt;
		&lt;Logger name="MemoryMappedFileLogger" level="debug" additivity="false"&gt;
			&lt;AppenderRef ref="MemoryMappedFile" /&gt;
		&lt;/Logger&gt;
	&lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="3-压测代码">3. 压测代码</h3>
<pre><code class="language-java">@State(Scope.Benchmark)
public class Log4J2FileAppenderBenchmark {

    static Logger fileLogger;
    static Logger randomAccessLogger;
    static Logger memoryMappedLogger;
    static final Random RANDOM= new Random();
    static final double OUTPUT_EXCEPTION_PROBABILITY = 0.2;

    @Setup(Level.Trial)
    public void setUp() throws Exception {
        System.setProperty("log4j.configurationFile", "log4j2-appender.xml");
        fileLogger = LogManager.getLogger("FileLogger");
        randomAccessLogger = LogManager.getLogger("RandomAccessFileLogger");
        memoryMappedLogger = LogManager.getLogger("MemoryMappedFileLogger");
    }

    @TearDown
    public void tearDown() {
        System.clearProperty("log4j.configurationFile");
    }

		public void outputLog(Logger logger){
        if (RANDOM.nextDouble() &lt; OUTPUT_EXCEPTION_PROBABILITY) {
            logger.debug(Const.MSG_HAVE_100_CHARS, Const.THROWABLE_HAVE_100_STACK);
        } else {
            logger.debug(Const.MSG_HAVE_100_CHARS);
        }
    }

    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    @Benchmark
    public void syncFileLogger() {
        outputLog(fileLogger);
    }

    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    @Benchmark
    public void syncRandomAccessLogger() {
        outputLog(randomAccessLogger);
    }

    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    @Benchmark
    public void syncMemoryMappedAppendLogger() {
        outputLog(memoryMappedLogger);
    }
}
</code></pre>
<h3 id="4-jmh-参数">4. JMH 参数</h3>
<p>JMH 执行的参数为：<code>-jvmArgs "-Xmx2g -Xms2g" -f 2 -t 4 -w 10 -wi 2 -r 30 -i 2 -to 300 -prof gc -rf json</code>，即设置 JVM 参数为 -Xmx2g -Xms2g（堆内存最大和最小均为 2GB），使用 2 个 fork（-f 2），每个 fork 使用 4 个线程（-t 4），预热阶段每次运行 10 秒（-w 10），预热迭代 2 次（-wi 2），正式测试每次运行 30 秒（-r 30），正式测试迭代 2 次（-i 2），超时时间为 300 秒（-to 300），启用 GC 性能分析（-prof gc），并将测试结果输出为 JSON 格式（-rf json）。</p>
<h3 id="5-压测结果">5. 压测结果</h3>
<table>
<thead>
<tr>
<th><strong>Appender 类型</strong></th>
<th><strong>平均吞吐量</strong></th>
<th><strong>内存分配速率（MB/sec）</strong></th>
<th><strong>垃圾回收次数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>FileAppender</td>
<td>42.5 ops/ms</td>
<td>1328.1 MB/sec</td>
<td>235</td>
</tr>
<tr>
<td>RandomAccessFileAppender</td>
<td>46.6 ops/ms</td>
<td>1498.4 MB/sec</td>
<td>266</td>
</tr>
<tr>
<td>MemoryMappedFileAppender</td>
<td>90.9 ops/ms</td>
<td>3162.5 MB/sec</td>
<td>561</td>
</tr>
</tbody>
</table>
<h3 id="6-压测结论">6. 压测结论</h3>
<p>基于上述基准环境及压测结果，可得出结论：</p>
<p>（1）MemoryMappedFileAppender 性能比 RandomAccessFileAppender 和 FileAppender 高约一倍。</p>
<p>（2）RandomAccessFileAppender 性能稍优于 FileAppender，吞吐量高 8.8%。</p>
<p>此外，从其余 CASE 的压测来看：</p>
<p>（1）日志字段越少、单条日志体积越小，MemoryMappedFileAppender 性能优势越明显，最多可高于 FileAppender 10 倍。</p>
<p>（2）在相同基准环境下，增加压测线程数，三类 Appender 性能均有所提升，RandomAccessFileAppender 和 MemoryMappedFileAppender 提升更为显著。将压测线程增加到 64 时，FileAppender、RandomAccessFileAppender 和 MemoryMappedFileAppender 吞吐量分别为 46.6、56.3 和 138.4 ops/ms，FileAppender 略有提升，相比之下，RandomAccessFileAppender 和 MemoryMappedFileAppender 领先 FileAppender 的优势分别扩大 20.8% 和 197%。</p>
<p>（3）使用 JDK21 对 MemoryMappedFileAppender 进行压测时，会抛出 IllegalAccessException 异常。原因是：自 Java9 起引入了模块系统（JPMS），限制了外部模块访问内部 API 的能力。解决方法：在运行时为 JVM 添加参数<code>--add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED</code>。</p>
<p>（4）在相同基准环境下，发现使用 JDK21 压测，三种 Appender 的性能均有较大幅度下降，原因不明，已向社区<a href="https://github.com/apache/logging-log4j2/issues/3393" target="_blank" rel="noopener nofollow">反馈</a>。</p>
<h2 id="五使用建议">五、使用建议</h2>
<h3 id="1-如何选择">1. 如何选择</h3>
<p>（1）常规情况下，推荐优先使用 FileAppender。其性能良好，每毫秒可达 42.5ops（实际生产环境中部署服务器大部分使用 HD 硬盘，其 IO 性能远不如 SSD，因此吞吐量可能会下降），能满足绝大部分业务需求，且简单可靠，支持 Rolling（文件切分、滚动和备份）；RandomAccessFileAppender 性能仅比 FileAppender 略高，但存在丢失日志的风险，不太推荐使用；实际使用中，如果采用 FileAppender 或 RandomAccessFileAppender，建议使用其 Rolling 类，即 RollingFileAppender 和 RollingRandomAccessFileAppender，以满足文件切分、轮转和压缩等必备需求。</p>
<p>（2）若对性能要求较高，且能接受可能发生的较多日志丢失，与其考虑采用 MemoryMappedFileAppender，不如考虑使用异步日志（AsyncLogger）加消息队列 Appender 的组合方式，后者性能更好，且内存占用小，与系统平台耦合低。</p>
<p>（3）从压测结果来看，不同配置参数和使用环境，性能会存在一定波动。【特别建议】：根据业务实际使用场景、功能需求以及日志配置等情况，提前做好性能测试与分析，以便选择合适的 Appender。</p>
<h3 id="2-配置建议">2. 配置建议</h3>
<p>实际生产环境中，【禁止】将 append 和 immediateFlush 参数设置为 false。因为前者会使原日志被覆盖，后者可能导致无法查看实时日志以及日志丢失。</p>
<h2 id="六参考文章">六、参考文章</h2>
<p>（1）<a href="https://logging.apache.org/log4j/2.x/index.html" target="_blank" rel="noopener nofollow">log4j2.x</a></p>
<p>（2）<a href="https://logging.apache.org/log4j/2.12.x/" target="_blank" rel="noopener nofollow">log4j2 2.12.x</a></p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18742618"></vc:categories-tags>
    </ul>
