
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18978925" title="发布于 2025-07-16 14:03">
    <span role="heading" aria-level="2">【Java并发工具三剑客】CountDownLatch、CyclicBarrier和Semaphore详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在Java并发编程中，<code>java.util.concurrent</code>包提供了强大的工具类来简化线程间的协调工作。本文将深入探讨三个核心工具：<strong>CountDownLatch</strong>、<strong>CyclicBarrier</strong>和<strong>Semaphore</strong>，分析它们的原理、应用场景和关键区别，并提供实用的代码示例。</p>
<h2 id="一核心工具详解">一、核心工具详解</h2>
<h3 id="1-countdownlatch倒计时闩锁">1. CountDownLatch（倒计时闩锁）</h3>
<p><strong>原理</strong>：基于计数器实现，初始值代表需要等待的事件数。工作线程完成任务后调用<code>countDown()</code>减少计数，主线程通过<code>await()</code>阻塞等待计数器归零。</p>
<p><strong>典型应用场景</strong>：</p>
<ul>
<li>主线程等待所有子任务完成</li>
<li>服务启动等待依赖资源初始化</li>
<li>并行计算任务同步</li>
</ul>
<pre><code class="language-java">import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        int workerCount = 3;
        CountDownLatch latch = new CountDownLatch(workerCount);
        
        for (int i = 0; i &lt; workerCount; i++) {
            new Thread(() -&gt; {
                System.out.println("工作者" + Thread.currentThread().getId() + "初始化完成");
                latch.countDown();  // 计数器减1
            }).start();
        }
        
        System.out.println("主线程等待初始化...");
        latch.await();  // 阻塞直到计数器归零
        System.out.println("所有工作者初始化完成，主线程继续");
    }
}
/* 输出：
   主线程等待初始化...
   工作者14初始化完成
   工作者13初始化完成
   工作者15初始化完成
   所有工作者初始化完成，主线程继续 */
</code></pre>
<h3 id="2-cyclicbarrier循环屏障">2. CyclicBarrier（循环屏障）</h3>
<p><strong>原理</strong>：让一组线程在屏障点相互等待，当所有线程都到达后执行预设操作并重置屏障，可循环使用。</p>
<p><strong>典型应用场景</strong>：</p>
<ul>
<li>多阶段数据处理（加载→处理→存储）</li>
<li>并行计算的分步同步</li>
<li>多线程测试的并发起点控制</li>
</ul>
<pre><code class="language-java">import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        int threadCount = 3;
        Runnable barrierAction = () -&gt; System.out.println("--- 所有线程到达屏障 ---");
        
        CyclicBarrier barrier = new CyclicBarrier(threadCount, barrierAction);
        
        for (int i = 0; i &lt; threadCount; i++) {
            new Thread(() -&gt; {
                try {
                    System.out.println(Thread.currentThread().getName() + " 加载阶段1数据");
                    barrier.await();  // 第一次等待
                    
                    System.out.println(Thread.currentThread().getName() + " 处理阶段1数据");
                    barrier.await();  // 第二次等待（屏障重用）
                    
                    System.out.println(Thread.currentThread().getName() + " 加载阶段2数据");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, "Worker-"+i).start();
        }
    }
}
/* 输出：
   Worker-0 加载阶段1数据
   Worker-1 加载阶段1数据
   Worker-2 加载阶段1数据
   --- 所有线程到达屏障 ---
   Worker-2 处理阶段1数据
   Worker-0 处理阶段1数据
   Worker-1 处理阶段1数据
   --- 所有线程到达屏障 ---
   Worker-1 加载阶段2数据
   Worker-2 加载阶段2数据
   Worker-0 加载阶段2数据 */
</code></pre>
<h3 id="3-semaphore信号量">3. Semaphore（信号量）</h3>
<p><strong>原理</strong>：维护一组许可证，控制资源访问并发数。线程通过<code>acquire()</code>获取许可，<code>release()</code>释放许可。</p>
<p><strong>典型应用场景</strong>：</p>
<ul>
<li>数据库连接池管理</li>
<li>API限流控制</li>
<li>资源池实现（如线程池）</li>
</ul>
<pre><code class="language-java">import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    public static void main(String[] args) {
        int maxConnections = 3;
        Semaphore semaphore = new Semaphore(maxConnections);
        
        for (int i = 1; i &lt;= 5; i++) {
            new Thread(() -&gt; {
                String threadName = Thread.currentThread().getName();
                try {
                    System.out.println(threadName + " 尝试获取连接");
                    semaphore.acquire();  // 获取许可
                    
                    System.out.println(threadName + " 获取连接成功 | 剩余许可: " 
                                        + semaphore.availablePermits());
                    Thread.sleep(2000);  // 模拟数据库操作
                    
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();  // 释放许可
                    System.out.println(threadName + " 释放连接");
                }
            }, "Thread-"+i).start();
        }
    }
}
/* 输出：
   Thread-1 尝试获取连接
   Thread-2 尝试获取连接
   Thread-3 尝试获取连接
   Thread-4 尝试获取连接
   Thread-5 尝试获取连接
   Thread-1 获取连接成功 | 剩余许可: 2
   Thread-2 获取连接成功 | 剩余许可: 1
   Thread-3 获取连接成功 | 剩余许可: 0
   （等待2秒...）
   Thread-1 释放连接
   Thread-4 获取连接成功 | 剩余许可: 0
   Thread-2 释放连接
   Thread-5 获取连接成功 | 剩余许可: 0 */
</code></pre>
<h2 id="二核心区别对比">二、核心区别对比</h2>
<table>
<thead>
<tr>
<th style="text-align: left">特性</th>
<th style="text-align: left">CountDownLatch</th>
<th style="text-align: left">CyclicBarrier</th>
<th style="text-align: left">Semaphore</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>核心目的</strong></td>
<td style="text-align: left"><strong>等待事件完成</strong></td>
<td style="text-align: left"><strong>线程组在屏障点相互等待</strong></td>
<td style="text-align: left"><strong>控制并发访问资源的数量</strong></td>
</tr>
<tr>
<td style="text-align: left"><strong>计数器</strong></td>
<td style="text-align: left">递减 (countDown), <strong>一次性</strong></td>
<td style="text-align: left">递增 (await)，<strong>可重置循环使用</strong></td>
<td style="text-align: left">可增减 (acquire/release), <strong>可重用</strong></td>
</tr>
<tr>
<td style="text-align: left"><strong>重置能力</strong></td>
<td style="text-align: left">❌ 不可重置</td>
<td style="text-align: left">✅ 可循环使用</td>
<td style="text-align: left">✅ 持续管理许可</td>
</tr>
<tr>
<td style="text-align: left"><strong>触发条件</strong></td>
<td style="text-align: left">计数器减到 <strong>0</strong></td>
<td style="text-align: left">等待线程数达到 <strong>预设值</strong></td>
<td style="text-align: left">有可用许可</td>
</tr>
<tr>
<td style="text-align: left"><strong>线程角色</strong></td>
<td style="text-align: left">主线程(等待) vs 工作线程(做事)</td>
<td style="text-align: left"><strong>所有线程角色对等</strong></td>
<td style="text-align: left">线程角色无特定关系</td>
</tr>
<tr>
<td style="text-align: left"><strong>屏障动作</strong></td>
<td style="text-align: left">❌ 不支持</td>
<td style="text-align: left">✅ 支持 (可选Runnable)</td>
<td style="text-align: left">❌ 不支持</td>
</tr>
<tr>
<td style="text-align: left"><strong>典型比喻</strong></td>
<td style="text-align: left">起跑线裁判等待运动员就位</td>
<td style="text-align: left">旅游团在景点集合点等待团员</td>
<td style="text-align: left">停车场入口闸机控制车辆进入</td>
</tr>
</tbody>
</table>
<h2 id="三关键区别解析">三、关键区别解析</h2>
<ol>
<li>
<p><strong>一次性 vs 循环性</strong>：</p>
<ul>
<li><code>CountDownLatch</code>是<strong>一次性</strong>的，计数器归零后即失效</li>
<li><code>CyclicBarrier</code><strong>可循环使用</strong>，自动重置计数器</li>
<li><code>Semaphore</code><strong>持续管理</strong>许可证，无使用次数限制</li>
</ul>
</li>
<li>
<p><strong>等待模式</strong>：</p>
<ul>
<li><code>CountDownLatch</code>：<strong>单向等待</strong>（主线程等子线程）</li>
<li><code>CyclicBarrier</code>：<strong>多向等待</strong>（所有线程相互等待）</li>
<li><code>Semaphore</code>：<strong>资源竞争</strong>（线程间无直接协调）</li>
</ul>
</li>
<li>
<p><strong>计数器行为</strong>：</p>
<ul>
<li><code>CountDownLatch</code>：只减不增（<code>countDown()</code>）</li>
<li><code>CyclicBarrier</code>：内部计数增加到目标值后重置</li>
<li><code>Semaphore</code>：可增可减（<code>acquire()</code>减，<code>release()</code>增）</li>
</ul>
</li>
</ol>
<h2 id="四如何选择合适工具">四、如何选择合适工具</h2>
<p>根据实际场景需求选择最合适的工具：</p>
<ul>
<li>
<p>需要 <strong>主线程等待多个子任务完成</strong> → 选择 <strong><code>CountDownLatch</code></strong></p>
<pre><code class="language-java">// 微服务启动等待依赖初始化
CountDownLatch serviceLatch = new CountDownLatch(3);
databaseInit(serviceLatch);
cacheInit(serviceLatch);
configLoad(serviceLatch);
serviceLatch.await(); // 等待所有依赖就绪
startService();
</code></pre>
</li>
<li>
<p>需要 <strong>多线程分阶段同步执行</strong> → 选择 <strong><code>CyclicBarrier</code></strong></p>
<pre><code class="language-java">// 并行计算分阶段处理
CyclicBarrier computeBarrier = new CyclicBarrier(4, () -&gt; 
    System.out.println("阶段完成，交换中间结果"));
</code></pre>
</li>
<li>
<p>需要 <strong>限制资源并发访问量</strong> → 选择 <strong><code>Semaphore</code></strong></p>
<pre><code class="language-java">// API限流（每秒最多100请求）
Semaphore rateLimiter = new Semaphore(100);
executor.submit(() -&gt; {
    rateLimiter.acquire();
    callExternalAPI();
    rateLimiter.release();
});
</code></pre>
</li>
</ul>
<h2 id="五总结">五、总结</h2>
<p>Java并发工具三剑客各有其适用场景：</p>
<ul>
<li><strong>CountDownLatch</strong> 是<strong>任务协调器</strong>，解决"主等子"的同步问题</li>
<li><strong>CyclicBarrier</strong> 是<strong>线程同步器</strong>，解决"线程组多阶段协同"问题</li>
<li><strong>Semaphore</strong> 是<strong>资源控制器</strong>，解决"并发访问量限制"问题</li>
</ul>
<p>理解它们的核心区别和适用场景，能够帮助我们在复杂并发场景中选择最合适的工具，构建高效可靠的并发系统。在实际开发中，根据具体需求灵活选用这些工具，可以显著提升程序的并发性能和可维护性。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 14:03">2025-07-16 14:03</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18978925);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18978925', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18978925', title: '【Java并发工具三剑客】CountDownLatch、CyclicBarrier和Semaphore详解' })">举报</a>
</div>
        