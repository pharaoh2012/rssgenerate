
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/eanojiang/p/19051898" title="发布于 2025-08-22 05:42">
    <span role="heading" aria-level="2">仿神秘海域/美末环境交互的程序化动画学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        顽皮狗天下第一
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><strong>写在前面：</strong></p>
<p>真正实现这些细枝末节的东西的时候才能感受到这种技术力的恐怖。</p>
<p>——致敬顽皮狗工作室</p>
</blockquote>
<h2 id="插件安装">插件安装</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053813019-2039736898.png" alt="1755773270538" loading="lazy"></p>
<h2 id="为角色添加组件">为角色添加组件</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053813713-611246744.png" alt="1755773337095" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053814338-1463063657.png" alt="1755773371949" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053814717-372422136.png" alt="1755773411325" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053815055-1522603149.png" alt="1755773431970" loading="lazy"></p>
<p>右手同理</p>
<h2 id="状态机脚本编写">状态机脚本编写</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053815798-1629959597.png" alt="1755775744433" loading="lazy"></p>
<p>BaseState.cs</p>
<pre><code class="language-csharp">using UnityEngine;
using System;

/// &lt;summary&gt;
/// 状态基类，定义了状态机中所有状态的基本行为规范
/// 泛型参数EEState限制为枚举类型，用于表示具体的状态类型
/// &lt;/summary&gt;
/// &lt;typeparam name="EState"&gt;状态枚举类型，继承自Enum&lt;/typeparam&gt;
public abstract class BaseState&lt;EState&gt; where EState : Enum
{
    //构造函数
    public BaseState(EState key)
    {
        StateKey = key;
    }
    public EState StateKey { get; private set; }

    public abstract void EnterState();
    public abstract void ExitState();
    public abstract void UpdateState();
    public abstract EState GetNextState();
    public abstract void OnTriggerEnter(Collider other);
    public abstract void OnTriggerStay(Collider other);
    public abstract void OnTriggerExit(Collider other);
}
</code></pre>
<p>NewBaseState.cs</p>
<pre><code class="language-csharp">using UnityEngine;
using System;
using System.Collections.Generic;

/// &lt;summary&gt;
/// 状态管理器泛型抽象类
/// &lt;/summary&gt;
/// &lt;typeparam name="EState"&gt;状态枚举类型，需继承自Enum&lt;/typeparam&gt;
public abstract class StateManager&lt;EState&gt; : MonoBehaviour where EState : Enum
{
    // 存储所有状态的字典，键为状态枚举，值为对应的状态实例
    protected Dictionary&lt;EState, BaseState&lt;EState&gt;&gt; States = new Dictionary&lt;EState, BaseState&lt;EState&gt;&gt;();
    // 当前激活的状态
    protected BaseState&lt;EState&gt; CurrentState;

    // 标志位：是否处于状态切换中
    protected bool IsTransitioningState = false;

    void Start()
    {
        CurrentState.EnterState();
    }

    void Update()
    {
        EState nextStateKey = CurrentState.GetNextState();

        if (!IsTransitioningState &amp;&amp; nextStateKey.Equals(CurrentState.StateKey))
        {
            // 如果当前状态和下一状态相同，则更新当前状态
            CurrentState.UpdateState();
        }
        else if(!IsTransitioningState)
        {
            // 不同，则切换到下一状态
            TransitionToState(nextStateKey);
        }
    }

    /// &lt;summary&gt;
    /// 状态切换方法，用于从当前状态切换到目标状态
    /// &lt;/summary&gt;
    /// &lt;param name="stateKey"&gt;目标状态的枚举标识&lt;/param&gt;
    protected virtual void TransitionToState(EState stateKey)
    {
        IsTransitioningState = true;

        // 退出当前状态
        CurrentState.ExitState();
        // 进入目标状态
        CurrentState = States[stateKey];
        CurrentState.EnterState();

        IsTransitioningState = false;
    }

    /// &lt;summary&gt;
    /// 当碰撞体进入触发器时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;进入触发器的碰撞体&lt;/param&gt;
    void OnTriggerEnter(Collider other)
    {
        CurrentState.OnTriggerEnter(other);
    }

    /// &lt;summary&gt;
    /// 当碰撞体持续处于触发器中时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;处于触发器中的碰撞体&lt;/param&gt;
    void OnTriggerStay(Collider other)
    {
        CurrentState.OnTriggerStay(other);
    }

    /// &lt;summary&gt;
    /// 当碰撞体退出触发器时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;退出触发器的碰撞体&lt;/param&gt;
    void OnTriggerExit(Collider other)
    {
        CurrentState.OnTriggerExit(other);
    }
}
</code></pre>
<h2 id="animation-rigging">Animation Rigging</h2>
<blockquote>
<p>Rig Builder组件要放在Animator的同级</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816105-338026225.png" alt="1755784900189" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816415-2142758309.png" alt="1755784962449" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816722-1091885840.png" alt="1755785011835" loading="lazy"></p>
<p>Rig放置的位置</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817119-890067986.png" alt="1755784884750" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817362-993366441.png" alt="1755785030047" loading="lazy"></p>
<h2 id="环境交互状态机的编写">环境交互状态机的编写</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817586-1564131573.png" alt="1755785081711" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053818473-1938481811.png" alt="1755789073630" loading="lazy"></p>
<p>EnvironmentInteractionStateMachine</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Animations.Rigging;
using UnityEngine.Assertions;   //调试用


public class EnvironmentInteractionStateMachine : StateManager&lt;EnvironmentInteractionStateMachine.EEnvironmentInteractionState&gt;
{
    // 环境交互状态
    public enum EEnvironmentInteractionState
    {
        Search,   // 搜索状态
        Approach, // 接近状态
        Rise,     // 起身状态
        Touch,    // 触碰状态
        Reset     // 重置状态
    }

    private EnvironmentInteractionContext _context;

    // 约束、组件等引用
    [SerializeField] private TwoBoneIKConstraint _leftIkConstraint;
    [SerializeField] private TwoBoneIKConstraint _rightIkConstraint;
    [SerializeField] private MultiRotationConstraint _leftMultiRotationConstraint;
    [SerializeField] private MultiRotationConstraint _rightMultiRotationConstraint;
    [SerializeField] private CharacterController characterController;

    void Awake()
    {
        ValidateConstraints();

        _context = new EnvironmentInteractionContext(_leftIkConstraint, _rightIkConstraint, _leftMultiRotationConstraint, _rightMultiRotationConstraint, characterController);
    }

    // 校验各类约束、组件是否正确赋值
    private void ValidateConstraints()
    {
        Assert.IsNotNull(_leftIkConstraint, "Left IK constraint 没有赋值");
        Assert.IsNotNull(_rightIkConstraint, "Right IK constraint 没有赋值");
        Assert.IsNotNull(_leftMultiRotationConstraint, "Left multi-rotation constraint 没有赋值");
        Assert.IsNotNull(_rightMultiRotationConstraint, "Right multi-rotation constraint 没有赋值");
        Assert.IsNotNull(characterController, "characterController used to control character 没有赋值");
    }


}
</code></pre>
<p>EnvironmentInteractionContext用来管理各种属性</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Animations.Rigging;

public class EnvironmentInteractionContext
{
    private TwoBoneIKConstraint _leftIkConstraint;
    private TwoBoneIKConstraint _rightIkConstraint;
    private MultiRotationConstraint _leftMultiRotationConstraint;
    private MultiRotationConstraint _rightMultiRotationConstraint;
    private CharacterController _characterController;

    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
    }

    // 外部可以访问的属性
    public TwoBoneIKConstraint LeftIkConstraint =&gt; _leftIkConstraint;
    public TwoBoneIKConstraint RightIkConstraint =&gt; _rightIkConstraint;
    public MultiRotationConstraint LeftMultiRotationConstraint =&gt; _leftMultiRotationConstraint;
    public MultiRotationConstraint RightMultiRotationConstraint =&gt; _rightMultiRotationConstraint;
    public CharacterController CharacterController =&gt; _characterController;
}
</code></pre>
<p>从ResetState开始</p>
<pre><code class="language-csharp">using UnityEngine;

public class ResetState : EnvironmentInteractionState
{
    // 构造函数
    public ResetState(EnvironmentInteractionContext context, EnvironmentInteractionStateMachine.EEnvironmentInteractionState estate) : base(context, estate)
    {
        EnvironmentInteractionContext Context = context;
    }
    public override void EnterState(){}
    public override void ExitState() { }
    public override void UpdateState() { }
    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState() 
    { 
        return StateKey; 
    }
    public override void OnTriggerEnter(Collider other) { }
    public override void OnTriggerStay(Collider other) { }
    public override void OnTriggerExit(Collider other) { }
}
</code></pre>
<p>EnvironmentInteractionStateMachine中加入初始化函数</p>
<pre><code class="language-csharp">    void Awake()
    {
	//原来的代码

        InitalizeStates();
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 初始化状态机
    /// &lt;/summary&gt;
    private void InitalizeStates()
    {
        //添加状态
        States.Add(EEnvironmentInteractionState.Reset, new ResetState(_context, EEnvironmentInteractionState.Reset));
        States.Add(EEnvironmentInteractionState.Search, new SearchState(_context, EEnvironmentInteractionState.Search));
        States.Add(EEnvironmentInteractionState.Approach, new ApproachState(_context, EEnvironmentInteractionState.Approach));
        States.Add(EEnvironmentInteractionState.Rise, new RiseState(_context, EEnvironmentInteractionState.Rise));
        States.Add(EEnvironmentInteractionState.Touch, new TouchState(_context, EEnvironmentInteractionState.Touch));

        //设置初始状态为Reset
        CurrentState = States[EEnvironmentInteractionState.Reset];

    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053818826-206355508.png" alt="1755793245712" loading="lazy"></p>
<p>状态机运行正常</p>
<h2 id="环境检测">环境检测</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053819519-1296840604.png" alt="1755793230388" loading="lazy"></p>
<h3 id="1在角色身上创建一个稍大于臂展的碰撞盒">1.在角色身上创建一个稍大于臂展的碰撞盒</h3>
<p>EnvironmentInteractionStateMachine</p>
<pre><code class="language-csharp">    void Awake()
    {
        ///原来的代码

        ConstructEnvironmentDetectionCollider();
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 创建一个环境检测用的碰撞体
    /// &lt;/summary&gt;
    private void ConstructEnvironmentDetectionCollider()
    {
        // 碰撞体大小的基准值
        float wingspan = characterController.height;

        // 给当前游戏对象添加盒型碰撞体组件
        BoxCollider boxCollider = gameObject.AddComponent&lt;BoxCollider&gt;();

        // 设置碰撞体大小为立方体，各边长度等于翼展
        boxCollider.size = new Vector3(wingspan, wingspan, wingspan);

        // 设置碰撞体中心位置
        // 基于角色控制器的中心位置进行偏移：
        // Y轴方向上移翼展的25%，Z轴方向前移翼展的50%
        boxCollider.center = new Vector3(
            characterController.center.x,
            characterController.center.y + (.25f * wingspan),
            characterController.center.z + (.5f * wingspan)
        );

        // 将碰撞体设置为触发器模式（用于检测碰撞而非物理碰撞响应）
        boxCollider.isTrigger = true;
    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053820138-1365850558.png" alt="1755800944612" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053820425-1425268731.png" alt="1755800951964" loading="lazy"></p>
<h3 id="2碰撞体触发器的交互机制">2.碰撞体触发器的交互机制</h3>
<ol>
<li>角色进入 “触发器区域” → <code>OnTriggerEnter</code> 触发（一次）</li>
<li>角色持续待在区域内 → 每帧触发 <code>OnTriggerStay</code></li>
<li>角色离开区域 → <code>OnTriggerExit</code> 触发（一次）</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053821037-609730775.png" alt="1755794086675" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053821543-1731118420.png" alt="1755794176628" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822003-920432170.png" alt="1755794192951" loading="lazy"></p>
<h3 id="3找到离角色更近的一侧用来决定后面开启哪边的ik">3.找到离角色更近的一侧，用来决定后面开启哪边的IK</h3>
<p>在<strong>EnvironmentInteractionContext</strong>加入：判断碰撞相交位置更靠近哪一侧</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822466-523966974.png" alt="1755801127469" loading="lazy"></p>
<pre><code class="language-csharp">    // 身体两侧
    public enum EBodySide
    {
        RIGHT,
        LEFT
    }
</code></pre>
<pre><code class="language-csharp">    // 当前IK约束
    public TwoBoneIKConstraint CurrentIkConstraint { get; private set; }
    // 当前多旋转约束
    public MultiRotationConstraint CurrentMultiRotationConstraint { get; private set; }
    // 当前IK控制的目标位置
    public Transform CurrentIkTargetTransform { get; private set; }
    // 当前肩部骨骼
    public Transform CurrentShoulderTransform { get; private set; }
    // 当前身体的侧边（左或右）
    public EBodySide CurrentBodySide { get; private set; }

    /// &lt;summary&gt;
    /// 根据传入位置，判断目标更靠近左侧还是右侧肩部，设置当前身体的侧边
    /// &lt;/summary&gt;
    /// &lt;param name="positionToCheck"&gt;需要检测的目标位置&lt;/param&gt;
    public void SetCurrentSide(Vector3 positionToCheck)
    {
        // 左肩部骨骼
        Vector3 leftShoulder = _leftIkConstraint.data.root.transform.position;
        // 右肩部骨骼
        Vector3 rightShoulder = _rightIkConstraint.data.root.transform.position;

        // 标志位：目标位置是否更靠近左侧
        bool isLeftCloser = Vector3.Distance(positionToCheck, leftShoulder) &lt;
                            Vector3.Distance(positionToCheck, rightShoulder);
        if (isLeftCloser)
        {
            CurrentBodySide = EBodySide.LEFT;
            CurrentIkConstraint = _leftIkConstraint;
            CurrentMultiRotationConstraint = _leftMultiRotationConstraint;
        }
        else
        {
            CurrentBodySide = EBodySide.RIGHT;
            CurrentIkConstraint = _rightIkConstraint;
            CurrentMultiRotationConstraint = _rightMultiRotationConstraint;
        }
        // 记录当前肩部骨骼 和 IK控制的目标位置
        CurrentShoulderTransform = CurrentIkConstraint.data.root.transform;
        CurrentIkTargetTransform = CurrentIkConstraint.data.target.transform;
    }
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable时才进行IK目标位置追踪
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable"))
        {
            // 最近的碰撞点
            Vector3 closestPointFromRoot = GetClosestPointOnCollider(intersectingCollider, Context.RootTransform.position);
            // 设置当前更靠近的侧面(根据最近的碰撞点)
            Context.SetCurrentSide(closestPointFromRoot);
        }

    }

    /// &lt;summary&gt;
    /// 更新 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，依据其状态更新目标位置&lt;/param&gt;
    protected void UpdateIkTargetPosition(Collider intersectingCollider)
    {

    }

    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {

    }
</code></pre>
<p>这里要用到一个新的变量<strong>RootTransform</strong>用来在<strong>GetClosestPointOnCollider()</strong>方法中传入参数<strong>positionToCheck</strong></p>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 根对象
    private Transform _rootTransform;
</code></pre>
<p>构造函数要加入这个变量</p>
<pre><code class="language-csharp">    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController,
        Transform rootTransform)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
        _rootTransform = rootTransform;
    }
</code></pre>
<pre><code class="language-csharp">    public Transform RootTransform =&gt; _rootTransform;
</code></pre>
<p>当然，在EnvironmentInteractionStateMachine中也要传入这个变量</p>
<p>Awake()</p>
<pre><code class="language-csharp">        _context = new EnvironmentInteractionContext(_leftIkConstraint, _rightIkConstraint, _leftMultiRotationConstraint, _rightMultiRotationConstraint, characterController,transform.root);
</code></pre>
<p>写一下<strong>ResetState</strong>的GetNextState()的下一状态切换逻辑</p>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState() 
    { 
        // 下一个状态为 SearchState
        return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Search;
        //return StateKey; 
    }
</code></pre>
<blockquote>
<p>注意：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822791-1705124530.png" alt="1755802950451" loading="lazy"></p>
</blockquote>
<p>在<strong>SearchState</strong>的<strong>OnTriggerEnter()</strong>中调用<strong>StartIkTargetPositionTracking()</strong>启动 IK 目标位置追踪</p>
<pre><code class="language-csharp">    public override void OnTriggerEnter(Collider other) {
        // 进入搜索状态时，开始跟踪目标位置
        StartIkTargetPositionTracking(other);
    }
</code></pre>
<p>测试一下功能是否正常：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053823118-615327104.png" alt="1755803008162" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053826956-1456660406.gif" alt="1755807104145" loading="lazy"></p>
<blockquote>
<p>效果倒是正常，不过这是我调试好久发现的问题，只有挂载rigidbody的物体才会触发Trigger回调函数，正常来说只要一方有rigidbody就能触发，不知道为什么这里会出现这个问题，角色身上的这个触发器肯定是rigidbody，那已经满足条件了，为什么还要其他物体也要挂载rigidbody，想不明白。。。</p>
<p>不过实现了就好，后面再排查问题吧，先完成最要紧</p>
</blockquote>
<h3 id="4解决一下在狭窄通道走过的时候左右频繁触发的问题">4.解决一下在狭窄通道走过的时候，左右频繁触发的问题</h3>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 当前交互的碰撞体
    public Collider CurrentIntersectingCollider { get; set; }
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable &amp;&amp; 当前没有可交互的碰撞体 时才进行IK目标位置追踪
        // 防止频繁触发
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable") &amp;&amp; Context.CurrentIntersectingCollider == null)
        {
            // 记录当前碰撞体
            Context.CurrentIntersectingCollider = intersectingCollider;
            // 最近的碰撞点
            Vector3 closestPointFromRoot = GetClosestPointOnCollider(intersectingCollider, Context.RootTransform.position);
            // 设置当前更靠近的侧面(根据最近的碰撞点)
            Context.SetCurrentSide(closestPointFromRoot);
        }
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {
        if(intersectingCollider == Context.CurrentIntersectingCollider)
        {
            Context.CurrentIntersectingCollider = null;
        }
    }
</code></pre>
<p>SearchState</p>
<pre><code class="language-csharp">    public override void OnTriggerEnter(Collider other) {
        Debug.Log("Trigger：Enter");
        // 进入搜索状态，开始跟踪目标位置
        StartIkTargetPositionTracking(other);
    }
    public override void OnTriggerStay(Collider other) { }
    public override void OnTriggerExit(Collider other) {
        Debug.Log("Trigger：Exit");
        // 退出搜索状态，停止跟踪目标位置
        ResetIkTargetPositionTracking(other);
    }
</code></pre>
<h3 id="5设置ik的目标位置">5.设置IK的目标位置</h3>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 相交碰撞体的最近点——默认值设为无穷大
    public Vector3 ClosestPointOnColliderFromShoulder { get; set; } = Vector3.positiveInfinity;
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, Context.CurrentShoulderTransform.position);
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable &amp;&amp; 当前没有可交互的碰撞体 时才进行IK目标位置追踪
        // 防止频繁触发
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable") &amp;&amp; Context.CurrentIntersectingCollider == null)
        {
            // 原来的代码不变


            //设置IK目标位置
            SetIkTargetPosition();
        }
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 更新 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，依据其状态更新目标位置&lt;/param&gt;
    protected void UpdateIkTargetPosition(Collider intersectingCollider)
    {
        // 在接触过程中，一直更新IK目标位置
        if (Context.CurrentIntersectingCollider == intersectingCollider)
        {
            SetIkTargetPosition();
        }
    }
</code></pre>
<p>SearchState</p>
<pre><code class="language-csharp">    public override void OnTriggerStay(Collider other) {
        // 跟踪目标位置
        UpdateIkTargetPosition(other);
    }
</code></pre>
<p>然后在EnvironmentInteractionStateMachine中加入可视化</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 当物体被选中时调用Gizmos绘制
    /// &lt;/summary&gt;
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;

        // 在最近碰撞点处绘制一个红色的球
        if (_context != null &amp;&amp; _context.ClosestPointOnColliderFromShoulder != null)
        {
            Gizmos.DrawSphere(_context.ClosestPointOnColliderFromShoulder, 0.03f);
        }
    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053831811-1699883224.gif" alt="1755809630756" loading="lazy"></p>
<blockquote>
<p>新的问题出现了：</p>
<p>当角色行走的时候，由于身体会浮动，这个最近的碰撞点也在上下浮动，后面加上动画会出现手一直在墙上 上下乱摸。。。</p>
</blockquote>
<h3 id="6解决最近碰撞点上下浮动问题">6.解决最近碰撞点上下浮动问题</h3>
<blockquote>
<p>其实加一个变量记录一下角色的肩高就行，设定ik位置的时候传入该参数，这个点的高度就保持不变了</p>
</blockquote>
<p><strong>EnvironmentInteractionContext</strong>的构造函数加入一个角色的肩部高度变量</p>
<pre><code class="language-csharp">    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController,
        Transform rootTransform)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
        _rootTransform = rootTransform;

        CharacterShoulderHeight = leftIkConstraint.data.root.transform.position.y;
    }
</code></pre>
<pre><code class="language-csharp">    // 角色的肩部高度,用来约束Ik的高度
    public float CharacterShoulderHeight { get; private set; }
</code></pre>
<p><strong>EnvironmentInteractionState</strong>传入目标位置的参数的y轴改成角色肩高<strong>CharacterShoulderHeight</strong></p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, 
            // 目标位置：上半身的xz位置 角色肩高的y位置(高度位置)
            new Vector3(Context.RootTransform.position.x, Context.CharacterShoulderHeight, Context.RootTransform.position.z));
    }
</code></pre>
<blockquote>
<p>问题解决</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053836304-687699737.gif" alt="1755810520182" loading="lazy"></p>
<h3 id="7在离开当前碰撞体后重置ik的目标位置为无穷大">7.在离开当前碰撞体后，重置Ik的目标位置为无穷大</h3>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {
        if(intersectingCollider == Context.CurrentIntersectingCollider)
        {
            // 重置当前碰撞体为空
            Context.CurrentIntersectingCollider = null;
            // 重置IK目标位置为无穷大
            Context.ClosestPointOnColliderFromShoulder = Vector3.positiveInfinity;
        }
    }
</code></pre>
<p>效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053841541-174085628.gif" alt="1755810786266" loading="lazy"></p>
<h3 id="8开始对手部的ik组件目标位置进行更新">8.开始对手部的IK组件目标位置进行更新</h3>
<blockquote>
<p>注意：需要为ik的目标位置加一个法向的偏移，防止手部穿模(因为手是有厚度的，不是纸片人)</p>
</blockquote>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, 
            // 目标位置：上半身的xz位置 角色肩高的y位置(高度位置)
            new Vector3(Context.RootTransform.position.x, Context.CharacterShoulderHeight, Context.RootTransform.position.z));

        #region 让手部的IK目标移动到这个最近碰撞点
        // 1. 射线方向：从“最近碰撞点”指向“当前肩部位置”的向量
        Vector3 rayDirection = Context.CurrentShoulderTransform.position
                             - Context.ClosestPointOnColliderFromShoulder;
            // Unity 中向量的运算：Vector3 终点 - Vector3 起点

        // 2. 归一化，得到单位向量
        Vector3 normalizedRayDirection = rayDirection.normalized;

        // 3. 偏移距离，防止手部穿模
        float offsetDistance = 0.05f;

        // 4. 最终要到达的位置：在“最近碰撞点”基础上，加上 沿rayDirection射线方向偏移 offsetDistance 距离
        Vector3 targettPosition = Context.ClosestPointOnColliderFromShoulder 
            + normalizedRayDirection * offsetDistance;

        // 5. 更新 IK 目标位置
        Context.CurrentIkTargetTransform.position = targettPosition;
        #endregion
    }
</code></pre>
<p>如果把权重一开始就拉到1，效果是这样的：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053849230-836447837.gif" alt="1755812110107" loading="lazy"></p>
<blockquote>
<p>当然，我们还得根据具体的状态写Ik权重的控制脚本</p>
</blockquote>
<h2 id="每个具体状态的ik控制逻辑的脚本编写">每个具体状态的Ik控制逻辑的脚本编写</h2>
<blockquote>
<p>也就是根据状态决定是否/怎样更新手部Two Bone IK Constraint的权重</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-08-22 05:43">2025-08-22 05:42</span>&nbsp;
<a href="https://www.cnblogs.com/eanojiang">EanoJiang</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19051898);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19051898', targetLink: 'https://www.cnblogs.com/eanojiang/p/19051898', title: '仿神秘海域/美末环境交互的程序化动画学习' })">举报</a>
</div>
        