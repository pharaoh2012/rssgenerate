
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/eanojiang/p/19051898" title="发布于 2025-08-24 16:20">
    <span role="heading" aria-level="2">(已完结)仿神秘海域/美末环境交互的程序化动画学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        顽皮狗天下第一
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p><strong>写在前面：</strong></p>
<p>真正实现这些细枝末节的东西的时候才能感受到这种技术力的恐怖。</p>
<p>——致敬顽皮狗工作室</p>
</blockquote>
<h2 id="插件安装">插件安装</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053813019-2039736898.png" alt="1755773270538" loading="lazy"></p>
<h2 id="为角色添加组件">为角色添加组件</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053813713-611246744.png" alt="1755773337095" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053814338-1463063657.png" alt="1755773371949" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053814717-372422136.png" alt="1755773411325" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053815055-1522603149.png" alt="1755773431970" loading="lazy"></p>
<p>右手同理</p>
<h2 id="状态机脚本编写">状态机脚本编写</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053815798-1629959597.png" alt="1755775744433" loading="lazy"></p>
<p>BaseState.cs</p>
<pre><code class="language-csharp">using UnityEngine;
using System;

/// &lt;summary&gt;
/// 状态基类，定义了状态机中所有状态的基本行为规范
/// 泛型参数EEState限制为枚举类型，用于表示具体的状态类型
/// &lt;/summary&gt;
/// &lt;typeparam name="EState"&gt;状态枚举类型，继承自Enum&lt;/typeparam&gt;
public abstract class BaseState&lt;EState&gt; where EState : Enum
{
    //构造函数
    public BaseState(EState key)
    {
        StateKey = key;
    }
    public EState StateKey { get; private set; }

    public abstract void EnterState();
    public abstract void ExitState();
    public abstract void UpdateState();
    public abstract EState GetNextState();
    public abstract void OnTriggerEnter(Collider other);
    public abstract void OnTriggerStay(Collider other);
    public abstract void OnTriggerExit(Collider other);
}
</code></pre>
<p>NewBaseState.cs</p>
<pre><code class="language-csharp">using UnityEngine;
using System;
using System.Collections.Generic;

/// &lt;summary&gt;
/// 状态管理器泛型抽象类
/// &lt;/summary&gt;
/// &lt;typeparam name="EState"&gt;状态枚举类型，需继承自Enum&lt;/typeparam&gt;
public abstract class StateManager&lt;EState&gt; : MonoBehaviour where EState : Enum
{
    // 存储所有状态的字典，键为状态枚举，值为对应的状态实例
    protected Dictionary&lt;EState, BaseState&lt;EState&gt;&gt; States = new Dictionary&lt;EState, BaseState&lt;EState&gt;&gt;();
    // 当前激活的状态
    protected BaseState&lt;EState&gt; CurrentState;

    // 标志位：是否处于状态切换中
    protected bool IsTransitioningState = false;

    void Start()
    {
        CurrentState.EnterState();
    }

    void Update()
    {
        EState nextStateKey = CurrentState.GetNextState();

        if (!IsTransitioningState &amp;&amp; nextStateKey.Equals(CurrentState.StateKey))
        {
            // 如果当前状态和下一状态相同，则更新当前状态
            CurrentState.UpdateState();
        }
        else if(!IsTransitioningState)
        {
            // 不同，则切换到下一状态
            TransitionToState(nextStateKey);
        }
    }

    /// &lt;summary&gt;
    /// 状态切换方法，用于从当前状态切换到目标状态
    /// &lt;/summary&gt;
    /// &lt;param name="stateKey"&gt;目标状态的枚举标识&lt;/param&gt;
    protected virtual void TransitionToState(EState stateKey)
    {
        IsTransitioningState = true;

        // 退出当前状态
        CurrentState.ExitState();
        // 进入目标状态
        CurrentState = States[stateKey];
        CurrentState.EnterState();

        IsTransitioningState = false;
    }

    /// &lt;summary&gt;
    /// 当碰撞体进入触发器时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;进入触发器的碰撞体&lt;/param&gt;
    void OnTriggerEnter(Collider other)
    {
        CurrentState.OnTriggerEnter(other);
    }

    /// &lt;summary&gt;
    /// 当碰撞体持续处于触发器中时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;处于触发器中的碰撞体&lt;/param&gt;
    void OnTriggerStay(Collider other)
    {
        CurrentState.OnTriggerStay(other);
    }

    /// &lt;summary&gt;
    /// 当碰撞体退出触发器时调用的方法，转发给当前状态处理
    /// &lt;/summary&gt;
    /// &lt;param name="other"&gt;退出触发器的碰撞体&lt;/param&gt;
    void OnTriggerExit(Collider other)
    {
        CurrentState.OnTriggerExit(other);
    }
}
</code></pre>
<h2 id="animation-rigging">Animation Rigging</h2>
<blockquote>
<p>Rig Builder组件要放在Animator的同级</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816105-338026225.png" alt="1755784900189" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816415-2142758309.png" alt="1755784962449" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053816722-1091885840.png" alt="1755785011835" loading="lazy"></p>
<p>Rig放置的位置</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817119-890067986.png" alt="1755784884750" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817362-993366441.png" alt="1755785030047" loading="lazy"></p>
<h2 id="环境交互状态机的编写">环境交互状态机的编写</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053817586-1564131573.png" alt="1755785081711" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053818473-1938481811.png" alt="1755789073630" loading="lazy"></p>
<p>EnvironmentInteractionStateMachine</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Animations.Rigging;
using UnityEngine.Assertions;   //调试用


public class EnvironmentInteractionStateMachine : StateManager&lt;EnvironmentInteractionStateMachine.EEnvironmentInteractionState&gt;
{
    // 环境交互状态
    public enum EEnvironmentInteractionState
    {
        Search,   // 搜索状态
        Approach, // 接近状态
        Rise,     // 起身状态
        Touch,    // 触碰状态
        Reset     // 重置状态
    }

    private EnvironmentInteractionContext _context;

    // 约束、组件等引用
    [SerializeField] private TwoBoneIKConstraint _leftIkConstraint;
    [SerializeField] private TwoBoneIKConstraint _rightIkConstraint;
    [SerializeField] private MultiRotationConstraint _leftMultiRotationConstraint;
    [SerializeField] private MultiRotationConstraint _rightMultiRotationConstraint;
    [SerializeField] private CharacterController characterController;

    void Awake()
    {
        ValidateConstraints();

        _context = new EnvironmentInteractionContext(_leftIkConstraint, _rightIkConstraint, _leftMultiRotationConstraint, _rightMultiRotationConstraint, characterController);
    }

    // 校验各类约束、组件是否正确赋值
    private void ValidateConstraints()
    {
        Assert.IsNotNull(_leftIkConstraint, "Left IK constraint 没有赋值");
        Assert.IsNotNull(_rightIkConstraint, "Right IK constraint 没有赋值");
        Assert.IsNotNull(_leftMultiRotationConstraint, "Left multi-rotation constraint 没有赋值");
        Assert.IsNotNull(_rightMultiRotationConstraint, "Right multi-rotation constraint 没有赋值");
        Assert.IsNotNull(characterController, "characterController used to control character 没有赋值");
    }


}
</code></pre>
<p>EnvironmentInteractionContext用来管理各种属性</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Animations.Rigging;

public class EnvironmentInteractionContext
{
    private TwoBoneIKConstraint _leftIkConstraint;
    private TwoBoneIKConstraint _rightIkConstraint;
    private MultiRotationConstraint _leftMultiRotationConstraint;
    private MultiRotationConstraint _rightMultiRotationConstraint;
    private CharacterController _characterController;

    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
    }

    // 外部可以访问的属性
    public TwoBoneIKConstraint LeftIkConstraint =&gt; _leftIkConstraint;
    public TwoBoneIKConstraint RightIkConstraint =&gt; _rightIkConstraint;
    public MultiRotationConstraint LeftMultiRotationConstraint =&gt; _leftMultiRotationConstraint;
    public MultiRotationConstraint RightMultiRotationConstraint =&gt; _rightMultiRotationConstraint;
    public CharacterController CharacterController =&gt; _characterController;
}
</code></pre>
<p>从ResetState开始</p>
<pre><code class="language-csharp">using UnityEngine;

public class ResetState : EnvironmentInteractionState
{
    // 构造函数
    public ResetState(EnvironmentInteractionContext context, EnvironmentInteractionStateMachine.EEnvironmentInteractionState estate) : base(context, estate)
    {
        EnvironmentInteractionContext Context = context;
    }
    public override void EnterState(){}
    public override void ExitState() { }
    public override void UpdateState() { }
    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState() 
    { 
        return StateKey; 
    }
    public override void OnTriggerEnter(Collider other) { }
    public override void OnTriggerStay(Collider other) { }
    public override void OnTriggerExit(Collider other) { }
}
</code></pre>
<p>EnvironmentInteractionStateMachine中加入初始化函数</p>
<pre><code class="language-csharp">    void Awake()
    {
	//原来的代码

        InitalizeStates();
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 初始化状态机
    /// &lt;/summary&gt;
    private void InitalizeStates()
    {
        //添加状态
        States.Add(EEnvironmentInteractionState.Reset, new ResetState(_context, EEnvironmentInteractionState.Reset));
        States.Add(EEnvironmentInteractionState.Search, new SearchState(_context, EEnvironmentInteractionState.Search));
        States.Add(EEnvironmentInteractionState.Approach, new ApproachState(_context, EEnvironmentInteractionState.Approach));
        States.Add(EEnvironmentInteractionState.Rise, new RiseState(_context, EEnvironmentInteractionState.Rise));
        States.Add(EEnvironmentInteractionState.Touch, new TouchState(_context, EEnvironmentInteractionState.Touch));

        //设置初始状态为Reset
        CurrentState = States[EEnvironmentInteractionState.Reset];

    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053818826-206355508.png" alt="1755793245712" loading="lazy"></p>
<p>状态机运行正常</p>
<h2 id="环境检测">环境检测</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053819519-1296840604.png" alt="1755793230388" loading="lazy"></p>
<h3 id="1在角色身上创建一个稍大于臂展的碰撞盒">1.在角色身上创建一个稍大于臂展的碰撞盒</h3>
<p>EnvironmentInteractionStateMachine</p>
<pre><code class="language-csharp">    void Awake()
    {
        ///原来的代码

        ConstructEnvironmentDetectionCollider();
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 创建一个环境检测用的碰撞体
    /// &lt;/summary&gt;
    private void ConstructEnvironmentDetectionCollider()
    {
        // 碰撞体大小的基准值
        float wingspan = characterController.height;

        // 给当前游戏对象添加盒型碰撞体组件
        BoxCollider boxCollider = gameObject.AddComponent&lt;BoxCollider&gt;();

        // 设置碰撞体大小为立方体，各边长度等于翼展
        boxCollider.size = new Vector3(wingspan, wingspan, wingspan);

        // 设置碰撞体中心位置
        // 基于角色控制器的中心位置进行偏移：
        // Y轴方向上移翼展的25%，Z轴方向前移翼展的50%
        boxCollider.center = new Vector3(
            characterController.center.x,
            characterController.center.y + (.25f * wingspan),
            characterController.center.z + (.5f * wingspan)
        );

        // 将碰撞体设置为触发器模式（用于检测碰撞而非物理碰撞响应）
        boxCollider.isTrigger = true;
    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053820138-1365850558.png" alt="1755800944612" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053820425-1425268731.png" alt="1755800951964" loading="lazy"></p>
<h3 id="2碰撞体触发器的交互机制">2.碰撞体触发器的交互机制</h3>
<ol>
<li>角色进入 “触发器区域” → <code>OnTriggerEnter</code> 触发（一次）</li>
<li>角色持续待在区域内 → 每帧触发 <code>OnTriggerStay</code></li>
<li>角色离开区域 → <code>OnTriggerExit</code> 触发（一次）</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053821037-609730775.png" alt="1755794086675" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053821543-1731118420.png" alt="1755794176628" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822003-920432170.png" alt="1755794192951" loading="lazy"></p>
<h3 id="3找到离角色更近的一侧用来决定后面开启哪边的ik">3.找到离角色更近的一侧，用来决定后面开启哪边的IK</h3>
<p>在<strong>EnvironmentInteractionContext</strong>加入：判断碰撞相交位置更靠近哪一侧</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822466-523966974.png" alt="1755801127469" loading="lazy"></p>
<pre><code class="language-csharp">    // 身体两侧
    public enum EBodySide
    {
        RIGHT,
        LEFT
    }
</code></pre>
<pre><code class="language-csharp">    // 当前IK约束
    public TwoBoneIKConstraint CurrentIkConstraint { get; private set; }
    // 当前多旋转约束
    public MultiRotationConstraint CurrentMultiRotationConstraint { get; private set; }
    // 当前IK控制的目标位置
    public Transform CurrentIkTargetTransform { get; private set; }
    // 当前肩部骨骼
    public Transform CurrentShoulderTransform { get; private set; }
    // 当前身体的侧边（左或右）
    public EBodySide CurrentBodySide { get; private set; }

    /// &lt;summary&gt;
    /// 根据传入位置，判断目标更靠近左侧还是右侧肩部，设置当前身体的侧边
    /// &lt;/summary&gt;
    /// &lt;param name="positionToCheck"&gt;需要检测的目标位置&lt;/param&gt;
    public void SetCurrentSide(Vector3 positionToCheck)
    {
        // 左肩部骨骼
        Vector3 leftShoulder = _leftIkConstraint.data.root.transform.position;
        // 右肩部骨骼
        Vector3 rightShoulder = _rightIkConstraint.data.root.transform.position;

        // 标志位：目标位置是否更靠近左侧
        bool isLeftCloser = Vector3.Distance(positionToCheck, leftShoulder) &lt;
                            Vector3.Distance(positionToCheck, rightShoulder);
        if (isLeftCloser)
        {
            CurrentBodySide = EBodySide.LEFT;
            CurrentIkConstraint = _leftIkConstraint;
            CurrentMultiRotationConstraint = _leftMultiRotationConstraint;
        }
        else
        {
            CurrentBodySide = EBodySide.RIGHT;
            CurrentIkConstraint = _rightIkConstraint;
            CurrentMultiRotationConstraint = _rightMultiRotationConstraint;
        }
        // 记录当前肩部骨骼 和 IK控制的目标位置
        CurrentShoulderTransform = CurrentIkConstraint.data.root.transform;
        CurrentIkTargetTransform = CurrentIkConstraint.data.target.transform;
    }
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable时才进行IK目标位置追踪
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable"))
        {
            // 最近的碰撞点
            Vector3 closestPointFromRoot = GetClosestPointOnCollider(intersectingCollider, Context.RootTransform.position);
            // 设置当前更靠近的侧面(根据最近的碰撞点)
            Context.SetCurrentSide(closestPointFromRoot);
        }

    }

    /// &lt;summary&gt;
    /// 更新 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，依据其状态更新目标位置&lt;/param&gt;
    protected void UpdateIkTargetPosition(Collider intersectingCollider)
    {

    }

    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {

    }
</code></pre>
<p>这里要用到一个新的变量<strong>RootTransform</strong>用来在<strong>GetClosestPointOnCollider()</strong>方法中传入参数<strong>positionToCheck</strong></p>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 根对象
    private Transform _rootTransform;
</code></pre>
<p>构造函数要加入这个变量</p>
<pre><code class="language-csharp">    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController,
        Transform rootTransform)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
        _rootTransform = rootTransform;
    }
</code></pre>
<pre><code class="language-csharp">    public Transform RootTransform =&gt; _rootTransform;
</code></pre>
<p>当然，在EnvironmentInteractionStateMachine中也要传入这个变量</p>
<p>Awake()</p>
<pre><code class="language-csharp">        _context = new EnvironmentInteractionContext(_leftIkConstraint, _rightIkConstraint, _leftMultiRotationConstraint, _rightMultiRotationConstraint, characterController,transform.root);
</code></pre>
<p>写一下<strong>ResetState</strong>的GetNextState()的下一状态切换逻辑</p>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState() 
    { 
        // 下一个状态为 SearchState
        return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Search;
        //return StateKey; 
    }
</code></pre>
<blockquote>
<p>注意：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053822791-1705124530.png" alt="1755802950451" loading="lazy"></p>
</blockquote>
<p>在<strong>SearchState</strong>的<strong>OnTriggerEnter()</strong>中调用<strong>StartIkTargetPositionTracking()</strong>启动 IK 目标位置追踪</p>
<pre><code class="language-csharp">    public override void OnTriggerEnter(Collider other) {
        // 进入搜索状态时，开始跟踪目标位置
        StartIkTargetPositionTracking(other);
    }
</code></pre>
<p>测试一下功能是否正常：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053823118-615327104.png" alt="1755803008162" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053826956-1456660406.gif" alt="1755807104145" loading="lazy"></p>
<blockquote>
<p>效果倒是正常，不过这是我调试好久发现的问题，只有挂载rigidbody的物体才会触发Trigger回调函数，正常来说只要一方有rigidbody就能触发，不知道为什么这里会出现这个问题，角色身上的这个触发器肯定是rigidbody，那已经满足条件了，为什么还要其他物体也要挂载rigidbody，想不明白。。。</p>
<p>不过实现了就好，后面再排查问题吧，先完成最要紧</p>
</blockquote>
<h3 id="4解决一下在狭窄通道走过的时候左右频繁触发的问题">4.解决一下在狭窄通道走过的时候，左右频繁触发的问题</h3>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 当前交互的碰撞体
    public Collider CurrentIntersectingCollider { get; set; }
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable &amp;&amp; 当前没有可交互的碰撞体 时才进行IK目标位置追踪
        // 防止频繁触发
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable") &amp;&amp; Context.CurrentIntersectingCollider == null)
        {
            // 记录当前碰撞体
            Context.CurrentIntersectingCollider = intersectingCollider;
            // 最近的碰撞点
            Vector3 closestPointFromRoot = GetClosestPointOnCollider(intersectingCollider, Context.RootTransform.position);
            // 设置当前更靠近的侧面(根据最近的碰撞点)
            Context.SetCurrentSide(closestPointFromRoot);
        }
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {
        if(intersectingCollider == Context.CurrentIntersectingCollider)
        {
            Context.CurrentIntersectingCollider = null;
        }
    }
</code></pre>
<p>SearchState</p>
<pre><code class="language-csharp">    public override void OnTriggerEnter(Collider other) {
        Debug.Log("Trigger：Enter");
        // 进入搜索状态，开始跟踪目标位置
        StartIkTargetPositionTracking(other);
    }
    public override void OnTriggerStay(Collider other) { }
    public override void OnTriggerExit(Collider other) {
        Debug.Log("Trigger：Exit");
        // 退出搜索状态，停止跟踪目标位置
        ResetIkTargetPositionTracking(other);
    }
</code></pre>
<h3 id="5设置ik的目标位置">5.设置IK的目标位置</h3>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 相交碰撞体的最近点——默认值设为无穷大
    public Vector3 ClosestPointOnColliderFromShoulder { get; set; } = Vector3.positiveInfinity;
</code></pre>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, Context.CurrentShoulderTransform.position);
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 启动 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，作为追踪关联对象&lt;/param&gt;
    protected void StartIkTargetPositionTracking(Collider intersectingCollider)
    {
        //只有碰撞体的层级为Interactable &amp;&amp; 当前没有可交互的碰撞体 时才进行IK目标位置追踪
        // 防止频繁触发
        if (intersectingCollider.gameObject.layer == LayerMask.NameToLayer("Interactable") &amp;&amp; Context.CurrentIntersectingCollider == null)
        {
            // 原来的代码不变


            //设置IK目标位置
            SetIkTargetPosition();
        }
    }
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 更新 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，依据其状态更新目标位置&lt;/param&gt;
    protected void UpdateIkTargetPosition(Collider intersectingCollider)
    {
        // 在接触过程中，一直更新IK目标位置
        if (Context.CurrentIntersectingCollider == intersectingCollider)
        {
            SetIkTargetPosition();
        }
    }
</code></pre>
<p>SearchState</p>
<pre><code class="language-csharp">    public override void OnTriggerStay(Collider other) {
        // 跟踪目标位置
        UpdateIkTargetPosition(other);
    }
</code></pre>
<p>然后在EnvironmentInteractionStateMachine中加入可视化</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 当物体被选中时调用Gizmos绘制
    /// &lt;/summary&gt;
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;

        // 在最近碰撞点处绘制一个红色的球
        if (_context != null &amp;&amp; _context.ClosestPointOnColliderFromShoulder != null)
        {
            Gizmos.DrawSphere(_context.ClosestPointOnColliderFromShoulder, 0.03f);
        }
    }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053831811-1699883224.gif" alt="1755809630756" loading="lazy"></p>
<blockquote>
<p>新的问题出现了：</p>
<p>当角色行走的时候，由于身体会浮动，这个最近的碰撞点也在上下浮动，后面加上动画会出现手一直在墙上 上下乱摸。。。</p>
</blockquote>
<h3 id="6解决最近碰撞点上下浮动问题">6.解决最近碰撞点上下浮动问题</h3>
<blockquote>
<p>其实加一个变量记录一下角色的肩高就行，设定ik位置的时候传入该参数，这个点的高度就保持不变了</p>
</blockquote>
<p><strong>EnvironmentInteractionContext</strong>的构造函数加入一个角色的肩部高度变量</p>
<pre><code class="language-csharp">    public EnvironmentInteractionContext(
        TwoBoneIKConstraint leftIkConstraint,
        TwoBoneIKConstraint rightIkConstraint,
        MultiRotationConstraint leftMultiRotationConstraint,
        MultiRotationConstraint rightMultiRotationConstraint,
        CharacterController characterController,
        Transform rootTransform)
    {
        _leftIkConstraint = leftIkConstraint;
        _rightIkConstraint = rightIkConstraint;
        _leftMultiRotationConstraint = leftMultiRotationConstraint;
        _rightMultiRotationConstraint = rightMultiRotationConstraint;
        _characterController = characterController;
        _rootTransform = rootTransform;

        CharacterShoulderHeight = leftIkConstraint.data.root.transform.position.y;
    }
</code></pre>
<pre><code class="language-csharp">    // 角色的肩部高度,用来约束Ik的高度
    public float CharacterShoulderHeight { get; private set; }
</code></pre>
<p><strong>EnvironmentInteractionState</strong>传入目标位置的参数的y轴改成角色肩高<strong>CharacterShoulderHeight</strong></p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, 
            // 目标位置：上半身的xz位置 角色肩高的y位置(高度位置)
            new Vector3(Context.RootTransform.position.x, Context.CharacterShoulderHeight, Context.RootTransform.position.z));
    }
</code></pre>
<blockquote>
<p>问题解决</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053836304-687699737.gif" alt="1755810520182" loading="lazy"></p>
<h3 id="7在离开当前碰撞体后重置ik的目标位置为无穷大">7.在离开当前碰撞体后，重置Ik的目标位置为无穷大</h3>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 重置 IK 目标位置追踪
    /// &lt;/summary&gt;
    /// &lt;param name="intersectingCollider"&gt;相交的碰撞体，针对其执行追踪重置&lt;/param&gt;
    protected void ResetIkTargetPositionTracking(Collider intersectingCollider)
    {
        if(intersectingCollider == Context.CurrentIntersectingCollider)
        {
            // 重置当前碰撞体为空
            Context.CurrentIntersectingCollider = null;
            // 重置IK目标位置为无穷大
            Context.ClosestPointOnColliderFromShoulder = Vector3.positiveInfinity;
        }
    }
</code></pre>
<p>效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053841541-174085628.gif" alt="1755810786266" loading="lazy"></p>
<h3 id="8开始对手部的ik组件目标位置进行更新">8.开始对手部的IK组件目标位置进行更新</h3>
<blockquote>
<p>注意：需要为ik的目标位置加一个法向的偏移，防止手部穿模(因为手是有厚度的，不是纸片人)</p>
</blockquote>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 设置 IK 目标位置
    /// &lt;/summary&gt;
    /// &lt;param name="targetPosition"&gt;&lt;/param&gt;
    private void SetIkTargetPosition()
    {
        // 最近的碰撞点
        Context.ClosestPointOnColliderFromShoulder = GetClosestPointOnCollider(Context.CurrentIntersectingCollider, 
            // 目标位置：上半身的xz位置 角色肩高的y位置(高度位置)
            new Vector3(Context.RootTransform.position.x, Context.CharacterShoulderHeight, Context.RootTransform.position.z));

        #region 让手部的IK目标移动到这个最近碰撞点
        // 1. 射线方向：从“最近碰撞点”指向“当前肩部位置”的向量
        Vector3 rayDirection = Context.CurrentShoulderTransform.position
                             - Context.ClosestPointOnColliderFromShoulder;
            // Unity 中向量的运算：Vector3 终点 - Vector3 起点

        // 2. 归一化，得到单位向量
        Vector3 normalizedRayDirection = rayDirection.normalized;

        // 3. 偏移距离，防止手部穿模
        float offsetDistance = 0.05f;

        // 4. 最终要到达的位置：在“最近碰撞点”基础上，加上 沿rayDirection射线方向偏移 offsetDistance 距离
        Vector3 targettPosition = Context.ClosestPointOnColliderFromShoulder 
            + normalizedRayDirection * offsetDistance;

        // 5. 更新 IK 目标位置
        Context.CurrentIkTargetTransform.position = targettPosition;
        #endregion
    }
</code></pre>
<p>如果把权重一开始就拉到1，效果是这样的：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822053849230-836447837.gif" alt="1755812110107" loading="lazy"></p>
<blockquote>
<p>当然，我们还得根据具体的状态写Ik权重的控制脚本</p>
</blockquote>
<h2 id="每个具体状态的ik控制逻辑的脚本编写">每个具体状态的Ik控制逻辑的脚本编写</h2>
<blockquote>
<p>也就是根据状态决定是否/怎样更新手部Two Bone IK Constraint的权重</p>
</blockquote>
<h3 id="1对现有代码进行一些小改动更符合真实世界的运作机制">1.对现有代码进行一些小改动，更符合真实世界的运作机制</h3>
<p><strong>ResetState <code>&lt;-&gt;</code> SearchState</strong>：这个切换不应该是瞬时发生的，应该要加入一个延迟</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234428486-170812543.png" alt="1755813204514" loading="lazy"></p>
<h4 id="1先解决-resetstate---searchstate">1）先解决 <strong>ResetState</strong> <code>-&gt;</code> SearchState</h4>
<pre><code class="language-csharp">    // 持续时间计时器
    float _elapsedTimer = 0.0f;
    // 持续时间的阈值
    float _resetDuration = 2.0f;
</code></pre>
<pre><code class="language-csharp">    public override void EnterState(){
        // 重置 持续时间计时器
        _elapsedTimer = 0.0f;
        // 重置 最近碰撞点 和 当前碰撞体
        Context.ClosestPointOnColliderFromShoulder = Vector3.positiveInfinity;
        Context.CurrentIntersectingCollider = null;
        Debug.Log("ResetState EnterState");
    }
</code></pre>
<pre><code class="language-csharp">    public override void UpdateState() {
        _elapsedTimer += Time.deltaTime;
    }
</code></pre>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState() 
    { 
        bool isMoving = Context.CharacterController.velocity != Vector3.zero;
        //只有当持续时间超过阈值，且角色正在移动时，才会切换到 SearchState
        if(_elapsedTimer &gt; _resetDuration &amp;&amp; isMoving)
        {
            // 下一个状态为 SearchState
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Search;
        }
        return StateKey; 
    }
</code></pre>
<h4 id="2解决-searchstate-的状态跳转">2）解决 <strong>SearchState</strong> 的状态跳转</h4>
<pre><code class="language-csharp">    // 接近碰撞点的距离阈值
    public float _approachDistanceThreshold = 2.0f;
</code></pre>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState()
    {
        // 标志位：是否接近目标
        bool isCloseToTarget = Vector3.Distance(Context.ClosestPointOnColliderFromShoulder, Context.RootTransform.position) &lt; _approachDistanceThreshold;
        // 标志位：是否是最近碰撞点(只要不是无穷大，就是最近碰撞点)
        bool isClosestPointOnColliderValid = Context.ClosestPointOnColliderFromShoulder != Vector3.positiveInfinity;
        // 状态转移到接近状态ApproachState
        if (isCloseToTarget &amp;&amp; isClosestPointOnColliderValid)
        {
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Approach;
        }
        return StateKey;
    }
</code></pre>
<h4 id="3approachstate">3）<strong>ApproachState</strong></h4>
<pre><code class="language-csharp">    // 接近状态的计时器
    float _elapsedTimer = 0.0f;
    // 过渡时间
    float _lerpduration = 5.0f;
    // 接近状态的目标权重
    float _approachWeight = 0.5f;
</code></pre>
<pre><code class="language-csharp">    public override void EnterState() {
        Debug.Log("ApproachState OnTriggerEnter");
        // 重置计时器
        _elapsedTimer = 0.0f;
    }
    public override void ExitState() { }
    public override void UpdateState() { 
        _elapsedTimer += Time.deltaTime;
        // 从当前的权重过渡到接近状态的权重
        Context.CurrentIkConstraint.weight = Mathf.Lerp(Context.CurrentIkConstraint.weight, _approachWeight, _elapsedTimer / _lerpduration);
    }
</code></pre>
<pre><code class="language-csharp">    public override void OnTriggerEnter(Collider other) {
        StartIkTargetPositionTracking(other);
        }
    public override void OnTriggerStay(Collider other) {
        UpdateIkTargetPosition(other);
    }
    public override void OnTriggerExit(Collider other) { 
        ResetIkTargetPositionTracking(other);
    }
</code></pre>
<blockquote>
<p>现在能够在进入ApproachState状态时，随时间从当前的权重平滑过渡到Approach的目标权重</p>
</blockquote>
<h5 id="approachstate状态需要让手部ik在更低的位置">ApproachState状态需要让手部ik在更低的位置</h5>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234429935-1200484482.png" alt="1755849093630" loading="lazy"></p>
<p>以左手为例，面板做如下调整：</p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234430480-402083326.png" alt="1755850535804" loading="lazy"></p>
<blockquote>
<p>开始编写脚本，让进入Approach时手部ik目标高度在角色腰部，也就是角色碰撞体的中心的y轴坐标</p>
</blockquote>
<p>EnvironmentInteractionContext</p>
<pre><code class="language-csharp">    // 交互点的Y轴偏移量，用来细调每个具体状态的交互点的高度
    public float InteractionPoint_Y_Offset { get; set; } = 0.0f;
    // 角色碰撞体的中心点的高度
    public float CharacterColliderCenterY { get; set; }
</code></pre>
<p>EnvironmentInteractionStateMachine 的 ConstructEnvironmentDetectionCollider()</p>
<pre><code class="language-csharp">        _context.CharacterColliderCenterY = characterController.center.y;
</code></pre>
<p>ResetState</p>
<pre><code class="language-csharp">    // 平滑过渡的持续时间
    float _lerpDuration = 10.0f;
</code></pre>
<pre><code class="language-csharp">    public override void UpdateState() {
        _elapsedTimer += Time.deltaTime;
        // 碰撞点的 Y 轴偏移，平滑过渡到角色碰撞体中心的高度
        Context.InteractionPoint_Y_Offset = Mathf.Lerp(Context.InteractionPoint_Y_Offset, Context.CharacterColliderCenterY, _elapsedTimer / _lerpDuration);
    }
</code></pre>
<p>EnvironmentInteractionState 的 SetIkTargetPosition()，y轴方向换成碰撞点的y轴偏移</p>
<pre><code class="language-csharp">        // 5. 更新 IK 目标位置
        Context.CurrentIkTargetTransform.position = 
            new Vector3(
                targettPosition.x,
                Context.InteractionPoint_Y_Offset,
                targettPosition.z);
</code></pre>
<h5 id="approachstate状态需要手腕旋转到让手掌朝向地面也就是multi-rotation-constraint组件需要权重过渡到一个目标值">ApproachState状态需要手腕旋转到让手掌朝向地面，也就是Multi-Rotation Constraint组件需要权重过渡到一个目标值</h5>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234430731-880129709.png" alt="1755850711437" loading="lazy"></p>
<pre><code class="language-csharp">    // 接近状态的IkConstraint目标权重
    float _approachWeight = 0.5f;
    // 接近状态的MultiRotationConstraint目标旋转权重
    float _approachRotationWeight = 0.75f;
    // 旋转速度
    float _rotationSpeed = 500f;
</code></pre>
<pre><code class="language-csharp">    public override void UpdateState() { 
        //目标朝向：让手掌朝向地面，forwad=向下，up=角色的朝向
        Quaternion targetGroundRotation = Quaternion.LookRotation(-Vector3.up, Context.RootTransform.forward);

        _elapsedTimer += Time.deltaTime;
  
        // 控制手腕旋转ik的控制器朝向 旋转到 目标朝向
        Context.CurrentIkTargetTransform.rotation = Quaternion.RotateTowards(
            Context.CurrentIkTargetTransform.rotation, 
            targetGroundRotation, 
            _rotationSpeed * Time.deltaTime);

        // 更新权重：从当前的权重过渡到接近状态的对应权重
        //MultiRotationConstraint：
        Context.CurrentMultiRotationConstraint.weight = Mathf.Lerp(
            Context.CurrentMultiRotationConstraint.weight, 
            _approachRotationWeight, 
            _elapsedTimer / _lerpduration);
        //IkConstraint：
        Context.CurrentIkConstraint.weight = Mathf.Lerp(
            Context.CurrentIkConstraint.weight, 
            _approachWeight, 
            _elapsedTimer / _lerpduration);
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234431004-1710896655.png" alt="1755853694085" loading="lazy"></p>
<h4 id="4-approachstate的切换---risestate--resetstate-有两种切换方式">4） ApproachState的切换 -&gt; RiseState / ResetState (有两种切换方式)</h4>
<h5 id="状态切换">状态切换</h5>
<p>如果继续接近碰撞点到一定距离阈值：ApproachState -&gt; RiseState</p>
<p>如果在ApproachState状态持续时间超过一个阈值：ApproachState -&gt; ResetState</p>
<p><strong>ApproachState</strong></p>
<pre><code class="language-csharp">    // 接近状态持续时间,超过就回到ResetState状态
    float _approachDuration = 2.0f;
</code></pre>
<pre><code class="language-csharp">    // 是否能切换到上升状态的距离阈值
    float _riseDistanceThreshold = 0.5f;
</code></pre>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState()
    {
        // 是否超过Approach状态的持续时间
        bool isOverStateLifeTime = _elapsedTimer &gt; _approachDuration;
        if (isOverStateLifeTime)
        {
            // 切换到Reset状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }

        // 是否在手臂伸手范围内
        bool isWithArmsReach = Vector3.Distance(Context.ClosestPointOnColliderFromShoulder, Context.CurrentShoulderTransform.position) &lt; _riseDistanceThreshold;
        bool isClosestPointOnColliderValid = Context.ClosestPointOnColliderFromShoulder != Vector3.positiveInfinity;
        if (isWithArmsReach &amp;&amp; isClosestPointOnColliderValid)
        {
            // 切换到上升状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Rise;
        }
        return StateKey;
    }
</code></pre>
<h5 id="在resetstate中重置权重">在<strong>ResetState</strong>中重置权重</h5>
<p>UpdateState()</p>
<pre><code class="language-csharp">        // 更新权重：平滑重置当前的权重
        //MultiRotationConstraint：
        Context.CurrentMultiRotationConstraint.weight = Mathf.Lerp(
            Context.CurrentMultiRotationConstraint.weight,
            0,
            _elapsedTimer / _lerpDuration);
        //IkConstraint：
        Context.CurrentIkConstraint.weight = Mathf.Lerp(
            Context.CurrentIkConstraint.weight,
            0,
            _elapsedTimer / _lerpDuration);
</code></pre>
<p>EnvironmentInteractionContext的构造函数加入身体侧边的默认设置，也就是把一侧Rig相关参数传入CurrentXXX参数(CurrentIkConstraint、CurrentMultiRotationConstraint)</p>
<pre><code class="language-csharp">        // 默认设置当前身体的侧边为无穷大
        SetCurrentSide(Vector3.positiveInfinity);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234431325-1263296397.png" alt="1755857122673" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234443296-697202183.gif" alt="1755856962570" loading="lazy"></p>
<h5 id="回到reset之后需要让ik控制器部件也回到原来的position和rotation">回到Reset之后，需要让ik控制器部件也回到原来的position和rotation</h5>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234446752-1388741745.png" alt="1755857362835" loading="lazy"></p>
<p>在<strong>EnvironmentInteractionContext</strong>中记录初始position和rotation信息</p>
<pre><code class="language-csharp">    // 记录初始位置
    private Vector3 _leftOriginalTransformPosition;
    private Vector3 _rightOriginalTransformPosition;
</code></pre>
<p>构造函数中</p>
<pre><code class="language-csharp">        _leftOriginalTransformPosition = _leftIkConstraint.data.target.transform.localPosition;
        _rightOriginalTransformPosition = _rightIkConstraint.data.target.transform.localPosition;
        OriginalTargetRotation = _leftIkConstraint.data.target.rotation;            // 初始的目标旋转(左右侧一样)
</code></pre>
<p>公开属性</p>
<pre><code class="language-csharp">    public Vector3 CurrentOriginalTargetPosition { get; private set; }
    public Quaternion OriginalTargetRotation { get; private set; }
</code></pre>
<p>SetCurrentSide()中赋值</p>
<pre><code class="language-csharp">        //靠近哪边就赋值哪边的Rig相关参数到CurrentXXX参数
        if (isLeftCloser)
        {
            Debug.Log("目标更靠近角色的左侧");
            CurrentBodySide = EBodySide.LEFT;
            CurrentIkConstraint = _leftIkConstraint;
            CurrentMultiRotationConstraint = _leftMultiRotationConstraint;
            CurrentOriginalTargetPosition = _leftOriginalTargetPosition;
        }
        else
        {
            Debug.Log("目标更靠近角色的右侧");
            CurrentBodySide = EBodySide.RIGHT;
            CurrentIkConstraint = _rightIkConstraint;
            CurrentMultiRotationConstraint = _rightMultiRotationConstraint;
            CurrentOriginalTargetPosition = _rightOriginalTargetPosition;
        }
</code></pre>
<p>在<strong>ResetState</strong>中让ik目标控制器部件回到原来的position和rotation</p>
<pre><code class="language-csharp">    // 转向速度
    float _rotationSpeed = 500f;
</code></pre>
<p>UpdateState()</p>
<pre><code class="language-csharp">        // ik目标控制器部件也回到原来的position和rotation
        Context.CurrentIkTargetTransform.localPosition = Vector3.Lerp(
            Context.CurrentIkTargetTransform.localPosition,
            Context.CurrentOriginalTargetPosition,
            _elapsedTimer / _lerpDuration
        );

        Context.CurrentIkTargetTransform.rotation = Quaternion.RotateTowards(
            Context.CurrentIkTargetTransform.rotation,
            Context.OriginalTargetRotation,
            _rotationSpeed * Time.deltaTime
        );
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234448510-1433785513.gif" alt="1755859484290" loading="lazy"></p>
<h4 id="5risestate">5）<strong>RiseState</strong></h4>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234449153-1307563139.png" alt="1755859593481" loading="lazy"></p>
<p>先更新ik目标控制器的y轴高度：</p>
<p><strong>RiseState</strong></p>
<pre><code class="language-csharp">    float _elapsedTimer = 0.0f;         // 已消耗时间，用于控制插值进度
    float _lerpDuration = 5.0f;         // 插值总时长，决定状态过渡的“慢/快”
    float _riseWeight = 1.0f;           // 权重目标值，用于IK和旋转约束的过渡

</code></pre>
<pre><code class="language-csharp">    public override void UpdateState()
    {
        // 1. 碰撞点的y轴高度偏移 平滑更新到 最近碰撞点的Y坐标
        Context.InteractionPoint_Y_Offset = Mathf.Lerp(
            Context.InteractionPoint_Y_Offset,
            Context.ClosestPointOnColliderFromShoulder.y,
            _elapsedTimer / _lerpDuration
        );

        // 2. 更新IK约束CurrentIkConstraint的权重：从当前权重到目标权重_riseWeight
        Context.CurrentIkConstraint.weight = Mathf.Lerp(
            Context.CurrentIkConstraint.weight,
            _riseWeight,
            _elapsedTimer / _lerpDuration
        );

        // 3. 更新多旋转约束CurrentMultiRotationConstraint的权重：从当前权重到目标权重_riseWeight
        Context.CurrentMultiRotationConstraint.weight = Mathf.Lerp(
            Context.CurrentMultiRotationConstraint.weight,
            _riseWeight,
            _elapsedTimer / _lerpDuration
        );

        _elapsedTimer += Time.deltaTime;
    }
</code></pre>
<p>再更新手掌的朝向：</p>
<p><strong>RiseState</strong></p>
<pre><code class="language-csharp">    Quaternion _targetHandRotation;   // 手部的目标旋转角度，用于让手部贴合交互物体表面
    float _maxDistance = 0.5f;         // 射线检测的最大距离
    protected LayerMask _interactableLayerMask = LayerMask.GetMask("Interactable");
    float _rotationSpeed = 1000f;      // 旋转速度
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 计算期望的手部旋转角度，用于让手部贴合交互物体表面
    /// &lt;/summary&gt;
    private void CalculateExpectedHandRotation()
    {
        // 1. 获取起始点（肩部位置）和终点（最近碰撞点）
        Vector3 startPos = Context.CurrentShoulderTransform.position;
        Vector3 endPos = Context.ClosestPointOnColliderFromShoulder;

        // 2. 射线方向：肩部指向碰撞点的归一化方向向量
        Vector3 direction = (endPos - startPos).normalized;

        // 3. 发射射线
        if (Physics.Raycast(startPos, direction, out RaycastHit hit, _maxDistance, _interactableLayerMask))
        {
            // 碰撞点的表面法线
            Vector3 surfaceNormal = hit.normal;

            // 目标朝向：与表面法线相反（让手部朝向碰撞点的表面法线的反方向）
            Vector3 targetForward = -surfaceNormal;

            // 手部的目标旋转方向：与目标朝向相同，但绕着Y轴旋转90度
            _targetHandRotation = Quaternion.LookRotation(targetForward, Vector3.up);
        }
    }

</code></pre>
<p>UpdateState()</p>
<pre><code class="language-csharp">        // 计算期望的手部旋转角度
        CalculateExpectedHandRotation();
</code></pre>
<pre><code class="language-csharp">        // 4. 让 IK目标控制器 朝着 预期的手部旋转角度 平滑旋转
        Context.CurrentIkTargetTransform.rotation = Quaternion.RotateTowards(
            Context.CurrentIkTargetTransform.rotation,
            _targetHandRotation,
            _rotationSpeed * Time.deltaTime
        );
</code></pre>
<h4 id="6risestate-的状态切换---touchstate--resetstate-两种切换方式">6）RiseState 的状态切换 -&gt; TouchState / ResetState (两种切换方式)</h4>
<h5 id="状态切换-1">状态切换</h5>
<p>如果继续接近碰撞点到一定距离阈值：RiseState -&gt; TouchState</p>
<p>如果在RiseState状态持续时间超过一个阈值：RiseState-&gt; ResetState</p>
<p>RiseState</p>
<pre><code class="language-csharp">    // 用于判断是否能够进入TouchState状态的阈值
    float _touchDistanceThreshold = 0.05f;  // TouchState的距离阈值
    float _touchTimeThreshold = 1f;         // TouchState的持续时间阈值
</code></pre>
<pre><code class="language-csharp">    public override void EnterState()
    {
        // 重置计时器
        _elapsedTimer = 0.0f;
    }
</code></pre>
<pre><code class="language-csharp">    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState()
    {
        // 标志位： 是否达到能够Touch的距离阈值
        bool isCloseToTouch = Vector3.Distance(
                Context.CurrentIkTargetTransform.position,
                Context.ClosestPointOnColliderFromShoulder
            ) &lt; _touchDistanceThreshold;
        // 标志位： 是否达到能够Touch的持续时间阈值
        bool isTouchTimeOver = _elapsedTimer &gt;= _touchTimeThreshold;

        if (isCloseToTouch &amp;&amp; isTouchTimeOver)
        {
            // 切换到Touch状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Touch;
        }
        return StateKey;
    }
</code></pre>
<h4 id="7touchstate---resetstate">7）<strong>TouchState</strong> -&gt; ResetState</h4>
<p>切换条件只有时间阈值，超过就切换到ResetState</p>
<pre><code class="language-csharp">using UnityEngine;

public class TouchState : EnvironmentInteractionState
{
    public float _elapsedTime = 0.0f;
    public float _resetThreshold = 0.5f;    // 重置阈值：超过该时长就切换到 Reset 状态

    public TouchState(EnvironmentInteractionContext context,EnvironmentInteractionStateMachine.EEnvironmentInteractionState estate): base(context, estate)
    {
        EnvironmentInteractionContext Context = context; 
    }

    public override void EnterState()
    {
        // 重置计时器
        _elapsedTime = 0.0f;
    }

    public override void ExitState() { }

    public override void UpdateState()
    {
        _elapsedTime += Time.deltaTime;
    }

    public override EnvironmentInteractionStateMachine.EEnvironmentInteractionState GetNextState()
    {
        if (_elapsedTime &gt; _resetThreshold)
        {
            // 切换到 ResetState
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }

        return StateKey;
    }

    public override void OnTriggerEnter(Collider other)
    {
        StartIkTargetPositionTracking(other);
    }
    public override void OnTriggerStay(Collider other)
    {
        UpdateIkTargetPosition(other);
    }
    public override void OnTriggerExit(Collider other)
    {
        ResetIkTargetPositionTracking(other);
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234455646-784167467.gif" alt="1755863473113" loading="lazy"></p>
<h2 id="reset事件的几个触发机制">Reset事件的几个触发机制</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234458156-1818128795.png" alt="1755863775713" loading="lazy"></p>
<p>另加一个可能的情况：角色跳的时候也触发Reset(虽然现在没给角色加入跳跃)</p>
<p>EnvironmentInteractionState</p>
<pre><code class="language-csharp">    private float _movingAwayOffset = 0.005f;       // 远离目标的偏移值

    bool _shouldReset;      // 标志位：是否能够进入ResetState
</code></pre>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// 是否能够进入ResetState
    /// &lt;/summary&gt;
    /// &lt;returns&gt;能够进入时返回 true，否则返回 false&lt;/returns&gt;
    protected bool CheckShouldReset()
    {
        if (_shouldReset)
        {
            // 重置「最近距离」为无穷大
            Context.LowestDistance = Mathf.Infinity;
            // 重置标志位
            _shouldReset = false;
            return true;
        }

        // 标志位：是否停止移动
        bool isPlayerStopped = CheckIsStopped();
        // 标志位：是否正在远离目标交互点
        bool isMovingAway = CheckIsMovingAway();
        // 标志位：是否是非法角度
        bool isInvalidAngle = CheckIsInvalidAngle();
        // 标志位：是否正在跳跃
        bool isPlayerJumping = CheckIsJumping();

        if(isPlayerStopped || isMovingAway || isInvalidAngle || isPlayerJumping)
        {
            // 重置「最近距离」为无穷大
            Context.LowestDistance = Mathf.Infinity;
            return true;
        }

        return false;
    }

</code></pre>
<p>触发机制的检测函数</p>
<pre><code class="language-csharp">    /// &lt;summary&gt;
    /// Reset事件的触发机制1： ———— 玩家是否停止移动
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    protected bool CheckIsStopped()
    {
        bool isPlayerStopped = GameInputManager.MainInstance.Movement == Vector2.zero;
        return isPlayerStopped;
    }
    /// &lt;summary&gt;
    /// Reset事件的触发机制2： ———— 玩家是否正在远离目标交互点
    /// &lt;/summary&gt;
    /// &lt;returns&gt;玩家远离目标时返回 true，否则返回 false&lt;/returns&gt;
    protected bool CheckIsMovingAway()
    {
        // 1. 角色根节点到目标碰撞点的当前距离
        float currentDistanceToTarget = Vector3.Distance(
            Context.RootTransform.position,
            Context.ClosestPointOnColliderFromShoulder
        );

        // 标志位：是否正在搜索新的交互点
        bool isSearchingForNewInteraction = Context.CurrentIntersectingCollider == null;
        if (isSearchingForNewInteraction)
        {
            return false;
        }

        // 标志位：是否在靠近目标
        bool isGettingCloserToTarget = currentDistanceToTarget &lt;= Context.LowestDistance;
        if (isGettingCloserToTarget)
        {
            // 更新最近距离
            Context.LowestDistance = currentDistanceToTarget;
            // 未远离
            return false;
        }

        // 标志位：是否已远离目标（当前距离超过「最近距离 + 偏移值」）
        bool isMovingAwayFromTarget = currentDistanceToTarget &gt; Context.LowestDistance + _movingAwayOffset;
        if (isMovingAwayFromTarget)
        {
            // 标记为远离，重置「最近距离」（下次重新开始计算）
            Context.LowestDistance = Mathf.Infinity;
            // 远离
            return true;
        }

        return false;
    }
    /// &lt;summary&gt;
    /// Reset事件的触发机制3： ———— 当前交互的角度是否为“非法角度”
    /// &lt;/summary&gt;
    /// &lt;returns&gt;如果是非法角度返回 true，否则返回 false&lt;/returns&gt;
    protected bool CheckIsInvalidAngle()
    {
        // 如果当前交互的碰撞体为空，直接判定不是不良角度
        if (Context.CurrentIntersectingCollider == null)
        {
            return false;
        }

        // 计算从肩部指向碰撞点的方向向量
        Vector3 targetDirection = Context.ClosestPointOnColliderFromShoulder
                                 - Context.CurrentShoulderTransform.position;

        // 根据身体侧别（左/右）确定肩部的参考方向
        Vector3 shoulderDirection = (Context.CurrentBodySide == EnvironmentInteractionContext.EBodySide.RIGHT) ?
            Context.RootTransform.right
            : -Context.RootTransform.right;

        // 计算肩部参考方向与目标方向的点积（用于判断夹角方向）
        float dotProduct = Vector3.Dot(shoulderDirection, targetDirection.normalized);

        // 非法角度 = 点积小于 0 (目标方向与肩部参考方向夹角大于 90 度)
        bool isInvalidAngle = dotProduct &lt; 0;

        return isInvalidAngle;
    }
    /// &lt;summary&gt;
    /// Reset事件的触发机制4： ———— 玩家是否正在跳跃
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    protected bool CheckIsJumping()
    {
        bool isPlayerJumping = Mathf.Round(Context.CharacterController.velocity.y) &gt;= 1;
        return isPlayerJumping;
    }
</code></pre>
<p>在每个状态的状态切换函数GetNextState()中加入 切换到ResetState的触发条件</p>
<p>SearchState</p>
<pre><code class="language-csharp">        if (CheckShouldReset())
        {
            // 切换到Reset状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }
</code></pre>
<p>ApproachState</p>
<pre><code class="language-csharp">        if (isOverStateLifeTime || CheckShouldReset())
        {
            // 切换到Reset状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }
</code></pre>
<p>RiseState</p>
<pre><code class="language-csharp">        if (CheckShouldReset())
        {
            // 切换到Reset状态
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }
</code></pre>
<p>TouchState</p>
<pre><code class="language-csharp">        if (_elapsedTime &gt; _resetThreshold || CheckShouldReset())
        {
            // 切换到 ResetState
            return EnvironmentInteractionStateMachine.EEnvironmentInteractionState.Reset;
        }
</code></pre>
<blockquote>
<p>找到了之前从ResetState切换到SearchState一直响应慢的问题根源：</p>
<p><strong>动画根运动驱动，需要用输入来判断是否在移动</strong></p>
</blockquote>
<p><strong>ResetState</strong>的GetNextState()函数</p>
<pre><code class="language-csharp">        // 标志位：是否正在移动(是否有Movement输入)
        bool isMoving = GameInputManager.MainInstance.Movement != Vector2.zero;
</code></pre>
<h2 id="最终效果如下">最终效果如下：</h2>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234515732-41602954.gif" alt="1755877190523" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3614909/202508/3614909-20250822234538535-686840099.gif" alt="1755877441326" loading="lazy"></p>
<p>我的评价是很丝滑很自然，这是我做过细节最多最复杂的动作拆解系统</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-08-24 16:23">2025-08-24 16:20</span>&nbsp;
<a href="https://www.cnblogs.com/eanojiang">EanoJiang</a>&nbsp;
阅读(<span id="post_view_count">89</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19051898);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19051898', targetLink: 'https://www.cnblogs.com/eanojiang/p/19051898', title: '(已完结)仿神秘海域/美末环境交互的程序化动画学习' })">举报</a>
</div>
        