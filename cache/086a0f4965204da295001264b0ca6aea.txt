<!----> <meta itemprop="headline" content="用好了 defineProps 才叫会用 Vue3，90% 的写法都错了"> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"> <meta itemprop="datePublished" content="2025-06-09T02:13:07.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用好了 defineProps 才叫会用 Vue3，90% 的写法都错了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-06-09T02:13:07.000Z" title="Mon Jun 09 2025 02:13:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-06-09
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    10,639
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>Vue 3 的 <code>Composition API</code> 给开发者带来了更强的逻辑组织能力，但很多人用 <code>defineProps</code> 的方式，依然停留在 Vue 2 的“Options 语法心智”。本质上只是把 <code>props: {}</code> 拿出来“提前声明”，并没有真正理解它的运行机制、类型推导优势、默认值处理方式、解构陷阱等关键点。</p>
<p>这篇文章不做语法搬运，而是用实战视角，带你了解：<strong>defineProps 到底该怎么写，才是专业的 Vue3 写法。</strong></p>
<hr>
<h2 data-id="heading-0">🎯 为什么说你用错了 defineProps？</h2>
<p>我们先来看一个常见的 Vue3 组件写法：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">count</span>: <span class="hljs-title class_">Number</span>
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>你以为这就完事了？它只是基本写法。但在真实业务中，我们往往会遇到：</p>
<ul>
<li>需要传默认值</li>
<li>想要类型推导</li>
<li>解构 props 却发现响应性丢失</li>
<li>TS 类型重复声明，不够优雅</li>
</ul>
<p><strong>这些问题，defineProps 其实早就帮你解决了，只是你没用对方式。</strong></p>
<hr>
<h2 data-id="heading-1">✅ 正确的三种 defineProps 写法</h2>
<h3 data-id="heading-2">① 写法一：<strong>声明式类型推导（推荐）</strong></h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span> {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
  count?: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">const</span> props = defineProps&lt;<span class="hljs-title class_">Props</span>&gt;()
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>自动获得类型推导</li>
<li>在 <code>&lt;script setup lang="ts"&gt;</code> 中书写自然</li>
<li>可配合 <code>withDefaults</code> 补充默认值</li>
</ul>
<blockquote>
<p>这是 Composition API 的推荐写法，完全由 TypeScript 驱动，而不是运行时校验。</p>
</blockquote>
<hr>
<h3 data-id="heading-3">② 写法二：<strong>运行时代码校验（Options 式）</strong></h3>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">props</span> = <span class="hljs-title function_ invoke__">defineProps</span>({
  <span class="hljs-attr">title</span>: {
    <span class="hljs-attr">type</span>: String,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">count</span>: {
    <span class="hljs-attr">type</span>: Number,
    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>
  }
})
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>保留 Vue2 的 props 校验逻辑</li>
<li>更适合 JS-only 项目（不使用 TS）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>类型推导不如泛型直观</li>
<li>与 <code>withDefaults</code> 不兼容</li>
</ul>
<hr>
<h3 data-id="heading-4">③ 写法三：<strong>与 <code>withDefaults</code> 配合（实战最常见）</strong></h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">withDefaults</span>(defineProps&lt;{
  title?: <span class="hljs-built_in">string</span>
  count?: <span class="hljs-built_in">number</span>
}&gt;(), {
  <span class="hljs-attr">title</span>: <span class="hljs-string">'默认标题'</span>,
  <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>
})
</code></pre>
<p><strong>优势是：</strong></p>
<ul>
<li>既能获得类型推导，又能写默认值</li>
<li>不会重复写 default</li>
<li>比纯 defineProps 更简洁易维护</li>
</ul>
<blockquote>
<p>注意：<strong>withDefaults 只能配合泛型式 defineProps 使用，不能和对象式 props 写法混用。</strong></p>
</blockquote>
<hr>
<h2 data-id="heading-5">⚠️ 高发误区警告：你踩过几个？</h2>
<h3 data-id="heading-6">🚫 误区 1：直接解构 props，响应性丢失</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> { title, count } = defineProps&lt;{ <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> }&gt;()
</code></pre>
<p>上面的写法会让 <code>title</code> 和 <code>count</code> 成为普通变量，<strong>不是响应式的</strong>。</p>
<p><strong>解决方式</strong>：使用 <code>toRefs</code></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> props = defineProps&lt;{ <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> }&gt;()
<span class="hljs-keyword">const</span> { title, count } = <span class="hljs-title function_">toRefs</span>(props)
</code></pre>
<p>这样才能在 <code>watch(title, ...)</code> 中有效监听变化。</p>
<hr>
<h3 data-id="heading-7">🚫 误区 2：类型和默认值重复声明</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">const</span> props = defineProps({
  title: {
    type: String <span class="hljs-keyword">as</span> PropType&lt;<span class="hljs-built_in">string</span>&gt;, <span class="hljs-comment">// 写了类型</span>
    <span class="hljs-literal">default</span>: <span class="hljs-string">'Hello'</span> <span class="hljs-comment">// 又写默认值</span>
  }
})
</code></pre>
<p>在 TS 项目中，这种方式显得繁琐且不智能。<strong>建议直接用泛型 + withDefaults</strong>，让 IDE 自动推导类型。</p>
<hr>
<h3 data-id="heading-8">🚫 误区 3：没有区分“开发期类型检查” vs “运行时校验”</h3>
<p>Vue3 的 Props 有两个模式：</p>
<ul>
<li>TypeScript 模式：靠 IDE + 编译器</li>
<li>Options 模式：在浏览器运行时报错</li>
</ul>
<p><strong>实际推荐：生产环境靠 TypeScript 检查即可，无需运行时 Props 校验，提高性能。</strong></p>
<hr>
<h2 data-id="heading-9">🎯 defineProps 是真正的组件契约声明</h2>
<p>在 Vue3 的 <code>&lt;script setup&gt;</code> 中，<code>defineProps</code> 就是<strong>你和使用你组件的人之间的契约</strong>。</p>
<h3 data-id="heading-10">为什么说它是契约？</h3>
<ul>
<li>它声明了组件的“输入规范”</li>
<li>它决定了类型校验、默认值逻辑</li>
<li>它是组件文档的第一手来源</li>
</ul>
<p>你越是随便写它，越容易在团队协作时踩坑。</p>
<hr>
<h2 data-id="heading-11">💡 defineProps 的进阶技巧：你未必知道的几个点</h2>
<h3 data-id="heading-12">✔ 你可以在 defineProps 里使用类型别名</h3>
<pre><code class="hljs language-matlab" lang="matlab"><span class="hljs-built_in">type</span> Size = <span class="hljs-string">'sm'</span> | <span class="hljs-string">'md'</span> | <span class="hljs-string">'lg'</span>

withDefaults(defineProps&lt;{
  <span class="hljs-built_in">size</span>?: Size
}&gt;(), {
  <span class="hljs-built_in">size</span>: <span class="hljs-string">'md'</span>
})
</code></pre>
<p>这是让 <code>props.size</code> 具备完整类型提示的关键方式。</p>
<hr>
<h3 data-id="heading-13">✔ 配合 <code>defineEmits</code> 写法更完整</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> emit = defineEmits&lt;{
  (<span class="hljs-attr">e</span>: <span class="hljs-string">'submit'</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>
  (<span class="hljs-attr">e</span>: <span class="hljs-string">'cancel'</span>): <span class="hljs-built_in">void</span>
}&gt;()
</code></pre>
<p>这样写出的组件，<strong>输入（props）+ 输出（emit）都具备契约</strong>，可以被任何 IDE 精确识别。</p>
<hr>
<h3 data-id="heading-14">✔ defineProps 写法决定你能不能使用 Volar 的类型推导</h3>
<p>很多人发现 <code>&lt;MyComponent :title="xx" /&gt;</code> 里没有类型提示，大概率是你组件没有正确写 defineProps 的泛型。保持结构清晰，是让 IDE 吃得饱的唯一方式。</p>
<hr>
<h2 data-id="heading-15">🚀 小结：defineProps 不只是 props，它是组件健壮性的开端</h2>





























<table><thead><tr><th>错误写法</th><th>问题</th></tr></thead><tbody><tr><td>不加泛型</td><td>IDE 无法提示</td></tr><tr><td>直接解构</td><td>响应性丢失</td></tr><tr><td>类型 + default 双声明</td><td>代码重复、难维护</td></tr><tr><td>没有 withDefaults</td><td>写默认值繁琐、不能配合类型推导</td></tr><tr><td>使用 runtime 校验 + TS</td><td>混乱、效率低</td></tr></tbody></table>
<p><strong>正确思路是</strong>：在 TypeScript 项目中，尽可能采用 <code>defineProps&lt;T&gt;() + withDefaults()</code> 写法，做到类型明确、默认值清晰、响应式安全。</p>
<hr>
<h2 data-id="heading-16">📌 怎么判断你是否“真的会用 defineProps”？</h2>
<ul>
<li>❌ 你写了 defineProps 但 props 解构不响应</li>
<li>❌ 你写 default 写得很痛苦</li>
<li>❌ 你项目里 props 写法风格混乱</li>
<li>❌ 你的组件在 IDE 中没有 props 自动补全</li>
</ul>
<p>✅ 如果你能做到：</p>
<ul>
<li>使用泛型 + <code>withDefaults</code></li>
<li>保持 props 和 emits 的契约完整</li>
<li>清晰地类型提示和响应性解构</li>
</ul>
<p>那恭喜你，是真的理解了 Vue3 的组件心智模型。</p></div></div>