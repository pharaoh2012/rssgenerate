
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangSir-devops/p/18859218" title="发布于 2025-05-04 22:07">
    <span role="heading" aria-level="2">K8s新手系列之ReplicationController资源</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="概述">概述</h2>
<p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/</a></p>
<p><strong>ReplicationController 是一个比较原始的Pod控制器，已经被废弃，由ReplicaSet控制器替代，想要了解ReplicaSet可查看这篇文章：</strong><a href="https://www.cnblogs.com/huangSir-devops/p/18859229" title="K8s新手系列之ReplicaSet资源" target="_blank">K8s新手系列之ReplicaSet资源</a></p>
<p><code>ReplicationController</code>简称<code>rc</code>，称为副本控制器，其主要作用就是控制Pod副本数量的控制器。</p>
<p>ReplicationController 确保在任何时候都有特定数量的 Pod 副本处于运行状态。只要 ReplicationController 不删除，则指定的Pod数量会使用存活。</p>
<h2 id="replicationcontroller的作用">ReplicationController的作用</h2>
<ul>
<li>
<p>副本管理：ReplicationController 的核心功能是保证在任何时候都有指定数量的 Pod 副本在运行。如果有 Pod 意外终止，ReplicationController 会自动创建新的 Pod 来替代它；如果 Pod 数量过多，它会删除多余的 Pod。</p>
</li>
<li>
<p>滚动更新：在早期版本中，虽然 ReplicationController 本身不支持滚动更新，但可以通过创建新的 ReplicationController 并逐步减少旧的 ReplicationController 中的 Pod 数量来实现类似滚动更新的效果。</p>
</li>
<li>
<p>集群扩容和缩容：用户可以通过修改 ReplicationController 中的副本数量来轻松地对应用进行扩容或缩容。</p>
</li>
</ul>
<h2 id="replicationcontroller资源配置文件详解">ReplicationController资源配置文件详解</h2>
<p>可以通过<code>kubectl explain rc</code>查看创建ReplicationController需要的字段</p>
<p>示例：</p>
<pre><code>[root@node01 ~]# kubectl explain rc
KIND:     ReplicationController
VERSION:  v1

DESCRIPTION:
     ReplicationController represents the configuration of a replication
     controller.

# fileds字段中的内容已进行截取
FIELDS:
   apiVersion   &lt;string&gt;
     
   kind &lt;string&gt;

   metadata     &lt;Object&gt;

   spec &lt;Object&gt;

   status       &lt;Object&gt;
</code></pre>
<p>通过上述可以发现定义ReplicationController的资源文件和定义Pod一样，也需要apiVersion、kind、metadata、spec等字段。</p>
<p>但是spec字段中有三个字段，需要注意，分别是replicas、selector、template。如下：</p>
<pre><code>[root@node01 ~]# kubectl explain rc.spec
KIND:     ReplicationController
VERSION:  v1

RESOURCE: spec &lt;Object&gt;

DESCRIPTION:
     Spec defines the specification of the desired behavior of the replication
     controller. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

     ReplicationControllerSpec is the specification of a replication controller.

FIELDS:
   minReadySeconds      &lt;integer&gt;
   # minReadySeconds 规定了一个时间阈值，只有当 Pod 保持就绪状态的时间达到或者超过这个阈值，并且在此期间 Pod 内的任何容器都没有崩溃，这个 Pod 才会被视为可用。
   
   replicas     &lt;integer&gt;
   # 定义Pod的副本数量
   
   selector     &lt;map[string]string&gt;
   # 标签选择器，这里指定Pod定义的标签
   
   template     &lt;Object&gt;
   # 定义Pod的模板
</code></pre>
<h2 id="创建replicationcontroller">创建ReplicationController</h2>
<p>这里我们创建三个Pod副本</p>
<p>示例：</p>
<pre><code># 定义rc清单文件
[root@node01 ~/rc]# cat rc-nginx.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: rc-nginx-1
  namespace: default
  labels:
    app: rc-nginx
spec:
  # 定义Pod的副本数量
  replicas: 3
  # 标签选择器，这里和Pod的Label保持一致
  selector:
    app: nginx
  # 定义Pod的模板，只需要定义metadata和spec两个字段即可
  template:
    metadata:
      name: pod-nginx
      labels:
        app: nginx
    spec:
      restartPolicy: Always
      containers:
      - name: nginx
        image: nginx:latest
      restartPolicy: Always

# 创建rc
[root@node01 ~/rc]# kubectl apply -f rc-nginx.yaml
replicationcontroller/rc-nginx-1 created
</code></pre>
<h3 id="查看replicationcontroller和对应的pod">查看ReplicationController和对应的Pod</h3>
<p>查看ReplicationController</p>
<pre><code>[root@node01 ~/rc]# kubectl get rc -o wide
NAME         DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR
rc-nginx-1   3         3         3       45s   nginx        nginx:latest   app=nginx
</code></pre>
<p>查看对应Pod</p>
<pre><code>[root@node01 ~/rc]# kubectl get po | grep rc-nginx
rc-nginx-1-8ptc7       1/1     Running            0                2m38s
rc-nginx-1-8xvbr       1/1     Running            0                2m38s
rc-nginx-1-lk45f       1/1     Running            0                2m38s
</code></pre>
<h2 id="验证replicationcontroller的副本管理">验证ReplicationController的副本管理</h2>
<p>ReplicationController 的核心功能是保证在任何时候都有指定数量的 Pod 副本在运行。如果有 Pod 意外终止，ReplicationController 会自动创建新的 Pod 来替代它；如果 Pod 数量过多，它会删除多余的 Pod。</p>
<p>当我们删除创建好的Pod时，ReplicationController会发生什么呢？</p>
<pre><code># 删除上面创建Pod
[root@node01 ~/rc]# kubectl delete po rc-nginx-1-8ptc7 rc-nginx-1-8xvbr rc-nginx-1-lk45f
pod "rc-nginx-1-8ptc7" deleted
pod "rc-nginx-1-8xvbr" deleted
pod "rc-nginx-1-lk45f" deleted

# 查看rc，发现其副本数量还是三个
[root@node01 ~/rc]# kubectl get rc
NAME         DESIRED   CURRENT   READY   AGE
rc-nginx-1   3         3         3       6m11s

# 查看Pod，发现对应的Pod还是三个
[root@node01 ~/rc]# kubectl get po | grep rc-nginx
rc-nginx-1-g6qvg       1/1     Running            0                18s
rc-nginx-1-gwzd4       1/1     Running            0                18s
rc-nginx-1-x2rqm       1/1     Running            0                19s

</code></pre>
<p>通过上述验证，当Pod被意外终止时，ReplicationController会自动创建它</p>
<h2 id="验证replicationcontroller的扩缩容">验证ReplicationController的扩缩容</h2>
<h3 id="验证扩容">验证扩容</h3>
<p>我们将副本数量调整成5，看看会发生什么？</p>
<pre><code>[root@node01 ~/rc]# cat rc-nginx.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: rc-nginx-1
  namespace: default
  labels:
    app: rc-nginx
spec:
  # 将副本数量调整成5
  replicas: 5
  selector:
    app: nginx
  template:
    metadata:
      name: pod-nginx
      labels:
        app: nginx
    spec:
      restartPolicy: Always
      containers:
      - name: nginx
        image: nginx:latest
      restartPolicy: Always

# 重新应用它
[root@node01 ~/rc]# kubectl apply -f rc-nginx.yaml
replicationcontroller/rc-nginx-1 configured
</code></pre>
<p>查看一下：</p>
<pre><code># 查看rc
[root@node01 ~/rc]# kubectl get rc
NAME         DESIRED   CURRENT   READY   AGE
rc-nginx-1   5         5         5       11m
# 查看pod
[root@node01 ~/rc]# kubectl get po | grep rc-nginx
NAME                   READY   STATUS             RESTARTS         AGE
rc-nginx-1-7dnlv       1/1     Running            0                87s
rc-nginx-1-dsr6h       1/1     Running            0                87s
rc-nginx-1-g6qvg       1/1     Running            0                6m55s
rc-nginx-1-gwzd4       1/1     Running            0                6m55s
rc-nginx-1-x2rqm       1/1     Running            0                6m56s
</code></pre>
<p>通过上述发现Pod副本数量由3个变成了5个，查看AGE字段，发现有两个Pod是新建的状态。</p>
<h3 id="验证缩容">验证缩容</h3>
<p>同理，我们将副本数量调整成1，看看会发生什么？</p>
<pre><code>[root@node01 ~/rc]# cat rc-nginx.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: rc-nginx-1
  namespace: default
  labels:
    app: rc-nginx
spec:
  # 将副本数量调整成1
  replicas: 1
  selector:
    app: nginx
  template:
    metadata:
      name: pod-nginx
      labels:
        app: nginx
    spec:
      restartPolicy: Always
      containers:
      - name: nginx
        image: nginx:latest
      restartPolicy: Always

# 重新应用它
[root@node01 ~/rc]# kubectl apply -f rc-nginx.yaml
replicationcontroller/rc-nginx-1 configured
</code></pre>
<p>查看一下</p>
<pre><code># 查看rc
[root@node01 ~/rc]# kubectl get rc
NAME         DESIRED   CURRENT   READY   AGE
rc-nginx-1   1         1         1       15m
# 查看Pod
[root@node01 ~/rc]# kubectl get po | grep rc-nginx
rc-nginx-1-x2rqm       1/1     Running            0               9m32s
</code></pre>
<p>通过上述发现，Pod数量由5个缩减成了1个</p>
<h2 id="验证replicationcontroller的滚动更新">验证ReplicationController的滚动更新</h2>
<p>早期版本中，虽然 ReplicationController 本身不支持滚动更新，但可以通过创建新的 ReplicationController 并逐步减少旧的 ReplicationController 中的 Pod 数量来实现类似滚动更新的效果。</p>
<p>示例：将上述案例中的Pod的镜像替换成tomcat</p>
<pre><code>[root@node01 ~/rc]# cat rc-nginx.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: rc-nginx-1
  namespace: default
  labels:
    app: rc-nginx
spec:
  # 将副本数量调整成5
  replicas: 5
  selector:
    app: nginx
  template:
    metadata:
      name: pod-nginx
      labels:
        app: nginx
    spec:
      restartPolicy: Always
      containers:
      - name: nginx
        # 将镜像替换成tomcat
        image: tomcat:latest
      restartPolicy: Always

# 重新应用它
[root@node01 ~/rc]# kubectl apply -f rc-nginx.yaml
replicationcontroller/rc-nginx-1 configured
</code></pre>
<p>查看Pod变化</p>
<pre><code># 第一次查看
[root@node01 ~/rc]# kubectl get po
NAME                   READY   STATUS              RESTARTS         AGE
rc-nginx-1-gvdwl       0/1     ContainerCreating   0                2s
rc-nginx-1-rtdlw       0/1     ContainerCreating   0                2s
rc-nginx-1-vzfb2       0/1     ContainerCreating   0                2s
rc-nginx-1-x2rqm       1/1     Running             0                15m
rc-nginx-1-zwms9       0/1     ContainerCreating   0                2s

# 最后查看
[root@node01 ~/rc]# kubectl get po
NAME                   READY   STATUS             RESTARTS         AGE
pod-evc-secret-1       0/1     CrashLoopBackOff   68 (3m39s ago)   21h
rc-nginx-1-gvdwl       1/1     Running            0                71s
rc-nginx-1-rtdlw       1/1     Running            0                71s
rc-nginx-1-vzfb2       1/1     Running            0                71s
rc-nginx-1-wscvf       0/1     ContainerCreating  0                3s
rc-nginx-1-zwms9       1/1     Running            0                71s
</code></pre>
<p>发现Pod在逐步替换，可以访问一下对应Pod试一下，发现返回的内容是Tomcat的内容<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504140032861-685233018.png" alt="image" loading="lazy"></p>
<h3 id="滚动更新的原理">滚动更新的原理</h3>
<p>滚动更新的核心目标是在不中断服务的前提下，逐步将旧版本的应用替换为新版本。在使用 ReplicationController 时，这一过程主要通过以下几个步骤完成：</p>
<ol>
<li>
<p>创建新版本的 ReplicationController<br>
当需要对应用进行更新时，首先要创建一个新的 ReplicationController，其配置与旧的 ReplicationController 基本相同，但使用了新版本的应用镜像。新的 ReplicationController 初始的副本数量通常设置为 0。</p>
</li>
<li>
<p>逐步增加新版本的 Pod 副本数量<br>
在创建好新的 ReplicationController 后，逐步增加其管理的 Pod 副本数量。每次增加少量副本（例如每次增加 1 个），这样可以确保新的 Pod 有足够的时间启动并稳定运行，避免一次性创建大量新 Pod 导致资源紧张或服务不稳定。</p>
</li>
<li>
<p>逐步减少旧版本的 Pod 副本数量<br>
在增加新版本 Pod 副本数量的同时，逐步减少旧的 ReplicationController 管理的 Pod 副本数量。同样，每次减少少量副本，以保证服务的连续性。</p>
</li>
<li>
<p>重复步骤 2 和 3<br>
不断重复增加新版本 Pod 副本数量和减少旧版本 Pod 副本数量的过程，直到旧版本的 ReplicationController 管理的 Pod 副本数量降为 0，而新版本的 ReplicationController 管理的 Pod 副本数量达到预期值。</p>
</li>
</ol>
<h2 id="管理replicationcontroller">管理ReplicationController</h2>
<h3 id="查看replicationcontroller">查看ReplicationController</h3>
<p>语法：</p>
<pre><code>kubectl get rc &lt;rc-name&gt; -n &lt;namespace-name&gt;
</code></pre>
<p>示例：</p>
<pre><code>[root@node01 ~/rc]# kubectl get rc
NAME         DESIRED   CURRENT   READY   AGE
rc-nginx-1   5         5         5       29m
</code></pre>
<h3 id="修改replicationcontroller">修改ReplicationController</h3>
<p>由两种方式，一种是通过<code>kubectl edit rc &lt;rc-name&gt;</code>来进行修改，会打开一个类似<code>vim</code>的界面，修改其对应的值即可，最后<code>wq</code>保存即可应用你的配置<br>
<img src="https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504140330006-1592142854.png" alt="image" loading="lazy"></p>
<p>第二种方式则是修改对应的资源文件，最后使用<code>kubectl apply -f &lt;file&gt;</code>即可</p>
<h3 id="删除replicationcontroller">删除ReplicationController</h3>
<p>删除ReplicationController时会删除所有对应的Pod！！！</p>
<p>语法：</p>
<pre><code>kubectl delete rc &lt;rc-name&gt; -n &lt;namespace-name&gt;
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/huangSir-devops/" target="_blank">huangSir-devops</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/huangSir-devops/p/18859218" target="_blank">https://www.cnblogs.com/huangSir-devops/p/18859218</a>，微信Vac666666，欢迎交流</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0045628879560185185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-04 22:08">2025-05-04 22:07</span>&nbsp;
<a href="https://www.cnblogs.com/huangSir-devops">huangSir-devops</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18859218);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18859218', targetLink: 'https://www.cnblogs.com/huangSir-devops/p/18859218', title: 'K8s新手系列之ReplicationController资源' })">举报</a>
</div>
        