
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zuowj/p/18737399" title="发布于 2025-02-25 23:24">
    <span role="heading" aria-level="2">事务中无法切换数据源？DataSourceSwitchInvoker：轻松实现多数据源切换执行工具类</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="背景">背景：</h3>
<p>在有标注为@Transactional的类或公共方法中（传播特性，如：NOT_SUPPORTED、SUPPORTS、REQUIRED【默认值】、REQUIRES_NEW）执行数据源切换可能不成功（比如：主从数据源切换，多数据源切换等，均会发现切换不成功，或“偶尔又切换成功”），导致本应该需要查主库却查了从库，本应该查B库却仍查了A库导致表不存在等各种查询问题。</p>
<h3 id="原因是什么呢">原因是什么呢？</h3>
<p>本质原因是：因为只要添加了@Transactional （传播特性，如：NOT_SUPPORTED、SUPPORTS、REQUIRED【默认值】、REQUIRES_NEW），在事务同步上下文类型为：SYNCHRONIZATION_ALWAYS时 ，那么会在事务切面中进行初始化事务同步上下文状态【prepareTransactionStatus】（具体可分析代码位置：org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction），此时org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive 是true，若需要事务时（EQUIRED【默认值】、REQUIRES_NEW）则还会org.springframework.transaction.support.AbstractPlatformTransactionManager#doBegin获取connection并开启事务且构建ConnectionHolder注册保存于事务同步上下文中，当mybatis 的SqlSessionTemplate.SqlSessionInterceptor.invoke执行时，第一次会将获取的SqlSession通过SqlSessionUtils.registerSessionHolder注册保存于事务同步上下文中，后续只要是同一个SqlSession，那么间接的就是持有同一个SpringManagedTransaction，SpringManagedTransaction是优先从ConnectionHolder获取已有connection对象，若不存在才会创建新的connection对象，并构建ConnectionHolder注册保存于事务同步上下文中，后续<strong>只要是在同一个事务同步上下文中，那么都是复用相同的SqlSession、SpringManagedTransaction、ConnectionHolder，所以单纯的改DataSource（ThreadLocal的线程变量）没有用，因为此时ConnectionHolder中保存的是Connection，而不是DataSource</strong></p>
<h3 id="spring声明式事务源代码分析流程图">Spring声明式事务源代码分析流程图</h3>
<p><img src="https://img2024.cnblogs.com/blog/458152/202502/458152-20250225225900185-951435957.jpg" alt="" loading="lazy"></p>
<h4 id="为何偶尔切换数据源成功"><strong>为何偶尔切换数据源成功？</strong></h4>
<p>当为事务传播特性为NOT_SUPPORTED、SUPPORTS时，由于此时事务管理器并不会提前打开Conneciton并开启事务（即：也不会保存到ConnectionHolder）【从上图中就可以看出】，而是在执行一条SQL语句时，触发了MyBatis的第一次获取SqlSession，间接的执行了DataSourceUtils.doGetConnection（会保存到ConnectionHolder中），如果在方法中的执行第一条SQL语句前进行数据源切换，那么就可以生效，若在执行第一条SQL语句后再尝试切换，那么由于SqlSession已不是最新的（ConnectionHolder中已有Connection），则只会复用。</p>
<h3 id="解决方案">解决方案：</h3>
<p>新增数据源切换执行器工具类：DataSourceSwitchInvoker，作用：在执行前会检查要切换的数据源与当前已持有的数据源（ConnectionHolder.Connection）是否一致，一致则直接执行回调方法（即：不存在切换数据源），不一致则挂起当前事务（挂事务与资源后，会清空事务同步上下文，就像从来没有执行过事务方法一样，默认状态），然后执行回调方法，最后恢复被挂起的事务与资源，并恢复回执行前的数据源设置。即：相当于在事务执行过程中，撕开一个口子（无任何状态），执行完成后，再恢复回事务的原状态，不影响后续的执行。</p>
<h3 id="datasourceswitchinvokerinvokeon-代码逻辑流程图">DataSourceSwitchInvoker.invokeOn 代码逻辑流程图：</h3>
<p>（注：图片部份位置有屏蔽删减是因为我实现了多个版本，本次是简化实用版，无需复杂的设置，直接方法入参传入即可）<br>
<img src="https://img2024.cnblogs.com/blog/458152/202502/458152-20250225231014358-1619145746.jpg" alt="" loading="lazy"></p>
<h4 id="datasourceswitchinvoker-实现code">DataSourceSwitchInvoker 实现CODE:</h4>
<pre><code class="language-java">
/**
 * @author: zuowenjun
 * @description:数据源切换后执行器，解决在多数据源项目中，无法在事务方法中进行数据源切换问题
 */
@Component
public class DataSourceSwitchInvoker {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceSwitchInvoker.class);

    private static final Map&lt;String, String&gt; DATA_SOURCE_NAME_WITH_URL_MAP = new HashMap&lt;&gt;();

    private static final String SET_BEFORE = "BEFORE";
    private static final String SET_AFTER = "AFTER";


    @Value("${dataSourceSwitchInvoker.settings.datasourceJdbcUrlPattern:}")
    private String datasourceJdbcUrlPattern;

    /**
     * 初始化必要条件：数据源配置集合（数据源名称与jdbcUrl对应关系）
     */
    @PostConstruct
    public void initializeRequirement() {
        if (StringUtils.isBlank(datasourceJdbcUrlPattern)) {
            LOGGER.warn("datasourceJdbcUrlPattern is null");
            return;
        }

        DATA_SOURCE_NAME_WITH_URL_MAP.clear();

        Map&lt;String, String&gt; configMap = getPropertiesByPattern(datasourceJdbcUrlPattern, value -&gt; ObjectUtils.defaultIfNull(value, "").toString().trim(), (k, v) -&gt; StringUtils.isNotEmpty(v));

        if (MapUtils.isEmpty(configMap)) {
            LOGGER.error("DataSourceSwitchInvoker.initializeRequirement configMap is empty ,datasourceJdbcUrlPattern: {}", datasourceJdbcUrlPattern);
            return;
        }

        DATA_SOURCE_NAME_WITH_URL_MAP.putAll(configMap);

        LOGGER.info("DataSourceSwitchInvoker.initializeRequirement ok");
    }



    /**
     * 在指定的数据源下执行回调方法
     *
     * @param getCurrentDsNameFunc
     * @param setCurrentDsNameFunc
     * @param invokeCallback
     * @return
     */
    public static &lt;T&gt; T invokeOn(String newDataSourceName, Supplier&lt;String&gt; getCurrentDsNameFunc, Consumer&lt;String&gt; setCurrentDsNameFunc, BiFunction&lt;String, String, Boolean&gt; checkSameDsNameFunc, Supplier&lt;T&gt; invokeCallback) {
        Assert.notNull(getCurrentDsNameFunc, "执行前获取数据源配置回调方法不能为空");
        Assert.notNull(setCurrentDsNameFunc, "执行前要设置的数据源配置回调方法不能为空");
        Assert.notNull(invokeCallback, "具体执行回调方法不能为空");


        String invokeId = "DSI" + System.currentTimeMillis();

        String oldDataSourceName = getCurrentDsNameFunc.get();

        setCurrentDsNameFunc.accept(newDataSourceName);

        LOGGER.info("DataSourceSwitchInvoker.invokeOn setCurrentDsName {} --&gt; {} ,invokeId: {}", oldDataSourceName, newDataSourceName, invokeId);

        Object currentTransaction = null;
        Object suspendedResourcesHolder = null;
        PlatformTransactionManagerDelegateInner platformTransactionManagerDelegate = null;
        try {

            String currentDbConnectionUrl = TransactionManagerUtils.getCurrentDbConnectionUrl(null);

            if (StringUtils.isEmpty(currentDbConnectionUrl) || currentDbConnectionUrl.equalsIgnoreCase(DATA_SOURCE_NAME_WITH_URL_MAP.get(newDataSourceName))) {
                //若当前没有持有DB连接 或持有的DB连接与当前要设置的DB数据源相同，则表明无需额外处理，只需正常执行即可
                return invokeCallback.get();
            } else if (StringUtils.isNotEmpty(currentDbConnectionUrl) &amp;&amp; checkSameDsNameFunc != null) {
                String currentUsedDataSourceName = DATA_SOURCE_NAME_WITH_URL_MAP.entrySet().stream().filter(kv -&gt; currentDbConnectionUrl.equalsIgnoreCase(kv.getValue())).map(Map.Entry::getKey).findFirst().orElse(null);
                if (Boolean.TRUE.equals(checkSameDsNameFunc.apply(currentUsedDataSourceName, newDataSourceName))) {
                    //若当前事务连接对应的已实际使用的数据源与要设置的数据源一致，则表明无需额外处理，只需正常执行即可
                    return invokeCallback.get();
                }
            }

            //若持有DB连接，则需要先挂起当前事务或资源
            AbstractPlatformTransactionManager platformTransactionManager = SpringUtils.getBean(AbstractPlatformTransactionManager.class);
            Assert.notNull(platformTransactionManager, "not found AbstractPlatformTransactionManager bean");

            platformTransactionManagerDelegate = new PlatformTransactionManagerDelegateInner(platformTransactionManager);
            currentTransaction = TransactionManagerUtils.getCurrentTransaction(platformTransactionManager);

            if (!platformTransactionManagerDelegate.isExistingTransaction(currentTransaction)) {
                currentTransaction = null;
            }

            suspendedResourcesHolder = platformTransactionManagerDelegate.suspend(currentTransaction);

            LOGGER.debug("DataSourceSwitchInvoker.invokeOn suspend result is {} ,invokeId: {}", suspendedResourcesHolder != null, invokeId);

            return invokeCallback.get();

        } finally {
            String resumeSuspendedResources = null;
            //前面若有挂起事务或资源，则需在执行完方法后需恢复到当前事务状态
            if (currentTransaction != null || suspendedResourcesHolder != null) {
                platformTransactionManagerDelegate.resume(currentTransaction, suspendedResourcesHolder);
                resumeSuspendedResources = "resume suspendedResources ok";
            }

            setCurrentDsNameFunc.accept(oldDataSourceName);

            LOGGER.info("DataSourceSwitchInvoker.invokeOn end {} , recover setCurrentDsName {} --&gt; {} ,invokeId: {}", resumeSuspendedResources, newDataSourceName, oldDataSourceName, invokeId);
        }
    }


    /**
     * 在指定的数据源下执行回调方法
     *
     * @param setCurrentDsNameFunc
     * @param invokeCallback
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; T invokeOn(Consumer&lt;String&gt; setCurrentDsNameFunc, Supplier&lt;T&gt; invokeCallback) {
        return invokeOn(SET_BEFORE, () -&gt; SET_AFTER, setCurrentDsNameFunc, null, invokeCallback);
    }

    private static &lt;T&gt; Map&lt;String, T&gt; getPropertiesByPattern(String configPath, Function&lt;Object, T&gt; convertValueFunc, BiFunction&lt;String, T, Boolean&gt; filterFunc) {
        Assert.notNull(configPath, "param configPath not be null");
        Assert.notNull(convertValueFunc, "param convertValueFunc not be null");

        Map&lt;String, T&gt; resultMap = new HashMap&lt;&gt;();

        if (!(SpringUtils.getApplicationContext().getEnvironment() instanceof ConfigurableEnvironment)) {
            return resultMap;
        }

        ConfigurableEnvironment environment = (ConfigurableEnvironment) SpringUtils.getApplicationContext().getEnvironment();
        AntPathMatcher antPathMatcher = new AntPathMatcher(".");
        String configKey = "{configKey}";
        // 遍历所有的属性源
        for (PropertySource&lt;?&gt; propertySource : environment.getPropertySources()) {
            if (propertySource instanceof EnumerablePropertySource) {
                EnumerablePropertySource&lt;?&gt; enumerablePropertySource = (EnumerablePropertySource&lt;?&gt;) propertySource;

                // 遍历当前属性源中的所有属性
                for (String propertyName : enumerablePropertySource.getPropertyNames()) {
                    if (antPathMatcher.match(configPath, propertyName)) {
                        String key = propertyName;
                        if (configPath.contains(configKey)) {
                            key = antPathMatcher.extractUriTemplateVariables(configPath, propertyName).getOrDefault(configKey.replaceAll("[{}]", ""), "&lt;null&gt;");
                        }

                        T value = convertValueFunc.apply(enumerablePropertySource.getProperty(propertyName));
                        if (filterFunc == null || filterFunc.apply(key, value)) {
                            resultMap.put(key, convertValueFunc.apply(value));
                        }
                    }
                }
            }
        }
        return resultMap;
    }

    /**
     * 通过内部类在不破坏封装性、访问性的前提下，提供当前类内部的protected方法的访问能力
     */
    private static class PlatformTransactionManagerDelegateInner extends PlatformTransactionManagerDelegate {

        public PlatformTransactionManagerDelegateInner(AbstractPlatformTransactionManager transactionManager) {
            super(transactionManager);
        }

        @Override
        protected Object suspend(Object transaction) throws TransactionException {
            return super.suspend(transaction);
        }

        @Override
        protected void resume(Object transaction, Object resourcesHolderObj) {
            super.resume(transaction, resourcesHolderObj);
        }

        @Override
        protected boolean isExistingTransaction(Object transaction) {
            return super.isExistingTransaction(transaction);
        }
    }

}
</code></pre>
<h4 id="依赖code注意包名路径需与abstractplatformtransactionmanagerdatasourcetransactionmanager一致">依赖CODE(注意包名路径需与AbstractPlatformTransactionManager、DataSourceTransactionManager一致)：</h4>
<pre><code class="language-java">//author: zuowenjun
//注意包名必需是如下，因为要访问protected方法
package org.springframework.jdbc.datasource;

public class PlatformTransactionManagerDelegate {
    private final AbstractPlatformTransactionManager delegate;

    public PlatformTransactionManagerDelegate(AbstractPlatformTransactionManager transactionManager) {
        this.delegate = transactionManager;
    }

    protected Object suspend(Object transaction) throws TransactionException {
        return delegate.suspend(transaction);
    }

    protected void resume(Object transaction, Object resourcesHolderObj) {
        AbstractPlatformTransactionManager.SuspendedResourcesHolder resourcesHolder = (AbstractPlatformTransactionManager.SuspendedResourcesHolder) resourcesHolderObj;
        delegate.resume(transaction, resourcesHolder);
    }

    protected boolean isExistingTransaction(Object transaction) {
        return delegate.isExistingTransaction(transaction);
    }

}

//author: zuowenjun
//注意包名必需是如下，因为要访问protected方法
package org.springframework.transaction.support;

public class TransactionManagerUtils {
    
    public static String getCurrentDbConnectionUrl(String threadLocalDbNameIfNoSet) {
        DataSource dataSource = SpringUtils.getBean(DataSource.class);
        if (dataSource == null) {
            return threadLocalDbNameIfNoSet;
        }

        ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);
        if (conHolder == null || !conHolder.hasConnection()) {
            return threadLocalDbNameIfNoSet;
        }

        try {
            return conHolder.getConnection().getMetaData().getURL();
        } catch (Throwable e) {
            LOGGER.warn("TransactionManagerUtils.getCurrentDbConnectionUrl error", e);
        }

        return threadLocalDbNameIfNoSet;
    }

    public static Object getCurrentTransaction(AbstractPlatformTransactionManager transactionManager) {
        if (!(transactionManager instanceof DataSourceTransactionManager)) {
            throw new RuntimeException("only support DataSourceTransactionManager doGetTransaction");
        }

        DataSourceTransactionManager dsTransactionManager = (DataSourceTransactionManager) transactionManager;
        return dsTransactionManager.doGetTransaction();
    }
    
}
</code></pre>
<p>其中：SpringUtils工具类是一个简单的实现了Spring上下文织入的接口然后赋值给静态字段，最终实现可以直接使用applicationContext.getBean(type)</p>
<h4 id="使用示例code">使用示例CODE：</h4>
<pre><code class="language-java">//假设这里是数据源的设置，tips:多数据源一般都是自定义实现了AbstractRoutingDataSource，然后使用ThreadLocal来保存设置当前要使用的数据源配置名称

private ThreadLocal&lt;String&gt; dataSourceHolder = new ThreadLocal&lt;&gt;();

@Transactional
public doWithTx(){
        //第一种方法：【推荐第一种】
        //假设之前是read_db 数据源，现在需要切换成master_db
        DataSourceSwitchInvoker.invokeOn("master_db", () -&gt; dataSourceHolder.get(), (dsName) -&gt; dataSourceHolder.set(dsName), null, () -&gt; {
            Object demo = null; //模拟 demoMapper.get(123L);
            return demo;
        });

    
        //第二种方法：（重载方法，一个设置数据源方法处理执行前、执行后的数据源设置）
    //假设之前是read_db 数据源，现在需要切换成master_db
        AtomicReference&lt;String&gt; dsName = new AtomicReference&lt;&gt;();
        DataSourceSwitchInvoker.invokeOn(eventName -&gt; {
            if (SET_BEFORE.equals(eventName)) {
                //执行前，自行记录之前的数据源
                dsName.set(dataSourceHolder.get());
                //设置新数据源
                dataSourceHolder.set("master_db");
            } else if (SET_AFTER.equals(eventName)) {
                //执行后，还原设置数据源
                dataSourceHolder.set(dsName.get());
            }

        }, () -&gt; {
            Object demo = null; //模拟 demoMapper.get(123L);
            return demo;
        });
}
    
</code></pre>
<h4 id="编码建议">编码建议：</h4>
<p>切换虽好用，但建议不要在切换的方法中进行写数据的操作，更适合仅用于临时需要查询其他数据源的数据时使用，以免破坏spring事务的完整性，因为invokeOn方法本身就是先挂起一个事务，然后开新连接执行新的操作DB的方法，最后还原恢复事务，若在其中又进行了其他的操作，可能存在未知风险，虽然理论做什么都可以但非常不建议。</p>
<p>经多种测试，无论是普通方法 OR 在事务中的方法，均能正常执行，简直就是YYDS！原创不易，如有帮助关注+点个赞吧<sub>v</sub></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8778445261608796" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-25 23:25">2025-02-25 23:24</span>&nbsp;
<a href="https://www.cnblogs.com/zuowj">梦在旅途</a>&nbsp;
阅读(<span id="post_view_count">197</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737399" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737399);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737399', targetLink: 'https://www.cnblogs.com/zuowj/p/18737399', title: '事务中无法切换数据源？DataSourceSwitchInvoker：轻松实现多数据源切换执行工具类' })">举报</a>
</div>
        