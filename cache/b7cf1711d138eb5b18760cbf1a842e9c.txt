<!----> <meta itemprop="headline" content="打造企业级axios二次封装，领导连忙点赞"> <meta itemprop="keywords" content="前端,JavaScript"> <meta itemprop="datePublished" content="2025-01-21T16:59:47.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端金熊"> <meta itemprop="url" content="https://juejin.cn/user/97193028493655"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-b21437b8="">
            打造企业级axios二次封装，领导连忙点赞
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-b21437b8=""><div class="author-info-box" data-v-b21437b8=""><div class="author-name" data-v-b21437b8=""><a href="/user/97193028493655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-b21437b8=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    前端金熊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-b21437b8=""><time datetime="2025-01-21T16:59:47.000Z" title="Tue Jan 21 2025 16:59:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-b21437b8="">
                    2025-01-21
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-b21437b8=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-b21437b8=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-b21437b8=""></circle></svg> <span class="views-count" data-v-b21437b8="">
                    4,240
                  </span> <span class="read-time" data-v-b21437b8=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-b21437b8=""><rect width="16" height="16" fill="none" data-v-b21437b8=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-b21437b8=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-b21437b8=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-b21437b8=""></div> <!----> <!----></div> <!----> <!----> <!----> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/img/banner.a5c9f88.jpg" style="width:100%;height:auto;display:block;" data-v-b21437b8=""> <div id="article-root" itemprop="articleBody" class="main" data-v-b21437b8=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">1. 主文件 <code>index.js</code></h2>
<p>在主文件中，我们创建了一个 axios 实例，并设置了请求和响应拦截器。以下是如何在项目中进行配置和初始化 axios：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;
<span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>;
<span class="hljs-keyword">import</span> addReqInterceptor <span class="hljs-keyword">from</span> <span class="hljs-string">'./reqInterceptor'</span>;
<span class="hljs-keyword">import</span> addResInterceptor <span class="hljs-keyword">from</span> <span class="hljs-string">'./resInterceptor'</span>;


<span class="hljs-comment">// 创建 axios 实例</span>
<span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">$baseUrl</span>, <span class="hljs-comment">// 在环境变量中设置基础的请求 URL</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>,  <span class="hljs-comment">// 设置请求超时时间，单位是毫秒</span>
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 跨域请求时是否需要携带 cookie</span>
  <span class="hljs-attr">paramsSerializer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) {
    <span class="hljs-comment">// 使用 qs 库对请求参数进行序列化，支持数组格式化</span>
    <span class="hljs-keyword">return</span> qs.<span class="hljs-title function_">stringify</span>(params, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'indices'</span> });
  },
});

<span class="hljs-comment">// 添加请求拦截器</span>
<span class="hljs-title function_">addReqInterceptor</span>(instance);

<span class="hljs-comment">// 添加响应拦截器</span>
<span class="hljs-title function_">addResInterceptor</span>(instance);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;

</code></pre>
<p><strong>1.1 paramsSerializer</strong></p>
<p>在 <code>Axios</code> 配置中，支持使用 <code>params</code> 对象作为参数。<br>
当发起 <code>GET</code> 请求时，我可以设置 <code>params</code> 信息并且传递给 <code>Axios</code>，Axios 会根据 <code>paramsSerializer</code> 自动将其序列化并附加到 URL 中。</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/401b720c4f284b938dd6e20eca040b49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv6YeR54aK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742355878&amp;x-signature=8%2FIXkGwzI7%2FuI%2Bpd1qCRwrUiozE%3D" alt="image.png" width="100%" loading="lazy">
<hr>
<h2 data-id="heading-1">2. 请求拦截器 <code>reqInterceptor.js</code></h2>
<p>在请求拦截器中，主要的工作是：</p>
<ul>
<li><strong>添加 Token</strong>：从存储中获取 Token 并将其放入请求头中。</li>
<li><strong>取消请求功能</strong>：如果请求需要取消，则为其添加取消令牌。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { getToken } <span class="hljs-keyword">from</span> <span class="hljs-string">"./auth"</span>; <span class="hljs-comment">// 假设有一个获取 token 的方法</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;

<span class="hljs-comment">// 请求拦截器</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addReqInterceptor</span>(<span class="hljs-params">axiosInstance</span>) {
  axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
    <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> {
      <span class="hljs-comment">// 在 header 上携带 token</span>
      <span class="hljs-title function_">addRequestToken</span>(options);

      <span class="hljs-comment">// 添加取消请求的配置项</span>
      <span class="hljs-title function_">addCancelToken</span>(options);

      <span class="hljs-keyword">return</span> options;
    },
    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      <span class="hljs-comment">// 请求错误的处理</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Request interceptor error: <span class="hljs-subst">${error}</span>`</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    }
  );
}

<span class="hljs-comment">// 添加 Token 到请求头</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addRequestToken</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">let</span> tokenMsg = <span class="hljs-title function_">getToken</span>(); <span class="hljs-comment">// 获取 token</span>
  <span class="hljs-keyword">if</span> (tokenMsg) {
    tokenMsg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(tokenMsg);
    <span class="hljs-keyword">if</span> (tokenMsg.<span class="hljs-property">token</span> &amp;&amp; tokenMsg.<span class="hljs-property">token</span> !== <span class="hljs-string">"undefined"</span>) {
      <span class="hljs-comment">// 将 token 放到请求头</span>
      options.<span class="hljs-property">headers</span>.<span class="hljs-property">token</span> = tokenMsg.<span class="hljs-property">token</span>;
    }
  }
}

<span class="hljs-comment">// 取消请求</span>
<span class="hljs-keyword">const</span> source = {}; <span class="hljs-comment">// 用于存储取消的请求</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addCancelToken</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">const</span> url = options.<span class="hljs-property">url</span>; <span class="hljs-comment">// 请求地址</span>
  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">useCancel</span>) {
    <span class="hljs-comment">// 如果需要取消请求</span>
    <span class="hljs-keyword">if</span> (source[url]) {
      source[url].<span class="hljs-title function_">cancel</span>(); <span class="hljs-comment">// 取消之前的请求</span>
    }
    <span class="hljs-comment">// 获取一个CancelToken对象</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">CancelToken</span> = axios.<span class="hljs-property">CancelToken</span>;
    <span class="hljs-comment">// source()将返回一个能取消请求的方法</span>
    source[url] = <span class="hljs-title class_">CancelToken</span>.<span class="hljs-title function_">source</span>();
    options.<span class="hljs-property">cancelToken</span> = source[url].<span class="hljs-property">token</span>;
  }
}
</code></pre>
<p><strong>2.1 携带 Token</strong></p>
<p>很多 <code>API 接口</code> 只允许经过身份验证的用户访问。如果没有携带 <code>Token</code> 或 <code>Token</code> 无效，服务器会返回 <code>401</code> 错误，表示用户需要重新认证。在请求拦截器中默认添加，可减少每次添加Token的麻烦</p>
<p><strong>2.2 取消请求场景</strong></p>
<p><strong>用户切换组件或表格:</strong> <br>
&nbsp;&nbsp;&nbsp;&nbsp;如果前一个请求尚未完成，而用户已经切换了组件或者表格，之前调用的相同的请求不再需要。如果仍然继续执行请求，则浪费了带宽和处理资源。</p>
<p><strong>搜索输入时：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在搜索功能中，用户输入时会触发自动搜索请求。如果用户连续输入或者输入过快，每个输入都会发出新的请求，前一个请求可以取消</p>
<hr>
<h2 data-id="heading-2">3. 响应拦截器 resInterceptor.js</h2>
<p>在响应拦截器中，主要工作是：</p>
<ul>
<li><strong>检查 HTTP 状态码</strong>：如果状态码不在 2xx 范围内，请求出错需要抛出错误。</li>
<li><strong>检查返回的 code 字段</strong>：根据后端定义的返回代码处理不同的业务逻辑（如 token 过期、操作失败等）。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 响应拦截器</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addResInterceptor</span>(<span class="hljs-params">axiosInstance</span>) {
  <span class="hljs-comment">// 响应状态检查</span>
  axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(checkStatus, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
  });

  <span class="hljs-comment">// 响应代码检查</span>
  axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(checkCodes, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
  });
}

<span class="hljs-comment">// 响应状态检查</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkStatus</span>(<span class="hljs-params">response</span>) {
  <span class="hljs-comment">// 判断 HTTP 响应状态是否在 200~299 范围内</span>
  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; response.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
    <span class="hljs-keyword">return</span> response;
  }

  <span class="hljs-comment">// 如果不在范围内，抛出错误</span>
  <span class="hljs-keyword">const</span> errorText = codeMessage[response.<span class="hljs-property">status</span>] || response.<span class="hljs-property">statusText</span>;
  <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(errorText);
  error.<span class="hljs-property">name</span> = response.<span class="hljs-property">status</span>;
  error.<span class="hljs-property">response</span> = response;
  <span class="hljs-keyword">throw</span> error;
}

<span class="hljs-comment">// 响应代码检查</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkCodes</span>(<span class="hljs-params">response</span>) {
  <span class="hljs-keyword">const</span> data = response.<span class="hljs-property">data</span>;

  <span class="hljs-comment">// 根据不同的 code 执行不同的操作</span>
  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">code</span> === <span class="hljs-number">10002</span> || data.<span class="hljs-property">code</span> === <span class="hljs-number">10004</span>) {
    <span class="hljs-comment">// 如果 code 为 10002 或 10004，表示登录失效，弹出重新登陆操作</span>
    <span class="hljs-title function_">reLogIn</span>(); 
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">code</span> === -<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果 code 为 -1，表示操作失败，弹出提示</span>
    <span class="hljs-comment">// alert可以是内部项目封装的弹窗提示</span>
    <span class="hljs-title function_">alert</span>({
      <span class="hljs-attr">text</span>: data.<span class="hljs-property">message</span>,
      <span class="hljs-attr">icon</span>: <span class="hljs-string">"info"</span>,
      <span class="hljs-attr">button</span>: <span class="hljs-string">"close"</span>,
    });
  }

  <span class="hljs-keyword">return</span> response; <span class="hljs-comment">// 返回原始响应数据</span>
}

<span class="hljs-comment">// 服务器返回的状态信息</span>
<span class="hljs-keyword">const</span> codeMessage = {
  <span class="hljs-number">200</span>: <span class="hljs-string">"服务器成功返回请求的数据"</span>,
  <span class="hljs-number">201</span>: <span class="hljs-string">"新建或修改数据成功"</span>,
  <span class="hljs-number">202</span>: <span class="hljs-string">"一个请求已经进入后台排队(异步任务)中"</span>,
  <span class="hljs-number">204</span>: <span class="hljs-string">"删除数据成功"</span>,
  <span class="hljs-number">400</span>: <span class="hljs-string">"发出的请求有错误，服务器没有进行新建或修改数据的操作"</span>,
  <span class="hljs-number">401</span>: <span class="hljs-string">"用户没有权限(令牌、用户名、密码错误)"</span>,
  <span class="hljs-number">403</span>: <span class="hljs-string">"用户得到授权，但是访问是被禁止的"</span>,
  <span class="hljs-number">404</span>: <span class="hljs-string">"发出的请求针对的是不存在的记录，服务器没有进行操作"</span>,
  <span class="hljs-number">406</span>: <span class="hljs-string">"请求的格式不可得"</span>,
  <span class="hljs-number">410</span>: <span class="hljs-string">"请求的资源被永久删除，且不会再得到"</span>,
  <span class="hljs-number">422</span>: <span class="hljs-string">"当创建一个对象时，发生一个验证错误"</span>,
  <span class="hljs-number">500</span>: <span class="hljs-string">"服务器发生错误，请检查服务器"</span>,
  <span class="hljs-number">502</span>: <span class="hljs-string">"网关错误"</span>,
  <span class="hljs-number">503</span>: <span class="hljs-string">"服务不可用，服务器暂时过载或维护"</span>,
  <span class="hljs-number">504</span>: <span class="hljs-string">"网关超时"</span>,
};

</code></pre>
<p>在请求和响应拦截器中，我省略了部分项目业务独有的代码判断。您可以在对应的代码中加上你项目中独有的一些判断和修改传参，</p>
<h2 data-id="heading-3">4.封装get和post请求</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>axios</code> 返回的结果里不只是后端的结果信息，还有 <code>config</code>，<code>headers</code> 等信息。但是我们一般在开发中只需要其中的 <code>data</code> 信息。<br></p>
<p><strong><code>axios</code> 返回的结果如下</strong>：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd53af533b284d75a04429aa1590a8b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv6YeR54aK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742355878&amp;x-signature=kzvQ5BZ42T2t0aBMvwb%2B0CVdkuo%3D" alt="image.png" loading="lazy"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了减少每次请求都需要从 <code>axios</code> 返回的完整响应对象中提取 <code>data</code> 的操作，我们可以对 <code>get</code> 和 <code>post</code> 方法进行封装。<br></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 封装 GET 请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url, options</span>) {
  <span class="hljs-keyword">return</span> instance
    .<span class="hljs-title function_">get</span>(url, options)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-property">data</span>)  <span class="hljs-comment">// 只返回 data 部分</span>
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"请求 GET 错误:"</span>, error);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);  <span class="hljs-comment">// 返回错误信息</span>
    });
}

<span class="hljs-comment">// 封装 POST 请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url, options</span>) {
  <span class="hljs-keyword">return</span> instance
    .<span class="hljs-title function_">post</span>(url, options)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-property">data</span>)  <span class="hljs-comment">// 只返回 data 部分</span>
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"请求 POST 错误:"</span>, error);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);  <span class="hljs-comment">// 返回错误信息</span>
    });
}
</code></pre>
<p><strong>使用封装的 <code>post</code> 示例：</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { post } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>;

<span class="hljs-keyword">const</span> postData = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">'New Post'</span>,
  <span class="hljs-attr">content</span>: <span class="hljs-string">'This is the content of the new post.'</span>,
};

<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/posts'</span>, postData)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'返回的数据:'</span>, data);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败:'</span>, error);
  });
</code></pre>
<h2 data-id="heading-4">总结：</h2>
<ol>
<li><strong>请求拦截器</strong>：在请求发送之前，添加了 Token、默认头部、取消请求配置。</li>
<li><strong>响应拦截器</strong>：检查 HTTP 状态码，并根据返回的 <code>code</code> 字段执行不同的业务操作，比如弹出提示或登出。</li>
<li><strong>封装get和post请求</strong>: 请求成功后，直接返回 <code>response.data</code>，减少冗余代码。</li>
</ol>
<p><strong>提示：</strong> 如果您想了解 <code>axios</code> 的核心代码实现，可以参考：<a href="https://juejin.cn/post/7460116391192723506" target="_blank" title="https://juejin.cn/post/7460116391192723506">轻松掌握axios核心源码</a></p></div></div>