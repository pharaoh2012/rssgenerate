
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaokang-coding/p/18801623" title="å‘å¸ƒäº 2025-04-03 19:24">
    <span role="heading" aria-level="2">ã€Œç¡¬æ ¸å®æˆ˜ã€å›è°ƒå‡½æ•°åˆ°åº•æ˜¯ä¸ªå•¥ï¼Ÿä¸€æ–‡å¸¦ä½ ä»åŸç†åˆ°å®æˆ˜å½»åº•æŒæ¡C/C++å›è°ƒå‡½æ•°</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å°åº·ã€‚</p>
<blockquote>
<p>ç½‘ä¸Šè®²å›è°ƒå‡½æ•°çš„æ–‡ç« ä¸å°‘ï¼Œä½†å¤§å¤šæµ…å°è¾„æ­¢ã€ç¼ºå°‘ç³»ç»Ÿæ€§ï¼Œæ›´åˆ«æå®æˆ˜åœºæ™¯å’Œè¸©å‘æŒ‡å—äº†ã€‚ä½œä¸ºä¸€ä¸ªåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¸å›è°ƒå‡½æ•°æ‰“äº†å¤šå¹´äº¤é“çš„å¼€å‘è€…ï¼Œä»Šå¤©æˆ‘æƒ³åˆ†äº«ä¸€äº›çœŸæ­£å®ç”¨çš„ç»éªŒï¼Œå¸¦ä½ æ­å¼€å›è°ƒå‡½æ•°çš„ç¥ç§˜é¢çº±ï¼Œä»ç†è®ºåˆ°å®æˆ˜å…¨æ–¹ä½æŒæ¡è¿™ä¸ªå¼ºå¤§è€Œå¸¸è§çš„ç¼–ç¨‹æŠ€å·§ã€‚</p>
</blockquote>
<h2 id="å¼€ç¯‡é‚£äº›å¹´æˆ‘ä»¬è¢«å›è°ƒå‡½æ•°æ•´æ‡µçš„æ—¥å­">å¼€ç¯‡ï¼šé‚£äº›å¹´ï¼Œæˆ‘ä»¬è¢«å›è°ƒå‡½æ•°æ•´æ‡µçš„æ—¥å­</h2>
<p>è¿˜è®°å¾—æˆ‘åˆšå¼€å§‹å­¦ç¼–ç¨‹æ—¶ï¼Œé‡åˆ°"å›è°ƒå‡½æ•°"è¿™ä¸ªè¯ç®€ç›´ä¸€è„¸æ‡µï¼š</p>
<p>"å›è°ƒï¼Ÿæ˜¯ä¸æ˜¯æ‰“ç”µè¯å›å»çš„æ„æ€ï¼Ÿ"</p>
<p>"å‡½æ•°è¿˜èƒ½å›è¿‡å¤´è°ƒç”¨ï¼Ÿè¿™æ˜¯ä»€ä¹ˆé»‘é­”æ³•ï¼Ÿ"</p>
<p>"ä¸ºå•¥ä»£ç é‡Œæœ‰ä¸ªå‡½æ•°æŒ‡é’ˆä¼ æ¥ä¼ å»çš„ï¼Ÿè¿™æ˜¯åœ¨å¹²å•¥ï¼Ÿ"</p>
<p>å¦‚æœä½ ä¹Ÿæœ‰è¿™äº›ç–‘é—®ï¼Œé‚£æ­å–œä½ ï¼Œä»Šå¤©è¿™ç¯‡æ–‡ç« å°±æ˜¯ä¸ºä½ é‡èº«å®šåšçš„ï¼</p>
<blockquote>
<p>å¾®ä¿¡æœç´¢ ã€Œ<strong>è·Ÿç€å°åº·å­¦ç¼–ç¨‹</strong>ã€ï¼Œå…³æ³¨æˆ‘ï¼Œåç»­è¿˜æœ‰æ›´å¤šç¡¬æ ¸æŠ€æœ¯æ–‡ç« åˆ†äº«ï¼Œå¸¦ä½ ç©è½¬ Linux C/C++ ç¼–ç¨‹ï¼ğŸ˜†</p>
</blockquote>
<h2 id="ä¸€ä»€ä¹ˆæ˜¯å›è°ƒå‡½æ•°å…ˆæ¥ä¸ªé€šä¿—è§£é‡Š">ä¸€ã€ä»€ä¹ˆæ˜¯å›è°ƒå‡½æ•°ï¼Ÿå…ˆæ¥ä¸ªé€šä¿—è§£é‡Š</h2>
<p><strong>å›è°ƒå‡½æ•°æœ¬è´¨ä¸Šå°±æ˜¯ï¼šæŠŠä¸€ä¸ªå‡½æ•°å½“ä½œå‚æ•°ä¼ ç»™å¦ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨åˆé€‚çš„æ—¶æœºå†è¢«"å›å¤´è°ƒç”¨"ã€‚</strong></p>
<p>è¿™ä¹ˆè¯´å¤ªæŠ½è±¡ï¼Ÿé‚£æˆ‘ä»¬æ¥ä¸ªç”Ÿæ´»ä¸­çš„ä¾‹å­ï¼š</p>
<p>æƒ³è±¡ä½ å»ç«é”…åº—åƒé¥­ï¼Œä½†å‘ç°éœ€è¦æ’é˜Ÿã€‚æœ‰ä¸¤ç§æ–¹å¼ç­‰ä½ï¼š</p>
<ol>
<li><strong>å‚»ç­‰æ³•</strong>ï¼šç«™åœ¨é—¨å£ä¸€ç›´ç›¯ç€å‰å°ï¼Œä¸åœé—®"åˆ°æˆ‘äº†å—ï¼Ÿåˆ°æˆ‘äº†å—ï¼Ÿ"</li>
<li><strong>å›è°ƒæ³•</strong>ï¼šæ‹¿ä¸ªå° buzzerï¼ˆå‘¼å«å™¨ï¼‰ï¼Œè¯¥å¹²å˜›å¹²å˜›å»ï¼Œç­‰è½®åˆ°ä½ æ—¶ï¼Œbuzzer ä¼šè‡ªåŠ¨éœ‡åŠ¨æé†’ä½ </li>
</ol>
<p>æ˜¾ç„¶ç¬¬äºŒç§æ–¹å¼æ›´é«˜æ•ˆï¼è¿™å°±æ˜¯å›è°ƒçš„æ€æƒ³ï¼š</p>
<ul>
<li>å°buzzerå°±æ˜¯ä½ ä¼ é€’çš„"å›è°ƒå‡½æ•°"</li>
<li>é¤å…å‰å°å°±æ˜¯æ¥æ”¶å›è°ƒçš„å‡½æ•°</li>
<li>buzzeréœ‡åŠ¨å°±æ˜¯å›è°ƒå‡½æ•°è¢«æ‰§è¡Œ</li>
<li>ä½ ä¸ç”¨ä¸€ç›´å®ˆç€ï¼Œè§£æ”¾äº†è‡ªå·±å»åšå…¶ä»–äº‹</li>
</ul>
<p><strong>å›è°ƒå‡½æ•°çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š"æ§åˆ¶åè½¬"ï¼ˆIoCï¼‰</strong>â€”â€” æŠŠ"ä½•æ—¶æ‰§è¡Œ"çš„æ§åˆ¶æƒäº¤ç»™äº†åˆ«äººï¼Œè€Œä¸æ˜¯è‡ªå·±ä¸€ç›´è½®è¯¢æ£€æŸ¥ã€‚</p>
<h2 id="äºŒä¸ºä»€ä¹ˆéœ€è¦å›è°ƒå‡½æ•°">äºŒã€ä¸ºä»€ä¹ˆéœ€è¦å›è°ƒå‡½æ•°ï¼Ÿ</h2>
<p>åœ¨æ·±å…¥ä»£ç å‰ï¼Œæˆ‘ä»¬å…ˆææ¸…æ¥šä¸ºå•¥éœ€è¦è¿™ç©æ„å„¿ï¼Ÿå›è°ƒå‡½æ•°è§£å†³äº†å“ªäº›é—®é¢˜ï¼Ÿ</p>
<ol>
<li><strong>è§£è€¦åˆ</strong>ï¼šè°ƒç”¨è€…ä¸éœ€è¦çŸ¥é“è¢«è°ƒç”¨è€…çš„å…·ä½“å®ç°</li>
<li><strong>å¼‚æ­¥å¤„ç†</strong>ï¼šå¯ä»¥åœ¨äº‹ä»¶å‘ç”Ÿæ—¶æ‰æ‰§è¡Œç›¸åº”ä»£ç ï¼Œä¸éœ€è¦ä¸€ç›´ç­‰å¾…</li>
<li><strong>æé«˜æ‰©å±•æ€§</strong>ï¼šåŒä¸€ä¸ªå‡½æ•°å¯ä»¥æ¥å—ä¸åŒçš„å›è°ƒå‡½æ•°ï¼Œå®ç°ä¸åŒçš„åŠŸèƒ½</li>
<li><strong>å®ç°äº‹ä»¶é©±åŠ¨</strong>ï¼šGUIç¼–ç¨‹ã€ç½‘ç»œç¼–ç¨‹ç­‰é¢†åŸŸçš„åŸºç¡€</li>
</ol>
<h2 id="ä¸‰å›è°ƒå‡½æ•°çš„åŸºæœ¬ç»“æ„ä»£ç è¯¦è§£">ä¸‰ã€å›è°ƒå‡½æ•°çš„åŸºæœ¬ç»“æ„ï¼šä»£ç è¯¦è§£</h2>
<p>å¥½äº†ï¼Œè¯´äº†è¿™ä¹ˆå¤šï¼Œæ¥çœ‹çœ‹ C/C++ ä¸­å›è°ƒå‡½æ•°åˆ°åº•é•¿å•¥æ ·ï¼š</p>
<pre><code class="language-c++">// 1. å®šä¹‰å›è°ƒå‡½æ•°ç±»å‹ï¼ˆå‡½æ•°æŒ‡é’ˆç±»å‹ï¼‰
typedef void (*CallbackFunc)(int);

// 2. å®é™…çš„å›è°ƒå‡½æ•°
void onTaskCompleted(int result) {
    printf("å“‡ï¼ä»»åŠ¡å®Œæˆäº†ï¼ç»“æœæ˜¯: %d\n", result);
}

// 3. æ¥æ”¶å›è°ƒå‡½æ•°çš„å‡½æ•°
void doSomethingAsync(CallbackFunc callback) {
    printf("å¼€å§‹æ‰§è¡Œä»»åŠ¡...\n");
    // å‡è®¾è¿™é‡Œæ˜¯ä¸€äº›è€—æ—¶æ“ä½œ
    int result = 42;
    printf("ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œå‡†å¤‡è°ƒç”¨å›è°ƒå‡½æ•°...\n");
    // æ“ä½œå®Œæˆï¼Œè°ƒç”¨å›è°ƒå‡½æ•°
    callback(result);
}

// 4. ä¸»å‡½æ•°
int main() {
    // æŠŠå›è°ƒå‡½æ•°ä¼ é€’è¿‡å»
    doSomethingAsync(onTaskCompleted);
    return 0;
}
</code></pre>
<p>ä¸Šé¢çš„ä»£ç ä¸­ï¼š</p>
<ol>
<li><code>CallbackFunc</code> æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆç±»å‹ï¼Œå®ƒå®šä¹‰äº†å›è°ƒå‡½æ•°çš„ç­¾å</li>
<li><code>onTaskCompleted</code> æ˜¯å®é™…çš„å›è°ƒå‡½æ•°ï¼Œå®ƒä¼šåœ¨ä»»åŠ¡å®Œæˆæ—¶è¢«è°ƒç”¨</li>
<li><code>doSomethingAsync</code> æ˜¯æ¥æ”¶å›è°ƒå‡½æ•°çš„å‡½æ•°ï¼Œå®ƒåœ¨å®Œæˆä»»åŠ¡åä¼šè°ƒç”¨ä¼ å…¥çš„å›è°ƒå‡½æ•°</li>
<li>åœ¨ <code>main</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å°† <code>onTaskCompleted</code> ä½œä¸ºå‚æ•°ä¼ ç»™äº† <code>doSomethingAsync</code></li>
</ol>
<p>æ³¨æ„å‡½æ•°æŒ‡é’ˆçš„å®šä¹‰ï¼š<code>typedef void (*CallbackFunc)(int);</code></p>
<ul>
<li><code>void</code> è¡¨ç¤ºå›è°ƒå‡½æ•°ä¸è¿”å›å€¼</li>
<li><code>(*CallbackFunc)</code> è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆç±»å‹ï¼Œåä¸º <code>CallbackFunc</code></li>
<li><code>(int)</code> è¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ª int ç±»å‹çš„å‚æ•°</li>
</ul>
<p>è¿™å°±æ˜¯å›è°ƒå‡½æ•°çš„åŸºæœ¬ç»“æ„ï¼æ ¸å¿ƒå°±æ˜¯æŠŠå‡½æ•°çš„åœ°å€å½“ä½œå‚æ•°ä¼ é€’ï¼Œç„¶ååœ¨åˆé€‚çš„æ—¶æœºè°ƒç”¨å®ƒã€‚</p>
<h2 id="å››å›è°ƒå‡½æ•°çš„æœ¬è´¨æ·±å…¥ç†è§£å‡½æ•°æŒ‡é’ˆ">å››ã€å›è°ƒå‡½æ•°çš„æœ¬è´¨ï¼šæ·±å…¥ç†è§£å‡½æ•°æŒ‡é’ˆ</h2>
<p>è¦çœŸæ­£ç†è§£å›è°ƒå‡½æ•°ï¼Œå¿…é¡»å…ˆææ¸…æ¥šå‡½æ•°æŒ‡é’ˆã€‚åœ¨C/C++ä¸­ï¼Œå‡½æ•°åœ¨å†…å­˜ä¸­ä¹Ÿæœ‰åœ°å€ï¼Œå¯ä»¥ç”¨æŒ‡é’ˆæŒ‡å‘å®ƒä»¬ã€‚</p>
<pre><code class="language-c++">// æ™®é€šå‡½æ•°
int add(int a, int b) {
    return a + b;
}

int main() {
    // å£°æ˜ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ
    int (*funcPtr)(int, int);
    
    // è®©æŒ‡é’ˆæŒ‡å‘addå‡½æ•°
    funcPtr = add;
    
    // é€šè¿‡å‡½æ•°æŒ‡é’ˆè°ƒç”¨å‡½æ•°
    int result = funcPtr(5, 3);
    printf("ç»“æœæ˜¯: %d\n", result);  // è¾“å‡º: ç»“æœæ˜¯: 8
    
    return 0;
}
</code></pre>
<p>è¿™é‡Œçš„ <code>funcPtr</code> å°±æ˜¯å‡½æ•°æŒ‡é’ˆï¼Œå®ƒæŒ‡å‘äº† <code>add</code> å‡½æ•°ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæŒ‡é’ˆè°ƒç”¨å‡½æ•°ï¼Œå°±åƒé€šè¿‡æ™®é€šæŒ‡é’ˆè®¿é—®å˜é‡ä¸€æ ·ã€‚</p>
<p><strong>å›è°ƒå‡½æ•°çš„æœ¬è´¨å°±æ˜¯åˆ©ç”¨å‡½æ•°æŒ‡é’ˆï¼Œå®ç°äº†å‡½æ•°çš„"å»¶è¿Ÿè°ƒç”¨"æˆ–"æ¡ä»¶è°ƒç”¨"</strong>ã€‚å®ƒè®©ä¸€ä¸ªå‡½æ•°å¯ä»¥åœ¨æœªæ¥æŸä¸ªæ—¶åˆ»ï¼Œæ»¡è¶³æŸä¸ªæ¡ä»¶æ—¶ï¼Œè¢«å¦ä¸€ä¸ªå‡½æ•°è°ƒç”¨ã€‚</p>
<h2 id="äº”cä¸cä¸­çš„ä¸åŒå›è°ƒæ–¹å¼">äº”ã€Cä¸C++ä¸­çš„ä¸åŒå›è°ƒæ–¹å¼</h2>
<p>Cå’ŒC++æä¾›äº†ä¸åŒçš„å®ç°å›è°ƒçš„æ–¹å¼ï¼Œè®©æˆ‘ä»¬æ¯”è¾ƒä¸€ä¸‹ï¼š</p>
<h3 id="1-cè¯­è¨€ä¸­çš„å‡½æ•°æŒ‡é’ˆ">1. Cè¯­è¨€ä¸­çš„å‡½æ•°æŒ‡é’ˆ</h3>
<p>è¿™æ˜¯æœ€åŸºç¡€çš„æ–¹å¼ï¼Œå°±åƒæˆ‘ä»¬å‰é¢çœ‹åˆ°çš„ï¼š</p>
<pre><code class="language-c">typedef void (*Callback)(int);

void someFunction(Callback cb) {
    // ...
    cb(42);
}
</code></pre>
<h3 id="2-cä¸­çš„å‡½æ•°å¯¹è±¡functor">2. C++ä¸­çš„å‡½æ•°å¯¹è±¡ï¼ˆFunctorï¼‰</h3>
<pre><code class="language-c++">// å‡½æ•°å¯¹è±¡ç±»
class PrintCallback {
public:
    void operator()(int value) {
        std::cout &lt;&lt; "å€¼æ˜¯: " &lt;&lt; value &lt;&lt; std::endl;
    }
};

// æ¥æ”¶å‡½æ•°å¯¹è±¡çš„å‡½æ•°
template&lt;typename Func&gt;
void doSomething(Func callback) {
    callback(100);
}

int main() {
    PrintCallback printer;
    doSomething(printer);  // è¾“å‡º: å€¼æ˜¯: 100
    return 0;
}
</code></pre>
<h3 id="3-c11ä¸­çš„-stdfunction-å’Œ-lambda-è¡¨è¾¾å¼">3. C++11ä¸­çš„ std::function å’Œ lambda è¡¨è¾¾å¼</h3>
<p>è¿™æ˜¯æœ€ç°ä»£çš„æ–¹å¼ï¼Œä¹Ÿæœ€çµæ´»ï¼š</p>
<pre><code class="language-c++">// ä½¿ç”¨std::function
void doTask(std::function&lt;void(int)&gt; callback) {
    callback(200);
}

int main() {
    // ä½¿ç”¨lambdaè¡¨è¾¾å¼
    doTask([](int value) {
        std::cout &lt;&lt; "Lambdaè¢«è°ƒç”¨ï¼Œå€¼æ˜¯: " &lt;&lt; value &lt;&lt; std::endl;
    });
    
    // å¸¦æ•è·çš„lambda
    int factor = 10;
    doTask([factor](int value) {
        std::cout &lt;&lt; "ç»“æœæ˜¯: " &lt;&lt; value * factor &lt;&lt; std::endl;
    });
    
    return 0;
}
</code></pre>
<p>C++11çš„<code>std::function</code>å’Œ <code>lambda</code> è¡¨è¾¾å¼è®©å›è°ƒå˜å¾—æ›´åŠ çµæ´»ï¼Œç‰¹åˆ«æ˜¯ lambda å¯ä»¥æ•è·å¤–éƒ¨å˜é‡ï¼Œè¿™åœ¨ C è¯­è¨€ä¸­å¾ˆéš¾å®ç°ã€‚</p>
<blockquote>
<p>å¾®ä¿¡æœç´¢ ã€Œ<strong>è·Ÿç€å°åº·å­¦ç¼–ç¨‹</strong>ã€ï¼Œå…³æ³¨æˆ‘ï¼Œåç»­è¿˜æœ‰æ›´å¤šç¡¬æ ¸æŠ€æœ¯æ–‡ç« åˆ†äº«ï¼Œå¸¦ä½ ç©è½¬ Linux C/C++ ç¼–ç¨‹ï¼ğŸ˜†</p>
</blockquote>
<h2 id="å…­å›è°ƒå‡½æ•°çš„å®æˆ˜æ¡ˆä¾‹">å…­ã€å›è°ƒå‡½æ•°çš„å®æˆ˜æ¡ˆä¾‹</h2>
<p>å…‰è¯´ä¸ç»ƒå‡æŠŠå¼ï¼Œæ¥å‡ ä¸ªå®é™…æ¡ˆä¾‹æ„Ÿå—ä¸€ä¸‹å›è°ƒå‡½æ•°çš„å¼ºå¤§ï¼š</p>
<h3 id="æ¡ˆä¾‹1è‡ªå®šä¹‰æ’åº">æ¡ˆä¾‹1ï¼šè‡ªå®šä¹‰æ’åº</h3>
<p>å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œæƒ³æŒ‰ç…§ä¸åŒçš„è§„åˆ™æ’åºï¼š</p>
<pre><code class="language-c++">// å®šä¹‰æ¯”è¾ƒå‡½æ•°ç±»å‹
typedef int (*CompareFunc)(const void*, const void*);

// å‡åºæ¯”è¾ƒ
int ascendingCompare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

// é™åºæ¯”è¾ƒ
int descendingCompare(const void* a, const void* b) {
    return (*(int*)b - *(int*)a);
}

// è‡ªå®šä¹‰æ’åºå‡½æ•°
void customSort(int arr[], int size, CompareFunc compare) {
    qsort(arr, size, sizeof(int), compare);
}

int main() {
    int numbers[] = {-42, 8, -15, 16, -23, 4};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    // å‡åºæ’åº
    customSort(numbers, size, ascendingCompare);
    
    // é™åºæ’åº
    customSort(numbers, size, descendingCompare);
    
    return 0;
}
</code></pre>
<p>è¿™ä¸ªä¾‹å­å±•ç¤ºäº†å›è°ƒå‡½æ•°æœ€å¸¸è§çš„ç”¨é€”ä¹‹ä¸€ï¼šé€šè¿‡ä¼ å…¥ä¸åŒçš„æ¯”è¾ƒå‡½æ•°ï¼Œå®ç°ä¸åŒçš„æ’åºè§„åˆ™ï¼Œè€Œæ— éœ€ä¿®æ”¹æ’åºç®—æ³•æœ¬èº«ã€‚</p>
<h3 id="æ¡ˆä¾‹2äº‹ä»¶å¤„ç†ç³»ç»Ÿ">æ¡ˆä¾‹2ï¼šäº‹ä»¶å¤„ç†ç³»ç»Ÿ</h3>
<p>GUIç¼–ç¨‹ä¸­ï¼Œå›è°ƒå‡½æ•°æ— å¤„ä¸åœ¨ã€‚ä¸‹é¢æˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸ªç®€å•çš„äº‹ä»¶ç³»ç»Ÿï¼š</p>
<pre><code class="language-c++">// äº‹ä»¶ç±»å‹
enum EventType { CLICK, HOVER, KEY_PRESS };

// äº‹ä»¶ç»“æ„ä½“
struct Event {
    EventType type;
    int x, y;
    char key;
};

// å®šä¹‰å›è°ƒå‡½æ•°ç±»å‹
typedef void (*EventCallback)(const Event*);

// å„ç§äº‹ä»¶å¤„ç†å‡½æ•°
void onClickCallback(const Event* event) {
    printf("ç‚¹å‡»äº‹ä»¶è§¦å‘äº†ï¼åæ ‡: (%d, %d)\n", 
           event-&gt;x, event-&gt;y);
}

void onKeyPressCallback(const Event* event) {
    printf("æŒ‰é”®äº‹ä»¶è§¦å‘äº†ï¼æŒ‰ä¸‹çš„é”®æ˜¯: %c\n", 
           event-&gt;key);
}
...

// äº‹ä»¶å¤„ç†å™¨ç»“æ„ä½“
struct EventHandler {
    EventCallback callbacks[10];  // å‡è®¾æœ€å¤š10ç§äº‹ä»¶ç±»å‹
};

// æ³¨å†Œäº‹ä»¶å›è°ƒ
void registerCallback(EventHandler* handler, EventType type, EventCallback callback) {
    handler-&gt;callbacks[type] = callback;
}

// äº‹ä»¶åˆ†å‘å™¨
void dispatchEvent(EventHandler* handler, const Event* event) {
    if (handler-&gt;callbacks[event-&gt;type] != NULL) {
        handler-&gt;callbacks[event-&gt;type](event);
    }
}

int main() {
    // åˆ›å»ºå¹¶åˆå§‹åŒ–äº‹ä»¶å¤„ç†å™¨
    EventHandler handler;
    
    // æ³¨å†Œå›è°ƒå‡½æ•°
    registerCallback(&amp;handler, CLICK, onClickCallback);
    
    // æ¨¡æ‹Ÿç‚¹å‡»äº‹ä»¶
    Event clickEvent = {CLICK, 100, 200};
    dispatchEvent(&amp;handler, &amp;clickEvent);
    
    return 0;
}
</code></pre>
<p>è¿™ä¸ªä¾‹å­æ¨¡æ‹Ÿäº† GUI ç¨‹åºä¸­çš„äº‹ä»¶å¤„ç†æœºåˆ¶ï¼šä¸åŒç±»å‹çš„äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œç³»ç»Ÿä¼šè°ƒç”¨ç›¸åº”çš„å›è°ƒå‡½æ•°ã€‚è¿™æ˜¯æ‰€æœ‰ GUIæ¡†æ¶çš„åŸºç¡€è®¾è®¡æ¨¡å¼ã€‚</p>
<h3 id="æ¡ˆä¾‹3å¸¦ç”¨æˆ·æ•°æ®çš„å›è°ƒå‡½æ•°">æ¡ˆä¾‹3ï¼šå¸¦ç”¨æˆ·æ•°æ®çš„å›è°ƒå‡½æ•°</h3>
<p>åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸éœ€è¦ç»™å›è°ƒå‡½æ•°ä¼ é€’é¢å¤–çš„ä¸Šä¸‹æ–‡æ•°æ®ã€‚ä¸‹é¢çœ‹çœ‹å‡ ç§å®ç°æ–¹å¼ï¼š</p>
<h4 id="ä½¿ç”¨voidæŒ‡é’ˆä¼ é€’ç”¨æˆ·æ•°æ®cè¯­è¨€é£æ ¼">ä½¿ç”¨voidæŒ‡é’ˆä¼ é€’ç”¨æˆ·æ•°æ®ï¼ˆCè¯­è¨€é£æ ¼ï¼‰</h4>
<pre><code class="language-c++">// ç”¨æˆ·æ•°æ®ç»“æ„ä½“
struct UserData {
    const char* name;
    int id;
};

// å›è°ƒå‡½æ•°ç±»å‹
typedef void (*Callback)(int result, void* userData);

// å®é™…çš„å›è°ƒå‡½æ•°
void processResult(int result, void* userData) {
    UserData* data = (UserData*)userData;
    printf("ç”¨æˆ· %s (ID: %d) æ”¶åˆ°ç»“æœ: %d\n", 
        data-&gt;name, data-&gt;id, result);
}

// æ‰§è¡Œä»»åŠ¡çš„å‡½æ•°
void executeTask(Callback callback, void* userData) {
    int result = 100;
    callback(result, userData);
}

int main() {
    // åˆ›å»ºç”¨æˆ·æ•°æ®
    UserData user = {"å¼ ä¸‰", 1001};

    // æ‰§è¡Œä»»åŠ¡
    executeTask(processResult, &amp;user);

    return 0;
}
</code></pre>
<p>è¿™ç§æ–¹å¼é€šè¿‡<code>void*</code>ç±»å‹å‚æ•°ä¼ é€’ä»»æ„ç±»å‹çš„æ•°æ®ï¼Œæ˜¯Cè¯­è¨€ä¸­æœ€å¸¸è§çš„æ–¹å¼ã€‚ä½†ç¼ºç‚¹æ˜¯ç¼ºä¹ç±»å‹å®‰å…¨æ€§ï¼Œå®¹æ˜“å‡ºé”™ã€‚</p>
<h4 id="ä½¿ç”¨c11çš„-stdfunction-å’Œ-lambda-è¡¨è¾¾å¼">ä½¿ç”¨C++11çš„ std::function å’Œ lambda è¡¨è¾¾å¼</h4>
<pre><code class="language-c++">// ä½¿ç”¨std::functionå®šä¹‰å›è°ƒç±»å‹
using TaskCallback = std::function&lt;void(int)&gt;;

// æ‰§è¡Œä»»åŠ¡çš„å‡½æ•°
void executeTask(TaskCallback callback) {
    int result = 300;
    callback(result);
}

int main() {
    // ä½¿ç”¨lambdaæ•è·å±€éƒ¨å˜é‡
    std::string userName = "ç”¨æˆ·1";
    int userId = 2001;

    // lambdaæ•è·å¤–éƒ¨å˜é‡
    executeTask([userName, userId](int result) {
        std::cout &lt;&lt; userName &lt;&lt; " (ID: " &lt;&lt; userId 
            &lt;&lt; ") æ”¶åˆ°ç»“æœ: " &lt;&lt; result &lt;&lt; std::endl;
    });

    return 0;
}
</code></pre>
<p>è¿™ç§æ–¹å¼æœ€çµæ´»ï¼Œlambdaè¡¨è¾¾å¼å¯ä»¥ç›´æ¥æ•è·å‘¨å›´ç¯å¢ƒä¸­çš„å˜é‡ï¼Œå¤§å¤§ç®€åŒ–äº†ä»£ç ã€‚</p>
<h2 id="å…«å›è°ƒå‡½æ•°çš„è®¾è®¡æ¨¡å¼">å…«ã€å›è°ƒå‡½æ•°çš„è®¾è®¡æ¨¡å¼</h2>
<p>å›è°ƒå‡½æ•°åœ¨å„ç§è®¾è®¡æ¨¡å¼ä¸­å¹¿æ³›åº”ç”¨ï¼Œä¸‹é¢ä»‹ç»ä¸¤ä¸ªå¸¸è§çš„æ¨¡å¼ï¼š</p>
<h3 id="1-è§‚å¯Ÿè€…æ¨¡å¼observer-pattern">1. è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰</h3>
<p>è§‚å¯Ÿè€…æ¨¡å¼ä¸­ï¼Œå¤šä¸ªè§‚å¯Ÿè€…æ³¨å†Œåˆ°è¢«è§‚å¯Ÿå¯¹è±¡ï¼Œå½“è¢«è§‚å¯Ÿå¯¹è±¡çŠ¶æ€å˜åŒ–æ—¶ï¼Œé€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…ï¼š</p>
<pre><code class="language-c++">// ä½¿ç”¨C++11çš„æ–¹å¼å®ç°è§‚å¯Ÿè€…æ¨¡å¼
class Subject {
private:
    // å­˜å‚¨è§‚å¯Ÿè€…çš„å›è°ƒå‡½æ•°
    std::vector&lt;std::function&lt;void(const std::string&amp;)&gt;&gt; observers;
    
public:
    // æ·»åŠ è§‚å¯Ÿè€…
    void addObserver(std::function&lt;void(const std::string&amp;)&gt; observer) {
        observers.push_back(observer);
    }
    
    // é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
    void notifyObservers(const std::string&amp; message) {
        for (auto&amp; observer : observers) {
            observer(message);
        }
    }
};
</code></pre>
<p>è¿™ä¸ªæ¨¡å¼åœ¨GUIç¼–ç¨‹ã€æ¶ˆæ¯ç³»ç»Ÿã€äº‹ä»¶å¤„ç†ä¸­éå¸¸å¸¸è§ã€‚</p>
<h3 id="2-ç­–ç•¥æ¨¡å¼strategy-pattern">2. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰</h3>
<p>ç­–ç•¥æ¨¡å¼ä½¿ç”¨å›è°ƒå‡½æ•°å®ç°ä¸åŒçš„ç®—æ³•ç­–ç•¥ï¼š</p>
<pre><code class="language-c++">// å®šä¹‰ç­–ç•¥ç±»å‹ï¼ˆä½¿ç”¨å›è°ƒå‡½æ•°ï¼‰
using SortStrategy = std::function&lt;void(std::vector&lt;int&gt;&amp;)&gt;;

// æ’åºä¸Šä¸‹æ–‡ç±»
class Sorter {
private:
    SortStrategy strategy;
    
public:
    Sorter(SortStrategy strategy) : strategy(strategy) {}
    
    void setStrategy(SortStrategy newStrategy) {
        strategy = newStrategy;
    }
    
    void sort(std::vector&lt;int&gt;&amp; data) {
        strategy(data);
    }
};
</code></pre>
<p>ç­–ç•¥æ¨¡å¼å…è®¸åœ¨è¿è¡Œæ—¶åˆ‡æ¢ç®—æ³•ï¼Œéå¸¸çµæ´»ã€‚</p>
<h2 id="ä¹å›è°ƒå‡½æ•°çš„é™·é˜±ä¸æœ€ä½³å®è·µ">ä¹ã€å›è°ƒå‡½æ•°çš„é™·é˜±ä¸æœ€ä½³å®è·µ</h2>
<p>ä½¿ç”¨å›è°ƒå‡½æ•°è™½ç„¶å¼ºå¤§ï¼Œä½†ä¹Ÿå­˜åœ¨ä¸€äº›æ½œåœ¨çš„é—®é¢˜å’Œé™·é˜±ã€‚ä¸‹é¢æ€»ç»“ä¸€äº›å¸¸è§çš„å‘å’Œç›¸åº”çš„æœ€ä½³å®è·µï¼š</p>
<h3 id="1-ç”Ÿå‘½å‘¨æœŸé—®é¢˜">1. ç”Ÿå‘½å‘¨æœŸé—®é¢˜</h3>
<p><strong>é™·é˜±</strong>ï¼šå›è°ƒå‡½æ•°ä¸­å¼•ç”¨äº†å·²ç»è¢«é”€æ¯çš„å¯¹è±¡ã€‚</p>
<pre><code class="language-c++">void dangerousCallback() {
    char* buffer = new char[100];
    
    // æ³¨å†Œä¸€ä¸ªåœ¨æœªæ¥æ‰§è¡Œçš„å›è°ƒå‡½æ•°
    registerCallback([buffer]() {
        // å±é™©ï¼æ­¤æ—¶bufferå¯èƒ½å·²ç»è¢«åˆ é™¤
        strcpy(buffer, "Hello");
    });
    
    // bufferåœ¨è¿™é‡Œè¢«åˆ é™¤
    delete[] buffer;
}
</code></pre>
<p><strong>æœ€ä½³å®è·µ</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æº</li>
</ul>
<pre><code class="language-c++">void safeCallback() {
    // ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
    auto buffer = std::make_shared&lt;std::vector&lt;char&gt;&gt;(100);
    
    // æ™ºèƒ½æŒ‡é’ˆä¼šåœ¨æ‰€æœ‰å¼•ç”¨æ¶ˆå¤±æ—¶è‡ªåŠ¨é‡Šæ”¾
    registerCallback([buffer]() {
        // å®‰å…¨ï¼å³ä½¿åŸå§‹ä½œç”¨åŸŸç»“æŸï¼Œbufferä»ç„¶æœ‰æ•ˆ
        std::copy_n("Hello", 6, buffer-&gt;data());
    });
}
</code></pre>
<ul>
<li>æä¾›å–æ¶ˆæ³¨å†Œæœºåˆ¶</li>
</ul>
<pre><code class="language-c++">class CallbackManager {
    std::map&lt;int, std::function&lt;void()&gt;&gt; callbacks;
    int nextId = 0;
    
public:
    // è¿”å›æ ‡è¯†ç¬¦ï¼Œç”¨äºå–æ¶ˆæ³¨å†Œ
    int registerCallback(std::function&lt;void()&gt; cb) {
        int id = nextId++;
        callbacks[id] = cb;
        return id;
    }
    
    void unregisterCallback(int id) {
        callbacks.erase(id);
    }
};

void safeUsage() {
    CallbackManager manager;
    
    // ä¿å­˜IDç”¨äºå–æ¶ˆæ³¨å†Œ
    int callbackId = manager.registerCallback([]() { /* ... */ });
    
    // åœ¨åˆé€‚çš„æ—¶æœºå–æ¶ˆæ³¨å†Œ
    manager.unregisterCallback(callbackId);
}
</code></pre>
<h3 id="2-å›è°ƒåœ°ç‹±callback-hell">2. å›è°ƒåœ°ç‹±ï¼ˆCallback Hellï¼‰</h3>
<p><strong>é™·é˜±</strong>ï¼šåµŒå¥—å¤ªå¤šå±‚å›è°ƒï¼Œå¯¼è‡´ä»£ç éš¾ä»¥ç†è§£å’Œç»´æŠ¤ã€‚</p>
<pre><code class="language-c++">doTaskA([](int resultA) {
    doTaskB(resultA, [](int resultB) {
        doTaskC(resultB, [](int resultC) {
            // ä»£ç ç¼©è¿›è¶Šæ¥è¶Šæ·±ï¼Œéš¾ä»¥é˜…è¯»å’Œç»´æŠ¤
        });
    });
});
</code></pre>
<p><strong>æœ€ä½³å®è·µ</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨ std::async å’Œ std::futureï¼ˆC++11ï¼‰</li>
</ul>
<pre><code class="language-c++">// C++11åŠä»¥ä¸Š
std::future&lt;int&gt; doTaskAAsync() {
    return std::async(std::launch::async, []() {
        return doTaskA();
    });
}

std::future&lt;int&gt; doTaskBAsync(int resultA) {
    return std::async(std::launch::async, [resultA]() {
        return doTaskB(resultA);
    });
}

std::future&lt;int&gt; doTaskCAsync(int resultB) {
    return std::async(std::launch::async, [resultB]() {
        return doTaskC(resultB);
    });
}

// çœŸæ­£çš„å¼‚æ­¥é“¾å¼è°ƒç”¨
void chainedAsyncTasks() {
    try {
        // å¯åŠ¨ä»»åŠ¡A
        auto futureA = doTaskAAsync();
        
        // ç­‰å¾…Aå®Œæˆå¹¶å¯åŠ¨B
        auto resultA = futureA.get();
        auto futureB = doTaskBAsync(resultA);
        
        // ç­‰å¾…Bå®Œæˆå¹¶å¯åŠ¨C
        auto resultB = futureB.get();
        auto futureC = doTaskCAsync(resultB);
        
        // è·å–æœ€ç»ˆç»“æœ
        auto resultC = futureC.get();
        std::cout &lt;&lt; "Final result: " &lt;&lt; resultC &lt;&lt; std::endl;
    }
    catch(const std::exception&amp; e) {
        std::cerr &lt;&lt; "Error in task chain: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
<ul>
<li>ä½¿ç”¨åç¨‹ (C++20)</li>
</ul>
<pre><code class="language-c++">// ä½¿ç”¨C++20åç¨‹è§£å†³å›è°ƒåœ°ç‹±
#include &lt;coroutine&gt;

// ä¼ªä»£ç ï¼šç®€åŒ–çš„ä»»åŠ¡åç¨‹ç±»å‹
template&lt;typename T&gt;
struct Task {
    struct promise_type { /* åç¨‹å¿…éœ€çš„æ¥å£ */ };
    // ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„åç¨‹çŠ¶æ€æœº
};

// å¼‚æ­¥ä»»åŠ¡A
Task&lt;int&gt; doTaskAAsync() {
    // co_return è¿”å›å€¼å¹¶ç»“æŸåç¨‹ (ç±»ä¼¼returnä½†ç”¨äºåç¨‹)
    co_return doTaskA();
}

// å¼‚æ­¥ä»»åŠ¡B - æ¥æ”¶Açš„ç»“æœä½œä¸ºè¾“å…¥
Task&lt;int&gt; doTaskBAsync(int resultA) {
    co_return doTaskB(resultA);
}

// å¼‚æ­¥ä»»åŠ¡C - æ¥æ”¶Bçš„ç»“æœä½œä¸ºè¾“å…¥
Task&lt;int&gt; doTaskCAsync(int resultB) {
    co_return doTaskC(resultB);
}

// ä¸»ä»»åŠ¡ - åç¨‹æ–¹å¼é“¾æ¥æ‰€æœ‰ä»»åŠ¡
Task&lt;int&gt; processAllTasksAsync() {
    try {
        // co_await æš‚åœå½“å‰åç¨‹ï¼Œç­‰å¾…doTaskAAsync()å®Œæˆ
        // åç¨‹æš‚åœæ—¶ä¸ä¼šé˜»å¡çº¿ç¨‹ï¼Œæ§åˆ¶æƒè¿”å›ç»™è°ƒç”¨è€…
        int resultA = co_await doTaskAAsync();
        
        // å½“ä»»åŠ¡Aå®Œæˆåï¼Œåç¨‹ä»è¿™é‡Œç»§ç»­æ‰§è¡Œ
        std::cout &lt;&lt; "Task A completed: " &lt;&lt; resultA &lt;&lt; std::endl;
        
        // ç­‰å¾…ä»»åŠ¡Bå®Œæˆ
        int resultB = co_await doTaskBAsync(resultA);
        std::cout &lt;&lt; "Task B completed: " &lt;&lt; resultB &lt;&lt; std::endl;
        
        // ç­‰å¾…ä»»åŠ¡Cå®Œæˆ
        int resultC = co_await doTaskCAsync(resultB);
        std::cout &lt;&lt; "Task C completed: " &lt;&lt; resultC &lt;&lt; std::endl;
        
        // è¿”å›æœ€ç»ˆç»“æœ
        co_return resultC;
    } 
    catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Error in coroutine chain: " &lt;&lt; e.what() &lt;&lt; std::endl;
        co_return -1;
    }
}

// å¯åŠ¨åç¨‹é“¾ (ä¼ªä»£ç )
void runAsyncChain() {
    // å¯åŠ¨åç¨‹å¹¶ç­‰å¾…å®Œæˆ
    auto task = processAllTasksAsync();
    int finalResult = syncAwait(task);  // åŒæ­¥ç­‰å¾…åç¨‹å®Œæˆ
    std::cout &lt;&lt; "Final result: " &lt;&lt; finalResult &lt;&lt; std::endl;
}
</code></pre>
<h3 id="3-å¼‚å¸¸å¤„ç†">3. å¼‚å¸¸å¤„ç†</h3>
<p><strong>é™·é˜±</strong>ï¼šå›è°ƒå‡½æ•°ä¸­æŠ›å‡ºçš„å¼‚å¸¸æ— æ³•è¢«è°ƒç”¨è€…æ•è·ã€‚</p>
<pre><code class="language-c++">void riskyCallback() {
    try {
        executeCallback([]() {
            throw std::runtime_error("å›è°ƒä¸­çš„é”™è¯¯");  // è¿™ä¸ªå¼‚å¸¸æ— æ³•è¢«å¤–å±‚æ•è·
        });
    } catch (const std::exception&amp; e) {
        // è¿™é‡Œæ•è·ä¸åˆ°å›è°ƒä¸­æŠ›å‡ºçš„å¼‚å¸¸ï¼
        std::cout &lt;&lt; "æ•è·åˆ°å¼‚å¸¸: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
<p><strong>æœ€ä½³å®è·µ</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨é”™è¯¯ç ä»£æ›¿å¼‚å¸¸</li>
</ul>
<pre><code class="language-c++">// å®šä¹‰é”™è¯¯ç 
enum class ErrorCode {
    Success = 0,
    GeneralError = -1,
    NetworkError = -2,
    TimeoutError = -3
    // æ›´å¤šå…·ä½“çš„é”™è¯¯ç±»å‹...
};

// ä½¿ç”¨std::function
void executeSafe(std::function&lt;void(int result, ErrorCode code, const std::string&amp; message)&gt; callback) {
    try {
        // å°è¯•æ‰§è¡Œæ“ä½œ
        int result = performOperation();
        callback(result, ErrorCode::Success, "æ“ä½œæˆåŠŸ");
    } catch (const std::exception&amp; e) {
        // å¯ä»¥æ ¹æ®å¼‚å¸¸ç±»å‹è®¾ç½®ä¸åŒçš„é”™è¯¯ç 
        callback(0, ErrorCode::GeneralError, e.what());
    } catch (...) {
        callback(0, ErrorCode::GeneralError, "æœªçŸ¥é”™è¯¯");
    }
}
</code></pre>
<h3 id="4-çº¿ç¨‹å®‰å…¨é—®é¢˜">4. çº¿ç¨‹å®‰å…¨é—®é¢˜</h3>
<p><strong>é™·é˜±</strong>ï¼šå›è°ƒå¯èƒ½åœ¨ä¸åŒçº¿ç¨‹ä¸­æ‰§è¡Œï¼Œå¯¼è‡´å¹¶å‘è®¿é—®é—®é¢˜ã€‚</p>
<pre><code class="language-c++">class Counter {
    int count = 0;
    
public:
    void registerCallbacks() {
        // è¿™äº›å›è°ƒå¯èƒ½åœ¨ä¸åŒçº¿ç¨‹ä¸­è¢«è°ƒç”¨
        registerCallback([this]() { count++; });  // ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
        registerCallback([this]() { count++; });
    }
};
</code></pre>
<p><strong>æœ€ä½³å®è·µ</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«æ•°æ®</li>
</ul>
<pre><code class="language-c++">class ThreadSafeCounter {
    int count = 0;
    std::mutex mutex;
    
public:
    void registerCallbacks() {
        registerCallback([this]() { 
            std::lock_guard&lt;std::mutex&gt; lock(mutex);
            count++;  // ç°åœ¨æ˜¯çº¿ç¨‹å®‰å…¨çš„
        });
    }
};
</code></pre>
<ul>
<li>ä½¿ç”¨åŸå­æ“ä½œ</li>
</ul>
<pre><code class="language-c++">class AtomicCounter {
    std::atomic&lt;int&gt; count{0};
    
public:
    void registerCallbacks() {
        registerCallback([this]() { 
            count++;  // åŸå­æ“ä½œï¼Œçº¿ç¨‹å®‰å…¨
        });
    }
};
</code></pre>
<h3 id="5-å¾ªç¯å¼•ç”¨å†…å­˜æ³„æ¼">5. å¾ªç¯å¼•ç”¨ï¼ˆå†…å­˜æ³„æ¼ï¼‰</h3>
<p><strong>é™·é˜±</strong>ï¼šå¯¹è±¡é—´ç›¸äº’æŒæœ‰å›è°ƒï¼Œå¯¼è‡´å¾ªç¯å¼•ç”¨æ— æ³•é‡Šæ”¾å†…å­˜ã€‚</p>
<pre><code class="language-c++">class Button {
    std::function&lt;void()&gt; onClick;
    
public:
    void setClickHandler(std::function&lt;void()&gt; handler) {
        onClick = handler;
    }
};

class Dialog {
    std::shared_ptr&lt;Button&gt; button;
    
public:
    Dialog() {
        button = std::make_shared&lt;Button&gt;();
        // å¾ªç¯å¼•ç”¨: Dialogå¼•ç”¨Buttonï¼ŒButtonçš„å›è°ƒå¼•ç”¨Dialog
        button-&gt;setClickHandler([this]() {
            this-&gt;handleClick();  // æ•è·äº†thisæŒ‡é’ˆ
        });
    }
};
</code></pre>
<p><strong>æœ€ä½³å®è·µ</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨ enable_shared_from_this</li>
</ul>
<pre><code class="language-c++">class DialogWithWeakPtr : public std::enable_shared_from_this&lt;DialogWithWeakPtr&gt; {
    std::shared_ptr&lt;Button&gt; button;
    
public:
    DialogWithWeakPtr() {
        button = std::make_shared&lt;Button&gt;();
    }
    
    void initialize() {
        // å®‰å…¨åœ°è·å–thisçš„weak_ptr
        std::weak_ptr&lt;DialogWithWeakPtr&gt; weakThis = shared_from_this();
            
        button-&gt;setClickHandler([weakThis]() {
            // å°è¯•è·å–å¼ºå¼•ç”¨
            if (auto dialog = weakThis.lock()) {
                dialog-&gt;handleClick();  // å®‰å…¨ä½¿ç”¨
            }
        });
    }
    
    void handleClick() {
        // å¤„ç†ç‚¹å‡»äº‹ä»¶
    }
};

// ä½¿ç”¨æ–¹å¼
auto dialog = std::make_shared&lt;DialogWithWeakPtr&gt;();
dialog-&gt;initialize();  // å¿…é¡»åœ¨shared_ptræ„é€ åè°ƒç”¨
</code></pre>
<h2 id="åå›è°ƒå‡½æ•°åœ¨ç°ä»£cä¸­çš„æ¼”åŒ–">åã€å›è°ƒå‡½æ•°åœ¨ç°ä»£C++ä¸­çš„æ¼”åŒ–</h2>
<p>C++11åŠä»¥åçš„ç‰ˆæœ¬ä¸ºå›è°ƒå‡½æ•°æä¾›äº†æ›´å¤šç°ä»£åŒ–çš„å®ç°æ–¹å¼ï¼š</p>
<h3 id="1-stdfunctionå’Œstdbind">1. std::functionå’Œstd::bind</h3>
<p><code>std::function</code>æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡½æ•°åŒ…è£…å™¨ï¼Œå¯ä»¥å­˜å‚¨ä»»ä½•å¯è°ƒç”¨å¯¹è±¡ï¼š</p>
<pre><code class="language-c++">// æ¥å—ä»»ä½•æ»¡è¶³ç­¾åè¦æ±‚çš„å¯è°ƒç”¨å¯¹è±¡
void performOperation(std::function&lt;int(int, int)&gt; operation, int a, int b) {
    int result = operation(a, b);
    std::cout &lt;&lt; "ç»“æœ: " &lt;&lt; result &lt;&lt; std::endl;
}

// ä½¿ç”¨
performOperation([](int x, int y) { return x + y; }, 5, 3);
</code></pre>
<h3 id="2-lambdaè¡¨è¾¾å¼">2. Lambdaè¡¨è¾¾å¼</h3>
<p>Lambdaå¤§å¤§ç®€åŒ–äº†å›è°ƒå‡½æ•°çš„ç¼–å†™ï¼š</p>
<pre><code class="language-c++">std::vector&lt;int&gt; numbers = {5, 3, 1, 4, 2};

// ä½¿ç”¨lambdaä½œä¸ºæ’åºè§„åˆ™
std::sort(numbers.begin(), numbers.end(), 
          [](int a, int b) { return a &gt; b; });

// ä½¿ç”¨lambdaä½œä¸ºéå†æ“ä½œ
std::for_each(numbers.begin(), numbers.end(),
              [](int n) { std::cout &lt;&lt; n &lt;&lt; " "; });
</code></pre>
<h3 id="3-åç¨‹c20">3. åç¨‹ï¼ˆC++20ï¼‰</h3>
<p>C++20å¼•å…¥äº†åç¨‹ï¼Œå¯ä»¥æ›´ä¼˜é›…åœ°å¤„ç†å¼‚æ­¥æ“ä½œï¼š</p>
<pre><code class="language-c++">// æ³¨æ„ï¼šéœ€è¦C++20æ”¯æŒ
std::future&lt;int&gt; asyncOperation() {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    co_return 42;  // ä½¿ç”¨co_returnè¿”å›ç»“æœ
}

// ä½¿ç”¨co_awaitç­‰å¾…å¼‚æ­¥ç»“æœ
std::future&lt;void&gt; processResult() {
    int result = co_await asyncOperation();
    std::cout &lt;&lt; "ç»“æœ: " &lt;&lt; result &lt;&lt; std::endl;
}
</code></pre>
<p>åç¨‹å°†å›è°ƒé£æ ¼çš„å¼‚æ­¥ä»£ç è½¬å˜ä¸ºæ›´æ˜“è¯»çš„åŒæ­¥é£æ ¼ï¼Œæ˜¯è§£å†³å›è°ƒåœ°ç‹±çš„æœ‰æ•ˆæ–¹å¼ã€‚</p>
<h2 id="åä¸€æ€»ç»“å›è°ƒå‡½æ•°çš„æœ¬è´¨ä¸ä»·å€¼">åä¸€ã€æ€»ç»“ï¼šå›è°ƒå‡½æ•°çš„æœ¬è´¨ä¸ä»·å€¼</h2>
<p>ç»è¿‡è¿™ä¸€è·¯çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å›è°ƒå‡½æ•°çš„æœ¬è´¨ï¼š</p>
<ol>
<li><strong>æ§åˆ¶åè½¬ï¼ˆIoCï¼‰</strong> - æŠŠ"ä½•æ—¶æ‰§è¡Œ"çš„æ§åˆ¶æƒäº¤ç»™è°ƒç”¨è€…</li>
<li><strong>å»¶è¿Ÿæ‰§è¡Œ</strong> - åœ¨ç‰¹å®šæ¡ä»¶æ»¡è¶³æ—¶æ‰æ‰§è¡Œä»£ç </li>
<li><strong>è§£è€¦åˆ</strong> - åˆ†ç¦»"åšä»€ä¹ˆ"å’Œ"æ€ä¹ˆåš"</li>
<li><strong>è¡Œä¸ºå‚æ•°åŒ–</strong> - å°†è¡Œä¸ºä½œä¸ºå‚æ•°ä¼ é€’</li>
</ol>
<p>å›è°ƒå‡½æ•°çš„æœ€å¤§ä»·å€¼åœ¨äºå®ƒå®ç°äº†"æ§åˆ¶åè½¬"ï¼Œè¿™ä½¿å¾—ä»£ç æ›´åŠ çµæ´»ã€å¯æ‰©å±•ã€å¯ç»´æŠ¤ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå®ƒåœ¨GUIç¼–ç¨‹ã€äº‹ä»¶é©±åŠ¨ç³»ç»Ÿã€å¼‚æ­¥ç¼–ç¨‹ç­‰é¢†åŸŸå¦‚æ­¤é‡è¦ã€‚</p>
<p>æœ€åç”¨ä¸€å¥è¯æ€»ç»“å›è°ƒå‡½æ•°ï¼š<strong>æŠŠ"æ€ä¹ˆåš"çš„æƒåŠ›äº¤ç»™åˆ«äººï¼Œè‡ªå·±åªè´Ÿè´£"åšä»€ä¹ˆ"çš„ä¸€ç§ç¼–ç¨‹æŠ€å·§ã€‚</strong></p>
<hr>
<p>æ€ä¹ˆæ ·ï¼Ÿé€šè¿‡è¿™ç¯‡æ–‡ç« ï¼Œä½ æ˜¯ä¸æ˜¯å¯¹å›è°ƒå‡½æ•°æœ‰äº†æ›´æ·±å…¥çš„ç†è§£ï¼Ÿä»æ‡µæ‡‚åˆ°å…¥é—¨ï¼Œå†åˆ°èƒ½å¤Ÿåœ¨å®æˆ˜ä¸­çµæ´»è¿ç”¨ï¼Œç›¸ä¿¡ä½ å·²ç»æŒæ¡äº†è¿™ä¸ªå¼ºå¤§çš„ç¼–ç¨‹æŠ€å·§ã€‚</p>
<p>å…¶å®ï¼Œç¼–ç¨‹ä¸­è¿˜æœ‰å¾ˆå¤šç±»ä¼¼çš„çŸ¥è¯†ç‚¹ï¼Œçœ‹èµ·æ¥ç®€å•ï¼Œä½†è¦çœŸæ­£æŒæ¡å´ä¸å®¹æ˜“ã€‚å°±åƒæˆ‘ä»¬ä»Šå¤©è®²çš„å›è°ƒå‡½æ•°ï¼Œè¡¨é¢ä¸Šåªæ˜¯"å‡½æ•°æŒ‡é’ˆä½œä¸ºå‚æ•°"è¿™ä¹ˆç®€å•ï¼Œæ·±å…¥äº†è§£å´å‘ç°å®ƒæ¶‰åŠæ§åˆ¶åè½¬ã€å¼‚æ­¥ç¼–ç¨‹ç­‰é«˜çº§æ¦‚å¿µï¼Œå®æˆ˜ä¸­è¿˜æœ‰å„ç§å‘éœ€è¦é¿å¼€ã€‚</p>
<p>å¦‚æœä½ æƒ³ç»§ç»­æ·±å…¥å­¦ä¹ æ›´å¤š <strong>è®¡ç®—æœºåŸºç¡€çŸ¥è¯†</strong> å’Œ <strong>C/C++å®æˆ˜æŠ€å·§</strong>ï¼Œæ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·ã€<strong>è·Ÿç€å°åº·å­¦ç¼–ç¨‹</strong>ã€‘ã€‚åœ¨é‚£é‡Œï¼Œæˆ‘ä¼šæŒç»­åˆ†äº«ï¼š</p>
<ul>
<li>è®¡ç®—æœºåŸºç¡€çŸ¥è¯†çš„æ·±å…¥æµ…å‡ºè®²è§£</li>
<li>Linux C/C++åç«¯å¼€å‘æ ¸å¿ƒæŠ€æœ¯</li>
<li>å¸¸è§å¤§å‚é¢è¯•é¢˜è¯¦ç»†è§£æ</li>
<li>è®¡ç®—æœºç½‘ç»œã€æ“ä½œç³»ç»Ÿã€è®¡ç®—æœºä½“ç³»ç»“æ„ç­‰ä¸“é¢˜</li>
<li>ä»¥åŠåƒä»Šå¤©è¿™æ ·çš„ç¼–ç¨‹å®æˆ˜ç»éªŒ</li>
</ul>
<p>æˆ‘çš„é£æ ¼å°±æ˜¯æŠŠå¤æ‚çš„ä¸œè¥¿è®²ç®€å•ï¼ŒæŠŠæ¯ç‡¥çš„çŸ¥è¯†è®²æœ‰è¶£ï¼Œç¡®ä¿ä½ èƒ½è½»æ¾ç†è§£å¹¶åº”ç”¨åˆ°å®é™…å·¥ä½œä¸­ã€‚ä¸ç®¡ä½ æ˜¯ç¼–ç¨‹æ–°æ‰‹è¿˜æ˜¯æœ‰ç»éªŒçš„å¼€å‘è€…ï¼Œéƒ½èƒ½åœ¨å…¬ä¼—å·æ‰¾åˆ°é€‚åˆè‡ªå·±çš„å†…å®¹ã€‚</p>
<p>å­¦ä¹ æ˜¯ä¸€åœºé©¬æ‹‰æ¾ï¼Œè€Œä¸æ˜¯çŸ­è·‘ã€‚å¸Œæœ›æˆ‘ä»¬èƒ½ä¸€èµ·åœ¨ç¼–ç¨‹çš„é“è·¯ä¸Šä¸æ–­è¿›æ­¥ï¼Œäº’ç›¸æˆé•¿ï¼</p>
<p>å¦‚æœè§‰å¾—è¿™ç¯‡æ–‡ç« ä¸é”™ï¼Œåˆ«å¿˜äº†<strong>ç‚¹èµã€æ”¶è—å’Œå…³æ³¨</strong>å“¦~ æˆ–è€…<strong>åˆ†äº«</strong>ç»™ä½ çš„æœ‹å‹ä»¬ï¼ä½ çš„æ¯ä¸€æ¬¡äº’åŠ¨ï¼Œéƒ½æ˜¯æˆ‘åˆ›ä½œçš„æœ€å¤§åŠ¨åŠ›ï¼</p>
<h2 id="äº’åŠ¨ç¯èŠ‚">äº’åŠ¨ç¯èŠ‚</h2>
<p>ä½ åœ¨ä½¿ç”¨å›è°ƒå‡½æ•°æ—¶é‡åˆ°è¿‡å“ªäº›å‘ï¼Ÿæˆ–è€…æœ‰ä»€ä¹ˆç–‘é—®ï¼Ÿæ¬¢è¿åœ¨è¯„è®ºåŒºåˆ†äº«ä½ çš„ç»éªŒå’Œå›°æƒ‘ï¼Œæˆ‘ä»¬ä¸€èµ·è®¨è®ºï¼</p>
<hr>
<p>å…³æ³¨æˆ‘ï¼Œå¸¦ä½ ç”¨æœ€é€šä¿—æ˜“æ‡‚çš„æ–¹å¼æŒæ¡ç¼–ç¨‹æŠ€å·§~</p>
<h4 id="æ€ä¹ˆå…³æ³¨æˆ‘çš„å…¬ä¼—å·">æ€ä¹ˆå…³æ³¨æˆ‘çš„å…¬ä¼—å·ï¼Ÿ</h4>
<p>æ‰«ä¸‹æ–¹å…¬ä¼—å·äºŒç»´ç å³å¯å…³æ³¨ã€‚</p>
<p><img src="https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png" alt="" loading="lazy"></p>
<p>å¦å¤–ï¼Œå°åº·è¿˜å»ºäº†ä¸€ä¸ªæŠ€æœ¯äº¤æµç¾¤ï¼Œä¸“é—¨èŠæŠ€æœ¯ã€ç­”ç–‘è§£æƒ‘ã€‚å¦‚æœä½ åœ¨è¯»æ–‡ç« æ—¶ç¢°åˆ°ä¸æ‡‚çš„åœ°æ–¹ï¼Œéšæ—¶æ¬¢è¿æ¥ç¾¤é‡Œæé—®ï¼æˆ‘ä¼šå°½åŠ›å¸®å¤§å®¶è§£ç­”ï¼Œç¾¤é‡Œè¿˜æœ‰ä¸å°‘æŠ€æœ¯å¤§ä½¬åœ¨çº¿æ”¯æ´ï¼Œå’±ä»¬ä¸€èµ·å­¦ä¹ è¿›æ­¥ï¼Œäº’ç›¸æˆé•¿ï¼</p>
<p><img src="https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.204083268454861" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-03 19:25">2025-04-03 19:24</span>&nbsp;
<a href="https://www.cnblogs.com/xiaokang-coding">æ±Ÿå°åº·</a>&nbsp;
é˜…è¯»(<span id="post_view_count">81</span>)&nbsp;
è¯„è®º(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18801623" rel="nofollow">ç¼–è¾‘</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18801623);return false;">æ”¶è—</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18801623', targetLink: 'https://www.cnblogs.com/xiaokang-coding/p/18801623', title: 'ã€Œç¡¬æ ¸å®æˆ˜ã€å›è°ƒå‡½æ•°åˆ°åº•æ˜¯ä¸ªå•¥ï¼Ÿä¸€æ–‡å¸¦ä½ ä»åŸç†åˆ°å®æˆ˜å½»åº•æŒæ¡C/C++å›è°ƒå‡½æ•°' })">ä¸¾æŠ¥</a>
</div>
        