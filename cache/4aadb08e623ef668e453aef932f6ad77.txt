
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/threeAgePie/p/19025357" title="发布于 2025-08-06 16:34">
    <span role="heading" aria-level="2">Java文件写入与编码、字节数组、字符集、字符编解码 一文打通！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-编码操作和解码操作">1. 编码操作和解码操作</h1>
<p>编码操作是把字符串映射为一组byte序列。以何种方式映射？比如把“你”映射为00000000还是11111111？这是由编码集决定的。</p>
<p>常见的字符编码集如UTF-8、GBK等。</p>
<p>解码操作是把一组byte映射为字符串。同理根据编码集就可以进行解码操作。这是一个互逆的过程。</p>
<p>类似于谍战片中的情报，写在纸上的是加密内容（byte序列），当接头人拿到情报后通过密码本(编码集)，解出真正的内容。</p>
<h1 id="2-案例">2. 案例</h1>
<p>现在提出一个需求，你来编写一个Java接口。<br>
<code>实现接收一个网络请求，请求包含一个字符串参数，你把这个字符串保存到C盘为a.txt文档。</code></p>
<p>这个过程设计到哪些编码和解码,是如何进行的？。</p>
<p>因为上层网络传输以byte为单位传输。</p>
<p>首先浏览器发送http请求时会把字符串参数“你好”根据编码方式(如UTF-8)编码为byte数组[0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD]，从网络中传输。</p>
<p>当后端接收到请求后由Spring MVC框架会自动读取参数byte数组，默认按照UTF-8编码进行解码（版本不同解码时默认编码方式可能不同），创建一个String对象。</p>
<p>现在我们把字符串写到本地文件a.txt.</p>
<p>要知道文件存储同样是二进制，因此需要把字符串转为byte数组。</p>
<p>把byte数组写到本地磁盘，这个过程就完成了。</p>
<p>可能有的同学会有疑问？写入的a.txt文件你说是byte数组，但是我看到的是字符串呀！</p>
<p>你看到的是字符串，这是因为你打开文本使用的软件会读取byte序列，按照系统编码方式(可能是UTF-8、可能是GBK可以设置)进行编码后呈现给你的。</p>
<p>相信你通过电脑记事本打开有些文件，一定见过乱码吧。出现乱码的原因是通过某种编码方式写入磁盘的byte数组，它与记事本软件打开文本时使用的编码方式不一致。</p>
<p>这就是我们常说的编码不一致的问题。</p>
<h1 id="java中string默认编码是utf-16是怎么回事">Java中String默认编码是UTF-16是怎么回事？</h1>
<p>这里说的String默认编码是指String字符串在内存中的编码方式。<code>String</code>对象在内存中始终使用UTF-16编码。也就是说，无论原始字节是何种编码（UTF-8、GBK等），一旦被转换成<code>String</code>，它就会以UTF-16编码的形式存储在内存中。</p>
<h1 id="字符集和字符编码">字符集和字符编码</h1>
<p>Unicode是字符集。Unicode 为全球几乎所有字符（文字、符号、表情等）分配了唯一的数字编号（称为 “码点”，格式为 U+XXXX），例如 U+0061 代表小写字母 “a”，U+4E2D 代表汉字 “中”。它只定义了字符与码点的对应关系，不涉及存储或传输的具体方式。char类型字符强制转换为int类型的值，对应的是该字符的unicode码点。</p>
<p>UTF-8 是 “Unicode 转换格式”（Unicode Transformation Format）的一种，它规定了如何将 Unicode 码点转换为计算机可存储的二进制字节序列。</p>
<hr>
<p>追加 InputStreamReader 和 OutStreamReader<br>
实际底层Writer还是写入的字节序列，Reader读取的还是字节序列，只是内部做了包装，把字节转为字符，这样方便用户调用函数操作字符。</p>
<p>Java I/O使用了装饰器模式，每一层都有特定职责。</p>
<pre><code>// 字符流处理
BufferedReader reader = new BufferedReader(     // 提供缓冲功能
                        new InputStreamReader( // 字节转字符
                          inputStream));       // 原始字节流

// 字节流处理  
BufferedInputStream bis = new BufferedInputStream( // 提供缓冲功能
                           inputStream);          // 原始字节流
</code></pre>
<p><code>个人水平有限，如有错误还请各位大佬指正</code></p>

</div>
<div id="MySignature" role="contentinfo">
    生活虽然苦闷，但跑起来总是带风！
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.20833333333333334" data-date-updated="2025-08-06 21:34">2025-08-06 16:34</span>&nbsp;
<a href="https://www.cnblogs.com/threeAgePie">三只蛋黄派</a>&nbsp;
阅读(<span id="post_view_count">99</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19025357);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19025357', targetLink: 'https://www.cnblogs.com/threeAgePie/p/19025357', title: 'Java文件写入与编码、字节数组、字符集、字符编解码 一文打通！' })">举报</a>
</div>
        