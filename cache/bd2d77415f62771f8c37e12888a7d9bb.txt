
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18716232" title="发布于 2025-02-14 22:01">
    <span role="heading" aria-level="2">SQL优化的20条军规</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>作为一个写SQL的程序员，代码写得好不好是一回事，但SQL写得烂，性能拉胯，全公司都得为你的慢查询买单，尤其在大数据量表上，SQL写不好就是“内鬼”级别的错误。</p>
<p>今天不整那些虚的，直接来点硬货：20条SQL优化小技巧，每一条都能救你一命，关键是，我还给你配上代码例子，拿去直接用，希望对你会有所帮助。</p>
<p>我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，里面的技术亮点挺多的，欢迎访问和star。[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
<h2 id="1-避免select-">1. 避免SELECT *</h2>
<p>别一上来就 <code>SELECT *</code>，你觉得这样写省事，但数据库得把整张表的每一列都给你搬过来，代价大得吓人。需要啥列写清楚，别偷懒。</p>
<pre><code class="language-sql">-- 错误写法
SELECT * FROM users;

-- 正确写法
SELECT id, name, age FROM users;
</code></pre>
<p><strong>优化原因</strong>：减少网络传输数据量，避免无用字段占内存。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<h2 id="2-where字段要有索引">2. WHERE字段要有索引</h2>
<p>你写 WHERE 条件时，涉及到的字段要有索引。没索引，MySQL 就得一行行地扫描表，全表扫描慢得你怀疑人生。</p>
<pre><code class="language-sql">-- 创建索引
CREATE INDEX idx_users_age ON users(age);

-- 使用索引查询
SELECT * FROM users WHERE age &gt; 25;
</code></pre>
<p><strong>优化原因</strong>：索引就像目录，能直接跳到你要的那页，而不是一本书从头翻到尾。</p>
<h2 id="3-用explain分析sql性能">3. 用EXPLAIN分析SQL性能</h2>
<p>写SQL前，别直接跑，先加个 <code>EXPLAIN</code> 看看执行计划。看啥？<code>type</code> 是不是 <code>ALL</code>，是不是走了全表扫描。如果有，赶紧改。</p>
<pre><code class="language-sql">EXPLAIN SELECT * FROM users WHERE age &gt; 25;
</code></pre>
<p><strong>优化原因</strong>：清楚执行计划，知道SQL跑得是不是高效。</p>
<h2 id="4-避免where里的函数操作">4. 避免WHERE里的函数操作</h2>
<p>别在WHERE条件里对字段用函数，索引直接失效。</p>
<pre><code class="language-sql">-- 错误写法
SELECT * FROM users WHERE YEAR(create_time) = 2023;

-- 正确写法
SELECT * FROM users WHERE create_time &gt;= '2023-01-01' AND create_time &lt; '2024-01-01';
</code></pre>
<p><strong>优化原因</strong>：函数操作让索引失效，回表扫描浪费时间。</p>
<h2 id="5-避免or条件改用union">5. 避免OR条件，改用UNION</h2>
<p>WHERE 里写了个 OR，可能导致两个字段的索引全失效。别用 OR，用 UNION 替代。</p>
<pre><code class="language-sql">-- 错误写法
SELECT * FROM users WHERE age = 25 OR city = 'shenzhen';

-- 正确写法
SELECT * FROM users WHERE age = 25
UNION
SELECT * FROM users WHERE city = 'shenzhen';
</code></pre>
<p><strong>优化原因</strong>：OR 会让索引失效，而 UNION 可以分别利用索引。</p>
<h2 id="6-优化limit分页">6. 优化LIMIT分页</h2>
<p>LIMIT 用得好不好直接影响性能，特别是分页到 10000 页的时候，直接卡死你。改进方法是用 ID 或时间范围过滤。</p>
<pre><code class="language-sql">-- 错误写法
SELECT * FROM users ORDER BY create_time LIMIT 10000, 10;

-- 正确写法
SELECT * FROM users WHERE id &gt; 10000 ORDER BY id LIMIT 10;
</code></pre>
<p><strong>优化原因</strong>：用范围过滤减少不必要的扫描。</p>
<h2 id="7-用覆盖索引">7. 用覆盖索引</h2>
<p>覆盖索引的意思是，查询的字段全在索引里，MySQL 不需要回表。</p>
<pre><code class="language-sql">-- 创建覆盖索引
CREATE INDEX idx_users_age_name ON users(age, name);

-- 查询
SELECT name FROM users WHERE age &gt; 25;
</code></pre>
<p><strong>优化原因</strong>：只从索引获取数据，不用回表，提高查询速度。</p>
<h2 id="8-减少join表数量">8. 减少JOIN表数量</h2>
<p><code>JOIN</code> 太多表会让执行计划复杂化，数据量大的表用 JOIN，性能就拉了。</p>
<pre><code class="language-sql">-- 复杂的多表JOIN
SELECT * FROM orders
JOIN users ON orders.user_id = users.id
JOIN products ON orders.product_id = products.id;

-- 优化：拆分查询
SELECT * FROM orders WHERE user_id IN (
    SELECT id FROM users WHERE age &gt; 25
);
</code></pre>
<p><strong>优化原因</strong>：减少中间表的数据处理量，降低JOIN复杂度。</p>
<h2 id="9-使用批量插入">9. 使用批量插入</h2>
<p>单条插入写多了，性能会被写锁拖垮，换成批量插入。</p>
<pre><code class="language-sql">-- 错误写法
INSERT INTO users (id, name) VALUES (1, 'zhangsan');
INSERT INTO users (id, name) VALUES (2, 'lisi');

-- 正确写法
INSERT INTO users (id, name) VALUES (1, 'zhangsan'), (2, 'lisi');
</code></pre>
<p><strong>优化原因</strong>：减少数据库连接和提交的次数。</p>
<h2 id="10-group-by前过滤数据">10. GROUP BY前过滤数据</h2>
<p><code>GROUP BY</code> 本质上是对结果排序分组，数据量大时效率感人。先用 <code>WHERE</code> 把数据量缩小。</p>
<pre><code class="language-sql">-- 错误写法
SELECT age, COUNT(*) FROM users GROUP BY age;

-- 正确写法
SELECT age, COUNT(*) FROM users WHERE age &gt; 25 GROUP BY age;
</code></pre>
<p><strong>优化原因</strong>：减少GROUP BY处理的数据量。</p>
<h2 id="11-like查询优化">11. LIKE查询优化</h2>
<p>模糊查询用 <code>%xxx%</code> 的时候，索引没了，直接全表扫描。改成前缀匹配，或者用全文索引。</p>
<pre><code class="language-sql">-- 前缀匹配
SELECT * FROM users WHERE name LIKE 'zhang%';

-- 全文索引
CREATE FULLTEXT INDEX idx_name ON users(name);
SELECT * FROM users WHERE MATCH(name) AGAINST('zhang');
</code></pre>
<p><strong>优化原因</strong>：用索引提高查询效率。</p>
<h2 id="12-避免大字段频繁查询">12. 避免大字段频繁查询</h2>
<p>TEXT 和 BLOB 这种大字段会拖累查询性能，把它们单独拆到一张表。</p>
<pre><code class="language-sql">-- 原表
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    profile TEXT
);

-- 拆表
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    profile TEXT
);
</code></pre>
<p><strong>优化原因</strong>：减少主表查询时的大字段负担。</p>
<h2 id="13-定期清理无用数据"><strong>13. 定期清理无用数据</strong></h2>
<p>表里垃圾数据太多，索引也跟着膨胀，查询性能直线下降。</p>
<pre><code class="language-sql">-- 定期清理历史数据
DELETE FROM logs WHERE create_time &lt; '2022-01-01';
</code></pre>
<p><strong>优化原因</strong>：保持表轻量化，避免数据膨胀。</p>
<h2 id="14-用分区表优化大数据表">14. 用分区表优化大数据表</h2>
<p>分区表是大数据量优化的利器，把数据按范围分成多个分区。</p>
<pre><code class="language-sql">CREATE TABLE orders (
    id INT NOT NULL,
    order_date DATE NOT NULL
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024)
);
</code></pre>
<p><strong>优化原因</strong>：查询只扫描一个分区，而不是整张表。</p>
<h2 id="15-索引字段选用低基数的字段">15. 索引字段选用低基数的字段</h2>
<p>基数低的字段（比如性别）用索引没意义，能用组合索引就用。</p>
<pre><code class="language-sql">-- 错误：性别字段加索引
CREATE INDEX idx_gender ON users(gender);

-- 正确：性别+年龄组合索引
CREATE INDEX idx_gender_age ON users(gender, age);
</code></pre>
<p><strong>优化原因</strong>：避免低基数索引浪费存储。</p>
<h2 id="16-控制表字段数量">16. 控制表字段数量</h2>
<p>表字段太多会让数据表臃肿，查询性能也会变差。合理拆分表。</p>
<h2 id="17-用事务优化批量更新">17. 用事务优化批量更新</h2>
<p>大批量更新用事务，可以减少锁竞争。</p>
<pre><code class="language-sql">START TRANSACTION;
UPDATE users SET age = age + 1 WHERE age &gt; 25;
COMMIT;
</code></pre>
<h2 id="18-用查询缓存">18. 用查询缓存</h2>
<p>MySQL 有查询缓存机制，适合静态数据高频查询场景。</p>
<pre><code class="language-sql">-- 开启查询缓存
SET GLOBAL query_cache_size = 1048576;
SELECT SQL_CACHE * FROM users WHERE age &gt; 25;
</code></pre>
<h2 id="19-用preparedstatement">19. 用PreparedStatement</h2>
<p>预编译可以提高性能，还能防止 SQL 注入。</p>
<h2 id="20-定期优化表">20. 定期优化表</h2>
<p>表用了很久会有碎片，定期优化表能提高性能。</p>
<pre><code class="language-sql">OPTIMIZE TABLE users;
</code></pre>
<h2 id="总结">总结</h2>
<p>SQL 优化是个手艺活，写好 SQL 就能少掉无数锅，尤其是团队开发时，一个烂 SQL 能拖死整个项目。</p>
<p>这 20 条技巧别只看一遍，拿着自己的查询多实践，别等线上掉链子才后悔！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008426013408564815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 22:02">2025-02-14 22:01</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18716232" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18716232);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18716232', targetLink: 'https://www.cnblogs.com/12lisu/p/18716232', title: 'SQL优化的20条军规' })">举报</a>
</div>
        