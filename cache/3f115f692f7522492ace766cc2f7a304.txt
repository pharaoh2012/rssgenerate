
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/april-code/p/18818351" title="发布于 2025-04-10 14:10">
    <span role="heading" aria-level="2">ocr识别遇到的小问题-图片的EXIF 元数据</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>  之前在公司通过paddleocr写了个接口，传入图片的base64编码返回识别出的文字信息。但是图片为横向时，文字行会乱序，所以准备新加一个功能通过paddleclas推理图片文字的倾斜角度，并将图片旋转为正向。在测试过程中发现windows打开一个正向图片，调用ocr接口时无法识别，返回一堆奇怪的文字。</p>
<h2 id="排查过程">排查过程</h2>
<p>  首先我需要识别的图片在windows中打开是这样的，宽为4096，长为3072<br>
<img src="https://img2024.cnblogs.com/blog/2715357/202504/2715357-20250410132811254-478912627.jpg" alt="" loading="lazy"><br>
<br><br>
  识别出的结果为<br>
<img src="https://img2024.cnblogs.com/blog/2715357/202504/2715357-20250410133157651-1417612112.jpg" alt="" loading="lazy"><br>
（图片内容为示例图片，实际是纯文字图片，返回的内容都是奇怪的文字）<br>
<br><br>
  之后尝试了其他正向图片都可以正常识别，于是在PyCharm中打算通过python打开图片，然后使用本地的paddleocr尝试一下。使用如下代码：</p>
<pre><code>with open("C:\\Users\\xxxxx\\test.jpg", "rb") as image_file:
     file_content = base64.b64encode(image_file.read()).decode("utf8")
</code></pre>
<p>  发现预览图片时，图片是旋转的，于是将图片复制到pycharm和idea里，发现全部都是旋转的图片。<br>
<img src="https://img2024.cnblogs.com/blog/2715357/202504/2715357-20250410134151649-2052023403.jpg" alt="" loading="lazy"><br>
  并且发现只有jpg格式的出现了这个问题，其他如PNG格式的图片是正常的。<br>
<br><br>
  于是搜索了一下jpg和PNG图片的不同之处。发现JPEG 图片通常包含 EXIF 元数据，里面包括了一个 Orientation 标签，它告诉系统应该如何旋转图片来正常显示。</p>
<ul>
<li>
<p>Windows 的照片查看器会读取这个 Orientation 标签，并自动旋转图片。</p>
</li>
<li>
<p>但一些 IDE（如 PyCharm、IDEA）中的图片查看器或第三方库（如 PIL、OpenCV）通常不读取 EXIF 的 Orientation 信息，而是直接以图像的原始像素排列进行显示。</p>
</li>
</ul>
<p>  那么问题就很明显了，使用如下代码对图片的EXIF信息进行读取</p>
<pre><code>from PIL import Image, ExifTags

def open_image_with_correct_orientation(path):
    image = Image.open(path)

    try:
        for orientation in ExifTags.TAGS.keys():
            if ExifTags.TAGS[orientation] == 'Orientation':
                break

        exif = image._getexif()
        if exif is not None:
            orientation_value = exif.get(orientation)

            if orientation_value == 3:
                image = image.rotate(180, expand=True)
            elif orientation_value == 6:
                image = image.rotate(270, expand=True)
            elif orientation_value == 8:
                image = image.rotate(90, expand=True)
    except Exception as e:
        print(f"读取 EXIF 方向失败: {e}")

    return image

# 示例使用
img = open_image_with_correct_orientation("your_image.jpg")
img.show()
</code></pre>
<p>  返回结果为<br>
<img src="https://img2024.cnblogs.com/blog/2715357/202504/2715357-20250410134546231-268167727.jpg" alt="" loading="lazy"><br>
  发现Orientation 为3，证明原始图片确实是旋转过的。</p>
<h2 id="解决办法">解决办法</h2>
<p>1、通过上述代码获取图片的元数据的旋转信息，对图片进行旋转<br>
2、通过paddleclas判断文字的倾斜角度，对图片进行旋转，我这边采用的是这种方法，毕竟这次遇到的bug是因为测试为了方便直接对图片进行旋转并保存而出现。线上环境中图片由于每个人拍摄角度不固定，所以很可能上传的原始图片就是倾倒的。</p>
<h2 id="图片的exif元数据">图片的EXIF元数据</h2>
<p><strong>常见关键字段：</strong></p>
<ul>
<li>
<p>Orientation：图像方向（是否旋转）</p>
</li>
<li>
<p>DateTime：拍摄时间</p>
</li>
<li>
<p>Make / Model：设备品牌 / 型号</p>
</li>
<li>
<p>ExifImageWidth / ExifImageHeight：原始像素尺寸</p>
</li>
<li>
<p>GPSInfo：地理位置信息（如果有）<br>
<br></p>
</li>
</ul>
<p><strong>Orientation 的取值含义：</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>正常</td>
</tr>
<tr>
<td>3</td>
<td>旋转 180 度</td>
</tr>
<tr>
<td>6</td>
<td>顺时针旋转 90 度</td>
</tr>
<tr>
<td>8</td>
<td>逆时针旋转 90 度</td>
</tr>
</tbody>
</table>
<p><strong>常见支持 EXIF 的图片格式</strong>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>JPEG / JPG</td>
<td>✅ 是主要支持 EXIF 的格式</td>
</tr>
<tr>
<td>TIFF</td>
<td>✅ 原始格式之一，支持丰富的元信息</td>
</tr>
<tr>
<td>HEIF / HEIC</td>
<td>✅ 新一代图像格式（如 iPhone 拍照），支持 EXIF，但不是所有工具都能读取</td>
</tr>
<tr>
<td>WebP</td>
<td>✅ 支持嵌入元数据（EXIF 和 XMP），但不是标准实现的一部分，兼容性差异较大</td>
</tr>
<tr>
<td>RAW 格式（如 .CR2, .NEF, .ARW, .DNG 等）</td>
<td>✅ 摄影相机原始文件，通常包含大量 EXIF 和其他元数据</td>
</tr>
<tr>
<td>PNG</td>
<td>❌ 不支持 EXIF，但可以写入其他形式的元数据（如 tEXt 或 iTXt）</td>
</tr>
<tr>
<td>BMP</td>
<td>❌ 不支持 EXIF</td>
</tr>
<tr>
<td>GIF</td>
<td>❌ 不支持 EXIF</td>
</tr>
<tr>
<td>SVG</td>
<td>❌ 是 XML 文本格式，不支持 EXIF，但可以有自定义 metadata 区域</td>
</tr>
</tbody>
</table>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/april-code/" target="_blank">日报初级开发工程师</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/april-code/p/18818351" target="_blank">https://www.cnblogs.com/april-code/p/18818351</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.008427580181712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-10 14:10">2025-04-10 14:10</span>&nbsp;
<a href="https://www.cnblogs.com/april-code">日报初级开发工程师</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18818351" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18818351);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18818351', targetLink: 'https://www.cnblogs.com/april-code/p/18818351', title: 'ocr识别遇到的小问题-图片的EXIF 元数据' })">举报</a>
</div>
        