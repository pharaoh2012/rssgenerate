
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fs7744/p/19013049" title="发布于 2025-07-30 15:41">
    <span role="heading" aria-level="2">c# ACME client (补充)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上一篇 <a href="https://www.cnblogs.com/fs7744/p/19009427" target="_blank">c# ACME client</a> 漏了一部分内容，今天补上</p>
<p>除了之前介绍的在 asp.net core 使用方式，还可以单独在代码中使用client</p>
<h3 id="简化用法">简化用法</h3>
<p>如果已经集成好完全的自动证书申请验证，就可以使用已经封装好的代码进行简单使用</p>
<p>举例在asp.net core提供 一个api  可以根据参数申请证书</p>
<p>starup</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddAcmeChallengeCore(config: c =&gt;
{
    c.HttpClientConfig = new VKProxy.Config.HttpClientConfig()
    {
        DangerousAcceptAnyServerCertificate = true
    };
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}
app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<p>api</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
using VKProxy.ACME.AspNetCore;
using VKProxy.Core.Extensions;

namespace WithApi.Controllers;

[ApiController]
[Route("[controller]")]
public class CertController : ControllerBase
{
    private readonly IAcmeStateIniter initer;

    public CertController(IAcmeStateIniter initer)
    {
        this.initer = initer;
    }

    [HttpGet]
    public async Task&lt;string&gt; Get([FromQuery] string domain)
    {
        // 证书配置
        var o = new AcmeChallengeOptions()
        {
            AllowedChallengeTypes = VKProxy.ACME.AspNetCore.ChallengeType.Http01,
            Server = new Uri("https://127.0.0.1:14000/dir"),
            DomainNames = new[] { domain },
            AdditionalIssuers = new[] { """
                        -----BEGIN CERTIFICATE-----
                        MIIDGzCCAgOgAwIBAgIIUPFry5qBu34wDQYJKoZIhvcNAQELBQAwIDEeMBwGA1UE
                        AxMVUGViYmxlIFJvb3QgQ0EgMjFjNjY3MCAXDTI1MDcyMjAxMTA0OVoYDzIwNTUw
                        NzIyMDExMDQ5WjAgMR4wHAYDVQQDExVQZWJibGUgUm9vdCBDQSAyMWM2NjcwggEi
                        MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCxNKa4y93OFYaSx8bcbuWsHHnW
                        mpfsobK5Elf7GE02mi/cDrMP+wR1l53BuucrW04OyoewkBsJNZoxEy1DkCjxv4+g
                        Q+HgGCR5R14ex17ZdFxpcl42H8QnRB3IqVBlJiz0JyGZwiaOamOkUTVEYTGDeuxu
                        PglpvboGeatsWQe0MJJfBN8OxLVUmi6Y/enbzlIdv3tvgQujfPNiS8MLDMBuIiMs
                        ixhu8YAzUqvVKZoQVK7GwbD9WrVBKub8w86StKFmU14aSXahidt8IENdpLO2OT3J
                        y1nt25QDsAmtS1/wGnTDPeefLGsM7kGYNesQkSW0w8Um4p9KLWKnKyOvzPZrAgMB
                        AAGjVzBVMA4GA1UdDwEB/wQEAwIChDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNV
                        HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRoXcwo6c5J8jMweiHKPw4OlcWIQzANBgkq
                        hkiG9w0BAQsFAAOCAQEAad9XT4sN1KserYtCxBKmoPhPAHInHYgG/Z2gd6KqdsK9
                        biIgEbKo84tClLqA6XCN/yN1bMQL2ZMbWBF8oHv/A5o0atpTpd+Ho+punHYRIpqv
                        akUX21Zsu6NdAuH7g7m9t9h/lc6tgiqaAf2HwpC3NrXmUlPRqLay7/t+BFQU6dBa
                        E+qzmL7lHZQf1UArfb+QDYH2XsFCk9Pjv0xdP+PGwf8HqHhfPLctvus5JL+LXp0X
                        68eWKQCs1CrL8cUMwcELlW/mR1lKnJL1WgM1Bns9ZF1ha6egG539ruzQjItF6MHB
                        xAEt55nXfs+mjV1p7qrcmR8jIdByR9C36T21r+8pKA==
                        -----END CERTIFICATE-----

                        """
            }
        };

        // 申请全新account 
        o.NewAccount(new string[] { "mailto:test11@xxx.com" });
        // 执行全套流程
        var cert = await initer.CreateCertificateAsync(o);
        return cert.ExportPem();
    }
}
</code></pre>
<p>默认情况下三种验证方式：</p>
<h4 id="http">http</h4>
<p>如在 asp.net core 中使用，默认已经添加了 <code>app.Map("/.well-known/acme-challenge"</code> 路由处理， 如要申请公网上权威认证的证书，请将 <code>/.well-known/acme-challenge</code> 路由暴露在公网让acme服务器可以访问</p>
<p>其次由于默认实现没有持久化和分布式处理验证信息，重启和多实例都会有问题，如有需求可以替换<code>IHttpChallengeResponseStore</code>实现以达到效果</p>
<pre><code class="language-csharp">public interface IHttpChallengeResponseStore
{
    Task AddChallengeResponseAsync(string token, string keyAuth, CancellationToken cancellationToken);

    Task&lt;string&gt; GetChallengeResponse(string token, CancellationToken cancellationToken);

    Task RemoveChallengeResponseAsync(string token, CancellationToken cancellationToken);
}
</code></pre>
<h4 id="dns">dns</h4>
<p>由于不同服务商有各自的api，所以默认没有实现，该功能其实无效，如需使用，请实现 <code>IDnsChallengeStore</code></p>
<pre><code class="language-csharp">public interface IDnsChallengeStore
{
    Task AddTxtRecordAsync(string acmeDomain, string dnsTxt, CancellationToken cancellationToken);

    Task RemoveTxtRecordAsync(string acmeDomain, string dnsTxt, CancellationToken cancellationToken);
}
</code></pre>
<h4 id="tls">tls</h4>
<p>个人并不推荐使用tls验证方式，其由于验证自签证书和正式证书都会在 tls 层，运行时不停机重新申请对于tls管理还是有些挑战的</p>
<p>如想尝试可以实现<code>ITlsAlpnChallengeStore</code> （默认在 asp.net core 的实现并不能支持过滤验证自签证书只用于acme服务器请求）</p>
<pre><code class="language-csharp">public interface ITlsAlpnChallengeStore
{
    Task AddChallengeAsync(string domainName, X509Certificate2 cert, CancellationToken cancellationToken);

    Task RemoveChallengeAsync(string domainName, X509Certificate2 cert, CancellationToken cancellationToken);
}
</code></pre>
<h3 id="底层-client">底层 client</h3>
<p>如需直接使用原始 acme 协议client，可参考如下</p>
<p>starup</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();

builder.Services.AddACME(c =&gt;
{
    c.HttpClientConfig = new VKProxy.Config.HttpClientConfig()
    {
        DangerousAcceptAnyServerCertificate = true
    };
});
</code></pre>
<p>use</p>
<pre><code class="language-csharp">var context = services.BuildServiceProvider().GetRequiredService&lt;IAcmeContext&gt;();

await context.InitAsync(new Uri("https://127.0.0.1:14000/dir"), cancellationToken);

var account = await context.NewAccountAsync(new string[] { "mailto:xxx@xxx.com" }, true, KeyAlgorithm.RS256.NewKey());

var order = await context.NewOrderAsync(new string[] { "test.com" });
var aus = order.GetAuthorizationsAsync().ToBlockingEnumerable().ToArray();
var a = aus.First();
var b = await a.HttpAsync();
var c = await b.ValidateAsync();

Key privateKey = KeyAlgorithm.RS256.NewKey();
var csrInfo = new CsrInfo
{
    CommonName = "test.com",
};
order = await context.FinalizeAsync(csr, key, cancellationToken);
var acmeCert = await order.DownloadAsync();

var pfxBuilder = acmeCert.ToPfx(privateKey);
if (!string.IsNullOrWhiteSpace(Args.AdditionalIssuer) &amp;&amp; File.Exists(Args.AdditionalIssuer))
{
    pfxBuilder.AddIssuer(File.ReadAllBytes(Args.AdditionalIssuer));
}
var pfx = pfxBuilder.Build("HTTPS Cert - " + Args.Domain, string.Empty);
var r = X509CertificateLoader.LoadPkcs12(pfx, string.Empty, X509KeyStorageFlags.Exportable);
</code></pre>
<h3 id="ui">ui</h3>
<p>在 VKProxy管理站点的 ui sni 里面添加了 简单的 http 验证方式的acme证书界面配置 如下图</p>
<p>（当然使用前提得是 暴露 xxx域名/.well-known/acme-challenge 接口到公网，这样公网acme 才能验证）</p>
<p><img alt="acme" loading="lazy" data-src="https://img2024.cnblogs.com/blog/818422/202507/818422-20250730151656030-564317182.jpg" class="lazyload"></p>
<h2 id="专职acme管理程序">专职ACME管理程序</h2>
<p>其实对更多人来说，ACME都是低频率使用，只是现在免费证书大多90天，所以才期望有个工具帮自己干活</p>
<p>现成的很多，比如</p>
<ul>
<li><a href="https://github.com/acmesh-official/acme.sh" target="_blank" rel="noopener nofollow">acme.sh</a> 脚本工具，稍显复杂</li>
<li><a href="https://github.com/certimate-go/certimate" target="_blank" rel="noopener nofollow">certimate</a> 目前只支持 dns 验证，不过dns服务商/通知/证书部署都支持非常全面</li>
</ul>
<p>所以珠玉在前，大家可以直接尽情使用</p>
<p>至于用c#再做一个，多半没有啥人关注，不信，和大家打个赌：评论留言说期望有个c#版的超过 30 条，就搞一个 （一条评论都没有，信不信，哈哈哈）</p>
<p><a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">VKProxy</a> 是使用c#开发的基于 Kestrel 实现 L4/L7的代理（感兴趣的同学烦请点个<a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">github</a>小赞赞呢）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-30 15:41">2025-07-30 15:41</span>&nbsp;
<a href="https://www.cnblogs.com/fs7744">victor.x.qu</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19013049);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19013049', targetLink: 'https://www.cnblogs.com/fs7744/p/19013049', title: 'c# ACME client (补充)' })">举报</a>
</div>
        