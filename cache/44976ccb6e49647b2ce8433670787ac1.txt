
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kuangdaoyizhimei/p/18933359" title="发布于 2025-06-17 17:45">
    <span role="heading" aria-level="2">SpringBoot集成TOTP双因素认证（2FA）实战</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        SpringBoot集成2FA双因素认证，使用GooleAuth+光年Admin模板实现
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一双因素认证的概念">一、双因素认证的概念</h2>
<p>双因素认证（2FA，Two Factor Authentication）又称双因子认证、两步验证，指的是是一种安全认证过程，需要用户提供两种不同类型的认证因子来表明自己的身份，包括密码、指纹、短信验证码、智能卡、生物识别等多种因素组合，从而提高用户账户的安全性和可靠性。</p>
<p>2FA认证流程如下：</p>
<ol>
<li>用户登录应用程序。</li>
<li>用户输入登录凭证，通常是账号和密码，做初始身份验证。</li>
<li>验证成功后，提示用户提交第二个身份验证因子。</li>
<li>用户将第二个身份验证因子输入至应用程序，如果第二个身份验证因子通过，用户将通过身份验证并被授予对应的系统操作权限。</li>
</ol>
<p>举个简单的例子，我们使用账号密码登录微博、豆瓣等应用时，命名账号密码都对了，但是还要输入手机验证码二次验证以确保安全性，这就是双因素验证。</p>
<p>虽然短信验证码实现简单，但是在实际场景中，一般会使用其它2FA方式替代：一则短信发送会产生费用，二则它也不是那么安全，它容易被拦截和伪造，SIM 卡也可以克隆。</p>
<p>一般来说，安全的双因素认证不是密码 + 短消息，而是密码+ <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" target="_blank" rel="noopener nofollow">TOTP</a>。</p>
<h2 id="二totp">二、TOTP</h2>
<p>TOTP 的全称是"基于时间的一次性密码"（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener nofollow">RFC6238</a>。</p>
<h3 id="1totp步骤">1、TOTP步骤</h3>
<p><strong>第一步</strong>，用户开启双因素认证后，服务器生成一个密钥。</p>
<p><strong>第二步</strong>：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174057115-1101424757.png" alt="image-20250617151407567" style="zoom: 50%">
<p>注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>
<p><strong>第三步</strong>，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174108234-1187141380.jpg" alt="微信图片_20250617151530" style="zoom: 25%">
<p><strong>第四步</strong>，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>
<h3 id="2totp原理">2、TOTP原理</h3>
<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>
<p>答案就是下面的公式。</p>
<pre><code class="language-bash">TC = floor((unixtime(now) − unixtime(T0)) / TS)
</code></pre>
<p>上面的公式中，TC 表示一个时间计数器，<code>unixtime(now)</code>是当前 Unix 时间戳，<code>unixtime(T0)</code>是约定的起始时间点的时间戳，默认是<code>0</code>，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>
<pre><code class="language-bash">TC = floor(unixtime(now) / 30)
</code></pre>
<p>所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>
<p>接下来，就可以算出哈希了。</p>
<pre><code class="language-bash">TOTP = HASH(SecretKey, TC)
</code></pre>
<p>上面代码中，<code>HASH</code>就是约定的哈希函数，默认是 SHA-1。</p>
<p>接下来在SpringBoot中集成TOTP实现双因素认证。</p>
<h2 id="三totp双因素认证实战">三、TOTP双因素认证实战</h2>
<h3 id="1开源项目googleauth">1、开源项目：GoogleAuth</h3>
<p>TOTP自己手写还是稍稍有些复杂，去网上找了开源项目，发现一个比较好的实现：<a href="https://github.com/wstrange/GoogleAuth" target="_blank" rel="noopener nofollow">GoogleAuth</a>，使用时需要引入Maven依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.warrenstrange&lt;/groupId&gt;
    &lt;artifactId&gt;googleauth&lt;/artifactId&gt;
    &lt;version&gt;1.5.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>为了生成图片二维码，还需要引入：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
    &lt;zxing.version&gt;3.4.0&lt;/zxing.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;core&lt;/artifactId&gt;
    &lt;version&gt;${zxing.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;javase&lt;/artifactId&gt;
    &lt;version&gt;${zxing.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>GoogleAuth的API比较简单，常见API如下：</p>
<h4 id="生成secret">生成secret</h4>
<pre><code class="language-java">/**
 * 测试获取秘钥
 */
@Test
public void testGetKey() {
    GoogleAuthenticator gAuth = new GoogleAuthenticator();
    final GoogleAuthenticatorKey key = gAuth.createCredentials();
    String key1 = key.getKey();
    log.info(key1);
}
</code></pre>
<h4 id="生成一次性验证码">生成一次性验证码</h4>
<pre><code class="language-java">/**
 * 测试生成一次性验证码
 */
@Test
public void testGetTotpPassword() {
    GoogleAuthenticator gAuth = new GoogleAuthenticator();
    int code = gAuth.getTotpPassword("PWTBUDW6OAPV6E2EVMBHX2X7LH6MXRNE");
    log.info("{}", code);
}
</code></pre>
<h4 id="验证码验证">验证码验证</h4>
<pre><code class="language-java">/**
 * 测试秘钥验证
 */
@Test
public void testAuthorize() {
    GoogleAuthenticatorConfig config = new GoogleAuthenticatorConfig
            .GoogleAuthenticatorConfigBuilder()
            //设置容忍度最小
            .setWindowSize(1)
            .build();
    GoogleAuthenticator gAuth = new GoogleAuthenticator(config);
    int verificationCode = 448247;
    String secretKey = "6VRFLPHNPQ4P2WAQWEIYPCQ43KIHVCJO";
    boolean isCodeValid = gAuth.authorize(secretKey, verificationCode);
    if (isCodeValid) {
        log.info("匹配");
    } else {
        log.info("不匹配");
    }
}
</code></pre>
<h4 id="获取二维码图片链接格式">获取二维码（图片链接格式）</h4>
<pre><code class="language-java">/**
 * 获取图片二维码
 */
@Test
public void testGetOtpAuthURL() {
    GoogleAuthenticator gAuth = new GoogleAuthenticator();
    final GoogleAuthenticatorKey key = gAuth.createCredentials();
    log.info(key.getKey());
    String otpAuthURL = GoogleAuthenticatorQRGenerator.getOtpAuthURL(
            ISSUER,
            userName,
            key
    );
    log.info(otpAuthURL);
}
</code></pre>
<h4 id="获取二维码字节流">获取二维码（字节流）</h4>
<pre><code class="language-java">@Test
public void testGetOtpAuthQrByteArrayOutputStream() throws WriterException, IOException {
    GoogleAuthenticator gAuth = new GoogleAuthenticator();
    final GoogleAuthenticatorKey key = gAuth.createCredentials();
    String otpAuthUri = GoogleAuthenticatorQRGenerator.getOtpAuthTotpURL(
            ISSUER,
            userName,
            key);

    QRCodeWriter qrWriter = new QRCodeWriter();
    BitMatrix bitMatrix = qrWriter.encode(otpAuthUri, BarcodeFormat.QR_CODE, 200, 200);
    BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    ImageIO.write(bufferedImage, "png", outputStream);
    ImageIO.write(bufferedImage, "png", new File("temp.png"));
}
</code></pre>
<h3 id="2开源项目光年admin模板">2、开源项目：光年Admin模板</h3>
<p>为了能更直观的展示TOTP功能集成到SpringBoot的样子，我决定基于开源项目 <a href="https://gitee.com/yinqi/Light-Year-Admin-Template-v5" target="_blank" rel="noopener nofollow">Light Year Admin v5</a> 去做前端的开发。<strong><a href="https://gitee.com/yinqi/Light-Year-Admin-Template-v5" target="_blank" rel="noopener nofollow">Light Year Admin v5</a></strong> 是一个管理端模板，基于Bootstrap 5.1.3。线上体验地址：<a href="http://lyear.itshubao.com/v5/" target="_blank" rel="noopener nofollow">http://lyear.itshubao.com/v5/</a> ，也可以下载下来以后使用<code>http-server</code>快速启动查看效果：</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174058771-379033843.jpg" alt="20250617160234" style="zoom: 80%">
<p>该项目是一个纯前端项目，为了更方便的集成到SpringBoot，我将其集成到了freemarker：</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174059490-1576841489.png" alt="image-20250617161339553" style="zoom: 50%">
<h3 id="3项目实战2fa-demo">3、项目实战：2fa-demo</h3>
<p>项目地址：<a href="https://gitee.com/kdyzm/2fa-demo" target="_blank" rel="noopener nofollow">https://gitee.com/kdyzm/2fa-demo</a></p>
<p>该项目依赖于MySQL，所以在运行前需要先准备好MySQL环境。</p>
<h4 id="运行前准备">运行前准备</h4>
<p>需要创建Mysql数据库，运行如下脚本：</p>
<pre><code class="language-sql">CREATE DATABASE `2fa_demo` ;
USE `2fa_demo`;

CREATE TABLE `sys_user` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户名',
  `nick_name` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户昵称',
  `password` varchar(64) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户密码',
  `two_fa_secret` varchar(64) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '两步验证的秘钥',
  `tow_fa_enabled` tinyint(1) DEFAULT '0' COMMENT '是否启用两步验证',
  `create_by` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'sys' COMMENT '创建人',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_by` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `del_flag` tinyint(1) NOT NULL DEFAULT '0' COMMENT '删除标志，0：未删除；1：已删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='用户表';

insert  into `sys_user`(`id`,`user_name`,`nick_name`,`password`,`two_fa_secret`,`tow_fa_enabled`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values 
(1,'kdyzm','狂盗一枝梅','123456','H5C7U7M3FJN6DGL6EAAWHF6TVAAINAGU',0,'kdyzm','2025-06-16 13:51:03',NULL,'2025-06-17 13:37:13',0);

CREATE TABLE `sys_user_2fa` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint DEFAULT NULL COMMENT '用户id',
  `secret_key` varchar(64) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '秘钥',
  `scratch_codes` varchar(128) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '静态验证码',
  `create_by` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_by` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `del_flag` tinyint(1) NOT NULL DEFAULT '0' COMMENT '删除标志，0：未删除；1：已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_id` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='两步验证相关临时配置表';
</code></pre>
<p>之后修改配置文件中的Mysql配置信息：</p>
<pre><code class="language-yaml">JDBC_MYSQL_HOST: localhost
JDBC_MYSQL_PORT: 3306
JDBC_MYSQL_DATABASE: 2fa_demo
JDBC_MYSQL_USERNAME: root
JDBC_MYSQL_PASSWORD: '123456'
</code></pre>
<h4 id="项目启动">项目启动</h4>
<p>将项目导入Intelij，运行Application，出现如下即可表示运行成功</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174100599-360932434.png" alt="image-20250617165811258" style="zoom: 50%">
<p>打开链接，进入登录页面</p>
<h4 id="账号密码登录">账号密码登录</h4>
<p>在未登录的情况下打开链接http://localhost:8024，就会进入登录页面</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174101782-336888879.jpg" alt="20250617170158" style="zoom: 80%">
<blockquote>
<p>登录账号：kdyzm</p>
<p>登录密码：123456</p>
</blockquote>
<p>登录成功之后进入首页。</p>
<h4 id="开启两步验证">开启两步验证</h4>
<p>登录成功之后进入首页，点击首页右上角两步验证</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174102925-1852501402.jpg" alt="20250617170554" style="zoom: 80%">
<p>进入两步验证页面，由于未设置过二次验证，所以会提示去设置</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174104053-2042027494.png" alt="20250617170716" style="zoom: 80%">
<p>点击“开启二次验证”按钮，进入两步骤验证向导</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174104993-504733957.jpg" alt="20250617170906" style="zoom: 80%">
<p>点击下一步输入电子邮件</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174106181-1348187308.jpg" alt="20250617171200" style="zoom: 80%">
<p>点击下一步，进入关键的验证器配置步骤</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174107218-903956252.jpg" alt="20250617171311" style="zoom: 80%">
<p>在这一步，IOS下可以安装<code>Authenticator</code>或者微信小程序搜索“<code>MFA</code>”，使用“<code>腾讯身份验证器</code>”扫描二维码完成验证器设置，注意，<strong>如果多次扫描相同的二维码，需要删除上次扫描的记录</strong>。</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174108234-1187141380.jpg" alt="微信图片_20250617151530" style="zoom: 25%">
<p>点击下一步，校验配置的正确性：</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174109175-1747069979.jpg" alt="20250617172222" style="zoom: 80%">
<p>提示配置开启成功即表示已配置成功。</p>
<h4 id="验证两步验证">验证两步验证</h4>
<p>退出登录，回到登录页，输入账号密码登录，登录成功后不再跳转到首页，而是跳转到二次验证页面：</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174110230-47488201.jpg" alt="20250617172603" style="zoom: 80%">
<p>从手机上获取动态验证码，即可成功登录系统。</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174111377-711828071.jpg" alt="20250617172715" style="zoom: 80%">
<h4 id="关闭两步验证">关闭两步验证</h4>
<p>进入首页后，再次进入两步验证页面，即可看到关闭按钮</p>
<img src="https://img2024.cnblogs.com/blog/516671/202506/516671-20250617174112391-1600154316.png" alt="20250617172910" style="zoom: 80%">
<p>关闭后再次登录系统，就不会进入两步验证页面了。</p>
<h3 id="4实战总结">4、实战总结</h3>
<p>由于本项目案例只关注2FA相关的内容，我在光年Admin模板的静态模板只实现了登录以及2FA相关的功能，而且时间匆忙代码比较糙。。。</p>
<p>该项目还剩下一些问题没实现</p>
<ol>
<li>二次验证的记住设备功能</li>
<li>8位数的静态码未实现校验功能</li>
<li>设备丢失静态码找回功能未实现</li>
</ol>
<p>以后有时间再补充了。</p>
<br>
<p>最后，欢迎关注我的博客呀：<a href="https://blog.kdyzm.cn" title="一枝梅的博客" target="_blank" rel="noopener nofollow">一枝梅的博客</a></p>
<br>
<br>
<p>END.</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2222222222222222" data-date-updated="2025-06-17 23:05">2025-06-17 17:45</span>&nbsp;
<a href="https://www.cnblogs.com/kuangdaoyizhimei">狂盗一枝梅</a>&nbsp;
阅读(<span id="post_view_count">227</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18933359);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18933359', targetLink: 'https://www.cnblogs.com/kuangdaoyizhimei/p/18933359', title: 'SpringBoot集成TOTP双因素认证（2FA）实战' })">举报</a>
</div>
        