
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18695795" title="发布于 2025-01-31 23:17">
    <span role="heading" aria-level="2">【编码】自定义通信协议——实现零拷贝文件传输</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>前言</h3>
<p>上一篇随笔，介绍了如何扩展自定义协议的请求类型。本篇随笔我将介绍如何基于这个自定义协议来实现文件传输，其中将涉及<code>数据分片</code>和<code>零拷贝</code></p>
<p>在设计自定义协议之前，我们首先了解一下HTTP协议是如何处理文件传输的。</p>
<h3>HTTP协议的实现方式</h3>
<p>在这里，我们主要讨论应用最广泛的HTTP/1.1协议</p>
<p><strong>关于数据分片</strong></p>
<p>HTTP 协议本身是一个纯文本协议，其中的 <code>Content-Length</code> 头部字段用于指定响应体（body）的内容长度。<code>Content-Length</code> 是纯文本格式，理论上没有长度限制，因此在大多数情况下，HTTP 协议可以一次性传输整个文件。</p>
<p>对于较大的文件，通常情况下，可以通过一个请求下载整个文件，这也是许多网站和服务的常见做法。但如果文件特别大，或者为了提高下载效率（例如支持断点续传、并行下载等），就需要在应用层处理文件的分片。例如，服务端可以先返回文件的分段信息，然后客户端逐个请求文件的不同部分。</p>
<p><strong>关于零拷贝</strong></p>
<p>HTTP 协议的客户端库通常不暴露底层的 socket 连接，导致上层应用无法直接操作 socket 进行零拷贝传输。</p>
<p>大多数情况下，数据需要先被拷贝到进程的内存中，再传输给 HTTP 客户端。</p>
<p>由于 HTTP 客户端库的限制，零拷贝技术在 HTTP 协议的应用中并不直接适用。</p>
<h3>自定义协议</h3>
<p><strong>关于数据分片</strong></p>
<p>在自定义协议中，我们可以更灵活地控制传输过程。例如，我们只使用 3 个字节来表示消息体的长度，因此协议的最大传输内容为 16MB（2^24 - 1 字节）。</p>
<p>对于超出该限制的内容，我们必须进行分块处理，确保每个数据块都符合协议的长度限制。</p>
<p><strong>关于零拷贝</strong></p>
<p>自定义协议可以引用到Socket，所以可以使用零拷贝，避免数据在内存和磁盘之间的多次拷贝，从而提高传输效率，减少 CPU 的负载。</p>
<h3>初步设计</h3>
<p><strong>如何构建数据包？</strong></p>
<p><strong><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250131222305738-1311785086.png" alt="" width="555" height="277" loading="lazy"></strong></p>
<p>消息体是一个完整的ProtoBuf BaseResponse消息</p>
<ul>
<li>msgId：请求ID</li>
<li>headers：文件名+文件大小+分块数量+分块号</li>
<li>bytes：文件分块数据</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">message BaseResponse {
    required int32 msgId </span>= 1<span style="color: rgba(0, 0, 0, 1)">;
    repeated Header headers </span>= 2<span style="color: rgba(0, 0, 0, 1)">;
    optional bytes data </span>= 3<span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>消息体分两部分发送</p>
<p>1.先发送元数据（BaseResponse的msgId+headers)</p>
<p>2.后发送文件数据</p>
<p><strong>服务端：</strong></p>
<p>1.截取文件范围得到chunkSize</p>
<p>2.构建BaseResponse（仅包含msgId和headers）</p>
<p>3.计算得到消息体Length = BaseResponse的大小+chunkSize</p>
<p>4.发出消息头</p>
<p>5.发出BaseResponse</p>
<p>6.零拷贝发出文件chunk</p>
<p><strong>客户端：</strong></p>
<p>1.将消息体作为一个完整的BaseResponse进行解析。</p>
<h3>冲突？ProtoBuf与零拷贝</h3>
<p>在处理过程中，我们会遇到一个问题：<strong>ProtoBuf</strong> 的解析过程需要特定的编码格式，拼接进去的文件内容无法直接作为 <code>ProtoBuf</code> 消息的一部分。</p>
<p>如果需要ProtoBuf能识别这个文件内容，则文件数据必须参与编码，要参与编码就得载入到进程内存中。这跟零拷贝是相悖的。</p>
<p><strong>如何处理这个问题？</strong></p>
<p>再加一个length！消息体分为三部分：</p>
<ul>
<li>2字节，作为proto消息的长度信息。（元数据字节数有限，2字节足够表示）</li>
<li>n字节，proto消息（msgId+headers）</li>
<li>n字节，文件chunk数据</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250131222742504-1902773894.png" alt="" width="563" height="251" loading="lazy"></p>
<h3>处理逻辑</h3>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250131225604031-1367716975.png" alt="" width="712" height="548" loading="lazy"></p>
<p><strong>1）服务端代码</strong><br>Java的零拷贝API是FileChannel.transferTo(long position, long count, WritableByteChannel)。<br>不过Netty的Channel不是WritableByteChannel的子类。要使用零拷贝，得用Netty提供的FileRegion。底层也是调用FileChannel的transferTo。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> handleDownloadRequest(BaseRequest baseRequest, ChannelHandlerContext ctx) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        File file </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> File("F:\\redis.log"<span style="color: rgba(0, 0, 0, 1)">);
        RandomAccessFile raf </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> RandomAccessFile(file, "r"<span style="color: rgba(0, 0, 0, 1)">);
        FileChannel fileChannel </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 0, 255, 1)">long</span> fileLength =<span style="color: rgba(0, 0, 0, 1)"> raf.length();
        System.out.println(</span>"file length" +<span style="color: rgba(0, 0, 0, 1)"> fileLength);
        </span><span style="color: rgba(0, 0, 255, 1)">long</span> offset = 0<span style="color: rgba(0, 0, 0, 1)">;


        </span><span style="color: rgba(0, 0, 255, 1)">int</span> chunkIndex = 0<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> totalChunks = (<span style="color: rgba(0, 0, 255, 1)">int</span>) Math.ceil((<span style="color: rgba(0, 0, 255, 1)">double</span>) fileLength /<span style="color: rgba(0, 0, 0, 1)"> MAX_CHUNK_SIZE);
        </span><span style="color: rgba(0, 0, 255, 1)">boolean</span> firstPackage = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 0, 255, 1)">while</span>(offset &lt;<span style="color: rgba(0, 0, 0, 1)"> fileLength) {
            raf </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> RandomAccessFile(file, "r"<span style="color: rgba(0, 0, 0, 1)">);
            fileChannel </span>=<span style="color: rgba(0, 0, 0, 1)"> raf.getChannel();
            System.out.println(</span>"open:"+<span style="color: rgba(0, 0, 0, 1)">fileChannel.isOpen());
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">文件块大小</span>
            <span style="color: rgba(0, 0, 255, 1)">long</span> chunkSize = Math.min(MAX_CHUNK_SIZE, fileLength -<span style="color: rgba(0, 0, 0, 1)"> offset);
            System.out.println(</span>"chunkSize:"+<span style="color: rgba(0, 0, 0, 1)">chunkSize);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建 FileRegion 来传输当前文件块</span>
            FileRegion fileRegion = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DefaultFileRegion(fileChannel, offset, chunkSize);


            List</span>&lt;Header&gt; headers = <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayList&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(firstPackage) {
                headers.add(Header.newBuilder().setKey(</span>"fileName"<span style="color: rgba(0, 0, 0, 1)">).setValue(file.getName()).build());
                headers.add(Header.newBuilder().setKey(</span>"fileSize"<span style="color: rgba(0, 0, 0, 1)">).setValue(String.valueOf(fileLength)).build());
                headers.add(Header.newBuilder().setKey(</span>"totalChunks"<span style="color: rgba(0, 0, 0, 1)">).setValue(String.valueOf(totalChunks)).build());
            }
            headers.add(Header.newBuilder().setKey(</span>"chunkIndex"<span style="color: rgba(0, 0, 0, 1)">).setValue(String.valueOf(chunkIndex)).build());

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发送消息体的上半部分（msgId+headers）</span>
            BaseResponse response =<span style="color: rgba(0, 0, 0, 1)"> BaseResponse.newBuilder()
                    .setMsgId(baseRequest.getMsgId())
                    .addAllHeaders(headers)
                    .build();
            </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] payloadHeadBytes =<span style="color: rgba(0, 0, 0, 1)"> response.toByteArray();
            </span><span style="color: rgba(0, 0, 255, 1)">long</span> bodyLength = 2 + payloadHeadBytes.length + chunkSize; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">两个字节</span>

            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] lengthBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[3<span style="color: rgba(0, 0, 0, 1)">];
            lengthBytes[</span>0] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (bodyLength &gt;&gt; 16<span style="color: rgba(0, 0, 0, 1)">);
            lengthBytes[</span>1] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (bodyLength &gt;&gt; 8<span style="color: rgba(0, 0, 0, 1)">);
            lengthBytes[</span>2] = (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">) bodyLength;

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">protobuf长度</span>
            <span style="color: rgba(0, 0, 255, 1)">long</span> length2 =<span style="color: rgba(0, 0, 0, 1)"> payloadHeadBytes.length;
            </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] lengthBytes2 = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[2<span style="color: rgba(0, 0, 0, 1)">];
            lengthBytes2[</span>0] = (<span style="color: rgba(0, 0, 255, 1)">byte</span>) (length2 &gt;&gt; 8<span style="color: rgba(0, 0, 0, 1)">);
            lengthBytes2[</span>1] = (<span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">) (length2);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发送消息头+消息体的上半部分</span>
            ByteBuf byteBuf = Unpooled.copiedBuffer(<span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[]{5<span style="color: rgba(0, 0, 0, 1)">}, lengthBytes, lengthBytes2, payloadHeadBytes);
            ChannelFuture f1 </span>=<span style="color: rgba(0, 0, 0, 1)"> ctx.channel().writeAndFlush(byteBuf);
            f1.sync();
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">            System.out.println("f1:"+f1.isSuccess());
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">零拷贝写出文件数据（文件内容无需进入用户区内存，直接拷贝到socket发送缓冲区）</span>
            ChannelFuture f2 =<span style="color: rgba(0, 0, 0, 1)"> ctx.writeAndFlush(fileRegion);
            f2.sync();
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">            System.out.println("f2:"+f2.isSuccess());</span>
<span style="color: rgba(0, 0, 0, 1)">
            firstPackage </span>= <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 更新偏移量</span>
            offset +=<span style="color: rgba(0, 0, 0, 1)"> chunkSize;
            System.out.println(</span>"写出："+<span style="color: rgba(0, 0, 0, 1)">bodyLength);

            raf.close();
        }

    }</span></pre>
</div>
<p><strong>2）客户端代码</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> DownloadManager {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> Map&lt;Integer, FileDownContext&gt; waitingMap = <span style="color: rgba(0, 0, 255, 1)">new</span> ConcurrentHashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> addToMap(Integer msgId, CompletableFuture&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)"> waiter) {
        waitingMap.put(msgId, </span><span style="color: rgba(0, 0, 255, 1)">new</span> FileDownContext(<span style="color: rgba(0, 0, 255, 1)">null</span>, <span style="color: rgba(0, 0, 255, 1)">null</span>, 0L, 0.0d<span style="color: rgba(0, 0, 0, 1)">, waiter));
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onResponse(BaseResponse response) {
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">        System.out.println("收到："+response.getMsgId());</span>
        Integer msgId =<span style="color: rgba(0, 0, 0, 1)"> response.getMsgId();
        FileDownContext context </span>=<span style="color: rgba(0, 0, 0, 1)"> waitingMap.get(msgId);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.isNull(context)) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">首包带有这两个信息</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (Header header : response.getHeadersList()) {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(StrUtil.equals(header.getKey(), "fileName"<span style="color: rgba(0, 0, 0, 1)">)) {
                context.setFileName(header.getValue());
            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(StrUtil.equals(header.getKey(), "totalChunks"<span style="color: rgba(0, 0, 0, 1)">)) {
                context.setTotalChunks(Long.parseLong(header.getValue()));
            }
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">更新接收情况</span>
        context.receivedChunks++<span style="color: rgba(0, 0, 0, 1)">;
        context.progress </span>= (<span style="color: rgba(0, 0, 255, 1)">double</span>)context.receivedChunks/<span style="color: rgba(0, 0, 0, 1)">context.totalChunks;

        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">文件如果不存在，则创建</span>
            Path filePath = Paths.get("F:\\clientDownload\\" +<span style="color: rgba(0, 0, 0, 1)"> context.fileName);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(!<span style="color: rgba(0, 0, 0, 1)">Files.exists(filePath)) {
                Files.createFile(filePath);
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">追加写入文件</span>
<span style="color: rgba(0, 0, 0, 1)">            Files.write(filePath, response.getData().toByteArray(), StandardOpenOption.APPEND);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (IOException e) {
            e.printStackTrace();
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">完成请求，释放Context</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.equals(context.receivedChunks, context.totalChunks)) {
            context.waiter.complete(context.fileName);
            waitingMap.remove(msgId);
        }
    }

    @Data
    @AllArgsConstructor
    </span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> FileDownContext {
        String fileName;
        Long totalChunks;
        Long receivedChunks;
        Double progress;
        CompletableFuture</span>&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)"> waiter;
    }
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9642268143391204" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-31 23:17">2025-01-31 23:17</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">59</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18695795" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18695795);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18695795', targetLink: 'https://www.cnblogs.com/longfurcat/p/18695795', title: '【编码】自定义通信协议——实现零拷贝文件传输' })">举报</a>
</div>
        