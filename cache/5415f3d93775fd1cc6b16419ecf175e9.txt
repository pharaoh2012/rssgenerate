
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/BNTang/p/18972942" title="发布于 2025-07-08 14:14">
    <span role="heading" aria-level="2">精控Spring AI日志</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>还在为 Spring AI 默认的日志抓狂吗？想看日志却看不到，一开 DEBUG 就刷屏... 别慌！</p>
<p>今天 NEO 带你解锁一个神级操作：<strong>自定义 Advisor</strong>，让你轻松掌控 AI 调用的每一个细节！</p>
<h2 id="advisor-是什么spring-ai-的拦截器">Advisor 是什么？Spring AI 的“拦截器”</h2>
<p>如果你玩过 Servlet 的 Filter 或者 Spring AOP 的切面，那 Advisor 对你来说就是老朋友了。</p>
<p>简单来说，Spring AI 的 Advisor 就是一个<strong>调用拦截器</strong>。它能在你的代码调用大模型<strong>之前</strong>和<strong>之后</strong>“插一脚”，执行一些额外的操作。</p>
<p>想在调用前做个权限校验？或者在调用后记个详细日志？用 Advisor 就对了！</p>
<p>官方虽然提供了一些现成的 Advisor，但实际业务场景千变万化，总有不满足需求的时候。这时候，我们就需要自己动手，丰衣足食！</p>
<h2 id="四步搞定定制你的专属-advisor">四步搞定！定制你的专属 Advisor</h2>
<p>想拥有自己的 Advisor？跟着下面四步走，轻松搞定！</p>
<p>1）<strong>选择“岗哨”接口</strong></p>
<p>根据你的需求，选择实现一个或两个接口：</p>
<ul>
<li><code>CallAroundAdvisor</code>：处理普通的同步请求（非流式）。</li>
<li><code>StreamAroundAdvisor</code>：处理酷炫的流式请求。</li>
</ul>
<blockquote>
<p>强烈建议两个都实现，全方位无死角！</p>
</blockquote>
<pre><code class="language-java">public class MyCustomAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
    // 实现方法...
}
</code></pre>
<p>2）<strong>实现核心“拦截”方法</strong></p>
<p>这是 Advisor 的灵魂所在，你可以在这里对请求和响应为所欲为。</p>
<ul>
<li><strong>非流式处理 (<code>aroundCall</code>)</strong> ：</li>
</ul>
<pre><code class="language-java">@Override
public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
    // 1. 请求到达，先处理一下（前置处理）
    AdvisedRequest modifiedRequest = processRequest(advisedRequest);
    
    // 2. 放行，让请求继续前进
    AdvisedResponse response = chain.nextAroundCall(modifiedRequest);
    
    // 3. 响应返回，再处理一下（后置处理）
    return processResponse(response);
}
</code></pre>
<ul>
<li><strong>流式处理 (<code>aroundStream</code>)</strong> ：</li>
</ul>
<pre><code class="language-java">@Override
public Flux&lt;AdvisedResponse&gt; aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
    // 1. 处理请求
    AdvisedRequest modifiedRequest = processRequest(advisedRequest);
    
    // 2. 调用链并处理流式响应
    return chain.nextAroundStream(modifiedRequest)
               .map(response -&gt; processResponse(response)); // 对流中每个元素进行处理
}
</code></pre>
<p>3）<strong>排个队，定个序</strong></p>
<p>通过 <code>getOrder()</code> 方法告诉 Spring AI 你的 Advisor 应该在什么时候执行。<strong>数字越小，优先级越高</strong>，越先被执行。</p>
<pre><code class="language-java">@Override
public int getOrder() {
    // 值越小优先级越高，越先执行
    return 100; 
}
</code></pre>
<p>4）<strong>取个独一无二的名字</strong></p>
<p>给你的 Advisor 一个响亮的名号！</p>
<pre><code class="language-java">@Override
public String getName() {
    return "NEO自定义的 Advisor";
}
</code></pre>
<p>下面，进入实战环节！</p>
<h2 id="实战告别-debug打造-info-级日志神器">实战：告别 DEBUG！打造 INFO 级日志神器</h2>
<p>Spring AI 自带的 <code>SimpleLoggerAdvisor</code> 日志拦截器，看似贴心，实则有点“坑”——它用的是 <strong>Debug</strong> 级别输出日志。</p>
<p>而 Spring Boot 项目默认的日志级别是 <strong>Info</strong>，导致我们根本看不到任何日志输出！</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202507/2105804-20250708124118920-376229169.png" alt="" loading="lazy"></p>
<p><strong>（默认 Info 级别，看不到任何日志）</strong></p>
<p>当然，你可以粗暴地修改配置文件，把日志级别调成 Debug：</p>
<pre><code class="language-yaml">logging:
  level:
    org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor: debug
</code></pre>
<p>日志是出来了，但又带来了新的问题：信息太杂乱！</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202507/2105804-20250708125508881-931558329.png" alt="" loading="lazy"></p>
<p><strong>（Debug 级别日志，信息过于繁杂）</strong></p>
<p>为了更优雅地解决问题，我们来自己实现一个日志 Advisor：<strong>默认打印 Info 级别日志，并且只输出我们最关心的用户提问和 AI 回复</strong>。</p>
<p>在自己项目根包下新建 <code>advisor</code> 包，编写我们的日志神器 <code>MyLoggerAdvisor</code>：</p>
<pre><code class="language-java">/**
 * 自定义日志 Advisor 打印 info 级别日志、只输出单次用户提示词和 AI 回复的文本
 **/
@Slf4j
public class MyLoggerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {

    /**
     * 获取 Advisor 的唯一名称
     */
    @NotNull
    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    /**
     * 设置执行顺序，0 表示较高优先级
     */
    @Override
    public int getOrder() {
        return 0;
    }

    /**
     * 调用前置处理：记录用户请求
     */
    private AdvisedRequest before(AdvisedRequest request) {
        log.info("AI Request: {}", request.userText());
        return request;
    }

    /**
     * 调用后置处理：记录 AI 响应
     */
    private void observeAfter(AdvisedResponse advisedResponse) {
        log.info("AI Response: {}", advisedResponse.response().getResult().getOutput().getContent());
    }

    /**
     * 环绕处理（非流式）
     */
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        // 1. 调用前
        advisedRequest = this.before(advisedRequest);

        // 2. 放行
        AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequest);

        // 3. 调用后
        this.observeAfter(advisedResponse);

        return advisedResponse;
    }

    /**
     * 环绕处理（流式）
     */
    public Flux&lt;AdvisedResponse&gt; aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        // 1. 调用前
        advisedRequest = this.before(advisedRequest);

        // 2. 放行
        Flux&lt;AdvisedResponse&gt; advisedResponses = chain.nextAroundStream(advisedRequest);

        // 3. 调用后，使用 MessageAggregator 聚合流式响应，然后统一记录
        return (new MessageAggregator())
                .aggregateAdvisedResponse(
                        advisedResponses,
                        this::observeAfter
                );
    }
}
</code></pre>
<blockquote>
<p><strong>代码小贴士</strong>：在流式处理 <code>aroundStream</code> 中，我们用 <code>MessageAggregator</code> 工具类将零散的 <code>Flux</code> 响应聚合成一个完整的响应，这样就能在日志中打印出最终的、完整的 AI 回复，而不是一堆零散的数据块。</p>
</blockquote>
<p>最后，在 <code>App</code> 中“装备”上我们刚出炉的日志神器：</p>
<pre><code class="language-java">public App(ChatModel ollamaChatModel) {
    // 初始化基于内存的对话记忆
    ChatMemory chatMemory = new InMemoryChatMemory();
    chatClient = ChatClient.builder(ollamaChatModel)
            .defaultSystem(SYSTEM_PROMPT)
            .defaultAdvisors(
                    new MessageChatMemoryAdvisor(chatMemory),
                    // 替换掉官方的 SimpleLoggerAdvisor
                    // new SimpleLoggerAdvisor()
                    // 使用我们自定义的日志 Advisor
                    new MyLoggerAdvisor()
            )
            .build();
}
</code></pre>
<p>现在再运行程序，看看效果如何？</p>
<p><img src="https://img2024.cnblogs.com/blog/2105804/202507/2105804-20250708125338871-1904187510.png" alt="" loading="lazy"></p>
<p><strong>（效果拔群！清爽的 Info 级别日志）</strong></p>
<p>看！日志变得如此清爽，只留下了我们最需要的信息。</p>
<p>通过自定义 Advisor，我们不仅解决了日志记录的痛点，更解锁了 Spring AI 的一个强大扩展点。无论是鉴权、计费、还是更复杂的业务逻辑，都可以通过 Advisor 优雅地实现，让你的 AI 应用更加健壮和灵活。</p>
<p>你还有哪些使用 Advisor 的奇思妙想？欢迎在评论区留言讨论！</p>
<p>如果觉得这篇文章对你有帮助，别忘了<strong>点赞</strong>、<strong>在看</strong>、<strong>分享</strong>三连哦！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-08 14:14">2025-07-08 14:14</span>&nbsp;
<a href="https://www.cnblogs.com/BNTang">BNTang</a>&nbsp;
阅读(<span id="post_view_count">173</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18972942);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18972942', targetLink: 'https://www.cnblogs.com/BNTang/p/18972942', title: '精控Spring AI日志' })">举报</a>
</div>
        