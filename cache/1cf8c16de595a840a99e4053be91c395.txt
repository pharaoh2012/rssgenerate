
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hugogoos/p/18713781" title="发布于 2025-02-13 15:54">
    <span role="heading" aria-level="2">并发编程 - 线程同步（七）之互斥锁Monitor</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        学习C#互斥锁Monitor，注意避免锁定值类型和try/finally错误，善用TryEnter避免长时间持锁，以及使用Wait、Pulse等方法实现生产者-消费者模式。示例代码和测试方法在代码库。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>通过前面对锁lock的基本使用以及注意事项的学习，相信大家对锁的同步机制有了大致了解，今天我们将继续学习——互斥锁Monitor。</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154232957-1510575971.jpg" alt="" loading="lazy"></p>
<p>lock是C#语言中的关键字，是语法糖，lock语句最终会由C#编译器解析成Monitor类实现相关语句。</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154226616-1660435397.png" alt="" loading="lazy"></p>
<p>例如以下lock语句：</p>
<pre><code class="language-csharp">lock (obj)
{
    //同步代码块
}
</code></pre>
<p>最终会被解析成以下代码：</p>
<pre><code class="language-csharp">Monitor.Enter(obj);
try
{
    //同步代码块
}
finally
{
    Monitor.Exit(obj);
}
</code></pre>
<p>lock关键字简洁且易于使用，而Monitor类 则功能强大，能够提供比lock关键字更细粒度、更灵活的控制以及更多的功能。</p>
<p>因为lock关键字是Monitor类的语法糖，因此lock关键字面临的问题，Monitor类同样也会面临。当然也会存在一些Monitor类特有的问题。</p>
<p>下面我们一起详细学习Monitor类的注意事项以及实现一个简单的生产者-消费者模式示例代码。</p>
<h1 id="01避免锁定值类型"><em><strong>01</strong></em>、避免锁定值类型</h1>
<p>这是因为 Monitor.Enter方法的参数为Object类型，这就导致如果传递值类型会导致值类型被装箱，进而导致线程在已装箱的对象上获取锁，最终线程每次调用Monitor.Enter方法都在一个完全不同的对象上获取锁，导致锁失效，无法实现线程同步。</p>
<p>看看下面这个代码示例：</p>
<pre><code class="language-csharp">public class LockValueTypeExample
{
    private static readonly int _lock = 88;
    public void Method1()
    {
        try
        {
            Monitor.Enter(_lock);
            var threadId = Thread.CurrentThread.ManagedThreadId;
            Console.WriteLine($"线程 {threadId} 通过 lock(值类型) 锁进入 Method1");
            Console.WriteLine($"进入时间 {DateTime.Now:HH:mm:ss}");
            Console.WriteLine($"开始休眠 5 秒");
            Console.WriteLine($"------------------------------------");
            Thread.Sleep(5000);
        }
        finally
        {
            Console.WriteLine($"开始释放锁 {DateTime.Now:HH:mm:ss}");
            Monitor.Exit(_lock);
            Console.WriteLine($"完成锁释放 {DateTime.Now:HH:mm:ss}");
        }
    }
}
public static void LockValueTypeRun()
{
    var example = new LockValueTypeExample();
    var thread1 = new Thread(example.Method1);
    thread1.Start();
}
</code></pre>
<p>看看执行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154216419-1893140828.png" alt="" loading="lazy"></p>
<p>可以发现在释放锁的时候抛出异常，大致意思是：“对象同步方法在未同步的代码块中被调用。”，这就是因为锁定的地方和释放的地方锁已经不一样了。</p>
<h1 id="02小心tryfinally"><em><strong>02</strong></em>、小心try/finally</h1>
<p>如上面的例子，Monitor.Enter方法是写在try块中，试想一下：如果在Monitor.Enter方法之前抛出了异常会怎样异常？看下面这段代码：</p>
<pre><code class="language-csharp">public class LockBeforeExceptionExample
{
    private static readonly object _lock = new object();
    public void Method1()
    {
        try
        {
            if (new Random().Next(2) == 1)
            {
                Console.WriteLine($"在调用Monitor.Enter前发生异常");
                throw new Exception("在调用Monitor.Enter前发生异常");
            }
            Monitor.Enter(_lock);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"捕捉到异常：{ex.Message}");
        }
        finally
        {
            Console.WriteLine($"开始释放锁 {DateTime.Now:HH:mm:ss}");
            Monitor.Exit(_lock);
            Console.WriteLine($"完成锁释放 {DateTime.Now:HH:mm:ss}");
        }
    }
}
public static void LockBeforeExceptionRun()
{
    var example = new LockBeforeExceptionExample();
    var thread1 = new Thread(example.Method1);
    thread1.Start();
}
</code></pre>
<p>上面代码是在调用Monitor.Enter方法前随机抛出异常，当发生异常后，可以在释放锁的时候和锁定值类型报了同样的错误，执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154207727-11256589.png" alt="" loading="lazy"></p>
<p>这是因为还没有执行锁定就抛出异常，导致释放一个没有锁定的锁。</p>
<p>那要如何解决这个问题呢？Monitor类已经考虑到了这种情况，并给出了解决办法——使用Monitor.Enter的第二个参数lockTaken，当获取锁定成功则更改lockTaken为true。如此在finally的时候只需要判断lockTaken即可决定是否需要执行释放锁操作，具体代码如下：</p>
<pre><code class="language-csharp">public class LockSolveBeforeExceptionExample
{
    private static readonly object _lock = new object();
    public void Method1()
    {
        var lockTaken = false;
        try
        {
            if (new Random().Next(2) == 1)
            {
                Console.WriteLine($"在调用Monitor.Enter前发生异常");
                throw new Exception("在调用Monitor.Enter前发生异常");
            }
            Monitor.Enter(_lock,ref lockTaken);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"捕捉到异常：{ex.Message}");
        }
        finally
        {
            if (lockTaken)
            {
                Console.WriteLine($"开始释放锁 {DateTime.Now:HH:mm:ss}");
                Monitor.Exit(_lock);
                Console.WriteLine($"完成锁释放 {DateTime.Now:HH:mm:ss}");
            }
            else
            {
                Console.WriteLine($"未执行锁定，无需释放锁");
            }
        }
    }
}
public static void LockSolveBeforeExceptionRun()
{
    var example = new LockSolveBeforeExceptionExample();
    var thread1 = new Thread(example.Method1);
    thread1.Start();
}
</code></pre>
<p>执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154158058-1274143900.png" alt="" loading="lazy"></p>
<h1 id="03善用tryenter"><em><strong>03</strong></em>、善用TryEnter</h1>
<p>我们知道使用锁应当避免长时间持有锁，长时间持有锁会阻塞其他线程，影响性能。我们可以通过Monitor.TryEnter指定超时时间，可以看看下面示例代码：</p>
<pre><code class="language-csharp">public class LockTryEnterExample
{
    private static readonly object _lock = new object();
    public void Method1()
    {
        try
        {
            Monitor.Enter(_lock);
            Console.WriteLine($"Method1 | 获取锁成功，并锁定 5 秒");
            Thread.Sleep(5000);
        }
        finally
        {
            Monitor.Exit(_lock);
        }
    }
    public void Method2()
    {
        Console.WriteLine($"Method2 | 尝试获取锁");
        if (Monitor.TryEnter(_lock, 3000))
        {
            try
            {
            }
            finally
            {
            }
        }
        else
        {
            Console.WriteLine($"Method2 | 3 秒内未获取到锁，自动退出锁");
        }
    }
    public void Method3()
    {
        Console.WriteLine($"Method3 | 尝试获取锁");
        if (Monitor.TryEnter(_lock, 7000))
        {
            try
            {
                Console.WriteLine($"Method3 | 7 秒内获取到锁");
            }
            finally
            {
                Console.WriteLine($"Method3 |开始释放锁");
                Monitor.Exit(_lock);
                Console.WriteLine($"Method3 |完成锁释放");
            }
        }
        else
        {
            Console.WriteLine($"Method3 | 7 秒内未获取到锁，自动退出锁");
        }
    }
}
public static void LockTryEnterRun()
{
    var example = new LockTryEnterExample();
    var thread1 = new Thread(example.Method1);
    var thread2 = new Thread(example.Method2);
    var thread3 = new Thread(example.Method3);
    thread1.Start();
    thread2.Start();
    thread3.Start();
}
</code></pre>
<p>执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154147953-1536533580.png" alt="" loading="lazy"></p>
<p>可以发现当Method1锁定5秒后，Method2尝试3秒内获取锁，结果并未获取到自动退出；然后Method3尝试7秒内获取锁，结果获取到锁并正确释放锁。</p>
<h1 id="04实现生产者-消费者模式"><em><strong>04</strong></em>、实现生产者-消费者模式</h1>
<p>除了上面介绍的方法，Monitor类还有Wait、Pulse、PulseAll等方法。</p>
<p><strong>Wait：</strong> 该方法用于将当前线程放入等待队列，直到收到其他线程的信号通知。</p>
<p><strong>Pulse：</strong> 该方法用于唤醒等待队列中的一个线程。当一个线程调用 Pulse 时，它会通知一个正在等待该对象锁的线程继续执行。</p>
<p><strong>PulseAll：</strong> 该方法用于唤醒等待队列中的所有线程。</p>
<p>然后我们利用Monitor类的这些功能来实现一个简单的生产者-消费者模式。大致思路如下：</p>
<p>1.首先启动生产者线程，获取锁，然后生成数据；</p>
<p>2.当生产者生产的数据小于数据队列长度，则生产一条数据同时通知消费者线程进行消费，否则暂停当前线程等待消费者线程消费数据；</p>
<p>3.然后启动消费者线程，获取锁，然后消费数据；</p>
<p>4.当数据队列中有数据，则消费一条数据同时通知生产者线程可以生产数据了，否则暂停当前线程等待生产者线程生产数据；</p>
<p>具体代码如下：</p>
<pre><code class="language-csharp">public class LockProducerConsumerExample
{
    private static Queue&lt;int&gt; queue = new Queue&lt;int&gt;();
    private static object _lock = new object();
    //生产者
    public  void Producer()
    {
        while (true)
        {
            lock (_lock)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                if (queue.Count &lt; 3)
                {
                    var item = new Random().Next(100);
                    queue.Enqueue(item);
                    Console.WriteLine($"生产者，生产： {item}");
                    //唤醒消费者
                    Monitor.Pulse(_lock);  
                }
                else
                {
                    //队列满时，生产者等待
                    Console.WriteLine($"队列已满，生产者等待中……");
                    Monitor.Wait(_lock);  
                }
            }
            Thread.Sleep(500);
        }
    }
    // 消费者
    public  void Consumer()
    {
        while (true)
        {
            lock (_lock)
            {
                Console.ForegroundColor = ConsoleColor.Blue;
                if (queue.Count &gt; 0)
                {
                    var item = queue.Dequeue();
                    Console.WriteLine($"消费者，消费： {item}");
                    //唤醒生产者
                    Monitor.Pulse(_lock);  
                }
                else
                {
                    //队列空时，消费者等待
                    Console.WriteLine($"队列已空，消费者等待中……");
                    Monitor.Wait(_lock);  
                }
            }
            Thread.Sleep(10000);
        }
    }
}
public static void LockProducerConsumerRun()
{
    var example = new LockProducerConsumerExample();
    var thread1 = new Thread(example.Producer);
    var thread2 = new Thread(example.Consumer);
    thread1.Start();
    thread2.Start();
    thread1.Join();
    thread2.Join();
}
</code></pre>
<p>执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250213154136030-1152957035.png" alt="" loading="lazy"></p>
<p><em><strong>注</strong></em>：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。<a href="https://gitee.com/hugogoos/Planner" target="_blank" rel="noopener nofollow">https://gitee.com/hugogoos/Planner</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.189494566789352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 15:55">2025-02-13 15:54</span>&nbsp;
<a href="https://www.cnblogs.com/hugogoos">IT规划师</a>&nbsp;
阅读(<span id="post_view_count">222</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18713781" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18713781);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18713781', targetLink: 'https://www.cnblogs.com/hugogoos/p/18713781', title: '并发编程 - 线程同步（七）之互斥锁Monitor' })">举报</a>
</div>
        