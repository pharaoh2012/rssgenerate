
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ITnoteforlsy/p/18809331" title="发布于 2025-04-07 10:42">
    <span role="heading" aria-level="2">从源码解析 QGraphicsItem 旋转、缩放、平移、transform等变换操作，利用QGraphicsTransform实现变形动画</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>QGraphicsItem 有3种方式进行变换：1. 最简单方便的是使用 setRotation() 、setScale()；2. 使用 setTransform() 进行复杂变换；3. 还可以使用 setTransformations()进行多项组合变换及自定义变换。同时应用这三种方式将产生叠加效果，并以 QTransform 形式返回。由于QTransform 是以矩阵为基础进行运算，所以叠加时运算的顺序将影响最后的运算结果。       QGraphicsItem 叠加变换时按照如下顺序进行：首先，应用 setTransform() 设置的 transform；其次，叠加运算 setTransformations() 设置的 transformations（按照 list 中的顺序执行）；然后，叠加运算 setRotation() 设置的 rotation；最后，叠加运算 setScale()设置的 scale。这些规则体现在 qgraphicsitem_p.h 中的 QGraphicsItemPrivate 结构体中，源码如下：</p>
<pre><code>struct QGraphicsItemPrivate::TransformData
{
    QTransform transform;// 对应setTransform()设置的值
    qreal scale; // 对应setScale()设置的值
    qreal rotation; // 对应setRotation()设置的值
    qreal xOrigin;
    qreal yOrigin;
    QList&lt;QGraphicsTransform *&gt; graphicsTransforms; // 对应setTransformations()设置的设置的值
    bool onlyTransform;

    TransformData() :
        scale(1.0), rotation(0.0),
        xOrigin(0.0), yOrigin(0.0),
        onlyTransform(true)
    { }

    QTransform computedFullTransform(QTransform *postmultiplyTransform = nullptr) const
    {
        // 此处进行叠加运算
        if (onlyTransform) {
            if (!postmultiplyTransform || postmultiplyTransform-&gt;isIdentity())
                return transform;
            if (transform.isIdentity())
                return *postmultiplyTransform;
            return transform * *postmultiplyTransform;
        }

        QTransform x(transform);
        if (!graphicsTransforms.isEmpty()) {
            QMatrix4x4 m;
            for (int i = 0; i &lt; graphicsTransforms.size(); ++i)
                graphicsTransforms.at(i)-&gt;applyTo(&amp;m);
            x *= m.toTransform();
        }
        x.translate(xOrigin, yOrigin);
        x.rotate(rotation);
        x.scale(scale, scale);
        x.translate(-xOrigin, -yOrigin);
        if (postmultiplyTransform)
            x *= *postmultiplyTransform;
        return x;
    }
};

</code></pre>
<p>从源码中可以看出，transform、scale、rotation、graphicsTransforms单独存储。通过setRotation()设置的值存储在rotation，通过setScale()设置的值存储在scale。而rotation()和scale()返回的值就是QGraphicsItemPrivate中的变量rotation和scale。从qgraphicsitem.cpp源码中可以看到rotation和scale的存储方法。</p>
<pre><code>qreal QGraphicsItem::rotation() const
{
    if (!d_ptr-&gt;transformData)
        return 0;
    return d_ptr-&gt;transformData-&gt;rotation;
}

void QGraphicsItem::setRotation(qreal angle)
{
    prepareGeometryChange();
    qreal newRotation = angle;

    if (d_ptr-&gt;flags &amp; ItemSendsGeometryChanges) {
        // Notify the item that the rotation is changing.
        const QVariant newRotationVariant(itemChange(ItemRotationChange, angle));
        newRotation = newRotationVariant.toReal();
    }

    if (!d_ptr-&gt;transformData)
        d_ptr-&gt;transformData = new QGraphicsItemPrivate::TransformData;

    if (d_ptr-&gt;transformData-&gt;rotation == newRotation)
        return;

    d_ptr-&gt;transformData-&gt;rotation = newRotation;
    d_ptr-&gt;transformData-&gt;onlyTransform = false;
    d_ptr-&gt;dirtySceneTransform = 1;

    // Send post-notification.
    if (d_ptr-&gt;flags &amp; ItemSendsGeometryChanges)
        itemChange(ItemRotationHasChanged, newRotation);

    if (d_ptr-&gt;isObject)
        emit static_cast&lt;QGraphicsObject *&gt;(this)-&gt;rotationChanged();

    d_ptr-&gt;transformChanged();
}
</code></pre>
<p>如果需要获取当前图元旋转的角度，从 rotation() 方法中的得到的角度只是通过 setRotation() 方法设置的角度，该角度不包含 transform 和 graphicsTransforms 中隐含的角度。当然，如果图元只是进行了角度变换，可以从 sceneTransform() 方法获取 Transform，利用文章《<a href="https://www.cnblogs.com/ITnoteforlsy/p/18148656" title="Qt 从 QTransform 逆向解出 Translate/Scale/Rotate（平移/缩放/旋转）分析" target="_blank">Qt 从 QTransform 逆向解出 Translate/Scale/Rotate（平移/缩放/旋转）分析</a>》介绍的方法可以逆向解析出图元旋转的角度。</p>
<p>如果需要获取图元每次变化的角度、缩放大小及平移信息，可以只使用 setTransformations() 方法来控制图元进行变化，因为 QGraphicsTransform 的子类可以完全由开发者自己控制，所执行的变换都可以很容易的计算出来。例如：QGraphicsTransform 的子类 QGraphicsRotation 提供了 angle() 和 setAngle(qreal) 方法；QGraphicsScale 提供了 setXScale(qreal) 、xScale() const 、setYScale(qreal) 、yScale() const 等方法。</p>
<p>控制图元变换时 setTransformations() 方法更灵活一些，特别是对图元进行变换动画时，编写 QGraphicsTransform 的子类，很容易控制动画。具体代码可以参考GitHub项目 <a href="https://github.com/lsyeei/dashboard" title="Compelling Data Designer" target="_blank" rel="noopener nofollow">Compelling Data Designer</a> 中 BIDesigner/animation<br>
/tranfromanimation 的实现方法。通过扩展 QGraphicsTransform 实现子类 GraphicsRotationZ 、 GraphicsRotationY 、 GraphicsRotationX 、 QGraphicsTranslation 实现了旋转、水平翻转、垂直翻转、按路径移动、缩放等动画效果。<br>
<img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407102627551-720752550.gif" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4827038324282407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-07 10:42">2025-04-07 10:42</span>&nbsp;
<a href="https://www.cnblogs.com/ITnoteforlsy">永不停转</a>&nbsp;
阅读(<span id="post_view_count">102</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18809331" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18809331);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18809331', targetLink: 'https://www.cnblogs.com/ITnoteforlsy/p/18809331', title: '从源码解析 QGraphicsItem 旋转、缩放、平移、transform等变换操作，利用QGraphicsTransform实现变形动画' })">举报</a>
</div>
        