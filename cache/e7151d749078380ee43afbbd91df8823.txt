
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/javaguide/p/18624855" title="发布于 2024-12-23 19:19">
    <span role="heading" aria-level="2">快手后端面试，被面试官秒挂了！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>你好，我是 Guide。很久没有分享凉经了，今天来分享一位西北工业大学的读者面试快手，一面就直接秒挂的面经。</p>
<p>快手一面主要会问一些基础问题，也就是比较简单且容易准备的常规八股，通常不会问项目或者问的比较少。到了二面，会开始问项目，各种问题也挖掘的更深一些。</p>
<p>很多同学觉得这种基础问题的考查意义不大，实际上还是很有意义的，这种基础性的知识在日常开发中也会需要经常用到。例如，线程池这块的拒绝策略、核心参数配置什么的，如果你不了解，实际项目中使用线程池可能就用的不是很明白，容易出现问题。而且，其实这种基础性的问题是最容易准备的，像各种底层原理、系统设计、场景题以及深挖你的项目这类才是最难的！</p>
<p>下面是正文。</p>
<p>一面没有问项目，就是一些很基础的八股。面试官说我的基础知识太薄弱，很多面试题回答的像是在硬背，没有自己的理解。另外，他建议我提高一下自己的表达能力，吐词尽量要清晰一些。</p>
<h3 id="1java-异常类分为哪两种有什么区别">1、Java 异常类分为哪两种？有什么区别？</h3>
<p>Java 异常类层次结构图概览：</p>
<p><img src="https://img2024.cnblogs.com/blog/1843652/202412/1843652-20241223191822293-1556139622.png" alt="Java 异常类层次结构图" loading="lazy"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，<s>我们没办法通过 <code>catch</code> 来进行捕获</s>不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="2try-with-resources-怎么使用">2、try-with-resources 怎么使用？</h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effective Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<pre><code class="language-java">//读取文本文件的内容
Scanner scanner = null;
try {
    scanner = new Scanner(new File("D://read.txt"));
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();
    }
}
</code></pre>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<pre><code class="language-java">try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
</code></pre>
<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<pre><code class="language-java">try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>更多 Java 基础相关的面试题，可以参考这几篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html" target="_blank" rel="noopener nofollow">Java 基础常见面试题总结（上）</a></li>
<li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html" target="_blank" rel="noopener nofollow">Java 基础常见面试题总结（中）</a></li>
<li><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html" target="_blank" rel="noopener nofollow">Java 基础常见面试题总结（下）</a></li>
</ul>
<h3 id="3hashmap-为什么不是线程安全的">3、HashMap 为什么不是线程安全的？</h3>
<p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p>
<p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p>
<p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>
<p>举个例子：</p>
<ul>
<li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li>
<li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li>
<li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li>
</ul>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    // ...
    // 判断是否出现 hash 碰撞
    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 桶中已经存在元素（处理hash冲突）
    else {
    // ...
}
</code></pre>
<p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p>
<ol>
<li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li>
<li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li>
<li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li>
<li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li>
</ol>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    // ...
    // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<h3 id="4那-hashmap-线程安全的替代品是">4、那 HashMap 线程安全的替代品是？</h3>
<p>我们知道，<code>HashMap</code> 是线程不安全的，如果在并发场景下使用，一种常见的解决方式是通过 <code>Collections.synchronizedMap()</code> 方法对 <code>HashMap</code> 进行包装，使其变为线程安全。不过，这种方式是通过一个全局锁来同步不同线程间的并发访问，会导致严重的性能瓶颈，尤其是在高并发场景下。</p>
<p>为了解决这一问题，<code>ConcurrentHashMap</code> 应运而生，作为 <code>HashMap</code> 的线程安全版本，它提供了更高效的并发处理能力。</p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<p><img src="https://img2024.cnblogs.com/blog/1843652/202412/1843652-20241223191822283-1011237165.png" alt="Java7 ConcurrentHashMap 存储结构" loading="lazy"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<p><img src="https://img2024.cnblogs.com/blog/1843652/202412/1843652-20241223191822268-1684640586.png" alt="Java8 ConcurrentHashMap 存储结构" loading="lazy"></p>
<p>更多 Java 集合相关的面试题，可以参考这几篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html" target="_blank" rel="noopener nofollow">Java 集合常见面试题总结（上）</a></li>
<li><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html" target="_blank" rel="noopener nofollow">Java 集合常见面试题总结（中）</a></li>
<li><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html" target="_blank" rel="noopener nofollow">Java 集合常见面试题总结（下）</a></li>
</ul>
<h3 id="5可重入锁指的是">5、可重入锁指的是？</h3>
<p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<h3 id="6synchronized-是可重入锁吗">6、synchronized 是可重入锁吗？</h3>
<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>
<p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p>
<pre><code class="language-java">public class SynchronizedDemo {
    public synchronized void method1() {
        System.out.println("方法1");
        method2();
    }

    public synchronized void method2() {
        System.out.println("方法2");
    }
}
</code></pre>
<p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p>
<p>更多 Java 并发相关的面试题，可以参考这几篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html" target="_blank" rel="noopener nofollow">Java 并发常见面试题总结（上）</a></li>
<li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html" target="_blank" rel="noopener nofollow">Java 并发常见面试题总结（中）</a></li>
<li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html" target="_blank" rel="noopener nofollow">Java 并发常见面试题总结（下）</a></li>
</ul>
<h3 id="7堆内存的结构是">7、堆内存的结构是？</h3>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ol>
<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<p><img src="https://img2024.cnblogs.com/blog/1843652/202412/1843652-20241223191822278-1158317915.png" alt="堆内存结构" loading="lazy"></p>
<p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p>
<h3 id="8对象会被分配都哪个区域">8、对象会被分配都哪个区域？</h3>
<p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p>
<p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h3 id="9jdk-默认垃圾回收器是">9、JDK 默认垃圾回收器是？</h3>
<ul>
<li><strong>JDK 1.8 默认垃圾回收器</strong>：Parallel Scanvenge（新生代）+ Parallel Old（老年代）。 这个组合也被称为 Parallel GC 或 Throughput GC，侧重于吞吐量。</li>
<li><strong>JDK 1.9 及以后默认垃圾回收器</strong>：G1 GC (Garbage-First Garbage Collector)。 G1 GC 是一个更现代化的垃圾回收器，旨在平衡吞吐量和停顿时间，尤其适用于堆内存较大的应用。</li>
</ul>
<p>更多 JVM 相关的面试题，可以参考这几篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/java/jvm/memory-area.html" target="_blank" rel="noopener nofollow">Java 内存区域详解（重点）</a></li>
<li><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html" target="_blank" rel="noopener nofollow">JVM 垃圾回收详解（重点）</a></li>
<li><a href="https://javaguide.cn/java/jvm/class-file-structure.html" target="_blank" rel="noopener nofollow">类文件结构详解</a></li>
<li><a href="https://javaguide.cn/java/jvm/class-loading-process.html" target="_blank" rel="noopener nofollow">类加载过程详解</a></li>
<li><a href="https://javaguide.cn/java/jvm/classloader.html" target="_blank" rel="noopener nofollow">类加载器详解（重点）</a></li>
</ul>
<h3 id="10你知道哪些-java-性能优化和问题排查工具">10、你知道哪些 Java 性能优化和问题排查工具？</h3>
<p>JDK 自带的可视化分析工具：</p>
<ul>
<li><strong>JConsole</strong> ：基于 JMX 的可视化监视、管理工具，可以用于查看应用程序的运行概况、内存、线程、类、VM 概括、MBean 等信息。</li>
<li><strong>VisualVM</strong>：基于 NetBeans 平台开发，具备了插件扩展功能的特性。利用它不仅能够监控服务的 CPU、内存、线程、类等信息，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。根据《深入理解 Java 虚拟机》介绍：“VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的”。</li>
</ul>
<p>JDK 自带的命令行工具：</p>
<ul>
<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>
<li><strong><code>jstat</code></strong> （JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>
<li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li>
<li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li>
<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；</li>
<li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>
<p>第三方工具：</p>
<ul>
<li><strong>MAT</strong>：一款功能强大的 Java 堆内存分析器，可以用于查找内存泄漏以及查看内存消耗情况，用户可以利用 VisualVM 或者是 <code>jmap</code> 命令生产堆文件，然后导入工具中进行分析。</li>
<li><strong>GCeasy</strong>：一款在线的 GC 日志分析器，使用起来非常方便，用户可以通过它的 Web 网站导入 GC 日志，实时进行内存泄漏检测、GC 暂停原因分析、JVM 配置建议优化等功能。网站地址：<a href="https://gceasy.io/" target="_blank" rel="noopener nofollow">https://gceasy.io/</a> 。</li>
<li><strong>GCViewer</strong>：一款非常强大的 GC 日志可视化分析工具，功能强大而且完全免费。</li>
<li><strong>JProfiler</strong>：一款商用的性能分析利器，功能强大，但需要付费使用。 它提供更深入的性能分析功能，例如方法调用分析、内存分配分析等。</li>
<li><strong>Arthas</strong>：阿里开源的一款线上监控诊断工具，可以查看应用负载、内存、gc、线程等信息。</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.046908591502314814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 19:19">2024-12-23 19:19</span>&nbsp;
<a href="https://www.cnblogs.com/javaguide">JavaGuide</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18624855" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18624855);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18624855', targetLink: 'https://www.cnblogs.com/javaguide/p/18624855', title: '快手后端面试，被面试官秒挂了！' })">举报</a>
</div>
        