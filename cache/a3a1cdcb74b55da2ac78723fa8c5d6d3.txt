
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18898130" title="发布于 2025-05-27 10:19">
    <span role="heading" aria-level="2">明明是同一条SQL，为什么有时候走索引a，有时候却走索引b ？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>想象你是一家餐厅的服务员，面前有两个菜单：</p>
<ul>
<li><strong>菜单A</strong>：按菜品分类排列（前菜、主菜、甜点）</li>
<li><strong>菜单B</strong>：按价格从低到高排列</li>
</ul>
<p>当顾客说："我要最便宜的川菜"。</p>
<p>你会：</p>
<ol>
<li>先用菜单B找到所有低价菜</li>
<li>从中筛选川菜</li>
</ol>
<p>或者：</p>
<ol>
<li>先用菜单A找到所有川菜</li>
<li>再按价格排序</li>
</ol>
<p><strong>这就是MySQL优化器的日常决策</strong>！</p>
<p>明明是同一条SQL，有时候走的索引a，而有时候走的索引b，就是它的锅。</p>
<p>今天这篇文章跟大家一起聊聊，MySQL选错索引的问题，希望对你会有所帮助。</p>
<h2 id="1-一个让程序员崩溃的案例">1 一个让程序员崩溃的案例</h2>
<p>现在有个需求：查询今年开始已付款的前100个订单。</p>
<p>给status字段创建了索引idx_status。</p>
<p>给create_time字段创建了索引idx_create_time。</p>
<p>查询订单的sql如下：</p>
<pre><code class="language-sql">SELECT * FROM orders 
WHERE status = 'paid'      -- 状态条件
AND create_time &gt; '2025-01-01' -- 时间条件
ORDER BY amount DESC 
LIMIT 100;
</code></pre>
<p><strong>周一执行计划如下</strong>：</p>
<pre><code class="language-plain">使用索引：idx_status（状态索引）  
扫描行数：500行  
耗时：0.1秒
</code></pre>
<p><strong>周二执行计划如下</strong>：</p>
<pre><code class="language-plain">使用索引：idx_create_time（时间索引）  
扫描行数：50万行  
耗时：8秒
</code></pre>
<p>周一只扫描了500行数据，而周二却扫描了50万行数据。</p>
<p>周一耗时0.1秒，而周二耗时却又8秒。</p>
<p>同一SQL在不同时间性能差异80倍！</p>
<p>让我们拆解背后的原因。</p>
<h2 id="2-揭秘优化器的决策三步曲">2 揭秘优化器的"决策三步曲"</h2>
<p>MySQL优化器的决策流程如下：<br>
<img src="https://files.mdnice.com/user/5303/2cd47d9b-8efc-40c5-bf40-31c57924538a.png" alt="" loading="lazy"></p>
<p><strong>成本计算示例</strong>：</p>
<table>
<thead>
<tr>
<th>索引名称</th>
<th>预估扫描行数</th>
<th>回表次数</th>
<th>排序成本</th>
<th>总成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>idx_status</td>
<td>50万</td>
<td>50万次</td>
<td>需要排序</td>
<td>1050分</td>
</tr>
<tr>
<td>idx_create_time</td>
<td>5万</td>
<td>5万次</td>
<td>无需排序</td>
<td>600分</td>
</tr>
</tbody>
</table>
<p>根据扫描行数、回表次数、排序成本，计算一个总成本的分数。</p>
<p>优化器会选择总成本更低的idx_create_time索引。</p>
<h2 id="3-导致索引切换的四大真凶">3 导致索引切换的四大真凶</h2>
<h3 id="真凶1数据分布变化">真凶1：数据分布变化</h3>
<p><strong>场景还原</strong>：</p>
<ul>
<li>周一数据：已支付订单5万条，其中2025年的5万条</li>
<li>周二数据：已支付订单50万条，其中2025年的50万条</li>
</ul>
<p>这个例子中数据分布变化很大，周二的数据，比周一的数据一下子多了45万。</p>
<p>可能会影响总成本的分数。</p>
<p>我们可以通过下面的SQL查看数据分布：</p>
<pre><code class="language-sql">SELECT 
  COUNT(*) AS total,
  SUM(status='paid') AS paid_count,
  SUM(create_time&gt;'2023-01-01') AS new_orders 
FROM orders;
</code></pre>
<h3 id="真凶2统计信息过期">真凶2：统计信息过期</h3>
<p>统计信息过期，就像用去年的地图导航，新修的路不会出现在地图上。</p>
<p>MySQL的"地图"就是统计信息。</p>
<p>我们可以通过ANALYZE TABLE ... DELETE STATISTICS命令删除统计信息：</p>
<pre><code class="language-sql">ANALYZE TABLE orders DELETE STATISTICS;
</code></pre>
<p>这时候查询可能变成全表扫描：</p>
<pre><code class="language-sql">EXPLAIN SELECT...
</code></pre>
<p>显示type: ALL</p>
<p><strong>那么，如何解决这个问题呢？</strong></p>
<p>使用ANALYZE TABLE命令，刷新统计信息（相当于更新地图）：</p>
<pre><code class="language-sql">ANALYZE TABLE orders;
</code></pre>
<h3 id="真凶3索引覆盖度差异">真凶3：索引覆盖度差异</h3>
<p><strong>点餐类比</strong>：</p>
<ul>
<li>菜单A能直接看到菜品价格 → 无需问厨师（覆盖索引）</li>
<li>菜单B只能看到菜品名 → 需要问厨师详情（回表查询）</li>
</ul>
<p>下面的SQL会走idx_status（需要回表）：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE status='paid';
</code></pre>
<p>下面的SQL会走idx_create_time（覆盖索引）：</p>
<pre><code class="language-sql">SELECT create_time FROM 
orders WHERE create_time&gt;'2023-01-01';
</code></pre>
<h3 id="真凶4索引碎片化">真凶4：索引碎片化</h3>
<p>索引碎片化就像书本的目录页被撕破，找内容变得困难。</p>
<p><strong>检查方法</strong>：</p>
<pre><code class="language-sql">SHOW TABLE STATUS LIKE 'orders';
</code></pre>
<p>查看Data_free字段，值越大碎片越多。</p>
<p><strong>优化方案</strong>：</p>
<p>使用ALTER TABLE命令重建索引。</p>
<pre><code class="language-sql">ALTER TABLE orders ENGINE=INNODB;
</code></pre>
<h2 id="4-问题排查四步法">4 问题排查四步法</h2>
<h3 id="第一步查看当前执行计划">第一步：查看当前执行计划</h3>
<p>使用EXPLAIN查看当前SQL的执行计划：</p>
<pre><code class="language-sql">EXPLAIN 
SELECT * FROM orders 
WHERE status='paid' 
AND create_time&gt;'2023-01-01';
</code></pre>
<h3 id="第二步检查统计信息">第二步：检查统计信息</h3>
<p>使用SHOW INDEX命令检查索引的统计信息：</p>
<pre><code class="language-sql">SHOW INDEX FROM orders;
</code></pre>
<p>关注Cardinality字段，值越接近真实数据越好。</p>
<h3 id="第三步分析数据分布">第三步：分析数据分布</h3>
<p>使用下面的SQL分析数据分布:</p>
<pre><code class="language-sql">SELECT 
  COUNT(*) AS total,
  AVG(LENGTH(status)) AS status_avg_len 
FROM orders;
</code></pre>
<h3 id="第四步追踪优化器思考过程">第四步：追踪优化器思考过程</h3>
<pre><code class="language-sql">SET optimizer_trace="enabled=on";
SELECT * FROM orders WHERE ...;
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
</code></pre>
<p>开启optimizer_trace，然后通过INFORMATION_SCHEMA.OPTIMIZER_TRACE表查看追踪优化器思考过程。</p>
<h2 id="5-三大终极解决方案">5 三大终极解决方案</h2>
<h3 id="方案1引导优化器选择">方案1：引导优化器选择</h3>
<p>使用FORCE INDEX强制使用指定索引：</p>
<pre><code class="language-sql">SELECT * FROM orders FORCE INDEX(idx_status) WHERE ...;
</code></pre>
<h3 id="方案2创建更优索引">方案2：创建更优索引</h3>
<p>创建更优的联合索引：</p>
<pre><code class="language-sql">ALTER TABLE orders 
ADD INDEX idx_status_create_time(status,create_time);
</code></pre>
<h3 id="方案3定期维护计划">方案3：定期维护计划</h3>
<ol>
<li>定期统计信息更新</li>
<li>定期碎片率检查</li>
<li>定期索引重建</li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="六个必须检查的点">六个必须检查的点</h3>
<ol>
<li>WHERE条件字段是否有合适索引</li>
<li>ORDER BY/GROUP BY是否利用索引排序</li>
<li>统计信息是否最新（尤其大表每天更新）</li>
<li>是否存在索引碎片（每月检查一次）</li>
<li>是否出现索引合并（INDEX_MERGE）</li>
<li>是否使用覆盖索引（减少回表）</li>
</ol>
<h3 id="三条黄金法则">三条黄金法则</h3>
<ol>
<li><strong>二八定律</strong>：20%的索引满足80%的查询</li>
<li><strong>数据驱动</strong>：定期分析查询模式调整索引</li>
<li><strong>防御编程</strong>：核心查询明确指定索引</li>
</ol>
<p>最后说一句(求关注，别白嫖我)<br>
如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，我的所有文章都会在公众号上首发，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03372683046875" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 10:20">2025-05-27 10:19</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">64</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18898130);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18898130', targetLink: 'https://www.cnblogs.com/12lisu/p/18898130', title: '明明是同一条SQL，为什么有时候走索引a，有时候却走索引b ？' })">举报</a>
</div>
        