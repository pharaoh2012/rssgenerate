
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/19062599" title="发布于 2025-08-28 16:51">
    <span role="heading" aria-level="2">深入解析权重轮询算法：非平滑与平滑实现的原理与数学依据</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言一场关于公平分配的艺术-">前言：一场关于"公平"分配的艺术 🎭</h2>
<p>想象一下，你是一位餐厅经理，有三名厨师：👨‍🍳 大厨A（能做5道菜）、👨‍🍳 二厨B（能做3道菜）和 👨‍🍳 小厨C（能做2道菜）。现在来了10位客人，你怎么分配任务才能既发挥每个人的特长，又不让任何一位厨师累趴下？这就是负载均衡要解决的核心问题！</p>
<p>在分布式系统领域，权重轮询算法就像是这位聪明的餐厅经理，它能够根据服务器的"厨艺"（处理能力）分配不同比例的请求。今天，我们就来深入探讨两种不同的"分配艺术"：简单粗暴的非平滑权重轮询和精明圆滑的平滑权重轮询。</p>
<h2 id="一非平滑权重轮询老实人的直球对决-">一、非平滑权重轮询：老实人的直球对决 ⚾</h2>
<h3 id="11-算法原理排排坐分果果">1.1 算法原理：排排坐，分果果</h3>
<p>非平滑权重轮询算法（又称静态权重轮询）的核心思想是基于权重比例进行确定性分配。算法维护一个全局计数器，通过对总权重取模来确定当前请求应该分配给哪个服务器。</p>
<p><strong>详细实现原理</strong>：</p>
<ol>
<li><strong>初始化阶段</strong>：计算所有服务器权重的总和（totalWeight）</li>
<li><strong>选择阶段</strong>：
<ul>
<li>维护一个原子计数器（currentIndex），确保线程安全</li>
<li>每次请求时，计数器递增并对总权重取模：<code>index = (currentIndex + 1) % totalWeight</code></li>
<li>遍历服务器列表，用当前索引值依次减去每个服务器的权重</li>
<li>当剩余值小于某个服务器的权重时，选择该服务器</li>
</ul>
</li>
</ol>
<p><strong>数学表达</strong>：<br>
设服务器权重数组为 W = [w₁, w₂, ..., wₙ]，总权重 T = Σwᵢ<br>
对于第k个请求，选择满足以下条件的服务器i：<br>
Σʲ⁻¹wⱼ ≤ (k mod T) &lt; Σʲwⱼ，其中 j=1 to i</p>
<h3 id="12-数学依据区间映射理论-">1.2 数学依据：区间映射理论 📐</h3>
<p><strong>严格的数学理论</strong>：</p>
<p>非平滑权重轮询基于数论中的模运算和区间划分原理。算法将[0, T-1]的整数区间按权重比例划分为n个子区间，每个子区间的长度等于对应服务器的权重。</p>
<p>数学上，可以表示为：</p>
<ul>
<li>服务器i的分配区间为 [Sᵢ, Sᵢ + wᵢ)，其中 Sᵢ = Σʲ⁻¹wⱼ (j=1 to i-1)</li>
<li>对于请求序列号k，计算 m = k mod T</li>
<li>选择满足 m ∈ [Sᵢ, Sᵢ + wᵢ) 的服务器i</li>
</ul>
<p><strong>通俗解释</strong>：<br>
想象有一个长度为总权重的"轮盘赌"，每个服务器占据与其权重成比例的扇形区域。每次请求就像旋转轮盘，指针停在哪个区域就选择对应的服务器。这种方法的优点是实现简单，计算复杂度低（O(n)），但缺点是分配不够平滑，可能导致某些服务器短时间内接收大量请求。</p>
<h3 id="13-代码实现深度解析-">1.3 代码实现深度解析 💻</h3>
<pre><code class="language-java">public Server getNextServer() {
    // 使用原子操作确保线程安全，避免并发问题
    int index = currentIndex.updateAndGet(i -&gt; (i + 1) % totalWeight);
    
    // 线性搜索找到对应的服务器
    for (Server server : servers) {
        if (index &lt; server.getWeight()) {
            return server; // 找到目标服务器
        }
        index -= server.getWeight(); // 调整索引，继续寻找
    }
    return servers.get(0); // 安全回退
}
</code></pre>
<p><strong>代码分析</strong>：</p>
<ul>
<li><code>AtomicInteger</code> 确保多线程环境下的线程安全</li>
<li>取模运算 <code>% totalWeight</code> 将索引限制在 [0, totalWeight-1] 范围内</li>
<li>线性搜索的时间复杂度为 O(n)，对于服务器数量不多的情况效率可接受</li>
</ul>
<h3 id="14-执行过程详细图示-️">1.4 执行过程详细图示 🍽️</h3>
<p>假设有三台服务器：</p>
<ul>
<li>🟥 ServerA: 权重 5</li>
<li>🟦 ServerB: 权重 3</li>
<li>🟩 ServerC: 权重 2<br>
总权重 = 10</li>
</ul>
<p><strong>详细的分配过程</strong>：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>当前索引</th>
<th>计算过程</th>
<th>选中服务器</th>
<th>分配模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0 &lt; 5? ✅</td>
<td>🟥 ServerA</td>
<td>A</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1 &lt; 5? ✅</td>
<td>🟥 ServerA</td>
<td>A</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2 &lt; 5? ✅</td>
<td>🟥 ServerA</td>
<td>A</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>3 &lt; 5? ✅</td>
<td>🟥 ServerA</td>
<td>A</td>
</tr>
<tr>
<td>5</td>
<td>4</td>
<td>4 &lt; 5? ✅</td>
<td>🟥 ServerA</td>
<td>A</td>
</tr>
<tr>
<td>6</td>
<td>5</td>
<td>5 &lt; 5? ❌ → 5-5=0; 0 &lt; 3? ✅</td>
<td>🟦 ServerB</td>
<td>B</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
<td>6 &lt; 5? ❌ → 6-5=1; 1 &lt; 3? ✅</td>
<td>🟦 ServerB</td>
<td>B</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>7 &lt; 5? ❌ → 7-5=2; 2 &lt; 3? ✅</td>
<td>🟦 ServerB</td>
<td>B</td>
</tr>
<tr>
<td>9</td>
<td>8</td>
<td>8 &lt; 5? ❌ → 8-5=3; 3 &lt; 3? ❌ → 3-3=0; 0 &lt; 2? ✅</td>
<td>🟩 ServerC</td>
<td>C</td>
</tr>
<tr>
<td>10</td>
<td>9</td>
<td>9 &lt; 5? ❌ → 9-5=4; 4 &lt; 3? ❌ → 4-3=1; 1 &lt; 2? ✅</td>
<td>🟩 ServerC</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>模式分析</strong>：<br>
分配序列为：A-A-A-A-A-B-B-B-C-C<br>
这种分配明显不平滑，ServerA连续处理5个请求，然后ServerB处理3个，最后ServerC处理2个。</p>
<h2 id="二平滑权重轮询情商满分的分配大师-">二、平滑权重轮询：情商满分的分配大师 🎩</h2>
<h3 id="21-算法原理动态权重调整机制">2.1 算法原理：动态权重调整机制</h3>
<p>平滑权重轮询算法通过引入动态权重概念来解决非平滑算法的问题。每个服务器有两个权重值：</p>
<ul>
<li>固定权重（weight）：表示服务器的处理能力</li>
<li>当前权重（currentWeight）：动态值，在运行时调整</li>
</ul>
<p><strong>详细实现原理</strong>：</p>
<ol>
<li><strong>初始化阶段</strong>：所有服务器的当前权重设为0</li>
<li><strong>选择阶段</strong>：
<ul>
<li>每次请求前，所有服务器的当前权重增加其固定权重</li>
<li>选择当前权重最大的服务器</li>
<li>被选中服务器的当前权重减去总权重</li>
<li>重复此过程</li>
</ul>
</li>
</ol>
<p><strong>数学本质</strong>：<br>
这实际上是一种贪心算法，通过动态调整权重来确保：</p>
<ul>
<li>权重大的服务器被选中的概率更高</li>
<li>但不会连续多次选择同一服务器</li>
<li>长期来看，选择比例精确匹配权重比例</li>
</ul>
<h3 id="22-数学依据公平序列生成算法-">2.2 数学依据：公平序列生成算法 📊</h3>
<p><strong>严格的数学理论</strong>：</p>
<p>平滑权重轮询算法基于以下数学原理：</p>
<p>设服务器i的权重为wᵢ，总权重为T = Σwᵢ<br>
算法保证：</p>
<ol>
<li>每个周期（T次请求）内，服务器i被选中 exactly wᵢ 次</li>
<li>服务器i的两次被选中之间的最大间隔不超过 ⌈T/wᵢ⌉</li>
<li>序列的平滑度最优：方差最小化</li>
</ol>
<p>算法可以形式化为：<br>
对于每个请求t：</p>
<ol>
<li>更新：cᵢ(t) = cᵢ(t-1) + wᵢ 对于所有i</li>
<li>选择：i* = argmaxᵢ cᵢ(t)</li>
<li>调整：cᵢ<em>(t) = cᵢ</em>(t) - T</li>
</ol>
<p><strong>通俗解释</strong>：<br>
这就像给每个服务器发一张"积分卡"。每次请求前，大家都获得与能力相符的积分，积分最高者获得处理机会，但需要扣除"入场费"（总权重）。这样既能保证能力强的服务器获得更多机会，又能避免它们垄断所有请求。</p>
<h3 id="23-代码实现深度解析-">2.3 代码实现深度解析 🧠</h3>
<pre><code class="language-java">public Server getNextServer() {
    Server targetServer = null;
    int maxWeight = Integer.MIN_VALUE;
    
    // 第一步：所有服务器增加权重，并找出最大值
    for (Server server : servers) {
        int newWeight = server.getCurrentWeight() + server.getWeight();
        server.setCurrentWeight(newWeight);
        
        if (newWeight &gt; maxWeight) {
            maxWeight = newWeight;
            targetServer = server;
        }
    }
    
    // 第二步：选中服务器减去总权重
    if (targetServer != null) {
        targetServer.setCurrentWeight(targetServer.getCurrentWeight() - totalWeight);
        return targetServer;
    }
    
    return servers.get(0);
}
</code></pre>
<p><strong>算法复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，需要遍历服务器列表两次（可优化为一次）</li>
<li>空间复杂度：O(n)，需要为每个服务器存储额外状态</li>
<li>线程安全：需要额外同步机制（示例代码未显示）</li>
</ul>
<h3 id="24-执行过程详细图示-">2.4 执行过程详细图示 🎡</h3>
<p>同样配置：ServerA(5), ServerB(3), ServerC(2), 总权重=10</p>
<p><strong>详细执行过程</strong>：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>增加后权重</th>
<th>选中服务器</th>
<th>调整后权重</th>
<th>分配序列</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>🟥 A:0+5=5, 🟦 B:0+3=3, 🟩 C:0+2=2</td>
<td>🟥 A(max=5)</td>
<td>🟥 A:5-10=-5, 🟦 B:3, 🟩 C:2</td>
<td>A</td>
</tr>
<tr>
<td>2</td>
<td>🟥 A:-5+5=0, 🟦 B:3+3=6, 🟩 C:2+2=4</td>
<td>🟦 B(max=6)</td>
<td>🟥 A:0, 🟦 B:6-10=-4, 🟩 C:4</td>
<td>B</td>
</tr>
<tr>
<td>3</td>
<td>🟥 A:0+5=5, 🟦 B:-4+3=-1, 🟩 C:4+2=6</td>
<td>🟩 C(max=6)</td>
<td>🟥 A:5, 🟦 B:-1, 🟩 C:6-10=-4</td>
<td>C</td>
</tr>
<tr>
<td>4</td>
<td>🟥 A:5+5=10, 🟦 B:-1+3=2, 🟩 C:-4+2=-2</td>
<td>🟥 A(max=10)</td>
<td>🟥 A:10-10=0, 🟦 B:2, 🟩 C:-2</td>
<td>A</td>
</tr>
<tr>
<td>5</td>
<td>🟥 A:0+5=5, 🟦 B:2+3=5, 🟩 C:-2+2=0</td>
<td>🟥 A或B(都5)</td>
<td>🟥 A:5-10=-5, 🟦 B:5, 🟩 C:0</td>
<td>A</td>
</tr>
<tr>
<td>6</td>
<td>🟥 A:-5+5=0, 🟦 B:5+3=8, 🟩 C:0+2=2</td>
<td>🟦 B(max=8)</td>
<td>🟥 A:0, 🟦 B:8-10=-2, 🟩 C:2</td>
<td>B</td>
</tr>
<tr>
<td>7</td>
<td>🟥 A:0+5=5, 🟦 B:-2+3=1, 🟩 C:2+2=4</td>
<td>🟥 A(max=5)</td>
<td>🟥 A:5-10=-5, 🟦 B:1, 🟩 C:4</td>
<td>A</td>
</tr>
<tr>
<td>8</td>
<td>🟥 A:-5+5=0, 🟦 B:1+3=4, 🟩 C:4+2=6</td>
<td>🟩 C(max=6)</td>
<td>🟥 A:0, 🟦 B:4, 🟩 C:6-10=-4</td>
<td>C</td>
</tr>
<tr>
<td>9</td>
<td>🟥 A:0+5=5, 🟦 B:4+3=7, 🟩 C:-4+2=-2</td>
<td>🟦 B(max=7)</td>
<td>🟥 A:5, 🟦 B:7-10=-3, 🟩 C:-2</td>
<td>B</td>
</tr>
<tr>
<td>10</td>
<td>🟥 A:5+5=10, 🟦 B:-3+3=0, 🟩 C:-2+2=0</td>
<td>🟥 A(max=10)</td>
<td>🟥 A:10-10=0, 🟦 B:0, 🟩 C:0</td>
<td>A</td>
</tr>
</tbody>
</table>
<p><strong>分配序列</strong>：A, B, C, A, A, B, A, C, B, A</p>
<p><strong>平滑性分析</strong>：</p>
<ul>
<li>ServerA被选中5次（50%），但没有连续超过2次</li>
<li>ServerB被选中3次（30%），分布均匀</li>
<li>ServerC被选中2次（20%），间隔合理</li>
</ul>
<h2 id="三两种算法对比分析-️">三、两种算法对比分析 ⚖️</h2>
<h3 id="31-理论基础对比">3.1 理论基础对比</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>非平滑权重轮询</th>
<th>平滑权重轮询</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数学基础</strong></td>
<td>模运算和区间划分</td>
<td>动态规划和贪心算法</td>
</tr>
<tr>
<td><strong>序列性质</strong></td>
<td>确定性、周期性</td>
<td>确定性、准周期性</td>
</tr>
<tr>
<td><strong>平滑度</strong></td>
<td>低（可能连续选择）</td>
<td>高（分布均匀）</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>长期比例公平</td>
<td>长期比例公平+短期平滑</td>
</tr>
</tbody>
</table>
<h3 id="32-性能特征对比-">3.2 性能特征对比 📊</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>非平滑权重轮询</th>
<th>平滑权重轮询</th>
</tr>
</thead>
<tbody>
<tr>
<td>🎯 分配策略</td>
<td>区间映射，简单直接</td>
<td>动态调整，智能平滑</td>
</tr>
<tr>
<td>⚡ 时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>💾 空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>🔒 线程安全</td>
<td>容易（原子计数器）</td>
<td>较复杂（需要同步状态）</td>
</tr>
<tr>
<td>📈 可扩展性</td>
<td>好</td>
<td>较好</td>
</tr>
</tbody>
</table>
<h3 id="33-适用场景分析-">3.3 适用场景分析 💡</h3>
<p><strong>非平滑权重轮询适用场景</strong>：</p>
<ul>
<li>🔧 服务器处理能力差异大，能承受突发负载</li>
<li>⏱️ 请求间隔较大，不需要考虑瞬时负载均衡</li>
<li>🎯 对实现简单性要求高的场景</li>
<li>📱 资源受限环境（内存占用少）</li>
</ul>
<p><strong>平滑权重轮询适用场景</strong>：</p>
<ul>
<li>🌐 需要均匀分配请求，避免服务器瞬时压力</li>
<li>⚖️ 服务器处理能力相近，需要精细负载均衡</li>
<li>🚀 对响应时间一致性要求高的场景</li>
<li>📊 长期运行的服务，需要稳定性能</li>
</ul>
<h2 id="四总结与展望-">四、总结与展望 🔭</h2>
<p>权重轮询算法是负载均衡领域的经典解决方案，两种变体各有其独特的价值和适用场景。</p>
<p><strong>非平滑权重轮询</strong>就像是一位实事求是的工程师，采用直接了当的解决方案：</p>
<ul>
<li>优点：实现简单、资源消耗少、容易理解</li>
<li>缺点：分配不够平滑、可能造成瞬时负载不均</li>
<li>适用：简单场景、资源受限环境、对平滑性要求不高</li>
</ul>
<p><strong>平滑权重轮询</strong>则像是一位深思熟虑的架构师，追求最优的整体效果：</p>
<ul>
<li>优点：分配平滑、负载均衡效果好、用户体验佳</li>
<li>缺点：实现稍复杂、需要维护额外状态</li>
<li>适用：高性能要求、对平滑性敏感、长期运行的系统</li>
</ul>
<p><strong>选择建议</strong>：</p>
<ul>
<li>如果系统规模小、请求间隔大，选择非平滑算法</li>
<li>如果系统规模大、请求频繁，选择平滑算法</li>
<li>也可以考虑混合策略，根据不同场景动态选择</li>
</ul>
<p><strong>未来发展方向</strong>：</p>
<ul>
<li>自适应权重调整：根据服务器实时负载动态调整权重</li>
<li>机器学习优化：使用预测模型优化分配策略</li>
<li>混合算法：结合多种负载均衡策略的优点</li>
</ul>
<p>记住：没有最好的算法，只有最适合的解决方案。理解每种算法的原理和特性，才能在实际应用中做出明智的选择。</p>
<hr>
<p><strong>附录：完整代码示例</strong>（见原始问题中的代码实现）</p>
<p><strong>温馨提示</strong>：理论是指导实践的基础，但实际应用中还需要考虑网络延迟、服务器健康状态、会话保持等现实因素。设计负载均衡系统时，建议进行充分的测试和性能分析！</p>
<p><strong>附录：完整代码示例</strong></p>
<pre><code class="language-java">package com.sun;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 非平滑加权轮询负载均衡算法实现
 * 这种算法按照权重比例分配请求，但分配不够平滑
 */
public class NonSmoothWeightedRoundRobin {

    // 服务器节点类
    public static class Server {
        private String name;
        private int weight;

        public Server(String name, int weight) {
            this.name = name;
            this.weight = weight;
        }

        public String getName() {
            return name;
        }

        public int getWeight() {
            return weight;
        }

        @Override
        public String toString() {
            return "Server{name='" + name + "', weight=" + weight + "}";
        }
    }

    private List&lt;Server&gt; servers; // 服务器列表
    private int totalWeight;      // 总权重
    private AtomicInteger currentIndex; // 当前索引

    public NonSmoothWeightedRoundRobin() {
        servers = new ArrayList&lt;&gt;();
        totalWeight = 0;
        currentIndex = new AtomicInteger(-1);
    }

    /**
     * 添加服务器
     * @param name 服务器名称
     * @param weight 服务器权重
     */
    public void addServer(String name, int weight) {
        if (weight &lt;= 0) {
            throw new IllegalArgumentException("权重必须大于0");
        }
        servers.add(new Server(name, weight));
        totalWeight += weight;
    }

    /**
     * 获取下一台服务器 - 非平滑加权轮询算法
     * 算法原理：
     * 1. 计算所有服务器的总权重
     * 2. 使用一个递增的计数器，对总权重取模
     * 3. 遍历服务器列表，用余数依次减去每个服务器的权重
     * 4. 当余数小于某个服务器的权重时，选择该服务器
     * @return 被选中的服务器
     */
    public Server getNextServer() {
        if (servers.isEmpty()) {
            throw new IllegalStateException("没有可用的服务器");
        }
        // 使用原子递增确保线程安全
        int index = currentIndex.updateAndGet(i -&gt; (i + 1) % totalWeight);
        // 遍历服务器列表，找到对应的服务器
        for (Server server : servers) {
            if (index &lt; server.getWeight()) {
                return server;
            }
            index -= server.getWeight();
        }
        // 正常情况下不会执行到这里
        return servers.get(0);
    }

    /**
     * 打印服务器列表和权重信息
     */
    public void printServerInfo() {
        System.out.println("服务器列表:");
        for (Server server : servers) {
            System.out.println("  " + server.getName() + " - 权重: " + server.getWeight());
        }
        System.out.println("总权重: " + totalWeight);
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建负载均衡器
        NonSmoothWeightedRoundRobin lb = new NonSmoothWeightedRoundRobin();
        // 添加服务器及其权重
        lb.addServer("ServerA", 5); // 50%的请求
        lb.addServer("ServerB", 3); // 30%的请求
        lb.addServer("ServerC", 2); // 20%的请求
        // 打印服务器信息
        lb.printServerInfo();
        // 模拟20次请求分配
        System.out.println("\n请求分配情况:");
        for (int i = 0; i &lt; 20; i++) {
            Server server = lb.getNextServer();
            System.out.println("请求 " + (i+1) + " 分配给: " + server.getName());
        }
        // 验证分配比例
        System.out.println("\n验证分配比例:");
        int[] count = new int[3]; // 统计每个服务器的请求次数
        for (int i = 0; i &lt; 10000; i++) {
            Server server = lb.getNextServer();
            if ("ServerA".equals(server.getName())) {
                count[0]++;
            } else if ("ServerB".equals(server.getName())) {
                count[1]++;
            } else if ("ServerC".equals(server.getName())) {
                count[2]++;
            }
        }

        System.out.println("ServerA: " + count[0] + " 次 (" + (count[0]/100.0) + "%)");
        System.out.println("ServerB: " + count[1] + " 次 (" + (count[1]/100.0) + "%)");
        System.out.println("ServerC: " + count[2] + " 次 (" + (count[2]/100.0) + "%)");
    }
}
</code></pre>
<pre><code>package com.sun;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 非平滑加权轮询负载均衡算法实现
 * 这种算法按照权重比例分配请求，但分配不够平滑
 */

public class SmoothWeightedRoundRobin {

    // 服务器节点类
    @Data
    public static class Server {
        private String name;
        private int weight;
        private int currentWeight;

        public Server(String name, int weight, int currentWeight) {
            this.name = name;
            this.weight = weight;
            this.currentWeight = currentWeight;
        }

    }

    private List&lt;Server&gt; servers; // 服务器列表
    private int totalWeight;      // 总权重
    private AtomicInteger currentIndex; // 当前索引

    public SmoothWeightedRoundRobin() {
        servers = new ArrayList&lt;&gt;();
        totalWeight = 0;
        currentIndex = new AtomicInteger(-1);
    }

    /**
     * 添加服务器
     *
     * @param name   服务器名称
     * @param weight 服务器权重
     */
    public void addServer(String name, int weight) {
        if (weight &lt;= 0) {
            throw new IllegalArgumentException("权重必须大于0");
        }
        servers.add(new Server(name, weight, 0));
        totalWeight += weight;
    }

    /**
     * 获取下一台服务器 - 平滑加权轮询算法
     * 算法原理：
         1、每个服务器有两个权重：固定权重(weight)和当前权重(current_weight)
         2、每次选择时，所有服务器的当前权重增加其固定权重
         3、选择当前权重最大的服务器
         4、被选中的服务器的当前权重减去总权重
         5、重复上述过程
     *
     * @return 被选中的服务器
     */
    public Server getNextServer() {
        if (servers.isEmpty()) {
            throw new IllegalStateException("没有可用的服务器");
        }

        for (Server server : servers) {
            server.setCurrentWeight(server.getCurrentWeight() + server.getWeight());
        }

        Server targetServer = null;
        // 遍历服务器列表，找到对应的服务器
        for (Server server : servers) {
            if (targetServer==null){
                targetServer=server;
                continue;
            }
            if (server.currentWeight &gt; targetServer.getCurrentWeight()) {
                targetServer = server;
            }
        }

        if (targetServer != null) {
            targetServer.currentWeight -= totalWeight;
            return targetServer;
        }

        // 正常情况下不会执行到这里
        return servers.get(0);
    }

    /**
     * 打印服务器列表和权重信息
     */
    public void printServerInfo() {
        System.out.println("服务器列表:");
        for (Server server : servers) {
            System.out.println("  " + server.getName() + " - 权重: " + server.getWeight());
        }
        System.out.println("总权重: " + totalWeight);
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建负载均衡器
        SmoothWeightedRoundRobin lb = new SmoothWeightedRoundRobin();

        // 添加服务器及其权重
        lb.addServer("ServerA", 5); // 50%的请求
        lb.addServer("ServerB", 3); // 30%的请求
        lb.addServer("ServerC", 2); // 20%的请求

        // 打印服务器信息
        lb.printServerInfo();

        // 模拟20次请求分配
        System.out.println("\n请求分配情况:");
        for (int i = 0; i &lt; 20; i++) {
            Server server = lb.getNextServer();
            System.out.println("请求 " + (i + 1) + " 分配给: " + server.getName());
        }

        // 验证分配比例
        System.out.println("\n验证分配比例:");
        int[] count = new int[3]; // 统计每个服务器的请求次数
        for (int i = 0; i &lt; 10000; i++) {
            Server server = lb.getNextServer();
            if ("ServerA".equals(server.getName())) {
                count[0]++;
            } else if ("ServerB".equals(server.getName())) {
                count[1]++;
            } else if ("ServerC".equals(server.getName())) {
                count[2]++;
            }
        }

        System.out.println("ServerA: " + count[0] + " 次 (" + (count[0] / 100.0) + "%)");
        System.out.println("ServerB: " + count[1] + " 次 (" + (count[1] / 100.0) + "%)");
        System.out.println("ServerC: " + count[2] + " 次 (" + (count[2] / 100.0) + "%)");
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.058333333333333334" data-date-updated="2025-08-28 18:15">2025-08-28 16:51</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">127</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19062599);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19062599', targetLink: 'https://www.cnblogs.com/sun-10387834/p/19062599', title: '深入解析权重轮询算法：非平滑与平滑实现的原理与数学依据' })">举报</a>
</div>
        