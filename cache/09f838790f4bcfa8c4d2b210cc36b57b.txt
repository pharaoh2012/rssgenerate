<!----> <meta itemprop="headline" content="如何处理复杂前端业务代码"> <meta itemprop="keywords" content="前端,架构"> <meta itemprop="datePublished" content="2025-01-04T05:44:53.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="yiludegeX"> <meta itemprop="url" content="https://juejin.cn/user/632960952313912"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-0faec0bc="">
            如何处理复杂前端业务代码
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-0faec0bc=""><div class="author-info-box" data-v-0faec0bc=""><div class="author-name" data-v-0faec0bc=""><a href="/user/632960952313912/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-0faec0bc=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    yiludegeX
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-0faec0bc=""><time datetime="2025-01-04T05:44:53.000Z" title="Sat Jan 04 2025 05:44:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-0faec0bc="">
                    2025-01-04
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-0faec0bc=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-0faec0bc=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-0faec0bc=""></circle></svg> <span class="views-count" data-v-0faec0bc="">
                    4,765
                  </span> <span class="read-time" data-v-0faec0bc=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-0faec0bc=""><rect width="16" height="16" fill="none" data-v-0faec0bc=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-0faec0bc=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-0faec0bc=""></path></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-0faec0bc=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-0faec0bc=""><div class="article-viewer markdown-body result"><blockquote>
<p>作为处理过vue单文件 1w+行的过来人总结</p>
</blockquote>
<p>    本文所指的业务代码，即大家理解的CRUD代码，没有技术难度却是日常写的最多的代码，虽然技术简单但随着业务复杂度不断上升如果没有做好设计和维护，经过多次迭代和人员的更替就会变成团队沉重的负担。本文探讨一种组织前端业务代码的方式，在复杂业务场景下，有效提升代码阅读和维护体验，保持业务开发的轻松流畅的体验。</p>
<h2 data-id="heading-0">一、&nbsp; 理解coding时间</h2>
<p>    这篇文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fieeexplore.ieee.org%2Fabstract%2Fdocument%2F7997917%2F" target="_blank" title="https://ieeexplore.ieee.org/abstract/document/7997917/" ref="nofollow noopener noreferrer">Measuring Program Comprehension: A Large-Scale Field Study with Professionals</a>调查了程序员写代码过程中时间花费情况。作者通过监测78名开发者在7个真实项目中花费的3148小时的程序理解活动时间来进行统计，并利用数据收集工具和视频录制工具对程序员花费的时间进行严格分类。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3af0b8cbc5042c2903b89a2b46081dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=e%2F8rQnT31i2TscJvm5Z5dJKgG7g%3D" alt="企业微信截图_7fd1803d-907b-4b50-981a-4abbe0521d8d.png" loading="lazy"></p>
<p>    作者将程序员写代码时间分了comprehension、navigation、editing、others这四类，并给出了这四类时间在不同样本中的分布：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/361f78db7b45447e8ad4d28d5171f25e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=eqcpyHmibdlSnmwy4TjskYcLntE%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    从结果上来看不同样本之间趋势是一致的，程序员在理解代码以及代码导航之间花去了超过80%的时间，这可能和我们体感不太一致但却是客观事实，项目的代码才是写代码最大的心智负担。简单的业务可能不需要这么长时间但是庞大的项目体量可能让这个时间达到90%以上。</p>
<h2 data-id="heading-1">二、&nbsp; 视图驱动逻辑</h2>
<p>    降低占据代码开发80%以上的理解导航时间对于项目维护至关重要，也是性价比最高的事情。那么我们的前端业务代码是如何变得难以理解的呢？</p>
<p>    很多开发会将数据的请求、逻辑的处理统一放置在组件中，数据和逻辑链条通过组件数层层传递，功能也是通过组件来进行组织，这样就形成了典型的视图驱动逻辑：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b287da7c0f94eac9f0ab53a3832f771~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=oZOYcF45WhRaO7sC98bOSjUs0XY%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    采取这种方式组织代码，不用怎么思考就可以快速进行功能开发，但是业务一复杂随之而来的就是维护成本飙升：</p>
<ol>
<li>
<p><strong>组件过于臃肿</strong>：数据的请求、数据的转换、数据的逻辑处理、全部堆在组件内部</p>
</li>
<li>
<p><strong>代码阅读困难</strong>：业务逻辑散落在各个组件中，需按照组件链条来理解业务</p>
</li>
<li>
<p><strong>通信复杂</strong>：组件层层嵌套，通信非常复杂，也难以理解</p>
</li>
<li>
<p><strong>定位困难</strong>：定位问题需要按照组件链条来排查，成本非常高</p>
</li>
<li>
<p><strong>无法复用</strong>：视图的差异性导致数据处理和业务逻辑无法复用</p>
</li>
<li>
<p><strong>重复请求</strong>：组件内部请求数据导致可以复用的数据难以复用</p>
</li>
<li>
<p><strong>复杂度高</strong>：数据流呈现螺旋网状调用，牵一发而动全身</p>
</li>
</ol>
<p>    总而言之，这种方法不但无法降低阅读导航时间，反而加重了这方面花费的时间，因为数据和逻辑被组件绑架了，无法从更高的维度分别进行抽象。</p>
<h2 data-id="heading-2">三、&nbsp; 数据驱动视图</h2>
<p>    如果认为前端状态是一系列数据和逻辑的总和，那么Url变化、DOM元素的操作、定时器、http请求等副作用导致状态在一直动态变化，界面其实是状态某一个时刻的切片。</p>
<p>    将状态直接放入界面中其实是本末倒置，将状态从视图层抽离，视图消费状态才符合上述理念。从这个角度来看必然需要有一个单独承载状态的层级。</p>
<p>    我们把数据请求放置在&nbsp;source&nbsp;层，把逻辑放置到&nbsp;logic&nbsp;层，视图拆分成&nbsp;view&nbsp;层和&nbsp;component&nbsp;层，这样就得到了下面的架构：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6abf1acca167457e9883d90ce9d2ac9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=RfGbJ%2F1cjQkQ%2BIxiC1lsw%2Be20z8%3D" alt="image.png" width="60%" loading="lazy"></p>
<p>    这种架构可以理解为数据驱动视图，目前仅仅是把原本包裹在组件中的请求和逻辑抽离出来，这样做可以降低阅读代码的心智负担吗？是的，仅仅是抽离出来并做适当的拆分就可以有效降低阅读代码的时间，但是我们还可以做的更好，我们可以将数据和逻辑抽象成模型。</p>
<h2 data-id="heading-3">四、&nbsp; 模型驱动视图</h2>
<p>    模型驱动相比数据驱动，更多的是将业务进行抽象，设计出更好的数据格式降低逻辑在前端页面流转时的阻碍。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51caaec81783424a9423afac960b8be4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=hTaxy0Qv4QsoZNPP3LjwWMgVEzo%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    通过后端&nbsp;API&nbsp;返回的数据可以理解为后端业务模型的返回，但是前端更多的是 for&nbsp;页面，后端业务模型和前端页面所需要的业务模型必然是不适配的，所以应该将前端数据和逻辑做更适合前端的业务抽象，也就是前端业务模型。</p>
<p>    从API获取的数据需要转换成前端业务模型，这个模型和页面是高度适配，数据的流转在前端将非常顺畅并没有太多数据层面的转换，需要发请求时再将前端业务模型的数据转换成API所需要的数据格式。</p>
<p>    早期 jQuery 操作 DOM 的时代时代，到响应式 MVVM&nbsp;框架、再到模型来驱动视图，开发思维将经历变更：事件驱动 -&gt; 数据驱动 -&gt; 模型驱动：</p>
<p>事件驱动：</p>
<pre><code class="hljs language-text" lang="text">    构建页面：设计DOM =&gt; 生成DOM =&gt; 绑定事件
    监听事件：操作UI =&gt; 触发事件 =&gt; 响应处理 =&gt; 更新UI
</code></pre>
<p>数据驱动：</p>
<pre><code class="hljs language-text" lang="text">    构建页面：设计数据结构 =&gt; 事件绑定逻辑 =&gt; 生成DOM
    监听事件：操作UI =&gt; 触发事件 =&gt; 响应处理 =&gt; 更新数据 =&gt; 更新UI
</code></pre>
<p>模型驱动：</p>
<pre><code class="hljs language-text" lang="text">    构建模型：设计模型的数据和方法
    构建页面：绑定模型的数据和方法 =&gt; 生成DOM
    监听事件：操作UI =&gt; 触发事件 =&gt; 响应处理 =&gt; 调用模型方法 =&gt; 更新UI
</code></pre>
<p>    模型是对数据的更高形式的抽象，可以采用 OOP 的思想来组织模型，也可以采用 DDD 的理念来实现模型，哪怕是技术简单的业务代码，如果采用模型思维也会迫使开发者开发业务代码从体力活动转变脑力活动。</p>
<h2 data-id="heading-4">五、&nbsp; 落地模型（vue版本）</h2>
<p>    在做简单业务的时候听到要用模型，会有一种杀鸡用牛刀的感觉，本能上会觉得很麻烦或者会增加工作量，但是随着业务不断迭代复杂，再想进行重构则容易积重难返，还面临高速换轮胎、无法说服上级等窘境。</p>
<p>    实际上落地模型既不麻烦也不会增加工总量，但业务的复杂度采用任何办法都不会降低，只能采用模块拆解的方式来隔离，本文不对将业务如何抽象成模型做进一步的探讨，更多的是说明如何拆解模型，如何组织模型。</p>
<p>    模型驱动视图只是改变开发思维，降低组织代码、阅读代码、维护代码的成本，下面我们就以&nbsp;vue&nbsp;框架为例来说明：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e956f72261a5439ba6199055d96a9048~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=a4FvqVbjHjg%2BZ9N7g5R9D0yDCDs%3D" alt="image.png" width="70%" loading="lazy"></p>
<h4 data-id="heading-5">逻辑层</h4>
<p>    采用vue框架毫无疑问模型需要落地到 pinia store里面，得益于 react hook思想，我们得以采用&nbsp;composition&nbsp;的方式来组织&nbsp;store：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>;
    <span class="hljs-keyword">import</span> { useProjectStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'xxxx'</span>;

    <span class="hljs-keyword">const</span> useAppStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'app'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 1、定义 store 的依赖关系</span>
    <span class="hljs-keyword">const</span> projectStore = <span class="hljs-title function_">useProjectStore</span>()

    <span class="hljs-comment">// 2、定义 service 的依赖关系</span>
    <span class="hljs-keyword">const</span> aService = <span class="hljs-title function_">useAService</span>(projectStore.<span class="hljs-property">xService</span>)
    <span class="hljs-keyword">const</span> bService = <span class="hljs-title function_">useBService</span>(aService)
    <span class="hljs-keyword">const</span> cService = <span class="hljs-title function_">useCService</span>(bService)

    <span class="hljs-keyword">return</span> { aService, bService, cService }
    })
</code></pre>
<p>    我们会将业务拆解成多个&nbsp;store，再将每个 store 拆成多个&nbsp;service，每个&nbsp;service&nbsp;的功能是高内聚的。可以理解 store&nbsp;是一个壳，内部service&nbsp;才是负责实现功能内聚的模型，注意在&nbsp;store&nbsp;中只能干两件事情：</p>
<ol>
<li>定义 store 和&nbsp;store 之间的依赖关系</li>
<li>定义 service 和 service 之间的依赖关系</li>
</ol>
<p>    如果逻辑是一本书，那么store的定义就是目录，具体的业务实现都放在&nbsp;service，这个很重要！！！，可以有效的降低阅读定位代码的时间。随着业务复杂度提升，store 也会越来越多和庞大，store 占据浏览器的内存也会不断增多，store也可以提供destroy 方法，页面可以根据策略进行销毁。</p>
<p>    service&nbsp;可以采用正常书写&nbsp;composition&nbsp;来设计模型即可，模型无非是由一系列数据和修改数据的方法构成，以&nbsp;aService&nbsp;为例：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useAService (xService) {
      <span class="hljs-keyword">const</span> data1 = <span class="hljs-title function_">ref</span>()

      <span class="hljs-keyword">const</span> data2 = <span class="hljs-title function_">ref</span>()
      <span class="hljs-keyword">const</span> data2Loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
      <span class="hljs-keyword">const</span> data2Error = <span class="hljs-title function_">ref</span>()

      <span class="hljs-keyword">const</span> handleData1 = (arg) {
          data1.<span class="hljs-property">value</span> = arg
          <span class="hljs-title function_">fetchData2</span>()
      }
      
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData2</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
            data2Loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">try</span>{
                data2.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, {<span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title class_">String</span>(data1.<span class="hljs-property">value</span>)}) 
                data2Loading = <span class="hljs-literal">false</span>
            }<span class="hljs-keyword">catch</span>(e){
                data2Error.<span class="hljs-property">value</span> = e.<span class="hljs-property">message</span>
                data2Loading = <span class="hljs-literal">false</span>
            }  
     }
     <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>({data1, data2, data2Loading, data2Error, handleData1, fetchData2 })
</code></pre>
<p>    其中经常会出现数据之间的异步依赖关系，例如 data2 异步依赖于 data1，data1 发生变化需要更新 data2，为此如果采用命令式的方式来写代码会暴露大量细节造成阅读困难，而模型本身并不关心这些细节，并且还会污染到模型其他地方比如：</p>
<p>    handleData1 明明是处理 data1 相关的逻辑，就是因为 data2 依赖了 data1 就需要将 fetchData2 也放进来 ，后续还有地方改到 data1 则都需要调用 fetchData2 。</p>
<h5 data-id="heading-6">异步数据依赖关系维护</h5>
<p>    既然采用命令式方式编写异步数据依赖关系，往往会大大降低代码的可读性并且污染模型代码，而且项目已经采用&nbsp;vue&nbsp;响应式，不妨将声明式+响应式结合起来：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">import</span> { useFetch } <span class="hljs-keyword">from</span> <span class="hljs-string">'fluth-vue'</span>

    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useAService (xService) {
      <span class="hljs-keyword">const</span> data1 = <span class="hljs-title function_">ref</span>()
      <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: data2, <span class="hljs-attr">loading</span>: data2Loading, <span class="hljs-attr">error</span>: data2Error， <span class="hljs-attr">promise$</span>: fetchData2$ } =  <span class="hljs-title function_">useFetch</span>(url, {<span class="hljs-attr">refetch</span>: <span class="hljs-literal">true</span>}).<span class="hljs-title function_">post</span>(data1)
     
      <span class="hljs-keyword">const</span> handleData1 = (arg) {
        data1.<span class="hljs-property">value</span> = arg
      }
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>({ data1, data2, data2Loading, data2Error, handleData1, fetchData2$ })
     }
</code></pre>
<p>    采用 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffluthjs.github.io%2Ffluth-vue%2Fcn%2Findex.html" title="https://fluthjs.github.io/fluth-vue/cn/index.html" target="_blank" ref="nofollow noopener noreferrer">fluth-vue&nbsp;</a>的usefetch，一行语句就声明了 data2 和 data1的异步关系，极大的降低了代码复杂度和污染，至于出现的fetchData2$&nbsp;有何妙用，下面就可以用到。</p>
<h5 data-id="heading-7">异步逻辑依赖关系维护</h5>
<p>    bService&nbsp;如果依赖 aService&nbsp;的异步数据 data2，我们经常会采用监听数据的方式来处理这种逻辑，这叫利用数据的响应式来组织逻辑，是一种阅读体验非常差的编码方式：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useBService (aService) {
      <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>()
      
      <span class="hljs-title function_">watch</span>(aservice.<span class="hljs-property">data2</span>), <span class="hljs-function">() =&gt;</span> {
          data.<span class="hljs-property">value</span> = <span class="hljs-title function_">formart</span>(aservice.<span class="hljs-property">data2</span>)
      })
    }
</code></pre>
<p>    利用数据的响应式来组织逻辑，这会带来两个问题：</p>
<ol>
<li>丢失语义，监听数据是没有语义的，阅读的逻辑链条在这里断裂</li>
<li>时序控制困难，尤其是当依赖多个数据且这些数据存在时序依赖关系时，那么采用监听方式非常难控制时序</li>
</ol>
<p>    此时采用 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffluthjs.github.io%2Ffluth-vue%2Fcn%2Findex.html" title="https://fluthjs.github.io/fluth-vue/cn/index.html" target="_blank" ref="nofollow noopener noreferrer">fluth-vue</a>&nbsp;在 useFetch提供的 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffluthjs.github.io%2Ffluth-vue%2Fcn%2FuseFetch%2Fstream.html" target="_blank" title="https://fluthjs.github.io/fluth-vue/cn/useFetch/stream.html" ref="nofollow noopener noreferrer">promise$流</a></p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useBService (aService) {
      <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>()
      
      aService.<span class="hljs-property">fetchData2$</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
          data.<span class="hljs-property">value</span> = <span class="hljs-title function_">formart</span>(aservice.<span class="hljs-property">data2</span>)
      }) 
    }
</code></pre>
<p>    如果通过数据响应式来组织异步逻辑，则逻辑就像一个三维网状结构；通过流来处理异步逻辑就像一条管道，任何一个节点都可以知道上游节点在哪里，什么语义。</p>
<p>    这里我们知道 fetchData2$&nbsp;之后需要处理&nbsp;bService&nbsp;的&nbsp;data&nbsp;数据，至于数据是否需要从流中传递过来，这已经不重要了，因为整个 aService 已经注入进来，虽然新的数据也可以从管道获取。</p>
<h4 data-id="heading-8">数据层</h4>
<p>    随着异步数据依赖关系越来越复杂，我们除了自动响应式请求，还有自动&nbsp;intervel&nbsp;更新、缓存、条件、重试、防抖、节流等方面的需求，定义在 aService 的 useFetch则会变得越来越庞大：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: data2, <span class="hljs-attr">loading</span>: data2Loading, <span class="hljs-attr">error</span>: data2Error， <span class="hljs-attr">promise$</span>: fetchData2$ } = <span class="hljs-title function_">useFetch</span>(url,   {
         <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,
         <span class="hljs-attr">condition</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> data1.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt; <span class="hljs-number">18</span>),
         <span class="hljs-attr">refetch</span>: <span class="hljs-literal">true</span>, 
         <span class="hljs-attr">refresh</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>, 
         <span class="hljs-attr">retry</span>: <span class="hljs-number">3</span>,
         <span class="hljs-attr">debounce</span>: <span class="hljs-number">1000</span>,
         <span class="hljs-attr">throttle</span>: <span class="hljs-number">1000</span>,
         <span class="hljs-attr">cacheSetting</span>: {
            <span class="hljs-attr">expiration</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,
            <span class="hljs-attr">cacheResolve</span>: <span class="hljs-function">(<span class="hljs-params">{ url, payload }</span>) =&gt;</span> url + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload.<span class="hljs-property">value</span>),
      }
    }).<span class="hljs-title function_">post</span>(data1);
</code></pre>
<p>    此时适合封装成到source层：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">import</span> { useFetch } <span class="hljs-keyword">from</span> <span class="hljs-string">'fluth-vue'</span>

    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useFetchData2Api</span> = (<span class="hljs-params">data1: Ref&lt;{xxx}&gt;</span>) =&gt; 
     <span class="hljs-title function_">useFetch</span>(url, {
          <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">condition</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> data1.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt; <span class="hljs-number">18</span>),
          <span class="hljs-attr">refetch</span>: <span class="hljs-literal">true</span>, 
          <span class="hljs-attr">refresh</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>, 
          <span class="hljs-attr">retry</span>: <span class="hljs-number">3</span>,
          <span class="hljs-attr">debounce</span>: <span class="hljs-number">1000</span>,
          <span class="hljs-attr">throttle</span>: <span class="hljs-number">1000</span>,
          <span class="hljs-attr">cacheSetting</span>: {
              <span class="hljs-attr">expiration</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,
              <span class="hljs-attr">cacheResolve</span>: <span class="hljs-function">(<span class="hljs-params">{ url, payload }</span>) =&gt;</span> url + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload.<span class="hljs-property">value</span>),
          }
    }).<span class="hljs-title function_">post</span>(data1);
</code></pre>
<p>    那么在&nbsp;aService&nbsp;声明异步数据&nbsp;data2&nbsp;和&nbsp;data1&nbsp;的关系就非常简单：</p>
<pre><code class="hljs language-ts" lang="ts">    <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: data2, <span class="hljs-attr">loading</span>: data2Loading, <span class="hljs-attr">error</span>: data2Error， <span class="hljs-attr">promise$</span>: fetchData2$ } = <span class="hljs-title function_">useFetchData2Api</span>(data1)
</code></pre>
<p>    service模型层彻底干净清晰，而source层慢慢的就会如下所示：</p>
<pre><code class="hljs language-text" lang="text">    api
    ├── index.ts
    ├── useaaaaApi
    │   ├── type.ts
    │   └── index.ts
    ├── usebbbApi
    │   ├── type.ts
    │   └── index.ts
    └── useeeeApi
        ├── type.ts
        └── index.ts
</code></pre>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>    数据层定义了从 API 传递过来的数据模型(type.ts)，以及各个异步数据之间的声明式关系（例如：data1 和 data2）。根据业务情况，在数据层中我们还可以做一些统一的处理：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b080427ecac48119303ff0da415d20e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=IuVwufISjHphmsklDg9ydZ5wTns%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    这部分处理可以根据项目实际情况来添加，总而言之，数据层提供了两个重要的基础能力：</p>
<ol>
<li>规范了 API 层的数据 typescript 类型定义</li>
<li>声明了异步数据之间的关系是怎么样的</li>
</ol>
<h4 data-id="heading-9">视图层</h4>
<p>    由于逻辑都在store 和 service 里面，view&nbsp;原则上不保留业务逻辑的数据，只消费模型数据、调用模型方法、以及视图逻辑数据（比如打开关闭之类的），还有一类可以保存的数据就是模型数据的派生，从模型数据 computed 出一份自己消费，但也不建议做过多逻辑，逻辑统一由模型来处理。</p>
<p>    这使得整个view层变得非常简洁，无需复杂的 props 数据传递、也没有上蹿下跳的 emit，直接内部通过 store 的 service来获取数据。在&nbsp;view&nbsp;层的任意组件原则上都可以直接从 store 中获取模型数据、调用模型方法。而阅读 View层代码，就可以直接定位页面涉及到的store、service 以及相应的所有模块依赖和逻辑链条。</p>
<p>    建议采用&nbsp;.tsx&nbsp;的方式来组织&nbsp;view&nbsp;的代码，可以带来两个好处：</p>
<ol>
<li>更加灵活的模板</li>
<li>由于 vue devtool 无法查看组件状态（setup return render()），倒逼开发者使用模型来处理逻辑（vue devtool pinia 可查看状态）</li>
</ol>
<h4 data-id="heading-10">组件层</h4>
<p>    组件层主要封装的是没有业务属性的组件，不能从也不应该从 store 直接获取数据，只能通过 props 接收 view 传递的数据。</p>
<h2 data-id="heading-11">六、&nbsp; 是否有效果？</h2>
<p>    我们可以从一个新维护者的角度来看：</p>
<h4 data-id="heading-12">新需求</h4>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/224fea7f52434628944fdbcf33238c70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=my0NUl%2FCaUD9%2F5%2Bu9IF5Q6DaqSE%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    拿到需求，定位涉及到的页面，定位到涉及到的&nbsp;store、service，并通过前面介绍的流可以定位整个上下游逻辑链条以及涉及到的数据模型有哪些，所有的时间加起来不会超过5分钟。</p>
<h4 data-id="heading-13">解bug</h4>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d172c776e96749c696cf1d34ca70ef2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=5M7bmEOuJ1l6K19mo7vMpI27M28%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    同样按照上面的思路，这个&nbsp;bug&nbsp;几乎可以在5分钟内定位整个上下游逻辑链条以及涉及到的数据模型有哪些，通过 vue devtool 可以直接查看 pinia 中模型的数据，几乎不用排查&nbsp;vue 组件链条</p>
<h4 data-id="heading-14">维护成本</h4>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b664c135432b4fdc8aeb1e9997c1a78e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeWlsdWRlZ2VY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1743497730&amp;x-signature=EWH9unPq%2F0Y19%2BwtC4alYEppq60%3D" alt="image.png" width="70%" loading="lazy"></p>
<p>    业务的复杂度可能会上升，组织代码的复杂度维持不变，5分钟原则依然不变可以有效的降低理解代码、定位代码的时间。采用这种方式，会逼迫开发者不断完善模型、抽象业务，阻止视图层对逻辑的侵入，从而有效降低代码腐化速度。</p>
<h2 data-id="heading-15">七、&nbsp; 总结</h2>
<p>    通过模型驱动视图的理念，用 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffluthjs.github.io%2Ffluth-vue%2Fcn%2FuseFetch%2Fintroduce.html" title="https://fluthjs.github.io/fluth-vue/cn/useFetch/introduce.html" target="_blank" ref="nofollow noopener noreferrer">声明式+响应式</a> 来组织异步数据依赖，用<a href="https://link.juejin.cn?target=https%3A%2F%2Ffluthjs.github.io%2Ffluth-doc%2Fcn%2Findex.html" title="https://fluthjs.github.io/fluth-doc/cn/index.html" target="_blank" ref="nofollow noopener noreferrer">&nbsp;promise 流</a>&nbsp;流来组织异步逻辑依赖，这种组织代码的形式能够明显的降低开发者在降低阅读代码、定位代码的时间，降低代码腐化速度，在一些轻交互、重逻辑的场景（比如：管理端、sass等）具有良好的效果。最后代码呈现出类似 angular service + vue reactive + react tsx 的组织效果。</p>
<p>最后广告，欢迎点⭐️</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffluthjs%2Ffluth" target="_blank" title="https://github.com/fluthjs/fluth" ref="nofollow noopener noreferrer">github.com/fluthjs/flu…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffluthjs%2Ffluth-vue" target="_blank" title="https://github.com/fluthjs/fluth-vue" ref="nofollow noopener noreferrer">github.com/fluthjs/flu…</a></p></div></div>