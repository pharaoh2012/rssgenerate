
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18931813" title="发布于 2025-06-17 19:58">
    <span role="heading" aria-level="2">[计算机组成原理/Java] 字符集编码: Unicode 字符集(UTF8/UTF16/UTF32) 和 `BOM`(Byte Order Mark/字节序标记) / UnicodeTextUtils</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="序">序</h1>
<ul>
<li>最近解析 以太网 SOME/IP 报文时，涉及到解析数据类型为 String(标准的Unicode字符集编码的文本序列，且细分为 动态 String [存在 32 bit 的 StringFieldLength] 和 静态 String ) 的场景。</li>
</ul>
<blockquote>
<p>尤其是 Struct 嵌套 String 时，还涉及到 CPU 的内存对齐(alignment)问题。</p>
</blockquote>
<ul>
<li>言归正传，本文对 Unicode 字符集 做个总结。</li>
<li>不想看 Unicode 不同细分字符集的原理的，可直接跳过 【Unicode字符集原理剖析】章节</li>
<li>不了解【<strong>大小端/字节序</strong>(<code>Endian</code>)】的朋友，可参考阅读此篇：</li>
</ul>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18921308" target="_blank">[网络传输/序列化/CPU/内存/计算机组成原理] 字节序/大小端 - 博客园/千千寰宇</a></li>
</ul>
</blockquote>
<ul>
<li>关于 Unicode 字符集 与 BOM 的原理、技术实现/代码实现的帖子，全网比较缺乏。</li>
</ul>
<blockquote>
<p>此篇应该是最详实且务实的一篇。</p>
</blockquote>
<h1 id="概述-unicode字符集">概述： Unicode字符集</h1>
<h2 id="unicode-字符集的-bom--byte-order-mark--字符顺序标记">Unicode 字符集的 BOM := Byte Order Mark := 字符顺序标记</h2>
<ul>
<li><code>BOM</code>（Byte Order Mark）在分析<code>unicode</code>之前，先把<code>bom</code>(byte order mark)说一下。</li>
</ul>
<blockquote>
<p><code>bom</code>是<code>unicode</code><strong>字符顺序的标识符号</strong>，一般以<strong>魔数</strong>(<code>magic code</code>)的形式出现在以<code>Unicode</code>字符编码的文件的开始的头部，作为该文件的编码标识。</p>
</blockquote>
<ul>
<li>举个很简单的例子:</li>
</ul>
<blockquote>
<p>在 windows 下新建一个文本文件，并另存为 utf8 的文件格式。<br>
该文件里面没有任何内容，我们再用<code>Hex Edit</code>来查看该文件的二进制内容：</p>
</blockquote>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250616205345092-1283192683.png" class="lazyload"></p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250616205451431-1647625326.png" class="lazyload"></p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250617201222901-1599536381.png" class="lazyload"></p>
<blockquote>
<p>UTF-8</p>
</blockquote>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250616205822918-2114867698.png" class="lazyload"></p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1173617/202506/1173617-20250617201748607-1596416830.png" class="lazyload"></p>
<blockquote>
<p>UTF-8 with BOM</p>
</blockquote>
<blockquote>
<p><code>0xEF BB BF</code>就是这个文件的<code>bom</code>, 这也就是标识该文件是以<code>utf8</code>为编码格式的。</p>
</blockquote>
<h2 id="带-bom-的-unicode-文本-vs-不带-bom-的-unicode-文本">带 BOM 的 Unicode 文本 vs. 不带 BOM 的 Unicode 文本</h2>
<ul>
<li><code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code> 还区分带 <code>BOM</code> 的以及不带 <code>BOM</code> 的 Unicode 文本。</li>
<li><code>BOM</code> 的全称为 <code>byte-order mark</code>，即<strong>字节顺序标记</strong>，它是插入到以UTF-8、UTF16或UTF-32编码Unicode文件开头的特殊标记。</li>
</ul>
<blockquote>
<p>这些标记对于 UTF-8 来说<strong>并不是必须的</strong>。所以，我们们可以将带有 <code>BOM</code> 的 <code>UTF-8</code> 转换为 <code>UTF-8</code>。</p>
</blockquote>
<h2 id="unicode-字符集-bom的对应关系">Unicode 字符集 BOM的对应关系</h2>
<blockquote>
<p>下面来看看字符编码与其<code>bom</code>的对应关系</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符编码</th>
<th>Bom (十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTF-8</td>
<td>EF BB BF</td>
</tr>
<tr>
<td>UTF-16 (BE) 大端</td>
<td>FE FF</td>
</tr>
<tr>
<td>UTF-16 (LE) 小端</td>
<td>FF FE</td>
</tr>
<tr>
<td>UTF-32 (BE) 大端</td>
<td>00 00 FE FF</td>
</tr>
<tr>
<td>UTF-32 (LE) 小端</td>
<td>FF FE 00 00</td>
</tr>
<tr>
<td>GB-18030</td>
<td>84 31 95 33</td>
</tr>
</tbody>
</table>
<h2 id="unicode字符集原理剖析">Unicode字符集原理剖析</h2>
<h3 id="utf-8编码剖析">UTF-8编码剖析</h3>
<ul>
<li><code>Unicode</code>编码以<code>code point</code>来标识每一个字符， <code>code point</code> 的范围是<br>
<code>0x000000 – 0x10FFFF</code></li>
</ul>
<blockquote>
<p>也就是每一个字符的code point都落在这个范围<br>
而<code>utf8</code>的<strong>一个字符</strong>可以用<code>1-4</code>字节来表示，可能有人会说这code point最大也就是0x10FFFF，为什么最大不是可以用三个字节表示呢？那是因为utf8有自己独特的表示格式，先来看看下面的对应关系:</p>
</blockquote>
<table>
<thead>
<tr>
<th>字节数</th>
<th>字符code point位数</th>
<th>最小的code point</th>
<th>最大的code point</th>
<th>第一个字节</th>
<th>第二个字节</th>
<th>第三个字节</th>
<th>第四个字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>U+0000</td>
<td>U+007F</td>
<td>0XXXXXXX</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>U+0080</td>
<td>U+07FF</td>
<td>110XXXXX</td>
<td>10XXXXXX</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>3</td>
<td>16</td>
<td>U+0800</td>
<td>U+FFFF</td>
<td>1110XXXX</td>
<td>10XXXXXX</td>
<td>10XXXXXX</td>
<td>无</td>
</tr>
<tr>
<td>4</td>
<td>21</td>
<td>U+10000</td>
<td>U+10FFFF</td>
<td>11110XXX</td>
<td>10XXXXXX</td>
<td>10XXXXXX</td>
<td>10XXXXXX</td>
</tr>
</tbody>
</table>
<ul>
<li>当某个字符的code point (cp简称) U+0000 &lt;= cp &lt;= U+007F 落在这个范围内</li>
</ul>
<blockquote>
<p>这时只需要一个字节来表示 0XXXXXXX，将该字符的code point （7位）填入X的位置，就可以得到该字符的utf8的编码后的格式了。<br>
我们以小写字母a举个例子，a的code point是01100001, 经过utf8编码后 <code>01100001(0x61)</code></p>
</blockquote>
<ul>
<li>例如，中文汉字 <code>加</code> code point 为 <code>0x52A0</code> 二进制格式 ‭<code>0101 0010 1010 0000</code></li>
</ul>
<blockquote>
<p>按照上表中的规则，该字符需要用3个字节来表示<br>
按照<strong>填充规则</strong> ，第一个字节 <code>1110XXXX</code> -&gt; <code>11100101</code> , 第二个字节10XXXXXX -&gt; 10001010 , 第三个字节10XXXXXX -&gt; 10100000</p>
<blockquote>
<p>组合起来就是 <code>11100101 10001010 10100000</code> := <code>‭HEX-&gt; 0xE58AA0‬</code></p>
</blockquote>
</blockquote>
<h3 id="utf-16编码剖析">UTF-16编码剖析</h3>
<ul>
<li><code>utf-16</code>编码的单元是2个字节，也就是16位。</li>
</ul>
<blockquote>
<p>utf-16编码格式在程序内存里经常使用，因为它比较高效,<br>
java中Character 字符用的就是utf-16编码格式<br>
在早期的时候，世界上所有的字符都可以用两个字节标识，也就是code point范围 U+0000 – U+FFFF，这样utf-16就可以很好的表示了，而且也不用像utf8那样按照固定的模板组合，可以直接用字符的code point表示，非常高效。</p>
</blockquote>
<blockquote>
<p>但是随着时间的推移，所有字符远远不能用两个字节的code point 表示了，那为了兼容code point 超过U+FFFF的字符 就出现字符代理对(Surrogate pair), utf16就是使用代理对来表示code point 范围在 U+10000 -&gt; U+10FFFF之间的字符，当然也就的使用四个字节来表示该字符了。<br>
对于Surrogate pair 与code point 之间的对应关系算法，等会儿再说。<br>
先来看下utf16对于code point 小与U+10000的字符表示，其实用的就是字符的code point表示，这里还区分了大小端的表示法。</p>
</blockquote>
<ul>
<li>案例</li>
</ul>
<blockquote>
<p>还是来看中文汉字 <code>加</code> code point 为 <code>0x52A0</code>， 推测一下:<br>
如果用utf16大端存储，那就是<code>0x52A0</code>;<br>
如果用utf16小端存储，那就是<code>0xA052</code></p>
</blockquote>
<h3 id="utf-32编码剖析">UTF-32编码剖析</h3>
<ul>
<li><code>utf-32</code>用4个字节表示<strong>一个字符</strong></li>
</ul>
<blockquote>
<ul>
<li>直接用字符的<code>code point</code>表示，非常高效，不需要任何的转化操作</li>
<li>但<strong>占用的存储空间</strong>却是很大的，会有空间的浪费。</li>
</ul>
</blockquote>
<ul>
<li>例如：小写字母<code>a</code></li>
</ul>
<blockquote>
<p><code>code point</code> 是 <code>0x61</code><br>
用<code>utf32</code>表示就是<strong>大端</strong> -&gt; <code>0x00 00 00 61</code> ; <strong>小端</strong> -&gt; <code>0x61 00 00 00</code><br>
这样会造成<strong>存储空间</strong>的浪费，当然应用场景不同而已，当追求高效的转换而忽略存储空间的浪费这个问题，utf32编码格式是比较好的选择。<br>
而utf8的原则是尽可能的节省存储空间，牺牲转化的效率，各有各的好处。</p>
</blockquote>
<h2 id="判别unicode文本的字符集的方法java-废弃不可靠">判别Unicode文本的字符集的方法(Java) 【废弃/不可靠】</h2>
<blockquote>
<p>亲测，此方法并可绝对可靠（尤其是结果为 UTF-8 的情况）。</p>
</blockquote>
<pre><code class="language-java">    /**
     * 获取 Unicode 文本的字符集
     * @param textBytes
     * @return
     */
    public static Charset getUnicodeTextCharset(byte[] textBytes){
        String encoding = null;
        int bomSize = 4;//BOM_SIZE;
        byte bom[] = new byte[bomSize];
        int n, unread;
        //n = internalIn.read(bom, 0, bom.length);

        //读取 bom
        int off = 0;
        int len = bom.length;
        int pos = 0;

        if (bom == null) {
            throw new NullPointerException();
        } else if (off &lt; 0 || len &lt; 0 || len &gt; bom.length - off) {
            throw new IndexOutOfBoundsException();
        }
        int avail = bom.length &lt;= textBytes.length ? bom.length : textBytes.length ;//算 bom.length 与 textBytes.length 的最小值
        if (avail &gt; 0) {
            System.arraycopy(textBytes, pos, bom, off, avail);
        }

        //判断 unicode 字符集
        if ((bom[0] == (byte) 0x00) &amp;&amp; (bom[1] == (byte) 0x00)
                &amp;&amp; (bom[2] == (byte) 0xFE) &amp;&amp; (bom[3] == (byte) 0xFF)) {
            encoding = "UTF-32BE";
            //unread = n - 4;
        } else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)
                &amp;&amp; (bom[2] == (byte) 0x00) &amp;&amp; (bom[3] == (byte) 0x00)) {
            encoding = "UTF-32LE";
            //unread = n - 4;
        } else if ((bom[0] == (byte) 0xEF) &amp;&amp; (bom[1] == (byte) 0xBB)
                &amp;&amp; (bom[2] == (byte) 0xBF)) {
            encoding = "UTF-8";//utf08 with bom
            //unread = n - 3;
        } else if ((bom[0] == (byte) 0xFE) &amp;&amp; (bom[1] == (byte) 0xFF)) {
            encoding = "UTF-16BE";
            //unread = n - 2;
        } else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)) {
            encoding = "UTF-16LE";
            //unread = n - 2;
        } else {
            // Unicode BOM mark not found, unread all bytes
            //defaultEncoding = defaultEncoding == null ? Charset.defaultCharset().name() : defaultEncoding;
            //defaultEncoding = defaultEncoding == null ? null : defaultEncoding;
            //encoding = defaultEncoding;
            //unread = n;
            encoding = "UTF-8";//默认: UTF-8 (without bom)
        }
        // System.out.println("read=" + n + ", unread=" + unread);
        return Charset.forName(encoding);
    }
</code></pre>
<h1 id="最佳实践">最佳实践</h1>
<h2 id="unicodetextutils--unicode文本处理工具类">UnicodeTextUtils : Unicode文本处理工具类</h2>
<h3 id="unicodecharsetenum">UnicodeCharsetEnum</h3>
<pre><code class="language-java">import com.xxx.sdk.pojo.text.enums.DigitalModeEnum;

/**
 * Unicode 字符集
 * @updateTime 2025.6.17 19:48
 */
public enum UnicodeCharsetEnum {
    UTF8_WITH_BOM("UTF8_WITH_BOM", "UTF-8 With BOM", "UTF-8"),
    UTF8_WITHOUT_BOM("UTF8_WITHOUT_BOM", "UTF-8 Without BOM", "UTF-8"),

    //小端
    UTF16LE_WITH_BOM("UTF16LE_WITH_BOM", "UTF-16LE With BOM", "UTF-16LE"),
    UTF16LE_WITHOUT_BOM("UTF16LE_WITHOUT_BOM", "UTF-16LE Without BOM", "UTF-16LE"),

    //大端
    UTF16BE_WITH_BOM("UTF16BE_WITH_BOM", "UTF-16BE With BOM", "UTF-16BE"),
    UTF16BE_WITHOUT_BOM("UTF16BE_WITHOUT_BOM", "UTF-16BE Without BOM", "UTF-16BE"),

    //小端
    UTF32LE_WITH_BOM("UTF32LE_WITH_BOM", "UTF-32LE With BOM",  "UTF-32LE"),
    UTF32LE_WITHOUT_BOM("UTF32LE_WITHOUT_BOM", "UTF-32LE Without BOM",  "UTF-32LE"),

    //大端
    UTF32BE_WITH_BOM("UTF32BE_WITH_BOM", "UTF-32BE With BOM", "UTF-32BE"),
    UTF32BE_WITHOUT_BOM("UTF32BE_WITHOUT_BOM", "UTF-32BE Without BOM", "UTF-32BE");

    private final String charsetCode;
    private final String charsetName;
    //java中定义的字符集
    private final String javaCharset;


    public final static String CODE_PARAM = "code";
    public final static String NAME_PARAM = "name";

    UnicodeCharsetEnum(String charsetCode, String charsetName, String javaCharset) {
        this.charsetCode = charsetCode;
        this.charsetName = charsetName;
        this.javaCharset = javaCharset;
    }

    public static UnicodeCharsetEnum findByCharsetCode(String charsetCode) {
        for (UnicodeCharsetEnum type : values()) {
            if (type.getCharsetCode().equals(charsetCode)) {
                return type;
            }
        }
        return null;
    }

    public static UnicodeCharsetEnum findByCharsetName(String charsetName) {
        for (UnicodeCharsetEnum type : values()) {
            if (type.getCharsetName().equals(charsetName)) {
                return type;
            }
        }
        return null;
    }


    public String getCharsetName() {
        return charsetName;
    }

    public String getCharsetCode() {
        return charsetCode;
    }

    public String getJavaCharset() {
        return javaCharset;
    }
}
</code></pre>
<h3 id="unicodetextutils">UnicodeTextUtils</h3>
<pre><code class="language-java">import com.xxx.sdk.pojo.text.UnicodeCharsetEnum;

import java.io.UnsupportedEncodingException;

/**
 * Unicode 文本处理工具类
 * @updateTime 2025.6.17 19:47
 */
public class UnicodeTextUtils {
    /**
     * 将指定文本转换为指定 Unicode 字符集的字节数组
     * @param text Java 字符串
     *     eg: "hello world!你好!"
     * @param unicodeCharset
     *     eg: UTF8_WITH_BOM
     * @return 指定 Unicode 字符集的字节数组
     * @usage String newText = new String( textToBytes(text="hello world!你好!", UTF8_WITH_BOM) ,  UTF8_WITH_BOM.charset)
     */
    public static byte [] textToBytes(String text, UnicodeCharsetEnum unicodeCharset) throws UnsupportedEncodingException {
        byte [] textBytes = null;
        switch (unicodeCharset) {
            // UTF8 不涉及 字节序(大小端)问题 (每个文本字符的最小单元: 1 byte)
            case UTF8_WITH_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-8"
                int bomLength = 3;
                byte [] textBytes2 = new byte [textBytes1.length + bomLength];//预留 3个字节，填充 bom
                System.arraycopy(textBytes1, 00, textBytes2, 0 + bomLength, textBytes1.length);
                textBytes2[0] = (byte)0xef;
                textBytes2[1] = (byte)0xbb;
                textBytes2[2] = (byte)0xbf;

                //text == newText == "hello world!你好!", newText == [ (byte)0xef, (byte)0xbb, (byte)0xbf, 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, -28, -67, -96, -27, -91, -67, 33 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes2;
                break;
            }
            case UTF8_WITHOUT_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-8"

                //text == newText == "hello world!你好!", newText == [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, -28, -67, -96, -27, -91, -67, 33 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes1;
                break;
            }

            //UTF16 设计 字节序(大小端)问题 (每个文本字符的最小单元: 2 byte)
            case UTF16LE_WITH_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-16LE"
                int bomLength = 2;
                byte [] textBytes2 = new byte [textBytes1.length + bomLength];//预留 2个字节，填充 bom
                System.arraycopy(textBytes1, 00, textBytes2, 0 + bomLength, textBytes1.length);
                textBytes2[0] = (byte)0xff;
                textBytes2[1] = (byte)0xfe;
                //text == newText == "hello world!你好!", newText == [ 0xff/-1, 0xfe/-2, 104, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 0, 119, 0, 111, 0, 114, 0, 108, 0, 100, 0, 33, 0, 96, 79, 125, 89, 33, 0 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes2;
                break;
            }
            case UTF16LE_WITHOUT_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-16LE"

                //text == newText == "hello world!你好!", newText == [ 104, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 0, 119, 0, 111, 0, 114, 0, 108, 0, 100, 0, 33, 0, 96, 79, 125, 89, 33, 0 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes1;
                break;
            }

            case UTF16BE_WITH_BOM : {
                //方法1
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-16BE"
                int bomLength = 2;
                byte [] textBytes2 = new byte [textBytes1.length + bomLength];//预留 2个字节，填充 bom
                System.arraycopy(textBytes1, 00, textBytes2, 0 + bomLength, textBytes1.length);
                textBytes2[0] = (byte)0xfe;
                textBytes2[1] = (byte)0xff;

                //方法2
                //byte [] textBytes2 = (new String( text )).getBytes( "UTF-16" );//仅适用于 utf16 BE with bom(0xfe = -2, 0xff=-1)

                //text == newText == "hello world!你好!", newText == [ 0xfe/-2, 0xff/-1, 0, 104, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 0, 119, 0, 111, 0, 114, 0, 108, 0, 100, 0, 33, 79, 96, 89, 125, 0, 33 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes2;
                break;
            }
            case UTF16BE_WITHOUT_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-16BE"

                //text == newText == "hello world!你好!", newText == [ 0, 104, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 0, 119, 0, 111, 0, 114, 0, 108, 0, 100, 0, 33, 79, 96, 89, 125, 0, 33 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes1;
                break;
            }

            //UTF32 设计 字节序(大小端)问题 (每个文本字符的最小单元: 4 byte)
            case UTF32LE_WITH_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-32LE"
                int bomLength = 4;
                byte [] textBytes2 = new byte [textBytes1.length + bomLength];//预留 4个字节，填充 bom
                System.arraycopy(textBytes1, 00, textBytes2, 0 + bomLength, textBytes1.length);
                textBytes2[0] = (byte)0xff;
                textBytes2[1] = (byte)0xfe;
                textBytes2[2] = (byte)0x00;
                textBytes2[3] = (byte)0x00;

                //text == newText == "hello world!你好!", newText ==
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes2;
                break;
            }
            case UTF32LE_WITHOUT_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-32LE"

                //text == newText == "hello world!你好!", newText ==
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes1;
                break;
            }

            case UTF32BE_WITH_BOM : {
                //方法1
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-32BE"
                int bomLength = 4;
                byte [] textBytes2 = new byte [textBytes1.length + bomLength];//预留 2个字节，填充 bom
                System.arraycopy(textBytes1, 00, textBytes2, 0 + bomLength, textBytes1.length);
                textBytes2[0] = (byte)0x00;
                textBytes2[1] = (byte)0x00;
                textBytes2[2] = (byte)0xfe;
                textBytes2[3] = (byte)0xff;

                //text == newText == "hello world!你好!", newText ==
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes2;
                break;
            }
            case UTF32BE_WITHOUT_BOM : {
                byte [] textBytes1 = (new String( text )).getBytes( unicodeCharset.getJavaCharset() );//"UTF-32BE"

                //方法2
                //byte [] textBytes2 = (new String( text )).getBytes( "UTF-32" );//仅适用于 utf32 BE without bom(0x00, 0x00, 0xfe = -2, 0xff=-1)

                //text == newText == "hello world!你好!", newText == [ 0, 0, 0, 104, 0, 0, 0, 101, 0, 0, 0, 108, 0, 0, 0, 108, 0, 0, 0, 111, 0, 0, 0, 32, 0, 0, 0, 119, 0, 0, 0, 111, 0, 0, 0, 114, 0, 0, 0, 108, 0, 0, 0, 100, 0, 0, 0, 33, 0, 0, 79, 96, 0, 0, 89, 125, 0, 0, 0, 33 ]
                //String newText = new String( textBytes2, unicodeCharset.getJavaCharset() );
                textBytes = textBytes1;
                break;
            }
            default: {
                //do nothing
                break;
            }
        }

        return textBytes;
    }
}
</code></pre>
<h3 id="unicodetextutilstest">UnicodeTextUtilsTest</h3>
<pre><code class="language-java">package com.xxx.sdk.utils.text;


import com.xxx.sdk.pojo.text.UnicodeCharsetEnum;
import com.xxx.sdk.utils.bytes.BytesUtils;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

@Slf4j
public class UnicodeTextUtilsTest {
    @Test
    public void textToBytesTest() throws Exception {
        String text = "hello world!你好!";

        //efbbbf68656c6c6f20776f726c6421e4bda0e5a5bd21
        log.info( "UTF8_WITH_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF8_WITH_BOM) ));
        //68656c6c6f20776f726c6421e4bda0e5a5bd21
        log.info( "UTF8_WITHOUT_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF8_WITHOUT_BOM) ));

        //fffe680065006c006c006f00200077006f0072006c0064002100604f7d592100
        log.info( "UTF16LE_WITH_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF16LE_WITH_BOM) ));
        //680065006c006c006f00200077006f0072006c0064002100604f7d592100
        log.info( "UTF16LE_WITHOUT_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF16LE_WITHOUT_BOM) ));
        //feff00680065006c006c006f00200077006f0072006c006400214f60597d0021
        log.info( "UTF16BE_WITH_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF16BE_WITH_BOM) ));
        //00680065006c006c006f00200077006f0072006c006400214f60597d0021
        log.info( "UTF16BE_WITHOUT_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF16BE_WITHOUT_BOM) ));

        //fffe000068000000650000006c0000006c0000006f00000020000000770000006f000000720000006c0000006400000021000000604f00007d59000021000000
        log.info( "UTF32LE_WITH_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF32LE_WITH_BOM) ));
        //68000000650000006c0000006c0000006f00000020000000770000006f000000720000006c0000006400000021000000604f00007d59000021000000
        log.info( "UTF32LE_WITHOUT_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF32LE_WITHOUT_BOM) ));
        //0000feff00000068000000650000006c0000006c0000006f00000020000000770000006f000000720000006c000000640000002100004f600000597d00000021
        log.info( "UTF32BE_WITH_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF32BE_WITH_BOM) ));
        //00000068000000650000006c0000006c0000006f00000020000000770000006f000000720000006c000000640000002100004f600000597d00000021
        log.info( "UTF32BE_WITHOUT_BOM:{}", BytesUtils.bytesToHexString( UnicodeTextUtils.textToBytes(text, UnicodeCharsetEnum.UTF32BE_WITHOUT_BOM) ));
    }
}
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li>
<p><a href="https://www.cnblogs.com/johnnyzen/p/18921308" target="_blank">[网络传输/序列化/CPU/内存/计算机组成原理] 字节序/大小端 - 博客园/千千寰宇</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/johnnyzen/p/18293230" target="_blank">[Java SE] 基础工具类：ByteUtils(字节操作) - 博客园/千千寰宇</a></p>
</li>
<li>
<p><a href="https://stackoverflow.org.cn/questions/879482" target="_blank" rel="noopener nofollow">java - 如何使用 BOM 编码/解码 UTF-16LE 字节数组？ - StackoverFlow</a></p>
</li>
</ul>
<blockquote>
<p>用 <code>BOM</code> 将 a 编码 <code>java.lang.String</code> 为 <code>UTF-16 little endian</code> 的方法</p>
</blockquote>
<pre><code class="language-java">public static byte[] encodeString(String message) {

    byte[] tmp = null;
    try {
        tmp = message.getBytes("UTF-16LE");
    } catch(UnsupportedEncodingException e) {
        // should not possible
        AssertionError ae =
        new AssertionError("Could not encode UTF-16LE");
        ae.initCause(e);
        throw ae;
    }

    // use brute force method to add BOM
    byte[] utf16lemessage = new byte[2 + tmp.length];
    utf16lemessage[0] = (byte)0xFF;
    utf16lemessage[1] = (byte)0xFE;
    System.arraycopy(tmp, 0,
                     utf16lemessage, 2,
                     tmp.length);
    return utf16lemessage;
}
</code></pre>
<blockquote>
<p>这是一个老问题，但我仍然找不到适合我情况的可接受答案。基本上，<strong>Java 没有内置的带有 BOM 的 UTF-16LE 编码器。因此，您必须推出自己的实现</strong>。 2017-08-24T22:17:10.220</p>
</blockquote>
<pre><code class="language-java">private byte[] encodeUTF16LEWithBOM(final String s) {
    ByteBuffer content = Charset.forName("UTF-16LE").encode(s);
    byte[] bom = { (byte) 0xff, (byte) 0xfe };
    return ByteBuffer.allocate(content.capacity() + bom.length).put(bom).put(content).array();
}
</code></pre>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://blog.csdn.net/rodbate/article/details/76296131" target="_blank" rel="noopener nofollow">字符集编码 Unicode UTF8 UTF16 UTF32 和BOM（Byte Order Mark） - CSDN</a></li>
<li><a href="https://www.zhihu.com/question/265298913" target="_blank" rel="noopener nofollow">win10下怎么把txt格式转换为无bom的utf-8形式？ - Zhihu</a></li>
</ul>
<blockquote>
<ul>
<li><code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code> 还区分带 <code>BOM</code> 的以及不带 <code>BOM</code> 的 Unicode 文本。</li>
</ul>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.021527777777777778" data-date-updated="2025-06-17 20:29">2025-06-17 19:58</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18931813);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18931813', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18931813', title: '[计算机组成原理/Java] 字符集编码: Unicode 字符集(UTF8/UTF16/UTF32) 和 `BOM`(Byte Order Mark/字节序标记) / UnicodeTextUtils' })">举报</a>
</div>
        