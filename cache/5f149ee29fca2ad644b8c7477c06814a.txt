
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18873868" title="发布于 2025-05-13 10:38">
    <span role="heading" aria-level="2">如何医治一条慢SQL?</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>"苏工，订单列表又崩了！"</p>
<p>接到电话时，我对着监控大屏上999ms的SQL响应时间哭笑不得。</p>
<p>几年来，我发现一个定律：所有SQL问题都是在凌晨三点爆发！</p>
<p>今天抽丝剥茧，教你用架构师的思维给慢SQL开刀手术。</p>
<p>希望对你会有所帮助。</p>
<h2 id="1-术前检查找准病灶">1 术前检查：找准病灶</h2>
<h3 id="11-explain-查看执行计划">1.1 EXPLAIN 查看执行计划</h3>
<p>使用EXPLAIN查看SQL语句的执行计划，相当于给SQL拍了张X光。</p>
<p>下面是一个典型的SQL问题，它是某电商平台历史订单查询的SQL语句：</p>
<pre><code class="language-sql">SELECT * 
FROM orders o 
LEFT JOIN users u ON o.user_id = u.id
LEFT JOIN products p ON o.product_id = p.id
WHERE o.create_time &gt; '2023-01-01'
  AND u.vip_level &gt; 3
  AND p.category_id IN (5,8)
ORDER BY o.amount DESC 
LIMIT 1000,20;
</code></pre>
<p>使用EXPLAIN关键字查看执行计划的结果如下：</p>
<pre><code class="language-sql">+----+-------------+-------+------+---------------+------+---------+------+---------+---------------------------------+
| id | select_type | table | type | possible_keys | key  | rows    | Extra| key_len | 
+----+-------------+-------+------+---------------+------+---------+------+---------+---------------------------------+
| 1  | SIMPLE      | o     | ALL  | idx_user_time | NULL | 1987400 | Using where; Using filesort     |  
| 1  | SIMPLE      | u     | ALL  | PRIMARY       | NULL | 100000  | Using where                     |
| 1  | SIMPLE      | p     | ALL  | PRIMARY       | NULL | 50000   | Using where                     |
+----+-------------+-------+------+---------------+------+---------+------+---------+---------------------------------+
</code></pre>
<p><strong>诊断报告</strong>：</p>
<ul>
<li>全表扫描三连击（type=ALL）</li>
<li>filesort暴力排序（内存警告）</li>
<li>索引全军覆没</li>
</ul>
<h2 id="2-手术方案精准打击">2 手术方案：精准打击</h2>
<h3 id="21-单表代谢手术">2.1 单表代谢手术</h3>
<p>如果通过执行计划查到是索引有问题，我们就需要单独优化索引。</p>
<p><strong>病根</strong>：JSON字段索引失效</p>
<p>错误用法：</p>
<pre><code class="language-sql">ALTER TABLE users ADD INDEX idx_extend ((extend_info-&gt;'$.is_vip')); 
</code></pre>
<p>extend_info字段是JSON类型的字段，即使创建了索引，索引也会丢失。</p>
<p>正解姿势（MySQL 8.0+）：</p>
<pre><code class="language-sql">ALTER TABLE users ADD INDEX idx_vip_level (vip_level);
ALTER TABLE orders ADD INDEX idx_create_user (create_time, user_id) COMMENT '组合索引覆盖查询';
</code></pre>
<p>创建组合索引覆盖查询。</p>
<h3 id="22-血管疏通术">2.2 血管疏通术</h3>
<p><strong>卡点分析</strong>：</p>
<p>原始join顺序是：</p>
<pre><code class="language-sql">orders → users → products
</code></pre>
<p>优化后的方案：</p>
<pre><code class="language-sql">(子查询过滤users) → products → orders
</code></pre>
<p>调整执行顺序，用小表驱动大表。</p>
<p>重写后的SQL：</p>
<pre><code class="language-sql">SELECT o.* 
FROM products p 
INNER JOIN (
  SELECT o.id, o.amount, o.create_time 
  FROM orders o 
  WHERE o.create_time &gt; '2023-01-01'
) o ON p.id = o.product_id 
INNER JOIN (
  SELECT id 
  FROM users 
  WHERE vip_level &gt; 3
) u ON o.user_id = u.id  
WHERE p.category_id IN (5,8)
ORDER BY o.amount DESC 
LIMIT 1000,20;
</code></pre>
<p><strong>术后效果</strong>：</p>
<ul>
<li>先扫小表（users过滤后只有100条）</li>
<li>消除冗余字段传输</li>
<li>减少Join时临时表生成</li>
</ul>
<h3 id="23-开颅手术">2.3 开颅手术</h3>
<p>通过执行计划锁定了问题，走错索引了，该怎么处理呢？</p>
<p>可以通过FORCE INDEX强制指定索引：</p>
<pre><code class="language-sql">SELECT /*+ INDEX(o idx_create_user) */ 
       o.id, o.amount 
FROM orders o FORCE INDEX (idx_create_user)
WHERE o.create_time &gt; '2023-01-01';
</code></pre>
<p>使用衍生表加速：</p>
<pre><code class="language-sql">SELECT *
FROM (
  SELECT id, amount 
  FROM orders 
  WHERE create_time &gt; '2023-01-01'
  ORDER BY amount DESC 
  LIMIT 1020 
) tmp 
ORDER BY amount DESC 
LIMIT 1000,20;
</code></pre>
<p><strong>医嘱</strong>：</p>
<ul>
<li>警惕OR导致的索引失效</li>
<li>用覆盖索引避免回表查询</li>
<li>CTE表达式谨慎使用</li>
</ul>
<h3 id="24-生命体征监测">2.4 生命体征监测</h3>
<p>查看索引使用：</p>
<pre><code class="language-sql">SHOW INDEX FROM orders;
</code></pre>
<p>监控索引使用率：</p>
<pre><code>SELECT object_schema, object_name, index_name,
       count_read, count_fetch 
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL;
</code></pre>
<h2 id="3-术后护理体系化治理">3 术后护理：体系化治理</h2>
<h3 id="31-sql消毒中心">3.1 SQL消毒中心</h3>
<p>需要制定优秀的代码规范，否则可能会出现全表扫描的问题。</p>
<p>在日常工作中，我们要尽可能减少<strong>Java代码感染源</strong>。</p>
<p>MyBatis危险写法：</p>
<pre><code class="language-java">@Select("SELECT * FROM orders WHERE #{condition}")
List&lt;Order&gt; findByCondition(@Param("condition") String condition);
</code></pre>
<p>condition参数可以传入任何内容，如何传入了1=1，可能会导致查询所有的数据，走全表扫描，让查询效率变得非常低。</p>
<p>正确做法（参数化查询）：</p>
<pre><code>@Select("SELECT * FROM orders WHERE create_time &gt; #{time}")
List&lt;Order&gt; findByTime(@Param("time") Date time);
</code></pre>
<p><strong>消毒方案</strong>：</p>
<ol>
<li>SQL审核平台接入（如Yearning）</li>
<li>MyBatis拦截器拦截全表更新</li>
<li>自动化EXPLAIN分析流水线</li>
</ol>
<h3 id="32-查杀大表癌症">3.2 查杀大表癌症</h3>
<p>如果遇到大表的癌症病例，可以用分库分表的方案解决。</p>
<p><strong>病历案例</strong>：3亿订单表终极解决方案</p>
<pre><code class="language-yml">// Sharding-JDBC分片配置
spring.shardingsphere.rules.sharding.tables.orders.actual-data-nodes=ds$0..1.orders_$-&gt;{2020..2023}
spring.shardingsphere.rules.sharding.tables.orders.table-strategy.standard.sharding-column=create_time
spring.shardingsphere.rules.sharding.tables.orders.table-strategy.standard.sharding-algorithm-name=time_range
</code></pre>
<p><strong>化疗方案</strong>：</p>
<ul>
<li>时间维度分片（2020~2023年度表）</li>
<li>用户ID取模分库</li>
<li>冷热分离（OSS归档历史数据）</li>
</ul>
<h2 id="医嘱总结">医嘱总结</h2>
<p><strong>优化三板斧</strong>：</p>
<ol>
<li>定位：慢查询日志+执行计划分析</li>
<li>切割：化繁为简拆分多步执行</li>
<li>重建：符合业务场景的数据结构</li>
</ol>
<p><strong>避坑口诀</strong>：</p>
<ul>
<li>索引不是银弹，覆盖才是王道</li>
<li>Join水深，能拆就拆</li>
<li>Order By+Limit≠分页优化</li>
</ul>
<p>最后送上苏三的传秘方：当你优化SQL到怀疑人生时，不妨试试这三味药：</p>
<ol>
<li>删业务逻辑</li>
<li>加缓存</li>
<li>换数据库</li>
</ol>
<p>保证药到病除（老板打不打死你我就不管了，哈哈哈）！</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1567618584050926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-13 10:38">2025-05-13 10:38</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">159</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873868);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873868', targetLink: 'https://www.cnblogs.com/12lisu/p/18873868', title: '如何医治一条慢SQL?' })">举报</a>
</div>
        