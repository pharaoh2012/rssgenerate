
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18768981" title="发布于 2025-03-13 00:44">
    <span role="heading" aria-level="2">迅速理解 LCS  最长公共子序列问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在算法与数据结构的经典问题中，最长公共子序列（Longest Common Subsequence，简称 LCS）问题占据着重要的地位。给定两个序列，我们需要找到它们最长的公共子序列，而子序列要求保持原序列元素的顺序但不需要连续。LCS 问题在文本比较、生物信息学中的基因序列比对等领域有着广泛的应用。</p>
<p>例如，对于序列 X = "ABCBDAB" 和序列 Y = "BDCABB"，它们的最长公共子序列为 "BCAB"，长度为4。</p>
<p>LCS 的标准解法可以通过动态规划在相对高效的时间内解决，但在某些特殊情境下，我们可以通过巧妙的转化进一步优化其效率，尤其当其中一个序列中元素不重复时。</p>
<h2 id="动态规划">动态规划</h2>
<p>动态规划是解决 LCS 问题的标准方法。设序列 $ X $ 和序列 $ Y $ 的长度分别为 $ m $ 和 $ n $。我们定义二维数组 $ dp[i][j] $ 为 $ X $ 的前 $ i $ 个元素和 $ Y $ 的前 $ j $ 个元素的最长公共子序列长度，则状态转移方程为：</p>
<ul>
<li>若 $ X[i] = Y[j] $，则 $ dp[i][j] = dp[i-1][j-1] + 1 $；</li>
<li>还可从之前状态取，$ dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) $。</li>
</ul>
<p>每一个 $ dp[i][j] $ 都可直接得出，时间复杂度 <span class="math inline">\(O(mn)\)</span>。</p>
<p>每一个 $ dp[i][j] $ 仅由 $ dp[i-1]$ 推出，通过滚动数组或交替数组的技巧，将空间复杂度降低至 $ O(\min(m,n)) $。具体实现时，仅维护当前和上一行（或列）的信息即可。</p>
<p>代码略。</p>
<h2 id="无重复元素的-lcs-问题">无重复元素的 LCS 问题</h2>
<p>当问题中有额外的限制条件时，我们常能发现优化的可能性。具体而言，当序列 $ X $ 中的元素是唯一的，即每个元素至多出现一次时，LCS 问题可转化为最长递增子序列（Longest Increasing Subsequence，简称 LIS）问题，从而实现高效求解。</p>
<p>具体转化过程为：</p>
<ol>
<li>建立序列 $ Y $ 中元素到其索引位置的映射；</li>
<li>用序列 $ X $ 中的元素依次检查该元素是否存在于 $ Y $ 中，若存在，则用其在 $ Y $ 中的位置替代；</li>
<li>形成新的序列 $ Z $，序列 $ Z $ 中的每个元素均为序列 $ Y $ 中的索引位置。</li>
</ol>
<p>转化后问题变为寻找序列 $ Z $ 的 LIS。该转化之所以成立，其正确性源于如下两个核心事实：</p>
<ul>
<li><strong>保序性</strong>：原LCS要求序列顺序匹配，这与转化后的序列 $ Z $ 中元素位置索引的严格递增特性一致。</li>
<li><strong>唯一性保证映射的单射性</strong>：由于序列 $ X $ 中出现，一定只能出现在唯一的位置， 中元素的唯一性，映射过程中不会出现元素位置的歧义，确保新序列 $ Z $ 能够精确代表 $ X $ 和 $ Y $ 的顺序关系。</li>
</ul>
<p>由于 $ Y $ 中元素，若在 $ X $ 中出现，一定只能出现在唯一的位置，所以可以把 $ Y $ 转化为索引，求“索引的递增序列”，一个递增的索引序列就代表一个公共子序列。</p>
<p>因此，此转化将原本朴素的 LCS 问题优化为 $ O(m \log m) $ 的 LIS 问题，使得在特定场景下的算法效率大大提高。LIS 的代码实现可以参考往期文章。</p>
<pre><code class="language-cpp">int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n), tail;

    unordered_map&lt;int, int&gt; mp;
    mp.reserve(n);
	
    for (int i = 0; i &lt; n; i++) {
        Cin &gt;&gt; a[i];
        mp[a[i]] = i;
    }
    for (int i = 0; i &lt; n; i++) {
        int x;
        Cin &gt;&gt; x;
        if (!mp.count(x)) continue;
        
        x = mp[x];

        auto it = lower_bound(tail.begin(), tail.end(), x);
        if (it == tail.end()) {
            tail.push_back(x);
        } else {
            *it = x;
        }
    } printf("%d\n", tail.size());
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6812509028900463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 10:00">2025-03-13 00:44</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">114</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18768981" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18768981);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18768981', targetLink: 'https://www.cnblogs.com/ofnoname/p/18768981', title: '迅速理解 LCS  最长公共子序列问题' })">举报</a>
</div>
        