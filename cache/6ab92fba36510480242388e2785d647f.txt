
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18959951" title="发布于 2025-07-01 17:07">
    <span role="heading" aria-level="2">C++ 流</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 C++ 标准库中，<strong>stream（流）</strong>是处理输入输出（I/O）的核心抽象，分为输入流（<code>istream</code>）、输出流（<code>ostream</code>）、输入输出流（<code>iostream</code>）等多种类型，且支持面向不同设备（文件、字符串、控制台等）的具体流类型。</p>
<hr>
<h1 id="stream-类型">Stream 类型</h1>
<table>
<thead>
<tr>
<th>类别</th>
<th>主要类型及说明</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入流</strong></td>
<td><code>std::istream</code>：通用输入流基类</td>
<td><code>&lt;istream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::ifstream</code>：文件输入流</td>
<td><code>&lt;fstream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::istringstream</code>：字符串输入流</td>
<td><code>&lt;sstream&gt;</code></td>
</tr>
<tr>
<td><strong>输出流</strong></td>
<td><code>std::ostream</code>：通用输出流基类</td>
<td><code>&lt;ostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::ofstream</code>：文件输出流</td>
<td><code>&lt;fstream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::ostringstream</code>：字符串输出流</td>
<td><code>&lt;sstream&gt;</code></td>
</tr>
<tr>
<td><strong>输入输出流</strong></td>
<td><code>std::iostream</code>：通用输入输出流基类</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::fstream</code>：文件输入输出流</td>
<td><code>&lt;fstream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::stringstream</code>：字符串输入输出流</td>
<td><code>&lt;sstream&gt;</code></td>
</tr>
<tr>
<td><strong>标准流对象</strong></td>
<td><code>std::cin</code>：标准输入流（全局对象）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::cout</code>：标准输出流（全局对象）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::cerr</code>：标准错误输出流（无缓冲）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td><code>std::clog</code>：标准错误输出流（带缓冲）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
</tbody>
</table>
<hr>
<p>继承关系简图（简化版）</p>
<pre><code>std::ios_base
    └── std::ios
           ├── std::istream
           │      ├── std::ifstream
           │      └── std::istringstream
           ├── std::ostream
           │      ├── std::ofstream
           │      └── std::ostringstream
           └── std::iostream
                  ├── std::fstream
                  └── std::stringstream
</code></pre>
<hr>
<hr>
<h2 id="一标准流">一、标准流</h2>
<p>C++ 标准库定义了四个主要的标准流对象：</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>功能描述</th>
<th>缓冲机制</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::cin</code></td>
<td><code>std::istream</code></td>
<td>标准输入流，通常关联键盘输入</td>
<td>带缓冲</td>
<td>从键盘或重定向输入读取数据</td>
</tr>
<tr>
<td><code>std::cout</code></td>
<td><code>std::ostream</code></td>
<td>标准输出流，通常关联控制台显示</td>
<td>带缓冲</td>
<td>向控制台或重定向输出写数据</td>
</tr>
<tr>
<td><code>std::cerr</code></td>
<td><code>std::ostream</code></td>
<td>标准错误输出流，关联控制台显示</td>
<td><strong>无缓冲</strong></td>
<td>用于错误或即时输出提示</td>
</tr>
<tr>
<td><code>std::clog</code></td>
<td><code>std::ostream</code></td>
<td>标准日志输出流，关联控制台显示</td>
<td>带缓冲</td>
<td>用于程序日志信息输出</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="1-stdcin---标准输入流">1. <code>std::cin</code> - 标准输入流</h3>
<ul>
<li>类型：<code>std::istream</code></li>
<li>默认关联设备：键盘（终端输入）</li>
<li>用法：</li>
</ul>
<pre><code class="language-cpp">int x;
std::cin &gt;&gt; x;  // 从标准输入读取一个整数
</code></pre>
<ul>
<li><strong>缓冲</strong>：带缓冲。输入时会先缓冲一部分数据，通常是整行读取后交给程序处理。</li>
<li>支持格式化输入：<code>operator&gt;&gt;</code> 会自动跳过空白、换行，进行类型转换。</li>
<li>支持重定向：例如从文件读取时，命令行重定向输入 <code>program &lt; input.txt</code>。</li>
</ul>
<hr>
<h3 id="2-stdcout---标准输出流">2. <code>std::cout</code> - 标准输出流</h3>
<ul>
<li>类型：<code>std::ostream</code></li>
<li>默认关联设备：控制台（终端显示）</li>
<li>用法：</li>
</ul>
<pre><code class="language-cpp">std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;
</code></pre>
<ul>
<li><strong>缓冲</strong>：带缓冲。缓冲区满或者遇到 <code>std::endl</code> 会刷新缓冲区写到终端。</li>
<li>支持各种类型的格式化输出（整型、浮点、字符串、自定义类型重载 <code>operator&lt;&lt;</code>）。</li>
<li>支持重定向：例如把输出写入文件 <code>program &gt; output.txt</code>。</li>
</ul>
<hr>
<h3 id="3-stdcerr---标准错误输出流">3. <code>std::cerr</code> - 标准错误输出流</h3>
<ul>
<li>类型：<code>std::ostream</code></li>
<li>默认关联设备：控制台（终端显示）</li>
<li><strong>无缓冲</strong>输出：写入时立即发送到终端，适合打印错误或警告信息，确保及时可见。</li>
<li>用法：</li>
</ul>
<pre><code class="language-cpp">std::cerr &lt;&lt; "Error: File not found!" &lt;&lt; std::endl;
</code></pre>
<ul>
<li>作用是和 <code>cout</code> 分开输出，方便终端或脚本捕获错误信息。</li>
<li>不受缓冲影响，即使程序异常退出也更容易保证错误信息打印出来。</li>
</ul>
<hr>
<h3 id="4-stdclog---标准日志输出流">4. <code>std::clog</code> - 标准日志输出流</h3>
<ul>
<li>类型：<code>std::ostream</code></li>
<li>默认关联设备：控制台（终端显示）</li>
<li><strong>带缓冲</strong>输出，适合大量日志信息，效率高。</li>
<li>用法：</li>
</ul>
<pre><code class="language-cpp">std::clog &lt;&lt; "Log: Starting the program..." &lt;&lt; std::endl;
</code></pre>
<ul>
<li>用于日志信息输出，不同于 <code>cerr</code> 主要是“错误”，<code>clog</code> 主要是“日志”。</li>
<li>和 <code>cerr</code> 区别在于缓冲方式和输出语义。</li>
</ul>
<hr>
<h3 id="标准流对象常用操作和特性">标准流对象常用操作和特性</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取输入</td>
<td><code>std::cin &gt;&gt; x;</code></td>
<td>从键盘读取格式化输入</td>
</tr>
<tr>
<td>输出文本</td>
<td><code>std::cout &lt;&lt; "Hello\n";</code></td>
<td>向终端打印文本</td>
</tr>
<tr>
<td>输出错误信息</td>
<td><code>std::cerr &lt;&lt; "Error!\n";</code></td>
<td>立即打印错误信息</td>
</tr>
<tr>
<td>输出日志</td>
<td><code>std::clog &lt;&lt; "Log message\n";</code></td>
<td>缓冲写入日志信息</td>
</tr>
<tr>
<td>刷新缓冲区</td>
<td><code>std::cout.flush();</code> 或 <code>std::cout &lt;&lt; std::flush;</code></td>
<td>立即将缓冲内容写入设备</td>
</tr>
<tr>
<td>操纵符换行+刷新</td>
<td><code>std::cout &lt;&lt; std::endl;</code></td>
<td>输出换行并刷新缓冲</td>
</tr>
<tr>
<td>判断流状态</td>
<td><code>if (!std::cin) { /* 读取失败 */ }</code></td>
<td>判断流是否处于错误状态</td>
</tr>
<tr>
<td>重定向流</td>
<td>命令行重定向 <code>program &lt; input.txt &gt; output.txt</code></td>
<td>改变流的输入输出设备</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="标准流对象的缓冲策略">标准流对象的缓冲策略</h3>
<table>
<thead>
<tr>
<th>流对象</th>
<th>缓冲类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::cin</code></td>
<td>带缓冲</td>
<td>读取时先缓冲，优化输入效率</td>
</tr>
<tr>
<td><code>std::cout</code></td>
<td>带缓冲</td>
<td>输出时缓存，遇换行或缓冲满时刷新</td>
</tr>
<tr>
<td><code>std::cerr</code></td>
<td>无缓冲</td>
<td>错误信息立即输出，不等待缓冲刷新</td>
</tr>
<tr>
<td><code>std::clog</code></td>
<td>带缓冲</td>
<td>日志输出缓冲，提高效率</td>
</tr>
</tbody>
</table>
<h2 id="二输入输出流">二、输入输出流</h2>
<p>在C++中，<strong>输入输出流（Input/Output Stream）</strong>是对数据流动方向的抽象，用于从某个设备（如键盘、文件、内存）读取数据或向其写入数据。输入流负责读取，输出流负责写入。<strong>输入输出流</strong>即同时支持<strong>输入和输出</strong>的流，能既从中读取数据，也向其中写入数据。</p>
<h3 id="基本流层级和具体实现类">基本流层级和具体实现类</h3>
<h3 id="stdiostream"><code>std::iostream</code></h3>
<ul>
<li>继承自 <code>std::istream</code> 和 <code>std::ostream</code>。支持标准输入输出流的所有操作。既可以用作输入流，也可以用作输出流。</li>
<li>底层依赖于缓冲区（buffer）管理，避免频繁系统调用，提升效率。<code>iostream</code> 对象拥有一个<code>streambuf</code>缓冲区指针，通过它实现具体读写。<code>iostream</code> 继承了格式化输入输出的能力，比如支持<code>operator&gt;&gt;</code>、<code>operator&lt;&lt;</code>对各种类型的重载。</li>
</ul>
<table>
<thead>
<tr>
<th>类名</th>
<th>功能描述</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ios_base</code></td>
<td>I/O 库的基础类，管理格式化和状态</td>
<td><code>&lt;ios&gt;</code></td>
</tr>
<tr>
<td><code>std::ios</code></td>
<td>继承自 <code>ios_base</code>，增加缓冲等支持</td>
<td><code>&lt;ios&gt;</code></td>
</tr>
<tr>
<td><code>std::istream</code></td>
<td>输入流基类</td>
<td><code>&lt;istream&gt;</code></td>
</tr>
<tr>
<td><code>std::ostream</code></td>
<td>输出流基类</td>
<td><code>&lt;ostream&gt;</code></td>
</tr>
<tr>
<td><code>std::iostream</code></td>
<td>输入输出流基类（继承自 <code>istream</code> 和 <code>ostream</code>）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
</tbody>
</table>
<p><code>iostream</code>继承了输入流和输出流的功能，因此可同时读写。</p>
<hr>
<p>具体实现类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>用途</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::fstream</code></td>
<td>文件输入输出流</td>
<td><code>&lt;fstream&gt;</code></td>
</tr>
<tr>
<td><code>std::stringstream</code></td>
<td>内存字符串输入输出流</td>
<td><code>&lt;sstream&gt;</code></td>
</tr>
</tbody>
</table>
<h4 id="1-文件读写使用-stdfstream">1. 文件读写（使用 <code>std::fstream</code>）</h4>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::fstream file("example.txt", std::ios::in | std::ios::out | std::ios::trunc);
    if (!file) {
        std::cerr &lt;&lt; "文件打开失败\n";
        return 1;
    }

    // 写入数据
    file &lt;&lt; "Hello, iostream!\n";

    // 重置文件读取位置到开头
    file.seekg(0);

    // 读取数据
    std::string line;
    std::getline(file, line);
    std::cout &lt;&lt; "文件内容: " &lt;&lt; line &lt;&lt; std::endl;

    file.close();
    return 0;
}
</code></pre>
<hr>
<h4 id="2-内存字符串读写使用-stdstringstream">2. 内存字符串读写（使用 <code>std::stringstream</code>）</h4>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;iostream&gt;

int main() {
    std::stringstream ss;

    // 写入
    ss &lt;&lt; "123 456";

    int a, b;
    // 读取
    ss &gt;&gt; a &gt;&gt; b;

    std::cout &lt;&lt; "读取到的数字：" &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; std::endl;
}
//输出： 读取到的数字：123, 456
</code></pre>
<hr>
<h3 id="常用成员函数部分">常用成员函数（部分）</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator&gt;&gt;</code></td>
<td>格式化输入（读取）</td>
</tr>
<tr>
<td><code>operator&lt;&lt;</code></td>
<td>格式化输出（写入）</td>
</tr>
<tr>
<td><code>read(char*, size_t)</code></td>
<td>读取原始字节流</td>
</tr>
<tr>
<td><code>write(char*, size_t)</code></td>
<td>写入原始字节流</td>
</tr>
<tr>
<td><code>get()</code></td>
<td>读取一个字符</td>
</tr>
<tr>
<td><code>put(char)</code></td>
<td>写入一个字符</td>
</tr>
<tr>
<td><code>seekg(pos)</code></td>
<td>设置输入位置</td>
</tr>
<tr>
<td><code>seekp(pos)</code></td>
<td>设置输出位置</td>
</tr>
<tr>
<td><code>tellg()</code></td>
<td>获取当前输入位置</td>
</tr>
<tr>
<td><code>tellp()</code></td>
<td>获取当前输出位置</td>
</tr>
<tr>
<td><code>good()</code>, <code>fail()</code>, <code>eof()</code></td>
<td>检查流状态</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>刷新缓冲区</td>
</tr>
</tbody>
</table>
<h2 id="流状态及错误处理">流状态及错误处理</h2>
<p>在 C++ 中，输入输出流（<code>iostream</code>）提供了状态标志和错误处理机制，用于检测和处理 I/O 操作中的异常或错误情况。理解这些机制对于编写健壮的 I/O 代码非常重要。</p>
<hr>
<h3 id="流的状态标志stream-state-flags">流的状态标志（Stream State Flags）</h3>
<p>C++ 的流对象（如 <code>std::ifstream</code>, <code>std::ofstream</code>, <code>std::cin</code>, <code>std::cout</code> 等）都继承自 <code>std::ios_base</code> 类，并维护一组状态标志来表示流当前的状态。这些状态标志是通过成员函数 <code>rdstate()</code> 获取的，其类型为 <code>std::ios_base::iostate</code>。</p>
<p>常见的状态标志包括：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>goodbit</code></td>
<td>没有发生错误（一切正常）</td>
</tr>
<tr>
<td><code>badbit</code></td>
<td>发生了不可恢复的读写错误（例如底层设备出错）</td>
</tr>
<tr>
<td><code>failbit</code></td>
<td>输入/输出操作失败（但流仍可用，例如类型不匹配）</td>
</tr>
<tr>
<td><code>eofbit</code></td>
<td>到达文件末尾（EOF）</td>
</tr>
</tbody>
</table>
<h3 id="示例">示例：</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    std::ifstream file("example.txt");
    if (!file) {
        std::cerr &lt;&lt; "Failed to open file.\n";
    }

    int value;
    file &gt;&gt; value;

    if (file.fail()) {
        std::cerr &lt;&lt; "Input failed: type mismatch or bad input.\n";
    }
    if (file.bad()) {
        std::cerr &lt;&lt; "Serious I/O error occurred.\n";
    }
    if (file.eof()) {
        std::cerr &lt;&lt; "End of file reached.\n";
    }
    if (file.good()) {
        std::cout &lt;&lt; "Everything is fine.\n";
    }

    return 0;
}
</code></pre>
<hr>
<h3 id="状态检查函数">状态检查函数</h3>
<p>除了直接使用 <code>rdstate()</code> 来获取状态位外，还可以使用以下成员函数进行状态判断：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>返回值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>good()</code></td>
<td>是否处于良好状态（没有设置任何错误标志）</td>
</tr>
<tr>
<td><code>bad()</code></td>
<td>是否发生了不可恢复的错误</td>
</tr>
<tr>
<td><code>fail()</code></td>
<td>是否发生了可恢复的错误（包括 <code>eofbit</code>）</td>
</tr>
<tr>
<td><code>eof()</code></td>
<td>是否到达文件末尾</td>
</tr>
<tr>
<td><code>operator!()</code></td>
<td>是否处于失败状态（即 <code>fail()</code> 为真）</td>
</tr>
<tr>
<td><code>operator bool()</code></td>
<td>是否处于非失败状态（即 <code>!fail()</code> 为真）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="清除状态标志">清除状态标志</h2>
<p>如果你希望继续使用一个已经出错的流对象，可以使用 <code>clear()</code> 或 <code>clear(iostate)</code> 函数来清除状态标志。</p>
<h3 id="示例-1">示例：</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int num;
    std::cin &gt;&gt; num;

    if (std::cin.fail()) {
        std::cin.clear(); // 清除 failbit
        std::cin.ignore(10000, '\n'); // 忽略缓冲区中的非法输入
        std::cout &lt;&lt; "Invalid input. Please enter an integer: ";
        std::cin &gt;&gt; num;
    }

    std::cout &lt;&lt; "You entered: " &lt;&lt; num &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<hr>
<h2 id="错误处理与异常机制exception-handling">错误处理与异常机制（Exception Handling）</h2>
<p>默认情况下，C++ 流不会抛出异常，而是通过状态标志来报告错误。但你可以通过 <code>exceptions()</code> 函数启用异常处理。</p>
<h3 id="示例启用异常">示例：启用异常</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    std::ifstream file("nonexistent.txt");

    // 启用异常：当流状态变为 badbit 或 failbit 时抛出异常
    file.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try {
        int value;
        file &gt;&gt; value; // 如果文件不存在或无法读取，将抛出异常
    } catch (const std::ios_base::failure&amp; e) {
        std::cerr &lt;&lt; "Caught an exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }

    return 0;
}
</code></pre>
<blockquote>
<p>⚠️ 注意：启用异常后，某些操作（如构造失败）可能不会触发异常。建议结合 <code>if (!file)</code> 进行检查。</p>
</blockquote>
<h2 id="三输入流">三、输入流</h2>
<p>在 C++ 中，<strong>输入流（Input Stream）</strong> 是一种用于从数据源读取数据的机制。C++ 的标准库提供了强大的 I/O 流类库，其中与输入相关的类主要包括：</p>
<ul>
<li><code>std::istream</code>：基本输入流类。</li>
<li><code>std::ifstream</code>：用于从文件中读取数据。</li>
<li><code>std::istringstream</code>：用于从字符串中读取数据。</li>
<li><code>std::cin</code>：标准输入流对象（通常来自键盘）。</li>
</ul>
<p>所有输入流都继承自 <code>std::istream</code> 类。它的核心功能是提供读取操作符 <code>&gt;&gt;</code> 和成员函数如 <code>get()</code>, <code>getline()</code>, <code>read()</code> 等。</p>
<h3 id="常用输入流对象">常用输入流对象：</h3>
<table>
<thead>
<tr>
<th>对象/类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::cin</code></td>
<td>标准输入流，默认从控制台读取</td>
</tr>
<tr>
<td><code>std::ifstream</code></td>
<td>文件输入流</td>
</tr>
<tr>
<td><code>std::istringstream</code></td>
<td>字符串输入流</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="常用输入方法">常用输入方法</h3>
<h3 id="1-使用-operator-提取运算符">1. 使用 <code>operator &gt;&gt;</code>（提取运算符）</h3>
<p>这是最常用的输入方式，用于按类型读取数据。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int age;
    std::cout &lt;&lt; "Enter your age: ";
    std::cin &gt;&gt; age;
    std::cout &lt;&lt; "You are " &lt;&lt; age &lt;&lt; " years old.\n";
    return 0;
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>它会自动跳过前导空白字符（空格、换行、制表符等）。</li>
<li>如果输入类型不匹配（比如输入字母而非数字），将设置 <code>failbit</code> 标志。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-使用-get-函数">2. 使用 <code>get()</code> 函数</h3>
<p>用于逐个或批量读取字符（包括空白字符）。</p>
<h4 id="单字符读取">单字符读取：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    char ch;
    while (std::cin.get(ch)) {
        std::cout &lt;&lt; ch;
    }
    return 0;
}
</code></pre>
<h4 id="多字符读取带缓冲区">多字符读取（带缓冲区）：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    char buffer[100];
    std::cin.get(buffer, 100);
    std::cout &lt;&lt; "You entered: " &lt;&lt; buffer &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<blockquote>
<p><code>get()</code> 不会跳过空白字符，并且不会自动添加 <code>\0</code> 结尾。</p>
</blockquote>
<hr>
<h3 id="3-使用-getline-函数">3. 使用 <code>getline()</code> 函数</h3>
<p>用于读取整行输入，直到遇到换行符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    char buffer[100];
    std::cin.get(buffer, 100);
    std::cout &lt;&lt; "You entered: " &lt;&lt; buffer &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>或者使用 <code>std::string</code> 版本：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::cout &lt;&lt; "You entered: " &lt;&lt; line &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<blockquote>
<p><code>getline()</code> 更适合读取包含空格的完整句子。</p>
</blockquote>
<hr>
<h3 id="4-使用-read-函数二进制模式">4. 使用 <code>read()</code> 函数（二进制模式）</h3>
<p>用于一次性读取指定数量的字节，常用于二进制文件处理。</p>
<pre><code class="language-cpp">char buffer[100];
std::cin.read(buffer, sizeof(buffer));
std::streamsize count = std::cin.gcount();
std::cout.write(buffer, count); // 输出已读取的内容
</code></pre>
<h3 id="文件输入流ifstream">文件输入流<code>ifstream</code></h3>
<p><code>std::ifstream</code>（<strong>input file stream</strong>）是<strong>文件输入流</strong>，用于从文件中读取数据，就像 <code>std::cin</code> 用于从标准输入读取一样。</p>
<p>它是 C++ 的 IO 库中的一部分，定义在头文件 <code>&lt;fstream&gt;</code> 中。</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
</code></pre>
<p>继承关系如下：</p>
<pre><code>std::ios_base
    ↑
std::ios
    ↑
std::istream
    ↑
std::ifstream
</code></pre>
<hr>
<h4 id="常用构造函数">常用构造函数</h4>
<table>
<thead>
<tr>
<th>构造函数形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ifstream()</code></td>
<td>创建未打开任何文件的流对象</td>
</tr>
<tr>
<td><code>ifstream(const char* filename)</code></td>
<td>打开一个文件用于读取，使用默认模式（文本模式）</td>
</tr>
<tr>
<td><code>ifstream(const char* filename, ios::openmode mode)</code></td>
<td>指定模式打开文件</td>
</tr>
<tr>
<td><code>ifstream(const std::string&amp; filename, ios::openmode mode)</code></td>
<td>使用 <code>std::string</code> 作为文件名</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="常见打开模式stdiosopenmode">常见打开模式（<code>std::ios::openmode</code>）</h4>
<p>你可以传给 <code>ifstream</code> 构造函数或者 <code>open()</code> 方法的模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ios::in</code></td>
<td>以读模式打开（默认）</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>以二进制模式打开</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>打开文件并定位到文件尾</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>追加模式（ifstream 很少用）</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>清空文件（仅用于 ofstream）</td>
</tr>
</tbody>
</table>
<p>⚠️ 注意：<code>ifstream</code> 默认自带 <code>ios::in</code>，所以你不用显式加 unless 和其他模式组合。</p>
<h4 id="常见用法示例">常见用法示例</h4>
<p>🔸 1. 基本读取一整行</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
    std::ifstream infile("example.txt");

    if (!infile.is_open()) {
        std::cerr &lt;&lt; "Failed to open file.\n";
        return 1;
    }

    std::string line;
    while (std::getline(infile, line)) {
        std::cout &lt;&lt; "Line: " &lt;&lt; line &lt;&lt; '\n';
    }

    infile.close();
    return 0;
}
</code></pre>
<hr>
<p>🔸 2. 按单词读取</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
    std::ifstream infile("example.txt");

    if (!infile.is_open()) {
        std::cerr &lt;&lt; "Failed to open file.\n";
    }

    std::string word;
    while (infile &gt;&gt; word) {
        std::cout &lt;&lt; "Word: " &lt;&lt; word &lt;&lt; '\n';
    }

    infile.close();
    return 0;
}
</code></pre>
<hr>
<p>🔸 3. 按数字读取</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
    try {
        std::ifstream infile("/home/fxq/untitled3/example.txt");

        if (!infile.is_open()) {
            std::cerr &lt;&lt; "Failed to open file.\n";
        }

        int num;
        while (infile &gt;&gt; num) {
            std::cout &lt;&lt; "Read number: " &lt;&lt; num &lt;&lt; '\n';
        }

        infile.close();
    } catch (const std::runtime_error&amp; e) {
         std::cerr &lt;&lt; "发生异常: " &lt;&lt; e.what() &lt;&lt;  std::endl;
    }
    return 0;
}
</code></pre>
<hr>
<p>🔸 4. 用 <code>.open()</code> 延迟打开</p>
<pre><code class="language-cpp">std::ifstream infile;
infile.open("data.txt");

if (!infile) {
    std::cerr &lt;&lt; "Failed to open.\n";
}
</code></pre>
<h4 id="缓冲区">缓冲区</h4>
<p>C++ 的 <code>std::ifstream</code> 默认是<strong>带缓冲的</strong>，其底层使用了一个<strong>缓冲区（buffer）*<em>来优化文件读取效率。但你可以*</em>自定义缓冲区大小和内存</strong>，甚至设置成<strong>无缓冲</strong>。下面是详细讲解。</p>
<hr>
<h5 id="默认情况下ifstream-自带缓冲">默认情况下：<code>ifstream</code> 自带缓冲</h5>
<ul>
<li><code>ifstream</code> 会使用系统默认的缓冲区（通常是 4KB 或 8KB）。</li>
<li>当你调用 <code>read()</code>、<code>getline()</code>、<code>operator&gt;&gt;</code> 等函数时，<strong>数据先进入缓冲区，再从中解析或返回给用户程序</strong>。</li>
<li>好处是：减少系统调用次数，提高读取性能。</li>
</ul>
<hr>
<h5 id="自定义缓冲区rdbuf-pubsetbuf">自定义缓冲区：<code>rdbuf()-&gt;pubsetbuf()</code></h5>
<p>你可以设置自己的缓冲区或取消缓冲区：</p>
<pre><code class="language-cpp">std::ifstream file("example.txt");
char buffer[4096];  // 自定义缓冲区

file.rdbuf()-&gt;pubsetbuf(buffer, sizeof(buffer));
</code></pre>
<ul>
<li><code>pubsetbuf(buffer, size)</code>：设置缓冲区起始地址和大小</li>
<li>只能在 <code>open()</code> 之前调用（对已打开文件无效）</li>
</ul>
<hr>
<h5 id="设置无缓冲模式强烈不推荐除非特殊需求">设置无缓冲模式（<strong>强烈不推荐除非特殊需求</strong>）</h5>
<pre><code class="language-cpp">file.rdbuf()-&gt;pubsetbuf(nullptr, 0); // 禁用缓冲
</code></pre>
<p>⚠️ 这会让每一次 <code>read()</code> 或 <code>getline()</code> 都变成系统调用，<strong>性能会大幅下降</strong>，只在需要极低延迟的数据交互中才使用（如串口通信等）。</p>
<hr>
<h5 id="完整示例自定义缓冲区读取大文件">完整示例：自定义缓冲区读取大文件</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    // 有问题试一下全路径
    std::ifstream file("example.txt");

    // 自定义缓冲区
    char custom_buffer[8192];  // 8KB
    file.rdbuf()-&gt;pubsetbuf(custom_buffer, sizeof(custom_buffer));

    if (!file) {
        std::cerr &lt;&lt; "打开文件失败\n";
        return 1;
    }

    std::string line;
    size_t count = 0;
    while (std::getline(file, line)) {
        std::cout &lt;&lt; line &lt;&lt; std::endl;
        ++count;
    }

    std::cout &lt;&lt; "共读取行数：" &lt;&lt; count &lt;&lt; "\n";
    file.close();
    return 0;
}
</code></pre>
<hr>
<h5 id="推荐场景">推荐场景</h5>
<table>
<thead>
<tr>
<th>场景</th>
<th>缓冲设置建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>大文件（几百 MB 以上）</td>
<td>自定义大缓冲区（如 64KB）</td>
</tr>
<tr>
<td>小文件 / 一次性读取</td>
<td>默认缓冲即可</td>
</tr>
<tr>
<td>实时读取（如串口）</td>
<td><code>pubsetbuf(nullptr, 0)</code></td>
</tr>
<tr>
<td>多线程读取（少见）</td>
<td>每线程独立缓冲区</td>
</tr>
</tbody>
</table>
<h2 id="字符串输入流istringstream">字符串输入流（istringstream）</h2>
<p>用于从字符串中解析数据，常用于字符串拆分和格式转换。</p>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;iostream&gt;

int main() {
    std::string data = "John 25 85.5";
    std::istringstream iss(data);

    std::string name;
    int age;
    double score;

    iss &gt;&gt; name &gt;&gt; age &gt;&gt; score;
    std::cout &lt;&lt; name &lt;&lt; ", " &lt;&lt; age &lt;&lt; ", " &lt;&lt; score &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;&gt;</code></td>
<td>提取数据，自动跳过空白，类型安全</td>
</tr>
<tr>
<td><code>get()</code></td>
<td>读取字符（含空白）</td>
</tr>
<tr>
<td><code>getline()</code></td>
<td>读取一行（推荐用于整行输入）</td>
</tr>
<tr>
<td><code>read()</code></td>
<td>读取二进制数据</td>
</tr>
<tr>
<td><code>gcount()</code></td>
<td>获取最后一次读取的字符数</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清除错误状态</td>
</tr>
<tr>
<td><code>ignore()</code></td>
<td>忽略缓冲区中的无效字符</td>
</tr>
</tbody>
</table>
<h2 id="四输出流">四、输出流</h2>
<p>输出流是 C++ I/O 库中的一个核心概念，用于<strong>向外部目标输出数据</strong>，目标可以是：</p>
<ul>
<li>控制台（标准输出 <code>std::cout</code>）</li>
<li>文件（<code>std::ofstream</code>）</li>
<li>字符串（<code>std::ostringstream</code>）</li>
<li>自定义设备（如网络、GUI 等）</li>
</ul>
<pre><code class="language-cpp">std::ios_base
  └── std::ios
        └── std::ostream      // 输出流基类
              ├── std::ofstream       // 文件输出流
              ├── std::ostringstream  // 字符串输出流
              └── std::iostream       // 同时支持输入输出
</code></pre>
<hr>
<h3 id="常见输出流类型">常见输出流类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>功能</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ostream</code></td>
<td>所有输出流的基类</td>
<td><code>&lt;ostream&gt;</code></td>
</tr>
<tr>
<td><code>std::cout</code></td>
<td>标准输出流（控制台）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td><code>std::cerr</code></td>
<td>错误输出流（无缓冲）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td><code>std::clog</code></td>
<td>日志输出流（有缓冲）</td>
<td><code>&lt;iostream&gt;</code></td>
</tr>
<tr>
<td><code>std::ofstream</code></td>
<td>文件输出流</td>
<td><code>&lt;fstream&gt;</code></td>
</tr>
<tr>
<td><code>std::ostringstream</code></td>
<td>字符串输出流</td>
<td><code>&lt;sstream&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="常见输出函数">常见输出函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator&lt;&lt;</code></td>
<td>格式化输出</td>
<td><code>os &lt;&lt; x</code></td>
</tr>
<tr>
<td><code>put(char)</code></td>
<td>输出一个字符</td>
<td><code>os.put('A')</code></td>
</tr>
<tr>
<td><code>write(char*, size_t)</code></td>
<td>输出字节流（通常用于二进制）</td>
<td><code>os.write(buf, n)</code></td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>刷新缓冲区，强制输出</td>
<td><code>os.flush()</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="格式化控制使用-stdiomanip">格式化控制（使用 <code>std::iomanip</code>）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
int main() {
    double pi = 3.14159265;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; pi &lt;&lt; std::endl; // 输出 3.14
}
</code></pre>
<table>
<thead>
<tr>
<th>控制符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::setw(n)</code></td>
<td>设置字段宽度</td>
</tr>
<tr>
<td><code>std::setfill(c)</code></td>
<td>设置填充字符</td>
</tr>
<tr>
<td><code>std::setprecision(n)</code></td>
<td>设置浮点数精度</td>
</tr>
<tr>
<td><code>std::fixed</code></td>
<td>固定小数位格式</td>
</tr>
<tr>
<td><code>std::scientific</code></td>
<td>科学计数法格式</td>
</tr>
<tr>
<td><code>std::hex</code>/<code>std::dec</code>/<code>std::oct</code></td>
<td>设置整数进制</td>
</tr>
<tr>
<td><code>std::left</code> / <code>std::right</code> / <code>std::internal</code></td>
<td>对齐方式</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="文件输出流stdofstream示例">文件输出流（<code>std::ofstream</code>）示例</h3>
<pre><code class="language-cpp">#include &lt;fstream&gt;
int main() {
    std::ofstream ofs("output.txt");
    if (!ofs) {
        std::cerr &lt;&lt; "无法打开文件！" &lt;&lt; std::endl;
        return 1;
    }
    ofs &lt;&lt; "写入文件的第一行" &lt;&lt; std::endl;
    ofs.close();
}
</code></pre>
<hr>
<h3 id="字符串输出流stdostringstream">字符串输出流（<code>std::ostringstream</code>）</h3>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;iostream&gt;
int main() {
    std::ostringstream oss;
    oss &lt;&lt; "Name: " &lt;&lt; "Alice" &lt;&lt; ", Age: " &lt;&lt; 30;

    std::string result = oss.str(); // 获取写入的字符串
    std::cout &lt;&lt; "字符串流结果: " &lt;&lt; result &lt;&lt; std::endl;
}
</code></pre>
<h3 id="输出流的缓冲刷新机制">输出流的缓冲刷新机制</h3>
<ul>
<li>会自动刷新缓冲区的情况：
<ul>
<li><code>std::endl</code>：输出换行并刷新</li>
<li><code>flush()</code> 手动刷新</li>
<li>缓冲区满时自动刷新</li>
<li>程序正常退出时自动刷新</li>
<li><code>std::cerr</code> 是<strong>无缓冲</strong>的</li>
</ul>
</li>
</ul>
<h2 id="五重定向流">五、重定向流</h2>
<p>C++ 中流的重定向（redirect）是指改变标准输入输出流（如 <code>std::cout</code>、<code>std::cin</code>）的目标，<strong>使它们指向其他设备（如文件、字符串、网络等）</strong>，而不是默认的控制台（终端）。这对于日志保存、测试、捕获输出都非常有用。</p>
<hr>
<h3 id="重定向-stdcoutstdcerr-到文件">重定向 <code>std::cout</code>、<code>std::cerr</code> 到文件</h3>
<p>方法：修改流缓冲区（<code>streambuf</code>）</p>
<p><code>std::cout</code> 等流对象内部都有一个缓冲区指针 <code>rdbuf()</code>，通过替换它，我们可以让输出写到别处。</p>
<hr>
<h4 id="代码示例把-stdcout-重定向到文件">代码示例：把 <code>std::cout</code> 重定向到文件</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    std::ofstream file("example.txt");
    if (!file) {
        std::cerr &lt;&lt; "打开文件失败！" &lt;&lt; std::endl;
        return 1;
    }

    // 备份原 cout 缓冲区指针
    std::streambuf* old_cout_buf = std::cout.rdbuf();

    // 将 cout 缓冲区指向文件流的缓冲区
    std::cout.rdbuf(file.rdbuf());

    // 现在所有 cout 输出写入文件
    std::cout &lt;&lt; "这行写入了 example.txt 文件" &lt;&lt; std::endl;

    // 恢复原来的缓冲区（输出回终端）
    std::cout.rdbuf(old_cout_buf);

    std::cout &lt;&lt; "这行又输出到终端了" &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<hr>
<h3 id="重定向-stdcin-从文件读取">重定向 <code>std::cin</code> 从文件读取</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    std::ifstream file("/home/fxq/untitled3/example.txt");
    if (!file) {
        std::cerr &lt;&lt; "打开文件失败！" &lt;&lt; std::endl;
        return 1;
    }

    // 备份原 cin 缓冲区指针
    std::streambuf* old_cin_buf = std::cin.rdbuf();

    // 将 cin 缓冲区指向文件流
    std::cin.rdbuf(file.rdbuf());

    std::string line;
    std::getline(std::cin, line);
    std::cout &lt;&lt; "从文件读取的内容: " &lt;&lt; line &lt;&lt; std::endl;

    // 恢复原缓冲区
    std::cin.rdbuf(old_cin_buf);

    return 0;
}
</code></pre>
<hr>
<h3 id="重定向流到字符串内存">重定向流到字符串（内存）</h3>
<p>可以用 <code>std::stringstream</code>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main() {
    std::stringstream ss;
    
    // 重定向 cout 到 stringstream
    std::streambuf* old_buf = std::cout.rdbuf(ss.rdbuf());

    std::cout &lt;&lt; "Hello, 内存流！" &lt;&lt; std::endl;

    // 恢复 cout
    std::cout.rdbuf(old_buf);

    // 获取写入的字符串
    std::string captured = ss.str();
    std::cout &lt;&lt; "捕获的字符串内容是: " &lt;&lt; captured &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<hr>
<h3 id="总结重定向关键点">总结重定向关键点</h3>
<table>
<thead>
<tr>
<th>操作步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>保存旧缓冲区指针</td>
<td><code>std::streambuf* old_buf = stream.rdbuf();</code></td>
</tr>
<tr>
<td>替换缓冲区指针</td>
<td><code>stream.rdbuf(new_stream.rdbuf());</code></td>
</tr>
<tr>
<td>使用新的流进行输入输出</td>
<td>输出会重定向到新流</td>
</tr>
<tr>
<td>恢复原缓冲区指针</td>
<td><code>stream.rdbuf(old_buf);</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="补充命令行重定向">补充：命令行重定向</h3>
<p>操作系统层面也支持重定向，不用代码实现，例如：</p>
<pre><code class="language-bash">./program &gt; output.txt  # 重定向 stdout
./program &lt; input.txt   # 重定向 stdin
./program 2&gt; error.log  # 重定向 stderr
</code></pre>
<hr>
<h2 id="_"></h2>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18959951" target="_blank">https://www.cnblogs.com/aslanvon/p/18959951</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-01 17:08">2025-07-01 17:07</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">61</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18959951);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18959951', targetLink: 'https://www.cnblogs.com/aslanvon/p/18959951', title: 'C++ 流' })">举报</a>
</div>
        