
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18636155" title="发布于 2024-12-27 16:43">
    <span role="heading" aria-level="2">泛型，泛型约束</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="什么是泛型">什么是泛型？</h3>
<p>泛型（Generics） 是一种编程技术，广泛应用于面向对象编程（OOP）中，特别是在C#、Java等现代编程语言中。泛型的核心思想是创建可以在多种数据类型上工作的类、接口和方法，而不需要为每种数据类型单独编写代码。这不仅提高了代码的重用性，还增强了类型安全性，减少了运行时错误。</p>
<p><strong>泛型的主要优点</strong></p>
<ol>
<li>类型安全性：
<ul>
<li>泛型在编译时进行类型检查，确保类型的一致性，减少运行时类型转换错误。</li>
</ul>
</li>
<li>代码重用：
<ul>
<li>通过泛型，可以编写适用于多种数据类型的通用代码，而不需要为每种数据类型编写单独的实现。</li>
</ul>
</li>
<li>性能提升：
<ul>
<li>泛型避免了装箱（boxing）和拆箱（unboxing）操作，提高了性能，特别是在处理值类型时。</li>
</ul>
</li>
<li>可读性和可维护性：
<ul>
<li>泛型代码更易于阅读和维护，因为类型信息在编译时就已经明确。</li>
</ul>
</li>
</ol>
<p><strong>泛型的实现</strong></p>
<ol>
<li>
<p>泛型类：<br>
定义一个类，使其可以处理多种数据类型的实例。</p>
<pre><code> public class Box&lt;T&gt;
 {
 	private T _content;

 	public void SetContent(T content)
 	{
 		_content = content;
 	}

 	public T GetContent()
 	{
 		return _content;
 	}
 }

 public class Program
 {
 	public static void Main()
 	{
 		Box&lt;int&gt; intBox = new Box&lt;int&gt;();
 		intBox.SetContent(42);
 		Console.WriteLine(intBox.GetContent()); // 输出: 42

 		Box&lt;string&gt; stringBox = new Box&lt;string&gt;();
 		stringBox.SetContent("Hello, World!");
 		Console.WriteLine(stringBox.GetContent()); // 输出: Hello, World!
 	}
 }
</code></pre>
</li>
<li>
<p>泛型接口：<br>
定义一个接口，使其可以处理多种数据类型的实例。</p>
<pre><code> public interface IStorage&lt;T&gt;
 {
 	void Store(T item);
 	T Retrieve();
 }

 public class Storage&lt;T&gt; : IStorage&lt;T&gt;
 {
 	private T _item;

 	public void Store(T item)
 	{
 		_item = item;
 	}

 	public T Retrieve()
 	{
 		return _item;
 	}
 }

 public class Program
 {
 	public static void Main()
 	{
 		IStorage&lt;int&gt; intStorage = new Storage&lt;int&gt;();
 		intStorage.Store(100);
 		Console.WriteLine(intStorage.Retrieve()); // 输出: 100

 		IStorage&lt;string&gt; stringStorage = new Storage&lt;string&gt;();
 		stringStorage.Store("Generic Storage");
 		Console.WriteLine(stringStorage.Retrieve()); // 输出: Generic Storage
 	}
 }
</code></pre>
</li>
<li>
<p>泛型方法：<br>
定义一个方法，使其可以处理多种数据类型的参数和返回值。</p>
<pre><code> public class GenericMethods
 {
 	public static T GetDefault&lt;T&gt;() where T : new()
 	{
 		return new T();
 	}

 	public static void Print&lt;T&gt;(T item)
 	{
 		Console.WriteLine(item);
 	}
 }

 public class Program
 {
 	public static void Main()
 	{
 		int defaultInt = GenericMethods.GetDefault&lt;int&gt;();
 		Console.WriteLine(defaultInt); // 输出: 0

 		string defaultString = GenericMethods.GetDefault&lt;string&gt;();
 		Console.WriteLine(defaultString); // 输出: (空字符串)

 		GenericMethods.Print(42); // 输出: 42
 		GenericMethods.Print("Hello, World!"); // 输出: Hello, World!
 	}
 }
</code></pre>
</li>
<li>
<p>泛型约束：<br>
可以为泛型类、接口和方法添加约束，以限制泛型参数的类型。<br>
常见的约束包括：</p>
<ul>
<li>
<p>where T : new()：要求泛型参数必须有一个无参构造函数。</p>
</li>
<li>
<p>where T : class：要求泛型参数必须是引用类型。</p>
</li>
<li>
<p>where T : struct：要求泛型参数必须是值类型。</p>
</li>
<li>
<p>where T : IInterface：要求泛型参数必须实现特定的接口。</p>
</li>
<li>
<p>where T : BaseClass：要求泛型参数必须继承自特定的基类。</p>
<pre><code>  public class GenericConstraint&lt;T&gt; where T : new()
  {
  	public T CreateInstance()
  	{
  		return new T();
  	}
  }

  public class MyClass
  {
  	public void MyMethod()
  	{
  		Console.WriteLine("MyClass instance created.");
  	}
  }

  public class Program
  {
  	public static void Main()
  	{
  		GenericConstraint&lt;MyClass&gt; constraint = new GenericConstraint&lt;MyClass&gt;();
  		MyClass instance = constraint.CreateInstance();
  		instance.MyMethod(); // 输出: MyClass instance created.
  	}
  }
</code></pre>
</li>
</ul>
</li>
<li>
<p>泛型的应用场景<br>
<strong>1.集合类：</strong><br>
泛型集合类（如List&lt;T 、Dictionary&lt;TKey, TValue）提供了类型安全的集合操作。</p>
<pre><code> 	List &lt;int numbers = new List &lt;int();
 	numbers.Add(1);
 	numbers.Add(2);
 	numbers.Add(3);

 	foreach (int number in numbers)
 	{
 		Console.WriteLine(number); // 输出: 1 2 3
 	}
</code></pre>
</li>
</ol>
<p><strong>2.算法和数据结构：</strong><br>
算法和数据结构：</p>
<pre><code>	public class Stack&lt;T&gt;
	{
		private List&lt;T&gt; _elements = new List&lt;T&gt;();

		public void Push(T item)
		{
			_elements.Add(item);
		}

		public T Pop()
		{
			if (_elements.Count == 0)
			{
				throw new InvalidOperationException("Stack is empty.");
			}
			T item = _elements[_elements.Count - 1];
			_elements.RemoveAt(_elements.Count - 1);
			return item;
		}

		public T Peek()
		{
			if (_elements.Count == 0)
			{
				throw new InvalidOperationException("Stack is empty.");
			}
			return _elements[_elements.Count - 1];
		}
	}

	public class Program
	{
		public static void Main()
		{
			Stack&lt;int&gt; intStack = new Stack&lt;int&gt;();
			intStack.Push(1);
			intStack.Push(2);
			Console.WriteLine(intStack.Pop()); // 输出: 2

			Stack&lt;string&gt; stringStack = new Stack&lt;string&gt;();
			stringStack.Push("Hello");
			stringStack.Push("World");
			Console.WriteLine(stringStack.Pop()); // 输出: World
		}
	}
</code></pre>
<p><strong>3.工厂模式</strong><br>
泛型可以用于实现工厂模式，创建不同类型的对象。</p>
<pre><code>	public class Factory&lt;T&gt; where T : new()
	{
		public T Create()
		{
			return new T();
		}
	}

	public class Product
	{
		public void Display()
		{
			Console.WriteLine("Product displayed.");
		}
	}

	public class Service
	{
		public void Execute()
		{
			Console.WriteLine("Service executed.");
		}
	}

	public class Program
	{
		public static void Main()
		{
			Factory&lt;Product&gt; productFactory = new Factory&lt;Product&gt;();
			Product product = productFactory.Create();
			product.Display(); // 输出: Product displayed.

			Factory&lt;Service&gt; serviceFactory = new Factory&lt;Service&gt;();
			Service service = serviceFactory.Create();
			service.Execute(); // 输出: Service executed.
		}
	}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.680930239127315" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 16:43">2024-12-27 16:43</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18636155" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18636155);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18636155', targetLink: 'https://www.cnblogs.com/chenshibao/p/18636155', title: '泛型，泛型约束' })">举报</a>
</div>
        