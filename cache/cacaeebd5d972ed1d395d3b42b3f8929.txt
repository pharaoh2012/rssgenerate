
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/powertoolsteam/p/19012227" title="发布于 2025-07-30 09:12">
    <span role="heading" aria-level="2">.NET 10 中的新增功能系列文章2——ASP.NET Core 中的新增功能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>随着技术的不断演进，.NET 平台持续为开发者带来创新和改进。作为 .NET 生态系统中的重要组成部分，ASP.NET Core 在每个版本中都引入了令人兴奋的新功能和优化。本文将深入探讨 .NET 10 中 ASP.NET Core 的主要更新，特别是 Blazor 框架中的各项增强功能，旨在为开发者提供一个清晰、全面的概述，帮助您更好地利用这些新特性来构建更强大、更安全的 Web 应用程序。我们将重点关注安全性、性能、开发体验和路由方面的改进，并提供相关的代码示例和详细说明。</p>
<h2 id="正文">正文</h2>
<h3 id="blazor-web-app-安全性增强">Blazor Web App 安全性增强</h3>
<p>在 .NET 10 中，Blazor Web App 的安全性得到了显著提升。官方新增并更新了多个安全示例，涵盖了不同的身份验证和授权场景。</p>
<h4 id="1-新的和经过更新的-blazor-web-app-安全示例">1. 新的和经过更新的 Blazor Web App 安全示例</h4>
<p>Blazor Web App 的安全示例得到了全面的更新，主要包括以下几个方面：</p>
<ul>
<li><strong>OpenID Connect (OIDC) 保护</strong>：提供了如何使用 OIDC 保护 Blazor Web App 的详细指南和示例。</li>
<li><strong>Microsoft Entra ID (原 Azure AD) 保护</strong>：更新了使用 Microsoft Entra ID 保护 Blazor Web App 的示例。</li>
<li><strong>Windows 身份验证保护</strong>：新增了使用 Windows 身份验证保护 Blazor Web App 的示例。</li>
</ul>
<p>所有 OIDC 和 Entra 示例解决方案现在都包含一个单独的 Web API 项目 (<code>MinimalApiJwt</code>)，用于演示如何安全地配置和调用外部 Web API。 调用 Web API 的方式通过使用令牌处理程序和具名 HTTP 客户端，来对接 OIDC 身份提供程序，或使用 Microsoft Entra ID 的 Microsoft Identity Web 包/API。</p>
<p>这些示例解决方案在 <code>Program</code> 文件中的 C# 代码中进行配置。此外，还提供了从应用程序设置文件（例如 <code>appsettings.json</code>）配置解决方案的新指南，位于 OIDC 或 Entra 文章的“通过 JSON 配置提供程序（应用设置）提供配置”部分。</p>
<p>Entra 文章和示例应用还包含了关于以下方法的新的指导：</p>
<ul>
<li>如何对 Web 场托管方案使用加密的分布式令牌缓存。</li>
<li>如何将 <a href="https://azure.microsoft.com/products/key-vault/" target="_blank" rel="noopener nofollow">Azure Key Vault</a> 与 <a href="https://learn.microsoft.com/zh-cn/entra/identity/managed-identities-azure-resources/overview" target="_blank" rel="noopener nofollow">Azure 托管标识</a> 配合使用来保护数据。</li>
</ul>
<h3 id="blazor-ui-组件和性能优化">Blazor UI 组件和性能优化</h3>
<h4 id="1-quickgrid-rowclass-参数">1. QuickGrid <code>RowClass</code> 参数</h4>
<p>为了提供更灵活的 UI 样式控制，<code>QuickGrid</code> 组件新增了 <code>RowClass</code> 参数。 开发者现在可以根据行项的特定条件，动态地将样式表类应用于网格的行。 例如，通过定义一个方法，根据 <code>MyGridItem</code> 的 <code>IsArchived</code> 属性来应用不同的 CSS 类：</p>
<pre><code class="language-html">&lt;QuickGrid ... RowClass="GetRowCssClass"&gt;
    ...
&lt;/QuickGrid&gt;

@code {
    private string GetRowCssClass(MyGridItem item) =&gt;
        item.IsArchived ? "row-archived" : null;
}
</code></pre>
<p>这极大地增强了 <code>QuickGrid</code> 的定制能力，使得数据呈现更加直观和富有表现力。</p>
<h4 id="2-关闭-quickgrid-列选项">2. 关闭 <code>QuickGrid</code> 列选项</h4>
<p>现在，可以使用 <code>QuickGrid</code> 的新方法 <code>HideColumnOptionsAsync</code> 关闭列选项的用户界面。 这对于需要在用户执行特定操作（如应用筛选器）后自动关闭列选项的场景非常有用，从而提升用户体验。</p>
<pre><code class="language-html">&lt;QuickGrid @ref="movieGrid" Items="movies"&gt;
    &lt;PropertyColumn Property="@(m =&gt; m.Title)" Title="Title"&gt;
        &lt;ColumnOptions&gt;
            &lt;input type="search" @bind="titleFilter" placeholder="Filter by title" 
                @bind:after="@(() =&gt; movieGrid.HideColumnOptionsAsync())" /&gt;
        &lt;/ColumnOptions&gt;
    &lt;/PropertyColumn&gt;
    &lt;PropertyColumn Property="@(m =&gt; m.Genre)" Title="Genre" /&gt;
    &lt;PropertyColumn Property="@(m =&gt; m.ReleaseYear)" Title="Release Year" /&gt;
&lt;/QuickGrid&gt;

@code {
    private QuickGrid&lt;Movie&gt;? movieGrid;
    private string titleFilter = string.Empty;
    private IQueryable&lt;Movie&gt; movies = new List&lt;Movie&gt; { ... }.AsQueryable();
    private IQueryable&lt;Movie&gt; filteredMovies =&gt; 
        movies.Where(m =&gt; m.Title!.Contains(titleFilter));
}
</code></pre>
<h4 id="3-响应流式处理的默认启用和选择停用">3. 响应流式处理的默认启用和选择停用</h4>
<p>在 .NET 10 之前，<code>HttpClient</code> 请求的响应流式处理是可选启用的，现在默认启用。 这意味着调用 <code>HttpContent.ReadAsStreamAsync</code> 对于 <code>HttpResponseMessage.Content</code>（<code>response.Content.ReadAsStreamAsync()</code>）返回的是 <code>BrowserHttpReadStream</code>，而不再返回 <code>MemoryStream</code>。 <code>BrowserHttpReadStream</code> 不支持同步操作，例如 <code>Stream.Read(Span&lt;Byte&gt;)</code>。 如果代码使用了同步操作，开发者可以选择禁用响应流式处理或手动将 <code>Stream</code> 复制到 <code>MemoryStream</code>。</p>
<p>要选择退出全局响应流式处理，可以在项目文件中添加 <code>&lt;WasmEnableStreamingResponse&gt;false&lt;/WasmEnableStreamingResponse&gt;</code> 属性，或者将 <code>DOTNET_WASM_ENABLE_STREAMING_RESPONSE</code> 环境变量设置为 <code>false</code> 或 <code>0</code>。</p>
<pre><code class="language-xml">&lt;WasmEnableStreamingResponse&gt;false&lt;/WasmEnableStreamingResponse&gt;
</code></pre>
<p>要选择退出单个请求的响应流式处理，可以将 <code>HttpRequestMessage</code> 上的 <code>SetBrowserResponseStreamingEnabled</code> 设置为 <code>false</code>：</p>
<pre><code class="language-c#">requestMessage.SetBrowserResponseStreamingEnabled(false);
</code></pre>
<h4 id="4-blazor-脚本作为静态-web-资产">4. Blazor 脚本作为静态 Web 资产</h4>
<p>为了提升性能和优化资源加载，在 .NET 10 及更高版本中，Blazor 脚本现在被用作具有自动压缩和指纹的静态 Web 资产，而不再从 ASP.NET Core 共享框架中的嵌入资源提供。 这有助于更好地利用浏览器缓存和 CDN，提高应用的加载速度。</p>
<h4 id="5-blazor-webassembly-性能分析和诊断计数器">5. Blazor WebAssembly 性能分析和诊断计数器</h4>
<p>新版本为 Blazor WebAssembly 应用引入了全面的性能分析和诊断计数器。 这些计数器提供了组件生命周期、导航、事件处理和线路管理的详细可观测性，帮助开发者识别和解决性能瓶颈。</p>
<h4 id="6-预加载的-blazor-框架静态资源">6. 预加载的 Blazor 框架静态资源</h4>
<p>在 Blazor Web App 中，框架静态资源使用 <code>Link</code> 头信息自动预加载，这允许浏览器在提取和呈现初始页面之前预加载资源。 在独立 Blazor WebAssembly 应用中，框架资源会被安排为高优先级下载，并在浏览器 <code>index.html</code> 页面处理过程早期进行缓存。 这种机制可以显著缩短应用的首次加载时间。</p>
<h4 id="7-blazor-webassembly-在-blazor-web-app-中静态资源预加载">7. Blazor WebAssembly 在 Blazor Web App 中静态资源预加载</h4>
<p>为了更好地在 Blazor Web App 中预加载 WebAssembly 资产，Blazor 将 <code>&lt;link&gt;</code> 标头替换为 <code>LinkPreload</code> 组件 (<code>&lt;LinkPreload /&gt;</code>)。 这使得应用程序的基路径配置 (<code>&lt;base href="..." /&gt;</code>) 能够正确识别应用程序的根目录。 默认情况下，Blazor Web App 模板在 .NET 10 中采用此特性。 升级到 .NET 10 的应用可以通过在 <code>LinkPreload</code> 组件的头部内容 (<code>&lt;base&gt;</code>) 中，将 <code>App</code> 组件放置在基 URL 标签 (<code>App.razor</code>) 后来实现该功能。</p>
<pre><code class="language-Diff">&lt;head&gt;
    ...
    &lt;base href="/" /&gt;
+   &lt;LinkPreload /&gt;
    ...
&lt;/head&gt;
</code></pre>
<h4 id="8-自定义-blazor-缓存和-blazorcachebootresources-msbuild-属性已删除">8. 自定义 Blazor 缓存和 <code>BlazorCacheBootResources</code> MSBuild 属性已删除</h4>
<p>由于所有 Blazor 客户端文件现在都由浏览器进行指纹标记和缓存，Blazor 的自定义缓存机制和 <code>BlazorCacheBootResources</code> MSBuild 属性已从框架中移除。 开发者应从客户端项目的项目文件中删除此属性，因为它不再有任何影响。</p>
<h3 id="blazor-路由和导航改进">Blazor 路由和导航改进</h3>
<h4 id="1-路由模板要点">1. 路由模板要点</h4>
<p><code>[Route]</code> 属性现在支持路由语法突出显示，以帮助开发者更好地可视化路由模板的结构，从而减少路由配置错误。</p>
<h4 id="2-mapsto-不再滚动到顶部来进行同一页面导航">2. <code>MapsTo</code> 不再滚动到顶部来进行同一页面导航</h4>
<p>以前，<code>NavigationManager.NavigateTo</code> 在进行同一页面导航时会滚动到页面顶部。 在 .NET 10 中，此行为已更改，浏览器在导航到同一页面时不再滚动到页面顶部。 这意味着在更新当前页面的地址（例如更改查询字符串或片段）时不再重置视口，从而提升了用户体验，尤其是在单页应用中。</p>
<h4 id="3-已将重新连接-ui-组件添加到-blazor-web-app-项目模板中">3. 已将重新连接 UI 组件添加到 Blazor Web App 项目模板中</h4>
<p>Blazor Web App 项目模板现在包含一个 <code>ReconnectModal</code> 组件，它包含了并置的样式表和 JavaScript 文件，旨在在客户端失去与服务器的 WebSocket 连接时，改进开发者对重新连接 UI 的控制。 该组件不会以编程方式插入样式，确保符合 <code>style-src</code> 策略更严格的内容安全策略 (CSP) 设置。 新的重新连接 UI 功能包括通过在重新连接 UI 元素上设置特定的 CSS 类来指示重新连接状态，以及调度新的 <code>components-reconnect-state-changed</code> 事件以更改重新连接状态。 代码可以使用 CSS 类和新事件所指示的新重新连接状态“<code>retrying</code>”更好地区分重新连接过程的阶段。</p>
<h4 id="4-使用-navlinkmatchall-时忽略查询字符串和片段">4. 使用 <code>NavLinkMatch.All</code> 时忽略查询字符串和片段</h4>
<p>当使用 <code>NavLink</code> 参数的 <code>NavLinkMatch.All</code> 值时，<code>Match</code> 组件现在将忽略查询字符串和片段。 这意味着如果 URL 路径匹配但查询字符串或片段发生更改，则链接将保留 <code>active</code> 类。 要还原到原始行为，可以将 <code>Microsoft.AspNetCore.Components.Routing.NavLink.EnableMatchAllForQueryStringAndFragment</code> <code>AppContext</code> 开关设置为 <code>true</code>。 开发者也可以通过重写 <code>NavLink</code> 的 <code>ShouldMatch</code> 方法来自定义匹配行为。</p>
<pre><code class="language-c#">public class CustomNavLink : NavLink
{
    protected override bool ShouldMatch(string currentUriAbsolute)
    {
        // Custom matching logic
    }
}
</code></pre>
<h4 id="5-navigationmanagernavigateto-不再抛出异常-navigationexception">5. <code>NavigationManager.NavigateTo</code> 不再抛出异常 <code>NavigationException</code></h4>
<p>以前，在进行静态服务器端渲染 (SSR) 时，调用 <code>NavigationManager.NavigateTo</code> 会在转换为重定向响应前抛出 <code>NavigationException</code>，从而中断执行。 在 .NET 10 中，在静态 SSR 期间调用 <code>NavigationManager.NavigateTo</code> 不再引发 <code>NavigationException</code>。 其行为与交互式呈现一致，执行导航但不会抛出异常。 依赖于 <code>NavigationException</code> 被抛出的代码应进行更新。 例如，在默认 Blazor Identity UI 中，<code>IdentityRedirectManager</code> 过去在调用 <code>RedirectTo</code> 之后抛出一个 <code>InvalidOperationException</code>，以确保它不会在交互式呈现期间被调用。 现在应删除此异常和 <code>[DoesNotReturn]</code> 属性。</p>
<h4 id="6-blazor-路由器具有参数-notfoundpage">6. Blazor 路由器具有参数 <code>NotFoundPage</code></h4>
<p>Blazor 现在提供了一种改进的方法，用于在导航到不存在的页面时显示“找不到”页面。 可以通过使用 <code>NotFoundPage</code> 参数将页面类型传递给组件 <code>Router</code> 来指定在调用 <code>NavigationManager.NotFound</code> 时要呈现的页面。 推荐使用此方式替代 <code>NotFound</code> 的呈现片段 (<code>&lt;NotFound&gt;...&lt;/NotFound&gt;</code>)，因为它支持路由、适配状态码页面重执行中间件，并兼容非 Blazor 场景。 如果同时定义了 <code>NotFound</code> 呈现片段和 <code>NotFoundPage</code>，则以 <code>NotFoundPage</code> 指定的页面优先。</p>
<pre><code class="language-html">&lt;Router AppAssembly="@typeof(Program).Assembly" NotFoundPage="typeof(Pages.NotFound)"&gt;
    &lt;Found Context="routeData"&gt;
        &lt;RouteView RouteData="@routeData" /&gt;
        &lt;FocusOnNavigate RouteData="@routeData" Selector="h1" /&gt;
    &lt;/Found&gt;
    &lt;NotFound&gt;This content is ignored because NotFoundPage is defined.&lt;/NotFound&gt;
&lt;/Router&gt;
</code></pre>
<p>项目 Blazor 模板现在默认包含一个 <code>NotFound.razor</code> 页面。 每当在应用中调用 <code>NavigationManager.NotFound</code> 时，此页面都会自动呈现，从而更轻松地处理缺失路由，并提供一致的用户体验。</p>
<h4 id="7-使用-navigationmanager-处理静态-ssr-和全局交互式呈现中的未找到响应">7. 使用 <code>NavigationManager</code> 处理静态 SSR 和全局交互式呈现中的“未找到”响应</h4>
<p><code>NavigationManager</code> 现在包含一个 <code>NotFound</code> 方法，用于处理在静态服务器端渲染（静态 SSR）或全局交互渲染期间找不到请求资源的情况。</p>
<ul>
<li><strong>静态服务器端呈现 (SSR)</strong>：调用 <code>NotFound</code> 会将 HTTP 状态代码设置为 404。</li>
<li><strong>交互式呈现</strong>：通知 Blazor 路由器 (<code>Router</code> 组件) 呈现“未找到”内容。</li>
<li><strong>流式呈现</strong>：如果增强导航处于活动状态，流式呈现会呈现“未找到”内容，而无需重新加载页面。 当增强的导航被阻止时，框架会重定向到“找不到”内容，并刷新页面。</li>
</ul>
<p>流式 <code>NavigationManager.NotFound</code> 内容呈现使用以下顺序：</p>
<ol>
<li><code>NotFoundPage</code> 传递给 <code>Router</code> 组件（如果存在）。</li>
<li>已配置的状态码页面重执行中间件页面。</li>
<li>如果上述两种方法均未采用，则不采取任何操作。</li>
</ol>
<p>非流式 <code>NavigationManager.NotFound</code> 内容呈现使用以下顺序：</p>
<ol>
<li><code>NotFoundPage</code> 传递给 <code>Router</code> 组件（如果存在）。</li>
<li>若存在“未找到”呈现片段内容，则使用该内容。<em>不建议在 .NET 10 或更高版本中使用。</em></li>
<li><code>DefaultNotFound</code> 404 内容（“<code>Not found</code>”纯文本）。</li>
</ol>
<p><code>UseStatusCodePagesWithReExecute</code> 在处理浏览器地址路由问题（如 URL 输入错误或点击无效链接）时优先。 当 <code>NavigationManager.OnNotFound</code> 被调用时，可以使用 <code>NotFound</code> 事件进行通知。</p>
<h3 id="blazor-开发体验和互操作性">Blazor 开发体验和互操作性</h3>
<h4 id="1-用于保存组件和服务状态的声明性模型">1. 用于保存组件和服务状态的声明性模型</h4>
<p>现在可以通过声明方式指定状态，使其能够通过 <code>[SupplyParameterFromPersistentComponentState]</code> 特性从组件和服务中持久化。 在预呈现期间，具有此属性的属性会通过 <code>PersistentComponentState</code> 服务自动持久化。 当组件以交互方式呈现或实例化服务时，将检索状态。</p>
<p>以前，使用 <code>PersistentComponentState</code> 服务预呈现期间保留组件状态涉及大量代码。 现在可以使用新的声明性模型简化此代码：</p>
<pre><code class="language-html">@page "/movies"
@inject IMovieService MovieService

@if (MoviesList == null)
{
    &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;
}
else
{
    &lt;QuickGrid Items="MoviesList.AsQueryable()"&gt;
        ...
    &lt;/QuickGrid&gt;
}

@code {
    [SupplyParameterFromPersistentComponentState]
    public List&lt;Movie&gt;? MoviesList { get; set; }

    protected override async Task OnInitializedAsync()
    {
        MoviesList ??= await MovieService.GetMoviesAsync();
    }
}
</code></pre>
<p>可以为同一类型的多个组件序列化状态，并且可以在服务中建立声明性状态，通过在 <code>RegisterPersistentService</code> 组件生成器（Razor）上以自定义服务类型和渲染模式调用 <code>AddRazorComponents</code>，以便在整个应用中使用。</p>
<h4 id="2-新的-javascript-互作功能">2. 新的 JavaScript 互作功能</h4>
<p>Blazor 添加了对以下 JS 互操作功能的支持：</p>
<ul>
<li>使用构造函数创建对象的实例 JS，并获取引用实例的 <code>IJSObjectReference</code>/<code>IJSInProcessObjectReference</code> .NET 句柄。</li>
<li>读取或修改 JS 对象属性的值，包括数据属性和访问器属性。</li>
</ul>
<p>以下异步方法在 <code>IJSRuntime</code> 和 <code>IJSObjectReference</code> 上可用：</p>
<ul>
<li>
<p><code>InvokeNewAsync(string identifier, object?[]? args)</code>：异步调用指定的 JS 构造函数。</p>
<pre><code class="language-c#">var classRef = await JSRuntime.InvokeNewAsync("jsInterop.TestClass", "Blazor!");
var text = await classRef.GetValueAsync&lt;string&gt;("text");
var textLength = await classRef.InvokeAsync&lt;int&gt;("getTextLength");
</code></pre>
</li>
<li>
<p><code>GetValueAsync&lt;TValue&gt;(string identifier)</code>：异步读取指定 JS 属性的值。</p>
<pre><code class="language-c#">var valueFromDataPropertyAsync = await JSRuntime.GetValueAsync&lt;int&gt;(
  "jsInterop.testObject.num");
</code></pre>
</li>
<li>
<p><code>SetValueAsync&lt;TValue&gt;(string identifier, TValue value)</code>：异步更新指定 JS 属性的值。</p>
<pre><code class="language-c#">await JSRuntime.SetValueAsync("jsInterop.testObject.num", 30);
</code></pre>
</li>
</ul>
<p>这些方法都有重载版本，可接收 <code>CancellationToken</code> 参数或 <code>TimeSpan</code> 超时时间参数。</p>
<p>以下同步方法可在 <code>IJSInProcessRuntime</code> 和 <code>IJSInProcessObjectReference</code> 上使用：</p>
<ul>
<li>
<p><code>InvokeNew(string identifier, object?[]? args)</code>：同步调用指定的 JS 构造函数。</p>
<pre><code class="language-c#">var inProcRuntime = ((IJSInProcessRuntime)JSRuntime);
var classRef = inProcRuntime.InvokeNew("jsInterop.TestClass", "Blazor!");
var text = classRef.GetValue&lt;string&gt;("text");
var textLength = classRef.Invoke&lt;int&gt;("getTextLength");
</code></pre>
</li>
<li>
<p><code>GetValue&lt;TValue&gt;(string identifier)</code>：同步读取指定 JS 属性的值。</p>
<pre><code class="language-c#">var inProcRuntime = ((IJSInProcessRuntime)JSRuntime);
var valueFromDataProperty = inProcRuntime.GetValue&lt;int&gt;(
  "jsInterop.testObject.num");
</code></pre>
</li>
<li>
<p><code>SetValue&lt;TValue&gt;(string identifier, TValue value)</code>：同步更新指定 JS 属性的值。</p>
<pre><code class="language-c#">var inProcRuntime = ((IJSInProcessRuntime)JSRuntime);
inProcRuntime.SetValue("jsInterop.testObject.num", 20);
</code></pre>
</li>
</ul>
<h4 id="3-javascript-捆绑程序支持">3. JavaScript 捆绑程序支持</h4>
<p>Blazor 的构建输出现在可以通过将 MSBuild 属性 <code>WasmBundlerFriendlyBootConfig</code> 设置为 <code>true</code>，在发布期间生成捆绑程序友好的输出，从而兼容 JavaScript 捆绑程序（如 Gulp、Webpack 和 Rollup）。 这为开发者在 Blazor 应用中使用现有 JavaScript 工具链提供了更大的灵活性。</p>
<h4 id="4-在独立-blazor-webassembly-应用中设置环境">4. 在独立 Blazor WebAssembly 应用中设置环境</h4>
<p>从 .NET 10 开始，<code>Properties/launchSettings.json</code> 文件不再用于控制独立 Blazor WebAssembly 应用中的环境。 现在，开发者应在应用的项目文件（<code>.csproj</code>）中使用 <code>&lt;WasmApplicationEnvironmentName&gt;</code> 属性来设置环境。</p>
<pre><code class="language-xml">&lt;WasmApplicationEnvironmentName&gt;Staging&lt;/WasmApplicationEnvironmentName&gt;
</code></pre>
<p>默认环境为：<code>Development</code>（用于生成）和 <code>Production</code>（用于发布）。</p>
<h4 id="5-内联的启动配置文件">5. 内联的启动配置文件</h4>
<p>Blazor 的启动配置，在 .NET 10 发布之前存在于名为 <code>blazor.boot.json</code> 的文件中，现在已内联到 <code>dotnet.js</code> 脚本中。 这主要影响直接操作 <code>blazor.boot.json</code> 文件的开发者。</p>
<h4 id="6-改进了表单验证">6. 改进了表单验证</h4>
<p>Blazor 现在改进了表单验证功能，包括对验证嵌套对象和集合项的属性的支持。 要选择使用新的验证功能，需要执行以下操作：</p>
<ol>
<li>
<p>在注册服务的文件 <code>Program</code> 中调用扩展方法 <code>AddValidation</code>。</p>
<pre><code class="language-c#">builder.Services.AddValidation();
</code></pre>
</li>
<li>
<p>在 C# 类文件中声明表单模型类型，而不是在组件 Razor (<code>.razor</code>) 中。</p>
</li>
<li>
<p>使用 <code>[ValidatableType]</code> 特性批注根窗体模型类型。</p>
<pre><code class="language-c#">[ValidatableType]
public class Order
{
    public Customer Customer { get; set; } = new();
    public List&lt;OrderItem&gt; OrderItems { get; set; } = [];
}

public class Customer
{
    [Required(ErrorMessage = "Name is required.")]
    public string? FullName { get; set; }

    [Required(ErrorMessage = "Email is required.")]
    public string? Email { get; set; }

    public ShippingAddress ShippingAddress { get; set; } = new();
}
</code></pre>
</li>
</ol>
<p>在组件中，继续使用 <code>DataAnnotationsValidator</code> 组件内部的 <code>EditForm</code> 组件：</p>
<pre><code class="language-html">&lt;EditForm Model="Model"&gt;
    &lt;DataAnnotationsValidator /&gt;

    &lt;h3&gt;Customer Details&lt;/h3&gt;
    &lt;div class="mb-3"&gt;
        &lt;label&gt;
            Full Name
            &lt;InputText @bind-Value="Model!.Customer.FullName" /&gt;
        &lt;/label&gt;
        &lt;ValidationMessage For="@(() =&gt; Model!.Customer.FullName)" /&gt;
    &lt;/div&gt;

    @* ... form continues ... *@
&lt;/EditForm&gt;

@code {
    public Order? Model { get; set; }

    protected override void OnInitialized() =&gt; Model ??= new();

    // ... code continues ...
}
</code></pre>
<p>声明组件（Razor文件）之外的<code>.razor</code>模型类型的要求是由于新的验证功能和Razor编译器本身都使用源生成器。 目前，一个源生成器的输出不能用作另一个源生成器的输入。</p>
<h3 id="aspnet-core-identity-的-web-身份验证-api密钥支持">ASP.NET Core Identity 的 Web 身份验证 API（密钥）支持</h3>
<p>ASP.NET Core Identity 现在支持基于 WebAuthn 和 FIDO2 标准的密钥身份验证。 Web 身份验证（WebAuthn）API，广泛被称为 <em>passkeys</em>，是一种现代的抗钓鱼身份验证方法，通过利用公钥加密和基于设备的身份验证来提高安全性和用户体验。 此功能允许用户使用安全、基于设备的身份验证方法（例如生物识别或安全密钥）在没有密码的情况下登录。 预览版 6 Blazor Web App 项目模板提供现成的密钥管理和登录功能。</p>
<h3 id="线路状态持久性">线路状态持久性</h3>
<p>在服务器端呈现期间，即使与服务器连接长时间断开或主动暂停，Blazor Web App 也可以保留用户会话（电路）状态，只要没有触发整页刷新。 这样，用户就可以在浏览器标签页节流、移动设备用户切换应用、网络中断或主动资源管理（暂停非活动电路）等情况下恢复会话，而不会丢失未保存的工作。</p>
<p>持久化状态所需的服务器资源比持久化线路少：</p>
<ul>
<li>即使断开连接，线路也可能继续执行工作，并消耗 CPU、内存和其他资源。持久化状态仅消耗开发人员控制的固定内存量。</li>
<li>持久化状态表示应用消耗的内存子集，因此服务器不需要跟踪应用的组件和其他服务器端对象。</li>
</ul>
<p>以下两种情况会保留状态：</p>
<ul>
<li><strong>组件状态</strong>：组件用于交互式服务器呈现的状态，例如，从数据库检索到的项目列表或用户正在填写的表单。</li>
<li><strong>作用域服务</strong>：如当前用户这类保存在服务器端服务中的状态。</li>
</ul>
<p>默认情况下，当在 <code>AddInteractiveServerComponents</code> 文件中调用 <code>AddRazorComponents</code> 时，会启用状态持久性。 <code>MemoryCache</code> 是单个应用实例的默认存储实现，存储最多 1,000 条持久化线路两小时，这是可配置的。 开发者可以使用以下选项更改内存提供程序的默认值：</p>
<ul>
<li><code>PersistedCircuitInMemoryMaxRetained</code>：要保留的最大线路数。默认值为 1,000 条线路。</li>
<li><code>PersistedCircuitInMemoryRetentionPeriod</code>：最长保留期是 <code>TimeSpan</code>。默认为 2 小时。</li>
</ul>
<pre><code class="language-c#">services.Configure&lt;CircuitOptions&gt;(options =&gt; {
    options.PersistedCircuitInMemoryMaxRetained = {CIRCUIT COUNT};
    options.PersistedCircuitInMemoryRetentionPeriod = {RETENTION PERIOD};
});
</code></pre>
<p>批注组件属性 <code>[SupplyFromPersistentComponentState]</code> 以启用线路状态持久性。</p>
<pre><code class="language-html">@foreach (var item in Items) {
    &lt;ItemDisplay @key="@($"unique-prefix-{item.Id}")" Item="item" /&gt;
}
@code {
    [SupplyFromPersistentComponentState]
    public List&lt;Item&gt; Items { get; set; }
    protected override async Task OnInitializedAsync()
    {
        Items ??= await LoadItemsAsync();
    }
}
</code></pre>
<p>若要为作用域服务保留状态，请用 <code>[SupplyFromPersistentComponentState]</code> 注解服务属性，将服务添加到服务集合，并调用 <code>RegisterPersistentService</code> 扩展方法：</p>
<pre><code class="language-c#">public class CustomUserService {
    [SupplyFromPersistentComponentState]
    public string UserData { get; set; }
}
services.AddScoped&lt;CustomUserService&gt;();
services.AddRazorComponents()
    .AddInteractiveServerComponents()
    .RegisterPersistentService&lt;CustomUserService&gt;(RenderMode.InteractiveAuto);
</code></pre>
<h3 id="client-side-fingerprinting">Client-side fingerprinting</h3>
<p>在 .NET 10 中，开发者可以选择启用独立 Blazor WebAssembly 应用的 JavaScript 模块的客户端指纹识别功能。 在生成/发布期间的独立 Blazor WebAssembly 应用中，框架使用生成期间计算的值来替代 <code>index.html</code> 中的占位符，以对静态资产进行指纹识别。 指纹会植入到 <code>blazor.webassembly.js</code> 脚本文件名中。</p>
<p>文件中必须存在 <code>wwwroot/index.html</code> 以下标记才能采用指纹功能：</p>
<pre><code class="language-Diff">&lt;head&gt;
    ...
+   &lt;script type="importmap"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    ...
-   &lt;script src="_framework/blazor.webassembly.js"&gt;&lt;/script&gt;
+   &lt;script src="_framework/blazor.webassembly#[.{fingerprint}].js"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>在项目文件中（<code>.csproj</code>），将 <code>&lt;OverrideHtmlAssetPlaceholders&gt;</code> 属性集添加到 <code>true</code>：</p>
<pre><code class="language-diff">&lt;Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net10.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
+   &lt;OverrideHtmlAssetPlaceholders&gt;true&lt;/OverrideHtmlAssetPlaceholders&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>任何带有指纹标记的 <code>index.html</code> 中的脚本都会被框架打上指纹。 例如，名为 <code>scripts.js</code> 的脚本文件位于应用的 <code>wwwroot/js</code> 文件夹中，通过在文件扩展名之前添加 <code>#[.{fingerprint}]</code> 进行指纹处理（<code>.js</code>）：</p>
<pre><code class="language-html">&lt;script src="js/scripts#[.{fingerprint}].js"&gt;&lt;/script&gt;
</code></pre>
<p>若要对独立应用中的其他 JS 模块进行指纹识别，请使用 Blazor WebAssembly 应用的项目文件（<code>&lt;StaticWebAssetFingerprintPattern&gt;</code>）中的 <code>.csproj</code> 属性。</p>
<pre><code class="language-xml">&lt;StaticWebAssetFingerprintPattern Include="JSModule" Pattern="*.mjs" 
  Expression="#[.{fingerprint}]!" /&gt;
</code></pre>
<p>文件自动放置在导入映射中，并在解析 JavaScript 互操作的导入时，浏览器会使用导入映射来解析指纹文件。</p>
<h2 id="结论">结论</h2>
<p>.NET 10 中的 ASP.NET Core 带来了诸多重要更新，特别是 Blazor 框架，它在安全性、性能、用户体验和开发效率方面均有显著提升。 从增强的 Blazor Web App 安全示例、<code>QuickGrid</code> 组件的样式和操作控制，到响应流式处理的默认启用和客户端指纹识别，这些功能都旨在帮助开发者构建更安全、更快速、更易于维护的现代 Web 应用。 新的 JavaScript 互操作功能和声明式状态管理模型也极大地简化了开发流程。 此外，路由和导航的改进，特别是 <code>NavigationManager.NavigateTo</code> 行为的优化以及 <code>NotFoundPage</code> 参数的引入，使得 Blazor 应用的用户体验更加流畅和可控。 密钥身份验证的支持则进一步加强了应用的安全性。 总体而言，.NET 10 的 ASP.NET Core 持续致力于提升开发者的生产力，并为构建高性能的 Web 应用程序提供了更坚实的基础。 开发者应积极探索和利用这些新功能，以充分发挥 .NET 10 的潜力。</p>
<h2 id="系列文章">系列文章</h2>
<p><a href="https://www.cnblogs.com/powertoolsteam/p/19010089" target="_blank">.NET 10 中的新增功能系列文章1——运行时中的新增功能</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <hr>
<br>
<p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">本文是由葡萄城技术开发团队发布，转载请注明出处：<a href="https://www.grapecity.com.cn/" target="_blank">葡萄城官网</a></p>
<!--p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解企业级低代码开发平台，请前往<a href="https://www.grapecity.com.cn/solutions/huozige" target="_blank">活字格</a>
</p><p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解可嵌入您系统的在线 Excel，请前往<a href="https://www.grapecity.com.cn/developer/spreadjs" target="_blank">SpreadJS纯前端表格控件</a></p>
<p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解嵌入式的商业智能和报表软件，请前往<a href="https://www.grapecity.com.cn/solutions/wyn" target="_blank">Wyn Enterprise
</a></p-->

<br>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-30 09:13">2025-07-30 09:12</span>&nbsp;
<a href="https://www.cnblogs.com/powertoolsteam">葡萄城技术团队</a>&nbsp;
阅读(<span id="post_view_count">278</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19012227);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19012227', targetLink: 'https://www.cnblogs.com/powertoolsteam/p/19012227', title: '.NET 10 中的新增功能系列文章2——ASP.NET Core 中的新增功能' })">举报</a>
</div>
        