
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18671729" title="发布于 2025-01-16 08:15">
    <span role="heading" aria-level="2">SpringBoot的两种启动方式原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="使用内置tomcat启动">使用内置tomcat启动</h2>
<h3 id="配置案例">配置案例</h3>
<h4 id="启动方式">启动方式</h4>
<ol>
<li>
<p>IDEA中main函数启动</p>
</li>
<li>
<p>mvn springboot-run</p>
</li>
<li>
<p>java -jar XXX.jar<br>
使用这种方式时，为保证服务在后台运行，会使用nohup</p>
<pre><code class="language-java">nohup java -jar -Xms128m -Xmx128m -Xss256k -XX:+PrintGCDetails -XX:+PrintHeapAtGC -Xloggc:/data/log/web-gc.log web.jar &gt;/data/log/web.log &amp;
</code></pre>
<p>使用java -jar默认情况下，不会启动任何嵌入式Application Server，该命令只是启动一个执行jar main的JVM进程，当spring-boot-starter-web包含嵌入式tomcat服务器依赖项时，执行java -jar则会启动Application Server</p>
</li>
</ol>
<h4 id="配置内置tomcat属性">配置内置tomcat属性</h4>
<p>关于Tomcat的属性都在 <code>org.springframework.boot.autoconfigure.web.ServerProperties</code> 配置类中做了定义，我们只需在application.properties配置属性做配置即可。通用的Servlet容器配置都以 <code>server</code> 作为前缀</p>
<pre><code class="language-bash">#配置程序端口，默认为8080
server.port= 8080
#用户会话session过期时间，以秒为单位
server.session.timeout=
#配置默认访问路径，默认为/
server.context-path=
</code></pre>
<p>而Tomcat特有配置都以 <code>server.tomcat</code> 作为前缀</p>
<pre><code class="language-bash"># 配置Tomcat编码,默认为UTF-8
server.tomcat.uri-encoding=UTF-8
# 配置最大线程数
server.tomcat.max-threads=1000
</code></pre>
<blockquote>
<p>注意：使用内置tomcat不需要有tomcat-embed-jasper和spring-boot-starter-tomcat依赖，因为在spring-boot-starter-web依赖中已经集成了tomcat</p>
</blockquote>
<h3 id="原理">原理</h3>
<h4 id="从main函数说起">从main函数说起</h4>
<pre><code class="language-java">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {
    return run(new Class[]{primarySource}, args);
}
 
// 这里run方法返回的是ConfigurableApplicationContext
public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {
 	return (new SpringApplication(primarySources)).run(args);
}
</code></pre>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
 ConfigurableApplicationContext context = null;
 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();
 this.configureHeadlessProperty();
 SpringApplicationRunListeners listeners = this.getRunListeners(args);
 listeners.starting();
 
 Collection exceptionReporters;
 try {
  ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
  ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
  this.configureIgnoreBeanInfo(environment);
  
  //打印banner，这里可以自己涂鸦一下，换成自己项目的logo
  Banner printedBanner = this.printBanner(environment);
  
  //创建应用上下文
  context = this.createApplicationContext();
  exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
 
  //预处理上下文
  this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
  
  //刷新上下文
  this.refreshContext(context);
  
  //再刷新上下文
  this.afterRefresh(context, applicationArguments);
  
  listeners.started(context);
  this.callRunners(context, applicationArguments);
 } catch (Throwable var10) {
  
 }
 
 try {
  listeners.running(context);
  return context;
 } catch (Throwable var9) {
  
 }
}
</code></pre>
<p>既然我们想知道tomcat在SpringBoot中是怎么启动的，那么run方法中，重点关注创建应用上下文（createApplicationContext）和刷新上下文（refreshContext）。</p>
<h4 id="创建上下文">创建上下文</h4>
<pre><code class="language-java">//创建上下文
protected ConfigurableApplicationContext createApplicationContext() {
 Class&lt;?&gt; contextClass = this.applicationContextClass;
 if (contextClass == null) {
  try {
   switch(this.webApplicationType) {
    case SERVLET:
                    //创建AnnotationConfigServletWebServerApplicationContext
        contextClass = Class.forName("org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext");
     break;
    case REACTIVE:
     contextClass = Class.forName("org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext");
     break;
    default:
     contextClass = Class.forName("org.springframework.context.annotation.AnnotationConfigApplicationContext");
   }
  } catch (ClassNotFoundException var3) {
   throw new IllegalStateException("Unable create a default ApplicationContext, please specify an ApplicationContextClass", var3);
  }
 }
 
 return (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);
}
</code></pre>
<p>这里会创建AnnotationConfigServletWebServerApplicationContext类。而AnnotationConfigServletWebServerApplicationContext类继承了ServletWebServerApplicationContext，而这个类是最终集成了AbstractApplicationContext。</p>
<h4 id="刷新上下文">刷新上下文</h4>
<pre><code class="language-java">//SpringApplication.java
//刷新上下文
private void refreshContext(ConfigurableApplicationContext context) {
 this.refresh(context);
 if (this.registerShutdownHook) {
  try {
   context.registerShutdownHook();
  } catch (AccessControlException var3) {
  }
 }
}
 
//这里直接调用最终父类AbstractApplicationContext.refresh()方法
protected void refresh(ApplicationContext applicationContext) {
 ((AbstractApplicationContext)applicationContext).refresh();
}
</code></pre>
<pre><code class="language-java">//AbstractApplicationContext.java
public void refresh() throws BeansException, IllegalStateException {
 synchronized(this.startupShutdownMonitor) {
  this.prepareRefresh();
  ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
  this.prepareBeanFactory(beanFactory);
 
  try {
   this.postProcessBeanFactory(beanFactory);
   this.invokeBeanFactoryPostProcessors(beanFactory);
   this.registerBeanPostProcessors(beanFactory);
   this.initMessageSource();
   this.initApplicationEventMulticaster();
   //调用各个子类的onRefresh()方法，也就说这里要回到子类：ServletWebServerApplicationContext，调用该类的onRefresh()方法
   this.onRefresh();
   this.registerListeners();
   this.finishBeanFactoryInitialization(beanFactory);
   this.finishRefresh();
  } catch (BeansException var9) {
   this.destroyBeans();
   this.cancelRefresh(var9);
   throw var9;
  } finally {
   this.resetCommonCaches();
  }
 
 }
}
</code></pre>
<pre><code class="language-java">//ServletWebServerApplicationContext.java
//在这个方法里看到了熟悉的面孔，this.createWebServer，神秘的面纱就要揭开了。
protected void onRefresh() {
 super.onRefresh();
 try {
  this.createWebServer();
 } catch (Throwable var2) {
  
 }
}
 
//ServletWebServerApplicationContext.java
//这里是创建webServer，但是还没有启动tomcat，这里是通过ServletWebServerFactory创建，那么接着看下ServletWebServerFactory
private void createWebServer() {
 WebServer webServer = this.webServer;
 ServletContext servletContext = this.getServletContext();
 if (webServer == null &amp;&amp; servletContext == null) {
  ServletWebServerFactory factory = this.getWebServerFactory();
  this.webServer = factory.getWebServer(new ServletContextInitializer[]{this.getSelfInitializer()});
 } else if (servletContext != null) {
  try {
   this.getSelfInitializer().onStartup(servletContext);
  } catch (ServletException var4) {
  
  }
 }
 
 this.initPropertySources();
}
 
//接口
public interface ServletWebServerFactory {
    WebServer getWebServer(ServletContextInitializer... initializers);
}
 
//实现
AbstractServletWebServerFactory
JettyServletWebServerFactory
TomcatServletWebServerFactory
UndertowServletWebServerFactory
</code></pre>
<p>这里ServletWebServerFactory接口有4个实现类，对应着四种容器：</p>
<p>而其中我们常用的有两个：TomcatServletWebServerFactory和JettyServletWebServerFactory。</p>
<pre><code class="language-java">//TomcatServletWebServerFactory.java
//这里我们使用的tomcat，所以我们查看TomcatServletWebServerFactory。到这里总算是看到了tomcat的踪迹。
@Override
public WebServer getWebServer(ServletContextInitializer... initializers) {
 Tomcat tomcat = new Tomcat();
 File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir("tomcat");
 tomcat.setBaseDir(baseDir.getAbsolutePath());
    //创建Connector对象
 Connector connector = new Connector(this.protocol);
 tomcat.getService().addConnector(connector);
 customizeConnector(connector);
 tomcat.setConnector(connector);
 tomcat.getHost().setAutoDeploy(false);
 configureEngine(tomcat.getEngine());
 for (Connector additionalConnector : this.additionalTomcatConnectors) {
  tomcat.getService().addConnector(additionalConnector);
 }
 prepareContext(tomcat.getHost(), initializers);
 return getTomcatWebServer(tomcat);
}
 
protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
 return new TomcatWebServer(tomcat, getPort() &gt;= 0);
}
 
//Tomcat.java
//返回Engine容器，看到这里，如果熟悉tomcat源码的话，对engine不会感到陌生。
public Engine getEngine() {
    Service service = getServer().findServices()[0];
    if (service.getContainer() != null) {
        return service.getContainer();
    }
    Engine engine = new StandardEngine();
    engine.setName( "Tomcat" );
    engine.setDefaultHost(hostname);
    engine.setRealm(createDefaultRealm());
    service.setContainer(engine);
    return engine;
}
//Engine是最高级别容器，Host是Engine的子容器，Context是Host的子容器，Wrapper是Context的子容器
</code></pre>
<p>getWebServer这个方法创建了Tomcat对象，并且做了两件重要的事情：把Connector对象添加到tomcat中，configureEngine(tomcat.getEngine());</p>
<p>getWebServer方法返回的是TomcatWebServer。</p>
<pre><code class="language-java">//TomcatWebServer.java
//这里调用构造函数实例化TomcatWebServer
public TomcatWebServer(Tomcat tomcat, boolean autoStart) {
 Assert.notNull(tomcat, "Tomcat Server must not be null");
 this.tomcat = tomcat;
 this.autoStart = autoStart;
 initialize();
}
 
private void initialize() throws WebServerException {
    //在控制台会看到这句日志
 logger.info("Tomcat initialized with port(s): " + getPortsDescription(false));
 synchronized (this.monitor) {
  try {
   addInstanceIdToEngineName();
 
   Context context = findContext();
   context.addLifecycleListener((event) -&gt; {
    if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {
     removeServiceConnectors();
    }
   });
 
   //===启动tomcat服务===
   this.tomcat.start();
 
   rethrowDeferredStartupExceptions();
 
   try {
    ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
   }
   catch (NamingException ex) {
                
   }
            
            //开启阻塞非守护进程
   startDaemonAwaitThread();
  }
  catch (Exception ex) {
   stopSilently();
   destroySilently();
   throw new WebServerException("Unable to start embedded Tomcat", ex);
  }
 }
}
</code></pre>
<pre><code class="language-java">//Tomcat.java
public void start() throws LifecycleException {
 getServer();
 server.start();
}
//这里server.start又会回到TomcatWebServer的
public void stop() throws LifecycleException {
 getServer();
 server.stop();
}
</code></pre>
<pre><code class="language-java">//TomcatWebServer.java
//启动tomcat服务
@Override
public void start() throws WebServerException {
 synchronized (this.monitor) {
  if (this.started) {
   return;
  }
  try {
   addPreviouslyRemovedConnectors();
   Connector connector = this.tomcat.getConnector();
   if (connector != null &amp;&amp; this.autoStart) {
    performDeferredLoadOnStartup();
   }
   checkThatConnectorsHaveStarted();
   this.started = true;
   //在控制台打印这句日志，如果在yml设置了上下文，这里会打印
   logger.info("Tomcat started on port(s): " + getPortsDescription(true) + " with context path '"
     + getContextPath() + "'");
  }
  catch (ConnectorStartFailedException ex) {
   stopSilently();
   throw ex;
  }
  catch (Exception ex) {
   throw new WebServerException("Unable to start embedded Tomcat server", ex);
  }
  finally {
   Context context = findContext();
   ContextBindings.unbindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
  }
 }
}
 
//关闭tomcat服务
@Override
public void stop() throws WebServerException {
 synchronized (this.monitor) {
  boolean wasStarted = this.started;
  try {
   this.started = false;
   try {
    stopTomcat();
    this.tomcat.destroy();
   }
   catch (LifecycleException ex) {
    
   }
  }
  catch (Exception ex) {
   throw new WebServerException("Unable to stop embedded Tomcat", ex);
  }
  finally {
   if (wasStarted) {
    containerCounter.decrementAndGet();
   }
  }
 }
}
</code></pre>
<h2 id="使用外置tomcat部署">使用外置tomcat部署</h2>
<h3 id="配置案例-1">配置案例</h3>
<p><a href="https://github.com/Seven-97/SpringBoot-Demo/tree/master/02-helloworld-tomcat" target="_blank" rel="noopener nofollow">外置Tomcat启动SpringBoot源码点击这里</a></p>
<h4 id="继承springbootservletinitializer">继承SpringBootServletInitializer</h4>
<ul>
<li>外部容器部署的话，就不能依赖于Application的main函数了，而是要以类似于web.xml文件配置的方式来启动Spring应用上下文，此时需要在启动类中继承SpringBootServletInitializer，并重写configure方法；还添加 @SpringBootApplication 注解，这是为了能扫描到所有Spring注解的bean</li>
</ul>
<p>方式一：启动类继承SpringBootServletInitializer实现configure：</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringBootHelloWorldTomcatApplication extends SpringBootServletInitializer {
	@Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(Application.class);
    }
}
</code></pre>
<p>这个类的作用与在web.xml中配置负责初始化Spring应用上下文的监听器作用类似，只不过在这里不需要编写额外的XML文件了。</p>
<p>方式二：新增加一个类继承SpringBootServletInitializer实现configure：</p>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        //此处的Application.class为带有@SpringBootApplication注解的启动类
        return builder.sources(Application.class);
    }
}
</code></pre>
<h4 id="pomxml修改tomcat相关的配置">pom.xml修改tomcat相关的配置</h4>
<p>首先需要将 jar 变成war <code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<p>如果要将<strong>最终的打包形式改为war</strong>的话，还需要对pom.xml文件进行修改，因为spring-boot-starter-web中包含内嵌的tomcat容器，所以直接部署在外部容器会冲突报错。因此需要将内置tomcat排除</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>在这里需要移除对嵌入式Tomcat的依赖，这样打出的war包中，在lib目录下才不会包含Tomcat相关的jar包，否则将会出现启动错误。</p>
<p>但是移除了tomcat后，原始的sevlet也被移除了，因此还需要额外引入servet的包</p>
<pre><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="注意的问题">注意的问题</h4>
<p>此时打成的包的名称应该和 application.properties 的 server.context-path=/test 保持一致</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;finalName&gt;test&lt;/finalName&gt;
&lt;/build&gt;
</code></pre>
<p>如果不一样发布到tomcat的webapps下上下文会变化</p>
<h3 id="原理-1">原理</h3>
<p>tomcat不会主动去启动springboot应用 ，， 所以tomcat启动的时候肯定调用了<strong>SpringBootServletInitializer</strong>的SpringApplicationBuilder ， 就会启动springboot。</p>
<blockquote>
<p>ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名。当servlet容器启动时候就会去该文件中找到ServletContainerInitializer的实现类，从而创建它的实例调用onstartUp。这里就是用了<a href="https://www.seven97.top/java/basis/06-SPI.html" target="_blank" rel="noopener nofollow">SPI机制</a></p>
</blockquote>
<h4 id="handlestypeswebapplicationinitializerclass">HandlesTypes(WebApplicationInitializer.class)</h4>
<ul>
<li>@HandlesTypes传入的类为ServletContainerInitializer感兴趣的</li>
<li>容器会自动在classpath中找到 WebApplicationInitializer，会传入到onStartup方法的webAppInitializerClasses中</li>
<li><code>Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses</code>这里面也包括之前定义的TomcatStartSpringBoot</li>
</ul>
<pre><code class="language-java">@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {
</code></pre>
<pre><code class="language-java">@Override
public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
      throws ServletException {

   List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();

   if (webAppInitializerClasses != null) {
      for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {
        // 如果不是接口 不是抽象 跟WebApplicationInitializer有关系  就会实例化
         if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
               WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
            try {
               initializers.add((WebApplicationInitializer)
                     ReflectionUtils.accessibleConstructor(waiClass).newInstance());
            }
            catch (Throwable ex) {
               throw new ServletException("Failed to instantiate WebApplicationInitializer class", ex);
            }
         }
      }
   }

   if (initializers.isEmpty()) {
      servletContext.log("No Spring WebApplicationInitializer types detected on classpath");
      return;
   }

   servletContext.log(initializers.size() + " Spring WebApplicationInitializers detected on classpath");
   // 排序
   AnnotationAwareOrderComparator.sort(initializers);
   for (WebApplicationInitializer initializer : initializers) {
      initializer.onStartup(servletContext);
   }
}
</code></pre>
<pre><code class="language-java">@Override
public void onStartup(ServletContext servletContext) throws ServletException {
   // Logger initialization is deferred in case an ordered
   // LogServletContextInitializer is being used
   this.logger = LogFactory.getLog(getClass());
   WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext);
   if (rootApplicationContext != null) {
      servletContext.addListener(new SpringBootContextLoaderListener(rootApplicationContext, servletContext));
   }
   else {
      this.logger.debug("No ContextLoaderListener registered, as createRootApplicationContext() did not "
            + "return an application context");
   }
}
</code></pre>
<h4 id="springbootservletinitializer">SpringBootServletInitializer</h4>
<pre><code class="language-java">protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
   SpringApplicationBuilder builder = createSpringApplicationBuilder();
   builder.main(getClass());
   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
   if (parent != null) {
      this.logger.info("Root context already created (using as parent).");
      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
      builder.initializers(new ParentContextApplicationContextInitializer(parent));
   }
   builder.initializers(new ServletContextApplicationContextInitializer(servletContext));
   builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class);
   // 调用configure
   builder = configure(builder); //①
   builder.listeners(new WebEnvironmentPropertySourceInitializer(servletContext));
   SpringApplication application = builder.build();//②
   if (application.getAllSources().isEmpty()
         &amp;&amp; MergedAnnotations.from(getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) {
      application.addPrimarySources(Collections.singleton(getClass()));
   }
   Assert.state(!application.getAllSources().isEmpty(),
         "No SpringApplication sources have been defined. Either override the "
               + "configure method or add an @Configuration annotation");
   // Ensure error pages are registered
   if (this.registerErrorPageFilter) {
      application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));
   }
   application.setRegisterShutdownHook(false);
   return run(application);//③
}
</code></pre>
<p>① 当调用configure就会来到TomcatStartSpringBoot .configure，将Springboot启动类传入到builder.source</p>
<pre><code class="language-java">@Override
protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
    return builder.sources(Application.class);
}
</code></pre>
<p>② 调用SpringApplication application = builder.build(); 就会根据传入的Springboot启动类来构建一个SpringApplication</p>
<pre><code class="language-java">public SpringApplication build(String... args) {
   configureAsChildIfNecessary(args);
   this.application.addPrimarySources(this.sources);
   return this.application;
}
</code></pre>
<p>③ 调用 return run(application); 就会启动springboot应用</p>
<pre><code class="language-java">protected WebApplicationContext run(SpringApplication application) {
   return (WebApplicationContext) application.run();
}
</code></pre>
<p>也就相当于Main函数启动：</p>
<pre><code class="language-java">public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
</code></pre>
<p>之后的流程就与上面 使用内置Tomcat的Main函数一致了</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3359381399664352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 08:15">2025-01-16 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">187</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18671729" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18671729);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18671729', targetLink: 'https://www.cnblogs.com/seven97-top/p/18671729', title: 'SpringBoot的两种启动方式原理' })">举报</a>
</div>
        