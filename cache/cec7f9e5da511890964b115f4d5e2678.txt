
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18717951" title="发布于 2025-02-16 20:50">
    <span role="heading" aria-level="2">你的边比较松弛：最短路的 Bellman-Ford 和 SPFA 方法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="dijkstra-的局限性">Dijkstra 的局限性</h2>
<p>在带权图的最短路径问题中，我们的目标是从一个起点出发，找到到达其他所有节点的<strong>最短路径</strong>。无论是交通导航中的最短耗时路线，还是金融网络中的最小成本路径，这一问题的核心始终是<strong>如何在复杂权重关系中寻找最优解</strong>。</p>
<p>经典算法Dijkstra凭借其<strong>贪心策略</strong>和<strong>优先队列优化</strong>，成为解决非负权图最短路径的标杆：</p>
<ul>
<li><strong>核心思想</strong>：每次选择当前距离起点最近的节点，逐步向外“扩散”确认最短路径。</li>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O((V+E)\log V)\)</span>（优先队列实现），在稠密图中表现优异。</li>
</ul>
<p>但这一算法背后隐藏着一个<strong>致命前提</strong>——<strong>所有边的权重必须非负</strong>。</p>
<p><strong>Dijkstra的“傲慢”与困境</strong><br>
想象这样一个场景：</p>
<blockquote>
<p>起点为<span class="math inline">\(A\)</span>，路径<span class="math inline">\(A \to B \to C\)</span>的总权重为<span class="math inline">\(3 + (-4) = -1\)</span>，而Dijkstra可能已经提前确认了<span class="math inline">\(A \to C\)</span>的“最短路径”为权重<span class="math inline">\(5\)</span>。此时，负权边<span class="math inline">\(B \to C\)</span>的存在，使得实际更优的路径被彻底忽略。</p>
</blockquote>
<p><strong>根本矛盾</strong>在于：Dijkstra通过“锁定”已访问节点的最短路径来保证效率，但这种“傲慢”的确定性策略，在面对负权边时反而成为枷锁——已锁定的节点无法被重新修正。</p>
<h4 id="破局之道松弛relaxation的哲学"><strong>破局之道：松弛（Relaxation）的哲学</strong></h4>
<p>“刚不可久，柔不可守”，面对负权边的挑战，我们需要一种<strong>柔性动态更新</strong>的机制。这便是<strong>松弛操作</strong>：</p>
<p></p><div class="math display">\[d[v] = \min(d[v], d[u] + w(u, v)) 
\]</div><p></p><ul>
<li><strong>核心意义</strong>：这和 dijstra 的更新操作相同。但是，在负边情况下，要允许节点距离值被反复修正。每一条边 <span class="math inline">\((u, v)\)</span> 都可能反复用来更新，即“走我能不能让路更短？”</li>
<li><strong>动态性</strong>：与Dijkstra的“刚性锁定”不同，松弛操作承认路径的<strong>不确定性</strong>，通过多轮迭代逼近最优解。</li>
</ul>
<h2 id="最短路径与负权环的矛盾">最短路径与负权环的矛盾</h2>
<h3 id="最短路径的黑洞">最短路径的“黑洞”</h3>
<p>通常的最短路算法不限制重复经过节点和边，对于正权图来说无所谓，重复过边徒增权重，没有任何好处；但是对于负权图来说，负权环的存在将直接冲击最短路问题的定义。</p>
<p>在带权图中，若存在一个环路，其<strong>总权重为负数</strong>（即绕行一圈后路径成本反而降低），则称其为<strong>负权环</strong>（Negative Weight Cycle）。数学表达式为：</p>
<p></p><div class="math display">\[\sum_{i=1}^{k} w(v_{i}, v_{i+1}) &lt; 0 \quad \text{（其中 } v_{k+1}=v_1\text{）}
\]</div><p></p><p>例如，图中环路 <span class="math inline">\(A \to B \to C \to A\)</span> 的权重依次为 <span class="math inline">\(2, -3, -1\)</span>，总权重为 <span class="math inline">\(-2\)</span>，这便是典型的负权环。</p>
<p>一旦起点到某个负权环存在可达路径，最短路径问题将<strong>失去意义</strong>：每次绕行负权环，总路径权重减少。理论上，路径可以无限次绕环，导致总权重趋向 <span class="math inline">\(-\infty\)</span>。这张图也就不存在最短路了。</p>
<p>例如下图中，从节点<span class="math inline">\(S\)</span>出发，经过路径<span class="math inline">\(S \to A \to B \to C \to A\)</span>后，每绕行一次环路<span class="math inline">\(A \to B \to C \to A\)</span>，总权重减少2。因此，<span class="math inline">\(S\)</span>到<span class="math inline">\(C\)</span>的“最短路径”可以无限优化，最终没有最小值。</p>
<h3 id="负环检测">负环检测</h3>
<p>负权环的存在挑战了我们对“最短路径”的直觉认知。在现实世界中，物理距离不可能为负，但抽象问题（如金融清算、能耗优化）中<strong>负权重广泛存在</strong>。例如：</p>
<ul>
<li><strong>金融网络</strong>：A向B转账手续费为-2元（即B实际收到+2元）。</li>
<li><strong>能量回收系统</strong>：机器人移动时，下坡路段可回收能量，视为负权边。</li>
</ul>
<p>任何声称支持负权边的算法，都必须具备<strong>负权环检测能力</strong>，否则可能在遇到负环时陷入死循环，或输出错误结果。这种检测本质上是对算法<strong>收敛性</strong>的验证：若图中存在负权环，算法需明确报告“无解”，而非尝试计算不存在的“最短路径”。例如网络路由协议中，需避免数据包因路径成本无限降低而在环路中永久循环。</p>
<h2 id="bellman-ford算法">Bellman-Ford算法</h2>
<p>Bellman-Ford算法的核心可以用一句话概括：<strong>穷举所有可能的路径更新</strong>。</p>
<ul>
<li><strong>暴力松弛策略</strong>：对图中所有边进行<span class="math inline">\(V-1\)</span>轮松弛操作（<span class="math inline">\(V\)</span>为节点数）</li>
<li><strong>数学基础</strong>：在无负权环的图中，任意两节点间的最短路径最多包含<span class="math inline">\(V-1\)</span>条边</li>
</ul>
<p>算法对所有边进行地毯式扫描。尝试用每一条边更新最短路径。只要没有负环，一条最短路径最多长<span class="math inline">\(V-1\)</span>，所以最多执行<span class="math inline">\(V-1\)</span>轮“地毯式松弛”。</p>
<pre><code class="language-cpp">class Graph {
    struct Edge {
        int to, weight, index;
        Edge(int t, int w, int i) : to(t), weight(w), index(i) {}
    };
    vector&lt;vector&lt;Edge&gt;&gt; adj; // 邻接表
    int n;
public:
    Graph(int n) : n(n), adj(n) {}

    void addEdge(int u, int v, int w, int i) {
        adj[u].emplace_back(v, w, i);
    }

    vector&lt;int&gt; bellmanFord(int s) {
        vector&lt;int&gt; dist(n, INT_MAX);
        dist[s] = 0;
        for (int i = 0; i &lt; n-1; ++i) {
            for (int u = 0; u &lt; n; ++u) {
                for (auto &amp;e : adj[u]) {
                    if (dist[u] != INT_MAX &amp;&amp; dist[e.to] &gt; dist[u] + e.weight) {
                        dist[e.to] = dist[u] + e.weight;
                    }
                }
            }
        }

        // 检测负环
        for (int u = 0; u &lt; n; ++u) {
            for (auto &amp;e : adj[u]) {
                if (dist[u] != INT_MAX &amp;&amp; dist[e.to] &gt; dist[u] + e.weight) {
                    return {}; // 存在负环
                }
            }
        } return dist;
    }
};
</code></pre>
<p>即使有负环，也可能某一些点仍存在最短路，代码里简略起见，存在负环则直接结束算法。另外，该条件为<strong>充分不必要条件</strong>，检测的是顶点出发可到达的负环。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p></p><div class="math display">\[O(V \cdot E) 
\]</div><p></p><ul>
<li><strong>最坏案例</strong>：完全图（<span class="math inline">\(E=V^2\)</span>）时复杂度达<span class="math inline">\(O(V^3)\)</span></li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(V)\)</span>（仅需存储节点距离）</li>
</ul>
<p>与Dijkstra算法的对比：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Dijkstra（二叉堆）</th>
<th>Bellman-Ford</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般</td>
<td><span class="math inline">\(O(E\log V)\)</span></td>
<td><span class="math inline">\(O(VE)\)</span></td>
</tr>
<tr>
<td>稀疏图（树状）</td>
<td><span class="math inline">\(O(V\log V)\)</span></td>
<td><span class="math inline">\(O(V^2)\)</span></td>
</tr>
<tr>
<td>稠密图</td>
<td><span class="math inline">\(O(V^2\log V)\)</span></td>
<td><span class="math inline">\(O(V^3)\)</span></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="负环检测第v轮的启示录">负环检测：第V轮的启示录</h3>
<p>在完成<span class="math inline">\(V-1\)</span>轮松弛后，算法会进行<strong>最终审判</strong>：若无负环，所有最短路径应已确定。若第<span class="math inline">\(V\)</span>轮仍能松弛，说明存在<strong>可无限优化的路径</strong>，即负权环</p>
<h2 id="spfa-算法队列版-bellman-ford">SPFA 算法：队列版 Bellman-Ford</h2>
<p>Bellman-Ford 的全量松弛策略虽然最终能完成，但过程中浪费了大量无效松弛操作。例如在下图所示的链状结构中：</p>
<pre><code>A → B → C → D → E
</code></pre>
<p>每一轮外层循环只能将更新向前推进一个节点，导致大量重复计算。只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。我们可以请回从源点逐渐延申的思路，只有某个节点<span class="math inline">\(u\)</span>的距离被更新后，其邻居<span class="math inline">\(v\)</span>才有可能需要更新，所以可以用队列动态维护待处理节点，避免全图扫描。当然，因为负权边的存在，一个节点可能会反复入队列。</p>
<p>首先将源点距离标记为 0 并入队，此后总是从队列中取出节点，并松弛周围的边；若松弛成功，则被更新的节点也可能再去优化其他节点，将其也入队，直到队列空。</p>
<p>SPFA（Shortest Path Faster Algorithm）的命名充满戏剧性：1994年由西南交通大学段凡丁提出，原论文命名为“改进的Bellman-Ford算法”。因其在随机数据中的卓越表现，算法社区赋予了这个“昵称”。</p>
<pre><code class="language-cpp">// ...
vector&lt;int&gt; spfa(int s) {
    vector&lt;int&gt; dist(n, INT_MAX);
    vector&lt;bool&gt; inq(n, false);
    vector&lt;int&gt; cnt(n, 0);

    queue&lt;int&gt; q;
    dist[s] = 0;
    inq[s] = true;
    q.push(s);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;

        for (auto &amp;e : adj[u]) {
            if (dist[u] != INT_MAX &amp;&amp; dist[e.to] &gt; dist[u] + e.weight) {
                dist[e.to] = dist[u] + e.weight;

                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;

                    if (++cnt[e.to] &gt; n) {
                        return {}; // 存在负环
                    }
                }
            }
        }
    } return dist;
}

</code></pre>
<h3 id="效率">效率</h3>
<p>SPFA 反而更加符合人类直觉，并且在随机图上效率非常优秀，接近线性。但最坏情况下仍会退化为 Bellman-Ford</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>时间复杂度</th>
<th>类比说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机稀疏图</td>
<td><span class="math inline">\(O(E)\)</span></td>
<td>更新波快速衰减</td>
</tr>
<tr>
<td>最坏情况</td>
<td><span class="math inline">\(O(VE)\)</span></td>
<td>节点被反复加入队列<span class="math inline">\(O(V)\)</span>次</td>
</tr>
<tr>
<td>含负环图</td>
<td><span class="math inline">\(O(VE)\)</span></td>
<td>持续绕环无法退出</td>
</tr>
</tbody>
</table>
<p>SPFA体现了<strong>反应式编程</strong>的思想：<strong>不预测</strong>哪些边需要松弛，<strong>不预设</strong>更新轮数上限。</p>
<h3 id="负环检测计数器">负环检测：计数器</h3>
<p>SPFA通过<strong>节点入队次数</strong>检测负环，比如维护计数器<code>cnt[v]</code>记录每个节点入队次数，若<code>cnt[v] &gt; V</code>则判定存在负环（原理和 BellmanFord 相同，在无负环的图中，任意节点最多被松弛 <span class="math inline">\(V-1\)</span> 次）。该条件为<strong>充分不必要条件</strong>，检测的是顶点出发可到达的负环。</p>
<h3 id="spfa-的数据敏感性">SPFA 的数据敏感性</h3>
<h4 id="队列策略优化">队列策略优化</h4>
<p>我们知道 SPFA 的性能极度依赖数据，通过设置队列调度策略，工程中可以使用以下技巧尽可能避免极端数据带来的影响：</p>
<ul>
<li>SLF（Small Label First）：新节点入队时，若其距离值<strong>小于队首节点</strong>，则插入队首（双端队列实现），否则入队尾。</li>
<li>LLL（Large Label Last）：当前节点距离值<strong>大于队列平均值</strong>时，将其重新插入队尾，避免“卡在”局部劣质路径</li>
<li>将入队次数较多的点从队尾而非队首插入，或者反过来让前几次入队的点从队尾进</li>
<li>随机扰动：以概率 <span class="math inline">\(p\)</span> 将新节点插入随机位置 / 以概率交换队首队尾 / 以概率排序队列</li>
</ul>
<p>这些优化本质是<strong>在队列的FIFO特性与优先队列的贪心特性之间寻找平衡点</strong>。让队列尽可能接近优先队列，不陷入次优解。但他们并非复杂度优化，只是针对常用构造数据（菊花图，网格图）的见招拆招，理论上只要还使用队列，就总存在被卡到 <span class="math inline">\(O(VE)\)</span> 的最坏数据。</p>
<h4 id="队列变体实验当spfa不再队列">队列变体实验：当SPFA不再“队列”</h4>
<p>另外一个思路是更换数据结构，会引发有趣的现象：</p>
<p><strong>实验一：优先队列（可重复入队的Dijkstra）</strong></p>
<ul>
<li><strong>实现</strong>：用优先队列（堆）代替普通队列，按<code>distance[v]</code>排序</li>
<li><strong>优点</strong>：
<ul>
<li>在正权图中等价于Dijkstra，时间复杂度<span class="math inline">\(O(E \log V)\)</span></li>
<li>对某些特定负权图（如近DAG图）可能更快</li>
</ul>
</li>
<li><strong>灾难性后果</strong>：
<ul>
<li>遇到负权边时，节点可能非常多次入队（距离值反复被更新）</li>
<li>复杂度不再稳定，可以被构造数据卡成指数级复杂度。</li>
</ul>
</li>
</ul>
<p><strong>实验二：栈（深度优先松弛）</strong></p>
<ul>
<li><strong>实现</strong>：用栈代替队列，后进先出（LIFO）</li>
<li><strong>优点</strong>：
<ul>
<li>可能更快发现某些负环（深度优先穿透环路）</li>
<li>对链式更新结构更高效</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>随机图上的效率降低</li>
<li>在无负环图中容易产生“更新震荡”</li>
<li>复杂度不再稳定，可以被构造数据卡成指数级复杂度。</li>
</ul>
</li>
</ul>
<p>队列的FIFO特性是SPFA在<strong>泛用性</strong>与<strong>效率</strong>间的最佳平衡选择。任何结构改变都将打破这一精妙平衡，除非数据特殊，还是不动为好。</p>
<h3 id="算法对比">算法对比</h3>
<p>下表展现了Dijkstra与Bellman-Ford/SPFA的<strong>本质矛盾</strong>与<strong>互补关系</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>Dijkstra</th>
<th>Bellman-Ford/SPFA</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>适用权重</strong></td>
<td>严格非负权</td>
<td>任意权重（含负权）</td>
</tr>
<tr>
<td><strong>检测负环</strong></td>
<td>不能</td>
<td>能（需显式实现）</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td><span class="math inline">\(O(E \log V)\)</span></td>
<td><span class="math inline">\(O(E)\)</span> ~ <span class="math inline">\(O(VE)\)</span></td>
</tr>
<tr>
<td><strong>更新策略</strong></td>
<td>贪心锁定</td>
<td>动态松弛</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>优先队列（堆）</td>
<td>队列/双端队列</td>
</tr>
</tbody>
</table>
<p>通过三要素决策树选择算法：</p>
<ol>
<li><strong>是否存在负权边？</strong>
<ul>
<li>无 → Dijkstra（稳定高效）</li>
<li>有 → 进入下一层判断</li>
</ul>
</li>
<li><strong>是否需检测负环？</strong>
<ul>
<li>需检测 → Bellman-Ford/SPFA</li>
<li>不需检测 → 考虑转化为非负权（Johnson算法预处理）</li>
</ul>
</li>
<li><strong>图结构特征？</strong>
<ul>
<li>随机稀疏图 → SPFA（平均<span class="math inline">\(O(E)\)</span>）</li>
<li>稠密规律图 → Bellman-Ford（避免队列抖动）</li>
<li>动态频繁更新 → SPFA（增量式处理）</li>
</ul>
</li>
</ol>
<p>正如《周易》所言：“穷则变，变则通，通则久”，面对最短路径问题的万千变化，唯有理解算法背后的哲学，方能在刚柔之间找到破局之钥。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.057160747094907406" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-16 20:51">2025-02-16 20:50</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18717951" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18717951);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18717951', targetLink: 'https://www.cnblogs.com/ofnoname/p/18717951', title: '你的边比较松弛：最短路的 Bellman-Ford 和 SPFA 方法' })">举报</a>
</div>
        