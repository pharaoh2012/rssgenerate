
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wangerdan115/p/18942240" title="发布于 2025-06-22 10:13">
    <span role="heading" aria-level="2">鸿蒙运动项目开发：项目运行环境切换器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>##鸿蒙核心技术##运动开发#</p>
<p>在开发鸿蒙运动项目时，管理不同运行环境（如开发环境、测试环境、生产环境）是一个常见的需求。通过合理地切换运行环境，开发者可以方便地进行调试、测试和部署。本文将介绍如何实现一个项目运行环境切换器，帮助你在鸿蒙开发中高效地管理不同环境的配置。</p>
<h2 id="前言">前言</h2>
<p>在现代软件开发中，环境管理是确保应用稳定性和可维护性的关键环节之一。无论是开发、测试还是生产环境，每个环境都可能有不同的配置需求，例如 API 地址、日志级别、功能开关等。通过实现一个运行环境切换器，我们可以轻松地在不同环境之间切换，而无需修改代码，从而提高开发效率和灵活性。</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2732256/202506/2732256-20250622101346752-1933353362.jpg" class="lazyload"></p>
<h2 id="一环境切换器的设计">一、环境切换器的设计</h2>
<h3 id="一环境配置类型">（一）环境配置类型</h3>
<p>为了支持不同环境的配置，我们定义了 <code>EnvironmentConfigs</code> 和 <code>CurrentEnvironment</code> 类型。</p>
<pre><code class="language-typescript">export type EnvironmentConfigs = Map&lt;string, Map&lt;string, string&gt;&gt;;

export interface CurrentEnvironment {
  name: string;
  configs: Map&lt;string, string&gt;;
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>EnvironmentConfigs</strong>：一个映射表，键为环境名称（如 <code>production</code>、<code>development</code>），值为该环境的配置映射表。</li>
<li><strong>CurrentEnvironment</strong>：表示当前环境的名称和配置。</li>
</ol>
<h3 id="二环境类型枚举">（二）环境类型枚举</h3>
<p>我们通过枚举定义了支持的环境类型。</p>
<pre><code class="language-typescript">export enum EnvironmentType {
  TYPE_PRODUCTION = "production",
  TYPE_DEVELOP = "develop"
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>枚举类型</strong>：通过枚举定义了两种环境类型：生产环境（<code>production</code>）和开发环境（<code>develop</code>）。可以根据需要扩展更多环境类型。</li>
</ol>
<h3 id="三环境管理类">（三）环境管理类</h3>
<p>环境管理类 <code>Environment</code> 是整个环境切换器的核心。它负责存储环境配置、加载保存的环境、切换环境以及通知回调。</p>
<pre><code class="language-typescript">export class Environment {
  private static instance: Environment;
  private static readonly ENVIRONMENT_STORAGE_KEY = 'current_environment';

  private currentEnvironment?: CurrentEnvironment;
  private environments: EnvironmentConfigs = new Map();
  private preferences: LibPreferencesSync;
  private environmentChangeCallbacks: Array&lt;(newEnvironment: CurrentEnvironment) =&gt; void&gt; = [];

  private constructor() {
    this.preferences = new LibPreferencesSync();
  }

  public static getInstance(): Environment {
    if (!Environment.instance) {
      Environment.instance = new Environment();
    }
    return Environment.instance;
  }

  public initEnvironments(evn: EnvironmentConfigs) {
    this.environments = evn;
    this.loadSavedEnvironment();
  }

  private loadSavedEnvironment() {
    if (!IS_PRODUCTION) {
      const savedEnvironmentName = this.preferences.getValue(Environment.ENVIRONMENT_STORAGE_KEY) as string;
      if (savedEnvironmentName &amp;&amp; this.environments.has(savedEnvironmentName)) {
        this.currentEnvironment = {
          name: savedEnvironmentName,
          configs: this.environments.get(savedEnvironmentName)!
        };
      } else {
        this.currentEnvironment = {
          name: EnvironmentType.TYPE_DEVELOP,
          configs: this.environments.get(EnvironmentType.TYPE_DEVELOP)!
        };
      }
    } else {
      this.currentEnvironment = {
        name: EnvironmentType.TYPE_PRODUCTION,
        configs: this.environments.get(EnvironmentType.TYPE_PRODUCTION)!
      };
    }
  }

  public switchEnvironment(name: string) {
    const configs = this.environments.get(name);
    if (configs) {
      this.currentEnvironment = { name, configs };
      this.preferences.saveKeyValue(Environment.ENVIRONMENT_STORAGE_KEY, name);
      this.environmentChangeCallbacks.forEach(callback =&gt; callback(this.currentEnvironment!));
    }
  }

  public getCurrentEnvironment(): CurrentEnvironment {
    return this.currentEnvironment!;
  }

  public getAllEnvironmentNames(): string[] {
    return Array.from(this.environments.keys());
  }

  public registerEnvironmentChangeCallback(callback: (newEnvironment: CurrentEnvironment) =&gt; void) {
    this.environmentChangeCallbacks.push(callback);
  }

  public unregisterEnvironmentChangeCallback(callback: (newEnvironment: CurrentEnvironment) =&gt; void) {
    this.environmentChangeCallbacks = this.environmentChangeCallbacks.filter(cb =&gt; cb !== callback);
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>单例模式</strong>：通过 <code>getInstance</code> 方法确保 <code>Environment</code> 的全局唯一性。</li>
<li><strong>环境初始化</strong>：通过 <code>initEnvironments</code> 方法初始化环境配置。</li>
<li><strong>加载保存的环境</strong>：在 <code>loadSavedEnvironment</code> 方法中，根据存储的环境名称加载对应的环境配置。</li>
<li><strong>环境切换</strong>：通过 <code>switchEnvironment</code> 方法切换环境，并通知所有注册的回调函数。</li>
<li><strong>回调机制</strong>：支持注册和注销环境切换回调，方便在环境切换时执行相关操作。</li>
</ol>
<h2 id="二环境切换器的使用">二、环境切换器的使用</h2>
<h3 id="一环境切换对话框">（一）环境切换对话框</h3>
<p>为了方便用户切换环境，我们实现了一个环境切换对话框 <code>EnvironmentDialog</code>。</p>
<pre><code class="language-typescript">@CustomDialog
export struct EnvironmentDialog {
  public controller: CustomDialogController;
  private themeManager: ThemeManager = ThemeManager.getInstance();
  private environment: Environment = Environment.getInstance();
  public onEnvironmentChanged?: () =&gt; void;

  build() {
    Column() {
      Text('选择环境')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .fontColor(this.themeManager.getTextPrimaryColor())
        .margin({ top: 24, bottom: 16 })

      List() {
        ForEach(this.environment.getAllEnvironmentNames(), (envname: string) =&gt; {
          ListItem() {
            Row() {
              Column() {
                Text(envname)
                  .fontSize(16)
                  .fontColor(this.themeManager.getTextPrimaryColor())
                  .margin({ bottom: 4 })
              }
              .alignItems(HorizontalAlign.Start)
              .layoutWeight(1)

              if (this.environment.getCurrentEnvironment().name === envname) {
                Image($r('app.media.base_icon_select'))
                  .width(24)
                  .height(24)
                  .margin({ left: 8 })
              }
            }
            .width('100%')
            .padding(16)
            .backgroundColor(this.themeManager.getSurfaceColor())
            .borderRadius(8)
            .onClick(() =&gt; {
              this.environment.switchEnvironment(envname);
              this.onEnvironmentChanged?.();
              this.controller.close();
            })
          }
          .margin({ bottom: 8 })
        }, (envname: string) =&gt; envname)
      }
      .width('100%')
      .layoutWeight(1)

      Button('关闭')
        .width('100%')
        .height(48)
        .backgroundColor(this.themeManager.getPrimaryColor())
        .margin({ top: 16 })
        .onClick(() =&gt; {
          this.controller.close();
        })
    }
    .width('90%')
    .padding(16)
    .backgroundColor(this.themeManager.getBackgroundColor())
    .borderRadius(16)
  }
}
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>环境列表</strong>：通过 <code>ForEach</code> 遍历所有环境名称，并为每个环境生成一个列表项。</li>
<li><strong>当前环境标识</strong>：如果当前环境与列表项环境一致，则显示选中图标。</li>
<li><strong>环境切换</strong>：点击列表项时，调用 <code>switchEnvironment</code> 方法切换环境，并关闭对话框。</li>
<li><strong>回调通知</strong>：环境切换后，调用 <code>onEnvironmentChanged</code> 回调函数，通知外部环境已切换。</li>
</ol>
<h3 id="二环境切换的回调机制">（二）环境切换的回调机制</h3>
<p>为了在环境切换时执行相关操作，我们可以通过注册回调函数来实现。</p>
<pre><code class="language-typescript">const environment = Environment.getInstance();

environment.registerEnvironmentChangeCallback((newEnvironment) =&gt; {
  console.log(`环境已切换到: ${newEnvironment.name}`);
  // 在这里执行环境切换后的相关操作，例如重新加载配置、刷新界面等
});
</code></pre>
<p><strong>核心点解析</strong>：</p>
<ol>
<li><strong>注册回调</strong>：通过 <code>registerEnvironmentChangeCallback</code> 方法注册回调函数。</li>
<li><strong>回调执行</strong>：在环境切换时，回调函数会被自动调用。</li>
</ol>
<h2 id="三总结">三、总结</h2>
<p>通过实现一个项目运行环境切换器，我们可以在鸿蒙运动项目中轻松地管理不同环境的配置。环境切换器不仅支持动态切换环境，还提供了回调机制，方便在环境切换时执行相关操作。通过这种方式，开发者可以在开发、测试和生产环境中快速切换，而无需修改代码，从而提高开发效率和灵活性。</p>
<p>在实际开发中，你可以根据项目的具体需求，进一步扩展和优化环境切换器。例如：</p>
<ul>
<li><strong>支持更多环境类型</strong>：根据项目需求，扩展更多环境类型，如测试环境、预发布环境等。</li>
<li><strong>动态加载配置</strong>：从远程服务器动态加载环境配置</li>
<li><strong>集成到构建工具</strong>：将环境切换器集成到构建工具中，支持在构建时指定运行环境。</li>
</ul>
<p>希望本文能为你的鸿蒙开发之旅提供有价值的参考！如果你有任何问题或建议，欢迎随时交流。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-22 10:14">2025-06-22 10:13</span>&nbsp;
<a href="https://www.cnblogs.com/wangerdan115">王二蛋和他的狗</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18942240);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18942240', targetLink: 'https://www.cnblogs.com/wangerdan115/p/18942240', title: '鸿蒙运动项目开发：项目运行环境切换器' })">举报</a>
</div>
        