
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18888415" title="发布于 2025-05-21 10:01">
    <span role="heading" aria-level="2">.NET外挂系列：4. harmony 中补丁参数的有趣玩法（上）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>前面几篇我们说完了 harmony 的几个注入点，这篇我们聚焦注入点可接收的几类参数的解读，非常有意思，在<code>.NET高级调试</code> 视角下也是非常重要的，到底是哪些参数，用一张表格整理如下：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__instance</code></td>
<td>访问非静态方法的实例（类似 <code>this</code>）。</td>
</tr>
<tr>
<td><code>__result</code></td>
<td>获取/修改返回值，要想修改用 <code>ref</code>。</td>
</tr>
<tr>
<td><code>__resultRef</code></td>
<td>修改返回引用（方法返回是 ref 返回 ）。</td>
</tr>
<tr>
<td><code>__state</code></td>
<td>在前缀和后缀间传递自定义数据 。</td>
</tr>
<tr>
<td><code>___fields</code></td>
<td>读写私有字段（三下划线开头，修改需加 <code>ref</code>）。</td>
</tr>
<tr>
<td><code>__args</code></td>
<td>以 <code>object[]</code> 形式访问所有参数（修改数组即修改参数）。</td>
</tr>
<tr>
<td><code>方法参数同名</code></td>
<td>直接映射原参数。</td>
</tr>
<tr>
<td><code>__n</code></td>
<td><code>__n</code> 表示直接访问第 <code>n</code> 个参数，从 0 开始）。</td>
</tr>
<tr>
<td><code>__originalMethod</code></td>
<td>获取原方法的 <code>MethodBase</code>。</td>
</tr>
<tr>
<td><code>__runOriginal</code></td>
<td>判断原方法是否被执行。</td>
</tr>
</tbody>
</table>
<p>大体上有10类参数，接下来开始介绍吧。</p>
<h2 id="二补丁参数解读">二：补丁参数解读</h2>
<h3 id="1-__instance">1. __instance</h3>
<p>我们都知道 <code>new Thread()</code> 出来的线程默认都是 <code>前台线程</code>，而这种线程会阻塞程序的退出，所以需求就来了，能不能让 <code>new Thread()</code> 出来的线程自动变为后台线程呢？哈哈，这就需要借助 <code>__instance</code> 啦，我们对<code>有参Start</code> 方法进行注入， 参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            var harmony = new Harmony("com.example.threadhook");
            harmony.PatchAll();

            var thread = new Thread((object obj) =&gt;
            {
                var currentThread = Thread.CurrentThread;
                Console.WriteLine($"3. tid={currentThread.ManagedThreadId}, 线程内容为： {obj}, 是否为后台线程:{Thread.CurrentThread.IsBackground}");
            });

            Console.WriteLine($"1. new Thread() 完毕，当前是否为后台线程:{thread.IsBackground}");
            thread.Start("hello world!");

            Console.ReadLine();
        }
    }

    [HarmonyPatch(typeof(Thread), "Start", new Type[] { typeof(object) })]
    public class ThreadStartHook
    {
        public static void Prefix(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"2. 即将 Thread.Start: 线程tid={__instance.ManagedThreadId}");
            Console.WriteLine("----------------------------");

            // 将默认的 前台线程 改为 后台线程								
            __instance.IsBackground = true;
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521100108307-2106309075.png" alt="" loading="lazy"></p>
<p>从卦中来看，非常完美，现在 Thread 再也不会阻塞程序的退出啦。。。</p>
<h3 id="2-__state">2. __state</h3>
<p>有时候我们有这样的一个场景，想测量一个某个底层sdk方法的执行时间，更具体一点就是测量某个线程的执行时间，做法的话通常有两种。</p>
<ol>
<li>在类中定义私有字段。</li>
</ol>
<p>有些朋友可能知道 harmony 有这么一条规定，那就是xxxhook中的注入方法必须是 static，所以我们只能定义 static 类型的Dictionary字段来记录，有点尴尬，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            var harmony = new Harmony("com.example.threadhook");
            harmony.PatchAll();

            var thread = new Thread((object obj) =&gt;
            {
                Thread.Sleep(new Random().Next(1000, 3000));
                var currentThread = Thread.CurrentThread;
                Console.WriteLine($"tid={currentThread.ManagedThreadId}, 线程内容为： {obj}");
            });

            thread.Start("hello world!");

            Console.ReadLine();
        }
    }

    [HarmonyPatch(typeof(Thread), "StartCallback")]
    public class ThreadStartHook
    {
        public static ConcurrentDictionary&lt;int, Stopwatch&gt; tidThreadTimeDict = new ConcurrentDictionary&lt;int, Stopwatch&gt;();

        public static void Prefix(Thread __instance)
        {
            Console.WriteLine($"1. 正在测量线程的执行时间...");

            var watch = new Stopwatch();
            watch.Start();

            tidThreadTimeDict.TryAdd(__instance.ManagedThreadId, watch);
        }

        public static void Postfix(Thread __instance)
        {
            var watch = tidThreadTimeDict[__instance.ManagedThreadId];
            watch.Stop();

            Console.WriteLine($"2. 线程执行结束，耗费时间:{watch.Elapsed.ToString()}");
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521100108337-931994191.png" alt="" loading="lazy"></p>
<p>从卦中可以看到当前线程执行了 <code>1.58s</code>，有点意思吧，针对上面的代码，有些朋友可能会挑毛病了。</p>
<ol>
<li>实现过于繁琐。</li>
</ol>
<p>确实有点繁琐，这时候就可以借助 <code>__state</code> 来充当 <code>Perfix</code> 和 <code>Postfix</code> 之间的临时变量，同时要知道 __state 可以定义成任何类型。</p>
<ol start="2">
<li>我要看到方法，而不是线程</li>
</ol>
<p>从卦中的输出看，确实我们要监控方法名，而不是线程，否则在真实场景中就会很乱，方法名我们从 Thread 下的 _startHelper 字段提取，这是一个匿名类，修改后的代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(Thread), "StartCallback")]
    public class ThreadStartCallbackHook
    {
        public static void Prefix(Thread __instance, out (Stopwatch, string) __state)
        {
            object startHelper = Traverse.Create(__instance).Field("_startHelper").GetValue();

            string methodName = Traverse.Create(startHelper).Field&lt;Delegate&gt;("_start").Value.Method.Name;
            object startArg = Traverse.Create(startHelper).Field("_startArg").GetValue();

            Console.WriteLine($"1. 正在测量 {methodName}({startArg}) 方法的执行时间...");

            var stopwatch = new Stopwatch();
            stopwatch.Start();

            __state = (stopwatch, $"{methodName}({startArg})");
        }

        public static void Postfix(Thread __instance, (Stopwatch, string) __state)
        {
            var (stopwatch, methodName) = __state;

            Console.WriteLine($"2. 线程执行结束，{methodName} 耗费时间:{stopwatch.Elapsed.ToString()}");
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521100108340-990774251.png" alt="" loading="lazy"></p>
<p>哈哈，修改后的代码相比第一版是不是爽了很多。。。</p>
<h3 id="3-__originalmethod">3. __originalMethod</h3>
<p>这个参数也是蛮重要的，通过它可以让你知道当前 patch 正骑在哪个原方法上，起到了过滤识别的作用，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            var harmony = new Harmony("com.example.threadhook");
            harmony.PatchAll();

            var max = Math.Max(10, 20);

            Console.ReadLine();
        }
    }

    [HarmonyPatch(typeof(Math), "Max", new Type[] { typeof(int), typeof(int) })]
    public class ThreadStartCallbackHook
    {
        public static void Prefix(Thread __instance, MethodBase __originalMethod)
        {
            var parameters = string.Join(",", __originalMethod.GetParameters().Select(i =&gt; i.Name));
            Console.WriteLine($"当前 Prefix 正在处理 {__originalMethod.Name}({parameters}) 方法...");
        }
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250521100108290-662326163.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>灵活运用这些奇奇怪怪的参数，相信你对 harmony 的使用有了一个全新的认识，大家可以开开心心的投放生产吧，去解决那些 Windows，Linux 上的 .NET程序的疑难杂症。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="12.4374392620625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-21 10:02">2025-05-21 10:01</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">275</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18888415);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18888415', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18888415', title: '.NET外挂系列：4. harmony 中补丁参数的有趣玩法（上）' })">举报</a>
</div>
        