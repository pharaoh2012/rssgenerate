
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ludangxin/p/18683656" title="发布于 2025-01-21 17:28">
    <span role="heading" aria-level="2">3. 使用sql查询csv/json文件内容,还能关联查询?</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-简介">1. 简介</h2>
<p>我们在前面的文章提到了calcite可以支持文件系统的数据源适配, 其实官方已经提供了相应的能力, 其支持csv和json的查询适配, 废话不多说, 直接展示.</p>
<h2 id="2-maven">2. Maven</h2>
<pre><code class="language-xml">&lt;!-- calcite文件系统支持 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;
    &lt;artifactId&gt;calcite-file&lt;/artifactId&gt;
    &lt;version&gt;1.37.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt;
    &lt;artifactId&gt;calcite-core&lt;/artifactId&gt;
    &lt;version&gt;1.37.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-数据文件准备">3. 数据文件准备</h2>
<h3 id="31-csv">3.1 csv</h3>
<p><code>user_info.csv</code></p>
<blockquote>
<p>首行将来被解析成表的字段, 冒号后面是字段类型, 如果未指定类型 默认使用varchar</p>
</blockquote>
<pre><code>ID:long,姓名:string,GENDER:string,BIRTHDAY:date
100,"张三",,"2001-01-01"
110,"李四","M","2001-01-01"
120,"王五","M","2002-05-03"
130,"赵六","F","2005-09-07"
140,"张铁牛","M","2007-01-01"
</code></pre>
<h3 id="32-json">3.2 json</h3>
<p><code>role_info.json</code></p>
<pre><code class="language-json">[
  {
    "id": 123,
    "name": "管理员",
    "key": "manager"
  },
  {
    "id": 234,
    "name": "老师",
    "key": "teacher"
  },
  {
    "id": 345,
    "name": "学生",
    "key": "student"
  }
]
</code></pre>
<p><strong>然后将文件放到resources/file目录下</strong></p>
<h2 id="4-核心代码">4. 核心代码</h2>
<pre><code class="language-java">package com.ldx.calcite;

import com.google.common.collect.ImmutableMap;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.adapter.file.FileSchemaFactory;
import org.apache.calcite.jdbc.CalciteConnection;
import org.apache.calcite.schema.Schema;
import org.apache.calcite.schema.SchemaPlus;
import org.apache.calcite.util.Sources;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.testng.collections.Maps;

import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.Properties;

@Slf4j
public class CalciteFileTest {
    private static Connection connection;

    private static SchemaPlus rootSchema;

    private static Statement statement;

    @BeforeAll
    @SneakyThrows
    public static void beforeAll() {
        Properties info = new Properties();
        // 不区分sql大小写
        info.setProperty("caseSensitive", "false");
        // 创建Calcite连接
        connection = DriverManager.getConnection("jdbc:calcite:", info);
        CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
        // 构建RootSchema，在Calcite中，RootSchema是所有数据源schema的parent，多个不同数据源schema可以挂在同一个RootSchema下
        rootSchema = calciteConnection.getRootSchema();
        final Schema schema = FileSchemaFactory.INSTANCE.create(rootSchema, "x",
                ImmutableMap.of("directory", resourcePath("file"), "flavor", "scannable"));
        rootSchema.add("test", schema);
        // 创建SQL语句执行查询
        statement = calciteConnection.createStatement();
    }

    @Test
    @SneakyThrows
    public void execute_simple_query() {
        ResultSet resultSet = statement.executeQuery("SELECT * FROM test.user_info");
        printResultSet(resultSet);
    }
  
    @Test
    @SneakyThrows
    public void test_execute_join_query() {
        ResultSet resultSet = statement.executeQuery("SELECT * FROM test.user_info ui inner join test.role_info ri on ui.role_id = ri.id");
        printResultSet(resultSet);
    }

    @AfterAll
    @SneakyThrows
    public static void closeResource() {
        statement.close();
        connection.close();
    }

    private static String resourcePath(String path) {
        final URL url = CalciteFileTest.class.getResource("/" + path);
        return Sources.of(url).file().getAbsolutePath();
    }

    public static void printResultSet(ResultSet resultSet) throws SQLException {
        // 获取 ResultSet 元数据
        ResultSetMetaData metaData = resultSet.getMetaData();

        // 获取列数
        int columnCount = metaData.getColumnCount();
        log.info("Number of columns: {}",columnCount);

        // 遍历 ResultSet 并打印结果
        while (resultSet.next()) {
            final Map&lt;String, String&gt; item = Maps.newHashMap();
            // 遍历每一列并打印
            for (int i = 1; i &lt;= columnCount; i++) {
                String columnName = metaData.getColumnName(i);
                String columnValue = resultSet.getString(i);
                item.put(columnName, columnValue);
            }

            log.info(item.toString());
        }
    }
}
</code></pre>
<p>其实核心代码就几行, 如下:</p>
<p>通过<code>FileSchemaFactory</code>指定文件目录和文件内容的读取方式, 默认将指定目录下的csv和json文件读取成<code>Table</code>, 表名就是file的名称</p>
<p><code>flavor</code>:</p>
<ul>
<li>
<p><code>SCANNABLE</code>: 数据扫描。会更侧重于快速地读取和遍历数据。这种方式适用于需要对大量数据进行全表扫描或者范围扫描的情况，例如统计汇总操作</p>
</li>
<li>
<p><code>FILTERABLE</code>: 数据过滤。会更侧重于数据的条件筛选，比如在 SQL 查询中的WHERE子句。</p>
</li>
<li>
<p><code>TRANSLATABLE</code>: 数据转换。会更侧重于数据转换，以满足特定的查询需求或者数据处理要求。这种转换可能包括数据类型的转换（如将字符串类型的数字转换为实际的数值类型）、格式转换（如日期格式的调整）等。</p>
</li>
</ul>
<pre><code class="language-java">// 这里的第二个参数“x”没什么意义, 源码中没用到, 可以随便填
final Schema schema = FileSchemaFactory.INSTANCE.create(rootSchema, "x",
               ImmutableMap.of("directory", resourcePath("file"), "flavor", "scannable"));
// 使用目录名称为schema名称, 这里的test就是schema名称
rootSchema.add("test", schema);
</code></pre>
<p>calcite也可以做对应表的关联查询, 测试中csv关联json文件信息</p>
<p><code>"SELECT * FROM test.user_info ui inner join test.role_info ri on ui.role_id = ri.id"</code></p>
<h2 id="5-测试查询">5. 测试查询</h2>
<p><code>execute_simple_query方法执行如下</code><br>
<img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250121152938004-1945794565.png" alt="" loading="lazy"></p>
<p><code>test_execute_join_query方法执行如下:</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1759273/202501/1759273-20250121152950270-662773372.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2043268387997685" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-21 17:29">2025-01-21 17:28</span>&nbsp;
<a href="https://www.cnblogs.com/ludangxin">张铁牛</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18683656" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18683656);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18683656', targetLink: 'https://www.cnblogs.com/ludangxin/p/18683656', title: '3. 使用sql查询csv/json文件内容,还能关联查询?' })">举报</a>
</div>
        