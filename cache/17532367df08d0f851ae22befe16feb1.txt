
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18838393" title="发布于 2025-04-28 14:02">
    <span role="heading" aria-level="2">C#网络编程(一)----DNS/TCP/UDP</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p><strong>计算机网络</strong>是指将分布在不同地理位置的计算机系统、设备通过通信线路和设备连接起来，遵循共同的通信协议，以实现 数据传输、资源共享、协同工作 的系统<br>
。它是现代信息技术的核心基础设施，支撑着互联网、物联网、云计算等众多领域的发展。</p>
<p>其核心要求为：</p>
<ol>
<li><strong>数据通信</strong><br>
实现不同设备间的信息传输。</li>
<li><strong>资源共享</strong><br>
共享硬件资源（如打印机、存储设备）、软件资源（如应用程序、数据库）和数据资源（如文件、图片)。</li>
<li><strong>分布式处理</strong><br>
将复杂任务分配给多台计算机协同完成。</li>
<li><strong>高可靠性与容错</strong><br>
多条传输路径，避免单点故障。</li>
</ol>
<h1 id="网络模型">网络模型</h1>
<p>为了<code>简化网络设计</code>，实现高内聚，低耦合。网络设计采用分层架构 ，每层实现特定功能并通过接口与上下层交互。</p>
<h2 id="七层模型">七层模型</h2>
<p>在分层模型中，每一层都有实体，这些实体指的是执行特定层次功能的硬件或软件组成。</p>
<blockquote>
<p>协议是一套标准和规则。分完层后，用于控制同一层次内的实体如何通信</p>
</blockquote>
<table>
<thead>
<tr>
<th>层</th>
<th>功能描述</th>
<th>典型协议/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>应用层</strong></td>
<td>直接为用户应用提供服务（如文件传输、电子邮件、Web服务）</td>
<td>HTTP、FTP、SMTP、DNS</td>
</tr>
<tr>
<td><strong>表示层</strong></td>
<td>数据格式转换、加密解密、压缩解压缩（确保跨系统兼容）</td>
<td>JPEG、SSL/TLS、ZIP</td>
</tr>
<tr>
<td><strong>会话层</strong></td>
<td>建立、管理和终止应用程序间的会话（如会话认证、断点续传）</td>
<td><span style="color: rgba(255, 0, 0, 1)">SSH、RPC</span>、NetBIOS</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>端到端的数据传输控制（确保可靠性或效率）</td>
<td><span style="color: rgba(255, 0, 0, 1)">TCP、UDP</span></td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>路由选择和网络互联（将数据从源网络转发到目标网络）</td>
<td><span style="color: rgba(255, 0, 0, 1)">IP</span>、ICMP、OSPF、BGP</td>
</tr>
<tr>
<td><strong>数据链路层</strong></td>
<td>相邻节点间的帧传输，处理物理寻址和错误检测</td>
<td>Ethernet（MAC协议）、PPP、VLAN</td>
</tr>
<tr>
<td><strong>物理层</strong></td>
<td>比特流在物理介质上的传输（定义硬件接口、信号形式等）</td>
<td>RJ45、光纤、Wi-Fi射频信号</td>
</tr>
</tbody>
</table>
<h2 id="四层模型">四层模型</h2>
<p>TCP/IP四层模型，也称为互联网协议套件(Internet Protocol Suite)。因为理论和实践的不同，7层模型太复杂，因此简化为4层。<br>
将物理层与链路层合并，合并了表示层，会话层。</p>
<blockquote>
<p>OSI是学术和法律上的国际标准，TCP/IP是事实上的国际标准。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250421144837641-1732369204.png" alt="image" loading="lazy"></p>
</blockquote>
<blockquote>
<p>还有5层模型，只是为了方便教学而臆想出的模型，不再赘述</p>
</blockquote>
<h1 id="应用层经典协议dns协议">应用层经典协议，DNS协议</h1>
<p>访问某个网站，本质上是与某台服务器通信。为了访问服务器，我们需要使用IP地址。但IP地址不太好记。<br>
因此，域名(Domain Name)由此而生，替代了难以记忆的IP地址。<br>
在域名与IP中间，有一个转换协议，叫做DNS(Domain Name System，域名系统)。将域名转换成IP。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427115318523-243161104.png" alt="image" loading="lazy"></p>
<h2 id="访问一个网站期间发生了什么">访问一个网站期间发生了什么？</h2>
<ol>
<li>用户请求</li>
<li>浏览器本地缓存检查<br>
浏览器先检查本地缓存中有没有域名的IP地址，没有就执行下一步</li>
<li>查询本地DNS服务器<br>
浏览器向本地DNS服务器发送查询请求，没有就执行下一步</li>
<li>查询根域名服务器<br>
本地DNS服务器向根域名服务器查询，根域名服务器返回顶级域名服务器(TLD Server)的地址</li>
<li>查询顶级域名服务器<br>
再由本地DNS服务器向顶级域名服务器查询，顶级域名服务器返回权威DNS服务器的地址</li>
<li>查询权威DNS服务器<br>
本地DNS服务器向权威DNS服务器查询，返回目标IP地址</li>
<li>访问目标网站<br>
浏览器获得IP地址访问目标网站。</li>
<li>建立TCP连接<br>
浏览器通过IP地址与服务器建立了TCP连接</li>
<li>发送HTTP请求<br>
浏览器构建HTTP请求(request header/request body/request row)，将请求发送到服务器。</li>
<li>服务器接收请求<br>
服务器接收到HTTP请求后，先由<code>反向代理</code>(如果有的话)来判断是静态请求还是动态请求。动态请求交由后端处理(kestrel/tomcat)，生成HTTP响应(response)</li>
<li>浏览器接收响应<br>
解析HTML，构建DOM树，解析CSS与JS文件。最终渲染页面。</li>
<li>断开连接<br>
TCP四次挥手断开连接。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427115023697-1728304776.png" alt="image" loading="lazy"></p>
<h1 id="传输层经典协议tcpudp协议">传输层经典协议，TCP/UDP协议</h1>
<h2 id="pdu">PDU</h2>
<p>协议数据单元(Protocol Data Unit,PDU，分为头部(PCI)与负载(SDU)计算机网络各层之间<code>交换信息的单位</code>。</p>
<p>在不同的层中，它的title各不相同：</p>
<ol>
<li>在链路层中叫帧(Frame)</li>
<li>网络层/应用层中叫数据包(Packet)</li>
<li>传输层中叫报文段(Segment，TCP)，数据报(Datagram，UDP)</li>
</ol>
<h2 id="数据传输的过程">数据传输的过程</h2>
<p>对于发送方，就是<code>层层加码</code>，对于接收方，则是<code>层层解码</code>。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250425120951643-2118692910.png" alt="image" loading="lazy"></p>
<h2 id="tcp协议">TCP协议</h2>
<p>TCP是一种面向连接、可靠的、基于字节流的传输层通信协议。</p>
<blockquote>
<p>可靠是建立在链路层不断地前提下，硬件断了，说啥都没用。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428102541203-1406882418.png" alt="image" loading="lazy"></p>
<ol>
<li>面向连接<br>
TCP是一种面向连接的协议，在数据交换之前，两个通信端必须先建立连接。<br>
这个连接通过三次握手(SYN-SYNACK-ACK)来建立</li>
<li>可靠传输<br>
发送方为每个报文段<code>分配一个序列号</code>，接收方通过发送确认应答(ACK)来确认已经收到<code>特定序列号</code>的报文段，如果发送方没有在<code>超时时间内收到ACK</code>，它将重传报文段。</li>
<li>流量控制<br>
TCP使用<code>滑动窗口</code>来进行流量控制，防止发送方过快地发送数据，导致接收方来不及处理。</li>
<li>拥塞控制<br>
TCP使用慢启动，阻塞避免，快重传和快恢复等算法，避免网络中的过度阻塞。动态调整数据的发送速度，从而提高网络效率。</li>
<li>数据排序<br>
由于网络延迟和路由变化，TCP报文段的到达顺序可能混乱。TCP能够通过<code>序列号来重新排序</code></li>
<li>端到端通信<br>
每个TCP连接由四个元素指定地址：IP，端口，目标IP，目标端口</li>
</ol>
<h3 id="tcp报文段格式">TCP报文段格式</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250425125954987-1140767751.png" alt="image" loading="lazy"></p>
<ol>
<li>源端口号与目标端口号<br>
每个字段16bit，标识端口号</li>
<li>序列号(sequence number field)<br>
一个32位的数，用于标识从<code>TCP源到目标</code>的数据字节流，确保数据的有序传输和重组。<br>
比如发送1000字节的数据流，TCP为数据流构建10个报文段，那么序列号就是0，100，200，300，....</li>
<li>确认号(acknowledgement number field)<br>
是对之前接收数据的确认，比如收到了122字节的，那么ack就是123，希望收到122之后字节流的意思</li>
<li>数据偏移(data offset)<br>
标识TCP头部的长度，因为TCP头部包含了可变的填充，所以长度不固定，因此需要记录长度信息。</li>
<li>保留(reserved)<br>
预保留，主要是为数据偏移溢出做准备</li>
<li>控制位<br>
一共6个bit，每个bit对应一个状态，控制TCP不同行为，比如建立连接(SYN)，终止连接(FIN)。
<ol>
<li>URG<br>
紧急标志，为1表示当前报文段紧急，接收方应该优先处理，后面的<code>紧急指针</code>指出了数据的位置</li>
<li>ACK<br>
确认标志，为1表示该报文段已经被成功接收，连接建立后，直到释放前，ACK标志始终为1。</li>
<li>PSH<br>
为1表示接收方应该立即将数据交给上层</li>
<li>RST<br>
为1表示连接出现错误，要求接收方终止连接，并重新建立。</li>
<li>SYN<br>
该标志用于建立连接，TCP前两次握手，SYN为1</li>
<li>FIN<br>
为1表示发送方已经没有数据发送，需要断开。</li>
</ol>
</li>
<li>窗口大小<br>
用于控制发送方的数据量，避免接收方的缓冲区溢出。</li>
<li>校验和<br>
用于检查整个TCP报文段的错误，确保数据的完整性。</li>
<li>紧急指针<br>
与URG控制位配合，如果为正数，表明从当前序列号开始的紧急数据的偏移量。</li>
<li>选项(Options)<br>
TCP可以包含各种可选字段，这些字段不固定，比如最大报文段大小，窗口缩放选项，选择性确认等，用于优化TCP连接的性能。</li>
<li>填充(padding)<br>
TCP是基于32位体系结构的，为了内存对齐。需要确保它的头部长度为32位的整数倍。由于选项(options)的长度不固定，所以需要使用填充来保证TCP头部长度是<code>32位的整数倍</code></li>
</ol>
<blockquote>
<p>TCP仅仅头部是32位对齐，数据部分不要求。</p>
</blockquote>
<h3 id="tcp的状态">TCP的状态</h3>
<ol>
<li>CLOSED<br>
初始状态和最终状态</li>
<li>LISTEN<br>
在服务端监听来自客户端的连接请求，服务端在这个状态下，等待客户端的报文。</li>
<li>SYN_SENT<br>
客户端发送一个连接请求到服务端(SYN包)，客户端进入SYN_SENT状态</li>
<li>SYN_RECEIVED<br>
服务端接收到SYN报文后，响应一个SYN+ACK报文，同时进入SYN_RECEIVED状态</li>
<li>ESTABLISHED<br>
连接已经建立成功，数据可以开始传输。三次握手完成后，双方都会进入的状态</li>
<li>FIN_WAIT_1<br>
当一端完成数据发送任务后，会发送一个FIN报文，表示数据发送完成。随即进入FIN_WAIT_1状态。</li>
<li>CLOSE_WAIT<br>
接收到对方的FIN报文后，发送一个ACK响应报文，并进入CLOSE_WAIT状态</li>
<li>FIN_WAIT_2<br>
接收到对方的ACK响应后，进入FIN_WAIT_2状态，等待对方处理好关闭后续事件后，再次发送FIN报文。</li>
<li>LAST_ACK<br>
在接收方处理完自己的数据后，会在此发送一个FIN报文，进入LAST-ACK状态</li>
<li>TIME_WAIT<br>
当进入FIN_WAIT_2状态的一方，在此接收到FIN报文后。就会进入TIME_WAIT状态。并发送一个ACK报文。<br>
这样可以正确地关闭连接。</li>
<li>CLOSING<br>
在同时关闭的情况下，当两端几乎同时发送FIN报文时，可能会进入CLOSING状态，表示双方都在等待对方的FIN报文的确认</li>
</ol>
<h3 id="tcp三次握手">TCP三次握手</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250425131639596-1573006452.png" alt="image" loading="lazy"></p>
<ol>
<li>第一次握手,SYN<br>
客户端发送一个<code>TCP报文段</code>到服务器。在这个报文段的头部中，SYN位被设为1，表明这是一个连接请求。并随机一个序列号，并在SEQ中随机一个数字x。<br>
此时<code>客户端状态变为SYN_SENT</code>状态</li>
<li>第二次握手,SYN+ACK<br>
服务器接收请求后，如果同意连接。服务端就<code>再发送一个TCP报文段</code>，在此报文段中，ACK位与SYN位会设为1，表明已经收到你的连接请求，顺带也要请求你。此时服务器也会随机一个数组y，作为服务器的seq,并将客户端的seq+1，作为ack返回回去。<br>
此时服务器进入<code>SYN_RECEIVED</code>状态</li>
<li>第三次握手,ACK<br>
客户端收到服务器的应答后，还需再发送<code>TCP报文段</code>，在此报文段中，ACK位为1，SYN重置为0，表明这是一个单纯的应答请求。此时客户端将服务端发来的y+1，返回回去，完成三次握手。<br>
此时客户端与服务器状态都进入<code>ESTABLISHED</code>状态</li>
</ol>
<blockquote>
<p>说人话就是：<br>
男：处对象吗？我微信是X。<br>
女：处！确认一下，确认你的微信是X。顺带告诉你，我的微信号是Y.<br>
男：收到！确认一下，你的微信号是Y。</p>
</blockquote>
<h4 id="为什么要三次握手">为什么要三次握手？</h4>
<p>TCP 三次握手（Three-Way Handshake）是建立可靠连接的核心机制，其设计目的是确保<strong>通信双方同步初始序列号（ISN）、确认双向通信能力</strong>，并避免旧连接的残留数据包干扰新连接。</p>
<ol>
<li>同步初始序列号（ISN）<br>
通信双方通过交换SYN包各自的seq，避免数据混淆。</li>
</ol>
<blockquote>
<p>为什么需要初始化ISN时要随机？ 类似数据库的自增主键，很容易被预测出下一个的值而遭到攻击。所以需要随机。</p>
</blockquote>
<ol start="2">
<li>确认双向通信能力<br>
服务端收到SYN，确认客户端能<code>发送数据</code>。<br>
客户端收到SYN-ACK，确认<code>服务端收发能力</code>。<br>
服务端收到ACK，确认客户端<code>接收能力</code></li>
</ol>
<blockquote>
<p>如果仅仅两次握手，那么无法确认客户端是否有接收能力。</p>
</blockquote>
<ol start="3">
<li>防止旧连接数据包干扰<br>
若网络中存在旧连接的延迟SYN包（如因网络拥塞滞留的数据包），通过三次握手的序列号机制可识别。<br>
因为客户端的ISN是基于随机数的递增，旧SYN包的序列号会小于当前ISN，客户端收到后直接忽略。</li>
</ol>
<blockquote>
<p>如果仅仅两次握手，服务器会无法识别旧数据包。因为不知道第三次握手的ack。</p>
</blockquote>
<h3 id="半连接队列全连接队列">半连接队列/全连接队列</h3>
<p>当服务器端进入LISTEND状态时，会在内部创建两个队列。半连接队列(SYN Queue)与全连接队列(ACCEPT Queue)。</p>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427150240867-2140168937.png" alt="image" loading="lazy"></p>
<h4 id="syn-flood-attacksyn泛洪攻击">SYN Flood Attack(SYN泛洪攻击)</h4>
<p>SYN泛洪水攻击是一种经典的DOS攻击，利用了 TCP 协议的设计缺陷。攻击者伪造<code>大量虚假IP地址</code>，向服务器发送海量SYN包，服务器会为每个SYN连接请求分配资源(内存，句柄/FD)等，并返回SYN-ACK。但攻击者永远不会回应(ACK)，导致这种<code>半开连接</code>长期占用资源(需要超时自动释放)，当连接队列被占满时，服务器就<code>无法处理正常用户</code>的请求。</p>
<p>防御手段：</p>
<ol>
<li>SYN Cookies(延时分配资源)<br>
服务器在收到SYN时，不立即分配资源。而是根据客户端的IP，端口号生成一个Cookie,并将其嵌入到<code>SYN-ACK报文段</code>中。当客户端返回ACK时，验证Cookie是否合法，再分配资源，创建连接。</li>
<li>调整参数<br>
增大半开连接队列，缩短超时时间。目的是减少无效请求对资源的占用。</li>
<li>防火墙拦截<br>
针对IP，或者短时间内不合理的SYN请求进行丢弃。</li>
<li>SYN Proxy<br>
在服务器前端部署反向代理，先由代理服务器完成于客户端三次握手，再将连接转发给服务器。</li>
</ol>
<blockquote>
<p>DDoS/Dos攻击本质上是一场社会工程学的较量，所谓道高一尺，魔高一丈，无法一劳永逸的防御，只能不断提高攻击者的成本，让攻击者知难而退。</p>
</blockquote>
<h3 id="tcp数据传输">TCP数据传输</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250425140703038-1263794109.png" alt="image" loading="lazy"></p>
<ol start="0">
<li>
<p>延时确认<br>
接收方在接收到报文段后，不会立即发送ACK。而是等待一段时间，看有没有报文继续发送过来，以此来降低网络开销。</p>
</li>
<li>
<p>累积确认<br>
TCP连接的建立和释放，ACK报文的值为接收到的seq/fin的值+1。<br>
<code>同样，在数据传输过程中</code>，ack报文的值也会根据seq的值产生变化。 ack=seq+接收到的数据长度<br>
因此，当多个报文过来时，把报文累计起来，多个报文的ACK合并为一个ACK。</p>
</li>
<li>
<p>超时重传<br>
当发送方，如果未在预定时间内接收到ACK。发送方会重新发送。</p>
</li>
<li>
<p>滑动窗口(接收方)<br>
让发送端根据接收端的实际接收能力控制发送的数据量。根据缓冲区的窗口大小，接收方可以在返回的ACK报文中，告诉发送方，<code>当前缓冲区还剩下多少</code>，当窗口大小为0时，发送方会暂停发送，一点时间后，待接收方窗口足够了。再发送报文通知发送方。</p>
</li>
<li>
<p>拥堵，阻塞控制(发送方)<br>
拥塞控制（Congestion Control）是计算机网络中用于防止网络因数据流量过大而导致性能下降甚至瘫痪的关键机制。它通过动态调整发送方的数据传输速率，使网络负载维持在合理范围内，确保网络资源的公平分配和高效利用<br>
当网络出现拥塞时，会导致数据包延迟，丢失等问题。当丢包到达一定时间，又会<code>触发TCP重传机制</code>，又进一步加重了网络负担。所以当网络拥塞时，TCP会自动降低发送的数据量。<br>
举个例子：<code>当高速拥堵时，交管部门就会封了某些高速入口，只出不进.</code><br>
TCP 通过 拥塞窗口（Congestion Window, cwnd） 控制发送方的速率，其大小反映了发送方对当前网络拥塞程度的估计。拥塞控制算法通过调整 cwnd 实现流量调控，主要包括以下四个阶段：</p>
<ul>
<li>慢启动：<br>
cwnd一开始比较小，每收到一个ack，就指数增长。当cwnd达到慢启动的一个阈值(Slow start Threshold)时，进入拥塞避免阶段，此时每收到一个ack，cwnd就只+1。</li>
<li>拥塞避免：<br>
随着网络的拥堵，如果限定时间内未收到ack，就会判定超时。将阈值调整为当前cwnd的一半，并将cwnd重置为1，重新开启慢启动过程。</li>
<li>快速重传：<br>
当发送方连续收到3个重复的ack时，马上判定报文段丢失，立即重传，而不是等待ack。</li>
<li>快速恢复：<br>
当快速重传发生时，阈值调整为当前cwnd的一半，不必从1开始。</li>
</ul>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427211813025-171099401.png" alt="image" loading="lazy"></p>
<blockquote>
<p>偷个懒，盗了尚硅谷的图。</p>
</blockquote>
<p><strong>综上所述：发送方的窗口大小应该是<code>拥塞窗口与接收窗口两者的最小值</code>。</strong></p>
<h3 id="tcp四次挥手">TCP四次挥手</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427152915361-266168340.png" alt="image" loading="lazy"></p>
<ol>
<li>
<p>第一次挥手<br>
客户端向服务端发送一个FIN结束报文，表示客户端发送完毕。但仍然可以接收数据，进入FIN_WAIT_1状态</p>
</li>
<li>
<p>第二次挥手<br>
服务端收到FIN报文后，向客户端发送一个ACK报文，确认收到。服务端进入CLOSE-WAIT状态并<code>开始处理收尾工作</code>，客户端收到ACK报文，进入FIN-WAIT-2状态。</p>
</li>
<li>
<p>第三次挥手<br>
服务端<code>擦完屁股</code>后，向客户端发送一个FIN报文，表示服务端也没有数据要发送了。服务器进入LAST-ACK状态</p>
</li>
<li>
<p>第四次挥手<br>
客户端收到FIN报文后，向服务端发送ACK报文，确认收到。服务端进入CLOSED状态。客户端进入TIME-WAIT状态，等待一段时间确保服务端收到ACK报文。等待2MSL后客户端变为CLOSED状态，<code>连接断开</code>。</p>
</li>
</ol>
<blockquote>
<p>说人话就是：<br>
男：分手吧，我累了。<br>
女：分就分！我把我的东西从房里搬出去。<br>
......<br>
......<br>
女：我收拾完了，再见<br>
男：再见，再也不见。</p>
</blockquote>
<h4 id="为什么要四次挥手">为什么要四次挥手？</h4>
<p>TCP采用 “四次挥手” 来释放连接，是由其<code>全双工通信特性</code>决定的。在全双工模式下，通信双方（客户端和服务器）各自独立管理发送和接收通道，因此需要分别关闭两个方向的数据流，确保数据完整传输且连接安全终止。</p>
<p>如果降低为3次，就会导服务端还有数据没发送完毕。连接就关闭的现象，数据就会丢失。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427154005337-1548524302.png" alt="image" loading="lazy"></p>
<h4 id="为什么要等待2msl才进入closed状态">为什么要等待2MSL，才进入CLOSED状态？</h4>
<p>在TCP四次挥手过程中，客户端在发送最后一个ACK包后会进入 TIME_WAIT 状态，并等待 2 倍 MSL（Maximum Segment Lifetime，最大段生命周期）的时间后才会最终关闭连接（进入 CLOSED 状态）。这一设计的核心目的是确保连接安全关闭，并避免旧连接的残留数据干扰新连接</p>
<ol>
<li>确保ACK成功到达服务器<br>
客户端发送的ACK包<code>可能丢失</code>，此时，服务端一直未收到ACK。所以会重发第三次挥手的FIN包，重新请求关闭连接。<br>
此时等待2MSL时间，客户端会在TIME_WAIT状态中收到服务器重发的FIN包，<code>重新发送ACK</code>进行确认，并<code>重置2MSL的定时器</code>，确保服务器正确关闭连接。<br>
若不等待直接关闭：客户端已关闭连接，无法响应服务器的重发FIN，导致服务器因超时未收到AC 而持续处于 LAST_ACK状态，浪费资源。</li>
<li>防止旧连接的数据包干扰新连接<br>
假设第四次挥手后，又马上建立一个连接。此时，<code>旧连接中延迟到达的数据包</code>可能仍在网络中传输。<br>
此时等待2MSL时间，确保旧连接的所有数据包都已超过MSL存活时间，被网络设备完全丢弃。<br>
若不等待直接关闭：新连接接收到旧连接的数据包，导致出现混乱数据。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250427155635822-985425146.png" alt="image" loading="lazy"></li>
</ol>
<h4 id="为什么是2msl而不是1msl">为什么是2MSL，而不是1MSL？</h4>
<p>1MSL是单向路径的最大延迟，一个数据包的往返时间最大不超过2MSL。所以取最大值。<br>
等待2MSL可确保：</p>
<ol>
<li>最后一个 ACK 包的往返确认（若丢失可重发）。</li>
<li>旧连接的所有数据包（无论发送方向）都已从网络中消失。</li>
</ol>
<blockquote>
<p>其本质是类似流浪地球电影中的饱和式救援，保证容错与隔离。</p>
</blockquote>
<h3 id="tcp重传机制">TCP重传机制</h3>
<p>TCP（传输控制协议）重传机制是保障数据可靠传输的关键部分，它能够应对网络传输过程中可能出现的数据包丢失、损坏等问题。</p>
<ol>
<li>超时重传<br>
发送方在发送数据包后，会为每一个数据包启动一个<code>超时定时器</code>。如果在超时时间（Retransmission Time-Out,RTO）外没有收到ACK。发送方就认为数据包丢失，从而触发重传操作。</li>
</ol>
<blockquote>
<p>RTO的计算是动态调整的过程，与往返时间（RTT，Round-Trip Time）相关。如果发生超时重传后仍然没有收到 ACK，后续的 RTO 会以指数形式增长，即每次重传时 RTO 翻倍，这就是指数退避策略，目的是避免大量重传数据包同时涌入网络，进一步加剧网络拥塞。</p>
</blockquote>
<ol start="2">
<li>
<p>快速重传<br>
当接收方收到<code>乱序的数据包</code>时，会立即发送重复的ACK，表明自己期望收到的包的序列号。<br>
如果发送方<code>连续收到3个重复的ACK</code>,就会认为这个ACK所对应的数据包<code>之后的所有数据</code>都丢失，立即重传，不等待超时定时到期。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428111551056-1458563646.png" alt="image" loading="lazy"></p>
</li>
<li>
<p>选择确认重传(SACK)<br>
快速重传解决了超时时间的问题，但面临另一个问题：重所有数据，会造成<code>重复发送</code>。<br>
为了解决此问题，<code>选择确认重传</code>允许接收方在 ACK 中告知发送方哪些数据包已经正确接收，即使这些数据包是不连续的。这样发送方就可以只重传真正丢失的数据包，而不是重传从丢失数据包开始的所有未确认数据包，提高了重传效率<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428112015162-1598171253.png" alt="image" loading="lazy"></p>
</li>
<li>
<p>重复ASCK(D-SACK)<br>
Duplicate SACK，是在 SACK 的基础上做了一些扩展。<br>
接收方在接收到重复的数据包时，会直接丢弃这些重复数据包，并向发送方发送相应的ACK，避免对重复数据进行不必要的处理。</p>
</li>
</ol>
<blockquote>
<p>看上去没什么卵拥，我都已经接收到数据了，只是重复了而已，丢弃就行。为什么还要发送ACK发送端呢？<br>
主要目的是帮助发送方判断，是包失序，ACK丢失，包重复，伪重传。让发送端知晓更多信息，更好做网络控制。</p>
</blockquote>
<h3 id="tcp的粘包与拆包">TCP的粘包与拆包</h3>
<p>TCP协议是面向字节流的，它本身不保证<code>消息边界</code>。 也就是说，应用层的多个数据包可能会被<code>合并成一个TCP段</code>来传输，一个数据包也可能被<code>拆分为多个TCP段</code>。</p>
<blockquote>
<p>其本质是应用层消息边界在TCP流中消失</p>
</blockquote>
<p>究其发生的原因，无外乎两种，数据包过小与过大。</p>
<ol>
<li>数据包过小<br>
TCP会将多个数据包合并为一个TCP段。发生粘包</li>
<li>数据包过大<br>
TCP会将其拆分为多个段传输（如 10KB 数据拆成 3 个段），发生拆包，接收方需重组后才能获取完整消息。</li>
<li>接收端读取数据不及时<br>
多个TCP段累计在缓冲区中。无法一次性读完，因此不知道数据的边界在哪。发生粘包。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428100739457-2111545445.png" alt="image" loading="lazy"></p>
<blockquote>
<p>解决粘包/拆包的核心思路</p>
</blockquote>
<ol>
<li>消息定长<br>
每个数据包的长度固定</li>
<li>分割符标记<br>
比如C++中经常出现的EOF标记</li>
<li>头部包含长度字段<br>
在每个数据包的头部添加一个固定长度的字段，标明消息体的总长度。接收方先读取头部获取长度，再按长度读取完整消息体</li>
</ol>
<h2 id="udp协议">UDP协议</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428103255504-1625312037.png" alt="image" loading="lazy"></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>TCP（传输控制协议）</strong></th>
<th><strong>UDP（用户数据报协议）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>连接方式</strong></td>
<td>面向连接（三次握手建立连接，四次挥手断开连接）</td>
<td>无连接（直接发送数据报，无需预先建立通道）</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠传输：<br>- 序列号与确认应答（ACK）<br>- 超时重传与快速重传<br>- 流量控制（滑动窗口）<br>- 拥塞控制（慢启动、拥塞避免）</td>
<td>不可靠传输：<br>- 不保证数据到达、顺序或完整性<br>- 无重传、流量控制或拥塞控制</td>
</tr>
<tr>
<td><strong>传输模式</strong></td>
<td>流式传输：<br>- 数据无边界，需应用层处理消息边界（可能出现粘包问题）</td>
<td>数据报传输：<br>- 每个数据报独立传输，接收方明确获取边界</td>
</tr>
<tr>
<td><strong>首部开销</strong></td>
<td>固定 20 字节（含序列号、确认号、窗口大小等复杂字段）</td>
<td>仅 8 字节（源端口、目标端口、长度、校验和）</td>
</tr>
<tr>
<td><strong>延迟与速度</strong></td>
<td>延迟较高（连接建立/重传机制耗时），传输速度较慢</td>
<td>延迟低（无连接/轻量级协议），传输速度快</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>- <strong>需可靠性场景</strong>：HTTP/HTTPS（网页浏览）、FTP（文件传输）、SMTP（邮件）、SSH（远程登录）<br>- <strong>典型案例</strong>：下载文件时确保数据完整</td>
<td>- <strong>需实时性场景</strong>：视频会议（WebRTC）、在线游戏（如《王者荣耀》）、直播<br>- <strong>典型案例</strong>：视频直播中容忍少量丢包以降低延迟</td>
</tr>
<tr>
<td><strong>其他关键差异</strong></td>
<td>- <strong>全双工通信</strong>：支持双向同时传输<br>- <strong>面向字节流</strong>：数据以连续字节流传输</td>
<td>- <strong>无连接状态</strong>：无需维护连接参数<br>- <strong>数据报独立性</strong>：每个数据包独立寻址</td>
</tr>
<tr>
<td><strong>协议结构</strong></td>
<td>- 首部包含 16 位源端口、16 位目标端口、32 位序列号、32 位确认号等</td>
<td>- 首部仅 4 个字段：源端口、目标端口、长度、校验和</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>支持（通过慢启动、快速恢复等算法）</td>
<td>不支持（可能加剧网络拥塞）</td>
</tr>
<tr>
<td><strong>适用网络环境</strong></td>
<td>复杂网络（如互联网），需处理高丢包率和延迟</td>
<td>可靠网络或对可靠性要求低的场景（如局域网）</td>
</tr>
</tbody>
</table>
<h1 id="眼见为实">眼见为实</h1>
<p>使用wireshark来进行抓包</p>
<h2 id="三次握手">三次握手</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428142949319-388087381.png" alt="image" loading="lazy"></p>
<h2 id="传输数据">传输数据</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428143436846-1355510004.png" alt="image" loading="lazy"></p>
<blockquote>
<p>这里发送了3条消息，两条连接成一组。 可以看到ACK是不断累加，两边互相确认保证数据传输无误。</p>
</blockquote>
<h2 id="四次挥手">四次挥手</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202504/1084317-20250428144011662-808990678.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1095914235636574" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-28 16:28">2025-04-28 14:02</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">185</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18838393);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18838393', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18838393', title: 'C#网络编程(一)----DNS/TCP/UDP' })">举报</a>
</div>
        