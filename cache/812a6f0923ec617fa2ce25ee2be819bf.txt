
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xbdedu/p/18678604" title="发布于 2025-01-18 16:53">
    <span role="heading" aria-level="2">基于C#实现多线程启动停止暂停继续</span>
    

</a>

        </h2>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-first-child="" data-pid="Y7SKooy-">大家好！我是付工。</p>
<p data-pid="7AQWqDjM">大部分初学者在学习C#上位机编程时，多线程是一个很难逾越的鸿沟，不合理地使用多线程，会导致经常出现各种奇怪的问题，这也是很多初学者不敢使用多线程的原因。但是在实际开发中，多线程是一个不可避免的技术栈，基本上每个项目都会使用到，因此学好多线程技术，很重要。</p>
<h3>一、多线程原理</h3>
<p data-pid="MySJZ6ID">首先，我们要了解什么是多线程，多线程是一种技术，能够让一个程序同时运行多个独立的执行流程，这个执行流程即线程，这样就可以提高程序的并发性和效率，使程序能够更有效地利用系统资源。</p>
<p data-pid="qT_S7Jro">打个比方，刚创业的时候，我们可能是一个人身兼多职，既要对接业务，又要做技术，还需要管理财务，虽然你可以同时做这些事情，但毕竟只有一个人，这里的同时，其实是靠“时间管理”来实现的，这就是单核CPU实现多线程的原理，依靠时间片切换来实现多个任务，这个时间片很短，通常在10-100ms数量级，因此，让我们感觉是同时进行的。</p>
<p data-pid="OnlYLwSt">随着技术的不断发展，现在的计算机CPU基本上都是多核的。8核、16核，都很常见，多核意味着有多个核心，可以同时运行多个任务。</p>
<p data-pid="4k81U9wG">因此，多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p>
<p data-pid="z8-kIeIa">如果你做项目不使用多线程，不仅是技术的问题，也是对电脑资源的极大浪费，就像买了一辆性能车，但是只用来日常代步。</p>
<h3>二、多线程发展</h3>
<p data-pid="AIVH1RMe">我们知道了多线程技术可以保证我们代码的高效运行，提高CPU资源的使用率，为什么很多人不敢使用，主要是因为多线程如果使用不当，容易出现各种奇怪的问题。</p>
<p data-pid="nTmZNMJY">我们必须要明确一点，多线程是“不可控的”，不要把多线程当做一个开关，需要的时候就开一下，不需要的时候就关闭一下。从微观角度来看，多线程是靠CPU调度来实现的，我们常说的开启多线程，只是告诉CPU，这个线程可以开了，但是至于是立即开，还是等一会再开，这个是由CPU调度决定的，对于关闭多线程也是一样。</p>
<p data-pid="Zt01g7C6">我们后续提到的控制多线程启动、停止、暂停、继续，这些都是.NET框架中提供的一些接口（方法）给开发人员，这样程序员就可以间接地实现多线程。</p>
<p data-pid="YYRyXHeM">微软的多线程技术也是在一直发展中，在.NET 1.0中就出现了多线程Thread，到2.0时推出了ThreadPool线程池，再到3.0是出现了Task，Task也是我们目前使用比较多的，Task被称之为多线程的最佳实践，再到4.0时推出Parallel并行编程，再到4.5推出async/await语法糖，它让我们可以用同步方法来实现异步编程。</p>
<img src="https://picx.zhimg.com/80/v2-fc9aa503615b197d71f50cae4e7e3fe7_720w.webp" width="762" height="281" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="762" data-rawheight="281" data-original-token="v2-6e5386ee3f9e7e5968ffa846b12cb7a6" data-original="https://picx.zhimg.com/v2-fc9aa503615b197d71f50cae4e7e3fe7_r.jpg" data-actualsrc="https://picx.zhimg.com/v2-fc9aa503615b197d71f50cae4e7e3fe7_1440w.jpg" data-lazy-status="ok">
<h3>三、多线程启停</h3>
<p data-pid="gmu4rIoP">Task是我们使用多线程开发中经常使用的一个类，这个类中提供了丰富的API函数，让我们可以很方便地对多线程进行管理，包括开启多线程了，就有很多种方法，比如Task.Run、Task.Factory.StartNew、Start等，由于篇幅有限，这里以其中一种进行说明。</p>
<p data-pid="1YnmG_dV">我们来使用多线程实现一个简单的案例，我们来做一个线程任务，这个任务很简单，就是让一个值类型的变量，每间隔100ms，自增一次，到一个值后，再0开始重新计数，然后将这个值显示在界面上，界面如下所示：</p>
<img src="https://pic1.zhimg.com/80/v2-c2e606760088f10a486f751e1fad2762_720w.webp" width="539" height="308" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="539" data-rawheight="308" data-original-token="v2-8fe1e80b656f279187328424e4021f52" data-original="https://pic1.zhimg.com/v2-c2e606760088f10a486f751e1fad2762_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c2e606760088f10a486f751e1fad2762_1440w.jpg" data-lazy-status="ok">
<p data-pid="9ORCgakF">所以该任务执行代码如下：</p>
<img src="https://pic1.zhimg.com/80/v2-107bfc4e55a6d1bb20c8d610e90e4078_720w.webp" width="600" height="304" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="304" data-original-token="v2-d85d280d04a0466c038b261afdac42a4" data-original="https://pic1.zhimg.com/v2-107bfc4e55a6d1bb20c8d610e90e4078_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-107bfc4e55a6d1bb20c8d610e90e4078_1440w.jpg" data-lazy-status="ok">
<p data-pid="RDQ066f1">我们可以看到在方法里调用了一个cts对象，这个对象就是CancellationTokenSource的对象，因此我们需要创建一个CancellationTokenSource对象cts，同时在属性CurrentValue中，要显示控件的值，这里需要用到委托实现跨线程访问的问题，这个我们后续专题讲解，代码如下：</p>
<img src="https://pic4.zhimg.com/80/v2-c9d9b4088fa5d7af5cc6093751ade1e3_720w.webp" width="600" height="427" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="427" data-original-token="v2-40f87459b98b370d52f91e04c0797005" data-original="https://pic4.zhimg.com/v2-c9d9b4088fa5d7af5cc6093751ade1e3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-c9d9b4088fa5d7af5cc6093751ade1e3_1440w.jpg" data-lazy-status="ok">
<p data-pid="OfrDiZgy">然后在启动线程按钮的事件里，编写代码如下：</p>
<img src="https://pic3.zhimg.com/80/v2-369cf861e89b7abbede38fc40f706bf6_720w.webp" width="600" height="185" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="185" data-original-token="v2-28181cc42bb2e0b0f5ce046c3d45b863" data-original="https://pic3.zhimg.com/v2-369cf861e89b7abbede38fc40f706bf6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-369cf861e89b7abbede38fc40f706bf6_1440w.jpg" data-lazy-status="ok">
<p data-pid="94u7A-gG">停止线程按钮的事件里，只需要调用cts的Cancel方法即可：</p>
<img src="https://pic1.zhimg.com/80/v2-20e039aed41b3d9cd183e31a431656ca_720w.webp" width="600" height="164" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="164" data-original-token="v2-7b63db802c7072c5ddc2ef549c0c1baa" data-original="https://pic1.zhimg.com/v2-20e039aed41b3d9cd183e31a431656ca_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-20e039aed41b3d9cd183e31a431656ca_1440w.jpg" data-lazy-status="ok">
<p data-pid="zRDUjtmv">我们可以看到，这里就是通过cts来控制cts的IsCancellationRequested属性，进而实现多线程的控制，这里的cts.IsCancellationRequested类似于一个布尔类型的标志位，但是CancellationTokenSource的作用不仅如此，还可以在此基础上实现多线程超时判断，注册事件等更复杂的多线程操作。</p>
<h3>四、多线程暂停继续</h3>
<p data-pid="R3qFYF-D">多线程的暂停继续，.NET为我们提供了另外一个对象——ManualResetEvent，这个对象会有一个值，这个值是布尔类型，就像一个门闸一样，True是打开门闸，False是关闭门闸，所以想要暂停多线程就调用这个对象的Reset方法，想要继续多线程就调用这个对象的Set方法，使用非常简单。</p>
<p data-pid="6M3Za1Oc">首先我们创建一下这个对象，可以通过构造方法，给这个对象赋初始值，我这里为True，这样就能直接运行，不会阻塞，代码如下：</p>
<img src="https://pica.zhimg.com/80/v2-5bde271202ba476764294ec4190d4bf0_720w.webp" width="600" height="133" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="133" data-original-token="v2-e632645aac51aa97edb8ef4c8bc9fb97" data-original="https://pica.zhimg.com/v2-5bde271202ba476764294ec4190d4bf0_r.jpg" data-actualsrc="https://pica.zhimg.com/v2-5bde271202ba476764294ec4190d4bf0_1440w.jpg" data-lazy-status="ok">
<p data-pid="2ANt-R1I">但是如果希望这个对象与多线程有所联系，必须要在多线程的方法里体现这个对象的作用，这个是调用这个对象的WaitOne方法，表示在调用的地方阻塞住，通过判断True或者False来决定是否继续执行，就像大家开车过高速收费站一样，即使现在普遍采用ETC了，在入口也需要减速，有一个ETC识别的过程，识别成功才会抬杆，识别不对，杆子是不会自动抬起的，这个是一样的道理。</p>
<p data-pid="XggsJXaQ">所以线程执行代码修改如下：</p>
<img src="https://picx.zhimg.com/80/v2-bfdac23d7bc20309599bb6afe88524f9_720w.webp" width="600" height="337" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="337" data-original-token="v2-3d88aa6f78f5c9565fa9b57c6e06e2d0" data-original="https://picx.zhimg.com/v2-bfdac23d7bc20309599bb6afe88524f9_r.jpg" data-actualsrc="https://picx.zhimg.com/v2-bfdac23d7bc20309599bb6afe88524f9_1440w.jpg" data-lazy-status="ok">
<p data-pid="9F7hSuQL">对比一下，其实就是加了一个manual.WaitOne()。</p>
<p data-pid="fjJrmEMW">线程暂停继续代码如下：</p>
<img src="https://pic3.zhimg.com/80/v2-cea5aa96cb4fdb36f53f707a2391340c_720w.webp" width="600" height="200" class="origin_image zh-lightbox-thumb lazy" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="200" data-original-token="v2-66c1c0a2ef18123d1874443e3b444699" data-original="https://pic3.zhimg.com/v2-cea5aa96cb4fdb36f53f707a2391340c_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-cea5aa96cb4fdb36f53f707a2391340c_1440w.jpg" data-lazy-status="ok">
<p data-pid="1MI1NMur">暂停继续的使用除了ManualResetEvent，还有一个AutoResetEvent，AutoResetEvent和ManualResetEvent的用法基本上是一样的，这里就不过多赘述，大家可以自己尝试一下。</p>
<p data-pid="1nPlc8ad">这两者的区别在于一个是手动，一个是自动，AutoResetEvent会在置位之后自动复位，这样体现在多线程里，就是会只执行一次，就像大家进小区一样，如果有10辆车在排队，这时候如果自动模式，每次都要抬杆落杆，每次只允许进一辆车，如果是手动模式，可以由保安控制门闸打开，等10辆车都进去之后，再由保安将门闸关闭。</p>
</div>
<div class="clear"></div>

        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.05559090306828704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 16:54">2025-01-18 16:53</span>&nbsp;
<a href="https://www.cnblogs.com/xbdedu">付工上位机</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678604" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678604);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678604', targetLink: 'https://www.cnblogs.com/xbdedu/p/18678604', title: '基于C#实现多线程启动停止暂停继续' })">举报</a>

        </p>
    