
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18849726" title="发布于 2025-05-14 22:08">
    <span role="heading" aria-level="2">C#网络编程(四)----HttpClient</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>HttpClient是C#中用于发送/接收HTTP请求的核心类，属于 System.Net.Http 命名空间。它是 .NET 中处理网络通信的现代 API，设计目标是替代早期的 WebClient/WebRequest/WebResponse/HttpWebRequest，支持异步编程、灵活配置和高性能网络交互，广泛用于调用 REST API、与 Web 服务通信、文件上传 / 下载等场景。</p>
<p><code>相对过时的类库，它的核心优势如下</code></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>异步优先</strong></td>
<td>所有方法都返回Task，支持async/await模式，避免线程阻塞</td>
</tr>
<tr>
<td><strong>连接池复用</strong></td>
<td>自动复用TCP连接(基于 Connection: keep-alive)，减少重复握手</td>
</tr>
<tr>
<td><strong>完善的Stream处理</strong></td>
<td>支持大文件流式读取内容，避免缓冲区溢出</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>实例本身是线程安全的（但需注意配置不可变，比如DNS），推荐复用实例（避免频繁创建导致端口耗尽）。</td>
</tr>
<tr>
<td><strong>灵活的请求配置</strong></td>
<td>支持链式配置自定义请求头，超时时间，代理，编码，SSL等功能</td>
</tr>
<tr>
<td><strong>继承第三方HTTP库</strong></td>
<td>可以替换默认的SocketsHttpHandler，来实现自定义HTTP请求库</td>
</tr>
</tbody>
</table>
<h2 id="发送请求">发送请求</h2>
<pre><code>//GET
HttpResponseMessage response = await _httpClient.GetAsync("https://www.baidu.com");
response.EnsureSuccessStatusCode(); // 检查状态码是否为 200-299，否则抛异常
string json = await response.Content.ReadAsStringAsync(); // 读取响应内容
Console.WriteLine($"响应内容：{json}");


//POST
var formContent = new MultipartFormDataContent();
var fileStream = new StreamContent(File.OpenRead("D:\\xxxx.jpg"));
fileStream.Headers.ContentType = MediaTypeHeaderValue.Parse("image/jpeg");
formContent.Add(fileStream, "file", "test.jpg"); // "file" 是表单字段名

HttpResponseMessage response = await _httpClient.PostAsync("https://api.example.com/upload", formContent);
response.EnsureSuccessStatusCode();
Console.WriteLine("文件上传成功");
</code></pre>
<h2 id="处理响应">处理响应</h2>
<p>HttpResponseMessage 包含响应的状态码、头部、内容等信息，关键属性如下：</p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>StatusCode</strong></td>
<td>HTTP 状态码（如 200 OK、404 Not Found）。</td>
</tr>
<tr>
<td><strong>Headers</strong></td>
<td>响应头部（如 Content-Type、Server）。</td>
</tr>
<tr>
<td><strong>Content</strong></td>
<td>响应内容（类型为 HttpContent），支持读取为字符串、流、字节数组等。</td>
</tr>
<tr>
<td><strong>EnsureSuccessStatusCode()</strong></td>
<td>若状态码非成功（2xx），抛出 HttpRequestException</td>
</tr>
<tr>
<td><strong>ReadAsStringAsync()</strong></td>
<td>异步读取内容为字符串（适合小数据，如 JSON）。</td>
</tr>
<tr>
<td><strong>ReadAsStreamAsync()</strong></td>
<td>异步读取内容为流（适合大文件下载，避免内存占用）。</td>
</tr>
<tr>
<td><strong>ReadAsByteArrayAsync()</strong></td>
<td>异步读取内容为字节数组（适合二进制数据，如图像）</td>
</tr>
</tbody>
</table>
<h2 id="自定义配置">自定义配置</h2>
<p>通过 HttpClient 的属性和 HttpClientHandler 可以自定义请求行为</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeout</td>
<td>请求超时时间（默认 100 秒），设置为 Timeout.InfiniteTimeSpan 表示无超时</td>
</tr>
<tr>
<td>DefaultRequestHeaders</td>
<td>所有请求默认携带的头部（如 User-Agent、Authorization）</td>
</tr>
<tr>
<td>BaseAddress</td>
<td>基础 URL后续请求只需指定相对路径</td>
</tr>
<tr>
<td>HttpClientHandler</td>
<td>底层处理器，可配置代理、证书验证、自动重定向、压缩等</td>
</tr>
</tbody>
</table>
<pre><code>var handler = new HttpClientHandler {
    Proxy = new WebProxy("http://proxy.example.com:8080"), // 设置代理
    UseProxy = true,
    ServerCertificateCustomValidationCallback = (req, cert, chain, errors) =&gt; true // 跳过证书验证（仅测试用）
};

var httpClient = new HttpClient(handler) {
    Timeout = TimeSpan.FromSeconds(30), // 30 秒超时
    BaseAddress = new Uri("https://api.example.com/")
};

// 添加默认请求头（如认证令牌）
httpClient.DefaultRequestHeaders.Authorization = 
    new AuthenticationHeaderValue("Bearer", "your_access_token");
</code></pre>
<h1 id="结构解析">结构解析</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250515113241452-1660250887.png" alt="image" loading="lazy"></p>
<ol>
<li>
<p>HttpClient/HttpMessageInvoker<br>
用户入口，提供GET/POST/PUT/DELETE等友好API，协调请求发送于响应接收。<br>
HttpClient本身是轻量级对象，仅包含了配置信息和对HttpMessageHandler的引用。</p>
</li>
<li>
<p>HttpMessageHandler<br>
HttpMessageHandler是 <code>核心抽象类</code>，定义了处理 HTTP 请求的基本行为。它通过抽象方法 SendAsync 接收 HttpRequestMessage，并返回 HttpResponseMessage。</p>
</li>
<li>
<p>HttpClientHandler<br>
HttpClientHandler是HttpMessageHandler 的具体子类，<br>
是早期 .NET中默认的 HTTP 处理程序。在.NET Core 2.1后，它演变为兼容层，底层通过 SocketsHttpHandler 实现网络通信，保持 API 兼容性。</p>
</li>
<li>
<p>SocketsHttpHandler<br>
这才是持有网络资源（TCP 连接池、TLS 会话）的<code>核心组件</code>，.NET Core 2.1之后默认的HTTP处理器，直接基于System.Net.Sockets，性能高且跨平台。</p>
</li>
<li>
<p>DelegatingHandler<br>
DelegatingHandler是一个抽象类，以<code>责任链模式</code>拓展请求处理逻辑，可以通过继承DelegatingHandler，以中间件的方式实现自定义逻辑(日志，重试，退让，缓存等)</p>
</li>
<li>
<p>HttpRequestMessage/HttpResponseMessage<br>
<strong>HttpRequestMessage：</strong>表示 HTTP 请求，包含 Method（如 HttpMethod.Get）、RequestUri、Headers、Content（请求体）等属性。<br>
<strong>HttpResponseMessage：</strong>表示 HTTP 响应，包含 StatusCode（状态码）、Headers、Content（响应体）、ReasonPhrase（状态描述）等属性。</p>
</li>
<li>
<p>HttpContent<br>
请求体与响应体的基类，定义了内容的通用操作，再根据不同的数据，派生出不同的子类。<br>
<strong>StringContent：</strong>文本内容（如 JSON、HTML）。<br>
<strong>ByteArrayContent：</strong>二进制字节数组内容（如图像、文件）。<br>
<strong>StreamContent：</strong>流式内容（如大文件上传）。<br>
<strong>MultipartFormDataContent：</strong>表单内容（支持文件上传）</p>
</li>
</ol>
<h1 id="请求处理流程">请求处理流程</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250515112531337-1457816259.png" alt="image" loading="lazy"></p>
<h1 id="net-9中优化">.NET 9中优化</h1>
<blockquote>
<p><a href="https://devblogs.microsoft.com/dotnet/dotnet-9-networking-improvements/#community-contributions" target="_blank" rel="noopener nofollow">https://devblogs.microsoft.com/dotnet/dotnet-9-networking-improvements/#community-contributions</a></p>
</blockquote>
<h1 id="弹性处理polly">弹性处理(Polly)</h1>
<p>总所周知，互联网是不稳定的，可能会网络波动、服务暂不可用等导致的瞬态故障。因此，一个健壮HttpClient还需要实现<code>重试，断路，回退，超时</code>等弹性处理，避免因单次失败直接终止业务流程。</p>
<blockquote>
<p>Polly 提供了 6 大核心策略，覆盖常见的弹性需求：</p>
</blockquote>
<ol>
<li>重试（Retry）<br>
当操作失败时（如抛异常或返回特定状态码），自动重试若干次，适用于可自愈的瞬态故障（如网络抖动）。</li>
</ol>
<pre><code>var retryPolicy = Policy
    .Handle&lt;HttpRequestException&gt;() // 处理 HTTP 请求异常
    .OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode) // 或非成功状态码
    .WaitAndRetryAsync(
        retryCount: 3,
        sleepDurationProvider: retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), // 指数退避
        onRetry: (result, sleepDuration, retryCount, context) =&gt; 
        {
            Console.WriteLine($"重试 {retryCount} 次，等待 {sleepDuration}，上次结果：{result.Exception?.Message ?? result.Result.StatusCode.ToString()}");
        }
    );
</code></pre>
<ol start="2">
<li>断路（Circuit Breaker）<br>
当故障频率超过阈值时，主动 “断开” 电路（拒绝后续请求），防止级联故障（如服务已崩溃，继续重试会加重负载）。</li>
</ol>
<pre><code>// 定义断路策略：10 秒内 5 次失败则断路 30 秒
var circuitBreaker = Policy
	.Handle&lt;HttpRequestException&gt;()
	.OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
	.CircuitBreakerAsync(
		5,
		TimeSpan.FromSeconds(30)
	);
</code></pre>
<ol start="3">
<li>回退（Fallback）<br>
当操作失败时，提供一个 “备用方案”（如返回缓存数据、默认值），避免用户看到错误。</li>
</ol>
<pre><code>// 定义回退策略：失败时返回预设的默认响应
var fallbackPolicy = Policy
    .Handle&lt;HttpRequestException&gt;()
    .OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .FallbackAsync(
        fallbackValue: new HttpResponseMessage(HttpStatusCode.OK) // 默认成功响应
        { Content = new StringContent("备用数据（来自缓存或默认值）") },
        onFallbackAsync: (result, context) =&gt; 
        {
            Console.WriteLine($"执行回退，原错误：{result.Exception?.Message}");
            return Task.CompletedTask;
        }
    );
</code></pre>
<ol start="4">
<li>超时（Timeout）<br>
限制操作的执行时间，避免长时间等待（如数据库查询超时）。</li>
</ol>
<pre><code>// 定义超时策略：操作超过 10 秒未完成则抛 TimeoutRejectedException
var timeoutPolicy = Policy
    .TimeoutAsync(
        timeout: TimeSpan.FromSeconds(10),
        onTimeoutAsync: (context, timeout, task) =&gt; 
        {
            Console.WriteLine($"操作超时，已等待 {timeout}");
            return Task.CompletedTask;
        }
    );
</code></pre>
<ol start="5">
<li>组合<br>
Polly支持将多个策略组合，按照组合顺序执行，用以应对复杂场景。<br>
比如<code>先重试，重试失败触发断路，断路期间执行回退。</code></li>
</ol>
<pre><code>// 组合策略，先执行最外层。
var wrappedPolicy = Policy.WrapAsync(
	fallbackPolicy,//最外层：失败时回退
	circuitBreakerkPolicy,//中层：断路保护
	retryPolicy //内层:重试
	);
</code></pre>
<h2 id="resilience">Resilience</h2>
<p>Resilience 是微软官方推出的现代弹性库，它是对Polly的封装，其核心目标是<code>降低弹性编程的门槛</code>。</p>
<blockquote>
<p>具体介绍请查阅MSDN，<a href="https://learn.microsoft.com/zh-cn/dotnet/core/resilience/http-resilience?tabs=dotnet-cli" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/dotnet/core/resilience/http-resilience?tabs=dotnet-cli</a></p>
</blockquote>
<p>它相对Polly的优势在于：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>Resilience</code></th>
<th><code>Polly</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>生态集成</strong></td>
<td>深度集成 ASP.NET Core（DI、<code>IHttpClientFactory</code>、配置）</td>
<td>需手动集成（如通过 <code>AddPolicyHandler</code>）</td>
</tr>
<tr>
<td><strong>配置方式</strong></td>
<td>支持从 <code>IConfiguration</code> 动态加载，支持热更新</td>
<td>需手动解析配置，无内置热更新</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>内置日志、指标、诊断事件</td>
<td>需通过回调手动实现</td>
</tr>
<tr>
<td><strong>API 设计</strong></td>
<td>类型安全的泛型 <code>ResiliencePipeline&lt;T&gt;</code></td>
<td>基于 <code>Policy</code> 和 <code>Policy&lt;TResult&gt;</code></td>
</tr>
<tr>
<td><strong>动态调整</strong></td>
<td>支持运行时修改策略参数（如重试次数）</td>
<td>需重建策略实例</td>
</tr>
<tr>
<td><strong>长期支持</strong></td>
<td>微软官方维护，长期演进方向</td>
<td>社区维护（Polly 7+ 支持 .NET Standard）</td>
</tr>
</tbody>
</table>
<h1 id="faq">FAQ</h1>
<h2 id="为什么不推荐new-httpclient的方式">为什么不推荐New HttpClient()的方式?</h2>
<p>上面讲到，HttpClient是线程安全的，那为什么不推荐使用New HttpClient()呢？<br>
主要是因为每一个HttpClient都会有一个独立的连接池造成的。</p>
<ol>
<li>
<p>端口耗尽<br>
每个 HttpClient 实例默认使用独立的 SocketsHttpHandler，在其内部按照Authority(<a href="https://xxxx.com:443" target="_blank" rel="noopener nofollow">https://xxxx.com:443</a>)进行分组管理TCP连接。如果是同一个Authority，则会复用连接。<br>
但如果是通过New HttpClient()的方式创建，即时是同一个URL，也会为分配新的端口号，无法实现复用，导致端口耗尽</p>
</li>
<li>
<p>TIME_WAIT 状态堆积<br>
当TCP连接关闭时，发起端会进入TIME_WAIT状态，并等待2MSL(约60s)。以确保接收端收到最终的ACK包。如若HttpClient被频繁创建和销毁，其底层的TCP连接会大量处于TIME_WAIT 状态，进一步加剧端口耗尽。</p>
</li>
<li>
<p>无法统一配置与拓展<br>
直接new HttpClient 难以统一管理公共配置，如代理、超时、证书验证等，每个实例都要配置一遍，<code>代码非常冗余</code>。<br>
且无法便捷集成扩展功能（如重试策略、断路机制、日志记录），这些需要通过 DelegatingHandler 实现，但 new 的方式难以统一添加中间件</p>
</li>
</ol>
<h3 id="眼见为实">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250514103842117-1922245596.png" alt="image" loading="lazy"></p>
<p><a href="https://www.cnblogs.com/maijin/p/18803787" title="图出处" target="_blank">图出处</a></p>
<h2 id="为什么在net-framework中不推荐单例静态的httpclient">为什么在.NET Framework中不推荐单例/静态的HttpClient?</h2>
<p>既然不推荐New HttpClient()，那我将HttpClient设单例或者静态的行不行？<br>
答案是也不行，因为HttpClient在首次解析域名后，会缓存DNS结果，默认缓存时间取决于操作系统和 DNS 服务器配置。<br>
如果HttpClient实例被长期保留，当DNS记录更新时(比如服务器IP变更)，会<code>导致请求失败或者连接到旧服务器</code>。</p>
<blockquote>
<p>仅针对 .NET Framework，在.NET Core之后，可以设置PooledConnectionLifetime来解决DNS缓存问题，从而变相解决端口耗尽问题。</p>
</blockquote>
<h3 id="眼见为实-1">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250514095607385-843406507.png" alt="image" loading="lazy"><br>
连接池缓存的地址，是以传入的URL作为Key。不是最终的IP地址，因此需要依赖DNS缓存来动态解析服务器IP地址。</p>
<p><a href="https://source.dot.net/#System.Net.Http/System/Net/Http/SocketsHttpHandler/HttpConnectionPoolManager.cs,8af6288f85799b87" title="源码" target="_blank" rel="noopener nofollow">源码</a></p>
<h2 id="time_wait的优化几个思路">TIME_WAIT的优化几个思路</h2>
<p>TCP的四次挥手是在内核态中进行处理的，我们<code>难以在用户态层面进行大刀阔斧的优化</code>。<br>
我们可以通过以下几种方式来进行小幅度优化：</p>
<ol>
<li>开启端口复用（内核态）<br>
调整操作系统配置，允许系统重用处于 TIME_WAIT 状态的端口。</li>
<li>缩短TIME_WAIT时间（内核态）<br>
TIME_WAIT 状态的默认持续时间是 60 秒，缩短此值可减少状态堆积。但会增加旧数据包干扰新连接的风险。</li>
<li>开启HTTP2（用户态）<br>
HTTP/2 支持 单 TCP 连接上的多路复用，多个请求 / 响应可并行传输，显著减少需要创建 / 关闭的 TCP 连接数量。</li>
</ol>
<pre><code>.ConfigurePrimaryHttpMessageHandler(() =&gt; new SocketsHttpHandler
{
    EnableHttp2 = true // 显式启用 HTTP/2（默认自动协商）
});
</code></pre>
<ol start="4">
<li>禁用 Nagle 算法(用户态)</li>
</ol>
<pre><code>.ConfigurePrimaryHttpMessageHandler(() =&gt; new SocketsHttpHandler
{
    ConnectCallback = async (context, cancellationToken) =&gt; 
    {
        var socket = new Socket(SocketType.Stream, ProtocolType.Tcp);
        socket.NoDelay = true; // 禁用 Nagle 算法（减少延迟）
        await socket.ConnectAsync(context.DnsEndPoint, cancellationToken);
        return new NetworkStream(socket, ownsSocket: true);
    }
});
</code></pre>
<ol start="5">
<li>延长连接空闲时间(用户态)</li>
</ol>
<pre><code>new SocketsHttpHandler
{
    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(2), // 空闲 2 分钟后关闭（而非立即关闭）
    PooledConnectionLifetime = TimeSpan.FromMinutes(10)    // 连接最长存活 10 分钟（避免频繁轮换）
};
</code></pre>
<blockquote>
<p>需要注意一点，服务器通常作为被动关闭方，一般不会产生大量TIME_WAIT连接，但在微服务大行其道的今天，服务器与服务器之间的通信，服务器也会作为发起方，导致出现大量的TIME_WAIT。</p>
</blockquote>
<h2 id="ihttpclientfactory的优势">IHttpClientFactory的优势？</h2>
<p>为了解决HttpClient端口耗尽与DNS缓存问题。.NET提供了IHttpClientFactory。</p>
<ol>
<li>连接池复用与端口管理<br>
IHttpClientFactory 负责管理 HttpClient 实例的<code>生命周期</code>，<code>共享底层 SocketsHttpHandler 和连接池</code>，避免重复创建连接池和端口.</li>
</ol>
<blockquote>
<p>有一点需要注意，如果应用需要使用Cookie，要考虑禁用自动Cookie处理。因为IHttpClientFactory共享底层的SocketsHttpHandler，所以会导致CookieContainer也会被共享，从而导致网站A的Cookie被<code>劫持</code>到了网站B。</p>
</blockquote>
<ol start="2">
<li>统一配置与扩展<br>
通过<code>AddHttpClient</code>注册客户端，集中配置，统一管理</li>
</ol>
<pre><code>serviceCollection
.AddHttpClient&lt;BaiduAPIService&gt;(configure =&gt;
{
	configure.BaseAddress = new Uri("https://www.baidu.com");
})
.AddHttpMessageHandler&lt;CustomerHandler&gt;();
</code></pre>
<ol start="3">
<li>DNS动态更新<br>
通过 SetHandlerLifetime 配置 HttpMessageHandler 的生命周期（默认 2 分钟），到期后自动重建 Handler 并重新解析 DNS，避免缓存旧 IP。</li>
</ol>
<pre><code>serviceCollection
	.AddHttpClient()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));
</code></pre>
<h2 id="ihttpclientfactory的生命周期">IHttpClientFactory的生命周期?</h2>
<blockquote>
<p>IHttpClientFactory的生命周期独立于DI。<br>
IHttpClientFactory在DI容器中以单例(Singleton)形式存在，通过IHttpClientFactory.CreateClient()获取的HttpClient实例是瞬态(Transient)，每次调用CreateClient都会返回一个新的HttpClient实例，但这些实例共享HttpMessageHandler管道。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250515111353439-1142667050.png" alt="image" loading="lazy"></p>
<h2 id="ihttpclientfactory的生命周期独立于di">IHttpClientFactory的生命周期独立于DI？</h2>
<p>DI 的生命周期（Transient/Scoped/Singleton）主要用于管理服务实例的创建与销毁，而IHttpClientFactory的核心目标是<code>高效管理HTTP连接</code>，这两者的理念存在严重冲突。</p>
<ol>
<li>HTTP连接的复用，需要长生命周期的HttpMessageHandler<br>
TCP的连接的创建成本极高，如果遵循DI的Scoped 生命周期，将会导致TCP连接无法复用，增加延迟与TIME_WAIT 状态堆积</li>
<li>DNS动态更新需要独立于 DI 的生命周期控制<br>
DNS解析结果会随着时间变化(服务器扩容/缩容)，若 HttpMessageHandler 生命周期与DI的Scoped绑定，若过长，会导致连接长期绑定旧IP，若过短，DNS解析过于频繁而限流。</li>
<li>HttpClient轻量级，频繁创建不会导致资源浪费</li>
</ol>
<blockquote>
<p>因此，IHttpClientFactory的生命周期独立于DI是一种优化的选择，而不是一种缺点</p>
</blockquote>
<h2 id="请勿重复注册httpclientservice">请勿重复注册HttpClientService</h2>
<pre><code>            var serviceCollection = new ServiceCollection();
            serviceCollection
                .AddHttpClient&lt;BaiduAPIService&gt;(configure =&gt;
                {
                    configure.BaseAddress = new Uri("https://www.baidu.com");

                });

            serviceCollection.AddSingleton&lt;BaiduAPIService&gt;();//重复注册BaiduAPIService，因为没有指定HttpClient的name，所以系统会提供default HttpClient，导致与上面的代码失效。可以使用TryAddSingleton or 删除此重复注册的代码。

</code></pre>
<h2 id="高并发情况下首次启动很慢">高并发情况下，首次启动很慢？</h2>
<p>HttpClient底层也用Task获取HttpConnection，当流量瞬增时，线程池创建新线程需要时间。等线程池<code>预热</code>后，便会恢复正常。</p>
<h2 id="我需要访问api-endpoint配置httpclient太繁琐了有没有更加简便的">我需要访问API Endpoint，配置HttpClient太繁琐了，有没有更加简便的？</h2>
<p>Refit是.NET生态中一款轻量级，声明式的HTTP客户端库，旨在通过<code>定义接口</code>的方式快速生成API Endpoint，<code>大幅度减少手动编写的样板代码</code>。</p>
<blockquote>
<p><a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener nofollow">https://github.com/reactiveui/refit</a></p>
</blockquote>
<pre><code>// Program.cs 中注册
serviceCollection.AddRefitClient&lt;BaiduAPIService&gt;()
	.ConfigureHttpClient(client =&gt;
	{
		client.BaseAddress = new Uri("https://api.github.com");
		client.DefaultRequestHeaders.Add("User-Agent", "MyApp/1.0");
	})
	.AddPolicyHandler(wrappedPolicy); // 添加弹性策略
public interface IGitHubApi
{
    // GET https://api.github.com/users/{username}
    [Get("/users/{username}")]
    Task&lt;User&gt; GetUserAsync(string username);

    // POST https://api.github.com/repos/{owner}/{repo}/issues
    [Post("/repos/{owner}/{repo}/issues")]
    Task&lt;Issue&gt; CreateIssueAsync(
        string owner, 
        string repo, 
        [Body] CreateIssueRequest request, 
        CancellationToken cancellationToken = default
    );
}
</code></pre>
<blockquote>
<p>分享一个曾经踩过的坑，.NET 6之前默认序列化/反序列化类库是Newtonsoft.Json，.NET 6之后切换成了System.Text.Json。Refit使用的是.NET默认配置，导致.NET 版本升级后，大量接口报错，惨遭挨锤！<br>
需要引用Refit.Newtonsoft.Json包，并修改配置ContentSerializer= new NewtonsoftJsonContentSerializer()。</p>
</blockquote>
<h1 id="最佳实践">最佳实践</h1>
<blockquote>
<p>方法一，个人推荐。</p>
</blockquote>
<pre><code>    internal class Program
    {
        static async Task Main(string[] args)
        {
            var serviceCollection = new ServiceCollection();
			//强类型，简单省事。
            serviceCollection
                .AddHttpClient&lt;BaiduAPIService&gt;(configure =&gt;
                {
                    configure.BaseAddress = new Uri("https://www.baidu.com");
                });  

            var services = serviceCollection.BuildServiceProvider();

            var httpClient= services.GetRequiredService&lt;BaiduAPIService&gt;();
            var result= await httpClient.GetStringAsync();
            Console.WriteLine(result);
        }
    }
	internal class BaiduAPIService
    {
        private readonly HttpClient _httpClient;

        public BaiduAPIService(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        public async Task&lt;string?&gt; GetStringAsync(string? url=null)
        {
            var response= await _httpClient.GetAsync(url);
            if (!response.IsSuccessStatusCode)
                return null;

            var result= await response.Content.ReadAsStringAsync();

            
            return result;
        }
    }
</code></pre>
<blockquote>
<p>方法二</p>
</blockquote>
<pre><code>    internal class Program
    {
        static async Task Main(string[] args)
        {
            var serviceCollection = new ServiceCollection();
			//自定义Name
            serviceCollection
                .AddHttpClient(nameof(BaiduAPIService), configure =&gt;
                {
                    configure.BaseAddress = new Uri("https://www.baidu.com");
                });

            serviceCollection.AddScoped&lt;BaiduAPIService&gt;();//需要主动注册DI
            var services = serviceCollection.BuildServiceProvider();

            var httpClient= services.GetRequiredService&lt;BaiduAPIService&gt;();
            var result= await httpClient.GetStringAsync();
            Console.WriteLine(result);
        }
    }
	internal class BaiduAPIService
    {
        private readonly HttpClient _httpClient;

        public BaiduAPIService(IHttpClientFactory httpClientFactory)
        {
            //因为DI不知道你要用哪个HttpClient，所以需要httpClientFactory来寻找name
            _httpClient = httpClientFactory.CreateClient(nameof(BaiduAPIService));
        }

        public async Task&lt;string?&gt; GetStringAsync(string? url=null)
        {
            var response= await _httpClient.GetAsync(url);
            if (!response.IsSuccessStatusCode)
                return null;

            var result= await response.Content.ReadAsStringAsync();

            
            return result;
        }
    }
</code></pre>
<blockquote>
<p>方法三，.NET 9后新增</p>
</blockquote>
<pre><code>    internal class Program
    {
        static async Task Main(string[] args)
        {
            var serviceCollection = new ServiceCollection();

            serviceCollection
                .AddHttpClient(nameof(BaiduAPIService), configure =&gt;
                {
                    configure.BaseAddress = new Uri("https://www.baidu.com");
                })
                .AddAsKeyed();//keyed DI 支持

            serviceCollection.AddScoped&lt;BaiduAPIService&gt;();
            var services = serviceCollection.BuildServiceProvider();

            var httpClient= services.GetRequiredService&lt;BaiduAPIService&gt;();
            var result= await httpClient.GetStringAsync();
            Console.WriteLine(result);
        }
    }
	internal class BaiduAPIService
    {
        private readonly HttpClient _httpClient;

        //从DI中选择你需要的HttpClient
        public BaiduAPIService([FromKeyedServices(nameof(BaiduAPIService))]HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        public async Task&lt;string?&gt; GetStringAsync(string? url=null)
        {
            var response= await _httpClient.GetAsync(url);
            if (!response.IsSuccessStatusCode)
                return null;

            var result= await response.Content.ReadAsStringAsync();

            
            return result;
        }
    }
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.025715518439814816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-15 17:40">2025-05-14 22:08</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">402</span>)&nbsp;
评论(<span id="post_comment_count">8</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18849726);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18849726', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18849726', title: 'C#网络编程(四)----HttpClient' })">举报</a>
</div>
        