
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18624757" title="发布于 2024-12-23 18:28">
    <span role="heading" aria-level="2">深入理解二叉查找树(BST)的重要查找操作</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>二叉查找树 (Binary Search Tree, 简称 BST) 是一种基本的数据结构，其设计核心在于每个节点的值都满足以下性质：</p>
<ul>
<li><strong>左子树的所有节点值</strong>均小于当前节点值。</li>
<li><strong>右子树的所有节点值</strong>均大于当前节点值。</li>
</ul>
<p>这使得二叉查找树能够高效地支持一系列查找相关操作，包括普通查找、前驱后继查询、基于排名的查询以及基于值的排名计算。在树形合理时，bst 可以以 log 的时间快速进行集合查找。</p>
<p>本文将结合代码和理论讲解这些操作，帮助读者全面掌握 BST 的查找机制。</p>
<p>假定我们这样构造二叉树：</p>
<pre><code>struct TreeNode {
    int value;       // 节点的值
    int size;        // 以该节点为根的子树大小
    TreeNode* left;  // 指向左子树
    TreeNode* right; // 指向右子树

    TreeNode(int v) : value(v), size(1), left(nullptr), right(nullptr) {}
};
</code></pre>
<hr>
<h2 id="1-普通查找">1. 普通查找</h2>
<h3 id="问题描述"><strong>问题描述</strong></h3>
<p>给定一个值 $ x $，我们希望在 BST 中找到值等于 $ x $ 的节点。</p>
<h3 id="查找思路"><strong>查找思路</strong></h3>
<p>从根节点开始递归或迭代：</p>
<ul>
<li>如果当前节点值等于 $ x $，则查找成功。</li>
<li>如果 $ x $ 小于当前节点值，则进入左子树继续查找。</li>
<li>如果 $ x $ 大于当前节点值，则进入右子树继续查找。</li>
<li>如果到达空节点，查找失败。</li>
</ul>
<h3 id="代码实现"><strong>代码实现</strong></h3>
<pre><code class="language-cpp">TreeNode* find(TreeNode* root, int value) {
    if (!root || root-&gt;value == value) return root;
    if (value &lt; root-&gt;value) return find(root-&gt;left, value);
    return find(root-&gt;right, value);
}
</code></pre>
<h3 id="时间复杂度"><strong>时间复杂度</strong></h3>
<ul>
<li><strong>平衡树</strong>：$ O(\log n) $</li>
<li><strong>非平衡树（退化为链表）</strong>：$ O(n) $</li>
</ul>
<p>即效率取决于树高。</p>
<hr>
<h2 id="2-查找前驱和后继">2. 查找前驱和后继</h2>
<h3 id="前驱与后继的定义"><strong>前驱与后继的定义</strong></h3>
<ul>
<li><strong>前驱</strong>：小于给定值的最大节点。</li>
<li><strong>后继</strong>：大于给定值的最小节点。</li>
</ul>
<h3 id="前驱查找"><strong>前驱查找</strong></h3>
<ul>
<li>如果节点有左子树，前驱是左子树中值最大的节点。</li>
<li>如果节点没有左子树，沿着父节点回溯，找到第一个右子树包含当前节点的祖先节点。</li>
</ul>
<h3 id="后继查找"><strong>后继查找</strong></h3>
<ul>
<li>如果节点有右子树，后继是右子树中值最小的节点。</li>
<li>如果节点没有右子树，沿着父节点回溯，找到第一个左子树包含当前节点的祖先节点。</li>
</ul>
<h3 id="代码实现-1"><strong>代码实现</strong></h3>
<pre><code class="language-cpp">TreeNode* findPredecessor(TreeNode* root, int value) {
    TreeNode* predecessor = nullptr;
    while (root) {
        if (value &gt; root-&gt;value) {
            predecessor = root;
            root = root-&gt;right;
        } else {
            root = root-&gt;left;
        }
    }
    return predecessor;
}

TreeNode* findSuccessor(TreeNode* root, int value) {
    TreeNode* successor = nullptr;
    while (root) {
        if (value &lt; root-&gt;value) {
            successor = root;
            root = root-&gt;left;
        } else {
            root = root-&gt;right;
        }
    }
    return successor;
}
</code></pre>
<hr>
<h2 id="3-以排名查询值">3. 以排名查询值</h2>
<h3 id="问题描述-1"><strong>问题描述</strong></h3>
<p>给定一个排名 $ k $，找到 BST 中第 $ k $ 小的节点值。</p>
<h3 id="额外信息子树大小"><strong>额外信息：子树大小</strong></h3>
<p>为了保存排名信息，我们在每个节点存储一个额外的属性 <code>size</code>，表示以当前节点为根的子树大小。</p>
<ul>
<li>根节点的子树大小为其左子树大小加右子树大小再加 1。</li>
<li>在插入节点时动态更新 <code>size</code> 属性。</li>
</ul>
<h3 id="查询思路"><strong>查询思路</strong></h3>
<ol>
<li>计算左子树大小 $ \text{size}_{\text{left}} $。</li>
<li>如果 $ k = \text{size}_{\text{left}} + 1 $，当前节点即为所求。</li>
<li>如果 $ k \leq \text{size}_{\text{left}} $，在左子树中递归查找。</li>
<li>如果 $ k &gt; \text{size}_{\text{left}} + 1 $，在右子树中递归查找，更新 $ k = k - \text{size}_{\text{left}} - 1 $。</li>
</ol>
<h3 id="代码实现-2"><strong>代码实现</strong></h3>
<pre><code class="language-cpp">TreeNode* findByRank(TreeNode* root, int k) {
    if (!root) return nullptr;
    int leftSize = root-&gt;left ? root-&gt;left-&gt;size : 0;
    if (k == leftSize + 1) return root;
    if (k &lt;= leftSize) return findByRank(root-&gt;left, k);
    return findByRank(root-&gt;right, k - leftSize - 1);
}
</code></pre>
<hr>
<h2 id="4-以值查询排名">4. 以值查询排名</h2>
<h3 id="问题描述-2"><strong>问题描述</strong></h3>
<p>给定一个值 $ x $，求其在 BST 中的排名（即有多少节点值小于 $ x $）。</p>
<h3 id="查询思路-1"><strong>查询思路</strong></h3>
<ol>
<li>初始化排名计数器 $ \text{rank} = 0 $。</li>
<li>遍历树路径：
<ul>
<li>如果 $ x $ 小于当前节点值，进入左子树。</li>
<li>如果 $ x $ 大于当前节点值，更新 $ \text{rank} += \text{size}_{\text{left}} + 1 $，进入右子树。</li>
<li>如果找到值等于 $ x $，返回当前排名。</li>
</ul>
</li>
<li>如果到达空节点，说明值不存在。</li>
</ol>
<h3 id="代码实现-3"><strong>代码实现</strong></h3>
<pre><code class="language-cpp">int findRankByValue(TreeNode* root, int value) {
    int rank = 0;
    while (root) {
        if (value &lt; root-&gt;value) {
            root = root-&gt;left;
        } else {
            rank += (root-&gt;left ? root-&gt;left-&gt;size : 0) + 1;
            if (value == root-&gt;value) return rank;
            root = root-&gt;right;
        }
    }
    return -1; // 值不存在
}
</code></pre>
<hr>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>方法描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找值</td>
<td>从根节点沿路径递归查找。</td>
<td>O(h)</td>
</tr>
<tr>
<td>查找前驱/后继</td>
<td>利用树的结构特性，寻找最接近的节点值。</td>
<td>O(h)</td>
</tr>
<tr>
<td>以排名查询值</td>
<td>利用子树大小属性，从根递归寻找第 ( k ) 小节点。</td>
<td>O(h)</td>
</tr>
<tr>
<td>以值查询排名</td>
<td>统计路径中左子树大小，计算排名。</td>
<td>O(h)</td>
</tr>
</tbody>
</table>
<p>通过本文的讲解和代码示例，希望读者能够掌握 BST 的查找操作，并能在实际开发中灵活运用这些知识。</p>
<p>然而，需要注意的是，查找操作的效率高度依赖于树的平衡性。当 BST 不平衡时，其性能可能退化到与链表类似，导致时间复杂度变为 $ O(n) $。因此，在进行插入和删除操作时，保持树的平衡是至关重要的。</p>
<p>为了解决这一问题，平衡二叉树（如 AVL 树、红黑树）通过特定的旋转操作，保证了树的高度始终保持在 $ O(\log n) $ 的级别。作为延伸思考，你可以研究平衡树的原理及其在保持效率上的作用。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07613523042708334" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 18:37">2024-12-23 18:28</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18624757" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18624757);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18624757', targetLink: 'https://www.cnblogs.com/ofnoname/p/18624757', title: '深入理解二叉查找树(BST)的重要查找操作' })">举报</a>
</div>
        