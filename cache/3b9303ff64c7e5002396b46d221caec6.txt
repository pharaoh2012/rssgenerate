
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/endswitch/p/19020468" title="发布于 2025-08-06 22:00">
    <span role="heading" aria-level="2">状压 dp</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p><a href="https://shanlunjiajian.github.io/2021/04/04/state-dp/" target="_blank" rel="noopener nofollow">博客。</a></p>
<p>通常是设一个二进制状态表示物品的取舍从而去转移。所以实际上其状态总数是没有变的，状压过程只是让状态排列的更加紧密了。</p>
<h1 id="子集枚举">子集枚举</h1>
<p>题目：</p>
<p>给定一个长度为 <span class="math inline">\(n\ (n\le15)\)</span> 的排列，问此排列中的 <span class="math inline">\(n\)</span> 个元素所组成的每一个集合的所有子集。</p>
<p>考虑暴力枚举一下。</p>
<pre><code class="language-cpp">for(int S = 0 ; S &lt;= (1 &lt;&lt; n) ; ++ S)
   for(int T = 0 ; T &lt;= S ; ++ T)
  	   ...
</code></pre>
<p>显然此时复杂度是 <span class="math inline">\(O(4 ^ n)\)</span> 的。</p>
<p>但是写成这样的形式能将复杂度降至 <span class="math inline">\(O(3 ^ n)\)</span>：</p>
<pre><code class="language-cpp">for(int S = 0 ; S &lt;= (1 &lt;&lt; n) ; ++S)
	for(int T = S ; T ; T = (T - 1) &amp; S)
		...
</code></pre>
<p>先考虑证明复杂度：</p>
<p><span class="math inline">\(n\)</span> 位选出 <span class="math inline">\(k\)</span> 位的方案数有 <span class="math inline">\((_{k}^{n})\)</span> 个，<span class="math inline">\(k\)</span> 位的子集个数有 <span class="math inline">\(2^k\)</span> 个</p>
<p>所有集合的子集的元素个数和为 <span class="math inline">\(\sum_{k=0}^{n}(_{k}^{n})\times 2^{k}\)</span>（不妨 <span class="math inline">\(k=0\)</span> 也计算在内）</p>
<p>将上式变形得：</p>
<p></p><div class="math display">\[\sum_{k=1}^{n}(_{k}^{n})\times 1^{n-k}\times 2^{k}
\]</div><p></p><p>二项式定理知为 <span class="math inline">\(O(3^n)\)</span>。</p>
<p>再证明一下正确性：</p>
<p>考虑 <span class="math inline">\(S\)</span> 的子集，在二进制上从大到小排成一排，那么大的通过减若干个 <span class="math inline">\(1\)</span> 就一定能到小的，</p>
<p>但是中间会产生大量的状态，这些状态中包含了一些 <span class="math inline">\(S\)</span> 中不包含的 <span class="math inline">\(1\)</span>，故和 <span class="math inline">\(S\)</span> 与一下，去冗即可。</p>
<p>从而每两个相邻的状态就都是 <span class="math inline">\(S\)</span> 的子集，由于降序从而任意两个状态不重复，即任意子集状态均可达。</p>
<h1 id="例题">例题</h1>
<h2 id="p3052-usaco12mar-cows-in-a-skyscraper-g"><a href="https://www.luogu.com.cn/problem/P3052" target="_blank" rel="noopener nofollow">P3052 [USACO12MAR] Cows in a Skyscraper G</a></h2>
<p>在此题中，<span class="math inline">\(n\)</span> 个物品的取舍是与答案相关的，而我们又发现 <span class="math inline">\(n\)</span> 的范围很小，所以可以考虑状压 dp。</p>
<p>设 <span class="math inline">\(dp_{i,j}\)</span> 将物品分成 <span class="math inline">\(i\)</span> 组，<span class="math inline">\(n\)</span> 个物品的取舍的不同的每组总体积小于等于 <span class="math inline">\(W\)</span> 的第 <span class="math inline">\(i\)</span> 组的总体积，其中 <span class="math inline">\(j\)</span> 为二进制数。</p>
<p>那么很显然我们就可以通过枚举 <span class="math inline">\(n \times 2^n\)</span> 个状态去进行转移了。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define rint register int 
//#define int long long
#define Debug(...) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; dp[i][j] &lt;&lt; '\n'
#define min(a, b) ((a) &lt; (b) ? (a) : (b))
using namespace std;

const int N = 20, M = (1 &lt;&lt; 19) + 5;
int n, W, w[N], dp[N][M];

signed main() {
	ios_base :: sync_with_stdio(NULL);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	cin &gt;&gt; n &gt;&gt; W;
	
	for(rint i = 0 ; i &lt; n ; ++ i)
		for(rint j = 0 ; j &lt; (1 &lt;&lt; n) ; ++ j)
			dp[i][j] = 1e9;
	
	for(int i = 0 ; i &lt; n ; ++ i)
		cin &gt;&gt; w[i], dp[1][1 &lt;&lt; i] = w[i];
	
	for(rint i = 1 ; i &lt;= n ; ++ i)
		for(rint j = 0 ; j &lt; (1 &lt;&lt; n) ; ++ j)
			if(dp[i][j] != 1e9)
				for(rint k = 0 ; k &lt; n ; ++ k) {
//					Debug();
					if(j &amp; (1 &lt;&lt; k)) continue;
					if(dp[i][j] + w[k] &lt;= W) dp[i][j | (1 &lt;&lt; k)] = min(dp[i][j | (1 &lt;&lt; k)], dp[i][j] + w[k]);
					else dp[i + 1][j | (1 &lt;&lt; k)] = min(dp[i][j | (1 &lt;&lt; k)], w[k]);
				}
	for(int i = 0 ; i &lt;= n ; ++ i)
		if(dp[i][(1 &lt;&lt; n) - 1] != 1e9) return cout &lt;&lt; i, 0;
	return 0;
}
</code></pre>
<h2 id="p5911-poi-2004-prz"><a href="https://www.luogu.com.cn/problem/P5911" target="_blank" rel="noopener nofollow">P5911 [POI 2004] PRZ</a></h2>
<ul>
<li><span class="math inline">\(dp_i = \min_{j \subseteq i} \{ dp_{i \bigoplus j} + t_j \}\)</span>。</li>
</ul>
<p>子集枚举即可。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

const int N = 17;
int n, m, t[N], w[N], T[1 &lt;&lt; N], W[1 &lt;&lt; N], dp[1 &lt;&lt; N];

signed main() {
	ios_base :: sync_with_stdio(NULL);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	cin &gt;&gt; m &gt;&gt; n;
	for(int i = 1 ; i &lt;= n ; ++ i)
		cin &gt;&gt; t[i] &gt;&gt; w[i];
	for(int i = 0 ; i &lt; (1 &lt;&lt; n) ; ++ i)
		for(int j = 1 ; j &lt;= n ; ++ j)
			if(i &amp; (1 &lt;&lt; (j - 1)))
				W[i] += w[j], T[i] = max(T[i], t[j]);
	
	memset(dp, 0x3f, sizeof dp);
	
	dp[0] = 0;
	
	for(int i = 0 ; i &lt; (1 &lt;&lt; n) ; ++ i)
		for(int j = i ; j ; j = (j - 1) &amp; i)
			if(W[j] &lt;= m) dp[i] = min(dp[i], dp[i ^ j] + T[j]);
	
	cout &lt;&lt; dp[(1 &lt;&lt; n) - 1];
	
	return 0;
}
</code></pre>
<h2 id="p3694-邦邦的大合唱站队"><a href="https://www.luogu.com.cn/problem/P3694" target="_blank" rel="noopener nofollow">P3694 邦邦的大合唱站队</a></h2>
<ol>
<li>状态：设 <span class="math inline">\(dp_i\)</span> 已经排好队的乐队是二进制下的 <span class="math inline">\(i\)</span> 时的最小代价。</li>
<li>答案：<span class="math inline">\(dp_{2 ^ m - 1}\)</span>。</li>
<li>转移：</li>
</ol>
<p>对于 <span class="math inline">\(dp_i\)</span>，枚举 <span class="math inline">\(i\)</span> 中第 <span class="math inline">\(j\)</span> 位的 <span class="math inline">\(1\)</span>：</p>
<p></p><div class="math display">\[dp_i = \min \{ dp_{i \bigoplus 2 ^ j} + buc_j + pre_{num + buc_j, j} - pre_{num, j} \}
\]</div><p></p><ol start="4">
<li>维护前缀和即可。</li>
</ol>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

const int M = 21;
const int N = 1e5 + 5;
int n, m, a[N], w[1 &lt;&lt; M], id[N], dp[1 &lt;&lt; M], buc[M], pre[N][M];

signed main() {
	ios_base :: sync_with_stdio(NULL);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	memset(dp, 0x3f, sizeof dp);
	dp[0] = 0;
	
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1 ; i &lt;= n ; ++ i) {
		cin &gt;&gt; a[i];
		
		++ buc[a[i]];
		
		for(int j = 1 ; j &lt;= m ; ++ j)
			pre[i][j] = pre[i - 1][j];
		pre[i][a[i]] = pre[i - 1][a[i]] + 1;
	}
	
	for(int i = 1 ; i &lt; (1 &lt;&lt; m) ; ++ i)
		for(int j = 0 ; j &lt; m ; ++ j)
			if(i &amp; (1 &lt;&lt; j)) w[i] += buc[j + 1];
	
	for(int i = 0 ; i &lt; (1 &lt;&lt; m) ; ++ i) {
		for(int j = 0 ; j &lt; m ; ++ j)
			if(i &amp; (1 &lt;&lt; j))
				dp[i] = min(dp[i], dp[i ^ (1 &lt;&lt; j)] + buc[j + 1] - pre[w[i]][j + 1] + pre[w[i ^ (1 &lt;&lt; j)]][j + 1]);
	}
	
	cout &lt;&lt; dp[(1 &lt;&lt; m) - 1];
	
	return 0;
}

/*
12 4
1
3
2
4
2
1
2
3
1
1
3
4
*/
</code></pre>
<h2 id="p2167">P2167</h2>
<ol>
<li>状态：设 <span class="math inline">\(dp_{i, S}\)</span> 表示已经匹配了前 <span class="math inline">\(i\)</span> 个位置，且参与匹配的字符串的状态是 <span class="math inline">\(S\)</span> 的方案数。</li>
<li>答案：</li>
</ol>
<p></p><div class="math display">\[\sum_{\operatorname{popcount} (S) = k} dp_{n, S}
\]</div><p></p><ol start="3">
<li>
<p>辅助状态：<span class="math inline">\(f_{i, c}\)</span> 表示 <span class="math inline">\(n\)</span> 个字符串在第 <span class="math inline">\(i\)</span> 位有字符 <span class="math inline">\(c\)</span> 的状态。</p>
</li>
<li>
<p>转移：</p>
</li>
</ol>
<p></p><div class="math display">\[dp_{i, S \cup f_{i, c}} = dp_{i, S \cup f_{i, c}} + dp_{i - 1, S}
\]</div><p></p><ol start="5">
<li>初始状态：<span class="math inline">\(dp_{0, 2 ^ n - 1} = 1\)</span>。</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-06 22:01">2025-08-06 22:00</span>&nbsp;
<a href="https://www.cnblogs.com/endswitch">endswitch</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19020468);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19020468', targetLink: 'https://www.cnblogs.com/endswitch/p/19020468', title: '状压 dp' })">举报</a>
</div>
        