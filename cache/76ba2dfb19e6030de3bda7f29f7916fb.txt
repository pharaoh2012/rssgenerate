
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/charlee44/p/18698533" title="发布于 2025-02-04 22:00">
    <span role="heading" aria-level="2">GDAL矢量数据集相关接口的资源控制问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        详细总结了GDAL矢量数据集相关接口的资源控制（例如资源没有释放或者释放多次）问题。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-引言">1. 引言</h1>
<p>笔者在<a href="https://charlee44.com/post.html?id=e67d597fede54bd9b2044d479aeb7874" target="_blank" rel="noopener nofollow">《使用GDAL读写矢量文件》</a>这篇文章中总结了通过GDAL读写矢量的具体实现。不过这篇文章中并没有谈到涉及到矢量数据集相关接口的资源控制问题。具体来说，GDAL/OGR诞生的年代连C++语言本身都不是很完善（c++11之前），因此提供的C++接口往往存在申请的资源需要释放的问题，因此在这里将其总结一下。</p>
<h1 id="2-详论">2. 详论</h1>
<h2 id="21-数据集类gdaldataset">2.1 数据集类GDALDataset</h2>
<p>矢量数据集GDALDataset对象需要通过GDALOpenEx来读取或者更新。在不需要这个对象之后，使用GDALClose进行关闭。例如：</p>
<pre><code class="language-cpp">GDALDataset *poDS = (GDALDataset*)GDALOpenEx(filePath, GDAL_OF_VECTOR, NULL, NULL, NULL);

//...

GDALClose(poDS);
poDS = nullptr;
</code></pre>
<p>另一方面，通过驱动类GDALDriver创建矢量数据集，不需要之后仍然使用GDALClose进行关闭。例如：</p>
<pre><code class="language-cpp">GDALDriver* driver = GetGDALDriverManager()-&gt;GetDriverByName("ESRI Shapefile");
if (!driver)
{
    printf("Get Driver ESRI Shapefile Error！\n");
    return false;
}
	
GDALDataset* dataset = driver-&gt;Create(filePath, 0, 0, 0, GDT_Unknown, NULL);

GDALClose(dataset);
dataset = nullptr;
</code></pre>
<p>理论上来说，GDALDataset对象在打开或者创建之后，使用<code>delete</code>进行释放也是可以的。但是一般而言，最好使用GDAL本身提供出来的释放接口。因为这个接口的内部实现可能并不只是delete那么简单，可能有其他的资源释放操作。不仅仅是GDAL，其他类库也是同理。</p>
<h2 id="22-图层类ogrlayer">2.2 图层类OGRLayer</h2>
<p>GDALDataset既可以是矢量数据集，也可以是栅格数据集。但是只有矢量数据集才能获取或创建图层类OGRLayer。但是无论是获取还是创建OGRLayer，再无需使用之后，都不用再进行主动释放了，OGRLayer对象会被GDALDataset对象托管，在GDALClose释放数据集对象之后，图层类OGRLayer就会随之释放。</p>
<pre><code class="language-cpp">OGRLayer* poLayer = poDS-&gt;GetLayer(0);
//获取后无需显式释放OGRLayer

OGRLayer* poLayer = dataset-&gt;CreateLayer("houseType", NULL, wkbPolygon, NULL);
//创建后无需显式释放OGRLayer
</code></pre>
<h2 id="23-要素类ogrfeature">2.3 要素类OGRFeature</h2>
<p>要素类OGRFeature一般从图层类OGRLayer对象中获取或者创建，不过无论是获取还是创建都需要进行显式释放。例如读取矢量数据集时遍历获取要素：</p>
<pre><code class="language-cpp">OGRFeature *poFeature;
while ((poFeature = poLayer-&gt;GetNextFeature()) != NULL)
{
    OGRGeometry *pGeo = poFeature-&gt;GetGeometryRef();
    //...
    OGRFeature::DestroyFeature(poFeature);
}
</code></pre>
<p>这里的<code>OGRFeature::DestroyFeature(poFeature);</code>就是GDAL提供的用于销毁要素对象的方法。另一方面，如果是写出数据集创建要素，比如笔者这里创建一个经纬度网格的矢量：</p>
<pre><code class="language-cpp">for (int yi = -90; yi &lt; 90; ++yi) {
    for (int xi = -180; xi &lt; 180; ++xi) {    
      OGRFeature poFeature(poLayer-&gt;GetLayerDefn());

      OGRLinearRing ogrRing;
      ogrRing.addPoint(xi, yi);
      ogrRing.addPoint(xi + 1, yi);
      ogrRing.addPoint(xi + 1, yi + 1);
      ogrRing.addPoint(xi, yi + 1);
      ogrRing.closeRings();

      OGRPolygon polygon;
      polygon.addRing(&amp;ogrRing);
      poFeature.SetGeometry(&amp;polygon);

      if (poLayer-&gt;CreateFeature(&amp;poFeature) != OGRERR_NONE) {
        printf("Failed to create feature in shapefile.\n");
        return false;
      }
    }
  }
</code></pre>
<p>OGRFeature使用的是值对象，在超出作用域之后会自动销毁。经过验证笔者这样写并没有问题，可以推断OGRLayer对于OGRFeature对象的管理应该是采用的深拷贝方式，并且会托管这个拷贝后的OGRFeature对象。</p>
<h2 id="24-几何类ogrgeometry">2.4 几何类OGRGeometry</h2>
<p>几何类OGRGeometry使用了C++类的继承和多态特性，本身其是一个基类，但是继承出了如OGRLinearRing、OGRPolygon等子类来表达点线面多种要素几何类型。因此GDAL提供了一个工厂类来创建和销毁，这是一种非常经典的设计模式：</p>
<pre><code class="language-cpp">OGRGeometry* poGeom = OGRGeometryFactory::createGeometry(wkbPoint);
// 使用完 poGeom 后释放它
OGRGeometryFactory::destroyGeometry(poGeom);
</code></pre>
<p>也就是OGRGeometryFactory::createGeometry和OGRGeometryFactory::destroyGeometry需要成对出现。不过笔者认为如果不是为了多态表达，直接使用值对象更加方便，如第2.3节中的示例所示。</p>
<p>另外，OGRGeometry对象是需要放置到OGRFeature对象中的，因此OGRFeature提供了两个接口：</p>
<ol>
<li><code>OGRErr SetGeometryDirectly(OGRGeometry*)</code>：浅拷贝OGRGeometry对象，OGRFeature对象直接托管OGRGeometry对象的所有权。</li>
<li><code>OGRErr SetGeometry(const OGRGeometry*)</code>：深拷贝OGRGeometry对象，OGRFeature对象托管OGRGeometry拷贝对象的所有权。</li>
</ol>
<p>另外，几何类之间的相互引用也是如此，如第2.3节中的示例所示，多边形增加环也有两个接口：</p>
<ol>
<li><code>addRingDirectly()</code> 浅拷贝OGRLinearRing对象，OGRPolygon对象直接托管OGRLinearRing对象的所有权。</li>
<li><code>addRing()</code>深拷贝OGRLinearRing对象，OGRPolygon对象托管OGRLinearRing拷贝对象的所有权。</li>
</ol>
<p>也就是一般而言，GDAL通常使用Directly后缀的函数接口来表达对原几何对象的托管。</p>
<h1 id="3-其他">3. 其他</h1>
<p>可以看到，GDAL的资源控制方面还是有点混乱的，有的要显式释放，有的又可以托管，有的干脆提供了两个接口。据说新的GDAL版本引入了很多新的C++特性，估计资源控制的逻辑要清晰一点。另外，我们也可以主动使用一些新的C++特性来避免资源控制需要主动释放的问题。例如使用智能指针，配合自定义删除器来销毁OGRFeature对象，如下例所示：</p>
<pre><code class="language-cpp">// 获取第一个图层
OGRLayer* poLayer = poDS-&gt;GetLayer(0);
if (poLayer == nullptr) {
    std::cerr &lt;&lt; "Failed to get the layer." &lt;&lt; std::endl;
    GDALClose(poDS);
    return -1;
}

// 自定义删除器用于销毁 OGRFeature
auto featureDeleter = [](OGRFeature* poFeature) {
    OGRFeature::DestroyFeature(poFeature);
};

// 遍历图层中的要素
poLayer-&gt;ResetReading();
std::unique_ptr&lt;OGRFeature, decltype(featureDeleter)&gt; poFeature(nullptr, featureDeleter);

while ((poFeature.reset(poLayer-&gt;GetNextFeature())), poFeature) {
    // 获取几何体
    OGRGeometry* poGeometry = poFeature-&gt;GetGeometryRef();
    if (poGeometry != nullptr) {
        // 输出几何体的WKT表示
        char* pszWKT = nullptr;
        poGeometry-&gt;exportToWkt(&amp;pszWKT);
        std::cout &lt;&lt; "Geometry: " &lt;&lt; pszWKT &lt;&lt; std::endl;
        CPLFree(pszWKT);  // 释放WKT字符串
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7651683174710648" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-04 22:00">2025-02-04 22:00</span>&nbsp;
<a href="https://www.cnblogs.com/charlee44">charlee44</a>&nbsp;
阅读(<span id="post_view_count">59</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18698533" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18698533);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18698533', targetLink: 'https://www.cnblogs.com/charlee44/p/18698533', title: 'GDAL矢量数据集相关接口的资源控制问题' })">举报</a>
</div>
        