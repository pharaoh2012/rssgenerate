
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yongshao/p/18863222" title="发布于 2025-05-06 21:59">
    <span role="heading" aria-level="2">青岛oj集训10</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        背包dp详解
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>最重要：01背包（完全背包）</p>
<p>设dp[i][j]表示前i个物品装进容量为j的背包</p>
<p>分两种情况，要么不要（第一项），要么要（第二项）f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])</p>
<p>注意，要判断j-w[i]是否为正</p>
<p>完全背包：</p>
<p>f[i][j]=max(f[i-1][j],f[i][j-w[i]]+v[i])</p>
<p>空间优化：</p>
<p>因为上一行用完就不会再用了</p>
<p>每次只会用到上一行的数据</p>
<p>所以只需要保留i-1和i这两行就行</p>
<p>所以考虑滚动数组</p>
<p>原来的数组：</p>
<p>f</p>
<p>|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; i=1</p>
<p>|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; i=2</p>
<p>|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; i=3</p>
<p>……</p>
<p>现在的数组：</p>
<p>f</p>
<p>|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; &nbsp;i=1,3,5,…&nbsp;</p>
<p>|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; &nbsp;i=2,4,6,…</p>
<p>所以只需要把所有f数组里的"i"变成i%2就行</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506191703889-392490283.png"></p>
<p>这种方法很多dp都可以用</p>
<p>那么还有一种方法可以只用一维，但是只有背包能用</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506200747991-1511722623.png"></p>
<p>观察到01背包（红）在更新f[i][j]的时候需要f[i-1]的值还未被更新，所以想要大的更新了小的没更新，要逆序枚举</p>
<p>而多重背包（蓝）在更新时需要f[i-1]已经更新，所以要正序枚举</p>
<p>P2979</p>
<p>有两种情况</p>
<p>如果没有大奶酪，那么就是最最最最普通的完全背包</p>
<p>因为我们要尽可能多的奶酪被压扁</p>
<p>先枚举上边的大奶酪是哪一种</p>
<p>再把背包大小变成m*5/4-大奶酪高度</p>
<p>再跑完全背包</p>
<p>but</p>
<p>放上大奶酪也不一定就好</p>
<p>所以你要判断一下，把这种情况和最普通的完全进行比较，选最大的</p>
<p>&nbsp;</p>
<p>1941</p>
<p>呵呵，绿题我能会就怪了</p>
<p>这是一道背包题，想不到吧</p>
<p>先假设这是一道简单的dp题</p>
<p>定义f[i][j]表示小鸟在(i,j)位置的最小步数</p>
<p>考虑没有柱子的情况</p>
<p>f[i][j]可以从f[i-1][j+y]或f[i-1][j-x]+1 , f[i-1][j-2x]+2……转移过来</p>
<p>如果你真这么做，那么O(nm^2)直接炸</p>
<p>会发现这些方程有点熟悉</p>
<p>f[i-1][j+y]不就是01背包吗？（-变成+了）</p>
<p>f[i-1][j-x]+1 , f[i-1][j-2x]+2……</p>
<p>不就是f[i][j-w[i]]+v[i]完全背包吗？</p>
<p>所以就是完全背包+01背包</p>
<p>柱子呢？</p>
<p>如果f[i][j]这个位置和柱子重合了</p>
<p>那么直接赋值为inf</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>多重背包</p>
<p>如果把每个都拆开成一个一个的小物品做01背包三层循环O(nms[i])太大了</p>
<p>那么二进制优化</p>
<p>会发现对于任何一个正整数n</p>
<p>找到2^（k-1）&lt; n &lt; 2^k</p>
<p>则n可以写成1+2+4+8+…+2^（k-2）+剩下的差</p>
<p>如40=1+2+4+8+16&nbsp; +&nbsp; 9</p>
<p>那么一个物品就会被拆成log下取整+1个数</p>
<p>这样就优化多了</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506200100704-2057503651.png"></p>
<p>&nbsp;</p>
<p>分组背包</p>
<p>首先是一堆01</p>
<p>给它分个组，每个组里只能选一个</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506195056445-1392439147.png"></p>
<p>P1782</p>
<p>呵呵，蓝题，呵呵呵呵哈哈哈</p>
<p>前半部分：标准的多重背包，用二进制优化不然就炸</p>
<p>后半部分：分组背包，枚举X</p>
<p>&nbsp;</p>
<p>可行性背包</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506201446762-1917192002.png"></p>
<p>第0列赋值1，O(nm)</p>
<p>但是会发现里面存的都是0,1</p>
<p>所以可以用bitset优化</p>
<p>bool qwq[5]={1,0,1,1,1};</p>
<p>那么bitset也就是10111</p>
<p>bitset&lt;5&gt; qwq=10111</p>
<p>它可以看做一个二进制数，左边是低位，右边是高位</p>
<p>即11101</p>
<p>对其右移1位：1101</p>
<p>那么bitset就变成1011（所以反了）</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506202453579-694383394.png"></p>
<p>这是直接用bool数组O(nm)</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506202620163-1575319345.png"></p>
<p>注意！！标蓝的&gt;&gt;变成&lt;&lt;</p>
<p>会比直接用bool快64（机器字长）倍</p>
<p>P5020</p>
<p>先将a排个序</p>
<p>那么a<sub>1</sub>一定在新的货币系统中</p>
<p>那么就可以把所有a<sub>1</sub>的倍数都删掉</p>
<p>再取最小的（假设是a2）</p>
<p>然后再把能用a<sub>1</sub>和a<sub>2</sub>都删掉直到没有</p>
<p>令f[i]表示i能否被新货币表示出来</p>
<p>若枚举到ai为0，则这个就是无法被表示的，就新加入货币系统，更新货币系统</p>
<p>P1537</p>
<p>判断：能否凑出一些弹珠为总价值的一半</p>
<p>多重可行性背包</p>
<p>但是直接跑6*2*10^4*2*10^4肯定过不了</p>
<p>你可以二进制优化O(6*log(n[i])*n)</p>
<p>当然，你可以再进行bitset优化，再快64倍O(6*log(n[i])*n/64)</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506204817722-1403681673.png"></p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506205226422-1564019679.png"></p>
<p>注意！！！状态转移方程是w<sub>i</sub>和v<sub>i</sub>打反了，不然也就没啥变化了</p>
<p>f[i][j]的定义很重要！！</p>
<p>&nbsp;</p>
<p class="lfe-h1">AT_abc364_e [ABC364E] Maximum Glutton</p>
<p>f[i][j][k]表示前i个物品，甜度为j，咸度为k，的最大菜肴</p>
<p>发现答案的值域很小，所以考虑把答案和甜/咸换一下</p>
<p><img src="https://img2024.cnblogs.com/blog/3564565/202505/3564565-20250506210141625-1273279395.png"></p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/yongshao/" target="_blank">永韶</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/yongshao/p/18863222" target="_blank">https://www.cnblogs.com/yongshao/p/18863222</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.012270359314814815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-06 22:00">2025-05-06 21:59</span>&nbsp;
<a href="https://www.cnblogs.com/yongshao">永韶</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18863222);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18863222', targetLink: 'https://www.cnblogs.com/yongshao/p/18863222', title: '青岛oj集训10' })">举报</a>
</div>
        