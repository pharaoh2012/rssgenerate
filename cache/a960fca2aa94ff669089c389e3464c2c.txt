
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19037825" title="发布于 2025-08-14 15:22">
    <span role="heading" aria-level="2">【渲染流水线】[几何阶段]-[几何着色]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250814152452812-450212077.png" alt="【渲染流水线】[几何阶段]-[几何着色]以UnityURP为例" class="desc_img">
        《Unity URP几何着色器技术解析》摘要： 几何着色器是URP中唯一支持自定义图元生成的着色器阶段（部分平台受限）。它位于顶点/曲面细分着色器之后，可接收完整图元数据并通过流输出机制动态修改几何结构，支持顶点增删改操作。典型应用包括模型细分（如将三角形拆分为子三角形）和轮廓线生成。实现时需声明#pragma geometry，使用TriangleStream等输出流类型，并通过maxvertexcount控制顶点输出量。需注意该技术对DX11/OpenGL ES3.2及以上API的依赖，移动端兼容性问题
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>允许自定义增加和创建新图元，<strong>唯一一个能自定义增加新图元的着色器</strong>。（部分平台支持，移动端很多不支持、apple的metal不支持）</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="作用">‌<strong>作用</strong>‌</h1>
<ul>
<li>基于图元生成新几何体（如将点扩展为粒子），位于曲面细分后、光栅化前 ‌。</li>
<li>这是一个‌<strong>可选</strong>‌阶段。它在曲面细分着色器之后运行（或在顶点着色器之后，如果没有曲面细分）。它接收一个完整的图元（点、线或三角形，以及其所有顶点），可以输出零个、一个或多个修改过的或全新的图元（点、线、三角带）。‌</li>
</ul>
<h1 id="配置">‌<strong>配置</strong>‌</h1>
<ul>
<li>Shader 中声明&nbsp;<code>#pragma geometry geom</code>。</li>
</ul>
<h1 id="核心工作原理"><strong>核心工作原理</strong></h1>
<ul>
<li>数据处理流程：
<ul>
<li>输入阶段：接收完整图元数据（点/线/三角形及其邻接变体）的顶点数组</li>
<li>处理阶段：通过流输出对象动态修改几何数据，支持顶点增删改操作</li>
<li>输出阶段：使用Append()方法将新顶点写入流对象，RestartStrip()重置三角带</li>
</ul>
</li>
<li>图元操作机制：
<ul>
<li>增删控制：通过maxvertexcount限制单次调用最大输出顶点数（建议值3-20个）</li>
<li>修改方式：在齐次裁剪空间重新计算顶点位置</li>
<li>分裂实现：例如将三角形拆分为多个子三角形时需重新计算法线</li>
</ul>
</li>
</ul>
<h1 id="urp实现步骤"><strong>URP实现步骤</strong></h1>
<ul>
<li>
<p>Shader基础结构：</p>
<pre><code class="language-glsl">hlsl
Shader "Custom/URPGeoShader" {
    Properties { _Extrude("Extrude", Float) = 0.1 }
    SubShader {
        Pass {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma geometry geom
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct v2g {
                float4 posOS : TEXCOORD0;
                float3 normalOS : NORMAL;
            };

            struct g2f {
                float4 posCS : SV_POSITION;
                float3 normalWS : TEXCOORD0;
            };

            [maxvertexcount(6)]
            void geom(triangle v2g input[3], inout TriangleStream&lt;g2f&gt; stream) {
                // 几何处理逻辑
            }
            ENDHLSL
        }
    }
}
</code></pre>
</li>
<li>
<p>关键参数说明：</p>
<ul>
<li>PrimitiveType：支持point/line/triangle及其邻接类型</li>
<li>Stream类型：PointStream/LineStream/TriangleStream三种输出流</li>
<li>性能优化：建议输出标量总数控制在20个以内</li>
</ul>
</li>
</ul>
<h1 id="典型应用案例">典型应用案例</h1>
<h2 id="模型细分">模型细分：</h2>
<pre><code class="language-glsl">hlsl
void geom(triangle v2g input[3], inout TriangleStream&lt;g2f&gt; stream) {
    float3 center = (input[0].posOS + input[1].posOS + input[2].posOS) / 3;
    for(int i=0; i&lt;3; i++) {
        g2f o;
        o.posCS = UnityObjectToClipPos(center);
        stream.Append(o);
        o.posCS = UnityObjectToClipPos(input[i].posOS);
        stream.Append(o);
        o.posCS = UnityObjectToClipPos(input[(i+1)%3].posOS);
        stream.Append(o);
        stream.RestartStrip();
    }
}
</code></pre>
<h2 id="轮廓线生成">轮廓线生成：</h2>
<pre><code class="language-glsl">hlsl
[maxvertexcount(6)]
void geom(triangle v2g input[3], inout TriangleStream&lt;g2f&gt; stream) {
    // 原始三角形
    for(int i=0; i&lt;3; i++) {
        g2f o;
        o.posCS = UnityObjectToClipPos(input[i].posOS);
        stream.Append(o);
    }
    stream.RestartStrip();

    // 外扩轮廓
    float extrude = _Extrude;
    for(int i=0; i&lt;3; i++) {
        g2f o;
        float4 offset = float4(input[i].normalOS * extrude, 0);
        o.posCS = UnityObjectToClipPos(input[i].posOS + offset);
        stream.Append(o);
    }
}
</code></pre>
<h1 id="注意事项">注意事项：</h1>
<ul>
<li>平台兼容性：需DX11/OpenGL ES3.2以上API支持</li>
<li>移动端限制：部分低端设备可能不支持几何着色器</li>
<li>性能影响：建议在PC平台使用，移动端需严格测试</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-08-14 15:25">2025-08-14 15:22</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">70</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19037825);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19037825', targetLink: 'https://www.cnblogs.com/SmalBox/p/19037825', title: '【渲染流水线】[几何阶段]-[几何着色]以UnityURP为例' })">举报</a>
</div>
        