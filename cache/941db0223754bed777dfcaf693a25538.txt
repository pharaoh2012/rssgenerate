
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/geeklab/p/18792777" title="发布于 2025-03-26 09:12">
    <span role="heading" aria-level="2">微服务架构的守护者：Redisson 分布式锁与看门狗机制实战指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-分布式锁简介">1. 分布式锁简介</h2>
<h3 id="11-什么是分布式锁">1.1 什么是分布式锁</h3>
<p>在单机应用中，可以使用 Java 内置的锁机制（如 synchronized、ReentrantLock 等）来实现线程间的同步。但在分布式环境下，由于应用部署在多台服务器上，传统的单机锁无法满足需求，这时就需要分布式锁。</p>
<p><strong>分布式锁</strong>是一种跨 JVM、跨服务器的锁机制，它能够在分布式系统中对共享资源进行互斥访问控制，确保在同一时间只有一个客户端可以获得锁并执行操作。</p>
<h3 id="12-分布式锁应用场景">1.2 分布式锁应用场景</h3>
<ol>
<li><strong>防止重复下单</strong>：在电商系统中，防止用户重复提交订单</li>
<li><strong>秒杀系统</strong>：控制商品库存的并发访问，避免超卖</li>
<li><strong>定时任务</strong>：确保集群环境下，定时任务只被一个节点执行</li>
<li><strong>数据一致性保护</strong>：保护跨系统的数据一致性操作</li>
</ol>
<h3 id="13-分布式锁的核心要求">1.3 分布式锁的核心要求</h3>
<ol>
<li><strong>互斥性</strong>：在任何时刻，只有一个客户端能持有锁</li>
<li><strong>可重入性</strong>：同一个客户端可以多次获取同一把锁</li>
<li><strong>防死锁</strong>：即使客户端崩溃，锁也应该在一定时间后自动释放</li>
<li><strong>高可用</strong>：分布式锁服务不应成为系统的单点故障</li>
<li><strong>性能</strong>：锁操作应该具备高性能、低延迟的特性</li>
</ol>
<h2 id="2-redisson-简介">2. Redisson 简介</h2>
<h3 id="21-什么是-redisson">2.1 什么是 Redisson</h3>
<p>Redisson 是一个在 Redis 基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它提供了分布式和可扩展的 Java 数据结构，包括分布式锁、分布式集合、分布式对象等功能。</p>
<h3 id="22-redisson-与-jedislettuce-对比">2.2 Redisson 与 Jedis、Lettuce 对比</h3>
<ul>
<li><strong>Jedis</strong>：Redis 的 Java 客户端，提供了 Redis 命令的基本封装，API 简单直观，但功能相对基础</li>
<li><strong>Lettuce</strong>：高级 Redis 客户端，基于 Netty，支持异步操作，性能优于 Jedis</li>
<li><strong>Redisson</strong>：不仅提供了 Redis 客户端功能，还提供了分布式锁、分布式集合等更高级的分布式特性，对分布式开发更加友好</li>
</ul>
<h3 id="23-redisson-的主要功能">2.3 Redisson 的主要功能</h3>
<ul>
<li><strong>分布式锁和同步器</strong>：分布式锁、读写锁、信号量、闭锁等</li>
<li><strong>分布式集合</strong>：Map、Set、List 等数据结构的分布式实现</li>
<li><strong>分布式服务</strong>：远程服务、实时对象服务等</li>
<li><strong>分布式执行服务</strong>：分布式执行服务、调度任务服务等</li>
</ul>
<h2 id="3-redisson-分布式锁的实现原理">3. Redisson 分布式锁的实现原理</h2>
<h3 id="31-基于-redis-的锁实现">3.1 基于 Redis 的锁实现</h3>
<p>Redisson 的分布式锁基于 Redis 的<code>EVAL</code>命令（执行 Lua 脚本）实现。它使用了一个 Redis 键值对来表示锁，键是锁的名称，值包含锁的持有者信息和过期时间。</p>
<p>基本流程：</p>
<ol>
<li><strong>获取锁</strong>：通过 Lua 脚本尝试在 Redis 中设置一个键值对，如果键不存在则获取成功</li>
<li><strong>锁的持有</strong>：为该键设置过期时间（避免死锁）</li>
<li><strong>锁的释放</strong>：通过执行 Lua 脚本删除对应的键</li>
<li><strong>锁的续期</strong>：通过看门狗机制延长锁的过期时间</li>
</ol>
<h3 id="32-锁的实现方案">3.2 锁的实现方案</h3>
<p>Redisson 提供了多种锁的实现方案：</p>
<ol>
<li><strong>普通可重入锁（RLock）</strong>：最基本的分布式锁实现，支持可重入</li>
<li><strong>公平锁（RFairLock）</strong>：按照请求顺序获取锁</li>
<li><strong>读写锁（RReadWriteLock）</strong>：读锁共享，写锁独占</li>
<li><strong>多重锁（RedissonMultiLock）</strong>：可以组合多个锁为一个锁</li>
<li><strong>红锁（RedissonRedLock）</strong>：基于 Redis 集群的高可靠性锁实现，可以抵御部分节点故障</li>
</ol>
<h3 id="33-锁的获取和释放流程">3.3 锁的获取和释放流程</h3>
<p><strong>锁的获取</strong>：</p>
<pre><code class="language-lua">-- KEYS[1]是锁的key，ARGV[1]是线程标识，ARGV[2]是过期时间
if (redis.call('exists', KEYS[1]) == 0) or (redis.call('hexists', KEYS[1], ARGV[1]) == 1) then
    redis.call('hincrby', KEYS[1], ARGV[1], 1);
    redis.call('pexpire', KEYS[1], ARGV[2]);
    return nil;
end;
return redis.call('pttl', KEYS[1]);
</code></pre>
<p><strong>锁的释放</strong>：</p>
<pre><code class="language-lua">-- KEYS[1]是锁的key，ARGV[1]是线程标识
if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then
    return nil;
end;
local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);
if (counter &gt; 0) then
    return 0;
else
    redis.call('del', KEYS[1]);
    return 1;
end;
</code></pre>
<h2 id="4-redisson-分布式锁的使用">4. Redisson 分布式锁的使用</h2>
<h3 id="41-maven-依赖配置">4.1 Maven 依赖配置</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson&lt;/artifactId&gt;
    &lt;version&gt;3.23.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="42-基本配置">4.2 基本配置</h3>
<pre><code class="language-java">@Configuration
public class RedissonConfig {

    @Value("${spring.data.redis.host}")
    private String host;

    @Value("${spring.data.redis.port}")
    private int port;

    @Value("${spring.data.redis.password}")
    private String password;

    @Value("${spring.data.redis.database}")
    private int database;

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://" + host + ":" + port)
              .setDatabase(database);
        if (password != null &amp;&amp; !password.isEmpty()) {
            config.useSingleServer().setPassword(password);
        }
        return Redisson.create(config);
    }
}
</code></pre>
<h3 id="43-基本锁的使用">4.3 基本锁的使用</h3>
<pre><code class="language-java">@Service
public class LockService {

    @Resource
    private RedissonClient redissonClient;

    public void doSomething() {
        RLock lock = redissonClient.getLock("myLock");

        try {
            // 尝试获取锁，最多等待100秒，锁有效期为30秒
            boolean isLocked = lock.tryLock(100, 30, TimeUnit.SECONDS);

            if (isLocked) {
                // 业务处理
                System.out.println("执行业务逻辑");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // 释放锁
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
</code></pre>
<h3 id="44-不同类型锁的使用">4.4 不同类型锁的使用</h3>
<ol>
<li><strong>可重入锁 (RLock)</strong></li>
</ol>
<pre><code class="language-java">RLock lock = redissonClient.getLock("myLock");
lock.lock();
try {
    try {
        lock.lock();
    } finally {
        lock.unlock();
    }
} finally {
    lock.unlock();
}
</code></pre>
<ol start="2">
<li><strong>公平锁 (RFairLock)</strong></li>
</ol>
<pre><code class="language-java">RLock fairLock = redissonClient.getFairLock("myFairLock");
fairLock.lock();
try {
    // 业务处理
} finally {
    fairLock.unlock();
}
</code></pre>
<ol start="3">
<li><strong>读写锁 (RReadWriteLock)</strong></li>
</ol>
<pre><code class="language-java">RReadWriteLock rwLock = redissonClient.getReadWriteLock("myRWLock");

// 读锁（共享）
RLock readLock = rwLock.readLock();
readLock.lock();
try {
    // 读取操作
} finally {
    readLock.unlock();
}

// 写锁（排他）
RLock writeLock = rwLock.writeLock();
writeLock.lock();
try {
    // 写入操作
} finally {
    writeLock.unlock();
}
</code></pre>
<ol start="4">
<li><strong>多重锁 (RedissonMultiLock)</strong></li>
</ol>
<pre><code class="language-java">RLock lock1 = redissonClient.getLock("lock1");
RLock lock2 = redissonClient.getLock("lock2");
RLock lock3 = redissonClient.getLock("lock3");

// 组合多个锁
RedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);
multiLock.lock();
try {
    // 业务处理
} finally {
    multiLock.unlock();
}
</code></pre>
<h2 id="5-看门狗机制详解">5. 看门狗机制详解</h2>
<h3 id="51-什么是看门狗机制">5.1 什么是看门狗机制</h3>
<p><strong>看门狗（Watchdog）机制</strong>是 Redisson 为分布式锁提供的一种自动续期功能。它能够在客户端持有锁期间，自动延长锁的有效期，防止因为执行时间过长导致锁过期被其他客户端获取，从而破坏互斥性。</p>
<h3 id="52-看门狗的工作原理">5.2 看门狗的工作原理</h3>
<ol>
<li>当客户端调用<code>lock()</code>方法获取锁时（不设置过期时间），Redisson 会默认设置一个 30 秒的锁有效期</li>
<li>同时，它会启动一个定时任务，默认每 10 秒检查一次（锁有效期的 1/3 时间）</li>
<li>如果客户端仍然持有锁，定时任务会自动刷新锁的有效期为 30 秒</li>
<li>这个过程会一直持续，直到客户端主动释放锁，或者客户端崩溃（此时看门狗停止工作，锁会在 30 秒后自动释放）</li>
</ol>
<h3 id="53-看门狗的关键源码分析">5.3 看门狗的关键源码分析</h3>
<p>Redisson 中看门狗的核心实现在<code>RedissonLock.java</code>类中：</p>
<pre><code class="language-java">// 锁的自动续期逻辑
private void scheduleExpirationRenewal(long threadId) {
    ExpirationEntry entry = new ExpirationEntry();
    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
    if (oldEntry != null) {
        oldEntry.addThreadId(threadId);
    } else {
        entry.addThreadId(threadId);
        renewExpiration();
    }
}

// 续期定时任务
private void renewExpiration() {
    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
        @Override
        public void run(Timeout timeout) throws Exception {
            // 续期逻辑
            // ...
            // 每internalLockLeaseTime/3时间后，重新检查并续期
            commandExecutor.getConnectionManager().newTimeout(this,
                internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
        }
    }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
}
</code></pre>
<h3 id="54-看门狗机制的启用和关闭">5.4 看门狗机制的启用和关闭</h3>
<p><strong>启用看门狗机制</strong>（默认）：</p>
<pre><code class="language-java">// 不指定过期时间，默认启用看门狗机制
lock.lock();
</code></pre>
<p><strong>禁用看门狗机制</strong>：</p>
<pre><code class="language-java">// 明确指定过期时间，看门狗机制将被禁用
lock.lock(10, 30, TimeUnit.SECONDS);
</code></pre>
<h3 id="55-看门狗配置参数">5.5 看门狗配置参数</h3>
<p>可以通过配置修改看门狗的默认行为：</p>
<pre><code class="language-java">// 设置锁的默认过期时间（看门狗续期间隔为该值的1/3）
Config config = new Config();
config.setLockWatchdogTimeout(30000); // 30秒
RedissonClient redisson = Redisson.create(config);
</code></pre>
<h2 id="6-分布式锁的最佳实践">6. 分布式锁的最佳实践</h2>
<h3 id="61-合理使用看门狗机制">6.1 合理使用看门狗机制</h3>
<ul>
<li>对于执行时间不确定的任务，推荐使用看门狗机制</li>
<li>对于执行时间确定且较短的任务，可以明确设置过期时间，关闭看门狗</li>
</ul>
<h3 id="62-锁的粒度选择">6.2 锁的粒度选择</h3>
<ul>
<li>尽量降低锁的粒度，例如对特定对象加锁，而不是整个方法</li>
<li>使用不同的锁名称来区分不同的业务操作</li>
</ul>
<h3 id="63-锁的释放保证">6.3 锁的释放保证</h3>
<ul>
<li>始终在 finally 块中释放锁</li>
<li>释放前检查当前线程是否持有锁（isHeldByCurrentThread）</li>
</ul>
<pre><code class="language-java">try {
    // 业务逻辑
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
</code></pre>
<h3 id="64-处理锁的获取失败">6.4 处理锁的获取失败</h3>
<ul>
<li>设置合理的等待时间</li>
<li>实现重试机制</li>
<li>提供降级策略</li>
</ul>
<pre><code class="language-java">int retryCount = 3;
while (retryCount &gt; 0) {
    boolean locked = lock.tryLock(5, TimeUnit.SECONDS);
    if (locked) {
        try {
            // 业务逻辑
            return result;
        } finally {
            lock.unlock();
        }
    }
    retryCount--;
    Thread.sleep(1000);
}
// 降级处理
return fallbackMethod();
</code></pre>
<h2 id="7-redisson-分布式锁与其他实现的对比">7. Redisson 分布式锁与其他实现的对比</h2>
<h3 id="71-与-redis-原生命令实现对比">7.1 与 Redis 原生命令实现对比</h3>
<p><strong>Redis 原生命令（SETNX + EXPIRE）：</strong></p>
<ul>
<li>优点：实现简单，不依赖额外库</li>
<li>缺点：原子性保证困难，无法解决锁过期问题，不支持可重入</li>
</ul>
<p><strong>Redisson：</strong></p>
<ul>
<li>优点：实现了可重入、自动续期、公平锁等高级特性</li>
<li>缺点：额外的依赖，有一定的学习成本</li>
</ul>
<h3 id="72-与-zookeeper-实现对比">7.2 与 Zookeeper 实现对比</h3>
<p><strong>Zookeeper：</strong></p>
<ul>
<li>优点：强一致性保证，临时节点机制自动释放，有序性支持</li>
<li>缺点：性能较低，适合高可靠低频操作</li>
</ul>
<p><strong>Redisson：</strong></p>
<ul>
<li>优点：性能高，功能丰富，适合高频操作</li>
<li>缺点：在某些极端情况下一致性不如 Zookeeper</li>
</ul>
<h3 id="73-各种实现的适用场景">7.3 各种实现的适用场景</h3>
<ul>
<li><strong>Redisson</strong>：适合高性能场景，对一致性要求不是极高但要求低延迟</li>
<li><strong>Zookeeper</strong>：适合高可靠性场景，对性能要求不高但要求强一致性</li>
<li><strong>数据库锁</strong>：适合与数据操作紧密结合的场景</li>
<li><strong>etcd</strong>：适合对可靠性和一致性都有较高要求的中等性能场景</li>
</ul>
<h2 id="8-常见问题及解决方案">8. 常见问题及解决方案</h2>
<h3 id="81-锁的误删除问题">8.1 锁的误删除问题</h3>
<p><strong>问题</strong>：一个客户端释放了其他客户端持有的锁</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>Redisson 通过锁值内存储线程标识，保证只有持有锁的线程才能释放</li>
<li>释放时通过<code>isHeldByCurrentThread()</code>方法检查</li>
</ul>
<h3 id="82-锁的过期问题">8.2 锁的过期问题</h3>
<p><strong>问题</strong>：业务执行时间超过锁的有效期</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用看门狗机制自动续期</li>
<li>合理评估业务执行时间，设置足够的锁有效期</li>
</ul>
<h3 id="83-缓存崩溃和恢复">8.3 缓存崩溃和恢复</h3>
<p><strong>问题</strong>：Redis 服务器故障或重启</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用 Redis 集群提高可用性</li>
<li>在关键业务使用 RedissonRedLock（红锁）</li>
<li>实现业务补偿机制</li>
</ul>
<h3 id="84-性能优化">8.4 性能优化</h3>
<ul>
<li>减小锁粒度</li>
<li>适当设置锁等待超时时间</li>
<li>避免长时间持有锁</li>
<li>使用读写锁分离读写操作</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4799552311296296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-26 09:12">2025-03-26 09:12</span>&nbsp;
<a href="https://www.cnblogs.com/geeklab">科韵小栈</a>&nbsp;
阅读(<span id="post_view_count">179</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18792777" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18792777);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18792777', targetLink: 'https://www.cnblogs.com/geeklab/p/18792777', title: '微服务架构的守护者：Redisson 分布式锁与看门狗机制实战指南' })">举报</a>
</div>
        