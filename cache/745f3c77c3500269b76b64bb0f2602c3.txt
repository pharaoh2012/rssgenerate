
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cunzai/p/18645924" title="发布于 2025-01-01 14:40">
    <span role="heading" aria-level="2">WebApi使用 （.Net Framework版）</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        如果不得不使用.Net Framework开发web api，可以参考本文。主要内容包括创建、属性路由、配置Swagger、IHttpActionResult接口、.bat文件一键启动、打包发布。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-创建">1 创建</h2>
<p>使用.Net做web后端，推荐使用.Net Core，微软在此基础上做了很多适配，包括内置Swagger，可以直接启动等等。而.Net Framework版，需要手动配置很多内容。</p>
<p>如果需要调用的项目是基于.Net Framework，那么web项目也应基于.Net Framework开发。或者其他原因不得不使用.Net Framework开发web项目，可以参考本文。</p>
<p>打开VS，在搜索栏输入“ASP.NET Web”，选择.Net Framework版，注意，这里要创建的是空白API项目，在前后端分离的项目中只作为后端接口，而不是MVC（模型-视图-控制器）</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605529-41791778.png" alt="" loading="lazy"></p>
<p>填写项目名，选择位置，选择需要的框架</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605507-356310287.png" alt="" loading="lazy"></p>
<p>创建一个空白项目，勾选“Web API”，取消勾选“HTTPS配置”</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605534-1959652960.png" alt="" loading="lazy"></p>
<p>添加完成后，会创建以下目录结构：</p>
<ul>
<li>“App_Data”目录用于方式一些资源文件；</li>
<li>“App_Start”目录下用于放置一些配置资源，默认已有一个配置类“WebApiConfig”，内容如下。config.MapHttpAttributeRoutes();表示启用了属性路由，允许在控制器和操作方法上直接使用特性（如 <code>[Route]</code>）来定义路由规则。下半部分表示定义默认路由规则。</li>
</ul>
<pre><code class="language-csharp">public static class WebApiConfig
{
    public static void Register(HttpConfiguration config)
    {
        config.MapHttpAttributeRoutes();

        config.Routes.MapHttpRoute(
            name: "DefaultApi",
            routeTemplate: "api/{controller}/{id}",
            defaults: new { id = RouteParameter.Optional }
        );
    }
}
</code></pre>
<ul>
<li>“Controllers”目录下放置对外接口；</li>
<li>“Models”目录下放置后端接口的内部逻辑，比如要接入数据库的操作等等。这些目录作为一个规范，如果违反这个规范随意放置，也可以正常运行，只不过看着比较杂乱。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605507-424929852.png" alt="" loading="lazy"></p>
<h2 id="2-测试">2 测试</h2>
<p>项目创建完成后，并没有提供任何对外接口，添加一个测试接口。选中“Controllers”目录=&gt;右键=&gt;添加=&gt;Web API控制器类</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605528-1811231730.png" alt="" loading="lazy"></p>
<p>填写名称，建议名称为“xxxController”（xxx为需要写的名称），此名称会被上文提到的“默认路由规则”匹配，将“xxx”作为api的一部分。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605487-1058496968.png" alt="" loading="lazy"></p>
<p>类创建完成后，会自动生成示例程序，包含Get, Post, Put, Delete请求</p>
<pre><code class="language-csharp">public class TestController : ApiController
{
    // GET api/&lt;controller&gt;
    public IEnumerable&lt;string&gt; Get()
    {
        return new string[] { "value1", "value2" };
    }

    // GET api/&lt;controller&gt;/5
    public string Get(int id)
    {
        return "value";
    }

    // POST api/&lt;controller&gt;
    public void Post([FromBody] string value)
    {
    }

    // PUT api/&lt;controller&gt;/5
    public void Put(int id, [FromBody] string value)
    {
    }

    // DELETE api/&lt;controller&gt;/5
    public void Delete(int id)
    {
    }
}
</code></pre>
<p>启动项目，基于.Net Framework的web项目需要借助于服务启动，vs调试默认使用IIS服务。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605529-130751444.png" alt="" loading="lazy"></p>
<p>启动完成后，没有配置默认的访问地址就会显示如下界面。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605636-371970174.png" alt="" loading="lazy"></p>
<p>测试Api访问。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605555-590794385.png" alt="" loading="lazy"></p>
<h2 id="3-配置属性路由规则">3 配置属性路由规则</h2>
<p>上文提到，配置类“WebApiConfig”中配置了默认路由规则，启用了属性路由。属性路由就是使用特性标记路由，使用属性路由代替了默认路由。</p>
<p>示例如下：</p>
<pre><code class="language-csharp">[RoutePrefix("api/TestABC")]
public class TestController : ApiController
{
    [HttpGet]
    [Route("GetValue")]
    // GET api/&lt;controller&gt;
    public IEnumerable&lt;string&gt; Get()
    {
        return new string[] { "value1", "value2" };
    }
}
</code></pre>
<p>启动，测试访问，可以看到，路由规则已经由默认路由规则变为了属性路由规则。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605873-1634385720.png" alt="" loading="lazy"></p>
<h2 id="4-配置swagger">4 配置Swagger</h2>
<h3 id="41-基本配置">4.1 基本配置</h3>
<p>在NuGet中下载安装“Swashbuckle”</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605536-2124252220.png" alt="" loading="lazy"></p>
<p>安装完成后，在“App_Start”目录下会自动生成“SwaggerConfig”配置类。可以修改需要显示的内容，下图这个语句包含两条信息，“版本”和“Title”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605553-1555805114.png" alt="" loading="lazy"></p>
<p>在项目属性中，勾选生成“XML文档文件”，本质上是Swagger将此xml转换为Swagger格式的内容。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605551-548043458.png" alt="" loading="lazy"></p>
<p>安装完之后，再访问本地URL，可能会报一个错，这里不要慌，一般是安装的“Swashbuckle”包依赖的内容与现有安装的包不相符，在NuGet包管理器中全部更到最新即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605552-628723853.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605563-2072362759.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605582-241516344.png" alt="" loading="lazy"></p>
<p>启动后在原有url后加入/swagger即可访问文档。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605619-2100530716.png" alt="" loading="lazy"></p>
<p>展开后，可以点击“Try it out”按钮进行测试。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605562-1999551149.png" alt="" loading="lazy"></p>
<p>请求与相应如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605530-199336801.png" alt="" loading="lazy"></p>
<p>测试Post，字符串一定要带""</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605591-1428697060.png" alt="" loading="lazy"></p>
<p>程序中获取到浏览器发送的内容。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605575-1139364814.png" alt="" loading="lazy"></p>
<h3 id="42-为程序添加注释">4.2 为程序添加注释</h3>
<p>上文提到，勾选了生成“XML文档文件”，此xml是将写的注释记录下来。</p>
<p>比如为Get请求添加注释。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 测试请求
/// &lt;/summary&gt;
/// &lt;returns&gt;返回示例数据&lt;/returns&gt;
public IEnumerable&lt;string&gt; Get()
{
    return new string[] { "value1", "value2" };
}
</code></pre>
<p>然后在SwaggerConfig配置类中添加一条配置。</p>
<pre><code class="language-csharp">c.IncludeXmlComments(Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "bin\\TestWebApi.xml"));
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605588-892005576.png" alt="" loading="lazy"></p>
<p>再次访问，可以看到，有了注释的内容。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605554-1463603069.png" alt="" loading="lazy"></p>
<h3 id="43-汉化处理">4.3 汉化处理</h3>
<p>安装“Swagger.Net.UI”</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605621-933124077.png" alt="" loading="lazy"></p>
<p>安装完成后，在“App_Start”目录下新增了一个SwaggerNet类</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605703-816921893.png" alt="" loading="lazy"></p>
<p>打开SwaggerNet类，注释掉这两行（这里我没做深究，参考的几篇文章都说注释掉这两行，可能后续运行有报错）</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605621-1897544571.png" alt="" loading="lazy"></p>
<p><font style="color: rgba(77, 77, 77, 1)">创建一个“SwaggerControllerDescProvider”类，用于对swagger文档中的内容进行汉化处理。</font></p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// swagger显示控制器的描述
/// &lt;/summary&gt;
public class SwaggerControllerDescProvider : ISwaggerProvider
{
    private readonly ISwaggerProvider _swaggerProvider;
    private static ConcurrentDictionary&lt;string, SwaggerDocument&gt; _cache = new ConcurrentDictionary&lt;string, SwaggerDocument&gt;();
    private readonly string _xml;
    /// &lt;summary&gt;
    /// 
    /// &lt;/summary&gt;
    /// &lt;param name="swaggerProvider"&gt;&lt;/param&gt;
    /// &lt;param name="xml"&gt;xml文档路径&lt;/param&gt;
    public SwaggerControllerDescProvider(ISwaggerProvider swaggerProvider, string xml)
    {
        _swaggerProvider = swaggerProvider;
        _xml = xml;
    }

    public SwaggerDocument GetSwagger(string rootUrl, string apiVersion)
    {
        var cacheKey = string.Format("{0}_{1}", rootUrl, apiVersion);
        SwaggerDocument srcDoc = null;
        //只读取一次
        if (!_cache.TryGetValue(cacheKey, out srcDoc))
        {
            srcDoc = _swaggerProvider.GetSwagger(rootUrl, apiVersion);

            srcDoc.vendorExtensions = new Dictionary&lt;string, object&gt; { { "ControllerDesc", GetControllerDesc() } };
            _cache.TryAdd(cacheKey, srcDoc);
        }
        return srcDoc;
    }

    /// &lt;summary&gt;
    /// 从API文档中读取控制器描述
    /// &lt;/summary&gt;
    /// &lt;returns&gt;所有控制器描述&lt;/returns&gt;
    public ConcurrentDictionary&lt;string, string&gt; GetControllerDesc()
    {
        string xmlpath = _xml;
        ConcurrentDictionary&lt;string, string&gt; controllerDescDict = new ConcurrentDictionary&lt;string, string&gt;();
        if (File.Exists(xmlpath))
        {
            XmlDocument xmldoc = new XmlDocument();
            xmldoc.Load(xmlpath);
            string type = string.Empty, path = string.Empty, controllerName = string.Empty;

            string[] arrPath;
            int length = -1, cCount = "Controller".Length;
            XmlNode summaryNode = null;
            foreach (XmlNode node in xmldoc.SelectNodes("//member"))
            {
                type = node.Attributes["name"].Value;
                if (type.StartsWith("T:"))
                {
                    //控制器
                    arrPath = type.Split('.');
                    length = arrPath.Length;
                    controllerName = arrPath[length - 1];
                    if (controllerName.EndsWith("Controller"))
                    {
                        //获取控制器注释
                        summaryNode = node.SelectSingleNode("summary");
                        string key = controllerName.Remove(controllerName.Length - cCount, cCount);
                        if (summaryNode != null &amp;&amp; !string.IsNullOrEmpty(summaryNode.InnerText) &amp;&amp; !controllerDescDict.ContainsKey(key))
                        {
                            controllerDescDict.TryAdd(key, summaryNode.InnerText.Trim());
                        }
                    }
                }
            }
        }
        return controllerDescDict;
    }
}
</code></pre>
<p><font style="color: rgba(77, 77, 77, 1)">在SwaggerUI文件夹中，创建一个swagger_lang.js的js,用于对swagger进行汉化处理（注：这个文件必须添加，否则汉化将失败）</font></p>
<p><font style="color: rgba(77, 77, 77, 1)">swagger_lang.js 文件中的js内容如下。在最后几行有“公司名称”和对应的Url，可以自行更改，这里我写了百度的链接作为测试。</font></p>
<pre><code class="language-javascript">/// &lt;summary&gt;
/// 中文转换
/// &lt;/summary&gt;
var SwaggerTranslator = (function () {
    //定时执行检测是否转换成中文,最多执行500次  即500*50/1000=25s
    var iexcute = 0,
        //中文语言包
        _words = {
            "Warning: Deprecated": "警告：已过时",
            "Implementation Notes": "实现备注",
            "Response Class": "响应类",
            "Status": "状态",
            "Parameters": "参数",
            "Parameter": "参数",
            "Value": "值",
            "Description": "描述",
            "Parameter Type": "参数类型",
            "Data Type": "数据类型",
            "Response Messages": "响应消息",
            "HTTP Status Code": "HTTP状态码",
            "Reason": "原因",
            "Response Model": "响应模型",
            "Request URL": "请求URL",
            "Response Body": "响应体",
            "Response Code": "响应码",
            "Response Headers": "响应头",
            "Hide Response": "隐藏响应",
            "Headers": "头",
            "Try it out!": "试一下！",
            "Show/Hide": "显示/隐藏",
            "List Operations": "显示操作",
            "Expand Operations": "展开操作",
            "Raw": "原始",
            "can't parse JSON.  Raw result": "无法解析JSON. 原始结果",
            "Model Schema": "模型架构",
            "Model": "模型",
            "apply": "应用",
            "Username": "用户名",
            "Password": "密码",
            "Terms of service": "服务条款",
            "Created by": "创建者",
            "See more at": "查看更多：",
            "Contact the developer": "联系开发者",
            "api version": "api版本",
            "Response Content Type": "响应Content Type",
            "fetching resource": "正在获取资源",
            "fetching resource list": "正在获取资源列表",
            "Explore": "浏览",
            "Show Swagger Petstore Example Apis": "显示 Swagger Petstore 示例 Apis",
            "Can't read from server.  It may not have the appropriate access-control-origin settings.": "无法从服务器读取。可能没有正确设置access-control-origin。",
            "Please specify the protocol for": "请指定协议：",
            "Can't read swagger JSON from": "无法读取swagger JSON于",
            "Finished Loading Resource Information. Rendering Swagger UI": "已加载资源信息。正在渲染Swagger UI",
            "Unable to read api": "无法读取api",
            "from path": "从路径",
            "Click to set as parameter value": "点击设置参数",
            "server returned": "服务器返回"
        },
 
        //定时执行转换
        _translator2Cn = function () {
            if ($("#resources_container .resource").length &gt; 0) {
                _tryTranslate();
            }
 
            if ($("#explore").text() == "Explore" &amp;&amp; iexcute &lt; 500) {
                iexcute++;
                setTimeout(_translator2Cn, 50);
            }
        },
 
        //设置控制器注释
        _setControllerSummary = function () {
            $.ajax({
                type: "get",
                async: true,
                url: $("#input_baseUrl").val(),
                dataType: "json",
                success: function (data) {
                    var summaryDict = data.ControllerDesc;
                    var id, controllerName, strSummary;
                    $("#resources_container .resource").each(function (i, item) {
                        id = $(item).attr("id");
                        if (id) {
                            controllerName = id.substring(9);
                            strSummary = summaryDict[controllerName];
                            if (strSummary) {
                                var option = $(item).children(".heading").children(".options");
                                if ($(option).children(".controller-summary").length &gt; 0) {
                                    $(option).children(".controller-summary").remove();
                                }
                                $(option).prepend('&lt;li class="controller-summary" title="' + strSummary + '"&gt;' + strSummary + '&lt;/li&gt;');
                            }
                        }
                    });
                }
            });
        },
 
        //尝试将英文转换成中文
        _tryTranslate = function () {
            $('[data-sw-translate]').each(function () {
                $(this).html(_getLangDesc($(this).html()));
                $(this).val(_getLangDesc($(this).val()));
                $(this).attr('title', _getLangDesc($(this).attr('title')));
            });
        },
        _getLangDesc = function (word) {
            return _words[$.trim(word)] !== undefined ? _words[$.trim(word)] : word;
        };
 
    return {
        Translator: function () {
            $("#logo").html("公司名称").attr("href", "https://www.baidu.com");
            $('body').append('&lt;style type="text/css"&gt;.controller-summary{color:#10a54a !important;word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:250px;text-align:right;cursor:default;} &lt;/style&gt;');
            //设置控制器描述
            _setControllerSummary();
            _translator2Cn();
        },
        translate: function () {
            this.Translator();
        }
    }
})();
//执行转换
SwaggerTranslator.Translator();
</code></pre>
<p><font style="color: rgba(77, 77, 77, 1)">新增的swagger_lang.js文件需要修改文件属性，将文件生成操作修改为“嵌入的资源”。</font></p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605590-51939297.png" alt="" loading="lazy"></p>
<p><font style="color: rgba(77, 77, 77, 1)">将创建的swagger_lang.js在SwaggerConfig文件中进行引用。注意文件的路径。</font></p>
<pre><code class="language-javascript">c.InjectJavaScript(thisAssembly, "TestWebApi.SwaggerUI.swagger_lang.js");  //引用中文包
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605636-906872209.png" alt="" loading="lazy"></p>
<p>汉化结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605582-1850668057.png" alt="" loading="lazy"></p>
<h2 id="5-包装返回结果">5 包装返回结果</h2>
<h3 id="51-ihttpactionresult接口">5.1 IHttpActionResult接口</h3>
<p>默认生成的测试程序，请求到的数据都直接返回的数据内容。</p>
<pre><code class="language-javascript">public IEnumerable&lt;string&gt; Get()
{
    return new string[] { "value1", "value2" };
}

// GET api/&lt;controller&gt;/5
public string Get(int id)
{
    return "value";
}
</code></pre>
<p>如果需要自主决定状态码或者返回错误结果内容时携带异常信息等，可以使用C#提供的IHttpActionResult接口。</p>
<pre><code class="language-javascript">public IHttpActionResult Get()
{
    return Ok(new string[] { "value1", "value2" });
}
</code></pre>
<p>其中Ok()是ASP.NET Web API 提供了一些常用的IHttpActionResult实现，代表200状态码，只使用Ok()，与不使用IHttpActionResult接口并无明显的区别。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605721-504456640.png" alt="" loading="lazy"></p>
<h3 id="52-其它方法">5.2 其它方法</h3>
<p>除了常见的 <code>Ok</code> 方法外，ASP.NET Web API 还提供了多个 <code>IHttpActionResult</code> 的实现类或方法，用于构建特定的 HTTP 响应。以下是常用的 <code>IHttpActionResult</code> 实现及其对应的用途：</p>
<h4 id="521-ok">5.2.1 Ok</h4>
<ul>
<li><strong>返回 HTTP 状态码：200 OK</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于返回一个成功的响应，并可以附带一个对象作为响应体。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    var data = new { Id = 1, Name = "Example" };
    return Ok(data);
}
</code></pre>
<hr>
<h4 id="522-badrequest">5.2.2 BadRequest</h4>
<ul>
<li><strong>返回 HTTP 状态码：400 Bad Request</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示客户端发送的请求无效，例如参数验证失败或格式错误。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Post(string value)
{
    if (string.IsNullOrEmpty(value))
    {
        return BadRequest("Value cannot be null or empty.");
    }
    return Ok();
}
</code></pre>
<hr>
<h4 id="523-unauthorized">5.2.3 Unauthorized</h4>
<ul>
<li><strong>返回 HTTP 状态码：401 Unauthorized</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于指示需要身份验证或身份验证失败。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    if (!User.Identity.IsAuthenticated)
    {
        return Unauthorized();
    }
    return Ok();
}
</code></pre>
<hr>
<h4 id="524-notfound">5.2.4 NotFound</h4>
<ul>
<li><strong>返回 HTTP 状态码：404 Not Found</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示所请求的资源不存在。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get(int id)
{
    var item = _repository.GetItem(id);
    if (item == null)
    {
        return NotFound();
    }
    return Ok(item);
}
</code></pre>
<hr>
<h4 id="525-conflict">5.2.5 Conflict</h4>
<ul>
<li><strong>返回 HTTP 状态码：409 Conflict</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示请求无法完成，因为发生了冲突（例如重复数据或违反约束）。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Post(Item item)
{
    if (_repository.Contains(item.Id))
    {
        return Conflict();
    }
    _repository.Add(item);
    return Ok();
}
</code></pre>
<hr>
<h4 id="526-created--createdatroute">5.2.6 Created / CreatedAtRoute</h4>
<ul>
<li><strong>返回 HTTP 状态码：201 Created</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示资源已成功创建，并可以附带新资源的 URI。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Post(Item item)
{
    _repository.Add(item);
    return Created(new Uri(Request.RequestUri + "/" + item.Id), item);
}

// 或者使用 CreatedAtRoute 指定路由名称
public IHttpActionResult Post(Item item)
{
    _repository.Add(item);
    return CreatedAtRoute("DefaultApi", new { id = item.Id }, item);
}
</code></pre>
<hr>
<h4 id="527-nocontent">5.2.7 NoContent</h4>
<ul>
<li><strong>返回 HTTP 状态码：204 No Content</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示请求已成功处理，但不需要返回响应体内容（例如更新操作）。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Put(int id, Item item)
{
    if (!_repository.Update(id, item))
    {
        return NotFound();
    }
    return StatusCode(HttpStatusCode.NoContent); // 或者直接 NoContent()
}
</code></pre>
<hr>
<h4 id="528-redirect--redirecttoroute">5.2.8 Redirect / RedirectToRoute</h4>
<ul>
<li><strong>返回 HTTP 状态码：302 Found 或其他重定向状态码</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示需要重定向到另一个 URI。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    return Redirect("https://www.example.com");
}

// 使用特定路由
public IHttpActionResult Get()
{
    return RedirectToRoute("DefaultApi", new { id = 1 });
}
</code></pre>
<hr>
<h4 id="529-internalservererror">5.2.9 InternalServerError</h4>
<ul>
<li><strong>返回 HTTP 状态码：500 Internal Server Error</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示服务器内部发生错误。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    try
    {
        // 处理逻辑
    }
    catch (Exception ex)
    {
        return InternalServerError(ex);
    }
}
</code></pre>
<hr>
<h4 id="5210-responsemessage">5.2.10 ResponseMessage</h4>
<ul>
<li><strong>返回自定义的 HTTP 响应消息</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于完全自定义 HTTP 响应，灵活构建响应消息。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    var response = Request.CreateResponse(HttpStatusCode.OK, "Custom Message");
    return ResponseMessage(response);
}
</code></pre>
<hr>
<h4 id="5211-statuscode">5.2.11 StatusCode</h4>
<ul>
<li><strong>返回任意 HTTP 状态码</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于返回特定的 HTTP 状态码，而不需要返回额外的内容。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Delete(int id)
{
    _repository.Remove(id);
    return StatusCode(HttpStatusCode.NoContent); // 返回 204 No Content
}
</code></pre>
<hr>
<h4 id="5212-json">5.2.12 Json</h4>
<ul>
<li><strong>返回 JSON 格式的响应</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于直接返回 JSON 数据，而不依赖模型绑定。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    var data = new { Id = 1, Name = "Example" };
    return Json(data);
}
</code></pre>
<hr>
<h4 id="5213-exceptionresult">5.2.13 ExceptionResult</h4>
<ul>
<li><strong>返回异常结果</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于返回一个表示异常的响应。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    try
    {
        throw new InvalidOperationException("An unexpected error occurred.");
    }
    catch (Exception ex)
    {
        return InternalServerError(ex); // 适用于返回异常信息的场景
    }
}
</code></pre>
<hr>
<h4 id="5214-notimplemented">5.2.14 NotImplemented</h4>
<ul>
<li><strong>返回 HTTP 状态码：501 Not Implemented</strong></li>
<li><strong>用法</strong>：
<ul>
<li>用于表示服务端还未实现某个功能。</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public IHttpActionResult Get()
{
    return StatusCode(HttpStatusCode.NotImplemented);
}
</code></pre>
<hr>
<h4 id="5215-总结">5.2.15 总结</h4>
<p>以下是常见的 <code>IHttpActionResult</code> 方法及其对应的 HTTP 状态码：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>HTTP 状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ok</code></td>
<td>200 OK</td>
<td>请求成功并返回数据。</td>
</tr>
<tr>
<td><code>BadRequest</code></td>
<td>400 Bad Request</td>
<td>客户端请求无效。</td>
</tr>
<tr>
<td><code>Unauthorized</code></td>
<td>401 Unauthorized</td>
<td>表示未通过身份验证。</td>
</tr>
<tr>
<td><code>NotFound</code></td>
<td>404 Not Found</td>
<td>资源不存在。</td>
</tr>
<tr>
<td><code>Conflict</code></td>
<td>409 Conflict</td>
<td>请求冲突（如违反约束）。</td>
</tr>
<tr>
<td><code>Created</code></td>
<td>201 Created</td>
<td>成功创建资源，并返回资源 URI。</td>
</tr>
<tr>
<td><code>NoContent</code></td>
<td>204 No Content</td>
<td>请求成功，但没有返回内容。</td>
</tr>
<tr>
<td><code>Redirect</code></td>
<td>302 Found</td>
<td>重定向到另一个 URI。</td>
</tr>
<tr>
<td><code>InternalServerError</code></td>
<td>500 Internal Server Error</td>
<td>服务器内部错误。</td>
</tr>
<tr>
<td><code>ResponseMessage</code></td>
<td>自定义状态码</td>
<td>返回自定义的 HTTP 响应消息。</td>
</tr>
<tr>
<td><code>StatusCode</code></td>
<td>任意状态码</td>
<td>返回指定的 HTTP 状态码。</td>
</tr>
<tr>
<td><code>Json</code></td>
<td>任意状态码</td>
<td>返回 JSON 响应内容。</td>
</tr>
</tbody>
</table>
<p>通过这些方法，开发者可以灵活地编写符合 HTTP 规范的响应，满足各种 RESTful API 的需求。</p>
<h2 id="6-标明返回类型">6 标明返回类型</h2>
<p>书接第五部分，返回类型如果使用IHttpActionResult接口，Swagger文档中无法解析出响应的具体内容，如下图所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605604-1627807739.png" alt="" loading="lazy"></p>
<p>如果希望显示响应内容，可以使用特性标明。</p>
<pre><code class="language-javascript">[SwaggerResponse(200, "Success", typeof(string[]))]
public IHttpActionResult Get()
{
    return Ok(new string[] { "value1", "value2" });
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605581-726131506.png" alt="" loading="lazy"></p>
<p>有关这方面的扩展内容很多，感兴趣可以自行查阅。</p>
<h2 id="7-一键启动">7 一键启动</h2>
<p>在项目的Web.config文件同目录下创建一个.bat文件</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605664-1526983458.png" alt="" loading="lazy"></p>
<p>.bat文件的内容如下，相关信息修改为适合本项目的内容。这里有一点，正常来说应该先启动IIS Express，再执行“浏览器访问URL”，但是启动IIS Express这个行为会阻塞到当前语句，不再往下执行，所以这里将“浏览器访问URL”语句提前，浏览器会等待IIS Express启动后访问成功。</p>
<pre><code class="language-bash">@echo off
:: 设置IIS Express的路径（通常位于Program Files中，如果安装在其他位置，请调整路径）
set IIS_EXPRESS_PATH="C:\Program Files\IIS Express\iisexpress.exe"

:: 项目的物理路径，这条语句不需要修改，意为访问bat文件所在目录
cd /d "%~dp0"

:: Web项目的端口
set PORT=63027

:: 项目的启动URL（如果需要）
set URL=http://localhost:%PORT%/swagger/ui/index#/

:: 打开默认浏览器访问URL（可选）
start %URL%

:: 启动IIS Express
%IIS_EXPRESS_PATH% /path:"%cd%" /port:%PORT%

pause
</code></pre>
<p>双击该bat文件即可将项目内容自动配置到IIS服务中。</p>
<h2 id="8-打包">8 打包</h2>
<p>选择“发布”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605605-1436073989.png" alt="" loading="lazy"></p>
<p>发布位置选择“文件夹”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605598-2112563428.png" alt="" loading="lazy"></p>
<p>点击“发布”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605600-2094177701.png" alt="" loading="lazy"></p>
<p>生成的内容如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605605-509383577.png" alt="" loading="lazy"></p>
<p>将“配置Swagger”中生成的xml文件拷到bin目录下，这是Swagger文档的基础，发布操作不会自动复制该文件，需要手动复制。然后将“一键启动”生成的.bat文件复制到Web.config文件同目录下，双击即可打开。</p>
<p><img src="https://img2024.cnblogs.com/blog/2880894/202501/2880894-20250102223605620-561473627.png" alt="" loading="lazy"></p>
<h2 id="9-参考">9 参考</h2>
<p><a href="https://blog.csdn.net/suxuelian/article/details/133626818" target="_blank" rel="noopener nofollow">.net framework中webapi使用swagger进行接口文档展示</a></p>
<p><a href="https://www.cnblogs.com/huguodong/p/12748300.html" target="_blank">ASP.NET WebApi项目框架搭建（一）：创建项目</a></p>
<p><a href="https://www.cnblogs.com/refuge/p/8371415.html" target="_blank">WebApi 接口返回值类型详解 ( 转 )</a></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.43348083442939817" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-02 22:40">2025-01-01 14:40</span>&nbsp;
<a href="https://www.cnblogs.com/cunzai">纸照片</a>&nbsp;
阅读(<span id="post_view_count">97</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18645924" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18645924);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18645924', targetLink: 'https://www.cnblogs.com/cunzai/p/18645924', title: 'WebApi使用 （.Net Framework版）' })">举报</a>
</div>
	