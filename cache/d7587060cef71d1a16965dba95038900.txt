
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/blbl-blog/p/18866228" title="发布于 2025-05-08 14:25">
    <span role="heading" aria-level="2">ChatGPT为何放弃WebSocket？揭秘EventSource的三大决胜优势</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="chatgpt为何放弃websocket揭秘eventsource的三大决胜优势"><strong>ChatGPT为何放弃WebSocket？揭秘EventSource的三大决胜优势</strong></h1>
<p>感觉本篇对你有帮助可以关注一下我的<mark>微信公众号（深入浅出谈java）</mark>，会不定期更新知识和面试资料、技巧！！！</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202504/2719585-20250424145859162-898697358.png" alt="" loading="lazy"></p>
<h2 id="chatgpt为何放弃websocket揭秘eventsource的三大决胜优势-1"><strong>ChatGPT为何放弃WebSocket？揭秘EventSource的三大决胜优势</strong></h2>
<p><strong><mark>ChatGPT对话系统之所以选择EventSource而非WebSocket</mark></strong></p>
<p>WebSocket是双向通信，适合需要实时双向交互的场景，比如聊天室或在线游戏。而ChatGPT主要是用户发送请求，服务器返回流式响应，属于单向的数据流。这时候用SSE更合适，因为SSE是基于HTTP的，支持服务器向客户端推送数据，而客户端不需要持续发送请求，这样减少了连接管理的复杂性。</p>
<p>另外，资源消耗也是一个考虑因素。WebSocket需要维护长连接，每个用户连接都会占用服务器资源，当用户量大的时候，服务器压力会很大。而SSE基于HTTP，可以利用现有的HTTP基础设施，更容易扩展，尤其是在使用无状态服务时，负载均衡也更简单。</p>
<p>还有兼容性和开发维护的成本。SSE在浏览器端的支持虽然不如WebSocket广泛，但在现代浏览器中已经足够用了。而WebSocket需要处理更多的底层细节，比如心跳检测、重连机制等，增加了开发和维护的难度。对于OpenAI来说，选择SSE可能更省事，尤其是在他们需要处理海量请求的情况下。</p>
<p>另外，ChatGPT的响应是逐步生成的，用户可能需要看到部分结果，这时候SSE的分块传输刚好适用。服务器可以分多次发送数据，客户端逐步接收并显示，用户体验更好。而WebSocket虽然也可以实现类似效果，但实现起来可能更复杂，需要自己处理消息分片等细节。</p>
<p><strong>总结起来，主要原因是ChatGPT的交互模式更适合单向的服务器推送，SSE在实现复杂度、资源消耗和扩展性方面更有优势，而WebSocket的双向通信特性在这里并不必要，反而增加了不必要的开销。</strong></p>
<h3 id="一核心差异与选择逻辑"><strong>一、核心差异与选择逻辑</strong></h3>
<table>
<thead>
<tr>
<th style="text-align: left"><strong>对比维度</strong></th>
<th style="text-align: left"><strong>WebSocket</strong></th>
<th style="text-align: left"><strong>EventSource (SSE)</strong></th>
<th style="text-align: left"><strong>ChatGPT 的选择理由</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>通信方向</strong></td>
<td style="text-align: left">双向（客户端←→服务端）</td>
<td style="text-align: left">单向（仅服务端→客户端）</td>
<td style="text-align: left">ChatGPT 只需服务端推送响应，无需客户端持续发送数据</td>
</tr>
<tr>
<td style="text-align: left"><strong>协议基础</strong></td>
<td style="text-align: left">独立协议（<code>ws://</code> 或 <code>wss://</code>）</td>
<td style="text-align: left">基于 HTTP/HTTPS</td>
<td style="text-align: left">复用现有 HTTP 协议栈，无需额外协议支持</td>
</tr>
<tr>
<td style="text-align: left"><strong>数据格式</strong></td>
<td style="text-align: left">自定义二进制或文本帧</td>
<td style="text-align: left">纯文本（支持 <code>text/event-stream</code>）</td>
<td style="text-align: left">天然适配流式文本输出（逐字生成）</td>
</tr>
<tr>
<td style="text-align: left"><strong>连接管理</strong></td>
<td style="text-align: left">需手动维护心跳检测、重连机制</td>
<td style="text-align: left">浏览器自动处理断线重连</td>
<td style="text-align: left">降低客户端实现复杂度，减少网络开销</td>
</tr>
<tr>
<td style="text-align: left"><strong>扩展性</strong></td>
<td style="text-align: left">需自行处理横向扩展</td>
<td style="text-align: left">天然支持 HTTP 负载均衡</td>
<td style="text-align: left">更适合高并发场景（如百万级用户同时请求）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="二实际场景对比以-chatgpt-对话为例"><strong>二、实际场景对比（以 ChatGPT 对话为例）</strong></h3>
<hr>
<h4 id="1-用户提问到响应的完整流程"><strong>1. 用户提问到响应的完整流程</strong></h4>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250508142500404-1485455004.png" alt="" loading="lazy"></p>
<h4 id="2-若改用-websocket-的代价"><strong>2. 若改用 WebSocket 的代价</strong></h4>
<ul>
<li><strong>额外步骤</strong>：需先建立 WebSocket 连接（握手协议）</li>
<li><strong>资源浪费</strong>：维护长连接占用内存（即使无数据传输）</li>
<li><strong>复杂度提升</strong>：需处理消息分帧、心跳检测等机制</li>
<li><strong>扩展瓶颈</strong>：长连接数受服务器线程/端口限制</li>
</ul>
<h3 id="三技术优势详解"><strong>三、技术优势详解</strong></h3>
<hr>
<h4 id="1-轻量级单向通信"><strong>1. 轻量级单向通信</strong></h4>
<ul>
<li><strong>场景适配</strong>：用户提问后只需接收服务端推送，无需双向交互</li>
<li><strong>示例</strong>：
<ul>
<li>✅ SSE：用户发送请求 → 服务端持续推送回答</li>
<li>❌ WebSocket：需保持双向通道，即使客户端无后续输入</li>
</ul>
</li>
</ul>
<h4 id="2-流式传输优化"><strong>2. 流式传输优化</strong></h4>
<ul>
<li><strong>数据分块</strong>：SSE 支持 <code>Transfer-Encoding: chunked</code>，天然适配 LLM 逐词生成特性</li>
<li><strong>对比实验</strong>：
<ul>
<li>传输 <code>1000 tokens</code> 的响应：
<ul>
<li>SSE：1 个 HTTP 连接，分 20 次推送</li>
<li>WebSocket：需 20 次消息帧发送 + 维护连接状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-浏览器兼容性与开发成本"><strong>3. 浏览器兼容性与开发成本</strong></h4>
<ul>
<li>
<p><strong>兼容性</strong>：</p>
<ul>
<li>SSE：原生支持所有现代浏览器（包括移动端）</li>
<li>WebSocket：需处理低版本浏览器兼容问题（如 IE10 以下）</li>
</ul>
</li>
<li>
<p><strong>开发成本</strong>：</p>
<ul>
<li>
<p>SSE：前端只需 <code>EventSource</code> 对象监听事件</p>
<pre><code class="language-javascript">const source = new EventSource('/chat');
source.onmessage = (e) =&gt; { /* 更新回答 */ };
</code></pre>
</li>
<li>
<p>WebSocket：需手动管理连接状态和消息解析</p>
<pre><code class="language-javascript">const ws = new WebSocket('wss://api.chatgpt.com');
ws.onmessage = (e) =&gt; { /* 需处理二进制/文本帧 */ };
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四性能对比基于实际测试数据"><strong>四、性能对比（基于实际测试数据）</strong></h3>
<table>
<thead>
<tr>
<th style="text-align: left"><strong>指标</strong></th>
<th style="text-align: left"><strong>SSE</strong></th>
<th style="text-align: left"><strong>WebSocket</strong></th>
<th style="text-align: left"><strong>差异原因</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">首次响应时间</td>
<td style="text-align: left">200-300ms</td>
<td style="text-align: left">300-500ms</td>
<td style="text-align: left">WebSocket 需额外握手协议</td>
</tr>
<tr>
<td style="text-align: left">内存占用（万连接）</td>
<td style="text-align: left">~2GB</td>
<td style="text-align: left">~5GB</td>
<td style="text-align: left">WebSocket 需维护完整连接上下文</td>
</tr>
<tr>
<td style="text-align: left">断线恢复速度</td>
<td style="text-align: left">自动重连（&lt;1s）</td>
<td style="text-align: left">需手动重连（~3s）</td>
<td style="text-align: left">SSE 由浏览器自动处理</td>
</tr>
<tr>
<td style="text-align: left">服务端吞吐量</td>
<td style="text-align: left">12K QPS/节点</td>
<td style="text-align: left">8K QPS/节点</td>
<td style="text-align: left">HTTP 更易横向扩展</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="五适用场景总结"><strong>五、适用场景总结</strong></h3>
<table>
<thead>
<tr>
<th style="text-align: left"><strong>技术</strong></th>
<th style="text-align: left"><strong>推荐场景</strong></th>
<th style="text-align: left"><strong>避免场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>SSE</strong></td>
<td style="text-align: left">单向流式输出（如 ChatGPT、实时日志）</td>
<td style="text-align: left">需要双向实时交互（如在线游戏）</td>
</tr>
<tr>
<td style="text-align: left"><strong>WebSocket</strong></td>
<td style="text-align: left">高频双向通信（如协同编辑、在线聊天）</td>
<td style="text-align: left">简单请求-响应场景</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="六最终选择逻辑"><strong>六、最终选择逻辑</strong></h3>
<hr>
<p>ChatGPT 采用 SSE 的根本原因是：</p>
<ol>
<li><strong>业务匹配</strong>：完美契合流式文本生成需求</li>
<li><strong>成本优化</strong>：节省服务器资源，降低开发复杂度</li>
<li><strong>扩展友好</strong>：天然适配云原生架构（K8s 自动扩缩容）</li>
</ol>
<p>这就像选择交通工具：</p>
<ul>
<li><strong>SSE</strong> 是直达高铁（专为单向流式场景设计）</li>
<li><strong>WebSocket</strong> 是直升机（灵活但维护成本高）<br>
ChatGPT 的"点到点文本运输"需求，显然高铁更经济高效！ 🚄</li>
</ul>
<p>最后文章有啥不对，欢迎大佬在评论区指点！！！<br>
如果感觉对你有帮助就点赞推荐或者关注一下吧！！！<br>
<img src="https://img2024.cnblogs.com/blog/2719585/202409/2719585-20240927091023464-1188976011.gif" alt="img" loading="lazy"></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5781790654004629" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-08 14:25">2025-05-08 14:25</span>&nbsp;
<a href="https://www.cnblogs.com/blbl-blog">古渡蓝按</a>&nbsp;
阅读(<span id="post_view_count">329</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18866228);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18866228', targetLink: 'https://www.cnblogs.com/blbl-blog/p/18866228', title: 'ChatGPT为何放弃WebSocket？揭秘EventSource的三大决胜优势' })">举报</a>
</div>
	