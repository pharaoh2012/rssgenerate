
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/violet1359/p/18804744" title="发布于 2025-04-05 14:16">
    <span role="heading" aria-level="2">D 图上的遍历算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="图上的遍历算法">图上的遍历算法</h1>
<h2 id="广度优先搜索-bfs">广度优先搜索 BFS</h2>
<h3 id="概念">概念</h3>
<p><strong>广度优先搜索（Breadth-First Search）</strong>是一种图遍历算法，用于在图或树中按层次逐层访问节点。它从源节点（起始节点）开始，首先访问源节点的所有直接邻接节点，然后依次访问距离源节点较远的节点，直到遍历完整个图或到达目标节点</p>
<p>BFS通过队列逐层扩展的方式，确保按最短路径访问节点，并且保证在无权图中找到从源节点到目标节点的最短路径，适用于寻找最短路径、连通分量和解决图的层次遍历等问题</p>
<p>时间复杂度：<span class="math inline">\(O(V+E)\)</span>，其中<span class="math inline">\(V\)</span>是图中节点数（顶点数），<span class="math inline">\(E\)</span>是图中的边数</p>
<h3 id="实现方法">实现方法</h3>
<p>BFS 采用 <strong>队列（Queue）</strong> 来保证节点的逐层访问。每当一个节点被访问时，其所有未访问的邻接节点都会被加入队列，确保接下来的节点按照它们的距离起始节点的层数顺序依次访问</p>
<pre><code class="language-cpp">//伪代码
BFS(graph, start):
    将起始节点 start 加入队列 queue 并标记为已访问
    while queue 非空:
        当前节点 node = 从队列中弹出
        访问节点 node
        遍历 node 的所有邻接节点 neighbor:
            if neighbor 没有被访问过:
                标记 neighbor 为已访问
                将 neighbor 加入队列
</code></pre>
<pre><code class="language-cpp">//C++代码（邻接表，维护了距离数组和前驱节点数组）
//Q 队列，用于存储待访问的节点
//vis 访问标记数组，记录每个节点是否被访问过
//d 距离数组，记录每个节点从起始节点的最短距离
//p 前驱节点数组，记录每个节点的前驱节点，帮助恢复路径
//head[u] 节点u的邻接表的头节点
//e[i].to 边i的目标节点
//e[i].nxt 边i的下一个边的指针，用于遍历邻接表
void bfs(int u) {
    while (!Q.empty()) Q.pop();//清空队列
    Q.push(u);
    vis[u] = 1;
    d[u] = 0;
    p[u] = -1;
    while (!Q.empty()) {
        u = Q.front();
        Q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            if (!vis[e[i].to]) {
                Q.push(e[i].to);
                vis[e[i].to] = 1;
                d[e[i].to] = d[u] + 1;
                p[e[i].to] = u;
            }
        }
    }
}
void restore(int x) {
    vector&lt;int&gt; res;
    for (int v = x; v != -1; v = p[v]) res.push_back(v);
    reverse(res.begin(), res.end());
    for (int i = 0; i &lt; res.size(); ++i) printf("%d ", res[i]);
}
</code></pre>
<h3 id="层序遍历">层序遍历</h3>
<h4 id="例题-leetcode-102-二叉树的层序遍历">例题 Leetcode 102 二叉树的层序遍历</h4>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> （即逐层地，从左到右访问所有节点）</p>
<p><strong>样例输入：</strong></p>
<pre><code>root = [3,9,20,null,null,15,7]
</code></pre>
<div class="mermaid">graph TB
A((3))
B((9))
C((20))
D((15))
E((7))
A---B
A---C
C---D
C---E
</div><p><strong>样例输出：</strong></p>
<pre><code>[[3],[9,20],[15,7]]
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    vector &lt;vector &lt;int&gt;&gt; ans;
    if (!root) return ans;
    queue &lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();//队列中元素数量
        ans.push_back(vector &lt;int&gt; ());
        for (int i = 1; i &lt;= size; ++i) {
            auto node = q.front(); q.pop();
            ans.back().push_back(node-&gt;val);
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
    }
    return ans;
}
</code></pre>
<h3 id="最短路径">最短路径</h3>
<p><strong>创建一个数组或字典来记录每个节点的最短路径（即距离）。</strong>初始时，将起点的距离设置为<code>0</code>，其他节点设置为<code> -1</code>表示未被访问。广度优先搜索时，对于每个邻居节点，如果它尚未被访问过，则更新其最短路径为当前节点的最短路径<code>+1</code>，并将该邻居节点加入队列</p>
<h4 id="例题-luogu-p1443-马的遍历">例题 Luogu P1443 马的遍历</h4>
<p>有一个 <span class="math inline">\(n \times m\)</span> 的棋盘，在某个点 <span class="math inline">\((x, y)\)</span> 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步</p>
<p><strong>输入：</strong>输入只有一行四个整数，分别为 <span class="math inline">\(n, m, x, y\)</span></p>
<p><strong>输出：</strong>一个 <span class="math inline">\(n \times m\)</span> 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 <span class="math inline">\(-1\)</span>）</p>
<p><strong>样例输入：</strong></p>
<pre><code>3 3 1 1
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>0    3    2    
3    -1   1    
2    1    4
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">int vis[N][N],f[N][N];
int dx[8]={-1,-2,-2,-1,1,2,2,1};
int dy[8]={2,1,-1,-2,2,1,-1,-2};//8个方向

f[x][y]=0;//记录步数
q.push(make_pair(x,y));
vis[x][y]=true;

while(!q.empty())
{
    int xx=q.front().first,yy=q.front().second;
    q.pop();
    for(int i=0;i&lt;8;i++)
    {
        int u=xx+dx[i],v=yy+dy[i];
        if(u&lt;1||u&gt;n||v&lt;1||v&gt;m||vis[u][v])continue;
        vis[u][v]=true;q.push(make_pair(u,v));
        f[u][v]=f[xx][yy]+1;
    }
}
</code></pre>
<p><strong>Luogu B3625 迷宫寻路</strong></p>
<p>迷宫可以视为一个 <span class="math inline">\(n\times m\)</span> 矩阵，每个位置要么是空地，要么是墙。机器猫初始时位于 <span class="math inline">\((1, 1)\)</span> 的位置，只能从一个空地走到其上、下、左、右的空地，问能否走到 <span class="math inline">\((n, m)\)</span> 位置</p>
<p><strong>输入：</strong>第一行，两个正整数 <span class="math inline">\(n,m\)</span>。  接下来 <span class="math inline">\(n\)</span> 行，输入这个迷宫。每行输入一个长为 <span class="math inline">\(m\)</span> 的字符串，<code>#</code> 表示墙，<code>.</code> 表示空地</p>
<p><strong>输出：</strong>仅一行，一个字符串。如果机器猫能走到 <span class="math inline">\((n, m)\)</span>，则输出 <code>Yes</code>；否则输出 <code>No</code></p>
<p><strong>样例输入：</strong></p>
<pre><code>3 5
.##.#
.#...
...#.
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code class="language-c++">Yes
</code></pre>
<p><strong>Luogu P1135 奇怪的电梯</strong></p>
<p>大楼的每一层楼都可以停电梯，而且第 <span class="math inline">\(i\)</span> 层楼（<span class="math inline">\(1 \le i \le N\)</span>）上有一个数字 <span class="math inline">\(K_i\)</span>（<span class="math inline">\(0 \le K_i \le N\)</span>）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： <span class="math inline">\(3, 3, 1, 2, 5\)</span> 代表了 <span class="math inline">\(K_i\)</span>（<span class="math inline">\(K_1=3\)</span>，<span class="math inline">\(K_2=3\)</span>，……），从 <span class="math inline">\(1\)</span> 楼开始。在 <span class="math inline">\(1\)</span> 楼，按“上”可以到 <span class="math inline">\(4\)</span> 楼，按“下”是不起作用的，因为没有 <span class="math inline">\(-2\)</span> 楼。那么，从 <span class="math inline">\(A\)</span> 楼到 <span class="math inline">\(B\)</span> 楼至少要按几次按钮呢？</p>
<p><strong>输入：</strong>  第一行为三个用空格隔开的正整数，表示 <span class="math inline">\(N, A, B\)</span>（<span class="math inline">\(1 \le N \le 200\)</span>，<span class="math inline">\(1 \le A, B \le N\)</span>）。第二行为 <span class="math inline">\(N\)</span> 个用空格隔开的非负整数，表示 <span class="math inline">\(K_i\)</span></p>
<p><strong>输出：</strong>一行，即最少按键次数，若无法到达，则输出 <code>-1</code></p>
<p><strong>样例输入：</strong></p>
<pre><code>5 1 5
3 3 1 2 5
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>3
</code></pre>
<h3 id="连通分量问题">连通分量问题</h3>
<p><strong>无向图中的连通分量</strong>：是指图中所有节点都彼此连通的最大子集。对于一个无向图，如果你从一个节点出发，通过图中的边能访问到其他所有节点，那么这些节点组成一个连通分量。如果图的某个子集内的节点之间有路径相连，则该子集为一个连通分量</p>
<h4 id="例题-leetcode-200-岛屿数量">例题 Leetcode 200 岛屿数量</h4>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成</p>
<p>此外，你可以假设该网格的四条边均被水包围</p>
<p><strong>样例输入：</strong></p>
<pre><code>grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code class="language-c++">3
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; //四个方向
void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
    queue&lt;pair&lt;int, int&gt;&gt; que;
    que.push({x, y});
    visited[x][y] = true;
    while(!que.empty()) {
        pair&lt;int ,int&gt; cur = que.front(); que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for (int i = 0; i &lt; 4; i++) {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;
            if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == '1') {
                que.push({nextx, nexty});
                visited[nextx][nexty] = true;
            }
        }
    }
}
</code></pre>
<h2 id="深度优先搜索-dfs">深度优先搜索 DFS</h2>
<h3 id="概念-1">概念</h3>
<p><strong>深度优先搜索（Depth-First Search）</strong>是一种用于图或树的遍历算法，它的基本思想是：从一个起始节点出发，沿着一条路径一直向下遍历，直到不能继续为止，然后回溯到上一个节点，继续探索其它未被访问的节点，直到所有节点都被访问过为止</p>
<p>DFS的核心思想是尽量深入每一个分支，探索到没有可再走的路径后，再回退到上一层节点进行其他路径的搜索</p>
<p>时间复杂度：<span class="math inline">\(O(V+E)\)</span></p>
<h3 id="实现方法-1">实现方法</h3>
<h4 id="递归">递归</h4>
<p>实现DFS最常见的方法，能直观的利用函数调用栈自动进行回溯。递归地访问当前节点的所有未访问的邻居；每次递归调用都会进入下一个节点，直到无法访问为止，再回溯到上一个节点，继续访问其他未被访问的邻居</p>
<pre><code class="language-cpp">int n,path[N];
bool st[N + 1]; // 标记数组
void dfs(int u) // 排列第 u 个数
{
    if (u == n)
    {
        for (int i = 0; i &lt; n; i++)
            printf("%5d", path[i]);
        printf("\n");
        return;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        if (!st[i])
        {
            path[u] = i;   // 将 i 放入当前排列的位置
            st[i] = true;  // 标记 i 已被使用
            dfs(u + 1);    // 递归 构造排列的下一个位置
            st[i] = false; // 回溯 撤销选择，取消对 i 的标记
        }
    }
}
</code></pre>
<h4 id="栈">栈</h4>
<p>显式地使用栈来模拟递归过程。从栈顶取出节点并访问，将当前节点的所有未访问的邻居压入栈中；当所有邻居被访问后，出栈，回溯到上一个节点。显式栈避免了递归带来的栈溢出问题，适合于需要较大深度遍历的场景</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; adj;  //邻接表
vector&lt;bool&gt; vis;         //记录节点是否已经遍历

void dfs(int s) {
    stack&lt;int&gt; st;
    st.push(s);
    vis[s] = true;
    while (!st.empty()) {
        int u = st.top();
        st.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                vis[v] = true;  //确保栈里没有重复元素
                st.push(v);
            }
        }
    }
}
</code></pre>
<h3 id="回溯问题">回溯问题</h3>
<p>当递归到某一层时，如果发现当前状态不符合条件，或者已经找到一个解，就撤销当前的操作，返回到上一个状态，继续尝试其他的选择</p>
<h4 id="例题-acwing-843-n皇后问题">例题 Acwing 843 N皇后问题</h4>
<p>将 <span class="math inline">\(n\)</span> 个皇后放在 <span class="math inline">\(n \times n\)</span> 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数n，请你输出所有的满足条件的棋子摆法</p>
<p><strong>输入：</strong>共一行，包含整数 <span class="math inline">\(n\)</span></p>
<p><strong>输出：</strong>每个解决方案占 <span class="math inline">\(n\)</span> 行，每行输出一个长度为 <span class="math inline">\(n\)</span> 的字符串，用来表示完整的棋盘状态。其中 ”<span class="math inline">\(.\)</span>” 表示某一个位置的方格状态为空，”<span class="math inline">\(Q\)</span>” 表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行</p>
<p><strong>输入样例：</strong></p>
<pre><code class="language-c++">4
</code></pre>
<p><strong>输出样例：</strong></p>
<pre><code class="language-c++">.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">int n;
char g[N][N];//用来存路径
bool col[N], dg[N], udg[N];//col列，dg对角线，udg反对角线，用来判断该位置是否可行

void dfs(int u) {
    if (u == n) {
        for (int i = 0; i &lt; n; i ++ ) puts(g[i]);
        puts("");
        return;
    }
    int x = u;
    for (int y = 0; y &lt; n; y ++ ) 
        if (col[y] == false &amp;&amp; dg[y - x + n] == false &amp;&amp; udg[y + x] == false) {
            col[y] = dg[y - x + n] = udg[y + x] = true;
            g[x][y] = 'Q';
            dfs(x + 1);
            g[x][y] = '.';
            col[y] = dg[y - x + n] = udg[y + x] = false;
        }
}
</code></pre>
<p><strong>Luogu P1706 全排列问题</strong></p>
<p>按照字典序输出自然数 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 所有不重复的排列，即 <span class="math inline">\(n\)</span> 的全排列，要求所产生的任一数字序列中不允许出现重复的数字</p>
<p><strong>输入：</strong>一个整数 <span class="math inline">\(n\)</span></p>
<p><strong>输出：</strong>由 <span class="math inline">\(1 \sim n\)</span> 组成的所有不重复的数字序列，每行一个序列。每个数字保留 <span class="math inline">\(5\)</span> 个场宽</p>
<p><strong>样例输入：</strong></p>
<pre><code>3
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>1    2    3
1    3    2
2    1    3
2    3    1
3    1    2
3    2    1
</code></pre>
<h3 id="强连通分量">强连通分量</h3>
<p>在有向图 <span class="math inline">\(G\)</span> 中，如果两个顶点 <span class="math inline">\(u\)</span> ，<span class="math inline">\(v\)</span> 间有一条从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的有向路径，同时还有一条从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(u\)</span> 的有向路径，则称两个顶点<strong>强连通</strong>。如果有向图 <span class="math inline">\(G\)</span> 的每两个顶点都强连通，称 <span class="math inline">\(G\)</span> 是一个<strong>强连通图</strong>。有向非强连通图的极大强连通子图，称为<strong>强连通分量</strong></p>
<div class="mermaid">graph LR
1--&gt;2
2--&gt;5
5--&gt;1
2--&gt;3
3--&gt;5
5--&gt;6
3--&gt;7
</div><p>如上图，<span class="math inline">\(\{1,2,3,5\}\)</span>为一个强连通分量，因为顶点 <span class="math inline">\(1,2,3,5\)</span> 两两可达</p>
<h4 id="tarjan算法">Tarjan算法</h4>
<ul>
<li>从每个未访问的节点开始执行DFS。在DFS的过程中，记录节点的发现时间<code>DFN</code>，更新最早可到达的祖先节点<code>LOW</code></li>
<li>当某个节点的<code>LOW</code>值等于其发现时间<code>DFN</code>时，说明从该节点开始的节点（包括它本身）形成了一个强连通分量。此时，从栈中弹出所有节点，并将它们标记为同一强连通分量</li>
<li><strong>栈<code>stack</code>在算法中用于保存当前DFS路径中的节点，直到识别到一个强连通分量时，再从栈中弹出这些节点</strong></li>
</ul>
<pre><code class="language-cpp">//vis[] 用于标记节点是否在栈中，避免重复处理
//stack[] 栈，用于存放当前DFS访问路径上的节点
//LOW[] 表示节点pos能回到的最早节点的时间戳
//DFN[] 记录节点的DFS发现时间
//dfs_num DFS的计数器，用于给每个节点标记一个唯一的访问时间戳
//size[] 记录每个强连通分量的大小
//dye[] 标记每个节点属于哪个强连通分量
//CN 当前强连通分量的编号
//pre[]和E[] 用于存储图的边和邻接表，pre[pos]存储pos节点的出边
void tarjan(int pos){
    vis[stack[++index]=pos]=1;//入栈并标记
    LOW[pos]=DFN[pos]=++dfs_num;
    for(int i=pre[pos];i;i=E[i].next){
        if(!DFN[E[i].to]){
            tarjan(E[i].to);
            LOW[pos]=min(LOW[pos],LOW[E[i].to]);
        }
        else if(vis[E[i].to]) LOW[pos]=min(LOW[pos],DFN[E[i].to]);
    }
    if(LOW[pos]==DFN[pos]){
        vis[pos]=0;
        size[dye[pos]=++CN]++;//染色及记录强连通分量大小
        while(pos!=stack[index]){
            vis[stack[index]]=0;
            size[CN]++;//记录大小
            dye[stack[index--]]=CN;//弹栈并染色
        }
        index--;
    }
}
</code></pre>
<h4 id="例题-luogu-p2341-受欢迎的牛">例题 Luogu P2341 受欢迎的牛</h4>
<p>被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果 <span class="math inline">\(A\)</span> 喜欢 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 喜欢 <span class="math inline">\(C\)</span>，那么 <span class="math inline">\(A\)</span> 也喜欢 <span class="math inline">\(C\)</span>。牛栏里共有 <span class="math inline">\(N\)</span> 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星</p>
<p><strong>输入：</strong>第一行是两个用空格分开的整数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span>；接下来 <span class="math inline">\(M\)</span> 行是每行两个用空格分开的整数 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，表示 <span class="math inline">\(A\)</span> 喜欢 <span class="math inline">\(B\)</span></p>
<p><strong>输出：</strong>一行单独一个整数，表示明星奶牛的数量</p>
<p><strong>样例输入：</strong></p>
<pre><code>3 3
1 2
2 1
2 3
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>1
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">void tarjan(int u) 
{
	low[u]=dfn[u]=++dfn_sum;
	stack[top++]=u;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(dfn(v))
			low[u]=min(low[u],dfn[v]);
		else
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
	}
	if(low[u]==dfn[u])
	{
		int now=stack[--top];s_sum++;
		s[u]+=s_sum;
		while(now!=u)
		{
			s[now]=s_num;
			now=s[--top];
		}
	}
}
</code></pre>
<h3 id="拓扑排序">拓扑排序</h3>
<p><strong>对于图中的每条有向边 <span class="math inline">\(u \to v\)</span>，在排序结果中，顶点 <span class="math inline">\(u\)</span> 必须排在顶点 <span class="math inline">\(v\)</span> 的前面</strong></p>
<p>只适用于有向无环图，也叫拓扑图</p>
<div class="mermaid">graph LR
A--&gt;B--&gt;C
A--&gt;D--&gt;C
</div><p>该图拓扑序列为 <span class="math inline">\(ABDC\)</span> 或 <span class="math inline">\(ADBC\)</span></p>
<h4 id="kahn算法">Kahn算法</h4>
<p><strong>入度：</strong>多少条边指向该节点，入度为 0 的点可以排在最前位置</p>
<p><strong>出度：</strong>该节点指向多少条边</p>
<p>先计算每个节点的入度，选择所有入度为 0 的节点作为初始节点，加入结果列表。移除这些节点及其出度边，更新相邻节点的入度。如果有相邻节点的入度变为 0，则继续加入队列，直到所有节点都被处理完</p>
<pre><code class="language-cpp">//伪代码
queue &lt;- 所有入度为 0 的点
while queue 不空
{
    t &lt;- 队头
    枚举 t 的所有出边 t-&gt;j
    删掉t-&gt;j,d[j]--;
}
</code></pre>
<h4 id="例题-luogu-b3644-拓扑排序">例题 Luogu B3644 拓扑排序</h4>
<p>有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。给出每个人的后代的信息。输出一个序列，使得每个人的后辈都比那个人后列出</p>
<p><strong>输入：</strong>第 <span class="math inline">\(1\)</span> 行一个整数 <span class="math inline">\(N\)</span>，表示家族的人数。接下来 <span class="math inline">\(N\)</span> 行，第 <span class="math inline">\(i\)</span> 行描述第 <span class="math inline">\(i\)</span> 个人的后代编号 <span class="math inline">\(a_{i,j}\)</span>，表示 <span class="math inline">\(a_{i,j}\)</span> 是 <span class="math inline">\(i\)</span> 的后代。每行最后是 <span class="math inline">\(0\)</span> 表示描述完毕</p>
<p><strong>输出：</strong>输出一个序列，使得每个人的后辈都比那个人后列出。如果有多种不同的序列，输出任意一种即可</p>
<p><strong>样例输入：</strong></p>
<pre><code>5
0
4 5 1 0
1 0
5 3 0
3 0
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>2 4 5 3 1
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">queue &lt;int&gt; Q;
void toposort() {
	for(int i = 1; i &lt;= n; i++) {
		if(deg[i] == 0) {
			printf("%d ", i);
			Q.push(i);
		}
	}
	while(Q.size()) {
		int x = Q.front(); Q.pop();
		for(int i = Head[x]; i; i = Next[i]) {
			deg[to[i]]--;
			if(deg[to[i]] == 0) {
				printf("%d ", to[i]);
				Q.push(to[i]);
			}
		}
	}
}
</code></pre>
<h3 id="环的检测">环的检测</h3>
<p><strong>环</strong>指在图中从某个顶点出发，沿着图的有向边/无向边遍历后能够回到该顶点的路径</p>
<p><strong>拓扑排序</strong>适用于有向无环图。如果一个有向图可以进行拓扑排序，则说明该图没有环。<strong>如果不能进行拓扑排序，说明图中存在环</strong></p>
<h4 id="例题-leetcode-207-课程表">例题 Leetcode 207 课程表</h4>
<p>你这个学期必须选修 <code>numCourses</code> 门课程</p>
<p>在选修某些课程之前需要一些先修课程。先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code>，表示如果要学习课程 <code>ai</code> 则必须先学习课程 <code>bi</code></p>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code></p>
<p><strong>样例输入：</strong></p>
<pre><code class="language-c++">numCourses = 2, prerequisites = [[1,0],[0,1]]
</code></pre>
<p><strong>样例输出：</strong></p>
<pre><code>false
</code></pre>
<p><strong>关键代码：</strong></p>
<pre><code class="language-cpp">bool toposort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i &lt;= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }
    return tt == n - 1;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.555470574587963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-05 16:54">2025-04-05 14:16</span>&nbsp;
<a href="https://www.cnblogs.com/violet1359">YamadaRyou</a>&nbsp;
阅读(<span id="post_view_count">117</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18804744" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18804744);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18804744', targetLink: 'https://www.cnblogs.com/violet1359/p/18804744', title: 'D 图上的遍历算法' })">举报</a>
</div>
        