
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/GuijiH6/p/18686213" title="发布于 2025-01-22 15:40">
    <span role="heading" aria-level="2">DVWA靶场XSS漏洞通关教程及源码审计</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="xss漏洞">XSS漏洞</h1>
<p><strong>XSS</strong>（跨站脚本攻击，Cross-Site  Scripting）是一种安全漏洞，通常发生在Web应用程序中。XSS漏洞允许攻击者把恶意脚本注入到内容中,  这会在其他用户的浏览器中执行。这种攻击可能导致用户会话被劫持、网站内容被修改、用户敏感信息被窃取等多种安全问题。常见的XSS类型包括：</p>
<ol>
<li><strong>存储型XSS</strong>：恶意脚本被存储在目标服务器上，比如在数据库中。比如当用户在一个留言板上输入代码，代码被存储下来了，访问该页面的其他用户就会受到影响。</li>
<li><strong>反射型XSS</strong>：恶意脚本通过URL等手段被“反射”到用户的浏览器中，常在带有查询参数的链接中实施。用户点击恶意链接时，会立即执行该脚本。</li>
<li><strong>DOM型XSS</strong>：基于文档对象模型（DOM）的变化，在客户端执行的XSS。DOM型XSS攻击不会涉及到服务器端内容改变。</li>
</ol>
<p>防御XSS攻击的方法包括：</p>
<ul>
<li>对用户输入进行严格的验证和过滤。</li>
<li>对输出进行编码，确保浏览器不能将其错误地解释为可执行代码。</li>
<li>使用安全的HTTP头，如Content Security Policy（CSP）。</li>
</ul>
<h2 id="dom型xss">DOM型XSS</h2>
<h3 id="low">low</h3>
<p>直接尝试</p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101155617257.png" alt="" loading="lazy"></p>
<h4 id="源码审计">源码审计</h4>
<p>没有任何过滤情况</p>
<pre><code class="language-php">&lt;?php
//没有保护，什么都没有
# No protections, anything goes
?&gt;
</code></pre>
<h3 id="medium">medium</h3>
<p>查看源码发现过滤掉了<strong>“&lt;script”</strong>，当函数匹配到 &lt;script 字符串的时候就会将URL后面的参数修正为 ?default=English</p>
<p>绕过</p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101160140858.png" alt="" loading="lazy"></p>
<h4 id="源码审计-1">源码审计</h4>
<p>过滤了<strong>&lt;script</strong> 字段，可以双写绕过，或者大小写绕过</p>
<pre><code class="language-php">&lt;?php
// 检查是否有输入
if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) {
    $default = $_GET['default']; // 获取查询参数 'default' 的值并赋给变量 $default

    # 不允许含有 script 标签
    if (stripos ($default, "&lt;script") !== false) {
        header ("location: ?default=English"); // 如果检测到 &lt;script&gt; 标签，则重定向到 ?default=English
        exit; // 终止脚本执行
    }
}
?&gt;
</code></pre>
<h3 id="high">high</h3>
<p>这里设置了白名单，如果default的值不为”French”、”English”、”German”、”Spanish”的话就重置URL为:?default=English ，这里只是对 default 的变量进行了过滤</p>
<p>可以考虑后面加 <strong>#</strong> 或 <strong>&amp;</strong></p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101160348438.png" alt="" loading="lazy"></p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101160412624.png" alt="" loading="lazy"></p>
<h4 id="源码审计-2">源码审计</h4>
<p>首先确保有输入数据，设置了白名单允许的语言，可以利用白名单语言进行绕过</p>
<pre><code class="language-php">&lt;?php
// 检查是否有输入
if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) {
    
    # 白名单允许的语言
    switch ($_GET['default']) {
        case "French":  // 法语
        case "English": // 英语
        case "German":  // 德语
        case "Spanish": // 西班牙语
            # 合法的语言
            break;
        default:
            header ("location: ?default=English"); // 如果输入的语言不在白名单内，则重定向到 ?default=English
            exit; // 终止脚本执行
    }
}
?&gt;
</code></pre>
<h3 id="impossible">impossible</h3>
<h4 id="源码审计-3">源码审计</h4>
<p>将防护移到客户端，更加安全</p>
<pre><code class="language-php">&lt;?php
# 不需要做任何事情，保护措施在客户端处理
?&gt;
</code></pre>
<h2 id="反射型xss-reflected">反射型XSS (Reflected）</h2>
<p><strong>反射型XSS</strong>，顾名思义在于“反射”这个一来一回的过程。反射型XSS的触发有后端的参与，而之所以触发XSS是因为后端解析用户在前端输入的带有XSS性质的脚本或者脚本的data  URI编码，后端解析用户输入处理后返回给前端，由浏览器解析这段XSS脚本，触发XSS漏洞。因此如果要避免反射性XSS，则必须需要后端的协调，在后端解析前端的数据时首先做相关的字串检测和转义处理；同时前端同样也许针对用户的数据做excape转义，保证数据源的可靠性</p>
<ul>
<li>
<p>基本原理就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。</p>
</li>
<li>
<p>特点：非持久化 必须用户点击带有特定参数的链接才能引起。</p>
</li>
<li>
<p>XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。</p>
</li>
</ul>
<h3 id="low-1">low</h3>
<p>并没有任何过滤</p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101161854180.png" alt="" loading="lazy"></p>
<h4 id="源码审计-4">源码审计</h4>
<pre><code class="language-php">&lt;?php
header ("X-XSS-Protection: 0"); // 设置 HTTP 头部，关闭 XSS 攻击防护
// 检查是否有输入
// array_key_exists() 函数：判断 $_GET 的值中是否存在 “name” 键名，并且 $_GET[‘name’] 的值是否不为空，满足这些条件，直接输出下面的输出语句。
if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {
    // 给最终用户的反馈
    echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; // 输出问候信息，包含用户输入的名称
}
?&gt;
</code></pre>
<h3 id="medium-1">medium</h3>
<p>这里过滤了<strong>&lt;script</strong>标签，这里使用了<strong>str_replace</strong>函数，它是区分大小写的，因此可以使用大小写绕过</p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101162128655.png" alt="" loading="lazy"></p>
<p>也可以使用双写绕过</p>
<p><img src="https://track123.oss-cn-beijing.aliyuncs.com/20250101162307003.png" alt="" loading="lazy"></p>
<h4 id="源码审计-5">源码审计</h4>
<p>过滤了<strong></strong></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1984281511412037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 15:41">2025-01-22 15:40</span>&nbsp;
<a href="https://www.cnblogs.com/GuijiH6">H轨迹H</a>&nbsp;
阅读(<span id="post_view_count">50</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18686213" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18686213);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18686213', targetLink: 'https://www.cnblogs.com/GuijiH6/p/18686213', title: 'DVWA靶场XSS漏洞通关教程及源码审计' })">举报</a>
</div>
        