
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dnboy/p/18800454" title="发布于 2025-03-30 12:24">
    <span role="heading" aria-level="2">CompletableFuture原理及应用场景详解</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122203924-1650091534.png" alt="" loading="lazy"></p>
<h2 id="1应用场景">1.应用场景</h2>
<p>现在我们打开各个APP上的一个页面，可能就需要涉及后端几十个服务的API调用，比如某宝、某个外卖APP上，下面是某个外卖APP的首页。首页上的页面展示会关联很多服务的API调用，如果使用同步调用的方式，接口耗时完全不能满足需求，因此，需要用到异步调用的方式。</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122214338-1551704610.jpg" alt="" loading="lazy"></p>
<h2 id="2使用线程池的弊端">2.使用线程池的弊端</h2>
<p>说起异步调用，我们通常是创建一个线程池来实现多个请求的并行调用，这样接口的整体耗时由执行时间最长的线程决定。</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122224962-6602601.png" alt="" loading="lazy"></p>
<p>但是线程池存在的问题是资源利用率较低：</p>
<ul>
<li>CPU资源大量浪费在阻塞等待上</li>
<li>CPU调度的线程数增加了，在上下文切换上的资源消耗更大了。而且线程本身也占用系统资源</li>
</ul>
<h2 id="3completablefuture的特性">3.CompletableFuture的特性</h2>
<p>我们引入CompletableFuture对业务流程进行编排，降低依赖之间的阻塞。本文主要讲述CompletableFuture的使用和原理。并对比Future、CompletableFuture、RxJava、Reactor的特性</p>
<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">Future</th>
<th style="text-align: left">CompletableFuture</th>
<th style="text-align: left">RxJava</th>
<th>Reactor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">Composable（可组合）</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">✔️</td>
<td style="text-align: left">✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align: left">Asynchronous（异步）</td>
<td style="text-align: left">✔️</td>
<td style="text-align: left">✔️</td>
<td style="text-align: left">✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align: left">Operator fusion（操作融合）</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align: left">Lazy（延迟执行）</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align: left">Backpressure（回压）</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">❌</td>
<td style="text-align: left">✔️</td>
<td>✔️</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>可组合</strong>：将多个依赖操作通过不同方式进行编排，例如CompletableFuture提供thenCompose、thenCombine等方法，这些方法支持了可组合的特性</li>
<li><strong>操作融合</strong>：将数据流中的多个操作符以某种方式结合起来，进而降低开销</li>
<li><strong>延迟执行</strong>：操作不会立即执行，当收到明确指示时才会触发操作</li>
<li><strong>回压</strong>：异步阶段的处理速度跟不上，直接失败会导致大量数据丢失，这是需要反馈上游生产者降低调用量</li>
</ul>
<p>RxJava和Reactor虽然功能更强大，但是学习成本也更高，我们选择学习成本较低的CompletableFuture</p>
<h2 id="4-一个例子回顾future">4 一个例子回顾Future</h2>
<p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步，而Future是Java5新加的接口，提供异步并行计算的功能</p>
<ul>
<li>Future只能通过阻塞或者轮询的方式获取结果，且不支持设置回调方法</li>
<li>Future.get()方法是阻塞调用获取结果，还提供了isDone方法，在程序中轮询这个方法可查询执行结果</li>
</ul>
<p>创建任务方法类</p>
<pre><code class="language-java">public class UserService {

    public String getUserInfo() throws InterruptedException {
        Thread.sleep(300L);
        return "getUserInfo() 返回结果";
    }

    public String getUserAddress() throws InterruptedException {
        Thread.sleep(500L);
        return "getUserAddress() 返回结果";
    }
}
</code></pre>
<p>创建Future测试</p>
<pre><code class="language-java">public class FutureTest {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        UserService userService = new UserService();
        try {
            Long start = System.currentTimeMillis();
            Future&lt;String&gt; future1 = executor.submit(new Callable&lt;String&gt;() {
                @Override
                public String call() throws Exception {
                    return userService.getUserInfo();
                }
            });
            Future&lt;String&gt; future2 = executor.submit(new Callable&lt;String&gt;() {
                @Override
                public String call() throws Exception {
                    return userService.getUserAddress();
                }
            });
            String result1 = future1.get();
            System.out.println(result1);
            String result2 = future2.get();
            System.out.println(result2);

            System.out.println("两个任务执行耗时：" + (System.currentTimeMillis() - start) + " ms");

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
</code></pre>
<p>最后执行结果为：</p>
<pre><code class="language-shell">getUserInfo() 返回结果
getUserAddress() 返回结果
两个任务执行耗时：505 ms
</code></pre>
<p>使用Future后任务的整体耗时，由最长的任务耗时决定</p>
<p>前面也说过，Future对结果的获取不友好，没有提供回调方法，只能阻塞或者轮询的方式。</p>
<p>Java8之前也可以用guava的ListenableFuture，来设置回调，但是这样又会导致臭名昭著的回调地狱（异步编程中因多层嵌套回调函数导致的代码可读性、可维护性急剧下降的现象），这里不展开了</p>
<h2 id="5completablefuture的使用">5.CompletableFuture的使用</h2>
<p>CompletableFuture实现了两个接口：Future和CompletionStage，Future用于异步计算，CompletionStage用于表示异步执行过程汇总的一个步骤Stage</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122240685-1653906876.png" alt="" loading="lazy"></p>
<h3 id="51一个例子入门completablefuture">5.1一个例子入门CompletableFuture</h3>
<p>这里创建一个流程，多个任务之间存在依赖关系</p>
<p>根据依赖数量，可以分为：零依赖、一元依赖、二元依赖、多元依赖</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122252032-46087834.png" alt="" loading="lazy"></p>
<h3 id="511零依赖创建异步任务">5.1.1零依赖：创建异步任务</h3>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122303221-1570883646.png" alt="" loading="lazy"></p>
<p>上面两个任务CF1、CF2就是零依赖，可以直接创建，主要有三种创建方式：</p>
<pre><code class="language-java">        ExecutorService executor = Executors.newFixedThreadPool(5);
        UserService userService = new UserService();
        //1、使用runAsync或supplyAsync发起异步调用
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt;
                userService.getUserInfo(), executor);
        //2、CompletableFuture.completedFuture()直接创建一个已完成状态的CompletableFuture
        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.completedFuture("result2");
        //3、先初始化一个未完成的CompletableFuture，然后通过complete() completeExceptionally()，完成该CompletableFuture
        CompletableFuture&lt;String&gt; cf = new CompletableFuture&lt;&gt;();
        cf.complete("success");
</code></pre>
<h3 id="512-一元依赖依赖一个cf">5.1.2 一元依赖：依赖一个CF</h3>
<p>任务的执行存在一个上游依赖，可以通过<strong>thenApply</strong>、thenAccept、thenCompose方法来实现</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122314534-936069873.png" alt="" loading="lazy"></p>
<pre><code class="language-java">CompletableFuture&lt;String&gt; cf3 = cf1.thenApply(result1 -&gt; {
  //result1为CF1的结果
  //......
  return "result3";
});
CompletableFuture&lt;String&gt; cf5 = cf2.thenApply(result2 -&gt; {
  //result2为CF2的结果
  //......
  return "result5";
});
</code></pre>
<h3 id="513-二元依赖依赖两个cf">5.1.3 二元依赖：依赖两个CF</h3>
<p>上图中的CF4就是个二元依赖，它依赖CF1和CF2，我们通过thenCombine等回调来实现。代码如下：</p>
<pre><code class="language-java">CompletableFuture&lt;String&gt; cf4 = cf1.thenCombine(cf2, (result1, result2) -&gt; {
            //result1和result2分别为cf1和cf2的结果
            return "result4";
        });
</code></pre>
<h3 id="514-多元依赖依赖多个cf">5.1.4 多元依赖：依赖多个CF</h3>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122327165-1940710214.png" alt="" loading="lazy"></p>
<p>CF6是多元依赖，这种关系可以通过<code>allOf</code>、<code>anyOf</code>方法来实现：</p>
<ul>
<li><code>allOf</code>方法：多个依赖需全部完成</li>
<li><code>anyOf</code>方法：任意一个依赖完成即可</li>
</ul>
<pre><code class="language-java">        //多元依赖
CompletableFuture&lt;Void&gt; cf6 = CompletableFuture.allOf(cf3, cf4, cf5);
CompletableFuture&lt;String&gt; result = cf6.thenApply(v -&gt; {
            //这里的join并不会阻塞，因为传给thenApply的函数是在CF3、CF4、CF5全部完成时，才会执行 。
            String result3 = cf3.join();
            String result4 = cf4.join();
            String result5 = cf5.join();
            //根据result3、result4、result5组装最终result;
            return result3 + result4 + result5;
        });
</code></pre>
<h2 id="6completablefuture原理">6.CompletableFuture原理</h2>
<p>CompletableFuture包含了两个volatile修饰的变量：result和stack</p>
<ul>
<li>result存储当前CF的结果</li>
<li>stack表示当前CF完成后需要触发的依赖动作，依赖动作可以有多个，以栈形成存储，stack表示栈顶元素</li>
</ul>
<pre><code class="language-java">    volatile Object result;       // Either the result or boxed AltResult
    volatile Completion stack;    // Top of Treiber stack of dependent actions
</code></pre>
<p>Completion类本身是<strong>观察者</strong>的基类</p>
<p><img src="https://img2024.cnblogs.com/blog/2784584/202503/2784584-20250330122339255-1449358875.png" alt="" loading="lazy"></p>
<p><strong>被观察者</strong>：每个CF都是一个被观察者，stack中存储的是注册的所有观察者，当CF执行完成后，会弹栈stack，依次通知观察者。result用于存储CF执行的结果数据</p>
<p><strong>观察者</strong>：回调方法如thenApply、thenAccept会生成一个Completion类型的对象，就是观察者。检查当前CF是否已完成，如果已完成则执行Completion，否则加入观察者链stack中</p>
<h2 id="7使用问题">7.使用问题</h2>
<h3 id="71代码执行在哪个线程上">7.1代码执行在哪个线程上？</h3>
<p>CompletableFuture的组合操作都有同步和异步两种方法：</p>
<p><strong>同步方法</strong>（即不带Async后缀的）：</p>
<ul>
<li>如果注册时被依赖的操作已经执行完成，则直接由<strong>当前线程执行</strong></li>
<li>如果注册时被依赖操作未执行完，则由<strong>回调线程执行</strong></li>
</ul>
<p><strong>异步方法</strong>（带Async后缀的）：</p>
<ul>
<li>不传递线程池参数Executor时，由公共线程池CommonPool（CPU核数-1）执行</li>
<li>传递时用的传入的指定线程池</li>
</ul>
<h3 id="72异步回调要传线程池">7.2异步回调要传线程池</h3>
<p>异步回调时<strong>强制传入线程池，并根据实际情况做线程池隔离</strong></p>
<p>不传递时，使用的都是公共线程池CommonPool，容易形成性能瓶颈。手动传递线程池参数可以更方便调节参数，并给不同业务分配不同线程池，做到资源隔离</p>
<h3 id="73-future需要获取返回值才能获取异常信息">7.3 Future需要获取返回值，才能获取异常信息</h3>
<pre><code class="language-java">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(
     ......
)

  //如果不加get()方法这一行，看不到异常信息
  future.get();
</code></pre>
<p>Future需要获取返回值时，才能获取到异常信息，不加get()方法是看不到的。</p>
<p>CompletableFuture还提供了异常捕获回调exceptionally方法，相当于同步调用中的try/catch方法可获取异常</p>
<pre><code class="language-java">public CompletableFuture&lt;Integer&gt; getCancelTypeAsync(long orderId) {
    CompletableFuture&lt;WmOrderOpRemarkResult&gt; remarkResultFuture = wmOrderAdditionInfoThriftService.findOrderCancelledRemarkByOrderIdAsync(orderId);//业务方法，内部会发起异步rpc调用
    return remarkResultFuture
      .exceptionally(err -&gt; {//通过exceptionally 捕获异常，打印日志并返回默认值
         log.error("WmOrderRemarkService.getCancelTypeAsync Exception orderId={}", orderId, err);
         return 0;
      });
}
</code></pre>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.5797531026724537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-30 12:24">2025-03-30 12:24</span>&nbsp;
<a href="https://www.cnblogs.com/dnboy">卷福同学</a>&nbsp;
阅读(<span id="post_view_count">39</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18800454" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18800454);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18800454', targetLink: 'https://www.cnblogs.com/dnboy/p/18800454', title: 'CompletableFuture原理及应用场景详解' })">举报</a>
</div>
