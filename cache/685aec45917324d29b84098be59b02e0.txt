
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/leadingcode/p/18832215" title="发布于 2025-04-18 09:59">
    <span role="heading" aria-level="2">做Docx预览，一定要做这个神库！！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>Hey, 我是 沉浸式趣谈</li>
<li>本文首发于【沉浸式趣谈】，我的个人博客 <strong><a href="https://yaolifeng.com" target="_blank" rel="noopener nofollow">https://yaolifeng.com</a></strong> 也同步更新。</li>
<li>转载请在文章开头注明出处和版权信息。</li>
<li>如果本文对您有所帮助，请 <strong>点赞</strong>、<strong>评论</strong>、<strong>转发</strong>，支持一下，谢谢！</li>
</ul>
<p>只需几行代码，你就能在浏览器中完美预览 Word 文档，甚至连表格样式、页眉页脚都原汁原味地呈现出来。</p>
<p>接下来，给大家分享两个 Docx 预览的库：</p>
<h2 id="docx-preview-vs-mammoth">docx-preview VS mammoth</h2>
<p><code>docx-preview</code>和<code>mammoth</code>是目前最流行的两个 Word 文档预览库，它们各有特色且适用于不同场景。</p>
<h3 id="docx-preview还原度爆表的选择">docx-preview：还原度爆表的选择</h3>
<p>安装简单：</p>
<pre><code class="language-bash">npm install docx-preview
</code></pre>
<p>基础用法：</p>
<pre><code class="language-javascript">import { renderAsync } from 'docx-preview';

// 获取到docx文件的blob或ArrayBuffer后
renderAsync(docData, document.getElementById('container')).then(() =&gt; console.log('文档渲染完成！'));
</code></pre>
<p>试了试后，这个库渲染出来的效果简直和 Office 打开的一模一样！连段落格式、表格样式、甚至是分页效果，都完美呈现。</p>
<h3 id="mammoth简洁至上的转换器">mammoth：简洁至上的转换器</h3>
<p>mammoth 的思路完全不同，它把 Word 文档转成干净的 HTML：</p>
<pre><code class="language-bash">npm install mammoth
</code></pre>
<p>使用也很简单：</p>
<pre><code class="language-javascript">import mammoth from 'mammoth';

mammoth.convertToHtml({ arrayBuffer: docxBuffer }).then(result =&gt; {
    document.getElementById('container').innerHTML = result.value;
    console.log('转换成功，但有些警告：', result.messages);
});
</code></pre>
<p>转换出来的 HTML 非常干净，只保留了文档的语义结构。</p>
<p>比如，Word 中的"标题 1"样式会变成 HTML 中的<code>&lt;h1&gt;</code>标签。</p>
<h2 id="哪个更适合你">哪个更适合你？</h2>
<h3 id="场景一做了个简易-word-预览器">场景一：做了个简易 Word 预览器</h3>
<p>要实现在线预览 Word 文档，且跟 "Word" 长得一模一样。</p>
<p>首选<code>docx-preview</code>：</p>
<pre><code class="language-javascript">import { renderAsync } from 'docx-preview';

async function previewDocx(fileUrl) {
    try {
        // 获取文件
        const response = await fetch(fileUrl);
        const docxBlob = await response.blob();

        // 渲染到页面上
        const container = document.getElementById('docx-container');
        await renderAsync(docxBlob, container, null, {
            className: 'docx-viewer',
            inWrapper: true,
            breakPages: true,
            renderHeaders: true,
            renderFooters: true,
        });

        console.log('文档渲染成功！');
    } catch (error) {
        console.error('渲染文档时出错:', error);
    }
}
</code></pre>
<p>效果很赞！文档分页显示，目录、页眉页脚、表格边框样式都完美呈现。</p>
<p>不过也有些小坑：</p>
<ol>
<li>文档特别大时，渲染速度会变慢</li>
<li>一些复杂的 Word 功能可能显示不完美</li>
</ol>
<h3 id="场景二做内容编辑系统">场景二：做内容编辑系统</h3>
<p>需要让用户上传 Word 文档，然后提取内容进行编辑。</p>
<p>选择<code>mammoth</code>：</p>
<pre><code class="language-javascript">import mammoth from 'mammoth';

async function extractContent(file) {
    try {
        // 读取文件
        const arrayBuffer = await file.arrayBuffer();

        // 自定义样式映射
        const options = {
            styleMap: ["p[style-name='注意事项'] =&gt; div.alert-warning", "p[style-name='重要提示'] =&gt; div.alert-danger"],
        };

        const result = await mammoth.convertToHtml({ arrayBuffer }, options);
        document.getElementById('content').innerHTML = result.value;

        if (result.messages.length &gt; 0) {
            console.warn('转换有些小问题:', result.messages);
        }
    } catch (error) {
        console.error('转换文档失败:', error);
    }
}
</code></pre>
<p>mammoth 的优点在这个场景下完全发挥出来：</p>
<ol>
<li><strong>语义化 HTML</strong>：生成干净的 HTML 结构</li>
<li><strong>样式映射</strong>：可以自定义 Word 样式到 HTML 元素的映射规则</li>
<li><strong>轻量转换</strong>：处理速度非常快</li>
</ol>
<h2 id="进阶技巧">进阶技巧</h2>
<h3 id="docx-preview-的进阶配置">docx-preview 的进阶配置</h3>
<pre><code class="language-javascript">renderAsync(docxBlob, container, styleContainer, {
    className: 'custom-docx', // 自定义CSS类名前缀
    inWrapper: true, // 是否使用包装容器
    ignoreWidth: false, // 是否忽略页面宽度
    ignoreHeight: false, // 是否忽略页面高度
    breakPages: true, // 是否分页显示
    renderHeaders: true, // 是否显示页眉
    renderFooters: true, // 是否显示页脚
    renderFootnotes: true, // 是否显示脚注
    renderEndnotes: true, // 是否显示尾注
    renderComments: true, // 是否显示评论
    useBase64URL: false, // 使用Base64还是ObjectURL处理资源
});
</code></pre>
<p>超实用技巧：如果只想把文档渲染成一整页（不分页），只需设置<code>breakPages: false</code>！</p>
<h3 id="mammoth-的自定义图片处理">mammoth 的自定义图片处理</h3>
<p>默认情况下，mammoth 会把图片转成 base64 嵌入 HTML。</p>
<p>在大型文档中，这会导致 HTML 特别大。</p>
<p>更好的方案：</p>
<pre><code class="language-javascript">const options = {
    convertImage: mammoth.images.imgElement(function (image) {
        return image.readAsArrayBuffer().then(function (imageBuffer) {
            // 创建blob URL而不是base64
            const blob = new Blob([imageBuffer], { type: image.contentType });
            const url = URL.createObjectURL(blob);

            return {
                src: url,
                alt: '文档图片',
            };
        });
    }),
};

mammoth.convertToHtml({ arrayBuffer: docxBuffer }, options).then(/* ... */);
</code></pre>
<p>这样一来，图片以 Blob URL 形式加载，页面性能显著提升！</p>
<h2 id="其他方案对比">其他方案对比</h2>
<p>说实话，在选择这两个库之前，也有其他解决方案：</p>
<h3 id="微软-office-online-在线预览">微软 Office Online 在线预览</h3>
<p>利用微软官方提供的 Office Online Server 或 Microsoft 365 的在线服务，通过嵌入 <code>WebView</code> 或 <code>&lt;iframe&gt;</code> 实现 DOCX 的在线渲染。</p>
<p>示例代码：</p>
<pre><code class="language-html">&lt;iframe src="https://view.officeapps.live.com/op/embed.aspx?src=文档URL"&gt;&lt;/iframe&gt;
</code></pre>
<h4 id="优点">优点</h4>
<ul>
<li><strong>格式高度还原</strong>：支持复杂排版、图表、公式等。</li>
<li><strong>无需本地依赖</strong>：纯浏览器端实现。</li>
<li><strong>官方维护</strong>：兼容性最好。</li>
</ul>
<p>折腾一圈，还是<code>docx-preview</code>和<code>mammoth</code>这俩兄弟最实用。</p>
<p>它们提供了轻量级的解决方案，仅需几十 KB 就能搞定 Word 预览问题，而且不需要依赖外部服务，完全可以在前端实现。</p>
<h2 id="写在最后">写在最后</h2>
<p><code>docx-preview</code>适合需要高还原度的场景，如文档预览系统；</p>
<p>而<code>mammoth</code>适合内容提取、文档到 HTML 的转换场景，如内容管理系统。</p>
<p>而 <code>微软 Office Online</code> 适合高还原公开文档。</p>
<p>根据具体需求选择合适的工具吧！</p>
<p>后面打算写关于 powerpoint、excel、pdf、图片系列，需要的小伙伴可以关注一波！</p>
<h2 id="其他好文推荐">其他好文推荐</h2>
<p><a href="https://mp.weixin.qq.com/s/RGFQbqzmrY1NVkdUsQcMBw" target="_blank" rel="noopener nofollow">关于 Node，一定要学这个 10+万 Star 项目！</a><br>
<a href="https://mp.weixin.qq.com/s/U58MpLt_7ndZlGQfogZdAA" target="_blank" rel="noopener nofollow">关于 MCP，这几个网站你一定要知道！</a><br>
<a href="https://mp.weixin.qq.com/s/f5pIdyY8grx9t6qYxMgR1w" target="_blank" rel="noopener nofollow">【完整汇总】近 5 年 JavaScript 新特性完整总览</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04151545716319444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 10:00">2025-04-18 09:59</span>&nbsp;
<a href="https://www.cnblogs.com/leadingcode">沉浸式趣谈</a>&nbsp;
阅读(<span id="post_view_count">75</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18832215);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18832215', targetLink: 'https://www.cnblogs.com/leadingcode/p/18832215', title: '做Docx预览，一定要做这个神库！！' })">举报</a>
</div>
        