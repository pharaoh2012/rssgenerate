
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zpcdbky/p/18800861" title="发布于 2025-04-06 03:34">
    <span role="heading" aria-level="2">虚函数表里有什么？（二）——普通单继承下的虚函数表</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        这是本系列文章的第二篇，在前文的基础上，本文将探究普通单继承下的虚函数表和相关内容。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>前言</h1>
<p><a href="https://www.cnblogs.com/zpcdbky/p/18773538" target="_blank">上篇文章</a>中，我们探索了单个多态对象（没有继承）的虚函数表中的条目及它们的作用。本文继续探究普通单继承下的虚函数表。</p>
<p>本节示例代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> #include &lt;iostream&gt;
<span style="color: rgba(0, 128, 128, 1)"> 2</span> #include &lt;typeinfo&gt;
<span style="color: rgba(0, 128, 128, 1)"> 3</span> 
<span style="color: rgba(0, 128, 128, 1)"> 4</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 0, 1)">    Base() {}
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base() {}
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> zoo()
</span><span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">11</span>         std::cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Base::zoo\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">13</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span> foo() = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">15</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> b_num = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">16</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)">17</span> 
<span style="color: rgba(0, 128, 128, 1)">18</span> <span style="color: rgba(0, 0, 255, 1)">class</span> Derived : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Base
</span><span style="color: rgba(0, 128, 128, 1)">19</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">20</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">21</span> <span style="color: rgba(0, 0, 0, 1)">    Derived() {}
</span><span style="color: rgba(0, 128, 128, 1)">22</span>     ~<span style="color: rgba(0, 0, 0, 1)">Derived() {}
</span><span style="color: rgba(0, 128, 128, 1)">23</span>     <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> fun()
</span><span style="color: rgba(0, 128, 128, 1)">24</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">25</span>         std::cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Derived::fun\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">26</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">27</span>     <span style="color: rgba(0, 0, 255, 1)">void</span> foo() <span style="color: rgba(0, 0, 255, 1)">override</span>
<span style="color: rgba(0, 128, 128, 1)">28</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">29</span>         std::cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">my num is: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; d_num &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">30</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">31</span> <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">32</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> d_num = <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">33</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)">34</span> 
<span style="color: rgba(0, 128, 128, 1)">35</span> <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">argv[])
</span><span style="color: rgba(0, 128, 128, 1)">36</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">37</span>     std::cout &lt;&lt;<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(Derived) &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">38</span>     Base *p = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Derived;
</span><span style="color: rgba(0, 128, 128, 1)">39</span>     <span style="color: rgba(0, 0, 255, 1)">const</span> std::type_info &amp;info = typeid(*<span style="color: rgba(0, 0, 0, 1)">p);
</span><span style="color: rgba(0, 128, 128, 1)">40</span>     std::cout &lt;&lt; info.name() &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">41</span>     <span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p;
</span><span style="color: rgba(0, 128, 128, 1)">42</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">43</span> }</pre>
</div>
<h1>Base类虚函数布局</h1>
<p>Base类有纯虚函数，不能实例化，那我们如何查看它的vtable呢？一种方式是通过<a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGIAJykrgAyeAyYAHI%2BAEaYxCAAzBqkAA6oCoRODB7evnppGY4CoeFRLLHxZgDstpj2RQxCBEzEBDk%2BfoF2mA5ZTS0EJZExcYnJCs2t7XlctpODYcPlo9UAlLaoXsTI7BzmCWHI3lgA1CYJbk4TxJis59gmGgCC%2B4fHmGcXBACeKZhh/HujxezyOTAUChOFnBmGBJiqVmeKS80VoeGQIGBJ2xUJhEFWZwR8IAIlicQA3PCtLxiE4AP2hSnxhKsVVJzxxJ0p1Np5NQeHQJwAXqhUPiydj4YinpzORN0CAUJsCJ83Oc3GczJYYYqRagTABWNwMcxmc7SzkkiUnAD0Nq5VIINNoXP5gv4YoJ52JJw05uBKWIeHJTAI7GtYRV0QA%2BgwfJ8fVwNH6EtKram4aCDBCTsS4sHMIKQCdkaj0bilHCiUiUWiMda80HyYXmVKrRycXTGwX0K2iWzrdynby3ScqF4GOKO5LqzLZdj5Yq0F4Ver1ZqzN3mwqQOOTUaTVr/dPCey59i7a6BWPRczUM3iEGsNbL22T5e5QQd8vVxd16aWG%2BE44xYE48AUYtTVVdd0FjeM1wuE4wD2A9kOPc9bXtdsnkDYNQ3DE9IxOWCQITE4zGTdD0zTZ4iJYJgwggIiWmAZBSBOZAEBaE4ACoWPJQ0rANYlVirC0cUXJUV2gi4MiFTBUCoCAt0LL0/0QtDUL2DMT0ZD4eJSMjwgAd1zfNt3Qzk0AYCYTkkn4/mjAFUE1AA2ZyyIc/5ewM0SdIwySfxkjVnIAOmYNhW3UjVNONND/M5LB6DDEtLJxG4nWIBhfSotkOHWWhOANXg/A4LRSFQTg1Usaw7M2bYPn2HhSAITR8vWABrEADWSQqOEkEq2oqzheAg5JWrK/LSDgWAYEQJUWBSOg4nISg0EW5b4mAKQzD4Ogw2ICCIGiIbojCFpvk4ZqzuYYhvgAeWibQegm5r1rYQR7oYWhLsm0gsGiLxgDcMRaAg7heCweijHEP78BuXpm3B8rMFUHoV12crIzqK7eDRaJiAujwsCGgggxYXHSAfaJ0kwPNoeANEjDa9YqAMYAFAANTwTBjPuv5Sua/hBBEMR2C4BIZEERQVHUP7dFmAxmdMGrLH0PBoggyB1lQFIGnBgBaYATgN%2B6zBNqgGFQA2wiZj4Dflb0VasSwKJNgB1UHeHvOIn0wLX8VqeoshcBh3E8Do9BCRYygqfJ0kyARpj8WYCkThghlj0ZZm6XoBH6KYI5mIOXr6eZM5GeIc/mZO9AmAYK%2BWKv1gUeqdgkAqisGv7Ko4E5VAADlcg3XMkE5WOQE4pFC82IFwQgSE1BIuFWXgJq0VZOu63rOAG0gKYHsxQv8VyuH8fwzAl1ykkkDRXNIUryt70aQHGlnprmiAkGVZECFWiB1pLXoMQCIrBdiD2HqPDiStjZcCqKFDQoVmqFgXk%2BPQwthCiHEFIKW8glBqCGgrUgxlCYpFxp3DgxUH5DV7vdFcv8TiKX7kPEeY8J5T0kDPE4EAPAbWAUvFea8WbrAQLcLA8RA59T3hTOBCCEgD2TFUIeCRXL%2BANP4aQj9vYjVsK/FqwjSBdR6voTgCRu5Px0evdqJiOBmHMdojgQjJqbypnEDIzhJBAA" target="_blank" rel="noopener nofollow">Compiler Explorer</a>，另一种是通过GDB。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250329214933892-339078162.png" alt="" loading="lazy"></p>
<p>转化成图，如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202503/642223-20250329212642883-1604248402.png" alt="" loading="lazy"></p>
<p>上篇文章介绍过的内容不再重复，这里着重介绍以下几点：</p>
<ol>
<li>因为含有纯虚函数的类不能实例化，自然也不存在析构，因此两个析构函数的地址都是0。</li>
<li>虚函数地址在虚函数表中的顺序与它们在类中的声明顺序一致，本例中，先是constructor，接着是<span class="cnblogs_code">Base::zoo()</span>，最后是纯虚函数<span class="cnblogs_code">Base::foo()</span>。读者可以调整这些函数的声明顺序，然后观察虚函数表的变化。</li>
<li><span class="cnblogs_code">__cxa_pure_virtual</span>是一个错误处理函数，当调到纯虚函数时，实际上会执行这个函数，该函数最终会&nbsp;<span class="cnblogs_code">std::abort()</span>&nbsp;（<a href="https://github.com/gcc-mirror/gcc/blob/cc63163f0a17f80b2bee1b174197793d163680c1/libstdc%2B%2B-v3/libsupc%2B%2B/pure.cc#L47" target="_blank" rel="noopener nofollow">source code</a>）。什么时候会出现这种情况呢？<a href="https://uvdn7.github.io/pure_virtual/" target="_blank" rel="noopener nofollow">这篇文章</a>讲得很透彻，在下就不班门弄斧了。</li>
</ol>
<h1>Derived类虚函数布局</h1>
<p><img src="https://img2024.cnblogs.com/blog/642223/202504/642223-20250406032635978-515619010.png" alt="" loading="lazy"></p>
<p>着重介绍以下几点。</p>
<h2>合并的虚函数表</h2>
<p>因为只有一个基类，且不是虚基类，因此基类子对象和派生类共用一个虚函数表。对于某个条目，如果派生类有自己的实现（比如typeinfo、override的虚函数等），那么就采用派生类的版本，否则，采用基类的版本。对于派生类新增的虚函数，按声明顺序依次排在最后面。如上图所示。</p>
<h2>__si_class_type_info</h2>
<p>和之前不同的是，这里type_info指针指向了&nbsp;<span class="cnblogs_code">__si_class_type_info</span>&nbsp;对象。该类继承自上篇文章提到的&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;，源码位于<a href="https://github.com/gcc-mirror/gcc/blob/cc63163f0a17f80b2bee1b174197793d163680c1/libstdc%2B%2B-v3/libsupc%2B%2B/cxxabi.h#L505" target="_blank" rel="noopener nofollow">cxxabi.h</a>，<a href="https://www.swag.uwaterloo.ca/acd/docs/ItaniumC++ABI.htm" target="_blank" rel="noopener nofollow">Itanium C++ ABI</a>的解释是：</p>
<blockquote>
<p>For classes containing only a single, public, non-virtual base at offset zero (i.e. the derived class is dynamic iff the base is), class&nbsp;<code>abi::__si_class_type_info</code>&nbsp;is used. It adds to&nbsp;<code>abi::__class_type_info</code>&nbsp;a single member pointing to the type_info structure for the base type, declared "<code>__class_type_info const *__base_type</code>".</p>
</blockquote>
<p>即，使用&nbsp;<span class="cnblogs_code">__si_class_type_info</span>&nbsp;的条件是：1）单一继承；2）public继承；3）不是虚继承；4）基类对象是<a href="https://en.cppreference.com/w/cpp/language/object#Polymorphic_objects" target="_blank" rel="noopener nofollow">polymorphic object</a>（这个概念在上篇文章介绍过）。</p>
<p>相比于&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;，&nbsp;<span class="cnblogs_code">__si_class_type_info </span>&nbsp;多了一个指向直接基类typeinfo信息的指针&nbsp;<span class="cnblogs_code">__base_type</span>&nbsp;。那么，&nbsp;<span class="cnblogs_code">__base_type</span>&nbsp;有什么用呢？</p>
<h3>用途一：异常捕获时的类型匹配</h3>
<p>对于本文示例，执行下面的代码时（需要将&nbsp;<span class="cnblogs_code">Base::foo</span>&nbsp;改为非纯虚函数），<span style="color: rgba(0, 0, 255, 1)"><br></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
    </span><span style="color: rgba(0, 0, 255, 1)">throw</span><span style="color: rgba(0, 0, 0, 1)"> Derived();
} </span><span style="color: rgba(0, 0, 255, 1)">catch</span> (<span style="color: rgba(0, 0, 255, 1)">const</span> Base&amp;<span style="color: rgba(0, 0, 0, 1)"> b) {
    b.foo();
}</span></pre>
</div>
<p>在catch实现的核心函数&nbsp;<span class="cnblogs_code">__do_catch</span>&nbsp;里（<a href="https://github.com/gcc-mirror/gcc/blob/8d42378acdf1a011420ba78685f7a6c79808c881/libstdc%2B%2B-v3/libsupc%2B%2B/class_type_info.cc#L33" target="_blank" rel="noopener nofollow">source code</a>），会判断抛出的异常类型和捕获的异常类型是否匹配。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> __class_type_info::
__do_catch (</span><span style="color: rgba(0, 0, 255, 1)">const</span> type_info *<span style="color: rgba(0, 0, 0, 1)">thr_type,
            </span><span style="color: rgba(0, 0, 255, 1)">void</span> **<span style="color: rgba(0, 0, 0, 1)">thr_obj,
            unsigned outer) </span><span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 这里==调用的是基类std::type_info的operator==, 本质上就是比较typeinfo name这一字符串常量</span>
  <span style="color: rgba(0, 0, 255, 1)">if</span> (*<span style="color: rgba(0, 0, 255, 1)">this</span> == *<span style="color: rgba(0, 0, 0, 1)">thr_type)
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (outer &gt;= <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Neither `A' nor `A *'.</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果不匹配，就看thr_type的上层类型是否匹配</span>
  <span style="color: rgba(0, 0, 255, 1)">return</span> thr_type-&gt;__do_upcast (<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, thr_obj);
}</span></pre>
</div>
<p>本例中，&nbsp;<span class="cnblogs_code">thr_type</span>&nbsp;是指向typeinfo for Derived，即&nbsp;<span class="cnblogs_code">__si_class_type_info</span>&nbsp;对象的指针，&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针是指向typeinfo for Base，即&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;对象的指针。&nbsp;<span class="cnblogs_code">std::type_info::operator==</span>&nbsp;的实现代码见<a href="https://github.com/gcc-mirror/gcc/blob/145e462d557af537d90ef6da1391a57603c6fcf0/libstdc%2B%2B-v3/libsupc%2B%2B/typeinfo#L210" target="_blank" rel="noopener nofollow">这里</a>。</p>
<p>在<a href="https://github.com/gcc-mirror/gcc/blob/145e462d557af537d90ef6da1391a57603c6fcf0/libstdc%2B%2B-v3/libsupc%2B%2B/si_class_type_info.cc#L75" target="_blank" rel="noopener nofollow">__si_class_type_info::__do_upcast</a>里，如果当前类型（这里是Derived类型）和要捕获的目标类型（这里是Base类型）不相同，就调用&nbsp;<span class="cnblogs_code">__base_type-&gt;__do_upcast</span>&nbsp;，去看基类的类型和要捕获的类型是否相同。如此这般，直到匹配或者upcast到最“祖先”的类型。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> __si_class_type_info::
__do_upcast (</span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *dst, <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">obj_ptr,
             __upcast_result </span>&amp;__restrict result) <span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果当前类型和dst（即要捕获的类型）相同，返回true</span>
  <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (__class_type_info::__do_upcast (dst, obj_ptr, result))
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;

  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 否则看基类类型是否和dst相同</span>
  <span style="color: rgba(0, 0, 255, 1)">return</span> __base_type-&gt;<span style="color: rgba(0, 0, 0, 1)">__do_upcast (dst, obj_ptr, result);
}

</span><span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> __class_type_info::
__do_upcast (</span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *dst, <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">obj,
             __upcast_result </span>&amp;__restrict result) <span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (*<span style="color: rgba(0, 0, 255, 1)">this</span> == *dst) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 相同就返回true</span>
<span style="color: rgba(0, 0, 0, 1)">    {
      result.dst_ptr </span>=<span style="color: rgba(0, 0, 0, 1)"> obj;
      result.base_type </span>=<span style="color: rgba(0, 0, 0, 1)"> nonvirtual_base_type;
      result.part2dst </span>=<span style="color: rgba(0, 0, 0, 1)"> __contained_public;
      </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
    }
  </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<h3>用途二：dynamic_cast中的类型回溯</h3>
<p>需要注意的是，如果是向上转换（upcast），如下，</p>
<div class="cnblogs_code">
<pre>Derived *pd = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Derived;
Basel </span>*pb = dynamic_cast&lt;Base *&gt;(pd);</pre>
</div>
<p>gcc编译器通常会优化成从派生类对象到基类子对象的简单指针移动，不会去调用&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;操作符（是的，它是operator，不是函数）的底层实现&nbsp;<span class="cnblogs_code">__dynamic_cast</span>&nbsp;（这是函数，是gcc对&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;的实现），即使&nbsp;<span class="cnblogs_code">-O0</span>&nbsp;优化级别也是如此。因此，我们重点关注向下转换（downcast）的情形。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">struct</span> A { <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">A(){} };
</span><span style="color: rgba(0, 0, 255, 1)">struct</span> B : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> A {};
</span><span style="color: rgba(0, 0, 255, 1)">struct</span> C : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> B {};
</span><span style="color: rgba(0, 0, 255, 1)">struct</span> D : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> C {};

</span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main() {
  A </span>*pa = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> D;
  B </span>*pb = dynamic_cast&lt;B*&gt;<span style="color: rgba(0, 0, 0, 1)">(pa);
  </span><span style="color: rgba(0, 0, 255, 1)">int</span> ret = nullptr == pb ? -<span style="color: rgba(128, 0, 128, 1)">1</span> : <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
  </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> pa;
  </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ret;
}</span></pre>
</div>
<p>这里，是从基类A到派生类B的向下转换，&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;会检查是否可以转换，因为&nbsp;<span class="cnblogs_code">pa</span>&nbsp;实际指向的最派生类D的实例，因此从本质上讲还是完整对象到基类子对象的转换，因此，最终转换是成功的。那么，&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;是如何做到这一点的呢？让我们从核心实现&nbsp;<span class="cnblogs_code">__dynamic_cast</span>&nbsp;开始。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">extern</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">C</span><span style="color: rgba(128, 0, 0, 1)">"</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">
__dynamic_cast (</span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *src_ptr,    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> object started from</span>
                <span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *src_type, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> type of the starting object</span>
                <span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *dst_type, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> desired target type</span>
                ptrdiff_t src2dst) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> how src and dst are related</span>
<span style="color: rgba(0, 0, 0, 1)">  {
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (__builtin_expect(!src_ptr, <span style="color: rgba(128, 0, 128, 1)">0</span>)) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果源指针是空，直接返回空</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> NULL; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Handle precondition violations gracefully.
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 这里就是利用虚函数表里的top_offset和typeinfo信息，找到完整对象（也
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 就是最派生类对象）的指针和类型信息</span>
  <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *vtable = *static_cast &lt;<span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 255, 1)">const</span> *&gt;<span style="color: rgba(0, 0, 0, 1)"> (src_ptr);
  </span><span style="color: rgba(0, 0, 255, 1)">const</span> vtable_prefix *prefix =<span style="color: rgba(0, 0, 0, 1)">
    (adjust_pointer </span>&lt;vtable_prefix&gt;<span style="color: rgba(0, 0, 0, 1)">
     (vtable,  </span>-<span style="color: rgba(0, 0, 0, 1)">ptrdiff_t (offsetof (vtable_prefix, origin))));
  </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *whole_ptr =<span style="color: rgba(0, 0, 0, 1)">
      adjust_pointer </span>&lt;<span style="color: rgba(0, 0, 255, 1)">void</span>&gt; (src_ptr, prefix-&gt;<span style="color: rgba(0, 0, 0, 1)">whole_object);
  </span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *whole_type = prefix-&gt;<span style="color: rgba(0, 0, 0, 1)">whole_type;
  __class_type_info::__dyncast_result result; </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 构造一个result，存放__do_cast的结果

  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 这里省略一些与本主题无关的校验代码

  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 从完整对象的类型（本例是D）向上回溯，寻找目标类型dst_type（本例是B）</span>
  whole_type-&gt;<span style="color: rgba(0, 0, 0, 1)">__do_dyncast (src2dst, __class_type_info::__contained_public,
                            dst_type, whole_ptr, src_type, src_ptr, result);

  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 根据result确定返回结果，代码先省略</span>
  }</pre>
</div>
<p>&nbsp;<span class="cnblogs_code">__dynamic_cast</span>&nbsp;会根据待转换对象的指针和类型信息，通过虚函数表中的top_offset和typeinfo，拿到最派生对象的指针和类型信息，然后层层回溯，看看能不能回溯到目标类型。对本例来说，就是先从A类型得到最派生类型D，然后从D逐级回溯，D--&gt;C--&gt;B。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">bool</span><span style="color: rgba(0, 0, 0, 1)"> 
__do_dyncast (ptrdiff_t src2dst,
              __sub_kind access_path,
              </span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *<span style="color: rgba(0, 0, 0, 1)">dst_type,
              </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">obj_ptr,
              </span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *<span style="color: rgba(0, 0, 0, 1)">src_type,
              </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">src_ptr,
              __dyncast_result </span>&amp;__restrict result) <span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (*<span style="color: rgba(0, 0, 255, 1)">this</span> == *<span style="color: rgba(0, 0, 0, 1)">dst_type)
    {
      result.dst_ptr </span>= obj_ptr; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 这里其实就是dynamic_cast的返回值
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 还会设置result的其它字段，与本主题无关，先略过</span>
      <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span>; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> false的意思是：不用再回溯了</span>
<span style="color: rgba(0, 0, 0, 1)">    }
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (obj_ptr == src_ptr &amp;&amp; *<span style="color: rgba(0, 0, 255, 1)">this</span> == *src_type) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 先略过</span>
<span style="color: rgba(0, 0, 0, 1)">    {
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 省略一些代码</span>
      <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    }
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果当前类型不匹配，就回溯到上一层</span>
  <span style="color: rgba(0, 0, 255, 1)">return</span> __base_type-&gt;<span style="color: rgba(0, 0, 0, 1)">__do_dyncast (src2dst, access_path, dst_type, obj_ptr,
                             src_type, src_ptr, result);
}</span></pre>
</div>
<p>因为过分深入细节会偏离主题，所以本文仅点到为止，等到讲述完虚函数表相关的内容，后面会专门拿出一篇文章，结合实例，讲解&nbsp;<span class="cnblogs_code">__dynamic_cast</span>&nbsp;的实现细节，帮助读者把之前的知识融会贯通。</p>
<p>gcc源码位置：<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/dyncast.cc#L45" target="_blank" rel="noopener nofollow">__dynamic_cast</a>、<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/si_class_type_info.cc#L44" target="_blank" rel="noopener nofollow">__si_class_type_info::__do_dynamic</a>。</p>
<h3>用途三：dynamic_cast中寻找public基类</h3>
<p>如果通过找到了转换目标的地址，但是却不能确定&nbsp;<span class="cnblogs_code">src_type</span>&nbsp;是不是&nbsp;<span class="cnblogs_code">dst_type</span>&nbsp;的public基类（如果不是，转换就会失败，返回空指针），因此需要从&nbsp;<span class="cnblogs_code">dst_type</span>&nbsp;向上回溯，看能不能找出到&nbsp;<span class="cnblogs_code">src_type</span>&nbsp;的public路径。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> __dynamic_cast中的逻辑</span>
<span style="color: rgba(0, 0, 255, 1)">if</span> (result.dst2src ==<span style="color: rgba(0, 0, 0, 1)"> __class_type_info::__unknown)
    result.dst2src </span>= dst_type-&gt;<span style="color: rgba(0, 0, 0, 1)">__find_public_src (src2dst, result.dst_ptr,
                                                  src_type, src_ptr);</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;<span class="cnblogs_code">__find_public_src</span>&nbsp;是&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;的成员函数，在<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/tinfo.h#L161" target="_blank" rel="noopener nofollow">tinfo.h</a>中定义。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">inline __class_type_info::__sub_kind __class_type_info::
__find_public_src (ptrdiff_t src2dst,
                   </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">obj_ptr,
                   </span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *<span style="color: rgba(0, 0, 0, 1)">src_type,
                   </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *src_ptr) <span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (src2dst &gt;= <span style="color: rgba(128, 0, 128, 1)">0</span>) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 若大于0，src是dst的基类子对象，接下来看加上偏移量后指针是否匹配</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span> adjust_pointer &lt;<span style="color: rgba(0, 0, 255, 1)">void</span>&gt; (obj_ptr, src2dst) ==<span style="color: rgba(0, 0, 0, 1)"> src_ptr
            </span>?<span style="color: rgba(0, 0, 0, 1)"> __contained_public : __not_contained;
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (src2dst == -<span style="color: rgba(128, 0, 128, 1)">2</span>) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 等于-2表示：src is not a public base of dst</span>
    <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> __not_contained;
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 其余情况需要调用__do_find_public_src逐级回溯</span>
  <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
}</span></pre>
</div>
<p><span class="cnblogs_code">__si_class_type_info::__do_find_public_src</span>&nbsp;会逐级向上回溯。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">__class_type_info::__sub_kind __si_class_type_info::
__do_find_public_src (ptrdiff_t src2dst,
                      </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *<span style="color: rgba(0, 0, 0, 1)">obj_ptr,
                      </span><span style="color: rgba(0, 0, 255, 1)">const</span> __class_type_info *<span style="color: rgba(0, 0, 0, 1)">src_type,
                      </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">void</span> *src_ptr) <span style="color: rgba(0, 0, 255, 1)">const</span><span style="color: rgba(0, 0, 0, 1)">
{
  </span><span style="color: rgba(0, 0, 255, 1)">if</span> (src_ptr == obj_ptr &amp;&amp; *<span style="color: rgba(0, 0, 255, 1)">this</span> == *<span style="color: rgba(0, 0, 0, 1)">src_type)
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> __contained_public;
  </span><span style="color: rgba(0, 0, 255, 1)">return</span> __base_type-&gt;<span style="color: rgba(0, 0, 0, 1)">__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
}</span></pre>
</div>
<p>那么，什么情况下需要逐级寻找public base呢？比如说下面的代码：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span> Base { <span style="color: rgba(0, 0, 255, 1)">public</span>: <span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Base() {} };          
</span><span style="color: rgba(0, 0, 255, 1)">class</span> Middle : <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">virtual</span><span style="color: rgba(0, 0, 0, 1)"> Base {};             
</span><span style="color: rgba(0, 0, 255, 1)">class</span> Derived : <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Middle {};                 

</span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main() {
    Base</span>* base_ptr = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Derived;                 
    Derived</span>* derived_ptr = dynamic_cast&lt;Derived*&gt;<span style="color: rgba(0, 0, 0, 1)">(base_ptr);
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> ret = nullptr == derived_ptr ? -<span style="color: rgba(128, 0, 128, 1)">1</span> : <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> base_ptr;
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ret;
}</span></pre>
</div>
<p>因为这里继承关系比较复杂（涉及到虚拟继承），所以&nbsp;<span class="cnblogs_code">__do_dyncast</span>&nbsp;不能确定&nbsp;<span class="cnblogs_code">dst2src</span>&nbsp;是什么，需要再次回溯。由于虚拟继承超出了本文的讨论范围，因此暂不深入分析，留待后序文章探讨。</p>
<h1>总结</h1>
<ul>
<li>在vtable中，纯虚函数对应&nbsp;<span class="cnblogs_code">__cxa_pure_virtual</span>&nbsp;这个错误处理函数，该函数的本质是调用&nbsp;<span class="cnblogs_code">about()</span>&nbsp;，即，如果调用纯虚函数，会导致程序奔溃。</li>
<li>如果一个类只有一个基类，并且这个基类是public的、非虚的、多态的（含有虚函数），那么，派生类对象和基类子对象公用一个vtable，对于某个条目，如果派生类有自己的实现，那么就采用派生类的版本，否则，采用基类的版本。对于派生类新增的虚函数，按声明顺序依次排在最后面。</li>
<li>对于满足上述条件的派生类，它对应的typeinfo类型是&nbsp;<span class="cnblogs_code">__si_class_type_info</span>&nbsp;，该类是&nbsp;<span class="cnblogs_code">__class_type_info</span>&nbsp;的派生类，含有一个指向基类typeinfo的指针&nbsp;<span class="cnblogs_code">__base_type</span>&nbsp;，依靠该指针，可以从派生类类型到基类类型进行逐层回溯，这在异常捕获、&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;中发挥着重要作用。</li>
</ul>
<p>由于在下才疏学浅，能力有限，错误疏漏之处在所难免，恳请广大读者批评指正，您的批评是在下前进的不竭动力。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2323403287349537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-06 03:37">2025-04-06 03:34</span>&nbsp;
<a href="https://www.cnblogs.com/zpcdbky">同勉共进</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18800861" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18800861);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18800861', targetLink: 'https://www.cnblogs.com/zpcdbky/p/18800861', title: '虚函数表里有什么？（二）——普通单继承下的虚函数表' })">举报</a>
</div>
        