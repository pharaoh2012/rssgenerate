
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Aitozi/p/18774397" title="发布于 2025-03-15 23:30">
    <span role="heading" aria-level="2">Paimon merge into 实现原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="语法">语法</h1>
<pre><code class="language-SQL">MERGE INTO target  
USING source  
ON source.a = target.a  
WHEN MATCHED THEN  
UPDATE SET a = source.a, b = source.b, c = source.c
WHEN NOT MATCHED THEN 
INSERT (a, b, c) values (a, b, c)
</code></pre>
<p>merge into 实际上是一个语法糖, 相对应的语义也可以通过其他的 sql 语法来表达, 例如 UPDATE/DELETE/INSERT, 但是 merge into 的好处是本身一次事务, 因此可以原子性的完成多个修改的操作.</p>
<p><a href="https://docs.databricks.com/aws/en/sql/language-manual/delta-merge-into" target="_blank" rel="noopener nofollow">databricks merge into</a></p>
<h1 id="paimon-merge-into">Paimon merge into</h1>
<p>在 Paimon 中, 主键表和非主键表提供了不同的 merge into 实现方式.</p>
<h2 id="非主键表">非主键表</h2>
<h3 id="cow">COW</h3>
<p><img src="https://aitozi.oss-cn-hangzhou.aliyuncs.com/img.Pasted%20image%2020250315172505.png" alt="Pasted image 20250315172505|350" loading="lazy"></p>
<p>处理流程</p>
<ol>
<li>通过 join 找出 update/delete 语句所涉及的文件, 及 touched splits. 这一步不需要读取源表的全量字段数据, 只需要读取关联条件所涉及的字段</li>
<li>将所有涉及到的数据文件作为数据源读取, 并和 source 表进行 full outer join, 对 join 结果进行 match 和 not match 的处理, 并写出至新文件中</li>
<li>将所有的老的数据文件标记为删除文件, 新写入生成的文件标记为新增文件</li>
</ol>
<p><strong>为什么需要第一次 inner join?</strong></p>
<p>当 Matched Action 中涉及对原始文件的修改需求, 例如 merge action 中存在 UPDATE 或 DELETE 子句时, 就有两种方式</p>
<ul>
<li>对 target 表进行一次 insert overwrite, 那么这样对于涉及 update/delete 的文件自然就完成了更新</li>
<li>通过 inner join 找出涉及修改的文件, 再修改完成后通过指定文件 DELETE 的方式标记删除</li>
</ul>
<p>显然, 在小范围更新的场景下, 第二种方式会更加合适, 可以减少重写文件的数量, 降低存储放大.</p>
<p><strong>为什么需要将 non touched splits  也纳入到计算中?</strong></p>
<p>因为有 <code>WHEN NOT MATCHED</code> 这类 not matched by source/target 时, 就需要将 inner join 未匹配上的数据也参与计算才能使得 <code>WHEN NOT MATCHED</code> 条件判断准确.</p>
<p>劣势:</p>
<ol>
<li>原来的一次 join 操作, 被转化为两次 join</li>
<li>如果 source 是一个包含计算逻辑的 view, 也会被展开执行</li>
</ol>
<p>优势:</p>
<ol>
<li>如果 touched 列表比较小, 可以降低过程中重写的开销以及存储空间</li>
</ol>
<h3 id="deletion-vector">Deletion vector</h3>
<p><img src="https://aitozi.oss-cn-hangzhou.aliyuncs.com/img.Pasted%20image%2020250315232351.png" alt="Pasted image 20250315232351|217" loading="lazy"></p>
<ol>
<li>直接基于原始的 target, source 进行 full outer join, 同时读取的时候会读取出 target 表中的 row_index, 用于后续的标记删除</li>
<li>基于 merge action 进行处理
<ul>
<li>将 INSERT 和 UPDATE_AFTER 数据写入 add 新增文件</li>
<li>将其中的 DELETE 数据标记删除, 构建成 deletion vector 索引文件</li>
</ul>
</li>
</ol>
<p>优势</p>
<ol>
<li>只有一轮 join 和原始计算开销相近</li>
<li>通过标记删除的方式, 同样可以降低存储空间</li>
</ol>
<h2 id="主键表">主键表</h2>
<p><img src="https://aitozi.oss-cn-hangzhou.aliyuncs.com/img.Pasted%20image%2020250315232411.png" alt="Pasted image 20250315232411|184" loading="lazy"></p>
<p>主键表的流程和上面的流程其实很像, 因为本身主键表就有更新删除能力, 因此构建出变更行后直接写回主键表即可.</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/delta-io/delta/blob/master/spark/src/main/scala/org/apache/spark/sql/delta/commands/MergeIntoCommand.scala" target="_blank" rel="noopener nofollow">Delta merge into</a></li>
<li><a href="https://github.com/apache/iceberg/pull/1947" target="_blank" rel="noopener nofollow">Iceberg merge into</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/Aitozi/" target="_blank">Aitozi</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/Aitozi/p/18774397" target="_blank">https://www.cnblogs.com/Aitozi/p/18774397</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8719460019155093" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-15 23:30">2025-03-15 23:30</span>&nbsp;
<a href="https://www.cnblogs.com/Aitozi">Aitozi</a>&nbsp;
阅读(<span id="post_view_count">40</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18774397" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18774397);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18774397', targetLink: 'https://www.cnblogs.com/Aitozi/p/18774397', title: 'Paimon merge into 实现原理' })">举报</a>
</div>
        