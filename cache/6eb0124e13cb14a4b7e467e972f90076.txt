
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18716557" title="发布于 2025-02-15 11:29">
    <span role="heading" aria-level="2">最小生成树可并行化的 Sollin（Boruvka）算法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上期回顾：<a href="https://www.cnblogs.com/ofnoname/p/18715203" target="_blank">https://www.cnblogs.com/ofnoname/p/18715203</a></p>
<p>在前文中，我们剖析了最小生成树（MST）问题中的两大经典算法：</p>
<ul>
<li><strong>Kruskal</strong> 以“边权平等”为信条，通过排序与并查集自下而上聚合连通分量；</li>
<li><strong>Prim</strong> 以“中心辐射”为策略，通过优先队列自上而下扩张领土。</li>
</ul>
<p>二者虽路径迥异，却殊途同归，均以贪心策略保证全局最优。还有一种不那么为人熟知的 <strong>Sollin 算法</strong>（又称 Boruvka 算法），它融合了前两者的思想，并在并行计算领域大放异彩，在特定情况下非常有用。</p>
<h2 id="sollin-算法分治与并行">Sollin 算法：分治与并行</h2>
<p>Sollin 算法仍然基于贪心，但是他从多个起点开始。想象一场战国时代的争霸赛：初始每一个点都是一代表一个国家，自身是一个连通分量，接下来每个小国（连通分量）各自派出使者，寻找与邻国间成本最低的结盟道路。所有国家<strong>同时行动</strong>，每一轮合并后形成更大的联盟，直到天下归一。Sollin 算法的核心正是这种<strong>分阶段的并行贪心策略</strong>：</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>初始化</strong>：每个节点自成一个连通分量。</li>
<li><strong>并行探索</strong>：每一轮迭代下，对每个连通分量，找到其连接外界的<strong>最小权重边</strong>（类似 Prim 的切割性质）。</li>
<li><strong>批量合并</strong>：将所有找到的最小边加入 MST，合并连通分量。</li>
<li><strong>循环迭代</strong>：重复步骤 2-3，直至只剩一个连通分量。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250215112613919-1050179689.png" alt="image" loading="lazy"></p>
<h3 id="正确性证明">正确性证明</h3>
<p>Sollin 的正确性同样基于<strong>安全边定理</strong>：</p>
<blockquote>
<p>每个连通分量选择的最小出边，必定属于某个 MST。</p>
</blockquote>
<p><strong>归纳法视角</strong>：</p>
<ul>
<li><strong>初始状态</strong>：每个节点独立，所有边均为安全边候选。</li>
<li><strong>归纳假设</strong>：当前已选边集是某个 MST 的子集。</li>
<li><strong>归纳步骤</strong>：每轮选择的边均为不同切割的最小边，加入后仍保持 MST 的存在性。</li>
</ul>
<p><strong>关键观察</strong>：</p>
<ul>
<li>若两个连通分量选择彼此之间的同一条边，该边只会被加入一次（去重机制）。</li>
<li>合并操作保证连通分量数量至少减半，确保算法终止。</li>
</ul>
<pre><code class="language-cpp">struct Edge {
    int u, v, weight, index;
};

class Graph {
    int n, m;
    vector&lt;Edge&gt; edges;

public:
    Graph(int n, int m) : n(n), m(m) {}
    
    void addEdge(int u, int v, int weight, int index) {
        edges.push_back({u, v, weight, index});
    }
    
    long long boruvka(vector&lt;int&gt;&amp; result) {
        UnionFind uf(n); // 并查集实现略
        long long total_weight = 0;
        int components = n;
        
        while (components &gt; 1) {
            vector&lt;Edge&gt; min_edges(n, {-1, -1, INT_MAX, -1});
            
            // 查找每个连通分量的最小边
            for (const auto&amp; edge : edges) {
                int root_u = uf.find(edge.u);
                int root_v = uf.find(edge.v);
                if (root_u == root_v) continue;
                
                if (edge.weight &lt; min_edges[root_u].weight)
                    min_edges[root_u] = edge;
                
                if (edge.weight &lt; min_edges[root_v].weight)
                    min_edges[root_v] = edge;
            }
            
            // 收集并处理有效边
            unordered_set&lt;int&gt; valid_edges;
            for (int i = 0; i &lt; n; ++i) {
                if (min_edges[i].index != -1 &amp;&amp; 
                    !uf.connected(min_edges[i].u, min_edges[i].v)) {
                    valid_edges.insert(min_edges[i].index);
                }
            }
            
            if (valid_edges.empty()) break;
            
            // 合并连通分量并记录结果
            int added = 0;
            for (int idx : valid_edges) {
                const Edge&amp; e = edges[idx];
                if (uf.unite(e.u, e.v)) {
                    total_weight += e.weight;
                    result.push_back(idx);
                    added++;
                }
            }
            
            if (added == 0) break;
            components -= added;
        }
        
        return components == 1 ? total_weight : -1;
    }
};
</code></pre>
<hr>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>每轮操作成本</strong>：
<ul>
<li>寻找每个连通分量的最小边：<span class="math inline">\(O(|E|)\)</span>（需遍历所有边）。</li>
<li>合并连通分量：使用并查集优化后接近 <span class="math inline">\(O(|V| \cdot \alpha(|V|))\)</span>。</li>
</ul>
</li>
<li><strong>轮数上限</strong>：由于每轮连通分量数量至少减半，总轮数为 <span class="math inline">\(O(\log |V|)\)</span>。</li>
<li><strong>总复杂度</strong>：<span class="math inline">\(O(|E| \log |V|)\)</span>，与二叉堆优化的 Prim 算法相当。</li>
</ul>
<hr>
<h2 id="sollin-vs-kruskal">Sollin vs Kruskal</h2>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Sollin (Boruvka)</strong></th>
<th><strong>Kruskal</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心策略</strong></td>
<td>多连通分量并行找最小边</td>
<td>全局排序 + 单线程并查集</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td><span class="math inline">\(O(|E| \log |V|)\)</span></td>
<td><span class="math inline">\(O(|E| \log |E|)\)</span></td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>需维护多个连通分量</td>
<td>只需存储并查集和边列表</td>
</tr>
<tr>
<td><strong>并行潜力</strong></td>
<td>✅ 每轮操作天然可并行（如MapReduce）</td>
<td>❌ 排序和并查集依赖全局状态</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>边权分布均匀的图，或需要并行处理</td>
<td>稀疏图（<span class="math inline">\(|E| \ll |V|^2\)</span>）</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>较高（需处理多分量合并与去重）</td>
<td>简单（仅排序与并查集）</td>
</tr>
</tbody>
</table>
<p>在分布式系统中，每轮各连通分量的最小边搜索可分配给不同计算节点，适合超大规模图（如社交网络分析）。据说 Boruvka 算法在 20 世纪 20 年代被用于规划捷克斯洛伐克的电力网络，其分阶段特性契合人工计算流程。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9739767232175925" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-15 11:29">2025-02-15 11:29</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">88</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18716557" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18716557);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18716557', targetLink: 'https://www.cnblogs.com/ofnoname/p/18716557', title: '最小生成树可并行化的 Sollin（Boruvka）算法' })">举报</a>
</div>
        