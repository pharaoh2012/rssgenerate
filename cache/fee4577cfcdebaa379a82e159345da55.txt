
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/penggeon/p/18750132" title="发布于 2025-03-04 11:18">
    <span role="heading" aria-level="2">STM32实战——ESP8266 WIFI模块</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        此篇博文提供了ESP8266的开发指南，包括在STM32上使用ESP8266进行WiFi连接、发送和接收HTTP请求以及在ESP8266中使用AT指令发送GET方式请求等内容。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="esp8266">ESP8266</h1>
<h2 id="硬件介绍">硬件介绍</h2>
<p>ESP8266系列模组有哪些：</p>
<p><img src="https://s2.loli.net/2024/03/30/pqEPUhmrTweBOa6.png" alt="" loading="lazy"></p>
<p><img src="https://s2.loli.net/2024/03/30/wAlxfqJHXcKNOjo.png" alt="" loading="lazy"></p>
<p>在本实验中，<code>ESP8266</code>与<code>ESP-01</code>不做区分。</p>
<p>ESP-01引脚介绍：</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.3</td>
<td>3.3V供电，避免使用5V供电</td>
</tr>
<tr>
<td>RX</td>
<td>UART_RXD，异步串口接受端</td>
</tr>
<tr>
<td>RST</td>
<td>外部复位引脚，低电平有效，默认高电平</td>
</tr>
<tr>
<td>IO0</td>
<td>GPIO_0引脚:状态:1.悬空:Flash下载模式和工作模式:2.下拉:串口下载模式</td>
</tr>
<tr>
<td>EN</td>
<td>使能端口，高电平工作，低电平模块不工作</td>
</tr>
<tr>
<td>IO2</td>
<td>GPIO_2引脚，开机上电时禁止下拉，默认高电平</td>
</tr>
<tr>
<td>TX</td>
<td>UART_TXD，异步串口发送端</td>
</tr>
<tr>
<td>GND</td>
<td>GND接地引脚</td>
</tr>
</tbody>
</table>
<p>实物图如下（某些板子没有丝印端口说明，可以参照下图）：</p>
<p><img src="https://s2.loli.net/2024/03/30/Ojg47tzKx3SMrmQ.jpg" alt="" loading="lazy"></p>
<p>引脚连接如下：</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>连接</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.3V</td>
<td>3.3V</td>
</tr>
<tr>
<td>RST</td>
<td>3.3V</td>
</tr>
<tr>
<td>EN</td>
<td>3.3V</td>
</tr>
<tr>
<td>IO2</td>
<td>3.3V</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>IO0</td>
<td>GND</td>
</tr>
<tr>
<td>TXD</td>
<td>RXD</td>
</tr>
<tr>
<td>RXD</td>
<td>TXD</td>
</tr>
</tbody>
</table>
<p>硬件连接图（2）</p>
<p><img src="https://s2.loli.net/2024/04/02/qn8L71H6zbujw4r.jpg" alt="" loading="lazy"></p>
<p><strong>使用ESP串口工具</strong></p>
<p>某宝上有现成的调试ESP8266模块的串口工具，已将各个引脚接好，还带有RST按键，烧录固件库或者调试程序使用很方便。</p>
<p>本次实验测试时使用该串口工具。</p>
<p><img src="https://img2024.cnblogs.com/blog/3152699/202503/3152699-20250304111545779-1445684723.jpg" alt="" loading="lazy"></p>
<h2 id="三种模式">三种模式</h2>
<p>ESP8266 支持 softAP 模式，station 模式，softAP + station 共存模式三种。</p>
<p>利用 ESP8266 可以实现十分灵活的组网方式和网络拓扑。</p>
<blockquote>
<p>提示<br>
SoftAP：即无线接入点，是一个无线网络的中心节点。通常使用的无线路由器就是一个无线接入点。</p>
<p>Station：即无线终端，是一个无线网络的终端端。</p>
</blockquote>
<h2 id="at命令">AT命令</h2>
<p><img src="https://img2024.cnblogs.com/blog/3152699/202503/3152699-20250304110819937-1629710112.jpg" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3152699/202503/3152699-20250304110916076-1257979883.jpg" alt="" loading="lazy"></p>
<p>此外，在<code>AT+CIPSEND</code>输入模式下发送<code>+++</code>（不需要换行），即可退出输入模式。</p>
<p><code>ATE1</code>开启回显，<code>ATE0</code>关闭回显。</p>
<p><code>AT+CIOBAUD=115200</code>将波特率修改为115200。</p>
<h2 id="esp8266-tcp通信测试">ESP8266 TCP通信测试</h2>
<h3 id="网络环境准备">网络环境准备</h3>
<p>手机开启流量，开启热点，设置热点名称（最好是6位字母以下）和密码。</p>
<p>将电脑连接到手机热点。</p>
<h3 id="电脑端准备">电脑端准备</h3>
<p>1、网络调试</p>
<p>win+R 输入cmd进入DOS窗口，之后输入<code>ipconfig</code>查看当前电脑IP地址，例如我的IP为<code>192.168.41.242</code></p>
<p>打开网络调试工具（任意工具即可，例如野火网络调试助手），将电脑配置为<code>TCP Server</code>，输入刚刚的IP<code>192.168.41.242</code>，端口号自己决定（需要与下一步相匹配），例如8080。</p>
<p>点击开始监听。</p>
<p>2、串口</p>
<p>将"ESP8266模块的串口工具"插入电脑USB口，打开串口调试工具（任意串口调试工具均可），设置波特率115200（ESP8266默认波特率），数据位8位，停止位1位，校验位无。</p>
<p>接收与发送均为"文本模式"，编码为GBK编码。</p>
<h3 id="esp8266连接流程">ESP8266连接流程</h3>
<p>依次利用串口向ESP8266输入以下命令。</p>
<ul>
<li><code>AT\r\n</code><br>
检查ESP8266模块连接是否正常</li>
<li><code>AT+CWMODE=1\r\n</code><br>
配置模块为Sta模式</li>
<li><code>AT+CWJAP="WIFI名称","WIFI密码"\r\n</code><br>
连接指定WIFI，确保为自己的WIFI</li>
<li><code>AT+CIPMUX=0\r\n</code><br>
设置成单连接</li>
<li><code>AT+CIPSTART="TCP","192.168.41.242",8080\r\n</code><br>
创建TCP连接，IP地址为电脑的IP，串口为电脑监听的端口号</li>
<li><code>AT+CIPMODE=1\r\n</code><br>
进入透传模式，进入到透传模式后AT指令就会失效，需要退出后才能生效</li>
<li><code>AT+CIPSEND\r\n</code><br>
准备向服务器发送请求，前面都成功的前提下发送完这个指令后会出现一个&gt;，此时输入发送信息即可</li>
</ul>
<p>如果前面的命令均正确，则发送<code>Hello</code>后，此时电脑网络调试工具会接收<code>Hello</code>。</p>
<p>电脑网络调试工具发送<code>123</code>，ESP8266也会收到<code>123</code>。</p>
<p>至此，单独对ESP8266的设置和测试完成。接下来可以编写STM32代码。</p>
<p>附：完整的输入输出信息（<code>\r\n</code>表示按一次回车）</p>
<p>输入：</p>
<pre><code class="language-txt">AT\r\n
ATE0\r\n
AT+CWMODE=1\r\n
AT+CWJAP="bwifyt","123456789"\r\n
AT+CIPMUX=0\r\n
AT+CIPSTART="TCP","192.168.41.242",8080\r\n
AT+CIPMODE=1\r\n
AT+CIPSEND\r\n
</code></pre>
<p>输出：</p>
<pre><code class="language-txt">AT


OK
ATE0


OK

OK
WIFI CONNECTED
WIFI GOT IP

OK

OK

ERROR
CLOSED

ERROR
CLOSED

ERROR
CLOSED
CONNECT

OK

OK

OK

&gt;
</code></pre>
<h2 id="esp8266-http测试">ESP8266 HTTP测试</h2>
<h3 id="http协议">HTTP协议</h3>
<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="" loading="lazy"></p>
<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt="" loading="lazy"></p>
<h3 id="esp8266发送http请求">ESP8266发送HTTP请求</h3>
<p>这里使用<a href="https://www.seniverse.com/" target="_blank" rel="noopener nofollow">心知天气</a>进行测试。</p>
<p>服务器的IP地址可以使用<code>ping api.seniverse.com</code>命令获得。</p>
<p>端口号一般为80端口，如果是其他端口，请先使用网络调试助手确保可行。</p>
<p>使用正确的AT命令，重新设置ESP8266连接的IP地址（或者重启模块，重新设置，参照上一小节内容）。</p>
<p>发送格式</p>
<pre><code class="language-txt">GET /v3/weather/now.json?key=你的密钥&amp;location=beijing&amp;language=zh-Hans&amp;unit=c


</code></pre>
<p>响应：服务器返回的数据</p>
<pre><code class="language-txt">{"results":[{"location":{"id":"WX4FBXXFKE4F","name":"北京","country":"CN","path":"北京,北京,中国","timezone":"Asia/Shanghai","timezone_offset":"+08:00"},"now":{"text":"多云","code":"4","temperature":"16"},"last_update":"2024-03-31T20:24:29+08:00"}]}
</code></pre>
<p>也可以使用完整的GET请求：</p>
<pre><code class="language-txt">GET /v3/weather/now.json?key=你的密钥&amp;location=beijing&amp;language=zh-Hans&amp;unit=c HTTP/1.1
Content-Type: application/json;charset=utf-8
Host: www.liefyuan.top
Connection: Keep Alive


</code></pre>
<blockquote>
<p>注意<br>
GET之后有一空格，HTTP/1.1之前有一空格。最后需要以两行换行表示结束。</p>
</blockquote>
<blockquote>
<p>响应信息<br>
发送完整的GET请求，可以得到完整的响应信息</p>
<p>使用简略的GET请求，可以得到简略的响应信息</p>
</blockquote>
<p>至于POST请求，需要与后端进行沟通，才能够确定具体的发送格式。</p>
<h3 id="esp8266接收响应">ESP8266接收响应</h3>
<blockquote>
<p>提示<br>
以下内容与我目前所做的项目高度相关，因此有部分其他代码不做解释，只讲解关键点代码</p>
</blockquote>
<p>发送HTTP请求之后，需要接收相关的响应，并对数据进行解析。</p>
<p>C语言有类似于CJSON的库可以能够实现数据解析做这件事，但是我们这里依旧采用自编代码实现。</p>
<p>优点是不需要导入CJSON的代码，对于单片机要求不高。缺点是需要手动编写，但是我们请求的次数不多，也就显得不是很麻烦了。</p>
<p><strong>1、初始化</strong></p>
<p>首先进行初始化，开启串口接收数据的中断。</p>
<pre><code class="language-C">// USART相关配置

/*中断输出配置*/
USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // 开启串口接收数据的中断
USART_ITConfig(USART3, USART_IT_IDLE, ENABLE); // 开启串口接收数据的中断

// NVIC相关配置
</code></pre>
<p>这里的“两个”中断都需要打开，不然无法正常接收到数据。</p>
<p><strong>2、中断函数</strong></p>
<p>之后编写我们需要的中断函数，即将ESP8266接收到的数据保存下来。</p>
<pre><code class="language-c">/**
 * @brief  串口3接收到数据中断回调函数
 * @param  None
 * @retval None
 */
static void ESP8266_FrameFinish_CallBack(void) {
  Serial_Printf("\r\n中断回调函数串口输出:\r\n%s", ESP8266_Buffer.Body);
}

/**
 * @brief  串口3中断函数
 * @param  None
 * @retval None
 */
void USART3_IRQHandler(void) {
  if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
  {
    // 当接收没有结束时，将源源不断的接收到的字符存入缓冲区
    if (ESP8266_Buffer.Length &lt; (USART_RX_BUF_SIZE - 1))
    {
      ESP8266_Buffer.Body[ESP8266_Buffer.Length++] = (char)USART_ReceiveData(USART3);
    }
  }
  if (USART_GetITStatus(USART3, USART_IT_IDLE) != RESET)
  {
    // 当接收结束时，向缓冲区尾端添加结束符
    ESP8266_Buffer.FinishFlag = 1;
    ESP8266_Buffer.Body[ESP8266_Buffer.Length] = '\0';
    // 清除串口空闲中断标志位
    volatile uint16_t temp;
    temp = USART3-&gt;SR;
    temp = USART3-&gt;DR;
    ESP8266_FrameFinish_CallBack();
  }
}
</code></pre>
<p><strong>3、发送HTTP接收数据</strong></p>
<pre><code class="language-c">/**
 * @brief  清空ESP8266_Buffer结构体
 * @param  None
 * @retval None
 */
void ESP8266_ClearBuffer(void)
{
  memset(ESP8266_Buffer.Body, 0, USART_RX_BUF_SIZE);  // 清空缓存区数据
  ESP8266_Buffer.FinishFlag = 0;  // 清空FinishFlag, 表示没有接收完成
  ESP8266_Buffer.Length = 0;      // 清空Length, 表示接收长度为0
}

/**
 * @brief  HTTP GET类型请求
 * @param  address 请求地址
 * @param  timeout 超时时间(单位:100ms)
 * @retval char* 字符数组
 */
char* ESP8266_HTTP_Get(char* address, uint8_t timeout)
{
  ESP8266_ClearBuffer();  // 清空ESP8266缓存
  ESP8266_Printf("GET %s HTTP/1.1\r\n\r\n", address);
  while(timeout--)
  {
    Delay_ms(100);
    if(ESP8266_Buffer.FinishFlag)
    {
      return ESP8266_GetBuffer();
    }
  }
  
  return "HTTP Send Failed.";
}
</code></pre>
<p><strong>4、解析数据</strong></p>
<p>由于我的接收响应是这样的</p>
<pre><code class="language-json">{
    "status": "1",
    "msg": [
        {
            "id": 7,
            "name": "temperature",
            "value": "26.0"
        },
        {
            "id": 8,
            "name": "humidity",
            "value": "100.0"
        },
        {
            "id": 9,
            "name": "concentration",
            "value": "200.9"
        }
    ]
}
</code></pre>
<p>所以我的解析数据函数如下（添加了注释，相信大家能够明白）</p>
<pre><code class="language-c">/**
 * @brief  从res中提取信息, 数据类型为uint8_t
 * @param  res: 响应字符串
 * @param  name: 数据名称
              temperature: 温度
              humidity: 湿度
              concentration: 浓度
 * @param  integer_part: 整数部分
 * @param  decimal_part: 小数部分
 * @retval 无
 */
void GetInformation(char *res, char *name, uint8_t *integer_part, uint8_t *decimal_part) {
	char *key_start = strstr(res, name);              // 寻找name开头
	char *result_start = strstr(key_start, "value") + 9;  // 寻找数据开头
	char *dot = strchr(result_start, '.');                // 寻找小数点
	char *result_end = strchr(result_start, '\"');    // 寻找数据结尾
  
	char string_integer_part[5];
	char string_decimal_part[5];
	strncpy(string_integer_part, result_start, dot - result_start); // 整数部分字符串
	strncpy(string_decimal_part, dot + 1, result_end - dot - 1);    // 小数部分字符串

	*integer_part = atoi(string_integer_part);      // 整数部分
	*decimal_part = atoi(string_decimal_part);      // 小数部分
}
</code></pre>
<p><strong>5、示例代码</strong></p>
<pre><code class="language-c">// ESP8266_HTTP_Get是请求HTTP的参数，将返回一个字符串指针
char* res = ESP8266_HTTP_Get("/your_site", 100);
char* res_end;
do
{
	res = ESP8266_GetBuffer();
	res_end = strstr(res, "}]}");
	Delay_ms(100);
}while(res_end == NULL);

// 获取温度, 湿度, PM2.5浓度值
char* name = "temperature";
GetInformation(res, name, &amp;temp.Temp_H_Threshold, &amp;temp.Temp_L_Threshold);
</code></pre>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://blog.csdn.net/qq_45217381/article/details/131478473?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32%20esp8266&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-131478473.nonecase&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener nofollow">STM32外设系列—ESP8266（WIFI）_stm32 esp8266-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_56646002/article/details/131446836?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171176842316800215089577%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171176842316800215089577&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131446836-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=esp8266%E6%B5%8B%E8%AF%95&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener nofollow">esp8266学习记录_stm32+esp8266测试方法-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/jx5631833/article/details/126371579?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171176681016800197064086%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171176681016800197064086&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-126371579-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=stm32%20esp8266&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener nofollow">STM32-连接wifi模块(esp8266)_stm32wifi模块-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/jidudong0673/article/details/105219900" target="_blank" rel="noopener nofollow">ESP8266-01引脚说明与连接_esp01引脚定义-CSDN博客</a></p>
<p><a href="https://www.runoob.com/http/http-messages.html" target="_blank" rel="noopener nofollow">HTTP 消息结构 | 菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/C_huamao/article/details/108955730" target="_blank" rel="noopener nofollow">ESP8266——AT指令发送POST请求</a></p>
<p><a href="https://blog.csdn.net/whstudio123/article/details/106391099" target="_blank" rel="noopener nofollow">ESP8266使用AT指令发送GET方式HTTP请求</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04053177597685185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-04 11:34">2025-03-04 11:18</span>&nbsp;
<a href="https://www.cnblogs.com/penggeon">鹏展-penggeon</a>&nbsp;
阅读(<span id="post_view_count">27</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18750132" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18750132);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18750132', targetLink: 'https://www.cnblogs.com/penggeon/p/18750132', title: 'STM32实战——ESP8266 WIFI模块' })">举报</a>
</div>
        