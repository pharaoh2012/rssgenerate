
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18822171" title="发布于 2025-04-12 21:41">
    <span role="heading" aria-level="2">树状数组（Fenwick Tree）原理和优化全面解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>你正在开发一个交易系统，需要实时完成两种操作：</p>
<ol>
<li>更新某个时间点的价格（单点修改）</li>
<li>快速计算某段时间段内的交易总量（区间查询）</li>
</ol>
<p>当数据量较小时，我们可能会这样实现：</p>
<pre><code class="language-cpp">vector&lt;int&gt; prices(n);
// 单点更新 - O(1)
prices[index] += new_value; 
// 区间查询 - O(n)
int sum = accumulate(prices.begin() + l, prices.begin() + r + 1, 0);
</code></pre>
<p><strong>但当数据量达到百万级时</strong>，这样的操作会导致严重的性能瓶颈。尤其当系统要求每秒处理数万次操作时，传统的数组结构显然力不从心。</p>
<p>聪明的开发者可能会想到前缀和优化：</p>
<pre><code class="language-cpp">vector&lt;int&gt; prefix(n + 1);
// 构建前缀和 - O(n)
for(int i = 1; i &lt;= n; ++i) 
    prefix[i] = prefix[i-1] + prices[i-1];
// 区间查询 - O(1)
int sum = prefix[r+1] - prefix[l];
</code></pre>
<p>但新的问题随之而来——当某个<code>prices[i]</code>更新时，需要同步更新所有相关的<code>prefix[j]</code>（<code>j ≥ i+1</code>），这使得<strong>单点修改的复杂度退化为O(n)</strong>。查询和修改互相矛盾，在动态数据场景下尤为突出。</p>
<p>正如计算机科学家Donald Knuth所言："算法的本质，是通过组织数据来减少不必要的计算。<strong>树状数组（Fenwick Tree）</strong>正是在这样的需求背景下被Peter Fenwick于1994年提出。其精妙之处在于：</p>
<ol>
<li>通过<strong>二进制索引的位运算</strong>建立层级关系</li>
<li><strong>单点修改</strong>和<strong>区间查询</strong>都在亚线性时间内完成</li>
<li>不消耗额外空间</li>
</ol>
<h2 id="树状数组的智慧设计">树状数组的智慧设计</h2>
<p>原始数组的每个位置 <code>arr[i]</code> 存储的就是本下标的值，这使得区间查询必须遍历所有元素。为了高效求和，现在我们构建树状数组，赋予每个位置新的使命——让它存储一段特定区间的<strong>聚合信息</strong>（如区间和）。那么，如何确定 <code>tree[i]</code> 应该管理原数组的哪些位置？</p>
<p>惯例上，树状数组下标从 1 开始。为了让一个长区间被拆为对数段，我们让其<strong>最低有效位（LSB）</strong>决定它管理的范围<br>
<span class="math inline">\(\text{LSB(i)} = i \&amp; -i\)</span><br>
例如：<br>
<span class="math inline">\(6 = 110_2 \Rightarrow \text{LSB(6)} = 10_2 = 2_{10}\)</span><br>
<span class="math inline">\(8 = 1000_2 \Rightarrow \text{LSB(8)} = 1000_2 = 8_{10}\)</span></p>
<p><code>tree[i]</code> 管理原数组的区间 <span class="math inline">\([i - \text{LSB(i)} + 1,\ i]\)</span><br>
（即从去掉最低位的下一个数开始，到自身结束）</p>
<p>以 <span class="math inline">\(n=8\)</span> 为例的树状数组结构：</p>
<table>
<thead>
<tr>
<th>索引 <span class="math inline">\(i\)</span></th>
<th>二进制</th>
<th>管辖范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0001</td>
<td><span class="math inline">\([1,1]\)</span></td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td><span class="math inline">\([1,2]\)</span></td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td><span class="math inline">\([3,3]\)</span></td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td><span class="math inline">\([1,4]\)</span></td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td><span class="math inline">\([5,5]\)</span></td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td><span class="math inline">\([5,6]\)</span></td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td><span class="math inline">\([7,7]\)</span></td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td><span class="math inline">\([1,8]\)</span></td>
</tr>
</tbody>
</table>
<p>这个数组就叫做树状数组。有了这样一个数组，其前缀和 <span class="math inline">\(sum[1..k]\)</span> 的计算可分解为：</p>
<p></p><div class="math display">\[\text{sum}[1..k] = \text{tree}[k] + \text{tree}[k - \text{LSB}(k)] + \text{tree}[k - \text{LSB}(k) - \text{LSB}(k-\text{LSB}(k))] + \cdots
\]</div><p></p><p>例如计算 <span class="math inline">\(\text{sum}[1..7]\)</span>，它包括：</p>
<ol>
<li><span class="math inline">\(\text{tree}[7]\)</span> （管理 <span class="math inline">\([7,7]\)</span>）</li>
<li><span class="math inline">\(\text{tree}[7-1=6]\)</span> （管理 <span class="math inline">\([5,6]\)</span>）</li>
<li><span class="math inline">\(\text{tree}[6-2=4]\)</span> （管理 <span class="math inline">\([1,4]\)</span>）</li>
<li><span class="math inline">\(\text{tree}[4-4=0]\)</span> （终止）</li>
</ol>
<p><strong>操作次数</strong>恰好等于 <span class="math inline">\(k\)</span> 的二进制表示中 <code>1</code> 的位数，即 <span class="math inline">\(O(\log n)\)</span>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250412173902945-459935570.png" alt="image" loading="lazy"></p>
<h2 id="树状数组的核心操作">树状数组的核心操作</h2>
<p>我们将通过C++类实现来演示树状数组的三大核心操作：<strong>单点更新</strong>、<strong>前缀查询</strong>和<strong>区间查询</strong>。</p>
<pre><code class="language-cpp">class FenwickTree {
private:
    vector&lt;int&gt; tree;  // 树状数组存储
    int n;             // 元素数量

    // 计算最低有效位 (Least Significant Bit)
    int LSB(int x) { 
        return x &amp; -x;  // 利用补码特性
    }

public:
    // 构造函数：初始化大小为n+1（下标从1开始）
    FenwickTree(int size) : n(size), tree(size + 1) {}

    // 操作函数将在下文实现...
};
</code></pre>
<h4 id="单点更新point-add">单点更新（Point Add）</h4>
<p><strong>功能</strong>：在原数组的<code>index</code>位置增加<code>delta</code>值</p>
<p>要更新一个点，我们需要从他自己开始，更新所有包含该位置的<code>tree[i]</code>。通过不断向高位跳跃找到所有相关节点：</p>
<pre><code class="language-cpp">void pointAdd(int index, int delta) {
    // 从index开始向上更新父节点
    for(; index &lt;= n; index += LSB(index)) {
        tree[index] += delta;
    }
}
</code></pre>
<p><strong>操作流程</strong>（以更新<code>arr[3]</code>为例）：</p>
<ol>
<li>更新<code>tree[3]</code>（管理<code>[3,3]</code>）</li>
<li>跳转到<code>3 + LSB(3) = 4</code>，更新<code>tree[4]</code>（管理<code>[1,4]</code>）</li>
<li>跳转到<code>4 + LSB(4) = 8</code>，更新<code>tree[8]</code>（管理<code>[1,8]</code>）</li>
<li>直到超出<code>n</code>停止</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250412180105204-1356655261.png" alt="image" loading="lazy"></p>
<h4 id="前缀查询prefix-query">前缀查询（Prefix Query）</h4>
<p><strong>功能</strong>：查询原数组<code>[1..index]</code>的区间和</p>
<p>通过不断去掉最低位累加片段和：</p>
<pre><code class="language-cpp">int prefixQuery(int index) {
    int sum = 0;
    // 从index开始向下累加子区间
    for(; index &gt; 0; index -= LSB(index)) {
        sum += tree[index];
    }
    return sum;
}
</code></pre>
<p><strong>操作流程</strong>（查询<code>sum[1..7]</code>为例）：</p>
<ol>
<li>加<code>tree[7]</code>（<code>[7,7]</code>）</li>
<li>跳转到<code>7 - LSB(7) = 6</code>，加<code>tree[6]</code>（<code>[5,6]</code>）</li>
<li>跳转到<code>6 - LSB(6) = 4</code>，加<code>tree[4]</code>（<code>[1,4]</code>）</li>
<li>跳转到<code>4 - LSB(4) = 0</code>终止</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250412180159001-1310045903.png" alt="image" loading="lazy"></p>
<h4 id="区间查询range-query">区间查询（Range Query）</h4>
<p><strong>功能</strong>：查询原数组<code>[left, right]</code>的区间和</p>
<p>求两次前缀和差分即可。</p>
<pre><code class="language-cpp">int rangeQuery(int left, int right) {
    return prefixQuery(right) - prefixQuery(left - 1);
}
</code></pre>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>循环次数（最坏情况）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pointAdd</code></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(\lfloor \log_2 n \rfloor + 1\)</span></td>
</tr>
<tr>
<td><code>prefixQuery</code></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(\lfloor \log_2 n \rfloor + 1\)</span></td>
</tr>
<tr>
<td><code>rangeQuery</code></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(2(\lfloor \log_2 n \rfloor + 1)\)</span></td>
</tr>
</tbody>
</table>
<p>惯例上，树状数组下标从 1 开始。保持1-based索引可避免死循环（<code>index=0</code>时循环终止）</p>
<h4 id="快速建树">快速建树</h4>
<p>将树状数组全部初始化成 0，然后对原数组的值挨个插入，可以完成初始化。</p>
<pre><code class="language-cpp">// 通过n次pointAdd操作建树
FenwickTree(int size, const vector&lt;int&gt;&amp; nums) : n(size), tree(size + 1) {
    for(int i = 1; i &lt;= n; ++i) {
        pointAdd(i, nums[i-1]); // 每次O(log n)
    }
}
</code></pre>
<p>但是还有更高效的方法。利用每个节点的子节点已经计算的结果，对于节点 <span class="math inline">\(i\)</span>：</p>
<ol>
<li>累加原数组 <span class="math inline">\(\text{arr}[i]\)</span></li>
<li>累加所有比 <span class="math inline">\(i\)</span> 小且 <span class="math inline">\(j + \text{LSB}(j) = i\)</span> 的 <span class="math inline">\(\text{tree}[j]\)</span></li>
</ol>
<pre><code class="language-cpp">FenwickTree(int size, const vector&lt;int&gt;&amp; nums) : n(size), tree(size + 1) {
    // 第一步：直接拷贝原数组
    for(int i = 1; i &lt;= n; ++i) {
        tree[i] = nums[i-1];
    }
    
    // 第二步：递推更新父节点
    for(int i = 1; i &lt;= n; ++i) {
        int j = i + LSB(i);  // 找到直接父节点
        if(j &lt;= n) {
            tree[j] += tree[i];  // 将当前节点的值贡献给父节点
        }
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250412182332484-808815775.png" alt="image" loading="lazy"></p>
<p><strong>建树过程示例</strong>（以数组<code>[1,3,5,7,9,11]</code>为例）：</p>
<ol>
<li>初始状态：<code>tree = [0,1,3,5,7,9,11]</code></li>
<li>处理<code>i=1</code>：<code>j=1+1=2</code> → <code>tree[2] += 1</code> → <code>tree[2]=4</code></li>
<li>处理<code>i=2</code>：<code>j=2+2=4</code> → <code>tree[4] += 4</code> → <code>tree[4]=11</code></li>
<li>处理<code>i=3</code>：<code>j=3+1=4</code> → <code>tree[4] += 5</code> → <code>tree[4]=16</code></li>
<li>处理<code>i=4</code>：<code>j=4+4=8</code>（超出范围跳过）</li>
<li>处理<code>i=5</code>：<code>j=5+1=6</code> → <code>tree[6] += 9</code> → <code>tree[6]=20</code></li>
<li>最终树状数组：<code>[0,1,4,5,16,9,20]</code></li>
</ol>
<table>
<thead>
<tr>
<th>建树方法</th>
<th>时间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>单点插入法</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td>通用但较慢</td>
</tr>
<tr>
<td>递推法</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>已知原数组时最优</td>
</tr>
</tbody>
</table>
<h2 id="树状数组实现区间修改">树状数组实现区间修改</h2>
<p>树状数组支持快速的单点修改和区间查询。而通过维护原数组的差分数组的树状数组，可以反过来实现区间修改（修改两个点）和单点查询（查询一个和）。而如果同时区间修改和区间维护呢？这就需要巧妙的数学构思。</p>
<p>通过维护两个树状数组 <span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span>，实现区间操作：</p>
<ul>
<li><strong>区间加</strong>：在<span class="math inline">\([l, r]\)</span>上统一加<span class="math inline">\(\Delta\)</span></li>
<li><strong>区间和</strong>：查询<span class="math inline">\([l, r]\)</span>的和</li>
</ul>
<p><strong>数学推导</strong>：</p>
<ol>
<li>定义差分数组 <span class="math inline">\(d[i] = \text{arr}[i] - \text{arr}[i-1]\)</span></li>
<li>前缀和可表示为：<p></p><div class="math display">\[\sum_{i=1}^k \text{arr}[i] = \sum_{i=1}^k \sum_{j=1}^i d[j] = \sum_{i=1}^k (k-i+1)d[i]
\]</div><p></p></li>
<li>展开得到：<p></p><div class="math display">\[(k+1)\sum_{i=1}^k d[i] - \sum_{i=1}^k i \cdot d[i]
\]</div><p></p></li>
</ol>
<p>所以说，我们要维护两个树状数组，一个表示的是 <span class="math inline">\(d_i\)</span>，一个是<span class="math inline">\(i \cdot d_i\)</span>。进行区间修改时，对两个数组分别进行两次单点修改；进行区间查询时，分别查询并用上文式子相加。</p>
<pre><code class="language-cpp">class RangeFenwick {
private:
    FenwickTree B1, B2; // 两个基础树状数组
    
    void rangeAddRaw(int l, int r, int delta) {
        B1.pointAdd(l, delta);
        B1.pointAdd(r+1, -delta);
        B2.pointAdd(l, l*delta);
        B2.pointAdd(r+1, -(r+1)*delta);
    }
    
public:
    RangeFenwick(int n) : B1(n), B2(n) {}
    
    // 区间[l,r]增加delta
    void rangeAdd(int l, int r, int delta) {
        rangeAddRaw(l, r, delta);
    }
    
    // 查询前缀和[1..k]
    int prefixQuery(int k) {
        return (k+1)*B1.prefixQuery(k) - B2.prefixQuery(k);
    }
    
    // 查询区间和[l..r]
    int rangeQuery(int l, int r) {
        return prefixQuery(r) - prefixQuery(l-1);
    }
};
</code></pre>
<h4 id="终极思考题">终极思考题</h4>
<p>如何设计支持以下操作的树状数组？</p>
<ul>
<li>区间加</li>
<li>区间乘</li>
<li>区间求和</li>
</ul>
<p>（提示：维护三个树状数组分别存储<span class="math inline">\(\Delta\)</span>、<span class="math inline">\(i\Delta\)</span>和<span class="math inline">\(i^2\Delta\)</span>）</p>
<h2 id="树状数组处理最值">树状数组处理最值</h2>
<p>求区间和时，我们直接求两次前缀和并相减，但对于最大值/最小值这类信息：</p>
<ul>
<li><strong>不满足可减性</strong>：<span class="math inline">\(\max\{l..r\} \neq \max\{1..r\} - \max\{1..(l-1)\}\)</span></li>
</ul>
<p>因此，我们需要手动分解目标区间，并统计答案。</p>
<pre><code class="language-cpp">class FenwickMax {
private:
    vector&lt;int&gt; tree;
    vector&lt;int&gt; origin; // 保存原始值，修改时也要一同修改
    int n;
    
    void update(int i, int val) {
        origin[i] = val;
        for(; i &lt;= n; i += LSB(i)) {
            tree[i] = val;
            for(int j = 1; j &lt; LSB(i); j &lt;&lt;= 1) {
                tree[i] = max(tree[i], tree[i-j]);
            }
        }
    }
    
public:
    FenwickMax(const vector&lt;int&gt;&amp; nums) : n(nums.size()), 
                                        tree(n+1, INT_MIN),
                                        origin(n+1) {
        for(int i = 1; i &lt;= n; ++i) {
            update(i, nums[i-1]);
        }
    }
    
    int rangeMax(int l, int r) {
        int res = INT_MIN;
        while(r &gt;= l) {
            // Case 1：当前区间完全在查询范围内
            if(r - LSB(r) + 1 &gt;= l) {
                res = max(res, tree[r]);
                r -= LSB(r); // 移动到前一个区间
            } 
            // Case 2：需要单点检查
            else {
                res = max(res, origin[r]);
                --r; // 退一位继续检查
            }
        }
        return res;
    }
};
</code></pre>
<p>以查询<span class="math inline">\(max[5..14]\)</span>为例：</p>
<ol>
<li>从右端点14向左查询：
<ul>
<li>取<span class="math inline">\(tree[14]\)</span>（管理<span class="math inline">\([13..14]\)</span>）</li>
<li>剩余查询<span class="math inline">\([5..12]\)</span></li>
</ul>
</li>
<li>处理<span class="math inline">\([5..12]\)</span>：
<ul>
<li>取<span class="math inline">\(tree[12]\)</span>（管理<span class="math inline">\([9..12]\)</span>）</li>
<li>剩余查询<span class="math inline">\([5..8]\)</span></li>
</ul>
</li>
<li>处理<span class="math inline">\([5..8]\)</span>：
<ul>
<li>取<span class="math inline">\(tree[8]\)</span>（管理<span class="math inline">\([1..8]\)</span>）→ <strong>超出左边界</strong></li>
<li>必须改为单点检查<span class="math inline">\(arr[8]\)</span></li>
<li>剩余查询<span class="math inline">\([5..7]\)</span></li>
</ul>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250412211144904-1639574980.png" alt="image" loading="lazy"></p>
<p><strong>复杂度证明</strong>：</p>
<ul>
<li><strong>最佳情况</strong>：当 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 正好是某个 <span class="math inline">\(tree[i]\)</span> 的边界时，仅需 <span class="math inline">\(\log n\)</span> 步</li>
<li><strong>最差情况</strong>：需要交替执行 Case1 和 Case2 约 <span class="math inline">\(2\log n\)</span> 次。每层需要处理 <span class="math inline">\(\log n\)</span> 个碎片区间，每个区间需要<span class="math inline">\(\log n\)</span>时间检查 → <span class="math inline">\(O(\log^2 n)\)</span></li>
</ul>
<h2 id="二维树状数组">二维树状数组</h2>
<p>这里简要介绍树状数组如何从维护数组改造为维护矩阵。在二维情景下，每个节点 <code>tree[x][y]</code> 管理原数组中从 <code>(x - LSB(x) + 1, y - LSB(y) + 1)</code> 到 <code>(x, y)</code> 的子矩阵</p>
<h4 id="单点更新point-add-1">单点更新（Point Add）</h4>
<pre><code class="language-cpp">void pointAdd(int x, int y, int delta) {
    for(int i = x; i &lt;= n; i += LSB(i))
        for(int j = y; j &lt;= m; j += LSB(j))
            tree[i][j] += delta;
}
</code></pre>
<p>更新所有包含 <code>(x,y)</code> 的矩形区域。例如更新 <code>(3,3)</code> 会影响：</p>
<ul>
<li><code>tree[3][3]</code>（管理<code>[3,3]×[3,3]</code>）</li>
<li><code>tree[3][4]</code>（管理<code>[3,3]×[3,4]</code>）</li>
<li><code>tree[4][3]</code>（管理<code>[3,4]×[3,3]</code>）</li>
<li><code>tree[4][4]</code>（管理<code>[3,4]×[3,4]</code>）</li>
</ul>
<h4 id="前缀查询prefix-query-1">前缀查询（Prefix Query）</h4>
<pre><code class="language-cpp">int prefixQuery(int x, int y) {
    int sum = 0;
    for(int i = x; i &gt; 0; i -= LSB(i))
        for(int j = y; j &gt; 0; j -= LSB(j))
            sum += tree[i][j];
    return sum;
}
</code></pre>
<p>通过二维前缀和分解：</p>
<p></p><div class="math display">\[∑_{i=1}^x ∑_{j=1}^y arr[i][j] = 
  tree[x][y] 
+ tree[x - LSB(x)][y] 
+ tree[x][y - LSB(y)] 
- tree[x - LSB(x)][y - LSB(y)]
\]</div><p></p><h4 id="区间查询range-query-1">区间查询（Range Query）</h4>
<pre><code class="language-cpp">int rangeQuery(int x1, int y1, int x2, int y2) {
    return prefixQuery(x2,y2) 
         - prefixQuery(x1-1,y2) 
         - prefixQuery(x2,y1-1) 
         + prefixQuery(x1-1,y1-1);
}
</code></pre>
<p>通过四个前缀矩形的加减实现任意矩形区域求和（类比二维前缀和容斥）</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>循环次数（最坏）</th>
</tr>
</thead>
<tbody>
<tr>
<td>单点更新</td>
<td><span class="math inline">\(O(\log^2 n)\)</span></td>
<td><span class="math inline">\(\log^2 n\)</span></td>
</tr>
<tr>
<td>区间查询</td>
<td><span class="math inline">\(O(\log^2 n)\)</span></td>
<td><span class="math inline">\(4\log^2 n\)</span></td>
</tr>
</tbody>
</table>
<h2 id="树状数组-vs-线段树">树状数组 vs 线段树</h2>
<p>树状数组和线段树可以解决类似的问题。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>树状数组</th>
<th>线段树</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码复杂度</td>
<td>15-20行核心代码</td>
<td>50+行实现</td>
</tr>
<tr>
<td>区间修改支持</td>
<td>需改造（双树状数组）</td>
<td>原生支持</td>
</tr>
<tr>
<td>空间消耗</td>
<td><span class="math inline">\(O(n)\)</span>，无额外空间消耗</td>
<td><span class="math inline">\(O(n)\)</span>，需要约 4 倍空间</td>
</tr>
<tr>
<td>时间消耗</td>
<td>常数更小的 <span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
<tr>
<td>不可差分信息</td>
<td>受限</td>
<td>完全支持</td>
</tr>
<tr>
<td>高维扩展</td>
<td>简单（嵌套结构）</td>
<td>复杂（四分树等）</td>
</tr>
<tr>
<td>动态开点</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6288349829594907" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-12 21:41">2025-04-12 21:41</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">41</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18822171);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18822171', targetLink: 'https://www.cnblogs.com/ofnoname/p/18822171', title: '树状数组（Fenwick Tree）原理和优化全面解析' })">举报</a>
</div>
        