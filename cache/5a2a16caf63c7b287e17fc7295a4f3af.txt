
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18676634" title="发布于 2025-01-25 10:16">
    <span role="heading" aria-level="2">.NET Core GC压缩(compact_phase)底层原理浅谈</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>终于来到了GC的最后一个步骤，在此之间，大量预备工作已经完成。<code>万事俱备，只欠东风</code></p>
<h1 id="清除">清除</h1>
<p>如果GC决定不压缩，它将仅执行清除操作。清除操作非常简单，把所有不可到达对象(gap)，转换成Free。也就是转换成空闲内存空间。<br>
由于所有的繁重计算任务在plan_phase阶段均已完成，所以步骤比较简单</p>
<ol>
<li>
<p>基于gap的size创建空闲列表<br>
free &gt; 2 * min_obj_size 的Free块会被放入空闲列表，小于此大小的不再被利用，但会纳入内存碎片统计</p>
</li>
<li>
<p>恢复“被销毁”的前置plug和plug<br>
这是pinned 对象的特殊情况，pinned的plug前面可能还是一个plug,所以没有gap来存放， 因此会根据实际情况“钉住”它的前面或者后面的Plug.来暂存gap_reloc_pair信息。 所以用完后还要“还回去”</p>
</li>
<li>
<p>更新终结队列，并提升或降低plug的代</p>
</li>
<li>
<p>更新段空间</p>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117142819489-2028699155.png" alt="image" loading="lazy"></p>
<h2 id="眼见为实">眼见为实</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117141112396-1931178778.png" alt="image" loading="lazy"></p>
<h1 id="压缩">压缩</h1>
<p>如果GC决定压缩，就比较复杂了。总体分为两步</p>
<ol>
<li>复制对象并移动到新位置(重定位阶段)</li>
<li>将新对象的地址在root上更新</li>
</ol>
<h2 id="gc重定位阶段">GC重定位阶段</h2>
<p>此步骤更新所有对稍后要移动对象的引用，为了更新这些地址，要扫描他们的root，并逐一更新</p>
<ol>
<li>栈空间的root</li>
<li>跨代记忆集的root</li>
<li>托管堆中的root</li>
<li>前置plug与后置Plug的root</li>
<li>终结器队列的root</li>
<li>句柄表的root</li>
</ol>
<p>比如某个对象的内存地址为0x1000,压缩后它的新地址为0x500。那就就要对该对象的所有root更新内存地址。</p>
<h3 id="眼见为实-1">眼见为实</h3>
<details>
<summary>点击查看代码</summary>
<pre><code>    internal class Program
    {
        static void Main(string[] args)
        {
            Append();
            AppendStatic();
            Compact();
        }

        public static Person person;
        public static List&lt;byte[]&gt; list = new List&lt;byte[]&gt;();

        static void Append()
        {
            //填 10M 数组到 临时段上
            for (int i = 0; i &lt; 1024 * 10; i++)
            {
                list.Add(new byte[1000]);
            }

            Console.WriteLine("1. 10M 数据已分配完毕，请查看临时段大小，准备分配 Person 对象!");
            Debugger.Break();
        }

        static void AppendStatic()
        {
            person = new Person();
            list = null;

            Console.WriteLine("2. Person 已分配，list已去根，请再次观察托管堆！准备触发 GC，请下 compact_phase 断点！");
            Debugger.Break();
        }

        static void Compact()
        {
            GC.Collect(2, GCCollectionMode.Forced, true, true);
            Console.WriteLine("3. GC 已触发，请观察 Person 是否已变！");
            Debugger.Break();
        }
    }

    public class Person { }
</code></pre>
</details>
<p>在bp coreclr!WKS::gc_heap::compact_phase 下断点，观察对象的新老地址变化<br>
GC前：<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117144913887-151107206.png" alt="image" loading="lazy"><br>
GC后：内存地址发生变化<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117145501318-1012205625.png" alt="image" loading="lazy"></p>
<h3 id="眼见为实-2">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250125100556508-1361156282.png" alt="image" loading="lazy"></p>
<h2 id="压缩对象">压缩对象</h2>
<p>在上面更新root的操作完成后,GC要移动所有对象。由以下几个步骤组成</p>
<ol>
<li>复制对象</li>
<li>恢复“被销毁”的前置plug和plug</li>
<li>重新划分代边界</li>
<li>释放内存段</li>
<li>创建空闲列表</li>
</ol>
<h3 id="眼见为实-3">眼见为实</h3>
<p>GC前:<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117150705658-266865400.png" alt="image" loading="lazy"></p>
<p>GC后：对象被移动，原有地址被压缩释放<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250117150759815-206756899.png" alt="image" loading="lazy"></p>
<h3 id="眼见为实复制连续的内存区域">眼见为实:复制连续的内存区域</h3>
<p>以滑动的方式来copy内存，避免出现覆盖问题<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202501/1084317-20250125101235738-182727241.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.014902034637731482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-25 10:17">2025-01-25 10:16</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18676634" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18676634);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18676634', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18676634', title: '.NET Core GC压缩(compact_phase)底层原理浅谈' })">举报</a>

		</p>
	