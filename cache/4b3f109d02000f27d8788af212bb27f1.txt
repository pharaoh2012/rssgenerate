
<table cellspacing="0" cellpadding="0"><tbody><tr><td class="t_f" id="postmessage_52603137">
<i class="pstatus"> 本帖最后由 tracese 于 2025-3-16 16:40 编辑 </i><br>
<br>
传输层，包括 TCP、UDP 和 SCTP（Stream Control Transmission Protocol，流控制传输协议）。UDP 是一个简单的、不可靠的数据报协议，而 TCP 是一个复杂、可靠的字节流协议。SCTP 与 TCP 类似之处在于它也是一个可靠的传输协议，但它还提供消息边界、传输级别多宿（multihoming）支持以及将头端阻塞（head-of-line blocking）减少到最小的一种方法。<br>
<strong>TCP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
传输控制协议（Transmission Control Protocol）。TCP 是一个面向连接的协议，为用户进程提供可靠的全双工字节流。TCP 套接字是一种流套接字（stream socket）。TCP 关心确认、超时和重传之类的细节。</font><br>
<strong>UDP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
用户数据报协议（User Datagram Protocol）。UDP 是一个无连接协议。UDP 套接字是一种数据报套接字（datagram socket）。UDP 数据报不能保证最终到达它们的目的地。</font><br>
<strong>SCTP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
流控制传输协议（Stream Control Transmission Protocol）。SCTP 是一个提供可靠全双工关联的面向连接的协议。我们使用“关联”一词来指称 SCTP 中的连接，因为 SCTP 是多宿的，从而每个关联的两端均涉及一组 IP 地址和一个端口号。SCTP 提供消息服务，也就是维护来自应用层的记录边界。</font><br>
<strong>ICMP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
网际控制消息协议（Internet Control Message Protocol）。ICMP 处理在路由器和主机之间流通的错误和控制信息。</font><br>
<strong>IGMP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
网际组管理协议（Internet Group Management Protocol）。IGMP 用于多播。</font><br>
<strong>ARP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
地址解析协议（Address Resolution Protocol）。ARP 把一个 IPv4 地址映射成一个硬件地址。</font><br>
<strong>RARP</strong><font style="background-color:rgba(192, 221, 252, 0.5)"><br>
反向地址解析协议（Reverse Address Resolution Protocol）。RARP 把一个硬件地址映射成一个IPv4地址。</font><br>
<br>
<strong>用户数据报协议 UDP</strong><br>
应用进程往一个 UDP 套接字写入一个消息，该消息随后被封装到一个 UDP 数据报，该 UDP 数据报进而又被封装到一个 IP 数据报，然后发送到目的地。UDP 不保证 UDP 数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。<br>
<u>问题：缺乏可靠性。如果一个数据报到达了其最终目的地，但是校验和检测发现有错误，或者该数据报在网络传输途中被丢弃了，它就无法被投递给 UDP 套接字，也不会被源端自动重传。</u><br>
解决：如果想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆的特性：来自对端的确认、本端的超时与重传等。<br>
每个 UDP 数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。TCP 是一个字节流协议，没有任何记录边界，这一点不同于 UDP。<br>
UDP 提供无连接的（connectionless）服务，因为 UDP 客户与服务器之间不必存在任何长期的关系。<br>
一个 UDP 客户可以创建一个套接字并发送一个数据报给一个给定的服务器，然后立即用同一个套接字发送另一个数据报给另一个服务器。同样地，一个 UDP 服务器可以用同一个 UDP 套接字从若干个不同的客户接收数据报，每个客户一个数据报。<br>
<br>
<strong>传输控制协议 TCP</strong><br>
首先， TCP 提供客户与服务器之间的连接（connection）。TCP 客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。<br>
其次，TCP 还提供了可靠性（reliability）。当 TCP 向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP 就自动重传数据并等待更长时间。在数次重传失败后，TCP 才放弃。<br>
<u>注意，TCP并不保证数据一定会被对方端点接收，因为这是不可能做到的。如果有可能，TCP就把数据递送到对方端点，否则就(通过放弃重传并中断连接这一手段)通知用户。这么说来，TCP也不能被描述成是100%可靠的协议，它提供的是数据的可靠递送或故障的可靠通知。</u><br>
TCP 含有应用于动态估算客户和服务器之间的往返时间（round-trip time，RTT）的算法，以便它知道等待一个确认需要多少时间。另外，因为 RTT 受网络流通各种变化因素影响，TCP 还持续估算一个给定连接的 RTT。TCP 通过给其中每个字节关联一个序列号对所发送的数据进行排序（sequencing）。如果接收端 TCP 收到来自端的重复数据，它可以根据序列号判定数据是重复的，从而丢弃重复数据。<br>
UDP 不提供可靠性。UDP 本身不提供确认、序列号、RTT 估算、超时和重传机制。<br>
<br>
<br>
<strong>TCP 的三次握手</strong><ul type="1" class="litype_1"><li>服务器必须准备好接受外来的连接。这通常通过调用 socket、bind 和 listen 这 3 个函数来完成，我们称之为被动打开（passive open）。</li><li>客户通过调用 connect 发起主动打开（active open）。这导致客户 TCP 发送一个 SYN（同步）分节，它告诉服务器客户将在连接中发送的数据的初始序列号。通常 SYN 分节不携带数据，其所在 IP 数据报只含有一个 IP 首部、一个 TCP 首部及可能有的 TCP 选项。</li><li>服务器必须确认（ACK）客户的 SYN，同时自己也得发送一个 SYN 分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送 SYN 和对客户 SYN 的 ACK（确认）。</li><li>客户必须确认服务器的 SYN。<br>
</li></ul><img id="aimg_JW5hD" onclick="zoom(this, this.src, 0, 0, 0)" class="zoom" file="https://gitee.com/Trace001/blog-img/raw/master/img/image.png" onmouseover="img_onmouseoverfunc(this)" lazyloadthumb="1" border="0" alt="" src="https://gitee.com/Trace001/blog-img/raw/master/img/image.png"><br>
客户的初始序列号为 J，服务器的初始序列号为 K。ACK 中的确认号是发送这个 ACK 的一端所期待的下一个序列号。因为 SYN 占据一个字节的序列号空间，所以每一个 SYN 的 ACK 中的确认号就是该 SYN 的初始序列号加 1。类似地，每一个 FIN 的 ACK 中的确认号为该 FIN 的序列号加 1。<br>
<br>
<strong>TCP 和 UDP 有哪些区别</strong><ul type="1" class="litype_1"><li><strong>是否面向连接：</strong><font style="font-size:14px">TCP 是</font><strong>面向连接的运输层协议</strong><font style="font-size:14px">，</font><font style="color:rgb(60, 60, 67)"><font style="font-size:16px">在传送数据之前必须先建立连接，数据传送结束后要释放连接。UDP 是</font></font><strong><font color="#3c3c43"><font style="font-size:16px">无连接的</font></font></strong><font style="color:rgb(60, 60, 67)"><font style="font-size:16px">，即在传送数据之前不需要先建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。</font></font></li><li><strong>是否是可靠传输</strong>：TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达。UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。</li><li><strong>是否有状态：</strong><font color="#333333"><font style="font-size:16px">TCP 需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP 不维护连接状态，也不跟踪这些参数。</font></font></li><li><strong>传输形式：</strong><font color="#333333"><font style="font-size:16px">TCP 向应用进程提供可靠的、按顺序的</font></font><strong><font color="#333333"><font style="font-size:16px">字节流服务，</font></font></strong><font color="#333333"><font style="font-size:16px">但是它不提供报文的界限，由应用进程自己维护。</font></font><font color="#3c3c43"><font style="font-size:16px">UDP 是</font></font><strong><font color="#3c3c43"><font style="font-size:16px">面向报文</font></font></strong><font color="#3c3c43"><font style="font-size:16px">的，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后就向下交付 IP 层。</font></font></li><li><strong><font color="#3c3c43"><font style="font-size:16px">分片不同：</font></font></strong>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li><li><strong>首部开销：</strong>TCP 首部一般是 20 个字节，如果使用了「选项」字段则会变长。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li><strong>服务对象</strong>：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li><strong>拥塞控制、流量控制</strong>：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。<br>
</li></ul><font style="background-color:rgba(217, 201, 248, 0.5)"><br>
</font><br>
<font style="background-color:rgba(217, 201, 248, 0.5)">内容来源：《UNIX网络编程 卷1：套接字联网API（第3版） 卷1：套接字联网API》</font></td></tr></tbody></table>


