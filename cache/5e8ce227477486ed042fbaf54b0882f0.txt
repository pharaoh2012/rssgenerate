
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/guoxiaoyu/p/18642488" title="发布于 2025-01-02 09:23">
    <span role="heading" aria-level="2">gRPC编译与字段编号的细节探讨</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上次我们专门通过一个简单的HelloWorld示例来了解了gRPC的基本概念和使用方法。今天，我们将继续深入探讨gRPC，重点讨论一些在实际应用中需要特别注意的要点。实际上，gRPC的核心目标是简化远程调用的过程，它通过定义清晰的接口，利用Protocol Buffers（简称proto协议）来生成不同编程语言的接口代码，从而实现跨语言、高效的通信。</p>
<p>在回顾了gRPC的基本工作原理之后，我们今天将进一步扩展视野，继续探讨一些更细节的部分。</p>
<h1 id="grpc">gRPC</h1>
<h2 id="是否会覆盖">是否会覆盖</h2>
<p>今天，我特别添加了一个新的测试接口，目的是测试在进行重新编译时，系统是否会丢失之前定义的接口和相关业务逻辑。为了简化说明，实体类部分就不再重新编写了，它与之前定义的内容完全一致。具体细节请见下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212432039-951733750.png" alt="image" loading="lazy"></p>
<p>在我重新进行编译后，我发现除了这个特定的类需要单独手动编写之外，其他的内容都已经自动生成完毕。这意味着，我们不需要担心会因编译过程而导致已有内容被直接覆盖掉。</p>
<p>实际上，Maven 工具本身也可以配置，以控制在执行时是否删除目录中的某些内容并重新生成。虽然这里不作详细讨论，但从正常业务操作的角度来看，我们通常都不希望自己辛苦编写的代码在没有任何警告的情况下，因他人的误操作或一键执行而被完全删除。</p>
<p><img src="https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212437106-515669221.png" alt="image" loading="lazy"></p>
<h2 id="字段编号有何用">字段编号有何用</h2>
<p>在我们讨论实体类消息体中为何会出现数字时，首先要明确的是，虽然我们在定义字段时已经给它们起了具体的名字，但这远不够。特别是在使用 gRPC 进行服务通信时，你需要从传统的 JSON 格式（键值对结构）中跳脱出来，重新理解字段的表示方式。</p>
<p>在 gRPC 中，数据是通过 Protocol Buffers（Protobuf） 进行序列化和传输的，而 Protobuf 的一个关键概念就是 字段编号（Field Numbers）。如图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212442491-726950642.png" alt="image" loading="lazy"></p>
<p>其实作用最主要的就是序列化和反序列化，当 Protobuf 序列化消息时，它并不直接存储字段名（如 name、age 等），而是存储字段编号和字段值的对应关系。这样，这使得数据传输时比使用 JSON 或 XML 更加紧凑。</p>
<p>我们简单看下后台输出的日志，你大概就能理解了，如图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212446386-893934506.png" alt="image" loading="lazy"></p>
<p>我们把这些字节全拿出来看下。比如：</p>
<ol>
<li><strong>00 00 00 00</strong>：这些是四个字节，通常是用来表示某个字段的填充数据，可能是某种标识符、长度或者预留字节。</li>
<li><strong>07</strong>：这个字节通常表示某种数据的长度或其他编码标识。</li>
<li><strong>0a</strong>：这个字节也有可能是长度或某种控制符号。</li>
<li><strong>05</strong>：又是一个字节，通常也表示控制信息。</li>
<li><strong>57 6f 72 6c 64</strong>：这些字节代表的是ASCII编码字符。它们对应的字符为：
<ul>
<li><code>57</code> → 'W'</li>
<li><code>6f</code> → 'o'</li>
<li><code>72</code> → 'r'</li>
<li><code>6c</code> → 'l'</li>
<li><code>64</code> → 'd'</li>
</ul>
</li>
</ol>
<p>因此，<code>57 6f 72 6c 64</code> 对应的字符串是 "World"。</p>
<p>同理，我们看下返回的数据也是一样的字节。然后反序列化成我们所需要的字段值，具体的我们就不探讨了。了解下他的优点即可。</p>
<p>这串字节 <code>00000000150a137869616f79753a2048656c6c6f20576f726c64</code> 可以被解释为：</p>
<ul>
<li>一些前导字节（如 <code>00 00 00 00</code> 和 <code>15 0a 13</code>）可能是标识符、长度字段或者控制信息。</li>
<li>后面部分解码成了字符串 <code>"xiaoyu: Hello World"</code></li>
</ul>
<p>还有一个需要注意的就是，既然他有字段编号，所以你不要轻易去修改编号，就算不用了，也要去用新的编号进行标识处理。这是因为如果有老客户端仍在继续使用，会导致无法正确解析新版消息，会出现兼容性错误。</p>
<h1 id="总结">总结</h1>
<p>通过今天的探讨，我们进一步加深了对gRPC和Protocol Buffers的理解，特别是在实际应用中可能遇到的一些细节和注意事项。我们了解了在重新编译时，系统如何自动生成接口代码并避免覆盖已有内容，从而减少了手动操作的风险。同时，深入探讨了Protocol Buffers中的字段编号机制，它不仅有助于数据的高效序列化和传输，也在版本兼容性上起到了至关重要的作用。尽管字段名称对开发者来说更具可读性，但最终传输的数据依赖于字段编号，而对编号的管理和修改必须小心谨慎，以确保不同版本之间的兼容性。</p>
<p>希望通过今天的讲解，大家能更好地理解gRPC的应用场景和实际操作中的细节。</p>
<hr>
<p>我是努力的小雨，一名 Java 服务端码农，潜心研究着 AI 技术的奥秘。我热爱技术交流与分享，对开源社区充满热情。同时也是一位腾讯云创作之星、阿里云专家博主、华为云云享专家、掘金优秀作者。</p>
<p>💡 我将不吝分享我在技术道路上的个人探索与经验，希望能为你的学习与成长带来一些启发与帮助。</p>
<p>🌟 欢迎关注努力的小雨！🌟</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05618087748726852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-02 09:24">2025-01-02 09:23</span>&nbsp;
<a href="https://www.cnblogs.com/guoxiaoyu">努力的小雨</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18642488" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18642488);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18642488', targetLink: 'https://www.cnblogs.com/guoxiaoyu/p/18642488', title: 'gRPC编译与字段编号的细节探讨' })">举报</a>
</div>
	