
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/LearnerPing/p/18987402" title="发布于 2025-07-16 14:17">
    <span role="heading" aria-level="2">JsonConvert反序列化枚举转换</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="适用场景反序列化对象里面存在枚举类型">适用场景：反序列化对象里面存在枚举类型</h1>
<h2 id="说明">说明</h2>
<p>在使用JsonConvert.DeserializeObject<t>转换对象的时候，想要更直观的看到值对应的含义，一般会设定一个枚举值，但是在转换的时候，由于传入值的不确定，会无法识别枚举具体类型而报错，需要我们手动拓展</t></p>
<h2 id="实现">实现</h2>
<p>实现方式主要是通过继承JsonConverter，在转换的过程中添加对输入值，以及输出对象的格式进行校验，确保能安全准确的处理枚举类型<br>
核心代码：</p>
<pre><code>    public class SafeEnumConverter&lt;T&gt; : JsonConverter where T : struct
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(T);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.String)
            {
                var enumText = reader.Value.ToString();
                if (string.IsNullOrEmpty(enumText))
                    return default(T);

                // 先尝试数字
                int intValue;
                if (int.TryParse(enumText, out intValue))
                    return (T)Enum.ToObject(typeof(T), intValue);

                // 再尝试枚举名
                T value;
                if (Enum.TryParse&lt;T&gt;(enumText, true, out value))
                    return value;
            }
            else if (reader.TokenType == JsonToken.Integer)
            {
                return (T)Enum.ToObject(typeof(T), Convert.ToInt32(reader.Value));
            }
            return default(T);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(Convert.ToInt32(value));
        }
    }
</code></pre>
<ol>
<li>通过重写CanConvert，判断当前转换器是否能处理类型 T，只针对类型T进行转换</li>
<li>ReadJson是转换的核心，实现将 JSON 字符串或数字安全地转换为枚举类型 T。<br>
- 如果 JSON 是字符串（如 "1" 或 "EnumName"）：<br>
先尝试转成数字（如 "1" → 1 → 枚举值）。<br>
再尝试转成枚举名（如 "EnumName" → 枚举值）。<br>
- 如果 JSON 是数字（如 1）：<br>
直接转成枚举值。<br>
- 如果都不行，返回默认值（通常是0）。</li>
<li>WriteJson：结果输出，将枚举值序列化为数字（int），而不是字符串。</li>
</ol>
<h2 id="使用方法">使用方法</h2>
<p>在需要的枚举属性上加特性，或全局注册：</p>
<pre><code>[JsonConverter(typeof(SafeEnumConverter&lt;MyEnum&gt;))]
public MyEnum Status { get; set; }
</code></pre>
<p>或者</p>
<pre><code>JsonConvert.DeserializeObject&lt;T&gt;(json, new SafeEnumConverter&lt;MyEnum&gt;());
</code></pre>
<p>能兼容数字、字符串等多种Json输入的转换</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-16 14:18">2025-07-16 14:17</span>&nbsp;
<a href="https://www.cnblogs.com/LearnerPing">LearnerPing</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18987402);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18987402', targetLink: 'https://www.cnblogs.com/LearnerPing/p/18987402', title: 'JsonConvert反序列化枚举转换' })">举报</a>
</div>
        