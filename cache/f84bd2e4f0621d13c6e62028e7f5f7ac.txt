
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/forges/p/18737973" title="发布于 2025-02-26 10:45">
    <span role="heading" aria-level="2">在 .NET Core 中实现缓存端模式：使用 Redis 提升性能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>&nbsp;</h3>
<p>在现代的 Web 应用中，缓存是提升应用性能的关键组件。尤其是当应用频繁读取数据时，使用缓存可以显著减少数据库的负担并提高响应速度。缓存端模式（Cache-Aside Pattern）是一种常用的缓存策略，它可以帮助我们按需加载数据到缓存中。当缓存失效时，应用会从数据存储中加载最新的数据并更新缓存。本文将详细讲解如何在 .NET Core 中实现缓存端模式，使用 Redis 来提升应用性能。</p>
<h4>1. 为什么使用缓存端模式？</h4>
<p>缓存端模式是指应用程序在访问数据时，首先尝试从缓存中获取数据。如果缓存中没有数据（缓存未命中），则应用程序会从数据存储（如数据库）加载数据，并将其存储到缓存中。缓存的生命周期由应用程序控制，而不是缓存系统自动决定。</p>
<p>与其他缓存策略（如直读和直写策略）不同，缓存端模式的优点在于：</p>
<ul>
<li><strong>按需加载</strong>：只有在需要时才将数据加载到缓存中，避免了缓存空间浪费。</li>
<li><strong>灵活控制缓存生命周期</strong>：缓存的过期时间、更新策略等都由应用程序控制，确保数据的时效性。</li>
<li><strong>提高性能</strong>：频繁读取的数据会被缓存起来，减少数据库的访问压力。</li>
</ul>
<h4>2. 实现步骤</h4>
<h5>2.1 安装 Redis 客户端库</h5>
<p>在 .NET Core 项目中使用 Redis，我们需要安装 <code>StackExchange.Redis</code> 包，这是一个性能优良且易于使用的 Redis 客户端库。你可以通过以下命令安装：</p>
<pre><code class="language-bash">dotnet add package StackExchange.Redis
</code></pre>
<h5>2.2 配置 Redis 连接字符串</h5>
<p>在 <code>appsettings.json</code> 中配置 Redis 连接信息。假设你使用的是本地的 Redis 实例或 Azure Redis 缓存，连接字符串配置如下：</p>
<pre><code class="language-json">{
  "ConnectionStrings": {
    "RedisConnection": "localhost:6379" // 连接本地 Redis 实例
  }
}
</code></pre>
<p>这里，<code>"RedisConnection"</code> 是用于连接 Redis 的连接字符串。</p>
<h5>2.3 创建 Redis 服务类</h5>
<p>接下来，我们创建一个 <code>RedisCacheService</code> 类，用于管理与 Redis 的连接。为了提高性能，我们将连接使用 <code>Lazy&lt;T&gt;</code> 实现懒加载，确保连接只会在第一次使用时初始化。</p>
<pre><code class="language-csharp">using StackExchange.Redis;
using Microsoft.Extensions.Configuration;

public class RedisCacheService
{
    private static Lazy&lt;ConnectionMultiplexer&gt; _lazyConnection;
    private static ConnectionMultiplexer _connection;

    public RedisCacheService(IConfiguration configuration)
    {
        // 获取 Redis 连接字符串
        string redisConnectionString = configuration.GetConnectionString("RedisConnection");

        // 使用 Lazy 确保 Redis 连接只有一个实例，并且是懒加载的
        _lazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;
            ConnectionMultiplexer.Connect(redisConnectionString));
    }

    // 获取 Redis 数据库实例
    public IDatabase GetDatabase()
    {
        return _lazyConnection.Value.GetDatabase();
    }

    // 获取 Redis 连接实例
    public ConnectionMultiplexer GetConnection()
    {
        return _lazyConnection.Value;
    }
}
</code></pre>
<p>此类将 Redis 连接字符串作为参数，并提供一个 <code>GetDatabase</code> 方法来获取 Redis 数据库实例，供后续的缓存操作使用。</p>
<h5>2.4 在 <code>Startup.cs</code> 中注册 Redis 服务</h5>
<p>为了在整个应用中共享 Redis 服务，我们需要将 <code>RedisCacheService</code> 注册为单例服务。在 <code>Startup.cs</code> 文件的 <code>ConfigureServices</code> 方法中注册服务：</p>
<pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;RedisCacheService&gt;();  // 注册 RedisCacheService 为单例服务
}
</code></pre>
<h5>2.5 实现缓存端模式</h5>
<p>现在，我们可以实现缓存端模式。在缓存端模式中，当应用程序需要数据时，首先检查缓存是否包含该数据。如果缓存中没有数据（缓存未命中），则从数据存储（如数据库）中加载数据，并将其存入缓存中。我们还要为缓存设置过期时间，确保数据的时效性。</p>
<p>以下是实现缓存端模式的代码示例：</p>
<pre><code class="language-csharp">using Newtonsoft.Json;
using StackExchange.Redis;
using System;
using System.Threading.Tasks;

public class MyEntity
{
    public int Id { get; set; }
    public string Name { get; set; }
}

public class MyEntityService
{
    private readonly RedisCacheService _redisCacheService;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromMinutes(5);

    public MyEntityService(RedisCacheService redisCacheService)
    {
        _redisCacheService = redisCacheService;
    }

    // 获取实体的异步方法
    public async Task&lt;MyEntity&gt; GetMyEntityAsync(int id)
    {
        var cache = _redisCacheService.GetDatabase();
        var key = $"MyEntity:{id}";  // 用 id 生成唯一的缓存键

        // 尝试从缓存中获取数据
        var cachedData = await cache.StringGetAsync(key);
        if (!string.IsNullOrEmpty(cachedData))
        {
            // 如果缓存中有数据，直接返回缓存的值
            return JsonConvert.DeserializeObject&lt;MyEntity&gt;(cachedData);
        }

        // 如果缓存没有数据，执行数据库查询（此处假设从数据库获取数据）
        MyEntity entityFromDb = await GetEntityFromDbAsync(id);

        // 如果数据库中找到了该数据，缓存并返回
        if (entityFromDb != null)
        {
            // 将从数据库获取的数据存入缓存
            await cache.StringSetAsync(key, JsonConvert.SerializeObject(entityFromDb), _cacheExpiration);
        }

        return entityFromDb;
    }

    // 假设此方法是从数据库中获取数据
    private Task&lt;MyEntity&gt; GetEntityFromDbAsync(int id)
    {
        // 模拟从数据库查询数据
        return Task.FromResult(new MyEntity { Id = id, Name = "Entity " + id });
    }
}
</code></pre>
<h4>解释：</h4>
<ol>
<li><strong>缓存加载</strong>：在 <code>GetMyEntityAsync</code> 方法中，首先使用 <code>StringGetAsync</code> 尝试从 Redis 缓存中读取数据。如果缓存中有数据，直接返回缓存的内容。</li>
<li><strong>缓存失效</strong>：如果缓存未命中，方法会从数据库加载数据，并将其存入 Redis 缓存中，设置缓存的过期时间为 5 分钟。</li>
<li><strong>缓存更新</strong>：在缓存更新时，应用程序会先从数据库加载数据，然后缓存该数据。如果缓存中已存在数据，旧的缓存将被新的数据覆盖。</li>
</ol>
<h5>2.6 使缓存数据失效</h5>
<p>当应用程序更新数据库中的数据时，需要从缓存中删除该数据，避免缓存中存留过时的数据。下面是一个更新实体并使缓存失效的例子：</p>
<pre><code class="language-csharp">public async Task UpdateEntityAsync(MyEntity entity)
{
    // 更新数据库中的实体
    await UpdateEntityInDbAsync(entity);

    // 从缓存中删除该实体
    var cache = _redisCacheService.GetDatabase();
    var key = $"MyEntity:{entity.Id}";
    await cache.KeyDeleteAsync(key);  // 删除缓存中的条目
}

private Task UpdateEntityInDbAsync(MyEntity entity)
{
    // 模拟更新数据库中的数据
    return Task.CompletedTask;
}
</code></pre>
<p>在更新数据库之后，我们从 Redis 缓存中删除该实体的缓存条目，确保下次从数据库加载时数据是最新的。</p>
<h4>3. 性能与优化</h4>
<p>在实现缓存端模式时，有一些细节需要特别注意：</p>
<ul>
<li><strong>缓存过期时间</strong>：合理设置缓存过期时间非常重要。如果缓存过期时间太短，应用程序会频繁地从数据库加载数据，浪费性能；如果过期时间太长，缓存中的数据可能会过时。建议根据数据的访问频率和变化频率来调整过期时间。</li>
<li><strong>缓存淘汰策略</strong>：Redis 提供了多种缓存淘汰策略（如 LRU - 最近最少使用）。根据实际需求，可以配置 Redis 使用合适的淘汰策略，以确保缓存空间的有效使用。</li>
</ul>
<h4>4. 总结</h4>
<p>通过实现缓存端模式，我们能够高效地将缓存与数据存储结合，优化应用性能。在 .NET Core 中，结合使用 Redis 和 <code>StackExchange.Redis</code> 库，我们可以按需加载数据到缓存中，并确保缓存的数据与数据存储中的数据保持一致。缓存端模式非常适合于读取频繁的数据，可以大幅减少数据库访问，提高系统的响应速度和可靠性。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06472874435532408" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 10:46">2025-02-26 10:45</span>&nbsp;
<a href="https://www.cnblogs.com/forges">努力，努力再努力</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18737973" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18737973);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18737973', targetLink: 'https://www.cnblogs.com/forges/p/18737973', title: '在 .NET Core 中实现缓存端模式：使用 Redis 提升性能' })">举报</a>
</div>
        