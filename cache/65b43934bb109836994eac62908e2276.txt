
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kongsq/p/18804085" title="发布于 2025-04-01 14:37">
    <span role="heading" aria-level="2">虚拟电商-话费充值业务（二）话费充值对接供应商模块开发</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        话费充值业务，对接供应商
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>　　一、对接供应商模块开发</h1>
<p><br>　　供应商对接模块chongba_recharge_supplier主要负责的就是调用外部的供应商系统进行充值下单，这种调用是一种基于HTTP协议的调用。</p>
<p>　　此外在供应商对接模块中主要是实现的业务逻辑有：</p>
<p>1：余额或押金不足情况下的失败轮转</p>
<p>2：网络故障/充值失败重试，需要添加一个重试任务</p>
<p>3：重试次数到达阈值后停止供应商对接</p>
<p>4：供应商异步回调，订单状态修改</p>
<h1>　　二、对接供应商服务接口定义</h1>
<p><br>　　chongba_recharge_supplier监听到支付成功消息之后，接收到的消息：RechargeRequest，具体对接的不直接写在监听类中，单独定义一个对接供应商服务接口</p>
<p>　　步骤1：在chongba_recharge_supplier模块下创建包：com.chongba.supplier.inf，在该包下创建充吧系统对接供应商接口：SupplierService，接口中定义一个对接方法：void recharge(RechargeRequest rechargeRequest);</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">interface</span><span style="color: rgba(0, 0, 0, 1)"> SupplierService {
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 对接供应商下单
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> rechargeRequest
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> recharge(RechargeRequest rechargeRequest);
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br>步骤2：在chongba_recharge_supplier模块下创建包：com.chongba.supplier.service，在该包下创建一个接口的实现类：SupplierServiceImpl</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Slf4j
@Service
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> SupplierServiceImpl <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> SupplierService{    
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> recharge(RechargeRequest rechargeRequest) {
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br>步骤3：配置供应商系统的接口地址，在实际业务中调用第三方系统接口大都基于HTTP协议调用，充吧系统在模块中模拟了两个供应商，注意这个模块并没有在充吧的注册中心去注册，因为我们模拟的是外部系统，所以我们要调用外部系统必须得知道系统接口的调用地址；</p>
<p>在application-dev.yml中配置如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">supplier:
  apis: {
          "jisuapi": "http://127.0.0.1:8090/jisuapi/mobilerecharge/recharge",
          "juheapi": "http://127.0.0.1:8090/juheapi/recharge"
         }</span></pre>
</div>
<p>&nbsp;</p>
<p><br>步骤4：编写配置类读取配置，在chongba_recharge_supplier模块下创建包：com.chongba.supplier.conf，在该包下创建配置类：SupplierConfig</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Data
@Component
@ConfigurationProperties(prefix </span>= "supplier"<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SupplierConfig {
    
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> Map&lt;String,String&gt; apis; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">加载供应商api地址</span>
}</pre>
</div>
<p>&nbsp;</p>
<p><br>步骤5：在对接服务实现类：SupplierServiceImpl中注入配置类SupplierConfig，并测试配置能否正常读取</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Slf4j
@Service
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> SupplierServiceImpl <span style="color: rgba(0, 0, 255, 1)">implements</span><span style="color: rgba(0, 0, 0, 1)"> SupplierService{
    @Autowired
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> SupplierConfig supplierConfig;
    
    @PostConstruct
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> init(){
        System.out.println(</span>"加载到的配置如下:"+<span style="color: rgba(0, 0, 0, 1)">supplierConfig.getApis());
    }
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> recharge(RechargeRequest rechargeRequest) {
        
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br>运行启动类：SupplierApplication，查看控制台输出：</p>
<h1>　　三、对接供应商逻辑编写</h1>
<p><br>　　配置正常加载之后需要编写对接供应商的处理逻辑，先将代码结构实现，然后补充细节</p>
<p>　　 1）.编写对接逻辑分发方法：doDispatchSupplier(RechargeRequest rechargeRequest)，根据供应商编号进行分发<br>　　 2）.编写对接聚合的方法：doPostJuhe(RechargeRequest rechargeRequest)<br>　　 3）.编写对接极速的方法：doPostJisu(RechargeRequest rechargeRequest)</p>
<p>&nbsp;　　对接第三方其实就是向第三方系统接口地址发起HTTP请求，我们可以使用HttpClient、PostMan等工具。</p>
<p>步骤1：在启动类SupplierApplication中向容器注入RestTemplate</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Bean
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> RestTemplate restTemplate(){
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> RestTemplate();
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br>步骤2：整体对接代码结构如下：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Autowired
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> RestTemplate restTemplate;
​
@Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> recharge(RechargeRequest rechargeRequest) {
        doDispatchSupplier(rechargeRequest);
    }
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 对接逻辑分发
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> rechargeRequest
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doDispatchSupplier(RechargeRequest rechargeRequest) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">设置供应商的调用地址:</span>
        String url =<span style="color: rgba(0, 0, 0, 1)"> supplierConfig.getApis().get(rechargeRequest.getSupply());
        rechargeRequest.setRechargeUrl(url);
​
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">根据需要对接的供应商的编号确定不同的对接方式---不同的api需要传递的参数类型和参数名称等各不相同</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Constants.juheapi.equals(rechargeRequest.getSupply())){
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">对接聚合</span>
<span style="color: rgba(0, 0, 0, 1)">            doPostJuhe(rechargeRequest);
        }</span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Constants.jisuapi.equals(rechargeRequest.getSupply())) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">对接极速</span>
<span style="color: rgba(0, 0, 0, 1)">            doPostJisu(rechargeRequest);
        }
    }
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doPostJuhe(RechargeRequest rechargeRequest) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">聚合要求传递的是json格式的数据
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建并设置请求头</span>
        HttpHeaders headers = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建请求实体</span>
        HttpEntity httpEntity = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpEntity(JSON.toJSONString(rechargeRequest),headers);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发送请求</span>
        ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(rechargeRequest.getRechargeUrl(), httpEntity, String.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获得结果</span>
        String body =<span style="color: rgba(0, 0, 0, 1)"> responseEntity.getBody();
        System.out.println(body);
    }
​
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doPostJisu(RechargeRequest rechargeRequest) {
        
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>然后注意：在我们监听类中监听到消息之后，要去调用我们供应商对接服务接口方法：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Component
@Slf4j
@RocketMQMessageListener(topic </span>= "pay",consumerGroup = "order-paid-consumer"<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> PayRocketListener <span style="color: rgba(0, 0, 255, 1)">implements</span> RocketMQListener&lt;RechargeRequest&gt;<span style="color: rgba(0, 0, 0, 1)">{
​
    @Autowired
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> SupplierService supplierService;
​
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 监听消息:
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> rechargeRequest
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> onMessage(RechargeRequest rechargeRequest) {
        log.info(</span>"PayRocketListener 监听到了消息,{}"<span style="color: rgba(0, 0, 0, 1)">,rechargeRequest);
        supplierService.recharge(rechargeRequest);
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>启动测试：</p>
<p>启动chongba_recharge_web工程，chongba_recharge_mock工程，chongba_recharge_supplier工程</p>
<p>访问：<a href="http://localhost:191/%20" target="_blank" rel="noopener nofollow">http://localhost:191/ </a>进行充值，查看结果</p>
<p>步骤3：供应商返回结果封装处理：对于供应商的返回结果数据我们可以统一封装处理</p>
<p>对进行泛型的反序列化，使用TypeReference可以明确的指定反序列化的类型</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">@Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> recharge(RechargeRequest rechargeRequest) {
        Result</span>&lt;RechargeResponse&gt; result =<span style="color: rgba(0, 0, 0, 1)"> doDispatchSupplier(rechargeRequest);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(result !=<span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">){           
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * 对接逻辑分发
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> rechargeRequest
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> Result&lt;RechargeResponse&gt;<span style="color: rgba(0, 0, 0, 1)"> doDispatchSupplier(RechargeRequest rechargeRequest) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">设置供应商的调用地址:</span>
        String url =<span style="color: rgba(0, 0, 0, 1)"> supplierConfig.getApis().get(rechargeRequest.getSupply());
        rechargeRequest.setRechargeUrl(url);
​
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">根据需要对接的供应商的编号确定不同的对接方式---不同的api需要传递的参数类型和参数名称等各不相同</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Constants.juheapi.equals(rechargeRequest.getSupply())){
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">对接聚合</span>
            <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">  doPostJuhe(rechargeRequest);
        }</span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Constants.jisuapi.equals(rechargeRequest.getSupply())) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">对接极速</span>
            <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">  doPostJisu(rechargeRequest);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> Result&lt;RechargeResponse&gt;<span style="color: rgba(0, 0, 0, 1)"> doPostJuhe(RechargeRequest rechargeRequest) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">聚合要求传递的是json格式的数据
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建并设置请求头</span>
        HttpHeaders headers = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建请求实体</span>
        HttpEntity httpEntity = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpEntity(JSON.toJSONString(rechargeRequest),headers);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">发送请求</span>
        ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(rechargeRequest.getRechargeUrl(), httpEntity, String.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获得结果</span>
        <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">String body = responseEntity.getBody();// Result&lt;RechargeResponse&gt;
        Result result = JSON.parseObject(body, Result.class);//因为泛型的问题可能会导致出现问题
        System.out.println(body);</span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
        Result</span>&lt;RechargeResponse&gt; result = JSON.parseObject(responseEntity.getBody(), <span style="color: rgba(0, 0, 255, 1)">new</span> TypeReference&lt;Result&lt;RechargeResponse&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">(){});
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> result;
    }
​
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 对接极速</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> Result&lt;RechargeResponse&gt;<span style="color: rgba(0, 0, 0, 1)"> doPostJisu(RechargeRequest rechargeRequest) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>　　四、对接供应商测试</h1>
<p><br>　　业务逻辑：</p>
<p>　　选择手机充值进行话费充值。进行充值，然后生成订单并支付成功。支付成功后，对接供应商模块，发送消息到供应商平台，然后接收聚合供应商返回的消息。进行处理。</p>
<p>　　选择充值：</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202504/527658-20250401143528748-40795775.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><br>　　进行充值：</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202504/527658-20250401143540349-1964104782.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>　　充值话费成功：</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202504/527658-20250401143557250-638747629.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>　　对接供应商模块，发送消息到供应商平台，然后接收聚合供应商返回的消息（余额不足）。对接成功。<br><br></p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="1.0726721371342594" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-01 14:37">2025-04-01 14:37</span>&nbsp;
<a href="https://www.cnblogs.com/kongsq">努力--坚持</a>&nbsp;
阅读(<span id="post_view_count">269</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18804085" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18804085);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18804085', targetLink: 'https://www.cnblogs.com/kongsq/p/18804085', title: '虚拟电商-话费充值业务（二）话费充值对接供应商模块开发' })">举报</a>
</div>
