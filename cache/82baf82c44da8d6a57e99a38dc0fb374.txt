
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pains/p/18854297" title="发布于 2025-04-29 21:01">
    <span role="heading" aria-level="2">.net c# Func&lt;Task&gt;及变体做为多播委托异步执行会另开线程的问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-问题">1. 问题</h1>
<p>环境是dotnet8及以前的版本，dotnet9+不知道是否还有这个问题（我猜是一样的）。<br>
如下代码，在多播委托await异步执行时，不会等待委托方法执行完成，它们在新的线程中运行。</p>
<pre><code class="language-csharp">async Task A()
{
}
async Task B()
{
}
Func&lt;Task&gt; func;//下面+=运算赋值为多播委托
func+=async()=&gt;await A();
func+=async()=&gt;await B();

await func();//这里不会等待A和B方法执行完成，它们在新的线程中运行
</code></pre>
<h1 id="2-解决">2. 解决</h1>
<p>用GetInvocationList方法取得所有委托方法，逐个执行。</p>
<pre><code class="language-csharp">Func&lt;Task&gt; func;//下面+=运算赋值为多播委托
func+=async()=&gt;await A();
func+=async()=&gt;await B();

var subscribers = func.GetInvocationList();//取得多播委托的每个方法然后逐个执行
foreach(var subscriber in subscribers)
{
    var asyncMethod = (Func&lt;Task&gt;)subscriber;
    await asyncMethod();
}
</code></pre>
<h1 id="3-总结">3. 总结</h1>
<p>同样的道理，也适用于事件，因为事件本身也是委托。用这个办法就可以解决事件、委托、Action、Func等同步还是异步执行的问题。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">
<p id="PSignature" style="border-top-color: #e0e0e0; border-top-width: 1px; border-top-style: dashed; border-right-color: #e0e0e0; border-right-width: 1px; border-right-style: dashed; border-bottom-color: #e0e0e0; border-bottom-width: 1px; border-bottom-style: dashed; border-left-color: #e0e0e0; border-left-width: 1px; border-left-style: dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 80px; background-image: url(https://images.cnblogs.com/cnblogs_com/pains/109838/r_copyright.png); background-attachment: initial; background-origin: initial; background-clip: initial; font-family: 微软雅黑; font-size: 11px; background-color: #e5f1f4; background-position: 1% 50%; background-repeat: no-repeat no-repeat; ">
作者：<a href="http://pains.cnblogs.com/" target="_blank">Rick Carter</a>
<br>
出处：<a href="http://pains.cnblogs.com/" target="_blank">http://pains.cnblogs.com/</a>
<br>
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
</p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="6.1419641864444445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-29 21:01">2025-04-29 21:01</span>&nbsp;
<a href="https://www.cnblogs.com/pains">Rick Carter</a>&nbsp;
阅读(<span id="post_view_count">54</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18854297);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18854297', targetLink: 'https://www.cnblogs.com/pains/p/18854297', title: '.net c# Func&amp;lt;Task&amp;gt;及变体做为多播委托异步执行会另开线程的问题' })">举报</a>
</div>
        