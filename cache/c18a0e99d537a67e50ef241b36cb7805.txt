
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/changelzj/p/18808622" title="发布于 2025-04-04 02:00">
    <span role="heading" aria-level="2">DataPermissionInterceptor源码解读</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>本文首发在我的博客：<a href="https://blog.liuzijian.com/post/mybatis-plus-source-data-permission-interceptor.html" target="_blank" rel="noopener nofollow">https://blog.liuzijian.com/post/mybatis-plus-source-data-permission-interceptor.html</a></strong></p>
<h2 id="一概述">一、概述</h2>
<p>DataPermissionInterceptor是MyBatis-Plus中的一个拦截器插件，用于实现数据权限功能，它将查询、删除和修改的SQL进行拦截并获得要执行的SQL，并解析出SQL中的表和原有条件，通过一个DataPermissionHandler接口来回调获取每个表的数据权限条件，再和原有的条件拼接在一起形成新的SQL，执行重写后的新SQL，从而实现数据权限功能。因为添加操作无需数据权限控制，因此不处理添加的情况。</p>
<p>本类的实现较为简单，因为对于数据权限来说，对于比较复杂的查询SQL的解析逻辑基本已经由父类完成，具体见：<a href="https://www.cnblogs.com/changelzj/p/18794189" target="_blank">BaseMultiTableInnerInterceptor源码解读</a>，本类作为子类将查询SQL调用父类进行解析重写即可，对于删除和更新的SQL仅仅针对delete和update本身的where条件进行处理，而且是单表操作，因此对于删除和更新来说，只是将表原有条件和数据权限条件做简单的拼接即可。</p>
<p>本文基于MyBatis-Plus的3.5.9版本的源码，并fork了代码： <a href="https://github.com/changelzj/mybatis-plus/tree/lzj-3.5.9" target="_blank" rel="noopener nofollow">https://github.com/changelzj/mybatis-plus/tree/lzj-3.5.9</a></p>
<pre><code class="language-java">public class DataPermissionInterceptor extends BaseMultiTableInnerInterceptor implements InnerInterceptor {

    private DataPermissionHandler dataPermissionHandler;

    @SuppressWarnings("RedundantThrows")
    @Override
    public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {...}

    @Override
    public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) {...}

    @Override
    protected void processSelect(Select select, int index, String sql, Object obj) {...}

    protected void setWhere(PlainSelect plainSelect, String whereSegment) {...}

    @Override
    protected void processUpdate(Update update, int index, String sql, Object obj) {...}

    @Override
    protected void processDelete(Delete delete, int index, String sql, Object obj) {...}

    protected Expression getUpdateOrDeleteExpression(final Table table, final Expression where, final String whereSegment) {...}

    @Override
    public Expression buildTableExpression(final Table table, final Expression where, final String whereSegment) {...}
}
</code></pre>
<h2 id="二源码解读">二、源码解读</h2>
<h3 id="21-beforequery">2.1 beforeQuery</h3>
<p>该方法从<code>InnerInterceptor</code>接口继承而来，是解析查询SQL的起点，MyBatis-Plus执行时就是对实现<code>InnerInterceptor</code>接口的类中的对应方法进行回调的，会传入要执行的SQL并接收重写后的SQL来实现对SQL的修改，在查询SQL执行前进行拦截并调用<code>beforeQuery()</code>，<code>beforeQuery()</code>中再去调用<code>parserSingle()</code></p>
<p><code>parserSingle()</code>是从父类BaseMultiTableInnerInterceptor自JsqlParserSupport抽象类间接继承而来的，JsqlParserSupport类的功能非常简单，作用是判断SQL是增删改查的哪一种类型，然后分别调用对应的方法开始解析。</p>
<p>当调用<code>parserSingle()</code>并传入SQL时，会在JsqlParserSupport的<code>processParser()</code>方法中先判断是哪一种Statement，然后分别强转为具体的Select、Update、Delete、Insert对象，再调用该类间接继承并重写的<code>processSelect()</code>方法并传入Select对象。</p>
<p><code>processSelect()</code>方法会再调用父类的<code>processSelectBody()</code>对查询SQL进行解析，对于解析到的每张表和已有条件，再去调用父类的<code>builderExpression()</code>进而再调用<code>buildTableExpression()</code>获取当前表对应的数据权限过滤条件再和已有条件进行拼接。</p>
<pre><code class="language-java">@SuppressWarnings("RedundantThrows")
@Override
public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    if (InterceptorIgnoreHelper.willIgnoreDataPermission(ms.getId())) {
        return;
    }
    PluginUtils.MPBoundSql mpBs = PluginUtils.mpBoundSql(boundSql);
    mpBs.sql(parserSingle(mpBs.sql(), ms.getId()));
}
</code></pre>
<h3 id="22-beforeprepare">2.2 beforePrepare</h3>
<p>该方法和<code>beforeQuery()</code>一样，也是从<code>InnerInterceptor</code>接口中继承而来，因为添加修改和删除SQL都要预编译，因此该方法可作为解析删除和修改SQL的起点，不同的是<code>beforePrepare()</code>调用的是<code>JsqlParserSupport</code>中继承来的<code>parserMulti()</code>，因为查询语句只能一次执行一条，但是增删改语句可以用分号间隔一次执行多条，故需调用<code>parserMulti()</code>将多个语句循环拆开，然后判断并分别强转为具体的Select、Update、Delete、Insert对象，再分别调用该类间接继承并重写的<code>processDelete()</code>、<code>processUpdate()</code>方法并分别传入Delete，Update对象，然后直接解析出要删除和更新数据的表和已有删除更新条件，调用父类的<code>andExpression()</code>进而在调用<code>buildTableExpression()</code>来拼接数据权限过滤条件。</p>
<pre><code class="language-java">@Override
public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) {
    PluginUtils.MPStatementHandler mpSh = PluginUtils.mpStatementHandler(sh);
    MappedStatement ms = mpSh.mappedStatement();
    SqlCommandType sct = ms.getSqlCommandType();
    if (sct == SqlCommandType.UPDATE || sct == SqlCommandType.DELETE) {
        if (InterceptorIgnoreHelper.willIgnoreDataPermission(ms.getId())) {
            return;
        }
        PluginUtils.MPBoundSql mpBs = mpSh.mPBoundSql();
        mpBs.sql(parserMulti(mpBs.sql(), ms.getId()));
    }
}
</code></pre>
<h3 id="23-processselect">2.3 processSelect</h3>
<p>开始一个对查询SQL的解析，当前版本走的是<code>if (dataPermissionHandler instanceof MultiDataPermissionHandler)</code>的新版本的逻辑，先调用<code>processSelectBody()</code>进行解析，对于WITH中的结构，又在调用<code>processSelectBody()</code>后单独组织了一段针对WITH中的查询的解析逻辑。旧版本应该是直接获取where后面的条件直接传递给dataPermissionHandler，在dataPermissionHandler中对where进行追加，而新版本代码是将解析到的表传到dataPermissionHandler，传入的是表名返回表的数据权限条件</p>
<pre><code class="language-java">@Override
protected void processSelect(Select select, int index, String sql, Object obj) {
    if (dataPermissionHandler == null) {
        return;
    }
    if (dataPermissionHandler instanceof MultiDataPermissionHandler) {
        // 参照 com.baomidou.mybatisplus.extension.plugins.inner.TenantLineInnerInterceptor.processSelect 做的修改
        final String whereSegment = (String) obj;
        processSelectBody(select, whereSegment);
        List&lt;WithItem&gt; withItemsList = select.getWithItemsList();
        if (!CollectionUtils.isEmpty(withItemsList)) {
            withItemsList.forEach(withItem -&gt; processSelectBody(withItem, whereSegment));
        }
    } else {
        // 兼容原来的旧版 DataPermissionHandler 场景
        if (select instanceof PlainSelect) {
            this.setWhere((PlainSelect) select, (String) obj);
        } else if (select instanceof SetOperationList) {
            SetOperationList setOperationList = (SetOperationList) select;
            List&lt;Select&gt; selectBodyList = setOperationList.getSelects();
            selectBodyList.forEach(s -&gt; this.setWhere((PlainSelect) s, (String) obj));
        }
    }
}
</code></pre>
<h3 id="24-setwhere">2.4 setWhere</h3>
<p>这段代码应该是为旧版本用的，没有走到</p>
<pre><code class="language-java">/**
 * 设置 where 条件
 *
 * @param plainSelect  查询对象
 * @param whereSegment 查询条件片段
 */
protected void setWhere(PlainSelect plainSelect, String whereSegment) {
    if (dataPermissionHandler == null) {
        return;
    }
    // 兼容旧版的数据权限处理
    final Expression sqlSegment = dataPermissionHandler.getSqlSegment(plainSelect.getWhere(), whereSegment);
    if (null != sqlSegment) {
        plainSelect.setWhere(sqlSegment);
    }
}
</code></pre>
<h3 id="25-processupdate">2.5 processUpdate</h3>
<pre><code class="language-java">/**
 * update 语句处理
 */
@Override
protected void processUpdate(Update update, int index, String sql, Object obj) {
    final Expression sqlSegment = getUpdateOrDeleteExpression(update.getTable(), update.getWhere(), (String) obj);
    if (null != sqlSegment) {
        update.setWhere(sqlSegment);
    }
}

</code></pre>
<h3 id="26-processdelete">2.6 processDelete</h3>
<pre><code class="language-java">/**
 * delete 语句处理
 */
@Override
protected void processDelete(Delete delete, int index, String sql, Object obj) {
    final Expression sqlSegment = getUpdateOrDeleteExpression(delete.getTable(), delete.getWhere(), (String) obj);
    if (null != sqlSegment) {
        delete.setWhere(sqlSegment);
    }
}

</code></pre>
<h3 id="27-getupdateordeleteexpression">2.7 getUpdateOrDeleteExpression</h3>
<p>针对更新和删除的SQL，不同于查询，当更新后的值是子查询或更新删除条件的值是一个子查询的时候，不会为这个子查询中的表追加条件，仅把针对整个update或delete语句的条件本身和要追加的数据权限过滤条件进行AND和OR拼接，因此会直接把表名和WHERE条件调用父类的<code>andExpression(table, where, whereSegment)</code>进行拼接，方法的返回值即为拼接后的结果，直接返回。</p>
<pre><code class="language-java">protected Expression getUpdateOrDeleteExpression(final Table table, final Expression where, final String whereSegment) {
    if (dataPermissionHandler == null) {
        return null;
    }
    if (dataPermissionHandler instanceof MultiDataPermissionHandler) {
        return andExpression(table, where, whereSegment);
    } else {
        // 兼容旧版的数据权限处理
        return dataPermissionHandler.getSqlSegment(where, whereSegment);
    }
}

</code></pre>
<h3 id="28-buildtableexpression">2.8 buildTableExpression</h3>
<p>传入表名，返回表要追加的数据权限过滤条件，具体哪个表需要怎样的数据权限条件，会通过回调<code>dataPermissionHandler.getSqlSegment()</code>让DataPermissionHandler的实现类根据具体业务来确定</p>
<pre><code class="language-java">@Override
public Expression buildTableExpression(final Table table, final Expression where, final String whereSegment) {
    if (dataPermissionHandler == null) {
        return null;
    }
    // 只有新版数据权限处理器才会执行到这里
    final MultiDataPermissionHandler handler = (MultiDataPermissionHandler) dataPermissionHandler;
    return handler.getSqlSegment(table, where, whereSegment);
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.013626217173611" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-04 02:01">2025-04-04 02:00</span>&nbsp;
<a href="https://www.cnblogs.com/changelzj">LiuZijian</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18808622" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18808622);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18808622', targetLink: 'https://www.cnblogs.com/changelzj/p/18808622', title: 'DataPermissionInterceptor源码解读' })">举报</a>
</div>
        