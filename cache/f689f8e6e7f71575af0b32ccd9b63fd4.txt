
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Runoob-Yang/p/19035559" title="发布于 2025-08-13 12:50">
    <span role="heading" aria-level="2">微服务项目中基于 Servlet 的业务模块与 WebFlux 网关模块的 Redis 统一化配置教程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="微服务项目中servlet模块与webflux网关的redis使用指南">微服务项目中Servlet模块与WebFlux网关的Redis使用指南</h1>
<p>在微服务架构的蓬勃发展浪潮中，Redis凭借其超高的性能、丰富的功能，已然成为缓存、分布式锁、会话存储等场景下的核心支撑技术。然而，在微服务项目里，基于Servlet的普通业务模块和基于WebFlux的网关模块，由于它们底层的技术架构存在显著差异，在使用Redis时也呈现出不同的特点和实现方式。下面，我们就深入探讨这两种场景下Redis的使用之道。</p>
<h2 id="一技术架构差异简析">一、技术架构差异简析</h2>
<p>在微服务的技术生态中，基于Servlet的普通业务模块和基于WebFlux的网关模块，在处理请求的方式上有着本质区别。</p>
<p>基于Servlet的普通模块，遵循的是<strong>同步阻塞</strong>的I/O模型。这就意味着当一个请求进入模块后，线程会一直等待I/O操作完成，在这个过程中，线程无法去处理其他请求，容易造成线程资源的浪费，尤其是在高并发场景下，可能会出现线程池耗尽的情况。</p>
<p>而基于WebFlux的网关模块，则采用了<strong>异步非阻塞</strong>的I/O模型。它能够在一个线程上处理多个请求，当遇到I/O操作时，线程不会阻塞等待，而是会去处理其他请求，待I/O操作完成后再回来继续处理，极大地提高了线程的利用率，非常适合高并发、I/O密集型的网关场景。</p>
<p>这种底层技术架构的差异，直接影响了Redis在这两种模块中的使用方式。</p>
<h2 id="二基于servlet的普通模块使用redis">二、基于Servlet的普通模块使用Redis</h2>
<p>在基于Servlet的普通模块中，我们通常会选择<strong>Spring Data Redis</strong>作为操作Redis的框架，它对Redis的各种操作进行了友好封装，让开发者能够更便捷地使用Redis。</p>
<h3 id="一引入依赖">（一）引入依赖</h3>
<p>在 Maven 项目中，需要在<code>pom.xml</code>文件中引入相关依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>其中，<code>spring-boot-starter-data-redis</code>是Spring Data Redis的 starter 依赖，<code>commons-pool2</code>为Redis连接池提供支持，有助于提高Redis连接的管理效率。</p>
<h3 id="二配置redis连接">（二）配置Redis连接</h3>
<p>在<code>application.properties</code>或<code>application.yml</code>中进行Redis连接信息的配置：</p>
<pre><code class="language-yaml">spring:
  redis:
    host: localhost
    port: 6379
    password: 123456
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 2
        max-wait: -1ms
</code></pre>
<p>这里配置了Redis的主机地址、端口、密码以及连接池参数。采用Lettuce作为Redis客户端，它是一个高性能的异步Redis客户端，在Spring Boot 2.x及以上版本中成为了默认的客户端。</p>
<h3 id="三redis操作模板">（三）Redis操作模板</h3>
<p>Spring Data Redis提供了<code>RedisTemplate</code>和<code>StringRedisTemplate</code>两种模板类用于操作Redis。<code>StringRedisTemplate</code>是<code>RedisTemplate</code>的子类，专门用于处理键和值都是字符串的情况，使用起来更加便捷。</p>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class RedisUtils {

    private final RedisTemplate&lt;String, Object&gt; redisTemplate;

    public void set(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }

    public void set(String key, Object value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }

    public void set(String key, Object value, long seconds) {
        redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS);
    }

    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }

    public String getString(String key) {
        Object obj = redisTemplate.opsForValue().get(key);
        return obj == null ? null : obj.toString();
    }

    public Boolean delete(String key) {
        return redisTemplate.delete(key);
    }

    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    public Boolean setNx(String key, Object value) {
        return redisTemplate.opsForValue().setIfAbsent(key, value);
    }

    public Boolean tryLock(String lockKey, String requestId, long seconds) {
        return redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, seconds, TimeUnit.SECONDS);
    }

    public Boolean tryLock(String lockKey, String requestId, long timeout, TimeUnit unit) {
        return redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, timeout, unit);
    }

    public Boolean releaseLock(String lockKey, String requestId) {
        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();
        redisScript.setScriptText(RELEASE_SCRIPT);
        redisScript.setResultType(Long.class);
        Long result = redisTemplate.execute(redisScript, Collections.singletonList(lockKey), requestId);
        return RELEASE_SUCCESS.equals(result);
    }
}
</code></pre>
<p>在上述代码中，通过Lombok中热<code>@RequireArgsConstructor</code>注入<code>StringRedisTemplate</code>，然后利用其<code>opsForValue()</code>方法获取操作字符串类型数据的<code>ValueOperations</code>对象，进而实现对Redis中字符串数据的增、删、查等操作。</p>
<h3 id="四缓存注解的使用">（四）缓存注解的使用</h3>
<p>Spring还提供了缓存注解，如<code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>等，可以更方便地实现缓存功能。</p>
<p>首先，需要在配置类上添加<code>@EnableCaching</code>注解开启缓存功能：</p>
<pre><code class="language-java">@Configuration
@EnableCaching
public class RedisCacheConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues();

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }
}
</code></pre>
<p>在这个配置中，定义了Redis缓存的默认配置，包括缓存过期时间、键和值的序列化方式等。使用<code>GenericJackson2JsonRedisSerializer</code>对值进行序列化，能够将对象转换为JSON格式存储，方便读取和解析。</p>
<p>然后在Service层的方法上使用缓存注解：</p>
<pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Cacheable(value = "user", key = "#id")
    public User getUserById(Long id) {
        return userMapper.selectById(id);
    }

    @CachePut(value = "user", key = "#user.id")
    public User updateUser(User user) {
        userMapper.updateById(user);
        return user;
    }

    @CacheEvict(value = "user", key = "#id")
    public void deleteUser(Long id) {
        userMapper.deleteById(id);
    }
}
</code></pre>
<p><code>@Cacheable</code>表示在调用方法之前，会先从缓存中查询，如果缓存中存在，则直接返回缓存中的数据，不执行方法体；如果缓存中不存在，则执行方法体，并将方法的返回值存入缓存。<code>@CachePut</code>会将方法的返回值存入缓存，无论缓存中是否已存在该数据。<code>@CacheEvict</code>用于删除缓存中的数据。</p>
<h2 id="三基于webflux的gateway中使用redis">三、基于WebFlux的Gateway中使用Redis</h2>
<p>在基于WebFlux的Gateway中，由于WebFlux是异步非阻塞的，所以需要使用<strong>响应式的Redis客户端</strong>来操作Redis，以契合其异步非阻塞的特性。Spring提供了<code>spring-boot-starter-data-redis-reactive</code>来支持响应式Redis操作。</p>
<h3 id="一引入依赖-1">（一）引入依赖</h3>
<p>在<code>pom.xml</code>中引入响应式Redis的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>spring-boot-starter-data-redis-reactive</code>提供了响应式的Redis操作支持，同样需要<code>commons-pool2</code>来支持连接池。</p>
<h3 id="二配置redis连接-1">（二）配置Redis连接</h3>
<p>与基于Servlet的模块类似，在<code>application.yml</code>中配置Redis连接信息：</p>
<pre><code class="language-yaml">spring:
  redis:
    host: localhost
    port: 6379
    password: 123456
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 2
        max-wait: -1ms
</code></pre>
<p>这里的配置与Servlet模块中的配置基本一致，因为连接Redis的基本信息是相同的。</p>
<h3 id="三响应式redis操作">（三）响应式Redis操作</h3>
<p>响应式Redis操作主要通过<code>ReactiveRedisTemplate</code>和<code>ReactiveStringRedisTemplate</code>来实现，它们返回的是<code>Mono</code>或<code>Flux</code>类型的结果，契合WebFlux的响应式编程模型。</p>
<pre><code class="language-java">@Service
public class ReactiveRedisService {

    @Autowired
    private ReactiveStringRedisTemplate reactiveStringRedisTemplate;

    // 设置字符串类型数据
    public Mono&lt;Boolean&gt; setString(String key, String value) {
        return reactiveStringRedisTemplate.opsForValue().set(key, value);
    }

    // 获取字符串类型数据
    public Mono&lt;String&gt; getString(String key) {
        return reactiveStringRedisTemplate.opsForValue().get(key);
    }

    // 设置带过期时间的字符串数据
    public Mono&lt;Boolean&gt; setStringWithExpire(String key, String value, long timeout, TimeUnit unit) {
        return reactiveStringRedisTemplate.opsForValue().set(key, value, timeout, unit);
    }

    // 删除数据
    public Mono&lt;Long&gt; delete(String key) {
        return reactiveStringRedisTemplate.delete(key);
    }
}
</code></pre>
<p>在响应式操作中，每个方法返回的都是<code>Mono</code>类型，<code>Mono</code>表示一个包含0或1个元素的异步序列。当调用这些方法时，并不会立即执行Redis操作，而是返回一个操作的承诺，只有当订阅这个<code>Mono</code>时，操作才会真正执行。</p>
<h3 id="四在gateway过滤器中使用redis">（四）在Gateway过滤器中使用Redis</h3>
<p>在Gateway中，经常需要在过滤器中使用Redis来实现一些功能，如限流、令牌验证等。下面以一个简单的令牌验证过滤器为例：</p>
<pre><code class="language-java">@Component
public class TokenValidateFilter implements GlobalFilter, Ordered {

    @Autowired
    private ReactiveRedisService reactiveRedisService;

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = exchange.getRequest().getHeaders().getFirst("token");
        if (token == null || token.isEmpty()) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }

        return reactiveRedisService.getString("token:" + token)
                .flatMap(userId -&gt; {
                    if (userId != null) {
                        // 令牌有效，继续执行后续过滤器
                        return chain.filter(exchange);
                    } else {
                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                        return exchange.getResponse().setComplete();
                    }
                })
                .switchIfEmpty(Mono.defer(() -&gt; {
                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                    return exchange.getResponse().setComplete();
                }));
    }

    @Override
    public int getOrder() {
        return -100;
    }
}
</code></pre>
<p>在这个过滤器中，首先从请求头中获取令牌<code>token</code>，然后通过<code>ReactiveRedisService</code>从Redis中查询该令牌对应的用户ID。如果查询到结果，说明令牌有效，继续执行后续的过滤器；如果未查询到结果或令牌不存在，则返回未授权的响应。</p>
<p>这里充分利用了响应式编程的特性，通过<code>flatMap</code>、<code>switchIfEmpty</code>等操作符来处理异步流，保证了整个操作的异步非阻塞性。</p>
<h2 id="四两种场景下redis使用的对比">四、两种场景下Redis使用的对比</h2>
<h3 id="一编程模型">（一）编程模型</h3>
<p>基于Servlet的普通模块采用的是<strong>同步阻塞</strong>的编程模型，使用<code>RedisTemplate</code>进行Redis操作时，方法的调用会阻塞当前线程，直到操作完成。</p>
<p>基于WebFlux的Gateway采用的是<strong>异步非阻塞</strong>的编程模型，使用<code>ReactiveRedisTemplate</code>进行Redis操作时，方法返回<code>Mono</code>或<code>Flux</code>对象，不会阻塞线程，开发者通过订阅这些对象来处理操作结果。</p>
<h3 id="二性能表现">（二）性能表现</h3>
<p>在高并发场景下，基于WebFlux的Gateway使用响应式Redis客户端能够更高效地利用线程资源，减少线程切换的开销，从而表现出更好的性能。</p>
<p>而基于Servlet的普通模块由于采用同步阻塞的方式，在面对大量并发请求时，可能会因为线程阻塞而导致性能瓶颈。</p>
<h3 id="三适用场景">（三）适用场景</h3>
<p>基于Servlet的普通模块的Redis使用方式适用于<strong>业务逻辑相对复杂、对响应时间要求不是特别高</strong>的场景。</p>
<p>基于WebFlux的Gateway的Redis使用方式适用于<strong>高并发、I/O密集型</strong>的场景，如网关的限流、令牌验证等，能够更好地应对大量的并发请求。</p>
<h2 id="五总结">五、总结</h2>
<p>在微服务项目中，基于Servlet的普通模块和基于WebFlux的Gateway在使用Redis时，由于底层技术架构的不同，选择的Redis操作方式也有所差异。</p>
<p>普通模块通过<code>Spring Data Redis</code>的<code>RedisTemplate</code>进行同步操作，简单直观，适合处理复杂的业务逻辑；Gateway则通过<code>spring-boot-starter-data-redis-reactive</code>的<code>ReactiveRedisTemplate</code>进行异步非阻塞操作，能够更好地应对高并发场景。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-13 12:50">2025-08-13 12:50</span>&nbsp;
<a href="https://www.cnblogs.com/Runoob-Yang">Neil·Yang</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19035559);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19035559', targetLink: 'https://www.cnblogs.com/Runoob-Yang/p/19035559', title: '微服务项目中基于 Servlet 的业务模块与 WebFlux 网关模块的 Redis 统一化配置教程' })">举报</a>
</div>
        